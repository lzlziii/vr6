using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using AOT;
using DG.Tweening;
using DG.Tweening.Core;
using DSPLib;
using ExitGames.Client.Photon;
using LIV.SDK.Unity;
using LitJson;
using Microsoft.MixedReality.Toolkit.Rendering;
using Photon.Pun;
using Photon.Pun.UtilityScripts;
using Photon.Realtime;
using Pico.Avatar;
using Pico.Avatar.MiniJSON;
using Pico.Avatar.Postprocess;
using Pico.Avatar.SdkInvokes;
using Pico.Platform;
using Pico.Platform.Models;
using PlayFab;
using PlayFab.ClientModels;
using RangersAppLog.Utility;
using RangersAppLog.Wrapper;
using RenderHeads.Media.AVProVideo;
using RootMotion.FinalIK;
using TMPro;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.XR.PXR;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.InputSystem;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using VRKeyboard.Utils;
using Wacki;
using XCharts.Runtime;
using XftWeapon;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
[Serializable]
[ExecuteInEditMode]
public class BezierCurve : MonoBehaviour
{
	public int resolution = 30;

	public Color drawColor = Color.white;

	[SerializeField]
	private bool _close;

	private float _length;

	[SerializeField]
	public BezierPoint[] points = new BezierPoint[0];

	public bool dirty { get; private set; }

	public bool close
	{
		get
		{
			return _close;
		}
		set
		{
			if (_close != value)
			{
				_close = value;
				dirty = true;
			}
		}
	}

	public BezierPoint this[int index] => points[index];

	public int pointCount => points.Length;

	public float length
	{
		get
		{
			if (dirty)
			{
				_length = 0f;
				for (int i = 0; i < points.Length - 1; i++)
				{
					_length += ApproximateLength(points[i], points[i + 1], resolution);
				}
				if (close)
				{
					_length += ApproximateLength(points[points.Length - 1], points[0], resolution);
				}
				dirty = false;
			}
			return _length;
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = drawColor;
		if (points.Length > 1)
		{
			points = points.Where((BezierPoint x) => x != null).ToArray();
			for (int i = 0; i < points.Length - 1; i++)
			{
				DrawCurve(points[i], points[i + 1], resolution);
			}
			if (close)
			{
				DrawCurve(points[points.Length - 1], points[0], resolution);
			}
		}
	}

	private void Awake()
	{
		dirty = true;
	}

	public void CreateNodeFromBeatPoint(Transform CurveParent, csEditorBeatItem_Point bp)
	{
		List<BezierPoint> list = new List<BezierPoint>();
		bp.thisT.parent = CurveParent;
		BezierPoint bezierPoint = bp.gameObject.GetComponent<BezierPoint>();
		if (bezierPoint == null)
		{
			bezierPoint = bp.gameObject.AddComponent<BezierPoint>();
		}
		list.Add(bezierPoint);
		bezierPoint.curve = this;
		points = list.ToArray();
	}

	public void AddPoint(BezierPoint point)
	{
		List<BezierPoint> list = new List<BezierPoint>(points);
		list.Add(point);
		points = list.ToArray();
		dirty = true;
	}

	public BezierPoint AddPointAt(Vector3 position)
	{
		GameObject obj = new GameObject("Point " + pointCount);
		obj.transform.parent = base.transform;
		obj.transform.position = position;
		BezierPoint bezierPoint = obj.AddComponent<BezierPoint>();
		bezierPoint.curve = this;
		return bezierPoint;
	}

	public void RemovePoint(BezierPoint point)
	{
		List<BezierPoint> list = new List<BezierPoint>(points);
		list.Remove(point);
		points = list.ToArray();
		dirty = false;
	}

	public BezierPoint[] GetAnchorPoints()
	{
		return (BezierPoint[])points.Clone();
	}

	public Vector3 GetPointAt(float t)
	{
		if (t <= 0f)
		{
			return points[0].position;
		}
		if (t >= 1f)
		{
			return points[points.Length - 1].position;
		}
		float num = 0f;
		float num2 = 0f;
		BezierPoint bezierPoint = null;
		BezierPoint p = null;
		for (int i = 0; i < points.Length - 1; i++)
		{
			num2 = ApproximateLength(points[i], points[i + 1]) / length;
			if (num + num2 > t)
			{
				bezierPoint = points[i];
				p = points[i + 1];
				break;
			}
			num += num2;
		}
		if (close && bezierPoint == null)
		{
			bezierPoint = points[points.Length - 1];
			p = points[0];
		}
		t -= num;
		return GetPoint(bezierPoint, p, t / num2);
	}

	public int GetPointIndex(BezierPoint point)
	{
		int result = -1;
		for (int i = 0; i < points.Length; i++)
		{
			if (points[i] == point)
			{
				result = i;
				break;
			}
		}
		return result;
	}

	public void SetDirty()
	{
		dirty = true;
	}

	public static void DrawCurve(BezierPoint p1, BezierPoint p2, int resolution)
	{
		int num = resolution + 1;
		float num2 = resolution;
		Vector3 from = p1.position;
		Vector3 zero = Vector3.zero;
		for (int i = 1; i < num; i++)
		{
			zero = GetPoint(p1, p2, (float)i / num2);
			Gizmos.DrawLine(from, zero);
			from = zero;
		}
	}

	public static Vector3 GetPoint(BezierPoint p1, BezierPoint p2, float t)
	{
		if (p1.handle2 != Vector3.zero)
		{
			if (p2.handle1 != Vector3.zero)
			{
				return GetCubicCurvePoint(p1.position, p1.globalHandle2, p2.globalHandle1, p2.position, t);
			}
			return GetQuadraticCurvePoint(p1.position, p1.globalHandle2, p2.position, t);
		}
		if (p2.handle1 != Vector3.zero)
		{
			return GetQuadraticCurvePoint(p1.position, p2.globalHandle1, p2.position, t);
		}
		return GetLinearPoint(p1.position, p2.position, t);
	}

	public static Vector3 GetCubicCurvePoint(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float t)
	{
		t = Mathf.Clamp01(t);
		Vector3 vector = Mathf.Pow(1f - t, 3f) * p1;
		Vector3 vector2 = 3f * Mathf.Pow(1f - t, 2f) * t * p2;
		Vector3 vector3 = 3f * (1f - t) * Mathf.Pow(t, 2f) * p3;
		Vector3 vector4 = Mathf.Pow(t, 3f) * p4;
		return vector + vector2 + vector3 + vector4;
	}

	public static Vector3 GetQuadraticCurvePoint(Vector3 p1, Vector3 p2, Vector3 p3, float t)
	{
		t = Mathf.Clamp01(t);
		Vector3 vector = Mathf.Pow(1f - t, 2f) * p1;
		Vector3 vector2 = 2f * (1f - t) * t * p2;
		Vector3 vector3 = Mathf.Pow(t, 2f) * p3;
		return vector + vector2 + vector3;
	}

	public static Vector3 GetLinearPoint(Vector3 p1, Vector3 p2, float t)
	{
		return p1 + (p2 - p1) * t;
	}

	public static Vector3 GetPoint(float t, params Vector3[] points)
	{
		t = Mathf.Clamp01(t);
		int num = points.Length - 1;
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < points.Length; i++)
		{
			Vector3 vector = points[points.Length - i - 1] * ((float)BinomialCoefficient(i, num) * Mathf.Pow(t, num - i) * Mathf.Pow(1f - t, i));
			zero += vector;
		}
		return zero;
	}

	public static float ApproximateLength(BezierPoint p1, BezierPoint p2, int resolution = 10)
	{
		float num = resolution;
		float num2 = 0f;
		Vector3 vector = p1.position;
		for (int i = 0; i < resolution + 1; i++)
		{
			Vector3 point = GetPoint(p1, p2, (float)i / num);
			num2 += (point - vector).magnitude;
			vector = point;
		}
		return num2;
	}

	private static int BinomialCoefficient(int i, int n)
	{
		return Factoral(n) / (Factoral(i) * Factoral(n - i));
	}

	private static int Factoral(int i)
	{
		if (i == 0)
		{
			return 1;
		}
		int num = 1;
		while (i - 1 >= 0)
		{
			num *= i;
			i--;
		}
		return num;
	}
}
[Serializable]
public class BezierPoint : MonoBehaviour
{
	public enum HandleStyle
	{
		Connected,
		Broken,
		None
	}

	[SerializeField]
	private BezierCurve _curve;

	public HandleStyle handleStyle;

	[SerializeField]
	private Vector3 _handle1;

	[SerializeField]
	private Vector3 _handle2;

	private Vector3 lastPosition;

	public BezierCurve curve
	{
		get
		{
			return _curve;
		}
		set
		{
			if ((bool)_curve)
			{
				_curve.RemovePoint(this);
			}
			_curve = value;
			_curve.AddPoint(this);
		}
	}

	public Vector3 position
	{
		get
		{
			return base.transform.position;
		}
		set
		{
			base.transform.position = value;
		}
	}

	public Vector3 localPosition
	{
		get
		{
			return base.transform.localPosition;
		}
		set
		{
			base.transform.localPosition = value;
		}
	}

	public Vector3 handle1
	{
		get
		{
			return _handle1;
		}
		set
		{
			if (!(_handle1 == value))
			{
				_handle1 = value;
				if (handleStyle == HandleStyle.None)
				{
					handleStyle = HandleStyle.Broken;
				}
				else if (handleStyle == HandleStyle.Connected)
				{
					_handle2 = -value;
				}
				_curve.SetDirty();
			}
		}
	}

	public Vector3 globalHandle1
	{
		get
		{
			return base.transform.TransformPoint(handle1);
		}
		set
		{
			handle1 = base.transform.InverseTransformPoint(value);
		}
	}

	public Vector3 handle2
	{
		get
		{
			return _handle2;
		}
		set
		{
			if (!(_handle2 == value))
			{
				_handle2 = value;
				if (handleStyle == HandleStyle.None)
				{
					handleStyle = HandleStyle.Broken;
				}
				else if (handleStyle == HandleStyle.Connected)
				{
					_handle1 = -value;
				}
				_curve.SetDirty();
			}
		}
	}

	public Vector3 globalHandle2
	{
		get
		{
			return base.transform.TransformPoint(handle2);
		}
		set
		{
			handle2 = base.transform.InverseTransformPoint(value);
		}
	}

	private void Update()
	{
		if (!_curve.dirty && base.transform.position != lastPosition)
		{
			_curve.SetDirty();
			lastPosition = base.transform.position;
		}
	}
}
public class CheckAsset : MonoBehaviour
{
	public GameObject meshToCheck;

	public AnimationClip animationToUse;

	private Mesh testMesh;

	private Material testMaterial;

	private GameObject boneMesh;

	private SkinnedMeshRenderer boneRenderer;

	private SkinnedMeshRenderer[] checkRenderer;

	private Animation anim;

	private Dictionary<int, string> boneIndex2Name = new Dictionary<int, string>();

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(meshToCheck, base.transform.position, base.transform.rotation, base.transform);
		anim = gameObject.AddComponent<Animation>();
	}

	private void BuildIndex2Name(SkinnedMeshRenderer inRenderer)
	{
	}

	private void CreateMeshRenderer(Mesh inMesh)
	{
		GameObject obj = new GameObject();
		obj.transform.parent = base.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = Quaternion.identity;
		SkinnedMeshRenderer skinnedMeshRenderer = obj.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = inMesh;
		Transform transform = base.transform.Find("test01(Clone)/ROOT/All/RIG");
		skinnedMeshRenderer.rootBone = transform.transform;
		skinnedMeshRenderer.bones = boneRenderer.bones;
		skinnedMeshRenderer.material = new Material(Shader.Find("Diffuse"));
		skinnedMeshRenderer.material = testMaterial;
		Matrix4x4[] array = new Matrix4x4[skinnedMeshRenderer.bones.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = skinnedMeshRenderer.bones[i].worldToLocalMatrix * base.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.sharedMesh.bindposes = array;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			PlayAnimaiton();
		}
	}

	private void PlayAnimaiton()
	{
		anim.clip = animationToUse;
		anim.AddClip(animationToUse, "test");
		anim.Play("test");
	}
}
[ExecuteInEditMode]
public class EffectsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private float oldScale;

	private void Start()
	{
		oldScale = particlesScale;
	}

	private void Update()
	{
	}
}
public class SoundPlayTime : MonoBehaviour
{
	public bool playOnAwake;

	public bool loopCheck;

	private float timer;

	public float waitTime = 1f;

	private float loopTime;

	public float loopWaitTime;

	private bool flag;

	public AudioClip sound01;

	private AudioSource audioSource;

	private void Start()
	{
		loopTime = loopWaitTime;
		audioSource = GetComponent<AudioSource>();
		audioSource.playOnAwake = playOnAwake;
		if (audioSource.playOnAwake)
		{
			audioSource.clip = sound01;
			audioSource.Play();
			if (!loopCheck)
			{
				UnityEngine.Object.Destroy(this);
			}
		}
		else
		{
			loopTime = 0f;
		}
	}

	private void Update()
	{
		loopTime -= Time.deltaTime;
		timer += Time.deltaTime;
		if (timer >= waitTime && !flag && loopTime <= 0f)
		{
			audioSource.clip = sound01;
			audioSource.Play();
			flag = false;
			loopTime = loopWaitTime;
			if (!loopCheck)
			{
				UnityEngine.Object.Destroy(this);
			}
		}
	}
}
public class FlareRotate : MonoBehaviour
{
	public float speed;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	private void Update()
	{
		thisT.Rotate(0f, 1f * speed, 0f);
	}
}
public class XWeaponTrailDemo : MonoBehaviour
{
	public Animation SwordAnimation;

	public XWeaponTrail ProTrailDistort;

	public XWeaponTrail ProTrailShort;

	public XWeaponTrail ProTraillong;

	public XWeaponTrail SimpleTrail;

	public void Start()
	{
		ProTrailDistort.Init();
		ProTrailShort.Init();
		ProTraillong.Init();
		SimpleTrail.Init();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("测试"))
		{
			SwordAnimation.Play();
		}
		if (GUI.Button(new Rect(0f, 0f, 150f, 30f), "Activate Trail1"))
		{
			ProTrailDistort.Deactivate();
			ProTrailShort.Deactivate();
			ProTraillong.Deactivate();
			SwordAnimation.Play();
			SimpleTrail.Activate();
		}
		if (GUI.Button(new Rect(0f, 30f, 150f, 30f), "Stop Trail1"))
		{
			SimpleTrail.Deactivate();
		}
		if (GUI.Button(new Rect(0f, 60f, 150f, 30f), "Stop Trail1 Smoothly"))
		{
			SimpleTrail.StopSmoothly(0.3f);
		}
		if (GUI.Button(new Rect(0f, 120f, 150f, 30f), "Activate Trail2"))
		{
			SimpleTrail.Deactivate();
			SwordAnimation.Play();
			ProTrailDistort.Activate();
			ProTrailShort.Activate();
			ProTraillong.Activate();
		}
		if (GUI.Button(new Rect(0f, 150f, 150f, 30f), "Stop Trail2"))
		{
			ProTrailDistort.Deactivate();
			ProTrailShort.Deactivate();
			ProTraillong.Deactivate();
		}
		if (GUI.Button(new Rect(0f, 180f, 150f, 30f), "Stop Trail2 Smoothly"))
		{
			ProTrailDistort.StopSmoothly(0.3f);
			ProTrailShort.StopSmoothly(0.3f);
			ProTraillong.StopSmoothly(0.3f);
		}
	}
}
public class AutoDestroyPS : MonoBehaviour
{
	private float timeLeft;

	private void Awake()
	{
		ParticleSystem.MainModule main = GetComponent<ParticleSystem>().main;
		timeLeft = main.startLifetimeMultiplier + main.duration;
		UnityEngine.Object.Destroy(base.gameObject, timeLeft);
	}
}
public class ComboDEMO : MonoBehaviour
{
	public Animation anim;

	public TextMeshProUGUI comboText;

	public TextMeshProUGUI comboText2;

	private bool oneTime;

	private float timeRec;

	public csRanEffect ranEffect;

	public float comboIndex;

	private Color ring2Color;

	private IEnumerator Start()
	{
		anim.Play("show");
		yield return new WaitForSeconds(1f);
		while (true)
		{
			yield return new WaitForFixedUpdate();
			if (Check5xCombo() == 1)
			{
				oneTime = true;
				anim.Play("1combo");
				timeRec = Time.time;
				ranEffect.SetColor(csBeatItemColor.LBlack);
			}
			if (Check5xCombo() == 2)
			{
				oneTime = true;
				anim.Play("100combo");
				timeRec = Time.time;
				ranEffect.SetColor(csBeatItemColor.LBlack);
			}
			if (Time.time > timeRec + 2f && oneTime)
			{
				oneTime = false;
				anim.Play();
			}
			comboText.text = ((int)comboIndex).ToString();
			comboIndex += 10f * Time.deltaTime;
		}
	}

	private int Check5xCombo()
	{
		if ((int)comboIndex % 20 == 0 && (int)comboIndex < 100 && (int)comboIndex > 0)
		{
			return 1;
		}
		if ((int)comboIndex % 20 == 0 && (int)comboIndex >= 100)
		{
			return 2;
		}
		return 0;
	}

	private bool CheckBigCombo()
	{
		int num = (int)comboIndex;
		if (num == 50 || num == 100 || num == 200 || num == 300 || num == 400)
		{
			return true;
		}
		return false;
	}
}
public class MouseOrbit : MonoBehaviour
{
	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float scrollSpeed = 1f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	public float smoothTime = 2f;

	private float rotationYAxis;

	private float rotationXAxis;

	private float velocityX;

	private float velocityY;

	private bool start = true;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		rotationYAxis = eulerAngles.y;
		rotationXAxis = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (!target)
		{
			return;
		}
		if (Input.GetMouseButton(1))
		{
			start = false;
			velocityX += xSpeed * Input.GetAxis("Mouse X") * 0.02f;
			velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
		}
		if (!start)
		{
			rotationYAxis += velocityX;
			rotationXAxis -= velocityY;
			rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			Vector3 position = quaternion * vector + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
			velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
			velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			float axis = Input.GetAxis("Mouse ScrollWheel");
			if (axis < 0f && distance < distanceMax)
			{
				distance += scrollSpeed;
			}
			else if (axis > 0f && distance > distanceMin)
			{
				distance -= scrollSpeed;
			}
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class Rotater : MonoBehaviour
{
	public float Speed;

	private void Update()
	{
		base.transform.Rotate(0f, 1f * Speed, 0f, Space.Self);
	}
}
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(UnderWaterFog))]
[ExecuteInEditMode]
public class FogControl : MonoBehaviour
{
	public float FadeSpeed = 10f;

	private float Rate = 1f;

	private UnderWaterFog fog;

	private Camera cam;

	private void OnEnable()
	{
		init();
	}

	private void Start()
	{
		init();
	}

	private void Update()
	{
		Rate += Time.deltaTime / FadeSpeed;
		Rate = Mathf.Clamp(Rate, 0f, FadeSpeed);
		if (cam.transform.position.y <= fog.height)
		{
			if (!fog.enabled)
			{
				fog.enabled = true;
			}
			fog.fogColor.a = Mathf.Lerp(fog.fogColor.a, 1f, Rate);
		}
		else
		{
			fog.fogColor.a = Mathf.Lerp(fog.fogColor.a, 0f, Rate * 2f);
			if (fog.fogColor.a <= 0.01f)
			{
				fog.enabled = false;
			}
		}
	}

	private void init()
	{
		if (cam == null)
		{
			cam = GetComponent<Camera>();
		}
		if (fog == null)
		{
			fog = GetComponent<UnderWaterFog>();
		}
		if (cam.transform.position.y >= fog.height)
		{
			fog.fogColor.a = 0f;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Rendering/UnderWater Fog")]
public class UnderWaterFog : MonoBehaviour
{
	public Color fogColor = Color.white;

	[Tooltip("Fog top Y coordinate")]
	public float height = 1f;

	[Range(0.001f, 10f)]
	public float heightDensity = 2f;

	[Tooltip("Push fog away from the camera by this amount")]
	public float startDistance;

	public Shader fogShader;

	private Material fogMaterial;

	private void OnEnable()
	{
		CheckResources();
	}

	public bool CheckResources()
	{
		if (fogShader == null)
		{
			fogShader = Shader.Find("Hidden/UnderWaterFog");
		}
		if (fogMaterial == null)
		{
			fogMaterial = new Material(fogShader);
		}
		bool result = true;
		if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			return false;
		}
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
		return result;
	}

	[ImageEffectOpaque]
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!CheckResources())
		{
			Graphics.Blit(source, destination);
			return;
		}
		Camera component = GetComponent<Camera>();
		Transform transform = component.transform;
		float nearClipPlane = component.nearClipPlane;
		float farClipPlane = component.farClipPlane;
		float fieldOfView = component.fieldOfView;
		float aspect = component.aspect;
		Matrix4x4 identity = Matrix4x4.identity;
		float num = fieldOfView * 0.5f;
		Vector3 vector = transform.right * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f)) * aspect;
		Vector3 vector2 = transform.up * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f));
		Vector3 vector3 = transform.forward * nearClipPlane - vector + vector2;
		float num2 = vector3.magnitude * farClipPlane / nearClipPlane;
		vector3.Normalize();
		vector3 *= num2;
		Vector3 vector4 = transform.forward * nearClipPlane + vector + vector2;
		vector4.Normalize();
		vector4 *= num2;
		Vector3 vector5 = transform.forward * nearClipPlane + vector - vector2;
		vector5.Normalize();
		vector5 *= num2;
		Vector3 vector6 = transform.forward * nearClipPlane - vector - vector2;
		vector6.Normalize();
		vector6 *= num2;
		identity.SetRow(0, vector3);
		identity.SetRow(1, vector4);
		identity.SetRow(2, vector5);
		identity.SetRow(3, vector6);
		Vector3 position = transform.position;
		float num3 = position.y - height;
		float z = ((num3 <= 0f) ? 1f : 0f);
		fogMaterial.SetColor("_Color", fogColor);
		fogMaterial.SetMatrix("_FrustumCornersWS", identity);
		fogMaterial.SetVector("_CameraWS", position);
		fogMaterial.SetVector("_HeightParams", new Vector4(height, num3, z, heightDensity * 0.5f));
		fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), 1f, 0f, 0f));
		FogMode fogMode = RenderSettings.fogMode;
		float num4 = heightDensity;
		float fogStartDistance = RenderSettings.fogStartDistance;
		float fogEndDistance = RenderSettings.fogEndDistance;
		bool flag = fogMode == FogMode.Linear;
		float num5 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
		float num6 = ((Mathf.Abs(num5) > 0.0001f) ? (1f / num5) : 0f);
		Vector4 value = default(Vector4);
		value.x = num4 * 1.2011224f;
		value.y = num4 * 1.442695f;
		value.z = (flag ? (0f - num6) : 0f);
		value.w = (flag ? (fogEndDistance * num6) : 0f);
		fogMaterial.SetVector("_SceneFogParams", value);
		fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, 0f, 0f, 0f));
		CustomGraphicsBlit(source, destination, fogMaterial, 0);
	}

	private static void CustomGraphicsBlit(RenderTexture source, RenderTexture dest, Material fxMaterial, int passNr)
	{
		RenderTexture.active = dest;
		fxMaterial.SetTexture("_MainTex", source);
		GL.PushMatrix();
		GL.LoadOrtho();
		fxMaterial.SetPass(passNr);
		GL.Begin(7);
		GL.MultiTexCoord2(0, 0f, 0f);
		GL.Vertex3(0f, 0f, 3f);
		GL.MultiTexCoord2(0, 1f, 0f);
		GL.Vertex3(1f, 0f, 2f);
		GL.MultiTexCoord2(0, 1f, 1f);
		GL.Vertex3(1f, 1f, 1f);
		GL.MultiTexCoord2(0, 0f, 1f);
		GL.Vertex3(0f, 1f, 0f);
		GL.End();
		GL.PopMatrix();
	}
}
public class FlyCamera : MonoBehaviour
{
	public float speed = 12f;

	public float gravity;

	private Vector3 moveDirection = Vector3.zero;

	public bool Flyfaster;

	private float actspeed;

	private void FixedUpdate()
	{
		Flyfaster = false;
		if (Input.GetKey(KeyCode.LeftShift))
		{
			Flyfaster = true;
		}
		if (Flyfaster)
		{
			actspeed = 2.5f * speed;
		}
		else
		{
			actspeed = speed;
		}
		if (Input.GetKeyDown(KeyCode.PageUp))
		{
			speed += 1f;
		}
		if (Input.GetKeyDown(KeyCode.PageDown))
		{
			speed -= 1f;
		}
		if (Input.GetKey(KeyCode.Q))
		{
			base.transform.Translate(new Vector3(0f, 0.8f, 0f) * actspeed * Time.deltaTime, Space.World);
		}
		if (Input.GetKey(KeyCode.E))
		{
			base.transform.Translate(new Vector3(0f, -0.8f, 0f) * actspeed * Time.deltaTime, Space.World);
		}
		moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
		moveDirection = base.transform.TransformDirection(moveDirection);
		moveDirection *= actspeed;
		moveDirection.y -= gravity * Time.deltaTime;
		base.transform.Translate(moveDirection * Time.deltaTime, Space.World);
	}
}
public class MouseSwitcher : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetKey(KeyCode.Mouse0))
		{
			GetComponent<uMouseLook>().enabled = true;
		}
		else
		{
			GetComponent<uMouseLook>().enabled = false;
		}
	}
}
[AddComponentMenu("Camera-Control/uMouse Look")]
public class uMouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	public float rotationX;

	public float rotationY;

	private Quaternion originalRotation;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion * quaternion2;
		}
		else if (axes == RotationAxes.MouseX)
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			Quaternion quaternion3 = Quaternion.AngleAxis(rotationX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion3;
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			Quaternion quaternion4 = Quaternion.AngleAxis(rotationY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion4;
		}
	}

	private void OnEnable()
	{
		Vector3 euler = new Vector3(0f, 0f, base.transform.localEulerAngles.z);
		originalRotation = Quaternion.Euler(euler);
		rotationY = 0f - base.transform.localEulerAngles.x;
		rotationX = base.transform.localEulerAngles.y;
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
		Vector3 euler = new Vector3(0f, 0f, base.transform.localEulerAngles.z);
		originalRotation = Quaternion.Euler(euler);
		rotationY = 0f - base.transform.localEulerAngles.x;
		rotationX = base.transform.localEulerAngles.y;
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class csTestTriangle : MonoBehaviour
{
	public Transform[] items;

	public float moveSpeed = 2f;

	public int index;

	private float currentStd = 1f;

	private float currentHeight = 1.7f;

	private string getStd = "";

	private void Awake()
	{
		SetPos();
	}

	private void SetPos()
	{
		for (int i = 0; i < items.Length; i++)
		{
			items[i].position = new Vector3(0f, 0f, 20f);
		}
	}

	private IEnumerator Start()
	{
		while (true)
		{
			yield return new WaitForFixedUpdate();
			items[index].transform.position -= Vector3.forward * moveSpeed;
			if (items[index].transform.position.z < -1f)
			{
				index++;
				UnityEngine.Debug.Log(index);
				if (index > items.Length - 1)
				{
					index = 0;
					SetPos();
				}
			}
		}
	}

	private void setStd(float height, float std)
	{
		Vector3 localScale = Vector3.one * height / 1.7f * std;
		localScale.z = 1f;
		for (int i = 0; i < items.Length; i++)
		{
			items[i].localScale = localScale;
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(20f, 50f, 300f, 35f), "当前标准:" + currentStd + ",当前身高:" + currentHeight);
		getStd = GUI.TextField(new Rect(20f, 85f, 150f, 20f), getStd);
		if (GUI.Button(new Rect(20f, 110f, 150f, 20f), "设置标准"))
		{
			currentStd = float.Parse(getStd);
			setStd(currentHeight, currentStd);
		}
		if (GUI.Button(new Rect(20f, 140f, 150f, 20f), "设置身高"))
		{
			currentHeight = float.Parse(getStd);
			setStd(currentHeight, currentStd);
		}
	}
}
public class anim : MonoBehaviour
{
	private float DEFAULT_POWER = 0.8f;

	private float MIN_TIME = 3.5f;

	private float MAX_TIME = 4.5f;

	private MaterialPropertyBlock prop_;

	private float default_;

	private float a_;

	private void Start()
	{
		prop_ = new MaterialPropertyBlock();
		a_ = DEFAULT_POWER;
	}

	private void Update()
	{
		if (Time.time >= MIN_TIME && Time.time <= MAX_TIME)
		{
			float num = DEFAULT_POWER / (MAX_TIME - MIN_TIME);
			float num2 = Time.time - MIN_TIME;
			a_ -= num * num2;
		}
		prop_.Clear();
		prop_.SetFloat("_EdgePower", a_);
		base.gameObject.GetComponent<Renderer>().SetPropertyBlock(prop_);
	}
}
[RequireComponent(typeof(AudioSource))]
public class AudioProcessor : MonoBehaviour
{
	[Serializable]
	public class OnBeatEventHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnSpectrumEventHandler : UnityEvent<float[]>
	{
	}

	private class Autoco
	{
		private int del_length;

		private float decay;

		private float[] delays;

		private float[] outputs;

		private int indx;

		private float[] bpms;

		private float[] rweight;

		private float wmidbpm = 120f;

		private float woctavewidth;

		public Autoco(int len, float alpha, float framePeriod, float bandwidth)
		{
			woctavewidth = bandwidth;
			decay = alpha;
			del_length = len;
			delays = new float[del_length];
			outputs = new float[del_length];
			indx = 0;
			bpms = new float[del_length];
			rweight = new float[del_length];
			for (int i = 0; i < del_length; i++)
			{
				bpms[i] = 60f / (framePeriod * (float)i);
				rweight[i] = (float)Math.Exp(-0.5 * Math.Pow(Math.Log(bpms[i] / wmidbpm) / Math.Log(2.0) / (double)woctavewidth, 2.0));
			}
		}

		public void newVal(float val)
		{
			delays[indx] = val;
			for (int i = 0; i < del_length; i++)
			{
				int num = (indx - i + del_length) % del_length;
				outputs[i] += (1f - decay) * (delays[indx] * delays[num] - outputs[i]);
			}
			if (++indx == del_length)
			{
				indx = 0;
			}
		}

		public float autoco(int del)
		{
			return rweight[del] * outputs[del];
		}

		public float avgBpm()
		{
			float num = 0f;
			for (int i = 0; i < bpms.Length; i++)
			{
				num += bpms[i];
			}
			return num / (float)del_length;
		}
	}

	public AudioSource audioSource;

	private long lastT;

	private long nowT;

	private long diff;

	private long entries;

	private long sum;

	public int bufferSize = 1024;

	private int samplingRate = 44100;

	private int nBand = 12;

	public float gThresh = 0.1f;

	private int blipDelayLen = 16;

	private int[] blipDelay;

	private int sinceLast;

	private float framePeriod;

	private int colmax = 120;

	private float[] spectrum;

	private float[] averages;

	private float[] acVals;

	private float[] onsets;

	private float[] scorefun;

	private float[] dobeat;

	private int now;

	private float[] spec;

	private int maxlag = 100;

	private float decay = 0.997f;

	private Autoco auco;

	private float alph;

	[Header("Events")]
	public OnBeatEventHandler onBeat;

	public OnSpectrumEventHandler onSpectrum;

	private long getCurrentTimeMillis()
	{
		return DateTime.Now.Ticks / 10000;
	}

	private void initArrays()
	{
		blipDelay = new int[blipDelayLen];
		onsets = new float[colmax];
		scorefun = new float[colmax];
		dobeat = new float[colmax];
		spectrum = new float[bufferSize];
		averages = new float[12];
		acVals = new float[maxlag];
		alph = 100f * gThresh;
	}

	private void Start()
	{
		initArrays();
		audioSource = GetComponent<AudioSource>();
		samplingRate = audioSource.clip.frequency;
		framePeriod = (float)bufferSize / (float)samplingRate;
		spec = new float[nBand];
		for (int i = 0; i < nBand; i++)
		{
			spec[i] = 100f;
		}
		auco = new Autoco(maxlag, decay, framePeriod, getBandWidth());
		lastT = getCurrentTimeMillis();
	}

	public void tapTempo()
	{
		nowT = getCurrentTimeMillis();
		diff = nowT - lastT;
		lastT = nowT;
		sum += diff;
		entries++;
		UnityEngine.Debug.Log("average = " + (int)(sum / entries));
	}

	private double[] toDoubleArray(float[] arr)
	{
		if (arr == null)
		{
			return null;
		}
		int num = arr.Length;
		double[] array = new double[num];
		for (int i = 0; i < num; i++)
		{
			array[i] = arr[i];
		}
		return array;
	}

	private void Update()
	{
		if (!audioSource.isPlaying)
		{
			return;
		}
		audioSource.GetSpectrumData(spectrum, 0, FFTWindow.BlackmanHarris);
		computeAverages(spectrum);
		onSpectrum.Invoke(averages);
		float num = 0f;
		for (int i = 0; i < nBand; i++)
		{
			float num2 = Math.Max(-100f, 20f * (float)Math.Log10(averages[i]) + 160f);
			num2 *= 0.025f;
			float num3 = num2 - spec[i];
			spec[i] = num2;
			num += num3;
		}
		onsets[now] = num;
		auco.newVal(num);
		float num4 = 0f;
		int num5 = 0;
		for (int j = 0; j < maxlag; j++)
		{
			float num6 = (float)Math.Sqrt(auco.autoco(j));
			if (num6 > num4)
			{
				num4 = num6;
				num5 = j;
			}
			acVals[maxlag - 1 - j] = num6;
		}
		float num7 = -999999f;
		int num8 = 0;
		alph = 100f * gThresh;
		for (int k = num5 / 2; k < Math.Min(colmax, 2 * num5); k++)
		{
			float num9 = num + scorefun[(now - k + colmax) % colmax] - alph * (float)Math.Pow(Math.Log((float)k / (float)num5), 2.0);
			if (num9 > num7)
			{
				num7 = num9;
				num8 = k;
			}
		}
		scorefun[now] = num7;
		float num10 = scorefun[0];
		for (int l = 0; l < colmax; l++)
		{
			if (scorefun[l] < num10)
			{
				num10 = scorefun[l];
			}
		}
		for (int m = 0; m < colmax; m++)
		{
			scorefun[m] -= num10;
		}
		num7 = scorefun[0];
		num8 = 0;
		for (int n = 0; n < colmax; n++)
		{
			if (scorefun[n] > num7)
			{
				num7 = scorefun[n];
				num8 = n;
			}
		}
		dobeat[now] = 0f;
		sinceLast++;
		if (num8 == now && sinceLast > num5 / 4)
		{
			onBeat.Invoke();
			blipDelay[0] = 1;
			dobeat[now] = 1f;
			sinceLast = 0;
		}
		if (++now == colmax)
		{
			now = 0;
		}
	}

	public void changeCameraColor()
	{
		float r = UnityEngine.Random.Range(0f, 1f);
		float g = UnityEngine.Random.Range(0f, 1f);
		float b = UnityEngine.Random.Range(0f, 1f);
		Color backgroundColor = new Color(r, g, b);
		GetComponent<Camera>().clearFlags = CameraClearFlags.Color;
		Camera.main.backgroundColor = backgroundColor;
	}

	public float getBandWidth()
	{
		return 2f / (float)bufferSize * ((float)samplingRate / 2f);
	}

	public int freqToIndex(int freq)
	{
		if ((float)freq < getBandWidth() / 2f)
		{
			return 0;
		}
		if ((float)freq > (float)(samplingRate / 2) - getBandWidth() / 2f)
		{
			return bufferSize / 2;
		}
		float num = (float)freq / (float)samplingRate;
		return (int)Math.Round((float)bufferSize * num);
	}

	public void computeAverages(float[] data)
	{
		for (int i = 0; i < 12; i++)
		{
			float num = 0f;
			int freq = ((i != 0) ? ((int)((float)(samplingRate / 2) / (float)Math.Pow(2.0, 12 - i))) : 0);
			int freq2 = (int)((float)(samplingRate / 2) / (float)Math.Pow(2.0, 11 - i));
			int num2 = freqToIndex(freq);
			int num3 = freqToIndex(freq2);
			for (int j = num2; j <= num3; j++)
			{
				num += data[j];
			}
			num /= (float)(num3 - num2 + 1);
			averages[i] = num;
		}
	}

	private float map(float s, float a1, float a2, float b1, float b2)
	{
		return b1 + (s - a1) * (b2 - b1) / (a2 - a1);
	}

	public float constrain(float value, float inclusiveMinimum, float inlusiveMaximum)
	{
		if (value >= inclusiveMinimum)
		{
			if (value <= inlusiveMaximum)
			{
				return value;
			}
			return inlusiveMaximum;
		}
		return inclusiveMinimum;
	}
}
public class BeatDetection : MonoBehaviour
{
	public enum beatmode
	{
		Energy,
		Frequency,
		Both
	}

	public enum beatType
	{
		None = 0,
		kick = 1,
		snare = 2,
		hithat = 4,
		energy = 8
	}

	public enum EventType
	{
		Energy,
		Kick,
		Snare,
		HitHat
	}

	public class EventInfo
	{
		public EventType messageInfo;

		public BeatDetection sender;
	}

	public delegate void CallbackEventHandler(EventInfo eventInfo);

	public beatmode beatMode;

	public CallbackEventHandler CallBackFunction;

	private int numSamples = 1024;

	private int minFrequency = 60;

	private const int MAX_FRQSEC = 50;

	private const int LINEAR_OCTAVE_DIVISIONS = 3;

	private const int HISTORY_LENGTH = 43;

	private const int MAX_HISTORY = 500;

	private const float MIN_BEAT_SEPARATION = 0.05f;

	private int numHistory;

	private int circularHistory;

	private float[] energyHistory = new float[500];

	private float[] mediasHistory = new float[500];

	private float[,] freqHistory = new float[50, 500];

	private float[,] medHistory = new float[50, 500];

	private float[] averages = new float[50];

	private bool[] detectados = new bool[50];

	private int acumula;

	private float[] estad1 = new float[50];

	private float[] estad2 = new float[50];

	private float sampleRate;

	private int avgPerOctave;

	private int octaves;

	private int totalBfLen;

	private int historyLength;

	private int sampleRange;

	private float tIni;

	private float[] tIniF = new float[50];

	private int kg;

	private float[] spectrum0;

	private float[] spectrum1;

	private float[] frames0;

	private float[] frames1;

	private void Update()
	{
		int num = isBeat();
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			SendEvent(EventType.Kick);
		}
		if (((uint)num & 2u) != 0)
		{
			SendEvent(EventType.Snare);
		}
		if (((uint)num & 4u) != 0)
		{
			SendEvent(EventType.HitHat);
		}
		if (((uint)num & 8u) != 0)
		{
			SendEvent(EventType.Energy);
		}
	}

	private void SendEvent(EventType theEvent)
	{
		if (CallBackFunction != null)
		{
			EventInfo eventInfo = new EventInfo();
			eventInfo.sender = this;
			eventInfo.messageInfo = theEvent;
			CallBackFunction(eventInfo);
		}
	}

	private void Start()
	{
		spectrum0 = new float[numSamples];
		spectrum1 = new float[numSamples];
		frames0 = new float[numSamples];
		frames1 = new float[numSamples];
		setUpEnergy();
		setUpFrequency();
		tIni = Time.time;
		for (int i = 0; i < 50; i++)
		{
			tIniF[i] = Time.time;
		}
	}

	private int isBeat()
	{
		GetComponent<AudioSource>().GetSpectrumData(spectrum0, 0, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetSpectrumData(spectrum1, 1, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetOutputData(frames0, 0);
		GetComponent<AudioSource>().GetOutputData(frames1, 1);
		beatType beatType = beatType.None;
		switch (beatMode)
		{
		case beatmode.Energy:
			if (isBeatEnergy())
			{
				return 8;
			}
			break;
		case beatmode.Frequency:
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat());
		case beatmode.Both:
			if (isBeatEnergy())
			{
				beatType = beatType.energy;
			}
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat() | beatType);
		}
		return 0;
	}

	private void initDetector()
	{
		numHistory = 0;
		circularHistory = 0;
		for (int i = 0; i < 500; i++)
		{
			energyHistory[i] = 0f;
			mediasHistory[i] = 0f;
		}
		acumula = 0;
		historyLength = 0;
	}

	private void setUpEnergy()
	{
		sampleRate = AudioSettings.outputSampleRate;
		sampleRange = numSamples;
		historyLength = 43;
		numHistory = 0;
		circularHistory = 0;
	}

	private void setUpFrequency()
	{
		sampleRange = numSamples;
		historyLength = 43;
		sampleRate = AudioSettings.outputSampleRate;
		numHistory = 0;
		circularHistory = 0;
		float num = sampleRate / 2f;
		octaves = 1;
		while ((num /= 2f) > (float)minFrequency)
		{
			octaves++;
		}
		avgPerOctave = 3;
		totalBfLen = octaves * avgPerOctave;
		for (int i = 0; i < totalBfLen; i++)
		{
			for (int j = 0; j < historyLength; j++)
			{
				freqHistory[i, j] = 0f;
				medHistory[i, j] = 0f;
			}
		}
	}

	private bool isBeatEnergy()
	{
		float num = 0f;
		for (int i = 0; i < sampleRange; i++)
		{
			num += frames0[i] * frames0[i] + frames1[i] * frames1[i];
		}
		num /= (float)sampleRange;
		float num2 = Mathf.Sqrt(num) * 100f;
		float num3 = 0f;
		for (int j = 0; j < numHistory; j++)
		{
			num3 += energyHistory[j];
		}
		if (numHistory > 0)
		{
			num3 /= (float)numHistory;
		}
		float num4 = 0f;
		for (int k = 0; k < numHistory; k++)
		{
			num4 += (energyHistory[k] - num3) * (energyHistory[k] - num3);
		}
		if (numHistory > 0)
		{
			num4 /= (float)numHistory;
		}
		float num5 = -0.0025714f * num4 + 1.5142857f;
		float num6 = Mathf.Max(num2 - num5 * num3, 0f);
		float num7 = 0f;
		int num8 = 0;
		for (int l = 0; l < numHistory; l++)
		{
			if (mediasHistory[l] > 0f)
			{
				num7 += mediasHistory[l];
				num8++;
			}
		}
		if (num8 > 0)
		{
			num7 /= (float)num8;
		}
		float num9 = Mathf.Max(num6 - num7, 0f);
		bool result;
		if (Time.time - tIni < 0.05f)
		{
			result = false;
		}
		else if ((double)num9 > 0.0 && (double)num2 > 2.0)
		{
			result = true;
			tIni = Time.time;
		}
		else
		{
			result = false;
		}
		numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
		energyHistory[circularHistory] = num2;
		mediasHistory[circularHistory] = num6;
		circularHistory++;
		circularHistory %= historyLength;
		return result;
	}

	private int freqToIndex(float freq)
	{
		float num = sampleRate / (float)sampleRange;
		if (freq < num / 2f)
		{
			return 0;
		}
		if (freq > sampleRate / 2f - num / 2f)
		{
			return sampleRange / 2 - 1;
		}
		float num2 = freq / sampleRate;
		return (int)((float)sampleRange * num2);
	}

	private float calcAvg(float lowFreq, float hiFreq, float[] spectrum)
	{
		int num = freqToIndex(lowFreq);
		int num2 = freqToIndex(hiFreq);
		float num3 = 0f;
		for (int i = num; i <= num2; i++)
		{
			num3 += spectrum[i];
		}
		return num3 / (float)(num2 - num + 1);
	}

	private void isBeatFrequency()
	{
		for (int i = 0; i < octaves; i++)
		{
			float num = ((i != 0) ? (sampleRate / 2f / Mathf.Pow(2f, octaves - i)) : 0f);
			float num2 = (sampleRate / 2f / Mathf.Pow(2f, octaves - i - 1) - num) / (float)avgPerOctave;
			float num3 = num;
			for (int j = 0; j < avgPerOctave; j++)
			{
				int num4 = j + i * avgPerOctave;
				float num5 = calcAvg(num3, num3 + num2, spectrum0);
				float num6 = calcAvg(num3, num3 + num2, spectrum1);
				averages[num4] = num6;
				if (num5 > num6)
				{
					averages[num4] = num5;
				}
				num3 += num2;
			}
		}
		acumula++;
		for (int k = 0; k < totalBfLen; k++)
		{
			if (kg == 2)
			{
				estad1[k] = averages[k];
				estad2[k] = averages[k];
				continue;
			}
			estad1[k] += averages[k];
			if (averages[k] > estad2[k])
			{
				estad2[k] = averages[k];
			}
		}
		for (int l = 1; l < totalBfLen; l++)
		{
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			float num10 = averages[l];
			num7 = 0f;
			for (int m = 0; m < numHistory; m++)
			{
				num7 += freqHistory[l, m];
			}
			if (numHistory > 0)
			{
				num7 /= (float)numHistory;
			}
			num8 = 0f;
			for (int n = 0; n < numHistory; n++)
			{
				num8 += (freqHistory[l, n] - num7) * (freqHistory[l, n] - num7);
			}
			if (numHistory > 0)
			{
				num8 /= (float)numHistory;
			}
			num9 = -0.0025714f * num8 + 1.5142857f;
			float num11 = Mathf.Max(num10 - num9 * num7, 0f);
			float num12 = 0f;
			int num13 = 0;
			for (int num14 = 0; num14 < numHistory; num14++)
			{
				if (medHistory[l, num14] > 0f)
				{
					num12 += medHistory[l, num14];
					num13++;
				}
			}
			if (num13 > 0)
			{
				num12 /= (float)num13;
			}
			Mathf.Max(num11 - num12, 0f);
			float num15;
			float num16;
			if (l < 7)
			{
				num15 = 0.003f;
				num16 = 2f;
			}
			else if (l > 6 && l < 20)
			{
				num15 = 0.001f;
				num16 = 3f;
			}
			else
			{
				num15 = 0.001f;
				num16 = 4f;
			}
			if (Time.time - tIniF[l] < 0.05f)
			{
				detectados[l] = false;
			}
			else if (num10 > num16 * num7 && num10 > num15)
			{
				detectados[l] = true;
				tIniF[l] = Time.time;
			}
			else
			{
				detectados[l] = false;
			}
			numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
			freqHistory[l, circularHistory] = num10;
			medHistory[l, circularHistory] = num11;
			circularHistory++;
			circularHistory %= historyLength;
		}
	}

	private beatType isKick()
	{
		int high = ((6 >= totalBfLen) ? totalBfLen : 6);
		if (isRange(1, high, 2))
		{
			return beatType.kick;
		}
		return beatType.None;
	}

	private beatType isSnare()
	{
		int num = ((8 >= totalBfLen) ? totalBfLen : 8);
		int num2 = totalBfLen - 5;
		int threshold = (num2 - num) / 3;
		if (isRange(num, num2, threshold))
		{
			return beatType.snare;
		}
		return beatType.None;
	}

	private beatType isHat()
	{
		int low = ((totalBfLen - 6 >= 0) ? (totalBfLen - 6) : 0);
		int high = totalBfLen - 1;
		if (isRange(low, high, 1))
		{
			return beatType.hithat;
		}
		return beatType.None;
	}

	private bool isRange(int low, int high, int threshold)
	{
		int num = 0;
		for (int i = low; i < high + 1; i++)
		{
			if (detectados[i])
			{
				num++;
			}
		}
		if (num >= threshold)
		{
			return true;
		}
		return false;
	}
}
public class csBeatPoint : MonoBehaviour
{
	public Transform pointT;

	public void SetPointT(float x, float y)
	{
		pointT.localScale = new Vector3(x, 0.15f, 1f);
	}

	public void SetPointT(BeatDetection.EventInfo eventInfo)
	{
		if (eventInfo.messageInfo == BeatDetection.EventType.Energy)
		{
			pointT.localScale = new Vector3(1f, 0.15f, 1f);
		}
		else if (eventInfo.messageInfo == BeatDetection.EventType.HitHat)
		{
			pointT.localScale = new Vector3(3f, 0.15f, 1f);
		}
		else if (eventInfo.messageInfo == BeatDetection.EventType.Kick)
		{
			pointT.localScale = new Vector3(5f, 0.15f, 1f);
		}
		else if (eventInfo.messageInfo == BeatDetection.EventType.Snare)
		{
			pointT.localScale = new Vector3(8f, 0.15f, 1f);
		}
	}
}
public class csBroadcasterEditorUI : MonoBehaviour
{
	public Dictionary<HintTense, string> TenseString = new Dictionary<HintTense, string>();

	private HintTense curTense;

	public Image InputImg;

	public Button InputSaveBtn;

	public Button InitBtn;

	public Button[] HintSwtBtns;

	public InputField InputF;

	public void Start()
	{
		for (int i = 0; i < HintSwtBtns.Length; i++)
		{
			TenseString.Add((HintTense)i, "");
			UnityEngine.Debug.LogError(TenseString[(HintTense)i]);
		}
		HintSwtBtns[0].onClick.AddListener(delegate
		{
			OnHintSwitchClick(HintTense.Common);
			InputImg.color = HintSwtBtns[0].image.color;
		});
		HintSwtBtns[1].onClick.AddListener(delegate
		{
			OnHintSwitchClick(HintTense.Normal);
			InputImg.color = HintSwtBtns[1].image.color;
		});
		HintSwtBtns[2].onClick.AddListener(delegate
		{
			OnHintSwitchClick(HintTense.Mid);
			InputImg.color = HintSwtBtns[2].image.color;
		});
		HintSwtBtns[3].onClick.AddListener(delegate
		{
			OnHintSwitchClick(HintTense.Hot);
			InputImg.color = HintSwtBtns[3].image.color;
		});
		HintSwtBtns[4].onClick.AddListener(delegate
		{
			OnHintSwitchClick(HintTense.Super);
			InputImg.color = HintSwtBtns[4].image.color;
		});
	}

	private void OnHintSwitchClick(HintTense t)
	{
		UnityEngine.Debug.LogError(t);
		InputF.text = TenseString[t];
		curTense = t;
	}

	public void OnHintSaveClick()
	{
		TenseString[curTense] = InputF.text;
	}

	public void OnHintInitClick()
	{
		TenseString[curTense] = InputF.text;
		csMusicEditor.instance.CreateHintBeatItem(curTense, TenseString[curTense]);
	}

	public void DeleteSelectRol()
	{
		csMusicEditor.instance.DeleteSelectRolItem();
	}
}
public enum HintTense
{
	Common,
	Normal,
	Mid,
	Hot,
	Super
}
public class csCurvePointDot : MonoBehaviour
{
	public csEditorBeatItem_Point thisBeatItem;

	public csBeatCurvePointType curveType;

	public AirplanePath thisPathA;

	public BezierCurve thisPathB;

	public List<csEditorBeatItem_Point> WayPointsList = new List<csEditorBeatItem_Point>();

	public static csCurvePointDot currentStartPoint;

	[Header("点阵间距")]
	public float DotDist = 0.03f;

	[HideInInspector]
	public csEditorBeatItem_Point BeatItemEnd;

	[HideInInspector]
	public csEditorBeatItem_Point BeatItemMid;

	[SerializeField]
	public List<csEditorBeatItem_Waypath> DotPointsList = new List<csEditorBeatItem_Waypath>();

	private void Awake()
	{
		thisPathB = base.gameObject.GetComponent<BezierCurve>();
		thisPathB.resolution = 50;
		thisBeatItem = GetComponent<csEditorBeatItem_Point>();
		if (curveType == csBeatCurvePointType.Start)
		{
			AddNodeToPath(thisBeatItem, csBeatCurvePointType.Start);
		}
	}

	public void InitMidPoint()
	{
		if ((bool)BeatItemMid)
		{
			UnityEngine.Object.DestroyImmediate(BeatItemMid.gameObject);
		}
		GameObject obj = UnityEngine.Object.Instantiate(csMusicEditor.instance.PointItemPrefab, thisBeatItem.thisT.position + (BeatItemEnd.thisT.position - thisBeatItem.thisT.position) / 2f, Quaternion.identity);
		obj.transform.SetParent(csMusicEditor.instance.CurMusicPrefab.transform);
		csEditorBeatItem_Point csEditorBeatItem_Point2 = (BeatItemMid = obj.GetComponent<csEditorBeatItem_Point>());
		csEditorBeatItem_Point2.InitBeat((thisBeatItem.BeatPos + BeatItemEnd.BeatPos) / 2f, csEditorBeatItem_Point2.ItemTrack);
		csEditorBeatItem_Point2.InitColorAndType(thisBeatItem.m_BeatItemColor, 1);
	}

	public void AddNodeToPath(csEditorBeatItem_Point newNode, csBeatCurvePointType cPointType)
	{
		switch (cPointType)
		{
		case csBeatCurvePointType.End:
			BeatItemEnd = newNode;
			if (!WayPointsList.Contains(newNode))
			{
				WayPointsList.Add(newNode);
			}
			break;
		case csBeatCurvePointType.Mid:
			if (!WayPointsList.Contains(newNode))
			{
				WayPointsList.Add(newNode);
			}
			break;
		default:
			if (!WayPointsList.Contains(newNode))
			{
				WayPointsList.Add(newNode);
			}
			break;
		}
	}

	public void CreatePathLine()
	{
		thisPathA = GetComponent<AirplanePath>();
		thisPathA.nodes = new AirplaneNode[0];
		for (int i = 0; i < WayPointsList.Count; i++)
		{
			thisPathA.CreateNodeFromBeatPoint(thisBeatItem.thisT, WayPointsList[i]);
		}
	}

	public void CreatePathDotA()
	{
		foreach (csEditorBeatItem_Waypath dotPoints in DotPointsList)
		{
			if (dotPoints != null)
			{
				UnityEngine.Object.DestroyImmediate(dotPoints.gameObject);
			}
		}
		DotPointsList.Clear();
		int num = thisPathA.nodes.Length - 1;
		float num2 = 0f;
		for (int i = 0; i < num; i++)
		{
			int num3 = ((i != thisPathA.nodes.Length - 1) ? (i + 1) : 0);
			Vector3 position = thisPathA.nodes[i].Position;
			Vector3 p = thisPathA.nodes[i].controlPoints[1];
			Vector3 p2 = thisPathA.nodes[num3].controlPoints[0];
			Vector3 position2 = thisPathA.nodes[num3].Position;
			AirplanePath.BezierLength(position, p, p2, position2, 20);
			float num4 = 300f;
			Vector3 vector = AirplanePath.CalculateBezierPoint(0f / num4, position, p, p2, position2);
			if (i == 0)
			{
				csEditorBeatItem_Waypath component = UnityEngine.Object.Instantiate(csMusicEditor.instance.WayPointStartItemPrefab_InGame, vector, Quaternion.identity, thisBeatItem.thisT).GetComponent<csEditorBeatItem_Waypath>();
				component.ItemTrack = thisBeatItem.ItemTrack;
				component.m_BeatItemColor = thisBeatItem.m_BeatItemColor;
				component.InitBeat(thisBeatItem.BeatPos, thisBeatItem.ItemTrack);
				component.InitColorAndType(thisBeatItem.m_BeatItemColor, 3);
				float z = thisBeatItem.thisT.parent.InverseTransformPoint(component.thisT.position).z;
				component.BeatPos = 1f * z / (csMusicEditor.instance.beatGapTime * csMusicEditor.instance.beatGapDis);
				DotPointsList.Add(component);
				DotPointsList[0].LocalWayPathList.Add(Vector3.zero);
			}
			for (int j = 1; (float)j <= num4; j++)
			{
				Vector3 vector2 = AirplanePath.CalculateBezierPoint((float)j / num4, position, p, p2, position2);
				num2 += Vector3.Distance(vector2, vector);
				vector = vector2;
				if (num2 > DotDist)
				{
					num2 -= DotDist;
					thisBeatItem.thisT.parent.InverseTransformPoint(vector2);
					DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(vector2));
				}
			}
		}
		DotPointsList[0].InitLine(isDirect: true);
	}

	[SerializeField]
	public void CreatePathDotB()
	{
		int num = thisPathB.pointCount - 1;
		float num2 = 0f;
		_ = thisPathB.length;
		for (int i = 0; i < num; i++)
		{
			int index = ((i != num) ? (i + 1) : 0);
			BezierPoint bezierPoint = thisPathB[i];
			BezierPoint p = thisPathB[index];
			Vector3 position = bezierPoint.position;
			if (i == 0)
			{
				if (DotPointsList.Count == 0 || DotPointsList[0] == null)
				{
					DotPointsList.Clear();
					csEditorBeatItem_Waypath component = UnityEngine.Object.Instantiate(csMusicEditor.instance.WayPointStartItemPrefab_InGame, position, Quaternion.identity, thisBeatItem.thisT).GetComponent<csEditorBeatItem_Waypath>();
					component.ItemTrack = thisBeatItem.ItemTrack;
					component.m_BeatItemColor = thisBeatItem.m_BeatItemColor;
					component.InitBeat(thisBeatItem.BeatPos, thisBeatItem.ItemTrack);
					component.InitColorAndType(thisBeatItem.m_BeatItemColor, 3);
					float z = thisBeatItem.thisT.parent.InverseTransformPoint(component.thisT.position).z;
					component.BeatPos = 1f * z / (csMusicEditor.instance.beatGapTime * csMusicEditor.instance.beatGapDis);
					DotPointsList.Add(component);
				}
				else
				{
					DotPointsList[0].transform.position = position;
					DotPointsList[0].LocalWayPathList.Clear();
				}
			}
			for (int j = 0; (float)j < 1f / DotDist; j++)
			{
				Vector3 point = BezierCurve.GetPoint(bezierPoint, p, num2);
				num2 += DotDist;
				thisBeatItem.thisT.parent.InverseTransformPoint(point);
				DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(point));
			}
			DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(BezierCurve.GetPoint(bezierPoint, p, 1f)));
			num2 = 0f;
		}
		DotPointsList[0].InitLine(isDirect: true);
	}

	public void CreatePathDotBEditor()
	{
		if (thisPathB == null)
		{
			UnityEngine.Debug.LogError("漏调B曲线", base.gameObject);
			return;
		}
		foreach (csEditorBeatItem_Waypath dotPoints in DotPointsList)
		{
			if (dotPoints != null)
			{
				UnityEngine.Object.DestroyImmediate(dotPoints.gameObject);
			}
		}
		DotPointsList.Clear();
		int num = thisPathB.pointCount - 1;
		float num2 = 0f;
		_ = thisPathB.length;
		for (int i = 0; i < num; i++)
		{
			int index = ((i != num) ? (i + 1) : 0);
			BezierPoint bezierPoint = thisPathB[i];
			BezierPoint p = thisPathB[index];
			Vector3 position = bezierPoint.position;
			if (i == 0)
			{
				csEditorBeatItem_Waypath component = UnityEngine.Object.Instantiate(csMusicEditor.instance.WayPointStartItemPrefab_InGame, position, Quaternion.identity, thisBeatItem.thisT).GetComponent<csEditorBeatItem_Waypath>();
				component.ItemTrack = thisBeatItem.ItemTrack;
				component.m_BeatItemColor = thisBeatItem.m_BeatItemColor;
				component.InitBeat(thisBeatItem.BeatPos, thisBeatItem.ItemTrack);
				component.InitColorAndType(thisBeatItem.m_BeatItemColor, 3);
				float z = thisBeatItem.thisT.parent.InverseTransformPoint(component.thisT.position).z;
				component.BeatPos = 1f * z / (csMusicEditor.instance.beatGapTime * csMusicEditor.instance.beatGapDis);
				DotPointsList.Add(component);
			}
			for (int j = 0; (float)j < 1f / DotDist; j++)
			{
				Vector3 point = BezierCurve.GetPoint(bezierPoint, p, num2);
				num2 += DotDist;
				thisBeatItem.thisT.parent.InverseTransformPoint(point);
				DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(point));
			}
			DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(BezierCurve.GetPoint(bezierPoint, p, 1f)));
			num2 = 0f;
		}
		DotPointsList[0].InitLine(isDirect: true);
	}

	public void CreateExistPathBDotLine()
	{
		if (thisPathB == null)
		{
			UnityEngine.Debug.LogError("漏调B曲线", base.gameObject);
			return;
		}
		int num = thisPathB.pointCount - 1;
		float num2 = 0f;
		DotPointsList[0].PathLineRnd.positionCount = 0;
		DotPointsList[0].LocalWayPathList.Clear();
		for (int i = 0; i < num; i++)
		{
			int index = ((i != num) ? (i + 1) : 0);
			BezierPoint p = thisPathB[i];
			BezierPoint p2 = thisPathB[index];
			for (int j = 0; (float)j < 1f / DotDist; j++)
			{
				Vector3 point = BezierCurve.GetPoint(p, p2, num2);
				num2 += DotDist;
				thisBeatItem.thisT.parent.InverseTransformPoint(point);
				DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(point));
			}
			DotPointsList[0].LocalWayPathList.Add(DotPointsList[0].thisT.InverseTransformPoint(BezierCurve.GetPoint(p, p2, 1f)));
			num2 = 0f;
		}
		DotPointsList[0].InitLine(isDirect: true);
	}

	public void ConvertToNewCurve()
	{
		if (thisPathB == null)
		{
			thisPathB = base.gameObject.AddComponent<BezierCurve>();
			thisPathB.resolution = 50;
		}
		thisPathB.drawColor = Color.red;
		thisPathA = GetComponent<AirplanePath>();
		thisPathA.showGizmos = false;
		for (int i = 0; i < WayPointsList.Count; i++)
		{
			WayPointsList[i].ConvertToNewCurve();
		}
		thisPathB.resolution = 50;
		CurveGenerate();
	}

	private void CurveGenerate()
	{
		int num = 0;
		int num2 = 0;
		float num3 = 0f;
		for (int i = 0; i < thisPathB.pointCount; i++)
		{
			if (num2 < thisPathB.pointCount - 1)
			{
				num = i + 1;
				num2 = i + 2;
				Vector3 position = thisPathB[i].transform.position;
				Vector3 position2 = thisPathB[num].transform.position;
				Vector3 position3 = thisPathB[num2].transform.position;
				Vector3 vector = (position2 - position) / 2f + position;
				Vector3 vector2 = (position3 - position2) / 2f + position2;
				num3 = Vector3.Distance(position3, position2) / (Vector3.Distance(position2, position) + Vector3.Distance(position3, position2));
				Vector3 vector3 = (vector2 - vector) * num3 + vector;
				thisPathB[num].handle2 = thisPathB[num].transform.InverseTransformPoint(vector3 + (position2 - vector3) + (vector2 - vector3));
			}
		}
	}
}
public class csEditorBeatHint : MonoBehaviour
{
	public Transform HintTrans;

	public void SetHintTrans(float YScale)
	{
		HintTrans.localScale = new Vector3(1f, YScale, 1f);
	}
}
public class csEditorBeatItem : MonoBehaviour
{
	public csBeatItemColor m_BeatItemColor;

	public float BeatPos;

	public Transform thisT;

	public Transform childT;

	public csBeatItemType m_BeatItemType;

	public Collider ItemCol;

	public int TypeIndex;

	public int AngleTurn;

	private int rythmIndex;

	protected bool isMoveStart;

	protected Vector3 WorldMoveDir;

	public bool isTutorialItem;

	public float moveSpeed;

	public int currentHitSpeedLevel;

	public bool isStartHole = true;

	public int ItemTrack;

	public List<Vector3> LocalWayPathList = new List<Vector3>();

	private Vector3 shouldBePos;

	private bool hasShowedEffect;

	public GameObject closeEffect;

	public float PlayCloseEffectTime;

	protected float ReturnT = 100f;

	public float closeT = 100f;

	private float perfectHitOffsetTime;

	protected bool isDownloadGameObj;

	private float FlyOutTime = 0.4f;

	private float FlyBackTimePer = 0.9f;

	public float moveDis = 1f;

	private Quaternion standradRotate;

	protected bool isHit;

	protected csSimpleRigidbody rb;

	private float speedModi = 10f;

	public void SetRInedx(int i)
	{
		rythmIndex = i;
	}

	public float GetAddTime()
	{
		float num = ((!GameManagerNew.instance.isBroadcastScene) ? GameManagerNew.instance.SongPlayer.beatGapDis : GameManagerNew.instance.SongPlayerH.beatGapDis);
		return LocalWayPathList[LocalWayPathList.Count - 1].z / 4f * num / moveSpeed;
	}

	private void Awake()
	{
		thisT = base.transform;
		if (thisT.childCount > 0)
		{
			childT = thisT.GetChild(0);
		}
		ItemCol = GetComponent<Collider>();
		if ((bool)ItemCol)
		{
			ItemCol.enabled = false;
		}
		rb = GetComponent<csSimpleRigidbody>();
	}

	private void OnMouseDown()
	{
	}

	private void Update()
	{
		OnUpdate();
	}

	public virtual void OnUpdate()
	{
		if (!isMoveStart)
		{
			return;
		}
		thisT.transform.position += WorldMoveDir * moveSpeed * Time.deltaTime;
		ReturnT -= Time.deltaTime;
		if ((bool)closeEffect && !hasShowedEffect)
		{
			closeT -= Time.deltaTime;
		}
		if (ReturnT <= 0f)
		{
			ReturnT = 100f;
			OnItemMiss();
			OnItemReturnToPool();
		}
		if (!hasShowedEffect && closeT < PlayCloseEffectTime + perfectHitOffsetTime)
		{
			if ((bool)closeEffect)
			{
				closeEffect.SetActive(value: true);
			}
			hasShowedEffect = true;
		}
	}

	public void InitBeat(float beatP, int track)
	{
		BeatPos = beatP;
		ItemCol.enabled = true;
		ItemTrack = track;
	}

	public virtual void InitColorAndType(csBeatItemColor _ItemColor, int _index)
	{
		TypeIndex = _index;
	}

	public virtual void SetColScale(float s)
	{
	}

	public virtual void SetHintLineLength(int fromAngle, int toAngle)
	{
	}

	public virtual void InitMoveDirAndSpeed(Vector3 Dir, float speed, int angle, bool isDownloadGame = false)
	{
		if ((bool)closeEffect)
		{
			closeEffect.SetActive(value: false);
		}
		isDownloadGameObj = isDownloadGame;
		isMoveStart = true;
		WorldMoveDir = Dir;
		moveSpeed = speed;
		perfectHitOffsetTime = csGameSettings.PerfectHitZOffset / moveSpeed;
		float z = (Quaternion.Euler(0f, -angle, 0f) * thisT.position).z;
		AngleTurn = angle;
		ReturnT = (Mathf.Abs(z) + csGameSettings.OnMissDistance) / moveSpeed;
		closeT = Mathf.Abs(z) / moveSpeed;
		hasShowedEffect = false;
		moveStart(isDownloadGame);
		isHit = false;
	}

	public virtual void moveStart(bool isDownloadGame = false)
	{
		float MaxTime = 0f;
		if (GameManagerNew.instance.isBroadcastScene)
		{
			MaxTime = GameManagerNew.instance.SongPlayerH.SongPrepareDist / moveSpeed;
		}
		else
		{
			MaxTime = GameManagerNew.instance.SongPlayer.SongPrepareDist / moveSpeed;
		}
		Vector3 zero = Vector3.zero;
		if (isOutFlyType(m_BeatItemType))
		{
			zero.x = ((m_BeatItemColor == csBeatItemColor.RWhite) ? 1 : (-1));
		}
		switch (m_BeatItemType)
		{
		case csBeatItemType.Normal:
			zero.y = -1f;
			break;
		case csBeatItemType.Direction:
			zero.y = 0.5f;
			break;
		}
		if (GameManagerNew.instance.isBroadcastScene || isDownloadGame)
		{
			return;
		}
		if (isOutFlyType(m_BeatItemType))
		{
			zero = Quaternion.Euler(0f, AngleTurn, 0f) * zero;
			zero.Normalize();
			zero = thisT.InverseTransformDirection(zero * 3f);
			Quaternion localRotation = childT.localRotation;
			childT.localRotation = Quaternion.Euler(0f, 0f, (m_BeatItemColor == csBeatItemColor.LBlack) ? (-150) : 150) * childT.localRotation;
			childT.localScale = Vector3.zero;
			childT.DOScale(Vector3.one, FlyOutTime * 8f / moveSpeed);
			childT.DOLocalRotateQuaternion(localRotation, FlyOutTime * 8f / moveSpeed + 0.5f);
			childT.DOLocalMove(zero, FlyOutTime * 8f / moveSpeed).SetEase(Ease.Linear).OnComplete(delegate
			{
				childT.DOLocalMove(Vector3.zero, MaxTime * FlyBackTimePer).SetEase(Ease.OutQuart);
			});
		}
		else if (isScaleFlyType(m_BeatItemType))
		{
			_ = childT.localRotation;
			childT.localScale = Vector3.zero;
			childT.DOScale(Vector3.one, FlyOutTime * 8f / moveSpeed);
		}
		else if (m_BeatItemType == csBeatItemType.Wall)
		{
			childT.localScale = Vector3.zero;
			childT.DOScale(Vector3.one, FlyOutTime * 8f / moveSpeed);
			Quaternion localRotation2 = childT.localRotation;
			childT.rotation = Quaternion.LookRotation(childT.forward, childT.rotation * Vector3.right);
			childT.DOLocalRotateQuaternion(localRotation2, FlyOutTime * 8f / moveSpeed + 0.5f);
		}
		else
		{
			childT.localScale = Vector3.zero;
			childT.DOScale(Vector3.one, FlyOutTime * 8f / moveSpeed);
			Quaternion localRotation3 = childT.localRotation;
			childT.localRotation = Quaternion.Euler(0f, 0f, 150f) * childT.localRotation;
			childT.DOLocalRotateQuaternion(localRotation3, FlyOutTime * 8f / moveSpeed + 0.5f);
		}
	}

	private bool isOutFlyType(csBeatItemType t)
	{
		if (t != csBeatItemType.Normal && t != csBeatItemType.Direction)
		{
			return t == csBeatItemType.Turning;
		}
		return true;
	}

	private bool isScaleFlyType(csBeatItemType t)
	{
		if (t != csBeatItemType.StickDirection && t != csBeatItemType.StickTurning)
		{
			return t == csBeatItemType.Triangle;
		}
		return true;
	}

	public void rotateStart()
	{
		standradRotate = thisT.rotation;
		thisT.rotation = Quaternion.identity;
		thisT.DORotateQuaternion(standradRotate, closeT / 3f * 2f);
	}

	public virtual void SetVisible(bool isVis)
	{
		base.gameObject.SetActive(value: false);
	}

	public virtual void SetToDir(csHitObjType dirType)
	{
	}

	public virtual void SetRotateAngle(int a)
	{
	}

	public virtual void SetToColorInGame(csBeatItemColor c)
	{
	}

	public virtual void OnItemHit(Vector3 forceDir)
	{
		if (csSportInfoManager.instance.isStartDataRecord)
		{
			csSportInfoManager.instance.thisTimeHit++;
		}
		if (!isDownloadGameObj && !csTutorialSceneGameManager.instance && !csIngameSwiftHint.isPlaying)
		{
			GameManagerNew.instance.GameValueManager.setComboFatherRotation(AngleTurn);
			GameManagerNew.instance.GameValueManager.OnHitItem(m_BeatItemType, forceDir, m_BeatItemColor, thisT, currentHitSpeedLevel, WorldMoveDir);
		}
		isHit = true;
		bool status = false;
		if (m_BeatItemType != csBeatItemType.Way)
		{
			SetVisible(isVis: false);
			csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
			status = true;
		}
		if (!csTutorialSceneGameManager.isTutorial)
		{
			movement_header obj = new movement_header(csByteEventTracking.Instance.stage_Header, GameManagerNew.instance.SongPlayer.curItemDataIndex, this, status, forceDir.magnitude);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.movement_flow, new Dictionary<string, object>
			{
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"movement_header",
					JsonUtility.ToJson(obj)
				}
			});
		}
	}

	public bool GetIsHit()
	{
		return isHit;
	}

	public virtual void OnItemMiss()
	{
		if (!isHit && !isDownloadGameObj && !csTutorialSceneGameManager.instance)
		{
			GameManagerNew.instance.GameValueManager.OnMissItem(m_BeatItemType);
		}
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, m_BeatItemType == csBeatItemType.Way);
		if (!csTutorialSceneGameManager.isTutorial)
		{
			movement_header obj = new movement_header(csByteEventTracking.Instance.stage_Header, GameManagerNew.instance.SongPlayer.curItemDataIndex, this, m_BeatItemType == csBeatItemType.Way, 0f);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.movement_flow, new Dictionary<string, object>
			{
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"movement_header",
					JsonUtility.ToJson(obj)
				}
			});
		}
	}

	public virtual void OnItemMissFly(Vector3 misHitVel)
	{
		if (isDownloadGameObj)
		{
			if ((bool)csTutorialSceneGameManager.instance)
			{
				GameManagerNew.instance.GameValueManager.OnMissItem(m_BeatItemType);
			}
			if (csSportInfoManager.instance.isStartDataRecord)
			{
				csSportInfoManager.instance.thisTimeMissHit++;
			}
			csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
		}
	}

	public IEnumerator StartFly(Vector3 dir)
	{
		if (dir == Vector3.zero)
		{
			dir = csPlayer.instance.PicoXRControllerL.transform.forward;
		}
		if (dir.sqrMagnitude < 1f)
		{
			dir = dir.normalized;
		}
		rb.AddForce(speedModi * dir);
		isHit = true;
		yield return new WaitForSeconds(1f);
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public virtual void OnItemReturnToPool()
	{
		isHit = true;
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public virtual void OnColorInverse()
	{
		if (m_BeatItemColor == csBeatItemColor.RWhite)
		{
			SetToColorInGame(csBeatItemColor.LBlack);
		}
		else
		{
			SetToColorInGame(csBeatItemColor.RWhite);
		}
	}

	public virtual void OnItemReset()
	{
		isMoveStart = false;
		ReturnT = 100f;
	}
}
public class csEditorBeatItemPos : MonoBehaviour
{
	public Image image;

	public bool onMouseOver;

	public int FromTrack;

	public void Select()
	{
		image.enabled = true;
	}

	public void UnSelect()
	{
		image.enabled = false;
	}
}
public class csEditorBeatItem_FootRingHint : csEditorBeatItem
{
	public Transform FootT;

	public void setFoot(bool isLeft)
	{
		FootT.localScale = new Vector3(isLeft ? 1 : (-1), 1f, 1f);
	}

	public override void InitColorAndType(csBeatItemColor _ItemColor, int _index)
	{
		base.InitColorAndType(_ItemColor, _index);
		m_BeatItemColor = _ItemColor;
		setFoot(_ItemColor == csBeatItemColor.LBlack);
	}
}
public class csEditorBeatItem_Hint : csEditorBeatItem
{
	public string HintText;

	public Image BKGImg;

	public Text TextHintT;

	public Color[] BkgColors;

	public HintTense HTense;

	public void InitHintText(HintTense ht, string h)
	{
		HTense = ht;
		BKGImg.color = BkgColors[(int)ht];
		string hintText = (TextHintT.text = h);
		HintText = hintText;
	}

	public override void OnItemReturnToPool()
	{
		base.OnItemReturnToPool();
		LevelBroadCastHintCanvas.instance.PeekNext();
	}
}
public class csEditorBeatItem_Hitobj : csEditorBeatItem
{
	public csHitObjType m_HitObjType;

	public GameObject[] PrefabArray;

	public csHitObjChild m_HitObjChild;

	public Transform HintLineT;

	public string RewardID = "";

	public string RewardName = "";

	private GameObject temp;

	private ColoredHitEffect cHitEffect;

	public override void InitColorAndType(csBeatItemColor _ItemColor, int _index)
	{
		base.InitColorAndType(_ItemColor, _index);
		m_BeatItemColor = _ItemColor;
		m_HitObjType = (csHitObjType)_index;
		SetToDir(m_HitObjType);
		m_HitObjChild.SetColor(_ItemColor);
	}

	public override void SetColScale(float s)
	{
	}

	public override void OnUpdate()
	{
		if (!isTutorialItem)
		{
			base.OnUpdate();
			return;
		}
		thisT.transform.position += WorldMoveDir * moveSpeed * Time.deltaTime;
		if (thisT.transform.position.z < -5f)
		{
			ReturnT = 100f;
			OnItemReturnToPool();
		}
	}

	public override void OnColorInverse()
	{
		if (m_BeatItemColor == csBeatItemColor.RWhite)
		{
			SetToColorInGame(csBeatItemColor.LBlack);
		}
		else
		{
			SetToColorInGame(csBeatItemColor.RWhite);
		}
	}

	public override void SetRotateAngle(int a)
	{
		base.SetRotateAngle(a);
		AngleTurn = a;
	}

	public override void SetToColorInGame(csBeatItemColor c)
	{
		m_BeatItemColor = c;
		m_HitObjChild.SetColor(c);
	}

	public override void SetHintLineLength(int fromAngle, int toAngle)
	{
		if (m_BeatItemType == csBeatItemType.Turning || m_BeatItemType == csBeatItemType.StickTurning)
		{
			float num = Mathf.DeltaAngle(fromAngle, toAngle);
			float z = 0.15f;
			if (!(num <= 30f))
			{
				z = ((!(num > 30f) || !(num < 90f)) ? 0.45f : (0.15f + (num - 30f) / 30f * 0.15f));
			}
			HintLineT.localScale = new Vector3(1f, 1f, z);
		}
	}

	public override void SetToDir(csHitObjType dirType)
	{
		if (m_BeatItemType == csBeatItemType.Direction || m_BeatItemType == csBeatItemType.Normal || m_BeatItemType == csBeatItemType.Turning || m_BeatItemType == csBeatItemType.StickTurning || m_BeatItemType == csBeatItemType.StickDirection)
		{
			switch (dirType)
			{
			case csHitObjType.LT:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.up * 0.3f, -new Vector3(1f, -1f, -0.3f));
				break;
			case csHitObjType.MT:
				if (m_BeatItemColor == csBeatItemColor.LBlack)
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.up * 0.3f, -new Vector3(-0.3f, -1f, -0.3f));
				}
				else
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.up * 0.3f, -new Vector3(0.3f, -1f, -0.3f));
				}
				break;
			case csHitObjType.RT:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.up * 0.3f, -new Vector3(-1f, -1f, -0.3f));
				break;
			case csHitObjType.LM:
				if (m_BeatItemType == csBeatItemType.Turning || m_BeatItemType == csBeatItemType.StickTurning)
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.right * 0.3f, -new Vector3(1f, 0f, -1f));
				}
				else
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.right * 0.3f, -new Vector3(1f, 0f, -0.3f));
				}
				break;
			case csHitObjType.MM:
				thisT.localRotation = Quaternion.identity;
				break;
			case csHitObjType.RM:
				if (m_BeatItemType == csBeatItemType.Turning || m_BeatItemType == csBeatItemType.StickTurning)
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.right * 0.3f, -new Vector3(-1f, 0f, -1f));
				}
				else
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.right * 0.3f, -new Vector3(-1f, 0f, -0.3f));
				}
				break;
			case csHitObjType.LB:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.up * 0.3f, -new Vector3(1f, 1f, -0.3f));
				break;
			case csHitObjType.MB:
				if (m_BeatItemColor == csBeatItemColor.LBlack)
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.up * 0.3f, -new Vector3(-0.3f, 1f, -0.3f));
				}
				else
				{
					thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.up * 0.3f, -new Vector3(0.3f, 1f, -0.3f));
				}
				break;
			case csHitObjType.RB:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.up * 0.3f, -new Vector3(-1f, 1f, -0.3f));
				break;
			}
		}
		else if (m_BeatItemType == csBeatItemType.SwiftKnee)
		{
			switch (dirType)
			{
			case csHitObjType.LM:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward - Vector3.right * 0.3f, Vector3.up);
				break;
			case csHitObjType.MM:
				thisT.localRotation = Quaternion.identity;
				break;
			case csHitObjType.RM:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward + Vector3.right * 0.3f, Vector3.up);
				break;
			}
		}
		else
		{
			switch (dirType)
			{
			case csHitObjType.LT:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(1f, -1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.MT:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(0f, -1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.RT:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(-1f, -1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.LM:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(1f, 0f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.MM:
				thisT.localRotation = Quaternion.identity;
				break;
			case csHitObjType.RM:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(-1f, 0f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.LB:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(1f, 1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.MB:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(0f, 1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			case csHitObjType.RB:
				thisT.localRotation = Quaternion.LookRotation(Vector3.forward, -new Vector3(-1f, 1f, 0f));
				thisT.Rotate(Vector3.right, 30f);
				break;
			}
		}
	}

	private PoolObjectType getEffectType(string id)
	{
		return PoolObjectType.RewardEffect_1;
	}

	public override void OnItemHit(Vector3 forceDir)
	{
		base.OnItemHit(forceDir);
		if ((bool)ItemCol)
		{
			ItemCol.enabled = false;
		}
		m_HitObjChild.gameObject.SetActive(value: false);
		if (m_BeatItemType == csBeatItemType.Reward)
		{
			if (csTutorialSceneGameManager.isTutorial || GameManagerNew.instance.SongPlayer.IsLastLevel())
			{
				csObjectPool.Instance.GetObjectByType(getEffectType(csGameSettings.currentStage), thisT.position, thisT.forward).transform.rotation = Quaternion.LookRotation(thisT.forward, Vector3.up);
			}
			else
			{
				csObjectPool.Instance.GetObjectByType(PoolObjectType.RewardEffect_2, thisT.position, thisT.forward).transform.rotation = Quaternion.LookRotation(thisT.forward, Vector3.up);
			}
		}
		else if (m_BeatItemType == csBeatItemType.Defence)
		{
			csObjectPool.Instance.GetObjectByType(PoolObjectType.DefenceEffect, thisT.position, thisT.forward);
		}
		else if (m_BeatItemType == csBeatItemType.Normal)
		{
			if (currentHitSpeedLevel == 1)
			{
				cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Speed1, thisT.position);
				cHitEffect.SetColor(m_BeatItemColor);
				cHitEffect.transform.up = forceDir;
			}
			else
			{
				cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Speed3, thisT.position);
				cHitEffect.SetColor(m_BeatItemColor);
				cHitEffect.transform.up = forceDir;
			}
		}
		else
		{
			if (currentHitSpeedLevel == 0)
			{
				return;
			}
			if (csGameDataTransfer.playMode == csPlayMode.Boxing)
			{
				if (m_BeatItemType == csBeatItemType.SwiftKick)
				{
					if (currentHitSpeedLevel == 1)
					{
						cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Swift_KickLow, thisT.position + thisT.forward * 0.6f);
						cHitEffect.SetColor(m_BeatItemColor);
						cHitEffect.transform.up = forceDir;
					}
					else
					{
						cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Swift_Kick, thisT.position + thisT.forward * 0.6f);
						cHitEffect.SetColor(m_BeatItemColor);
						cHitEffect.transform.up = forceDir;
					}
				}
				else if (m_BeatItemType == csBeatItemType.SwiftKnee)
				{
					if (currentHitSpeedLevel == 1)
					{
						cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_KneeLow, thisT.position);
						cHitEffect.SetColor(m_BeatItemColor);
						cHitEffect.transform.position += 0.2f * Vector3.forward;
					}
					else
					{
						cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Knee, thisT.position);
						cHitEffect.SetColor(m_BeatItemColor);
						cHitEffect.transform.position += 0.2f * Vector3.forward;
					}
				}
				else
				{
					cHitEffect = csObjectPool.Instance.GetColoredEffectType((PoolObjectType)(5000 + currentHitSpeedLevel), thisT.position);
					cHitEffect.SetColor(m_BeatItemColor);
					cHitEffect.transform.up = forceDir;
				}
			}
			else if (currentHitSpeedLevel == 1)
			{
				cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Speed1_gun, thisT.position);
				cHitEffect.SetColor(m_BeatItemColor);
				cHitEffect.transform.up = forceDir;
			}
			else
			{
				cHitEffect = csObjectPool.Instance.GetColoredEffectType(PoolObjectType.HitEffect_Speed3_gun, thisT.position);
				cHitEffect.SetColor(m_BeatItemColor);
				cHitEffect.transform.up = forceDir;
			}
		}
	}

	public override void OnItemMiss()
	{
		base.OnItemMiss();
		if ((bool)csMainSceneAudioPlayer.instance)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D("Miss");
		}
	}

	public override void OnItemMissFly(Vector3 misHitVel)
	{
		isHit = true;
		rb.SetKinematic(isTrue: false);
		rb.useGravity = true;
		if (!isDownloadGameObj && !csTutorialSceneGameManager.instance && !csIngameSwiftHint.isPlaying)
		{
			GameManagerNew.instance.GameValueManager.OnMissItem(m_BeatItemType);
			if (csSportInfoManager.instance.isStartDataRecord)
			{
				csSportInfoManager.instance.thisTimeMissHit++;
			}
			GameManagerNew.instance.GameValueManager.addWrongHit();
		}
		isMoveStart = false;
		if ((bool)GameManagerNew.instance)
		{
			GameManagerNew.instance.StartCoroutine(StartFly(misHitVel));
		}
		if ((bool)csTutorialSceneGameManager.instance)
		{
			csTutorialSceneGameManager.instance.StartCoroutine(StartFly(misHitVel));
		}
		if (!csTutorialSceneGameManager.isTutorial)
		{
			movement_header obj = new movement_header(csByteEventTracking.Instance.stage_Header, GameManagerNew.instance.SongPlayer.curItemDataIndex, this, m_BeatItemType == csBeatItemType.Way, 0f);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.movement_flow, new Dictionary<string, object>
			{
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"movement_header",
					JsonUtility.ToJson(obj)
				}
			});
		}
	}

	public override void OnItemReset()
	{
		base.OnItemReset();
		rb.useGravity = false;
		rb.SetKinematic(isTrue: true);
		m_HitObjChild.gameObject.SetActive(value: true);
	}
}
public class csEditorBeatItem_Hole : csEditorBeatItem
{
	public override void SetRotateAngle(int a)
	{
		base.SetRotateAngle(a);
		AngleTurn = a;
		thisT.transform.localRotation = Quaternion.Euler(0f, a, 0f);
	}
}
public class csEditorBeatItem_Point : csEditorBeatItem
{
	public csBeatCurvePointType m_BeatItemPointType;

	public MeshRenderer m_MeshRenderer;

	public TextMeshPro m_Text;

	public MeshRenderer[] EditorRndsToHide;

	public GameObject[] RedObjs;

	public GameObject[] BlueObjs;

	public void HideEditorRnd(bool isHide)
	{
		MeshRenderer[] editorRndsToHide = EditorRndsToHide;
		for (int i = 0; i < editorRndsToHide.Length; i++)
		{
			editorRndsToHide[i].enabled = isHide;
		}
	}

	private void Start()
	{
		if (m_BeatItemPointType == csBeatCurvePointType.Single)
		{
			for (int i = 0; i < RedObjs.Length; i++)
			{
				RedObjs[i].SetActive(m_BeatItemColor == csBeatItemColor.LBlack);
			}
			for (int j = 0; j < BlueObjs.Length; j++)
			{
				BlueObjs[j].SetActive(m_BeatItemColor == csBeatItemColor.RWhite);
			}
		}
	}

	public override void SetToColorInGame(csBeatItemColor c)
	{
		base.SetToColorInGame(c);
		if (m_BeatItemPointType == csBeatCurvePointType.Single)
		{
			m_BeatItemColor = c;
			for (int i = 0; i < RedObjs.Length; i++)
			{
				RedObjs[i].SetActive(m_BeatItemColor == csBeatItemColor.LBlack);
			}
			for (int j = 0; j < BlueObjs.Length; j++)
			{
				BlueObjs[j].SetActive(m_BeatItemColor == csBeatItemColor.RWhite);
			}
		}
	}

	public override void InitColorAndType(csBeatItemColor _ItemColor, int _index)
	{
		base.InitColorAndType(_ItemColor, _index);
		m_BeatItemColor = _ItemColor;
		m_BeatItemPointType = (csBeatCurvePointType)_index;
		if ((bool)m_MeshRenderer)
		{
			m_MeshRenderer.material = ((_ItemColor == csBeatItemColor.LBlack) ? csMusicEditor.instance.ItemMaterial_Red : csMusicEditor.instance.ItemMaterial_Blue);
		}
		CurvePointInit();
	}

	private void CurvePointInit()
	{
		if (m_BeatItemPointType == csBeatCurvePointType.Mid || m_BeatItemPointType == csBeatCurvePointType.End)
		{
			BezierPoint bezierPoint = GetComponent<BezierPoint>();
			if (bezierPoint == null)
			{
				bezierPoint = base.gameObject.AddComponent<BezierPoint>();
			}
			if ((bool)csCurvePointDot.currentStartPoint)
			{
				csCurvePointDot.currentStartPoint.AddNodeToPath(this, m_BeatItemPointType);
				thisT.SetParent(csCurvePointDot.currentStartPoint.thisBeatItem.thisT);
				bezierPoint.curve = csCurvePointDot.currentStartPoint.thisPathB;
				bezierPoint.handle1 = Vector3.back;
			}
			else
			{
				UnityEngine.Debug.LogError("没有起始点");
			}
		}
		if (m_BeatItemPointType == csBeatCurvePointType.Start)
		{
			BezierPoint bezierPoint2 = GetComponent<BezierPoint>();
			if (bezierPoint2 == null)
			{
				bezierPoint2 = base.gameObject.AddComponent<BezierPoint>();
			}
			BezierCurve bezierCurve = GetComponent<BezierCurve>();
			if (bezierCurve == null)
			{
				bezierCurve = base.gameObject.AddComponent<BezierCurve>();
			}
			bezierCurve.close = false;
			bezierPoint2.curve = bezierCurve;
			csCurvePointDot csCurvePointDot2 = GetComponent<csCurvePointDot>();
			if (csCurvePointDot2 == null)
			{
				csCurvePointDot2 = base.gameObject.AddComponent<csCurvePointDot>();
			}
			csCurvePointDot.currentStartPoint = csCurvePointDot2;
		}
		base.gameObject.name = "CurvePoint " + m_BeatItemPointType;
	}

	public override void OnItemHit(Vector3 forceDir)
	{
		base.OnItemHit(forceDir);
		if (m_BeatItemColor == csBeatItemColor.LBlack)
		{
			csObjectPool.Instance.GetObjectByType(PoolObjectType.PointHitRed, thisT.position, Vector3.forward);
		}
		else
		{
			csObjectPool.Instance.GetObjectByType(PoolObjectType.PointHitBlue, thisT.position, Vector3.forward);
		}
	}

	public void ConvertToNewCurve()
	{
		if (m_BeatItemPointType == csBeatCurvePointType.Mid || m_BeatItemPointType == csBeatCurvePointType.End)
		{
			BezierPoint bezierPoint = GetComponent<BezierPoint>();
			if (bezierPoint == null)
			{
				bezierPoint = base.gameObject.AddComponent<BezierPoint>();
			}
			if ((bool)csCurvePointDot.currentStartPoint)
			{
				csCurvePointDot.currentStartPoint.AddNodeToPath(this, m_BeatItemPointType);
				thisT.SetParent(csCurvePointDot.currentStartPoint.thisBeatItem.thisT);
				bezierPoint.curve = csCurvePointDot.currentStartPoint.thisPathB;
			}
			else
			{
				UnityEngine.Debug.LogError("没有起始点");
			}
		}
		if (m_BeatItemPointType == csBeatCurvePointType.Start)
		{
			BezierPoint bezierPoint2 = GetComponent<BezierPoint>();
			if (bezierPoint2 == null)
			{
				bezierPoint2 = base.gameObject.AddComponent<BezierPoint>();
			}
			BezierCurve bezierCurve = GetComponent<BezierCurve>();
			if (bezierCurve == null)
			{
				bezierCurve = base.gameObject.AddComponent<BezierCurve>();
			}
			bezierCurve.close = false;
			bezierPoint2.curve = bezierCurve;
			csCurvePointDot csCurvePointDot2 = GetComponent<csCurvePointDot>();
			if (csCurvePointDot2 == null)
			{
				csCurvePointDot2 = base.gameObject.AddComponent<csCurvePointDot>();
			}
			csCurvePointDot.currentStartPoint = csCurvePointDot2;
		}
	}
}
public class csEditorBeatItem_Wall : csEditorBeatItem
{
	public string WallID = "";

	public string WallName = "";

	public csWallHole[] WallHoles;

	public csWallJudgeChecker JudegeChecker;

	public bool isJudged;

	public Sprite WallSprite;

	public bool headPass;

	public bool leftHandPass;

	public bool rightHandPass;

	public GameObject[] TriangleMesh;

	[Header("范围:0-4")]
	public int currentTriangleType;

	public bool needHeadPass = true;

	public bool needRightHandPass = true;

	public bool needLeftHandPass = true;

	public override void OnUpdate()
	{
		if (!isTutorialItem)
		{
			base.OnUpdate();
			return;
		}
		thisT.transform.position += WorldMoveDir * moveSpeed * Time.deltaTime;
		if (thisT.transform.position.z < -5f)
		{
			ReturnT = 100f;
			OnItemReturnToPool();
		}
	}

	private void initScale(float height)
	{
		Vector3 localScale = Vector3.one * height / 170f * csGameSettings.triangleStd;
		localScale.z = 1f;
		thisT.localScale = localScale;
	}

	public override void SetVisible(bool isVis)
	{
	}

	public override void OnItemHit(Vector3 forceDir)
	{
		csAudioManager.instance.playAudioByName("wallSuccess", csGameSettings.SoundEffectVol * 0.5f);
		base.OnItemHit(forceDir);
		isJudged = true;
		if ((bool)GameManagerNew.instance)
		{
			csObjectPool.Instance.GetObjectByType(PoolObjectType.WallPassEffect, GameManagerNew.instance.CurPlayer.camT.position + Vector3.up * 0.5f, thisT.forward);
		}
	}

	public override void OnItemMiss()
	{
		csAudioManager.instance.playAudioByName("wallMiss", csGameSettings.SoundEffectVol * 0.5f);
		if (!csTutorialSceneGameManager.instance)
		{
			isJudged = true;
			GameManagerNew.instance.GameValueManager.OnMissItem(m_BeatItemType);
			if (csSportInfoManager.instance.isStartDataRecord)
			{
				csSportInfoManager.instance.thisTimeMissHit++;
			}
		}
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
		if ((bool)csMainSceneAudioPlayer.instance)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D("Miss");
		}
	}

	public void OnItemHit(int currentType)
	{
		switch (currentType)
		{
		case 1:
			leftHandPass = true;
			break;
		case 2:
			rightHandPass = true;
			break;
		case 0:
			headPass = true;
			break;
		}
		headPass = !needHeadPass || headPass;
		rightHandPass = !needRightHandPass || rightHandPass;
		leftHandPass = !needLeftHandPass || leftHandPass;
		if (!isJudged && leftHandPass && rightHandPass && headPass)
		{
			OnItemHit(Vector3.zero);
		}
	}

	public void ReturnToPool()
	{
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public override void OnItemReset()
	{
		base.OnItemReset();
		initScale(PlayerPrefs.GetInt("Height", 170));
		WallReset();
	}

	public void WallReset()
	{
		isJudged = false;
		leftHandPass = false;
		rightHandPass = false;
		headPass = false;
		csWallHole[] wallHoles = WallHoles;
		for (int i = 0; i < wallHoles.Length; i++)
		{
			wallHoles[i].Reset();
		}
	}

	public void setToTargetTriangle(int num)
	{
		for (int i = 0; i < TriangleMesh.Length; i++)
		{
			TriangleMesh[i].SetActive(value: false);
		}
		TriangleMesh[currentTriangleType].SetActive(value: true);
	}
}
public class csEditorBeatItem_Waypath : csEditorBeatItem
{
	public csHitObjType m_HitObjType;

	public GameObject[] PrefabArray;

	public csHitObjChild m_HitObjChild;

	public LineRenderer PathLineRnd;

	public GameObject m_BoxObj;

	public Transform m_CliderPerant;

	public float width = 0.2f;

	private int m_SubPointNum = 3;

	private List<BoxCollider> m_boxColliderList = new List<BoxCollider>();

	public List<Vector3> LineRealLoaclPos = new List<Vector3>();

	private GameObject temp;

	public override void InitColorAndType(csBeatItemColor _ItemColor, int _index)
	{
	}

	public override void InitMoveDirAndSpeed(Vector3 Dir, float speed, int angle, bool isDownloadGame = false)
	{
		base.InitMoveDirAndSpeed(Dir, speed, angle);
		InitLine();
		ReturnT += GetAddTime();
	}

	public override void OnColorInverse()
	{
		if (m_BeatItemColor == csBeatItemColor.RWhite)
		{
			SetToColorInGame(csBeatItemColor.LBlack);
		}
		else
		{
			SetToColorInGame(csBeatItemColor.RWhite);
		}
	}

	public void InitLine(bool isDirect = false)
	{
		if ((bool)GameManagerNew.instance)
		{
			LineRealLoaclPos.Clear();
			float num = ((!GameManagerNew.instance.isBroadcastScene) ? GameManagerNew.instance.SongPlayer.beatGapDis : GameManagerNew.instance.SongPlayerH.beatGapDis);
			for (int i = 0; (float)i < (float)LocalWayPathList.Count * 0.85f; i++)
			{
				LineRealLoaclPos.Add(new Vector3(LocalWayPathList[i].x, LocalWayPathList[i].y, LocalWayPathList[i].z / 4f * num));
			}
			SetPathLineRnd(LineRealLoaclPos, withCol: true, isDirect);
		}
		else if ((bool)csTutorialSceneGameManager.instance)
		{
			LineRealLoaclPos.Clear();
			float beatGapDis = csTutorialSceneGameManager.instance.SongPlayer.beatGapDis;
			for (int j = 0; (float)j < (float)LocalWayPathList.Count * 0.85f; j++)
			{
				LineRealLoaclPos.Add(new Vector3(LocalWayPathList[j].x, LocalWayPathList[j].y, LocalWayPathList[j].z / 4f * beatGapDis));
			}
			SetPathLineRnd(LineRealLoaclPos, withCol: true, isDirect);
		}
		else
		{
			LineRealLoaclPos.Clear();
			LineRealLoaclPos.AddRange(LocalWayPathList);
			SetPathLineRnd(LineRealLoaclPos, withCol: false, isDirect);
		}
	}

	public override void SetRotateAngle(int a)
	{
		base.SetRotateAngle(a);
		AngleTurn = a;
	}

	public override void SetToColorInGame(csBeatItemColor c)
	{
		m_BeatItemColor = c;
		m_HitObjChild.SetColor(c);
	}

	private PoolObjectType getEffectType(string id)
	{
		return PoolObjectType.RewardEffect_1;
	}

	public override void OnItemHit(Vector3 forceDir)
	{
		if ((bool)ItemCol)
		{
			ItemCol.enabled = false;
		}
	}

	public override void OnItemMiss()
	{
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public override void OnItemMissFly(Vector3 misHitVel)
	{
	}

	public override void OnItemReset()
	{
		base.OnItemReset();
		rb.useGravity = false;
		rb.SetKinematic(isTrue: true);
		m_HitObjChild.gameObject.SetActive(value: true);
	}

	private void SetPathLineRnd(List<Vector3> pahtPointList, bool withCol, bool isDirect = false)
	{
		if (isDirect)
		{
			PathLineRnd.positionCount = pahtPointList.Count;
			PathLineRnd.SetPositions(pahtPointList.ToArray());
		}
		else
		{
			StartCoroutine(SetPositions(pahtPointList, GetAddTime()));
		}
		if (withCol)
		{
			InitBoxColliderList(pahtPointList);
		}
	}

	private IEnumerator SetPositions(List<Vector3> pahtPointList, float SetTime)
	{
		float GapTime = SetTime / (float)(pahtPointList.Count - 1);
		for (int i = 0; i < pahtPointList.Count; i++)
		{
			PathLineRnd.positionCount = i + 1;
			PathLineRnd.SetPosition(i, pahtPointList[i]);
			yield return new WaitForSeconds(GapTime);
		}
	}

	private void InitBoxColliderList(List<Vector3> pahtPointList)
	{
		Vector3 vector = default(Vector3);
		Vector3 vector2 = default(Vector3);
		bool flag = true;
		m_boxColliderList.Clear();
		for (int i = 0; i < pahtPointList.Count - 1; i += m_SubPointNum)
		{
			vector = pahtPointList[i];
			if (pahtPointList.Count - 1 >= i + m_SubPointNum)
			{
				vector2 = pahtPointList[i + m_SubPointNum];
			}
			else
			{
				vector2 = pahtPointList[pahtPointList.Count - 1];
				flag = false;
			}
			InitBoxByPoint(vector, vector2);
		}
		if (!flag)
		{
			vector = pahtPointList[pahtPointList.Count - 2];
			vector2 = pahtPointList[pahtPointList.Count - 1];
			InitBoxByPoint(vector, vector2);
		}
	}

	private void InitBoxByPoint(Vector3 startPos, Vector3 endPos)
	{
		Vector3 vector = default(Vector3);
		Quaternion quaternion = default(Quaternion);
		Vector3 normalized = (endPos - startPos).normalized;
		float num = Vector3.Distance(startPos, endPos);
		vector = normalized * (num * 0.5f) + startPos;
		quaternion = Quaternion.LookRotation(normalized);
		InitBoxColliderOne(num, vector, quaternion);
	}

	public override void OnItemReturnToPool()
	{
		for (int i = 0; i < m_boxColliderList.Count; i++)
		{
			csObjectPool.Instance.ReturnGameObjectIntoPool(m_boxColliderList[i].gameObject, delay: false);
		}
		base.OnItemReturnToPool();
	}

	private void InitBoxColliderOne(float distance, Vector3 midPoint, Quaternion Rotation)
	{
		GameObject objectByType = csObjectPool.Instance.GetObjectByType(PoolObjectType.LineRndBoxCol, m_CliderPerant.position, m_CliderPerant.forward);
		objectByType.transform.SetParent(m_CliderPerant);
		BoxCollider component = objectByType.GetComponent<BoxCollider>();
		objectByType.SetActive(value: true);
		objectByType.transform.localPosition = midPoint;
		component.size = new Vector3(width, width, distance + distance / 5f);
		objectByType.transform.localRotation = Rotation;
		m_boxColliderList.Add(component);
	}
}
public class csEditorBeatPoint : MonoBehaviour
{
	public float BeatTime;

	public Transform thisT;

	public Material BigBeatM;

	public Material SmallBeatM;

	public Material SmallBeatMSel;

	public Material BigBeatMSel;

	public bool isSmall;

	public MeshRenderer BeatLineMR;

	public TextMeshPro tm;

	public bool isSelected;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void SetTMBig(int x)
	{
		tm.text = x.ToString();
		BeatLineMR.sharedMaterial = BigBeatM;
		isSmall = false;
	}

	public void SetTMSmall(int x)
	{
		BeatLineMR.sharedMaterial = SmallBeatM;
		tm.enabled = false;
		isSmall = true;
	}

	public void OnSelected(bool isSel)
	{
		if (isSel)
		{
			if (BeatLineMR.sharedMaterial == BigBeatM)
			{
				isSmall = false;
			}
			else
			{
				isSmall = true;
			}
		}
		isSelected = isSel;
		if (isSel)
		{
			if (isSmall)
			{
				BeatLineMR.sharedMaterial = SmallBeatMSel;
			}
			else
			{
				BeatLineMR.sharedMaterial = BigBeatMSel;
			}
		}
		else if (isSmall)
		{
			BeatLineMR.sharedMaterial = SmallBeatM;
		}
		else
		{
			BeatLineMR.sharedMaterial = BigBeatM;
		}
	}
}
public class csEditorUIManager : MonoBehaviour
{
	public static csEditorUIManager instance;

	public bool isPunchEditor = true;

	public InputField LevelNameInputFeild;

	public GameObject WallBtnPrefab;

	public Transform WallBtnParent;

	public Button BtnCopy;

	public Button BtnPaste;

	public Button[] HitDirBtn_LBlack;

	public Button[] HitObjBtn_RWhite;

	public Button SwiftKnee_LBlack_L;

	public Button SwiftKnee_LBlack;

	public Button SwiftKnee_LBlack_R;

	public Button SwiftKick_LBlack;

	public Button SwiftTrample_LBlack;

	public Button SwiftKnee_RWhite_L;

	public Button SwiftKnee_RWhite;

	public Button SwiftKnee_RWhite_R;

	public Button SwiftKick_RWhite;

	public Button SwiftTrample_RWhite;

	public Button RStickUp;

	public Transform RStickUpT;

	public Button RStickDown;

	public Transform RStickDownT;

	public Button LStickUp;

	public Transform LStickUpT;

	public Button LStickDown;

	public Transform LStickDownT;

	public InputField StickAngleField;

	public Button ConfirmStickAngle;

	public Button DefenseBtn;

	public Button FinishBtn;

	public Button DeleteBtn;

	public Button BtnHoleStart;

	public Button BtnHoleEnd;

	public Button BtnLineStart;

	public Button BtnLineMid;

	public Button BtnLineEnd;

	public Button BtnFindPathStart;

	public Button BtnLFootHint;

	public Button BtnRFootHint;

	public Button BtnLturnBlack;

	public Button BtnRturnWhite;

	public Button BtnLturnWhite;

	public Button BtnRturnBlack;

	public Button BtnConfirmAngle;

	public Text CurrentDirection;

	public InputField TurnAngleField;

	public RectTransform DirHintArrow;

	public Slider ScheduleSlider;

	public Button SetScrollValueBtn;

	public InputField ScrollValueInputField;

	public GridLayoutGroup ScrollGridLayoutGroup;

	public RectTransform GridRectTrans;

	public Button nextTrackBtn;

	public Button lastTrackBtn;

	public Text currentTrackNum;

	public int currentTrack = 1;

	public Transform m_camera;

	public Transform[] lines;

	public Text currentSongPlayTime;

	public InputField MoveSelValue;

	public Button MoveSelObject;

	private int anglestick;

	private Transform beatLine;

	public InputField PrefabKey;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		ScheduleSlider.onValueChanged.AddListener(OnScheduleSliderValueChanged);
		for (int i = 0; i < HitDirBtn_LBlack.Length; i++)
		{
			int temp = i;
			HitDirBtn_LBlack[i].onClick.AddListener(delegate
			{
				SelectHitObj(csBeatItemColor.LBlack, (csHitObjType)temp);
			});
		}
		if (isPunchEditor)
		{
			SwiftKnee_LBlack_L.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.LBlack, csHitObjType.LM);
			});
			SwiftKnee_LBlack.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.LBlack);
			});
			SwiftKnee_LBlack_R.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.LBlack, csHitObjType.RM);
			});
			SwiftKick_LBlack.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKick, csBeatItemColor.LBlack);
			});
			SwiftTrample_LBlack.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftTrample, csBeatItemColor.LBlack);
			});
			SwiftKnee_RWhite_L.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.RWhite, csHitObjType.LM);
			});
			SwiftKnee_RWhite.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.RWhite);
			});
			SwiftKnee_RWhite_R.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKnee, csBeatItemColor.RWhite, csHitObjType.RM);
			});
			SwiftKick_RWhite.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftKick, csBeatItemColor.RWhite);
			});
			SwiftTrample_RWhite.onClick.AddListener(delegate
			{
				SelectSwiftObj(csBeatItemType.SwiftTrample, csBeatItemColor.RWhite);
			});
		}
		SetCurDirection(int.Parse(TurnAngleField.text));
		TurnAngleField.onSubmit.AddListener(delegate(string s)
		{
			SetCurDirection(int.Parse(s));
		});
		DefenseBtn.onClick.AddListener(delegate
		{
			SelectHitObjDefense();
		});
		FinishBtn.onClick.AddListener(delegate
		{
			SelectHitObjFinish();
		});
		DeleteBtn.onClick.AddListener(delegate
		{
			DeleteSelectRol();
		});
		BtnCopy.onClick.AddListener(delegate
		{
			CopySelectTimeZone();
		});
		BtnPaste.onClick.AddListener(delegate
		{
			PasteSelectTimeZone();
		});
		BtnHoleStart.onClick.AddListener(delegate
		{
			SelectHoleObj(isStartHole: true, int.Parse(TurnAngleField.text));
		});
		BtnHoleEnd.onClick.AddListener(delegate
		{
			SelectHoleObj(isStartHole: false, int.Parse(TurnAngleField.text));
		});
		if (!isPunchEditor)
		{
			BtnLineStart.onClick.AddListener(delegate
			{
				SelectLineObj(csBeatCurvePointType.Start);
			});
			BtnLineMid.onClick.AddListener(delegate
			{
				SelectLineObj(csBeatCurvePointType.Mid);
			});
			BtnLineEnd.onClick.AddListener(delegate
			{
				SelectLineObj(csBeatCurvePointType.End);
			});
			BtnFindPathStart.onClick.AddListener(delegate
			{
				FindPathStart();
			});
		}
		if ((bool)BtnLFootHint)
		{
			BtnLFootHint.onClick.AddListener(delegate
			{
				SelectFootObj(isLFoot: true);
			});
		}
		if ((bool)BtnRFootHint)
		{
			BtnRFootHint.onClick.AddListener(delegate
			{
				SelectFootObj(isLFoot: false);
			});
		}
		BtnLturnBlack.onClick.AddListener(delegate
		{
			SelectTurningObj(csBeatItemColor.LBlack, isLeft: true, int.Parse(TurnAngleField.text));
		});
		BtnRturnWhite.onClick.AddListener(delegate
		{
			SelectTurningObj(csBeatItemColor.RWhite, isLeft: false, int.Parse(TurnAngleField.text));
		});
		BtnLturnWhite.onClick.AddListener(delegate
		{
			SelectTurningObj(csBeatItemColor.RWhite, isLeft: true, int.Parse(TurnAngleField.text));
		});
		BtnRturnBlack.onClick.AddListener(delegate
		{
			SelectTurningObj(csBeatItemColor.LBlack, isLeft: false, int.Parse(TurnAngleField.text));
		});
		MoveSelValue.text = "1";
		MoveSelObject.onClick.AddListener(delegate
		{
			csMusicEditor.instance.MoveSelectedTimeZone(float.Parse(MoveSelValue.text));
		});
		if ((bool)nextTrackBtn)
		{
			nextTrackBtn.onClick.AddListener(delegate
			{
				changeTrack(isNext: true);
			});
		}
		if ((bool)lastTrackBtn)
		{
			lastTrackBtn.onClick.AddListener(delegate
			{
				changeTrack(isNext: false);
			});
		}
		BtnConfirmAngle.onClick.AddListener(delegate
		{
			SelectHitObjFinish();
		});
		for (int j = 0; j < HitObjBtn_RWhite.Length; j++)
		{
			int temp2 = j;
			HitObjBtn_RWhite[j].onClick.AddListener(delegate
			{
				SelectHitObj(csBeatItemColor.RWhite, (csHitObjType)temp2);
			});
		}
		ScrollValueInputField.text = csMusicEditor.instance.ScrollAccr.ToString();
		SetScrollValueBtn.onClick.AddListener(delegate
		{
			csMusicEditor.instance.ScrollAccr = float.Parse(ScrollValueInputField.text);
		});
		for (int k = 0; k < csMusicEditor.instance.WallPrefabs.Count; k++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(WallBtnPrefab, WallBtnParent);
			obj.transform.localScale = Vector3.one;
			string tempid = csMusicEditor.instance.WallPrefabs[k].WallID;
			string tempname = csMusicEditor.instance.WallPrefabs[k].WallName;
			int index = k;
			obj.GetComponent<Button>().onClick.AddListener(delegate
			{
				UnityEngine.Debug.LogError("墙：" + tempname);
				SelectWallObj(index, tempid, int.Parse(TurnAngleField.text));
			});
			obj.GetComponentInChildren<Text>().text = "";
			obj.GetComponentInChildren<Image>().sprite = csMusicEditor.instance.WallPrefabs[k].WallSprite;
		}
		SetGridHeight(3);
		if (!isPunchEditor)
		{
			InitStickButtonAngle();
			ConfirmStickAngle.onClick.AddListener(InitStickButtonAngle);
			LStickUp.onClick.AddListener(delegate
			{
				SelectHitObjWithAngle(csBeatItemColor.LBlack, -anglestick);
			});
			LStickDown.onClick.AddListener(delegate
			{
				SelectHitObjWithAngle(csBeatItemColor.LBlack, -anglestick + 180);
			});
			RStickUp.onClick.AddListener(delegate
			{
				SelectHitObjWithAngle(csBeatItemColor.RWhite, -anglestick);
			});
			RStickDown.onClick.AddListener(delegate
			{
				SelectHitObjWithAngle(csBeatItemColor.RWhite, -anglestick + 180);
			});
		}
	}

	private void InitStickButtonAngle()
	{
		anglestick = int.Parse(StickAngleField.text);
		RStickUpT.localEulerAngles = new Vector3(0f, 0f, -anglestick);
		RStickDownT.localEulerAngles = new Vector3(0f, 0f, -anglestick + 180);
		LStickUpT.localEulerAngles = new Vector3(0f, 0f, -anglestick);
		LStickDownT.localEulerAngles = new Vector3(0f, 0f, -anglestick + 180);
	}

	public void changeTrack(bool isNext)
	{
		beatLine = csMusicEditor.instance.CurMusicPrefab.GetComponent<csMusicPrefabData>().BeatLineT;
		if (isNext)
		{
			if (currentTrack >= 3)
			{
				return;
			}
			currentTrack++;
			m_camera.DOLocalMoveX(1.42f + (float)((currentTrack - 1) * 4), 0.5f);
		}
		else
		{
			if (currentTrack <= 1)
			{
				return;
			}
			currentTrack--;
			m_camera.DOLocalMoveX(1.42f + (float)((currentTrack - 1) * 4), 0.5f);
		}
		beatLine.SetParent(lines[currentTrack - 1]);
		beatLine.localPosition = Vector3.zero;
		beatLine.SetParent(csMusicEditor.instance.CurMusicPrefab.transform);
		currentTrackNum.text = currentTrack.ToString();
	}

	private void SetGridHeight(int num)
	{
		int num2 = (int)((float)ScrollGridLayoutGroup.transform.childCount + (float)num - 1f) / num;
		float num3 = (float)num2 * ScrollGridLayoutGroup.cellSize.y;
		num3 += (float)(num2 - 1) * ScrollGridLayoutGroup.spacing.y;
		num3 += (float)(ScrollGridLayoutGroup.padding.top + ScrollGridLayoutGroup.padding.bottom);
		GridRectTrans.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, num3);
	}

	public void SaveLevelPrefab()
	{
		csMusicEditor.instance.SaveEditorMusicToPrefab(LevelNameInputFeild.text);
	}

	public void SaveItemGroupPrefab()
	{
		csMusicEditor.instance.SaveSelectedGruopToPrefab(PrefabKey.text);
	}

	public void InstantiateItemGruopPrefab()
	{
		csMusicEditor.instance.InstantiateGroupPrefab(PrefabKey.text);
	}

	private void Update()
	{
		ScheduleSlider.value = csMusicEditor.instance.SliderPercent;
		if (Input.GetKeyDown(KeyCode.Delete))
		{
			DeleteSelectRol();
		}
		currentSongPlayTime.text = csMusicEditor.instance.ass.time.ToString();
	}

	private void OnScheduleSliderValueChanged(float value)
	{
		if (Input.GetMouseButtonUp(0) || Input.GetMouseButtonDown(0))
		{
			UnityEngine.Debug.LogError("OnScheduleSliderValueChanged:" + value);
			csMusicEditor.instance.SetSliderPercentByUI(value);
		}
	}

	public void FindPathStart()
	{
		if (!csCurvePointDot.currentStartPoint)
		{
			UnityEngine.Debug.LogError("未发现起始点");
		}
	}

	private void SelectSwiftObj(csBeatItemType bType, csBeatItemColor _ItemColor, csHitObjType ht = csHitObjType.MM)
	{
		if (bType == csBeatItemType.SwiftKnee)
		{
			csMusicEditor.instance.CreatBeatItem(bType, _ItemColor, (int)ht);
		}
		else
		{
			csMusicEditor.instance.CreatBeatItem(bType, _ItemColor, -1);
		}
	}

	private void SelectHitObj(csBeatItemColor _ItemColor, csHitObjType _type)
	{
		if (isPunchEditor)
		{
			if (_type != csHitObjType.MM)
			{
				csMusicEditor.instance.CreatBeatItem(csBeatItemType.Direction, _ItemColor, (int)_type);
			}
			else
			{
				csMusicEditor.instance.CreatBeatItem(csBeatItemType.Normal, _ItemColor, (int)_type);
			}
		}
		else if (_type != csHitObjType.MM)
		{
			csMusicEditor.instance.CreatBeatItem(csBeatItemType.StickDirection, _ItemColor, (int)_type);
		}
		else
		{
			csMusicEditor.instance.CreatBeatItem(csBeatItemType.Way, _ItemColor, (int)_type);
		}
	}

	private void SelectHitObjWithAngle(csBeatItemColor _ItemColor, int angle)
	{
		if (isPunchEditor)
		{
			csMusicEditor.instance.CreatBeatItem(csBeatItemType.Direction, _ItemColor, 0);
		}
		else
		{
			csMusicEditor.instance.CreatBeatItemWithRotation(csBeatItemType.StickDirection, _ItemColor, angle);
		}
	}

	private void DeleteSelectRol()
	{
		csMusicEditor.instance.DeleteSelectRolItem();
	}

	private void SelectHoleObj(bool isStartHole, int angle)
	{
		UnityEngine.Debug.LogError("AngleGet:" + angle);
		csMusicEditor.instance.CreatHoleBeatItem(isStartHole, angle);
	}

	private void SelectLineObj(csBeatCurvePointType curveType)
	{
		csMusicEditor.instance.CreatLineBeatItem(curveType);
	}

	private void SelectFootObj(bool isLFoot)
	{
		csMusicEditor.instance.CreatFootBeatItem(isLFoot);
	}

	private void SelectTurningObj(csBeatItemColor _ItemColor, bool isLeft, int angle)
	{
		UnityEngine.Debug.LogError("AngleGet:" + angle);
		csMusicEditor.instance.CreatTurningBeatItem(csBeatItemType.Turning, _ItemColor, isLeft, angle);
	}

	private void SelectHitObjDefense()
	{
		csMusicEditor.instance.CreatBeatItem(csBeatItemType.Defence, csBeatItemColor.LBlack, -1);
	}

	private void SelectHitObjFinish()
	{
		csMusicEditor.instance.CreatBeatItem(csBeatItemType.Reward, csBeatItemColor.LBlack, -1);
	}

	private void SelectWallObj(int index, string WallID, int zAngle)
	{
		if (!isPunchEditor)
		{
			zAngle = 0;
		}
		csMusicEditor.instance.CreatWallItem(index, zAngle);
	}

	public void CopySelectTimeZone()
	{
		csMusicEditor.instance.CopySelectedTimeZone();
	}

	public void PasteSelectTimeZone()
	{
		csMusicEditor.instance.PasteSelectedTimeZone();
	}

	public void SetCurDirection(int finalAngle)
	{
		CurrentDirection.text = finalAngle.ToString();
		DirHintArrow.localEulerAngles = new Vector3(0f, 0f, -finalAngle);
	}
}
public class csEditorUIManagerVideoFollow : MonoBehaviour
{
	public static csEditorUIManagerVideoFollow instance;

	public InputField LevelNameInputFeild;

	public Button BtnCopy;

	public Button BtnPaste;

	public Button CheckPointStartBtn;

	public Button CheckPointEndBtn;

	public Button HeadHandGroupBtn;

	public Button MultiMoveBtn;

	public Button MultiChildMoveBtn;

	public Button InteractableBtn;

	public Slider ScheduleSlider;

	public Button SetScrollValueBtn;

	public InputField ScrollValueInputField;

	public GridLayoutGroup ScrollGridLayoutGroup;

	public RectTransform GridRectTrans;

	public Transform m_camera;

	public Text currentSongPlayTime;

	public InputField MoveSelValue;

	public Button MoveSelObject;

	private Transform beatLine;

	public InputField PrefabKey;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		ScheduleSlider.onValueChanged.AddListener(OnScheduleSliderValueChanged);
		BtnCopy.onClick.AddListener(delegate
		{
			CopySelectTimeZone();
		});
		BtnPaste.onClick.AddListener(delegate
		{
			PasteSelectTimeZone();
		});
		CheckPointStartBtn.onClick.AddListener(delegate
		{
			SelectCheckPointObj(isStartHole: true);
		});
		CheckPointEndBtn.onClick.AddListener(delegate
		{
			SelectCheckPointObj(isStartHole: false);
		});
		HeadHandGroupBtn.onClick.AddListener(delegate
		{
			SelectVideoItem(VFllowItemType.MovementJudge);
		});
		MultiMoveBtn.onClick.AddListener(delegate
		{
			SelectVideoItem(VFllowItemType.MultiMovement);
		});
		MultiChildMoveBtn.onClick.AddListener(delegate
		{
			SelectVideoItem(VFllowItemType.MultiMovementChild);
		});
		InteractableBtn.onClick.AddListener(delegate
		{
			SelectVideoItem(VFllowItemType.Interactable);
		});
		MoveSelValue.text = "1";
		MoveSelObject.onClick.AddListener(delegate
		{
			csMusicEditorVideoFollow.instance.MoveSelectedTimeZone(float.Parse(MoveSelValue.text));
		});
		ScrollValueInputField.text = csMusicEditorVideoFollow.instance.ScrollAccr.ToString();
		SetScrollValueBtn.onClick.AddListener(delegate
		{
			csMusicEditorVideoFollow.instance.ScrollAccr = float.Parse(ScrollValueInputField.text);
		});
	}

	public void SaveLevelPrefab()
	{
		csMusicEditorVideoFollow.instance.SaveEditorMusicToPrefab(LevelNameInputFeild.text);
	}

	public void SaveItemGroupPrefab()
	{
		csMusicEditorVideoFollow.instance.SaveSelectedGruopToPrefab(PrefabKey.text);
	}

	private void Update()
	{
		ScheduleSlider.value = csMusicEditorVideoFollow.instance.SliderPercent;
		if (Input.GetKeyDown(KeyCode.Delete))
		{
			DeleteSelectRol();
		}
		currentSongPlayTime.text = csMusicEditorVideoFollow.instance.vp.time.ToString();
	}

	private void OnScheduleSliderValueChanged(float value)
	{
		if (Input.GetMouseButtonUp(0) || Input.GetMouseButtonDown(0))
		{
			UnityEngine.Debug.LogError("OnScheduleSliderValueChanged:" + value);
			csMusicEditorVideoFollow.instance.SetSliderPercentByUI(value);
		}
	}

	public void FindPathStart()
	{
		if (!csCurvePointDot.currentStartPoint)
		{
			UnityEngine.Debug.LogError("未发现起始点");
		}
	}

	private void SelectVideoItem(VFllowItemType type)
	{
		csMusicEditorVideoFollow.instance.CreatBeatItem(type, -1);
	}

	private void SelectVideoItemInteractable(VFllowItemType type, int intactType)
	{
		csMusicEditorVideoFollow.instance.CreatBeatItem(type, intactType);
	}

	private void DeleteSelectRol()
	{
		csMusicEditorVideoFollow.instance.DeleteSelectRolItem();
	}

	private void SelectCheckPointObj(bool isStartHole)
	{
		csMusicEditorVideoFollow.instance.CreatHoleBeatItem(isStartHole);
	}

	public void CopySelectTimeZone()
	{
		csMusicEditorVideoFollow.instance.CopySelectedTimeZone();
	}

	public void PasteSelectTimeZone()
	{
		csMusicEditorVideoFollow.instance.PasteSelectedTimeZone();
	}
}
[CreateAssetMenu(menuName = "Chesstar/Create MyScriptableObject ")]
public class csGameProfile : ScriptableObject
{
	public string Version = "0.9.3.0";

	public int VersionCode = 4;

	public string ProductName = "HiBow";

	public ChannelType CurrentChannel;

	public ReleaseType CurrentReleaseType = ReleaseType.Official;

	public bool IsInternal;

	public bool IsMRC;

	public bool UseNoAccount;

	public bool IsCNMainLand = true;

	public bool TimeLock = true;

	public bool testLogin;

	public bool testPicoLogin;

	public bool testPicoGetInfo;

	public bool testPlayfabLogin;

	public bool testPlayfabGetInfo;

	public bool isSelfHostServerData;

	public bool isSuperGorillaTest;
}
public class csGameSettings : MonoBehaviour
{
	public static bool isLoading = false;

	public static bool inited = false;

	public static bool isLogined = false;

	public static bool IsOfflineVersion = false;

	public static DateTime TempVIPEndDate;

	public static string OfflineHint;

	public static XRDeviceType CurrentDevice = XRDeviceType.PicoNeo3;

	public static csGameProfile profile;

	public static float m_MaxBGVolume = 1f;

	public static float m_MInBGVolume = 0.3f;

	public static float OnMissDistance = 1f;

	private static HitSoundEffectType CurrentHitSEType;

	public static float GlobalVol = 1.6f;

	public static string currentStage = "";

	private static bool playerPlatformOn = true;

	public static GameScene currGameScene = GameScene.Main;

	public static float handCalWeight = 0.2f;

	public static float headCalWeight = 2f;

	private static bool playerCurrentDataOn = true;

	public static bool dontNeedShowLogo = false;

	public static bool needReLogin = false;

	private static bool comboShow = true;

	public static DateTime FreePlayEndTime = new DateTime(2023, 6, 30, 23, 59, 59);

	private static float soundeffectvol = 1f;

	private static float hitFXVol = 1f;

	private static float musicvol = 1f;

	private static float micvol = 1f;

	private static float voicevol = 1f;

	private static float coachvoicevol = 1f;

	public static Vector3 CenterHolePos = new Vector3(0f, 1.2f, 0f);

	public static float XYScale = 1f;

	public static float PerfectHitZOffset = 1.334f;

	public const string PlayerIdentifier = "V1";

	public static float triangleStd = 0.95f;

	public static float[] levelMinSpeed = new float[4] { 0.1f, 2f, 4f, 5f };

	public static float[] levelMinStickSpeed = new float[4] { 0.1f, 0.5f, 0.5f, 5f };

	public static float DirAngleOffset = 80f;

	public static ServerRegion DefaultRegion = ServerRegion.China;

	public static bool canMRC = true;

	public static string UserAgreementUrl = "http://chesstar.com/olympia/useragreement/";

	public static string PravicyPolicyUrl = "http://chesstar.com/olympia/privacypolicy/";

	public static HitSoundEffectType currentHitSEType
	{
		get
		{
			return CurrentHitSEType;
		}
		set
		{
			CurrentHitSEType = value;
			PlayerPrefs.SetInt("HitSoundEffectTypeV2", (int)currentHitSEType);
		}
	}

	public static bool PlayerPlatformOn
	{
		get
		{
			return playerPlatformOn;
		}
		set
		{
			playerPlatformOn = value;
			PlayerPrefs.SetInt("isPlatformOpenedV2", value ? 1 : 0);
		}
	}

	public static bool PlayerCurrentDataOn
	{
		get
		{
			return playerCurrentDataOn;
		}
		set
		{
			playerCurrentDataOn = value;
			PlayerPrefs.SetInt("isCurrentDataOpened", value ? 1 : 0);
		}
	}

	public static bool ComboShow
	{
		get
		{
			return comboShow;
		}
		set
		{
			comboShow = value;
			PlayerPrefs.SetInt("isComboOpened", value ? 1 : 0);
		}
	}

	public static float SoundEffectVol
	{
		get
		{
			return soundeffectvol;
		}
		set
		{
			soundeffectvol = value;
			PlayerPrefs.SetFloat("SoundEffectVolV2", value);
		}
	}

	public static float HitFXVol
	{
		get
		{
			return hitFXVol;
		}
		set
		{
			hitFXVol = value;
			PlayerPrefs.SetFloat("HitFXVol", value);
		}
	}

	public static float MusicVol
	{
		get
		{
			return musicvol;
		}
		set
		{
			musicvol = value;
			PlayerPrefs.SetFloat("MusicVolV2", value);
		}
	}

	public static float MicVol
	{
		get
		{
			return micvol;
		}
		set
		{
			micvol = value;
			RtcService.SetCaptureVolume((int)(400f * micvol));
			PlayerPrefs.SetFloat("MicVolV2", value);
		}
	}

	public static float VoiceVol
	{
		get
		{
			return voicevol;
		}
		set
		{
			voicevol = value;
			RtcService.SetEarMonitorVolume((int)(400f * micvol));
			PlayerPrefs.SetFloat("VoiceVolV2", value);
		}
	}

	public static float CoachVoiceVol
	{
		get
		{
			return coachvoicevol;
		}
		set
		{
			coachvoicevol = value;
			PlayerPrefs.SetFloat("CoachVoiceVolV2", value);
		}
	}

	public static ChannelType currentChannel => profile.CurrentChannel;

	public static string GameVersion => profile.Version;

	public static ServerRegion CurServer
	{
		get
		{
			return (ServerRegion)PlayerPrefs.GetInt("SelectRegion", (int)DefaultRegion);
		}
		set
		{
			PlayerPrefs.SetInt("SelectRegion", (int)value);
		}
	}

	public static bool useInternalAppID => profile.IsInternal;

	public static bool IsMRCPackage => profile.IsMRC;

	public static void InitDevice()
	{
		CurrentDevice = XRDeviceType.PicoNeo3;
		if (PXR_Input.GetControllerDeviceType() == PXR_Input.ControllerDevice.PICO_4)
		{
			CurrentDevice = XRDeviceType.Pico4;
		}
		playerPlatformOn = PlayerPrefs.GetInt("isPlatformOpenedV2", 1) == 1;
		playerCurrentDataOn = PlayerPrefs.GetInt("isCurrentDataOpened", 1) == 1;
		comboShow = PlayerPrefs.GetInt("isComboOpened", 1) == 1;
		soundeffectvol = PlayerPrefs.GetFloat("SoundEffectVolV2", 0.75f);
		musicvol = PlayerPrefs.GetFloat("MusicVolV2", 0.75f);
		micvol = PlayerPrefs.GetFloat("MicVolV2", 0.75f);
		voicevol = PlayerPrefs.GetFloat("VoiceVolV2", 0.75f);
		coachvoicevol = PlayerPrefs.GetFloat("CoachVoiceVolV2", 0.75f);
		profile = Resources.Load<csGameProfile>("GameProfile");
		inited = true;
	}
}
public class csHitObjChild : MonoBehaviour
{
	public csEditorBeatItem ParentItem;

	public GameObject[] RedObjs;

	private SphereCollider RedSpCol;

	private float OriRedRad = 1f;

	public GameObject[] BlueObjs;

	private SphereCollider BlueSpCol;

	private float OriBlueRad = 1f;

	private void Awake()
	{
		for (int i = 0; i < RedObjs.Length; i++)
		{
			SphereCollider componentInChildren = RedObjs[i].GetComponentInChildren<SphereCollider>(includeInactive: true);
			if (componentInChildren != null && (bool)componentInChildren.GetComponent<csBeatChild>())
			{
				RedSpCol = componentInChildren;
				OriRedRad = RedSpCol.radius;
			}
		}
		for (int j = 0; j < BlueObjs.Length; j++)
		{
			SphereCollider componentInChildren2 = BlueObjs[j].GetComponentInChildren<SphereCollider>(includeInactive: true);
			if (componentInChildren2 != null && (bool)componentInChildren2.GetComponent<csBeatChild>())
			{
				BlueSpCol = componentInChildren2;
				OriBlueRad = BlueSpCol.radius;
			}
		}
	}

	public void SetColor(csBeatItemColor _color)
	{
		for (int i = 0; i < RedObjs.Length; i++)
		{
			RedObjs[i].SetActive(_color == csBeatItemColor.LBlack);
		}
		for (int j = 0; j < BlueObjs.Length; j++)
		{
			BlueObjs[j].SetActive(_color == csBeatItemColor.RWhite);
		}
	}

	public void SetScale(float colScale)
	{
		if ((bool)RedSpCol)
		{
			RedSpCol.radius = OriRedRad * colScale;
		}
		if ((bool)BlueSpCol)
		{
			BlueSpCol.radius = OriBlueRad * colScale;
		}
	}
}
public class csLevelEditor : MonoBehaviour
{
	public int m_LevelIndex;

	public float m_CarMoveSpeed;

	public GameObject[] m_CarPrefabs;

	public GameObject[] m_HitPointPrefabs;

	public GameObject[] m_DoorPrefabs;

	public BeatDetection m_BeatDetection;

	public AudioSource m_AudioPlayer;

	public GameObject m_BeatPoint;

	public Transform m_BeatLine;

	public Transform m_CameraT;

	public Transform m_LevelObjsT;

	private bool m_RecordBeatPoint;

	private bool m_CheckBeatPoint;

	public Transform beats;

	private float m_MusicLength;

	private float time;

	private float m_RecordTime;

	private int index = 1;

	private Ray ray;

	private RaycastHit hit;

	private float currentPos;

	private void Awake()
	{
	}

	private void Update()
	{
	}

	private void onOnbeatDetected(BeatDetection.EventInfo eventInfo)
	{
		if (m_RecordBeatPoint)
		{
			GameObject obj = UnityEngine.Object.Instantiate(m_BeatPoint);
			csBeatPoint component = obj.GetComponent<csBeatPoint>();
			obj.transform.SetParent(beats.transform);
			component.SetPointT(eventInfo);
			obj.transform.localPosition = new Vector3(Time.realtimeSinceStartup - m_RecordTime, 0f, 0f);
		}
	}

	private void OnGUI()
	{
	}
}
public class csMainSceneAudioPlayer : MonoBehaviour
{
	public static csMainSceneAudioPlayer instance;

	public AudioSource ASSplayer2D;

	public List<AduioClipObject> AObjectList = new List<AduioClipObject>();

	private Dictionary<string, AudioClip> ClipByName = new Dictionary<string, AudioClip>();

	private void Awake()
	{
		instance = this;
		for (int i = 0; i < AObjectList.Count; i++)
		{
			ClipByName.Add(AObjectList[i].AduioName, AObjectList[i].m_Clip);
		}
		ASSplayer2D.volume = 1f;
	}

	private void OnDestroy()
	{
	}

	public void OnAudioVolChange()
	{
		ASSplayer2D.volume = 1f;
	}

	public void PlayAudio2D(string name, float vol = 1f)
	{
		ASSplayer2D.PlayOneShot(ClipByName[name], csGameSettings.SoundEffectVol);
	}

	public void PlayAudio2DClip(AudioClip ac, float vol = 1f)
	{
		ASSplayer2D.PlayOneShot(ac, csGameSettings.SoundEffectVol);
	}

	public void PlayAudio(string name, Vector3 pos, float vol = 1f)
	{
		AudioSource.PlayClipAtPoint(ClipByName[name], pos, vol);
	}
}
[Serializable]
public class AduioClipObject
{
	public string AduioName;

	public AudioClip m_Clip;
}
public class csMusicEditor : MonoBehaviour
{
	public bool isPunchEditor = true;

	[Header("是否取用现成Prefab")]
	public bool UseBeatPrefab;

	[Header("被编辑的现成Prefab")]
	public GameObject BeatPrefab;

	public bool UseBeatDataInGame;

	[Header("被编辑的现成DataInGame")]
	public GameObject BeatGameData;

	private float moveSpeed = 1f;

	public Transform thisT;

	public bool StartMove;

	public AudioSource ass;

	public GameObject beat_B;

	public GameObject DetectedBeat_B;

	public Transform line;

	public GameObject MusicCaseParent;

	[HideInInspector]
	public GameObject CurMusicPrefab;

	private csMusicPrefabData curMusicData;

	public GameObject EditorUIObj;

	public GameObject beatItem_1;

	[Header("歌曲长度（需略长于歌曲原长）")]
	public float MusicTime = 150f;

	[Header("每分节拍数")]
	public int beatCount = 168;

	[Header("每大节有几小拍")]
	public int beatCountInCol = 4;

	[Header("大拍间隔时间（秒）无法设置")]
	public float beatGapTime;

	[HideInInspector]
	public float beatGapDis = 4f;

	[Header("滚轮精确度")]
	public float ScrollAccr = 1f;

	[Header("当前编辑点位置 无法设置")]
	public float selectBeatIndex;

	[Header("歌曲播放速度")]
	public float BGMSpeed = 1f;

	public static csMusicEditor instance;

	public csEditorBeatItemPos selectBeatItemPos;

	public Transform WallTrans;

	public Transform LevelRootT;

	public GameObject BRHintItem;

	public GameObject HoleStart;

	public GameObject HoleEnd;

	public GameObject FootHintRing;

	public GameObject DirectionItemPrefab;

	public GameObject StickDirectionItemPrefab;

	public GameObject WayItemPrefab;

	public GameObject NormalItemPrefab;

	public GameObject DefenseItemPrefab;

	public GameObject RewardItemPrefab;

	public GameObject RotateItemPrefab;

	public GameObject SwiftKneeItemPrefab;

	public GameObject SwiftKickItemPrefab;

	public GameObject SwiftTrampleItemPrefab;

	public GameObject PointItemPrefab;

	public GameObject WayPointStartItemPrefab_InGame;

	public List<csEditorBeatItem_Wall> WallPrefabs = new List<csEditorBeatItem_Wall>();

	public Material ItemMaterial_Red;

	public Material ItemMaterial_Blue;

	private SpectralFluxAnalyzer preProcessedSpectralFluxAnalyzer;

	private bool AnalyzerDone;

	private int numChannels;

	private int numTotalSamples;

	private int sampleRate;

	private float clipLength;

	private float[] multiChannelSamples;

	private Tweener RotateTween;

	public PrefabCreator PCreator;

	public float SliderPercent;

	private Ray ray;

	private RaycastHit hit;

	private float MinSelTime = 9999f;

	private float moveMinSelTime = 9999f;

	private float MaxSelTime;

	private float MinSelTimeByBeat = 9999f;

	private bool ShouldClearSelect;

	private List<csEditorBeatPoint> SelBeatPointList = new List<csEditorBeatPoint>();

	private List<csEditorBeatItem> CopyList = new List<csEditorBeatItem>();

	private List<csEditorBeatItem> MoveList = new List<csEditorBeatItem>();

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		thisT = base.transform;
	}

	private void Start()
	{
		if (UseBeatPrefab && (bool)BeatPrefab)
		{
			CreatBeat(BeatPrefab);
		}
		else if (UseBeatDataInGame && (bool)BeatGameData)
		{
			CreatBeatObjByData(beatCount, beatCountInCol, BeatGameData);
		}
		else
		{
			CreatBeat(beatCount, beatCountInCol);
		}
		DoSongBeatDetect();
	}

	public void DoSongBeatDetect()
	{
		preProcessedSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
		multiChannelSamples = new float[ass.clip.samples * ass.clip.channels];
		numChannels = ass.clip.channels;
		numTotalSamples = ass.clip.samples;
		clipLength = ass.clip.length;
		sampleRate = ass.clip.frequency;
		ass.clip.GetData(multiChannelSamples, 0);
		UnityEngine.Debug.Log("GetData done");
		Thread thread = new Thread(getFullSpectrumThreaded);
		UnityEngine.Debug.Log("Starting Background Thread");
		thread.Start();
	}

	private void OnBeatDetectDone()
	{
		UnityEngine.Debug.Log(preProcessedSpectralFluxAnalyzer.spectralFluxSamples);
		UnityEngine.Debug.Log(preProcessedSpectralFluxAnalyzer.spectralFluxSamples[0].time);
		UnityEngine.Debug.Log(preProcessedSpectralFluxAnalyzer.spectralFluxSamples[0].isPeak);
		UnityEngine.Debug.Log("Starting Background Done");
		for (int i = 0; i < preProcessedSpectralFluxAnalyzer.spectralFluxSamples.Count; i++)
		{
			if (preProcessedSpectralFluxAnalyzer.spectralFluxSamples[i].isPeak)
			{
				GameObject obj = UnityEngine.Object.Instantiate(DetectedBeat_B, new Vector3(0f, 0f, preProcessedSpectralFluxAnalyzer.spectralFluxSamples[i].time * beatGapDis), Quaternion.identity);
				obj.transform.SetParent(curMusicData.BeatLineT);
				obj.GetComponent<csEditorBeatHint>().SetHintTrans(preProcessedSpectralFluxAnalyzer.spectralFluxSamples[i].spectralFlux);
			}
		}
	}

	public void getFullSpectrumThreaded()
	{
		try
		{
			float[] array = new float[numTotalSamples];
			int num = 0;
			float num2 = 0f;
			for (int i = 0; i < multiChannelSamples.Length; i++)
			{
				num2 += multiChannelSamples[i];
				if ((i + 1) % numChannels == 0)
				{
					array[num] = num2 / (float)numChannels;
					num++;
					num2 = 0f;
				}
			}
			UnityEngine.Debug.Log("Combine Channels done");
			UnityEngine.Debug.Log(array.Length);
			int num3 = 1024;
			int num4 = array.Length / num3;
			FFT fFT = new FFT();
			fFT.Initialize((uint)num3);
			UnityEngine.Debug.Log($"Processing {num4} time domain samples for FFT");
			double[] array2 = new double[num3];
			for (int j = 0; j < num4; j++)
			{
				Array.Copy(array, j * num3, array2, 0, num3);
				double[] array3 = DSP.Window.Coefficients(DSP.Window.Type.Hanning, (uint)num3);
				double[] timeSeries = DSP.Math.Multiply(array2, array3);
				double b = DSP.Window.ScaleFactor.Signal(array3);
				double[] a = DSP.ConvertComplex.ToMagnitude(fFT.Execute(timeSeries));
				a = DSP.Math.Multiply(a, b);
				float time = getTimeFromIndex(j) * (float)num3;
				preProcessedSpectralFluxAnalyzer.analyzeSpectrum(Array.ConvertAll(a, (double x) => (float)x), time);
			}
			UnityEngine.Debug.Log("Spectrum Analysis done");
			UnityEngine.Debug.Log("Background Thread Completed");
			AnalyzerDone = true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log(ex.ToString());
		}
	}

	public float getTimeFromIndex(int index)
	{
		return 1f / (float)sampleRate * (float)index;
	}

	private void CreatBeat(GameObject go)
	{
		CurMusicPrefab = UnityEngine.Object.Instantiate(go);
		csEditorUIManager.instance.LevelNameInputFeild.text = go.name;
		curMusicData = CurMusicPrefab.GetComponent<csMusicPrefabData>();
		curMusicData.ProcessItemToList();
		curMusicData.OpenListItemCollider();
		beatGapTime = 60f / (float)curMusicData.SongBeatCount;
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		ass.clip = curMusicData.ASS.clip;
	}

	private void CreatBeatObjByData(int b, int s, GameObject go)
	{
		csMusicPrefabOptmizedData component = go.GetComponent<csMusicPrefabOptmizedData>();
		csEditorUIManager.instance.LevelNameInputFeild.text = go.name;
		beatGapTime = 60f / (float)b;
		CurMusicPrefab = UnityEngine.Object.Instantiate(MusicCaseParent);
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		curMusicData = CurMusicPrefab.GetComponent<csMusicPrefabData>();
		curMusicData.SongBeatCount = b;
		curMusicData.SongPlayTime = (int)MusicTime;
		for (int i = 0; (float)i < MusicTime / beatGapTime; i++)
		{
			float z = beatGapTime * (float)i * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, z), Quaternion.identity);
			gameObject.transform.SetParent(curMusicData.BeatLineT);
			gameObject.GetComponent<csEditorBeatPoint>().SetTMBig(i);
			gameObject.GetComponent<csEditorBeatPoint>().BeatTime = beatGapTime * (float)i;
			curMusicData.AddBeatLinePoint(gameObject.GetComponent<csEditorBeatPoint>());
			for (int j = 1; j < beatCountInCol; j++)
			{
				float num = beatGapTime * (float)i * beatGapDis;
				num += beatGapTime * (float)j * beatGapDis / (float)beatCountInCol;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, num), Quaternion.identity);
				gameObject2.transform.SetParent(curMusicData.BeatLineT);
				gameObject2.GetComponent<csEditorBeatPoint>().SetTMSmall(j);
				gameObject2.GetComponent<csEditorBeatPoint>().BeatTime = beatGapTime * (float)i + beatGapTime * (float)j / (float)beatCountInCol;
				curMusicData.AddBeatLinePoint(gameObject2.GetComponent<csEditorBeatPoint>());
			}
		}
		for (int k = 0; k < component.SingleLevelDataList[0].BeatItemList.Count; k++)
		{
			csBeatItemData csBeatItemData2 = component.SingleLevelDataList[0].BeatItemList[k];
			if (csBeatItemData2.m_BeatItemType == csBeatItemType.Wall)
			{
				GameObject obj = UnityEngine.Object.Instantiate(WallPrefabs[0].gameObject, WallTrans.position, Quaternion.identity);
				obj.transform.SetParent(CurMusicPrefab.transform);
				obj.transform.localPosition = new Vector3(0f, csGameSettings.CenterHolePos.y + csGameSongPlayer.WallOffset.y, csBeatItemData2.LocalPos.z);
				obj.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
				obj.GetComponent<csEditorBeatItem>().InitBeat(csBeatItemData2.BeatPos, 1);
			}
			else
			{
				Vector3 vector = new Vector3(-1.119362f, 1.452069f, csBeatItemData2.LocalPos.z);
				GameObject obj2 = UnityEngine.Object.Instantiate(NormalItemPrefab, vector, Quaternion.identity);
				obj2.transform.SetParent(CurMusicPrefab.transform);
				obj2.transform.localPosition = vector;
				csEditorBeatItem component2 = obj2.GetComponent<csEditorBeatItem>();
				component2.InitBeat(csBeatItemData2.BeatPos, 1);
				component2.InitColorAndType(csBeatItemColor.LBlack, 4);
			}
		}
	}

	private void CreatBeat(int b, int s)
	{
		beatGapTime = 60f / (float)b;
		CurMusicPrefab = UnityEngine.Object.Instantiate(MusicCaseParent);
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		curMusicData = CurMusicPrefab.GetComponent<csMusicPrefabData>();
		curMusicData.SongBeatCount = b;
		curMusicData.SongPlayTime = (int)MusicTime;
		for (int i = 0; (float)i < MusicTime / beatGapTime; i++)
		{
			float z = beatGapTime * (float)i * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, z), Quaternion.identity);
			gameObject.transform.SetParent(curMusicData.BeatLineT);
			gameObject.GetComponent<csEditorBeatPoint>().SetTMBig(i);
			gameObject.GetComponent<csEditorBeatPoint>().BeatTime = beatGapTime * (float)i;
			curMusicData.AddBeatLinePoint(gameObject.GetComponent<csEditorBeatPoint>());
			for (int j = 1; j < beatCountInCol; j++)
			{
				float num = beatGapTime * (float)i * beatGapDis;
				num += beatGapTime * (float)j * beatGapDis / (float)beatCountInCol;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, num), Quaternion.identity);
				gameObject2.transform.SetParent(curMusicData.BeatLineT);
				gameObject2.GetComponent<csEditorBeatPoint>().SetTMSmall(j);
				gameObject2.GetComponent<csEditorBeatPoint>().BeatTime = beatGapTime * (float)i + beatGapTime * (float)j / (float)beatCountInCol;
				curMusicData.AddBeatLinePoint(gameObject2.GetComponent<csEditorBeatPoint>());
			}
		}
	}

	private void MoveLine()
	{
		line.transform.localPosition = new Vector3(0f, 0f, -1f * selectBeatIndex * beatGapTime * beatGapDis);
		if (StartMove)
		{
			StartPlay();
		}
	}

	private void Control()
	{
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if ((double)Mathf.Abs(axis) > 0.01 && StartMove)
		{
			StartMove = false;
			StartPlay();
		}
		if (axis > 0.05f)
		{
			if (!(-1f * line.localPosition.z / (beatGapTime * beatGapDis) - selectBeatIndex > 0.01f))
			{
				selectBeatIndex -= 1f / ScrollAccr;
			}
			SliderPercent = selectBeatIndex / ((float)curMusicData.SongPlayTime / beatGapTime);
			MoveLine();
		}
		else if (axis < -0.05f)
		{
			selectBeatIndex += 1f / ScrollAccr;
			SliderPercent = selectBeatIndex / ((float)curMusicData.SongPlayTime / beatGapTime);
			MoveLine();
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			StartMove = !StartMove;
			StartPlay();
		}
	}

	private void StartPlay()
	{
		if (StartMove)
		{
			float num = beatGapTime * beatGapDis * selectBeatIndex / (float)beatCountInCol;
			UnityEngine.Debug.Log("Start Time" + num);
			if (!(num < 0f))
			{
				ass.time = num;
				ass.Play();
			}
		}
		else
		{
			ass.Stop();
			if (!EditorUIObj.activeSelf)
			{
				EditorUIObj.SetActive(value: true);
			}
		}
	}

	public void SelectBeatItem(csEditorBeatItemPos p)
	{
		if (selectBeatItemPos != null)
		{
			selectBeatItemPos.UnSelect();
		}
		selectBeatItemPos = p;
	}

	private csEditorBeatItem GetCurrselectedItem()
	{
		csEditorBeatItem result = null;
		Collider[] array = Physics.OverlapSphere(new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f), isPunchEditor ? 0.145f : 0.0725f);
		foreach (Collider collider in array)
		{
			if ((bool)collider.GetComponent<csEditorBeatItem>())
			{
				result = collider.GetComponent<csEditorBeatItem>();
			}
		}
		return result;
	}

	public void CreatBeatItem(csBeatItemType _type, csBeatItemColor _ItemColor, int typeindex)
	{
		if (RotateTween != null && RotateTween.IsPlaying())
		{
			return;
		}
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			if (currselectedItem.m_BeatItemType == _type)
			{
				currselectedItem.InitColorAndType(_ItemColor, typeindex);
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject gameObject = _type switch
		{
			csBeatItemType.StickDirection => StickDirectionItemPrefab, 
			csBeatItemType.Direction => DirectionItemPrefab, 
			csBeatItemType.Normal => NormalItemPrefab, 
			csBeatItemType.Defence => DefenseItemPrefab, 
			csBeatItemType.Reward => RewardItemPrefab, 
			csBeatItemType.Turning => RotateItemPrefab, 
			csBeatItemType.Way => WayItemPrefab, 
			csBeatItemType.SwiftKnee => SwiftKneeItemPrefab, 
			csBeatItemType.SwiftKick => SwiftKickItemPrefab, 
			csBeatItemType.SwiftTrample => SwiftTrampleItemPrefab, 
			_ => null, 
		};
		if ((bool)gameObject)
		{
			GameObject obj = UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(_ItemColor, typeindex);
		}
	}

	public void CreatBeatItemWithRotation(csBeatItemType _type, csBeatItemColor _ItemColor, int angle)
	{
		if (RotateTween == null || !RotateTween.IsPlaying())
		{
			csEditorBeatItem currselectedItem = GetCurrselectedItem();
			if (currselectedItem != null)
			{
				UnityEngine.Object.Destroy(currselectedItem.gameObject);
			}
			Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
			GameObject gameObject = _type switch
			{
				csBeatItemType.StickDirection => StickDirectionItemPrefab, 
				csBeatItemType.Direction => DirectionItemPrefab, 
				csBeatItemType.Normal => NormalItemPrefab, 
				csBeatItemType.Defence => DefenseItemPrefab, 
				csBeatItemType.Reward => RewardItemPrefab, 
				csBeatItemType.Turning => RotateItemPrefab, 
				csBeatItemType.Way => WayItemPrefab, 
				_ => null, 
			};
			if ((bool)gameObject)
			{
				GameObject obj = UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity);
				obj.transform.SetParent(CurMusicPrefab.transform);
				csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
				component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
				component.InitColorAndType(_ItemColor, 0);
				component.thisT.localRotation = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, angle) * Vector3.up);
			}
		}
	}

	public void CreatFootBeatItem(bool isLeftFoot)
	{
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Debug.LogError("CurBeatItem:" + currselectedItem.m_BeatItemType);
			if (currselectedItem.m_BeatItemType == csBeatItemType.FootRingHint)
			{
				currselectedItem.InitColorAndType((!isLeftFoot) ? csBeatItemColor.RWhite : csBeatItemColor.LBlack, 0);
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject footHintRing = FootHintRing;
		if ((bool)footHintRing)
		{
			GameObject obj = UnityEngine.Object.Instantiate(footHintRing, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType((!isLeftFoot) ? csBeatItemColor.RWhite : csBeatItemColor.LBlack, 0);
		}
	}

	public void CreatHoleBeatItem(bool isStartHole, int angle)
	{
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Debug.LogError("CurBeatItem:" + currselectedItem.m_BeatItemType);
			if (currselectedItem.m_BeatItemType == (csBeatItemType)(isStartHole ? 20 : 21))
			{
				currselectedItem.InitColorAndType(csBeatItemColor.LBlack, 0);
				currselectedItem.SetRotateAngle(angle);
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject gameObject = (isStartHole ? HoleStart : HoleEnd);
		if ((bool)gameObject)
		{
			GameObject obj = UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(csBeatItemColor.LBlack, 0);
			component.SetRotateAngle(angle);
		}
	}

	public void CreatLineBeatItem(csBeatCurvePointType curveType)
	{
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		UnityEngine.Debug.LogError("CreatBeatItem:" + curveType);
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject pointItemPrefab = PointItemPrefab;
		if ((bool)pointItemPrefab)
		{
			GameObject obj = UnityEngine.Object.Instantiate(pointItemPrefab, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(csBeatItemColor.LBlack, (int)curveType);
		}
	}

	public void CreateHintBeatItem(HintTense ht, string hintTxt)
	{
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject bRHintItem = BRHintItem;
		if ((bool)bRHintItem)
		{
			GameObject obj = UnityEngine.Object.Instantiate(bRHintItem, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(csBeatItemColor.LBlack, (int)ht);
			((csEditorBeatItem_Hint)component).InitHintText(ht, hintTxt);
			component.SetRotateAngle(0);
		}
	}

	public void DeleteSelectRolItem()
	{
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
	}

	public void CreatTurningBeatItem(csBeatItemType _type, csBeatItemColor _ItemColor, bool isLeftTurn, int angle)
	{
		if (RotateTween != null && RotateTween.IsPlaying())
		{
			return;
		}
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Debug.LogError("CurBeatItem:" + currselectedItem.m_BeatItemType);
			if (currselectedItem.m_BeatItemType == _type)
			{
				currselectedItem.InitColorAndType(_ItemColor, isLeftTurn ? 3 : 5);
				currselectedItem.SetRotateAngle(isLeftTurn ? angle : (-angle));
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject rotateItemPrefab = RotateItemPrefab;
		if ((bool)rotateItemPrefab)
		{
			GameObject obj = UnityEngine.Object.Instantiate(rotateItemPrefab, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(_ItemColor, isLeftTurn ? 3 : 5);
			component.SetRotateAngle(isLeftTurn ? angle : (-angle));
		}
	}

	public void RefreshCurrentDirection()
	{
	}

	public void CreatWallItem(int index, int zAngle)
	{
		if (RotateTween != null && RotateTween.IsPlaying())
		{
			return;
		}
		csEditorBeatItem currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Debug.LogError("CurBeatItem:" + currselectedItem.m_BeatItemType);
			if (currselectedItem.m_BeatItemType == csBeatItemType.Wall)
			{
				currselectedItem.InitColorAndType(csBeatItemColor.LBlack, 0);
				currselectedItem.thisT.localEulerAngles = new Vector3(0f, 0f, zAngle);
				currselectedItem.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 vector = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject gameObject = UnityEngine.Object.Instantiate(WallPrefabs[index].gameObject, isPunchEditor ? WallTrans.position : vector, Quaternion.identity);
		gameObject.transform.SetParent(CurMusicPrefab.transform);
		currselectedItem = gameObject.GetComponent<csEditorBeatItem>();
		if (currselectedItem.m_BeatItemType == csBeatItemType.Wall)
		{
			gameObject.transform.localPosition = new Vector3(0f, csGameSettings.CenterHolePos.y + csGameSongPlayer.WallOffset.y, gameObject.transform.localPosition.z);
		}
		else
		{
			gameObject.transform.localPosition = new Vector3((selectBeatItemPos.FromTrack - 1) * 4, 0f, gameObject.transform.localPosition.z);
		}
		gameObject.transform.localEulerAngles = new Vector3(0f, 0f, zAngle);
		gameObject.GetComponent<csEditorBeatItem>().InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
	}

	public void SaveEditorMusicToPrefab(string prefabName)
	{
		CurMusicPrefab.GetComponent<csMusicPrefabData>().SaveItemToList();
		PCreator.RunTimeCreatePrefab(CurMusicPrefab, prefabName);
	}

	public void SaveSelectedGruopToPrefab(string prefabKeyName)
	{
		CopySelectedTimeZone();
		GameObject gameObject = new GameObject(prefabKeyName);
		CopyList.Sort((csEditorBeatItem x, csEditorBeatItem y) => (x.BeatPos > y.BeatPos) ? 1 : (-1));
		gameObject.transform.position = new Vector3(0f, 0f, CopyList[0].transform.position.z);
		gameObject.transform.SetParent(CurMusicPrefab.transform);
		foreach (csEditorBeatItem copy in CopyList)
		{
			copy.transform.SetParent(gameObject.transform);
		}
		PCreator.RunTimeCreateGroupPrefab(gameObject, prefabKeyName);
	}

	public void InstantiateGroupPrefab(string prefabKeyName)
	{
		GameObject gameObject;
		if (csEditorUIManager.instance.isPunchEditor)
		{
			gameObject = PCreator.RunTimeInstantiateGroupPrefab(prefabKeyName, Vector3.zero);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
		}
		else
		{
			gameObject = PCreator.RunTimeInstantiateGroupPrefab(prefabKeyName, Vector3.zero);
			gameObject.transform.position = new Vector3(gameObject.transform.position.x + (float)((csEditorUIManager.instance.currentTrack - 1) * 4), gameObject.transform.position.y, gameObject.transform.position.z);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
		}
		csEditorBeatItem[] componentsInChildren = gameObject.GetComponentsInChildren<csEditorBeatItem>();
		csEditorBeatItem[] array;
		if (!isPunchEditor)
		{
			array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ItemTrack = csEditorUIManager.instance.currentTrack;
			}
		}
		array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem2 in array)
		{
			if (csEditorBeatItem2.transform.position.z == 0f)
			{
				_ = csEditorBeatItem2.BeatPos;
				break;
			}
		}
		float num = 1f;
		csEditorBeatItem csEditorBeatItem3 = null;
		int num2 = 0;
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			if (!componentsInChildren[j].GetComponent<csEditorBeatItem_Point>())
			{
				num2 = j;
				csEditorBeatItem3 = componentsInChildren[j];
				break;
			}
		}
		csEditorBeatItem csEditorBeatItem4 = null;
		for (int k = num2 + 1; k < componentsInChildren.Length; k++)
		{
			if (!componentsInChildren[k].GetComponent<csEditorBeatItem_Point>())
			{
				if (componentsInChildren[k].thisT.position.z != csEditorBeatItem3.thisT.position.z)
				{
					csEditorBeatItem4 = componentsInChildren[k];
				}
				break;
			}
		}
		num = 1f / (csEditorBeatItem3.thisT.position.z - csEditorBeatItem4.thisT.position.z) * (csEditorBeatItem3.BeatPos - csEditorBeatItem4.BeatPos) * 240f / (float)curMusicData.SongBeatCount;
		array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem5 in array)
		{
			csEditorBeatItem5.transform.position = new Vector3(csEditorBeatItem5.transform.position.x, csEditorBeatItem5.transform.position.y, csEditorBeatItem5.transform.position.z * num);
		}
		array = componentsInChildren;
		for (int i = 0; i < array.Length; i++)
		{
			csEditorBeatItem_Waypath component = array[i].GetComponent<csEditorBeatItem_Waypath>();
			if ((bool)component)
			{
				BezierPoint[] points = component.thisT.parent.GetComponent<BezierCurve>().points;
				foreach (BezierPoint bezierPoint in points)
				{
					bezierPoint.handle1 = new Vector3(bezierPoint.handle1.x, bezierPoint.handle1.y, bezierPoint.handle1.z * num);
					bezierPoint.handle2 = new Vector3(bezierPoint.handle2.x, bezierPoint.handle2.y, bezierPoint.handle2.z * num);
				}
				component.thisT.parent.GetComponent<csCurvePointDot>().CreatePathDotB();
			}
		}
		if (!csEditorUIManager.instance.isPunchEditor)
		{
			array = gameObject.GetComponentsInChildren<csEditorBeatItem>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ItemTrack = csEditorUIManager.instance.currentTrack;
			}
		}
	}

	private void Update()
	{
		Control();
		if (AnalyzerDone)
		{
			AnalyzerDone = false;
			OnBeatDetectDone();
		}
		if (Input.GetKeyDown(KeyCode.R) && Input.GetKey(KeyCode.LeftShift))
		{
			curMusicData.RefreshLineBeatItemPoint(beatGapDis);
		}
		if (Input.GetKeyDown(KeyCode.LeftControl) && ShouldClearSelect)
		{
			ShouldClearSelect = false;
			MinSelTime = 9999f;
			MinSelTimeByBeat = 9999f;
			moveMinSelTime = 9999f;
			MaxSelTime = 0f;
			for (int i = 0; i < SelBeatPointList.Count; i++)
			{
				SelBeatPointList[i].OnSelected(isSel: false);
			}
			SelBeatPointList.Clear();
			curMusicData.ProcessItemToList();
		}
		if (Input.GetKey(KeyCode.LeftControl) && Input.GetMouseButton(0))
		{
			ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out hit, 1000f, 32))
			{
				float num = line.InverseTransformPoint(hit.point).z / beatGapDis;
				if (MinSelTime > num)
				{
					MinSelTime = num;
				}
				if (num > MaxSelTime)
				{
					MaxSelTime = num;
				}
				for (int j = 0; j < curMusicData.BeatPointList.Count; j++)
				{
					if (curMusicData.BeatPointList[j].BeatTime > MinSelTime && !curMusicData.BeatPointList[j].isSelected)
					{
						curMusicData.BeatPointList[j].OnSelected(isSel: true);
						if (curMusicData.BeatPointList[j].BeatTime < MinSelTimeByBeat)
						{
							MinSelTimeByBeat = curMusicData.BeatPointList[j].BeatTime;
						}
						SelBeatPointList.Add(curMusicData.BeatPointList[j]);
					}
					if (curMusicData.BeatPointList[j].BeatTime > MaxSelTime)
					{
						break;
					}
				}
			}
		}
		else if (Input.GetMouseButton(0))
		{
			ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out hit, 1000f, 32))
			{
				csEditorBeatItemPos component = hit.collider.GetComponent<csEditorBeatItemPos>();
				if ((bool)component && (isPunchEditor || csEditorUIManager.instance.currentTrack == component.FromTrack))
				{
					SelectBeatItem(component);
					component.Select();
				}
			}
		}
		if (Input.GetKeyUp(KeyCode.LeftControl))
		{
			ShouldClearSelect = true;
		}
	}

	public float SetSliderPercentByUI(float oldf)
	{
		selectBeatIndex = (int)(oldf * ((float)curMusicData.SongPlayTime / beatGapTime));
		SliderPercent = selectBeatIndex / ((float)curMusicData.SongPlayTime / beatGapTime);
		float sliderPercent = SliderPercent;
		MoveLine();
		return sliderPercent;
	}

	private void FixedUpdate()
	{
		ass.pitch = BGMSpeed;
		if (StartMove)
		{
			line.localPosition += Vector3.forward * BGMSpeed * moveSpeed * beatGapDis * Time.deltaTime * -1f;
			if (line.localPosition.z < 0f)
			{
				selectBeatIndex = -1f * line.localPosition.z / (beatGapTime * beatGapDis);
			}
			selectBeatIndex = (float)(int)(selectBeatIndex * ScrollAccr) / ScrollAccr;
			SliderPercent = selectBeatIndex / ((float)curMusicData.SongPlayTime / beatGapTime);
		}
	}

	public void CopySelectedTimeZone()
	{
		if (MaxSelTime <= MinSelTime)
		{
			UnityEngine.Debug.LogError("没有找到可复制项目");
			return;
		}
		csEditorBeatItem[] componentsInChildren = curMusicData.transform.GetComponentsInChildren<csEditorBeatItem>();
		CopyList.Clear();
		UnityEngine.Debug.LogError("MinSelTimeByBeat:" + MinSelTimeByBeat + " MaxSelTime:" + MaxSelTime);
		csEditorBeatItem[] array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem2 in array)
		{
			if (!(csEditorBeatItem2.BeatPos * beatGapTime >= MinSelTimeByBeat) || !(csEditorBeatItem2.BeatPos * beatGapTime <= MaxSelTime))
			{
				continue;
			}
			if (csEditorBeatItem2.m_BeatItemType == csBeatItemType.Way)
			{
				if (csEditorBeatItem2 is csEditorBeatItem_Point && ((((csEditorBeatItem_Point)csEditorBeatItem2).m_BeatItemPointType == csBeatCurvePointType.Start && csEditorBeatItem2.ItemTrack == csEditorUIManager.instance.currentTrack) || csEditorUIManager.instance.isPunchEditor))
				{
					CopyList.Add(csEditorBeatItem2);
				}
			}
			else if (csEditorBeatItem2.ItemTrack == csEditorUIManager.instance.currentTrack || csEditorUIManager.instance.isPunchEditor)
			{
				CopyList.Add(csEditorBeatItem2);
			}
		}
	}

	public void MoveSelectedTimeZone(float moveValue)
	{
		csEditorBeatItem[] componentsInChildren = curMusicData.transform.GetComponentsInChildren<csEditorBeatItem>();
		MoveList.Clear();
		csEditorBeatItem[] array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem2 in array)
		{
			if (csEditorBeatItem2.BeatPos >= selectBeatIndex)
			{
				MoveList.Add(csEditorBeatItem2);
			}
		}
		for (int j = 0; j < MoveList.Count; j++)
		{
			float num = moveValue * 0.25f * beatGapTime;
			float num2 = num * beatGapDis;
			MoveList[j].transform.localPosition = new Vector3(MoveList[j].transform.localPosition.x, MoveList[j].transform.localPosition.y, MoveList[j].transform.localPosition.z + num2);
			MoveList[j].GetComponent<csEditorBeatItem>().BeatPos += num / beatGapTime;
		}
	}

	public void PasteSelectedTimeZone()
	{
		for (int i = 0; i < CopyList.Count; i++)
		{
			float num = CopyList[i].BeatPos * beatGapTime - MinSelTimeByBeat;
			float num2 = num * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(CopyList[i].gameObject);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
			if (csEditorUIManager.instance.isPunchEditor)
			{
				gameObject.transform.localPosition = new Vector3(gameObject.transform.localPosition.x, gameObject.transform.localPosition.y, selectBeatIndex * beatGapTime * beatGapDis + num2);
			}
			else
			{
				gameObject.transform.localPosition = new Vector3(gameObject.transform.localPosition.x - (float)((CopyList[i].ItemTrack - 1) * 4) + (float)((csEditorUIManager.instance.currentTrack - 1) * 4), gameObject.transform.localPosition.y, selectBeatIndex * beatGapTime * beatGapDis + num2);
			}
			if (csEditorUIManager.instance.isPunchEditor)
			{
				gameObject.GetComponent<csEditorBeatItem>().InitBeat(selectBeatIndex + num / beatGapTime, CopyList[i].ItemTrack);
				if (CopyList[i] is csEditorBeatItem_Point && ((csEditorBeatItem_Point)CopyList[i]).m_BeatItemPointType == csBeatCurvePointType.Start)
				{
					gameObject.GetComponent<csCurvePointDot>().DotPointsList[0].ItemTrack = CopyList[i].ItemTrack;
				}
			}
			else
			{
				gameObject.GetComponent<csEditorBeatItem>().InitBeat(selectBeatIndex + num / beatGapTime, csEditorUIManager.instance.currentTrack);
				if (CopyList[i] is csEditorBeatItem_Point && ((csEditorBeatItem_Point)CopyList[i]).m_BeatItemPointType == csBeatCurvePointType.Start)
				{
					gameObject.GetComponent<csCurvePointDot>().DotPointsList[0].ItemTrack = csEditorUIManager.instance.currentTrack;
				}
			}
		}
	}
}
public class csMusicEditorVideoFollow : MonoBehaviour
{
	[Header("是否取用现成Prefab")]
	public bool UseBeatPrefab;

	[Header("被编辑的现成Prefab")]
	public GameObject BeatPrefab;

	public bool UseBeatDataInGame;

	[Header("被编辑的现成DataInGame")]
	public GameObject BeatGameData;

	[Header("大拍间隔距离（每秒米数）就是关卡版移动速度，修改后需要刷新")]
	public float beatGapDis = 10f;

	private float moveSpeed = 1f;

	public Transform thisT;

	public bool StartMove;

	public VideoPlayer vp;

	public GameObject beat_B;

	public Transform line;

	public GameObject MusicCaseParent;

	[HideInInspector]
	public GameObject CurMusicPrefab;

	private csVideoPrefabData curMusicData;

	public GameObject EditorUIObj;

	public GameObject VideoItemPrefab_SingleMove;

	public GameObject VideoItemPrefab_MultiMove;

	public GameObject VideoItemPrefab_MultiMoveChild;

	[Header("视频长度")]
	public float MusicTime = 150f;

	[Header("每大节有几小拍")]
	public int beatCountInCol = 10;

	[Header("滚轮精确度")]
	public float ScrollAccr = 1f;

	[Header("当前编辑点位置 无法设置")]
	public float selectBeatIndex;

	public static csMusicEditorVideoFollow instance;

	public csEditorBeatItemPos selectBeatItemPos;

	public GameObject BRHintItem;

	public GameObject CheckStart;

	public GameObject CheckEnd;

	public Material ItemMaterial_Red;

	public Material ItemMaterial_Blue;

	public PrefabCreator PCreator;

	public float SliderPercent;

	private Ray ray;

	private RaycastHit hit;

	private float MinSelTime = 9999f;

	private float moveMinSelTime = 9999f;

	private float MaxSelTime;

	private float MinSelTimeByBeat = 9999f;

	private bool ShouldClearSelect;

	private List<csEditorBeatPoint> SelBeatPointList = new List<csEditorBeatPoint>();

	private List<csEditorBeatItem> CopyList = new List<csEditorBeatItem>();

	private List<csEditorBeatItem> MoveList = new List<csEditorBeatItem>();

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		thisT = base.transform;
	}

	private void Start()
	{
		if (UseBeatPrefab && (bool)BeatPrefab)
		{
			CreatBeat(BeatPrefab);
		}
		else
		{
			CreatBeat(beatCountInCol);
		}
	}

	private void CreatBeat(GameObject go)
	{
		CurMusicPrefab = UnityEngine.Object.Instantiate(go);
		csEditorUIManagerVideoFollow.instance.LevelNameInputFeild.text = go.name;
		curMusicData = CurMusicPrefab.GetComponent<csVideoPrefabData>();
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		vp.clip = curMusicData.VClip;
	}

	private void CreatBeatObjByData(int b, int s, GameObject go)
	{
		go.GetComponent<csMusicPrefabOptmizedData>();
		csEditorUIManager.instance.LevelNameInputFeild.text = go.name;
		CurMusicPrefab = UnityEngine.Object.Instantiate(MusicCaseParent);
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		curMusicData = CurMusicPrefab.GetComponent<csVideoPrefabData>();
		curMusicData.VideoPlayTime = (int)MusicTime;
		for (int i = 0; (float)i < MusicTime; i++)
		{
			float z = (float)i * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, z), Quaternion.identity);
			gameObject.transform.SetParent(curMusicData.BeatLineT);
			gameObject.GetComponent<csEditorBeatPoint>().SetTMBig(i);
			gameObject.GetComponent<csEditorBeatPoint>().BeatTime = i;
			curMusicData.AddBeatLinePoint(gameObject.GetComponent<csEditorBeatPoint>());
			for (int j = 1; j < beatCountInCol; j++)
			{
				float num = (float)i * beatGapDis;
				num += (float)j * beatGapDis / (float)beatCountInCol;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, num), Quaternion.identity);
				gameObject2.transform.SetParent(curMusicData.BeatLineT);
				gameObject2.GetComponent<csEditorBeatPoint>().SetTMSmall(j);
				gameObject2.GetComponent<csEditorBeatPoint>().BeatTime = (float)i + (float)j / (float)beatCountInCol;
				curMusicData.AddBeatLinePoint(gameObject2.GetComponent<csEditorBeatPoint>());
			}
		}
	}

	private void CreatBeat(int s)
	{
		CurMusicPrefab = UnityEngine.Object.Instantiate(MusicCaseParent);
		CurMusicPrefab.transform.SetParent(line);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		curMusicData = CurMusicPrefab.GetComponent<csVideoPrefabData>();
		curMusicData.VideoPlayTime = (int)MusicTime;
		for (int i = 0; (float)i < MusicTime; i++)
		{
			float z = (float)i * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, z), Quaternion.identity);
			gameObject.transform.SetParent(curMusicData.BeatLineT);
			gameObject.GetComponent<csEditorBeatPoint>().SetTMBig(i);
			gameObject.GetComponent<csEditorBeatPoint>().BeatTime = i;
			curMusicData.AddBeatLinePoint(gameObject.GetComponent<csEditorBeatPoint>());
			for (int j = 1; j < beatCountInCol; j++)
			{
				float num = (float)i * beatGapDis;
				num += (float)j * beatGapDis / (float)beatCountInCol;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(beat_B, new Vector3(0f, 0f, num), Quaternion.identity);
				gameObject2.transform.SetParent(curMusicData.BeatLineT);
				gameObject2.GetComponent<csEditorBeatPoint>().SetTMSmall(j);
				gameObject2.GetComponent<csEditorBeatPoint>().BeatTime = (float)i + (float)j / (float)beatCountInCol;
				curMusicData.AddBeatLinePoint(gameObject2.GetComponent<csEditorBeatPoint>());
			}
		}
	}

	private void MoveLine()
	{
		float num = beatGapDis * selectBeatIndex / (float)beatCountInCol;
		UnityEngine.Debug.LogError("fromTime:" + num);
		if (num > 0f)
		{
			vp.time = num;
			vp.Play();
			vp.Pause();
		}
		line.transform.localPosition = new Vector3(0f, 0f, -1f * selectBeatIndex * beatGapDis);
		if (StartMove)
		{
			StartPlay();
		}
	}

	private void Control()
	{
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if ((double)Mathf.Abs(axis) > 0.01 && StartMove)
		{
			StartMove = false;
			StartPlay();
		}
		if (axis > 0.05f)
		{
			if (!(-1f * line.localPosition.z / beatGapDis - selectBeatIndex > 0.01f))
			{
				selectBeatIndex -= 1f / ScrollAccr;
			}
			SliderPercent = selectBeatIndex / (float)curMusicData.VideoPlayTime;
			MoveLine();
		}
		else if (axis < -0.05f)
		{
			selectBeatIndex += 1f / ScrollAccr;
			SliderPercent = selectBeatIndex / (float)curMusicData.VideoPlayTime;
			MoveLine();
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			StartMove = !StartMove;
			StartPlay();
		}
	}

	private void StartPlay()
	{
		if (StartMove)
		{
			float num = beatGapDis * selectBeatIndex / (float)beatCountInCol;
			UnityEngine.Debug.Log("Start Time" + num);
			if (!(num < 0f))
			{
				vp.time = num;
				vp.Play();
			}
		}
		else
		{
			vp.Stop();
			if (!EditorUIObj.activeSelf)
			{
				EditorUIObj.SetActive(value: true);
			}
		}
	}

	public void SelectBeatItem(csEditorBeatItemPos p)
	{
		if (selectBeatItemPos != null)
		{
			selectBeatItemPos.UnSelect();
		}
		selectBeatItemPos = p;
	}

	private csVFollowItemBase GetCurrselectedItem()
	{
		csVFollowItemBase result = null;
		Collider[] array = Physics.OverlapSphere(new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f), 0.145f);
		foreach (Collider collider in array)
		{
			if ((bool)collider.GetComponent<csVFollowItemBase>())
			{
				result = collider.GetComponent<csVFollowItemBase>();
			}
		}
		return result;
	}

	public void CreatBeatItem(VFllowItemType _type, int interactableType)
	{
		csVFollowItemBase currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			if (currselectedItem.VFType == _type)
			{
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject gameObject = _type switch
		{
			VFllowItemType.MovementJudge => VideoItemPrefab_SingleMove, 
			VFllowItemType.MultiMovement => VideoItemPrefab_MultiMove, 
			VFllowItemType.MultiMovementChild => VideoItemPrefab_MultiMoveChild, 
			VFllowItemType.Interactable => null, 
			_ => null, 
		};
		if ((bool)gameObject)
		{
			GameObject obj = UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			obj.GetComponent<csVFollowItemBase>().InitBeat(selectBeatIndex);
		}
	}

	public void CreatHoleBeatItem(bool isStartHole)
	{
		csVFollowItemBase currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Debug.LogError("CurBeatItem:" + currselectedItem.VFType);
			if (currselectedItem.VFType == ((!isStartHole) ? VFllowItemType.CheckPointEnd : VFllowItemType.CheckPointStart))
			{
				return;
			}
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject gameObject = (isStartHole ? CheckStart : CheckEnd);
		if ((bool)gameObject)
		{
			GameObject obj = UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			obj.GetComponent<csVFollowItemBase>().InitBeat(selectBeatIndex);
		}
	}

	public void CreateHintBeatItem(HintTense ht, string hintTxt)
	{
		csVFollowItemBase currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
		Vector3 position = new Vector3(selectBeatItemPos.transform.position.x, selectBeatItemPos.transform.position.y, 0f);
		GameObject bRHintItem = BRHintItem;
		if ((bool)bRHintItem)
		{
			GameObject obj = UnityEngine.Object.Instantiate(bRHintItem, position, Quaternion.identity);
			obj.transform.SetParent(CurMusicPrefab.transform);
			csEditorBeatItem component = obj.GetComponent<csEditorBeatItem>();
			component.InitBeat(selectBeatIndex, selectBeatItemPos.FromTrack);
			component.InitColorAndType(csBeatItemColor.LBlack, (int)ht);
			((csEditorBeatItem_Hint)component).InitHintText(ht, hintTxt);
			component.SetRotateAngle(0);
		}
	}

	public void DeleteSelectRolItem()
	{
		csVFollowItemBase currselectedItem = GetCurrselectedItem();
		if (currselectedItem != null)
		{
			UnityEngine.Object.Destroy(currselectedItem.gameObject);
		}
	}

	public void SaveEditorMusicToPrefab(string prefabName)
	{
		CurMusicPrefab.GetComponent<csVideoPrefabData>().SaveItemToList();
		PCreator.RunTimeCreatePrefab(CurMusicPrefab, "VideoLevelPrefab/" + prefabName);
	}

	public void SaveSelectedGruopToPrefab(string prefabKeyName)
	{
		CopySelectedTimeZone();
		GameObject gameObject = new GameObject(prefabKeyName);
		CopyList.Sort((csEditorBeatItem x, csEditorBeatItem y) => (x.BeatPos > y.BeatPos) ? 1 : (-1));
		gameObject.transform.position = new Vector3(0f, 0f, CopyList[0].transform.position.z);
		gameObject.transform.SetParent(CurMusicPrefab.transform);
		foreach (csEditorBeatItem copy in CopyList)
		{
			copy.transform.SetParent(gameObject.transform);
		}
		PCreator.RunTimeCreateGroupPrefab(gameObject, prefabKeyName);
	}

	private void Update()
	{
		Control();
		if (Input.GetKeyDown(KeyCode.R) && Input.GetKey(KeyCode.LeftShift))
		{
			curMusicData.RefreshLineBeatItemPoint(beatGapDis);
		}
		if (Input.GetKeyDown(KeyCode.LeftControl) && ShouldClearSelect)
		{
			ShouldClearSelect = false;
			MinSelTime = 9999f;
			MinSelTimeByBeat = 9999f;
			moveMinSelTime = 9999f;
			MaxSelTime = 0f;
			for (int i = 0; i < SelBeatPointList.Count; i++)
			{
				SelBeatPointList[i].OnSelected(isSel: false);
			}
			SelBeatPointList.Clear();
			curMusicData.ProcessItemToList();
		}
		if (Input.GetKey(KeyCode.LeftControl) && Input.GetMouseButton(0))
		{
			ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out hit, 1000f, 32))
			{
				float num = line.InverseTransformPoint(hit.point).z / beatGapDis;
				if (MinSelTime > num)
				{
					MinSelTime = num;
				}
				if (num > MaxSelTime)
				{
					MaxSelTime = num;
				}
				for (int j = 0; j < curMusicData.BeatPointList.Count; j++)
				{
					if (curMusicData.BeatPointList[j].BeatTime > MinSelTime && !curMusicData.BeatPointList[j].isSelected)
					{
						curMusicData.BeatPointList[j].OnSelected(isSel: true);
						if (curMusicData.BeatPointList[j].BeatTime < MinSelTimeByBeat)
						{
							MinSelTimeByBeat = curMusicData.BeatPointList[j].BeatTime;
						}
						SelBeatPointList.Add(curMusicData.BeatPointList[j]);
					}
					if (curMusicData.BeatPointList[j].BeatTime > MaxSelTime)
					{
						break;
					}
				}
			}
		}
		else if (Input.GetMouseButton(0))
		{
			ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out hit, 1000f, 32))
			{
				csEditorBeatItemPos component = hit.collider.GetComponent<csEditorBeatItemPos>();
				if ((bool)component)
				{
					SelectBeatItem(component);
					component.Select();
				}
			}
		}
		if (Input.GetKeyUp(KeyCode.LeftControl))
		{
			ShouldClearSelect = true;
		}
	}

	public float SetSliderPercentByUI(float oldf)
	{
		selectBeatIndex = (int)(oldf * (float)curMusicData.VideoPlayTime);
		SliderPercent = selectBeatIndex / (float)curMusicData.VideoPlayTime;
		float sliderPercent = SliderPercent;
		MoveLine();
		return sliderPercent;
	}

	private void FixedUpdate()
	{
		if (StartMove)
		{
			line.localPosition += Vector3.forward * moveSpeed * beatGapDis * Time.deltaTime * -1f;
			if (line.localPosition.z < 0f)
			{
				selectBeatIndex = -1f * line.localPosition.z / beatGapDis;
			}
			selectBeatIndex = (float)(int)(selectBeatIndex * ScrollAccr) / ScrollAccr;
			SliderPercent = selectBeatIndex / (float)curMusicData.VideoPlayTime;
		}
	}

	public void CopySelectedTimeZone()
	{
		if (MaxSelTime <= MinSelTime)
		{
			UnityEngine.Debug.LogError("没有找到可复制项目");
			return;
		}
		csEditorBeatItem[] componentsInChildren = curMusicData.transform.GetComponentsInChildren<csEditorBeatItem>();
		CopyList.Clear();
		UnityEngine.Debug.LogError("MinSelTimeByBeat:" + MinSelTimeByBeat + " MaxSelTime:" + MaxSelTime);
		csEditorBeatItem[] array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem2 in array)
		{
			if (!(csEditorBeatItem2.BeatPos >= MinSelTimeByBeat) || !(csEditorBeatItem2.BeatPos <= MaxSelTime))
			{
				continue;
			}
			if (csEditorBeatItem2.m_BeatItemType == csBeatItemType.Way)
			{
				if (csEditorBeatItem2 is csEditorBeatItem_Point && ((((csEditorBeatItem_Point)csEditorBeatItem2).m_BeatItemPointType == csBeatCurvePointType.Start && csEditorBeatItem2.ItemTrack == csEditorUIManager.instance.currentTrack) || csEditorUIManager.instance.isPunchEditor))
				{
					CopyList.Add(csEditorBeatItem2);
				}
			}
			else if (csEditorBeatItem2.ItemTrack == csEditorUIManager.instance.currentTrack || csEditorUIManager.instance.isPunchEditor)
			{
				CopyList.Add(csEditorBeatItem2);
			}
		}
	}

	public void MoveSelectedTimeZone(float moveValue)
	{
		csEditorBeatItem[] componentsInChildren = curMusicData.transform.GetComponentsInChildren<csEditorBeatItem>();
		MoveList.Clear();
		csEditorBeatItem[] array = componentsInChildren;
		foreach (csEditorBeatItem csEditorBeatItem2 in array)
		{
			if (csEditorBeatItem2.BeatPos >= selectBeatIndex)
			{
				MoveList.Add(csEditorBeatItem2);
			}
		}
		for (int j = 0; j < MoveList.Count; j++)
		{
			float num = moveValue * 0.25f;
			float num2 = num * beatGapDis;
			MoveList[j].transform.localPosition = new Vector3(MoveList[j].transform.localPosition.x, MoveList[j].transform.localPosition.y, MoveList[j].transform.localPosition.z + num2);
			MoveList[j].GetComponent<csEditorBeatItem>().BeatPos += num;
		}
	}

	public void PasteSelectedTimeZone()
	{
		for (int i = 0; i < CopyList.Count; i++)
		{
			float num = CopyList[i].BeatPos - MinSelTimeByBeat;
			float num2 = num * beatGapDis;
			GameObject gameObject = UnityEngine.Object.Instantiate(CopyList[i].gameObject);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
			if (csEditorUIManager.instance.isPunchEditor)
			{
				gameObject.transform.localPosition = new Vector3(gameObject.transform.localPosition.x, gameObject.transform.localPosition.y, selectBeatIndex * beatGapDis + num2);
			}
			else
			{
				gameObject.transform.localPosition = new Vector3(gameObject.transform.localPosition.x - (float)((CopyList[i].ItemTrack - 1) * 4) + (float)((csEditorUIManager.instance.currentTrack - 1) * 4), gameObject.transform.localPosition.y, selectBeatIndex * beatGapDis + num2);
			}
			if (csEditorUIManager.instance.isPunchEditor)
			{
				gameObject.GetComponent<csEditorBeatItem>().InitBeat(selectBeatIndex + num, CopyList[i].ItemTrack);
				if (CopyList[i] is csEditorBeatItem_Point && ((csEditorBeatItem_Point)CopyList[i]).m_BeatItemPointType == csBeatCurvePointType.Start)
				{
					gameObject.GetComponent<csCurvePointDot>().DotPointsList[0].ItemTrack = CopyList[i].ItemTrack;
				}
			}
			else
			{
				gameObject.GetComponent<csEditorBeatItem>().InitBeat(selectBeatIndex + num, csEditorUIManager.instance.currentTrack);
				if (CopyList[i] is csEditorBeatItem_Point && ((csEditorBeatItem_Point)CopyList[i]).m_BeatItemPointType == csBeatCurvePointType.Start)
				{
					gameObject.GetComponent<csCurvePointDot>().DotPointsList[0].ItemTrack = csEditorUIManager.instance.currentTrack;
				}
			}
		}
	}
}
public class csMusicPrefabData : MonoBehaviour
{
	public Transform BeatLineT;

	public AudioSource ASS;

	public Dictionary<float, List<csEditorBeatItem>> TimeBeatListDict = new Dictionary<float, List<csEditorBeatItem>>();

	public List<csEditorBeatPoint> BeatPointList = new List<csEditorBeatPoint>();

	public List<csEditorBeatItem> BeatItemList = new List<csEditorBeatItem>();

	public int SongBeatCount;

	public int SongPlayTime;

	public string CurSongName;

	public string CurSingerName;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void ProcessItemToDictionary()
	{
	}

	private void OnEnable()
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.OnSelected(isSel: false);
		}
	}

	public void AddBeatLinePoint(csEditorBeatPoint bp)
	{
		BeatPointList.Add(bp);
	}

	public void RefreshLineBeatItemPoint(float newGapDis)
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.thisT.localPosition = new Vector3(0f, 0f, newGapDis * beatPoint.BeatTime);
		}
		ProcessItemToList();
		foreach (csEditorBeatItem beatItem in BeatItemList)
		{
			beatItem.thisT.localPosition = new Vector3(beatItem.thisT.localPosition.x, beatItem.thisT.localPosition.y, newGapDis * beatItem.BeatPos);
		}
	}

	public void ProcessItemToList()
	{
		BeatItemList.Clear();
		csEditorBeatItem[] componentsInChildren = thisT.GetComponentsInChildren<csEditorBeatItem>();
		foreach (csEditorBeatItem item in componentsInChildren)
		{
			BeatItemList.Add(item);
		}
	}

	public void OpenListItemCollider()
	{
		foreach (csEditorBeatItem beatItem in BeatItemList)
		{
			if ((bool)beatItem.ItemCol)
			{
				beatItem.ItemCol.enabled = true;
			}
		}
	}

	public void SaveItemToList()
	{
		ASS.clip = csMusicEditor.instance.ass.clip;
		BeatItemList.Clear();
		csEditorBeatItem[] componentsInChildren = thisT.GetComponentsInChildren<csEditorBeatItem>();
		foreach (csEditorBeatItem item in componentsInChildren)
		{
			BeatItemList.Add(item);
		}
	}

	public void CloseBeatBaseLine(bool isClose)
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.gameObject.SetActive(!isClose);
		}
	}
}
public class csMusicPrefabOptmizedData : MonoBehaviour
{
	public List<SingleLevelData> SingleLevelDataList = new List<SingleLevelData>();

	public List<FollowTimeHintData> FollowTimeHintDataList = new List<FollowTimeHintData>();

	public csThinkingGameData ThinkGameData;

	public void ClearBeatsToPool()
	{
		csEditorBeatItem[] componentsInChildren = base.transform.GetComponentsInChildren<csEditorBeatItem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnItemReturnToPool();
		}
		csCreatePointManager[] componentsInChildren2 = base.transform.GetComponentsInChildren<csCreatePointManager>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].CallReturnToPool();
		}
	}
}
[Serializable]
public class SingleLevelDataInGameData
{
	public int SongBeatCount;

	public float SongBeatGap = 4f;

	public int SongPlayTime;

	public string CurLevelName;

	public string CurSingerName;
}
[Serializable]
public class SingleLevelData
{
	public csPlayMode HandPlayMode;

	public int SongBeatCount;

	public float SongBeatGap = 4f;

	public int SongPlayTime;

	public AudioClip CoachVoiceOverClip;

	public float CoachVoiceDelay;

	public string FixedLevelSkyboxName;

	public string FixedSkyboxInfoID;

	public AudioClip AudioClip;

	public string AudioClipName;

	public string CurLevelName;

	public string CurSingerName;

	public List<csBeatItemData> BeatItemList = new List<csBeatItemData>();
}
[Serializable]
public class FollowTimeHintData
{
	public string VideoID;

	public List<FrameHintData> FrameDataList = new List<FrameHintData>();
}
[Serializable]
public class FrameHintData
{
	public float TimeStamp;

	public string HintString;

	public string HintLocalID;
}
public class csMusicRoot : MonoBehaviour
{
	public AudioClip clip;

	private void OnGUI()
	{
		GUILayout.Space(200f);
	}

	private void FixedUpdate()
	{
	}
}
public class csRhythmEditorGUI : MonoBehaviour
{
	public float RightAreaSize = 0.3f;

	public float R_TopAreaSize = 0.3f;

	public float R_MidAreaSize = 0.4f;

	private GUIStyle RedTextStyle = new GUIStyle();

	private GUIStyle BlueTextStyle = new GUIStyle();

	public int testWallCount = 10;

	private Vector2 WallScrollVect2;

	public float SliderValue;

	private float OldSliderValue;

	private void Awake()
	{
		RedTextStyle.normal.textColor = Color.red;
		BlueTextStyle.normal.textColor = Color.blue;
	}

	private void OnGUI()
	{
		GUILayout.BeginHorizontal();
		GUILayout.Button("加载");
		GUILayout.Button("存储");
		GUILayout.EndHorizontal();
		GUILayout.BeginArea(new Rect((1f - RightAreaSize) * (float)Screen.width, 0f, RightAreaSize * (float)Screen.width, Screen.height));
		GUILayout.BeginVertical();
		PointGUI();
		HitGUI();
		WallGUI();
		GUILayout.EndVertical();
		GUILayout.EndArea();
		BottomSlider();
	}

	private void PointGUI()
	{
		GUILayout.BeginArea(new Rect(0f, 0f, RightAreaSize * (float)Screen.width, R_TopAreaSize * (float)Screen.height));
		GUILayout.Label("红", RedTextStyle);
		GUILayout.BeginHorizontal();
		if (GUILayout.Button("头"))
		{
			ChoosePoint(isRed: true, 0);
		}
		if (GUILayout.Button("中"))
		{
			ChoosePoint(isRed: true, 1);
		}
		if (GUILayout.Button("尾"))
		{
			ChoosePoint(isRed: true, 2);
		}
		GUILayout.EndHorizontal();
		GUILayout.Label("蓝", BlueTextStyle);
		GUILayout.BeginHorizontal();
		if (GUILayout.Button("头"))
		{
			ChoosePoint(isRed: false, 0);
		}
		if (GUILayout.Button("中"))
		{
			ChoosePoint(isRed: false, 1);
		}
		if (GUILayout.Button("尾"))
		{
			ChoosePoint(isRed: false, 2);
		}
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
	}

	private void HitGUI()
	{
		GUILayout.BeginHorizontal();
		GUILayout.BeginArea(new Rect(0f, R_TopAreaSize * (float)Screen.height, RightAreaSize * (float)Screen.width * 0.5f, R_MidAreaSize * (float)Screen.height));
		GUILayout.BeginVertical();
		GUILayout.Label("红", RedTextStyle);
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				if (j % 3 == 0)
				{
					GUILayout.BeginHorizontal();
				}
				if (GUILayout.Button("*"))
				{
					ChooseHitObj(isRed: true, i * 3 + j);
				}
				GUILayout.Space(10f);
				if (j % 3 == 2)
				{
					GUILayout.EndHorizontal();
				}
			}
		}
		GUILayout.EndVertical();
		GUILayout.EndArea();
		GUILayout.BeginArea(new Rect(RightAreaSize * (float)Screen.width * 0.5f, R_TopAreaSize * (float)Screen.height, RightAreaSize * (float)Screen.width * 0.5f, R_MidAreaSize * (float)Screen.height));
		GUILayout.BeginVertical();
		GUILayout.Label("蓝", BlueTextStyle);
		for (int k = 0; k < 3; k++)
		{
			for (int l = 0; l < 3; l++)
			{
				if (l % 3 == 0)
				{
					GUILayout.BeginHorizontal();
				}
				if (GUILayout.Button("*"))
				{
					ChooseHitObj(isRed: false, k * 3 + l);
				}
				GUILayout.Space(10f);
				if (l % 3 == 2)
				{
					GUILayout.EndHorizontal();
				}
			}
		}
		GUILayout.EndVertical();
		GUILayout.EndArea();
		GUILayout.EndHorizontal();
	}

	private void WallGUI()
	{
		GUILayout.BeginArea(new Rect(0f, (R_TopAreaSize + R_MidAreaSize) * (float)Screen.height, RightAreaSize * (float)Screen.width, (1f - R_TopAreaSize - R_MidAreaSize - 0.03f) * (float)Screen.height));
		WallScrollVect2 = GUILayout.BeginScrollView(WallScrollVect2);
		for (int i = 0; i < testWallCount; i++)
		{
			if (i % 3 == 0)
			{
				GUILayout.BeginHorizontal();
			}
			if (GUILayout.Button("墙" + i, GUILayout.Width((RightAreaSize * (float)Screen.width - 70f) / 3f)))
			{
				ChooseWall(i);
			}
			GUILayout.Space(10f);
			if (i % 3 == 2 || i == testWallCount - 1)
			{
				GUILayout.EndHorizontal();
			}
		}
		GUILayout.EndScrollView();
		GUILayout.EndArea();
	}

	private void BottomSlider()
	{
		GUILayout.BeginArea(new Rect(0f, 0.98f * (float)Screen.height, Screen.width, 50f));
		SliderValue = GUILayout.HorizontalSlider(SliderValue, 0f, 1f);
		if (SliderValue != OldSliderValue && Input.GetMouseButton(0))
		{
			UnityEngine.Debug.LogError("OnValueChangedByMouse");
		}
		OldSliderValue = SliderValue;
		GUILayout.EndArea();
	}

	public void SetSliderValueByManager(int value)
	{
		SliderValue = value;
		OldSliderValue = value;
	}

	private void SelectPath()
	{
	}

	private void ChoosePoint(bool isRed, int index)
	{
		UnityEngine.Debug.LogError("ChoosePoint:" + isRed + "," + index);
	}

	private void ChooseHitObj(bool isRed, int index)
	{
		UnityEngine.Debug.LogError("ChooseHitObj:" + isRed + "," + index);
	}

	private void ChooseWall(int index)
	{
		UnityEngine.Debug.LogError("ChooseWall:" + index);
	}
}
public class csSimpleRigidbody : MonoBehaviour
{
	public Transform thisT;

	private bool isKinematic;

	public bool useGravity = true;

	public Vector3 velocity;

	private bool isStart;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void AddForce(Vector3 force)
	{
		velocity = force;
	}

	private void Update()
	{
		if (!isKinematic)
		{
			if (useGravity)
			{
				velocity += Physics.gravity * Time.deltaTime;
			}
			thisT.position += velocity * Time.deltaTime;
		}
	}

	public void SetKinematic(bool isTrue)
	{
		isKinematic = isTrue;
		if (isKinematic)
		{
			velocity = Vector3.zero;
		}
	}

	public bool GetKinematic()
	{
		return isKinematic;
	}
}
[Serializable]
public class csThinkingGameData
{
	public AudioClip CoachStartVoiceClip;
}
public class csType
{
}
[Serializable]
public class LevelObjectData
{
	public GameObject LevelPrefab;

	public AudioClip[] LevelSongs;
}
[Serializable]
public class SongDataObject
{
	public GameObject SongDataPrefab;

	public GameObject LevelDataPrefab;
}
[Serializable]
public enum SearchKeywords
{
	None,
	Boxing,
	Stick,
	Follow,
	Think,
	KeepFit,
	LossWeight,
	MakeBody,
	DifEasy,
	DifNormal,
	DifHard,
	Timelessten,
	Timetentofifteen,
	Timemore,
	Keep,
	superMonkey,
	SearchKeywords16,
	SearchKeywords17,
	SearchKeywords18
}
public enum Festival
{
	None,
	NationalDay
}
public enum ServerRegion
{
	None = -1,
	Asia = 0,
	Australia = 1,
	CanadaEast = 2,
	China = 3,
	Europe = 4,
	India = 5,
	Japan = 6,
	Russia = 7,
	RussiaEast = 8,
	SouthAmerica = 9,
	SouthKorea = 10,
	USAEAST = 11,
	USAWEST = 12,
	ALL = 50
}
public enum EyeFadeMode
{
	OnlyBlack,
	LoadingDot,
	ShowText,
	LogoText,
	LogoAnim,
	ProgressBar
}
public enum GameType
{
	None = -1,
	Level,
	Endless,
	Tutorial
}
public enum HandType
{
	LEFT = 0,
	RIGHT = 1,
	FIT = 3
}
[Serializable]
public class PlayerInfoInPlayfab
{
	public string NickName = "";

	public string NickID;

	public int Height;

	public int Weight;

	public int Age;

	public int ArmLength;

	public int SquatHeight;

	public bool isMale;

	public string AvatarInfo;

	public List<string> playedClass = new List<string>();

	public List<string> classCollection = new List<string>();

	public List<SearchKeywords> LikeTabs = new List<SearchKeywords>();

	public PlayerInfoInPlayfab()
	{
	}

	public PlayerInfoInPlayfab(string _NickID, string _NickName, int _Height, int _Weight, int _Age, int _ArmLength, int _SquatHeight, bool _isMale, List<SearchKeywords> _LikeTabs, List<string> _playedClass, List<string> _classCollection)
	{
		NickID = _NickID;
		NickName = _NickName;
		Height = _Height;
		Weight = _Weight;
		Age = _Age;
		ArmLength = _ArmLength;
		SquatHeight = _SquatHeight;
		isMale = _isMale;
		LikeTabs = _LikeTabs;
		classCollection = _classCollection;
		playedClass = _playedClass;
	}

	public PlayerInfoInPlayfab(PlayerInfoInPlayfab temp)
	{
		NickID = temp.NickID;
		NickName = temp.NickName;
		Height = temp.Height;
		Weight = temp.Weight;
		Age = temp.Age;
		isMale = temp.isMale;
		LikeTabs = temp.LikeTabs;
		classCollection = temp.classCollection;
		playedClass = temp.playedClass;
	}

	public PlayerInfoInPlayfab(List<SearchKeywords> _LikeTabs)
	{
		LikeTabs = _LikeTabs;
	}
}
public class PlayerClassHistoryData
{
	public List<ClassData> HistoryClassList = new List<ClassData>();

	public List<ClassData> CollectionClassList = new List<ClassData>();

	public List<string> CollectionPlanList = new List<string>();
}
public class PlayerClassScoreData
{
	public List<ClassScoreData> ScoreList = new List<ClassScoreData>();
}
[Serializable]
public class ClassScoreData
{
	public string ClassID;

	public long Score;
}
[Serializable]
public class ClassData
{
	public string ClassID;

	public ClassHistoryState HistoryState;

	public ClassData(string cid, ClassHistoryState chs)
	{
		ClassID = cid;
		HistoryState = chs;
	}
}
public enum ClassHistoryState
{
	UnFinished,
	Finished,
	Collection
}
public enum BannerType
{
	SpColumn,
	Class,
	Plan,
	Brand,
	TutorialEnterance
}
public class PicoAccountInfo
{
	public string picoID;

	public string picoAvatarID;

	public string picoNickName;

	public string headIconURL;

	public List<string> picoAvatarClothes = new List<string>();

	public List<string> friendID = new List<string>();

	public List<SearchKeywords> picoLikeTab = new List<SearchKeywords>();

	public bool isMale;

	public int Age;

	public int Height;

	public int Weight;

	public float sumCal;

	public float dayCal;

	public float weekCal;

	public float monthCal;

	public PicoAccountInfo(string _picoID, string _picoAvatarID, string _picoNickName, string _headIconURL, List<string> _picoAvatarClothes, List<string> _friendID, List<SearchKeywords> _picoLikeTab, bool _isMale, int _Age, int _Height, int _Weight, float _sumCal, float _dayCal, float _weekCal, float _monthCal)
	{
		picoID = _picoID;
		picoAvatarID = _picoAvatarID;
		picoNickName = _picoNickName;
		headIconURL = _headIconURL;
		picoAvatarClothes = _picoAvatarClothes;
		friendID = _friendID;
		picoLikeTab = _picoLikeTab;
		isMale = _isMale;
		Age = _Age;
		Height = _Height;
		Weight = _Weight;
		sumCal = _sumCal;
		dayCal = _dayCal;
		weekCal = _weekCal;
		monthCal = _monthCal;
	}

	public PicoAccountInfo()
	{
	}

	public PicoAccountInfo(PicoAccountInfo temp)
	{
		picoID = temp.picoID;
		picoAvatarID = temp.picoAvatarID;
		picoNickName = temp.picoNickName;
		headIconURL = temp.headIconURL;
		picoAvatarClothes = temp.picoAvatarClothes;
		friendID = temp.friendID;
		picoLikeTab = temp.picoLikeTab;
		isMale = temp.isMale;
		Age = temp.Age;
		Height = temp.Height;
		Weight = temp.Weight;
		sumCal = temp.sumCal;
		dayCal = temp.dayCal;
		weekCal = temp.weekCal;
		monthCal = temp.monthCal;
	}
}
public class ClassInfo
{
	public string classID;

	public int diff;

	public csPlayMode type;

	public List<SearchKeywords> tab = new List<SearchKeywords>();

	public string className;

	public float classTime;

	public string coachIcon;

	public string coachName;

	public string shortInfo;

	public string detailInfo;

	public string classPic;

	public string classMovie;

	public string updateTime;

	public int playerNums;
}
public class SportPlan
{
	public string PlanID;

	public List<string> classIDs = new List<string>();

	public string planName;

	public string shortInfo;

	public string detailInfo;

	public string planPic;
}
public class NoticeData
{
	public string version;

	public string activityNotice;

	public string newsNotice;
}
public class playerPlayInfo
{
	public float dayCal;

	public float weekCal;

	public float monthCal;

	public float precision;

	public float power;

	public float allCal;

	public float sumPoint;

	public playerPlayInfo(float _dayCal, float _weekCal, float _monthCal, float _precision, float _power, float _allCal, float _sumPoint)
	{
		dayCal = _dayCal;
		weekCal = _weekCal;
		monthCal = _monthCal;
		precision = _precision;
		power = _power;
		allCal = _allCal;
		sumPoint = _sumPoint;
	}

	public playerPlayInfo()
	{
	}
}
[Serializable]
public class VersionedVideoVersionData
{
	public List<VideoVersionDataByVersion> VideoVersionDataByVersionList = new List<VideoVersionDataByVersion>();

	public VersionedVideoVersionData(List<VideoVersionDataByVersion> vvdlist)
	{
		VideoVersionDataByVersionList = vvdlist;
	}
}
[Serializable]
public class VideoVersionDataByVersion
{
	public string Version;

	public List<VideoVersionItem> VersionDataList;

	public VideoVersionDataByVersion(string v, List<VideoVersionItem> vdl)
	{
		Version = v;
		VersionDataList = vdl;
	}
}
[Serializable]
public class VideoVersionData
{
	public List<VideoVersionItem> VersionDataList;

	public VideoVersionData(List<VideoVersionItem> vdl)
	{
		VersionDataList = vdl;
	}
}
[Serializable]
public class VideoVersionItem
{
	public string ClassID;

	public int WPVersion;

	public int CDVersion;

	public int FolVersion;

	public VideoVersionItem(string cid, int wpv, int cdv, int folv)
	{
		ClassID = cid;
		WPVersion = wpv;
		CDVersion = cdv;
		FolVersion = folv;
	}
}
public class CurrentVersion
{
	public List<VersionInfo> VersionList = new List<VersionInfo>();
}
public class VersionInfo
{
	public string VersionName;

	public string VersionValue;

	public string TestVersionValue;

	public string PatchValue;

	public string TestPatchValue;
}
public enum GAMESTATE
{
	MENUSTART = 1,
	INGAME,
	GAMEEND,
	GAMEPAUSE,
	Loading,
	CountDown,
	StartGame,
	SLevelCountDown,
	CoachTimePause,
	CoachTime,
	RelaxTime,
	FollowTime,
	FollowTimePause,
	FollowResult,
	FollowGap,
	FollowGapPause,
	TutorialPractice,
	TutorialVideo,
	TutorialVideoPause
}
public enum csBeatItemType
{
	None = 0,
	Wall = 1,
	Normal = 2,
	Direction = 3,
	Defence = 4,
	Obstacle = 5,
	Reward = 6,
	Turning = 7,
	Triangle = 8,
	Way = 9,
	StickDirection = 10,
	StickTurning = 11,
	SwiftKnee = 12,
	SwiftKick = 13,
	SwiftTrample = 14,
	SceneHoleStart = 20,
	SceneHoleEnd = 21,
	FootRingHint = 22,
	SceneLineObj = 23
}
public enum csBeatCurvePointType
{
	Start,
	Mid,
	End,
	Single
}
public enum csPlayMode
{
	Menu = 0,
	Follow = 0,
	Stick = 1,
	Boxing = 2,
	FollowBoxing = 3,
	FollowSword = 4
}
public enum csHitObjType
{
	LT,
	MT,
	RT,
	LM,
	MM,
	RM,
	LB,
	MB,
	RB
}
public enum csBeatItemColor
{
	LBlack,
	RWhite
}
public enum PanelType
{
	None = 0,
	Login = 1,
	MainMenu = 2,
	Loading = 3,
	Tips = 4,
	VRKeyboard = 5,
	Settings = 6,
	TipsNoButton = 7,
	Developer = 8,
	Tutorial = 9,
	HeadDetail = 35,
	MyInformation = 36,
	Plan = 37,
	Room = 38,
	Friends = 39,
	Multi = 20,
	FirstLogin = 21,
	LevelChoose = 10,
	ClassDetail = 11,
	DownloadPanel = 12,
	OrderManagerPanel = 13,
	SpColumn = 22,
	disconnect = 23,
	CommonHint = 24,
	AnnouncementDetailsPanel = 25,
	InGameFollowResult = 28,
	InGameFollowPause = 29,
	InGameGaming = 30,
	InGamePause = 31,
	InGameResult = 32,
	InGameSLevelResult = 33,
	InGameCoachPause = 34,
	InGameCurrentData = 40,
	InGameFollowGap = 41,
	InGameTutorialResult = 42,
	InGameTutorialPause = 43,
	InGameRelaxPause = 44,
	InGameResultForSuperMonkey = 45,
	InGameCommonHint = 46,
	InGameSwiftHint = 47
}
public enum ReleaseType
{
	None,
	Official,
	DevTest,
	BetaTest
}
public enum ChannelType
{
	Steam,
	PicoXR,
	Viveport,
	Oculus,
	NoAccount,
	OfflineStore,
	DianXin,
	Wave6Dof,
	Nolo6Dof
}
public enum XRDeviceType
{
	Vive,
	Oculus,
	WMR,
	Cosmos,
	PicoNeo3,
	Pico4
}
public enum VideoType
{
	WarmUp,
	CoolDown,
	Follow
}
[Serializable]
public class GameSongData
{
	public string SongID;

	public string LevelDataUrlName;

	public string ClassID;

	public string ClassTitleID;

	public string ClassDetailID;

	public int ClassTotalTime;

	public ClassType Type;

	public ClassPayType PayType;

	public List<ClassFeature> ClassFeatures;

	public string CaochName;

	public Diff Diff;

	public string CoverImgID;

	public string CoachImgID;

	public string FixedWPSkyboxName;

	public string WarmUpOrFollowVideoNum;

	public float WarmUpOrFollowVideoLength;

	public int WPVideoVersion = 1;

	public bool IsSingleEyeLevel;

	public float EyeOffsetX;

	public List<SingleLevelDataInGameData> GameSongInfoList = new List<SingleLevelDataInGameData>();

	public List<string> PrepareClassIDList;

	public string FixedCDSkyboxName;

	public string CoolDownVideoNum;

	public float CoolDownVideoLength;

	public int CDVideoVersion = 1;

	public List<FollowVideoData> FollowVideoDataList;

	public int FolVideoVersion = 1;

	public csPlayMode TypeInHand;

	public csPlayMode HandTypeInFollow;

	public float WarmUpVideoVol = 1f;

	public Vector2 WarmUpVideoScale = new Vector2(2.2f, 2.2f);

	public Vector3 WarmUpVideoOffset = new Vector3(0f, -0.801f, -0.704f);

	public Vector3 WarmUpCaochEuler = new Vector3(0f, 180f, 0f);

	public float CoolDownVideoVol = 1f;

	public Vector2 CoolDownVideoScale = new Vector2(2.2f, 2.2f);

	public Vector3 CoolDownVideoOffset = new Vector3(0f, -0.801f, -0.704f);

	public Vector3 CoolDownCaochEuler = new Vector3(0f, 180f, 0f);

	public int weight = 9999;
}
[Serializable]
public class FollowVideoData
{
	public string VideoName;

	public int GapTime;

	public float VideoVol = 1f;

	public Vector2 VideoScale;

	public Vector3 VideoOffset;

	public Vector3 CoachEuler;

	public FollowVideoData()
	{
	}

	public FollowVideoData(string vname, int gt, float vol, Vector2 vs, Vector3 voff, Vector3 ce)
	{
		VideoName = vname;
		GapTime = gt;
		VideoVol = vol;
		VideoScale = vs;
		VideoOffset = voff;
		CoachEuler = ce;
	}
}
public enum Diff
{
	easy,
	normal,
	hard,
	hardest
}
public enum ClassFeature
{
	Conceal = -1,
	Recommend,
	Abdomen,
	Wweat,
	Other,
	KeepFit,
	LossWeight,
	MakeBody,
	SuperMonkey,
	Keep,
	AddOn,
	Swift,
	AlphaTestLevels,
	SwiftVibration,
	Pamela
}
public enum ClassType
{
	Sport,
	Follow,
	Think,
	TutorialPunch,
	TutorialStick,
	TUtorialFollow,
	SuperGorilla,
	Mix
}
public enum ClassPayType
{
	Free,
	Pay
}
public enum Languages
{
	ChineseSimplified,
	English,
	German,
	Korean,
	French,
	Japanese
}
public enum PoolObjectType
{
	PointHitRed = 0,
	PointHitBlue = 1,
	HitPointRed = 2,
	HitPointBlue = 3,
	HitObj_LBL = 4,
	HitObj_LML = 5,
	HitObj_LTL = 6,
	HitObj_MBL = 7,
	HitObj_MML = 8,
	HitObj_MTL = 9,
	HitObj_RBL = 10,
	HitObj_RML = 11,
	HitObj_RTL = 12,
	HitObj_LBR = 13,
	HitObj_LMR = 14,
	HitObj_LTR = 15,
	HitObj_MBR = 16,
	HitObj_MMR = 17,
	HitObj_MTR = 18,
	HitObj_RBR = 19,
	HitObj_RMR = 20,
	HitObj_RTR = 21,
	PunchObject_Normal = 22,
	PunchObject_Direction = 23,
	PunchOjbect_Defend = 24,
	PunchOjbect_Turning = 25,
	PunchOjbect_Reward = 26,
	HitPointSingle = 27,
	ItemSpawnPoint = 28,
	FootRingObject = 29,
	StickObject_Way = 30,
	StickObject_Diection = 31,
	comboPrefab = 32,
	StickObject_Turning = 33,
	FootRingObject_Swift = 34,
	SwiftObject_Knee = 40,
	SwiftObject_Kick = 41,
	SwiftObject_Trample = 42,
	SwiftObject_Kick2 = 43,
	DefenceEffect = 5000,
	HitEffect_Speed1 = 5001,
	HitEffect_Speed2 = 5002,
	HitEffect_Speed3 = 5003,
	HitEffect_Speed3_zhiquan = 5004,
	HitEffect_Speed1_gun = 5005,
	HitEffect_Speed3_gun = 5006,
	WallPassEffect = 5010,
	RewardEffect_1 = 5100,
	RewardEffect_2 = 5101,
	TrianglePassEffect_2000 = 5210,
	HitEffect_Swift_KickLow = 5301,
	HitEffect_Swift_Kick = 5302,
	HitEffect_KneeLow = 5303,
	HitEffect_Knee = 5304,
	Wall_1000 = 1000,
	Triangle_2000 = 2000,
	Triangle_2100 = 2100,
	Triangle_2200 = 2200,
	Triangle_2300 = 2300,
	Triangle_2400 = 2400,
	Triangle_2500 = 2500,
	Triangle_2600 = 2600,
	Triangle_2700 = 2700,
	Triangle_2800 = 2800,
	Triangle_2900 = 2900,
	Triangle_2901 = 2901,
	Triangle_2902 = 2902,
	Triangle_2903 = 2903,
	Rewarad_3000 = 3000,
	LineRndBoxCol = 6000,
	SwiftHitHintL = 7000,
	SwiftHitHintR = 7001
}
public enum PoolUIHintType
{
	DebugHint,
	HitHarder,
	WatchDirection,
	SwiftKick_Soft,
	SwiftKick_Hard,
	SwiftKnee_Soft,
	SwiftKnee_Hard
}
public enum DowloadState
{
	Wait,
	Downloading,
	Stoped,
	Completed
}
public enum CommonHintType
{
	OnlyText,
	OnlyTextImage,
	TextOneButton,
	TextTwoButton,
	TextImageOneButton,
	TextImageTwoButton
}
[Serializable]
public enum OrderType
{
	Once,
	Continuity
}
[Serializable]
public enum OrderDevice
{
	Neo3,
	Pico4,
	Other
}
public enum GameScene
{
	Main,
	Follow,
	Thinking,
	Tutorial
}
public enum HitSoundEffectType
{
	Relax,
	Dynamic,
	Burn
}
[Serializable]
public class csBeatItemData
{
	public Vector3 LocalPos;

	public Quaternion LocalRot;

	public float BeatPos;

	public csBeatItemType m_BeatItemType;

	public csBeatItemColor m_BeatItemColor;

	public int TypeIndex;

	public int AngleTurn;

	public int BeatTrack;

	public List<Vector3> WayPointList;

	public string BeatHint;

	public csBeatItemData()
	{
	}

	public csBeatItemData(Vector3 localp, Quaternion localr, float bpos, csBeatItemType itemtype, csBeatItemColor itemcolor, int ti, int at, int bt, List<Vector3> wpl, string bh)
	{
		LocalPos = localp;
		LocalRot = localr;
		BeatPos = bpos;
		m_BeatItemType = itemtype;
		m_BeatItemColor = itemcolor;
		TypeIndex = ti;
		AngleTurn = at;
		BeatTrack = bt;
		WayPointList = wpl;
		BeatHint = bh;
	}
}
[Serializable]
public class csRoomInfo
{
	public string GameId;

	public string AppVersion;

	public string Region;

	public string UserId;

	public string NickName;

	public int PlayerCount;

	public bool Jia;

	public bool IsOpen;

	public bool IsVisible;

	public int MaxPlayers;

	public CustomProperties CustomProperties;

	public string CreatTime;
}
[Serializable]
public class CustomProperties
{
	public int pc;

	public int mi;

	public bool cdsi;

	public string invite;

	public int orr;

	public bool ic;

	public bool otb;

	public int gm;

	public string rn;

	public int WFPT;

	public bool IsOpen;

	public bool IsVisible;

	public int pcr;

	public bool hasPsw;

	public string Psw;

	public bool IsRank;
}
[Serializable]
public class SpColumnData
{
	public string BannerID;

	public string TitleID;

	public string[] ClassGroup;

	public SpColumnData(string banner, string title, string[] classes)
	{
		BannerID = banner;
		TitleID = title;
		ClassGroup = classes;
	}
}
[Serializable]
public class TitleDataInPlayFab
{
	public List<SpColumnData> list = new List<SpColumnData>();
}
public class SportPlanDataInPlayFab
{
	public List<SportPlanData> list = new List<SportPlanData>();
}
[Serializable]
public class SportPlanData
{
	public string PlanID;

	public string NameID;

	public string ImageID;

	public string DetailID;

	public int Days;

	public List<SportPlanClassData> ClassIDs;

	public SportPlanData(string _PlanID, string _NameID, string _ImageID, string _DetailID, int _Days, List<SportPlanClassData> _ClassIDs)
	{
		PlanID = _PlanID;
		NameID = _NameID;
		ImageID = _ImageID;
		DetailID = _DetailID;
		Days = _Days;
		ClassIDs = _ClassIDs;
	}
}
[Serializable]
public struct SportPlanClassData
{
	public int dayIndex;

	public List<string> classIDs;

	public SportPlanClassData(int index, List<string> ids)
	{
		dayIndex = index;
		classIDs = ids;
	}
}
[Serializable]
public class PlayerPlanDataInPlayFab
{
	public List<PlayerPlanDetailData> historyPlanList = new List<PlayerPlanDetailData>();

	public PlayerPlanDetailData currentPlan
	{
		get
		{
			if (historyPlanList.Count == 0)
			{
				return null;
			}
			return historyPlanList[0];
		}
	}

	public void insertSportPlan(PlayerPlanDetailData plan)
	{
		if (historyPlanList.Count > 10)
		{
			historyPlanList.RemoveAt(9);
		}
		historyPlanList.Insert(0, plan);
	}

	public PlayerPlanDetailData getPlan(string planID)
	{
		return historyPlanList.Find((PlayerPlanDetailData x) => x.PlanID == planID);
	}

	public void ResetPlan(string PlanID)
	{
		PlayerPlanDetailData plan = getPlan(PlanID);
		for (int i = 0; i < plan.PlanDayClassList.Count; i++)
		{
			int num = 0;
			while (i < plan.PlanDayClassList[i].isFinish.Count)
			{
				plan.PlanDayClassList[i].isFinish[num] = false;
				num++;
			}
		}
	}

	public PlayerPlanDataInPlayFab(List<PlayerPlanDetailData> dL)
	{
		historyPlanList = dL;
	}

	public PlayerPlanDataInPlayFab(PlayerPlanDataInPlayFab d)
	{
		historyPlanList = d.historyPlanList;
	}

	public PlayerPlanDataInPlayFab()
	{
	}
}
[Serializable]
public class clockInData
{
	public int aim = 4;

	public List<string> clockInDates = new List<string>();

	public clockInData()
	{
		aim = 4;
	}

	public void changeAim(int target)
	{
		if (target > 7)
		{
			target = 7;
		}
		if (target < 1)
		{
			target = 1;
		}
		aim = target;
	}

	public void addClockInDate(DateTime time)
	{
		string item = time.ToShortDateString();
		if (!clockInDates.Contains(item))
		{
			clockInDates.Add(item);
		}
	}

	public bool isClockIn(DateTime time)
	{
		return clockInDates.Contains(time.ToShortDateString());
	}

	public clockInData(int _aim, List<string> _clockInDates)
	{
		aim = _aim;
		clockInDates = _clockInDates;
	}
}
[Serializable]
public class daySportInfoDataInPlayfab
{
	public List<daySportInfoData> careerInfoList = new List<daySportInfoData>();

	public daySportInfoDataInPlayfab(List<daySportInfoData> _careerInfoList)
	{
		careerInfoList = _careerInfoList;
	}

	public daySportInfoDataInPlayfab()
	{
	}

	public daySportInfoData getCareerDataByDate(DateTime time)
	{
		string text = time.ToShortDateString();
		for (int i = 0; i < careerInfoList.Count; i++)
		{
			if (text == careerInfoList[i].date)
			{
				return careerInfoList[i];
			}
		}
		return null;
	}

	public void addInfo(daySportInfoData data)
	{
		for (int i = 0; i < careerInfoList.Count; i++)
		{
			if (careerInfoList[i].date == data.date)
			{
				if (data.cal != float.NaN && data.cal > 0f)
				{
					careerInfoList[i].cal += data.cal;
				}
				careerInfoList[i].playTime += data.playTime;
				return;
			}
		}
		careerInfoList.Add(data);
	}

	public void addInfo(SportInfoDataWithMode data, string date)
	{
		for (int i = 0; i < careerInfoList.Count; i++)
		{
			if (!(careerInfoList[i].date == date))
			{
				continue;
			}
			if (careerInfoList[i].sportInfoWithMode.Count > 0)
			{
				SportInfoDataWithMode sportInfoDataWithMode = careerInfoList[i].sportInfoWithMode.Find((SportInfoDataWithMode x) => x.mode == data.mode);
				if (sportInfoDataWithMode != null)
				{
					sportInfoDataWithMode.cal += data.cal;
					sportInfoDataWithMode.playTime += data.playTime;
				}
				else
				{
					careerInfoList[i].sportInfoWithMode.Add(data);
				}
			}
			else
			{
				careerInfoList[i].sportInfoWithMode.Add(data);
			}
			break;
		}
	}

	public void resetInfo(daySportInfoData data)
	{
		for (int i = 0; i < careerInfoList.Count; i++)
		{
			if (careerInfoList[i].date == data.date)
			{
				careerInfoList[i].cal = data.cal;
				careerInfoList[i].playTime = data.playTime;
				break;
			}
		}
	}
}
[Serializable]
public class SportInfoDataWithMode
{
	public csPlayMode mode;

	public float cal;

	public float playTime;

	public SportInfoDataWithMode(csPlayMode _mode, float _cal, float _playTime)
	{
		mode = _mode;
		cal = _cal;
		playTime = _playTime;
	}

	public SportInfoDataWithMode()
	{
	}
}
[Serializable]
public class daySportInfoData
{
	public string date;

	public float cal;

	public float playTime;

	public List<SportInfoDataWithMode> sportInfoWithMode = new List<SportInfoDataWithMode>();

	public daySportInfoData(string _data, float _cal, float _playTime)
	{
		date = _data;
		cal = _cal;
		playTime = _playTime;
		sportInfoWithMode = new List<SportInfoDataWithMode>();
	}

	public daySportInfoData()
	{
	}
}
[Serializable]
public class PlayerPlanDetailData
{
	public string PlanID;

	public string startTime;

	public string ImageID;

	public string NameID;

	public string DetailID;

	public int Days;

	public List<ClassInADay> PlanDayClassList = new List<ClassInADay>();

	public PlayerPlanDetailData(string _PlanID, List<ClassInADay> _hasPlayedClass)
	{
		PlanID = _PlanID;
		PlanDayClassList = _hasPlayedClass;
	}

	public PlayerPlanDetailData(PlayerPlanDetailData data)
	{
		PlanID = data.PlanID;
		PlanDayClassList = data.PlanDayClassList;
	}

	public PlayerPlanDetailData()
	{
	}

	public bool isPlanFinish()
	{
		for (int i = 0; i < PlanDayClassList.Count; i++)
		{
			if (!PlanDayClassList[i].GetDayFinish())
			{
				return false;
			}
		}
		return true;
	}

	public PlayerPlanDetailData(SportPlanData data, DateTime nowTime)
	{
		PlanID = data.PlanID;
		startTime = nowTime.ToShortDateString();
		ImageID = data.ImageID;
		NameID = data.NameID;
		DetailID = data.DetailID;
		Days = data.Days;
		for (int i = 0; i < data.ClassIDs.Count; i++)
		{
			PlanDayClassList.Add(new ClassInADay(data.ClassIDs[i].dayIndex, data.ClassIDs[i].classIDs));
		}
	}
}
[Serializable]
public struct ClassInADay
{
	public int dayIndex;

	public List<string> classIDs;

	public List<bool> isFinish;

	public ClassInADay(int index, List<string> ids, List<bool> finish)
	{
		dayIndex = index;
		classIDs = ids;
		isFinish = finish;
	}

	public ClassInADay(int index, List<string> ids)
	{
		dayIndex = index;
		classIDs = ids;
		List<bool> list = new List<bool>();
		for (int i = 0; i < classIDs.Count; i++)
		{
			list.Add(item: false);
		}
		isFinish = list;
	}

	public bool GetDayFinish()
	{
		for (int i = 0; i < isFinish.Count; i++)
		{
			if (!isFinish[i])
			{
				return false;
			}
		}
		return true;
	}
}
public class UrlDataInPlayFab
{
	public List<UrlData> list = new List<UrlData>();
}
[Serializable]
public class UrlData
{
	public string GameDataUrl;

	public List<string> LanguageUrlList = new List<string>();

	public UrlData(string gameData, List<string> languageList)
	{
		GameDataUrl = gameData;
		LanguageUrlList = languageList;
	}
}
[Serializable]
public class SNCheckUrlData
{
	public string SNCheckUrl;
}
[Serializable]
public class PlayerOrderData
{
	public string beginOrderTime;

	public string endOrderTime;

	public OrderType orderType;

	public OrderDevice OrderDevice;

	public PlayerOrderData()
	{
	}

	public PlayerOrderData(string startTime, string endTime, OrderType Type, OrderDevice odv)
	{
		beginOrderTime = startTime;
		endOrderTime = endTime;
		orderType = Type;
		OrderDevice = odv;
	}

	public PlayerOrderData(PlayerOrderData temp)
	{
		beginOrderTime = temp.beginOrderTime;
		endOrderTime = temp.endOrderTime;
		orderType = temp.orderType;
	}

	public void InitData(string startTime, string endTime, OrderType Type, OrderDevice odv)
	{
		beginOrderTime = startTime;
		endOrderTime = endTime;
		orderType = Type;
		OrderDevice = odv;
	}
}
[Serializable]
public class TutorialStepInfo
{
	public TutorialStep tutorialStep;

	public float TimeBeforeOpenHole;

	public List<TutorialOnePracticeInfo> tutorialOnePracticeInfos;

	public float TimeBeforeCloseHole;
}
[Serializable]
public class TutorialOnePracticeInfo
{
	public csBeatItemType beatItemType;

	public csBeatItemColor beatItemColor;

	public float TimeBeforeNextSpawn;
}
[Serializable]
public class AnnouncementData
{
	public List<AnnouncementItem> AnnouncementDataList;

	public AnnouncementData(List<AnnouncementItem> l)
	{
		AnnouncementDataList = l;
	}
}
[Serializable]
public class AnnouncementItem
{
	public string AnnID;

	public string DateStart;

	public string DateEnd;

	public string AnnouceTitleCN;

	public string AnnouceTitleEN;

	public string AnnouceDetailCN;

	public string AnnouceDetailEN;

	public string ImgTitleURLCN;

	public string ImgTitleURLEN;

	public string ImgDetailURLCN;

	public string ImgDetailURLEN;
}
[Serializable]
public class GameVersionData
{
	public string VersionOnline;

	public string VersionPretest;

	public string VersionInDev;
}
[Serializable]
public class ServerMaintenData
{
	public List<VersionMaintenData> MainTenDataList;

	public ServerMaintenData(List<VersionMaintenData> l)
	{
		MainTenDataList = l;
	}
}
[Serializable]
public class VersionMaintenData
{
	public string Version;

	public bool IsInMainten;

	public string DetailTextCN;

	public string DetailTextEN;

	public VersionMaintenData(string v, bool isOn, string cn, string en)
	{
		Version = v;
		IsInMainten = isOn;
		DetailTextCN = cn;
		DetailTextEN = en;
	}
}
[Serializable]
public class PlayerNickNameData
{
	public List<string> NickNameList;
}
[Serializable]
public class PlayerAllTimeBeheaviorData
{
	public List<DailyBeheaviorData> AllTimeBeheaviorList = new List<DailyBeheaviorData>();
}
[Serializable]
public class DailyBeheaviorData
{
	public string DateTime;

	public List<ClassBeheavior> DailyBeheaviorList = new List<ClassBeheavior>();
}
[Serializable]
public class ClassBeheavior
{
	public BeheaviorType m_BeheaviorType;

	public string ID;

	public int Num;
}
[Serializable]
public class ClassBehaviourForAll
{
	public string ID;

	public int playTimes;

	public int playerNumbers;

	public int collectTimes;

	public ClassBehaviourForAll(string s)
	{
		ID = s;
		playTimes = 0;
		playerNumbers = 0;
		collectTimes = 0;
	}
}
public enum BeheaviorType
{
	ClassFinishNum,
	CalCost
}
[Serializable]
public class OfflineGateData
{
	public List<OfflineGateVersionData> VersionDataList;

	public OfflineGateData(List<OfflineGateVersionData> v)
	{
		VersionDataList = v;
	}
}
[Serializable]
public class OfflineGateVersionData
{
	public string Version;

	public bool OverAllSwitch;

	public string DateTimeStart;

	public string DateTimeEnd;

	public string TempAccountVipEndDate;

	public OfflineGateVersionData(string v, bool ovs, string dts, string dte, string taed)
	{
		Version = v;
		OverAllSwitch = ovs;
		DateTimeStart = dts;
		DateTimeEnd = dte;
		TempAccountVipEndDate = taed;
	}
}
[Serializable]
public class PlayerDailyGoalData
{
	public int palyTimeAim;

	private float calPerMin = 0.1f;

	public int calAim;

	public int calAimState;

	public int palyTimeAimState;

	public List<string> finishDates = new List<string>();

	public PlayerDailyGoalData()
	{
	}

	public PlayerDailyGoalData(int _palyTimeAim, int _calAim, int _calAimState, int _playTimeAimState, List<string> _finishDates)
	{
		palyTimeAim = _palyTimeAim;
		calAimState = _calAimState;
		palyTimeAimState = _playTimeAimState;
		finishDates = _finishDates;
	}

	public void SetAim(int targetPlayTime)
	{
		palyTimeAim = targetPlayTime;
		calAim = (int)((float)targetPlayTime * calPerMin);
		UnityEngine.Debug.Log("<color=yellow>===SetAim===" + palyTimeAim + "</color>");
	}

	public int GetCalAim()
	{
		return calAim;
	}

	public void UpdateAimState(float _cal, float _playTime)
	{
		if (calAim != 0 && palyTimeAim != 0)
		{
			int num = ((_cal != 0f) ? ((!(_cal >= (float)calAim)) ? 1 : 2) : 0);
			calAimState = num;
			int num2 = ((_playTime != 0f) ? ((!(_playTime >= (float)calAim)) ? 1 : 2) : 0);
			palyTimeAimState = num2;
		}
	}

	public int GetCalAimState()
	{
		return calAimState;
	}

	public int GetPlayTimeAimState()
	{
		return palyTimeAimState;
	}

	public void AddFinishDate(DateTime time)
	{
		string item = time.ToShortDateString();
		if (!finishDates.Contains(item))
		{
			finishDates.Add(item);
		}
	}

	public bool CheckIsFinish(DateTime time)
	{
		return finishDates.Contains(time.ToShortDateString());
	}
}
public enum VFllowItemType
{
	CheckPointStart,
	CheckPointEnd,
	MovementJudge,
	MultiMovement,
	MultiMovementChild,
	Interactable
}
[Serializable]
public class SingleMoveData
{
	public SingleMoveDataHeadSet HeadSetData;

	public SingleMoveDataController ControllerDataL;

	public SingleMoveDataController ControllerDataR;
}
[Serializable]
public class MultiMoveData
{
	public List<SingleMoveData> sgDataList;

	public int FinishCount;
}
[Serializable]
public class SingleMoveDataHeadSet
{
	public bool IsCheck;

	public float HeightPercent;

	public float Speed;

	public bool IsCheckDir;

	public Vector3 LookDir;
}
[Serializable]
public class SingleMoveDataController
{
	public bool IsCheck;

	public bool IsCheckDirToHead;

	public Vector3 HandDir;

	public bool IsCheckDistToHead;

	public float HandDist;

	public bool IsCheckVel;

	public Vector3 Vel;
}
[Serializable]
public class csVFItemData
{
	public VFllowItemType VFType;

	public float ShowTime;

	public SingleMoveData smData;

	public MultiMoveData mmData;
}
public class VFItemCheckData
{
	public VFllowItemType VFType;

	public bool IsCorrect;

	public VFItemCheckData(VFllowItemType vt, bool ic)
	{
		VFType = vt;
		IsCorrect = ic;
	}
}
public class csVideoPrefabData : MonoBehaviour
{
	public Transform BeatLineT;

	public VideoClip VClip;

	public Dictionary<float, List<csEditorBeatItem>> TimeBeatListDict = new Dictionary<float, List<csEditorBeatItem>>();

	public List<csEditorBeatPoint> BeatPointList = new List<csEditorBeatPoint>();

	public List<csVFollowItemBase> VFItemList = new List<csVFollowItemBase>();

	public int VideoPlayTime;

	public string CurVideoLevelName;

	public string CurVideoCoachName;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void ProcessItemToDictionary()
	{
	}

	private void OnEnable()
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.OnSelected(isSel: false);
		}
	}

	public void AddBeatLinePoint(csEditorBeatPoint bp)
	{
		BeatPointList.Add(bp);
	}

	public void RefreshLineBeatItemPoint(float newGapDis)
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.thisT.localPosition = new Vector3(0f, 0f, newGapDis * beatPoint.BeatTime);
		}
		ProcessItemToList();
		foreach (csVFollowItemBase vFItem in VFItemList)
		{
			vFItem.thisT.localPosition = new Vector3(vFItem.thisT.localPosition.x, vFItem.thisT.localPosition.y, newGapDis * vFItem.ShowTime);
		}
	}

	public void ProcessItemToList()
	{
		VFItemList.Clear();
		csVFollowItemBase[] componentsInChildren = thisT.GetComponentsInChildren<csVFollowItemBase>();
		foreach (csVFollowItemBase item in componentsInChildren)
		{
			VFItemList.Add(item);
		}
	}

	public void OpenListItemCollider()
	{
		foreach (csVFollowItemBase vFItem in VFItemList)
		{
			if ((bool)vFItem.ItemCol)
			{
				vFItem.ItemCol.enabled = true;
			}
		}
	}

	public void SaveItemToList()
	{
		VClip = csMusicEditorVideoFollow.instance.vp.clip;
		VFItemList.Clear();
		csVFollowItemBase[] componentsInChildren = thisT.GetComponentsInChildren<csVFollowItemBase>();
		foreach (csVFollowItemBase item in componentsInChildren)
		{
			VFItemList.Add(item);
		}
	}

	public void CloseBeatBaseLine(bool isClose)
	{
		foreach (csEditorBeatPoint beatPoint in BeatPointList)
		{
			beatPoint.gameObject.SetActive(!isClose);
		}
	}
}
public class csWallHole : MonoBehaviour
{
	public bool IsHeadHole;

	public csEditorBeatItem_Wall ParentWall;

	public bool CheckColor;

	public csBeatItemColor HoleColor = csBeatItemColor.RWhite;

	public void Reset()
	{
	}
}
public class csWallJudgeChecker : MonoBehaviour
{
	public csEditorBeatItem_Wall ParentWall;
}
public class csWayPathInnerCollider : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class LevelBroadCastHintCanvas : MonoBehaviour
{
	public static LevelBroadCastHintCanvas instance;

	public string HintText;

	public Image BKGImg;

	public Text TextHintT;

	public Color[] BkgColors;

	public HintTense HTense;

	public Transform PlayerRig;

	public Queue<TenseHintData> HintDataList = new Queue<TenseHintData>();

	private void Awake()
	{
		instance = this;
	}

	public void InitHintText(HintTense ht, string h)
	{
		HintDataList.Enqueue(new TenseHintData(ht, h));
		if (HintDataList.Count == 1)
		{
			ShowNext();
		}
	}

	public void PeekNext()
	{
		if (HintDataList.Count >= 1)
		{
			ShowNext();
		}
	}

	public void SetPlayerRigFwd(Vector3 dir)
	{
		PlayerRig.rotation = Quaternion.LookRotation(dir, Vector3.up);
	}

	public void ShowNext()
	{
		TenseHintData tenseHintData = HintDataList.Dequeue();
		HTense = tenseHintData.HT;
		BKGImg.color = BkgColors[(int)tenseHintData.HT];
		string hintText = (TextHintT.text = tenseHintData.HintT);
		HintText = hintText;
	}
}
public class TenseHintData
{
	public HintTense HT;

	public string HintT;

	public TenseHintData(HintTense ht, string h)
	{
		HT = ht;
		HintT = h;
	}
}
public class PrefabCreator : MonoBehaviour
{
	public void RunTimeCreatePrefab(GameObject obj, string prefabName)
	{
	}

	public void RunTimeCreateGroupPrefab(GameObject obj, string prefabName)
	{
	}

	public GameObject RunTimeInstantiateGroupPrefab(string prefabName, Vector3 pos)
	{
		return null;
	}
}
public class TestManager : MonoBehaviour
{
	public PrefabCreator PCreator;

	public GameObject PrefabParent;

	public string PreFabname = "PefabTest";

	private void OnGUI()
	{
		if (GUILayout.Button("SavePrefab"))
		{
			PCreator.RunTimeCreatePrefab(PrefabParent, PreFabname);
		}
	}
}
public class csVFollowItemBase : MonoBehaviour
{
	public Transform thisT;

	public float ShowTime;

	public VFllowItemType VFType;

	public Collider ItemCol;

	public int FinishCount = 1;

	public List<csVFollowItemBase> ChildItems;

	public SingleMoveDataHeadSetHolder HeadData;

	public SingleMoveDataControllerHolder CtrlLData;

	public SingleMoveDataControllerHolder CtrlRData;

	public void InitBeat(float selIndex)
	{
		ShowTime = selIndex;
	}

	public void OnItemReturnToPool()
	{
	}
}
public class csVFollowItem_CheckPoint : csVFollowItemBase
{
}
public class csVFollowItem_HeadHandGroup : csVFollowItemBase
{
}
public class csVFollowItem_Interact : csVFollowItemBase
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class csVFollowItem_MultiAct : csVFollowItemBase
{
	public List<csVFollowItem_MultiActChild> ChildItemList = new List<csVFollowItem_MultiActChild>();

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class csVFollowItem_MultiActChild : csVFollowItemBase
{
}
public class csVideoPrefabOptmizedData : MonoBehaviour
{
	public List<SingleVideoLevelData> SingleLevelDataList = new List<SingleVideoLevelData>();

	public void ClearBeatsToPool()
	{
		csVFollowItemBase[] componentsInChildren = base.transform.GetComponentsInChildren<csVFollowItemBase>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnItemReturnToPool();
		}
	}
}
[Serializable]
public class SingleVideoLevelData
{
	public int SongPlayTime;

	public List<csVFItemData> VidItemList = new List<csVFItemData>();
}
public class SingleMoveDataControllerHolder : MonoBehaviour
{
	public SingleMoveDataController ControllerCheckData;
}
public class SingleMoveDataHeadSetHolder : MonoBehaviour
{
	public SingleMoveDataHeadSet HeadSetCheckData;
}
public class AES : MonoBehaviour
{
	private string key = "YFpoGQ@$VrUMf64tZ9eg^RiaQSZ^Pw%*";

	public static string Encrypt(string str, string key)
	{
		AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider();
		try
		{
			aesCryptoServiceProvider.Key = Encoding.UTF8.GetBytes(key);
			aesCryptoServiceProvider.GenerateIV();
			aesCryptoServiceProvider.IV = aesCryptoServiceProvider.IV;
			byte[] bytes = Encoding.UTF8.GetBytes(str);
			byte[] str2 = aesCryptoServiceProvider.CreateEncryptor().TransformFinalBlock(bytes, 0, bytes.Length);
			string text = ToHexString(aesCryptoServiceProvider.IV);
			string text2 = ToHexString(str2);
			return text + ":" + text2;
		}
		catch (Exception value)
		{
			Console.WriteLine(value);
			return null;
		}
	}

	public static string Decrypt(string encodedStr, string key)
	{
		AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider();
		try
		{
			aesCryptoServiceProvider.Key = Encoding.UTF8.GetBytes(key);
			string[] array = encodedStr.Split(':');
			byte[] iV = FromHexString(array[0]);
			aesCryptoServiceProvider.IV = iV;
			byte[] array2 = FromHexString(array[1]);
			return Encoding.UTF8.GetString(aesCryptoServiceProvider.CreateDecryptor().TransformFinalBlock(array2, 0, array2.Length));
		}
		catch (Exception value)
		{
			Console.WriteLine(value);
			return null;
		}
	}

	public static string ToHexString(byte[] str)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (byte b in str)
		{
			stringBuilder.Append(b.ToString("X2"));
		}
		return stringBuilder.ToString();
	}

	public static byte[] FromHexString(string hexString)
	{
		byte[] array = new byte[hexString.Length / 2];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Convert.ToByte(hexString.Substring(i * 2, 2), 16);
		}
		return array;
	}
}
[ExecuteInEditMode]
public class AirplaneNode : MonoBehaviour
{
	public float tangentStrength = 1f;

	public float tangentAngleOffset;

	[HideInInspector]
	public Vector3[] controlPoints;

	[HideInInspector]
	public AirplanePath path;

	public Vector3 Position => base.transform.position;

	private void OnDestroy()
	{
		if (path != null)
		{
			path.OnDestroyedNode(this);
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.DrawSphere(base.transform.position, 0.03f);
	}
}
[AddComponentMenu("Airplane Path/Airplane Path")]
public class AirplanePath : MonoBehaviour
{
	public enum PathLoopingType
	{
		Once,
		Looping
	}

	[Serializable]
	public class GizmoColors
	{
		public Color pathColor = Color.red;

		public Color nodeTangentsColor = Color.green;
	}

	public PathLoopingType loopingType = PathLoopingType.Looping;

	public bool playAtStart = true;

	public bool deactivatePlaneOnStop = true;

	public bool destroyOnDeactivate;

	public bool showGizmos = true;

	public GizmoColors gizmoColors = new GizmoColors();

	public float speed = 100f;

	public float rollIntensity = 2.5f;

	public Transform plane;

	public Transform planeRoot;

	private Transform FlyingPosT;

	public AirplaneNode[] nodes = new AirplaneNode[0];

	private const float rollSmoothing = 5f;

	private float smoothRoll;

	public float time;

	public const int gizmoSplinePrecision = 20;

	private Vector3 p0;

	private Vector3 p1;

	private Vector3 p2;

	private Vector3 p3;

	[HideInInspector]
	public GameObject nodeParent;

	[HideInInspector]
	public Transform lastCreatedNode;

	public bool NeedRoot = true;

	private UnityAction OnPathEnd;

	private UnityAction OnPathNearEnd;

	private bool TryJudgeOverTime;

	public bool UseRotationLerp = true;

	private Quaternion rotation = Quaternion.identity;

	private float SetRotateTime = 0.5f;

	public bool Playing { get; set; }

	public int Index { get; set; }

	public Vector3 Velocity { get; private set; }

	public float RollOffset { get; set; }

	public float TurnRollAngle { get; private set; }

	public event EventHandler<PathOverEventArgs> PathOver;

	private void Start()
	{
		SetControlPoints();
		if (playAtStart)
		{
			StartPath(0);
		}
		GameObject gameObject = new GameObject("PathObject");
		FlyingPosT = gameObject.transform;
	}

	public void StartPath()
	{
		rotation = Quaternion.identity;
		StartPath(0);
	}

	public void StartPath(UnityAction onpEnd, UnityAction onPNear)
	{
		OnPathEnd = onpEnd;
		rotation = Quaternion.identity;
		StartPath(0);
		OnPathNearEnd = onPNear;
	}

	public void StartPath(int firstNodeIndex, float starttime = 0f)
	{
		if (!CheckForProblems(firstNodeIndex))
		{
			plane.gameObject.SetActive(value: true);
			SetRotateTime = 0.5f;
			time = starttime;
			if (starttime == 0f)
			{
				plane.position = nodes[firstNodeIndex].Position;
			}
			Index = firstNodeIndex;
			p0 = nodes[firstNodeIndex].Position;
			p1 = nodes[firstNodeIndex].controlPoints[1];
			if (firstNodeIndex + 1 >= nodes.Length)
			{
				p2 = nodes[0].controlPoints[0];
				p3 = nodes[0].Position;
			}
			else
			{
				p2 = nodes[firstNodeIndex + 1].controlPoints[0];
				p3 = nodes[firstNodeIndex + 1].Position;
			}
			Playing = true;
		}
	}

	public void StopPath()
	{
		OnPathEnd?.Invoke();
		StopPath(deactivatePlaneOnStop);
	}

	public void StopPath(bool deactivatePlane)
	{
		Playing = false;
		if (deactivatePlane)
		{
			plane.gameObject.SetActive(value: false);
		}
		if (this.PathOver != null)
		{
			this.PathOver(this, new PathOverEventArgs(Velocity, TurnRollAngle + RollOffset, deactivatePlane));
		}
		if (deactivatePlane && destroyOnDeactivate)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private bool CheckForProblems(int firstNodeIndex)
	{
		if (nodes.Length <= 1)
		{
			UnityEngine.Debug.LogError("Not enough nodes created", this);
			return true;
		}
		if (firstNodeIndex + 1 == nodes.Length && loopingType == PathLoopingType.Once)
		{
			UnityEngine.Debug.Log("Chosen starting node too high for Once looping type, plane starting at the end of path", this);
			return true;
		}
		if (firstNodeIndex + 1 > nodes.Length)
		{
			UnityEngine.Debug.LogError("Chosen starting node too high, node inexistant", this);
			return true;
		}
		if (nodes.Length <= 2 && loopingType == PathLoopingType.Looping)
		{
			UnityEngine.Debug.Log("Too few nodes for Looping mode, which needs at least 3 nodes. Change looping type or add nodes", this);
			return true;
		}
		if (plane == null)
		{
			UnityEngine.Debug.Log("No aircraft GameObject set", this);
			return true;
		}
		return false;
	}

	private void LogNanError()
	{
		UnityEngine.Debug.LogError(ToString() + " disabled: Subsequent Airplane Nodes may be at the same position, which causes unexpected errors. Try moving nodes a little.", this);
		base.enabled = false;
	}

	private void Update()
	{
		if (!Playing)
		{
			return;
		}
		Vector3 vector = CalculateBezierDerivative(time, p0, p1, p2, p3);
		float magnitude = vector.magnitude;
		if (magnitude == 0f)
		{
			LogNanError();
			return;
		}
		float num = speed / magnitude;
		time += Time.deltaTime * num;
		while (time >= 1f)
		{
			int num2 = Index + 2;
			switch (loopingType)
			{
			case PathLoopingType.Looping:
				Index = ((Index != nodes.Length - 1) ? (Index + 1) : 0);
				num2 = ((Index != nodes.Length - 1) ? (Index + 1) : 0);
				break;
			case PathLoopingType.Once:
				Index++;
				if (Index >= nodes.Length - 2)
				{
					TryJudgeOverTime = true;
				}
				if (Index >= nodes.Length - 1)
				{
					StopPath();
					return;
				}
				num2 = Index + 1;
				break;
			}
			p0 = nodes[Index].Position;
			p1 = nodes[Index].controlPoints[1];
			p2 = nodes[num2].controlPoints[0];
			p3 = nodes[num2].Position;
			time -= 1f;
			time *= magnitude;
			vector = CalculateBezierDerivative(0f, p0, p1, p2, p3);
			magnitude = vector.magnitude;
			time /= magnitude;
			num = speed / magnitude;
		}
		if (TryJudgeOverTime && time > 0.95f)
		{
			OnPathNearEnd?.Invoke();
			TryJudgeOverTime = false;
		}
		Velocity = vector * num;
		FlyingPosT.position = CalculateBezierPoint(time, p0, p1, p2, p3);
		Vector3 vector2 = CalculateBezierSecondDerivative(time, p0, p1, p2, p3);
		SetRotateTime += Time.deltaTime;
		if (SetRotateTime >= 0.1f)
		{
			SetRotateTime = 0f;
			Vector3 normalized = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			if (vector == Vector3.zero)
			{
				LogNanError();
				return;
			}
			float rollFactor = Vector3.Dot(vector2 * speed * 0.001f / magnitude, normalized);
			float z = CalculateRollAngle(rollFactor);
			rotation.SetLookRotation(vector, Vector3.up);
			rotation *= Quaternion.Euler(new Vector3(0f, 0f, z));
		}
		if (UseRotationLerp)
		{
			FlyingPosT.rotation = rotation;
		}
		plane.position = Vector3.MoveTowards(plane.position, FlyingPosT.position, Time.deltaTime * speed);
		if (UseRotationLerp)
		{
			plane.rotation = Quaternion.Lerp(plane.rotation, FlyingPosT.rotation, Time.deltaTime * 5f);
		}
	}

	private float CalculateRollAngle(float rollFactor)
	{
		smoothRoll = Mathf.Lerp(smoothRoll, rollFactor, 5f * Time.deltaTime);
		float num = Mathf.Atan2(1f, smoothRoll * rollIntensity);
		num *= 57.29578f;
		num = (TurnRollAngle = num - 90f);
		return num + RollOffset;
	}

	public void SetControlPoints()
	{
		for (int i = 0; i < nodes.Length; i++)
		{
			if (nodes[i] == null)
			{
				FixNullErrors();
				break;
			}
		}
		if (nodes.Length <= 1)
		{
			return;
		}
		switch (loopingType)
		{
		case PathLoopingType.Looping:
		{
			for (int k = 0; k < nodes.Length; k++)
			{
				AirplaneNode airplaneNode5 = ((k == 0) ? nodes[nodes.Length - 1] : nodes[k - 1]);
				AirplaneNode airplaneNode6 = ((k == nodes.Length - 1) ? nodes[0] : nodes[k + 1]);
				AirplaneNode airplaneNode7 = nodes[k];
				Vector3 vector = CalculateTangent(airplaneNode5.Position, airplaneNode6.Position, airplaneNode7.Position);
				vector = Quaternion.Euler(0f, nodes[k].tangentAngleOffset, 0f) * vector;
				airplaneNode7.controlPoints = new Vector3[2]
				{
					airplaneNode7.Position - vector * airplaneNode7.tangentStrength,
					airplaneNode7.Position + vector * airplaneNode7.tangentStrength
				};
			}
			break;
		}
		case PathLoopingType.Once:
		{
			if (nodes.Length == 2)
			{
				nodes[0].controlPoints = new Vector3[2]
				{
					Vector3.zero,
					(nodes[1].Position + nodes[0].Position) * 0.5f
				};
				nodes[1].controlPoints = new Vector3[2]
				{
					(nodes[0].Position + nodes[1].Position) * 0.5f,
					Vector3.zero
				};
				break;
			}
			Vector3 vector;
			for (int j = 1; j < nodes.Length - 1; j++)
			{
				AirplaneNode airplaneNode = nodes[j - 1];
				AirplaneNode airplaneNode2 = nodes[j + 1];
				AirplaneNode airplaneNode3 = nodes[j];
				vector = CalculateTangent(airplaneNode.Position, airplaneNode2.Position, airplaneNode3.Position);
				vector = Quaternion.Euler(0f, nodes[j].tangentAngleOffset, 0f) * vector;
				airplaneNode3.controlPoints = new Vector3[2]
				{
					airplaneNode3.Position - vector * airplaneNode3.tangentStrength,
					airplaneNode3.Position + vector * airplaneNode3.tangentStrength
				};
			}
			vector = (nodes[1].controlPoints[0] - nodes[0].Position) * 0.5f;
			vector = Quaternion.Euler(0f, nodes[0].tangentAngleOffset, 0f) * vector;
			nodes[0].controlPoints = new Vector3[2]
			{
				Vector3.zero,
				nodes[0].Position + vector * nodes[0].tangentStrength
			};
			AirplaneNode airplaneNode4 = nodes[nodes.Length - 1];
			vector = (nodes[nodes.Length - 2].controlPoints[1] - airplaneNode4.Position) * 0.5f;
			vector = Quaternion.Euler(0f, airplaneNode4.tangentAngleOffset, 0f) * vector;
			airplaneNode4.controlPoints = new Vector3[2]
			{
				airplaneNode4.Position + vector * airplaneNode4.tangentStrength,
				Vector3.zero
			};
			break;
		}
		}
	}

	private Vector3 CalculateTangent(Vector3 previous, Vector3 next, Vector3 current)
	{
		Vector3 vector = (next - previous) * 0.5f;
		Vector3 vector2 = current - (next + previous) * 0.5f;
		Vector3 vector3 = new Vector3(0f - vector2.y, 0f, vector2.x);
		vector3 = ((Vector3.Dot(vector, vector3) >= 0f) ? vector3 : (-vector3));
		Vector3 vector4 = vector3 * 0.5f + vector * 0.5f;
		return new Vector3(vector4.x, vector.y, vector4.z);
	}

	public static Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}

	public static Vector3 CalculateBezierDerivative(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		return -3f * num3 * p0 + (t * (9f * t - 12f) + 3f) * p1 + 3f * t * (2f - 3f * t) * p2 + 3f * num2 * p3;
	}

	private static Vector3 CalculateBezierSecondDerivative(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		return 6f * num * p0 + (18f * t - 12f) * p1 + (6f - 18f * t) * p2 + 6f * t * p3;
	}

	public static float BezierLength(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, int pointCount = 30)
	{
		if (pointCount < 2)
		{
			return 0f;
		}
		float num = 0f;
		Vector3 b = CalculateBezierPoint(0f / (float)pointCount, p0, p1, p2, p3);
		for (int i = 1; i <= pointCount; i++)
		{
			Vector3 vector = CalculateBezierPoint((float)i / (float)pointCount, p0, p1, p2, p3);
			num += Vector3.Distance(vector, b);
			b = vector;
		}
		return num;
	}

	private void SetPathParent()
	{
		if (nodeParent == null)
		{
			Transform transform = base.transform.Find("Path");
			if (transform != null)
			{
				nodeParent = transform.gameObject;
			}
		}
		if (nodeParent == null)
		{
			nodeParent = new GameObject("Path");
			Transform obj = nodeParent.transform;
			obj.parent = base.transform;
			obj.localPosition = Vector3.zero;
			obj.localRotation = Quaternion.identity;
		}
	}

	public void CreateNode()
	{
		SetPathParent();
		List<AirplaneNode> list = new List<AirplaneNode>(nodes);
		GameObject obj = new GameObject("Node " + (nodes.Length + 1));
		Transform transform = obj.transform;
		transform.parent = nodeParent.transform;
		if (lastCreatedNode != null)
		{
			transform.localPosition = lastCreatedNode.localPosition + Vector3.forward;
			transform.localRotation = lastCreatedNode.localRotation;
		}
		else
		{
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
		}
		lastCreatedNode = transform;
		AirplaneNode airplaneNode = obj.AddComponent<AirplaneNode>();
		list.Add(airplaneNode);
		airplaneNode.path = this;
		nodes = list.ToArray();
	}

	public void CreateNodeFromBeatPoint(Transform CurveParent, csEditorBeatItem_Point bp)
	{
		List<AirplaneNode> list = new List<AirplaneNode>(nodes);
		bp.thisT.parent = CurveParent;
		AirplaneNode airplaneNode = bp.gameObject.GetComponent<AirplaneNode>();
		if (airplaneNode == null)
		{
			airplaneNode = bp.gameObject.AddComponent<AirplaneNode>();
		}
		list.Add(airplaneNode);
		airplaneNode.path = this;
		nodes = list.ToArray();
	}

	public void OnDestroyedNode(AirplaneNode destroyedNode)
	{
		List<AirplaneNode> list = new List<AirplaneNode>();
		int num = 1;
		AirplaneNode[] array = nodes;
		foreach (AirplaneNode airplaneNode in array)
		{
			if (airplaneNode != destroyedNode)
			{
				airplaneNode.gameObject.name = "Node " + num;
				num++;
				list.Add(airplaneNode);
			}
		}
		nodes = list.ToArray();
	}

	public UnityEngine.Object[] GetAllObjects()
	{
		List<UnityEngine.Object> list = new List<UnityEngine.Object>();
		AirplaneNode[] array = nodes;
		foreach (AirplaneNode airplaneNode in array)
		{
			list.Add(airplaneNode.gameObject);
		}
		list.Add(this);
		return list.ToArray();
	}

	private void OnDrawGizmos()
	{
		if (!showGizmos || !base.enabled || (loopingType == PathLoopingType.Looping && nodes.Length < 3) || (loopingType == PathLoopingType.Once && nodes.Length < 2))
		{
			return;
		}
		SetControlPoints();
		int num = nodes.Length;
		if (loopingType == PathLoopingType.Once)
		{
			num = nodes.Length - 1;
		}
		for (int i = 0; i < num; i++)
		{
			int num2 = ((i != nodes.Length - 1) ? (i + 1) : 0);
			Gizmos.color = gizmoColors.pathColor;
			float num3 = 0.05f;
			Vector3 position = nodes[i].Position;
			Vector3 vector = nodes[i].controlPoints[1];
			Vector3 vector2 = nodes[num2].controlPoints[0];
			Vector3 position2 = nodes[num2].Position;
			Vector3 from = CalculateBezierPoint(0f, position, vector, vector2, position2);
			float num4 = 0f;
			for (int j = 1; j <= 20; j++)
			{
				num4 += num3;
				Vector3 vector3 = CalculateBezierPoint(num4, position, vector, vector2, position2);
				Gizmos.DrawLine(from, vector3);
				from = vector3;
			}
		}
	}

	public bool IsLast(AirplaneNode node)
	{
		if (node == nodes[nodes.Length - 1])
		{
			return loopingType == PathLoopingType.Once;
		}
		return false;
	}

	public bool IsFirst(AirplaneNode node)
	{
		if (node == nodes[0])
		{
			return loopingType == PathLoopingType.Once;
		}
		return false;
	}

	public void FixNullErrors()
	{
		List<AirplaneNode> list = new List<AirplaneNode>();
		int num = 1;
		int num2 = nodes.Length;
		AirplaneNode[] array = nodes;
		foreach (AirplaneNode airplaneNode in array)
		{
			if (airplaneNode != null)
			{
				airplaneNode.gameObject.name = "Node " + num;
				num++;
				list.Add(airplaneNode);
			}
		}
		nodes = list.ToArray();
		int num3 = nodes.Length;
		if (num2 != num3)
		{
			UnityEngine.Debug.Log("Null References in Nodes array cleared", this);
		}
	}
}
public class csForveateRendering : MonoBehaviour
{
}
public class PathBarrelRoll : MonoBehaviour
{
	public float rollingSpeed = 0.5f;

	private AirplanePath path;

	private bool rolling;

	private float t;

	private void Start()
	{
		path = GetComponent<AirplanePath>();
	}

	private void Update()
	{
		if (rolling)
		{
			Roll();
		}
		else if (Input.GetKeyDown(KeyCode.B) && path.Playing)
		{
			t = 0f;
			rolling = true;
		}
	}

	private void Roll()
	{
		t += Time.deltaTime * rollingSpeed;
		path.RollOffset = Mathf.Lerp(0f, 360f, t);
		if (t >= 1f)
		{
			rolling = false;
			path.RollOffset = 0f;
		}
	}
}
public class PathFreeFall : MonoBehaviour
{
	public float gravity = 10f;

	public float drag = 0.05f;

	public float rollWhenFalling = 100f;

	private AirplanePath path;

	private bool falling;

	private Vector3 velocity;

	private float offsetAngle;

	private float rollingSpeed;

	private void Start()
	{
		path = GetComponent<AirplanePath>();
		path.PathOver += BeginFall;
	}

	private void BeginFall(object sender, PathOverEventArgs args)
	{
		if (!args.Deactivated)
		{
			offsetAngle = args.OffsetRollAngle;
			velocity = args.Velocity;
			falling = true;
			rollingSpeed = 0f;
		}
	}

	private void Update()
	{
		if (falling)
		{
			if (path.Playing)
			{
				falling = false;
			}
			else
			{
				Fall();
			}
		}
		else if (Input.GetKeyDown(KeyCode.Space) && path.Playing)
		{
			falling = true;
		}
	}

	private void Fall()
	{
		velocity -= (Vector3.up * gravity + velocity * drag) * Time.deltaTime;
		path.plane.position += velocity * Time.deltaTime;
		rollingSpeed += Time.deltaTime * rollWhenFalling;
		rollingSpeed = Mathf.Clamp(rollingSpeed, -360f, 360f);
		offsetAngle += Time.deltaTime * rollingSpeed;
		Quaternion identity = Quaternion.identity;
		identity.SetLookRotation(velocity, Vector3.up);
		identity *= Quaternion.Euler(new Vector3(0f, 0f, offsetAngle));
		path.plane.rotation = identity;
	}
}
public class PathStarter : MonoBehaviour
{
	private AirplanePath path;

	private bool hasFreeFall;

	private void Start()
	{
		path = GetComponent<AirplanePath>();
		if (GetComponent<PathFreeFall>() != null)
		{
			hasFreeFall = true;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			if (!path.Playing)
			{
				path.StartPath();
			}
			else if (hasFreeFall)
			{
				path.StopPath(deactivatePlane: false);
			}
		}
	}
}
public class PathOverEventArgs : EventArgs
{
	public Vector3 Velocity { get; set; }

	public float OffsetRollAngle { get; set; }

	public bool Deactivated { get; set; }

	public PathOverEventArgs(Vector3 velocity, float offsetRollAngle, bool deactivated)
	{
		Deactivated = deactivated;
		Velocity = velocity;
		OffsetRollAngle = offsetRollAngle;
	}
}
public class AddPlayerSong : MonoBehaviour
{
	public static AddPlayerSong Instance;

	public GameObject UnSearch;

	public GameObject AddOn;

	public Dictionary<string, AssetBundle> UrlNametoBundleDic = new Dictionary<string, AssetBundle>();

	public void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
			string path = Application.persistentDataPath + "/SongData/";
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			AddPlayerSongData();
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.S))
		{
			UnSearch.SetActive(!UnSearch.activeSelf);
			AddOn.SetActive(!UnSearch.activeSelf);
		}
	}

	private void AddPlayerSongData()
	{
		string text = Application.persistentDataPath + "/SongData/";
		FileInfo[] files = new DirectoryInfo(text).GetFiles("*.unity3d");
		foreach (FileInfo fileInfo in files)
		{
			AssetBundle assetBundle = AssetBundle.LoadFromFile(text + fileInfo.Name);
			if (assetBundle != null)
			{
				string text2 = fileInfo.Name.Replace(".unity3d", string.Empty);
				GameSongData bundleSongData = assetBundle.LoadAsset<GameObject>(text2).GetComponent<ABundleSongData>().BundleSongData;
				GameData.instance.AddOnSongLevelData.Add(bundleSongData);
				UrlNametoBundleDic.Add(bundleSongData.LevelDataUrlName, assetBundle);
			}
		}
	}
}
public class csAssetLoader : MonoBehaviour
{
	public static csAssetLoader instance;

	public csMusicPrefabOptmizedData curMusicData;

	public static string URLHead = "https://olympia-cn.pico-interactive.com/";

	private Coroutine LastLevelDataGetCor;

	private string CurrentUrl = "";

	private Coroutine LastVidLevelDataGetCor;

	public csVideoPrefabOptmizedData curVidData;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			if (!Directory.Exists(Application.persistentDataPath + "/VideoData/"))
			{
				Directory.CreateDirectory(Application.persistentDataPath + "/VideoData/");
			}
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator LoadAssetFromURL(string BundleName, UnityAction<bool, AssetBundle> onLoadDone)
	{
		WWW www = new WWW(URLHead + BundleName + ".unity3d");
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			AssetBundle arg = AssetBundle.LoadFromMemory(www.bytes);
			onLoadDone(arg0: true, arg);
		}
		else
		{
			onLoadDone(arg0: false, null);
		}
	}

	public void LoadAssetFromURLByByte(string BundleName, UnityAction<bool, AssetBundle> onLoadDone)
	{
		StartCoroutine(LoadAssetFromURLByByteCor(BundleName, onLoadDone));
	}

	public IEnumerator LoadAssetFromURLByByteCor(string BundlePath, UnityAction<bool, AssetBundle> onLoadDone)
	{
		WWW www = new WWW(URLHead + BundlePath + ".unity3d");
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			AssetBundle arg = AssetBundle.LoadFromMemory(DecryptBytesByByte(www.bytes));
			onLoadDone(arg0: true, arg);
		}
		else
		{
			UnityEngine.Debug.LogError(www.error);
			onLoadDone(arg0: false, null);
		}
	}

	public void LoadFollowVideoFromURLByByte(string VideoName, int partNum, int partIndex, UnityAction<bool, bool> onLoadDone)
	{
		StartCoroutine(LoadAndSaveFollowVideoByteToMp4(VideoName, onLoadDone, partNum, partIndex));
	}

	public bool JudgeFollowListDownloadDone(List<FollowVideoData> fl, GameSongData sd)
	{
		for (int i = 0; i < fl.Count; i++)
		{
			if (!File.Exists(Application.persistentDataPath + "/VideoData/" + fl[i].VideoName + ".bytes"))
			{
				return false;
			}
		}
		return true;
	}

	public IEnumerator LoadAndSaveFollowVideoByteToMp4(string VideoName, UnityAction<bool, bool> onLoadDone, int partNum, int partIndex)
	{
		string url = URLHead + "MP4Video/" + VideoName + ".mp4";
		string filePath2 = Application.persistentDataPath + "/VideoData/";
		filePath2 = filePath2 + VideoName + ".bytes";
		UnityWebRequest headRequest = UnityWebRequest.Head(url);
		yield return headRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(headRequest.error))
		{
			yield break;
		}
		ulong totalLength = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
		headRequest.Dispose();
		UnityWebRequest Request = UnityWebRequest.Get(url);
		Request.downloadHandler = new DownloadHandlerFile(filePath2, append: true);
		FileInfo fileInfo = new FileInfo(filePath2);
		ulong fileLength = (ulong)fileInfo.Length;
		Request.SetRequestHeader("Range", "bytes=" + fileLength + "-");
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		if (fileLength < totalLength)
		{
			Request.SendWebRequest();
			while (!Request.isDone)
			{
				csMainMenuManager.instance.downloadPanel.SetSliderValue((float)((double)(Request.downloadedBytes + fileLength) / (double)totalLength) / (float)partNum + (float)partIndex / (float)partNum);
				yield return null;
			}
		}
		if (string.IsNullOrEmpty(Request.error))
		{
			onLoadDone(arg0: true, arg1: true);
		}
		else
		{
			onLoadDone(arg0: true, arg1: false);
		}
		Request.Dispose();
	}

	public void LoadEnvAssetFromURLByByte(string BundleName, UnityAction<bool, AssetBundle> onLoadDone)
	{
		StartCoroutine(LoadEnvAssetFromURL(BundleName, onLoadDone));
	}

	private IEnumerator LoadEnvAssetFromURL(string BundleName, UnityAction<bool, AssetBundle> onLoadDone)
	{
		string url = URLHead + "EnvAssets/" + BundleName + "_EnByte.unity3d";
		string filePath = Application.persistentDataPath + "EnvAssets/" + BundleName + "_EnByte.unity3d";
		UnityWebRequest headRequest = UnityWebRequest.Head(url);
		yield return headRequest.SendWebRequest();
		ulong totalLength = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
		headRequest.Dispose();
		UnityWebRequest Request = UnityWebRequestAssetBundle.GetAssetBundle(url);
		Request.downloadHandler = new DownloadHandlerFile(filePath, append: true);
		FileInfo fileInfo = new FileInfo(filePath);
		ulong fileLength = (ulong)fileInfo.Length;
		Request.SetRequestHeader("Range", "bytes=" + fileLength + "-");
		if (fileLength < totalLength)
		{
			Request.SendWebRequest();
			while (!Request.isDone)
			{
				_ = (double)(Request.downloadedBytes + fileLength) / (double)totalLength;
				yield return null;
			}
		}
		if (string.IsNullOrEmpty(Request.error))
		{
			AssetBundle arg = AssetBundle.LoadFromMemory(DecryptBytesByByte(File.ReadAllBytes(filePath)));
			onLoadDone(arg0: true, arg);
		}
		Request.Dispose();
	}

	public void LoadVideoFromURLByByte(string VideoName, UnityAction<bool, bool> onLoadDone)
	{
		StartCoroutine(LoadAndSaveVideoByteToMp4(VideoName, onLoadDone));
	}

	public IEnumerator LoadAndSaveVideoByteToMp4(string VideoName, UnityAction<bool, bool> onLoadDone)
	{
		string url = URLHead + "MP4Video/" + VideoName + ".mp4";
		string filePath2 = Application.persistentDataPath + "/VideoData/";
		filePath2 = filePath2 + VideoName + ".bytes";
		UnityWebRequest headRequest = UnityWebRequest.Head(url);
		yield return headRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(headRequest.error))
		{
			yield break;
		}
		ulong totalLength = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
		headRequest.Dispose();
		UnityWebRequest Request = UnityWebRequest.Get(url);
		Request.downloadHandler = new DownloadHandlerFile(filePath2, append: true);
		FileInfo fileInfo = new FileInfo(filePath2);
		ulong fileLength = (ulong)fileInfo.Length;
		Request.SetRequestHeader("Range", "bytes=" + fileLength + "-");
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		csEyeFadeManager.Instance.SetFillAmount(0f);
		if (fileLength < totalLength)
		{
			Request.SendWebRequest();
			while (!Request.isDone)
			{
				csMainMenuManager.instance.downloadPanel.SetSliderValue((float)((double)(Request.downloadedBytes + fileLength) / (double)totalLength));
				csEyeFadeManager.Instance.SetFillAmount((float)((double)(Request.downloadedBytes + fileLength) / (double)totalLength));
				yield return null;
			}
		}
		if (string.IsNullOrEmpty(Request.error))
		{
			onLoadDone(arg0: true, arg1: true);
		}
		else
		{
			onLoadDone(arg0: true, arg1: false);
		}
		Request.Dispose();
	}

	public void DownloadLevelDataList(string LevelName, Action<csMusicPrefabOptmizedData> CallBack)
	{
		bool BundleIsDone = false;
		AssetBundle Bundle = null;
		LoadAssetFromURLByByte("LevelPrefabInData/" + LevelName + "_byte", delegate(bool b, AssetBundle a)
		{
			BundleIsDone = b;
			Bundle = a;
			UnityEngine.Debug.LogError("ISDOne " + BundleIsDone);
			csMusicPrefabOptmizedData component = Bundle.LoadAsset<GameObject>(LevelName).GetComponent<csMusicPrefabOptmizedData>();
			CallBack(component);
		});
	}

	public void DownloadLanguage(string languageName, Action<TextAsset, string> callBack)
	{
		bool BundleIsDone = false;
		AssetBundle Bundle = null;
		LoadAssetFromURLByByte("LanguageAsset/" + languageName + "_addon_byte", delegate(bool b, AssetBundle a)
		{
			BundleIsDone = b;
			Bundle = a;
			UnityEngine.Debug.LogError("ISDOne " + BundleIsDone);
			TextAsset textAsset = Bundle.LoadAsset<TextAsset>(languageName + "_addon");
			UnityEngine.Debug.LogError("VideoName --> " + textAsset.name);
			callBack(textAsset, languageName);
		});
	}

	public static void WriteBytes(string Path, string TargetPath)
	{
		byte[] bytes = File.ReadAllBytes(Path);
		File.WriteAllBytes(TargetPath, bytes);
	}

	public static byte[] EncryptBytesByPath(string Path)
	{
		return EncryptUtil.Encrypt(File.ReadAllBytes(Path), EncryptUtil.SECRET_KEY);
	}

	public static void EncryptBytesToPath(string Path, string TargetPath)
	{
		byte[] bytes = EncryptBytesByPath(Path);
		File.WriteAllBytes(TargetPath, bytes);
	}

	public static byte[] DecryptBytesByByte(byte[] bytes)
	{
		return EncryptUtil.Decrypt(bytes, EncryptUtil.SECRET_KEY);
	}

	public void GetOptmizedDataByUrl(string shorturl, bool isBundleLevel, UnityAction<csMusicPrefabOptmizedData> OnLevelDataLoadDone)
	{
		if (isBundleLevel)
		{
			StartCoroutine(ResourcesAsyncAssetBundle(shorturl, AddPlayerSong.Instance.UrlNametoBundleDic[shorturl], OnLevelDataLoadDone));
			return;
		}
		if (LastLevelDataGetCor != null)
		{
			StopCoroutine(LastLevelDataGetCor);
		}
		CurrentUrl = shorturl;
		LastLevelDataGetCor = StartCoroutine(ResourcesAsync(shorturl, OnLevelDataLoadDone));
	}

	public void GetOptmizedVideoDataByUrl(string shorturl, UnityAction<csVideoPrefabOptmizedData> OnLevelDataLoadDone)
	{
		if (LastVidLevelDataGetCor != null)
		{
			StopCoroutine(LastVidLevelDataGetCor);
		}
		CurrentUrl = shorturl;
		LastVidLevelDataGetCor = StartCoroutine(ResourcesAsync(shorturl, OnLevelDataLoadDone));
	}

	private IEnumerator ResourcesAsyncAssetBundle(string shorturl, AssetBundle ab, UnityAction<csMusicPrefabOptmizedData> OnLevelDataLoadDone)
	{
		Resources.UnloadUnusedAssets();
		AssetBundleRequest resourcesRequest = ab.LoadAssetAsync<GameObject>(shorturl);
		yield return resourcesRequest;
		if (resourcesRequest.asset != null)
		{
			curMusicData = ((GameObject)resourcesRequest.asset).GetComponent<csMusicPrefabOptmizedData>();
			OnLevelDataLoadDone(curMusicData);
		}
		else
		{
			OnLevelDataLoadDone(null);
		}
	}

	private IEnumerator ResourcesAsync(string shorturl, UnityAction<csMusicPrefabOptmizedData> OnLevelDataLoadDone)
	{
		Resources.UnloadUnusedAssets();
		ResourceRequest resourcesRequest = Resources.LoadAsync("LevelPrefabInData/" + shorturl);
		while (!resourcesRequest.isDone)
		{
			yield return new WaitForEndOfFrame();
		}
		yield return resourcesRequest;
		if (shorturl == CurrentUrl)
		{
			if (resourcesRequest.asset != null)
			{
				curMusicData = ((GameObject)resourcesRequest.asset).GetComponent<csMusicPrefabOptmizedData>();
				OnLevelDataLoadDone(curMusicData);
			}
			else
			{
				OnLevelDataLoadDone(null);
			}
		}
	}

	private IEnumerator ResourcesAsync(string shorturl, UnityAction<csVideoPrefabOptmizedData> OnLevelDataLoadDone)
	{
		Resources.UnloadUnusedAssets();
		ResourceRequest resourcesRequest = Resources.LoadAsync("VideoLevelPrefabInData/" + shorturl);
		while (!resourcesRequest.isDone)
		{
			yield return new WaitForEndOfFrame();
		}
		yield return resourcesRequest;
		if (shorturl == CurrentUrl)
		{
			if (resourcesRequest.asset != null)
			{
				curVidData = ((GameObject)resourcesRequest.asset).GetComponent<csVideoPrefabOptmizedData>();
				OnLevelDataLoadDone(curVidData);
			}
			else
			{
				OnLevelDataLoadDone(null);
			}
		}
	}

	private IEnumerator StartGetOptmizedDataByUrl(string shorturl, UnityAction<csMusicPrefabOptmizedData> OnLevelDataLoadDone)
	{
		bool BundleIsDone = false;
		AssetBundle Bundle = null;
		while (!BundleIsDone)
		{
			yield return LoadAssetFromURL(shorturl, delegate(bool b, AssetBundle a)
			{
				BundleIsDone = b;
				Bundle = a;
			});
			yield return new WaitForSeconds(1f);
		}
		StartCoroutine(BundleLoadOptmizedDataAsync(Bundle, shorturl, OnLevelDataLoadDone));
	}

	private IEnumerator BundleLoadOptmizedDataAsync(AssetBundle Bundle, string shorturl, UnityAction<csMusicPrefabOptmizedData> OnLevelDataLoadDone)
	{
		AssetBundleRequest abRQ = Bundle.LoadAssetAsync<GameObject>(shorturl);
		yield return abRQ;
		if (abRQ.asset != null)
		{
			csMusicPrefabOptmizedData component = ((GameObject)abRQ.asset).GetComponent<csMusicPrefabOptmizedData>();
			OnLevelDataLoadDone(component);
		}
	}

	public IEnumerator CheckVideoValid(string VideoName, UnityAction<bool> onCheckDone)
	{
		string uri = URLHead + "MP4Video/" + VideoName + ".mp4";
		string filePath2 = Application.persistentDataPath + "/VideoData/";
		filePath2 = filePath2 + VideoName + ".bytes";
		UnityWebRequest headRequest = UnityWebRequest.Head(uri);
		yield return headRequest.SendWebRequest();
		if (string.IsNullOrEmpty(headRequest.error))
		{
			ulong num = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
			headRequest.Dispose();
			ulong length = (ulong)new FileInfo(filePath2).Length;
			bool arg = ((length < num || length > num) ? true : false);
			onCheckDone(arg);
		}
	}

	public void followPrepareVideo(List<string> videolist, UnityAction<bool> OnFollowListDone)
	{
		StartCoroutine(downloadURLList(videolist, OnFollowListDone));
	}

	private IEnumerator downloadURLList(List<string> list, UnityAction<bool> OnFollowListDone)
	{
		GameManagerNew.instance.isFollowDownLoading = true;
		for (int i = 0; i < list.Count; i++)
		{
			string filePath = Application.persistentDataPath + "/VideoData/" + list[i] + ".bytes";
			bool VideoDataError = false;
			if (File.Exists(filePath))
			{
				yield return StartCoroutine(CheckVideoValid(list[i], delegate(bool x)
				{
					VideoDataError = x;
				}));
			}
			if (!(!File.Exists(filePath) || VideoDataError))
			{
				continue;
			}
			bool isMp4Done = false;
			bool isGetMsg = false;
			LoadFollowVideoFromURLByByte(list[i], list.Count, i, delegate(bool isgetmsg, bool isdone)
			{
				isGetMsg = isgetmsg;
				isMp4Done = isdone;
			});
			while (!isGetMsg)
			{
				yield return new WaitForSecondsRealtime(0.1f);
			}
			if (isMp4Done)
			{
				if (!Directory.Exists(Application.persistentDataPath + "/VideoData/"))
				{
					Directory.CreateDirectory(Application.persistentDataPath + "/VideoData/");
				}
			}
			else
			{
				OnFollowListDone?.Invoke(arg0: false);
			}
		}
		yield return new WaitForSeconds(2f);
		OnFollowListDone?.Invoke(arg0: true);
		csMainMenuManager.instance.downloadPanel.SetSliderValue(1f);
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			Resources.UnloadUnusedAssets();
			GC.Collect();
		});
	}
}
public enum BundleType
{
	AllGameLevelData,
	LevelData,
	VideoData,
	SkyBoxData
}
public class EncryptUtil
{
	public static string SECRET_KEY = "qwertasd";

	public static byte[] Encrypt(byte[] bytes, string secretKey)
	{
		using DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider();
		dESCryptoServiceProvider.Key = Encoding.ASCII.GetBytes(secretKey);
		dESCryptoServiceProvider.IV = Encoding.ASCII.GetBytes(secretKey);
		MemoryStream memoryStream = new MemoryStream();
		using (CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
		{
			cryptoStream.Write(bytes, 0, bytes.Length);
			cryptoStream.FlushFinalBlock();
			cryptoStream.Close();
		}
		byte[] result = memoryStream.ToArray();
		memoryStream.Close();
		return result;
	}

	public static byte[] Decrypt(byte[] bytes, string secretKey)
	{
		using DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider();
		dESCryptoServiceProvider.Key = Encoding.ASCII.GetBytes(secretKey);
		dESCryptoServiceProvider.IV = Encoding.ASCII.GetBytes(secretKey);
		MemoryStream memoryStream = new MemoryStream();
		using (CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateDecryptor(), CryptoStreamMode.Write))
		{
			cryptoStream.Write(bytes, 0, bytes.Length);
			cryptoStream.FlushFinalBlock();
			cryptoStream.Close();
		}
		byte[] result = memoryStream.ToArray();
		memoryStream.Close();
		return result;
	}
}
public class PlotController : MonoBehaviour
{
	public List<Transform> plotPoints;

	private Material highlightMaterial;

	public int displayWindowSize = 300;

	private void Start()
	{
		plotPoints = new List<Transform>();
		float x = base.transform.Find("Point/BasePoint").localScale.x;
		for (int i = 0; i < displayWindowSize; i++)
		{
			Transform transform = (UnityEngine.Object.Instantiate(Resources.Load("Point"), base.transform) as GameObject).transform;
			float x2 = (float)(displayWindowSize / 2 * -1) * x + (float)i * x;
			transform.localPosition = new Vector3(x2, transform.localPosition.y, transform.localPosition.z);
			plotPoints.Add(transform);
		}
	}

	public void updatePlot(List<SpectralFluxInfo> pointInfo, int curIndex = -1)
	{
		if (plotPoints.Count < displayWindowSize - 1)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		if (curIndex > 0)
		{
			num2 = Mathf.Max(0, curIndex - displayWindowSize / 2);
			num3 = Mathf.Min(curIndex + displayWindowSize / 2, pointInfo.Count - 1);
		}
		else
		{
			num2 = Mathf.Max(0, pointInfo.Count - displayWindowSize - 1);
			num3 = Mathf.Min(num2 + displayWindowSize, pointInfo.Count);
		}
		for (int i = num2; i < num3; i++)
		{
			int index = num;
			num++;
			Transform point = plotPoints[index].Find("FluxPoint");
			Transform point2 = plotPoints[index].Find("ThreshPoint");
			Transform point3 = plotPoints[index].Find("PeakPoint");
			if (pointInfo[i].isPeak)
			{
				setPointHeight(point3, pointInfo[i].spectralFlux);
				setPointHeight(point, 0f);
			}
			else
			{
				setPointHeight(point, 0f);
				setPointHeight(point3, 0f);
			}
			setPointHeight(point2, 0f);
		}
	}

	public void setPointHeight(Transform point, float height)
	{
		float num = 0.06f;
		point.localPosition = new Vector3(point.localPosition.x, height * num, point.localPosition.z);
	}
}
public class SongController : MonoBehaviour
{
	private float[] realTimeSpectrum;

	private SpectralFluxAnalyzer realTimeSpectralFluxAnalyzer;

	private PlotController realTimePlotController;

	private int numChannels;

	private int numTotalSamples;

	private int sampleRate;

	private float clipLength;

	private float[] multiChannelSamples;

	private SpectralFluxAnalyzer preProcessedSpectralFluxAnalyzer;

	private PlotController preProcessedPlotController;

	private AudioSource audioSource;

	public bool realTimeSamples = true;

	public bool preProcessSamples;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		if (realTimeSamples)
		{
			realTimeSpectrum = new float[1024];
			realTimeSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
			realTimePlotController = GameObject.Find("RealtimePlot").GetComponent<PlotController>();
			sampleRate = AudioSettings.outputSampleRate;
		}
		if (preProcessSamples)
		{
			preProcessedSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
			preProcessedPlotController = GameObject.Find("PreprocessedPlot").GetComponent<PlotController>();
			multiChannelSamples = new float[audioSource.clip.samples * audioSource.clip.channels];
			numChannels = audioSource.clip.channels;
			numTotalSamples = audioSource.clip.samples;
			clipLength = audioSource.clip.length;
			sampleRate = audioSource.clip.frequency;
			audioSource.clip.GetData(multiChannelSamples, 0);
			UnityEngine.Debug.Log("GetData done");
			Thread thread = new Thread(getFullSpectrumThreaded);
			UnityEngine.Debug.Log("Starting Background Thread");
			thread.Start();
		}
	}

	private void Update()
	{
		if (realTimeSamples)
		{
			audioSource.GetSpectrumData(realTimeSpectrum, 0, FFTWindow.BlackmanHarris);
			realTimeSpectralFluxAnalyzer.analyzeSpectrum(realTimeSpectrum, audioSource.time);
			realTimePlotController.updatePlot(realTimeSpectralFluxAnalyzer.spectralFluxSamples);
		}
		if (preProcessSamples)
		{
			int curIndex = getIndexFromTime(audioSource.time) / 1024;
			preProcessedPlotController.updatePlot(preProcessedSpectralFluxAnalyzer.spectralFluxSamples, curIndex);
		}
	}

	public int getIndexFromTime(float curTime)
	{
		float num = clipLength / (float)numTotalSamples;
		return Mathf.FloorToInt(curTime / num);
	}

	public float getTimeFromIndex(int index)
	{
		return 1f / (float)sampleRate * (float)index;
	}

	public void getFullSpectrumThreaded()
	{
		try
		{
			float[] array = new float[numTotalSamples];
			int num = 0;
			float num2 = 0f;
			for (int i = 0; i < multiChannelSamples.Length; i++)
			{
				num2 += multiChannelSamples[i];
				if ((i + 1) % numChannels == 0)
				{
					array[num] = num2 / (float)numChannels;
					num++;
					num2 = 0f;
				}
			}
			UnityEngine.Debug.Log("Combine Channels done");
			UnityEngine.Debug.Log(array.Length);
			int num3 = 1024;
			int num4 = array.Length / num3;
			FFT fFT = new FFT();
			fFT.Initialize((uint)num3);
			UnityEngine.Debug.Log($"Processing {num4} time domain samples for FFT");
			double[] array2 = new double[num3];
			for (int j = 0; j < num4; j++)
			{
				Array.Copy(array, j * num3, array2, 0, num3);
				double[] array3 = DSP.Window.Coefficients(DSP.Window.Type.Hanning, (uint)num3);
				double[] timeSeries = DSP.Math.Multiply(array2, array3);
				double b = DSP.Window.ScaleFactor.Signal(array3);
				double[] a = DSP.ConvertComplex.ToMagnitude(fFT.Execute(timeSeries));
				a = DSP.Math.Multiply(a, b);
				float time = getTimeFromIndex(j) * (float)num3;
				preProcessedSpectralFluxAnalyzer.analyzeSpectrum(Array.ConvertAll(a, (double x) => (float)x), time);
			}
			UnityEngine.Debug.Log("Spectrum Analysis done");
			UnityEngine.Debug.Log("Background Thread Completed");
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log(ex.ToString());
		}
	}
}
public class SpectralFluxInfo
{
	public float time;

	public float spectralFlux;

	public float threshold;

	public float prunedSpectralFlux;

	public bool isPeak;
}
public class SpectralFluxAnalyzer
{
	private int numSamples = 1024;

	private float thresholdMultiplier = 1.5f;

	private int thresholdWindowSize = 50;

	public List<SpectralFluxInfo> spectralFluxSamples;

	private float[] curSpectrum;

	private float[] prevSpectrum;

	private int indexToProcess;

	public SpectralFluxAnalyzer()
	{
		spectralFluxSamples = new List<SpectralFluxInfo>();
		indexToProcess = thresholdWindowSize / 2;
		curSpectrum = new float[numSamples];
		prevSpectrum = new float[numSamples];
	}

	public void setCurSpectrum(float[] spectrum)
	{
		curSpectrum.CopyTo(prevSpectrum, 0);
		spectrum.CopyTo(curSpectrum, 0);
	}

	public void analyzeSpectrum(float[] spectrum, float time)
	{
		setCurSpectrum(spectrum);
		SpectralFluxInfo spectralFluxInfo = new SpectralFluxInfo();
		spectralFluxInfo.time = time;
		spectralFluxInfo.spectralFlux = calculateRectifiedSpectralFlux();
		spectralFluxSamples.Add(spectralFluxInfo);
		if (spectralFluxSamples.Count >= thresholdWindowSize)
		{
			spectralFluxSamples[indexToProcess].threshold = getFluxThreshold(indexToProcess);
			spectralFluxSamples[indexToProcess].prunedSpectralFlux = getPrunedSpectralFlux(indexToProcess);
			int num = indexToProcess - 1;
			if (isPeak(num))
			{
				spectralFluxSamples[num].isPeak = true;
			}
			indexToProcess++;
		}
		else
		{
			UnityEngine.Debug.Log($"Not ready yet.  At spectral flux sample size of {spectralFluxSamples.Count} growing to {thresholdWindowSize}");
		}
	}

	private float calculateRectifiedSpectralFlux()
	{
		float num = 0f;
		for (int i = 0; i < numSamples; i++)
		{
			num += Mathf.Max(0f, curSpectrum[i] - prevSpectrum[i]);
		}
		return num;
	}

	private float getFluxThreshold(int spectralFluxIndex)
	{
		int num = Mathf.Max(0, spectralFluxIndex - thresholdWindowSize / 2);
		int num2 = Mathf.Min(spectralFluxSamples.Count - 1, spectralFluxIndex + thresholdWindowSize / 2);
		float num3 = 0f;
		for (int i = num; i < num2; i++)
		{
			num3 += spectralFluxSamples[i].spectralFlux;
		}
		return num3 / (float)(num2 - num) * thresholdMultiplier;
	}

	private float getPrunedSpectralFlux(int spectralFluxIndex)
	{
		return Mathf.Max(0f, spectralFluxSamples[spectralFluxIndex].spectralFlux - spectralFluxSamples[spectralFluxIndex].threshold);
	}

	private bool isPeak(int spectralFluxIndex)
	{
		if (spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex + 1].prunedSpectralFlux && spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex - 1].prunedSpectralFlux)
		{
			return true;
		}
		return false;
	}

	private void logSample(int indexToLog)
	{
		int num = Mathf.Max(0, indexToLog - thresholdWindowSize / 2);
		int num2 = Mathf.Min(spectralFluxSamples.Count - 1, indexToLog + thresholdWindowSize / 2);
		UnityEngine.Debug.Log($"Peak detected at song time {spectralFluxSamples[indexToLog].time} with pruned flux of {spectralFluxSamples[indexToLog].prunedSpectralFlux} ({spectralFluxSamples[indexToLog].spectralFlux} over thresh of {spectralFluxSamples[indexToLog].threshold}).\nThresh calculated on time window of {spectralFluxSamples[num].time}-{spectralFluxSamples[num2].time} ({spectralFluxSamples[num2].time - spectralFluxSamples[num].time} seconds) containing {num2 - num} samples.");
	}
}
public class csControllerPostionTracker : MonoBehaviour
{
	public Transform PositonTracker;

	public Transform HeadPos;

	private float Dis = 0.8f;

	private float heightLimit = 0.15f;

	private bool shouldTrack = true;

	private void Update()
	{
		float num = PositonTracker.position.x - HeadPos.position.x;
		float num2 = PositonTracker.position.y - HeadPos.position.y;
		float num3 = PositonTracker.position.z - HeadPos.position.z;
		if (Mathf.Pow(num, 2f) + Mathf.Pow(num2, 2f) + Mathf.Pow(num3, 2f) > Dis && num2 > heightLimit)
		{
			shouldTrack = false;
		}
		else
		{
			shouldTrack = true;
		}
		if (shouldTrack)
		{
			base.gameObject.transform.position = PositonTracker.position;
			base.gameObject.transform.rotation = PositonTracker.rotation;
			return;
		}
		float num4 = Mathf.Sqrt(Dis / (Mathf.Pow(num, 2f) + Mathf.Pow(num2, 2f) + Mathf.Pow(num3, 2f)));
		Vector3 position = default(Vector3);
		position.x = num * num4 + HeadPos.position.x;
		position.y = num2 * num4 + HeadPos.position.y;
		position.z = num3 * num4 + HeadPos.position.z;
		base.gameObject.transform.position = position;
		base.gameObject.transform.rotation = PositonTracker.rotation;
	}
}
public class csLODSwitcher : MonoBehaviour
{
	private LODGroup LODComponent;

	public List<GameObject> LODObjs;

	private void Start()
	{
	}

	private void CloseLOD()
	{
		LODComponent = GetComponent<LODGroup>();
		if (LODComponent != null)
		{
			LODComponent.enabled = false;
		}
		foreach (GameObject lODObj in LODObjs)
		{
			lODObj.SetActive(value: false);
		}
	}
}
public class csRTCLobby : MonoBehaviour
{
	public Button buttonEnterRoom;

	public Button buttonleaveRoom;

	public Toggle toggleEarMonitorMode;

	public Text outputText;

	private string currentRoomID;

	private void Start()
	{
		buttonEnterRoom.onClick.AddListener(OnClickJoinRoom);
		toggleEarMonitorMode.onValueChanged.AddListener(delegate(bool earMonitorMode)
		{
			Log($"EarMonitorMode {earMonitorMode}");
			if (earMonitorMode)
			{
				RtcService.SetEarMonitorMode(RtcEarMonitorMode.On);
			}
			else
			{
				RtcService.SetEarMonitorMode(RtcEarMonitorMode.Off);
			}
			Log($"EarMonitorMode {earMonitorMode} Done");
		});
		outputText.text = "";
		init();
	}

	private void Update()
	{
	}

	public void init()
	{
		try
		{
			if (CoreService.IsInitialized())
			{
				initRtc();
			}
			else
			{
				CoreService.AsyncInitialize().OnComplete(delegate(Message<PlatformInitializeResult> m)
				{
					if (m.Data == PlatformInitializeResult.Success || m.Data == PlatformInitializeResult.AlreadyInitialized)
					{
						Log("初始化引擎成功");
						initRtc();
					}
					else
					{
						Log($"初始化引擎失败{m.Data}");
					}
				});
			}
		}
		catch (Exception arg)
		{
			Log($"初始化引擎失败{arg}");
			throw;
		}
		RtcService.SetOnJoinRoomResultCallback(OnJoinRoom);
		RtcService.SetOnLeaveRoomResultCallback(OnLeaveRoom);
		RtcService.SetOnUserLeaveRoomResultCallback(OnUserLeaveRoom);
		RtcService.SetOnUserJoinRoomResultCallback(OnUserJoinRoom);
		RtcService.SetOnConnectionStateChangeCallback(OnConnectionStateChange);
		RtcService.SetOnWarnCallback(OnWarn);
		RtcService.SetOnErrorCallback(OnError);
	}

	private void Log(string s)
	{
		UnityEngine.Debug.LogError("[RtcDemo]" + s);
		if (outputText != null)
		{
			outputText.text = s + "\n" + outputText.text;
		}
	}

	private void initRtc()
	{
		RtcEngineInitResult rtcEngineInitResult = RtcService.InitRtcEngine();
		if (rtcEngineInitResult != 0)
		{
			Log($"初始化Rtc引擎失败{rtcEngineInitResult}");
		}
		RtcService.EnableAudioPropertiesReport(2000);
	}

	private void OnClickJoinRoom()
	{
		RtcRoomProfileType roomProfile = RtcRoomProfileType.Communication;
		string roomId = "1";
		string userId = SystemInfo.deviceUniqueIdentifier;
		Log($"userId={userId} roomId={roomId} scenarioType={roomProfile}");
		Dictionary<RtcPrivilege, int> dictionary = new Dictionary<RtcPrivilege, int>();
		dictionary.Add(RtcPrivilege.PublishStream, 7200);
		dictionary.Add(RtcPrivilege.SubscribeStream, 7200);
		RtcService.GetToken(roomId, userId, 7200, dictionary).OnComplete(delegate(Message<string> msg)
		{
			if (msg.IsError)
			{
				Log($"获取rtc token失败 code={msg.GetError().Code} message={msg.GetError().Message}");
			}
			else
			{
				string data = msg.Data;
				Log("网络请求token:" + data);
				int num = RtcService.JoinRoom(roomId, userId, data, roomProfile, isAutoSubscribeAudio: true);
				Log($"进房结果{num} RoomId={roomId}");
			}
		});
	}

	private void OnJoinRoom(Message<RtcJoinRoomResult> msg)
	{
		if (msg.IsError)
		{
			Error error = msg.GetError();
			RtcJoinRoomResult data = msg.Data;
			string arg = "";
			if (data != null)
			{
				arg = data.RoomId;
			}
			Log($"【进房失败】code={error.Code} message={error.Message} roomId={arg}");
			return;
		}
		RtcJoinRoomResult data2 = msg.Data;
		if (data2.ErrorCode != 0)
		{
			Log($"【进房失败】code={data2.ErrorCode} RoomId={data2.RoomId} UserId={data2.UserId}");
			return;
		}
		Log("进房成功之前");
		Log($"【进房成功】过去的时间{data2.Elapsed} JoinType:{data2.JoinType} RoomId:{data2.RoomId} UserId:{data2.UserId}");
		currentRoomID = data2.RoomId;
		buttonleaveRoom.onClick.AddListener(delegate
		{
			Log("Doing leave room:" + currentRoomID);
			int num = RtcService.LeaveRoom(currentRoomID);
			buttonleaveRoom.onClick.RemoveAllListeners();
			Log($"退房结果{num} RoomId={currentRoomID}");
		});
	}

	private void OnLeaveRoom(Message<RtcLeaveRoomResult> msg)
	{
		if (msg.IsError)
		{
			Error error = msg.GetError();
			Log($"【离房结果】code={error.Code} message={error.Message}");
		}
		else
		{
			RtcLeaveRoomResult data = msg.Data;
			Log("[退房]RoomId=" + data.RoomId);
		}
	}

	private void OnUserLeaveRoom(Message<RtcUserLeaveInfo> msg)
	{
		if (msg.IsError)
		{
			msg.GetError();
			return;
		}
		RtcUserLeaveInfo data = msg.Data;
		Log($"[UserLeave]用户[{data.UserId}]离开了房间[{data.RoomId}],下线原因：{data.OfflineReason}");
	}

	private void OnUserJoinRoom(Message<RtcUserJoinInfo> msg)
	{
		if (msg.IsError)
		{
			msg.GetError();
			return;
		}
		RtcUserJoinInfo data = msg.Data;
		Log($"[UserJoin]用户'{data.UserId}'加入房间{data.RoomId},info={data.UserExtra} 花费时间{data.Elapsed}");
	}

	private void OnConnectionStateChange(Message<RtcConnectionState> message)
	{
		Log($"[ConnectionStateChange] {message.Data}");
	}

	private void OnError(Message<int> message)
	{
		Log($"[RtcError] {message.Data}");
	}

	private void OnWarn(Message<int> message)
	{
		Log($"[RtcWarn] {message.Data}");
	}
}
public class csSNTool1 : MonoBehaviour
{
	public bool islocalTest;

	private string checkSnUrlOnline = "/checksnactive?data=";

	private string checkSnUrlLocal = "http://127.0.0.1:3002/checksnactive?data=";

	private string publicKey = "-----BEGIN PUBLIC KEY-----\r\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCaXxLl7sOhNo7ARpXqO6HbZ4TV\r\nrblRS83zNwatmkCFS15P8aJeKz3i+CT0JgOojQAUy2WGkZF4NvbZ+BOzaecuCXXz\r\nz7Rc79A4R64oa3HxwUQHZi4FsDcwMVMaScN7ZSP9DH2PTctJsVdCK5khiMpr2/BI\r\nZivIaz8uu6OwLaaDRwIDAQAB\r\n-----END PUBLIC KEY-----";

	public string Encode(string a)
	{
		return RSAHelper.Encript(a, publicKey);
	}

	public void CheckSN(UnityAction<string> act, string sn, string userid)
	{
		string a = $"{{\"sn\":\"{sn}\",\"userid\":\"{userid}\"}}";
		a = Encode(a);
		if (islocalTest)
		{
			StartCoroutine(DoWWWGET(act, checkSnUrlLocal, a));
		}
		else
		{
			StartCoroutine(DoWWWGET(act, csCloudSettings.SNUrlData.SNCheckUrl + checkSnUrlOnline, a));
		}
	}

	private IEnumerator DoWWWGET(UnityAction<string> act, string url, string data)
	{
		url += data;
		UnityEngine.Debug.Log(url);
		UnityWebRequest w = UnityWebRequest.Get(url);
		w.timeout = 5;
		yield return w.SendWebRequest();
		if (w.isHttpError || w.isNetworkError)
		{
			UnityEngine.Debug.LogError(w.error);
			act("99");
		}
		else
		{
			act(w.downloadHandler.text);
		}
	}

	private static string GetMacAddress()
	{
		string text = "";
		NetworkInterface[] allNetworkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
		foreach (NetworkInterface networkInterface in allNetworkInterfaces)
		{
			UnityEngine.Debug.Log(networkInterface.Description);
			if (networkInterface.Description == "en0")
			{
				text = networkInterface.GetPhysicalAddress().ToString();
				break;
			}
			text = networkInterface.GetPhysicalAddress().ToString();
			if (text != "")
			{
				break;
			}
		}
		return text;
	}
}
public class csTutorialEntranceManager : MonoBehaviour
{
	public static csTutorialEntranceManager instance;

	public Sprite PunchTutorialIcon;

	public Sprite StickTutorialIcon;

	public Sprite SettingReminderIcon;

	private void Awake()
	{
		instance = this;
	}

	private void Update()
	{
	}

	public void EnterPunchTutorial()
	{
		GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
	}

	public void EnterStickTutorial()
	{
		GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataStick);
	}
}
public class csUtils
{
	public static string StrMD5(bool isshort, string strToEncrypt)
	{
		byte[] bytes = new UTF8Encoding().GetBytes(strToEncrypt);
		byte[] value = new MD5CryptoServiceProvider().ComputeHash(bytes);
		int num = (isshort ? BitConverter.ToInt16(value, 0) : BitConverter.ToInt32(value, 0));
		return ((num > 0) ? "1" : "0") + Mathf.Abs(num);
	}

	public static string StrMD5_ShotID(string strToEncrypt)
	{
		byte[] bytes = new UTF8Encoding().GetBytes(strToEncrypt);
		int num = BitConverter.ToInt32(new MD5CryptoServiceProvider().ComputeHash(bytes), 0);
		return (((num > 0) ? "1" : "0") + Mathf.Abs(num)).Substring(0, 8);
	}

	public static string GetMd5StrDianXin(string ConvertString)
	{
		StringBuilder stringBuilder = new StringBuilder();
		byte[] array = MD5.Create().ComputeHash(Encoding.UTF8.GetBytes(ConvertString));
		for (int i = 0; i < array.Length; i++)
		{
			stringBuilder.Append(array[i].ToString("X2"));
		}
		return stringBuilder.ToString().ToLower();
	}

	public static long GetInt64HashCode(string strText)
	{
		long result = 0L;
		if (!string.IsNullOrEmpty(strText))
		{
			byte[] bytes = Encoding.Unicode.GetBytes(strText);
			byte[] value = new SHA256Managed().ComputeHash(bytes);
			long num = BitConverter.ToInt64(value, 0);
			long num2 = BitConverter.ToInt64(value, 8);
			long num3 = BitConverter.ToInt64(value, 24);
			result = num ^ num2 ^ num3;
		}
		return result;
	}

	public static string AESEncrypt(string content)
	{
		byte[] key = get_key();
		byte[] bytes = Encoding.UTF8.GetBytes(content);
		byte[] array = new RijndaelManaged
		{
			Key = key,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateEncryptor().TransformFinalBlock(bytes, 0, bytes.Length);
		return Convert.ToBase64String(array, 0, array.Length);
	}

	public static string AESDecrypt(string content)
	{
		byte[] key = get_key();
		byte[] array = Convert.FromBase64String(content);
		byte[] bytes = new RijndaelManaged
		{
			Key = key,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateDecryptor().TransformFinalBlock(array, 0, array.Length);
		return Encoding.UTF8.GetString(bytes);
	}

	private static byte[] get_key()
	{
		byte[] bytes = Encoding.UTF8.GetBytes("chesstarjohn20170920kindomslicer");
		return new MD5CryptoServiceProvider().ComputeHash(bytes);
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3);
	}

	public static string GetTeamID(bool isdouble, string player1name, string player2name)
	{
		string text = "";
		text = ((!isdouble) ? player1name : ((string.Compare(player1name, player2name) > 0) ? (player1name + player2name) : (player2name + player1name)));
		return StrMD5(isshort: false, text);
	}

	public static string GetTeamName(string player1name, string player2name)
	{
		if (string.Compare(player1name, player2name) <= 0)
		{
			return player2name + ";" + player1name;
		}
		return player1name + ";" + player2name;
	}

	public static string RequestHelper(string url)
	{
		HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
		HttpWebResponse httpWebResponse = null;
		try
		{
			httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
		}
		catch (WebException)
		{
		}
		string result = "";
		if (httpWebResponse != null)
		{
			StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream());
			result = streamReader.ReadToEnd();
			streamReader.Close();
			streamReader.Dispose();
		}
		return result;
	}

	public static DateTime GetTime(long TimeStamp)
	{
		return TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1)).AddTicks(TimeStamp * 10000);
	}

	public static Vector3 GetRandomPosition(Vector3 center, float insideradius, float outsideradius)
	{
		_ = Vector3.zero;
		Vector2 vector = UnityEngine.Random.onUnitSphere * UnityEngine.Random.Range(insideradius, outsideradius);
		return new Vector3(center.x + vector.x, center.y, center.z + vector.y);
	}

	public static Vector3 GetVerticalDir(Vector3 _dir)
	{
		if (_dir.z == 0f)
		{
			return new Vector3(0f, 0f, -1f);
		}
		return new Vector3((0f - _dir.z) / _dir.x, 0f, 1f).normalized;
	}
}
public class DownloadTest : MonoBehaviour
{
	public Button wwwDownloadBtn;

	public Button webDownloadBtn;

	public Text showText;

	private WWW VideoW;

	private bool isStop;

	private void Awake()
	{
		if (!Directory.Exists(Application.persistentDataPath + "/Chesstar/Test/"))
		{
			Directory.CreateDirectory(Application.persistentDataPath + "/Chesstar/Test/");
		}
	}

	private void Start()
	{
		wwwDownloadBtn.onClick.AddListener(StartWWWDownload);
		webDownloadBtn.onClick.AddListener(StartWebDownload);
	}

	public void StartWWWDownload()
	{
		StartCoroutine(LoadAndSaveVideoByteToMp4());
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			StartWWWDownload();
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			StartWebDownload();
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			TestByteToMp4();
		}
		if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			ShowDrive();
		}
	}

	public IEnumerator LoadAndSaveVideoByteToMp4()
	{
		VideoW = new WWW(csAssetLoader.URLHead + "EncryptVideo/GL_luoluo_05_2_EnByte.unity3d");
		StartCoroutine(ProgressLog());
		yield return VideoW;
		if (string.IsNullOrEmpty(VideoW.error))
		{
			byte[] bytes = VideoW.bytes;
			File.WriteAllBytes(Application.persistentDataPath + "\\Chesstar\\Test\\GL_luoluo_05_2_EnByte_www.unity3d", bytes);
		}
		else
		{
			UnityEngine.Debug.LogError("www下载错误 ---- " + VideoW.error.ToString());
			showText.text = "www下载错误 ---- " + VideoW.error.ToString();
		}
	}

	private IEnumerator ProgressLog()
	{
		yield return new WaitForSecondsRealtime(0.1f);
		while (!VideoW.isDone)
		{
			UnityEngine.Debug.LogError("www下载进度---" + VideoW.progress);
			yield return new WaitForSecondsRealtime(0.3f);
		}
		UnityEngine.Debug.LogError("www下载进度---" + VideoW.progress);
	}

	private void StartWebDownload()
	{
		StartCoroutine(LoadAWebByteToMp4_New());
	}

	private IEnumerator LoadAWebByteToMp4()
	{
		ShowText("web点击了下载-");
		string url = csAssetLoader.URLHead + "EncryptVideo/GL_luoluo_05_2_EnByte.unity3d";
		UnityWebRequest huwr = UnityWebRequest.Head(url);
		yield return huwr.SendWebRequest();
		if (huwr.isNetworkError || huwr.isHttpError)
		{
			UnityEngine.Debug.LogError("huwrError = " + huwr.error);
			yield break;
		}
		string text = huwr.GetResponseHeader("Content-Length");
		if (text == null)
		{
			text = "";
		}
		long num = long.Parse(text);
		_ = Application.persistentDataPath + "/Chesstar/Test";
		string path = Application.persistentDataPath + "/Chesstar/Test/GL_luoluo_05_2_EnByte_Web.unity3d";
		using FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write);
		long nowFileLengeh = fs.Length;
		ShowText("已下载长度" + fs.Length);
		if (nowFileLengeh < num)
		{
			ShowText("下载未完成");
			fs.Seek(nowFileLengeh, SeekOrigin.Begin);
			UnityWebRequest uwr = UnityWebRequest.Get(url);
			uwr.SetRequestHeader("Rang", "bytes=" + nowFileLengeh + "-" + num);
			uwr.SendWebRequest();
			if (uwr.isNetworkError || uwr.isHttpError)
			{
				ShowText("uwrError = " + uwr.error);
				yield break;
			}
			long index = 0L;
			while (!uwr.isDone && !isStop)
			{
				yield return null;
				byte[] data = uwr.downloadHandler.data;
				if (data != null)
				{
					long num2 = data.Length - index;
					fs.Write(data, (int)index, (int)num2);
					index += num2;
					nowFileLengeh += num2;
					ShowText("下载进度 = " + uwr.downloadProgress);
					if (uwr.isDone)
					{
						ShowText("下载完成");
					}
				}
			}
		}
		else
		{
			ShowText("文件完整，无需下载");
		}
	}

	private IEnumerator LoadAWebByteToMp4_New()
	{
		string url = csAssetLoader.URLHead + "EncryptVideo/GL_luoluo_05_2_EnByte.unity3d";
		string filePath = Application.persistentDataPath + "/Chesstar/Test/GL_luoluo_05_2_EnByte_Web.unity3d";
		UnityWebRequest headRequest = UnityWebRequest.Head(url);
		yield return headRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(headRequest.error))
		{
			ShowText("获取下载的文件大小失败");
			yield break;
		}
		ulong totalLength = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
		ShowText("获取大小" + totalLength);
		headRequest.Dispose();
		UnityWebRequest Request = UnityWebRequest.Get(url);
		Request.downloadHandler = new DownloadHandlerFile(filePath, append: true);
		FileInfo fileInfo = new FileInfo(filePath);
		ulong fileLength = (ulong)fileInfo.Length;
		ShowText("文件总共大小:" + fileLength + ",totalLength=" + totalLength);
		Request.SetRequestHeader("Range", "bytes=" + fileLength + "-");
		if (fileLength < totalLength)
		{
			Request.SendWebRequest();
			while (!Request.isDone)
			{
				ShowText("下载进度" + (double)(Request.downloadedBytes + fileLength) / (double)totalLength);
				yield return null;
			}
		}
		if (string.IsNullOrEmpty(Request.error))
		{
			ShowText("下载成功");
		}
		else
		{
			ShowText("下载失败" + Request.error);
		}
		Request.Dispose();
	}

	private void ShowText(string text)
	{
		UnityEngine.Debug.LogError(text);
		showText.text = text;
	}

	private void TestByteToMp4()
	{
		string bytePath = Application.dataPath + "\\Chesstar\\VideoData\\VideoByte\\GL_jiabao_01_01_EnByte.unity3d";
		string text = Application.dataPath + "\\Chesstar\\VideoData\\Mp4\\GL_jiabao_01_01.mp4";
		StartCoroutine(ByteMp4Coroutine(text));
		ByteToMp4_Thread(bytePath, text);
	}

	private void ByteToMp4_Thread(string bytePath, string mp4Path)
	{
		new Thread((ThreadStart)delegate
		{
			try
			{
				byte[] bytes = csAssetLoader.DecryptBytesByByte(File.ReadAllBytes(bytePath));
				File.WriteAllBytes(mp4Path, bytes);
				ShowText("文件转换成功------");
			}
			catch (Exception value)
			{
				Console.WriteLine(value);
			}
		}).Start();
	}

	private IEnumerator ByteMp4Coroutine(string targetPath)
	{
		while (!File.Exists(targetPath))
		{
			yield return null;
		}
		UnityEngine.Debug.LogError("有文件了");
	}

	private void ShowDrive()
	{
		string text = "";
		DriveInfo[] drives = DriveInfo.GetDrives();
		foreach (DriveInfo driveInfo in drives)
		{
			text = text + "Name = " + driveInfo.Name + ";   空间 = " + driveInfo.TotalFreeSpace + "\n";
			ShowText(text);
		}
	}
}
public class EncryptTools : MonoBehaviour
{
	private static byte[] Keys = new byte[8] { 18, 52, 86, 120, 144, 171, 205, 239 };

	private static string encryptKey = "ChesstarMJW";

	public static string EncryptDES(string encryptString)
	{
		try
		{
			byte[] bytes = Encoding.UTF8.GetBytes(encryptKey.Substring(0, 8));
			byte[] keys = Keys;
			byte[] bytes2 = Encoding.UTF8.GetBytes(encryptString);
			DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider();
			MemoryStream memoryStream = new MemoryStream();
			CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateEncryptor(bytes, keys), CryptoStreamMode.Write);
			cryptoStream.Write(bytes2, 0, bytes2.Length);
			cryptoStream.FlushFinalBlock();
			cryptoStream.Close();
			return Convert.ToBase64String(memoryStream.ToArray());
		}
		catch
		{
			return encryptString;
		}
	}

	public static string DecryptDES(string decryptString)
	{
		try
		{
			byte[] bytes = Encoding.UTF8.GetBytes(encryptKey.Substring(0, 8));
			byte[] keys = Keys;
			byte[] array = Convert.FromBase64String(decryptString);
			DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider();
			MemoryStream memoryStream = new MemoryStream();
			CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateDecryptor(bytes, keys), CryptoStreamMode.Write);
			cryptoStream.Write(array, 0, array.Length);
			cryptoStream.FlushFinalBlock();
			cryptoStream.Close();
			return Encoding.UTF8.GetString(memoryStream.ToArray());
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("catch:" + ex.StackTrace);
			return decryptString;
		}
	}
}
[Serializable]
public class ABundleSongData : MonoBehaviour
{
	public GameSongData BundleSongData;
}
public class xmAudioCtrl : MonoBehaviour
{
	public static xmAudioCtrl m_instance;

	public AudioObject[] audioClips;

	private void Awake()
	{
		if (m_instance == null)
		{
			m_instance = this;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.T))
		{
			PlaySoundWithVol("normalSuccess1", csGameSettings.SoundEffectVol * 0.25f, new Vector3(0f, 0f, 0f));
		}
		if (Input.GetKeyDown(KeyCode.Y))
		{
			PlaySoundWithVol("normalSuccess2", csGameSettings.SoundEffectVol * 0.25f, new Vector3(0f, 0f, 0f));
		}
		if (Input.GetKeyDown(KeyCode.U))
		{
			PlaySoundWithVol("normalSuccess3", csGameSettings.SoundEffectVol * 0.25f, new Vector3(0f, 0f, 0f));
		}
	}

	public void PlaySound(string clipName, Vector3 Point)
	{
		AudioClip clip = GetClip(clipName);
		if (clip != null && xmAudioManager.instance != null)
		{
			xmAudioManager.instance.PlayClip(clip, Point);
		}
	}

	public void PlaySoundWithVol(string clipName, float Volume, Vector3 Point)
	{
		AudioClip clip = GetClip(clipName);
		if (clip != null && xmAudioManager.instance != null)
		{
			xmAudioManager.instance.PlayClipWithVol(clip, Volume, Point);
		}
	}

	public void PlaySound(string clipName, float waitTime, Vector3 Point)
	{
		StartCoroutine(playSound(clipName, waitTime, Point));
	}

	private IEnumerator playSound(string clipName, float waitTime, Vector3 Point)
	{
		yield return new WaitForSeconds(waitTime);
		AudioClip clip = GetClip(clipName);
		if (clip != null)
		{
			xmAudioManager.instance.PlayClip(clip, Point);
		}
	}

	public void PlaySound(string clipName, bool loop, Vector3 Point)
	{
		AudioClip clip = GetClip(clipName);
		if (clip != null)
		{
			xmAudioManager.instance.PlayClip(clip, loop, Point);
		}
	}

	public void PlaySound(string clipName, float volume, bool loop, Vector3 Point)
	{
		AudioClip clip = GetClip(clipName);
		if (clip != null)
		{
			xmAudioManager.instance.PlayClip(clip, volume, loop, Point);
		}
	}

	public void StopSound(string clipName)
	{
		AudioClip clip = GetClip(clipName);
		if (clip != null)
		{
			xmAudioManager.instance.StopPlay(clip);
		}
	}

	private AudioClip GetClip(string clipName)
	{
		for (int i = 0; i < audioClips.Length; i++)
		{
			if (string.Compare(clipName, audioClips[i].m_Name) == 0)
			{
				return audioClips[i].m_Clip;
			}
		}
		return null;
	}
}
[Serializable]
public class AudioObject
{
	public string m_Name;

	public AudioClip m_Clip;
}
public class xmAudioManager : MonoBehaviour
{
	public static xmAudioManager instance;

	private int maxAudioSources = 10;

	private List<AudioSource> audioSourceList = new List<AudioSource>();

	public AudioMixerGroup master;

	[Header("初始音高 区间0.5-2")]
	public float PitchValue;

	[Header("递增音高 累加极值最高为2")]
	public float PitchGap;

	[Header("音高段数")]
	public int PitchNum = 8;

	public int PitchCombo;

	private Coroutine pitchCor;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		Init();
	}

	private void Init()
	{
		for (int i = 0; i < maxAudioSources; i++)
		{
			GameObject obj = new GameObject("audioSource" + i);
			obj.transform.parent = base.transform;
			obj.transform.position = Vector3.zero;
			AudioSource audioSource = obj.AddComponent<AudioSource>();
			if ((bool)GameManagerNew.instance)
			{
				audioSource.maxDistance = 1000f;
			}
			audioSource.minDistance = 20f;
			audioSource.outputAudioMixerGroup = master;
			audioSource.spatialBlend = 1f;
			audioSourceList.Add(audioSource);
		}
	}

	public void PlayClip(AudioClip clip, Vector3 Point)
	{
		for (int i = 0; i < audioSourceList.Count; i++)
		{
			if (!audioSourceList[i].isPlaying)
			{
				audioSourceList[i].clip = clip;
				audioSourceList[i].volume = 3f;
				audioSourceList[i].loop = false;
				audioSourceList[i].transform.position = Point;
				audioSourceList[i].Play();
				break;
			}
		}
	}

	public void PitchComboClear()
	{
		PitchCombo = 0;
	}

	private IEnumerator PitchPlay(string name, float vol, AudioSource AudioSource, AudioClip clip)
	{
		PitchCombo++;
		if (PitchCombo > PitchNum - 1)
		{
			PitchCombo = PitchNum - 1;
		}
		AudioSource.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)PitchCombo * PitchGap);
		AudioSource.PlayOneShot(clip, vol);
		yield return new WaitForSeconds(AudioSource.clip.length + 0.1f);
	}

	public void PlayClipWithVol(AudioClip clip, float Volume, Vector3 Point)
	{
		for (int i = 0; i < audioSourceList.Count; i++)
		{
			if (!audioSourceList[i].isPlaying)
			{
				audioSourceList[i].clip = clip;
				audioSourceList[i].volume = Volume;
				audioSourceList[i].loop = false;
				audioSourceList[i].transform.position = Point;
				PitchCombo++;
				if (PitchCombo > PitchNum - 1)
				{
					PitchCombo = PitchNum - 1;
				}
				audioSourceList[i].outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)PitchCombo * PitchGap);
				audioSourceList[i].PlayOneShot(clip);
				break;
			}
		}
	}

	public void PlayClip(AudioClip clip, bool loop, Vector3 Point)
	{
		for (int i = 0; i < audioSourceList.Count; i++)
		{
			if (!audioSourceList[i].isPlaying)
			{
				audioSourceList[i].volume = 3f;
				audioSourceList[i].clip = clip;
				audioSourceList[i].loop = loop;
				audioSourceList[i].transform.position = Point;
				audioSourceList[i].Play();
				break;
			}
		}
	}

	public void PlayClip(AudioClip clip, float volume, bool loop, Vector3 Point)
	{
		for (int i = 0; i < audioSourceList.Count; i++)
		{
			if (!audioSourceList[i].isPlaying)
			{
				audioSourceList[i].volume = 3f;
				audioSourceList[i].clip = clip;
				audioSourceList[i].loop = loop;
				audioSourceList[i].transform.position = Point;
				audioSourceList[i].Play();
				break;
			}
		}
	}

	public void StopPlay(AudioClip clip)
	{
		if (audioSourceList.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < audioSourceList.Count; i++)
		{
			if (audioSourceList[i].isPlaying && audioSourceList[i].clip == clip)
			{
				audioSourceList[i].Stop();
				audioSourceList[i].clip = null;
				audioSourceList[i].loop = false;
				audioSourceList[i].transform.localPosition = Vector3.zero;
				break;
			}
		}
	}
}
public class ColoredHitEffect : MonoBehaviour
{
	public float returnTime = 2f;

	public GameObject WhiteEffect;

	public GameObject BlackEffect;

	public void SetColor(csBeatItemColor bc)
	{
		if (bc == csBeatItemColor.LBlack)
		{
			WhiteEffect.SetActive(value: false);
			BlackEffect.SetActive(value: true);
		}
		else
		{
			WhiteEffect.SetActive(value: true);
			BlackEffect.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		StartCoroutine(StartReturn());
	}

	private IEnumerator StartReturn()
	{
		yield return new WaitForSeconds(returnTime);
		csObjectPool.Instance.ReturnColoredObjectIntoPool(this, delay: false);
	}
}
public class csBeatChild : MonoBehaviour
{
	public csHitObjChild ParentObj;

	public bool isCorrect = true;

	private void Awake()
	{
		ParentObj = GetComponentInParent<csHitObjChild>();
	}
}
public class csBeatWay : MonoBehaviour
{
}
public class csBoxHint : MonoBehaviour
{
	protected CanvasGroup m_CGroup;

	public TextMeshProUGUI T_Line;

	public TextMeshProUGUI T_Line_Shad;

	protected Transform thisT;

	private Vector3 LocalScaleOri;

	private float flytimer;

	public bool isAnimating;

	private void Awake()
	{
		thisT = base.transform;
		m_CGroup = base.transform.GetChild(0).GetComponent<CanvasGroup>();
		m_CGroup.alpha = 0f;
		LocalScaleOri = thisT.localScale;
	}

	public virtual void DoOnEnable()
	{
	}

	private void OnEnable()
	{
		DoOnEnable();
	}

	public virtual void SetText(string word1, string word2 = "")
	{
		T_Line.text = word1;
		T_Line.text.Replace("\\n", "\n");
		T_Line_Shad.text = word1;
		T_Line_Shad.text.Replace("\\n", "\n");
		if (!word2.Equals(""))
		{
			T_Line.text = word1 + "\n" + word2;
			T_Line.text.Replace("\\n", "\n");
			T_Line_Shad.text = word1 + "\n" + word2;
			T_Line_Shad.text.Replace("\\n", "\n");
		}
	}

	private void Update()
	{
		if (GameManagerNew.instance.CurPlayer != null)
		{
			Transform camT = GameManagerNew.instance.CurPlayer.camT;
			Vector3 forward = m_CGroup.transform.position - camT.position;
			forward.y = 0f;
			m_CGroup.transform.rotation = Quaternion.LookRotation(forward);
		}
	}

	public virtual void DoAnimate(UnityAction animdowncallback, float addtime = 0f)
	{
		StartCoroutine(DoAnimating(animdowncallback, addtime));
	}

	public void SpeedUp()
	{
		flytimer = 0.7f;
	}

	private IEnumerator DoAnimating(UnityAction animdowncallback, float addtime = 0f)
	{
		isAnimating = true;
		m_CGroup.transform.localPosition = Vector3.zero;
		m_CGroup.DOFade(1f, 0.3f);
		thisT.DOPunchScale(LocalScaleOri * 1.03f, 0.5f);
		flytimer = 2f + addtime;
		while (flytimer > 0f)
		{
			yield return null;
			flytimer -= Time.deltaTime;
			m_CGroup.transform.Translate(Vector3.up * 0.5f * Time.deltaTime);
		}
		m_CGroup.DOFade(0f, 0.3f);
		yield return new WaitForSeconds(0.3f);
		isAnimating = false;
		csObjectPool.Instance.ReturnHintObjectIntoPool(this, delay: false);
		animdowncallback?.Invoke();
	}

	public virtual void SetPlayerKillContent(bool isKill, string OtherPlayerName, int otherPlayerLv, int OtherPlayerRnk, int myRnk, bool haveBigHead = false, bool isRevenge = false)
	{
	}

	public virtual void SetScore(int ks, int khs)
	{
	}
}
public enum CareerData
{
	CompleteTimes,
	FaliedTimes,
	TotalGameTime,
	TotalScore,
	TotalCalories,
	HandMoveDistance,
	HeadMoveDistance
}
public class csCareerDataManager : MonoBehaviour
{
	public static csCareerDataManager instance;

	private static Dictionary<CareerData, object> CareerDataDic = new Dictionary<CareerData, object>();

	private static int completeTimes;

	private static int failedTimes;

	private static float totalGameTime;

	private static int totalScore;

	private static float totalCalories;

	private static float handMoveDistance;

	private static float headMoveDistance;

	public static int CompleteTimes
	{
		get
		{
			return completeTimes;
		}
		set
		{
			completeTimes = value;
			CareerDataDic[CareerData.CompleteTimes] = value;
			PlayerPrefs.SetInt("CompleteTimes", value);
		}
	}

	public static int FailedTimes
	{
		get
		{
			return failedTimes;
		}
		set
		{
			failedTimes = value;
			CareerDataDic[CareerData.FaliedTimes] = value;
			PlayerPrefs.SetInt("FailedTimes", value);
		}
	}

	private static float CompletionRate => completeTimes / (completeTimes + failedTimes);

	public static float TotalGameTime
	{
		get
		{
			return totalGameTime;
		}
		set
		{
			totalGameTime = value;
			CareerDataDic[CareerData.TotalGameTime] = value;
			PlayerPrefs.SetFloat("TotalGameTime", value);
		}
	}

	public static int TotalScore
	{
		get
		{
			return totalScore;
		}
		set
		{
			totalScore = value;
			CareerDataDic[CareerData.TotalScore] = value;
			PlayerPrefs.SetInt("TotalScore", value);
		}
	}

	public static float TotalCalories
	{
		get
		{
			return totalCalories;
		}
		set
		{
			totalCalories = value;
			CareerDataDic[CareerData.TotalCalories] = value;
			PlayerPrefs.SetFloat("TotalCalories", value);
		}
	}

	public static float HandMoveDistance
	{
		get
		{
			return handMoveDistance;
		}
		set
		{
			handMoveDistance = value;
			CareerDataDic[CareerData.HandMoveDistance] = value;
			PlayerPrefs.SetFloat("HandMoveDistance", value);
		}
	}

	public static float HeadMoveDistance
	{
		get
		{
			return HeadMoveDistance;
		}
		set
		{
			headMoveDistance = value;
			CareerDataDic[CareerData.HeadMoveDistance] = value;
			PlayerPrefs.SetFloat("HeadMoveDistance", value);
		}
	}

	private void Awake()
	{
		instance = this;
		CareerDataDic.Clear();
		CompleteTimes = PlayerPrefs.GetInt(CareerData.CompleteTimes.ToString(), 0);
		FailedTimes = PlayerPrefs.GetInt(CareerData.FaliedTimes.ToString(), 0);
		TotalGameTime = PlayerPrefs.GetFloat(CareerData.TotalGameTime.ToString(), 0f);
		TotalScore = PlayerPrefs.GetInt(CareerData.TotalScore.ToString(), 0);
		TotalCalories = PlayerPrefs.GetFloat(CareerData.TotalCalories.ToString(), 0f);
		HandMoveDistance = PlayerPrefs.GetFloat(CareerData.HandMoveDistance.ToString(), 0f);
		HeadMoveDistance = PlayerPrefs.GetFloat(CareerData.HeadMoveDistance.ToString(), 0f);
	}

	public object GetData(CareerData Data)
	{
		return CareerDataDic[Data];
	}

	public void SetData(CareerData Data, object Value)
	{
		CareerDataDic[Data] = Value;
	}
}
public class csFollowSceneGameManager : MonoBehaviour
{
	public GAMESTATE gameState = GAMESTATE.MENUSTART;

	public csMediaPlayerMan mediaPlayerMan;

	private bool cantPause;

	public bool SkipClicked;

	public static csFollowSceneGameManager instance;

	public bool isGameEnd;

	public csVideoCheckPlayer VidCheckPlayer;

	public csPlayer CurPlayer;

	public csGameSongPlayer SongPlayer;

	public csMusicCtrl musicCtrl;

	public csGameValueManager GameValueManager;

	private bool SkipFollowVideo;

	public GameSongData CurSongData;

	private bool IsGetOptData;

	public csMusicPrefabOptmizedData CurLevelOptData;

	public int currentSection;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		isGameEnd = false;
		csTutorialSceneGameManager.isTutorial = false;
		Cursor.lockState = CursorLockMode.Locked;
	}

	private IEnumerator Start()
	{
		while (!CurPlayer)
		{
			yield return null;
		}
		Transform transform = (UnityEngine.Object.Instantiate(Resources.Load("Player/SongTimer"), CurPlayer.camT) as GameObject).transform;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		SongPlayer.SongTimer = transform.GetComponentInChildren<Text>();
		SongPlayer.SongTimer.enabled = false;
		startFollowGame();
	}

	private void Update()
	{
		UserInput();
		if (csGameSettings.profile.CurrentReleaseType == ReleaseType.DevTest && csXRInput.Instance.TryGetButtonValue(ButtonType.GripButton, PressState.Pressing, IsLeft: true) && csXRInput.Instance.TryGetButtonValue(ButtonType.primaryButton, PressState.Down, IsLeft: false))
		{
			SkipFollowVideo = true;
		}
	}

	private void UserInput()
	{
		if (csGameSettings.isLoading)
		{
			return;
		}
		if (gameState == GAMESTATE.FollowTime || gameState == GAMESTATE.FollowTimePause)
		{
			if (gameState == GAMESTATE.FollowTime && !mediaPlayerMan.isPause && mediaPlayerMan.CanPause)
			{
				if (CurPlayer.GetMenuBtnDown())
				{
					PauseGameInFollowTime();
					csTalkingData.Instance.SendEvent("KC05_课程暂停", 1.0, new Dictionary<string, object> { 
					{
						"课程ID：" + csGameDataTransfer.currentClassID,
						$"第{currentSection}小节暂停次数"
					} });
				}
			}
			else if (gameState == GAMESTATE.FollowTimePause && CurPlayer.GetMenuBtnDown() && mediaPlayerMan.isPause)
			{
				ResumeGameInCaochTime();
				csTalkingData.Instance.SendEvent("KC05_课程暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					$"第{currentSection}小节继续次数"
				} });
			}
		}
		if (gameState == GAMESTATE.FollowGap)
		{
			if (CurPlayer.GetMenuBtnDown() && !cantPause)
			{
				PauseGameInFollowGap();
				csTalkingData.Instance.SendEvent("KC06_休息暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					"休息暂停次数"
				} });
			}
		}
		else if (gameState == GAMESTATE.FollowGapPause && CurPlayer.GetMenuBtnDown())
		{
			ResumeGameInFollowGap();
			csTalkingData.Instance.SendEvent("KC06_休息暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"休息继续次数"
			} });
		}
	}

	private void PauseGameInFollowTime()
	{
		csSportInfoManager.instance.pauseDataRecord();
		csSportInfoManager.instance.PauseCalculateCal();
		csPlayer.instance.switchController(isSwitchToMenu: true);
		gameState = GAMESTATE.FollowTimePause;
		PauseVideo();
		csIngameMenuManager.instance.PauseGameInFollowTime();
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	public void ResumeGameInCaochTime()
	{
		if (gameState == GAMESTATE.FollowTimePause)
		{
			csSportInfoManager.instance.ResumeCalculateCal();
			csSportInfoManager.instance.startDataRecord();
			gameState = GAMESTATE.FollowTime;
		}
		else
		{
			gameState = GAMESTATE.CoachTime;
		}
		csIngameMenuManager.instance.ResumeGame();
		csPlayMode handTypeInFollow = CurSongData.HandTypeInFollow;
		if ((uint)(handTypeInFollow - 3) > 1u)
		{
			csPlayer.instance.switchController(isSwitchToMenu: true);
		}
		else
		{
			csPlayer.instance.switchControllerWithMode(CurSongData.HandTypeInFollow);
		}
		mediaPlayerMan.resumePlay();
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	private void PauseGameInFollowGap()
	{
		gameState = GAMESTATE.FollowGapPause;
		csPlayer.instance.switchController(isSwitchToMenu: true);
		csIngameMenuManager.instance.PauseGameInFollowGap();
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	public void BackToMain()
	{
		gameState = GAMESTATE.MENUSTART;
		StopAllCoroutines();
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csGameDataTransfer.playMode = csPlayMode.Menu;
			csGameSettings.currGameScene = GameScene.Main;
			GameData.instance.StartCoroutine(backToGameScene());
		}, 2.5f);
		SongPlayer.Stop();
		SongPlayer.ClearData();
		csIngameMenuManager.instance.ClosePanel();
	}

	private IEnumerator backToGameScene()
	{
		Scene activeScene = SceneManager.GetActiveScene();
		CreateSceneParameters parameters = new CreateSceneParameters(LocalPhysicsMode.None);
		SceneManager.CreateScene("Fake", parameters);
		AsyncOperation asyncOperation = SceneManager.UnloadSceneAsync(activeScene, UnloadSceneOptions.UnloadAllEmbeddedSceneObjects);
		Resources.UnloadUnusedAssets();
		GC.Collect();
		bool UploadDone = false;
		asyncOperation.completed += delegate
		{
			UploadDone = true;
		};
		while (!UploadDone)
		{
			yield return null;
		}
		SceneManager.LoadScene("GameScene");
	}

	public void ResumeGameInFollowGap()
	{
		csSportInfoManager.instance.ResumeCalculateCal();
		csSportInfoManager.instance.startDataRecord();
		gameState = GAMESTATE.FollowGap;
		csIngameMenuManager.instance.ResumeGame();
		csPlayMode handTypeInFollow = CurSongData.HandTypeInFollow;
		if ((uint)(handTypeInFollow - 3) > 1u)
		{
			csPlayer.instance.switchController(isSwitchToMenu: true);
		}
		else
		{
			csPlayer.instance.switchControllerWithMode(CurSongData.HandTypeInFollow);
		}
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameFollowGap);
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	public void PauseVideo()
	{
		mediaPlayerMan.pausePlay();
	}

	public void closeVideo()
	{
		mediaPlayerMan.closeVideo();
	}

	private void startFollowGame()
	{
		GameSongData gameSongData = (CurSongData = GameData.instance.GetSongDataByClassID(csGameDataTransfer.currentClassID));
		csAssetLoader.instance.GetOptmizedDataByUrl(gameSongData.LevelDataUrlName, isBundleLevel: false, delegate(csMusicPrefabOptmizedData x)
		{
			IsGetOptData = true;
			CurLevelOptData = x;
		});
		csIngameMenuManager.instance.inGameFollowPause.InitClassDetail(gameSongData);
		csGameSettings.isLoading = false;
		if (csGameSettings.IsMRCPackage)
		{
			csEnvironmentManager.instance.ChangeEnvInFollow(csGameDataTransfer.mrcSelectedEnv);
		}
		else
		{
			csEnvironmentManager.instance.ChangeEnvInFollow(CurSongData.FixedWPSkyboxName);
		}
		csPlayMode handTypeInFollow = gameSongData.HandTypeInFollow;
		if ((uint)(handTypeInFollow - 3) > 1u)
		{
			csPlayer.instance.switchController(isSwitchToMenu: true);
		}
		else
		{
			csPlayer.instance.switchControllerWithMode(CurSongData.HandTypeInFollow);
		}
		if (gameSongData.Type == ClassType.SuperGorilla)
		{
			mediaPlayerMan.changeScreenT(gameSongData.WarmUpVideoOffset, gameSongData.WarmUpVideoScale, gameSongData.WarmUpCaochEuler, gameSongData.EyeOffsetX, gameSongData.IsSingleEyeLevel && (gameSongData.ClassID == "300001" || gameSongData.ClassID == "300002" || gameSongData.ClassID == "300003" || gameSongData.ClassID == "300004"));
		}
		else
		{
			mediaPlayerMan.changeScreenT(gameSongData.WarmUpVideoOffset, gameSongData.WarmUpVideoScale, gameSongData.WarmUpCaochEuler, gameSongData.EyeOffsetX, gameSongData.IsSingleEyeLevel);
		}
		csPlayer.instance.ResetRotation(isReset: true);
		StartCoroutine(StartFollowGameByID(gameSongData));
		csIngameMenuManager.instance.inGameFollowPause.InitClassDetail(gameSongData);
	}

	private IEnumerator StartFollowGameByID(GameSongData sd)
	{
		gameState = GAMESTATE.FollowTime;
		while ((bool)csPlayer.instance && !csPlayer.instance.welcomeOver)
		{
			yield return null;
		}
		csPlayer.instance.SetHeadDownHint(flag: false);
		yield return StartFollowTime(sd);
		yield return new WaitForSeconds(1f);
	}

	private IEnumerator StartFollowTime(GameSongData gameSongData)
	{
		gameState = GAMESTATE.FollowTime;
		csPlayer.instance.pauseUILaser(dontUse: true);
		csSportInfoManager.instance.startCalculateCal();
		csSportInfoManager.instance.startDataRecord(isContinue: false);
		for (int i = 0; i < gameSongData.FollowVideoDataList.Count; i++)
		{
			mediaPlayerMan.screen.SetActive(value: true);
			mediaPlayerMan.setVideoByIndexFollow(gameSongData.FollowVideoDataList[i].VideoName + csCloudSettings.GetClassVideoVersion(gameSongData.ClassID, VideoType.Follow));
			if (CurSongData.Type == ClassType.SuperGorilla)
			{
				mediaPlayerMan.changeScreenT(gameSongData.FollowVideoDataList[i].VideoOffset, gameSongData.FollowVideoDataList[i].VideoScale, gameSongData.FollowVideoDataList[i].CoachEuler, gameSongData.EyeOffsetX, gameSongData.IsSingleEyeLevel && (CurSongData.ClassID == "300001" || CurSongData.ClassID == "300002" || CurSongData.ClassID == "300003" || CurSongData.ClassID == "300004"));
			}
			else
			{
				mediaPlayerMan.changeScreenT(gameSongData.FollowVideoDataList[i].VideoOffset, gameSongData.FollowVideoDataList[i].VideoScale, gameSongData.FollowVideoDataList[i].CoachEuler, gameSongData.EyeOffsetX, gameSongData.IsSingleEyeLevel);
			}
			currentSection = i;
			csByteEventTracking.Instance.stage_Header.SetStage(StageType.follow, currentSection + 1);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_start, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				}
			});
			while (!mediaPlayerMan.mediaPlayer.Info.HasVideo() || !IsGetOptData)
			{
				yield return new WaitForSeconds(0.5f);
			}
			mediaPlayerMan.startPlay(0.0, gameSongData);
			mediaPlayerMan.SetAudioPercentByData(gameSongData.FollowVideoDataList[i].VideoVol);
			if (CurLevelOptData != null && CurLevelOptData.FollowTimeHintDataList.Count > 0)
			{
				mediaPlayerMan.subtitleManager.Play(CurLevelOptData, i);
			}
			gameState = GAMESTATE.FollowTime;
			cantPause = true;
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				if (csGameSettings.PlayerCurrentDataOn)
				{
					cantPause = false;
					StartCoroutine(WaitForPausePanel(delegate
					{
						csIngameMenuManager.instance.OpenPanel(PanelType.InGameCurrentData);
					}));
				}
			});
			csSportInfoManager.instance.ResumeCalculateCal();
			csSportInfoManager.instance.startDataRecord();
			float timer2 = 0f;
			mediaPlayerMan.getMediaLength();
			while (gameState != GAMESTATE.MENUSTART && !mediaPlayerMan.mediaPlayer.Control.IsFinished())
			{
				if (!mediaPlayerMan.isPause)
				{
					timer2 += Time.deltaTime;
				}
				yield return null;
			}
			csIngameMenuManager.instance.OpenPanel(PanelType.InGameGaming);
			csSportInfoManager.instance.pauseDataRecord();
			csSportInfoManager.instance.PauseCalculateCal();
			gameState = GAMESTATE.FollowGap;
			cantPause = true;
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				mediaPlayerMan.closeVideo();
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
				{
					cantPause = false;
				}, 1f);
			}, 1f);
			yield return new WaitForSeconds(2f);
			SkipClicked = false;
			if (gameSongData.FollowVideoDataList[i].GapTime != 0)
			{
				csIngameMenuManager.instance.OpenPanel(PanelType.InGameFollowGap);
				csIngameMenuManager.instance.followGapPanel.SetTotalCountdowNum(gameSongData.FollowVideoDataList[i].GapTime);
				csIngameMenuManager.instance.followGapPanel.InitProgress();
				timer2 = gameSongData.FollowVideoDataList[i].GapTime;
				bool startFade = false;
				bool finshFade = false;
				while (gameState != GAMESTATE.MENUSTART && timer2 > 0f && !SkipClicked)
				{
					yield return null;
					if (gameState == GAMESTATE.FollowGap)
					{
						timer2 -= Time.deltaTime;
						csIngameMenuManager.instance.followGapPanel.SetCurrentCountdownNum(timer2);
						csIngameMenuManager.instance.followGapPanel.SetProgress();
					}
					if (timer2 <= 1f && !startFade && i != gameSongData.FollowVideoDataList.Count - 1)
					{
						cantPause = true;
						csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
						{
							csIngameMenuManager.instance.ClosePanel();
							cantPause = false;
							finshFade = true;
						});
						finshFade = true;
					}
				}
				if (SkipClicked)
				{
					cantPause = true;
					csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
					{
						csIngameMenuManager.instance.ClosePanel();
						cantPause = false;
						finshFade = true;
					});
				}
				while (!finshFade)
				{
					yield return null;
				}
				yield return new WaitForSeconds(2f);
			}
			SkipClicked = false;
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{ "status", "finish" },
				{
					"accuracy",
					GameValueManager.GetCurrentStagePrecise()
				},
				{
					"real_kcal",
					GameValueManager.GetCurrentStageKCal()
				},
				{
					"goal",
					GameValueManager.GetCurrentStageScore()
				},
				{
					"strength",
					GameValueManager.GetCurrentStageStrength()
				},
				{ "combo", 0 }
			});
		}
		if (CurSongData.Type == ClassType.SuperGorilla)
		{
			if (gameState != GAMESTATE.MENUSTART)
			{
				csSportInfoManager.instance.stopCalculateCal();
				csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
				csIngameMenuManager.instance.SetAndShowResultSuperGorilla();
				gameState = GAMESTATE.FollowResult;
			}
		}
		else if (gameState != GAMESTATE.MENUSTART)
		{
			csSportInfoManager.instance.stopCalculateCal();
			csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
			csIngameMenuManager.instance.SetAndShowResultFollow();
			csCloudStorage.instance.SetClassAsClassHistory(csGameDataTransfer.currentClassID, ClassHistoryState.Finished);
			csCloudStorage.instance.AddNewBeheaviorData(BeheaviorType.ClassFinishNum, 1, csGameDataTransfer.currentClassID);
			csCloudStorage.instance.addClockInDate(null);
			gameState = GAMESTATE.FollowResult;
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"duration",
					(int)(GameManagerNew.instance.GameTimer * 1000f)
				},
				{ "status", "success" },
				{
					"goal",
					GameValueManager.GetCurrentTotalScore()
				},
				{
					"real_kcal",
					GameValueManager.GetCurrentTotalKCal()
				}
			});
		}
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	private IEnumerator WaitForPausePanel(Action ShowCurrentData)
	{
		while (gameState == GAMESTATE.FollowTimePause)
		{
			yield return new WaitForEndOfFrame();
		}
		ShowCurrentData?.Invoke();
	}

	public void SetFollowAudioVolume()
	{
		mediaPlayerMan.SetAudioVolume();
	}
}
public class csFootRingHint : MonoBehaviour
{
	public Transform FootT;

	public bool isSwiftFoot;

	public Animation FootAnim;

	private float beatGapTime;

	private bool CorrectFrontFootIsLeft;

	public bool RingIsHide;

	private float timer;

	private bool isTriggerCorrect;

	private Coroutine hideCor;

	public void setFoot(bool isLeft, float bgt)
	{
		RingIsHide = false;
		if (isLeft)
		{
			FootAnim.Play("ShowLeft");
		}
		else
		{
			FootAnim.Play("ShowRight");
		}
		CorrectFrontFootIsLeft = isLeft;
		FootT.localScale = new Vector3(isLeft ? 1 : (-1), 1f, 1f);
		beatGapTime = bgt;
		isTriggerCorrect = false;
		StartCoroutine(SelfReturn());
		if (hideCor != null)
		{
			StopCoroutine(hideCor);
		}
	}

	private IEnumerator SelfReturn()
	{
		timer = 0f;
		while (timer < beatGapTime * 4f && !RingIsHide)
		{
			timer += Time.deltaTime;
			yield return new WaitForEndOfFrame();
			if (!(timer > 0.5f) || isTriggerCorrect || !isSwiftFoot)
			{
				continue;
			}
			int footState = csPlayer.instance.SwiftContrl.GetFootState();
			if (footState >= 0)
			{
				if (footState == 0 && CorrectFrontFootIsLeft)
				{
					isTriggerCorrect = true;
					break;
				}
				if (footState == 1 && !CorrectFrontFootIsLeft)
				{
					isTriggerCorrect = true;
					break;
				}
			}
		}
		if (!isTriggerCorrect)
		{
			if (CorrectFrontFootIsLeft)
			{
				FootAnim.Play("LeftHide");
			}
			else
			{
				FootAnim.Play("RightHide");
			}
			yield return new WaitForSeconds(0.6f);
		}
		else
		{
			if (CorrectFrontFootIsLeft)
			{
				FootAnim.Play("LeftDone");
			}
			else
			{
				FootAnim.Play("RightDone");
			}
			yield return new WaitForSeconds(0.5f);
		}
		RingIsHide = true;
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public void StarHideAfterSecs(float sec)
	{
		if (hideCor != null)
		{
			StopCoroutine(hideCor);
		}
		hideCor = StartCoroutine(HideAfterSecs(sec));
	}

	private IEnumerator HideAfterSecs(float sec)
	{
		yield return new WaitForSeconds(sec);
		RingIsHide = true;
	}
}
public class csGameSongPlayer : MonoBehaviour
{
	public GameObject CurMusicPrefab;

	public csMusicPrefabOptmizedData curMusicData;

	public bool StartMove;

	private bool StartMoveState;

	[Header("大拍间隔时间（秒）无法设置")]
	public float beatGapTime;

	public Transform SongMovingT;

	public AudioSource ass;

	public AudioSource ass_VoiceOver;

	[Header("歌曲播放速度")]
	public float BGMSpeed = 1f;

	[Header("每大节有几小拍")]
	public int beatCountInCol = 4;

	[Header("拳击关卡版移动速度")]
	public float beatGapDisBoxing = 15f;

	[Header("棍棒关卡版移动速度")]
	public float beatGapDisStick = 13f;

	[Header("大拍间隔距离（每秒米数）就是关卡版移动速度，修改后需要刷新")]
	public float beatGapDis = 1f;

	private int curAudioClipState;

	private Vector3 MoveTStartPos;

	[Header("刷新点距离玩家距离（米）")]
	public float SongPrepareDist = 24f;

	public List<csBeatItemData> CurBeatItemList = new List<csBeatItemData>();

	public int curItemDataIndex;

	public int TotalCount;

	public int CurSLevelIndex;

	private bool isSwiftLevel;

	public float CurSongPlayTime;

	private float TimeAfterStop;

	public Text SongTimer;

	private float FasterScale = 3f;

	private bool isFaster;

	public Dictionary<int, int> TrackAngleDic = new Dictionary<int, int>();

	public Dictionary<int, csCreatePointManager> TrackHoleDic = new Dictionary<int, csCreatePointManager>();

	public PunchOffsetManager POM;

	public static Vector3 WallOffset = new Vector3(0f, 0.3f, 0f);

	public static float MaxAddColScale = 0.3f;

	private float tempXScaleOffest;

	private Vector3 LocalPosInData;

	private csFootRingHint curRingHint;

	public void SetLevelTypeSpeed(csPlayMode handMode)
	{
		switch (handMode)
		{
		case csPlayMode.Boxing:
			beatGapDis = beatGapDisBoxing;
			break;
		case csPlayMode.Stick:
			beatGapDis = beatGapDisStick;
			break;
		}
	}

	private void Awake()
	{
		MoveTStartPos = SongMovingT.localPosition;
	}

	private void Start()
	{
		SetAudioVolume();
	}

	public void CreatBeat(csMusicPrefabOptmizedData musicData)
	{
		CurSLevelIndex = 0;
		CurMusicPrefab = new GameObject("MusicPrefab");
		CurMusicPrefab.transform.position = new Vector3(0f, 0f, 1f);
		List<float> list = new List<float>();
		csByteEventTracking.Instance.stage_Header.SetStage(StageType.fitness, 2);
		isSwiftLevel = GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.Swift);
		curMusicData = UnityEngine.Object.Instantiate(musicData);
		for (int i = 0; i < curMusicData.SingleLevelDataList.Count; i++)
		{
			list.Add(curMusicData.SingleLevelDataList[i].SongPlayTime);
		}
		csIngameTimeLineHint.instance.InitDot(list);
		CurBeatItemList = curMusicData.SingleLevelDataList[CurSLevelIndex].BeatItemList;
		beatGapTime = 60f / (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongBeatCount;
		CurMusicPrefab.transform.SetParent(SongMovingT.parent);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		TotalCount = 0;
		for (int j = 0; j < curMusicData.SingleLevelDataList.Count; j++)
		{
			TotalCount += curMusicData.SingleLevelDataList[j].BeatItemList.Count;
		}
		ass.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].AudioClip;
		ass_VoiceOver.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].CoachVoiceOverClip;
	}

	public bool IsLastLevel()
	{
		if (CurSLevelIndex == curMusicData.SingleLevelDataList.Count - 1)
		{
			return true;
		}
		return false;
	}

	public bool LoadNextSLevel()
	{
		bool flag = false;
		CurSLevelIndex++;
		csIngamePanelSLevelOver.instance.processMan.initPoint(curMusicData.SingleLevelDataList.Count);
		csIngamePanelSLevelOver.instance.processMan.setProcess(CurSLevelIndex);
		csIngameTimeLineHint.instance.SetProgressFinish(CurSLevelIndex);
		if (CurSLevelIndex >= curMusicData.SingleLevelDataList.Count)
		{
			flag = false;
			csIngamePanelSLevelOver.instance.EndBtn.gameObject.SetActive(value: true);
			csIngamePanelSLevelOver.instance.NextBtn.gameObject.SetActive(value: false);
		}
		else
		{
			csIngamePanelSLevelOver.instance.EndBtn.gameObject.SetActive(value: false);
			csIngamePanelSLevelOver.instance.NextBtn.gameObject.SetActive(value: true);
			CurBeatItemList = curMusicData.SingleLevelDataList[CurSLevelIndex].BeatItemList;
			beatGapTime = 60f / (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongBeatCount;
			ass.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].AudioClip;
			ass_VoiceOver.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].CoachVoiceOverClip;
			flag = true;
		}
		return flag;
	}

	private IEnumerator ShowClassTips()
	{
		if (GameManagerNew.instance.CurSongData.TypeInHand == csPlayMode.Boxing && GameManagerNew.instance.CurSongData.Type == ClassType.Sport)
		{
			yield return new WaitForSeconds(2f);
			csIngamePowerBar.instance.FadeIn();
		}
		csInGameClassTips.instance.ClassName.text = curMusicData.SingleLevelDataList[CurSLevelIndex].CurLevelName;
		csInGameClassTips.instance.CoachName.text = curMusicData.SingleLevelDataList[CurSLevelIndex].CurSingerName;
		yield return new WaitForSeconds(0.7f);
		csInGameClassTips.instance.FadeIn();
		yield return new WaitForSeconds(7f);
		csInGameClassTips.instance.FadeOut();
		if (StartMove)
		{
			csIngameTimeLineHint.instance.FadeIn();
		}
	}

	public void StartPlay(bool isStart)
	{
		csPlayer.instance.SetHeadDownHint(flag: false);
		StartMove = isStart;
		StartMoveState = StartMove;
		TrackAngleDic.Clear();
		if ((bool)GameManagerNew.instance && GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csPlayer.instance.SetAvatarShow(isShow: true);
		}
		if (StartMove)
		{
			if (!csTutorialSceneGameManager.instance && !csIngameSwiftHint.isPlaying)
			{
				StartCoroutine(ShowClassTips());
			}
			StartCoroutine(SongPrepareToPlay());
			curItemDataIndex = 0;
			SongMovingT.localPosition += Vector3.forward * SongPrepareDist;
		}
		else
		{
			ass.Stop();
			ass_VoiceOver.Stop();
		}
	}

	private IEnumerator SongPrepareToPlay()
	{
		float waitTime = SongPrepareDist / beatGapDis;
		ass_VoiceOver.Play();
		while (waitTime > 0f)
		{
			if (GameManagerNew.instance.gameState == GAMESTATE.INGAME || csIngameSwiftHint.isPlaying || ((bool)csTutorialSceneGameManager.instance && csTutorialSceneGameManager.instance.gameState == GAMESTATE.INGAME))
			{
				waitTime -= Time.deltaTime;
			}
			yield return new WaitForEndOfFrame();
		}
		ass.time = 0f;
		ass.Play();
	}

	public void Pause()
	{
		csIngameTimeLineHint.instance.FadeOut();
		csIngamePowerBar.instance.FadeOut();
		ass.Pause();
		ass_VoiceOver.Pause();
		StartMoveState = StartMove;
		StartMove = false;
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: false);
		}
	}

	public void OnBeforResume()
	{
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: true);
		}
	}

	public void Resume()
	{
		if (curAudioClipState == 1)
		{
			ass.Play();
			ass_VoiceOver.Play();
		}
		if (!csTutorialSceneGameManager.instance)
		{
			csIngameTimeLineHint.instance.FadeIn();
			if (GameManagerNew.instance.CurSongData.TypeInHand == csPlayMode.Boxing && GameManagerNew.instance.CurSongData.Type == ClassType.Sport)
			{
				csIngamePowerBar.instance.FadeIn();
			}
		}
		StartMove = StartMoveState;
	}

	public void ClearData()
	{
		SongMovingT.localPosition = MoveTStartPos;
		if ((bool)curMusicData)
		{
			UnityEngine.Object.Destroy(curMusicData.gameObject);
		}
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
			UnityEngine.Object.Destroy(CurMusicPrefab);
		}
		TrackHoleDic.Clear();
	}

	public void ClearBeatsToPool(Transform BeatParent)
	{
		csEditorBeatItem[] componentsInChildren = BeatParent.GetComponentsInChildren<csEditorBeatItem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnItemReturnToPool();
		}
		csCreatePointManager[] componentsInChildren2 = BeatParent.GetComponentsInChildren<csCreatePointManager>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].CallReturnToPool();
		}
	}

	public void ClearSLevelData()
	{
		SongMovingT.localPosition = MoveTStartPos;
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
		}
	}

	public void Stop()
	{
		CurSongPlayTime = 0f;
		curAudioClipState = 0;
		ass.Stop();
		ass_VoiceOver.Stop();
		StartMoveState = StartMove;
		StartMove = false;
		curItemDataIndex = 0;
		TimeAfterStop = 0f;
	}

	private void Update()
	{
		if (!StartMove)
		{
			return;
		}
		SongMovingT.position += Vector3.forward * BGMSpeed * 4f * Time.deltaTime * -1f;
		if (ass.isPlaying)
		{
			CurSongPlayTime = ass.time + SongPrepareDist / beatGapDis;
			curAudioClipState = 1;
			csIngameTimeLineHint.instance.SetSliderValue(CurSLevelIndex, CurSongPlayTime / (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongPlayTime);
		}
		else if (((bool)GameManagerNew.instance && GameManagerNew.instance.gameState == GAMESTATE.INGAME) || csIngameSwiftHint.isPlaying || ((bool)csTutorialSceneGameManager.instance && csTutorialSceneGameManager.instance.gameState == GAMESTATE.INGAME))
		{
			CurSongPlayTime += Time.deltaTime;
			if (curAudioClipState == 1)
			{
				curAudioClipState = 2;
			}
		}
		if (curItemDataIndex < CurBeatItemList.Count)
		{
			while (CurBeatItemList[curItemDataIndex].BeatPos * beatGapTime < CurSongPlayTime)
			{
				if (CurBeatItemList[curItemDataIndex].BeatPos >= 0f && CurBeatItemList[curItemDataIndex].BeatPos * beatGapTime < CurSongPlayTime)
				{
					InitBeatItemByItemData(CurBeatItemList[curItemDataIndex]);
					curItemDataIndex++;
				}
				else if (CurBeatItemList[curItemDataIndex].BeatPos < 0f)
				{
					curItemDataIndex++;
				}
				if (curItemDataIndex >= CurBeatItemList.Count)
				{
					break;
				}
			}
		}
		if (!ass.isPlaying && !csTutorialSceneGameManager.instance && !csIngameSwiftHint.isPlaying)
		{
			if (CurSongPlayTime + TimeAfterStop - SongPrepareDist / beatGapDis < (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongPlayTime)
			{
				TimeAfterStop += Time.deltaTime;
			}
			else if (LoadNextSLevel())
			{
				GameManagerNew.instance.SLevelOver(isAllover: false);
			}
			else
			{
				GameManagerNew.instance.SLevelOver(isAllover: true);
			}
		}
		if (!ass.isPlaying && !csTutorialSceneGameManager.instance && csIngameSwiftHint.isPlaying)
		{
			if (CurSongPlayTime + TimeAfterStop - SongPrepareDist / beatGapDis < (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongPlayTime)
			{
				TimeAfterStop += Time.deltaTime;
			}
			else
			{
				csIngameSwiftHint.isPlaying = false;
				Stop();
			}
		}
		if (!ass.isPlaying && (bool)csTutorialSceneGameManager.instance)
		{
			if (CurSongPlayTime + TimeAfterStop - SongPrepareDist / beatGapDis < (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongPlayTime)
			{
				TimeAfterStop += Time.deltaTime;
			}
			else
			{
				csTutorialSceneGameManager.instance.isFinalMusicGameOver = true;
			}
		}
		if (csGameSettings.profile.CurrentReleaseType != ReleaseType.DevTest)
		{
			return;
		}
		if (Input.GetKeyDown(KeyCode.Insert) || (csXRInput.Instance.TryGetButtonValue(ButtonType.GripButton, PressState.Pressing, IsLeft: true) && csXRInput.Instance.TryGetButtonValue(ButtonType.primaryButton, PressState.Down, IsLeft: false)))
		{
			curItemDataIndex = CurBeatItemList.Count;
			ass.Stop();
			if ((bool)csTutorialSceneGameManager.instance)
			{
				csTutorialSceneGameManager.instance.SongPlayer.Stop();
				csTutorialSceneGameManager.instance.SongPlayer.ClearSLevelData();
				csTutorialSceneGameManager.instance.gameState = GAMESTATE.TutorialVideo;
				csPlayer.instance.pauseUILaser(dontUse: false);
				csPlayer.instance.switchController(isSwitchToMenu: true);
				return;
			}
			if (LoadNextSLevel())
			{
				GameManagerNew.instance.SLevelOver(isAllover: false);
			}
			else
			{
				GameManagerNew.instance.SLevelOver(isAllover: true);
			}
		}
		if (Input.GetKeyDown(KeyCode.RightArrow) || (csXRInput.Instance.TryGetButtonValue(ButtonType.GripButton, PressState.Pressing, IsLeft: true) && csXRInput.Instance.TryGetButtonValue(ButtonType.secondaryButton, PressState.Down, IsLeft: false)))
		{
			isFaster = !isFaster;
			if (isFaster)
			{
				Time.timeScale = FasterScale;
				Time.fixedDeltaTime = 0.02f / FasterScale;
				ass.pitch = FasterScale;
				ass_VoiceOver.pitch = FasterScale;
			}
			else
			{
				Time.timeScale = 1f;
				Time.fixedDeltaTime = 0.02f;
				ass.pitch = 1f;
				ass_VoiceOver.pitch = 1f;
			}
		}
	}

	private Vector3 GetPunchObjectPos(int typeIndex, bool isLeft)
	{
		Vector3 result = Vector3.zero;
		switch (typeIndex)
		{
		case 0:
			result = POM.RH_LTTypeIndex0.localPosition;
			break;
		case 1:
			result = ((!isLeft) ? POM.RH_MTTypeIndex1.localPosition : POM.LH_MTTypeIndex1.localPosition);
			break;
		case 2:
			result = POM.LH_RTTypeIndex2.localPosition;
			break;
		case 3:
			result = POM.RH_LMypeIndex3.localPosition;
			break;
		case 4:
			result = Vector3.zero;
			result = ((!isLeft) ? POM.RH_MMTypeIndex4.localPosition : POM.LH_MMTypeIndex4.localPosition);
			break;
		case 5:
			result = POM.LH_RMTypeIndex5.localPosition;
			break;
		case 6:
			result = ((!isLeft) ? POM.R_SwiftKnee.localPosition : POM.L_SwiftKnee.localPosition);
			break;
		case 7:
			result = ((!isLeft) ? POM.R_SwiftKick.localPosition : POM.L_SwiftKick.localPosition);
			break;
		case 8:
			result = ((!isLeft) ? POM.R_SwiftTrample.localPosition : POM.L_SwiftTrample.localPosition);
			break;
		}
		return result;
	}

	public void InitBeatItemByItemData(csBeatItemData d)
	{
		GameObject gameObject = null;
		csEditorBeatItem csEditorBeatItem2 = null;
		Vector3 zero = Vector3.zero;
		if (d.m_BeatItemType != csBeatItemType.SceneHoleStart && d.m_BeatItemType != csBeatItemType.SceneHoleEnd && TrackHoleDic.ContainsKey(d.BeatTrack))
		{
			TrackHoleDic[d.BeatTrack].SpawnItem();
		}
		LocalPosInData = d.LocalPos;
		switch (d.m_BeatItemType)
		{
		case csBeatItemType.Triangle:
			gameObject = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.forward * 20f, Vector3.forward);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			LocalPosInData.y = 0f;
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Wall:
			gameObject = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.forward * 20f, Vector3.forward);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + WallOffset.y;
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.StickDirection:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			LocalPosInData.x *= csGameSettings.XYScale;
			LocalPosInData.y *= csGameSettings.XYScale;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Diection, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			tempXScaleOffest = Mathf.Abs(d.LocalPos.x) - 0.56f;
			if (tempXScaleOffest > 0f)
			{
				csEditorBeatItem2.SetColScale(1f + tempXScaleOffest / 0.74f * MaxAddColScale);
			}
			else
			{
				csEditorBeatItem2.SetColScale(1f);
			}
			break;
		case csBeatItemType.StickTurning:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			LocalPosInData.x *= csGameSettings.XYScale;
			LocalPosInData.y *= csGameSettings.XYScale;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Turning, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				csEditorBeatItem2.SetHintLineLength(TrackAngleDic[d.BeatTrack], d.AngleTurn);
			}
			else
			{
				csEditorBeatItem2.SetHintLineLength(0, d.AngleTurn);
			}
			tempXScaleOffest = Mathf.Abs(d.LocalPos.x) - 0.56f;
			if (tempXScaleOffest > 0f)
			{
				csEditorBeatItem2.SetColScale(1f + tempXScaleOffest / 0.74f * MaxAddColScale);
			}
			else
			{
				csEditorBeatItem2.SetColScale(1f);
			}
			break;
		case csBeatItemType.Way:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			LocalPosInData.x *= csGameSettings.XYScale;
			LocalPosInData.y *= csGameSettings.XYScale;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Way, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.LocalWayPathList = d.WayPointList;
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			break;
		case csBeatItemType.Direction:
			zero = GetPunchObjectPos(d.TypeIndex, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Direction, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			break;
		case csBeatItemType.Turning:
			zero = GetPunchObjectPos(d.TypeIndex, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Turning, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				csEditorBeatItem2.SetHintLineLength(TrackAngleDic[d.BeatTrack], d.AngleTurn);
			}
			else
			{
				csEditorBeatItem2.SetHintLineLength(0, d.AngleTurn);
			}
			break;
		case csBeatItemType.Defence:
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Defend, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Reward:
		{
			if (csGameDataTransfer.playMode == csPlayMode.Stick)
			{
				LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
				LocalPosInData.x *= csGameSettings.XYScale;
				LocalPosInData.y *= csGameSettings.XYScale;
			}
			else
			{
				LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
				LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			}
			PoolObjectType type = PoolObjectType.Rewarad_3000;
			_ = csGameSettings.currentStage;
			gameObject = csObjectPool.Instance.GetObjectByType(type, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		case csBeatItemType.Normal:
			zero = GetPunchObjectPos(4, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Normal, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.SwiftKnee:
			zero = GetPunchObjectPos(6, d.m_BeatItemColor == csBeatItemColor.LBlack);
			switch (d.TypeIndex)
			{
			case 3:
				zero.x += -0.15f;
				break;
			case 5:
				zero.x += 0.15f;
				break;
			}
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.SwiftObject_Knee, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.SwiftKick:
			zero = GetPunchObjectPos(7, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.SwiftObject_Kick, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.SwiftTrample:
			zero = GetPunchObjectPos(8, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = 0.03f;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.SwiftObject_Trample, Vector3.forward * 20f, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.SceneHoleStart:
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				TrackAngleDic[d.BeatTrack] = d.AngleTurn;
			}
			else
			{
				TrackAngleDic.Add(d.BeatTrack, d.AngleTurn);
			}
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.ItemSpawnPoint, Vector3.forward * 20f, Vector3.forward);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
			LocalPosInData.x = csGameSettings.CenterHolePos.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y;
			gameObject.transform.localPosition = Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * (LocalPosInData + SongMovingT.localPosition + csGameSettings.PerfectHitZOffset * Vector3.forward);
			gameObject.transform.localRotation = Quaternion.LookRotation(Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * Vector3.forward);
			if (TrackHoleDic.ContainsKey(d.BeatTrack))
			{
				TrackHoleDic[d.BeatTrack] = gameObject.GetComponent<csCreatePointManager>();
			}
			else
			{
				TrackHoleDic.Add(d.BeatTrack, gameObject.GetComponent<csCreatePointManager>());
			}
			StartCoroutine(HoleOperationDelay(TrackHoleDic[d.BeatTrack], isOpen: true));
			return;
		case csBeatItemType.SceneHoleEnd:
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				TrackAngleDic[d.BeatTrack] = 0;
			}
			else
			{
				TrackAngleDic.Add(d.BeatTrack, 0);
			}
			if (TrackHoleDic.ContainsKey(d.BeatTrack))
			{
				StartCoroutine(HoleOperationDelay(TrackHoleDic[d.BeatTrack], isOpen: false));
				TrackHoleDic.Remove(d.BeatTrack);
			}
			return;
		case csBeatItemType.FootRingHint:
			gameObject = ((!isSwiftLevel) ? csObjectPool.Instance.GetObjectByType(PoolObjectType.FootRingObject, Vector3.zero, Vector3.forward) : csObjectPool.Instance.GetObjectByType(PoolObjectType.FootRingObject_Swift, Vector3.zero, Vector3.forward));
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				gameObject.transform.rotation = Quaternion.LookRotation(Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * Vector3.forward);
			}
			else
			{
				gameObject.transform.rotation = Quaternion.LookRotation(Vector3.forward);
			}
			curRingHint = gameObject.GetComponent<csFootRingHint>();
			curRingHint.setFoot(d.m_BeatItemColor == csBeatItemColor.LBlack, beatGapTime);
			return;
		}
		if (curRingHint != null && !curRingHint.RingIsHide)
		{
			curRingHint.StarHideAfterSecs(0.5f);
		}
		csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
		csEditorBeatItem2.thisT.SetParent(CurMusicPrefab.transform);
		float num = 0f;
		if (TrackAngleDic.ContainsKey(d.BeatTrack))
		{
			num = TrackAngleDic[d.BeatTrack];
		}
		if (d.m_BeatItemType == csBeatItemType.Defence)
		{
			csEditorBeatItem2.thisT.localPosition = Quaternion.Euler(0f, num, 0f) * (LocalPosInData + SongMovingT.localPosition + csGameSettings.PerfectHitZOffset * 0.5f * Vector3.forward);
		}
		else
		{
			csEditorBeatItem2.thisT.localPosition = Quaternion.Euler(0f, num, 0f) * (LocalPosInData + SongMovingT.localPosition + csGameSettings.PerfectHitZOffset * Vector3.forward);
		}
		csEditorBeatItem2.thisT.localRotation = Quaternion.Euler(0f, num, 0f) * d.LocalRot;
		csEditorBeatItem2.InitMoveDirAndSpeed(Quaternion.Euler(0f, num, 0f) * -Vector3.forward, BGMSpeed * beatGapDis, (int)num);
	}

	private IEnumerator HoleOperationDelay(csCreatePointManager hole, bool isOpen)
	{
		if (isOpen)
		{
			hole.openSpawnPoint();
		}
		float waitTime = SongPrepareDist / beatGapDis;
		while (waitTime > 0f)
		{
			if (GameManagerNew.instance.gameState == GAMESTATE.INGAME || csIngameSwiftHint.isPlaying || (csTutorialSceneGameManager.instance != null && csTutorialSceneGameManager.instance.gameState == GAMESTATE.INGAME))
			{
				waitTime -= Time.deltaTime;
			}
			yield return new WaitForEndOfFrame();
		}
		if (isOpen)
		{
			hole.openSpawnPoint();
		}
		else
		{
			hole.closeSpawnPoint();
		}
	}

	public void SetAudioVolume()
	{
		ass.volume = csGameSettings.MusicVol;
		ass_VoiceOver.volume = csGameSettings.CoachVoiceVol;
	}
}
public class csGameSongPlayerHintScene : MonoBehaviour
{
	public GameObject CurMusicPrefab;

	public csMusicPrefabOptmizedData curMusicData;

	public bool StartMove;

	[Header("大拍间隔时间（秒）无法设置")]
	public float beatGapTime;

	public Transform SongMovingT;

	public AudioSource ass;

	public AudioSource ass_VoiceOver;

	[Header("歌曲播放速度")]
	public float BGMSpeed = 1f;

	[Header("每大节有几小拍")]
	public int beatCountInCol = 4;

	[Header("拳击关卡版移动速度")]
	public float beatGapDisBoxing = 15f;

	[Header("棍棒关卡版移动速度")]
	public float beatGapDisStick = 13f;

	[Header("大拍间隔距离（每秒米数）就是关卡版移动速度，修改后需要刷新")]
	public float beatGapDis = 1f;

	private Vector3 MoveTStartPos;

	[Header("刷新点距离玩家距离（米）")]
	public float SongPrepareDist = 24f;

	public List<csBeatItemData> CurBeatItemList = new List<csBeatItemData>();

	public int curItemDataIndex;

	public int TotalCount;

	public int CurSLevelIndex;

	public float CurSongPlayTime;

	private float TimeAfterStop;

	public Dictionary<int, int> TrackAngleDic = new Dictionary<int, int>();

	public Dictionary<int, csCreatePointManager> TrackHoleDic = new Dictionary<int, csCreatePointManager>();

	public PunchOffsetManager POM;

	public static float PlayerHeight = 1.7f;

	public static Vector3 WallOffset = new Vector3(0f, 0.2f, 0f);

	private Vector3 LocalPosInData;

	private float YAngleLast;

	public void SetLevelTypeSpeed(csPlayMode handMode)
	{
		switch (handMode)
		{
		case csPlayMode.Boxing:
			beatGapDis = beatGapDisBoxing;
			break;
		case csPlayMode.Stick:
			beatGapDis = beatGapDisStick;
			break;
		}
	}

	private void Awake()
	{
		MoveTStartPos = SongMovingT.localPosition;
	}

	private void Start()
	{
		SetAudioVolume();
	}

	public void CreatBeat(csMusicPrefabOptmizedData musicData)
	{
		CurSLevelIndex = 0;
		CurMusicPrefab = new GameObject("MusicPrefab");
		CurMusicPrefab.transform.position = new Vector3(0f, 0f, 1f);
		curMusicData = UnityEngine.Object.Instantiate(musicData);
		CurBeatItemList = curMusicData.SingleLevelDataList[CurSLevelIndex].BeatItemList;
		beatGapTime = 60f / (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongBeatCount;
		CurMusicPrefab.transform.SetParent(SongMovingT.parent);
		CurMusicPrefab.transform.localPosition = Vector3.zero;
		TotalCount = 0;
		for (int i = 0; i < curMusicData.SingleLevelDataList.Count; i++)
		{
			TotalCount += curMusicData.SingleLevelDataList[i].BeatItemList.Count;
		}
		ass.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].AudioClip;
		ass_VoiceOver.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].CoachVoiceOverClip;
	}

	public bool LoadNextSLevel()
	{
		bool flag = false;
		CurSLevelIndex++;
		if (CurSLevelIndex >= curMusicData.SingleLevelDataList.Count)
		{
			return false;
		}
		CurBeatItemList = curMusicData.SingleLevelDataList[CurSLevelIndex].BeatItemList;
		beatGapTime = 60f / (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongBeatCount;
		ass.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].AudioClip;
		ass_VoiceOver.clip = curMusicData.SingleLevelDataList[CurSLevelIndex].CoachVoiceOverClip;
		return true;
	}

	public void StartPlay(bool isStart)
	{
		StartMove = isStart;
		TrackAngleDic.Clear();
		if (StartMove)
		{
			StartCoroutine(SongPrepareToPlay());
			curItemDataIndex = 0;
			SongMovingT.localPosition += Vector3.forward * SongPrepareDist;
		}
		else
		{
			ass.Stop();
			ass_VoiceOver.Stop();
		}
	}

	private IEnumerator SongPrepareToPlay()
	{
		float waitTime = SongPrepareDist / beatGapDis;
		while (waitTime > 0f)
		{
			waitTime -= Time.deltaTime;
			yield return new WaitForEndOfFrame();
		}
		ass.time = 0f;
		ass.Play();
		ass_VoiceOver.Play();
	}

	public void Pause()
	{
		ass.Pause();
		ass_VoiceOver.Pause();
		StartMove = false;
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: false);
		}
	}

	public void OnBeforResume()
	{
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: true);
		}
	}

	public void Resume()
	{
		ass.Play();
		ass_VoiceOver.Play();
		StartMove = true;
	}

	public void ClearData()
	{
		SongMovingT.localPosition = MoveTStartPos;
		if ((bool)curMusicData)
		{
			UnityEngine.Object.Destroy(curMusicData.gameObject);
		}
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
			UnityEngine.Object.Destroy(CurMusicPrefab);
		}
		TrackHoleDic.Clear();
	}

	public void ClearBeatsToPool(Transform BeatParent)
	{
		csEditorBeatItem[] componentsInChildren = BeatParent.GetComponentsInChildren<csEditorBeatItem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnItemReturnToPool();
		}
		csCreatePointManager[] componentsInChildren2 = BeatParent.GetComponentsInChildren<csCreatePointManager>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].CallReturnToPool();
		}
	}

	public void ClearSLevelData()
	{
		SongMovingT.localPosition = MoveTStartPos;
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
		}
	}

	public void Stop()
	{
		CurSongPlayTime = 0f;
		ass.Stop();
		ass_VoiceOver.Stop();
		StartMove = false;
		curItemDataIndex = 0;
		TimeAfterStop = 0f;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			CreatBeat(curMusicData);
			StartPlay(isStart: true);
		}
		if (!StartMove)
		{
			return;
		}
		SongMovingT.position += Vector3.forward * BGMSpeed * 4f * Time.deltaTime * -1f;
		if (ass.isPlaying)
		{
			CurSongPlayTime = ass.time + SongPrepareDist / beatGapDis;
		}
		else
		{
			CurSongPlayTime += Time.deltaTime;
		}
		if (curItemDataIndex < CurBeatItemList.Count)
		{
			if (CurBeatItemList[curItemDataIndex].BeatPos >= 0f && CurBeatItemList[curItemDataIndex].BeatPos * beatGapTime < CurSongPlayTime)
			{
				InitBeatItemByItemData(CurBeatItemList[curItemDataIndex]);
				curItemDataIndex++;
			}
			else if (CurBeatItemList[curItemDataIndex].BeatPos < 0f)
			{
				curItemDataIndex++;
			}
		}
		if (!ass.isPlaying)
		{
			if (CurSongPlayTime + TimeAfterStop - SongPrepareDist / beatGapDis < (float)curMusicData.SingleLevelDataList[CurSLevelIndex].SongPlayTime)
			{
				TimeAfterStop += Time.deltaTime;
			}
			else if (LoadNextSLevel())
			{
				Stop();
				ClearSLevelData();
				StartPlay(isStart: true);
			}
		}
	}

	private Vector3 GetPunchObjectPos(int typeIndex, bool isLeft)
	{
		Vector3 result = Vector3.zero;
		switch (typeIndex)
		{
		case 0:
			result = POM.RH_LTTypeIndex0.localPosition;
			break;
		case 1:
			result = ((!isLeft) ? POM.RH_MTTypeIndex1.localPosition : POM.LH_MTTypeIndex1.localPosition);
			break;
		case 2:
			result = POM.LH_RTTypeIndex2.localPosition;
			break;
		case 3:
			result = POM.RH_LMypeIndex3.localPosition;
			break;
		case 4:
			result = Vector3.zero;
			result = ((!isLeft) ? POM.RH_MMTypeIndex4.localPosition : POM.LH_MMTypeIndex4.localPosition);
			break;
		case 5:
			result = POM.LH_RMTypeIndex5.localPosition;
			break;
		}
		return result;
	}

	public void InitBeatItemByItemData(csBeatItemData d)
	{
		GameObject gameObject = null;
		csEditorBeatItem csEditorBeatItem2 = null;
		Vector3 zero = Vector3.zero;
		if (d.m_BeatItemType != csBeatItemType.SceneHoleStart && d.m_BeatItemType != csBeatItemType.SceneHoleEnd && TrackHoleDic.ContainsKey(d.BeatTrack))
		{
			TrackHoleDic[d.BeatTrack].SpawnItem();
		}
		LocalPosInData = d.LocalPos;
		switch (d.m_BeatItemType)
		{
		case csBeatItemType.Triangle:
			gameObject = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.zero, Vector3.forward);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			LocalPosInData.y = 0f;
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Wall:
			gameObject = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.zero, Vector3.forward);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + WallOffset.y;
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.StickDirection:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Diection, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			break;
		case csBeatItemType.StickTurning:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Turning, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				csEditorBeatItem2.SetHintLineLength(TrackAngleDic[d.BeatTrack], d.AngleTurn);
			}
			else
			{
				csEditorBeatItem2.SetHintLineLength(0, d.AngleTurn);
			}
			break;
		case csBeatItemType.Way:
			LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Way, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.LocalWayPathList = d.WayPointList;
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			UnityEngine.Debug.LogError("WayInit:" + d.BeatPos, gameObject.gameObject);
			break;
		case csBeatItemType.Direction:
			zero = GetPunchObjectPos(d.TypeIndex, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Direction, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			break;
		case csBeatItemType.Turning:
			zero = GetPunchObjectPos(d.TypeIndex, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Turning, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			csEditorBeatItem2.SetRotateAngle(d.AngleTurn);
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				csEditorBeatItem2.SetHintLineLength(TrackAngleDic[d.BeatTrack], d.AngleTurn);
			}
			else
			{
				csEditorBeatItem2.SetHintLineLength(0, d.AngleTurn);
			}
			break;
		case csBeatItemType.Defence:
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Defend, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Reward:
		{
			if (csGameDataTransfer.playMode == csPlayMode.Stick)
			{
				LocalPosInData.x -= (float)((d.BeatTrack - 1) * 4);
			}
			else
			{
				LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
				LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			}
			PoolObjectType type = PoolObjectType.Rewarad_3000;
			_ = csGameSettings.currentStage;
			gameObject = csObjectPool.Instance.GetObjectByType(type, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		case csBeatItemType.Normal:
			zero = GetPunchObjectPos(4, d.m_BeatItemColor == csBeatItemColor.LBlack);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + zero.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + zero.y;
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Normal, Vector3.zero, Vector3.forward);
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Obstacle:
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.HitPointRed, Vector3.zero, Vector3.forward);
			LocalPosInData.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y + WallOffset.y + 2f;
			csEditorBeatItem2 = gameObject.GetComponent<csEditorBeatItem>();
			((csEditorBeatItem_Hint)csEditorBeatItem2).InitHintText((HintTense)d.TypeIndex, d.BeatHint);
			LevelBroadCastHintCanvas.instance.InitHintText((HintTense)d.TypeIndex, d.BeatHint);
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.SceneHoleStart:
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				TrackAngleDic[d.BeatTrack] = d.AngleTurn;
			}
			else
			{
				TrackAngleDic.Add(d.BeatTrack, d.AngleTurn);
			}
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.ItemSpawnPoint, Vector3.zero, Vector3.forward);
			gameObject.transform.SetParent(CurMusicPrefab.transform);
			LocalPosInData.x = csGameSettings.CenterHolePos.x;
			LocalPosInData.y = csGameSettings.CenterHolePos.y;
			gameObject.transform.localPosition = Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * (LocalPosInData + SongMovingT.localPosition + csGameSettings.PerfectHitZOffset * Vector3.forward);
			gameObject.transform.localRotation = Quaternion.LookRotation(Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * Vector3.forward);
			if (TrackHoleDic.ContainsKey(d.BeatTrack))
			{
				TrackHoleDic[d.BeatTrack] = gameObject.GetComponent<csCreatePointManager>();
			}
			else
			{
				TrackHoleDic.Add(d.BeatTrack, gameObject.GetComponent<csCreatePointManager>());
			}
			StartCoroutine(HoleOperationDelay(TrackHoleDic[d.BeatTrack], isOpen: true));
			return;
		case csBeatItemType.SceneHoleEnd:
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				TrackAngleDic[d.BeatTrack] = 0;
			}
			else
			{
				TrackAngleDic.Add(d.BeatTrack, 0);
			}
			if (TrackHoleDic.ContainsKey(d.BeatTrack))
			{
				StartCoroutine(HoleOperationDelay(TrackHoleDic[d.BeatTrack], isOpen: false));
				TrackHoleDic.Remove(d.BeatTrack);
			}
			return;
		case csBeatItemType.FootRingHint:
			gameObject = csObjectPool.Instance.GetObjectByType(PoolObjectType.FootRingObject, Vector3.zero, Vector3.forward);
			if (TrackAngleDic.ContainsKey(d.BeatTrack))
			{
				gameObject.transform.rotation = Quaternion.LookRotation(Quaternion.Euler(0f, TrackAngleDic[d.BeatTrack], 0f) * Vector3.forward);
			}
			else
			{
				gameObject.transform.rotation = Quaternion.LookRotation(Vector3.forward);
			}
			gameObject.GetComponent<csFootRingHint>().setFoot(d.m_BeatItemColor == csBeatItemColor.LBlack, beatGapTime);
			return;
		}
		csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
		csEditorBeatItem2.thisT.SetParent(CurMusicPrefab.transform);
		float num = 0f;
		num = ((!TrackAngleDic.ContainsKey(d.BeatTrack) || d.m_BeatItemType == csBeatItemType.Obstacle) ? YAngleLast : ((float)TrackAngleDic[d.BeatTrack]));
		if (YAngleLast != num)
		{
			LevelBroadCastHintCanvas.instance.SetPlayerRigFwd(Quaternion.Euler(0f, num, 0f) * Vector3.forward);
		}
		YAngleLast = num;
		csEditorBeatItem2.thisT.localPosition = Quaternion.Euler(0f, num, 0f) * (LocalPosInData + SongMovingT.localPosition + csGameSettings.PerfectHitZOffset * Vector3.forward);
		csEditorBeatItem2.thisT.localRotation = Quaternion.Euler(0f, num, 0f) * d.LocalRot;
		csEditorBeatItem2.InitMoveDirAndSpeed(Quaternion.Euler(0f, num, 0f) * -Vector3.forward, BGMSpeed * beatGapDis, (int)num);
	}

	private IEnumerator HoleOperationDelay(csCreatePointManager hole, bool isOpen)
	{
		if (isOpen)
		{
			hole.openSpawnPoint();
		}
		float waitTime = SongPrepareDist / beatGapDis;
		while (waitTime > 0f)
		{
			waitTime -= Time.deltaTime;
			yield return new WaitForEndOfFrame();
		}
		if (isOpen)
		{
			hole.openSpawnPoint();
		}
		else
		{
			hole.closeSpawnPoint();
		}
	}

	public void SetAudioVolume()
	{
		ass.volume = csGameSettings.MusicVol;
		ass_VoiceOver.volume = csGameSettings.CoachVoiceVol;
	}
}
public class csGameValueManager : MonoBehaviour
{
	public bool Invincible;

	public int showComboNum = 25;

	public Transform comboPrefabT;

	private int comboShowTimes;

	private Transform comboFT;

	public int currentSLevelNum;

	private List<SLevelValueData> SLevelList = new List<SLevelValueData>();

	private List<float> PunchSpeed = new List<float>();

	private csMusicPrefabOptmizedData currentOptmizedData;

	public Action<int> isBoxingFire;

	private int isFireCount;

	public static List<SLevelValueData> SBoxLevelList = new List<SLevelValueData>();

	public static float SBoxLevelTime = 0f;

	public static List<SLevelValueData> SStickLevelList = new List<SLevelValueData>();

	public static float SStickLevelTime = 0f;

	private float LastAngle;

	private csComboManager currentCombo;

	private ColoredHitEffect cHitEffect;

	public static bool isFirstShowCombo = true;

	private ColoredHitEffect HitHintUI;

	private void Awake()
	{
		comboFT = comboPrefabT.parent;
	}

	public void Init(csMusicPrefabOptmizedData OptmizedData)
	{
		SLevelList.Clear();
		isFireCount = 0;
		PunchSpeed.Clear();
		csIngamePowerBar.instance.ResetSlider();
		currentOptmizedData = OptmizedData;
		for (int i = 0; i < currentOptmizedData.SingleLevelDataList.Count; i++)
		{
			SLevelList.Add(new SLevelValueData());
		}
	}

	public void SaveSuperMonkeyLevelScore(int step)
	{
		float num = 0f;
		switch (step)
		{
		case 1:
		{
			UnityEngine.Debug.LogError("SBoxLevelList Count:" + SLevelList.Count);
			for (int j = 0; j < SLevelList.Count; j++)
			{
				UnityEngine.Debug.LogError("SBoxLevelList Score:" + SLevelList[j].Score);
				if (SLevelList[j].Score > 0)
				{
					SBoxLevelList.Add(SLevelList[j]);
					num += (float)GameManagerNew.instance.SongPlayer.curMusicData.SingleLevelDataList[j].SongPlayTime;
				}
			}
			SBoxLevelTime = num;
			UnityEngine.Debug.LogError("SBoxLevelList Count:" + SBoxLevelList.Count);
			break;
		}
		case 2:
		{
			for (int i = SBoxLevelList.Count; i < SLevelList.Count; i++)
			{
				if (SLevelList[i].Score > 0)
				{
					SStickLevelList.Add(SLevelList[i]);
					num += (float)GameManagerNew.instance.SongPlayer.curMusicData.SingleLevelDataList[i].SongPlayTime;
				}
			}
			UnityEngine.Debug.LogError("SStickLevelList Count:" + SStickLevelList.Count);
			SStickLevelTime = num;
			break;
		}
		}
	}

	public void SetCurrentSLevelIndex(int i)
	{
		if (i >= currentOptmizedData.SingleLevelDataList.Count)
		{
			return;
		}
		currentSLevelNum = i;
		SLevelList[i].Score = 0;
		SLevelList[i].Combo = 0;
		SLevelList[i].Strength = 0;
		SLevelList[i].Cal = 0f;
		SLevelList[i].TotalCombo = 0;
		SLevelList[i].MaxCombo = 0;
		SLevelList[i].maxHit = 0;
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
		for (int j = 0; j < currentOptmizedData.SingleLevelDataList[i].BeatItemList.Count; j++)
		{
			if (currentOptmizedData.SingleLevelDataList[i].BeatItemList[j].LocalPos.z >= 0f && currentOptmizedData.SingleLevelDataList[i].BeatItemList[j].m_BeatItemType != csBeatItemType.Way && currentOptmizedData.SingleLevelDataList[i].BeatItemList[j].m_BeatItemType != csBeatItemType.SceneHoleStart && currentOptmizedData.SingleLevelDataList[i].BeatItemList[j].m_BeatItemType != csBeatItemType.SceneHoleEnd && currentOptmizedData.SingleLevelDataList[i].BeatItemList[j].m_BeatItemType != csBeatItemType.FootRingHint)
			{
				SLevelList[i].maxHit++;
			}
		}
		SLevelList[i].wrongHitNum = 0;
	}

	public void SetToNextSLevelIndex()
	{
		int num = currentSLevelNum;
		num++;
		if (num >= SLevelList.Count)
		{
			return;
		}
		currentSLevelNum = num;
		SLevelList[num].Score = 0;
		SLevelList[num].Combo = 0;
		SLevelList[num].Strength = 0;
		SLevelList[num].Cal = 0f;
		SLevelList[num].TotalCombo = 0;
		SLevelList[num].MaxCombo = 0;
		SLevelList[num].maxHit = 0;
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
		for (int i = 0; i < currentOptmizedData.SingleLevelDataList[num].BeatItemList.Count; i++)
		{
			if (currentOptmizedData.SingleLevelDataList[num].BeatItemList[i].LocalPos.z >= 0f && currentOptmizedData.SingleLevelDataList[num].BeatItemList[i].m_BeatItemType != csBeatItemType.Way && currentOptmizedData.SingleLevelDataList[num].BeatItemList[i].m_BeatItemType != csBeatItemType.SceneHoleStart && currentOptmizedData.SingleLevelDataList[num].BeatItemList[i].m_BeatItemType != csBeatItemType.SceneHoleEnd && currentOptmizedData.SingleLevelDataList[num].BeatItemList[i].m_BeatItemType != csBeatItemType.FootRingHint)
			{
				SLevelList[num].maxHit++;
			}
		}
		SLevelList[num].wrongHitNum = 0;
		isFireCount = 0;
	}

	private void addScore(int currentCombo)
	{
		SLevelList[currentSLevelNum].Score += 10 + currentCombo / 50;
	}

	private void addScoreByForce(Vector3 forceDir)
	{
		float sqrMagnitude = forceDir.sqrMagnitude;
		if (sqrMagnitude >= 1f && sqrMagnitude < 2.25f)
		{
			SLevelList[currentSLevelNum].Score += 2;
		}
		else if (sqrMagnitude >= 2.25f && sqrMagnitude < 4f)
		{
			SLevelList[currentSLevelNum].Score += 5;
		}
		else if (sqrMagnitude >= 4f)
		{
			SLevelList[currentSLevelNum].Score += 10;
		}
	}

	public void addWrongHit()
	{
		SLevelList[currentSLevelNum].wrongHitNum++;
	}

	private int getMaxScore(int i)
	{
		int num = 10 * i;
		int num2 = 1;
		while (num2 < i / 50)
		{
			num += num2 * 50;
		}
		return num + num2 * i % 50;
	}

	public SLevelValueData getSlevelInfo()
	{
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
		SLevelList[currentSLevelNum].Strength = csSportInfoManager.instance.GetCurrentIntensityInt();
		SLevelList[currentSLevelNum].Cal = csSportInfoManager.instance.GetFinalCalInt();
		SLevelList[currentSLevelNum].Precise = (float)SLevelList[currentSLevelNum].Hit / (float)SLevelList[currentSLevelNum].maxHit;
		if (SLevelList[currentSLevelNum].Precise < 0f)
		{
			SLevelList[currentSLevelNum].Precise = 0f;
		}
		SLevelList[currentSLevelNum].Precise *= 100f;
		SLevelList[currentSLevelNum].Score = (int)((float)SLevelList[currentSLevelNum].Score * ((float)SLevelList[currentSLevelNum].Strength / 100f));
		return SLevelList[currentSLevelNum];
	}

	public int GetCombo()
	{
		return SLevelList[currentSLevelNum].Combo;
	}

	public List<SLevelValueData> getFinalResultLevelData()
	{
		return SLevelList;
	}

	public List<float> getFinalPunchSpeedData()
	{
		return PunchSpeed;
	}

	public void setComboFatherRotation(float angle)
	{
		comboFT.localEulerAngles = Vector3.up * angle;
		if (LastAngle != angle)
		{
			LastAngle = angle;
			if ((bool)currentCombo)
			{
				currentCombo.transform.position = comboPrefabT.position;
				currentCombo.transform.rotation = Quaternion.LookRotation(comboPrefabT.forward);
				currentCombo.FadeIn();
			}
		}
	}

	public void OnHitItem(csBeatItemType itemType, Vector3 forceDir, csBeatItemColor m_BeatItemColor, Transform thisT, int currentHitSpeedLevel, Vector3 WorldMoveDir)
	{
		addScore(SLevelList[currentSLevelNum].Combo);
		if (itemType != csBeatItemType.Defence && itemType != csBeatItemType.Wall && itemType != csBeatItemType.Obstacle && itemType != csBeatItemType.Triangle)
		{
			addScoreByForce(forceDir);
		}
		SLevelList[currentSLevelNum].Hit++;
		SLevelList[currentSLevelNum].Combo++;
		SLevelList[currentSLevelNum].TotalCombo++;
		if (SLevelList[currentSLevelNum].Combo > SLevelList[currentSLevelNum].MaxCombo)
		{
			SLevelList[currentSLevelNum].MaxCombo = SLevelList[currentSLevelNum].Combo;
		}
		if (itemType == csBeatItemType.Defence || itemType == csBeatItemType.Wall || itemType == csBeatItemType.Turning)
		{
			xmAudioManager.instance.PitchComboClear();
		}
		switch (itemType)
		{
		case csBeatItemType.Direction:
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			PunchSpeed.Add(forceDir.magnitude);
			csIngamePowerBar.instance.SetSliderValue(PunchSpeed);
			break;
		case csBeatItemType.Normal:
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			PunchSpeed.Add(forceDir.magnitude);
			csIngamePowerBar.instance.SetSliderValue(PunchSpeed);
			break;
		case csBeatItemType.Turning:
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			PunchSpeed.Add(forceDir.magnitude);
			csIngamePowerBar.instance.SetSliderValue(PunchSpeed);
			break;
		case csBeatItemType.Reward:
			SLevelList[currentSLevelNum].Combo += 4;
			SLevelList[currentSLevelNum].TotalCombo += 4;
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			break;
		case csBeatItemType.Defence:
			SLevelList[currentSLevelNum].Combo++;
			SLevelList[currentSLevelNum].TotalCombo++;
			break;
		case csBeatItemType.SwiftKick:
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			break;
		case csBeatItemType.SwiftKnee:
			if (currentHitSpeedLevel > 1)
			{
				isFireCount++;
			}
			break;
		}
		if (csGameDataTransfer.playMode == csPlayMode.Boxing && SLevelList[currentSLevelNum].Combo % 20 == 0)
		{
			if (m_BeatItemColor == csBeatItemColor.LBlack)
			{
				currentCombo.ranEffect.SetColor(csBeatItemColor.LBlack);
			}
			else
			{
				currentCombo.ranEffect.SetColor(csBeatItemColor.RWhite);
			}
		}
		if (SLevelList[currentSLevelNum].Combo >= 5)
		{
			if (currentCombo == null)
			{
				currentCombo = csObjectPool.Instance.GetObjectByType(PoolObjectType.comboPrefab, comboPrefabT.position, comboPrefabT.forward).GetComponent<csComboManager>();
				currentCombo.setComboNumWithParticle(SLevelList[currentSLevelNum].Combo);
			}
			else
			{
				currentCombo.setComboNumWithParticle(SLevelList[currentSLevelNum].Combo);
			}
		}
		if (SLevelList[currentSLevelNum].Combo / showComboNum > comboShowTimes)
		{
			comboShowTimes++;
			if (csGameSettings.ComboShow)
			{
				currentCombo.setComboNumWithParticle(SLevelList[currentSLevelNum].Combo);
			}
		}
	}

	public void OnMissItem(csBeatItemType itemType)
	{
		SLevelList[currentSLevelNum].Combo = 0;
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
		comboShowTimes = 0;
		xmAudioManager.instance.PitchComboClear();
	}

	public void ClearComboShow()
	{
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
	}

	public void ResetScore()
	{
		if (SLevelList.Count > 0)
		{
			SLevelList[currentSLevelNum].Score = 0;
			SLevelList[currentSLevelNum].Combo = 0;
			SLevelList[currentSLevelNum].Strength = 0;
			SLevelList[currentSLevelNum].Cal = 0f;
			SLevelList[currentSLevelNum].TotalCombo = 0;
			SLevelList[currentSLevelNum].MaxCombo = 0;
		}
		if ((bool)currentCombo)
		{
			currentCombo.ReturnToPool();
			currentCombo = null;
		}
	}

	private PoolObjectType getEffectType(string id)
	{
		return PoolObjectType.RewardEffect_1;
	}

	public int GetCurrentTotalScore()
	{
		int num = 0;
		foreach (SLevelValueData sLevel in SLevelList)
		{
			num += sLevel.Score;
		}
		return num;
	}

	public int GetCurrentTotalKCal()
	{
		float num = 0f;
		foreach (SLevelValueData sLevel in SLevelList)
		{
			num += sLevel.Cal;
		}
		return (int)(num / 1000f);
	}

	public int GetCurrentStagePrecise()
	{
		if (SLevelList.Count <= 0)
		{
			return 0;
		}
		return (int)SLevelList[currentSLevelNum].Precise;
	}

	public int GetCurrentStageKCal()
	{
		if (SLevelList.Count <= 0)
		{
			return 0;
		}
		return (int)(SLevelList[currentSLevelNum].Cal / 1000f);
	}

	public int GetCurrentStageScore()
	{
		if (SLevelList.Count <= 0)
		{
			return 0;
		}
		return SLevelList[currentSLevelNum].Score;
	}

	public int GetCurrentStageStrength()
	{
		if (SLevelList.Count <= 0)
		{
			return 0;
		}
		return SLevelList[currentSLevelNum].Strength;
	}

	public int GetCurrentStageMaxCombo()
	{
		if (SLevelList.Count <= 0)
		{
			return 0;
		}
		return SLevelList[currentSLevelNum].MaxCombo;
	}
}
public class SLevelValueData
{
	public int Score;

	public float Precise;

	public float Cal;

	public int Strength;

	public int Combo;

	public int Hit;

	public int maxHit;

	public int MaxCombo;

	public int TotalCombo;

	public int wrongHitNum;
}
public class csHeadChecker : MonoBehaviour
{
	public void OnTriggerEnter(Collider other)
	{
		csWallJudgeChecker component = other.GetComponent<csWallJudgeChecker>();
		if ((bool)component)
		{
			if (!component.ParentWall.headPass && !component.ParentWall.isJudged)
			{
				component.ParentWall.OnItemMiss();
			}
			return;
		}
		csWallHole component2 = other.GetComponent<csWallHole>();
		if ((bool)component2 && component2.ParentWall.needHeadPass)
		{
			component2.ParentWall.OnItemHit(0);
		}
	}
}
public class csMissChecker : MonoBehaviour
{
	public static csMissChecker instance;

	public Transform LeftHand;

	public Transform RightHand;

	public Transform LeftMissTrans;

	public Transform RightMissTrans;

	private bool inited;

	private void Awake()
	{
		instance = this;
	}

	private void Update()
	{
		if (!inited)
		{
			if (LeftHand == null)
			{
				return;
			}
			inited = true;
		}
		if (inited)
		{
			base.transform.position = new Vector3(0f, 0f, Math.Min(LeftHand.position.z, RightHand.position.z) - 1f);
		}
	}

	public void OnTriggerEnter(Collider other)
	{
		csEditorBeatItem component = other.GetComponent<csEditorBeatItem>();
		if ((bool)component)
		{
			component.OnItemMiss();
			return;
		}
		csBeatChild component2 = other.GetComponent<csBeatChild>();
		if ((bool)component2)
		{
			component2.ParentObj.ParentItem.OnItemMiss();
			return;
		}
		csWallJudgeChecker component3 = other.GetComponent<csWallJudgeChecker>();
		if ((bool)component3)
		{
			component3.ParentWall.ReturnToPool();
		}
	}
}
public class csObjectPool : MonoBehaviour
{
	public static csObjectPool Instance;

	public List<Multi_csGameObject> m_GameObjectPrefabs = new List<Multi_csGameObject>();

	private Dictionary<PoolObjectType, Queue<GameObject>> m_GameObjcetsByType = new Dictionary<PoolObjectType, Queue<GameObject>>();

	private Dictionary<PoolObjectType, List<GameObject>> m_GameObjcetListByType = new Dictionary<PoolObjectType, List<GameObject>>();

	private Dictionary<GameObject, Multi_csGameObject> m_GameObjectByGO = new Dictionary<GameObject, Multi_csGameObject>();

	public List<Multi_csUIHintObject> m_UIHintObjectPrefabs = new List<Multi_csUIHintObject>();

	private Dictionary<PoolUIHintType, Queue<csBoxHint>> m_HintByType = new Dictionary<PoolUIHintType, Queue<csBoxHint>>();

	private Dictionary<GameObject, Multi_csUIHintObject> m_HintObjectByGO = new Dictionary<GameObject, Multi_csUIHintObject>();

	public List<Multi_csGameObject> m_GameObjectColoredEffect = new List<Multi_csGameObject>();

	private Dictionary<PoolObjectType, Queue<ColoredHitEffect>> m_ColorEffectByType = new Dictionary<PoolObjectType, Queue<ColoredHitEffect>>();

	private Dictionary<GameObject, Multi_csGameObject> m_ColorEffectByGO = new Dictionary<GameObject, Multi_csGameObject>();

	private void Awake()
	{
		Instance = this;
		for (int i = 0; i < m_GameObjectPrefabs.Count; i++)
		{
			Queue<GameObject> queue = new Queue<GameObject>();
			List<GameObject> list = new List<GameObject>();
			for (int j = 0; j < m_GameObjectPrefabs[i].m_MaxSize; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_GameObjectPrefabs[i].m_Object);
				gameObject.transform.SetParent(base.transform);
				list.Add(gameObject);
				queue.Enqueue(gameObject);
				m_GameObjectByGO[gameObject] = m_GameObjectPrefabs[i];
				gameObject.SetActive(value: false);
			}
			m_GameObjcetListByType[m_GameObjectPrefabs[i].m_Type] = list;
			m_GameObjcetsByType[m_GameObjectPrefabs[i].m_Type] = queue;
		}
		for (int k = 0; k < m_UIHintObjectPrefabs.Count; k++)
		{
			Queue<csBoxHint> queue2 = new Queue<csBoxHint>();
			for (int l = 0; l < m_UIHintObjectPrefabs[k].m_MaxSize; l++)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(m_UIHintObjectPrefabs[k].m_Object);
				gameObject2.transform.SetParent(base.transform);
				queue2.Enqueue(gameObject2.GetComponent<csBoxHint>());
				m_HintObjectByGO[gameObject2] = m_UIHintObjectPrefabs[k];
				gameObject2.SetActive(value: false);
			}
			m_HintByType[m_UIHintObjectPrefabs[k].m_Type] = queue2;
		}
		for (int m = 0; m < m_GameObjectColoredEffect.Count; m++)
		{
			Queue<ColoredHitEffect> queue3 = new Queue<ColoredHitEffect>();
			for (int n = 0; n < m_GameObjectColoredEffect[m].m_MaxSize; n++)
			{
				GameObject gameObject3 = UnityEngine.Object.Instantiate(m_GameObjectColoredEffect[m].m_Object);
				gameObject3.transform.SetParent(base.transform);
				queue3.Enqueue(gameObject3.GetComponent<ColoredHitEffect>());
				m_ColorEffectByGO[gameObject3] = m_GameObjectColoredEffect[m];
				gameObject3.SetActive(value: false);
			}
			m_ColorEffectByType[m_GameObjectColoredEffect[m].m_Type] = queue3;
		}
	}

	public GameObject GetObjectByType(PoolObjectType type, Vector3 postion, Vector3 fwd)
	{
		if (m_GameObjcetsByType[type].Count == 0)
		{
			return null;
		}
		GameObject obj = m_GameObjcetsByType[type].Dequeue();
		obj.transform.position = postion;
		obj.transform.rotation = Quaternion.LookRotation(fwd);
		obj.SetActive(value: true);
		return obj;
	}

	public GameObject[] GetObjectsByType(PoolObjectType type)
	{
		if (m_GameObjcetListByType[type].Count == 0)
		{
			return null;
		}
		return m_GameObjcetListByType[type].ToArray();
	}

	public void ReturnGameObjectIntoPool(GameObject go, bool delay)
	{
		if (delay)
		{
			go.SetActive(value: false);
			if (m_GameObjectByGO.ContainsKey(go))
			{
				StartCoroutine(DelayToReset_GO(go));
			}
			else
			{
				UnityEngine.Object.Destroy(go);
			}
		}
		else if (m_GameObjectByGO.ContainsKey(go))
		{
			if (!m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Contains(go))
			{
				m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Enqueue(go);
			}
			if ((bool)go)
			{
				go.transform.SetParent(base.transform);
				go.SetActive(value: false);
			}
		}
		else
		{
			UnityEngine.Object.Destroy(go);
		}
	}

	private IEnumerator DelayToReset_GO(GameObject go)
	{
		yield return new WaitForSeconds(5f);
		if ((bool)go)
		{
			go.transform.SetParent(base.transform);
			go.SetActive(value: false);
			if (!m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Contains(go))
			{
				m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Enqueue(go);
			}
		}
	}

	public csBoxHint GetHintByType(PoolUIHintType type, Vector3 postion)
	{
		if (m_HintByType[type].Count == 0)
		{
			return null;
		}
		csBoxHint csBoxHint2 = m_HintByType[type].Dequeue();
		if (csBoxHint2 != null)
		{
			GameObject obj = csBoxHint2.gameObject;
			obj.transform.position = postion;
			obj.SetActive(value: true);
		}
		return csBoxHint2;
	}

	public void ReturnHintObjectIntoPool(csBoxHint go, bool delay)
	{
		if (!delay)
		{
			go.gameObject.SetActive(value: false);
			if (m_HintObjectByGO.ContainsKey(go.gameObject))
			{
				StartCoroutine(DelayToReset_HG(go));
			}
		}
		else if (m_HintObjectByGO.ContainsKey(go.gameObject))
		{
			m_HintByType[m_HintObjectByGO[go.gameObject].m_Type].Enqueue(go);
			go.gameObject.SetActive(value: false);
		}
	}

	private IEnumerator DelayToReset_HG(csBoxHint go)
	{
		yield return new WaitForSeconds(5f);
		if ((bool)go)
		{
			go.gameObject.SetActive(value: false);
			m_HintByType[m_HintObjectByGO[go.gameObject].m_Type].Enqueue(go);
		}
	}

	public ColoredHitEffect GetColoredEffectType(PoolObjectType type, Vector3 postion)
	{
		if (m_ColorEffectByType[type].Count == 0)
		{
			return null;
		}
		ColoredHitEffect coloredHitEffect = m_ColorEffectByType[type].Dequeue();
		if (coloredHitEffect != null)
		{
			GameObject obj = coloredHitEffect.gameObject;
			obj.transform.position = postion;
			obj.SetActive(value: true);
		}
		return coloredHitEffect;
	}

	public void ReturnColoredObjectIntoPool(ColoredHitEffect go, bool delay)
	{
		if (!delay)
		{
			go.gameObject.SetActive(value: false);
			if (m_ColorEffectByGO.ContainsKey(go.gameObject))
			{
				StartCoroutine(DelayToReset_HG(go));
			}
		}
		else if (m_ColorEffectByGO.ContainsKey(go.gameObject))
		{
			m_ColorEffectByType[m_ColorEffectByGO[go.gameObject].m_Type].Enqueue(go);
			go.gameObject.SetActive(value: false);
		}
	}

	private IEnumerator DelayToReset_HG(ColoredHitEffect go)
	{
		yield return new WaitForSeconds(5f);
		if ((bool)go)
		{
			go.gameObject.SetActive(value: false);
			m_ColorEffectByType[m_ColorEffectByGO[go.gameObject].m_Type].Enqueue(go);
		}
	}
}
[Serializable]
public class Multi_csGameObject
{
	public PoolObjectType m_Type;

	public GameObject m_Object;

	public int m_MaxSize;
}
[Serializable]
public class Multi_csUIHintObject
{
	public PoolUIHintType m_Type;

	public GameObject m_Object;

	public int m_MaxSize;
}
public class csRanEffect : MonoBehaviour
{
	public float returnTime = 2f;

	public GameObject REffect;

	public GameObject LEffect;

	public void SetColor(csBeatItemColor bc)
	{
		if (bc == csBeatItemColor.LBlack)
		{
			LEffect.SetActive(value: false);
			LEffect.SetActive(value: true);
		}
		else
		{
			REffect.SetActive(value: false);
			REffect.SetActive(value: true);
		}
	}
}
public class csSportInfoManager : MonoBehaviour
{
	public static csSportInfoManager instance;

	public bool isStartCal;

	public static float IntensityModifier = 0.3f;

	public static float IntensityDrecress = 0.2f;

	private csControllerforPicoXR LHandCtrl;

	private csControllerforPicoXR RHandCtrl;

	private csControllerforPicoXR HeadCtrl;

	private float WeightToCal = 75f;

	public float Intensity;

	private float IntencityPercent;

	public float Distance;

	private float spt;

	private float tempLAcc;

	private float tempRAcc;

	private float tempHAcc;

	private float tempLSpeed;

	private float tempRSpeed;

	private float tempHSpeed;

	private float IntensityLimit = 0.2f;

	private float IntensityStartLoseTime = 5f;

	private float IntensityStartLoseTimer;

	private float thisTimeCal;

	private float deltaCal;

	private float AvgPower;

	private float CalIncrease;

	private int AvgAccuracy;

	public bool isStartDataRecord;

	private float recordTimer;

	public List<float> calIncreaseList = new List<float>();

	public List<float> avgPowerList = new List<float>();

	public List<int> avgAccuracyList = new List<int>();

	private int recordCounter;

	public int thisTimeHit;

	public int thisTimeMissHit;

	public float consumeCal => thisTimeCal;

	private void Awake()
	{
		instance = this;
	}

	public void SetUpPlayerRig(csControllerforPicoXR LCtrl, csControllerforPicoXR RCtrl, csControllerforPicoXR HCtrl)
	{
		LHandCtrl = LCtrl;
		RHandCtrl = RCtrl;
		HeadCtrl = HCtrl;
	}

	public void startCalculateCal()
	{
		isStartCal = true;
		thisTimeCal = 0f;
		IntencityPercent = 0f;
		spt = 0f;
		Distance = 0f;
		WeightToCal = csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight;
		if (WeightToCal > 150f)
		{
			WeightToCal = 150f;
		}
		if (WeightToCal < 30f)
		{
			WeightToCal = 30f;
		}
	}

	public void PauseCalculateCal()
	{
		isStartCal = false;
	}

	public void ResumeCalculateCal()
	{
		isStartCal = true;
	}

	public void stopCalculateCal()
	{
		isStartCal = false;
		csCloudSettings.InitDateTime(delegate
		{
			csCloudStorage.instance.addPlayerCareerData(new daySportInfoData(csCloudSettings.GetNowTime().ToShortDateString(), thisTimeCal, GetSportTime()), null);
			csCloudStorage.instance.addPlayerCareerDataWithMode(new SportInfoDataWithMode((csGameSettings.currGameScene != 0) ? csFollowSceneGameManager.instance.CurSongData.TypeInHand : GameManagerNew.instance.CurSongData.TypeInHand, thisTimeCal, GetSportTime()), csCloudSettings.GetNowTime().ToShortDateString(), null);
			csCloudStorage.instance.AddNewBeheaviorData(BeheaviorType.CalCost, (int)thisTimeCal);
		});
	}

	public int GetCurrentIntensityInt()
	{
		IntencityPercent = Mathf.Min(IntencityPercent, 100f);
		return (int)IntencityPercent;
	}

	public float GetCurrentIntensity()
	{
		IntencityPercent = Mathf.Min(IntencityPercent, 100f);
		return IntencityPercent;
	}

	public float GetCurrentDist()
	{
		return Distance;
	}

	public int GetSportTime()
	{
		return (int)spt;
	}

	public int GetFinalCalInt()
	{
		return (int)thisTimeCal;
	}

	public float GetFinalCal()
	{
		return thisTimeCal;
	}

	private void Update()
	{
		if (isStartCal)
		{
			spt += Time.deltaTime;
			if (csGameSettings.currentChannel == ChannelType.PicoXR)
			{
				tempLAcc = LHandCtrl.GetAcc().magnitude;
				tempRAcc = RHandCtrl.GetAcc().magnitude;
				tempHAcc = HeadCtrl.GetAcc().magnitude;
				tempLSpeed = LHandCtrl.GetVel().magnitude;
				tempRSpeed = RHandCtrl.GetVel().magnitude;
				tempHSpeed = HeadCtrl.GetVel().magnitude;
			}
			Intensity = (tempLSpeed + tempRSpeed) * 0.5f + tempHSpeed * 8f;
			if (Intensity < IntensityLimit)
			{
				IntensityStartLoseTimer += Time.deltaTime;
				if (IntensityStartLoseTimer > IntensityStartLoseTime)
				{
					IntencityPercent -= Time.deltaTime * IntensityDrecress;
				}
			}
			else
			{
				IntencityPercent += Intensity * Time.deltaTime * IntensityModifier;
				IntensityStartLoseTimer = 0f;
			}
			if (IntencityPercent <= 0f)
			{
				IntencityPercent = 0f;
			}
			Distance += tempLSpeed * Time.deltaTime;
			Distance += tempRSpeed * Time.deltaTime;
			Distance += tempHSpeed * Time.deltaTime;
			if (LHandCtrl.GetVel().sqrMagnitude > 0.25f || RHandCtrl.GetVel().sqrMagnitude > 0.25f || HeadCtrl.GetVel().sqrMagnitude > 0.04f)
			{
				CalculateCalByPlayerWeight(WeightToCal);
			}
		}
		if (!isStartDataRecord)
		{
			return;
		}
		recordTimer += Time.deltaTime;
		if (!(recordTimer > 1f))
		{
			return;
		}
		recordTimer = 0f;
		AvgPower += IntencityPercent;
		recordCounter++;
		if (recordCounter >= 5)
		{
			AvgPower /= 5f;
			if (thisTimeHit + thisTimeMissHit > 0)
			{
				AvgAccuracy = thisTimeHit * 100 / (thisTimeHit + thisTimeMissHit);
			}
			else if (thisTimeHit + thisTimeMissHit == 0)
			{
				AvgAccuracy = 100;
			}
			else
			{
				AvgAccuracy = 0;
			}
			calIncreaseList.Add(CalIncrease);
			avgPowerList.Add(AvgPower);
			avgAccuracyList.Add(AvgAccuracy);
			resetRecordData(ResetAll: false);
		}
	}

	public void CalculateCal(float acc, float weight)
	{
		deltaCal = acc * weight * Time.deltaTime;
		thisTimeCal += deltaCal;
		if (isStartDataRecord)
		{
			CalIncrease += deltaCal;
		}
	}

	public void CalculateCalByPlayerWeight(float weight)
	{
		deltaCal = 5.5f * weight * 0.2783f * Time.deltaTime;
		thisTimeCal += deltaCal;
		if (isStartDataRecord)
		{
			CalIncrease += deltaCal;
		}
	}

	public void resetRecordData(bool ResetAll)
	{
		AvgPower = 0f;
		AvgAccuracy = 100;
		recordTimer = 0f;
		recordCounter = 0;
		thisTimeHit = 0;
		thisTimeMissHit = 0;
		if (ResetAll)
		{
			CalIncrease = 0f;
		}
	}

	public void startDataRecord(bool isContinue = true)
	{
		if (!isContinue)
		{
			avgPowerList.Clear();
			avgAccuracyList.Clear();
			calIncreaseList.Clear();
			resetRecordData(ResetAll: true);
			avgPowerList.Add(0f);
			avgAccuracyList.Add(100);
			calIncreaseList.Add(0f);
		}
		isStartDataRecord = true;
	}

	public void endDataRecord()
	{
		isStartDataRecord = false;
		resetRecordData(ResetAll: true);
	}

	public void pauseDataRecord(bool isEndSong = false)
	{
		isStartDataRecord = false;
		if (isEndSong)
		{
			AvgPower /= recordCounter;
			if (thisTimeHit + thisTimeMissHit != 0)
			{
				AvgAccuracy = thisTimeHit * 100 / (thisTimeHit + thisTimeMissHit);
			}
			else
			{
				AvgAccuracy = 100;
			}
			calIncreaseList.Add(CalIncrease);
			avgPowerList.Add(AvgPower);
			avgAccuracyList.Add(AvgAccuracy);
			resetRecordData(ResetAll: false);
		}
	}
}
public class csSwiftChecker : MonoBehaviour
{
	public csBeatItemColor m_WandColor;

	public csBeatItemType CheckType;

	public BoxCollider BoxCastCol;

	private bool useNewSoundEffect;

	private bool isCheckingColor;

	private int SpeedStartLevel = 1;

	private bool LineHapticOn;

	private bool isNewBeat = true;

	private float HapticStrength = 0.8f;

	private float HapticStrengthOri = 0.9f;

	public float HapticLastTime = 3f;

	private csEditorBeatItem LastHitBeat;

	private RaycastHit[] hitCol;

	private RaycastHit[] failureHitCol;

	public float CheckDist = 0.8f;

	public float failureCheckDis = 0.3f;

	private float WayObjAddScale = 2f;

	public void OnTriggerEnterByBoxCast(Collider other)
	{
		csBeatChild component = other.GetComponent<csBeatChild>();
		isCheckingColor = component != null && component.ParentObj.ParentItem.m_BeatItemColor != m_WandColor;
		if (component == null || (component != null && (component.ParentObj.ParentItem.GetIsHit() || isCheckingColor)) || component.ParentObj.ParentItem.m_BeatItemType != CheckType)
		{
			return;
		}
		int num = 0;
		if ((bool)component)
		{
			num = CheckSpeed(component.ParentObj.ParentItem.m_BeatItemType);
		}
		Vector3 forward = Vector3.forward;
		if (!component || num <= 0)
		{
			return;
		}
		_ = component.ParentObj.ParentItem.m_BeatItemType;
		csEditorBeatItem parentItem = component.ParentObj.ParentItem;
		if (true && parentItem.m_BeatItemColor != m_WandColor && parentItem.m_BeatItemType != csBeatItemType.Reward && parentItem.m_BeatItemType != csBeatItemType.Way)
		{
			_ = parentItem.m_BeatItemType;
			_ = 4;
		}
		if (1 == 0)
		{
			return;
		}
		component.ParentObj.ParentItem.currentHitSpeedLevel = num;
		parentItem.OnItemHit(forward);
		if (GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.SwiftVibration))
		{
			if (m_WandColor == csBeatItemColor.LBlack)
			{
				csPlayer.instance.SetControllerVibration(1f, 80, 0.8f, 80, 0f, 200f);
				if ((bool)csPlayer.instance)
				{
					csPlayer.instance.TriggerHandHaptic(isL: true);
				}
			}
			else
			{
				csPlayer.instance.SetControllerVibration(1f, 80, 0.8f, 80, 0f, 200f);
				if ((bool)csPlayer.instance)
				{
					csPlayer.instance.TriggerHandHaptic(isL: false);
				}
			}
		}
		string clipName = "normalSuccess";
		useNewSoundEffect = false;
		switch (component.ParentObj.ParentItem.m_BeatItemType)
		{
		case csBeatItemType.Normal:
		case csBeatItemType.SwiftKick:
			clipName = "kickClip";
			break;
		case csBeatItemType.SwiftKnee:
			clipName = "swiftknee";
			break;
		case csBeatItemType.SwiftTrample:
			if (num == 2)
			{
				num = 3;
			}
			clipName = "normalSuccess" + num + "_" + csGameSettings.currentHitSEType;
			if (csGameSettings.currentHitSEType == HitSoundEffectType.Dynamic)
			{
				useNewSoundEffect = false;
			}
			else
			{
				useNewSoundEffect = false;
			}
			break;
		case csBeatItemType.Reward:
			clipName = "rewardSuccess" + num;
			break;
		}
		if (useNewSoundEffect)
		{
			xmAudioCtrl.m_instance.PlaySoundWithVol(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f, parentItem.thisT.position);
		}
		else if (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.StickDirection || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.StickTurning)
		{
			csAudioManager.instance.playAudioAtPoint(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.5f, parentItem.thisT.position);
		}
		else if (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftKick)
		{
			csAudioManager.instance.playAudioByName(clipName);
		}
		else
		{
			csAudioManager.instance.playAudioAtPoint(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f, parentItem.thisT.position);
		}
	}

	public void OnTriggerEnterByBoxCastFailure(Collider other)
	{
		csBeatChild component = other.GetComponent<csBeatChild>();
		if (component != null && (component.ParentObj.ParentItem.GetIsHit() || component.ParentObj.ParentItem.m_BeatItemColor != m_WandColor || component.ParentObj.ParentItem.m_BeatItemType != CheckType))
		{
			return;
		}
		int num = 0;
		if ((bool)component)
		{
			num = CheckSpeed(component.ParentObj.ParentItem.m_BeatItemType);
		}
		if (!component || num <= 0)
		{
			return;
		}
		bool flag = false;
		Vector3 forward = Vector3.forward;
		switch (component.ParentObj.ParentItem.m_BeatItemType)
		{
		case csBeatItemType.SwiftKick:
			if (csPlayer.instance.SwiftContrl.CurState != PlayerState.LeftKick && csPlayer.instance.SwiftContrl.CurState != PlayerState.RightKick)
			{
				flag = true;
			}
			break;
		case csBeatItemType.SwiftKnee:
			if (csPlayer.instance.SwiftContrl.CurState != PlayerState.LeftKnee && csPlayer.instance.SwiftContrl.CurState != PlayerState.RightKnee)
			{
				flag = true;
			}
			break;
		}
		csEditorBeatItem parentItem = component.ParentObj.ParentItem;
		if (flag)
		{
			parentItem.OnItemMissFly(forward);
			string text = "normalMiss";
			switch (component.ParentObj.ParentItem.m_BeatItemType)
			{
			case csBeatItemType.Normal:
				text = "normalMiss";
				break;
			case csBeatItemType.Reward:
				text = "rewardMiss";
				break;
			case csBeatItemType.Direction:
				text = "directionMiss";
				break;
			case csBeatItemType.Defence:
				text = "defenceMiss";
				break;
			}
			csAudioManager.instance.playAudioByName(text, csGameSettings.SoundEffectVol * 0.25f);
		}
	}

	public int CheckSpeed(csBeatItemType beatType)
	{
		int num = SpeedStartLevel;
		float num2 = 0f;
		num2 = ((m_WandColor == csBeatItemColor.LBlack) ? ((CheckType != csBeatItemType.SwiftKnee) ? csPlayer.instance.SwiftContrl.GetSpeedByState(PlayerState.LeftKick) : csPlayer.instance.SwiftContrl.GetSpeedByState(PlayerState.LeftKnee)) : ((CheckType != csBeatItemType.SwiftKnee) ? csPlayer.instance.SwiftContrl.GetSpeedByState(PlayerState.RightKick) : csPlayer.instance.SwiftContrl.GetSpeedByState(PlayerState.RightKnee)));
		if (beatType == csBeatItemType.SwiftKick)
		{
			if (num2 > csPlayer.instance.SwiftContrl.HardKickSpeed)
			{
				if (num < 3)
				{
					num = 3;
				}
			}
			else if (num < 1)
			{
				num = 1;
			}
		}
		else if (num2 > csPlayer.instance.SwiftContrl.HardKneeSpeed)
		{
			if (num < 3)
			{
				num = 3;
			}
		}
		else if (num < 1)
		{
			num = 1;
		}
		return num;
	}

	public void SetHapticLastTime(float t, csEditorBeatItem thisBeat)
	{
		if (LastHitBeat != thisBeat && thisBeat.m_BeatItemColor == m_WandColor)
		{
			LineHapticOn = true;
			LastHitBeat = thisBeat;
			isNewBeat = true;
			HapticLastTime = t;
			HapticStrength = HapticStrengthOri;
		}
	}

	private void Update()
	{
		hitCol = Physics.BoxCastAll(BoxCastCol.transform.position, BoxCastCol.transform.localScale.x * BoxCastCol.size / 2f, BoxCastCol.transform.up, BoxCastCol.transform.rotation, CheckDist, 1024);
		failureHitCol = Physics.BoxCastAll(BoxCastCol.transform.position - Vector3.forward * 0.5f, BoxCastCol.transform.localScale.x * BoxCastCol.size / 2f, BoxCastCol.transform.up, BoxCastCol.transform.rotation, CheckDist, 1024);
		if (hitCol.Length != 0)
		{
			RaycastHit[] array = hitCol;
			foreach (RaycastHit raycastHit in array)
			{
				OnTriggerEnterByBoxCast(raycastHit.collider);
			}
		}
		if (failureHitCol.Length != 0)
		{
			RaycastHit[] array = failureHitCol;
			foreach (RaycastHit raycastHit2 in array)
			{
				OnTriggerEnterByBoxCastFailure(raycastHit2.collider);
			}
		}
	}

	public bool CheckDirectionObj(Vector3 handVelocity, Transform direction)
	{
		if (Vector3.Angle(handVelocity, direction.up) < csGameSettings.DirAngleOffset)
		{
			return true;
		}
		return false;
	}
}
public class csThinkingSceneGameManager : MonoBehaviour
{
	public GAMESTATE gameState = GAMESTATE.MENUSTART;

	public csMediaPlayerMan mediaPlayerMan;

	private bool cantPause;

	public bool SkipClicked;

	public static csThinkingSceneGameManager instance;

	public bool isGameEnd;

	public csPlayer CurPlayer;

	public csGameSongPlayer SongPlayer;

	public csMusicCtrl musicCtrl;

	public csGameValueManager GameValueManager;

	public GameSongData CurSongData;

	private bool isShowMeadia;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		isGameEnd = false;
		csTutorialSceneGameManager.isTutorial = false;
		Cursor.lockState = CursorLockMode.Locked;
	}

	private IEnumerator Start()
	{
		while (!CurPlayer)
		{
			yield return null;
		}
		Transform transform = (UnityEngine.Object.Instantiate(Resources.Load("Player/SongTimer"), CurPlayer.camT) as GameObject).transform;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		SongPlayer.SongTimer = transform.GetComponentInChildren<Text>();
		SongPlayer.SongTimer.enabled = false;
		startThinkingGame();
	}

	private void Update()
	{
		UserInput();
	}

	private void UserInput()
	{
		if (csGameSettings.isLoading)
		{
			return;
		}
		if (gameState == GAMESTATE.FollowTime || gameState == GAMESTATE.FollowTimePause)
		{
			if (gameState == GAMESTATE.FollowTime && !mediaPlayerMan.isPause && mediaPlayerMan.CanPause)
			{
				if (CurPlayer.GetMenuBtnDown())
				{
					PauseGameInFollowTime();
				}
			}
			else if (gameState == GAMESTATE.FollowTimePause && CurPlayer.GetMenuBtnDown() && mediaPlayerMan.isPause)
			{
				ResumeGameInCaochTime();
			}
		}
		if (gameState == GAMESTATE.FollowGap)
		{
			if (CurPlayer.GetMenuBtnDown() && !cantPause)
			{
				PauseGameInFollowGap();
			}
		}
		else if (gameState == GAMESTATE.FollowGapPause && CurPlayer.GetMenuBtnDown())
		{
			ResumeGameInFollowGap();
		}
	}

	private void PauseGameInFollowTime()
	{
		csSportInfoManager.instance.pauseDataRecord();
		csSportInfoManager.instance.PauseCalculateCal();
		gameState = GAMESTATE.FollowTimePause;
		PauseVideo();
		csIngameMenuManager.instance.PauseGameInFollowTime();
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	public void ResumeGameInCaochTime()
	{
		if (gameState == GAMESTATE.FollowTimePause)
		{
			csSportInfoManager.instance.ResumeCalculateCal();
			csSportInfoManager.instance.startDataRecord();
			gameState = GAMESTATE.FollowTime;
		}
		else
		{
			gameState = GAMESTATE.CoachTime;
		}
		csIngameMenuManager.instance.ResumeGame();
		mediaPlayerMan.resumePlay();
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	private void PauseGameInFollowGap()
	{
		gameState = GAMESTATE.FollowGapPause;
		csIngameMenuManager.instance.PauseGameInFollowGap();
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	public void BackToMain()
	{
		gameState = GAMESTATE.MENUSTART;
		StopAllCoroutines();
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csGameDataTransfer.playMode = csPlayMode.Menu;
			csGameSettings.currGameScene = GameScene.Main;
			GameData.instance.StartCoroutine(backToGameScene());
		}, 2.5f);
		SongPlayer.Stop();
		SongPlayer.ClearData();
		csIngameMenuManager.instance.ClosePanel();
	}

	private IEnumerator backToGameScene()
	{
		Scene activeScene = SceneManager.GetActiveScene();
		CreateSceneParameters parameters = new CreateSceneParameters(LocalPhysicsMode.None);
		SceneManager.CreateScene("Fake", parameters);
		AsyncOperation asyncOperation = SceneManager.UnloadSceneAsync(activeScene, UnloadSceneOptions.UnloadAllEmbeddedSceneObjects);
		Resources.UnloadUnusedAssets();
		GC.Collect();
		bool UploadDone = false;
		asyncOperation.completed += delegate
		{
			UploadDone = true;
		};
		while (!UploadDone)
		{
			yield return null;
		}
		SceneManager.LoadScene("GameScene");
	}

	public void ResumeGameInFollowGap()
	{
		csSportInfoManager.instance.ResumeCalculateCal();
		csSportInfoManager.instance.startDataRecord();
		gameState = GAMESTATE.FollowGap;
		csIngameMenuManager.instance.ResumeGame();
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameFollowGap);
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	public void PauseVideo()
	{
		mediaPlayerMan.pausePlay();
	}

	public void closeVideo()
	{
		mediaPlayerMan.closeVideo();
	}

	private void startThinkingGame()
	{
		GameSongData gameSongData = (CurSongData = GameData.instance.GetSongDataByClassID(csGameDataTransfer.currentClassID));
		csGameSettings.isLoading = false;
		csEnvironmentManager.instance.ChangeEnvInFollow(CurSongData.FixedWPSkyboxName);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		mediaPlayerMan.changeScreenT(gameSongData.WarmUpVideoOffset, gameSongData.WarmUpVideoScale, gameSongData.WarmUpCaochEuler, CurSongData.EyeOffsetX, CurSongData.IsSingleEyeLevel);
		csPlayer.instance.ResetRotation(isReset: true);
		isShowMeadia = true;
		StartCoroutine(StartThinkingGameByID(gameSongData));
		csIngameMenuManager.instance.inGameFollowPause.InitClassDetail(gameSongData);
	}

	private IEnumerator StartThinkingGameByID(GameSongData sd)
	{
		gameState = GAMESTATE.FollowTime;
		while ((bool)csPlayer.instance && !csPlayer.instance.welcomeOver)
		{
			yield return null;
		}
		csPlayer.instance.SetHeadDownHint(flag: true);
		csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
		csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
		yield return StartThinkingTime(sd);
		yield return new WaitForSeconds(1f);
	}

	private IEnumerator StartThinkingTime(GameSongData songData)
	{
		gameState = GAMESTATE.FollowTime;
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		mediaPlayerMan.screen.SetActive(value: true);
		mediaPlayerMan.setVideoByIndexFollow(songData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(songData.ClassID, VideoType.WarmUp));
		mediaPlayerMan.changeScreenT(songData.WarmUpVideoOffset, songData.WarmUpVideoScale, songData.WarmUpCaochEuler, songData.EyeOffsetX, songData.IsSingleEyeLevel);
		while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		mediaPlayerMan.mediaPlayer.AudioVolume = 0f;
		mediaPlayerMan.startPlay();
		PlayWarmUpSound();
		gameState = GAMESTATE.FollowTime;
		cantPause = true;
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			if (csGameSettings.PlayerCurrentDataOn)
			{
				cantPause = false;
			}
		});
		float timer = 0f;
		float allTime = songData.WarmUpOrFollowVideoLength;
		float warmUpVedioTime = mediaPlayerMan.getMediaLength();
		while (gameState != GAMESTATE.MENUSTART && timer <= allTime + 1.5f)
		{
			if (timer >= warmUpVedioTime && isShowMeadia)
			{
				FadeToHideMediaPlayer();
				SetCoolDownVeido();
			}
			timer += Time.deltaTime;
			yield return null;
		}
		StopWarmUpSound();
		mediaPlayerMan.SetAudioVolume();
		mediaPlayerMan.setVideoByIndexFollow(songData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(songData.ClassID, VideoType.CoolDown));
		FadeToShowMediaPlayer();
		float timerCool = 0f;
		float allTimeCool = mediaPlayerMan.getMediaLength();
		while (gameState != GAMESTATE.MENUSTART && timerCool <= allTimeCool)
		{
			timerCool += Time.deltaTime;
			yield return null;
		}
		gameState = GAMESTATE.FollowGap;
		cantPause = true;
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			mediaPlayerMan.closeVideo();
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				cantPause = false;
			}, 1f);
		}, 1f);
		yield return new WaitForSeconds(2f);
		if (gameState != GAMESTATE.MENUSTART)
		{
			csIngameMenuManager.instance.SetAndShowResultFollow();
			csCloudStorage.instance.SetClassAsClassHistory(csGameDataTransfer.currentClassID, ClassHistoryState.Finished);
			csCloudStorage.instance.AddNewBeheaviorData(BeheaviorType.ClassFinishNum, 1, csGameDataTransfer.currentClassID);
			csCloudStorage.instance.addClockInDate(null);
			gameState = GAMESTATE.FollowResult;
		}
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	private void PlayWarmUpSound()
	{
		AudioClip coachStartVoiceClip = csAssetLoader.instance.curMusicData.ThinkGameData.CoachStartVoiceClip;
		musicCtrl.musicList[0] = coachStartVoiceClip;
		musicCtrl.m_BGMAudio.enabled = true;
		musicCtrl.PlayGameBGM();
	}

	private void StopWarmUpSound()
	{
		musicCtrl.m_BGMAudio.Stop();
	}

	private void SetCoolDownVeido()
	{
	}

	private void FadeToHideMediaPlayer()
	{
		isShowMeadia = false;
		mediaPlayerMan.ChangeColor(new Color(1f, 1f, 1f, 0f), 2f, delegate
		{
			mediaPlayerMan.pausePlay();
		});
	}

	private void FadeToShowMediaPlayer()
	{
		isShowMeadia = true;
		mediaPlayerMan.startPlay();
		mediaPlayerMan.ChangeColor(new Color(1f, 1f, 1f, 1f), 2f, delegate
		{
		});
	}

	public void SetFollowAudioVolume()
	{
		mediaPlayerMan.SetAudioVolume();
	}
}
public class csTutorialSceneGameManager : MonoBehaviour
{
	public GAMESTATE gameState = GAMESTATE.MENUSTART;

	public csMediaPlayerMan mediaPlayerMan;

	private bool cantPause;

	public bool SkipClicked;

	private string currentClassID;

	public static csTutorialSceneGameManager instance;

	public static bool isTutorial;

	public bool isGameEnd;

	public List<csMusicPrefabOptmizedData> endMusicPrefabs;

	public AudioSource CoachVoiceAudioSource;

	public List<AudioClip> PracticeCoachVoiceClips;

	public bool isFinalMusicGameOver;

	[Header("拳击教程视频配置")]
	[Tooltip("暂停的时间")]
	public List<float> PauseTimePunch;

	[Tooltip("开始的时间")]
	public List<float> StartTimePunch;

	[Header("棍棒教程视频配置")]
	[Tooltip("暂停的时间")]
	public List<float> PauseTimeStick;

	[Tooltip("开始的时间")]
	public List<float> StartTimeStick;

	[Header("两个教程通用时间监视器")]
	[SerializeField]
	[Tooltip("当前第几段视频")]
	private int currentVideoIndex;

	[SerializeField]
	[Tooltip("暂停的偏移量，避免误差")]
	private float pauseTimeOffset;

	[Tooltip("当前时间")]
	[SerializeField]
	private float currentTimer;

	[Tooltip("教程视频的总时间")]
	[SerializeField]
	private float videoAllTime;

	public string tutorialStage;

	[Space]
	public csPlayer CurPlayer;

	public csGameSongPlayer SongPlayer;

	public csMusicCtrl musicCtrl;

	public csGameValueManager GameValueManager;

	public GameSongData CurSongData;

	public TutorialStep CurrentStep;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		isGameEnd = false;
		isTutorial = true;
		Cursor.lockState = CursorLockMode.Locked;
	}

	private IEnumerator Start()
	{
		while (!CurPlayer)
		{
			yield return null;
		}
		startGame();
	}

	private void Update()
	{
		UserInput();
	}

	private void UserInput()
	{
		if (!csGameSettings.isLoading)
		{
			if (gameState == GAMESTATE.TutorialVideo && CurPlayer.GetMenuBtnDown())
			{
				PauseGameInTutorialVideo();
			}
			if (gameState == GAMESTATE.INGAME && CurPlayer.GetMenuBtnDown())
			{
				PauseGameInTutorialGame();
			}
		}
	}

	private void PauseGameInTutorialVideo()
	{
		gameState = GAMESTATE.TutorialVideoPause;
		csIngameMenuManager.instance.PauseGameInTutorial();
		mediaPlayerMan.pausePlay();
		csPlayer.instance.pauseUILaser(dontUse: false);
	}

	public void ResumeGameInTutorialVideo()
	{
		gameState = GAMESTATE.TutorialVideo;
		mediaPlayerMan.resumePlay();
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	private void PauseGameInTutorialGame()
	{
		gameState = GAMESTATE.GAMEPAUSE;
		SongPlayer.Pause();
		csIngameMenuManager.instance.PauseGameInTutorial();
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
	}

	public void ResumeGameInTutorialGame()
	{
		gameState = GAMESTATE.INGAME;
		SongPlayer.OnBeforResume();
		SongPlayer.Resume();
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
	}

	public void BackToMain()
	{
		gameState = GAMESTATE.MENUSTART;
		StopAllCoroutines();
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csGameDataTransfer.playMode = csPlayMode.Menu;
			csGameSettings.currGameScene = GameScene.Main;
			GameData.instance.StartCoroutine(backToGameScene());
		}, 2.5f);
		SongPlayer.Stop();
		SongPlayer.ClearData();
		csIngameMenuManager.instance.ClosePanel();
	}

	private IEnumerator backToGameScene()
	{
		Scene activeScene = SceneManager.GetActiveScene();
		CreateSceneParameters parameters = new CreateSceneParameters(LocalPhysicsMode.None);
		SceneManager.CreateScene("Fake", parameters);
		AsyncOperation asyncOperation = SceneManager.UnloadSceneAsync(activeScene, UnloadSceneOptions.UnloadAllEmbeddedSceneObjects);
		Resources.UnloadUnusedAssets();
		GC.Collect();
		bool UploadDone = false;
		asyncOperation.completed += delegate
		{
			UploadDone = true;
		};
		while (!UploadDone)
		{
			yield return null;
		}
		SceneManager.LoadScene("GameScene");
	}

	private void startGame()
	{
		if (csGameDataTransfer.playMode == csPlayMode.Boxing)
		{
			CurSongData = GameData.instance.TutorialSongDataPunch;
		}
		if (csGameDataTransfer.playMode == csPlayMode.Stick)
		{
			CurSongData = GameData.instance.TutorialSongDataStick;
		}
		csPlayer.instance.SetHeadDownHint(flag: true);
		csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
		csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
		csGameSettings.isLoading = false;
		csEnvironmentManager.instance.ChangeEnvInTutorial("112");
		csPlayer.instance.switchController(isSwitchToMenu: true);
		mediaPlayerMan.changeScreenT(CurSongData.WarmUpVideoOffset, CurSongData.WarmUpVideoScale, CurSongData.WarmUpCaochEuler, CurSongData.EyeOffsetX, CurSongData.IsSingleEyeLevel);
		csPlayer.instance.ResetRotation(isReset: true);
		csIngameMenuManager.instance.inGameTutorialPause.InitClassDetail(CurSongData);
		StartCoroutine(StartTutorialGame());
	}

	private IEnumerator StartTutorialGame()
	{
		if (!PlayerPrefs.HasKey("GuideVideoDone"))
		{
			PlayerPrefs.SetInt("GuideVideoDone", 1);
			yield return StartPlayGuideVideo();
		}
		switch (csGameDataTransfer.playMode)
		{
		case csPlayMode.Boxing:
			StartCoroutine(TutorialPunchGame());
			break;
		case csPlayMode.Stick:
			StartCoroutine(TutorialStickGame());
			break;
		}
	}

	private IEnumerator TutorialPunchGame()
	{
		while (!csPlayer.instance)
		{
			yield return null;
		}
		PlayerPrefs.SetInt("PunchTutorialDone", 1);
		mediaPlayerMan.screen.SetActive(value: true);
		mediaPlayerMan.setVideoByIndex(CurSongData.FollowVideoDataList[1].VideoName, delegate
		{
		});
		mediaPlayerMan.changeScreenT(CurSongData.FollowVideoDataList[1].VideoOffset, CurSongData.FollowVideoDataList[1].VideoScale, CurSongData.FollowVideoDataList[1].CoachEuler, CurSongData.EyeOffsetX, CurSongData.IsSingleEyeLevel);
		while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		currentTimer = 0f;
		videoAllTime = mediaPlayerMan.getMediaLength();
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
		{
		});
		tutorialStage = "01_拳击教程开始";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "02_拳击第一段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step1_PunchNormal, PracticeCoachVoiceClips[0]);
		tutorialStage = "03_拳击第一段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "04_拳击第二段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step2_PunchDirection, PracticeCoachVoiceClips[1]);
		tutorialStage = "05_拳击第二段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "06_拳击第三段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step3_PunchHorizontalDirection, PracticeCoachVoiceClips[2]);
		tutorialStage = "07_拳击第三段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "08_拳击第四段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step4_WallAndDefence, PracticeCoachVoiceClips[3]);
		tutorialStage = "09_拳击第四段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "10_拳击第五段教学，视频观看完毕";
		yield return StartFinalMusicGame(endMusicPrefabs[0]);
		csTalkingData.Instance.SendEvent("JC06_拳击关卡", 1.0, null);
		tutorialStage = "11_拳击教学关卡通关";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		csTalkingData.Instance.SendEvent("JC05_拳击讲解", 1.0, null);
		tutorialStage = "12_拳击最后教学，视频观看完毕";
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.end_tutorial, new Dictionary<string, object>
		{
			{ "stage", tutorialStage },
			{ "status", "success" }
		});
		BackToMain();
	}

	private IEnumerator TutorialStickGame()
	{
		while (!csPlayer.instance)
		{
			yield return null;
		}
		PlayerPrefs.SetInt("StickTutorialDone", 1);
		mediaPlayerMan.screen.SetActive(value: true);
		mediaPlayerMan.setVideoByIndex(CurSongData.FollowVideoDataList[1].VideoName, delegate
		{
		});
		mediaPlayerMan.changeScreenT(CurSongData.FollowVideoDataList[1].VideoOffset, CurSongData.FollowVideoDataList[0].VideoScale, CurSongData.FollowVideoDataList[0].CoachEuler, CurSongData.EyeOffsetX, CurSongData.IsSingleEyeLevel);
		while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		currentTimer = 0f;
		videoAllTime = mediaPlayerMan.getMediaLength();
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
		{
		});
		tutorialStage = "12_棍棒教程开始";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "13_棍棒第一段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step1_StickDirection, PracticeCoachVoiceClips[4]);
		tutorialStage = "14_棍棒第一段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "15_棍棒第二段教学，视频观看完毕";
		yield return StartCheckPlayerAct(TutorialStep.Step2_StickTriangle, PracticeCoachVoiceClips[5]);
		tutorialStage = "16_棍棒第二段教学，玩家学习完毕";
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		tutorialStage = "17_棍棒第三段教学，视频观看完毕";
		yield return StartFinalMusicGame(endMusicPrefabs[1]);
		csTalkingData.Instance.SendEvent("JC08_棍棒关卡", 1.0, null);
		tutorialStage = "18_棍棒教学关卡通关";
		yield return new WaitForSeconds(3f);
		yield return StartPlayVideo(csGameDataTransfer.playMode);
		csTalkingData.Instance.SendEvent("JC07_棍棒讲解", 1.0, null);
		tutorialStage = "19_棍棒最后教学，视频观看完毕";
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.end_tutorial, new Dictionary<string, object>
		{
			{ "stage", tutorialStage },
			{ "status", "success" }
		});
		BackToMain();
	}

	private IEnumerator StartPlayGuideVideo()
	{
		tutorialStage = "00_0_开始播放引导视频";
		gameState = GAMESTATE.TutorialVideo;
		mediaPlayerMan.screen.SetActive(value: true);
		mediaPlayerMan.setVideoByIndex(CurSongData.FollowVideoDataList[0].VideoName, delegate
		{
		});
		mediaPlayerMan.changeScreenT(CurSongData.FollowVideoDataList[0].VideoOffset, CurSongData.FollowVideoDataList[0].VideoScale, CurSongData.FollowVideoDataList[0].CoachEuler, CurSongData.EyeOffsetX, CurSongData.IsSingleEyeLevel);
		while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
		{
		});
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		mediaPlayerMan.SetMatColor(new Color(1f, 1f, 1f, 0f));
		mediaPlayerMan.ChangeColor(new Color(1f, 1f, 1f, 1f), 0.6f, delegate
		{
		});
		mediaPlayerMan.startPlay(0.0, CurSongData);
		yield return new WaitForSeconds(0.65f);
		cantPause = true;
		float timer = 0f;
		float videoTime = mediaPlayerMan.getMediaLength();
		while (gameState != GAMESTATE.MENUSTART && timer <= videoTime)
		{
			if (!mediaPlayerMan.isPause)
			{
				timer += Time.deltaTime;
			}
			yield return null;
		}
		mediaPlayerMan.ChangeColor(new Color(1f, 1f, 1f, 0f), 1f, delegate
		{
		});
		yield return new WaitForSeconds(1.2f);
		mediaPlayerMan.CloseVideoInTutorial();
		tutorialStage = "00_1_引导视频播放完毕";
		csTalkingData.Instance.SendEvent("JC04_总体介绍", 1.0, null);
	}

	private IEnumerator StartPlayVideo(csPlayMode playMode)
	{
		gameState = GAMESTATE.TutorialVideo;
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		if (mediaPlayerMan.isPause)
		{
			yield return StartCoroutine(mediaPlayerMan.resumePlayInTutorial(currentTimer));
		}
		else
		{
			mediaPlayerMan.startPlay(0.0, CurSongData);
			mediaPlayerMan.SetMatColor(new Color(1f, 1f, 1f, 0f));
			mediaPlayerMan.ChangeColor(new Color(1f, 1f, 1f, 1f), 1f, delegate
			{
			});
			yield return new WaitForSeconds(1.1f);
		}
		cantPause = true;
		if (playMode == csPlayMode.Boxing)
		{
			while (gameState != GAMESTATE.MENUSTART && currentTimer < videoAllTime)
			{
				if (!mediaPlayerMan.isPause)
				{
					currentTimer += Time.deltaTime;
				}
				if (currentTimer >= PauseTimePunch[currentVideoIndex] - pauseTimeOffset - 1f && currentTimer <= PauseTimePunch[currentVideoIndex] + pauseTimeOffset)
				{
					yield return StartCoroutine(mediaPlayerMan.PasusePlayInTutorial());
					currentTimer = StartTimePunch[currentVideoIndex];
					mediaPlayerMan.mediaPlayer.Control.Seek(currentTimer);
					if (currentVideoIndex < PauseTimePunch.Count - 1)
					{
						currentVideoIndex++;
					}
					break;
				}
				yield return null;
			}
		}
		if (playMode == csPlayMode.Stick)
		{
			while (gameState != GAMESTATE.MENUSTART && currentTimer < videoAllTime)
			{
				if (!mediaPlayerMan.isPause)
				{
					currentTimer += Time.deltaTime;
				}
				if (currentTimer >= PauseTimeStick[currentVideoIndex] - pauseTimeOffset && currentTimer <= PauseTimeStick[currentVideoIndex] + pauseTimeOffset)
				{
					yield return StartCoroutine(mediaPlayerMan.PasusePlayInTutorial());
					currentTimer = StartTimeStick[currentVideoIndex];
					mediaPlayerMan.mediaPlayer.Control.Seek(currentTimer);
					if (currentVideoIndex < PauseTimeStick.Count - 1)
					{
						currentVideoIndex++;
					}
					break;
				}
				yield return null;
			}
		}
		gameState = GAMESTATE.TutorialPractice;
		cantPause = false;
	}

	private IEnumerator StartCheckPlayerAct(TutorialStep step, AudioClip coachVoiceClip)
	{
		gameState = GAMESTATE.TutorialPractice;
		CurrentStep = step;
		csPlayer.instance.switchController(isSwitchToMenu: false);
		switch (csGameDataTransfer.playMode)
		{
		case csPlayMode.Boxing:
			csTutorialPracticeManager.instance.StartPunchPractise(step);
			break;
		case csPlayMode.Stick:
			csTutorialPracticeManager.instance.StartStickPractise(step);
			break;
		}
		CoachVoiceAudioSource.clip = coachVoiceClip;
		CoachVoiceAudioSource.Play();
		while (CurrentStep != 0)
		{
			yield return null;
		}
		CoachVoiceAudioSource.Stop();
		CoachVoiceAudioSource.clip = null;
	}

	private IEnumerator StartFinalMusicGame(csMusicPrefabOptmizedData musicPrefabOptmizedData)
	{
		gameState = GAMESTATE.INGAME;
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: false);
		mediaPlayerMan.CoachPlatform.SetActive(value: false);
		csPlayer.instance.switchController(isSwitchToMenu: false);
		SongPlayer.CreatBeat(musicPrefabOptmizedData);
		SongPlayer.StartPlay(isStart: true);
		yield return new WaitUntil(() => isFinalMusicGameOver);
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: true);
		mediaPlayerMan.CoachPlatform.SetActive(value: true);
	}

	public void SetFollowAudioVolume()
	{
		mediaPlayerMan.SetAudioVolume();
	}

	public void SetStepFinish()
	{
		CurrentStep = TutorialStep.StepDone;
	}

	public IEnumerator OutChild(Transform parent, Transform target)
	{
		Vector3 localpos = target.localPosition;
		target.parent = base.transform;
		float waitTime = SongPlayer.SongPrepareDist / SongPlayer.beatGapDis;
		while (waitTime > 0f)
		{
			if (gameState == GAMESTATE.INGAME)
			{
				waitTime -= Time.deltaTime;
			}
			yield return new WaitForEndOfFrame();
		}
		target.parent = parent;
		target.localPosition = localpos;
	}
}
public enum TutorialStep
{
	StepDone,
	Step1_PunchNormal,
	Step2_PunchDirection,
	Step3_PunchHorizontalDirection,
	Step4_WallAndDefence,
	Step1_StickDirection,
	Step2_StickTriangle
}
public class csVideoCheckPlayer : MonoBehaviour
{
	public GameObject CurMusicPrefab;

	public csVideoPrefabOptmizedData curMusicData;

	public bool StartMove;

	private bool StartMoveState;

	public List<csVFItemData> CurBeatItemList = new List<csVFItemData>();

	public int curItemDataIndex;

	public int TotalCount;

	public int CurSLevelIndex;

	public float CurSongPlayTime;

	private float TimeAfterStop;

	public Dictionary<int, VFItemCheckData> ItemCheckResultDic = new Dictionary<int, VFItemCheckData>();

	private bool CheckingStart;

	private Vector3 LHandVelDir;

	private Vector3 RHandVelDir;

	public void CreatBeat(csVideoPrefabOptmizedData musicData)
	{
		CurSLevelIndex = 0;
		CurMusicPrefab = new GameObject("VideoFollowPrefab");
		CurMusicPrefab.transform.position = new Vector3(0f, 0f, 1f);
		List<float> list = new List<float>();
		curMusicData = UnityEngine.Object.Instantiate(musicData);
		for (int i = 0; i < curMusicData.SingleLevelDataList.Count; i++)
		{
			list.Add(curMusicData.SingleLevelDataList[i].SongPlayTime);
		}
		csIngameTimeLineHint.instance.InitDot(list);
		for (int j = 0; j < curMusicData.SingleLevelDataList.Count; j++)
		{
			TotalCount += curMusicData.SingleLevelDataList[j].VidItemList.Count;
		}
	}

	public void LoadLevel(int l)
	{
		CurSLevelIndex = l;
		CurBeatItemList = curMusicData.SingleLevelDataList[CurSLevelIndex].VidItemList;
	}

	public void StartPlay(bool isStart, int level)
	{
		LoadLevel(level);
		csPlayer.instance.SetHeadDownHint(flag: false);
		StartMove = isStart;
		StartMoveState = StartMove;
		if (StartMove)
		{
			curItemDataIndex = 0;
		}
	}

	public void Pause()
	{
		StartMoveState = StartMove;
		StartMove = false;
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: false);
		}
	}

	public void OnBeforResume()
	{
		if ((bool)CurMusicPrefab)
		{
			CurMusicPrefab.SetActive(value: true);
		}
	}

	public void Resume()
	{
		if (!csTutorialSceneGameManager.instance)
		{
			csIngameTimeLineHint.instance.FadeIn();
			if (GameManagerNew.instance.CurSongData.TypeInHand == csPlayMode.Boxing && GameManagerNew.instance.CurSongData.Type == ClassType.Sport)
			{
				csIngamePowerBar.instance.FadeIn();
			}
		}
		StartMove = StartMoveState;
	}

	public void ClearData()
	{
		if ((bool)curMusicData)
		{
			UnityEngine.Object.Destroy(curMusicData.gameObject);
		}
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
			UnityEngine.Object.Destroy(CurMusicPrefab);
		}
	}

	public void ClearBeatsToPool(Transform BeatParent)
	{
		csVFollowItemBase[] componentsInChildren = BeatParent.GetComponentsInChildren<csVFollowItemBase>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnItemReturnToPool();
		}
	}

	public void ClearSLevelData()
	{
		if ((bool)CurMusicPrefab)
		{
			ClearBeatsToPool(CurMusicPrefab.transform);
		}
	}

	public void Stop()
	{
		CurSongPlayTime = 0f;
		StartMoveState = StartMove;
		StartMove = false;
		curItemDataIndex = 0;
		TimeAfterStop = 0f;
	}

	private void Update()
	{
		if (!StartMove)
		{
			return;
		}
		if (csFollowSceneGameManager.instance.mediaPlayerMan.mediaPlayer.Control.IsPlaying())
		{
			CurSongPlayTime = (float)csFollowSceneGameManager.instance.mediaPlayerMan.mediaPlayer.Control.GetCurrentTime();
		}
		if (curItemDataIndex >= CurBeatItemList.Count)
		{
			return;
		}
		while (CurBeatItemList[curItemDataIndex].ShowTime < CurSongPlayTime)
		{
			if (CurBeatItemList[curItemDataIndex].ShowTime >= 0f && CurBeatItemList[curItemDataIndex].ShowTime < CurSongPlayTime)
			{
				InitBeatItemByItemData(curItemDataIndex, CurBeatItemList[curItemDataIndex]);
				curItemDataIndex++;
			}
			else if (CurBeatItemList[curItemDataIndex].ShowTime < 0f)
			{
				curItemDataIndex++;
			}
			if (curItemDataIndex >= CurBeatItemList.Count)
			{
				break;
			}
		}
	}

	public void InitBeatItemByItemData(int itemIndex, csVFItemData d)
	{
		switch (d.VFType)
		{
		case VFllowItemType.CheckPointStart:
			CheckingStart = true;
			break;
		case VFllowItemType.CheckPointEnd:
		{
			CheckingStart = false;
			bool flag = true;
			foreach (VFItemCheckData value in ItemCheckResultDic.Values)
			{
				if (!value.IsCorrect)
				{
					flag = false;
					CheckEndFail();
					break;
				}
			}
			if (flag)
			{
				CheckEndSuccess();
			}
			break;
		}
		case VFllowItemType.MovementJudge:
			ItemCheckResultDic.Add(itemIndex, new VFItemCheckData(d.VFType, ic: false));
			StartCoroutine(SingleMoveJudge(itemIndex, d, ItemCheckResultDic[itemIndex]));
			break;
		}
	}

	private void CheckEndFail()
	{
	}

	private void CheckEndSuccess()
	{
	}

	private float PlayerHeight()
	{
		return csGameSettings.CenterHolePos.y + 0.4f;
	}

	private IEnumerator SingleMoveJudge(int itemIndex, csVFItemData d, VFItemCheckData checkData)
	{
		while (CheckingStart && !checkData.IsCorrect)
		{
			bool HeadCheckPass = false;
			bool HandLCheckPass = false;
			bool HandRCheckPass = false;
			yield return null;
			if (d.smData.HeadSetData.IsCheck)
			{
				if (Input.GetKey(KeyCode.UpArrow))
				{
					HeadCheckPass = true;
				}
				if (d.smData.HeadSetData.HeightPercent <= 0f || Mathf.Abs(csPlayer.instance.PicoXRControllerHead.thisT.localPosition.y - d.smData.HeadSetData.HeightPercent * PlayerHeight()) < 0.15f)
				{
					if ((d.smData.HeadSetData.Speed <= 0f || csPlayer.instance.PicoXRControllerHead.GetVel().sqrMagnitude > d.smData.HeadSetData.Speed * d.smData.HeadSetData.Speed) && (!d.smData.HeadSetData.IsCheckDir || Vector3.Dot(d.smData.HeadSetData.LookDir, csPlayer.instance.PicoXRControllerHead.thisT.forward) > 0.8f))
					{
						HeadCheckPass = true;
					}
				}
				else
				{
					HeadCheckPass = false;
				}
			}
			else
			{
				HeadCheckPass = true;
			}
			if (d.smData.ControllerDataL.IsCheck)
			{
				if (Input.GetKey(KeyCode.LeftArrow))
				{
					HandLCheckPass = true;
				}
				if ((!d.smData.ControllerDataL.IsCheckDirToHead || Vector3.Dot(d.smData.ControllerDataL.HandDir.normalized, (csPlayer.instance.PicoXRControllerL.thisT.position - csPlayer.instance.PicoXRControllerHead.thisT.position).normalized) > 0.8f) && (!d.smData.ControllerDataL.IsCheckDistToHead || d.smData.ControllerDataL.HandDist * PlayerHeight() < (csPlayer.instance.PicoXRControllerL.thisT.position - csPlayer.instance.PicoXRControllerHead.thisT.position).magnitude))
				{
					if (!d.smData.ControllerDataL.IsCheckVel)
					{
						HandLCheckPass = true;
					}
					else if (csPlayer.instance.PicoXRControllerL.GetVel().sqrMagnitude > d.smData.ControllerDataL.Vel.sqrMagnitude && Vector3.Dot(csPlayer.instance.PicoXRControllerL.GetVel().normalized, d.smData.ControllerDataL.Vel.normalized) > 0.8f)
					{
						HandLCheckPass = true;
					}
				}
			}
			else
			{
				HandLCheckPass = true;
			}
			if (d.smData.ControllerDataR.IsCheck)
			{
				if (Input.GetKey(KeyCode.RightArrow))
				{
					HandRCheckPass = true;
				}
				if ((!d.smData.ControllerDataR.IsCheckDirToHead || Vector3.Dot(d.smData.ControllerDataR.HandDir.normalized, (csPlayer.instance.PicoXRControllerR.thisT.position - csPlayer.instance.PicoXRControllerHead.thisT.position).normalized) > 0.8f) && (!d.smData.ControllerDataR.IsCheckDistToHead || d.smData.ControllerDataR.HandDist * PlayerHeight() < (csPlayer.instance.PicoXRControllerR.thisT.position - csPlayer.instance.PicoXRControllerHead.thisT.position).magnitude))
				{
					if (!d.smData.ControllerDataR.IsCheckVel)
					{
						HandRCheckPass = true;
					}
					else if (csPlayer.instance.PicoXRControllerR.GetVel().sqrMagnitude > d.smData.ControllerDataR.Vel.sqrMagnitude && Vector3.Dot(csPlayer.instance.PicoXRControllerR.GetVel().normalized, d.smData.ControllerDataR.Vel.normalized) > 0.8f)
					{
						HandRCheckPass = true;
					}
				}
			}
			else
			{
				HandRCheckPass = true;
			}
			if (HeadCheckPass && HandLCheckPass && HandRCheckPass)
			{
				checkData.IsCorrect = true;
			}
		}
	}
}
public class csWandChecker : MonoBehaviour
{
	public bool IsInnerChecker;

	public bool CheckWayObj;

	public csBeatItemColor m_WandColor;

	public BoxCollider Col;

	public BoxCollider BoxCastCol;

	private bool useNewSoundEffect;

	private bool isCheckingColor;

	public GameObject gloveFireLv1;

	public GameObject gloveFireLv2;

	private int SpeedStartLevel;

	private bool LineHapticOn;

	private bool isNewBeat = true;

	private float HapticStrength = 0.9f;

	private float HapticStrengthOri = 0.9f;

	public float HapticLastTime = 3f;

	private csEditorBeatItem LastHitBeat;

	private float HapticTimer;

	private RaycastHit[] hitCol;

	private RaycastHit[] failureHitCol;

	public float CheckDist = 0.8f;

	public float failureCheckDis = 0.15f;

	private float WayObjAddScale = 2f;

	private int fireState;

	private void Start()
	{
		csGameValueManager gameValueManager = GameManagerNew.instance.GameValueManager;
		gameValueManager.isBoxingFire = (Action<int>)Delegate.Combine(gameValueManager.isBoxingFire, new Action<int>(IsFire));
	}

	public void OnTriggerEnterByBoxCast(Collider other)
	{
		csBeatChild component = other.GetComponent<csBeatChild>();
		if (component != null && (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftKick || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftKnee || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftTrample))
		{
			return;
		}
		isCheckingColor = component != null && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Reward && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Way && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Defence && component.ParentObj.ParentItem.m_BeatItemColor != m_WandColor;
		if (component != null && (component.ParentObj.ParentItem.GetIsHit() || isCheckingColor))
		{
			return;
		}
		int num = 0;
		if ((bool)component)
		{
			num = CheckSpeed(component.ParentObj.ParentItem.m_BeatItemType);
		}
		if ((bool)component && (num > 0 || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Defence || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Way))
		{
			bool flag = false;
			Vector3 forceDir = Vector3.forward;
			switch (component.ParentObj.ParentItem.m_BeatItemType)
			{
			default:
				forceDir = ((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel();
				flag = true;
				break;
			case csBeatItemType.Way:
				flag = true;
				break;
			case csBeatItemType.Direction:
			case csBeatItemType.Turning:
				flag = CheckDirectionObj(((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel(), component.ParentObj.transform);
				forceDir = ((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel();
				break;
			case csBeatItemType.StickDirection:
			case csBeatItemType.StickTurning:
				flag = true;
				forceDir = ((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel();
				break;
			case csBeatItemType.Defence:
				flag = csPlayer.instance.InDefenseState();
				break;
			}
			csEditorBeatItem parentItem = component.ParentObj.ParentItem;
			if (flag && parentItem.m_BeatItemColor != m_WandColor && parentItem.m_BeatItemType != csBeatItemType.Reward && parentItem.m_BeatItemType != csBeatItemType.Way)
			{
				_ = parentItem.m_BeatItemType;
				_ = 4;
			}
			if (flag)
			{
				if (parentItem.m_BeatItemType == csBeatItemType.Way)
				{
					SetHapticLastTime(parentItem.GetAddTime(), parentItem);
				}
				else
				{
					component.ParentObj.ParentItem.currentHitSpeedLevel = num;
					parentItem.OnItemHit(forceDir);
					if (parentItem.m_BeatItemType == csBeatItemType.Defence)
					{
						csPlayer.instance.SetControllerVibration(1f, 100, 0.5f, 50, 300f, 0f);
						if ((bool)csPlayer.instance)
						{
							csPlayer.instance.TriggerHandHaptic(isL: true);
							csPlayer.instance.TriggerHandHaptic(isL: false);
						}
					}
					else
					{
						if (LineHapticOn && HapticStrength < HapticStrengthOri * 0.5f)
						{
							HapticStrength = 0f;
							LineHapticOn = false;
							GameManagerNew.instance.CurPlayer.StartHandHaptic(isL: true, 0f, 0f);
						}
						if (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Reward)
						{
							csPlayer.instance.SetControllerVibration(1f, 50, 0.8f, 50, 100f, 100f);
						}
						else if (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Normal || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Direction)
						{
							switch (num)
							{
							case 1:
								csPlayer.instance.SetControllerVibration(0.7f, 140, 0.7f, 110, 0f, 140f);
								break;
							case 2:
								csPlayer.instance.SetControllerVibration(1f, 80, 1f, 60, 0f, 160f);
								break;
							case 3:
								csPlayer.instance.SetControllerVibration(1f, 80, 1f, 60, 0f, 160f);
								break;
							}
						}
						else
						{
							switch (num)
							{
							case 1:
								csPlayer.instance.SetControllerVibration(0.8f, 200, 0.4f, 150, 0f, 150f);
								break;
							case 2:
								csPlayer.instance.SetControllerVibration(1f, 200, 0.6f, 150, 0f, 150f);
								break;
							case 3:
								csPlayer.instance.SetControllerVibration(1f, 200, 0.6f, 150, 0f, 150f);
								break;
							}
						}
						if ((bool)csPlayer.instance)
						{
							csPlayer.instance.TriggerHandHaptic(m_WandColor == csBeatItemColor.LBlack);
						}
					}
					string clipName = "normalSuccess";
					useNewSoundEffect = false;
					switch (component.ParentObj.ParentItem.m_BeatItemType)
					{
					case csBeatItemType.Normal:
						if (num == 2)
						{
							num = 3;
						}
						clipName = "normalSuccess" + num + "_" + csGameSettings.currentHitSEType;
						if (csGameSettings.currentHitSEType == HitSoundEffectType.Dynamic)
						{
							useNewSoundEffect = false;
						}
						else
						{
							useNewSoundEffect = false;
						}
						break;
					case csBeatItemType.Reward:
						clipName = "rewardSuccess" + num;
						break;
					case csBeatItemType.Direction:
						if (num == 2)
						{
							num = 3;
						}
						clipName = "normalSuccess" + num + "_" + csGameSettings.currentHitSEType;
						if (csGameSettings.currentHitSEType == HitSoundEffectType.Dynamic)
						{
							useNewSoundEffect = false;
						}
						else
						{
							useNewSoundEffect = false;
						}
						break;
					case csBeatItemType.Turning:
						if (num == 2)
						{
							num = 3;
						}
						clipName = "normalSuccess" + num + "_" + csGameSettings.currentHitSEType;
						if (csGameSettings.currentHitSEType == HitSoundEffectType.Dynamic)
						{
							useNewSoundEffect = false;
						}
						else
						{
							useNewSoundEffect = false;
						}
						break;
					case csBeatItemType.StickTurning:
						if (num == 2)
						{
							num = 3;
						}
						clipName = "directionSuccess" + num;
						break;
					case csBeatItemType.StickDirection:
						if (num == 2)
						{
							num = 3;
						}
						clipName = "directionSuccess" + num;
						break;
					case csBeatItemType.Defence:
						clipName = "defenceSuccess_" + csGameSettings.currentHitSEType;
						break;
					}
					if (useNewSoundEffect)
					{
						xmAudioCtrl.m_instance.PlaySoundWithVol(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f, parentItem.thisT.position);
					}
					else if (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.StickDirection || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.StickTurning)
					{
						csAudioManager.instance.playAudioAtPoint(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.5f, parentItem.thisT.position);
					}
					else
					{
						csAudioManager.instance.playAudioAtPoint(clipName, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.8f, parentItem.thisT.position);
					}
				}
			}
			else
			{
				parentItem.OnItemMissFly((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL.GetVel() : csPlayer.instance.PicoXRControllerR.GetVel());
				string text = "normalMiss";
				switch (component.ParentObj.ParentItem.m_BeatItemType)
				{
				case csBeatItemType.Normal:
					text = "normalMiss_" + csGameSettings.currentHitSEType;
					break;
				case csBeatItemType.Reward:
					text = "rewardMiss";
					break;
				case csBeatItemType.Direction:
					text = "directionMiss_" + csGameSettings.currentHitSEType;
					break;
				case csBeatItemType.Defence:
					text = "defenceMiss_" + csGameSettings.currentHitSEType;
					break;
				}
				csAudioManager.instance.playAudioAtPoint(text, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.8f, parentItem.thisT.position);
			}
		}
		else if ((bool)component && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Defence)
		{
			csEditorBeatItem parentItem2 = component.ParentObj.ParentItem;
			if ((bool)parentItem2)
			{
				parentItem2.OnItemMissFly((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL.GetVel() : csPlayer.instance.PicoXRControllerR.GetVel());
			}
			string text2 = "normalMiss";
			switch (component.ParentObj.ParentItem.m_BeatItemType)
			{
			case csBeatItemType.Normal:
				text2 = "normalMiss_" + csGameSettings.currentHitSEType;
				break;
			case csBeatItemType.Reward:
				text2 = "rewardMiss";
				break;
			case csBeatItemType.Direction:
				text2 = "directionMiss_" + csGameSettings.currentHitSEType;
				break;
			case csBeatItemType.Defence:
				text2 = "defenceMiss_" + csGameSettings.currentHitSEType;
				break;
			}
			csAudioManager.instance.playAudioAtPoint(text2, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.8f, parentItem2.thisT.position);
		}
		csWallHole component2 = other.GetComponent<csWallHole>();
		if ((bool)component2 && (component2.ParentWall.needLeftHandPass || component2.ParentWall.needRightHandPass))
		{
			component2.ParentWall.OnItemHit((m_WandColor == csBeatItemColor.LBlack) ? 1 : 2);
		}
	}

	public void OnTriggerEnterByBoxCastFailure(Collider other)
	{
		csBeatChild component = other.GetComponent<csBeatChild>();
		if ((component != null && (component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftKick || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftKnee || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.SwiftTrample)) || (component != null && (component.ParentObj.ParentItem.GetIsHit() || component.ParentObj.ParentItem.m_BeatItemColor == m_WandColor || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Reward || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Way || component.ParentObj.ParentItem.m_BeatItemType == csBeatItemType.Defence)))
		{
			return;
		}
		int num = 0;
		if ((bool)component)
		{
			num = CheckSpeed(component.ParentObj.ParentItem.m_BeatItemType);
		}
		if (!component || (num <= 0 && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Defence && component.ParentObj.ParentItem.m_BeatItemType != csBeatItemType.Way))
		{
			return;
		}
		bool flag = false;
		_ = Vector3.forward;
		switch (component.ParentObj.ParentItem.m_BeatItemType)
		{
		default:
			((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel();
			flag = true;
			break;
		case csBeatItemType.Way:
			flag = true;
			break;
		case csBeatItemType.Direction:
		case csBeatItemType.Turning:
		case csBeatItemType.StickDirection:
		case csBeatItemType.StickTurning:
			flag = CheckDirectionObj(((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel(), component.ParentObj.transform);
			((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL : csPlayer.instance.PicoXRControllerR).GetVel();
			break;
		case csBeatItemType.Defence:
			flag = !csPlayer.instance.InDefenseState();
			break;
		}
		csEditorBeatItem parentItem = component.ParentObj.ParentItem;
		if (flag)
		{
			parentItem.OnItemMissFly((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL.GetVel() : csPlayer.instance.PicoXRControllerR.GetVel());
			string text = "normalMiss";
			switch (component.ParentObj.ParentItem.m_BeatItemType)
			{
			case csBeatItemType.Normal:
				text = "normalMiss";
				break;
			case csBeatItemType.Reward:
				text = "rewardMiss";
				break;
			case csBeatItemType.Direction:
				text = "directionMiss_" + csGameSettings.currentHitSEType;
				break;
			case csBeatItemType.Defence:
				text = "defenceMiss_" + csGameSettings.currentHitSEType;
				break;
			}
			csAudioManager.instance.playAudioAtPoint(text, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f * 0.8f, parentItem.thisT.position);
		}
	}

	public int CheckSpeed(csBeatItemType beatType)
	{
		int num = SpeedStartLevel;
		float num2 = ((m_WandColor == csBeatItemColor.LBlack) ? csPlayer.instance.PicoXRControllerL.GetVel().magnitude : csPlayer.instance.PicoXRControllerR.GetVel().magnitude);
		if (beatType == csBeatItemType.StickTurning || beatType == csBeatItemType.StickDirection)
		{
			if (num2 > csGameSettings.levelMinStickSpeed[2])
			{
				if (num < 3)
				{
					num = 3;
				}
			}
			else if (num2 > csGameSettings.levelMinStickSpeed[1])
			{
				if (num < 2)
				{
					num = 2;
				}
			}
			else if (num2 > csGameSettings.levelMinStickSpeed[0] && num < 1)
			{
				num = 1;
			}
		}
		else if (num2 > csGameSettings.levelMinSpeed[2])
		{
			if (num < 3)
			{
				num = 3;
			}
		}
		else if (num2 > csGameSettings.levelMinSpeed[1])
		{
			if (num < 3)
			{
				num = 3;
			}
		}
		else if (num2 > csGameSettings.levelMinSpeed[0] && num < 1)
		{
			num = 1;
		}
		return num;
	}

	public void SetHapticLastTime(float t, csEditorBeatItem thisBeat)
	{
		if (LastHitBeat != thisBeat && thisBeat.m_BeatItemColor == m_WandColor)
		{
			LineHapticOn = true;
			LastHitBeat = thisBeat;
			isNewBeat = true;
			HapticLastTime = t;
			HapticTimer = t;
			HapticStrength = HapticStrengthOri;
		}
	}

	private void Update()
	{
		hitCol = Physics.BoxCastAll(BoxCastCol.transform.position, BoxCastCol.transform.localScale.x * BoxCastCol.size / 2f, BoxCastCol.transform.up, BoxCastCol.transform.rotation, CheckDist, 1024);
		if (CheckWayObj)
		{
			failureHitCol = Physics.BoxCastAll(BoxCastCol.transform.position, BoxCastCol.transform.localScale.x * BoxCastCol.size / 8f, BoxCastCol.transform.up, BoxCastCol.transform.rotation, failureCheckDis, 1024);
		}
		else
		{
			failureHitCol = Physics.BoxCastAll(BoxCastCol.transform.position, BoxCastCol.transform.localScale.x * BoxCastCol.size / 8f, BoxCastCol.transform.up, BoxCastCol.transform.rotation, failureCheckDis, 1024);
		}
		if (hitCol.Length != 0)
		{
			RaycastHit[] array = hitCol;
			foreach (RaycastHit raycastHit in array)
			{
				OnTriggerEnterByBoxCast(raycastHit.collider);
			}
		}
		if (failureHitCol.Length != 0)
		{
			RaycastHit[] array = failureHitCol;
			foreach (RaycastHit raycastHit2 in array)
			{
				OnTriggerEnterByBoxCastFailure(raycastHit2.collider);
			}
		}
		if (!CheckWayObj)
		{
			return;
		}
		if (LineHapticOn)
		{
			if (Physics.CheckBox(Col.transform.position, Col.transform.localScale.x * Col.size / 2f * WayObjAddScale, Col.transform.rotation, 16))
			{
				GameManagerNew.instance.CurPlayer.StartHandHaptic(m_WandColor == csBeatItemColor.LBlack, HapticStrength, HapticLastTime);
			}
			else
			{
				GameManagerNew.instance.CurPlayer.StartHandHaptic(m_WandColor == csBeatItemColor.LBlack, 0f, 0f);
			}
		}
		if (HapticTimer > 0f)
		{
			HapticTimer -= Time.deltaTime;
			HapticStrength -= Time.deltaTime * HapticStrengthOri / (HapticLastTime * 1.1f) * 0.4f;
			return;
		}
		HapticStrength = 0f;
		if (LineHapticOn && m_WandColor == csBeatItemColor.LBlack)
		{
			LineHapticOn = false;
			GameManagerNew.instance.CurPlayer.StartHandHaptic(isL: true, 0f, 0f);
		}
		if (LineHapticOn && m_WandColor == csBeatItemColor.RWhite)
		{
			LineHapticOn = false;
			GameManagerNew.instance.CurPlayer.StartHandHaptic(isL: false, 0f, 0f);
		}
	}

	public bool CheckDirectionObj(Vector3 handVelocity, Transform direction)
	{
		if (Vector3.Angle(handVelocity, direction.up) < csGameSettings.DirAngleOffset)
		{
			return true;
		}
		return false;
	}

	public void IsFire(int fireCount)
	{
		if (!CheckWayObj && fireState != fireCount)
		{
			fireState = fireCount;
			switch (fireCount)
			{
			case 0:
				gloveFireLv1.SetActive(value: false);
				gloveFireLv2.SetActive(value: false);
				break;
			case 1:
				gloveFireLv1.SetActive(value: true);
				gloveFireLv2.SetActive(value: false);
				break;
			case 2:
				gloveFireLv2.SetActive(value: true);
				gloveFireLv1.SetActive(value: false);
				break;
			}
		}
	}
}
public class GameData : MonoBehaviour
{
	public static GameData instance;

	public List<GameSongData> SongLevelData = new List<GameSongData>();

	public GameSongData TutorialSongDataPunch;

	public GameSongData TutorialSongDataStick;

	public GameSongData TutorialSongDataSwift;

	public List<GameSongData> AddOnSongLevelData = new List<GameSongData>();

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		GameDataSorting();
	}

	public GameSongData GetSongDataByClassID(string id)
	{
		return SongLevelData.Find((GameSongData x) => x.ClassID == id);
	}

	public void GameDataSorting()
	{
		for (int i = 0; i < SongLevelData.Count - 1; i++)
		{
			for (int j = 0; j < SongLevelData.Count - i - 1; j++)
			{
				if (SongLevelData[j].weight > SongLevelData[j + 1].weight)
				{
					GameSongData value = SongLevelData[j];
					SongLevelData[j] = SongLevelData[j + 1];
					SongLevelData[j + 1] = value;
				}
			}
		}
	}
}
public class GameManagerNew : MonoBehaviour
{
	public GAMESTATE gameState = GAMESTATE.MENUSTART;

	public csPlayer CurPlayer;

	public int[] TestEasyModeScores;

	public int[] TestNormalModeScores;

	public int[] TestHardModeScores;

	public csMusicCtrl musicCtrl;

	public AudioClip[] countDownClips;

	public AudioClip gameEndClip;

	public static GameManagerNew instance;

	public bool isBroadcastScene;

	public csGameSongPlayer SongPlayer;

	public csGameSongPlayerHintScene SongPlayerH;

	public csGameValueManager GameValueManager;

	public int lastScore;

	public int levelScore;

	public bool isGameEnd;

	public GameType gameType = GameType.None;

	private bool headColliderLock;

	public bool SkipClicked;

	public bool isSkipCoach;

	public bool isShowDownload = true;

	public float carItemsSpeedCoefficient = 1f;

	public static bool isNeverEnd;

	public int allPointsCount;

	public int losePointsCount;

	public float GameTimer;

	public string CurCoolVideoNum;

	private bool cantPause;

	public bool isShowBtn;

	public csPlayMode startPlayMode;

	private bool isStickLevel;

	public string lastTimeStr;

	private float time;

	private TimeSpan timespam;

	private Coroutine IEStartTimerCoroutine;

	public csMediaPlayerMan mediaPlayerMan;

	private bool isInGame;

	public bool isFollowDownLoading;

	private csClassDownloadData followDownloadMision;

	private csClassDownloadData thinkDownloadMision;

	private bool firstStart;

	public GameSongData CurSongData;

	public Diff curDif;

	private csClassDownloadData sportDownloadMision;

	private bool IsOptmizedDataLoaded;

	public float downloadStartTime;

	private float localHeight = 178f;

	public GameObject VREventSystem;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		isGameEnd = false;
		csTutorialSceneGameManager.isTutorial = false;
		Cursor.lockState = CursorLockMode.Locked;
	}

	public void Update()
	{
		UserInput();
	}

	private void UserInput()
	{
		if (csGameSettings.isLoading)
		{
			return;
		}
		if (gameState == GAMESTATE.FollowTime || gameState == GAMESTATE.FollowTimePause)
		{
			if (gameState == GAMESTATE.FollowTime && !mediaPlayerMan.isPause && mediaPlayerMan.CanPause)
			{
				if (CurPlayer.GetMenuBtnDown())
				{
					PauseGameInFollowTime();
				}
			}
			else if (gameState == GAMESTATE.FollowTimePause && CurPlayer.GetMenuBtnDown() && mediaPlayerMan.isPause)
			{
				ResumeGameInCaochTime();
			}
		}
		if (gameState == GAMESTATE.FollowGap)
		{
			if (CurPlayer.GetMenuBtnDown() && !cantPause)
			{
				PauseGameInFollowGap();
			}
		}
		else if (gameState == GAMESTATE.FollowGapPause && CurPlayer.GetMenuBtnDown())
		{
			ResumeGameInFollowGap();
		}
		if (gameState != GAMESTATE.INGAME && gameState != GAMESTATE.GAMEPAUSE && gameState != GAMESTATE.CoachTime && gameState != GAMESTATE.CoachTimePause && gameState != GAMESTATE.RelaxTime)
		{
			return;
		}
		if (gameState == GAMESTATE.INGAME)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				csTalkingData.Instance.SendEvent("KC03_卡关暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					$"第{SongPlayer.CurSLevelIndex}关暂停次数"
				} });
				PauseGame();
			}
		}
		else if (gameState == GAMESTATE.GAMEPAUSE)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				csTalkingData.Instance.SendEvent("KC03_卡关暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					$"第{SongPlayer.CurSLevelIndex}关继续次数"
				} });
				ResumeGame();
			}
		}
		else if (gameState == GAMESTATE.CoachTime && !mediaPlayerMan.isPause && mediaPlayerMan.CanPause)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					"热身暂停次数"
				} });
				PauseGameInCaochTime("ShowBtn");
			}
		}
		else if (gameState == GAMESTATE.CoachTime && !csIngameSwiftHint.isPause)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				csIngameSwiftHint.isPause = true;
				csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
				{
					"课程ID：" + csGameDataTransfer.currentClassID,
					"热身暂停次数"
				} });
				PauseGameInCaochTime("ShowBtn");
			}
		}
		else if (gameState == GAMESTATE.CoachTimePause && mediaPlayerMan.isPause)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				if (isShowBtn)
				{
					csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
					{
						"课程ID：" + csGameDataTransfer.currentClassID,
						"热身继续次数"
					} });
				}
				else
				{
					csTalkingData.Instance.SendEvent("KC04_冷身暂停", 1.0, new Dictionary<string, object> { 
					{
						"课程ID：" + csGameDataTransfer.currentClassID,
						"冷身继续次数"
					} });
				}
				ResumeGameInCaochTime();
			}
		}
		else if (gameState == GAMESTATE.CoachTimePause && csIngameSwiftHint.isPause)
		{
			if (CurPlayer.GetMenuBtnDown())
			{
				ResumeGameInCaochTime();
			}
		}
		else if (gameState == GAMESTATE.RelaxTime && CurPlayer.GetMenuBtnDown())
		{
			csTalkingData.Instance.SendEvent("KC04_冷身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"冷身暂停次数"
			} });
			PauseGameInCaochTime("DontShowBtn");
		}
	}

	private void PauseGame()
	{
		csSportInfoManager.instance.pauseDataRecord();
		csSportInfoManager.instance.PauseCalculateCal();
		gameState = GAMESTATE.GAMEPAUSE;
		UnActiveCurrentItems();
		SongPlayer.Pause();
		csIngameMenuManager.instance.PauseGame();
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
	}

	private void PauseGameInCaochTime(string message)
	{
		gameState = GAMESTATE.CoachTimePause;
		PauseVideo();
		if (CurSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csIngameMenuManager.instance.PauseGameInCaochTime(message);
			if (csIngameSwiftHint.isPlaying)
			{
				SongPlayer.Pause();
				csPlayer.instance.pauseUILaser(dontUse: false);
				csPlayer.instance.switchController(isSwitchToMenu: true);
			}
		}
		else
		{
			csIngameMenuManager.instance.PauseGameInCaochTime(message);
		}
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		if (message == "ShowBtn")
		{
			isShowBtn = true;
		}
		else if (message == "DontShowBtn")
		{
			isShowBtn = false;
		}
	}

	private void PauseGameInFollowTime()
	{
		csSportInfoManager.instance.pauseDataRecord();
		csSportInfoManager.instance.PauseCalculateCal();
		gameState = GAMESTATE.FollowTimePause;
		PauseVideo();
		csIngameMenuManager.instance.PauseGameInFollowTime();
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
	}

	private void PauseGameInFollowGap()
	{
		gameState = GAMESTATE.FollowGapPause;
		csIngameMenuManager.instance.PauseGameInFollowGap();
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
	}

	public void SLevelOver(bool isAllover)
	{
		csIngameTimeLineHint.instance.FadeOut();
		csIngamePowerBar.instance.FadeOut();
		csSportInfoManager.instance.stopCalculateCal();
		csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
		gameState = GAMESTATE.SLevelCountDown;
		GameValueManager.setComboFatherRotation(0f);
		csIngamePanelSLevelOver.instance.CurSongInfo.text = SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex - 1].CurLevelName + "-" + SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex - 1].CurSingerName;
		SongPlayer.Stop();
		SongPlayer.ClearSLevelData();
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		SLevelValueData sLevelValueData = new SLevelValueData();
		sLevelValueData = GameValueManager.getSlevelInfo();
		if (CurSongData.Type == ClassType.SuperGorilla)
		{
			if (!isStickLevel && SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].BeatItemList.FindIndex((csBeatItemData x) => x.m_BeatItemType == csBeatItemType.StickDirection) >= 0)
			{
				isStickLevel = true;
				csIngameMenuManager.instance.ShowSLevelResultSuperGorillaBreak(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, (int)sLevelValueData.Cal, sLevelValueData.Strength, isAllover);
				csIngameMenuManager.instance.PrepareNextLevelHint_SuperMonkey(2);
				GameValueManager.SaveSuperMonkeyLevelScore(1);
			}
			else
			{
				csIngameMenuManager.instance.ShowSLevelResult(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, (int)sLevelValueData.Cal, sLevelValueData.Strength, isAllover, isSGLevel: true);
				if (isAllover)
				{
					GameValueManager.SaveSuperMonkeyLevelScore(2);
					csIngameMenuManager.instance.PrepareNextLevelHint_SuperMonkey(3);
				}
			}
		}
		else if (CurSongData.Type == ClassType.Mix)
		{
			if (SongPlayer.CurSLevelIndex < SongPlayer.curMusicData.SingleLevelDataList.Count && startPlayMode != SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].HandPlayMode)
			{
				csIngameMenuManager.instance.ShowSLevelResult(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, (int)sLevelValueData.Cal, sLevelValueData.Strength, isAllover, isSGLevel: true);
				startPlayMode = SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].HandPlayMode;
				SongPlayer.SetLevelTypeSpeed(SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].HandPlayMode);
			}
			else
			{
				csIngameMenuManager.instance.ShowSLevelResult(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, (int)sLevelValueData.Cal, sLevelValueData.Strength, isAllover, isSGLevel: true);
			}
		}
		else
		{
			csIngameMenuManager.instance.ShowSLevelResult(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, (int)sLevelValueData.Cal, sLevelValueData.Strength, isAllover);
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{ "status", "finish" },
			{
				"accuracy",
				GameValueManager.GetCurrentStagePrecise()
			},
			{
				"real_kcal",
				GameValueManager.GetCurrentStageKCal()
			},
			{
				"goal",
				GameValueManager.GetCurrentStageScore()
			},
			{
				"strength",
				GameValueManager.GetCurrentStageStrength()
			},
			{
				"combo",
				GameValueManager.GetCurrentStageMaxCombo()
			}
		});
	}

	public void SLevelStartNext()
	{
		csSportInfoManager.instance.startCalculateCal();
		csSportInfoManager.instance.startDataRecord();
		GameValueManager.SetToNextSLevelIndex();
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			if (CurSongData.Type == ClassType.Mix)
			{
				csGameDataTransfer.playMode = instance.SongPlayer.curMusicData.SingleLevelDataList[instance.SongPlayer.CurSLevelIndex].HandPlayMode;
				csPlayer.instance.HandItemMan.InitItemOnHand(instance.SongPlayer.curMusicData.SingleLevelDataList[instance.SongPlayer.CurSLevelIndex].HandPlayMode);
			}
			csEnvironmentManager.instance.ChangeEnvInGame(SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedLevelSkyboxName, SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedSkyboxInfoID);
			csEnvironmentManager.instance.ChangeEnvInGame(SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedLevelSkyboxName, SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedSkyboxInfoID, CurSongData.ClassFeatures.Contains(ClassFeature.Swift));
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
			{
			});
			gameState = GAMESTATE.INGAME;
			SongPlayer.StartPlay(isStart: true);
			csPlayer.instance.ResetRotation(isReset: false);
			csPlayer.instance.switchController(isSwitchToMenu: false);
			csPlayer.instance.pauseUILaser(dontUse: true);
			csIngameTimeLineHint.instance.FadeIn();
			if (CurSongData.TypeInHand == csPlayMode.Boxing && CurSongData.Type == ClassType.Sport)
			{
				csIngamePowerBar.instance.FadeIn();
			}
		}, 2.5f);
		csIngamePanelSLevelOver.instance.Close();
		csByteEventTracking.Instance.stage_Header.SetStage(StageType.fitness, SongPlayer.CurSLevelIndex + 2);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_start, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			}
		});
	}

	private void OnEnvDownloadDone()
	{
	}

	public void GameOver(bool toEnd)
	{
		csGameDataTransfer.playMode = csPlayMode.Menu;
		CurPlayer.switchController(isSwitchToMenu: false);
		gameState = GAMESTATE.GAMEEND;
		if (IEStartTimerCoroutine != null)
		{
			StopCoroutine(IEStartTimerCoroutine);
		}
		SongPlayer.Stop();
		SongPlayer.ClearData();
		csIngamePanelSLevelOver.instance.Close();
		StartCoroutine(StartRelax());
	}

	public void StartSuperGorillaFollow()
	{
		csGameDataTransfer.playMode = csPlayMode.Menu;
		StartCoroutine(WaitToChange("FollowScene"));
	}

	public void BackToMain()
	{
		csPlayer.instance.SetHeadDownHint(flag: false);
		GameValueManager.ResetScore();
		gameState = GAMESTATE.MENUSTART;
		StopAllCoroutines();
		csIngameTimeLineHint.instance.FadeOut();
		GameValueManager.isBoxingFire?.Invoke(0);
		GameValueManager.setComboFatherRotation(0f);
		csIngamePowerBar.instance.FadeOut();
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			if ((bool)csPlayer.instance.SwiftContrl)
			{
				csPlayer.instance.SwiftContrl.OpenPlayerIK(isOpen: false);
			}
			XRSettings.eyeTextureResolutionScale = csPlayerRigLoader.MenuResScale;
			csEnvironmentManager.instance.ChangeEnvInMain();
			csGameDataTransfer.playMode = csPlayMode.Menu;
			CurPlayer.switchController(isSwitchToMenu: false);
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
			{
			});
			csMainMenuManager.instance.OpenMainPanel();
			csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
			csLevelChoosePanel.instance.tagsx5.SetActive(value: true);
			long classHistorySum = csCloudStorage.instance.GetClassHistorySum();
			csLevelChoosePanel.instance.scoreRankPanel.Init((int)classHistorySum);
			csLevelChoosePanel.instance.GoBackToMain();
			csPlayer.instance.StartMR(isON: false);
		}, 2.5f);
		SongPlayer.Stop();
		SongPlayer.ClearData();
		csIngameMenuManager.instance.ClosePanel();
	}

	public void ResumeGame()
	{
		csSportInfoManager.instance.ResumeCalculateCal();
		csSportInfoManager.instance.startDataRecord();
		gameState = GAMESTATE.CountDown;
		csIngameMenuManager.instance.ResumeGame();
		ActiveCurrentItems();
		StartCoroutine(CountDownFromResume());
	}

	public void ResumeGameInFollowGap()
	{
		csSportInfoManager.instance.ResumeCalculateCal();
		csSportInfoManager.instance.startDataRecord();
		gameState = GAMESTATE.FollowGap;
		csIngameMenuManager.instance.ResumeGame();
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameFollowGap);
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
	}

	public void ResumeGameInCaochTime()
	{
		if (gameState == GAMESTATE.FollowTimePause)
		{
			csSportInfoManager.instance.ResumeCalculateCal();
			csSportInfoManager.instance.startDataRecord();
			gameState = GAMESTATE.FollowTime;
		}
		else
		{
			gameState = GAMESTATE.CoachTime;
		}
		ActiveCurrentItems();
		if (CurSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csIngameSwiftHint.isPause = false;
			csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: false);
			csIngameMenuManager.instance.ResumeGameSwift();
			if (csIngameSwiftHint.isPlaying)
			{
				SongPlayer.OnBeforResume();
				SongPlayer.Resume();
				csPlayer.instance.switchController(isSwitchToMenu: false);
			}
		}
		else
		{
			csIngameMenuManager.instance.ResumeGame();
			mediaPlayerMan.resumePlay();
		}
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
	}

	private IEnumerator CountDownFromResume()
	{
		yield return null;
		SongPlayer.OnBeforResume();
		csIngameMenuManager.instance.ResumeGame();
		SongPlayer.Resume();
		gameState = GAMESTATE.INGAME;
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
	}

	public int GetLastMinutes()
	{
		return (int)(time / 60f);
	}

	private IEnumerator SetGamingTime()
	{
		while (!isGameEnd)
		{
			if (gameState == GAMESTATE.INGAME)
			{
				time += Time.unscaledDeltaTime;
				timespam = TimeSpan.FromSeconds(time);
				lastTimeStr = string.Format("{0}:{1}:{2}", timespam.Hours.ToString("D2"), timespam.Minutes.ToString("D2"), timespam.Seconds.ToString("D2"));
				csIngameMenuManager.instance.SetTime(lastTimeStr);
			}
			yield return new WaitForEndOfFrame();
		}
	}

	public void PlayHaptics(AudioClip clip, HandType type)
	{
	}

	public void AddScore(int v)
	{
		lastScore = levelScore;
		levelScore += v;
		csIngameMenuManager.instance.SetScoreLabel(levelScore.ToString());
	}

	public void GameEnd()
	{
		AudioSource.PlayClipAtPoint(gameEndClip, Vector3.zero, 0.9f);
		PlayHaptics(gameEndClip, HandType.FIT);
		gameState = GAMESTATE.GAMEEND;
		UnActiveCurrentItems();
		csIngameMenuManager.instance.HideMenu();
		musicCtrl.PlayMenuBGM(isended: true);
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		isGameEnd = true;
	}

	private void StartTimer()
	{
		GameTimer = 0f;
		if (IEStartTimerCoroutine != null)
		{
			StopCoroutine(IEStartTimerCoroutine);
		}
		IEStartTimerCoroutine = StartCoroutine(IEStartTimer());
	}

	private IEnumerator IEStartTimer()
	{
		while (gameState != GAMESTATE.GAMEEND)
		{
			GameTimer += 0.1f;
			yield return new WaitForSeconds(0.1f);
		}
	}

	public IEnumerator OutChild(Transform parent, Transform target)
	{
		Vector3 localpos = target.localPosition;
		target.parent = base.transform;
		float waitTime = SongPlayer.SongPrepareDist / SongPlayer.beatGapDis;
		while (waitTime > 0f)
		{
			if (gameState == GAMESTATE.INGAME)
			{
				waitTime -= Time.deltaTime;
			}
			yield return new WaitForEndOfFrame();
		}
		target.parent = parent;
		target.localPosition = localpos;
	}

	public void PauseVideo()
	{
		mediaPlayerMan.pausePlay();
	}

	public void closeVideo()
	{
		mediaPlayerMan.closeVideo();
	}

	private IEnumerator StartRelax()
	{
		csByteEventTracking.Instance.stage_Header.SetStage(StageType.cooldown, CurSongData.GameSongInfoList.Count + 2);
		isSkipCoach = false;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_start, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			}
		});
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			csPlayer.instance.SetHeadDownHint(flag: true);
			csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			csPlayer.instance.ResetRotation(isReset: true);
			csMainMenuManager.instance.ClosePanel();
			gameState = GAMESTATE.RelaxTime;
			csPlayer.instance.pauseUILaser(dontUse: true);
			csPlayer.instance.switchController(isSwitchToMenu: false);
			mediaPlayerMan.screen.SetActive(value: true);
			csEnvironmentManager.instance.ChangeEnvInWarmUpOrCoolDown();
			if (CurSongData.ClassFeatures.Contains(ClassFeature.AddOn))
			{
				SkipClicked = true;
			}
			mediaPlayerMan.setLocalVideoByIndex(CurSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurSongData.ClassID, VideoType.CoolDown));
		});
		while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
		});
		mediaPlayerMan.startPlay(0.0, CurSongData);
		mediaPlayerMan.SetAudioPercentByData(CurSongData.CoolDownVideoVol);
		float timer = 0f;
		float allTime = mediaPlayerMan.getMediaLength();
		bool isDisplayHint = false;
		while (gameState != GAMESTATE.MENUSTART && !SkipClicked && timer <= allTime + 1.5f)
		{
			if (!mediaPlayerMan.isPause)
			{
				timer += Time.deltaTime;
				if (!isDisplayHint && timer >= 1f)
				{
					StartCoroutine(csIngameMenuManager.instance.DisplayCoachTimeHint());
					isDisplayHint = true;
				}
			}
			yield return null;
		}
		mediaPlayerMan.closeVideo();
		csPlayer.instance.SetHeadDownHint(flag: false);
		SkipClicked = false;
		if (gameState != GAMESTATE.MENUSTART)
		{
			gameState = GAMESTATE.GAMEEND;
			SLevelValueData sLevelValueData = new SLevelValueData();
			List<SLevelValueData> finalResultLevelData = GameValueManager.getFinalResultLevelData();
			UnityEngine.Debug.LogError("tmpDataList:" + finalResultLevelData.Count);
			for (int i = 0; i < finalResultLevelData.Count; i++)
			{
				sLevelValueData.Cal += finalResultLevelData[i].Cal;
				sLevelValueData.Score += finalResultLevelData[i].Score;
				sLevelValueData.Strength += finalResultLevelData[i].Strength;
				sLevelValueData.Precise += finalResultLevelData[i].Precise;
				sLevelValueData.Hit += finalResultLevelData[i].Hit;
				sLevelValueData.maxHit += finalResultLevelData[i].maxHit;
			}
			sLevelValueData.Precise /= finalResultLevelData.Count;
			sLevelValueData.Strength /= finalResultLevelData.Count;
			bool isBoxing = false;
			float num = 0f;
			if (CurSongData.TypeInHand == csPlayMode.Boxing && CurSongData.Type == ClassType.Sport)
			{
				isBoxing = true;
				List<float> finalPunchSpeedData = GameValueManager.getFinalPunchSpeedData();
				for (int j = 0; j < finalPunchSpeedData.Count; j++)
				{
					num += finalPunchSpeedData[j];
				}
				num /= (float)finalPunchSpeedData.Count;
			}
			csIngameMenuManager.instance.SetAndShowResult();
			csIngameMenuManager.instance.finalResultPanel.setSlevelInfo(finalResultLevelData, CurSongData.Type != ClassType.Mix);
			csIngameMenuManager.instance.finalResultPanel.ShowAllData(sLevelValueData, sLevelValueData.Precise, sLevelValueData.Score, sLevelValueData.Cal, sLevelValueData.Strength, sLevelValueData.TotalCombo, 3000 * finalResultLevelData.Count, csGameDataTransfer.currentClassID, isBoxing, num);
			csCloudStorage.instance.SetClassAsClassHistory(csGameDataTransfer.currentClassID, ClassHistoryState.Finished);
			csCloudStorage.instance.AddNewBeheaviorData(BeheaviorType.ClassFinishNum, 1, csGameDataTransfer.currentClassID);
			csCloudStorage.instance.addClockInDate(null);
			csCloudStorage.instance.UpdateHistorySum(csGameDataTransfer.currentClassID, sLevelValueData.Score);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"status",
					isSkipCoach ? "jump" : "finish"
				},
				{ "accuracy", 0 },
				{ "real_kcal", 0 },
				{ "goal", 0 },
				{ "strength", 0 },
				{ "combo", 0 }
			});
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"duration",
					(int)(GameTimer * 1000f)
				},
				{ "status", "success" },
				{
					"goal",
					GameValueManager.GetCurrentTotalScore()
				},
				{
					"real_kcal",
					GameValueManager.GetCurrentTotalKCal()
				}
			});
		}
		csIngameMenuManager.instance.coachTimeTips.Body.SetActive(value: false);
		csPlayer.instance.pauseUILaser(dontUse: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
	}

	private void StartFollowWithDownload(List<FollowVideoData> fdataList, string classId)
	{
		gameState = GAMESTATE.FollowTime;
		csMainMenuManager.instance.ClosePanel();
		List<FollowVideoData> list = new List<FollowVideoData>();
		for (int i = 0; i < fdataList.Count; i++)
		{
			FollowVideoData followVideoData = new FollowVideoData();
			followVideoData.VideoName = fdataList[i].VideoName;
			followVideoData.GapTime = fdataList[i].GapTime;
			followVideoData.VideoScale = fdataList[i].VideoScale;
			followVideoData.VideoOffset = fdataList[i].VideoOffset;
			followVideoData.CoachEuler = fdataList[i].CoachEuler;
			list.Add(followVideoData);
			list[list.Count - 1].VideoName += csCloudSettings.GetClassVideoVersion(classId, VideoType.Follow);
		}
		followDownloadMision = csVedioDownloadManager.instance.CreateAndStartClassMision(list, classId, FollowDownloaCallBack, delegate
		{
		}, OnDownloadProgressCallBack, isPlaying: true);
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		csMainMenuManager.instance.downloadPanel.AddExitCallBack(OnFollowMisionCanncel);
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "SoloFollow");
		csGameDataTransfer.playMode = csPlayMode.Menu;
	}

	private void OnFollowMisionCanncel()
	{
		if (followDownloadMision != null)
		{
			csClassDownloadData obj = followDownloadMision;
			obj.classMisionCompletCallBack = (Action)Delegate.Remove(obj.classMisionCompletCallBack, new Action(FollowDownloaCallBack));
			csClassDownloadData obj2 = followDownloadMision;
			obj2.classMisionProgressCallBack = (Action<double>)Delegate.Remove(obj2.classMisionProgressCallBack, new Action<double>(OnDownloadProgressCallBack));
		}
		followDownloadMision = null;
		BackToMain();
	}

	private void OnThinkMisionCanncel()
	{
		if (thinkDownloadMision != null)
		{
			csClassDownloadData obj = thinkDownloadMision;
			obj.classMisionCompletCallBack = (Action)Delegate.Remove(obj.classMisionCompletCallBack, new Action(FollowDownloaCallBack));
			csClassDownloadData obj2 = thinkDownloadMision;
			obj2.classMisionProgressCallBack = (Action<double>)Delegate.Remove(obj2.classMisionProgressCallBack, new Action<double>(OnDownloadProgressCallBack));
		}
		thinkDownloadMision = null;
		BackToMain();
	}

	private void FollowDownloaCallBack()
	{
		StartCoroutine(WaitToChange("FollowScene"));
	}

	private IEnumerator WaitToChange(string SceneName)
	{
		if (csGameSettings.IsMRCPackage && SceneName != "TutorialScene")
		{
			yield return new WaitUntil(() => csMrcPanel.instance.IsStart);
		}
		yield return new WaitForSeconds(0.5f);
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			if (SceneName != null)
			{
				switch (SceneName)
				{
				case "FollowScene":
					csGameSettings.currGameScene = GameScene.Follow;
					break;
				case "ThinkingScene":
					csGameSettings.currGameScene = GameScene.Thinking;
					break;
				case "TutorialScene":
					csGameSettings.currGameScene = GameScene.Tutorial;
					break;
				}
			}
			SceneManager.LoadScene(SceneName);
		});
	}

	private void ThinkingDownloaCallBack()
	{
		StartCoroutine(WaitToChange("ThinkingScene"));
	}

	private void OnDownloadProgressCallBack(double progress)
	{
		csMainMenuManager.instance.downloadPanel.SetSliderValue((float)progress);
	}

	private IEnumerator StartCoachTime(GameSongData gameSongData)
	{
		csByteEventTracking.Instance.stage_Header.SetStage(StageType.warmup, 1);
		isSkipCoach = false;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_start, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			}
		});
		if (!SkipClicked)
		{
			if (gameSongData.Type == ClassType.SuperGorilla)
			{
				mediaPlayerMan.setLocalVideoByIndex(gameSongData.WarmUpOrFollowVideoNum + "_V2");
			}
			else
			{
				mediaPlayerMan.setLocalVideoByIndex(gameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(gameSongData.ClassID, VideoType.WarmUp));
			}
			csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
			{
				yield return new WaitForSeconds(0.5f);
			}
			mediaPlayerMan.screen.SetActive(value: true);
			csMainMenuManager.instance.ClosePanel();
			csMainMenuManager.instance.CloseMainPanel();
			csPlayer.instance.pauseUILaser(dontUse: true);
			csPlayer.instance.switchController(isSwitchToMenu: false);
			yield return new WaitForSeconds(2f);
			XRSettings.eyeTextureResolutionScale = csPlayerRigLoader.GameResScale;
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				mediaPlayerMan.startPlay(0.0, gameSongData);
				mediaPlayerMan.SetAudioPercentByData(CurSongData.WarmUpVideoVol);
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
				{
				}, 1f);
			}, 1f);
			float timer = 0f;
			float allTime = mediaPlayerMan.getMediaLength();
			gameState = GAMESTATE.CoachTime;
			bool isDisplayHint = false;
			while (!SkipClicked && timer <= allTime + 1.5f)
			{
				if (!mediaPlayerMan.isPause)
				{
					timer += Time.deltaTime;
				}
				if (!isDisplayHint && timer >= 1f)
				{
					StartCoroutine(csIngameMenuManager.instance.DisplayCoachTimeHint());
					isDisplayHint = true;
				}
				yield return null;
			}
			mediaPlayerMan.closeVideo();
			SkipClicked = false;
		}
		if (SkipClicked)
		{
			closeVideo();
			SkipClicked = false;
		}
		csIngameMenuManager.instance.coachTimeTips.Body.SetActive(value: false);
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{
				"status",
				isSkipCoach ? "jump" : "finish"
			},
			{ "accuracy", 0 },
			{ "real_kcal", 0 },
			{ "goal", 0 },
			{ "strength", 0 },
			{ "combo", 0 }
		});
	}

	private IEnumerator StartSwiftToturial(GameSongData gameSongData)
	{
		if (!SkipClicked)
		{
			csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint01");
			csMainMenuManager.instance.ClosePanel();
			csMainMenuManager.instance.CloseMainPanel();
			csPlayer.instance.switchController(isSwitchToMenu: false);
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				csEnvironmentManager.instance.ChangeEnvInGame(GameData.instance.TutorialSongDataSwift.FixedWPSkyboxName);
				XRSettings.eyeTextureResolutionScale = csPlayerRigLoader.GameResScale;
				csIngameMenuManager.instance.OpenPanel(PanelType.InGameSwiftHint);
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
				{
				}, 1f);
			}, 1f);
			gameState = GAMESTATE.CoachTime;
			while (!SkipClicked)
			{
				yield return null;
			}
			SkipClicked = false;
		}
		if (SkipClicked)
		{
			SkipClicked = false;
		}
		csIngameMenuManager.instance.coachTimeTips.Body.SetActive(value: false);
		csPlayer.instance.pauseUILaser(dontUse: true);
		csPlayer.instance.switchController(isSwitchToMenu: false);
	}

	public IEnumerator StartSwiftMusicGame(csMusicPrefabOptmizedData musicPrefabOptmizedData)
	{
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: false);
		csPlayer.instance.switchController(isSwitchToMenu: false);
		SongPlayer.CreatBeat(musicPrefabOptmizedData);
		SongPlayer.StartPlay(isStart: true);
		while (csIngameSwiftHint.isPlaying)
		{
			yield return null;
			if (SongPlayer.CurSongPlayTime > 40f)
			{
				csIngameSwiftHint.instance.CloseHint();
			}
		}
		yield return new WaitUntil(() => !csIngameSwiftHint.isPlaying);
	}

	public void StartGame(GameSongData songData)
	{
		csByteEventTracking.Instance.level_Header = new level_header(songData.ClassID + "_" + csLogin.instance.userid + "_" + DateTime.Now.ToString());
		csByteEventTracking.Instance.class_Header = new class_header(songData);
		csByteEventTracking.Instance.stage_Header = new stage_header(songData);
		csSettingPanel.HeightReset();
		csGameSettings.isLoading = true;
		csGameDataTransfer.currentClassID = songData.ClassID;
		csGameDataTransfer.curClassType = songData.Type;
		csGameDataTransfer.playMode = songData.TypeInHand;
		csPlayer.instance.SetHeadDownHint(flag: true);
		csPlayer.instance.HandHintL.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint02");
		csPlayer.instance.HandHintR.hintContent.text = csLocalizationManager.Instance.GetLocalText("HeadDownHint02");
		csGameSettings.isLoading = false;
		csPlayer.instance.switchController(isSwitchToMenu: true);
		csLevelChoosePanel.instance.playerinfotitle.SetActive(value: false);
		mediaPlayerMan.changeScreenT(songData.WarmUpVideoOffset, songData.WarmUpVideoScale, songData.WarmUpCaochEuler, songData.EyeOffsetX, songData.IsSingleEyeLevel);
		bool flag = false;
		csMainMenuManager.instance.downloadPanel.InitClassDetail(songData);
		switch (csGameDataTransfer.curClassType)
		{
		case ClassType.Sport:
			csIngameMenuManager.instance.inGameCoachPause.InitClassDetail(songData);
			csIngameMenuManager.instance.inGamePanelPause.InitClassDetail(songData);
			StartSportWithDownload(songData);
			StartTimer();
			break;
		case ClassType.Follow:
			StartCoroutine(StartFollowGameByID(songData));
			StartTimer();
			break;
		case ClassType.SuperGorilla:
			csIngameMenuManager.instance.inGameCoachPause.InitClassDetail(songData);
			csIngameMenuManager.instance.inGamePanelPause.InitClassDetail(songData);
			StartCoroutine(StartSuperGorillaGameByID(songData));
			StartTimer();
			break;
		case ClassType.Mix:
			csIngameMenuManager.instance.inGameCoachPause.InitClassDetail(songData);
			csIngameMenuManager.instance.inGamePanelPause.InitClassDetail(songData);
			StartSportWithDownload(songData);
			StartTimer();
			break;
		case ClassType.Think:
			StartCoroutine(StartThinkGameByID(songData));
			StartTimer();
			break;
		case ClassType.TutorialPunch:
		case ClassType.TutorialStick:
			StartCoroutine(StartTutorialByClassType(csGameDataTransfer.curClassType));
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.start_tutorial, new Dictionary<string, object>());
			flag = true;
			break;
		}
		if (!flag)
		{
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("level_header", csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header));
			dictionary.Add("class_header", csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header));
			if (!firstStart)
			{
				firstStart = true;
				dictionary.Add("first_gap_duration", (int)(Time.realtimeSinceStartup * 1000f));
			}
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_start, dictionary);
		}
	}

	private IEnumerator StartFollowGameByID(GameSongData sd)
	{
		gameState = GAMESTATE.FollowTime;
		StartFollowWithDownload(sd.FollowVideoDataList, sd.ClassID);
		yield return new WaitForSeconds(1f);
	}

	private IEnumerator StartSuperGorillaGameByID(GameSongData sd)
	{
		isStickLevel = false;
		CurSongData = sd;
		List<FollowVideoData> list = new List<FollowVideoData>();
		FollowVideoData followVideoData = new FollowVideoData();
		FollowVideoData followVideoData2 = new FollowVideoData();
		followVideoData.VideoName = sd.WarmUpOrFollowVideoNum + "_V2";
		followVideoData2.VideoName = sd.CoolDownVideoNum + "_V2";
		list.Add(followVideoData);
		list.Add(followVideoData2);
		for (int i = 0; i < sd.FollowVideoDataList.Count; i++)
		{
			if (CurSongData.ClassID == "300001" || CurSongData.ClassID == "300002" || CurSongData.ClassID == "300003" || CurSongData.ClassID == "300004")
			{
				FollowVideoData item = new FollowVideoData(sd.FollowVideoDataList[i].VideoName + "_V2", sd.FollowVideoDataList[i].GapTime, sd.FollowVideoDataList[i].VideoVol, sd.FollowVideoDataList[i].VideoScale, sd.FollowVideoDataList[i].VideoOffset, sd.FollowVideoDataList[i].CoachEuler);
				list.Add(item);
			}
			else
			{
				FollowVideoData item2 = new FollowVideoData(sd.FollowVideoDataList[i].VideoName + "_V1", sd.FollowVideoDataList[i].GapTime, sd.FollowVideoDataList[i].VideoVol, sd.FollowVideoDataList[i].VideoScale, sd.FollowVideoDataList[i].VideoOffset, sd.FollowVideoDataList[i].CoachEuler);
				list.Add(item2);
			}
		}
		sportDownloadMision = csVedioDownloadManager.instance.CreateAndStartClassMision(list, sd.ClassID, SportDownloaCallBackSuperGorilla, delegate
		{
		}, OnDownloadProgressCallBack, isPlaying: true);
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		csMainMenuManager.instance.downloadPanel.AddExitCallBack(OnSportMisionCanncel);
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "Sport");
		yield return new WaitForSeconds(1f);
	}

	private IEnumerator StartThinkGameByID(GameSongData sd)
	{
		StartThinkingWithDownload(sd);
		yield return null;
	}

	private IEnumerator StartTutorialByClassType(ClassType ct)
	{
		StartCoroutine(WaitToChange("TutorialScene"));
		yield return null;
	}

	private void StartThinkingWithDownload(GameSongData sd)
	{
		gameState = GAMESTATE.FollowTime;
		csMainMenuManager.instance.ClosePanel();
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		csMainMenuManager.instance.downloadPanel.AddExitCallBack(OnThinkMisionCanncel);
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "Think");
		csGameDataTransfer.playMode = csPlayMode.Menu;
		CurSongData = sd;
		List<FollowVideoData> list = new List<FollowVideoData>();
		FollowVideoData followVideoData = new FollowVideoData();
		FollowVideoData followVideoData2 = new FollowVideoData();
		followVideoData.VideoName = sd.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(sd.ClassID, VideoType.WarmUp);
		followVideoData2.VideoName = sd.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(sd.ClassID, VideoType.CoolDown);
		list.Add(followVideoData);
		list.Add(followVideoData2);
		thinkDownloadMision = csVedioDownloadManager.instance.CreateAndStartClassMision(list, sd.ClassID, ThinkingDownloaCallBack, delegate
		{
		}, OnDownloadProgressCallBack, isPlaying: true);
	}

	private void StartSportWithDownload(GameSongData sd)
	{
		CurSongData = sd;
		List<FollowVideoData> list = new List<FollowVideoData>();
		FollowVideoData followVideoData = new FollowVideoData();
		FollowVideoData followVideoData2 = new FollowVideoData();
		followVideoData.VideoName = sd.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(sd.ClassID, VideoType.WarmUp);
		followVideoData2.VideoName = sd.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(sd.ClassID, VideoType.CoolDown);
		list.Add(followVideoData);
		list.Add(followVideoData2);
		sportDownloadMision = csVedioDownloadManager.instance.CreateAndStartClassMision(list, sd.ClassID, SportDownloaCallBack, delegate
		{
		}, OnDownloadProgressCallBack, isPlaying: true);
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		csMainMenuManager.instance.downloadPanel.AddExitCallBack(OnSportMisionCanncel);
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "Sport");
	}

	private void OnSportMisionCanncel()
	{
		if (sportDownloadMision != null)
		{
			csClassDownloadData obj = sportDownloadMision;
			obj.classMisionCompletCallBack = (Action)Delegate.Remove(obj.classMisionCompletCallBack, new Action(SportDownloaCallBack));
			csClassDownloadData obj2 = sportDownloadMision;
			obj2.classMisionProgressCallBack = (Action<double>)Delegate.Remove(obj2.classMisionProgressCallBack, new Action<double>(OnDownloadProgressCallBack));
		}
		sportDownloadMision = null;
		BackToMain();
	}

	private void SportDownloaCallBack()
	{
		StartCoroutine(StartSportGameByID(CurSongData));
	}

	private IEnumerator StartSportGameByID(GameSongData sd)
	{
		if (csGameSettings.IsMRCPackage)
		{
			yield return new WaitUntil(() => csMrcPanel.instance.IsStart);
		}
		curDif = sd.Diff;
		if (!sd.ClassFeatures.Contains(ClassFeature.AddOn) && !sd.ClassFeatures.Contains(ClassFeature.Swift))
		{
			yield return StartCoachTime(sd);
		}
		else if (sd.ClassFeatures.Contains(ClassFeature.Swift))
		{
			SongPlayer.beatGapDis = 9f;
			csPlayer.instance.SwiftContrl.OpenPlayerIK(isOpen: true);
			yield return StartSwiftToturial(sd);
		}
		else
		{
			csMainMenuManager.instance.ClosePanel();
			csMainMenuManager.instance.CloseMainPanel();
			csPlayer.instance.pauseUILaser(dontUse: true);
			csPlayer.instance.switchController(isSwitchToMenu: false);
		}
		csIngameMenuManager.instance.inGameRelaxPause.isSportPause = true;
		gameState = GAMESTATE.INGAME;
		CurSongData = sd;
		csMainMenuManager.instance.ClosePanel();
		SongPlayer.SetLevelTypeSpeed(CurSongData.TypeInHand);
		musicCtrl.FadeBGMVolume(0f, 1f);
		csGameDataTransfer.playMode = CurSongData.TypeInHand;
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameGaming);
		IsOptmizedDataLoaded = false;
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csAssetLoader.instance.GetOptmizedDataByUrl(CurSongData.LevelDataUrlName, isBundleLevel: false, delegate(csMusicPrefabOptmizedData d)
			{
				IsOptmizedDataLoaded = true;
				GameValueManager.Init(d);
				SongPlayer.CreatBeat(d);
				if (CurSongData.Type == ClassType.Mix)
				{
					startPlayMode = d.SingleLevelDataList[0].HandPlayMode;
					SongPlayer.SetLevelTypeSpeed(d.SingleLevelDataList[0].HandPlayMode);
				}
			});
			StartCoroutine(ChangeWaitForPuase(delegate
			{
				if (csGameSettings.IsMRCPackage)
				{
					csEnvironmentManager.instance.ChangeEnvInGame(csGameDataTransfer.mrcSelectedEnv);
				}
				else
				{
					csEnvironmentManager.instance.ChangeEnvInGame(SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedLevelSkyboxName, SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedSkyboxInfoID, CurSongData.ClassFeatures.Contains(ClassFeature.Swift));
				}
			}));
			csPlayer.instance.StartMR(CurSongData.ClassFeatures.Contains(ClassFeature.Swift));
		});
		while (!IsOptmizedDataLoaded)
		{
			yield return new WaitForEndOfFrame();
		}
		while (gameState == GAMESTATE.GAMEPAUSE)
		{
			yield return new WaitForEndOfFrame();
		}
		csSportInfoManager.instance.startCalculateCal();
		csSportInfoManager.instance.startDataRecord(isContinue: false);
		GameValueManager.SetCurrentSLevelIndex(0);
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.ProgressBar, delegate
		{
		});
		yield return new WaitForSeconds(2f);
		while (gameState == GAMESTATE.GAMEPAUSE)
		{
			yield return new WaitForEndOfFrame();
		}
		SongPlayer.StartPlay(isStart: true);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_start, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			}
		});
	}

	private void SportDownloaCallBackSuperGorilla()
	{
		StartCoroutine(StartSportGameByIDSuperGorilla(CurSongData));
	}

	private IEnumerator StartSportGameByIDSuperGorilla(GameSongData sd)
	{
		if (csGameSettings.IsMRCPackage)
		{
			yield return new WaitUntil(() => csMrcPanel.instance.IsStart);
		}
		curDif = sd.Diff;
		yield return StartCoachTime(sd);
		gameState = GAMESTATE.INGAME;
		CurSongData = sd;
		csMainMenuManager.instance.ClosePanel();
		SongPlayer.SetLevelTypeSpeed(CurSongData.TypeInHand);
		musicCtrl.FadeBGMVolume(0f, 1f);
		csGameDataTransfer.playMode = CurSongData.TypeInHand;
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameGaming);
		IsOptmizedDataLoaded = false;
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csAssetLoader.instance.GetOptmizedDataByUrl(CurSongData.LevelDataUrlName, isBundleLevel: false, delegate(csMusicPrefabOptmizedData d)
			{
				csGameDataTransfer.playMode = d.SingleLevelDataList[0].HandPlayMode;
				IsOptmizedDataLoaded = true;
				GameValueManager.Init(d);
				SongPlayer.CreatBeat(d);
			});
			StartCoroutine(ChangeWaitForPuase(delegate
			{
				if (csGameSettings.IsMRCPackage)
				{
					csEnvironmentManager.instance.ChangeEnvInGame(csGameDataTransfer.mrcSelectedEnv);
				}
				else
				{
					csEnvironmentManager.instance.ChangeEnvInGame(SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedLevelSkyboxName, SongPlayer.curMusicData.SingleLevelDataList[SongPlayer.CurSLevelIndex].FixedSkyboxInfoID);
				}
			}));
		});
		while (!IsOptmizedDataLoaded)
		{
			yield return new WaitForEndOfFrame();
		}
		while (gameState == GAMESTATE.GAMEPAUSE)
		{
			yield return new WaitForEndOfFrame();
		}
		csSportInfoManager.instance.startCalculateCal();
		csSportInfoManager.instance.startDataRecord(isContinue: false);
		GameValueManager.SetCurrentSLevelIndex(0);
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.ProgressBar, delegate
		{
		});
		yield return new WaitForSeconds(2f);
		while (gameState == GAMESTATE.GAMEPAUSE)
		{
			yield return new WaitForEndOfFrame();
		}
		SongPlayer.StartPlay(isStart: true);
	}

	private IEnumerator ChangeWaitForPuase(Action ChangeCb)
	{
		while (gameState == GAMESTATE.GAMEPAUSE || !IsOptmizedDataLoaded)
		{
			yield return new WaitForEndOfFrame();
		}
		ChangeCb?.Invoke();
	}

	public void SetMusicAudioVolume()
	{
		musicCtrl.SetAudioVolume();
		SongPlayer.SetAudioVolume();
		mediaPlayerMan.SetAudioVolume();
	}

	public void SetEffectAudioVolume()
	{
	}

	public void SetCoachAudioVolume()
	{
		mediaPlayerMan.SetAudioVolume();
	}

	public void SetGameEnvironmentToRightHeight(float height)
	{
		_ = (height - localHeight) / localHeight;
	}

	public void StopTutorial()
	{
		ClearCurrentItems();
	}

	public void ClearCurrentItems()
	{
	}

	public void UnActiveCurrentItems()
	{
	}

	public void ActiveCurrentItems()
	{
	}

	public void UseVREventSystem(bool isUse)
	{
		VREventSystem.SetActive(isUse);
		if ((bool)csPlayer.instance)
		{
			csPlayer.instance.UILaserL.enabled = false;
			csPlayer.instance.UILaserR.enabled = false;
		}
	}
}
public class PoolObjSelfReturn : MonoBehaviour
{
	public float returnTime = 2f;

	private void OnEnable()
	{
		StartCoroutine(StartReturn());
	}

	private IEnumerator StartReturn()
	{
		yield return new WaitForSeconds(returnTime);
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}
}
public class csAudioManager : MonoBehaviour
{
	public static csAudioManager instance;

	public List<AudioClip> audioClipList = new List<AudioClip>();

	private Dictionary<string, AudioClip> m_AudioClipDic = new Dictionary<string, AudioClip>();

	private AudioSource AudioSource;

	[Header("初始音高 区间0.5-2")]
	public float PitchValue;

	[Header("递增音高 累加极值最高为2")]
	public float PitchGap;

	[Header("音高段数")]
	public int PitchNum = 8;

	private Coroutine pitchCor;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Start()
	{
		AudioSource = GetComponent<AudioSource>();
		for (int i = 0; i < audioClipList.Count; i++)
		{
			m_AudioClipDic.Add(audioClipList[i].name, audioClipList[i]);
		}
		SetAudioVolume();
	}

	public void SetAudioVolume()
	{
		AudioSource.volume = csGameSettings.SoundEffectVol;
	}

	public void playAudioByName(string name)
	{
		AudioSource.PlayOneShot(m_AudioClipDic[name], 1f);
	}

	public void playAudioByName(string name, float vol)
	{
		AudioSource.PlayOneShot(m_AudioClipDic[name], vol);
	}

	public void playAudioAtPoint(string Name, float vol, Vector3 pos)
	{
		AudioSource.PlayClipAtPoint(m_AudioClipDic[Name], pos, vol);
	}

	public AudioClip getAudioByName(string name)
	{
		return m_AudioClipDic[name];
	}

	private IEnumerator PitchPlay(string name, float vol, AudioSource ItemAudioSource)
	{
		int num = GameManagerNew.instance.GameValueManager.GetCombo() - 1;
		if (num > PitchNum - 1)
		{
			num = PitchNum - 1;
		}
		ItemAudioSource.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)num * PitchGap);
		ItemAudioSource.PlayOneShot(m_AudioClipDic[name], vol);
		yield return new WaitForSeconds(ItemAudioSource.clip.length + 0.1f);
	}

	public void PlayClipAtItem(string name, float vol, AudioSource ItemAudioSource)
	{
		if (pitchCor != null)
		{
			StopCoroutine(pitchCor);
		}
		pitchCor = StartCoroutine(PitchPlay(name, vol, ItemAudioSource));
	}
}
public class csAudioPitchShift : MonoBehaviour
{
	public AudioSource thisAss;

	[Header("初始音高 区间 0.5-2")]
	public float PitchValue;

	[Header("递增音高 累加极值最高为2")]
	public float PitchGap;

	[Header("音高段数")]
	public int PitchNum = 8;

	public List<AudioClip> audioClipList = new List<AudioClip>();

	private Dictionary<string, AudioClip> m_AudioClipDic = new Dictionary<string, AudioClip>();

	public AudioSource PitchShiftAudioSource;

	private Coroutine pitchCor;

	private void Start()
	{
		PitchShiftAudioSource = GetComponent<AudioSource>();
		for (int i = 0; i < audioClipList.Count; i++)
		{
			m_AudioClipDic.Add(audioClipList[i].name, audioClipList[i]);
		}
		SetAudioVolume();
	}

	public void SetAudioVolume()
	{
		PitchShiftAudioSource.volume = csGameSettings.SoundEffectVol;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			if (pitchCor != null)
			{
				StopCoroutine(pitchCor);
			}
			pitchCor = StartCoroutine(PitchPlay());
		}
	}

	private IEnumerator PitchPlay()
	{
		for (int i = 0; i < PitchNum; i++)
		{
			thisAss.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)i * PitchGap);
			thisAss.Play();
			yield return new WaitForSeconds(thisAss.clip.length + 0.1f);
		}
	}

	private IEnumerator playPitchAudioByName(string name)
	{
		PitchNum = GameManagerNew.instance.GameValueManager.GetCombo() - 1;
		if (PitchNum > 7)
		{
			PitchNum = 7;
		}
		for (int i = 0; i < PitchNum; i++)
		{
			PitchShiftAudioSource.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)i * PitchGap);
			PitchShiftAudioSource.PlayOneShot(m_AudioClipDic[name], csGameSettings.SoundEffectVol);
			yield return new WaitForSeconds(PitchShiftAudioSource.clip.length + 0.1f);
		}
	}

	private IEnumerator playPitchAudioByName(string name, float vol)
	{
		for (int i = 0; i < PitchNum; i++)
		{
			PitchShiftAudioSource.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)i * PitchGap);
			PitchShiftAudioSource.PlayOneShot(m_AudioClipDic[name], vol);
			yield return new WaitForSeconds(PitchShiftAudioSource.clip.length + 0.1f);
		}
	}
}
public class csAvatarCreator : MonoBehaviour
{
	public csMultiPlayer thisPlayer;

	public string _userId = "18079d36-4d8a-4c7b-9a08-d95c9c14c3400";

	public string avatarID;

	public AvatarManifestationType manifestationType = AvatarManifestationType.Full;

	public AvatarHeadShowType headShowType;

	public bool bodyCulling;

	public SnapshotLevel snapshotLevel = SnapshotLevel.FullBone;

	public JointType[] criticalJoints;

	public bool enablePlaceHolder = true;

	public bool autoStopAnimating = true;

	public bool needStartApp = true;

	public bool actionBasedControl;

	public PicoAvatar thisAvatar;

	public Transform Body;

	public bool AvatarIsReady;

	private void Start()
	{
		AvatarIsReady = false;
	}

	public void CreateAvatar(string thisUsrID, string thisAvatarID)
	{
		if (!thisPlayer.isCreatedAvatar)
		{
			thisPlayer.isCreatedAvatar = true;
			StartCoroutine(StartGenerateAvatar(thisUsrID, thisAvatarID));
		}
	}

	private IEnumerator StartGenerateAvatar(string thisUsrID, string thisAvatarID)
	{
		while (!PicoAvatarApp.isWorking || !PicoAvatarManager.isWorking || !PicoAvatarManager.instance.isReady)
		{
			yield return null;
		}
		while (Camera.main == null)
		{
			yield return null;
		}
		AvatarCapabilities avatarCapabilities = new AvatarCapabilities();
		avatarCapabilities.manifestationType = manifestationType;
		avatarCapabilities.isLocalAvatar = thisPlayer.IsLocal();
		avatarCapabilities.controlSourceType = ((!thisPlayer.IsLocal()) ? ControlSourceType.RemoteServer : ControlSourceType.LocalUser);
		avatarCapabilities.bodyCulling = bodyCulling;
		avatarCapabilities.snapshotLevel = snapshotLevel;
		avatarCapabilities.enablePlaceHolder = enablePlaceHolder;
		avatarCapabilities.autoStopAnimating = autoStopAnimating;
		if (!string.IsNullOrEmpty(thisUsrID))
		{
			_userId = thisUsrID;
		}
		if (!string.IsNullOrEmpty(thisAvatarID))
		{
			avatarID = thisAvatarID;
		}
		thisAvatar = PicoAvatarManager.instance.LoadAvatar(new AvatarLoadContext(_userId, avatarID, null, avatarCapabilities));
		while (thisAvatar == null)
		{
			yield return null;
		}
		if (thisPlayer.IsLocal())
		{
			thisAvatar.SetLayer(6);
		}
		thisAvatar.criticalJoints = criticalJoints;
		if (thisPlayer.IsLocal())
		{
			headShowType = AvatarHeadShowType.Hide;
		}
		thisAvatar.SetHeadShowType(headShowType);
		thisAvatar.entity.OnAvatarLodReady.AddListener(OnAvatarLodReady);
		Transform obj = thisAvatar.transform;
		obj.SetParent(Body);
		obj.localPosition = Vector3.zero;
		obj.localRotation = Quaternion.identity;
		obj.localScale = Vector3.one;
		while (!thisAvatar.entity.isAnyLodReady)
		{
			yield return null;
		}
		if (thisPlayer.IsLocal())
		{
			thisAvatar.SetLayer(6);
		}
		thisPlayer.StartCoroutine(thisPlayer.SendAvatarInfo());
	}

	private void OnAvatarLodReady()
	{
		AvatarIsReady = true;
	}
}
public class csComboManager : MonoBehaviour
{
	public Transform thisT;

	public TextMeshProUGUI text;

	public Animator Anim;

	public Animation particleAnimtion;

	private Color ring2Color;

	public csRanEffect ranEffect;

	private void Awake()
	{
	}

	public void FadeIn()
	{
	}

	public void setComboText(int num)
	{
		text.text = num.ToString();
	}

	public void setComboNumWithAnim(int num)
	{
		text.text = num.ToString();
	}

	public void setComboNumWithParticle(int num)
	{
		text.text = num.ToString();
		if (csGameValueManager.isFirstShowCombo)
		{
			particleAnimtion.Play("show");
			csGameValueManager.isFirstShowCombo = false;
		}
		if (num % 20 == 0)
		{
			if (num <= 100)
			{
				particleAnimtion.Play("1combo");
			}
			else
			{
				particleAnimtion.Play("100combo");
			}
		}
	}

	private IEnumerator PlayAnim()
	{
		particleAnimtion.Play("hide");
		csGameValueManager.isFirstShowCombo = true;
		yield return new WaitForSeconds(0.367f);
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public void ReturnToPool()
	{
		StartCoroutine("PlayAnim");
	}
}
public class csCreatePointManager : MonoBehaviour
{
	public GameObject ItemSpawnPoint;

	public GameObject speedLine;

	public GameObject SpawnEffect;

	public Animator ani;

	public ParticleSystem LineParticle;

	public GameObject outEmbers;

	public GameObject StickEffect;

	private bool isOpened;

	private Vector3 localpos;

	private Coroutine effectCoroutine;

	public void openSpawnPoint()
	{
		if (csGameDataTransfer.playMode == csPlayMode.Boxing)
		{
			outEmbers.SetActive(value: true);
			StickEffect.SetActive(value: false);
		}
		if (csGameDataTransfer.playMode == csPlayMode.Stick)
		{
			outEmbers.SetActive(value: false);
			StickEffect.SetActive(value: true);
		}
		ItemSpawnPoint.SetActive(value: true);
		speedLine.SetActive(value: true);
	}

	private void OnEnable()
	{
		isOpened = false;
		StartCoroutine(OpenDone());
	}

	private IEnumerator OpenDone()
	{
		yield return new WaitForSeconds(1f);
		isOpened = true;
	}

	private void Start()
	{
		localpos = speedLine.transform.localPosition;
	}

	public void closeSpawnPoint()
	{
		isOpened = false;
		ani.Play("spawnpointHide");
		LineParticle.emissionRate = 0f;
		if ((bool)GameManagerNew.instance)
		{
			GameManagerNew.instance.StartCoroutine(returnToPool());
			localpos = speedLine.transform.localPosition;
			GameManagerNew.instance.StartCoroutine(GameManagerNew.instance.OutChild(base.transform, speedLine.transform));
		}
		if ((bool)csTutorialSceneGameManager.instance)
		{
			csTutorialSceneGameManager.instance.StartCoroutine(returnToPool());
			csTutorialSceneGameManager.instance.StartCoroutine(csTutorialSceneGameManager.instance.OutChild(base.transform, speedLine.transform));
		}
	}

	public void CallReturnToPool()
	{
		ItemSpawnPoint.SetActive(value: false);
		speedLine.transform.parent = base.transform;
		speedLine.transform.localPosition = localpos;
		LineParticle.emissionRate = 1f;
		SpawnEffect.SetActive(value: false);
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	private IEnumerator returnToPool()
	{
		yield return new WaitForSeconds(0.5f);
		isOpened = false;
		ItemSpawnPoint.SetActive(value: false);
		LineParticle.emissionRate = 1f;
		SpawnEffect.SetActive(value: false);
		csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	public void SpawnItem()
	{
		if (isOpened)
		{
			if (effectCoroutine != null)
			{
				StopCoroutine(effectCoroutine);
			}
			effectCoroutine = StartCoroutine(IESpawnItem());
		}
	}

	private IEnumerator IESpawnItem()
	{
		if (!SpawnEffect.activeSelf)
		{
			SpawnEffect.SetActive(value: true);
		}
		ani.Play("spawnpointSpawn");
		yield return new WaitForSeconds(1f);
		SpawnEffect.SetActive(value: false);
	}
}
public class csEnvironmentManager : MonoBehaviour
{
	public static csEnvironmentManager instance;

	public GameObject CurEnv;

	public GameObject testEnv;

	public GameObject[] Env_Main;

	public string[] Env_GAMENames;

	public string[] EnvInfo_GAME;

	public string[] Env_CoachWarmUpNames;

	public string[] Env_CoachFollowNames;

	private int index = -1;

	public Transform DirctionT;

	public Transform PosT;

	private AudioSource[] audioPlayerList;

	public bool isTestScene;

	public string currenSceneIntroduceID;

	private string lastname;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		if (isTestScene)
		{
			ChangeEnvInMain();
		}
	}

	public void ChangeEnvInMain()
	{
		if (CurEnv != null)
		{
			UnityEngine.Object.Destroy(CurEnv);
		}
		GameObject gameObject = null;
		if (testEnv != null)
		{
			gameObject = (CurEnv = UnityEngine.Object.Instantiate(testEnv, PosT));
			audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
			SetAudioVolume();
			DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
			CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * gameObject.transform.localScale.y, 0f);
			CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
		}
		else
		{
			int num = UnityEngine.Random.Range(0, Env_Main.Length);
			gameObject = UnityEngine.Object.Instantiate(Env_Main[num], PosT);
			currenSceneIntroduceID = "SkyBoxDetail" + Env_Main[num].name;
			DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
			CurEnv = gameObject;
			audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
			SetAudioVolume();
			CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * gameObject.transform.localScale.y, 0f);
			CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
		}
	}

	public void ChangeEnvInGame(string fixedSceneName = "", string fixedSceneInterviewID = "", bool MRScene = false)
	{
		if (CurEnv != null)
		{
			Resources.UnloadUnusedAssets();
			UnityEngine.Object.Destroy(CurEnv);
		}
		GameObject original;
		if (string.IsNullOrEmpty(fixedSceneName))
		{
			int num = UnityEngine.Random.Range(0, Env_GAMENames.Length);
			original = Resources.Load(Env_GAMENames[num]) as GameObject;
			csInGameClassTips.instance.detail.text = csLocalizationManager.Instance.GetLocalText(EnvInfo_GAME[num]);
			currenSceneIntroduceID = EnvInfo_GAME[num];
			if (Env_GAMENames[num] == "105")
			{
				XRSettings.eyeTextureResolutionScale = 1f;
			}
			if (csInGameClassTips.instance.detail.text.Contains("\\n"))
			{
				csInGameClassTips.instance.detail.text = csInGameClassTips.instance.detail.text.Replace("\\n", "\n");
			}
		}
		else
		{
			original = Resources.Load(fixedSceneName) as GameObject;
			csInGameClassTips.instance.detail.text = csLocalizationManager.Instance.GetLocalText(fixedSceneInterviewID);
			currenSceneIntroduceID = fixedSceneInterviewID;
			if (csInGameClassTips.instance.detail.text.Contains("\\n"))
			{
				csInGameClassTips.instance.detail.text = csInGameClassTips.instance.detail.text.Replace("\\n", "\n");
			}
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(original, PosT);
		audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
		SetAudioVolume();
		DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
		CurEnv = gameObject;
		CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * CurEnv.transform.localScale.y, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
	}

	public void ChangeEnvInWarmUpOrCoolDown(string fixedSceneName = "")
	{
		if (CurEnv != null)
		{
			Resources.UnloadUnusedAssets();
			UnityEngine.Object.Destroy(CurEnv);
		}
		GameObject original;
		if (string.IsNullOrEmpty(fixedSceneName))
		{
			int num = UnityEngine.Random.Range(0, Env_CoachWarmUpNames.Length);
			original = Resources.Load(Env_CoachWarmUpNames[num]) as GameObject;
			currenSceneIntroduceID = "SkyBoxDetail" + Env_CoachWarmUpNames[num];
		}
		else
		{
			original = Resources.Load(fixedSceneName) as GameObject;
			currenSceneIntroduceID = "SkyBoxDetail" + fixedSceneName;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(original, PosT);
		audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
		SetAudioVolume();
		DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
		CurEnv = gameObject;
		CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * gameObject.transform.localScale.y, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
	}

	public void ChangeEnvInFollow(string fixedSceneName = "")
	{
		if (CurEnv != null)
		{
			Resources.UnloadUnusedAssets();
			UnityEngine.Object.Destroy(CurEnv);
		}
		GameObject original;
		if (string.IsNullOrEmpty(fixedSceneName))
		{
			int num = UnityEngine.Random.Range(0, Env_CoachFollowNames.Length);
			original = Resources.Load(Env_CoachFollowNames[num]) as GameObject;
			currenSceneIntroduceID = "SkyBoxDetail" + Env_CoachFollowNames[num];
		}
		else
		{
			original = Resources.Load(fixedSceneName) as GameObject;
			currenSceneIntroduceID = "SkyBoxDetail" + fixedSceneName;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(original, PosT);
		audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
		SetAudioVolume();
		DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
		CurEnv = gameObject;
		CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * gameObject.transform.localScale.y, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
	}

	public void ChangeEnvInTutorial(string fixedSceneName)
	{
		if (CurEnv != null)
		{
			Resources.UnloadUnusedAssets();
			UnityEngine.Object.Destroy(CurEnv);
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load(fixedSceneName) as GameObject, PosT);
		audioPlayerList = gameObject.GetComponentsInChildren<AudioSource>();
		SetAudioVolume();
		DirctionT = gameObject.transform.Find("CamPos").GetComponent<Transform>();
		CurEnv = gameObject;
		CurEnv.transform.localPosition = new Vector3(0f, (0f - DirctionT.localPosition.y) * gameObject.transform.localScale.y, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 360f - DirctionT.localEulerAngles.y, 0f);
	}

	public void SetAudioVolume()
	{
		if (audioPlayerList.Length != 0)
		{
			AudioSource[] array = audioPlayerList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].volume = csGameSettings.MusicVol;
			}
		}
	}

	public void SetAudioMute(bool mute)
	{
		if (audioPlayerList.Length != 0)
		{
			AudioSource[] array = audioPlayerList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].mute = mute;
			}
		}
	}
}
public class csEnvironmentManagerTest : MonoBehaviour
{
	public static csEnvironmentManagerTest instance;

	public GameObject CurEnv;

	public GameObject[] Envs;

	public Transform PosT;

	private int EnvIndex = -1;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Update()
	{
		if (csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Down, IsLeft: false))
		{
			GoNext();
		}
		if (csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Down, IsLeft: true))
		{
			GoPrev();
		}
	}

	public void GoNext()
	{
		if (CurEnv != null)
		{
			UnityEngine.Object.Destroy(CurEnv);
		}
		EnvIndex++;
		if (EnvIndex >= Envs.Length)
		{
			EnvIndex = 0;
		}
		GameObject curEnv = UnityEngine.Object.Instantiate(Envs[EnvIndex], PosT);
		CurEnv = curEnv;
		CurEnv.transform.localPosition = new Vector3(0f, -9f, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 104f, 0f);
		CurEnv.transform.localScale = Vector3.one * 0.2f;
	}

	public void GoPrev()
	{
		if (CurEnv != null)
		{
			UnityEngine.Object.Destroy(CurEnv);
		}
		EnvIndex--;
		if (EnvIndex < 0)
		{
			EnvIndex = Envs.Length - 1;
		}
		GameObject curEnv = UnityEngine.Object.Instantiate(Envs[EnvIndex], PosT);
		CurEnv = curEnv;
		CurEnv.transform.localPosition = new Vector3(0f, -9f, 0f);
		CurEnv.transform.localEulerAngles = new Vector3(0f, 104f, 0f);
		CurEnv.transform.localScale = Vector3.one * 0.2f;
	}
}
public class csGameDataTransfer : MonoBehaviour
{
	public static string currentClassID;

	public static csPlayMode playMode;

	public static ClassType curClassType;

	public static string mrcSelectedEnv;
}
public class csHand : MonoBehaviour
{
	public HandType handType;

	[HideInInspector]
	public Transform thisT;

	[HideInInspector]
	public Transform handSphere;

	public GameObject handObj;
}
public class csItemOnHandIniter : MonoBehaviour
{
	[Header("0是左 1是右")]
	public GameObject[] StickPrefabs;

	public Transform[] StickInitT;

	public Transform[] StickInitTNeo4;

	public GameObject[] BoxingPrefabs;

	public Transform[] BoxingInitT;

	public Transform[] BoxingInitTNeo4;

	public GameObject[] MenuPrefabs;

	public Transform[] MenuInitT;

	public GameObject[] FollowSwordPrefabs;

	public GameObject[] FollowBoxingPrefabs;

	public Transform[] FollowSwordT;

	public Transform[] FollowBoxingT;

	private bool isStickObjInited;

	private bool isBoxingObjInited;

	private bool isMenuObjInited;

	public Transform currentItemOnHandL;

	public Transform currentItemOnHandR;

	private void Start()
	{
		if (csGameSettings.CurrentDevice == XRDeviceType.Pico4)
		{
			StickInitT = StickInitTNeo4;
			BoxingInitT = BoxingInitTNeo4;
		}
	}

	public void InitItemOnHand()
	{
		CloseAllHandHolds();
		if ((bool)GameManagerNew.instance || (bool)csFollowSceneGameManager.instance || (bool)csMultiGameManager.instance || (bool)csTutorialSceneGameManager.instance)
		{
			switch (csGameDataTransfer.playMode)
			{
			case csPlayMode.Stick:
				if (!isStickObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(StickPrefabs[0], StickInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(StickPrefabs[1], StickInitT[1]).transform;
					isStickObjInited = true;
				}
				StickInitT[0].gameObject.SetActive(value: true);
				StickInitT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.Menu:
				if (!isMenuObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(MenuPrefabs[0], MenuInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(MenuPrefabs[1], MenuInitT[1]).transform;
					isMenuObjInited = true;
				}
				MenuInitT[0].gameObject.SetActive(value: true);
				MenuInitT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.Boxing:
				if (!isBoxingObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(BoxingPrefabs[0], BoxingInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(BoxingPrefabs[1], BoxingInitT[1]).transform;
					isBoxingObjInited = true;
				}
				if (csGameSettings.IsMRCPackage && !csMrcPanel.instance.IsPunchMeshOn)
				{
					currentItemOnHandL.Find("glove_Black").gameObject.SetActive(value: false);
					currentItemOnHandR.Find("glove_White").gameObject.SetActive(value: false);
				}
				BoxingInitT[0].gameObject.SetActive(value: true);
				BoxingInitT[1].gameObject.SetActive(value: true);
				break;
			}
		}
		if ((bool)currentItemOnHandL)
		{
			currentItemOnHandL.localPosition = Vector3.zero;
			currentItemOnHandL.localRotation = Quaternion.identity;
		}
		if ((bool)currentItemOnHandR)
		{
			currentItemOnHandR.localPosition = Vector3.zero;
			currentItemOnHandR.localRotation = Quaternion.identity;
		}
	}

	public void InitItemOnHand(csPlayMode playmode)
	{
		CloseAllHandHolds();
		if ((bool)GameManagerNew.instance || (bool)csFollowSceneGameManager.instance)
		{
			switch (playmode)
			{
			case csPlayMode.Stick:
				if (!isStickObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(StickPrefabs[0], StickInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(StickPrefabs[1], StickInitT[1]).transform;
					isStickObjInited = true;
				}
				StickInitT[0].gameObject.SetActive(value: true);
				StickInitT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.Menu:
				if (!isMenuObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(MenuPrefabs[0], MenuInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(MenuPrefabs[1], MenuInitT[1]).transform;
					isMenuObjInited = true;
				}
				MenuInitT[0].gameObject.SetActive(value: true);
				MenuInitT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.Boxing:
				if (!isBoxingObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(BoxingPrefabs[0], BoxingInitT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(BoxingPrefabs[1], BoxingInitT[1]).transform;
					isBoxingObjInited = true;
				}
				BoxingInitT[0].gameObject.SetActive(value: true);
				BoxingInitT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.FollowBoxing:
				if (!isBoxingObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(FollowBoxingPrefabs[0], FollowBoxingT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(FollowBoxingPrefabs[1], FollowBoxingT[1]).transform;
					isBoxingObjInited = true;
				}
				FollowBoxingT[0].gameObject.SetActive(value: true);
				FollowBoxingT[1].gameObject.SetActive(value: true);
				break;
			case csPlayMode.FollowSword:
				if (!isBoxingObjInited)
				{
					currentItemOnHandL = UnityEngine.Object.Instantiate(FollowSwordPrefabs[0], FollowSwordT[0]).transform;
					currentItemOnHandR = UnityEngine.Object.Instantiate(FollowSwordPrefabs[1], FollowSwordT[1]).transform;
					isBoxingObjInited = true;
				}
				FollowSwordT[0].gameObject.SetActive(value: true);
				FollowSwordT[1].gameObject.SetActive(value: true);
				break;
			}
		}
		if ((bool)currentItemOnHandL)
		{
			currentItemOnHandL.localPosition = Vector3.zero;
			currentItemOnHandL.localRotation = Quaternion.identity;
		}
		if ((bool)currentItemOnHandR)
		{
			currentItemOnHandR.localPosition = Vector3.zero;
			currentItemOnHandR.localRotation = Quaternion.identity;
		}
	}

	public void CloseAllHandHolds()
	{
		StickInitT[0].gameObject.SetActive(value: false);
		StickInitT[1].gameObject.SetActive(value: false);
		BoxingInitT[0].gameObject.SetActive(value: false);
		BoxingInitT[1].gameObject.SetActive(value: false);
		MenuInitT[0].gameObject.SetActive(value: false);
		MenuInitT[1].gameObject.SetActive(value: false);
		FollowSwordT[0].gameObject.SetActive(value: false);
		FollowSwordT[1].gameObject.SetActive(value: false);
		FollowBoxingT[0].gameObject.SetActive(value: false);
		FollowBoxingT[1].gameObject.SetActive(value: false);
	}

	public void SwitchToMenuCon()
	{
		CloseAllHandHolds();
		if (!isMenuObjInited)
		{
			currentItemOnHandL = UnityEngine.Object.Instantiate(MenuPrefabs[0], MenuInitT[0]).transform;
			currentItemOnHandR = UnityEngine.Object.Instantiate(MenuPrefabs[1], MenuInitT[1]).transform;
			isMenuObjInited = true;
		}
		MenuInitT[0].gameObject.SetActive(value: true);
		MenuInitT[1].gameObject.SetActive(value: true);
		if ((bool)currentItemOnHandL)
		{
			currentItemOnHandL.localPosition = Vector3.zero;
			currentItemOnHandL.localRotation = Quaternion.identity;
		}
		if ((bool)currentItemOnHandR)
		{
			currentItemOnHandR.localPosition = Vector3.zero;
			currentItemOnHandR.localRotation = Quaternion.identity;
		}
	}
}
public class csLoadingGameManger : MonoBehaviour
{
	public static csLoadingGameManger instance;

	public Transform PlayerHitPosT;

	private Coroutine GameplayCor;

	private bool InGaming;

	private csEditorBeatItem curitem;

	public float StickObjXDir = 0.2f;

	public float StickObjYOffset = 0.2f;

	public float CenterPosY = 1.4f;

	public PunchOffsetManager POM;

	private void Awake()
	{
		instance = this;
	}

	public void StartGame(csPlayMode rndMode)
	{
		PlayerHitPosT.SetParent(null);
		PlayerHitPosT.localScale = Vector3.one;
		PlayerHitPosT.position = new Vector3(0f, 0f, 4f + csGameSettings.PerfectHitZOffset - 0.5f);
		if (GameplayCor != null)
		{
			StopCoroutine(GameplayCor);
		}
		switch (csGameDataTransfer.playMode)
		{
		case csPlayMode.Stick:
			GameplayCor = StartCoroutine(StickPlay());
			break;
		case csPlayMode.Boxing:
			GameplayCor = StartCoroutine(PunchPlay());
			break;
		case csPlayMode.Menu:
			if (rndMode == csPlayMode.Boxing)
			{
				GameplayCor = StartCoroutine(PunchPlay());
			}
			else
			{
				GameplayCor = StartCoroutine(StickPlay());
			}
			break;
		}
	}

	private void Update()
	{
		if (InGaming && GameManagerNew.instance.CurPlayer.GetMenuBtnDown())
		{
			csMainMenuManager.instance.downloadPanel.StopMiniGame();
		}
	}

	public void StopGame()
	{
		InGaming = false;
		if (GameplayCor != null)
		{
			StopCoroutine(GameplayCor);
		}
		if ((bool)curitem)
		{
			curitem.OnItemReturnToPool();
		}
	}

	private IEnumerator PunchPlay()
	{
		csBeatItemData bdata = null;
		InGaming = true;
		while (InGaming)
		{
			int num = UnityEngine.Random.Range(0, 6);
			switch (num)
			{
			case 0:
				bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.RWhite, num, 0, 0, new List<Vector3>(), "");
				break;
			case 1:
				bdata = ((UnityEngine.Random.Range(0, 100) <= 50) ? new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.LBlack, num, 0, 0, new List<Vector3>(), "") : new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.RWhite, num, 0, 0, new List<Vector3>(), ""));
				break;
			case 2:
				bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.LBlack, num, 0, 0, new List<Vector3>(), "");
				break;
			case 3:
				bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.RWhite, num, 0, 0, new List<Vector3>(), "");
				break;
			case 4:
				bdata = ((UnityEngine.Random.Range(0, 100) <= 50) ? new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Normal, csBeatItemColor.LBlack, num, 0, 0, new List<Vector3>(), "") : new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Normal, csBeatItemColor.RWhite, num, 0, 0, new List<Vector3>(), ""));
				break;
			case 5:
				bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Direction, csBeatItemColor.LBlack, num, 0, 0, new List<Vector3>(), "");
				break;
			}
			curitem = InitBeatItemByItemData(bdata);
			while (!curitem.GetIsHit())
			{
				yield return new WaitForSeconds(0.1f);
			}
		}
	}

	private IEnumerator StickPlay()
	{
		csBeatItemData bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.StickDirection, csBeatItemColor.LBlack, 0, 0, 0, new List<Vector3>(), "");
		InGaming = true;
		List<int> UseablePosList = new List<int>();
		while (InGaming)
		{
			int AngleCase = UnityEngine.Random.Range(0, 5);
			UseablePosList.Clear();
			switch (AngleCase)
			{
			case 0:
				UseablePosList.Add(1);
				UseablePosList.Add(2);
				UseablePosList.Add(3);
				UseablePosList.Add(4);
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 45f) * Vector3.up);
				break;
			case 1:
				UseablePosList.Add(1);
				UseablePosList.Add(2);
				UseablePosList.Add(3);
				UseablePosList.Add(4);
				UseablePosList.Add(5);
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 15f) * Vector3.up);
				break;
			case 2:
				UseablePosList.Add(1);
				UseablePosList.Add(2);
				UseablePosList.Add(3);
				UseablePosList.Add(4);
				UseablePosList.Add(5);
				UseablePosList.Add(6);
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 0f) * Vector3.up);
				break;
			case 3:
				UseablePosList.Add(2);
				UseablePosList.Add(3);
				UseablePosList.Add(4);
				UseablePosList.Add(5);
				UseablePosList.Add(6);
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, -15f) * Vector3.up);
				break;
			case 4:
				UseablePosList.Add(3);
				UseablePosList.Add(4);
				UseablePosList.Add(5);
				UseablePosList.Add(6);
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, -45f) * Vector3.up);
				break;
			}
			UnityEngine.Debug.LogError("Anglecase:" + AngleCase);
			int objInitPosIndex = UseablePosList[UnityEngine.Random.Range(0, UseablePosList.Count)];
			switch (objInitPosIndex)
			{
			case 1:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 2f;
				bdata.m_BeatItemColor = csBeatItemColor.LBlack;
				break;
			case 2:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 1f;
				bdata.m_BeatItemColor = csBeatItemColor.LBlack;
				break;
			case 3:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.left * StickObjXDir;
				bdata.m_BeatItemColor = csBeatItemColor.LBlack;
				break;
			case 4:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.right * StickObjXDir;
				bdata.m_BeatItemColor = csBeatItemColor.RWhite;
				break;
			case 5:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f;
				bdata.m_BeatItemColor = csBeatItemColor.RWhite;
				break;
			case 6:
				bdata.LocalPos = Vector3.zero + Vector3.up * StickObjYOffset + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 2f;
				bdata.m_BeatItemColor = csBeatItemColor.RWhite;
				break;
			}
			bdata.LocalPos += Vector3.up * CenterPosY;
			curitem = InitBeatItemByItemData(bdata);
			while (!curitem.GetIsHit())
			{
				yield return new WaitForSeconds(0.1f);
			}
			bdata = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.StickDirection, csBeatItemColor.LBlack, 0, 0, 0, new List<Vector3>(), "");
			switch (AngleCase)
			{
			case 0:
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 225f) * Vector3.up);
				switch (objInitPosIndex)
				{
				case 1:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir;
					break;
				case 2:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir;
					break;
				case 3:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 1f;
					break;
				case 4:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 2f;
					break;
				}
				break;
			case 1:
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 195f) * Vector3.up);
				switch (objInitPosIndex)
				{
				case 1:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 1f;
					break;
				case 2:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir;
					break;
				case 3:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 0f;
					break;
				case 4:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 1f;
					break;
				case 5:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 2f;
					break;
				}
				break;
			case 2:
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 180f) * Vector3.up);
				switch (objInitPosIndex)
				{
				case 1:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 2f;
					break;
				case 2:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 1f;
					break;
				case 3:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 0f;
					break;
				case 4:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 0f;
					break;
				case 5:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 1f;
					break;
				case 6:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 2f;
					break;
				}
				break;
			case 3:
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 165f) * Vector3.up);
				switch (objInitPosIndex)
				{
				case 2:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 2f;
					break;
				case 3:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 1f;
					break;
				case 4:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 0f;
					break;
				case 5:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 0f;
					break;
				case 6:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 1f;
					break;
				}
				break;
			case 4:
				bdata.LocalRot = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, 135f) * Vector3.up);
				switch (objInitPosIndex)
				{
				case 3:
					bdata.m_BeatItemColor = csBeatItemColor.LBlack;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 2f;
					break;
				case 4:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 1f;
					break;
				case 5:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.left * StickObjXDir + Vector3.left * StickObjXDir * 2f * 0f;
					break;
				case 6:
					bdata.m_BeatItemColor = csBeatItemColor.RWhite;
					bdata.LocalPos = Vector3.zero + Vector3.up * (0f - StickObjYOffset) + Vector3.right * StickObjXDir + Vector3.right * StickObjXDir * 2f * 0f;
					break;
				}
				break;
			}
			bdata.LocalPos += Vector3.up * CenterPosY;
			curitem = InitBeatItemByItemData(bdata);
			while (!curitem.GetIsHit())
			{
				yield return new WaitForSeconds(0.1f);
			}
		}
	}

	public csEditorBeatItem InitBeatItemByItemData(csBeatItemData d)
	{
		csEditorBeatItem csEditorBeatItem2 = null;
		Vector3 zero = Vector3.zero;
		Vector3 localPos = d.LocalPos;
		switch (d.m_BeatItemType)
		{
		case csBeatItemType.StickDirection:
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Diection, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			break;
		case csBeatItemType.Direction:
			zero = GetPunchObjectPos(d.TypeIndex, d.m_BeatItemColor == csBeatItemColor.LBlack);
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Direction, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			break;
		case csBeatItemType.Defence:
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Defend, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Reward:
		{
			if (csGameDataTransfer.playMode == csPlayMode.Stick)
			{
				localPos.x -= (d.BeatTrack - 1) * 4;
			}
			else
			{
				localPos.x = csGameSettings.CenterHolePos.x + zero.x;
				localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			}
			PoolObjectType type = PoolObjectType.Rewarad_3000;
			_ = csGameSettings.currentStage;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(type, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		case csBeatItemType.Normal:
			zero = GetPunchObjectPos(4, d.m_BeatItemColor == csBeatItemColor.LBlack);
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Normal, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
		csEditorBeatItem2.thisT.SetParent(PlayerHitPosT);
		csEditorBeatItem2.thisT.localPosition = localPos;
		csEditorBeatItem2.thisT.localRotation = d.LocalRot;
		csEditorBeatItem2.InitMoveDirAndSpeed(-Vector3.forward, 3f, 0, isDownloadGame: true);
		return csEditorBeatItem2;
	}

	private Vector3 GetPunchObjectPos(int typeIndex, bool isLeft)
	{
		Vector3 result = Vector3.zero;
		switch (typeIndex)
		{
		case 0:
			result = POM.RH_LTTypeIndex0.localPosition;
			break;
		case 1:
			result = ((!isLeft) ? POM.RH_MTTypeIndex1.localPosition : POM.LH_MTTypeIndex1.localPosition);
			break;
		case 2:
			result = POM.LH_RTTypeIndex2.localPosition;
			break;
		case 3:
			result = POM.RH_LMypeIndex3.localPosition;
			break;
		case 4:
			result = Vector3.zero;
			result = ((!isLeft) ? POM.RH_MMTypeIndex4.localPosition : POM.LH_MMTypeIndex4.localPosition);
			break;
		case 5:
			result = POM.LH_RMTypeIndex5.localPosition;
			break;
		}
		return result;
	}
}
public class csMediaPlayerMan : MonoBehaviour
{
	public MediaPlayer mediaPlayer;

	public GameObject screen;

	public UpdateMultiPassStereo umps;

	public bool isPause;

	public bool CanPause;

	public GameObject CoachPlatform;

	public GameObject SuperMonkeyIcon;

	public csSubtitleManager subtitleManager;

	private bool IsSingleEye;

	public bool IsMultiScenePlayer;

	public List<string> LocalVideoList = new List<string>();

	private void Start()
	{
		SetAudioVolume();
		screen.SetActive(value: false);
		CoachPlatform.transform.localScale = Vector3.zero;
		if (!csTutorialSceneGameManager.instance)
		{
			CoachPlatform.SetActive(value: false);
		}
		screen.GetComponent<MeshRenderer>().enabled = false;
	}

	public void changeScreenT(Vector3 ScreenPos, Vector2 ScreenScale, Vector3 localEulerAngles, float eyeXoffset, bool isSingleEye)
	{
		screen.transform.localPosition = ScreenPos;
		Vector3 localScale = screen.transform.localScale;
		localScale.x = ScreenScale.x;
		localScale.y = ScreenScale.y;
		screen.transform.localScale = localScale;
		screen.transform.localEulerAngles = localEulerAngles;
		umps.SetEyeOffset(new Vector2(eyeXoffset, 0f));
		IsSingleEye = isSingleEye;
	}

	public float getMediaLength()
	{
		return (float)mediaPlayer.Info.GetDuration();
	}

	public void startPlay(double time = 0.0, GameSongData gameSongData = null)
	{
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: true);
		StartCoroutine(StartPlayVideo(time, gameSongData));
	}

	public void resumePlay()
	{
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: true);
		CoachPlatform.SetActive(value: true);
		CoachPlatform.transform.localScale = Vector3.one;
		screen.SetActive(value: true);
		screen.GetComponent<MeshRenderer>().enabled = true;
		isPause = false;
		if (IsMultiScenePlayer)
		{
			csMultiGameManager.instance.currentPlayer.OpenVidCam(isOpen: true);
		}
		else
		{
			csPlayer.instance.OpenVidCam(isOpen: true);
		}
		mediaPlayer.Play();
		CanPause = true;
	}

	public IEnumerator resumePlayInTutorial(float time)
	{
		isPause = false;
		screen.SetActive(value: true);
		screen.GetComponent<MeshRenderer>().enabled = true;
		mediaPlayer.Control.Seek(time);
		mediaPlayer.Play();
		CanPause = true;
		SetMatColor(new Color(1f, 1f, 1f, 0f));
		ChangeColor(new Color(1f, 1f, 1f, 1f), 1f, delegate
		{
		});
		yield return null;
	}

	private IEnumerator StartPlayVideo(double time, GameSongData gameSongData)
	{
		CoachPlatform.SetActive(value: true);
		CoachPlatform.transform.localScale = Vector3.one;
		if (gameSongData != null)
		{
			if (gameSongData.ClassFeatures.Contains(ClassFeature.SuperMonkey))
			{
				SuperMonkeyIcon.SetActive(value: true);
			}
			else
			{
				SuperMonkeyIcon.SetActive(value: false);
			}
		}
		screen.SetActive(value: true);
		screen.GetComponent<MeshRenderer>().enabled = true;
		isPause = false;
		mediaPlayer.Control.Seek(time);
		mediaPlayer.Play();
		if (IsMultiScenePlayer)
		{
			csMultiGameManager.instance.currentPlayer.OpenVidCam(isOpen: true);
		}
		else
		{
			csPlayer.instance.OpenVidCam(isOpen: true);
		}
		yield return new WaitForSeconds(0.5f);
		CanPause = true;
	}

	public void setVideoByIndex(string index, UnityAction OnVedioDone)
	{
		UpdateMultiPassStereo.UseStereo = true;
		mediaPlayer.CloseMedia();
		if (LocalVideoList.Contains(index))
		{
			StartCoroutine(ResourcesAsync(index, OnVedioDone, isEyeLoad: false));
		}
		else
		{
			StartCoroutine(URLAsyncDownload(index, OnVedioDone, isEyeLoad: false));
		}
		MediaHints fallbackMediaHints = mediaPlayer.FallbackMediaHints;
		fallbackMediaHints.alphaPacking = AlphaPacking.TopBottom;
		fallbackMediaHints.transparency = TransparencyMode.Transparent;
		if (IsSingleEye)
		{
			fallbackMediaHints.stereoPacking = StereoPacking.None;
		}
		else
		{
			fallbackMediaHints.stereoPacking = StereoPacking.LeftRight;
		}
		mediaPlayer.FallbackMediaHints = fallbackMediaHints;
	}

	public void TestPlayStreamingVideoByUrl(string url)
	{
		UpdateMultiPassStereo.UseStereo = true;
		mediaPlayer.CloseMedia();
		Resources.UnloadUnusedAssets();
		GC.Collect();
		MediaHints fallbackMediaHints = mediaPlayer.FallbackMediaHints;
		fallbackMediaHints.alphaPacking = AlphaPacking.TopBottom;
		fallbackMediaHints.transparency = TransparencyMode.Transparent;
		fallbackMediaHints.stereoPacking = StereoPacking.LeftRight;
		mediaPlayer.FallbackMediaHints = fallbackMediaHints;
		mediaPlayer.OpenMedia(new MediaPath(url, MediaPathType.AbsolutePathOrURL));
	}

	public void setLocalVideoByIndex(string index)
	{
		UpdateMultiPassStereo.UseStereo = true;
		mediaPlayer.CloseMedia();
		Resources.UnloadUnusedAssets();
		GC.Collect();
		string path = Application.persistentDataPath + "/VideoData/" + index + ".bytes";
		MediaHints fallbackMediaHints = mediaPlayer.FallbackMediaHints;
		fallbackMediaHints.alphaPacking = AlphaPacking.TopBottom;
		fallbackMediaHints.transparency = TransparencyMode.Transparent;
		if (IsSingleEye)
		{
			fallbackMediaHints.stereoPacking = StereoPacking.None;
		}
		else
		{
			fallbackMediaHints.stereoPacking = StereoPacking.LeftRight;
		}
		mediaPlayer.FallbackMediaHints = fallbackMediaHints;
		mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, path, autoPlay: false);
	}

	public void setVideoByIndexFollow(string index, bool useStereo = true)
	{
		UpdateMultiPassStereo.UseStereo = true;
		mediaPlayer.CloseMedia();
		string path = Application.persistentDataPath + "/VideoData/" + index + ".bytes";
		MediaHints fallbackMediaHints = mediaPlayer.FallbackMediaHints;
		fallbackMediaHints.alphaPacking = AlphaPacking.TopBottom;
		fallbackMediaHints.transparency = TransparencyMode.Transparent;
		if (IsSingleEye)
		{
			fallbackMediaHints.stereoPacking = StereoPacking.None;
		}
		else
		{
			fallbackMediaHints.stereoPacking = StereoPacking.LeftRight;
		}
		mediaPlayer.FallbackMediaHints = fallbackMediaHints;
		mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, path, autoPlay: false);
		Resources.UnloadUnusedAssets();
		GC.Collect();
	}

	private IEnumerator ResourcesAsync(string shorturl, UnityAction OnVedioDone, bool isEyeLoad)
	{
		string filePath = Application.persistentDataPath + "/VideoData/" + shorturl + ".bytes";
		byte[] resByte = null;
		if (!File.Exists(filePath))
		{
			ResourceRequest resourcesRequest = Resources.LoadAsync(shorturl);
			csEyeFadeManager.Instance.SetFillAmount(0f);
			if (csGameSettings.currGameScene == GameScene.Main)
			{
				csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
			}
			while (!resourcesRequest.isDone)
			{
				if (csGameSettings.currGameScene == GameScene.Main)
				{
					csMainMenuManager.instance.downloadPanel.SetSliderValue(resourcesRequest.progress);
				}
				csEyeFadeManager.Instance.SetFillAmount(resourcesRequest.progress);
				yield return new WaitForSecondsRealtime(0.1f);
			}
			yield return resourcesRequest;
			if (resourcesRequest.asset != null)
			{
				TextAsset textAsset = (TextAsset)resourcesRequest.asset;
				if (!Directory.Exists(Application.persistentDataPath + "/VideoData/"))
				{
					Directory.CreateDirectory(Application.persistentDataPath + "/VideoData/");
				}
				resByte = textAsset.bytes;
			}
		}
		yield return new WaitForSeconds(2f);
		if (csGameSettings.currGameScene == GameScene.Main)
		{
			csMainMenuManager.instance.downloadPanel.SetSliderValue(1f);
		}
		if (!isEyeLoad)
		{
			if (resByte != null)
			{
				File.WriteAllBytes(filePath, resByte);
			}
			OnVedioDone?.Invoke();
			mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, filePath, autoPlay: false);
			Resources.UnloadUnusedAssets();
			GC.Collect();
		}
		else
		{
			if (resByte != null)
			{
				File.WriteAllBytes(filePath, resByte);
			}
			OnVedioDone?.Invoke();
			mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, filePath, autoPlay: false);
			Resources.UnloadUnusedAssets();
			GC.Collect();
		}
	}

	public IEnumerator CheckVideoValid(string VideoName, UnityAction<bool> onCheckDone)
	{
		string uri = csAssetLoader.URLHead + "MP4Video/" + VideoName + ".mp4";
		string filePath2 = Application.persistentDataPath + "/VideoData/";
		filePath2 = filePath2 + VideoName + ".bytes";
		UnityWebRequest headRequest = UnityWebRequest.Head(uri);
		yield return headRequest.SendWebRequest();
		if (string.IsNullOrEmpty(headRequest.error))
		{
			ulong num = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
			headRequest.Dispose();
			ulong length = (ulong)new FileInfo(filePath2).Length;
			bool arg = ((length < num || length > num) ? true : false);
			onCheckDone(arg);
		}
	}

	private IEnumerator URLAsyncDownload(string shorturl, UnityAction OnVedioDone, bool isEyeLoad)
	{
		string filePath = Application.persistentDataPath + "/VideoData/" + shorturl + ".bytes";
		bool VideoDataError = false;
		if (File.Exists(filePath))
		{
			yield return StartCoroutine(CheckVideoValid(shorturl, delegate(bool x)
			{
				VideoDataError = x;
			}));
		}
		if (!File.Exists(filePath) || VideoDataError)
		{
			bool isMp4Done = false;
			bool isGetMsg = false;
			csAssetLoader.instance.LoadVideoFromURLByByte(shorturl, delegate(bool isgetmsg, bool isdone)
			{
				isGetMsg = isgetmsg;
				isMp4Done = isdone;
			});
			while (!isGetMsg)
			{
				yield return new WaitForSecondsRealtime(0.1f);
			}
			if (isMp4Done && !Directory.Exists(Application.persistentDataPath + "/VideoData/"))
			{
				Directory.CreateDirectory(Application.persistentDataPath + "/VideoData/");
			}
		}
		if (!isEyeLoad)
		{
			yield return new WaitForSeconds(2f);
		}
		if (csGameSettings.currGameScene == GameScene.Main)
		{
			csMainMenuManager.instance.downloadPanel.SetSliderValue(1f);
		}
		csEyeFadeManager.Instance.SetFillAmount(1f);
		if (!isEyeLoad)
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				OnVedioDone?.Invoke();
				mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, filePath, autoPlay: false);
				Resources.UnloadUnusedAssets();
				GC.Collect();
			});
		}
		else
		{
			OnVedioDone?.Invoke();
			mediaPlayer.OpenMedia(MediaPathType.AbsolutePathOrURL, filePath, autoPlay: false);
			Resources.UnloadUnusedAssets();
			GC.Collect();
		}
	}

	public void CloseVideoInTutorial()
	{
		mediaPlayer.Stop();
		mediaPlayer.CloseMedia();
		screen.SetActive(value: false);
	}

	public void closeVideo()
	{
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: false);
		if (IsMultiScenePlayer)
		{
			csMultiGameManager.instance.currentPlayer.OpenVidCam(isOpen: false);
		}
		else
		{
			csPlayer.instance.OpenVidCam(isOpen: false);
		}
		mediaPlayer.Stop();
		mediaPlayer.CloseMedia();
		screen.SetActive(value: false);
		CoachPlatform.SetActive(value: false);
	}

	public void pausePlay()
	{
		screen.GetComponent<MeshRenderer>().enabled = false;
		mediaPlayer.Pause();
		CanPause = false;
		isPause = true;
		CoachPlatform.SetActive(value: false);
	}

	public IEnumerator PasusePlayInTutorial()
	{
		ChangeColor(new Color(1f, 1f, 1f, 0f), 0.6f, delegate
		{
		});
		yield return new WaitForSeconds(0.65f);
		mediaPlayer.Pause();
		screen.GetComponent<MeshRenderer>().enabled = false;
		CanPause = false;
		isPause = true;
	}

	public void SetAudioVolume()
	{
		mediaPlayer.AudioVolume = csGameSettings.CoachVoiceVol;
	}

	public void SetAudioPercentByData(float percent)
	{
		mediaPlayer.AudioVolume = csGameSettings.CoachVoiceVol * percent;
	}

	public void ChangeColor(Color color, float time, Action callBack)
	{
		screen.GetComponent<MeshRenderer>().material.DOColor(color, time).OnComplete(delegate
		{
			if (callBack != null)
			{
				callBack();
			}
		});
	}

	public void SetMatColor(Color color)
	{
		screen.GetComponent<MeshRenderer>().material.color = color;
	}
}
[Serializable]
public class IDToVideoRef
{
	public string ID;

	public MediaReference MediaRef;
}
public class csModelIKLoader : MonoBehaviour
{
	public string ModelName;

	public Transform LoadT;

	public Transform HeadFollowT;

	public Transform LeftFollowT;

	public Transform RightFollowT;

	private VRIK modelIK;

	private void Start()
	{
		GameObject gameObject = null;
		gameObject = UnityEngine.Object.Instantiate(Resources.Load("Model/" + ModelName), LoadT) as GameObject;
		modelIK = gameObject.gameObject.GetComponent<VRIK>();
		modelIK.solver.spine.headTarget = HeadFollowT;
		modelIK.solver.leftArm.target = LeftFollowT;
		modelIK.solver.rightArm.target = RightFollowT;
	}

	private void Update()
	{
	}
}
public enum MultiRoomState
{
	NotStart = -1,
	FirstCountDown,
	VideoPlaying,
	VideoBreak,
	RoomOver
}
public class csMultiGameManager : MonoBehaviourPunCallbacks, IPunObservable
{
	public List<csMultiPlayer> PlayerList = new List<csMultiPlayer>();

	public static csMultiGameManager instance;

	public csMultiPlayer currentPlayer;

	public SyncRoomInfo currentRoomInfo = new SyncRoomInfo();

	public MultiRoomState CurRoomState;

	private GameSongData currentGameSongData;

	public csMultiRoomPanel roomPanel;

	public csIngamePanelFollowGap FollowGapPanel;

	private int[] book = new int[8];

	public Transform[] initPos;

	public Transform center;

	public csMediaPlayerMan mediaPlayerMan;

	public string[] picoIDs;

	public GameObject[] platforms;

	public ParticleSystem[] platformEffects;

	public ParticleSystem[] platformExitEffects;

	public float MasterPlayerStartCountDown = 15f;

	public int MinStartPlayers = 2;

	private bool userPresent = true;

	private bool LastPresent = true;

	public GameObject FakeButton;

	public GameObject AvatarApp;

	public float platformUpTime = 1f;

	private Coroutine PlayerUIRefreshCor;

	private bool isGetFirstSyncInfo;

	private string currentRoomID;

	public csPlayMode playMode;

	private GameSongData songData;

	private float Timer;

	private Coroutine UnmountedQuitCor;

	private void Awake()
	{
		if ((bool)instance)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			instance = this;
		}
	}

	private void Start()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			MasterStartCall();
		}
		else
		{
			OnClientPlayerRoomJoined();
		}
		currentGameSongData = GameData.instance.GetSongDataByClassID((string)PhotonNetwork.CurrentRoom.CustomProperties["cid"]);
		roomPanel.setClassInfo(currentGameSongData);
		roomPanel.setPlayerInfo(csCloudStorage.instance.m_PlayerInfoInPlayfab);
		csEnvironmentManager.instance.ChangeEnvInMain();
		startAvatarApp();
		RtcService.SetOnJoinRoomResultCallback(OnJoinRoom);
		RTCinit();
	}

	private void Update()
	{
		currentRoomInfo.serverTime += Time.deltaTime;
		if (PicoAvatarManager.isWorking)
		{
			PicoAvatarManager.instance.SyncNetSimulation(instance.currentRoomInfo.serverTime);
		}
		if ((bool)currentPlayer && (currentPlayer.picoL.GetMenuPressDown() || currentPlayer.picoR.GetMenuPressDown() || Input.GetKeyDown(KeyCode.L)))
		{
			if (roomPanel.isOpend)
			{
				roomPanel.Close();
				currentPlayer.pauseUILaser(dontUse: true);
			}
			else
			{
				roomPanel.Open();
				currentPlayer.pauseUILaser(dontUse: false);
			}
		}
		if (CurRoomState == MultiRoomState.RoomOver && PhotonNetwork.IsMasterClient)
		{
			Timer += Time.deltaTime;
			if (Timer >= 60f)
			{
				CurRoomState = MultiRoomState.NotStart;
				changeRoomProperties("State", (int)CurRoomState);
				if (PhotonNetwork.IsMasterClient)
				{
					MasterStartCall();
					SyncRoomInfoData();
				}
			}
		}
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (!deviceAtXRNode.isValid)
		{
			return;
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.userPresence, out userPresent);
		if (LastPresent != userPresent)
		{
			if (!userPresent)
			{
				OCHMDUnMounted();
			}
			else
			{
				OCHMDMounted();
			}
			LastPresent = userPresent;
		}
	}

	private void SyncRoomInfoData()
	{
		string text = JsonUtility.ToJson(currentRoomInfo);
		base.photonView.RPC("RpcSyncRoomInfo", RpcTarget.All, text);
	}

	private void changeRoomProperties(string proertiesName, int value)
	{
		if (PhotonNetwork.IsMasterClient)
		{
			ExitGames.Client.Photon.Hashtable customProperties = PhotonNetwork.CurrentRoom.CustomProperties;
			if (customProperties.ContainsKey(proertiesName))
			{
				customProperties[proertiesName] = value;
			}
			PhotonNetwork.CurrentRoom.SetCustomProperties(customProperties);
		}
	}

	private void SetRoomUIByRoomState(MultiRoomState rs)
	{
	}

	public void MasterStartCall()
	{
		currentRoomInfo.videoindex = 0;
		currentRoomInfo.countDownTimer = MasterPlayerStartCountDown;
		base.photonView.RPC("startCountDown", RpcTarget.All);
	}

	public override void OnLeftRoom()
	{
		base.OnLeftRoom();
		PicoAvatarManager.instance.UnloadAllAvatars();
		UnityEngine.Object.DestroyImmediate(AvatarApp.gameObject);
		RtcService.LeaveRoom(currentRoomID);
	}

	public override void OnDisconnected(DisconnectCause cause)
	{
		base.OnDisconnected(cause);
	}

	public void startAvatarApp()
	{
		StartCoroutine(IEStartAvatarApp());
	}

	private IEnumerator IEStartAvatarApp()
	{
		while (!PicoAvatarApp.isWorking)
		{
			yield return null;
		}
		PicoAvatarApp.instance.StartAvatarManager();
	}

	public void exitGame()
	{
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				csGameSettings.needReLogin = true;
				csGameSettings.dontNeedShowLogo = false;
				csGameSettings.isLogined = false;
				PhotonNetwork.Disconnect();
				csPlayfabServer.Instance.StartCoroutine(UnloadAndGotoFirst());
			});
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
		});
		csMainMenuManager.instance.OpenPanel(PanelType.disconnect);
	}

	public void exitGameBtn()
	{
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.LeaveRoom();
			}
			PhotonNetwork.Disconnect();
			csPlayfabServer.Instance.StartCoroutine(UnloadAndGotoFirst());
		});
	}

	private IEnumerator UnloadAndGotoFirst()
	{
		while (PhotonNetwork.NetworkClientState != ClientState.Disconnected)
		{
			yield return null;
		}
		Scene activeScene = SceneManager.GetActiveScene();
		CreateSceneParameters parameters = new CreateSceneParameters(LocalPhysicsMode.None);
		SceneManager.CreateScene("Fake", parameters);
		AsyncOperation asyncOperation = SceneManager.UnloadSceneAsync(activeScene, UnloadSceneOptions.UnloadAllEmbeddedSceneObjects);
		Resources.UnloadUnusedAssets();
		GC.Collect();
		bool UploadDone = false;
		asyncOperation.completed += delegate
		{
			UploadDone = true;
		};
		while (!UploadDone)
		{
			yield return null;
		}
		SceneManager.LoadScene("GameScene");
	}

	public void addPlayerToList(csMultiPlayer player, bool isMine)
	{
		if (!PlayerList.Contains(player))
		{
			PlayerList.Add(player);
			if (player.IsLocal())
			{
				player.photonView.RPC("SetMasterClientPosAndSync", RpcTarget.MasterClient);
			}
			if (isMine)
			{
				currentPlayer = player;
			}
		}
		refreshAllPlayerInfo();
	}

	[PunRPC]
	public void startCountDown()
	{
		Timer = 0f;
		FakeButton.SetActive(value: false);
		StartCoroutine(countdownToStart());
	}

	public void platformMove(float endValue, int pos, bool playEffect, TweenCallback callback = null)
	{
		platforms[pos].transform.DOLocalMoveY(endValue, platformUpTime).OnComplete(callback);
		if (endValue < 0f)
		{
			platformExitEffects[pos].gameObject.SetActive(value: true);
			platformExitEffects[pos].Play();
		}
		else
		{
			platformEffects[pos].gameObject.SetActive(value: true);
			platformEffects[pos].Play();
		}
	}

	public void setTargetPlayerPos(csMultiPlayer player)
	{
		bool flag = false;
		int num = 0;
		while (num < PlayerList.Count)
		{
			flag = false;
			for (int i = 0; i < PlayerList.Count; i++)
			{
				if (PlayerList[i].currentInitPos == num)
				{
					num++;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				break;
			}
		}
		player.currentInitPos = num;
	}

	public void refreshAllPlayerPosInfo()
	{
		for (int i = 0; i < PlayerList.Count; i++)
		{
			if (!(PlayerList[i] == null))
			{
				PlayerList[i].photonView.RPC("SyncPlayerPos", RpcTarget.All, PlayerList[i].currentInitPos);
			}
		}
	}

	public void refreshAllPlayerInfo()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			for (int i = 0; i < PlayerList.Count; i++)
			{
				if (!(PlayerList[i] == null))
				{
					string text = JsonUtility.ToJson(PlayerList[i].thisPlayerInfo);
					PlayerList[i].photonView.RPC("SyncPlayerInfo", RpcTarget.All, text, PlayerList[i].PicoID, PlayerList[i].AvatarID, PlayerList[i].photonView.Owner.NickName, PlayerList[i].AvatarUrl);
				}
			}
		}
		if (PlayerUIRefreshCor != null)
		{
			StopCoroutine(PlayerUIRefreshCor);
		}
		PlayerUIRefreshCor = StartCoroutine(RefreshPlayerRoomUIInfo());
	}

	private IEnumerator RefreshPlayerRoomUIInfo()
	{
		bool flag = false;
		while (!flag)
		{
			yield return new WaitForEndOfFrame();
			flag = true;
			for (int i = 0; i < PlayerList.Count; i++)
			{
				if (!PlayerList[i].BasicInfoIsSynced)
				{
					flag = false;
					break;
				}
			}
		}
		roomPanel.RefresPlayerUIList(PlayerList);
		PlayerUIRefreshCor = null;
	}

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		base.OnPlayerEnteredRoom(newPlayer);
		if (PhotonNetwork.IsMasterClient && (bool)base.photonView)
		{
			SyncRoomInfoData();
		}
	}

	[PunRPC]
	public void RpcSyncRoomInfo(string tmp)
	{
		SyncRoomInfo syncRoomInfo = JsonUtility.FromJson<SyncRoomInfo>(tmp);
		currentRoomInfo = syncRoomInfo;
		isGetFirstSyncInfo = true;
	}

	public void OnClientPlayerRoomJoined()
	{
		ExitGames.Client.Photon.Hashtable customProperties = PhotonNetwork.CurrentRoom.CustomProperties;
		if (customProperties.ContainsKey("State"))
		{
			CurRoomState = (MultiRoomState)(int)customProperties["State"];
		}
		StartCoroutine(SynceRoomStateAfterJoin());
	}

	private IEnumerator SynceRoomStateAfterJoin()
	{
		while (!isGetFirstSyncInfo)
		{
			yield return null;
		}
		switch (CurRoomState)
		{
		case MultiRoomState.FirstCountDown:
			startCountDown();
			break;
		case MultiRoomState.VideoPlaying:
			roomPanel.Close();
			StartCoroutine(StartFollowGameByID(currentGameSongData));
			break;
		case MultiRoomState.VideoBreak:
			roomPanel.Close();
			StartCoroutine(StartFollowGameByID(currentGameSongData));
			break;
		}
	}

	public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
	{
		base.OnRoomPropertiesUpdate(propertiesThatChanged);
		if (propertiesThatChanged.ContainsKey("State"))
		{
			CurRoomState = (MultiRoomState)(int)propertiesThatChanged["State"];
		}
	}

	private IEnumerator countdownToStart()
	{
		CurRoomState = MultiRoomState.FirstCountDown;
		changeRoomProperties("State", (int)CurRoomState);
		if (PhotonNetwork.IsMasterClient && (bool)base.photonView)
		{
			SyncRoomInfoData();
		}
		roomPanel.Close();
		FollowGapPanel.Open();
		FollowGapPanel.SetCurrentCountdownNum(currentRoomInfo.countDownTimer);
		float tempTimer = currentRoomInfo.countDownTimer;
		while (tempTimer > 0f)
		{
			tempTimer -= 0.1f;
			if (PhotonNetwork.IsMasterClient)
			{
				currentRoomInfo.countDownTimer = tempTimer;
			}
			yield return new WaitForSeconds(0.1f);
			FollowGapPanel.SetCurrentCountdownNum(tempTimer);
		}
		currentRoomInfo.countDownTimer = 0f;
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
		{
			FollowGapPanel.Close();
			CurRoomState = MultiRoomState.VideoPlaying;
			changeRoomProperties("State", (int)CurRoomState);
			if (PhotonNetwork.IsMasterClient && (bool)base.photonView)
			{
				string text = JsonUtility.ToJson(currentRoomInfo);
				base.photonView.RPC("StartGame", RpcTarget.All, text);
			}
		});
	}

	private void initRtc()
	{
		RtcService.InitRtcEngine();
		RtcService.EnableAudioPropertiesReport(2000);
		RtcRoomProfileType roomProfile = RtcRoomProfileType.Communication;
		string roomId = csUtils.StrMD5(isshort: true, PhotonNetwork.CurrentRoom.Name);
		string userId = SystemInfo.deviceUniqueIdentifier;
		Dictionary<RtcPrivilege, int> dictionary = new Dictionary<RtcPrivilege, int>();
		dictionary.Add(RtcPrivilege.PublishStream, 7200);
		dictionary.Add(RtcPrivilege.SubscribeStream, 7200);
		currentRoomID = roomId;
		RtcService.GetToken(roomId, userId, 7200, dictionary).OnComplete(delegate(Message<string> msg)
		{
			if (!msg.IsError)
			{
				string data = msg.Data;
				RtcService.JoinRoom(roomId, userId, data, roomProfile, isAutoSubscribeAudio: true);
				RtcService.StartAudioCapture();
				RtcService.PublishRoom(roomId);
			}
		});
	}

	private void OnJoinRoom(Message<RtcJoinRoomResult> msg)
	{
		if (!msg.IsError)
		{
			RtcJoinRoomResult data = msg.Data;
			if (data.ErrorCode == 0)
			{
				currentRoomID = data.RoomId;
			}
		}
	}

	public void RTCinit()
	{
		try
		{
			if (CoreService.IsInitialized())
			{
				initRtc();
				return;
			}
			CoreService.AsyncInitialize().OnComplete(delegate(Message<PlatformInitializeResult> m)
			{
				if (m.Data == PlatformInitializeResult.Success || m.Data == PlatformInitializeResult.AlreadyInitialized)
				{
					initRtc();
				}
			});
		}
		catch (Exception)
		{
			throw;
		}
	}

	[PunRPC]
	public void StartGame(string tmp)
	{
		SyncRoomInfo syncRoomInfo = JsonUtility.FromJson<SyncRoomInfo>(tmp);
		currentRoomInfo = syncRoomInfo;
		roomPanel.Close();
		StartCoroutine(StartFollowGameByID(currentGameSongData));
	}

	private IEnumerator StartFollowGameByID(GameSongData sd)
	{
		songData = sd;
		while (currentPlayer == null)
		{
			yield return new WaitForEndOfFrame();
		}
		yield return StartFollowTime(sd.FollowVideoDataList);
	}

	private IEnumerator StartFollowTime(List<FollowVideoData> fdataList)
	{
		currentPlayer.pauseUILaser(dontUse: true);
		for (int i = currentRoomInfo.videoindex; i < fdataList.Count; i++)
		{
			currentRoomInfo.videoindex = i;
			if (PhotonNetwork.IsMasterClient)
			{
				SyncRoomInfoData();
			}
			if (CurRoomState == MultiRoomState.VideoPlaying)
			{
				mediaPlayerMan.screen.SetActive(value: true);
				mediaPlayerMan.setVideoByIndexFollow(fdataList[i].VideoName + csCloudSettings.GetClassVideoVersion(currentGameSongData.ClassID, VideoType.Follow));
				mediaPlayerMan.changeScreenT(fdataList[i].VideoOffset, fdataList[i].VideoScale, fdataList[i].CoachEuler, songData.EyeOffsetX, songData.IsSingleEyeLevel);
				while (!mediaPlayerMan.mediaPlayer.Info.HasVideo())
				{
					yield return new WaitForSeconds(0.1f);
				}
				mediaPlayerMan.startPlay(currentRoomInfo.videoTime);
				mediaPlayerMan.SetAudioPercentByData(fdataList[i].VideoVol);
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
				{
				});
				float allTime = mediaPlayerMan.getMediaLength();
				float temptimer2 = currentRoomInfo.videoTime;
				while (CurRoomState == MultiRoomState.VideoPlaying && temptimer2 <= allTime + 1.5f)
				{
					if (!mediaPlayerMan.isPause)
					{
						temptimer2 += Time.deltaTime;
					}
					if (PhotonNetwork.IsMasterClient)
					{
						currentRoomInfo.videoTime = temptimer2;
					}
					yield return null;
				}
			}
			currentRoomInfo.videoTime = 0f;
			if (PhotonNetwork.IsMasterClient)
			{
				SyncRoomInfoData();
			}
			if (PhotonNetwork.IsMasterClient)
			{
				CurRoomState = MultiRoomState.VideoBreak;
				changeRoomProperties("State", (int)CurRoomState);
			}
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
			{
				mediaPlayerMan.closeVideo();
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.OnlyBlack, delegate
				{
				}, 1f);
			}, 1f);
			if (PhotonNetwork.IsMasterClient)
			{
				currentRoomInfo.countDownTimer = fdataList[i].GapTime;
			}
			yield return new WaitForSeconds(2f);
			UnityEngine.Debug.LogError("currentRoomInfo.countDownTimer:" + currentRoomInfo.countDownTimer);
			if (CurRoomState == MultiRoomState.VideoBreak && fdataList[i].GapTime != 0)
			{
				FollowGapPanel.Open();
				FollowGapPanel.SetCurrentCountdownNum(fdataList[i].GapTime);
				bool finshFade = false;
				float temptimer2 = currentRoomInfo.countDownTimer;
				while (CurRoomState == MultiRoomState.VideoBreak && temptimer2 > 0f)
				{
					yield return null;
					if (CurRoomState == MultiRoomState.VideoBreak)
					{
						temptimer2 -= Time.deltaTime;
						if (PhotonNetwork.IsMasterClient)
						{
							currentRoomInfo.countDownTimer = temptimer2;
						}
						FollowGapPanel.SetCurrentCountdownNum(temptimer2);
					}
				}
				currentRoomInfo.countDownTimer = 0f;
				csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.OnlyBlack, delegate
				{
					FollowGapPanel.Close();
					finshFade = true;
				});
				while (!finshFade)
				{
					yield return null;
				}
				yield return new WaitForSeconds(2f);
			}
			CurRoomState = MultiRoomState.VideoPlaying;
			if (PhotonNetwork.IsMasterClient)
			{
				changeRoomProperties("State", (int)CurRoomState);
			}
		}
		csCloudStorage.instance.SetClassAsClassHistory(currentGameSongData.ClassID, ClassHistoryState.Finished);
		csCloudStorage.instance.AddNewBeheaviorData(BeheaviorType.ClassFinishNum, 1, currentGameSongData.ClassID);
		csCloudStorage.instance.addClockInDate(null);
		CurRoomState = MultiRoomState.RoomOver;
		changeRoomProperties("State", (int)CurRoomState);
		currentPlayer.pauseUILaser(dontUse: false);
	}

	private IEnumerator UnMountedQuit()
	{
		yield return new WaitForSeconds(5f);
		if (PhotonNetwork.InRoom)
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				csGameSettings.needReLogin = true;
				csGameSettings.dontNeedShowLogo = false;
				csGameSettings.isLogined = false;
				PhotonNetwork.Disconnect();
				csPlayfabServer.Instance.StartCoroutine(UnloadAndGotoFirst());
			});
		}
	}

	private void OCHMDUnMounted()
	{
		if (UnmountedQuitCor == null)
		{
			UnmountedQuitCor = StartCoroutine(UnMountedQuit());
		}
	}

	private void OCHMDMounted()
	{
		if (UnmountedQuitCor != null)
		{
			StopCoroutine(UnmountedQuitCor);
			UnmountedQuitCor = null;
		}
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		base.OnPlayerLeftRoom(otherPlayer);
		UnityEngine.Debug.LogError(otherPlayer.NickName);
		int i;
		for (i = 0; i < PlayerList.Count; i++)
		{
			if (PlayerList[i] == null)
			{
				book[PlayerList[i].currentInitPos] = 0;
				PlayerList.RemoveAt(i);
			}
			else
			{
				if (!(PlayerList[i].PlayerPhotonID == otherPlayer.NickName))
				{
					continue;
				}
				platformMove(-0.5f, PlayerList[i].currentInitPos, !PlayerList[i].IsLocal(), delegate
				{
					book[PlayerList[i].currentInitPos] = 0;
					PicoAvatarManager.instance.UnloadAvatar(PlayerList[i].avatarCreator.thisAvatar);
					if (PhotonNetwork.IsMasterClient)
					{
						PhotonNetwork.Destroy(PlayerList[i].photonView);
					}
					PlayerList.RemoveAt(i);
				});
				break;
			}
		}
		refreshAllPlayerInfo();
	}

	public void SetCoachAudioVolume()
	{
		mediaPlayerMan.SetAudioVolume();
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			serializeData(currentRoomInfo.videoTime, currentRoomInfo.countDownTimer, stream, info);
		}
		else
		{
			deserializeData(stream, info);
		}
	}

	private void serializeData(float videoTime, float countDownTimer, PhotonStream stream, PhotonMessageInfo info)
	{
		stream.SendNext(videoTime);
		stream.SendNext(countDownTimer);
	}

	private void deserializeData(PhotonStream stream, PhotonMessageInfo info)
	{
		currentRoomInfo.videoTime = (float)stream.ReceiveNext();
		currentRoomInfo.countDownTimer = (float)stream.ReceiveNext();
	}
}
[Serializable]
public class SyncRoomInfo
{
	public int videoindex;

	public float videoTime;

	public float countDownTimer;

	public float serverTime;

	public SyncRoomInfo()
	{
		videoindex = 0;
		countDownTimer = 0f;
		videoTime = 0f;
		serverTime = 0f;
	}
}
public class csMultiPlayer : MonoBehaviourPunCallbacks
{
	public string PlayerNickName;

	public string PlayerPhotonID;

	public GameObject XRrig;

	public csControllerforPicoXR picoL;

	public csControllerforPicoXR picoR;

	public csControllerforPicoXR controllerHead;

	public int currentInitPos;

	public Transform Body;

	private bool AvatarIsReady;

	public PlayerInfoInPlayfab thisPlayerInfo;

	public string AvatarUrl;

	public string PicoID;

	public string AvatarID;

	public csAvatarCreator avatarCreator;

	public EditorInputDevice eid;

	public Transform head;

	public csItemOnHandIniter HandItemMan;

	private float headSpeed;

	private Vector3 lastHeadPos;

	public bool isCreatedAvatar;

	public bool BasicInfoIsSynced;

	public ViveUILaserPointer UILaserL;

	public ViveUILaserPointer UILaserR;

	public Camera VideoCam;

	private void Awake()
	{
		if (IsLocal())
		{
			StartCoroutine(initFade());
		}
	}

	private IEnumerator initFade()
	{
		if (IsLocal())
		{
			PicoAvatarApp.instance.mainCamera = head.GetComponent<Camera>();
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("Player/CanvasEyeFade")) as GameObject;
			obj.GetComponent<csEyeFadeManager>().BindToPlayer(head);
			obj.GetComponent<csEyeFadeManager>().setToBlack();
			XRrig.SetActive(IsLocal());
			csGameSettings.isLoading = true;
			yield return new WaitForSeconds(2f);
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
			{
				csGameSettings.isLoading = false;
			});
		}
	}

	private void Start()
	{
		AvatarIsReady = false;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		currentInitPos = -1;
		StartCoroutine(waitForManager());
		csSportInfoManager.instance.SetUpPlayerRig(picoL, picoR, controllerHead);
		if (IsLocal())
		{
			HandItemMan.InitItemOnHand();
		}
	}

	public IEnumerator SendAvatarInfo()
	{
		while (IsLocal() && avatarCreator.AvatarIsReady)
		{
			updateAvatarInfo();
			yield return new WaitForSeconds(0.3f);
		}
	}

	[PunRPC]
	public void SyncPlayerInfo(string tmp, string _PicoNickNam, string _PicoID, string _AvatarID, string photonID, string avatarURL)
	{
		PlayerInfoInPlayfab playerInfoInPlayfab = JsonUtility.FromJson<PlayerInfoInPlayfab>(tmp);
		thisPlayerInfo = playerInfoInPlayfab;
		PlayerNickName = _PicoNickNam;
		PlayerPhotonID = photonID;
		if (!string.IsNullOrEmpty(_PicoID))
		{
			PicoID = _PicoID;
		}
		if (!string.IsNullOrEmpty(_AvatarID))
		{
			AvatarID = _AvatarID;
		}
		AvatarUrl = avatarURL;
		BasicInfoIsSynced = true;
	}

	[PunRPC]
	public void SyncPlayerPos(int pos)
	{
		StartCoroutine(IEsetPlayerPos(pos));
	}

	[PunRPC]
	public void SetMasterClientPosAndSync()
	{
		StartCoroutine(IESetMasterClientPosAndSync());
	}

	private IEnumerator IESetMasterClientPosAndSync()
	{
		while (!csMultiGameManager.instance.PlayerList.Contains(this))
		{
			yield return null;
		}
		csMultiGameManager.instance.setTargetPlayerPos(this);
		csMultiGameManager.instance.refreshAllPlayerPosInfo();
	}

	private IEnumerator IEsetPlayerPos(int pos)
	{
		while (csMultiGameManager.instance == null)
		{
			yield return null;
		}
		currentInitPos = pos;
		if (!isCreatedAvatar)
		{
			csMultiGameManager.instance.platformMove(0f, pos, !IsLocal());
		}
		yield return new WaitForSeconds(csMultiGameManager.instance.platformUpTime);
		base.transform.position = csMultiGameManager.instance.initPos[pos].position;
		base.transform.rotation = csMultiGameManager.instance.initPos[pos].rotation;
		eid.UserId = PicoID;
		avatarCreator.CreateAvatar(PicoID, "0");
		eid.gameObject.SetActive(value: true);
		if (IsLocal())
		{
			csMultiGameManager.instance.center.localEulerAngles = Vector3.down * 45f * currentInitPos;
		}
	}

	public void pauseUILaser(bool dontUse)
	{
		UILaserL.enabled = !dontUse;
		UILaserR.enabled = !dontUse;
	}

	private void updateAvatarInfo()
	{
		double timestamp = csMultiGameManager.instance.currentRoomInfo.serverTime;
		AvatarEntity entity = avatarCreator.thisAvatar.entity;
		entity.RecordPacket(timestamp);
		byte[] data = entity.GetFixedPacketMemoryView().getData();
		base.photonView.RPC("SyncAvatarInfo", RpcTarget.Others, data);
	}

	[PunRPC]
	public void SyncAvatarInfo(byte[] data)
	{
		if ((bool)avatarCreator.thisAvatar && !IsLocal())
		{
			AvatarEntity entity = avatarCreator.thisAvatar.entity;
			MemoryView newPacketData = new MemoryView(data, shared: true);
			entity.ApplyPacket(newPacketData);
		}
	}

	public bool IsLocal()
	{
		if (base.photonView == null)
		{
			return true;
		}
		return base.photonView.IsMine;
	}

	private IEnumerator waitForManager()
	{
		while (!csMultiGameManager.instance)
		{
			yield return null;
		}
		if (IsLocal())
		{
			string text = JsonUtility.ToJson(csCloudStorage.instance.m_PlayerInfoInPlayfab);
			if (!string.IsNullOrEmpty(csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID))
			{
				PicoID = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID;
			}
			if (!string.IsNullOrEmpty(csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoAvatarID))
			{
				AvatarID = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoAvatarID;
			}
			base.photonView.RPC("SyncPlayerInfo", RpcTarget.All, text, csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName, PicoID, AvatarID, base.photonView.Owner.NickName, csPlayerPicoDataManager.instance.m_PicoAccountInfo.headIconURL);
		}
		csMultiGameManager.instance.addPlayerToList(this, base.photonView.IsMine);
	}

	public void OpenVidCam(bool isOpen)
	{
		VideoCam.enabled = isOpen;
	}
}
public class csMultiPlayerLoader : MonoBehaviourPunCallbacks
{
	public Transform StartT;

	private string PicoRig = "MultiPlayerForPicoXR";

	private string SteamRig = "MultiPlayerForSteamVR";

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(0.1f * (float)PhotonNetwork.PlayerList.Length);
		string prefabName = PicoRig;
		switch (csGameSettings.currentChannel)
		{
		case ChannelType.PicoXR:
			prefabName = PicoRig;
			break;
		case ChannelType.Steam:
			prefabName = SteamRig;
			break;
		}
		PhotonNetwork.Instantiate(prefabName, StartT.position, StartT.rotation, 0).GetComponent<csMultiPlayer>();
	}
}
public class csMusicCtrl : MonoBehaviour
{
	public AudioClip gameMenuClip;

	public AudioClip gameEndClip;

	public AudioClip[] musicList;

	public AudioSource m_BGMAudio;

	private float tempvolume;

	private void Start()
	{
		if (csGameSettings.currGameScene == GameScene.Follow)
		{
			if (csFollowSceneGameManager.instance.musicCtrl == null)
			{
				csFollowSceneGameManager.instance.musicCtrl = this;
			}
		}
		else if (csGameSettings.currGameScene == GameScene.Thinking)
		{
			if (csThinkingSceneGameManager.instance.musicCtrl == null)
			{
				csThinkingSceneGameManager.instance.musicCtrl = this;
			}
		}
		else if (GameManagerNew.instance.musicCtrl == null)
		{
			GameManagerNew.instance.musicCtrl = this;
		}
		SetAudioVolume();
		PlayMenuBGM(isended: false);
	}

	public void PlayMenuBGM(bool isended)
	{
		StopCoroutine("StartPlayBGM");
		StartCoroutine(MenuBGMAnim(isended));
	}

	private IEnumerator MenuBGMAnim(bool isended)
	{
		if (isended)
		{
			m_BGMAudio.DOFade(0f, 1f);
			yield return new WaitForSeconds(1f);
			m_BGMAudio.Stop();
		}
		m_BGMAudio.clip = (isended ? gameEndClip : gameMenuClip);
		m_BGMAudio.loop = true;
		m_BGMAudio.Play();
		m_BGMAudio.DOFade(0.5f, 1f);
	}

	public void SetBGMVolume(float value)
	{
		m_BGMAudio.volume = value;
	}

	public void PlayGameBGM()
	{
		m_BGMAudio.Stop();
		m_BGMAudio.loop = false;
		StartCoroutine("StartPlayBGM");
	}

	private IEnumerator StartPlayBGM()
	{
		for (int i = 0; i < musicList.Length; i++)
		{
			m_BGMAudio.clip = musicList[i];
			m_BGMAudio.Play();
			if (i > 0)
			{
				m_BGMAudio.DOFade(tempvolume, 1f);
			}
			yield return new WaitForSeconds(musicList[i].length - 1f);
			tempvolume = m_BGMAudio.volume;
			m_BGMAudio.DOFade(0f, 1f);
			yield return new WaitForSeconds(2f);
		}
	}

	public void FadeBGMVolume(float value, float time)
	{
		m_BGMAudio.DOFade(value, time).SetEase(Ease.Linear);
	}

	public void SpeedUpVolume()
	{
		m_BGMAudio.DOFade(csGameSettings.m_MaxBGVolume, 0.01f).OnComplete(delegate
		{
			m_BGMAudio.DOFade(csGameSettings.m_MInBGVolume, 0.01f).SetDelay(0.1f);
		});
	}

	public void SetAudioVolume()
	{
		m_BGMAudio.volume = csGameSettings.MusicVol;
	}
}
public class csPlatformEffectMgr : MonoBehaviour
{
	public static csPlatformEffectMgr instance;

	public GameObject PlatformObj;

	public GameObject PlayerPlatformSmall;

	public GameObject PlayerPlatformBig;

	public GameObject CoachPlatform;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		if ((bool)PlayerPlatformBig)
		{
			PlayerPlatformBig.transform.localScale = Vector3.one;
		}
		if ((bool)CoachPlatform)
		{
			CoachPlatform.SetActive(value: false);
		}
		InitPanelState();
	}

	private void InitPanelState()
	{
		if (csGameSettings.PlayerPlatformOn)
		{
			OpenPlatform();
		}
		else
		{
			ClosePlatform();
		}
	}

	public void ShowCoachPlatform(bool isShow)
	{
		if ((bool)CoachPlatform)
		{
			CoachPlatform.SetActive(isShow);
		}
		if (!csGameSettings.PlayerPlatformOn)
		{
			return;
		}
		if (isShow)
		{
			if ((bool)PlayerPlatformBig)
			{
				PlayerPlatformBig.SetActive(value: false);
			}
		}
		else if ((bool)PlayerPlatformBig)
		{
			PlayerPlatformBig.SetActive(value: true);
		}
	}

	public void ForceOpenPlatform(bool isOpen)
	{
		PlayerPlatformBig.SetActive(isOpen);
	}

	public void ClosePlatform()
	{
		if ((bool)PlayerPlatformBig)
		{
			PlayerPlatformBig.SetActive(value: false);
		}
		CloseEffect();
	}

	public void OpenPlatform()
	{
		if ((bool)PlayerPlatformBig)
		{
			PlayerPlatformBig.SetActive(value: true);
		}
		PlayEffect();
	}

	public void ForceSetPlayerPlatform(bool isOpen)
	{
		if (!isOpen)
		{
			PlayerPlatformBig.SetActive(isOpen);
		}
		PlayerPlatformSmall.SetActive(isOpen);
	}

	public void CloseEffect()
	{
	}

	public void PlayEffect()
	{
	}
}
public class csPlayer : MonoBehaviour
{
	public static csPlayer instance;

	public csSwiftAvatarController SwiftContrl;

	public Camera VideoCam;

	public HeadsDownHint HandHintL;

	public HeadsDownHint HandHintR;

	public Transform HeadTrackT;

	public Transform HandLTrackT;

	public Transform HandRTrackT;

	public csEyeFadeManager EyeFade;

	public GameObject AvatarObj;

	public bool welcomeOver;

	private int calibrated = -1;

	public Transform camT;

	public AudioSource countDownAs;

	public csItemOnHandIniter HandItemMan;

	public csControllerforPicoXR PicoXRControllerL;

	public csControllerforPicoXR PicoXRControllerR;

	public csControllerforPicoXR PicoXRControllerHead;

	public ViveUILaserPointer UILaserL;

	public ViveUILaserPointer UILaserR;

	public csHandTriggerRaycast PageLaserL;

	public csHandTriggerRaycast PageLaserR;

	private float OutRadius = 0.5f;

	private float InRadius = 0.2f;

	public Vector3 DisToCenter;

	private bool isArrowShow;

	private float StartStr = 0.5f;

	private int StartFreq = 30;

	private float EndStr;

	private int EndFreq;

	private float TKeep;

	private float TLoss;

	public float DefenseAngle = 30f;

	private float DefenseCosin = 1f;

	public void OpenVidCam(bool isOpen)
	{
		VideoCam.enabled = isOpen;
		SetLayerRecursively(PicoXRControllerL.gameObject, isOpen ? 7 : 0);
		SetLayerRecursively(PicoXRControllerR.gameObject, isOpen ? 7 : 0);
		SetLayerRecursively(HandHintL.gameObject, isOpen ? 7 : 0);
		SetLayerRecursively(HandHintR.gameObject, isOpen ? 7 : 0);
	}

	private static void SetLayerRecursively(GameObject go, int layer)
	{
		go.layer = layer;
		Transform transform = go.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			SetLayerRecursively(transform.GetChild(i).gameObject, layer);
		}
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		DefenseCosin = Mathf.Cos(DefenseAngle * ((float)Math.PI / 180f));
	}

	public void SetAvatarShow(bool isShow)
	{
		if ((bool)AvatarObj)
		{
			AvatarObj.SetActive(isShow);
		}
	}

	private IEnumerator Start()
	{
		camT.gameObject.SetActive(value: false);
		SetAvatarShow(isShow: false);
		yield return new WaitForEndOfFrame();
		camT.gameObject.SetActive(value: true);
		switchController(isSwitchToMenu: false);
		OutRadius = ReturnHintCircle.instance.MaxDis;
		InRadius = ReturnHintCircle.instance.MinDis;
		ReturnHintCircle.instance.ThisT.gameObject.SetActive(value: false);
		csSportInfoManager.instance.SetUpPlayerRig(PicoXRControllerL, PicoXRControllerR, PicoXRControllerHead);
		if (HandHintL != null)
		{
			HandHintL.SetCamera(camT, PicoXRControllerL.thisT);
		}
		if (HandHintR != null)
		{
			HandHintR.SetCamera(camT, PicoXRControllerR.thisT);
		}
		if (csGameSettings.currGameScene == GameScene.Follow)
		{
			csFollowSceneGameManager.instance.CurPlayer = this;
			csFollowSceneGameManager.instance.mediaPlayerMan.umps.Camera = camT.GetComponent<Camera>();
			EyeFade.setToBlack();
			welcomeOver = true;
			camT.gameObject.SetActive(value: true);
			yield break;
		}
		if (csGameSettings.currGameScene == GameScene.Thinking)
		{
			csThinkingSceneGameManager.instance.CurPlayer = this;
			csThinkingSceneGameManager.instance.mediaPlayerMan.umps.Camera = camT.GetComponent<Camera>();
			EyeFade.setToBlack();
			welcomeOver = true;
			camT.gameObject.SetActive(value: true);
			yield break;
		}
		if (csGameSettings.currGameScene == GameScene.Tutorial)
		{
			csTutorialSceneGameManager.instance.CurPlayer = this;
			csTutorialSceneGameManager.instance.mediaPlayerMan.umps.Camera = camT.GetComponent<Camera>();
			EyeFade.setToBlack();
			welcomeOver = true;
			camT.gameObject.SetActive(value: true);
			yield break;
		}
		GameManagerNew.instance.CurPlayer = this;
		GameManagerNew.instance.mediaPlayerMan.umps.Camera = camT.GetComponent<Camera>();
		OpenVidCam(isOpen: false);
		EyeFade.setToBlack();
		csEnvironmentManager.instance.ChangeEnvInMain();
		if (!csGameSettings.dontNeedShowLogo)
		{
			csEnvironmentManager.instance.SetAudioMute(mute: true);
		}
		camT.gameObject.SetActive(value: true);
		csMainMenuManager.instance.OpenPanel(PanelType.MainMenu);
		AudioListener.volume = 1f * csGameSettings.GlobalVol;
		if (csGameSettings.dontNeedShowLogo)
		{
			StartCoroutine(VoiceStart());
			EyeFade.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
			csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
			welcomeOver = true;
			yield break;
		}
		if (csGameSettings.needReLogin)
		{
			csLogin.instance.Restart();
			csGameSettings.needReLogin = false;
		}
		SetHeadDownHint(flag: false);
		csMainMenuManager.instance.startPage.startShow(delegate
		{
			csGameSettings.dontNeedShowLogo = true;
			welcomeOver = true;
			StartCoroutine(VoiceStart());
		});
	}

	private void OnApplicationFocus(bool focus)
	{
		if (csGameSettings.currentChannel == ChannelType.PicoXR && focus)
		{
			PXR_Input.GetFitnessBandCalibState(ref calibrated);
			if (calibrated == 1)
			{
				csSwiftAvatarController.IsTrackerSet = true;
			}
		}
	}

	public void StartSwiftSet()
	{
		float height = (camT.position.y * 100f + 15f) / 100f;
		SwiftContrl.InitAvatarIK(HeadTrackT, HandLTrackT, HandRTrackT, height);
		UnityEngine.Debug.LogError("StartSwiftSet");
		StartCoroutine(CallSetUpAfterCamSet());
	}

	private IEnumerator CallSetUpAfterCamSet()
	{
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		PXR_Input.OpenFitnessBandCalibrationAPP();
	}

	public void StartMR(bool isON)
	{
	}

	private IEnumerator VoiceStart()
	{
		float t = 0.5f;
		while (t > 0f)
		{
			AudioListener.volume = (0.5f - t) / 0.5f * csGameSettings.GlobalVol;
			t -= Time.deltaTime;
			yield return new WaitForEndOfFrame();
		}
		AudioListener.volume = 1f * csGameSettings.GlobalVol;
	}

	public void ResetRotation(bool isReset)
	{
		if (isReset)
		{
			InputTracking.Recenter();
			base.transform.eulerAngles = new Vector3(0f, 0f, 0f);
		}
		else
		{
			base.transform.eulerAngles = new Vector3(0f, 0f - camT.localEulerAngles.y, 0f);
		}
	}

	private void Update()
	{
		DisToCenter = new Vector3(camT.position.x, 0f, camT.position.z);
		if (csGameDataTransfer.playMode != 0)
		{
			if (DisToCenter.magnitude > InRadius)
			{
				ReturnHintCircle.instance.CircleFadein(DisToCenter.magnitude);
				if (!isArrowShow)
				{
					StartCoroutine(HintArrow());
				}
			}
			if (isArrowShow && DisToCenter.magnitude < InRadius)
			{
				ReturnHintCircle.instance.CircleFadeout(DisToCenter.magnitude);
				if (isArrowShow)
				{
					isArrowShow = false;
				}
			}
		}
		else if (isArrowShow && DisToCenter.magnitude < InRadius)
		{
			ReturnHintCircle.instance.CircleFadeout(DisToCenter.magnitude);
			if (isArrowShow)
			{
				isArrowShow = false;
			}
		}
	}

	private IEnumerator HintArrow()
	{
		yield return null;
		ReturnHintCircle.instance.ArrowsToPlayerT.transform.rotation = Quaternion.LookRotation(-new Vector3(ReturnHintCircle.instance.ArrowsToPlayerT.transform.position.x, 0f, ReturnHintCircle.instance.ArrowsToPlayerT.transform.position.z));
		ReturnHintCircle.instance.ArrowsToPlayerT.transform.position = camT.transform.position + camT.forward - camT.up * 0.5f;
		ReturnHintCircle.instance.CircleAni.Play("arrowanim");
		isArrowShow = true;
	}

	public bool GetMenuBtnDown()
	{
		if (!PicoXRControllerL.GetMenuPressDown())
		{
			return PicoXRControllerR.GetMenuPressDown();
		}
		return true;
	}

	public void pauseUILaser(bool dontUse)
	{
		LaserPointerInputModule.instance.gameObject.SetActive(!dontUse);
		UILaserL.enabled = !dontUse;
		UILaserR.enabled = !dontUse;
		PageLaserL.enabled = !dontUse;
		PageLaserR.enabled = !dontUse;
	}

	public void switchController(bool isSwitchToMenu)
	{
		if (isSwitchToMenu)
		{
			HandItemMan.SwitchToMenuCon();
		}
		else
		{
			HandItemMan.InitItemOnHand();
		}
	}

	public void switchControllerWithMode(csPlayMode mode)
	{
		HandItemMan.InitItemOnHand(mode);
	}

	public void SetControllerVibration(float pa, int fa, float pb, int fb, float ta, float tb)
	{
		StartStr = pa;
		StartFreq = fa;
		EndStr = pb;
		EndFreq = fb;
		TKeep = ta / 1000f;
		TLoss = tb / 1000f;
	}

	public void TriggerHandHaptic(bool isL)
	{
		if (isL)
		{
			PicoXRControllerL.StartLinearHanpticPulse(StartStr, EndStr, StartFreq, EndFreq, TLoss, TKeep);
		}
		else
		{
			PicoXRControllerR.StartLinearHanpticPulse(StartStr, EndStr, StartFreq, EndFreq, TLoss, TKeep);
		}
	}

	public void StartHandHaptic(bool isL, float str, float time)
	{
		if (isL)
		{
			PicoXRControllerL.StartHapticPulse(str, time);
		}
		else
		{
			PicoXRControllerR.StartHapticPulse(str, time);
		}
	}

	public bool InDefenseState()
	{
		bool result = false;
		if (Vector3.Distance(PicoXRControllerL.thisT.position, PicoXRControllerR.thisT.position) < 0.4f && Mathf.Abs(PicoXRControllerL.thisT.position.y - PicoXRControllerR.thisT.position.y) < 0.15f && Mathf.Abs(camT.position.y - PicoXRControllerL.thisT.position.y) < 0.25f && Mathf.Abs(camT.position.y - PicoXRControllerR.thisT.position.y) < 0.25f)
		{
			result = true;
		}
		return result;
	}

	public void SetHeadDownHint(bool flag)
	{
		HandHintL.gameObject.SetActive(flag);
		HandHintR.gameObject.SetActive(flag);
	}
}
public class csPlayerRigLoader : MonoBehaviour
{
	public Transform StartT;

	private string PicoRig = "PlayerForPicoXR";

	private string SteamRig = "PlayerForSteamVR";

	public Text ScaleT;

	public static float MenuResScale = 1.3f;

	public static float GameResScale = 1.1f;

	public GameObject PlayerGO;

	private void Awake()
	{
		csGameSettings.InitDevice();
		if (csGameSettings.CurrentDevice == XRDeviceType.Pico4)
		{
			MenuResScale = 1.3f;
			GameResScale = 1.1f;
		}
		else
		{
			MenuResScale = 1.2f;
			GameResScale = 1f;
		}
		switch (csGameSettings.currentChannel)
		{
		case ChannelType.Steam:
			UnityEngine.Object.DestroyImmediate(PlayerGO);
			PlayerGO = UnityEngine.Object.Instantiate(Resources.Load("Player/" + SteamRig), StartT) as GameObject;
			break;
		}
		PlayerGO.transform.localScale = Vector3.one;
	}

	private IEnumerator Start()
	{
		yield return new WaitForEndOfFrame();
		PlayerGO.transform.position += new Vector3(csPlayer.instance.camT.position.x, 0f, csPlayer.instance.camT.position.z);
	}
}
public class csSimpleExplod : MonoBehaviour
{
	public Transform[] ChildTs;

	public Vector3[] ChildPos;

	public Vector3[] ChildRot;

	public csSimpleRigidbody[] ChildBodise;

	private void Awake()
	{
		ChildPos = new Vector3[ChildTs.Length];
		ChildRot = new Vector3[ChildTs.Length];
		for (int i = 0; i < ChildTs.Length; i++)
		{
			ChildBodise[i].SetKinematic(isTrue: true);
			ChildBodise[i].useGravity = true;
			ChildPos[i] = ChildTs[i].localPosition;
			ChildRot[i] = ChildTs[i].localEulerAngles;
		}
	}

	public void DoExlpode(Vector3 fromPoint, float force)
	{
		for (int i = 0; i < ChildTs.Length; i++)
		{
			ChildBodise[i].SetKinematic(isTrue: false);
			ChildBodise[i].AddForce((ChildTs[i].position - fromPoint).normalized * force);
		}
	}

	public void ExlpodeReset()
	{
		for (int i = 0; i < ChildTs.Length; i++)
		{
			ChildTs[i].localPosition = ChildPos[i];
			ChildTs[i].localEulerAngles = ChildRot[i];
			ChildBodise[i].SetKinematic(isTrue: true);
		}
	}
}
public class csSubtitleManager : MonoBehaviour
{
	public TMP_Text uiText;

	public float duration = 3f;

	public float durationIn = 1f;

	public float durationOut = 1f;

	private csMusicPrefabOptmizedData data;

	private int index;

	private Coroutine coPlaying;

	private Tweener twIn;

	private Tweener twOut;

	public void Play(csMusicPrefabOptmizedData data, int index)
	{
		if (data.FollowTimeHintDataList != null && data.FollowTimeHintDataList.Count != 0)
		{
			if (coPlaying != null)
			{
				UnityEngine.Debug.LogWarning("多次调用");
				return;
			}
			this.data = data;
			this.index = index;
			uiText.gameObject.SetActive(value: true);
			coPlaying = StartCoroutine(CoPlaying());
		}
	}

	private void Awake()
	{
		uiText.DOFade(0f, 0f);
		uiText.gameObject.SetActive(value: false);
	}

	private IEnumerator CoPlaying()
	{
		List<FrameHintData> list = data.FollowTimeHintDataList[index].FrameDataList;
		float num = 0f;
		for (int i = 0; i < list.Count; i++)
		{
			float seconds = list[i].TimeStamp - num;
			yield return new WaitForSeconds(seconds);
			num = list[i].TimeStamp;
			PlaySubtitle(list[i].HintString);
		}
	}

	private void PlaySubtitle(string text)
	{
		twIn?.Kill();
		twOut?.Kill();
		uiText.text = text;
		twIn = uiText.DOFade(1f, durationIn);
		twOut = uiText.DOFade(0f, durationOut).SetDelay(duration);
	}
}
public class csTooltipManager : MonoBehaviour
{
	public static csTooltipManager instance;

	public Canvas canvas;

	public float duration = 2f;

	public float effectTime = 1f;

	private CanvasGroup canvasGroup;

	private void Start()
	{
		canvasGroup = canvas.GetComponent<CanvasGroup>();
		canvas.gameObject.SetActive(value: false);
		if (instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			instance = this;
		}
	}

	public void DisplayTooltip(float duration)
	{
		StopCoroutine(TideTooltip(duration));
		DOTween.KillAll();
		StartCoroutine(TideTooltip(duration));
	}

	private IEnumerator TideTooltip(float duration)
	{
		canvas.gameObject.SetActive(value: true);
		canvasGroup.alpha = 0f;
		canvasGroup.DOFade(1f, effectTime);
		yield return new WaitForSeconds(duration + effectTime);
		canvasGroup.DOFade(0f, effectTime).OnComplete(delegate
		{
			canvas.gameObject.SetActive(value: false);
		});
	}
}
public class csTutorialPracticeManager : MonoBehaviour
{
	public Transform PlayerHitPosT;

	private Vector3 WallOffset = new Vector3(0f, 0.2f, 0f);

	public static csTutorialPracticeManager instance;

	private GameObject currentHole;

	public float beatItemSlowSpeedFactor;

	public PunchOffsetManager POM;

	private csEditorBeatItem curitem;

	private void Start()
	{
		PlayerHitPosT.position = new Vector3(0f, 0f, 16.2f);
	}

	private void Awake()
	{
		instance = this;
	}

	public void StartPunchPractise(TutorialStep step)
	{
		switch (step)
		{
		case TutorialStep.Step1_PunchNormal:
			StartCoroutine(Step1PunchNormalPractice());
			break;
		case TutorialStep.Step2_PunchDirection:
			StartCoroutine(Step2PunchDirectionPractice());
			break;
		case TutorialStep.Step3_PunchHorizontalDirection:
			StartCoroutine(Step3PunchHorizontalDirectionPractice());
			break;
		case TutorialStep.Step4_WallAndDefence:
			StartCoroutine(Step4PunchDefencePractice());
			break;
		}
	}

	public void StartStickPractise(TutorialStep step)
	{
		switch (step)
		{
		case TutorialStep.Step1_StickDirection:
			StartCoroutine(Step1StickDirectionPractice());
			break;
		case TutorialStep.Step2_StickTriangle:
			StartCoroutine(Step2StickTrianglePractice());
			break;
		}
	}

	private IEnumerator Step1PunchNormalPractice()
	{
		SpawnHole();
		yield return new WaitForSeconds(9.6f);
		yield return SpawnOneTutorialItem(csBeatItemType.Normal, csBeatItemColor.LBlack, Vector3.zero, 1f, Quaternion.identity);
		yield return SpawnOneTutorialItem(csBeatItemType.Normal, csBeatItemColor.RWhite, Vector3.zero, 1f, Quaternion.identity);
		yield return SpawnOneTutorialItem(csBeatItemType.Normal, csBeatItemColor.LBlack, Vector3.zero, 1f, Quaternion.identity);
		yield return SpawnOneTutorialItem(csBeatItemType.Normal, csBeatItemColor.RWhite, Vector3.zero, 1f, Quaternion.identity);
		yield return new WaitForSeconds(6f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	private IEnumerator Step2PunchDirectionPractice()
	{
		SpawnHole();
		yield return new WaitForSeconds(2f);
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.LBlack, new Vector3(0f, 0f, -0.16f), 1.1f, Quaternion.Euler(0f, -16f, -90f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.RWhite, new Vector3(0f, 0f, -0.16f), 1.1f, Quaternion.Euler(0f, 16f, 90f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.LBlack, new Vector3(0f, 0f, -0.16f), 1.1f, Quaternion.Euler(0f, -16f, -90f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.RWhite, new Vector3(0f, 0f, -0.16f), 1.1f, Quaternion.Euler(0f, 16f, 90f));
		yield return new WaitForSeconds(7f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	private IEnumerator Step3PunchHorizontalDirectionPractice()
	{
		SpawnHole();
		yield return new WaitForSeconds(0.5f);
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.LBlack, new Vector3(0f, 0f, -0.16f), 1.3f, Quaternion.Euler(16.6f, 0f, -16f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.RWhite, new Vector3(0f, 0f, -0.16f), 1.3f, Quaternion.Euler(16.6f, 0f, 16f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.LBlack, new Vector3(0f, 0f, -0.16f), 1.3f, Quaternion.Euler(16.6f, 0f, -16f));
		yield return SpawnOneTutorialItem(csBeatItemType.Direction, csBeatItemColor.RWhite, new Vector3(0f, 0f, -0.16f), 1.3f, Quaternion.Euler(16.6f, 0f, 16f));
		yield return new WaitForSeconds(7f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	private IEnumerator Step4PunchDefencePractice()
	{
		SpawnHole();
		yield return SpawnWall(-45f, 1.3f);
		yield return SpawnWall(45f, 1.3f);
		yield return SpawnWall(-45f, 1.3f);
		yield return SpawnWall(45f, 1.3f);
		yield return new WaitForSeconds(5.2f);
		yield return SpawnOneTutorialItem(csBeatItemType.Defence, csBeatItemColor.RWhite, Vector3.zero, 2.5f, Quaternion.identity);
		yield return SpawnOneTutorialItem(csBeatItemType.Defence, csBeatItemColor.RWhite, Vector3.zero, 2.5f, Quaternion.identity);
		yield return SpawnOneTutorialItem(csBeatItemType.Defence, csBeatItemColor.RWhite, Vector3.zero, 2.5f, Quaternion.identity);
		yield return new WaitForSeconds(11f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	private IEnumerator Step1StickDirectionPractice()
	{
		SpawnHole();
		yield return new WaitForSeconds(21f);
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.LBlack, new Vector3(-0.55f, -0.6f, 0f), 0f, Quaternion.Euler(0f, 0f, 180f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.RWhite, new Vector3(0.55f, -0.6f, 0f), 1.5f, Quaternion.Euler(0f, 0f, 180f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.LBlack, new Vector3(-0.55f, 0.6f, 0f), 0f, Quaternion.Euler(0f, 0f, 0f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.RWhite, new Vector3(0.55f, 0.6f, 0f), 1.5f, Quaternion.Euler(0f, 0f, 0f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.LBlack, new Vector3(-0.36f, 0.3f, 0f), 0f, Quaternion.Euler(0f, 0f, 90f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.RWhite, new Vector3(-0.36f, -0.3f, 0f), 1.5f, Quaternion.Euler(0f, 0f, 90f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.RWhite, new Vector3(0.36f, 0.3f, 0f), 0f, Quaternion.Euler(0f, 0f, -90f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.LBlack, new Vector3(0.36f, -0.3f, 0f), 1.5f, Quaternion.Euler(0f, 0f, -90f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.RWhite, new Vector3(-0.18f, 0.3f, 0f), 0f, Quaternion.Euler(0f, 0f, 90f));
		yield return SpawnOneTutorialItem(csBeatItemType.StickDirection, csBeatItemColor.LBlack, new Vector3(0.18f, -0.3f, 0f), 1.5f, Quaternion.Euler(0f, 0f, -90f));
		yield return new WaitForSeconds(6.5f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	private IEnumerator Step2StickTrianglePractice()
	{
		SpawnHole();
		yield return new WaitForSeconds(6.5f);
		yield return SpawnTriangle(2500, 7.8f);
		yield return SpawnTriangle(2901, 2f);
		yield return SpawnTriangle(2902, 1.5f);
		yield return SpawnTriangle(2903, 2f);
		yield return new WaitForSeconds(6f);
		CloseHole();
		csTutorialSceneGameManager.instance.SetStepFinish();
	}

	public csEditorBeatItem InitBeatItemByItemData(csBeatItemData d)
	{
		csEditorBeatItem csEditorBeatItem2 = null;
		Vector3 zero = Vector3.zero;
		Vector3 localPos = d.LocalPos;
		switch (d.m_BeatItemType)
		{
		case csBeatItemType.Triangle:
		{
			GameObject objectByType2 = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.forward * 20f, Vector3.forward);
			localPos.y = 0f;
			csEditorBeatItem2 = objectByType2.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		case csBeatItemType.StickDirection:
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.StickObject_Diection, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			localPos.x += csGameSettings.CenterHolePos.x;
			localPos.y += csGameSettings.CenterHolePos.y;
			break;
		case csBeatItemType.Direction:
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Direction, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
			csEditorBeatItem2.SetToDir((csHitObjType)d.TypeIndex);
			break;
		case csBeatItemType.Defence:
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchOjbect_Defend, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Normal:
			zero = GetPunchObjectPos(4, d.m_BeatItemColor == csBeatItemColor.LBlack);
			localPos.x = csGameSettings.CenterHolePos.x + zero.x;
			localPos.y = csGameSettings.CenterHolePos.y + zero.y;
			csEditorBeatItem2 = csObjectPool.Instance.GetObjectByType(PoolObjectType.PunchObject_Normal, Vector3.forward * 20f, Vector3.forward).GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		case csBeatItemType.Wall:
		{
			GameObject objectByType = csObjectPool.Instance.GetObjectByType((PoolObjectType)d.TypeIndex, Vector3.forward * 20f, Vector3.forward);
			localPos.x = csGameSettings.CenterHolePos.x + WallOffset.x;
			localPos.y = csGameSettings.CenterHolePos.y + WallOffset.y;
			csEditorBeatItem2 = objectByType.GetComponent<csEditorBeatItem>();
			csEditorBeatItem2.OnItemReset();
			break;
		}
		}
		csEditorBeatItem2.SetToColorInGame(d.m_BeatItemColor);
		csEditorBeatItem2.thisT.SetParent(PlayerHitPosT);
		csEditorBeatItem2.thisT.localPosition = localPos;
		csEditorBeatItem2.thisT.localRotation = d.LocalRot;
		csEditorBeatItem2.InitMoveDirAndSpeed(-Vector3.forward, 3f, 0);
		return csEditorBeatItem2;
	}

	private IEnumerator SpawnOneTutorialItem(csBeatItemType beatItemType, csBeatItemColor beatItemColor, Vector3 offset, float spawnGapTime, Quaternion rotate)
	{
		currentHole.GetComponent<csCreatePointManager>().SpawnItem();
		csBeatItemData d = new csBeatItemData(offset, rotate, 0f, beatItemType, beatItemColor, 0, 0, 0, new List<Vector3>(), "");
		InitBeatItemByItemData(d).isTutorialItem = true;
		yield return new WaitForSeconds(spawnGapTime);
	}

	private IEnumerator SpawnWall(float rotZ, float spawnGapTime)
	{
		csBeatItemData d = new csBeatItemData(Vector3.zero, Quaternion.Euler(0f, 0f, rotZ), 0f, csBeatItemType.Wall, csBeatItemColor.RWhite, 1000, 0, 0, new List<Vector3>(), "");
		InitBeatItemByItemData(d).isTutorialItem = true;
		yield return new WaitForSeconds(spawnGapTime);
	}

	private IEnumerator SpawnTriangle(int typeIndex, float spawnGapTime)
	{
		csBeatItemData d = new csBeatItemData(Vector3.zero, Quaternion.identity, 0f, csBeatItemType.Triangle, csBeatItemColor.RWhite, typeIndex, 0, 0, new List<Vector3>(), "");
		InitBeatItemByItemData(d).isTutorialItem = true;
		yield return new WaitForSeconds(spawnGapTime);
	}

	private void SpawnHole()
	{
		currentHole = csObjectPool.Instance.GetObjectByType(PoolObjectType.ItemSpawnPoint, Vector3.zero, Vector3.forward);
		StartCoroutine(HoleOperationDelay(currentHole.GetComponent<csCreatePointManager>(), isOpen: true));
		currentHole.transform.position = new Vector3(csGameSettings.CenterHolePos.x, csGameSettings.CenterHolePos.y, PlayerHitPosT.position.z);
	}

	private void CloseHole()
	{
		if ((bool)currentHole)
		{
			StartCoroutine(HoleOperationDelay(currentHole.GetComponent<csCreatePointManager>(), isOpen: false));
		}
	}

	private IEnumerator HoleOperationDelay(csCreatePointManager hole, bool isOpen)
	{
		if (isOpen)
		{
			hole.openSpawnPoint();
		}
		else
		{
			hole.closeSpawnPoint();
		}
		yield return null;
	}

	private Vector3 GetPunchObjectPos(int typeIndex, bool isLeft)
	{
		Vector3 result = Vector3.zero;
		switch (typeIndex)
		{
		case 0:
			result = POM.RH_LTTypeIndex0.localPosition;
			break;
		case 1:
			result = ((!isLeft) ? POM.RH_MTTypeIndex1.localPosition : POM.LH_MTTypeIndex1.localPosition);
			break;
		case 2:
			result = POM.LH_RTTypeIndex2.localPosition;
			break;
		case 3:
			result = POM.RH_LMypeIndex3.localPosition;
			break;
		case 4:
			result = Vector3.zero;
			result = ((!isLeft) ? POM.RH_MMTypeIndex4.localPosition : POM.LH_MMTypeIndex4.localPosition);
			break;
		case 5:
			result = POM.LH_RMTypeIndex5.localPosition;
			break;
		}
		return result;
	}
}
public class csUserData : MonoBehaviour
{
	private static List<int> m_LevelStarNums = new List<int>();

	public static void Init()
	{
		InitLevelStarNums();
	}

	private static void InitLevelStarNums()
	{
		string[] array = PlayerPrefs.GetString("LevelStars", "0;0;0;0;0;0;0;0;0;0").Split(';');
		for (int i = 0; i < array.Length; i++)
		{
			m_LevelStarNums.Add(int.Parse(array[i]));
		}
	}

	public static void SaveRelaxGamePoint(int value)
	{
		PlayerPrefs.SetInt("RelaxGamPoint", GetRelaxGamePoint() + value);
	}

	public static int GetRelaxGamePoint()
	{
		return PlayerPrefs.GetInt("RelaxGamPoint", 0);
	}

	public static void SaveNormalGamePoint(int value)
	{
		PlayerPrefs.SetInt("NormalGamPoint", GetNormalGamePoint() + value);
	}

	public static int GetNormalGamePoint()
	{
		return PlayerPrefs.GetInt("NormalGamPoint", 0);
	}

	public static bool IsUseCustomBGM()
	{
		if (PlayerPrefs.GetInt("IsUseCustomBGM", 0) != 0)
		{
			return true;
		}
		return false;
	}

	public static void SetBGMState(bool iscustom)
	{
		PlayerPrefs.SetInt("IsUseCustomBGM", iscustom ? 1 : 0);
	}

	public static int GetCurrentUserLevel()
	{
		return PlayerPrefs.GetInt("CurrentLevel", 0);
	}

	public static void SaveCurrentUserLevel(int level)
	{
		PlayerPrefs.SetInt("CurrentLevel", level);
	}

	public static void SaveStarNums(int level, int num)
	{
		m_LevelStarNums[level] = num;
		string text = "";
		for (int i = 0; i < m_LevelStarNums.Count; i++)
		{
			text += ((i == m_LevelStarNums.Count - 1) ? m_LevelStarNums[i].ToString() : (m_LevelStarNums[i] + ";"));
		}
		PlayerPrefs.SetString("LevelStars", text);
	}

	public static int GetLevelStarNums(int level)
	{
		return m_LevelStarNums[level];
	}

	public static int GetTotalStarNums()
	{
		return m_LevelStarNums.Sum();
	}
}
public class PunchOffsetManager : MonoBehaviour
{
	public Transform thisT;

	public Transform RH_LTTypeIndex0;

	public Transform LH_MTTypeIndex1;

	public Transform RH_MTTypeIndex1;

	public Transform LH_RTTypeIndex2;

	public Transform RH_LMypeIndex3;

	public Transform LH_MMTypeIndex4;

	public Transform RH_MMTypeIndex4;

	public Transform LH_RMTypeIndex5;

	public Transform L_SwiftKnee;

	public Transform L_SwiftKick;

	public Transform L_SwiftTrample;

	public Transform R_SwiftKnee;

	public Transform R_SwiftKick;

	public Transform R_SwiftTrample;

	public Transform KickHintL;

	public Transform KickHintR;

	public Transform KneeHintL;

	public Transform KneeHintR;

	private void Start()
	{
		thisT.position = new Vector3(0f, csGameSettings.CenterHolePos.y, csGameSettings.PerfectHitZOffset);
	}
}
public class ReturnHintCircle : MonoBehaviour
{
	public static ReturnHintCircle instance;

	public Transform ThisT;

	public GameObject ArrowsToPlayerT;

	public Animator CircleAni;

	public GameObject Tishiquan;

	public Material mat;

	public float Fadespeed = 1f;

	public Color col;

	public float MinDis = 0.2f;

	public float MaxDis = 0.5f;

	private float showtime = 1f;

	private bool isShow = true;

	private float timer;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		mat = Tishiquan.GetComponent<MeshRenderer>().materials[0];
		col = mat.GetColor("_TintColor");
		col.a = 0f;
		mat.SetColor("_TintColor", col);
	}

	public void CircleFadein(float dis)
	{
		ThisT.gameObject.SetActive(value: true);
		if (dis <= MaxDis && dis >= MinDis)
		{
			col.a = (dis - MinDis) / (MaxDis - MinDis) * 47f / 255f;
		}
		if (dis > MaxDis)
		{
			col.a = 0.18431373f;
		}
		if (dis < MinDis)
		{
			col.a = 0f;
		}
		mat.SetColor("_TintColor", col);
	}

	public void CircleFadeout(float dis)
	{
		ThisT.gameObject.SetActive(value: false);
	}

	private void Update()
	{
	}
}
public class csByteEventTracking : MonoBehaviour
{
	public static csByteEventTracking Instance;

	public bool isEventTracking;

	private bool isInit;

	public bool generatingLogFiles;

	public bool showEditorDebug;

	[EnumFlags]
	public ByteEventTrackingID canTrackingID;

	private static string path;

	public class_header class_Header = new class_header();

	public level_header level_Header = new level_header();

	public stage_header stage_Header = new stage_header();

	private string user = "";

	private string header = "";

	private float time;

	private float timeInterval;

	private Coroutine startTimekeepingIE;

	private bool isForeground = true;

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			Instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		if (generatingLogFiles)
		{
			path = Application.persistentDataPath + "/埋点上报信息.txt";
			FileInfo fileInfo = new FileInfo(path);
			if (!fileInfo.Exists)
			{
				fileInfo.CreateText();
			}
			else
			{
				File.Delete(path);
				fileInfo.CreateText();
			}
		}
		Application.logMessageReceived += HandleLog;
	}

	public static void FileWrite(string data)
	{
		try
		{
			StreamWriter streamWriter = new StreamWriter(path, append: true, Encoding.UTF8);
			streamWriter.WriteLine(data);
			streamWriter.Close();
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
	}

	public string GetStringHeaderValue(EventParams value)
	{
		return value switch
		{
			EventParams.class_Header => JsonUtility.ToJson(class_Header), 
			EventParams.level_Header => JsonUtility.ToJson(level_Header), 
			EventParams.stage_Header => JsonUtility.ToJson(stage_Header), 
			_ => "", 
		};
	}

	public void Init()
	{
		if (csGameSettings.IsOfflineVersion || !isEventTracking)
		{
			return;
		}
		string picoID = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID;
		string picoNickName = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName;
		string value = PXR_Plugin.System.UPxr_GetDeviceSN();
		foreach (KeyValuePair<string, string> item in new Dictionary<string, string>
		{
			{ "open_id", picoID },
			{ "sn", value },
			{ "user_name", picoNickName },
			{ "is_vip", "0" }
		})
		{
			RangersAppLog.Wrapper.RangersAppLog.SetCustomHeaderInfo(item.Key, item.Value);
		}
		SetUniqueID(picoID);
		isInit = true;
		string data = string.Format("埋点头参设置：{0}：{1}", DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss.fff") + "     header", header);
		if (generatingLogFiles)
		{
			FileWrite(data);
		}
	}

	public void SetUniqueID(string openid)
	{
		if (isEventTracking)
		{
			RangersAppLog.Wrapper.RangersAppLog.SetUserUniqueID(openid);
		}
	}

	public void SendEvent(ByteEventTrackingID eventId, Dictionary<string, object> parameters)
	{
		if (!csGameSettings.IsOfflineVersion && isEventTracking && isInit && IsSelectEventType(eventId))
		{
			RangersAppLog.Wrapper.RangersAppLog.EventV3(eventId.ToString(), parameters);
			string data = string.Format("埋点：{0}：{1}", DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss.fff") + "     " + eventId, RangersAppLog.Utility.Utility.JSONStringFromDictionary(parameters));
			if (generatingLogFiles)
			{
				FileWrite(data);
			}
		}
	}

	public void StartTimekeeping()
	{
		if (startTimekeepingIE != null)
		{
			StopCoroutine(startTimekeepingIE);
			startTimekeepingIE = null;
		}
		startTimekeepingIE = StartCoroutine(StartTimekeepingIE());
	}

	private IEnumerator StartTimekeepingIE()
	{
		while (true)
		{
			yield return null;
			timeInterval = 0f;
			while (isForeground)
			{
				time += Time.deltaTime;
				timeInterval += Time.deltaTime;
				if (timeInterval >= 60f)
				{
					timeInterval = 0f;
					SendEvent(ByteEventTrackingID.heartbeat_count, new Dictionary<string, object> { 
					{
						"duration",
						(int)(time * 1000f)
					} });
				}
				yield return null;
			}
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		isForeground = focus;
		if (!focus)
		{
			SendEvent(ByteEventTrackingID.heartbeat_count, new Dictionary<string, object> { 
			{
				"duration",
				(int)(time * 1000f)
			} });
		}
	}

	private void HandleLog(string message, string stackTrace, LogType type)
	{
		switch (type)
		{
		case LogType.Error:
			if (message.Length > 0)
			{
				message = message.Substring(0, (message.Length > 10) ? 10 : (message.Length - 1));
				Instance.SendEvent(ByteEventTrackingID.app_error, new Dictionary<string, object> { { "error_id", message } });
			}
			break;
		case LogType.Assert:
		case LogType.Warning:
		case LogType.Log:
		case LogType.Exception:
			break;
		}
	}

	private bool IsSelectEventType(ByteEventTrackingID _eventType)
	{
		int num = 1 << (int)_eventType;
		if (((uint)canTrackingID & (uint)num) == (uint)num)
		{
			return true;
		}
		return false;
	}

	public string GetIP()
	{
		return Dns.GetHostEntry(Dns.GetHostName()).AddressList.First((IPAddress f) => f.AddressFamily == AddressFamily.InterNetwork).ToString();
	}
}
public enum ByteEventTrackingID
{
	app_start,
	enter_page,
	class_start,
	class_end,
	stage_start,
	stage_end,
	heartbeat_count,
	app_error,
	app_update_show,
	start_tutorial,
	end_tutorial,
	class_loading_start,
	class_loading_end,
	button_click,
	app_loading_flow,
	favorite_class,
	set_target,
	movement_flow,
	class_show,
	class_click
}
public enum EventParams
{
	class_Header,
	level_Header,
	stage_Header
}
[Serializable]
public class user
{
	public string user_unique_id;

	public string serial_number;

	public string open_udid;

	public string uid;

	public string client_udid;

	public string user_is_login;

	public user(string user_unique_id, string serial_number, string open_udid, string uid, string client_udid, string user_is_login)
	{
		this.user_unique_id = user_unique_id;
		this.serial_number = serial_number;
		this.open_udid = open_udid;
		this.uid = uid;
		this.client_udid = client_udid;
		this.user_is_login = user_is_login;
	}
}
[Serializable]
public class header
{
	public string client_ip;

	public string timezone;

	public string region;

	public string time;

	public string product_name;

	public string os_name;

	public string os_version;

	public string platform;

	public string app_id;

	public string app_name;

	public string app_version;

	public string app_package;

	public string app_channel;

	public header(string client_ip, string timezone, string region, string time, string product_name, string os_name, string os_version, string platform, string app_id, string app_name, string app_version, string app_package, string app_channel)
	{
		this.client_ip = client_ip;
		this.timezone = timezone;
		this.region = region;
		this.time = time;
		this.product_name = product_name;
		this.os_name = os_name;
		this.os_version = os_version;
		this.platform = platform;
		this.app_id = app_id;
		this.app_name = app_name;
		this.app_version = app_version;
		this.app_package = app_package;
		this.app_channel = app_channel;
	}
}
[Serializable]
public class class_header
{
	public string class_id = "";

	public string class_name = "";

	public string class_type = "";

	public string class_coach = "";

	public string difficulty = "";

	public int class_time;

	public int class_kcal;

	public int stage_number;

	public string is_favorite = "";

	public class_header()
	{
	}

	public class_header(GameSongData data)
	{
		Init(data);
	}

	public class_header(string classID)
	{
		GameSongData data = GameData.instance.SongLevelData.Find((GameSongData item) => item.ClassID == classID);
		Init(data);
	}

	private void Init(GameSongData data)
	{
		class_id = data.ClassID;
		class_name = data.SongID;
		class_type = GetClassType(data);
		class_coach = data.CaochName;
		difficulty = data.Diff.ToString().ToLower();
		class_time = data.ClassTotalTime;
		int num = csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight;
		if (num > 150)
		{
			num = 150;
		}
		if (num < 30)
		{
			num = 30;
		}
		class_kcal = (int)(0.92f * (float)num * (float)data.ClassTotalTime / 1000f);
		stage_number = GetStageNumber(data);
		is_favorite = (IsinCollectionlist(data.ClassID) ? "1" : "0");
	}

	private string GetClassType(GameSongData data)
	{
		if (data.Type == ClassType.Sport)
		{
			if (data.ClassFeatures.Count > 0 && data.ClassFeatures[0] == ClassFeature.Swift)
			{
				return "Swift";
			}
			return data.TypeInHand switch
			{
				csPlayMode.Stick => "Flow", 
				csPlayMode.Boxing => "Boxing", 
				_ => "None", 
			};
		}
		if (data.Type == ClassType.Follow)
		{
			return "Coach";
		}
		if (data.Type == ClassType.Mix)
		{
			return "Mixed";
		}
		return "None";
	}

	private int GetStageNumber(GameSongData data)
	{
		return class_type switch
		{
			"Boxing" => data.GameSongInfoList.Count + 2, 
			"Flow" => data.GameSongInfoList.Count + 2, 
			"Coach" => data.FollowVideoDataList.Count, 
			"Mixed" => 0, 
			"Swift" => data.GameSongInfoList.Count + 2, 
			_ => 0, 
		};
	}

	private bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}
}
[Serializable]
public class stage_header
{
	public string stage_id = "";

	public int stage_order;

	public string stage_type = "";

	public string coach = "";

	public string voice_actor = "";

	public string music_id = "";

	public string music_name = "";

	public string stage_map = "";

	private GameSongData data;

	public stage_header()
	{
	}

	public stage_header(GameSongData data)
	{
		this.data = data;
		coach = data.CaochName;
		voice_actor = data.CaochName;
	}

	public void SetStage(StageType stageType, int stage)
	{
		stage_id = string.Format(data.ClassID + "{0:00}", stage);
		stage_order = stage;
		stage_type = stageType.ToString();
		if (stageType == StageType.fitness && data.GameSongInfoList.Count > 0 && stage - 2 >= 0)
		{
			music_id = data.GameSongInfoList[stage - 2].CurLevelName + "_" + data.GameSongInfoList[stage - 2].CurSingerName;
			music_name = data.GameSongInfoList[stage - 2].CurLevelName;
		}
		else
		{
			music_id = "none";
			music_name = "none";
		}
		stage_map = csEnvironmentManager.instance.currenSceneIntroduceID;
	}
}
public enum StageType
{
	warmup,
	fitness,
	cooldown,
	follow,
	tutorial
}
[Serializable]
public class movement_header
{
	private enum SportType
	{
		hide = 1,
		hit = 2,
		defend = 3,
		line = 9
	}

	public string stage_id = "";

	public string stage_name = "";

	public int movement_order;

	public string type = "";

	public string status = "";

	public string direction = "";

	public string power = "";

	public string body_parts = "";

	public movement_header()
	{
	}

	public movement_header(stage_header stage_Header, int movement_order, csEditorBeatItem item, bool status, float speed)
	{
		stage_id = stage_Header.stage_id;
		stage_name = stage_Header.music_name;
		this.movement_order = movement_order;
		SportType beatItemType = (SportType)item.m_BeatItemType;
		type = beatItemType.ToString();
		this.status = (status ? "1" : "0");
		direction = GetDirection(item.transform.localPosition.x);
		power = ((speed > csGameSettings.levelMinSpeed[1]) ? "hard" : "soft");
		body_parts = GetBodyParts(item.m_BeatItemType);
	}

	private string GetDirection(float x)
	{
		if (x < 0f)
		{
			return "left";
		}
		if (x > 0f)
		{
			return "right";
		}
		return "mid";
	}

	private string GetBodyParts(csBeatItemType type)
	{
		switch (type)
		{
		case csBeatItemType.Normal:
		case csBeatItemType.Defence:
		case csBeatItemType.Way:
			return "hand";
		case csBeatItemType.SwiftKnee:
			return "knee";
		case csBeatItemType.SwiftKick:
			return "foot";
		default:
			return "none";
		}
	}

	private string GetSN()
	{
		return new AndroidJavaObject("android.os.Build").GetStatic<string>("SERIAL");
	}
}
[Serializable]
public class level_header
{
	public string class_session = "";

	public level_header()
	{
	}

	public level_header(string class_session)
	{
		this.class_session = class_session;
	}
}
[Serializable]
public class params_
{
}
[Serializable]
public class header_custom
{
}
public enum ButtonTrackingClick
{
	None,
	Announcement_BoxConfirm,
	Announcement_,
	Main_Sports,
	Main_Follow,
	Main_Settings,
	Menu_Explore,
	Menu_Plan,
	Menu_My,
	OverallRankingPageDown,
	My_History,
	My_Collect,
	My_ExerciseProgram,
	My_Details,
	ExerciseProgram_,
	Main_Sports_Boxing,
	Main_Sports_Stick,
	Main_Follow_Super,
	Main_Follow_Follow
}
public class EnumFlags : PropertyAttribute
{
}
public class csTalkingData : MonoBehaviour
{
	public static csTalkingData Instance;

	public string AppID = "13659DEFCDA34D69AD43CC587CDFADD0";

	private string EventVersion;

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
			TalkingDataSDK.Init(AppID, "PicoXR", "");
		}
	}

	public void SendEvent(string eventId, double eventValue, Dictionary<string, object> parameters)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			EventVersion = csGameSettings.GameVersion;
			EventVersion = EventVersion.Replace(".", "_");
			TalkingDataSDK.OnEvent(EventVersion + "_" + eventId, eventValue, parameters);
		}
	}
}
public class csClassDownloadData
{
	private List<FollowVideoData> VideoDataList;

	public List<csDownloadMision> NowMisionList;

	private double TotalVideoNum;

	public string ClassID;

	private double OneMisionProgress;

	public DowloadState downloadState;

	public Action classMisionCompletCallBack;

	public Action<string> classMisionFiledCallBack;

	public Action classMisionStopCallBack;

	public Action classMisionStartCallBack;

	public Action classMisionCanncelCallBack;

	public Action<double> classMisionProgressCallBack;

	private float downloadStartTime;

	private class_header class_Header;

	public csClassDownloadData(List<FollowVideoData> FollowVideoDataList, string classID, Action completCb, Action<string> FiledCb, Action<double> progressCb)
	{
		NowMisionList = new List<csDownloadMision>();
		VideoDataList = FollowVideoDataList;
		TotalVideoNum = FollowVideoDataList.Count;
		OneMisionProgress = 1.0 / TotalVideoNum;
		ClassID = classID;
		downloadState = DowloadState.Wait;
		classMisionCompletCallBack = completCb;
		classMisionFiledCallBack = FiledCb;
		classMisionProgressCallBack = progressCb;
		CreateAllMision();
		class_Header = new class_header(ClassID);
	}

	private void CreateAllMision()
	{
		for (int i = 0; i < VideoDataList.Count; i++)
		{
			csDownloadMision csDownloadMision2 = csVedioDownloadManager.instance.CreatDownloadMisionByName(VideoDataList[i].VideoName, delegate
			{
			}, OnMisionComplet, OnMisionFiled, OnMisionProgress);
			if (csDownloadMision2 != null)
			{
				NowMisionList.Add(csDownloadMision2);
			}
		}
		PrintAllMision();
	}

	public void StartAllMision()
	{
		if (NowMisionList.Count <= 0)
		{
			MisionProgress(1.0);
			ClassMisionComplet();
			return;
		}
		NowMisionList[0].MisionStart();
		downloadState = DowloadState.Downloading;
		if (classMisionStartCallBack != null)
		{
			classMisionStartCallBack();
		}
		PrintAllMision();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_loading_start, new Dictionary<string, object> { 
		{
			"class_header",
			JsonUtility.ToJson(class_Header)
		} });
		downloadStartTime = Time.realtimeSinceStartup;
	}

	public void StopAllMision()
	{
		NowMisionList[0].MisionStop();
		downloadState = DowloadState.Stoped;
		if (classMisionStopCallBack != null)
		{
			classMisionStopCallBack();
		}
		PrintAllMision();
		VedioDownloadSendEvent(2);
	}

	public void CanncelAllMision()
	{
		for (int num = NowMisionList.Count - 1; num >= 0; num--)
		{
			NowMisionList[num].MisionCanncel();
			NowMisionList.RemoveAt(num);
		}
		classMisionCanncelCallBack();
		VedioDownloadSendEvent(2);
	}

	public double GetTotalProgress()
	{
		double num = 0.0;
		int overMisionNum = GetOverMisionNum();
		num += (double)overMisionNum * OneMisionProgress;
		if (NowMisionList.Count > 0)
		{
			num += NowMisionList[0].GetProgress() * OneMisionProgress;
		}
		return num;
	}

	public int GetOverMisionNum()
	{
		return (int)TotalVideoNum - NowMisionList.Count;
	}

	private void MisionProgress(double prs)
	{
		if (classMisionProgressCallBack != null)
		{
			classMisionProgressCallBack(prs);
		}
	}

	private void OnMisionProgress(double prs)
	{
		if (classMisionProgressCallBack != null)
		{
			classMisionProgressCallBack(GetTotalProgress());
		}
	}

	private void OnMisionComplet()
	{
		_ = NowMisionList[0].FileName;
		NowMisionList.RemoveAt(0);
		if (downloadState != 0 && downloadState != DowloadState.Stoped)
		{
			if (NowMisionList.Count <= 0)
			{
				OnMisionProgress(1.0);
				ClassMisionComplet();
			}
			else
			{
				NowMisionList[0].MisionStart();
			}
			PrintAllMision();
		}
	}

	private void PrintAllMision()
	{
		string text = "课程中所有下载任务：\n";
		for (int i = 0; i < NowMisionList.Count; i++)
		{
			text = text + "[" + i + "] = " + NowMisionList[i].FileName;
			string text2 = "";
			switch (NowMisionList[i].dowloadState)
			{
			case DowloadState.Downloading:
				text2 = "(正在下载)";
				break;
			case DowloadState.Wait:
				text2 = "(等待)";
				break;
			case DowloadState.Stoped:
				text2 = "(暂停)";
				break;
			}
			text = text + " - " + text2 + "\n";
		}
	}

	public void ClassMisionComplet()
	{
		downloadState = DowloadState.Completed;
		if (classMisionCompletCallBack != null)
		{
			classMisionCompletCallBack();
		}
		VedioDownloadSendEvent(0);
	}

	public void OnMisionFiled(string error)
	{
		if (classMisionFiledCallBack != null)
		{
			classMisionFiledCallBack(error);
		}
		VedioDownloadSendEvent(1);
	}

	private void VedioDownloadSendEvent(int state)
	{
		string text = "";
		text = state switch
		{
			0 => "finish", 
			1 => "fail", 
			2 => "cancel", 
			_ => "error", 
		};
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_loading_end, new Dictionary<string, object>
		{
			{
				"class_header",
				JsonUtility.ToJson(class_Header)
			},
			{
				"stage",
				class_Header.class_type + "VideoDownload"
			},
			{ "status", text },
			{
				"duration",
				(int)((Time.realtimeSinceStartup - downloadStartTime) * 1000f)
			}
		});
	}
}
public class csDownloadMision
{
	private string downloadUrl;

	private string targetPath;

	private string mp4Path;

	public string FileName;

	private Action StartCallBack;

	private Action CompletCallBack;

	private Action<string> FiledCallBack;

	private Action<double> ProgressCallBack;

	private double mishionProgress;

	public DowloadState dowloadState;

	private Coroutine DowloadCorurine;

	private Coroutine WriteFileCorutine;

	private UnityWebRequest Request;

	public csDownloadMision(string fileName, string rul, string path, string mp4path, Action startCb, Action completCb, Action<string> FiledCb, Action<double> progressCb)
	{
		FileName = fileName;
		downloadUrl = rul;
		targetPath = path;
		mp4Path = mp4path;
		StartCallBack = startCb;
		CompletCallBack = completCb;
		FiledCallBack = FiledCb;
		ProgressCallBack = progressCb;
		MisionWait();
	}

	public void MisionWait()
	{
		dowloadState = DowloadState.Wait;
	}

	public void MisionContinue()
	{
		MisionStart();
	}

	public void MisionStop()
	{
		dowloadState = DowloadState.Stoped;
		UnityEngine.Debug.LogError("暂停任务: " + FileName);
		MisionCanncel();
	}

	public void MisionCanncel()
	{
		UnityEngine.Debug.LogError("取消任务: " + FileName);
		if (Request != null)
		{
			Request.Dispose();
		}
		if (DowloadCorurine != null)
		{
			csVedioDownloadManager.instance.StopCoroutine(DowloadCorurine);
		}
	}

	public void MisionStart()
	{
		dowloadState = DowloadState.Downloading;
		if (DowloadCorurine != null)
		{
			csVedioDownloadManager.instance.StopCoroutine(DowloadCorurine);
		}
		DowloadCorurine = csVedioDownloadManager.instance.StartCoroutine(LoadAWebByteToMp4_New());
	}

	private IEnumerator LoadAWebByteToMp4_New()
	{
		string url = downloadUrl;
		string filePath = targetPath;
		UnityWebRequest headRequest = UnityWebRequest.Head(url);
		yield return headRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(headRequest.error))
		{
			ShowText("获取下载的文件大小失败 : " + headRequest.error);
			if (FiledCallBack != null)
			{
				FiledCallBack(headRequest.error);
			}
			yield break;
		}
		ulong totalLength = ulong.Parse(headRequest.GetResponseHeader("Content-Length"));
		ShowText("获取大小" + totalLength);
		headRequest.Dispose();
		Request = UnityWebRequest.Get(url);
		Request.downloadHandler = new DownloadHandlerFile(filePath, append: true);
		FileInfo fileInfo = new FileInfo(filePath);
		ulong fileLength = (ulong)fileInfo.Length;
		Request.SetRequestHeader("Range", "bytes=" + fileLength + "-");
		if (fileLength < totalLength)
		{
			Request.SendWebRequest();
			while (!Request.isDone)
			{
				mishionProgress = (double)(Request.downloadedBytes + fileLength) / (double)totalLength;
				ProgressCallBack(mishionProgress);
				yield return null;
			}
		}
		if (string.IsNullOrEmpty(Request.error))
		{
			ShowText("下载成功 - 开始转换文件");
			csDownloadTools.instance.SaveDownloadFileExists(FileName + ".bytes");
			CompletCallBack();
		}
		else
		{
			ShowText("下载失败" + Request.error);
			if (FiledCallBack != null)
			{
				FiledCallBack(Request.error);
			}
		}
		Request.Dispose();
	}

	public double GetProgress()
	{
		return mishionProgress;
	}

	private void ShowText(string str)
	{
	}

	private void MP4DownCallBack()
	{
		CompletCallBack();
	}
}
public class csDownloadTools : MonoBehaviour
{
	public static csDownloadTools instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	public void ByteToMp4_Thread(string mp4Name, string bytePath, string mp4Path, Action DownCallBcak)
	{
		new Thread((ThreadStart)delegate
		{
			try
			{
				byte[] bytes = csAssetLoader.DecryptBytesByByte(File.ReadAllBytes(bytePath));
				File.WriteAllBytes(mp4Path, bytes);
			}
			catch (Exception value)
			{
				Console.WriteLine(value);
			}
		}).Start();
		StartCoroutine(ByteMp4Coroutine(mp4Name, bytePath, mp4Path, DownCallBcak));
	}

	private IEnumerator ByteMp4Coroutine(string mp4Name, string bytePath, string mp4Path, Action CallBcak)
	{
		while (!File.Exists(mp4Path))
		{
			yield return null;
		}
		SaveDownloadFileExists(mp4Name);
		CallBcak();
		File.Delete(bytePath);
	}

	public void SaveDownloadFileExists(string FileName)
	{
		string @string = PlayerPrefs.GetString("PlayerDownloadFiles");
		if (!IsDownloadFileExists(FileName))
		{
			@string = @string + FileName + ";";
			PlayerPrefs.SetString("PlayerDownloadFiles", @string);
		}
	}

	public bool IsDownloadFileExists(string FileName)
	{
		string @string = PlayerPrefs.GetString("PlayerDownloadFiles");
		if (@string.Contains(";"))
		{
			string[] array = @string.Split(';');
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				if (array2[i] == FileName)
				{
					return true;
				}
			}
			return false;
		}
		return false;
	}

	public bool CheckEnByteFileExists(string FileName)
	{
		return IsDownloadFileExists(FileName + "_EnByte.unity3d");
	}

	public bool CheckMP4FileExists(string FileName)
	{
		return IsDownloadFileExists(FileName + ".bytes");
	}
}
public class csVedioDownloadManager : MonoBehaviour
{
	public static csVedioDownloadManager instance;

	private string GameVedioPath;

	private List<csDownloadMision> MishionList;

	private List<csClassDownloadData> ClassDataList;

	private csDownloadMision CurrentMishion;

	public Action<string> classMisionCreateCallback;

	private int MaxMisionCount;

	private int MaxClassMisionCount;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			MishionList = new List<csDownloadMision>();
			ClassDataList = new List<csClassDownloadData>();
			MaxMisionCount = 20;
			MaxClassMisionCount = 5;
		}
		GameVedioPath = Application.persistentDataPath + "/VideoData/";
		if (!Directory.Exists(GameVedioPath))
		{
			Directory.CreateDirectory(GameVedioPath);
		}
	}

	public csDownloadMision CreatDownloadMisionByName(string videoName, Action startCb, Action completCb, Action<string> FiledCb, Action<double> progressCb)
	{
		string rul = csAssetLoader.URLHead + "MP4Video/" + videoName + ".mp4";
		string path = GameVedioPath + videoName + ".bytes";
		string mp4path = GameVedioPath + videoName + ".bytes";
		if (CheckMision(videoName))
		{
			return GetMisionByName(videoName);
		}
		csDownloadTools.instance.CheckMP4FileExists(videoName);
		return new csDownloadMision(videoName, rul, path, mp4path, startCb, delegate
		{
			completCb();
		}, FiledCb, progressCb);
	}

	private bool CheckMision(string videoName)
	{
		for (int i = 0; i < MishionList.Count; i++)
		{
			if (MishionList[i].FileName == videoName)
			{
				return true;
			}
		}
		return false;
	}

	private void StartFirstMision()
	{
		if (MishionList.Count >= 1)
		{
			MishionList[0].MisionStart();
		}
	}

	private void StopFirstMision()
	{
		if (MishionList.Count >= 1)
		{
			MishionList[0].MisionStop();
		}
	}

	public void StartMisionByName(string name)
	{
		StopFirstMision();
		for (int i = 0; i < MishionList.Count; i++)
		{
			if (MishionList[i].FileName == name)
			{
				csDownloadMision item = MishionList[i];
				MishionList.RemoveAt(i);
				MishionList.Insert(0, item);
				StartFirstMision();
				break;
			}
		}
		PrintAllMision();
	}

	public void StopMision()
	{
		StopFirstMision();
		if (MishionList.Count > 1)
		{
			csDownloadMision csDownloadMision2 = MishionList[1];
			MishionList.RemoveAt(1);
			MishionList.Insert(0, csDownloadMision2);
			csDownloadMision2.MisionStart();
		}
		PrintAllMision();
	}

	public void StopAllMision()
	{
		StopFirstMision();
		PrintAllMision();
	}

	public void CanncelMisionByName(string name)
	{
		for (int i = 0; i < MishionList.Count; i++)
		{
			if (MishionList[i].FileName == name)
			{
				MishionList[i].MisionCanncel();
				MishionList.RemoveAt(i);
				break;
			}
		}
		PrintAllMision();
	}

	private void WaitMisionByName(string name)
	{
	}

	private void OnMisionComplet()
	{
		_ = MishionList[0].FileName;
		MishionList.RemoveAt(0);
		PrintAllMision();
	}

	private void PrintAllMision()
	{
		string text = "所有下载任务：\n";
		for (int i = 0; i < MishionList.Count; i++)
		{
			text = text + "[" + i + "] = " + MishionList[i].FileName;
			string text2 = "";
			switch (MishionList[i].dowloadState)
			{
			case DowloadState.Downloading:
				text2 = "(正在下载)";
				break;
			case DowloadState.Wait:
				text2 = "(等待)";
				break;
			case DowloadState.Stoped:
				text2 = "(暂停)";
				break;
			}
			text = text + " - " + text2 + "\n";
		}
	}

	public void StartLastMision()
	{
		StartMisionByName(MishionList[MishionList.Count - 1].FileName);
	}

	public void CannelFirstMision()
	{
		CanncelMisionByName(MishionList[0].FileName);
	}

	public void CannelLastMision()
	{
		CanncelMisionByName(MishionList[MishionList.Count - 1].FileName);
	}

	public double GetProgressByName(string name)
	{
		return GetMisionByName(name)?.GetProgress() ?? 0.0;
	}

	public csDownloadMision GetMisionByName(string name)
	{
		for (int i = 0; i < MishionList.Count; i++)
		{
			if (MishionList[i].FileName == name)
			{
				return MishionList[i];
			}
		}
		return null;
	}

	public bool CheckClassMision(string classId)
	{
		for (int i = 0; i < ClassDataList.Count; i++)
		{
			if (ClassDataList[i].ClassID == classId)
			{
				return true;
			}
		}
		return false;
	}

	public csClassDownloadData CreateClassMisionDataByID(List<FollowVideoData> FollowVideoDataList, string ClassID, Action completCb, Action<string> FiledCb, Action<double> progressCb, bool isPlaying = false)
	{
		if (CheckClassMision(ClassID))
		{
			csClassDownloadData classMisionById = GetClassMisionById(ClassID);
			classMisionById.classMisionCompletCallBack = (Action)Delegate.Combine(classMisionById.classMisionCompletCallBack, completCb);
			classMisionById.classMisionFiledCallBack = (Action<string>)Delegate.Combine(classMisionById.classMisionFiledCallBack, FiledCb);
			classMisionById.classMisionProgressCallBack = (Action<double>)Delegate.Combine(classMisionById.classMisionProgressCallBack, progressCb);
			return classMisionById;
		}
		if (ClassDataList.Count >= MaxClassMisionCount && !isPlaying)
		{
			return null;
		}
		csClassDownloadData csClassDownloadData2 = new csClassDownloadData(FollowVideoDataList, ClassID, delegate
		{
			OnClassMisionComplet();
		}, delegate(string error)
		{
			OnClassMisionFiled(error);
		}, delegate
		{
		});
		csClassDownloadData2.classMisionCompletCallBack = (Action)Delegate.Combine(csClassDownloadData2.classMisionCompletCallBack, completCb);
		csClassDownloadData2.classMisionFiledCallBack = (Action<string>)Delegate.Combine(csClassDownloadData2.classMisionFiledCallBack, FiledCb);
		csClassDownloadData2.classMisionProgressCallBack = (Action<double>)Delegate.Combine(csClassDownloadData2.classMisionProgressCallBack, progressCb);
		if (csClassDownloadData2.NowMisionList.Count <= 0 && !isPlaying)
		{
			return null;
		}
		ClassDataList.Add(csClassDownloadData2);
		if (ClassDataList.Count == 1)
		{
			csClassDownloadData2.StartAllMision();
		}
		PrintAllClass();
		if (classMisionCreateCallback != null)
		{
			classMisionCreateCallback(ClassID);
		}
		return csClassDownloadData2;
	}

	public csClassDownloadData CreateAndStartClassMision(List<FollowVideoData> FollowVideoDataList, string ClassID, Action completCb, Action<string> FiledCb, Action<double> progressCb, bool isPlaying = false)
	{
		csClassDownloadData result = CreateClassMisionDataByID(FollowVideoDataList, ClassID, completCb, FiledCb, progressCb, isPlaying);
		StartClassMisionById(ClassID);
		return result;
	}

	public csClassDownloadData GetClassMisionById(string ClassID)
	{
		for (int i = 0; i < ClassDataList.Count; i++)
		{
			if (ClassDataList[i].ClassID == ClassID)
			{
				return ClassDataList[i];
			}
		}
		return null;
	}

	private void StopClassFirstMision()
	{
		if (ClassDataList.Count >= 1)
		{
			ClassDataList[0].StopAllMision();
		}
	}

	public void StartClassFirstMision()
	{
		if (ClassDataList.Count >= 1)
		{
			ClassDataList[0].StartAllMision();
		}
	}

	private void OnClassMisionComplet()
	{
		_ = ClassDataList[0].ClassID;
		ClassDataList.RemoveAt(0);
		StartClassFirstMision();
		PrintAllClass();
	}

	private void OnClassMisionFiled(string error)
	{
		StopAllClassMision();
		if (GameManagerNew.instance.gameState != GAMESTATE.MENUSTART)
		{
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common11"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
			{
			});
		}
	}

	public void StartClassMisionById(string classId)
	{
		StopClassFirstMision();
		csClassDownloadData csClassDownloadData2 = null;
		for (int i = 0; i < ClassDataList.Count; i++)
		{
			if (ClassDataList[i].ClassID == classId)
			{
				csClassDownloadData2 = ClassDataList[i];
				ClassDataList.RemoveAt(i);
				ClassDataList.Insert(0, csClassDownloadData2);
				break;
			}
		}
		StartClassFirstMision();
		PrintAllClass();
	}

	public void StopClassMision()
	{
		StopClassFirstMision();
		if (ClassDataList.Count > 1)
		{
			csClassDownloadData csClassDownloadData2 = ClassDataList[1];
			ClassDataList.RemoveAt(1);
			ClassDataList.Insert(0, csClassDownloadData2);
			csClassDownloadData2.StartAllMision();
		}
		PrintAllClass();
	}

	public void StopAllClassMision()
	{
		StopClassFirstMision();
		PrintAllClass();
	}

	public void CanncelClassMisionByClassId(string classId)
	{
		for (int i = 0; i < ClassDataList.Count; i++)
		{
			if (ClassDataList[i].ClassID == classId)
			{
				ClassDataList[i].CanncelAllMision();
				ClassDataList.RemoveAt(i);
				if (i == 0)
				{
					StartClassFirstMision();
				}
				break;
			}
		}
		PrintAllClass();
	}

	public bool CheckClassMisionCanCreatByList(List<FollowVideoData> FollowVideoDataList)
	{
		bool result = true;
		if (FollowVideoDataList.Count + MishionList.Count > 20)
		{
			result = false;
		}
		return result;
	}

	private void PrintAllClass()
	{
		string text = "所有下载课程：\n";
		for (int i = 0; i < ClassDataList.Count; i++)
		{
			text = text + "[" + i + "] = " + ClassDataList[i].ClassID;
			string text2 = "";
			switch (ClassDataList[i].downloadState)
			{
			case DowloadState.Downloading:
				text2 = "(正在下载)";
				break;
			case DowloadState.Wait:
				text2 = "(等待)";
				break;
			case DowloadState.Stoped:
				text2 = "(暂停)";
				break;
			}
			text = text + " - " + text2 + "\n";
			text += "所有下载任务：\n";
			string text3 = "";
			for (int j = 0; j < MishionList.Count; j++)
			{
				text = text + "[" + j + "] = " + MishionList[j].FileName;
				switch (MishionList[j].dowloadState)
				{
				case DowloadState.Downloading:
					text3 = "(正在下载)";
					break;
				case DowloadState.Wait:
					text3 = "(等待)";
					break;
				case DowloadState.Stoped:
					text3 = "(暂停)";
					break;
				}
				text = text + " - " + text3 + "\n";
			}
		}
	}

	public void StartLastClassMision()
	{
		StartClassMisionById(ClassDataList[ClassDataList.Count - 1].ClassID);
	}

	public void CannelFirstClassMision()
	{
		CanncelClassMisionByClassId(ClassDataList[0].ClassID);
	}

	public void CannelLastClassMision()
	{
		CanncelClassMisionByClassId(ClassDataList[ClassDataList.Count - 1].ClassID);
	}

	private void OnClassMisionCreate(string ClassID)
	{
		classMisionCreateCallback(ClassID);
	}

	public void FileClassMision()
	{
		if (ClassDataList[0] != null)
		{
			ClassDataList[0].OnMisionFiled("cuowo");
		}
	}
}
public interface IPageContent
{
	void GetContentByPageIdx(int idx);
}
public class csFontChanger : MonoBehaviour
{
	private Text m_Text;

	public float m_FactorSize = 1.3f;

	public Font EnFont;

	private void Awake()
	{
		m_Text = GetComponent<Text>();
	}

	private void Start()
	{
		if (csLocalizationManager.Instance.m_CurrentLanguage != 0)
		{
			_ = 1;
		}
	}
}
public class csFontScale : MonoBehaviour
{
	private Text m_Text;

	public int CNSize = 110;

	public int ENSize = 100;

	public float CNLineS = 1.15f;

	public float ENLineS = 0.8f;

	private void Awake()
	{
		m_Text = GetComponent<Text>();
	}

	private void Start()
	{
		switch (csLocalizationManager.Instance.m_CurrentLanguage)
		{
		case Languages.ChineseSimplified:
			m_Text.fontSize = CNSize;
			m_Text.lineSpacing = CNLineS;
			break;
		case Languages.English:
			m_Text.fontSize = ENSize;
			m_Text.lineSpacing = ENLineS;
			break;
		default:
			m_Text.fontSize = ENSize;
			m_Text.lineSpacing = ENLineS;
			break;
		}
	}
}
public class csLocalGameObject : MonoBehaviour
{
	public List<LocalGameObject> m_SRDataList = new List<LocalGameObject>();

	private void OnEnable()
	{
		for (int i = 0; i < m_SRDataList.Count; i++)
		{
			if (m_SRDataList[i].m_Language == csLocalizationManager.Instance.m_CurrentLanguage)
			{
				m_SRDataList[i].m_GameObject.SetActive(value: true);
			}
			else
			{
				m_SRDataList[i].m_GameObject.SetActive(value: false);
			}
		}
	}
}
[Serializable]
public class LocalGameObject
{
	public Languages m_Language;

	public GameObject m_GameObject;
}
public class csLocalImage : MonoBehaviour
{
	public string id;

	private Image m_Sprite;

	private void Awake()
	{
		m_Sprite = GetComponent<Image>();
	}

	private void OnEnable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalImage));
		if (m_Sprite != null)
		{
			m_Sprite.overrideSprite = csLocalizationManager.Instance.GetLocalSprite(id);
		}
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalImage));
	}

	private void UpdateLocalImage()
	{
	}
}
public class csLocalizationManager : MonoBehaviour
{
	public static csLocalizationManager Instance;

	public bool UseLocalization;

	private Dictionary<Languages, Dictionary<string, string>> m_LanguageTextDic = new Dictionary<Languages, Dictionary<string, string>>();

	private Dictionary<Languages, Dictionary<string, Sprite>> m_LanguageSpriteDic = new Dictionary<Languages, Dictionary<string, Sprite>>();

	public Languages m_CurrentLanguage;

	public ServerRegion CurrentRegion = ServerRegion.China;

	private Dictionary<string, string> m_CurrentLocalTexts = new Dictionary<string, string>();

	private Dictionary<string, Sprite> m_CurrentLocalSprites = new Dictionary<string, Sprite>();

	public List<Sprite> m_LocalSprites;

	public static Action updateLocalText;

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
			UnityEngine.Object.DontDestroyOnLoad(this);
			for (int i = 0; i < Enum.GetValues(typeof(Languages)).Length; i++)
			{
				Dictionary<Languages, Dictionary<string, string>> languageTextDic = m_LanguageTextDic;
				int key = i;
				Languages languages = (Languages)i;
				languageTextDic.Add((Languages)key, ReadLocalizationData(languages.ToString()));
				switch ((Languages)i)
				{
				case Languages.ChineseSimplified:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("cn"));
					break;
				case Languages.English:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("en"));
					break;
				case Languages.German:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("en"));
					break;
				case Languages.Korean:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("en"));
					break;
				case Languages.French:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("en"));
					break;
				default:
					m_LanguageSpriteDic.Add((Languages)i, ReadLocalSpriteData("en"));
					break;
				}
			}
			if (PlayerPrefs.GetInt("CurrentLanguage", -1) == -1)
			{
				if (Application.systemLanguage == SystemLanguage.Chinese || Application.systemLanguage == SystemLanguage.ChineseSimplified || Application.systemLanguage == SystemLanguage.ChineseTraditional)
				{
					m_CurrentLanguage = Languages.ChineseSimplified;
				}
				else
				{
					m_CurrentLanguage = Languages.English;
				}
			}
			else
			{
				m_CurrentLanguage = (Languages)PlayerPrefs.GetInt("CurrentLanguage", -1);
			}
			SetLanguage(m_CurrentLanguage);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public Sprite GetLocalSprite(string id)
	{
		return m_CurrentLocalSprites[id];
	}

	public Sprite GetLocalSprite(string id, Languages regionType)
	{
		return m_LanguageSpriteDic[regionType][id];
	}

	public string GetLocalText(string id)
	{
		if (!m_CurrentLocalTexts.ContainsKey(id))
		{
			UnityEngine.Debug.LogError(id);
			return "ERROR NULL TEXT";
		}
		return m_CurrentLocalTexts[id];
	}

	private Dictionary<string, string> ReadLocalizationData(string filename)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string path = "Localization/" + filename;
		string text = "";
		TextAsset textAsset = Resources.Load(path) as TextAsset;
		if (textAsset == null)
		{
			UnityEngine.Debug.Log("Can't find asset " + filename);
		}
		else
		{
			StringReader stringReader = new StringReader(textAsset.text);
			while ((text = stringReader.ReadLine()) != null)
			{
				if (text.Contains(";"))
				{
					string[] array = text.Split(';');
					dictionary.Add(array[0], array[1]);
				}
			}
			stringReader.Dispose();
		}
		return dictionary;
	}

	private Dictionary<string, Sprite> ReadLocalSpriteData(string filename)
	{
		Dictionary<string, Sprite> dictionary = new Dictionary<string, Sprite>();
		for (int i = 0; i < m_LocalSprites.Count; i++)
		{
			string[] array = m_LocalSprites[i].name.Split('_');
			if (array[1] == filename)
			{
				dictionary.Add(array[0], m_LocalSprites[i]);
			}
		}
		return dictionary;
	}

	public void SetLanguage(Languages language)
	{
		PlayerPrefs.SetInt("CurrentLanguage", (int)language);
		m_CurrentLanguage = language;
		m_CurrentLocalSprites = m_LanguageSpriteDic[m_CurrentLanguage];
		m_CurrentLocalTexts = m_LanguageTextDic[m_CurrentLanguage];
		if (updateLocalText != null)
		{
			updateLocalText();
		}
	}

	public void DownloadLanguage()
	{
		for (int i = 0; i < Enum.GetValues(typeof(Languages)).Length; i++)
		{
			string languageName = "English";
			switch ((Languages)i)
			{
			case Languages.English:
				languageName = "English";
				break;
			case Languages.ChineseSimplified:
				languageName = "ChineseSimplified";
				break;
			}
			csAssetLoader.instance.DownloadLanguage(languageName, UpdateLanguage);
		}
	}

	public void UpdateLanguage(TextAsset textAsset, string languageName)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string text = "";
		if (textAsset == null)
		{
			UnityEngine.Debug.LogError("Can't download asset " + textAsset);
		}
		else
		{
			StringReader stringReader = new StringReader(textAsset.text);
			while ((text = stringReader.ReadLine()) != null)
			{
				if (text.Contains(";"))
				{
					string[] array = text.Split(';');
					dictionary.Add(array[0], array[1]);
				}
			}
			stringReader.Dispose();
		}
		Languages key = Languages.English;
		switch (languageName)
		{
		case "ChineseSimplified":
			key = Languages.ChineseSimplified;
			break;
		case "English":
			key = Languages.English;
			break;
		}
		Dictionary<string, string> dictionary2 = m_LanguageTextDic[key];
		foreach (KeyValuePair<string, string> item in dictionary)
		{
			if (!string.IsNullOrEmpty(dictionary2[item.Key]))
			{
				dictionary2[item.Key] = item.Value;
			}
			else
			{
				dictionary2.Add(item.Key, item.Value);
			}
		}
	}
}
public class csLocalObjectActive : MonoBehaviour
{
	public List<LocalObjectActive> m_SRDataList = new List<LocalObjectActive>();

	private Dictionary<Languages, GameObject> m_SpriteDicByLanguage = new Dictionary<Languages, GameObject>();

	private void Awake()
	{
		for (int i = 0; i < m_SRDataList.Count; i++)
		{
			m_SpriteDicByLanguage[m_SRDataList[i].m_Language] = m_SRDataList[i].m_GO;
		}
		if ((bool)m_SpriteDicByLanguage[csLocalizationManager.Instance.m_CurrentLanguage])
		{
			m_SpriteDicByLanguage[csLocalizationManager.Instance.m_CurrentLanguage].SetActive(value: true);
		}
	}

	private void OnEnable()
	{
		if ((bool)m_SpriteDicByLanguage[csLocalizationManager.Instance.m_CurrentLanguage])
		{
			m_SpriteDicByLanguage[csLocalizationManager.Instance.m_CurrentLanguage].SetActive(value: true);
		}
	}
}
[Serializable]
public class LocalObjectActive
{
	public Languages m_Language;

	public GameObject m_GO;
}
public class csLocalSpriteRenderer : MonoBehaviour
{
	public string m_ID = "";

	private SpriteRenderer m_Sprite;

	private void Awake()
	{
		m_Sprite = GetComponent<SpriteRenderer>();
	}

	private void OnEnable()
	{
		if (m_Sprite != null)
		{
			m_Sprite.sprite = csLocalizationManager.Instance.GetLocalSprite(m_ID);
		}
	}
}
public class csLocalText : MonoBehaviour
{
	public string m_ID;

	private Text m_Text;

	private TextMeshProUGUI m_Text_tmugui;

	private void Awake()
	{
		m_Text = GetComponent<Text>();
		if (!m_Text)
		{
			m_Text_tmugui = GetComponent<TextMeshProUGUI>();
		}
	}

	private void OnEnable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
		UpdateLocalText();
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void UpdateLocalText()
	{
		if (csLocalizationManager.Instance == null || !csLocalizationManager.Instance.UseLocalization)
		{
			return;
		}
		if ((bool)m_Text)
		{
			m_Text.text = csLocalizationManager.Instance.GetLocalText(m_ID);
			if (m_Text.text.Contains("\\n"))
			{
				m_Text.text = m_Text.text.Replace("\\n", "\n");
			}
		}
		else if ((bool)m_Text_tmugui)
		{
			m_Text_tmugui.text = csLocalizationManager.Instance.GetLocalText(m_ID);
			if (m_Text_tmugui.text.Contains("\\n"))
			{
				m_Text_tmugui.text = m_Text_tmugui.text.Replace("\\n", "\n");
			}
		}
	}
}
public class csLocalTextMesh : MonoBehaviour
{
	public string m_ID;

	public string m_WMRID;

	public string m_OculusID;

	private TextMesh m_Text;

	private void Awake()
	{
		m_Text = GetComponent<TextMesh>();
	}

	private void OnEnable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
		UpdateLocalText();
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void UpdateLocalText()
	{
		if (csGameSettings.CurrentDevice == XRDeviceType.WMR && !string.IsNullOrEmpty(m_WMRID))
		{
			m_Text.text = csLocalizationManager.Instance.GetLocalText(m_WMRID);
		}
		else if (csGameSettings.CurrentDevice == XRDeviceType.Oculus && !string.IsNullOrEmpty(m_OculusID))
		{
			m_Text.text = csLocalizationManager.Instance.GetLocalText(m_OculusID);
		}
		else
		{
			m_Text.text = csLocalizationManager.Instance.GetLocalText(m_ID);
		}
		m_Text.text = m_Text.text.Replace("\\n", "\n");
	}
}
public class csLocalTextMeshPro : MonoBehaviour
{
	public string m_ID;

	public string m_WMRID;

	public string m_OculusID;

	private TextMeshPro m_Text;

	private void Awake()
	{
		m_Text = GetComponent<TextMeshPro>();
	}

	private void OnEnable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
		UpdateLocalText();
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void UpdateLocalText()
	{
		if (!(csLocalizationManager.Instance == null))
		{
			if (csGameSettings.CurrentDevice == XRDeviceType.WMR && !string.IsNullOrEmpty(m_WMRID))
			{
				m_Text.text = csLocalizationManager.Instance.GetLocalText(m_WMRID);
			}
			else if (csGameSettings.CurrentDevice == XRDeviceType.Oculus && !string.IsNullOrEmpty(m_OculusID))
			{
				m_Text.text = csLocalizationManager.Instance.GetLocalText(m_OculusID);
			}
			else
			{
				m_Text.text = csLocalizationManager.Instance.GetLocalText(m_ID);
			}
			if (m_Text.text.Contains("\\n"))
			{
				m_Text.text = m_Text.text.Replace("\\n", "\n");
			}
		}
	}
}
public class Singleton<T> : MonoBehaviour where T : Component
{
	private static readonly object syslock = new object();

	private static T _instance;

	public static T Instance
	{
		get
		{
			if (_instance == null)
			{
				lock (syslock)
				{
					_instance = UnityEngine.Object.FindObjectOfType(typeof(T)) as T;
					if (_instance == null)
					{
						_instance = (T)new GameObject(typeof(T).Name).AddComponent(typeof(T));
					}
				}
			}
			return _instance;
		}
	}
}
public class csMrcManager : MonoBehaviour
{
	public static csMrcManager instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		base.gameObject.SetActive(csGameSettings.canMRC);
	}
}
public class csMrcPanel : MonoBehaviour
{
	[SerializeField]
	private int curEnvIndex;

	public TextMeshProUGUI EnvTitleTMP;

	public bool IsStart;

	public static csMrcPanel instance;

	public Toggle PunchOnToggle;

	public bool IsPunchMeshOn = true;

	private void Awake()
	{
		instance = this;
	}

	private void OnEnable()
	{
		curEnvIndex = 0;
		string localText = csLocalizationManager.Instance.GetLocalText("SkyBoxDetail" + csEnvironmentManager.instance.Env_Main[curEnvIndex].name);
		EnvTitleTMP.text = csEnvironmentManager.instance.Env_GAMENames[curEnvIndex].ToString() + " : " + localText.Substring(0, localText.IndexOf("\\n"));
		if (!csGameSettings.IsMRCPackage)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		IsStart = false;
	}

	public void AddEnvIndex()
	{
		string text = "";
		curEnvIndex++;
		if (curEnvIndex > csEnvironmentManager.instance.Env_Main.Length + csEnvironmentManager.instance.EnvInfo_GAME.Length - 1)
		{
			curEnvIndex = 0;
		}
		if (curEnvIndex <= csEnvironmentManager.instance.Env_Main.Length - 1)
		{
			text = csLocalizationManager.Instance.GetLocalText("SkyBoxDetail" + csEnvironmentManager.instance.Env_Main[curEnvIndex].name);
			EnvTitleTMP.text = csEnvironmentManager.instance.Env_Main[curEnvIndex].name + " : " + text.Substring(0, text.IndexOf("\\n"));
		}
		else
		{
			text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.EnvInfo_GAME[curEnvIndex - csEnvironmentManager.instance.Env_Main.Length]);
			EnvTitleTMP.text = csEnvironmentManager.instance.Env_GAMENames[curEnvIndex - csEnvironmentManager.instance.Env_Main.Length].ToString() + " : " + text.Substring(0, text.IndexOf("\\n"));
		}
	}

	public void DecreaseEnvIndex()
	{
		curEnvIndex--;
		string text = "";
		if (curEnvIndex < 0)
		{
			curEnvIndex = csEnvironmentManager.instance.Env_Main.Length + csEnvironmentManager.instance.EnvInfo_GAME.Length - 1;
		}
		if (curEnvIndex <= csEnvironmentManager.instance.Env_Main.Length - 1)
		{
			text = csLocalizationManager.Instance.GetLocalText("SkyBoxDetail" + csEnvironmentManager.instance.Env_Main[curEnvIndex].name);
			EnvTitleTMP.text = csEnvironmentManager.instance.Env_Main[curEnvIndex].name + " : " + text.Substring(0, text.IndexOf("\\n"));
		}
		else
		{
			text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.EnvInfo_GAME[curEnvIndex - csEnvironmentManager.instance.Env_Main.Length]);
			EnvTitleTMP.text = csEnvironmentManager.instance.Env_GAMENames[curEnvIndex - csEnvironmentManager.instance.Env_Main.Length].ToString() + " : " + text.Substring(0, text.IndexOf("\\n"));
		}
	}

	public void PunchToggleValueChange()
	{
		IsPunchMeshOn = PunchOnToggle.isOn;
	}

	public void StartCourse()
	{
		if (curEnvIndex <= csEnvironmentManager.instance.Env_Main.Length - 1)
		{
			csGameDataTransfer.mrcSelectedEnv = csEnvironmentManager.instance.Env_Main[curEnvIndex].name;
		}
		else
		{
			csGameDataTransfer.mrcSelectedEnv = csEnvironmentManager.instance.Env_GAMENames[curEnvIndex - csEnvironmentManager.instance.Env_Main.Length];
		}
		IsPunchMeshOn = PunchOnToggle.isOn;
		IsStart = true;
	}
}
public class csPCLivMRManager : MonoBehaviour
{
	public static csPCLivMRManager instance;

	public LIV.SDK.Unity.LIV MyLiv;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class ODemo1 : MonoBehaviour
{
	public csSNTool1 tool;

	public string sn;

	public string userid;

	public string result;

	private void Start()
	{
		UnityEngine.Debug.Log(tool.Encode("{\"sn\":\"123\",\"userid\":\"huixiumo\"}"));
	}

	private void OnGUI()
	{
		GUILayout.Box("sn码");
		sn = GUILayout.TextField(sn);
		GUILayout.Box("userid");
		userid = GUILayout.TextField(userid);
		if (GUILayout.Button("发送到测试服"))
		{
			tool.CheckSN(delegate(string r)
			{
				UnityEngine.Debug.Log(r);
				switch (r)
				{
				case "0":
					UnityEngine.Debug.Log("验证失败，该验证码已验证");
					break;
				case "8":
					UnityEngine.Debug.Log("验证通过");
					break;
				case "6":
					UnityEngine.Debug.Log("同一设备重复验证");
					break;
				case "-1":
					UnityEngine.Debug.Log("验证失败");
					break;
				}
			}, sn, userid);
		}
		GUILayout.Label(result);
	}
}
public class csPhotonLobby : MonoBehaviourPunCallbacks
{
	public static csPhotonLobby instance;

	[SerializeField]
	public const byte maxPlayerFollowMode = 8;

	[SerializeField]
	private float timeWaitForPlayer = 10f;

	[SerializeField]
	private string[] gameRoomSceneNames;

	private bool switchingRegions;

	private string inviterName = "";

	private string inviterID = "";

	private Photon.Realtime.FriendInfo inviterInfo;

	private bool matchfailed;

	public PunTeams.Team readyToTeam;

	public static Dictionary<string, RoomInfo> cachedRoomList = new Dictionary<string, RoomInfo>();

	public static List<csRoomInfo> csRoomInfoListInDataBase = new List<csRoomInfo>();

	public static UnityAction OnRoomListUpdated;

	private bool IsRoomCreated;

	private string cacheRoomName;

	private string cacheClassID;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		UpdateRoomInfoDicInDataBase();
	}

	public override void OnConnectedToMaster()
	{
		base.OnConnectedToMaster();
	}

	public void OnJoinedLobbyInit()
	{
		PhotonNetwork.GetCustomRoomList(new TypedLobby("SQLLobby", LobbyType.SqlLobby), "true");
		OnOnOffLineRefresh(isToOnline: false);
	}

	public override void OnJoinedLobby()
	{
		base.OnJoinedLobby();
		readyToTeam = PunTeams.Team.none;
		PhotonNetwork.LocalPlayer.SetTeam(PunTeams.Team.none);
		PhotonNetwork.GetCustomRoomList(new TypedLobby("SQLLobby", LobbyType.SqlLobby), "true");
		OnOnOffLineRefresh(isToOnline: false);
	}

	public override void OnLeftRoom()
	{
		base.OnLeftRoom();
		OnJoinedLobby();
	}

	public void UpdateRoomInfoDicInDataBase()
	{
	}

	public override void OnCreateRoomFailed(short returnCode, string message)
	{
		base.OnCreateRoomFailed(returnCode, message);
		UnityEngine.Debug.LogError("returnCode" + returnCode);
		UnityEngine.Debug.LogError("message" + message);
	}

	public override void OnRoomListUpdate(List<RoomInfo> roomList)
	{
		base.OnRoomListUpdate(roomList);
		UpdateRoomList(roomList);
	}

	public static void UpdateRoomList(List<RoomInfo> roomList)
	{
		UpdateCachedRoomList(roomList);
	}

	private static void UpdateCachedRoomList(List<RoomInfo> roomList)
	{
		foreach (RoomInfo room in roomList)
		{
			if (!room.IsVisible || room.RemovedFromList)
			{
				if (cachedRoomList.ContainsKey(room.Name))
				{
					cachedRoomList.Remove(room.Name);
				}
			}
			else if (cachedRoomList.ContainsKey(room.Name))
			{
				cachedRoomList[room.Name] = room;
			}
			else
			{
				cachedRoomList.Add(room.Name, room);
			}
		}
		if (roomList.Count == 0)
		{
			cachedRoomList.Clear();
		}
		OnRoomListUpdated?.Invoke();
	}

	private IEnumerator WaitForLeave()
	{
		yield return new WaitForSeconds(1f);
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.LeaveRoom();
			DeleteRoomWhenExit();
		}
		while (PhotonNetwork.NetworkingClient.State != ClientState.ConnectedToMasterServer)
		{
			yield return new WaitForSeconds(1f);
		}
		if (!PhotonNetwork.InLobby)
		{
			PhotonNetwork.JoinLobby(new TypedLobby("SQLLobby", LobbyType.SqlLobby));
		}
		while (!PhotonNetwork.InLobby)
		{
			yield return new WaitForEndOfFrame();
		}
		csGameSettings.isLoading = false;
	}

	private void playfabConnectFailed()
	{
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				csGameSettings.needReLogin = true;
				csGameSettings.dontNeedShowLogo = false;
				csGameSettings.isLogined = false;
				SceneManager.LoadScene("GameScene");
			});
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
		});
		csMainMenuManager.instance.OpenPanel(PanelType.disconnect);
	}

	public override void OnDisconnected(DisconnectCause cause)
	{
		base.OnDisconnected(cause);
		if (PhotonNetwork.NetworkClientState == ClientState.Disconnected || PhotonNetwork.NetworkClientState == ClientState.JoinedLobby)
		{
			PhotonNetwork.Disconnect();
		}
		playfabConnectFailed();
	}

	public override void OnJoinRandomFailed(short returnCode, string message)
	{
		base.OnJoinRandomFailed(returnCode, message);
		UnityEngine.Debug.LogError("errorcode = " + returnCode + ";error = " + message);
		if (returnCode == 32760)
		{
			CreatNewRoom(cacheRoomName, cacheClassID);
		}
		else
		{
			matchfailed = true;
		}
	}

	public override void OnJoinRoomFailed(short returnCode, string message)
	{
		base.OnJoinRoomFailed(returnCode, message);
		matchfailed = true;
	}

	public void JoinRoomByName(string customRoomName)
	{
		PhotonNetwork.JoinRoom(customRoomName);
	}

	public void CreatNewRoom(string customRoomName, string classid)
	{
		if (!IsRoomCreated)
		{
			IsRoomCreated = true;
			StartCoroutine(WaitInLobbyWhileCreateRoom(customRoomName, classid));
		}
	}

	private IEnumerator WaitInLobbyWhileCreateRoom(string customRoomName, string classid)
	{
		cacheRoomName = customRoomName;
		cacheClassID = classid;
		csGameSettings.isLoading = true;
		if (PhotonNetwork.NetworkClientState != ClientState.Disconnected)
		{
			if (!PhotonNetwork.InLobby && !PhotonNetwork.OfflineMode)
			{
				PhotonNetwork.JoinLobby(new TypedLobby("SQLLobby", LobbyType.SqlLobby));
			}
			while (!PhotonNetwork.InLobby && !PhotonNetwork.OfflineMode)
			{
				yield return new WaitForSeconds(0.5f);
			}
			byte maxPlayers = 8;
			ExitGames.Client.Photon.Hashtable customRoomProperties = new ExitGames.Client.Photon.Hashtable
			{
				{
					"gm",
					csGameDataTransfer.playMode
				},
				{ "cid", classid },
				{ "State", -1 }
			};
			Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
			roomOptions.PlayerTtl = 2000;
			roomOptions.MaxPlayers = maxPlayers;
			roomOptions.CustomRoomProperties = customRoomProperties;
			roomOptions.PublishUserId = true;
			roomOptions.CustomRoomPropertiesForLobby = new string[3] { "gm", "cid", "State" };
			roomOptions.CleanupCacheOnLeave = false;
			roomOptions.IsVisible = true;
			roomOptions.IsOpen = true;
			Photon.Realtime.RoomOptions roomOptions2 = roomOptions;
			PhotonNetwork.CreateRoom(customRoomName, roomOptions2, new TypedLobby("", LobbyType.SqlLobby));
			IsRoomCreated = false;
		}
	}

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		base.OnPlayerEnteredRoom(newPlayer);
		if (PhotonNetwork.IsMasterClient)
		{
			UpdateRoomInfo(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
		}
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		base.OnPlayerLeftRoom(otherPlayer);
		if (PhotonNetwork.IsMasterClient)
		{
			UpdateRoomInfo(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
		}
	}

	private void UpdateRoomInfo(string name, int count)
	{
	}

	public void DeleteRoomWhenExit()
	{
		_ = PhotonNetwork.CurrentRoom.PlayerCount;
		_ = 1;
	}

	public override void OnCreatedRoom()
	{
		csGameSettings.isLoading = false;
		UnityEngine.Debug.LogError("OnCreatedRoom");
	}

	public override void OnJoinedRoom()
	{
		_ = PhotonNetwork.CurrentRoom.CustomProperties;
		SceneManager.LoadScene("MultiScene");
	}

	public void OnOnOffLineRefresh(bool isToOnline)
	{
	}
}
public class csPhotonLogin : MonoBehaviour
{
	public string PhotonAppIDInternal = "3fef8c57-4d51-4956-9ebd-3e5c837dca6e";
}
public class csPhotonSettings : MonoBehaviour
{
	public static csPhotonSettings instance;

	public static GameObject thisG;

	public string InternalChinaPUNAppId;

	public string OfficialChinaServerIP;

	public string OfficialOverseaServerIP;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (thisG == null)
		{
			thisG = base.gameObject;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class csCloudScriptTest : MonoBehaviour
{
}
public class csCloudSettings : MonoBehaviour
{
	public static csCloudSettings Instance;

	public static GameVersionData curGameVersion;

	public static TitleDataInPlayFab titleDatas;

	public static SportPlanDataInPlayFab sportPlanDatas;

	public static UrlDataInPlayFab urlDatas;

	public static VersionedVideoVersionData VersionedVVersionData;

	public static AnnouncementData AnnData;

	public static SNCheckUrlData SNUrlData;

	public static ServerMaintenData ServerMaintenD;

	public static List<AnnouncementItem> AvaliableAnnDataList = new List<AnnouncementItem>();

	private static DateTime nowTime;

	public static Festival CurrentFestival = Festival.None;

	public static UnityAction<List<AnnouncementItem>> AnnoucementLoadSuccessAct;

	public static Dictionary<string, Sprite> AnnouceImgCacheDic = new Dictionary<string, Sprite>();

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
	}

	public static void Init(GameVersionData version, TitleDataInPlayFab titledata, SportPlanDataInPlayFab sportPlanData, UrlDataInPlayFab urlDataInPlayFab, VersionedVideoVersionData vvd, AnnouncementData ad, SNCheckUrlData snd, ServerMaintenData smd)
	{
		curGameVersion = version;
		titleDatas = titledata;
		sportPlanDatas = sportPlanData;
		urlDatas = urlDataInPlayFab;
		VersionedVVersionData = vvd;
		AnnData = ad;
		SNUrlData = snd;
		ServerMaintenD = smd;
		InitDateTime(JudgeAndSetAnnoucementData);
	}

	public static void InitTimeOnStart()
	{
		nowTime = DateTime.UtcNow;
	}

	public static void InitDateTime(Action OnDone = null)
	{
		csPlayfabServer.Instance.GetServerTime(delegate(DateTime now)
		{
			nowTime = now;
			CheckLimitTime();
			OnDone?.Invoke();
			CurrentFestival = Festival.None;
			if (timeChecker(10, 1, 10, 7))
			{
				CurrentFestival = Festival.NationalDay;
			}
			else
			{
				CurrentFestival = Festival.None;
			}
		});
	}

	private static void CheckLimitTime()
	{
		if (csGameSettings.profile.TimeLock && !((new DateTime(2022, 10, 30) - nowTime).TotalHours > 0.0))
		{
			UnityEngine.Debug.LogError("Reach TimeLimit Quit Game");
			Application.Quit();
		}
	}

	private static bool timeChecker(int minMonth, int minDay, int maxMonth, int maxDay)
	{
		DateTime dateTime = GetNowTime();
		int month = dateTime.Month;
		int day = dateTime.Day;
		if (minMonth < maxMonth)
		{
			if (month < minMonth || month > maxMonth)
			{
				return false;
			}
			if (month == minMonth && day < minDay)
			{
				return false;
			}
			if (month == maxMonth && day > maxDay)
			{
				return false;
			}
		}
		else
		{
			if (minMonth == maxMonth)
			{
				if (month == minMonth && day >= minDay)
				{
					return month <= maxDay;
				}
				return false;
			}
			if (month < minMonth && month > maxMonth)
			{
				return false;
			}
			if (month == minMonth && day < minDay)
			{
				return false;
			}
			if (month == maxMonth && day > maxDay)
			{
				return false;
			}
		}
		return true;
	}

	public static DateTime GetNowTime()
	{
		return nowTime;
	}

	public static string GetClassVideoVersion(string classid, VideoType vt)
	{
		VideoVersionItem videoVersionItem = VersionedVVersionData.VideoVersionDataByVersionList.Find((VideoVersionDataByVersion x) => x.Version == csGameSettings.GameVersion).VersionDataList.Find((VideoVersionItem x) => x.ClassID == classid);
		if (videoVersionItem == null)
		{
			return "_V1";
		}
		string text = "_V";
		switch (vt)
		{
		case VideoType.WarmUp:
			text += videoVersionItem.WPVersion;
			break;
		case VideoType.CoolDown:
			text += videoVersionItem.CDVersion;
			break;
		case VideoType.Follow:
			text += videoVersionItem.FolVersion;
			break;
		}
		return text;
	}

	public static void JudgeAndSetAnnoucementData()
	{
		AvaliableAnnDataList.Clear();
		for (int i = 0; i < AnnData.AnnouncementDataList.Count; i++)
		{
			DateTime dateTime = DateTime.Parse(AnnData.AnnouncementDataList[i].DateStart);
			DateTime dateTime2 = DateTime.Parse(AnnData.AnnouncementDataList[i].DateEnd);
			TimeSpan timeSpan = nowTime - dateTime;
			TimeSpan timeSpan2 = nowTime - dateTime2;
			if (timeSpan.TotalHours >= 0.0 && timeSpan2.TotalHours < 0.0)
			{
				AvaliableAnnDataList.Add(AnnData.AnnouncementDataList[i]);
			}
		}
		Instance.StartCoroutine(PreloadImg());
	}

	private static IEnumerator PreloadImg()
	{
		for (int i = 0; i < AvaliableAnnDataList.Count; i++)
		{
			yield return Instance.StartCoroutine(GetAnnouceImage(AvaliableAnnDataList[i].ImgTitleURLCN, csAssetLoader.URLHead + "Annoucement/" + AvaliableAnnDataList[i].ImgTitleURLCN + ".png"));
			yield return Instance.StartCoroutine(GetAnnouceImage(AvaliableAnnDataList[i].ImgDetailURLCN, csAssetLoader.URLHead + "Annoucement/" + AvaliableAnnDataList[i].ImgDetailURLCN + ".png"));
			yield return Instance.StartCoroutine(GetAnnouceImage(AvaliableAnnDataList[i].ImgTitleURLEN, csAssetLoader.URLHead + "Annoucement/" + AvaliableAnnDataList[i].ImgTitleURLEN + ".png"));
			yield return Instance.StartCoroutine(GetAnnouceImage(AvaliableAnnDataList[i].ImgDetailURLEN, csAssetLoader.URLHead + "Annoucement/" + AvaliableAnnDataList[i].ImgDetailURLEN + ".png"));
		}
		yield return null;
		AnnoucementLoadSuccessAct?.Invoke(AvaliableAnnDataList);
	}

	private static IEnumerator GetAnnouceImage(string id, string url)
	{
		if (string.IsNullOrEmpty(url))
		{
			yield break;
		}
		WWW www = new WWW(url);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			Texture2D texture = www.texture;
			Sprite value = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
			if (!AnnouceImgCacheDic.ContainsKey(id))
			{
				AnnouceImgCacheDic.Add(id, value);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("GetAnnouceImage:" + www.error);
		}
	}

	public static void GetAnnouceImageFromCloud(string id, UnityAction<int, Sprite> onSpriteGet)
	{
		if (AnnouceImgCacheDic.ContainsKey(id))
		{
			onSpriteGet(1, AnnouceImgCacheDic[id]);
		}
		else
		{
			onSpriteGet(0, null);
		}
	}
}
public class csCloudStorage : MonoBehaviour
{
	public static csCloudStorage instance;

	public static GameObject thisG;

	public static bool HasInitUserData;

	private Dictionary<string, string> userdata = new Dictionary<string, string>();

	public static bool isFirstLogin = true;

	public static bool isFirstLoginToday = true;

	public PlayerInfoInPlayfab m_PlayerInfoInPlayfab = new PlayerInfoInPlayfab();

	public playerPlayInfo m_PlayerPlayInfo = new playerPlayInfo();

	public PlayerPlanDataInPlayFab m_PlayerPlanData = new PlayerPlanDataInPlayFab();

	public PlayerClassHistoryData m_PlayerClassHistoryData = new PlayerClassHistoryData();

	public daySportInfoDataInPlayfab m_PlayerCareerSportData = new daySportInfoDataInPlayfab();

	public PlayerOrderData m_PlayerOrderData = new PlayerOrderData();

	public PlayerClassScoreData m_PlayerClassScoreData = new PlayerClassScoreData();

	public clockInData m_PlayerClockInData = new clockInData();

	public PlayerDailyGoalData m_PlayerDailyGoalData = new PlayerDailyGoalData();

	public PlayerAllTimeBeheaviorData m_PlayerAllTimeBeheaviorData = new PlayerAllTimeBeheaviorData();

	public bool isDeveloper;

	public string userNickName => m_PlayerInfoInPlayfab.NickName;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			thisG = base.gameObject;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
	}

	public void SaveUserData(Dictionary<string, string> data, Action<bool, string> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		dictionary.Add("PlayerInfoInPlayfab", JsonUtility.ToJson(m_PlayerInfoInPlayfab));
		dictionary.Add("PicoAccountInfoInPlayfab", JsonUtility.ToJson(new PicoAccountInfo(csPlayerPicoDataManager.instance.m_PicoAccountInfo)));
		dictionary.Add("PlayerPlayInfoInPlayfab", JsonUtility.ToJson(m_PlayerPlayInfo));
		dictionary.Add("PlayerClassHistoryData", JsonUtility.ToJson(m_PlayerClassHistoryData));
		dictionary.Add("PlayerClockInData", JsonUtility.ToJson(m_PlayerClockInData));
		dictionary.Add("PlayerPlanData", JsonUtility.ToJson(m_PlayerPlanData));
		dictionary.Add("PlayerCareerData", JsonUtility.ToJson(m_PlayerCareerSportData));
		dictionary.Add("PlayerOrderData", csPlayerOrderManager.instance.EncodeOrderData(m_PlayerOrderData));
		dictionary.Add("PlayerAllTimeBeheaviorData", JsonUtility.ToJson(m_PlayerAllTimeBeheaviorData));
		dictionary.Add("PlayerClassScoreData", JsonUtility.ToJson(m_PlayerClassScoreData));
		dictionary.Add("PlayerDailyGoalData", JsonUtility.ToJson(m_PlayerDailyGoalData));
		csPlayfabServer.Instance.UpdateUserData(dictionary, delegate(bool result, string error)
		{
			if (result)
			{
				if (callback != null)
				{
					callback(arg1: true, "");
				}
			}
			else if (callback != null)
			{
				callback(arg1: false, "");
			}
		});
	}

	public bool OrderDataIsReady()
	{
		return userdata.ContainsKey("PlayerOrderData");
	}

	public void Init(Dictionary<string, string> data)
	{
		userdata.Clear();
		userdata = new Dictionary<string, string>(data);
		if (!string.IsNullOrEmpty(data["PlayerInfoInPlayfab"]))
		{
			m_PlayerInfoInPlayfab = JsonUtility.FromJson<PlayerInfoInPlayfab>(userdata["PlayerInfoInPlayfab"]);
		}
		if (!string.IsNullOrEmpty(data["PlayerPlayInfoInPlayfab"]))
		{
			m_PlayerPlayInfo = JsonUtility.FromJson<playerPlayInfo>(userdata["PlayerPlayInfoInPlayfab"]);
		}
		if (!string.IsNullOrEmpty(data["PlayerOrderData"]))
		{
			string text = userdata["PlayerOrderData"];
			m_PlayerOrderData = csPlayerOrderManager.instance.DecodeOrderData(text);
			csPlayerOrderManager.instance.Init(m_PlayerOrderData);
			UnityEngine.Debug.LogError("PlayerOrderData:" + EncryptTools.DecryptDES(text));
		}
		else
		{
			csPlayerOrderManager.instance.Init(new PlayerOrderData());
		}
		if (!string.IsNullOrEmpty(data["PlayerClassHistoryData"]))
		{
			m_PlayerClassHistoryData = JsonUtility.FromJson<PlayerClassHistoryData>(userdata["PlayerClassHistoryData"]);
		}
		if (userdata.ContainsKey("isDeveloper") && !string.IsNullOrEmpty(userdata["isDeveloper"]))
		{
			isDeveloper = userdata["isDeveloper"] == "1";
		}
		if (userdata.ContainsKey("PlayerPlanData") && !string.IsNullOrEmpty(data["PlayerPlanData"]))
		{
			m_PlayerPlanData = JsonUtility.FromJson<PlayerPlanDataInPlayFab>(userdata["PlayerPlanData"]);
		}
		if (userdata.ContainsKey("PlayerCareerData") && !string.IsNullOrEmpty(data["PlayerCareerData"]))
		{
			m_PlayerCareerSportData = JsonUtility.FromJson<daySportInfoDataInPlayfab>(userdata["PlayerCareerData"]);
		}
		if (data.ContainsKey("PlayerClockInData") && !string.IsNullOrEmpty(data["PlayerClockInData"]))
		{
			m_PlayerClockInData = JsonUtility.FromJson<clockInData>(userdata["PlayerClockInData"]);
			if (m_PlayerClockInData.aim < 1)
			{
				m_PlayerClockInData.aim = 1;
			}
			if (m_PlayerClockInData.aim > 7)
			{
				m_PlayerClockInData.aim = 7;
			}
		}
		if (data.ContainsKey("PlayerClassScoreData") && !string.IsNullOrEmpty(data["PlayerClassScoreData"]))
		{
			m_PlayerClassScoreData = JsonUtility.FromJson<PlayerClassScoreData>(userdata["PlayerClassScoreData"]);
		}
		else
		{
			m_PlayerClassScoreData = new PlayerClassScoreData();
		}
		if (userdata.ContainsKey("PlayerAllTimeBeheaviorData") && !string.IsNullOrEmpty(data["PlayerAllTimeBeheaviorData"]))
		{
			m_PlayerAllTimeBeheaviorData = JsonUtility.FromJson<PlayerAllTimeBeheaviorData>(userdata["PlayerAllTimeBeheaviorData"]);
		}
		else
		{
			m_PlayerAllTimeBeheaviorData = new PlayerAllTimeBeheaviorData();
		}
		if (data.ContainsKey("PlayerDailyGoalData") && !string.IsNullOrEmpty(data["PlayerDailyGoalData"]))
		{
			m_PlayerDailyGoalData = JsonUtility.FromJson<PlayerDailyGoalData>(userdata["PlayerDailyGoalData"]);
			return;
		}
		UnityEngine.Debug.Log("<color=yellow>===new PlayerDailyGoalData()===</color>");
		m_PlayerDailyGoalData = new PlayerDailyGoalData();
	}

	public void SetClassAsClassHistory(string classID, ClassHistoryState hs)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		int num = m_PlayerClassHistoryData.HistoryClassList.FindIndex((ClassData x) => x.ClassID == classID);
		if (num >= 0)
		{
			if (m_PlayerClassHistoryData.HistoryClassList[num].HistoryState == ClassHistoryState.UnFinished)
			{
				m_PlayerClassHistoryData.HistoryClassList[num].HistoryState = hs;
			}
			ClassData item = new ClassData(m_PlayerClassHistoryData.HistoryClassList[num].ClassID, m_PlayerClassHistoryData.HistoryClassList[num].HistoryState);
			m_PlayerClassHistoryData.HistoryClassList.RemoveAt(num);
			m_PlayerClassHistoryData.HistoryClassList.Insert(0, item);
		}
		else
		{
			m_PlayerClassHistoryData.HistoryClassList.Insert(0, new ClassData(classID, hs));
		}
		while (m_PlayerClassHistoryData.HistoryClassList.Count > 100)
		{
			m_PlayerClassHistoryData.HistoryClassList.RemoveAt(m_PlayerClassHistoryData.HistoryClassList.Count - 1);
		}
		UpdatePlayerHistoryInfo(delegate
		{
		});
	}

	public void SetPlanAsCollection(string PlanID)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			if (m_PlayerClassHistoryData.CollectionPlanList.Contains(PlanID))
			{
				m_PlayerClassHistoryData.CollectionPlanList.Remove(PlanID);
			}
			else
			{
				m_PlayerClassHistoryData.CollectionPlanList.Add(PlanID);
			}
			UpdatePlayerHistoryInfo(delegate
			{
			});
		}
	}

	public void SetOrRemoveClassCollection(string classID, bool isSet)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		int num = m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classID);
		GameSongData data = GameData.instance.SongLevelData.Find((GameSongData x) => x.ClassID == classID);
		if (isSet)
		{
			if (num < 0)
			{
				m_PlayerClassHistoryData.CollectionClassList.Add(new ClassData(classID, ClassHistoryState.Collection));
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.favorite_class, new Dictionary<string, object>
				{
					{ "status", "favorite" },
					{
						"class_header",
						JsonUtility.ToJson(new class_header(data))
					}
				});
			}
		}
		else if (num >= 0)
		{
			m_PlayerClassHistoryData.CollectionClassList.RemoveAt(num);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.favorite_class, new Dictionary<string, object>
			{
				{ "status", "cancel" },
				{
					"class_header",
					JsonUtility.ToJson(new class_header(data))
				}
			});
		}
		UpdatePlayerHistoryInfo(delegate
		{
		});
	}

	private void UpdatePlayerHistoryInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string str = JsonUtility.ToJson(m_PlayerClassHistoryData);
		dictionary.Add("PlayerClassHistoryData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerClassHistoryData"] = str;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void ModifiDataAfterUpdate()
	{
		if (string.IsNullOrEmpty(userNickName))
		{
			string nickID = "XXX";
			UpdateNickName(nickID, null);
		}
	}

	public void UpdateNickName(string nickID, Action<bool, string> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		PlayerInfoInPlayfab temp = new PlayerInfoInPlayfab(nickID, m_PlayerInfoInPlayfab.NickName, m_PlayerInfoInPlayfab.Height, m_PlayerInfoInPlayfab.Weight, m_PlayerInfoInPlayfab.Age, m_PlayerInfoInPlayfab.ArmLength, m_PlayerInfoInPlayfab.SquatHeight, m_PlayerInfoInPlayfab.isMale, m_PlayerInfoInPlayfab.LikeTabs, m_PlayerInfoInPlayfab.playedClass, m_PlayerInfoInPlayfab.classCollection);
		string str = JsonUtility.ToJson(temp);
		m_PlayerInfoInPlayfab = temp;
		dictionary.Add("PlayerInfoInPlayfab", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerInfoInPlayfab"] = str;
				m_PlayerInfoInPlayfab = temp;
				if (callback != null)
				{
					callback(arg1: true, "");
				}
				csPlayfabServer.Instance.GetPlayerProfile_NameTag(delegate(string CurrentName)
				{
					if (string.IsNullOrEmpty(CurrentName))
					{
						csPlayfabServer.Instance.AddPlayerTag("Name:" + nickID);
					}
					else
					{
						csPlayfabServer.Instance.ReNameWithTag(CurrentName, "Name:" + nickID);
					}
				});
			}
		});
	}

	public void UpdatePlayerInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		PlayerInfoInPlayfab temp = new PlayerInfoInPlayfab(m_PlayerInfoInPlayfab.NickID, m_PlayerInfoInPlayfab.NickName, m_PlayerInfoInPlayfab.Height, m_PlayerInfoInPlayfab.Weight, m_PlayerInfoInPlayfab.Age, m_PlayerInfoInPlayfab.ArmLength, m_PlayerInfoInPlayfab.SquatHeight, m_PlayerInfoInPlayfab.isMale, m_PlayerInfoInPlayfab.LikeTabs, m_PlayerInfoInPlayfab.playedClass, m_PlayerInfoInPlayfab.classCollection);
		string str = JsonUtility.ToJson(temp);
		m_PlayerInfoInPlayfab = temp;
		dictionary.Add("PlayerInfoInPlayfab", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerInfoInPlayfab"] = str;
				m_PlayerInfoInPlayfab = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void UpdatePicoAccountInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		PicoAccountInfo obj = new PicoAccountInfo(csPlayerPicoDataManager.instance.m_PicoAccountInfo);
		string str = JsonUtility.ToJson(obj);
		dictionary.Add("PicoAccountInfoInPlayfab", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PicoAccountInfoInPlayfab"] = str;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void changeClockInAimDays(int i, Action callback)
	{
		m_PlayerClockInData.changeAim(i);
		UpdateClockInData(callback);
	}

	public void addClockInDate(Action callback)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			csCloudSettings.InitDateTime(delegate
			{
				m_PlayerClockInData.addClockInDate(csCloudSettings.GetNowTime());
				UpdateClockInData(callback);
				DateTime now = DateTime.Now;
				csTalkingData.Instance.SendEvent("DK01_每日打卡", 1.0, new Dictionary<string, object> { 
				{
					"打卡设备：" + Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice),
					$"打卡时间时间段：{now.Year:D}年{now.Month:D}月{now.Day:D}日 {now.Hour:D}点—{now.Hour + 1:D}点"
				} });
			});
		}
	}

	public void resetPlayerCareerData(daySportInfoData data, Action callback)
	{
		m_PlayerCareerSportData.resetInfo(data);
		UpdateCareerData(callback);
	}

	public void addPlayerCareerData(daySportInfoData data, Action callback)
	{
		m_PlayerCareerSportData.addInfo(data);
	}

	public void addPlayerCareerDataWithMode(SportInfoDataWithMode data, string date, Action callback)
	{
		m_PlayerCareerSportData.addInfo(data, date);
	}

	public void UpdateCareerData(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		daySportInfoDataInPlayfab temp = new daySportInfoDataInPlayfab(m_PlayerCareerSportData.careerInfoList);
		string str = JsonUtility.ToJson(temp);
		m_PlayerCareerSportData = temp;
		dictionary.Add("PlayerCareerData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerCareerData"] = str;
				m_PlayerCareerSportData = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void UpdateClockInData(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		clockInData temp = new clockInData(m_PlayerClockInData.aim, m_PlayerClockInData.clockInDates);
		string str = JsonUtility.ToJson(temp);
		m_PlayerClockInData = temp;
		dictionary.Add("PlayerClockInData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerClockInData"] = str;
				m_PlayerClockInData = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void UpdatePlayerPlayInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		playerPlayInfo temp = new playerPlayInfo(m_PlayerPlayInfo.dayCal, m_PlayerPlayInfo.weekCal, m_PlayerPlayInfo.monthCal, m_PlayerPlayInfo.precision, m_PlayerPlayInfo.power, m_PlayerPlayInfo.allCal, m_PlayerPlayInfo.sumPoint);
		string str = JsonUtility.ToJson(temp);
		m_PlayerPlayInfo = temp;
		dictionary.Add("PlayerPlayInfoInPlayfab", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerPlayInfoInPlayfab"] = str;
				m_PlayerPlayInfo = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void UpdatePlayerPlanInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		PlayerPlanDataInPlayFab temp = new PlayerPlanDataInPlayFab(m_PlayerPlanData.historyPlanList);
		string str = JsonUtility.ToJson(temp);
		m_PlayerPlanData = temp;
		dictionary.Add("PlayerPlanData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerPlanData"] = str;
				m_PlayerPlanData = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public void setPlayerPlanFinish(string PlanID, int day, string classID)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayerPlanDetailData plan = m_PlayerPlanData.getPlan(PlanID);
		for (int i = 0; i < plan.PlanDayClassList.Count; i++)
		{
			if (day != plan.PlanDayClassList[i].dayIndex)
			{
				continue;
			}
			for (int num = 0; num < plan.PlanDayClassList[i].classIDs.Count; i++)
			{
				if (classID == plan.PlanDayClassList[i].classIDs[num])
				{
					plan.PlanDayClassList[i].isFinish[num] = true;
					break;
				}
			}
			break;
		}
	}

	public void SetPlayerOrderData(DateTime beginTime, DateTime endTime, OrderType type, OrderDevice odv, Action<bool> callback)
	{
		m_PlayerOrderData.InitData(beginTime.ToString(new CultureInfo("zh-cn")), endTime.ToString(new CultureInfo("zh-cn")), type, odv);
		UpdatePlayerOrderData(callback);
	}

	public void UpdatePlayerOrderData(Action<bool> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string str = csPlayerOrderManager.instance.EncodeOrderData(m_PlayerOrderData);
		dictionary.Add("PlayerOrderData", str);
		m_PlayerOrderData = csPlayerOrderManager.instance.DecodeOrderData(str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerOrderData"] = str;
				m_PlayerOrderData = csPlayerOrderManager.instance.DecodeOrderData(str);
				csPlayerOrderManager.instance.RefreshData(m_PlayerOrderData);
				UnityEngine.Debug.LogError(m_PlayerOrderData.OrderDevice);
				UnityEngine.Debug.LogError(m_PlayerOrderData.beginOrderTime);
				UnityEngine.Debug.LogError("玩家订阅数据成功-->>>" + str);
				callback?.Invoke(obj: true);
			}
			else
			{
				callback?.Invoke(obj: false);
			}
		});
	}

	public void AddNewBeheaviorData(BeheaviorType beheaviorType, int num, string id = "")
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		DateTime nowTime = csCloudSettings.GetNowTime();
		string text = $"{nowTime.Year:D}/{nowTime.Month:D}/{nowTime.Day:D}";
		DailyBeheaviorData dailyClass = new DailyBeheaviorData();
		if (m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList.Count == 0 || m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList == null)
		{
			dailyClass = AddDailyBeheaviorData(dailyClass, text);
			m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList.Add(dailyClass);
		}
		else
		{
			dailyClass = m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList[m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList.Count - 1];
		}
		if (dailyClass.DateTime != text)
		{
			dailyClass = AddDailyBeheaviorData(dailyClass, text);
			m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList.Add(dailyClass);
		}
		switch (beheaviorType)
		{
		case BeheaviorType.ClassFinishNum:
		{
			bool flag = false;
			foreach (ClassBeheavior dailyBeheavior in dailyClass.DailyBeheaviorList)
			{
				if (dailyBeheavior.ID == id)
				{
					flag = true;
					dailyBeheavior.Num += num;
				}
			}
			if (!flag)
			{
				ClassBeheavior classBeheavior = new ClassBeheavior();
				classBeheavior.m_BeheaviorType = BeheaviorType.ClassFinishNum;
				classBeheavior.ID = id;
				classBeheavior.Num += num;
				dailyClass.DailyBeheaviorList.Add(classBeheavior);
			}
			break;
		}
		case BeheaviorType.CalCost:
			foreach (ClassBeheavior dailyBeheavior2 in dailyClass.DailyBeheaviorList)
			{
				if (dailyBeheavior2.m_BeheaviorType == BeheaviorType.CalCost)
				{
					dailyBeheavior2.Num += num;
				}
			}
			break;
		}
		m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList[m_PlayerAllTimeBeheaviorData.AllTimeBeheaviorList.Count - 1] = dailyClass;
		UpdatePlayerBeheaviorData(null);
	}

	private DailyBeheaviorData AddDailyBeheaviorData(DailyBeheaviorData dailyClass, string currentDate)
	{
		dailyClass.DateTime = currentDate;
		ClassBeheavior classBeheavior = new ClassBeheavior();
		classBeheavior.m_BeheaviorType = BeheaviorType.CalCost;
		classBeheavior.ID = "Calorie";
		classBeheavior.Num = 0;
		dailyClass.DailyBeheaviorList.Add(classBeheavior);
		return dailyClass;
	}

	private void UpdatePlayerBeheaviorData(Action<bool> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string value = JsonUtility.ToJson(m_PlayerAllTimeBeheaviorData);
		dictionary.Add("PlayerAllTimeBeheaviorData", value);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				callback?.Invoke(obj: true);
			}
			else
			{
				callback?.Invoke(obj: false);
			}
		});
	}

	private void UpdatePlayerScoreInfo(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string str = JsonUtility.ToJson(m_PlayerClassScoreData);
		dictionary.Add("PlayerClassScoreData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerClassScoreData"] = str;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}

	public long GetClassHistorySum()
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return 0L;
		}
		long sum = 0L;
		foreach (ClassData cd in m_PlayerClassHistoryData.HistoryClassList)
		{
			char[] array = cd.ClassID.ToCharArray();
			if (array.Length != 0 && array[0] != '1')
			{
				continue;
			}
			ClassScoreData classScoreData = m_PlayerClassScoreData.ScoreList.Find((ClassScoreData x) => x.ClassID == cd.ClassID);
			if (classScoreData != null)
			{
				sum += classScoreData.Score;
				continue;
			}
			ClassScoreData csd = new ClassScoreData();
			csPicoLeaderboard.Instance.GetMyLeaderBoardData(cd.ClassID, delegate(List<LeaderboardEntry> entry, string log)
			{
				if (entry.Count > 0)
				{
					csd.ClassID = cd.ClassID;
					csd.Score = entry[0].Score;
					m_PlayerClassScoreData.ScoreList.Add(csd);
					sum += entry[0].Score;
				}
			}, delegate
			{
			});
		}
		UpdatePlayerScoreInfo(delegate
		{
		});
		return sum;
	}

	public void UpdateHistorySum(string classid, long score)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			ClassScoreData classScoreData = m_PlayerClassScoreData.ScoreList.Find((ClassScoreData x) => x.ClassID == classid);
			if (classScoreData != null && classScoreData.Score < score)
			{
				classScoreData.Score = score;
				UpdatePlayerScoreInfo(delegate
				{
				});
			}
			else if (classScoreData == null)
			{
				ClassScoreData classScoreData2 = new ClassScoreData();
				classScoreData2.ClassID = classid;
				classScoreData2.Score = score;
				m_PlayerClassScoreData.ScoreList.Add(classScoreData2);
				UpdatePlayerScoreInfo(delegate
				{
				});
			}
		}
	}

	public void SetPlayerDailyGoal(int targetPlayTime, Action callback)
	{
		m_PlayerDailyGoalData.SetAim(targetPlayTime);
		UpdatePlayerDailyGoalData(callback);
	}

	public void UpdateDailyGoalState(float _cal, float _playTime, Action callback)
	{
		m_PlayerDailyGoalData.UpdateAimState(_cal, _playTime);
		UpdatePlayerDailyGoalData(callback);
	}

	public void AddDailyGoalFinishDate(Action callback)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			csCloudSettings.InitDateTime(delegate
			{
				m_PlayerDailyGoalData.AddFinishDate(csCloudSettings.GetNowTime());
				UpdatePlayerDailyGoalData(callback);
			});
		}
	}

	public void UpdatePlayerDailyGoalData(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		PlayerDailyGoalData temp = new PlayerDailyGoalData(m_PlayerDailyGoalData.palyTimeAim, m_PlayerDailyGoalData.calAim, m_PlayerDailyGoalData.calAimState, m_PlayerDailyGoalData.palyTimeAimState, m_PlayerDailyGoalData.finishDates);
		string str = JsonUtility.ToJson(temp);
		m_PlayerDailyGoalData = temp;
		dictionary.Add("PlayerDailyGoalData", str);
		SaveUserData(dictionary, delegate(bool state, string error)
		{
			if (state)
			{
				userdata["PlayerDailyGoalData"] = str;
				m_PlayerDailyGoalData = temp;
				if (callback != null)
				{
					callback();
				}
			}
		});
	}
}
public class csEyeFadeManager : MonoBehaviour
{
	public static csEyeFadeManager Instance;

	public Image[] BlackImg;

	public GameObject[] AllPanel;

	public GameObject LoadingDotPanel;

	public GameObject TextHintPanel;

	public GameObject LogoTextPanel;

	public GameObject LogoAnimPanel;

	public GameObject ProgressBarPanel;

	private Tweener[] Tweener = new Tweener[2];

	private bool isFadeToBlack;

	public Image FillImg;

	public RectTransform FillRect;

	public float FillMin = 10f;

	public float FillMax = 150f;

	private void Awake()
	{
		Instance = this;
		Image[] blackImg = BlackImg;
		for (int i = 0; i < blackImg.Length; i++)
		{
			blackImg[i].enabled = false;
		}
		ShowAllPanel(isShow: false);
	}

	private void ShowAllPanel(bool isShow)
	{
		GameObject[] allPanel = AllPanel;
		for (int i = 0; i < allPanel.Length; i++)
		{
			allPanel[i].SetActive(isShow);
		}
	}

	public void BindToPlayer(Transform CameraT)
	{
		base.transform.SetParent(CameraT);
		Transform obj = base.transform;
		Vector3 localPosition = (base.transform.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
	}

	public void FadeToBlackWithMode(EyeFadeMode mode, UnityAction OnFadeDone, float t = 2f)
	{
		StartCoroutine(IEFadeToBlackWithMode(mode, OnFadeDone, t));
	}

	public void setToBlack()
	{
		Image[] blackImg = BlackImg;
		foreach (Image obj in blackImg)
		{
			obj.color = new Color(0f, 0f, 0f, 1f);
			obj.enabled = true;
		}
		isFadeToBlack = true;
	}

	private IEnumerator IEFadeToBlackWithMode(EyeFadeMode mode, UnityAction OnFadeDone, float t = 2f)
	{
		isFadeToBlack = true;
		csGameSettings.isLoading = true;
		Image[] blackImg = BlackImg;
		foreach (Image obj in blackImg)
		{
			obj.color = new Color(0f, 0f, 0f, 0f);
			obj.enabled = true;
		}
		if (Tweener[0] != null && !Tweener[0].IsComplete())
		{
			Tweener[0].Kill();
		}
		if (Tweener[1] != null && !Tweener[1].IsComplete())
		{
			Tweener[1].Kill();
		}
		Tweener[0] = BlackImg[0].DOFade(1f, t);
		Tweener[1] = BlackImg[1].DOFade(1f, t);
		ShowAllPanel(isShow: false);
		switch (mode)
		{
		case EyeFadeMode.LoadingDot:
			LoadingDotPanel.SetActive(value: true);
			break;
		case EyeFadeMode.ProgressBar:
			ProgressBarPanel.SetActive(value: true);
			break;
		}
		yield return new WaitForSecondsRealtime(t);
		csGameSettings.isLoading = false;
		OnFadeDone?.Invoke();
		_ = mode;
	}

	public void FadeToGameWithMode(EyeFadeMode mode, UnityAction OnFadeDone, float t = 2f)
	{
		StartCoroutine(IEFadeToGame(mode, OnFadeDone, t));
	}

	private IEnumerator IEFadeToGame(EyeFadeMode mode, UnityAction OnFadeDone, float t = 2f)
	{
		isFadeToBlack = false;
		Image[] blackImg = BlackImg;
		for (int i = 0; i < blackImg.Length; i++)
		{
			blackImg[i].color = new Color(0f, 0f, 0f, 1f);
		}
		if (Tweener[0] != null && !Tweener[0].IsComplete())
		{
			Tweener[0].Kill();
		}
		if (Tweener[1] != null && !Tweener[1].IsComplete())
		{
			Tweener[1].Kill();
		}
		Tweener[0] = BlackImg[0].DOFade(0f, t);
		ShowAllPanel(isShow: false);
		switch (mode)
		{
		case EyeFadeMode.LoadingDot:
			LoadingDotPanel.SetActive(value: false);
			break;
		case EyeFadeMode.ProgressBar:
			ProgressBarPanel.SetActive(value: false);
			break;
		}
		yield return new WaitForSecondsRealtime(0.5f);
		Tweener[1] = BlackImg[1].DOFade(0f, t - 0.5f);
		yield return new WaitForSecondsRealtime(t - 0.5f);
		OnFadeDone?.Invoke();
		_ = mode;
		if (!isFadeToBlack)
		{
			blackImg = BlackImg;
			for (int i = 0; i < blackImg.Length; i++)
			{
				blackImg[i].enabled = false;
			}
		}
	}

	public void SetFillAmount(float percent)
	{
		float x = FillMin + (FillMax - FillMin) * percent;
		FillRect.sizeDelta = new Vector2(x, FillRect.sizeDelta.y);
	}
}
public class csLogin : MonoBehaviour
{
	public static csLogin instance;

	public bool needShowDisconnectPanel;

	private bool BreakTTLShow;

	public bool isGetPlayfabData;

	public string username = "";

	private bool isFirstLogin;

	public string userid = "";

	public bool TTLShow;

	private int step;

	public static float tokenT;

	private static bool VersionHintIsShow;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		needShowDisconnectPanel = false;
		csFirstLoginPanel.isGoingtoGuide = false;
	}

	public void Restart()
	{
		StartCoroutine(Start());
	}

	public void openDisconnectPanel()
	{
		BreakTTLShow = true;
		StartCoroutine(IEopenDisconnectPanel());
	}

	private IEnumerator IEopenDisconnectPanel()
	{
		csLevelChoosePanel.instance.playerinfotitle.SetActive(value: false);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
		while (!csPlayer.instance || !csPlayer.instance.welcomeOver || !csEyeFadeManager.Instance)
		{
			yield return null;
		}
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
			csMainMenuManager.instance.OpenPanel(PanelType.disconnect, "1");
		});
	}

	private IEnumerator Start()
	{
		csByteEventTracking.Instance.StartTimekeeping();
		isFirstLogin = false;
		csGameSettings.isLogined = false;
		yield return StartCoroutine(OfflineVersionSet());
		yield return StartCoroutine(Login());
		if (!isFirstLogin)
		{
			while (!csGameSettings.isLogined)
			{
				yield return null;
			}
			yield return StartCoroutine(InitData(needinitsettings: true));
			while (!csPlayer.instance || !csPlayer.instance.welcomeOver || !csEyeFadeManager.Instance)
			{
				yield return null;
			}
			if (!csFirstLoginPanel.isGoingtoGuide)
			{
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
				{
				});
				csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
			}
			long classHistorySum = csCloudStorage.instance.GetClassHistorySum();
			csLevelChoosePanel.instance.scoreRankPanel.Init((int)classHistorySum);
			csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: true);
			csLevelChoosePanel.instance.tagsx5.SetActive(value: true);
			csPlayerOrderManager.instance.OnEnterGame();
		}
	}

	private IEnumerator OfflineVersionSet()
	{
		bool IsGetFeedback = false;
		csSelfHostServerAPI.instance.GetOfflineSwitch(delegate(string s)
		{
			OfflineSwitchResult offlineSwitchResult = JsonUtility.FromJson<OfflineSwitchResult>(s);
			if (offlineSwitchResult.OverAllSwitch)
			{
				csGameSettings.IsOfflineVersion = true;
				csGameSettings.TempVIPEndDate = TryParseDateTime(offlineSwitchResult.TempAccountVipEndDate);
				csGameSettings.OfflineHint = offlineSwitchResult.AnnText;
			}
			IsGetFeedback = true;
		}, delegate
		{
			IsGetFeedback = true;
		});
		while (!IsGetFeedback)
		{
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator ForceOfflineVersion()
	{
		OfflineSwitchResult offlineSwitchResult = new OfflineSwitchResult();
		offlineSwitchResult.OverAllSwitch = true;
		offlineSwitchResult.TempAccountVipEndDate = new DateTime(2023, 12, 31).ToString();
		offlineSwitchResult.AnnText = "Swift测试专用";
		if (offlineSwitchResult.OverAllSwitch)
		{
			csGameSettings.IsOfflineVersion = true;
			csGameSettings.TempVIPEndDate = TryParseDateTime(offlineSwitchResult.TempAccountVipEndDate);
			csGameSettings.OfflineHint = offlineSwitchResult.AnnText;
		}
		bool IsGetFeedback = true;
		while (!IsGetFeedback)
		{
			yield return new WaitForEndOfFrame();
		}
	}

	private DateTime TryParseDateTime(string dt)
	{
		if (DateTime.TryParse(dt, out var result))
		{
			return result;
		}
		if (DateTime.TryParseExact(dt, "dd/MM/yyyy", null, DateTimeStyles.None, out result))
		{
			return result;
		}
		DateTime.TryParseExact(dt, "MM/dd/yyyy", null, DateTimeStyles.None, out result);
		return result;
	}

	private IEnumerator Login()
	{
		isFirstLogin = false;
		csPlayerPicoDataManager.instance.isGetInfo = false;
		if (csGameSettings.currentChannel == ChannelType.PicoXR)
		{
			if (csGameSettings.profile.UseNoAccount)
			{
				csPlayerPicoDataManager.instance.isGetInfo = true;
			}
			else
			{
				csPlayerPicoDataManager.instance.PicoLogin();
			}
			UnityEngine.Debug.LogError("csPlayerPicoDataManager.instance.isGetInfo Start:" + Time.timeSinceLevelLoad);
			while (!csPlayerPicoDataManager.instance.isGetInfo)
			{
				yield return new WaitForSeconds(0.5f);
			}
			UnityEngine.Debug.LogError("csPlayerPicoDataManager.instance.isGetInfo End:" + Time.timeSinceLevelLoad);
		}
		else
		{
			csPlayerPicoDataManager.instance.isGetInfo = true;
		}
		userid = SystemInfo.deviceUniqueIdentifier + "V1320230523v8";
		username = "OlympiaTest";
		if (!csGameSettings.profile.UseNoAccount && csGameSettings.currentChannel == ChannelType.PicoXR)
		{
			userid = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID;
			username = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName;
		}
		int state = -2;
		if (!csPlayfabServer.Instance.IsClientLoggedIn)
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_03" },
				{ "step_name", "GetTheBackEndData" },
				{ "status", "start" }
			});
			float startTime = Time.realtimeSinceStartup;
			csPlayfabServer.Instance.Login(userid, delegate(int result, Dictionary<string, string> data, string error)
			{
				state = result;
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
				{
					{ "step_id", "AppLoadingStep_03" },
					{ "step_name", "GetTheBackEndDataSuccess" },
					{ "status", "end" },
					{
						"duration",
						(int)((Time.realtimeSinceStartup - startTime) * 1000f)
					}
				});
			}, startTime);
			float ttlLogin2 = 0f;
			while (ttlLogin2 < 30f && state == -2 && !BreakTTLShow)
			{
				ttlLogin2 += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				if (ttlLogin2 >= 30f)
				{
					UnityEngine.Debug.LogError("TTL Playfab");
					TTLShow = true;
					csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
					csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common18"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
					{
						Application.Quit();
					});
					csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
				}
			}
			BreakTTLShow = false;
		}
		else
		{
			state = 1;
		}
		while (state == -2)
		{
			yield return new WaitForEndOfFrame();
		}
		if (state != -1)
		{
			csCloudSettings.InitDateTime();
		}
		if (state == 0)
		{
			isFirstLogin = true;
			csPlayfabServer.Instance.InitGameSettings(delegate
			{
			});
			float ttlLogin2 = 0f;
			while (ttlLogin2 < 30f && csCloudSettings.SNUrlData == null && !BreakTTLShow)
			{
				ttlLogin2 += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				if (ttlLogin2 >= 30f)
				{
					UnityEngine.Debug.LogError("TTL Playfab InitGameSettings");
					TTLShow = true;
					csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
					csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common18"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
					{
						Application.Quit();
					});
					csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
				}
			}
			BreakTTLShow = false;
			float t = 0f;
			while (t < 30f && (csPlayer.instance == null || !csPlayer.instance.welcomeOver || !csEyeFadeManager.Instance || csCloudSettings.SNUrlData == null))
			{
				t += Time.deltaTime;
				yield return null;
			}
			if (t >= 30f)
			{
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
				csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common18"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					Application.Quit();
				});
				csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
			}
			else if (csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionOnline || csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionPretest || csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionInDev)
			{
				VersionMaintenData versionMaintenData = csCloudSettings.ServerMaintenD.MainTenDataList.Find((VersionMaintenData x) => x.Version == csGameSettings.GameVersion);
				if (versionMaintenData != null)
				{
					if (versionMaintenData.IsInMainten)
					{
						ShowMaintenHint(versionMaintenData);
					}
					else if (csGameSettings.GameVersion != csCloudSettings.curGameVersion.VersionOnline)
					{
						ShowNewVersionHint(delegate
						{
							csMainMenuManager.instance.OpenPanel(PanelType.FirstLogin);
							csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
						});
					}
					else
					{
						csMainMenuManager.instance.OpenPanel(PanelType.FirstLogin);
						csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
					}
				}
			}
			else
			{
				CheckMainVersion();
			}
		}
		else
		{
			csGameSettings.isLogined = true;
			DateTime now = DateTime.Now;
			csTalkingData.Instance.SendEvent("DL06_登陆", 1.0, new Dictionary<string, object> { 
			{
				"登陆设备：" + Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice),
				$"登陆时间时间段：{now.Year:D}年{now.Month:D}月{now.Day:D}日 {now.Hour:D}点—{now.Hour + 1:D}点"
			} });
		}
		if (PlayerPrefs.GetInt("First_Install", 1) == 1)
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_start, new Dictionary<string, object> { { "is_first_install", "1" } });
			PlayerPrefs.SetInt("First_Install", 0);
		}
		else
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_start, new Dictionary<string, object> { { "is_first_install", "0" } });
		}
	}

	private void OnLevelWasLoaded(int level)
	{
		if (level != 0 || !(instance == this) || !csGameSettings.isLogined)
		{
			return;
		}
		if (Time.realtimeSinceStartup - tokenT > 3600f)
		{
			tokenT = Time.realtimeSinceStartup;
			csPlayfabServer.Instance.RefreshToken();
		}
		csPlayfabServer.Instance.InitGameSettings(delegate
		{
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
				csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
				{
				});
			}
			long classHistorySum = csCloudStorage.instance.GetClassHistorySum();
			csLevelChoosePanel.instance.scoreRankPanel.Init((int)classHistorySum);
		});
	}

	private IEnumerator InitData(bool needinitsettings)
	{
		csCloudStorage.HasInitUserData = false;
		step = 0;
		bool isGetUserData = false;
		csPlayfabServer.Instance.InitUserData(delegate(int state, Dictionary<string, string> data, string error)
		{
			isGetUserData = true;
			if (state == 1)
			{
				step++;
				csCloudStorage.instance.Init(data);
				csCloudStorage.HasInitUserData = true;
			}
		});
		float ttlLogin2 = 0f;
		while (ttlLogin2 < 30f && !isGetUserData && !BreakTTLShow)
		{
			ttlLogin2 += Time.deltaTime;
			yield return new WaitForEndOfFrame();
			if (ttlLogin2 >= 30f)
			{
				UnityEngine.Debug.LogError("TTL Playfab InitData");
				TTLShow = true;
				csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
				csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common18"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					Application.Quit();
				});
				csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
			}
		}
		BreakTTLShow = false;
		if (needinitsettings)
		{
			bool SettingIsInit = false;
			csPlayfabServer.Instance.InitGameSettings(delegate
			{
				StartCoroutine(WaitFoPlayerData());
				SettingIsInit = true;
			});
			ttlLogin2 = 0f;
			while (ttlLogin2 < 30f && !SettingIsInit && !BreakTTLShow)
			{
				ttlLogin2 += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				if (ttlLogin2 >= 30f)
				{
					UnityEngine.Debug.LogError("TTL Playfab InitGameSettings 2");
					TTLShow = true;
					csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, null);
					csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common18"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
					{
						Application.Quit();
					});
					csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
				}
			}
			BreakTTLShow = false;
		}
		while ((needinitsettings && step < 2) || (!needinitsettings && step < 1))
		{
			yield return new WaitForEndOfFrame();
		}
		csCloudStorage.instance.ModifiDataAfterUpdate();
		isGetPlayfabData = true;
	}

	private void OnApplicationFocus(bool focus)
	{
		if (Time.realtimeSinceStartup - tokenT > 3600f)
		{
			tokenT = Time.realtimeSinceStartup;
			csPlayfabServer.Instance.RefreshToken();
		}
	}

	private IEnumerator WaitFoPlayerData()
	{
		bool checkMainVersion = false;
		while (!csCloudStorage.HasInitUserData || csMainMenuManager.instance.startPage.isShowing)
		{
			yield return new WaitForEndOfFrame();
		}
		if (csGameSettings.IsOfflineVersion)
		{
			while (csMainMenuManager.instance.startPage.isShowing)
			{
				yield return new WaitForEndOfFrame();
			}
			ShowOfflineMessage();
		}
		else if (csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionOnline || csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionPretest || csGameSettings.GameVersion == csCloudSettings.curGameVersion.VersionInDev)
		{
			VersionMaintenData versionMaintenData = csCloudSettings.ServerMaintenD.MainTenDataList.Find((VersionMaintenData x) => x.Version == csGameSettings.GameVersion);
			if (versionMaintenData != null)
			{
				if (versionMaintenData.IsInMainten)
				{
					ShowMaintenHint(versionMaintenData);
				}
				else if (csGameSettings.GameVersion != csCloudSettings.curGameVersion.VersionOnline && !VersionHintIsShow)
				{
					ShowNewVersionHint(delegate
					{
						step++;
						csMainMenuManager.instance.ClosePanel();
					});
				}
				else
				{
					step++;
				}
			}
		}
		else
		{
			checkMainVersion = true;
		}
		if (checkMainVersion)
		{
			CheckMainVersion();
		}
	}

	private void CheckMainVersion()
	{
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
		});
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common13"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
			Application.Quit();
		});
		csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_update_show, new Dictionary<string, object>
		{
			{
				"app_version_new",
				csCloudSettings.curGameVersion.VersionOnline
			},
			{ "update_type", "cold" }
		});
	}

	private void ShowMaintenHint(VersionMaintenData vd)
	{
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
		});
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint((csLocalizationManager.Instance.m_CurrentLanguage == Languages.ChineseSimplified) ? vd.DetailTextCN : vd.DetailTextEN, csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
			Application.Quit();
		});
		csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
	}

	private void ShowNewVersionHint(Action act)
	{
		VersionHintIsShow = true;
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
		});
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("Common21"), csLocalizationManager.Instance.GetLocalText("Common22"), null, act);
		csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
	}

	private void ShowOfflineMessage()
	{
		csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
		{
		});
		csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(csGameSettings.OfflineHint, csLocalizationManager.Instance.GetLocalText("OfflineMessage02"), null, csLocalizationManager.Instance.GetLocalText("OfflineMessage03"), null, delegate
		{
			Application.Quit();
		}, delegate
		{
			step++;
		});
		csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
	}
}
public class csOrderManagerPanel : csPanelBase
{
	public TextMeshProUGUI TimeText;

	public Button ShopButton;

	public Button BackButton;

	public TextMeshProUGUI TipText;

	private void Start()
	{
		ShopButton.onClick.AddListener(OnShopClick);
		BackButton.onClick.AddListener(OnBackClick);
	}

	public override void Open()
	{
		base.Open();
		RefreshUI();
		csPlayerOrderManager.instance.AddCallBackAction(RefreshUI, RefreshUI);
	}

	public override void Close()
	{
		base.Close();
		csPlayerOrderManager.instance.RemoveCallBackAction(RefreshUI, RefreshUI);
	}

	private void RefreshUI()
	{
		string text = "";
		if (csPlayerOrderManager.instance.GetHaveOrdered())
		{
			if (csPlayerOrderManager.instance.IsOrdering())
			{
				DateTime endTime = csPlayerOrderManager.instance.GetEndTime();
				text = csLocalizationManager.Instance.GetLocalText("PlayerOrder12") + endTime.Year + "." + endTime.Month + "." + endTime.Day + csLocalizationManager.Instance.GetLocalText("PlayerOrder13");
			}
			else
			{
				text = csLocalizationManager.Instance.GetLocalText("PlayerOrder14");
			}
		}
		else
		{
			text = csLocalizationManager.Instance.GetLocalText("PlayerOrder15");
		}
		TimeText.text = text;
	}

	private void OnShopClick()
	{
		csMainMenuManager.instance.CloseAddOn();
		csPlayerOrderManager.instance.StartToOrder();
	}

	private void OnBackClick()
	{
		csMainMenuManager.instance.CloseAddOn();
	}
}
public class csPicoLeaderboard : MonoBehaviour
{
	public static csPicoLeaderboard Instance;

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
	}

	public void SubmitLeaderBoard(string leaderBoardName, long Score, UnityAction<bool> OnSubmitDone)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		LeaderboardService.WriteEntry(leaderBoardName, Score).OnComplete(delegate(Message<bool> msg)
		{
			if (msg.IsError)
			{
				OnSubmitDone?.Invoke(arg0: false);
			}
			else
			{
				OnSubmitDone?.Invoke(arg0: true);
			}
		});
	}

	public void GetLeaderBoradRankScale(string leaderboardName, UnityAction<int> OnGetLeaderboardNum)
	{
	}

	public void GetLeaderBoard(string leaderboardName, int pageSize, int pageIdx, UnityAction<List<LeaderboardEntry>, ulong, string> OnSubmitDone)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		LeaderboardService.GetEntries(leaderboardName, pageSize, pageIdx, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(delegate(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				OnSubmitDone(msg.Data, msg.Data.TotalCount, leaderboardName);
			}
		});
	}

	public void GetLeaderBoardAfterRank(string leaderboardName, int pageSize, int pageIdx, int afterRank, UnityAction<List<LeaderboardEntry>> OnSubmitDone)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		LeaderboardService.GetEntriesAfterRank(leaderboardName, pageSize, pageIdx, Convert.ToUInt64(afterRank)).OnComplete(delegate(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				OnSubmitDone(msg.Data);
			}
		});
	}

	public void GetMyLeaderBoardData(string leaderBoardName, UnityAction<List<LeaderboardEntry>, string> OnGetDone, UnityAction<int> OnGetFailed)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		string[] userIDs = new string[1] { csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID };
		LeaderboardService.GetEntriesByIds(leaderBoardName, 1, 0, LeaderboardStartAt.CenteredOnViewer, userIDs).OnComplete(delegate(Message<LeaderboardEntryList> msg)
		{
			if (msg.IsError)
			{
				UnityEngine.Debug.LogError("msg.IsError：" + msg.Error.Message);
				UnityEngine.Debug.LogError("msg.IsError：" + msg.Error.Code);
				OnGetFailed(msg.Error.Code);
			}
			else
			{
				if (msg.Data.Count > 0)
				{
					UnityEngine.Debug.LogError("msg.Data：" + msg.Data[0].Rank);
					UnityEngine.Debug.LogError("msg.Data：" + msg.Data[0].Rank);
				}
				OnGetDone(msg.Data, leaderBoardName);
			}
		});
	}
}
public class csPlayerOrderManager : MonoBehaviour
{
	public static csPlayerOrderManager instance;

	private bool haveOrdered;

	private int totalOrderTime;

	private OrderType orderType;

	private DateTime orderBeginTime;

	private DateTime orderEndTime;

	private Action orderSuccessAction;

	private Action orderFailedAction;

	private Coroutine orderCoroutine;

	private PlayerOrderData playerOrderData;

	public csSNTool1 SNTool;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
	}

	public void SetPlayfabOrderData(DateTime beginTime, DateTime endTime, OrderType type, OrderDevice odv, Action<bool> callBack)
	{
		csCloudStorage.instance.SetPlayerOrderData(beginTime, endTime, type, odv, callBack);
	}

	public void Init(PlayerOrderData orderData)
	{
		playerOrderData = orderData;
		orderBeginTime = TryParseDateTime(orderData.beginOrderTime);
		orderEndTime = TryParseDateTime(orderData.endOrderTime);
		orderType = orderData.orderType;
		SetHaveOrdered();
		SetTotalOrderTime();
	}

	private DateTime TryParseDateTime(string dt)
	{
		if (DateTime.TryParse(dt, out var result))
		{
			return result;
		}
		if (DateTime.TryParseExact(dt, "dd/MM/yyyy", null, DateTimeStyles.None, out result))
		{
			return result;
		}
		DateTime.TryParseExact(dt, "MM/dd/yyyy", null, DateTimeStyles.None, out result);
		return result;
	}

	public void RefreshData(PlayerOrderData orderData)
	{
		Init(orderData);
	}

	private void SetHaveOrdered()
	{
		haveOrdered = orderBeginTime != DateTime.MinValue;
	}

	private void SetTotalOrderTime()
	{
		totalOrderTime = (orderEndTime - orderBeginTime).Days;
	}

	public bool IsOrdering()
	{
		return orderEndTime >= csCloudSettings.GetNowTime();
	}

	public bool GetHaveOrdered()
	{
		return haveOrdered;
	}

	public int GetTotalTime()
	{
		return totalOrderTime;
	}

	public DateTime GetBeginTime()
	{
		return orderBeginTime;
	}

	public DateTime GetEndTime()
	{
		return orderEndTime;
	}

	public void AddCallBackAction(Action suceAction, Action filedAction)
	{
		orderSuccessAction = (Action)Delegate.Combine(orderSuccessAction, suceAction);
		orderFailedAction = (Action)Delegate.Combine(orderFailedAction, filedAction);
	}

	public void RemoveCallBackAction(Action suceAction, Action filedAction)
	{
		orderSuccessAction = (Action)Delegate.Remove(orderSuccessAction, suceAction);
		orderFailedAction = (Action)Delegate.Remove(orderFailedAction, filedAction);
	}

	public void OrderSucssceCallback(DateTime beginTime, DateTime endTime, OrderType type, OrderDevice odv)
	{
		SetPlayfabOrderData(beginTime, endTime, type, odv, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				RefreshAllPanel();
				ShowSucsses();
			}
			else
			{
				OrderFiledCallback();
			}
		});
	}

	public void OrderFiledCallback()
	{
		ShowFailed();
	}

	public void ShowShopTip(string tipText)
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(tipText, csLocalizationManager.Instance.GetLocalText("PlayerOrder01"), null, csLocalizationManager.Instance.GetLocalText("PlayerOrder02"), null, delegate
		{
			StartToOrder();
		}, delegate
		{
		});
	}

	public void StartToOrder()
	{
		if (orderCoroutine != null)
		{
			UnityEngine.Debug.LogError("玩家还有订单未完成，无法再次开启订单");
			return;
		}
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		string localText = csLocalizationManager.Instance.GetLocalText("PlayerOrder03");
		csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(localText, csLocalizationManager.Instance.GetLocalText("PlayerOrder04"), null, csLocalizationManager.Instance.GetLocalText("PlayerOrder05"), null, delegate
		{
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder06"), csLocalizationManager.Instance.GetLocalText("Common08"), null, csLocalizationManager.Instance.GetLocalText("Common09"), null, delegate
			{
				orderCoroutine = StartCoroutine(StartOrderOnceCoroutine());
			}, delegate
			{
			});
		}, delegate
		{
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder07"), csLocalizationManager.Instance.GetLocalText("Common08"), null, csLocalizationManager.Instance.GetLocalText("Common09"), null, delegate
			{
				orderCoroutine = StartCoroutine(StartOrderContinuityCoroutine());
			}, delegate
			{
			});
		});
	}

	private IEnumerator StartOrderOnceCoroutine()
	{
		yield return new WaitForSeconds(1f);
		DateTime nowTime = csCloudSettings.GetNowTime();
		DateTime endTime = ((haveOrdered && !IsOverTime()) ? new DateTime(orderBeginTime.Year, orderBeginTime.Month, orderBeginTime.Day, orderBeginTime.Hour, orderBeginTime.Minute, orderBeginTime.Second).AddMonths(1) : new DateTime(nowTime.Year, nowTime.Month, nowTime.Day, nowTime.Hour, nowTime.Minute, nowTime.Second).AddMonths(1));
		OrderType type = OrderType.Once;
		OrderSucssceCallback(nowTime, endTime, type, OrderDevice.Neo3);
		orderCoroutine = null;
	}

	public void GetFreeFirstOrder(bool isPico4)
	{
		if (orderCoroutine != null)
		{
			UnityEngine.Debug.LogError("玩家还有订单未完成，无法再次开启订单");
		}
		else if (isPico4)
		{
			orderCoroutine = StartCoroutine(StartFreeFirstOrder(9));
		}
		else
		{
			orderCoroutine = StartCoroutine(StartFreeFirstOrder(6));
		}
	}

	private IEnumerator StartFreeFirstOrder(int Month)
	{
		yield return new WaitForSeconds(1f);
		DateTime nowTime = csCloudSettings.GetNowTime();
		DateTime endTime = new DateTime(nowTime.Year, nowTime.Month, nowTime.Day, nowTime.Hour, nowTime.Minute, nowTime.Second).AddMonths(Month);
		SetPlayfabOrderData(nowTime, endTime, OrderType.Once, (Month == 9) ? OrderDevice.Pico4 : OrderDevice.Neo3, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				RefreshAllPanel();
				ShowSucsses();
				if (Month == 6)
				{
					csTalkingData.Instance.SendEvent("DY01_订阅领取", 1.0, new Dictionary<string, object> { 
					{
						"领取成功设备",
						Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
					} });
				}
				else if (Month == 9)
				{
					csTalkingData.Instance.SendEvent("DY02_额外领取", 1.0, new Dictionary<string, object> { 
					{
						"领取成功设备",
						Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
					} });
				}
			}
			else
			{
				OrderFiledCallback();
				if (Month == 6)
				{
					csTalkingData.Instance.SendEvent("DY01_订阅领取", 1.0, new Dictionary<string, object> { 
					{
						"领取失败设备",
						Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
					} });
				}
				else if (Month == 9)
				{
					csTalkingData.Instance.SendEvent("DY02_额外领取", 1.0, new Dictionary<string, object> { 
					{
						"领取失败设备",
						Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
					} });
				}
			}
		});
		orderCoroutine = null;
	}

	private IEnumerator StartAddonPico4Order(int Month)
	{
		yield return new WaitForSeconds(0.1f);
		DateTime nowTime = csCloudSettings.GetNowTime();
		DateTime dateTime = DateTime.Parse(csCloudStorage.instance.m_PlayerOrderData.endOrderTime);
		DateTime endTime = new DateTime(dateTime.Year, dateTime.Month, dateTime.Day, dateTime.Hour, dateTime.Minute, dateTime.Second).AddMonths(Month);
		SetPlayfabOrderData(nowTime, endTime, OrderType.Once, OrderDevice.Pico4, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				RefreshAllPanel();
				ShowSucsses();
				csTalkingData.Instance.SendEvent("DY0X_老号新机领取", 1.0, new Dictionary<string, object> { 
				{
					"领取成功设备",
					Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
				} });
			}
			else
			{
				OrderFiledCallback();
				csTalkingData.Instance.SendEvent("DY0X_老号新机领取", 1.0, new Dictionary<string, object> { 
				{
					"领取失败设备",
					Enum.GetName(typeof(XRDeviceType), csGameSettings.CurrentDevice)
				} });
			}
		});
		orderCoroutine = null;
	}

	private IEnumerator StartOrderContinuityCoroutine()
	{
		yield return new WaitForSeconds(1f);
		DateTime nowTime = csCloudSettings.GetNowTime();
		DateTime endTime = ((haveOrdered && !IsOverTime()) ? new DateTime(orderBeginTime.Year, orderBeginTime.Month, orderBeginTime.Day, orderBeginTime.Hour, orderBeginTime.Minute, orderBeginTime.Second).AddMonths(1) : new DateTime(nowTime.Year, nowTime.Month, nowTime.Day, nowTime.Hour, nowTime.Minute, nowTime.Second).AddMonths(1));
		OrderType type = OrderType.Continuity;
		OrderSucssceCallback(nowTime, endTime, type, OrderDevice.Neo3);
		orderCoroutine = null;
	}

	public bool IsFirstInGame()
	{
		_ = haveOrdered;
		return !haveOrdered;
	}

	public void AutoOrderOneMonth()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		string localText = csLocalizationManager.Instance.GetLocalText("PlayerOrder08");
		localText = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName + localText;
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(localText, csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
			StartCoroutine(AutoOrder());
		});
	}

	private IEnumerator AutoOrder()
	{
		yield return new WaitForEndOfFrame();
		DateTime nowTime = csCloudSettings.GetNowTime();
		DateTime endTime = new DateTime(nowTime.Year, nowTime.Month, nowTime.Day, nowTime.Hour, nowTime.Minute, nowTime.Second).AddMonths(1);
		OrderType type = OrderType.Once;
		OrderSucssceCallback(nowTime, endTime, type, OrderDevice.Neo3);
	}

	public TimeSpan GetLeftOrderTime()
	{
		if (!haveOrdered || orderEndTime < csCloudSettings.GetNowTime())
		{
			return TimeSpan.Zero;
		}
		return orderEndTime - csCloudSettings.GetNowTime();
	}

	public bool IsOverTime()
	{
		return orderEndTime < csCloudSettings.GetNowTime();
	}

	public bool IsInOrderTime()
	{
		return orderEndTime >= csCloudSettings.GetNowTime();
	}

	public void OpenOrderManagerPanel()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.OrderManagerPanel);
	}

	public void OnEnterGame()
	{
		RefreshAllPanel();
	}

	private void CheckFirstTime()
	{
		if (IsFirstInGame())
		{
			AutoOrderOneMonth();
		}
	}

	private void CheckOrderDataForPico4()
	{
	}

	private IEnumerator CheckPico4AddOnOrder()
	{
		if (csGameSettings.CurrentDevice != XRDeviceType.Pico4)
		{
			yield break;
		}
		bool GetSNCallback = false;
		if (string.IsNullOrEmpty(SystemInfo.deviceUniqueIdentifier) || string.IsNullOrEmpty(csLogin.instance.userid))
		{
			csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("DisconnectPanel05"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
			{
				Application.Quit();
			});
			csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
		}
		while (!GetSNCallback)
		{
			yield return null;
		}
	}

	public void TryGetAddOnPico4()
	{
		AddCallBackAction(OnAddonVipGetSuccess, OnAddonVipGetFailed);
		StartCoroutine(StartAddonPico4Order(3));
	}

	public void OnAddonVipGetSuccess()
	{
		RemoveCallBackAction(OnAddonVipGetSuccess, OnAddonVipGetFailed);
	}

	public void OnAddonVipGetFailed()
	{
		RemoveCallBackAction(OnAddonVipGetSuccess, OnAddonVipGetFailed);
	}

	private void CheckOverTime()
	{
		int days = GetLeftOrderTime().Days;
		DateTime nowTime = csCloudSettings.GetNowTime();
		if (days >= 0 && !IsOverTime() && days < 3)
		{
			bool flag = false;
			string @string = PlayerPrefs.GetString("LastShowOverSoonDate");
			if (@string == "")
			{
				flag = true;
			}
			else
			{
				DateTime dateTime = DateTime.Parse(@string);
				if (dateTime.Year != nowTime.Year || dateTime.Month != nowTime.Month || dateTime.Date != nowTime.Date)
				{
					flag = true;
				}
			}
			if (flag)
			{
				ShowOverTimeSoon();
				PlayerPrefs.SetString("LastShowOverSoonDate", nowTime.ToString());
			}
		}
		else
		{
			if (!IsOverTime())
			{
				return;
			}
			bool flag2 = false;
			string string2 = PlayerPrefs.GetString("LastShowOverTimeDate");
			if (string2 == "")
			{
				flag2 = true;
			}
			else
			{
				DateTime dateTime2 = DateTime.Parse(string2);
				if (dateTime2.Year < nowTime.Year || dateTime2.Month < nowTime.Month || dateTime2.Date < nowTime.Date)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				ShowOverTimePanel();
				PlayerPrefs.SetString("LastShowOverTimeDate", nowTime.ToString());
			}
		}
	}

	private void ShowOverTimeSoon()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		csMainMenuManager.instance.commonHintPanel.InitTwoButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder09"), csLocalizationManager.Instance.GetLocalText("PlayerOrder01"), null, csLocalizationManager.Instance.GetLocalText("PlayerOrder02"), null, delegate
		{
			StartToOrder();
		}, delegate
		{
		});
	}

	public void ShowOverTimePanel()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder10"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
		});
	}

	public void RefreshAllPanel()
	{
	}

	private void ShowSucsses()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder11"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
			if (orderSuccessAction != null)
			{
				orderSuccessAction();
			}
		});
	}

	private void ShowFailed()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
		csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("PlayerOrder22"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
		{
			if (orderFailedAction != null)
			{
				orderFailedAction();
			}
		});
	}

	public string EncodeOrderData(PlayerOrderData data)
	{
		return EncryptTools.EncryptDES(JsonUtility.ToJson(data));
	}

	public PlayerOrderData DecodeOrderData(string byteStr)
	{
		try
		{
			return JsonUtility.FromJson<PlayerOrderData>(EncryptTools.DecryptDES(byteStr));
		}
		catch
		{
			UnityEngine.Debug.LogError("Decode Error");
			return new PlayerOrderData();
		}
	}

	private string ByteToString(byte[] bytes)
	{
		string text = "";
		for (int i = 0; i < bytes.Length; i++)
		{
			string text2 = Convert.ToString(bytes[i], 2);
			text2 = text2.Insert(0, new string('0', 8 - text2.Length));
			text += text2;
		}
		return text;
	}

	private byte[] StringToByte(string str)
	{
		byte[] array = new byte[str.Length / 8];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Convert.ToByte(str.Substring(i * 8, 8), 2);
		}
		return array;
	}

	private byte[] OrderDataToByte(PlayerOrderData data)
	{
		using MemoryStream memoryStream = new MemoryStream();
		((IFormatter)new BinaryFormatter()).Serialize((Stream)memoryStream, (object)data);
		return memoryStream.GetBuffer();
	}

	private PlayerOrderData ByteToOrderData(byte[] targetByte)
	{
		using MemoryStream serializationStream = new MemoryStream(targetByte);
		return (PlayerOrderData)((IFormatter)new BinaryFormatter()).Deserialize((Stream)serializationStream);
	}
}
public class csPlayerOrderTest : MonoBehaviour
{
	public TMP_InputField yearInput;

	public TMP_InputField mothInput;

	public TMP_InputField dayInput;

	public TMP_InputField endYearInput;

	public TMP_InputField endMothInput;

	public TMP_InputField endDayInput;

	public Button SetButton;

	public Button ResetButton;

	public Button ClearButton;

	private void Start()
	{
		SetButton.onClick.AddListener(SetOrderTime);
		ResetButton.onClick.AddListener(ResetData);
		ClearButton.onClick.AddListener(ClearLoaclData);
	}

	private void SetOrderTime()
	{
		int year = int.Parse(yearInput.text);
		int month = int.Parse(mothInput.text);
		int day = int.Parse(dayInput.text);
		int year2 = int.Parse(endYearInput.text);
		int month2 = int.Parse(endMothInput.text);
		int day2 = int.Parse(endDayInput.text);
		DateTime beginTime = new DateTime(year, month, day);
		DateTime endTime = new DateTime(year2, month2, day2);
		csPlayerOrderManager.instance.SetPlayfabOrderData(beginTime, endTime, OrderType.Once, OrderDevice.Neo3, delegate
		{
		});
		csPlayerOrderManager.instance.OrderSucssceCallback(beginTime, endTime, OrderType.Once, OrderDevice.Neo3);
	}

	private void ResetData()
	{
	}

	private void ClearLoaclData()
	{
	}
}
public class csPlayerPicoDataManager : MonoBehaviour
{
	public static csPlayerPicoDataManager instance;

	public bool isLogin;

	public PicoAccountInfo m_PicoAccountInfo = new PicoAccountInfo();

	private float startInitTime;

	private int tryTime;

	public bool isGetInfo;

	private static bool OpenAccountTest;

	public string[] TestIDList = new string[22]
	{
		"7147877677582533663", "7147878619543503886", "7147894240218186767", "7147879325658907656", "7147878490480657415", "7147876977565893639", "7147876994892514318", "7147881454234633253", "7147878013659710500", "7147878836787741732",
		"7147879240606909454", "7147895436874073103", "7147878341226578974", "7147878517559133220", "7147878307898573854", "7147879022142276645", "7147904565868872718", "7147879735811556359", "7147881170934498335", "7147879493758256165",
		"7147880132349363236", "7147878912104711205"
	};

	private float startAccountTime;

	private void Awake()
	{
		if ((bool)instance)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			instance = this;
		}
	}

	private void Start()
	{
	}

	public void PicoLogin()
	{
		isGetInfo = false;
		if (csGameSettings.IsOfflineVersion)
		{
			UnityEngine.Debug.LogError("OfflineVersion IsSuccess:" + Time.timeSinceLevelLoad);
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
			}
			else
			{
				LoginCallback();
			}
			return;
		}
		try
		{
			UnityEngine.Debug.LogError("AsyncInitialize Start:" + Time.timeSinceLevelLoad);
			startInitTime = Time.realtimeSinceStartup;
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_01" },
				{ "step_name", "PicoPlatformInitialization" },
				{ "status", "start" }
			});
			CoreService.AsyncInitialize().OnComplete(delegate(Message<PlatformInitializeResult> m)
			{
				UnityEngine.Debug.LogError("AsyncInitialize OnComplete:" + Time.timeSinceLevelLoad);
				if (m.IsError)
				{
					if (csMainMenuManager.instance.disconnectPanel.isOpend)
					{
						csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: false);
					}
					UnityEngine.Debug.LogError("AsyncInitialize IsError:" + Time.timeSinceLevelLoad);
					picoLoginFailed();
				}
				else if (m.Data != 0 && m.Data != PlatformInitializeResult.AlreadyInitialized)
				{
					UnityEngine.Debug.LogError("AsyncInitialize IsError:" + Time.timeSinceLevelLoad);
					picoLoginFailed();
				}
				else
				{
					UnityEngine.Debug.LogError("AsyncInitialize IsSuccess:" + Time.timeSinceLevelLoad);
					if (csMainMenuManager.instance.disconnectPanel.isOpend)
					{
						csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
					}
					else
					{
						LoginCallback();
					}
				}
			});
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("AsyncInitialize Exception:" + Time.timeSinceLevelLoad);
			UnityEngine.Debug.LogError("AsyncInitialize Message:" + ex.Message);
			UnityEngine.Debug.LogError("AsyncInitialize StackTrace:" + ex.StackTrace);
			UnityEngine.Debug.LogError("AsyncInitialize Source:" + ex.Source);
			picoLoginFailed();
		}
	}

	private void picoLoginFailed()
	{
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			PicoLogin();
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				LoginCallback();
			});
		});
		csLogin.instance.openDisconnectPanel();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_01" },
			{ "step_name", "PicoPlatformInitializationFailure" },
			{ "status", "end" },
			{
				"duration",
				(int)((Time.realtimeSinceStartup - startInitTime) * 1000f)
			}
		});
	}

	public void LoginCallback()
	{
		isLogin = true;
		getPicoInfo();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_01" },
			{ "step_name", "PicoPlatformInitializationSuccess" },
			{ "status", "end" },
			{
				"duration",
				(int)((Time.realtimeSinceStartup - startInitTime) * 1000f)
			}
		});
	}

	public void updateAllPicoInfo(Action callback)
	{
		csCloudStorage.instance.UpdatePicoAccountInfo(callback);
	}

	public void getPicoInfo()
	{
		if (csGameSettings.IsOfflineVersion)
		{
			UnityEngine.Debug.LogError("IsOfflineVersion GetLoggedInUser Start:" + Time.timeSinceLevelLoad);
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
			}
			else
			{
				isGetInfo = true;
			}
			m_PicoAccountInfo.picoID = SystemInfo.deviceUniqueIdentifier;
			m_PicoAccountInfo.headIconURL = "";
			m_PicoAccountInfo.picoNickName = "User";
			return;
		}
		UnityEngine.Debug.LogError("GetLoggedInUser Start:" + Time.timeSinceLevelLoad);
		startAccountTime = Time.realtimeSinceStartup;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_02" },
			{ "step_name", "AccountDataAcquisition" },
			{ "status", "start" }
		});
		UserService.GetLoggedInUser().OnComplete(delegate(Message<User> msg)
		{
			UnityEngine.Debug.LogError("GetLoggedInUser OnComplete:" + Time.timeSinceLevelLoad);
			if (!msg.IsError)
			{
				UnityEngine.Debug.LogError("GetLoggedInUser Success:" + Time.timeSinceLevelLoad);
				if (csMainMenuManager.instance.disconnectPanel.isOpend)
				{
					csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
				}
				else
				{
					isGetInfo = true;
				}
				User data = msg.Data;
				m_PicoAccountInfo.picoID = data.ID;
				m_PicoAccountInfo.headIconURL = data.ImageUrl;
				m_PicoAccountInfo.picoNickName = data.DisplayName;
				if (OpenAccountTest)
				{
					int @int = PlayerPrefs.GetInt("TestIDNum", 0);
					m_PicoAccountInfo.picoID = TestIDList[@int];
					m_PicoAccountInfo.picoNickName = "TestID:" + @int;
					@int++;
					if (@int >= 22)
					{
						@int = 0;
					}
					PlayerPrefs.SetInt("TestIDNum", @int);
					UnityEngine.Debug.LogError("TestID:" + m_PicoAccountInfo.picoID);
				}
				csByteEventTracking.Instance.Init();
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
				{
					{ "step_id", "AppLoadingStep_02" },
					{ "step_name", "AccountDataAcquisitionSuccess" },
					{ "status", "end" },
					{
						"duration",
						(int)((Time.realtimeSinceStartup - startAccountTime) * 1000f)
					}
				});
			}
			else
			{
				UnityEngine.Debug.LogError("GetLoggedInUser IsError:" + Time.timeSinceLevelLoad);
				Error error = msg.GetError();
				UnityEngine.Debug.LogError("Error: " + error.Message);
				if (csMainMenuManager.instance.disconnectPanel.isOpend)
				{
					csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: false);
				}
				picoInfoGotFailed();
			}
		});
	}

	private void picoInfoGotFailed()
	{
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			getPicoInfo();
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				isGetInfo = true;
			});
		});
		csLogin.instance.openDisconnectPanel();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_02" },
			{ "step_name", "AccountDataAcquisitionFailure" },
			{ "status", "end" },
			{
				"duration",
				(int)((Time.realtimeSinceStartup - startAccountTime) * 1000f)
			}
		});
	}
}
public class csPlayfabServer : MonoBehaviour
{
	public static csPlayfabServer Instance;

	private string playfabID = "";

	private string selfHostServerID = "";

	public bool isFirstLogin;

	private Dictionary<string, Sprite> AvatarCacheDic = new Dictionary<string, Sprite>();

	private LoginInfo loginInfo = new LoginInfo();

	private Dictionary<string, string> data = new Dictionary<string, string>();

	private bool AccountWithoutData;

	public bool PlayerIsMedia;

	private int trylogintime;

	public string PlayfabID => selfHostServerID;

	public bool IsClientLoggedIn
	{
		get
		{
			if (csGameSettings.IsOfflineVersion)
			{
				return true;
			}
			if (loginInfo.token == null || string.IsNullOrEmpty(loginInfo.token))
			{
				return false;
			}
			return true;
		}
	}

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void AddPlayerTag(string _code)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayFabClientAPI.ExecuteCloudScript(new ExecuteCloudScriptRequest
		{
			FunctionName = "AddPlayerTag",
			FunctionParameter = new
			{
				Data = _code
			}
		}, delegate(ExecuteCloudScriptResult result)
		{
			for (int i = 0; i < result.Logs.Count; i++)
			{
				UnityEngine.Debug.LogError(result.Logs[i].Data);
			}
		}, delegate
		{
			AddPlayerTag(_code);
		});
	}

	public void ReNameWithTag(string oldname, string newname)
	{
		RemovePlayerTag(oldname, delegate(bool result)
		{
			if (result)
			{
				AddPlayerTag(newname);
			}
		});
	}

	private void RemovePlayerTag(string _code, Action<bool> Callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayFabClientAPI.ExecuteCloudScript(new ExecuteCloudScriptRequest
		{
			FunctionName = "RemovePlayerTag",
			FunctionParameter = new
			{
				Data = _code
			}
		}, delegate(ExecuteCloudScriptResult result)
		{
			for (int i = 0; i < result.Logs.Count; i++)
			{
				UnityEngine.Debug.LogError(result.Logs[i].Data);
			}
			Callback?.Invoke(obj: true);
		}, delegate
		{
		});
	}

	public void GetServerTime(Action<DateTime> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			callback(DateTime.UtcNow);
			return;
		}
		csSelfHostServerAPI.instance.GetServerTime(delegate(string actSuccess)
		{
			DateTime obj = Convert.ToDateTime(actSuccess);
			if (callback != null)
			{
				callback(obj);
			}
		}, delegate
		{
			if (callback != null)
			{
				callback(DateTime.UtcNow);
			}
		});
	}

	public void GetPlayerProfile_NameTag(Action<string> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayFabClientAPI.GetPlayerProfile(new GetPlayerProfileRequest
		{
			PlayFabId = PlayfabID,
			ProfileConstraints = new PlayerProfileViewConstraints
			{
				ShowTags = true
			}
		}, delegate(GetPlayerProfileResult result)
		{
			string obj = "";
			if (result.PlayerProfile.Tags.Count != 0)
			{
				for (int i = 0; i < result.PlayerProfile.Tags.Count; i++)
				{
					if (result.PlayerProfile.Tags[i].TagValue.Contains("Name:"))
					{
						string[] array = result.PlayerProfile.Tags[i].TagValue.Split(new string[1] { "Name:" }, StringSplitOptions.None);
						obj = "Name:" + array[1];
					}
				}
			}
			callback?.Invoke(obj);
		}, delegate
		{
			GetPlayerProfile_NameTag(callback);
		});
	}

	public void UpdateUserData(Dictionary<string, string> data, Action<bool, string> callback)
	{
		if (csGameSettings.IsOfflineVersion || !PlayFabClientAPI.IsClientLoggedIn())
		{
			return;
		}
		PlayFabClientAPI.UpdateUserData(new UpdateUserDataRequest
		{
			Data = data,
			Permission = UserDataPermission.Public
		}, delegate
		{
			if (callback != null)
			{
				callback(arg1: true, "");
			}
		}, delegate(PlayFabError error)
		{
			if (callback != null)
			{
				callback(arg1: false, error.GenerateErrorReport());
			}
		});
	}

	public void UpdateUserData(Dictionary<string, object> playerData, Action<bool, string> callback)
	{
		string d = JsonMapper.ToJson(playerData);
		string encode = csSelfHostServerAPI.instance.GetEncode(d);
		string value = $"{{\"token\":\"{loginInfo.token}\",\"data\":\"{encode}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		csSelfHostServerAPI.instance.UpdateUserData(wWWForm, delegate
		{
			if (callback != null)
			{
				callback(arg1: true, "");
			}
			UnityEngine.Debug.Log("<color=yellow>===UpdateUserData:更新玩家数据成功！！！！！===</color>");
		}, delegate(string actFailed)
		{
			if (callback != null)
			{
				callback(arg1: false, actFailed);
			}
			UnityEngine.Debug.Log("<color=yellow>===更新玩家数据失败！详情为：===" + actFailed + "</color>");
		});
	}

	public void InitGameSettings(Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			GameVersionData gameVersionData = new GameVersionData();
			gameVersionData.VersionInDev = (gameVersionData.VersionOnline = (gameVersionData.VersionPretest = csGameSettings.GameVersion));
			TitleDataInPlayFab titledata = JsonUtility.FromJson<TitleDataInPlayFab>("{\"list\":[]}");
			SportPlanDataInPlayFab sportPlanData = JsonUtility.FromJson<SportPlanDataInPlayFab>("{\"list\":[{\"PlanID\":\"PlanID\",\"NameID\":\"拳击训练计划\",\"ImageID\":\"Plan_01\",\"DetailID\":\"从基础到进阶的拳击训练计划\",\"Days\":5,\"ClassIDs\":[{\"dayIndex\":1,\"classIDs\":[\"200001\"]},{\"dayIndex\":2,\"classIDs\":[\"101005\"]},{\"dayIndex\":3,\"classIDs\":[\"200003\"]},{\"dayIndex\":4,\"classIDs\":[\"101004\"]},{\"dayIndex\":5,\"classIDs\":[\"101006\"]}]}]}");
			UrlDataInPlayFab urlDataInPlayFab = JsonUtility.FromJson<UrlDataInPlayFab>("{\"list\":[{\"PlanID\":\"PlanID\",\"NameID\":\"拳击训练计划\",\"ImageID\":\"Plan_01\",\"DetailID\":\"从基础到进阶的拳击训练计划\",\"Days\":5,\"ClassIDs\":[{\"dayIndex\":1,\"classIDs\":[\"200001\"]},{\"dayIndex\":2,\"classIDs\":[\"101005\"]},{\"dayIndex\":3,\"classIDs\":[\"200003\"]},{\"dayIndex\":4,\"classIDs\":[\"101004\"]},{\"dayIndex\":5,\"classIDs\":[\"101006\"]}]}]}");
			VersionedVideoVersionData vvd = JsonUtility.FromJson<VersionedVideoVersionData>("{\"VideoVersionDataByVersionList\":[{\"Version\":\"1.1.0.0\",\"VersionDataList\":[{\"ClassID\":\"101002\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101004\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101005\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101006\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101001\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101003\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101007\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"101008\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102009\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102010\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102011\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102012\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102013\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102014\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102015\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102016\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102017\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102018\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102019\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"102020\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"200001\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"200002\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"200003\",\"WPVersion\":2,\"CDVersion\":2,\"FolVersion\":2},{\"ClassID\":\"200004\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200005\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200006\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200007\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200008\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200009\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200010\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200012\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200013\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200014\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200015\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200016\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200017\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200018\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200019\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200020\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200021\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200022\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200023\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200024\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200025\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200026\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200030\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200027\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200029\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200011\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1},{\"ClassID\":\"200028\",\"WPVersion\":1,\"CDVersion\":1,\"FolVersion\":1}]}]}");
			AnnouncementData ad = JsonUtility.FromJson<AnnouncementData>("{\"AnnouncementDataList\":[{\"AnnID\":\"Ann000\",\"DateStart\":\"2022/9/7 0:00:00\",\"DateEnd\":\"2022/9/10 0:00:00\",\"AnnouceTitleCN\":\"欢迎！\",\"AnnouceTitleEN\":\"English Title\",\"AnnouceDetailCN\":\"欢迎来到超燃一刻！\",\"AnnouceDetailEN\":\"English Detail\",\"ImgTitleURLCN\":\"Ann000TitleCN\",\"ImgTitleURLEN\":\"Ann000TitleEN\",\"ImgDetailURLCN\":\"Ann000DetailCN\",\"ImgDetailURLEN\":\"Ann000DetailEN\"},{\"AnnID\":\"Ann000\",\"DateStart\":\"2022/9/7 0:00:00\",\"DateEnd\":\"2022/9/10 0:00:00\",\"AnnouceTitleCN\":\"中文标题2\",\"AnnouceTitleEN\":\"English Title2\",\"AnnouceDetailCN\":\"中文内容2\",\"AnnouceDetailEN\":\"English Detail2\",\"ImgTitleURLCN\":\"Ann000TitleCN\",\"ImgTitleURLEN\":\"Ann000TitleEN\",\"ImgDetailURLCN\":\"Ann000DetailCN\",\"ImgDetailURLEN\":\"Ann000DetailEN\"},{\"AnnID\":\"Ann000\",\"DateStart\":\"2022/9/7 0:00:00\",\"DateEnd\":\"2022/9/10 0:00:00\",\"AnnouceTitleCN\":\"中文标题3\",\"AnnouceTitleEN\":\"English Title3\",\"AnnouceDetailCN\":\"中文内容3\",\"AnnouceDetailEN\":\"English Detail3\",\"ImgTitleURLCN\":\"Ann000TitleCN\",\"ImgTitleURLEN\":\"Ann000TitleEN\",\"ImgDetailURLCN\":\"Ann000DetailCN\",\"ImgDetailURLEN\":\"Ann000DetailEN\"},{\"AnnID\":\"Ann007\",\"DateStart\":\"2022/11/6 0:00:00\",\"DateEnd\":\"2022/11/16 0:00:00\",\"AnnouceTitleCN\":\"最新活动\",\"AnnouceTitleEN\":\"最新活动\",\"AnnouceDetailCN\":\"活动时间段：2022 年 11 月 6 日  至 11 月 15 日\\n其中活动二时间为：2022 年 11 月 6 日  至 11 月 9 日\\n【活动一】\\n在所有课程中，<B>寻找『拳王邹市明』榜上留名的关卡</B>，完成该课程并与拳王在排行榜合影，将截图上传至排行榜，即可获得<B> 288 </B>论坛积分奖励\\n【活动二】\\n活动期间内，挑战<B>『拳王邹市明』</B>完成的《力量掌握》拳击训练课程，若分数达到 14000 分及以上，将分数结算截图上传至排行榜，即可获得<B> 188 P币</B>奖励\\n【活动三】\\n<B>参与条件：完成【活动一】并截图上传排行榜，即可参与【活动三】，<color=red>否则将无法领取活动奖励</color></B>\\n<B>活动期间内累计坚持 3 天</B>每日运动时长达<B> 30 分钟</B>，即可领取<B> 30 P币 + 300 论坛积分</B>奖励\\n<B>活动期间内累计坚持 5 天</B>每日运动时长达<B> 30 分钟</B>，即可领取 <B>50 P币 + 500 论坛积分</B>奖励\\n<B>活动期间内累计坚持 8 天</B>每日运动时长达<B> 30 分钟</B>，即可领取<B> 80 P币 + 800 论坛积分</B>奖励\\n注意：运动时长以运动中心《超燃一刻》运动时长数据为准，玩家可在运动中心检查每天运动时长\\n活动详情请见：\\n移动端：【PICO VR 助手】——>【最新活动】——>【找到对应活动即可】\\nPC端：【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\",\"AnnouceDetailEN\":\"活动时间段：2022 年 11 月 6 日  至 11 月 15 日\\n其中活动二时间为：2022 年 11 月 6 日  至 11 月 9 日\\n【活动一】\\n在所有课程中，<B>寻找『拳王邹市明』榜上留名的关卡</B>，完成该课程并与拳王在排行榜合影，将截图上传至排行榜，即可获得<B> 288 </B>论坛积分奖励\\n【活动二】\\n活动期间内，挑战<B>『拳王邹市明』</B>完成的《力量掌握》拳击训练课程，若分数达到 14000 分及以上，将分数结算截图上传至排行榜，即可获得<B> 188 P币</B>奖励\\n【活动三】\\n<B>参与条件：完成【活动一】并截图上传排行榜，即可参与【活动三】，<color=red>否则将无法领取活动奖励</color></B>\\n<B>活动期间内累计坚持 3 天</B>每日运动时长达<B> 30 分钟</B>，即可领取<B> 30 P币 + 300 论坛积分</B>奖励\\n<B>活动期间内累计坚持 5 天</B>每日运动时长达<B> 30 分钟</B>，即可领取 <B>50 P币 + 500 论坛积分</B>奖励\\n<B>活动期间内累计坚持 8 天</B>每日运动时长达<B> 30 分钟</B>，即可领取<B> 80 P币 + 800 论坛积分</B>奖励\\n注意：运动时长以运动中心《超燃一刻》运动时长数据为准，玩家可在运动中心检查每天运动时长\\n活动详情请见：\\n移动端：【PICO VR 助手】——>【最新活动】——>【找到对应活动即可】\\nPC端：【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\",\"ImgTitleURLCN\":\"Ann007TitleCN\",\"ImgTitleURLEN\":\"Ann007TitleEN\",\"ImgDetailURLCN\":\"Ann007DetailCN\",\"ImgDetailURLEN\":\"Ann007DetailEN\"},{\"AnnID\":\"Ann006\",\"DateStart\":\"2022/10/31 0:00:00\",\"DateEnd\":\"2022/10/31 0:00:00\",\"AnnouceTitleCN\":\"最新活动\",\"AnnouceTitleEN\":\"最新活动\",\"AnnouceDetailCN\":\"活动时间：10月31日-11月5日\\n【活动一】\\n活动期间内，所有更新至v1.0.3版本并完成任意一节【超级猩猩专栏】私教课程的用户，即可领取 200 论坛积分奖励\\n【活动二】\\n活动期间内，累计三天，每天使用《超燃一刻》运动时长达到 60 分钟的用户，可领取 500 论坛积分奖励\\n注意：运动时长以运动中心数据为准，玩家可在运动中心检查每天运动时长\\n活动详情请见【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\",\"AnnouceDetailEN\":\"活动时间：10月31日-11月5日\\n【活动一】\\n活动期间内，所有更新至v1.0.3版本并完成任意一节【超级猩猩专栏】私教课程的用户，即可领取 200 论坛积分奖励\\n【活动二】\\n活动期间内，累计三天，每天使用《超燃一刻》运动时长达到 60 分钟的用户，可领取 500 论坛积分奖励\\n注意：运动时长以运动中心数据为准，玩家可在运动中心检查每天运动时长\\n活动详情请见【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\",\"ImgTitleURLCN\":\"Ann005TitleCN\",\"ImgTitleURLEN\":\"Ann005TitleEN\",\"ImgDetailURLCN\":\"Ann005DetailCN\",\"ImgDetailURLEN\":\"Ann005DetailEN\"},{\"AnnID\":\"Ann005\",\"DateStart\":\"2022/10/18 0:00:00\",\"DateEnd\":\"2022/10/19 0:00:00\",\"AnnouceTitleCN\":\"最新活动\",\"AnnouceTitleEN\":\"最新活动\",\"AnnouceDetailCN\":\"活动时间：10月20日-11月3日\\n参与须知：参与活动前需要先在应用内任意截图，并通过“截图上传至排行榜”功能上传至排行榜，视为报名参与活动，否则将无法领取活动一、活动二奖励\\n【活动一：乐享运动】\\n每日完成任意一节课程，视为完成当日打卡，即可获得当日 <B>100 论坛积分奖励，最高可得1500论坛积分奖励；</B>\\n【活动二：燃动奖池】\\n活动期间内，每天使用《超燃一刻》自由体验课程，运动时长达到30分钟，累计天数达到活动要求即可参与积分奖池瓜分。运动时长以运动中心数据为准\\n<B>具体活动奖励如下：</B>\\n - <B>累计坚持 4 天</B>每日运动时长达 <B>30 分钟，</B>可参与第一梯度 <B>5</B> 万论坛积分奖池瓜分；\\n - <B>累计坚持 8 天</B>每日运动时长达<B> 30 分钟，</B>可参与第二梯度 <B>10</B> 万论坛积分奖池瓜分；\\n - <B>累计坚持 12 天</B>每日运动时长达 <B>30 分钟，</B>可参与第二梯度 <B>10</B> 万论坛积分奖池瓜分；\\n活动详情请见【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\\n  \",\"AnnouceDetailEN\":\"活动时间：10月20日-11月3日\\n参与须知：参与活动前需要先在应用内任意截图，并通过“截图上传至排行榜”功能上传至排行榜，视为报名参与活动，否则将无法领取活动一、活动二奖励\\n【活动一：乐享运动】\\n每日完成任意一节课程，视为完成当日打卡，即可获得当日 <B>100 论坛积分奖励，最高可得1500论坛积分奖励；</B>\\n【活动二：燃动奖池】\\n活动期间内，每天使用《超燃一刻》自由体验课程，运动时长达到30分钟，累计天数达到活动要求即可参与积分奖池瓜分。运动时长以运动中心数据为准\\n<B>具体活动奖励如下：</B>\\n - <B>累计坚持 4 天</B>每日运动时长达 <B>30 分钟，</B>可参与第一梯度 <B>5</B> 万论坛积分奖池瓜分；\\n - <B>累计坚持 8 天</B>每日运动时长达<B> 30 分钟，</B>可参与第二梯度 <B>10</B> 万论坛积分奖池瓜分；\\n - <B>累计坚持 12 天</B>每日运动时长达 <B>30 分钟，</B>可参与第二梯度 <B>10</B> 万论坛积分奖池瓜分；\\n活动详情请见【PICO官方社区】——>【超燃一刻板块专区】置顶活动帖\\n  \",\"ImgTitleURLCN\":\"Ann005TitleCN\",\"ImgTitleURLEN\":\"Ann005TitleEN\",\"ImgDetailURLCN\":\"Ann005DetailCN\",\"ImgDetailURLEN\":\"Ann005DetailEN\"},{\"AnnID\":\"Ann001\",\"DateStart\":\"2022/9/26 0:00:00\",\"DateEnd\":\"2023/9/26 0:00:00\",\"AnnouceTitleCN\":\"使用小提示\",\"AnnouceTitleEN\":\"使用小提示\",\"AnnouceDetailCN\":\"四条必看信息：\\n1、强烈建议在首次体验时，先耐心完成新手引导，可以更好地了解如何在VR世界中健身，你可以在【今日推荐中】找到它\\n2、左手柄菜单键：在体验私教课程中，可以使用【菜单键】暂停，选择开启或关闭运动数据的实时显示。在体验拳击、双棍训练时，可以使用【菜单键】暂停，自由调节所站立的平台大小\\n3、体验私教课程中，卡路里消耗的单位目前为【卡（cal）】，而生活中常见的单位为【千卡（Kcal）】，1千=1000卡，未来我们会接入PICO运动中心，带来更完善的运动数据统计\\n4、为了获得更好的运动效果，建议录入准确的个人信息，如果需要修改，请点击主界面上方个人头像\",\"AnnouceDetailEN\":\"四条必看信息：\\n1、强烈建议在首次体验时，先耐心完成新手引导，可以更好地了解如何在VR世界中健身，你可以在【今日推荐中】找到它\\n2、左手柄菜单键：在体验私教课程中，可以使用【菜单键】暂停，选择开启或关闭运动数据的实时显示。在体验拳击、双棍训练时，可以使用【菜单键】暂停，自由调节所站立的平台大小\\n3、体验私教课程中，卡路里消耗的单位目前为【卡（cal）】，而生活中常见的单位为【千卡（Kcal）】，1千=1000卡，未来我们会接入PICO运动中心，带来更完善的运动数据统计\\n4、为了获得更好的运动效果，建议录入准确的个人信息，如果需要修改，请点击主界面上方个人头像\",\"ImgTitleURLCN\":\"Ann001TitleCN\",\"ImgTitleURLEN\":\"Ann001TitleEN\",\"ImgDetailURLCN\":\"Ann001DetailCN\",\"ImgDetailURLEN\":\"Ann001DetailEN\"},{\"AnnID\":\"Ann002\",\"DateStart\":\"2022/9/26 0:00:00\",\"DateEnd\":\"2022/9/26 0:00:00\",\"AnnouceTitleCN\":\"提升健身效果\",\"AnnouceTitleEN\":\"提升健身效果\",\"AnnouceDetailCN\":\"做到以下三点，你可以收获更好的健身效果：                          1、拳击训练时，可保持拳击站姿（双脚前后站立），击打障碍物时模仿拳击出拳动作，能够更快的进入运动状态。躲避飞来的【激光横杆】时，收紧你的核心肌肉群，采用拳击身法的左右闪躲                                                                                                 2、双棍训练时，不要偷懒只使用手腕，尽可能大幅度、舒展的挥动手臂击打目标物，可以有效提升上肢锻炼效果，穿过【障碍门】时，尽量挺直上身，屈膝深蹲穿过障碍门，可大幅提升燃脂效果                                                                                         3、体验私教课程时，认真听讲并努力完成每一个动作，随教练的指导，保持全身跟发力的状态，可获得最佳效果。如果一次没有学会，没关系，你可以不断的重复同一个课程\",\"AnnouceDetailEN\":\"做到以下三点，你可以收获更好的健身效果：                          1、拳击训练时，可保持拳击站姿（双脚前后站立），击打障碍物时模仿拳击出拳动作，能够更快的进入运动状态。躲避飞来的【激光横杆】时，收紧你的核心肌肉群，采用拳击身法的左右闪躲                                                                                                 2、双棍训练时，不要偷懒只使用手腕，尽可能大幅度、舒展的挥动手臂击打目标物，可以有效提升上肢锻炼效果，穿过【障碍门】时，尽量挺直上身，屈膝深蹲穿过障碍门，可大幅提升燃脂效果                                                                                         3、体验私教课程时，认真听讲并努力完成每一个动作，随教练的指导，保持全身跟发力的状态，可获得最佳效果。如果一次没有学会，没关系，你可以不断的重复同一个课程\",\"ImgTitleURLCN\":\"Ann002TitleCN\",\"ImgTitleURLEN\":\"Ann002TitleEN\",\"ImgDetailURLCN\":\"Ann002DetailCN\",\"ImgDetailURLEN\":\"Ann002DetailEN\"},{\"AnnID\":\"Ann003\",\"DateStart\":\"2022/9/26 0:00:00\",\"DateEnd\":\"2023/9/26 0:00:00\",\"AnnouceTitleCN\":\"问题与解答\",\"AnnouceTitleEN\":\"问题与解答\",\"AnnouceDetailCN\":\"Q：私教课程和拳击/双棍训练分别是什么？\\nA：私教课程：专业的教练及丰富的私教课程，明星教练面对面教学，为VR设备定制的专属课程，足不出户体验沉浸式私教课程。太极、拳击、剑术格斗、舞蹈、芭蕾、热舞减脂操...种类丰富、难度细分，适合各类人群\\n拳击/双棍训练：独特的拳击/双棍模式，结合了运动和音乐的玩法。精心挑选动感十足的音乐，专属BGM加持，跟随动感音乐尽情律动你的身体，快乐运动，尽情燃脂\\nQ：课程预载是什么？\\nA：当选择任何一个课程后，在主界面右方会出现进入课程和课程预载的按钮。首次进入时，不论先择哪种方式，都需要下载该课程。你可以根据自己的网络状况选择下载方式，以后每次进入已完成预载的课程，则无需下载，可直接进入课程\\n课程选择界面，带有下载标志的课程则是你还没有进入过或预下载过的课程，记得及时去体验呦\\nQ：如何跳过课程热身？\\nA：热爱健身的你肯定会经常体验同一课程，但每次都出现的热身环节如果让你感觉有些【漫长】，你可以按左手柄菜单键（“—”键），选择跳过即可\",\"AnnouceDetailEN\":\"Q：私教课程和拳击/双棍训练分别是什么？\\nA：私教课程：专业的教练及丰富的私教课程，明星教练面对面教学，为VR设备定制的专属课程，足不出户体验沉浸式私教课程。太极、拳击、剑术格斗、舞蹈、芭蕾、热舞减脂操...种类丰富、难度细分，适合各类人群\\n拳击/双棍训练：独特的拳击/双棍模式，结合了运动和音乐的玩法。精心挑选动感十足的音乐，专属BGM加持，跟随动感音乐尽情律动你的身体，快乐运动，尽情燃脂\\nQ：课程预载是什么？\\nA：当选择任何一个课程后，在主界面右方会出现进入课程和课程预载的按钮。首次进入时，不论先择哪种方式，都需要下载该课程。你可以根据自己的网络状况选择下载方式，以后每次进入已完成预载的课程，则无需下载，可直接进入课程\\n课程选择界面，带有下载标志的课程则是你还没有进入过或预下载过的课程，记得及时去体验呦\\nQ：如何跳过课程热身？\\nA：热爱健身的你肯定会经常体验同一课程，但每次都出现的热身环节如果让你感觉有些【漫长】，你可以按左手柄菜单键（“—”键），选择跳过即可\",\"ImgTitleURLCN\":\"Ann003TitleCN\",\"ImgTitleURLEN\":\"Ann003TitleEN\",\"ImgDetailURLCN\":\"Ann003DetailCN\",\"ImgDetailURLEN\":\"Ann003DetailEN\"},{\"AnnID\":\"Ann004\",\"DateStart\":\"2022/9/26 0:00:00\",\"DateEnd\":\"2022/12/30 0:00:00\",\"AnnouceTitleCN\":\"订阅赠予公告\",\"AnnouceTitleEN\":\"订阅赠予公告\",\"AnnouceDetailCN\":\"欢迎来到《超燃一刻》，为了帮你更好的开启虚拟运动健身之旅，为了鼓励更多用户参与到运动健身中来，即日起我们将为所有用户赠送【限时免费的订阅会员】！\\n详情如下：\\n 每名用户首次进入《超燃一刻》，即可获得长达【6个月】的订阅会员\\n拥有订阅会员后，你可以畅享所有会员专属内容\\n活动时间：2022年9月27日至12月31日\\n到期后将不再赠送，已获得赠送的用户将继续享受已拥有的订阅会员直至到期\\n我们致力于打造一个内容更加丰富的健身世界，未来将会持续更新私教课程、运动训练\\n关于订阅会员的【价格】、【优惠】、【福利】、【赠送】等信息，请关注后续公告\",\"AnnouceDetailEN\":\"欢迎来到《超燃一刻》，为了帮你更好的开启虚拟运动健身之旅，为了鼓励更多用户参与到运动健身中来，即日起我们将为所有用户赠送【限时免费的订阅会员】！\\n详情如下：\\n 每名用户首次进入《超燃一刻》，即可获得长达【6个月】的订阅会员\\n拥有订阅会员后，你可以畅享所有会员专属内容\\n活动时间：2022年9月27日至12月31日\\n到期后将不再赠送，已获得赠送的用户将继续享受已拥有的订阅会员直至到期\\n我们致力于打造一个内容更加丰富的健身世界，未来将会持续更新私教课程、运动训练\\n关于订阅会员的【价格】、【优惠】、【福利】、【赠送】等信息，请关注后续公告\",\"ImgTitleURLCN\":\"Ann004TitleCN\",\"ImgTitleURLEN\":\"Ann004TitleEN\",\"ImgDetailURLCN\":\"Ann004DetailCN\",\"ImgDetailURLEN\":\"Ann004DetailEN\"}]}");
			SNCheckUrlData snd = JsonUtility.FromJson<SNCheckUrlData>("{\"SNCheckUrl\":\"http://159.138.103.195:3002\"}");
			ServerMaintenData smd = JsonUtility.FromJson<ServerMaintenData>("{\"MainTenDataList\":[{\"Version\":\"1.1.0.0\",\"IsInMainten\":false,\"DetailTextCN\":\"我们目前正在对《超燃一刻》的服务器进行维护，在维护期间，将暂时无法使用《超燃一刻》。维护于 yyyy年mm月dd日 开始，预计持续 x 小时。维护完成后将会更新全新版本，建议您在WIFI环境下前往PICO商店升级。\",\"DetailTextEN\":\"EN停服更新，预计xxx恢复\"},{\"Version\":\"1.0.5.0\",\"IsInMainten\":false,\"DetailTextCN\":\"CN停服更新，预计xxx恢复\",\"DetailTextEN\":\"EN停服更新，预计xxx恢复\"}]}");
			csCloudSettings.Init(gameVersionData, titledata, sportPlanData, urlDataInPlayFab, vvd, ad, snd, smd);
			if (callback != null)
			{
				callback();
			}
			return;
		}
		float startTime = Time.realtimeSinceStartup;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_04" },
			{ "step_name", "GameConfigurationGeneration" },
			{ "status", "start" }
		});
		string value = $"{{\"token\":\"{loginInfo.token}\",\"dataversion\":\"{csGameSettings.GameVersion}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		csSelfHostServerAPI.instance.GetVersionData(wWWForm, delegate(string actSuccess)
		{
			UnityEngine.Debug.LogError("actSuccess:" + actSuccess);
			Dictionary<string, object> dictionary = JsonMapper.ToObject<Dictionary<string, object>>(JsonUtility.FromJson<GameSettingsResult>(actSuccess).data[0].data);
			GameVersionData version = JsonUtility.FromJson<GameVersionData>(dictionary["GameVersionData"].ToString());
			TitleDataInPlayFab titledata2 = JsonUtility.FromJson<TitleDataInPlayFab>(dictionary["TitleData"].ToString());
			SportPlanDataInPlayFab sportPlanData2 = JsonUtility.FromJson<SportPlanDataInPlayFab>(dictionary["SportPlanData"].ToString());
			UrlDataInPlayFab urlDataInPlayFab2 = JsonUtility.FromJson<UrlDataInPlayFab>(dictionary["GameDataURLs"].ToString());
			VersionedVideoVersionData vvd2 = JsonUtility.FromJson<VersionedVideoVersionData>(dictionary["VersionedVideoVersionData"].ToString());
			AnnouncementData ad2 = JsonUtility.FromJson<AnnouncementData>(dictionary["AnnouncementData"].ToString());
			SNCheckUrlData snd2 = JsonUtility.FromJson<SNCheckUrlData>(dictionary["SNCheckUrlData"].ToString());
			ServerMaintenData smd2 = JsonUtility.FromJson<ServerMaintenData>(dictionary["ServerMaintenData"].ToString());
			csCloudSettings.Init(version, titledata2, sportPlanData2, urlDataInPlayFab2, vvd2, ad2, snd2, smd2);
			if (callback != null)
			{
				callback();
			}
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_04" },
				{ "step_name", "GameConfigurationGenerationSuccess" },
				{ "status", "end" },
				{
					"duration",
					(int)((Time.realtimeSinceStartup - startTime) * 1000f)
				}
			});
		}, delegate
		{
			PlayfabSettingsInitDataFailed(callback);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_04" },
				{ "step_name", "GameConfigurationGenerationFailure" },
				{ "status", "end" },
				{
					"duration",
					(int)((Time.realtimeSinceStartup - startTime) * 1000f)
				}
			});
		});
	}

	public void PlayfabSettingsInitDataFailed(Action callback)
	{
		if (csLogin.instance.TTLShow)
		{
			return;
		}
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			InitGameSettings(callback);
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				callback?.Invoke();
			});
		});
		csLogin.instance.openDisconnectPanel();
	}

	private void PlayfabInitDataFailed(Action<int, Dictionary<string, string>, string> callback)
	{
		if (csLogin.instance.TTLShow)
		{
			return;
		}
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			InitUserData(callback);
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				if (AccountWithoutData)
				{
					if (callback != null)
					{
						callback(0, null, "");
					}
				}
				else if (callback != null)
				{
					callback(1, data, "");
				}
			});
		});
		csLogin.instance.openDisconnectPanel();
	}

	public void InitUserData(Action<int, Dictionary<string, string>, string> callback)
	{
		if (!IsClientLoggedIn)
		{
			return;
		}
		if (csGameSettings.IsOfflineVersion)
		{
			AccountWithoutData = false;
			data.Clear();
			data.Add("PlayerInfoInPlayfab", JsonUtility.ToJson(csCloudStorage.instance.m_PlayerInfoInPlayfab));
			data.Add("PicoAccountInfoInPlayfab", JsonUtility.ToJson(new PicoAccountInfo()));
			data.Add("PlayerPlayInfoInPlayfab", JsonUtility.ToJson(new playerPlayInfo()));
			data.Add("PlayerClassHistoryData", JsonUtility.ToJson(new PlayerClassHistoryData()));
			data.Add("PlayerClockInData", JsonUtility.ToJson(new clockInData()));
			data.Add("PlayerPlanData", JsonUtility.ToJson(new PlayerPlanDataInPlayFab()));
			data.Add("PlayerCareerData", JsonUtility.ToJson(new daySportInfoDataInPlayfab()));
			PlayerOrderData playerOrderData = new PlayerOrderData();
			DateTime dateTime = new DateTime(2022, 12, 7);
			DateTime tempVIPEndDate = csGameSettings.TempVIPEndDate;
			playerOrderData.InitData(dateTime.ToString(new CultureInfo("zh-cn")), tempVIPEndDate.ToString(new CultureInfo("zh-cn")), OrderType.Once, OrderDevice.Neo3);
			data.Add("PlayerOrderData", csPlayerOrderManager.instance.EncodeOrderData(playerOrderData));
			data.Add("PlayerAllTimeBeheaviorData", JsonUtility.ToJson(new PlayerAllTimeBeheaviorData()));
			data.Add("PlayerClassScoreData", JsonUtility.ToJson(new PlayerClassScoreData()));
			data.Add("PlayerDailyGoalData", JsonUtility.ToJson(new PlayerDailyGoalData()));
			if (callback != null)
			{
				callback(1, data, "");
			}
			return;
		}
		float startTime = Time.realtimeSinceStartup;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
		{
			{ "step_id", "AppLoadingStep_05" },
			{ "step_name", "PersonalDataGeneration" },
			{ "status", "start" }
		});
		string value = $"{{\"token\":\"{loginInfo.token}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		csSelfHostServerAPI.instance.GetUserData(wWWForm, delegate(string actSuccess)
		{
			PlayerSettingsResult playerSettingsResult = JsonUtility.FromJson<PlayerSettingsResult>(actSuccess);
			Dictionary<string, object> dictionary = JsonMapper.ToObject<Dictionary<string, object>>(playerSettingsResult.data[0].data);
			selfHostServerID = playerSettingsResult.data[0].playerid;
			if (dictionary.Count == 0)
			{
				AccountWithoutData = true;
			}
			else
			{
				AccountWithoutData = false;
				data.Clear();
				data.Add("PlayerInfoInPlayfab", dictionary["PlayerInfoInPlayfab"].ToString());
				data.Add("PicoAccountInfoInPlayfab", dictionary["PicoAccountInfoInPlayfab"].ToString());
				data.Add("PlayerPlayInfoInPlayfab", dictionary["PlayerPlayInfoInPlayfab"].ToString());
				data.Add("PlayerClassHistoryData", dictionary["PlayerClassHistoryData"].ToString());
				data.Add("PlayerClockInData", dictionary["PlayerClockInData"].ToString());
				data.Add("PlayerPlanData", dictionary["PlayerPlanData"].ToString());
				data.Add("PlayerCareerData", dictionary["PlayerCareerData"].ToString());
				data.Add("PlayerOrderData", dictionary["PlayerOrderData"].ToString());
				data.Add("PlayerAllTimeBeheaviorData", dictionary["PlayerAllTimeBeheaviorData"].ToString());
				data.Add("PlayerClassScoreData", dictionary["PlayerClassScoreData"].ToString());
				data.Add("PlayerDailyGoalData", dictionary.ContainsKey("PlayerDailyGoalData") ? dictionary["PlayerDailyGoalData"].ToString() : JsonUtility.ToJson(new PlayerDailyGoalData()));
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
				{
					{ "step_id", "AppLoadingStep_05" },
					{ "step_name", "PersonalDataGenerationSuccess" },
					{ "status", "end" },
					{
						"duration",
						(int)((Time.realtimeSinceStartup - startTime) * 1000f)
					}
				});
			}
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
			}
			else if (dictionary.Count == 0)
			{
				if (callback != null)
				{
					callback(0, null, "");
				}
			}
			else if (callback != null)
			{
				callback(1, data, "");
			}
		}, delegate
		{
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: false);
			}
			PlayfabInitDataFailed(callback);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_05" },
				{ "step_name", "PersonalDataGenerationFailure" },
				{ "status", "end" },
				{
					"duration",
					(int)((Time.realtimeSinceStartup - startTime) * 1000f)
				}
			});
		});
	}

	public void SetDefaultData(Dictionary<string, string> data, Action callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayFabClientAPI.UpdateUserData(new UpdateUserDataRequest
		{
			Data = data,
			Permission = UserDataPermission.Public
		}, delegate
		{
			if (callback != null)
			{
				callback();
			}
		}, delegate(PlayFabError error)
		{
			if (error.GenerateErrorReport().Contains("Cannot resolve destination host") || error.GenerateErrorReport().Contains("Unable to complete SSL connection"))
			{
				csPhotonLobby.instance.OnDisconnected(DisconnectCause.Exception);
			}
			else
			{
				SetDefaultData(data, callback);
			}
		});
	}

	public void SetDefaultData(Dictionary<string, object> playerData, Action callback)
	{
		string d = JsonMapper.ToJson(playerData);
		string encode = csSelfHostServerAPI.instance.GetEncode(d);
		string value = $"{{\"token\":\"{loginInfo.token}\",\"data\":\"{encode}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		csSelfHostServerAPI.instance.UpdateUserData(wWWForm, delegate
		{
			if (callback != null)
			{
				callback();
			}
		}, delegate
		{
		});
	}

	public void DeleteUserData(List<string> deleteKeys, Action<bool> callback)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		PlayFabClientAPI.UpdateUserData(new UpdateUserDataRequest
		{
			KeysToRemove = deleteKeys,
			Permission = UserDataPermission.Private
		}, delegate
		{
			if (callback != null)
			{
				callback(obj: true);
			}
		}, delegate
		{
			if (callback != null)
			{
				callback(obj: false);
			}
		});
	}

	public void IsMediaLicense(Action<bool> callback)
	{
		GetTitleDataRequest request = new GetTitleDataRequest();
		new List<string>().Add("MediaLicense");
		PlayFabClientAPI.GetTitleData(request, delegate(GetTitleDataResult result)
		{
			bool flag = false;
			string text = result.Data["MediaLicense"];
			if (!string.IsNullOrEmpty(text))
			{
				flag = text.Split(';').ToList().Contains(PlayfabID);
				PlayerIsMedia = flag;
			}
			if (callback != null)
			{
				callback(flag);
			}
		}, delegate
		{
			if (callback != null)
			{
				callback(obj: false);
			}
		});
	}

	public void PlayfabLoginFailed(string userid, Action<int, Dictionary<string, string>, string> callback)
	{
		if (csLogin.instance.TTLShow)
		{
			return;
		}
		csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
		{
			Login(userid, callback);
		}, delegate
		{
			Application.Quit();
		}, delegate
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				if (isFirstLogin)
				{
					if (callback != null)
					{
						callback(0, null, "");
					}
				}
				else
				{
					InitUserData(callback);
				}
			});
		});
		csLogin.instance.openDisconnectPanel();
	}

	public void Login(string userid, Action<int, Dictionary<string, string>, string> callback, float startTime = 0f)
	{
		LoginWithCustomIDRequest loginWithCustomIDRequest = new LoginWithCustomIDRequest();
		loginWithCustomIDRequest.CustomId = userid;
		loginWithCustomIDRequest.CreateAccount = true;
		if (csGameSettings.IsOfflineVersion)
		{
			selfHostServerID = userid;
			InitUserData(callback);
			return;
		}
		PlayFabClientAPI.LoginWithCustomID(loginWithCustomIDRequest, delegate(LoginResult result)
		{
			playfabID = result.PlayFabId;
			UnityEngine.Debug.LogError("PlayfabID:" + playfabID);
		}, delegate
		{
			UnityEngine.Debug.LogError("playfab登录失败！！");
		});
		csSelfHostServerAPI.instance.Login(userid, delegate(string actSuccess)
		{
			selfHostServerID = userid;
			UnityEngine.Debug.LogError("SelfHostServerID:" + selfHostServerID);
			Dictionary<string, object> dictionary = JsonMapper.ToObject<Dictionary<string, object>>(actSuccess);
			loginInfo.token = dictionary["token"].ToString();
			loginInfo.isnewcreate = (int)dictionary["isnewcreate"];
			if (loginInfo.isnewcreate == 1)
			{
				isFirstLogin = true;
			}
			else
			{
				isFirstLogin = false;
			}
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: true);
			}
			else
			{
				trylogintime = 0;
				if (loginInfo.isnewcreate == 1)
				{
					isFirstLogin = true;
					if (callback != null)
					{
						callback(0, null, "");
					}
				}
				else
				{
					isFirstLogin = false;
					InitUserData(callback);
				}
			}
		}, delegate(string actFailed)
		{
			if (csMainMenuManager.instance.disconnectPanel.isOpend)
			{
				csMainMenuManager.instance.disconnectPanel.OnRetryCallBack(isSuccess: false);
			}
			PlayfabLoginFailed(userid, callback);
			UnityEngine.Debug.LogError("SelfHostServer登录失败！详情为：" + actFailed);
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.app_loading_flow, new Dictionary<string, object>
			{
				{ "step_id", "AppLoadingStep_02" },
				{ "step_name", "GetTheBackEndDataFailure" },
				{ "status", "end" },
				{
					"duration",
					(int)((Time.realtimeSinceStartup - startTime) * 1000f)
				}
			});
		});
	}

	public void RefreshToken()
	{
		csSelfHostServerAPI.instance.Login(selfHostServerID, delegate(string actSuccess)
		{
			Dictionary<string, object> dictionary = JsonMapper.ToObject<Dictionary<string, object>>(actSuccess);
			loginInfo.token = dictionary["token"].ToString();
		}, delegate
		{
		});
	}

	public void GetMyStaticsByName(string boardName, Action<int> valueGetAction)
	{
		if (csGameSettings.IsOfflineVersion)
		{
			return;
		}
		GetPlayerStatisticsRequest request = new GetPlayerStatisticsRequest
		{
			StatisticNames = new List<string> { boardName }
		};
		int myValue = 0;
		PlayFabClientAPI.GetPlayerStatistics(request, delegate(GetPlayerStatisticsResult x)
		{
			if (x.Statistics.Count > 0)
			{
				myValue = x.Statistics[0].Value;
				valueGetAction(myValue);
			}
			else
			{
				valueGetAction(0);
			}
		}, null);
	}

	public void SubmitScore(int playerScore, string leaderboardName, Action<UpdatePlayerStatisticsResult> ResultCallBack, Action<PlayFabError> SubmitScoreFailureCallback)
	{
		if (!csGameSettings.IsOfflineVersion && PlayFabClientAPI.IsClientLoggedIn())
		{
			PlayFabClientAPI.UpdatePlayerStatistics(new UpdatePlayerStatisticsRequest
			{
				Statistics = new List<StatisticUpdate>
				{
					new StatisticUpdate
					{
						StatisticName = leaderboardName,
						Value = playerScore
					}
				}
			}, ResultCallBack, SubmitScoreFailureCallback);
		}
	}

	public void RequestLeaderBoardAct(string LeaderBoardName, int startPos, int MaxCount, Action<GetLeaderboardResult> OnGetResultCallBack, Action<PlayFabError> OnErrorCallBack)
	{
		if (!csGameSettings.IsOfflineVersion && PlayFabClientAPI.IsClientLoggedIn())
		{
			PlayFabClientAPI.GetLeaderboard(new GetLeaderboardRequest
			{
				StatisticName = LeaderBoardName,
				StartPosition = startPos,
				MaxResultsCount = MaxCount,
				ProfileConstraints = new PlayerProfileViewConstraints
				{
					ShowAvatarUrl = true,
					ShowDisplayName = true,
					ShowTags = true
				}
			}, OnGetResultCallBack, OnErrorCallBack);
		}
	}

	public void RequestLeaderBoardAroundMy(string LeaderBoardName, int MaxCount, Action<GetLeaderboardAroundPlayerResult> OnGetResultCallBack, Action<PlayFabError> OnErrorCallBack)
	{
		if (!csGameSettings.IsOfflineVersion && PlayFabClientAPI.IsClientLoggedIn())
		{
			PlayFabClientAPI.GetLeaderboardAroundPlayer(new GetLeaderboardAroundPlayerRequest
			{
				StatisticName = LeaderBoardName,
				MaxResultsCount = MaxCount,
				PlayFabId = playfabID
			}, OnGetResultCallBack, OnErrorCallBack);
		}
	}

	public void GetMyLeaderBoardData(string LeaderBoardName, Action<PlayerLeaderboardEntry> OnGetResultCallBack, Action<PlayFabError> OnErrorCallBack)
	{
		RequestLeaderBoardAroundMy(LeaderBoardName, 1, delegate(GetLeaderboardAroundPlayerResult result)
		{
			for (int i = 0; i < result.Leaderboard.Count; i++)
			{
				if (result.Leaderboard[i].PlayFabId == playfabID)
				{
					OnGetResultCallBack(result.Leaderboard[i]);
					break;
				}
			}
		}, delegate(PlayFabError errorResult)
		{
			OnErrorCallBack(errorResult);
		});
	}

	public void StartGetAvatar(string id, string url, UnityAction<int, Sprite> onSpriteGet)
	{
		StartCoroutine(GetAvatarImage(id, url, onSpriteGet));
	}

	private IEnumerator GetAvatarImage(string id, string url, UnityAction<int, Sprite> onSpriteGet)
	{
		if (string.IsNullOrEmpty(url))
		{
			onSpriteGet(0, null);
			yield break;
		}
		if (AvatarCacheDic.ContainsKey(id))
		{
			onSpriteGet(1, AvatarCacheDic[id]);
			yield break;
		}
		WWW www = new WWW(url);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			Texture2D texture = www.texture;
			Sprite value = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
			if (!AvatarCacheDic.ContainsKey(id))
			{
				AvatarCacheDic.Add(id, value);
			}
			onSpriteGet(1, AvatarCacheDic[id]);
		}
		else
		{
			onSpriteGet(0, null);
		}
	}
}
public class csSelfHostServerAPI : MonoBehaviour
{
	public static csSelfHostServerAPI instance;

	private bool isTestUrl;

	private static string urlOnline = "https://olympia-web-cn.picovr.com";

	private static string urlTest = "http://47.94.52.192:3000";

	private string publicKey = "-----BEGIN PUBLIC KEY-----\r\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCaXxLl7sOhNo7ARpXqO6HbZ4TV\r\nrblRS83zNwatmkCFS15P8aJeKz3i+CT0JgOojQAUy2WGkZF4NvbZ+BOzaecuCXXz\r\nz7Rc79A4R64oa3HxwUQHZi4FsDcwMVMaScN7ZSP9DH2PTctJsVdCK5khiMpr2/BI\r\nZivIaz8uu6OwLaaDRwIDAQAB\r\n-----END PUBLIC KEY-----";

	private string key = "YFpoGQ@$VrUMf64tZ9eg^RiaQSZ^Pw%*";

	private static int postID = 0;

	public string Encode(string a)
	{
		return AES.Encrypt(a, key);
	}

	private void Awake()
	{
		if (instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			instance = this;
		}
	}

	public void Login(string userid, UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/login";
		string value = $"{{\"userid\":\"{userid}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		StartCoroutine(DoWWWPOST(url, wWWForm, actSuccess, actFailed));
	}

	public void UpdateUserData(WWWForm udata, UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/updateuserdata";
		StartCoroutine(DoWWWPOST(url, udata, actSuccess, actFailed));
	}

	public void GetUserData(WWWForm udata, UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/getuserdata";
		StartCoroutine(DoWWWPOST(url, udata, actSuccess, actFailed));
	}

	public void GetVersionData(WWWForm udata, UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/getpublicdata";
		StartCoroutine(DoWWWPOST(url, udata, actSuccess, actFailed));
	}

	public void GetServerTime(UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/getservertime";
		StartCoroutine(DoWWWPOST(url, null, actSuccess, actFailed));
	}

	public string GetEncode(string d)
	{
		return Encode(d);
	}

	public void GetOfflineSwitch(UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		string url = (isTestUrl ? urlTest : urlOnline) + "/checkofflineswitch";
		string value = $"{{\"version\":\"{csGameSettings.GameVersion}\"}}";
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("body", value);
		StartCoroutine(DoWWWPOST(url, wWWForm, actSuccess, actFailed));
	}

	private static IEnumerator DoWWWPOST(string url, WWWForm form, UnityAction<string> actSuccess, UnityAction<string> actFailed)
	{
		UnityWebRequest w = UnityWebRequest.Post(url, form);
		w.timeout = 5;
		yield return w.SendWebRequest();
		if (w.isHttpError || w.isNetworkError)
		{
			UnityEngine.Debug.LogError(w.error);
			actFailed?.Invoke(w.error);
		}
		else
		{
			actSuccess?.Invoke(w.downloadHandler.text);
			postID++;
		}
	}

	private static string GetMacAddress()
	{
		string text = "";
		NetworkInterface[] allNetworkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
		foreach (NetworkInterface networkInterface in allNetworkInterfaces)
		{
			UnityEngine.Debug.Log(networkInterface.Description);
			if (networkInterface.Description == "en0")
			{
				text = networkInterface.GetPhysicalAddress().ToString();
				break;
			}
			text = networkInterface.GetPhysicalAddress().ToString();
			if (text != "")
			{
				break;
			}
		}
		return text;
	}
}
[Serializable]
public class LoginInfo
{
	public string token;

	public int isnewcreate;
}
[Serializable]
public class GameSettingsResult
{
	public int code;

	public string message;

	public GameVersionDataResult[] data;
}
[Serializable]
public class GameVersionDataResult
{
	public string dataversion;

	public string data;
}
[Serializable]
public class PlayerSettingsResult
{
	public int code;

	public string message;

	public PlayerDataResult[] data;
}
[Serializable]
public class PlayerDataResult
{
	public string playerid;

	public string data;
}
[Serializable]
public class OfflineSwitchResult
{
	public int code;

	public string message;

	public bool OverAllSwitch;

	public string TempAccountVipEndDate;

	public string AnnText;
}
public class Rsademo : MonoBehaviour
{
	private string privateKey = "-----BEGIN RSA PRIVATE KEY-----\r\nMIICXQIBAAKBgQCzVBO/HUhgU4cIRS2UE255r2uGEaVuPAxrANab5z7rv/hUm1t1\r\nTW9G6qaLvXraUS2c6m4PW+VVY8j/fViIy9XLhd2IdYsbuTNyV6gQVnA4tdMdnJdr\r\nvfzaXiIoPzP3u9Ll8LEQSW2iiludxwBlVz/VdCiAEYBMuYmrmSHsan5ObQIDAQAB\r\nAoGBAIHSy1zfQSdjMO2ez0lU6/SyN0BfBAmS9VZ9y+AgACBB4PC3a/W28mk/tQST\r\nTx5ACKqB2N3LpHI2BCxaPT8DeilfjaUibpOqXJ918+oXmOEpEBpEz2FzkzZWeUOo\r\n8bkDiuEE1RyzQEQExxCbiLQFCpX0NNIpccrTYJ3wRZfroojNAkEA4Pd9xxscmxQM\r\ns4aQgE+/paQWR//B2JQjhsxvYfLhrMUKgWMWpfm5EfhG3AlIE/N7iZADPLZ+2JMG\r\n2ljnE3VdzwJBAMwQ6DJpueg2Yj5+ufTVhFBIkJZXWGIZv5FWmzaycfJOafg/ToRB\r\nQWjU7Dr7buxQ4jgFI6eZcN8uM5pcer/ouwMCQDRCSb2O1r5PkgPCJp8n52UbEPH4\r\nv5cIEpiltNoUCciQnTghRImZ0RwTiKJkpZG85d22zomz+xNkVBs0u7kRcpECQAfH\r\nNTKGuSFSwVfkeK4OXWa5/Vjdp27F0Hl3tZ7WGmXD+2IM968u1ZFrXD27S7USOC0u\r\ndPd0b8rx9eGSWNNryYUCQQCWbiNhKEDQ1+yauWhZwamsc2Zl/Gde0eQYrWlmoZRE\r\nr4w8Xlt8XVBTNBf5ljALeVtXOs0LNuWqnmy1v7wMPvnN\r\n-----END RSA PRIVATE KEY-----";

	public string[] dataList;

	public string[] nDataList;

	private bool result;

	private IEnumerator Start()
	{
		UnityEngine.Debug.Log(GetMacAddress());
		StartCoroutine(CheckKey(GetMacAddress()));
		yield return new WaitForSeconds(2f);
		UnityEngine.Debug.Log(result);
	}

	private IEnumerator CheckKey(string key)
	{
		string text = "data.txt";
		WWW data = new WWW(Application.streamingAssetsPath + "/" + text);
		yield return data;
		if (!string.IsNullOrEmpty(data.error))
		{
			yield break;
		}
		dataList = data.text.Split('\n');
		nDataList = new string[dataList.Length];
		UnityEngine.Debug.Log(dataList.Length);
		for (int i = 0; i < dataList.Length; i++)
		{
			dataList[i] = dataList[i].Replace("\n", "").Replace(" ", "").Replace("\t", "")
				.Replace("\r", "")
				.Replace("\0", "");
			if (!(dataList[i] == ""))
			{
				Encoding.Default.GetBytes(Decode(dataList[i]));
				Encoding.Default.GetBytes(key);
				string @string = Encoding.UTF8.GetString(Encoding.Default.GetBytes(Decode(dataList[i])));
				key = Encoding.UTF8.GetString(Encoding.Default.GetBytes(key));
				UnityEngine.Debug.Log(@string);
				if (@string == key)
				{
					UnityEngine.Debug.Log("wwws");
				}
				if (@string.Equals(key))
				{
					UnityEngine.Debug.Log("wwws");
				}
				if (@string.Contains(key))
				{
					result = true;
				}
				if (key.Contains(@string))
				{
					result = true;
					break;
				}
				continue;
			}
			break;
		}
	}

	public string Decode(string a)
	{
		return RSAHelper.Decrypt(a, privateKey);
	}

	private static string GetMacAddress()
	{
		string text = "";
		NetworkInterface[] allNetworkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
		foreach (NetworkInterface networkInterface in allNetworkInterfaces)
		{
			if (networkInterface.Description == "en0")
			{
				text = networkInterface.GetPhysicalAddress().ToString();
				break;
			}
			text = networkInterface.GetPhysicalAddress().ToString();
			if (text != "")
			{
				break;
			}
		}
		return text;
	}
}
public class RSAHelper
{
	public static string Encript(string value, string pemPublicKey)
	{
		using RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
		rSACryptoServiceProvider.ImportParameters(ConvertFromPemPublicKey(pemPublicKey));
		return Convert.ToBase64String(rSACryptoServiceProvider.Encrypt(Encoding.UTF8.GetBytes(value), fOAEP: false));
	}

	public static string Decrypt(string encryptedData, string pemPrivateKey)
	{
		using RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
		rSACryptoServiceProvider.ImportParameters(ConvertFromPemPrivateKey(pemPrivateKey));
		byte[] array = rSACryptoServiceProvider.Decrypt(Convert.FromBase64String(encryptedData), fOAEP: false);
		return Encoding.UTF8.GetString(array, 0, array.Length);
	}

	public static RSAParameters ConvertFromPemPublicKey(string pemFileConent)
	{
		pemFileConent = pemFileConent.Replace("-----BEGIN PUBLIC KEY-----", "").Replace("-----END PUBLIC KEY-----", "").Replace("\n", "")
			.Replace("\r", "");
		byte[] array = Convert.FromBase64String(pemFileConent);
		bool flag = array.Length == 162;
		bool flag2 = array.Length == 294;
		if (!(flag || flag2))
		{
			throw new ArgumentException("pem file content is incorrect, Only support the key size is 1024 or 2048");
		}
		byte[] array2 = (flag ? new byte[128] : new byte[256]);
		byte[] array3 = new byte[3];
		Array.Copy(array, flag ? 29 : 33, array2, 0, flag ? 128 : 256);
		Array.Copy(array, flag ? 159 : 291, array3, 0, 3);
		RSAParameters result = default(RSAParameters);
		result.Modulus = array2;
		result.Exponent = array3;
		return result;
	}

	public static RSAParameters ConvertFromPemPrivateKey(string pemFileConent)
	{
		if (string.IsNullOrEmpty(pemFileConent))
		{
			throw new ArgumentNullException("pemFileConent", "This arg cann't be empty.");
		}
		pemFileConent = pemFileConent.Replace("-----BEGIN RSA PRIVATE KEY-----", "").Replace("-----END RSA PRIVATE KEY-----", "").Replace("\n", "")
			.Replace("\r", "");
		byte[] array = Convert.FromBase64String(pemFileConent);
		bool flag = array.Length == 609 || array.Length == 610;
		bool flag2 = array.Length == 1190 || array.Length == 1192;
		if (!(flag || flag2))
		{
			throw new ArgumentException("pem file content is incorrect, Only support the key size is 1024 or 2048");
		}
		int num = (flag ? 11 : 12);
		byte[] array2 = (flag ? new byte[128] : new byte[256]);
		Array.Copy(array, num, array2, 0, array2.Length);
		num += array2.Length;
		num += 2;
		byte[] array3 = new byte[3];
		Array.Copy(array, num, array3, 0, 3);
		num += 3;
		num += 4;
		if (array[num] == 0)
		{
			num++;
		}
		byte[] array4 = (flag ? new byte[128] : new byte[256]);
		Array.Copy(array, num, array4, 0, array4.Length);
		num += array4.Length;
		num += ((!flag) ? ((array[num + 2] == 128) ? 3 : 4) : ((array[num + 1] == 64) ? 2 : 3));
		byte[] array5 = (flag ? new byte[64] : new byte[128]);
		Array.Copy(array, num, array5, 0, array5.Length);
		num += array5.Length;
		num += ((!flag) ? ((array[num + 2] == 128) ? 3 : 4) : ((array[num + 1] == 64) ? 2 : 3));
		byte[] array6 = (flag ? new byte[64] : new byte[128]);
		Array.Copy(array, num, array6, 0, array6.Length);
		num += array6.Length;
		num += ((!flag) ? ((array[num + 2] == 128) ? 3 : 4) : ((array[num + 1] == 64) ? 2 : 3));
		byte[] array7 = (flag ? new byte[64] : new byte[128]);
		Array.Copy(array, num, array7, 0, array7.Length);
		num += array7.Length;
		num += ((!flag) ? ((array[num + 2] == 128) ? 3 : 4) : ((array[num + 1] == 64) ? 2 : 3));
		byte[] array8 = (flag ? new byte[64] : new byte[128]);
		Array.Copy(array, num, array8, 0, array8.Length);
		num += array8.Length;
		num += ((!flag) ? ((array[num + 2] == 128) ? 3 : 4) : ((array[num + 1] == 64) ? 2 : 3));
		byte[] array9 = (flag ? new byte[64] : new byte[128]);
		Array.Copy(array, num, array9, 0, array9.Length);
		RSAParameters result = default(RSAParameters);
		result.Modulus = array2;
		result.Exponent = array3;
		result.D = array4;
		result.P = array5;
		result.Q = array6;
		result.DP = array7;
		result.DQ = array8;
		result.InverseQ = array9;
		return result;
	}
}
public class csSwiftAvatarController : MonoBehaviour
{
	public VRIK AvatarVRIK;

	public VRIK AnimVRIK;

	public LegTrackingAvatarSample SampleIK;

	public Transform ManT;

	public Transform DummT;

	public Renderer DummyMan;

	public Animator GayAnim;

	public Transform RightUpLegT;

	public Transform RightLegT;

	public Transform LeftUpLegT;

	public Transform LeftLegT;

	public Transform AvatarT;

	private Transform HeadTrackT;

	private Transform HandLTrackT;

	private Transform HandRTrackT;

	public Transform Head_IKFollowT;

	public Transform HandL_IKFollowT;

	public Transform HandR_IKFollowT;

	public Transform FootL_IKFollowT;

	public Transform FootR_IKFollowT;

	public bool IKIsSet;

	public PlayerState CurState;

	public float KickTriggerAngle = 40f;

	private float KickTriggerRad;

	public float KneeDownLegTriggerAngle = 20f;

	private float KneeDownLegTriggerRad;

	public float KickUpLegTriggerAngle = 40f;

	private float KickUpLegTriggerRad;

	public float KneeTriggerAngle = 60f;

	private float KneeTriggerRad;

	public float kickZTrigger = 0.4f;

	public GameObject DebugInfoO;

	public Text PlayerStateTxt;

	public Text PlayerLUpLegAngleTxt;

	public Text PlayerRUpLegAngleTxt;

	public Text PlayerLDownLegAngleTxt;

	public Text PlayerRDownLegAngleTxt;

	public Text PlayerLKneeSpeed;

	public Text PlayerRKneeSpeed;

	public Text PlayerLKneeStateSpeed;

	public Text PlayerRKneeStateSpeed;

	public Text PlayerLFootSpeed;

	public Text PlayerRFootSpeed;

	public Text PlayerLFootStateSpeed;

	public Text PlayerRFootStateSpeed;

	[Header("脚踢重击速度")]
	public float HardKickSpeed = 4f;

	[Header("膝击重击速度")]
	public float HardKneeSpeed = 1.8f;

	public static bool IsTrackerSet;

	public Text HeightT;

	public GameObject PlayerBody;

	private double displayTime;

	private float LUpLegFwdValue;

	private float RUpLegFwdValue;

	private Vector3 ManPos;

	public float YOffset;

	public float ZOffset;

	private BodyTrackerResult bodyTrackerResult;

	private int SpeedFrameCount = 10;

	private Vector3 TempLKneePos;

	private Vector3 TempRKneePos;

	private Vector3 TempLFootPos;

	private Vector3 TempRFootPos;

	public List<Vector3> LKneePosList = new List<Vector3>();

	public List<Vector3> RKneePosList = new List<Vector3>();

	public List<Vector3> LFootPosList = new List<Vector3>();

	public List<Vector3> RFootPosList = new List<Vector3>();

	private float MagLKnee;

	private float MagRKnee;

	private float MagLFoot;

	private float MagRFoot;

	private float MagLKneeState;

	private float MagRKneeState;

	private float MagLFootState;

	private float MagRFootState;

	private float Length;

	private int pointCount;

	private Vector3 dirLUpLeg = Vector3.zero;

	private Vector3 dirRUpLeg = Vector3.zero;

	private Vector3 dirLDownLeg = Vector3.zero;

	private Vector3 dirRDownLeg = Vector3.zero;

	private void Awake()
	{
		KickTriggerRad = Mathf.Cos((float)Math.PI / 180f * KickTriggerAngle);
		KneeTriggerRad = Mathf.Cos((float)Math.PI / 180f * KneeTriggerAngle);
		KneeDownLegTriggerRad = Mathf.Cos((float)Math.PI / 180f * KneeDownLegTriggerAngle);
		KickUpLegTriggerAngle = Mathf.Cos((float)Math.PI / 180f * KickUpLegTriggerAngle);
		GayAnim.SetBool("LeftStand", value: true);
		DebugInfoO.SetActive(value: false);
	}

	public void InitAvatarIK(Transform head, Transform handl, Transform handr, float height)
	{
		UnityEngine.Debug.LogError("InitAvatarIK");
		IKIsSet = true;
		HeadTrackT = head;
		HandLTrackT = handl;
		HandRTrackT = handr;
		SampleIK.OnPlayerInit(height);
		UpdateAvatarHeigh(height);
	}

	private void UpdateAvatarHeigh(float height)
	{
		HeightT.text = "采集身高:" + height;
		AvatarT.localScale = Vector3.one * height / 1.76f * 1.03f;
		ManT.localScale = Vector3.one * height / 1.76f;
	}

	public void OpenPlayerIK(bool isOpen)
	{
		UnityEngine.Debug.LogError("OpenPlayerIK:" + isOpen);
		PlayerBody.SetActive(isOpen);
	}

	private void Update()
	{
		if (IKIsSet)
		{
			Head_IKFollowT.position = HeadTrackT.position;
			Head_IKFollowT.rotation = HeadTrackT.rotation;
			HandL_IKFollowT.position = HandLTrackT.position;
			HandL_IKFollowT.rotation = HandLTrackT.rotation;
			HandR_IKFollowT.position = HandRTrackT.position;
			HandR_IKFollowT.rotation = HandRTrackT.rotation;
			bodyTrackerResult = default(BodyTrackerResult);
			displayTime = PXR_System.GetPredictedDisplayTime();
			PXR_Input.GetBodyTrackingPose(displayTime, ref bodyTrackerResult);
			TempLKneePos = LeftLegT.position;
			TempRKneePos = RightLegT.position;
			TempLFootPos = FootL_IKFollowT.position;
			TempRFootPos = FootR_IKFollowT.position;
			TempLFootPos = new Vector3((float)bodyTrackerResult.trackingdata[7].localpose.PosX, (float)bodyTrackerResult.trackingdata[7].localpose.PosY, (float)bodyTrackerResult.trackingdata[7].localpose.PosZ);
			FootL_IKFollowT.position = AvatarT.localScale.x * 1.12f * (TempLFootPos - Head_IKFollowT.position) + Head_IKFollowT.position;
			FootL_IKFollowT.rotation = new Quaternion((float)bodyTrackerResult.trackingdata[7].localpose.RotQx, (float)bodyTrackerResult.trackingdata[7].localpose.RotQy, (float)bodyTrackerResult.trackingdata[7].localpose.RotQz, (float)bodyTrackerResult.trackingdata[7].localpose.RotQw);
			TempRFootPos = new Vector3((float)bodyTrackerResult.trackingdata[8].localpose.PosX, (float)bodyTrackerResult.trackingdata[8].localpose.PosY, (float)bodyTrackerResult.trackingdata[8].localpose.PosZ);
			FootR_IKFollowT.position = AvatarT.localScale.x * 1.12f * (TempRFootPos - Head_IKFollowT.position) + Head_IKFollowT.position;
			FootR_IKFollowT.rotation = new Quaternion((float)bodyTrackerResult.trackingdata[8].localpose.RotQx, (float)bodyTrackerResult.trackingdata[8].localpose.RotQy, (float)bodyTrackerResult.trackingdata[8].localpose.RotQz, (float)bodyTrackerResult.trackingdata[8].localpose.RotQw);
			TempLKneePos = new Vector3((float)bodyTrackerResult.trackingdata[4].localpose.PosX, (float)bodyTrackerResult.trackingdata[4].localpose.PosY, (float)bodyTrackerResult.trackingdata[4].localpose.PosZ);
			TempRKneePos = new Vector3((float)bodyTrackerResult.trackingdata[5].localpose.PosX, (float)bodyTrackerResult.trackingdata[5].localpose.PosY, (float)bodyTrackerResult.trackingdata[5].localpose.PosZ);
			LKneePosList.Add(TempLKneePos);
			if (LKneePosList.Count > SpeedFrameCount)
			{
				LKneePosList.RemoveAt(0);
			}
			RKneePosList.Add(TempRKneePos);
			if (RKneePosList.Count > SpeedFrameCount)
			{
				RKneePosList.RemoveAt(0);
			}
			LFootPosList.Add(TempLFootPos);
			if (LFootPosList.Count > SpeedFrameCount)
			{
				LFootPosList.RemoveAt(0);
			}
			RFootPosList.Add(TempRFootPos);
			if (RFootPosList.Count > SpeedFrameCount)
			{
				RFootPosList.RemoveAt(0);
			}
			Length = 0f;
			pointCount = 0;
			for (int i = 0; i < LKneePosList.Count - 1; i++)
			{
				Length += Vector3.Distance(LKneePosList[i + 1], LKneePosList[i]);
				pointCount++;
			}
			MagLKnee = Length / (float)pointCount / Time.deltaTime;
			Length = 0f;
			pointCount = 0;
			for (int j = 0; j < RKneePosList.Count - 1; j++)
			{
				Length += Vector3.Distance(RKneePosList[j + 1], RKneePosList[j]);
				pointCount++;
			}
			MagRKnee = Length / (float)pointCount / Time.deltaTime;
			Length = 0f;
			pointCount = 0;
			for (int k = 0; k < LFootPosList.Count - 1; k++)
			{
				Length += Vector3.Distance(LFootPosList[k + 1], LFootPosList[k]);
				pointCount++;
			}
			MagLFoot = Length / (float)pointCount / Time.deltaTime;
			Length = 0f;
			pointCount = 0;
			for (int l = 0; l < RFootPosList.Count - 1; l++)
			{
				Length += Vector3.Distance(RFootPosList[l + 1], RFootPosList[l]);
				pointCount++;
			}
			MagRFoot = Length / (float)pointCount / Time.deltaTime;
			ManPos = Head_IKFollowT.position;
			ManPos.y = YOffset;
			ManPos.z += ZOffset;
			ManT.position = ManPos;
			DummT.position = ManPos;
			SampleIK.thisT.position = ManPos;
			Vector3 zero = Vector3.zero;
			zero = new Vector3((float)bodyTrackerResult.trackingdata[4].localpose.PosX, (float)bodyTrackerResult.trackingdata[4].localpose.PosY, (float)bodyTrackerResult.trackingdata[4].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[1].localpose.PosX, (float)bodyTrackerResult.trackingdata[1].localpose.PosY, (float)bodyTrackerResult.trackingdata[1].localpose.PosZ);
			zero.Normalize();
			if (Vector3.Dot(zero, Vector3.forward) > 0f)
			{
				PlayerLUpLegAngleTxt.text = (Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f).ToString();
			}
			else
			{
				PlayerLUpLegAngleTxt.text = "-" + Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f;
			}
			zero = new Vector3((float)bodyTrackerResult.trackingdata[5].localpose.PosX, (float)bodyTrackerResult.trackingdata[5].localpose.PosY, (float)bodyTrackerResult.trackingdata[5].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[2].localpose.PosX, (float)bodyTrackerResult.trackingdata[2].localpose.PosY, (float)bodyTrackerResult.trackingdata[2].localpose.PosZ);
			zero.Normalize();
			if (Vector3.Dot(zero, Vector3.forward) > 0f)
			{
				PlayerRUpLegAngleTxt.text = (Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f).ToString();
			}
			else
			{
				PlayerRUpLegAngleTxt.text = "-" + Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f;
			}
			zero = new Vector3((float)bodyTrackerResult.trackingdata[7].localpose.PosX, (float)bodyTrackerResult.trackingdata[7].localpose.PosY, (float)bodyTrackerResult.trackingdata[7].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[4].localpose.PosX, (float)bodyTrackerResult.trackingdata[4].localpose.PosY, (float)bodyTrackerResult.trackingdata[4].localpose.PosZ);
			zero.Normalize();
			if (Vector3.Dot(zero, Vector3.forward) > 0f)
			{
				PlayerLDownLegAngleTxt.text = (Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f).ToString();
			}
			else
			{
				PlayerLDownLegAngleTxt.text = "-" + Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f;
			}
			zero = new Vector3((float)bodyTrackerResult.trackingdata[8].localpose.PosX, (float)bodyTrackerResult.trackingdata[8].localpose.PosY, (float)bodyTrackerResult.trackingdata[8].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[5].localpose.PosX, (float)bodyTrackerResult.trackingdata[5].localpose.PosY, (float)bodyTrackerResult.trackingdata[5].localpose.PosZ);
			zero.Normalize();
			if (Vector3.Dot(zero, Vector3.forward) > 0f)
			{
				PlayerRDownLegAngleTxt.text = (Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f).ToString();
			}
			else
			{
				PlayerRDownLegAngleTxt.text = "-" + Mathf.Acos(Vector3.Dot(zero, Vector3.down)) * 57.29578f;
			}
			PlayerStateUpdate();
		}
	}

	public void PlayerStateUpdate()
	{
		dirLUpLeg = -LeftUpLegT.up;
		dirRUpLeg = -RightUpLegT.up;
		dirLDownLeg = -LeftLegT.up;
		dirRDownLeg = -RightLegT.up;
		dirLUpLeg = new Vector3((float)bodyTrackerResult.trackingdata[4].localpose.PosX, (float)bodyTrackerResult.trackingdata[4].localpose.PosY, (float)bodyTrackerResult.trackingdata[4].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[1].localpose.PosX, (float)bodyTrackerResult.trackingdata[1].localpose.PosY, (float)bodyTrackerResult.trackingdata[1].localpose.PosZ);
		dirRUpLeg = new Vector3((float)bodyTrackerResult.trackingdata[5].localpose.PosX, (float)bodyTrackerResult.trackingdata[5].localpose.PosY, (float)bodyTrackerResult.trackingdata[5].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[2].localpose.PosX, (float)bodyTrackerResult.trackingdata[2].localpose.PosY, (float)bodyTrackerResult.trackingdata[2].localpose.PosZ);
		dirLDownLeg = new Vector3((float)bodyTrackerResult.trackingdata[7].localpose.PosX, (float)bodyTrackerResult.trackingdata[7].localpose.PosY, (float)bodyTrackerResult.trackingdata[7].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[4].localpose.PosX, (float)bodyTrackerResult.trackingdata[4].localpose.PosY, (float)bodyTrackerResult.trackingdata[4].localpose.PosZ);
		dirRDownLeg = new Vector3((float)bodyTrackerResult.trackingdata[8].localpose.PosX, (float)bodyTrackerResult.trackingdata[8].localpose.PosY, (float)bodyTrackerResult.trackingdata[8].localpose.PosZ) - new Vector3((float)bodyTrackerResult.trackingdata[5].localpose.PosX, (float)bodyTrackerResult.trackingdata[5].localpose.PosY, (float)bodyTrackerResult.trackingdata[5].localpose.PosZ);
		dirLUpLeg.Normalize();
		dirRUpLeg.Normalize();
		dirLDownLeg.Normalize();
		dirRDownLeg.Normalize();
		LUpLegFwdValue = Vector3.Dot(AvatarVRIK.references.root.forward, dirLUpLeg);
		RUpLegFwdValue = Vector3.Dot(AvatarVRIK.references.root.forward, dirRUpLeg);
		if (LUpLegFwdValue > RUpLegFwdValue)
		{
			if (LUpLegFwdValue > 0f)
			{
				if (Vector3.Dot(dirLUpLeg, Vector3.down) < KickUpLegTriggerAngle && Vector3.Dot(dirLDownLeg, Vector3.down) < KickTriggerRad && Vector3.Dot(dirLDownLeg, Vector3.forward) > 0f)
				{
					OnStateGet(PlayerState.LeftKick);
					return;
				}
				if (Vector3.Dot(dirLUpLeg, Vector3.down) < KneeTriggerRad)
				{
					OnStateGet(PlayerState.LeftKnee);
					return;
				}
				switch (GetFootStateLR())
				{
				case 0:
					OnStateGet(PlayerState.LeftStand);
					break;
				case 1:
					OnStateGet(PlayerState.RightStand);
					break;
				}
			}
			else
			{
				switch (GetFootStateLR())
				{
				case 0:
					OnStateGet(PlayerState.LeftStand);
					break;
				case 1:
					OnStateGet(PlayerState.RightStand);
					break;
				}
			}
		}
		else if (RUpLegFwdValue > 0f)
		{
			if (Vector3.Dot(dirRUpLeg, Vector3.down) < KickUpLegTriggerAngle && Vector3.Dot(dirRDownLeg, Vector3.down) < KickTriggerRad && Vector3.Dot(dirRDownLeg, Vector3.forward) > 0f)
			{
				OnStateGet(PlayerState.RightKick);
				return;
			}
			if (Vector3.Dot(dirRUpLeg, Vector3.down) < KneeTriggerRad)
			{
				OnStateGet(PlayerState.RightKnee);
				return;
			}
			switch (GetFootStateLR())
			{
			case 0:
				OnStateGet(PlayerState.RightStand);
				break;
			case 1:
				OnStateGet(PlayerState.RightStand);
				break;
			}
		}
		else
		{
			switch (GetFootStateLR())
			{
			case 0:
				OnStateGet(PlayerState.RightStand);
				break;
			case 1:
				OnStateGet(PlayerState.RightStand);
				break;
			}
		}
	}

	private void OnStateGet(PlayerState s)
	{
		if (CurState != s)
		{
			CurState = s;
			MagLKneeState = 0f;
			MagRKneeState = 0f;
			MagLFootState = 0f;
			MagRFootState = 0f;
			switch (CurState)
			{
			case PlayerState.LeftStand:
				GayAnim.SetBool("LeftStand", value: true);
				break;
			case PlayerState.RightStand:
				GayAnim.SetBool("LeftStand", value: false);
				break;
			case PlayerState.LeftKnee:
				MagLKneeState = MagLKnee;
				GayAnim.CrossFade("kneeLeft", 0.1f);
				break;
			case PlayerState.RightKnee:
				MagRKneeState = MagRKnee;
				GayAnim.CrossFade("kneeRight", 0.1f);
				break;
			case PlayerState.LeftKick:
				MagLFootState = MagLFoot;
				GayAnim.CrossFade("kickLeft", 0.1f);
				break;
			case PlayerState.RightKick:
				MagRFootState = MagRFoot;
				GayAnim.CrossFade("kickRight", 0.1f);
				break;
			}
		}
	}

	public bool IsKicking()
	{
		return false;
	}

	public bool IsSteping()
	{
		return false;
	}

	public bool IsKneeUp()
	{
		return false;
	}

	public int GetFootState()
	{
		Vector3 forward = AvatarVRIK.references.root.forward;
		forward.y = 0f;
		forward = forward.normalized;
		Vector3 lhs = FootL_IKFollowT.position - Head_IKFollowT.position;
		lhs.y = 0f;
		Vector3 lhs2 = FootR_IKFollowT.position - Head_IKFollowT.position;
		lhs2.y = 0f;
		float num = Vector3.Dot(lhs, forward);
		float num2 = Vector3.Dot(lhs2, forward);
		if (Mathf.Abs(num - num2) > 0.15f)
		{
			if (num >= num2)
			{
				return 0;
			}
			return 1;
		}
		return -1;
	}

	public int GetFootStateLR()
	{
		Vector3 forward = AvatarVRIK.references.root.forward;
		forward.y = 0f;
		forward = forward.normalized;
		Vector3 lhs = FootL_IKFollowT.position - Head_IKFollowT.position;
		lhs.y = 0f;
		Vector3 lhs2 = FootR_IKFollowT.position - Head_IKFollowT.position;
		lhs2.y = 0f;
		float num = Vector3.Dot(lhs, forward);
		float num2 = Vector3.Dot(lhs2, forward);
		if (num >= num2)
		{
			return 0;
		}
		return 1;
	}

	public float GetSpeedByState(PlayerState s)
	{
		return s switch
		{
			PlayerState.LeftKick => Mathf.Max(MagLFoot, MagLFootState), 
			PlayerState.RightKick => Mathf.Max(MagRFoot, MagRFootState), 
			PlayerState.LeftKnee => Mathf.Max(MagLKnee, MagLKneeState), 
			PlayerState.RightKnee => Mathf.Max(MagRKnee, MagRKneeState), 
			_ => 0f, 
		};
	}
}
public enum PlayerState
{
	LeftStand,
	RightStand,
	LeftKick,
	RightKick,
	LeftKnee,
	RightKnee
}
public class LegTrackingAvatarSample : MonoBehaviour
{
	public List<Transform> BonesList = new List<Transform>(new Transform[24]);

	public Dictionary<int, Quaternion> mRotationDic = new Dictionary<int, Quaternion>();

	public float[] SkeletonLens = new float[11];

	public GameObject leftexplotionEffect;

	public GameObject rightexplotionEffect;

	private BodyTrackerResult m_BodyTrackerResult;

	private Vector3 position;

	private Quaternion rotation;

	private Vector3 rightFootPosition;

	private Vector3 leftAnklePos;

	private Vector3 rightAnklePos;

	private Vector3 footPosition;

	private int lastLeftAction;

	private int lastRightAction;

	public Transform thisT;

	private bool isInit;

	private void Start()
	{
		m_BodyTrackerResult = default(BodyTrackerResult);
		m_BodyTrackerResult.trackingdata = new BodyTrackerTransform[24];
		for (int i = 0; i < BonesList.Count; i++)
		{
			if (BonesList[i] != null)
			{
				mRotationDic.Add(i, BonesList[i].rotation);
			}
		}
		lastLeftAction = 1000;
		lastRightAction = 1000;
	}

	public void OnPlayerInit(float Height)
	{
		UnityEngine.Debug.LogError("OnPlayerInit");
		isInit = true;
		thisT.transform.localScale = Vector3.one / 1.75f * Height;
	}

	private void OnDisable()
	{
		UnityEngine.Debug.LogError("LegTrack OnDisable");
	}

	private void Update()
	{
		if (!isInit)
		{
			return;
		}
		PXR_Input.GetBodyTrackingPose(0.0, ref m_BodyTrackerResult);
		position.x = (float)m_BodyTrackerResult.trackingdata[0].localpose.PosX;
		position.y = (float)m_BodyTrackerResult.trackingdata[0].localpose.PosY;
		position.z = (float)m_BodyTrackerResult.trackingdata[0].localpose.PosZ;
		UnityEngine.Debug.LogError("LegTrackingAvatarSample Update");
		for (int i = 0; i < BonesList.Count; i++)
		{
			if (BonesList[i] != null)
			{
				rotation.x = (float)m_BodyTrackerResult.trackingdata[i].localpose.RotQx;
				rotation.y = (float)m_BodyTrackerResult.trackingdata[i].localpose.RotQy;
				rotation.z = (float)m_BodyTrackerResult.trackingdata[i].localpose.RotQz;
				rotation.w = (float)m_BodyTrackerResult.trackingdata[i].localpose.RotQw;
				BonesList[i].rotation = rotation * mRotationDic[i];
			}
		}
	}

	[ContextMenu("AutoBindAvatarBones")]
	public void FindBonesReference()
	{
		BonesList[0] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips").transform;
		BonesList[1] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_L").transform;
		BonesList[2] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_R").transform;
		BonesList[3] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1").transform;
		BonesList[4] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_L/Leg_L").transform;
		BonesList[5] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_R/Leg_R").transform;
		BonesList[6] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2").transform;
		BonesList[7] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_L/Leg_L/Foot_L").transform;
		BonesList[8] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_R/Leg_R/Foot_R").transform;
		BonesList[9] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest").transform;
		BonesList[10] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_L/Leg_L/Foot_L/Foot_rotate_L/HeelToes_L/Toes_rotate_L/Toes_L").transform;
		BonesList[11] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/UpLeg_R/Leg_R/Foot_R/Foot_rotate_R/HeelToes_R/Toes_rotate_R/Toes_R").transform;
		BonesList[12] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Neck").transform;
		BonesList[13] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_L").transform;
		BonesList[14] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_R").transform;
		BonesList[15] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Neck/Head").transform;
		BonesList[16] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_L/Arm_L").transform;
		BonesList[17] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_R/Arm_R").transform;
		BonesList[18] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_L/Arm_L/Arm_L_twist/ForeArm_L").transform;
		BonesList[19] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_R/Arm_R/Arm_R_twist/ForeArm_R").transform;
		BonesList[20] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_L/Arm_L/Arm_L_twist/ForeArm_L/ForeArm_L_twist01/ForeArm_L_twist02/Hand_L").transform;
		BonesList[21] = GameObject.Find(base.name + "/RIG/DeformationSystem/Root/GlobalScale/Hips/Spine1/Spine2/Chest/Shoulder_R/Arm_R/Arm_R_twist/ForeArm_R/ForeArm_R_twist01/ForeArm_R_twist02/Hand_R").transform;
	}

	[ContextMenu("AutoFindAvatarBonesLenth")]
	public void FindBonesLength()
	{
		SkeletonLens[0] = 0.2f;
		SkeletonLens[1] = (BonesList[12].position - BonesList[15].position).magnitude;
		SkeletonLens[2] = (BonesList[12].position - (BonesList[0].position + BonesList[3].position) * 0.5f).magnitude;
		SkeletonLens[3] = ((BonesList[0].position + BonesList[3].position) * 0.5f - (BonesList[1].position + BonesList[2].position) * 0.5f).magnitude;
		SkeletonLens[4] = (BonesList[1].position - BonesList[4].position).magnitude;
		SkeletonLens[5] = (BonesList[4].position - BonesList[7].position).magnitude;
		SkeletonLens[6] = (BonesList[7].position - BonesList[10].position).magnitude;
		SkeletonLens[7] = (BonesList[16].position - BonesList[17].position).magnitude;
		SkeletonLens[8] = (BonesList[16].position - BonesList[18].position).magnitude;
		SkeletonLens[9] = (BonesList[18].position - BonesList[20].position).magnitude;
		SkeletonLens[10] = 0.169f;
	}
}
public class csTestExplodeManager : MonoBehaviour
{
	public csSimpleExplod simExpBody;

	public Transform FromPointT;

	public float Force = 2f;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			simExpBody.DoExlpode(FromPointT.position, Force);
		}
		if (Input.GetKeyDown(KeyCode.R))
		{
			simExpBody.ExlpodeReset();
		}
	}
}
public class csTestSceneMan : MonoBehaviour
{
	public Transform[] runner;

	private Transform currentRunner;

	public float speed = 0.6f;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			currentRunner = runner[0];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			currentRunner = runner[1];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			currentRunner = runner[2];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			currentRunner = runner[3];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			currentRunner = runner[4];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			currentRunner = runner[5];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha7))
		{
			currentRunner = runner[6];
			resetRunner();
		}
		if (Input.GetKeyDown(KeyCode.Alpha8))
		{
			currentRunner = runner[7];
			resetRunner();
		}
	}

	private void resetRunner()
	{
		StopAllCoroutines();
		if ((bool)currentRunner.GetComponent<csEditorBeatItem_Wall>())
		{
			currentRunner.GetComponent<csEditorBeatItem_Wall>().WallReset();
		}
		for (int i = 0; i < runner.Length; i++)
		{
			runner[i].transform.position = Vector3.forward * 3f;
			runner[i].gameObject.SetActive(value: false);
		}
		currentRunner.gameObject.SetActive(value: true);
		StartCoroutine(Run());
	}

	private IEnumerator Run()
	{
		while (true)
		{
			currentRunner.position -= Vector3.forward * speed * Time.deltaTime;
			if (currentRunner.position.z < -1f)
			{
				currentRunner.position = Vector3.forward * 3f;
				if ((bool)currentRunner.GetComponent<csEditorBeatItem_Wall>())
				{
					currentRunner.GetComponent<csEditorBeatItem_Wall>().WallReset();
				}
			}
			yield return null;
		}
	}
}
public class csVersionWaterMark : MonoBehaviour
{
	public Text WaterMarkTxt;

	private void Start()
	{
		switch (csGameSettings.profile.CurrentReleaseType)
		{
		case ReleaseType.BetaTest:
			WaterMarkTxt.text = "内测版 V" + csGameSettings.GameVersion;
			break;
		case ReleaseType.DevTest:
			WaterMarkTxt.text = "开发者版 V" + csGameSettings.GameVersion;
			break;
		}
	}
}
public class csCoachTimeTips : MonoBehaviour
{
	public static csCoachTimeTips instance;

	public TextMeshProUGUI tipsContent;

	public GameObject Body;

	public float displayTime = 4f;

	public GameObject pico3Image;

	public GameObject pico4Image;

	private Transform thisT;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		thisT = base.transform;
		Body.GetComponent<CanvasGroup>().alpha = 0f;
	}

	private void Start()
	{
		if (csGameSettings.CurrentDevice == XRDeviceType.PicoNeo3 && pico3Image != null)
		{
			pico3Image.SetActive(value: true);
		}
		else if (pico4Image != null)
		{
			pico4Image.SetActive(value: true);
		}
	}

	public void FadeOut()
	{
		if (GameManagerNew.instance.gameState == GAMESTATE.RelaxTime)
		{
			tipsContent.text = csLocalizationManager.Instance.GetLocalText("CoachTimeHint02");
		}
		else
		{
			tipsContent.text = csLocalizationManager.Instance.GetLocalText("CoachTimeHint01");
		}
		csIngameMenuManager.instance.ParentT.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
		Body.SetActive(value: true);
		Body.GetComponent<CanvasGroup>().DOFade(0.8f, 0.5f);
	}

	public void FadeIn()
	{
		Body.GetComponent<CanvasGroup>().DOFade(0f, 0.5f).OnComplete(delegate
		{
			Body.SetActive(value: false);
		});
	}
}
public class csGenericUIAnimation : MonoBehaviour
{
	[Header("此物体开始的动画")]
	public List<AnimationStep> StartAnimations;

	[Header("此物体结束的动画")]
	public List<AnimationStep> EndAnimations;

	private void OnEnable()
	{
		StartCoroutine(AnimationStep());
	}

	private void OnDisable()
	{
	}

	private IEnumerator AnimationStep()
	{
		foreach (AnimationStep step in StartAnimations)
		{
			yield return new WaitForSeconds(step.timeBeforeThisAnimation);
			Tweener t = null;
			if (step.IsEndPosBasedOnCurrentPos)
			{
				step.Pos = step.TargetObj.transform.position + step.Pos;
			}
			CanvasGroup component;
			switch (step.animationType)
			{
			case AnimationType.fadeIn:
				if (step.TargetObj.TryGetComponent<CanvasGroup>(out component))
				{
					component.alpha = 0f;
					t = component.DOFade(1f, step.Duration);
				}
				break;
			case AnimationType.fadeOut:
				if (step.TargetObj.TryGetComponent<CanvasGroup>(out component))
				{
					component.alpha = 1f;
					t = component.DOFade(0f, step.Duration);
				}
				break;
			case AnimationType.Move:
				t = step.TargetObj.transform.DOMove(step.Pos, step.Duration);
				break;
			}
			if (step.animationCurve != null)
			{
				t.SetEase(step.animationCurve);
			}
			if (step.CurrentStateIsEndState)
			{
				t.From();
			}
			yield return new WaitForSeconds(step.timeAfterThisAnimation);
		}
	}
}
[Serializable]
public class AnimationStep
{
	public AnimationType animationType;

	public bool CurrentStateIsEndState;

	public GameObject TargetObj;

	public float timeBeforeThisAnimation;

	public float Duration;

	public float Value;

	public bool IsEndPosBasedOnCurrentPos;

	public Vector3 Pos;

	public AnimationCurve animationCurve;

	public float timeAfterThisAnimation;
}
public enum AnimationType
{
	fadeOut,
	fadeIn,
	Move
}
public class csIDImageIconManager : MonoBehaviour
{
	public static csIDImageIconManager instance;

	public List<IDImageData> IDImageList = new List<IDImageData>();

	public void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public Sprite GetImgByID(string id)
	{
		return IDImageList.Find((IDImageData x) => x.imgID == id)?.imgSprite;
	}
}
[Serializable]
public class IDImageData
{
	public string imgID;

	public Sprite imgSprite;
}
public class csImagePositionSet : MonoBehaviour
{
	public RectTransform targetPos;

	public RectTransform originPos;

	public void SetPostion()
	{
		base.transform.localPosition = targetPos.localPosition;
	}

	public void ResetPostion()
	{
		base.transform.localPosition = originPos.localPosition;
	}
}
public class csInfoHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public Canvas detailInfo;

	public TextMeshProUGUI detailText;

	private Tweener t;

	private void Start()
	{
		detailInfo.enabled = false;
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		base.transform.DOScale(1.1f, 0.2f);
		detailInfo.enabled = true;
		if (detailText != null)
		{
			detailText.gameObject.SetActive(value: true);
		}
		if (t != null && t.IsPlaying())
		{
			t.Kill();
		}
		t = detailInfo.gameObject.transform.DOScale(1f, 0.2f);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		base.transform.DOScale(1f, 0.2f);
		if (t != null && t.IsPlaying())
		{
			t.Kill();
		}
		if (detailText != null)
		{
			detailText.gameObject.SetActive(value: false);
		}
		t = detailInfo.gameObject.transform.DOScale(0f, 0.2f);
	}
}
public class csPanelBase : MonoBehaviour
{
	public bool IsIngamePanel;

	public PanelType type;

	public GameObject body;

	public bool isOpend;

	private void Awake()
	{
		InitRef();
	}

	protected virtual void InitRef()
	{
		body.SetActive(value: false);
		if (IsIngamePanel)
		{
			if (!csIngameMenuManager.instance.panelDic.ContainsKey(type))
			{
				csIngameMenuManager.instance.panelDic.Add(type, this);
			}
		}
		else if (!csMainMenuManager.instance.panelDic.ContainsKey(type))
		{
			csMainMenuManager.instance.panelDic.Add(type, this);
		}
	}

	public virtual void Open()
	{
		if (!isOpend)
		{
			body.SetActive(value: true);
			isOpend = true;
		}
	}

	public virtual void Open(string message)
	{
		Open();
	}

	public virtual void Open(string message, Action okaction, Action noaction)
	{
		Open();
	}

	public virtual void Open(string message, bool neterror, int buttonnum, string oktext, string notext, Action okaction, Action noaction, bool isGetProp = false)
	{
		Open();
	}

	public virtual void Close()
	{
		if (isOpend)
		{
			body.SetActive(value: false);
			isOpend = false;
		}
	}
}
[RequireComponent(typeof(Image))]
[RequireComponent(typeof(Mask))]
public class csTMPScroll : MonoBehaviour
{
	public TextMeshProUGUI target;

	private RectTransform thisT;

	private RectTransform targetT;

	public float speed = 30f;

	private Vector3 oriPos;

	private bool needMove;

	private float textWidth;

	private bool isScroll;

	private Tweener moveTweener;

	public bool IsVertical;

	private void Awake()
	{
		thisT = GetComponent<RectTransform>();
		targetT = target.GetComponent<RectTransform>();
		thisT.sizeDelta = targetT.sizeDelta;
		oriPos = targetT.localPosition;
	}

	private void OnEnable()
	{
		needMove = false;
		isScroll = false;
		moveTweener = null;
		targetT.localPosition = new Vector2(0f, targetT.localPosition.y);
	}

	private void OnDisable()
	{
		moveTweener.Kill();
		targetT.localPosition = oriPos;
	}

	private void Update()
	{
		if (IsVertical)
		{
			textWidth = target.GetRenderedValues(onlyVisibleCharacters: true).y;
			if (textWidth > targetT.sizeDelta.y)
			{
				if (!needMove)
				{
					needMove = true;
				}
				isScroll = true;
				targetT.localPosition += Vector3.up * speed * Time.deltaTime;
				if (targetT.localPosition.y > textWidth)
				{
					targetT.localPosition = new Vector2(targetT.localPosition.x, 0f - targetT.sizeDelta.y);
				}
			}
			else if (needMove)
			{
				moveTweener.Kill();
				targetT.localPosition = new Vector2(targetT.localPosition.x, 0f - textWidth);
				needMove = false;
			}
			return;
		}
		textWidth = target.GetRenderedValues(onlyVisibleCharacters: true).x;
		if (textWidth > targetT.sizeDelta.x)
		{
			if (!needMove)
			{
				needMove = true;
			}
			isScroll = true;
			targetT.localPosition += Vector3.left * speed * Time.deltaTime;
			if (targetT.localPosition.x < 0f - textWidth)
			{
				targetT.localPosition = new Vector2(targetT.sizeDelta.x, targetT.localPosition.y);
			}
		}
		else if (needMove)
		{
			moveTweener.Kill();
			targetT.localPosition = new Vector2(0f, targetT.localPosition.y);
			needMove = false;
		}
	}
}
public class HeadsDownHint : MonoBehaviour
{
	public Transform thisT;

	public float headDownAngle = 22.5f;

	public GameObject pico3Image;

	public GameObject pico4Image;

	public TextMeshProUGUI hintContent;

	private Canvas Hint;

	private Transform HeadCamera;

	private Tweener t;

	private bool isDisplay;

	private Transform FollowHandT;

	private void Start()
	{
		thisT = base.transform;
		Hint = GetComponent<Canvas>();
		Hint.enabled = false;
		if (csGameSettings.CurrentDevice == XRDeviceType.PicoNeo3 && pico3Image != null)
		{
			pico3Image.SetActive(value: true);
		}
		else if (pico4Image != null)
		{
			pico4Image.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (!(HeadCamera == null))
		{
			if (!isDisplay && Vector3.Dot(HeadCamera.forward, Vector3.up) < Mathf.Cos((90f + headDownAngle) * (float)Math.PI / 180f))
			{
				DisplayHint();
			}
			else if (isDisplay && Vector3.Dot(HeadCamera.forward, Vector3.up) >= Mathf.Cos((90f + headDownAngle) * (float)Math.PI / 180f))
			{
				CloseHint();
			}
			if (isDisplay)
			{
				Vector3 forward = HeadCamera.forward;
				Quaternion rotation = Quaternion.LookRotation(forward, Vector3.up);
				base.transform.rotation = rotation;
				forward.y = 0f;
				thisT.position = FollowHandT.position + Vector3.up * 0.1f + forward.normalized * -0.1f;
			}
		}
	}

	public void SetCamera(Transform camera, Transform fht)
	{
		HeadCamera = camera;
		FollowHandT = fht;
	}

	private void DisplayHint()
	{
		Hint.enabled = true;
		if (t != null && t.IsPlaying())
		{
			t.Kill();
		}
		t = base.transform.DOScale(1f, 0.2f);
		isDisplay = true;
	}

	private void CloseHint()
	{
		if (t != null && t.IsPlaying())
		{
			t.Kill();
		}
		t = base.transform.DOScale(0f, 0.2f);
		isDisplay = false;
	}
}
public class csButtonHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler
{
	[SerializeField]
	private float OnHoverZ = -50f;

	[Header("按下后是否取消hover状态")]
	public bool isClickCancelHover;

	[Header("是否轮播")]
	public bool isScrollText;

	public csTMPScroll scrollComponent;

	public void OnPointerEnter(PointerEventData eventData)
	{
		base.gameObject.transform.DOLocalMoveZ(OnHoverZ, 0.2f);
		if (isScrollText && scrollComponent != null)
		{
			scrollComponent.enabled = true;
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		base.gameObject.transform.DOLocalMoveZ(0f, 0.2f);
		if (isScrollText && scrollComponent != null)
		{
			scrollComponent.enabled = false;
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (isClickCancelHover)
		{
			base.gameObject.transform.DOLocalMoveZ(0f, 0.2f);
		}
	}
}
public class csInGameClassTips : MonoBehaviour
{
	public static csInGameClassTips instance;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI CoachName;

	public TextMeshProUGUI detail;

	public GameObject Body;

	private Transform thisT;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		thisT = base.transform;
		Body.GetComponent<CanvasGroup>().alpha = 0f;
	}

	public void FadeIn()
	{
		csIngameMenuManager.instance.ParentT.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
		Body.SetActive(value: true);
		Body.GetComponent<CanvasGroup>().DOFade(0.8f, 0.5f);
	}

	public void FadeOut()
	{
		Body.GetComponent<CanvasGroup>().DOFade(0f, 0.5f).OnComplete(delegate
		{
			Body.SetActive(value: false);
		});
	}

	private void Update()
	{
	}
}
public class csIngameCoachPause : csPanelBase
{
	public Button CloseBtn;

	public Button OpenBtn;

	public GameObject[] RelexCloseObjs;

	public TextMeshProUGUI ClassDiff;

	public TextMeshProUGUI ClassTime;

	public TextMeshProUGUI ClassCoach;

	public TextMeshProUGUI ClassType;

	public Image ClassTypeImage;

	public Image ClassDifImage;

	public Sprite[] ClassEasyTypeSprites;

	public Sprite[] ClassNormalTypeSprites;

	public Sprite[] ClassHardTypeSprites;

	public Sprite[] ClassDifSprites;

	public Image CoachImg;

	public Image ClassImg_selected;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public TextMeshProUGUI sceneryIntroduction;

	private GameSongData CurGameSongData;

	public csVRButtonInMenu LikeButton;

	private void Start()
	{
		LikeButton.button.onClick.AddListener(delegate
		{
			SetCollection(IsinCollectionlist(CurGameSongData.ClassID));
		});
	}

	public override void Open(string message)
	{
		base.Open(message);
		if (csGameSettings.PlayerPlatformOn)
		{
			OpenBtn.gameObject.SetActive(value: true);
			CloseBtn.gameObject.SetActive(value: false);
		}
		else
		{
			CloseBtn.gameObject.SetActive(value: true);
			OpenBtn.gameObject.SetActive(value: false);
		}
		switch (message)
		{
		case "ShowBtn":
		{
			GameObject[] relexCloseObjs = RelexCloseObjs;
			for (int i = 0; i < relexCloseObjs.Length; i++)
			{
				relexCloseObjs[i].SetActive(value: true);
			}
			break;
		}
		case "DontShowBtn":
		{
			GameObject[] relexCloseObjs = RelexCloseObjs;
			for (int i = 0; i < relexCloseObjs.Length; i++)
			{
				relexCloseObjs[i].SetActive(value: true);
			}
			break;
		}
		}
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: false);
		string text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.currenSceneIntroduceID);
		if (text.Contains("\\n"))
		{
			text = text.Replace("\\n", "\n");
		}
		sceneryIntroduction.text = text;
	}

	public void PauseGame()
	{
	}

	public void ResumeGame()
	{
		csPlatformEffectMgr.instance.ShowCoachPlatform(isShow: true);
		GameManagerNew.instance.ResumeGameInCaochTime();
		if (GameManagerNew.instance.isShowBtn)
		{
			csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"热身继续次数"
			} });
		}
		else
		{
			csTalkingData.Instance.SendEvent("KC04_冷身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"冷身继续次数"
			} });
		}
	}

	public void BackToMain()
	{
		GameManagerNew.instance.BackToMain();
		GameManagerNew.instance.closeVideo();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{ "status", "cancel" },
			{ "accuracy", 0 },
			{ "real_kcal", 0 },
			{ "goal", 0 },
			{ "strength", 0 },
			{ "combo", 0 }
		});
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{
				"duration",
				(int)(GameManagerNew.instance.GameTimer * 1000f)
			},
			{ "status", "cancel" },
			{
				"goal",
				GameManagerNew.instance.GameValueManager.GetCurrentTotalScore()
			},
			{
				"real_kcal",
				GameManagerNew.instance.GameValueManager.GetCurrentTotalKCal()
			}
		});
		if (GameManagerNew.instance.isShowBtn)
		{
			csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"热身退出次数"
			} });
		}
		else
		{
			csTalkingData.Instance.SendEvent("KC04_冷身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"冷身退出次数"
			} });
		}
	}

	public void SkipCoachTime()
	{
		GameManagerNew.instance.SkipClicked = true;
		GameManagerNew.instance.isSkipCoach = true;
		if (GameManagerNew.instance.isShowBtn)
		{
			csTalkingData.Instance.SendEvent("KC02_热身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"热身跳过次数"
			} });
		}
		else if (GameManagerNew.instance.gameState == GAMESTATE.FollowGapPause)
		{
			csTalkingData.Instance.SendEvent("KC06_休息暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"休息跳过次数"
			} });
		}
		else
		{
			csTalkingData.Instance.SendEvent("KC04_冷身暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				"冷身跳过次数"
			} });
		}
	}

	public void ClosePlatform()
	{
		csPlatformEffectMgr.instance.ClosePlatform();
		csGameSettings.PlayerPlatformOn = false;
		CloseBtn.gameObject.SetActive(value: true);
		OpenBtn.gameObject.SetActive(value: false);
	}

	public void OpenPlatform()
	{
		csPlatformEffectMgr.instance.OpenPlatform();
		csGameSettings.PlayerPlatformOn = true;
		OpenBtn.gameObject.SetActive(value: true);
		CloseBtn.gameObject.SetActive(value: false);
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		ClassImg_selected.sprite = csIDImageIconManager.instance.GetImgByID(d.CoverImgID);
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID);
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		int num = d.ClassTotalTime / 60;
		ClassTime.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01") + num + "min";
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDifImage.sprite = ClassDifSprites[0];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common01");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassEasyTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassEasyTypeSprites[1];
				break;
			}
			break;
		case Diff.normal:
			ClassDifImage.sprite = ClassDifSprites[1];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common02");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassNormalTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassNormalTypeSprites[1];
				break;
			}
			break;
		case Diff.hard:
			ClassDifImage.sprite = ClassDifSprites[2];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common03");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassHardTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassHardTypeSprites[1];
				break;
			}
			break;
		}
		CoachImg.sprite = csIDImageIconManager.instance.GetImgByID(d.CoachImgID);
		ClassCoach.text = d.CaochName;
	}

	public void resetLevelItemLikeState()
	{
		if (IsinCollectionlist(CurGameSongData.ClassID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public void SetCollection(bool isSet)
	{
		if (!isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: true);
			LikeButton.OnSelect();
		}
		if (isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: false);
			LikeButton.DeSelect();
		}
		csMainMenuManager.instance.levelItemActions[CurGameSongData.ClassID]();
	}

	public override void Open()
	{
		base.Open();
		resetLevelItemLikeState();
	}
}
public class csIngameFollowPause : csPanelBase
{
	public Button ResumeBtn;

	public Button EndBtn;

	public Button skipBtn;

	public TextMeshProUGUI calT;

	public TextMeshProUGUI timeT;

	public Image calImg;

	public Image timeImg;

	public AudioClip SfxSetClip;

	public AudioClip TeacherSetClip;

	public csOnPointerEvents CoachVolEvt;

	public csOnPointerEvents SFXVolEvt;

	public Image classTypeImage;

	public Image classDifImage;

	public Sprite[] TypeSprites;

	public Sprite[] DifSprites;

	public Image ClassImg_selected;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public TextMeshProUGUI ClassDiff;

	public TextMeshProUGUI ClassTime;

	public TextMeshProUGUI ClassCoach;

	public TextMeshProUGUI sceneryIntroduction;

	public Image CoachImg;

	public GameSongData CurGameSongData;

	public Button CurrentDataCloseBtn;

	public Button CurrentDataOpenBtn;

	public Slider SFXVol;

	public Slider CoachVoiceVol;

	public csVRButtonInMenu LikeButton;

	protected override void InitRef()
	{
		base.InitRef();
		ResumeBtn.onClick.AddListener(ResumeGame);
		EndBtn.onClick.AddListener(BackToMain);
		LikeButton.button.onClick.AddListener(delegate
		{
			SetCollection(IsinCollectionlist(CurGameSongData.ClassID));
		});
		skipBtn.onClick.AddListener(delegate
		{
			csFollowSceneGameManager.instance.SkipClicked = true;
		});
	}

	public override void Open()
	{
		base.Open();
		calT.text = ((int)((float)csSportInfoManager.instance.GetFinalCalInt() / 1000f)).ToString();
		calImg.material = new Material(calImg.material);
		timeImg.material = new Material(timeImg.material);
		calImg.material.SetFloat("_Progress", (float)csSportInfoManager.instance.GetFinalCalInt() / 3000f);
		timeT.text = csSportInfoManager.instance.GetSportTime() / 60 + "Min";
		timeImg.material.SetFloat("_Progress", (float)csSportInfoManager.instance.GetSportTime() / 1000f);
		EndBtn.transform.localPosition = new Vector3(0f, EndBtn.transform.localPosition.y, 0f);
		skipBtn.gameObject.SetActive(value: false);
		string text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.currenSceneIntroduceID);
		if (text.Contains("\\n"))
		{
			text = text.Replace("\\n", "\n");
		}
		sceneryIntroduction.text = text;
		InitSettingsData();
		resetLevelItemLikeState();
	}

	public override void Open(string message)
	{
		Open();
		if (message == "canSkip")
		{
			EndBtn.transform.localPosition = new Vector3(76.7f, -52.4f, 0f);
			skipBtn.gameObject.SetActive(value: true);
		}
		string text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.currenSceneIntroduceID);
		if (text.Contains("\\n"))
		{
			text = text.Replace("\\n", "\n");
		}
		sceneryIntroduction.text = text;
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		ClassImg_selected.sprite = csIDImageIconManager.instance.GetImgByID(d.CoverImgID);
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID);
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		int num = d.ClassTotalTime / 60;
		ClassTime.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01") + num + "min";
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common01");
			classTypeImage.sprite = TypeSprites[0];
			classDifImage.sprite = DifSprites[0];
			break;
		case Diff.normal:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common02");
			classTypeImage.sprite = TypeSprites[1];
			classDifImage.sprite = DifSprites[1];
			break;
		case Diff.hard:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common03");
			classTypeImage.sprite = TypeSprites[2];
			classDifImage.sprite = DifSprites[2];
			break;
		}
		CoachImg.sprite = csIDImageIconManager.instance.GetImgByID(d.CoachImgID);
		ClassCoach.text = d.CaochName;
	}

	public void ResumeGame()
	{
		if (csFollowSceneGameManager.instance.gameState != GAMESTATE.FollowGapPause)
		{
			csFollowSceneGameManager.instance.ResumeGameInCaochTime();
		}
		else
		{
			csFollowSceneGameManager.instance.ResumeGameInFollowGap();
		}
		csTalkingData.Instance.SendEvent("KC05_课程暂停", 1.0, new Dictionary<string, object> { 
		{
			"课程ID：" + csGameDataTransfer.currentClassID,
			$"第{csFollowSceneGameManager.instance.currentSection}小节继续次数"
		} });
		UnityEngine.Debug.LogError("ResumeGame");
	}

	public void BackToMain()
	{
		UnityEngine.Debug.LogError("BackToMian");
		csSportInfoManager.instance.stopCalculateCal();
		csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameGaming);
		csIngameMenuManager.instance.ClosePanel();
		csFollowSceneGameManager.instance.BackToMain();
		csFollowSceneGameManager.instance.closeVideo();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{ "status", "cancel" },
			{
				"accuracy",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentStagePrecise()
			},
			{
				"real_kcal",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentStageKCal()
			},
			{
				"goal",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentStageScore()
			},
			{
				"strength",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentStageStrength()
			},
			{ "combo", 0 }
		});
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{
				"duration",
				(int)(GameManagerNew.instance.GameTimer * 1000f)
			},
			{ "status", "cancel" },
			{
				"goal",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentTotalScore()
			},
			{
				"real_kcal",
				csFollowSceneGameManager.instance.GameValueManager.GetCurrentTotalKCal()
			}
		});
		csTalkingData.Instance.SendEvent("KC06_退出", 1.0, new Dictionary<string, object> { 
		{
			"课程ID：" + csGameDataTransfer.currentClassID,
			$"第{csFollowSceneGameManager.instance.currentSection}小节退出次数"
		} });
	}

	private void InitSettingsData()
	{
		if (csGameSettings.PlayerCurrentDataOn)
		{
			CurrentDataCloseBtn.gameObject.SetActive(value: false);
			CurrentDataOpenBtn.gameObject.SetActive(value: true);
		}
		else
		{
			CurrentDataCloseBtn.gameObject.SetActive(value: true);
			CurrentDataOpenBtn.gameObject.SetActive(value: false);
		}
		SFXVol.SetValueWithoutNotify(csGameSettings.SoundEffectVol);
		SFXVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.SoundEffectVol = x;
			csAudioManager.instance.SetAudioVolume();
			GameManagerNew.instance.SetEffectAudioVolume();
		});
		CoachVoiceVol.SetValueWithoutNotify(csGameSettings.CoachVoiceVol);
		CoachVoiceVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.CoachVoiceVol = x;
			csFollowSceneGameManager.instance.SetFollowAudioVolume();
		});
	}

	public void CloseCurrentData()
	{
		csGameSettings.PlayerCurrentDataOn = false;
		CurrentDataCloseBtn.gameObject.SetActive(value: true);
		CurrentDataOpenBtn.gameObject.SetActive(value: false);
	}

	public void OpenCurrentData()
	{
		csGameSettings.PlayerCurrentDataOn = true;
		CurrentDataCloseBtn.gameObject.SetActive(value: false);
		CurrentDataOpenBtn.gameObject.SetActive(value: true);
	}

	public void resetLevelItemLikeState()
	{
		if (IsinCollectionlist(CurGameSongData.ClassID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public void SetCollection(bool isSet)
	{
		if (!isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: true);
			LikeButton.OnSelect();
		}
		if (isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: false);
			LikeButton.DeSelect();
		}
		csMainMenuManager.instance.levelItemActions[CurGameSongData.ClassID]();
	}
}
public class csIngameFollowResult : csPanelBase
{
	public Button EndBtn;

	public TextMeshProUGUI calT;

	public TextMeshProUGUI timeT;

	public Image calImg;

	public Image timeImg;

	protected override void InitRef()
	{
		base.InitRef();
		EndBtn.onClick.AddListener(BackToMain);
	}

	public void BackToMain()
	{
		if (csGameSettings.currGameScene == GameScene.Thinking)
		{
			csThinkingSceneGameManager.instance.BackToMain();
			csThinkingSceneGameManager.instance.closeVideo();
		}
		else if (csGameSettings.currGameScene == GameScene.Follow)
		{
			csFollowSceneGameManager.instance.BackToMain();
			csFollowSceneGameManager.instance.closeVideo();
		}
	}

	public void setFollowResult(int cal, int time)
	{
		calT.text = ((int)((float)cal / 1000f)).ToString();
		calImg.material = new Material(calImg.material);
		calImg.material.SetFloat("_Progress", 0f);
		calImg.material.DOFloat((float)cal / 3000f, "_Progress", 0.35f);
		timeT.text = time.ToString();
		timeImg.material = new Material(timeImg.material);
		timeImg.material.SetFloat("_Progress", 0f);
		timeImg.material.DOFloat(1f, "_Progress", 0.35f);
	}
}
public class csIngameMenuManager : MonoBehaviour
{
	public static csIngameMenuManager instance;

	public Transform ParentT;

	public csIngamePanelResult finalResultPanel;

	public csIngamePanelFollowGap followGapPanel;

	public csCommonHintPanel InGameCommonHintPanel;

	public Dictionary<PanelType, csPanelBase> panelDic = new Dictionary<PanelType, csPanelBase>();

	public csIngameFollowPause inGameFollowPause;

	public csIngameFollowResult inGameFollowResult;

	public csIngameTutorialPause inGameTutorialPause;

	public csIngameTutorialResult inGameTutorialResult;

	public csIngameCoachPause inGameCoachPause;

	public csIngamePanelPause inGamePanelPause;

	public csIngameRelaxPause inGameRelaxPause;

	public csIngameResultForSuperMonkey ingameResultForSuperMonkey;

	public csCoachTimeTips coachTimeTips;

	public PanelType currentPanel;

	private void Awake()
	{
		instance = this;
	}

	public void PauseGame()
	{
		OpenPanel(PanelType.InGamePause);
	}

	public void PauseGameInCaochTime(string message)
	{
		OpenPanel(PanelType.InGameCoachPause, message);
		coachTimeTips.Body.SetActive(value: false);
	}

	public void PauseGameInFollowTime()
	{
		OpenPanel(PanelType.InGameFollowPause);
	}

	public void PauseGameInFollowGap()
	{
		OpenPanel(PanelType.InGameFollowPause, "canSkip");
	}

	public void PauseGameInTutorial()
	{
		OpenPanel(PanelType.InGameTutorialPause);
	}

	public void ResumeGame()
	{
		if ((bool)csFollowSceneGameManager.instance && csFollowSceneGameManager.instance.gameState == GAMESTATE.FollowTime)
		{
			if (csGameSettings.PlayerCurrentDataOn)
			{
				OpenPanel(PanelType.InGameCurrentData);
			}
			else
			{
				OpenPanel(PanelType.InGameGaming);
			}
		}
		else
		{
			OpenPanel(PanelType.InGameGaming);
		}
		coachTimeTips.Body.SetActive(value: true);
	}

	public void ResumeGameSwift()
	{
		if (csIngameSwiftHint.isPlaying)
		{
			OpenPanel(PanelType.InGameSwiftHint, "NoPlay");
		}
		else
		{
			OpenPanel(PanelType.InGameSwiftHint);
		}
	}

	public void BackToMain()
	{
		ClosePanel();
	}

	public void ShowCountDown(int N)
	{
	}

	public void HideCountDown()
	{
	}

	public void SetTime(string t)
	{
	}

	public void SetCombo(int c)
	{
	}

	public void SetScore(int s)
	{
	}

	public void SetHP(float h)
	{
	}

	public void SetEnergy(float Scale, int Rate)
	{
	}

	public void SetAndShowResult()
	{
		OpenPanel(PanelType.InGameResult);
	}

	public void SetAndShowResultFollow()
	{
		inGameFollowResult.setFollowResult(csSportInfoManager.instance.GetFinalCalInt(), csSportInfoManager.instance.GetSportTime() / 60);
		OpenPanel(PanelType.InGameFollowResult);
	}

	public void SetAndShowResultSuperGorilla()
	{
		SLevelValueData sLevelValueData = new SLevelValueData();
		List<SLevelValueData> sBoxLevelList = csGameValueManager.SBoxLevelList;
		for (int i = 0; i < sBoxLevelList.Count; i++)
		{
			sLevelValueData.Cal += sBoxLevelList[i].Cal;
			sLevelValueData.Score += sBoxLevelList[i].Score;
			sLevelValueData.Strength += sBoxLevelList[i].Strength;
			sLevelValueData.Precise += sBoxLevelList[i].Precise;
			sLevelValueData.Hit += sBoxLevelList[i].Hit;
			sLevelValueData.maxHit += sBoxLevelList[i].maxHit;
		}
		ingameResultForSuperMonkey.ShowBoxingData(sLevelValueData.Score, (int)sLevelValueData.Cal, csGameValueManager.SBoxLevelTime);
		SLevelValueData sLevelValueData2 = new SLevelValueData();
		sBoxLevelList = csGameValueManager.SStickLevelList;
		for (int j = 0; j < sBoxLevelList.Count; j++)
		{
			sLevelValueData2.Cal += sBoxLevelList[j].Cal;
			sLevelValueData2.Score += sBoxLevelList[j].Score;
			sLevelValueData2.Strength += sBoxLevelList[j].Strength;
			sLevelValueData2.Precise += sBoxLevelList[j].Precise;
			sLevelValueData2.Hit += sBoxLevelList[j].Hit;
			sLevelValueData2.maxHit += sBoxLevelList[j].maxHit;
		}
		ingameResultForSuperMonkey.ShowStickData(sLevelValueData2.Score, (int)sLevelValueData2.Cal, csGameValueManager.SStickLevelTime);
		ingameResultForSuperMonkey.ShowFollowData(csSportInfoManager.instance.GetFinalCalInt(), csSportInfoManager.instance.GetSportTime());
		ingameResultForSuperMonkey.ShowDataSum();
		OpenPanel(PanelType.InGameResultForSuperMonkey);
	}

	public void SetAndShowResultTutorial()
	{
		inGameFollowResult.setFollowResult(csSportInfoManager.instance.GetFinalCalInt(), csSportInfoManager.instance.GetSportTime() / 60);
		OpenPanel(PanelType.InGameTutorialResult);
	}

	public void ShowSLevelResult(SLevelValueData resultData, float precise, int score, int cal, int strength, bool isAllOver = false, bool isSGLevel = false)
	{
		OpenPanel(PanelType.InGameSLevelResult);
		csIngamePanelSLevelOver.instance.Data_Corret = precise;
		csIngamePanelSLevelOver.instance.Data_Score = score;
		csIngamePanelSLevelOver.instance.Data_kcal = cal;
		csIngamePanelSLevelOver.instance.Data_Str = strength;
		csIngamePanelSLevelOver.instance.resultData = resultData;
		if (isAllOver)
		{
			if (isSGLevel)
			{
				csIngamePanelSLevelOver.instance.CountDownToRelexSG();
			}
			else
			{
				csIngamePanelSLevelOver.instance.CountDownToRelex();
			}
		}
		else
		{
			csIngamePanelSLevelOver.instance.CountDownToResume();
		}
	}

	public void ShowSLevelResultSuperGorillaBreak(SLevelValueData resultData, float precise, int score, int cal, int strength, bool isAllOver = false)
	{
		OpenPanel(PanelType.InGameSLevelResult);
		csIngamePanelSLevelOver.instance.Data_Corret = precise;
		csIngamePanelSLevelOver.instance.Data_Score = score;
		csIngamePanelSLevelOver.instance.Data_kcal = cal;
		csIngamePanelSLevelOver.instance.Data_Str = strength;
		csIngamePanelSLevelOver.instance.resultData = resultData;
		csIngamePanelSLevelOver.instance.CountDownToSuperGorillaBreak();
	}

	public void PrepareNextLevelHint_SuperMonkey(int nextLevel)
	{
		inGameRelaxPause.nextLesson.enabled = true;
		inGameRelaxPause.nextLesson.text = csLocalizationManager.Instance.GetLocalText("InGameRelaxPause03") + GameManagerNew.instance.CurSongData.GameSongInfoList[nextLevel - 1].CurLevelName;
	}

	public void SetScoreLabel(string score)
	{
	}

	public void HideMenu()
	{
	}

	public void OpenPanel(PanelType type, string message = "")
	{
		Vector3 forward = csPlayer.instance.camT.forward;
		forward.y = 0f;
		ParentT.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
		if (currentPanel != 0)
		{
			panelDic[currentPanel].Close();
		}
		currentPanel = type;
		if (string.IsNullOrEmpty(message))
		{
			panelDic[type].Open();
		}
		else
		{
			panelDic[type].Open(message);
		}
	}

	public void ClosePanel(string message = "")
	{
		if (currentPanel != 0)
		{
			panelDic[currentPanel].Close();
		}
		currentPanel = PanelType.None;
	}

	public IEnumerator DisplayCoachTimeHint()
	{
		coachTimeTips.FadeOut();
		yield return new WaitForSeconds(coachTimeTips.displayTime);
		coachTimeTips.FadeIn();
	}
}
public class csIngamePanelCurrentData : csPanelBase
{
	public TextMeshProUGUI strength;

	public TextMeshProUGUI cal;

	public TextMeshProUGUI distanceT;

	public TextMeshProUGUI timeT;

	public Animator animator;

	public Image strengthFill;

	public Image calFill;

	private bool hasOpen;

	public Image DisFillImage;

	public Image TimeFillImage;

	private GameSongData curSongdata;

	[SerializeField]
	private float curTime;

	public int targetCal = 500;

	public override void Open()
	{
		animator.SetTrigger("Enter");
		animator.SetFloat("speed", 1f);
		animator.Play("Enter", 0, 0f);
		hasOpen = true;
		curSongdata = GameData.instance.GetSongDataByClassID(csGameDataTransfer.currentClassID);
		strengthFill.fillAmount = 0f;
		calFill.fillAmount = 0f;
		DisFillImage.fillAmount = 0f;
		TimeFillImage.fillAmount = 0f;
		base.Open();
	}

	public override void Close()
	{
		hasOpen = false;
		StartCoroutine(closePanel());
	}

	private IEnumerator closePanel()
	{
		animator.Play("Enter", 0, 1f);
		animator.SetFloat("speed", -1f);
		yield return new WaitForSeconds(1f);
		if (!hasOpen)
		{
			base.Close();
		}
	}

	public void setStrength(float value)
	{
		strengthFill.fillAmount = value / 100f;
	}

	public void setCal(float value, float target)
	{
		calFill.fillAmount = value / target;
	}

	public void setDis(float value, float target)
	{
		DisFillImage.fillAmount = value / target;
	}

	public void setTime()
	{
		TimeFillImage.fillAmount = csSportInfoManager.instance.GetSportTime() / curSongdata.ClassTotalTime;
	}

	private void Update()
	{
		curTime += Time.deltaTime;
		if (isOpend && (bool)csSportInfoManager.instance && csSportInfoManager.instance.isStartCal)
		{
			cal.text = ((int)(csSportInfoManager.instance.GetFinalCal() / 1000f)).ToString();
			setCal(csSportInfoManager.instance.GetFinalCal(), targetCal);
			strength.text = csSportInfoManager.instance.GetCurrentIntensityInt().ToString();
			setStrength(csSportInfoManager.instance.GetCurrentIntensity());
			distanceT.text = ((int)csSportInfoManager.instance.GetCurrentDist()).ToString();
			setDis(csSportInfoManager.instance.GetFinalCal(), targetCal);
			timeT.text = (csSportInfoManager.instance.GetSportTime() / 60).ToString();
			setTime();
		}
	}

	private bool IsPaused()
	{
		return csIngameMenuManager.instance.inGameCoachPause.isOpend;
	}
}
public class csIngamePanelFollowGap : csPanelBase
{
	public TextMeshProUGUI countdown;

	public float TotalCountDownNum;

	public float CurCountDownNum;

	public Image Fill;

	private Material fillMat;

	public void SetCurrentCountdownNum(float leftTime)
	{
		countdown.text = ((int)leftTime).ToString();
		CurCountDownNum = leftTime;
	}

	public void SetTotalCountdowNum(float leftTime)
	{
		TotalCountDownNum = leftTime;
	}

	public void SetProgress()
	{
		Fill.material.SetFloat("_Progress", CurCountDownNum / TotalCountDownNum);
	}

	public void InitProgress()
	{
		Fill.material = new Material(Fill.material);
		Fill.material.SetFloat("_Progress", 1f);
	}
}
public class csIngamePanelGaming : csPanelBase
{
	public TMP_Text ScoreText;

	public TMP_Text ComboText;

	public RectTransform HP;

	public RectTransform EnergyMask;

	public RectTransform EnergyStript;

	public TMP_Text RateText;

	public Image RateImg;

	public void SetCombo(int c)
	{
		ComboText.text = c.ToString();
	}

	public void SetScore(int s)
	{
		ScoreText.text = s.ToString();
	}

	public void SetHP(float Scale)
	{
		HP.sizeDelta = new Vector2(90f + 655f * Scale, 60f);
	}

	public void SetEnergy(float Scale, int Rate)
	{
		RateImg.fillAmount = Scale;
		RateText.text = "x" + Rate;
	}
}
public class csIngamePanelLeaderboard : MonoBehaviour, IPageContent
{
	public List<csIngamePanelLeaderItem> m_LeaderItemList = new List<csIngamePanelLeaderItem>();

	private csIngamePanelLeaderItem m_myItem;

	private string m_boardName;

	private int m_myScore;

	private int m_maxLeaderCount;

	private csPageUpdownMain pageUpdownMain;

	private int startPage;

	private List<LeaderboardEntry> m_temp_leaderBoardData = new List<LeaderboardEntry>();

	private LeaderboardEntry m_temp_myBoardData;

	public GameObject LoadingObj;

	public GameObject LoadingDone;

	private void Awake()
	{
		m_myItem = m_LeaderItemList[m_LeaderItemList.Count - 1];
		m_maxLeaderCount = m_LeaderItemList.Count - 1;
		pageUpdownMain = GetComponent<csPageUpdownMain>();
		startPage = pageUpdownMain.Totalpage;
	}

	public void Init(string boardName, int score)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			base.gameObject.SetActive(value: true);
			m_boardName = boardName;
			m_myScore = score;
			if (pageUpdownMain != null)
			{
				pageUpdownMain.ResetPage();
			}
			UploadMyData();
		}
	}

	public void InitDataOnlyFetch(string boardName)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			m_boardName = boardName;
			m_myItem.gameObject.SetActive(value: false);
			LoadingObj.SetActive(value: true);
			LoadingDone.SetActive(value: false);
			if (pageUpdownMain != null)
			{
				pageUpdownMain.ResetPage();
			}
			GetLeadrDataByPageIdx(0);
		}
	}

	public void OpenLeaderBoard(bool isOpen)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			base.gameObject.SetActive(isOpen);
			if (pageUpdownMain != null)
			{
				pageUpdownMain.ResetPage();
			}
		}
	}

	private void UploadMyData()
	{
		LoadingObj.SetActive(value: true);
		LoadingDone.SetActive(value: false);
		m_myItem.gameObject.SetActive(value: false);
		csPicoLeaderboard.Instance.SubmitLeaderBoard(m_boardName, m_myScore, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				UploadMyDataComplet(null);
			}
			else
			{
				UploadMyDataFiled(null);
			}
		});
	}

	private void UploadMyDataComplet(UpdatePlayerStatisticsResult result)
	{
		StartCoroutine(WaitforUpdate());
	}

	private IEnumerator WaitforUpdate()
	{
		yield return new WaitForSeconds(1f);
		GetLeadrDataByPageIdx(0);
	}

	private void UploadMyDataFiled(PlayFabError result)
	{
	}

	public void GetLeadrDataByPageIdx(int idx)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			csPicoLeaderboard.Instance.GetLeaderBoard(m_boardName, m_maxLeaderCount, idx, GetLeaderDataCompletPico);
		}
	}

	private void GetLeaderDataCompletPico(List<LeaderboardEntry> resultList, ulong totalCount, string boardName)
	{
		if (boardName != m_boardName)
		{
			return;
		}
		LoadingObj.SetActive(value: false);
		LoadingDone.SetActive(value: true);
		m_temp_leaderBoardData = resultList;
		for (int i = 0; i < m_temp_leaderBoardData.Count; i++)
		{
			if (m_LeaderItemList[i] != null)
			{
				m_LeaderItemList[i].InitPicoOthers(m_temp_leaderBoardData[i], isMine: false);
			}
		}
		if (m_temp_leaderBoardData.Count < m_LeaderItemList.Count)
		{
			for (int j = m_temp_leaderBoardData.Count; j < m_LeaderItemList.Count - 1; j++)
			{
				m_LeaderItemList[j].Hide();
			}
		}
		if (pageUpdownMain != null)
		{
			pageUpdownMain.Totalpage = Mathf.Min((int)Math.Ceiling(1.0 * (double)totalCount / (double)m_LeaderItemList.Count), startPage);
			pageUpdownMain.UpdatePageText();
		}
		StartGetMyData(totalCount);
	}

	private void GetLeaderDataFailed(PlayFabError result)
	{
	}

	private void StartGetLeaderboardCount(UnityAction<int> OnGetDone)
	{
		csPicoLeaderboard.Instance.GetLeaderBoradRankScale(m_boardName, OnGetDone);
	}

	private void StartGetMyData(ulong MaxBoardCount)
	{
		csPicoLeaderboard.Instance.GetMyLeaderBoardData(m_boardName, delegate(List<LeaderboardEntry> data, string lbname)
		{
			if (data != null)
			{
				if (data.Count > 0)
				{
					GetMyDataCompletPico(data[0], lbname, MaxBoardCount);
				}
				else
				{
					GetMyDataFailed(null);
				}
			}
			else
			{
				GetMyDataFailed(null);
			}
		}, delegate
		{
			GetMyDataFailed(null);
		});
	}

	private void GetMyDataCompletPico(LeaderboardEntry result, string lbName, ulong MaxCount)
	{
		if (!(lbName != m_boardName))
		{
			m_myItem.gameObject.SetActive(value: true);
			m_temp_myBoardData = result;
			m_myItem.InitPicoMine(m_temp_myBoardData, isMine: true, MaxCount);
		}
	}

	private void GetMyDataFailed(PlayFabError result)
	{
		m_myItem.gameObject.SetActive(value: true);
		m_myItem.InitEmptyPicoData();
	}

	public void GetContentByPageIdx(int idx)
	{
		GetLeadrDataByPageIdx(idx);
	}
}
public class csIngamePanelLeaderItem : MonoBehaviour
{
	private LeaderboardEntry m_playerData;

	public TextMeshProUGUI m_randNum;

	public TextMeshProUGUI m_playerName;

	public TextMeshProUGUI m_playerScore;

	public Image m_playerImage;

	public Image hightlight;

	private bool m_isMine;

	public TextMeshProUGUI RankHintText;

	public int percentageLine = 100;

	public bool isTotalScore;

	private void Awake()
	{
	}

	public void InitPicoMine(LeaderboardEntry playerData, bool isMine, ulong MaxCount)
	{
		_ = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID;
		base.gameObject.SetActive(value: true);
		m_isMine = isMine;
		m_playerData = playerData;
		string text = "";
		text = playerData.User.ImageUrl;
		csPlayfabServer.Instance.StartGetAvatar(playerData.User.ID, text, SetSprite);
		if (playerData.Rank > percentageLine)
		{
			m_randNum.text = ((double)playerData.Rank / (double)MaxCount).ToString("0%");
			if (isTotalScore)
			{
				RankHintText.text = "您在所有练习课程中获得的最高分总和已经超越" + (1f - 1f * (float)playerData.Rank / (float)MaxCount).ToString("0%") + "的玩家";
			}
			else
			{
				RankHintText.text = "您在该门课程中获得的最高分已经超越" + (1f - 1f * (float)playerData.Rank / (float)MaxCount).ToString("0%") + "的玩家";
			}
		}
		else
		{
			m_randNum.text = playerData.Rank.ToString();
			RankHintText.text = csLocalizationManager.Instance.GetLocalText("InGameResultPanel28");
			if (isTotalScore)
			{
				RankHintText.text = "您在所有练习课程中获得的最高分总和位于第" + playerData.Rank + "名";
			}
			else
			{
				RankHintText.text = "您在该门课程中获得的最高分位于第" + playerData.Rank + "名";
			}
		}
		string playerName = GetPlayerName();
		m_playerName.text = playerName;
		m_playerScore.text = playerData.Score.ToString();
	}

	public void InitPicoOthers(LeaderboardEntry playerData, bool isMine)
	{
		base.gameObject.SetActive(value: true);
		m_isMine = isMine;
		m_playerData = playerData;
		string text = "";
		text = playerData.User.ImageUrl;
		csPlayfabServer.Instance.StartGetAvatar(playerData.User.ID, text, SetSprite);
		if (playerData.Rank > 99)
		{
			m_randNum.text = "99+";
		}
		else
		{
			m_randNum.text = playerData.Rank.ToString();
		}
		string playerName = GetPlayerName();
		m_playerName.text = playerName;
		m_playerScore.text = playerData.Score.ToString();
		if (csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoID == playerData.User.ID)
		{
			if (hightlight != null)
			{
				hightlight.enabled = true;
			}
		}
		else if (hightlight != null)
		{
			hightlight.enabled = false;
		}
	}

	public void InitEmptyPicoData()
	{
		base.gameObject.SetActive(value: true);
		m_isMine = true;
		csPlayfabServer.Instance.StartGetAvatar(csPlayfabServer.Instance.PlayfabID, csPlayerPicoDataManager.instance.m_PicoAccountInfo.headIconURL, SetSprite);
		if (isTotalScore)
		{
			RankHintText.text = csLocalizationManager.Instance.GetLocalText("InGameResultPanel29");
		}
		else
		{
			RankHintText.text = csLocalizationManager.Instance.GetLocalText("InGameResultPanel25");
		}
		m_randNum.text = "-";
		string playerName = GetPlayerName();
		m_playerName.text = playerName;
		m_playerScore.text = "-";
	}

	private void SetSprite(int isSuc, Sprite sprite)
	{
		m_playerImage.sprite = sprite;
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	private string GetPlayerName()
	{
		if (m_isMine)
		{
			return "我";
		}
		string result = "旅行者";
		if (string.IsNullOrEmpty(m_playerData.User.DisplayName))
		{
			return result;
		}
		return m_playerData.User.DisplayName;
	}
}
public class csIngamePanelPause : csPanelBase
{
	public TextMeshProUGUI ClassDiff;

	public TextMeshProUGUI ClassTime;

	public TextMeshProUGUI ClassCoach;

	public TextMeshProUGUI ClassType;

	public Image ClassTypeImage;

	public Image ClassDifImage;

	public Sprite[] ClassEasyTypeSprites;

	public Sprite[] ClassNormalTypeSprites;

	public Sprite[] ClassHardTypeSprites;

	public Sprite[] ClassDifSprites;

	public Image CoachImg;

	public Button CloseBtn;

	public Button OpenBtn;

	public Image ClassImg_selected;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public TextMeshProUGUI sceneryIntroduction;

	private GameSongData CurGameSongData;

	public csVRButtonInMenu LikeButton;

	private void Start()
	{
		LikeButton.button.onClick.AddListener(delegate
		{
			SetCollection(IsinCollectionlist(CurGameSongData.ClassID));
		});
	}

	public void ClosePlatform()
	{
		csPlatformEffectMgr.instance.ClosePlatform();
		csGameSettings.PlayerPlatformOn = false;
		CloseBtn.gameObject.SetActive(value: true);
		OpenBtn.gameObject.SetActive(value: false);
	}

	public void OpenPlatform()
	{
		csPlatformEffectMgr.instance.OpenPlatform();
		csGameSettings.PlayerPlatformOn = true;
		OpenBtn.gameObject.SetActive(value: true);
		CloseBtn.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			ResumeGame();
		}
		if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			ExitToMenu();
		}
	}

	public void ResumeGame()
	{
		GameManagerNew.instance.ResumeGame();
		csTalkingData.Instance.SendEvent("KC03_卡关暂停", 1.0, new Dictionary<string, object> { 
		{
			"课程ID：" + csGameDataTransfer.currentClassID,
			$"第{GameManagerNew.instance.SongPlayer.CurSLevelIndex}关继续次数"
		} });
	}

	public void ExitToMenu()
	{
		csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
		csSportInfoManager.instance.stopCalculateCal();
		GameManagerNew.instance.BackToMain();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{ "status", "cancel" },
			{
				"accuracy",
				GameManagerNew.instance.GameValueManager.GetCurrentStagePrecise()
			},
			{
				"real_kcal",
				GameManagerNew.instance.GameValueManager.GetCurrentStageKCal()
			},
			{
				"goal",
				GameManagerNew.instance.GameValueManager.GetCurrentStageScore()
			},
			{
				"strength",
				GameManagerNew.instance.GameValueManager.GetCurrentStageStrength()
			},
			{
				"combo",
				GameManagerNew.instance.GameValueManager.GetCurrentStageMaxCombo()
			}
		});
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
		{
			{
				"level_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
			},
			{
				"class_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
			},
			{
				"stage_header",
				csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
			},
			{
				"duration",
				(int)(GameManagerNew.instance.GameTimer * 1000f)
			},
			{ "status", "cancel" },
			{
				"goal",
				GameManagerNew.instance.GameValueManager.GetCurrentTotalScore()
			},
			{
				"real_kcal",
				GameManagerNew.instance.GameValueManager.GetCurrentTotalKCal()
			}
		});
		csTalkingData.Instance.SendEvent("KC03_卡关暂停", 1.0, new Dictionary<string, object> { 
		{
			"课程ID：" + csGameDataTransfer.currentClassID,
			$"第{GameManagerNew.instance.SongPlayer.CurSLevelIndex}关退出次数"
		} });
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		ClassImg_selected.sprite = csIDImageIconManager.instance.GetImgByID(d.CoverImgID);
		int num = d.ClassTotalTime / 60;
		ClassTime.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01") + num + "min";
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID);
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		switch (d.TypeInHand)
		{
		case csPlayMode.Boxing:
			ClassType.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01A") + csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
			break;
		case csPlayMode.Stick:
			ClassType.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01A") + csLocalizationManager.Instance.GetLocalText("LevelDetail01C");
			break;
		case csPlayMode.Menu:
			ClassType.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01A") + csLocalizationManager.Instance.GetLocalText("LevelDetail01D");
			break;
		}
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDifImage.sprite = ClassDifSprites[0];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common01");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassEasyTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassEasyTypeSprites[1];
				break;
			}
			break;
		case Diff.normal:
			ClassDifImage.sprite = ClassDifSprites[1];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common02");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassNormalTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassNormalTypeSprites[1];
				break;
			}
			break;
		case Diff.hard:
			ClassDifImage.sprite = ClassDifSprites[2];
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common03");
			switch (d.TypeInHand)
			{
			case csPlayMode.Stick:
				ClassTypeImage.sprite = ClassHardTypeSprites[0];
				break;
			case csPlayMode.Boxing:
				ClassTypeImage.sprite = ClassHardTypeSprites[1];
				break;
			}
			break;
		}
		CoachImg.sprite = csIDImageIconManager.instance.GetImgByID(d.CoachImgID);
		ClassCoach.text = d.CaochName;
	}

	public void resetLevelItemLikeState()
	{
		if (IsinCollectionlist(CurGameSongData.ClassID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public void SetCollection(bool isSet)
	{
		if (!isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: true);
			LikeButton.OnSelect();
		}
		if (isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: false);
			LikeButton.DeSelect();
		}
		csMainMenuManager.instance.levelItemActions[CurGameSongData.ClassID]();
	}

	public override void Open()
	{
		base.Open();
		GameManagerNew.instance.GameValueManager.ClearComboShow();
		if (csGameSettings.PlayerPlatformOn)
		{
			OpenBtn.gameObject.SetActive(value: true);
			CloseBtn.gameObject.SetActive(value: false);
		}
		else
		{
			CloseBtn.gameObject.SetActive(value: true);
			OpenBtn.gameObject.SetActive(value: false);
		}
		resetLevelItemLikeState();
		string text = csLocalizationManager.Instance.GetLocalText(csEnvironmentManager.instance.currenSceneIntroduceID);
		if (text.Contains("\\n"))
		{
			text = text.Replace("\\n", "\n");
		}
		sceneryIntroduction.text = text;
	}
}
public class csIngamePanelProcessMan : MonoBehaviour
{
	public GameObject pointPrefab;

	public GameObject root;

	public Sprite yellow;

	public Sprite black;

	private List<csIngamePanelProcessPoint> points = new List<csIngamePanelProcessPoint>();

	private int currentMax;

	public void initPoint(int num)
	{
		currentMax = num;
		while (points.Count < num)
		{
			points.Add(UnityEngine.Object.Instantiate(pointPrefab, root.transform).GetComponent<csIngamePanelProcessPoint>());
		}
		for (int i = 0; i < points.Count; i++)
		{
			if (i > num - 1)
			{
				points[i].gameObject.SetActive(value: false);
			}
			else
			{
				points[i].gameObject.SetActive(value: true);
			}
			points[i].setSpriteOn(isOn: false, black);
		}
	}

	public void setPage(int num)
	{
		root.SetActive(value: true);
		for (int i = 0; i < points.Count; i++)
		{
			points[i].setSpriteOn(isOn: false, black);
		}
		points[num].setSpriteOn(isOn: true, yellow);
	}

	public void setProcess(int num)
	{
		root.SetActive(value: true);
		for (int i = 0; i < points.Count; i++)
		{
			points[i].setSpriteOn(isOn: false, black);
		}
		for (int j = 0; j < num; j++)
		{
			points[j].setSpriteOn(isOn: true, yellow);
		}
	}
}
public class csIngamePanelProcessPoint : MonoBehaviour
{
	public Image pointImg;

	public Transform thisT;

	public void setSpriteOn(bool isOn, Sprite s)
	{
		pointImg.enabled = isOn;
		if (isOn)
		{
			pointImg.sprite = s;
		}
	}
}
public class csIngamePanelResult : csPanelBase
{
	public int SongCount = 3;

	public RectTransform DetailRect;

	public csIngamePanelLeaderboard ResultLeaderBoard;

	public Image[] fill_EachClassCal;

	public float Data_Corret_Total;

	public int Data_Score_Total;

	public float Data_kcal_Total;

	public float Data_Str_Total;

	public float Data_averageSpeed_Total;

	public Image Data_Corret_IMG;

	public Image Data_Score_IMG;

	public Image Data_kcal_IMG;

	public Image Data_Str_IMG;

	public Image Data_averageSpeed_IMG;

	public TextMeshProUGUI Data_Correttext;

	public TextMeshProUGUI Data_Scoretext;

	public TextMeshProUGUI Data_kcaltext;

	public TextMeshProUGUI Data_Strtext;

	public TextMeshProUGUI Data_averageSpeedText;

	public TextMeshProUGUI taskSit;

	private Coroutine ShowScoreCoroutine;

	private Coroutine ClassCalCoroutine;

	public float maxAverageSpeed = 6f;

	public GameObject averageSpeedCircle;

	private float averageSpeedValue;

	private int currentShow;

	public csVRButtonInMenu showStrChartBtn;

	public csVRButtonInMenu showCalChartBtn;

	public csVRButtonInMenu showAccChartBtn;

	public LineChart strengthChart;

	public LineChart calChart;

	public LineChart accuracyChart;

	private bool isMoving;

	public RectTransform mainBG;

	public csVRButtonInMenu openDetailBtn;

	public csVRButtonInMenu closeDetailBtn;

	public CanvasGroup downPart;

	public TextMeshProUGUI[] SLevelCal;

	public Image[] SLevelCalProcess;

	public RectTransform leftBG;

	protected override void InitRef()
	{
		base.InitRef();
		showStrChartBtn.button.onClick.AddListener(delegate
		{
			showChart(0);
		});
		showCalChartBtn.button.onClick.AddListener(delegate
		{
			showChart(1);
		});
		showAccChartBtn.button.onClick.AddListener(delegate
		{
			showChart(2);
		});
		openDetailBtn.button.onClick.AddListener(delegate
		{
			openDetail();
		});
		closeDetailBtn.button.onClick.AddListener(delegate
		{
			closeDeatil();
		});
	}

	public override void Open()
	{
		base.Open();
		showChart(1);
		closeDeatil();
		if (GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.AddOn))
		{
			taskSit.text = csLocalizationManager.Instance.GetLocalText("InGameResultPanel20");
		}
		else
		{
			taskSit.text = csLocalizationManager.Instance.GetLocalText(GameManagerNew.instance.CurSongData.ClassTitleID) + " " + csLocalizationManager.Instance.GetLocalText("InGameResultPanel20");
		}
	}

	public void ShowClassCal(List<float> songcalPercent)
	{
		int count = songcalPercent.Count;
		DetailRect.sizeDelta = new Vector2(150f, 28f * (float)(count + 1));
		ClassCalCoroutine = StartCoroutine(WaitToShowClassCal(songcalPercent));
	}

	private IEnumerator WaitToShowClassCal(List<float> songcalPercent)
	{
		for (int i = 0; i < fill_EachClassCal.Length; i++)
		{
			fill_EachClassCal[i].fillAmount = 0f;
		}
		yield return new WaitForSeconds(0.5f);
		for (int j = 0; j < songcalPercent.Count; j++)
		{
			fill_EachClassCal[j].DOFillAmount(0f, songcalPercent[j]);
		}
	}

	public void ShowAllData(SLevelValueData allData, float TotalData_Accur, int TotalData_Score, float TotalData_kcal, float TotalData_Str, int totalscore, float totalcal, string classID, bool isBoxing, float averageSpeed)
	{
		if (!isBoxing)
		{
			averageSpeedCircle.SetActive(value: false);
		}
		Data_Correttext.text = (int)TotalData_Accur + "%";
		Data_Scoretext.text = TotalData_Score.ToString();
		Data_kcaltext.text = ((int)(TotalData_kcal / 1000f)).ToString();
		Data_Strtext.text = (int)TotalData_Str + "%";
		Data_averageSpeedText.text = averageSpeed.ToString("#0.0") + "m/s";
		ShowScoreCoroutine = StartCoroutine(WaitToDoFill(allData, TotalData_Accur, TotalData_Score, TotalData_kcal, TotalData_Str, averageSpeed));
		if (GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.AddOn))
		{
			ResultLeaderBoard.gameObject.SetActive(value: false);
		}
		else
		{
			if (!csGameSettings.IsOfflineVersion)
			{
				ResultLeaderBoard.gameObject.SetActive(value: true);
			}
			ResultLeaderBoard.Init(classID, TotalData_Score);
		}
		setCalChart();
		setAccuracyChart();
		setStrengthChart();
	}

	private IEnumerator WaitToDoFill(SLevelValueData allData, float TotalData_Accur, int TotalData_Score, float TotalData_kcal, float TotalData_Str, float averageSpeed)
	{
		Data_Corret_IMG.material = new Material(Data_Corret_IMG.material);
		Data_Score_IMG.material = new Material(Data_Score_IMG.material);
		Data_Str_IMG.material = new Material(Data_Str_IMG.material);
		Data_kcal_IMG.material = new Material(Data_kcal_IMG.material);
		Data_averageSpeed_IMG.material = new Material(Data_averageSpeed_IMG.material);
		Data_Corret_IMG.material.SetFloat("_Progress", 0f);
		Data_Score_IMG.material.SetFloat("_Progress", 0f);
		Data_Str_IMG.material.SetFloat("_Progress", 0f);
		Data_kcal_IMG.material.SetFloat("_Progress", 0f);
		Data_averageSpeed_IMG.material.SetFloat("_Progress", 0f);
		yield return new WaitForSeconds(1f);
		Data_Corret_IMG.material.DOFloat(TotalData_Accur / 100f, "_Progress", 0.5f);
		Data_Score_IMG.material.DOFloat(1f, "_Progress", 0.5f);
		Data_Str_IMG.material.DOFloat(TotalData_Str / 100f, "_Progress", 0.5f);
		averageSpeedValue = Mathf.Clamp(averageSpeed / maxAverageSpeed, 0f, 1f);
		Data_averageSpeed_IMG.material.DOFloat(averageSpeedValue, "_Progress", 0.5f);
		float num = (float)allData.Hit / ((float)allData.maxHit * 0.9f) + (float)allData.wrongHitNum * 0.8f / ((float)allData.maxHit * 0.9f);
		if (num >= 1f)
		{
			num = 1f;
		}
		Data_kcal_IMG.material.DOFloat(num, "_Progress", 0.5f);
	}

	private void showChart(int num)
	{
		if (currentShow != num && num >= 0 && num <= 2)
		{
			currentShow = num;
			calChart.gameObject.SetActive(value: false);
			accuracyChart.gameObject.SetActive(value: false);
			strengthChart.gameObject.SetActive(value: false);
			switch (num)
			{
			case 0:
				showStrChartBtn.OnSelect();
				showCalChartBtn.DeSelect();
				showAccChartBtn.DeSelect();
				strengthChart.gameObject.SetActive(value: true);
				strengthChart.AnimationFadeIn();
				break;
			case 1:
				showStrChartBtn.DeSelect();
				showCalChartBtn.OnSelect();
				showAccChartBtn.DeSelect();
				calChart.gameObject.SetActive(value: true);
				calChart.AnimationFadeIn();
				break;
			case 2:
				showStrChartBtn.DeSelect();
				showCalChartBtn.DeSelect();
				showAccChartBtn.OnSelect();
				accuracyChart.gameObject.SetActive(value: true);
				accuracyChart.AnimationFadeIn();
				break;
			}
		}
	}

	private void closeDeatil()
	{
		if (!isMoving)
		{
			isMoving = true;
			downPart.DOFade(0f, 0.3f).OnComplete(delegate
			{
				openDetailBtn.gameObject.SetActive(value: true);
				closeDetailBtn.gameObject.SetActive(value: false);
				downPart.gameObject.SetActive(value: false);
				isMoving = false;
			});
			mainBG.DOSizeDelta(new Vector2(mainBG.sizeDelta.x, 125f), 0.5f);
		}
	}

	private void openDetail()
	{
		if (!isMoving)
		{
			isMoving = true;
			downPart.gameObject.SetActive(value: true);
			downPart.DOFade(1f, 0.8f).OnComplete(delegate
			{
				openDetailBtn.gameObject.SetActive(value: false);
				closeDetailBtn.gameObject.SetActive(value: true);
				isMoving = false;
			});
			mainBG.DOSizeDelta(new Vector2(mainBG.sizeDelta.x, 245.7f), 0.5f);
		}
	}

	private void setCalChart()
	{
		XAxis orAddChartComponent = calChart.GetOrAddChartComponent<XAxis>();
		orAddChartComponent.data.Clear();
		orAddChartComponent.splitNumber = 0;
		calChart.series[0].ClearData();
		for (int i = 0; i < csSportInfoManager.instance.calIncreaseList.Count; i++)
		{
			if (i / 12 <= 0)
			{
				calChart.AddXAxisData($"{i % 12 * 5}s");
			}
			else
			{
				calChart.AddXAxisData($"{i / 12}m{i % 12 * 5}s");
			}
			calChart.AddData(0, (int)csSportInfoManager.instance.calIncreaseList[i]);
		}
	}

	private void setAccuracyChart()
	{
		XAxis orAddChartComponent = accuracyChart.GetOrAddChartComponent<XAxis>();
		orAddChartComponent.data.Clear();
		orAddChartComponent.splitNumber = 0;
		accuracyChart.series[0].ClearData();
		for (int i = 0; i < csSportInfoManager.instance.avgAccuracyList.Count; i++)
		{
			if (i / 12 <= 0)
			{
				accuracyChart.AddXAxisData($"{i % 12 * 5}s");
			}
			else
			{
				accuracyChart.AddXAxisData($"{i / 12}m{i % 12 * 5}s");
			}
			accuracyChart.AddData(0, csSportInfoManager.instance.avgAccuracyList[i]);
		}
	}

	private void setStrengthChart()
	{
		XAxis orAddChartComponent = strengthChart.GetOrAddChartComponent<XAxis>();
		orAddChartComponent.data.Clear();
		orAddChartComponent.splitNumber = 0;
		strengthChart.series[0].ClearData();
		for (int i = 0; i < csSportInfoManager.instance.avgPowerList.Count; i++)
		{
			if (i / 12 <= 0)
			{
				strengthChart.AddXAxisData($"{i % 12 * 5}s");
			}
			else
			{
				strengthChart.AddXAxisData($"{i / 12}m{i % 12 * 5}s");
			}
			strengthChart.AddData(0, (int)csSportInfoManager.instance.avgPowerList[i]);
		}
	}

	public void BackToMain()
	{
		GameManagerNew.instance.BackToMain();
	}

	public void Resume()
	{
		GameManagerNew.instance.ResumeGame();
	}

	public void setSlevelInfo(List<SLevelValueData> list, bool showInfo)
	{
		leftBG.gameObject.SetActive(showInfo);
		if (!showInfo)
		{
			return;
		}
		leftBG.sizeDelta = new Vector2(leftBG.sizeDelta.x, 25.5f + 28.5f * (float)list.Count);
		for (int i = 0; i < list.Count; i++)
		{
			SLevelCal[i].text = (int)(list[i].Cal / 1000f) + "kcal";
			float num = (float)list[i].Hit / ((float)list[i].maxHit * 0.9f) + (float)list[i].wrongHitNum * 0.8f / ((float)list[i].maxHit * 0.9f);
			if (num >= 1f)
			{
				num = 1f;
			}
			SLevelCalProcess[i].fillAmount = num;
		}
	}

	public override void Close()
	{
		base.Close();
		if (ShowScoreCoroutine != null)
		{
			StopCoroutine(ShowScoreCoroutine);
		}
		if (ClassCalCoroutine != null)
		{
			StopCoroutine(ClassCalCoroutine);
		}
	}
}
public class csIngamePanelScoreRank : MonoBehaviour, IPageContent
{
	public List<csIngamePanelLeaderItem> m_LeaderItemList = new List<csIngamePanelLeaderItem>();

	private csIngamePanelLeaderItem m_myItem;

	private const string m_boardName = "TotalScoreRank";

	private int m_myScore;

	private int m_maxLeaderCount;

	private csPageUpdownMain pageUpdownMain;

	private int startPage;

	private List<LeaderboardEntry> m_temp_leaderBoardData = new List<LeaderboardEntry>();

	private LeaderboardEntry m_temp_myBoardData;

	public GameObject LoadingObj;

	public GameObject LoadingDone;

	private void Awake()
	{
		m_myItem = m_LeaderItemList[m_LeaderItemList.Count - 1];
		m_maxLeaderCount = m_LeaderItemList.Count - 1;
		pageUpdownMain = GetComponent<csPageUpdownMain>();
		startPage = pageUpdownMain.Totalpage;
	}

	public void Init(int score)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			base.gameObject.SetActive(value: true);
			m_myScore = score;
			if (pageUpdownMain != null)
			{
				pageUpdownMain.ResetPage();
			}
			UploadMyData();
		}
	}

	private void UploadMyData()
	{
		LoadingObj.SetActive(value: true);
		LoadingDone.SetActive(value: false);
		m_myItem.gameObject.SetActive(value: false);
		csPicoLeaderboard.Instance.SubmitLeaderBoard("TotalScoreRank", m_myScore, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				UploadMyDataComplete(null);
			}
			else
			{
				UploadMyDataFailed(null);
			}
		});
	}

	private void UploadMyDataComplete(UpdatePlayerStatisticsResult result)
	{
		StartCoroutine(WaitforUpdate());
	}

	private IEnumerator WaitforUpdate()
	{
		yield return new WaitForSeconds(1f);
		GetLeadrDataByPageIdx(0);
	}

	private void UploadMyDataFailed(PlayFabError result)
	{
	}

	public void GetLeadrDataByPageIdx(int idx)
	{
		if (!csGameSettings.IsOfflineVersion)
		{
			csPicoLeaderboard.Instance.GetLeaderBoard("TotalScoreRank", m_maxLeaderCount, idx, GetLeaderDataCompletPico);
		}
	}

	private void GetLeaderDataCompletPico(List<LeaderboardEntry> resultList, ulong totalCount, string boardName)
	{
		LoadingObj.SetActive(value: false);
		LoadingDone.SetActive(value: true);
		m_temp_leaderBoardData = resultList;
		for (int i = 0; i < m_temp_leaderBoardData.Count; i++)
		{
			if (m_LeaderItemList[i] != null)
			{
				m_LeaderItemList[i].InitPicoOthers(m_temp_leaderBoardData[i], isMine: false);
			}
		}
		if (m_temp_leaderBoardData.Count < m_LeaderItemList.Count)
		{
			for (int j = m_temp_leaderBoardData.Count; j < m_LeaderItemList.Count - 1; j++)
			{
				m_LeaderItemList[j].Hide();
			}
		}
		if (pageUpdownMain != null)
		{
			pageUpdownMain.Totalpage = Mathf.Min((int)Math.Ceiling(1.0 * (double)totalCount / (double)(m_LeaderItemList.Count - 1)), startPage);
			pageUpdownMain.UpdatePageText();
		}
		StartGetMyData(totalCount);
	}

	private void StartGetMyData(ulong MaxBoardCount)
	{
		csPicoLeaderboard.Instance.GetMyLeaderBoardData("TotalScoreRank", delegate(List<LeaderboardEntry> data, string lbname)
		{
			if (data != null)
			{
				if (data.Count > 0)
				{
					GetMyDataCompletPico(data[0], lbname, MaxBoardCount);
				}
				else
				{
					GetMyDataFailed(null);
				}
			}
			else
			{
				GetMyDataFailed(null);
			}
		}, delegate
		{
			GetMyDataFailed(null);
		});
	}

	private void GetMyDataCompletPico(LeaderboardEntry result, string lbName, ulong MaxCount)
	{
		m_myItem.gameObject.SetActive(value: true);
		m_temp_myBoardData = result;
		m_myItem.InitPicoMine(m_temp_myBoardData, isMine: true, MaxCount);
	}

	private void GetMyDataFailed(PlayFabError result)
	{
		m_myItem.gameObject.SetActive(value: true);
		m_myItem.InitEmptyPicoData();
	}

	public void GetContentByPageIdx(int idx)
	{
		GetLeadrDataByPageIdx(idx);
	}
}
public class csIngamePanelSLevelOver : csPanelBase
{
	public static csIngamePanelSLevelOver instance;

	public TextMeshProUGUI CountDown_inBtn;

	public float Timer;

	public TextMeshProUGUI CountDown_inText;

	public Button NextBtn;

	public Button EndBtn;

	public csIngamePanelProcessMan processMan;

	public TextMeshProUGUI Data_Correttext;

	public TextMeshProUGUI Data_Scoretext;

	public TextMeshProUGUI Data_kcaltext;

	public TextMeshProUGUI Data_Strtext;

	public SLevelValueData resultData;

	public float Data_Corret;

	public int Data_Score;

	public float Data_kcal;

	public float Data_Str;

	public Image Data_Corret_IMG;

	public Image Data_Score_IMG;

	public Image Data_kcal_IMG;

	public Image Data_Str_IMG;

	public int CurTotalScore = 1000;

	public float CurTotalCal = 1000f;

	public TextMeshProUGUI CurSongInfo;

	private Coroutine DownTimeCoroutine;

	private bool CountDownPause;

	private bool isResumed;

	private bool isExited;

	[SerializeField]
	private bool isSGResume;

	public Image timeFill;

	private float CountDownTime = 5f;

	private int LastInt;

	private bool isSGRelex;

	protected override void InitRef()
	{
		base.InitRef();
		instance = this;
	}

	public void CountDownPauseResume()
	{
		CountDownPause = !CountDownPause;
		if (CountDownPause)
		{
			CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver01");
		}
		else
		{
			CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02");
		}
	}

	public void CountDownToResume()
	{
		isSGResume = false;
		isResumed = false;
		ShowData(Data_Corret, Data_Score, Data_kcal, Data_Str, CurTotalScore, CurTotalCal);
		if (DownTimeCoroutine != null)
		{
			StopCoroutine(DownTimeCoroutine);
		}
		DownTimeCoroutine = StartCoroutine(CountDownEight());
	}

	public void CountDownToSuperGorillaBreak()
	{
		isResumed = false;
		isSGResume = true;
		ShowData(Data_Corret, Data_Score, Data_kcal, Data_Str, CurTotalScore, CurTotalCal);
		if (DownTimeCoroutine != null)
		{
			StopCoroutine(DownTimeCoroutine);
		}
		DownTimeCoroutine = StartCoroutine(CountDownEightToSuperGorillaBreak());
	}

	public void ShowData(float Data_Accur, int Data_Score, float Data_kcal, float Data_Str, int totalscore, float totalcal)
	{
		Data_Correttext.text = (int)Data_Accur + "%";
		Data_Scoretext.text = Data_Score.ToString();
		Data_kcaltext.text = ((int)(Data_kcal / 1000f)).ToString();
		Data_Strtext.text = (int)Data_Str + "%";
		Data_Corret_IMG.material = new Material(Data_Corret_IMG.material);
		Data_Corret_IMG.material.SetFloat("_Progress", 0f);
		Data_Corret_IMG.material.DOFloat(Data_Accur / 100f, "_Progress", 0.5f);
		Data_Score_IMG.material = new Material(Data_Score_IMG.material);
		Data_Score_IMG.material.SetFloat("_Progress", 0f);
		Data_Score_IMG.material.DOFloat(Data_Score / totalscore, "_Progress", 0.5f);
		Data_kcal_IMG.material = new Material(Data_kcal_IMG.material);
		Data_kcal_IMG.material.SetFloat("_Progress", 0f);
		Data_kcal_IMG.material.DOFloat(Data_kcal / totalcal, "_Progress", 0.5f);
		Data_Str_IMG.material = new Material(Data_Str_IMG.material);
		Data_Str_IMG.material.SetFloat("_Progress", 0f);
		Data_Str_IMG.material.DOFloat(Data_Str / 100f, "_Progress", 0.5f);
		float num = (float)resultData.Hit / ((float)resultData.maxHit * 0.9f) + (float)resultData.wrongHitNum * 0.8f / ((float)resultData.maxHit * 0.9f);
		if (num >= 1f)
		{
			num = 1f;
		}
		Data_kcal_IMG.material.DOFloat(num, "_Progress", 0.5f);
	}

	private IEnumerator CountDownEight()
	{
		float cdt = CountDownTime;
		LastInt = 5;
		CountDown_inBtn.gameObject.SetActive(value: true);
		CountDown_inText.gameObject.SetActive(value: true);
		timeFill.fillAmount = 1f;
		CountDownPause = false;
		while (cdt > 0f)
		{
			if (!CountDownPause)
			{
				cdt -= Time.deltaTime;
			}
			if (cdt < (float)(LastInt + 1))
			{
				if (LastInt <= 0)
				{
					CountDown_inText.text = "0" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver03");
				}
				else
				{
					CountDown_inText.text = LastInt + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver03");
				}
				LastInt--;
			}
			timeFill.fillAmount = cdt / CountDownTime;
			yield return new WaitForEndOfFrame();
		}
		if (!isResumed)
		{
			ResumeGame();
		}
	}

	private IEnumerator CountDownEightToSuperGorillaBreak()
	{
		float cdt = CountDownTime;
		LastInt = 5;
		CountDown_inBtn.gameObject.SetActive(value: true);
		CountDown_inText.gameObject.SetActive(value: true);
		timeFill.fillAmount = 1f;
		CountDownPause = false;
		while (cdt > 0f)
		{
			if (!CountDownPause)
			{
				cdt -= Time.deltaTime;
			}
			if (cdt < (float)(LastInt + 1))
			{
				if (LastInt <= 0)
				{
					CountDown_inText.text = "0" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver03");
				}
				else
				{
					CountDown_inText.text = LastInt + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver03");
				}
				LastInt--;
			}
			timeFill.fillAmount = cdt / CountDownTime;
			yield return new WaitForEndOfFrame();
		}
		if (!isResumed)
		{
			SGResume();
		}
	}

	private void SGResume()
	{
		isSGResume = false;
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameRelaxPause);
	}

	public void CountDownToRelex()
	{
		isExited = false;
		ShowData(Data_Corret, Data_Score, Data_kcal, Data_Str, CurTotalScore, CurTotalCal);
		if (DownTimeCoroutine != null)
		{
			StopCoroutine(DownTimeCoroutine);
		}
		DownTimeCoroutine = StartCoroutine(CountDownEightRelex());
	}

	private IEnumerator CountDownEightRelex()
	{
		float cdt = CountDownTime;
		LastInt = 5;
		CountDown_inBtn.gameObject.SetActive(value: true);
		CountDown_inText.gameObject.SetActive(value: true);
		timeFill.fillAmount = 1f;
		CountDownPause = false;
		while (cdt > 0f)
		{
			if (!CountDownPause)
			{
				cdt -= Time.deltaTime;
			}
			if (cdt < (float)(LastInt + 1))
			{
				if (LastInt <= 0)
				{
					CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(0s)";
					CountDown_inText.text = "0" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver04");
				}
				else
				{
					CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(" + LastInt + "s)";
					CountDown_inText.text = LastInt + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver04");
				}
				LastInt--;
			}
			timeFill.fillAmount = cdt / CountDownTime;
			yield return new WaitForEndOfFrame();
		}
		if (!isExited)
		{
			GameOver();
		}
		CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(5s)";
		CountDown_inText.text = "5" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver04");
	}

	public void GameOver()
	{
		isExited = true;
		if (isSGRelex)
		{
			isSGRelex = false;
			csIngameMenuManager.instance.inGameRelaxPause.isSportPause = false;
			csIngameMenuManager.instance.OpenPanel(PanelType.InGameRelaxPause);
		}
		else
		{
			csIngameMenuManager.instance.inGameRelaxPause.nextLesson.enabled = false;
			GameManagerNew.instance.GameOver(toEnd: true);
		}
	}

	public void CountDownToRelexSG()
	{
		isSGRelex = true;
		isExited = false;
		ShowData(Data_Corret, Data_Score, Data_kcal, Data_Str, CurTotalScore, CurTotalCal);
		if (DownTimeCoroutine != null)
		{
			StopCoroutine(DownTimeCoroutine);
		}
		DownTimeCoroutine = StartCoroutine(CountDownEightRelexSG());
	}

	private IEnumerator CountDownEightRelexSG()
	{
		float cdt = CountDownTime;
		LastInt = 5;
		CountDown_inBtn.gameObject.SetActive(value: true);
		CountDown_inText.gameObject.SetActive(value: true);
		timeFill.fillAmount = 1f;
		CountDownPause = false;
		while (cdt > 0f)
		{
			if (!CountDownPause)
			{
				cdt -= Time.deltaTime;
			}
			if (cdt < (float)(LastInt + 1))
			{
				if (LastInt <= 0)
				{
					CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(0s)";
					CountDown_inText.text = "0" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver05");
				}
				else
				{
					CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(" + LastInt + "s)";
					CountDown_inText.text = LastInt + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver05");
				}
				LastInt--;
			}
			timeFill.fillAmount = cdt / CountDownTime;
			yield return new WaitForEndOfFrame();
		}
		if (!isExited)
		{
			GameOver();
		}
		CountDown_inBtn.text = csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver02") + "(5s)";
		CountDown_inText.text = "5" + csLocalizationManager.Instance.GetLocalText("IngamePanelSLevelOver05");
	}

	public void ResumeGame()
	{
		isResumed = true;
		if (isSGResume)
		{
			SGResume();
		}
		else
		{
			GameManagerNew.instance.SLevelStartNext();
		}
	}

	public void ExitToMenu()
	{
		GameManagerNew.instance.BackToMain();
	}
}
public class csIngamePowerBar : MonoBehaviour
{
	public static csIngamePowerBar instance;

	public Canvas thisCanvas;

	public CanvasGroup ThisCG;

	public RectTransform SliderBar;

	public TMP_Text PowerText;

	public TMP_Text AveragePowerText;

	public Transform PowerBarRoot;

	public GameObject upArrow;

	public GameObject downArrow;

	private Image upArrowImg;

	private Image downArrowImg;

	public float arrowShowTime = 0.5f;

	public Transform AveragePowerToggle;

	public csInGamePowerFireAnimation FireAnim;

	private Image FireAnimImg;

	private float sliderBarWidth;

	private Slider sliderBarSlider;

	private bool LineHintIsOn;

	private float LineHintLerpProp = 2f;

	private Vector3 LineHintMoveStartV;

	private Vector3 LineHintMoveEndV;

	private bool IsInLerp;

	private List<float> TL = new List<float>();

	public Transform Handle;

	private Vector3 camFwd;

	private float currentPower;

	private float sumPower;

	private float averagePower;

	private float lastAveragePower;

	private float currentPowerValue;

	private float averagePowerValue;

	private float myValue;

	[Tooltip("力量条上限")]
	public float maxPowerValue = 6f;

	[Tooltip("力量条动画速度")]
	public float changeTime = 0.3f;

	[Tooltip("力量条动画在最大值的停留时间")]
	public float stayTime;

	private void Awake()
	{
		instance = this;
		ThisCG.alpha = 0f;
		thisCanvas.enabled = false;
	}

	public void Start()
	{
		sliderBarWidth = SliderBar.sizeDelta.x;
		sliderBarSlider = SliderBar.GetComponent<Slider>();
		upArrowImg = upArrow.GetComponent<Image>();
		downArrowImg = downArrow.GetComponent<Image>();
		FireAnim = FireAnim.GetComponent<csInGamePowerFireAnimation>();
		FireAnimImg = FireAnim.transform.GetComponent<Image>();
		ResetSlider();
	}

	public void FadeIn()
	{
		if ((bool)GameManagerNew.instance && GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csPlayer.instance.SetAvatarShow(isShow: true);
		}
		csIngameMenuManager.instance.ParentT.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
		thisCanvas.enabled = true;
		ThisCG.DOFade(1f, 0.5f);
		LineHintIsOn = true;
	}

	public void FadeOut()
	{
		csPlayer.instance.SetAvatarShow(isShow: false);
		ThisCG.DOFade(0f, 0.5f).OnComplete(delegate
		{
			thisCanvas.enabled = false;
			LineHintIsOn = false;
		});
	}

	private void Update()
	{
		if (LineHintIsOn)
		{
			PowerBarRoot.position = GameManagerNew.instance.GameValueManager.comboPrefabT.position;
			instance.PowerBarRoot.rotation = Quaternion.LookRotation(GameManagerNew.instance.GameValueManager.comboPrefabT.forward);
		}
		sliderBarSlider.value = myValue;
	}

	private void LineHintAngleCheck()
	{
		camFwd = csPlayer.instance.camT.forward;
		camFwd.y = 0f;
		LineHintMoveEndV = camFwd;
		if (IsInLerp)
		{
			return;
		}
		if (camFwd.sqrMagnitude == 0f)
		{
			camFwd = Vector3.forward;
		}
		if (Vector3.Angle(camFwd, PowerBarRoot.transform.forward) >= 30f)
		{
			LineHintMoveStartV = PowerBarRoot.transform.forward;
			LineHintMoveEndV = camFwd;
			IsInLerp = true;
			LineHintMoveStartV.y = 0f;
			LineHintMoveEndV.y = 0f;
			LineHintLerpProp = 0f;
			DOTween.To(() => 0f, delegate(float x)
			{
				LineHintLerpProp = x;
			}, 1f, 0.8f).SetEase(Ease.InOutQuart);
		}
	}

	public void SetSliderValue(List<float> powerList)
	{
		currentPower = powerList[powerList.Count - 1];
		sumPower += currentPower;
		averagePower = sumPower / (float)powerList.Count;
		if (averagePower > lastAveragePower)
		{
			ShowArrow(upArrowImg);
		}
		if (averagePower < lastAveragePower)
		{
			ShowArrow(downArrowImg);
		}
		lastAveragePower = averagePower;
		currentPowerValue = currentPower / maxPowerValue;
		averagePowerValue = averagePower / maxPowerValue;
		currentPowerValue = Mathf.Clamp(currentPowerValue, 0f, 1f);
		averagePowerValue = Mathf.Clamp(averagePowerValue, 0f, 1f);
		DOTween.To(() => myValue, delegate(float x)
		{
			myValue = x;
		}, currentPowerValue, changeTime);
		StartCoroutine(PowerBarAnim(changeTime, stayTime));
		AveragePowerToggle.localPosition = new Vector3((averagePowerValue - 0.5f) * sliderBarWidth, 15f, 0f);
		if (averagePower > 2.95f && averagePower <= 3.45f)
		{
			GameManagerNew.instance.GameValueManager.isBoxingFire(1);
		}
		else if (averagePower > 3.45f)
		{
			GameManagerNew.instance.GameValueManager.isBoxingFire(2);
		}
		else
		{
			GameManagerNew.instance.GameValueManager.isBoxingFire(0);
		}
		PowerText.text = currentPower.ToString("#0.0");
		AveragePowerText.text = averagePower.ToString("#0.0");
	}

	public void ResetSlider()
	{
		FireAnimImg.enabled = false;
		upArrowImg.color = new Color(255f, 255f, 255f, 0f);
		downArrowImg.color = new Color(255f, 255f, 255f, 0f);
		AveragePowerToggle.localPosition = new Vector3(0f - sliderBarWidth / 2f, 15f, 0f);
		sumPower = 0f;
		currentPower = 0f;
		sliderBarSlider.value = 0f;
		PowerText.text = "0";
		AveragePowerText.text = "0";
		if ((bool)GameManagerNew.instance)
		{
			GameManagerNew.instance.GameValueManager.isBoxingFire?.Invoke(0);
		}
	}

	public void ShowArrow(Image arrowImg)
	{
		arrowImg.color = new Color(255f, 255f, 255f, 255f);
		StartCoroutine(HideArrow(arrowImg));
	}

	private IEnumerator HideArrow(Image arrowImg)
	{
		yield return new WaitForSeconds(arrowShowTime);
		arrowImg.color = new Color(255f, 255f, 255f, 0f);
	}

	private IEnumerator PowerBarAnim(float time, float stayTime)
	{
		yield return new WaitForSeconds(time + stayTime);
		DOTween.To(() => myValue, delegate(float x)
		{
			myValue = x;
		}, 0f, changeTime);
	}
}
[RequireComponent(typeof(Image))]
public class csInGamePowerFireAnimation : MonoBehaviour
{
	private Image ImageSource;

	private int mCurFrame;

	private float mDelta;

	public float FPS = 5f;

	public List<Sprite> SpriteFrames;

	public bool IsPlaying;

	public bool Foward = true;

	public bool AutoPlay;

	public bool Loop;

	public int FrameCount => SpriteFrames.Count;

	private void Awake()
	{
		ImageSource = GetComponent<Image>();
	}

	private void Start()
	{
		if (AutoPlay)
		{
			Play();
		}
		else
		{
			IsPlaying = false;
		}
	}

	private void SetSprite(int idx)
	{
		ImageSource.sprite = SpriteFrames[idx];
	}

	public void Play()
	{
		IsPlaying = true;
		Foward = true;
	}

	public void PlayReverse()
	{
		IsPlaying = true;
		Foward = false;
	}

	private void Update()
	{
		if (!IsPlaying || FrameCount == 0)
		{
			return;
		}
		mDelta += Time.deltaTime;
		if (!(mDelta > 1f / FPS))
		{
			return;
		}
		mDelta = 0f;
		if (Foward)
		{
			mCurFrame++;
		}
		else
		{
			mCurFrame--;
		}
		if (mCurFrame >= FrameCount)
		{
			if (!Loop)
			{
				IsPlaying = false;
				return;
			}
			mCurFrame = 0;
		}
		else if (mCurFrame < 0)
		{
			if (!Loop)
			{
				IsPlaying = false;
				return;
			}
			mCurFrame = FrameCount - 1;
		}
		SetSprite(mCurFrame);
	}

	public void Pause()
	{
		IsPlaying = false;
	}

	public void Resume()
	{
		if (!IsPlaying)
		{
			IsPlaying = true;
		}
	}

	public void Stop()
	{
		mCurFrame = 0;
		SetSprite(mCurFrame);
		IsPlaying = false;
	}

	public void Rewind()
	{
		mCurFrame = 0;
		SetSprite(mCurFrame);
		Play();
	}
}
public class csIngameRelaxPause : csPanelBase
{
	public Button ResumeBtn;

	public Button ExitBtn;

	public TextMeshProUGUI nextLesson;

	public bool isSportPause = true;

	private void Start()
	{
		ResumeBtn.onClick.AddListener(ResumeGame);
		ExitBtn.onClick.AddListener(ExitToMenu);
	}

	public void ResumeGame()
	{
		if (isSportPause)
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
				csGameDataTransfer.playMode = GameManagerNew.instance.SongPlayer.curMusicData.SingleLevelDataList[GameManagerNew.instance.SongPlayer.CurSLevelIndex].HandPlayMode;
				csPlayer.instance.HandItemMan.InitItemOnHand(GameManagerNew.instance.SongPlayer.curMusicData.SingleLevelDataList[GameManagerNew.instance.SongPlayer.CurSLevelIndex].HandPlayMode);
			});
			csIngamePanelSLevelOver.instance.ResumeGame();
			csIngameMenuManager.instance.ClosePanel();
		}
		else
		{
			csIngameMenuManager.instance.ClosePanel();
			GameManagerNew.instance.GameOver(toEnd: true);
		}
	}

	public override void Close()
	{
		base.Close();
		nextLesson.enabled = false;
	}

	public void ExitToMenu()
	{
		csIngameMenuManager.instance.OpenPanel(PanelType.InGameCommonHint);
		csIngameMenuManager.instance.InGameCommonHintPanel.InitTwoButtonHint(csLocalizationManager.Instance.GetLocalText("InGameCommonHintForSuperMonkey01"), csLocalizationManager.Instance.GetLocalText("InGameCommonHintForSuperMonkey02"), null, csLocalizationManager.Instance.GetLocalText("InGameCommonHintForSuperMonkey03"), null, delegate
		{
			csSportInfoManager.instance.pauseDataRecord(isEndSong: true);
			csSportInfoManager.instance.stopCalculateCal();
			GameManagerNew.instance.BackToMain();
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.stage_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{ "status", "cancel" },
				{
					"accuracy",
					GameManagerNew.instance.GameValueManager.GetCurrentStagePrecise()
				},
				{
					"real_kcal",
					GameManagerNew.instance.GameValueManager.GetCurrentStageKCal()
				},
				{
					"goal",
					GameManagerNew.instance.GameValueManager.GetCurrentStageScore()
				},
				{
					"strength",
					GameManagerNew.instance.GameValueManager.GetCurrentStageStrength()
				},
				{
					"combo",
					GameManagerNew.instance.GameValueManager.GetCurrentStageMaxCombo()
				}
			});
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_end, new Dictionary<string, object>
			{
				{
					"level_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.level_Header)
				},
				{
					"class_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.class_Header)
				},
				{
					"stage_header",
					csByteEventTracking.Instance.GetStringHeaderValue(EventParams.stage_Header)
				},
				{
					"duration",
					(int)(GameManagerNew.instance.GameTimer * 1000f)
				},
				{ "status", "cancel" },
				{
					"goal",
					GameManagerNew.instance.GameValueManager.GetCurrentTotalScore()
				},
				{
					"real_kcal",
					GameManagerNew.instance.GameValueManager.GetCurrentTotalKCal()
				}
			});
			csTalkingData.Instance.SendEvent("KC03_卡关暂停", 1.0, new Dictionary<string, object> { 
			{
				"课程ID：" + csGameDataTransfer.currentClassID,
				$"第{GameManagerNew.instance.SongPlayer.CurSLevelIndex}关退出次数"
			} });
		}, delegate
		{
			csIngameMenuManager.instance.OpenPanel(PanelType.InGameRelaxPause);
		});
	}
}
public class csIngameResultForSuperMonkey : csPanelBase
{
	public Button BackBtn;

	public TextMeshProUGUI ScoreSumText;

	public TextMeshProUGUI CalSumText;

	public TextMeshProUGUI BoxingScore;

	public TextMeshProUGUI BoxingCal;

	public TextMeshProUGUI BoxingTime;

	public TextMeshProUGUI StickScore;

	public TextMeshProUGUI StickCal;

	public TextMeshProUGUI StickTime;

	public TextMeshProUGUI FollowCal;

	public TextMeshProUGUI FollowTime;

	public Image AllScoreFill;

	public Image AllCalFill;

	private int scoreSum;

	private int calSum;

	private float TimeSum;

	private void Start()
	{
		BackBtn.onClick.AddListener(BackToMenu);
	}

	public void DataInit()
	{
		scoreSum = 0;
		calSum = 0;
		TimeSum = 0f;
	}

	public void ShowBoxingData(int score, int cal, float seconds)
	{
		BoxingScore.text = score.ToString();
		scoreSum += score;
		BoxingCal.text = cal / 1000 + "Kcal";
		calSum += cal;
		if (seconds > 60f)
		{
			BoxingTime.text = (int)(seconds / 60f) + "min" + seconds % 60f + "s";
		}
		else
		{
			BoxingTime.text = seconds + "s";
		}
		TimeSum += seconds;
	}

	public void ShowStickData(int score, int cal, float seconds)
	{
		StickScore.text = score.ToString();
		scoreSum += score;
		StickCal.text = cal / 1000 + "Kcal";
		calSum += cal;
		if (seconds > 60f)
		{
			StickTime.text = (int)(seconds / 60f) + "min" + seconds % 60f + "s";
		}
		else
		{
			StickTime.text = seconds + "s";
		}
		TimeSum += seconds;
	}

	public void ShowFollowData(int cal, float seconds)
	{
		FollowCal.text = cal / 1000 + "Kcal";
		calSum += cal;
		if (seconds > 60f)
		{
			FollowTime.text = (int)(seconds / 60f) + "min" + seconds % 60f + "s";
		}
		else
		{
			FollowTime.text = seconds + "s";
		}
		TimeSum += seconds;
	}

	public void ShowDataSum()
	{
		ScoreSumText.text = scoreSum.ToString();
		CalSumText.text = calSum.ToString();
		AllScoreFill.fillAmount = (float)scoreSum / 20000f;
		AllCalFill.fillAmount = (float)calSum / CalcuateCal(TimeSum);
		DataInit();
	}

	public float CalcuateCal(float timeUse)
	{
		float num = csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight;
		if (num > 150f)
		{
			num = 150f;
		}
		if (num < 30f)
		{
			num = 30f;
		}
		return 5.5f * num * 0.2783f * timeUse;
	}

	public void BackToMenu()
	{
		csFollowSceneGameManager.instance.BackToMain();
		csFollowSceneGameManager.instance.closeVideo();
	}
}
public class csIngameSwiftHint : csPanelBase
{
	public static csIngameSwiftHint instance;

	public static bool isPause;

	public static bool isPlaying;

	private bool hintIsClose;

	public CanvasGroup CGTutorialUI;

	private csMusicPrefabOptmizedData md;

	private bool isSkiped;

	protected override void InitRef()
	{
		base.InitRef();
		instance = this;
	}

	public override void Open()
	{
		base.Open();
		if (!isPlaying)
		{
			isSkiped = false;
			StartCoroutine(StartSwiftTutorial());
			CGTutorialUI.gameObject.SetActive(value: true);
			CGTutorialUI.alpha = 1f;
			hintIsClose = false;
		}
	}

	public void SkipSwiftTutorial()
	{
		if (!isSkiped)
		{
			isSkiped = true;
			GameManagerNew.instance.SkipClicked = true;
			isPause = false;
			isPlaying = false;
			hintIsClose = false;
			GameManagerNew.instance.SongPlayer.Stop();
			GameManagerNew.instance.SongPlayer.ClearData();
		}
	}

	private IEnumerator StartSwiftTutorial()
	{
		isPlaying = true;
		bool dataIsGet = false;
		csAssetLoader.instance.GetOptmizedDataByUrl(GameData.instance.TutorialSongDataSwift.LevelDataUrlName, isBundleLevel: false, delegate(csMusicPrefabOptmizedData d)
		{
			md = d;
			dataIsGet = true;
		});
		while (!dataIsGet)
		{
			yield return new WaitForEndOfFrame();
		}
		if (isPlaying)
		{
			while (isPause)
			{
				yield return new WaitForEndOfFrame();
			}
			if (isPlaying)
			{
				yield return GameManagerNew.instance.StartSwiftMusicGame(md);
				SkipSwiftTutorial();
			}
		}
	}

	public void CloseHint()
	{
		if (!hintIsClose)
		{
			CGTutorialUI.DOFade(0f, 0.5f).OnComplete(delegate
			{
				CGTutorialUI.gameObject.SetActive(value: false);
				csPlayer.instance.pauseUILaser(dontUse: true);
			});
			hintIsClose = true;
		}
	}
}
public class csIngameTimeLineHint : MonoBehaviour
{
	public static csIngameTimeLineHint instance;

	public Canvas thisCanvas;

	public CanvasGroup ThisCG;

	public float BarWidth = 512f;

	public RectTransform MaskRect;

	public Transform DotParent;

	public Transform ArrowHintT;

	public TextMeshProUGUI TimeText;

	public GameObject TimeLineDot;

	public List<csIngameTimeLineHintDot> HintDots;

	private Dictionary<int, float> DotStartValue = new Dictionary<int, float>();

	private Dictionary<int, float> DotFillValue = new Dictionary<int, float>();

	public int CurrentProgressDot;

	public Transform TimeLineRoot;

	private bool LineHintIsOn;

	private float LineHintLerpProp = 2f;

	private Vector3 LineHintMoveStartV;

	private Vector3 LineHintMoveEndV;

	private bool IsInLerp;

	private Vector3 camFwd;

	private float MaxTime;

	private void Awake()
	{
		instance = this;
		ThisCG.alpha = 0f;
		thisCanvas.enabled = false;
	}

	public void FadeIn()
	{
		if ((bool)GameManagerNew.instance && GameManagerNew.instance.CurSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csPlayer.instance.SetAvatarShow(isShow: true);
		}
		csIngameMenuManager.instance.ParentT.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
		thisCanvas.enabled = true;
		ThisCG.DOFade(1f, 0.5f);
		LineHintIsOn = true;
	}

	public void FadeOut()
	{
		csPlayer.instance.SetAvatarShow(isShow: false);
		ThisCG.DOFade(0f, 0.5f).OnComplete(delegate
		{
			thisCanvas.enabled = false;
			LineHintIsOn = false;
		});
	}

	private void Update()
	{
		if (LineHintIsOn)
		{
			LineHintAngleCheck();
			if (LineHintLerpProp < 1f)
			{
				IsInLerp = true;
				TimeLineRoot.transform.rotation = Quaternion.Lerp(Quaternion.LookRotation(LineHintMoveStartV, Vector3.up), Quaternion.LookRotation(LineHintMoveEndV, Vector3.up), LineHintLerpProp);
			}
			else
			{
				IsInLerp = false;
			}
		}
	}

	private void LineHintAngleCheck()
	{
		camFwd = csPlayer.instance.camT.forward;
		camFwd.y = 0f;
		LineHintMoveEndV = camFwd;
		if (IsInLerp)
		{
			return;
		}
		if (camFwd.sqrMagnitude == 0f)
		{
			camFwd = Vector3.forward;
		}
		if (Vector3.Angle(camFwd, TimeLineRoot.transform.forward) >= 30f)
		{
			LineHintMoveStartV = TimeLineRoot.transform.forward;
			LineHintMoveEndV = camFwd;
			IsInLerp = true;
			LineHintMoveStartV.y = 0f;
			LineHintMoveEndV.y = 0f;
			LineHintLerpProp = 0f;
			DOTween.To(() => 0f, delegate(float x)
			{
				LineHintLerpProp = x;
			}, 1f, 0.8f).SetEase(Ease.InOutQuart);
		}
	}

	public void InitDot(List<float> TimeCostList)
	{
		ArrowHintT.localPosition = new Vector3(0f, 13f, 0f);
		DotStartValue.Clear();
		DotFillValue.Clear();
		if (TimeCostList.Count + 1 > HintDots.Count)
		{
			int num = TimeCostList.Count + 1 - HintDots.Count;
			for (int i = 0; i < num; i++)
			{
				csIngameTimeLineHintDot component = UnityEngine.Object.Instantiate(TimeLineDot, DotParent).GetComponent<csIngameTimeLineHintDot>();
				HintDots.Add(component);
				component.OpenDot(isOpen: false);
			}
		}
		foreach (csIngameTimeLineHintDot hintDot in HintDots)
		{
			hintDot.OpenDot(isOpen: false);
		}
		MaxTime = 0f;
		for (int j = 0; j < TimeCostList.Count; j++)
		{
			MaxTime += TimeCostList[j];
		}
		for (int k = 0; k < TimeCostList.Count + 1; k++)
		{
			if (k == 0)
			{
				DotStartValue.Add(0, 0f);
				DotFillValue.Add(k, BarWidth * TimeCostList[k] / MaxTime);
				continue;
			}
			DotStartValue.Add(k, DotStartValue[k - 1] + BarWidth * TimeCostList[k - 1] / MaxTime);
			if (k < TimeCostList.Count)
			{
				DotFillValue.Add(k, BarWidth * TimeCostList[k] / MaxTime);
			}
		}
		for (int l = 0; l < TimeCostList.Count + 1; l++)
		{
			HintDots[l].OpenDot(isOpen: true);
			if (l == 0)
			{
				HintDots[l].SetLocalPosX(0f);
				HintDots[l].SetDotReach(isReach: true);
			}
			else
			{
				HintDots[l].SetLocalPosX(DotStartValue[l]);
				HintDots[l].SetDotReach(isReach: false);
			}
		}
		SetSliderValue(0, 0f);
	}

	public void SetProgressFinish(int p)
	{
		HintDots[p].SetDotReach(isReach: true);
	}

	public void SetSliderValue(int curDot, float percent)
	{
		CurrentProgressDot = curDot;
		MaskRect.sizeDelta = new Vector2(DotStartValue[curDot] + percent * DotFillValue[curDot], MaskRect.sizeDelta.y);
		ArrowHintT.localPosition = new Vector3(DotStartValue[curDot] + percent * DotFillValue[curDot], 13f, 0f);
		TimeText.text = csUtils.FormatFloatTimeToStr(full: false, ArrowHintT.localPosition.x / BarWidth * MaxTime);
	}
}
public class csIngameTimeLineHintDot : MonoBehaviour
{
	public Image Img_DotReach;

	public Transform thisT;

	public void OpenDot(bool isOpen)
	{
		base.gameObject.SetActive(isOpen);
	}

	public void SetDotReach(bool isReach)
	{
		Img_DotReach.enabled = isReach;
	}

	public void SetLocalPosX(float posX)
	{
		UnityEngine.Debug.LogError("SetLocalPosX:" + posX);
		thisT.transform.localPosition = new Vector3(posX, 0f, 0f);
	}
}
public class csIngameTutorialPause : csPanelBase
{
	public Button ResumeBtn;

	public Button EndBtn;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public GameSongData CurGameSongData;

	public Sprite[] ClassImageSprites;

	public Image ClassImage;

	protected override void InitRef()
	{
		base.InitRef();
		ResumeBtn.onClick.AddListener(ResumeGame);
		EndBtn.onClick.AddListener(BackToMain);
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID);
		ClassName.text = ClassName.text.Replace("\\n", "\n");
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		Classdetail.text = Classdetail.text.Replace("\\n", "\n");
		_ = d.ClassTotalTime / 60;
		switch (d.Type)
		{
		case ClassType.TutorialPunch:
			ClassImage.sprite = ClassImageSprites[0];
			break;
		case ClassType.TutorialStick:
			ClassImage.sprite = ClassImageSprites[1];
			break;
		case ClassType.TUtorialFollow:
			break;
		}
	}

	public void ResumeGame()
	{
		csIngameMenuManager.instance.ClosePanel();
		if (csTutorialSceneGameManager.instance.gameState == GAMESTATE.TutorialVideoPause)
		{
			csTutorialSceneGameManager.instance.ResumeGameInTutorialVideo();
		}
		if (csTutorialSceneGameManager.instance.gameState == GAMESTATE.GAMEPAUSE)
		{
			csTutorialSceneGameManager.instance.ResumeGameInTutorialGame();
		}
	}

	public void BackToMain()
	{
		UnityEngine.Debug.LogError("BackToMian");
		csTutorialSceneGameManager.instance.BackToMain();
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.end_tutorial, new Dictionary<string, object>
		{
			{
				"stage",
				csTutorialSceneGameManager.instance.tutorialStage
			},
			{ "status", "cancel" }
		});
	}
}
public class csIngameTutorialResult : csPanelBase
{
	public Button EndBtn;

	public TextMeshProUGUI calT;

	public TextMeshProUGUI timeT;

	public Image calImg;

	public Image timeImg;

	protected override void InitRef()
	{
		base.InitRef();
		EndBtn.onClick.AddListener(BackToMain);
	}

	public void BackToMain()
	{
		csFollowSceneGameManager.instance.BackToMain();
		csFollowSceneGameManager.instance.closeVideo();
	}

	public void setFollowResult(int cal, int time)
	{
		calT.text = cal.ToString();
		calImg.fillAmount = (float)cal / 3000f;
		timeT.text = time.ToString();
		timeImg.fillAmount = 1f;
	}
}
public class csAnnouncementDetailsPanel : csPanelBase
{
	public string currentAnnID;

	public TextMeshProUGUI title;

	public TextMeshProUGUI detail;

	public Image DetailImage;

	public csPageUpdownMain CsPageUpdown;

	public RectTransform contentMask;

	public RectTransform content;

	private float contentHeight;

	public RectTransform detailTra;

	private float browseTime;

	private Coroutine calculagraph;

	protected override void InitRef()
	{
		base.InitRef();
	}

	public void SetAnnouncementDetails(string currentAnnID, string title, string detail, Sprite detailsSprite)
	{
		this.currentAnnID = currentAnnID;
		title = title.Replace("\\n", "\n");
		this.title.text = title;
		detail = detail.Replace("\\n", "\n");
		this.detail.text = detail;
		DetailImage.sprite = detailsSprite;
		StartCoroutine(CalculateContentHeight());
	}

	private IEnumerator CalculateContentHeight()
	{
		yield return new WaitForEndOfFrame();
		content.localPosition = Vector3.zero;
		contentHeight = 93.813f + detailTra.sizeDelta.y;
		content.sizeDelta = new Vector2(content.sizeDelta.x, contentHeight);
		CsPageUpdown.SetTotalpage((int)Math.Ceiling(contentHeight / contentMask.sizeDelta.y));
		browseTime = 0f;
		calculagraph = StartCoroutine(Calculagraph());
	}

	private IEnumerator Calculagraph()
	{
		while (true)
		{
			browseTime += Time.deltaTime;
			yield return null;
		}
	}

	public void Back()
	{
		StopCoroutine(calculagraph);
		csPlayfabServer.Instance.SubmitScore((int)Math.Ceiling(browseTime), currentAnnID, null, null);
		browseTime = 0f;
		csAnnouncementPanel.Instance.downPanel.SetActive(value: true);
		csAnnouncementPanel.Instance.playerinfoPanel.SetActive(value: true);
		csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
		if (!csGameSettings.IsOfflineVersion)
		{
			csLevelChoosePanel.instance.scoreRankPanel.gameObject.SetActive(value: true);
		}
	}
}
public class csAnnouncementPanel : MonoBehaviour
{
	public static csAnnouncementPanel Instance;

	public GameObject main;

	public GameObject loading;

	public Transform titleGroup;

	public GameObject titleLitem;

	public Image announcementImage;

	public Sprite PlayerCostmizeSprite;

	public csAnnouncementTitleLitem currentAnnouncement;

	public csAnnouncementTitleLitem CostumizeEnterance;

	private bool loadOver;

	private List<csAnnouncementTitleLitem> titleLitemList = new List<csAnnouncementTitleLitem>();

	private List<AnnouncementItem> announcementItemList = new List<AnnouncementItem>();

	[HideInInspector]
	public List<csVRButtonInMenu> buttonInMenus = new List<csVRButtonInMenu>();

	public GameObject downPanel;

	public GameObject playerinfoPanel;

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			Instance = this;
		}
		if (!loadOver)
		{
			main.SetActive(value: false);
			loading.SetActive(value: true);
		}
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(SetLanguage));
	}

	public void InitClassDetail(List<AnnouncementItem> AnnouncementItemList)
	{
		if (titleLitemList.Count > 0)
		{
			foreach (csAnnouncementTitleLitem titleLitem in titleLitemList)
			{
				if (!(titleLitem == CostumizeEnterance))
				{
					UnityEngine.Object.Destroy(titleLitem.gameObject);
				}
			}
			titleLitemList.Clear();
			buttonInMenus.Clear();
		}
		if (AnnouncementItemList.Count > 0)
		{
			foreach (AnnouncementItem AnnouncementItem in AnnouncementItemList)
			{
				csAnnouncementTitleLitem component = UnityEngine.Object.Instantiate(this.titleLitem, titleGroup).GetComponent<csAnnouncementTitleLitem>();
				component.Initialization(AnnouncementItem, announcementImage);
				component.announcementPanel = this;
				buttonInMenus.Add(component.vrButton);
				titleLitemList.Add(component);
			}
			loadOver = true;
			main.SetActive(value: true);
			loading.SetActive(value: false);
			announcementItemList = AnnouncementItemList;
			titleLitemList[0].FirstLoad();
		}
		CostumizeEnterance.transform.SetAsLastSibling();
		titleLitemList.Add(CostumizeEnterance);
		CostumizeEnterance.announcementPanel = this;
		buttonInMenus.Add(CostumizeEnterance.vrButton);
	}

	public void SetLanguage()
	{
		foreach (csAnnouncementTitleLitem titleLitem in titleLitemList)
		{
			UnityEngine.Object.Destroy(titleLitem.gameObject);
		}
		titleLitemList.Clear();
		buttonInMenus.Clear();
		InitClassDetail(announcementItemList);
	}

	public void OnClickDetailButton()
	{
		if (currentAnnouncement.isCustmize)
		{
			UnityEngine.Debug.Log("Addon Level Entrance");
			csLevelChoosePanel.instance.ApplySpColKeyword(csLevelChoosePanel.LevelGroupType.AddOnLevels, csLocalizationManager.Instance.GetLocalText("AnnouncementPanel02"));
		}
		else
		{
			csMainMenuManager.instance.announcementDetailsPanel.SetAnnouncementDetails(currentAnnouncement.annID, currentAnnouncement.annouceTitle, currentAnnouncement.annouceDetail, currentAnnouncement.annouceDetailSprite);
			csTalkingData.Instance.SendEvent("GG01_公告点击量", 1.0, new Dictionary<string, object> { { "公告ID：", currentAnnouncement.annID } });
			downPanel.SetActive(value: false);
			playerinfoPanel.SetActive(value: false);
			csMainMenuManager.instance.OpenPanel(PanelType.AnnouncementDetailsPanel);
		}
		csLevelChoosePanel.instance.scoreRankPanel.gameObject.SetActive(value: false);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_Announcement_{currentAnnouncement.annID}"
			},
			{
				"button_name",
				ButtonTrackingClick.Announcement_.ToString() + currentAnnouncement.annouceTitle
			}
		});
	}
}
public class csAnnouncementTitleLitem : MonoBehaviour
{
	public string annID;

	public TextMeshProUGUI title;

	private Image MyImage;

	public csAnnouncementPanel announcementPanel;

	public string annouceTitle;

	public string annouceDetail;

	public Sprite annouceTitleSprite;

	public Sprite annouceDetailSprite;

	public csVRButtonInMenu vrButton;

	public Image myTittleImage;

	public bool isCustmize;

	public void Initialization(AnnouncementItem MyAnnouncementItem, Image img)
	{
		if (title == null)
		{
			title = base.transform.Find("Text (TMP)").GetComponent<TextMeshProUGUI>();
		}
		vrButton = GetComponent<csVRButtonInMenu>();
		vrButton.DeSelect();
		MyImage = img;
		switch (csLocalizationManager.Instance.m_CurrentLanguage)
		{
		case Languages.ChineseSimplified:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleCN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailCN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLCN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLCN, GetDetailSprite);
			break;
		case Languages.English:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleEN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailEN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLEN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLEN, GetDetailSprite);
			break;
		case Languages.German:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleEN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailEN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLEN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLEN, GetDetailSprite);
			break;
		case Languages.Korean:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleEN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailEN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLEN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLEN, GetDetailSprite);
			break;
		case Languages.French:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleEN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailEN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLEN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLEN, GetDetailSprite);
			break;
		case Languages.Japanese:
			annID = MyAnnouncementItem.AnnID;
			annouceTitle = MyAnnouncementItem.AnnouceTitleEN;
			annouceDetail = MyAnnouncementItem.AnnouceDetailEN;
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgTitleURLEN, GetTitleSprite);
			csCloudSettings.GetAnnouceImageFromCloud(MyAnnouncementItem.ImgDetailURLEN, GetDetailSprite);
			break;
		}
		title.text = annouceTitle;
		myTittleImage.sprite = annouceTitleSprite;
	}

	public void InitializationCustmize(string at, Sprite imgspt, Image img)
	{
		annouceTitle = at;
		title.text = annouceTitle;
		annouceTitleSprite = imgspt;
		MyImage = img;
	}

	public void OnIitleClick()
	{
		title.text = annouceTitle;
		MyImage.sprite = annouceTitleSprite;
		announcementPanel.currentAnnouncement = this;
		if (csAnnouncementPanel.Instance.buttonInMenus != null)
		{
			foreach (csVRButtonInMenu buttonInMenu in csAnnouncementPanel.Instance.buttonInMenus)
			{
				buttonInMenu.DeSelect();
			}
		}
		vrButton.OnSelect();
		csAnnouncementPanel.Instance.OnClickDetailButton();
	}

	public void FirstLoad()
	{
		title.text = annouceTitle;
		MyImage.sprite = annouceTitleSprite;
		announcementPanel.currentAnnouncement = this;
		vrButton.DeSelect();
	}

	public void GetTitleSprite(int state, Sprite sprite)
	{
		if (state == 1)
		{
			annouceTitleSprite = sprite;
		}
	}

	public void GetDetailSprite(int state, Sprite sprite)
	{
		if (state == 1)
		{
			annouceDetailSprite = sprite;
		}
	}
}
public class csBannerItem : MonoBehaviour
{
	public BannerType type;

	public Image bannerImg;

	public Button clickBtn;

	public string currentID;

	public string currentImgID;

	public List<string> currentIDList = new List<string>();

	public Image Selectedimg;

	private GameSongData tmpGameSongData;

	public Image BoxingImg;

	public Sprite[] BoxSprite;

	public Image StickImg;

	public Sprite[] StickSprite;

	public Image FollowImg;

	public Sprite[] FollowSprite;

	public csVRButtonInMenu LikeButton;

	public GameObject LikeButtonObject;

	public void setClassBanner(string classID)
	{
		LikeButtonObject.SetActive(value: true);
		type = BannerType.Class;
		currentID = classID;
		if (GameData.instance.GetSongDataByClassID(currentID) != null)
		{
			tmpGameSongData = GameData.instance.GetSongDataByClassID(currentID);
			bannerImg.sprite = csIDImageIconManager.instance.GetImgByID(tmpGameSongData.CoverImgID + "L");
			BoxingImg.gameObject.SetActive(value: false);
			StickImg.gameObject.SetActive(value: false);
			FollowImg.gameObject.SetActive(value: false);
			switch (tmpGameSongData.TypeInHand)
			{
			case csPlayMode.Boxing:
				BoxingImg.gameObject.SetActive(value: true);
				break;
			case csPlayMode.Stick:
				StickImg.gameObject.SetActive(value: true);
				break;
			case csPlayMode.Menu:
				FollowImg.gameObject.SetActive(value: true);
				break;
			}
			BoxingImg.sprite = BoxSprite[(int)tmpGameSongData.Diff];
			StickImg.sprite = StickSprite[(int)tmpGameSongData.Diff];
			FollowImg.sprite = FollowSprite[(int)tmpGameSongData.Diff];
			LikeButton.button.onClick.RemoveAllListeners();
			LikeButton.button.onClick.AddListener(delegate
			{
				SetCollection(IsinCollectionlist(tmpGameSongData.ClassID));
			});
		}
		resetLevelItemLikeState();
	}

	public void setSpColumnBanner(List<string> classIDs, string titleID, string imgID)
	{
		LikeButtonObject.SetActive(value: false);
		type = BannerType.SpColumn;
		currentIDList = classIDs;
		currentImgID = imgID;
		currentID = titleID;
		bannerImg.sprite = csIDImageIconManager.instance.GetImgByID(imgID);
	}

	public void setPlanBanner(string PlanID, Sprite s)
	{
		LikeButtonObject.SetActive(value: true);
		LikeButton.button.onClick.RemoveAllListeners();
		LikeButton.button.onClick.AddListener(delegate
		{
			setPlanToCollection();
		});
		type = BannerType.Plan;
		currentID = PlanID;
		bannerImg.sprite = s;
	}

	private void setPlanToCollection()
	{
		csCloudStorage.instance.SetPlanAsCollection(currentID);
		if (csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(currentID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public void setBrandBanner(string BrandID, Sprite s)
	{
		LikeButtonObject.SetActive(value: false);
		type = BannerType.Brand;
		currentID = BrandID;
		bannerImg.sprite = s;
	}

	public void setTutorialBanner(string TutorialID, Sprite s)
	{
		if (TutorialID != null && !(TutorialID == "Tutorial_Stick"))
		{
			_ = TutorialID == "Tutorial_Box";
		}
		LikeButtonObject.SetActive(value: false);
		type = BannerType.TutorialEnterance;
		currentID = TutorialID;
		bannerImg.sprite = s;
	}

	public void HandleFunc()
	{
		switch (type)
		{
		case BannerType.SpColumn:
			csMainMenuManager.instance.OpenPanel(PanelType.SpColumn);
			csMainMenuManager.instance.planDetailPanel.setPanel(currentImgID, currentID, currentIDList);
			break;
		case BannerType.Brand:
			csLevelChoosePanel.instance.InitClassBoardbyType(1);
			break;
		case BannerType.Class:
			csLevelChoosePanel.instance.InitClassDetailPanel(tmpGameSongData);
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
			csLevelChoosePanel.instance.ShowSelectedItem(this);
			break;
		case BannerType.Plan:
		{
			csMainMenuManager.instance.OpenPanel(PanelType.SpColumn);
			SportPlanData sportPlanData = csCloudSettings.sportPlanDatas.list.Find((SportPlanData x) => x.PlanID == currentID);
			csMainMenuManager.instance.planDetailPanel.setPanel(sportPlanData.ImageID, sportPlanData.NameID, sportPlanData.DetailID, sportPlanData.PlanID, sportPlanData.ClassIDs);
			break;
		}
		case BannerType.TutorialEnterance:
			switch (currentID)
			{
			case "Tutorial_Stick":
				GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataStick);
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.start_tutorial, new Dictionary<string, object>());
				csTalkingData.Instance.SendEvent("JC09", 1.0, null);
				break;
			case "Tutorial_Box":
				GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
				csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.start_tutorial, new Dictionary<string, object>());
				csTalkingData.Instance.SendEvent("JC10", 1.0, null);
				break;
			}
			break;
		}
	}

	private IEnumerator startSearch()
	{
		csSearchManager.instance.SwitchToPanel(ToggleGroupType.Follow);
		yield return null;
		SearchKeywords keyWord = SearchKeywords.superMonkey;
		string text = currentID;
		if (text != null && text == "brand_supermonkey")
		{
			keyWord = SearchKeywords.superMonkey;
		}
		csSearchManager.instance.OnKeyWordClick(keyWord);
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public void SetCollection(bool isSet)
	{
		if (type == BannerType.Class)
		{
			if (!isSet)
			{
				csCloudStorage.instance.SetOrRemoveClassCollection(tmpGameSongData.ClassID, isSet: true);
				LikeButton.OnSelect();
			}
			if (isSet)
			{
				csCloudStorage.instance.SetOrRemoveClassCollection(tmpGameSongData.ClassID, isSet: false);
				LikeButton.DeSelect();
			}
			csMainMenuManager.instance.levelItemActions[currentID]();
			if (csLevelChoosePanel.instance.classDetail.isOpend)
			{
				csLevelChoosePanel.instance.classDetail.resetLevelItemLikeState();
			}
		}
	}

	public void resetLevelItemLikeState()
	{
		if (IsinCollectionlist(currentID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public void OnStartPress()
	{
		if (!csGameSettings.isLoading)
		{
			GameManagerNew.instance.StartGame(tmpGameSongData);
			csCloudStorage.instance.SetClassAsClassHistory(tmpGameSongData.ClassID.ToString(), ClassHistoryState.UnFinished);
			csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
		}
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3);
	}
}
public class csBoxingHelpPopover : MonoBehaviour
{
	public TextMeshProUGUI explainText;

	public VideoPlayer videoPlayer;

	public RawImage videoPlayerRaw;

	public GameObject[] closeObj;

	public List<csVRButtonInMenu> itemBtn = new List<csVRButtonInMenu>();

	public List<HelpItem> helpItems = new List<HelpItem>();

	private bool FirstSet;

	private void Awake()
	{
		videoPlayerRaw = videoPlayer.GetComponent<RawImage>();
	}

	private void OnEnable()
	{
		OnClickItemBtn(2);
	}

	public void OnClickItemBtn(int index)
	{
		if (index < 0 || helpItems.Count == 0 || itemBtn.Count == 0 || index > helpItems.Count - 1 || index > itemBtn.Count - 1)
		{
			return;
		}
		explainText.text = csLocalizationManager.Instance.GetLocalText(helpItems[index].explainID);
		if (explainText.text.Contains("\\n"))
		{
			explainText.text = explainText.text.Replace("\\n", "\n");
		}
		FirstSet = false;
		videoPlayerRaw.color = new Color(1f, 1f, 1f, 0f);
		videoPlayer.clip = helpItems[index].video;
		videoPlayer.Play();
		foreach (csVRButtonInMenu item in itemBtn)
		{
			item.DeSelect();
		}
		itemBtn[index].OnSelect();
	}

	public void Open()
	{
		csLevelChoosePanel.instance.HideTwoSidePanel(isClose: true);
		base.gameObject.SetActive(value: true);
		GameObject[] array = closeObj;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		PlayerPrefs.SetInt("OpenBoxingHelpPopover", 1);
	}

	private void Update()
	{
		videoPlayerRaw.texture = videoPlayer.texture;
		if (!FirstSet && videoPlayer.isPlaying)
		{
			FirstSet = true;
			videoPlayerRaw.color = Color.white;
		}
	}

	public void Close()
	{
		if (!csLevelChoosePanel.instance.classDetail.isOpend)
		{
			csLevelChoosePanel.instance.HideTwoSidePanel(isClose: false);
		}
		base.gameObject.SetActive(value: false);
		GameObject[] array = closeObj;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	private void OnDisable()
	{
		closeObj[closeObj.Length - 1].SetActive(value: true);
	}
}
[Serializable]
public class HelpItem
{
	public VideoClip video;

	public string explainID;
}
public class csBulletinPanel : MonoBehaviour
{
	public static csBulletinPanel instance;

	public float moveLength = 10f;

	public float heightChange;

	public float posY;

	public GameObject ContentTextObj;

	public Button ButtonUpBar;

	public Button ButtonDownBar;

	public float y;

	public float y_p;

	private void Awake()
	{
		instance = this;
		ButtonUpBar.onClick.AddListener(delegate
		{
			posY += moveLength;
		});
		ButtonDownBar.onClick.AddListener(delegate
		{
			posY -= moveLength;
		});
	}

	private void Start()
	{
		StartCoroutine(GetHeightChange());
	}

	private void Update()
	{
		if (posY < 0f)
		{
			posY = 0f;
		}
		if (posY > heightChange)
		{
			posY = heightChange;
		}
		ContentTextObj.GetComponent<RectTransform>().anchoredPosition = new Vector2(5f, posY);
	}

	public IEnumerator GetHeightChange()
	{
		yield return new WaitForEndOfFrame();
		y = ContentTextObj.GetComponent<RectTransform>().sizeDelta.y;
		y_p = ContentTextObj.transform.parent.GetComponent<RectTransform>().sizeDelta.y;
		heightChange = y - y_p;
		posY = 0f;
	}
}
public class csCalDetail : MonoBehaviour
{
	public csVRButtonInMenu showDay;

	public csVRButtonInMenu showWeek;

	public csVRButtonInMenu showMonth;

	public csVRButtonInMenu showCal;

	public csVRButtonInMenu showTime;

	public csVRButtonInMenu showAllType;

	public csVRButtonInMenu showBoxing;

	public csVRButtonInMenu showStick;

	public csVRButtonInMenu showFollow;

	public LineChart chart;

	public BarChart barChart;

	public int defaultDateMode;

	public int defaultType;

	private int currentDateMode;

	private int currentType;

	[Header("默认显示页数 1 本周  2 上周  3 上上周")]
	public int defaulShowIndex = 3;

	public Button pgUpBtn;

	public Button pgDownBtn;

	public TextMeshProUGUI pageText;

	public int currentPageIndex;

	public int maxPageIndex = 3;

	public void changeDateMode(int mode)
	{
		currentDateMode = mode;
		switch (mode)
		{
		case 0:
			showDay.OnSelect();
			showWeek.DeSelect();
			showMonth.DeSelect();
			break;
		case 1:
			showDay.DeSelect();
			showWeek.OnSelect();
			showMonth.DeSelect();
			break;
		case 2:
			showDay.DeSelect();
			showWeek.DeSelect();
			showMonth.OnSelect();
			break;
		}
		ResetPage(currentDateMode, currentType, isReOpen: false);
	}

	public void changePlayType(int type)
	{
		showAllType.DeSelect();
		showBoxing.DeSelect();
		showStick.DeSelect();
		showFollow.DeSelect();
		switch (type)
		{
		case 0:
			showAllType.OnSelect();
			break;
		case 1:
			showBoxing.OnSelect();
			break;
		case 2:
			showStick.OnSelect();
			break;
		case 3:
			showFollow.OnSelect();
			break;
		}
		currentType = type;
		ResetPage(currentDateMode, currentType, isReOpen: false);
	}

	public void setTimeChart(int dateMode, bool isCal)
	{
		csCloudSettings.InitDateTime(delegate
		{
			chart.GetOrAddChartComponent<XAxis>().data.Clear();
			chart.GetOrAddChartComponent<YAxis>().axisName.name = (isCal ? "KCal" : "min");
			chart.series[0].ClearData();
			chart.series[1].ClearData();
			chart.series[2].ClearData();
			List<int> list = new List<int>();
			List<int> list2 = new List<int>();
			List<int> list3 = new List<int>();
			switch (dateMode)
			{
			case 0:
			{
				DateTime time = csCloudSettings.GetNowTime().AddDays(-6.0);
				for (int l = 0; l < 7; l++)
				{
					daySportInfoData careerDataByDate2 = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
					list.Add(0);
					list2.Add(0);
					list3.Add(0);
					if (careerDataByDate2 != null)
					{
						for (int m = 0; m < careerDataByDate2.sportInfoWithMode.Count; m++)
						{
							switch (careerDataByDate2.sportInfoWithMode[m].mode)
							{
							case csPlayMode.Boxing:
								list[l] = (isCal ? ((int)careerDataByDate2.sportInfoWithMode[m].cal) : ((int)careerDataByDate2.sportInfoWithMode[m].playTime));
								break;
							case csPlayMode.Stick:
								list2[l] = (isCal ? ((int)careerDataByDate2.sportInfoWithMode[m].cal) : ((int)careerDataByDate2.sportInfoWithMode[m].playTime));
								break;
							case csPlayMode.Menu:
								list3[l] = (isCal ? ((int)careerDataByDate2.sportInfoWithMode[m].cal) : ((int)careerDataByDate2.sportInfoWithMode[m].playTime));
								break;
							}
						}
						if (!isCal)
						{
							list3[l] = list3[l] / 60 + 1;
							list2[l] = list2[l] / 60 + 1;
							list[l] = list[l] / 60 + 1;
						}
						else
						{
							list3[l] = list3[l] / 1000 + 1;
							list2[l] = list2[l] / 1000 + 1;
							list[l] = list[l] / 1000 + 1;
						}
					}
					chart.AddData(2, list3[l]);
					chart.AddData(1, list2[l]);
					chart.AddData(0, list[l]);
					chart.AddXAxisData(time.Month + "/" + time.Day);
					time = time.AddDays(1.0);
				}
				break;
			}
			case 1:
			{
				int num = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
				if (num < 0)
				{
					num = 6;
				}
				DateTime time = csCloudSettings.GetNowTime().AddDays(-num).AddDays(-20.0);
				for (int i = 0; i < 4; i++)
				{
					list.Add(0);
					list2.Add(0);
					list3.Add(0);
					for (int j = 0; j < 7; j++)
					{
						daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
						if (careerDataByDate != null)
						{
							for (int k = 0; k < careerDataByDate.sportInfoWithMode.Count; k++)
							{
								switch (careerDataByDate.sportInfoWithMode[k].mode)
								{
								case csPlayMode.Boxing:
									list[i] += (isCal ? ((int)careerDataByDate.sportInfoWithMode[k].cal) : ((int)careerDataByDate.sportInfoWithMode[k].playTime));
									break;
								case csPlayMode.Stick:
									list2[i] += (isCal ? ((int)careerDataByDate.sportInfoWithMode[k].cal) : ((int)careerDataByDate.sportInfoWithMode[k].playTime));
									break;
								case csPlayMode.Menu:
									list3[i] += (isCal ? ((int)careerDataByDate.sportInfoWithMode[k].cal) : ((int)careerDataByDate.sportInfoWithMode[k].playTime));
									break;
								}
							}
							if (!isCal)
							{
								list3[i] = list3[i] / 60 + 1;
								list2[i] = list2[i] / 60 + 1;
								list[i] = list[i] / 60 + 1;
							}
							else
							{
								list3[i] = list3[i] / 1000 + 1;
								list2[i] = list2[i] / 1000 + 1;
								list[i] = list[i] / 1000 + 1;
							}
						}
						time = time.AddDays(1.0);
					}
					chart.AddData(0, list[i]);
					chart.AddData(1, list2[i]);
					chart.AddData(2, list3[i]);
					chart.AddXAxisData(time.AddDays(-8.0).Month + "/" + time.AddDays(-8.0).Day + "-" + time.AddDays(-1.0).Month + "/" + time.AddDays(-1.0).Day);
				}
				break;
			}
			}
			chart.enabled = true;
			chart.AnimationFadeIn();
		});
	}

	public void SetBarChart(int dateMode, int type, int pageIndex)
	{
		int myIndex = 4 - pageIndex;
		csCloudSettings.InitDateTime(delegate
		{
			barChart.GetOrAddChartComponent<XAxis>().data.Clear();
			barChart.series[0].ClearData();
			barChart.series[1].ClearData();
			List<daySportInfoData> list = new List<daySportInfoData>();
			List<SportInfoDataWithMode> list2 = new List<SportInfoDataWithMode>();
			List<SportInfoDataWithMode> list3 = new List<SportInfoDataWithMode>();
			List<SportInfoDataWithMode> list4 = new List<SportInfoDataWithMode>();
			switch (dateMode)
			{
			case 0:
			{
				UnityEngine.Debug.Log("===============周趋势:显示日数据====================");
				DateTime time = csCloudSettings.GetNowTime().AddDays(-(7 * myIndex - 1));
				for (int l = 0; l < 7; l++)
				{
					daySportInfoData careerDataByDate2 = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
					list.Add(new daySportInfoData());
					list2.Add(new SportInfoDataWithMode());
					list3.Add(new SportInfoDataWithMode());
					list4.Add(new SportInfoDataWithMode());
					if (careerDataByDate2 != null)
					{
						list[l].cal = Mathf.Ceil(careerDataByDate2.cal / 1000f);
						list[l].playTime = Mathf.Ceil(careerDataByDate2.playTime / 60f);
						for (int m = 0; m < careerDataByDate2.sportInfoWithMode.Count; m++)
						{
							switch (careerDataByDate2.sportInfoWithMode[m].mode)
							{
							case csPlayMode.Boxing:
								list2[l].cal = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].cal / 1000f);
								list2[l].playTime = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].playTime / 60f);
								break;
							case csPlayMode.Stick:
								list3[l].cal = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].cal / 1000f);
								list3[l].playTime = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].playTime / 60f);
								break;
							case csPlayMode.Menu:
								list4[l].cal = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].cal / 1000f);
								list4[l].playTime = Mathf.Ceil(careerDataByDate2.sportInfoWithMode[m].playTime / 60f);
								break;
							}
						}
					}
					switch (type)
					{
					case 0:
						barChart.AddData(0, list[l].cal);
						barChart.AddData(1, list[l].playTime);
						break;
					case 1:
						barChart.AddData(0, list2[l].cal);
						barChart.AddData(1, list2[l].playTime);
						break;
					case 2:
						barChart.AddData(0, list3[l].cal);
						barChart.AddData(1, list3[l].playTime);
						break;
					case 3:
						barChart.AddData(0, list4[l].cal);
						barChart.AddData(1, list4[l].playTime);
						break;
					}
					barChart.AddXAxisData(time.Month + "." + time.Day);
					time = time.AddDays(1.0);
				}
				break;
			}
			case 1:
			{
				UnityEngine.Debug.Log("==========月趋势：显示周数据===========");
				int num4 = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
				if (num4 < 0)
				{
					num4 = 6;
				}
				DateTime time = csCloudSettings.GetNowTime().AddDays(-num4).AddDays(-((6 * myIndex - 1) * 7 - 1));
				for (int n = 0; n < 6; n++)
				{
					list.Add(new daySportInfoData());
					list2.Add(new SportInfoDataWithMode());
					list3.Add(new SportInfoDataWithMode());
					list4.Add(new SportInfoDataWithMode());
					for (int num5 = 0; num5 < 7; num5++)
					{
						daySportInfoData careerDataByDate3 = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
						if (careerDataByDate3 != null)
						{
							list[n].cal += Mathf.Ceil(careerDataByDate3.cal / 1000f);
							list[n].playTime += Mathf.Ceil(careerDataByDate3.playTime / 60f);
							for (int num6 = 0; num6 < careerDataByDate3.sportInfoWithMode.Count; num6++)
							{
								switch (careerDataByDate3.sportInfoWithMode[num6].mode)
								{
								case csPlayMode.Boxing:
									list2[n].cal += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].cal / 1000f);
									list2[n].playTime += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].playTime / 60f);
									break;
								case csPlayMode.Stick:
									list3[n].cal += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].cal / 1000f);
									list3[n].playTime += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].playTime / 60f);
									break;
								case csPlayMode.Menu:
									list4[n].cal += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].cal / 1000f);
									list4[n].playTime += Mathf.Ceil(careerDataByDate3.sportInfoWithMode[num6].playTime / 60f);
									break;
								}
							}
						}
						time = time.AddDays(1.0);
					}
					switch (type)
					{
					case 0:
						barChart.AddData(0, list[n].cal);
						barChart.AddData(1, list[n].playTime);
						break;
					case 1:
						barChart.AddData(0, list2[n].cal);
						barChart.AddData(1, list2[n].playTime);
						break;
					case 2:
						barChart.AddData(0, list3[n].cal);
						barChart.AddData(1, list3[n].playTime);
						break;
					case 3:
						barChart.AddData(0, list4[n].cal);
						barChart.AddData(1, list4[n].playTime);
						break;
					}
					barChart.AddXAxisData(time.AddDays(-8.0).Month + "." + time.AddDays(-8.0).Day + "~" + time.AddDays(-1.0).Month + "." + time.AddDays(-2.0).Day);
				}
				break;
			}
			case 2:
			{
				UnityEngine.Debug.Log("==========年趋势：显示月数据（六个月）===========");
				int num = csCloudSettings.GetNowTime().Month - (6 * myIndex - 1);
				int num2 = csCloudSettings.GetNowTime().Year;
				while (num <= 0)
				{
					num = 12 + num;
					num2--;
				}
				for (int i = 0; i < 6; i++)
				{
					list.Add(new daySportInfoData());
					list2.Add(new SportInfoDataWithMode());
					list3.Add(new SportInfoDataWithMode());
					list4.Add(new SportInfoDataWithMode());
					DateTime time = new DateTime(num2, num, 1);
					int num3 = DateTime.DaysInMonth(num2, num);
					for (int j = 0; j < num3; j++)
					{
						daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
						if (careerDataByDate != null)
						{
							list[i].cal += Mathf.Ceil(careerDataByDate.cal / 1000f);
							list[i].playTime += Mathf.Ceil(careerDataByDate.playTime / 60f);
							for (int k = 0; k < careerDataByDate.sportInfoWithMode.Count; k++)
							{
								switch (careerDataByDate.sportInfoWithMode[k].mode)
								{
								case csPlayMode.Boxing:
									list2[i].cal += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].cal / 1000f);
									list2[i].playTime += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].playTime / 60f);
									break;
								case csPlayMode.Stick:
									list3[i].cal += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].cal / 1000f);
									list3[i].playTime += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].playTime / 60f);
									break;
								case csPlayMode.Menu:
									list4[i].cal += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].cal / 1000f);
									list4[i].playTime += Mathf.Ceil(careerDataByDate.sportInfoWithMode[k].playTime / 60f);
									break;
								}
							}
						}
						time = time.AddDays(1.0);
					}
					switch (type)
					{
					case 0:
						barChart.AddData(0, list[i].cal);
						barChart.AddData(1, list[i].playTime);
						break;
					case 1:
						barChart.AddData(0, list2[i].cal);
						barChart.AddData(1, list2[i].playTime);
						break;
					case 2:
						barChart.AddData(0, list3[i].cal);
						barChart.AddData(1, list3[i].playTime);
						break;
					case 3:
						barChart.AddData(0, list4[i].cal);
						barChart.AddData(1, list4[i].playTime);
						break;
					}
					barChart.AddXAxisData(num2 + "." + num);
					num++;
					if (num > 12)
					{
						num2++;
						num = 1;
					}
				}
				break;
			}
			}
			barChart.enabled = true;
			barChart.AnimationFadeIn();
		});
	}

	public List<daySportInfoData> GetDataOfMonth(int year, int month)
	{
		List<daySportInfoData> list = new List<daySportInfoData>();
		DateTime time = new DateTime(year, month, 1);
		int num = DateTime.DaysInMonth(year, month);
		for (int i = 0; i < num; i++)
		{
			daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
			if (careerDataByDate != null)
			{
				list.Add(careerDataByDate);
			}
			time = time.AddDays(1.0);
		}
		return list;
	}

	public void PageUp()
	{
		if (currentPageIndex != 1)
		{
			pgDownBtn.gameObject.GetComponent<csVRButtonInMenu>().EnableInteractive();
			currentPageIndex--;
			ShowPageByIndex(currentDateMode, currentType, currentPageIndex);
			if (currentPageIndex == 1)
			{
				pgUpBtn.gameObject.GetComponent<csVRButtonInMenu>().DisableInteractive();
			}
		}
	}

	public void PageDown()
	{
		if (currentPageIndex != maxPageIndex)
		{
			pgUpBtn.gameObject.GetComponent<csVRButtonInMenu>().EnableInteractive();
			currentPageIndex++;
			ShowPageByIndex(currentDateMode, currentType, currentPageIndex);
			if (currentPageIndex == maxPageIndex)
			{
				pgDownBtn.gameObject.GetComponent<csVRButtonInMenu>().DisableInteractive();
			}
		}
	}

	public void ShowPageByIndex(int dateMode, int playType, int index)
	{
		pageText.text = string.Format("{0}{1}{2}", currentPageIndex, "/", maxPageIndex);
		SetBarChart(dateMode, playType, index);
	}

	public void ResetPage(int dateMode, int playType, bool isReOpen)
	{
		currentPageIndex = maxPageIndex;
		currentDateMode = dateMode;
		currentType = playType;
		if (isReOpen)
		{
			showDay.OnSelect();
			showWeek.DeSelect();
			showMonth.DeSelect();
			showAllType.OnSelect();
			showBoxing.DeSelect();
			showStick.DeSelect();
			showFollow.DeSelect();
		}
		pgUpBtn.gameObject.GetComponent<csVRButtonInMenu>().EnableInteractive();
		pgDownBtn.gameObject.GetComponent<csVRButtonInMenu>().DisableInteractive();
		ShowPageByIndex(currentDateMode, currentType, currentPageIndex);
	}
}
public class csCheckInSportsDataPanel : MonoBehaviour
{
	public BarChart weekDataBarChart;

	public csVRButtonInMenu personalPlanBtn;

	public csVRButtonInMenu weekDataBtn;

	public GameObject weekDataPanel;

	public csPersonalPlanPanel personalPlanPanel;

	public Button ShowDetailBtn;

	public csMyInformationPanel csMyInformationPanel;

	public TextMeshProUGUI weekCalText;

	public TextMeshProUGUI weekTimeText;

	private int currentTime;

	private int currentCal;

	private List<int> weekTime = new List<int>();

	private List<int> weekCal = new List<int>();

	public void Init()
	{
		personalPlanBtn.OnSelect();
		weekDataBtn.DeSelect();
		weekDataPanel.SetActive(value: false);
		personalPlanPanel.gameObject.SetActive(value: true);
		personalPlanPanel.SetCheckInDaysOfWeek();
	}

	public void OnPersonalPlanBtnClick()
	{
		personalPlanBtn.OnSelect();
		weekDataBtn.DeSelect();
		weekDataPanel.SetActive(value: false);
		personalPlanPanel.gameObject.SetActive(value: true);
	}

	public void OnWeekDataBtnClick()
	{
		personalPlanBtn.DeSelect();
		weekDataBtn.OnSelect();
		weekDataPanel.SetActive(value: true);
		personalPlanPanel.gameObject.SetActive(value: false);
		SetWeekDataBarChart();
	}

	public void OnShowDetailBtnClick()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.MyInformation);
		csMyInformationPanel.CheckOrderToShowDetail();
	}

	public void SetWeekDataBarChart()
	{
		weekTime.Clear();
		weekCal.Clear();
		for (int i = 0; i < weekDataBarChart.series.Count; i++)
		{
			weekDataBarChart.series[i].ClearData();
		}
		csCloudSettings.InitDateTime(delegate
		{
			DateTime nowTime = csCloudSettings.GetNowTime();
			daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(nowTime);
			if (careerDataByDate != null)
			{
				if (careerDataByDate.playTime != float.NaN)
				{
					currentTime = (int)Mathf.Ceil(careerDataByDate.playTime / 60f);
				}
				if (careerDataByDate.cal != float.NaN)
				{
					currentCal = (int)Mathf.Ceil(careerDataByDate.cal / 1000f);
				}
			}
			weekCalText.text = currentCal.ToString();
			weekTimeText.text = currentTime.ToString();
			int num = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
			if (num < 0)
			{
				num = 6;
			}
			DateTime time = csCloudSettings.GetNowTime().AddDays(-num);
			for (int j = 0; j < 7; j++)
			{
				daySportInfoData careerDataByDate2 = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
				if (careerDataByDate2 != null)
				{
					weekCal.Add((int)Mathf.Ceil(careerDataByDate2.cal / 1000f));
					weekTime.Add((int)Mathf.Ceil(careerDataByDate2.playTime / 60f));
				}
				else
				{
					weekCal.Add(0);
					weekTime.Add(0);
				}
				time = time.AddDays(1.0);
			}
			ShowWeekDataBarChart(weekCal, weekTime);
		});
	}

	public void ShowWeekDataBarChart(List<int> cals, List<int> times)
	{
		for (int i = 0; i < weekDataBarChart.series.Count; i++)
		{
			weekDataBarChart.series[i].ClearData();
		}
		for (int j = 0; j < cals.Count; j++)
		{
			weekDataBarChart.AddData(0, cals[j]);
		}
		for (int k = 0; k < times.Count; k++)
		{
			weekDataBarChart.AddData(1, times[k]);
		}
		weekDataBarChart.AnimationFadeIn();
		weekDataBarChart.enabled = true;
	}
}
public class csClassDetailPanel : csPanelBase
{
	public Image ClassImg_selected;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public TextMeshProUGUI ClassDiff;

	public TextMeshProUGUI ClassTime;

	public TextMeshProUGUI ClassCoach;

	public TextMeshProUGUI ClassTypeText;

	public TextMeshProUGUI ClassKcal;

	public Image CoachImg;

	public Image Selectanim;

	public RectTransform DetailRect;

	public GameObject SongDataPrefab;

	public List<csSongDetailItemInDetailPanel> SongDetailItemList = new List<csSongDetailItemInDetailPanel>();

	public Image ClassTypeImage;

	public Image ClassDifImage;

	public Sprite[] ClassEasyTypeSprites;

	public Sprite[] ClassNormalTypeSprites;

	public Sprite[] ClassHardTypeSprites;

	public Sprite[] ClassDifSprites;

	public GameObject LoadingObj;

	public GameObject LoadDoneObj;

	public csIngamePanelLeaderboard LeaderBoardRight;

	public csClassVideoDownloadPanel VideoDownloadPanel;

	public GameSongData CurGameSongData;

	private int AddOnCols = 3;

	private Coroutine DoTweenCor;

	public GameObject SwiftAdjustObj;

	public csVRButtonInMenu SwiftAdjustBtn;

	public csVRButtonInMenu LikeButton;

	private bool ISLiked;

	public void PlaySelectAnimation()
	{
		Selectanim.transform.localScale = Vector3.one;
		Selectanim.color = new Color(1f, 1f, 1f, 0.5f);
		Selectanim.transform.DOScale(Vector3.one * 1.3f, 0.5f);
		Selectanim.GetComponent<Graphic>().DOFade(0f, 0.5f);
	}

	protected override void InitRef()
	{
		base.InitRef();
		LikeButton.button.onClick.AddListener(delegate
		{
			SetCollection(!ISLiked);
		});
	}

	public override void Open()
	{
		base.Open();
		LoadingObj.SetActive(value: true);
		LoadDoneObj.SetActive(value: false);
		resetLevelItemLikeState();
		PlaySelectAnimation();
		LeaderBoardRight.OpenLeaderBoard(isOpen: false);
		if (CurGameSongData.Type == ClassType.Sport || CurGameSongData.Type == ClassType.Mix)
		{
			if (!csGameSettings.IsOfflineVersion)
			{
				LeaderBoardRight.gameObject.SetActive(value: true);
				LeaderBoardRight.InitDataOnlyFetch(CurGameSongData.ClassID);
				LeaderBoardRight.OpenLeaderBoard(isOpen: true);
			}
			SetDetailFromGameSongData();
		}
		else
		{
			SkipLevelDataDownload();
		}
		if (DoTweenCor != null)
		{
			StopCoroutine(DoTweenCor);
		}
		DetailRect.gameObject.GetComponent<ContentSizeFitter>().enabled = true;
		DetailRect.gameObject.GetComponent<VerticalLayoutGroup>().enabled = true;
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		SwiftAdjustObj.SetActive(value: false);
		if (CurGameSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			SwiftAdjustObj.SetActive(value: true);
		}
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDifImage.sprite = ClassDifSprites[0];
			switch (d.Type)
			{
			case ClassType.Sport:
				switch (d.TypeInHand)
				{
				case csPlayMode.Stick:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01C");
					ClassTypeImage.sprite = ClassEasyTypeSprites[0];
					break;
				case csPlayMode.Boxing:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
					ClassTypeImage.sprite = ClassEasyTypeSprites[1];
					break;
				}
				break;
			case ClassType.Mix:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01C");
				ClassTypeImage.sprite = ClassEasyTypeSprites[0];
				break;
			case ClassType.Follow:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01D");
				ClassTypeImage.sprite = ClassEasyTypeSprites[2];
				break;
			case ClassType.Think:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01E");
				ClassTypeImage.sprite = ClassEasyTypeSprites[3];
				break;
			case ClassType.SuperGorilla:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01F");
				ClassTypeImage.sprite = ClassEasyTypeSprites[1];
				break;
			}
			break;
		case Diff.normal:
			ClassDifImage.sprite = ClassDifSprites[1];
			switch (d.Type)
			{
			case ClassType.Sport:
				switch (d.TypeInHand)
				{
				case csPlayMode.Stick:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01C");
					ClassTypeImage.sprite = ClassNormalTypeSprites[0];
					break;
				case csPlayMode.Boxing:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
					ClassTypeImage.sprite = ClassNormalTypeSprites[1];
					break;
				}
				break;
			case ClassType.Mix:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
				ClassTypeImage.sprite = ClassNormalTypeSprites[1];
				break;
			case ClassType.Follow:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01D");
				ClassTypeImage.sprite = ClassNormalTypeSprites[2];
				break;
			case ClassType.Think:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01E");
				ClassTypeImage.sprite = ClassNormalTypeSprites[3];
				break;
			case ClassType.SuperGorilla:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01F");
				ClassTypeImage.sprite = ClassNormalTypeSprites[1];
				break;
			}
			break;
		case Diff.hard:
			ClassDifImage.sprite = ClassDifSprites[2];
			switch (d.Type)
			{
			case ClassType.Sport:
				switch (d.TypeInHand)
				{
				case csPlayMode.Stick:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01C");
					ClassTypeImage.sprite = ClassHardTypeSprites[0];
					break;
				case csPlayMode.Boxing:
					ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
					ClassTypeImage.sprite = ClassHardTypeSprites[1];
					break;
				}
				break;
			case ClassType.Mix:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01B");
				ClassTypeImage.sprite = ClassHardTypeSprites[1];
				break;
			case ClassType.Follow:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01D");
				ClassTypeImage.sprite = ClassHardTypeSprites[2];
				break;
			case ClassType.Think:
				ClassTypeImage.sprite = ClassHardTypeSprites[3];
				break;
			case ClassType.SuperGorilla:
				ClassTypeText.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01F");
				ClassTypeImage.sprite = ClassHardTypeSprites[1];
				break;
			}
			break;
		}
		ClassImg_selected.sprite = csIDImageIconManager.instance.GetImgByID(d.CoverImgID);
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID).Substring(4);
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		int num = d.ClassTotalTime / 60;
		ClassTime.text = num + "min";
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common01");
			break;
		case Diff.normal:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common02");
			break;
		case Diff.hard:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common03");
			break;
		}
		CoachImg.sprite = csIDImageIconManager.instance.GetImgByID(d.CoachImgID);
		ClassCoach.text = d.CaochName;
		int num2 = csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight;
		if (num2 > 150)
		{
			num2 = 150;
		}
		if (num2 < 30)
		{
			num2 = 30;
		}
		ClassKcal.text = $"{(int)(0.92f * (float)num2 * (float)d.ClassTotalTime / 1000f)}kcal";
		VideoDownloadPanel.InitPanelData(CurGameSongData);
	}

	public void SkipLevelDataDownload()
	{
		DetailRect.gameObject.SetActive(value: false);
		LoadingObj.SetActive(value: false);
		LoadDoneObj.SetActive(value: true);
	}

	private void OnLevelDataLoadDone(csMusicPrefabOptmizedData d)
	{
		if (DoTweenCor != null)
		{
			StopCoroutine(DoTweenCor);
		}
		DetailRect.gameObject.GetComponent<ContentSizeFitter>().enabled = true;
		DetailRect.gameObject.GetComponent<VerticalLayoutGroup>().enabled = true;
		DetailRect.gameObject.SetActive(value: true);
		while (SongDetailItemList.Count < d.SingleLevelDataList.Count + AddOnCols)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(SongDataPrefab, DetailRect.transform);
			SongDetailItemList.Add(gameObject.GetComponent<csSongDetailItemInDetailPanel>());
		}
		for (int i = 0; i < SongDetailItemList.Count; i++)
		{
			SongDetailItemList[i].SetSongState(isOn: false);
		}
		for (int j = 0; j < d.SingleLevelDataList.Count + AddOnCols; j++)
		{
			if (j == 0)
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail03"), "", (int)CurGameSongData.WarmUpOrFollowVideoLength);
			}
			else if (j == d.SingleLevelDataList.Count + (AddOnCols - 2))
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail04"), "", (int)CurGameSongData.CoolDownVideoLength);
			}
			else if (j == d.SingleLevelDataList.Count + (AddOnCols - 1))
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail05"), "", CurGameSongData.ClassTotalTime);
			}
			else
			{
				SongDetailItemList[j].SetSongState(isOn: true);
				SongDetailItemList[j].SetSongDetail(d.SingleLevelDataList[j - 1].CurLevelName, d.SingleLevelDataList[j - 1].CurSingerName, d.SingleLevelDataList[j - 1].SongPlayTime);
			}
		}
		DoTweenCor = StartCoroutine(DoTween());
		LoadingObj.SetActive(value: false);
		LoadDoneObj.SetActive(value: true);
	}

	public void AdjustSwift()
	{
		csPlayer.instance.StartSwiftSet();
	}

	private void SetDetailFromGameSongData()
	{
		SwiftAdjustObj.SetActive(value: false);
		if (CurGameSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			SwiftAdjustObj.SetActive(value: true);
		}
		if (DoTweenCor != null)
		{
			StopCoroutine(DoTweenCor);
		}
		DetailRect.gameObject.GetComponent<ContentSizeFitter>().enabled = true;
		DetailRect.gameObject.GetComponent<VerticalLayoutGroup>().enabled = true;
		DetailRect.gameObject.SetActive(value: true);
		List<SingleLevelDataInGameData> gameSongInfoList = CurGameSongData.GameSongInfoList;
		while (SongDetailItemList.Count < gameSongInfoList.Count + AddOnCols)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(SongDataPrefab, DetailRect.transform);
			SongDetailItemList.Add(gameObject.GetComponent<csSongDetailItemInDetailPanel>());
		}
		for (int i = 0; i < SongDetailItemList.Count; i++)
		{
			SongDetailItemList[i].SetSongState(isOn: false);
		}
		for (int j = 0; j < gameSongInfoList.Count + AddOnCols; j++)
		{
			if (j == 0)
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail03"), "", (int)CurGameSongData.WarmUpOrFollowVideoLength);
			}
			else if (j == gameSongInfoList.Count + (AddOnCols - 2))
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail04"), "", (int)CurGameSongData.CoolDownVideoLength);
			}
			else if (j == gameSongInfoList.Count + (AddOnCols - 1))
			{
				SongDetailItemList[j].SetSongState(isOn: true, isSongOnly: true);
				SongDetailItemList[j].SetSongDetail(csLocalizationManager.Instance.GetLocalText("LevelDetail05"), "", CurGameSongData.ClassTotalTime);
			}
			else
			{
				SongDetailItemList[j].SetSongState(isOn: true);
				SongDetailItemList[j].SetSongDetail(gameSongInfoList[j - 1].CurLevelName, gameSongInfoList[j - 1].CurSingerName, gameSongInfoList[j - 1].SongPlayTime);
			}
		}
		DoTweenCor = StartCoroutine(DoTween());
		LoadingObj.SetActive(value: false);
		LoadDoneObj.SetActive(value: true);
	}

	public void resetLevelItemLikeState()
	{
		if (IsinCollectionlist(CurGameSongData.ClassID))
		{
			ISLiked = true;
			LikeButton.OnSelect();
		}
		else
		{
			ISLiked = false;
			LikeButton.DeSelect();
		}
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public void SetCollection(bool isSet)
	{
		if (isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: true);
			LikeButton.OnSelect();
			ISLiked = true;
		}
		else
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(CurGameSongData.ClassID, isSet: false);
			LikeButton.DeSelect();
			ISLiked = false;
		}
		csMainMenuManager.instance.levelItemActions[CurGameSongData.ClassID]();
		for (int i = 0; i < csLevelChoosePanel.instance.RecommandClassLineManager.recInMain.Count; i++)
		{
			if (csLevelChoosePanel.instance.RecommandClassLineManager.recInMain[i].type == BannerType.Class)
			{
				csLevelChoosePanel.instance.RecommandClassLineManager.recInMain[i].resetLevelItemLikeState();
			}
		}
	}

	private void CheckVideoFiles()
	{
	}

	private IEnumerator DoTween()
	{
		yield return new WaitForEndOfFrame();
		float y = DetailRect.sizeDelta.y;
		DetailRect.gameObject.GetComponent<ContentSizeFitter>().enabled = false;
		DetailRect.gameObject.GetComponent<VerticalLayoutGroup>().enabled = false;
		DetailRect.sizeDelta = new Vector2(DetailRect.sizeDelta.x, 304f);
		DetailRect.DOSizeDelta(new Vector2(DetailRect.sizeDelta.x, y), 0.5f);
		foreach (csSongDetailItemInDetailPanel songDetailItem in SongDetailItemList)
		{
			Vector3 localPosition = songDetailItem.gameObject.transform.localPosition;
			songDetailItem.gameObject.transform.localPosition = new Vector3(localPosition.x, -76f, 0f);
			songDetailItem.gameObject.transform.DOLocalMove(localPosition, 0.5f);
		}
	}
}
public class csClassVideoDownloadPanel : MonoBehaviour
{
	private enum PanelDownloadState
	{
		No,
		Downloading,
		Puse,
		Complet
	}

	public Button DownLoadButton;

	public csVRButtonInMenu VRDownloadButton;

	public TextMeshProUGUI DownloadBtnText;

	public GameObject DownLoadingObj;

	public Image Progress;

	public Button PauseBtn;

	public Button StartBtn;

	private GameSongData CurGameSongData;

	private bool VedioFilesExist;

	private bool HaveMision;

	private string ClassID;

	private ClassType classType;

	private List<FollowVideoData> FollowVideoDataList;

	private csClassDownloadData DownloadMision;

	private PanelDownloadState NowState;

	private void Awake()
	{
		DownLoadButton.onClick.AddListener(CreateDownload);
		PauseBtn.onClick.AddListener(StopDownload);
		StartBtn.onClick.AddListener(StartDownload);
	}

	public void InitPanelData(GameSongData songData)
	{
		if (!GameManagerNew.instance.isShowDownload)
		{
			Show(isShow: false);
			return;
		}
		RemoveMisionCallback();
		CurGameSongData = songData;
		ClassID = CurGameSongData.ClassID;
		classType = songData.Type;
		SetFollowVideoDataList();
		VedioFilesExist = CheckVedioFilesExist();
		if (VedioFilesExist)
		{
			SetNowState(PanelDownloadState.Complet);
			return;
		}
		HaveMision = csVedioDownloadManager.instance.CheckClassMision(ClassID);
		SetProgress(0.0);
		if (HaveMision)
		{
			DownloadMision = csVedioDownloadManager.instance.GetClassMisionById(ClassID);
			SetProgress(DownloadMision.GetTotalProgress());
			SetMisionCallback();
		}
		else
		{
			csVedioDownloadManager instance = csVedioDownloadManager.instance;
			instance.classMisionCreateCallback = (Action<string>)Delegate.Combine(instance.classMisionCreateCallback, new Action<string>(CreateMisionCallback));
		}
		RefreshUI();
	}

	private void SetFollowVideoDataList()
	{
		switch (classType)
		{
		case ClassType.Sport:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData3 = new FollowVideoData();
			FollowVideoData followVideoData4 = new FollowVideoData();
			followVideoData3.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData4.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData3);
			FollowVideoDataList.Add(followVideoData4);
			break;
		}
		case ClassType.Mix:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData5 = new FollowVideoData();
			FollowVideoData followVideoData6 = new FollowVideoData();
			followVideoData5.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData6.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData5);
			FollowVideoDataList.Add(followVideoData6);
			break;
		}
		case ClassType.Follow:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int k = 0; k < CurGameSongData.FollowVideoDataList.Count; k++)
			{
				FollowVideoData followVideoData2 = new FollowVideoData();
				followVideoData2.VideoName = CurGameSongData.FollowVideoDataList[k].VideoName;
				followVideoData2.GapTime = CurGameSongData.FollowVideoDataList[k].GapTime;
				followVideoData2.VideoScale = CurGameSongData.FollowVideoDataList[k].VideoScale;
				followVideoData2.VideoOffset = CurGameSongData.FollowVideoDataList[k].VideoOffset;
				followVideoData2.CoachEuler = CurGameSongData.FollowVideoDataList[k].CoachEuler;
				FollowVideoDataList.Add(followVideoData2);
			}
			for (int l = 0; l < FollowVideoDataList.Count; l++)
			{
				FollowVideoDataList[l].VideoName += csCloudSettings.GetClassVideoVersion(ClassID, VideoType.Follow);
			}
			break;
		}
		case ClassType.Think:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData7 = new FollowVideoData();
			FollowVideoData followVideoData8 = new FollowVideoData();
			followVideoData7.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData8.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData7);
			FollowVideoDataList.Add(followVideoData8);
			break;
		}
		case ClassType.SuperGorilla:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int i = 0; i < CurGameSongData.FollowVideoDataList.Count; i++)
			{
				FollowVideoData followVideoData = new FollowVideoData();
				followVideoData.VideoName = CurGameSongData.FollowVideoDataList[i].VideoName;
				followVideoData.GapTime = CurGameSongData.FollowVideoDataList[i].GapTime;
				followVideoData.VideoScale = CurGameSongData.FollowVideoDataList[i].VideoScale;
				followVideoData.VideoOffset = CurGameSongData.FollowVideoDataList[i].VideoOffset;
				followVideoData.CoachEuler = CurGameSongData.FollowVideoDataList[i].CoachEuler;
				FollowVideoDataList.Add(followVideoData);
			}
			for (int j = 0; j < FollowVideoDataList.Count; j++)
			{
				if (ClassID == "300000")
				{
					if (j < 8)
					{
						FollowVideoDataList[j].VideoName += "_V2";
					}
					else
					{
						FollowVideoDataList[j].VideoName += "_V1";
					}
				}
				else if (ClassID == "300001" || ClassID == "300002" || ClassID == "300003" || ClassID == "300004")
				{
					FollowVideoDataList[j].VideoName += "_V2";
				}
				else
				{
					FollowVideoDataList[j].VideoName += "_V1";
				}
			}
			break;
		}
		case ClassType.TutorialPunch:
		case ClassType.TutorialStick:
		case ClassType.TUtorialFollow:
			break;
		}
	}

	private void EnableCheckCallback()
	{
		if ((bool)csVedioDownloadManager.instance)
		{
			HaveMision = csVedioDownloadManager.instance.CheckClassMision(ClassID);
		}
		else
		{
			HaveMision = false;
		}
		if (HaveMision)
		{
			DownloadMision = csVedioDownloadManager.instance.GetClassMisionById(ClassID);
			SetMisionCallback();
		}
	}

	private void Show(bool isShow)
	{
		base.gameObject.SetActive(isShow);
	}

	public void RefreshUI()
	{
		HaveMision = csVedioDownloadManager.instance.CheckClassMision(ClassID);
		if (HaveMision)
		{
			if (DownloadMision.downloadState == DowloadState.Downloading)
			{
				PauseBtn.gameObject.SetActive(value: true);
				StartBtn.gameObject.SetActive(value: false);
				SetNowState(PanelDownloadState.Downloading);
			}
			else
			{
				PauseBtn.gameObject.SetActive(value: false);
				StartBtn.gameObject.SetActive(value: true);
				SetNowState(PanelDownloadState.Puse);
			}
		}
		else
		{
			VedioFilesExist = CheckVedioFilesExist();
			if (VedioFilesExist)
			{
				SetNowState(PanelDownloadState.Complet);
			}
			else
			{
				SetNowState(PanelDownloadState.No);
			}
		}
	}

	public void SetMisionCallback()
	{
		RemoveMisionCallback();
		if (DownloadMision != null)
		{
			csClassDownloadData downloadMision = DownloadMision;
			downloadMision.classMisionProgressCallBack = (Action<double>)Delegate.Combine(downloadMision.classMisionProgressCallBack, new Action<double>(ProgerssCallback));
			csClassDownloadData downloadMision2 = DownloadMision;
			downloadMision2.classMisionCompletCallBack = (Action)Delegate.Combine(downloadMision2.classMisionCompletCallBack, new Action(CompletCallback));
			csClassDownloadData downloadMision3 = DownloadMision;
			downloadMision3.classMisionStartCallBack = (Action)Delegate.Combine(downloadMision3.classMisionStartCallBack, new Action(StartCallback));
		}
	}

	private void RemoveMisionCallback()
	{
		csVedioDownloadManager instance = csVedioDownloadManager.instance;
		instance.classMisionCreateCallback = (Action<string>)Delegate.Remove(instance.classMisionCreateCallback, new Action<string>(CreateMisionCallback));
		if (DownloadMision != null)
		{
			csClassDownloadData downloadMision = DownloadMision;
			downloadMision.classMisionProgressCallBack = (Action<double>)Delegate.Remove(downloadMision.classMisionProgressCallBack, new Action<double>(ProgerssCallback));
			csClassDownloadData downloadMision2 = DownloadMision;
			downloadMision2.classMisionCompletCallBack = (Action)Delegate.Remove(downloadMision2.classMisionCompletCallBack, new Action(CompletCallback));
			csClassDownloadData downloadMision3 = DownloadMision;
			downloadMision3.classMisionStartCallBack = (Action)Delegate.Remove(downloadMision3.classMisionStartCallBack, new Action(StartCallback));
		}
	}

	public void CreateDownload()
	{
		DownloadMision = csVedioDownloadManager.instance.CreateClassMisionDataByID(FollowVideoDataList, ClassID, delegate
		{
		}, delegate
		{
		}, delegate
		{
		});
		if (DownloadMision != null)
		{
			RefreshUI();
			SetMisionCallback();
		}
	}

	private void StartDownload()
	{
		csVedioDownloadManager.instance.StartClassMisionById(ClassID);
		RefreshUI();
	}

	private void StopDownload()
	{
		csVedioDownloadManager.instance.StopClassMision();
		RefreshUI();
	}

	private void CreateMisionCallback(string _ClassID)
	{
		if (!(this == null) && !(_ClassID != ClassID))
		{
			DownloadMision = csVedioDownloadManager.instance.GetClassMisionById(ClassID);
			RefreshUI();
			SetMisionCallback();
		}
	}

	private void StartCallback()
	{
		RefreshUI();
	}

	private void ProgerssCallback(double progress)
	{
		double totalProgress = DownloadMision.GetTotalProgress();
		SetProgress((float)totalProgress);
	}

	private void SetProgress(double progress)
	{
		Progress.fillAmount = (float)progress;
	}

	private void CompletCallback()
	{
		SetNowState(PanelDownloadState.Complet);
	}

	private void OnEnable()
	{
		EnableCheckCallback();
	}

	private void OnDisable()
	{
		RemoveMisionCallback();
	}

	private bool CheckVedioFilesExist()
	{
		bool result = true;
		for (int i = 0; i < FollowVideoDataList.Count; i++)
		{
			if (!csDownloadTools.instance.CheckMP4FileExists(FollowVideoDataList[i].VideoName))
			{
				result = false;
				break;
			}
		}
		return result;
	}

	private PanelDownloadState GetNowState()
	{
		return PanelDownloadState.No;
	}

	private void SetNowState(PanelDownloadState State)
	{
		NowState = State;
		switch (NowState)
		{
		case PanelDownloadState.No:
			DownLoadButton.gameObject.SetActive(value: true);
			DownLoadingObj.SetActive(value: false);
			break;
		case PanelDownloadState.Downloading:
			DownLoadButton.gameObject.SetActive(value: false);
			DownLoadingObj.SetActive(value: true);
			break;
		case PanelDownloadState.Puse:
			DownLoadButton.gameObject.SetActive(value: false);
			DownLoadingObj.SetActive(value: true);
			break;
		case PanelDownloadState.Complet:
			DownLoadButton.gameObject.SetActive(value: true);
			DownLoadingObj.SetActive(value: false);
			break;
		}
		ChangeDownloadButton();
	}

	private void ChangeDownloadButton()
	{
		DownLoadButton.interactable = true;
		VRDownloadButton.enabled = true;
		switch (NowState)
		{
		case PanelDownloadState.No:
			DownloadBtnText.color = new Color(1f, 1f, 1f, 1f);
			DownloadBtnText.text = csLocalizationManager.Instance.GetLocalText("ClassDownloadPanel01");
			break;
		case PanelDownloadState.Downloading:
			DownloadBtnText.text = csLocalizationManager.Instance.GetLocalText("ClassDownloadPanel02");
			break;
		case PanelDownloadState.Puse:
			DownloadBtnText.text = csLocalizationManager.Instance.GetLocalText("ClassDownloadPanel04");
			break;
		case PanelDownloadState.Complet:
			DownloadBtnText.color = new Color(46f / 85f, 46f / 85f, 46f / 85f, 255f);
			DownloadBtnText.text = csLocalizationManager.Instance.GetLocalText("ClassDownloadPanel03");
			DownLoadButton.interactable = false;
			VRDownloadButton.enabled = false;
			break;
		}
	}
}
public class csCommonHintPanel : csPanelBase
{
	public enum BackGroundImageType
	{
		normal,
		bubble
	}

	public enum CenterImageType
	{
		smileFace,
		tearFace,
		setting,
		boxing,
		stick,
		ExclamationMark
	}

	public GameObject OnlyText;

	public GameObject OneBtn;

	public GameObject TwoBtn;

	public GameObject TextWithImage;

	public GameObject ButtonTextObj;

	public GameObject OneBigButtonObj;

	public TextMeshProUGUI TextOnly;

	public TextMeshProUGUI ImageText;

	public Image CenterImage;

	public Image bgImage;

	public Sprite[] bgSprites;

	public Sprite[] CenterImageSprites;

	public Button OneBtnSure;

	public Button TwoBtnSure;

	public Button TwoBtnCancel;

	private Coroutine Timer;

	private CommonHintType CureType;

	private float ShowTime;

	private void OnDisable()
	{
		ResetHint();
	}

	public void ResetHint()
	{
		OnlyText.SetActive(value: false);
		OneBtn.SetActive(value: false);
		TwoBtn.SetActive(value: false);
		TextWithImage.SetActive(value: false);
		ButtonTextObj.SetActive(value: false);
		OneBigButtonObj.SetActive(value: false);
		if (Timer != null)
		{
			StopCoroutine(Timer);
		}
		OneBtnSure.onClick.RemoveAllListeners();
		TwoBtnSure.onClick.RemoveAllListeners();
		TwoBtnCancel.onClick.RemoveAllListeners();
	}

	public void InitNoButtonHint(string Text, float ShowTime, Action CloseCallback)
	{
		ResetHint();
		OnlyText.SetActive(value: true);
		TextOnly.text = Text;
		TextOnly.text = TextOnly.text.Replace("\\n", "\n");
		Timer = StartCoroutine(AutoCloseTimer(ShowTime, CloseCallback));
	}

	public void InitNoButtonImageHint(string Text, Sprite spr, float ShowTime, Action CloseCallback)
	{
		ResetHint();
		TextWithImage.SetActive(value: true);
		ImageText.text = Text;
		ImageText.text = ImageText.text.Replace("\\n", "\n");
		CenterImage.sprite = spr;
		Timer = StartCoroutine(AutoCloseTimer(ShowTime, CloseCallback));
	}

	public void InitOneButtonHint(string Text, string ButtonText, Sprite ButtonSpr, Action SureCallback)
	{
		ResetHint();
		OnlyText.SetActive(value: true);
		OneBtn.SetActive(value: true);
		TextOnly.text = Text;
		TextOnly.text = TextOnly.text.Replace("\\n", "\n");
		SetButton(OneBtnSure, ButtonText, ButtonSpr, SureCallback);
	}

	public void InitOneButtonImageHint(string Text, CenterImageType centerImageType, string ButtonText, Sprite ButtonSpr, Action SureCallback)
	{
		ResetHint();
		TextWithImage.SetActive(value: true);
		OneBtn.SetActive(value: true);
		ImageText.text = Text;
		ImageText.text = ImageText.text.Replace("\\n", "\n");
		SetCenterImage(centerImageType);
		SetButton(OneBtnSure, ButtonText, ButtonSpr, SureCallback);
	}

	public void InitTwoButtonHint(string Text, string SureButtonText, Sprite SureButtonSpr, string CanncelButtonText, Sprite CanncelButtonSpr, Action SureCallback, Action CannelCallback)
	{
		ResetHint();
		OnlyText.SetActive(value: true);
		TwoBtn.SetActive(value: true);
		TextOnly.text = Text;
		TextOnly.text = TextOnly.text.Replace("\\n", "\n");
		SetButton(TwoBtnSure, SureButtonText, SureButtonSpr, SureCallback);
		SetButton(TwoBtnCancel, CanncelButtonText, CanncelButtonSpr, CannelCallback);
	}

	public void InitTwoButtonImageHint(string Text, CenterImageType centerImageType, string SureButtonText, Sprite SureButtonSpr, string CancelButtonText, Sprite CancelButtonSpr, Action SureCallback, Action CannelCallback)
	{
		ResetHint();
		TextWithImage.SetActive(value: true);
		ImageText.text = Text;
		ImageText.text = ImageText.text.Replace("\\n", "\n");
		SetCenterImage(centerImageType);
		TwoBtn.SetActive(value: true);
		SetButton(TwoBtnSure, SureButtonText, SureButtonSpr, SureCallback);
		SetButton(TwoBtnCancel, CancelButtonText, CancelButtonSpr, CannelCallback);
	}

	public void SetBackGroundImage(BackGroundImageType backGroundImageType)
	{
		switch (backGroundImageType)
		{
		case BackGroundImageType.normal:
			bgImage.sprite = bgSprites[0];
			break;
		case BackGroundImageType.bubble:
			bgImage.sprite = bgSprites[1];
			break;
		default:
			bgImage.sprite = bgSprites[0];
			break;
		}
	}

	private void SetCenterImage(CenterImageType centerImageType)
	{
		switch (centerImageType)
		{
		case CenterImageType.smileFace:
			CenterImage.sprite = CenterImageSprites[0];
			break;
		case CenterImageType.tearFace:
			CenterImage.sprite = CenterImageSprites[1];
			break;
		case CenterImageType.setting:
			CenterImage.sprite = CenterImageSprites[2];
			break;
		case CenterImageType.boxing:
			CenterImage.sprite = CenterImageSprites[3];
			break;
		case CenterImageType.stick:
			CenterImage.sprite = CenterImageSprites[4];
			break;
		case CenterImageType.ExclamationMark:
			CenterImage.sprite = CenterImageSprites[5];
			break;
		}
	}

	private void SetButton(Button Btn, string ButtonText, Sprite ButtonSpr, Action Callback)
	{
		TextMeshProUGUI component = Btn.transform.Find("Text").GetComponent<TextMeshProUGUI>();
		if (ButtonSpr != null)
		{
			component.gameObject.SetActive(value: false);
		}
		else
		{
			component.gameObject.SetActive(value: true);
			component.text = ButtonText;
			component.text = component.text.Replace("\\n", "\n");
		}
		Btn.onClick.AddListener(delegate
		{
			Close();
			Callback();
		});
	}

	public new void Close()
	{
		csMainMenuManager.instance.CloseAddOn();
	}

	private IEnumerator AutoCloseTimer(float time, Action closeCallback)
	{
		yield return new WaitForSeconds(time);
		Close();
		closeCallback?.Invoke();
	}
}
public class csDelayedPlayAim : MonoBehaviour
{
	public Animation animation;

	public float time;

	public GameObject[] objects;

	private Coroutine play;

	public void OnEnable()
	{
		if (PlayerPrefs.GetInt("OpenBoxingHelpPopover", 0) != 1)
		{
			if (play != null)
			{
				StopCoroutine(play);
				play = null;
			}
			play = StartCoroutine(Play());
		}
	}

	private IEnumerator Play()
	{
		yield return new WaitForSeconds(time);
		animation.Play();
	}

	public void Stop()
	{
		if (play != null)
		{
			StopCoroutine(play);
			play = null;
		}
		animation.Stop();
		GameObject[] array = objects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		Stop();
	}
}
public class csDeveloperPanel : csPanelBase
{
	public Transform Text;

	public Vector3 InitPosition = new Vector3(0f, -610f, 0f);

	public override void Open()
	{
		base.Open();
		Text.localPosition = InitPosition;
	}

	private void Update()
	{
		Text.Translate(0f, Time.deltaTime * 0.3f, 0f);
		if (Text.localPosition.y > 320f)
		{
			Text.localPosition = InitPosition;
		}
	}
}
public class csDownloadPanel : csPanelBase
{
	public Button StartPlay;

	public Button TutotialButton;

	public Button ExitPlay;

	public TextMeshProUGUI TipsText;

	public List<string> HintTextID = new List<string>();

	public Image DownloadprogressImg;

	public TextMeshProUGUI DownloadprogressText;

	public CanvasGroup leftReminder;

	private Action ExitCallback;

	public GameObject MiniQuitHintObj;

	public Image ClassImg_selected;

	public Image CoachImg;

	public TextMeshProUGUI ClassName;

	public TextMeshProUGUI Classdetail;

	public TextMeshProUGUI ClassTime;

	public TextMeshProUGUI ClassDiff;

	public TextMeshProUGUI ClassCoach;

	public TextMeshProUGUI TutorialText;

	private GameSongData CurGameSongData;

	public CanvasGroup middle;

	public Animator BodyAnimator;

	public Image HintIcon;

	public Sprite SP_Neo3;

	public Sprite SP_Pico4;

	private ClassType classType;

	private List<FollowVideoData> FollowVideoDataList;

	private Coroutine buttonStartAnimation;

	public void SetSliderValue(float v)
	{
		DownloadprogressImg.material.SetFloat("_Progress", v);
		DownloadprogressText.text = (int)(v * 100f) + "%";
	}

	public void InitClassDetail(GameSongData d)
	{
		CurGameSongData = d;
		ClassImg_selected.sprite = csIDImageIconManager.instance.GetImgByID(d.CoverImgID);
		ClassName.text = csLocalizationManager.Instance.GetLocalText(d.ClassTitleID);
		Classdetail.text = csLocalizationManager.Instance.GetLocalText(d.ClassDetailID);
		int num = d.ClassTotalTime / 60;
		ClassTime.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01") + num + "min";
		switch (d.Diff)
		{
		case Diff.easy:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common01");
			break;
		case Diff.normal:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common02");
			break;
		case Diff.hard:
			ClassDiff.text = csLocalizationManager.Instance.GetLocalText("Common03");
			break;
		}
		CoachImg.sprite = csIDImageIconManager.instance.GetImgByID(d.CoachImgID);
		ClassCoach.text = d.CaochName;
		classType = d.Type;
		leftReminder.gameObject.SetActive(value: false);
		StartPlay.gameObject.SetActive(value: true);
		TutotialButton.gameObject.SetActive(value: true);
		TutorialText.text = ((d.TypeInHand == csPlayMode.Boxing) ? csLocalizationManager.Instance.GetLocalText("DownloadPanel20") : csLocalizationManager.Instance.GetLocalText("DownloadPanel21"));
		ExitPlay.gameObject.SetActive(value: true);
		SetFollowVideoDataList();
		buttonStartAnimation = StartCoroutine(ButtonStartAnimation());
	}

	private void SetFollowVideoDataList()
	{
		switch (classType)
		{
		case ClassType.Sport:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData7 = new FollowVideoData();
			FollowVideoData followVideoData8 = new FollowVideoData();
			followVideoData7.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData8.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData7);
			FollowVideoDataList.Add(followVideoData8);
			break;
		}
		case ClassType.Mix:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData5 = new FollowVideoData();
			FollowVideoData followVideoData6 = new FollowVideoData();
			followVideoData5.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData6.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData5);
			FollowVideoDataList.Add(followVideoData6);
			break;
		}
		case ClassType.Follow:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int k = 0; k < CurGameSongData.FollowVideoDataList.Count; k++)
			{
				FollowVideoData followVideoData4 = new FollowVideoData();
				followVideoData4.VideoName = CurGameSongData.FollowVideoDataList[k].VideoName;
				followVideoData4.GapTime = CurGameSongData.FollowVideoDataList[k].GapTime;
				followVideoData4.VideoScale = CurGameSongData.FollowVideoDataList[k].VideoScale;
				followVideoData4.VideoOffset = CurGameSongData.FollowVideoDataList[k].VideoOffset;
				followVideoData4.CoachEuler = CurGameSongData.FollowVideoDataList[k].CoachEuler;
				FollowVideoDataList.Add(followVideoData4);
			}
			for (int l = 0; l < FollowVideoDataList.Count; l++)
			{
				FollowVideoDataList[l].VideoName += csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.Follow);
			}
			TutotialButton.gameObject.SetActive(value: false);
			break;
		}
		case ClassType.Think:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData2 = new FollowVideoData();
			FollowVideoData followVideoData3 = new FollowVideoData();
			followVideoData2.VideoName = CurGameSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.WarmUp);
			followVideoData3.VideoName = CurGameSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData2);
			FollowVideoDataList.Add(followVideoData3);
			break;
		}
		case ClassType.SuperGorilla:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int i = 0; i < CurGameSongData.FollowVideoDataList.Count; i++)
			{
				FollowVideoData followVideoData = new FollowVideoData();
				followVideoData.VideoName = CurGameSongData.FollowVideoDataList[i].VideoName;
				followVideoData.GapTime = CurGameSongData.FollowVideoDataList[i].GapTime;
				followVideoData.VideoScale = CurGameSongData.FollowVideoDataList[i].VideoScale;
				followVideoData.VideoOffset = CurGameSongData.FollowVideoDataList[i].VideoOffset;
				followVideoData.CoachEuler = CurGameSongData.FollowVideoDataList[i].CoachEuler;
				FollowVideoDataList.Add(followVideoData);
			}
			for (int j = 0; j < FollowVideoDataList.Count; j++)
			{
				FollowVideoDataList[j].VideoName += csCloudSettings.GetClassVideoVersion(CurGameSongData.ClassID, VideoType.Follow);
			}
			TutotialButton.gameObject.SetActive(value: false);
			break;
		}
		case ClassType.TutorialPunch:
		case ClassType.TutorialStick:
		case ClassType.TUtorialFollow:
			break;
		}
	}

	private void Update()
	{
		if (isOpend && GameManagerNew.instance.CurPlayer.GetMenuBtnDown())
		{
			ExitGame();
		}
	}

	private void IsAnimation()
	{
		DownloadprogressImg.material = new Material(DownloadprogressImg.material);
		if (CheckVedioFilesExist())
		{
			middle.alpha = 1f;
			DownloadprogressImg.material.SetFloat("_TexAlpha", 1f);
			return;
		}
		BodyAnimator.SetTrigger("IsAnimation");
		middle.alpha = 0f;
		DownloadprogressImg.material.SetFloat("_TexAlpha", 0f);
		middle.DOFade(1f, 0.3f);
		DownloadprogressImg.material.DOFloat(1f, "_TexAlpha", 0.5f);
	}

	private IEnumerator ButtonStartAnimation()
	{
		yield return new WaitForSeconds(5f);
		leftReminder.gameObject.SetActive(value: true);
		BodyAnimator.SetTrigger("IsHint");
	}

	private bool CheckVedioFilesExist()
	{
		bool result = true;
		for (int i = 0; i < FollowVideoDataList.Count; i++)
		{
			if (!csDownloadTools.instance.CheckMP4FileExists(FollowVideoDataList[i].VideoName))
			{
				result = false;
				break;
			}
		}
		return result;
	}

	public void AddExitCallBack(Action exitCb)
	{
		ExitCallback = exitCb;
	}

	public void RemoveExitCallBack()
	{
		ExitCallback = null;
	}

	public void ExitGame()
	{
		if (MiniQuitHintObj.activeSelf)
		{
			StopMiniGame();
			return;
		}
		if (ExitCallback != null)
		{
			ExitCallback();
		}
		RemoveExitCallBack();
	}

	public override void Open()
	{
		base.Open();
		MiniQuitHintObj.SetActive(value: false);
		TipsText.text = csLocalizationManager.Instance.GetLocalText(HintTextID[UnityEngine.Random.Range(0, HintTextID.Count)]);
		TipsText.text = TipsText.text.Replace("\\n", "\n");
		IsAnimation();
		HintIcon.overrideSprite = ((csGameSettings.CurrentDevice == XRDeviceType.PicoNeo3) ? SP_Neo3 : SP_Pico4);
	}

	public override void Open(string msg)
	{
		base.Open();
		switch (msg)
		{
		case "MultiFollow":
			csLevelChoosePanel.instance.playerinfotitle.SetActive(value: false);
			csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
			break;
		default:
			_ = msg == "Sport";
			break;
		case "SoloFollow":
		case "Think":
			break;
		}
		if (CheckVedioFilesExist())
		{
			StartPlay.gameObject.SetActive(value: false);
			ExitPlay.gameObject.SetActive(value: false);
			MiniQuitHintObj.SetActive(value: false);
		}
		else
		{
			MiniQuitHintObj.SetActive(value: false);
		}
		TipsText.text = csLocalizationManager.Instance.GetLocalText(HintTextID[UnityEngine.Random.Range(0, HintTextID.Count)]);
		TipsText.text = TipsText.text.Replace("\\n", "\n");
		HintIcon.overrideSprite = ((csGameSettings.CurrentDevice == XRDeviceType.PicoNeo3) ? SP_Neo3 : SP_Pico4);
		IsAnimation();
	}

	public void EnterTutorial()
	{
		if (CurGameSongData.TypeInHand == csPlayMode.Boxing)
		{
			GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
		}
		if (CurGameSongData.TypeInHand == csPlayMode.Stick)
		{
			GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataStick);
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.start_tutorial, new Dictionary<string, object>());
		csTalkingData.Instance.SendEvent("JC02_加载入口", 1.0, null);
	}

	public override void Close()
	{
		base.Close();
		csLoadingGameManger.instance.StopGame();
	}

	public void StartMiniGame()
	{
		StopCoroutine(buttonStartAnimation);
		MiniQuitHintObj.SetActive(value: true);
		csPlayMode csPlayMode2 = ((UnityEngine.Random.Range(0, 100) <= 50) ? csPlayMode.Stick : csPlayMode.Boxing);
		csLoadingGameManger.instance.StartGame(csPlayMode2);
		if (csGameDataTransfer.playMode == csPlayMode.Boxing || csGameDataTransfer.playMode == csPlayMode.Stick)
		{
			csPlayer.instance.switchController(isSwitchToMenu: false);
		}
		else
		{
			csPlayer.instance.switchControllerWithMode(csPlayMode2);
		}
		csPlayer.instance.pauseUILaser(dontUse: true);
	}

	public void StopMiniGame()
	{
		buttonStartAnimation = StartCoroutine(ButtonStartAnimation());
		csLoadingGameManger.instance.StopGame();
		MiniQuitHintObj.SetActive(value: false);
		csPlayer.instance.switchController(isSwitchToMenu: true);
		csPlayer.instance.pauseUILaser(dontUse: false);
	}
}
public class csFirstLoginPanel : csPanelBase
{
	public GameObject PicoSyncPage;

	public Image headIcon;

	public TextMeshProUGUI PlayerPicoID;

	public TextMeshProUGUI avtarUserName;

	public Image picoAvatar;

	public TMP_InputField age;

	public TMP_InputField height;

	public TMP_InputField weight;

	public GameObject UserAgreementPage;

	public GameObject SportCenterPage;

	public GameObject PlayerInfoPage;

	public GameObject CreateAvatarPage;

	public GameObject LikeTabPage;

	public GameObject VipGetPage;

	public GameObject GuideEntrancePage;

	public TMP_InputField enterNickName;

	public TMP_InputField enterAge;

	public TMP_InputField enterHeight;

	public TMP_InputField enterWeight;

	private List<SearchKeywords> selectedLikeKeys = new List<SearchKeywords>();

	private PlayerInfo curPlayerInfo = new PlayerInfo();

	private PicoAccountInfo playerPicoInfo = new PicoAccountInfo();

	public static bool isGoingtoGuide;

	private bool isGotPicoInfo;

	public csSNTool1 SNTool;

	private bool getSprotCenter;

	public csFirstLoginVipReward RewardStepPanel;

	private void Start()
	{
		enterNickName.keyboardType = (TouchScreenKeyboardType)(-1);
		enterAge.keyboardType = (TouchScreenKeyboardType)(-1);
		enterHeight.keyboardType = (TouchScreenKeyboardType)(-1);
		enterWeight.keyboardType = (TouchScreenKeyboardType)(-1);
	}

	public override void Open()
	{
		base.Open();
		PlayerPicoID.text = csLogin.instance.username;
		avtarUserName.text = csLogin.instance.username;
		curPlayerInfo.PlayerName = csLogin.instance.username;
		StartCoroutine(welcomeToFitAll());
	}

	public void CloseGame()
	{
		csTalkingData.Instance.SendEvent("DL04_隐私政策", 1.0, new Dictionary<string, object> { { "是否同意", "否，退出应用" } });
		Application.Quit();
	}

	public void openURLUserAgreement()
	{
		Application.OpenURL(csGameSettings.UserAgreementUrl);
	}

	public void openURLPravicyPolicy()
	{
		Application.OpenURL(csGameSettings.PravicyPolicyUrl);
	}

	private IEnumerator getPicoInfo()
	{
		if (csGameSettings.CurrentDevice == XRDeviceType.Pico4)
		{
			bool GetSNCallback = false;
			if (string.IsNullOrEmpty(SystemInfo.deviceUniqueIdentifier) || string.IsNullOrEmpty(csLogin.instance.userid))
			{
				csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(csLocalizationManager.Instance.GetLocalText("DisconnectPanel05"), csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					Application.Quit();
				});
				csMainMenuManager.instance.OpenPanel(PanelType.CommonHint);
			}
			else
			{
				RewardStepPanel.Init(isUnactivaedPico4: false);
				GetSNCallback = true;
			}
			while (!GetSNCallback)
			{
				yield return null;
			}
		}
		else
		{
			RewardStepPanel.Init(isUnactivaedPico4: false);
		}
		yield return null;
		isGotPicoInfo = true;
	}

	public IEnumerator welcomeToFitAll()
	{
		csLevelChoosePanel.instance.playerinfotitle.SetActive(value: false);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
		StartCoroutine(getPicoInfo());
		while (!isGotPicoInfo)
		{
			yield return null;
		}
		PicoSyncPage.SetActive(value: true);
		PicoSyncPage.GetComponent<CanvasGroup>().alpha = 0f;
		PicoSyncPage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
	}

	public void PicoSyncContinue()
	{
		curPlayerInfo.PlayerName = PlayerPicoID.text;
		PicoSyncPage.SetActive(value: false);
		UserAgreementPage.SetActive(value: true);
		UserAgreementPage.transform.DOScale(0f, 0.6f).From();
		csTalkingData.Instance.SendEvent("DL01_欢迎", 1.0, null);
	}

	public void AgreeUseragreement()
	{
		UserAgreementPage.SetActive(value: false);
		GotoSportCenterSkipAvatar();
		csTalkingData.Instance.SendEvent("DL04_隐私政策", 1.0, new Dictionary<string, object> { { "是否同意", "是，继续下一步" } });
	}

	public void GotoSportCenter()
	{
		SportCenterPage.SetActive(value: false);
		CreateAvatarPage.SetActive(value: true);
		CreateAvatarPage.GetComponent<CanvasGroup>().alpha = 0f;
		CreateAvatarPage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
	}

	public void GotoSportCenterSkipAvatar()
	{
		SportCenterPage.SetActive(value: false);
		PlayerInfoPage.SetActive(value: true);
		PlayerInfoPage.GetComponent<CanvasGroup>().alpha = 0f;
		PlayerInfoPage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
	}

	public void getAndSetPicoPlayerInfo()
	{
	}

	public void selectBoy()
	{
		curPlayerInfo.isMale = true;
	}

	public void selectGirl()
	{
		curPlayerInfo.isMale = false;
	}

	public void createAvatarPageContinue()
	{
		CreateAvatarPage.SetActive(value: false);
		PlayerInfoPage.SetActive(value: true);
		PlayerInfoPage.GetComponent<CanvasGroup>().alpha = 0f;
		PlayerInfoPage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
		csTalkingData.Instance.SendEvent("DL02_昵称化身", 1.0, null);
	}

	public void PlayerInfoContinue()
	{
		if (int.TryParse(weight.text, out curPlayerInfo.weight) && int.TryParse(height.text, out curPlayerInfo.height))
		{
			int.TryParse(age.text, out curPlayerInfo.Age);
		}
		PlayerInfoPage.SetActive(value: false);
		LikeTabPage.SetActive(value: true);
		LikeTabPage.GetComponent<CanvasGroup>().alpha = 0f;
		LikeTabPage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
		csTalkingData.Instance.SendEvent("DL03_健康数据", 1.0, null);
	}

	public void LikeTabPageContinueToVipAward()
	{
		LikeTabPageContinue();
	}

	public void TryGetPlayerVip()
	{
		RewardStepPanel.TryGetVipFree();
	}

	public void LikeTabPageContinue()
	{
		LikeTabPage.SetActive(value: false);
		VipGetPage.SetActive(value: false);
		GuideEntrancePage.SetActive(value: true);
		GuideEntrancePage.GetComponent<CanvasGroup>().alpha = 0f;
		GuideEntrancePage.GetComponent<CanvasGroup>().DOFade(1f, 1f);
		if (csLikeTabPageMan.isSelectStyle)
		{
			csTalkingData.Instance.SendEvent("DL05_运动偏好", 1.0, new Dictionary<string, object> { { "是否选择偏爱的风格", "是" } });
		}
		else
		{
			csTalkingData.Instance.SendEvent("DL05_运动偏好", 1.0, new Dictionary<string, object> { { "是否选择偏爱的风格", "否" } });
		}
	}

	public void EnterGuideScene()
	{
		isGoingtoGuide = true;
		startGame();
		GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
		csTalkingData.Instance.SendEvent("JC01_登陆入口", 1.0, null);
	}

	public void startGame()
	{
		csCloudStorage.instance.m_PlayerInfoInPlayfab.isMale = curPlayerInfo.isMale;
		csCloudStorage.instance.m_PlayerInfoInPlayfab.Age = curPlayerInfo.Age;
		csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight = curPlayerInfo.weight;
		csCloudStorage.instance.m_PlayerInfoInPlayfab.Height = curPlayerInfo.height;
		csCloudStorage.instance.m_PlayerInfoInPlayfab.NickName = curPlayerInfo.PlayerName;
		csCloudStorage.instance.UpdateNickName(curPlayerInfo.PlayerName, delegate(bool result, string error)
		{
			if (result)
			{
				csLogin.instance.StartCoroutine(CompleteRegister());
				csPlayfabServer.Instance.GetPlayerProfile_NameTag(delegate(string CurrentName)
				{
					if (string.IsNullOrEmpty(CurrentName))
					{
						csPlayfabServer.Instance.AddPlayerTag("Name:" + curPlayerInfo.PlayerName);
					}
					else
					{
						UnityEngine.Debug.LogError("ReNameWithTag:");
						csPlayfabServer.Instance.ReNameWithTag(CurrentName, "Name:" + curPlayerInfo.PlayerName);
					}
				});
			}
		});
		if (!isGoingtoGuide)
		{
			csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: true);
			csLevelChoosePanel.instance.tagsx5.SetActive(value: true);
		}
		else
		{
			csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
			{
			});
		}
		csMainMenuManager.instance.ClosePanel();
	}

	private IEnumerator CompleteRegister()
	{
		int process = 0;
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		selectedLikeKeys = LikeTabPage.GetComponent<csLikeTabPageMan>().selectedTabNames;
		csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs = selectedLikeKeys;
		dictionary.Add("PlayerInfoInPlayfab", JsonUtility.ToJson(csCloudStorage.instance.m_PlayerInfoInPlayfab));
		dictionary.Add("PicoAccountInfoInPlayfab", JsonUtility.ToJson(playerPicoInfo));
		dictionary.Add("PlayerPlayInfoInPlayfab", JsonUtility.ToJson(new playerPlayInfo()));
		dictionary.Add("PlayerClassHistoryData", JsonUtility.ToJson(new PlayerClassHistoryData()));
		dictionary.Add("PlayerClockInData", JsonUtility.ToJson(new clockInData()));
		dictionary.Add("PlayerPlanData", JsonUtility.ToJson(new PlayerPlanDataInPlayFab()));
		dictionary.Add("PlayerCareerData", JsonUtility.ToJson(new daySportInfoDataInPlayfab()));
		dictionary.Add("PlayerOrderData", csPlayerOrderManager.instance.EncodeOrderData(csCloudStorage.instance.m_PlayerOrderData));
		dictionary.Add("PlayerAllTimeBeheaviorData", JsonUtility.ToJson(new PlayerAllTimeBeheaviorData()));
		dictionary.Add("PlayerClassScoreData", JsonUtility.ToJson(new PlayerClassScoreData()));
		dictionary.Add("PlayerDailyGoalData", JsonUtility.ToJson(new PlayerDailyGoalData()));
		csPlayfabServer.Instance.SetDefaultData(dictionary, delegate
		{
			process++;
		});
		while (process < 1)
		{
			yield return new WaitForEndOfFrame();
		}
		csLogin.instance.Restart();
	}
}
public class PlayerInfo
{
	public string PlayerName;

	public bool isMale = true;

	public int Age;

	public int weight;

	public int height;
}
public class csFirstLoginVipReward : MonoBehaviour
{
	public TextMeshProUGUI TitleTxt;

	public TextMeshProUGUI TitleTxtSuccess;

	public TextMeshProUGUI ContentTxt;

	public TextMeshProUGUI ContentTxtSuccess;

	public GameObject GetBtn;

	public GameObject LoadingBtn;

	public csFirstLoginPanel firstLogin;

	private bool isPico4Player;

	public GameObject tryGet;

	public GameObject SuccessGet;

	public Animator animator;

	public void Init(bool isUnactivaedPico4)
	{
		if (isUnactivaedPico4)
		{
			isPico4Player = true;
			TitleTxt.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel24");
			ContentTxt.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel25");
			TitleTxtSuccess.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel26");
			ContentTxtSuccess.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel27");
			TitleTxt.text = TitleTxt.text.Replace("\\n", "\n");
			ContentTxt.text = ContentTxt.text.Replace("\\n", "\n");
			TitleTxtSuccess.text = TitleTxtSuccess.text.Replace("\\n", "\n");
			ContentTxtSuccess.text = ContentTxtSuccess.text.Replace("\\n", "\n");
		}
		else
		{
			isPico4Player = false;
			TitleTxt.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel24");
			ContentTxt.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel28");
			TitleTxtSuccess.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel26");
			ContentTxtSuccess.text = csLocalizationManager.Instance.GetLocalText("FirstLoginPanel29");
			TitleTxt.text = TitleTxt.text.Replace("\\n", "\n");
			ContentTxt.text = ContentTxt.text.Replace("\\n", "\n");
			TitleTxtSuccess.text = TitleTxtSuccess.text.Replace("\\n", "\n");
			ContentTxtSuccess.text = ContentTxtSuccess.text.Replace("\\n", "\n");
		}
		GetBtn.SetActive(value: true);
		LoadingBtn.SetActive(value: false);
		tryGet.SetActive(value: true);
		SuccessGet.SetActive(value: false);
	}

	public void TryGetVipFree()
	{
		GetBtn.SetActive(value: false);
		LoadingBtn.SetActive(value: true);
		csPlayerOrderManager.instance.AddCallBackAction(OnVipGetSuccess, OnVipGetFailed);
		csPlayerOrderManager.instance.GetFreeFirstOrder(isPico4Player);
	}

	public void OnVipGetSuccess()
	{
		csPlayerOrderManager.instance.RemoveCallBackAction(OnVipGetSuccess, OnVipGetFailed);
		GetSuccess();
	}

	public void OnVipGetFailed()
	{
		csPlayerOrderManager.instance.RemoveCallBackAction(OnVipGetSuccess, OnVipGetFailed);
		GetBtn.SetActive(value: true);
		LoadingBtn.SetActive(value: false);
	}

	public void GetSuccess()
	{
		tryGet.SetActive(value: false);
		SuccessGet.SetActive(value: true);
		animator.SetBool("Play", value: true);
	}
}
public class csFriendPanel : csPanelBase
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class csInputKeyboardButton : MonoBehaviour
{
	public TMP_InputField inputField;

	private Button button;

	public bool isNumber;

	public bool scopeLimitation;

	public int minValue;

	public int maxValue;

	private void Awake()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Keyboard/InputButton"), base.transform) as GameObject;
		button = gameObject.GetComponent<Button>();
		button.onClick.AddListener(OpenKeyBoard);
	}

	private void Start()
	{
		RectTransform component = inputField.transform.GetComponent<RectTransform>();
		button.transform.GetComponent<RectTransform>().sizeDelta = component.sizeDelta;
	}

	private void OpenKeyBoard()
	{
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.VRKeyboard);
		csMainMenuManager.instance.GetKeyboardPanel().AddInpunt(inputField, isNumber, scopeLimitation, minValue, maxValue);
	}

	private void CloseKeyBoard()
	{
		csMainMenuManager.instance.CloseAddOn();
	}

	private void OnDisable()
	{
		CloseKeyBoard();
	}
}
public class csKeyboardPanel : csPanelBase
{
	public KeyboardManager keyboardManager;

	private TMP_InputField inputField;

	private bool isNumber;

	private bool scopeLimitation;

	private int minValue;

	private int maxValue;

	public void AddInpunt(TMP_InputField input, bool isNumber, bool scopeLimitation, int minValue, int maxValue)
	{
		inputField = input;
		this.isNumber = isNumber;
		this.scopeLimitation = scopeLimitation;
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	public void OnEnterClick()
	{
		if (isNumber)
		{
			if (int.TryParse(keyboardManager.inputText.text, out var result))
			{
				if (scopeLimitation)
				{
					if (result < minValue)
					{
						result = minValue;
					}
					else if (result > maxValue)
					{
						result = maxValue;
					}
				}
				inputField.text = result.ToString();
			}
			else
			{
				inputField.text = "";
			}
		}
		else
		{
			inputField.text = keyboardManager.inputText.text;
		}
		keyboardManager.Clear();
		csMainMenuManager.instance.CloseAddOn();
	}
}
public class csLayoutGroupPanel : MonoBehaviour
{
	public List<GameObject> objectsChild = new List<GameObject>();

	public GameObject Title;

	public bool isFolding;

	public Transform FoldingButtonT;

	public RectTransform BKGRect;

	public float MinSizeY = 78f;

	private float OriSizeY = 78f;

	private void Start()
	{
		for (int i = 0; i < base.transform.childCount; i++)
		{
			if (base.transform.GetChild(i).gameObject.activeInHierarchy)
			{
				objectsChild.Add(base.transform.GetChild(i).gameObject);
			}
		}
		OriSizeY = BKGRect.sizeDelta.y;
		objectsChild.Remove(Title);
	}

	public void FoldingPanel()
	{
		if (isFolding)
		{
			for (int i = 0; i < objectsChild.Count; i++)
			{
				objectsChild[i].SetActive(value: true);
			}
			BKGRect.sizeDelta = new Vector2(BKGRect.sizeDelta.x, OriSizeY);
			isFolding = !isFolding;
			FoldingButtonT.rotation = Quaternion.Euler(Vector3.zero);
		}
		else
		{
			for (int j = 0; j < objectsChild.Count; j++)
			{
				objectsChild[j].SetActive(value: false);
			}
			BKGRect.sizeDelta = new Vector2(BKGRect.sizeDelta.x, MinSizeY);
			isFolding = !isFolding;
			FoldingButtonT.rotation = Quaternion.Euler(0f, 0f, -90f);
		}
	}
}
public class csLeaderBoardHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public GameObject MyinfoHoverPanel;

	public void OnPointerEnter(PointerEventData eventData)
	{
		MyinfoHoverPanel.gameObject.SetActive(value: true);
		MyinfoHoverPanel.transform.DOScale(1f, 0.2f);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		MyinfoHoverPanel.transform.DOScale(0f, 0.2f);
	}
}
public class csLevelChoosePanel : csPanelBase
{
	public enum LevelGroupType
	{
		BoxLevels,
		StickLevels,
		SportLevels,
		SuperGrolia,
		Follow,
		FreeLevels,
		Thinking,
		AddOnLevels,
		Mix,
		SwiftLevels,
		AlphaTestLevels,
		Pamela
	}

	public static csLevelChoosePanel instance;

	public csRecommandInMainMgr RecommandClassLineManager;

	public Dictionary<LevelGroupType, csLoadClassLine> NormalClassLineDic = new Dictionary<LevelGroupType, csLoadClassLine>();

	public GameObject ClassLinePrefab;

	public Transform ClassLineGroupT;

	public GameObject LevelPrefab;

	public Button Settings_Btn;

	public Button HeadBtn;

	public GameObject UnsearchPanel;

	public GameObject SearchingPanel;

	public Transform SerachingParent;

	public GameObject SpColPanel;

	public Transform SpColParent;

	public Transform AddOnParent;

	public List<csLevelItem> SearchingList = new List<csLevelItem>();

	public List<csLevelItem> SearchingList_All = new List<csLevelItem>();

	public GameObject AnnouncementPanelGO;

	public GameObject LevelchoosePanelGO;

	public GameObject CheatPanelGO;

	public List<csLevelItem> SpColList = new List<csLevelItem>();

	public List<csLevelItem> SpColList_All = new List<csLevelItem>();

	public GameObject PageIcon;

	private List<csPageDotInLevelChoose> IconList = new List<csPageDotInLevelChoose>();

	public List<csLevelItem> LevelList_Rec = new List<csLevelItem>();

	public List<csLevelItem> LevelList_Sport = new List<csLevelItem>();

	public string ClassIDToPlay;

	public csLevelItem curSelectedItem;

	public csBannerItem currentBannerItem;

	public Slider HeightSlider;

	public TextMeshProUGUI HeightT;

	public List<string> RecListID;

	public List<string> SportListID;

	public List<string> BoxingListID;

	public List<string> StickListID;

	public List<string> SuperGroliaID;

	public List<string> FollowID;

	public GameObject playerinfotitle;

	public GameObject tagsx5;

	public GameObject ToBeContinueObj;

	public csClassDetailPanel classDetail;

	public Animator animator;

	public csAnnouncementPanel announcementPanel;

	public GameObject sportsEntertainment;

	public GameObject followCourse;

	public GameObject returnToMainBtn;

	public GameObject downPanel;

	public List<GameObject> classLineList;

	public Animation middleAnimationClip;

	public csIngamePanelScoreRank scoreRankPanel;

	public TextMeshProUGUI middleTitle;

	public RectTransform middleTitleImage;

	public GameObject returnToSecondBtn;

	public GameObject tutorialBtn;

	public GameObject boxingHelpHelpBtn;

	public GameObject boxingHelpHelpPanel;

	public csCheckInSportsDataPanel csChinkInSportsDataPanel;

	private GameObject BoxLevelsFree;

	public Animation ThridPanelAnim;

	public csPageUpdownMain NormalPageMan;

	public GameObject FreePlayHintO;

	public bool isBannerOpen;

	public csPageUpdownMain searchingPageMan;

	public TextMeshProUGUI SpColText;

	public Image TitleImage;

	public Sprite[] TitleSprites;

	public csPageUpdownMain spColPageMan;

	public Button SpcolReturnBtn;

	public GameObject LoadingObj;

	public TextMeshProUGUI todayTime;

	public TextMeshProUGUI todayCal;

	public TextMeshProUGUI weeklyCal;

	public GameObject secondPanel;

	public GameObject sportsEntertainmentItemPanel;

	public GameObject followCourseItemPanel;

	private bool isEntertainType;

	public GameObject BtnAnimateEntertain;

	public GameObject BtnAnimateFollow;

	public GameObject BtnAnimateSecPunch;

	public GameObject BtnAnimateSecStick;

	public GameObject BtnAnimateSecKeep;

	public GameObject BtnAnimateSecSM;

	public csClassVideoDownloadPanel csClassVideoDownloadPanel;

	private int CurEntertainBoardbyType;

	public GameObject LeftSportDataPanel;

	public GameObject personalPlanPanel;

	public GameObject personalPlanPanelBody;

	protected override void InitRef()
	{
		base.InitRef();
		instance = this;
		OnSetHeightValue(PlayerPrefs.GetInt("Height", 170));
		HeightSlider.value = (float)(PlayerPrefs.GetInt("Height", 170) - 150) / 50f;
		HeightSlider.onValueChanged.AddListener(delegate(float x)
		{
			OnSetHeightValue(x * 50f + 150f);
		});
		Settings_Btn.onClick.AddListener(OpenSettingsPanel);
		HeadBtn.onClick.AddListener(OpenMyPanel);
		SpcolReturnBtn.onClick.AddListener(ReturnFromSpCol);
		SearchingList.Clear();
		StartCoroutine(InitData());
		middleTitle.text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel01");
		csCloudSettings.AnnoucementLoadSuccessAct = (UnityAction<List<AnnouncementItem>>)Delegate.Combine(csCloudSettings.AnnoucementLoadSuccessAct, new UnityAction<List<AnnouncementItem>>(announcementPanel.InitClassDetail));
	}

	private void OnDestroy()
	{
		csCloudSettings.AnnoucementLoadSuccessAct = (UnityAction<List<AnnouncementItem>>)Delegate.Remove(csCloudSettings.AnnoucementLoadSuccessAct, new UnityAction<List<AnnouncementItem>>(announcementPanel.InitClassDetail));
	}

	private IEnumerator InitData()
	{
		UnsearchPanel.SetActive(value: false);
		LoadingObj.SetActive(value: true);
		while (csLogin.instance == null || !csLogin.instance.isGetPlayfabData)
		{
			yield return null;
		}
		UnsearchPanel.SetActive(value: true);
		BtnAnimateEntertain.SetActive(value: false);
		BtnAnimateFollow.SetActive(value: false);
		LoadingObj.SetActive(value: false);
		SetPagePanel(isOpen: false);
		RecommandClassLineManager.InitRecommandClassInMain();
		RefreshByOrderData();
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
		csPlayerOrderManager.instance.RemoveCallBackAction(RefreshByOrderData, RefreshByOrderData);
	}

	public void RefreshByOrderData()
	{
		playerinfotitle.GetComponent<csPlayerInfoPanel>().ShowOrderIcon(csPlayerOrderManager.instance.IsOrdering());
	}

	public void InitClassDetailPanel(GameSongData d)
	{
		classDetail.InitClassDetail(d);
		scoreRankPanel.gameObject.SetActive(value: false);
	}

	public void SetPageTo(LevelGroupType gt)
	{
	}

	public void OpenSettingsPanel()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.Settings);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{5:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.Main_Settings.ToString()
			}
		});
	}

	public void OpenMyPanel()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.HeadDetail);
	}

	public override void Open()
	{
		base.Open();
		GoBackToMain();
		isBannerOpen = false;
		tagsx5.SetActive(value: true);
		playerinfotitle.SetActive(value: true);
		setSportData();
		csTagsMgr.instance.setSelect(csTagsMgr.instance.ExploreBtn);
		animator.Play("mainPanelEnter", 0);
		if (!(csLogin.instance == null) && csLogin.instance.isGetPlayfabData)
		{
			ShowSpcolPanel(isShow: false);
		}
		if (PlayerPrefs.GetInt(csLogin.instance.userid + "FreeHint", 0) == 0)
		{
			PlayerPrefs.SetInt(csLogin.instance.userid + "FreeHint", 1);
			FreePlayHintO.SetActive(value: true);
		}
		if (Time.realtimeSinceStartup - csLogin.tokenT > 3600f)
		{
			csLogin.tokenT = Time.realtimeSinceStartup;
			csPlayfabServer.Instance.RefreshToken();
		}
	}

	public void ConfirmFreePlayHint()
	{
		FreePlayHintO.SetActive(value: false);
		animator.Play("mainPanelEnter", 0);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{1:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.Announcement_BoxConfirm.ToString()
			}
		});
	}

	public void GetLeaderboardAct()
	{
	}

	public void StartGame()
	{
		if (!PlayerPrefs.HasKey("PunchTutorialDone") && curSelectedItem.ItemSongData.TypeInHand == csPlayMode.Boxing)
		{
			PlayerPrefs.SetInt("PunchTutorialDone", 1);
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			csMainMenuManager.instance.commonHintPanel.InitTwoButtonImageHint(csLocalizationManager.Instance.GetLocalText("TutorialEntranceHint01"), csCommonHintPanel.CenterImageType.boxing, csLocalizationManager.Instance.GetLocalText("Common10"), null, csLocalizationManager.Instance.GetLocalText("Common09"), null, csTutorialEntranceManager.instance.EnterPunchTutorial, delegate
			{
				csMainMenuManager.instance.commonHintPanel.Close();
				csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
				csMainMenuManager.instance.commonHintPanel.InitOneButtonImageHint(csLocalizationManager.Instance.GetLocalText("TutorialEntranceHint03"), csCommonHintPanel.CenterImageType.setting, csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					csMainMenuManager.instance.commonHintPanel.Close();
					InitClassDetailPanel(curSelectedItem.ItemSongData);
					csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
					ShowSelectedItem(curSelectedItem);
				});
			});
		}
		else if (!PlayerPrefs.HasKey("StickTutorialDone") && curSelectedItem.ItemSongData.TypeInHand == csPlayMode.Stick)
		{
			PlayerPrefs.SetInt("StickTutorialDone", 1);
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			string localText = csLocalizationManager.Instance.GetLocalText("TutorialEntranceHint02");
			csMainMenuManager.instance.commonHintPanel.InitTwoButtonImageHint(localText, csCommonHintPanel.CenterImageType.stick, csLocalizationManager.Instance.GetLocalText("Common10"), null, csLocalizationManager.Instance.GetLocalText("Common09"), null, csTutorialEntranceManager.instance.EnterStickTutorial, delegate
			{
				csMainMenuManager.instance.commonHintPanel.Close();
				csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
				csMainMenuManager.instance.commonHintPanel.InitOneButtonImageHint(csLocalizationManager.Instance.GetLocalText("TutorialEntranceHint03"), csCommonHintPanel.CenterImageType.setting, csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					csMainMenuManager.instance.commonHintPanel.Close();
					InitClassDetailPanel(curSelectedItem.ItemSongData);
					csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
					ShowSelectedItem(curSelectedItem);
				});
			});
		}
		else if (!curSelectedItem.CheckCanStartGame())
		{
			csPlayerOrderManager.instance.ShowShopTip(csLocalizationManager.Instance.GetLocalText("PlayerOrder19"));
		}
		else
		{
			DetailNormalStartGame();
		}
	}

	private void DetailNormalStartGame()
	{
		if (!isBannerOpen)
		{
			curSelectedItem.OnStartPress();
		}
		else
		{
			currentBannerItem.OnStartPress();
		}
		if ((bool)currentBannerItem)
		{
			currentBannerItem.Selectedimg.enabled = false;
		}
		if ((bool)curSelectedItem)
		{
			curSelectedItem.Selectedimg.enabled = false;
		}
		tagsx5.SetActive(value: false);
	}

	public void ShowSelectedItem(csBannerItem item)
	{
		isBannerOpen = true;
		currentBannerItem = item;
		for (int i = 0; i < SearchingList.Count; i++)
		{
			SearchingList[i].Selectedimg.enabled = false;
		}
		foreach (csLoadClassLine value in NormalClassLineDic.Values)
		{
			for (int j = 0; j < value.ListInMain.Count; j++)
			{
				value.ListInMain[j].Selectedimg.enabled = false;
			}
		}
		currentBannerItem.Selectedimg.enabled = true;
	}

	public void ShowSelectedItem(csLevelItem item)
	{
		isBannerOpen = false;
		curSelectedItem = item;
		for (int i = 0; i < SearchingList.Count; i++)
		{
			SearchingList[i].Selectedimg.enabled = false;
			SearchingList[i].itemBtn.SetActive(value: false);
		}
		foreach (csLoadClassLine value in NormalClassLineDic.Values)
		{
			for (int j = 0; j < value.ListInMain.Count; j++)
			{
				value.ListInMain[j].Selectedimg.enabled = false;
				value.ListInMain[j].itemBtn.SetActive(value: false);
			}
		}
		for (int k = 0; k < csMainMenuManager.instance.myInformationPanel.CollectionList_All.Count; k++)
		{
			csMainMenuManager.instance.myInformationPanel.CollectionList_All[k].Selectedimg.enabled = false;
			csMainMenuManager.instance.myInformationPanel.CollectionList_All[k].itemBtn.SetActive(value: false);
		}
		for (int l = 0; l < csMainMenuManager.instance.myInformationPanel.HisList_All.Count; l++)
		{
			csMainMenuManager.instance.myInformationPanel.HisList_All[l].Selectedimg.enabled = false;
			csMainMenuManager.instance.myInformationPanel.HisList_All[l].itemBtn.SetActive(value: false);
		}
		for (int m = 0; m < csMainMenuManager.instance.planDetailPanel.levelItems.Count; m++)
		{
			csMainMenuManager.instance.planDetailPanel.levelItems[m].Selectedimg.enabled = false;
			csMainMenuManager.instance.planDetailPanel.levelItems[m].itemBtn.SetActive(value: false);
		}
		for (int n = 0; n < SpColList_All.Count; n++)
		{
			SpColList_All[n].Selectedimg.enabled = false;
			SpColList_All[n].startBtn.SetActive(value: false);
			SpColList_All[n].itemBtn.SetActive(value: false);
		}
		curSelectedItem.Selectedimg.enabled = true;
		curSelectedItem.itemBtn.SetActive(value: true);
	}

	public void ApplySearchKeywordList(ToggleGroupType tg, List<SearchKeywords> kwl)
	{
		if (kwl.Count > 0)
		{
			ShowSearchPanel(isShow: true);
			SearchingList.Clear();
			for (int j = 0; j < kwl.Count; j++)
			{
				switch (kwl[j])
				{
				case SearchKeywords.Boxing:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.TypeInHand == csPlayMode.Boxing && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
					break;
				case SearchKeywords.Stick:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.TypeInHand == csPlayMode.Stick && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
					break;
				case SearchKeywords.Follow:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.Type == ClassType.Follow && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
					break;
				case SearchKeywords.Think:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.Type == ClassType.Think && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
					break;
				case SearchKeywords.DifEasy:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.Diff == Diff.easy));
					break;
				case SearchKeywords.DifHard:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.Diff == Diff.hard));
					break;
				case SearchKeywords.DifNormal:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.Diff == Diff.normal));
					break;
				case SearchKeywords.KeepFit:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.KeepFit)));
					break;
				case SearchKeywords.LossWeight:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.LossWeight)));
					break;
				case SearchKeywords.MakeBody:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.MakeBody)));
					break;
				case SearchKeywords.Timelessten:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassTotalTime <= 600));
					break;
				case SearchKeywords.Timetentofifteen:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassTotalTime >= 600 && s.ItemSongData.ClassTotalTime < 900));
					break;
				case SearchKeywords.Timemore:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassTotalTime >= 900));
					break;
				case SearchKeywords.superMonkey:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.SuperMonkey)));
					break;
				case SearchKeywords.Keep:
					SearchingList.AddRange(SearchingList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.Keep)));
					break;
				}
			}
			switch (tg)
			{
			case ToggleGroupType.Follow:
				SearchingList = SearchingList.FindAll((csLevelItem x) => x.ItemSongData.Type == ClassType.Follow);
				break;
			case ToggleGroupType.Thinking:
				SearchingList = SearchingList.FindAll((csLevelItem x) => x.ItemSongData.Type == ClassType.Think);
				break;
			case ToggleGroupType.Training:
				SearchingList = SearchingList.FindAll((csLevelItem x) => x.ItemSongData.Type == ClassType.Sport);
				break;
			}
			SearchingList = SearchingList.Where((csLevelItem x, int i) => SearchingList.FindIndex((csLevelItem n) => n.ItemSongData.ClassID == x.ItemSongData.ClassID) == i).ToList();
			for (int k = 0; k < SearchingList_All.Count; k++)
			{
				SearchingList_All[k].gameObject.SetActive(value: false);
			}
			for (int l = 0; l < SearchingList.Count; l++)
			{
				SearchingList[l].gameObject.SetActive(value: true);
			}
			searchingPageMan.Totalpage = SearchingList.Count / 12 + ((SearchingList.Count % 12 != 0) ? 1 : 0);
			searchingPageMan.SetToPage(0);
		}
		else
		{
			ShowSearchPanel(isShow: false);
		}
	}

	private void ShowSearchPanel(bool isShow)
	{
		if (isShow)
		{
			UnsearchPanel.SetActive(value: false);
			SearchingPanel.SetActive(value: true);
			csSearchManager.instance.BtnDeleteAll.gameObject.SetActive(value: true);
		}
		else
		{
			UnsearchPanel.SetActive(value: true);
			BtnAnimateEntertain.SetActive(value: false);
			BtnAnimateFollow.SetActive(value: false);
			SearchingPanel.SetActive(value: false);
			csSearchManager.instance.BtnDeleteAll.gameObject.SetActive(value: false);
		}
	}

	public void ApplySpColKeyword(LevelGroupType tg, string colName)
	{
		ShowSpcolPanel(isShow: true);
		SpColList.Clear();
		ToBeContinueObj.SetActive(value: false);
		SpColText.text = colName;
		TitleImage.enabled = true;
		switch (tg)
		{
		case LevelGroupType.BoxLevels:
			TitleImage.sprite = TitleSprites[0];
			break;
		case LevelGroupType.StickLevels:
			TitleImage.sprite = TitleSprites[1];
			break;
		case LevelGroupType.SportLevels:
			TitleImage.sprite = TitleSprites[2];
			break;
		case LevelGroupType.SuperGrolia:
			TitleImage.sprite = TitleSprites[3];
			break;
		case LevelGroupType.Follow:
			TitleImage.sprite = TitleSprites[4];
			break;
		case LevelGroupType.FreeLevels:
			TitleImage.sprite = TitleSprites[5];
			break;
		case LevelGroupType.Thinking:
			TitleImage.sprite = TitleSprites[6];
			break;
		case LevelGroupType.AddOnLevels:
			TitleImage.enabled = false;
			break;
		case LevelGroupType.AlphaTestLevels:
		case LevelGroupType.Pamela:
			TitleImage.enabled = false;
			break;
		}
		switch (tg)
		{
		case LevelGroupType.Follow:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.Type == ClassType.Follow && s.ItemSongData.ClassFeatures.Contains(ClassFeature.Keep) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
			if (SpColList.Count > 3 && SpColList[0].ItemSongData.ClassID == "200001")
			{
				SpColList[0].transform.SetAsLastSibling();
				SpColList[1].transform.SetAsLastSibling();
				SpColList[2].transform.SetAsLastSibling();
			}
			break;
		case LevelGroupType.FreeLevels:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.PayType == ClassPayType.Free && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AddOn) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
			break;
		case LevelGroupType.SportLevels:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.Type == ClassType.Sport && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AddOn) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
			break;
		case LevelGroupType.BoxLevels:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.TypeInHand == csPlayMode.Boxing && s.ItemSongData.Type != ClassType.Mix && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AddOn) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
			break;
		case LevelGroupType.StickLevels:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.TypeInHand == csPlayMode.Stick && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AddOn) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)));
			break;
		case LevelGroupType.AlphaTestLevels:
			switch (csGameSettings.profile.CurrentReleaseType)
			{
			case ReleaseType.BetaTest:
				SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.Abdomen)));
				break;
			case ReleaseType.DevTest:
				SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.Pamela)));
				break;
			}
			break;
		case LevelGroupType.Pamela:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.AlphaTestLevels) && s.ItemSongData.ClassFeatures.Contains(ClassFeature.Pamela)));
			break;
		case LevelGroupType.SuperGrolia:
			SpColList.AddRange(SpColList_All.FindAll((csLevelItem s) => s.ItemSongData.ClassFeatures.Contains(ClassFeature.SuperMonkey) && !s.ItemSongData.ClassFeatures.Contains(ClassFeature.AddOn)));
			if (SpColList.Count > 3 && SpColList[0].ItemSongData.ClassID == "200001")
			{
				SpColList[0].transform.SetAsLastSibling();
				SpColList[1].transform.SetAsLastSibling();
				SpColList[2].transform.SetAsLastSibling();
			}
			break;
		case LevelGroupType.AddOnLevels:
			ToBeContinueObj.SetActive(value: true);
			break;
		}
		for (int i = 0; i < SpColList_All.Count; i++)
		{
			SpColList_All[i].gameObject.SetActive(value: false);
		}
		for (int j = 0; j < SpColList.Count; j++)
		{
			SpColList[j].gameObject.SetActive(value: true);
		}
		spColPageMan.Totalpage = SpColList.Count / 8 + ((SpColList.Count % 8 != 0) ? 1 : 0);
		spColPageMan.SetToPage(0);
	}

	public void ShowSpcolPanel(bool isShow)
	{
		if (isShow)
		{
			UnsearchPanel.SetActive(value: false);
			SpColPanel.SetActive(value: true);
			tagsx5.SetActive(value: false);
			playerinfotitle.gameObject.SetActive(value: false);
		}
		else
		{
			UnsearchPanel.SetActive(value: true);
			SpColPanel.SetActive(value: false);
			tagsx5.SetActive(value: true);
			playerinfotitle.gameObject.SetActive(value: true);
		}
	}

	public void ReturnFromSpCol()
	{
		ShowSpcolPanel(isShow: false);
		downPanel.SetActive(value: false);
	}

	private IEnumerator Start()
	{
		csPlayerOrderManager.instance.AddCallBackAction(RefreshByOrderData, RefreshByOrderData);
		while (GameData.instance.SongLevelData == null || csCloudSettings.VersionedVVersionData == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		LevelList_Rec.Clear();
		for (int j = 0; j < GameData.instance.SongLevelData.Count; j++)
		{
			if (GameData.instance.SongLevelData[j].Type != ClassType.SuperGorilla)
			{
				csLevelItem component = UnityEngine.Object.Instantiate(LevelPrefab, SpColParent).GetComponent<csLevelItem>();
				component.IntiSongData(GameData.instance.SongLevelData[j], "AllClassColumn", -1, sendevent: false);
				SpColList_All.Add(component);
				yield return new WaitForEndOfFrame();
			}
		}
		for (int j = 0; j < GameData.instance.AddOnSongLevelData.Count; j++)
		{
			csLevelItem LevelItem = UnityEngine.Object.Instantiate(LevelPrefab, SpColParent).GetComponent<csLevelItem>();
			LevelItem.IntiSongData(GameData.instance.AddOnSongLevelData[j], "PlayerCustom", -1, sendevent: false);
			yield return new WaitForEndOfFrame();
			SpColList_All.Add(LevelItem);
		}
	}

	private void OnSetHeightValue(float Height)
	{
		csGameSettings.CenterHolePos = new Vector3(0f, Height / 100f - 0.4f, 0f);
		HeightT.text = ((int)Height).ToString();
		PlayerPrefs.SetInt("Height", (int)Height);
	}

	private void setSportData()
	{
		csCloudSettings.InitDateTime(delegate
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			int num4 = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
			if (num4 < 0)
			{
				num4 = 6;
			}
			DateTime nowTime = csCloudSettings.GetNowTime();
			daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(nowTime);
			if (careerDataByDate != null)
			{
				if (careerDataByDate.cal != float.NaN)
				{
					num3 = careerDataByDate.cal;
				}
				if (careerDataByDate.playTime != float.NaN)
				{
					num = careerDataByDate.playTime;
				}
			}
			nowTime = nowTime.AddDays(-num4);
			for (int i = 0; i < 7; i++)
			{
				daySportInfoData careerDataByDate2 = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(nowTime);
				if (careerDataByDate2 != null && careerDataByDate2.cal != float.NaN)
				{
					num2 += careerDataByDate2.cal;
				}
				nowTime = nowTime.AddDays(1.0);
			}
			todayTime.text = ((int)num / 60).ToString();
			todayCal.text = ((int)Math.Ceiling(num3 / 1000f)).ToString();
			weeklyCal.text = ((int)(num2 / 1000f)).ToString();
		});
	}

	public void InitClassBoardbyType(int enterType)
	{
		classLineList = new List<GameObject>();
		StartCoroutine(SecondPanelOpenAnimate(enterType));
		if (enterType == 0)
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
			{
				{
					"button_id",
					$"ButtonTracking_{3:000}"
				},
				{
					"button_name",
					ButtonTrackingClick.Main_Sports.ToString()
				}
			});
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.enter_page, new Dictionary<string, object>
			{
				{
					"page_name",
					type.ToString()
				},
				{ "page_status", "SportsPage" }
			});
		}
		else
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
			{
				{
					"button_id",
					$"ButtonTracking_{4:000}"
				},
				{
					"button_name",
					ButtonTrackingClick.Main_Follow.ToString()
				}
			});
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.enter_page, new Dictionary<string, object>
			{
				{
					"page_name",
					type.ToString()
				},
				{ "page_status", "FollowPage" }
			});
		}
	}

	private IEnumerator SecondPanelOpenAnimate(int enterType)
	{
		csGameSettings.isLoading = true;
		if (enterType == 0)
		{
			BtnAnimateEntertain.SetActive(value: true);
		}
		else
		{
			BtnAnimateFollow.SetActive(value: true);
		}
		yield return new WaitForSeconds(0.2f);
		if (enterType == 0)
		{
			sportsEntertainmentItemPanel.gameObject.SetActive(value: true);
			followCourseItemPanel.gameObject.SetActive(value: false);
			isEntertainType = true;
		}
		else
		{
			sportsEntertainmentItemPanel.gameObject.SetActive(value: false);
			followCourseItemPanel.gameObject.SetActive(value: true);
			isEntertainType = false;
		}
		RecommandClassLineManager.gameObject.SetActive(value: false);
		sportsEntertainment.SetActive(value: false);
		followCourse.SetActive(value: false);
		downPanel.SetActive(value: false);
		returnToMainBtn.SetActive(value: true);
		middleAnimationClip.Play();
		switch (enterType)
		{
		case 0:
			middleTitle.text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel60");
			break;
		case 1:
			middleTitle.text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel62");
			break;
		}
		middleTitleImage.GetComponent<csImagePositionSet>().SetPostion();
		BtnAnimateEntertain.SetActive(value: false);
		BtnAnimateFollow.SetActive(value: false);
		secondPanel.gameObject.SetActive(value: true);
		csGameSettings.isLoading = false;
	}

	private IEnumerator ThirdPanelOpenAnimate(int type)
	{
		csGameSettings.isLoading = true;
		if (type == 0)
		{
			BtnAnimateSecPunch.SetActive(value: true);
		}
		else
		{
			BtnAnimateSecStick.SetActive(value: true);
		}
		yield return new WaitForSeconds(0.05f);
		ThridPanelAnim.Play();
		ButtonTrackingClick trackingClick = ButtonTrackingClick.None;
		string page = "";
		CurEntertainBoardbyType = type;
		switch (type)
		{
		case 0:
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(ClassLinePrefab, ClassLineGroupT);
			NormalClassLineDic.Add(LevelGroupType.BoxLevels, gameObject2.GetComponent<csLoadClassLine>());
			NormalClassLineDic[LevelGroupType.BoxLevels].InitClassLineInMain(GameData.instance.SongLevelData.FindAll((GameSongData x) => x.TypeInHand == csPlayMode.Boxing && x.Type != ClassType.SuperGorilla && !x.ClassFeatures.Contains(ClassFeature.AlphaTestLevels) && x.Type != ClassType.Mix && !x.ClassFeatures.Contains(ClassFeature.AddOn)), csLocalizationManager.Instance.GetLocalText("LevelMenuPanel10"), LevelGroupType.BoxLevels);
			classLineList.Add(gameObject2);
			boxingHelpHelpBtn.SetActive(value: true);
			trackingClick = ButtonTrackingClick.Main_Sports_Boxing;
			page = "Sports_BoxingPage";
			break;
		}
		case 1:
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(ClassLinePrefab, ClassLineGroupT);
			NormalClassLineDic.Add(LevelGroupType.StickLevels, gameObject.GetComponent<csLoadClassLine>());
			NormalClassLineDic[LevelGroupType.StickLevels].InitClassLineInMain(GameData.instance.SongLevelData.FindAll((GameSongData x) => x.TypeInHand == csPlayMode.Stick && !x.ClassFeatures.Contains(ClassFeature.AlphaTestLevels)), csLocalizationManager.Instance.GetLocalText("LevelMenuPanel11"), LevelGroupType.StickLevels);
			classLineList.Add(gameObject);
			trackingClick = ButtonTrackingClick.Main_Sports_Stick;
			page = "Sports_StickPage";
			break;
		}
		}
		yield return new WaitForSeconds(0.15f);
		sportsEntertainmentItemPanel.gameObject.SetActive(value: false);
		returnToMainBtn.SetActive(value: false);
		returnToSecondBtn.SetActive(value: true);
		tutorialBtn.SetActive(value: true);
		NormalPageMan.Totalpage = (int)Math.Ceiling(1.0 * (double)NormalClassLineDic.Count / 2.0);
		NormalPageMan.SetToPage(0);
		BtnAnimateSecPunch.SetActive(value: false);
		BtnAnimateSecStick.SetActive(value: false);
		csGameSettings.isLoading = false;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{(int)trackingClick:000}"
			},
			{
				"button_name",
				trackingClick.ToString()
			}
		});
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.enter_page, new Dictionary<string, object>
		{
			{ "page_name", "LevelChoose" },
			{ "page_status", page }
		});
	}

	public void GetEntertainClassBoardbyType(int type)
	{
		StartCoroutine(ThirdPanelOpenAnimate(type));
	}

	private IEnumerator ThirdPanelOpenAnimateFollow(int type)
	{
		csGameSettings.isLoading = true;
		if (type == 0)
		{
			BtnAnimateSecSM.SetActive(value: true);
		}
		else
		{
			BtnAnimateSecKeep.SetActive(value: true);
		}
		yield return new WaitForSeconds(0.05f);
		ThridPanelAnim.Play();
		GameData.instance.SongLevelData.FindAll((GameSongData x) => x.Type == ClassType.Follow);
		ButtonTrackingClick trackingClick = ButtonTrackingClick.None;
		string page = "";
		switch (type)
		{
		case 0:
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(ClassLinePrefab, ClassLineGroupT);
			NormalClassLineDic.Add(LevelGroupType.SuperGrolia, gameObject2.GetComponent<csLoadClassLine>());
			List<GameSongData> sdList = GameData.instance.SongLevelData.FindAll((GameSongData x) => x.Type == ClassType.Follow && x.ClassFeatures.Contains(ClassFeature.SuperMonkey));
			NormalClassLineDic[LevelGroupType.SuperGrolia].InitClassLineInMain(sdList, csLocalizationManager.Instance.GetLocalText("LevelMenuPanel13"), LevelGroupType.SuperGrolia);
			classLineList.Add(gameObject2);
			trackingClick = ButtonTrackingClick.Main_Follow_Super;
			page = "Follow_SuperPage";
			break;
		}
		case 1:
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(ClassLinePrefab, ClassLineGroupT);
			NormalClassLineDic.Add(LevelGroupType.Follow, gameObject.GetComponent<csLoadClassLine>());
			List<GameSongData> sdList = GameData.instance.SongLevelData.FindAll((GameSongData x) => x.ClassFeatures.Contains(ClassFeature.Keep));
			NormalClassLineDic[LevelGroupType.Follow].InitClassLineInMain(sdList, csLocalizationManager.Instance.GetLocalText("LevelMenuPanel12"), LevelGroupType.Follow);
			classLineList.Add(gameObject);
			trackingClick = ButtonTrackingClick.Main_Follow_Follow;
			page = "Follow_FollowPage";
			break;
		}
		}
		returnToMainBtn.SetActive(value: false);
		yield return new WaitForSeconds(0.15f);
		returnToSecondBtn.SetActive(value: true);
		followCourseItemPanel.gameObject.SetActive(value: false);
		BtnAnimateSecSM.SetActive(value: false);
		BtnAnimateSecKeep.SetActive(value: false);
		NormalPageMan.Totalpage = (int)Math.Ceiling(1.0 * (double)NormalClassLineDic.Count / 2.0);
		NormalPageMan.SetToPage(0);
		csGameSettings.isLoading = false;
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{(int)trackingClick:000}"
			},
			{
				"button_name",
				trackingClick.ToString()
			}
		});
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.enter_page, new Dictionary<string, object>
		{
			{ "page_name", "LevelChoose" },
			{ "page_status", page }
		});
	}

	public void GetFollowCourseIClassBoardbyType(int type)
	{
		StartCoroutine(ThirdPanelOpenAnimateFollow(type));
	}

	public void GoBackToMain()
	{
		NormalPageMan.SetPageWithoutDOT(0);
		NormalPageMan.Totalpage = 1;
		for (int num = classLineList.Count - 1; num >= 0; num--)
		{
			GameObject obj = classLineList[num];
			classLineList.RemoveAt(num);
			UnityEngine.Object.Destroy(obj);
		}
		NormalClassLineDic.Clear();
		csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
		if (!csGameSettings.IsOfflineVersion)
		{
			scoreRankPanel.gameObject.SetActive(value: true);
		}
		SetPagePanel(isOpen: false);
		returnToMainBtn.SetActive(value: false);
		RecommandClassLineManager.gameObject.SetActive(value: false);
		AnnouncementPanelGO.SetActive(value: true);
		LeftSportDataPanel.SetActive(value: true);
		csChinkInSportsDataPanel.Init();
		sportsEntertainment.SetActive(value: true);
		followCourse.SetActive(value: true);
		downPanel.SetActive(value: true);
		secondPanel.gameObject.SetActive(value: false);
		returnToSecondBtn.SetActive(value: false);
		tutorialBtn.SetActive(value: false);
		boxingHelpHelpBtn.SetActive(value: false);
		boxingHelpHelpPanel.SetActive(value: false);
		BtnAnimateEntertain.SetActive(value: false);
		BtnAnimateFollow.SetActive(value: false);
		middleTitle.text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel01");
		middleTitleImage.GetComponent<csImagePositionSet>().ResetPostion();
	}

	public void GoToAlphaTestLevels()
	{
		ApplySpColKeyword(LevelGroupType.AlphaTestLevels, "测试关");
	}

	public void GoToAlphaPamelaLevels()
	{
		ApplySpColKeyword(LevelGroupType.Pamela, "测试关");
	}

	public void SetPagePanel(bool isOpen)
	{
		NormalPageMan.PageDownBtn.gameObject.SetActive(isOpen);
		NormalPageMan.PageUpBtn.gameObject.SetActive(isOpen);
		NormalPageMan.PageDetail.gameObject.SetActive(isOpen);
	}

	public void OnReturnToSecondBtnClick()
	{
		NormalPageMan.SetPageWithoutDOT(0);
		NormalPageMan.Totalpage = 1;
		for (int num = classLineList.Count - 1; num >= 0; num--)
		{
			GameObject obj = classLineList[num];
			classLineList.RemoveAt(num);
			UnityEngine.Object.Destroy(obj);
		}
		NormalClassLineDic.Clear();
		csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
		if (!csGameSettings.IsOfflineVersion)
		{
			scoreRankPanel.gameObject.SetActive(value: true);
		}
		SetPagePanel(isOpen: false);
		if (isEntertainType)
		{
			sportsEntertainmentItemPanel.gameObject.SetActive(value: true);
		}
		else
		{
			followCourseItemPanel.gameObject.SetActive(value: true);
		}
		AnnouncementPanelGO.SetActive(value: true);
		LeftSportDataPanel.SetActive(value: true);
		returnToMainBtn.SetActive(value: true);
		returnToSecondBtn.SetActive(value: false);
		tutorialBtn.SetActive(value: false);
		boxingHelpHelpBtn.SetActive(value: false);
	}

	public void OnTutorialBtnClick()
	{
		switch (CurEntertainBoardbyType)
		{
		case 0:
			GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
			csTalkingData.Instance.SendEvent("JC10", 1.0, null);
			break;
		case 1:
			GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataStick);
			csTalkingData.Instance.SendEvent("JC09", 1.0, null);
			break;
		}
	}

	public void HideLeftPanels()
	{
		AnnouncementPanelGO.SetActive(value: false);
		LeftSportDataPanel.SetActive(value: false);
	}

	public void HideTwoSidePanel(bool isClose)
	{
		playerinfotitle.SetActive(!isClose);
		AnnouncementPanelGO.SetActive(!isClose);
		LeftSportDataPanel.SetActive(!isClose);
		scoreRankPanel.gameObject.SetActive(!isClose);
	}
}
public class csLevelChooseSuperMonkey : csPanelBase
{
	public static csLevelChooseSuperMonkey instance;

	public csClassDetailPanel classDetail;

	private GameSongData curSongData;

	public csSuperMonkeyItem[] SelItems;

	public csClassVideoDownloadPanel OneBtnDownloadMgr;

	public GameSongData AllVideoData;

	protected override void InitRef()
	{
		base.InitRef();
		instance = this;
	}

	private void Start()
	{
		OneBtnDownloadMgr.InitPanelData(AllVideoData);
	}

	public void InitClassDetailPanel(GameSongData d)
	{
		classDetail.InitClassDetail(d);
		curSongData = d;
	}

	public void StartGame()
	{
		GameManagerNew.instance.StartGame(curSongData);
	}

	public void ClearSelected()
	{
		csSuperMonkeyItem[] selItems = SelItems;
		for (int i = 0; i < selItems.Length; i++)
		{
			selItems[i].ShowSelected(isShow: false);
		}
	}
}
public class csLevelItem : MonoBehaviour
{
	public Transform root;

	public GameSongData ItemSongData;

	public Image bgImage;

	public Sprite[] bgSprites;

	public TextMeshProUGUI SongNameText;

	public TextMeshProUGUI CoachText;

	public TextMeshProUGUI TimeText;

	private csLevelChoosePanel ParentChoosePanel;

	public Image Selectedimg;

	public Image BoxingImg;

	public Image StickImg;

	public Image FollowImg;

	public TextMeshProUGUI diffText;

	public TextMeshProUGUI diffText_shadow;

	public Image diffImg;

	public Sprite[] diffImgSprites;

	public Image SelectanimImg;

	public Image CoachHeadIcon;

	public csVRButtonInMenu LikeButton;

	public bool isCollected;

	public Sprite[] DownloadSprs;

	public GameObject DownloadIconObj;

	public Image DownloadShowImage;

	public GameObject DownloadShowObj;

	public GameObject downloadJiantou;

	public GameObject puseObj;

	public GameObject downloadBgObj;

	public GameObject freeIconObj;

	public GameObject orderIconObj;

	public TextMeshProUGUI PlanDateText;

	private List<FollowVideoData> FollowVideoDataList;

	private csClassDownloadData DownloadMisionData;

	public GameObject startBtn;

	public GameObject perloadBtn;

	public GameObject itemBtn;

	private bool isInited;

	private string section;

	private bool isNeedPerload;

	private bool MissionAdded;

	public void SetBgImage(int index)
	{
		bgImage.sprite = bgSprites[index];
	}

	public void OnStartPress()
	{
		if (csGameSettings.isLoading)
		{
			return;
		}
		if (ItemSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			if (csSwiftAvatarController.IsTrackerSet)
			{
				GameManagerNew.instance.StartGame(ItemSongData);
				csCloudStorage.instance.SetClassAsClassHistory(ItemSongData.ClassID.ToString(), ClassHistoryState.UnFinished);
				csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
				DateTime now = DateTime.Now;
				csTalkingData.Instance.SendEvent("KC01_进入课程", 1.0, new Dictionary<string, object> { 
				{
					"课程/卡关ID：" + ItemSongData.ClassID,
					$"{now.Year:D}年{now.Month:D}月{now.Day:D}日 {now.Hour:D}点—{now.Hour + 1:D}点"
				} });
			}
			else
			{
				csPlayer.instance.StartSwiftSet();
			}
			return;
		}
		if (ItemSongData.ClassFeatures.Contains(ClassFeature.Swift))
		{
			csPlayer.instance.StartSwiftSet();
		}
		GameManagerNew.instance.StartGame(ItemSongData);
		csCloudStorage.instance.SetClassAsClassHistory(ItemSongData.ClassID.ToString(), ClassHistoryState.UnFinished);
		csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
		DateTime now2 = DateTime.Now;
		csTalkingData.Instance.SendEvent("KC01_进入课程", 1.0, new Dictionary<string, object> { 
		{
			"课程/卡关ID：" + ItemSongData.ClassID,
			$"{now2.Year:D}年{now2.Month:D}月{now2.Day:D}日 {now2.Hour:D}点—{now2.Hour + 1:D}点"
		} });
	}

	public void showItem(bool isShow)
	{
		root.gameObject.SetActive(isShow);
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3);
	}

	private void OnEnable()
	{
		if (isInited)
		{
			if (csMainMenuManager.instance.levelItemActions.ContainsKey(ItemSongData.ClassID))
			{
				Dictionary<string, Action> levelItemActions = csMainMenuManager.instance.levelItemActions;
				string classID = ItemSongData.ClassID;
				levelItemActions[classID] = (Action)Delegate.Combine(levelItemActions[classID], new Action(resetLevelItemLikeState));
			}
			else
			{
				csMainMenuManager.instance.levelItemActions.Add(ItemSongData.ClassID, resetLevelItemLikeState);
			}
			resetLevelItemLikeState();
			SetDownloadIcon();
			RefreshOrderIcon();
			SetOrderCallBack();
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_show, new Dictionary<string, object>
			{
				{
					"class_header",
					JsonUtility.ToJson(new class_header(ItemSongData))
				},
				{ "section", section }
			});
		}
	}

	private void OnDisable()
	{
		if (csMainMenuManager.instance.levelItemActions.ContainsKey(ItemSongData.ClassID))
		{
			Dictionary<string, Action> levelItemActions = csMainMenuManager.instance.levelItemActions;
			string classID = ItemSongData.ClassID;
			levelItemActions[classID] = (Action)Delegate.Remove(levelItemActions[classID], new Action(resetLevelItemLikeState));
		}
		RemoveDownloadMisionCallback();
		RemoveOrderCallBack();
	}

	public void IntiSongData(GameSongData sd, string section, int planDays = -1, bool sendevent = true)
	{
		ItemSongData = sd;
		this.section = section;
		SongNameText.text = csLocalizationManager.Instance.GetLocalText(sd.ClassTitleID).Substring(4);
		if (planDays == -1)
		{
			PlanDateText.gameObject.SetActive(value: false);
		}
		else
		{
			PlanDateText.text = "Day" + planDays;
		}
		if (sd.ClassFeatures.Contains(ClassFeature.AddOn))
		{
			CoachHeadIcon.enabled = false;
			CoachText.text = "";
			TimeText.text = "";
			bgImage.sprite = csIDImageIconManager.instance.GetImgByID("GB009");
		}
		else
		{
			CoachHeadIcon.enabled = true;
			CoachText.text = sd.CaochName;
			TimeText.text = sd.ClassTotalTime / 60 + "分钟";
			bgImage.sprite = csIDImageIconManager.instance.GetImgByID(sd.CoverImgID);
		}
		CoachHeadIcon.sprite = csIDImageIconManager.instance.GetImgByID(sd.CoachImgID);
		BoxingImg.gameObject.SetActive(value: false);
		StickImg.gameObject.SetActive(value: false);
		FollowImg.gameObject.SetActive(value: false);
		switch (ItemSongData.TypeInHand)
		{
		case csPlayMode.Boxing:
			BoxingImg.gameObject.SetActive(value: true);
			break;
		case csPlayMode.Stick:
			StickImg.gameObject.SetActive(value: true);
			break;
		case csPlayMode.Menu:
			FollowImg.gameObject.SetActive(value: true);
			break;
		}
		switch (ItemSongData.Diff)
		{
		case Diff.easy:
			diffText.text = csLocalizationManager.Instance.GetLocalText("LevelItem004");
			diffText_shadow.text = csLocalizationManager.Instance.GetLocalText("LevelItem004");
			diffImg.sprite = diffImgSprites[0];
			break;
		case Diff.normal:
			diffText.text = csLocalizationManager.Instance.GetLocalText("LevelItem005");
			diffText_shadow.text = csLocalizationManager.Instance.GetLocalText("LevelItem005");
			diffImg.sprite = diffImgSprites[1];
			break;
		case Diff.hard:
			diffText.text = csLocalizationManager.Instance.GetLocalText("LevelItem006");
			diffText_shadow.text = csLocalizationManager.Instance.GetLocalText("LevelItem006");
			diffImg.sprite = diffImgSprites[2];
			break;
		}
		LikeButton.button.onClick.AddListener(delegate
		{
			SetCollection(IsinCollectionlist(ItemSongData.ClassID));
		});
		if (csMainMenuManager.instance.levelItemActions.ContainsKey(ItemSongData.ClassID))
		{
			Dictionary<string, Action> levelItemActions = csMainMenuManager.instance.levelItemActions;
			string classID = ItemSongData.ClassID;
			levelItemActions[classID] = (Action)Delegate.Combine(levelItemActions[classID], new Action(resetLevelItemLikeState));
		}
		else
		{
			csMainMenuManager.instance.levelItemActions.Add(ItemSongData.ClassID, resetLevelItemLikeState);
		}
		isInited = true;
		resetLevelItemLikeState();
		SetFollowVideoDataList();
		SetDownloadIcon();
		RefreshOrderIcon();
		if (sendevent)
		{
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_show, new Dictionary<string, object>
			{
				{
					"class_header",
					JsonUtility.ToJson(new class_header(ItemSongData))
				},
				{ "section", section }
			});
		}
	}

	public void resetLevelItemLikeState()
	{
		if (!(this == null))
		{
			if (IsinCollectionlist(ItemSongData.ClassID))
			{
				LikeButton.OnSelect();
			}
			else
			{
				LikeButton.DeSelect();
			}
		}
	}

	private IEnumerator setLikeTab()
	{
		while (!csLogin.instance.isGetPlayfabData)
		{
			yield return null;
		}
		if (IsinCollectionlist(ItemSongData.ClassID))
		{
			LikeButton.OnSelect();
		}
		else
		{
			LikeButton.DeSelect();
		}
	}

	public bool IsinCollectionlist(string classid)
	{
		return csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.FindIndex((ClassData x) => x.ClassID == classid) >= 0;
	}

	public bool IsPlayerPlayedThisClass(string classid)
	{
		int num = csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList.FindIndex((ClassData x) => x.ClassID == classid);
		if (num < 0)
		{
			return false;
		}
		return csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList[num].HistoryState == ClassHistoryState.Finished;
	}

	public void SetCollection(bool isSet)
	{
		if (!isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(ItemSongData.ClassID, isSet: true);
			LikeButton.OnSelect();
		}
		if (isSet)
		{
			csCloudStorage.instance.SetOrRemoveClassCollection(ItemSongData.ClassID, isSet: false);
			LikeButton.DeSelect();
		}
		csMainMenuManager.instance.levelItemActions[ItemSongData.ClassID]();
		if (csLevelChoosePanel.instance.classDetail.isOpend)
		{
			csLevelChoosePanel.instance.classDetail.resetLevelItemLikeState();
		}
		for (int i = 0; i < csLevelChoosePanel.instance.RecommandClassLineManager.recInMain.Count; i++)
		{
			if (csLevelChoosePanel.instance.RecommandClassLineManager.recInMain[i].type == BannerType.Class)
			{
				csLevelChoosePanel.instance.RecommandClassLineManager.recInMain[i].resetLevelItemLikeState();
			}
		}
	}

	public void SelectToShow()
	{
		if (isNeedPerload)
		{
			perloadBtn.SetActive(value: true);
			startBtn.SetActive(value: false);
		}
		else
		{
			perloadBtn.SetActive(value: false);
			startBtn.SetActive(value: true);
		}
		csLevelChoosePanel.instance.HideLeftPanels();
		if (ItemSongData.PrepareClassIDList.Count > 0)
		{
			bool flag = false;
			int i;
			for (i = 0; i < ItemSongData.PrepareClassIDList.Count; i++)
			{
				if (csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList.Find((ClassData x) => x.ClassID == ItemSongData.PrepareClassIDList[i]) == null)
				{
					flag = true;
				}
			}
			if (flag && PlayerPrefs.GetInt("ClassID" + ItemSongData.ClassID, 0) == 0)
			{
				PlayerPrefs.SetInt("ClassID" + ItemSongData.ClassID, 1);
				string text = csLocalizationManager.Instance.GetLocalText("Common14") + "\n" + csLocalizationManager.Instance.GetLocalText(GameData.instance.GetSongDataByClassID(ItemSongData.PrepareClassIDList[0]).ClassTitleID);
				csMainMenuManager.instance.commonHintPanel.InitOneButtonHint(text, csLocalizationManager.Instance.GetLocalText("Common08"), null, delegate
				{
					csMainMenuManager.instance.ClosePopup(PanelType.CommonHint);
					csLevelChoosePanel.instance.InitClassDetailPanel(ItemSongData);
					csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
					ShowAnim();
					csLevelChoosePanel.instance.ShowSelectedItem(this);
				});
				csMainMenuManager.instance.OpenPenelAddOn(PanelType.CommonHint);
			}
			else
			{
				csLevelChoosePanel.instance.InitClassDetailPanel(ItemSongData);
				csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
				ShowAnim();
				csLevelChoosePanel.instance.ShowSelectedItem(this);
			}
		}
		else
		{
			csLevelChoosePanel.instance.InitClassDetailPanel(ItemSongData);
			csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
			ShowAnim();
			csLevelChoosePanel.instance.ShowSelectedItem(this);
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.class_click, new Dictionary<string, object>
		{
			{
				"class_header",
				JsonUtility.ToJson(new class_header(ItemSongData))
			},
			{ "section", section }
		});
	}

	public void ShowAnim()
	{
		if (SelectanimImg != null)
		{
			SelectanimImg.transform.localScale = Vector3.one;
			SelectanimImg.color = new Color(1f, 1f, 1f, 0.5f);
			SelectanimImg.transform.DOScale(Vector3.one * 1.3f, 0.5f);
			SelectanimImg.GetComponent<Graphic>().DOFade(0f, 0.5f);
		}
	}

	private void SetFollowVideoDataList()
	{
		if (FollowVideoDataList != null)
		{
			return;
		}
		switch (ItemSongData.Type)
		{
		case ClassType.Sport:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData3 = new FollowVideoData();
			FollowVideoData followVideoData4 = new FollowVideoData();
			followVideoData3.VideoName = ItemSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.WarmUp);
			followVideoData4.VideoName = ItemSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData3);
			FollowVideoDataList.Add(followVideoData4);
			break;
		}
		case ClassType.Mix:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData5 = new FollowVideoData();
			FollowVideoData followVideoData6 = new FollowVideoData();
			followVideoData5.VideoName = ItemSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.WarmUp);
			followVideoData6.VideoName = ItemSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData5);
			FollowVideoDataList.Add(followVideoData6);
			break;
		}
		case ClassType.Follow:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int k = 0; k < ItemSongData.FollowVideoDataList.Count; k++)
			{
				FollowVideoData followVideoData2 = new FollowVideoData();
				followVideoData2.VideoName = ItemSongData.FollowVideoDataList[k].VideoName;
				followVideoData2.GapTime = ItemSongData.FollowVideoDataList[k].GapTime;
				followVideoData2.VideoScale = ItemSongData.FollowVideoDataList[k].VideoScale;
				followVideoData2.VideoOffset = ItemSongData.FollowVideoDataList[k].VideoOffset;
				followVideoData2.CoachEuler = ItemSongData.FollowVideoDataList[k].CoachEuler;
				FollowVideoDataList.Add(followVideoData2);
			}
			for (int l = 0; l < FollowVideoDataList.Count; l++)
			{
				FollowVideoDataList[l].VideoName += csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.Follow);
			}
			break;
		}
		case ClassType.Think:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			FollowVideoData followVideoData7 = new FollowVideoData();
			FollowVideoData followVideoData8 = new FollowVideoData();
			followVideoData7.VideoName = ItemSongData.WarmUpOrFollowVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.WarmUp);
			followVideoData8.VideoName = ItemSongData.CoolDownVideoNum + csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.CoolDown);
			FollowVideoDataList.Add(followVideoData7);
			FollowVideoDataList.Add(followVideoData8);
			break;
		}
		case ClassType.SuperGorilla:
		{
			FollowVideoDataList = new List<FollowVideoData>();
			for (int i = 0; i < ItemSongData.FollowVideoDataList.Count; i++)
			{
				FollowVideoData followVideoData = new FollowVideoData();
				followVideoData.VideoName = ItemSongData.FollowVideoDataList[i].VideoName;
				followVideoData.GapTime = ItemSongData.FollowVideoDataList[i].GapTime;
				followVideoData.VideoScale = ItemSongData.FollowVideoDataList[i].VideoScale;
				followVideoData.VideoOffset = ItemSongData.FollowVideoDataList[i].VideoOffset;
				followVideoData.CoachEuler = ItemSongData.FollowVideoDataList[i].CoachEuler;
				FollowVideoDataList.Add(followVideoData);
			}
			for (int j = 0; j < FollowVideoDataList.Count; j++)
			{
				FollowVideoDataList[j].VideoName += csCloudSettings.GetClassVideoVersion(ItemSongData.ClassID, VideoType.Follow);
			}
			break;
		}
		case ClassType.TutorialPunch:
		case ClassType.TutorialStick:
		case ClassType.TUtorialFollow:
			break;
		}
	}

	private bool CheckVideoFileExist()
	{
		bool result = true;
		for (int i = 0; i < FollowVideoDataList.Count; i++)
		{
			if (!csDownloadTools.instance.CheckMP4FileExists(FollowVideoDataList[i].VideoName))
			{
				result = false;
				break;
			}
		}
		return result;
	}

	public void OnPerloadBtnClick()
	{
		DownloadMisionData = csVedioDownloadManager.instance.CreateClassMisionDataByID(FollowVideoDataList, ItemSongData.ClassID, delegate
		{
		}, delegate
		{
		}, delegate
		{
		});
		SetDownloadIcon();
	}

	private void SetDownloadIcon()
	{
		if (GameManagerNew.instance.isShowDownload)
		{
			if (CheckVideoFileExist())
			{
				DownloadIconObj.SetActive(value: false);
				isNeedPerload = false;
				return;
			}
			isNeedPerload = true;
			DownloadIconObj.SetActive(value: true);
			SetDownloadMision();
			SetDownloadIconByIndex();
			SetDownloadMisionCallback();
		}
	}

	private void SetDownloadIconByIndex()
	{
		int num = 0;
		DownloadShowImage.fillAmount = 1f;
		if (DownloadMisionData == null)
		{
			num = 0;
		}
		else
		{
			if (DownloadMisionData.downloadState == DowloadState.Downloading)
			{
				num = 1;
				DownloadShowImage.fillAmount = (float)DownloadMisionData.GetTotalProgress();
			}
			else if (DownloadMisionData.downloadState == DowloadState.Stoped)
			{
				num = 2;
				DownloadShowImage.fillAmount = (float)DownloadMisionData.GetTotalProgress();
			}
			else if (DownloadMisionData.downloadState == DowloadState.Wait)
			{
				num = 3;
			}
			if (DownloadMisionData.downloadState == DowloadState.Completed)
			{
				DownloadIconObj.SetActive(value: false);
				isNeedPerload = false;
				perloadBtn.SetActive(value: false);
				startBtn.SetActive(value: true);
			}
		}
		switch (num)
		{
		case 0:
			DownloadShowObj.gameObject.SetActive(value: false);
			downloadJiantou.SetActive(value: true);
			puseObj.SetActive(value: false);
			downloadBgObj.SetActive(value: false);
			break;
		case 1:
			if (!DownloadShowObj.gameObject.activeSelf)
			{
				DownloadShowObj.gameObject.SetActive(value: true);
				downloadJiantou.SetActive(value: false);
				downloadBgObj.SetActive(value: true);
			}
			if (puseObj.activeSelf)
			{
				puseObj.SetActive(value: false);
			}
			break;
		case 2:
			puseObj.SetActive(value: true);
			downloadJiantou.SetActive(value: false);
			downloadBgObj.SetActive(value: true);
			DownloadShowObj.gameObject.SetActive(value: true);
			break;
		case 3:
			puseObj.SetActive(value: false);
			downloadJiantou.SetActive(value: false);
			downloadBgObj.SetActive(value: true);
			DownloadShowObj.gameObject.SetActive(value: false);
			break;
		}
	}

	private void SetDownloadMision()
	{
		DownloadMisionData = csVedioDownloadManager.instance.GetClassMisionById(ItemSongData.ClassID);
	}

	private void SetDownloadMisionCallback()
	{
		RemoveDownloadMisionCallback();
		MissionAdded = true;
		csVedioDownloadManager instance = csVedioDownloadManager.instance;
		instance.classMisionCreateCallback = (Action<string>)Delegate.Combine(instance.classMisionCreateCallback, new Action<string>(CreateMisionCallback));
		if (DownloadMisionData != null)
		{
			csClassDownloadData downloadMisionData = DownloadMisionData;
			downloadMisionData.classMisionStartCallBack = (Action)Delegate.Combine(downloadMisionData.classMisionStartCallBack, new Action(StartMisionCallback));
			csClassDownloadData downloadMisionData2 = DownloadMisionData;
			downloadMisionData2.classMisionStopCallBack = (Action)Delegate.Combine(downloadMisionData2.classMisionStopCallBack, new Action(StopMisionCallback));
			csClassDownloadData downloadMisionData3 = DownloadMisionData;
			downloadMisionData3.classMisionProgressCallBack = (Action<double>)Delegate.Combine(downloadMisionData3.classMisionProgressCallBack, new Action<double>(OnMisionProgress));
			csClassDownloadData downloadMisionData4 = DownloadMisionData;
			downloadMisionData4.classMisionCompletCallBack = (Action)Delegate.Combine(downloadMisionData4.classMisionCompletCallBack, new Action(MisionCompletCallback));
			csClassDownloadData downloadMisionData5 = DownloadMisionData;
			downloadMisionData5.classMisionCanncelCallBack = (Action)Delegate.Combine(downloadMisionData5.classMisionCanncelCallBack, new Action(CanncalMisionCallback));
		}
	}

	private void RemoveDownloadMisionCallback()
	{
		MissionAdded = false;
		csVedioDownloadManager instance = csVedioDownloadManager.instance;
		instance.classMisionCreateCallback = (Action<string>)Delegate.Remove(instance.classMisionCreateCallback, new Action<string>(CreateMisionCallback));
		if (DownloadMisionData != null)
		{
			csClassDownloadData downloadMisionData = DownloadMisionData;
			downloadMisionData.classMisionStartCallBack = (Action)Delegate.Remove(downloadMisionData.classMisionStartCallBack, new Action(StartMisionCallback));
			csClassDownloadData downloadMisionData2 = DownloadMisionData;
			downloadMisionData2.classMisionStopCallBack = (Action)Delegate.Remove(downloadMisionData2.classMisionStopCallBack, new Action(StopMisionCallback));
			csClassDownloadData downloadMisionData3 = DownloadMisionData;
			downloadMisionData3.classMisionProgressCallBack = (Action<double>)Delegate.Remove(downloadMisionData3.classMisionProgressCallBack, new Action<double>(OnMisionProgress));
			csClassDownloadData downloadMisionData4 = DownloadMisionData;
			downloadMisionData4.classMisionCompletCallBack = (Action)Delegate.Remove(downloadMisionData4.classMisionCompletCallBack, new Action(MisionCompletCallback));
			csClassDownloadData downloadMisionData5 = DownloadMisionData;
			downloadMisionData5.classMisionCanncelCallBack = (Action)Delegate.Remove(downloadMisionData5.classMisionCanncelCallBack, new Action(CanncalMisionCallback));
		}
	}

	private void CreateMisionCallback(string ClassID)
	{
		if (!(this == null) && !(ClassID != ItemSongData.ClassID))
		{
			SetDownloadMision();
			SetDownloadIconByIndex();
			SetDownloadIcon();
		}
	}

	private void StartMisionCallback()
	{
		if (!(this == null))
		{
			SetDownloadIconByIndex();
		}
	}

	private void StopMisionCallback()
	{
		if (!(this == null))
		{
			SetDownloadIconByIndex();
		}
	}

	private void MisionCompletCallback()
	{
		if (!(this == null))
		{
			SetDownloadIconByIndex();
		}
	}

	private void CanncalMisionCallback()
	{
		if (!(this == null))
		{
			DownloadMisionData = null;
			SetDownloadIconByIndex();
		}
	}

	private void OnMisionProgress(double prs)
	{
		if (!(this == null))
		{
			DownloadShowImage.fillAmount = (float)DownloadMisionData.GetTotalProgress();
		}
	}

	public bool CheckCanStartGame()
	{
		if (ItemSongData.PayType == ClassPayType.Free)
		{
			return true;
		}
		bool flag = true;
		if (csPlayerOrderManager.instance.IsOrdering())
		{
			return true;
		}
		return false;
	}

	public void RefreshOrderIcon()
	{
		orderIconObj.SetActive(!csPlayerOrderManager.instance.IsOrdering() && ItemSongData.PayType == ClassPayType.Pay);
	}

	private void SetOrderCallBack()
	{
		if (!(this == null))
		{
			csPlayerOrderManager.instance.AddCallBackAction(RefreshOrderIcon, RefreshOrderIcon);
		}
	}

	private void RemoveOrderCallBack()
	{
		if (!(this == null))
		{
			csPlayerOrderManager.instance.RemoveCallBackAction(RefreshOrderIcon, RefreshOrderIcon);
		}
	}

	public void StartGame()
	{
		csLevelChoosePanel.instance.StartGame();
	}
}
public class csLikeTabPageMan : MonoBehaviour
{
	public GameObject selectOne;

	public GameObject selectedOne;

	public Transform selectOneT;

	public Transform selectedOneT;

	[SerializeField]
	private csTabSelectedOne[] selectedTabScripts;

	[SerializeField]
	private csTabSelectOne[] selectTabScripts;

	public SearchKeywords[] selectTabKeys;

	public Sprite[] selectTabPic;

	public List<SearchKeywords> selectedTabNames;

	public static bool isSelectStyle;

	private int currentFirstNum;

	public bool canAddSelected => selectedTabNames.Count < 8;

	private void Start()
	{
		showSelectOnes();
		isSelectStyle = false;
	}

	private void showSelectOnes()
	{
		for (int i = 0; i < selectTabScripts.Length; i++)
		{
			selectTabScripts[i].gameObject.SetActive(value: false);
		}
		for (int j = 0; j < selectedTabScripts.Length; j++)
		{
			selectedTabScripts[j].gameObject.SetActive(value: false);
		}
		int num = ((selectTabKeys.Length <= 4) ? selectTabKeys.Length : 4);
		for (int k = 0; k < num; k++)
		{
			selectTabScripts[k].gameObject.SetActive(value: true);
		}
		currentFirstNum = 0;
		setName(currentFirstNum);
	}

	public void deleteSelected(SearchKeywords name)
	{
		if (selectedTabNames.Contains(name))
		{
			selectedTabNames.Remove(name);
		}
		for (int i = 0; i < selectTabScripts.Length; i++)
		{
			selectTabScripts[i].setSelect();
		}
		setSelected();
	}

	public void AddSelectedOne(SearchKeywords name)
	{
		if (!selectedTabNames.Contains(name))
		{
			selectedTabNames.Add(name);
		}
		setSelected();
		isSelectStyle = true;
	}

	private void setSelected()
	{
		for (int i = 0; i < selectedTabScripts.Length; i++)
		{
			selectedTabScripts[i].gameObject.SetActive(value: false);
		}
		for (int j = 0; j < selectedTabNames.Count; j++)
		{
			selectedTabScripts[j].gameObject.SetActive(value: true);
			selectedTabScripts[j].tabName.text = SerchKeyWordToName(selectedTabNames[j]);
			selectedTabScripts[j].tabName2.text = SerchKeyWordToName(selectedTabNames[j]);
			selectedTabScripts[j].keyword = selectedTabNames[j];
		}
	}

	private string SerchKeyWordToName(SearchKeywords key)
	{
		string result = "";
		switch (key)
		{
		case SearchKeywords.KeepFit:
			result = "保持健康";
			break;
		case SearchKeywords.LossWeight:
			result = "减脂";
			break;
		case SearchKeywords.MakeBody:
			result = "塑形";
			break;
		}
		return result;
	}

	private void setName(int num)
	{
		for (int i = 0; i < selectTabScripts.Length; i++)
		{
			selectTabScripts[i].setNameAndPic(SerchKeyWordToName(selectTabKeys[num]), selectTabPic[num], selectTabKeys[num]);
			if (++num >= 4)
			{
				num = 0;
			}
		}
	}

	public void refreshTab()
	{
		currentFirstNum++;
		if (currentFirstNum >= 4)
		{
			currentFirstNum = 0;
		}
		setName(currentFirstNum);
	}
}
public class csLoadClassLine : MonoBehaviour
{
	public csPageMoveTrigger pageTrigger;

	public List<int> list_ClassID;

	public RectTransform LoadT;

	public Button LeftBtn;

	public Button RightBtn;

	public Button UpBtn;

	public Button DownBtn;

	public TextMeshProUGUI PageDetail;

	public Button ShowAll;

	public GameObject LevelItemPrefab;

	public int Totalpage;

	public int PageNow;

	public TextMeshProUGUI SprotText;

	public List<GameSongData> InMainDataList;

	public List<csLevelItem> ListInMain;

	public Image TitleImage;

	public Sprite[] TitleSprites;

	public Image LeftBgImage;

	public Sprite[] LeftBgImageSprites;

	public Image MiddleBgImage;

	public Sprite[] MiddleBgImageSprites;

	public Image RightBgImage;

	public Sprite[] RightBgImageSprites;

	public Mask mask;

	public Image img;

	[SerializeField]
	private csLevelChoosePanel.LevelGroupType levelGroupType;

	private bool isMoving;

	public float pageWidth = -1628f;

	public float pageHeight = 1078f;

	public float itemXDeviation = -3f;

	public int itemCountPerPage = 12;

	private void Start()
	{
		LeftBtn.onClick.AddListener(PageLeft);
		RightBtn.onClick.AddListener(PageRight);
		UpBtn.onClick.AddListener(PageUp);
		DownBtn.onClick.AddListener(PageDown);
		ShowAll.onClick.AddListener(ShowSpColAll);
		csPageMoveTrigger obj = pageTrigger;
		obj.OnPageLeftAct = (UnityAction)Delegate.Combine(obj.OnPageLeftAct, new UnityAction(PageLeft));
		csPageMoveTrigger obj2 = pageTrigger;
		obj2.OnPageRightAct = (UnityAction)Delegate.Combine(obj2.OnPageRightAct, new UnityAction(PageRight));
	}

	private void ShowSpColAll()
	{
		csLevelChoosePanel.instance.ApplySpColKeyword(levelGroupType, SprotText.text);
	}

	private void OnEnable()
	{
		isMoving = false;
	}

	public void InitClassLineInMain(List<GameSongData> sdList, string colName, csLevelChoosePanel.LevelGroupType type)
	{
		SprotText.text = colName;
		InMainDataList = sdList;
		levelGroupType = type;
		switch (levelGroupType)
		{
		case csLevelChoosePanel.LevelGroupType.BoxLevels:
			TitleImage.sprite = TitleSprites[0];
			LeftBgImage.sprite = LeftBgImageSprites[0];
			MiddleBgImage.sprite = MiddleBgImageSprites[0];
			RightBgImage.sprite = RightBgImageSprites[0];
			break;
		case csLevelChoosePanel.LevelGroupType.StickLevels:
			TitleImage.sprite = TitleSprites[1];
			LeftBgImage.sprite = LeftBgImageSprites[1];
			MiddleBgImage.sprite = MiddleBgImageSprites[1];
			RightBgImage.sprite = RightBgImageSprites[1];
			break;
		case csLevelChoosePanel.LevelGroupType.SuperGrolia:
			TitleImage.sprite = TitleSprites[2];
			LeftBgImage.sprite = LeftBgImageSprites[2];
			MiddleBgImage.sprite = MiddleBgImageSprites[2];
			RightBgImage.sprite = RightBgImageSprites[2];
			break;
		case csLevelChoosePanel.LevelGroupType.Follow:
			TitleImage.sprite = TitleSprites[3];
			LeftBgImage.sprite = LeftBgImageSprites[3];
			MiddleBgImage.sprite = MiddleBgImageSprites[3];
			RightBgImage.sprite = RightBgImageSprites[3];
			break;
		}
		Totalpage = (int)Math.Ceiling((float)InMainDataList.Count / (float)itemCountPerPage);
		string section = type switch
		{
			csLevelChoosePanel.LevelGroupType.BoxLevels => "BoxingColumn", 
			csLevelChoosePanel.LevelGroupType.StickLevels => "StickColumn", 
			csLevelChoosePanel.LevelGroupType.SportLevels => "SportColumn", 
			csLevelChoosePanel.LevelGroupType.SuperGrolia => "SuperGroliaColumn", 
			csLevelChoosePanel.LevelGroupType.Follow => "FollowColumn", 
			csLevelChoosePanel.LevelGroupType.FreeLevels => "FreeColumn", 
			csLevelChoosePanel.LevelGroupType.Thinking => "ThinkingColumn", 
			csLevelChoosePanel.LevelGroupType.AddOnLevels => "AddOnColumn", 
			csLevelChoosePanel.LevelGroupType.Mix => "MixColumn", 
			csLevelChoosePanel.LevelGroupType.SwiftLevels => "SwiftColumn", 
			csLevelChoosePanel.LevelGroupType.AlphaTestLevels => "AlphaTestColumn", 
			csLevelChoosePanel.LevelGroupType.Pamela => "New5Column", 
			_ => "NoneColumn", 
		};
		for (int i = 0; i < InMainDataList.Count; i++)
		{
			csLevelItem component = UnityEngine.Object.Instantiate(LevelItemPrefab, LoadT).GetComponent<csLevelItem>();
			component.IntiSongData(InMainDataList[i], section);
			ListInMain.Add(component);
		}
		SetToPage(0);
	}

	public void PageLeft()
	{
	}

	public void PageRight()
	{
	}

	public void PageUp()
	{
		if (!isMoving && PageNow > 0)
		{
			SetToPage(PageNow - 1, isToLeft: true);
		}
	}

	public void PageDown()
	{
		if (!isMoving && PageNow < Totalpage - 1)
		{
			SetToPage(PageNow + 1, isToLeft: false);
		}
	}

	public void SetToPage(int p)
	{
		mask.enabled = true;
		img.enabled = true;
		PageNow = p;
		PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (PageNow + 1) : 0, "/", Totalpage);
		for (int i = 0; i < ListInMain.Count; i++)
		{
			if (i < ListInMain.Count)
			{
				if (i >= p * itemCountPerPage && i < (itemCountPerPage + 1) * 4)
				{
					ListInMain[i].showItem(isShow: true);
				}
				else
				{
					ListInMain[i].showItem(isShow: false);
				}
			}
		}
	}

	public void SetToPage(int p, bool isToLeft)
	{
		mask.enabled = true;
		img.enabled = true;
		int lastPage = PageNow;
		PageNow = p;
		PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (PageNow + 1) : 0, "/", Totalpage);
		for (int i = p * itemCountPerPage; i < p * itemCountPerPage + itemCountPerPage; i++)
		{
			if (i < ListInMain.Count)
			{
				ListInMain[i].showItem(isShow: true);
			}
		}
		isMoving = true;
		LoadT.DOLocalMoveY((float)PageNow * pageHeight, 0.7f).OnComplete(delegate
		{
			for (int j = lastPage * itemCountPerPage; j < lastPage * itemCountPerPage + itemCountPerPage; j++)
			{
				if (j < ListInMain.Count)
				{
					ListInMain[j].showItem(isShow: false);
				}
			}
			isMoving = false;
			mask.enabled = false;
			img.enabled = false;
		});
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			PageRight();
		}
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			PageLeft();
		}
		if (Input.GetKeyDown(KeyCode.UpArrow))
		{
			PageUp();
		}
		if (Input.GetKeyDown(KeyCode.DownArrow))
		{
			PageDown();
		}
	}
}
public class csLoadingPanel : csPanelBase
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class csMainMenuManager : MonoBehaviour
{
	public static csMainMenuManager instance;

	public csPlanDetailPanel planDetailPanel;

	public csOfflineTipPanel disconnectPanel;

	public csDownloadPanel downloadPanel;

	public csCommonHintPanel commonHintPanel;

	public csSocialPanel multiPanel;

	public csAnnouncementDetailsPanel announcementDetailsPanel;

	public Dictionary<PanelType, csPanelBase> panelDic = new Dictionary<PanelType, csPanelBase>();

	public PanelType currentPanel;

	public PanelType currentPopup;

	public PanelType LastPanel = PanelType.LevelChoose;

	public bool isOpened;

	public AudioClip openMenuClip;

	public AudioClip closeMenuClip;

	private csControllerforPicoXR rightDevice;

	private csControllerforPicoXR leftDevice;

	public Dictionary<string, Action> levelItemActions = new Dictionary<string, Action>();

	public Text LogText;

	public CanvasGroup WelcomePage;

	public csMainMenuPanel startPage;

	public csMyInformationPanel myInformationPanel;

	public GameObject LevelChooseNormal;

	public GameObject LevelChooseSG;

	private bool firstStart;

	private List<PanelType> addOnPanels = new List<PanelType>();

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		LevelChooseNormal.SetActive(value: true);
		LevelChooseSG.SetActive(value: false);
	}

	public void Restart()
	{
		StartCoroutine(Start());
	}

	private IEnumerator Start()
	{
		csGameSettings.isLoading = true;
		OpenPopup(PanelType.Loading, "Start");
		yield return new WaitForEndOfFrame();
		while (!csPlayerPicoDataManager.instance.isGetInfo && !csPlayfabServer.Instance.IsClientLoggedIn)
		{
			yield return null;
		}
		csPlayer.instance.SetHeadDownHint(flag: false);
		ClosePopup(PanelType.Loading);
		csGameSettings.isLoading = false;
		isOpened = true;
	}

	public void OpenPanel(PanelType type, string message = "")
	{
		if (csIngameMenuManager.instance.currentPanel != 0)
		{
			csIngameMenuManager.instance.ClosePanel();
		}
		if (currentPanel != 0)
		{
			panelDic[currentPanel].Close();
			if (currentPanel == PanelType.LevelChoose || currentPanel == PanelType.Plan || currentPanel == PanelType.Multi || currentPanel == PanelType.Friends || currentPanel == PanelType.MyInformation)
			{
				LastPanel = currentPanel;
			}
			else
			{
				LastPanel = PanelType.LevelChoose;
			}
		}
		for (int i = 0; i < addOnPanels.Count; i++)
		{
			panelDic[addOnPanels[i]].Close();
		}
		addOnPanels.Clear();
		currentPanel = type;
		if (string.IsNullOrEmpty(message))
		{
			panelDic[type].Open();
		}
		else
		{
			panelDic[type].Open(message);
		}
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		dictionary.Add("page_name", type.ToString());
		dictionary.Add("page_status", "main");
		if (!firstStart && type == PanelType.LevelChoose)
		{
			firstStart = true;
			dictionary.Add("first_gap_duration", (int)(Time.realtimeSinceStartup * 1000f));
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.enter_page, dictionary);
	}

	public void CloseAddOn(string message = "")
	{
		for (int i = 0; i < addOnPanels.Count; i++)
		{
			panelDic[addOnPanels[i]].Close();
		}
		addOnPanels.Clear();
	}

	public csKeyboardPanel GetKeyboardPanel()
	{
		return (csKeyboardPanel)panelDic[PanelType.VRKeyboard];
	}

	public void OpenPenelAddOn(PanelType type, string message = "")
	{
		addOnPanels.Add(type);
		if (string.IsNullOrEmpty(message))
		{
			panelDic[type].Open();
		}
		else
		{
			panelDic[type].Open(message);
		}
	}

	public void ClosePanel(string message = "")
	{
		if (currentPanel != 0)
		{
			panelDic[currentPanel].Close();
		}
		currentPanel = PanelType.None;
	}

	public void ClosePanel(PanelType type, string message = "")
	{
		if (currentPanel == type)
		{
			ClosePanel(message);
			return;
		}
		panelDic[type].Close();
		if (addOnPanels.Contains(type))
		{
			addOnPanels.Remove(type);
		}
	}

	public void CloseMainPanel()
	{
		csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: false);
	}

	public void OpenMainPanel()
	{
		csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: true);
		base.gameObject.SetActive(value: true);
	}

	public void OpenPopup(PanelType type, string message = "")
	{
		if (currentPopup != 0)
		{
			panelDic[currentPopup].Close();
		}
		if (string.IsNullOrEmpty(message))
		{
			panelDic[type].Open();
		}
		else
		{
			panelDic[type].Open(message);
		}
		currentPopup = type;
	}

	public void ClosePopup(PanelType type)
	{
		panelDic[type].Close();
		currentPopup = PanelType.None;
	}

	public void ShowLoading()
	{
		csGameSettings.isLoading = true;
	}

	public void HideLoading()
	{
		csGameSettings.isLoading = false;
	}
}
public class csMainMenuPanel : csPanelBase
{
	public GameObject[] logo;

	public CanvasGroup logoGroup;

	public GameObject LogoLoading;

	public float showTime = 2f;

	public bool showText = true;

	public bool showImg = true;

	public float LogoOffset;

	public bool isShowing;

	private bool WaitForProcess = true;

	private void Start()
	{
		logoGroup.alpha = 0f;
		isShowing = false;
		float y = csPlayer.instance.PicoXRControllerHead.transform.position.y + LogoOffset;
		Vector3 position = body.transform.position;
		position.y = y;
		body.transform.position = position;
		csCloudSettings.AnnoucementLoadSuccessAct = (UnityAction<List<AnnouncementItem>>)Delegate.Combine(csCloudSettings.AnnoucementLoadSuccessAct, new UnityAction<List<AnnouncementItem>>(OnAnnounceImgGet));
	}

	public override void Open()
	{
		base.Open();
	}

	public void startShow(Action callback)
	{
		LogoLoading.SetActive(value: false);
		isShowing = true;
		StartCoroutine(IEstartShow(callback));
	}

	private void OnDestroy()
	{
		csCloudSettings.AnnoucementLoadSuccessAct = (UnityAction<List<AnnouncementItem>>)Delegate.Remove(csCloudSettings.AnnoucementLoadSuccessAct, new UnityAction<List<AnnouncementItem>>(OnAnnounceImgGet));
	}

	private void OnAnnounceImgGet(List<AnnouncementItem> ann)
	{
		WaitForProcess = false;
	}

	private IEnumerator IEstartShow(Action callback)
	{
		XRSettings.eyeTextureResolutionScale = 1.5f;
		float t = 0f;
		while (WaitForProcess && t < 4f)
		{
			t += Time.deltaTime;
			yield return new WaitForEndOfFrame();
		}
		yield return new WaitForEndOfFrame();
		for (int i = 0; i < logo.Length; i++)
		{
			logo[i].SetActive(value: false);
		}
		if (showImg)
		{
			logoGroup.alpha = 1f;
			if (csSimpleFrameAnim.instance.isVideo)
			{
				csSimpleFrameAnim.instance.videoPlayer.gameObject.SetActive(value: true);
				csSimpleFrameAnim.instance.Play();
				yield return new WaitForSeconds(8.5f);
				csSimpleFrameAnim.instance.videoPlayer.gameObject.SetActive(value: false);
			}
			else
			{
				csSimpleFrameAnim.instance.ImageSource.gameObject.SetActive(value: true);
				csSimpleFrameAnim.instance.Play();
				yield return new WaitForSeconds(8.5f);
				csSimpleFrameAnim.instance.ImageSource.gameObject.SetActive(value: false);
			}
			logo[3].SetActive(value: true);
			logoGroup.alpha = 0f;
			logoGroup.DOFade(1f, 1f);
			yield return new WaitForSeconds(1f + showTime);
			logoGroup.DOFade(0f, 1f);
			yield return new WaitForSeconds(1f);
			logo[3].SetActive(value: false);
			csEnvironmentManager.instance.SetAudioMute(mute: false);
		}
		XRSettings.eyeTextureResolutionScale = csPlayerRigLoader.MenuResScale;
		LogoLoading.SetActive(value: true);
		logoGroup.alpha = 0f;
		callback();
		isShowing = false;
	}

	public void ExitGame()
	{
		Application.Quit();
	}

	public void BackToMainMenu()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.MainMenu);
	}

	public void GoToSetting()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.Settings);
	}

	public void GoToDeveloper()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.Developer);
	}

	public void GoToTutorial()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.Tutorial);
	}
}
public class csMultiRoomPanel : csPanelBase
{
	public Image ClassImage;

	public Image CoachImage;

	public TextMeshProUGUI className;

	public TextMeshProUGUI classTime;

	public TextMeshProUGUI Dif;

	public TextMeshProUGUI coachName;

	public TextMeshProUGUI classDetail;

	public TextMeshProUGUI PlayerName;

	public TextMeshProUGUI PlayerDetail;

	public Slider MicVol;

	public Slider VoiceVol;

	public Slider CoachVoiceVol;

	public csOnPointerEvents CoachVolEvt;

	public csOnPointerEvents VoiceVolEvt;

	public csOnPointerEvents MicVolEvt;

	public AudioClip TeacherSetClip;

	public AudioClip MicSetClip;

	public AudioClip VoiceSetClip;

	public GameObject PlayerUIItemPrefab;

	public List<csPlayerUIItemInMulti> PlayerUIList = new List<csPlayerUIItemInMulti>();

	public Dictionary<string, csPlayerUIItemInMulti> PlayerUIItemList = new Dictionary<string, csPlayerUIItemInMulti>();

	private void Awake()
	{
		InitSliderSettings();
		foreach (csPlayerUIItemInMulti playerUI in PlayerUIList)
		{
			playerUI.SetPlayerOn(IsOn: false);
		}
	}

	public void RefresPlayerUIList(List<csMultiPlayer> PList)
	{
		foreach (csPlayerUIItemInMulti playerUI in PlayerUIList)
		{
			playerUI.SetPlayerOn(IsOn: false);
		}
		for (int i = 0; i < PList.Count; i++)
		{
			PlayerUIList[i].SetPlayerOn(IsOn: true);
			PlayerUIList[i].InitPlayerInfo(PList[i].PlayerNickName, PList[i] == csMultiGameManager.instance.currentPlayer, PList[i].AvatarUrl);
		}
	}

	public void setClassInfo(GameSongData info)
	{
		ClassImage.sprite = csIDImageIconManager.instance.GetImgByID(info.CoverImgID);
		CoachImage.sprite = csIDImageIconManager.instance.GetImgByID(info.CoachImgID);
		className.text = csLocalizationManager.Instance.GetLocalText("Common06") + csLocalizationManager.Instance.GetLocalText(info.ClassTitleID);
		classTime.text = csLocalizationManager.Instance.GetLocalText("LevelDetail01") + info.ClassTotalTime / 60 + "min";
		switch (info.Diff)
		{
		case Diff.easy:
			Dif.text = csLocalizationManager.Instance.GetLocalText("Common01");
			break;
		case Diff.hard:
			Dif.text = csLocalizationManager.Instance.GetLocalText("Common03");
			break;
		case Diff.hardest:
			Dif.text = csLocalizationManager.Instance.GetLocalText("Common04");
			break;
		case Diff.normal:
			Dif.text = csLocalizationManager.Instance.GetLocalText("Common05");
			break;
		}
		coachName.text = csLocalizationManager.Instance.GetLocalText("Common07") + info.CaochName;
		classDetail.text = csLocalizationManager.Instance.GetLocalText(info.ClassDetailID);
	}

	public void setPlayerInfo(PlayerInfoInPlayfab info)
	{
		PlayerName.text = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName;
	}

	private void InitSliderSettings()
	{
		MicVol.SetValueWithoutNotify(csGameSettings.MicVol);
		VoiceVol.SetValueWithoutNotify(csGameSettings.VoiceVol);
		MicVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.MicVol = x;
		});
		VoiceVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.VoiceVol = x;
		});
		csOnPointerEvents micVolEvt = MicVolEvt;
		micVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(micVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(MicSetClip, Vector3.zero, csGameSettings.MicVol);
		});
		csOnPointerEvents voiceVolEvt = VoiceVolEvt;
		voiceVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(voiceVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(VoiceSetClip, Vector3.zero, csGameSettings.VoiceVol);
		});
		CoachVoiceVol.SetValueWithoutNotify(csGameSettings.CoachVoiceVol);
		csOnPointerEvents coachVolEvt = CoachVolEvt;
		coachVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(coachVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(TeacherSetClip, Vector3.zero, csGameSettings.CoachVoiceVol);
		});
		CoachVoiceVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.CoachVoiceVol = x;
			csMultiGameManager.instance.SetCoachAudioVolume();
		});
	}
}
public class csMyDetalPanel : csPanelBase
{
	public Button ReturnBtn;

	public Image headIcon;

	public TMP_InputField enterHeight;

	public TMP_InputField enterWeight;

	public TMP_InputField enterAge;

	public TextMeshProUGUI userName;

	public TextMeshProUGUI Height;

	public TextMeshProUGUI Weight;

	public TextMeshProUGUI Age;

	public GameObject orderIconObj;

	public GameObject VIPIconObj;

	public Button OrderManagerBtn;

	public csTabSelectedOne[] selectedTabScripts;

	public List<SearchKeywords> canSelectTabNames = new List<SearchKeywords>();

	public TextMeshProUGUI[] selectLabel;

	public TextMeshProUGUI[] selectLabel2;

	public GameObject[] selectObj;

	public GameObject changeBtn;

	private List<SearchKeywords> showSelectNames = new List<SearchKeywords>();

	private int currentFirstNum;

	protected override void InitRef()
	{
		base.InitRef();
		ReturnBtn.onClick.AddListener(ReturnToMain);
		OrderManagerBtn.onClick.AddListener(OpenOrderManager);
		enterAge.keyboardType = (TouchScreenKeyboardType)(-1);
		enterHeight.keyboardType = (TouchScreenKeyboardType)(-1);
		enterWeight.keyboardType = (TouchScreenKeyboardType)(-1);
	}

	public override void Open()
	{
		base.Open();
		setSelected();
		currentFirstNum = 0;
		setName(currentFirstNum);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
		csPlayfabServer.Instance.StartGetAvatar(csPlayfabServer.Instance.PlayfabID, csPlayerPicoDataManager.instance.m_PicoAccountInfo.headIconURL, setHeadIcon);
		userName.text = csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName;
		enterHeight.text = csCloudStorage.instance.m_PlayerInfoInPlayfab.Height.ToString();
		enterWeight.text = csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight.ToString();
		enterAge.text = csCloudStorage.instance.m_PlayerInfoInPlayfab.Age.ToString();
		RefreshOrder();
		SetOrderCallBack();
	}

	public override void Close()
	{
		base.Close();
		RemoveOrderCallBack();
		int.TryParse(enterHeight.text, out csCloudStorage.instance.m_PlayerInfoInPlayfab.Height);
		int.TryParse(enterWeight.text, out csCloudStorage.instance.m_PlayerInfoInPlayfab.Weight);
		int.TryParse(enterAge.text, out csCloudStorage.instance.m_PlayerInfoInPlayfab.Age);
		csCloudStorage.instance.UpdatePlayerInfo(delegate
		{
		});
	}

	private void SetOrderCallBack()
	{
		csPlayerOrderManager.instance.AddCallBackAction(RefreshOrder, RefreshOrder);
	}

	private void RemoveOrderCallBack()
	{
		csPlayerOrderManager.instance.RemoveCallBackAction(RefreshOrder, RefreshOrder);
	}

	public void setHeadIcon(int isSuc, Sprite _headIcon)
	{
		if (isSuc != 0)
		{
			headIcon.sprite = _headIcon;
		}
	}

	public void ReturnToMain()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
		csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: true);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: true);
	}

	private void OpenOrderManager()
	{
		csPlayerOrderManager.instance.OpenOrderManagerPanel();
	}

	private void setSelected()
	{
		for (int i = 0; i < selectedTabScripts.Length; i++)
		{
			selectedTabScripts[i].gameObject.SetActive(value: false);
		}
		List<SearchKeywords> likeTabs = csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs;
		for (int j = 0; j < Mathf.Min(selectedTabScripts.Length, likeTabs.Count); j++)
		{
			selectedTabScripts[j].gameObject.SetActive(value: true);
			selectedTabScripts[j].tabName.text = SerchKeyWordToName(likeTabs[j]);
			selectedTabScripts[j].tabName2.text = SerchKeyWordToName(likeTabs[j]);
			selectedTabScripts[j].keyword = likeTabs[j];
		}
	}

	public void AddSelectedByNum(int i)
	{
		if (csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Count < 4)
		{
			AddSelectedOne(showSelectNames[i + currentFirstNum]);
		}
	}

	public void AddSelectedOne(SearchKeywords name)
	{
		if (!csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Contains(name))
		{
			csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Add(name);
		}
		setSelected();
		setName(currentFirstNum);
		csCloudStorage.instance.UpdatePlayerInfo(delegate
		{
		});
	}

	public void deleteSelected(SearchKeywords keyword)
	{
		if (csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Contains(keyword))
		{
			csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Remove(keyword);
		}
		setSelected();
		setName(currentFirstNum);
		csCloudStorage.instance.UpdatePlayerInfo(delegate
		{
		});
	}

	private void setName(int num)
	{
		showSelectNames.Clear();
		for (int i = 0; i < canSelectTabNames.Count; i++)
		{
			if (!csCloudStorage.instance.m_PlayerInfoInPlayfab.LikeTabs.Contains(canSelectTabNames[i]))
			{
				showSelectNames.Add(canSelectTabNames[i]);
			}
		}
		if (showSelectNames.Count <= 4)
		{
			currentFirstNum = 0;
			for (int j = 0; j < selectLabel.Length; j++)
			{
				if (j < showSelectNames.Count)
				{
					selectObj[j].SetActive(value: true);
					selectLabel[j].text = SerchKeyWordToName(showSelectNames[j]);
					selectLabel2[j].text = SerchKeyWordToName(showSelectNames[j]);
				}
				else
				{
					selectObj[j].SetActive(value: false);
				}
			}
			changeBtn.SetActive(value: false);
			return;
		}
		for (int k = 0; k < selectLabel.Length; k++)
		{
			selectObj[k].SetActive(value: true);
			selectLabel[k].text = SerchKeyWordToName(showSelectNames[num]);
			selectLabel2[k].text = SerchKeyWordToName(showSelectNames[num]);
			if (++num >= showSelectNames.Count)
			{
				num = 0;
			}
		}
		changeBtn.SetActive(value: true);
	}

	public void refreshTab()
	{
		if (showSelectNames.Count > 4)
		{
			currentFirstNum++;
			if (currentFirstNum >= 4)
			{
				currentFirstNum = 0;
			}
			setName(currentFirstNum);
		}
	}

	private string SerchKeyWordToName(SearchKeywords key)
	{
		string result = "";
		switch (key)
		{
		case SearchKeywords.KeepFit:
			result = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel18");
			break;
		case SearchKeywords.LossWeight:
			result = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel19");
			break;
		case SearchKeywords.MakeBody:
			result = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel20");
			break;
		case SearchKeywords.DifEasy:
			result = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel27");
			break;
		case SearchKeywords.DifNormal:
			result = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel31");
			break;
		}
		return result;
	}

	public void RefreshOrder()
	{
		VIPIconObj.SetActive(csPlayerOrderManager.instance.IsOrdering());
	}
}
public class csMyInformationPanel : csPanelBase
{
	public enum InformationPanelType
	{
		History,
		Collection,
		Plan
	}

	public GameObject LevelPrefab;

	public Button setTarget;

	public GameObject mainBody;

	public GameObject setBody;

	public GameObject DataBody;

	public Transform LoadHisT;

	public Transform LoadCollectionT;

	public Button setClockInAimBtn;

	public Button returnToMuInformatin;

	public TextMeshProUGUI currentClockInAimT;

	public Button DataDetailBtn;

	public Button ReturnToMain;

	public GameObject HistoryPanel;

	public GameObject AchivimentPanel;

	public GameObject SportPlanPanel;

	public csVRButtonInMenu Historybtn;

	public csVRButtonInMenu Achivimentbtn;

	public csVRButtonInMenu SportPlanbtn;

	public List<csLevelItem> HisList_All = new List<csLevelItem>();

	public List<csLevelItem> CollectionList_All = new List<csLevelItem>();

	public List<GameSongData> InHisList;

	public List<GameSongData> InColList;

	public LineChart CalChart;

	public LineChart timeChart;

	public BarChart calBarChart;

	public BarChart timeBarChart;

	public Dictionary<InformationPanelType, csVRButtonInMenu> PanelSwitchBtnDic = new Dictionary<InformationPanelType, csVRButtonInMenu>();

	public Dictionary<InformationPanelType, GameObject> PanelsDic = new Dictionary<InformationPanelType, GameObject>();

	public csPageUpdownMain HistoryPageMan;

	public csPageUpdownMain CollectionPageMan;

	public csCalDetail calDetailPanel;

	private int currentAim = 4;

	public Button showCalChartBtn;

	public Button showTimeChartBtn;

	private bool showCalChart = true;

	private bool showTimeChart;

	public TextMeshProUGUI weeklySportTime;

	public TextMeshProUGUI weeklyTargetDays;

	public TextMeshProUGUI weeklyTargetCal;

	public TextMeshProUGUI targetDaysTip;

	public Image weeklyTargetDaysImg;

	public csVRButtonInMenu ShowNotFinishBtn;

	private bool onlyShowNotFinish;

	public List<csPlanLevelItem> ColPlan_All = new List<csPlanLevelItem>();

	public GameObject PlanLevelItem;

	public Transform LoadColPlanT;

	public csPageUpdownMain ColPlanPageMan;

	protected override void InitRef()
	{
		base.InitRef();
		setBody.SetActive(value: false);
		DataBody.SetActive(value: false);
		setTarget.onClick.AddListener(delegate
		{
			setBody.SetActive(value: true);
			mainBody.SetActive(value: false);
			DataBody.SetActive(value: false);
			setTargetDaysTip();
		});
		returnToMuInformatin.onClick.AddListener(delegate
		{
			setBody.SetActive(value: false);
			mainBody.SetActive(value: true);
		});
		DataDetailBtn.onClick.AddListener(delegate
		{
			CheckOrderToShowDetail();
		});
		ReturnToMain.onClick.AddListener(delegate
		{
			csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
		});
		PanelsDic.Add(InformationPanelType.History, HistoryPanel);
		PanelsDic.Add(InformationPanelType.Collection, AchivimentPanel);
		PanelsDic.Add(InformationPanelType.Plan, SportPlanPanel);
		PanelSwitchBtnDic.Add(InformationPanelType.History, Historybtn);
		PanelSwitchBtnDic.Add(InformationPanelType.Collection, Achivimentbtn);
		PanelSwitchBtnDic.Add(InformationPanelType.Plan, SportPlanbtn);
		Historybtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(InformationPanelType.History);
		});
		Achivimentbtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(InformationPanelType.Collection);
		});
		SportPlanbtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(InformationPanelType.Plan);
		});
		ShowNotFinishBtn.button.onClick.AddListener(delegate
		{
			ShowHisClass(formButton: true);
		});
		setClockInAimBtn.onClick.AddListener(delegate
		{
			setClockInAim();
			setBody.SetActive(value: false);
			mainBody.SetActive(value: true);
		});
		showCalChartBtn.onClick.AddListener(delegate
		{
			OnClickShowCalChartBtn();
		});
		showTimeChartBtn.onClick.AddListener(delegate
		{
			OnClickShowTimeChartBtn();
		});
		showCalChartBtn.gameObject.GetComponent<csVRButtonInMenu>().OnSelect();
		showTimeChartBtn.gameObject.GetComponent<csVRButtonInMenu>().DeSelect();
	}

	private void OnClickShowCalChartBtn()
	{
		if (!showCalChart)
		{
			showCalChart = !showCalChart;
			showTimeChart = !showTimeChart;
			setCalBarChartState(showCalChart);
			setTimeBarChartState(!showCalChart);
			showCalChartBtn.gameObject.GetComponent<csVRButtonInMenu>().OnSelect();
			showTimeChartBtn.gameObject.GetComponent<csVRButtonInMenu>().DeSelect();
		}
	}

	private void OnClickShowTimeChartBtn()
	{
		if (!showTimeChart)
		{
			showCalChart = !showCalChart;
			showTimeChart = !showTimeChart;
			setTimeBarChartState(showTimeChart);
			setCalBarChartState(!showTimeChart);
			showCalChartBtn.gameObject.GetComponent<csVRButtonInMenu>().DeSelect();
			showTimeChartBtn.gameObject.GetComponent<csVRButtonInMenu>().OnSelect();
		}
	}

	public void CheckOrderToShowDetail()
	{
		DataBody.SetActive(value: true);
		mainBody.SetActive(value: false);
		setBody.SetActive(value: false);
		csLevelChoosePanel.instance.downPanel.SetActive(value: false);
		calDetailPanel.ResetPage(calDetailPanel.defaultDateMode, calDetailPanel.defaultType, isReOpen: true);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{13:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.My_Details.ToString()
			}
		});
	}

	public void setClockInAim()
	{
		csCloudStorage.instance.changeClockInAimDays(currentAim, delegate
		{
			setWeekTargetPanel();
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.set_target, new Dictionary<string, object> { { "day", currentAim } });
		});
	}

	public void setChart(List<int> cals, List<int> times)
	{
		for (int i = 0; i < CalChart.series.Count; i++)
		{
			CalChart.series[i].ClearData();
		}
		for (int j = 0; j < cals.Count; j++)
		{
			CalChart.AddData(0, cals[j] / 1000 + ((cals[j] % 1000 != 0) ? 1 : 0));
		}
		timeChart.ClearData();
		for (int k = 0; k < times.Count; k++)
		{
			timeChart.AddData(0, times[k]);
		}
		CalChart.AnimationFadeIn();
		timeChart.AnimationFadeIn();
		CalChart.enabled = true;
		timeChart.enabled = true;
	}

	public void setCalChartState(bool isShow)
	{
		CalChart.GetOrAddChartComponent<YAxis>().show = isShow;
		CalChart.series[0].show = isShow;
		CalChart.AnimationFadeIn();
	}

	public void setTimeChartState(bool isShow)
	{
		timeChart.gameObject.SetActive(isShow);
		timeChart.AnimationFadeIn();
	}

	public void setBarChart(List<int> cals, List<int> times)
	{
		for (int i = 0; i < calBarChart.series.Count; i++)
		{
			calBarChart.series[i].ClearData();
		}
		for (int j = 0; j < cals.Count; j++)
		{
			calBarChart.AddData(0, cals[j] / 1000 + ((cals[j] % 1000 != 0) ? 1 : 0));
		}
		timeBarChart.ClearData();
		for (int k = 0; k < times.Count; k++)
		{
			timeBarChart.AddData(0, times[k]);
		}
		calBarChart.AnimationFadeIn();
		timeBarChart.AnimationFadeIn();
		calBarChart.enabled = true;
		timeBarChart.enabled = true;
	}

	public void setCalBarChartState(bool isShow)
	{
		calBarChart.GetOrAddChartComponent<YAxis>().show = isShow;
		calBarChart.series[0].show = isShow;
		calBarChart.AnimationFadeIn();
	}

	public void setTimeBarChartState(bool isShow)
	{
		timeBarChart.gameObject.SetActive(isShow);
		timeBarChart.AnimationFadeIn();
	}

	public void changeAimDays(bool add)
	{
		if (add)
		{
			if (currentAim < 7)
			{
				currentAim++;
				currentClockInAimT.text = currentAim.ToString();
			}
		}
		else if (currentAim > 1)
		{
			currentAim--;
			currentClockInAimT.text = currentAim.ToString();
		}
	}

	public override void Open()
	{
		base.Open();
		onlyShowNotFinish = false;
		ShowNotFinishBtn.DeSelect();
		ShowColClass();
		ShowHisClass();
		ShowColPlan();
		currentAim = csCloudStorage.instance.m_PlayerClockInData.aim;
		currentClockInAimT.text = currentAim.ToString();
		setWeekTargetPanel();
		setChartPanel();
		DataBody.SetActive(value: false);
		setBody.SetActive(value: false);
		mainBody.SetActive(value: true);
	}

	private void setTargetDaysTip()
	{
		targetDaysTip.text = $"您现在的目标为每周打卡{csCloudStorage.instance.m_PlayerClockInData.aim.ToString()}次";
	}

	public void setWeekTargetPanel()
	{
		csCloudSettings.InitDateTime(delegate
		{
			float num = 0f;
			float num2 = 0f;
			int num3 = 0;
			int num4 = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
			if (num4 < 0)
			{
				num4 = 6;
			}
			DateTime time = csCloudSettings.GetNowTime().AddDays(-num4);
			for (int i = 0; i < 7; i++)
			{
				daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
				if (careerDataByDate != null)
				{
					if (careerDataByDate.playTime != float.NaN)
					{
						num += careerDataByDate.playTime;
						num /= 60f;
					}
					if (careerDataByDate.cal != float.NaN)
					{
						num2 += careerDataByDate.cal;
					}
				}
				if (csCloudStorage.instance.m_PlayerClockInData.isClockIn(time))
				{
					num3++;
				}
				time = time.AddDays(1.0);
			}
			weeklyTargetDays.text = $"<size=19><color=#29F8FF>{num3.ToString()}</color></size><size=16> / </size><size=19>{csCloudStorage.instance.m_PlayerClockInData.aim}</size>";
			weeklyTargetDaysImg.material = new Material(weeklyTargetDaysImg.material);
			weeklyTargetDaysImg.material.SetFloat("_Progress", (float)num3 / (float)csCloudStorage.instance.m_PlayerClockInData.aim);
			weeklySportTime.text = $"<color=#00FFDE>{(int)num}</color>";
			weeklyTargetCal.text = $"<color=#FFDF61>{(int)(num2 / 1000f)}</color>";
		});
	}

	public void setChartPanel()
	{
		showCalChart = true;
		showTimeChart = false;
		setCalBarChartState(showCalChart);
		setTimeBarChartState(showTimeChart);
		for (int i = 0; i < CalChart.series.Count; i++)
		{
			CalChart.series[i].ClearData();
		}
		timeChart.ClearData();
		csCloudSettings.InitDateTime(delegate
		{
			List<int> list = new List<int>();
			List<int> list2 = new List<int>();
			int num = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
			if (num < 0)
			{
				num = 6;
			}
			DateTime time = csCloudSettings.GetNowTime().AddDays(-num);
			for (int j = 0; j < 7; j++)
			{
				daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(time);
				if (careerDataByDate != null)
				{
					list2.Add((int)careerDataByDate.cal);
					list.Add((int)careerDataByDate.playTime / 60 + 1);
				}
				else
				{
					list2.Add(0);
					list.Add(0);
				}
				time = time.AddDays(1.0);
			}
			setChart(list2, list);
			setBarChart(list2, list);
		});
	}

	private void ShowHisClass(bool formButton = false)
	{
		foreach (csLevelItem item in HisList_All)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		HisList_All.Clear();
		InHisList.Clear();
		if (formButton)
		{
			if (onlyShowNotFinish)
			{
				ShowNotFinishBtn.DeSelect();
			}
			else
			{
				ShowNotFinishBtn.OnSelect();
			}
			onlyShowNotFinish = !onlyShowNotFinish;
		}
		for (int i = 0; i < csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList.Count; i++)
		{
			if (GameData.instance.GetSongDataByClassID(csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList[i].ClassID) != null && (!formButton || !onlyShowNotFinish || csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList[i].HistoryState != ClassHistoryState.Finished))
			{
				InHisList.Add(GameData.instance.GetSongDataByClassID(csCloudStorage.instance.m_PlayerClassHistoryData.HistoryClassList[i].ClassID));
				csLevelItem component = UnityEngine.Object.Instantiate(LevelPrefab, LoadHisT).GetComponent<csLevelItem>();
				component.IntiSongData(InHisList[InHisList.Count - 1], "PlayerHistory");
				HisList_All.Add(component);
			}
		}
		HistoryPageMan.Totalpage = HisList_All.Count / 8 + ((HisList_All.Count % 8 != 0) ? 1 : 0);
		HistoryPageMan.SetToPage(0);
	}

	private void ShowColClass()
	{
		foreach (csLevelItem item in CollectionList_All)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		CollectionList_All.Clear();
		InColList.Clear();
		for (int i = 0; i < csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList.Count; i++)
		{
			if (GameData.instance.GetSongDataByClassID(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList[i].ClassID) != null)
			{
				InColList.Add(GameData.instance.GetSongDataByClassID(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionClassList[i].ClassID));
				csLevelItem component = UnityEngine.Object.Instantiate(LevelPrefab, LoadCollectionT).GetComponent<csLevelItem>();
				component.IntiSongData(InColList[i], "PlayerCollec");
				CollectionList_All.Add(component);
				component.LikeButton.button.onClick.AddListener(ShowColClass);
			}
		}
		if (CollectionList_All.Count == 0)
		{
			CollectionPageMan.Totalpage = 0;
		}
		else
		{
			CollectionPageMan.Totalpage = CollectionList_All.Count / 8 + ((CollectionList_All.Count % 8 != 0) ? 1 : 0);
		}
		CollectionPageMan.SetToPage(0);
	}

	private void ShowColPlan()
	{
		foreach (csPlanLevelItem item in ColPlan_All)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		ColPlan_All.Clear();
		int i;
		for (i = 0; i < csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Count; i++)
		{
			if (csCloudSettings.sportPlanDatas.list.Find((SportPlanData x) => x.PlanID == csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList[i]) != null)
			{
				csPlanLevelItem component = UnityEngine.Object.Instantiate(PlanLevelItem, LoadColPlanT).GetComponent<csPlanLevelItem>();
				component.Init(csCloudSettings.sportPlanDatas.list.Find((SportPlanData x) => x.PlanID == csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList[i]));
				ColPlan_All.Add(component);
				component.transform.localPosition = Vector3.zero;
				component.likeBtn.button.onClick.AddListener(ShowColPlan);
				if (i % 2 == 0)
				{
					component.BgMaskImage.sprite = component.OrangeBgMaskSprite;
					component.FrontMaskImage.sprite = component.OrangeFrontMaskSprite;
				}
				else
				{
					component.BgMaskImage.sprite = component.PurpleBgMaskSprite;
					component.FrontMaskImage.sprite = component.PurpleFrontMaskSprite;
				}
			}
		}
		ColPlanPageMan.Totalpage = ColPlan_All.Count / 4 + ((ColPlan_All.Count % 4 != 0) ? 1 : 0);
		ColPlanPageMan.SetToPage(0);
	}

	private void SwitchToPanel(InformationPanelType gruopType)
	{
		int num = 0;
		string value = "";
		csMainMenuManager.instance.ClosePanel(PanelType.ClassDetail);
		foreach (csVRButtonInMenu value2 in PanelSwitchBtnDic.Values)
		{
			value2.DeSelect();
		}
		PanelSwitchBtnDic[gruopType].OnSelect();
		foreach (GameObject value3 in PanelsDic.Values)
		{
			value3.SetActive(value: false);
		}
		PanelsDic[gruopType].SetActive(value: true);
		switch (gruopType)
		{
		case InformationPanelType.History:
		{
			for (int j = 0; j < HisList_All.Count; j++)
			{
				HisList_All[j].resetLevelItemLikeState();
			}
			num = 10;
			value = ButtonTrackingClick.My_History.ToString();
			break;
		}
		case InformationPanelType.Collection:
		{
			ShowColClass();
			for (int i = 0; i < CollectionList_All.Count; i++)
			{
				CollectionList_All[i].resetLevelItemLikeState();
			}
			num = 11;
			value = ButtonTrackingClick.My_Collect.ToString();
			break;
		}
		case InformationPanelType.Plan:
			ShowColPlan();
			num = 12;
			value = ButtonTrackingClick.My_ExerciseProgram.ToString();
			break;
		}
		PanelsDic[gruopType].GetComponent<CanvasGroup>().alpha = 0f;
		PanelsDic[gruopType].GetComponent<CanvasGroup>().DOFade(1f, 0.6f);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{num:000}"
			},
			{ "button_name", value }
		});
	}

	private void Start()
	{
		SwitchToPanel(InformationPanelType.Collection);
	}
}
public class csOfflineTipPanel : csPanelBase
{
	public TextMeshProUGUI disconnectReason;

	public GameObject disconnectPanel;

	public GameObject restartGamePanel;

	public GameObject connectingPanel;

	public Button refreshBtn;

	public Button closeBtn;

	public Button restartGame;

	private UnityAction OnTrySuccess;

	private int counter;

	private void Awake()
	{
		InitRef();
		restartGame.onClick.AddListener(delegate
		{
			Application.Quit();
		});
	}

	public override void Open(string message)
	{
		switch (message)
		{
		case "0":
			disconnectReason.text = csLocalizationManager.Instance.GetLocalText("csOfflineTipPanel01");
			break;
		case "1":
			disconnectReason.text = csLocalizationManager.Instance.GetLocalText("csOfflineTipPanel02");
			break;
		}
		base.Open(message);
		csLevelChoosePanel.instance.playerinfotitle.SetActive(value: false);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
		csGameSettings.isLoading = false;
		disconnectPanel.SetActive(value: true);
		if (counter >= 3)
		{
			disconnectPanel.SetActive(value: false);
			restartGamePanel.SetActive(value: true);
			connectingPanel.SetActive(value: false);
		}
		else
		{
			restartGamePanel.SetActive(value: false);
			connectingPanel.SetActive(value: false);
		}
	}

	public void setRetryAction(UnityAction ReTryAction, UnityAction closeAction, UnityAction OnRetrySuccess)
	{
		counter++;
		if (counter > 3)
		{
			disconnectPanel.SetActive(value: false);
			restartGamePanel.SetActive(value: true);
			connectingPanel.SetActive(value: false);
			return;
		}
		refreshBtn.onClick.RemoveAllListeners();
		refreshBtn.onClick.AddListener(delegate
		{
			disconnectPanel.SetActive(value: false);
			restartGamePanel.SetActive(value: false);
			connectingPanel.SetActive(value: true);
		});
		refreshBtn.onClick.AddListener(ReTryAction);
		closeBtn.onClick.RemoveAllListeners();
		closeBtn.onClick.AddListener(closeAction);
		OnTrySuccess = OnRetrySuccess;
	}

	public void OnRetryCallBack(bool isSuccess)
	{
		if (!isSuccess)
		{
			disconnectPanel.SetActive(value: true);
			UnityEngine.Debug.LogError("  restartGamePanel.SetActive(false);");
			restartGamePanel.SetActive(value: false);
			connectingPanel.SetActive(value: false);
		}
		else
		{
			counter = 0;
			csMainMenuManager.instance.ClosePanel();
			OnTrySuccess?.Invoke();
		}
	}
}
public class csPageDotInLevelChoose : MonoBehaviour
{
	public Button thisBtn;

	public Image DotOn;

	private csLevelChoosePanel parentPanel;

	private int DotPage;

	public void InitDot(csLevelChoosePanel pp, int page)
	{
		parentPanel = pp;
		DotPage = page;
		thisBtn.onClick.AddListener(SetToPage);
	}

	private void SetToPage()
	{
	}

	public void SetPageDotOn(bool isOn)
	{
		DotOn.enabled = isOn;
	}
}
public class csPageUpdownMain : MonoBehaviour
{
	public csPageMoveTrigger pageMoveTrigger;

	public RectTransform Page;

	public GameObject pageContent;

	public int Totalpage = 3;

	public int Curpage;

	public Button PageDownBtn;

	public Button PageUpBtn;

	public TextMeshProUGUI PageDetail;

	public float pageStartOffset;

	public float pageMoveDis = 930f;

	public float FirstPageOffset;

	public bool isActualPage;

	private Tweener tweener;

	private bool isPagedown = true;

	private bool isTurning;

	private void Awake()
	{
		PageDownBtn.onClick.AddListener(PageDown);
		PageUpBtn.onClick.AddListener(PageUp);
		if (pageMoveTrigger != null)
		{
			csPageMoveTrigger obj = pageMoveTrigger;
			obj.OnPageDownAct = (UnityAction)Delegate.Combine(obj.OnPageDownAct, new UnityAction(PageDown));
			csPageMoveTrigger obj2 = pageMoveTrigger;
			obj2.OnPageUpAct = (UnityAction)Delegate.Combine(obj2.OnPageUpAct, new UnityAction(PageUp));
		}
	}

	private void OnEnable()
	{
	}

	public void PageDown()
	{
		if (Curpage < Totalpage - 1)
		{
			isPagedown = true;
			SetToPage(Curpage + 1);
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{9:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.OverallRankingPageDown.ToString()
			}
		});
	}

	public void PageUp()
	{
		if (Curpage > 0)
		{
			isPagedown = false;
			SetToPage(Curpage - 1);
		}
	}

	public void SetToPage(int p)
	{
		if (!isActualPage)
		{
			Curpage = p;
			PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (Curpage + 1) : 0, "/", Totalpage);
			tweener = Page.DOLocalMoveY(((Curpage == 0) ? 0f : FirstPageOffset) + pageStartOffset + (float)Curpage * pageMoveDis, 0.7f);
		}
		else if ((bool)pageContent && pageContent.GetComponent<IPageContent>() != null && !isTurning)
		{
			isTurning = true;
			Curpage = p;
			PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (Curpage + 1) : 0, "/", Totalpage);
			Vector3 lastPosition = Page.position;
			float endValue = lastPosition.y + (isPagedown ? pageMoveDis : (0f - pageMoveDis));
			tweener = Page.DOLocalMoveY(endValue, 0.7f);
			tweener.OnComplete(delegate
			{
				pageContent.GetComponent<IPageContent>().GetContentByPageIdx(p);
				StartCoroutine(SetPagePostion(lastPosition));
			});
		}
	}

	public void SetPageWithoutDOT(int p)
	{
		if (tweener != null && tweener.IsPlaying())
		{
			tweener.Kill();
		}
		Curpage = p;
		PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (Curpage + 1) : 0, "/", Totalpage);
		Vector3 localPosition = Page.transform.localPosition;
		localPosition.y = ((Curpage == 0) ? 0f : FirstPageOffset) + pageStartOffset + (float)Curpage * pageMoveDis;
		Page.transform.localPosition = localPosition;
	}

	public void SetTotalpage(int totalpage)
	{
		Totalpage = totalpage;
		SetToPage(0);
	}

	public void ResetPage()
	{
		Curpage = 0;
		UpdatePageText();
	}

	public void UpdatePageText()
	{
		PageDetail.text = string.Format("{0}{1}{2}", (Totalpage != 0) ? (Curpage + 1) : 0, "/", Totalpage);
	}

	private IEnumerator SetPagePostion(Vector3 position)
	{
		yield return new WaitForSeconds(0.4f);
		Page.position = position;
		isTurning = false;
	}
}
public class csPersonalPlanPanel : MonoBehaviour
{
	public TextMeshProUGUI checkInDaysOfWeek;

	public TextMeshProUGUI weeklyTargetDays;

	public TextMeshProUGUI dayCalText;

	public TextMeshProUGUI dayCalPlan;

	public TextMeshProUGUI dayTimeText;

	public TextMeshProUGUI dayTimePlan;

	public Button changeAimBtn;

	public Image calCircleFillImg;

	public Image timeCircleFillImg;

	public List<Image> CheckInSuccessImg;

	public Image faceImg;

	public TextMeshProUGUI text;

	[Header("预设玩家目标卡路里(Kcal)/运动时间(min)")]
	public int perTargetDayCal = 400;

	public int perTargetDayTime = 20;

	public GameObject setTargetBody;

	public GameObject middlePanel;

	public TextMeshProUGUI targetDaysTip;

	public TextMeshProUGUI currentClockInAimT;

	public csLevelChoosePanel csLevelChoosePanel;

	private bool closedownPanelFlag;

	private int currentAim = 4;

	public void SetCheckInDaysOfWeek()
	{
		int targetDayCal = perTargetDayCal;
		int targetDayTime = perTargetDayTime;
		csCloudSettings.InitDateTime(delegate
		{
			float num = 0f;
			float num2 = 0f;
			DateTime nowTime = csCloudSettings.GetNowTime();
			daySportInfoData careerDataByDate = csCloudStorage.instance.m_PlayerCareerSportData.getCareerDataByDate(nowTime);
			if (careerDataByDate != null)
			{
				if (careerDataByDate.playTime != float.NaN)
				{
					num = (int)Mathf.Ceil(careerDataByDate.playTime / 60f);
				}
				if (careerDataByDate.cal != float.NaN)
				{
					num2 = (int)Mathf.Ceil(careerDataByDate.cal / 1000f);
				}
			}
			dayCalText.text = num2.ToString();
			dayTimeText.text = num.ToString();
			int num3 = 0;
			int num4 = (int)(csCloudSettings.GetNowTime().DayOfWeek - 1);
			if (num4 < 0)
			{
				num4 = 6;
			}
			DateTime time = csCloudSettings.GetNowTime().AddDays(-num4);
			for (int i = 0; i < 7; i++)
			{
				if (csCloudStorage.instance.m_PlayerClockInData.isClockIn(time))
				{
					CheckInSuccessImg[i].enabled = true;
					num3++;
				}
				else
				{
					CheckInSuccessImg[i].enabled = false;
				}
				time = time.AddDays(1.0);
			}
			checkInDaysOfWeek.text = num3.ToString();
			weeklyTargetDays.text = csCloudStorage.instance.m_PlayerClockInData.aim.ToString();
			dayCalPlan.text = targetDayCal.ToString();
			dayTimePlan.text = targetDayTime.ToString();
			calCircleFillImg.fillAmount = ((targetDayCal != 0) ? (num2 / (float)targetDayCal) : 0f);
			timeCircleFillImg.fillAmount = ((targetDayTime != 0) ? (num / (float)targetDayTime) : 0f);
		});
	}

	public void OnClickChangeAimBtn()
	{
		setTargetBody.SetActive(value: true);
		middlePanel.SetActive(value: false);
		if (csLevelChoosePanel.downPanel.activeSelf)
		{
			closedownPanelFlag = true;
			csLevelChoosePanel.downPanel.SetActive(value: false);
		}
		currentClockInAimT.text = currentAim.ToString();
		targetDaysTip.text = $"您现在的目标为每周打卡{csCloudStorage.instance.m_PlayerClockInData.aim.ToString()}次";
	}

	public void CloseChangeAimPanel()
	{
		setTargetBody.SetActive(value: false);
		middlePanel.SetActive(value: true);
		if (closedownPanelFlag)
		{
			csLevelChoosePanel.downPanel.SetActive(value: true);
			closedownPanelFlag = false;
		}
	}

	public void changeAimDays(bool add)
	{
		if (add)
		{
			if (currentAim < 7)
			{
				currentAim++;
				currentClockInAimT.text = currentAim.ToString();
			}
		}
		else if (currentAim > 1)
		{
			currentAim--;
			currentClockInAimT.text = currentAim.ToString();
		}
	}

	public void setClockInAim()
	{
		csCloudStorage.instance.changeClockInAimDays(currentAim, delegate
		{
			CloseChangeAimPanel();
			SetCheckInDaysOfWeek();
			csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.set_target, new Dictionary<string, object> { { "day", currentAim } });
		});
	}
}
public class csPlanDetailPanel : csPanelBase
{
	public Transform Content;

	public float PageUpDis;

	private int currentPage = 1;

	private int maxPage = 1;

	public TextMeshProUGUI Title;

	public TextMeshProUGUI Detail;

	public TextMeshProUGUI coach1;

	public TextMeshProUGUI coach2;

	public TextMeshProUGUI planDays;

	public Image titleIMG;

	public Image coachImg1;

	public Image coachImg2;

	public List<csLevelItem> levelItems;

	public GameObject levelItemPrefab;

	public string currentID;

	public Image ColumnBanner;

	public TextMeshProUGUI ColumnName;

	public GameObject columnObjects;

	public GameObject planObjects;

	public List<SportPlanClassData> PlanClasses = new List<SportPlanClassData>();

	public csPageUpdownMain pageUpdownMain;

	public bool backToPlan = true;

	public bool backToMyInfo;

	public GameObject collectStar;

	public csVRButtonInMenu collectBtn;

	public void setPanel(string titleImg, string title, string detail, string id, List<SportPlanClassData> planClassInfo, bool isBackToMyInfo = false)
	{
		planObjects.SetActive(value: true);
		backToPlan = true;
		backToMyInfo = isBackToMyInfo;
		PlanClasses = planClassInfo;
		titleIMG.sprite = csIDImageIconManager.instance.GetImgByID(titleImg);
		Title.text = title;
		Detail.text = detail;
		currentID = id;
		csTagsMgr.instance.setSelect(csTagsMgr.instance.PlanBtn);
		planDays.text = planClassInfo.Count + "天";
		for (int i = 0; i < levelItems.Count; i++)
		{
			UnityEngine.Object.Destroy(levelItems[i].gameObject);
		}
		levelItems.Clear();
		List<string> list = new List<string>();
		for (int j = 0; j < planClassInfo.Count; j++)
		{
			for (int k = 0; k < planClassInfo[j].classIDs.Count; k++)
			{
				list.Add(planClassInfo[j].classIDs[k]);
			}
		}
		coach1.text = GameData.instance.GetSongDataByClassID(list[0]).CaochName;
		coach2.text = GameData.instance.GetSongDataByClassID(list[1]).CaochName;
		coachImg1.sprite = csIDImageIconManager.instance.GetImgByID(GameData.instance.GetSongDataByClassID(list[0]).CoachImgID);
		coachImg2.sprite = csIDImageIconManager.instance.GetImgByID(GameData.instance.GetSongDataByClassID(list[1]).CoachImgID);
		for (int l = 0; l < planClassInfo.Count; l++)
		{
			for (int m = 0; m < planClassInfo[l].classIDs.Count; m++)
			{
				csLevelItem component = UnityEngine.Object.Instantiate(levelItemPrefab).GetComponent<csLevelItem>();
				levelItems.Add(component);
				component.IntiSongData(GameData.instance.GetSongDataByClassID(planClassInfo[l].classIDs[m]), "ExerciseProgram", planClassInfo[l].dayIndex);
				component.transform.parent = Content;
				component.transform.localPosition = Vector3.zero;
				component.transform.localScale = Vector3.one;
			}
		}
		maxPage = levelItems.Count / 8 + 1 + ((levelItems.Count % 8 != 0) ? 1 : 0);
		pageUpdownMain.Totalpage = maxPage;
	}

	public override void Open()
	{
		base.Open();
		collectBtn.button.onClick.RemoveAllListeners();
		collectBtn.button.onClick.AddListener(setPlanToCollection);
		setStar(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(currentID));
	}

	public void setPanel(string titleImg, string title, List<string> classIDs)
	{
		planObjects.SetActive(value: false);
		backToPlan = false;
		ColumnBanner.sprite = csIDImageIconManager.instance.GetImgByID(titleImg);
		ColumnName.text = title;
		for (int i = 0; i < levelItems.Count; i++)
		{
			UnityEngine.Object.Destroy(levelItems[i].gameObject);
		}
		levelItems.Clear();
		for (int j = 0; j < classIDs.Count; j++)
		{
			csLevelItem component = UnityEngine.Object.Instantiate(levelItemPrefab).GetComponent<csLevelItem>();
			levelItems.Add(component);
			component.IntiSongData(GameData.instance.GetSongDataByClassID(classIDs[j]), "SpecialColumn");
			component.transform.parent = Content;
			component.transform.localPosition = Vector3.zero;
			component.transform.localScale = Vector3.one;
		}
		maxPage = levelItems.Count / 8 + 1 + ((levelItems.Count % 8 != 0) ? 1 : 0);
		pageUpdownMain.Totalpage = maxPage;
	}

	public void BackToMainMenu()
	{
		if (backToPlan)
		{
			if (backToMyInfo)
			{
				csMainMenuManager.instance.OpenPanel(PanelType.MyInformation);
				csTagsMgr.instance.setSelect(csTagsMgr.instance.MyBtn);
			}
			else
			{
				csMainMenuManager.instance.OpenPanel(PanelType.Plan);
				csTagsMgr.instance.setSelect(csTagsMgr.instance.PlanBtn);
			}
		}
		else
		{
			csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
			csTagsMgr.instance.setSelect(csTagsMgr.instance.ExploreBtn);
		}
	}

	private void setPlanToCollection()
	{
		csCloudStorage.instance.SetPlanAsCollection(currentID);
		setStar(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(currentID));
	}

	private void setStar(bool isCollected)
	{
		collectStar.SetActive(isCollected);
	}
}
public class csPlanLevelItem : MonoBehaviour
{
	public csVRButtonInMenu likeBtn;

	public GameObject collectStar;

	public bool isInited;

	public TextMeshProUGUI PlanName;

	public Image PlanContentImage;

	public SportPlanData thisPlanInfo;

	public Image BgMaskImage;

	public Image FrontMaskImage;

	public Sprite OrangeBgMaskSprite;

	public Sprite OrangeFrontMaskSprite;

	public Sprite PurpleBgMaskSprite;

	public Sprite PurpleFrontMaskSprite;

	private bool isFormCol;

	public void setStar(bool isCollected)
	{
		if (isCollected)
		{
			likeBtn.OnSelect();
		}
		else
		{
			likeBtn.DeSelect();
		}
	}

	public void Init(SportPlanData sp, bool isCol = false)
	{
		isInited = true;
		thisPlanInfo = sp;
		likeBtn.button.onClick.AddListener(setPlanToCollection);
		PlanContentImage.sprite = csIDImageIconManager.instance.GetImgByID(sp.ImageID);
		PlanName.text = sp.NameID;
		isFormCol = isCol;
		setStar(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(sp.PlanID));
	}

	private void setPlanToCollection()
	{
		csCloudStorage.instance.SetPlanAsCollection(thisPlanInfo.PlanID);
		setStar(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(thisPlanInfo.PlanID));
	}

	public void OpenPlanPanel()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.SpColumn);
		csMainMenuManager.instance.planDetailPanel.setPanel(thisPlanInfo.ImageID, thisPlanInfo.NameID, thisPlanInfo.DetailID, thisPlanInfo.PlanID, thisPlanInfo.ClassIDs);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_ExerciseProgram_{thisPlanInfo.PlanID}"
			},
			{
				"button_name",
				ButtonTrackingClick.ExerciseProgram_.ToString() + thisPlanInfo.NameID
			}
		});
	}
}
public class csPlanPanel : csPanelBase
{
	private List<csPlanLevelItem> PlanLevelItems = new List<csPlanLevelItem>();

	public GameObject PlanLevelPrefab;

	public Transform Content;

	private int maxPage = 1;

	public csPageUpdownMain pageUpdownMain;

	public void SetPlanPanel()
	{
		PlanLevelItems.Clear();
		for (int i = 0; i < csCloudSettings.sportPlanDatas.list.Count; i++)
		{
			csPlanLevelItem component = UnityEngine.Object.Instantiate(PlanLevelPrefab).GetComponent<csPlanLevelItem>();
			PlanLevelItems.Add(component);
			component.Init(csCloudSettings.sportPlanDatas.list[i]);
			component.transform.parent = Content;
			component.transform.localPosition = Vector3.zero;
			component.transform.localRotation = Quaternion.identity;
			component.transform.localScale = Vector3.one;
			if (i % 2 == 0)
			{
				component.BgMaskImage.sprite = component.OrangeBgMaskSprite;
				component.FrontMaskImage.sprite = component.OrangeFrontMaskSprite;
			}
			else
			{
				component.BgMaskImage.sprite = component.PurpleBgMaskSprite;
				component.FrontMaskImage.sprite = component.PurpleFrontMaskSprite;
			}
		}
		Content.transform.localPosition = Vector3.zero;
		maxPage = ((PlanLevelItems.Count / 4 + 1 + PlanLevelItems.Count % 4 != 0) ? 1 : 0);
		pageUpdownMain.Totalpage = maxPage;
	}

	public override void Open()
	{
		base.Open();
		for (int i = 0; i < PlanLevelItems.Count; i++)
		{
			PlanLevelItems[i].setStar(csCloudStorage.instance.m_PlayerClassHistoryData.CollectionPlanList.Contains(PlanLevelItems[i].thisPlanInfo.PlanID));
		}
	}

	private IEnumerator Start()
	{
		while (csLogin.instance == null || !csLogin.instance.isGetPlayfabData)
		{
			yield return null;
		}
		SetPlanPanel();
	}
}
public class csPlayerInfoPanel : MonoBehaviour
{
	public Image HeadIcon;

	public TextMeshProUGUI nickName;

	public GameObject OrderIcon;

	private IEnumerator Start()
	{
		while (!csPlayerPicoDataManager.instance.isGetInfo)
		{
			yield return new WaitForSeconds(0.1f);
		}
		csPlayfabServer.Instance.StartGetAvatar(csPlayfabServer.Instance.PlayfabID, csPlayerPicoDataManager.instance.m_PicoAccountInfo.headIconURL, setHeadIcon);
	}

	public void setHeadIcon(int isSuc, Sprite _headIcon)
	{
		if (isSuc != 0)
		{
			setPlayrInfo(_headIcon, csPlayerPicoDataManager.instance.m_PicoAccountInfo.picoNickName);
		}
	}

	public void setPlayrInfo(Sprite headIcon, string Name)
	{
		nickName.text = Name;
		HeadIcon.sprite = headIcon;
	}

	public void ShowOrderIcon(bool isShow)
	{
		OrderIcon.SetActive(isShow);
	}
}
public class csPlayerUIItemInMulti : MonoBehaviour
{
	public GameObject ThisG;

	public GameObject MineBoarder;

	public GameObject OthersBoarder;

	public TextMeshProUGUI PlayerName;

	public Image PlayerHeadIcon;

	public void SetPlayerOn(bool IsOn)
	{
		ThisG.SetActive(IsOn);
	}

	public void InitPlayerInfo(string name, bool isMine, string HeadIconUrl)
	{
		MineBoarder.SetActive(isMine);
		OthersBoarder.SetActive(!isMine);
		PlayerName.text = name;
		csPlayfabServer.Instance.StartGetAvatar(csPlayfabServer.Instance.PlayfabID, csPlayerPicoDataManager.instance.m_PicoAccountInfo.headIconURL, setHeadIcon);
	}

	public void setHeadIcon(int isSuc, Sprite _headIcon)
	{
		if (isSuc != 0)
		{
			PlayerHeadIcon.sprite = _headIcon;
		}
	}
}
public class csRecommandInMainMgr : MonoBehaviour
{
	public csPageMoveTrigger pageTrigger;

	public List<string> ClassIDs = new List<string>();

	public List<string> PlanIDs = new List<string>();

	public List<string> BrandIDs = new List<string>();

	public List<string> TutorialIDs = new List<string>();

	public List<BannerType> BannerTypes = new List<BannerType>();

	[Space(5f)]
	public List<int> reclist_ClassID;

	public GameObject LevelRec_Prefab;

	public Transform GroupT;

	public int Totalpage = 3;

	public int Curpage;

	public Button PageLBtn;

	public Button PageRBtn;

	public Transform DotGroup;

	public GameObject Dot;

	public List<Image> DotGroupList;

	public Sprite GreyDot;

	public Sprite YellowDot;

	public csIngamePanelProcessMan ProcessPoint;

	public List<csBannerItem> recInMain;

	public float pageWidth = -1342f;

	public float offset;

	private void Start()
	{
		PageRBtn.onClick.AddListener(PageRight);
		PageLBtn.onClick.AddListener(PageLeft);
		csPageMoveTrigger obj = pageTrigger;
		obj.OnPageLeftAct = (UnityAction)Delegate.Combine(obj.OnPageLeftAct, new UnityAction(PageLeft));
		csPageMoveTrigger obj2 = pageTrigger;
		obj2.OnPageRightAct = (UnityAction)Delegate.Combine(obj2.OnPageRightAct, new UnityAction(PageRight));
	}

	public void InitDot(int dotnum)
	{
		Image original = new GameObject("Dot").AddComponent<Image>();
		for (int i = 0; i < dotnum; i++)
		{
			Image component = UnityEngine.Object.Instantiate(original, DotGroup).GetComponent<Image>();
			component.name = $"Dot_{i}";
			component.transform.localScale = Vector3.one * 0.2f;
			DotGroupList.Add(component);
		}
	}

	public void InitRecommandClassInMain()
	{
		Totalpage = 0;
		for (int j = 0; j < BannerTypes.Count; j++)
		{
			switch (BannerTypes[j])
			{
			case BannerType.SpColumn:
			{
				Totalpage += csCloudSettings.titleDatas.list.Count;
				for (int l = 0; l < csCloudSettings.titleDatas.list.Count; l++)
				{
					csBannerItem component2 = UnityEngine.Object.Instantiate(LevelRec_Prefab, GroupT).GetComponent<csBannerItem>();
					component2.setSpColumnBanner(new List<string>(csCloudSettings.titleDatas.list[l].ClassGroup), csCloudSettings.titleDatas.list[l].TitleID, csCloudSettings.titleDatas.list[l].BannerID);
					recInMain.Add(component2);
				}
				break;
			}
			case BannerType.Class:
			{
				Totalpage += ClassIDs.Count;
				for (int n = 0; n < ClassIDs.Count; n++)
				{
					csBannerItem component4 = UnityEngine.Object.Instantiate(LevelRec_Prefab, GroupT).GetComponent<csBannerItem>();
					component4.setClassBanner(ClassIDs[n]);
					recInMain.Add(component4);
				}
				break;
			}
			case BannerType.Plan:
			{
				Totalpage += PlanIDs.Count;
				int i;
				for (i = 0; i < PlanIDs.Count; i++)
				{
					csBannerItem component5 = UnityEngine.Object.Instantiate(LevelRec_Prefab, GroupT).GetComponent<csBannerItem>();
					component5.setPlanBanner(PlanIDs[i], csIDImageIconManager.instance.GetImgByID(csCloudSettings.sportPlanDatas.list.Find((SportPlanData x) => x.PlanID == PlanIDs[i]).ImageID + "L"));
					recInMain.Add(component5);
				}
				break;
			}
			case BannerType.Brand:
			{
				Totalpage += BrandIDs.Count;
				for (int m = 0; m < BrandIDs.Count; m++)
				{
					csBannerItem component3 = UnityEngine.Object.Instantiate(LevelRec_Prefab, GroupT).GetComponent<csBannerItem>();
					component3.setBrandBanner(BrandIDs[m], csIDImageIconManager.instance.GetImgByID(BrandIDs[m]));
					recInMain.Add(component3);
				}
				break;
			}
			case BannerType.TutorialEnterance:
			{
				Totalpage += TutorialIDs.Count;
				for (int k = 0; k < TutorialIDs.Count; k++)
				{
					csBannerItem component = UnityEngine.Object.Instantiate(LevelRec_Prefab, GroupT).GetComponent<csBannerItem>();
					component.setTutorialBanner(TutorialIDs[k], csIDImageIconManager.instance.GetImgByID(TutorialIDs[k]));
					recInMain.Add(component);
				}
				break;
			}
			}
		}
		ProcessPoint.initPoint(Totalpage);
		ProcessPoint.setPage(0);
	}

	public void PageRight()
	{
		if (Curpage < Totalpage - 1)
		{
			SetToPage(Curpage + 1);
		}
	}

	public void PageLeft()
	{
		if (Curpage > 0)
		{
			SetToPage(Curpage - 1);
		}
	}

	public void SetToPage(int p)
	{
		Curpage = p;
		ProcessPoint.setPage(p);
		GroupT.GetComponent<RectTransform>().DOAnchorPosX(offset + (float)Curpage * pageWidth, 0.2f);
	}

	private void Update()
	{
	}
}
public class csSearchKeywordHintBtn : MonoBehaviour
{
	public Button thisBtn;

	private SearchKeywords thisKeyword;

	public TextMeshProUGUI[] KeywordTxts;

	private void Awake()
	{
		thisBtn = GetComponent<Button>();
	}

	public void InitKeywordHint(SearchKeywords k)
	{
		thisKeyword = k;
		thisBtn.onClick.AddListener(RemoveKeywordInSearch);
		switch (k)
		{
		default:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("SearchKeywordHintBtn01");
			}
			break;
		}
		case SearchKeywords.Boxing:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel14");
			}
			break;
		}
		case SearchKeywords.Stick:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel11");
			}
			break;
		}
		case SearchKeywords.Follow:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel12");
			}
			break;
		}
		case SearchKeywords.Think:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel17");
			}
			break;
		}
		case SearchKeywords.DifEasy:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel27");
			}
			break;
		}
		case SearchKeywords.DifNormal:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("SearchKeywordHintBtn02");
			}
			break;
		}
		case SearchKeywords.DifHard:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel29");
			}
			break;
		}
		case SearchKeywords.KeepFit:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel18");
			}
			break;
		}
		case SearchKeywords.LossWeight:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel19");
			}
			break;
		}
		case SearchKeywords.MakeBody:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel20");
			}
			break;
		}
		case SearchKeywords.Timelessten:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = "<10min";
			}
			break;
		}
		case SearchKeywords.Timetentofifteen:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = "10~15min";
			}
			break;
		}
		case SearchKeywords.Timemore:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = ">15min";
			}
			break;
		}
		case SearchKeywords.superMonkey:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = csLocalizationManager.Instance.GetLocalText("LevelMenuPanel22");
			}
			break;
		}
		case SearchKeywords.Keep:
		{
			TextMeshProUGUI[] keywordTxts = KeywordTxts;
			for (int i = 0; i < keywordTxts.Length; i++)
			{
				keywordTxts[i].text = "Keep";
			}
			break;
		}
		}
	}

	private void RemoveKeywordInSearch()
	{
		csSearchManager.instance.RemoveCallFromHint(thisKeyword);
	}

	public void RemoveKeywordObj()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class csSearchKeywordToggle : MonoBehaviour
{
	public SearchKeywords BtnKeyWord;

	public csVRButtonInMenu thisVRBtn;

	public Button thisUIBtn;

	public bool isOn;

	private void Awake()
	{
		thisUIBtn = GetComponent<Button>();
		thisVRBtn = GetComponent<csVRButtonInMenu>();
		thisVRBtn.DeSelect();
		thisUIBtn.onClick.AddListener(OnToggleClick);
	}

	private void Start()
	{
		csSearchManager.instance.AddToggleBtnToSearch(this);
	}

	private void OnToggleClick()
	{
		csSearchManager.instance.OnKeyWordClick(BtnKeyWord);
	}

	public void SetState(bool on)
	{
		isOn = on;
		if (isOn)
		{
			thisVRBtn.OnSelect();
		}
		else
		{
			thisVRBtn.DeSelect();
		}
	}
}
public class csSearchManager : MonoBehaviour
{
	public static csSearchManager instance;

	public csPageMoveTrigger pageTrigger;

	public ScrollRect VerScroll;

	public RectTransform BGDownT;

	public csVRButtonInMenu FollowBtn;

	public csVRButtonInMenu TrainingBtn;

	public csVRButtonInMenu ThinkingBtn;

	public Dictionary<ToggleGroupType, csVRButtonInMenu> PanelSwitchBtnDic = new Dictionary<ToggleGroupType, csVRButtonInMenu>();

	public csVRButtonInMenu BtnDeleteAll;

	public Dictionary<SearchKeywords, csSearchKeywordHintBtn> KeyWordHintDic = new Dictionary<SearchKeywords, csSearchKeywordHintBtn>();

	public List<SearchKeywords> SelectedKeywordList = new List<SearchKeywords>();

	public GameObject KeyWordHintPrefab;

	public Transform KeyWordHintParentT;

	public GameObject PanelSportTypeObj;

	private bool CanScroll = true;

	private ToggleGroupType curToggleGruop;

	public Dictionary<SearchKeywords, csSearchKeywordToggle> ToggleBtnDic = new Dictionary<SearchKeywords, csSearchKeywordToggle>();

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		csPageMoveTrigger obj = pageTrigger;
		obj.OnPageUpAct = (UnityAction)Delegate.Combine(obj.OnPageUpAct, new UnityAction(PageUp));
		csPageMoveTrigger obj2 = pageTrigger;
		obj2.OnPageDownAct = (UnityAction)Delegate.Combine(obj2.OnPageDownAct, new UnityAction(PageDown));
		PanelSwitchBtnDic.Add(ToggleGroupType.Follow, FollowBtn);
		PanelSwitchBtnDic.Add(ToggleGroupType.Training, TrainingBtn);
		PanelSwitchBtnDic.Add(ToggleGroupType.Thinking, ThinkingBtn);
		FollowBtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(ToggleGroupType.Follow);
		});
		TrainingBtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(ToggleGroupType.Training);
		});
		ThinkingBtn.button.onClick.AddListener(delegate
		{
			SwitchToPanel(ToggleGroupType.Thinking);
		});
		BtnDeleteAll.button.onClick.AddListener(RemoveKeyWord);
		BtnDeleteAll.gameObject.SetActive(value: false);
		SwitchToPanel(ToggleGroupType.Follow);
	}

	private void PageUp()
	{
		if (CanScroll)
		{
			CanScroll = false;
			float num = VerScroll.verticalNormalizedPosition + 0.25f;
			if (num > 1f)
			{
				num = 1f;
			}
			VerScroll.DOVerticalNormalizedPos(num, 0.2f).OnComplete(delegate
			{
				CanScroll = true;
			});
		}
	}

	private void PageDown()
	{
		if (CanScroll)
		{
			CanScroll = false;
			float num = VerScroll.verticalNormalizedPosition - 0.25f;
			if (num < 0f)
			{
				num = 0f;
			}
			VerScroll.DOVerticalNormalizedPos(num, 0.2f).OnComplete(delegate
			{
				CanScroll = true;
			});
		}
	}

	public void SwitchToPanel(ToggleGroupType groupType)
	{
		curToggleGruop = groupType;
		foreach (csVRButtonInMenu value in PanelSwitchBtnDic.Values)
		{
			value.DeSelect();
		}
		PanelSwitchBtnDic[groupType].OnSelect();
		if (groupType == ToggleGroupType.Follow || groupType == ToggleGroupType.Thinking)
		{
			PanelSportTypeObj.SetActive(value: false);
		}
		else
		{
			PanelSportTypeObj.SetActive(value: true);
		}
		ApplySearchListToLevelPanel();
	}

	public void RemoveKeyWord()
	{
		foreach (csSearchKeywordToggle value in ToggleBtnDic.Values)
		{
			if (value.isOn)
			{
				SelectedKeywordList.Remove(value.BtnKeyWord);
				value.SetState(on: false);
				csSearchKeywordHintBtn obj = KeyWordHintDic[value.BtnKeyWord];
				KeyWordHintDic.Remove(value.BtnKeyWord);
				obj.RemoveKeywordObj();
			}
		}
		SelectedKeywordList.Clear();
		ApplySearchListToLevelPanel();
	}

	public void OnKeyWordClick(SearchKeywords keyWord)
	{
		ToggleBtnDic[keyWord].SetState(!ToggleBtnDic[keyWord].isOn);
		if (ToggleBtnDic[keyWord].isOn)
		{
			SelectedKeywordList.Add(keyWord);
			csSearchKeywordHintBtn component = UnityEngine.Object.Instantiate(KeyWordHintPrefab, KeyWordHintParentT).GetComponent<csSearchKeywordHintBtn>();
			component.InitKeywordHint(keyWord);
			KeyWordHintDic.Add(keyWord, component);
		}
		else
		{
			SelectedKeywordList.Remove(keyWord);
			csSearchKeywordHintBtn obj = KeyWordHintDic[keyWord];
			KeyWordHintDic.Remove(keyWord);
			obj.RemoveKeywordObj();
		}
		ApplySearchListToLevelPanel();
	}

	public void RemoveCallFromHint(SearchKeywords k)
	{
		if (ToggleBtnDic[k].isOn)
		{
			SelectedKeywordList.Remove(k);
			ToggleBtnDic[k].SetState(!ToggleBtnDic[k].isOn);
			csSearchKeywordHintBtn obj = KeyWordHintDic[k];
			KeyWordHintDic.Remove(k);
			obj.RemoveKeywordObj();
			ApplySearchListToLevelPanel();
		}
	}

	private void ApplySearchListToLevelPanel()
	{
		csLevelChoosePanel.instance.ApplySearchKeywordList(curToggleGruop, SelectedKeywordList);
	}

	public void AddToggleBtnToSearch(csSearchKeywordToggle t)
	{
		ToggleBtnDic.Add(t.BtnKeyWord, t);
	}
}
public enum ToggleGroupType
{
	Follow,
	Training,
	Thinking
}
public class csSettingPanel : csPanelBase
{
	public static csSettingPanel instance;

	public Button ReturnBtn;

	public float Music_volume;

	public float Effect_volume;

	public float Mic_volume;

	public float Voice_volume;

	public float HitFX_volume;

	public Button Platform_Off;

	public Button Platform_On;

	public Button Combo_Off;

	public Button Combo_On;

	public Button Language_Chinese;

	public Button Language_English;

	public Button Language_Japanese;

	public Button SE_Relax;

	public Button SE_Intense;

	public Button SE_Burn;

	public GameObject LanguageDetail;

	public GameObject SEDetail;

	public Button OpenLangDetail;

	public Button OpenSEDetail;

	public TextMeshProUGUI CurlanguageText;

	public Slider MusicVol;

	public Slider SFXVol;

	public csOnPointerEvents MusicVolEvt;

	public csOnPointerEvents SFXVolEvt;

	public csOnPointerEvents MicVolEvt;

	public csOnPointerEvents VoiceVolEvt;

	public csOnPointerEvents CoachVolEvt;

	public csOnPointerEvents HitFXVolEvt;

	public Slider MicVol;

	public Slider VoiceVol;

	public Slider CoachVoiceVol;

	public Slider HitFXVol;

	public AudioClip MusicSetClip;

	public AudioClip SfxSetClip;

	public AudioClip TeacherSetClip;

	public AudioClip MicSetClip;

	public AudioClip VoiceSetClip;

	public AudioClip HitFXSetClip;

	public AudioClip HitFXSetClip_Relax;

	public AudioClip HitFXSetClip_Dynamic;

	public AudioClip HitFXSetClip_Burn;

	public csVRButtonInMenu TabBtnDisplay;

	public csVRButtonInMenu TabBtnAudio;

	public csVRButtonInMenu TabBtnOthers;

	public GameObject DisplayTab;

	public GameObject AudioTab;

	public GameObject OthersTab;

	public TextMeshProUGUI SETpyeText;

	protected override void InitRef()
	{
		base.InitRef();
		SetSelectTab(0);
		ReturnBtn.onClick.AddListener(ReturnToMain);
		Platform_On.onClick.AddListener(ClosePlatform);
		Platform_Off.onClick.AddListener(OpenPlatform);
		instance = this;
		OpenLangDetail.onClick.AddListener(delegate
		{
			LanguageDetail.SetActive(value: true);
		});
		OpenSEDetail.onClick.AddListener(delegate
		{
			SEDetail.SetActive(value: true);
		});
		Language_English.onClick.AddListener(delegate
		{
			ChangeLanguage(Languages.English);
		});
		Language_Chinese.onClick.AddListener(delegate
		{
			ChangeLanguage(Languages.ChineseSimplified);
		});
		SE_Relax.onClick.AddListener(delegate
		{
			ChangeSoundEffectType(HitSoundEffectType.Relax);
		});
		SE_Intense.onClick.AddListener(delegate
		{
			ChangeSoundEffectType(HitSoundEffectType.Dynamic);
		});
		SE_Burn.onClick.AddListener(delegate
		{
			ChangeSoundEffectType(HitSoundEffectType.Burn);
		});
		csGameSettings.currentHitSEType = (HitSoundEffectType)PlayerPrefs.GetInt("HitSoundEffectTypeV2", 2);
		SoundEffectTypeShow();
	}

	public void SetSelectTab(int tab)
	{
		switch ((SettingTab)tab)
		{
		case SettingTab.Display:
			TabBtnDisplay.OnSelect();
			TabBtnAudio.DeSelect();
			TabBtnOthers.DeSelect();
			DisplayTab.SetActive(value: true);
			AudioTab.SetActive(value: false);
			OthersTab.SetActive(value: false);
			break;
		case SettingTab.Audios:
			TabBtnDisplay.DeSelect();
			TabBtnAudio.OnSelect();
			TabBtnOthers.DeSelect();
			DisplayTab.SetActive(value: false);
			AudioTab.SetActive(value: true);
			OthersTab.SetActive(value: false);
			break;
		case SettingTab.Other:
			TabBtnDisplay.DeSelect();
			TabBtnAudio.DeSelect();
			TabBtnOthers.OnSelect();
			DisplayTab.SetActive(value: false);
			AudioTab.SetActive(value: false);
			OthersTab.SetActive(value: true);
			break;
		}
	}

	public static void HeightReset()
	{
		float num = (int)(csPlayer.instance.camT.position.y * 100f) + 15;
		if (num < 150f)
		{
			num = 150f;
		}
		if (num > 200f)
		{
			num = 200f;
		}
		csGameSettings.XYScale = (num - 150f) / 50f * 0.3f + 0.8f;
		csGameSettings.CenterHolePos = new Vector3(0f, num / 100f - 0.4f, 0f);
		PlayerPrefs.SetInt("Height", (int)num);
	}

	private IEnumerator Start()
	{
		InitPaltformSetting();
		InitComboSetting();
		InitSliderSettings();
		while (!GameManagerNew.instance || !GameManagerNew.instance.CurPlayer)
		{
			yield return null;
		}
	}

	public override void Open()
	{
		InitPaltformSetting();
		InitComboSetting();
		InitSliderSettings();
		csLevelChoosePanel.instance.tagsx5.SetActive(value: false);
		base.Open();
	}

	public void InitPaltformSetting()
	{
		if (csGameSettings.PlayerPlatformOn)
		{
			Platform_On.gameObject.SetActive(value: true);
			Platform_Off.gameObject.SetActive(value: false);
		}
		else
		{
			Platform_Off.gameObject.SetActive(value: true);
			Platform_On.gameObject.SetActive(value: false);
		}
	}

	public void InitComboSetting()
	{
		csGameSettings.ComboShow = true;
		if (csGameSettings.ComboShow)
		{
			Combo_On.gameObject.SetActive(value: true);
			Combo_Off.gameObject.SetActive(value: false);
		}
		if (!csGameSettings.ComboShow)
		{
			Combo_On.gameObject.SetActive(value: false);
			Combo_Off.gameObject.SetActive(value: true);
		}
		Combo_On.onClick.AddListener(delegate
		{
			csGameSettings.ComboShow = false;
			Combo_Off.gameObject.SetActive(value: true);
			Combo_On.gameObject.SetActive(value: false);
		});
		Combo_Off.onClick.AddListener(delegate
		{
			csGameSettings.ComboShow = true;
			Combo_On.gameObject.SetActive(value: true);
			Combo_Off.gameObject.SetActive(value: false);
		});
	}

	private void InitSliderSettings()
	{
		MusicVol.SetValueWithoutNotify(csGameSettings.MusicVol);
		MicVol.SetValueWithoutNotify(csGameSettings.MicVol);
		VoiceVol.SetValueWithoutNotify(csGameSettings.VoiceVol);
		csOnPointerEvents musicVolEvt = MusicVolEvt;
		musicVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(musicVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(MusicSetClip, Vector3.zero, csGameSettings.MusicVol);
		});
		csOnPointerEvents sFXVolEvt = SFXVolEvt;
		sFXVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(sFXVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(SfxSetClip, Vector3.zero, csGameSettings.SoundEffectVol);
		});
		csOnPointerEvents hitFXVolEvt = HitFXVolEvt;
		hitFXVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(hitFXVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(HitFXSetClip, Vector3.zero, csGameSettings.SoundEffectVol * csGameSettings.HitFXVol * 0.25f);
		});
		csOnPointerEvents micVolEvt = MicVolEvt;
		micVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(micVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(MicSetClip, Vector3.zero, csGameSettings.MicVol);
		});
		csOnPointerEvents voiceVolEvt = VoiceVolEvt;
		voiceVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(voiceVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(VoiceSetClip, Vector3.zero, csGameSettings.VoiceVol);
		});
		csOnPointerEvents coachVolEvt = CoachVolEvt;
		coachVolEvt.OnPointUpAct = (UnityAction)Delegate.Combine(coachVolEvt.OnPointUpAct, (UnityAction)delegate
		{
			AudioSource.PlayClipAtPoint(TeacherSetClip, Vector3.zero, csGameSettings.CoachVoiceVol);
		});
		MusicVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.MusicVol = x;
			GameManagerNew.instance.SetMusicAudioVolume();
			csEnvironmentManager.instance.SetAudioVolume();
		});
		MicVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.MicVol = x;
		});
		VoiceVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.VoiceVol = x;
		});
		SFXVol.SetValueWithoutNotify(csGameSettings.SoundEffectVol);
		SFXVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.SoundEffectVol = x;
			csAudioManager.instance.SetAudioVolume();
			GameManagerNew.instance.SetEffectAudioVolume();
		});
		CoachVoiceVol.SetValueWithoutNotify(csGameSettings.CoachVoiceVol);
		CoachVoiceVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.CoachVoiceVol = x;
			GameManagerNew.instance.SetCoachAudioVolume();
		});
		HitFXVol.SetValueWithoutNotify(csGameSettings.HitFXVol);
		HitFXVol.onValueChanged.AddListener(delegate(float x)
		{
			csGameSettings.HitFXVol = x;
		});
	}

	private void InitLanguageSettings()
	{
		switch ((Languages)PlayerPrefs.GetInt("CurrentLanguage", -1))
		{
		case Languages.ChineseSimplified:
			CurlanguageText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel01");
			break;
		case Languages.English:
			CurlanguageText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel02");
			break;
		}
	}

	public void ChangeLanguage(Languages LAN)
	{
		LanguageDetail.SetActive(value: false);
		switch (LAN)
		{
		case Languages.ChineseSimplified:
			CurlanguageText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel01");
			break;
		case Languages.English:
			CurlanguageText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel02");
			break;
		}
		csLocalizationManager.Instance.SetLanguage(LAN);
	}

	public void ClosePlatform()
	{
		csPlatformEffectMgr.instance.ClosePlatform();
		csGameSettings.PlayerPlatformOn = false;
		Platform_Off.gameObject.SetActive(value: true);
		Platform_On.gameObject.SetActive(value: false);
	}

	public void OpenPlatform()
	{
		csPlatformEffectMgr.instance.OpenPlatform();
		csGameSettings.PlayerPlatformOn = true;
		Platform_On.gameObject.SetActive(value: true);
		Platform_Off.gameObject.SetActive(value: false);
	}

	public void ReturnToMain()
	{
		csMainMenuManager.instance.OpenPanel(csMainMenuManager.instance.LastPanel);
		csLevelChoosePanel.instance.playerinfotitle.gameObject.SetActive(value: true);
		csLevelChoosePanel.instance.tagsx5.SetActive(value: true);
	}

	public void EnterPunchTutorial()
	{
		GameManagerNew.instance.StartGame(GameData.instance.TutorialSongDataPunch);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.start_tutorial, new Dictionary<string, object>());
		csTalkingData.Instance.SendEvent("JC03_设置入口", 1.0, null);
	}

	public void GoUserArgeement()
	{
		Application.OpenURL(csGameSettings.UserAgreementUrl);
	}

	public void GoPravicyPolicy()
	{
		Application.OpenURL(csGameSettings.PravicyPolicyUrl);
	}

	public void ChangeSoundEffectType(HitSoundEffectType currentType)
	{
		SEDetail.SetActive(value: false);
		csGameSettings.currentHitSEType = currentType;
		SoundEffectTypeShow();
	}

	public void SoundEffectTypeShow()
	{
		switch (csGameSettings.currentHitSEType)
		{
		case HitSoundEffectType.Relax:
			SETpyeText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel30");
			HitFXSetClip = HitFXSetClip_Relax;
			break;
		case HitSoundEffectType.Dynamic:
			SETpyeText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel31");
			HitFXSetClip = HitFXSetClip_Dynamic;
			break;
		case HitSoundEffectType.Burn:
			SETpyeText.text = csLocalizationManager.Instance.GetLocalText("SettingsPanel32");
			HitFXSetClip = HitFXSetClip_Burn;
			break;
		}
	}
}
public enum SettingTab
{
	Display,
	Audios,
	Other
}
public class csSimpleFrameAnim : MonoBehaviour
{
	public static csSimpleFrameAnim instance;

	public Image ImageSource;

	public AudioClip logoClip;

	public AudioSource logoSource;

	private int mCurFrame;

	private float mDelta;

	public float FPS = 20f;

	public List<Sprite> SpriteFrames = new List<Sprite>();

	public bool IsPlaying;

	public bool Foward = true;

	public bool AutoPlay;

	public bool Loop;

	private Action<object> animPlayEndAction;

	private object caller;

	public VideoPlayer videoPlayer;

	public bool isVideo;

	public bool independentVoice;

	public int FrameCount => SpriteFrames.Count;

	private void Awake()
	{
		if (instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			instance = this;
		}
		if (AutoPlay)
		{
			Play();
		}
		logoSource = GetComponent<AudioSource>();
	}

	private void SetSprite(int idx)
	{
		ImageSource.sprite = SpriteFrames[idx];
	}

	public void Play()
	{
		if (isVideo)
		{
			videoPlayer.Play();
		}
		else
		{
			IsPlaying = true;
			Foward = true;
		}
		if (independentVoice)
		{
			logoSource.PlayOneShot(logoClip, 1f);
		}
	}

	public void PlayReverse()
	{
		IsPlaying = true;
		Foward = false;
	}

	private void Update()
	{
		if (!IsPlaying || FrameCount == 0)
		{
			return;
		}
		mDelta += Time.deltaTime;
		if (!(mDelta > 1f / FPS))
		{
			return;
		}
		mDelta = 0f;
		if (Foward)
		{
			mCurFrame++;
		}
		else
		{
			mCurFrame--;
		}
		if (mCurFrame >= FrameCount)
		{
			if (!Loop)
			{
				IsPlaying = false;
				if (animPlayEndAction != null)
				{
					animPlayEndAction(caller);
				}
				return;
			}
			mCurFrame = 0;
		}
		else if (mCurFrame < 0)
		{
			if (!Loop)
			{
				IsPlaying = false;
				if (animPlayEndAction != null)
				{
					animPlayEndAction(caller);
				}
				return;
			}
			mCurFrame = FrameCount - 1;
		}
		SetSprite(mCurFrame);
	}

	public void Pause()
	{
		IsPlaying = false;
	}

	public void Resume()
	{
		if (!IsPlaying)
		{
			IsPlaying = true;
		}
	}

	public void Stop()
	{
		mCurFrame = 0;
		SetSprite(mCurFrame);
		IsPlaying = false;
	}

	public void Rewind()
	{
		mCurFrame = 0;
		SetSprite(mCurFrame);
		Play();
	}

	public void AddAnimPlayEndListener(Action<object> aciton, object caller)
	{
		animPlayEndAction = aciton;
		this.caller = caller;
	}
}
public class csSocialPanel : csPanelBase
{
	public string[] FakeClassIDs;

	private List<RoomInfo> roomlist = new List<RoomInfo>();

	public GameObject RoomPrefab;

	public Transform DataGrid;

	public RectTransform DataGridT;

	public List<csUIRoomInfo> roomUIList = new List<csUIRoomInfo>();

	public List<csUIRoomInfo> fakeRoomUIList = new List<csUIRoomInfo>();

	private List<csUIRoomInfo> realShowRoomUIList = new List<csUIRoomInfo>();

	public Mask mask;

	public Button UpBtn;

	public Button DownBtn;

	public TextMeshProUGUI PageText;

	private bool isMoveing;

	private int NowRoomPage;

	private int OnePageMaxRoom = 5;

	private int Totalpage;

	private float OneItemMoveHeight;

	private int TotalRoomItemNum;

	public int onePageNum = 5;

	private int currentPage;

	public csPhotonLobby photonLobby;

	public csPageMoveTrigger pageMoveTrigger;

	private bool DontDisconnect;

	private csClassDownloadData followDownloadMision;

	private GameSongData CurrSongData;

	private string CurrRoomName;

	private Dictionary<string, int> SameClassDic = new Dictionary<string, int>();

	private Coroutine ConnectoPhotonCor;

	private Coroutine ConnectoPhotonRetryCor;

	public GameObject PhotonNetHint;

	public GameObject RoomPanel;

	public TextMeshProUGUI NetHintText;

	private void PageUp()
	{
		if (!isMoveing && NowRoomPage > 0)
		{
			MoveToPage(NowRoomPage - 1, isDown: false);
		}
	}

	protected override void InitRef()
	{
		base.InitRef();
		for (int i = 0; i < FakeClassIDs.Length; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(RoomPrefab);
			obj.transform.SetParent(DataGrid);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.SetActive(value: true);
			csUIRoomInfo component = obj.GetComponent<csUIRoomInfo>();
			component.SetFakeInfo(FakeClassIDs[i], csPlayMode.Menu);
			fakeRoomUIList.Add(component);
		}
		for (int j = 0; j < 100; j++)
		{
			GameObject obj2 = UnityEngine.Object.Instantiate(RoomPrefab);
			obj2.transform.SetParent(DataGrid);
			obj2.transform.localPosition = Vector3.zero;
			obj2.transform.localRotation = Quaternion.identity;
			obj2.transform.localScale = Vector3.one;
			obj2.SetActive(value: true);
			csUIRoomInfo component2 = obj2.GetComponent<csUIRoomInfo>();
			roomUIList.Add(component2);
		}
	}

	private void PageDown()
	{
		if (!isMoveing && NowRoomPage < Totalpage - 1)
		{
			MoveToPage(NowRoomPage + 1, isDown: true);
		}
	}

	private void MoveToPage(int page, bool isDown)
	{
		int lastPage = NowRoomPage;
		NowRoomPage = page;
		for (int i = page * OnePageMaxRoom; i < page * OnePageMaxRoom + OnePageMaxRoom && i < TotalRoomItemNum; i++)
		{
			if (i < realShowRoomUIList.Count)
			{
				realShowRoomUIList[i].ShowItem(isShow: true);
			}
		}
		isMoveing = true;
		mask.enabled = true;
		DataGridT.DOAnchorPosY(NowRoomPage * 213, 0.2f).OnComplete(delegate
		{
			for (int j = lastPage * OnePageMaxRoom; j < lastPage * OnePageMaxRoom + OnePageMaxRoom && j < TotalRoomItemNum; j++)
			{
				if (j < realShowRoomUIList.Count)
				{
					realShowRoomUIList[j].ShowItem(isShow: false);
				}
			}
			isMoveing = false;
			mask.enabled = false;
			SetPageText();
		});
	}

	private IEnumerator pos()
	{
		yield return new WaitForSeconds(0.5f);
		DataGrid.localPosition = Vector3.zero;
	}

	private void SetPageText()
	{
		PageText.text = NowRoomPage + 1 + "/" + Totalpage;
	}

	private void Start()
	{
		currentPage = 0;
		csPhotonLobby.OnRoomListUpdated = (UnityAction)Delegate.Combine(csPhotonLobby.OnRoomListUpdated, new UnityAction(RefreshRoomInfo));
		UpBtn.onClick.AddListener(PageUp);
		DownBtn.onClick.AddListener(PageDown);
		csPageMoveTrigger obj = pageMoveTrigger;
		obj.OnPageUpAct = (UnityAction)Delegate.Combine(obj.OnPageUpAct, new UnityAction(PageUp));
		csPageMoveTrigger obj2 = pageMoveTrigger;
		obj2.OnPageDownAct = (UnityAction)Delegate.Combine(obj2.OnPageDownAct, new UnityAction(PageDown));
		GetOneMoveHeight();
	}

	private void OnDisable()
	{
		csPhotonLobby.OnRoomListUpdated = (UnityAction)Delegate.Remove(csPhotonLobby.OnRoomListUpdated, new UnityAction(RefreshRoomInfo));
	}

	private void GetOneMoveHeight()
	{
		OneItemMoveHeight = RoomPrefab.GetComponent<csUIRoomInfo>().GetItemHight();
	}

	public override void Open()
	{
		ShowNetHint(isShow: false);
		ConnectoPhotonCor = StartCoroutine(ConnectToPhoton());
	}

	public override void Open(string message)
	{
		base.Open(message);
		_ = message == "reconnect";
		ShowNetHint(isShow: false);
		RefreshRoomInfo();
	}

	public override void Close()
	{
		base.Close();
		if (!DontDisconnect)
		{
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
			{
				ShowNetHint(isShow: true);
			});
			PhotonNetwork.Disconnect();
			photonLobby.enabled = false;
		}
	}

	public void TryCreateRoom(string classID, string roomName)
	{
		GameSongData songDataByClassID = GameData.instance.GetSongDataByClassID(classID);
		if (csAssetLoader.instance.JudgeFollowListDownloadDone(songDataByClassID.FollowVideoDataList, songDataByClassID))
		{
			if (string.IsNullOrEmpty(roomName))
			{
				List<RoomInfo> list = csPhotonLobby.cachedRoomList.Values.ToList().FindAll((RoomInfo x) => (string)x.CustomProperties["cid"] == classID);
				if (list.Count <= 0)
				{
					csPhotonLobby.instance.CreatNewRoom(songDataByClassID.ClassID + "0", classID);
				}
				else
				{
					csPhotonLobby.instance.CreatNewRoom(songDataByClassID.ClassID + list.Count, classID);
				}
				return;
			}
			RoomInfo roomInfo = csPhotonLobby.cachedRoomList.Values.ToList().Find((RoomInfo x) => x.Name == roomName);
			bool flag = true;
			if (roomInfo == null)
			{
				ShowNetHint(isShow: true);
				SetNetHintMsg(csLocalizationManager.Instance.GetLocalText("UIRoomInfo06"));
			}
			else if (roomInfo.PlayerCount >= 8)
			{
				ShowNetHint(isShow: true);
				SetNetHintMsg(csLocalizationManager.Instance.GetLocalText("UIRoomInfo07"));
			}
			else
			{
				csPhotonLobby.instance.JoinRoomByName(roomName);
			}
			if (flag)
			{
				ShowNetHint(isShow: true);
				SetNetHintMsg(csLocalizationManager.Instance.GetLocalText("UIRoomInfo06"));
			}
		}
		else
		{
			StartFollowWithDownload(songDataByClassID, roomName);
		}
	}

	private void StartFollowWithDownload(GameSongData gsd, string roomName)
	{
		DontDisconnect = true;
		csMainMenuManager.instance.ClosePanel();
		CurrSongData = gsd;
		CurrRoomName = roomName;
		followDownloadMision = csVedioDownloadManager.instance.CreateAndStartClassMision(gsd.FollowVideoDataList, gsd.ClassID, FollowDownloaCallBack, delegate
		{
		}, OnDownloadProgressCallBack, isPlaying: true);
		csMainMenuManager.instance.ClosePanel();
		csMainMenuManager.instance.downloadPanel.AddExitCallBack(OnFollowMisionCanncel);
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "MultiFollow");
		GameManagerNew.instance.isFollowDownLoading = true;
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
	}

	private void OnFollowMisionCanncel()
	{
		if (followDownloadMision != null)
		{
			csClassDownloadData obj = followDownloadMision;
			obj.classMisionCompletCallBack = (Action)Delegate.Remove(obj.classMisionCompletCallBack, new Action(FollowDownloaCallBack));
			csClassDownloadData obj2 = followDownloadMision;
			obj2.classMisionProgressCallBack = (Action<double>)Delegate.Remove(obj2.classMisionProgressCallBack, new Action<double>(OnDownloadProgressCallBack));
		}
		followDownloadMision = null;
		GameManagerNew.instance.isFollowDownLoading = false;
		GameManagerNew.instance.BackToMain();
	}

	private void OnDownloadProgressCallBack(double progress)
	{
		csMainMenuManager.instance.downloadPanel.SetSliderValue((float)progress);
	}

	private void FollowDownloaCallBack()
	{
		StartCoroutine(WaitToChange());
		GameManagerNew.instance.isFollowDownLoading = false;
	}

	private IEnumerator WaitToChange()
	{
		UnityEngine.Debug.LogError("下载完成");
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		if (CurrSongData != null && CurrRoomName != null)
		{
			csGameDataTransfer.playMode = csPlayMode.Menu;
			UnityEngine.Debug.LogError("尝试进入房间");
			TryCreateRoom(CurrSongData.ClassID, CurrRoomName);
		}
	}

	private IEnumerator FollowListDownload(GameSongData gsd, string roomName)
	{
		DontDisconnect = true;
		csMainMenuManager.instance.ClosePanel();
		csMainMenuManager.instance.OpenPanel(PanelType.DownloadPanel, "MultiFollow");
		List<string> list = new List<string>();
		for (int i = 0; i < gsd.FollowVideoDataList.Count; i++)
		{
			list.Add(gsd.FollowVideoDataList[i].VideoName + csCloudSettings.GetClassVideoVersion(gsd.ClassID, VideoType.Follow));
		}
		GameManagerNew.instance.isFollowDownLoading = true;
		csAssetLoader.instance.followPrepareVideo(list, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				GameManagerNew.instance.isFollowDownLoading = false;
			}
			else
			{
				DontDisconnect = false;
			}
		});
		csMainMenuManager.instance.downloadPanel.SetSliderValue(0f);
		while (GameManagerNew.instance.isFollowDownLoading)
		{
			yield return new WaitForSeconds(0.5f);
		}
		DontDisconnect = false;
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		csGameDataTransfer.playMode = csPlayMode.Menu;
		TryCreateRoom(gsd.ClassID, roomName);
	}

	public void RefreshRoomInfo()
	{
		RoomInfo[] array = csPhotonLobby.cachedRoomList.Values.ToArray();
		roomlist.Clear();
		int num = array.Length;
		_ = onePageNum;
		_ = currentPage;
		realShowRoomUIList.Clear();
		for (int i = 0; i < fakeRoomUIList.Count; i++)
		{
			TotalRoomItemNum++;
			fakeRoomUIList[i].ShowObject(isShow: true);
			realShowRoomUIList.Add(fakeRoomUIList[i]);
		}
		for (int j = 0; j < roomUIList.Count; j++)
		{
			if (j >= num)
			{
				roomUIList[j].ShowItem(isShow: false);
				continue;
			}
			roomUIList[j].ShowItem(isShow: true);
			roomUIList[j].SetRoomInfo(array[j], array[j].PlayerCount >= 8);
			realShowRoomUIList.Add(roomUIList[j]);
			bool flag = false;
			for (int k = 0; k < fakeRoomUIList.Count; k++)
			{
				if (fakeRoomUIList[k].gameObject.activeSelf && roomUIList[j].roomName.text == fakeRoomUIList[k].roomName.text)
				{
					flag = true;
					fakeRoomUIList[k].ShowObject(isShow: false);
					realShowRoomUIList.Remove(fakeRoomUIList[k]);
				}
			}
			if (!flag)
			{
				TotalRoomItemNum++;
			}
		}
		for (int l = OnePageMaxRoom; l < realShowRoomUIList.Count; l++)
		{
			realShowRoomUIList[l].ShowItem(isShow: false);
		}
		Totalpage = (int)Math.Ceiling((float)realShowRoomUIList.Count / (float)OnePageMaxRoom);
		SetPageText();
	}

	private IEnumerator ConnectToPhoton()
	{
		csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
		{
			base.Open();
		});
		if (csGameSettings.CurServer == ServerRegion.China && csGameSettings.useInternalAppID)
		{
			PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime = csPhotonSettings.instance.InternalChinaPUNAppId;
		}
		PhotonNetwork.NickName = csUtils.GetMd5StrDianXin(SystemInfo.deviceUniqueIdentifier + "V1");
		PhotonNetwork.AutomaticallySyncScene = false;
		PhotonNetwork.PhotonServerSettings.AppSettings.AppVersion = csGameSettings.GameVersion.Substring(0, 5);
		yield return new WaitForEndOfFrame();
		UnityEngine.Debug.LogError("CurServer" + csGameSettings.CurServer);
		switch (csGameSettings.CurServer)
		{
		case ServerRegion.None:
			PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = true;
			PhotonNetwork.PhotonServerSettings.AppSettings.Port = 0;
			PhotonNetwork.PhotonServerSettings.AppSettings.Server = "ns.exitgames.com";
			PhotonNetwork.ConnectToBestCloudServer();
			break;
		case ServerRegion.Asia:
			PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion = "asia";
			PhotonNetwork.PhotonServerSettings.AppSettings.Port = 0;
			PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = true;
			PhotonNetwork.PhotonServerSettings.AppSettings.Server = "ns.exitgames.com";
			PhotonNetwork.ConnectUsingSettings();
			break;
		case ServerRegion.China:
			if (csGameSettings.useInternalAppID)
			{
				PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion = "cn";
				PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = true;
				PhotonNetwork.PhotonServerSettings.AppSettings.Port = 0;
				PhotonNetwork.PhotonServerSettings.AppSettings.Server = "ns.photonengine.cn";
				PhotonNetwork.ConnectUsingSettings();
			}
			else
			{
				PhotonNetwork.PhotonServerSettings.AppSettings.Port = 5055;
				PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = false;
				PhotonNetwork.PhotonServerSettings.AppSettings.Server = "39.107.202.134";
				PhotonNetwork.ConnectUsingSettings();
			}
			break;
		}
		int counter = 0;
		while (PhotonNetwork.NetworkingClient.State != ClientState.ConnectedToMasterServer)
		{
			counter++;
			if (counter >= 4)
			{
				break;
			}
			yield return new WaitForSeconds(2f);
		}
		if (PhotonNetwork.NetworkingClient.State != ClientState.ConnectedToMasterServer)
		{
			csMainMenuManager.instance.disconnectPanel.setRetryAction(delegate
			{
				csEyeFadeManager.Instance.FadeToBlackWithMode(EyeFadeMode.LoadingDot, delegate
				{
					csGameSettings.needReLogin = true;
					csGameSettings.dontNeedShowLogo = false;
					csGameSettings.isLogined = false;
					SceneManager.LoadScene("GameScene");
				});
			}, delegate
			{
				Application.Quit();
			}, delegate
			{
			});
			csMainMenuManager.instance.OpenPanel(PanelType.disconnect);
		}
		else
		{
			PhotonNetwork.JoinLobby(new TypedLobby("SQLLobby", LobbyType.SqlLobby));
			while (!PhotonNetwork.InLobby)
			{
				yield return new WaitForEndOfFrame();
			}
			PhotonNetwork.GetCustomRoomList(new TypedLobby("SQLLobby", LobbyType.SqlLobby), "true");
			ConnectoPhotonCor = null;
			photonLobby.gameObject.SetActive(value: true);
			photonLobby.enabled = true;
			csEyeFadeManager.Instance.FadeToGameWithMode(EyeFadeMode.LoadingDot, delegate
			{
			});
		}
	}

	public void ShowNetHint(bool isShow)
	{
		PhotonNetHint.SetActive(isShow);
		RoomPanel.SetActive(!isShow);
	}

	public void SetNetHintMsg(string msg)
	{
		NetHintText.text = msg;
		NetHintText.text = NetHintText.text.Replace("\\n", "\n");
	}
}
public class csSongDetailItemInDetailPanel : MonoBehaviour
{
	public GameObject thisG;

	public TextMeshProUGUI SongName;

	public TextMeshProUGUI SingerName;

	public TextMeshProUGUI TimeTxt;

	public GameObject imageIcon;

	public void SetSongState(bool isOn, bool isSongOnly = false)
	{
		thisG.SetActive(isOn);
		if (isSongOnly)
		{
			SongName.transform.localPosition = new Vector3(SongName.transform.localPosition.x, 0f, 0f);
			imageIcon.transform.localPosition = new Vector3(imageIcon.transform.localPosition.x, 0f, 0f);
			SingerName.gameObject.SetActive(value: false);
		}
		else
		{
			SongName.transform.localPosition = new Vector3(SongName.transform.localPosition.x, 25f, 0f);
			SingerName.gameObject.SetActive(value: true);
		}
	}

	public void SetSongDetail(string songName, string singer, int t)
	{
		SongName.text = songName;
		SingerName.text = singer;
		TimeTxt.text = csUtils.FormatFloatTimeToStr(full: false, t);
	}
}
public class csSpColumnPanel : csPanelBase
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class csSuperMonkeyItem : MonoBehaviour
{
	public Transform root;

	public TextMeshProUGUI songName;

	public Image songPic;

	public GameSongData ItemSongData;

	public Image selectedPic;

	public string ClassID;

	public void ShowDetail()
	{
		csLevelChooseSuperMonkey.instance.InitClassDetailPanel(GameData.instance.GetSongDataByClassID(ClassID));
		csMainMenuManager.instance.OpenPenelAddOn(PanelType.ClassDetail);
		csLevelChooseSuperMonkey.instance.ClearSelected();
		ShowSelected(isShow: true);
	}

	public void ShowSelected(bool isShow)
	{
		selectedPic.enabled = isShow;
	}
}
public class csTabSelectedOne : MonoBehaviour
{
	public Transform thisT;

	public TextMeshProUGUI tabName;

	public TextMeshProUGUI tabName2;

	public SearchKeywords keyword;

	public Button closeBtn;

	public csLikeTabPageMan ltpm;

	public csMyDetalPanel mdp;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void closeTab()
	{
		if (ltpm != null)
		{
			ltpm.deleteSelected(keyword);
		}
		if (mdp != null)
		{
			mdp.deleteSelected(keyword);
		}
	}
}
public class csTabSelectOne : MonoBehaviour
{
	public Transform thisT;

	public new TextMeshProUGUI name;

	public SearchKeywords keyword;

	public Image pic;

	public Image edge;

	public csVRButtonInMenu thisBtn;

	public csLikeTabPageMan ltpm;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void setNameAndPic(string n, Sprite p, SearchKeywords key)
	{
		keyword = key;
		name.text = n;
		pic.sprite = p;
		setSelect();
	}

	public void setSelect()
	{
		if (ltpm.selectedTabNames.Contains(keyword))
		{
			thisBtn.OnSelect();
		}
		else
		{
			thisBtn.DeSelect();
		}
	}

	public void addSelectedOne()
	{
		if (ltpm.canAddSelected)
		{
			ltpm.AddSelectedOne(keyword);
			setSelect();
		}
	}
}
public class csTagsMgr : MonoBehaviour
{
	public static csTagsMgr instance;

	public csVRButtonInMenu ExploreBtn;

	public csVRButtonInMenu PlanBtn;

	public csVRButtonInMenu MultiroomBtn;

	public csVRButtonInMenu FriendsBtn;

	public csVRButtonInMenu MyBtn;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		ExploreBtn.button.onClick.AddListener(OnClickExploreBtn);
		PlanBtn.button.onClick.AddListener(OnClickPlanBtn);
		MultiroomBtn.button.onClick.AddListener(delegate
		{
			setSelect(MultiroomBtn);
			if (csPlayerOrderManager.instance.IsOrdering())
			{
				csMainMenuManager.instance.OpenPanel(PanelType.Multi);
			}
			else
			{
				csPlayerOrderManager.instance.ShowShopTip(csLocalizationManager.Instance.GetLocalText("PlayerOrder21"));
			}
		});
		FriendsBtn.button.onClick.AddListener(delegate
		{
			setSelect(FriendsBtn);
			csMainMenuManager.instance.OpenPanel(PanelType.Friends);
		});
		MyBtn.button.onClick.AddListener(OnClickMyBtn);
		setSelect(ExploreBtn);
	}

	public void OnClickExploreBtn()
	{
		setSelect(ExploreBtn);
		csMainMenuManager.instance.OpenPanel(PanelType.LevelChoose);
		if ((bool)csLevelChoosePanel.instance && !csGameSettings.IsOfflineVersion)
		{
			csLevelChoosePanel.instance.scoreRankPanel.gameObject.SetActive(value: true);
		}
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{6:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.Menu_Explore.ToString()
			}
		});
	}

	public void OnClickPlanBtn()
	{
		setSelect(PlanBtn);
		csMainMenuManager.instance.OpenPanel(PanelType.Plan);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{7:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.Menu_Plan.ToString()
			}
		});
	}

	public void OnClickMyBtn()
	{
		setSelect(MyBtn);
		csMainMenuManager.instance.OpenPanel(PanelType.MyInformation);
		csByteEventTracking.Instance.SendEvent(ByteEventTrackingID.button_click, new Dictionary<string, object>
		{
			{
				"button_id",
				$"ButtonTracking_{8:000}"
			},
			{
				"button_name",
				ButtonTrackingClick.Menu_My.ToString()
			}
		});
	}

	public void setSelect(csVRButtonInMenu selectedOne)
	{
		ExploreBtn.DeSelect();
		PlanBtn.DeSelect();
		MultiroomBtn.DeSelect();
		FriendsBtn.DeSelect();
		MyBtn.DeSelect();
		selectedOne.OnSelect();
	}
}
public class csTutorialPanel : csPanelBase
{
	public void BackToMainMenu()
	{
		csMainMenuManager.instance.OpenPanel(PanelType.MainMenu);
	}
}
public class csUIRoomInfo : MonoBehaviour
{
	public TextMeshProUGUI roomName;

	public TextMeshProUGUI playerCountT;

	public TextMeshProUGUI roomStateT;

	public RectTransform recTransform;

	public csPlayMode roomMode;

	public int PlayerCount = 1;

	public string classID;

	public bool HasPassword;

	public string password;

	public int curentState;

	private ServerRegion RoomRegion = ServerRegion.None;

	public RoomInfo roomInfo;

	private GameSongData thisData;

	public bool isFakeRoom;

	public GameObject JoinBtn;

	public GameObject FullBtn;

	public bool IsShow;

	public GameObject body;

	public void SetFakeInfo(string fid, csPlayMode fm)
	{
		classID = fid;
		thisData = GameData.instance.GetSongDataByClassID(classID);
		roomName.text = csLocalizationManager.Instance.GetLocalText(thisData.ClassTitleID);
		roomMode = fm;
		HasPassword = false;
		PlayerCount = 0;
		playerCountT.text = "0/8";
		isFakeRoom = true;
		curentState = -1;
		roomStateT.text = csLocalizationManager.Instance.GetLocalText("UIRoomInfo01");
		SetJoinBtnOn(isOn: true);
	}

	public void SetJoinBtnOn(bool isOn)
	{
		JoinBtn.SetActive(isOn);
		FullBtn.SetActive(!isOn);
	}

	public void ShowItem(bool isShow)
	{
		body.SetActive(isShow);
		IsShow = isShow;
	}

	public void ShowObject(bool isShow)
	{
		ShowItem(isShow);
		base.gameObject.SetActive(isShow);
	}

	public void SetRoomInfo(RoomInfo ri, bool isPlayerFull)
	{
		SetJoinBtnOn(!isPlayerFull);
		roomInfo = ri;
		if (roomInfo != null)
		{
			classID = (string)roomInfo.CustomProperties["cid"];
			thisData = GameData.instance.GetSongDataByClassID(classID);
			roomName.text = csLocalizationManager.Instance.GetLocalText(thisData.ClassTitleID);
			roomMode = (csPlayMode)roomInfo.CustomProperties["gm"];
			PlayerCount = roomInfo.PlayerCount;
			playerCountT.text = PlayerCount + "/8";
			isFakeRoom = false;
			switch ((int)roomInfo.CustomProperties["State"])
			{
			case -1:
				curentState = -1;
				roomStateT.text = csLocalizationManager.Instance.GetLocalText("UIRoomInfo01");
				break;
			case 0:
				curentState = 0;
				roomStateT.text = csLocalizationManager.Instance.GetLocalText("UIRoomInfo02");
				break;
			case 1:
				curentState = 1;
				roomStateT.text = csLocalizationManager.Instance.GetLocalText("UIRoomInfo03");
				break;
			}
		}
	}

	public void OnJoinRoomClick()
	{
		csGameDataTransfer.playMode = roomMode;
		csMainMenuManager.instance.multiPanel.TryCreateRoom(classID, isFakeRoom ? "" : roomInfo.Name);
	}

	public float GetItemHight()
	{
		return recTransform.sizeDelta.y;
	}
}
public class DotModel
{
	public UIVertex lb;

	public UIVertex lt;

	public UIVertex rt;

	public UIVertex rb;
}
[AddComponentMenu("UI/Effects/Extensions/CurvedText")]
public class CurvedText : BaseMeshEffect
{
	public float radius = 600f;

	[Range(0f, 360f)]
	[SerializeField]
	public double singleAngle = 5.0;

	private float lenghOfWord;

	public override void ModifyMesh(VertexHelper vh)
	{
		if (!IsActive())
		{
			return;
		}
		DotModel dotModel = new DotModel();
		int num = vh.currentVertCount / 4;
		float num2 = (num - 1) / 2;
		for (int i = 0; i < num; i++)
		{
			PopulateUIVertex(vh, i * 4, ref dotModel);
			UIVertex vertex = default(UIVertex);
			vh.PopulateUIVertex(ref vertex, i * 4);
			UIVertex vertex2 = default(UIVertex);
			vh.PopulateUIVertex(ref vertex2, i * 4 + 1);
			UIVertex vertex3 = default(UIVertex);
			vh.PopulateUIVertex(ref vertex3, i * 4 + 2);
			UIVertex vertex4 = default(UIVertex);
			vh.PopulateUIVertex(ref vertex4, i * 4 + 3);
			double num3 = (double)(num2 - (float)i) * singleAngle * Math.PI / 180.0;
			double num4 = Math.Sin(num3 / 2.0) * (double)radius * 2.0;
			float num5 = (float)(-Convert.ToInt16(Math.Cos(num3 / 2.0) * num4)) + (num2 - (float)i) * lenghOfWord;
			float num6 = -Math.Abs(Convert.ToInt16(Math.Sin(num3 / 2.0) * num4));
			vertex.position.x += num5;
			vertex2.position.x += num5;
			vertex3.position.x += num5;
			vertex4.position.x += num5;
			vertex.position.y += num6;
			vertex2.position.y += num6;
			vertex3.position.y += num6;
			vertex4.position.y += num6;
			float num7 = Vector3.Distance(b: Vector3.Lerp(vertex.position, vertex3.position, 0.5f), a: vertex.position);
			double num8 = Math.Abs(Math.Sin(num3 / 2.0) * (double)num7 * 2.0);
			float num9 = Convert.ToSingle(Math.Abs(Math.Cos(num3 / 2.0) * num8));
			float num10 = Convert.ToSingle(Math.Abs(Math.Sin(num3 / 2.0) * num8));
			if ((float)i - num2 < 0f)
			{
				vertex.position.x += num10;
				vertex2.position.x -= num9;
				vertex3.position.x -= num10;
				vertex4.position.x += num9;
				vertex.position.y -= num9;
				vertex2.position.y -= num10;
				vertex3.position.y += num9;
				vertex4.position.y += num10;
			}
			else
			{
				vertex.position.x += num9;
				vertex2.position.x -= num10;
				vertex3.position.x -= num9;
				vertex4.position.x += num10;
				vertex.position.y -= num10;
				vertex2.position.y -= num9;
				vertex3.position.y += num10;
				vertex4.position.y += num9;
			}
			vh.SetUIVertex(vertex, i * 4);
			vh.SetUIVertex(vertex2, i * 4 + 1);
			vh.SetUIVertex(vertex3, i * 4 + 2);
			vh.SetUIVertex(vertex4, i * 4 + 3);
		}
	}

	private void PopulateUIVertex(VertexHelper vh, int index, ref DotModel dotModel)
	{
		vh.PopulateUIVertex(ref dotModel.lb, index);
		vh.PopulateUIVertex(ref dotModel.lt, index + 1);
		vh.PopulateUIVertex(ref dotModel.rt, index + 2);
		vh.PopulateUIVertex(ref dotModel.rb, index + 3);
		lenghOfWord = Math.Abs(dotModel.rb.position.x - dotModel.rt.position.x);
	}
}
public class DownloadingPanelAnimation : MonoBehaviour
{
	public CanvasGroup middle;

	public float FadeTime;

	public Transform leftPanel;

	public Transform RightPanel;

	public Vector3 leftMoveVec;

	public Vector3 rightMoveVec;

	public float MoveTime;

	private void OnEnable()
	{
		leftPanel.DOMove(leftPanel.localPosition + leftMoveVec, MoveTime).From();
		RightPanel.DOMove(leftPanel.position + rightMoveVec, MoveTime).From();
		StartCoroutine(Animation());
	}

	private IEnumerator Animation()
	{
		middle.alpha = 0f;
		yield return new WaitForSeconds(0.5f);
		middle.DOFade(1f, FadeTime);
	}
}
public class LevelMenuPanelAnimation : MonoBehaviour
{
	public Animator animator;

	private void OnEnable()
	{
		if (!base.gameObject.activeSelf)
		{
			Invoke("PlayOpenAnimation", 1f);
		}
	}

	private void PlayOpenAnimation()
	{
		animator.Play("mainPanelEnter", 0);
	}
}
public class csCheatLeaderboard : MonoBehaviour
{
	public TextMeshProUGUI ClassID;

	public TextMeshProUGUI Debug;

	public TMP_InputField scoreInput;

	public Button startBtn;

	private void Start()
	{
		startBtn.onClick.AddListener(StartHapticPulse);
	}

	private void OnEnable()
	{
		Debug.text = "Debug";
	}

	private void StartHapticPulse()
	{
		long score = long.Parse(scoreInput.text);
		csPicoLeaderboard.Instance.SubmitLeaderBoard(ClassID.text, score, delegate(bool isSuccess)
		{
			if (isSuccess)
			{
				Debug.text = "上传成功";
			}
			else
			{
				Debug.text = "上传失败";
			}
		});
	}
}
public class csControllerforPicoXR : MonoBehaviour
{
	public bool isLeftHand;

	public bool isHead;

	public Transform thisT;

	public csControllerForSteamVR SteamController;

	private Coroutine LinearHanpticTimer;

	private float temp;

	public bool isPulsing;

	private Coroutine TriggerHapticPulseCoroutine;

	public Vector3 GetVel()
	{
		if (isHead)
		{
			return thisT.parent.TransformDirection(csXRInput.Instance.GetHeadControllerVel());
		}
		return thisT.parent.TransformDirection(csXRInput.Instance.GetControllerVel(isLeftHand));
	}

	public Vector2 JoyStickPos()
	{
		return csXRInput.Instance.TryGetJoystickValue(isLeftHand);
	}

	public Vector3 GetAcc()
	{
		if (!isHead)
		{
			return thisT.parent.TransformDirection(csXRInput.Instance.GetControllerAcc(isLeftHand));
		}
		return thisT.parent.TransformDirection(csXRInput.Instance.GetHeadControllerAcc());
	}

	private void Awake()
	{
		thisT = base.transform;
	}

	public bool GetMenuPressDown()
	{
		return csXRInput.Instance.TryGetButtonValue(ButtonType.MenuButton, PressState.Down, isLeftHand);
	}

	public bool GetTriggerDown()
	{
		return csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Down, isLeftHand);
	}

	public bool GetTriggerUp()
	{
		return csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Up, isLeftHand);
	}

	public void StartHapticPulse(float s, float t)
	{
		if (s < 0f)
		{
			s = 0f;
		}
		if (csGameSettings.CurrentDevice == XRDeviceType.Pico4)
		{
			PXR_Input.SetControllerVibrationEvent((!isLeftHand) ? 1u : 0u, 180, s, (int)(t * 1000f));
		}
		else
		{
			PXR_Input.SetControllerVibration(s, (int)(t * 1000f), (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
		}
	}

	public void StartLinearHanpticPulse(float startStrenth, float endStrenth, int startfreq, int endfreq, float losstime, float keepTime = 0f)
	{
		if (LinearHanpticTimer != null)
		{
			StopCoroutine(LinearHanpticTimer);
		}
		if (keepTime == 0f)
		{
			LinearHanpticTimer = StartCoroutine(IELinearHanpticPulse(startStrenth, endStrenth, startfreq, endfreq, losstime, keepTime));
		}
		else
		{
			LinearHanpticTimer = StartCoroutine(IEKeepHanpticPulse(startStrenth, endStrenth, startfreq, endfreq, losstime, keepTime));
		}
	}

	private IEnumerator IEKeepHanpticPulse(float startStrenth, float endStrenth, int startfreq, int endfreq, float losstime, float keepTime = 0f)
	{
		SetHanpValue(startStrenth, startfreq, keepTime);
		yield return new WaitForSeconds(keepTime);
		float timer = 0f;
		while (timer < losstime)
		{
			timer += Time.deltaTime;
			yield return new WaitForEndOfFrame();
			SetHanpValue(Mathf.Lerp(startStrenth, endStrenth, timer / losstime), (int)Mathf.Lerp(startfreq, endfreq, timer / losstime), 0.1f);
		}
	}

	private void SetHanpValue(float strenth, int freq, float time)
	{
		if (csGameSettings.CurrentDevice == XRDeviceType.PicoNeo3)
		{
			PXR_Input.SetControllerVibration(strenth, (int)(time * 1000f), (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
		}
		else
		{
			PXR_Input.SetControllerVibrationEvent((!isLeftHand) ? 1u : 0u, freq, strenth, (int)(time * 1000f));
		}
	}

	private IEnumerator IELinearHanpticPulse(float startStrenth, float endStrenth, int startfreq, int endfreq, float losstime, float keepTime = 0f)
	{
		yield return new WaitForEndOfFrame();
		float timer = 0f;
		if (csGameSettings.CurrentDevice == XRDeviceType.Pico4)
		{
			PXR_Input.SetControllerVibrationEvent((!isLeftHand) ? 1u : 0u, startfreq, startStrenth, (int)(losstime * 1000f));
			while (timer < losstime)
			{
				timer += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				PXR_Input.SetControllerVibrationEvent((!isLeftHand) ? 1u : 0u, (int)Mathf.Lerp(startfreq, endfreq, timer / losstime), Mathf.Lerp(startStrenth, endStrenth, timer / losstime), (int)(losstime * 1000f));
			}
			PXR_Input.SetControllerVibrationEvent((!isLeftHand) ? 1u : 0u, 0, 0f, 0);
		}
		else
		{
			PXR_Input.SetControllerVibration(startStrenth, (int)(losstime * 1000f), (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
			while (timer < losstime)
			{
				timer += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				PXR_Input.SetControllerVibration(Mathf.Lerp(startStrenth, endStrenth, timer / losstime), (int)(Time.deltaTime * 1000f), (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
			}
			PXR_Input.SetControllerVibration(0f, 0, (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
		}
	}

	public void TriggerHapticPulse(float s, float t)
	{
		if (temp < s)
		{
			if (TriggerHapticPulseCoroutine != null)
			{
				StopCoroutine(TriggerHapticPulseCoroutine);
			}
			TriggerHapticPulseCoroutine = StartCoroutine(IETriggerHapticPulse(s, t));
		}
		else if (TriggerHapticPulseCoroutine == null)
		{
			TriggerHapticPulseCoroutine = StartCoroutine(IETriggerHapticPulse(s, t));
		}
		temp = s;
	}

	private IEnumerator IETriggerHapticPulse(float strength, float t)
	{
		isPulsing = true;
		PXR_Input.SetControllerVibration(strength, (int)(t * 1000f), (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
		yield return new WaitForSeconds(t);
		PXR_Input.SetControllerVibration(0f, 0, (!isLeftHand) ? PXR_Input.Controller.RightController : PXR_Input.Controller.LeftController);
		isPulsing = false;
		temp = 0f;
	}
}
public class csControllerForSteamVR : MonoBehaviour
{
	[Tooltip("The device this action should apply to. Any if the action is not device specific.")]
	public Transform thisT;

	public bool isBusy;
}
[Serializable]
public class hapticTest
{
	public float hapticminStrenth;

	public float hapticmaxStrenth;

	public float hapticlosstime;

	public float haptickeeptime;

	public int hapticmaxfrequency;

	public int hapticminfrequency;
}
public class csControllerTest : MonoBehaviour
{
	public TMP_InputField minStrenthInput;

	public TMP_InputField maxStrenthInput;

	public TMP_InputField losstimeInput;

	public TMP_InputField keeptimeInput;

	public TMP_InputField maxfrequencyInput;

	public TMP_InputField minfrequencyInput;

	public Button defaultStartBtn;

	public Button maxfrequencyUpBtn;

	public Button maxfrequencyDownBtn;

	public Button maxStrenthUpBtn;

	public Button maxStrenthDownBtn;

	public Button lossTimeUpBtn;

	public Button lossTimeDownBtn;

	public Button minfrequencyUpBtn;

	public Button minfrequencyDownBtn;

	public Button minStrenthUpBtn;

	public Button minStrenthDownBtn;

	public Button keepTimeUpBtn;

	public Button keepTimeDownBtn;

	public hapticTest defence;

	public hapticTest punchLV1;

	public hapticTest punchLV2;

	private float minStrenth;

	private float maxStrenth;

	private float losstime;

	private float keeptime;

	private int maxfrequency;

	private int minfrequency;

	public static csControllerTest instance;

	public bool UseHapTest;

	private void Start()
	{
		instance = this;
		defaultStartBtn.onClick.AddListener(defaultHaptic);
	}

	private void StartHapticPulse(hapticTest haptictType)
	{
		haptictType.hapticminStrenth = float.Parse(minStrenthInput.text);
		haptictType.hapticmaxStrenth = float.Parse(maxStrenthInput.text);
		haptictType.hapticlosstime = float.Parse(losstimeInput.text);
		haptictType.haptickeeptime = float.Parse(keeptimeInput.text);
		haptictType.hapticmaxfrequency = int.Parse(maxfrequencyInput.text);
		haptictType.hapticminfrequency = int.Parse(minfrequencyInput.text);
		csPlayer.instance.SetControllerVibration(haptictType.hapticmaxStrenth, haptictType.hapticmaxfrequency, haptictType.hapticminStrenth, haptictType.hapticminfrequency, haptictType.haptickeeptime, haptictType.hapticlosstime);
		csPlayer.instance.TriggerHandHaptic(isL: true);
		csPlayer.instance.TriggerHandHaptic(isL: false);
	}

	public void defaultHaptic()
	{
		UseHapTest = true;
		minStrenth = float.Parse(minStrenthInput.text);
		maxStrenth = float.Parse(maxStrenthInput.text);
		losstime = float.Parse(losstimeInput.text);
		keeptime = float.Parse(keeptimeInput.text);
		maxfrequency = int.Parse(maxfrequencyInput.text);
		minfrequency = int.Parse(minfrequencyInput.text);
		punchLV2.hapticminStrenth = float.Parse(minStrenthInput.text);
		punchLV2.hapticmaxStrenth = float.Parse(maxStrenthInput.text);
		punchLV2.hapticlosstime = float.Parse(losstimeInput.text);
		punchLV2.haptickeeptime = float.Parse(keeptimeInput.text);
		punchLV2.hapticmaxfrequency = int.Parse(maxfrequencyInput.text);
		punchLV2.hapticminfrequency = int.Parse(minfrequencyInput.text);
		csPlayer.instance.SetControllerVibration(maxStrenth, maxfrequency, minStrenth, minfrequency, keeptime, losstime);
		csPlayer.instance.TriggerHandHaptic(isL: true);
		csPlayer.instance.TriggerHandHaptic(isL: false);
	}

	public void DefenceHit()
	{
		csPlayer.instance.SetControllerVibration(defence.hapticmaxStrenth, defence.hapticmaxfrequency, defence.hapticminStrenth, defence.hapticminfrequency, defence.haptickeeptime, defence.hapticlosstime);
		csPlayer.instance.TriggerHandHaptic(isL: true);
		csPlayer.instance.TriggerHandHaptic(isL: false);
		csAudioManager.instance.playAudioAtPoint("defenceSuccess", csGameSettings.SoundEffectVol * 0.25f, base.transform.position);
	}

	public void PunchLV1(bool isLeft)
	{
		csPlayer.instance.SetControllerVibration(punchLV1.hapticmaxStrenth, punchLV1.hapticmaxfrequency, punchLV1.hapticminStrenth, punchLV1.hapticminfrequency, punchLV1.haptickeeptime, punchLV1.hapticlosstime);
		if (isLeft)
		{
			csPlayer.instance.TriggerHandHaptic(isL: true);
		}
		else
		{
			csPlayer.instance.TriggerHandHaptic(isL: false);
		}
		csAudioManager.instance.playAudioAtPoint("normalSuccess1", csGameSettings.SoundEffectVol * 0.25f, base.transform.position);
	}

	public void PunchLV2(bool isLeft)
	{
		csPlayer.instance.SetControllerVibration(punchLV2.hapticmaxStrenth, punchLV2.hapticmaxfrequency, punchLV2.hapticminStrenth, punchLV2.hapticminfrequency, punchLV2.haptickeeptime, punchLV2.hapticlosstime);
		if (isLeft)
		{
			csPlayer.instance.TriggerHandHaptic(isL: true);
		}
		else
		{
			csPlayer.instance.TriggerHandHaptic(isL: false);
		}
		csAudioManager.instance.playAudioAtPoint("normalSuccess2", csGameSettings.SoundEffectVol * 0.25f, base.transform.position);
	}

	private void defenceHaptic()
	{
		StartHapticPulse(defence);
	}

	private void punchLV1Haptic()
	{
		StartHapticPulse(punchLV1);
	}

	private void punchLV2Haptic()
	{
		StartHapticPulse(punchLV2);
	}

	private void maxfrequencyUp()
	{
		maxfrequencyInput.text = (int.Parse(maxfrequencyInput.text) + 1).ToString();
		maxfrequency = int.Parse(maxfrequencyInput.text);
		if (maxfrequency > 300)
		{
			maxfrequency = 300;
			maxfrequencyInput.text = maxfrequency.ToString();
		}
	}

	private void maxfrequencyDown()
	{
		maxfrequencyInput.text = (int.Parse(maxfrequencyInput.text) - 1).ToString();
		maxfrequency = int.Parse(maxfrequencyInput.text);
		if (maxfrequency < 50)
		{
			maxfrequency = 50;
			maxfrequencyInput.text = maxfrequency.ToString();
		}
	}

	private void minfrequencyUp()
	{
		minfrequencyInput.text = (int.Parse(minfrequencyInput.text) + 1).ToString();
		minfrequency = int.Parse(minfrequencyInput.text);
		if (minfrequency > 300)
		{
			minfrequency = 300;
			minfrequencyInput.text = minfrequency.ToString();
		}
	}

	private void minfrequencyDown()
	{
		minfrequencyInput.text = (int.Parse(minfrequencyInput.text) - 1).ToString();
		minfrequency = int.Parse(minfrequencyInput.text);
		if (minfrequency < 50)
		{
			minfrequency = 50;
			minfrequencyInput.text = minfrequency.ToString();
		}
	}

	private void minStrenthUp()
	{
		minStrenthInput.text = (float.Parse(minStrenthInput.text) + 0.1f).ToString();
		minStrenth = float.Parse(minStrenthInput.text);
		if (minStrenth > 1f)
		{
			minStrenth = 1f;
			minStrenthInput.text = minStrenth.ToString();
		}
	}

	private void minStrenthDown()
	{
		minStrenthInput.text = (float.Parse(minStrenthInput.text) - 0.1f).ToString();
		minStrenth = float.Parse(minStrenthInput.text);
		if (minStrenth < 0f)
		{
			minStrenth = 0f;
			minStrenthInput.text = minStrenth.ToString();
		}
	}

	private void maxStrenthUp()
	{
		maxStrenthInput.text = (float.Parse(maxStrenthInput.text) + 0.1f).ToString();
		maxStrenth = float.Parse(maxStrenthInput.text);
		if (maxStrenth > 1f)
		{
			maxStrenth = 1f;
			maxStrenthInput.text = maxStrenth.ToString();
		}
	}

	private void maxStrenthDown()
	{
		maxStrenthInput.text = (float.Parse(maxStrenthInput.text) - 0.1f).ToString();
		maxStrenth = float.Parse(maxStrenthInput.text);
		if (maxStrenth < 0f)
		{
			maxStrenth = 0f;
			maxStrenthInput.text = maxStrenth.ToString();
		}
	}

	private void losstimeUp()
	{
		losstimeInput.text = (int.Parse(losstimeInput.text) + 1).ToString();
		losstime = int.Parse(losstimeInput.text);
		if (losstime > 500f)
		{
			losstime = 500f;
			losstimeInput.text = losstime.ToString();
		}
	}

	private void lossTimeDown()
	{
		losstimeInput.text = (int.Parse(losstimeInput.text) - 1).ToString();
		losstime = int.Parse(losstimeInput.text);
		if (losstime < 0f)
		{
			losstime = 0f;
			losstimeInput.text = losstime.ToString();
		}
	}

	private void KeeptimeUp()
	{
		keeptimeInput.text = (int.Parse(keeptimeInput.text) + 1).ToString();
		keeptime = int.Parse(keeptimeInput.text);
		if (keeptime > 500f)
		{
			keeptime = 500f;
			keeptimeInput.text = keeptime.ToString();
		}
	}

	private void KeepTimeDown()
	{
		keeptimeInput.text = (int.Parse(keeptimeInput.text) - 1).ToString();
		keeptime = int.Parse(keeptimeInput.text);
		if (keeptime < 50f)
		{
			keeptime = 50f;
			keeptimeInput.text = keeptime.ToString();
		}
	}
}
public class csHandTriggerRaycast : MonoBehaviour
{
	public List<csPageMoveTrigger> TriggerList = new List<csPageMoveTrigger>();

	public csControllerforPicoXR RayControllerXR;

	public LayerMask TriggerCastLayer;

	private RaycastHit[] Hits;

	private Ray CastRay;

	private Vector2 joyStickpos;

	private bool DeadZoneStateReset = true;

	private void Update()
	{
		CastRay.origin = RayControllerXR.thisT.position;
		CastRay.direction = RayControllerXR.thisT.forward;
		Hits = Physics.RaycastAll(CastRay, 10f, TriggerCastLayer);
		TriggerList.Clear();
		for (int i = 0; i < Hits.Length; i++)
		{
			csPageMoveTrigger component = Hits[i].collider.GetComponent<csPageMoveTrigger>();
			if (component != null)
			{
				TriggerList.Add(component);
			}
		}
		joyStickpos = RayControllerXR.JoyStickPos();
		if (joyStickpos.sqrMagnitude < 0.01f)
		{
			DeadZoneStateReset = true;
		}
		if (!DeadZoneStateReset || !(joyStickpos.sqrMagnitude >= 0.04f))
		{
			return;
		}
		if (Mathf.Abs(joyStickpos.x) > Mathf.Abs(joyStickpos.y))
		{
			if (joyStickpos.x > 0f)
			{
				foreach (csPageMoveTrigger trigger in TriggerList)
				{
					trigger.OnPageRightAct?.Invoke();
				}
			}
			else
			{
				foreach (csPageMoveTrigger trigger2 in TriggerList)
				{
					trigger2.OnPageLeftAct?.Invoke();
				}
			}
		}
		else if (joyStickpos.y > 0f)
		{
			foreach (csPageMoveTrigger trigger3 in TriggerList)
			{
				trigger3.OnPageUpAct?.Invoke();
			}
		}
		else
		{
			foreach (csPageMoveTrigger trigger4 in TriggerList)
			{
				trigger4.OnPageDownAct?.Invoke();
			}
		}
		DeadZoneStateReset = false;
	}
}
public class csOnPointerEvents : MonoBehaviour, IPointerUpHandler, IEventSystemHandler
{
	public UnityAction OnPointUpAct;

	public void OnPointerUp(PointerEventData eventData)
	{
		OnPointUpAct?.Invoke();
	}
}
public class csPageMoveTrigger : MonoBehaviour
{
	public UnityAction OnPageUpAct;

	public UnityAction OnPageDownAct;

	public UnityAction OnPageLeftAct;

	public UnityAction OnPageRightAct;

	private void Start()
	{
		OnPageUpAct = (UnityAction)Delegate.Combine(OnPageUpAct, new UnityAction(OnButtonClick));
		OnPageDownAct = (UnityAction)Delegate.Combine(OnPageDownAct, new UnityAction(OnButtonClick));
		OnPageLeftAct = (UnityAction)Delegate.Combine(OnPageLeftAct, new UnityAction(OnButtonClick));
		OnPageRightAct = (UnityAction)Delegate.Combine(OnPageRightAct, new UnityAction(OnButtonClick));
	}

	private void OnButtonClick()
	{
		csAudioManager.instance.playAudioByName("btnClick");
	}
}
[RequireComponent(typeof(Button))]
public class csVRButtonInMenu : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler
{
	[SerializeField]
	private GameObject normalEffectObj;

	[SerializeField]
	private GameObject hoverEffectObj;

	[SerializeField]
	private GameObject disableEffectObj;

	[SerializeField]
	private float restZ;

	[SerializeField]
	private float OnHoverZ = -50f;

	[SerializeField]
	private GameObject selectedEffectObj;

	[SerializeField]
	private bool showHoverWhenSelected = true;

	public Button button;

	public bool zoomed;

	private bool selected;

	private bool canInteractive = true;

	public AudioClip selectedMusic;

	public bool dontShowSelectWhenHover;

	public bool HideHoverWhenOnSelect;

	private void Awake()
	{
		if (normalEffectObj != null && !selected)
		{
			normalEffectObj.SetActive(value: true);
		}
		if (hoverEffectObj != null)
		{
			hoverEffectObj.SetActive(value: false);
		}
	}

	public void DisableInteractive()
	{
		canInteractive = false;
		if (disableEffectObj != null)
		{
			disableEffectObj.SetActive(value: true);
		}
		if (normalEffectObj != null)
		{
			normalEffectObj.SetActive(value: false);
		}
		if (hoverEffectObj != null)
		{
			hoverEffectObj.SetActive(value: false);
		}
		if (selectedEffectObj != null)
		{
			selectedEffectObj.SetActive(value: false);
		}
	}

	public void EnableInteractive()
	{
		canInteractive = true;
		if (disableEffectObj != null)
		{
			disableEffectObj.SetActive(value: false);
		}
		if (normalEffectObj != null)
		{
			normalEffectObj.SetActive(value: true);
		}
		if (hoverEffectObj != null)
		{
			hoverEffectObj.SetActive(value: false);
		}
		if (selectedEffectObj != null)
		{
			selectedEffectObj.SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		if (normalEffectObj != null)
		{
			normalEffectObj.SetActive(value: true);
		}
		if (hoverEffectObj != null)
		{
			(hoverEffectObj.transform as RectTransform).anchoredPosition3D = new Vector3((hoverEffectObj.transform as RectTransform).anchoredPosition3D.x, (hoverEffectObj.transform as RectTransform).anchoredPosition3D.y, restZ);
			hoverEffectObj.SetActive(value: false);
		}
		if (selectedEffectObj != null)
		{
			selectedEffectObj.SetActive(value: false);
		}
		if (disableEffectObj != null)
		{
			disableEffectObj.SetActive(value: false);
		}
		zoomed = false;
	}

	private void OnEnable()
	{
		if (selected)
		{
			if (selectedEffectObj != null)
			{
				selectedEffectObj.SetActive(value: true);
			}
			if (normalEffectObj != null)
			{
				normalEffectObj.SetActive(value: false);
			}
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (canInteractive && !zoomed)
		{
			if (normalEffectObj != null)
			{
				normalEffectObj.SetActive(value: false);
			}
			if (hoverEffectObj != null && (!selected || (selected && showHoverWhenSelected)))
			{
				hoverEffectObj.SetActive(value: true);
			}
			if (selectedEffectObj != null && selected && showHoverWhenSelected && dontShowSelectWhenHover)
			{
				selectedEffectObj.SetActive(value: false);
			}
			zoomed = true;
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (canInteractive && zoomed)
		{
			if (normalEffectObj != null && !selected)
			{
				normalEffectObj.SetActive(value: true);
			}
			if (hoverEffectObj != null)
			{
				hoverEffectObj.SetActive(value: false);
			}
			if (selectedEffectObj != null && selected && showHoverWhenSelected && dontShowSelectWhenHover)
			{
				selectedEffectObj.SetActive(value: true);
			}
			zoomed = false;
		}
	}

	private void Update()
	{
		if (canInteractive)
		{
			if (selectedEffectObj != null && selectedEffectObj.activeSelf && showHoverWhenSelected)
			{
				(selectedEffectObj.transform as RectTransform).anchoredPosition3D = (selectedEffectObj.transform as RectTransform).anchoredPosition3D.ModifyZ(Mathf.Clamp(zoomed ? ((selectedEffectObj.transform as RectTransform).anchoredPosition3D.z + Time.deltaTime * (OnHoverZ - restZ) * 6f) : ((selectedEffectObj.transform as RectTransform).anchoredPosition3D.z - Time.deltaTime * (OnHoverZ - restZ) * 6f), OnHoverZ, restZ));
			}
			if (hoverEffectObj != null && hoverEffectObj.activeSelf)
			{
				(hoverEffectObj.transform as RectTransform).anchoredPosition3D = (hoverEffectObj.transform as RectTransform).anchoredPosition3D.ModifyZ(Mathf.Clamp(zoomed ? ((hoverEffectObj.transform as RectTransform).anchoredPosition3D.z + Time.deltaTime * (OnHoverZ - restZ) * 6f) : ((hoverEffectObj.transform as RectTransform).anchoredPosition3D.z - Time.deltaTime * (OnHoverZ - restZ) * 6f), OnHoverZ, restZ));
			}
		}
	}

	public void OnSelect()
	{
		if (canInteractive)
		{
			selected = true;
			if (normalEffectObj != null)
			{
				normalEffectObj.SetActive(value: false);
			}
			if (hoverEffectObj != null && !showHoverWhenSelected)
			{
				hoverEffectObj.SetActive(showHoverWhenSelected);
			}
			if (hoverEffectObj != null && HideHoverWhenOnSelect)
			{
				hoverEffectObj.SetActive(value: false);
			}
			selectedEffectObj.SetActive(value: true);
		}
	}

	public void DeSelect()
	{
		if (canInteractive)
		{
			if (normalEffectObj != null)
			{
				normalEffectObj.SetActive(value: true);
			}
			if (hoverEffectObj != null && HideHoverWhenOnSelect)
			{
				hoverEffectObj.SetActive(value: false);
			}
			selectedEffectObj.SetActive(value: false);
			selected = false;
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (!csGameSettings.isLoading && selectedMusic != null)
		{
			AudioSource.PlayClipAtPoint(selectedMusic, base.transform.position);
		}
	}
}
public class csXRInput : MonoBehaviour
{
	public static csXRInput Instance;

	private UnityEngine.XR.InputDevice leftHandController;

	private UnityEngine.XR.InputDevice rightHandController;

	private UnityEngine.XR.InputDevice headController;

	private int UpdateCount;

	public Dictionary<ButtonType, int> OnButtonDownGetCountDic = new Dictionary<ButtonType, int>();

	public Dictionary<ButtonType, int> OnButtonUpGetCountDic = new Dictionary<ButtonType, int>();

	public Dictionary<ButtonType, bool> OnButtonPressLastValueDown = new Dictionary<ButtonType, bool>();

	public Dictionary<ButtonType, bool> OnButtonPressLastValueUp = new Dictionary<ButtonType, bool>();

	public Dictionary<ButtonType, bool> OnButtonLastDownValue = new Dictionary<ButtonType, bool>();

	public Dictionary<ButtonType, bool> OnButtonLastUpValue = new Dictionary<ButtonType, bool>();

	private void Awake()
	{
		if (Instance == null)
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			Instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		leftHandController = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		rightHandController = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		headController = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		OnButtonPressLastValueUp.Add(ButtonType.MenuButtonL, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.MenuButtonR, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.TriggerButtonL, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.TriggerButtonR, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.GripButtonL, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.GripButtonR, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.primary2DAxisClickL, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.primary2DAxisClickR, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.primaryButtonLeft, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.secondaryButtonLeft, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.primaryButtonRight, value: false);
		OnButtonPressLastValueUp.Add(ButtonType.secondaryButtonRight, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.MenuButtonL, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.MenuButtonR, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.TriggerButtonL, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.TriggerButtonR, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.GripButtonL, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.GripButtonR, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.primary2DAxisClickL, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.primary2DAxisClickR, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.primaryButtonLeft, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.secondaryButtonLeft, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.primaryButtonRight, value: false);
		OnButtonPressLastValueDown.Add(ButtonType.secondaryButtonRight, value: false);
		OnButtonLastDownValue.Add(ButtonType.MenuButtonL, value: false);
		OnButtonLastDownValue.Add(ButtonType.TriggerButtonL, value: false);
		OnButtonLastDownValue.Add(ButtonType.GripButtonL, value: false);
		OnButtonLastDownValue.Add(ButtonType.primary2DAxisClickL, value: false);
		OnButtonLastDownValue.Add(ButtonType.MenuButtonR, value: false);
		OnButtonLastDownValue.Add(ButtonType.TriggerButtonR, value: false);
		OnButtonLastDownValue.Add(ButtonType.GripButtonR, value: false);
		OnButtonLastDownValue.Add(ButtonType.primary2DAxisClickR, value: false);
		OnButtonLastDownValue.Add(ButtonType.primaryButtonLeft, value: false);
		OnButtonLastDownValue.Add(ButtonType.secondaryButtonLeft, value: false);
		OnButtonLastDownValue.Add(ButtonType.primaryButtonRight, value: false);
		OnButtonLastDownValue.Add(ButtonType.secondaryButtonRight, value: false);
		OnButtonLastUpValue.Add(ButtonType.MenuButtonL, value: false);
		OnButtonLastUpValue.Add(ButtonType.TriggerButtonL, value: false);
		OnButtonLastUpValue.Add(ButtonType.GripButtonL, value: false);
		OnButtonLastUpValue.Add(ButtonType.primary2DAxisClickL, value: false);
		OnButtonLastUpValue.Add(ButtonType.MenuButtonR, value: false);
		OnButtonLastUpValue.Add(ButtonType.TriggerButtonR, value: false);
		OnButtonLastUpValue.Add(ButtonType.GripButtonR, value: false);
		OnButtonLastUpValue.Add(ButtonType.primary2DAxisClickR, value: false);
		OnButtonLastUpValue.Add(ButtonType.primaryButtonLeft, value: false);
		OnButtonLastUpValue.Add(ButtonType.secondaryButtonLeft, value: false);
		OnButtonLastUpValue.Add(ButtonType.primaryButtonRight, value: false);
		OnButtonLastUpValue.Add(ButtonType.secondaryButtonRight, value: false);
		OnButtonDownGetCountDic.Add(ButtonType.MenuButtonL, -1);
		OnButtonDownGetCountDic.Add(ButtonType.TriggerButtonL, -1);
		OnButtonDownGetCountDic.Add(ButtonType.GripButtonL, -1);
		OnButtonDownGetCountDic.Add(ButtonType.primary2DAxisClickL, -1);
		OnButtonDownGetCountDic.Add(ButtonType.MenuButtonR, -1);
		OnButtonDownGetCountDic.Add(ButtonType.TriggerButtonR, -1);
		OnButtonDownGetCountDic.Add(ButtonType.GripButtonR, -1);
		OnButtonDownGetCountDic.Add(ButtonType.primary2DAxisClickR, -1);
		OnButtonDownGetCountDic.Add(ButtonType.primaryButtonLeft, -1);
		OnButtonDownGetCountDic.Add(ButtonType.secondaryButtonLeft, -1);
		OnButtonDownGetCountDic.Add(ButtonType.primaryButtonRight, -1);
		OnButtonDownGetCountDic.Add(ButtonType.secondaryButtonRight, -1);
		OnButtonUpGetCountDic.Add(ButtonType.MenuButtonL, -1);
		OnButtonUpGetCountDic.Add(ButtonType.TriggerButtonL, -1);
		OnButtonUpGetCountDic.Add(ButtonType.GripButtonL, -1);
		OnButtonUpGetCountDic.Add(ButtonType.primary2DAxisClickL, -1);
		OnButtonUpGetCountDic.Add(ButtonType.MenuButtonR, -1);
		OnButtonUpGetCountDic.Add(ButtonType.TriggerButtonR, -1);
		OnButtonUpGetCountDic.Add(ButtonType.GripButtonR, -1);
		OnButtonUpGetCountDic.Add(ButtonType.primary2DAxisClickR, -1);
		OnButtonUpGetCountDic.Add(ButtonType.primaryButtonLeft, -1);
		OnButtonUpGetCountDic.Add(ButtonType.secondaryButtonLeft, -1);
		OnButtonUpGetCountDic.Add(ButtonType.primaryButtonRight, -1);
		OnButtonUpGetCountDic.Add(ButtonType.secondaryButtonRight, -1);
		InputDevices.deviceConnected += OnDevice;
		StartCoroutine(WaitAFrame());
	}

	private void OnDestroy()
	{
		InputDevices.deviceConnected -= OnDevice;
	}

	private void OnDevice(UnityEngine.XR.InputDevice ipd)
	{
		leftHandController = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		rightHandController = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		headController = InputDevices.GetDeviceAtXRNode(XRNode.Head);
	}

	private IEnumerator WaitAFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			UpdateCount++;
			if (UpdateCount > 5000)
			{
				UpdateCount = 0;
			}
		}
	}

	public Vector3 GetControllerVel(bool IsLeft)
	{
		Vector3 value = Vector3.zero;
		(IsLeft ? leftHandController : rightHandController).TryGetFeatureValue(UnityEngine.XR.CommonUsages.deviceVelocity, out value);
		return value;
	}

	public Vector3 GetHeadControllerVel()
	{
		Vector3 value = Vector3.zero;
		headController.TryGetFeatureValue(UnityEngine.XR.CommonUsages.centerEyeVelocity, out value);
		return value;
	}

	public Vector3 GetControllerAcc(bool IsLeft)
	{
		Vector3 value = Vector3.zero;
		(IsLeft ? leftHandController : rightHandController).TryGetFeatureValue(UnityEngine.XR.CommonUsages.deviceAcceleration, out value);
		return value;
	}

	public Vector3 GetHeadControllerAcc()
	{
		Vector3 value = Vector3.zero;
		headController.TryGetFeatureValue(UnityEngine.XR.CommonUsages.centerEyeAcceleration, out value);
		return value;
	}

	public bool TryGetButtonValue(ButtonType bt, PressState ps, bool IsLeft)
	{
		bool value = false;
		UnityEngine.XR.InputDevice inputDevice = (IsLeft ? leftHandController : rightHandController);
		InputFeatureUsage<bool> usage = default(InputFeatureUsage<bool>);
		switch (bt)
		{
		case ButtonType.MenuButton:
		case ButtonType.MenuButtonL:
		case ButtonType.MenuButtonR:
			usage = UnityEngine.XR.CommonUsages.menuButton;
			bt = (IsLeft ? ButtonType.MenuButtonL : ButtonType.MenuButtonR);
			break;
		case ButtonType.TriggerButton:
		case ButtonType.TriggerButtonL:
		case ButtonType.TriggerButtonR:
			usage = UnityEngine.XR.CommonUsages.triggerButton;
			bt = ((!IsLeft) ? ButtonType.TriggerButtonR : ButtonType.TriggerButtonL);
			break;
		case ButtonType.GripButton:
		case ButtonType.GripButtonL:
		case ButtonType.GripButtonR:
			usage = UnityEngine.XR.CommonUsages.gripButton;
			bt = ((!IsLeft) ? ButtonType.GripButtonR : ButtonType.GripButtonL);
			break;
		case ButtonType.primary2DAxisClick:
		case ButtonType.primary2DAxisClickL:
		case ButtonType.primary2DAxisClickR:
			usage = UnityEngine.XR.CommonUsages.primary2DAxisClick;
			bt = ((!IsLeft) ? ButtonType.primary2DAxisClickR : ButtonType.primary2DAxisClickL);
			break;
		case ButtonType.primaryButton:
		case ButtonType.primaryButtonLeft:
		case ButtonType.primaryButtonRight:
			usage = UnityEngine.XR.CommonUsages.primaryButton;
			bt = ((!IsLeft) ? ButtonType.primaryButtonRight : ButtonType.primaryButtonLeft);
			break;
		case ButtonType.secondaryButton:
		case ButtonType.secondaryButtonLeft:
		case ButtonType.secondaryButtonRight:
			usage = UnityEngine.XR.CommonUsages.secondaryButton;
			bt = ((!IsLeft) ? ButtonType.secondaryButtonRight : ButtonType.secondaryButtonLeft);
			break;
		}
		switch (ps)
		{
		case PressState.Pressing:
			inputDevice.TryGetFeatureValue(usage, out value);
			break;
		case PressState.Down:
		{
			if (OnButtonDownGetCountDic[bt] == UpdateCount)
			{
				value = OnButtonLastDownValue[bt];
				break;
			}
			bool value3 = false;
			OnButtonDownGetCountDic[bt] = -1;
			inputDevice.TryGetFeatureValue(usage, out value3);
			if (!OnButtonPressLastValueDown[bt] && value3)
			{
				OnButtonLastDownValue[bt] = true;
				OnButtonDownGetCountDic[bt] = UpdateCount;
				value = true;
			}
			else
			{
				value = false;
			}
			OnButtonPressLastValueDown[bt] = value3;
			break;
		}
		case PressState.Up:
		{
			if (OnButtonUpGetCountDic[bt] == UpdateCount)
			{
				value = OnButtonLastUpValue[bt];
				break;
			}
			OnButtonUpGetCountDic[bt] = -1;
			bool value2 = false;
			inputDevice.TryGetFeatureValue(usage, out value2);
			if (OnButtonPressLastValueUp[bt] && !value2)
			{
				OnButtonUpGetCountDic[bt] = UpdateCount;
				OnButtonLastUpValue[bt] = true;
				value = true;
			}
			else
			{
				value = false;
			}
			OnButtonPressLastValueUp[bt] = value2;
			break;
		}
		}
		return value;
	}

	public Vector2 TryGetJoystickValue(bool IsLeft)
	{
		(IsLeft ? leftHandController : rightHandController).TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out var value);
		return value;
	}

	public float TryGetTriggerValue(bool IsLeft)
	{
		(IsLeft ? leftHandController : rightHandController).TryGetFeatureValue(UnityEngine.XR.CommonUsages.trigger, out var value);
		return value;
	}
}
public enum ButtonType
{
	MenuButton,
	MenuButtonL,
	MenuButtonR,
	TriggerButton,
	TriggerButtonL,
	TriggerButtonR,
	GripButton,
	GripButtonL,
	GripButtonR,
	primary2DAxisClick,
	primary2DAxisClickL,
	primary2DAxisClickR,
	primaryButton,
	primaryButtonLeft,
	primaryButtonRight,
	secondaryButton,
	secondaryButtonLeft,
	secondaryButtonRight
}
public enum PressState
{
	Down,
	Pressing,
	Up
}
public static class ExtensionMethod
{
	public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
	{
		return DOTween.To(() => target.horizontalNormalizedPosition, delegate(float x)
		{
			target.horizontalNormalizedPosition = x;
		}, endValue, duration).SetOptions(snapping).SetTarget(target);
	}

	public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
	{
		return DOTween.To(() => target.verticalNormalizedPosition, delegate(float x)
		{
			target.verticalNormalizedPosition = x;
		}, endValue, duration).SetOptions(snapping).SetTarget(target);
	}

	public static Vector3 ModifyZ(this Vector3 trans, float newVal)
	{
		trans = new Vector3(trans.x, trans.y, newVal);
		return trans;
	}
}
public class XRKeyInput : MonoBehaviour
{
	private void Update()
	{
		csXRInput.Instance.TryGetButtonValue(ButtonType.primaryButton, PressState.Down, IsLeft: true);
		csXRInput.Instance.GetControllerVel(IsLeft: true);
		csXRInput.Instance.TryGetJoystickValue(IsLeft: true);
		csXRInput.Instance.TryGetTriggerValue(IsLeft: true);
	}
}
public class AvatarSpecConfig
{
	public static string userId = "662230622642634752";

	public static string specJsonStrMale = "{\n\"info\": {\n    \"sex\": \"female\",\n    \"background\": {\n        \"color\": [\n            255,\n            255,\n            0\n        ],\n        \"image\": \"https://dfsedffe.png\"\n    }\n},\n\"graph\": {\n    \"type\": \"PicoAvatar\",\n    \"label\": \"general asset graph for pico avatar\",\n    \"nodes\": {\n        \"1\": {\n            \"label\": \"Body\",\n            \"metadata\": {\n                \"tag\": \"Body_dev\",\n                \"uuid\": \"1124192375956492288\",\n                \"colors\": {\n                    \"circleColor\": [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                },\n                \"category\": \"Body\",\n                \"textures\": {\n                    \"signature\": \"fsegisjf\"\n                },\n                \"incompatibleTags\": [\n                    \"hair_longBangs\"\n                ]\n            }\n        },\n        \"2\": {\n            \"label\": \"Head\",\n            \"metadata\": {\n                \"tag\": \"Head_dev\",\n                \"uuid\": \"1124193712697954304\",\n                \"colors\": {\n                    \"circleColor\": [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                },\n                \"category\": \"Face_Female\",\n                \"textures\": {\n                    \"signature\": \"fsegisjf\"\n                },\n                \"incompatibleTags\": [\n                    \"hair_longBangs\"\n                ]\n            }\n        },\n        \"3\": {\n            \"label\": \"Cloth\",\n            \"metadata\": {\n                \"tag\": \"Cloth_dev\",\n                \"uuid\": \"1124399438712197120\",\n                \"colors\": {\n                    \"circleColor\": [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                },\n                \"category\": \"Clothes_Female\",\n                \"textures\": {\n                    \"signature\": \"fsegisjf\"\n                },\n                \"incompatibleTags\": [\n                    \"hair_longBangs\"\n                ]\n            }\n        },\n        \"4\": {\n            \"label\": \"Hair\",\n            \"metadata\": {\n                \"tag\": \"Hair_dev\",\n                \"uuid\": \"1124194666516238336\",\n                \"colors\": {\n                    \"circleColor\": [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                },\n                \"category\": \"Hair_Female\",\n                \"textures\": {\n                    \"signature\": \"fsegisjf\"\n                },\n                \"incompatibleTags\": [\n                    \"hair_longBangs\"\n                ]\n            }\n        },\n        \"5\": {\n            \"label\": \"Skeleton\",\n            \"metadata\": {\n                \"tag\": \"Skeleton\",\n                \"uuid\": \"1124851501048971264\",\n                \"colors\": {\n                    \"circleColor\": [\n                        1,\n                        1,\n                        1,\n                        1\n                    ]\n                },\n                \"category\": \"Skeleton\",\n                \"textures\": {\n                    \"signature\": \"fsegisjf\"\n                },\n                \"incompatibleTags\": [\n                    \"hair_longBangs\"\n                ]\n            }\n        }\n    },\n    \"directed\": true\n}\n}\n";

	public static string userIdPlaceHolder = "111111111111111111";

	public static string userIdPlaceHolderOther = "111111111111111111Other";

	public static string specJsonStrPlaceHolder = "{\n    \"info\": {\n        \"sex\": \"female\",\n        \"background\": {\n            \"color\": [\n                255,\n                255,\n                0\n            ],\n            \"image\": \"https://dfsedffe.png\"\n        }\n    },\n    \"graph\": {\n        \"type\": \"PicoAvatar\",\n        \"label\": \"general asset graph for pico avatar\",\n        \"directed\": true,\n        \"nodes\": {\n            \"1\": {\n                \"label\": \"Body\",\n                \"metadata\": {\n                    \"uuid\": \"1188395664229949440\",\n                    \"category\": \"Body\",\n                    \"tag\": \"Body_dev\",\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ],\n                    \"pins\": {\n                        \"root\": {\n                            \"type\": \"transform\",\n                            \"entityName\": \"root\"\n                        }\n                    },\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"blendshapes\": {\n                        \"mouthOpen\": 0.8\n                    },\n                    \"boneDisplacements\": {\n                        \"nose\": 0.3\n                    },\n                    \"animations\": {\n                        \"gesture1\": \"fsegfsi\"\n                    }\n                }\n            },\n            \"2\": {\n                \"label\": \"Head\",\n                \"metadata\": {\n                    \"tag\": \"Head_dev\",\n                    \"uuid\": \"1188394912090595328\",\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"category\": \"Face_Female\",\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ]\n                }\n            },\n            \"5\": {\n                \"label\": \"Skeleton\",\n                \"metadata\": {\n                    \"uuid\": \"1146383172259737600\",\n                    \"tag\": \"Skeleton\",\n                    \"category\": \"Skeleton\",\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ],\n                    \"pins\": {\n                        \"root\": {\n                            \"type\": \"transform\",\n                            \"entityName\": \"root\"\n                        }\n                    },\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"blendshapes\": {\n                        \"mouthOpen\": 0.8\n                    },\n                    \"boneDisplacements\": {\n                        \"nose\": 0.3\n                    }\n                }\n            }\n        }\n    }\n}\n";

	public static string specJsonStrPlaceHolderOverSea = "{\n    \"info\": {\n        \"sex\": \"female\",\n        \"background\": {\n            \"color\": [\n                255,\n                255,\n                0\n            ],\n            \"image\": \"https://dfsedffe.png\"\n        }\n    },\n    \"graph\": {\n        \"type\": \"PicoAvatar\",\n        \"label\": \"general asset graph for pico avatar\",\n        \"directed\": true,\n        \"nodes\": {\n            \"1\": {\n                \"label\": \"Body\",\n                \"metadata\": {\n                    \"uuid\": \"1420223972024389632\",\n                    \"category\": \"Body\",\n                    \"tag\": \"Body_dev\",\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ],\n                    \"pins\": {\n                        \"root\": {\n                            \"type\": \"transform\",\n                            \"entityName\": \"root\"\n                        }\n                    },\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"blendshapes\": {\n                        \"mouthOpen\": 0.8\n                    },\n                    \"boneDisplacements\": {\n                        \"nose\": 0.3\n                    },\n                    \"animations\": {\n                        \"gesture1\": \"fsegfsi\"\n                    }\n                }\n            },\n            \"2\": {\n                \"label\": \"Head\",\n                \"metadata\": {\n                    \"tag\": \"Head_dev\",\n                    \"uuid\": \"1420225153643712512\",\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"category\": \"Face_Female\",\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ]\n                }\n            },\n            \"5\": {\n                \"label\": \"Skeleton\",\n                \"metadata\": {\n                    \"uuid\": \"1420228126096629760\",\n                    \"tag\": \"Skeleton\",\n                    \"category\": \"Skeleton\",\n                    \"incompatibleTags\": [\n                        \"hair_longBangs\"\n                    ],\n                    \"pins\": {\n                        \"root\": {\n                            \"type\": \"transform\",\n                            \"entityName\": \"root\"\n                        }\n                    },\n                    \"colors\": {\n                        \"circleColor\": [\n                            1,\n                            1,\n                            1,\n                            1\n                        ]\n                    },\n                    \"textures\": {\n                        \"signature\": \"fsegisjf\"\n                    },\n                    \"blendshapes\": {\n                        \"mouthOpen\": 0.8\n                    },\n                    \"boneDisplacements\": {\n                        \"nose\": 0.3\n                    }\n                }\n            }\n        }\n    }\n}\n";
}
public class EditorInputDevice : MonoBehaviour
{
	private static Dictionary<string, EditorInputDevice> _devices = new Dictionary<string, EditorInputDevice>();

	public string UserId;

	public bool useEditorTarget;

	public Transform transRoot;

	public Transform transHead;

	public Transform transLeft;

	public Transform transRight;

	public bool isWorking { get; private set; }

	public static EditorInputDevice GetDevice(string userId)
	{
		if (_devices.TryGetValue(userId, out var value))
		{
			return value;
		}
		return null;
	}

	public void Init()
	{
		if (!isWorking)
		{
			if (_devices.ContainsKey(UserId))
			{
				UnityEngine.Debug.LogErrorFormat("EditorInputDevice with userId {0} is allready exist.", UserId);
			}
			else
			{
				_devices.Add(UserId, this);
				isWorking = true;
			}
		}
	}

	public void DeInit()
	{
		if (isWorking)
		{
			_devices.Remove(UserId);
			isWorking = false;
		}
	}

	private void Start()
	{
		Init();
	}

	private void OnDestroy()
	{
		DeInit();
	}
}
public class PicoDebugPause : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class PicoJNIHelper
{
	public static bool IsPrimitive(Type t)
	{
		return t.IsPrimitive;
	}

	public static jvalue[] CreateJNIArgArray(object[] args)
	{
		jvalue[] array = new jvalue[args.GetLength(0)];
		int num = 0;
		foreach (object obj in args)
		{
			if (obj == null)
			{
				array[num].l = IntPtr.Zero;
			}
			else if (IsPrimitive(obj.GetType()))
			{
				if (obj is int)
				{
					array[num].i = (int)obj;
				}
				else if (obj is bool)
				{
					array[num].z = (bool)obj;
				}
				else if (obj is byte)
				{
					UnityEngine.Debug.LogWarning("Passing Byte arguments to Java methods is obsolete, pass SByte parameters instead");
					array[num].b = (sbyte)(byte)obj;
				}
				else if (obj is sbyte)
				{
					array[num].b = (sbyte)obj;
				}
				else if (obj is short)
				{
					array[num].s = (short)obj;
				}
				else if (obj is long)
				{
					array[num].j = (long)obj;
				}
				else if (obj is float)
				{
					array[num].f = (float)obj;
				}
				else if (obj is double)
				{
					array[num].d = (double)obj;
				}
				else if (obj is char)
				{
					array[num].c = (char)obj;
				}
			}
			else if (obj is string)
			{
				char[] array2 = ((string)obj).ToCharArray();
				try
				{
					array[num].l = AndroidJNIHelper.ConvertToJNIArray(array2);
				}
				catch (Exception ex)
				{
					array[num].l = IntPtr.Zero;
					UnityEngine.Debug.LogError($"AndroidJNIHelper.ConvertToJNIArray is error: {obj.ToString()} msg : {ex.Message}");
				}
			}
			else if (obj is AndroidJavaClass)
			{
				array[num].l = ((AndroidJavaClass)obj).GetRawClass();
			}
			else if (obj is AndroidJavaObject)
			{
				array[num].l = ((AndroidJavaObject)obj).GetRawObject();
			}
			else if (obj is Array)
			{
				array[num].l = AndroidJNIHelper.ConvertToJNIArray((Array)obj);
			}
			else
			{
				if (!(obj is AndroidJavaRunnable))
				{
					throw new Exception("JNI; Unknown argument type '" + obj.GetType()?.ToString() + "'");
				}
				array[num].l = AndroidJNIHelper.CreateJavaRunnable((AndroidJavaRunnable)obj);
			}
			num++;
		}
		return array;
	}
}
public enum TalkingDataProfileType
{
	ANONYMOUS = 0,
	REGISTERED = 1,
	SINA_WEIBO = 2,
	QQ = 3,
	QQ_WEIBO = 4,
	ND91 = 5,
	WEIXIN = 6,
	TYPE1 = 11,
	TYPE2 = 12,
	TYPE3 = 13,
	TYPE4 = 14,
	TYPE5 = 15,
	TYPE6 = 16,
	TYPE7 = 17,
	TYPE8 = 18,
	TYPE9 = 19,
	TYPE10 = 20
}
public enum TalkingDataGender
{
	UNKNOWN,
	MALE,
	FEMALE
}
public class TalkingDataProfile
{
	public AndroidJavaObject javaObj;

	public static TalkingDataProfile CreateProfile()
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			TalkingDataProfile talkingDataProfile = new TalkingDataProfile();
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.tendcloud.tenddata.TalkingDataProfile");
			talkingDataProfile.javaObj = androidJavaClass.CallStatic<AndroidJavaObject>("createProfile", Array.Empty<object>());
			return talkingDataProfile;
		}
		return null;
	}

	public TalkingDataProfile SetName(string name)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			javaObj.Call<AndroidJavaObject>("setName", new object[1] { name });
		}
		return this;
	}

	public TalkingDataProfile SetType(TalkingDataProfileType type)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.tendcloud.tenddata.TalkingDataProfileType").CallStatic<AndroidJavaObject>("valueOf", new object[1] { type.ToString() });
			javaObj.Call<AndroidJavaObject>("setType", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetGender(TalkingDataGender gender)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.tendcloud.tenddata.TalkingDataGender").CallStatic<AndroidJavaObject>("valueOf", new object[1] { gender.ToString() });
			javaObj.Call<AndroidJavaObject>("setGender", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetAge(int age)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			javaObj.Call<AndroidJavaObject>("setAge", new object[1] { age });
		}
		return this;
	}

	public TalkingDataProfile SetProperty1(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty1", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty2(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty2", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty3(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty3", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty4(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty4", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty5(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty5", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty6(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty6", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty7(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty7", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty8(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty8", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty9(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty9", new object[1] { androidJavaObject });
		}
		return this;
	}

	public TalkingDataProfile SetProperty10(object property)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			AndroidJavaObject androidJavaObject = AndroidJavaObjectFromObject(property);
			javaObj.Call<AndroidJavaObject>("setProperty10", new object[1] { androidJavaObject });
		}
		return this;
	}

	private AndroidJavaObject AndroidJavaObjectFromObject(object parameter)
	{
		AndroidJavaObject result = null;
		if (parameter is string)
		{
			result = new AndroidJavaObject("java.lang.String", parameter);
		}
		else if (parameter is byte || parameter is sbyte)
		{
			result = new AndroidJavaObject("java.lang.Byte", parameter);
		}
		else if (parameter is short || parameter is ushort)
		{
			result = new AndroidJavaObject("java.lang.Short", parameter);
		}
		else if (parameter is int || parameter is uint)
		{
			result = new AndroidJavaObject("java.lang.Integer", parameter);
		}
		else if (parameter is long || parameter is ulong)
		{
			result = new AndroidJavaObject("java.lang.Long", parameter);
		}
		else if (parameter is float)
		{
			result = new AndroidJavaObject("java.lang.Float", parameter);
		}
		else if (parameter is double)
		{
			result = new AndroidJavaObject("java.lang.Double", parameter);
		}
		return result;
	}
}
public static class TalkingDataSDK
{
	private static readonly string TALKINGDATA_CLASS = "com.tendcloud.tenddata.TalkingDataSDK";

	private static AndroidJavaClass talkingdataClass;

	private static AndroidJavaClass unityPlayerClass;

	private static string deviceId = null;

	private static string oaid = null;

	private static AndroidJavaObject GetCurrentActivity()
	{
		if (unityPlayerClass == null)
		{
			unityPlayerClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		}
		return unityPlayerClass.GetStatic<AndroidJavaObject>("currentActivity");
	}

	public static void Init(string appId, string channelId, string custom)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			UnityEngine.Debug.Log("TalkingData Unity SDK.");
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.tendcloud.tenddata.dz"))
			{
				androidJavaClass.SetStatic("a", 2);
			}
			if (talkingdataClass == null)
			{
				talkingdataClass = new AndroidJavaClass(TALKINGDATA_CLASS);
			}
			AndroidJavaObject currentActivity = GetCurrentActivity();
			talkingdataClass.CallStatic("init", currentActivity, appId, channelId, custom);
			talkingdataClass.CallStatic("onResume", currentActivity);
		}
	}

	public static void OnPause()
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onPause", GetCurrentActivity());
			talkingdataClass = null;
			unityPlayerClass = null;
		}
	}

	public static void BackgroundSessionEnabled()
	{
		if (Application.platform != 0)
		{
			_ = Application.platform;
			_ = 7;
		}
	}

	public static string GetDeviceId()
	{
		if (deviceId == null && Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			if (talkingdataClass == null)
			{
				talkingdataClass = new AndroidJavaClass(TALKINGDATA_CLASS);
			}
			deviceId = talkingdataClass.CallStatic<string>("getDeviceId", new object[1] { GetCurrentActivity() });
		}
		return deviceId;
	}

	public static string GetOAID()
	{
		if (oaid == null && Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			if (talkingdataClass == null)
			{
				talkingdataClass = new AndroidJavaClass(TALKINGDATA_CLASS);
			}
			oaid = talkingdataClass.CallStatic<string>("getOAID", new object[1] { GetCurrentActivity() });
		}
		return oaid;
	}

	public static void SetVerboseLogDisable()
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			if (talkingdataClass == null)
			{
				talkingdataClass = new AndroidJavaClass(TALKINGDATA_CLASS);
			}
			talkingdataClass.CallStatic("setVerboseLogDisable");
		}
	}

	public static void SetLocation(double latitude, double longitude)
	{
		if (Application.platform != 0)
		{
			_ = Application.platform;
			_ = 7;
		}
	}

	public static void OnPageBegin(string pageName)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onPageBegin", GetCurrentActivity(), pageName);
		}
	}

	public static void OnPageEnd(string pageName)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onPageEnd", GetCurrentActivity(), pageName);
		}
	}

	public static void OnReceiveDeepLink(string url)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onReceiveDeepLink", url);
		}
	}

	public static void OnRegister(string profileId, TalkingDataProfile profile, string invitationCode)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onRegister", profileId, profile.javaObj, invitationCode);
		}
	}

	public static void OnLogin(string profileId, TalkingDataProfile profile)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onLogin", profileId, profile.javaObj);
		}
	}

	public static void OnProfileUpdate(TalkingDataProfile profile)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onProfileUpdate", profile.javaObj);
		}
	}

	public static void OnCreateCard(string profileId, string method, string content)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onCreateCard", profileId, method, content);
		}
	}

	public static void OnFavorite(string category, string content)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onFavorite", category, content);
		}
	}

	public static void OnShare(string profileId, string content)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onShare", profileId, content);
		}
	}

	public static void OnPunch(string profileId, string punchId)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onPunch", profileId, punchId);
		}
	}

	public static void OnSearch(TalkingDataSearch search)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onSearch", search.javaObj);
		}
	}

	public static void OnPay(string profileId, string orderId, int amount, string currencyType, string paymentType, string itemId, int itemCount)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onPay", profileId, orderId, amount, currencyType, paymentType, itemId, itemCount);
		}
	}

	public static void OnCreateRole(string name)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onCreateRole", name);
		}
	}

	public static void OnLevelPass(string profileId, string levelId)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onLevelPass", profileId, levelId);
		}
	}

	public static void OnGuideFinished(string profileId, string content)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onGuideFinished", profileId, content);
		}
	}

	public static void OnAchievementUnlock(string profileId, string achievementId)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("onAchievementUnlock", profileId, achievementId);
		}
	}

	public static void OnEvent(string eventId, double eventValue, Dictionary<string, object> parameters)
	{
		if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.WindowsEditor || talkingdataClass == null)
		{
			return;
		}
		if (parameters != null && parameters.Count > 0)
		{
			int count = parameters.Count;
			AndroidJavaObject androidJavaObject = new AndroidJavaObject("java.util.HashMap", count);
			IntPtr methodID = AndroidJNIHelper.GetMethodID(androidJavaObject.GetRawClass(), "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
			object[] array = new object[2];
			foreach (KeyValuePair<string, object> parameter in parameters)
			{
				array[0] = new AndroidJavaObject("java.lang.String", parameter.Key);
				array[1] = (typeof(string).IsInstanceOfType(parameter.Value) ? new AndroidJavaObject("java.lang.String", parameter.Value) : new AndroidJavaObject("java.lang.Double", parameter.Value?.ToString() ?? ""));
				AndroidJNI.CallObjectMethod(androidJavaObject.GetRawObject(), methodID, AndroidJNIHelper.CreateJNIArgArray(array));
			}
			talkingdataClass.CallStatic("onEvent", GetCurrentActivity(), eventId, eventValue, androidJavaObject);
			androidJavaObject.Dispose();
		}
		else
		{
			talkingdataClass.CallStatic("onEvent", GetCurrentActivity(), eventId, eventValue, null);
		}
	}

	public static void SetGlobalKV(string key, object val)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			AndroidJavaObject androidJavaObject = (typeof(string).IsInstanceOfType(val) ? new AndroidJavaObject("java.lang.String", val) : new AndroidJavaObject("java.lang.Double", val?.ToString() ?? ""));
			talkingdataClass.CallStatic("setGlobalKV", key, androidJavaObject);
		}
	}

	public static void RemoveGlobalKV(string key)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && talkingdataClass != null)
		{
			talkingdataClass.CallStatic("removeGlobalKV", key);
		}
	}
}
public class TalkingDataSearch
{
	public AndroidJavaObject javaObj;

	public static TalkingDataSearch CreateSearch()
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor)
		{
			TalkingDataSearch talkingDataSearch = new TalkingDataSearch();
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.tendcloud.tenddata.TalkingDataSearch");
			talkingDataSearch.javaObj = androidJavaClass.CallStatic<AndroidJavaObject>("createSearch", Array.Empty<object>());
			return talkingDataSearch;
		}
		return null;
	}

	public TalkingDataSearch SetCategory(string category)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			javaObj.Call<AndroidJavaObject>("setCategory", new object[1] { category });
		}
		return this;
	}

	public TalkingDataSearch SetContent(string content)
	{
		if (Application.platform != 0 && Application.platform != RuntimePlatform.WindowsEditor && javaObj != null)
		{
			javaObj.Call<AndroidJavaObject>("setContent", new object[1] { content });
		}
		return this;
	}
}
public class TDDemoScript : MonoBehaviour
{
	private const int top = 100;

	private const int left = 80;

	private const int height = 60;

	private const int spacing = 20;

	private readonly int width = (Screen.width - 160 - 20) / 2;

	private const int step = 80;

	private string tdid;

	private string oaid;

	private void OnGUI()
	{
		int num = 0;
		GUI.Box(new Rect(10f, 10f, Screen.width - 20, Screen.height - 20), "Demo Menu");
		GUI.Label(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), tdid);
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "getTDID"))
		{
			tdid = TalkingDataSDK.GetDeviceId();
		}
		GUI.Label(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), oaid);
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "getOAID"))
		{
			oaid = TalkingDataSDK.GetOAID();
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnPageBegin"))
		{
			TalkingDataSDK.OnPageBegin("home_page");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnPageEnd"))
		{
			TalkingDataSDK.OnPageEnd("home_page");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnReceiveDeepLink"))
		{
			TalkingDataSDK.OnReceiveDeepLink("https://www.talkingdata.com");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnRegister"))
		{
			TalkingDataProfile talkingDataProfile = TalkingDataProfile.CreateProfile();
			talkingDataProfile.SetName("name01");
			talkingDataProfile.SetType(TalkingDataProfileType.WEIXIN);
			talkingDataProfile.SetGender(TalkingDataGender.MALE);
			talkingDataProfile.SetAge(18);
			talkingDataProfile.SetProperty1("property1");
			talkingDataProfile.SetProperty2(2);
			talkingDataProfile.SetProperty3(3.14);
			talkingDataProfile.SetProperty4("property4");
			talkingDataProfile.SetProperty5("property5");
			talkingDataProfile.SetProperty6(0.618);
			talkingDataProfile.SetProperty7("property7");
			talkingDataProfile.SetProperty8("property8");
			talkingDataProfile.SetProperty9(9.8);
			talkingDataProfile.SetProperty10("property10");
			TalkingDataSDK.OnRegister("user01", talkingDataProfile, "123456");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnLogin"))
		{
			TalkingDataProfile talkingDataProfile2 = TalkingDataProfile.CreateProfile();
			talkingDataProfile2.SetName("name01");
			talkingDataProfile2.SetType(TalkingDataProfileType.WEIXIN);
			talkingDataProfile2.SetGender(TalkingDataGender.MALE);
			talkingDataProfile2.SetAge(18);
			talkingDataProfile2.SetProperty1("property1");
			talkingDataProfile2.SetProperty2(2);
			talkingDataProfile2.SetProperty3(3.14);
			talkingDataProfile2.SetProperty4("property4");
			talkingDataProfile2.SetProperty5("property5");
			talkingDataProfile2.SetProperty6(0.618);
			talkingDataProfile2.SetProperty7("property7");
			talkingDataProfile2.SetProperty8("property8");
			talkingDataProfile2.SetProperty9(9.8);
			talkingDataProfile2.SetProperty10("property10");
			TalkingDataSDK.OnLogin("user01", talkingDataProfile2);
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnProfileUpdate"))
		{
			TalkingDataProfile talkingDataProfile3 = TalkingDataProfile.CreateProfile();
			talkingDataProfile3.SetName("name01");
			talkingDataProfile3.SetType(TalkingDataProfileType.WEIXIN);
			talkingDataProfile3.SetGender(TalkingDataGender.MALE);
			talkingDataProfile3.SetAge(18);
			talkingDataProfile3.SetProperty1("property1");
			talkingDataProfile3.SetProperty2(2);
			talkingDataProfile3.SetProperty3(3.14);
			talkingDataProfile3.SetProperty4("property4");
			talkingDataProfile3.SetProperty5("property5");
			talkingDataProfile3.SetProperty6(0.618);
			talkingDataProfile3.SetProperty7("property7");
			talkingDataProfile3.SetProperty8("property8");
			talkingDataProfile3.SetProperty9(9.8);
			talkingDataProfile3.SetProperty10("property10");
			TalkingDataSDK.OnProfileUpdate(talkingDataProfile3);
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnCreateCard"))
		{
			TalkingDataSDK.OnCreateCard("user01", "支付宝", "支付宝账号123456789");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnFavorite"))
		{
			TalkingDataSDK.OnFavorite("服装", "2019新款");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnShare"))
		{
			TalkingDataSDK.OnShare("user01", "课程");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnPunch"))
		{
			TalkingDataSDK.OnPunch("user01", "签到0023");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnSearch"))
		{
			TalkingDataSearch talkingDataSearch = TalkingDataSearch.CreateSearch();
			talkingDataSearch.SetCategory("类型");
			talkingDataSearch.SetContent("内容");
			TalkingDataSDK.OnSearch(talkingDataSearch);
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnPay"))
		{
			TalkingDataSDK.OnPay("user01", "order01", 1077600, "CNY", "Apple Pay", "item01", 2);
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnCreateRole"))
		{
			TalkingDataSDK.OnCreateRole("role01");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnLevelPass"))
		{
			TalkingDataSDK.OnLevelPass("user01", "AdTracking_123456");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnGuideFinished"))
		{
			TalkingDataSDK.OnGuideFinished("user01", "新手教程顺利通过");
		}
		if (GUI.Button(new Rect(80 + num % 2 * (width + 20), 100 + 80 * (num++ / 2), width, 60f), "OnAchievementUnlock"))
		{
			TalkingDataSDK.OnAchievementUnlock("user01", "AdTracking_123456");
		}
		if (GUI.Button(new Rect(80f, 100 + 80 * num++, width, 60f), "OnEvent"))
		{
			Dictionary<string, object> parameters = new Dictionary<string, object>
			{
				{ "StringValue", "Pi" },
				{ "NumberValue", 3.14 }
			};
			TalkingDataSDK.OnEvent("action_id", 9.11, parameters);
		}
	}

	private void Start()
	{
		UnityEngine.Debug.Log("Start");
		TalkingDataSDK.BackgroundSessionEnabled();
		TalkingDataSDK.Init("your_app_id", "your_channel_id", "your_custom_parameter");
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Escape))
		{
			Application.Quit();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Debug.Log("onDestroy");
		TalkingDataSDK.OnPause();
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("Awake");
	}

	private void OnEnable()
	{
		UnityEngine.Debug.Log("OnEnable");
	}

	private void OnDisable()
	{
		UnityEngine.Debug.Log("OnDisable");
	}
}
public class camToCubeMapRawTexture : MonoBehaviour
{
	public Camera[] Cams;

	public GameObject camGroup;

	public GameObject CanvasObj;

	private Vector3 distantViewPosition;

	private Vector3[] faceAngles = new Vector3[6]
	{
		new Vector3(-90f, 0f, 0f),
		new Vector3(0f, 180f, 0f),
		new Vector3(90f, 0f, 0f),
		new Vector3(0f, -90f, 0f),
		new Vector3(0f, 0f, 0f),
		new Vector3(0f, 90f, 0f)
	};

	private RenderTexture cubemap;

	private bool CamOpen;

	private bool isFar = true;

	private Vector3 CamFWD;

	private Vector3 CamFWDRecord;

	private void Start()
	{
		for (int i = 0; i < faceAngles.Length; i++)
		{
			Cams[i].transform.eulerAngles = faceAngles[i];
		}
		for (int j = 0; j < faceAngles.Length; j++)
		{
			Cams[j].enabled = CamOpen;
		}
		CanvasObj.SetActive(CamOpen);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F9))
		{
			CamFWD = csPlayer.instance.camT.forward;
			CamFWD.y = 0f;
			if (CamFWD.sqrMagnitude == 0f)
			{
				CamFWD = Vector3.forward;
			}
			distantViewPosition = csPlayer.instance.camT.position;
			camGroup.transform.position = distantViewPosition;
			camGroup.transform.rotation = Quaternion.LookRotation(CamFWD, Vector3.up);
			CamFWDRecord = CamFWD;
		}
		if (Input.GetKeyDown(KeyCode.F10))
		{
			if (isFar)
			{
				camGroup.transform.position = csPlayer.instance.camT.position;
				camGroup.transform.rotation = Quaternion.identity;
				isFar = false;
			}
			else
			{
				camGroup.transform.position = distantViewPosition;
				camGroup.transform.rotation = Quaternion.LookRotation(CamFWDRecord, Vector3.up);
				isFar = true;
			}
		}
	}
}
public class OnBeheaviorEnable : MonoBehaviour
{
}
public class csBundleLoader : MonoBehaviour
{
	public string BundleName = "";

	private IEnumerator Start()
	{
		WWW www = new WWW(csAssetLoader.URLHead + BundleName + ".unity3d");
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			UnityEngine.Debug.LogError(www.bytes.Length);
			AssetBundle assetBundle = AssetBundle.LoadFromMemory(www.bytes);
			UnityEngine.Debug.LogError(www.bytes.Length);
			UnityEngine.Object.Instantiate(assetBundle.LoadAsset<GameObject>("disallaprefabs"));
		}
		else
		{
			UnityEngine.Debug.LogError(www.error);
		}
	}
}
public class csLevelTestStart : MonoBehaviour
{
	public List<ReleaseType> RTShowList = new List<ReleaseType>();

	private void Start()
	{
		if (RTShowList.Contains(csGameSettings.profile.CurrentReleaseType))
		{
			base.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class csSuperGorillaStart : MonoBehaviour
{
	private GameSongData TestData;

	private void Start()
	{
		base.gameObject.SetActive(value: false);
		TestData = GameData.instance.SongLevelData[GameData.instance.SongLevelData.FindIndex((GameSongData x) => x.ClassID == "300001")];
		UnityEngine.Debug.LogError("测试课程名：" + TestData.SongID);
		base.gameObject.GetComponent<Button>().onClick.AddListener(StartSG);
	}

	private void Update()
	{
	}

	private void StartSG()
	{
		GameManagerNew.instance.StartGame(TestData);
	}
}
public class csTestAVproPlayer : MonoBehaviour
{
	public MediaPlayer mediaPlayerL;

	public Camera camL;

	public MeshRenderer a;

	public Camera camR;

	public MeshRenderer b;

	public InputField InputMp4;

	private static readonly LazyShaderProperty PropCameraPosition = new LazyShaderProperty("_CameraPosition");

	public void OnPlayClick()
	{
		setVideoByIndex(InputMp4.text);
	}

	public void setVideoByIndex(string index)
	{
		UpdateMultiPassStereo.UseStereo = true;
		MediaHints fallbackMediaHints = mediaPlayerL.FallbackMediaHints;
		fallbackMediaHints.alphaPacking = AlphaPacking.TopBottom;
		fallbackMediaHints.transparency = TransparencyMode.Transparent;
		fallbackMediaHints.stereoPacking = StereoPacking.LeftRight;
		mediaPlayerL.CloseMedia();
		mediaPlayerL.OpenMedia(MediaPathType.RelativeToStreamingAssetsFolder, index + ".mp4", autoPlay: false);
		mediaPlayerL.FallbackMediaHints = fallbackMediaHints;
		StartCoroutine(StartPlay());
	}

	private void LateUpdate()
	{
		a.material.SetVector(PropCameraPosition.Id, camL.transform.position);
		b.material.SetVector(PropCameraPosition.Id, camR.transform.position);
	}

	private IEnumerator StartPlay()
	{
		while (mediaPlayerL.Info.HasVideo())
		{
			yield return new WaitForSeconds(0.5f);
		}
		mediaPlayerL.Play();
	}
}
public class csTestDevicesName : MonoBehaviour
{
	public Text NameText;

	private void Start()
	{
		List<UnityEngine.XR.InputDevice> list = new List<UnityEngine.XR.InputDevice>();
		InputDevices.GetDevices(list);
		for (int i = 0; i < list.Capacity; i++)
		{
			Text nameText = NameText;
			nameText.text = nameText.text + "\n " + list[i].name;
		}
		Text nameText2 = NameText;
		nameText2.text = nameText2.text + "\n " + SystemInfo.deviceName;
		NameText.text = NameText.text.Replace("\\n", "\n");
	}

	private void Update()
	{
	}
}
public class csTestEnterance : MonoBehaviour
{
	public TextMeshProUGUI TxTTitle;

	private void Start()
	{
		switch (csGameSettings.profile.CurrentReleaseType)
		{
		case ReleaseType.BetaTest:
			TxTTitle.text = "内测入口";
			break;
		case ReleaseType.DevTest:
			TxTTitle.text = "开发者测试入口";
			break;
		}
	}
}
public class csTestPitchShift : MonoBehaviour
{
	public AudioSource thisAss;

	[Header("初始音高 区间 0.5-2")]
	public float PitchValue;

	[Header("递增音高 累加极值最高为2")]
	public float PitchGap;

	[Header("音高段数")]
	public int PitchNum = 8;

	public Camera Ca;

	public LayerMask CaMask;

	private Coroutine pitchCor;

	private void Start()
	{
		Ca.cullingMask = CaMask;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			if (pitchCor != null)
			{
				StopCoroutine(pitchCor);
			}
			pitchCor = StartCoroutine(PitchPlay());
		}
	}

	private IEnumerator PitchPlay()
	{
		for (int i = 0; i < PitchNum; i++)
		{
			thisAss.outputAudioMixerGroup.audioMixer.SetFloat("Pitch", PitchValue + (float)i * PitchGap);
			thisAss.Play();
			yield return new WaitForSeconds(thisAss.clip.length + 0.1f);
		}
	}
}
public class csTestStreamVideo : MonoBehaviour
{
	public csMediaPlayerMan mplayer;

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(2f);
		mplayer.screen.SetActive(value: true);
		mplayer.screen.GetComponent<MeshRenderer>().enabled = true;
		mplayer.TestPlayStreamingVideoByUrl("http://olympia-video-cn.picovr.com/90855ecede9f4479ab4abc35aeeb2b3a?auth_key=1671175143-fd097ef8f42147f095c83a9593db3beb-0-75994528537126fe87dd3876fbc7b5b4");
	}

	private void Update()
	{
		if (csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Down, IsLeft: true) || Input.GetMouseButtonDown(0))
		{
			mplayer.screen.SetActive(value: true);
			mplayer.screen.GetComponent<MeshRenderer>().enabled = true;
			mplayer.TestPlayStreamingVideoByUrl("http://olympia-video-cn.picovr.com/7886c1de94ab4a71bc40fca842c2d2a3?auth_key=1671715872-2a0f2556a2c740608f5ee3a260147596-0-2af6dfc9da2659c6499997c506e1eb1e");
		}
		if (csXRInput.Instance.TryGetButtonValue(ButtonType.TriggerButton, PressState.Down, IsLeft: false) || Input.GetMouseButtonDown(1))
		{
			mplayer.screen.SetActive(value: true);
			mplayer.screen.GetComponent<MeshRenderer>().enabled = true;
			mplayer.TestPlayStreamingVideoByUrl("http://olympia-video-cn.picovr.com/90855ecede9f4479ab4abc35aeeb2b3a?auth_key=1671175143-fd097ef8f42147f095c83a9593db3beb-0-75994528537126fe87dd3876fbc7b5b4");
		}
		if (csXRInput.Instance.TryGetButtonValue(ButtonType.primaryButton, PressState.Down, IsLeft: false) || Input.GetMouseButtonDown(1))
		{
			Application.Quit();
		}
	}
}
public class TestSceneLoad : MonoBehaviour
{
	public string LastTimeStr;

	public string NowTimeStr;

	public DateTime LastWeekTime;

	public DateTime NowTime;

	private void StartDate()
	{
		LastWeekTime = DateTime.Parse(LastTimeStr, new CultureInfo("zh-cn"));
		NowTime = DateTime.Parse(NowTimeStr, new CultureInfo("zh-cn"));
		int num = (int)(LastWeekTime.DayOfWeek + 1);
		if (num > 6)
		{
			num = 0;
		}
		int num2 = (int)(NowTime.DayOfWeek + 1);
		if (num2 > 6)
		{
			num2 = 0;
		}
		LastWeekTime = LastWeekTime.AddDays(-num);
		NowTime = NowTime.AddDays(-num2);
		UnityEngine.Debug.LogError("LastWeekTime.Day:" + LastWeekTime.Day);
		UnityEngine.Debug.LogError("NowTime.Day:" + NowTime.Day);
		if (LastWeekTime.Day != NowTime.Day)
		{
			UnityEngine.Debug.LogError("New Week");
		}
		else
		{
			UnityEngine.Debug.LogError("Same Week");
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.S))
		{
			StartDate();
		}
	}
}
public class MediaPlay : MonoBehaviour
{
	public VideoPlayer target;

	public float BianNum;

	public float MoveNum;

	public float frameNum;

	public float FrameNN;

	private float hhH;

	private void Start()
	{
		hhH = base.transform.localPosition.x;
	}

	private void Update()
	{
		frameNum = target.frame;
		if (Input.GetKeyDown(KeyCode.Space))
		{
			target.Play();
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			target.frame--;
		}
		if (Input.GetKeyDown(KeyCode.W))
		{
			target.frame -= 5L;
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			target.Pause();
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			target.frame++;
		}
		FrameNN = target.frame;
		BianBianBian(FrameNN, 5, 5);
	}

	private void BianBianBian(float FrameN, int LeftN, int RightN)
	{
		if (FrameN == 1f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 44f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 136f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 228f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 321f)
		{
			LeftN = 6;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 342f)
		{
			LeftN = 6;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 350f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 432f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 451f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 466f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 487f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 509f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 523f)
		{
			LeftN = 6;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 524f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 530f)
		{
			LeftN = 6;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 546f)
		{
			LeftN = 5;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 556f)
		{
			LeftN = 5;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 562f)
		{
			LeftN = 4;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 568f)
		{
			LeftN = 4;
			RightN = 6;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 574f)
		{
			LeftN = 3;
			RightN = 6;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 578f)
		{
			LeftN = 2;
			RightN = 6;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 582f)
		{
			LeftN = 1;
			RightN = 6;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 587f)
		{
			LeftN = 1;
			RightN = 5;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 593f)
		{
			LeftN = 1;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 601f)
		{
			LeftN = 2;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 607f)
		{
			LeftN = 3;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
		}
		if (FrameN == 626f)
		{
			LeftN = 4;
			RightN = 4;
			base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f);
			MoveYes(LeftN, RightN);
			target.Stop();
			target.Play();
			UnityEngine.Debug.Log("yes replay");
		}
		UnityEngine.Debug.Log("wefweffffffffffffff" + base.transform.localScale.x);
	}

	private void MoveYes(int leftN, int rightN)
	{
		base.transform.localPosition = new Vector3(hhH + (float)(leftN - rightN) * MoveNum, base.transform.localPosition.y, base.transform.localPosition.z);
	}
}
public class RbMoveYou : MonoBehaviour
{
	public Transform target;

	public float forceSpeed;

	public Rigidbody selfRb;

	private Vector3 moveDir;

	private void Start()
	{
	}

	private void Update()
	{
		moveDir = target.position - base.transform.position;
	}

	private void FixedUpdate()
	{
		selfRb.AddForce(moveDir * forceSpeed);
	}
}
public class SNTest : MonoBehaviour
{
	public VideoPlayer vp;

	public float BianNum;

	public float MoveNum;

	public float frameNum;

	public float FrameNN;

	private float hhH;

	public float screenWidth = 10f;

	private List<int> tmpList = new List<int>();

	private void Start()
	{
		StartCoroutine(getVideoInfo());
	}

	private bool ColorGap(Color32 _color, Color JugdeColor)
	{
		Color32 color = JugdeColor;
		Color.RGBToHSV(_color, out var H, out var S, out var V);
		Color.RGBToHSV(color, out var H2, out var S2, out var V2);
		UnityEngine.Debug.LogError(H2 + "   " + H);
		float f = Mathf.Abs(H2 * 360f - H * 360f);
		float f2 = Mathf.Abs(S2 * 255f - S * 255f);
		float f3 = Mathf.Abs(V2 * 255f - V * 255f);
		f = Mathf.Floor(f);
		f2 = Mathf.Floor(f2);
		f3 = Mathf.Floor(f3);
		UnityEngine.Debug.LogError(f.ToString());
		UnityEngine.Debug.LogError(f2.ToString());
		UnityEngine.Debug.LogError(f3.ToString());
		if (f <= 100f && f2 <= 100f && f3 < 100f)
		{
			return true;
		}
		return false;
	}

	private void bianbianbain(int LeftN, int RightN)
	{
		base.transform.localScale = new Vector3(1f - (float)(LeftN + RightN - 2) * BianNum, 1f, 1f) / 10f * screenWidth;
		MoveYes(LeftN, RightN);
	}

	private void MoveYes(int leftN, int rightN)
	{
		base.transform.localPosition = new Vector3(hhH + (float)(leftN - rightN) * MoveNum, base.transform.localPosition.y, base.transform.localPosition.z);
	}

	public bool Difference(Color c1, Color c2)
	{
		c1 *= 255f;
		c2 *= 255f;
		float num = (c1.r + c2.r) * 0.5f;
		return Mathf.Sqrt((2f + num / 255f) * Mathf.Pow(c1.r - c2.r, 2f) + 4f * Mathf.Pow(c1.g - c2.g, 2f) + (2f + (255f - num) / 255f) * Mathf.Pow(c1.b - c2.b, 2f)) / 765f < 0.55f;
	}

	private Color GetColor(VideoPlayer vp, int posY, int posX = 0)
	{
		Color pixel = TextureToTexture2D(vp.texture).GetPixel(32 * (posX - 1), 32 * (posY - 1) + 16);
		GC.Collect();
		return pixel;
	}

	private Texture2D TextureToTexture2D(Texture texture)
	{
		Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, mipChain: false);
		RenderTexture active = RenderTexture.active;
		RenderTexture temporary = RenderTexture.GetTemporary(texture.width, texture.height, 32);
		Graphics.Blit(texture, temporary);
		RenderTexture.active = temporary;
		texture2D.ReadPixels(new Rect(0f, 0f, temporary.width, temporary.height), 0, 0);
		texture2D.Apply();
		RenderTexture.active = active;
		RenderTexture.ReleaseTemporary(temporary);
		active = null;
		return texture2D;
	}

	private int checkLine1Level(List<int> colors)
	{
		if (colors[0] == 3)
		{
			return 6;
		}
		if (colors[0] == 2)
		{
			return 5;
		}
		if (colors[0] == 1)
		{
			if (colors[1] == 1)
			{
				if (colors[2] == 1)
				{
					return 4;
				}
				return 3;
			}
			return 2;
		}
		return 1;
	}

	private int checkLine2Level(List<int> colors)
	{
		if (colors[0] == 2)
		{
			if (colors[3] == 2)
			{
				return 1;
			}
			return 5;
		}
		if (colors[1] == 2)
		{
			return 4;
		}
		return colors[2] switch
		{
			0 => 7, 
			1 => 6, 
			2 => 3, 
			3 => 2, 
			_ => 1, 
		};
	}

	private IEnumerator getVideoInfo()
	{
		yield return new WaitForSeconds(0.5f);
		vp.Play();
		vp.Pause();
		vp.frame = 0L;
		long allFrameNum = (long)vp.frameCount;
		List<frameInfo> frames = new List<frameInfo>();
		while (vp.frame < allFrameNum)
		{
			addVideoInfo(frames, (int)vp.frame);
			yield return new WaitForSeconds(0.5f);
			vp.frame++;
		}
		string text = JsonUtility.ToJson(frames);
		createTxtText(text, vp.clip.name);
	}

	public void createTxtText(string text, string videoName)
	{
		FileStream fileStream = new FileStream(Application.dataPath + "/Chesstar/VideoData/" + videoName + ".txt", FileMode.Create);
		byte[] bytes = Encoding.UTF8.GetBytes(text);
		fileStream.Write(bytes, 0, bytes.Length);
		if (fileStream != null)
		{
			fileStream.Flush();
			fileStream.Close();
			fileStream.Dispose();
		}
	}

	public string getTextData(string fileName)
	{
		return File.ReadAllText(Application.dataPath + "/Chesstar/VideoData/" + fileName + ".txt");
	}

	private void addVideoInfo(List<frameInfo> list, int frame)
	{
		tmpList.Clear();
		for (int i = 1; i <= 4; i++)
		{
			tmpList.Add(getColorNum(GetColor(vp, 4, i)));
		}
		int num = checkLine1Level(tmpList);
		tmpList.Clear();
		for (int j = 1; j <= 4; j++)
		{
			tmpList.Add(getColorNum(GetColor(vp, 2, j)));
		}
		int num2 = checkLine2Level(tmpList);
		if (list.Count != 0 && !sameInfo(list[list.Count - 1], num, num2))
		{
			list.Add(new frameInfo(frame, num, num2));
		}
	}

	private bool sameInfo(frameInfo target, int leftLevel, int RightLevel)
	{
		if (target.leftLevel == leftLevel)
		{
			return target.rightLevel == RightLevel;
		}
		return false;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.P))
		{
			if (vp.isPlaying)
			{
				vp.Pause();
			}
			else
			{
				vp.Play();
			}
		}
		if (Input.GetKeyDown(KeyCode.Q))
		{
			UnityEngine.Debug.LogError(vp.texture.width);
		}
	}

	private int getColorNum(Color target)
	{
		if (Difference(target, Color.green))
		{
			return 1;
		}
		if (Difference(target, Color.red))
		{
			return 2;
		}
		if (Difference(target, Color.yellow))
		{
			return 3;
		}
		return 0;
	}

	private void test()
	{
		if (vp.isPlaying)
		{
			tmpList.Clear();
			for (int i = 1; i <= 4; i++)
			{
				tmpList.Add(getColorNum(GetColor(vp, 4, i)));
			}
			int leftN = checkLine1Level(tmpList);
			tmpList.Clear();
			for (int j = 1; j <= 4; j++)
			{
				tmpList.Add(getColorNum(GetColor(vp, 2, j)));
			}
			int rightN = checkLine2Level(tmpList);
			bianbianbain(leftN, rightN);
		}
	}
}
public class frameInfo
{
	public int currentNum;

	public int leftLevel;

	public int rightLevel;

	public frameInfo(int num, int left, int right)
	{
		currentNum = num;
		leftLevel = left;
		rightLevel = right;
	}
}
namespace SoftMasking.Samples
{
	[RequireComponent(typeof(RectTransform))]
	public class Draggable : UIBehaviour, IDragHandler, IEventSystemHandler
	{
		private RectTransform _rectTransform;

		protected override void Awake()
		{
			base.Awake();
			_rectTransform = GetComponent<RectTransform>();
		}

		public void OnDrag(PointerEventData eventData)
		{
			_rectTransform.anchoredPosition += eventData.delta;
		}
	}
	[RequireComponent(typeof(Camera))]
	public class HorizontalFovSetter : MonoBehaviour
	{
		public float horizontalFov;

		private Camera _camera;

		public void Awake()
		{
			_camera = GetComponent<Camera>();
		}

		public void Update()
		{
			_camera.fieldOfView = horizontalFov / _camera.aspect;
		}
	}
	public class Item : MonoBehaviour
	{
		public Image image;

		public Text title;

		public Text description;

		public RectTransform healthBar;

		public RectTransform damageBar;

		public void Set(string name, Sprite sprite, Color color, float health, float damage)
		{
			if ((bool)image)
			{
				image.sprite = sprite;
				image.color = color;
			}
			if ((bool)title)
			{
				title.text = name;
			}
			if ((bool)description)
			{
				description.text = "The short description of " + name;
			}
			if ((bool)healthBar)
			{
				healthBar.anchorMax = new Vector2(health, 1f);
			}
			if ((bool)damageBar)
			{
				damageBar.anchorMax = new Vector2(damage, 1f);
			}
		}
	}
	public class ItemsGenerator : MonoBehaviour
	{
		public RectTransform target;

		public Sprite image;

		public int count;

		public string baseName;

		public Item itemPrefab;

		private static readonly Color[] colors = new Color[7]
		{
			Color.red,
			Color.green,
			Color.blue,
			Color.cyan,
			Color.yellow,
			Color.magenta,
			Color.gray
		};

		public void Generate()
		{
			DestroyChildren();
			int num = UnityEngine.Random.Range(0, colors.Length - 1);
			for (int i = 0; i < count; i++)
			{
				Item item = UnityEngine.Object.Instantiate(itemPrefab);
				item.transform.SetParent(target, worldPositionStays: false);
				item.Set($"{baseName} {i + 1:D2}", image, colors[(num + i) % colors.Length], UnityEngine.Random.Range(0.4f, 1f), UnityEngine.Random.Range(0.4f, 1f));
			}
		}

		private void DestroyChildren()
		{
			while (target.childCount > 0)
			{
				UnityEngine.Object.DestroyImmediate(target.GetChild(0).gameObject);
			}
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class MaskPainter : UIBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler
	{
		public Graphic spot;

		public RectTransform stroke;

		private RectTransform _rectTransform;

		protected override void Awake()
		{
			base.Awake();
			_rectTransform = GetComponent<RectTransform>();
		}

		protected override void Start()
		{
			base.Start();
			spot.enabled = false;
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			UpdateStrokeByEvent(eventData);
		}

		public void OnDrag(PointerEventData eventData)
		{
			UpdateStrokeByEvent(eventData, drawTrail: true);
		}

		private void UpdateStrokeByEvent(PointerEventData eventData, bool drawTrail = false)
		{
			UpdateStrokePosition(eventData.position, drawTrail);
			UpdateStrokeColor(eventData.button);
		}

		private void UpdateStrokePosition(Vector2 screenPosition, bool drawTrail = false)
		{
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(_rectTransform, screenPosition, null, out var localPoint))
			{
				Vector2 anchoredPosition = stroke.anchoredPosition;
				stroke.anchoredPosition = localPoint;
				if (drawTrail)
				{
					SetUpTrail(anchoredPosition);
				}
				spot.enabled = true;
			}
		}

		private void SetUpTrail(Vector2 prevPosition)
		{
			Vector2 vector = stroke.anchoredPosition - prevPosition;
			stroke.localRotation = Quaternion.AngleAxis(Mathf.Atan2(vector.y, vector.x) * 57.29578f, Vector3.forward);
			spot.rectTransform.offsetMin = new Vector2(0f - vector.magnitude, 0f);
		}

		private void UpdateStrokeColor(PointerEventData.InputButton pressedButton)
		{
			spot.materialForRendering.SetInt("_BlendOp", (pressedButton != 0) ? 2 : 0);
		}
	}
	public class Minimap : MonoBehaviour
	{
		public RectTransform map;

		public RectTransform marker;

		[Space]
		public float minZoom = 0.8f;

		public float maxZoom = 1.4f;

		public float zoomStep = 0.2f;

		private float _zoom = 1f;

		public void LateUpdate()
		{
			map.anchoredPosition = -marker.anchoredPosition * _zoom;
		}

		public void ZoomIn()
		{
			_zoom = Clamp(_zoom + zoomStep);
			map.localScale = Vector3.one * _zoom;
		}

		public void ZoomOut()
		{
			_zoom = Clamp(_zoom - zoomStep);
			map.localScale = Vector3.one * _zoom;
		}

		private float Clamp(float zoom)
		{
			return Mathf.Clamp(zoom, minZoom, maxZoom);
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class PaintedMask : UIBehaviour
	{
		public Camera renderCamera;

		public SoftMask targetMask;

		private RenderTexture _renderTexture;

		private Vector2 maskSize => ((RectTransform)targetMask.transform).rect.size;

		protected override void Start()
		{
			base.Start();
			_renderTexture = new RenderTexture((int)maskSize.x, (int)maskSize.y, 0, RenderTextureFormat.ARGB32);
			_renderTexture.Create();
			renderCamera.targetTexture = _renderTexture;
			targetMask.renderTexture = _renderTexture;
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class RectManipulator : UIBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IEndDragHandler
	{
		[Flags]
		public enum ManipulationType
		{
			None = 0,
			Move = 1,
			ResizeLeft = 2,
			ResizeUp = 4,
			ResizeRight = 8,
			ResizeDown = 0x10,
			ResizeUpLeft = 6,
			ResizeUpRight = 0xC,
			ResizeDownLeft = 0x12,
			ResizeDownRight = 0x18,
			Rotate = 0x20
		}

		public RectTransform targetTransform;

		public ManipulationType manipulation;

		public ShowOnHover showOnHover;

		[Header("Limits")]
		public Vector2 minSize;

		[Header("Display")]
		public Graphic icon;

		public float normalAlpha = 0.2f;

		public float selectedAlpha = 1f;

		public float transitionDuration = 0.2f;

		private bool _isManipulatedNow;

		private Vector2 _startAnchoredPosition;

		private Vector2 _startSizeDelta;

		private float _startRotation;

		private RectTransform parentTransform => targetTransform.parent as RectTransform;

		public void OnPointerEnter(PointerEventData eventData)
		{
			HighlightIcon(highlight: true);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (!_isManipulatedNow)
			{
				HighlightIcon(highlight: false);
			}
		}

		private void HighlightIcon(bool highlight, bool instant = false)
		{
			if ((bool)icon)
			{
				float alpha = (highlight ? selectedAlpha : normalAlpha);
				float duration = (instant ? 0f : transitionDuration);
				icon.CrossFadeAlpha(alpha, duration, ignoreTimeScale: true);
			}
			if ((bool)showOnHover)
			{
				showOnHover.forcedVisible = highlight;
			}
		}

		protected override void Start()
		{
			base.Start();
			HighlightIcon(highlight: false, instant: true);
		}

		public void OnBeginDrag(PointerEventData eventData)
		{
			_isManipulatedNow = true;
			RememberStartTransform();
		}

		private void RememberStartTransform()
		{
			if ((bool)targetTransform)
			{
				_startAnchoredPosition = targetTransform.anchoredPosition;
				_startSizeDelta = targetTransform.sizeDelta;
				_startRotation = targetTransform.localRotation.eulerAngles.z;
			}
		}

		public void OnDrag(PointerEventData eventData)
		{
			if (!(targetTransform == null) && !(parentTransform == null) && _isManipulatedNow)
			{
				Vector2 vector = ToParentSpace(eventData.pressPosition, eventData.pressEventCamera);
				Vector2 vector2 = ToParentSpace(eventData.position, eventData.pressEventCamera);
				DoRotate(vector, vector2);
				Vector2 parentSpaceMovement = vector2 - vector;
				DoMove(parentSpaceMovement);
				DoResize(parentSpaceMovement);
			}
		}

		private Vector2 ToParentSpace(Vector2 position, Camera eventCamera)
		{
			RectTransformUtility.ScreenPointToLocalPointInRectangle(parentTransform, position, eventCamera, out var localPoint);
			return localPoint;
		}

		private void DoMove(Vector2 parentSpaceMovement)
		{
			if (Is(ManipulationType.Move))
			{
				MoveTo(_startAnchoredPosition + parentSpaceMovement);
			}
		}

		private bool Is(ManipulationType expected)
		{
			return (manipulation & expected) == expected;
		}

		private void MoveTo(Vector2 desiredAnchoredPosition)
		{
			targetTransform.anchoredPosition = ClampPosition(desiredAnchoredPosition);
		}

		private Vector2 ClampPosition(Vector2 position)
		{
			Vector2 vector = parentTransform.rect.size / 2f;
			return new Vector2(Mathf.Clamp(position.x, 0f - vector.x, vector.x), Mathf.Clamp(position.y, 0f - vector.y, vector.y));
		}

		private void DoRotate(Vector2 startParentPoint, Vector2 targetParentPoint)
		{
			if (Is(ManipulationType.Rotate))
			{
				Vector2 startLever = startParentPoint - (Vector2)targetTransform.localPosition;
				Vector2 endLever = targetParentPoint - (Vector2)targetTransform.localPosition;
				float num = DeltaRotation(startLever, endLever);
				targetTransform.localRotation = Quaternion.AngleAxis(_startRotation + num, Vector3.forward);
			}
		}

		private float DeltaRotation(Vector2 startLever, Vector2 endLever)
		{
			float current = Mathf.Atan2(startLever.y, startLever.x) * 57.29578f;
			float target = Mathf.Atan2(endLever.y, endLever.x) * 57.29578f;
			return Mathf.DeltaAngle(current, target);
		}

		private void DoResize(Vector2 parentSpaceMovement)
		{
			Vector3 vector = Quaternion.Inverse(targetTransform.rotation) * parentSpaceMovement;
			Vector2 localOffset = ProjectResizeOffset(vector);
			if (localOffset.sqrMagnitude > 0f)
			{
				SetSizeDirected(localOffset, ResizeSign());
			}
		}

		private Vector2 ProjectResizeOffset(Vector2 localOffset)
		{
			bool num = Is(ManipulationType.ResizeLeft) || Is(ManipulationType.ResizeRight);
			return new Vector2(y: (Is(ManipulationType.ResizeUp) || Is(ManipulationType.ResizeDown)) ? localOffset.y : 0f, x: num ? localOffset.x : 0f);
		}

		private Vector2 ResizeSign()
		{
			return new Vector2(Is(ManipulationType.ResizeLeft) ? (-1f) : 1f, Is(ManipulationType.ResizeDown) ? (-1f) : 1f);
		}

		private void SetSizeDirected(Vector2 localOffset, Vector2 sizeSign)
		{
			Vector2 vector = ClampSize(_startSizeDelta + Vector2.Scale(localOffset, sizeSign));
			targetTransform.sizeDelta = vector;
			Vector2 vector2 = Vector2.Scale((vector - _startSizeDelta) / 2f, sizeSign);
			MoveTo(_startAnchoredPosition + (Vector2)targetTransform.TransformVector(vector2));
		}

		private Vector2 ClampSize(Vector2 size)
		{
			return new Vector2(Mathf.Max(size.x, minSize.x), Mathf.Max(size.y, minSize.y));
		}

		public void OnEndDrag(PointerEventData eventData)
		{
			_isManipulatedNow = false;
			if (!eventData.hovered.Contains(base.gameObject))
			{
				HighlightIcon(highlight: false);
			}
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class ShowOnHover : UIBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public CanvasGroup targetGroup;

		private bool _forcedVisible;

		private bool _isPointerOver;

		public bool forcedVisible
		{
			get
			{
				return _forcedVisible;
			}
			set
			{
				if (_forcedVisible != value)
				{
					_forcedVisible = value;
					UpdateVisibility();
				}
			}
		}

		protected override void Start()
		{
			base.Start();
			UpdateVisibility();
		}

		private void UpdateVisibility()
		{
			SetVisible(ShouldBeVisible());
		}

		private bool ShouldBeVisible()
		{
			if (!_forcedVisible)
			{
				return _isPointerOver;
			}
			return true;
		}

		private void SetVisible(bool visible)
		{
			if ((bool)targetGroup)
			{
				targetGroup.alpha = (visible ? 1f : 0f);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			_isPointerOver = true;
			UpdateVisibility();
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			_isPointerOver = false;
			UpdateVisibility();
		}
	}
	public class SoftMaskSampleChooser : MonoBehaviour
	{
		public Dropdown dropdown;

		public Text fallbackLabel;

		public void Start()
		{
			string activeSceneName = SceneManager.GetActiveScene().name;
			int num = dropdown.options.FindIndex((Dropdown.OptionData x) => x.text == activeSceneName);
			if (num >= 0)
			{
				dropdown.value = num;
				dropdown.onValueChanged.AddListener(Choose);
			}
			else
			{
				Fallback(activeSceneName);
			}
		}

		private void Fallback(string activeSceneName)
		{
			dropdown.gameObject.SetActive(value: false);
			fallbackLabel.gameObject.SetActive(value: true);
			fallbackLabel.text = activeSceneName;
		}

		public void Choose(int sampleIndex)
		{
			SceneManager.LoadScene(dropdown.options[sampleIndex].text);
		}
	}
	public class SoftMaskToggler : MonoBehaviour
	{
		public GameObject mask;

		public bool doNotTouchImage;

		public void Toggle(bool enabled)
		{
			if ((bool)mask)
			{
				mask.GetComponent<SoftMask>().enabled = enabled;
				mask.GetComponent<Mask>().enabled = !enabled;
				if (!doNotTouchImage)
				{
					mask.GetComponent<Image>().enabled = !enabled;
				}
			}
		}
	}
	public class Tooltip : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public RectTransform tooltip;

		public void LateUpdate()
		{
			if (tooltip.gameObject.activeInHierarchy && RectTransformUtility.ScreenPointToLocalPointInRectangle(tooltip.parent.GetComponent<RectTransform>(), Input.mousePosition, null, out var localPoint))
			{
				tooltip.anchoredPosition = localPoint + new Vector2(10f, -20f);
			}
		}

		void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
		{
			tooltip.gameObject.SetActive(value: true);
		}

		void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
		{
			tooltip.gameObject.SetActive(value: false);
		}
	}
}
namespace Pico.Avatar
{
	public class AvatarAnimationBlendTree : NativeObject
	{
		public AnimBlendTreeType blendType = AnimBlendTreeType.Invalid;

		private const string PavDLLName = "effect";

		public AvatarAnimationState owner { get; set; }

		public AvatarAnimationBlendTree(IntPtr nativeHandle_)
		{
			SetNativeHandle(nativeHandle_, needRetain: false);
		}

		public void AddAnimationClip(string animationName)
		{
			pav_AvatarAnimationBlendTree_AddAnimazClip(base.nativeHandle, animationName);
		}

		public void AddParameterString(string param)
		{
			pav_AvatarAnimationBlendTree_AddParameterStr(base.nativeHandle, param);
		}

		public void AddParameterID(uint param)
		{
			pav_AvatarAnimationBlendTree_AddParameterID(base.nativeHandle, param);
		}

		public void SetThreshold1D(uint index, float threshold)
		{
			if (blendType == AnimBlendTreeType.BlendTree1D)
			{
				pav_AvatarAnimationBlendTree1D_SetThreshold(base.nativeHandle, index, threshold);
			}
		}

		public void SetThreshold2D(uint index, float thresholdX, float thresholdY)
		{
			if (blendType == AnimBlendTreeType.BlendTree2D)
			{
				pav_AvatarAnimationBlendTree2D_SetThreshold(base.nativeHandle, index, thresholdX, thresholdY);
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationBlendTree_AddAnimazClip(IntPtr nativeHandle, string animationName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationBlendTree_AddParameterStr(IntPtr nativeHandle, string paramStr);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationBlendTree_AddParameterID(IntPtr nativeHandle, uint paramID);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationBlendTree1D_SetThreshold(IntPtr nativeHandle, uint index, float threshold);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationBlendTree2D_SetThreshold(IntPtr nativeHandle, uint index, float thresholdX, float thresholdY);
	}
	public class AvatarAnimationLayer : NativeObject
	{
		public AnimLayerType layerType;

		public AvatarMask avatarMask;

		private string _name = "";

		private Dictionary<string, AvatarAnimationState> _animationStatesMap = new Dictionary<string, AvatarAnimationState>();

		private const string PavDLLName = "effect";

		public string name
		{
			get
			{
				if (_name == "")
				{
					StringBuilder stringBuilder = new StringBuilder("", 50);
					pav_AvatarAnimationLayer_GetName(base.nativeHandle, stringBuilder);
					_name = stringBuilder.ToString();
				}
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public uint id { get; set; }

		public AvatarBodyAnimController owner { get; set; }

		public AvatarAnimationLayer(IntPtr nativeHandle_)
		{
			SetNativeHandle(nativeHandle_, needRetain: false);
			InitNativeAnimationStates();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarAnimationLayer);
			}
		}

		public AvatarMask SetAvatarMask(AvatarMask avatarMask)
		{
			avatarMask.owner = this;
			pav_AvatarAnimationLayer_SetAvatarMask(base.nativeHandle, avatarMask.nativeHandle);
			return avatarMask;
		}

		public void SetLayerBlendMode(AnimLayerBlendMode blendMode)
		{
			pav_AvatarAnimationLayer_SetLayerBlendMode(base.nativeHandle, (uint)blendMode);
		}

		public void SetLayerBlendWeight(float blendWeight)
		{
			pav_AvatarAnimationLayer_SetLayerBlendWeight(base.nativeHandle, blendWeight);
		}

		public void SetSRTEnable(bool enableScale, bool enableRotation, bool enablePosition)
		{
			pav_AvatarAnimationLayer_SetSRTEnable(base.nativeHandle, enableScale, enableRotation, enablePosition);
		}

		public void PlayAnimationClip(string animationName, float loopTime, float speed, float fadeTime)
		{
			pav_AvatarAnimationLayer_PlayAnimationClipByName(base.nativeHandle, animationName, loopTime, speed, fadeTime);
		}

		public void StopAnimation(float fadeTime)
		{
			pav_AvatarAnimationLayer_StopAnimation(base.nativeHandle, fadeTime);
		}

		public void PlayAnimationState(AvatarAnimationState animationState, float fadeTime)
		{
			pav_AvatarAnimationLayer_PlayAnimationState(base.nativeHandle, animationState.nativeHandle, fadeTime);
		}

		public AvatarAnimationState CreateAnimationStateByName(string stateName)
		{
			IntPtr intPtr = pav_AvatarAnimationLayer_CreateAnimationStateByName(base.nativeHandle, stateName);
			if (intPtr != IntPtr.Zero)
			{
				AvatarAnimationState avatarAnimationState = new AvatarAnimationState(intPtr);
				avatarAnimationState.Retain();
				_animationStatesMap[avatarAnimationState.name] = avatarAnimationState;
				return avatarAnimationState;
			}
			return null;
		}

		public AvatarAnimationState GetAnimationStateByName(string stateName)
		{
			if (_animationStatesMap.ContainsKey(stateName))
			{
				return _animationStatesMap[stateName];
			}
			return null;
		}

		protected override void OnDestroy()
		{
			foreach (KeyValuePair<string, AvatarAnimationState> item in _animationStatesMap)
			{
				item.Value.Release();
			}
			_animationStatesMap.Clear();
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarAnimationLayer);
			}
		}

		private void InitNativeAnimationStates()
		{
			uint num = pav_AvatarAnimationLayer_GetAnimationStatesCount(base.nativeHandle);
			IntPtr[] array = new IntPtr[num];
			GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
			pav_AvatarAnimationLayer_GetAnimationStates(base.nativeHandle, num, gCHandle.AddrOfPinnedObject());
			for (uint num2 = 0u; num2 < num; num2++)
			{
				AvatarAnimationState avatarAnimationState = new AvatarAnimationState(array[num2]);
				avatarAnimationState.Retain();
				_animationStatesMap[avatarAnimationState.name] = avatarAnimationState;
			}
			gCHandle.Free();
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_SetLayerBlendMode(IntPtr nativeHandle, uint blendMode);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_SetLayerBlendWeight(IntPtr nativeHandle, float blendWeight);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_PlayAnimationClipByName(IntPtr nativeHandle, string animationName, float loopTime, float speed, float fadeTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_StopAnimation(IntPtr nativeHandle, float fadeTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_SetSRTEnable(IntPtr nativeHandle, bool enableScale, bool enableRotation, bool enablePosition);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_SetAvatarMask(IntPtr nativeHandle, IntPtr nativeHandleAvatarMask);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_GetName(IntPtr nativeHandle, StringBuilder stateName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarAnimationLayer_GetAnimationStatesCount(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_GetAnimationStates(IntPtr nativeHandle, uint stateCount, IntPtr nativeHandleStates);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarAnimationLayer_CreateAnimationStateByName(IntPtr nativeHandle, string stateName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationLayer_PlayAnimationState(IntPtr nativeHandle, IntPtr nativeHandleAnimationState, float fadeTime);
	}
	public enum AnimStateStatus
	{
		StateIdle,
		StateEnter,
		StateRunning,
		StateEnd,
		StateLeave
	}
	public class AvatarAnimationState : NativeObject
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void StateStatusCallback(uint stateStatus, IntPtr nativeHandle);

		public AnimStateStatus status;

		private string _name = "";

		private bool _callBackInitiated;

		private AvatarAnimationBlendTree _blendTree;

		private static Dictionary<IntPtr, List<Action<AvatarAnimationState>>> _stateEnterCallbacks = new Dictionary<IntPtr, List<Action<AvatarAnimationState>>>();

		private static Dictionary<IntPtr, List<Action<AvatarAnimationState>>> _stateEndCallbacks = new Dictionary<IntPtr, List<Action<AvatarAnimationState>>>();

		private static Dictionary<IntPtr, List<Action<AvatarAnimationState>>> _stateLeaveCallbacks = new Dictionary<IntPtr, List<Action<AvatarAnimationState>>>();

		private static Dictionary<IntPtr, AvatarAnimationState> _nativeHandleMap = new Dictionary<IntPtr, AvatarAnimationState>();

		private const string PavDLLName = "effect";

		public string name
		{
			get
			{
				if (_name == "")
				{
					StringBuilder stringBuilder = new StringBuilder("", 50);
					pav_AvatarAnimationState_GetName(base.nativeHandle, stringBuilder);
					_name = stringBuilder.ToString();
				}
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public AvatarBodyAnimController owner { get; set; }

		public AvatarAnimationBlendTree blendTree => _blendTree;

		public AvatarAnimationState(IntPtr nativeHandle_)
		{
			SetNativeHandle(nativeHandle_, needRetain: false);
			_nativeHandleMap.Add(nativeHandle_, this);
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarAnimationState);
			}
		}

		public void SetSpeed(float speed)
		{
			pav_AvatarAnimationState_SetSpeed(base.nativeHandle, speed);
		}

		public void SetWrapMode(float wrapMode)
		{
			pav_AvatarAnimationState_SetWrapMode(base.nativeHandle, wrapMode);
		}

		public void SetStartTime(float startTime)
		{
			pav_AvatarAnimationState_SetStartTime(base.nativeHandle, startTime);
		}

		public void AddAnimationClip(string animationName)
		{
			pav_AvatarAnimationState_AddAnimazClip(base.nativeHandle, animationName);
		}

		public void CreateBlendTree(AnimBlendTreeType blendTreeType)
		{
			if (blendTree != null)
			{
				blendTree.Release();
			}
			_blendTree = null;
			IntPtr intPtr = pav_AvatarAnimationState_CreateBlendTree(base.nativeHandle, (uint)blendTreeType);
			if (intPtr != IntPtr.Zero)
			{
				_blendTree = new AvatarAnimationBlendTree(intPtr);
				_blendTree.Retain();
				_blendTree.owner = this;
				_blendTree.blendType = blendTreeType;
			}
		}

		public void AddStateStatusCallBack(AnimStateStatus stateStatus, Action<AvatarAnimationState> stateCallBack)
		{
			if (!_callBackInitiated && pav_AvatarAnimationState_SetAnimationStateCallBack(base.nativeHandle, OnStateStatusCallback) == NativeResult.Success)
			{
				_callBackInitiated = true;
			}
			switch (stateStatus)
			{
			case AnimStateStatus.StateEnter:
				if (!_stateEnterCallbacks.ContainsKey(base.nativeHandle))
				{
					_stateEnterCallbacks.Add(base.nativeHandle, new List<Action<AvatarAnimationState>>());
				}
				_stateEnterCallbacks[base.nativeHandle].Add(stateCallBack);
				break;
			case AnimStateStatus.StateEnd:
				if (!_stateEndCallbacks.ContainsKey(base.nativeHandle))
				{
					_stateEndCallbacks.Add(base.nativeHandle, new List<Action<AvatarAnimationState>>());
				}
				_stateEndCallbacks[base.nativeHandle].Add(stateCallBack);
				break;
			case AnimStateStatus.StateLeave:
				if (!_stateLeaveCallbacks.ContainsKey(base.nativeHandle))
				{
					_stateLeaveCallbacks.Add(base.nativeHandle, new List<Action<AvatarAnimationState>>());
				}
				_stateLeaveCallbacks[base.nativeHandle].Add(stateCallBack);
				break;
			case AnimStateStatus.StateRunning:
				break;
			}
		}

		protected override void OnDestroy()
		{
			_stateEnterCallbacks.Remove(base.nativeHandle);
			_stateEndCallbacks.Remove(base.nativeHandle);
			_stateLeaveCallbacks.Remove(base.nativeHandle);
			_nativeHandleMap.Remove(base.nativeHandle);
			ReferencedObject.ReleaseField(ref _blendTree);
			_blendTree = null;
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarAnimationState);
			}
		}

		[MonoPInvokeCallback(typeof(StateStatusCallback))]
		private static void OnStateStatusCallback(uint stateStatus, IntPtr nativeHandle)
		{
			switch ((AnimStateStatus)stateStatus)
			{
			case AnimStateStatus.StateEnter:
				if (!_stateEnterCallbacks.ContainsKey(nativeHandle))
				{
					break;
				}
				{
					foreach (Action<AvatarAnimationState> item in _stateEnterCallbacks[nativeHandle])
					{
						item(_nativeHandleMap[nativeHandle]);
					}
					break;
				}
			case AnimStateStatus.StateEnd:
				if (!_stateEndCallbacks.ContainsKey(nativeHandle))
				{
					break;
				}
				{
					foreach (Action<AvatarAnimationState> item2 in _stateEndCallbacks[nativeHandle])
					{
						item2(_nativeHandleMap[nativeHandle]);
					}
					break;
				}
			case AnimStateStatus.StateLeave:
				if (!_stateLeaveCallbacks.ContainsKey(nativeHandle))
				{
					break;
				}
				{
					foreach (Action<AvatarAnimationState> item3 in _stateLeaveCallbacks[nativeHandle])
					{
						item3(_nativeHandleMap[nativeHandle]);
					}
					break;
				}
			case AnimStateStatus.StateRunning:
				break;
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_GetName(IntPtr nativeHandle, StringBuilder stateName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_SetSpeed(IntPtr nativeHandle, float speed);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_SetWrapMode(IntPtr nativeHandle, float wrapMode);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_SetStartTime(IntPtr nativeHandle, float startTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_AddAnimazClip(IntPtr nativeHandle, string animationName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarAnimationState_CreateBlendTree(IntPtr nativeHandle, uint blendTreeType);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAnimationState_SetAnimationStateCallBack(IntPtr nativeHandle, StateStatusCallback stateStatusCallback);
	}
	public class AvatarAutoFitController : NativeObject
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void AvatarOffsetChangedCallback(IntPtr nativeHandle, Vector3 avatarOffset);

		public AvatarBodyAnimController owner;

		public Vector3 avatarOffset;

		private bool _localAvatarHeightFittingEnable;

		private float _maxFloatingTime = 3f;

		private float _maxCrouchingTime = 3f;

		private float _crouchingDistance = 0.2f;

		private float _maxCrouchingDistance = 0.7f;

		private bool _callBackInitiated;

		private bool _needUpdateOffset;

		private static Dictionary<IntPtr, List<Action<AvatarAutoFitController, Vector3>>> _avatarOffsetChangedCallbacks = new Dictionary<IntPtr, List<Action<AvatarAutoFitController, Vector3>>>();

		private static Dictionary<IntPtr, Vector3> _avatarOffsetChangedCallbackToInvoke = new Dictionary<IntPtr, Vector3>();

		private static Dictionary<IntPtr, AvatarAutoFitController> _nativeHandleMap = new Dictionary<IntPtr, AvatarAutoFitController>();

		private const string PavDLLName = "effect";

		public bool localAvatarHeightFittingEnable
		{
			get
			{
				return _localAvatarHeightFittingEnable;
			}
			set
			{
				_localAvatarHeightFittingEnable = value;
				pav_AvatarAutoFitController_SetLocalAvatarHeightFittingEnable(base.nativeHandle, _localAvatarHeightFittingEnable);
			}
		}

		public AvatarAutoFitController(IntPtr nativeHandler_, AvatarBodyAnimController owner_)
		{
			SetNativeHandle(nativeHandler_, needRetain: false);
			_nativeHandleMap.Add(nativeHandler_, this);
			owner = owner_;
		}

		public void UpdateAvatarHeightOffset()
		{
			_needUpdateOffset = true;
		}

		public void SetCurrentAvatarOffset(Vector3 currentOffset)
		{
			avatarOffset = currentOffset;
			pav_AvatarAutoFitController_SetCurrentAvatarOffset(base.nativeHandle, currentOffset);
		}

		public Vector3 GetAvatarOffset()
		{
			Vector3 result = default(Vector3);
			pav_AvatarAutoFitController_GetAvatarOffset(base.nativeHandle, ref result);
			return result;
		}

		public void SetMaxFloatingTime(float maxFloatingTime)
		{
			_maxFloatingTime = maxFloatingTime;
			pav_AvatarAutoFitController_SetMaxFloatingTime(base.nativeHandle, maxFloatingTime);
		}

		public void SetMaxCrouchingTime(float maxCrouchingTime)
		{
			_maxCrouchingTime = maxCrouchingTime;
			pav_AvatarAutoFitController_SetMaxCrouchingTime(base.nativeHandle, maxCrouchingTime);
		}

		public void SetCrouchingDistance(float crouchingDistance)
		{
			_crouchingDistance = crouchingDistance;
			pav_AvatarAutoFitController_SetCrouchingDistance(base.nativeHandle, crouchingDistance);
		}

		public void SetMaxCrouchingDistance(float maxCrouchingDistance)
		{
			_maxCrouchingDistance = maxCrouchingDistance;
			pav_AvatarAutoFitController_SetMaxCrouchingDistance(base.nativeHandle, maxCrouchingDistance);
		}

		public void AddAvatarOffsetChangedCallback(Action<AvatarAutoFitController, Vector3> callback)
		{
			if (!_callBackInitiated && pav_AvatarAutoFitController_SetAvatarOffsetChangedCallback(base.nativeHandle, OnAvatarOffsetChangedCallback) == NativeResult.Success)
			{
				_callBackInitiated = true;
			}
			if (_callBackInitiated)
			{
				if (!_avatarOffsetChangedCallbacks.ContainsKey(base.nativeHandle))
				{
					_avatarOffsetChangedCallbacks.Add(base.nativeHandle, new List<Action<AvatarAutoFitController, Vector3>>());
				}
				_avatarOffsetChangedCallbacks[base.nativeHandle].Add(callback);
			}
		}

		public void ClearAvatarOffsetChangedCallback(Action<AvatarAutoFitController, Vector3> callback)
		{
			if (_callBackInitiated && _avatarOffsetChangedCallbacks.ContainsKey(base.nativeHandle))
			{
				_avatarOffsetChangedCallbacks[base.nativeHandle].Remove(callback);
			}
		}

		public void Internal_UpdateFrame()
		{
			if (!_avatarOffsetChangedCallbackToInvoke.ContainsKey(base.nativeHandle) || !_avatarOffsetChangedCallbacks.ContainsKey(base.nativeHandle))
			{
				return;
			}
			foreach (Action<AvatarAutoFitController, Vector3> item in _avatarOffsetChangedCallbacks[base.nativeHandle])
			{
				item(_nativeHandleMap[base.nativeHandle], _avatarOffsetChangedCallbackToInvoke[base.nativeHandle]);
			}
			_avatarOffsetChangedCallbackToInvoke.Remove(base.nativeHandle);
		}

		public void Internal_LateUpdateFrame()
		{
			if (_needUpdateOffset)
			{
				pav_AvatarAutoFitController_UpdateAvatarHeightOffset(base.nativeHandle);
				_needUpdateOffset = false;
			}
		}

		protected override void OnDestroy()
		{
			_avatarOffsetChangedCallbacks.Remove(base.nativeHandle);
			_avatarOffsetChangedCallbackToInvoke.Remove(base.nativeHandle);
			_nativeHandleMap.Remove(base.nativeHandle);
			base.OnDestroy();
		}

		[MonoPInvokeCallback(typeof(AvatarOffsetChangedCallback))]
		private static void OnAvatarOffsetChangedCallback(IntPtr nativeHandle, Vector3 avatarOffset)
		{
			if (!_avatarOffsetChangedCallbackToInvoke.ContainsKey(nativeHandle))
			{
				_avatarOffsetChangedCallbackToInvoke.Add(nativeHandle, avatarOffset);
			}
			else
			{
				_avatarOffsetChangedCallbackToInvoke[nativeHandle] = avatarOffset;
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_UpdateAvatarHeightOffset(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_GetAvatarOffset(IntPtr nativeHandle, ref Vector3 avatarOffset);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetCurrentAvatarOffset(IntPtr nativeHandle, Vector3 currentOffset);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetLocalAvatarHeightFittingEnable(IntPtr nativeHandle, bool enable);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetMaxFloatingTime(IntPtr nativeHandle, float maxFloatingTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetMaxCrouchingTime(IntPtr nativeHandle, float maxCrouchingTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetCrouchingDistance(IntPtr nativeHandle, float crouchingDistance);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetMaxCrouchingDistance(IntPtr nativeHandle, float maxCrouchingDistance);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarAutoFitController_SetAvatarOffsetChangedCallback(IntPtr nativeHandle, AvatarOffsetChangedCallback callback);
	}
	public enum IKEffectorType
	{
		Root,
		Head,
		LeftHand,
		RightHand,
		LeftFoot,
		RightFoot,
		Count
	}
	public enum IKTrackingSource
	{
		DeviceInput,
		Animation,
		Custom
	}
	public enum IKAutoStopMode
	{
		ControllerDisconnect = 1,
		ControllerIdle,
		ControllerLoseTracking,
		ControllerFarAway,
		Count
	}
	public enum AnimLayerBlendMode
	{
		Lerp,
		Additive,
		Override,
		Count
	}
	public enum AnimLayerType
	{
		AnimationClip,
		RemotePackage,
		Count
	}
	public enum AnimWrapMode
	{
		Loop = 0,
		PingPong = -1,
		ClampForever = -2,
		Seek = -3,
		Count = -2
	}
	public enum AnimBlendTreeType
	{
		Invalid = -1,
		BlendTree1D,
		BlendTree2D,
		BlendTreeDirect
	}
	public class AvatarBodyAnimController : NativeObject
	{
		public bool offsetDirty = true;

		public bool restoreToIdleWhenHeightInvalid;

		private AvatarAutoFitController _autoFitController;

		private XForm _headInitXform;

		private Quaternion _headOrientationInvAvatarSpace;

		private Matrix4x4 _headOrientationInvMatAvatarSpace;

		private bool _headXformInitialized;

		private Dictionary<string, AvatarAnimationLayer> _animationLayersMap = new Dictionary<string, AvatarAnimationLayer>();

		private AvatarAnimationLayer _remotePackageJointLayer;

		private AvatarAnimationLayer _remotePackageBlendShapeLayer;

		private TypeID2NameIDTable _jointNameIDTables;

		private NativeCall_AvatarBodyAnimController _rmiObject;

		private IDParameterTable _animationParameterTable;

		private Vector3 _eyeOffset;

		private Vector3 _leftHandPositionOffset;

		private Vector3 _rightHandPositionOffset;

		private Quaternion _leftHandRotationOffset;

		private Quaternion _rightHandRotationOffset;

		private float _minHeight = -10f;

		private float _maxHeight = 10f;

		private AvatarAnimationLayer _actionLayer;

		private bool _isPlayingIdle;

		private const string PavDLLName = "effect";

		public TypeID2NameIDTable jointNameIDTable
		{
			get
			{
				if (_jointNameIDTables == null)
				{
					_jointNameIDTables = new TypeID2NameIDTable(pav_AvatarBodyAnimController_GetJointNameIDTable(base.nativeHandle));
					_jointNameIDTables.Retain();
				}
				return _jointNameIDTables;
			}
		}

		public IDParameterTable animationParameterTable
		{
			get
			{
				if (_animationParameterTable == null)
				{
					_animationParameterTable = new IDParameterTable(pav_AvatarBodyAnimController_GetAnimationParameters(base.nativeHandle));
					_animationParameterTable.Retain();
				}
				return _animationParameterTable;
			}
		}

		public AvatarAutoFitController autoFitController
		{
			get
			{
				if (_autoFitController == null)
				{
					IntPtr intPtr = pav_AvatarBodyAnimController_GetAutoFitController(base.nativeHandle);
					if (intPtr != IntPtr.Zero)
					{
						_autoFitController = new AvatarAutoFitController(intPtr, this);
						_autoFitController.Retain();
					}
				}
				return _autoFitController;
			}
		}

		public bool started { get; set; }

		public AvatarEntity owner { get; private set; }

		public Vector3 eyeOffset
		{
			get
			{
				return _eyeOffset;
			}
			set
			{
				_eyeOffset = value;
				offsetDirty = true;
			}
		}

		public Vector3 leftHandPositionOffset
		{
			get
			{
				return _leftHandPositionOffset;
			}
			set
			{
				_leftHandPositionOffset = value;
				offsetDirty = true;
			}
		}

		public Vector3 rightHandPositionOffset
		{
			get
			{
				return _rightHandPositionOffset;
			}
			set
			{
				_rightHandPositionOffset = value;
				offsetDirty = true;
			}
		}

		public Quaternion leftHandRotationOffset
		{
			get
			{
				return _leftHandRotationOffset;
			}
			set
			{
				_leftHandRotationOffset = value;
				offsetDirty = true;
			}
		}

		public Quaternion rightHandRotationOffset
		{
			get
			{
				return _rightHandRotationOffset;
			}
			set
			{
				_rightHandRotationOffset = value;
				offsetDirty = true;
			}
		}

		public AvatarBodyAnimController(IntPtr nativeHandler_, AvatarEntity owner_)
		{
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarBodyAnimController);
			}
			owner = owner_;
			SetNativeHandle(nativeHandler_, needRetain: false);
			eyeOffset = new Vector3(0f, 0.1f, 0.1f);
			leftHandPositionOffset = new Vector3(0.036f, 0.041f, 0.081f);
			rightHandPositionOffset = new Vector3(-0.036f, 0.041f, 0.081f);
			leftHandRotationOffset = Quaternion.AngleAxis(36f, Vector3.left);
			rightHandRotationOffset = Quaternion.AngleAxis(36f, Vector3.left);
			InitNativeAnimationLayers();
		}

		public XForm GetJointXForm(uint jointType)
		{
			XForm entityXForm = default(XForm);
			pav_AvatarBodyAnimController_GetJointXForm(base.nativeHandle, jointType, ref entityXForm);
			return entityXForm;
		}

		public void SetJointXForm(uint jointType, XForm xform)
		{
			pav_AvatarBodyAnimController_SetJointXForm(base.nativeHandle, jointType, ref xform);
		}

		public XForm GetJointWorldXForm(uint jointType)
		{
			XForm entityXForm = default(XForm);
			pav_AvatarBodyAnimController_GetJointWorldXForm(base.nativeHandle, jointType, ref entityXForm);
			return entityXForm;
		}

		public void GetJointXForms(uint[] jointTypes, ref XForm[] xforms)
		{
			if (jointTypes.Length == xforms.Length)
			{
				GCHandle gCHandle = GCHandle.Alloc(jointTypes, GCHandleType.Pinned);
				GCHandle gCHandle2 = GCHandle.Alloc(xforms, GCHandleType.Pinned);
				pav_AvatarBodyAnimController_GetJointXForms(base.nativeHandle, (uint)jointTypes.Length, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject());
				gCHandle.Free();
				gCHandle2.Free();
			}
		}

		public void setWorldOrientation(uint count, uint[] jointTypes, Quaternion[] jointQuats)
		{
			if (jointTypes.Length == jointQuats.Length)
			{
				GCHandle gCHandle = GCHandle.Alloc(jointTypes, GCHandleType.Pinned);
				GCHandle gCHandle2 = GCHandle.Alloc(jointQuats, GCHandleType.Pinned);
				pav_AvatarBodyAnimController_SetWorldOrientations(base.nativeHandle, count, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject());
				gCHandle.Free();
				gCHandle2.Free();
			}
		}

		public XForm GetRemotePackageAvatarXForm()
		{
			XForm xform = default(XForm);
			pav_AvatarBodyAnimController_GetRemotePackageAvatarXForm(base.nativeHandle, ref xform);
			return xform;
		}

		public void SetIKEnable(uint ikEffectorType, bool enable)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetIKEnable(ikEffectorType, enable);
			}
		}

		public void SetIKEffectorXForm(uint iKEffectorType, XForm xform)
		{
			pav_AvatarBodyAnimController_SetIKEffectorXForm(base.nativeHandle, iKEffectorType, ref xform);
		}

		public void SetIKEffectorXForms(uint[] iKEffectorTypes, XForm[] xforms)
		{
			pav_AvatarBodyAnimController_SetIKEffectorXForms(base.nativeHandle, (uint)iKEffectorTypes.Length, ref iKEffectorTypes, ref xforms);
		}

		public XForm GetIKEffectorXForm(uint iKEffectorType)
		{
			XForm XForm = default(XForm);
			pav_AvatarBodyAnimController_GetIKEffectorXForm(base.nativeHandle, iKEffectorType, ref XForm);
			return XForm;
		}

		public void SetUpdateIKTargetFromDevice(uint ikEffectorType, bool enable)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetUpdateIKTargetFromDevice(ikEffectorType, enable);
			}
		}

		public void SetIKTrackingSource(uint ikEffectorType, uint trackingSource)
		{
			if (trackingSource == 0)
			{
				SetUpdateIKTargetFromDevice(ikEffectorType, enable: true);
			}
			else
			{
				SetUpdateIKTargetFromDevice(ikEffectorType, enable: false);
			}
			if (trackingSource == 1)
			{
				pav_AvatarBodyAnimController_SetUpdateIKTargetFromAnimation(base.nativeHandle, ikEffectorType, enable: true);
			}
			else
			{
				pav_AvatarBodyAnimController_SetUpdateIKTargetFromAnimation(base.nativeHandle, ikEffectorType, enable: false);
			}
		}

		public void SetRotationLimit(uint jointType, Vector3 minAngle, Vector3 maxAngle)
		{
			pav_AvatarBodyAnimController_SetRotationLimit(base.nativeHandle, jointType, minAngle, minAngle);
		}

		public void SetRotationLimitEnable(uint jointType, bool enable)
		{
			pav_AvatarBodyAnimController_SetRotationLimitEnable(base.nativeHandle, jointType, enable);
		}

		public void SetStretchEnable(uint ikEffectorType, bool enable)
		{
			pav_AvatarBodyAnimController_SetStretchEnable(base.nativeHandle, ikEffectorType, enable);
		}

		public void SetMaxStretchLength(uint ikEffectorType, float length)
		{
			pav_AvatarBodyAnimController_SetMaxStretchLength(base.nativeHandle, ikEffectorType, length);
		}

		public void SetMaxControllerDistance(float distance)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetMaxControllerDistance(distance);
			}
		}

		public void SetIKAutoStopModeEnable(uint ikAutoStopMode, bool enable)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetIKAutoStopModeEnable(ikAutoStopMode, enable);
			}
		}

		public void SetIKHandInvalidRegionEnable(bool enable)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetIKHandInvalidRegionEnable(enable);
			}
		}

		public void SetAvatarHeight(float height, bool isEyeHeight = true)
		{
			owner.owner.SetAvatarHeight(height, isEyeHeight);
			if (_autoFitController != null && _autoFitController.localAvatarHeightFittingEnable)
			{
				_autoFitController.UpdateAvatarHeightOffset();
			}
		}

		public void SetValidHipsHeightRange(float minHeight, float maxHeight)
		{
			_minHeight = minHeight;
			_maxHeight = maxHeight;
			pav_AvatarBodyAnimController_SetValidHipsHeightRange(base.nativeHandle, minHeight, maxHeight);
		}

		public AvatarAnimationLayer CreateAnimationLayerByName(string layerName)
		{
			IntPtr intPtr = pav_AvatarBodyAnimController_CreateAnimationLayerByName(base.nativeHandle, layerName);
			if (intPtr != IntPtr.Zero)
			{
				AvatarAnimationLayer avatarAnimationLayer = new AvatarAnimationLayer(intPtr);
				avatarAnimationLayer.Retain();
				_animationLayersMap[layerName] = avatarAnimationLayer;
				avatarAnimationLayer.name = layerName;
				avatarAnimationLayer.owner = this;
				return avatarAnimationLayer;
			}
			return null;
		}

		public AvatarAnimationLayer GetAnimationLayerByName(string layerName)
		{
			if (_animationLayersMap.ContainsKey(layerName))
			{
				return _animationLayersMap[layerName];
			}
			return null;
		}

		public AvatarAnimationLayer GetRemotePackageJointLayer()
		{
			if (_remotePackageJointLayer == null)
			{
				_remotePackageJointLayer = GetAnimationLayerByName("RemotePackageJoint");
				if (_remotePackageJointLayer != null)
				{
					_remotePackageJointLayer.layerType = AnimLayerType.RemotePackage;
				}
			}
			return _remotePackageJointLayer;
		}

		public AvatarAnimationLayer GetRemotePackageBlendShapeLayer()
		{
			if (_remotePackageBlendShapeLayer == null)
			{
				_remotePackageBlendShapeLayer = GetAnimationLayerByName("RemotePackageBlendShape");
				if (_remotePackageBlendShapeLayer != null)
				{
					_remotePackageBlendShapeLayer.layerType = AnimLayerType.RemotePackage;
				}
			}
			return _remotePackageBlendShapeLayer;
		}

		public void SetAnimationParameterBoolByID(uint parameterID, bool value)
		{
			pav_AvatarBodyAnimController_SetAnimationParameterBoolByID(base.nativeHandle, parameterID, value);
		}

		public void SetAnimationParameterFloatByID(uint parameterID, float value)
		{
			pav_AvatarBodyAnimController_SetAnimationParameterFloatByID(base.nativeHandle, parameterID, value);
		}

		public void SetAnimationParameterBoolByName(string parameterName, bool value)
		{
			pav_AvatarBodyAnimController_SetAnimationParameterBoolByName(base.nativeHandle, parameterName, value);
		}

		public void SetAnimationParameterFloatByName(string parameterName, float value)
		{
			pav_AvatarBodyAnimController_SetAnimationParameterFloatByName(base.nativeHandle, parameterName, value);
		}

		public void UpdateCustomHandPose(uint count, uint[] poseTypes, Vector3[] worldOffsets, XForm wristWorldXForm, uint side, bool syncWristTransform)
		{
			GCHandle gCHandle = GCHandle.Alloc(poseTypes, GCHandleType.Pinned);
			GCHandle gCHandle2 = GCHandle.Alloc(worldOffsets, GCHandleType.Pinned);
			pav_AvatarBodyAnimController_UpdateCustomHandPose(base.nativeHandle, count, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject(), ref wristWorldXForm, side, syncWristTransform);
			gCHandle.Free();
			gCHandle2.Free();
		}

		public void GetSkeletonJointInitOffsets(uint count, uint[] jointTypes, ref Vector3[] initPositions)
		{
			if (jointTypes.Length >= count && initPositions.Length >= count)
			{
				GCHandle gCHandle = GCHandle.Alloc(jointTypes, GCHandleType.Pinned);
				GCHandle gCHandle2 = GCHandle.Alloc(initPositions, GCHandleType.Pinned);
				pav_AvatarBodyAnimController_GetSkeletonJointInitOffsets(base.nativeHandle, count, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject());
				gCHandle.Free();
				gCHandle2.Free();
			}
		}

		public void Internal_LateUpdateFrame()
		{
			UpdateAvatarEntityXform();
			if (_autoFitController != null)
			{
				_autoFitController.Internal_LateUpdateFrame();
			}
			if (owner.owner.capabilities.controlSourceType != ControlSourceType.RemoteServer || !restoreToIdleWhenHeightInvalid)
			{
				return;
			}
			if (GetRemotePackageAvatarXForm().position.y < _minHeight)
			{
				if (_actionLayer == null)
				{
					_actionLayer = GetAnimationLayerByName("ActionLayer");
					AvatarMask avatarMask = new AvatarMask();
					avatarMask.Retain();
					_actionLayer.SetAvatarMask(avatarMask);
					for (uint num = 0u; num < 105; num++)
					{
						switch (num)
						{
						case 2u:
						case 20u:
						case 21u:
						case 22u:
						case 23u:
						case 24u:
						case 25u:
						case 26u:
						case 27u:
						case 28u:
							continue;
						}
						avatarMask.AddJointWithType((JointType)num);
					}
				}
				if (_actionLayer != null)
				{
					_actionLayer.PlayAnimationClip("idle", 0f, 1f, 0.5f);
					_isPlayingIdle = true;
				}
			}
			else if (_actionLayer != null && _isPlayingIdle)
			{
				_actionLayer.StopAnimation(1f);
				_isPlayingIdle = false;
			}
		}

		public void Internal_UpdateFrame()
		{
			if (!_headXformInitialized)
			{
				SetDefaultHeadXform();
			}
			if (_autoFitController != null)
			{
				_autoFitController.Internal_UpdateFrame();
			}
		}

		public void Internal_Initialize(uint nativeEntityId)
		{
			if (_rmiObject == null)
			{
				_rmiObject = new NativeCall_AvatarBodyAnimController(this, nativeEntityId);
				_rmiObject.Retain();
			}
		}

		public void Internal_Destroy()
		{
			if (!(base.nativeHandle != IntPtr.Zero))
			{
				return;
			}
			foreach (KeyValuePair<string, AvatarAnimationLayer> item in _animationLayersMap)
			{
				item.Value.Release();
			}
			_animationLayersMap.Clear();
			if (_autoFitController != null)
			{
				_autoFitController.Release();
				_autoFitController = null;
			}
			if (_jointNameIDTables != null)
			{
				_jointNameIDTables.Release();
				_jointNameIDTables = null;
			}
			if (_animationParameterTable != null)
			{
				_animationParameterTable.Release();
				_animationParameterTable = null;
			}
			if (_rmiObject != null)
			{
				_rmiObject.Release();
				_rmiObject = null;
			}
			SetNativeHandle(IntPtr.Zero, needRetain: false);
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarBodyAnimController);
			}
		}

		protected override void OnDestroy()
		{
			Internal_Destroy();
			base.OnDestroy();
		}

		public void OnAnimationStart()
		{
			started = true;
			SetDefaultHeadXform();
		}

		public void SetDefaultHeadXform()
		{
			_headInitXform = GetJointXForm(8u);
			XForm nativeXForm = owner.GetNativeXForm();
			Transform transform = owner.transform;
			transform.localPosition = nativeXForm.position;
			transform.localRotation = nativeXForm.orientation;
			transform.localScale = nativeXForm.scale;
			_headOrientationInvAvatarSpace = Quaternion.Inverse(nativeXForm.orientation * _headInitXform.orientation);
			_headOrientationInvMatAvatarSpace.SetTRS(new Vector3(0f, 0f, 0f), _headOrientationInvAvatarSpace, new Vector3(1f, 1f, 1f));
			_headXformInitialized = true;
		}

		public void UpdateAvatarEntityXform()
		{
			XForm nativeXForm = owner.GetNativeXForm();
			owner.transform.localPosition = nativeXForm.position;
			owner.transform.localRotation = nativeXForm.orientation;
			owner.transform.localScale = nativeXForm.scale;
		}

		public XForm GetEyeXForm()
		{
			if (!_headXformInitialized)
			{
				SetDefaultHeadXform();
			}
			XForm result = default(XForm);
			XForm jointXForm = GetJointXForm(8u);
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetTRS(jointXForm.position, jointXForm.orientation, jointXForm.scale);
			XForm nativeXForm = owner.GetNativeXForm();
			Matrix4x4 matrix4x2 = default(Matrix4x4);
			matrix4x2.SetTRS(nativeXForm.position, nativeXForm.orientation, nativeXForm.scale);
			Quaternion quaternion = nativeXForm.orientation * jointXForm.orientation;
			Matrix4x4 matrix4x3 = default(Matrix4x4);
			matrix4x3 = matrix4x2 * matrix4x;
			result.position = (matrix4x3 * _headOrientationInvMatAvatarSpace).MultiplyPoint(_eyeOffset);
			result.orientation = quaternion * _headOrientationInvAvatarSpace;
			return result;
		}

		private void InitNativeAnimationLayers()
		{
			uint num = pav_AvatarBodyAnimController_GetAnimationLayersCount(base.nativeHandle);
			IntPtr[] array = new IntPtr[num];
			GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
			pav_AvatarBodyAnimController_GetAnimationLayers(base.nativeHandle, num, gCHandle.AddrOfPinnedObject());
			for (uint num2 = 0u; num2 < num; num2++)
			{
				AvatarAnimationLayer avatarAnimationLayer = new AvatarAnimationLayer(array[num2]);
				avatarAnimationLayer.Retain();
				_animationLayersMap[avatarAnimationLayer.name] = avatarAnimationLayer;
			}
			gCHandle.Free();
			GetRemotePackageJointLayer();
			GetRemotePackageBlendShapeLayer();
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetJointNameIDTable(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetIKEffectorIDTable(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetIKEffectorXForm(IntPtr nativeHandle, uint ikEffectorType, ref XForm XForm);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetIKEffectorXForm(IntPtr nativeHandle, uint ikEffectorType, ref XForm xform);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetIKEffectorXForms(IntPtr nativeHandle, uint jointCount, ref uint[] jointTypes, ref XForm[] xforms);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetJointXForm(IntPtr entityHandle, uint jointType, ref XForm entityXForm);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetJointWorldXForm(IntPtr entityHandle, uint jointType, ref XForm entityXForm);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetJointXForm(IntPtr entityHandle, uint jointType, ref XForm entityXForm);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetJointXForms(IntPtr entityHandle, uint jointCount, IntPtr jointTypes, IntPtr jointXForms);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetRemotePackageAvatarXForm(IntPtr nativeHandle, ref XForm xform);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetUpdateIKTargetFromAnimation(IntPtr nativeHandle, uint ikEffectorType, bool enable);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetMaxStretchLength(IntPtr nativeHandle, uint ikEffectorType, float length);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetStretchEnable(IntPtr nativeHandle, uint ikEffectorType, bool enable);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetRotationLimit(IntPtr nativeHandle, uint jointType, Vector3 minAngle, Vector3 maxAngle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetRotationLimitEnable(IntPtr nativeHandle, uint jointType, bool enable);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetValidHipsHeightRange(IntPtr nativeHandle, float minHeight, float maxHeight);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_UpdateCustomHandPose(IntPtr nativeHandle, uint jointCount, IntPtr poseTypes, IntPtr worldOffsets, ref XForm wristWorldXForm, uint side, bool syncWristTransform);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetWorldOrientations(IntPtr nativeHandle, uint jointCount, IntPtr jointTypes, IntPtr jointQuats);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetSkeletonJointInitOffsets(IntPtr nativeHandle, uint jointCount, IntPtr jointTypes, IntPtr initPositions);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_CreateAnimationLayerByName(IntPtr nativeHandle, string layerName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetAnimationLayerByName(IntPtr nativeHandle, string layerName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarBodyAnimController_GetAnimationLayersCount(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_GetAnimationLayers(IntPtr nativeHandle, uint layerCount, IntPtr nativeHandleLayers);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetAnimationParameters(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetAnimationParameterBoolByID(IntPtr nativeHandle, uint parameterNameID, bool value);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetAnimationParameterFloatByID(IntPtr nativeHandle, uint parameterNameID, float value);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetAnimationParameterBoolByName(IntPtr nativeHandle, string parameterName, bool value);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarBodyAnimController_SetAnimationParameterFloatByName(IntPtr nativeHandle, string parameterName, float value);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarBodyAnimController_GetAutoFitController(IntPtr nativeHandle);
	}
	public enum HandSide
	{
		Invalid = -1,
		Left,
		Right,
		Count
	}
	public class AvatarCustomHandPose : NativeObject
	{
		private struct JointTransform
		{
			public JointType type;

			public Transform transform;

			public int parentIndex;
		}

		private HandSide side = HandSide.Invalid;

		private IKEffectorType ikEffectorType = IKEffectorType.LeftHand;

		public GameObject handPose;

		public GameObject handSkeleton;

		private Dictionary<string, PicoHandJointType.HandJointType> SkeletonData = new Dictionary<string, PicoHandJointType.HandJointType>();

		private Dictionary<JointType, Vector3> myJointOffsets = new Dictionary<JointType, Vector3>();

		private Dictionary<JointType, Vector3> recevieJointOffsets = new Dictionary<JointType, Vector3>();

		private List<JointTransform> _poseJointTransforms = new List<JointTransform>();

		private int _wristIndex;

		private Transform _avatarTransform;

		private XForm _wristXform;

		private XForm _wristWorldXform;

		private bool _syncWristTransform = true;

		private bool _ikTargetDirty = true;

		private Quaternion rootRetargetQuat;

		private Vector3 ReceiveUp;

		private Vector3 ReceiveForward;

		private Vector3 MyRightUp = new Vector3(0f, 0f, 1f);

		private Vector3 MyRightForward = new Vector3(1f, 0f, 0f);

		private Vector3 MyLeftUp = new Vector3(0f, 0f, -1f);

		private Vector3 MyLeftForward = new Vector3(-1f, 0f, 0f);

		private Vector3 wristOffset = new Vector3(0f, 0f, 0f);

		private bool hasAlignSkeleton;

		private int middleJointCount = 5;

		private bool scaleHandFlag;

		private PicoHandJointType.HandJointType[] MiddleJoints = new PicoHandJointType.HandJointType[5]
		{
			PicoHandJointType.HandJointType.MiddleRoot,
			PicoHandJointType.HandJointType.MiddleMeta,
			PicoHandJointType.HandJointType.MiddleProximal,
			PicoHandJointType.HandJointType.MiddleIntermediate,
			PicoHandJointType.HandJointType.MiddleDistal
		};

		private float handScale = 1f;

		public bool syncWristTransform
		{
			get
			{
				return _syncWristTransform;
			}
			set
			{
				_syncWristTransform = value;
				_ikTargetDirty = true;
			}
		}

		public void Internal_Initialize(HandSide _side, GameObject _handSkeleton, GameObject _handPose, Vector3 _up, Vector3 _forward, Vector3 _offset, Transform _avatarTrans)
		{
			side = _side;
			handSkeleton = _handSkeleton;
			handPose = _handPose;
			ReceiveUp = _up;
			ReceiveForward = _forward;
			wristOffset = _offset;
			_avatarTransform = _avatarTrans;
			ikEffectorType = ((_side == HandSide.Left) ? IKEffectorType.LeftHand : IKEffectorType.RightHand);
			SkeletonData = getCustomSkeletonData(handSkeleton);
			_poseJointTransforms = GetJointTransforms(handPose);
		}

		public void SetWristXForm(AvatarBodyAnimController bodyAnimController)
		{
			Matrix4x4 worldToLocalMatrix = _avatarTransform.worldToLocalMatrix;
			Quaternion rotation = _avatarTransform.rotation;
			if (bodyAnimController != null && _ikTargetDirty && bodyAnimController.owner.isAnyLodReady)
			{
				bodyAnimController.SetStretchEnable((uint)ikEffectorType, _syncWristTransform);
				bodyAnimController.SetUpdateIKTargetFromDevice((uint)ikEffectorType, !_syncWristTransform);
				_ikTargetDirty = false;
			}
			foreach (JointTransform poseJointTransform in _poseJointTransforms)
			{
				JointType type = poseJointTransform.type;
				if (type == JointType.RightHandWrist || type == JointType.LeftHandWrist)
				{
					if (_syncWristTransform)
					{
						Vector3 position = poseJointTransform.transform.localToWorldMatrix.MultiplyPoint(wristOffset);
						_wristWorldXform.orientation = poseJointTransform.transform.rotation * rootRetargetQuat;
						_wristWorldXform.position = position;
						_wristWorldXform.scale = new Vector3(handScale, handScale, handScale);
						_wristXform.position = worldToLocalMatrix.MultiplyPoint(_wristWorldXform.position);
						_wristXform.orientation = Quaternion.Inverse(rotation) * _wristWorldXform.orientation;
						_wristXform.scale = new Vector3(1f, 1f, 1f);
						bodyAnimController.SetIKEffectorXForm((uint)ikEffectorType, _wristXform);
					}
					break;
				}
			}
		}

		public void SetHandPose(AvatarBodyAnimController bodyAnimController)
		{
			if (!hasAlignSkeleton)
			{
				AlignHandSkeleton(bodyAnimController);
				hasAlignSkeleton = true;
			}
			uint num = 0u;
			uint[] array = new uint[_poseJointTransforms.Count];
			Vector3[] array2 = new Vector3[_poseJointTransforms.Count];
			foreach (JointTransform poseJointTransform in _poseJointTransforms)
			{
				JointType type = poseJointTransform.type;
				switch (type)
				{
				case JointType.LeftHandWrist:
				case JointType.RightHandWrist:
				{
					Vector3 position = poseJointTransform.transform.localToWorldMatrix.MultiplyPoint(wristOffset);
					_wristWorldXform.orientation = poseJointTransform.transform.rotation * rootRetargetQuat;
					_wristWorldXform.position = position;
					_wristWorldXform.scale = new Vector3(handScale, handScale, handScale);
					continue;
				}
				case JointType.Invalid:
					continue;
				}
				int parentIndex = poseJointTransform.parentIndex;
				JointType type2 = _poseJointTransforms[parentIndex].type;
				if (type2 != JointType.RightHandWrist && type2 != JointType.LeftHandWrist)
				{
					array2[num] = poseJointTransform.transform.position - _poseJointTransforms[parentIndex].transform.position;
					array[num] = (uint)type;
					num++;
				}
			}
			bodyAnimController.UpdateCustomHandPose(num, array, array2, _wristWorldXform, (uint)side, _syncWristTransform);
		}

		private void AlignHandSkeleton(AvatarBodyAnimController bodyAnimController)
		{
			uint[] array = new uint[26];
			Vector3[] initPositions = new Vector3[26];
			for (int i = 0; i < 26; i++)
			{
				array[i] = (uint)JointTypeFromHandType((PicoHandJointType.HandJointType)i, side);
			}
			bodyAnimController.GetSkeletonJointInitOffsets(26u, array, ref initPositions);
			for (int j = 0; j < 26; j++)
			{
				myJointOffsets.Add((JointType)array[j], initPositions[j]);
			}
			if (side == HandSide.Left)
			{
				alignHandRoot(ReceiveForward, ReceiveUp, MyLeftForward, MyLeftUp);
			}
			else
			{
				alignHandRoot(ReceiveForward, ReceiveUp, MyRightForward, MyRightUp);
			}
			if (!scaleHandFlag)
			{
				return;
			}
			float num = 0f;
			float num2 = 0f;
			for (int k = 0; k < middleJointCount; k++)
			{
				JointType key = JointTypeFromHandType(MiddleJoints[k], side);
				if (myJointOffsets.ContainsKey(key))
				{
					num += myJointOffsets[key].magnitude;
				}
				if (recevieJointOffsets.ContainsKey(key))
				{
					num2 += recevieJointOffsets[key].magnitude;
				}
			}
			handScale = num2 / num;
			if (handScale < 1f)
			{
				handScale = 1f;
			}
		}

		private List<JointTransform> GetJointTransforms(GameObject gob)
		{
			_wristIndex = -1;
			List<JointTransform> list = new List<JointTransform>();
			Dictionary<Transform, int> dictionary = new Dictionary<Transform, int>();
			bool flag = true;
			Transform[] componentsInChildren = gob.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				int value = -1;
				if ((bool)transform.parent && !dictionary.TryGetValue(transform.parent, out value))
				{
					value = -1;
				}
				PicoHandJointType.HandJointType handJointType = PicoHandJointType.HandJointType.Invalid;
				if (SkeletonData.ContainsKey(transform.name))
				{
					handJointType = SkeletonData[transform.name];
					if (handJointType == PicoHandJointType.HandJointType.Wrist)
					{
						flag = false;
					}
				}
				else if (flag)
				{
					handJointType = PicoHandJointType.HandJointType.Wrist;
					flag = false;
				}
				if (handJointType == PicoHandJointType.HandJointType.Wrist)
				{
					_wristIndex = list.Count;
				}
				if (value >= 0 && list[value].type == JointType.Invalid)
				{
					value = list[value].parentIndex;
				}
				JointType jointType = JointTypeFromHandType(handJointType, side);
				list.Add(new JointTransform
				{
					type = jointType,
					transform = transform,
					parentIndex = value
				});
				if (!recevieJointOffsets.ContainsKey(jointType))
				{
					if (side == HandSide.Right)
					{
						recevieJointOffsets.Add(jointType, transform.localPosition);
					}
					else
					{
						Vector3 localPosition = transform.localPosition;
						localPosition[0] = 0f - localPosition[0];
						recevieJointOffsets.Add(jointType, localPosition);
					}
				}
				dictionary.Add(transform, list.Count - 1);
			}
			return list;
		}

		private Dictionary<string, PicoHandJointType.HandJointType> getCustomSkeletonData(GameObject gob)
		{
			Dictionary<string, PicoHandJointType.HandJointType> dictionary = new Dictionary<string, PicoHandJointType.HandJointType>();
			Transform[] componentsInChildren = gob.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				PicoHandJointType component = transform.GetComponent<PicoHandJointType>();
				PicoHandJointType.HandJointType value = PicoHandJointType.HandJointType.Invalid;
				if (component != null)
				{
					value = component.jointType;
				}
				dictionary.Add(transform.name, value);
			}
			return dictionary;
		}

		private void alignHandRoot(Vector3 recevieForward, Vector3 recevieUp, Vector3 myForward, Vector3 myUp)
		{
			Quaternion quaternion = Quaternion.LookRotation(recevieForward, recevieUp);
			Quaternion rotation = Quaternion.LookRotation(myForward, myUp);
			rootRetargetQuat = quaternion * Quaternion.Inverse(rotation);
		}

		private JointType JointTypeFromHandType(PicoHandJointType.HandJointType handType, HandSide _side)
		{
			switch (handType)
			{
			case PicoHandJointType.HandJointType.Invalid:
				return JointType.Invalid;
			case PicoHandJointType.HandJointType.Wrist:
				if (_side != 0)
				{
					return JointType.RightHandWrist;
				}
				return JointType.LeftHandWrist;
			default:
				return (JointType)(((_side == HandSide.Left) ? 50 : 80) + handType - 1);
			}
		}
	}
	public class AvatarMask : NativeObject
	{
		private const string PavDLLName = "effect";

		public AvatarAnimationLayer owner { get; set; }

		public AvatarMask()
		{
			IntPtr nativeHandle_ = pav_AvatarMask_New();
			SetNativeHandle(nativeHandle_, needRetain: false);
		}

		public void AddJointWithType(JointType jointType)
		{
			pav_AvatarMask_AddJointType(base.nativeHandle, (uint)jointType);
		}

		public void AddJointWithName(string jointTransformName)
		{
			pav_AvatarMask_AddJoint(base.nativeHandle, jointTransformName);
		}

		public void Clear()
		{
			pav_AvatarMask_Clear(base.nativeHandle);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarMask_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarMask_AddJoint(IntPtr nativeHandle, string jointTransformName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarMask_AddJointType(IntPtr nativeHandle, uint jointTypeId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarMask_Clear(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarMask_GetJointTypeCount(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarMask_GetJointType(IntPtr nativeHandle, uint slotIndex);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarMask_GetJointNameCount(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarMask_GetJointName(IntPtr nativeHandle, uint jointIndex, StringBuilder jointName, uint nameBufferLen);
	}
	public class AvatarAssetBundle : NativeObject
	{
		private const string PavDLLName = "effect";

		public AvatarAssetBundle()
		{
			SetNativeHandle(pav_AssetBundle_Create(), needRetain: false);
		}

		public NativeResult LoadFromZipFile(string path)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AssetBundle closed.");
			}
			return pav_AssetBundle_LoadFromZipFile(base.nativeHandle, path);
		}

		public NativeResult LoadFromZipMemoryView(MemoryView mv)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AssetBundle closed.");
			}
			return pav_AssetBundle_LoadFromZipMemoryView(base.nativeHandle, mv.nativeHandle);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AssetBundle_Create();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AssetBundle_LoadFromZipFile(IntPtr nativeHandle, string path);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AssetBundle_LoadFromZipMemoryView(IntPtr nativeHandle, IntPtr mv);
	}
	public enum AvatarShapingParamKind
	{
		Custom = -1,
		BlendShape,
		CurveLineWithBlendShape,
		ControlVertexShape
	}
	public enum AvatarFaceProfileShapingMethod
	{
		None,
		Bone,
		BlendShape
	}
	public enum AvatarFaceFeatureShapingMethod
	{
		None,
		Bone,
		BlendShape
	}
	public enum AvatarBodyProfileShapingMethod
	{
		None,
		Bone
	}
	public class AvatarEditState
	{
		public enum Status
		{
			None,
			Entering,
			Working
		}

		private PicoAvatar _avatar;

		private NativeCall_AvatarEditState _rmiObject;

		private Status _status;

		private uint _targetEditAspect = 268435455u;

		private uint _curEditAspect = 268435455u;

		private Action<NativeResult> _enterStateFinishCallback;

		public Status status => _status;

		public uint curEditAspect => _curEditAspect;

		public AvatarEditState(PicoAvatar avatar)
		{
			_avatar = avatar;
			_rmiObject = new NativeCall_AvatarEditState(this, avatar.nativeAvatarId);
			_rmiObject.Retain();
		}

		public void Destroy()
		{
			if (_rmiObject != null)
			{
				if (_status == Status.Working)
				{
					ExitState();
				}
				_rmiObject.Release();
				_rmiObject = null;
			}
		}

		public void EnterState(uint editAspect, Action<NativeResult> finishCallback)
		{
			if (_status == Status.Entering || _status == Status.Working)
			{
				finishCallback?.Invoke(NativeResult.MonoStateViolated);
				return;
			}
			_targetEditAspect = editAspect;
			_enterStateFinishCallback = finishCallback;
			_status = Status.Entering;
			_rmiObject.EnterState(editAspect);
		}

		public void Internal_OnEnterState(NativeResult result)
		{
			if (_status == Status.Entering)
			{
				_status = Status.Working;
				_curEditAspect = _targetEditAspect;
			}
			if (_enterStateFinishCallback != null)
			{
				_enterStateFinishCallback(result);
			}
		}

		public void ExitState()
		{
			if (_status == Status.Working)
			{
				_status = Status.None;
				_rmiObject.ExitState();
			}
		}

		public void SetShapingParam(uint paramGroup, uint paramId, uint paramKind, string paramVal)
		{
			if (_status == Status.Working)
			{
				_rmiObject.SetShapingParam(paramGroup, paramId, paramKind, paramVal);
			}
		}

		public string GetShapingParam(uint paramGroup, uint paramId, uint paramKind)
		{
			if (_status == Status.Working)
			{
				return _rmiObject.GetShapingParam(paramGroup, paramId, paramKind);
			}
			return "{}";
		}

		public void StartCompareShapingParam(uint paramGroup, uint paramId = 0u)
		{
			if (_status == Status.Working)
			{
				_rmiObject.StartCompareShapingParam(paramGroup, paramId);
			}
		}

		public void EndCompareShapingParam()
		{
			if (_status == Status.Working)
			{
				_rmiObject.EndCompareShapingParam();
			}
		}
	}
	public class AsyncRequestBase : NativeCaller
	{
		private static uint _instanceId = 1u;

		public long requestId => base.instanceId;

		public AsyncRequestBase(NativeCallerAttribute attribute)
			: base(attribute, GetNextInstanceId())
		{
		}

		private static uint GetNextInstanceId()
		{
			return ++_instanceId;
		}
	}
	public class LoadAvatarRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "LoadAvatar", 3073u);

		public static long DoRequest(string userId, string avatarId, string capabilities, Action<long, int, string> responsed = null)
		{
			LoadAvatarRequest req = new LoadAvatarRequest();
			IDParameterTable iDParameterTable = req.invokeArgumentTable;
			iDParameterTable.SetStringParam(0u, userId.ToString());
			iDParameterTable.SetStringParam(1u, avatarId);
			iDParameterTable.SetStringParam(2u, capabilities);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string stringParam = returnParams.GetStringParam(1u);
					if (PicoAvatarManager.instance.GetAvatar(userId) != null)
					{
						if (val == 0)
						{
							responsed?.Invoke(req.requestId, (int)val, stringParam);
						}
						else
						{
							responsed?.Invoke(req.requestId, (int)val, stringParam);
						}
					}
					PicoAvatarManager.instance.Internal_ProcessAvatarLoadRequest(req.requestId, userId, (int)val, stringParam);
				}
			});
			return req.requestId;
		}

		private LoadAvatarRequest()
			: base(_Attribte)
		{
		}
	}
	public class LoadAvatarWithJsonSpecRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "LoadAvatarWithJsonSpec", 3073u);

		public static long DoRequest(string userId, string jsonSpecdata, string capabilities, Action<long, int, string> responsed = null)
		{
			LoadAvatarWithJsonSpecRequest req = new LoadAvatarWithJsonSpecRequest();
			IDParameterTable iDParameterTable = req.invokeArgumentTable;
			iDParameterTable.SetStringParam(0u, userId.ToString());
			iDParameterTable.SetStringParam(1u, jsonSpecdata);
			iDParameterTable.SetStringParam(2u, capabilities);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string stringParam = returnParams.GetStringParam(1u);
					if (PicoAvatarManager.instance.GetAvatar(userId) != null)
					{
						if (val == 0)
						{
							responsed?.Invoke(req.requestId, (int)val, stringParam);
						}
						else
						{
							responsed?.Invoke(req.requestId, (int)val, stringParam);
						}
					}
					PicoAvatarManager.instance.Internal_ProcessAvatarLoadRequest(req.requestId, userId, (int)val, stringParam);
				}
			});
			return req.requestId;
		}

		private LoadAvatarWithJsonSpecRequest()
			: base(_Attribte)
		{
		}
	}
	public class VerifyAppTokenRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "VerifyAppToken", 3073u);

		public static long DoRequest(Action<uint, string> callback = null)
		{
			VerifyAppTokenRequest verifyAppTokenRequest = new VerifyAppTokenRequest();
			_ = verifyAppTokenRequest.invokeArgumentTable;
			verifyAppTokenRequest.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				uint val = 1u;
				returnParams.GetUIntParam(0u, ref val);
				string stringParam = returnParams.GetStringParam(1u);
				if (PicoAvatarManager.instance != null)
				{
					PicoAvatarManager.instance.Internal_OnInitialized(val == 0);
				}
				if (callback != null)
				{
					callback(val, stringParam);
				}
			});
			return verifyAppTokenRequest.requestId;
		}

		private VerifyAppTokenRequest()
			: base(_Attribte)
		{
		}
	}
	public class GetEditDataRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "GetEditData", 3073u);

		public static long DoRequest(string type, Action<long, int, string> responsed = null)
		{
			GetEditDataRequest req = new GetEditDataRequest();
			req.invokeArgumentTable.SetStringParam(0u, type);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string uTF8StringParam = returnParams.GetUTF8StringParam(1u);
					responsed?.Invoke(req.requestId, (int)val, uTF8StringParam);
					PicoAvatarManager.instance.Internal_OnRequestDataArrived(req.requestId, (int)val, uTF8StringParam);
				}
			});
			return req.requestId;
		}

		private GetEditDataRequest()
			: base(_Attribte)
		{
		}
	}
	public class DownloadAssetRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "DownloadAsset", 3073u);

		public static long DoRequest(string assetId, Action<long, int, string> responsed = null)
		{
			DownloadAssetRequest req = new DownloadAssetRequest(assetId);
			req.invokeArgumentTable.SetStringParam(0u, assetId);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string uTF8StringParam = returnParams.GetUTF8StringParam(1u);
					responsed?.Invoke(req.requestId, (int)val, uTF8StringParam);
					PicoAvatarManager.instance.Internal_OnRequestDataArrived(req.requestId, (int)val, uTF8StringParam);
				}
			}, asyncApply: true);
			return req.requestId;
		}

		private DownloadAssetRequest(string avatarId)
			: base(_Attribte)
		{
		}
	}
	public class UpdateAvatarPreviewRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "UpdateAvatarPreview", 3073u);

		public static long DoRequest(string headImagePath, string halfImagePath, string fullImagePath, Action<long, int, string> responsed = null)
		{
			UpdateAvatarPreviewRequest req = new UpdateAvatarPreviewRequest();
			IDParameterTable iDParameterTable = req.invokeArgumentTable;
			iDParameterTable.SetStringParam(0u, headImagePath);
			iDParameterTable.SetStringParam(1u, halfImagePath);
			iDParameterTable.SetStringParam(2u, fullImagePath);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string uTF8StringParam = returnParams.GetUTF8StringParam(1u);
					responsed?.Invoke(req.requestId, (int)val, uTF8StringParam);
					PicoAvatarManager.instance.Internal_OnRequestDataArrived(req.requestId, (int)val, uTF8StringParam);
				}
			});
			return req.requestId;
		}

		private UpdateAvatarPreviewRequest()
			: base(_Attribte)
		{
		}
	}
	public class CustomRequest : AsyncRequestBase
	{
		private static NativeCallerAttribute _Attribte = new NativeCallerAttribute("AvatarRequest", "Custom", 3073u);

		public static long DoRequest(string jsonData, Action<long, int, string> responsed = null)
		{
			CustomRequest req = new CustomRequest();
			req.invokeArgumentTable.SetStringParam(0u, jsonData);
			req.DoApply(delegate(IDParameterTable returnParams, NativeCaller invoker)
			{
				if (PicoAvatarManager.instance != null)
				{
					uint val = 1u;
					returnParams.GetUIntParam(0u, ref val);
					string uTF8StringParam = returnParams.GetUTF8StringParam(1u);
					responsed?.Invoke(req.requestId, (int)val, uTF8StringParam);
					PicoAvatarManager.instance.Internal_OnRequestDataArrived(req.requestId, (int)val, uTF8StringParam);
				}
			}, asyncApply: true);
			return req.requestId;
		}

		private CustomRequest()
			: base(_Attribte)
		{
		}
	}
	public class AsyncResult
	{
		public enum ErrorActionType
		{
			Relogin_QuitApp,
			Retry_QuitApp,
			Retry,
			QuitApp,
			CustomCallback
		}

		private bool _OperationCancle;

		private bool _RequestFinished;

		private IntPtr _NativeHandle;

		private ErrorActionType _ErrorAction;

		private Action<AsyncResult> _RetryOrCustomCallback;

		private bool _ErrorActionExecuted;

		private Exception _Exception;

		private List<string> _ErrorTips;

		private const string PavDLLName = "effect";

		public Exception errorException => _Exception;

		public List<string> errorPositions => _ErrorTips;

		public bool requestFinished => _RequestFinished;

		public bool shouldHalt
		{
			get
			{
				if (!_OperationCancle)
				{
					return hasError;
				}
				return true;
			}
		}

		public bool hasError
		{
			get
			{
				if (_Exception != null || _ErrorTips != null)
				{
					return true;
				}
				if (_NativeHandle != IntPtr.Zero)
				{
					return pav_AsyncResult_HasError(_NativeHandle);
				}
				return false;
			}
		}

		public bool isErrorActionExecuted => _ErrorActionExecuted;

		public IntPtr nativeHandle
		{
			get
			{
				if (_NativeHandle == IntPtr.Zero)
				{
					_NativeHandle = pav_AsyncResult_New();
					if (_NativeHandle == IntPtr.Zero)
					{
						throw new OutOfMemoryException("AsyncResult.New");
					}
				}
				return _NativeHandle;
			}
		}

		public AsyncResult(ErrorActionType errorAction = ErrorActionType.Retry, Action<AsyncResult> retryOrCustomCallback = null)
		{
			_ErrorAction = errorAction;
			_RetryOrCustomCallback = retryOrCustomCallback;
		}

		~AsyncResult()
		{
			if (_NativeHandle != IntPtr.Zero)
			{
				NativeObject.ReleaseNative(ref _NativeHandle);
			}
		}

		public void Cancel()
		{
			_OperationCancle = true;
		}

		public void SetError(Exception e, string errorTip = "", string errorLog = "")
		{
			_OperationCancle = false;
			if (!string.IsNullOrEmpty(errorLog))
			{
				UnityEngine.Debug.Log("AAsyncRequest.AsyncResult.SetError.error:" + errorLog);
			}
			if (_Exception == null)
			{
				_Exception = e;
			}
			if (_ErrorTips == null)
			{
				_ErrorTips = new List<string>();
			}
			_ErrorTips.Add(errorTip);
		}

		public void Reuse()
		{
			if (!hasError)
			{
				_RequestFinished = false;
			}
		}

		public bool CheckAndProcessError()
		{
			if (_RequestFinished)
			{
				throw new InvalidProgramException("AsyncResult.CheckAndProcessError Can Only be invoked once ");
			}
			_RequestFinished = true;
			if (_OperationCancle)
			{
				return true;
			}
			if (hasError)
			{
				if (_Exception != null)
				{
					if (!(_Exception.GetType() == typeof(IOException)))
					{
						_ = _Exception.GetType() == typeof(OutOfMemoryException);
					}
					return false;
				}
				if (!_ErrorActionExecuted)
				{
					_ErrorActionExecuted = true;
					if (_ErrorTips != null && _ErrorTips.Count > 0)
					{
						_ = _ErrorTips[0];
					}
					else
					{
						GetNativeErrorString();
					}
				}
				return false;
			}
			return true;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AsyncResult_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_AsyncResult_HasError(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_AsyncResult_GetErrorStringLength(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_AsyncResult_GetErrorString(IntPtr handle, IntPtr chars, int charCount);

		private string GetNativeErrorString()
		{
			if (_NativeHandle == IntPtr.Zero)
			{
				return "";
			}
			int num = pav_AsyncResult_GetErrorStringLength(_NativeHandle);
			char[] value = new char[num];
			GCHandle gCHandle = GCHandle.Alloc(value, GCHandleType.Pinned);
			pav_AsyncResult_GetErrorString(_NativeHandle, gCHandle.AddrOfPinnedObject(), num);
			gCHandle.Free();
			return new string(value, 0, num);
		}
	}
	public class WaitCounter
	{
		private volatile int _waitingCount = 1;

		private Action _finishedCallback;

		public bool isReady => _waitingCount == 0;

		~WaitCounter()
		{
		}

		public void AddWaitCount(int count = 1)
		{
			_waitingCount += count;
		}

		public bool RemoveWaitCount(int count = 1)
		{
			_waitingCount -= count;
			if (_waitingCount == 0 && _finishedCallback != null)
			{
				Action finishedCallback = _finishedCallback;
				_finishedCallback = null;
				finishedCallback();
			}
			return _waitingCount == 0;
		}

		public bool WaitAll()
		{
			return --_waitingCount == 0;
		}

		public void WaitAll(Action callback)
		{
			if (WaitAll())
			{
				callback?.Invoke();
			}
			else
			{
				_finishedCallback = callback;
			}
		}
	}
	public class MsgEventHub
	{
		public enum EventType
		{
			NativeInvoke
		}

		private static AndroidJavaClass _MsgEventHubClass;

		private static AndroidJavaClass _UnityBridgeEventItemClass;

		private static IntPtr _EventItem_Field_eventType;

		private static IntPtr _EventItem_Field_param1;

		private static IntPtr _EventItem_Field_param2;

		public static void SentEventToApp(EventType eventType, string param1, string param2)
		{
			Android_SentEventToApp(eventType, param1, param2);
		}

		public static bool ReadAndDispatchMsgEvents()
		{
			return Android_ReadAndDispatchMsgEvents();
		}

		private static void DispatchMsgEvent(EventType eventType, string param1, string param2)
		{
			if (eventType == EventType.NativeInvoke)
			{
				SdkClient.HandleSdkInvoke(param1);
			}
		}

		public static void Android_SentEventToApp(EventType eventType, string param1, string param2)
		{
			if (CheckGetMsgEventHubClass())
			{
				_MsgEventHubClass.CallStatic("onEvent", (int)eventType, param1, param2);
			}
		}

		public static bool Android_ReadAndDispatchMsgEvents()
		{
			bool result = false;
			if (CheckGetMsgEventHubClass())
			{
				AndroidJavaObject androidJavaObject = _MsgEventHubClass.CallStatic<AndroidJavaObject>("ReadEvents", Array.Empty<object>());
				if (androidJavaObject != null)
				{
					IntPtr rawObject = androidJavaObject.GetRawObject();
					int arrayLength = AndroidJNI.GetArrayLength(rawObject);
					if (arrayLength > 0)
					{
						result = true;
						for (int i = 0; i < arrayLength; i++)
						{
							IntPtr objectArrayElement = AndroidJNI.GetObjectArrayElement(rawObject, i);
							EventType intField = (EventType)AndroidJNI.GetIntField(objectArrayElement, _EventItem_Field_eventType);
							string stringField = AndroidJNI.GetStringField(objectArrayElement, _EventItem_Field_param1);
							string stringField2 = AndroidJNI.GetStringField(objectArrayElement, _EventItem_Field_param2);
							DispatchMsgEvent(intField, stringField, stringField2);
						}
					}
					androidJavaObject.Dispose();
				}
			}
			return result;
		}

		private static bool CheckGetMsgEventHubClass()
		{
			if (_UnityBridgeEventItemClass == null)
			{
				_UnityBridgeEventItemClass = new AndroidJavaClass("com.pvr.avatarsdk.communication.base.MsgEvent");
				_EventItem_Field_eventType = AndroidJNIHelper.GetFieldID(_UnityBridgeEventItemClass.GetRawClass(), "eventType");
				_EventItem_Field_param1 = AndroidJNIHelper.GetFieldID(_UnityBridgeEventItemClass.GetRawClass(), "param1");
				_EventItem_Field_param2 = AndroidJNIHelper.GetFieldID(_UnityBridgeEventItemClass.GetRawClass(), "param2");
			}
			if (_MsgEventHubClass == null)
			{
				_MsgEventHubClass = new AndroidJavaClass("com.pvr.avatarsdk.communication.base.MsgEventHub");
			}
			return true;
		}
	}
	public class SdkClient
	{
		private static Dictionary<string, ConstructorInfo> _SDKInvokeTraits = new Dictionary<string, ConstructorInfo>();

		private static Dictionary<int, SdkCallBase> _WaitingCalls = new Dictionary<int, SdkCallBase>();

		private static int _LastInstanceId = -1;

		public static void HandleSdkInvoke(string invokeData)
		{
			Dictionary<string, object> dictionary = (Dictionary<string, object>)Json.Deserialize(invokeData);
			Dictionary<string, object> body = (Dictionary<string, object>)dictionary["body"];
			int @int = MiniJSONUtil.GetInt(dictionary, "instanceId");
			if (@int < 0)
			{
				SdkCallBase value = null;
				if (_WaitingCalls.TryGetValue(@int, out value))
				{
					_WaitingCalls.Remove(@int);
					value.HandleInvoke(body);
				}
				return;
			}
			string @string = MiniJSONUtil.GetString(dictionary, "type");
			string string2 = MiniJSONUtil.GetString(dictionary, "method");
			string key = @string + "+" + string2;
			ConstructorInfo value2 = null;
			if (_SDKInvokeTraits.TryGetValue(key, out value2))
			{
				SdkCallBase obj = (SdkCallBase)value2.Invoke(null);
				obj.instanceId = MiniJSONUtil.GetInt(dictionary, "instanceId");
				obj.HandleInvoke(body);
			}
			else
			{
				UnityEngine.Debug.LogError($"c# Not supported NativeInvoe. type:{@string} method:{string2}");
			}
		}

		public static void InvokePeer(SdkCallBase sdkCallBase)
		{
			if (sdkCallBase.instanceId == 0)
			{
				sdkCallBase.instanceId = --_LastInstanceId;
				if (sdkCallBase.needReturn)
				{
					_WaitingCalls.Add(sdkCallBase.instanceId, sdkCallBase);
				}
			}
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary["type"] = sdkCallBase.typeName;
			dictionary["method"] = sdkCallBase.methodName;
			dictionary["instanceId"] = sdkCallBase.instanceId;
			dictionary["body"] = sdkCallBase.BuildInvokeBody();
			MsgEventHub.SentEventToApp(MsgEventHub.EventType.NativeInvoke, Json.Serialize(dictionary), null);
		}

		public static void RegisterSDKInvoke(SdkCallBase sdkCallBase)
		{
			string key = sdkCallBase.typeName + "+" + sdkCallBase.methodName;
			_SDKInvokeTraits.Add(key, sdkCallBase.GetType().GetConstructor(new Type[0]));
		}
	}
	public class AvatarDataEntityBase : NativeObject
	{
	}
	[Preserve]
	public class RawMeshDataEntity : AvatarDataEntityBase
	{
		public struct AvatarBoneWeight
		{
			public int boneIndex0;

			public int boneIndex1;

			public int boneIndex2;

			public int boneIndex3;

			public float weight0;

			public float weight1;

			public float weight2;

			public float weight3;

			public void CopyFrom(AvatarBoneWeight other)
			{
				boneIndex0 = other.boneIndex0;
				boneIndex1 = other.boneIndex1;
				boneIndex2 = other.boneIndex2;
				boneIndex3 = other.boneIndex3;
				weight0 = other.weight0;
				weight1 = other.weight1;
				weight2 = other.weight2;
				weight3 = other.weight3;
			}

			public void Set(int index, int bone, float weight)
			{
				switch (index)
				{
				case 0:
					boneIndex0 = bone;
					weight0 = weight;
					break;
				case 1:
					boneIndex1 = bone;
					weight1 = weight;
					break;
				case 2:
					boneIndex2 = bone;
					weight2 = weight;
					break;
				case 3:
					boneIndex3 = bone;
					weight3 = weight;
					break;
				default:
					throw new NotImplementedException();
				}
			}

			public float GetWeight(int index)
			{
				return index switch
				{
					0 => weight0, 
					1 => weight1, 
					2 => weight2, 
					3 => weight3, 
					_ => throw new NotImplementedException(), 
				};
			}

			public int GetBoneIndex(int index)
			{
				return index switch
				{
					0 => boneIndex0, 
					1 => boneIndex1, 
					2 => boneIndex2, 
					3 => boneIndex3, 
					_ => throw new NotImplementedException(), 
				};
			}

			public void SetBoneIndex(int index, int boneIndex)
			{
				switch (index)
				{
				case 0:
					boneIndex0 = boneIndex;
					break;
				case 1:
					boneIndex1 = boneIndex;
					break;
				case 2:
					boneIndex2 = boneIndex;
					break;
				case 3:
					boneIndex3 = boneIndex;
					break;
				default:
					throw new NotImplementedException();
				}
			}

			public static implicit operator AvatarBoneWeight(BoneWeight sourceWeight)
			{
				AvatarBoneWeight result = default(AvatarBoneWeight);
				result.boneIndex0 = sourceWeight.boneIndex0;
				result.boneIndex1 = sourceWeight.boneIndex1;
				result.boneIndex2 = sourceWeight.boneIndex2;
				result.boneIndex3 = sourceWeight.boneIndex3;
				result.weight0 = sourceWeight.weight0;
				result.weight1 = sourceWeight.weight1;
				result.weight2 = sourceWeight.weight2;
				result.weight3 = sourceWeight.weight3;
				return result;
			}

			public static implicit operator BoneWeight(AvatarBoneWeight sourceWeight)
			{
				BoneWeight result = default(BoneWeight);
				result.boneIndex0 = sourceWeight.boneIndex0;
				result.boneIndex1 = sourceWeight.boneIndex1;
				result.boneIndex2 = sourceWeight.boneIndex2;
				result.boneIndex3 = sourceWeight.boneIndex3;
				result.weight0 = sourceWeight.weight0;
				result.weight1 = sourceWeight.weight1;
				result.weight2 = sourceWeight.weight2;
				result.weight3 = sourceWeight.weight3;
				return result;
			}

			public static AvatarBoneWeight[] Convert(BoneWeight[] boneWeights)
			{
				if (boneWeights == null)
				{
					return null;
				}
				AvatarBoneWeight[] array = new AvatarBoneWeight[boneWeights.Length];
				for (int i = 0; i < boneWeights.Length; i++)
				{
					array[i] = boneWeights[i];
				}
				return array;
			}

			public static AvatarBoneWeight[] Convert(List<BoneWeight> boneWeights)
			{
				if (boneWeights == null)
				{
					return null;
				}
				AvatarBoneWeight[] array = new AvatarBoneWeight[boneWeights.Count];
				for (int i = 0; i < boneWeights.Count; i++)
				{
					array[i] = boneWeights[i];
				}
				return array;
			}

			public static BoneWeight[] Convert(AvatarBoneWeight[] boneWeights)
			{
				if (boneWeights == null)
				{
					return null;
				}
				BoneWeight[] array = new BoneWeight[boneWeights.Length];
				for (int i = 0; i < boneWeights.Length; i++)
				{
					array[i] = boneWeights[i];
				}
				return array;
			}

			public void Clear()
			{
				boneIndex0 = 0;
				boneIndex1 = 0;
				boneIndex2 = 0;
				boneIndex3 = 0;
				weight0 = 0f;
				weight1 = 0f;
				weight2 = 0f;
				weight3 = 0f;
			}
		}

		private enum FieldIndex : uint
		{
			SpecId,
			Verts,
			Normals,
			Tangents,
			Colors32,
			UVs,
			BindPose,
			BoneWeights,
			BoneNames,
			BoneNameCount,
			Triangles,
			Guid,
			AttributeName,
			AttributeValue,
			RootBoneName,
			TrianglesCount
		}

		public struct SummaryInfo
		{
			public int positionCount;

			public int normalCount;

			public int tangentCount;

			public int colorCount;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			public int[] uvCounts;

			public int boneWeightCount;

			public int bindPoseBoneCount;

			public int boneNameCount;

			public int attributeCount;

			public int subMeshCount;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			public int[] triangleCount;
		}

		public bool forceCached;

		public SummaryInfo subtractInfo;

		private string _specId;

		private string _guid;

		private Vector3[] _vertices;

		private Vector3[] _normals;

		private Vector4[] _tangents;

		private Color32[] _colors32;

		private Vector2[][] _uvs;

		private int[][] _triangles;

		private Matrix4x4[] _bindPoses;

		private AvatarBoneWeight[] _boneWeights;

		private string[] _boneNames;

		private string _rootBoneName;

		private const string PavDLLName = "effect";

		public string specId
		{
			get
			{
				return CheckGetShortStringField(ref _specId, FieldIndex.SpecId);
			}
			set
			{
				pav_RawMeshDataEntity_SetStringFieldData(base.nativeHandle, 0u, 0u, value);
			}
		}

		public string guid
		{
			get
			{
				return CheckGetShortStringField(ref _guid, FieldIndex.Guid);
			}
			set
			{
				_guid = value;
				pav_RawMeshDataEntity_SetStringFieldData(base.nativeHandle, 11u, 0u, value);
			}
		}

		public Vector3[] vertices
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _vertices, FieldIndex.Verts, 0u, (uint)subtractInfo.positionCount);
			}
			set
			{
				subtractInfo.positionCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _vertices, FieldIndex.Verts, 0u, value);
			}
		}

		public Vector3[] normals
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _normals, FieldIndex.Normals, 0u, (uint)subtractInfo.normalCount);
			}
			set
			{
				subtractInfo.normalCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _normals, FieldIndex.Normals, 0u, value);
			}
		}

		public Vector4[] tangents
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _tangents, FieldIndex.Tangents, 0u, (uint)subtractInfo.tangentCount);
			}
			set
			{
				subtractInfo.tangentCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _tangents, FieldIndex.Tangents, 0u, value);
			}
		}

		public Color32[] colors32
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _colors32, FieldIndex.Colors32, 0u, (uint)subtractInfo.colorCount);
			}
			set
			{
				subtractInfo.colorCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _colors32, FieldIndex.Colors32, 0u, value);
			}
		}

		public Vector2[][] uv
		{
			get
			{
				if (_uvs != null)
				{
					return _uvs;
				}
				_uvs = new Vector2[8][];
				for (int i = 0; i < 8; i++)
				{
					GetPrimitiveFieldAsArray(ref _uvs[i], FieldIndex.UVs, (uint)i, (uint)subtractInfo.uvCounts[i]);
				}
				return _uvs;
			}
			set
			{
				_uvs = value;
				if (value != null && value.Length == 8)
				{
					_ = value?.Length;
					subtractInfo.uvCounts = new int[8];
					for (int i = 0; i < 8; i++)
					{
						subtractInfo.uvCounts[i] = value[i].Length;
						SetPrimitiveFieldAsArray(ref _uvs[i], FieldIndex.UVs, (uint)i, value[i]);
					}
				}
			}
		}

		public int[][] trianglesGroup
		{
			get
			{
				if (_triangles != null)
				{
					return _triangles;
				}
				_triangles = new int[subtractInfo.subMeshCount][];
				for (int i = 0; i < subtractInfo.subMeshCount; i++)
				{
					GetPrimitiveFieldAsArray(ref _triangles[i], FieldIndex.Triangles, (uint)i, (uint)subtractInfo.triangleCount[i]);
				}
				return _triangles;
			}
			set
			{
				_triangles = value;
				int num = ((value != null) ? value.Length : 0);
				subtractInfo.subMeshCount = num;
				subtractInfo.triangleCount = new int[num];
				pav_RawMeshDataEntity_SetIntegerFieldData(base.nativeHandle, 15u, 0u, num);
				for (int i = 0; i < num; i++)
				{
					if (value.Length > i)
					{
						subtractInfo.triangleCount[i] = value[i].Length;
						SetPrimitiveFieldAsArray(ref _triangles[i], FieldIndex.Triangles, (uint)i, value[i]);
					}
					else if (subtractInfo.triangleCount[i] != 0)
					{
						subtractInfo.triangleCount[i] = 0;
						SetPrimitiveFieldAsArray(ref _triangles[i], FieldIndex.Triangles, (uint)i, new int[0]);
					}
				}
			}
		}

		public Matrix4x4[] bindPoses
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _bindPoses, FieldIndex.BindPose, 0u, (uint)subtractInfo.bindPoseBoneCount);
			}
			set
			{
				subtractInfo.bindPoseBoneCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _bindPoses, FieldIndex.BindPose, 0u, value);
			}
		}

		public AvatarBoneWeight[] boneWeights
		{
			get
			{
				return GetPrimitiveFieldAsArray(ref _boneWeights, FieldIndex.BoneWeights, 0u, (uint)subtractInfo.boneWeightCount);
			}
			set
			{
				subtractInfo.boneWeightCount = ((value != null) ? value.Length : 0);
				SetPrimitiveFieldAsArray(ref _boneWeights, FieldIndex.BoneWeights, 0u, value);
			}
		}

		public string[] boneNames
		{
			get
			{
				if (_boneNames == null)
				{
					GetStringFieldAsArray(ref _boneNames, FieldIndex.BoneNames, FieldIndex.BoneNameCount);
				}
				return _boneNames;
			}
			set
			{
				subtractInfo.boneNameCount = ((value != null) ? value.Length : 0);
				SetStringFieldAsArray(ref _boneNames, FieldIndex.BoneNames, FieldIndex.BoneNameCount, value);
			}
		}

		public string rootBoneName
		{
			get
			{
				return CheckGetShortStringField(ref _rootBoneName, FieldIndex.RootBoneName);
			}
			set
			{
				pav_RawMeshDataEntity_SetStringFieldData(base.nativeHandle, 14u, 0u, value);
			}
		}

		public void CreateSummaryInfo(Mesh mesh, SkinnedMeshRenderer skinRenderer = null)
		{
			subtractInfo = default(SummaryInfo);
			Vector3[] array = mesh.vertices;
			Vector3[] array2 = mesh.normals;
			Vector4[] array3 = mesh.tangents;
			Color32[] array4 = mesh.colors32;
			Vector2[] array5 = mesh.uv;
			Vector2[] uv = mesh.uv2;
			Vector2[] uv2 = mesh.uv3;
			Vector2[] uv3 = mesh.uv4;
			Vector2[] uv4 = mesh.uv5;
			Vector2[] uv5 = mesh.uv6;
			Vector2[] uv6 = mesh.uv7;
			Vector2[] uv7 = mesh.uv8;
			subtractInfo.positionCount = ((array != null) ? array.Length : 0);
			subtractInfo.normalCount = ((array2 != null) ? array2.Length : 0);
			subtractInfo.tangentCount = ((array3 != null) ? array3.Length : 0);
			subtractInfo.colorCount = ((array4 != null) ? array4.Length : 0);
			subtractInfo.uvCounts[0] = ((array5 != null) ? array5.Length : 0);
			subtractInfo.uvCounts[1] = ((uv != null) ? uv.Length : 0);
			subtractInfo.uvCounts[2] = ((uv2 != null) ? uv2.Length : 0);
			subtractInfo.uvCounts[3] = ((uv3 != null) ? uv3.Length : 0);
			subtractInfo.uvCounts[4] = ((uv4 != null) ? uv4.Length : 0);
			subtractInfo.uvCounts[5] = ((uv5 != null) ? uv5.Length : 0);
			subtractInfo.uvCounts[6] = ((uv6 != null) ? uv6.Length : 0);
			subtractInfo.uvCounts[7] = ((uv7 != null) ? uv7.Length : 0);
			BoneWeight[] array6 = mesh.boneWeights;
			Matrix4x4[] bindposes = mesh.bindposes;
			subtractInfo.boneWeightCount = ((array6 != null) ? array6.Length : 0);
			subtractInfo.bindPoseBoneCount = ((bindposes != null) ? bindposes.Length : 0);
			subtractInfo.boneNameCount = subtractInfo.bindPoseBoneCount;
			subtractInfo.triangleCount = new int[mesh.subMeshCount];
			for (int i = 0; i < mesh.subMeshCount; i++)
			{
				int[] indices = mesh.GetIndices(i);
				subtractInfo.triangleCount[i] = ((indices != null) ? indices.Length : 0);
			}
			subtractInfo.subMeshCount = mesh.subMeshCount;
		}

		[Preserve]
		public RawMeshDataEntity()
		{
			SetNativeHandle(pav_RawMeshDataEntity_New(), needRetain: false);
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("RawMeshDataEntity.New");
			}
		}

		[Preserve]
		public RawMeshDataEntity(IntPtr nativeHandle, bool needRetain = false)
		{
			SetNativeHandle(nativeHandle, needRetain);
			if (nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("RawMeshDataEntity.New");
			}
			UpdateSummaryInfo();
		}

		~RawMeshDataEntity()
		{
		}

		[Preserve]
		protected override void OnDestroy()
		{
			base.OnDestroy();
		}

		[Preserve]
		public override void OnPostLoad()
		{
			UpdateSummaryInfo();
		}

		public RawMeshDataEntity Clone()
		{
			return new RawMeshDataEntity(pav_RawMeshDataEntity_Clone(base.nativeHandle));
		}

		public void UpdateSummaryInfo()
		{
			pav_RawMeshDataEntity_GetSummaryInfo(base.nativeHandle, ref subtractInfo);
		}

		public void Update(bool updateSubtractInfo = false)
		{
			if (updateSubtractInfo)
			{
				UpdateSummaryInfo();
			}
			if (forceCached)
			{
				return;
			}
			_vertices = null;
			_normals = null;
			_tangents = null;
			_colors32 = null;
			if (_uvs != null)
			{
				for (int i = 0; i < 8; i++)
				{
					_uvs[i] = null;
				}
				_uvs = null;
			}
			_triangles = null;
			_bindPoses = null;
			_boneNames = null;
		}

		public Mesh SetToUnityMesh(SkinnedMeshRenderer skinMeshRenderer, Dictionary<string, Transform> boneMap, List<int[]> triangles = null)
		{
			int num = 0;
			int boneNameCount = subtractInfo.boneNameCount;
			if (boneNameCount > 0)
			{
				string[] array = boneNames;
				Transform[] array2 = new Transform[boneNameCount];
				for (int i = 0; i < boneNameCount; i++)
				{
					if (boneMap.TryGetValue(array[i], out var value))
					{
						array2[i] = value;
						num++;
					}
					else
					{
						array2[i] = skinMeshRenderer.transform;
					}
				}
				_ = array.Length;
				if (boneMap.TryGetValue(rootBoneName, out var value2))
				{
					skinMeshRenderer.rootBone = value2;
				}
				else
				{
					skinMeshRenderer.rootBone = array2[0];
				}
				skinMeshRenderer.bones = array2;
			}
			Mesh mesh = skinMeshRenderer.sharedMesh;
			if (mesh == null)
			{
				mesh = new Mesh();
			}
			else if (mesh.vertexCount > 0)
			{
				mesh.Clear(keepVertexLayout: false);
			}
			mesh.vertices = vertices;
			mesh.normals = normals;
			mesh.tangents = tangents;
			mesh.colors32 = colors32;
			if (triangles != null && triangles.Count > 0)
			{
				mesh.subMeshCount = triangles.Count;
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					mesh.SetTriangles(triangles[j], j);
				}
			}
			else
			{
				int[][] array3 = trianglesGroup;
				mesh.subMeshCount = array3.Length;
				for (int k = 0; k < mesh.subMeshCount; k++)
				{
					mesh.SetTriangles(array3[k], k);
				}
			}
			if (subtractInfo.boneNameCount > 0)
			{
				mesh.boneWeights = AvatarBoneWeight.Convert(boneWeights);
				mesh.bindposes = bindPoses;
			}
			Vector2[][] array4 = uv;
			if (array4.Length == 8)
			{
				mesh.uv = array4[0];
				mesh.uv2 = array4[1];
				mesh.uv3 = array4[2];
				mesh.uv4 = array4[3];
				mesh.uv5 = array4[4];
				mesh.uv6 = array4[5];
				mesh.uv7 = array4[6];
				mesh.uv8 = array4[7];
			}
			mesh.RecalculateBounds();
			skinMeshRenderer.sharedMesh = mesh;
			Update();
			return mesh;
		}

		public void SetToUnityStaticMesh(Mesh mesh)
		{
			mesh.Clear();
			mesh.vertices = vertices;
			int[][] array = trianglesGroup;
			mesh.subMeshCount = array.Length;
			for (int i = 0; i < array.Length; i++)
			{
				mesh.SetTriangles(array[i], i);
			}
			mesh.normals = normals;
			mesh.tangents = tangents;
			Vector2[][] array2 = uv;
			if (array2.Length == 8)
			{
				mesh.uv = array2[0];
				mesh.uv2 = array2[1];
				mesh.uv3 = array2[2];
				mesh.uv4 = array2[3];
				mesh.uv5 = array2[4];
				mesh.uv6 = array2[5];
				mesh.uv7 = array2[6];
				mesh.uv8 = array2[7];
			}
			mesh.colors32 = colors32;
			mesh.bindposes = null;
			mesh.boneWeights = null;
			mesh.RecalculateBounds();
			Update();
		}

		public Vector3[] GetVertices(bool forceSync)
		{
			return GetPrimitiveFieldAsArray(ref _vertices, FieldIndex.Verts, 0u, (uint)subtractInfo.positionCount, forceSync);
		}

		private string CheckGetShortStringField(ref string field, FieldIndex fieldIndex, uint subIndex = 0u)
		{
			if (string.IsNullOrEmpty(field))
			{
				int strLen = pav_RawMeshDataEntity_GetStringFieldData(base.nativeHandle, (uint)fieldIndex, subIndex, Utility.sharedStringBuffer.Lock());
				Utility.sharedStringBuffer.Unlock();
				return Utility.sharedStringBuffer.GetANSIString((uint)strLen);
			}
			return field;
		}

		private T[] GetPrimitiveFieldAsArray<T>(ref T[] field, FieldIndex fieldIndex, uint subIndex, uint elementCount, bool forceSync = false)
		{
			if (field != null && field.Length == elementCount && !forceSync)
			{
				return field;
			}
			if (elementCount == 0)
			{
				field = new T[0];
				return null;
			}
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AvatarMeshData found null nativeHandle !");
			}
			if (field == null)
			{
				field = new T[elementCount];
			}
			GCHandle gCHandle = GCHandle.Alloc(field, GCHandleType.Pinned);
			pav_RawMeshDataEntity_GetArrayFieldData(base.nativeHandle, (uint)fieldIndex, subIndex, gCHandle.AddrOfPinnedObject());
			gCHandle.Free();
			return field;
		}

		private void SetPrimitiveFieldAsArray<T>(ref T[] cachedField, FieldIndex fieldIndex, uint subIndex, T[] value)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AvatarMeshData found null nativeHandle !");
			}
			if (value == null || value.Length == 0)
			{
				pav_RawMeshDataEntity_SetArrayFieldData(base.nativeHandle, (uint)fieldIndex, subIndex, IntPtr.Zero, 0u);
				cachedField = null;
				return;
			}
			GCHandle gCHandle = GCHandle.Alloc(value, GCHandleType.Pinned);
			pav_RawMeshDataEntity_SetArrayFieldData(base.nativeHandle, (uint)fieldIndex, subIndex, gCHandle.AddrOfPinnedObject(), (uint)value.Length);
			gCHandle.Free();
			cachedField = ((cachedField == value) ? value : null);
		}

		private string[] GetStringFieldAsArray(ref string[] field, FieldIndex fieldIndex, FieldIndex countFieldIndex, bool forceSync = false)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AvatarMeshData found null nativeHandle !");
			}
			int num = pav_RawMeshDataEntity_GetIntegerFieldData(base.nativeHandle, (uint)countFieldIndex, 0u);
			if (field == null || field.Length != num || forceSync)
			{
				field = new string[num];
			}
			for (int i = 0; i < num; i++)
			{
				CheckGetShortStringField(ref field[i], fieldIndex, (uint)i);
			}
			return field;
		}

		private void SetStringFieldAsArray(ref string[] cachedField, FieldIndex fieldIndex, FieldIndex countFieldIndex, string[] value)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("AvatarMeshData found null nativeHandle !");
			}
			int num = ((value != null) ? value.Length : 0);
			pav_RawMeshDataEntity_SetIntegerFieldData(base.nativeHandle, (uint)countFieldIndex, 0u, 0);
			if (num == 0)
			{
				cachedField = null;
				return;
			}
			for (int i = 0; i < num; i++)
			{
				pav_RawMeshDataEntity_SetStringFieldData(base.nativeHandle, (uint)fieldIndex, (uint)i, value[i]);
			}
			cachedField = value;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_RawMeshDataEntity_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_RawMeshDataEntity_Clone(IntPtr dataHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_RawMeshDataEntity_GetSummaryInfo(IntPtr dataHandle, ref SummaryInfo subtractInfo);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_RawMeshDataEntity_GetArrayFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex, IntPtr fieldData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_RawMeshDataEntity_SetArrayFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex, IntPtr fieldData, uint elementCount);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_RawMeshDataEntity_GetStringFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex, IntPtr charArray);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_RawMeshDataEntity_SetStringFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex, [In][MarshalAs(UnmanagedType.LPStr)] string fieldData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_RawMeshDataEntity_GetIntegerFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_RawMeshDataEntity_SetIntegerFieldData(IntPtr dataHandle, uint fieldIndex, uint subIndex, int fieldData);
	}
	[Serializable]
	[Preserve]
	public class SkeletonDataEntity : AvatarDataEntityBase
	{
		[Serializable]
		public class AvatarBone
		{
			public string boneName;

			public int boneNameHash;

			public int parentBoneNameHash;

			public Vector3 position;

			public Quaternion rotation;

			public Vector3 scale;
		}

		private struct SkeletonBoneLayout
		{
			public IntPtr name;

			public uint nameCharCount;

			public uint boneNameHash;

			public uint parentBoneNameHash;

			public Vector3 position;

			public Quaternion rotation;

			public Vector3 scale;
		}

		private AvatarBone[] _bones;

		private bool _needSyncToNative = true;

		private Dictionary<string, AvatarBone> _boneMap;

		private const string PavDLLName = "effect";

		public int boneCount
		{
			get
			{
				if (base.nativeHandle == IntPtr.Zero)
				{
					throw new Exception("AvatarSkeletonData.bones wrong for null _NativeHandle!");
				}
				return (int)pav_SkeletonDataEntity_GetBoneLength(base.nativeHandle);
			}
		}

		public AvatarBone[] bones
		{
			get
			{
				if (_bones != null)
				{
					return _bones;
				}
				if (base.nativeHandle == IntPtr.Zero)
				{
					throw new Exception("AvatarSkeletonData.bones wrong for null _NativeHandle!");
				}
				uint num = pav_SkeletonDataEntity_GetBoneLength(base.nativeHandle);
				_bones = new AvatarBone[num];
				for (int i = 0; i < num; i++)
				{
					SkeletonBoneLayout boneData = default(SkeletonBoneLayout);
					boneData.name = Utility.sharedStringBuffer.Lock();
					boneData.nameCharCount = 128u;
					pav_SkeletonDataEntity_GetBone(base.nativeHandle, (uint)i, ref boneData);
					Utility.sharedStringBuffer.Unlock();
					AvatarBone avatarBone = new AvatarBone();
					avatarBone.boneName = Utility.sharedStringBuffer.GetANSIString(boneData.nameCharCount);
					avatarBone.boneNameHash = (int)boneData.boneNameHash;
					avatarBone.parentBoneNameHash = (int)boneData.parentBoneNameHash;
					avatarBone.position = boneData.position;
					avatarBone.rotation = boneData.rotation;
					avatarBone.scale = boneData.scale;
					_bones[i] = avatarBone;
				}
				return _bones;
			}
			set
			{
				_bones = value;
				if (_needSyncToNative)
				{
					int num = ((_bones != null) ? _bones.Length : 0);
					pav_SkeletonDataEntity_SetBoneLength(base.nativeHandle, (uint)num);
					for (int i = 0; i < num; i++)
					{
						GCHandle gCHandle = GCHandle.Alloc(_bones[i].position, GCHandleType.Pinned);
						GCHandle gCHandle2 = GCHandle.Alloc(_bones[i].rotation, GCHandleType.Pinned);
						GCHandle gCHandle3 = GCHandle.Alloc(_bones[i].scale, GCHandleType.Pinned);
						pav_SkeletonDataEntity_SetBoneFieldData(base.nativeHandle, (uint)i, _bones[i].boneName, (uint)_bones[i].boneNameHash, (uint)_bones[i].parentBoneNameHash, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject(), gCHandle3.AddrOfPinnedObject());
						gCHandle.Free();
						gCHandle2.Free();
						gCHandle3.Free();
					}
				}
			}
		}

		public bool needSyncToNative
		{
			get
			{
				return _needSyncToNative;
			}
			set
			{
				_needSyncToNative = value;
			}
		}

		public Dictionary<string, AvatarBone> bonesMap
		{
			get
			{
				AvatarBone[] array = bones;
				if (_boneMap == null || _boneMap.Count != array.Length)
				{
					_boneMap = new Dictionary<string, AvatarBone>();
					AvatarBone[] array2 = array;
					foreach (AvatarBone avatarBone in array2)
					{
						_boneMap.Add(avatarBone.boneName, avatarBone);
					}
				}
				return _boneMap;
			}
		}

		[Preserve]
		public SkeletonDataEntity()
		{
			SetNativeHandle(pav_SkeletonDataEntity_New(), needRetain: false);
		}

		[Preserve]
		public SkeletonDataEntity(IntPtr _nativeHandle, bool needRetain = false)
		{
			SetNativeHandle(_nativeHandle, needRetain);
		}

		~SkeletonDataEntity()
		{
		}

		[Preserve]
		protected override void OnDestroy()
		{
			base.OnDestroy();
		}

		public void CopySkeleton(Transform rootXForm, string excludeXFormName, Transform directlyRelatedBone = null)
		{
			List<AvatarBone> list = new List<AvatarBone>();
			AddBone(rootXForm, list, excludeXFormName, directlyRelatedBone);
			bones = list.ToArray();
		}

		private void AddBone(Transform xform, List<AvatarBone> boneList, string excludeXFormName, Transform directlyRelatedBone)
		{
			if (!(xform.name == excludeXFormName) && (!(directlyRelatedBone != null) || !(xform != directlyRelatedBone) || UnityHelper.IsChildOf(xform, directlyRelatedBone) || UnityHelper.IsChildOf(directlyRelatedBone, xform)))
			{
				AvatarBone avatarBone = new AvatarBone();
				avatarBone.boneName = xform.name;
				avatarBone.boneNameHash = Animator.StringToHash(avatarBone.boneName);
				avatarBone.parentBoneNameHash = Animator.StringToHash(xform.parent.name);
				avatarBone.position = xform.localPosition;
				avatarBone.rotation = xform.localRotation;
				avatarBone.scale = xform.localScale;
				boneList.Add(avatarBone);
				int childCount = xform.childCount;
				for (int i = 0; i < childCount; i++)
				{
					AddBone(xform.GetChild(i), boneList, excludeXFormName, directlyRelatedBone);
				}
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_SkeletonDataEntity_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_SkeletonDataEntity_GetBone(IntPtr dataHandle, uint boneIndex, ref SkeletonBoneLayout boneData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_SkeletonDataEntity_SetBoneFieldData(IntPtr dataHandle, uint boneIndex, string boneName, uint boneNameHash, uint parentBoneNameHash, IntPtr position, IntPtr rotation, IntPtr scale);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_SkeletonDataEntity_SetBoneLength(IntPtr dataHandle, uint length);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_SkeletonDataEntity_GetBoneLength(IntPtr dataHandle);
	}
	public class DeviceInputReaderBuilder
	{
		public enum InputType
		{
			Editor,
			PicoXR,
			RemotePackage
		}

		public InputType type;

		public string userId;

		public DeviceInputReaderBuilder SetType(InputType type)
		{
			this.type = type;
			return this;
		}

		public DeviceInputReaderBuilder SetUserId(string userId)
		{
			this.userId = userId;
			return this;
		}

		public static IDeviceInputReader CreateFrom(DeviceInputReaderBuilder builder)
		{
			if (builder == null)
			{
				return null;
			}
			IDeviceInputReader deviceInputReader = null;
			switch (builder.type)
			{
			case InputType.PicoXR:
				deviceInputReader = new PXRDeviceInputReader();
				deviceInputReader.InitInputFeatureUsage();
				break;
			case InputType.Editor:
			{
				EditorInputDevice device = EditorInputDevice.GetDevice(builder.userId);
				if (device != null)
				{
					deviceInputReader = new EditorDeviceInputReader
					{
						useEditorTarget = device.useEditorTarget,
						transRoot = device.transRoot,
						transHead = device.transHead,
						transLeft = device.transLeft,
						transRight = device.transRight
					};
				}
				break;
			}
			}
			return deviceInputReader;
		}
	}
	public static class DeviceInputReaderBuilderExtra
	{
		public static IDeviceInputReader Build(this DeviceInputReaderBuilder builder)
		{
			return DeviceInputReaderBuilder.CreateFrom(builder);
		}
	}
	public class EditorDeviceInputReader : IDeviceInputReader
	{
		public bool useEditorTarget;

		public Transform transRoot;

		public Transform transHead;

		public Transform transLeft;

		public Transform transRight;

		public override void Initialize(IntPtr nativeHandler_, AvatarEntity owner)
		{
			base.Initialize(nativeHandler_, owner);
			if (!useEditorTarget)
			{
				if (XRRoot != null)
				{
					transRoot = XRRoot;
				}
				if (headTarget != null)
				{
					transHead = headTarget;
				}
				if (leftHandTarget != null)
				{
					transLeft = leftHandTarget;
				}
				if (rightHandTarget != null)
				{
					transRight = rightHandTarget;
				}
			}
		}

		public override void updateDevicePose()
		{
			Matrix4x4 matrix4x = ((transRoot == null) ? Matrix4x4.identity : transRoot.worldToLocalMatrix);
			Quaternion quaternion = ((transRoot == null) ? Quaternion.identity : Quaternion.Inverse(transRoot.rotation));
			if (transHead != null)
			{
				deviceData.positions[0] = matrix4x.MultiplyPoint(transHead.position);
				deviceData.orientations[0] = quaternion * transHead.rotation;
			}
			if (transLeft != null)
			{
				deviceData.positions[1] = matrix4x.MultiplyPoint(transLeft.position);
				deviceData.orientations[1] = quaternion * transLeft.rotation;
			}
			if (transRight != null)
			{
				deviceData.positions[2] = matrix4x.MultiplyPoint(transRight.position);
				deviceData.orientations[2] = quaternion * transRight.rotation;
			}
		}

		public override void updateConnectionStatus()
		{
			connectionStatus[0] = transHead != null && transHead.gameObject.activeInHierarchy;
			connectionStatus[1] = transLeft != null && transLeft.gameObject.activeInHierarchy;
			connectionStatus[2] = transRight != null && transRight.gameObject.activeInHierarchy;
			for (int i = 0; i < 3; i++)
			{
				deviceData.connectionStatus[i] = Convert.ToUInt32(connectionStatus[i]);
			}
		}

		public override void updateButtonStatus()
		{
			if (actionBased && buttonActions != null)
			{
				for (int i = 0; i < 12 && i < buttonActions.Length; i++)
				{
					deviceData.controllerButtonStatus[i] = Convert.ToUInt32(buttonActions[i].action.ReadValue<float>());
				}
			}
		}
	}
	public enum Runtime
	{
		CPU,
		GPU,
		DSP,
		AIP
	}
	public class FTResultReader : NativeObject
	{
		private AndroidJavaObject m_context;

		private AndroidJavaClass m_ftClass;

		public void Internal_Initialize()
		{
			UnityEngine.Debug.Log("Getting FaceTrackor class....");
			m_context = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			m_ftClass = new AndroidJavaClass("com.pico.engine.ft_sdk.FaceTrackor");
			m_ftClass.CallStatic("initialize", m_context, getInferenceType(Runtime.AIP));
			if (m_ftClass != null)
			{
				UnityEngine.Debug.Log("Got FaceTrackor class.");
			}
		}

		public float[] getFrameData()
		{
			float[] array = m_ftClass.CallStatic<float[]>("getResults", Array.Empty<object>());
			for (int i = 0; i < array.Length; i++)
			{
				UnityEngine.Debug.Log("current blendshape[" + i + "]: " + array[i]);
			}
			return array;
		}

		private AndroidJavaObject getInferenceType(Runtime runtime)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.pico.engine.ft_sdk.FaceTrackor$RunTime");
			return runtime switch
			{
				Runtime.CPU => androidJavaClass.GetStatic<AndroidJavaObject>("CPU"), 
				Runtime.GPU => androidJavaClass.GetStatic<AndroidJavaObject>("GPU"), 
				Runtime.DSP => androidJavaClass.GetStatic<AndroidJavaObject>("DSP"), 
				Runtime.AIP => androidJavaClass.GetStatic<AndroidJavaObject>("AIP"), 
				_ => androidJavaClass.GetStatic<AndroidJavaObject>("CPU"), 
			};
		}
	}
	public abstract class IDeviceInputReader : NativeObject
	{
		public enum ControllerButtons
		{
			LPrimary2DButton,
			RPrimary2DButton,
			LMenuButton,
			RMenuButton,
			LGripButton,
			RGripButton,
			LTriggerButton,
			RTriggerButton,
			XButton,
			YButton,
			AButton,
			BButton,
			Count
		}

		public enum DeviceType
		{
			Head,
			LeftHand,
			RightHand,
			Count
		}

		public enum ConnectionStatus
		{
			Disconnected,
			Avaliable,
			Lost,
			Idle,
			Count
		}

		public DeviceData deviceData;

		public bool[] connectionStatus = new bool[4];

		public bool[] controllerButtonStatus = new bool[12];

		public bool actionBased = true;

		public InputActionProperty[] positionActions;

		public InputActionProperty[] rotationActions;

		public InputActionProperty[] buttonActions;

		public Transform XRRoot;

		public Transform headTarget;

		public Transform leftHandTarget;

		public Transform rightHandTarget;

		protected AvatarEntity _owner;

		private const string PavDLLName = "effect";

		public virtual void Initialize(IntPtr nativeHandler_, AvatarEntity owner)
		{
			_owner = owner;
			SetNativeHandle(nativeHandler_, needRetain: false);
			deviceData.connectionStatus = new uint[4];
			deviceData.controllerButtonStatus = new uint[12];
			deviceData.positions = new Vector3[3];
			deviceData.orientations = new Quaternion[3];
		}

		public virtual void InitInputFeatureUsage()
		{
		}

		public void UpdateFrame()
		{
			updateConnectionStatus();
			updateButtonStatus();
			updateDevicePose();
			pav_AvatarDeviceInputReader_SetDeviceInputData(base.nativeHandle, ref deviceData);
		}

		public virtual void StartReadDeviceForNextFrame()
		{
		}

		public abstract void updateButtonStatus();

		public abstract void updateDevicePose();

		public abstract void updateConnectionStatus();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarDeviceInputReader_SetDeviceInputData(IntPtr nativeHandle, ref DeviceData deviceData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarDeviceInputReader_GetDeviceInputData(IntPtr nativeHandle, ref DeviceData deviceData);
	}
	public class PXRDeviceInputReader : XRDeviceInputReader
	{
		public enum DeviceAccessState
		{
			None,
			Reading,
			Ready
		}

		public float unitScale = 1f;

		public PxrControllerTracking pxrControllerTrackingLeft;

		public PxrControllerTracking pxrControllerTrackingRight;

		public float[] headData = new float[7];

		private volatile DeviceAccessState _deviceAccessState;

		public override void InitInputFeatureUsage()
		{
			base.InitInputFeatureUsage();
		}

		public void updateControllerStatus()
		{
			PXR_Plugin.Controller.UPxr_GetControllerTrackingState(0u, 0.0, headData, ref pxrControllerTrackingLeft);
			PXR_Plugin.Controller.UPxr_GetControllerTrackingState(1u, 0.0, headData, ref pxrControllerTrackingRight);
		}

		public override void updateConnectionStatus()
		{
			base.updateConnectionStatus();
			if (_deviceAccessState == DeviceAccessState.Ready)
			{
				uint status = (uint)pxrControllerTrackingLeft.localControllerPose.status;
				uint status2 = (uint)pxrControllerTrackingRight.localControllerPose.status;
				if (deviceData.connectionStatus[1] != 0 && status == 0)
				{
					deviceData.connectionStatus[1] = 3u;
				}
				else
				{
					deviceData.connectionStatus[1] = status;
				}
				if (deviceData.connectionStatus[2] != 0 && status2 == 0)
				{
					deviceData.connectionStatus[2] = 3u;
				}
				else
				{
					deviceData.connectionStatus[2] = status2;
				}
			}
		}

		public override void updateDevicePose()
		{
			base.updateDevicePose();
			for (int i = 0; i < 3; i++)
			{
				deviceData.positions[i] *= unitScale;
			}
		}

		public override void StartReadDeviceForNextFrame()
		{
			if (_deviceAccessState != DeviceAccessState.Reading)
			{
				_deviceAccessState = DeviceAccessState.Reading;
				PicoAvatarApp.instance.StartAsyncCoroutine(AsyncReadDeviceForNextFrame());
			}
		}

		private IEnumerator AsyncReadDeviceForNextFrame()
		{
			updateControllerStatus();
			_deviceAccessState = DeviceAccessState.Ready;
			yield break;
		}
	}
	public abstract class XRDeviceInputReader : IDeviceInputReader
	{
		protected InputFeatureUsage<bool>[] buttonFeature = new InputFeatureUsage<bool>[12];

		protected InputFeatureUsage<Vector3> devicePositionFeature;

		protected InputFeatureUsage<Quaternion> deviceRotationFeature;

		protected InputFeatureUsage<bool> leftControllerStatusFeature;

		protected InputFeatureUsage<bool> rightControllerStatusFeature;

		protected InputFeatureUsage<bool> headControllerStatusFeature;

		protected float yOffset;

		protected Vector3[] deviceOffsets = new Vector3[3];

		protected Quaternion[] deviceRotationOffsets = new Quaternion[3];

		private Dictionary<XRNode, UnityEngine.XR.InputDevice> _xrNodes = new Dictionary<XRNode, UnityEngine.XR.InputDevice>();

		private UnityEngine.XR.InputDevice _leftHandXRDevice;

		private UnityEngine.XR.InputDevice _rightHandXRDevice;

		private UnityEngine.XR.InputDevice _headHandXRDevice;

		public override void InitInputFeatureUsage()
		{
			buttonFeature[0] = UnityEngine.XR.CommonUsages.primary2DAxisClick;
			buttonFeature[2] = UnityEngine.XR.CommonUsages.menuButton;
			buttonFeature[4] = UnityEngine.XR.CommonUsages.gripButton;
			buttonFeature[6] = UnityEngine.XR.CommonUsages.triggerButton;
			buttonFeature[8] = UnityEngine.XR.CommonUsages.primaryButton;
			buttonFeature[9] = UnityEngine.XR.CommonUsages.secondaryButton;
			buttonFeature[1] = UnityEngine.XR.CommonUsages.primary2DAxisClick;
			buttonFeature[3] = UnityEngine.XR.CommonUsages.menuButton;
			buttonFeature[5] = UnityEngine.XR.CommonUsages.gripButton;
			buttonFeature[7] = UnityEngine.XR.CommonUsages.triggerButton;
			buttonFeature[10] = UnityEngine.XR.CommonUsages.primaryButton;
			buttonFeature[11] = UnityEngine.XR.CommonUsages.secondaryButton;
			devicePositionFeature = UnityEngine.XR.CommonUsages.devicePosition;
			deviceRotationFeature = UnityEngine.XR.CommonUsages.deviceRotation;
			headControllerStatusFeature = UnityEngine.XR.CommonUsages.userPresence;
			leftControllerStatusFeature = UnityEngine.XR.CommonUsages.isTracked;
			rightControllerStatusFeature = UnityEngine.XR.CommonUsages.isTracked;
			GameObject gameObject = GameObject.Find("Camera Offset");
			if (gameObject != null)
			{
				yOffset = gameObject.transform.position.y;
			}
			else
			{
				yOffset = 0f;
			}
			deviceOffsets[0] = new Vector3(0f, -0.15f, -0.1f);
			deviceOffsets[1] = new Vector3(0.02f, 0f, 0.08f);
			deviceOffsets[2] = new Vector3(-0.02f, 0f, 0.08f);
			for (int i = 0; i < 3; i++)
			{
				deviceRotationOffsets[i] = new Quaternion(0f, 0f, 0f, 1f);
			}
		}

		public override void updateButtonStatus()
		{
			if (!actionBased)
			{
				ControllerButtons[] buttons = new ControllerButtons[6]
				{
					ControllerButtons.LPrimary2DButton,
					ControllerButtons.LMenuButton,
					ControllerButtons.LGripButton,
					ControllerButtons.LTriggerButton,
					ControllerButtons.XButton,
					ControllerButtons.YButton
				};
				ControllerButtons[] buttons2 = new ControllerButtons[6]
				{
					ControllerButtons.RPrimary2DButton,
					ControllerButtons.RMenuButton,
					ControllerButtons.RGripButton,
					ControllerButtons.RTriggerButton,
					ControllerButtons.AButton,
					ControllerButtons.BButton
				};
				GetButtonState(XRNode.LeftHand, buttons);
				GetButtonState(XRNode.RightHand, buttons2);
				for (int i = 0; i < 12; i++)
				{
					deviceData.controllerButtonStatus[i] = Convert.ToUInt32(controllerButtonStatus[i]);
				}
			}
			else if (buttonActions != null)
			{
				for (int j = 0; j < 12 && j < buttonActions.Length; j++)
				{
					deviceData.controllerButtonStatus[j] = Convert.ToUInt32(buttonActions[j].action.ReadValue<float>());
				}
			}
		}

		protected void GetButtonState(XRNode node, params ControllerButtons[] buttons)
		{
			if (buttons != null)
			{
				UnityEngine.XR.InputDevice xRInputDevice = GetXRInputDevice(node);
				for (int i = 0; i < buttons.Length; i++)
				{
					xRInputDevice.TryGetFeatureValue(buttonFeature[(int)buttons[i]], out controllerButtonStatus[(int)buttons[i]]);
				}
			}
		}

		public override void updateDevicePose()
		{
			if (!(_owner == null) && _owner.bodyAnimController != null)
			{
				if (_owner.bodyAnimController.offsetDirty)
				{
					deviceOffsets[0] = _owner.bodyAnimController.eyeOffset;
					deviceOffsets[1] = _owner.bodyAnimController.leftHandPositionOffset;
					deviceOffsets[2] = _owner.bodyAnimController.rightHandPositionOffset;
					deviceRotationOffsets[1] = Quaternion.Inverse(_owner.bodyAnimController.leftHandRotationOffset);
					deviceRotationOffsets[2] = Quaternion.Inverse(_owner.bodyAnimController.rightHandRotationOffset);
					_owner.bodyAnimController.offsetDirty = false;
				}
				Matrix4x4 matrix4x = ((XRRoot == null) ? Matrix4x4.identity : XRRoot.worldToLocalMatrix);
				Quaternion quaternion = ((XRRoot == null) ? Quaternion.identity : Quaternion.Inverse(XRRoot.rotation));
				if (headTarget != null)
				{
					deviceData.positions[0] = matrix4x.MultiplyPoint(headTarget.position);
					deviceData.orientations[0] = quaternion * headTarget.rotation;
				}
				else
				{
					GetHeadXRDevice().TryGetFeatureValue(devicePositionFeature, out deviceData.positions[0]);
					GetHeadXRDevice().TryGetFeatureValue(deviceRotationFeature, out deviceData.orientations[0]);
				}
				if (leftHandTarget != null)
				{
					deviceData.positions[1] = matrix4x.MultiplyPoint(leftHandTarget.position);
					deviceData.orientations[1] = quaternion * leftHandTarget.rotation;
				}
				else
				{
					GetLeftHandXRDevice().TryGetFeatureValue(devicePositionFeature, out deviceData.positions[1]);
					GetLeftHandXRDevice().TryGetFeatureValue(deviceRotationFeature, out deviceData.orientations[1]);
				}
				if (rightHandTarget != null)
				{
					deviceData.positions[2] = matrix4x.MultiplyPoint(rightHandTarget.position);
					deviceData.orientations[2] = quaternion * rightHandTarget.rotation;
				}
				else
				{
					GetRightHandXRDevice().TryGetFeatureValue(devicePositionFeature, out deviceData.positions[2]);
					GetRightHandXRDevice().TryGetFeatureValue(deviceRotationFeature, out deviceData.orientations[2]);
				}
				for (int i = 0; i < 3; i++)
				{
					deviceData.orientations[i] = deviceData.orientations[i] * deviceRotationOffsets[i];
					Vector3 vector = deviceData.orientations[i] * deviceOffsets[i];
					deviceData.positions[i] -= vector;
				}
			}
		}

		public override void updateConnectionStatus()
		{
			GetLeftHandXRDevice().TryGetFeatureValue(leftControllerStatusFeature, out connectionStatus[1]);
			GetRightHandXRDevice().TryGetFeatureValue(rightControllerStatusFeature, out connectionStatus[2]);
			GetHeadXRDevice().TryGetFeatureValue(headControllerStatusFeature, out connectionStatus[0]);
			for (int i = 0; i < 3; i++)
			{
				deviceData.connectionStatus[i] = (connectionStatus[i] ? 1u : 0u);
			}
		}

		private UnityEngine.XR.InputDevice GetXRInputDevice(XRNode xnode)
		{
			if (_xrNodes.TryGetValue(xnode, out var value))
			{
				if (value.isValid)
				{
					return value;
				}
				_xrNodes.Remove(xnode);
			}
			value = InputDevices.GetDeviceAtXRNode(xnode);
			if (value.isValid)
			{
				_xrNodes.Add(xnode, value);
			}
			return value;
		}

		private UnityEngine.XR.InputDevice GetLeftHandXRDevice()
		{
			if (_leftHandXRDevice.isValid)
			{
				return _leftHandXRDevice;
			}
			_leftHandXRDevice = GetXRInputDevice(XRNode.LeftHand);
			return _leftHandXRDevice;
		}

		private UnityEngine.XR.InputDevice GetRightHandXRDevice()
		{
			if (_rightHandXRDevice.isValid)
			{
				return _rightHandXRDevice;
			}
			_rightHandXRDevice = GetXRInputDevice(XRNode.RightHand);
			return _rightHandXRDevice;
		}

		private UnityEngine.XR.InputDevice GetHeadXRDevice()
		{
			if (_headHandXRDevice.isValid)
			{
				return _headHandXRDevice;
			}
			_headHandXRDevice = GetXRInputDevice(XRNode.Head);
			return _headHandXRDevice;
		}
	}
	public class PicoAvatarAutoFitTrigger : MonoBehaviour
	{
		private Action triggerCall;

		private bool isOnFocus = true;

		private void OnApplicationFocus(bool focus)
		{
			UnityEngine.Debug.Log("pav:OnApplicationFocus:" + focus);
			if (!isOnFocus && focus)
			{
				TriggerAutoFit();
			}
			isOnFocus = focus;
		}

		private void OnApplicationPause(bool pause)
		{
			UnityEngine.Debug.Log("pav:OnApplicationPause:" + pause);
		}

		public void SetTriggerCallback(Action triggerCall = null)
		{
			this.triggerCall = triggerCall;
		}

		private void TriggerAutoFit()
		{
			if (triggerCall != null)
			{
				triggerCall();
			}
		}
	}
	public class PicoAvatarSceneLightEnvGroup : MonoBehaviour
	{
		public PicoAvatarSceneLightEnv[] sceneLightEnvsPrefabs;

		private GameObject _curSceneGO;

		private void OnDestroy()
		{
			if (_curSceneGO != null)
			{
				UnityEngine.Object.Destroy(_curSceneGO);
				_curSceneGO = null;
			}
		}

		public void SwitchScene(string sceneName)
		{
			if (sceneLightEnvsPrefabs == null)
			{
				return;
			}
			PicoAvatarSceneLightEnv picoAvatarSceneLightEnv = null;
			PicoAvatarSceneLightEnv[] array = sceneLightEnvsPrefabs;
			foreach (PicoAvatarSceneLightEnv picoAvatarSceneLightEnv2 in array)
			{
				if (picoAvatarSceneLightEnv2.sceneName == sceneName)
				{
					picoAvatarSceneLightEnv = picoAvatarSceneLightEnv2;
					break;
				}
			}
			if (_curSceneGO != null)
			{
				UnityEngine.Object.Destroy(_curSceneGO);
				_curSceneGO = null;
			}
			if (picoAvatarSceneLightEnv != null)
			{
				_curSceneGO = UnityEngine.Object.Instantiate(picoAvatarSceneLightEnv.gameObject);
				PicoAvatarSceneLightEnv componentInChildren = _curSceneGO.GetComponentInChildren<PicoAvatarSceneLightEnv>(includeInactive: true);
				if (componentInChildren != null)
				{
					componentInChildren.Apply();
				}
			}
		}
	}
	[Serializable]
	public class AvatarCapabilities
	{
		public AvatarManifestationType manifestationType = AvatarManifestationType.Full;

		public uint viewType = 1u;

		public bool bodyCulling = true;

		public bool isLocalAvatar;

		public bool useFaceTrackor;

		public bool enablePlaceHolder;

		public AvatarLodLevel maxLodLevel;

		public SnapshotLevel snapshotLevel = SnapshotLevel.Invalid;

		public uint defaultAvatarGender = 1u;

		public bool autoStopAnimating = true;

		public ControlSourceType controlSourceType = ControlSourceType.RemoteServer;

		public AvatarIKMode ikMode = AvatarIKMode.FullBody;

		public uint animationFlags;

		public bool avatarEditMode;

		public string ToJson()
		{
			if (isLocalAvatar)
			{
				controlSourceType = ControlSourceType.LocalUser;
			}
			if (snapshotLevel == SnapshotLevel.Invalid)
			{
				snapshotLevel = ((PicoAvatarApp.instance == null) ? SnapshotLevel.FullBone : PicoAvatarApp.instance.defaultPlaybackLevel);
			}
			return Json.Serialize(new Dictionary<string, object>
			{
				{
					"manifestationType",
					(int)manifestationType
				},
				{ "viewType", viewType },
				{ "bodyCulling", bodyCulling },
				{ "isLocalAvatar", isLocalAvatar },
				{ "useFaceTrackor", useFaceTrackor },
				{ "enablePlaceHolder", enablePlaceHolder },
				{
					"maxLodLevel",
					(int)maxLodLevel
				},
				{
					"snapshotLevel",
					(int)snapshotLevel
				},
				{ "defaultAvatarGender", defaultAvatarGender },
				{ "autoStopAnimating", autoStopAnimating },
				{
					"controlSourceType",
					(int)controlSourceType
				},
				{
					"ikMode",
					(int)ikMode
				},
				{ "animationFlags", animationFlags },
				{ "avatarEditMode", avatarEditMode }
			});
		}
	}
	[Serializable]
	public class AvatarLoadContext
	{
		public long requestId;

		public string userId;

		public string avatarId;

		public string jsonConfig;

		public AvatarCapabilities capabilities;

		private static string _fakeAvatarIdPrefix = "fakeAvatar_";

		private static int _nextFakeAvatarId = 1;

		public AvatarLoadContext()
		{
		}

		public AvatarLoadContext(string userId_, string avatarId_, string jsonConfig_, AvatarCapabilities capabilities_ = null)
		{
			userId = userId_;
			avatarId = avatarId_;
			jsonConfig = jsonConfig_;
			requestId = -1L;
			capabilities = capabilities_ ?? new AvatarCapabilities();
		}

		public static AvatarLoadContext CreateByAvatarId(string userId_, string avatarId_, AvatarCapabilities capabilities_ = null)
		{
			return new AvatarLoadContext(userId_, avatarId_, null, capabilities_);
		}

		public static AvatarLoadContext CreateByJsonConfig(string userId_, string jsonConfig_, AvatarCapabilities capabilities_ = null)
		{
			if (string.IsNullOrEmpty(jsonConfig_))
			{
				throw new ArgumentNullException("jsonConfig_ can not be empty.");
			}
			string avatarId_ = _fakeAvatarIdPrefix + _nextFakeAvatarId++;
			return new AvatarLoadContext(userId_, avatarId_, jsonConfig_, capabilities_);
		}

		public long DoRequest(Action<long, int, string> responsed = null)
		{
			string text = capabilities.ToJson();
			if (!string.IsNullOrEmpty(jsonConfig))
			{
				requestId = LoadAvatarWithJsonSpecRequest.DoRequest(userId, jsonConfig, text, responsed);
			}
			else if (avatarId != null)
			{
				requestId = LoadAvatarRequest.DoRequest(userId, avatarId, text, responsed);
			}
			else
			{
				requestId = -1L;
				responsed?.Invoke(requestId, -1, "");
			}
			return requestId;
		}
	}
	public enum NativeCallTargetType : uint
	{
		Client,
		Script
	}
	public enum NativeCallFlags : uint
	{
		NeedReturn = 1u,
		NoCallArgument = 2u,
		NoReturnArgument = 4u,
		Async = 0x400u,
		NotReuse = 0x800u
	}
	[AttributeUsage(AttributeTargets.Class)]
	public class NativeCallerAttribute : Attribute
	{
		private uint _signatureID;

		public uint flags { get; private set; }

		public string className { get; private set; }

		public string methodName { get; private set; }

		public bool NeedReturn => (flags & 1) != 0;

		public bool NoCallArgument => (flags & 2) != 0;

		public bool NoReturnArgument => (flags & 4) != 0;

		public bool Async => (flags & 0x400) != 0;

		public bool Reuse => (flags & 0x800) == 0;

		public bool NotReuse => (flags & 0x800) != 0;

		public uint signatureID
		{
			get
			{
				if (_signatureID == 0)
				{
					_signatureID = Utility.AddNameToIDNameTable(className + methodName);
				}
				return _signatureID;
			}
		}

		public NativeCallerAttribute(string className, string methodName, uint flags = 0u)
		{
			this.className = className;
			this.methodName = methodName;
			this.flags = flags;
		}
	}
	public class NativeCaller : NativeObject
	{
		[StructLayout(LayoutKind.Sequential, Pack = 8)]
		private struct CreateResult
		{
			public IntPtr nativeInvokePtr;

			public IntPtr invokeArgumentTablePtr;
		}

		private IDParameterTable _callArguments;

		private IDParameterTable _returnParams;

		private Action<IDParameterTable, NativeCaller> _asyncReturnCallback;

		private static Queue<NativeCaller> _asyncCallers = new Queue<NativeCaller>();

		private static Dictionary<IntPtr, NativeCaller> _allCallers = new Dictionary<IntPtr, NativeCaller>();

		private bool _inGlobalTable;

		protected const string PavDLLName = "effect";

		public uint instanceId { get; private set; }

		public bool isAsyncReturned { get; private set; }

		public NativeCallerAttribute attribute { get; private set; }

		public IDParameterTable invokeArgumentTable => _callArguments;

		public IDParameterTable returnArgumentTable => GetReturnParamsTable();

		public NativeCaller(NativeCallerAttribute attribute, uint instanceId)
		{
			this.attribute = attribute;
			this.instanceId = instanceId;
			CheckCreateNative();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.NativeCaller);
			}
		}

		public void DoApply(Action<IDParameterTable, NativeCaller> asyncReturnCallback = null, bool asyncApply = false)
		{
			_asyncReturnCallback = asyncReturnCallback;
			if (!_inGlobalTable && attribute.Async && (attribute.Reuse || attribute.NeedReturn))
			{
				isAsyncReturned = false;
				_inGlobalTable = true;
				Retain();
				_allCallers.Add(base.nativeHandle, this);
			}
			if (asyncApply)
			{
				ApplyAsync();
			}
			else
			{
				ApplyImmidiately();
			}
		}

		public virtual void OnAsyncReturn(IDParameterTable returnParams)
		{
			isAsyncReturned = true;
			if (_asyncReturnCallback != null)
			{
				_asyncReturnCallback(returnParams, this);
			}
		}

		protected override void OnDestroy()
		{
			ReferencedObject.ReleaseField(ref _callArguments);
			ReferencedObject.ReleaseField(ref _returnParams);
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.NativeCaller);
			}
		}

		private void ApplyAsync()
		{
			_asyncCallers.Enqueue(this);
		}

		private void ApplyImmidiately()
		{
			if (pav_NativeCaller_DoApply(base.nativeHandle) != 0 && AvatarEnv.NeedLog(DebugLogMask.GeneralError))
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, $"failed to call DoApply: class:{attribute.className} method:{attribute.methodName} id:{attribute.signatureID}");
			}
		}

		private void CheckCreateNative()
		{
			if (base.nativeHandle != IntPtr.Zero)
			{
				return;
			}
			CreateResult createResult = pav_NativeCaller_Create(1u, attribute.signatureID, attribute.flags, instanceId);
			if (createResult.nativeInvokePtr != IntPtr.Zero)
			{
				if (createResult.invokeArgumentTablePtr != IntPtr.Zero)
				{
					_callArguments = new IDParameterTable(createResult.invokeArgumentTablePtr);
					_callArguments.Retain();
				}
				SetNativeHandle(createResult.nativeInvokePtr, needRetain: false);
			}
		}

		private IDParameterTable GetReturnParamsTable(IntPtr returnParamsPtr)
		{
			if (_returnParams != null)
			{
				NativeObject.ReleaseNative(ref returnParamsPtr);
				return _returnParams;
			}
			_returnParams = new IDParameterTable(returnParamsPtr);
			_returnParams.Retain();
			return _returnParams;
		}

		private IDParameterTable GetReturnParamsTable()
		{
			if (_returnParams != null)
			{
				return _returnParams;
			}
			_returnParams = new IDParameterTable(pav_NativeCaller_GetReturnArgumentTable(base.nativeHandle));
			_returnParams.Retain();
			return _returnParams;
		}

		public static void Internal_ApplyAsyncCalls()
		{
			while (_asyncCallers.Count > 0)
			{
				_asyncCallers.Dequeue()?.ApplyImmidiately();
			}
		}

		public static void Internal_DispatchReturn(IntPtr NativeCallerHandle, IntPtr returnParamsPtr)
		{
			bool flag = true;
			if (_allCallers != null && _allCallers.TryGetValue(NativeCallerHandle, out var value))
			{
				IDParameterTable iDParameterTable = null;
				bool flag2 = false;
				try
				{
					if (AvatarEnv.NeedLog(DebugLogMask.NativeCallTrivial))
					{
						AvatarEnv.Log(DebugLogMask.NativeCallTrivial, $"ProcessReturn class:{value.attribute.className} method:{value.attribute.methodName} id:{value.attribute.signatureID}");
					}
					if (value.attribute.NotReuse)
					{
						value._inGlobalTable = false;
						flag2 = true;
						_allCallers.Remove(NativeCallerHandle);
						iDParameterTable = new IDParameterTable(returnParamsPtr);
					}
					else
					{
						iDParameterTable = value.GetReturnParamsTable(returnParamsPtr);
					}
					iDParameterTable.Retain();
					flag = false;
					value.OnAsyncReturn(iDParameterTable);
				}
				catch (Exception ex)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
					{
						AvatarEnv.Log(DebugLogMask.GeneralError, ex.Message);
					}
				}
				iDParameterTable?.Release();
				if (flag2)
				{
					value.Release();
				}
			}
			else if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "ProcessReturn error: caller with native handle lost.");
			}
			NativeObject.ReleaseNative(ref NativeCallerHandle);
			if (flag && returnParamsPtr != IntPtr.Zero)
			{
				NativeObject.ReleaseNative(ref returnParamsPtr);
			}
		}

		public static void RemoveWaitingCalls()
		{
			if (_allCallers == null || _allCallers.Count == 0)
			{
				return;
			}
			Dictionary<IntPtr, NativeCaller> allCallers = _allCallers;
			_allCallers = new Dictionary<IntPtr, NativeCaller>();
			foreach (KeyValuePair<IntPtr, NativeCaller> item in allCallers)
			{
				try
				{
					item.Value.OnAsyncReturn(null);
				}
				catch (Exception ex)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
					{
						AvatarEnv.Log(DebugLogMask.GeneralError, ex.Message);
					}
				}
				item.Value.Release();
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern CreateResult pav_NativeCaller_Create(uint targetType, uint signatureId, uint flags, uint instanceId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_NativeCaller_DoApply(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_NativeCaller_GetReturnArgumentTable(IntPtr nativeHandle);
	}
	public class NativeCalleeAttribute
	{
		private uint _signatureID;

		private Dictionary<uint, NativeCallProxy> _calleeProxies = new Dictionary<uint, NativeCallProxy>();

		public Type calleeType { get; private set; }

		public string className { get; private set; }

		public string methodName { get; private set; }

		public uint signatureId
		{
			get
			{
				if (_signatureID == 0)
				{
					_signatureID = Utility.AddNameToIDNameTable(className + methodName);
				}
				return _signatureID;
			}
		}

		public NativeCalleeAttribute(Type calleeType, string className, string methodName)
		{
			this.calleeType = calleeType;
			this.className = className;
			this.methodName = methodName;
		}

		public NativeCallee CreateInstance(IntPtr NativeCalleePtr, uint flags)
		{
			NativeCallee obj = (NativeCallee)calleeType.GetConstructor(new Type[0]).Invoke(new object[0]);
			obj.AttachNativeCallee(NativeCalleePtr, flags);
			return obj;
		}

		public void AddInvokeProxy(uint instanceId, NativeCallProxy skeletonObject)
		{
			_calleeProxies.Add(instanceId, skeletonObject);
		}

		public void RemoveInvokeProxy(uint instanceId)
		{
			_calleeProxies.Remove(instanceId);
		}

		public NativeCallProxy GetInvokeProxy(uint instanceId)
		{
			if (_calleeProxies.TryGetValue(instanceId, out var value))
			{
				return value;
			}
			return null;
		}
	}
	public class NativeCallee : NativeObject
	{
		private IDParameterTable _returnArguments;

		private IDParameterTable _callArguments;

		private bool _returned;

		private uint _flags;

		private uint _instanceId;

		private Action<IDParameterTable, NativeCallee> _onCalledCallback;

		protected const string PavDLLName = "effect";

		public uint instanceId => _instanceId;

		public NativeCallee()
		{
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.NativeCallee);
			}
		}

		public virtual void onCalled()
		{
			if (_onCalledCallback != null)
			{
				_onCalledCallback(_callArguments, this);
			}
		}

		public void DoReturn()
		{
			if ((_flags & (true ? 1u : 0u)) != 0 && !_returned)
			{
				_returned = true;
				pav_NativeCallee_DoReturn(base.nativeHandle);
			}
		}

		protected override void OnDestroy()
		{
			if ((_flags & (true ? 1u : 0u)) != 0 && !_returned)
			{
				DoReturn();
			}
			pav_NativeCallee_Destroy(base.nativeHandle);
			ReferencedObject.ReleaseField(ref _returnArguments);
			ReferencedObject.ReleaseField(ref _callArguments);
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.NativeCallee);
			}
		}

		protected IDParameterTable GetReturnArgumentTable()
		{
			if (_returnArguments == null)
			{
				_returnArguments = new IDParameterTable(pav_NativeCallee_GetReturnArgumentTable(base.nativeHandle));
				_returnArguments.Retain();
			}
			return _returnArguments;
		}

		public IDParameterTable SetCallArgumentTable(IntPtr nativeCallArgument)
		{
			if (_callArguments == null)
			{
				_callArguments = new IDParameterTable(nativeCallArgument);
				_callArguments.Retain();
			}
			else
			{
				NativeObject.ReleaseNative(ref nativeCallArgument);
			}
			return _callArguments;
		}

		public void AttachNativeCallee(IntPtr nativeHandle_, uint flags)
		{
			_flags = flags;
			SetNativeHandle(nativeHandle_, needRetain: false);
		}

		public void SetNeedReturn(uint instanceId)
		{
			_returned = false;
		}

		public void SetSkeletonMethod(Action<IDParameterTable, NativeCallee> skeletonCallback)
		{
			_onCalledCallback = skeletonCallback;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_NativeCallee_DoReturn(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_NativeCallee_GetReturnArgumentTable(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_NativeCallee_Destroy(IntPtr nativeHandle);
	}
	public class NativeCallProxy : ReferencedObject
	{
		private uint _instanceId;

		private Dictionary<NativeCalleeAttribute, Action<IDParameterTable, NativeCallee>> _calleeMethods = new Dictionary<NativeCalleeAttribute, Action<IDParameterTable, NativeCallee>>();

		private Dictionary<NativeCalleeAttribute, NativeCallee> _callees = new Dictionary<NativeCalleeAttribute, NativeCallee>();

		private List<NativeCaller> _callers = new List<NativeCaller>();

		public uint instanceId => _instanceId;

		public NativeCallProxy(uint instanceId_)
		{
			_instanceId = instanceId_;
		}

		protected override void OnDestroy()
		{
			foreach (KeyValuePair<NativeCalleeAttribute, Action<IDParameterTable, NativeCallee>> calleeMethod in _calleeMethods)
			{
				calleeMethod.Key.RemoveInvokeProxy(_instanceId);
			}
			_calleeMethods.Clear();
			foreach (KeyValuePair<NativeCalleeAttribute, NativeCallee> callee in _callees)
			{
				callee.Value.Release();
			}
			_callees.Clear();
			foreach (NativeCaller caller in _callers)
			{
				caller.Release();
			}
			_callers.Clear();
			base.OnDestroy();
		}

		protected void AddCalleeMethod(NativeCalleeAttribute invokeeAttribute, Action<IDParameterTable, NativeCallee> methodCallback)
		{
			invokeeAttribute.AddInvokeProxy(_instanceId, this);
			_calleeMethods.Add(invokeeAttribute, methodCallback);
			NativeCallMarshal.RegisterCallee(invokeeAttribute);
		}

		public NativeCallee GetCallee(NativeCalleeAttribute invokeAttribute, IntPtr NativeCalleePtr, IntPtr invokeArgumentsPtr, uint flags, uint instanceId)
		{
			if (_callees.TryGetValue(invokeAttribute, out var value) || !_calleeMethods.TryGetValue(invokeAttribute, out var value2))
			{
				NativeObject.ReleaseNative(ref NativeCalleePtr);
				NativeObject.ReleaseNative(ref invokeArgumentsPtr);
				return value;
			}
			value = invokeAttribute.CreateInstance(NativeCalleePtr, flags);
			value.Retain();
			value.SetSkeletonMethod(value2);
			value.SetCallArgumentTable(invokeArgumentsPtr);
			_callees.Add(invokeAttribute, value);
			return value;
		}

		public NativeCaller AddCallerMethod(NativeCallerAttribute attribute)
		{
			NativeCaller nativeCaller = new NativeCaller(attribute, _instanceId);
			nativeCaller.Retain();
			_callers.Add(nativeCaller);
			return nativeCaller;
		}
	}
	public class NativeCallMarshal
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OnDispatchCallCallback(IntPtr invokeePtr, IntPtr invokeParamsPtr, uint signatureID, uint flags, uint instanceId);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OnDispatchReturnCallback(IntPtr invokerPtr, IntPtr returnParamsPtr);

		private static Dictionary<IntPtr, NativeCallee> _reuseCallees = new Dictionary<IntPtr, NativeCallee>();

		private static Dictionary<ulong, NativeCalleeAttribute> _calleeTypes;

		protected const string PavDLLName = "effect";

		private static void RegisterCallees()
		{
		}

		public static void Initialize()
		{
			if (_calleeTypes == null)
			{
				_calleeTypes = new Dictionary<ulong, NativeCalleeAttribute>();
				RegisterCallees();
				pav_NativeCallMarshal_ClientConnect(OnDispatchCall, OnDispatchReturn);
			}
		}

		public static void Unitialize()
		{
			if (_calleeTypes == null)
			{
				return;
			}
			foreach (KeyValuePair<IntPtr, NativeCallee> reuseCallee in _reuseCallees)
			{
				reuseCallee.Value.Release();
			}
			_reuseCallees.Clear();
			NativeCaller.RemoveWaitingCalls();
			pav_NativeCallMarshal_ClientDisconnect();
			_calleeTypes.Clear();
			_calleeTypes = null;
		}

		public static bool IsInitialized()
		{
			return _calleeTypes != null;
		}

		public static void Update()
		{
			NativeCaller.Internal_ApplyAsyncCalls();
		}

		public static void RegisterCallee(NativeCalleeAttribute invokeeAttribute)
		{
			if (_calleeTypes.TryGetValue(invokeeAttribute.signatureId, out var value))
			{
				if (value != invokeeAttribute)
				{
					throw new Exception("RegisterCallee duplicated attribute with same signature id.");
				}
			}
			else
			{
				_calleeTypes.Add(invokeeAttribute.signatureId, invokeeAttribute);
			}
		}

		[MonoPInvokeCallback(typeof(OnDispatchCallCallback))]
		private static void OnDispatchCall(IntPtr invokeePtr, IntPtr invokeParamsPtr, uint signatureId, uint flags, uint instanceId)
		{
			bool flag = true;
			bool flag2 = true;
			NativeCallee value = null;
			if (_calleeTypes.TryGetValue(signatureId, out var value2))
			{
				if (AvatarEnv.NeedLog(DebugLogMask.NativeCallTrivial))
				{
					AvatarEnv.Log(DebugLogMask.NativeCallTrivial, $"OnDispatchInvoke class: {value2.className} method: {value2.methodName} ");
				}
				try
				{
					if ((flags & 0x800) == 0)
					{
						NativeCallProxy invokeProxy = value2.GetInvokeProxy(instanceId);
						if (invokeProxy != null)
						{
							value = invokeProxy.GetCallee(value2, invokeePtr, invokeParamsPtr, flags, instanceId);
							flag = false;
							flag2 = false;
						}
						else if (_reuseCallees.TryGetValue(invokeePtr, out value) && value.instanceId != instanceId)
						{
							flags |= 0x800u;
							value = null;
						}
					}
					if (value == null)
					{
						value = value2.CreateInstance(invokeePtr, flags);
						value.SetCallArgumentTable(invokeParamsPtr);
						flag = false;
						flag2 = false;
					}
					value.Retain();
					if ((flags & (true ? 1u : 0u)) != 0)
					{
						value.SetNeedReturn(instanceId);
					}
					value.onCalled();
				}
				catch (Exception ex)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
					{
						AvatarEnv.Log(DebugLogMask.GeneralError, "NativeCallMarshal.onCalled New: " + ex.Message);
					}
				}
			}
			else
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("NativeCallMarshal.onCalled with invalid signatureID: ");
				stringBuilder.AppendLine(signatureId.ToString());
				stringBuilder.Append("Types:");
				foreach (KeyValuePair<ulong, NativeCalleeAttribute> calleeType in _calleeTypes)
				{
					stringBuilder.Append("  signatureID: ");
					stringBuilder.Append(calleeType.Key);
					stringBuilder.Append("  name: ");
					stringBuilder.Append(calleeType.Value.className);
					stringBuilder.Append(".");
					stringBuilder.Append(calleeType.Value.methodName);
				}
				AvatarEnv.Log(DebugLogMask.GeneralError, stringBuilder.ToString());
			}
			value?.Release();
			if (flag)
			{
				NativeObject.ReleaseNative(ref invokeePtr);
			}
			if (flag2 && invokeParamsPtr != IntPtr.Zero)
			{
				NativeObject.ReleaseNative(ref invokeParamsPtr);
			}
		}

		[MonoPInvokeCallback(typeof(OnDispatchReturnCallback))]
		private static void OnDispatchReturn(IntPtr invokerPtr, IntPtr returnParamsPtr)
		{
			NativeCaller.Internal_DispatchReturn(invokerPtr, returnParamsPtr);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_NativeCallMarshal_ClientConnect(OnDispatchCallCallback onDispatchInvokeCallback, OnDispatchReturnCallback onDispatchReturnCallback);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_NativeCallMarshal_ClientDisconnect();
	}
	internal class NativeCall_Avatar : NativeCallProxy
	{
		private PicoAvatar _avatar;

		private NativeCaller _method_SetVisible;

		private NativeCaller _method_InitializeEdit;

		private NativeCaller _method_AlignHeight;

		private NativeCaller _method_PlayAnimation;

		private NativeCaller _method_StopAnimation;

		private NativeCaller _method_GetAnimationNames;

		private NativeCaller _method_LoadAnimationsExtern;

		private NativeCaller _method_LoadAnimationsFromAssetBundle;

		private NativeCaller _method_RemoveAnimation;

		private NativeCaller _method_ForceUpdateLod;

		private NativeCaller _method_GetAvatarSpecification;

		private const string className = "Avatar";

		private static NativeCallerAttribute _attribute_SetVisible = new NativeCallerAttribute("Avatar", "SetVisile");

		private static NativeCallerAttribute _attribute_InitializeEdit = new NativeCallerAttribute("Avatar", "InitializeEdit");

		private static NativeCallerAttribute _attribute_AlignHeight = new NativeCallerAttribute("Avatar", "AlignHeight");

		private static NativeCallerAttribute _attribute_PlayAnimation = new NativeCallerAttribute("Avatar", "PlayAnimation");

		private static NativeCallerAttribute _attribute_StopAnimation = new NativeCallerAttribute("Avatar", "StopAnimation");

		private static NativeCallerAttribute _attribute_GetAnimationNames = new NativeCallerAttribute("Avatar", "GetAnimationNames", 3u);

		private static NativeCallerAttribute _attribute_LoadAnimationsExtern = new NativeCallerAttribute("Avatar", "LoadAnimationsExtern");

		private static NativeCallerAttribute _attribute_LoadAnimationsFromAssetBundle = new NativeCallerAttribute("Avatar", "LoadAnimationsFromAssetBundle");

		private static NativeCallerAttribute _attribute_RemoveAnimation = new NativeCallerAttribute("Avatar", "RemoveAnimation");

		private static NativeCallerAttribute _attribute_ForceUpdateLod = new NativeCallerAttribute("Avatar", "ForceUpdateLod");

		private static NativeCallerAttribute _attribute_GetAvatarSpecification = new NativeCallerAttribute("Avatar", "GetAvatarSpecification", 3u);

		private static NativeCalleeAttribute _attribute_OnAvatarEntityLoaded = new NativeCalleeAttribute(typeof(NativeCallee), "Avatar", "OnAvatarEntityLoaded");

		private static NativeCalleeAttribute _attribute_OnAvatarSpecUpdated = new NativeCalleeAttribute(typeof(NativeCallee), "Avatar", "OnAvatarSpecUpdated");

		private static NativeCalleeAttribute _attribute_OnLoadAnimationsExternComplete = new NativeCalleeAttribute(typeof(NativeCallee), "Avatar", "OnLoadAnimationsExternComplete");

		public void InitializeEdit()
		{
			_method_InitializeEdit.DoApply();
		}

		public void SetVisible(bool visible)
		{
			_method_SetVisible.invokeArgumentTable.SetByteParam(0u, (byte)(visible ? 1 : 0));
			_method_SetVisible.DoApply();
		}

		public void SetAvatarHeight(float height)
		{
			_method_AlignHeight.invokeArgumentTable.SetFloatParam(0u, height);
			_method_AlignHeight.DoApply();
		}

		public void PlayAnimation(string name, float loopTime)
		{
			IDParameterTable invokeArgumentTable = _method_PlayAnimation.invokeArgumentTable;
			invokeArgumentTable.SetStringParam(0u, name);
			invokeArgumentTable.SetFloatParam(1u, loopTime);
			_method_PlayAnimation.DoApply();
		}

		public void StopAnimation(bool immediately)
		{
			_method_StopAnimation.invokeArgumentTable.SetBoolParam(0u, immediately);
			_method_StopAnimation.DoApply();
		}

		public string GetAnimationNames()
		{
			_method_GetAnimationNames.DoApply();
			return _method_GetAnimationNames.returnArgumentTable.GetUTF8StringParam(0u);
		}

		public void LoadAnimationsExtern(string assetBundlePath, string animationPathsJson)
		{
			IDParameterTable invokeArgumentTable = _method_LoadAnimationsExtern.invokeArgumentTable;
			invokeArgumentTable.SetStringParam(0u, assetBundlePath);
			invokeArgumentTable.SetStringParam(1u, animationPathsJson);
			_method_LoadAnimationsExtern.DoApply();
		}

		public void LoadAnimationsFromAssetBundle(AvatarAssetBundle ab, string animationPathsJson)
		{
			IDParameterTable invokeArgumentTable = _method_LoadAnimationsFromAssetBundle.invokeArgumentTable;
			invokeArgumentTable.SetObjectParam(0u, ab.nativeHandle);
			invokeArgumentTable.SetStringParam(1u, animationPathsJson);
			_method_LoadAnimationsFromAssetBundle.DoApply();
		}

		public void RemoveAnimation(string name)
		{
			_method_RemoveAnimation.invokeArgumentTable.SetStringParam(0u, name);
			_method_RemoveAnimation.DoApply();
		}

		public void ForceUpdateLod()
		{
			_ = _method_ForceUpdateLod.invokeArgumentTable;
			_method_ForceUpdateLod.DoApply();
		}

		public string GetAvatarSpecification()
		{
			_method_GetAvatarSpecification.DoApply();
			return _method_GetAvatarSpecification.returnArgumentTable.GetStringParam(0u);
		}

		private void OnAvatarSpecUpdated(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			string stringParam = invokeArguments.GetStringParam(0u);
			string stringParam2 = invokeArguments.GetStringParam(1u);
			_avatar.Internal_OnSpecUpdated(stringParam, stringParam2);
		}

		private void OnAvatarEntityLoaded(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 0u;
			uint val2 = 0u;
			uint val3 = 0u;
			invokeArguments.GetUIntParam(0u, ref val);
			invokeArguments.GetUIntParam(1u, ref val2);
			invokeArguments.GetUIntParam(2u, ref val3);
			string stringParam = invokeArguments.GetStringParam(3u);
			if (val != 0)
			{
				_avatar?.Internal_OnAvatarEntityLoaded(val, (AvatarLodLevel)val2, (AvatarSexType)val3, stringParam);
			}
			else
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "Failed to load Avatar.");
			}
		}

		private void OnLoadAnimationsExternComplete(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			string uTF8StringParam = invokeArguments.GetUTF8StringParam(0u);
			string uTF8StringParam2 = invokeArguments.GetUTF8StringParam(1u);
			_avatar.Internal_OnLoadAnimationsExternComplete(uTF8StringParam, uTF8StringParam2);
		}

		public NativeCall_Avatar(PicoAvatar avatar, uint instanceId)
			: base(instanceId)
		{
			_avatar = avatar;
			AddCalleeMethod(_attribute_OnAvatarSpecUpdated, OnAvatarSpecUpdated);
			AddCalleeMethod(_attribute_OnAvatarEntityLoaded, OnAvatarEntityLoaded);
			AddCalleeMethod(_attribute_OnLoadAnimationsExternComplete, OnLoadAnimationsExternComplete);
			_method_InitializeEdit = AddCallerMethod(_attribute_InitializeEdit);
			_method_SetVisible = AddCallerMethod(_attribute_SetVisible);
			_method_AlignHeight = AddCallerMethod(_attribute_AlignHeight);
			_method_PlayAnimation = AddCallerMethod(_attribute_PlayAnimation);
			_method_StopAnimation = AddCallerMethod(_attribute_StopAnimation);
			_method_GetAnimationNames = AddCallerMethod(_attribute_GetAnimationNames);
			_method_LoadAnimationsExtern = AddCallerMethod(_attribute_LoadAnimationsExtern);
			_method_LoadAnimationsFromAssetBundle = AddCallerMethod(_attribute_LoadAnimationsFromAssetBundle);
			_method_RemoveAnimation = AddCallerMethod(_attribute_RemoveAnimation);
			_method_ForceUpdateLod = AddCallerMethod(_attribute_ForceUpdateLod);
			_method_GetAvatarSpecification = AddCallerMethod(_attribute_GetAvatarSpecification);
		}
	}
	public class NetStats
	{
		public uint ping;

		public uint maxBandWidth;

		public uint avgBandWidth;
	}
	internal class NativeCall_AvatarApp : NativeCallProxy
	{
		private PicoAvatarApp _Object;

		private NativeCaller _method_Shutdown;

		private NativeCaller _method_SetBurden;

		private NativeCaller _method_SetDebugConfig;

		private NativeCaller _method_SetDebugLogMasks;

		private NativeCaller _method_GetNetStats;

		private NativeCaller _method_SetTraceNativeCaller;

		private const string className = "AvatarApp";

		private static NativeCallerAttribute _attribute_Shutdown = new NativeCallerAttribute("AvatarApp", "Shutdown");

		private static NativeCallerAttribute _attribute_SetBurden = new NativeCallerAttribute("AvatarApp", "SetBurden");

		private static NativeCallerAttribute _attribute_SetDebugConfig = new NativeCallerAttribute("AvatarApp", "SetDebugConfig");

		private static NativeCallerAttribute _attribute_SetDebugLogMasks = new NativeCallerAttribute("AvatarApp", "SetDebugLogMasks");

		private static NativeCallerAttribute _attribute_GetNetStats = new NativeCallerAttribute("AvatarApp", "GetNetStats", 3u);

		private static NativeCallerAttribute _attribute_SetTraceNativeCaller = new NativeCallerAttribute("AvatarApp", "SetTraceNativeCaller");

		private static NativeCalleeAttribute _attribute_OnError = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarApp", "OnError");

		public void Shutdown(uint reason)
		{
			_method_Shutdown.invokeArgumentTable.SetUIntParam(0u, reason);
			_method_Shutdown.DoApply();
		}

		public void SetBurden(uint burdenLevel)
		{
			_method_SetBurden.invokeArgumentTable.SetUIntParam(0u, burdenLevel);
			_method_SetBurden.DoApply();
		}

		public void SetDebugConfig(string debugConfigText)
		{
			_method_SetDebugConfig.invokeArgumentTable.SetStringParam(0u, debugConfigText);
			_method_SetDebugConfig.DoApply();
		}

		public void SetDebugLogMasks(uint debugLogMasks)
		{
			_method_SetDebugLogMasks.invokeArgumentTable.SetUIntParam(0u, debugLogMasks);
			_method_SetDebugLogMasks.DoApply();
		}

		public NetStats GetNetStats()
		{
			NetStats netStats = new NetStats();
			_method_GetNetStats.DoApply();
			IDParameterTable returnArgumentTable = _method_GetNetStats.returnArgumentTable;
			returnArgumentTable.GetUIntParam(0u, ref netStats.ping);
			returnArgumentTable.GetUIntParam(1u, ref netStats.maxBandWidth);
			returnArgumentTable.GetUIntParam(2u, ref netStats.avgBandWidth);
			return netStats;
		}

		public void SetTraceNativeCaller(bool trace)
		{
			_method_SetTraceNativeCaller.invokeArgumentTable.SetBoolParam(0u, trace);
			_method_SetTraceNativeCaller.DoApply();
		}

		private void OnError(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 0u;
			invokeArguments.GetUIntParam(0u, ref val);
			string stringParam = invokeArguments.GetStringParam(1u);
			if (val != 0 && AvatarEnv.NeedLog(DebugLogMask.GeneralError))
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "OnJSError " + stringParam);
			}
		}

		public NativeCall_AvatarApp(PicoAvatarApp obj, uint instanceId)
			: base(0u)
		{
			_Object = obj;
			AddCalleeMethod(_attribute_OnError, OnError);
			_method_Shutdown = AddCallerMethod(_attribute_Shutdown);
			_method_SetBurden = AddCallerMethod(_attribute_SetBurden);
			_method_SetDebugConfig = AddCallerMethod(_attribute_SetDebugConfig);
			_method_SetDebugLogMasks = AddCallerMethod(_attribute_SetDebugLogMasks);
			_method_GetNetStats = AddCallerMethod(_attribute_GetNetStats);
			_method_SetTraceNativeCaller = AddCallerMethod(_attribute_SetTraceNativeCaller);
		}
	}
	internal class NativeCall_AvatarBodyAnimController : NativeCallProxy
	{
		private AvatarBodyAnimController _avatarBodyAnimController;

		private NativeCaller _method_SetIKEnable;

		private NativeCaller _method_SetMaxControllerDistance;

		private NativeCaller _method_SetUpdateIKTargetFromDevice;

		private NativeCaller _method_SetIKAutoStopModeEnable;

		private NativeCaller _method_SetIKHandInvalidRegionEnable;

		private const string className = "AvatarBodyAnimController";

		private static NativeCallerAttribute _attribute_SetIKEnable = new NativeCallerAttribute("AvatarBodyAnimController", "SetIKEnable");

		private static NativeCallerAttribute _attribute_SetMaxControllerDistance = new NativeCallerAttribute("AvatarBodyAnimController", "SetMaxControllerDistance");

		private static NativeCallerAttribute _attribute_SetUpdateIKTargetFromDevice = new NativeCallerAttribute("AvatarBodyAnimController", "SetUpdateIKTargetFromDevice");

		private static NativeCallerAttribute _attribute_SetIKAutoStopModeEnable = new NativeCallerAttribute("AvatarBodyAnimController", "SetIKAutoStopModeEnable");

		private static NativeCallerAttribute _attribute_SetIKHandInvalidRegionEnable = new NativeCallerAttribute("AvatarBodyAnimController", "SetIKHandInvalidRegionEnable");

		public void SetIKEnable(uint ikEffectorType, bool enable)
		{
			IDParameterTable invokeArgumentTable = _method_SetIKEnable.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, ikEffectorType);
			invokeArgumentTable.SetBoolParam(1u, enable);
			_method_SetIKEnable.DoApply();
		}

		public void SetMaxControllerDistance(float distance)
		{
			_method_SetMaxControllerDistance.invokeArgumentTable.SetFloatParam(0u, distance);
			_method_SetMaxControllerDistance.DoApply();
		}

		public void SetUpdateIKTargetFromDevice(uint ikEffectorType, bool enable)
		{
			IDParameterTable invokeArgumentTable = _method_SetUpdateIKTargetFromDevice.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, ikEffectorType);
			invokeArgumentTable.SetBoolParam(1u, enable);
			_method_SetUpdateIKTargetFromDevice.DoApply();
		}

		public void SetIKAutoStopModeEnable(uint ikAutoStopMode, bool enable)
		{
			IDParameterTable invokeArgumentTable = _method_SetIKAutoStopModeEnable.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, ikAutoStopMode);
			invokeArgumentTable.SetBoolParam(1u, enable);
			_method_SetIKAutoStopModeEnable.DoApply();
		}

		public void SetIKHandInvalidRegionEnable(bool enable)
		{
			_method_SetIKHandInvalidRegionEnable.invokeArgumentTable.SetBoolParam(0u, enable);
			_method_SetIKHandInvalidRegionEnable.DoApply();
		}

		public NativeCall_AvatarBodyAnimController(AvatarBodyAnimController avatarBodyAnimController, uint instanceId)
			: base(instanceId)
		{
			_avatarBodyAnimController = avatarBodyAnimController;
			_method_SetIKEnable = AddCallerMethod(_attribute_SetIKEnable);
			_method_SetMaxControllerDistance = AddCallerMethod(_attribute_SetMaxControllerDistance);
			_method_SetUpdateIKTargetFromDevice = AddCallerMethod(_attribute_SetUpdateIKTargetFromDevice);
			_method_SetIKAutoStopModeEnable = AddCallerMethod(_attribute_SetIKAutoStopModeEnable);
			_method_SetIKHandInvalidRegionEnable = AddCallerMethod(_attribute_SetIKHandInvalidRegionEnable);
		}
	}
	public class NativeCalls_AvatarCamera : NativeCallProxy
	{
		private PicoAvatarCamera _avatarCamera;

		private NativeCaller _method_Move;

		private NativeCaller _method_SetConfig;

		private const string className = "AvatarCamera";

		private static NativeCallerAttribute _attribute_Move = new NativeCallerAttribute("AvatarCamera", "Move");

		private static NativeCallerAttribute _attribute_SetConfig = new NativeCallerAttribute("AvatarCamera", "SetConfig");

		public void Move(Vector3 pos, Quaternion quat)
		{
			IDParameterTable invokeArgumentTable = _method_Move.invokeArgumentTable;
			invokeArgumentTable.SetPointParam(0u, pos);
			invokeArgumentTable.SetQuaternionParam(1u, quat);
			_method_Move.DoApply();
		}

		public void SetConfig(Camera camera)
		{
			if (!(camera == null))
			{
				IDParameterTable invokeArgumentTable = _method_SetConfig.invokeArgumentTable;
				invokeArgumentTable.SetFloatParam(0u, camera.fieldOfView);
				invokeArgumentTable.SetFloatParam(1u, camera.aspect);
				invokeArgumentTable.SetFloatParam(2u, camera.nearClipPlane);
				invokeArgumentTable.SetFloatParam(3u, camera.farClipPlane);
				invokeArgumentTable.SetFloatParam(4u, camera.stereoSeparation);
				invokeArgumentTable.SetPointParam(5u, Vector3.up);
				invokeArgumentTable.SetPointParam(6u, Vector3.left);
				invokeArgumentTable.SetPointParam(7u, Vector3.forward);
				_method_SetConfig.DoApply();
			}
		}

		public NativeCalls_AvatarCamera(PicoAvatarCamera camera, uint instanceId)
			: base(0u)
		{
			_avatarCamera = camera;
			_method_Move = AddCallerMethod(_attribute_Move);
			_method_SetConfig = AddCallerMethod(_attribute_SetConfig);
		}
	}
	internal class NativeCall_AvatarEditState : NativeCallProxy
	{
		private AvatarEditState _Object;

		private NativeCaller _method_EnterState;

		private NativeCaller _method_ExitState;

		private NativeCaller _method_SetShapingParam;

		private NativeCaller _method_GetShapingParam;

		private NativeCaller _method_StartCompare;

		private NativeCaller _method_EndCompare;

		private const string className = "AvatarEditState";

		private static NativeCallerAttribute _attribute_EnterState = new NativeCallerAttribute("AvatarEditState", "EnterState");

		private static NativeCallerAttribute _attribute_ExitState = new NativeCallerAttribute("AvatarEditState", "ExitState");

		private static NativeCallerAttribute _attribute_SetShapingParam = new NativeCallerAttribute("AvatarEditState", "SetShapingParam");

		private static NativeCallerAttribute _attribute_GetShapingParam = new NativeCallerAttribute("AvatarEditState", "GetShapingParam");

		private static NativeCallerAttribute _attribute_StartCompare = new NativeCallerAttribute("AvatarEditState", "StartCompare", 3u);

		private static NativeCallerAttribute _attribute_EndCompare = new NativeCallerAttribute("AvatarEditState", "EndCompare");

		private static NativeCalleeAttribute _attribute_OnEnterState = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarEditState", "OnEnterState");

		public void EnterState(uint editAspect)
		{
			_method_EnterState.invokeArgumentTable.SetUIntParam(0u, editAspect);
			_method_EnterState.DoApply();
		}

		public void ExitState()
		{
			_ = _method_ExitState.invokeArgumentTable;
			_method_ExitState.DoApply();
		}

		public void SetShapingParam(uint paramGroup, uint paramId, uint paramKind, string paramVal)
		{
			IDParameterTable invokeArgumentTable = _method_SetShapingParam.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, paramGroup);
			invokeArgumentTable.SetUIntParam(1u, paramId);
			invokeArgumentTable.SetUIntParam(2u, paramKind);
			invokeArgumentTable.SetStringParam(3u, paramVal);
			_method_SetShapingParam.DoApply();
		}

		public string GetShapingParam(uint paramGroup, uint paramId, uint paramKind)
		{
			IDParameterTable invokeArgumentTable = _method_GetShapingParam.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, paramGroup);
			invokeArgumentTable.SetUIntParam(1u, paramId);
			invokeArgumentTable.SetUIntParam(2u, paramKind);
			_method_GetShapingParam.DoApply();
			IDParameterTable returnArgumentTable = _method_StartCompare.returnArgumentTable;
			uint val = 0u;
			returnArgumentTable.GetUIntParam(0u, ref val);
			if (val == 0)
			{
				return returnArgumentTable.GetStringParam(1u);
			}
			return null;
		}

		public bool StartCompareShapingParam(uint paramGroup, uint paramId)
		{
			IDParameterTable invokeArgumentTable = _method_GetShapingParam.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, paramGroup);
			invokeArgumentTable.SetUIntParam(1u, paramId);
			_method_StartCompare.DoApply();
			IDParameterTable returnArgumentTable = _method_StartCompare.returnArgumentTable;
			uint val = 0u;
			returnArgumentTable.GetUIntParam(0u, ref val);
			return val == 0;
		}

		public void EndCompareShapingParam()
		{
			_method_EndCompare.DoApply();
		}

		private void OnEnterState(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 0u;
			invokeArguments.GetUIntParam(0u, ref val);
			if (_Object != null)
			{
				_Object.Internal_OnEnterState((NativeResult)val);
				return;
			}
			string stringParam = invokeArguments.GetStringParam(1u);
			if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, " OnEnterState error: " + stringParam);
			}
		}

		public NativeCall_AvatarEditState(AvatarEditState obj, uint instanceId)
			: base(instanceId)
		{
			_Object = obj;
			AddCalleeMethod(_attribute_OnEnterState, OnEnterState);
			_method_EnterState = AddCallerMethod(_attribute_EnterState);
			_method_ExitState = AddCallerMethod(_attribute_ExitState);
			_method_SetShapingParam = AddCallerMethod(_attribute_SetShapingParam);
			_method_GetShapingParam = AddCallerMethod(_attribute_GetShapingParam);
			_method_StartCompare = AddCallerMethod(_attribute_StartCompare);
			_method_EndCompare = AddCallerMethod(_attribute_EndCompare);
		}
	}
	internal class NativeCall_AvatarEntity : NativeCallProxy
	{
		private AvatarEntity _avatarEntity;

		private NativeCaller _method_SetVisible;

		private NativeCaller _method_SetLodLevelLoaded;

		private NativeCaller _method_SetForceLodLevel;

		private const string className = "AvatarEntity";

		private static NativeCallerAttribute _attribute_SetVisible = new NativeCallerAttribute("AvatarEntity", "SetVisible");

		private static NativeCallerAttribute _attribute_SetLodLevelLoaded = new NativeCallerAttribute("AvatarEntity", "SetLodLevelLoaded");

		private static NativeCallerAttribute _attribute_SetForceLodLevel = new NativeCallerAttribute("AvatarEntity", "SetForceLodLevel");

		private static NativeCalleeAttribute _attribute_OnLodChanged = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarEntity", "OnLodChanged");

		private static NativeCalleeAttribute _attribute_OnAnimationStart = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarEntity", "OnAnimationStart");

		private static NativeCalleeAttribute _attribute_OnCustomHandSet = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarEntity", "OnCustomHandSet");

		public void SetVisible(bool visible)
		{
			_method_SetVisible.invokeArgumentTable.SetByteParam(0u, (byte)(visible ? 1 : 0));
			_method_SetVisible.DoApply();
		}

		public void SetLodLevelLoaded(AvatarLodLevel lodLevel)
		{
			_method_SetLodLevelLoaded.invokeArgumentTable.SetByteParam(0u, (byte)lodLevel);
			_method_SetLodLevelLoaded.DoApply();
		}

		public void SetForceLodLevel(AvatarLodLevel lodLevel)
		{
			_method_SetForceLodLevel.invokeArgumentTable.SetByteParam(0u, (byte)lodLevel);
			_method_SetForceLodLevel.DoApply();
		}

		private void OnLodChanged(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			if (AvatarEnv.NeedLog(DebugLogMask.NativeCallTrivial))
			{
				AvatarEnv.Log(DebugLogMask.NativeCallTrivial, "OnLodChanged");
			}
			uint val = 0u;
			if (invokeArguments.GetUIntParam(0u, ref val) == NativeResult.Success)
			{
				_avatarEntity?.OnLodChanged((AvatarLodLevel)val);
			}
		}

		private void OnAnimationStart(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			if (AvatarEnv.NeedLog(DebugLogMask.GeneralInfo))
			{
				AvatarEnv.Log(DebugLogMask.GeneralInfo, "JS=>C#: BodyAnimController.OnAnimationStart");
			}
			_avatarEntity?.bodyAnimController?.SetDefaultHeadXform();
			_avatarEntity?.bodyAnimController?.OnAnimationStart();
		}

		private void OnCustomHandSet(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			UnityEngine.Debug.Log("OnCustomHandSet");
			_avatarEntity?.UpdateCustomHandPose();
		}

		public NativeCall_AvatarEntity(AvatarEntity avatarEntity, uint instanceId)
			: base(instanceId)
		{
			_avatarEntity = avatarEntity;
			AddCalleeMethod(_attribute_OnLodChanged, OnLodChanged);
			AddCalleeMethod(_attribute_OnAnimationStart, OnAnimationStart);
			AddCalleeMethod(_attribute_OnCustomHandSet, OnCustomHandSet);
			_method_SetVisible = AddCallerMethod(_attribute_SetVisible);
			_method_SetLodLevelLoaded = AddCallerMethod(_attribute_SetLodLevelLoaded);
			_method_SetForceLodLevel = AddCallerMethod(_attribute_SetForceLodLevel);
		}
	}
	internal class NativeCall_AvatarLodManager : NativeCallProxy
	{
		private PicoAvatarLodManager _LodManager;

		private NativeCaller _method_Initialize;

		private NativeCaller _method_SetForceAndMaxLodLevel;

		private NativeCaller _method_SetLodScreenPercentages;

		private const string className = "AvatarLodManager";

		private static NativeCallerAttribute _attribute_Initialize = new NativeCallerAttribute("AvatarLodManager", "Initialize");

		private static NativeCallerAttribute _attribute_SetForceAndMaxLodLevel = new NativeCallerAttribute("AvatarLodManager", "SetForceAndMaxLodLevel");

		private static NativeCallerAttribute _attribute_SetLodScreenPercentages = new NativeCallerAttribute("AvatarLodManager", "SetLodScreenPercentages");

		public void Initialize(AvatarLodLevel forceLodLevel, AvatarLodLevel maxLodLevel, float lod0ScreenPercentage, float lod1ScreenPercentage, float lod2ScreenPercentage, float lod3ScreenPercentageo)
		{
			IDParameterTable invokeArgumentTable = _method_Initialize.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, (uint)forceLodLevel);
			invokeArgumentTable.SetUIntParam(1u, (uint)maxLodLevel);
			invokeArgumentTable.SetFloatParam(2u, lod0ScreenPercentage);
			invokeArgumentTable.SetFloatParam(3u, lod1ScreenPercentage);
			invokeArgumentTable.SetFloatParam(4u, lod2ScreenPercentage);
			invokeArgumentTable.SetFloatParam(5u, lod3ScreenPercentageo);
			_method_Initialize.DoApply();
		}

		public void SetForceAndMaxLodLevel(AvatarLodLevel forceLodLevel, AvatarLodLevel maxLodLevel)
		{
			IDParameterTable invokeArgumentTable = _method_SetForceAndMaxLodLevel.invokeArgumentTable;
			invokeArgumentTable.SetUIntParam(0u, (uint)forceLodLevel);
			invokeArgumentTable.SetFloatParam(1u, (uint)maxLodLevel);
			_method_SetForceAndMaxLodLevel.DoApply();
		}

		public void SetLodScreenPercentages(float lod0ScreenPercentage, float lod1ScreenPercentage, float lod2ScreenPercentage, float lod3ScreenPercentage)
		{
			IDParameterTable invokeArgumentTable = _method_SetLodScreenPercentages.invokeArgumentTable;
			invokeArgumentTable.SetFloatParam(0u, lod0ScreenPercentage);
			invokeArgumentTable.SetFloatParam(1u, lod1ScreenPercentage);
			invokeArgumentTable.SetFloatParam(2u, lod2ScreenPercentage);
			invokeArgumentTable.SetFloatParam(3u, lod3ScreenPercentage);
			_method_SetLodScreenPercentages.DoApply();
		}

		public NativeCall_AvatarLodManager(PicoAvatarLodManager LodManager, uint instanceId)
			: base(0u)
		{
			_LodManager = LodManager;
			_method_Initialize = AddCallerMethod(_attribute_Initialize);
			_method_SetForceAndMaxLodLevel = AddCallerMethod(_attribute_SetForceAndMaxLodLevel);
			_method_SetLodScreenPercentages = AddCallerMethod(_attribute_SetLodScreenPercentages);
		}
	}
	internal class NativeCall_AvatarManager : NativeCallProxy
	{
		private PicoAvatarManager _avatarManager;

		private NativeCaller _method_LoadAvatar;

		private NativeCaller _method_UnloadAvatar;

		private NativeCaller _method_DisablePrimitiveMerge;

		private NativeCaller _method_SetAvatarSDKVersion;

		private const string className = "AvatarManager";

		private static NativeCallerAttribute _attribute_LoadAvatar = new NativeCallerAttribute("AvatarManager", "LoadAvatar");

		private static NativeCallerAttribute _attribute_UnloadAvatar = new NativeCallerAttribute("AvatarManager", "UnloadAvatar");

		private static NativeCallerAttribute _attribute_DisablePrimitiveMerge = new NativeCallerAttribute("AvatarManager", "DisablePrimitiveMerge");

		private static NativeCallerAttribute _attribute_SetAvatarSDKVersion = new NativeCallerAttribute("AvatarManager", "SetAvatarSDKVersion");

		private static NativeCalleeAttribute _attribute_OnInitialized = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarManager", "OnInitialized");

		private static NativeCalleeAttribute _attribute_OnMessage = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarManager", "OnMessage");

		private static NativeCalleeAttribute _attribute_OnAttachAvatar = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarManager", "OnAttachAvatar");

		private static NativeCalleeAttribute _attribute_OnAvatarLoadFailed = new NativeCalleeAttribute(typeof(NativeCallee), "AvatarManager", "OnAvatarLoadFailed");

		public void LoadAvatar(string userId)
		{
			_method_LoadAvatar.invokeArgumentTable.SetStringParam(0u, userId);
			_method_LoadAvatar.DoApply();
		}

		public void UnloadAvatar(string userId)
		{
			_method_UnloadAvatar.invokeArgumentTable.SetStringParam(0u, userId);
			_method_UnloadAvatar.DoApply();
		}

		public void SetDisablePrimitiveMerge(bool disable)
		{
			_method_DisablePrimitiveMerge.invokeArgumentTable.SetBoolParam(0u, disable);
			_method_DisablePrimitiveMerge.DoApply();
		}

		public void SetAvatarSDKVersion(string version)
		{
			_method_SetAvatarSDKVersion.invokeArgumentTable.SetStringParam(0u, version);
			_method_SetAvatarSDKVersion.DoApply();
		}

		private void OnInitialized(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 1u;
			invokeArguments.GetUIntParam(0u, ref val);
			invokeArguments.GetUTF8StringParam(1u);
			if (val == 0)
			{
				_avatarManager.Internal_OnInitialized(success: true);
				return;
			}
			string stringParam = invokeArguments.GetStringParam(1u);
			if (AvatarEnv.NeedLog(DebugLogMask.GeneralError))
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "C# AvatarManager OnInitialized failed" + stringParam);
			}
		}

		private void OnMessage(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 1u;
			invokeArguments.GetUIntParam(0u, ref val);
			string stringParam = invokeArguments.GetStringParam(1u);
			_avatarManager.Internal_OnMessage(val, stringParam);
		}

		private void OnAttachNativeAvatar(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			uint val = 0u;
			string stringParam = invokeArguments.GetStringParam(0u);
			string stringParam2 = invokeArguments.GetStringParam(1u);
			invokeArguments.GetUIntParam(2u, ref val);
			string userId = stringParam;
			_avatarManager.Internal_OnAttachNativeAvatar(userId, stringParam2, val);
		}

		private void OnAvatarLoadFailed(IDParameterTable invokeArguments, NativeCallee invokee)
		{
			string stringParam = invokeArguments.GetStringParam(0u);
			string stringParam2 = invokeArguments.GetStringParam(1u);
			uint val = 1u;
			invokeArguments.GetUIntParam(2u, ref val);
			string stringParam3 = invokeArguments.GetStringParam(3u);
			string userId = stringParam;
			_avatarManager.Internal_OnAvatarLoadFailed(userId, stringParam2, (NativeResult)val, stringParam3);
		}

		public NativeCall_AvatarManager(PicoAvatarManager AvatarManager, uint instanceId)
			: base(0u)
		{
			_avatarManager = AvatarManager;
			AddCalleeMethod(_attribute_OnInitialized, OnInitialized);
			AddCalleeMethod(_attribute_OnMessage, OnMessage);
			AddCalleeMethod(_attribute_OnAttachAvatar, OnAttachNativeAvatar);
			AddCalleeMethod(_attribute_OnAvatarLoadFailed, OnAvatarLoadFailed);
			_method_LoadAvatar = AddCallerMethod(_attribute_LoadAvatar);
			_method_UnloadAvatar = AddCallerMethod(_attribute_UnloadAvatar);
			_method_DisablePrimitiveMerge = AddCallerMethod(_attribute_DisablePrimitiveMerge);
			_method_SetAvatarSDKVersion = AddCallerMethod(_attribute_SetAvatarSDKVersion);
		}
	}
	public class PicoAvatar : MonoBehaviour
	{
		public enum State
		{
			None,
			Loading,
			Running,
			Dead
		}

		public float nativeUpdateMinInterval = 0.1f;

		public bool isMovedWithRemotePlaybackAnimation;

		public JointType[] criticalJoints;

		private GameObject[] criticalJointObjects;

		private uint[] criticalJointIds;

		private XForm[] criticalJointXForms;

		public bool allowBlockFrameWhenLoading;

		public UnityAction<string, string> OnLoadAnimationsExternComplete;

		private string _avatarId;

		private NativeCall_Avatar _rmiObject;

		private State _curState;

		private Vector3 _lastNativePosition = Vector3.zero;

		private Quaternion _lastNativeRotation = Quaternion.identity;

		private AvatarEffectKind _avatarEffectKind;

		private PicoAvatarPlaceholderRef _placeholderRef;

		private List<Action<AvatarEntity>> _entityReadyCallbacks;

		private AvatarEditState _avatarEditState;

		private IntPtr _nativeHandle;

		private uint _nativeAvatarId;

		private const string PavDLLName = "effect";

		public State curState => _curState;

		public bool isAnyEntityReady { get; private set; }

		public AvatarEntity entity { get; private set; }

		public PicoAvatarPlaceholderRef placeHolderRef { get; private set; }

		public Transform cachedTransform { get; private set; }

		public string userId { get; private set; } = "0";


		public string avatarId => _avatarId;

		public AvatarCapabilities capabilities { get; private set; }

		public AvatarHeadShowType headShowType { get; private set; }

		public AvatarEffectKind avatarEffectKind => _avatarEffectKind;

		public bool isPlayingAnimation { get; private set; }

		public bool forceUpdateWhenInactive { get; set; }

		public AvatarSexType sex { get; private set; } = AvatarSexType.Invalid;


		public uint nativeAvatarId => _nativeAvatarId;

		public string avatarStyleName { get; private set; }

		public void SetLayer(int layer)
		{
			Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].gameObject.layer = layer;
			}
		}

		public void SetHeadShowType(AvatarHeadShowType headShowType)
		{
			this.headShowType = headShowType;
		}

		public void SetAvatarEffectKind(AvatarEffectKind avatarEffectKind_)
		{
			if (_avatarEffectKind == avatarEffectKind_)
			{
				return;
			}
			_avatarEffectKind = avatarEffectKind_;
			if (entity != null)
			{
				AvatarLod currentAvatarLod = entity.GetCurrentAvatarLod();
				if (currentAvatarLod != null)
				{
					currentAvatarLod.Internal_SetAvatarEffectKind(avatarEffectKind_);
				}
			}
		}

		public void SetAvatarHeight(float height, bool isEyeHeight = true)
		{
			if (entity != null && entity.bodyAnimController != null && isEyeHeight)
			{
				height -= entity.bodyAnimController.eyeOffset.y;
			}
			if (_rmiObject != null)
			{
				_rmiObject.SetAvatarHeight(height);
			}
		}

		public void PlayAnimation(string name, float loopTime = -1f)
		{
			if (_placeholderRef != null)
			{
				if (_placeholderRef.isReady)
				{
					PicoPlaceholderAvatar placeholderAvatar = _placeholderRef.GetPlaceholderAvatar();
					if (placeholderAvatar != null)
					{
						isPlayingAnimation = true;
						placeholderAvatar.PlayAnimation(name, loopTime);
					}
				}
				return;
			}
			if (_rmiObject != null)
			{
				isPlayingAnimation = true;
				if (entity != null)
				{
					AvatarBodyAnimController bodyAnimController = entity.bodyAnimController;
					if (bodyAnimController != null)
					{
						AvatarAnimationLayer animationLayerByName = bodyAnimController.GetAnimationLayerByName("BottomLayer");
						if (animationLayerByName != null)
						{
							animationLayerByName.PlayAnimationClip(name, loopTime, 1f, 0f);
							return;
						}
					}
				}
			}
			throw new Exception("PicoAvatar.PlayAnimation need lod ready!");
		}

		public void StopAnimation(bool immediately = true)
		{
			if (isPlayingAnimation)
			{
				isPlayingAnimation = false;
				if (entity != null)
				{
					entity.bodyAnimController?.GetAnimationLayerByName("ActionLayer")?.StopAnimation(0f);
				}
			}
		}

		public string GetAnimationNames()
		{
			if (_rmiObject != null)
			{
				return _rmiObject.GetAnimationNames();
			}
			return "";
		}

		public void LoadAllAnimationsExtern(string folderPath)
		{
			string searchPattern = "*.zip";
			string[] files = Directory.GetFiles(folderPath, searchPattern);
			for (int i = 0; i < files.Length; i++)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("[");
				using (ZipArchive zipArchive = new ZipArchive(File.OpenRead(files[i]), ZipArchiveMode.Read))
				{
					int num = 0;
					foreach (ZipArchiveEntry entry in zipArchive.Entries)
					{
						if (num > 0)
						{
							stringBuilder.Append(",");
						}
						stringBuilder.Append("\"");
						stringBuilder.Append(entry.FullName);
						stringBuilder.Append("\"");
						num++;
					}
				}
				stringBuilder.Append("]");
				string animationPathsJson = stringBuilder.ToString();
				LoadAnimationsExtern(files[i], animationPathsJson);
			}
		}

		public void LoadAnimationsExtern(string assetBundlePath, string animationPathsJson)
		{
			if (_rmiObject != null)
			{
				_rmiObject.LoadAnimationsExtern(assetBundlePath, animationPathsJson);
			}
		}

		public void LoadAnimationsFromAssetBundle(AvatarAssetBundle ab, string animationPathsJson)
		{
			if (_rmiObject != null)
			{
				_rmiObject.LoadAnimationsFromAssetBundle(ab, animationPathsJson);
			}
		}

		public void RemoveAnimation(string name)
		{
			if (_rmiObject != null)
			{
				_rmiObject.RemoveAnimation(name);
			}
		}

		public void ForceUpdateLod()
		{
			if (PicoAvatarApp.instance.forceLodLevel == AvatarLodLevel.Invalid && isAnyEntityReady && _rmiObject != null)
			{
				_rmiObject.ForceUpdateLod();
			}
		}

		public bool SetCustomHand(HandSide side, GameObject handSkeleton, GameObject handPose, Vector3 handUp, Vector3 handForward)
		{
			return SetCustomHand(side, handSkeleton, handPose, handUp, handForward, new Vector3(0f, 0f, 0f));
		}

		public bool SetCustomHand(HandSide side, GameObject handSkeleton, GameObject handPose, Vector3 handUp, Vector3 handForward, Vector3 wristOffset)
		{
			return entity.setCustomHand(side, handSkeleton, handPose, handUp, handForward, wristOffset);
		}

		public void ClearCustomHand(HandSide side)
		{
			entity.ClearCustomHand(side);
		}

		public void AddFirstEntityReadyCallback(Action<AvatarEntity> entityReadyCallback)
		{
			if (entity != null && isAnyEntityReady)
			{
				entityReadyCallback(entity);
			}
			else if (_entityReadyCallbacks == null)
			{
				_entityReadyCallbacks = new List<Action<AvatarEntity>>();
				_entityReadyCallbacks.Add(entityReadyCallback);
			}
		}

		public void CompactMemory(ulong flags)
		{
			pav_AvatarInstance_CompactMemory(_nativeHandle, flags);
		}

		public AvatarEditState GetAvatarEditState()
		{
			if (_avatarEditState == null && isAnyEntityReady && _rmiObject != null)
			{
				_rmiObject.InitializeEdit();
				_avatarEditState = new AvatarEditState(this);
			}
			return _avatarEditState;
		}

		public string GetAvatarSpecification()
		{
			if (_rmiObject != null)
			{
				return _rmiObject.GetAvatarSpecification();
			}
			return "";
		}

		public void Internal_Initialize(string userId, string avatarId_, AvatarLoadContext loadCtx)
		{
			this.userId = userId;
			_avatarId = avatarId_;
			capabilities = loadCtx.capabilities;
			if (cachedTransform == null)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				cachedTransform = base.transform;
				base.gameObject.layer = base.gameObject.layer;
				GameObject gameObject = new GameObject("Entity");
				entity = gameObject.AddComponent<AvatarEntity>();
				Transform obj = gameObject.transform;
				obj.SetParent(cachedTransform);
				obj.localPosition = Vector3.zero;
				obj.localRotation = Quaternion.identity;
				obj.localScale = Vector3.one;
				obj.gameObject.layer = base.gameObject.layer;
				PicoAvatarManager instance = PicoAvatarManager.instance;
				if (capabilities.enablePlaceHolder && capabilities.isLocalAvatar && instance.placeHolderLocalAvatar != null)
				{
					_placeholderRef = new PicoAvatarPlaceholderRef(userId, cachedTransform, instance.placeHolderLocalAvatar);
				}
				else if (capabilities.enablePlaceHolder && !capabilities.isLocalAvatar && instance.placeHolderOtherAvatar != null)
				{
					_placeholderRef = new PicoAvatarPlaceholderRef(userId, cachedTransform, instance.placeHolderOtherAvatar);
				}
			}
			entity.Internal_SetOwner(this);
		}

		public void Internal_OnAttachNativeAvatar(string avatarId, uint nativeAvatarId)
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				NativeObject.ReleaseNative(ref _nativeHandle);
			}
			_nativeHandle = pav_AvatarInstance_GetObject(nativeAvatarId);
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new Exception("Native AvatarInstance was not created when notify C# OnAttachNativeAvatar!");
			}
			_nativeAvatarId = nativeAvatarId;
			_curState = State.Loading;
			if (_rmiObject != null)
			{
				throw new Exception("PicoAvatar has attached.");
			}
			_rmiObject = new NativeCall_Avatar(this, nativeAvatarId);
			_rmiObject.Retain();
			if (PicoAvatarApp.instance.materialConfiguration != null && !PicoAvatarApp.instance.materialConfiguration.need_BumpMap && !PicoAvatarApp.instance.materialConfiguration.need_MetallicGlossMap)
			{
				CompactMemory(1uL);
			}
		}

		public void Internal_Destroy()
		{
			if (_curState == State.Dead)
			{
				return;
			}
			_curState = State.Dead;
			base.gameObject.SetActive(value: false);
			if (_avatarEditState != null)
			{
				_avatarEditState.Destroy();
				_avatarEditState = null;
			}
			if (entity != null)
			{
				entity.Internal_Destroy();
				entity = null;
			}
			if (_placeholderRef != null)
			{
				_placeholderRef.Release();
				_placeholderRef = null;
			}
			if (_entityReadyCallbacks != null)
			{
				List<Action<AvatarEntity>> entityReadyCallbacks = _entityReadyCallbacks;
				_entityReadyCallbacks = null;
				foreach (Action<AvatarEntity> item in entityReadyCallbacks)
				{
					item(null);
				}
			}
			if (_rmiObject != null)
			{
				_rmiObject.Release();
				_rmiObject = null;
			}
			if (_nativeHandle != IntPtr.Zero)
			{
				NativeObject.ReleaseNative(ref _nativeHandle);
			}
		}

		private void OnDestroy()
		{
			Internal_Destroy();
		}

		public void Internal_OnAvatarEntityLoaded(uint nativeEntityId, AvatarLodLevel curLodLevel, AvatarSexType avatarSex, string styleName)
		{
			sex = avatarSex;
			avatarStyleName = styleName;
			if (entity != null)
			{
				entity.Internal_Destroy();
				entity.Internal_CheckBuildFromNative(nativeEntityId, curLodLevel);
			}
			_curState = State.Running;
			UpdateAvatarMovement();
		}

		public void Internal_OnLoadAnimationsExternComplete(string assetBundlePath, string animationPathsJson)
		{
			OnLoadAnimationsExternComplete?.Invoke(assetBundlePath, animationPathsJson);
		}

		public virtual void Internal_OnAvatarEntityLodReadyToShow(AvatarEntity avatarEntity, AvatarLodLevel curLodLevel)
		{
			isAnyEntityReady = true;
			if (_placeholderRef != null)
			{
				_placeholderRef.Release();
				_placeholderRef = null;
				isPlayingAnimation = false;
			}
			if (entity.bodyAnimController != null)
			{
				entity.bodyAnimController.Internal_Initialize(entity.nativeEntityId);
			}
			if ((double)PicoAvatarApp.instance.forceAvatarHeight > 0.01)
			{
				SetAvatarHeight(PicoAvatarApp.instance.forceAvatarHeight);
			}
			UpdateAvatarMovement();
			if (_entityReadyCallbacks == null)
			{
				return;
			}
			List<Action<AvatarEntity>> entityReadyCallbacks = _entityReadyCallbacks;
			_entityReadyCallbacks = null;
			foreach (Action<AvatarEntity> item in entityReadyCallbacks)
			{
				item(entity);
			}
		}

		public void Internal_UpdateFrame(float gameTime)
		{
			UpdateAvatarMovement();
			if (entity != null && entity.nativeEntityId != 0)
			{
				entity.Internal_UpdateFrame();
			}
		}

		public void Internal_LateUpdateFrame(float gameTime)
		{
			if (!(entity != null) || entity.nativeEntityId == 0 || !entity.isAnyLodReady)
			{
				return;
			}
			entity.Internal_LateUpdateFrame(gameTime);
			if (criticalJoints == null || criticalJoints.Length == 0 || entity.bodyAnimController == null)
			{
				return;
			}
			_ = entity.bodyAnimController.jointNameIDTable;
			int num = criticalJoints.Length;
			if (criticalJointXForms == null)
			{
				criticalJointXForms = new XForm[num];
				criticalJointIds = new uint[num];
				criticalJointObjects = new GameObject[num];
				Transform parent = entity.transform;
				for (int i = 0; i < num; i++)
				{
					criticalJointIds[i] = (uint)criticalJoints[i];
					criticalJointObjects[i] = new GameObject(criticalJoints[i].ToString());
					Transform obj = criticalJointObjects[i].transform;
					obj.parent = parent;
					obj.localScale = Vector3.one;
				}
			}
			entity.bodyAnimController.GetJointXForms(criticalJointIds, ref criticalJointXForms);
			for (int j = 0; j < num; j++)
			{
				criticalJointObjects[j].transform.localPosition = criticalJointXForms[j].position;
				criticalJointObjects[j].transform.localRotation = criticalJointXForms[j].orientation;
			}
		}

		public void Internal_OnSpecUpdated(string avatarId, string jsonData)
		{
			_avatarId = avatarId;
		}

		private void UpdateAvatarMovement()
		{
			if (!(cachedTransform != null))
			{
				return;
			}
			bool flag = false;
			if (isMovedWithRemotePlaybackAnimation && capabilities.controlSourceType == ControlSourceType.RemoteServer)
			{
				XForm nativeXForm = GetNativeXForm();
				cachedTransform.localPosition = nativeXForm.position;
				cachedTransform.localRotation = nativeXForm.orientation;
				cachedTransform.localScale = nativeXForm.scale;
			}
			else
			{
				Vector3 position = cachedTransform.position;
				Quaternion rotation = cachedTransform.rotation;
				if (Vector3.SqrMagnitude(position - _lastNativePosition) > PicoAvatarApp.instance.positionErrorThreshold || Quaternion.Dot(rotation, _lastNativeRotation) < 1f - PicoAvatarApp.instance.orientationErrorThreshold)
				{
					flag = true;
				}
				if (flag)
				{
					_lastNativePosition = position;
					_lastNativeRotation = rotation;
					if (_nativeHandle != IntPtr.Zero)
					{
						XForm xform = default(XForm);
						xform.position = position;
						xform.orientation = rotation;
						xform.scale = cachedTransform.localScale;
						pav_AvatarInstance_SetXForm(_nativeHandle, xform);
					}
				}
			}
			if (_placeholderRef != null)
			{
				_placeholderRef.UpdateMovement();
			}
		}

		private XForm GetNativeXForm()
		{
			XForm xform = default(XForm);
			pav_AvatarInstance_GetXForm(_nativeHandle, ref xform);
			return xform;
		}

		public GameObject GetJointObject(JointType jointType)
		{
			if (criticalJointObjects == null || criticalJoints == null)
			{
				return null;
			}
			for (int i = 0; i < criticalJoints.Length; i++)
			{
				if (jointType == criticalJoints[i])
				{
					if (criticalJointObjects.Length <= i)
					{
						break;
					}
					return criticalJointObjects[i];
				}
			}
			return null;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarInstance_GetObject(uint nativeAvatarId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarInstance_SetXForm(IntPtr avatarHandle, XForm xform);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarInstance_GetXForm(IntPtr avatarHandle, ref XForm xform);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarInstance_CompactMemory(IntPtr avatarHandle, ulong flags);
	}
	public delegate void AvatarManagerInitialized(bool success);
	public delegate void AvatarManagerStopping();
	public class PicoAvatarApp : MonoBehaviour
	{
		public enum Stage
		{
			None,
			PreparingFirmware,
			PreInitialize,
			Running,
			PreUninitialize,
			Uninitialized
		}

		private enum AvatarAppConfigFlags
		{
			ServerSyncTime = 1
		}

		private struct AvatarAppConfig
		{
			public string appId;

			public uint version;

			public string avatarPath;

			public string cachePath;

			public uint injectMode;

			public uint intermitentMode;

			public uint flags;
		}

		[SerializeField]
		[HideInInspector]
		public string AvatarSDKVersion = "1.3.0";

		[Header("---------------- App Login --------------")]
		public string avatarAppId;

		public string avatarAppToken;

		public string userToken;

		public string nationType = "";

		public bool intermitentMode;

		public DeviceInputReaderBuilder.InputType localAvatarInputType = DeviceInputReaderBuilder.InputType.PicoXR;

		public DeviceInputReaderBuilder.InputType remoteAvatarInputType = DeviceInputReaderBuilder.InputType.RemotePackage;

		public ServerType serverType;

		public AccessType accessType;

		[Tooltip("Start AvatarManager when PicoAvatarApp started. Use configurations in PicoAvatarApp.")]
		public bool autoStartAvatarManager = true;

		[Header("------------------------------------------")]
		public string debugConfigText = string.Empty;

		[Header("------------------------------------------")]
		public bool enablePlaceHolder = true;

		[Tooltip("Force disable Merge")]
		public bool disablePrimitiveMerge;

		[Tooltip("force avatar height. If less than 0, do nothing. some application need average avatar height")]
		[Range(-0.1f, 10f)]
		public float forceAvatarHeight = -0.1f;

		[Tooltip("ik interplation delay time. When using intermitentMode, self update will delay to avoid jittering ")]
		[Range(0f, 1f)]
		public float ikInterpDelayTime = 0.03f;

		[SerializeField]
		public PicoMaterialConfiguration materialConfiguration;

		[HideInInspector]
		[SerializeField]
		public int avatarSceneLayer;

		[HideInInspector]
		[SerializeField]
		public int localAvatarHeadSceneLayer = -1;

		[Range(3000f, 3999f)]
		public int avatarTranspQueueStart = 3500;

		[Range(3000f, 3999f)]
		public int avatarOpauqeQueueStart = 2000;

		[HideInInspector]
		[SerializeField]
		public AvatarLodLevel maxLodLevel;

		[HideInInspector]
		[SerializeField]
		public AvatarLodLevel forceLodLevel = AvatarLodLevel.Invalid;

		[Header("------------- Expriment Playback ----------")]
		[Tooltip("average net delay time. ")]
		[Range(0.01f, 2f)]
		public float avgPlaybackDelayTime = 1f;

		[Tooltip(" maximum speed ratio when run after during playback.")]
		[Range(1f, 2f)]
		public float maxPlaybackSpeedRatio = 1.5f;

		[Tooltip(" minum speed ratio when run before during playback ")]
		[Range(0f, 1f)]
		public float minPlaybackSpeedRatio = 0.2f;

		[Tooltip("Whether all users share server synchronized time. It is decided by Application employing the sdk. Should be set before Start()")]
		public bool enableServerSyncTime;

		[Tooltip("Default playback snapshot level")]
		public SnapshotLevel defaultPlaybackLevel = SnapshotLevel.BlendShape;

		[Tooltip("Bit flags from AvatarAnimationFlags.")]
		public uint animationFlags;

		[Header("------------------------------------------")]
		[HideInInspector]
		[SerializeField]
		public uint enabledFullscreenFeatures = uint.MaxValue;

		[Tooltip("distance to switch to line profile mode.")]
		public float lineProfileDistance = 2f;

		[Tooltip("whether show rim profile.")]
		public bool enableRimProfile;

		[Tooltip("whether force disable casting shadow..")]
		public bool forceDisableCastShadow = true;

		[Tooltip("whether force disable receive shadow.")]
		public bool forceDisableReceiveShadow = true;

		[Tooltip("if enabled, Press Spacebar to Pause/Resume the time. Right Arrow to run a time step.")]
		public bool enableDebugPauseResume;

		[Tooltip("whether print system infos.")]
		public bool enableSystemInfo;

		[Header("------------------ Optimization --------------")]
		[Tooltip("position sync threshold for none-animation calculation.")]
		[Range(0f, 0.5f)]
		public float positionErrorThreshold = 0.1f;

		[Tooltip("orientation sync threshold for non-animation calculation.")]
		[Range(0f, 1f)]
		public float orientationErrorThreshold = 0.05f;

		public Camera mainCamera;

		private static PicoAvatarApp _instance;

		private bool _playingMode;

		private Stage _curStage;

		private NativeCall_AvatarApp _rmiObject;

		private IntPtr _nativeHandle;

		private PicoAvatarManager _avatarManager;

		private PicoAvatarSceneLightEnv _avatarSceneLightEnv;

		private float _lastTime;

		private float _timeScale = 1f;

		private Plane[] _frustumPlanes;

		[HideInInspector]
		[SerializeField]
		private float _lod0ScreenPercetage = 1f;

		[HideInInspector]
		[SerializeField]
		private float _lod1ScreenPercetage = 1f;

		[HideInInspector]
		[SerializeField]
		private float _lod2ScreenPercetage = 1f;

		[HideInInspector]
		[SerializeField]
		private float _lod3ScreenPercetage = 0.5f;

		[SerializeField]
		[HideInInspector]
		private float _additiveGI;

		[SerializeField]
		[HideInInspector]
		private uint _debugLogMasks = 16777215u;

		private bool _traceNativeCaller;

		[SerializeField]
		private bool _enableLogTime = true;

		[SerializeField]
		[HideInInspector]
		private bool _enableStats;

		private const string PavDLLName = "effect";

		public float additiveGI
		{
			get
			{
				return _additiveGI;
			}
			set
			{
				SetAdditiveGI(value);
			}
		}

		public float lod0ScreenPercetage => _lod0ScreenPercetage;

		public float lod1ScreenPercetage => _lod1ScreenPercetage;

		public float lod2ScreenPercetage => _lod2ScreenPercetage;

		public float lod3ScreenPercetage => _lod3ScreenPercetage;

		public static PicoAvatarApp instance => _instance;

		public static bool isWorking
		{
			get
			{
				if (_instance != null)
				{
					return _instance._curStage == Stage.Running;
				}
				return false;
			}
		}

		public static bool isNativeEngineReady
		{
			get
			{
				if (_instance != null && _instance._curStage != 0)
				{
					return _instance._curStage != Stage.Uninitialized;
				}
				return false;
			}
		}

		public Plane[] frustumPlanes => _frustumPlanes;

		public uint debugLogMasks
		{
			get
			{
				return _debugLogMasks;
			}
			set
			{
				SetDebugLogMasks(value);
			}
		}

		public bool traceNativeCaller
		{
			get
			{
				return _traceNativeCaller;
			}
			set
			{
				SetTraceNativeCaller(value);
			}
		}

		public bool enableLogTime
		{
			get
			{
				return _enableLogTime;
			}
			set
			{
				SetEnableLogTime(value);
			}
		}

		public bool enableStats
		{
			get
			{
				return _enableStats;
			}
			set
			{
				if (_enableStats != value)
				{
					_enableStats = value;
					if (_enableStats)
					{
						PicoAvatarStats.instance = new PicoAvatarStats();
					}
					else
					{
						PicoAvatarStats.instance = null;
					}
				}
			}
		}

		public PicoAvatarSceneLightEnv curAvatarSceneLightEnv { get; private set; }

		public event AvatarManagerInitialized OnAvatarManagerInitialized;

		public event AvatarManagerStopping OnAvatarManagerStopping;

		public void Awake()
		{
			_playingMode = Application.isPlaying;
		}

		private void Start()
		{
			UnityEngine.Debug.Log("pav: PicoAvatarApp.Start ...");
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			CoroutineExecutor.Start(this);
			if (_instance == null)
			{
				_instance = this;
				StartCoroutine(Coroutine_Initialize());
			}
			else if (_instance != this)
			{
				UnityEngine.Debug.LogWarning("Only one PicoAvatarSDK instance enabled.");
			}
		}

		public void Update()
		{
			if (_instance == null)
			{
				return;
			}
			float num = (Time.time - _lastTime) * _timeScale;
			_lastTime += num;
			Camera camera = mainCamera ?? Camera.main;
			if (camera != null)
			{
				_frustumPlanes = GeometryUtility.CalculateFrustumPlanes(camera);
			}
			if (!Utility.EnableSDKUpdate || !(_nativeHandle != IntPtr.Zero))
			{
				return;
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.EmitStart(PicoAvatarStats.StatsType.AvatarTotalUpdate);
			}
			if (NativeCallMarshal.IsInitialized())
			{
				NativeCallMarshal.Update();
			}
			if (_avatarManager != null)
			{
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.EmitStart(PicoAvatarStats.StatsType.AvatarPreUpdate);
				}
				_avatarManager.Internal_UpdateFrame(_lastTime);
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.EmitFinish(PicoAvatarStats.StatsType.AvatarPreUpdate);
				}
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.EmitStart(PicoAvatarStats.StatsType.AvatarCoreUpdate);
			}
			pav_AvatarApp_Update(_nativeHandle, _lastTime);
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.EmitFinish(PicoAvatarStats.StatsType.AvatarCoreUpdate);
			}
			if (_avatarManager != null)
			{
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.EmitStart(PicoAvatarStats.StatsType.AvatarRenderUpdate);
				}
				_avatarManager.Internal_LateUpdateFrame(_lastTime);
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.EmitFinish(PicoAvatarStats.StatsType.AvatarRenderUpdate);
				}
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.EmitFinish(PicoAvatarStats.StatsType.AvatarTotalUpdate);
			}
		}

		private void OnApplicationQuit()
		{
			UnityEngine.Debug.Log("pav: PicoAvatarApp.OnApplicationQuit");
			Uninitialize();
		}

		private void OnApplicationPause(bool pause)
		{
			if (pause)
			{
				UnityEngine.Debug.Log("pav: PicoAvatarApp.OnApplicationPause true");
			}
			else
			{
				UnityEngine.Debug.Log("pav: PicoAvatarApp.OnApplicationPause false");
			}
		}

		private void OnDestroy()
		{
			UnityEngine.Debug.Log("pav: PicoAvatarApp.OnDestroy");
			Uninitialize();
		}

		public void StartApp()
		{
			_lastTime = Time.time;
			StartCoroutine(Coroutine_Initialize());
		}

		public void StopApp()
		{
			Uninitialize();
		}

		public void StartAvatarManager()
		{
			if (_playingMode && isWorking && _avatarManager != null)
			{
				StopAvatarManager();
			}
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "PicoAvatarApp.StartAvatarManager");
			}
			if (_playingMode && isWorking && _avatarManager == null)
			{
				_avatarManager = new PicoAvatarManager();
				_avatarManager.Internal_Initialize(avatarAppId, avatarAppToken, userToken, Time.time, serverType, accessType, nationType);
			}
		}

		public void Internal_OnAvatarManagerInitialize(bool success)
		{
			this.OnAvatarManagerInitialized?.Invoke(success);
			if (!string.IsNullOrEmpty(debugConfigText))
			{
				_rmiObject.SetDebugConfig(debugConfigText);
			}
		}

		public void StopAvatarManager()
		{
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "PicoAvatarApp.StopAvatarManager start...");
			}
			this.OnAvatarManagerStopping?.Invoke();
			if (_playingMode && _avatarManager != null)
			{
				_avatarManager.Internal_Unitialize();
				_avatarManager = null;
			}
		}

		public void SetBurdenLevel(uint burdenLevel)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetBurden(burdenLevel);
			}
		}

		public void SetForceLodLevel(AvatarLodLevel forceLodLevel_)
		{
			forceLodLevel = forceLodLevel_;
			if (PicoAvatarLodManager.instance != null)
			{
				PicoAvatarLodManager.instance.Internal_SetForceAndMaxLodLevel(forceLodLevel, maxLodLevel);
			}
		}

		public void SetMaxLodLevel(AvatarLodLevel maxLodLevel_)
		{
			maxLodLevel = maxLodLevel_;
			if (PicoAvatarLodManager.instance != null)
			{
				PicoAvatarLodManager.instance.Internal_SetForceAndMaxLodLevel(forceLodLevel, maxLodLevel);
			}
		}

		public void SetLodScreenPercentages(float lod0ScreenPercentage, float lod1ScreenPercentage, float lod2ScreenPercentage, float lod3ScreenPercentage)
		{
			_lod0ScreenPercetage = lod0ScreenPercentage;
			_lod1ScreenPercetage = lod1ScreenPercentage;
			_lod2ScreenPercetage = lod2ScreenPercentage;
			_lod3ScreenPercetage = lod3ScreenPercentage;
			if (PicoAvatarLodManager.instance != null)
			{
				PicoAvatarLodManager.instance.Internal_SetLodScreenPercentages(lod0ScreenPercentage, lod1ScreenPercentage, lod2ScreenPercentage, lod3ScreenPercentage);
			}
		}

		public void SetAdditiveGI(float additiveGI_)
		{
			_additiveGI = additiveGI_;
		}

		private IEnumerator Coroutine_Initialize()
		{
			if (_curStage != 0 && _curStage != Stage.Uninitialized)
			{
				yield break;
			}
			AvatarEnv.Internal_Initialize(_debugLogMasks);
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp AvatarEnv Initialize");
			}
			if (_enableStats)
			{
				PicoAvatarStats.instance = new PicoAvatarStats();
			}
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp Start Initialize");
			}
			_lastTime = Time.time;
			SetEnableLogTime(enableLogTime);
			if (enableSystemInfo)
			{
				Utility.PrintSystemInfos();
			}
			if (_nativeHandle == IntPtr.Zero)
			{
				_nativeHandle = pav_AvatarApp_New(autoUnloadEngine: false);
			}
			if (_curStage != Stage.Uninitialized && _playingMode)
			{
				_curStage = Stage.PreparingFirmware;
				bool resourceReady = false;
				UnityAction<bool> onChecked = delegate(bool ready)
				{
					resourceReady = ready;
				};
				yield return Utility.CheckAvatarResources(onChecked);
				if (!resourceReady)
				{
					UnityEngine.Debug.LogError("AvatarManager Initizlize failed. Resource not ready.");
					yield break;
				}
			}
			_curStage = Stage.PreInitialize;
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.AppBootStart();
			}
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp Native SetConfig");
			}
			bool value = false;
			TTNetUtility.InitTTNet();
			AvatarAppConfig config = default(AvatarAppConfig);
			config.appId = avatarAppId;
			config.version = 0u;
			config.avatarPath = AvatarEnv.avatarPath;
			config.cachePath = AvatarEnv.avatarCachePath;
			config.injectMode = Convert.ToUInt32(value);
			config.intermitentMode = Convert.ToUInt32(intermitentMode);
			config.flags = 0u;
			if (enableServerSyncTime)
			{
				config.flags |= 1u;
			}
			if (AvatarEnv.avatarPackedPathFirst || !Directory.Exists(AvatarEnv.avatarPath))
			{
				config.avatarPath = AvatarEnv.avatarPackedPath;
			}
			pav_AvatarApp_SetConfig(_nativeHandle, ref config);
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp Native PreInitialize");
			}
			pav_AvatarApp_PreInitialize(_nativeHandle, Time.time);
			if (_playingMode)
			{
				if (AvatarEnv.NeedLog(DebugLogMask.Framework))
				{
					AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp NativeCallMarshal Initialize");
				}
				NativeCallMarshal.Initialize();
				_rmiObject = new NativeCall_AvatarApp(this, 0u);
				_rmiObject.Retain();
			}
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp NativeCallMarshal PostInitialize");
			}
			pav_AvatarApp_PostInitialize(_nativeHandle);
			if (GraphicsSettings.currentRenderPipeline == null)
			{
				PicoColorTemperature.CheckColorTemperature();
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.AppBootFinished();
			}
			_curStage = Stage.Running;
			if (autoStartAvatarManager)
			{
				StartAvatarManager();
			}
		}

		public void Uninitialize()
		{
			if (_curStage == Stage.None || _curStage == Stage.Uninitialized)
			{
				return;
			}
			try
			{
				_curStage = Stage.PreUninitialize;
				if (AvatarEnv.NeedLog(DebugLogMask.Framework))
				{
					AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp NativeCallMarshal PreUninitialize");
				}
				pav_AvatarApp_PreUninitialize(_nativeHandle);
				StopAvatarManager();
				if (_rmiObject != null)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.Framework))
					{
						AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp RmiObject Shutdown");
					}
					_rmiObject.Shutdown(0u);
				}
				if (_rmiObject != null)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.Framework))
					{
						AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp RmiObject Destroy");
					}
					_rmiObject.Release();
					_rmiObject = null;
				}
				if (_playingMode)
				{
					if (AvatarEnv.NeedLog(DebugLogMask.Framework))
					{
						AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp NativeCallMarshal Unitialize");
					}
					NativeCallMarshal.Unitialize();
				}
				if (AvatarEnv.NeedLog(DebugLogMask.Framework))
				{
					AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp NativeCallMarshal PostUninitialize");
				}
				pav_AvatarApp_PostUninitialize(_nativeHandle);
				if (AvatarEnv.NeedLog(DebugLogMask.Framework))
				{
					AvatarEnv.Log(DebugLogMask.Framework, "AvatarApp AvatarEnv UnInitialize");
				}
				AvatarEnv.UnInitialize();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
			}
			NativeObject.ReleaseNative(ref _nativeHandle);
			_curStage = Stage.Uninitialized;
		}

		public void UpdateNetStats()
		{
			if (_rmiObject != null)
			{
				_rmiObject.GetNetStats();
			}
		}

		public void SetDebugLogMasks(uint logMasks)
		{
			_debugLogMasks = logMasks;
			AvatarEnv.SetDebugLogMasks(_debugLogMasks);
			if (_rmiObject != null)
			{
				_rmiObject.SetDebugLogMasks(_debugLogMasks);
			}
		}

		public void SetTraceNativeCaller(bool trace)
		{
			_traceNativeCaller = trace;
			if (_rmiObject != null)
			{
				_rmiObject.SetTraceNativeCaller(trace);
			}
		}

		public void SetEnableLogTime(bool enableLogTime_)
		{
			_enableLogTime = enableLogTime_;
			AvatarEnv.SetEnableLogTime(enableLogTime_);
		}

		public void SetAvatarSceneLightEnv(PicoAvatarSceneLightEnv curAvatarSceneLightEnv_)
		{
			curAvatarSceneLightEnv = curAvatarSceneLightEnv_;
			if (_avatarManager != null && curAvatarSceneLightEnv_ != null)
			{
				_avatarManager.Internal_OnAvatarSceneLightEnvChanged(curAvatarSceneLightEnv);
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarApp_New(bool autoUnloadEngine);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_SetConfig(IntPtr nativeHandle, ref AvatarAppConfig config);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_PreInitialize(IntPtr nativeHandle, double starTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_PostInitialize(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_Update(IntPtr nativeHandle, double gameTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_PreUninitialize(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarApp_PostUninitialize(IntPtr nativeHandle);
	}
	public class PicoAvatarCamera
	{
		private NativeCalls_AvatarCamera _rmiObject;

		private AvatarBodyAnimController _avatarBodyAnimController;

		private PicoAvatar _trackingAvatar;

		private Vector3 _lastNativePosition = Vector3.zero;

		private Quaternion _lastNativeRotation = Quaternion.identity;

		public Camera mainCamera { get; set; }

		public PicoAvatar trakingAvatar
		{
			get
			{
				return _trackingAvatar;
			}
			set
			{
				_trackingAvatar = value;
				_avatarBodyAnimController = null;
			}
		}

		public void Internal_Initialize()
		{
			_rmiObject = new NativeCalls_AvatarCamera(this, 0u);
			_rmiObject.Retain();
			Camera camera = mainCamera ?? Camera.main;
			if (camera != null && _rmiObject != null)
			{
				_rmiObject.SetConfig(camera);
			}
		}

		public void Internal_Destroy()
		{
			if (_rmiObject != null)
			{
				_rmiObject.Release();
				_rmiObject = null;
			}
		}

		public void InternalUpdate()
		{
			Camera obj = mainCamera ?? Camera.main;
			if (_avatarBodyAnimController == null)
			{
				_avatarBodyAnimController = trakingAvatar?.entity?.bodyAnimController;
			}
			Transform transform = obj.transform;
			Vector3 position = transform.position;
			Quaternion rotation = transform.rotation;
			bool flag = false;
			if (Vector3.SqrMagnitude(position - _lastNativePosition) > PicoAvatarApp.instance.positionErrorThreshold * 2f || Quaternion.Dot(rotation, _lastNativeRotation) < 1f - PicoAvatarApp.instance.orientationErrorThreshold * 2f)
			{
				_lastNativePosition = position;
				_lastNativeRotation = rotation;
				flag = true;
			}
			if (flag && _rmiObject != null)
			{
				_rmiObject.Move(position, rotation);
			}
		}

		public void Internal_LateUpdate()
		{
			if (!(trakingAvatar == null))
			{
				Camera camera = mainCamera ?? Camera.main;
				if (_avatarBodyAnimController != null)
				{
					XForm eyeXForm = _avatarBodyAnimController.GetEyeXForm();
					camera.transform.localPosition = eyeXForm.position;
					camera.transform.localRotation = eyeXForm.orientation;
				}
			}
		}
	}
	public class AvatarEntity : MonoBehaviour
	{
		public AvatarCustomHandPose leftCustomHandPose;

		public AvatarCustomHandPose rightCustomHandPose;

		private bool leftCustomHand;

		private bool rightCustomHand;

		private Transform _XRRoot;

		private Transform _headTarget;

		private Transform _leftHandTarget;

		private Transform _rightHandTarget;

		public bool actionBasedControl;

		public InputActionProperty[] positionActions;

		public InputActionProperty[] rotationActions;

		public InputActionProperty[] buttonActions;

		private GameObject rightHandPose;

		private GameObject leftHandPose;

		public PicoPlaybackPacketRecorder debugPlaybackRecorder;

		public float _statsStartLoadTime;

		public float _statsFirstLodReadyTime;

		private int aaa;

		private string _userId = "0";

		private PicoAvatar _owner;

		private uint _nativeEntityId;

		private AvatarLodLevel _activeLodLevel = AvatarLodLevel.Invalid;

		private AvatarLodLevel _deactivingLodLevel = AvatarLodLevel.Invalid;

		private AvatarLodLevel _forceLodLevel = AvatarLodLevel.Invisible;

		private NativeCall_AvatarEntity _rmiObject;

		private AvatarLod[] _avatarLods = new AvatarLod[3];

		private IntPtr _nativeHandle = IntPtr.Zero;

		private AvatarBodyAnimController _bodyAnimController;

		private IDeviceInputReader _deviceInputReader;

		private MemoryView _shotPacketMemoryView;

		private static Dictionary<uint, AvatarEntity> _allAvatarEntities = new Dictionary<uint, AvatarEntity>();

		private TypeID2NameIDTable _faceBSChannelIDTable;

		private IDParameterTable _faceBSIDParamTable;

		private const string PavDLLName = "effect";

		public string userId => _userId;

		public uint nativeEntityId => _nativeEntityId;

		public PicoAvatar owner => _owner;

		public AvatarLodLevel currentLodLevel => _activeLodLevel;

		public bool isAnyLodReady { get; set; }

		public Transform XRRoot
		{
			get
			{
				return _XRRoot;
			}
			set
			{
				_XRRoot = value;
				if (_deviceInputReader != null)
				{
					_deviceInputReader.XRRoot = XRRoot;
				}
			}
		}

		public Transform headTarget
		{
			get
			{
				return _headTarget;
			}
			set
			{
				_headTarget = value;
				if (_deviceInputReader != null)
				{
					_deviceInputReader.headTarget = headTarget;
				}
			}
		}

		public Transform leftHandTarget
		{
			get
			{
				return _leftHandTarget;
			}
			set
			{
				_leftHandTarget = value;
				if (_deviceInputReader != null)
				{
					_deviceInputReader.leftHandTarget = leftHandTarget;
				}
			}
		}

		public Transform rightHandTarget
		{
			get
			{
				return _rightHandTarget;
			}
			set
			{
				_rightHandTarget = value;
				if (_deviceInputReader != null)
				{
					_deviceInputReader.rightHandTarget = rightHandTarget;
				}
			}
		}

		public AvatarBodyAnimController bodyAnimController
		{
			get
			{
				if (_bodyAnimController == null)
				{
					if (!isAnyLodReady)
					{
						return null;
					}
					IntPtr intPtr = pav_AvatarEntity_GetBodyAnimController(_nativeHandle);
					if (intPtr != IntPtr.Zero)
					{
						_bodyAnimController = new AvatarBodyAnimController(intPtr, this);
						_bodyAnimController.Retain();
					}
				}
				return _bodyAnimController;
			}
		}

		public IDeviceInputReader deviceInputReader => _deviceInputReader;

		public UnityEvent OnAvatarLodReady { get; private set; } = new UnityEvent();


		public UnityEvent OnAvatarWillUnBind { get; private set; } = new UnityEvent();


		public void Internal_SetOwner(PicoAvatar owner)
		{
			_owner = owner;
			_userId = ((owner == null) ? "0" : owner.userId);
			_statsStartLoadTime = AvatarEnv.realtimeSinceStartup;
			if (owner.capabilities.controlSourceType == ControlSourceType.RemoteServer)
			{
				base.transform.localScale = Vector3.zero;
			}
		}

		public AvatarLod GetCurrentAvatarLod()
		{
			if ((uint)_activeLodLevel >= 3u)
			{
				return null;
			}
			return _avatarLods[(int)_activeLodLevel];
		}

		public double GetAnimationPlaybackDelayTime()
		{
			return pav_AvatarEntity_GetPing(_nativeHandle);
		}

		public static AvatarEntity GetAvatarEntityWithNativeID(uint nativeEntityId)
		{
			if (_allAvatarEntities.TryGetValue(nativeEntityId, out var value))
			{
				return value;
			}
			return null;
		}

		public bool Internal_CheckBuildFromNative(uint nativeEntityId, AvatarLodLevel lodLevel)
		{
			if (_nativeEntityId != 0 && _nativeEntityId != nativeEntityId)
			{
				throw new ArgumentException("Native entity id conflicts!");
			}
			if (_rmiObject == null)
			{
				_rmiObject = new NativeCall_AvatarEntity(this, nativeEntityId);
				_rmiObject.Retain();
			}
			if (_nativeHandle == IntPtr.Zero)
			{
				_nativeHandle = pav_AvatarEntity_GetObject(nativeEntityId);
				if (_nativeHandle != IntPtr.Zero && !_allAvatarEntities.ContainsKey(nativeEntityId))
				{
					_nativeEntityId = nativeEntityId;
					_allAvatarEntities.Add(nativeEntityId, this);
					OnLodChanged(lodLevel);
					return true;
				}
				UnityEngine.Debug.LogError("BindEntity failed. NativeHandle is invalid or allready been used.");
				return false;
			}
			OnLodChanged(lodLevel);
			return true;
		}

		public void ForceLod(AvatarLodLevel lodLevel)
		{
			_forceLodLevel = AvatarLodLevel.Invisible;
			if (_rmiObject != null)
			{
				_rmiObject.SetForceLodLevel(lodLevel);
			}
		}

		public void OnLodChanged(AvatarLodLevel lodLevel)
		{
			if (_forceLodLevel < AvatarLodLevel.Lod0 && lodLevel != _activeLodLevel && CheckBuildAvatarLods(lodLevel))
			{
				_deactivingLodLevel = _activeLodLevel;
				_activeLodLevel = lodLevel;
				_avatarLods[(int)lodLevel].AsyncBuildPrimitives();
			}
		}

		public void OnAvatarLodBuildFinished(AvatarLodLevel lodLevel)
		{
			if (owner == null)
			{
				UnityEngine.Debug.LogWarning("AvatarEntity load finished but has been destroyed!");
				return;
			}
			if ((uint)_deactivingLodLevel < 3u)
			{
				_avatarLods[(int)_deactivingLodLevel]?.gameObject.SetActive(value: false);
				_deactivingLodLevel = AvatarLodLevel.Invalid;
			}
			if (lodLevel == _activeLodLevel && _avatarLods[(int)lodLevel] != null)
			{
				_avatarLods[(int)lodLevel]?.gameObject.SetActive(value: true);
				if (!isAnyLodReady)
				{
					isAnyLodReady = true;
					Internal_Initialize();
					owner.Internal_OnAvatarEntityLodReadyToShow(this, lodLevel);
					if (OnAvatarLodReady != null)
					{
						OnAvatarLodReady.Invoke();
						if (PicoAvatarStats.instance != null && _statsFirstLodReadyTime == 0f)
						{
							_statsFirstLodReadyTime = AvatarEnv.realtimeSinceStartup;
							PicoAvatarStats.instance.AvatarLodReady(owner.avatarId, lodLevel, _statsFirstLodReadyTime - _statsStartLoadTime);
						}
					}
				}
				else
				{
					owner.Internal_OnAvatarEntityLodReadyToShow(this, lodLevel);
				}
			}
			if (owner.capabilities.controlSourceType == ControlSourceType.RemoteServer)
			{
				SetPlaybackConfig();
			}
			else
			{
				SetLocalPlaybackConfig();
			}
			if (_rmiObject != null)
			{
				_rmiObject.SetLodLevelLoaded(lodLevel);
			}
		}

		public void Internal_Initialize()
		{
			if (deviceInputReader == null && owner.capabilities.controlSourceType == ControlSourceType.LocalUser && _nativeHandle != IntPtr.Zero)
			{
				DeviceInputReaderBuilder.InputType type = ((PicoAvatarApp.instance != null) ? ((!owner.capabilities.isLocalAvatar) ? PicoAvatarApp.instance.remoteAvatarInputType : PicoAvatarApp.instance.localAvatarInputType) : DeviceInputReaderBuilder.InputType.Editor);
				InitDeviceInputReader(new DeviceInputReaderBuilder().SetType(type).SetUserId(userId));
			}
		}

		public void Internal_Destroy()
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				return;
			}
			isAnyLodReady = false;
			ReferencedObject.ReleaseField(ref _shotPacketMemoryView);
			if (_deviceInputReader != null)
			{
				_deviceInputReader.Release();
				_deviceInputReader = null;
			}
			if (_nativeHandle != IntPtr.Zero)
			{
				if (OnAvatarWillUnBind != null)
				{
					OnAvatarWillUnBind.Invoke();
				}
				DestroyAvatarLods();
				ReferencedObject.ReleaseField(ref _bodyAnimController);
				_allAvatarEntities.Remove(_nativeEntityId);
				_nativeEntityId = 0u;
				NativeObject.ReleaseNative(ref _nativeHandle);
			}
			if (_rmiObject != null)
			{
				_rmiObject.Release();
				_rmiObject = null;
			}
			_owner = null;
			if (debugPlaybackRecorder != null)
			{
				debugPlaybackRecorder.StopRecord();
			}
		}

		public bool InitDeviceInputReader(DeviceInputReaderBuilder builder)
		{
			if (_deviceInputReader != null)
			{
				return false;
			}
			IntPtr nativeObjectPtr = pav_AvatarEntity_GetDeviceInputReader(_nativeHandle);
			if (nativeObjectPtr != IntPtr.Zero)
			{
				_deviceInputReader = builder.Build();
				if (_deviceInputReader != null)
				{
					_deviceInputReader.XRRoot = XRRoot;
					_deviceInputReader.headTarget = headTarget;
					_deviceInputReader.leftHandTarget = leftHandTarget;
					_deviceInputReader.rightHandTarget = rightHandTarget;
					_deviceInputReader.actionBased = actionBasedControl;
					_deviceInputReader.positionActions = positionActions;
					_deviceInputReader.rotationActions = rotationActions;
					_deviceInputReader.buttonActions = buttonActions;
					_deviceInputReader.Initialize(nativeObjectPtr, this);
					_deviceInputReader.Retain();
				}
				else
				{
					NativeObject.ReleaseNative(ref nativeObjectPtr);
				}
			}
			return _deviceInputReader != null;
		}

		public bool setCustomHand(HandSide side, GameObject handSkeleton, GameObject handPose, Vector3 handUp, Vector3 handForward, Vector3 wristOffset)
		{
			if (_nativeHandle == IntPtr.Zero || side == HandSide.Invalid || _owner == null)
			{
				return false;
			}
			pav_AvatarEntity_SetCustomHandSide(_nativeHandle, (uint)side);
			switch (side)
			{
			case HandSide.Left:
				leftCustomHand = true;
				leftCustomHandPose = new AvatarCustomHandPose();
				leftHandPose = handPose;
				leftCustomHandPose.Internal_Initialize(side, handSkeleton, handPose, handUp, handForward, wristOffset, _owner.cachedTransform);
				break;
			case HandSide.Right:
				rightCustomHand = true;
				rightCustomHandPose = new AvatarCustomHandPose();
				rightHandPose = handPose;
				rightCustomHandPose.Internal_Initialize(side, handSkeleton, handPose, handUp, handForward, wristOffset, _owner.cachedTransform);
				break;
			}
			return true;
		}

		public void ClearCustomHand(HandSide side)
		{
			switch (side)
			{
			case HandSide.Left:
				leftCustomHand = false;
				leftCustomHandPose = null;
				break;
			case HandSide.Right:
				rightCustomHand = false;
				rightCustomHandPose = null;
				break;
			}
			pav_AvatarEntity_ClearCustomHandSide(_nativeHandle, (uint)side);
		}

		public void UpdateCustomHandWristXForm()
		{
			if (bodyAnimController != null)
			{
				if (leftCustomHand && leftCustomHandPose != null)
				{
					leftCustomHandPose.SetWristXForm(bodyAnimController);
				}
				if (rightCustomHand && rightCustomHandPose != null)
				{
					rightCustomHandPose.SetWristXForm(bodyAnimController);
				}
			}
		}

		public void UpdateCustomHandPose()
		{
			if (bodyAnimController != null)
			{
				if (leftCustomHand && leftCustomHandPose != null)
				{
					leftCustomHandPose.SetHandPose(bodyAnimController);
				}
				if (rightCustomHand && rightCustomHandPose != null)
				{
					rightCustomHandPose.SetHandPose(bodyAnimController);
				}
			}
		}

		public void ChangeArmLengthWithWrist()
		{
		}

		public void Internal_UpdateFrame()
		{
			if (bodyAnimController != null)
			{
				bodyAnimController.Internal_UpdateFrame();
			}
			if (deviceInputReader != null)
			{
				deviceInputReader.UpdateFrame();
			}
			UpdateCustomHandWristXForm();
		}

		public void Internal_LateUpdateFrame(float elapsedTime)
		{
			if (owner == null || !isAnyLodReady)
			{
				return;
			}
			if (owner.capabilities.controlSourceType == ControlSourceType.LocalApp)
			{
				PicoPlaceholderAvatar picoPlaceholderAvatar = owner as PicoPlaceholderAvatar;
				if (picoPlaceholderAvatar != null && !picoPlaceholderAvatar.isReferenced)
				{
					return;
				}
			}
			else if (PicoAvatarManager.instance.cullAvatarAnimation)
			{
				Plane[] frustumPlanes = PicoAvatarApp.instance.frustumPlanes;
				if (frustumPlanes != null)
				{
					Bounds bounds = new Bounds(base.transform.position + new Vector3(0f, 1f, 0f), new Vector3(1.5f, 2f, 1.5f));
					if (!owner.capabilities.isLocalAvatar && !GeometryUtility.TestPlanesAABB(frustumPlanes, bounds))
					{
						return;
					}
				}
			}
			pav_AvatarEntity_SetVisibleThisFrame(_nativeHandle, visibleThisFrame: true);
			if (bodyAnimController != null)
			{
				bodyAnimController.Internal_LateUpdateFrame();
			}
			UpdateCustomHandPose();
		}

		public void Internal_UpdateSimulationRenderData(float elapsedTime)
		{
			if ((uint)_activeLodLevel < 3u)
			{
				_avatarLods[(int)_activeLodLevel]?.Internal_UpdateSimulationRenderData(elapsedTime);
			}
		}

		public void Internal_OnAvatarSceneLightEnvChanged(PicoAvatarSceneLightEnv lightEnv)
		{
			for (int i = 0; i < 3; i++)
			{
				AvatarLod avatarLod = _avatarLods[i];
				if (avatarLod != null)
				{
					avatarLod.Internal_OnAvatarSceneLightEnvChanged(lightEnv);
				}
			}
		}

		public MemoryView GetFixedPacketMemoryView()
		{
			if (_shotPacketMemoryView == null && _nativeHandle != IntPtr.Zero)
			{
				_shotPacketMemoryView = new MemoryView(pav_AvatarEntity_GetFixedPacketMemoryView(_nativeHandle));
				_shotPacketMemoryView.Retain();
			}
			return _shotPacketMemoryView;
		}

		public void RecordPacket(double timestamp)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("native AvatarEntity destroyed.");
			}
			pav_AvatarEntity_RecordPacket(_nativeHandle, timestamp);
			if (debugPlaybackRecorder != null)
			{
				debugPlaybackRecorder.RecordPacket(GetFixedPacketMemoryView());
			}
		}

		public int ApplyPacket(MemoryView newPacketData)
		{
			if (debugPlaybackRecorder != null)
			{
				debugPlaybackRecorder.RecordPacket(GetFixedPacketMemoryView());
			}
			return pav_AvatarEntity_ApplyPacket(_nativeHandle, newPacketData.nativeHandle);
		}

		private void SetPlaybackConfig()
		{
			PicoAvatarApp instance = PicoAvatarApp.instance;
			pav_AvatarEntity_SetPlaybackPacketConfig(_nativeHandle, instance.avgPlaybackDelayTime, instance.maxPlaybackSpeedRatio, instance.minPlaybackSpeedRatio);
		}

		private void SetLocalPlaybackConfig()
		{
			PicoAvatarApp instance = PicoAvatarApp.instance;
			pav_AvatarEntity_SetSelfPlaybackConfig(_nativeHandle, instance.ikInterpDelayTime);
		}

		protected bool CheckBuildAvatarLods(AvatarLodLevel curLodLevel)
		{
			if ((uint)curLodLevel < 3u)
			{
				if (_avatarLods[(int)curLodLevel] == null)
				{
					IntPtr intPtr = pav_AvatarEntity_GetAvatarLod(_nativeHandle, (uint)curLodLevel);
					if (!(intPtr != IntPtr.Zero))
					{
						return false;
					}
					GameObject obj = new GameObject($"Lod{curLodLevel}");
					obj.hideFlags = HideFlags.DontSave;
					obj.layer = base.gameObject.layer;
					obj.SetActive(value: false);
					obj.transform.parent = base.transform;
					obj.transform.localPosition = Vector3.zero;
					obj.transform.localRotation = Quaternion.identity;
					obj.transform.localScale = Vector3.one;
					AvatarLod avatarLod = obj.AddComponent<AvatarLod>();
					avatarLod.Internal_AttachNative(this, intPtr, curLodLevel);
					_avatarLods[(int)curLodLevel] = avatarLod;
				}
				return true;
			}
			return false;
		}

		protected void DestroyAvatarLods()
		{
			for (uint num = 0u; num < 3; num++)
			{
				if (_avatarLods[num] != null)
				{
					_avatarLods[num].Internal_Destroy();
					UnityEngine.Object.Destroy(_avatarLods[num].gameObject);
					_avatarLods[num] = null;
				}
			}
			_activeLodLevel = AvatarLodLevel.Invisible;
			_deactivingLodLevel = AvatarLodLevel.Invisible;
		}

		[Preserve]
		protected virtual void OnDestroy()
		{
			Internal_Destroy();
		}

		private void LateUpdate()
		{
			if (_deviceInputReader != null)
			{
				_deviceInputReader.StartReadDeviceForNextFrame();
			}
		}

		public XForm GetNativeXForm()
		{
			XForm entityXForm = default(XForm);
			pav_AvatarEntity_GetXForm(_nativeHandle, ref entityXForm);
			return entityXForm;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarEntity_GetObject(uint avatarEntityId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_SetVisibleThisFrame(IntPtr nativeHandle, bool visibleThisFrame);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern MemoryView.NativeData pav_AvatarEntity_GetFixedPacketMemoryView(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_RecordPacket(IntPtr nativeHandle, double timestamp);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_AvatarEntity_ApplyPacket(IntPtr nativeHandle, IntPtr nativeMemoryViewHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_SetPlaybackPacketConfig(IntPtr nativeHandle, float avgDelayTime, float maxPlaybackSpeedRatio, float minPlaybackSpeedRatio);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_SetSelfPlaybackConfig(IntPtr nativeHandle, float selfDelay);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_AvatarEntity_GetActiveLodLevel(IntPtr entityHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarEntity_GetAvatarLod(IntPtr entityHandle, uint lodLevel);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern float pav_AvatarEntity_GetPing(IntPtr entityHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarEntity_GetXForm(IntPtr entityHandle, ref XForm entityXForm);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarEntity_GetBodyAnimController(IntPtr entityHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarEntity_GetDeviceInputReader(IntPtr entityHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_AvatarEntity_GetCustomHandSide(IntPtr nativeHandle, uint side);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_SetCustomHandSide(IntPtr nativeHandle, uint side);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEntity_ClearCustomHandSide(IntPtr nativeHandle, uint side);
	}
	public enum DebugLogMask : uint
	{
		ForceLog = 0u,
		GeneralInfo = 1u,
		GeneralWarn = 2u,
		GeneralError = 4u,
		Framework = 8u,
		AvatarLoad = 32u,
		AvatarIK = 64u,
		AvatarAnimation = 128u,
		NativeCallTrivial = 1024u,
		NativeCallImportant = 2048u,
		NativeCallAll = 3072u,
		EditTrivial = 8192u,
		EditImportant = 16384u,
		AssetTrivial = 262144u,
		AssetImportant = 524288u,
		EngineTrivial = 2097152u,
		EngineImportant = 4194304u,
		NetTrivial = 8388608u,
		ProfileCmd = 134217728u,
		ProfileStatsStart = 33554432u,
		ProfileStatsEnd = 67108864u,
		WholelyDisableLog = 1073741824u
	}
	public delegate void AvatarLogAddedT(DebugLogMask logMask, string message);
	public class AvatarEnv
	{
		public enum EnvironmentFlags
		{
			Playing = 1
		}

		private enum LogSourceLangurage
		{
			Unknown,
			CSharp,
			JS,
			CPlusPlus
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void LogCallback(int debugLogMask, uint contentLen);

		public const string AvatarRelativePath = "AvatarSDKScript/";

		public const string AvatarPackedRelativePath = "AvatarSDKScript.bytes";

		public static bool avatarPackedPathFirst = true;

		public const string CacheRelativePath = "AvatarCache";

		private static bool _initialized = false;

		private static uint _debugLogMasks = 0u;

		private static bool _enableLogTime = false;

		private const int LogContentBufferSize = 10240;

		private static byte[] _logContentBuffer;

		private static GCHandle _handleForLogContentBuffer;

		private const string PavDLLName = "effect";

		public static float realtimeSinceStartup => pav_AvatarEnv_GetRealtimeSinceStartup();

		public static string resourceSpacePath => Application.streamingAssetsPath;

		public static string cacheSpacePath => "/sdcard";

		public static string workSpacePath => Application.persistentDataPath;

		public static string avatarPath => Path.Combine(workSpacePath, "AvatarSDKScript/");

		public static string avatarPackedPath => Path.Combine(workSpacePath, "AvatarSDKScript.bytes");

		public static string avatarCachePath => Path.Combine(cacheSpacePath, "AvatarCache");

		public static event AvatarLogAddedT OnAvatarLogAddedT;

		public static void Internal_Initialize(uint debugLogMasks)
		{
			if (!_initialized)
			{
				uint num = 0u;
				if (Application.isPlaying)
				{
					num |= 1u;
				}
				pav_AvatarEnv_Initialize(0u, num, 1u);
				if (!_handleForLogContentBuffer.IsAllocated)
				{
					_logContentBuffer = new byte[10240];
					_handleForLogContentBuffer = GCHandle.Alloc(_logContentBuffer, GCHandleType.Pinned);
				}
				_debugLogMasks = debugLogMasks;
				pav_AvatarEnv_SetLogCallback(_debugLogMasks, OnLogCalback, _handleForLogContentBuffer.AddrOfPinnedObject(), 10239u);
				if (NeedLog(DebugLogMask.Framework))
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append("avatarPath: ");
					stringBuilder.AppendLine(avatarPath);
					stringBuilder.Append("cachePath: ");
					stringBuilder.AppendLine(avatarCachePath);
					Log(DebugLogMask.Framework, stringBuilder.ToString());
				}
			}
			Application.SetStackTraceLogType(LogType.Log, StackTraceLogType.None);
		}

		public static void UnInitialize()
		{
			if (_initialized)
			{
				_initialized = false;
				if (_handleForLogContentBuffer.IsAllocated)
				{
					_handleForLogContentBuffer.Free();
				}
				pav_AvatarEnv_SetLogCallback(10000u, null, IntPtr.Zero, 0u);
				pav_AvatarEnv_Uninitialize();
			}
		}

		public static void SetDebugLogMasks(uint logMasks)
		{
			_debugLogMasks = logMasks;
			pav_AvatarEnv_SetDebugLogMasks(logMasks);
		}

		public static void SetEnableLogTime(bool enableLogTime)
		{
			_enableLogTime = enableLogTime;
		}

		public static string GetAvatarStats()
		{
			pav_AvatarEnv_LogAvatarStats(_handleForLogContentBuffer.AddrOfPinnedObject(), 10240u);
			return Encoding.ASCII.GetString(_logContentBuffer, 0, 10240);
		}

		public static bool NeedLog(DebugLogMask logMask)
		{
			if (((uint)logMask & _debugLogMasks) != 0)
			{
				return (_debugLogMasks & 0x40000000) == 0;
			}
			return false;
		}

		public static void Log(DebugLogMask debugLogMask, string content)
		{
			if ((_debugLogMasks & 0x40000000u) != 0)
			{
				return;
			}
			if (AvatarEnv.OnAvatarLogAddedT != null)
			{
				AvatarEnv.OnAvatarLogAddedT(debugLogMask, ConcatLogTime(content, LogSourceLangurage.CSharp));
				return;
			}
			switch (debugLogMask)
			{
			case DebugLogMask.GeneralError:
				UnityEngine.Debug.LogError(ConcatLogTime(content, LogSourceLangurage.CSharp));
				break;
			case DebugLogMask.GeneralWarn:
				UnityEngine.Debug.LogWarning(ConcatLogTime(content, LogSourceLangurage.CSharp));
				break;
			default:
				UnityEngine.Debug.Log(ConcatLogTime(content, LogSourceLangurage.CSharp));
				break;
			}
		}

		[MonoPInvokeCallback(typeof(LogCallback))]
		private static void OnLogCalback(int debugLogMask, uint contentLen)
		{
			if (contentLen >= 10240 || (_debugLogMasks & 0x40000000u) != 0)
			{
				return;
			}
			string @string = Encoding.ASCII.GetString(_logContentBuffer, 0, (int)contentLen);
			if (AvatarEnv.OnAvatarLogAddedT != null)
			{
				AvatarEnv.OnAvatarLogAddedT((DebugLogMask)debugLogMask, ConcatLogTime(@string));
				return;
			}
			switch ((DebugLogMask)debugLogMask)
			{
			case DebugLogMask.GeneralError:
				UnityEngine.Debug.LogError(ConcatLogTime(@string));
				break;
			case DebugLogMask.GeneralWarn:
				UnityEngine.Debug.LogWarning(ConcatLogTime(@string));
				break;
			case DebugLogMask.ProfileCmd:
				UnityEngine.Debug.LogWarning(ConcatLogTime(@string));
				break;
			default:
				UnityEngine.Debug.Log(ConcatLogTime(@string));
				break;
			case DebugLogMask.ProfileStatsStart:
			case DebugLogMask.ProfileStatsEnd:
				break;
			}
		}

		private static string ConcatLogTime(string content, LogSourceLangurage logLan = LogSourceLangurage.Unknown)
		{
			if (_enableLogTime)
			{
				float num = realtimeSinceStartup;
				int num2 = Mathf.FloorToInt(num);
				int num3 = (int)((num - (float)num2) * 1000f);
				int num4 = num2 / 60;
				int num5 = num4 / 60;
				num4 %= 60;
				num2 %= 60;
				content = ((num5 != 0) ? (string.Format("pav:{0} {1:D2}:{2:D2}:{3:D2}:{4:D3}: ", (logLan == LogSourceLangurage.CSharp) ? "C#: " : "", num5, num4, num2, num3) + content) : (string.Format("pav:{0} {1:D2}:{2:D2}:{3:D3}: ", (logLan == LogSourceLangurage.CSharp) ? "C#: " : "", num4, num2, num3) + content));
			}
			return content;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarEnv_Initialize(uint version, uint flags, uint targetEngineType);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarEnv_Uninitialize();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarEnv_SetLogCallback(uint debugLogMasks, LogCallback logcallback, IntPtr logContentBuffer, uint logContentBufferSize);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEnv_AddLog(int logLevel, string content, bool backEngine);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_AvatarEnv_SetDebugLogMasks(uint logMasks);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern float pav_AvatarEnv_GetRealtimeSinceStartup();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarEnv_LogAvatarStats(IntPtr contentBuffer, uint bufferSize);
	}
	public class AvatarLod : MonoBehaviour
	{
		public enum Stage
		{
			None,
			Attached,
			Building,
			Working,
			Destroyed
		}

		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		public struct PrimitiveList
		{
			[MarshalAs(UnmanagedType.U8)]
			public ulong count;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.U8)]
			public long[] pointers;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.U8)]
			public ulong[] ids;
		}

		private IntPtr _nativeHandle;

		private IntPtr _nativeRenderMeshHandle;

		private IntPtr _nativeRenderMaterialHandle;

		private Stage _stage;

		private volatile int _workingThreadCount;

		private AvatarLodLevel _lodLevel;

		private Dictionary<uint, AvatarPrimitive> _primitives;

		private List<AvatarPrimitive> _mergedPrimitives;

		private PicoLodMergedRenderMesh _mergedRenderMesh;

		private const string PavDLLName = "effect";

		public AvatarEntity owner { get; private set; }

		public bool isPrimitivesReady { get; private set; }

		public Dictionary<uint, AvatarPrimitive> primitives => _primitives;

		public PicoLodMergedRenderMesh mergedRenderMesh => _mergedRenderMesh;

		public IntPtr nativeHandle => _nativeHandle;

		public AvatarLodLevel lodLevel => _lodLevel;

		public void Internal_AttachNative(AvatarEntity owner, IntPtr nativeAvatarLod, AvatarLodLevel lodLevel)
		{
			if (_stage != Stage.Destroyed)
			{
				if (_nativeHandle != IntPtr.Zero)
				{
					throw new ArgumentException("the PicoAvatarLod has attached to native object.");
				}
				this.owner = owner;
				_lodLevel = lodLevel;
				_nativeHandle = nativeAvatarLod;
				_stage = Stage.Attached;
			}
		}

		public void Internal_Destroy()
		{
			if (_stage != Stage.Destroyed)
			{
				_stage = Stage.Destroyed;
				while (Interlocked.CompareExchange(ref _workingThreadCount, 0, 0) != 0)
				{
					AvatarEnv.Log(DebugLogMask.GeneralInfo, "Wait some ms when loading thread finish before detroy AvatarLod.");
					Thread.Sleep(5);
				}
				DestoryPrimitives();
				DestroyMergedMesh();
				NativeObject.ReleaseNative(ref _nativeRenderMeshHandle);
				NativeObject.ReleaseNative(ref _nativeRenderMaterialHandle);
				NativeObject.ReleaseNative(ref _nativeHandle);
			}
		}

		public void OnDestroy()
		{
			Internal_Destroy();
		}

		public void Internal_UpdateSimulationRenderData(float elapsedTime)
		{
			if (_stage != Stage.Working || !isPrimitivesReady || _primitives == null)
			{
				return;
			}
			if (pav_AvatarLod_GetAndClearAnyPrimitiveDirtyFlag(_nativeHandle))
			{
				foreach (AvatarPrimitive value in _primitives.Values)
				{
					value.Internal_CheckUpdatePrimitiveDrityData();
				}
			}
			foreach (AvatarPrimitive value2 in _primitives.Values)
			{
				value2.Internal_UpdateSimulationRenderData();
			}
			_mergedRenderMesh?.UpdateSimulationRenderData();
		}

		public void Internal_SetAvatarEffectKind(AvatarEffectKind avatarEffectKind)
		{
			foreach (KeyValuePair<uint, AvatarPrimitive> primitive in primitives)
			{
				if ((bool)primitive.Value.primitiveRenderMesh)
				{
					primitive.Value.primitiveRenderMesh.SetAvatarEffectKind(avatarEffectKind);
				}
			}
			if ((bool)mergedRenderMesh)
			{
				mergedRenderMesh.SetAvatarEffectKind(avatarEffectKind);
			}
		}

		public void Internal_OnAvatarSceneLightEnvChanged(PicoAvatarSceneLightEnv lightEnv)
		{
			foreach (KeyValuePair<uint, AvatarPrimitive> primitive in primitives)
			{
				if ((bool)primitive.Value.primitiveRenderMesh)
				{
					primitive.Value.primitiveRenderMesh.Internal_OnAvatarSceneLightEnvChanged(lightEnv);
				}
			}
			if ((bool)mergedRenderMesh)
			{
				mergedRenderMesh.Internal_OnAvatarSceneLightEnvChanged(lightEnv);
			}
		}

		public void OnRenderMeshDestroy(PicoLodMergedRenderMesh meshRenderable)
		{
			_mergedRenderMesh = null;
		}

		public void AsyncBuildPrimitives()
		{
			if (isPrimitivesReady)
			{
				owner.OnAvatarLodBuildFinished(_lodLevel);
				return;
			}
			if (_stage != Stage.Attached)
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "C# AvatarLod can only build primitives when newly attached and native data ready.");
				return;
			}
			_stage = Stage.Building;
			CreateAvatarPrimitives();
			PicoAvatarApp.instance.StartAsyncCoroutine(AsyncCoroutineBuildPrimitives());
		}

		public void PrebuildNativeRenderMeshAndMaterials()
		{
			CreateAvatarPrimitives();
			if (_primitives != null)
			{
				_ = _stage;
				_ = 2;
			}
		}

		private IEnumerator AsyncCoroutineBuildPrimitives()
		{
			Interlocked.Increment(ref _workingThreadCount);
			TryMergePrimitivesInThread();
			Interlocked.Decrement(ref _workingThreadCount);
			yield return PicoAsyncCoroutineYieldType.ToMainThread;
			int accumYieldCount = 0;
			int PrimLoadYieldCount = 4;
			if (_primitives == null || _stage != Stage.Building)
			{
				yield return PicoAsyncCoroutineYieldType.ToExit;
			}
			else if (owner.owner.allowBlockFrameWhenLoading)
			{
				PrimLoadYieldCount = 100;
				yield return PicoAsyncCoroutineYieldType.ToMainThreadFollows;
			}
			if (CreateLodMergedRenderMesh())
			{
				yield return _mergedRenderMesh.BuildFromNativeMeshAndMaterial(GetMergedRenderMeshHandle(), GetMergedRenderMaterialHandle());
			}
			if (_stage != Stage.Building)
			{
				yield break;
			}
			foreach (AvatarPrimitive value in _primitives.Values)
			{
				if (value != null && !value.isMergedToAvatarLod)
				{
					yield return value.Internal_BuildFromNativeRenderMeshAndMaterial();
					if (accumYieldCount++ > PrimLoadYieldCount)
					{
						accumYieldCount = 0;
						yield return PicoAsyncCoroutineYieldType.ToMainThreadFollows;
					}
					if (_stage != Stage.Building)
					{
						yield break;
					}
				}
			}
			if (_stage == Stage.Building)
			{
				_stage = Stage.Working;
				isPrimitivesReady = true;
				owner.OnAvatarLodBuildFinished(_lodLevel);
			}
		}

		private void CreateAvatarPrimitives()
		{
			if (_primitives != null)
			{
				return;
			}
			PrimitiveList primitiveList = default(PrimitiveList);
			primitiveList.count = 100uL;
			if (pav_AvatarLod_GetPrimitives(_nativeHandle, ref primitiveList) != 0)
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "avatar lod has now primitives! avatarId:" + owner.owner.avatarId);
				return;
			}
			Dictionary<uint, AvatarPrimitive> dictionary = new Dictionary<uint, AvatarPrimitive>();
			for (uint num = 0u; num < primitiveList.count; num++)
			{
				uint num2 = (uint)primitiveList.ids[num];
				AvatarPrimitive avatarPrimitive = new AvatarPrimitive((IntPtr)primitiveList.pointers[num], num2, this);
				avatarPrimitive.Retain();
				dictionary.Add(num2, avatarPrimitive);
			}
			_primitives = dictionary;
		}

		private void TryMergePrimitivesInThread()
		{
			if (_primitives == null || _primitives.Count == 0)
			{
				return;
			}
			int count = _primitives.Keys.Count;
			if (!PicoAvatarApp.instance.disablePrimitiveMerge && owner.owner.headShowType == AvatarHeadShowType.Normal)
			{
				_mergedPrimitives = new List<AvatarPrimitive>();
				uint[] array = new uint[count];
				GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
				NativeResult nativeResult = pav_AvatarLod_TryMerge(_nativeHandle, gCHandle.AddrOfPinnedObject(), array.Length);
				if (nativeResult == NativeResult.Success || nativeResult == NativeResult.AlreadyExists)
				{
					for (int i = 0; i < array.Length && array[i] != 0; i++)
					{
						if (PicoAvatarManager.instance == null)
						{
							break;
						}
						AvatarPrimitive avatarPrimitive = _primitives[array[i]];
						avatarPrimitive.Internal_SetMergedByAvatarLod(merged: true);
						_mergedPrimitives.Add(avatarPrimitive);
					}
				}
				else if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
				{
					AvatarEnv.Log(DebugLogMask.AvatarLoad, "AvatarLod: no primitive merged!");
				}
				gCHandle.Free();
			}
			if (_primitives == null)
			{
				return;
			}
			foreach (KeyValuePair<uint, AvatarPrimitive> primitive in _primitives)
			{
				if (!primitive.Value.isMergedToAvatarLod)
				{
					primitive.Value.Internal_PrebuildNativeRenderMeshAndMaterial();
				}
			}
			if (_mergedPrimitives == null || _mergedPrimitives.Count == 0)
			{
				GetMergedRenderMeshHandle();
				GetMergedRenderMaterialHandle();
			}
		}

		private bool CreateLodMergedRenderMesh()
		{
			if (_mergedPrimitives == null || _mergedPrimitives.Count == 0)
			{
				return false;
			}
			if (_mergedRenderMesh != null)
			{
				return true;
			}
			GameObject gameObject = new GameObject("MergedLodMesh");
			gameObject.hideFlags = HideFlags.DontSave;
			gameObject.transform.parent = base.transform;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = Vector3.one;
			gameObject.layer = base.gameObject.layer;
			_mergedRenderMesh = gameObject.AddComponent<PicoLodMergedRenderMesh>();
			_mergedRenderMesh.AttachAvatarLod(this);
			return true;
		}

		private void DestroyMergedMesh()
		{
			if (_mergedRenderMesh != null)
			{
				_mergedRenderMesh.Destroy();
				Utility.Destroy(_mergedRenderMesh);
				_mergedRenderMesh = null;
			}
		}

		private void DestoryPrimitives()
		{
			if (_primitives == null)
			{
				return;
			}
			foreach (KeyValuePair<uint, AvatarPrimitive> primitive in _primitives)
			{
				primitive.Value.Internal_Destory();
				primitive.Value.Release();
			}
			_primitives = null;
		}

		private IntPtr GetMergedRenderMaterialHandle()
		{
			if (_nativeRenderMaterialHandle != IntPtr.Zero)
			{
				return _nativeRenderMaterialHandle;
			}
			_nativeRenderMaterialHandle = pav_AvatarLod_GetMergedRenderMaterial(_nativeHandle);
			return _nativeRenderMaterialHandle;
		}

		private IntPtr GetMergedRenderMeshHandle()
		{
			if (_nativeRenderMeshHandle != IntPtr.Zero)
			{
				return _nativeRenderMeshHandle;
			}
			_nativeRenderMeshHandle = pav_AvatarLod_GetMergedRenderMesh(_nativeHandle);
			return _nativeRenderMeshHandle;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarLod_GetLodLevel(IntPtr avatarLodHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarLod_GetPrimitives(IntPtr avatarLodHandle, ref PrimitiveList primitives);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarLod_GetPrimitive(IntPtr avatarLodHandle, uint nodeId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarLod_TryMerge(IntPtr nativeHandle, IntPtr nodeIds, int nodeIdCount);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarLod_GetMergedRenderMaterial(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarLod_GetMergedRenderMesh(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_AvatarLod_GetAndClearAnyPrimitiveDirtyFlag(IntPtr nativeHandle);
	}
	public class PicoAvatarLodManager
	{
		private static PicoAvatarLodManager _instance;

		private NativeCall_AvatarLodManager _rmiObject;

		public static PicoAvatarLodManager instance => _instance;

		public PicoAvatarLodManager()
		{
			if (_instance == null)
			{
				_instance = this;
			}
		}

		public static void Internal_Initialize()
		{
			if (_instance == null && PicoAvatarApp.instance != null)
			{
				_instance = new PicoAvatarLodManager();
				_instance.Initialize(PicoAvatarApp.instance.forceLodLevel, PicoAvatarApp.instance.maxLodLevel, PicoAvatarApp.instance.lod0ScreenPercetage, PicoAvatarApp.instance.lod1ScreenPercetage, PicoAvatarApp.instance.lod2ScreenPercetage, PicoAvatarApp.instance.lod3ScreenPercetage);
			}
		}

		public static void Internal_Unitialize()
		{
			if (_instance != null)
			{
				_instance.Uninitialize();
				_instance = null;
			}
		}

		public void Internal_SetLodScreenPercentages(float lod0ScreenPercentage, float lod1ScreenPercentage, float lod2ScreenPercentage, float lod3ScreenPercentage)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetLodScreenPercentages(lod0ScreenPercentage, lod1ScreenPercentage, lod2ScreenPercentage, lod3ScreenPercentage);
			}
		}

		public void Internal_SetForceAndMaxLodLevel(AvatarLodLevel forceLodLevel, AvatarLodLevel maxLodLevel)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetForceAndMaxLodLevel(forceLodLevel, maxLodLevel);
			}
		}

		private void Initialize(AvatarLodLevel forceLodLevel, AvatarLodLevel maxLodLevel, float lod0ScreenPercentage, float lod1ScreenPercentage, float lod2ScreenPercentage, float lod3ScreenPercentage)
		{
			if (_rmiObject == null)
			{
				_rmiObject = new NativeCall_AvatarLodManager(this, 0u);
				_rmiObject.Retain();
				_rmiObject.Initialize(forceLodLevel, maxLodLevel, lod0ScreenPercentage, lod1ScreenPercentage, lod2ScreenPercentage, lod3ScreenPercentage);
			}
		}

		public void Uninitialize()
		{
			if (_rmiObject != null)
			{
				_rmiObject.Release();
				_rmiObject = null;
			}
		}
	}
	public delegate void AvatarRequestResponsed(long requestId, int errorCode, string message);
	public delegate void AvatarSpecificationUpdated(PicoAvatar avatar, long requestId, int errorCode, string message);
	public delegate void AvatarLoadFailed(string userId, string avatarId, NativeResult errorCode, string errorDesc);
	public class PicoAvatarManager
	{
		public delegate bool AvatarEntityVisitor(AvatarEntity avatarEntity);

		public delegate bool AvatarVisitor(PicoAvatar avatar);

		public bool cullAvatarAnimation = true;

		private static PicoAvatarManager _instance;

		private IntPtr _nativeHandle = IntPtr.Zero;

		private Dictionary<string, PicoAvatar> _avatarDict = new Dictionary<string, PicoAvatar>();

		private Dictionary<string, AvatarLoadContext> _avatarLoadContexts = new Dictionary<string, AvatarLoadContext>();

		private NativeCall_AvatarManager _rmiObject;

		private const string PavDLLName = "effect";

		public static PicoAvatarManager instance => _instance;

		public static bool isWorking
		{
			get
			{
				if (_instance != null)
				{
					return _instance.isReady;
				}
				return false;
			}
		}

		public bool isReady { get; private set; }

		public static bool canLoadAvatar
		{
			get
			{
				if (PicoAvatarApp.instance == null || !isWorking)
				{
					return false;
				}
				if (PicoAvatarApp.instance.enablePlaceHolder)
				{
					if (_instance.placeHolderOtherAvatar != null)
					{
						return _instance.placeHolderOtherAvatar.isAnyEntityReady;
					}
					return false;
				}
				return true;
			}
		}

		public int avatarCount => _avatarDict.Count;

		public PicoAvatarCamera avatarCamera { get; private set; } = new PicoAvatarCamera();


		public PicoPlaceholderAvatar placeHolderLocalAvatar { get; private set; }

		public PicoPlaceholderAvatar placeHolderOtherAvatar { get; private set; }

		public event AvatarRequestResponsed OnAvatarRequestResponsed;

		public event AvatarSpecificationUpdated OnAvatarSpecificationUpdated;

		public event AvatarLoadFailed OnAvatarLoadFailed;

		public PicoAvatarManager()
		{
			if (_instance == null)
			{
				_instance = this;
			}
		}

		public PicoAvatar GetAvatar(string userId)
		{
			if (_avatarDict.TryGetValue(userId, out var value))
			{
				return value;
			}
			return null;
		}

		public PicoAvatar LoadAvatar(AvatarLoadContext loadContext, Action<long, int, string> responsed = null)
		{
			if (loadContext.capabilities.maxLodLevel < PicoAvatarApp.instance.maxLodLevel)
			{
				loadContext.capabilities.maxLodLevel = PicoAvatarApp.instance.maxLodLevel;
			}
			if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, $"Start LoadAvatar. userId:{loadContext.userId}");
			}
			loadContext.capabilities.animationFlags = PicoAvatarApp.instance.animationFlags;
			if (_avatarLoadContexts.ContainsKey(loadContext.userId))
			{
				_avatarLoadContexts.Remove(loadContext.userId);
			}
			_avatarLoadContexts.Add(loadContext.userId, loadContext);
			if (_avatarDict.TryGetValue(loadContext.userId, out var value))
			{
				UnloadAvatar(loadContext.userId);
			}
			if (loadContext.DoRequest(responsed) == -1)
			{
				return null;
			}
			_avatarDict.TryGetValue(loadContext.userId, out value);
			return value;
		}

		public bool UnloadAvatar(PicoAvatar avatar)
		{
			if (avatar == null)
			{
				return true;
			}
			return UnloadAvatar(avatar.userId);
		}

		public bool UnloadAvatar(string userId)
		{
			_avatarLoadContexts.Remove(userId);
			if (_avatarDict.TryGetValue(userId, out var value))
			{
				_avatarDict.Remove(userId);
				UnloadTheAvatar(value);
				return true;
			}
			AvatarEnv.Log(DebugLogMask.GeneralWarn, "Avatar with the id has been unloaded.");
			return false;
		}

		public void SetDisablePrimitiveMerge(bool disable)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetDisablePrimitiveMerge(disable);
			}
		}

		public void SetAvatarSDKVersion(string version)
		{
			if (_rmiObject != null)
			{
				_rmiObject.SetAvatarSDKVersion(version);
			}
		}

		public void VisitAvatarEntities(AvatarEntityVisitor visitor)
		{
			using Dictionary<string, PicoAvatar>.Enumerator enumerator = _avatarDict.GetEnumerator();
			while (enumerator.MoveNext() && visitor(enumerator.Current.Value.entity))
			{
			}
		}

		public void VisitAvatars(AvatarVisitor visitor)
		{
			using Dictionary<string, PicoAvatar>.Enumerator enumerator = _avatarDict.GetEnumerator();
			while (enumerator.MoveNext() && visitor(enumerator.Current.Value))
			{
			}
		}

		public void ForceUpdateAvatarLods()
		{
			if (PicoAvatarApp.instance.forceLodLevel != AvatarLodLevel.Invalid)
			{
				return;
			}
			avatarCamera?.InternalUpdate();
			foreach (KeyValuePair<string, PicoAvatar> item in _avatarDict)
			{
				item.Value.ForceUpdateLod();
			}
		}

		public void Internal_UpdateFrame(float gameTime)
		{
			if (!isReady)
			{
				return;
			}
			avatarCamera?.InternalUpdate();
			foreach (KeyValuePair<string, PicoAvatar> item in _avatarDict)
			{
				if (item.Value.isActiveAndEnabled)
				{
					item.Value.Internal_UpdateFrame(gameTime);
				}
			}
		}

		public void Internal_LateUpdateFrame(float gameTime)
		{
			avatarCamera?.Internal_LateUpdate();
			foreach (KeyValuePair<string, PicoAvatar> item in _avatarDict)
			{
				if (item.Value.isActiveAndEnabled)
				{
					item.Value.Internal_LateUpdateFrame(gameTime);
				}
			}
			pav_AvatarManager_UpdateAvatarSimulationRenderDatas(_nativeHandle);
			foreach (KeyValuePair<string, PicoAvatar> item2 in _avatarDict)
			{
				if ((bool)item2.Value && item2.Value.isActiveAndEnabled)
				{
					item2.Value.entity?.Internal_UpdateSimulationRenderData(gameTime);
				}
			}
		}

		public void SyncNetSimulation(double serverTime)
		{
			pav_AvatarManager_SyncNetSimulation(_nativeHandle, serverTime);
		}

		public void Internal_Initialize(string avatarAppId, string avatarAppToken, string userToken, double startGameTime, ServerType serverType, AccessType accessType, string nationType = "")
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "AvatrManager initialization failed. nativeHandle is null.");
				return;
			}
			if (_rmiObject != null)
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "Duplicated invoke to initialize.");
				return;
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.AvatrManagerLoginStart();
			}
			if (_rmiObject == null)
			{
				_rmiObject = new NativeCall_AvatarManager(this, 0u);
				_rmiObject.Retain();
			}
			_nativeHandle = pav_AvatarManager_New();
			pav_AvatarManager_Initialize(_nativeHandle, avatarAppId, avatarAppToken, userToken, startGameTime, serverType, accessType, nationType);
		}

		public void Internal_OnInitialized(bool success)
		{
			if (success)
			{
				if (isReady)
				{
					AvatarEnv.Log(DebugLogMask.GeneralError, "AvatarManager has already been initialized");
				}
				isReady = true;
				SetDisablePrimitiveMerge(PicoAvatarApp.instance.disablePrimitiveMerge);
				SetAvatarSDKVersion(PicoAvatarApp.instance.AvatarSDKVersion);
				avatarCamera?.Internal_Initialize();
				PicoAvatarLodManager.Internal_Initialize();
				if (AvatarEnv.NeedLog(DebugLogMask.Framework))
				{
					AvatarEnv.Log(DebugLogMask.Framework, "PicoAvatarManager Initialized.");
				}
				if (PicoAvatarApp.instance.enablePlaceHolder)
				{
					AvatarCapabilities avatarCapabilities = new AvatarCapabilities();
					avatarCapabilities.manifestationType = AvatarManifestationType.Full;
					avatarCapabilities.isLocalAvatar = true;
					avatarCapabilities.bodyCulling = false;
					avatarCapabilities.enablePlaceHolder = false;
					avatarCapabilities.maxLodLevel = AvatarLodLevel.Lod2;
					avatarCapabilities.controlSourceType = ControlSourceType.LocalUser;
					if (PicoAvatarApp.instance.nationType == "" || PicoAvatarApp.instance.nationType == "cn" || PicoAvatarApp.instance.nationType == "cn-test")
					{
						placeHolderLocalAvatar = LoadAvatar(AvatarLoadContext.CreateByJsonConfig(AvatarSpecConfig.userIdPlaceHolder, AvatarSpecConfig.specJsonStrPlaceHolder, avatarCapabilities)) as PicoPlaceholderAvatar;
					}
					else
					{
						placeHolderLocalAvatar = LoadAvatar(AvatarLoadContext.CreateByJsonConfig(AvatarSpecConfig.userIdPlaceHolder, AvatarSpecConfig.specJsonStrPlaceHolderOverSea, avatarCapabilities)) as PicoPlaceholderAvatar;
					}
					placeHolderLocalAvatar.SetHeadShowType(AvatarHeadShowType.Hide);
					placeHolderLocalAvatar.transform.localPosition = Vector3.zero;
					placeHolderLocalAvatar.transform.localScale = Vector3.zero;
					AvatarCapabilities avatarCapabilities2 = new AvatarCapabilities();
					avatarCapabilities2.manifestationType = AvatarManifestationType.Full;
					avatarCapabilities2.isLocalAvatar = false;
					avatarCapabilities2.bodyCulling = false;
					avatarCapabilities2.enablePlaceHolder = false;
					avatarCapabilities2.maxLodLevel = AvatarLodLevel.Lod2;
					avatarCapabilities2.controlSourceType = ControlSourceType.LocalApp;
					if (PicoAvatarApp.instance.nationType == "" || PicoAvatarApp.instance.nationType == "cn" || PicoAvatarApp.instance.nationType == "cn-test")
					{
						placeHolderOtherAvatar = LoadAvatar(AvatarLoadContext.CreateByJsonConfig(AvatarSpecConfig.userIdPlaceHolderOther, AvatarSpecConfig.specJsonStrPlaceHolder, avatarCapabilities2)) as PicoPlaceholderAvatar;
					}
					else
					{
						placeHolderOtherAvatar = LoadAvatar(AvatarLoadContext.CreateByJsonConfig(AvatarSpecConfig.userIdPlaceHolderOther, AvatarSpecConfig.specJsonStrPlaceHolderOverSea, avatarCapabilities2)) as PicoPlaceholderAvatar;
					}
					placeHolderOtherAvatar.SetHeadShowType(AvatarHeadShowType.Normal);
					placeHolderOtherAvatar.transform.localPosition = Vector3.zero;
					placeHolderOtherAvatar.transform.localScale = Vector3.zero;
				}
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.AvatarManagerLoginFinished();
				}
			}
			else
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "Pico AvatarManager failed to initialize.");
			}
			PicoAvatarApp.instance.Internal_OnAvatarManagerInitialize(success);
		}

		public void Internal_Unitialize()
		{
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "Pico AvatarManager Unitialize Start.");
			}
			if (!(_nativeHandle == IntPtr.Zero))
			{
				_instance = null;
				UnloadAllAvatars();
				PicoAvatarLodManager.Internal_Unitialize();
				avatarCamera?.Internal_Destroy();
				if (_rmiObject != null)
				{
					_rmiObject.Release();
					_rmiObject = null;
				}
				if (_nativeHandle != IntPtr.Zero)
				{
					pav_AvatarManager_Shutdown(_nativeHandle);
					NativeObject.ReleaseNative(ref _nativeHandle);
				}
			}
		}

		public void Internal_OnAvatarSceneLightEnvChanged(PicoAvatarSceneLightEnv lightEnv)
		{
			if (_avatarDict == null)
			{
				return;
			}
			foreach (KeyValuePair<string, PicoAvatar> item in _avatarDict)
			{
				item.Value.entity?.Internal_OnAvatarSceneLightEnvChanged(lightEnv);
			}
		}

		private void UnloadTheAvatar(PicoAvatar avatarBase)
		{
			if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, $"UnloadTheAvatar. userId:{avatarBase.userId}");
			}
			if (avatarBase == placeHolderLocalAvatar)
			{
				placeHolderLocalAvatar = null;
			}
			if (avatarBase == placeHolderOtherAvatar)
			{
				placeHolderOtherAvatar = null;
			}
			if (avatarCamera != null && avatarBase == avatarCamera.trakingAvatar)
			{
				avatarCamera.trakingAvatar = null;
			}
			avatarBase.Internal_Destroy();
			if (_rmiObject != null)
			{
				_rmiObject.UnloadAvatar(avatarBase.userId.ToString());
			}
			UnityEngine.Object.Destroy(avatarBase.gameObject);
		}

		private void ResetTheAvatar(string userId)
		{
			if (_rmiObject != null)
			{
				_rmiObject.UnloadAvatar(userId.ToString());
			}
		}

		public void UnloadAllAvatars()
		{
			if (AvatarEnv.NeedLog(DebugLogMask.Framework))
			{
				AvatarEnv.Log(DebugLogMask.Framework, "Pico AvatarManager.UnloadAllAvatars Start.");
			}
			Dictionary<string, PicoAvatar> avatarDict = _avatarDict;
			_avatarDict = new Dictionary<string, PicoAvatar>();
			foreach (KeyValuePair<string, PicoAvatar> item in avatarDict)
			{
				UnloadTheAvatar(item.Value);
			}
		}

		public void Internal_OnRequestDataArrived(long requestId, int errorCode, string jsonStr)
		{
			this.OnAvatarRequestResponsed?.Invoke(requestId, errorCode, jsonStr);
		}

		public void Internal_ProcessAvatarLoadRequest(long requestId, string userId, int errorCode, string msg)
		{
			PicoAvatar avatar = GetAvatar(userId);
			if (avatar != null)
			{
				if (errorCode == 0)
				{
					this.OnAvatarSpecificationUpdated?.Invoke(avatar, requestId, errorCode, msg);
				}
				else
				{
					this.OnAvatarSpecificationUpdated?.Invoke(avatar, requestId, errorCode, msg);
				}
			}
		}

		public void Internal_OnMessage(uint messageType, string content)
		{
		}

		public void Internal_OnAttachNativeAvatar(string userId, string avatarId, uint nativeAvatarId)
		{
			if (!_avatarLoadContexts.TryGetValue(userId, out var value))
			{
				return;
			}
			if (!_avatarDict.TryGetValue(userId, out var value2))
			{
				GameObject gameObject = new GameObject($"PicoAvatar{userId}");
				if (PicoAvatarApp.instance.avatarSceneLayer > 0)
				{
					gameObject.layer = PicoAvatarApp.instance.avatarSceneLayer;
				}
				if (userId == AvatarSpecConfig.userIdPlaceHolder)
				{
					placeHolderLocalAvatar = gameObject.AddComponent<PicoPlaceholderAvatar>();
					placeHolderLocalAvatar.Internal_SetForLocalAvatar(forLocalAvatar: true);
					value2 = placeHolderLocalAvatar;
				}
				else if (userId == AvatarSpecConfig.userIdPlaceHolderOther)
				{
					placeHolderOtherAvatar = gameObject.AddComponent<PicoPlaceholderAvatar>();
					placeHolderOtherAvatar.Internal_SetForLocalAvatar(forLocalAvatar: false);
					value2 = placeHolderOtherAvatar;
				}
				else
				{
					value2 = gameObject.AddComponent<PicoAvatar>();
				}
				value2.Internal_OnAttachNativeAvatar(avatarId, nativeAvatarId);
				value2.Internal_Initialize(userId, avatarId, value);
				_avatarDict[userId] = value2;
			}
			else
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "Duplicated Avatar detected!!!");
			}
		}

		public void Internal_OnAvatarLoadFailed(string userId, string avatarId, NativeResult errorCode, string errorDesc)
		{
			if (this.OnAvatarLoadFailed != null)
			{
				this.OnAvatarLoadFailed(userId, avatarId, errorCode, errorDesc);
				return;
			}
			AvatarEnv.Log(DebugLogMask.GeneralError, $"OnAvatarLoadFailed. userId:{userId} avatarId:{avatarId} reason:{errorCode} desc:{errorDesc}");
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarManager_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarManager_Initialize(IntPtr nativeHandle, string avatarAppId, string avatarAppToken, string userToken, double startGameTime, ServerType serverType, AccessType accessType, string nationType);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarManager_Shutdown(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarManager_SyncNetSimulation(IntPtr nativeHandle, double serverTime);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarManager_UpdateAvatarSimulationRenderDatas(IntPtr nativeHandle);
	}
	public class AvatarMeshBuffer : ReferencedObject
	{
		public MeshInfo meshInfo;

		public MorphAndSkinDataInfo morphAndSkinDataInfo;

		private Mesh _mesh;

		private string[] _boneNames;

		private ComputeBuffer _staticMeshBuffer;

		private bool _hasTangents;

		private static Dictionary<IntPtr, AvatarMeshBuffer> _meshBuffers = new Dictionary<IntPtr, AvatarMeshBuffer>();

		private MeshData _nativeRenderMeshAbstract;

		private NativeArray<Vector3> _meshPositions;

		private NativeArray<Vector3> _meshNormals;

		private NativeArray<Vector3> _meshTangents;

		private ComputeBuffer _meshPositionsBuffer;

		private ComputeBuffer _meshNormalsBuffer;

		private ComputeBuffer _meshTangentshBuffer;

		private int _transferKernel_PN = -1;

		private int _transferKernel_PNT = -1;

		private const int ThreadGroupSize = 64;

		private ComputeShader _computeShader;

		private const string PavDLLName = "effect";

		public Mesh mesh => _mesh;

		public string[] boneNames => _boneNames;

		public ComputeBuffer runtimeBuffer => _staticMeshBuffer;

		public bool hasTangent => _hasTangents;

		public static AvatarMeshBuffer Internal_CreateAndRefMeshBuffer(IntPtr nativeRenderMeshHandle, bool needTangent, bool needSkin)
		{
			if (nativeRenderMeshHandle == IntPtr.Zero)
			{
				return null;
			}
			MeshInfo meshInfo_ = default(MeshInfo);
			if (pav_AvatarRenderMesh_GetMeshInfo(nativeRenderMeshHandle, ref meshInfo_) != 0 || meshInfo_.positionCount == 0)
			{
				return null;
			}
			if (_meshBuffers.TryGetValue(meshInfo_.meshObject, out var value))
			{
				value.GetMorphAndSkinGpuDataInfo(nativeRenderMeshHandle);
				value.Retain();
				return value;
			}
			value = new AvatarMeshBuffer();
			if (!value.Create(nativeRenderMeshHandle, meshInfo_, needTangent, needSkin))
			{
				value.CheckDelete();
				return null;
			}
			value.Retain();
			_meshBuffers.Add(meshInfo_.meshObject, value);
			return value;
		}

		protected override void OnDestroy()
		{
			_meshBuffers.Remove(meshInfo.meshObject);
			if (_staticMeshBuffer != null)
			{
				_staticMeshBuffer.Release();
				_staticMeshBuffer = null;
			}
			if (_mesh != null)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
				_mesh = null;
			}
			if (_meshPositions.Length > 0)
			{
				_meshPositions.Dispose();
				if (_meshNormals.Length > 0)
				{
					_meshNormals.Dispose();
				}
				if (_meshTangents.Length > 0)
				{
					_meshTangents.Dispose();
				}
				if (_meshPositionsBuffer != null)
				{
					_meshPositionsBuffer.Release();
					_meshPositionsBuffer = null;
				}
				if (_meshNormalsBuffer != null)
				{
					_meshNormalsBuffer.Release();
					_meshNormalsBuffer = null;
				}
				if (_meshTangentshBuffer != null)
				{
					_meshTangentshBuffer.Release();
					_meshTangentshBuffer = null;
				}
			}
			base.OnDestroy();
		}

		private bool Create(IntPtr nativeRenderMeshHandle, MeshInfo meshInfo_, bool needTangent, bool needSkin)
		{
			meshInfo = meshInfo_;
			CreateMesh(nativeRenderMeshHandle, needTangent, needSkin);
			if (_mesh != null)
			{
				InitializeGpuData(nativeRenderMeshHandle, needTangent);
			}
			return true;
		}

		protected unsafe void CreateMesh(IntPtr nativeRenderMeshHandle, bool needTangent, bool needSkin)
		{
			_hasTangents = false;
			NativeArray<Vector3> nativeArray = new NativeArray<Vector3>((int)meshInfo.positionCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector3> nativeArray2 = new NativeArray<Vector3>((int)meshInfo.normalCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector4> nativeArray3 = new NativeArray<Vector4>((int)meshInfo.tangentCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Color32> nativeArray4 = new NativeArray<Color32>((int)meshInfo.colorCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector2> nativeArray5 = new NativeArray<Vector2>((int)meshInfo.uvCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector2> nativeArray6 = new NativeArray<Vector2>((int)meshInfo.uv2Count, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector2> nativeArray7 = new NativeArray<Vector2>((int)meshInfo.uv3Count, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<Vector2> nativeArray8 = new NativeArray<Vector2>((int)meshInfo.uv4Count, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			NativeArray<BoneWeight> nativeArray9 = default(NativeArray<BoneWeight>);
			NativeArray<Matrix4x4> nativeArray10 = default(NativeArray<Matrix4x4>);
			NativeArray<IntPtr> nativeArray11 = default(NativeArray<IntPtr>);
			if (needSkin)
			{
				nativeArray9 = new NativeArray<BoneWeight>((int)meshInfo.boneWeightCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
				nativeArray10 = new NativeArray<Matrix4x4>((int)meshInfo.bindPoseBoneCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
				nativeArray11 = new NativeArray<IntPtr>((int)meshInfo.boneNameCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			}
			_nativeRenderMeshAbstract = default(MeshData);
			IntPtr[] array = new IntPtr[8];
			int num = 0;
			GCHandle[] array2 = new GCHandle[20];
			int[][] array3 = new int[8][];
			_nativeRenderMeshAbstract.positions = (IntPtr)nativeArray.GetUnsafePtr();
			_nativeRenderMeshAbstract.normals = ((meshInfo.normalCount == meshInfo.positionCount) ? ((IntPtr)nativeArray2.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.tangents = ((meshInfo.tangentCount == meshInfo.positionCount) ? ((IntPtr)nativeArray3.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.colors = ((meshInfo.colorCount == meshInfo.positionCount) ? ((IntPtr)nativeArray4.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.uv1 = ((meshInfo.uvCount == meshInfo.positionCount) ? ((IntPtr)nativeArray5.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.uv2 = ((meshInfo.uv2Count == meshInfo.positionCount) ? ((IntPtr)nativeArray6.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.uv3 = ((meshInfo.uv3Count == meshInfo.positionCount) ? ((IntPtr)nativeArray7.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.uv4 = ((meshInfo.uv4Count == meshInfo.positionCount) ? ((IntPtr)nativeArray8.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.boneWeights = IntPtr.Zero;
			_nativeRenderMeshAbstract.bindPoses = IntPtr.Zero;
			_nativeRenderMeshAbstract.boneNames = IntPtr.Zero;
			if (needSkin)
			{
				_nativeRenderMeshAbstract.boneWeights = ((meshInfo.boneWeightCount == meshInfo.positionCount) ? ((IntPtr)nativeArray9.GetUnsafePtr()) : IntPtr.Zero);
				_nativeRenderMeshAbstract.bindPoses = ((meshInfo.bindPoseBoneCount != 0) ? ((IntPtr)nativeArray10.GetUnsafePtr()) : IntPtr.Zero);
				_nativeRenderMeshAbstract.boneNames = ((meshInfo.boneNameCount != 0) ? ((IntPtr)nativeArray11.GetUnsafePtr()) : IntPtr.Zero);
			}
			for (int i = 0; i < 8 && meshInfo.indicesCount[i] != 0; i++)
			{
				array3[i] = new int[meshInfo.indicesCount[i]];
				GCHandle gCHandle = GCHandle.Alloc(array3[i], GCHandleType.Pinned);
				array2[num++] = gCHandle;
				array[i] = gCHandle.AddrOfPinnedObject();
			}
			GCHandle gCHandle2 = GCHandle.Alloc(array, GCHandleType.Pinned);
			array2[num++] = gCHandle2;
			_nativeRenderMeshAbstract.indices = gCHandle2.AddrOfPinnedObject();
			NativeResult nativeResult = pav_AvatarRenderMesh_GetMeshData(nativeRenderMeshHandle, ref _nativeRenderMeshAbstract);
			for (int j = 0; j < num; j++)
			{
				array2[j].Free();
			}
			if (nativeResult == NativeResult.Success && Utility.EnableRenderObject)
			{
				_mesh = new Mesh();
				_mesh.SetVertices(nativeArray);
				if (meshInfo.normalCount == meshInfo.positionCount)
				{
					_mesh.SetNormals(nativeArray2);
				}
				if (needTangent && meshInfo.tangentCount == meshInfo.positionCount)
				{
					_hasTangents = true;
					_mesh.SetTangents(nativeArray3);
				}
				if (meshInfo.colorCount == meshInfo.positionCount)
				{
					_mesh.SetColors(nativeArray4);
				}
				if (meshInfo.uvCount == meshInfo.positionCount)
				{
					_mesh.SetUVs(0, nativeArray5);
				}
				if (meshInfo.uv2Count == meshInfo.positionCount)
				{
					_mesh.SetUVs(1, nativeArray6);
				}
				if (meshInfo.uv3Count == meshInfo.positionCount)
				{
					_mesh.SetUVs(2, nativeArray7);
				}
				if (meshInfo.uv4Count == meshInfo.positionCount)
				{
					_mesh.SetUVs(3, nativeArray8);
				}
				if (needSkin)
				{
					if (meshInfo.boneWeightCount == meshInfo.positionCount)
					{
						_mesh.boneWeights = nativeArray9.ToArray();
					}
					if (meshInfo.bindPoseBoneCount != 0)
					{
						_mesh.bindposes = nativeArray10.ToArray();
					}
					if (meshInfo.boneNameCount != 0)
					{
						_boneNames = new string[meshInfo.boneNameCount];
						for (int k = 0; k < _boneNames.Length; k++)
						{
							int l = 0;
							byte* ptr = (byte*)(void*)nativeArray11[k];
							if (ptr != null)
							{
								for (; ptr[l] != 0; l++)
								{
								}
								if (l > 0)
								{
									_boneNames[k] = Encoding.UTF8.GetString(ptr, l);
								}
							}
						}
					}
				}
				_mesh.subMeshCount = (int)meshInfo.subMeshCount;
				for (int m = 0; m < (int)meshInfo.subMeshCount; m++)
				{
					_mesh.SetTriangles(array3[m], m);
				}
				_mesh.bounds = new Bounds(new Vector3(0f, 1f, 0f), new Vector3(1.6f, 2f, 1.2f));
			}
			nativeArray.Dispose();
			nativeArray2.Dispose();
			nativeArray3.Dispose();
			nativeArray4.Dispose();
			nativeArray5.Dispose();
			nativeArray6.Dispose();
			nativeArray7.Dispose();
			nativeArray8.Dispose();
			if (nativeArray9.IsCreated)
			{
				nativeArray9.Dispose();
			}
			if (nativeArray10.IsCreated)
			{
				nativeArray10.Dispose();
			}
			if (nativeArray11.IsCreated)
			{
				nativeArray11.Dispose();
			}
		}

		private NativeResult GetMorphAndSkinGpuDataInfo(IntPtr renderMeshHandle)
		{
			MorphAndSkinDataRequiredInfo requiredInfo = default(MorphAndSkinDataRequiredInfo);
			requiredInfo.version = 0u;
			requiredInfo.flags = 0u;
			requiredInfo.meshVertexDataFormat = 0u;
			requiredInfo.morphVertexDataFormat = 0u;
			return pav_AvatarRenderMesh_GetMorphAndSkinGpuDataInfo(renderMeshHandle, ref requiredInfo, ref morphAndSkinDataInfo);
		}

		protected unsafe void InitializeGpuData(IntPtr renderMeshHandle, bool needTangent)
		{
			if (GetMorphAndSkinGpuDataInfo(renderMeshHandle) == NativeResult.Success && morphAndSkinDataInfo.staticBufferByteSize != 0 && morphAndSkinDataInfo.dynamicBufferByteSize != 0 && morphAndSkinDataInfo.outputBufferByteSize != 0 && Utility.EnableRenderObject)
			{
				NativeArray<int> nativeArray = new NativeArray<int>((int)morphAndSkinDataInfo.staticBufferByteSize / 4, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
				MorphAndSkinResourceGpuData gpuData = default(MorphAndSkinResourceGpuData);
				gpuData.flags = 0u;
				gpuData.version = 0u;
				gpuData.staticBufferByteSize = morphAndSkinDataInfo.staticBufferByteSize;
				gpuData.dataBuffer = (IntPtr)nativeArray.GetUnsafePtr();
				if (pav_AvatarRenderMesh_FillMorphAndSkinResourceGpuData(renderMeshHandle, ref gpuData) == NativeResult.Success)
				{
					_staticMeshBuffer = new ComputeBuffer((int)morphAndSkinDataInfo.staticBufferByteSize / 4, 4, ComputeBufferType.Raw, ComputeBufferMode.Immutable);
					_staticMeshBuffer.SetData(nativeArray);
				}
				nativeArray.Dispose();
			}
		}

		public unsafe void Internal_UpdateMeshPNTData(IntPtr nativeRenderMeshHandle, PicoMaterialConfiguration materialConfiguration, bool needTangents)
		{
			needTangents = false;
			if (meshInfo.positionCount == 0 || meshInfo.normalCount != meshInfo.positionCount || materialConfiguration.transferShapingMeshShader == null || _staticMeshBuffer == null)
			{
				return;
			}
			if (_computeShader == null)
			{
				_computeShader = materialConfiguration.transferShapingMeshShader;
				if (_computeShader == null)
				{
					return;
				}
				_transferKernel_PNT = _computeShader.FindKernel("Transfer_PNT");
				_transferKernel_PN = _computeShader.FindKernel("Transfer_PN");
				if (_transferKernel_PNT < 0 || _transferKernel_PN < 0)
				{
					return;
				}
			}
			if (_meshPositions.Length == 0 && meshInfo.positionCount != 0)
			{
				_meshPositions = new NativeArray<Vector3>((int)meshInfo.positionCount, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			}
			if (_meshNormals.Length == 0 && meshInfo.normalCount != 0)
			{
				_meshNormals = new NativeArray<Vector3>((int)meshInfo.normalCount, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			}
			if (needTangents && _meshTangents.Length == 0 && meshInfo.tangentCount != 0)
			{
				_meshTangents = new NativeArray<Vector3>((int)meshInfo.tangentCount, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			}
			_nativeRenderMeshAbstract.positions = (IntPtr)_meshPositions.GetUnsafePtr();
			_nativeRenderMeshAbstract.normals = ((meshInfo.normalCount == meshInfo.positionCount) ? ((IntPtr)_meshNormals.GetUnsafePtr()) : IntPtr.Zero);
			_nativeRenderMeshAbstract.tangents = ((needTangents && meshInfo.tangentCount == meshInfo.positionCount) ? ((IntPtr)_meshTangents.GetUnsafePtr()) : IntPtr.Zero);
			if (pav_AvatarRenderMesh_GetMeshPNTData(nativeRenderMeshHandle, ref _nativeRenderMeshAbstract) != 0 || !Utility.EnableRenderObject)
			{
				return;
			}
			if (_meshPositionsBuffer == null)
			{
				_meshPositionsBuffer = new ComputeBuffer((int)meshInfo.positionCount, 12, ComputeBufferType.Structured, ComputeBufferMode.Immutable);
			}
			_meshPositionsBuffer.SetData(_meshPositions);
			if (_meshNormals.Length > 0)
			{
				if (_meshNormalsBuffer == null)
				{
					_meshNormalsBuffer = new ComputeBuffer((int)meshInfo.normalCount, 12, ComputeBufferType.Structured, ComputeBufferMode.Immutable);
				}
				_meshNormalsBuffer.SetData(_meshNormals);
			}
			int kernelIndex = _transferKernel_PN;
			if (needTangents && _meshTangents.Length > 0 && meshInfo.tangentCount != 0)
			{
				if (_meshTangentshBuffer == null)
				{
					_meshTangentshBuffer = new ComputeBuffer((int)meshInfo.tangentCount, 16, ComputeBufferType.Structured, ComputeBufferMode.Immutable);
				}
				_meshTangentshBuffer.SetData(_meshTangents);
				kernelIndex = _transferKernel_PNT;
				_computeShader.SetBuffer(kernelIndex, "_tangentBuffer", _meshTangentshBuffer);
			}
			int threadGroupsX = (int)(meshInfo.positionCount + 64 - 1) / 64;
			_computeShader.SetBuffer(kernelIndex, "_positionBuffer", _meshPositionsBuffer);
			_computeShader.SetBuffer(kernelIndex, "_normalBuffer", _meshNormalsBuffer);
			_computeShader.SetBuffer(kernelIndex, "_staticBuffer", _staticMeshBuffer);
			_computeShader.SetInt("_totalVertexCount", (int)meshInfo.positionCount);
			_computeShader.Dispatch(kernelIndex, threadGroupsX, 1, 1);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetMeshInfo(IntPtr nativeHandle, ref MeshInfo meshInfo);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetMeshData(IntPtr nativeHandle, ref MeshData meshData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetMorphAndSkinGpuDataInfo(IntPtr nativeHandle, ref MorphAndSkinDataRequiredInfo requiredInfo, ref MorphAndSkinDataInfo gpuDataInfo);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_FillMorphAndSkinResourceGpuData(IntPtr nativeHandle, ref MorphAndSkinResourceGpuData gpuData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetMeshPNTData(IntPtr nativeHandle, ref MeshData meshData);
	}
	public class AvatarPrimitive : ReferencedObject
	{
		private uint _nodeId;

		private IntPtr _nativeHandle;

		private IntPtr _nativeRenderMeshHandle;

		private IntPtr _nativeRenderMaterialHandle;

		private AvatarLod _owner;

		private PicoPrimitiveRenderMesh _primitiveRenderMesh;

		private AvatarShaderType _mainShaderType = AvatarShaderType.Invalid;

		private uint _nodeFlags = uint.MaxValue;

		private const string PavDLLName = "effect";

		public bool isMergedToAvatarLod { get; private set; }

		public IntPtr nativeHandle => _nativeHandle;

		public AvatarLod owner => _owner;

		public AvatarLodLevel lodLevel => _owner.lodLevel;

		public PicoPrimitiveRenderMesh primitiveRenderMesh => _primitiveRenderMesh;

		public uint nodeTypes
		{
			get
			{
				if (_nodeFlags == uint.MaxValue)
				{
					_nodeFlags = pav_AvatarPrimitive_GetNodeTypes(_nativeHandle);
				}
				return _nodeFlags;
			}
		}

		public AvatarShaderType mainShaderType
		{
			get
			{
				if (_mainShaderType == AvatarShaderType.Invalid)
				{
					_mainShaderType = (AvatarShaderType)pav_AvatarPrimitive_GetMainShaderType(_nativeHandle);
				}
				return _mainShaderType;
			}
		}

		public bool isDestroyed => _nodeId == 0;

		public AvatarPrimitive(IntPtr nativeHandle_, uint nodeId, AvatarLod owner_)
		{
			_nativeHandle = nativeHandle_;
			_nodeId = nodeId;
			_owner = owner_;
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarPrimitive);
			}
		}

		~AvatarPrimitive()
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				AvatarEnv.Log(DebugLogMask.GeneralError, "AvatarPrimitive not destroyed.");
				NativeObject.ReleaseNative(ref _nativeHandle);
			}
		}

		public void Internal_UpdateSimulationRenderData()
		{
			_primitiveRenderMesh?.UpdateSimulationRenderData();
		}

		public void Internal_Destory()
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				_nodeId = 0u;
				DestroyPrimitiveRenderMesh();
				NativeObject.ReleaseNative(ref _nativeRenderMeshHandle);
				NativeObject.ReleaseNative(ref _nativeRenderMaterialHandle);
				if (_nativeHandle != IntPtr.Zero)
				{
					NativeObject.ReleaseNative(ref _nativeHandle);
				}
				if (PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarPrimitive);
				}
			}
		}

		public void Internal_OnRenderMeshDestroy(PicoAvatarRenderMesh meshRenderable)
		{
			_primitiveRenderMesh = null;
		}

		public void Internal_SetMergedByAvatarLod(bool merged)
		{
			isMergedToAvatarLod = merged;
		}

		public IEnumerator Internal_BuildFromNativeRenderMeshAndMaterial()
		{
			CreatePrimitiveRenderMesh();
			if (_primitiveRenderMesh != null)
			{
				yield return _primitiveRenderMesh.BuildFromNativeRenderMeshAndMaterial(GetRenderMeshHandle(), GetRenderMaterialHandle());
			}
		}

		public void Internal_PrebuildNativeRenderMeshAndMaterial()
		{
			GetRenderMeshHandle();
			GetRenderMaterialHandle();
		}

		private IntPtr GetRenderMaterialHandle()
		{
			if (_nativeRenderMaterialHandle != IntPtr.Zero)
			{
				return _nativeRenderMaterialHandle;
			}
			_nativeRenderMaterialHandle = pav_AvatarPrimitive_GetRenderMaterial(_nativeHandle);
			return _nativeRenderMaterialHandle;
		}

		private IntPtr GetRenderMeshHandle()
		{
			if (_nativeRenderMeshHandle != IntPtr.Zero)
			{
				return _nativeRenderMeshHandle;
			}
			_nativeRenderMeshHandle = pav_AvatarPrimitive_GetRenderMesh(_nativeHandle);
			return _nativeRenderMeshHandle;
		}

		private void CreatePrimitiveRenderMesh()
		{
			if (isMergedToAvatarLod || _primitiveRenderMesh != null || !NeedCreateRenderMesh() || (owner.lodLevel > AvatarLodLevel.Lod2 && mainShaderType == AvatarShaderType.Eyelash_Base))
			{
				return;
			}
			GameObject gameObject = new GameObject($"PrimitiveMesh{_nodeId}");
			gameObject.hideFlags = HideFlags.DontSave;
			gameObject.transform.parent = _owner.transform;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = Vector3.one;
			gameObject.layer = owner.gameObject.layer;
			_primitiveRenderMesh = gameObject.AddComponent<PicoPrimitiveRenderMesh>();
			_primitiveRenderMesh.AttachPrimitive(this);
			if ((nodeTypes & (true ? 1u : 0u)) != 0 && owner.owner.owner.headShowType == AvatarHeadShowType.Hide)
			{
				if (PicoAvatarApp.instance.localAvatarHeadSceneLayer < 0)
				{
					gameObject.SetActive(value: false);
				}
				else
				{
					gameObject.layer = PicoAvatarApp.instance.localAvatarHeadSceneLayer;
				}
			}
		}

		public void Internal_CheckUpdatePrimitiveDrityData()
		{
			uint num = pav_AvatarPrimitive_GetAndClearPrimitiveDirtyFlags(_nativeHandle);
			if (_primitiveRenderMesh != null && (num & (true ? 1u : 0u)) != 0)
			{
				_primitiveRenderMesh.UpdateDirtyMeshPNTData();
			}
		}

		protected override void OnDestroy()
		{
			Internal_Destory();
			base.OnDestroy();
		}

		protected void DestroyPrimitiveRenderMesh()
		{
			if (_primitiveRenderMesh != null)
			{
				_primitiveRenderMesh.Destroy();
				Utility.Destroy(_primitiveRenderMesh);
				_primitiveRenderMesh = null;
			}
		}

		private bool NeedCreateRenderMesh()
		{
			return pav_AvatarPrimitive_needCreateRenderMesh(nativeHandle);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_AvatarPrimitive_needCreateRenderMesh(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_AvatarPrimitive_GetMergedToAvatarLod(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarPrimitive_GetNodeTypes(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarPrimitive_GetMainShaderType(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarPrimitive_GetRenderMaterial(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_AvatarPrimitive_GetRenderMesh(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_AvatarPrimitive_GetAndClearPrimitiveDirtyFlags(IntPtr nativeHandle);
	}
	public class PicoAvatarRenderMaterial : NativeObject
	{
		public enum SurfaceType
		{
			Opaque,
			Transparent
		}

		public enum BlendMode
		{
			Alpha,
			Premultiply,
			Additive,
			Multiply
		}

		public enum SmoothnessSource
		{
			BaseAlpha,
			SpecularAlpha
		}

		public enum RenderFace
		{
			Front = 2,
			Back = 1,
			Both = 0
		}

		public enum BlendModeOpt
		{
			Zero,
			One,
			DstColor,
			SrcColor,
			OneMinusDstColor,
			SrcAlpha,
			OneMinusSrcColor,
			DstAlpha,
			OneMinusDstAlpha,
			SrcAlphaSaturate,
			OneMinusSrcAlpha
		}

		public struct AvatarRenderStates
		{
			public AvatarShaderType shaderType;

			public AvatarSceneBlendType sceneBlendType;

			public AvatarRenderFace renderFace;

			public bool zWrite;

			public bool zTest;

			public AvatarPBRWorkflow workflow;

			public AvatarPBRSmoothnessSource smoothSource;
		}

		[StructLayout(LayoutKind.Sequential, Pack = 8)]
		private struct RenderStates
		{
			[MarshalAs(UnmanagedType.I4)]
			public uint shaderType;

			[MarshalAs(UnmanagedType.I1)]
			public byte sceneBlendType;

			[MarshalAs(UnmanagedType.I1)]
			public byte renderFace;

			[MarshalAs(UnmanagedType.I1)]
			public byte zWrite;

			[MarshalAs(UnmanagedType.I1)]
			public byte zTest;

			[MarshalAs(UnmanagedType.I1)]
			public byte workflow;

			[MarshalAs(UnmanagedType.I1)]
			public byte smoothSource;

			[MarshalAs(UnmanagedType.I4)]
			private uint reserved;
		}

		public bool hintCullBack;

		public bool has_OutlineColor;

		public bool has_Outline;

		public bool has_ToonShadowMap;

		public bool has_BaseMap;

		public bool has_BaseColor;

		public bool has_Cutoff;

		public bool has_Smoothness;

		public bool has_GlossMapScale;

		public bool has_SmoothnessTextureChannel;

		public bool has_Metallic;

		public bool has_MetallicGlossMap;

		public bool has_SpecColor = true;

		public bool has_SpecGlossMap;

		public bool has_SpecularHighlights;

		public bool has_EnvironmentReflections;

		public bool has_BumpScale;

		public bool has_BumpMap;

		public bool has_Parallax;

		public bool has_ParallaxMap;

		public bool has_OcclusionStrength;

		public bool has_OcclusionMap;

		public bool has_EmissionColor;

		public bool has_EmissionMap;

		public bool has_DetailMask;

		public bool has_DetailAlbedoMapScale;

		public bool has_DetailAlbedoMap;

		public bool has_DetailNormalMapScale;

		public bool has_DetailNormalMap;

		public bool has_ClearCoatMask;

		public bool has_ClearCoatSmoothness;

		public bool has_SecondBaseMap;

		public bool has_SecondBumpMap;

		public bool has_SecondMetallicSpecGlossMap;

		private MaterialPropertyBlock _propertyBlock = new MaterialPropertyBlock();

		private Material _RuntimeMaterial;

		private bool _Merged;

		private static PicoMaterialConfiguration _MaterialConfig;

		private Color matPV_OutlineColor;

		private float matPV_Outline;

		private AvatarTexture matPV_ToonShadowMap;

		private AvatarTexture matPV_BaseMap;

		private Color matPV_BaseColor;

		private float matPV_Cutoff;

		private float matPV_Smoothness;

		private float matPV_GlossMapScale;

		private float matPV_SmoothnessTextureChannel;

		private float matPV_Metallic;

		private AvatarTexture matPV_MetallicGlossMap;

		private Color matPV_SpecColor;

		private AvatarTexture matPV_SpecGlossMap;

		private int matPV_SpecularHighlights;

		private int matPV_EnvironmentReflections;

		private float matPV_BumpScale;

		private AvatarTexture matPV_BumpMap;

		private float matPV_Parallax;

		private AvatarTexture matPV_ParallaxMap;

		private float matPV_OcclusionStrength;

		private AvatarTexture matPV_OcclusionMap;

		private Color matPV_EmissionColor;

		private AvatarTexture matPV_EmissionMap;

		private AvatarTexture matPV_DetailMask;

		private float matPV_DetailAlbedoMapScale;

		private AvatarTexture matPV_DetailAlbedoMap;

		private float matPV_DetailNormalMapScale;

		private AvatarTexture matPV_DetailNormalMap;

		private float matPV_ClearCoatMask;

		private float matPV_ClearCoatSmoothness;

		private AvatarTexture matPV_SecondBaseMap;

		private AvatarTexture matPV_SecondBumpMap;

		private AvatarTexture matPV_SecondMetallicSpecGlossMap;

		private static bool _initialized;

		private static uint id_ShaderType;

		private static uint id_SceneBlendType;

		private static uint id_OutlineColor;

		private static uint id_Outline;

		private static uint id_ToonShadowMap;

		private static uint id_BaseMap;

		private static uint id_BaseColor;

		private static uint id_Cutoff;

		private static uint id_Smoothness;

		private static uint id_GlossMapScale;

		private static uint id_SmoothnessTextureChannel;

		private static uint id_Metallic;

		private static uint id_MetallicGlossMap;

		private static uint id_SpecColor;

		private static uint id_SpecGlossMap;

		private static uint id_SpecularHighlights;

		private static uint id_EnvironmentReflections;

		private static uint id_BumpScale;

		private static uint id_BumpMap;

		private static uint id_Parallax;

		private static uint id_ParallaxMap;

		private static uint id_OcclusionStrength;

		private static uint id_OcclusionMap;

		private static uint id_EmissionColor;

		private static uint id_EmissionMap;

		private static uint id_DetailMask;

		private static uint id_DetailAlbedoMapScale;

		private static uint id_DetailAlbedoMap;

		private static uint id_DetailNormalMapScale;

		private static uint id_DetailNormalMap;

		private static uint id_ClearCoatMask;

		private static uint id_ClearCoatSmoothness;

		private static uint id_SecondBaseMap;

		private static uint id_SecondBumpMap;

		private static uint id_SecondMetallicSpecGlossMap;

		private const string PavDLLName = "effect";

		public static PicoMaterialConfiguration materialConfiguration => GetMaterialConfiguration();

		public AvatarShaderType mat_ShaderType { get; private set; }

		public AvatarSceneBlendType mat_SceneBlendType { get; private set; }

		public AvatarRenderFace mat_RenderFace { get; private set; }

		public bool mat_ZWrite { get; private set; }

		public bool mat_ZTest { get; private set; }

		public AvatarPBRWorkflow mat_Workflow { get; private set; }

		public AvatarPBRSmoothnessSource mat_SmoothSource { get; private set; }

		public Color mat_OutlineColor => matPV_OutlineColor;

		public float mat_Outline => matPV_Outline;

		public AvatarTexture mat_ToonShadowMap => matPV_ToonShadowMap;

		public AvatarTexture mat_BaseMap => matPV_BaseMap;

		public Color mat_BaseColor => matPV_BaseColor;

		public float mat_Cutoff => matPV_Cutoff;

		public float mat_Smoothness => matPV_Smoothness;

		public float mat_GlossMapScale => matPV_GlossMapScale;

		public float mat_SmoothnessTextureChannel => matPV_SmoothnessTextureChannel;

		public float mat_Metallic => matPV_Metallic;

		public AvatarTexture mat_MetallicGlossMap => matPV_MetallicGlossMap;

		public Color mat_SpecColor => matPV_SpecColor;

		public AvatarTexture mat_SpecGlossMap => matPV_SpecGlossMap;

		public int mat_SpecularHighlights => matPV_SpecularHighlights;

		public int mat_EnvironmentReflections => matPV_EnvironmentReflections;

		public float mat_BumpScale => matPV_BumpScale;

		public AvatarTexture mat_BumpMap => matPV_BumpMap;

		public float mat_Parallax => matPV_Parallax;

		public AvatarTexture mat_ParallaxMap => matPV_ParallaxMap;

		public float mat_OcclusionStrength => matPV_OcclusionStrength;

		public AvatarTexture mat_OcclusionMap => matPV_OcclusionMap;

		public Color mat_EmissionColor => matPV_EmissionColor;

		public AvatarTexture mat_EmissionMap => matPV_EmissionMap;

		public AvatarTexture mat_DetailMask => matPV_DetailMask;

		public float mat_DetailAlbedoMapScale => matPV_DetailAlbedoMapScale;

		public AvatarTexture mat_DetailAlbedoMap => matPV_DetailAlbedoMap;

		public float mat_DetailNormalMapScale => matPV_DetailNormalMapScale;

		public AvatarTexture mat_DetailNormalMap => matPV_DetailNormalMap;

		public float mat_ClearCoatMask => matPV_ClearCoatMask;

		public float mat_ClearCoatSmoothness => matPV_ClearCoatSmoothness;

		public AvatarTexture mat_SecondBaseMap => matPV_SecondBaseMap;

		public AvatarTexture mat_SecondBumpMap => matPV_SecondBumpMap;

		public AvatarTexture mat_SecondMetallicSpecGlossMap => matPV_SecondMetallicSpecGlossMap;

		public PicoAvatarRenderMaterial(bool merged)
		{
			_Merged = merged;
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarRenderMaterial);
			}
		}

		public Material GetRuntimeMaterial(PicoAvatarRenderMesh renderMesh)
		{
			if (_RuntimeMaterial != null)
			{
				return _RuntimeMaterial;
			}
			if (_MaterialConfig == null)
			{
				return null;
			}
			_RuntimeMaterial = _MaterialConfig.ApplyToMaterial(this, renderMesh.lodLevel);
			if (!renderMesh.hasTangent)
			{
				_RuntimeMaterial.EnableKeyword("PAV_NO_TANGENTS");
			}
			if (renderMesh.outPositionBuffer != null)
			{
				_RuntimeMaterial.EnableKeyword("PAV_VERTEX_FROM_BUFFER");
			}
			return _RuntimeMaterial;
		}

		public void Internal_OnAvatarSceneLightEnvChanged(PicoAvatarSceneLightEnv lightEnv)
		{
			if (lightEnv != null && _RuntimeMaterial != null)
			{
				_RuntimeMaterial.SetFloat("_AdditiveGI", lightEnv.additiveGI);
			}
		}

		public void Internal_UpdateMaterial(Material material)
		{
			_MaterialConfig.ApplyToMaterial(this, material);
			material.SetFloat("_ShaderType", (float)mat_ShaderType);
			if (mat_ShaderType == AvatarShaderType.Eyelash_Base)
			{
				_RuntimeMaterial.EnableKeyword("_ALPHABLEND_ON");
			}
			float additiveGI = PicoAvatarApp.instance.additiveGI;
			if (PicoAvatarApp.instance.curAvatarSceneLightEnv != null)
			{
				additiveGI = PicoAvatarApp.instance.curAvatarSceneLightEnv.additiveGI;
			}
			material.SetFloat("_AdditiveGI", additiveGI);
			if (_MaterialConfig.enableMultiLights)
			{
				material.EnableKeyword("_ADDITIONAL_LIGHTS");
			}
			if (mat_BumpMap != null)
			{
				material.EnableKeyword("_NORMALMAP");
			}
			if (mat_MetallicGlossMap != null)
			{
				material.EnableKeyword("_METALLICSPECGLOSSMAP");
				material.DisableKeyword("_SPECULARHIGHLIGHTS_OFF");
				material.DisableKeyword("_SPECULAR_SETUP");
				material.DisableKeyword("_ENVIRONMENTREFLECTIONS_OFF");
			}
			else if (mat_SpecGlossMap != null)
			{
				material.EnableKeyword("_SPECULAR_SETUP");
				material.DisableKeyword("_METALLICSPECGLOSSMAP");
				material.DisableKeyword("_SPECULARHIGHLIGHTS_OFF");
				material.DisableKeyword("_ENVIRONMENTREFLECTIONS_OFF");
			}
			if (mat_EmissionMap != null)
			{
				material.EnableKeyword("_EMISSION");
			}
			if (mat_ParallaxMap != null)
			{
				material.EnableKeyword("_PARALLAXMAP");
			}
			_ = mat_ToonShadowMap;
			if (mat_DetailAlbedoMap != null && mat_DetailMask != null && mat_DetailNormalMap != null)
			{
				material.EnableKeyword("_DETAIL");
			}
			if (mat_SecondBaseMap != null)
			{
				material.EnableKeyword("_SECOND_BASEMAP");
				if (mat_SecondBumpMap != null)
				{
					material.EnableKeyword("_SECOND_NORMALMAP");
				}
				if (mat_SecondMetallicSpecGlossMap != null)
				{
					material.EnableKeyword("_SECOND_METALLICSPECGLOSSMAP");
				}
			}
			if (mat_SceneBlendType == AvatarSceneBlendType.SrcAlpha_OneMinusSrcAlpha)
			{
				_RuntimeMaterial.SetFloat("_Surface", 1f);
				_RuntimeMaterial.SetFloat("_Blend", 0f);
				_RuntimeMaterial.SetFloat("_SrcBlend", 5f);
				_RuntimeMaterial.SetFloat("_DstBlend", 10f);
				_RuntimeMaterial.renderQueue = PicoAvatarApp.instance.avatarTranspQueueStart;
				_RuntimeMaterial.SetOverrideTag("RenderType", "Transparent");
			}
			else if (PicoAvatarApp.instance.avatarOpauqeQueueStart != 2000)
			{
				_RuntimeMaterial.renderQueue = PicoAvatarApp.instance.avatarOpauqeQueueStart;
			}
			float value = 0f;
			_RuntimeMaterial.SetFloat("_Cull", value);
			if (!mat_ZWrite)
			{
				_RuntimeMaterial.SetFloat("_ZWrite", 0f);
			}
			if (!mat_ZTest)
			{
				_RuntimeMaterial.SetFloat("_ZTest", 0f);
			}
			if (PicoAvatarApp.instance != null && PicoAvatarApp.instance.enableRimProfile)
			{
				_RuntimeMaterial.EnableKeyword("PAV_RIM_PROFILE");
			}
		}

		public bool Internal_LoadPropertiesFromNativeMaterial(IntPtr nativeHandle_, AvatarLodLevel lodLevel)
		{
			SetNativeHandle(nativeHandle_, needRetain: true);
			CheckInitialize();
			RenderStates renderStates = default(RenderStates);
			pav_AvatarRenderMaterial_GetRenderStates(nativeHandle_, ref renderStates);
			mat_ShaderType = (AvatarShaderType)renderStates.shaderType;
			mat_SceneBlendType = (AvatarSceneBlendType)renderStates.sceneBlendType;
			mat_RenderFace = (AvatarRenderFace)renderStates.renderFace;
			mat_ZWrite = renderStates.zWrite != 0;
			mat_ZTest = renderStates.zTest != 0;
			mat_Workflow = (AvatarPBRWorkflow)renderStates.workflow;
			mat_SmoothSource = (AvatarPBRSmoothnessSource)renderStates.smoothSource;
			has_Outline = LoadFloat(nativeHandle_, id_Outline, ref matPV_Outline);
			has_Cutoff = LoadFloat(nativeHandle_, id_Cutoff, ref matPV_Cutoff);
			has_Smoothness = LoadFloat(nativeHandle_, id_Smoothness, ref matPV_Smoothness);
			has_GlossMapScale = LoadFloat(nativeHandle_, id_GlossMapScale, ref matPV_GlossMapScale);
			has_SmoothnessTextureChannel = LoadFloat(nativeHandle_, id_SmoothnessTextureChannel, ref matPV_SmoothnessTextureChannel);
			has_Metallic = LoadFloat(nativeHandle_, id_Metallic, ref matPV_Metallic);
			has_BumpScale = LoadFloat(nativeHandle_, id_BumpScale, ref matPV_BumpScale);
			has_Parallax = LoadFloat(nativeHandle_, id_Parallax, ref matPV_Parallax);
			has_OcclusionStrength = LoadFloat(nativeHandle_, id_OcclusionStrength, ref matPV_OcclusionStrength);
			has_DetailAlbedoMapScale = LoadFloat(nativeHandle_, id_DetailAlbedoMapScale, ref matPV_DetailAlbedoMapScale);
			has_DetailNormalMapScale = LoadFloat(nativeHandle_, id_DetailNormalMapScale, ref matPV_DetailNormalMapScale);
			has_ClearCoatMask = LoadFloat(nativeHandle_, id_ClearCoatMask, ref matPV_ClearCoatMask);
			has_ClearCoatSmoothness = LoadFloat(nativeHandle_, id_ClearCoatSmoothness, ref matPV_ClearCoatSmoothness);
			has_OutlineColor = LoadColor(nativeHandle_, id_OutlineColor, ref matPV_OutlineColor);
			has_BaseColor = LoadColor(nativeHandle_, id_BaseColor, ref matPV_BaseColor);
			has_SpecColor = LoadColor(nativeHandle_, id_SpecColor, ref matPV_SpecColor);
			has_EmissionColor = LoadColor(nativeHandle_, id_EmissionColor, ref matPV_EmissionColor);
			ConvertMergedMaterialColorsToLinear();
			if (_MaterialConfig.need_BumpMap && ((lodLevel == AvatarLodLevel.Lod2 && !_MaterialConfig.isLod2NeedBumpMap) || (lodLevel == AvatarLodLevel.Count && !_MaterialConfig.isLod3EnablePBR)))
			{
				matPV_Smoothness = 0.4f;
			}
			else if (mat_Smoothness == 0f)
			{
				matPV_Smoothness = 0.8f;
			}
			else
			{
				matPV_Smoothness = mat_Smoothness;
			}
			has_Smoothness = true;
			SetMergedFloat(-1, id_Smoothness, matPV_Smoothness);
			if (mat_Metallic == 0f)
			{
				matPV_Metallic = 0f;
			}
			else
			{
				matPV_Metallic = mat_Metallic;
			}
			has_Metallic = true;
			SetMergedFloat(-1, id_Metallic, matPV_Metallic);
			if (matPV_SpecColor.r < 0.001f && matPV_SpecColor.g < 0.001f && matPV_SpecColor.b < 0.001f)
			{
				has_SpecColor = true;
				matPV_SpecColor = new Color(0.05f, 0.05f, 0.05f, 0.5f);
			}
			int mergedCount = GetMergedCount();
			for (int i = 0; i < mergedCount; i++)
			{
				Color val = Color.white;
				if (GetMergedColor(i, id_SpecColor, ref val, toGamma: true) && val.r < 0.001f && val.g < 0.001f && val.b < 0.001f)
				{
					SetMergedColor(val: new Color(0.05f, 0.05f, 0.05f, 0.5f), materialIndex: i, propertyID: id_SpecColor);
				}
			}
			if (!has_BaseColor)
			{
				matPV_BaseColor = Color.white;
				has_BaseColor = true;
			}
			return true;
		}

		private void ConvertMergedMaterialColorsToLinear()
		{
			if (!_Merged)
			{
				return;
			}
			int mergedCount = GetMergedCount();
			for (int i = 0; i < mergedCount; i++)
			{
				Color val = Color.white;
				if (GetMergedColor(i, id_OutlineColor, ref val, toGamma: false))
				{
					SetMergedColor(i, id_OutlineColor, val);
				}
				if (GetMergedColor(i, id_BaseColor, ref val, toGamma: false))
				{
					SetMergedColor(i, id_BaseColor, val);
				}
				if (GetMergedColor(i, id_SpecColor, ref val, toGamma: false))
				{
					SetMergedColor(i, id_SpecColor, val);
				}
				if (GetMergedColor(i, id_EmissionColor, ref val, toGamma: false))
				{
					SetMergedColor(i, id_EmissionColor, val);
				}
			}
		}

		public IEnumerator Coroutine_LoadTexturesFromNativeMaterial(bool asyncMode, AvatarLodLevel lodLevel)
		{
			has_ToonShadowMap = false;
			has_BumpMap = false;
			has_ParallaxMap = false;
			has_DetailNormalMap = false;
			has_EmissionMap = false;
			has_DetailMask = false;
			has_DetailAlbedoMap = false;
			new AvatarTextureLoadContext();
			uint accumedTexByteSize3 = 0u;
			uint frameByteSizeCapacity = 8388608u;
			PicoMaterialConfiguration _MaterialConfig = GetMaterialConfiguration();
			has_BaseMap = LoadTexture(base.nativeHandle, id_BaseMap, ref matPV_BaseMap, isLinear: false);
			accumedTexByteSize3 += ((matPV_BaseMap != null) ? matPV_BaseMap.dataSize : 0);
			if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
			{
				accumedTexByteSize3 = 0u;
				yield return null;
			}
			if (base.nativeHandle == IntPtr.Zero)
			{
				yield break;
			}
			if (_MaterialConfig.need_ToonShadowMap)
			{
				has_ToonShadowMap = LoadTexture(base.nativeHandle, id_ToonShadowMap, ref matPV_ToonShadowMap);
			}
			if (lodLevel < AvatarLodLevel.Count || _MaterialConfig.isLod3EnablePBR)
			{
				if (_MaterialConfig.need_MetallicGlossMap)
				{
					has_MetallicGlossMap = LoadTexture(base.nativeHandle, id_MetallicGlossMap, ref matPV_MetallicGlossMap);
					if (has_MetallicGlossMap)
					{
						matPV_Metallic = 0.8f;
						SetMergedFloat(-1, id_Metallic, matPV_Metallic);
					}
					accumedTexByteSize3 += ((matPV_MetallicGlossMap != null) ? matPV_MetallicGlossMap.dataSize : 0);
					if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
					{
						accumedTexByteSize3 = 0u;
						yield return null;
					}
					if (base.nativeHandle == IntPtr.Zero)
					{
						yield break;
					}
				}
				if (_MaterialConfig.need_SpecGlossMap)
				{
					has_SpecGlossMap = LoadTexture(base.nativeHandle, id_SpecGlossMap, ref matPV_SpecGlossMap);
					accumedTexByteSize3 += ((matPV_SpecGlossMap != null) ? matPV_SpecGlossMap.dataSize : 0);
					if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
					{
						accumedTexByteSize3 = 0u;
						yield return null;
					}
					if (base.nativeHandle == IntPtr.Zero)
					{
						yield break;
					}
				}
			}
			if (_MaterialConfig.need_BumpMap && (lodLevel < AvatarLodLevel.Lod2 || _MaterialConfig.isLod2NeedBumpMap))
			{
				has_BumpMap = LoadTexture(base.nativeHandle, id_BumpMap, ref matPV_BumpMap);
				accumedTexByteSize3 += ((matPV_BumpMap != null) ? matPV_BumpMap.dataSize : 0);
				if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
				{
					accumedTexByteSize3 = 0u;
					yield return null;
				}
				if (base.nativeHandle == IntPtr.Zero)
				{
					yield break;
				}
				if (_MaterialConfig.need_ParallaxMap)
				{
					has_ParallaxMap = LoadTexture(base.nativeHandle, id_ParallaxMap, ref matPV_ParallaxMap);
					accumedTexByteSize3 += ((matPV_ParallaxMap != null) ? matPV_ParallaxMap.dataSize : 0);
					if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
					{
						accumedTexByteSize3 = 0u;
						yield return null;
					}
					if (base.nativeHandle == IntPtr.Zero)
					{
						yield break;
					}
				}
				if (_MaterialConfig.need_DetailNormalMap)
				{
					has_DetailNormalMap = LoadTexture(base.nativeHandle, id_DetailNormalMap, ref matPV_DetailNormalMap);
					accumedTexByteSize3 += ((matPV_DetailNormalMap != null) ? matPV_DetailNormalMap.dataSize : 0);
					if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
					{
						accumedTexByteSize3 = 0u;
						yield return null;
					}
					if (base.nativeHandle == IntPtr.Zero)
					{
						yield break;
					}
				}
			}
			if (_MaterialConfig.need_EmissionMap)
			{
				has_EmissionMap = LoadTexture(base.nativeHandle, id_EmissionMap, ref matPV_EmissionMap);
				accumedTexByteSize3 += ((matPV_EmissionMap != null) ? matPV_EmissionMap.dataSize : 0);
				if (asyncMode && accumedTexByteSize3 > frameByteSizeCapacity)
				{
					yield return null;
				}
				if (base.nativeHandle == IntPtr.Zero)
				{
					yield break;
				}
			}
			if (_MaterialConfig.need_DetailMask)
			{
				has_DetailMask = LoadTexture(base.nativeHandle, id_DetailMask, ref matPV_DetailMask);
			}
			if (_MaterialConfig.need_DetailAlbedoMap)
			{
				has_DetailAlbedoMap = LoadTexture(base.nativeHandle, id_DetailAlbedoMap, ref matPV_DetailAlbedoMap);
			}
			if (_MaterialConfig.need_SecondMap)
			{
				has_SecondBaseMap = LoadTexture(base.nativeHandle, id_SecondBaseMap, ref matPV_SecondBaseMap);
				if (_MaterialConfig.need_BumpMap)
				{
					has_SecondBumpMap = LoadTexture(base.nativeHandle, id_SecondBumpMap, ref matPV_SecondBumpMap);
				}
				if (_MaterialConfig.need_MetallicGlossMap || _MaterialConfig.need_SpecGlossMap)
				{
					has_SecondMetallicSpecGlossMap = LoadTexture(base.nativeHandle, id_SecondMetallicSpecGlossMap, ref matPV_SecondMetallicSpecGlossMap);
				}
			}
			_ = base.nativeHandle == IntPtr.Zero;
		}

		protected int GetMergedCount()
		{
			if (!_Merged)
			{
				return 0;
			}
			int materialCount = 0;
			pav_LodMergedAvatarRenderMaterial_getMergedCount(base.nativeHandle, ref materialCount);
			return materialCount;
		}

		protected bool SetMergedFloat(int materialIndex, uint propertyID, float val)
		{
			if (!_Merged)
			{
				return false;
			}
			return pav_LodMergedAvatarRenderMaterial_setFloat(base.nativeHandle, materialIndex, propertyID, ref val) == NativeResult.Success;
		}

		protected bool SetMergedColor(int materialIndex, uint propertyID, Color val)
		{
			if (!_Merged)
			{
				return false;
			}
			val = val.linear;
			return pav_LodMergedAvatarRenderMaterial_setVector4(base.nativeHandle, materialIndex, propertyID, ref val) == NativeResult.Success;
		}

		protected bool GetMergedFloat(int materialIndex, uint propertyID, ref float val)
		{
			if (!_Merged)
			{
				return false;
			}
			return pav_LodMergedAvatarRenderMaterial_getFloat(base.nativeHandle, materialIndex, propertyID, ref val) == NativeResult.Success;
		}

		protected bool GetMergedColor(int materialIndex, uint propertyID, ref Color val, bool toGamma)
		{
			if (!_Merged)
			{
				return false;
			}
			if (pav_LodMergedAvatarRenderMaterial_getVector4(base.nativeHandle, materialIndex, propertyID, ref val) == NativeResult.Success)
			{
				if (toGamma)
				{
					val.r = Mathf.LinearToGammaSpace(val.r);
					val.g = Mathf.LinearToGammaSpace(val.g);
					val.b = Mathf.LinearToGammaSpace(val.b);
				}
				return true;
			}
			return false;
		}

		protected override void OnDestroy()
		{
			ReferencedObject.ReleaseField(ref matPV_ToonShadowMap);
			ReferencedObject.ReleaseField(ref matPV_BaseMap);
			ReferencedObject.ReleaseField(ref matPV_MetallicGlossMap);
			ReferencedObject.ReleaseField(ref matPV_SpecGlossMap);
			ReferencedObject.ReleaseField(ref matPV_BumpMap);
			ReferencedObject.ReleaseField(ref matPV_ParallaxMap);
			ReferencedObject.ReleaseField(ref matPV_EmissionMap);
			ReferencedObject.ReleaseField(ref matPV_DetailMask);
			ReferencedObject.ReleaseField(ref matPV_DetailAlbedoMap);
			ReferencedObject.ReleaseField(ref matPV_DetailNormalMap);
			ReferencedObject.ReleaseField(ref matPV_SecondBaseMap);
			ReferencedObject.ReleaseField(ref matPV_SecondBumpMap);
			ReferencedObject.ReleaseField(ref matPV_SecondMetallicSpecGlossMap);
			if (_RuntimeMaterial != null)
			{
				UnityEngine.Object.DestroyImmediate(_RuntimeMaterial);
				_RuntimeMaterial = null;
			}
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarRenderMaterial);
			}
		}

		private bool LoadTexture(IntPtr renderMaterialHandle, uint propertyID, ref AvatarTexture avatarTex, bool isLinear = true)
		{
			TextureInfo val = default(TextureInfo);
			if (pav_AvatarRenderMaterial_GetTexture(renderMaterialHandle, propertyID, ref val) == NativeResult.Success)
			{
				avatarTex = AvatarTexture.CreateAndRefTexture(ref val, isLinear);
				return true;
			}
			return false;
		}

		private bool LoadFloat(IntPtr renderMaterialHandle, uint propertyID, ref float val)
		{
			return pav_AvatarRenderMaterial_GetFloat(renderMaterialHandle, propertyID, ref val) == NativeResult.Success;
		}

		private bool LoadColor(IntPtr renderMaterialHandle, uint propertyID, ref Color val)
		{
			return pav_AvatarRenderMaterial_GetVector4(renderMaterialHandle, propertyID, ref val) == NativeResult.Success;
		}

		private static PicoMaterialConfiguration GetMaterialConfiguration()
		{
			if (_MaterialConfig != null)
			{
				return _MaterialConfig;
			}
			if (PicoAvatarApp.instance != null)
			{
				_MaterialConfig = PicoAvatarApp.instance.materialConfiguration;
				if (_MaterialConfig != null)
				{
					return _MaterialConfig;
				}
			}
			if (_MaterialConfig == null)
			{
				_MaterialConfig = ScriptableObject.CreateInstance<PicoMaterialConfiguration>();
			}
			return _MaterialConfig;
		}

		private static void CheckInitialize()
		{
			if (!_initialized)
			{
				_initialized = true;
				id_ShaderType = Utility.AddNameToIDNameTable("_ShaderType");
				id_SceneBlendType = Utility.AddNameToIDNameTable("_SceneBlendType");
				id_OutlineColor = Utility.AddNameToIDNameTable("_OutlineColor");
				id_Outline = Utility.AddNameToIDNameTable("_Outline");
				id_ToonShadowMap = Utility.AddNameToIDNameTable("_ToonShadowMap");
				id_BaseMap = Utility.AddNameToIDNameTable("_BaseMap");
				id_BaseColor = Utility.AddNameToIDNameTable("_BaseColor");
				id_Cutoff = Utility.AddNameToIDNameTable("_Cutoff");
				id_Smoothness = Utility.AddNameToIDNameTable("_Smoothness");
				id_GlossMapScale = Utility.AddNameToIDNameTable("_GlossMapScale");
				id_SmoothnessTextureChannel = Utility.AddNameToIDNameTable("_SmoothnessTextureChannel");
				id_Metallic = Utility.AddNameToIDNameTable("_Metallic");
				id_MetallicGlossMap = Utility.AddNameToIDNameTable("_MetallicGlossMap");
				id_SpecColor = Utility.AddNameToIDNameTable("_SpecColor");
				id_SpecGlossMap = Utility.AddNameToIDNameTable("_SpecGlossMap");
				id_SpecularHighlights = Utility.AddNameToIDNameTable("_SpecularHighlights");
				id_EnvironmentReflections = Utility.AddNameToIDNameTable("_EnvironmentReflections");
				id_BumpScale = Utility.AddNameToIDNameTable("_BumpScale");
				id_BumpMap = Utility.AddNameToIDNameTable("_BumpMap");
				id_Parallax = Utility.AddNameToIDNameTable("_Parallax");
				id_ParallaxMap = Utility.AddNameToIDNameTable("_ParallaxMap");
				id_OcclusionStrength = Utility.AddNameToIDNameTable("_OcclusionStrength");
				id_OcclusionMap = Utility.AddNameToIDNameTable("_OcclusionMap");
				id_EmissionColor = Utility.AddNameToIDNameTable("_EmissionColor");
				id_EmissionMap = Utility.AddNameToIDNameTable("_EmissionMap");
				id_DetailMask = Utility.AddNameToIDNameTable("_DetailMask");
				id_DetailAlbedoMapScale = Utility.AddNameToIDNameTable("_DetailAlbedoMapScale");
				id_DetailAlbedoMap = Utility.AddNameToIDNameTable("_DetailAlbedoMap");
				id_DetailNormalMapScale = Utility.AddNameToIDNameTable("_DetailNormalMapScale");
				id_DetailNormalMap = Utility.AddNameToIDNameTable("_DetailNormalMap");
				id_ClearCoatMask = Utility.AddNameToIDNameTable("_ClearCoatMask");
				id_ClearCoatSmoothness = Utility.AddNameToIDNameTable("_ClearCoatSmoothness");
				id_SecondBaseMap = Utility.AddNameToIDNameTable("_SecondBaseMap");
				id_SecondBumpMap = Utility.AddNameToIDNameTable("_SecondBumpMap");
				id_SecondMetallicSpecGlossMap = Utility.AddNameToIDNameTable("_SecondMetallicSpecGlossMap");
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetRenderStates(IntPtr nativeHandle, ref RenderStates renderStates);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetBool(IntPtr nativeHandle, uint propertyID, ref bool val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetFloat(IntPtr nativeHandle, uint propertyID, ref float val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetInt(IntPtr nativeHandle, uint propertyID, ref int val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetVector3(IntPtr nativeHandle, uint propertyID, ref Vector3 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetVector4(IntPtr nativeHandle, uint propertyID, ref Vector4 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetVector4(IntPtr nativeHandle, uint propertyID, ref Color val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMaterial_GetTexture(IntPtr nativeHandle, uint propertyID, ref TextureInfo val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_LodMergedAvatarRenderMaterial_getMergedCount(IntPtr nativeHandle, ref int materialCount);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_LodMergedAvatarRenderMaterial_setFloat(IntPtr nativeHandle, int materialIndex, uint propertyID, ref float val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_LodMergedAvatarRenderMaterial_setVector4(IntPtr nativeHandle, int materialIndex, uint propertyID, ref Color val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_LodMergedAvatarRenderMaterial_getFloat(IntPtr nativeHandle, int materialIndex, uint propertyID, ref float val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_LodMergedAvatarRenderMaterial_getVector4(IntPtr nativeHandle, int materialIndex, uint propertyID, ref Color val);
	}
	public class PicoAvatarRenderMesh : MonoBehaviour
	{
		private bool _HasTangent = true;

		public AvatarLodLevel _CachedLodLevel;

		private IntPtr _nativeHandler;

		private bool _isRenderDataReady;

		private bool _isRenderMeshDataReady;

		private bool _isRenderMaterialDataReady;

		private AvatarMeshBuffer _staticMeshBuffer;

		private bool _mergedMesh;

		private PicoMaterialConfiguration _materialConfiguration;

		private ComputeBuffer _DynamicBuffer;

		private NativeArray<int> _DynamicCpuData;

		private MorphAndSkinSimulationGpuData _DynamicGpuDataInfo;

		private ComputeBuffer _OutPositionBuffer;

		private Texture2D _MaterialDataTexture;

		private MeshFilter _MeshFilter;

		private MeshRenderer _meshRenderer;

		private const int ThreadGroupSize = 64;

		private ComputeShader _computeShader;

		private int _computedFrame = -1;

		private int _skinMorphKernel_PN = -1;

		private int _skinMorphKernel_PNT = -1;

		private bool _materialNeedTangent;

		private NativeArray<Matrix4x4> _boneMatrices;

		private SkinnedMeshRenderer _skin;

		private Matrix4x4[] _bindposes;

		private Transform[] _boneTransforms;

		private const string PavDLLName = "effect";

		public MeshRenderer meshRenderer => _meshRenderer;

		public ComputeBuffer outPositionBuffer => _OutPositionBuffer;

		public bool hasTangent => _HasTangent;

		public AvatarLodLevel lodLevel => _CachedLodLevel;

		public PicoAvatarRenderMaterial renderMaterial { get; private set; }

		public AvatarEffectKind avatarEffectKind { get; protected set; }

		public bool isRenderDataReady => _isRenderDataReady;

		public bool isRenderMeshDataReady => _isRenderMeshDataReady;

		public bool isRenderMaterialDataReady => _isRenderMaterialDataReady;

		public PicoAvatarRenderMesh()
		{
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarRenderMesh);
			}
		}

		public virtual void Destroy()
		{
			if (!(_materialConfiguration == null))
			{
				_isRenderDataReady = false;
				_isRenderMeshDataReady = false;
				if (_MeshFilter != null)
				{
					_MeshFilter.sharedMesh = null;
					_MeshFilter = null;
				}
				if ((bool)_meshRenderer)
				{
					_meshRenderer.sharedMaterial = null;
					_meshRenderer = null;
				}
				if (renderMaterial != null)
				{
					renderMaterial.Release();
					renderMaterial = null;
				}
				ReferencedObject.ReleaseField(ref _staticMeshBuffer);
				if ((bool)_MaterialDataTexture)
				{
					Utility.DestroyImmediate(_MaterialDataTexture);
					_MaterialDataTexture = null;
				}
				if (_DynamicBuffer != null)
				{
					_DynamicBuffer.Release();
					_DynamicBuffer = null;
				}
				if (_OutPositionBuffer != null)
				{
					_OutPositionBuffer.Release();
					_OutPositionBuffer = null;
				}
				if (_DynamicCpuData.IsCreated)
				{
					_DynamicCpuData.Dispose();
				}
				if (_boneMatrices.IsCreated)
				{
					_boneMatrices.Dispose();
				}
				NativeObject.ReleaseNative(ref _nativeHandler);
				if (_materialConfiguration != null && PicoAvatarStats.instance != null)
				{
					PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarRenderMesh);
				}
				_materialConfiguration = null;
			}
		}

		public virtual void OnDestroy()
		{
			Destroy();
		}

		public virtual void UpdateSimulationRenderData()
		{
		}

		protected void SetMaterial(PicoAvatarRenderMaterial mat)
		{
			if (meshRenderer == null)
			{
				return;
			}
			Material runtimeMaterial = mat.GetRuntimeMaterial(this);
			if (runtimeMaterial == null)
			{
				if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
				{
					AvatarEnv.Log(DebugLogMask.AvatarLoad, "Failed to get runtime material.");
				}
			}
			else
			{
				UpdateMaterial(mat, runtimeMaterial);
				meshRenderer.sharedMaterial = runtimeMaterial;
				meshRenderer.SetPropertyBlock(new MaterialPropertyBlock());
				_isRenderDataReady = true;
			}
		}

		protected void UpdateMaterial(PicoAvatarRenderMaterial mat, Material material)
		{
			mat.Internal_UpdateMaterial(material);
			if (_mergedMesh)
			{
				material.EnableKeyword("PAV_MERGED_TEXTURE");
			}
			material.SetBuffer("_staticBuffer", _staticMeshBuffer.runtimeBuffer);
			material.SetBuffer("_dynamicBuffer", _DynamicBuffer);
			material.SetBuffer("_outputBuffer", _OutPositionBuffer);
			material.SetInt("_staticBufferOffset", (int)_staticMeshBuffer.morphAndSkinDataInfo.staticBufferOffset);
			material.SetInt("_dynamicBufferOffset", (int)_staticMeshBuffer.morphAndSkinDataInfo.dynamicBufferOffset);
			material.SetInt("_vertexIndexOffset", 0);
			if ((bool)_MaterialDataTexture)
			{
				material.SetTexture("_materialDataTexture", _MaterialDataTexture);
				material.SetVector("_materialDataTextureSize", new Vector4(_MaterialDataTexture.width, _MaterialDataTexture.height, 0f, 0f));
			}
			if (PicoAvatarApp.instance.forceDisableReceiveShadow)
			{
				material.DisableKeyword("_MAIN_LIGHT_SHADOWS");
				material.DisableKeyword("_MAIN_LIGHT_SHADOWS_CASCADE");
				material.DisableKeyword("SHADOWS_SHADOWMASK");
				material.EnableKeyword("_RECEIVE_SHADOWS_OFF");
				material.SetFloat("_ReceiveShadows", 0f);
			}
			if (avatarEffectKind != 0 && avatarEffectKind == AvatarEffectKind.SimpleOutline)
			{
				material.EnableKeyword("PAV_AVATAR_LOD_OUTLINE");
				material.SetFloat("_Surface", 0f);
				material.SetFloat("_ColorMask", 0f);
			}
			_materialNeedTangent = mat.has_BumpMap;
			if (!material.HasProperty(PicoAvatarApp.instance.materialConfiguration.unityID_BumpMap))
			{
				_materialNeedTangent = false;
			}
			if (lodLevel >= AvatarLodLevel.Lod2)
			{
				material.SetFloat("_BaseColorAmplify", 0.8f);
			}
		}

		public void OnShaderChanged()
		{
			if (!(meshRenderer == null) && renderMaterial != null && isRenderDataReady)
			{
				Material sharedMaterial = meshRenderer.sharedMaterial;
				if ((bool)sharedMaterial)
				{
					UpdateMaterial(renderMaterial, sharedMaterial);
				}
				meshRenderer.sharedMaterial = sharedMaterial;
			}
		}

		public virtual AvatarLod GetAvatarLod()
		{
			return null;
		}

		public void SetAvatarEffectKind(AvatarEffectKind avatarEffectKind_)
		{
			if (avatarEffectKind == avatarEffectKind_)
			{
				return;
			}
			avatarEffectKind = avatarEffectKind_;
			if ((bool)meshRenderer)
			{
				Material sharedMaterial = meshRenderer.sharedMaterial;
				if (sharedMaterial != null)
				{
					Material material = new Material(sharedMaterial.shader);
					UpdateMaterial(renderMaterial, material);
					meshRenderer.sharedMaterial = material;
				}
			}
		}

		public void Internal_OnAvatarSceneLightEnvChanged(PicoAvatarSceneLightEnv lightEnv)
		{
			if (renderMaterial != null)
			{
				renderMaterial.Internal_OnAvatarSceneLightEnvChanged(lightEnv);
			}
		}

		protected IEnumerator CreateUnityRenderMesh(bool asyncMode, IntPtr renderMeshHandle, AvatarLodLevel lodLevel_, IntPtr owner, bool mergedMesh, AvatarShaderType mainShaderType = AvatarShaderType.Invalid)
		{
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "AvatarRenderMesh.CreateUnityRenderMesh.Start");
			}
			if (_MeshFilter != null || renderMeshHandle == IntPtr.Zero || _staticMeshBuffer != null)
			{
				yield break;
			}
			bool enableSkin = Utility.EnableSkin;
			_materialConfiguration = PicoAvatarRenderMaterial.materialConfiguration;
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "start AvatarRenderMesh.CreateUnityRenderMesh.CreateAndRefMeshBuffer");
			}
			_staticMeshBuffer = AvatarMeshBuffer.Internal_CreateAndRefMeshBuffer(renderMeshHandle, _materialConfiguration.needTangent, enableSkin);
			if (_staticMeshBuffer == null)
			{
				yield break;
			}
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "finished AvatarRenderMesh.CreateUnityRenderMesh.CreateAndRefMeshBuffer");
			}
			_CachedLodLevel = lodLevel_;
			_mergedMesh = mergedMesh;
			if (_nativeHandler != renderMeshHandle)
			{
				if (renderMeshHandle != IntPtr.Zero)
				{
					NativeObject.RetainNative(renderMeshHandle);
				}
				if (_nativeHandler != IntPtr.Zero)
				{
					NativeObject.ReleaseNative(ref _nativeHandler);
				}
				_nativeHandler = renderMeshHandle;
			}
			_HasTangent = _staticMeshBuffer.hasTangent;
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "start AvatarRenderMesh.CreateUnityRenderMesh.CrateMeshRenderer");
			}
			_MeshFilter = base.gameObject.AddComponent<MeshFilter>();
			_MeshFilter.sharedMesh = _staticMeshBuffer.mesh;
			_meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			if (PicoAvatarApp.instance.forceDisableCastShadow || mainShaderType == AvatarShaderType.Eyelash_Base)
			{
				_meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			}
			if (PicoAvatarApp.instance.forceDisableReceiveShadow || lodLevel_ > AvatarLodLevel.Lod2)
			{
				_meshRenderer.receiveShadows = false;
			}
			if (enableSkin)
			{
				GameObject gameObject = new GameObject("skin");
				gameObject.transform.parent = base.gameObject.transform;
				gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.transform.localScale = new Vector3(1f, 1f, -1f);
				SkinnedMeshRenderer skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				skinnedMeshRenderer.sharedMesh = _staticMeshBuffer.mesh;
				skinnedMeshRenderer.sharedMaterial = new Material(Shader.Find("Universal Render Pipeline/Simple Lit"));
				Transform[] array = new Transform[_staticMeshBuffer.meshInfo.bindPoseBoneCount];
				_boneTransforms = new Transform[array.Length];
				for (int i = 0; i < _staticMeshBuffer.meshInfo.bindPoseBoneCount; i++)
				{
					GameObject gameObject2 = new GameObject(i.ToString());
					gameObject2.transform.parent = gameObject.transform;
					array[i] = gameObject2.transform;
					if (_staticMeshBuffer.boneNames != null && !string.IsNullOrEmpty(_staticMeshBuffer.boneNames[i]))
					{
						gameObject2.gameObject.name = _staticMeshBuffer.boneNames[i];
					}
				}
				for (int j = 0; j < _staticMeshBuffer.meshInfo.bindPoseBoneCount; j++)
				{
					GameObject gameObject3 = new GameObject("t_" + j);
					gameObject3.transform.parent = gameObject.transform;
					_boneTransforms[j] = gameObject3.transform;
					if (_staticMeshBuffer.boneNames != null && !string.IsNullOrEmpty(_staticMeshBuffer.boneNames[j]))
					{
						gameObject3.gameObject.name = "t_" + _staticMeshBuffer.boneNames[j];
					}
				}
				skinnedMeshRenderer.bones = array;
				Matrix4x4[] bindposes = skinnedMeshRenderer.sharedMesh.bindposes;
				_bindposes = new Matrix4x4[bindposes.Length];
				for (int k = 0; k < bindposes.Length; k++)
				{
					_bindposes[k] = bindposes[k];
					bindposes[k] = Matrix4x4.identity;
				}
				skinnedMeshRenderer.sharedMesh.bindposes = bindposes;
				_skin = skinnedMeshRenderer;
			}
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "finished AvatarRenderMesh.CreateUnityRenderMesh.CrateMeshRenderer");
			}
			if (asyncMode)
			{
				yield return null;
			}
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "start AvatarRenderMesh.CreateUnityRenderMesh.InitializeSimulationGpuData");
			}
			InitializeSimulationGpuData(owner);
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "finished AvatarRenderMesh.CreateUnityRenderMesh.InitializeSimulationGpuData");
			}
			_isRenderMeshDataReady = true;
			if (asyncMode && AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "AvatarRenderMesh.CreateUnityRenderMesh.end");
			}
		}

		protected unsafe void InitializeSimulationGpuData(IntPtr owner)
		{
			if (_staticMeshBuffer == null || _staticMeshBuffer.runtimeBuffer == null)
			{
				return;
			}
			uint dynamicBufferByteSize = _staticMeshBuffer.morphAndSkinDataInfo.dynamicBufferByteSize;
			_DynamicBuffer = new ComputeBuffer((int)dynamicBufferByteSize / 4, 4, ComputeBufferType.Raw, ComputeBufferMode.SubUpdates);
			_DynamicCpuData = new NativeArray<int>((int)dynamicBufferByteSize / 4, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			_DynamicGpuDataInfo = default(MorphAndSkinSimulationGpuData);
			_DynamicGpuDataInfo.flags = 0u;
			_DynamicGpuDataInfo.version = 0u;
			_DynamicGpuDataInfo.dynamicBufferByteSize = dynamicBufferByteSize;
			_DynamicGpuDataInfo.dataBuffer = (IntPtr)_DynamicCpuData.GetUnsafePtr();
			_DynamicGpuDataInfo.boneMatrices = IntPtr.Zero;
			_DynamicGpuDataInfo.materialData = IntPtr.Zero;
			if ((bool)_skin)
			{
				_boneMatrices = new NativeArray<Matrix4x4>((int)_staticMeshBuffer.meshInfo.bindPoseBoneCount, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
				_DynamicGpuDataInfo.boneMatrices = (IntPtr)_boneMatrices.GetUnsafePtr();
			}
			if (_staticMeshBuffer.morphAndSkinDataInfo.materialDataByteSize != 0)
			{
				uint num = _staticMeshBuffer.morphAndSkinDataInfo.materialDataByteSize / 16;
				uint num2 = num / 256;
				if (num % 256 != 0)
				{
					num2++;
				}
				_MaterialDataTexture = new Texture2D(256, (int)num2, GraphicsFormat.R32G32B32A32_SFloat, 1, TextureCreationFlags.None);
			}
			uint outputBufferByteSize = _staticMeshBuffer.morphAndSkinDataInfo.outputBufferByteSize;
			_OutPositionBuffer = new ComputeBuffer((int)outputBufferByteSize / 4, 4, ComputeBufferType.Structured);
			if (_staticMeshBuffer.runtimeBuffer != null && _DynamicBuffer != null && _OutPositionBuffer != null)
			{
				_computeShader = _materialConfiguration.morphAndSkinningShader;
				if ((bool)_computeShader)
				{
					_skinMorphKernel_PNT = _computeShader.FindKernel("CSMain_PNT");
					_skinMorphKernel_PN = _computeShader.FindKernel("CSMain_PN");
				}
				else if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
				{
					AvatarEnv.Log(DebugLogMask.GeneralError, "AvatarRenderMesh missing compute shader");
				}
			}
			UpdateMorphAndSkinSimulationBuffer(owner);
		}

		protected unsafe void UpdateMorphAndSkinSimulationBuffer(IntPtr owner)
		{
			if (!Utility.EnableRenderObject || !Utility.EnableSDKUpdate || _computedFrame == Time.frameCount || _DynamicBuffer == null || _staticMeshBuffer == null || _OutPositionBuffer == null)
			{
				return;
			}
			_DynamicGpuDataInfo.owner = owner;
			bool flag = false;
			if ((bool)_MaterialDataTexture)
			{
				NativeArray<float> rawTextureData = _MaterialDataTexture.GetRawTextureData<float>();
				_DynamicGpuDataInfo.materialData = (IntPtr)rawTextureData.GetUnsafePtr();
			}
			if (_nativeHandler != IntPtr.Zero && _DynamicBuffer != null)
			{
				NativeArray<int> nativeArray = _DynamicBuffer.BeginWrite<int>(0, _DynamicBuffer.count);
				_DynamicGpuDataInfo.dataBuffer = (IntPtr)nativeArray.GetUnsafePtr();
				if (pav_AvatarRenderMesh_FillMorphAndSkinSimulationGpuData(_nativeHandler, ref _DynamicGpuDataInfo) == NativeResult.Success)
				{
					flag = true;
				}
				_DynamicBuffer.EndWrite<int>(_DynamicBuffer.count);
			}
			if (!flag)
			{
				UnityEngine.Debug.LogError("AvatarRenderMesh pav_AvatarRenderMesh_FillMorphAndSkinSimulationGpuData failed");
			}
			if (flag && (bool)_skin)
			{
				Vector3 localPosition = default(Vector3);
				for (int i = 0; i < _boneMatrices.Length; i++)
				{
					Matrix4x4 matrix4x = _boneMatrices[i];
					localPosition.x = matrix4x.m03;
					localPosition.y = matrix4x.m13;
					localPosition.z = matrix4x.m23;
					Vector3 lossyScale = matrix4x.lossyScale;
					_skin.bones[i].localScale = lossyScale;
					_skin.bones[i].localRotation = matrix4x.rotation;
					_skin.bones[i].localPosition = localPosition;
					matrix4x = _boneMatrices[i] * _bindposes[i].inverse;
					localPosition.x = matrix4x.m03;
					localPosition.y = matrix4x.m13;
					localPosition.z = matrix4x.m23;
					lossyScale = matrix4x.lossyScale;
					_boneTransforms[i].localScale = lossyScale;
					_boneTransforms[i].localRotation = matrix4x.rotation;
					_boneTransforms[i].localPosition = localPosition;
				}
			}
			if (flag && (bool)_MaterialDataTexture && _DynamicGpuDataInfo.materialDataDirty)
			{
				_MaterialDataTexture.Apply(updateMipmaps: false, makeNoLongerReadable: false);
			}
			if (flag)
			{
				int num = ((_materialNeedTangent && _HasTangent) ? _skinMorphKernel_PNT : _skinMorphKernel_PN);
				if (num >= 0)
				{
					int threadGroupsX = (int)(_staticMeshBuffer.meshInfo.positionCount + 64 - 1) / 64;
					_computeShader.SetBuffer(num, "_staticBuffer", _staticMeshBuffer.runtimeBuffer);
					_computeShader.SetBuffer(num, "_dynamicBuffer", _DynamicBuffer);
					_computeShader.SetBuffer(num, "_outputBuffer", _OutPositionBuffer);
					_computeShader.SetInt("_meshInstanceCount", 1);
					_computeShader.SetInt("_totalVertexCount", (int)_staticMeshBuffer.meshInfo.positionCount);
					_computeShader.Dispatch(num, threadGroupsX, 1, 1);
					_computedFrame = Time.frameCount;
				}
			}
		}

		protected bool CreateRenderMaterial(IntPtr renderMaterialHandle, AvatarLodLevel lodLevel, bool merged)
		{
			if (renderMaterial == null)
			{
				renderMaterial = new PicoAvatarRenderMaterial(merged);
				renderMaterial.Retain();
				if (!renderMaterial.Internal_LoadPropertiesFromNativeMaterial(renderMaterialHandle, lodLevel))
				{
					renderMaterial.Release();
					renderMaterial = null;
					return false;
				}
			}
			return true;
		}

		public void UpdateDirtyMeshPNTData()
		{
			if (_staticMeshBuffer != null)
			{
				bool needTangents = _materialNeedTangent && _HasTangent;
				_staticMeshBuffer.Internal_UpdateMeshPNTData(_nativeHandler, _materialConfiguration, needTangents);
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetSkinJointPaletteInfo(IntPtr nativeHandle, ref JointPaletteInfo jointPaletteInfo);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetSkinJointPaletteData(IntPtr nativeHandle, ref JointPaletteData jointPaletteData);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_GetMorphAndSkinGpuDataInfo(IntPtr nativeHandle, uint requiredVersion, uint requiredFlags, ref MorphAndSkinDataInfo gpuDataInfo);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_AvatarRenderMesh_FillMorphAndSkinSimulationGpuData(IntPtr nativeHandle, ref MorphAndSkinSimulationGpuData gpuData);
	}
	public class PicoPrimitiveRenderMesh : PicoAvatarRenderMesh
	{
		private AvatarPrimitive _Primitive;

		public void AttachPrimitive(AvatarPrimitive primitive)
		{
			_Primitive = primitive;
			base.avatarEffectKind = primitive.owner.owner.owner.avatarEffectKind;
		}

		private void OnWillRenderObject()
		{
			if (base.isRenderDataReady && _Primitive != null && _Primitive.nativeHandle != IntPtr.Zero)
			{
				UpdateMorphAndSkinSimulationBuffer(_Primitive.nativeHandle);
			}
		}

		public override void Destroy()
		{
			if (_Primitive != null)
			{
				_Primitive.Internal_OnRenderMeshDestroy(this);
				_Primitive = null;
			}
			base.Destroy();
		}

		public IEnumerator BuildFromNativeRenderMeshAndMaterial(IntPtr renderMeshHandle, IntPtr renderMaterialHandle)
		{
			if (_Primitive == null || base.meshRenderer != null)
			{
				throw new Exception("BuildFromNativeRenderMesh invoked wrongly.");
			}
			if (renderMeshHandle == IntPtr.Zero || renderMaterialHandle == IntPtr.Zero)
			{
				yield break;
			}
			yield return CreateUnityRenderMesh(asyncMode: false, renderMeshHandle, _Primitive.lodLevel, _Primitive.nativeHandle, mergedMesh: false, _Primitive.mainShaderType);
			if (base.isRenderMeshDataReady)
			{
				if (CreateRenderMaterial(renderMaterialHandle, _Primitive.lodLevel, merged: false))
				{
					yield return base.renderMaterial.Coroutine_LoadTexturesFromNativeMaterial(asyncMode: true, _Primitive.lodLevel);
				}
				if (base.renderMaterial != null && base.meshRenderer != null && base.renderMaterial != null)
				{
					_ = _Primitive.owner.owner.owner.capabilities.isLocalAvatar;
					SetMaterial(base.renderMaterial);
				}
			}
		}

		public void UpdateMaterial(Material material)
		{
			UpdateMaterial(base.renderMaterial, material);
		}

		public override void UpdateSimulationRenderData()
		{
			if (_Primitive != null && _Primitive.nativeHandle != IntPtr.Zero)
			{
				UpdateMorphAndSkinSimulationBuffer(_Primitive.nativeHandle);
			}
		}

		public override AvatarLod GetAvatarLod()
		{
			return _Primitive?.owner;
		}
	}
	public class PicoLodMergedRenderMesh : PicoAvatarRenderMesh
	{
		private AvatarLod _AvatarLod;

		public void AttachAvatarLod(AvatarLod avatarLod)
		{
			_AvatarLod = avatarLod;
			base.avatarEffectKind = avatarLod.owner.owner.avatarEffectKind;
		}

		public IEnumerator BuildFromNativeMeshAndMaterial(IntPtr renderMeshHandle, IntPtr renderMaterialHandle)
		{
			if (_AvatarLod == null || base.meshRenderer != null)
			{
				throw new Exception("_AvatarLod or meshRenderer not");
			}
			if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
			{
				AvatarEnv.Log(DebugLogMask.AvatarLoad, "LodMergedRenderMesh.BuildFromNativeMeshAndMaterial.Start");
			}
			if (renderMeshHandle == IntPtr.Zero || renderMaterialHandle == IntPtr.Zero)
			{
				yield break;
			}
			yield return CreateUnityRenderMesh(asyncMode: false, renderMeshHandle, _AvatarLod.lodLevel, _AvatarLod.nativeHandle, mergedMesh: true);
			if (base.isRenderMeshDataReady)
			{
				yield return null;
				if (_AvatarLod != null && CreateRenderMaterial(renderMaterialHandle, _AvatarLod.lodLevel, merged: true))
				{
					yield return base.renderMaterial.Coroutine_LoadTexturesFromNativeMaterial(asyncMode: true, _AvatarLod.lodLevel);
				}
				if (base.meshRenderer != null && base.renderMaterial != null)
				{
					SetMaterial(base.renderMaterial);
				}
			}
		}

		public void UpdateMaterial(Material material)
		{
			UpdateMaterial(base.renderMaterial, material);
		}

		public override void Destroy()
		{
			if (_AvatarLod != null)
			{
				_AvatarLod.OnRenderMeshDestroy(this);
				_AvatarLod = null;
			}
			base.Destroy();
		}

		public override void UpdateSimulationRenderData()
		{
			if (_AvatarLod != null && _AvatarLod.nativeHandle != IntPtr.Zero)
			{
				UpdateMorphAndSkinSimulationBuffer(_AvatarLod.nativeHandle);
			}
		}

		public override AvatarLod GetAvatarLod()
		{
			return _AvatarLod;
		}

		private void OnWillRenderObject()
		{
			if (base.isRenderDataReady && _AvatarLod != null && _AvatarLod.nativeHandle != IntPtr.Zero)
			{
				UpdateMorphAndSkinSimulationBuffer(_AvatarLod.nativeHandle);
			}
		}
	}
	public class PicoAvatarSceneLightEnv : MonoBehaviour
	{
		public string sceneName;

		public float additiveGI;

		private bool _applyed;

		private void Start()
		{
			Apply();
		}

		private void OnDestroy()
		{
			if (PicoAvatarApp.instance != null && PicoAvatarApp.instance.curAvatarSceneLightEnv == this)
			{
				PicoAvatarApp.instance.SetAvatarSceneLightEnv(null);
			}
		}

		public void Apply()
		{
			if (!_applyed && PicoAvatarApp.instance != null)
			{
				_applyed = true;
				PicoAvatarApp.instance.SetAvatarSceneLightEnv(this);
			}
		}

		public void Update()
		{
			if (!_applyed && PicoAvatarApp.instance != null)
			{
				_applyed = true;
				PicoAvatarApp.instance.SetAvatarSceneLightEnv(this);
			}
		}
	}
	public enum AvatarPixelFormat
	{
		Invalid,
		A8Unorm,
		L8Unorm,
		LA8Unorm,
		GR4Unorm,
		ABGR4Unorm,
		ARGB4Unorm,
		RGBA4Unorm,
		BGRA4Unorm,
		B5G6R5Unorm,
		R5G6B5Unorm,
		A1BGR5Unorm,
		A1RGB5Unorm,
		RGB5A1Unorm,
		BGR5A1Unorm,
		R8Unorm,
		R8Snorm,
		R8Uscaleld,
		R8Sscaled,
		R8Uint,
		R8Sint,
		R8_sRGB,
		RG8Unorm,
		RG8Snorm,
		RG8Uscaled,
		RG8Sscaled,
		RG8Uint,
		RG8Sint,
		RG8_sRGB,
		RGB8Unorm,
		RGB8Snorm,
		RGB8Uscaled,
		RGB8Sscaled,
		RGB8Uint,
		RGB8Sint,
		RGB8_sRGB,
		BGR8Unorm,
		BGR8Snorm,
		BGR8Uscaled,
		BGR8Sscaled,
		BGR8Uint,
		BGR8Sint,
		BGR8_sRGB,
		RGBA8Unorm,
		RGBA8Snorm,
		RGBA8Uscaled,
		RGBA8Sscaled,
		RGBA8Uint,
		RGBA8Sint,
		RGBA8_sRGB,
		BGRA8Unorm,
		BGRA8Snorm,
		BGRA8Uscaled,
		BGRA8Sscaled,
		BGRA8Uint,
		BGRA8Sint,
		BGRA8_sRGB,
		ABGR8Unorm,
		ABGR8Snorm,
		ABGR8Uscaled,
		ABGR8Sscaled,
		ABGR8Uint,
		ABGR8Sint,
		ABGR8_sRGB,
		BGR10A2Unorm,
		BGR10A2Snorm,
		BGR10A2Uscaled,
		BGR10A2Sscaled,
		BGR10A2Uint,
		BGR10A2Sint,
		RGB10A2Unorm,
		RGB10A2Snorm,
		RGB10A2Uscaled,
		RGB10A2Sscaled,
		RGB10A2Uint,
		RGB10A2Sint,
		R16Unorm,
		R16Snorm,
		R16Uscaleld,
		R16Sscaled,
		R16Uint,
		R16Sint,
		R16Sfloat,
		RG16Unorm,
		RG16Snorm,
		RG16Uscaled,
		RG16Sscaled,
		RG16Uint,
		RG16Sint,
		RG16Sfloat,
		RGB16Unorm,
		RGB16Snorm,
		RGB16Uscaled,
		RGB16Sscaled,
		RGB16Uint,
		RGB16Sint,
		RGB16Sfloat,
		RGBA16Unorm,
		RGBA16Snorm,
		RGBA16Uscaled,
		RGBA16Sscaled,
		RGBA16Uint,
		RGBA16Sint,
		RGBA16Sfloat,
		R32Uint,
		R32Sint,
		R32Sfloat,
		RG32Uint,
		RG32Sint,
		RG32Sfloat,
		RGB32Uint,
		RGB32Sint,
		RGB32Sfloat,
		RGBA32Uint,
		RGBA32Sint,
		RGBA32Sfloat,
		R64Uint,
		R64Sint,
		R64Sfloat,
		RG64Uint,
		RG64Sint,
		RG64Sfloat,
		RGB64Uint,
		RGB64Sint,
		RGB64Sfloat,
		RGBA64Uint,
		RGBA64Sint,
		RGBA64Sfloat,
		RG11B10Ufloat,
		RGB9E5Ufloat,
		D16Unorm,
		D24X8Unorm,
		D32Sfloat,
		S8Uint,
		D16UnormS8Uint,
		D24UnormS8Uint,
		D32SfloatS8Uint,
		BC1_RGBUnorm,
		BC1_RGB_sRGB,
		BC1_RGBAUnorm,
		BC1_RGBA_sRGB,
		BC2_RGBAUnorm,
		BC2_RGBA_sRGB,
		BC3_RGBAUnorm,
		BC3_RGBA_sRGB,
		BC4_RUnorm,
		BC4_RSnorm,
		BC5_RGUnorm,
		BC5_RGSnorm,
		BC6H_RGBUfloat,
		BC6H_RGBSfloat,
		BC7_RGBAUnorm,
		BC7_RGBAUnorm_sRGB,
		ETC1_RGB8Unorm,
		ETC2_RGB8Unorm,
		ETC2_RGB8_sRGB,
		ETC2_RGB8A1Unorm,
		ETC2_RGB8A1_sRGB,
		ETC2_RGBA8Unorm,
		ETC2_RGBA8_sRGB,
		EAC_R11Unorm,
		EAC_R11Snorm,
		EAC_RG11Unorm,
		EAC_RG11Snorm,
		ASTC_4x4_LDR,
		ASTC_4x4_sRGB,
		ASTC_5x4_LDR,
		ASTC_5x4_sRGB,
		ASTC_5x5_LDR,
		ASTC_5x5_sRGB,
		ASTC_6x5_LDR,
		ASTC_6x5_sRGB,
		ASTC_6x6_LDR,
		ASTC_6x6_sRGB,
		ASTC_8x5_LDR,
		ASTC_8x5_sRGB,
		ASTC_8x6_LDR,
		ASTC_8x6_sRGB,
		ASTC_8x8_LDR,
		ASTC_8x8_sRGB,
		ASTC_10x5_LDR,
		ASTC_10x5_sRGB,
		ASTC_10x6_LDR,
		ASTC_10x6_sRGB,
		ASTC_10x8_LDR,
		ASTC_10x8_sRGB,
		ASTC_10x10_LDR,
		ASTC_10x10_sRGB,
		ASTC_12x10_LDR,
		ASTC_12x10_sRGB,
		ASTC_12x12_LDR,
		ASTC_12x12_sRGB,
		PVRTC1_RGB_2BPP,
		PVRTC1_RGB_4BPP,
		PVRTC1_RGBA_2BPP,
		PVRTC1_RGBA_4BPP,
		PVRTC2_RGBA_2BPP,
		PVRTC2_RGBA_4BPP,
		PVRTC1_RGB_2BPP_sRGB,
		PVRTC1_RGB_4BPP_sRGB,
		PVRTC1_RGBA_2BPP_sRGB,
		PVRTC1_RGBA_4BPP_sRGB,
		PVRTC2_RGBA_2BPP_sRGB,
		PVRTC2_RGBA_4BPP_sRGB,
		GBGR8_422_Unorm,
		BGRG8_422_Unorm,
		G8_B8_R8_3PLANE_420_Unorm,
		G8_BR8_2PLANE_420_Unorm,
		G8_B8_R8_3PLANE_422_Unorm,
		G8_BR8_2PLANE_422_UNnorm,
		G8_B8_R8_3PLANE_444_Unorm,
		RGB16Sfloat_GL_FLOAT,
		RGBA16Sfloat_GL_FLOAT
	}
	public enum AvatarDataType
	{
		Invalid,
		U8norm,
		S8norm,
		U8,
		S8,
		U16norm,
		S16norm,
		U16,
		S16,
		U32,
		S32,
		F16,
		F32
	}
	public enum ImageType
	{
		RENDERBUFFER,
		RENDERBUFFER_MS,
		TEXTURE_1D,
		TEXTURE_2D,
		TEXTURE_3D,
		TEXTURE_CUBE,
		TEXTURE_BUFFER,
		TEXTURE_2D_MS,
		TEXTURE_1D_ARRAY,
		TEXTURE_2D_ARRAY,
		TEXTURE_CUBE_ARRAY,
		TEXTURE_2D_MS_ARRAY,
		TEXTURE_EXTERNAL,
		TEXTURE_RECTANGLE,
		ImageTypeCount,
		RENDERBUFFER_MS_ATTACH,
		INVALID
	}
	public class AvatarTextureLoadContext
	{
		public AvatarTexture avatarTex;

		public bool result;

		public TextureInfo textureInfo;
	}
	internal static class NativeArrayExt
	{
		public unsafe static IntPtr GetPtr(this NativeArray<byte> array)
		{
			return (IntPtr)array.GetUnsafePtr();
		}
	}
	public class AvatarTexture : ReferencedObject
	{
		private TextureInfo _textureInfo;

		private Texture _texture;

		private Texture _mergedTexture;

		private uint _dataByteSize;

		private static Dictionary<IntPtr, AvatarTexture> _textures = new Dictionary<IntPtr, AvatarTexture>();

		private static int _textureCount = 0;

		private const string PavDLLName = "effect";

		public Texture runtimeTexture => _texture;

		public Texture runtimeMergedTexture => _mergedTexture;

		public uint dataSize => _dataByteSize;

		public AvatarTexture()
		{
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarTexture);
			}
		}

		public static AvatarTexture CreateAndRefTexture(ref TextureInfo textureInfo, bool isLinear)
		{
			if (textureInfo.texObject == IntPtr.Zero)
			{
				return null;
			}
			if (_textures.TryGetValue(textureInfo.texObject, out var value))
			{
				value.Retain();
				return value;
			}
			value = new AvatarTexture();
			if (!value.Create(textureInfo, isLinear))
			{
				value.CheckDelete();
				return null;
			}
			_textures.Add(textureInfo.texObject, value);
			value.Retain();
			return value;
		}

		protected override void OnDestroy()
		{
			if ((bool)_texture)
			{
				_textureCount--;
			}
			if ((bool)_mergedTexture)
			{
				_textureCount--;
			}
			Utility.DestroyImmediate(_texture);
			_texture = null;
			Utility.DestroyImmediate(_mergedTexture);
			_mergedTexture = null;
			_textures.Remove(_textureInfo.texObject);
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.AvatarTexture);
			}
		}

		private unsafe bool Create(TextureInfo textureInfo, bool isLinear)
		{
			_textureInfo = textureInfo;
			if (textureInfo.width == 0 || textureInfo.height == 0)
			{
				return false;
			}
			if (!Utility.EnableRenderObject)
			{
				return true;
			}
			try
			{
				TextureFormat unityTextureFormat = Utility.GetUnityTextureFormat((AvatarPixelFormat)textureInfo.format);
				if (textureInfo.imageType == 3)
				{
					Texture2D texture2D = new Texture2D((int)textureInfo.width, (int)textureInfo.height, unityTextureFormat, textureInfo.mipsCount > 1, isLinear);
					if (texture2D == null)
					{
						if (AvatarEnv.NeedLog(DebugLogMask.GeneralWarn))
						{
							AvatarEnv.Log(DebugLogMask.GeneralWarn, "new Texture2D error. format maybe wrong!");
						}
						return false;
					}
					NativeArray<byte> rawTextureData = texture2D.GetRawTextureData<byte>();
					TextureSliceData sliceFaceData = default(TextureSliceData);
					sliceFaceData.width = textureInfo.width;
					sliceFaceData.height = textureInfo.height;
					sliceFaceData.format = textureInfo.format;
					sliceFaceData.mips = textureInfo.mipsCount;
					sliceFaceData.face = 0;
					sliceFaceData.dataByteSize = (uint)rawTextureData.Length;
					_dataByteSize = (uint)rawTextureData.Length;
					sliceFaceData.data = (IntPtr)rawTextureData.GetUnsafePtr();
					if (pav_TextureDataEntity_GetSliceFaceData(textureInfo.texObject, ref sliceFaceData) != 0)
					{
						UnityEngine.Object.DestroyImmediate(texture2D);
						return false;
					}
					texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
					_texture = texture2D;
					_textureCount++;
				}
				else if (textureInfo.imageType == 9)
				{
					Texture2DArray texture2DArray = new Texture2DArray((int)textureInfo.width, (int)textureInfo.height, textureInfo.slicesCount, unityTextureFormat, textureInfo.mipsCount > 1, isLinear);
					if (texture2DArray == null)
					{
						UnityEngine.Debug.LogError("new Texture2DArray error. format maybe wrong!");
						return false;
					}
					texture2DArray.wrapMode = TextureWrapMode.Clamp;
					texture2DArray.filterMode = FilterMode.Bilinear;
					NativeArray<byte> nativeArray = new NativeArray<byte>((int)(textureInfo.width * textureInfo.height * 4), Allocator.Temp, NativeArrayOptions.UninitializedMemory);
					bool flag = false;
					TextureSliceData sliceFaceData2 = default(TextureSliceData);
					sliceFaceData2.width = textureInfo.width;
					sliceFaceData2.height = textureInfo.height;
					sliceFaceData2.format = textureInfo.format;
					sliceFaceData2.face = 0;
					_dataByteSize = 0u;
					for (int i = 0; i < textureInfo.mipsCount; i++)
					{
						sliceFaceData2.mips = (ushort)i;
						for (int j = 0; j < textureInfo.slicesCount; j++)
						{
							sliceFaceData2.slice = (ushort)j;
							sliceFaceData2.data = (IntPtr)nativeArray.GetUnsafePtr();
							if (pav_TextureDataEntity_GetSliceFaceData(textureInfo.texObject, ref sliceFaceData2) != 0)
							{
								flag = true;
								break;
							}
							_dataByteSize += sliceFaceData2.dataByteSize;
							texture2DArray.SetPixelData(nativeArray, i, j);
						}
						if (flag)
						{
							break;
						}
					}
					nativeArray.Dispose();
					if (flag)
					{
						UnityEngine.Object.DestroyImmediate(texture2DArray);
						return false;
					}
					texture2DArray.Apply(updateMipmaps: false, makeNoLongerReadable: true);
					_mergedTexture = texture2DArray;
					_textureCount++;
				}
			}
			catch (Exception ex)
			{
				if (AvatarEnv.NeedLog(DebugLogMask.AvatarLoad))
				{
					AvatarEnv.Log(DebugLogMask.AvatarLoad, ex.Message);
				}
				return false;
			}
			return true;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_TextureDataEntity_GetSliceFaceData(IntPtr nativeHandle, ref TextureSliceData sliceFaceData);
	}
	public enum BSType
	{
		Invalid = -1,
		eyeLookDown_L,
		noseSneer_L,
		eyeLookIn_L,
		browInnerUp,
		browDown_R,
		mouthClose,
		mouthLowerDown_R,
		jawOpen,
		mouthUpperUp_R,
		mouthShrugUpper,
		mouthFunnel,
		eyeLookIn_R,
		eyeLookDown_R,
		noseSneer_R,
		mouthRollUpper,
		jawRight,
		browDown_L,
		mouthShrugLower,
		mouthRollLower,
		mouthSmile_L,
		mouthPress_L,
		mouthSmile_R,
		mouthPress_R,
		mouthDimple_R,
		mouthLeft,
		jawForward,
		eyeSquint_L,
		mouthFrown_L,
		eyeBlink_L,
		cheekSquint_L,
		browOuterUp_L,
		eyeLookUp_L,
		jawLeft,
		mouthStretch_L,
		mouthPucker,
		eyeLookUp_R,
		browOuterUp_R,
		cheekSquint_R,
		eyeBlink_R,
		mouthUpperUp_L,
		mouthFrown_R,
		eyeSquint_R,
		mouthStretch_R,
		cheekPuff,
		eyeLookOut_L,
		eyeLookOut_R,
		eyeWide_R,
		eyeWide_L,
		mouthRight,
		mouthDimple_L,
		mouthLowerDown_L,
		tongueOut,
		head_Happy,
		head_Surprise,
		Count
	}
	[CreateAssetMenu(fileName = "BuiltInConfiguration", menuName = "Pico/Avatar/SDK/BuiltInConfiguration", order = 1)]
	public class PicoBuiltInConfiguration : ScriptableObject
	{
		public Material lodMaterial0;

		public Material lodMaterial1;

		public Material lodMaterial2;

		public Material lodMaterial3;

		public Material lodMaterial4;

		public ShaderVariantCollection shaderVariantCollection;

		public bool needTangent = true;

		public bool enableMultiLights = true;

		public ComputeShader morphAndSkinningShader;

		public string name_BaseColor = "_Color";

		public string name_BaseMap = "_MainTex";

		public string name_Cutoff = "_Cutoff";

		public string name_Smoothness = "_Glossiness";

		public string name_GlossMapScale = "_GlossMapScale";

		public string name_SmoothnessTextureChannel = "_SmoothnessTextureChannel";

		public string name_Metallic = "_Metallic";

		public string name_MetallicGlossMap = "_MetallicGlossMap";

		public string name_SpecularHighlights = "_SpecularHighlights";

		public string name_GlossyReflections = "_GlossyReflections";

		public string name_BumpScale = "_BumpScale";

		public string name_BumpMap = "_BumpMap";

		public string name_Parallax = "_Parallax";

		public string name_ParallaxMap = "_ParallaxMap";

		public string name_OcclusionStrength = "_OcclusionStrength";

		public string name_OcclusionMap = "_OcclusionMap";

		public string name_EmissionColor = "_EmissionColor";

		public string name_EmissionMap = "_EmissionMap";

		public string name_DetailMask = "_DetailMask";

		public string name_DetailAlbedoMap = "_DetailAlbedoMap";

		public string name_DetailAlbedoMapScale = "_DetailAlbedoMapScale";

		public string name_DetailNormalMap = "_DetailNormalMap";

		public string name_UVSetForSecondaryTextures = "_UVSec";

		public bool need_ToonShadowMap = true;

		public bool need_MetallicGlossMap = true;

		public bool need_SpecGlossMap = true;

		public bool need_BumpMap = true;

		public bool need_ParallaxMap;

		public bool need_EmissionMap = true;

		public bool need_DetailMask;

		public bool need_DetailAlbedoMap;

		public bool need_DetailNormalMap;

		public bool isLod2NeedBumpMap;

		public bool isLod3EnablePBR;

		public string name_OutlineColor = "_OutlineColor";

		public string name_Outline = "_Outline";

		public string name_ToonShadowMap = "_ToonShadowMap";

		public string name_SpecColor = "_SpecColor";

		public string name_SpecGlossMap = "_SpecGlossMap";

		public string name_EnvironmentReflections = "_EnvironmentReflections";

		public string name_DetailNormalMapScale = "_DetailNormalMapScale";

		public string name_ClearCoatMask = "_ClearCoatMask";

		public string name_ClearCoatSmoothness = "_ClearCoatSmoothness";

		public string name_ToonShadowMapArray = "_ToonShadowMapArray";

		public string name_BaseMapArray = "_BaseMapArray";

		public string name_MetallicGlossMapArray = "_MetallicGlossMapArray";

		public string name_SpecGlossMapArray = "_SpecGlossMapArray";

		public string name_BumpMapArray = "_BumpMapArray";

		public string name_ParallaxMapArray = "_ParallaxMapArray";

		public string name_OcclusionMapArray = "_OcclusionMapArray";

		public string name_EmissionMapArray = "_EmissionMapArray";

		public string name_DetailMaskArray = "_DetailMaskArray";

		public string name_DetailAlbedoMapArray = "_DetailAlbedoMapArray";

		public string name_DetailNormalMapArray = "_DetailNormalMapArray";

		private bool _Prepared;

		private bool _initialized;

		private int id_OutlineColor;

		private int id_Outline;

		private int id_ToonShadowMap;

		private int id_BaseMap;

		private int id_BaseColor;

		private int id_Cutoff;

		private int id_Smoothness;

		private int id_GlossMapScale;

		private int id_SmoothnessTextureChannel;

		private int id_Metallic;

		private int id_MetallicGlossMap;

		private int id_SpecColor;

		private int id_SpecGlossMap;

		private int id_SpecularHighlights;

		private int id_EnvironmentReflections;

		private int id_BumpScale;

		private int id_BumpMap;

		private int id_Parallax;

		private int id_ParallaxMap;

		private int id_OcclusionStrength;

		private int id_OcclusionMap;

		private int id_EmissionColor;

		private int id_EmissionMap;

		private int id_DetailMask;

		private int id_DetailAlbedoMapScale;

		private int id_DetailAlbedoMap;

		private int id_DetailNormalMapScale;

		private int id_DetailNormalMap;

		private int id_ClearCoatMask;

		private int id_ClearCoatSmoothness;

		private int id_ToonShadowMapArray;

		private int id_BaseMapArray;

		private int id_MetallicGlossMapArray;

		private int id_SpecGlossMapArray;

		private int id_BumpMapArray;

		private int id_ParallaxMapArray;

		private int id_OcclusionMapArray;

		private int id_EmissionMapArray;

		private int id_DetailMaskArray;

		private int id_DetailAlbedoMapArray;

		private int id_DetailNormalMapArray;

		public void ApplyToMaterial(PicoAvatarRenderMaterial nativeMaterial, Material material)
		{
			if (nativeMaterial.has_Outline)
			{
				material.SetFloat(id_Outline, nativeMaterial.mat_Outline);
			}
			if (nativeMaterial.has_Cutoff)
			{
				material.SetFloat(id_Cutoff, nativeMaterial.mat_Cutoff);
			}
			if (nativeMaterial.has_Smoothness)
			{
				material.SetFloat(id_Smoothness, nativeMaterial.mat_Smoothness);
			}
			if (nativeMaterial.has_GlossMapScale)
			{
				material.SetFloat(id_GlossMapScale, nativeMaterial.mat_GlossMapScale);
			}
			if (nativeMaterial.has_SmoothnessTextureChannel)
			{
				material.SetFloat(id_SmoothnessTextureChannel, nativeMaterial.mat_SmoothnessTextureChannel);
			}
			if (nativeMaterial.has_Metallic)
			{
				material.SetFloat(id_Metallic, nativeMaterial.mat_Metallic);
			}
			if (nativeMaterial.has_BumpScale)
			{
				material.SetFloat(id_BumpScale, nativeMaterial.mat_BumpScale);
			}
			if (nativeMaterial.has_Parallax)
			{
				material.SetFloat(id_Parallax, nativeMaterial.mat_Parallax);
			}
			if (nativeMaterial.has_OcclusionStrength)
			{
				material.SetFloat(id_OcclusionStrength, nativeMaterial.mat_OcclusionStrength);
			}
			if (nativeMaterial.has_DetailAlbedoMapScale)
			{
				material.SetFloat(id_DetailAlbedoMapScale, nativeMaterial.mat_DetailAlbedoMapScale);
			}
			if (nativeMaterial.has_DetailNormalMapScale)
			{
				material.SetFloat(id_DetailNormalMapScale, nativeMaterial.mat_DetailNormalMapScale);
			}
			if (nativeMaterial.has_ClearCoatMask)
			{
				material.SetFloat(id_ClearCoatMask, nativeMaterial.mat_ClearCoatMask);
			}
			if (nativeMaterial.has_ClearCoatSmoothness)
			{
				material.SetFloat(id_ClearCoatSmoothness, nativeMaterial.mat_ClearCoatSmoothness);
			}
			Color value = (nativeMaterial.has_BaseColor ? nativeMaterial.mat_BaseColor : Color.white);
			if (nativeMaterial.has_OutlineColor)
			{
				material.SetColor(id_OutlineColor, nativeMaterial.mat_OutlineColor);
			}
			material.SetColor(id_BaseColor, value);
			if (nativeMaterial.has_SpecColor)
			{
				material.SetColor(id_SpecColor, nativeMaterial.mat_SpecColor);
			}
			if (nativeMaterial.has_EmissionColor)
			{
				material.SetColor(id_EmissionColor, nativeMaterial.mat_EmissionColor);
			}
			setTextureProperty(material, nativeMaterial.mat_ToonShadowMap, id_ToonShadowMap, id_ToonShadowMapArray);
			setTextureProperty(material, nativeMaterial.mat_BaseMap, id_BaseMap, id_BaseMapArray);
			setTextureProperty(material, nativeMaterial.mat_MetallicGlossMap, id_MetallicGlossMap, id_MetallicGlossMapArray);
			setTextureProperty(material, nativeMaterial.mat_SpecGlossMap, id_SpecGlossMap, id_SpecGlossMapArray);
			setTextureProperty(material, nativeMaterial.mat_BumpMap, id_BumpMap, id_BumpMapArray);
			setTextureProperty(material, nativeMaterial.mat_ParallaxMap, id_ParallaxMap, id_ParallaxMapArray);
			setTextureProperty(material, nativeMaterial.mat_EmissionMap, id_EmissionMap, id_EmissionMapArray);
			setTextureProperty(material, nativeMaterial.mat_DetailMask, id_DetailMask, id_DetailMaskArray);
			setTextureProperty(material, nativeMaterial.mat_DetailAlbedoMap, id_DetailAlbedoMap, id_DetailAlbedoMapArray);
			setTextureProperty(material, nativeMaterial.mat_DetailNormalMap, id_DetailNormalMap, id_DetailNormalMapArray);
		}

		public virtual Material ApplyToMaterial(PicoAvatarRenderMaterial nativeMaterial, AvatarLodLevel lodLevel)
		{
			CheckPrepareConfiguration();
			return new Material(SelectMaterial(lodLevel));
		}

		private static void setTextureProperty(Material material, AvatarTexture avatarTexture, int texPropertyId, int arrayPropertyId)
		{
			if (avatarTexture != null)
			{
				if (avatarTexture.runtimeTexture != null)
				{
					material.SetTexture(texPropertyId, avatarTexture.runtimeTexture);
				}
				else if (avatarTexture.runtimeMergedTexture != null)
				{
					material.SetTexture(arrayPropertyId, avatarTexture.runtimeMergedTexture);
				}
			}
		}

		protected virtual Material SelectMaterial(AvatarLodLevel lodLevel)
		{
			_ = lodMaterial4 != null;
			if (lodMaterial3 != null && lodLevel > AvatarLodLevel.Lod2)
			{
				return lodMaterial3;
			}
			if (lodMaterial2 != null && lodLevel > AvatarLodLevel.Lod1)
			{
				return lodMaterial2;
			}
			if (lodMaterial1 != null && lodLevel > AvatarLodLevel.Lod0)
			{
				return lodMaterial1;
			}
			return lodMaterial0;
		}

		protected void CheckPrepareConfiguration()
		{
			if (!_Prepared)
			{
				if (lodMaterial0 == null)
				{
					lodMaterial0 = new Material(Shader.Find("PAV/URP/DiffuseSpec"));
				}
				CheckInitialize();
				_Prepared = true;
			}
		}

		private void CheckInitialize()
		{
			if (!_initialized)
			{
				if (morphAndSkinningShader == null)
				{
					morphAndSkinningShader = Resources.Load<ComputeShader>("MorphAndSkinning");
				}
				id_OutlineColor = Shader.PropertyToID(name_OutlineColor);
				id_Outline = Shader.PropertyToID(name_Outline);
				id_ToonShadowMap = Shader.PropertyToID(name_ToonShadowMap);
				id_BaseMap = Shader.PropertyToID(name_BaseMap);
				id_BaseColor = Shader.PropertyToID(name_BaseColor);
				id_Cutoff = Shader.PropertyToID(name_Cutoff);
				id_Smoothness = Shader.PropertyToID(name_Smoothness);
				id_GlossMapScale = Shader.PropertyToID(name_Smoothness);
				id_SmoothnessTextureChannel = Shader.PropertyToID(name_SmoothnessTextureChannel);
				id_Metallic = Shader.PropertyToID(name_Metallic);
				id_MetallicGlossMap = Shader.PropertyToID(name_MetallicGlossMap);
				id_SpecColor = Shader.PropertyToID(name_SpecColor);
				id_SpecGlossMap = Shader.PropertyToID(name_SpecGlossMap);
				id_SpecularHighlights = Shader.PropertyToID(name_SpecularHighlights);
				id_EnvironmentReflections = Shader.PropertyToID(name_EnvironmentReflections);
				id_BumpScale = Shader.PropertyToID(name_BumpScale);
				id_BumpMap = Shader.PropertyToID(name_BumpMap);
				id_Parallax = Shader.PropertyToID(name_Parallax);
				id_ParallaxMap = Shader.PropertyToID(name_ParallaxMap);
				id_OcclusionStrength = Shader.PropertyToID(name_OcclusionStrength);
				id_OcclusionMap = Shader.PropertyToID(name_OcclusionMap);
				id_EmissionColor = Shader.PropertyToID(name_EmissionColor);
				id_EmissionMap = Shader.PropertyToID(name_EmissionMap);
				id_DetailMask = Shader.PropertyToID(name_DetailMask);
				id_DetailAlbedoMapScale = Shader.PropertyToID(name_DetailAlbedoMapScale);
				id_DetailAlbedoMap = Shader.PropertyToID(name_DetailAlbedoMap);
				id_DetailNormalMapScale = Shader.PropertyToID(name_DetailNormalMapScale);
				id_DetailNormalMap = Shader.PropertyToID(name_DetailNormalMap);
				id_ClearCoatMask = Shader.PropertyToID(name_ClearCoatMask);
				id_ClearCoatSmoothness = Shader.PropertyToID(name_ClearCoatSmoothness);
				id_ToonShadowMapArray = Shader.PropertyToID(name_ToonShadowMapArray);
				id_BaseMapArray = Shader.PropertyToID(name_BaseMapArray);
				id_MetallicGlossMapArray = Shader.PropertyToID(name_MetallicGlossMapArray);
				id_SpecGlossMapArray = Shader.PropertyToID(name_SpecGlossMapArray);
				id_BumpMapArray = Shader.PropertyToID(name_BumpMapArray);
				id_ParallaxMapArray = Shader.PropertyToID(name_ParallaxMapArray);
				id_OcclusionMapArray = Shader.PropertyToID(name_OcclusionMapArray);
				id_EmissionMapArray = Shader.PropertyToID(name_EmissionMapArray);
				id_DetailMaskArray = Shader.PropertyToID(name_DetailMaskArray);
				id_DetailAlbedoMapArray = Shader.PropertyToID(name_DetailAlbedoMapArray);
				id_DetailNormalMapArray = Shader.PropertyToID(name_DetailNormalMapArray);
				_initialized = true;
			}
		}
	}
	public enum NativeResult
	{
		Success = 0,
		Unknown = -1,
		OutOfMemory = -2,
		NotInitialized = -3,
		AlreadyInitialized = -4,
		BadParameter = -5,
		Unsupported = -6,
		NotFound = -7,
		AlreadyExists = -8,
		IndexOutOfRange = -9,
		InvalidEntity = -10,
		InvalidLod = -11,
		InvalidPrimitive = -12,
		InvalidMesh = -13,
		InvalidRenderMesh = -14,
		InvalidMaterial = -15,
		InvalidRenderMaterial = -16,
		InvalidJoint = -17,
		InvalidBodyAnimController = -18,
		InvalidSkeleton = -19,
		InvalidImage = -20,
		InvalidObject = -21,
		InvalidStage = -22,
		InvalidDeviceInputReader = -23,
		InvalidAnimationLayer = -24,
		InvalidThread = -31,
		BufferTooSmall = -32,
		DataNotAvailable = -33,
		InvalidData = -34,
		SkeletonMismatch = -35,
		LibraryLoadFailed = -36,
		Pending = -37,
		MissingAccessToken = -38,
		MemoryLeak = -39,
		RequestCallbackNotSet = -40,
		UnmatchedLoadFilters = -41,
		DeserializationPending = -42,
		LegacyJointTypeFallback = -43,
		TypeError = -44,
		ServiceUnavailable = -50,
		NetError = -51,
		MismatchVersion = -52,
		Unloaded = -53,
		OperationCanceled = -60,
		MonoStateViolated = -61,
		FatalError = -100
	}
	public enum TargetEngineType : uint
	{
		AmazingEngine,
		Unity,
		Unreal
	}
	public enum ServerType : uint
	{
		OfflineEnv,
		ProductionEnv
	}
	public enum ResourcePlatform
	{
		Any,
		PC,
		Mobile,
		NUM
	}
	public enum RenderApiType
	{
		Invalid,
		Win_D3D11,
		Win_D3D12,
		Android_Gles3,
		Android_Vulkan,
		IOS_Metal,
		OSX_Metal,
		Num
	}
	public enum ResourceTechniqueLevel
	{
		Lowest,
		Medium,
		Full
	}
	public enum FileEncryptMethod
	{
		Normal,
		Lzma
	}
	public enum AccessType : uint
	{
		OwnApp,
		ThirdApp
	}
	public enum AvatarSexType
	{
		Female = 0,
		Male = 1,
		Both = 3,
		Invalid = -1
	}
	public enum ResourceSlotInClosetItem
	{
		None = -1,
		Base,
		Icon,
		Mesh,
		Skeleton,
		MaterialSet,
		ClothAnimationSet,
		AnimationSet,
		Texture,
		LightingData,
		SingleMaterial,
		ObiSkinnedCloth,
		BlendShape,
		Num
	}
	public enum ControlSourceType : uint
	{
		LocalUser,
		RemoteServer,
		LocalApp,
		PlaceHolder
	}
	public enum AvatarType : uint
	{
		NormalAvatar,
		PlaceholderAvatar
	}
	public enum AvatarManifestationType : uint
	{
		None = 0u,
		Full = 1u,
		Half = 2u,
		HeadHands = 4u,
		Head = 8u,
		Hands = 16u,
		All = 31u
	}
	public enum AvatarViewType : uint
	{
		None,
		FirstPerson,
		ThirdPerson,
		All
	}
	public enum AvatarHeadShowType : uint
	{
		Normal,
		Hide,
		Transparent,
		Edit
	}
	public enum AvatarNodeTypes : uint
	{
		Head = 1u,
		Hand
	}
	public enum AvatarShaderType
	{
		Invalid = -1,
		Body_Base = 0,
		Body_Toon = 1,
		Eyelash_Base = 200,
		Hair_Base = 300,
		Eye_Base = 400,
		Cloth_Base = 500
	}
	public enum AvatarSceneBlendType
	{
		Opaque,
		SrcAlpha_OneMinusSrcAlpha
	}
	public enum AvatarRenderFace
	{
		Front = 2,
		Back = 1,
		Both = 0
	}
	public enum AvatarPBRWorkflow
	{
		Specular,
		Metallic
	}
	public enum AvatarPBRSmoothnessSource
	{
		SpecularMetallicAlpha,
		AlbedoAlpha
	}
	public enum AvatarLodLevel
	{
		Invalid = -2,
		Invisible,
		Lod0,
		Lod1,
		Lod2,
		Count
	}
	public enum AvatarIKMode
	{
		Invalid = -1,
		None,
		UpperBody,
		FullBody,
		Count
	}
	public enum SnapshotLevel
	{
		Invalid = -1,
		DeviceInput,
		BasicBone,
		FullBone,
		BlendShape,
		Count
	}
	public enum AvatarAnimationFlags
	{
		DepressRemoteLowerBodyJoints = 1
	}
	public enum AvatarEffectKind
	{
		None,
		SimpleOutline,
		Black
	}
	public enum AvatarMemoryCompactFlags : ulong
	{
		NoTex_NormalAndMetal = 1uL
	}
	public enum AvatarPrimitiveDirtyFlags
	{
		MeshVertex = 1,
		MeshTopology = 2,
		MaterialUniforms = 8,
		Textures = 0x10
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct TextureInfo
	{
		public IntPtr texObject;

		public uint width;

		public uint height;

		public uint format;

		public ushort dataType;

		public ushort imageType;

		public ushort mipsCount;

		public ushort depthCount;

		public ushort slicesCount;

		public ushort reserved;

		public uint sliceFaceByteSize;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct TextureSliceData
	{
		public uint width;

		public uint height;

		public uint format;

		public ushort mips;

		public ushort face;

		public ushort slice;

		public ushort reserved;

		public uint dataByteSize;

		public IntPtr data;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct XForm
	{
		public Vector3 position;

		public Quaternion orientation;

		public Vector3 scale;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MeshInfo
	{
		public IntPtr meshObject;

		public uint positionCount;

		public uint normalCount;

		public uint tangentCount;

		public uint colorCount;

		public uint uvCount;

		public uint uv2Count;

		public uint uv3Count;

		public uint uv4Count;

		public uint boneNameCount;

		public uint bindPoseBoneCount;

		public uint boneWeightCount;

		public uint subMeshCount;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public uint[] indicesCount;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct JointWeight
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		private float[] weights;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		private int[] indices;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MeshData
	{
		public IntPtr positions;

		public IntPtr normals;

		public IntPtr tangents;

		public IntPtr colors;

		public IntPtr uv1;

		public IntPtr uv2;

		public IntPtr uv3;

		public IntPtr uv4;

		public IntPtr boneNames;

		public IntPtr bindPoses;

		public IntPtr boneWeights;

		public IntPtr indices;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct JointPaletteInfo
	{
		public uint rootJointNameHash;

		public uint jointCount;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct JointPaletteData
	{
		public IntPtr jointMatrices;

		public XForm rootJointXForm;
	}
	internal enum DataFormat
	{
		Float,
		Half,
		Packed_10_10_10_2_snorm
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MorphAndSkinDataRequiredInfo
	{
		public uint version;

		public uint flags;

		public uint meshVertexDataFormat;

		public uint morphVertexDataFormat;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MorphAndSkinDataInfo
	{
		public uint version;

		public uint flags;

		public uint staticBufferByteSize;

		public uint dynamicBufferByteSize;

		public uint outputBufferByteSize;

		public uint staticBufferOffset;

		public uint dynamicBufferOffset;

		public uint materialDataByteSize;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MorphAndSkinResourceGpuData
	{
		public uint version;

		public uint flags;

		public uint staticBufferByteSize;

		public IntPtr dataBuffer;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct MorphAndSkinSimulationGpuData
	{
		public uint version;

		public uint flags;

		public uint dynamicBufferByteSize;

		public IntPtr dataBuffer;

		public IntPtr owner;

		public IntPtr boneMatrices;

		public IntPtr materialData;

		public bool materialDataDirty;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct IKEffectorParameter
	{
		public float ikPositionWeight;

		public float ikRotationWeight;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct DeviceData
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.U4)]
		public uint[] connectionStatus;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.U4)]
		public uint[] controllerButtonStatus;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public Vector3[] positions;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public Quaternion[] orientations;
	}
	public class PicoHandJointType : MonoBehaviour
	{
		public enum HandJointType
		{
			Invalid = -1,
			Wrist,
			ThumbRoot,
			ThumbTrapezium,
			ThumbMeta,
			ThumbProximal,
			ThumbDistal,
			IndexRoot,
			IndexMeta,
			IndexProximal,
			IndexIntermediate,
			IndexDistal,
			MiddleRoot,
			MiddleMeta,
			MiddleProximal,
			MiddleIntermediate,
			MiddleDistal,
			RingRoot,
			RingMeta,
			RingProximal,
			RingIntermediate,
			RingDistal,
			PinkyRoot,
			PinkyMeta,
			PinkyProximal,
			PinkyIntermediate,
			PinkyDistal,
			Count
		}

		public HandJointType jointType;
	}
	[Preserve]
	public class IDParameterTable : NativeObject
	{
		public enum ParamType
		{
			Byte,
			Int,
			Float,
			UInt,
			Vector3,
			Vector4,
			IntPtr,
			String
		}

		protected const string PavDLLName = "effect";

		[Preserve]
		public IDParameterTable()
		{
			SetNativeHandle(pav_IDParameterTable_New(), needRetain: false);
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("IDParameterTable.New");
			}
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.IDParameterTable);
			}
		}

		[Preserve]
		public IDParameterTable(IntPtr nativeHandle_)
		{
			if (nativeHandle_ == IntPtr.Zero)
			{
				throw new OutOfMemoryException("IDParameterTable.New");
			}
			SetNativeHandle(nativeHandle_, needRetain: false);
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.IncreaseInstanceCount(PicoAvatarStats.InstanceType.IDParameterTable);
			}
		}

		public int GetParamCount(ParamType pt)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetParamCount(base.nativeHandle, (uint)pt);
		}

		public void CopyFrom(IDParameterTable parameterTable)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_CopyFrom(base.nativeHandle, parameterTable.nativeHandle);
		}

		public void Clear()
		{
			pav_IDParameterTable_Clear(base.nativeHandle);
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (PicoAvatarStats.instance != null)
			{
				PicoAvatarStats.instance.DecreaseInstanceCount(PicoAvatarStats.InstanceType.IDParameterTable);
			}
		}

		public void SetBoolParam(uint paramId, bool val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetByteParam(base.nativeHandle, paramId, (byte)(val ? 1u : 0u));
		}

		public NativeResult GetBoolParam(uint paramId, ref bool val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			byte val2 = (byte)(val ? 1u : 0u);
			NativeResult result = pav_IDParameterTable_GetByteParam(base.nativeHandle, paramId, ref val2);
			val = ((val2 != 0) ? true : false);
			return result;
		}

		public void SetByteParam(uint paramId, byte val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetByteParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetByteParam(uint paramId, ref byte val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetByteParam(base.nativeHandle, paramId, ref val);
		}

		public void SetUIntParam(uint paramId, uint val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetUIntParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetUIntParam(uint paramId, ref uint val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetUIntParam(base.nativeHandle, paramId, ref val);
		}

		public void SetFloatParam(uint paramId, float val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetFloatParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetFloatParam(uint paramId, ref float val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetFloatParam(base.nativeHandle, paramId, ref val);
		}

		public void SetULongParam(uint paramId, ulong val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetULongParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetULongParam(uint paramId, ref ulong val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetULongParam(base.nativeHandle, paramId, ref val);
		}

		public void SetObjectParam(uint paramId, IntPtr val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetObjectParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetObjectParam(uint paramId, ref IntPtr val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetObjectParam(base.nativeHandle, paramId, ref val);
		}

		public void SetVector3Param(uint paramId, Vector3 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetVector3Param(base.nativeHandle, paramId, val);
		}

		public NativeResult GetVector3Param(uint paramId, ref Vector3 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetVector3Param(base.nativeHandle, paramId, ref val);
		}

		public void SetPointParam(uint paramId, Vector3 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetPointParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetPointParam(uint paramId, ref Vector3 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetPointParam(base.nativeHandle, paramId, ref val);
		}

		public void SetVector4Param(uint paramId, Vector4 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetVector4Param(base.nativeHandle, paramId, val);
		}

		public NativeResult GetVector4Param(uint paramId, ref Vector4 val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetVector4Param(base.nativeHandle, paramId, ref val);
		}

		public void SetQuaternionParam(uint paramId, Quaternion val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetQuaternionParam(base.nativeHandle, paramId, val);
		}

		public NativeResult GetQuaternionParam(uint paramId, ref Quaternion val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			return pav_IDParameterTable_GetQuaternionParam(base.nativeHandle, paramId, ref val);
		}

		public void SetStringParam(uint paramId, string val)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			pav_IDParameterTable_SetStringParam(base.nativeHandle, paramId, val);
		}

		public string GetStringParam(uint paramId)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			uint length = Utility.sharedStringBuffer.length;
			int strLen = pav_IDParameterTable_GetStringParam(base.nativeHandle, paramId, Utility.sharedStringBuffer.Lock(), (int)length);
			Utility.sharedStringBuffer.Unlock();
			return Utility.sharedStringBuffer.GetANSIString((uint)strLen);
		}

		public string GetUTF8StringParam(uint paramId)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new InvalidOperationException();
			}
			uint length = Utility.sharedStringBuffer.length;
			int strLen = pav_IDParameterTable_GetStringParam(base.nativeHandle, paramId, Utility.sharedStringBuffer.Lock(), (int)length);
			Utility.sharedStringBuffer.Unlock();
			return Utility.sharedStringBuffer.GetUTF8String((uint)strLen);
		}

		public void SetByteParam(string paramName, byte val)
		{
			SetByteParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetByteParam(string paramName, ref byte val)
		{
			return GetByteParam(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetUIntParam(string paramName, uint val)
		{
			SetUIntParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetUIntParam(string paramName, ref uint val)
		{
			return GetUIntParam(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetFloatParam(string paramName, float val)
		{
			SetFloatParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetFloatParam(string paramName, ref float val)
		{
			return GetFloatParam(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetULongParam(string paramName, ulong val)
		{
			SetULongParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetULongParam(string paramName, ref ulong val)
		{
			return GetULongParam(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetObjecParam(string paramName, IntPtr val)
		{
			SetObjectParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetObjectParam(string paramName, ref IntPtr val)
		{
			return GetObjectParam(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetVector3Param(string paramName, Vector3 val)
		{
			SetVector3Param(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetVector3Param(string paramName, ref Vector3 val)
		{
			return GetVector3Param(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetVector4Param(string paramName, Vector4 val)
		{
			SetVector4Param(Utility.AddNameToIDNameTable(paramName), val);
		}

		public NativeResult GetVector4Param(string paramName, ref Vector4 val)
		{
			return GetVector4Param(Utility.AddNameToIDNameTable(paramName), ref val);
		}

		public void SetStringParam(string paramName, string val)
		{
			SetStringParam(Utility.AddNameToIDNameTable(paramName), val);
		}

		public string GetStringParam(string paramName)
		{
			return GetStringParam(Utility.AddNameToIDNameTable(paramName));
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_IDParameterTable_New();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_IDParameterTable_GetParamCount(IntPtr dataHandle, uint paramValueType);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_Clear(IntPtr dataHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetByteParam(IntPtr dataHandle, uint paramId, byte val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetByteParam(IntPtr dataHandle, uint paramId, ref byte val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetUIntParam(IntPtr dataHandle, uint paramId, uint val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetUIntParam(IntPtr dataHandle, uint paramId, ref uint val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetFloatParam(IntPtr dataHandle, uint paramId, float val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetFloatParam(IntPtr dataHandle, uint paramId, ref float val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetULongParam(IntPtr dataHandle, uint paramId, ulong val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetULongParam(IntPtr dataHandle, uint paramId, ref ulong val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetObjectParam(IntPtr dataHandle, uint paramId, IntPtr val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetObjectParam(IntPtr dataHandle, uint paramId, ref IntPtr val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetVector3Param(IntPtr dataHandle, uint paramId, Vector3 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetVector3Param(IntPtr dataHandle, uint paramId, ref Vector3 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetPointParam(IntPtr dataHandle, uint paramId, Vector3 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetPointParam(IntPtr dataHandle, uint paramId, ref Vector3 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetVector4Param(IntPtr dataHandle, uint paramId, Vector4 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetVector4Param(IntPtr dataHandle, uint paramId, ref Vector4 val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetQuaternionParam(IntPtr dataHandle, uint paramId, Quaternion val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_IDParameterTable_GetQuaternionParam(IntPtr dataHandle, uint paramId, ref Quaternion val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_SetStringParam(IntPtr dataHandle, uint paramId, string val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_IDParameterTable_GetStringParam(IntPtr dataHandle, uint paramId, IntPtr charBuffer, int bufferSize);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_IDParameterTable_CopyFrom(IntPtr dataHandle, IntPtr parameterTable);
	}
	[CreateAssetMenu(fileName = "DefaultMaterialConfiguration", menuName = "Pico/Avatar/SDK/AvatarMaterialConfiguration", order = 1)]
	public class PicoMaterialConfiguration : ScriptableObject
	{
		public Material lodMaterial0;

		public Material lodMaterial1;

		public Material lodMaterial2;

		public Material lodMaterial3;

		public Material lodMaterial4;

		public ShaderVariantCollection shaderVariantCollection;

		public bool needTangent = true;

		public bool enableMultiLights = true;

		public ComputeShader morphAndSkinningShader;

		public ComputeShader transferShapingMeshShader;

		public Material colorTemperatureMaterial;

		public bool need_ToonShadowMap = true;

		public bool need_MetallicGlossMap = true;

		public bool need_SpecGlossMap = true;

		public bool need_BumpMap = true;

		public bool need_ParallaxMap;

		public bool need_EmissionMap = true;

		public bool need_DetailMask;

		public bool need_DetailAlbedoMap;

		public bool need_DetailNormalMap;

		public bool need_SecondMap;

		public bool isLod2NeedBumpMap;

		public bool isLod3EnablePBR;

		public string baseColorTextureName = "_BaseMap";

		public string name_OutlineColor = "_OutlineColor";

		public string name_Outline = "_Outline";

		public string name_ToonShadowMap = "_ToonShadowMap";

		public string name_BaseMap = "_BaseMap";

		public string name_BaseColor = "_BaseColor";

		public string name_Cutoff = "_Cutoff";

		public string name_Smoothness = "_Smoothness";

		public string name_GlossMapScale = "_GlossMapScale";

		public string name_SmoothnessTextureChannel = "_SmoothnessTextureChannel";

		public string name_Metallic = "_Metallic";

		public string name_MetallicGlossMap = "_MetallicGlossMap";

		public string name_SpecColor = "_SpecColor";

		public string name_SpecGlossMap = "_SpecGlossMap";

		public string name_SpecularHighlights = "_SpecularHighlights";

		public string name_EnvironmentReflections = "_EnvironmentReflections";

		public string name_BumpScale = "_BumpScale";

		public string name_BumpMap = "_BumpMap";

		public string name_Parallax = "_Parallax";

		public string name_ParallaxMap = "_ParallaxMap";

		public string name_OcclusionStrength = "_OcclusionStrength";

		public string name_OcclusionMap = "_OcclusionMap";

		public string name_EmissionColor = "_EmissionColor";

		public string name_EmissionMap = "_EmissionMap";

		public string name_DetailMask = "_DetailMask";

		public string name_DetailAlbedoMapScale = "_DetailAlbedoMapScale";

		public string name_DetailAlbedoMap = "_DetailAlbedoMap";

		public string name_DetailNormalMapScale = "_DetailNormalMapScale";

		public string name_DetailNormalMap = "_DetailNormalMap";

		public string name_ClearCoatMask = "_ClearCoatMask";

		public string name_ClearCoatSmoothness = "_ClearCoatSmoothness";

		public string name_ToonShadowMapArray = "_ToonShadowMapArray";

		public string name_BaseMapArray = "_BaseMapArray";

		public string name_MetallicGlossMapArray = "_MetallicGlossMapArray";

		public string name_SpecGlossMapArray = "_SpecGlossMapArray";

		public string name_BumpMapArray = "_BumpMapArray";

		public string name_ParallaxMapArray = "_ParallaxMapArray";

		public string name_OcclusionMapArray = "_OcclusionMapArray";

		public string name_EmissionMapArray = "_EmissionMapArray";

		public string name_DetailMaskArray = "_DetailMaskArray";

		public string name_DetailAlbedoMapArray = "_DetailAlbedoMapArray";

		public string name_DetailNormalMapArray = "_DetailNormalMapArray";

		public string name_SecondBaseMap = "_SecondBaseMap";

		public string name_SecondBumpMap = "_SecondBumpMap";

		public string name_SecondMetallicSpecGlossMap = "_SecondMetallicSpecGlossMap";

		public string name_SecondBaseMapArray = "_SecondBaseMapArray";

		public string name_SecondBumpMapArray = "_SecondBumpMapArray";

		public string name_SecondMetallicSpecGlossMapArray = "_SecondMetallicSpecGlossMapArray";

		private bool _Prepared;

		private bool _initialized;

		private int id_OutlineColor;

		private int id_Outline;

		private int id_ToonShadowMap;

		private int id_BaseMap;

		private int id_BaseColor;

		private int id_Cutoff;

		private int id_Smoothness;

		private int id_GlossMapScale;

		private int id_SmoothnessTextureChannel;

		private int id_Metallic;

		private int id_MetallicGlossMap;

		private int id_SpecColor;

		private int id_SpecGlossMap;

		private int id_SpecularHighlights;

		private int id_EnvironmentReflections;

		private int id_BumpScale;

		private int id_BumpMap;

		private int id_Parallax;

		private int id_ParallaxMap;

		private int id_OcclusionStrength;

		private int id_OcclusionMap;

		private int id_EmissionColor;

		private int id_EmissionMap;

		private int id_DetailMask;

		private int id_DetailAlbedoMapScale;

		private int id_DetailAlbedoMap;

		private int id_DetailNormalMapScale;

		private int id_DetailNormalMap;

		private int id_ClearCoatMask;

		private int id_ClearCoatSmoothness;

		private int id_ToonShadowMapArray;

		private int id_BaseMapArray;

		private int id_MetallicGlossMapArray;

		private int id_SpecGlossMapArray;

		private int id_BumpMapArray;

		private int id_ParallaxMapArray;

		private int id_OcclusionMapArray;

		private int id_EmissionMapArray;

		private int id_DetailMaskArray;

		private int id_DetailAlbedoMapArray;

		private int id_DetailNormalMapArray;

		private int id_SecondBaseMap;

		private int id_SecondBumpMap;

		private int id_SecondMetallicSpecGlossMap;

		private int id_SecondBaseMapArray;

		private int id_SecondBumpMapArray;

		private int id_SecondMetallicSpecGlossMapArray;

		public int unityID_BumpMap => id_BumpMap;

		public void ApplyToMaterial(PicoAvatarRenderMaterial nativeMaterial, Material material)
		{
			if (nativeMaterial.has_Outline)
			{
				material.SetFloat(id_Outline, nativeMaterial.mat_Outline);
			}
			if (nativeMaterial.has_Cutoff)
			{
				material.SetFloat(id_Cutoff, nativeMaterial.mat_Cutoff);
			}
			if (nativeMaterial.has_Smoothness)
			{
				material.SetFloat(id_Smoothness, nativeMaterial.mat_Smoothness);
			}
			if (nativeMaterial.has_GlossMapScale)
			{
				material.SetFloat(id_GlossMapScale, nativeMaterial.mat_GlossMapScale);
			}
			if (nativeMaterial.has_SmoothnessTextureChannel)
			{
				material.SetFloat(id_SmoothnessTextureChannel, nativeMaterial.mat_SmoothnessTextureChannel);
			}
			if (nativeMaterial.has_Metallic)
			{
				material.SetFloat(id_Metallic, nativeMaterial.mat_Metallic);
			}
			if (nativeMaterial.has_BumpScale)
			{
				material.SetFloat(id_BumpScale, nativeMaterial.mat_BumpScale);
			}
			if (nativeMaterial.has_Parallax)
			{
				material.SetFloat(id_Parallax, nativeMaterial.mat_Parallax);
			}
			if (nativeMaterial.has_OcclusionStrength)
			{
				material.SetFloat(id_OcclusionStrength, nativeMaterial.mat_OcclusionStrength);
			}
			if (nativeMaterial.has_DetailAlbedoMapScale)
			{
				material.SetFloat(id_DetailAlbedoMapScale, nativeMaterial.mat_DetailAlbedoMapScale);
			}
			if (nativeMaterial.has_DetailNormalMapScale)
			{
				material.SetFloat(id_DetailNormalMapScale, nativeMaterial.mat_DetailNormalMapScale);
			}
			if (nativeMaterial.has_ClearCoatMask)
			{
				material.SetFloat(id_ClearCoatMask, nativeMaterial.mat_ClearCoatMask);
			}
			if (nativeMaterial.has_ClearCoatSmoothness)
			{
				material.SetFloat(id_ClearCoatSmoothness, nativeMaterial.mat_ClearCoatSmoothness);
			}
			if (nativeMaterial.has_BaseColor)
			{
				material.SetColor(id_BaseColor, nativeMaterial.mat_BaseColor);
			}
			if (nativeMaterial.has_OutlineColor)
			{
				material.SetColor(id_OutlineColor, nativeMaterial.mat_OutlineColor);
			}
			if (nativeMaterial.has_SpecColor)
			{
				material.SetColor(id_SpecColor, nativeMaterial.mat_SpecColor);
			}
			if (nativeMaterial.has_EmissionColor)
			{
				material.SetColor(id_EmissionColor, nativeMaterial.mat_EmissionColor);
			}
			setTextureProperty(material, nativeMaterial.mat_ToonShadowMap, id_ToonShadowMap, id_ToonShadowMapArray);
			setTextureProperty(material, nativeMaterial.mat_BaseMap, id_BaseMap, id_BaseMapArray);
			setTextureProperty(material, nativeMaterial.mat_MetallicGlossMap, id_MetallicGlossMap, id_MetallicGlossMapArray);
			setTextureProperty(material, nativeMaterial.mat_SpecGlossMap, id_SpecGlossMap, id_SpecGlossMapArray);
			setTextureProperty(material, nativeMaterial.mat_BumpMap, id_BumpMap, id_BumpMapArray);
			setTextureProperty(material, nativeMaterial.mat_ParallaxMap, id_ParallaxMap, id_ParallaxMapArray);
			setTextureProperty(material, nativeMaterial.mat_EmissionMap, id_EmissionMap, id_EmissionMapArray);
			setTextureProperty(material, nativeMaterial.mat_DetailMask, id_DetailMask, id_DetailMaskArray);
			setTextureProperty(material, nativeMaterial.mat_DetailAlbedoMap, id_DetailAlbedoMap, id_DetailAlbedoMapArray);
			setTextureProperty(material, nativeMaterial.mat_DetailNormalMap, id_DetailNormalMap, id_DetailNormalMapArray);
			setTextureProperty(material, nativeMaterial.mat_SecondBaseMap, id_SecondBaseMap, id_SecondBaseMapArray);
			setTextureProperty(material, nativeMaterial.mat_SecondBumpMap, id_SecondBumpMap, id_SecondBumpMapArray);
			setTextureProperty(material, nativeMaterial.mat_SecondMetallicSpecGlossMap, id_SecondMetallicSpecGlossMap, id_SecondMetallicSpecGlossMapArray);
		}

		public virtual Material ApplyToMaterial(PicoAvatarRenderMaterial nativeMaterial, AvatarLodLevel lodLevel)
		{
			CheckPrepareConfiguration();
			return new Material(SelectMaterial(lodLevel));
		}

		private static void setTextureProperty(Material material, AvatarTexture avatarTexture, int texPropertyId, int arrayPropertyId)
		{
			if (avatarTexture != null)
			{
				if (avatarTexture.runtimeTexture != null)
				{
					material.SetTexture(texPropertyId, avatarTexture.runtimeTexture);
				}
				else if (avatarTexture.runtimeMergedTexture != null)
				{
					material.SetTexture(arrayPropertyId, avatarTexture.runtimeMergedTexture);
				}
			}
		}

		protected virtual Material SelectMaterial(AvatarLodLevel lodLevel)
		{
			_ = lodMaterial4 != null;
			if (lodMaterial3 != null && lodLevel > AvatarLodLevel.Lod2)
			{
				return lodMaterial3;
			}
			if (lodMaterial2 != null && lodLevel > AvatarLodLevel.Lod1)
			{
				return lodMaterial2;
			}
			if (lodMaterial1 != null && lodLevel > AvatarLodLevel.Lod0)
			{
				return lodMaterial1;
			}
			return lodMaterial0;
		}

		protected void CheckPrepareConfiguration()
		{
			if (!_Prepared)
			{
				if (lodMaterial0 == null)
				{
					lodMaterial0 = new Material(Shader.Find("PAV/URP/DiffuseSpec"));
				}
				CheckInitialize();
				_Prepared = true;
			}
		}

		private void CheckInitialize()
		{
			if (!_initialized)
			{
				if (morphAndSkinningShader == null)
				{
					morphAndSkinningShader = Resources.Load<ComputeShader>("MorphAndSkinning");
				}
				if (transferShapingMeshShader == null)
				{
					transferShapingMeshShader = Resources.Load<ComputeShader>("PavTransferShapingMesh");
				}
				id_OutlineColor = Shader.PropertyToID(name_OutlineColor);
				id_Outline = Shader.PropertyToID(name_Outline);
				id_ToonShadowMap = Shader.PropertyToID(name_ToonShadowMap);
				id_BaseMap = Shader.PropertyToID(name_BaseMap);
				id_BaseColor = Shader.PropertyToID(name_BaseColor);
				id_Cutoff = Shader.PropertyToID(name_Cutoff);
				id_Smoothness = Shader.PropertyToID(name_Smoothness);
				id_GlossMapScale = Shader.PropertyToID(name_Smoothness);
				id_SmoothnessTextureChannel = Shader.PropertyToID(name_SmoothnessTextureChannel);
				id_Metallic = Shader.PropertyToID(name_Metallic);
				id_MetallicGlossMap = Shader.PropertyToID(name_MetallicGlossMap);
				id_SpecColor = Shader.PropertyToID(name_SpecColor);
				id_SpecGlossMap = Shader.PropertyToID(name_SpecGlossMap);
				id_SpecularHighlights = Shader.PropertyToID(name_SpecularHighlights);
				id_EnvironmentReflections = Shader.PropertyToID(name_EnvironmentReflections);
				id_BumpScale = Shader.PropertyToID(name_BumpScale);
				id_BumpMap = Shader.PropertyToID(name_BumpMap);
				id_Parallax = Shader.PropertyToID(name_Parallax);
				id_ParallaxMap = Shader.PropertyToID(name_ParallaxMap);
				id_OcclusionStrength = Shader.PropertyToID(name_OcclusionStrength);
				id_OcclusionMap = Shader.PropertyToID(name_OcclusionMap);
				id_EmissionColor = Shader.PropertyToID(name_EmissionColor);
				id_EmissionMap = Shader.PropertyToID(name_EmissionMap);
				id_DetailMask = Shader.PropertyToID(name_DetailMask);
				id_DetailAlbedoMapScale = Shader.PropertyToID(name_DetailAlbedoMapScale);
				id_DetailAlbedoMap = Shader.PropertyToID(name_DetailAlbedoMap);
				id_DetailNormalMapScale = Shader.PropertyToID(name_DetailNormalMapScale);
				id_DetailNormalMap = Shader.PropertyToID(name_DetailNormalMap);
				id_ClearCoatMask = Shader.PropertyToID(name_ClearCoatMask);
				id_ClearCoatSmoothness = Shader.PropertyToID(name_ClearCoatSmoothness);
				id_ToonShadowMapArray = Shader.PropertyToID(name_ToonShadowMapArray);
				id_BaseMapArray = Shader.PropertyToID(name_BaseMapArray);
				id_MetallicGlossMapArray = Shader.PropertyToID(name_MetallicGlossMapArray);
				id_SpecGlossMapArray = Shader.PropertyToID(name_SpecGlossMapArray);
				id_BumpMapArray = Shader.PropertyToID(name_BumpMapArray);
				id_ParallaxMapArray = Shader.PropertyToID(name_ParallaxMapArray);
				id_OcclusionMapArray = Shader.PropertyToID(name_OcclusionMapArray);
				id_EmissionMapArray = Shader.PropertyToID(name_EmissionMapArray);
				id_DetailMaskArray = Shader.PropertyToID(name_DetailMaskArray);
				id_DetailAlbedoMapArray = Shader.PropertyToID(name_DetailAlbedoMapArray);
				id_DetailNormalMapArray = Shader.PropertyToID(name_DetailNormalMapArray);
				id_SecondBaseMap = Shader.PropertyToID(name_SecondBaseMap);
				id_SecondBumpMap = Shader.PropertyToID(name_SecondBumpMap);
				id_SecondMetallicSpecGlossMap = Shader.PropertyToID(name_SecondMetallicSpecGlossMap);
				id_SecondBaseMapArray = Shader.PropertyToID(name_SecondBaseMapArray);
				id_SecondBumpMapArray = Shader.PropertyToID(name_SecondBumpMapArray);
				id_SecondMetallicSpecGlossMapArray = Shader.PropertyToID(name_SecondMetallicSpecGlossMapArray);
				_initialized = true;
			}
		}
	}
	public interface RefTarget
	{
		int refCount { get; }

		void Retain();

		void Release();
	}
	public class ReferencedObject : RefTarget
	{
		private volatile int _refCount;

		public int refCount => _refCount;

		~ReferencedObject()
		{
		}

		public void Retain()
		{
			_refCount++;
		}

		public void Release()
		{
			if (--_refCount == 0)
			{
				OnDestroy();
			}
		}

		public void CheckDelete()
		{
			if (_refCount <= 0)
			{
				OnDestroy();
			}
		}

		protected virtual void OnDestroy()
		{
		}

		public static void Replace<T>(ref T dest, T src) where T : RefTarget
		{
			src?.Retain();
			if (dest != null)
			{
				dest.Release();
			}
			dest = src;
		}

		public static void ReleaseField<T>(ref T field) where T : RefTarget
		{
			if (field != null)
			{
				T val = field;
				field = default(T);
				val.Release();
			}
		}
	}
	public abstract class NativeObject : ReferencedObject
	{
		private IntPtr _nativeHandle;

		private const string PavDLLName = "effect";

		public IntPtr nativeHandle => _nativeHandle;

		~NativeObject()
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				pav_Object_Release(_nativeHandle);
				_nativeHandle = IntPtr.Zero;
			}
		}

		[Preserve]
		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (_nativeHandle != IntPtr.Zero)
			{
				pav_Object_Release(_nativeHandle);
				_nativeHandle = IntPtr.Zero;
			}
		}

		public static void RetainNative(IntPtr nativeObjectPtr)
		{
			pav_Object_Retain(nativeObjectPtr);
		}

		public static void ReleaseNative(ref IntPtr nativeObjectPtr)
		{
			if (nativeObjectPtr != IntPtr.Zero)
			{
				IntPtr nativeObjectPtr2 = nativeObjectPtr;
				nativeObjectPtr = IntPtr.Zero;
				pav_Object_Release(nativeObjectPtr2);
			}
		}

		public virtual void OnPostLoad()
		{
		}

		protected void SetNativeHandle(IntPtr nativeHandle_, bool needRetain)
		{
			if (!(nativeHandle_ == _nativeHandle))
			{
				if (nativeHandle_ != IntPtr.Zero && needRetain)
				{
					pav_Object_Retain(nativeHandle_);
				}
				if (_nativeHandle != IntPtr.Zero)
				{
					pav_Object_Release(_nativeHandle);
				}
				_nativeHandle = nativeHandle_;
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_Object_Retain(IntPtr nativeObjectPtr);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_Object_Release(IntPtr nativeObjectPtr);
	}
	public class RefTargetGuard<T> : IDisposable where T : RefTarget
	{
		private T _Object;

		private bool _NeedRelease;

		public T target => _Object;

		public RefTargetGuard(T obj)
		{
			_Object = obj;
			if (obj != null)
			{
				obj.Retain();
				_NeedRelease = true;
			}
		}

		~RefTargetGuard()
		{
			Dispose();
		}

		public void Dispose()
		{
			if (_NeedRelease)
			{
				_NeedRelease = false;
				_Object.Release();
			}
		}
	}
	public class ReferencedObjectArray<T> where T : ReferencedObject
	{
		private T[] _Array;

		public int Length => _Array.Length;

		public T this[int i]
		{
			get
			{
				return _Array[i];
			}
			set
			{
				value?.Retain();
				if (_Array[i] != null)
				{
					_Array[i].Release();
				}
				_Array[i] = value;
			}
		}

		public ReferencedObjectArray(int count)
		{
			_Array = new T[count];
		}

		public void Clear()
		{
			for (int i = 0; i < _Array.Length; i++)
			{
				if (_Array[i] != null)
				{
					_Array[i].Release();
					_Array[i] = null;
				}
			}
		}
	}
	public class PicoPlaceholderAvatar : PicoAvatar
	{
		private bool _isForLocalAvatar;

		private int _entityRefCount;

		public bool isForLocalAvatar => _isForLocalAvatar;

		public bool isReferenced => _entityRefCount > 0;

		public void Internal_RetainPlaceholderEntity(PicoAvatarPlaceholderRef placeHolderRef, Action<AvatarEntity> readyCallback)
		{
			_entityRefCount++;
			if (_entityRefCount == 1 && !_isForLocalAvatar)
			{
				base.gameObject.SetActive(value: true);
			}
			AddFirstEntityReadyCallback(delegate(AvatarEntity entity)
			{
				if (_entityRefCount == 1)
				{
					PlayAnimation("idlePlaceHolder");
				}
				readyCallback(entity);
				_ = _isForLocalAvatar;
			});
		}

		public void Internal_ReleasePlaceholderEntity(PicoAvatarPlaceholderRef placeHolderRef)
		{
			if (--_entityRefCount == 0 && base.curState != State.Dead)
			{
				if (_isForLocalAvatar)
				{
					PicoAvatarManager.instance.UnloadAvatar(this);
					return;
				}
				StopAnimation();
				base.gameObject.SetActive(value: false);
			}
		}

		public void Internal_SetForLocalAvatar(bool forLocalAvatar)
		{
			_isForLocalAvatar = forLocalAvatar;
		}

		public override void Internal_OnAvatarEntityLodReadyToShow(AvatarEntity avatarEntity, AvatarLodLevel curLodLevel)
		{
			base.Internal_OnAvatarEntityLodReadyToShow(avatarEntity, curLodLevel);
			if (!_isForLocalAvatar && _entityRefCount == 0)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class PicoAvatarPlaceholderRef
	{
		private bool _isForLocalAvatar;

		private bool _isMirror;

		private Transform _parentTrans;

		private string _name;

		private Transform _copiedEntityTrans;

		private WeakReference<PicoPlaceholderAvatar> _weakPlaceHolderAvatar;

		public bool isForLocalAvatar => _isForLocalAvatar;

		public bool isReady => _copiedEntityTrans != null;

		public PicoAvatarPlaceholderRef(string name, Transform parentTrans, PicoPlaceholderAvatar placeHolderAvatar, bool isMirror = false)
		{
			PicoAvatarPlaceholderRef picoAvatarPlaceholderRef = this;
			if (parentTrans == null || placeHolderAvatar == null)
			{
				throw new ArgumentNullException("parent and placeHolderAvatar can not be null");
			}
			_parentTrans = parentTrans;
			_name = name;
			_isForLocalAvatar = placeHolderAvatar.isForLocalAvatar;
			_weakPlaceHolderAvatar = new WeakReference<PicoPlaceholderAvatar>(placeHolderAvatar);
			_isMirror = isMirror;
			placeHolderAvatar.Internal_RetainPlaceholderEntity(this, delegate(AvatarEntity entity)
			{
				if (picoAvatarPlaceholderRef._parentTrans != null && picoAvatarPlaceholderRef._copiedEntityTrans == null)
				{
					Transform transform = entity.transform;
					GameObject gameObject = UnityEngine.Object.Instantiate(entity.gameObject, picoAvatarPlaceholderRef._parentTrans);
					gameObject.name = "PlaceHolderEntity";
					picoAvatarPlaceholderRef._copiedEntityTrans = gameObject.transform;
					picoAvatarPlaceholderRef._copiedEntityTrans.localPosition = transform.localPosition;
					picoAvatarPlaceholderRef._copiedEntityTrans.localRotation = transform.localRotation;
					picoAvatarPlaceholderRef._copiedEntityTrans.localScale = Vector3.one;
					if (picoAvatarPlaceholderRef.isForLocalAvatar && !isMirror)
					{
						gameObject.SetActive(value: true);
					}
					else
					{
						gameObject.SetActiveRecursively(state: true);
					}
					if (picoAvatarPlaceholderRef.isForLocalAvatar)
					{
						picoAvatarPlaceholderRef._copiedEntityTrans.localRotation = transform.localRotation * Quaternion.Euler(0f, 180f, 0f);
					}
				}
			});
		}

		public void Release()
		{
			_parentTrans = null;
			if (_copiedEntityTrans != null)
			{
				UnityEngine.Object.Destroy(_copiedEntityTrans.gameObject);
				_copiedEntityTrans = null;
			}
			if (_weakPlaceHolderAvatar != null)
			{
				if (_weakPlaceHolderAvatar.TryGetTarget(out var target))
				{
					target?.Internal_ReleasePlaceholderEntity(this);
				}
				_weakPlaceHolderAvatar = null;
			}
		}

		public PicoPlaceholderAvatar GetPlaceholderAvatar()
		{
			if (_weakPlaceHolderAvatar != null && _weakPlaceHolderAvatar.TryGetTarget(out var target))
			{
				return target;
			}
			return null;
		}

		public void UpdateMovement()
		{
			if (isForLocalAvatar && _weakPlaceHolderAvatar != null && _weakPlaceHolderAvatar.TryGetTarget(out var target) && _copiedEntityTrans != null && target != null && target.entity != null && target.curState != PicoAvatar.State.Dead)
			{
				Transform transform = target.entity.transform;
				_copiedEntityTrans.localPosition = transform.localPosition;
				_copiedEntityTrans.localRotation = transform.localRotation;
			}
		}
	}
	public enum JointType
	{
		Invalid = -1,
		Root = 0,
		RootScale = 1,
		Hips = 2,
		SpineLower = 3,
		SpineMiddle = 4,
		SpineUpper = 5,
		Chest = 6,
		Neck = 7,
		Head = 8,
		Hair = 9,
		LeftLegUpper = 20,
		LeftLegLower = 21,
		LeftFootAnkle = 22,
		LeftToe = 23,
		LeftToeEnd = 24,
		RightLegUpper = 25,
		RightLegLower = 26,
		RightFootAnkle = 27,
		RightToe = 28,
		RightToeEnd = 29,
		LeftShoulder = 30,
		LeftArmUpper = 31,
		LeftArmUpperTwist = 33,
		LeftArmLower = 34,
		LeftHandTwist = 35,
		LeftHandTwist2 = 36,
		LeftHandWrist = 37,
		RightShoulder = 38,
		RightArmUpper = 39,
		RightArmUpperTwist = 40,
		RightArmLower = 41,
		RightHandTwist = 42,
		RightHandTwist2 = 43,
		RightHandWrist = 44,
		BasicJointCount = 45,
		LeftHandThumbRoot = 50,
		LeftHandThumbTrapezium = 51,
		LeftHandThumbMeta = 52,
		LeftHandThumbProximal = 53,
		LeftHandThumbDistal = 54,
		LeftHandIndexRoot = 55,
		LeftHandIndexMeta = 56,
		LeftHandIndexProximal = 57,
		LeftHandIndexIntermediate = 58,
		LeftHandIndexDistal = 59,
		LeftHandMiddleRoot = 60,
		LeftHandMiddleMeta = 61,
		LeftHandMiddleProximal = 62,
		LeftHandMiddleIntermediate = 63,
		LeftHandMiddleDistal = 64,
		LeftHandRingRoot = 65,
		LeftHandRingMeta = 66,
		LeftHandRingProximal = 67,
		LeftHandRingIntermediate = 68,
		LeftHandRingDistal = 69,
		LeftHandPinkyRoot = 70,
		LeftHandPinkyMeta = 71,
		LeftHandPinkyProximal = 72,
		LeftHandPinkyIntermediate = 73,
		LeftHandPinkyDistal = 74,
		RightHandThumbRoot = 80,
		RightHandThumbTrapezium = 81,
		RightHandThumbMeta = 82,
		RightHandThumbProximal = 83,
		RightHandThumbDistal = 84,
		RightHandIndexRoot = 85,
		RightHandIndexMeta = 86,
		RightHandIndexProximal = 87,
		RightHandIndexIntermediate = 88,
		RightHandIndexDistal = 89,
		RightHandMiddleRoot = 90,
		RightHandMiddleMeta = 91,
		RightHandMiddleProximal = 92,
		RightHandMiddleIntermediate = 93,
		RightHandMiddleDistal = 94,
		RightHandRingRoot = 95,
		RightHandRingMeta = 96,
		RightHandRingProximal = 97,
		RightHandRingIntermediate = 98,
		RightHandRingDistal = 99,
		RightHandPinkyRoot = 100,
		RightHandPinkyMeta = 101,
		RightHandPinkyProximal = 102,
		RightHandPinkyIntermediate = 103,
		RightHandPinkyDistal = 104,
		Count = 105
	}
	public class TypeID2NameIDTable : NativeObject
	{
		private Dictionary<uint, uint> _cachedTypeId2NameIds;

		private const string PavDLLName = "effect";

		public TypeID2NameIDTable(IntPtr nativeHandle_)
		{
			SetNativeHandle(nativeHandle_, needRetain: false);
		}

		public uint GetNameID(uint typeId)
		{
			if (_cachedTypeId2NameIds == null)
			{
				_cachedTypeId2NameIds = new Dictionary<uint, uint>();
			}
			uint value = 0u;
			if (_cachedTypeId2NameIds.TryGetValue(typeId, out value))
			{
				return value;
			}
			value = pav_TypeID2NameIDTable_GetNameID(base.nativeHandle, typeId);
			_cachedTypeId2NameIds.Add(typeId, value);
			return value;
		}

		private TypeID2NameIDTable()
		{
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_TypeID2NameIDTable_GetNameID(IntPtr nativeHandle, uint typeId);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_TypeID2NameIDTable_SetTypeIdWithName(IntPtr nativeHandle, uint typeId, string nameStr);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_TypeID2NameIDTable_SetTypeIDWithNameID(IntPtr nativeHandle, uint typeId, uint nameID);
	}
	public enum BufferType
	{
		CameraColor,
		Custom
	}
	public enum CommonFullscreenFeatureType
	{
		ToonLine = 1,
		ColorTemperature
	}
	public class PicoAvatarDrawFullscreenFeature : ScriptableRendererFeature
	{
		[Serializable]
		public class Settings
		{
			public RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingOpaques;

			public Material blitMaterial;

			public int blitMaterialPassIndex = -1;

			public BufferType sourceType;

			public BufferType destinationType;

			public string sourceTextureId = "_SourceTexture";

			public string destinationTextureId = "_DestinationTexture";

			public CommonFullscreenFeatureType featureType;
		}

		public Settings settings = new Settings();

		private PicoAvatarDrawFullscreenPass blitPass;

		private bool shouldSkipped()
		{
			_ = settings.featureType;
			_ = 2;
			return false;
		}

		public override void Create()
		{
			blitPass = new PicoAvatarDrawFullscreenPass(base.name);
		}

		public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
		{
			if ((!(PicoAvatarApp.instance != null) || (PicoAvatarApp.instance.enabledFullscreenFeatures & (uint)settings.featureType) != 0) && !shouldSkipped())
			{
				if (settings.blitMaterial == null && PicoAvatarApp.instance != null && PicoAvatarApp.instance.materialConfiguration != null)
				{
					settings.blitMaterial = PicoAvatarApp.instance.materialConfiguration.colorTemperatureMaterial;
				}
				if (settings.blitMaterial == null)
				{
					UnityEngine.Debug.LogWarningFormat("Missing Blit Material. {0} blit pass will not execute. Check for missing reference in the assigned renderer.", GetType().Name);
				}
				else
				{
					blitPass.renderPassEvent = settings.renderPassEvent;
					blitPass.settings = settings;
					renderer.EnqueuePass(blitPass);
				}
			}
		}
	}
	internal class PicoAvatarDrawFullscreenPass : ScriptableRenderPass
	{
		public PicoAvatarDrawFullscreenFeature.Settings settings;

		private RenderTargetIdentifier source;

		private RenderTargetIdentifier destination;

		private int temporaryRTId = Shader.PropertyToID("_TempRT");

		private int sourceId;

		private int destinationId;

		private bool isSourceAndDestinationSameTarget;

		private string m_ProfilerTag;

		public FilterMode filterMode { get; set; }

		public PicoAvatarDrawFullscreenPass(string tag)
		{
			m_ProfilerTag = tag;
		}

		public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
		{
			base.Configure(cmd, cameraTextureDescriptor);
		}

		public void Prepare(CommandBuffer cmd, ref RenderingData renderingData)
		{
			RenderTextureDescriptor cameraTargetDescriptor = renderingData.cameraData.cameraTargetDescriptor;
			cameraTargetDescriptor.depthBufferBits = 0;
			isSourceAndDestinationSameTarget = settings.sourceType == settings.destinationType && (settings.sourceType == BufferType.CameraColor || settings.sourceTextureId == settings.destinationTextureId);
			if (settings.sourceType == BufferType.CameraColor)
			{
				sourceId = -1;
				source = base.colorAttachment;
			}
			else
			{
				sourceId = Shader.PropertyToID(settings.sourceTextureId);
				cmd.GetTemporaryRT(sourceId, cameraTargetDescriptor, filterMode);
				source = new RenderTargetIdentifier(sourceId);
			}
			if (isSourceAndDestinationSameTarget)
			{
				destinationId = temporaryRTId;
				cmd.GetTemporaryRT(destinationId, cameraTargetDescriptor, filterMode);
				destination = new RenderTargetIdentifier(destinationId);
			}
			else if (settings.destinationType == BufferType.CameraColor)
			{
				destinationId = -1;
				destination = base.colorAttachment;
			}
			else
			{
				destinationId = Shader.PropertyToID(settings.destinationTextureId);
				cmd.GetTemporaryRT(destinationId, cameraTargetDescriptor, filterMode);
				destination = new RenderTargetIdentifier(destinationId);
			}
		}

		public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
		{
			CommandBuffer commandBuffer = CommandBufferPool.Get(m_ProfilerTag);
			Prepare(commandBuffer, ref renderingData);
			if (isSourceAndDestinationSameTarget)
			{
				Blit(commandBuffer, source, destination, settings.blitMaterial, settings.blitMaterialPassIndex);
				Blit(commandBuffer, destination, source);
			}
			else
			{
				Blit(commandBuffer, source, destination, settings.blitMaterial, settings.blitMaterialPassIndex);
			}
			context.ExecuteCommandBuffer(commandBuffer);
			CommandBufferPool.Release(commandBuffer);
		}

		public override void FrameCleanup(CommandBuffer cmd)
		{
			if (destinationId != -1)
			{
				cmd.ReleaseTemporaryRT(destinationId);
			}
			if (source == destination && sourceId != -1)
			{
				cmd.ReleaseTemporaryRT(sourceId);
			}
		}
	}
	public class RenderSystem
	{
		public enum RenderApiType
		{
			Invalid,
			Win_D3D11,
			Android_Gles3,
			IOS_Metal,
			OSX_Metal,
			Num
		}

		public enum GPUGrade
		{
			Low,
			Medium,
			High
		}

		public struct RenderApiTrait
		{
			public string programMiddleName;

			public string resourcePostName;

			public RenderApiTrait(string _programMiddleName, string _resPostName)
			{
				programMiddleName = _programMiddleName;
				resourcePostName = _resPostName;
			}
		}

		private static string[] _ResourcePlatformNames = new string[5] { "", "w32", "agl3", "iosm", "osxm" };

		private static string[] _ResourceTechniqueLevelNames = new string[3] { "t0", "t1", "t2" };

		public static RenderApiTrait[] apiTraits = new RenderApiTrait[5]
		{
			new RenderApiTrait("_invalid_", "_"),
			new RenderApiTrait("_dxbc_", "_w32"),
			new RenderApiTrait("_essl_", "_agl3"),
			new RenderApiTrait("_metal_", "_iosm"),
			new RenderApiTrait("_metalsrc_", "_osxm")
		};

		public static GPUGrade gpuGrade = GPUGrade.High;

		public static ResourceTechniqueLevel techniqueLevel = ResourceTechniqueLevel.Full;

		public static HashSet<TextureFormat> supportedTextures = null;

		private static RenderApiType _RenderApiType;

		public static string[] resourcePlatformNames => _ResourcePlatformNames;

		public static string[] resourceTechniqueLevelNames => _ResourceTechniqueLevelNames;

		public static ResourcePlatform GetResourcePlatformFormFileName(string fileName)
		{
			if (fileName.Contains(apiTraits[1].resourcePostName + ".bytes"))
			{
				return ResourcePlatform.PC;
			}
			if (fileName.Contains(apiTraits[2].resourcePostName + ".bytes"))
			{
				return ResourcePlatform.Mobile;
			}
			if (fileName.Contains(apiTraits[3].resourcePostName + ".bytes"))
			{
				return ResourcePlatform.Mobile;
			}
			if (fileName.Contains(apiTraits[4].resourcePostName + ".bytes"))
			{
				return ResourcePlatform.PC;
			}
			return ResourcePlatform.Any;
		}

		public static ResourcePlatform GetResourcePlatformFormRenderAPI(RenderApiType renderApi)
		{
			switch (renderApi)
			{
			case RenderApiType.Android_Gles3:
			case RenderApiType.IOS_Metal:
				return ResourcePlatform.Mobile;
			case RenderApiType.Win_D3D11:
			case RenderApiType.OSX_Metal:
				return ResourcePlatform.PC;
			default:
				return ResourcePlatform.Any;
			}
		}

		public static string GetResourceNameByPlatform(string name)
		{
			return name + apiTraits[(int)_RenderApiType].resourcePostName;
		}
	}
	public class CoroutineExecutor
	{
		private static MonoBehaviour _coroutineHolder;

		private static List<Action> _TaskQueueDuringUpdate = new List<Action>();

		private static List<Action> _TaskQueueDuringUpdateShadow = new List<Action>();

		private static SpinLock _Lock = new SpinLock(enableThreadOwnerTracking: true);

		public static void Start(MonoBehaviour holder)
		{
			_coroutineHolder = holder;
		}

		public static void Stop(MonoBehaviour holder)
		{
			if (_coroutineHolder == holder)
			{
				_coroutineHolder = null;
			}
		}

		public static Coroutine DoDelayedWork(Action callback, float time = 1f)
		{
			if (_coroutineHolder == null)
			{
				throw new Exception("_coroutineHolder not set yet.");
			}
			return _coroutineHolder.StartCoroutine(CoroutineDelayedWork(callback, time));
		}

		public static Coroutine DoConditionDelayedWork<T>(T[] target, T value, Action callback) where T : IComparable
		{
			if (_coroutineHolder == null)
			{
				throw new Exception("_coroutineHolder not set yet.");
			}
			return _coroutineHolder.StartCoroutine(CoroutineConditionDelayedWork(target, value, callback));
		}

		private static IEnumerator CoroutineConditionDelayedWork<T>(T[] target, T value, Action callback) where T : IComparable
		{
			while (target[0].CompareTo(value) != 0)
			{
				yield return null;
			}
			if (callback != null)
			{
				try
				{
					callback();
				}
				catch (Exception)
				{
				}
			}
		}

		private static IEnumerator CoroutineDelayedWork(Action callback, float time)
		{
			yield return new WaitForSeconds(time);
			try
			{
				callback();
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		public static void QueueWorkDuringUpdate(Action callback)
		{
			bool lockTaken = false;
			_Lock.Enter(ref lockTaken);
			if (lockTaken)
			{
				_TaskQueueDuringUpdate.Add(callback);
				_Lock.Exit();
				return;
			}
			throw new Exception("QueueWorkDuringUpdate wrong lock!");
		}

		private static void DispatchWorkQueueDuringUpdate()
		{
			bool lockTaken = false;
			_Lock.Enter(ref lockTaken);
			if (lockTaken)
			{
				List<Action> taskQueueDuringUpdateShadow = _TaskQueueDuringUpdateShadow;
				_TaskQueueDuringUpdateShadow = _TaskQueueDuringUpdate;
				_TaskQueueDuringUpdate = taskQueueDuringUpdateShadow;
				_Lock.Exit();
				foreach (Action item in _TaskQueueDuringUpdateShadow)
				{
					item();
				}
				_TaskQueueDuringUpdateShadow.Clear();
				return;
			}
			throw new Exception("DispatchWorkQueueDuringUpdate wrong lock!");
		}
	}
	public static class PicoAsyncCoroutineYieldType
	{
		public static readonly object ToMainThread;

		public static readonly object ToWorkThread;

		public static readonly object ToExit;

		public static readonly object ToMainThreadFollows;

		static PicoAsyncCoroutineYieldType()
		{
			ToMainThread = new object();
			ToWorkThread = new object();
			ToExit = new object();
			ToMainThreadFollows = new object();
		}
	}
	public class AsyncCoroutine : IEnumerator
	{
		private enum State
		{
			ToWorkThread,
			InWorkThread,
			ToMainThread,
			PendingYieldReturn,
			Finished,
			Cancelled
		}

		private State _state;

		private State _previousState;

		private IEnumerator _actualCoroutine;

		private object _pendingYieldObject;

		public object Current { get; private set; }

		public bool MoveNext()
		{
			return UpdateState();
		}

		public void Reset()
		{
			throw new NotSupportedException("AsyncCoroutine DONOT support Reset.");
		}

		public AsyncCoroutine(IEnumerator actualCoutine_)
		{
			_actualCoroutine = actualCoutine_;
			_state = State.ToWorkThread;
		}

		public void Cancel()
		{
			SetState(State.Cancelled);
		}

		private void SetState(State state)
		{
			lock (this)
			{
				if (_state != state && _state != State.Cancelled)
				{
					_state = state;
					_previousState = state;
				}
			}
		}

		private bool UpdateState()
		{
			if (_actualCoroutine == null)
			{
				return false;
			}
			Current = null;
			while (true)
			{
				switch (_state)
				{
				case State.ToWorkThread:
					PostToWorkThread();
					break;
				case State.InWorkThread:
					return true;
				case State.ToMainThread:
					ExecuteActualCoroutine(null);
					break;
				case State.PendingYieldReturn:
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToWorkThread)
					{
						PostToWorkThread();
						break;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToMainThread)
					{
						SetState(State.ToMainThread);
						ExecuteActualCoroutine(null);
						break;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToMainThreadFollows)
					{
						if (ExecuteMainThreadFollowingCoroutines())
						{
							break;
						}
						return true;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToExit)
					{
						SetState(State.Cancelled);
						return false;
					}
					Current = _pendingYieldObject;
					if (_previousState == State.InWorkThread)
					{
						_pendingYieldObject = PicoAsyncCoroutineYieldType.ToWorkThread;
					}
					else
					{
						_pendingYieldObject = PicoAsyncCoroutineYieldType.ToMainThread;
					}
					return true;
				default:
					return false;
				}
			}
		}

		private void PostToWorkThread()
		{
			SetState(State.InWorkThread);
			ThreadPool.QueueUserWorkItem(ExecuteActualCoroutine);
		}

		private void ExecuteActualCoroutine(object state)
		{
			try
			{
				if (_actualCoroutine.MoveNext())
				{
					lock (this)
					{
						_pendingYieldObject = _actualCoroutine.Current;
					}
					SetState(State.PendingYieldReturn);
				}
				else
				{
					SetState(State.Finished);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"{ex.Message}\n{ex.StackTrace}");
			}
		}

		private bool ExecuteMainThreadFollowingCoroutines()
		{
			try
			{
				while (_actualCoroutine.MoveNext())
				{
					_pendingYieldObject = _actualCoroutine.Current;
					SetState(State.PendingYieldReturn);
					if (_pendingYieldObject is IEnumerator coroutine)
					{
						if (RecursivelySyncRunCoroutine(coroutine) == PicoAsyncCoroutineYieldType.ToExit)
						{
							_pendingYieldObject = null;
							SetState(State.Cancelled);
						}
						continue;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToExit)
					{
						_pendingYieldObject = null;
						SetState(State.Cancelled);
						break;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToWorkThread)
					{
						break;
					}
					if (_pendingYieldObject == PicoAsyncCoroutineYieldType.ToMainThreadFollows)
					{
						return false;
					}
				}
				SetState(State.Finished);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"{ex.Message}\n{ex.StackTrace}");
			}
			return true;
		}

		private object RecursivelySyncRunCoroutine(IEnumerator coroutine)
		{
			while (coroutine.MoveNext())
			{
				object current = coroutine.Current;
				if (current != null)
				{
					if (current is IEnumerator coroutine2)
					{
						RecursivelySyncRunCoroutine(coroutine2);
					}
					else if (current == PicoAsyncCoroutineYieldType.ToExit)
					{
						return current;
					}
				}
			}
			return null;
		}
	}
	public static class AsyncCoroutineMonoBehaviourExtensions
	{
		public static Coroutine StartAsyncCoroutine(this MonoBehaviour behaviour, IEnumerator routine)
		{
			return behaviour.StartCoroutine(new AsyncCoroutine(routine));
		}
	}
	public class PicoAvatarStats
	{
		public enum StatsType
		{
			AppBoot,
			AvatarManagerLogin,
			FirstAvatarVisible,
			AverageAvatarLoad,
			AvatarTotalUpdate,
			AvatarPreUpdate,
			AvatarCoreUpdate,
			AvatarRenderUpdate,
			Num
		}

		public enum InstanceType
		{
			AvatarPrimitive,
			AvatarRenderMaterial,
			AvatarRenderMesh,
			AvatarTexture,
			AvatarBodyAnimController,
			AvatarAnimationLayer,
			AvatarAnimationState,
			NativeCaller,
			NativeCallee,
			IDParameterTable,
			Num
		}

		private float[] _statStartTimes = new float[8];

		private float[] _statCostTimes = new float[8];

		private int[] _instanceCounts = new int[10];

		public static PicoAvatarStats instance { get; set; }

		public float GetCostTime(StatsType statsType)
		{
			return _statCostTimes[(int)statsType];
		}

		public void EmitStart(StatsType statType)
		{
			_statStartTimes[(int)statType] = AvatarEnv.realtimeSinceStartup;
		}

		public void EmitFinish(StatsType statType, bool logStat = false)
		{
			float num = AvatarEnv.realtimeSinceStartup - _statStartTimes[(int)statType];
			_statCostTimes[(int)statType] = num;
			if (logStat)
			{
				AvatarEnv.Log(DebugLogMask.ForceLog, string.Format("{0} {1} cost:{2}s", "AvatarSDK", statType.ToString(), num));
			}
		}

		public void AppBootStart()
		{
			EmitStart(StatsType.AppBoot);
			EmitStart(StatsType.FirstAvatarVisible);
		}

		public void AppBootFinished()
		{
			EmitFinish(StatsType.AppBoot, logStat: true);
		}

		public void AvatrManagerLoginStart()
		{
			EmitStart(StatsType.AvatarManagerLogin);
		}

		public void AvatarManagerLoginFinished()
		{
			EmitFinish(StatsType.AvatarManagerLogin, logStat: true);
		}

		public void FirstAvatarVisible()
		{
			EmitStart(StatsType.FirstAvatarVisible);
		}

		public void AvatarLodReady(string avatarId, AvatarLodLevel lodLevel, float costTime)
		{
			if (_statCostTimes[2] == 0f)
			{
				EmitFinish(StatsType.FirstAvatarVisible, logStat: true);
			}
			AvatarEnv.Log(DebugLogMask.ForceLog, string.Format("{0} {1} avatarId:{2} lod:{3} cost:{4}", "AvatarSDK", "AvatarLoad", avatarId, lodLevel.ToString(), costTime));
		}

		public void IncreaseInstanceCount(InstanceType instanceType)
		{
			Interlocked.Increment(ref _instanceCounts[(int)instanceType]);
		}

		public void DecreaseInstanceCount(InstanceType instanceType)
		{
			Interlocked.Decrement(ref _instanceCounts[(int)instanceType]);
		}

		public void LogStats()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("instances:");
			for (int i = 0; i < 10; i++)
			{
				InstanceType instanceType = (InstanceType)i;
				stringBuilder.Append($"{instanceType.ToString()}={_instanceCounts[i]} | ");
			}
			UnityEngine.Debug.Log(stringBuilder.ToString());
		}
	}
	public static class Utility
	{
		public class AvatarResourceConfig
		{
			public string hash;

			public List<string> fileList;

			public static AvatarResourceConfig FromJson(string json)
			{
				AvatarResourceConfig avatarResourceConfig = null;
				try
				{
					avatarResourceConfig = new AvatarResourceConfig();
					Dictionary<string, object> json2 = Json.Deserialize(json) as Dictionary<string, object>;
					avatarResourceConfig.hash = MiniJSONUtil.GetString(json2, "hash");
					List<object> list = MiniJSONUtil.GetList(json2, "fileList");
					avatarResourceConfig.fileList = new List<string>();
					for (int i = 0; i < list.Count; i++)
					{
						avatarResourceConfig.fileList.Add((string)list[i]);
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				return avatarResourceConfig;
			}

			public string ToJson()
			{
				return Json.Serialize(new Dictionary<string, object>
				{
					{ "hash", hash },
					{ "fileList", fileList }
				});
			}
		}

		public class StringCharBuffer
		{
			private byte[] _SharedStringBuffer;

			private GCHandle _SharedStringBufferHandle;

			public uint length
			{
				get
				{
					if (_SharedStringBuffer != null)
					{
						return (uint)(_SharedStringBuffer.Length - 1);
					}
					return 0u;
				}
			}

			public StringCharBuffer(uint size = 1048576u)
			{
				_SharedStringBuffer = new byte[size];
			}

			~StringCharBuffer()
			{
				if (_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle.Free();
				}
			}

			public IntPtr Lock()
			{
				if (!_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle = GCHandle.Alloc(_SharedStringBuffer, GCHandleType.Pinned);
				}
				return _SharedStringBufferHandle.AddrOfPinnedObject();
			}

			public void Unlock()
			{
				if (_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle.Free();
				}
			}

			public string GetANSIString(uint strLen)
			{
				if (_SharedStringBuffer == null)
				{
					return null;
				}
				if (_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle.Free();
				}
				return Encoding.ASCII.GetString(_SharedStringBuffer, 0, Math.Min((int)strLen, _SharedStringBuffer.Length));
			}

			public string GetUTF8String(uint strLen)
			{
				if (_SharedStringBuffer == null)
				{
					return null;
				}
				if (_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle.Free();
				}
				return Encoding.UTF8.GetString(_SharedStringBuffer, 0, Math.Min((int)strLen, _SharedStringBuffer.Length));
			}

			public string GetUTF16String(uint strLen)
			{
				if (_SharedStringBuffer == null)
				{
					return null;
				}
				if (_SharedStringBufferHandle.IsAllocated)
				{
					_SharedStringBufferHandle.Free();
				}
				return Encoding.Unicode.GetString(_SharedStringBuffer, 0, Math.Min((int)strLen, _SharedStringBuffer.Length));
			}
		}

		public static bool EnableSDKUpdate = true;

		public static bool EnableRenderObject = true;

		public static bool EnableSkin = false;

		public const string VersionFilePath = "AvatarResource.version";

		public const string ResourceConfigFilePath = "AvatarResourceConfig.txt";

		private const string ResouceCacheHashKey = "AvatarResourceHash";

		public const string PackedAvatarSDKScriptHashFilePath = "AvatarSDKScript.hash";

		private static StringCharBuffer _SharedStringBuffer = new StringCharBuffer();

		private static Dictionary<string, uint> sNameIDTable = new Dictionary<string, uint>();

		private static byte[] byteBuffer = null;

		private const string PavDLLName = "effect";

		public static StringCharBuffer sharedStringBuffer => _SharedStringBuffer;

		public static string GetPathNameWithEndSlash(string pathName)
		{
			string text = pathName.Replace('\\', '/');
			if (!text.EndsWith("/"))
			{
				text += "/";
			}
			return text;
		}

		public static bool IsNullOrEmpty(string val)
		{
			return string.IsNullOrEmpty(val);
		}

		public static bool IsNullOrEmpty(MemoryStream val)
		{
			if (val != null)
			{
				return val.Length == 0;
			}
			return true;
		}

		public static bool IsNullOrEmpty(byte[] bytes)
		{
			if (bytes != null)
			{
				return bytes.Length == 0;
			}
			return true;
		}

		public static bool IsNullOrEmpty<T>(T[] array)
		{
			if (array != null)
			{
				return array.Length == 0;
			}
			return true;
		}

		public static bool IsNullOrEmpty(MemoryView data)
		{
			if (data != null)
			{
				return data.length == 0;
			}
			return true;
		}

		public static void LogMeshData(Mesh mesh, string logFileName)
		{
			FileStream fileStream = new FileStream(Path.Combine(Application.persistentDataPath, logFileName), FileMode.Create);
			StreamWriter streamWriter = new StreamWriter(fileStream);
			streamWriter.WriteLine($"Mesh: {mesh.name}");
			streamWriter.WriteLine($"-Vertices ({mesh.vertexCount})");
			Vector3[] vertices = mesh.vertices;
			for (int i = 0; i < vertices.Length; i++)
			{
				streamWriter.WriteLine($" （{vertices[i].x}, {vertices[i].y}, {vertices[i].z}）");
			}
			streamWriter.WriteLine();
			streamWriter.WriteLine($"-SubMeshes ({mesh.subMeshCount})");
			for (int j = 0; j < mesh.subMeshCount; j++)
			{
				int[] indices = mesh.GetIndices(j);
				int num = indices.Length / 3;
				streamWriter.WriteLine($"-SubMesh {j} ({num} triangles)");
				for (int k = 0; k < num; k++)
				{
					streamWriter.WriteLine(" triangle {0}: ({1}, {2}, {3})", k, indices[3 * k], indices[3 * k + 1], indices[3 * k + 2]);
				}
			}
			streamWriter.WriteLine();
			BoneWeight[] boneWeights = mesh.boneWeights;
			streamWriter.WriteLine($"-BoneWeights ({boneWeights.Length})");
			for (int l = 0; l < boneWeights.Length; l++)
			{
				string text = " BoneWeight " + l;
				BoneWeight boneWeight = boneWeights[l];
				text += $" ({boneWeight.boneIndex0}:{boneWeight.weight0})";
				text += $" ({boneWeight.boneIndex1}:{boneWeight.weight1})";
				text += $" ({boneWeight.boneIndex2}:{boneWeight.weight2})";
				text += $" ({boneWeight.boneIndex3}:{boneWeight.weight3})";
				streamWriter.WriteLine(text);
			}
			streamWriter.WriteLine();
			Matrix4x4[] bindposes = mesh.bindposes;
			streamWriter.WriteLine($"-bindPoses ({bindposes.Length})");
			for (int m = 0; m < bindposes.Length; m++)
			{
				Matrix4x4 matrix4x = bindposes[m];
				Vector3 vector = matrix4x.MultiplyPoint(Vector3.zero);
				Vector3 eulerAngles = matrix4x.rotation.eulerAngles;
				Vector3 lossyScale = matrix4x.lossyScale;
				streamWriter.WriteLine(" BindPose {0}: (Position: {1}, EularRotation: {2}, LossyScale: {3})", m, vector, eulerAngles, lossyScale);
			}
			streamWriter.Flush();
			streamWriter.Close();
			fileStream.Close();
		}

		public static void LogArrayData<T>(T[] data, string logFileName, string prefix = "-")
		{
			if (data != null)
			{
				FileStream fileStream = new FileStream(Path.Combine(AvatarEnv.workSpacePath, logFileName), FileMode.Create);
				StreamWriter streamWriter = new StreamWriter(fileStream);
				streamWriter.WriteLine($"{typeof(T).ToString()}: {data.Length}");
				for (int i = 0; i < data.Length; i++)
				{
					streamWriter.WriteLine(string.Format(prefix + "{0}", data[i]));
				}
				streamWriter.Flush();
				streamWriter.Close();
				fileStream.Close();
			}
		}

		public static void Destroy<T>(T field) where T : UnityEngine.Object
		{
			if ((bool)field)
			{
				UnityEngine.Object.Destroy(field);
			}
		}

		public static void DestroyImmediate<T>(T field) where T : UnityEngine.Object
		{
			if ((bool)field)
			{
				UnityEngine.Object.DestroyImmediate(field);
			}
		}

		private static void DeleteDirectory(string path)
		{
			if (!Directory.Exists(path))
			{
				return;
			}
			string[] fileSystemEntries = Directory.GetFileSystemEntries(path);
			foreach (string path2 in fileSystemEntries)
			{
				if (File.Exists(path2))
				{
					File.Delete(path2);
				}
				else
				{
					DeleteDirectory(path2);
				}
			}
			Directory.Delete(path, recursive: true);
		}

		private static IEnumerator ExtractRawAvatarSDKScript(UnityAction<bool> onChecked)
		{
			UnityEngine.Debug.Log("pav: ExtractRawAvatarSDKScript. Start.");
			string workSpacePath = AvatarEnv.workSpacePath;
			string avatarPath = AvatarEnv.avatarPath;
			string ResourcePath = Path.Combine(AvatarEnv.resourceSpacePath, "AvatarSDKScript/");
			string ConfigFilePath = Path.Combine(AvatarEnv.resourceSpacePath, "AvatarResourceConfig.txt");
			string localConfigPath = Path.Combine(workSpacePath, "AvatarResourceConfig.txt");
			string localHash = null;
			if (File.Exists(localConfigPath))
			{
				try
				{
					byte[] bytes = File.ReadAllBytes(localConfigPath);
					AvatarResourceConfig avatarResourceConfig = AvatarResourceConfig.FromJson(Encoding.UTF8.GetString(bytes));
					if (avatarResourceConfig != null)
					{
						localHash = avatarResourceConfig.hash;
					}
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogErrorFormat("pav: load file is error [{0}] error = [{1}]", localConfigPath, ex.Message);
				}
			}
			WWW configFileWWW2 = new WWW(ConfigFilePath);
			yield return configFileWWW2;
			if (!configFileWWW2.isDone)
			{
				UnityEngine.Debug.LogErrorFormat("pav: ExtractRawAvatarSDKScript. Copy Resourse fail. Load ConfigFile({0}) fail. Run OutputResourceList before build.", ConfigFilePath);
				onChecked?.Invoke(arg0: false);
				yield break;
			}
			if (!string.IsNullOrEmpty(configFileWWW2.error))
			{
				UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. Copy Resourse fail. Load ConfigFile({0}) error: {1}.", ConfigFilePath, configFileWWW2.error);
				onChecked?.Invoke(arg0: false);
				yield break;
			}
			string @string = Encoding.UTF8.GetString(configFileWWW2.bytes);
			if (string.IsNullOrEmpty(@string))
			{
				UnityEngine.Debug.LogErrorFormat("pav: ExtractRawAvatarSDKScript. Copy Resourse fail. Get ConfigData({0}) failed(null).", ConfigFilePath);
				onChecked?.Invoke(arg0: false);
				yield break;
			}
			AvatarResourceConfig avatarResourceConfig2 = AvatarResourceConfig.FromJson(@string);
			if (avatarResourceConfig2 == null)
			{
				UnityEngine.Debug.LogErrorFormat("pav: ExtractRawAvatarSDKScript. Copy Resourse fail. Parse ConfigData({0}) error: {1}", ConfigFilePath, @string);
				onChecked?.Invoke(arg0: false);
				yield break;
			}
			bool flag = false;
			if (!Directory.Exists(avatarPath))
			{
				UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. AvatarPath({0}) not exist.", avatarPath);
				flag = true;
			}
			else if (string.IsNullOrEmpty(avatarResourceConfig2.hash))
			{
				UnityEngine.Debug.LogError("pav: ExtractRawAvatarSDKScript. Get hash date failed.");
			}
			else if (avatarResourceConfig2.hash == localHash)
			{
				UnityEngine.Debug.Log("pav: Check hash up-to-date." + localHash);
				flag = false;
			}
			else
			{
				UnityEngine.Debug.Log("pav: Check hash different.");
				flag = true;
			}
			if (flag)
			{
				UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. Start copy AvatarResource:[{0}] to [{1}]", ResourcePath, avatarPath);
				if (Directory.Exists(avatarPath))
				{
					FileInfo[] files = new DirectoryInfo(avatarPath).GetFiles("*", SearchOption.AllDirectories);
					for (int i = 0; i < files.Length; i++)
					{
						File.Delete(avatarPath + "/" + files[i].Name);
					}
				}
				avatarResourceConfig2.fileList.Add("AvatarResourceConfig.txt");
				foreach (string relativePath in avatarResourceConfig2.fileList)
				{
					if (string.IsNullOrEmpty(relativePath))
					{
						continue;
					}
					bool isCopyHash = relativePath == "AvatarResourceConfig.txt";
					string resourceFile = Path.Combine(ResourcePath, relativePath);
					if (isCopyHash)
					{
						resourceFile = ConfigFilePath;
					}
					UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. Copy AvatarResource [{0}].", resourceFile);
					configFileWWW2 = new WWW(resourceFile);
					yield return configFileWWW2;
					if (configFileWWW2.isDone)
					{
						string text = Path.Combine(avatarPath, relativePath);
						if (isCopyHash)
						{
							text = localConfigPath;
						}
						UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. Copy AvatarResource to [{0}].", text);
						string directoryName = Path.GetDirectoryName(text);
						if (!Directory.Exists(directoryName))
						{
							Directory.CreateDirectory(directoryName);
						}
						if (configFileWWW2.bytes != null)
						{
							File.WriteAllBytes(text, configFileWWW2.bytes);
						}
					}
					else
					{
						UnityEngine.Debug.LogErrorFormat("pav: Copy source fail: {0}.", resourceFile);
					}
				}
			}
			onChecked?.Invoke(arg0: true);
			UnityEngine.Debug.LogFormat("pav: ExtractRawAvatarSDKScript. Done.");
		}

		private static IEnumerator ExtractPackedAvatarSDKScript(UnityAction<bool> onChecked)
		{
			UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Start.");
			string workPath = AvatarEnv.workSpacePath;
			string inHashFilePath = Path.Combine(AvatarEnv.resourceSpacePath, "AvatarSDKScript.hash");
			WWW inHashFileWWW = new WWW(inHashFilePath);
			yield return inHashFileWWW;
			if (inHashFileWWW.isDone && string.IsNullOrEmpty(inHashFileWWW.error))
			{
				string inHash = inHashFileWWW.text;
				UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Read in hash ({0}).", inHash);
				if (string.IsNullOrEmpty(inHash))
				{
					UnityEngine.Debug.LogErrorFormat("pav: ExtractPackedAvatarSDKScript. Invalid in hash.");
					yield break;
				}
				string outHashPath = Path.Combine(workPath, "AvatarSDKScript.hash");
				string text = null;
				if (File.Exists(outHashPath))
				{
					text = File.ReadAllText(outHashPath);
					UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Read out hash ({0}).", text);
				}
				if (!string.IsNullOrEmpty(text) && text == inHash)
				{
					UnityEngine.Debug.Log("pav: ExtractPackedAvatarSDKScript. Check hash up-to-date." + inHash);
				}
				else
				{
					inHashFilePath = Path.Combine(AvatarEnv.resourceSpacePath, "AvatarSDKScript.bytes");
					inHashFileWWW = new WWW(inHashFilePath);
					yield return inHashFileWWW;
					if (!inHashFileWWW.isDone || !string.IsNullOrEmpty(inHashFileWWW.error))
					{
						UnityEngine.Debug.LogErrorFormat("pav: ExtractPackedAvatarSDKScript. Load in pack file ({0}) fail.", inHashFilePath);
						yield break;
					}
					string text2 = Path.Combine(workPath, "AvatarSDKScript.bytes");
					try
					{
						File.WriteAllBytes(text2, inHashFileWWW.bytes);
						UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Write out pack file ({0}).", text2);
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogErrorFormat("pav: ExtractPackedAvatarSDKScript. Write out pack file ({0}) fail. {1}", text2, ex.Message);
						yield break;
					}
					File.WriteAllText(outHashPath, inHash);
					UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Write out hash ({0}).", inHash);
				}
				try
				{
					DeleteDirectory(AvatarEnv.avatarPath);
				}
				catch (Exception ex2)
				{
					UnityEngine.Debug.LogFormat("pav: ClearOldResources. error:({0}).", ex2.Message);
				}
				onChecked?.Invoke(arg0: true);
				UnityEngine.Debug.LogFormat("pav: ExtractPackedAvatarSDKScript. Done.");
			}
			else
			{
				UnityEngine.Debug.LogErrorFormat("pav: ExtractPackedAvatarSDKScript. Load in hash file ({0}) fail.", inHashFilePath);
			}
		}

		public static IEnumerator CheckAvatarResources(UnityAction<bool> onChecked)
		{
			bool rawAvatarSDKScriptReady = false;
			if (!AvatarEnv.avatarPackedPathFirst)
			{
				UnityAction<bool> onChecked2 = delegate(bool isReady)
				{
					rawAvatarSDKScriptReady = isReady;
				};
				yield return ExtractRawAvatarSDKScript(onChecked2);
			}
			bool packedAvatarSDKScriptReady = false;
			if (!rawAvatarSDKScriptReady)
			{
				UnityAction<bool> onChecked3 = delegate(bool isReady)
				{
					packedAvatarSDKScriptReady = isReady;
				};
				yield return ExtractPackedAvatarSDKScript(onChecked3);
			}
			onChecked?.Invoke(rawAvatarSDKScriptReady || packedAvatarSDKScriptReady);
		}

		public static bool RegisterCallback<T>(T callback, HashSet<T> set, string funcName)
		{
			if (set.Contains(callback))
			{
				UnityEngine.Debug.LogErrorFormat("{0} fail. Allready registed.", funcName);
				return false;
			}
			set.Add(callback);
			return true;
		}

		public static bool DeregisterCallback<T>(T callback, HashSet<T> set, string funcName)
		{
			if (!set.Remove(callback))
			{
				UnityEngine.Debug.LogErrorFormat("{0} fail. Not registed.", funcName);
				return false;
			}
			return true;
		}

		public static TextureFormat GetUnityTextureFormat(AvatarPixelFormat pixelFormat)
		{
			switch (pixelFormat)
			{
			case AvatarPixelFormat.A8Unorm:
			case AvatarPixelFormat.L8Unorm:
			case AvatarPixelFormat.LA8Unorm:
			case AvatarPixelFormat.R8Unorm:
			case AvatarPixelFormat.R8Snorm:
			case AvatarPixelFormat.R8Uscaleld:
			case AvatarPixelFormat.R8Sscaled:
			case AvatarPixelFormat.R8Uint:
			case AvatarPixelFormat.R8Sint:
			case AvatarPixelFormat.R8_sRGB:
				return TextureFormat.Alpha8;
			case AvatarPixelFormat.RGBA8Unorm:
			case AvatarPixelFormat.RGBA8Snorm:
			case AvatarPixelFormat.RGBA8Uscaled:
			case AvatarPixelFormat.RGBA8Uint:
			case AvatarPixelFormat.RGBA8Sint:
			case AvatarPixelFormat.RGBA8_sRGB:
				return TextureFormat.RGBA32;
			case AvatarPixelFormat.ABGR8Unorm:
			case AvatarPixelFormat.ABGR8Snorm:
			case AvatarPixelFormat.ABGR8Uscaled:
			case AvatarPixelFormat.ABGR8Uint:
			case AvatarPixelFormat.ABGR8Sint:
			case AvatarPixelFormat.ABGR8_sRGB:
				return TextureFormat.ARGB32;
			case AvatarPixelFormat.RGB8Unorm:
			case AvatarPixelFormat.RGB8Snorm:
			case AvatarPixelFormat.RGB8Uscaled:
			case AvatarPixelFormat.RGB8Sscaled:
			case AvatarPixelFormat.RGB8Uint:
			case AvatarPixelFormat.RGB8Sint:
			case AvatarPixelFormat.RGB8_sRGB:
				return TextureFormat.RGB24;
			case AvatarPixelFormat.ASTC_4x4_sRGB:
				return TextureFormat.ASTC_4x4;
			case AvatarPixelFormat.ASTC_5x5_sRGB:
				return TextureFormat.ASTC_5x5;
			case AvatarPixelFormat.ASTC_6x6_sRGB:
				return TextureFormat.ASTC_6x6;
			case AvatarPixelFormat.ASTC_8x8_sRGB:
				return TextureFormat.ASTC_8x8;
			case AvatarPixelFormat.ASTC_10x10_sRGB:
				return TextureFormat.ASTC_10x10;
			case AvatarPixelFormat.ASTC_12x12_sRGB:
				return TextureFormat.ASTC_12x12;
			case AvatarPixelFormat.ETC2_RGB8A1_sRGB:
				return TextureFormat.ETC2_RGBA1;
			case AvatarPixelFormat.ETC2_RGBA8_sRGB:
				return TextureFormat.ETC2_RGBA8;
			case AvatarPixelFormat.ETC2_RGB8_sRGB:
				return TextureFormat.ETC2_RGB;
			case AvatarPixelFormat.BC4_RUnorm:
			case AvatarPixelFormat.BC4_RSnorm:
				return TextureFormat.BC4;
			case AvatarPixelFormat.BC5_RGUnorm:
			case AvatarPixelFormat.BC5_RGSnorm:
				return TextureFormat.BC5;
			case AvatarPixelFormat.BC6H_RGBUfloat:
			case AvatarPixelFormat.BC6H_RGBSfloat:
				return TextureFormat.BC6H;
			case AvatarPixelFormat.BC7_RGBAUnorm:
			case AvatarPixelFormat.BC7_RGBAUnorm_sRGB:
				return TextureFormat.BC7;
			default:
				return TextureFormat.RGBA32;
			}
		}

		public static uint GetNameHash(string name)
		{
			if (!PicoAvatarApp.isNativeEngineReady)
			{
				throw new Exception("GetNameHash Need AvatarApp Started.");
			}
			if (!sNameIDTable.TryGetValue(name, out var value))
			{
				value = pav_Utility_GetNameHash(name);
				sNameIDTable.Add(name, value);
			}
			return value;
		}

		public static uint AddNameToIDNameTable(string name)
		{
			if (!PicoAvatarApp.isNativeEngineReady)
			{
				throw new Exception("GetNameHash Need AvatarApp Started.");
			}
			return pav_IDNameTable_AddName(name);
		}

		public static string GetNameWithIDFromIDNameTable(uint nameID)
		{
			if (!PicoAvatarApp.isNativeEngineReady)
			{
				throw new Exception("GetNameHash Need AvatarApp Started.");
			}
			if (byteBuffer == null)
			{
				byteBuffer = new byte[128];
			}
			uint num = pav_IDNameTable_GetNameWithID(nameID, ref byteBuffer, (uint)byteBuffer.Length);
			if (num >= 0 && num < 127)
			{
				return Encoding.ASCII.GetString(byteBuffer, 0, (int)num);
			}
			return string.Empty;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_Utility_GetNameHash([MarshalAs(UnmanagedType.LPStr)] string name);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_IDNameTable_AddName([MarshalAs(UnmanagedType.LPStr)] string name);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_IDNameTable_GetNameWithID(uint nameID, ref byte[] chars, uint byteCount);

		public static void PrintSystemInfos()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("SystemInfo:");
			stringBuilder.Append("batteryLevel:");
			stringBuilder.Append(SystemInfo.batteryLevel.ToString());
			stringBuilder.Append(" | operatingSystem:");
			stringBuilder.Append(SystemInfo.operatingSystem.ToString());
			stringBuilder.Append(" | operatingSystemFamily:");
			stringBuilder.Append(SystemInfo.operatingSystemFamily.ToString());
			stringBuilder.Append(" | processorType:");
			stringBuilder.Append(SystemInfo.processorType.ToString());
			stringBuilder.Append(" | processorFrequency:");
			stringBuilder.Append(SystemInfo.processorFrequency.ToString());
			stringBuilder.Append(" | processorCount:");
			stringBuilder.Append(SystemInfo.processorCount.ToString());
			stringBuilder.Append(" | systemMemorySize:");
			stringBuilder.Append(SystemInfo.systemMemorySize.ToString());
			stringBuilder.Append(" | deviceUniqueIdentifier:");
			stringBuilder.Append(SystemInfo.deviceUniqueIdentifier.ToString());
			stringBuilder.Append(" | graphicsMemorySize:");
			stringBuilder.Append(SystemInfo.graphicsMemorySize.ToString());
			stringBuilder.Append(" | graphicsDeviceName:");
			stringBuilder.Append(SystemInfo.graphicsDeviceName.ToString());
			stringBuilder.Append(" | graphicsDeviceID:");
			stringBuilder.Append(SystemInfo.graphicsDeviceID.ToString());
			stringBuilder.Append(" | graphicsUVStartsAtTop:");
			stringBuilder.Append(SystemInfo.graphicsUVStartsAtTop.ToString());
			stringBuilder.Append(" | graphicsShaderLevel:");
			stringBuilder.Append(SystemInfo.graphicsShaderLevel.ToString());
			stringBuilder.Append(" | renderingThreadingMode:");
			stringBuilder.Append(SystemInfo.renderingThreadingMode.ToString());
			stringBuilder.Append(" | supportsShadows:");
			stringBuilder.Append(SystemInfo.supportsShadows.ToString());
			stringBuilder.Append(" | graphicsMultiThreaded:");
			stringBuilder.Append(SystemInfo.graphicsMultiThreaded.ToString());
			stringBuilder.Append(" | supportsRawShadowDepthSampling:");
			stringBuilder.Append(SystemInfo.supportsRawShadowDepthSampling.ToString());
			stringBuilder.Append(" | supportsMotionVectors:");
			stringBuilder.Append(SystemInfo.supportsMotionVectors.ToString());
			stringBuilder.Append(" | supports3DTextures:");
			stringBuilder.Append(SystemInfo.supports3DTextures.ToString());
			stringBuilder.Append(" | supportsComputeShaders:");
			stringBuilder.Append(SystemInfo.supportsComputeShaders.ToString());
			stringBuilder.Append(" | supportsGeometryShaders:");
			stringBuilder.Append(SystemInfo.supportsGeometryShaders.ToString());
			stringBuilder.Append(" | supportsTessellationShaders:");
			stringBuilder.Append(SystemInfo.supportsTessellationShaders.ToString());
			stringBuilder.Append(" | supportsInstancing:");
			stringBuilder.Append(SystemInfo.supportsInstancing.ToString());
			stringBuilder.Append(" | supportsHardwareQuadTopology:");
			stringBuilder.Append(SystemInfo.supportsHardwareQuadTopology.ToString());
			stringBuilder.Append(" | usesReversedZBuffer:");
			stringBuilder.Append(SystemInfo.usesReversedZBuffer.ToString());
			stringBuilder.Append(" | supportsGraphicsFence:");
			stringBuilder.Append(SystemInfo.supportsGraphicsFence.ToString());
			UnityEngine.Debug.LogWarning(stringBuilder.ToString());
		}
	}
	internal class PicoDepressMerge : MonoBehaviour
	{
		public MeshRenderer depressMergeMeshRenderer;

		private void Start()
		{
			if (depressMergeMeshRenderer == null)
			{
				depressMergeMeshRenderer.SetPropertyBlock(new MaterialPropertyBlock());
			}
		}
	}
	[ExecuteInEditMode]
	public class PicoMaterialDebugHelper : MonoBehaviour
	{
		public Material[] materials;

		[Tooltip("Additive GI.")]
		[Range(0f, 1f)]
		public float additiveGI;

		public PicoAvatarSceneLightEnv avatarSceneLightEnv;

		private float _lastAdditiveGI = -1f;

		private void Start()
		{
		}

		private void Update()
		{
			if (avatarSceneLightEnv == null)
			{
				if (_lastAdditiveGI == additiveGI || materials == null || materials.Length == 0)
				{
					return;
				}
				_lastAdditiveGI = additiveGI;
				Material[] array = materials;
				foreach (Material material in array)
				{
					if (material != null)
					{
						material.SetFloat("_AdditiveGI", additiveGI);
					}
				}
			}
			else
			{
				if (_lastAdditiveGI == additiveGI || materials == null || materials.Length == 0)
				{
					return;
				}
				_lastAdditiveGI = additiveGI;
				Material[] array = materials;
				foreach (Material material2 in array)
				{
					if (material2 != null)
					{
						material2.SetFloat("_AdditiveGI", additiveGI);
					}
				}
				if (PicoAvatarApp.instance != null)
				{
					avatarSceneLightEnv.additiveGI = additiveGI;
					PicoAvatarApp.instance.SetAvatarSceneLightEnv(avatarSceneLightEnv);
				}
			}
		}
	}
	public class MemoryView : NativeObject
	{
		public struct NativeData
		{
			public IntPtr handle;

			public int length;
		}

		private byte[] _SharedData;

		private GCHandle _SharedDataHandle;

		private int _length;

		private const string PavDLLName = "effect";

		public uint length
		{
			get
			{
				if (!(base.nativeHandle == IntPtr.Zero))
				{
					return (uint)_length;
				}
				return 0u;
			}
		}

		public IntPtr bufferAddress
		{
			get
			{
				if (!(base.nativeHandle == IntPtr.Zero))
				{
					return pav_MemoryView_GetBuffer(base.nativeHandle);
				}
				return IntPtr.Zero;
			}
		}

		public bool sharedExternal
		{
			get
			{
				if (!(base.nativeHandle == IntPtr.Zero))
				{
					return pav_MemoryView_GetIsShared(base.nativeHandle);
				}
				return false;
			}
		}

		public MemoryView(NativeData nativeData)
		{
			SetNativeHandle(nativeData.handle, needRetain: false);
			_length = nativeData.length;
		}

		public MemoryView(string localFilePathName)
		{
			NativeData nativeData = pav_MemoryView_ReadBytesFromFile(localFilePathName);
			SetNativeHandle(nativeData.handle, needRetain: false);
			_length = nativeData.length;
		}

		public MemoryView(byte[] buffer, bool shared)
		{
			if (buffer != null && buffer.Length != 0)
			{
				_SharedDataHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
				IntPtr nativeHandle_ = pav_MemoryView_New(_SharedDataHandle.AddrOfPinnedObject(), (uint)buffer.Length, shared);
				if (!shared)
				{
					_SharedData = buffer;
					_SharedDataHandle.Free();
				}
				SetNativeHandle(nativeHandle_, needRetain: false);
				_length = buffer.Length;
			}
		}

		public IntPtr GetMemoryStreamPtr()
		{
			return pav_MemoryView_GetMemoryStreamPtr(base.nativeHandle);
		}

		public bool TransferSharedBuffer(byte[] buffer)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				return false;
			}
			if (_SharedDataHandle.IsAllocated)
			{
				_SharedDataHandle.Free();
				_SharedData = null;
			}
			if (buffer == null)
			{
				pav_MemoryView_Reset(base.nativeHandle, IntPtr.Zero, 0u, shared: false);
				return true;
			}
			_SharedData = buffer;
			_SharedDataHandle = GCHandle.Alloc(_SharedData, GCHandleType.Pinned);
			_length = buffer.Length;
			return pav_MemoryView_Reset(base.nativeHandle, _SharedDataHandle.AddrOfPinnedObject(), (uint)_length, shared: true) == NativeResult.Success;
		}

		public bool SetData(byte[] buffer)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				return false;
			}
			if (_SharedDataHandle.IsAllocated)
			{
				_SharedDataHandle.Free();
				_SharedData = null;
			}
			if (buffer == null)
			{
				pav_MemoryView_Reset(base.nativeHandle, IntPtr.Zero, 0u, shared: false);
				return true;
			}
			GCHandle gCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			_length = buffer.Length;
			NativeResult num = pav_MemoryView_Reset(base.nativeHandle, gCHandle.AddrOfPinnedObject(), (uint)_length, shared: false);
			gCHandle.Free();
			return num == NativeResult.Success;
		}

		public unsafe byte[] getData(bool reGetFromNative = true)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				return null;
			}
			_length = (int)pav_MemoryView_GetSize(base.nativeHandle);
			if (_SharedDataHandle.IsAllocated)
			{
				if (_length == _SharedData.Length)
				{
					return _SharedData;
				}
				_SharedDataHandle.Free();
				Array.Resize(ref _SharedData, _length);
			}
			if (_SharedData == null || _SharedData.Length != _length)
			{
				_SharedData = new byte[_length];
			}
			GCHandle gCHandle = GCHandle.Alloc(_SharedData, GCHandleType.Pinned);
			IntPtr intPtr = gCHandle.AddrOfPinnedObject();
			Buffer.MemoryCopy((void*)bufferAddress, (void*)intPtr, _length, _length);
			gCHandle.Free();
			return _SharedData;
		}

		public int GetSize(bool reGetFromNative = true)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				return 0;
			}
			_length = (int)pav_MemoryView_GetSize(base.nativeHandle);
			return _length;
		}

		public NativeResult WriteBytesToFile(string filePathName)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				return NativeResult.InvalidObject;
			}
			return pav_MemoryView_WriteBytesToFile(base.nativeHandle, filePathName);
		}

		public static MemoryView ReadBytesFromFile(string filePathName)
		{
			NativeData nativeData = pav_MemoryView_ReadBytesFromFile(filePathName);
			if (nativeData.handle == IntPtr.Zero)
			{
				return null;
			}
			return new MemoryView(nativeData);
		}

		[Preserve]
		protected override void OnDestroy()
		{
			if (_SharedData != null)
			{
				if (_SharedDataHandle.IsAllocated)
				{
					_SharedDataHandle.Free();
					_SharedData = null;
				}
				pav_MemoryView_Reset(base.nativeHandle, IntPtr.Zero, 0u, shared: false);
			}
			base.OnDestroy();
		}

		private MemoryView()
		{
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_MemoryView_New(IntPtr buffer, uint size, bool shared);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_MemoryView_WriteBytesToFile(IntPtr handle, string localFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeData pav_MemoryView_ReadBytesFromFile(string localFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_MemoryView_Reset(IntPtr nativeHandle, IntPtr buffer, uint size, bool shared);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_MemoryView_GetSize(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_MemoryView_GetBuffer(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_MemoryView_GetIsShared(IntPtr nativeHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_MemoryView_GetMemoryStreamPtr(IntPtr nativeHandle);
	}
	public class PicoPlaybackPacketRecorder
	{
		public static float recordInterval = 0.2f;

		private BinaryWriter _recordPacketFileWriter;

		private const int FlushPacketCount = 100;

		private int _packetCountFromLastFlush;

		public void StartRecord(AvatarEntity avatarEntity)
		{
			try
			{
				string text = AvatarEnv.avatarCachePath + "/records";
				Directory.CreateDirectory(text);
				string text2 = ((avatarEntity.owner.capabilities.controlSourceType != ControlSourceType.RemoteServer) ? "/local_" : "/remote_");
				DateTime now = DateTime.Now;
				string text3 = $"{now.Day}d{now.Hour}h{now.Minute}m{now.Second}s_";
				string text4 = text + text2 + text3 + avatarEntity.owner.userId + ".bytes";
				UnityEngine.Debug.Log("recordPacketFileName: " + text4);
				FileStream output = new FileStream(text4, FileMode.Create, FileAccess.Write);
				_recordPacketFileWriter = new BinaryWriter(output);
				_recordPacketFileWriter.Write(recordInterval);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		public void StopRecord()
		{
			if (_recordPacketFileWriter != null)
			{
				_recordPacketFileWriter.Close();
				_recordPacketFileWriter = null;
			}
		}

		public void RecordPacket(MemoryView packetMemoryView)
		{
			if (_recordPacketFileWriter == null)
			{
				return;
			}
			try
			{
				byte[] data = packetMemoryView.getData();
				_recordPacketFileWriter.Write(Time.realtimeSinceStartup);
				int value = data.Length;
				_recordPacketFileWriter.Write(value);
				_recordPacketFileWriter.Write(data, 0, data.Length);
				if (++_packetCountFromLastFlush > 100)
				{
					_packetCountFromLastFlush = 0;
					_recordPacketFileWriter.Flush();
				}
			}
			catch (Exception exception)
			{
				_recordPacketFileWriter = null;
				UnityEngine.Debug.LogException(exception);
			}
		}
	}
	public class PlaybackSampleFilter
	{
		public struct Sample
		{
			public float time;

			public Vector3 pos;

			public Quaternion quat;
		}

		private int _begin;

		private int _end;

		private Sample[] _samples;

		private int _filterWindowSize;

		private float _remoteTime;

		private float _latestRemoteTime = -1000f;

		private float _lastPlaybackUpdateTime = -1000f;

		private int _lastLeft = -1;

		private int _lastRight = -1;

		private float _invLastSnapFrameTime;

		private float _avgDelayTime;

		private float _maxPlaybackSpeedRatio;

		private float _minPlaybackSpeedRatio;

		private float _invAvgDelayTime;

		private bool isEmpty => _begin == _end;

		public void Initialize(int windowSize, float avgDelayTime, float maxPlaybackSpeedRatio, float minPlaybackSpeedRatio)
		{
			_avgDelayTime = Mathf.Max(0.001f, avgDelayTime);
			_maxPlaybackSpeedRatio = maxPlaybackSpeedRatio;
			_minPlaybackSpeedRatio = minPlaybackSpeedRatio;
			_invAvgDelayTime = 1f / _avgDelayTime;
			_samples = new Sample[windowSize];
			_filterWindowSize = windowSize;
			Reset();
		}

		public void AddSamplePoint(Vector3 pos, Quaternion quat, float timeStamp)
		{
			float num = timeStamp - _latestRemoteTime;
			if ((double)num < 0.0)
			{
				if (!((double)num < -5.0))
				{
					return;
				}
				Reset();
				_remoteTime = timeStamp;
			}
			else if (isEmpty)
			{
				_remoteTime = timeStamp;
			}
			_latestRemoteTime = timeStamp;
			Sample sample = default(Sample);
			sample.time = timeStamp;
			sample.pos = pos;
			sample.quat = quat;
			_samples[_end] = sample;
			if (_end + 1 == _begin || (_end == _filterWindowSize - 1 && _begin == 0))
			{
				_begin = _begin++ % _filterWindowSize;
			}
			_end = (_end + 1) % _filterWindowSize;
		}

		public bool MoveTime(ref Vector3 pos, ref Quaternion quat, float time)
		{
			if (isEmpty)
			{
				return false;
			}
			float num = time - _lastPlaybackUpdateTime;
			if (num > 1f)
			{
				num = 0.01f;
			}
			_lastPlaybackUpdateTime = time;
			if (_avgDelayTime > 0.001f)
			{
				float num2 = (_latestRemoteTime - _remoteTime - _avgDelayTime) * _invAvgDelayTime;
				if ((double)num2 > 0.0)
				{
					num2 = Mathf.Min(1f, num2);
					num *= Mathf.Lerp(1f, _maxPlaybackSpeedRatio, num2);
				}
				else
				{
					num2 = Mathf.Min(1f, 0f - num2);
					num *= Mathf.Lerp(1f, _minPlaybackSpeedRatio, num2);
				}
				_remoteTime += num;
			}
			else
			{
				_remoteTime = time;
			}
			float remoteTime = _remoteTime;
			int num3 = -1;
			int num4 = -1;
			int num5 = _begin;
			while (num5 != _end)
			{
				if (_samples[num5].time < remoteTime)
				{
					num3 = (_begin = num5);
					num5 = (num5 + 1) % _filterWindowSize;
					continue;
				}
				num4 = num5;
				break;
			}
			if (num3 != -1 && num4 != -1)
			{
				if (_lastLeft != num3 || _lastRight != num4)
				{
					_lastLeft = num3;
					_lastRight = num4;
					_invLastSnapFrameTime = 1f / (_samples[_lastRight].time - _samples[_lastLeft].time);
				}
				Sample sample = _samples[num3];
				Sample sample2 = _samples[num4];
				float t = (remoteTime - _samples[num3].time) * _invLastSnapFrameTime;
				pos = Vector3.Lerp(sample.pos, sample2.pos, t);
				quat = Quaternion.Lerp(sample.quat, sample2.quat, t);
			}
			else if (num3 != -1)
			{
				Sample sample3 = _samples[num3];
				pos = sample3.pos;
				quat = sample3.quat;
			}
			else
			{
				if (num4 == -1)
				{
					return false;
				}
				Sample sample4 = _samples[num4];
				pos = sample4.pos;
				quat = sample4.quat;
			}
			return true;
		}

		private void Reset()
		{
			_begin = (_end = 0);
			_lastLeft = (_lastRight = -1);
		}
	}
	public static class TTNetUtility
	{
		public static bool TTNetInited { get; private set; }

		public static void InitTTNet()
		{
			if (TTNetInited)
			{
				return;
			}
			try
			{
				AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity").Call<AndroidJavaObject>("getApplicationContext", Array.Empty<object>());
				if (androidJavaObject == null)
				{
					UnityEngine.Debug.LogError("getApplicationContext return null");
				}
				new AndroidJavaClass("com.pvr.avatarsdk.ttnet.TTNetUtility").CallStatic("InitTTNet", androidJavaObject);
				TTNetInited = true;
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}
	}
	public class UnityHelper
	{
		private static Mesh _PlatformScreenMesh;

		public static Transform FindParentTransform(Transform anyBone, string parentName)
		{
			if (anyBone == null)
			{
				return null;
			}
			if (anyBone.name == parentName)
			{
				return anyBone;
			}
			return FindParentTransform(anyBone.parent, parentName);
		}

		public static Transform FindTransformInParentOrSlibTree(Transform anyBone, string transName)
		{
			if (anyBone == null)
			{
				return null;
			}
			if (anyBone.name == transName)
			{
				return anyBone;
			}
			Transform transform = anyBone.Find(transName);
			if (transform != null)
			{
				return transform;
			}
			return FindTransformInParentOrSlibTree(anyBone.parent, transName);
		}

		public static Transform FindFirstMatchChildTransform(Transform parentXForm, string partName, bool exactlyMatch, bool isRecursively = false)
		{
			if (parentXForm == null)
			{
				return null;
			}
			if (exactlyMatch)
			{
				if (parentXForm.name.Equals(partName))
				{
					return parentXForm;
				}
			}
			else if (parentXForm.name.Contains(partName))
			{
				return parentXForm;
			}
			for (int i = 0; i < parentXForm.childCount; i++)
			{
				Transform child = parentXForm.GetChild(i);
				if (exactlyMatch)
				{
					if (child.name.Equals(partName))
					{
						return child;
					}
				}
				else if (child.name.Contains(partName))
				{
					return child;
				}
			}
			if (isRecursively)
			{
				for (int j = 0; j < parentXForm.childCount; j++)
				{
					Transform transform = FindFirstMatchChildTransform(parentXForm.GetChild(j), partName, exactlyMatch, isRecursively: true);
					if (transform != null)
					{
						return transform;
					}
				}
			}
			return null;
		}

		public static Dictionary<string, Transform> BuildBoneTable(Transform anyBone, string rootBoneName = "Root", bool checkNameConflict = true)
		{
			Dictionary<string, Transform> dictionary = new Dictionary<string, Transform>();
			Transform bone = FindParentTransform(anyBone, rootBoneName);
			AddToBoneTable(dictionary, bone, checkNameConflict);
			return dictionary;
		}

		private static void AddToBoneTable(Dictionary<string, Transform> boneTable, Transform bone, bool checkNameConflict)
		{
			if (!(bone == null))
			{
				string name = bone.name;
				if (!checkNameConflict || !boneTable.ContainsKey(name))
				{
					boneTable.Add(name, bone);
				}
				int childCount = bone.childCount;
				for (int i = 0; i < childCount; i++)
				{
					AddToBoneTable(boneTable, bone.GetChild(i), checkNameConflict);
				}
			}
		}

		public static bool IsOrChildOf(Transform child, Transform parent)
		{
			if (child == parent)
			{
				return true;
			}
			return IsChildOf(child, parent);
		}

		public static bool IsChildOf(Transform child, Transform parent)
		{
			if (child == null || parent == null)
			{
				return false;
			}
			if (child.parent == parent)
			{
				return true;
			}
			return IsChildOf(child.parent, parent);
		}

		public static Mesh GetPlatformScreenMesh()
		{
			if (_PlatformScreenMesh == null)
			{
				_PlatformScreenMesh = CreateScreenOverlayMesh(0f, 0f, 1f, 1f);
			}
			return _PlatformScreenMesh;
		}

		public static Mesh CreateScreenOverlayMesh(float x, float y, float width, float height)
		{
			Mesh mesh = new Mesh();
			float y2 = 1f;
			float y3 = 0f;
			float x2 = (x - 0.5f) * 2f;
			float y4 = (0.5f - y) * 2f;
			float x3 = (x + width - 0.5f) * 2f;
			float y5 = (0.5f - (y + height)) * 2f;
			mesh.vertices = new Vector3[4]
			{
				new Vector3(x2, y4),
				new Vector3(x2, y5),
				new Vector3(x3, y4),
				new Vector3(x3, y5)
			};
			mesh.uv = new Vector2[4]
			{
				new Vector2(0f, y2),
				new Vector2(0f, y3),
				new Vector2(1f, y2),
				new Vector2(1f, y3)
			};
			mesh.subMeshCount = 1;
			mesh.SetTriangles(new int[6] { 1, 0, 2, 1, 2, 3 }, 0);
			mesh.bounds = new Bounds(Vector3.zero, new Vector3(100000f, 100000f, 100000f));
			return mesh;
		}

		public static T GetComponent<T>(GameObject target) where T : Component
		{
			T val = target.GetComponent<T>();
			if (val == null)
			{
				val = target.AddComponent<T>();
			}
			return val;
		}
	}
	public class MiniJSONUtil
	{
		public static int GetInt(Dictionary<string, object> json, string key, int defaultValue = 0)
		{
			int result = defaultValue;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = Convert.ToInt32(json[key]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static long GetLong(Dictionary<string, object> json, string key, long defaultValue = 0L)
		{
			long result = defaultValue;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					long.TryParse(json[key].ToString(), out result);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static float GetFloat(Dictionary<string, object> json, string key, float defaultValue = 0f)
		{
			float result = defaultValue;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = Convert.ToSingle(json[key]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static bool GetBool(Dictionary<string, object> json, string key, bool defaultValue = false)
		{
			bool result = defaultValue;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = Convert.ToBoolean(json[key]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static string GetString(Dictionary<string, object> json, string key, string defaultValue = null)
		{
			string result = defaultValue;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = Convert.ToString(json[key]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static Dictionary<string, object> GetDictionary(Dictionary<string, object> json, string key)
		{
			Dictionary<string, object> result = null;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = json[key] as Dictionary<string, object>;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static Dictionary<TKey, object> GetDictionary<TKey>(Dictionary<string, object> json, string key)
		{
			Dictionary<TKey, object> result = null;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = json[key] as Dictionary<TKey, object>;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static int[] GetIntList(Dictionary<string, object> json, string key)
		{
			List<object> list = GetList(json, key);
			if (list == null || list.Count == 0)
			{
				return null;
			}
			try
			{
				int[] array = new int[list.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = (int)(long)list[i];
				}
				return array;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return null;
		}

		public static List<object> GetList(Dictionary<string, object> json, string key)
		{
			List<object> result = null;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					result = json[key] as List<object>;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return result;
		}

		public static Dictionary<string, object> ToObject(Vector3 val)
		{
			return new Dictionary<string, object>
			{
				["x"] = val.x,
				["y"] = val.y,
				["z"] = val.z
			};
		}

		public static Dictionary<string, object> ToObject(Rect val)
		{
			return new Dictionary<string, object>
			{
				["x"] = val.x,
				["y"] = val.y,
				["width"] = val.width,
				["height"] = val.height
			};
		}

		public static object ToList(Vector3[] val)
		{
			List<object> list = new List<object>();
			if (val != null)
			{
				for (int i = 0; i < val.Length; i++)
				{
					list.Add(ToObject(val[i]));
				}
			}
			return list;
		}

		public static Vector3 GetVector3(Dictionary<string, object> json, string key)
		{
			Vector3 zero = Vector3.zero;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					Dictionary<string, object> dictionary = (Dictionary<string, object>)json[key];
					zero.x = Convert.ToSingle(dictionary["x"]);
					zero.y = Convert.ToSingle(dictionary["y"]);
					zero.z = Convert.ToSingle(dictionary["z"]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return zero;
		}

		public static Dictionary<string, object> ToObject(Vector2 val)
		{
			return new Dictionary<string, object>
			{
				["x"] = val.x,
				["y"] = val.y
			};
		}

		public static object ToList(Vector2[] val)
		{
			List<object> list = new List<object>();
			for (int i = 0; i < val.Length; i++)
			{
				list.Add(ToObject(val[i]));
			}
			return list;
		}

		public static Vector2 GetVector2(Dictionary<string, object> json, string key)
		{
			Vector3 zero = Vector3.zero;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					Dictionary<string, object> dictionary = (Dictionary<string, object>)json[key];
					zero.x = Convert.ToSingle(dictionary["x"]);
					zero.y = Convert.ToSingle(dictionary["y"]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return zero;
		}

		public static Rect GetRect(Dictionary<string, object> json, string key)
		{
			Rect zero = Rect.zero;
			try
			{
				if (json != null && json.ContainsKey(key))
				{
					Dictionary<string, object> dictionary = (Dictionary<string, object>)json[key];
					zero.x = Convert.ToSingle(dictionary["x"]);
					zero.y = Convert.ToSingle(dictionary["y"]);
					zero.width = Convert.ToSingle(dictionary["width"]);
					zero.height = Convert.ToSingle(dictionary["height"]);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message + " stack:" + ex.StackTrace);
			}
			return zero;
		}

		public static object ToList(float[] val)
		{
			List<object> list = new List<object>();
			if (val != null)
			{
				for (int i = 0; i < val.Length; i++)
				{
					list.Add(val[i]);
				}
			}
			return list;
		}

		public static object ToList(int[] val)
		{
			List<object> list = new List<object>();
			if (val != null)
			{
				for (int i = 0; i < val.Length; i++)
				{
					list.Add((long)val[i]);
				}
			}
			return list;
		}
	}
}
namespace Pico.Avatar.Sample
{
	public class ActionAvatar : MonoBehaviour
	{
		public string userId = "662230622642634752";

		public AvatarManifestationType manifestationType = AvatarManifestationType.Full;

		public bool isLocalAvatar;

		public AvatarHeadShowType headShowType;

		public bool bodyCulling;

		public Vector3 eyeOffset;

		private bool cameraTracking;

		public SnapshotLevel snapshotLevel = SnapshotLevel.Invalid;

		public JointType[] criticalJoints;

		public bool enablePlaceHolder = true;

		public bool autoStopAnimating = true;

		public AvatarIKMode ikMode = AvatarIKMode.FullBody;

		public InputActionProperty[] buttonActions;

		private PicoAvatar avatar;

		private AvatarBodyAnimController _bodyAnimController;

		private GameObject leftSkeletonGo;

		private GameObject rightSkeletonGo;

		private GameObject leftHandPose;

		private GameObject rightHandPose;

		private string avatarID = "0";

		public Transform XRRoot;

		public Transform headTarget;

		public Transform leftHandTarget;

		public Transform rightHandTarget;

		public Transform cameraOffsetTarget;

		public bool isAutoFitHeight;

		public PicoAvatar Avatar => avatar;

		public void StartAvatar(string userID, InputActionProperty[] btnActions = null, string avatarID = "0")
		{
			if (avatar != null)
			{
				Dispose();
			}
			userId = userID;
			this.avatarID = avatarID;
			buttonActions = btnActions;
			CreateAvatar();
		}

		public void SetCustomHandPose(GameObject leftHandSkeleton, GameObject rightHandSkeleton, GameObject leftHandPose, GameObject rightHandPose)
		{
			leftSkeletonGo = leftHandSkeleton;
			rightSkeletonGo = rightHandSkeleton;
			this.leftHandPose = leftHandPose;
			this.rightHandPose = rightHandPose;
		}

		private void InitAvatarCustomData()
		{
			if (isLocalAvatar && (!(leftSkeletonGo == null) || !(rightSkeletonGo == null)) && !(avatar == null))
			{
				Vector3 handUp = new Vector3(0f, 0f, -1f);
				Vector3 handForward = new Vector3(-1f, 0f, 0f);
				Vector3 zero = Vector3.zero;
				Vector3 handUp2 = new Vector3(0f, 0f, -1f);
				Vector3 handForward2 = new Vector3(1f, 0f, 0f);
				Vector3 zero2 = Vector3.zero;
				avatar.SetCustomHand(HandSide.Right, rightSkeletonGo, rightHandPose, handUp, handForward, zero);
				if (avatar.SetCustomHand(HandSide.Left, leftSkeletonGo, leftHandPose, handUp2, handForward2, zero2))
				{
					UnityEngine.Debug.Log("pav:InitAvatarCustomData successful !");
				}
			}
		}

		private void CreateAvatar()
		{
			AvatarCapabilities avatarCapabilities = new AvatarCapabilities();
			avatarCapabilities.manifestationType = manifestationType;
			avatarCapabilities.isLocalAvatar = isLocalAvatar;
			avatarCapabilities.controlSourceType = ((!isLocalAvatar) ? ControlSourceType.RemoteServer : ControlSourceType.LocalUser);
			avatarCapabilities.bodyCulling = bodyCulling;
			avatarCapabilities.snapshotLevel = snapshotLevel;
			avatarCapabilities.enablePlaceHolder = enablePlaceHolder;
			avatarCapabilities.autoStopAnimating = autoStopAnimating;
			avatarCapabilities.ikMode = ikMode;
			avatar = PicoAvatarManager.instance.LoadAvatar(new AvatarLoadContext(userId, avatarID, null, avatarCapabilities));
			avatar.criticalJoints = criticalJoints;
			avatar.SetHeadShowType(headShowType);
			avatar.AddFirstEntityReadyCallback(delegate(AvatarEntity entity)
			{
				if (!(entity == null))
				{
					if (!isLocalAvatar)
					{
						avatar.PlayAnimation("idle");
					}
					else
					{
						_bodyAnimController = entity?.bodyAnimController;
						InitBodyAnimControllerIK();
						InitAvatarCustomData();
						InitAutoFitController();
					}
				}
			});
			AvatarEntity entity2 = avatar.entity;
			Transform obj = avatar?.transform;
			obj.SetParent(base.transform);
			obj.localPosition = Vector3.zero;
			obj.localRotation = Quaternion.identity;
			obj.localScale = Vector3.one;
			entity2.buttonActions = buttonActions;
			InitEntityXRTarget(entity2);
			if (cameraTracking && isLocalAvatar && PicoAvatarManager.instance.avatarCamera != null)
			{
				PicoAvatarManager.instance.avatarCamera.trakingAvatar = avatar;
			}
		}

		private void Dispose()
		{
			if (_bodyAnimController != null)
			{
				_bodyAnimController.autoFitController.ClearAvatarOffsetChangedCallback(OnAvatarOffsetChangedCallBack);
			}
			PicoAvatarManager.instance.UnloadAvatar(avatar);
			avatar = null;
		}

		private void InitEntityXRTarget(AvatarEntity avatarEntity)
		{
			avatarEntity.XRRoot = XRRoot;
			avatarEntity.headTarget = headTarget;
			avatarEntity.leftHandTarget = leftHandTarget;
			avatarEntity.rightHandTarget = rightHandTarget;
		}

		private void InitBodyAnimControllerIK()
		{
			if (_bodyAnimController != null)
			{
				_bodyAnimController.eyeOffset = eyeOffset;
				if (avatar.sex == AvatarSexType.Female)
				{
					_bodyAnimController.leftHandPositionOffset = new Vector3(0.036f, 0.041f, 0.081f);
					_bodyAnimController.rightHandPositionOffset = new Vector3(-0.04f, 0.05f, 0.086f);
					_bodyAnimController.leftHandRotationOffset = Quaternion.AngleAxis(36f, Vector3.left);
					_bodyAnimController.rightHandRotationOffset = Quaternion.AngleAxis(36.148f, Vector3.left);
				}
				else
				{
					_bodyAnimController.leftHandPositionOffset = new Vector3(0.036f, 0.048f, 0.098f);
					_bodyAnimController.rightHandPositionOffset = new Vector3(-0.036f, 0.045f, 0.1012f);
					_bodyAnimController.leftHandRotationOffset = Quaternion.AngleAxis(40.756f, Vector3.left);
					_bodyAnimController.rightHandRotationOffset = Quaternion.AngleAxis(40.756f, Vector3.left);
				}
				_bodyAnimController.SetStretchEnable(2u, enable: true);
				_bodyAnimController.SetStretchEnable(3u, enable: true);
				_bodyAnimController.SetMaxStretchLength(2u, 0.7f);
				_bodyAnimController.SetMaxStretchLength(3u, 0.7f);
				_bodyAnimController.SetValidHipsHeightRange(0f, 3f);
				_bodyAnimController.SetIKAutoStopModeEnable(1u, enable: true);
				_bodyAnimController.SetIKAutoStopModeEnable(2u, enable: true);
				_bodyAnimController.SetIKAutoStopModeEnable(3u, enable: true);
				_bodyAnimController.SetIKAutoStopModeEnable(4u, enable: true);
			}
		}

		private void InitAutoFitController()
		{
			if (_bodyAnimController != null && isAutoFitHeight && !(cameraOffsetTarget == null))
			{
				AvatarAutoFitController autoFitController = _bodyAnimController.autoFitController;
				if (autoFitController != null)
				{
					autoFitController.localAvatarHeightFittingEnable = true;
					autoFitController.ClearAvatarOffsetChangedCallback(OnAvatarOffsetChangedCallBack);
					autoFitController.AddAvatarOffsetChangedCallback(OnAvatarOffsetChangedCallBack);
				}
				PicoAvatarAutoFitTrigger picoAvatarAutoFitTrigger = avatar.entity.gameObject.GetComponent<PicoAvatarAutoFitTrigger>();
				if (picoAvatarAutoFitTrigger == null)
				{
					picoAvatarAutoFitTrigger = avatar.entity.gameObject.AddComponent<PicoAvatarAutoFitTrigger>();
				}
				picoAvatarAutoFitTrigger.SetTriggerCallback(OnAppAutoFitTrigger);
				Vector3 position = cameraOffsetTarget.transform.position;
				autoFitController.SetCurrentAvatarOffset(position);
				autoFitController.UpdateAvatarHeightOffset();
				UnityEngine.Debug.Log("pav:_autoFitController.UpdateAvatarHeightOffset");
			}
		}

		private void OnAvatarOffsetChangedCallBack(AvatarAutoFitController cotroller, Vector3 cameraOffsetPos)
		{
			if (isAutoFitHeight)
			{
				UnityEngine.Debug.Log("pav:OnAvatarOffsetChanged:" + cameraOffsetPos.ToString());
				RefreshCameraOffsetTargetPos(cameraOffsetPos);
				cotroller.SetCurrentAvatarOffset(cameraOffsetPos);
			}
		}

		private void OnAppAutoFitTrigger()
		{
			UnityEngine.Debug.Log("pav:OnAppAutoFitTrigger:");
			AvatarAutoFitController autoFitController = _bodyAnimController.autoFitController;
			if (autoFitController != null)
			{
				Vector3 position = cameraOffsetTarget.transform.position;
				autoFitController.SetCurrentAvatarOffset(position);
				autoFitController.UpdateAvatarHeightOffset();
			}
		}

		private void RefreshCameraOffsetTargetPos(Vector3 offset)
		{
			if (!(cameraOffsetTarget == null))
			{
				cameraOffsetTarget.transform.position = offset;
				UnityEngine.Debug.Log("pav:cameraOffsetTarget pos:" + cameraOffsetTarget.transform.position.ToString());
			}
		}
	}
	public class InputAssetsManager : MonoBehaviour
	{
		[SerializeField]
		public InputActionAsset inputAsset;

		[SerializeField]
		public List<string> actionNameList = new List<string>();

		[SerializeField]
		public List<InputActionReference> actionsRefList = new List<InputActionReference>();

		public int Count => actionsRefList.Count;

		public void AddInputActionReference(InputActionReference data)
		{
			if (!(data == null) && !(GetInputActionReference(data.name) == data))
			{
				actionNameList.Add(data.name);
				actionsRefList.Add(data);
			}
		}

		public InputActionReference GetInputActionReference(string actionName)
		{
			if (actionNameList.Count != actionsRefList.Count)
			{
				return null;
			}
			int num = actionNameList.IndexOf(actionName);
			if (num >= 0)
			{
				return actionsRefList[num];
			}
			return null;
		}

		public void Clear()
		{
			actionNameList.Clear();
			actionsRefList.Clear();
		}
	}
	public class PicoAvatarAppConfigUtils
	{
		public const string NationType = "cn";

		public const string AvatarAppId = "1148777474860445696";

		public const string AvatarAppToken = "6dk58qzA";

		public const string UserToken = "";

		public const string UserID = "7123062652275786789";

		public const string IsTest = "-test";
	}
	[CreateAssetMenu(fileName = "PicoAvatarJsonSpecData", menuName = "Pico/Demo/PicoAvatarJsonSpecData", order = 1)]
	public class PicoAvatarJsonSpecData : ScriptableObject
	{
		[SerializeField]
		public List<string> jsonSpecList = new List<string>();
	}
	public class XRRotateController : MonoBehaviour
	{
		private PxrControllerTracking pxrControllerTrackingLeft;

		private PxrControllerTracking pxrControllerTrackingRight;

		private float[] headData = new float[7];

		public float speed = 1f;

		public GameObject targetGo;

		private void Start()
		{
		}

		private void OnGUI()
		{
			if (GUILayout.RepeatButton("-"))
			{
				RotateAroundLocal(Vector3.up, speed);
			}
			if (GUILayout.RepeatButton("+"))
			{
				RotateAroundLocal(-Vector3.up, speed);
			}
		}

		private void Update()
		{
			PXR_Plugin.Controller.UPxr_GetControllerTrackingState(1u, 0.0, headData, ref pxrControllerTrackingRight);
			if (pxrControllerTrackingRight.localControllerPose.status == 0)
			{
				return;
			}
			InputDevices.GetDeviceAtXRNode(XRNode.RightHand).TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out var value);
			float num = VectorAngle(new Vector2(1f, 0f), value);
			if ((!(num > 45f) || !(num < 135f)) && (!(num < -45f) || !(num > -135f)))
			{
				if ((num < 180f && num > 135f) || (num < -135f && num > -180f))
				{
					RotateAroundLocal(Vector3.up, speed);
				}
				else if ((num > 0f && num < 45f) || (num > -45f && num < 0f))
				{
					RotateAroundLocal(-Vector3.up, speed);
				}
			}
			Vector2 vector = value;
			UnityEngine.Debug.Log("触摸点位置" + vector.ToString());
		}

		private void RotateAroundLocal(Vector3 dir, float angle)
		{
			if (!(targetGo == null))
			{
				targetGo.transform.Rotate(dir, angle);
			}
		}

		public void LinkTarget(GameObject go)
		{
			targetGo = go;
		}

		private float VectorAngle(Vector2 from, Vector2 to)
		{
			Vector3 vector = Vector3.Cross(from, to);
			float num = Vector2.Angle(from, to);
			if (!(vector.z > 0f))
			{
				return 0f - num;
			}
			return num;
		}
	}
}
namespace Pico.Avatar.MiniJSON
{
	public static class Json
	{
		private sealed class Parser : IDisposable
		{
			private enum TOKEN
			{
				NONE,
				CURLY_OPEN,
				CURLY_CLOSE,
				SQUARED_OPEN,
				SQUARED_CLOSE,
				COLON,
				COMMA,
				STRING,
				NUMBER,
				TRUE,
				FALSE,
				NULL
			}

			private const string WHITE_SPACE = " \t\n\r";

			private const string WORD_BREAK = " \t\n\r{}[],:\"";

			private StringReader json;

			private char PeekChar => Convert.ToChar(json.Peek());

			private char NextChar => Convert.ToChar(json.Read());

			private string NextWord
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					while (" \t\n\r{}[],:\"".IndexOf(PeekChar) == -1)
					{
						stringBuilder.Append(NextChar);
						if (json.Peek() == -1)
						{
							break;
						}
					}
					return stringBuilder.ToString();
				}
			}

			private TOKEN NextToken
			{
				get
				{
					EatWhitespace();
					if (json.Peek() == -1)
					{
						return TOKEN.NONE;
					}
					switch (PeekChar)
					{
					case '{':
						return TOKEN.CURLY_OPEN;
					case '}':
						json.Read();
						return TOKEN.CURLY_CLOSE;
					case '[':
						return TOKEN.SQUARED_OPEN;
					case ']':
						json.Read();
						return TOKEN.SQUARED_CLOSE;
					case ',':
						json.Read();
						return TOKEN.COMMA;
					case '"':
						return TOKEN.STRING;
					case ':':
						return TOKEN.COLON;
					case '-':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						return TOKEN.NUMBER;
					default:
						return NextWord switch
						{
							"false" => TOKEN.FALSE, 
							"true" => TOKEN.TRUE, 
							"null" => TOKEN.NULL, 
							_ => TOKEN.NONE, 
						};
					}
				}
			}

			private Parser(string jsonString)
			{
				json = new StringReader(jsonString);
			}

			public static object Parse(string jsonString)
			{
				using Parser parser = new Parser(jsonString);
				return parser.ParseValue();
			}

			public void Dispose()
			{
				json.Dispose();
				json = null;
			}

			private Dictionary<string, object> ParseObject()
			{
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				json.Read();
				while (true)
				{
					switch (NextToken)
					{
					case TOKEN.COMMA:
						continue;
					case TOKEN.NONE:
						return null;
					case TOKEN.CURLY_CLOSE:
						return dictionary;
					}
					string text = ParseString();
					if (text == null)
					{
						return null;
					}
					if (NextToken != TOKEN.COLON)
					{
						return null;
					}
					json.Read();
					dictionary[text] = ParseValue();
				}
			}

			private List<object> ParseArray()
			{
				List<object> list = new List<object>();
				json.Read();
				bool flag = true;
				while (flag)
				{
					TOKEN nextToken = NextToken;
					switch (nextToken)
					{
					case TOKEN.NONE:
						return null;
					case TOKEN.SQUARED_CLOSE:
						flag = false;
						break;
					default:
					{
						object item = ParseByToken(nextToken);
						list.Add(item);
						break;
					}
					case TOKEN.COMMA:
						break;
					}
				}
				return list;
			}

			private object ParseValue()
			{
				TOKEN nextToken = NextToken;
				return ParseByToken(nextToken);
			}

			private object ParseByToken(TOKEN token)
			{
				return token switch
				{
					TOKEN.STRING => ParseString(), 
					TOKEN.NUMBER => ParseNumber(), 
					TOKEN.CURLY_OPEN => ParseObject(), 
					TOKEN.SQUARED_OPEN => ParseArray(), 
					TOKEN.TRUE => true, 
					TOKEN.FALSE => false, 
					TOKEN.NULL => null, 
					_ => null, 
				};
			}

			private string ParseString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				json.Read();
				bool flag = true;
				while (flag)
				{
					if (json.Peek() == -1)
					{
						flag = false;
						break;
					}
					char nextChar = NextChar;
					switch (nextChar)
					{
					case '"':
						flag = false;
						break;
					case '\\':
						if (json.Peek() == -1)
						{
							flag = false;
							break;
						}
						nextChar = NextChar;
						switch (nextChar)
						{
						case '"':
						case '/':
						case '\\':
							stringBuilder.Append(nextChar);
							break;
						case 'b':
							stringBuilder.Append('\b');
							break;
						case 'f':
							stringBuilder.Append('\f');
							break;
						case 'n':
							stringBuilder.Append('\n');
							break;
						case 'r':
							stringBuilder.Append('\r');
							break;
						case 't':
							stringBuilder.Append('\t');
							break;
						case 'u':
						{
							StringBuilder stringBuilder2 = new StringBuilder();
							for (int i = 0; i < 4; i++)
							{
								stringBuilder2.Append(NextChar);
							}
							stringBuilder.Append((char)Convert.ToInt32(stringBuilder2.ToString(), 16));
							break;
						}
						}
						break;
					default:
						stringBuilder.Append(nextChar);
						break;
					}
				}
				return stringBuilder.ToString();
			}

			private object ParseNumber()
			{
				string nextWord = NextWord;
				if (nextWord.IndexOf('.') == -1)
				{
					long.TryParse(nextWord, out var result);
					return result;
				}
				double.TryParse(nextWord, out var result2);
				return result2;
			}

			private void EatWhitespace()
			{
				while (" \t\n\r".IndexOf(PeekChar) != -1)
				{
					json.Read();
					if (json.Peek() == -1)
					{
						break;
					}
				}
			}
		}

		private sealed class Serializer
		{
			private StringBuilder builder;

			private Serializer()
			{
				builder = new StringBuilder();
			}

			public static string Serialize(object obj)
			{
				Serializer serializer = new Serializer();
				serializer.SerializeValue(obj);
				return serializer.builder.ToString();
			}

			private void SerializeValue(object value)
			{
				if (value == null)
				{
					builder.Append("null");
				}
				else if (value is string str)
				{
					SerializeString(str);
				}
				else if (value is bool)
				{
					builder.Append(value.ToString().ToLower());
				}
				else if (value is IList anArray)
				{
					SerializeArray(anArray);
				}
				else if (value is IDictionary obj)
				{
					SerializeObject(obj);
				}
				else if (value is char)
				{
					SerializeString(value.ToString());
				}
				else
				{
					SerializeOther(value);
				}
			}

			private void SerializeObject(IDictionary obj)
			{
				bool flag = true;
				builder.Append('{');
				foreach (object key in obj.Keys)
				{
					if (!flag)
					{
						builder.Append(',');
					}
					SerializeString(key.ToString());
					builder.Append(':');
					SerializeValue(obj[key]);
					flag = false;
				}
				builder.Append('}');
			}

			private void SerializeArray(IList anArray)
			{
				builder.Append('[');
				bool flag = true;
				foreach (object item in anArray)
				{
					if (!flag)
					{
						builder.Append(',');
					}
					SerializeValue(item);
					flag = false;
				}
				builder.Append(']');
			}

			private void SerializeString(string str)
			{
				builder.Append('"');
				char[] array = str.ToCharArray();
				foreach (char c in array)
				{
					switch (c)
					{
					case '"':
						builder.Append("\\\"");
						continue;
					case '\\':
						builder.Append("\\\\");
						continue;
					case '\b':
						builder.Append("\\b");
						continue;
					case '\f':
						builder.Append("\\f");
						continue;
					case '\n':
						builder.Append("\\n");
						continue;
					case '\r':
						builder.Append("\\r");
						continue;
					case '\t':
						builder.Append("\\t");
						continue;
					}
					int num = Convert.ToInt32(c);
					if (num >= 32 && num <= 126)
					{
						builder.Append(c);
					}
					else
					{
						builder.Append("\\u" + Convert.ToString(num, 16).PadLeft(4, '0'));
					}
				}
				builder.Append('"');
			}

			private void SerializeOther(object value)
			{
				if (value is float || value is int || value is uint || value is long || value is double || value is sbyte || value is byte || value is short || value is ushort || value is ulong || value is decimal)
				{
					builder.Append(value.ToString());
				}
				else
				{
					SerializeString(value.ToString());
				}
			}
		}

		public static object Deserialize(string json)
		{
			if (json == null)
			{
				return null;
			}
			return Parser.Parse(json);
		}

		public static string Serialize(object obj)
		{
			return Serializer.Serialize(obj);
		}
	}
}
namespace Pico.Avatar.Postprocess
{
	internal class PicoColorTemperature : MonoBehaviour
	{
		public Material blitMaterial;

		public void OnRenderImage(RenderTexture srcRT, RenderTexture destRT)
		{
			if (!(blitMaterial == null))
			{
				Graphics.Blit(srcRT, destRT, blitMaterial);
			}
		}

		public static void CheckColorTemperature()
		{
			if (GraphicsSettings.currentRenderPipeline != null || PicoAvatarApp.instance == null || (PicoAvatarApp.instance.enabledFullscreenFeatures & 2) == 0)
			{
				return;
			}
			Camera camera = PicoAvatarApp.instance.mainCamera;
			if (camera == null)
			{
				camera = Camera.main;
			}
			if (!(camera == null))
			{
				PicoMaterialConfiguration materialConfiguration = PicoAvatarApp.instance.materialConfiguration;
				if (!(materialConfiguration == null) && !(materialConfiguration.colorTemperatureMaterial == null))
				{
					camera.gameObject.AddComponent<PicoColorTemperature>().blitMaterial = materialConfiguration.colorTemperatureMaterial;
				}
			}
		}
	}
}
namespace Pico.Avatar.IO
{
	public class Serialization
	{
		private const string AvatarSDKDLL = "effect";

		public static T LoadFromFile<T>(string filPathName) where T : NativeObject, new()
		{
			T val = new T();
			using RefTargetGuard<MemoryView> refTargetGuard = new RefTargetGuard<MemoryView>(new MemoryView(filPathName));
			LoadFromMemoryView(val, refTargetGuard.target);
			return val;
		}

		public static T LoadFromBytes<T>(byte[] bytes) where T : NativeObject, new()
		{
			T val = new T();
			using RefTargetGuard<MemoryView> refTargetGuard = new RefTargetGuard<MemoryView>(new MemoryView(bytes, shared: true));
			LoadFromMemoryView(val, refTargetGuard.target);
			return val;
		}

		public static T LoadFromMemoryView<T>(MemoryView memoryView) where T : NativeObject, new()
		{
			T val = new T();
			LoadFromMemoryView(val, memoryView);
			return val;
		}

		public static void LoadFromMemoryView<T>(T obj, MemoryView memoryView) where T : NativeObject
		{
			memoryView.Retain();
			if (memoryView.length == 0)
			{
				memoryView.Release();
				throw new FormatException("LoadFromMemoryView wrong.");
			}
			if (pav_Serialization_LoadFromMemoryView(obj.nativeHandle, memoryView.nativeHandle))
			{
				memoryView.Release();
				obj.OnPostLoad();
				return;
			}
			memoryView.Release();
			throw new FormatException("LoadFromMemoryView wrong.");
		}

		public static void SaveToLocalFile(string localFilePath, NativeObject obj, ResourcePlatform resourcePlatform = ResourcePlatform.Any, FileEncryptMethod encryptMethod = FileEncryptMethod.Normal, string debugText = "")
		{
			if (obj != null)
			{
				using (RefTargetGuard<MemoryView> refTargetGuard = new RefTargetGuard<MemoryView>(SaveToMemoryView(obj, resourcePlatform, encryptMethod, debugText)))
				{
					refTargetGuard.target.WriteBytesToFile(localFilePath);
				}
			}
		}

		public static MemoryView SaveToMemoryView(NativeObject obj, ResourcePlatform resourcePlatform = ResourcePlatform.Any, FileEncryptMethod encryptMethod = FileEncryptMethod.Normal, string debugText = "")
		{
			if (obj == null)
			{
				throw new NullReferenceException("SaveToMemoryView obj is null.");
			}
			MemoryView memoryView = new MemoryView(pav_Serialization_SaveToMemoryView(obj.nativeHandle, (uint)resourcePlatform, (uint)encryptMethod));
			if (memoryView.nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("SaveToMemoryView failed.");
			}
			return memoryView;
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_Serialization_LoadFromMemoryView(IntPtr obj, IntPtr memoryViewHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern MemoryView.NativeData pav_Serialization_SaveToMemoryView(IntPtr obj, uint resourcePlatform, uint encryptMethod);
	}
	public enum ReadWriteMode
	{
		Read = 1,
		Write
	}
	public enum SeekOrigin
	{
		Set,
		Cur
	}
	public class Stream : System.IO.Stream, RefTarget
	{
		private volatile int _refCount;

		private IntPtr _nativeHandle;

		private GCHandle _externalMemoryHandle;

		private byte[] _externalMemory;

		private ReadWriteMode _readWriteMode;

		private bool _isClosed = true;

		private const string PavDLLName = "effect";

		public IntPtr nativeHandle => _nativeHandle;

		public bool isContinuousMemoryStream => pav_Stream_IsContinuousMemoryStream(_nativeHandle);

		public int refCount => _refCount;

		[Preserve]
		public override long Position
		{
			get
			{
				if (_nativeHandle == IntPtr.Zero)
				{
					throw new NullReferenceException("Position _nativeHandle is null. Maybe has been closed");
				}
				return pav_Stream_Tell(_nativeHandle);
			}
			set
			{
				if (_nativeHandle == IntPtr.Zero)
				{
					throw new NullReferenceException("Position _nativeHandle is null. Maybe has been closed");
				}
				pav_Stream_Seek(_nativeHandle, (int)value, 0);
			}
		}

		[Preserve]
		public override long Length
		{
			get
			{
				if (_nativeHandle == IntPtr.Zero)
				{
					throw new NullReferenceException("Position _nativeHandle is null. Maybe has been closed");
				}
				return pav_Stream_GetSize(_nativeHandle);
			}
		}

		[Preserve]
		public override bool CanWrite => true;

		[Preserve]
		public override bool CanSeek => true;

		[Preserve]
		public override bool CanRead => true;

		public void Retain()
		{
			_refCount++;
		}

		public void Release()
		{
			if (--_refCount < 1)
			{
				Close();
			}
		}

		public Stream(int capacity)
		{
			_readWriteMode = ReadWriteMode.Write;
			_nativeHandle = pav_Stream_New(capacity);
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Stream");
			}
		}

		public Stream(byte[] data, int offset, int size, bool shareMemory, ReadWriteMode _readWriteMode = ReadWriteMode.Write)
		{
			this._readWriteMode = _readWriteMode;
			GCHandle externalMemoryHandle = GCHandle.Alloc(data, GCHandleType.Pinned);
			_nativeHandle = pav_Stream_NewWithData(externalMemoryHandle.AddrOfPinnedObject(), offset, size, shareMemory);
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Stream.New");
			}
			if (shareMemory)
			{
				_externalMemory = data;
				_externalMemoryHandle = externalMemoryHandle;
			}
			else
			{
				externalMemoryHandle.Free();
			}
		}

		public Stream(IntPtr localMemoryPtr, int offset, int size, ReadWriteMode _readWriteMode = ReadWriteMode.Write)
		{
			this._readWriteMode = _readWriteMode;
			_nativeHandle = pav_Stream_NewWithData(localMemoryPtr, offset, size, shareMem: false);
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Stream.New");
			}
		}

		public Stream(IntPtr _nativeHandle, ReadWriteMode _readWriteMode, bool needRetain)
		{
			this._readWriteMode = _readWriteMode;
			this._nativeHandle = _nativeHandle;
			if (this._nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Stream.New");
			}
			NativeObject.RetainNative(_nativeHandle);
		}

		public Stream(string localFilePath, ReadWriteMode _readWriteMode)
		{
			this._readWriteMode = _readWriteMode;
			_nativeHandle = pav_Stream_NewWithLocalFile(localFilePath, (int)_readWriteMode, cacheToMemoryStream: true);
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Stream.New");
			}
		}

		~Stream()
		{
			if (_nativeHandle != IntPtr.Zero)
			{
				DetachNative();
			}
		}

		[Preserve]
		protected override void Dispose(bool disposing)
		{
			_isClosed = true;
			if (_refCount < 1)
			{
				DetachNative();
			}
		}

		private void DetachNative()
		{
			NativeObject.ReleaseNative(ref _nativeHandle);
			if (_externalMemory != null)
			{
				_externalMemoryHandle.Free();
				_externalMemory = null;
			}
		}

		public void Reset(bool resetRead, bool resetWrite)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("Reset _nativeHandle is null.");
			}
			pav_Stream_Reset(_nativeHandle, resetRead, resetWrite);
		}

		public int ReadAllTo(byte[] outData, int offset)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("ReadAllTo _nativeHandle is null.");
			}
			int num = pav_Stream_GetSize(_nativeHandle);
			if (num + offset < outData.Length)
			{
				return 0;
			}
			pav_Stream_Seek(_nativeHandle, 0, 0);
			GCHandle gCHandle = GCHandle.Alloc(outData, GCHandleType.Pinned);
			int result = pav_Stream_ReadBytes(_nativeHandle, gCHandle.AddrOfPinnedObject(), offset, num);
			gCHandle.Free();
			return result;
		}

		public byte[] ReadAll()
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("ReadAll _nativeHandle is null.");
			}
			int num = pav_Stream_GetSize(_nativeHandle);
			if (num == 0)
			{
				return new byte[0];
			}
			byte[] array = new byte[num];
			pav_Stream_Seek(_nativeHandle, 0, 0);
			GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
			if (pav_Stream_ReadBytes(_nativeHandle, gCHandle.AddrOfPinnedObject(), 0, num) < num)
			{
				array = new byte[0];
			}
			gCHandle.Free();
			return array;
		}

		public void SaveToFile(string localFilePathName)
		{
			if (string.IsNullOrEmpty(localFilePathName))
			{
				throw new NullReferenceException("AMemoryStream.SaveToFile need valid file path name.");
			}
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("SaveToFile _nativeHandle is null. Maybe has been closed");
			}
			if (pav_Stream_WriteBytesToFile(_nativeHandle, localFilePathName) != 0)
			{
				throw new IOException("Failed to save file:" + localFilePathName);
			}
		}

		public void Open()
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new System.IO.InvalidDataException("ABinaryReader failed to open stream!");
			}
			_isClosed = false;
		}

		public string AsText()
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("Reset _nativeHandle is null.");
			}
			uint num = pav_Stream_GetTextCharCount(_nativeHandle);
			if (num == 0)
			{
				return null;
			}
			char[] value = new char[num];
			GCHandle gCHandle = GCHandle.Alloc(value, GCHandleType.Pinned);
			uint num2 = pav_Stream_CopyTextChars(_nativeHandle, gCHandle.AddrOfPinnedObject(), num);
			gCHandle.Free();
			if (num2 == num)
			{
				return new string(value, 0, (int)num);
			}
			return null;
		}

		public void SetText(string text)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("Reset _nativeHandle is null.");
			}
			pav_Stream_SetText(_nativeHandle, text);
		}

		public static Stream OpenAppAssetFile(string assetFilePathName)
		{
			IntPtr intPtr = pav_Stream_NewWithAppAssetFile(IntPtr.Zero, assetFilePathName);
			if (intPtr != IntPtr.Zero)
			{
				return new Stream(intPtr, ReadWriteMode.Read, needRetain: false);
			}
			return null;
		}

		[Preserve]
		public override void Flush()
		{
		}

		[Preserve]
		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("Read _nativeHandle is null. Maybe has been closed");
			}
			GCHandle gCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			int result = pav_Stream_ReadBytes(_nativeHandle, gCHandle.AddrOfPinnedObject(), offset, count);
			gCHandle.Free();
			return result;
		}

		[Preserve]
		public override int ReadByte()
		{
			return pav_Stream_ReadByte(_nativeHandle);
		}

		[Preserve]
		public override long Seek(long offset, System.IO.SeekOrigin origin)
		{
			pav_Stream_Seek(_nativeHandle, (int)offset, (int)origin);
			return Position;
		}

		[Preserve]
		public override void SetLength(long value)
		{
			if (_nativeHandle == IntPtr.Zero)
			{
				throw new NullReferenceException("SetLength _nativeHandle is null. Maybe has been closed");
			}
			pav_Stream_SetSize(_nativeHandle, (int)value);
		}

		[Preserve]
		public override void Write(byte[] buffer, int offset, int count)
		{
			GCHandle gCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			pav_Stream_WriteBytes(_nativeHandle, gCHandle.AddrOfPinnedObject(), offset, count);
			gCHandle.Free();
		}

		[Preserve]
		public override void WriteByte(byte value)
		{
			pav_Stream_WriteByte(_nativeHandle, value);
		}

		public void WriteMemoryStream(Stream oth)
		{
			if (!oth.isContinuousMemoryStream)
			{
				throw new Exception("WriteMemoryStream need memory stream ");
			}
			NativeResult nativeResult = pav_Stream_WriteMemoryStream(_nativeHandle, oth.nativeHandle);
			if (nativeResult != 0)
			{
				throw new Exception("pav_Stream_WriteMemoryStream failed. error: " + nativeResult);
			}
		}

		public void ReadMemoryStream(Stream oth)
		{
			if (!oth.isContinuousMemoryStream)
			{
				throw new Exception("ReadMemoryStream need memory stream ");
			}
			NativeResult nativeResult = pav_Stream_ReadMemoryStream(_nativeHandle, oth.nativeHandle);
			if (nativeResult != 0)
			{
				throw new Exception("pav_Stream_ReadMemoryStream failed. error: " + nativeResult);
			}
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_Stream_New(int bufferCapacity);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_Stream_NewWithData(IntPtr dataBuffer, int dataOffset, int dataSize, bool shareMem);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_Stream_NewWithLocalFile(string localFilePathName, int readWriteMode, bool cacheToMemoryStream);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_Stream_NewWithAppAssetFile(IntPtr osAppHandle, string assetFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_Stream_IsContinuousMemoryStream(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_SetSize(IntPtr handle, int size);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_Stream_GetSize(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_Stream_Reset(IntPtr handle, bool resetRead, bool resetWrite);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_Stream_IsReadBad(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool pav_Stream_IsWriteBad(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern void pav_Stream_Seek(IntPtr handle, int offsetFromOrigin, int seekOrigin);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_Stream_Tell(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_WriteByte(IntPtr handle, byte val);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_WriteBytes(IntPtr handle, IntPtr dataBuffer, int dataOffset, int dataSize);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_WriteMemoryStream(IntPtr handle, IntPtr othMemoryStreamHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern byte pav_Stream_ReadByte(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_Stream_ReadBytes(IntPtr handle, IntPtr dataBuffer, int dataOffset, int dataSize);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_ReadMemoryStream(IntPtr handle, IntPtr othMemoryStreamHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_Stream_WriteBytesToFile(IntPtr handle, string filePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_Stream_GetTextCharCount(IntPtr handle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_Stream_CopyTextChars(IntPtr handle, IntPtr utf16Chars, uint charCount);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern uint pav_Stream_SetText(IntPtr handle, string text);
	}
	public class ArchiveFileSystem : NativeObject
	{
		private const string PavDLLName = "effect";

		public ArchiveFileSystem()
		{
			SetNativeHandle(pav_ArchiveFileSystem_Create(), needRetain: false);
		}

		public NativeResult LoadFromFile(string archiveFilePathName)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("PicoArchiveFileSystem closed.");
			}
			return pav_ArchiveFileSystem_Load(base.nativeHandle, archiveFilePathName);
		}

		public NativeResult LoadFromBytes(byte[] bytesData)
		{
			MemoryView memoryView = new MemoryView(bytesData, shared: false);
			NativeResult result = pav_ArchiveFileSystem_LoadFromMemoryView(base.nativeHandle, memoryView.nativeHandle);
			memoryView.CheckDelete();
			return result;
		}

		public static NativeResult ArchiveFiles(string srcDirPathName, string targetFilePathName, string fileNames, uint flags = 0u)
		{
			return pav_ArchiveFileSystem_ArchiveFiles(srcDirPathName, targetFilePathName, fileNames, flags);
		}

		public static NativeResult ArchiveAllFiles(string srcDirPathName, string targetFilePathName)
		{
			return pav_ArchiveFileSystem_ArchiveAllFiles(srcDirPathName, targetFilePathName);
		}

		public NativeResult UnarchiveFiles(string targetDirPathName)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("PicoArchiveFileSystem closed.");
			}
			return pav_ArchiveFileSystem_UnarchiveFilesToDirectory(base.nativeHandle, targetDirPathName);
		}

		public string GetFileList(string directory)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("PicoArchiveFileSystem closed.");
			}
			uint length = Utility.sharedStringBuffer.length;
			int strLen = pav_ArchiveFileSystem_GetFileList(base.nativeHandle, directory, Utility.sharedStringBuffer.Lock(), (int)length);
			Utility.sharedStringBuffer.Unlock();
			return Utility.sharedStringBuffer.GetANSIString((uint)strLen);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_ArchiveFileSystem_Create();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ArchiveFileSystem_Load(IntPtr nativeHandle, string archiveFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ArchiveFileSystem_LoadFromMemoryView(IntPtr nativeHandle, IntPtr memoryViewHandle);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ArchiveFileSystem_ArchiveFiles(string srcDirPathName, string targetFilePathName, string fileNames, uint flags);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ArchiveFileSystem_ArchiveAllFiles(string srcDirPathName, string targetFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ArchiveFileSystem_UnarchiveFilesToDirectory(IntPtr nativeHandle, string targetDirPathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_ArchiveFileSystem_GetFileList(IntPtr nativeHandle, string directory, IntPtr fileList, int bufferLen);
	}
	public class ZipFileSystem : NativeObject
	{
		private const string PavDLLName = "effect";

		public ZipFileSystem()
		{
			SetNativeHandle(pav_ZipFileSystem_Create(), needRetain: false);
		}

		public NativeResult LoadFromFile(string zipFilePathName)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("PicoZipFileSystem closed.");
			}
			return pav_ZipFileSystem_Load(base.nativeHandle, zipFilePathName);
		}

		public string GetFileList(string directory)
		{
			if (base.nativeHandle == IntPtr.Zero)
			{
				throw new Exception("PicoZipFileSystem closed.");
			}
			uint length = Utility.sharedStringBuffer.length;
			int strLen = pav_ZipFileSystem_GetFileList(base.nativeHandle, directory, Utility.sharedStringBuffer.Lock(), (int)length);
			Utility.sharedStringBuffer.Unlock();
			return Utility.sharedStringBuffer.GetANSIString((uint)strLen);
		}

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr pav_ZipFileSystem_Create();

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern NativeResult pav_ZipFileSystem_Load(IntPtr nativeHandle, string zipFilePathName);

		[DllImport("effect", CallingConvention = CallingConvention.Cdecl)]
		private static extern int pav_ZipFileSystem_GetFileList(IntPtr nativeHandle, string directory, IntPtr fileList, int bufferLen);
	}
}
namespace Pico.Avatar.SdkInvokes
{
	public class SdkCallBase
	{
		public int instanceId { get; set; }

		public virtual string typeName { get; }

		public virtual string methodName { get; }

		public virtual bool needReturn { get; }

		public virtual Dictionary<string, object> BuildInvokeBody()
		{
			return new Dictionary<string, object>();
		}

		public virtual void HandleInvoke(Dictionary<string, object> body)
		{
		}
	}
}
namespace Photon.Realtime.Demo
{
	public class ConnectAndJoinRandomLb : MonoBehaviour, IConnectionCallbacks, IMatchmakingCallbacks, ILobbyCallbacks
	{
		[SerializeField]
		private AppSettings appSettings = new AppSettings();

		private LoadBalancingClient lbc;

		private ConnectionHandler ch;

		public Text StateUiText;

		public void Start()
		{
			lbc = new LoadBalancingClient();
			lbc.AddCallbackTarget(this);
			if (!lbc.ConnectUsingSettings(appSettings))
			{
				UnityEngine.Debug.LogError("Error while connecting");
			}
			ch = base.gameObject.GetComponent<ConnectionHandler>();
			if (ch != null)
			{
				ch.Client = lbc;
				ch.StartFallbackSendAckThread();
			}
		}

		public void Update()
		{
			LoadBalancingClient loadBalancingClient = lbc;
			if (loadBalancingClient != null)
			{
				loadBalancingClient.Service();
				Text stateUiText = StateUiText;
				string text = loadBalancingClient.State.ToString();
				if (stateUiText != null && !stateUiText.text.Equals(text))
				{
					stateUiText.text = "State: " + text;
				}
			}
		}

		public void OnConnected()
		{
		}

		public void OnConnectedToMaster()
		{
			UnityEngine.Debug.Log("OnConnectedToMaster");
			lbc.OpJoinRandomRoom();
		}

		public void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log("OnDisconnected(" + cause.ToString() + ")");
		}

		public void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public void OnRegionListReceived(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionListReceived");
			regionHandler.PingMinimumOfRegions(OnRegionPingCompleted, null);
		}

		public void OnRoomListUpdate(List<RoomInfo> roomList)
		{
		}

		public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
		{
		}

		public void OnJoinedLobby()
		{
		}

		public void OnLeftLobby()
		{
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
			UnityEngine.Debug.Log("OnJoinedRoom");
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
			UnityEngine.Debug.Log("OnJoinRandomFailed");
			lbc.OpCreateRoom(new EnterRoomParams());
		}

		public void OnLeftRoom()
		{
		}

		private void OnRegionPingCompleted(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionPingCompleted " + (object)regionHandler.BestRegion);
			UnityEngine.Debug.Log("RegionPingSummary: " + regionHandler.SummaryToCache);
			lbc.ConnectToRegionMaster(regionHandler.BestRegion.Code);
		}
	}
}
namespace Photon.Chat.Demo
{
	public static class AppSettingsExtensions
	{
		public static ChatAppSettings GetChatSettings(this AppSettings appSettings)
		{
			return new ChatAppSettings
			{
				AppIdChat = appSettings.AppIdChat,
				AppVersion = appSettings.AppVersion,
				FixedRegion = (appSettings.IsBestRegion ? null : appSettings.FixedRegion),
				NetworkLogging = appSettings.NetworkLogging,
				Protocol = appSettings.Protocol,
				EnableProtocolFallback = appSettings.EnableProtocolFallback,
				Server = (appSettings.IsDefaultNameServer ? null : appSettings.Server),
				Port = (ushort)appSettings.Port
			};
		}
	}
	public class ChannelSelector : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		public string Channel;

		public void SetChannel(string channel)
		{
			Channel = channel;
			GetComponentInChildren<Text>().text = Channel;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			UnityEngine.Object.FindObjectOfType<ChatGui>().ShowChannel(Channel);
		}
	}
	[ExecuteInEditMode]
	public class ChatAppIdCheckerUI : MonoBehaviour
	{
		public Text Description;

		public void Update()
		{
			if (string.IsNullOrEmpty(PhotonNetwork.PhotonServerSettings.AppSettings.AppIdChat))
			{
				if (Description != null)
				{
					Description.text = "<Color=Red>WARNING:</Color>\nPlease setup a Chat AppId in the PhotonServerSettings file.";
				}
			}
			else if (Description != null)
			{
				Description.text = string.Empty;
			}
		}
	}
	public class ChatGui : MonoBehaviour, IChatClientListener
	{
		public string[] ChannelsToJoinOnConnect;

		public string[] FriendsList;

		public int HistoryLengthToFetch;

		private string selectedChannelName;

		public ChatClient chatClient;

		protected internal ChatAppSettings chatAppSettings;

		public GameObject missingAppIdErrorPanel;

		public GameObject ConnectingLabel;

		public RectTransform ChatPanel;

		public GameObject UserIdFormPanel;

		public InputField InputFieldChat;

		public Text CurrentChannelText;

		public Toggle ChannelToggleToInstantiate;

		public GameObject FriendListUiItemtoInstantiate;

		private readonly Dictionary<string, Toggle> channelToggles = new Dictionary<string, Toggle>();

		private readonly Dictionary<string, FriendItem> friendListItemLUT = new Dictionary<string, FriendItem>();

		public bool ShowState = true;

		public GameObject Title;

		public Text StateText;

		public Text UserIdText;

		private static string HelpText = "\n    -- HELP --\nTo subscribe to channel(s) (channelnames are case sensitive) :  \n\t<color=#E07B00>\\subscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\s</color> <color=green><list of channelnames></color>\n\nTo leave channel(s):\n\t<color=#E07B00>\\unsubscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\u</color> <color=green><list of channelnames></color>\n\nTo switch the active channel\n\t<color=#E07B00>\\join</color> <color=green><channelname></color>\n\tor\n\t<color=#E07B00>\\j</color> <color=green><channelname></color>\n\nTo send a private message: (username are case sensitive)\n\t\\<color=#E07B00>msg</color> <color=green><username></color> <color=green><message></color>\n\nTo change status:\n\t\\<color=#E07B00>state</color> <color=green><stateIndex></color> <color=green><message></color>\n<color=green>0</color> = Offline <color=green>1</color> = Invisible <color=green>2</color> = Online <color=green>3</color> = Away \n<color=green>4</color> = Do not disturb <color=green>5</color> = Looking For Group <color=green>6</color> = Playing\n\nTo clear the current chat tab (private chats get closed):\n\t<color=#E07B00>\\clear</color>";

		public int TestLength = 2048;

		private byte[] testBytes = new byte[2048];

		public string UserName { get; set; }

		public void Start()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			UserIdText.text = "";
			StateText.text = "";
			StateText.gameObject.SetActive(value: true);
			UserIdText.gameObject.SetActive(value: true);
			Title.SetActive(value: true);
			ChatPanel.gameObject.SetActive(value: false);
			ConnectingLabel.SetActive(value: false);
			if (string.IsNullOrEmpty(UserName))
			{
				UserName = "user" + Environment.TickCount % 99;
			}
			chatAppSettings = PhotonNetwork.PhotonServerSettings.AppSettings.GetChatSettings();
			bool flag = !string.IsNullOrEmpty(chatAppSettings.AppIdChat);
			missingAppIdErrorPanel.SetActive(!flag);
			UserIdFormPanel.gameObject.SetActive(flag);
			if (!flag)
			{
				UnityEngine.Debug.LogError("You need to set the chat app ID in the PhotonServerSettings file in order to continue.");
			}
		}

		public void Connect()
		{
			UserIdFormPanel.gameObject.SetActive(value: false);
			chatClient = new ChatClient(this);
			chatClient.UseBackgroundWorkerForSending = true;
			chatClient.AuthValues = new AuthenticationValues(UserName);
			chatClient.ConnectUsingSettings(chatAppSettings);
			ChannelToggleToInstantiate.gameObject.SetActive(value: false);
			UnityEngine.Debug.Log("Connecting as: " + UserName);
			ConnectingLabel.SetActive(value: true);
		}

		public void OnDestroy()
		{
			if (chatClient != null)
			{
				chatClient.Disconnect();
			}
		}

		public void OnApplicationQuit()
		{
			if (chatClient != null)
			{
				chatClient.Disconnect();
			}
		}

		public void Update()
		{
			if (chatClient != null)
			{
				chatClient.Service();
			}
			if (StateText == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				StateText.gameObject.SetActive(ShowState);
			}
		}

		public void OnEnterSend()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SendChatMessage(InputFieldChat.text);
				InputFieldChat.text = "";
			}
		}

		public void OnClickSend()
		{
			if (InputFieldChat != null)
			{
				SendChatMessage(InputFieldChat.text);
				InputFieldChat.text = "";
			}
		}

		private void SendChatMessage(string inputLine)
		{
			if (string.IsNullOrEmpty(inputLine))
			{
				return;
			}
			if ("test".Equals(inputLine))
			{
				if (TestLength != testBytes.Length)
				{
					testBytes = new byte[TestLength];
				}
				chatClient.SendPrivateMessage(chatClient.AuthValues.UserId, testBytes, forwardAsWebhook: true);
			}
			bool flag = chatClient.PrivateChannels.ContainsKey(selectedChannelName);
			string target = string.Empty;
			if (flag)
			{
				target = selectedChannelName.Split(':')[1];
			}
			if (inputLine[0].Equals('\\'))
			{
				string[] array = inputLine.Split(new char[1] { ' ' }, 2);
				if (array[0].Equals("\\help"))
				{
					PostHelpToCurrentChannel();
				}
				if (array[0].Equals("\\state"))
				{
					int status = 0;
					List<string> list = new List<string>();
					list.Add("i am state " + status);
					string[] array2 = array[1].Split(' ', ',');
					if (array2.Length != 0)
					{
						status = int.Parse(array2[0]);
					}
					if (array2.Length > 1)
					{
						list.Add(array2[1]);
					}
					chatClient.SetOnlineStatus(status, list.ToArray());
				}
				else if ((array[0].Equals("\\subscribe") || array[0].Equals("\\s")) && !string.IsNullOrEmpty(array[1]))
				{
					chatClient.Subscribe(array[1].Split(' ', ','));
				}
				else if ((array[0].Equals("\\unsubscribe") || array[0].Equals("\\u")) && !string.IsNullOrEmpty(array[1]))
				{
					chatClient.Unsubscribe(array[1].Split(' ', ','));
				}
				else if (array[0].Equals("\\clear"))
				{
					ChatChannel channel;
					if (flag)
					{
						chatClient.PrivateChannels.Remove(selectedChannelName);
					}
					else if (chatClient.TryGetChannel(selectedChannelName, flag, out channel))
					{
						channel.ClearMessages();
					}
				}
				else if (array[0].Equals("\\msg") && !string.IsNullOrEmpty(array[1]))
				{
					string[] array3 = array[1].Split(new char[2] { ' ', ',' }, 2);
					if (array3.Length >= 2)
					{
						string target2 = array3[0];
						string message = array3[1];
						chatClient.SendPrivateMessage(target2, message);
					}
				}
				else if ((array[0].Equals("\\join") || array[0].Equals("\\j")) && !string.IsNullOrEmpty(array[1]))
				{
					string[] array4 = array[1].Split(new char[2] { ' ', ',' }, 2);
					if (channelToggles.ContainsKey(array4[0]))
					{
						ShowChannel(array4[0]);
						return;
					}
					chatClient.Subscribe(new string[1] { array4[0] });
				}
				else
				{
					UnityEngine.Debug.Log("The command '" + array[0] + "' is invalid.");
				}
			}
			else if (flag)
			{
				chatClient.SendPrivateMessage(target, inputLine);
			}
			else
			{
				chatClient.PublishMessage(selectedChannelName, inputLine);
			}
		}

		public void PostHelpToCurrentChannel()
		{
			CurrentChannelText.text += HelpText;
		}

		public void DebugReturn(DebugLevel level, string message)
		{
			switch (level)
			{
			case DebugLevel.ERROR:
				UnityEngine.Debug.LogError(message);
				break;
			case DebugLevel.WARNING:
				UnityEngine.Debug.LogWarning(message);
				break;
			default:
				UnityEngine.Debug.Log(message);
				break;
			}
		}

		public void OnConnected()
		{
			if (ChannelsToJoinOnConnect != null && ChannelsToJoinOnConnect.Length != 0)
			{
				chatClient.Subscribe(ChannelsToJoinOnConnect, HistoryLengthToFetch);
			}
			ConnectingLabel.SetActive(value: false);
			UserIdText.text = "Connected as " + UserName;
			ChatPanel.gameObject.SetActive(value: true);
			if (FriendsList != null && FriendsList.Length != 0)
			{
				chatClient.AddFriends(FriendsList);
				string[] friendsList = FriendsList;
				foreach (string text in friendsList)
				{
					if (FriendListUiItemtoInstantiate != null && text != UserName)
					{
						InstantiateFriendButton(text);
					}
				}
			}
			if (FriendListUiItemtoInstantiate != null)
			{
				FriendListUiItemtoInstantiate.SetActive(value: false);
			}
			chatClient.SetOnlineStatus(2);
		}

		public void OnDisconnected()
		{
			ConnectingLabel.SetActive(value: false);
		}

		public void OnChatStateChange(ChatState state)
		{
			StateText.text = state.ToString();
		}

		public void OnSubscribed(string[] channels, bool[] results)
		{
			foreach (string channelName in channels)
			{
				chatClient.PublishMessage(channelName, "says 'hi'.");
				if (ChannelToggleToInstantiate != null)
				{
					InstantiateChannelButton(channelName);
				}
			}
			UnityEngine.Debug.Log("OnSubscribed: " + string.Join(", ", channels));
			ShowChannel(channels[0]);
		}

		public void OnSubscribed(string channel, string[] users, Dictionary<object, object> properties)
		{
			UnityEngine.Debug.LogFormat("OnSubscribed: {0}, users.Count: {1} Channel-props: {2}.", channel, users.Length, properties.ToStringFull());
		}

		private void InstantiateChannelButton(string channelName)
		{
			if (channelToggles.ContainsKey(channelName))
			{
				UnityEngine.Debug.Log("Skipping creation for an existing channel toggle.");
				return;
			}
			Toggle toggle = UnityEngine.Object.Instantiate(ChannelToggleToInstantiate);
			toggle.gameObject.SetActive(value: true);
			toggle.GetComponentInChildren<ChannelSelector>().SetChannel(channelName);
			toggle.transform.SetParent(ChannelToggleToInstantiate.transform.parent, worldPositionStays: false);
			channelToggles.Add(channelName, toggle);
		}

		private void InstantiateFriendButton(string friendId)
		{
			GameObject obj = UnityEngine.Object.Instantiate(FriendListUiItemtoInstantiate);
			obj.gameObject.SetActive(value: true);
			FriendItem component = obj.GetComponent<FriendItem>();
			component.FriendId = friendId;
			obj.transform.SetParent(FriendListUiItemtoInstantiate.transform.parent, worldPositionStays: false);
			friendListItemLUT[friendId] = component;
		}

		public void OnUnsubscribed(string[] channels)
		{
			foreach (string text in channels)
			{
				if (channelToggles.ContainsKey(text))
				{
					UnityEngine.Object.Destroy(channelToggles[text].gameObject);
					channelToggles.Remove(text);
					UnityEngine.Debug.Log("Unsubscribed from channel '" + text + "'.");
					if (text == selectedChannelName && channelToggles.Count > 0)
					{
						IEnumerator<KeyValuePair<string, Toggle>> enumerator = channelToggles.GetEnumerator();
						enumerator.MoveNext();
						ShowChannel(enumerator.Current.Key);
						enumerator.Current.Value.isOn = true;
					}
				}
				else
				{
					UnityEngine.Debug.Log("Can't unsubscribe from channel '" + text + "' because you are currently not subscribed to it.");
				}
			}
		}

		public void OnGetMessages(string channelName, string[] senders, object[] messages)
		{
			if (channelName.Equals(selectedChannelName))
			{
				ShowChannel(selectedChannelName);
			}
		}

		public void OnPrivateMessage(string sender, object message, string channelName)
		{
			InstantiateChannelButton(channelName);
			if (message is byte[] array)
			{
				UnityEngine.Debug.Log("Message with byte[].Length: " + array.Length);
			}
			if (selectedChannelName.Equals(channelName))
			{
				ShowChannel(channelName);
			}
		}

		public void OnStatusUpdate(string user, int status, bool gotMessage, object message)
		{
			UnityEngine.Debug.LogWarning("status: " + $"{user} is {status}. Msg:{message}");
			if (friendListItemLUT.ContainsKey(user))
			{
				FriendItem friendItem = friendListItemLUT[user];
				if (friendItem != null)
				{
					friendItem.OnFriendStatusUpdate(status, gotMessage, message);
				}
			}
		}

		public void OnUserSubscribed(string channel, string user)
		{
			UnityEngine.Debug.LogFormat("OnUserSubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
		}

		public void OnUserUnsubscribed(string channel, string user)
		{
			UnityEngine.Debug.LogFormat("OnUserUnsubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
		}

		public void OnChannelPropertiesChanged(string channel, string userId, Dictionary<object, object> properties)
		{
			UnityEngine.Debug.LogFormat("OnChannelPropertiesChanged: {0} by {1}. Props: {2}.", channel, userId, properties.ToStringFull());
		}

		public void OnUserPropertiesChanged(string channel, string targetUserId, string senderUserId, Dictionary<object, object> properties)
		{
			UnityEngine.Debug.LogFormat("OnUserPropertiesChanged: (channel:{0} user:{1}) by {2}. Props: {3}.", channel, targetUserId, senderUserId, properties.ToStringFull());
		}

		public void OnErrorInfo(string channel, string error, object data)
		{
			UnityEngine.Debug.LogFormat("OnErrorInfo for channel {0}. Error: {1} Data: {2}", channel, error, data);
		}

		public void AddMessageToSelectedChannel(string msg)
		{
			ChatChannel channel = null;
			if (!chatClient.TryGetChannel(selectedChannelName, out channel))
			{
				UnityEngine.Debug.Log("AddMessageToSelectedChannel failed to find channel: " + selectedChannelName);
			}
			else
			{
				channel?.Add("Bot", msg, 0);
			}
		}

		public void ShowChannel(string channelName)
		{
			if (string.IsNullOrEmpty(channelName))
			{
				return;
			}
			ChatChannel channel = null;
			if (!chatClient.TryGetChannel(channelName, out channel))
			{
				UnityEngine.Debug.Log("ShowChannel failed to find channel: " + channelName);
				return;
			}
			selectedChannelName = channelName;
			CurrentChannelText.text = channel.ToStringMessages();
			UnityEngine.Debug.Log("ShowChannel: " + selectedChannelName);
			foreach (KeyValuePair<string, Toggle> channelToggle in channelToggles)
			{
				channelToggle.Value.isOn = ((channelToggle.Key == channelName) ? true : false);
			}
		}

		public void OpenDashboard()
		{
			Application.OpenURL("https://dashboard.photonengine.com");
		}
	}
	public class FriendItem : MonoBehaviour
	{
		public Text NameLabel;

		public Text StatusLabel;

		public Text Health;

		[HideInInspector]
		public string FriendId
		{
			get
			{
				return NameLabel.text;
			}
			set
			{
				NameLabel.text = value;
			}
		}

		public void Awake()
		{
			Health.text = string.Empty;
		}

		public void OnFriendStatusUpdate(int status, bool gotMessage, object message)
		{
			StatusLabel.text = status switch
			{
				1 => "Invisible", 
				2 => "Online", 
				3 => "Away", 
				4 => "Do not disturb", 
				5 => "Looking For Game/Group", 
				6 => "Playing", 
				_ => "Offline", 
			};
			if (gotMessage)
			{
				string text = string.Empty;
				if (message != null && message is string[] array && array.Length >= 2)
				{
					text = array[1] + "%";
				}
				Health.text = text;
			}
		}
	}
	public class IgnoreUiRaycastWhenInactive : MonoBehaviour, ICanvasRaycastFilter
	{
		public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
		{
			return base.gameObject.activeInHierarchy;
		}
	}
	[RequireComponent(typeof(ChatGui))]
	public class NamePickGui : MonoBehaviour
	{
		private const string UserNamePlayerPref = "NamePickUserName";

		public ChatGui chatNewComponent;

		public InputField idInput;

		public void Start()
		{
			chatNewComponent = UnityEngine.Object.FindObjectOfType<ChatGui>();
			string @string = PlayerPrefs.GetString("NamePickUserName");
			if (!string.IsNullOrEmpty(@string))
			{
				idInput.text = @string;
			}
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				StartChat();
			}
		}

		public void StartChat()
		{
			ChatGui chatGui = UnityEngine.Object.FindObjectOfType<ChatGui>();
			chatGui.UserName = idInput.text.Trim();
			chatGui.Connect();
			base.enabled = false;
			PlayerPrefs.SetString("NamePickUserName", chatGui.UserName);
		}
	}
}
namespace Photon.Chat.UtilityScripts
{
	public class EventSystemSpawner : MonoBehaviour
	{
		private void OnEnable()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}
	}
	public class OnStartDelete : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextButtonTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private Text _text;

		public Selectable Selectable;

		public Color NormalColor = Color.white;

		public Color HoverColor = Color.black;

		public void Awake()
		{
			_text = GetComponent<Text>();
		}

		public void OnEnable()
		{
			_text.color = NormalColor;
		}

		public void OnDisable()
		{
			_text.color = NormalColor;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = HoverColor;
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = NormalColor;
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextToggleIsOnTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Toggle toggle;

		private Text _text;

		public Color NormalOnColor = Color.white;

		public Color NormalOffColor = Color.black;

		public Color HoverOnColor = Color.black;

		public Color HoverOffColor = Color.black;

		private bool isHover;

		public void OnEnable()
		{
			_text = GetComponent<Text>();
			OnValueChanged(toggle.isOn);
			toggle.onValueChanged.AddListener(OnValueChanged);
		}

		public void OnDisable()
		{
			toggle.onValueChanged.RemoveListener(OnValueChanged);
		}

		public void OnValueChanged(bool isOn)
		{
			_text.color = ((!isOn) ? (isHover ? NormalOffColor : NormalOffColor) : (isHover ? HoverOnColor : HoverOnColor));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHover = true;
			_text.color = (toggle.isOn ? HoverOnColor : HoverOffColor);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHover = false;
			_text.color = (toggle.isOn ? NormalOnColor : NormalOffColor);
		}
	}
}
namespace LIV.SDK.Unity
{
	[Flags]
	public enum INVALIDATION_FLAGS : uint
	{
		NONE = 0u,
		HMD_CAMERA = 1u,
		STAGE = 2u,
		MR_CAMERA_PREFAB = 4u,
		EXCLUDE_BEHAVIOURS = 8u
	}
	[HelpURL("https://liv.tv/sdk-unity-docs")]
	[AddComponentMenu("LIV/LIV")]
	public class LIV : MonoBehaviour
	{
		public Action onActivate;

		public Action<SDKRender> onPreRender;

		public Action<SDKRender> onPreRenderBackground;

		public Action<SDKRender> onPostRenderBackground;

		public Action<SDKRender> onPreRenderForeground;

		public Action<SDKRender> onPostRenderForeground;

		public Action<SDKRender> onPostRender;

		public Action onDeactivate;

		[Tooltip("This is the topmost transform of your VR rig.")]
		[FormerlySerializedAs("TrackedSpaceOrigin")]
		[SerializeField]
		private Transform _stage;

		[Tooltip("This transform is an additional wrapper to the user’s playspace.")]
		[FormerlySerializedAs("StageTransform")]
		[SerializeField]
		private Transform _stageTransform;

		[Tooltip("This is the camera responsible for rendering the user’s HMD.")]
		[FormerlySerializedAs("HMDCamera")]
		[SerializeField]
		private Camera _HMDCamera;

		[Tooltip("Camera prefab for customized rendering.")]
		[FormerlySerializedAs("MRCameraPrefab")]
		[SerializeField]
		private Camera _MRCameraPrefab;

		[Tooltip("This option disables all standard Unity assets for the Mixed Reality rendering.")]
		[FormerlySerializedAs("DisableStandardAssets")]
		[SerializeField]
		private bool _disableStandardAssets;

		[Tooltip("The layer mask defines exactly which object layers should be rendered in MR.")]
		[FormerlySerializedAs("SpectatorLayerMask")]
		[SerializeField]
		private LayerMask _spectatorLayerMask = -1;

		[Tooltip("This is for removing unwanted scripts from the cloned MR camera.")]
		[FormerlySerializedAs("ExcludeBehaviours")]
		[SerializeField]
		private string[] _excludeBehaviours = new string[5] { "AudioListener", "Collider", "SteamVR_Camera", "SteamVR_Fade", "SteamVR_ExternalCamera" };

		[Tooltip("Recovers corrupted alpha channel when using post-effects.")]
		[FormerlySerializedAs("FixPostEffectsAlpha")]
		[SerializeField]
		private bool _fixPostEffectsAlpha;

		private bool _isActive;

		private SDKRender _render;

		private bool _wasReady;

		private INVALIDATION_FLAGS _invalidate;

		private Transform _stageCandidate;

		private Camera _HMDCameraCandidate;

		private Camera _MRCameraPrefabCandidate;

		private string[] _excludeBehavioursCandidate;

		private bool _enabled;

		private Coroutine _waitForEndOfFrameCoroutine;

		public Transform stage
		{
			get
			{
				if (!(_stage == null))
				{
					return _stage;
				}
				return base.transform.parent;
			}
			set
			{
				if (value == null)
				{
					UnityEngine.Debug.LogWarning("LIV: Stage cannot be null!");
				}
				if (_stage != value)
				{
					_stageCandidate = value;
					_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 2uL, enabled: true);
				}
			}
		}

		[Obsolete("Use stage instead")]
		public Transform trackedSpaceOrigin
		{
			get
			{
				return stage;
			}
			set
			{
				stage = value;
			}
		}

		public Matrix4x4 stageLocalToWorldMatrix
		{
			get
			{
				if (!(stage != null))
				{
					return Matrix4x4.identity;
				}
				return stage.localToWorldMatrix;
			}
		}

		public Matrix4x4 stageWorldToLocalMatrix
		{
			get
			{
				if (!(stage != null))
				{
					return Matrix4x4.identity;
				}
				return stage.worldToLocalMatrix;
			}
		}

		public Transform stageTransform
		{
			get
			{
				return _stageTransform;
			}
			set
			{
				_stageTransform = value;
			}
		}

		public Camera HMDCamera
		{
			get
			{
				return _HMDCamera;
			}
			set
			{
				if (value == null)
				{
					UnityEngine.Debug.LogWarning("LIV: HMD Camera cannot be null!");
				}
				if (_HMDCamera != value)
				{
					_HMDCameraCandidate = value;
					_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 1uL, enabled: true);
				}
			}
		}

		public Camera MRCameraPrefab
		{
			get
			{
				return _MRCameraPrefab;
			}
			set
			{
				if (_MRCameraPrefab != value)
				{
					_MRCameraPrefabCandidate = value;
					_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 4uL, enabled: true);
				}
			}
		}

		public bool disableStandardAssets
		{
			get
			{
				return _disableStandardAssets;
			}
			set
			{
				_disableStandardAssets = value;
			}
		}

		public LayerMask spectatorLayerMask
		{
			get
			{
				return _spectatorLayerMask;
			}
			set
			{
				_spectatorLayerMask = value;
			}
		}

		public string[] excludeBehaviours
		{
			get
			{
				return _excludeBehaviours;
			}
			set
			{
				if (_excludeBehaviours != value)
				{
					_excludeBehavioursCandidate = value;
					_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 8uL, enabled: true);
				}
			}
		}

		public bool fixPostEffectsAlpha
		{
			get
			{
				return _fixPostEffectsAlpha;
			}
			set
			{
				_fixPostEffectsAlpha = value;
			}
		}

		public bool isValid
		{
			get
			{
				if (_invalidate != 0)
				{
					return false;
				}
				if (_HMDCamera == null)
				{
					UnityEngine.Debug.LogError("LIV: HMD Camera is a required parameter!");
					return false;
				}
				if (_stage == null)
				{
					UnityEngine.Debug.LogWarning("LIV: Tracked space origin should be assigned!");
				}
				if ((int)_spectatorLayerMask == 0)
				{
					UnityEngine.Debug.LogWarning("LIV: The spectator layer mask is set to not show anything. Is this correct?");
				}
				return true;
			}
		}

		public bool isActive => _isActive;

		private bool _isReady
		{
			get
			{
				if (isValid && _enabled)
				{
					return SDKBridge.IsActive;
				}
				return false;
			}
		}

		public SDKRender render => _render;

		private void OnEnable()
		{
			_enabled = true;
			UpdateSDKReady();
		}

		private void Update()
		{
			UpdateSDKReady();
			Invalidate();
		}

		private void OnDisable()
		{
			_enabled = false;
			UpdateSDKReady();
		}

		private IEnumerator WaitForUnityEndOfFrame()
		{
			while (Application.isPlaying && base.enabled)
			{
				yield return new WaitForEndOfFrame();
				if (isActive)
				{
					_render.Render();
				}
			}
		}

		private void UpdateSDKReady()
		{
			bool isReady = _isReady;
			if (isReady != _wasReady)
			{
				OnSDKReadyChanged(isReady);
				_wasReady = isReady;
			}
		}

		private void OnSDKReadyChanged(bool value)
		{
			if (value)
			{
				OnSDKActivate();
			}
			else
			{
				OnSDKDeactivate();
			}
		}

		private void OnSDKActivate()
		{
			UnityEngine.Debug.Log("LIV: Compositor connected, setting up Mixed Reality!");
			SubmitSDKOutput();
			CreateAssets();
			StartRenderCoroutine();
			_isActive = true;
			if (onActivate != null)
			{
				onActivate();
			}
		}

		private void OnSDKDeactivate()
		{
			UnityEngine.Debug.Log("LIV: Compositor disconnected, cleaning up Mixed Reality.");
			if (onDeactivate != null)
			{
				onDeactivate();
			}
			StopRenderCoroutine();
			DestroyAssets();
			_isActive = false;
		}

		private void CreateAssets()
		{
			DestroyAssets();
			_render = new SDKRender(this);
		}

		private void DestroyAssets()
		{
			if (_render != null)
			{
				_render.Dispose();
				_render = null;
			}
		}

		private void StartRenderCoroutine()
		{
			StopRenderCoroutine();
			_waitForEndOfFrameCoroutine = StartCoroutine(WaitForUnityEndOfFrame());
		}

		private void StopRenderCoroutine()
		{
			if (_waitForEndOfFrameCoroutine != null)
			{
				StopCoroutine(_waitForEndOfFrameCoroutine);
				_waitForEndOfFrameCoroutine = null;
			}
		}

		private void SubmitSDKOutput()
		{
			SDKApplicationOutput empty = SDKApplicationOutput.empty;
			empty.supportedFeatures = FEATURES.BACKGROUND_RENDER | FEATURES.FOREGROUND_RENDER | FEATURES.OVERRIDE_POST_PROCESSING | FEATURES.FIX_FOREGROUND_ALPHA;
			empty.sdkID = "6QIB2VZ4URNC6VZIKU0ZIJX2GWBSU0S3";
			empty.sdkVersion = "1.5.4";
			empty.engineName = "unity";
			empty.engineVersion = Application.unityVersion;
			empty.applicationName = Application.productName;
			empty.applicationVersion = Application.version;
			empty.graphicsAPI = SystemInfo.graphicsDeviceType.ToString();
			empty.xrDeviceName = XRSettings.loadedDeviceName;
			SDKBridge.SubmitApplicationOutput(empty);
		}

		private void Invalidate()
		{
			if (SDKUtils.ContainsFlag((ulong)_invalidate, 2uL))
			{
				_stage = _stageCandidate;
				_stageCandidate = null;
				_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 2uL, enabled: false);
			}
			if (SDKUtils.ContainsFlag((ulong)_invalidate, 1uL))
			{
				_HMDCamera = _HMDCameraCandidate;
				_HMDCameraCandidate = null;
				_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 1uL, enabled: false);
			}
			if (SDKUtils.ContainsFlag((ulong)_invalidate, 4uL))
			{
				_MRCameraPrefab = _MRCameraPrefabCandidate;
				_MRCameraPrefabCandidate = null;
				_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 4uL, enabled: false);
			}
			if (SDKUtils.ContainsFlag((ulong)_invalidate, 8uL))
			{
				_excludeBehaviours = _excludeBehavioursCandidate;
				_excludeBehavioursCandidate = null;
				_invalidate = (INVALIDATION_FLAGS)SDKUtils.SetFlag((ulong)_invalidate, 8uL, enabled: false);
			}
		}
	}
	public static class SDKBridge
	{
		public struct SDKInjection<T>
		{
			public bool active;

			public Action action;

			public T data;
		}

		private static SDKInjection<SDKInputFrame> _injection_SDKInputFrame = new SDKInjection<SDKInputFrame>
		{
			active = false,
			action = null,
			data = SDKInputFrame.empty
		};

		private static SDKInjection<SDKResolution> _injection_SDKResolution = new SDKInjection<SDKResolution>
		{
			active = false,
			action = null,
			data = SDKResolution.zero
		};

		private static SDKInjection<bool> _injection_IsActive = new SDKInjection<bool>
		{
			active = false,
			action = null,
			data = false
		};

		private static bool _injection_DisableSubmit = false;

		private static bool _injection_DisableSubmitApplicationOutput = false;

		private static bool _injection_DisableAddTexture = false;

		private static bool _injection_DisableCreateFrame = false;

		public static bool IsActive
		{
			get
			{
				if (_injection_IsActive.active)
				{
					return _injection_IsActive.data;
				}
				return GetIsCaptureActive();
			}
		}

		public static int AddStringToChannel(int slot, IntPtr str, int length, ulong tag)
		{
			return -2;
		}

		public static int addtexture(IntPtr sourcetexture, ulong tag)
		{
			return -2;
		}

		public static ulong GetObjectTimeStamp(IntPtr obj)
		{
			return 0uL;
		}

		public static ulong GetCurrentTimeTicks()
		{
			return 0uL;
		}

		private static bool GetIsCaptureActive()
		{
			return false;
		}

		public static IntPtr GetRenderEventFunc()
		{
			return IntPtr.Zero;
		}

		public static IntPtr GetCompositorChannelObject(int slot, ulong tag, ulong timestamp)
		{
			return IntPtr.Zero;
		}

		public static int AddObjectToCompositorChannel(int slot, IntPtr obj, int objectsize, ulong tag)
		{
			return -2;
		}

		public static int AddObjectToFrame(IntPtr obj, int objectsize, ulong tag)
		{
			return -2;
		}

		public static IntPtr updatinputframe(IntPtr InputFrame)
		{
			return IntPtr.Zero;
		}

		public static IntPtr GetViewportTexture()
		{
			return IntPtr.Zero;
		}

		public static IntPtr GetChannelObject(int slot, ulong tag, ulong timestamp)
		{
			return IntPtr.Zero;
		}

		public static int AddObjectToChannel(int slot, IntPtr obj, int objectsize, ulong tag)
		{
			return -2;
		}

		public static ulong Tag(string str)
		{
			ulong num = 0uL;
			for (int i = 0; i < str.Length && i != 8; i++)
			{
				char c = str[i];
				num |= (ulong)((long)(c & 0xFF) << i * 8);
			}
			return num;
		}

		public static void AddString(string tag, string value, int slot)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			GCHandle gCHandle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
			AddStringToChannel(slot, Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0), bytes.Length, Tag(tag));
			gCHandle.Free();
		}

		public static void AddTexture(SDKTexture texture, ulong tag)
		{
			GCHandle gCHandle = GCHandle.Alloc(texture, GCHandleType.Pinned);
			addtexture(gCHandle.AddrOfPinnedObject(), tag);
			gCHandle.Free();
		}

		public static ulong GetObjectTime(IntPtr objectptr)
		{
			return GetObjectTimeStamp(objectptr) + 621355968000000000L;
		}

		public static ulong GetCurrentTime()
		{
			return GetCurrentTimeTicks() + 621355968000000000L;
		}

		public static void IssuePluginEvent()
		{
			if (!_injection_DisableSubmit)
			{
				GL.IssuePluginEvent(GetRenderEventFunc(), 2);
			}
		}

		public static void SubmitApplicationOutput(SDKApplicationOutput applicationOutput)
		{
			if (!_injection_DisableSubmitApplicationOutput)
			{
				AddString("APPNAME", applicationOutput.applicationName, 5);
				AddString("APPVER", applicationOutput.applicationVersion, 5);
				AddString("ENGNAME", applicationOutput.engineName, 5);
				AddString("ENGVER", applicationOutput.engineVersion, 5);
				AddString("GFXAPI", applicationOutput.graphicsAPI, 5);
				AddString("SDKID", applicationOutput.sdkID, 5);
				AddString("SDKVER", applicationOutput.sdkVersion, 5);
				AddString("SUPPORT", applicationOutput.supportedFeatures.ToString(), 5);
				AddString("XRNAME", applicationOutput.xrDeviceName, 5);
			}
		}

		public static bool GetStructFromGlobalChannel<T>(ref T mystruct, int channel, ulong tag)
		{
			IntPtr compositorChannelObject = GetCompositorChannelObject(channel, tag, ulong.MaxValue);
			if (compositorChannelObject == IntPtr.Zero)
			{
				return false;
			}
			mystruct = (T)Marshal.PtrToStructure(compositorChannelObject, typeof(T));
			return true;
		}

		public static int AddStructToGlobalChannel<T>(ref T mystruct, int channel, ulong tag)
		{
			GCHandle gCHandle = GCHandle.Alloc(mystruct, GCHandleType.Pinned);
			int result = AddObjectToCompositorChannel(channel, gCHandle.AddrOfPinnedObject(), Marshal.SizeOf(mystruct), tag);
			gCHandle.Free();
			return result;
		}

		public static bool GetStructFromLocalChannel<T>(ref T mystruct, int channel, ulong tag)
		{
			IntPtr channelObject = GetChannelObject(channel, tag, ulong.MaxValue);
			if (channelObject == IntPtr.Zero)
			{
				return false;
			}
			mystruct = (T)Marshal.PtrToStructure(channelObject, typeof(T));
			return true;
		}

		public static int AddStructToLocalChannel<T>(ref T mystruct, int channel, ulong tag)
		{
			GCHandle gCHandle = GCHandle.Alloc(mystruct, GCHandleType.Pinned);
			int result = AddObjectToChannel(channel, gCHandle.AddrOfPinnedObject(), Marshal.SizeOf(mystruct), tag);
			gCHandle.Free();
			return result;
		}

		public static void AddStructToFrame<T>(ref T mystruct, ulong tag)
		{
			GCHandle gCHandle = GCHandle.Alloc(mystruct, GCHandleType.Pinned);
			AddObjectToFrame(gCHandle.AddrOfPinnedObject(), Marshal.SizeOf(mystruct), tag);
			gCHandle.Free();
		}

		public static bool UpdateInputFrame(ref SDKInputFrame setframe)
		{
			if (_injection_SDKInputFrame.active && _injection_SDKInputFrame.action != null)
			{
				_injection_SDKInputFrame.action();
				setframe = _injection_SDKInputFrame.data;
			}
			else
			{
				GCHandle gCHandle = GCHandle.Alloc(setframe, GCHandleType.Pinned);
				IntPtr intPtr = updatinputframe(gCHandle.AddrOfPinnedObject());
				gCHandle.Free();
				if (intPtr == IntPtr.Zero)
				{
					setframe = SDKInputFrame.empty;
					return false;
				}
				setframe = (SDKInputFrame)Marshal.PtrToStructure(intPtr, typeof(SDKInputFrame));
				_injection_SDKInputFrame.data = setframe;
			}
			return true;
		}

		public static SDKTexture GetViewfinderTexture()
		{
			_ = SDKTexture.empty;
			IntPtr compositorChannelObject = GetCompositorChannelObject(11, Tag("OUTTEX"), ulong.MaxValue);
			if (compositorChannelObject == IntPtr.Zero)
			{
				return default(SDKTexture);
			}
			return (SDKTexture)Marshal.PtrToStructure(compositorChannelObject, typeof(SDKTexture));
		}

		public static void AddTexture(SDKTexture texture)
		{
			if (!_injection_DisableAddTexture)
			{
				string str = "";
				switch (texture.id)
				{
				case TEXTURE_ID.BACKGROUND_COLOR_BUFFER_ID:
					str = "BGCTEX";
					break;
				case TEXTURE_ID.FOREGROUND_COLOR_BUFFER_ID:
					str = "FGCTEX";
					break;
				case TEXTURE_ID.OPTIMIZED_COLOR_BUFFER_ID:
					str = "OPTTEX";
					break;
				}
				AddTexture(texture, Tag(str));
			}
		}

		public static void CreateFrame(SDKOutputFrame frame)
		{
			if (!_injection_DisableCreateFrame)
			{
				GCHandle gCHandle = GCHandle.Alloc(frame, GCHandleType.Pinned);
				AddObjectToFrame(gCHandle.AddrOfPinnedObject(), Marshal.SizeOf(frame), Tag("OUTFRAME"));
				gCHandle.Free();
			}
		}

		public static void SetGroundPlane(SDKPlane groundPlane)
		{
			AddStructToGlobalChannel(ref groundPlane, 2, Tag("SetGND"));
		}

		public static bool GetResolution(ref SDKResolution sdkResolution)
		{
			if (_injection_SDKResolution.active && _injection_SDKResolution.action != null)
			{
				_injection_SDKResolution.action();
				sdkResolution = _injection_SDKResolution.data;
				return true;
			}
			bool structFromLocalChannel = GetStructFromLocalChannel(ref sdkResolution, 15, Tag("SDKRes"));
			_injection_SDKResolution.data = sdkResolution;
			return structFromLocalChannel;
		}
	}
	public class SDKRender : IDisposable
	{
		private CommandBuffer _clipPlaneCommandBuffer;

		private CommandBuffer _combineAlphaCommandBuffer;

		private CommandBuffer _captureTextureCommandBuffer;

		private CommandBuffer _applyTextureCommandBuffer;

		private CommandBuffer _optimizedRenderingCommandBuffer;

		private CameraEvent _clipPlaneCameraEvent = CameraEvent.AfterForwardOpaque;

		private CameraEvent _clipPlaneCombineAlphaCameraEvent = CameraEvent.AfterEverything;

		private CameraEvent _captureTextureEvent = CameraEvent.BeforeImageEffects;

		private CameraEvent _applyTextureEvent = CameraEvent.AfterEverything;

		private CameraEvent _optimizedRenderingCameraEvent = CameraEvent.AfterEverything;

		private Mesh _clipPlaneMesh;

		private Material _clipPlaneSimpleMaterial;

		private Material _clipPlaneSimpleDebugMaterial;

		private Material _clipPlaneComplexMaterial;

		private Material _clipPlaneComplexDebugMaterial;

		private Material _writeOpaqueToAlphaMaterial;

		private Material _combineAlphaMaterial;

		private Material _writeMaterial;

		private Material _forceForwardRenderingMaterial;

		private RenderTexture _backgroundRenderTexture;

		private RenderTexture _foregroundRenderTexture;

		private RenderTexture _optimizedRenderTexture;

		private RenderTexture _complexClipPlaneRenderTexture;

		private LIV _liv;

		private SDKOutputFrame _outputFrame = SDKOutputFrame.empty;

		private SDKInputFrame _inputFrame = SDKInputFrame.empty;

		private SDKResolution _resolution = SDKResolution.zero;

		private Camera _cameraInstance;

		private SDKPose _requestedPose = SDKPose.empty;

		private int _requestedPoseFrameIndex;

		private bool useDeferredRendering
		{
			get
			{
				if (_cameraInstance.actualRenderingPath != RenderingPath.DeferredLighting)
				{
					return _cameraInstance.actualRenderingPath == RenderingPath.DeferredShading;
				}
				return true;
			}
		}

		private bool interlacedRendering => SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.INTERLACED_RENDER);

		private bool canRenderBackground
		{
			get
			{
				if (interlacedRendering && Time.frameCount % 2 != 0)
				{
					return false;
				}
				if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.BACKGROUND_RENDER))
				{
					return _backgroundRenderTexture != null;
				}
				return false;
			}
		}

		private bool canRenderForeground
		{
			get
			{
				if (interlacedRendering && Time.frameCount % 2 != 1)
				{
					return false;
				}
				if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.FOREGROUND_RENDER))
				{
					return _foregroundRenderTexture != null;
				}
				return false;
			}
		}

		private bool canRenderOptimized
		{
			get
			{
				if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.OPTIMIZED_RENDER))
				{
					return _optimizedRenderTexture != null;
				}
				return false;
			}
		}

		public LIV liv => _liv;

		public SDKOutputFrame outputFrame => _outputFrame;

		public SDKInputFrame inputFrame => _inputFrame;

		public SDKResolution resolution => _resolution;

		public Camera cameraInstance => _cameraInstance;

		public Camera cameraReference
		{
			get
			{
				if (!(_liv.MRCameraPrefab == null))
				{
					return _liv.MRCameraPrefab;
				}
				return _liv.HMDCamera;
			}
		}

		public Camera hmdCamera => _liv.HMDCamera;

		public Transform stage => _liv.stage;

		public Transform stageTransform => _liv.stageTransform;

		public Matrix4x4 stageLocalToWorldMatrix
		{
			get
			{
				if (!(_liv.stage == null))
				{
					return _liv.stage.localToWorldMatrix;
				}
				return Matrix4x4.identity;
			}
		}

		public Matrix4x4 localToWorldMatrix
		{
			get
			{
				if (!(_liv.stageTransform == null))
				{
					return _liv.stageTransform.localToWorldMatrix;
				}
				return stageLocalToWorldMatrix;
			}
		}

		public int spectatorLayerMask => _liv.spectatorLayerMask;

		public bool disableStandardAssets => _liv.disableStandardAssets;

		public bool canSetPose
		{
			get
			{
				if (_inputFrame.frameid == 0L)
				{
					return false;
				}
				return _inputFrame.priority.pose <= 63;
			}
		}

		private Material GetClipPlaneMaterial(bool debugClipPlane, bool complexClipPlane, ColorWriteMask colorWriteMask)
		{
			Material material;
			if (complexClipPlane)
			{
				material = (debugClipPlane ? _clipPlaneComplexDebugMaterial : _clipPlaneComplexMaterial);
				material.SetTexture(SDKShaders.LIV_CLIP_PLANE_HEIGHT_MAP_PROPERTY, _complexClipPlaneRenderTexture);
				material.SetFloat(SDKShaders.LIV_TESSELLATION_PROPERTY, _inputFrame.clipPlane.tesselation);
			}
			else
			{
				material = (debugClipPlane ? _clipPlaneSimpleDebugMaterial : _clipPlaneSimpleMaterial);
			}
			material.SetInt(SDKShaders.LIV_COLOR_MASK, (int)colorWriteMask);
			return material;
		}

		private Material GetGroundClipPlaneMaterial(bool debugClipPlane, ColorWriteMask colorWriteMask)
		{
			Material obj = (debugClipPlane ? _clipPlaneSimpleDebugMaterial : _clipPlaneSimpleMaterial);
			obj.SetInt(SDKShaders.LIV_COLOR_MASK, (int)colorWriteMask);
			return obj;
		}

		public SDKRender(LIV liv)
		{
			_liv = liv;
			CreateAssets();
		}

		public void Render()
		{
			UpdateBridgeResolution();
			UpdateBridgeInputFrame();
			SDKUtils.ApplyUserSpaceTransform(this);
			UpdateTextures();
			InvokePreRender();
			if (canRenderBackground)
			{
				RenderBackground();
			}
			if (canRenderForeground)
			{
				RenderForeground();
			}
			if (canRenderOptimized)
			{
				RenderOptimized();
			}
			IvokePostRender();
			SDKUtils.CreateBridgeOutputFrame(this);
			SDKBridge.IssuePluginEvent();
		}

		private void RenderBackground()
		{
			SDKUtils.SetCamera(_cameraInstance, _cameraInstance.transform, _inputFrame, localToWorldMatrix, spectatorLayerMask);
			_cameraInstance.targetTexture = _backgroundRenderTexture;
			RenderTexture renderTexture = null;
			bool num = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.OVERRIDE_POST_PROCESSING);
			if (num)
			{
				renderTexture = RenderTexture.GetTemporary(_backgroundRenderTexture.width, _backgroundRenderTexture.height, 0, _backgroundRenderTexture.format);
				_captureTextureCommandBuffer.Blit(BuiltinRenderTextureType.CurrentActive, renderTexture);
				_applyTextureCommandBuffer.Blit(renderTexture, BuiltinRenderTextureType.CurrentActive);
				_cameraInstance.AddCommandBuffer(_captureTextureEvent, _captureTextureCommandBuffer);
				_cameraInstance.AddCommandBuffer(_applyTextureEvent, _applyTextureCommandBuffer);
			}
			SDKShaders.StartRendering();
			SDKShaders.StartBackgroundRendering();
			InvokePreRenderBackground();
			SendTextureToBridge(_backgroundRenderTexture, TEXTURE_ID.BACKGROUND_COLOR_BUFFER_ID);
			_cameraInstance.Render();
			InvokePostRenderBackground();
			_cameraInstance.targetTexture = null;
			SDKShaders.StopBackgroundRendering();
			SDKShaders.StopRendering();
			if (num)
			{
				_cameraInstance.RemoveCommandBuffer(_captureTextureEvent, _captureTextureCommandBuffer);
				_cameraInstance.RemoveCommandBuffer(_applyTextureEvent, _applyTextureCommandBuffer);
				_captureTextureCommandBuffer.Clear();
				_applyTextureCommandBuffer.Clear();
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}

		private void RenderForeground()
		{
			bool debugClipPlane = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.DEBUG_CLIP_PLANE);
			bool complexClipPlane = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.COMPLEX_CLIP_PLANE);
			bool num = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.GROUND_CLIP_PLANE);
			bool flag = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.OVERRIDE_POST_PROCESSING);
			bool flag2 = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.FIX_FOREGROUND_ALPHA) | _liv.fixPostEffectsAlpha;
			MonoBehaviour[] behaviours = null;
			bool[] wasBehaviourEnabled = null;
			if (disableStandardAssets)
			{
				SDKUtils.DisableStandardAssets(_cameraInstance, ref behaviours, ref wasBehaviourEnabled);
			}
			CameraClearFlags clearFlags = _cameraInstance.clearFlags;
			Color backgroundColor = _cameraInstance.backgroundColor;
			Color fogColor = RenderSettings.fogColor;
			RenderSettings.fogColor = new Color(fogColor.r, fogColor.g, fogColor.b, 0f);
			SDKUtils.SetCamera(_cameraInstance, _cameraInstance.transform, _inputFrame, localToWorldMatrix, spectatorLayerMask);
			_cameraInstance.clearFlags = CameraClearFlags.Color;
			_cameraInstance.backgroundColor = Color.clear;
			_cameraInstance.targetTexture = _foregroundRenderTexture;
			RenderTexture temporary = RenderTexture.GetTemporary(_foregroundRenderTexture.width, _foregroundRenderTexture.height, 0, _foregroundRenderTexture.format);
			_clipPlaneCommandBuffer.DrawMesh(_clipPlaneMesh, Matrix4x4.identity, _writeOpaqueToAlphaMaterial, 0, 0);
			Matrix4x4 matrix = localToWorldMatrix * (Matrix4x4)_inputFrame.clipPlane.transform;
			_clipPlaneCommandBuffer.DrawMesh(_clipPlaneMesh, matrix, GetClipPlaneMaterial(debugClipPlane, complexClipPlane, ColorWriteMask.All), 0, 0);
			if (num)
			{
				Matrix4x4 matrix2 = localToWorldMatrix * (Matrix4x4)_inputFrame.groundClipPlane.transform;
				_clipPlaneCommandBuffer.DrawMesh(_clipPlaneMesh, matrix2, GetGroundClipPlaneMaterial(debugClipPlane, ColorWriteMask.All), 0, 0);
			}
			_clipPlaneCommandBuffer.Blit(BuiltinRenderTextureType.CurrentActive, temporary);
			_cameraInstance.AddCommandBuffer(_clipPlaneCameraEvent, _clipPlaneCommandBuffer);
			RenderTexture renderTexture = null;
			if (flag || flag2)
			{
				renderTexture = RenderTexture.GetTemporary(_foregroundRenderTexture.width, _foregroundRenderTexture.height, 0, _foregroundRenderTexture.format);
				_captureTextureCommandBuffer.Blit(BuiltinRenderTextureType.CurrentActive, renderTexture);
				_cameraInstance.AddCommandBuffer(_captureTextureEvent, _captureTextureCommandBuffer);
				_writeMaterial.SetInt(SDKShaders.LIV_COLOR_MASK, (!flag) ? 1 : 15);
				_applyTextureCommandBuffer.Blit(renderTexture, BuiltinRenderTextureType.CurrentActive, _writeMaterial);
				_cameraInstance.AddCommandBuffer(_applyTextureEvent, _applyTextureCommandBuffer);
			}
			_combineAlphaMaterial.SetInt(SDKShaders.LIV_COLOR_MASK, 1);
			_combineAlphaCommandBuffer.Blit(temporary, BuiltinRenderTextureType.CurrentActive, _combineAlphaMaterial);
			_cameraInstance.AddCommandBuffer(_clipPlaneCombineAlphaCameraEvent, _combineAlphaCommandBuffer);
			if (useDeferredRendering)
			{
				SDKUtils.ForceForwardRendering(cameraInstance, _clipPlaneMesh, _forceForwardRenderingMaterial);
			}
			SDKShaders.StartRendering();
			SDKShaders.StartForegroundRendering();
			InvokePreRenderForeground();
			SendTextureToBridge(_foregroundRenderTexture, TEXTURE_ID.FOREGROUND_COLOR_BUFFER_ID);
			_cameraInstance.Render();
			InvokePostRenderForeground();
			_cameraInstance.targetTexture = null;
			SDKShaders.StopForegroundRendering();
			SDKShaders.StopRendering();
			if (flag || flag2)
			{
				_cameraInstance.RemoveCommandBuffer(_captureTextureEvent, _captureTextureCommandBuffer);
				_cameraInstance.RemoveCommandBuffer(_applyTextureEvent, _applyTextureCommandBuffer);
				_captureTextureCommandBuffer.Clear();
				_applyTextureCommandBuffer.Clear();
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			_cameraInstance.RemoveCommandBuffer(_clipPlaneCameraEvent, _clipPlaneCommandBuffer);
			_cameraInstance.RemoveCommandBuffer(_clipPlaneCombineAlphaCameraEvent, _combineAlphaCommandBuffer);
			RenderTexture.ReleaseTemporary(temporary);
			_clipPlaneCommandBuffer.Clear();
			_combineAlphaCommandBuffer.Clear();
			_cameraInstance.clearFlags = clearFlags;
			_cameraInstance.backgroundColor = backgroundColor;
			RenderSettings.fogColor = fogColor;
			SDKUtils.RestoreStandardAssets(ref behaviours, ref wasBehaviourEnabled);
		}

		private void RenderOptimized()
		{
			bool debugClipPlane = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.DEBUG_CLIP_PLANE);
			bool complexClipPlane = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.COMPLEX_CLIP_PLANE);
			bool num = SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.GROUND_CLIP_PLANE);
			SDKUtils.SetCamera(_cameraInstance, _cameraInstance.transform, _inputFrame, localToWorldMatrix, spectatorLayerMask);
			_cameraInstance.targetTexture = _optimizedRenderTexture;
			_writeMaterial.SetInt(SDKShaders.LIV_COLOR_MASK, 1);
			_optimizedRenderingCommandBuffer.Blit(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CurrentActive, _writeMaterial);
			_writeOpaqueToAlphaMaterial.SetInt(SDKShaders.LIV_COLOR_MASK, 1);
			_optimizedRenderingCommandBuffer.DrawMesh(_clipPlaneMesh, Matrix4x4.identity, _writeOpaqueToAlphaMaterial, 0, 0);
			Matrix4x4 matrix = localToWorldMatrix * (Matrix4x4)_inputFrame.clipPlane.transform;
			_optimizedRenderingCommandBuffer.DrawMesh(_clipPlaneMesh, matrix, GetClipPlaneMaterial(debugClipPlane, complexClipPlane, ColorWriteMask.Alpha), 0, 0);
			if (num)
			{
				Matrix4x4 matrix2 = localToWorldMatrix * (Matrix4x4)_inputFrame.groundClipPlane.transform;
				_optimizedRenderingCommandBuffer.DrawMesh(_clipPlaneMesh, matrix2, GetGroundClipPlaneMaterial(debugClipPlane, ColorWriteMask.Alpha), 0, 0);
			}
			_cameraInstance.AddCommandBuffer(CameraEvent.AfterEverything, _optimizedRenderingCommandBuffer);
			SDKShaders.StartRendering();
			SDKShaders.StartBackgroundRendering();
			InvokePreRenderBackground();
			SendTextureToBridge(_optimizedRenderTexture, TEXTURE_ID.OPTIMIZED_COLOR_BUFFER_ID);
			_cameraInstance.Render();
			InvokePostRenderBackground();
			_cameraInstance.targetTexture = null;
			SDKShaders.StopBackgroundRendering();
			SDKShaders.StopRendering();
			_cameraInstance.RemoveCommandBuffer(CameraEvent.AfterEverything, _optimizedRenderingCommandBuffer);
			_optimizedRenderingCommandBuffer.Clear();
		}

		private void CreateAssets()
		{
			bool enabled = cameraReference.enabled;
			if (enabled)
			{
				cameraReference.enabled = false;
			}
			bool activeSelf = cameraReference.gameObject.activeSelf;
			if (activeSelf)
			{
				cameraReference.gameObject.SetActive(value: false);
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(cameraReference.gameObject, _liv.stage);
			_cameraInstance = (Camera)gameObject.GetComponent("Camera");
			SDKUtils.CleanCameraBehaviours(_cameraInstance, _liv.excludeBehaviours);
			if (activeSelf != cameraReference.gameObject.activeSelf)
			{
				cameraReference.gameObject.SetActive(activeSelf);
			}
			if (enabled != cameraReference.enabled)
			{
				cameraReference.enabled = enabled;
			}
			_cameraInstance.name = "LIV Camera";
			if (_cameraInstance.tag == "MainCamera")
			{
				_cameraInstance.tag = "Untagged";
			}
			_cameraInstance.transform.localScale = Vector3.one;
			_cameraInstance.rect = new Rect(0f, 0f, 1f, 1f);
			_cameraInstance.depth = 0f;
			_cameraInstance.stereoTargetEye = StereoTargetEyeMask.None;
			_cameraInstance.allowMSAA = false;
			_cameraInstance.enabled = false;
			_cameraInstance.gameObject.SetActive(value: true);
			_clipPlaneMesh = new Mesh();
			SDKUtils.CreateClipPlane(_clipPlaneMesh, 10, 10, useQuads: true, 1000f);
			_clipPlaneSimpleMaterial = new Material(Shader.Find("Hidden/LIV_ClipPlaneSimple"));
			_clipPlaneSimpleDebugMaterial = new Material(Shader.Find("Hidden/LIV_ClipPlaneSimpleDebug"));
			_clipPlaneComplexMaterial = new Material(Shader.Find("Hidden/LIV_ClipPlaneComplex"));
			_clipPlaneComplexDebugMaterial = new Material(Shader.Find("Hidden/LIV_ClipPlaneComplexDebug"));
			_writeOpaqueToAlphaMaterial = new Material(Shader.Find("Hidden/LIV_WriteOpaqueToAlpha"));
			_combineAlphaMaterial = new Material(Shader.Find("Hidden/LIV_CombineAlpha"));
			_writeMaterial = new Material(Shader.Find("Hidden/LIV_Write"));
			_forceForwardRenderingMaterial = new Material(Shader.Find("Hidden/LIV_ForceForwardRendering"));
			_clipPlaneCommandBuffer = new CommandBuffer();
			_combineAlphaCommandBuffer = new CommandBuffer();
			_captureTextureCommandBuffer = new CommandBuffer();
			_applyTextureCommandBuffer = new CommandBuffer();
			_optimizedRenderingCommandBuffer = new CommandBuffer();
		}

		private void DestroyAssets()
		{
			if (_cameraInstance != null)
			{
				UnityEngine.Object.Destroy(_cameraInstance.gameObject);
				_cameraInstance = null;
			}
			SDKUtils.DestroyObject(ref _clipPlaneMesh);
			SDKUtils.DestroyObject(ref _clipPlaneSimpleMaterial);
			SDKUtils.DestroyObject(ref _clipPlaneSimpleDebugMaterial);
			SDKUtils.DestroyObject(ref _clipPlaneComplexMaterial);
			SDKUtils.DestroyObject(ref _clipPlaneComplexDebugMaterial);
			SDKUtils.DestroyObject(ref _writeOpaqueToAlphaMaterial);
			SDKUtils.DestroyObject(ref _combineAlphaMaterial);
			SDKUtils.DestroyObject(ref _writeMaterial);
			SDKUtils.DestroyObject(ref _forceForwardRenderingMaterial);
			SDKUtils.DisposeObject(ref _clipPlaneCommandBuffer);
			SDKUtils.DisposeObject(ref _combineAlphaCommandBuffer);
			SDKUtils.DisposeObject(ref _captureTextureCommandBuffer);
			SDKUtils.DisposeObject(ref _applyTextureCommandBuffer);
			SDKUtils.DisposeObject(ref _optimizedRenderingCommandBuffer);
		}

		public void Dispose()
		{
			ReleaseBridgePoseControl();
			DestroyAssets();
			SDKUtils.DestroyTexture(ref _backgroundRenderTexture);
			SDKUtils.DestroyTexture(ref _foregroundRenderTexture);
			SDKUtils.DestroyTexture(ref _optimizedRenderTexture);
			SDKUtils.DestroyTexture(ref _complexClipPlaneRenderTexture);
		}

		public bool SetPose(Vector3 position, Quaternion rotation, float verticalFieldOfView = 60f, bool useLocalSpace = false)
		{
			if (_inputFrame.frameid == 0L)
			{
				return false;
			}
			SDKPose pose = _inputFrame.pose;
			float aspect = 1f;
			if (_resolution.height > 0)
			{
				aspect = (float)_resolution.width / (float)_resolution.height;
			}
			if (!useLocalSpace)
			{
				Matrix4x4 matrix = Matrix4x4.identity;
				Transform transform = ((stageTransform == null) ? stage : stageTransform);
				if (transform != null)
				{
					matrix = transform.worldToLocalMatrix;
				}
				position = matrix.MultiplyPoint(position);
				rotation = SDKUtils.RotateQuaternionByMatrix(matrix, rotation);
			}
			_requestedPose = new SDKPose
			{
				localPosition = position,
				localRotation = rotation,
				verticalFieldOfView = verticalFieldOfView,
				projectionMatrix = Matrix4x4.Perspective(verticalFieldOfView, aspect, pose.nearClipPlane, pose.farClipPlane)
			};
			_requestedPoseFrameIndex = Time.frameCount;
			return _inputFrame.priority.pose <= 63;
		}

		public void SetGroundPlane(float distance, Vector3 normal, bool useLocalSpace = false)
		{
			float distance2 = distance;
			Vector3 vector = normal;
			if (!useLocalSpace)
			{
				Matrix4x4 worldToLocalMatrix = ((stageTransform == null) ? stage : stageTransform).worldToLocalMatrix;
				Vector3 rhs = worldToLocalMatrix.MultiplyPoint(normal * distance);
				vector = worldToLocalMatrix.MultiplyVector(normal);
				distance2 = 0f - Vector3.Dot(normal, rhs);
			}
			SDKPlane groundPlane = default(SDKPlane);
			groundPlane.distance = distance2;
			groundPlane.normal = vector;
			SDKBridge.SetGroundPlane(groundPlane);
		}

		public void SetGroundPlane(Plane plane, bool useLocalSpace = false)
		{
			SetGroundPlane(plane.distance, plane.normal, useLocalSpace);
		}

		public void SetGroundPlane(Transform transform, bool useLocalSpace = false)
		{
			if (!(transform == null))
			{
				Quaternion obj = (useLocalSpace ? transform.localRotation : transform.rotation);
				Vector3 rhs = (useLocalSpace ? transform.localPosition : transform.position);
				Vector3 vector = obj * Vector3.up;
				SetGroundPlane(0f - Vector3.Dot(vector, rhs), vector, useLocalSpace);
			}
		}

		private void ReleaseBridgePoseControl()
		{
			_inputFrame.ReleaseControl();
			SDKBridge.UpdateInputFrame(ref _inputFrame);
		}

		private void UpdateBridgeResolution()
		{
			SDKBridge.GetResolution(ref _resolution);
		}

		private void UpdateBridgeInputFrame()
		{
			if (_requestedPoseFrameIndex == Time.frameCount)
			{
				_inputFrame.ObtainControl();
				_inputFrame.pose = _requestedPose;
				_requestedPose = SDKPose.empty;
			}
			else
			{
				_inputFrame.ReleaseControl();
			}
			if (_cameraInstance != null)
			{
				_inputFrame.pose.nearClipPlane = _cameraInstance.nearClipPlane;
				_inputFrame.pose.farClipPlane = _cameraInstance.farClipPlane;
			}
			SDKBridge.UpdateInputFrame(ref _inputFrame);
		}

		private void InvokePreRender()
		{
			if (_liv.onPreRender != null)
			{
				_liv.onPreRender(this);
			}
		}

		private void IvokePostRender()
		{
			if (_liv.onPostRender != null)
			{
				_liv.onPostRender(this);
			}
		}

		private void InvokePreRenderBackground()
		{
			if (_liv.onPreRenderBackground != null)
			{
				_liv.onPreRenderBackground(this);
			}
		}

		private void InvokePostRenderBackground()
		{
			if (_liv.onPostRenderBackground != null)
			{
				_liv.onPostRenderBackground(this);
			}
		}

		private void InvokePreRenderForeground()
		{
			if (_liv.onPreRenderForeground != null)
			{
				_liv.onPreRenderForeground(this);
			}
		}

		private void InvokePostRenderForeground()
		{
			if (_liv.onPostRenderForeground != null)
			{
				_liv.onPostRenderForeground(this);
			}
		}

		private void CreateBackgroundTexture()
		{
			if (!SDKUtils.CreateTexture(ref _backgroundRenderTexture, _resolution.width, _resolution.height, 24, RenderTextureFormat.ARGB32))
			{
				UnityEngine.Debug.LogError("LIV: Unable to create background texture!");
			}
		}

		private void CreateForegroundTexture()
		{
			if (!SDKUtils.CreateTexture(ref _foregroundRenderTexture, _resolution.width, _resolution.height, 24, RenderTextureFormat.ARGB32))
			{
				UnityEngine.Debug.LogError("LIV: Unable to create foreground texture!");
			}
		}

		private void CreateOptimizedTexture()
		{
			if (!SDKUtils.CreateTexture(ref _optimizedRenderTexture, _resolution.width, _resolution.height, 24, RenderTextureFormat.ARGB32))
			{
				UnityEngine.Debug.LogError("LIV: Unable to create optimized texture!");
			}
		}

		private void CreateComplexClipPlaneTexture()
		{
			if (!SDKUtils.CreateTexture(ref _complexClipPlaneRenderTexture, _inputFrame.clipPlane.width, _inputFrame.clipPlane.height, 0, RenderTextureFormat.ARGB32))
			{
				UnityEngine.Debug.LogError("LIV: Unable to create complex clip plane texture!");
			}
		}

		private void UpdateTextures()
		{
			if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.BACKGROUND_RENDER))
			{
				if (_backgroundRenderTexture == null || _backgroundRenderTexture.width != _resolution.width || _backgroundRenderTexture.height != _resolution.height)
				{
					CreateBackgroundTexture();
				}
			}
			else
			{
				SDKUtils.DestroyTexture(ref _backgroundRenderTexture);
			}
			if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.FOREGROUND_RENDER))
			{
				if (_foregroundRenderTexture == null || _foregroundRenderTexture.width != _resolution.width || _foregroundRenderTexture.height != _resolution.height)
				{
					CreateForegroundTexture();
				}
			}
			else
			{
				SDKUtils.DestroyTexture(ref _foregroundRenderTexture);
			}
			if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.OPTIMIZED_RENDER))
			{
				if (_optimizedRenderTexture == null || _optimizedRenderTexture.width != _resolution.width || _optimizedRenderTexture.height != _resolution.height)
				{
					CreateOptimizedTexture();
				}
			}
			else
			{
				SDKUtils.DestroyTexture(ref _optimizedRenderTexture);
			}
			if (SDKUtils.FeatureEnabled(inputFrame.features, FEATURES.COMPLEX_CLIP_PLANE))
			{
				if (_complexClipPlaneRenderTexture == null || _complexClipPlaneRenderTexture.width != _inputFrame.clipPlane.width || _complexClipPlaneRenderTexture.height != _inputFrame.clipPlane.height)
				{
					CreateComplexClipPlaneTexture();
				}
			}
			else
			{
				SDKUtils.DestroyTexture(ref _complexClipPlaneRenderTexture);
			}
		}

		private void SendTextureToBridge(RenderTexture texture, TEXTURE_ID id)
		{
			SDKTexture texture2 = default(SDKTexture);
			texture2.id = id;
			texture2.texturePtr = texture.GetNativeTexturePtr();
			texture2.SharedHandle = IntPtr.Zero;
			texture2.device = SDKUtils.GetDevice();
			texture2.dummy = 0;
			texture2.type = TEXTURE_TYPE.COLOR_BUFFER;
			texture2.format = TEXTURE_FORMAT.ARGB32;
			texture2.colorSpace = SDKUtils.GetColorSpace(texture);
			texture2.width = texture.width;
			texture2.height = texture.height;
			SDKBridge.AddTexture(texture2);
		}
	}
	internal static class SDKShaders
	{
		public static readonly int LIV_COLOR_MASK = Shader.PropertyToID("_LivColorMask");

		public static readonly int LIV_TESSELLATION_PROPERTY = Shader.PropertyToID("_LivTessellation");

		public static readonly int LIV_CLIP_PLANE_HEIGHT_MAP_PROPERTY = Shader.PropertyToID("_LivClipPlaneHeightMap");

		public const string LIV_MR_FOREGROUND_KEYWORD = "LIV_MR_FOREGROUND";

		public const string LIV_MR_BACKGROUND_KEYWORD = "LIV_MR_BACKGROUND";

		public const string LIV_MR_KEYWORD = "LIV_MR";

		public const string LIV_CLIP_PLANE_SIMPLE_SHADER = "Hidden/LIV_ClipPlaneSimple";

		public const string LIV_CLIP_PLANE_SIMPLE_DEBUG_SHADER = "Hidden/LIV_ClipPlaneSimpleDebug";

		public const string LIV_CLIP_PLANE_COMPLEX_SHADER = "Hidden/LIV_ClipPlaneComplex";

		public const string LIV_CLIP_PLANE_COMPLEX_DEBUG_SHADER = "Hidden/LIV_ClipPlaneComplexDebug";

		public const string LIV_WRITE_OPAQUE_TO_ALPHA_SHADER = "Hidden/LIV_WriteOpaqueToAlpha";

		public const string LIV_COMBINE_ALPHA_SHADER = "Hidden/LIV_CombineAlpha";

		public const string LIV_WRITE_SHADER = "Hidden/LIV_Write";

		public const string LIV_FORCE_FORWARD_RENDERING_SHADER = "Hidden/LIV_ForceForwardRendering";

		public static void StartRendering()
		{
			Shader.EnableKeyword("LIV_MR");
		}

		public static void StopRendering()
		{
			Shader.DisableKeyword("LIV_MR");
		}

		public static void StartForegroundRendering()
		{
			Shader.EnableKeyword("LIV_MR_FOREGROUND");
		}

		public static void StopForegroundRendering()
		{
			Shader.DisableKeyword("LIV_MR_FOREGROUND");
		}

		public static void StartBackgroundRendering()
		{
			Shader.EnableKeyword("LIV_MR_BACKGROUND");
		}

		public static void StopBackgroundRendering()
		{
			Shader.DisableKeyword("LIV_MR_BACKGROUND");
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct SDKConstants
	{
		public const string SDK_ID = "6QIB2VZ4URNC6VZIKU0ZIJX2GWBSU0S3";

		public const string SDK_VERSION = "1.5.4";

		public const string ENGINE_NAME = "unity";
	}
	public enum PRIORITY : sbyte
	{
		NONE = 0,
		GAME = 63
	}
	[Flags]
	public enum FEATURES : ulong
	{
		NONE = 0uL,
		BACKGROUND_RENDER = 1uL,
		FOREGROUND_RENDER = 2uL,
		COMPLEX_CLIP_PLANE = 4uL,
		BACKGROUND_DEPTH_RENDER = 8uL,
		OVERRIDE_POST_PROCESSING = 0x10uL,
		FIX_FOREGROUND_ALPHA = 0x20uL,
		GROUND_CLIP_PLANE = 0x40uL,
		RELEASE_CONTROL = 0x8000uL,
		OPTIMIZED_RENDER = 0x10000000uL,
		INTERLACED_RENDER = 0x20000000uL,
		DEBUG_CLIP_PLANE = 0x1000000000000uL
	}
	public enum TEXTURE_ID : uint
	{
		UNDEFINED = 0u,
		BACKGROUND_COLOR_BUFFER_ID = 10u,
		FOREGROUND_COLOR_BUFFER_ID = 20u,
		OPTIMIZED_COLOR_BUFFER_ID = 30u
	}
	public enum TEXTURE_TYPE : uint
	{
		UNDEFINED,
		COLOR_BUFFER
	}
	public enum TEXTURE_FORMAT : uint
	{
		UNDEFINED = 0u,
		ARGB32 = 10u
	}
	public enum TEXTURE_DEVICE : uint
	{
		UNDEFINED,
		RAW,
		DIRECTX,
		OPENGL,
		VULKAN,
		METAL
	}
	public enum TEXTURE_COLOR_SPACE : uint
	{
		UNDEFINED,
		LINEAR,
		SRGB
	}
	public enum RENDERING_PIPELINE : uint
	{
		UNDEFINED,
		FORWARD,
		DEFERRED,
		VERTEX_LIT,
		UNIVERSAL,
		HIGH_DEFINITION
	}
	public struct SDKResolution
	{
		public int width;

		public int height;

		public static SDKResolution zero
		{
			get
			{
				SDKResolution result = default(SDKResolution);
				result.width = 0;
				result.height = 0;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKResolution:\r\nwidth: {width}\r\nheight: {height}";
		}
	}
	public struct SDKVector3
	{
		public float x;

		public float y;

		public float z;

		public static SDKVector3 zero
		{
			get
			{
				SDKVector3 result = default(SDKVector3);
				result.x = 0f;
				result.y = 0f;
				result.z = 0f;
				return result;
			}
		}

		public static SDKVector3 one
		{
			get
			{
				SDKVector3 result = default(SDKVector3);
				result.x = 1f;
				result.y = 1f;
				result.z = 1f;
				return result;
			}
		}

		public static SDKVector3 forward
		{
			get
			{
				SDKVector3 result = default(SDKVector3);
				result.x = 0f;
				result.y = 0f;
				result.z = 1f;
				return result;
			}
		}

		public static SDKVector3 up
		{
			get
			{
				SDKVector3 result = default(SDKVector3);
				result.x = 0f;
				result.y = 1f;
				result.z = 0f;
				return result;
			}
		}

		public static SDKVector3 right
		{
			get
			{
				SDKVector3 result = default(SDKVector3);
				result.x = 1f;
				result.y = 0f;
				result.z = 0f;
				return result;
			}
		}

		public static implicit operator Vector3(SDKVector3 v)
		{
			return new Vector3(v.x, v.y, v.z);
		}

		public static implicit operator SDKVector3(Vector3 v)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = v.x;
			result.y = v.y;
			result.z = v.z;
			return result;
		}

		public static SDKVector3 operator +(SDKVector3 lhs, SDKVector3 rhs)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = lhs.x + rhs.x;
			result.y = lhs.y + rhs.y;
			result.z = lhs.z + rhs.z;
			return result;
		}

		public static SDKVector3 operator -(SDKVector3 lhs, SDKVector3 rhs)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = lhs.x - rhs.x;
			result.y = lhs.y - rhs.y;
			result.z = lhs.z - rhs.z;
			return result;
		}

		public static SDKVector3 operator *(SDKVector3 lhs, SDKVector3 rhs)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = lhs.x * rhs.x;
			result.y = lhs.y * rhs.y;
			result.z = lhs.z * rhs.z;
			return result;
		}

		public static SDKVector3 operator *(SDKVector3 lhs, float rhs)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = lhs.x * rhs;
			result.y = lhs.y * rhs;
			result.z = lhs.z * rhs;
			return result;
		}

		public override string ToString()
		{
			return $"SDKVector3:\r\nx: {x}\r\ny: {y}\r\nz: {z}";
		}
	}
	public struct SDKQuaternion
	{
		public float x;

		public float y;

		public float z;

		public float w;

		public static SDKQuaternion identity
		{
			get
			{
				SDKQuaternion result = default(SDKQuaternion);
				result.x = 0f;
				result.y = 0f;
				result.z = 0f;
				result.w = 1f;
				return result;
			}
		}

		public static implicit operator Quaternion(SDKQuaternion v)
		{
			return new Quaternion(v.x, v.y, v.z, v.w);
		}

		public static implicit operator SDKQuaternion(Quaternion v)
		{
			SDKQuaternion result = default(SDKQuaternion);
			result.x = v.x;
			result.y = v.y;
			result.z = v.z;
			result.w = v.w;
			return result;
		}

		public static SDKQuaternion Euler(float pitch, float yaw, float roll)
		{
			float f = roll * 0.5f;
			float num = Mathf.Sin(f);
			float num2 = Mathf.Cos(f);
			float f2 = pitch * 0.5f;
			float num3 = Mathf.Sin(f2);
			float num4 = Mathf.Cos(f2);
			float f3 = yaw * 0.5f;
			float num5 = Mathf.Sin(f3);
			float num6 = Mathf.Cos(f3);
			float num7 = num6 * num4 * num2 + num5 * num3 * num;
			float num8 = num6 * num3 * num2 + num5 * num4 * num;
			float num9 = num5 * num4 * num2 - num6 * num3 * num;
			float num10 = num6 * num4 * num - num5 * num3 * num2;
			SDKQuaternion result = default(SDKQuaternion);
			result.x = num8;
			result.y = num9;
			result.z = num10;
			result.w = num7;
			return result;
		}

		public static SDKQuaternion operator *(SDKQuaternion lhs, SDKQuaternion rhs)
		{
			float num = lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y;
			float num2 = lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z;
			float num3 = lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x;
			float num4 = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
			SDKQuaternion result = default(SDKQuaternion);
			result.x = num;
			result.y = num2;
			result.z = num3;
			result.w = num4;
			return result;
		}

		public static SDKVector3 operator *(SDKQuaternion lhs, SDKVector3 rhs)
		{
			float num = lhs.x * 2f;
			float num2 = lhs.y * 2f;
			float num3 = lhs.z * 2f;
			float num4 = lhs.x * num;
			float num5 = lhs.y * num2;
			float num6 = lhs.z * num3;
			float num7 = lhs.x * num2;
			float num8 = lhs.x * num3;
			float num9 = lhs.y * num3;
			float num10 = lhs.w * num;
			float num11 = lhs.w * num2;
			float num12 = lhs.w * num3;
			SDKVector3 result = default(SDKVector3);
			result.x = (1f - (num5 + num6)) * rhs.x + (num7 - num12) * rhs.y + (num8 + num11) * rhs.z;
			result.y = (num7 + num12) * rhs.x + (1f - (num4 + num6)) * rhs.y + (num9 - num10) * rhs.z;
			result.z = (num8 - num11) * rhs.x + (num9 + num10) * rhs.y + (1f - (num4 + num5)) * rhs.z;
			return result;
		}

		public override string ToString()
		{
			return $"SDKQuaternion:\r\nx: {x}\r\ny: {y}\r\nz: {z}\r\nw: {w}";
		}
	}
	public struct SDKMatrix4x4
	{
		public float m00;

		public float m01;

		public float m02;

		public float m03;

		public float m10;

		public float m11;

		public float m12;

		public float m13;

		public float m20;

		public float m21;

		public float m22;

		public float m23;

		public float m30;

		public float m31;

		public float m32;

		public float m33;

		public static SDKMatrix4x4 identity
		{
			get
			{
				SDKMatrix4x4 result = default(SDKMatrix4x4);
				result.m00 = 1f;
				result.m01 = 0f;
				result.m02 = 0f;
				result.m03 = 0f;
				result.m10 = 0f;
				result.m11 = 1f;
				result.m12 = 0f;
				result.m13 = 0f;
				result.m20 = 0f;
				result.m21 = 0f;
				result.m22 = 1f;
				result.m23 = 0f;
				result.m30 = 0f;
				result.m31 = 0f;
				result.m32 = 0f;
				result.m33 = 1f;
				return result;
			}
		}

		public static implicit operator Matrix4x4(SDKMatrix4x4 v)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.m00 = v.m00;
			result.m01 = v.m01;
			result.m02 = v.m02;
			result.m03 = v.m03;
			result.m10 = v.m10;
			result.m11 = v.m11;
			result.m12 = v.m12;
			result.m13 = v.m13;
			result.m20 = v.m20;
			result.m21 = v.m21;
			result.m22 = v.m22;
			result.m23 = v.m23;
			result.m30 = v.m30;
			result.m31 = v.m31;
			result.m32 = v.m32;
			result.m33 = v.m33;
			return result;
		}

		public static implicit operator SDKMatrix4x4(Matrix4x4 v)
		{
			SDKMatrix4x4 result = default(SDKMatrix4x4);
			result.m00 = v.m00;
			result.m01 = v.m01;
			result.m02 = v.m02;
			result.m03 = v.m03;
			result.m10 = v.m10;
			result.m11 = v.m11;
			result.m12 = v.m12;
			result.m13 = v.m13;
			result.m20 = v.m20;
			result.m21 = v.m21;
			result.m22 = v.m22;
			result.m23 = v.m23;
			result.m30 = v.m30;
			result.m31 = v.m31;
			result.m32 = v.m32;
			result.m33 = v.m33;
			return result;
		}

		public static SDKMatrix4x4 Perspective(float vFov, float aspect, float zNear, float zFar)
		{
			float num = vFov * ((float)Math.PI / 180f);
			float num2 = 2f * Mathf.Atan(Mathf.Tan(num * 0.5f) * aspect);
			float num3 = 1f / Mathf.Tan(num2 * 0.5f);
			float num4 = 1f / Mathf.Tan(num * 0.5f);
			float num5 = (zFar + zNear) / (zNear - zFar);
			float num6 = 2f * (zFar * zNear) / (zNear - zFar);
			SDKMatrix4x4 result = default(SDKMatrix4x4);
			result.m00 = num3;
			result.m01 = 0f;
			result.m02 = 0f;
			result.m03 = 0f;
			result.m10 = 0f;
			result.m11 = num4;
			result.m12 = 0f;
			result.m13 = 0f;
			result.m20 = 0f;
			result.m21 = 0f;
			result.m22 = num5;
			result.m23 = num6;
			result.m30 = 0f;
			result.m31 = 0f;
			result.m32 = -1f;
			result.m33 = 0f;
			return result;
		}

		public static SDKMatrix4x4 operator *(SDKMatrix4x4 lhs, SDKMatrix4x4 rhs)
		{
			SDKMatrix4x4 result = identity;
			result.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10 + lhs.m02 * rhs.m20 + lhs.m03 * rhs.m30;
			result.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11 + lhs.m02 * rhs.m21 + lhs.m03 * rhs.m31;
			result.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02 * rhs.m22 + lhs.m03 * rhs.m32;
			result.m03 = lhs.m00 * rhs.m03 + lhs.m01 * rhs.m13 + lhs.m02 * rhs.m23 + lhs.m03 * rhs.m33;
			result.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10 + lhs.m12 * rhs.m20 + lhs.m13 * rhs.m30;
			result.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11 + lhs.m12 * rhs.m21 + lhs.m13 * rhs.m31;
			result.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12 * rhs.m22 + lhs.m13 * rhs.m32;
			result.m13 = lhs.m10 * rhs.m03 + lhs.m11 * rhs.m13 + lhs.m12 * rhs.m23 + lhs.m13 * rhs.m33;
			result.m20 = lhs.m20 * rhs.m00 + lhs.m21 * rhs.m10 + lhs.m22 * rhs.m20 + lhs.m23 * rhs.m30;
			result.m21 = lhs.m20 * rhs.m01 + lhs.m21 * rhs.m11 + lhs.m22 * rhs.m21 + lhs.m23 * rhs.m31;
			result.m22 = lhs.m20 * rhs.m02 + lhs.m21 * rhs.m12 + lhs.m22 * rhs.m22 + lhs.m23 * rhs.m32;
			result.m23 = lhs.m20 * rhs.m03 + lhs.m21 * rhs.m13 + lhs.m22 * rhs.m23 + lhs.m23 * rhs.m33;
			result.m30 = lhs.m30 * rhs.m00 + lhs.m31 * rhs.m10 + lhs.m32 * rhs.m20 + lhs.m33 * rhs.m30;
			result.m31 = lhs.m30 * rhs.m01 + lhs.m31 * rhs.m11 + lhs.m32 * rhs.m21 + lhs.m33 * rhs.m31;
			result.m32 = lhs.m30 * rhs.m02 + lhs.m31 * rhs.m12 + lhs.m32 * rhs.m22 + lhs.m33 * rhs.m32;
			result.m33 = lhs.m30 * rhs.m03 + lhs.m31 * rhs.m13 + lhs.m32 * rhs.m23 + lhs.m33 * rhs.m33;
			return result;
		}

		public static SDKVector3 operator *(SDKMatrix4x4 lhs, SDKVector3 rhs)
		{
			SDKVector3 result = default(SDKVector3);
			result.x = lhs.m00 * rhs.x + lhs.m01 * rhs.y + lhs.m02 * rhs.z;
			result.y = lhs.m10 * rhs.x + lhs.m11 * rhs.y + lhs.m12 * rhs.z;
			result.z = lhs.m20 * rhs.x + lhs.m21 * rhs.y + lhs.m22 * rhs.z;
			return result;
		}

		public static SDKMatrix4x4 Translate(SDKVector3 value)
		{
			SDKMatrix4x4 result = default(SDKMatrix4x4);
			result.m00 = 1f;
			result.m01 = 0f;
			result.m02 = 0f;
			result.m03 = value.x;
			result.m10 = 0f;
			result.m11 = 1f;
			result.m12 = 0f;
			result.m13 = value.y;
			result.m20 = 0f;
			result.m21 = 0f;
			result.m22 = 1f;
			result.m23 = value.z;
			result.m30 = 0f;
			result.m31 = 0f;
			result.m32 = 0f;
			result.m33 = 1f;
			return result;
		}

		public static SDKMatrix4x4 Rotate(SDKQuaternion value)
		{
			float x = value.x;
			float y = value.y;
			float z = value.z;
			float w = value.w;
			SDKMatrix4x4 result = default(SDKMatrix4x4);
			result.m00 = 1f - 2f * y * y - 2f * z * z;
			result.m01 = 2f * x * y - 2f * z * w;
			result.m02 = 2f * x * z + 2f * y * w;
			result.m03 = 0f;
			result.m10 = 2f * x * y + 2f * z * w;
			result.m11 = 1f - 2f * x * x - 2f * z * z;
			result.m12 = 2f * y * z - 2f * x * w;
			result.m13 = 0f;
			result.m20 = 2f * x * z - 2f * y * w;
			result.m21 = 2f * y * z + 2f * x * w;
			result.m22 = 1f - 2f * x * x - 2f * y * y;
			result.m23 = 0f;
			result.m30 = 0f;
			result.m31 = 0f;
			result.m32 = 0f;
			result.m33 = 1f;
			return result;
		}

		public static SDKMatrix4x4 Scale(SDKVector3 value)
		{
			SDKMatrix4x4 result = default(SDKMatrix4x4);
			result.m00 = value.x;
			result.m01 = 0f;
			result.m02 = 0f;
			result.m03 = 0f;
			result.m10 = 0f;
			result.m11 = value.y;
			result.m12 = 0f;
			result.m13 = 0f;
			result.m20 = 0f;
			result.m21 = 0f;
			result.m22 = value.z;
			result.m23 = 0f;
			result.m30 = 0f;
			result.m31 = 0f;
			result.m32 = 0f;
			result.m33 = 1f;
			return result;
		}

		public static SDKMatrix4x4 TRS(SDKVector3 translation, SDKQuaternion rotation, SDKVector3 scale)
		{
			return Translate(translation) * Rotate(rotation) * Scale(scale);
		}

		public override string ToString()
		{
			return $"Matrix4x4:\r\n{m00} {m01} {m02} {m03}\r\n{m10} {m11} {m12} {m13}\r\n{m20} {m21} {m22} {m23}\r\n{m30} {m31} {m32} {m33}";
		}
	}
	public struct SDKPlane
	{
		public float distance;

		public SDKVector3 normal;

		public static SDKPlane empty
		{
			get
			{
				SDKPlane result = default(SDKPlane);
				result.distance = 0f;
				result.normal = SDKVector3.up;
				return result;
			}
		}

		public static implicit operator SDKPlane(Plane v)
		{
			SDKPlane result = default(SDKPlane);
			result.distance = v.distance;
			result.normal = v.normal;
			return result;
		}

		public override string ToString()
		{
			return $"SDKPlane:\r\n{distance} {normal}";
		}
	}
	public struct SDKPriority
	{
		public sbyte pose;

		public sbyte clipPlane;

		public sbyte stage;

		public sbyte resolution;

		public sbyte feature;

		public sbyte nearFarAdjustment;

		public sbyte groundPlane;

		public sbyte reserved2;

		public static SDKPriority empty
		{
			get
			{
				SDKPriority result = default(SDKPriority);
				result.pose = -63;
				result.clipPlane = -63;
				result.stage = -63;
				result.resolution = -63;
				result.feature = -63;
				result.nearFarAdjustment = 63;
				result.groundPlane = -63;
				result.reserved2 = -63;
				return result;
			}
		}

		public override string ToString()
		{
			return $"Priority:\r\npose: {pose}, clipPlane: {clipPlane}, stage: {stage}, resolution: {resolution}, feature: {feature}, nearFarAdjustment: {nearFarAdjustment}, groundPlane: {groundPlane}";
		}
	}
	public struct SDKApplicationOutput
	{
		public FEATURES supportedFeatures;

		public string engineName;

		public string engineVersion;

		public string applicationName;

		public string applicationVersion;

		public string xrDeviceName;

		public string graphicsAPI;

		public string sdkID;

		public string sdkVersion;

		public static SDKApplicationOutput empty
		{
			get
			{
				SDKApplicationOutput result = default(SDKApplicationOutput);
				result.supportedFeatures = FEATURES.NONE;
				result.engineName = string.Empty;
				result.engineVersion = string.Empty;
				result.applicationName = string.Empty;
				result.applicationVersion = string.Empty;
				result.xrDeviceName = string.Empty;
				result.graphicsAPI = string.Empty;
				result.sdkID = "6QIB2VZ4URNC6VZIKU0ZIJX2GWBSU0S3";
				result.sdkVersion = string.Empty;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKApplicationOutput:\r\nsupportedFeatures: {supportedFeatures}\r\nengineName: {engineName}\r\nengineVersion: {engineVersion}\r\napplicationName: {applicationName}\r\napplicationVersion: {applicationVersion}\r\nxrDeviceName: {xrDeviceName}\r\ngraphicsAPI: {graphicsAPI}\r\nsdkID: {sdkID}\r\nsdkVersion: {sdkVersion}";
		}
	}
	public struct SDKInputFrame
	{
		public SDKPose pose;

		public SDKClipPlane clipPlane;

		public SDKTransform stageTransform;

		public FEATURES features;

		public SDKClipPlane groundClipPlane;

		public ulong frameid;

		public ulong referenceframe;

		public SDKPriority priority;

		public static SDKInputFrame empty
		{
			get
			{
				SDKInputFrame result = default(SDKInputFrame);
				result.pose = SDKPose.empty;
				result.clipPlane = SDKClipPlane.empty;
				result.stageTransform = SDKTransform.empty;
				result.features = FEATURES.NONE;
				result.groundClipPlane = SDKClipPlane.empty;
				result.frameid = 0uL;
				result.referenceframe = 0uL;
				result.priority = SDKPriority.empty;
				return result;
			}
		}

		public void ReleaseControl()
		{
			priority = SDKPriority.empty;
		}

		public void ObtainControl()
		{
			priority = SDKPriority.empty;
			priority.pose = 63;
		}

		public override string ToString()
		{
			return $"SDKInputFrame:\r\npose: {pose}\r\nclipPlane: {clipPlane}\r\nstageTransform: {stageTransform}\r\nfeatures: {features}\r\ngroundClipPlane: {groundClipPlane}\r\nframeid: {frameid}\r\nreferenceframe: {referenceframe}\r\npriority: {priority:X4}";
		}
	}
	public struct SDKOutputFrame
	{
		public RENDERING_PIPELINE renderingPipeline;

		public SDKTrackedSpace trackedSpace;

		public static SDKOutputFrame empty
		{
			get
			{
				SDKOutputFrame result = default(SDKOutputFrame);
				result.renderingPipeline = RENDERING_PIPELINE.UNDEFINED;
				result.trackedSpace = SDKTrackedSpace.empty;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKOutputFrame:\r\nrenderingPipeline: {renderingPipeline}\r\ntrackedSpace: {trackedSpace}";
		}
	}
	public struct SDKTrackedSpace
	{
		public SDKVector3 trackedSpaceWorldPosition;

		public SDKQuaternion trackedSpaceWorldRotation;

		public SDKVector3 trackedSpaceLocalScale;

		public SDKMatrix4x4 trackedSpaceLocalToWorldMatrix;

		public SDKMatrix4x4 trackedSpaceWorldToLocalMatrix;

		public static SDKTrackedSpace empty
		{
			get
			{
				SDKTrackedSpace result = default(SDKTrackedSpace);
				result.trackedSpaceWorldPosition = SDKVector3.zero;
				result.trackedSpaceWorldRotation = SDKQuaternion.identity;
				result.trackedSpaceLocalScale = SDKVector3.zero;
				result.trackedSpaceLocalToWorldMatrix = SDKMatrix4x4.identity;
				result.trackedSpaceWorldToLocalMatrix = SDKMatrix4x4.identity;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKTrackedSpace:\r\ntrackedSpaceWorldPosition: {trackedSpaceWorldPosition}\r\ntrackedSpaceWorldRotation: {trackedSpaceWorldRotation}\r\ntrackedSpaceLocalScale: {trackedSpaceLocalScale}\r\ntrackedSpaceLocalToWorldMatrix: {trackedSpaceLocalToWorldMatrix}\r\ntrackedSpaceWorldToLocalMatrix: {trackedSpaceWorldToLocalMatrix}";
		}
	}
	public struct SDKTexture
	{
		public TEXTURE_ID id;

		public IntPtr texturePtr;

		public IntPtr SharedHandle;

		public TEXTURE_DEVICE device;

		public int dummy;

		public TEXTURE_TYPE type;

		public TEXTURE_FORMAT format;

		public TEXTURE_COLOR_SPACE colorSpace;

		public int width;

		public int height;

		public static SDKTexture empty
		{
			get
			{
				SDKTexture result = default(SDKTexture);
				result.id = TEXTURE_ID.UNDEFINED;
				result.texturePtr = IntPtr.Zero;
				result.SharedHandle = IntPtr.Zero;
				result.device = TEXTURE_DEVICE.UNDEFINED;
				result.dummy = 0;
				result.type = TEXTURE_TYPE.UNDEFINED;
				result.format = TEXTURE_FORMAT.UNDEFINED;
				result.colorSpace = TEXTURE_COLOR_SPACE.UNDEFINED;
				result.width = 0;
				result.height = 0;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKTexture:\r\nid: {id}\r\ntexturePtr: {texturePtr}\r\nSharedHandle: {SharedHandle}\r\ndevice: {device}\r\ndummy: {dummy}\r\ntype: {type}\r\nformat: {format}\r\ncolorSpace: {colorSpace}\r\nwidth: {width}\r\nheight: {height}";
		}
	}
	public struct SDKTransform
	{
		public SDKVector3 localPosition;

		public SDKQuaternion localRotation;

		public SDKVector3 localScale;

		public static SDKTransform empty
		{
			get
			{
				SDKTransform result = default(SDKTransform);
				result.localPosition = SDKVector3.zero;
				result.localRotation = SDKQuaternion.identity;
				result.localScale = SDKVector3.one;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKTransform:\r\nlocalPosition: {localPosition}\r\nlocalRotation: {localRotation}\r\nlocalScale: {localScale}";
		}
	}
	public struct SDKClipPlane
	{
		public SDKMatrix4x4 transform;

		public int width;

		public int height;

		public float tesselation;

		public static SDKClipPlane empty
		{
			get
			{
				SDKClipPlane result = default(SDKClipPlane);
				result.transform = SDKMatrix4x4.identity;
				result.width = 0;
				result.height = 0;
				result.tesselation = 0f;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKClipPlane:\r\ntransform: {transform}\r\nwidth: {width}\r\nheight: {height}\r\ntesselation: {tesselation}";
		}
	}
	public struct SDKControllerState
	{
		public SDKVector3 hmdposition;

		public SDKQuaternion hmdrotation;

		public SDKVector3 calibrationcameraposition;

		public SDKQuaternion calibrationcamerarotation;

		public SDKVector3 cameraposition;

		public SDKQuaternion camerarotation;

		public SDKVector3 leftposition;

		public SDKQuaternion leftrotation;

		public SDKVector3 rightposition;

		public SDKQuaternion rightrotation;

		public static SDKControllerState empty
		{
			get
			{
				SDKControllerState result = default(SDKControllerState);
				result.hmdposition = SDKVector3.zero;
				result.hmdrotation = SDKQuaternion.identity;
				result.calibrationcameraposition = SDKVector3.zero;
				result.calibrationcamerarotation = SDKQuaternion.identity;
				result.cameraposition = SDKVector3.zero;
				result.camerarotation = SDKQuaternion.identity;
				result.leftposition = SDKVector3.zero;
				result.leftrotation = SDKQuaternion.identity;
				result.rightposition = SDKVector3.zero;
				result.rightrotation = SDKQuaternion.identity;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKControllerState:\r\nhmdposition: {hmdposition}\r\nhmdrotation: {hmdrotation}\r\ncalibrationcameraposition: {calibrationcameraposition}\r\ncalibrationcamerarotation: {calibrationcamerarotation}\r\ncameraposition: {cameraposition}\r\ncamerarotation: {camerarotation}\r\nleftposition: {leftposition}\r\nleftrotation: {leftrotation}\r\nrightposition: {rightposition}\r\nrightrotation: {rightrotation}";
		}
	}
	public struct SDKPose
	{
		public SDKMatrix4x4 projectionMatrix;

		public SDKVector3 localPosition;

		public SDKQuaternion localRotation;

		public float verticalFieldOfView;

		public float nearClipPlane;

		public float farClipPlane;

		public int unused0;

		public int unused1;

		public static SDKPose empty
		{
			get
			{
				SDKPose result = default(SDKPose);
				result.projectionMatrix = SDKMatrix4x4.Perspective(90f, 1f, 0.01f, 1000f);
				result.localPosition = SDKVector3.zero;
				result.localRotation = SDKQuaternion.identity;
				result.verticalFieldOfView = 90f;
				result.nearClipPlane = 0.01f;
				result.farClipPlane = 1000f;
				return result;
			}
		}

		public override string ToString()
		{
			return $"SDKPose:\r\nprojectionMatrix: {projectionMatrix}\r\nlocalPosition: {localPosition}\r\nlocalRotation: {localRotation}\r\nverticalFieldOfView: {verticalFieldOfView}\r\nnearClipPlane: {nearClipPlane}\r\nfarClipPlane: {farClipPlane}";
		}
	}
	public static class SDKUtils
	{
		public static TEXTURE_COLOR_SPACE GetDefaultColorSpace => QualitySettings.activeColorSpace switch
		{
			ColorSpace.Gamma => TEXTURE_COLOR_SPACE.SRGB, 
			ColorSpace.Linear => TEXTURE_COLOR_SPACE.LINEAR, 
			_ => TEXTURE_COLOR_SPACE.UNDEFINED, 
		};

		public static void CreateClipPlane(Mesh mesh, int resX, int resY, bool useQuads, float skirtLength)
		{
			int num = (resX + 1) * (resY + 1);
			int num2 = (useQuads ? (resX * resY * 4) : (resX * resY * 2 * 3));
			Vector3[] array = new Vector3[num];
			Vector2[] array2 = new Vector2[num];
			int[] array3 = new int[num2];
			float num3 = 0.5f;
			float num4 = 0.5f;
			int num5 = resX + 1;
			int num6 = resY + 1;
			for (int i = 0; i < num6; i++)
			{
				for (int j = 0; j < num5; j++)
				{
					int num7 = i * num5 + j;
					float num8 = (float)j / (float)resX;
					float num9 = (float)i / (float)resY;
					float num10 = ((j == 0 || j == resX) ? skirtLength : 1f);
					float num11 = ((i == 0 || i == resY) ? skirtLength : 1f);
					array[num7] = new Vector2((0f - num3 + num8) * num10, (0f - num4 + num9) * num11);
					array2[num7] = new Vector2(Mathf.InverseLerp(1f, resX - 1, j), Mathf.InverseLerp(1f, resY - 1, i));
				}
			}
			mesh.Clear();
			mesh.vertices = array;
			mesh.uv = array2;
			mesh.bounds = new Bounds(Vector3.zero, Vector3.one * float.MaxValue);
			int num12 = resX * resY;
			int num13 = 0;
			int num14 = 0;
			if (useQuads)
			{
				for (int k = 0; k < num12; k++)
				{
					num13 = k / resX * num5 + k % resX;
					array3[num14++] = num13 + 1;
					array3[num14++] = num13;
					array3[num14++] = num13 + 1 + resX;
					array3[num14++] = num13 + 2 + resX;
				}
				mesh.SetIndices(array3, MeshTopology.Quads, 0);
				return;
			}
			for (int l = 0; l < num12; l++)
			{
				num13 = l / resX * num5 + l % resX;
				array3[num14++] = num13 + 2 + resX;
				array3[num14++] = num13 + 1;
				array3[num14++] = num13;
				array3[num14++] = num13 + 1 + resX;
				array3[num14++] = num13 + 2 + resX;
				array3[num14++] = num13;
			}
			mesh.SetIndices(array3, MeshTopology.Triangles, 0);
		}

		public static RenderTextureReadWrite GetReadWriteFromColorSpace(TEXTURE_COLOR_SPACE colorSpace)
		{
			return colorSpace switch
			{
				TEXTURE_COLOR_SPACE.LINEAR => RenderTextureReadWrite.Linear, 
				TEXTURE_COLOR_SPACE.SRGB => RenderTextureReadWrite.sRGB, 
				_ => RenderTextureReadWrite.Default, 
			};
		}

		public static TEXTURE_COLOR_SPACE GetColorSpace(RenderTexture renderTexture)
		{
			if (renderTexture == null)
			{
				return TEXTURE_COLOR_SPACE.UNDEFINED;
			}
			if (renderTexture.sRGB)
			{
				return TEXTURE_COLOR_SPACE.SRGB;
			}
			return TEXTURE_COLOR_SPACE.LINEAR;
		}

		public static RENDERING_PIPELINE GetRenderingPipeline(RenderingPath renderingPath)
		{
			return renderingPath switch
			{
				RenderingPath.DeferredLighting => RENDERING_PIPELINE.DEFERRED, 
				RenderingPath.DeferredShading => RENDERING_PIPELINE.DEFERRED, 
				RenderingPath.Forward => RENDERING_PIPELINE.FORWARD, 
				RenderingPath.VertexLit => RENDERING_PIPELINE.VERTEX_LIT, 
				_ => RENDERING_PIPELINE.UNDEFINED, 
			};
		}

		public static TEXTURE_DEVICE GetDevice()
		{
			switch (SystemInfo.graphicsDeviceType)
			{
			case GraphicsDeviceType.Direct3D11:
			case GraphicsDeviceType.Direct3D12:
				return TEXTURE_DEVICE.DIRECTX;
			case GraphicsDeviceType.Vulkan:
				return TEXTURE_DEVICE.VULKAN;
			case GraphicsDeviceType.Metal:
				return TEXTURE_DEVICE.METAL;
			case GraphicsDeviceType.OpenGLCore:
				return TEXTURE_DEVICE.OPENGL;
			default:
				return TEXTURE_DEVICE.UNDEFINED;
			}
		}

		public static bool ContainsFlag(ulong flags, ulong flag)
		{
			return (flags & flag) != 0;
		}

		public static ulong SetFlag(ulong flags, ulong flag, bool enabled)
		{
			if (enabled)
			{
				return flags | flag;
			}
			return flags & ~flag;
		}

		public static void GetCameraPositionAndRotation(SDKPose pose, Matrix4x4 originLocalToWorldMatrix, out Vector3 position, out Quaternion rotation)
		{
			position = originLocalToWorldMatrix.MultiplyPoint(pose.localPosition);
			rotation = RotateQuaternionByMatrix(originLocalToWorldMatrix, pose.localRotation);
		}

		public static void CleanCameraBehaviours(Camera camera, string[] excludeBehaviours)
		{
			foreach (Transform item in camera.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			if (excludeBehaviours != null)
			{
				for (int i = 0; i < excludeBehaviours.Length; i++)
				{
					UnityEngine.Object.Destroy(camera.GetComponent(excludeBehaviours[i]));
				}
			}
		}

		public static void SetCamera(Camera camera, Transform cameraTransform, SDKInputFrame inputFrame, Matrix4x4 originLocalToWorldMatrix, int layerMask)
		{
			Vector3 position = Vector3.zero;
			Quaternion rotation = Quaternion.identity;
			float verticalFieldOfView = inputFrame.pose.verticalFieldOfView;
			float nearClipPlane = inputFrame.pose.nearClipPlane;
			float farClipPlane = inputFrame.pose.farClipPlane;
			Matrix4x4 projectionMatrix = inputFrame.pose.projectionMatrix;
			GetCameraPositionAndRotation(inputFrame.pose, originLocalToWorldMatrix, out position, out rotation);
			cameraTransform.position = position;
			cameraTransform.rotation = rotation;
			camera.fieldOfView = verticalFieldOfView;
			camera.nearClipPlane = nearClipPlane;
			camera.farClipPlane = farClipPlane;
			camera.projectionMatrix = projectionMatrix;
			camera.cullingMask = layerMask;
		}

		public static Quaternion RotateQuaternionByMatrix(Matrix4x4 matrix, Quaternion rotation)
		{
			return Quaternion.LookRotation(matrix.MultiplyVector(Vector3.forward), matrix.MultiplyVector(Vector3.up)) * rotation;
		}

		public static SDKTrackedSpace GetTrackedSpace(Transform transform)
		{
			if (transform == null)
			{
				return SDKTrackedSpace.empty;
			}
			SDKTrackedSpace result = default(SDKTrackedSpace);
			result.trackedSpaceWorldPosition = transform.position;
			result.trackedSpaceWorldRotation = transform.rotation;
			result.trackedSpaceLocalScale = transform.localScale;
			result.trackedSpaceLocalToWorldMatrix = transform.localToWorldMatrix;
			result.trackedSpaceWorldToLocalMatrix = transform.worldToLocalMatrix;
			return result;
		}

		public static bool DestroyObject<T>(ref T reference) where T : UnityEngine.Object
		{
			if (reference == null)
			{
				return false;
			}
			UnityEngine.Object.Destroy(reference);
			reference = null;
			return true;
		}

		public static bool DisposeObject<T>(ref T reference) where T : IDisposable
		{
			if (reference == null)
			{
				return false;
			}
			reference.Dispose();
			reference = default(T);
			return true;
		}

		public static bool CreateTexture(ref RenderTexture renderTexture, int width, int height, int depth, RenderTextureFormat format)
		{
			DestroyTexture(ref renderTexture);
			if (width <= 0 || height <= 0)
			{
				UnityEngine.Debug.LogError("LIV: Unable to create render texture. Texture dimension must be higher than zero.");
				return false;
			}
			renderTexture = new RenderTexture(width, height, depth, format)
			{
				antiAliasing = 1,
				wrapMode = TextureWrapMode.Clamp,
				useMipMap = false,
				anisoLevel = 0
			};
			if (!renderTexture.Create())
			{
				UnityEngine.Debug.LogError("LIV: Unable to create render texture.");
				return false;
			}
			return true;
		}

		public static void DestroyTexture(ref RenderTexture _renderTexture)
		{
			if (!(_renderTexture == null))
			{
				if (_renderTexture.IsCreated())
				{
					_renderTexture.Release();
				}
				_renderTexture = null;
			}
		}

		public static void ApplyUserSpaceTransform(SDKRender render)
		{
			if (!(render.stageTransform == null))
			{
				render.stageTransform.localPosition = render.inputFrame.stageTransform.localPosition;
				render.stageTransform.localRotation = render.inputFrame.stageTransform.localRotation;
				render.stageTransform.localScale = render.inputFrame.stageTransform.localScale;
			}
		}

		public static void CreateBridgeOutputFrame(SDKRender render)
		{
			RENDERING_PIPELINE renderingPipeline = RENDERING_PIPELINE.UNDEFINED;
			if (render.cameraInstance != null)
			{
				renderingPipeline = GetRenderingPipeline(render.cameraInstance.actualRenderingPath);
			}
			SDKOutputFrame frame = default(SDKOutputFrame);
			frame.renderingPipeline = renderingPipeline;
			frame.trackedSpace = GetTrackedSpace((render.stageTransform == null) ? render.stage : render.stageTransform);
			SDKBridge.CreateFrame(frame);
		}

		public static bool FeatureEnabled(FEATURES features, FEATURES feature)
		{
			return ContainsFlag((ulong)features, (ulong)feature);
		}

		public static void DisableStandardAssets(Camera cameraInstance, ref MonoBehaviour[] behaviours, ref bool[] wasBehaviourEnabled)
		{
			behaviours = null;
			wasBehaviourEnabled = null;
			behaviours = cameraInstance.gameObject.GetComponents<MonoBehaviour>();
			wasBehaviourEnabled = new bool[behaviours.Length];
			for (int i = 0; i < behaviours.Length; i++)
			{
				MonoBehaviour monoBehaviour = behaviours[i];
				if (monoBehaviour.enabled && monoBehaviour.GetType().ToString().StartsWith("UnityStandardAssets."))
				{
					monoBehaviour.enabled = false;
					wasBehaviourEnabled[i] = true;
				}
			}
		}

		public static void RestoreStandardAssets(ref MonoBehaviour[] behaviours, ref bool[] wasBehaviourEnabled)
		{
			if (behaviours == null)
			{
				return;
			}
			for (int i = 0; i < behaviours.Length; i++)
			{
				if (wasBehaviourEnabled[i])
				{
					behaviours[i].enabled = true;
				}
			}
		}

		public static void ForceForwardRendering(Camera cameraInstance, Mesh clipPlaneMesh, Material forceForwardRenderingMaterial)
		{
			Matrix4x4 matrix = cameraInstance.transform.localToWorldMatrix * Matrix4x4.TRS(Vector3.forward * (cameraInstance.nearClipPlane + 0.1f), Quaternion.identity, Vector3.one);
			Graphics.DrawMesh(clipPlaneMesh, matrix, forceForwardRenderingMaterial, 0, cameraInstance, 0, new MaterialPropertyBlock(), castShadows: false, receiveShadows: false, useLightProbes: false);
		}
	}
}
namespace Evereal.SkyboxCapture
{
	public class AutoRotate : MonoBehaviour
	{
		public int angleSpeed = 30;

		private void Update()
		{
			base.transform.Rotate(Vector3.up * Time.deltaTime * angleSpeed);
		}
	}
	public class HintUI : MonoBehaviour
	{
		public SkyboxCapture skyboxCapture;

		private void OnGUI()
		{
			GUI.Label(new Rect(10f, 10f, 200f, 20f), "Press \"" + skyboxCapture.captureKey.ToString() + "\" to Capture Skybox Image");
		}
	}
	public class DontDestroy : MonoBehaviour
	{
		private void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
	}
	[Serializable]
	public enum ProjectionType
	{
		Equirectangular,
		Cubemap
	}
	[Serializable]
	public enum CubemapSizeType
	{
		_512,
		_1024,
		_2048,
		_4096
	}
	[Serializable]
	public enum CubemapLayoutType
	{
		HorizontalCross,
		SixSided,
		Compact
	}
	[Serializable]
	public enum AntiAliasingType
	{
		_1,
		_2,
		_4,
		_8
	}
	[Serializable]
	public enum ImageFormatType
	{
		PNG,
		JPEG
	}
	[Serializable]
	public enum ImageSizeType
	{
		_1440x720,
		_2048x1024,
		_4096x2048,
		_8192x4096,
		_12288x6144,
		_16384x8192
	}
	public static class Utils
	{
		public static string GetTimeString()
		{
			return DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
		}

		public static Material CreateMaterial(string sName, Material m2Create)
		{
			if ((bool)m2Create && m2Create.shader.name == sName)
			{
				return m2Create;
			}
			return CreateMaterial(Shader.Find(sName), m2Create);
		}

		public static Material CreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Create material missing shader!");
				return null;
			}
			if ((bool)m2Create && m2Create.shader == s && s.isSupported)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				return null;
			}
			if (m2Create != null)
			{
				UnityEngine.Object.Destroy(m2Create);
			}
			m2Create = new Material(s);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		public static Texture2D CreateTexture(int width, int height, Texture2D t2Create)
		{
			if ((bool)t2Create && t2Create.width == width && t2Create.height == height)
			{
				return t2Create;
			}
			if (t2Create != null)
			{
				UnityEngine.Object.Destroy(t2Create);
			}
			t2Create = new Texture2D(width, height, TextureFormat.RGBA32, mipChain: false);
			t2Create.hideFlags = HideFlags.HideAndDontSave;
			return t2Create;
		}

		public static RenderTexture CreateRenderTexture(int width, int height, int depth, int antiAliasing, RenderTexture t2Create, bool create = true)
		{
			if ((bool)t2Create && t2Create.width == width && t2Create.height == height && t2Create.depth == depth && t2Create.antiAliasing == antiAliasing && t2Create.IsCreated() == create)
			{
				return t2Create;
			}
			if (t2Create != null)
			{
				UnityEngine.Object.Destroy(t2Create);
			}
			t2Create = new RenderTexture(width, height, depth, RenderTextureFormat.ARGB32);
			t2Create.antiAliasing = antiAliasing;
			t2Create.hideFlags = HideFlags.HideAndDontSave;
			if (create)
			{
				t2Create.Create();
			}
			return t2Create;
		}

		public static string CreateFolder(string f2Create)
		{
			string text = f2Create;
			if (string.IsNullOrEmpty(text))
			{
				text = "Captures/";
			}
			if (!text.EndsWith("/") && !text.EndsWith("\\"))
			{
				text += "/";
			}
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			return Path.GetFullPath(text);
		}

		public static void BrowseFolder(string folder)
		{
			if (string.IsNullOrEmpty(folder))
			{
				folder = "Captures/";
			}
			string fullPath = Path.GetFullPath(folder);
			if (Directory.Exists(fullPath))
			{
				Process.Start(Path.GetFullPath(folder));
			}
			else
			{
				UnityEngine.Debug.LogWarning("Folder " + fullPath + " not existed!");
			}
		}
	}
	public class Readme : ScriptableObject
	{
		[Serializable]
		public class Section
		{
			public string heading;

			public string text;

			public string linkText;

			public string url;
		}

		public Texture2D icon;

		public float iconMaxWidth = 128f;

		public string title;

		public Section[] sections;

		public bool loadedLayout;
	}
	[RequireComponent(typeof(Camera))]
	[ExecuteInEditMode]
	public class SkyboxCapture : MonoBehaviour
	{
		[SerializeField]
		public KeyCode captureKey = KeyCode.Space;

		[SerializeField]
		public string saveFolder = "";

		private string saveFolderFullPath = "";

		[SerializeField]
		public ProjectionType projectionType;

		[SerializeField]
		public CubemapSizeType cubemapSize = CubemapSizeType._1024;

		[SerializeField]
		public CubemapLayoutType cubemapLayout = CubemapLayoutType.Compact;

		[SerializeField]
		public ImageFormatType imageFormat;

		[SerializeField]
		public int jpgQuality = 75;

		[SerializeField]
		public ImageSizeType imageSize = ImageSizeType._4096x2048;

		[SerializeField]
		public AntiAliasingType antiAliasing;

		[SerializeField]
		public Material equirectMaterial;

		[SerializeField]
		public Material cubemapMaterial;

		private Camera captureCamera;

		protected bool includeCameraRotation = true;

		private CubemapFace[] faces = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};

		private string imageSavePath;

		private byte[] imageData;

		protected string LOG_FORMAT = "[SkyboxCapture] {0}";

		public int CubemapSize
		{
			get
			{
				if (cubemapSize == CubemapSizeType._512)
				{
					return 512;
				}
				if (cubemapSize == CubemapSizeType._1024)
				{
					return 1024;
				}
				if (cubemapSize == CubemapSizeType._2048)
				{
					return 2048;
				}
				if (cubemapSize == CubemapSizeType._4096)
				{
					return 4096;
				}
				return 1;
			}
		}

		public int ImageWidth
		{
			get
			{
				if (projectionType == ProjectionType.Cubemap)
				{
					if (cubemapLayout == CubemapLayoutType.Compact)
					{
						return CubemapSize * 3;
					}
					if (cubemapLayout == CubemapLayoutType.HorizontalCross)
					{
						return CubemapSize * 4;
					}
					if (cubemapLayout == CubemapLayoutType.SixSided)
					{
						return CubemapSize;
					}
				}
				if (imageSize == ImageSizeType._1440x720)
				{
					return 1440;
				}
				if (imageSize == ImageSizeType._2048x1024)
				{
					return 2048;
				}
				if (imageSize == ImageSizeType._4096x2048)
				{
					return 4096;
				}
				if (imageSize == ImageSizeType._8192x4096)
				{
					return 8192;
				}
				if (imageSize == ImageSizeType._12288x6144)
				{
					return 12288;
				}
				if (imageSize == ImageSizeType._16384x8192)
				{
					return 16384;
				}
				return 1;
			}
		}

		public int ImageHeight
		{
			get
			{
				if (projectionType == ProjectionType.Cubemap)
				{
					if (cubemapLayout == CubemapLayoutType.Compact)
					{
						return CubemapSize * 2;
					}
					if (cubemapLayout == CubemapLayoutType.HorizontalCross)
					{
						return CubemapSize * 3;
					}
					if (cubemapLayout == CubemapLayoutType.SixSided)
					{
						return CubemapSize;
					}
				}
				if (imageSize == ImageSizeType._1440x720)
				{
					return 720;
				}
				if (imageSize == ImageSizeType._2048x1024)
				{
					return 1024;
				}
				if (imageSize == ImageSizeType._4096x2048)
				{
					return 2048;
				}
				if (imageSize == ImageSizeType._8192x4096)
				{
					return 4096;
				}
				if (imageSize == ImageSizeType._12288x6144)
				{
					return 6144;
				}
				if (imageSize == ImageSizeType._16384x8192)
				{
					return 8192;
				}
				return 1;
			}
		}

		public int AntiAliasing
		{
			get
			{
				if (antiAliasing == AntiAliasingType._1)
				{
					return 1;
				}
				if (antiAliasing == AntiAliasingType._2)
				{
					return 2;
				}
				if (antiAliasing == AntiAliasingType._4)
				{
					return 4;
				}
				if (antiAliasing == AntiAliasingType._8)
				{
					return 8;
				}
				return 1;
			}
		}

		public void StartCapture()
		{
			if (captureCamera == null)
			{
				captureCamera = GetComponent<Camera>();
			}
			saveFolderFullPath = Utils.CreateFolder(saveFolder);
			string arg = ((imageFormat == ImageFormatType.PNG) ? "png" : "jpg");
			imageSavePath = $"{saveFolderFullPath}skybox_{Utils.GetTimeString()}.{arg}";
			imageData = null;
			RenderTexture renderTexture = Utils.CreateRenderTexture(ImageWidth, ImageHeight, 24, AntiAliasing, null);
			if (projectionType == ProjectionType.Cubemap)
			{
				int num = CubemapSize;
				int num2 = CubemapSize;
				captureCamera.transform.eulerAngles = new Vector3(0f, 0f, 0f);
				Texture2D texture2D = Utils.CreateTexture(ImageWidth, ImageHeight, null);
				Texture2D texture2D2 = Utils.CreateTexture(num, num2, null);
				Cubemap cubemap = new Cubemap(CubemapSize, TextureFormat.RGBA32, mipChain: false);
				captureCamera.RenderToCubemap(cubemap);
				if (cubemapLayout == CubemapLayoutType.Compact)
				{
					for (int i = 0; i < faces.Length; i++)
					{
						Color[] pixels = cubemap.GetPixels(faces[i]);
						Array.Reverse((Array)pixels, 0, pixels.Length);
						for (int j = 0; j < num2; j++)
						{
							Array.Reverse((Array)pixels, j * num, num);
						}
						texture2D2.SetPixels(pixels);
						switch ((CubemapFace)i)
						{
						case CubemapFace.PositiveX:
							texture2D.SetPixels(0, num2, num, num2, pixels);
							break;
						case CubemapFace.NegativeX:
							texture2D.SetPixels(num, num2, num, num2, pixels);
							break;
						case CubemapFace.PositiveY:
							texture2D.SetPixels(num * 2, num2, num, num2, pixels);
							break;
						case CubemapFace.NegativeY:
							texture2D.SetPixels(0, 0, num, num2, pixels);
							break;
						case CubemapFace.PositiveZ:
							texture2D.SetPixels(num, 0, num, num2, pixels);
							break;
						case CubemapFace.NegativeZ:
							texture2D.SetPixels(num * 2, 0, num, num2, pixels);
							break;
						}
					}
					texture2D.Apply();
					WriteTexture2DImage(texture2D);
				}
				else if (cubemapLayout == CubemapLayoutType.HorizontalCross)
				{
					for (int k = 0; k < faces.Length; k++)
					{
						Color[] pixels2 = cubemap.GetPixels(faces[k]);
						Array.Reverse((Array)pixels2, 0, pixels2.Length);
						for (int l = 0; l < num2; l++)
						{
							Array.Reverse((Array)pixels2, l * num, num);
						}
						texture2D2.SetPixels(pixels2);
						switch ((CubemapFace)k)
						{
						case CubemapFace.PositiveX:
							texture2D.SetPixels(num * 2, num2, num, num2, pixels2);
							break;
						case CubemapFace.NegativeX:
							texture2D.SetPixels(0, num2, num, num2, pixels2);
							break;
						case CubemapFace.PositiveY:
							texture2D.SetPixels(num, num2 * 2, num, num2, pixels2);
							break;
						case CubemapFace.NegativeY:
							texture2D.SetPixels(num, 0, num, num2, pixels2);
							break;
						case CubemapFace.PositiveZ:
							texture2D.SetPixels(num, num2, num, num2, pixels2);
							break;
						case CubemapFace.NegativeZ:
							texture2D.SetPixels(num * 3, num2, num, num2, pixels2);
							break;
						}
					}
					texture2D.Apply();
					WriteTexture2DImage(texture2D);
				}
				else if (cubemapLayout == CubemapLayoutType.SixSided)
				{
					for (int m = 0; m < faces.Length; m++)
					{
						Color[] pixels3 = cubemap.GetPixels(faces[m]);
						Array.Reverse((Array)pixels3, 0, pixels3.Length);
						for (int n = 0; n < num2; n++)
						{
							Array.Reverse((Array)pixels3, n * num, num);
						}
						texture2D2.SetPixels(pixels3);
						string timeString = Utils.GetTimeString();
						switch ((CubemapFace)m)
						{
						case CubemapFace.PositiveX:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_right.{arg}";
							break;
						case CubemapFace.NegativeX:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_left.{arg}";
							break;
						case CubemapFace.PositiveY:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_top.{arg}";
							break;
						case CubemapFace.NegativeY:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_bottom.{arg}";
							break;
						case CubemapFace.PositiveZ:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_front.{arg}";
							break;
						case CubemapFace.NegativeZ:
							imageSavePath = $"{saveFolderFullPath}skybox_{timeString}_back.{arg}";
							break;
						}
						texture2D.SetPixels(0, 0, num, num2, pixels3);
						texture2D.Apply();
						WriteTexture2DImage(texture2D);
					}
				}
				RenderTexture.active = null;
				if (Application.isEditor)
				{
					UnityEngine.Object.DestroyImmediate(texture2D);
					UnityEngine.Object.DestroyImmediate(texture2D2);
				}
				else
				{
					UnityEngine.Object.Destroy(texture2D);
					UnityEngine.Object.Destroy(texture2D2);
				}
			}
			else if (projectionType == ProjectionType.Equirectangular)
			{
				RenderTexture renderTexture2 = Utils.CreateRenderTexture(CubemapSize, CubemapSize, 24, AntiAliasing, null, create: false);
				renderTexture2.dimension = TextureDimension.Cube;
				captureCamera.RenderToCubemap(renderTexture2);
				captureCamera.Render();
				if (includeCameraRotation)
				{
					equirectMaterial.SetMatrix("_CubeTransform", Matrix4x4.TRS(Vector3.zero, base.transform.rotation, Vector3.one));
				}
				else
				{
					equirectMaterial.SetMatrix("_CubeTransform", Matrix4x4.identity);
				}
				Graphics.Blit(renderTexture2, renderTexture, equirectMaterial);
				WriteTextureImage(renderTexture);
				if (Application.isEditor)
				{
					UnityEngine.Object.DestroyImmediate(renderTexture2);
				}
				else
				{
					UnityEngine.Object.Destroy(renderTexture2);
				}
			}
			if (Application.isEditor)
			{
				UnityEngine.Object.DestroyImmediate(renderTexture);
			}
			else
			{
				UnityEngine.Object.Destroy(renderTexture);
			}
		}

		private void WriteTextureImage(RenderTexture outputTexture)
		{
			RenderTexture.active = outputTexture;
			Texture2D texture2D = Utils.CreateTexture(ImageWidth, ImageHeight, null);
			texture2D.ReadPixels(new Rect(0f, 0f, ImageWidth, ImageHeight), 0, 0);
			texture2D.Apply();
			RenderTexture.active = null;
			WriteTexture2DImage(texture2D);
			if (Application.isEditor)
			{
				UnityEngine.Object.DestroyImmediate(texture2D);
			}
			else
			{
				UnityEngine.Object.Destroy(texture2D);
			}
		}

		private void WriteTexture2DImage(Texture2D texture2D)
		{
			if (imageFormat == ImageFormatType.PNG)
			{
				imageData = texture2D.EncodeToPNG();
			}
			else
			{
				imageData = texture2D.EncodeToJPG(jpgQuality);
			}
			Thread thread = new Thread(WriteImageProcess);
			thread.Priority = System.Threading.ThreadPriority.Lowest;
			thread.IsBackground = true;
			thread.Start();
		}

		private void WriteImageProcess()
		{
			while (imageData == null)
			{
				Thread.Sleep(100);
			}
			File.WriteAllBytes(imageSavePath, imageData);
			UnityEngine.Debug.LogFormat(LOG_FORMAT, "Save file to: " + imageSavePath);
			imageData = null;
		}

		private void Update()
		{
			if (Input.GetKeyDown(captureKey))
			{
				StartCapture();
			}
		}
	}
}
namespace UnityEngine.UI
{
	[AddComponentMenu("UI/Raycast Filters/Ignore Raycast Filter")]
	public class UIIgnoreRaycast : MonoBehaviour, ICanvasRaycastFilter
	{
		public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			return false;
		}
	}
}
namespace Wacki
{
	public abstract class IUILaserPointer : MonoBehaviour
	{
		public float laserThickness = 0.002f;

		public float laserHitScale = 0.02f;

		public bool laserAlwaysOn;

		public Color color;

		public GameObject hitPoint;

		public Material newMaterial;

		public LineRenderer RayLine;

		private float _distanceLimit;

		private Color OriColor;

		private void Start()
		{
			laserAlwaysOn = true;
			RayLine.SetPosition(0, Vector3.zero);
			OriColor = RayLine.endColor;
			hitPoint = UnityEngine.Object.Instantiate(hitPoint);
			hitPoint.transform.SetParent(base.transform, worldPositionStays: false);
			hitPoint.transform.localScale = new Vector3(laserHitScale, laserHitScale, laserHitScale);
			hitPoint.transform.localEulerAngles = new Vector3(90f, 0f, 0f);
			hitPoint.transform.localPosition = new Vector3(0f, 0f, 100f);
			hitPoint.SetActive(value: false);
			newMaterial.renderQueue = 3004;
			newMaterial.SetColor("_Color", color);
			Initialize();
			if (LaserPointerInputModule.instance == null)
			{
				new GameObject().AddComponent<LaserPointerInputModule>();
			}
			LaserPointerInputModule.instance.AddController(this);
		}

		private void OnDisable()
		{
			if ((bool)hitPoint)
			{
				hitPoint.SetActive(value: false);
			}
			if ((bool)RayLine)
			{
				RayLine.enabled = false;
			}
		}

		private void OnDestroy()
		{
			if (LaserPointerInputModule.instance != null)
			{
				LaserPointerInputModule.instance.RemoveController(this);
			}
		}

		protected virtual void Initialize()
		{
		}

		public virtual void OnEnterControl(GameObject control)
		{
		}

		public virtual void OnExitControl(GameObject control)
		{
		}

		public abstract bool ButtonDown();

		public abstract bool ButtonUp();

		protected virtual void Update()
		{
			RaycastHit hitInfo;
			bool flag = Physics.Raycast(new Ray(base.transform.position, base.transform.forward), out hitInfo, 10f, 32);
			float num = 100f;
			if (flag)
			{
				num = hitInfo.distance;
			}
			if (_distanceLimit > 0f)
			{
				num = Mathf.Min(num, _distanceLimit);
				flag = true;
			}
			if (flag)
			{
				if ((bool)RayLine)
				{
					RayLine.endColor = new Color(OriColor.r, OriColor.g, OriColor.b, OriColor.a);
					RayLine.enabled = true;
				}
				hitPoint.SetActive(value: true);
				hitPoint.transform.localPosition = new Vector3(0f, 0f, num);
				RayLine.SetPosition(1, new Vector3(0f, 0f, num));
			}
			else
			{
				hitPoint.SetActive(value: false);
				if ((bool)RayLine && !laserAlwaysOn)
				{
					RayLine.enabled = false;
				}
				else
				{
					RayLine.endColor = new Color(OriColor.r, OriColor.g, OriColor.b, 0f);
					RayLine.SetPosition(1, new Vector3(0f, 0f, 0.1f));
				}
			}
			_distanceLimit = -1f;
		}

		public virtual void LimitLaserDistance(float distance)
		{
			if (!(distance < 0f))
			{
				if (_distanceLimit < 0f)
				{
					_distanceLimit = distance;
				}
				else
				{
					_distanceLimit = Mathf.Min(_distanceLimit, distance);
				}
			}
		}
	}
	public class LaserPointerEventData : PointerEventData
	{
		public GameObject current;

		public IUILaserPointer controller;

		public LaserPointerEventData(EventSystem e)
			: base(e)
		{
		}

		public override void Reset()
		{
			current = null;
			controller = null;
			base.Reset();
		}
	}
	public class LaserPointerInputModule : BaseInputModule
	{
		private class ControllerData
		{
			public LaserPointerEventData pointerEvent;

			public GameObject currentPoint;

			public GameObject currentPressed;

			public GameObject currentDragging;
		}

		private static LaserPointerInputModule _instance;

		public LayerMask layerMask;

		private Camera UICamera;

		private PhysicsRaycaster raycaster;

		private HashSet<IUILaserPointer> _controllers;

		private Dictionary<IUILaserPointer, ControllerData> _controllerData = new Dictionary<IUILaserPointer, ControllerData>();

		public static LaserPointerInputModule instance => _instance;

		protected override void Awake()
		{
			base.Awake();
			if (_instance != null)
			{
				UnityEngine.Debug.LogWarning("Trying to instantiate multiple LaserPointerInputModule.");
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
			_instance = this;
		}

		protected override void Start()
		{
			base.Start();
			if (UICamera == null)
			{
				UICamera = new GameObject("UI Camera").AddComponent<Camera>();
				raycaster = UICamera.gameObject.AddComponent<PhysicsRaycaster>();
				UICamera.clearFlags = CameraClearFlags.Nothing;
				UICamera.stereoTargetEye = StereoTargetEyeMask.None;
				UICamera.enabled = false;
				UICamera.fieldOfView = 0.01f;
				UICamera.nearClipPlane = 0.01f;
			}
			Canvas[] array = Resources.FindObjectsOfTypeAll<Canvas>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].worldCamera = UICamera;
			}
		}

		public void ResetCanvas()
		{
			Start();
		}

		public void AddController(IUILaserPointer controller)
		{
			_controllerData.Add(controller, new ControllerData());
		}

		public void RemoveController(IUILaserPointer controller)
		{
			_controllerData.Remove(controller);
		}

		protected void UpdateCameraPosition(IUILaserPointer controller)
		{
			UICamera.transform.position = controller.transform.position;
			UICamera.transform.rotation = controller.transform.rotation;
		}

		public void ClearSelection()
		{
			if ((bool)base.eventSystem.currentSelectedGameObject)
			{
				base.eventSystem.SetSelectedGameObject(null);
			}
		}

		private void Select(GameObject go)
		{
			ClearSelection();
			if ((bool)ExecuteEvents.GetEventHandler<ISelectHandler>(go))
			{
				base.eventSystem.SetSelectedGameObject(go);
			}
		}

		public override void Process()
		{
			raycaster.eventMask = layerMask;
			foreach (KeyValuePair<IUILaserPointer, ControllerData> controllerDatum in _controllerData)
			{
				IUILaserPointer key = controllerDatum.Key;
				ControllerData value = controllerDatum.Value;
				UpdateCameraPosition(key);
				if (value.pointerEvent == null)
				{
					value.pointerEvent = new LaserPointerEventData(base.eventSystem);
				}
				else
				{
					value.pointerEvent.Reset();
				}
				value.pointerEvent.controller = key;
				value.pointerEvent.delta = Vector2.zero;
				value.pointerEvent.position = new Vector2((float)UICamera.pixelWidth * 0.5f, (float)UICamera.pixelHeight * 0.5f);
				base.eventSystem.RaycastAll(value.pointerEvent, m_RaycastResultCache);
				value.pointerEvent.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
				m_RaycastResultCache.Clear();
				if (controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject == null || controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject.layer != 5)
				{
					continue;
				}
				if (value.pointerEvent.pointerCurrentRaycast.distance > 0f)
				{
					key.LimitLaserDistance(value.pointerEvent.pointerCurrentRaycast.distance + 0.01f);
				}
				GameObject gameObject = value.pointerEvent.pointerCurrentRaycast.gameObject;
				if (value.currentPoint != gameObject)
				{
					if (value.currentPoint != null)
					{
						key.OnExitControl(value.currentPoint);
					}
					if (gameObject != null)
					{
						key.OnEnterControl(gameObject);
					}
				}
				value.currentPoint = gameObject;
				HandlePointerExitAndEnter(value.pointerEvent, value.currentPoint);
				if (key.ButtonDown())
				{
					ClearSelection();
					csAudioManager.instance.playAudioByName("btnClick");
					value.pointerEvent.pressPosition = value.pointerEvent.position;
					value.pointerEvent.pointerPressRaycast = value.pointerEvent.pointerCurrentRaycast;
					value.pointerEvent.pointerPress = null;
					if (value.currentPoint != null)
					{
						value.currentPressed = value.currentPoint;
						value.pointerEvent.current = value.currentPressed;
						GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerDownHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerDownHandler);
						if (gameObject2 == null)
						{
							gameObject2 = ExecuteEvents.ExecuteHierarchy(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							if (gameObject2 != null)
							{
								value.currentPressed = gameObject2;
							}
						}
						else
						{
							value.currentPressed = gameObject2;
							ExecuteEvents.Execute(gameObject2, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerClickHandler);
						}
						if (gameObject2 != null)
						{
							value.pointerEvent.pointerPress = gameObject2;
							value.currentPressed = gameObject2;
							Select(value.currentPressed);
							if ((bool)csMainSceneAudioPlayer.instance)
							{
								csMainSceneAudioPlayer.instance.PlayAudio2D("Click");
							}
						}
						ExecuteEvents.Execute(value.currentPressed, value.pointerEvent, ExecuteEvents.beginDragHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.beginDragHandler);
						value.pointerEvent.pointerDrag = value.currentPressed;
						value.currentDragging = value.currentPressed;
					}
				}
				if (key.ButtonUp())
				{
					if (value.currentDragging != null)
					{
						value.pointerEvent.current = value.currentDragging;
						ExecuteEvents.Execute(value.currentDragging, value.pointerEvent, ExecuteEvents.endDragHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.endDragHandler);
						if (value.currentPoint != null)
						{
							ExecuteEvents.ExecuteHierarchy(value.currentPoint, value.pointerEvent, ExecuteEvents.dropHandler);
						}
						value.pointerEvent.pointerDrag = null;
						value.currentDragging = null;
					}
					if ((bool)value.currentPressed)
					{
						value.pointerEvent.current = value.currentPressed;
						ExecuteEvents.Execute(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerUpHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerUpHandler);
						value.pointerEvent.rawPointerPress = null;
						value.pointerEvent.pointerPress = null;
						value.currentPressed = null;
					}
				}
				if (value.currentDragging != null)
				{
					value.pointerEvent.current = value.currentPressed;
					ExecuteEvents.Execute(value.currentDragging, value.pointerEvent, ExecuteEvents.dragHandler);
					ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.dragHandler);
				}
				if (base.eventSystem.currentSelectedGameObject != null)
				{
					value.pointerEvent.current = base.eventSystem.currentSelectedGameObject;
					ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
				}
			}
		}
	}
	public class ViveUILaserPointer : IUILaserPointer
	{
		private bool _connected;

		public csControllerforPicoXR RayControllerXR;

		protected override void Initialize()
		{
			base.Initialize();
			_connected = true;
		}

		public override bool ButtonDown()
		{
			if (!_connected)
			{
				return false;
			}
			if (csGameSettings.isLoading)
			{
				return false;
			}
			if (!RayControllerXR.GetTriggerDown())
			{
				return Input.GetKeyDown(KeyCode.P);
			}
			return true;
		}

		public override bool ButtonUp()
		{
			if (!_connected)
			{
				return false;
			}
			if (!RayControllerXR.GetTriggerUp())
			{
				return Input.GetKeyUp(KeyCode.P);
			}
			return true;
		}

		public override void OnEnterControl(GameObject control)
		{
			_ = _connected;
		}

		public override void OnExitControl(GameObject control)
		{
			_ = _connected;
		}
	}
}
namespace VRKeyboard.Utils
{
	public class GazeRaycaster : MonoBehaviour
	{
		public float delayInSeconds = 0.5f;

		public float loadingTime;

		public Image circle;

		private string lastTargetName = "";

		private Coroutine gazeControl;

		private void FixedUpdate()
		{
			Vector3 direction = base.transform.TransformDirection(Vector3.forward);
			if (Physics.Raycast(base.transform.position, direction, out var hitInfo))
			{
				if (hitInfo.transform.tag == "VRGazeInteractable")
				{
					if (!(lastTargetName == hitInfo.transform.name))
					{
						if (lastTargetName == "")
						{
							lastTargetName = hitInfo.transform.name;
						}
						if (hitInfo.transform.name != lastTargetName)
						{
							circle.fillAmount = 0f;
							lastTargetName = hitInfo.transform.name;
						}
						if (gazeControl != null)
						{
							StopCoroutine(gazeControl);
						}
						gazeControl = StartCoroutine(FillCircle(hitInfo.transform));
					}
				}
				else
				{
					if (gazeControl != null)
					{
						StopCoroutine(gazeControl);
					}
					ResetGazer();
				}
			}
			else
			{
				if (gazeControl != null)
				{
					StopCoroutine(gazeControl);
				}
				ResetGazer();
			}
		}

		private IEnumerator FillCircle(Transform target)
		{
			float timer = 0f;
			circle.fillAmount = 0f;
			yield return new WaitForSeconds(delayInSeconds);
			while (timer < loadingTime)
			{
				timer += Time.deltaTime;
				circle.fillAmount = timer / loadingTime;
				yield return null;
			}
			circle.fillAmount = 1f;
			if ((bool)target.GetComponent<Button>())
			{
				target.GetComponent<Button>().onClick.Invoke();
			}
			ResetGazer();
		}

		private void ResetGazer()
		{
			if (circle == null)
			{
				UnityEngine.Debug.LogError("Please assign target loading image, (ie. circle image)");
				return;
			}
			circle.fillAmount = 0f;
			lastTargetName = "";
		}
	}
	public class KeyboardManager : MonoBehaviour
	{
		[Header("User defined")]
		[Tooltip("If the character is uppercase at the initialization")]
		public bool isUppercase;

		public int maxInputLength;

		[Header("UI Elements")]
		public TextMeshProUGUI inputText;

		[Header("Essentials")]
		public Transform keys;

		public Transform litleKeys;

		public List<Transform> keyParents = new List<Transform>();

		private Key[] keyList;

		private bool capslockFlag;

		private string Input
		{
			get
			{
				return inputText.text;
			}
			set
			{
				inputText.text = value;
			}
		}

		private void Awake()
		{
			keyList = keys.GetComponentsInChildren<Key>();
			for (int i = 0; i < keyParents.Count; i++)
			{
				AddKeysByParent(keyParents[i]);
			}
		}

		private void AddKeysByParent(Transform parentTrans)
		{
			Key[] componentsInChildren = parentTrans.GetComponentsInChildren<Key>();
			List<Key> list = new List<Key>();
			for (int i = 0; i < keyList.Length; i++)
			{
				list.Add(keyList[i]);
			}
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				list.Add(componentsInChildren[j]);
			}
			keyList = list.ToArray();
		}

		private void AddLitleKeyBoard()
		{
			Key[] componentsInChildren = litleKeys.GetComponentsInChildren<Key>();
			List<Key> list = new List<Key>();
			for (int i = 0; i < keyList.Length; i++)
			{
				list.Add(keyList[i]);
			}
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				list.Add(componentsInChildren[j]);
			}
			keyList = list.ToArray();
		}

		private void Start()
		{
			Key[] array = keyList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnKeyClicked += GenerateInput;
			}
			capslockFlag = isUppercase;
			inputText.text = "";
		}

		public void Backspace()
		{
			if (Input.Length > 0)
			{
				Input = Input.Remove(Input.Length - 1);
			}
		}

		public void Clear()
		{
			Input = "";
		}

		public void CapsLock()
		{
			capslockFlag = !capslockFlag;
			Key[] array = keyList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].CapsLock(capslockFlag);
			}
		}

		public void Shift()
		{
			Key[] array = keyList;
			foreach (Key key in array)
			{
				if (key is Shift)
				{
					key.ShiftKey();
				}
			}
		}

		public void GenerateInput(string s)
		{
			if (Input.Length <= maxInputLength)
			{
				Input += s;
			}
		}
	}
	public class Alphabet : Key
	{
		public override void CapsLock(bool isUppercase)
		{
			if (isUppercase)
			{
				key.text = key.text.ToUpper();
			}
			else
			{
				key.text = key.text.ToLower();
			}
		}
	}
	public class CapsKey : Alphabet
	{
		public Image image;

		public List<Sprite> SprList = new List<Sprite>();

		private new void Awake()
		{
		}

		public override void CapsLock(bool isUppercase)
		{
			if (isUppercase)
			{
				image.sprite = SprList[1];
			}
			else
			{
				image.sprite = SprList[0];
			}
		}
	}
	public class Key : MonoBehaviour
	{
		public delegate void OnKeyClickedHandler(string key);

		protected TextMeshProUGUI key;

		public event OnKeyClickedHandler OnKeyClicked;

		public virtual void Awake()
		{
			key = base.transform.Find("Text (TMP)").GetComponent<TextMeshProUGUI>();
			GetComponent<Button>().onClick.AddListener(delegate
			{
				this.OnKeyClicked(key.text);
			});
		}

		public virtual void CapsLock(bool isUppercase)
		{
		}

		public virtual void ShiftKey()
		{
		}
	}
	public class Number : Key
	{
	}
	public class Shift : Key
	{
		private TextMeshProUGUI subscript;

		public override void Awake()
		{
			base.Awake();
			if (base.transform.Find("Subscript") != null)
			{
				subscript = base.transform.Find("Subscript").GetComponent<TextMeshProUGUI>();
			}
		}

		public override void ShiftKey()
		{
		}

		public override void CapsLock(bool isUppercase)
		{
			if (isUppercase)
			{
				key.text = key.text.ToUpper();
			}
			else
			{
				key.text = key.text.ToLower();
			}
		}
	}
	public class Symbol : Key
	{
	}
}
namespace System.Numerics
{
	[Serializable]
	public struct Complex : IEquatable<Complex>, IFormattable
	{
		private double m_real;

		private double m_imaginary;

		private const double LOG_10_INV = 0.43429448190325;

		public static readonly Complex Zero = new Complex(0.0, 0.0);

		public static readonly Complex One = new Complex(1.0, 0.0);

		public static readonly Complex ImaginaryOne = new Complex(0.0, 1.0);

		public double Real => m_real;

		public double Imaginary => m_imaginary;

		public double Magnitude => Abs(this);

		public double Phase => Math.Atan2(m_imaginary, m_real);

		public Complex(double real, double imaginary)
		{
			m_real = real;
			m_imaginary = imaginary;
		}

		public static Complex FromPolarCoordinates(double magnitude, double phase)
		{
			return new Complex(magnitude * Math.Cos(phase), magnitude * Math.Sin(phase));
		}

		public static Complex Negate(Complex value)
		{
			return -value;
		}

		public static Complex Add(Complex left, Complex right)
		{
			return left + right;
		}

		public static Complex Subtract(Complex left, Complex right)
		{
			return left - right;
		}

		public static Complex Multiply(Complex left, Complex right)
		{
			return left * right;
		}

		public static Complex Divide(Complex dividend, Complex divisor)
		{
			return dividend / divisor;
		}

		public static Complex operator -(Complex value)
		{
			return new Complex(0.0 - value.m_real, 0.0 - value.m_imaginary);
		}

		public static Complex operator +(Complex left, Complex right)
		{
			return new Complex(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary);
		}

		public static Complex operator -(Complex left, Complex right)
		{
			return new Complex(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary);
		}

		public static Complex operator *(Complex left, Complex right)
		{
			double real = left.m_real * right.m_real - left.m_imaginary * right.m_imaginary;
			double imaginary = left.m_imaginary * right.m_real + left.m_real * right.m_imaginary;
			return new Complex(real, imaginary);
		}

		public static Complex operator /(Complex left, Complex right)
		{
			double real = left.m_real;
			double imaginary = left.m_imaginary;
			double real2 = right.m_real;
			double imaginary2 = right.m_imaginary;
			if (Math.Abs(imaginary2) < Math.Abs(real2))
			{
				double num = imaginary2 / real2;
				return new Complex((real + imaginary * num) / (real2 + imaginary2 * num), (imaginary - real * num) / (real2 + imaginary2 * num));
			}
			double num2 = real2 / imaginary2;
			return new Complex((imaginary + real * num2) / (imaginary2 + real2 * num2), (0.0 - real + imaginary * num2) / (imaginary2 + real2 * num2));
		}

		public static double Abs(Complex value)
		{
			if (double.IsInfinity(value.m_real) || double.IsInfinity(value.m_imaginary))
			{
				return double.PositiveInfinity;
			}
			double num = Math.Abs(value.m_real);
			double num2 = Math.Abs(value.m_imaginary);
			if (num > num2)
			{
				double num3 = num2 / num;
				return num * Math.Sqrt(1.0 + num3 * num3);
			}
			if (num2 == 0.0)
			{
				return num;
			}
			double num4 = num / num2;
			return num2 * Math.Sqrt(1.0 + num4 * num4);
		}

		public static Complex Conjugate(Complex value)
		{
			return new Complex(value.m_real, 0.0 - value.m_imaginary);
		}

		public static Complex Reciprocal(Complex value)
		{
			if (value.m_real == 0.0 && value.m_imaginary == 0.0)
			{
				return Zero;
			}
			return One / value;
		}

		public static bool operator ==(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary == right.m_imaginary;
			}
			return false;
		}

		public static bool operator !=(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary != right.m_imaginary;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Complex))
			{
				return false;
			}
			return this == (Complex)obj;
		}

		public bool Equals(Complex value)
		{
			if (m_real.Equals(value.m_real))
			{
				return m_imaginary.Equals(value.m_imaginary);
			}
			return false;
		}

		public static implicit operator Complex(short value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(int value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(long value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(ushort value)
		{
			return new Complex((int)value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(uint value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(ulong value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(sbyte value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(byte value)
		{
			return new Complex((int)value, 0.0);
		}

		public static implicit operator Complex(float value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(double value)
		{
			return new Complex(value, 0.0);
		}

		public static explicit operator Complex(decimal value)
		{
			return new Complex((double)value, 0.0);
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", m_real, m_imaginary);
		}

		public string ToString(string format)
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", m_real.ToString(format, CultureInfo.CurrentCulture), m_imaginary.ToString(format, CultureInfo.CurrentCulture));
		}

		public string ToString(IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", m_real, m_imaginary);
		}

		public string ToString(string format, IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", m_real.ToString(format, provider), m_imaginary.ToString(format, provider));
		}

		public override int GetHashCode()
		{
			int num = 99999997;
			int num2 = m_real.GetHashCode() % num;
			int hashCode = m_imaginary.GetHashCode();
			return num2 ^ hashCode;
		}

		public static Complex Sin(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sin(real) * Math.Cosh(imaginary), Math.Cos(real) * Math.Sinh(imaginary));
		}

		public static Complex Sinh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sinh(real) * Math.Cos(imaginary), Math.Cosh(real) * Math.Sin(imaginary));
		}

		public static Complex Asin(Complex value)
		{
			return -ImaginaryOne * Log(ImaginaryOne * value + Sqrt(One - value * value));
		}

		public static Complex Cos(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cos(real) * Math.Cosh(imaginary), 0.0 - Math.Sin(real) * Math.Sinh(imaginary));
		}

		public static Complex Cosh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cosh(real) * Math.Cos(imaginary), Math.Sinh(real) * Math.Sin(imaginary));
		}

		public static Complex Acos(Complex value)
		{
			return -ImaginaryOne * Log(value + ImaginaryOne * Sqrt(One - value * value));
		}

		public static Complex Tan(Complex value)
		{
			return Sin(value) / Cos(value);
		}

		public static Complex Tanh(Complex value)
		{
			return Sinh(value) / Cosh(value);
		}

		public static Complex Atan(Complex value)
		{
			Complex complex = new Complex(2.0, 0.0);
			return ImaginaryOne / complex * (Log(One - ImaginaryOne * value) - Log(One + ImaginaryOne * value));
		}

		public static Complex Log(Complex value)
		{
			return new Complex(Math.Log(Abs(value)), Math.Atan2(value.m_imaginary, value.m_real));
		}

		public static Complex Log(Complex value, double baseValue)
		{
			return Log(value) / Log(baseValue);
		}

		public static Complex Log10(Complex value)
		{
			return Scale(Log(value), 0.43429448190325);
		}

		public static Complex Exp(Complex value)
		{
			double num = Math.Exp(value.m_real);
			double real = num * Math.Cos(value.m_imaginary);
			double imaginary = num * Math.Sin(value.m_imaginary);
			return new Complex(real, imaginary);
		}

		public static Complex Sqrt(Complex value)
		{
			return FromPolarCoordinates(Math.Sqrt(value.Magnitude), value.Phase / 2.0);
		}

		public static Complex Pow(Complex value, Complex power)
		{
			if (power == Zero)
			{
				return One;
			}
			if (value == Zero)
			{
				return Zero;
			}
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			double real2 = power.m_real;
			double imaginary2 = power.m_imaginary;
			double num = Abs(value);
			double num2 = Math.Atan2(imaginary, real);
			double num3 = real2 * num2 + imaginary2 * Math.Log(num);
			double num4 = Math.Pow(num, real2) * Math.Pow(Math.E, (0.0 - imaginary2) * num2);
			return new Complex(num4 * Math.Cos(num3), num4 * Math.Sin(num3));
		}

		public static Complex Pow(Complex value, double power)
		{
			return Pow(value, new Complex(power, 0.0));
		}

		private static Complex Scale(Complex value, double factor)
		{
			double real = factor * value.m_real;
			double imaginary = factor * value.m_imaginary;
			return new Complex(real, imaginary);
		}
	}
}
namespace DSPLib
{
	public class DFT
	{
		private double mDFTScale;

		private uint mLengthTotal;

		private uint mLengthHalf;

		private double[,] mCosTerm;

		private double[,] mSinTerm;

		private bool mOutOfMemory;

		public bool IsUsingCached
		{
			get
			{
				return !mOutOfMemory;
			}
			private set
			{
			}
		}

		public void Initialize(uint inputDataLength, uint zeroPaddingLength = 0u, bool forceNoCache = false)
		{
			mLengthTotal = inputDataLength + zeroPaddingLength;
			mLengthHalf = mLengthTotal / 2 + 1;
			mDFTScale = Math.Sqrt(2.0) / (double)(inputDataLength + zeroPaddingLength);
			mDFTScale *= (double)(inputDataLength + zeroPaddingLength) / (double)inputDataLength;
			if (forceNoCache)
			{
				mOutOfMemory = true;
				return;
			}
			mOutOfMemory = false;
			try
			{
				mCosTerm = new double[mLengthTotal, mLengthTotal];
				mSinTerm = new double[mLengthTotal, mLengthTotal];
				double num = Math.PI * 2.0 / (double)mLengthTotal;
				for (int i = 0; i < mLengthHalf; i++)
				{
					double num2 = (double)i * num;
					for (int j = 0; j < mLengthTotal; j++)
					{
						mCosTerm[i, j] = Math.Cos(num2 * (double)j) * mDFTScale;
						mSinTerm[i, j] = Math.Sin(num2 * (double)j) * mDFTScale;
					}
				}
			}
			catch (OutOfMemoryException)
			{
				mOutOfMemory = true;
			}
		}

		public Complex[] Execute(double[] timeSeries)
		{
			double[] array = new double[mLengthTotal];
			Array.Copy(timeSeries, array, timeSeries.Length);
			if (mOutOfMemory)
			{
				return Dft(array);
			}
			return DftCached(array);
		}

		private Complex[] Dft(double[] timeSeries)
		{
			uint num = mLengthTotal;
			uint num2 = mLengthHalf;
			double[] array = new double[num2];
			double[] array2 = new double[num2];
			Complex[] array3 = new Complex[num2];
			double num3 = Math.PI * 2.0 / (double)num;
			for (uint num4 = 0u; num4 < num2; num4++)
			{
				double num5 = (double)num4 * num3;
				for (uint num6 = 0u; num6 < num; num6++)
				{
					array[num4] += timeSeries[num6] * Math.Cos(num5 * (double)num6) * mDFTScale;
					array2[num4] -= timeSeries[num6] * Math.Sin(num5 * (double)num6) * mDFTScale;
				}
				array3[num4] = new Complex(array[num4], array2[num4]);
			}
			array3[0] = new Complex(array3[0].Real / Math.Sqrt(2.0), 0.0);
			array3[mLengthHalf - 1] = new Complex(array3[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array3;
		}

		private Complex[] DftCached(double[] timeSeries)
		{
			uint num = mLengthTotal;
			uint num2 = mLengthHalf;
			double[] array = new double[num2];
			double[] array2 = new double[num2];
			Complex[] array3 = new Complex[num2];
			for (uint num3 = 0u; num3 < num2; num3++)
			{
				for (uint num4 = 0u; num4 < num; num4++)
				{
					array[num3] += timeSeries[num4] * mCosTerm[num3, num4];
					array2[num3] -= timeSeries[num4] * mSinTerm[num3, num4];
				}
				array3[num3] = new Complex(array[num3], array2[num3]);
			}
			array3[0] = new Complex(array3[0].Real / Math.Sqrt(2.0), 0.0);
			array3[mLengthHalf - 1] = new Complex(array3[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array3;
		}

		public double[] FrequencySpan(double samplingFrequencyHz)
		{
			uint num = mLengthHalf;
			double[] array = new double[num];
			double num2 = samplingFrequencyHz / 2.0 / ((double)num - 1.0);
			for (uint num3 = 0u; num3 < num; num3++)
			{
				array[num3] += num2 * (double)num3;
			}
			return array;
		}
	}
	public class FFT
	{
		private class FFTElement
		{
			public double re;

			public double im;

			public FFTElement next;

			public uint revTgt;
		}

		private double mFFTScale = 1.0;

		private uint mLogN;

		private uint mN;

		private uint mLengthTotal;

		private uint mLengthHalf;

		private FFTElement[] mX;

		public void Initialize(uint inputDataLength, uint zeroPaddingLength = 0u)
		{
			mN = inputDataLength;
			bool flag = false;
			for (mLogN = 1u; mLogN <= 32; mLogN++)
			{
				double num = Math.Pow(2.0, mLogN);
				if ((double)(inputDataLength + zeroPaddingLength) == num)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				throw new ArgumentOutOfRangeException("inputDataLength + zeroPaddingLength was not an even power of 2! FFT cannot continue.");
			}
			mLengthTotal = inputDataLength + zeroPaddingLength;
			mLengthHalf = mLengthTotal / 2 + 1;
			mFFTScale = Math.Sqrt(2.0) / (double)mLengthTotal;
			mFFTScale *= (double)mLengthTotal / (double)inputDataLength;
			mX = new FFTElement[mLengthTotal];
			for (uint num2 = 0u; num2 < mLengthTotal; num2++)
			{
				mX[num2] = new FFTElement();
			}
			for (uint num3 = 0u; num3 < mLengthTotal - 1; num3++)
			{
				mX[num3].next = mX[num3 + 1];
			}
			for (uint num4 = 0u; num4 < mLengthTotal; num4++)
			{
				mX[num4].revTgt = BitReverse(num4, mLogN);
			}
		}

		public Complex[] Execute(double[] timeSeries)
		{
			uint num = mLengthTotal >> 1;
			uint num2 = mLengthTotal >> 1;
			uint num3 = mLengthTotal;
			uint num4 = 1u;
			FFTElement fFTElement = mX[0];
			uint num5 = 0u;
			for (uint num6 = 0u; num6 < mN; num6++)
			{
				fFTElement.re = timeSeries[num5];
				fFTElement.im = 0.0;
				fFTElement = fFTElement.next;
				num5++;
			}
			if (mN != mLengthTotal)
			{
				for (uint num7 = mN; num7 < mLengthTotal; num7++)
				{
					fFTElement.re = 0.0;
					fFTElement.im = 0.0;
					fFTElement = fFTElement.next;
				}
			}
			for (uint num8 = 0u; num8 < mLogN; num8++)
			{
				double num9 = (double)num4 * -2.0 * Math.PI / (double)mLengthTotal;
				double num10 = Math.Cos(num9);
				double num11 = Math.Sin(num9);
				for (uint num12 = 0u; num12 < mLengthTotal; num12 += num3)
				{
					FFTElement fFTElement2 = mX[num12];
					FFTElement fFTElement3 = mX[num12 + num2];
					double num13 = 1.0;
					double num14 = 0.0;
					for (uint num15 = 0u; num15 < num; num15++)
					{
						double re = fFTElement2.re;
						double im = fFTElement2.im;
						double re2 = fFTElement3.re;
						double im2 = fFTElement3.im;
						fFTElement2.re = re + re2;
						fFTElement2.im = im + im2;
						re2 = re - re2;
						im2 = im - im2;
						fFTElement3.re = re2 * num13 - im2 * num14;
						fFTElement3.im = re2 * num14 + im2 * num13;
						fFTElement2 = fFTElement2.next;
						fFTElement3 = fFTElement3.next;
						double num16 = num13;
						num13 = num13 * num10 - num14 * num11;
						num14 = num16 * num11 + num14 * num10;
					}
				}
				num >>= 1;
				num2 >>= 1;
				num3 >>= 1;
				num4 <<= 1;
			}
			fFTElement = mX[0];
			Complex[] array = new Complex[mLengthTotal];
			while (fFTElement != null)
			{
				uint revTgt = fFTElement.revTgt;
				array[revTgt] = new Complex(fFTElement.re * mFFTScale, fFTElement.im * mFFTScale);
				fFTElement = fFTElement.next;
			}
			Complex[] array2 = new Complex[mLengthHalf];
			Array.Copy(array, array2, mLengthHalf);
			array2[0] = new Complex(array2[0].Real / Math.Sqrt(2.0), 0.0);
			array2[mLengthHalf - 1] = new Complex(array2[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array2;
		}

		private uint BitReverse(uint x, uint numBits)
		{
			uint num = 0u;
			for (uint num2 = 0u; num2 < numBits; num2++)
			{
				num <<= 1;
				num |= x & 1u;
				x >>= 1;
			}
			return num;
		}

		public double[] FrequencySpan(double samplingFrequencyHz)
		{
			uint num = mLengthHalf;
			double[] array = new double[num];
			double num2 = samplingFrequencyHz / 2.0 / ((double)num - 1.0);
			for (int i = 0; i < num; i++)
			{
				array[i] += num2 * (double)i;
			}
			return array;
		}
	}
	public class DSP
	{
		public static class Generate
		{
			private static System.Random mRandom = new System.Random();

			public static double[] LinSpace(double startVal, double stopVal, uint points)
			{
				double[] array = new double[points];
				double num = (stopVal - startVal) / ((double)points - 1.0);
				for (uint num2 = 0u; num2 < points; num2++)
				{
					array[num2] = startVal + num * (double)num2;
				}
				return array;
			}

			public static double[] ToneSampling(double amplitudeVrms, double frequencyHz, double samplingFrequencyHz, uint points, double dcV = 0.0, double phaseDeg = 0.0)
			{
				double num = phaseDeg * System.Math.PI / 180.0;
				System.Math.Sqrt(2.0);
				double[] array = new double[points];
				for (uint num2 = 0u; num2 < points; num2++)
				{
					double num3 = (double)num2 / samplingFrequencyHz;
					array[num2] = System.Math.Sqrt(2.0) * amplitudeVrms * System.Math.Sin(System.Math.PI * 2.0 * num3 * frequencyHz + num) + dcV;
				}
				return array;
			}

			public static double[] ToneCycles(double amplitudeVrms, double cycles, uint points, double dcV = 0.0, double phaseDeg = 0.0)
			{
				double num = phaseDeg * System.Math.PI / 180.0;
				double num2 = System.Math.Sqrt(2.0) * amplitudeVrms;
				double[] array = new double[points];
				for (uint num3 = 0u; num3 < points; num3++)
				{
					array[num3] = num2 * System.Math.Sin(System.Math.PI * 2.0 * (double)num3 / (double)points * cycles + num) + dcV;
				}
				return array;
			}

			public static double[] NoisePsd(double amplitudePsd, double samplingFrequencyHz, uint points)
			{
				return NoiseRms(amplitudePsd * System.Math.Sqrt(samplingFrequencyHz / 2.0), points);
			}

			public static double[] NoiseRms(double amplitudeVrms, uint points, double dcV = 0.0)
			{
				_ = new double[points];
				return Math.Add(Noise(points, amplitudeVrms), dcV);
			}

			private static double[] Noise(uint size, double scaling_vrms)
			{
				double[] array = new double[size];
				double num = 0.0;
				for (uint num2 = 0u; num2 < size; num2++)
				{
					double num3;
					double num5;
					do
					{
						num3 = 2.0 * mRandom.NextDouble() - 1.0;
						double num4 = 2.0 * mRandom.NextDouble() - 1.0;
						num5 = num3 * num3 + num4 * num4;
					}
					while (num5 >= 1.0);
					if (num5 == 0.0)
					{
						array[num2] = 0.0;
					}
					else
					{
						array[num2] = num3 * System.Math.Sqrt(-2.0 * System.Math.Log(num5) / num5) * scaling_vrms;
					}
					num += array[num2];
				}
				double num6 = num / (double)size;
				for (uint num7 = 0u; num7 < size; num7++)
				{
					array[num7] -= num6;
				}
				return array;
			}
		}

		public static class Window
		{
			public enum Type
			{
				None,
				Rectangular,
				Welch,
				Bartlett,
				Hanning,
				Hann,
				Hamming,
				Nutall3,
				Nutall4,
				Nutall3A,
				Nutall3B,
				Nutall4A,
				BH92,
				Nutall4B,
				SFT3F,
				SFT3M,
				FTNI,
				SFT4F,
				SFT5F,
				SFT4M,
				FTHP,
				HFT70,
				FTSRS,
				SFT5M,
				HFT90D,
				HFT95,
				HFT116D,
				HFT144D,
				HFT169D,
				HFT196D,
				HFT223D,
				HFT248D
			}

			public static class ScaleFactor
			{
				public static double Signal(double[] windowCoefficients)
				{
					double num = 0.0;
					foreach (double num2 in windowCoefficients)
					{
						num += num2;
					}
					num /= (double)windowCoefficients.Length;
					return 1.0 / num;
				}

				public static double Noise(double[] windowCoefficients, double samplingFrequencyHz)
				{
					double num = 0.0;
					foreach (double num2 in windowCoefficients)
					{
						num += num2 * num2;
					}
					double num3 = windowCoefficients.Length;
					double num4 = samplingFrequencyHz / num3;
					return System.Math.Sqrt(1.0 / (num / num3 * num4));
				}

				public static double NENBW(double[] windowCoefficients)
				{
					double num = 0.0;
					double num2 = 0.0;
					foreach (double num3 in windowCoefficients)
					{
						num += num3;
						num2 += num3 * num3;
					}
					double num4 = windowCoefficients.Length;
					num /= num4;
					return num2 / (num * num) / num4;
				}
			}

			public static double[] Coefficients(Type windowName, uint points)
			{
				double[] array = new double[points];
				double num = points;
				switch (windowName)
				{
				case Type.None:
				case Type.Rectangular:
				{
					for (uint num3 = 0u; num3 < points; num3++)
					{
						array[num3] = 1.0;
					}
					break;
				}
				case Type.Bartlett:
				{
					for (uint num4 = 0u; num4 < points; num4++)
					{
						array[num4] = 2.0 / num * (num / 2.0 - System.Math.Abs((double)num4 - (num - 1.0) / 2.0));
					}
					break;
				}
				case Type.Welch:
				{
					for (uint num2 = 0u; num2 < points; num2++)
					{
						array[num2] = 1.0 - System.Math.Pow(2.0 * (double)num2 / num - 1.0, 2.0);
					}
					break;
				}
				case Type.Hanning:
				case Type.Hann:
					array = SineExpansion(points, 0.5, -0.5);
					break;
				case Type.Hamming:
					array = SineExpansion(points, 0.54, -0.46);
					break;
				case Type.BH92:
					array = SineExpansion(points, 287.0 / 800.0, -0.48829, 0.14128, -0.01168);
					break;
				case Type.Nutall3:
					array = SineExpansion(points, 0.375, -0.5, 0.125);
					break;
				case Type.Nutall3A:
					array = SineExpansion(points, 0.40897, -0.5, 0.09103);
					break;
				case Type.Nutall3B:
					array = SineExpansion(points, 0.4243801, -0.4973406, 0.0782793);
					break;
				case Type.Nutall4:
					array = SineExpansion(points, 0.3125, -15.0 / 32.0, 0.1875, -1.0 / 32.0);
					break;
				case Type.Nutall4A:
					array = SineExpansion(points, 0.338946, -0.481973, 0.161054, -0.018027);
					break;
				case Type.Nutall4B:
					array = SineExpansion(points, 0.355768, -0.487396, 0.144232, -0.012604);
					break;
				case Type.SFT3F:
					array = SineExpansion(points, 0.26526, -0.5, 0.23474);
					break;
				case Type.SFT4F:
					array = SineExpansion(points, 0.21706, -0.42103, 0.28294, -0.07897);
					break;
				case Type.SFT5F:
					array = SineExpansion(points, 0.1881, -0.36923, 0.28702, -0.13077, 0.02488);
					break;
				case Type.SFT3M:
					array = SineExpansion(points, 0.28235, -0.52105, 0.19659);
					break;
				case Type.SFT4M:
					array = SineExpansion(points, 0.241906, -0.460841, 0.255381, -0.041872);
					break;
				case Type.SFT5M:
					array = SineExpansion(points, 0.209671, -0.407331, 0.281225, -0.092669, 0.0091036);
					break;
				case Type.FTNI:
					array = SineExpansion(points, 0.2810639, -0.5208972, 0.1980399);
					break;
				case Type.FTHP:
					array = SineExpansion(points, 1.0, -1.912510941, 1.079173272, -0.1832630879);
					break;
				case Type.HFT70:
					array = SineExpansion(points, 1.0, -1.90796, 1.07349, -0.18199);
					break;
				case Type.FTSRS:
					array = SineExpansion(points, 1.0, -1.93, 1.29, -0.388, 0.028);
					break;
				case Type.HFT90D:
					array = SineExpansion(points, 1.0, -1.942604, 1.340318, -0.440811, 0.043097);
					break;
				case Type.HFT95:
					array = SineExpansion(points, 1.0, -1.9383379, 1.3045202, -0.402827, 0.0350665);
					break;
				case Type.HFT116D:
					array = SineExpansion(points, 1.0, -1.9575375, 1.4780705, -0.6367431, 0.1228389, -0.0066288);
					break;
				case Type.HFT144D:
					array = SineExpansion(points, 1.0, -1.96760033, 1.57983607, -0.81123644, 0.22583558, -0.02773848, 0.0009036);
					break;
				case Type.HFT169D:
					array = SineExpansion(points, 1.0, -1.97441842, 1.65409888, -0.95788186, 0.3367342, -0.06364621, 0.00521942, -0.00010599);
					break;
				case Type.HFT196D:
					array = SineExpansion(points, 1.0, -1.97928042, 1.710288951, -1.081629853, 0.448734314, -0.112376628, 0.015122992, -0.000871252, 1.1896E-05);
					break;
				case Type.HFT223D:
					array = SineExpansion(points, 1.0, -1.98298997309, 1.75556083063, -1.19037717712, 0.56155440797, -0.17296769663, 0.03233247087, -0.00324954578, 0.0001380104, -1.32725E-06);
					break;
				case Type.HFT248D:
					array = SineExpansion(points, 1.0, -1.985844164102, 1.791176438506, -1.282075284005, 0.667777530266, -0.240160796576, 0.056656381764, -0.008134974479, 0.00062454465, -1.9808998E-05, 1.32974E-07);
					break;
				}
				return array;
			}

			private static double[] SineExpansion(uint points, double c0, double c1 = 0.0, double c2 = 0.0, double c3 = 0.0, double c4 = 0.0, double c5 = 0.0, double c6 = 0.0, double c7 = 0.0, double c8 = 0.0, double c9 = 0.0, double c10 = 0.0)
			{
				double[] array = new double[points];
				for (uint num = 0u; num < points; num++)
				{
					array[num] = System.Math.PI * 2.0 * (double)num / (double)points;
				}
				double[] array2 = new double[points];
				for (uint num2 = 0u; num2 < points; num2++)
				{
					double num3 = c0;
					num3 += c1 * System.Math.Cos(array[num2]);
					num3 += c2 * System.Math.Cos(2.0 * array[num2]);
					num3 += c3 * System.Math.Cos(3.0 * array[num2]);
					num3 += c4 * System.Math.Cos(4.0 * array[num2]);
					num3 += c5 * System.Math.Cos(5.0 * array[num2]);
					num3 += c6 * System.Math.Cos(6.0 * array[num2]);
					num3 += c7 * System.Math.Cos(7.0 * array[num2]);
					num3 += c8 * System.Math.Cos(8.0 * array[num2]);
					num3 += c9 * System.Math.Cos(9.0 * array[num2]);
					num3 += c10 * System.Math.Cos(10.0 * array[num2]);
					array2[num2] = num3;
				}
				return array2;
			}
		}

		public static class ConvertMagnitude
		{
			public static double[] ToMagnitudeSquared(double[] magnitude)
			{
				uint num = (uint)magnitude.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = magnitude[num2] * magnitude[num2];
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(double[] magnitude)
			{
				uint num = (uint)magnitude.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = magnitude[num2];
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 20.0 * System.Math.Log10(num3);
				}
				return array;
			}
		}

		public static class ConvertMagnitudeSquared
		{
			public static double[] ToMagnitude(double[] magSquared)
			{
				uint num = (uint)magSquared.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = System.Math.Sqrt(magSquared[num2]);
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(double[] magSquared)
			{
				uint num = (uint)magSquared.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = magSquared[num2];
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 10.0 * System.Math.Log10(num3);
				}
				return array;
			}
		}

		public static class ConvertComplex
		{
			public static double[] ToMagnitudeSquared(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double magnitude = rawFFT[num2].Magnitude;
					array[num2] = magnitude * magnitude;
				}
				return array;
			}

			public static double[] ToMagnitude(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = rawFFT[num2].Magnitude;
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = rawFFT[num2].Magnitude;
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 20.0 * System.Math.Log10(num3);
				}
				return array;
			}

			public static double[] ToPhaseDegrees(Complex[] rawFFT)
			{
				double num = 180.0 / System.Math.PI;
				uint num2 = (uint)rawFFT.Length;
				double[] array = new double[num2];
				for (uint num3 = 0u; num3 < num2; num3++)
				{
					array[num3] = rawFFT[num3].Phase * num;
				}
				return array;
			}

			public static double[] ToPhaseRadians(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = rawFFT[num2].Phase;
				}
				return array;
			}
		}

		public static class Analyze
		{
			public static double FindRms(double[] a, uint startBin = 10u, uint stopBin = 10u)
			{
				double num = 0.0;
				uint num2 = 0u;
				uint num3 = (uint)a.Length;
				for (uint num4 = 0u; num4 < num3; num4++)
				{
					if (num4 > startBin - 1 && num4 <= num3 - 1 - stopBin)
					{
						num += a[num4] * a[num4];
						num2++;
					}
				}
				return System.Math.Sqrt(num / (double)num2);
			}

			public static double FindMean(double[] inData, uint startBin = 10u, uint stopBin = 10u)
			{
				double num = 0.0;
				double num2 = inData.Length;
				uint num3 = 0u;
				for (uint num4 = 0u; (double)num4 < num2; num4++)
				{
					if (num4 > startBin - 1 && !((double)num4 > num2 - 1.0 - (double)stopBin))
					{
						num += inData[num4];
						num3++;
					}
				}
				return num / (double)num3;
			}

			public static double FindMaxAmplitude(double[] inData)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				for (uint num3 = 0u; (double)num3 < num; num3++)
				{
					if (inData[num3] > num2)
					{
						num2 = inData[num3];
					}
				}
				return num2;
			}

			public static uint FindMaxPosition(double[] inData)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				uint result = 0u;
				for (uint num3 = 0u; (double)num3 < num; num3++)
				{
					if (inData[num3] > num2)
					{
						result = num3;
						num2 = inData[num3];
					}
				}
				return result;
			}

			public static double FindMaxFrequency(double[] inData, double[] fSpan)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				uint num3 = 0u;
				for (uint num4 = 0u; (double)num4 < num; num4++)
				{
					if (inData[num4] > num2)
					{
						num3 = num4;
						num2 = inData[num4];
					}
				}
				return fSpan[num3];
			}

			public static double[] UnwrapPhaseDegrees(double[] inPhaseDeg)
			{
				uint num = (uint)inPhaseDeg.Length;
				double[] array = new double[num];
				double[] array2 = new double[num];
				inPhaseDeg.CopyTo(array2, 0);
				array[0] = array2[0];
				for (uint num2 = 1u; num2 < num; num2++)
				{
					if (System.Math.Abs(array2[num2 - 1] - array2[num2]) >= 180.0)
					{
						if (array2[num2 - 1] < 0.0)
						{
							for (uint num3 = num2; num3 < num; num3++)
							{
								array2[num3] += -360.0;
							}
						}
						else
						{
							for (uint num4 = num2; num4 < num; num4++)
							{
								array2[num4] += 360.0;
							}
						}
					}
					array[num2] = array2[num2];
				}
				return array;
			}

			public static double[] UnwrapPhaseRadians(double[] inPhaseRad)
			{
				double num = System.Math.PI;
				double num2 = System.Math.PI * 2.0;
				uint num3 = (uint)inPhaseRad.Length;
				double[] array = new double[num3];
				inPhaseRad.CopyTo(array, 0);
				double[] array2 = new double[num3];
				array2[0] = array[0];
				for (uint num4 = 1u; num4 < num3; num4++)
				{
					if (System.Math.Abs(array[num4 - 1] - array[num4]) >= num)
					{
						if (array[num4 - 1] < 0.0)
						{
							for (uint num5 = num4; num5 < num3; num5++)
							{
								array[num5] += 0.0 - num2;
							}
						}
						else
						{
							for (uint num6 = num4; num6 < num3; num6++)
							{
								array[num6] += num2;
							}
						}
					}
					array2[num4] = array[num4];
				}
				return array2;
			}
		}

		public static class Math
		{
			public static double[] Multiply(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * b[num];
				}
				return array;
			}

			public static double[] Multiply(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * b;
				}
				return array;
			}

			public static double[] Add(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] + b[num];
				}
				return array;
			}

			public static double[] Add(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] + b;
				}
				return array;
			}

			public static double[] Subtract(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] - b[num];
				}
				return array;
			}

			public static double[] Subtract(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] - b;
				}
				return array;
			}

			public static double[] Divide(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] / b[num];
				}
				return array;
			}

			public static double[] Divide(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] / b;
				}
				return array;
			}

			public static double[] Sqrt(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = System.Math.Sqrt(a[num]);
				}
				return array;
			}

			public static double[] Square(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * a[num];
				}
				return array;
			}

			public static double[] Log10(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					double num2 = a[num];
					if (num2 <= 0.0)
					{
						num2 = double.Epsilon;
					}
					array[num] = System.Math.Log10(num2);
				}
				return array;
			}

			public static double[] RemoveMean(double[] a)
			{
				double num = 0.0;
				for (uint num2 = 0u; num2 < a.Length; num2++)
				{
					num += a[num2];
				}
				double b = num / (double)a.Length;
				return Subtract(a, b);
			}
		}
	}
}
namespace DG.Tweening
{
	[AddComponentMenu("DOTween/DOTween Animation")]
	public class DOTweenAnimation : ABSAnimationComponent
	{
		public float delay;

		public float duration = 1f;

		public Ease easeType = Ease.OutQuad;

		public AnimationCurve easeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public LoopType loopType;

		public int loops = 1;

		public string id = "";

		public bool isRelative;

		public bool isFrom;

		public bool isIndependentUpdate;

		public bool autoKill = true;

		public bool isActive = true;

		public bool isValid;

		public Component target;

		public DOTweenAnimationType animationType;

		public TargetType targetType;

		public TargetType forcedTargetType;

		public bool autoPlay = true;

		public bool useTargetAsV3;

		public float endValueFloat;

		public Vector3 endValueV3;

		public Vector2 endValueV2;

		public Color endValueColor = new Color(1f, 1f, 1f, 1f);

		public string endValueString = "";

		public Rect endValueRect = new Rect(0f, 0f, 0f, 0f);

		public Transform endValueTransform;

		public bool optionalBool0;

		public float optionalFloat0;

		public int optionalInt0;

		public RotateMode optionalRotationMode;

		public ScrambleMode optionalScrambleMode;

		public string optionalString;

		private bool _tweenCreated;

		private int _playCount = -1;

		private void Awake()
		{
			if (isActive && isValid && (animationType != DOTweenAnimationType.Move || !useTargetAsV3))
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void Start()
		{
			if (!_tweenCreated)
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void OnDestroy()
		{
			if (tween != null && tween.IsActive())
			{
				tween.Kill();
			}
			tween = null;
		}

		public void CreateTween()
		{
			if (target == null)
			{
				UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's target is NULL, because the animation was created with a DOTween Pro version older than 0.9.255. To fix this, exit Play mode then simply select this object, and it will update automatically", base.gameObject);
				return;
			}
			if (forcedTargetType != 0)
			{
				targetType = forcedTargetType;
			}
			if (targetType == TargetType.Unset)
			{
				targetType = TypeToDOTargetType(target.GetType());
			}
			switch (animationType)
			{
			case DOTweenAnimationType.Move:
				if (useTargetAsV3)
				{
					isRelative = false;
					if (endValueTransform == null)
					{
						UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target is NULL, a Vector3 of (0,0,0) will be used instead", base.gameObject);
						endValueV3 = Vector3.zero;
					}
					else if (targetType == TargetType.RectTransform)
					{
						RectTransform rectTransform = endValueTransform as RectTransform;
						if (rectTransform == null)
						{
							UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target should be a RectTransform, a Vector3 of (0,0,0) will be used instead", base.gameObject);
							endValueV3 = Vector3.zero;
						}
						else
						{
							RectTransform rectTransform2 = target as RectTransform;
							if (rectTransform2 == null)
							{
								UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's target and TO target are not of the same type. Please reassign the values", base.gameObject);
							}
							else
							{
								endValueV3 = DOTweenUtils46.SwitchToRectTransform(rectTransform, rectTransform2);
							}
						}
					}
					else
					{
						endValueV3 = endValueTransform.position;
					}
				}
				switch (targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOAnchorPos3D(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.LocalMove:
				tween = base.transform.DOLocalMove(endValueV3, duration, optionalBool0);
				break;
			case DOTweenAnimationType.Rotate:
				switch (targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DORotate(endValueFloat, duration);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				}
				break;
			case DOTweenAnimationType.LocalRotate:
				tween = base.transform.DOLocalRotate(endValueV3, duration, optionalRotationMode);
				break;
			case DOTweenAnimationType.Scale:
				tween = base.transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration);
				break;
			case DOTweenAnimationType.UIWidthHeight:
				tween = ((RectTransform)target).DOSizeDelta(optionalBool0 ? new Vector2(endValueFloat, endValueFloat) : endValueV2, duration);
				break;
			case DOTweenAnimationType.Color:
				isRelative = false;
				switch (targetType)
				{
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOColor(endValueColor, duration);
					break;
				case TargetType.Image:
					tween = ((Image)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOColor(endValueColor, duration);
					break;
				}
				break;
			case DOTweenAnimationType.Fade:
				isRelative = false;
				switch (targetType)
				{
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOFade(endValueFloat, duration);
					break;
				case TargetType.Image:
					tween = ((Image)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOIntensity(endValueFloat, duration);
					break;
				case TargetType.CanvasGroup:
					tween = ((CanvasGroup)target).DOFade(endValueFloat, duration);
					break;
				}
				break;
			case DOTweenAnimationType.Text:
				if (targetType == TargetType.Text)
				{
					tween = ((Text)target).DOText(endValueString, duration, optionalBool0, optionalScrambleMode, optionalString);
				}
				break;
			case DOTweenAnimationType.PunchPosition:
				switch (targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.PunchScale:
				tween = base.transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.PunchRotation:
				tween = base.transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakePosition:
				switch (targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.ShakeScale:
				tween = base.transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakeRotation:
				tween = base.transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.CameraAspect:
				tween = ((Camera)target).DOAspect(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraBackgroundColor:
				tween = ((Camera)target).DOColor(endValueColor, duration);
				break;
			case DOTweenAnimationType.CameraFieldOfView:
				tween = ((Camera)target).DOFieldOfView(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraOrthoSize:
				tween = ((Camera)target).DOOrthoSize(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraPixelRect:
				tween = ((Camera)target).DOPixelRect(endValueRect, duration);
				break;
			case DOTweenAnimationType.CameraRect:
				tween = ((Camera)target).DORect(endValueRect, duration);
				break;
			}
			if (tween == null)
			{
				return;
			}
			if (isFrom)
			{
				((Tweener)tween).From(isRelative);
			}
			else
			{
				tween.SetRelative(isRelative);
			}
			tween.SetTarget(base.gameObject).SetDelay(delay).SetLoops(loops, loopType)
				.SetAutoKill(autoKill)
				.OnKill(delegate
				{
					tween = null;
				});
			if (isSpeedBased)
			{
				tween.SetSpeedBased();
			}
			if (easeType == Ease.INTERNAL_Custom)
			{
				tween.SetEase(easeCurve);
			}
			else
			{
				tween.SetEase(easeType);
			}
			if (!string.IsNullOrEmpty(id))
			{
				tween.SetId(id);
			}
			tween.SetUpdate(isIndependentUpdate);
			if (hasOnStart)
			{
				if (onStart != null)
				{
					tween.OnStart(onStart.Invoke);
				}
			}
			else
			{
				onStart = null;
			}
			if (hasOnPlay)
			{
				if (onPlay != null)
				{
					tween.OnPlay(onPlay.Invoke);
				}
			}
			else
			{
				onPlay = null;
			}
			if (hasOnUpdate)
			{
				if (onUpdate != null)
				{
					tween.OnUpdate(onUpdate.Invoke);
				}
			}
			else
			{
				onUpdate = null;
			}
			if (hasOnStepComplete)
			{
				if (onStepComplete != null)
				{
					tween.OnStepComplete(onStepComplete.Invoke);
				}
			}
			else
			{
				onStepComplete = null;
			}
			if (hasOnComplete)
			{
				if (onComplete != null)
				{
					tween.OnComplete(onComplete.Invoke);
				}
			}
			else
			{
				onComplete = null;
			}
			if (autoPlay)
			{
				tween.Play();
			}
			else
			{
				tween.Pause();
			}
			if (hasOnTweenCreated && onTweenCreated != null)
			{
				onTweenCreated.Invoke();
			}
		}

		public override void DOPlay()
		{
			DOTween.Play(base.gameObject);
		}

		public override void DOPlayBackwards()
		{
			DOTween.PlayBackwards(base.gameObject);
		}

		public override void DOPlayForward()
		{
			DOTween.PlayForward(base.gameObject);
		}

		public override void DOPause()
		{
			DOTween.Pause(base.gameObject);
		}

		public override void DOTogglePause()
		{
			DOTween.TogglePause(base.gameObject);
		}

		public override void DORewind()
		{
			_playCount = -1;
			DOTweenAnimation[] components = base.gameObject.GetComponents<DOTweenAnimation>();
			for (int num = components.Length - 1; num > -1; num--)
			{
				Tween tween = components[num].tween;
				if (tween != null && tween.IsInitialized())
				{
					components[num].tween.Rewind();
				}
			}
		}

		public override void DORestart(bool fromHere = false)
		{
			_playCount = -1;
			if (tween == null)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 1)
				{
					DG.Tweening.Core.Debugger.LogNullTween(tween);
				}
				return;
			}
			if (fromHere && isRelative)
			{
				ReEvaluateRelativeTween();
			}
			DOTween.Restart(base.gameObject);
		}

		public override void DOComplete()
		{
			DOTween.Complete(base.gameObject);
		}

		public override void DOKill()
		{
			DOTween.Kill(base.gameObject);
			tween = null;
		}

		public void DOPlayById(string id)
		{
			DOTween.Play(base.gameObject, id);
		}

		public void DOPlayAllById(string id)
		{
			DOTween.Play(id);
		}

		public void DOPlayNext()
		{
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			while (_playCount < components.Length - 1)
			{
				_playCount++;
				DOTweenAnimation dOTweenAnimation = components[_playCount];
				if (dOTweenAnimation != null && dOTweenAnimation.tween != null && !dOTweenAnimation.tween.IsPlaying() && !dOTweenAnimation.tween.IsComplete())
				{
					dOTweenAnimation.tween.Play();
					break;
				}
			}
		}

		public void DORewindAndPlayNext()
		{
			_playCount = -1;
			DOTween.Rewind(base.gameObject);
			DOPlayNext();
		}

		public void DORestartById(string id)
		{
			_playCount = -1;
			DOTween.Restart(base.gameObject, id);
		}

		public void DORestartAllById(string id)
		{
			_playCount = -1;
			DOTween.Restart(id);
		}

		public List<Tween> GetTweens()
		{
			return DOTween.TweensByTarget(base.gameObject);
		}

		public static TargetType TypeToDOTargetType(Type t)
		{
			string text = t.ToString();
			int num = text.LastIndexOf(".");
			if (num != -1)
			{
				text = text.Substring(num + 1);
			}
			if (text.IndexOf("Renderer") != -1 && text != "SpriteRenderer")
			{
				text = "Renderer";
			}
			return (TargetType)Enum.Parse(typeof(TargetType), text);
		}

		private void ReEvaluateRelativeTween()
		{
			if (animationType == DOTweenAnimationType.Move)
			{
				((Tweener)tween).ChangeEndValue(base.transform.position + endValueV3, snapStartValue: true);
			}
			else if (animationType == DOTweenAnimationType.LocalMove)
			{
				((Tweener)tween).ChangeEndValue(base.transform.localPosition + endValueV3, snapStartValue: true);
			}
		}
	}
	public static class DOTweenAnimationExtensions
	{
		public static bool IsSameOrSubclassOf<T>(this Component t)
		{
			return t is T;
		}
	}
}
namespace Microsoft.MixedReality.Toolkit.Rendering
{
	[ExecuteInEditMode]
	[AddComponentMenu("Scripts/MRTK/Core/DepthBufferRenderer")]
	public class DepthBufferRenderer : MonoBehaviour
	{
		[SerializeField]
		[Tooltip("If not null, depth buffer rendering output will blit to this RenderTexture. If null, normal operation will blit the depth buffer as color to the screen.")]
		private RenderTexture outputTexture;

		private const string DepthShaderName = "Mixed Reality Toolkit/Depth Buffer Viewer";

		public RenderTexture OutputTexture
		{
			get
			{
				return outputTexture;
			}
			set
			{
				outputTexture = value;
			}
		}
	}
	public interface IMaterialInstanceOwner
	{
		void OnMaterialChanged(MaterialInstance materialInstance);
	}
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Rendering/MaterialInstance.html")]
	[ExecuteAlways]
	[RequireComponent(typeof(Renderer))]
	[AddComponentMenu("Scripts/MRTK/Core/MaterialInstance")]
	public class MaterialInstance : MonoBehaviour
	{
		private Renderer cachedRenderer;

		[SerializeField]
		[HideInInspector]
		private Material[] defaultMaterials;

		private Material[] instanceMaterials;

		private bool initialized;

		private bool materialsInstanced;

		private readonly HashSet<UnityEngine.Object> materialOwners = new HashSet<UnityEngine.Object>();

		private const string instancePostfix = " (Instance)";

		public Material Material => AcquireMaterial();

		public Material[] Materials => AcquireMaterials();

		private Renderer CachedRenderer
		{
			get
			{
				if (cachedRenderer == null)
				{
					cachedRenderer = GetComponent<Renderer>();
				}
				return cachedRenderer;
			}
		}

		public Material AcquireMaterial(UnityEngine.Object owner = null, bool instance = true)
		{
			if (owner != null)
			{
				materialOwners.Add(owner);
			}
			if (instance)
			{
				AcquireInstances();
			}
			Material[] array = instanceMaterials;
			if (array != null && array.Length != 0)
			{
				return instanceMaterials[0];
			}
			return null;
		}

		public Material[] AcquireMaterials(UnityEngine.Object owner = null, bool instance = true)
		{
			if (owner != null)
			{
				materialOwners.Add(owner);
			}
			if (instance)
			{
				AcquireInstances();
			}
			return instanceMaterials;
		}

		public void ReleaseMaterial(UnityEngine.Object owner, bool autoDestroy = true)
		{
			materialOwners.Remove(owner);
			if (autoDestroy && materialOwners.Count == 0)
			{
				DestorySafe(this);
			}
		}

		private void Awake()
		{
			Initialize();
		}

		private void Update()
		{
			Material[] sharedMaterials = CachedRenderer.sharedMaterials;
			if (MaterialsMatch(sharedMaterials, instanceMaterials))
			{
				return;
			}
			Material[] array = new Material[sharedMaterials.Length];
			int num = Math.Min(array.Length, defaultMaterials.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = defaultMaterials[i];
			}
			for (int j = 0; j < array.Length; j++)
			{
				Material material = sharedMaterials[j];
				if (!IsInstanceMaterial(material))
				{
					array[j] = material;
				}
			}
			defaultMaterials = array;
			CreateInstances();
			foreach (UnityEngine.Object materialOwner in materialOwners)
			{
				(materialOwner as IMaterialInstanceOwner)?.OnMaterialChanged(this);
			}
		}

		private void OnDestroy()
		{
			if (CachedRenderer != null && defaultMaterials != null)
			{
				CachedRenderer.sharedMaterials = defaultMaterials;
			}
			DestroyMaterials(instanceMaterials);
			instanceMaterials = null;
		}

		private void Initialize()
		{
			if (!initialized && CachedRenderer != null)
			{
				if (!HasValidMaterial(defaultMaterials))
				{
					defaultMaterials = CachedRenderer.sharedMaterials;
				}
				else if (!materialsInstanced)
				{
					CachedRenderer.sharedMaterials = defaultMaterials;
				}
				initialized = true;
			}
		}

		private void AcquireInstances()
		{
			if (CachedRenderer != null && !MaterialsMatch(CachedRenderer.sharedMaterials, instanceMaterials))
			{
				CreateInstances();
			}
		}

		private void CreateInstances()
		{
			Initialize();
			DestroyMaterials(instanceMaterials);
			instanceMaterials = InstanceMaterials(defaultMaterials);
			if (CachedRenderer != null && instanceMaterials != null)
			{
				CachedRenderer.sharedMaterials = instanceMaterials;
			}
			materialsInstanced = true;
		}

		private static bool MaterialsMatch(Material[] a, Material[] b)
		{
			if (a?.Length != b?.Length)
			{
				return false;
			}
			for (int i = 0; i < a?.Length; i++)
			{
				if (a[i] != b[i])
				{
					return false;
				}
			}
			return true;
		}

		private static Material[] InstanceMaterials(Material[] source)
		{
			if (source == null)
			{
				return null;
			}
			Material[] array = new Material[source.Length];
			for (int i = 0; i < source.Length; i++)
			{
				if (source[i] != null)
				{
					if (IsInstanceMaterial(source[i]))
					{
						UnityEngine.Debug.LogWarning("A material (" + source[i].name + ") which is already instanced was instanced multiple times.");
					}
					array[i] = new Material(source[i]);
					array[i].name += " (Instance)";
				}
			}
			return array;
		}

		private static void DestroyMaterials(Material[] materials)
		{
			if (materials != null)
			{
				for (int i = 0; i < materials.Length; i++)
				{
					DestorySafe(materials[i]);
				}
			}
		}

		private static bool IsInstanceMaterial(Material material)
		{
			if (material != null)
			{
				return material.name.Contains(" (Instance)");
			}
			return false;
		}

		private static bool HasValidMaterial(Material[] materials)
		{
			if (materials != null)
			{
				for (int i = 0; i < materials.Length; i++)
				{
					if (materials[i] != null)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static void DestorySafe(UnityEngine.Object toDestroy)
		{
			if (toDestroy != null && Application.isPlaying)
			{
				UnityEngine.Object.Destroy(toDestroy);
			}
		}
	}
}
namespace Microsoft.MixedReality.Toolkit.Utilities
{
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html#mesh-outlines")]
	public abstract class BaseMeshOutline : MonoBehaviour
	{
		[Tooltip("The material used to render the outline. Outline materials should normal have \"Depth Write\" set to Off and \"Vertex Extrusion\" enabled.")]
		[SerializeField]
		protected Material outlineMaterial;

		[Tooltip("How thick (in meters) should the outline be. Overrides the \"Extrusion Value\" in the MRTK/Standard material.")]
		[SerializeField]
		[Range(0.001f, 1f)]
		protected float outlineWidth = 0.01f;

		public Material OutlineMaterial
		{
			get
			{
				return outlineMaterial;
			}
			set
			{
				if (outlineMaterial != value)
				{
					outlineMaterial = value;
					ApplyOutlineMaterial();
				}
			}
		}

		public float OutlineWidth
		{
			get
			{
				return outlineWidth;
			}
			set
			{
				if (outlineWidth != value)
				{
					outlineWidth = value;
					ApplyOutlineWidth();
				}
			}
		}

		protected virtual void OnValidate()
		{
			ApplyOutlineMaterial();
			ApplyOutlineWidth();
		}

		protected abstract void ApplyOutlineMaterial();

		protected abstract void ApplyOutlineWidth();
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Scripts/MRTK/Core/ClippingBox")]
	public class ClippingBox : ClippingPrimitive
	{
		protected int clipBoxSizeID;

		protected int clipBoxInverseTransformID;

		protected override string Keyword => "_CLIPPING_BOX";

		protected override string ClippingSideProperty => "_ClipBoxSide";

		protected void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				Gizmos.matrix = base.transform.localToWorldMatrix;
				Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			}
		}

		protected override void Initialize()
		{
			base.Initialize();
			clipBoxSizeID = Shader.PropertyToID("_ClipBoxSize");
			clipBoxInverseTransformID = Shader.PropertyToID("_ClipBoxInverseTransform");
		}

		protected override void UpdateShaderProperties(MaterialPropertyBlock materialPropertyBlock)
		{
			Vector3 vector = base.transform.lossyScale * 0.5f;
			materialPropertyBlock.SetVector(value: new Vector4(vector.x, vector.y, vector.z, 0f), nameID: clipBoxSizeID);
			Matrix4x4 inverse = Matrix4x4.TRS(base.transform.position, base.transform.rotation, Vector3.one).inverse;
			materialPropertyBlock.SetMatrix(clipBoxInverseTransformID, inverse);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Scripts/MRTK/Core/ClippingPlane")]
	public class ClippingPlane : ClippingPrimitive
	{
		protected int clipPlaneID;

		protected override string Keyword => "_CLIPPING_PLANE";

		protected override string ClippingSideProperty => "_ClipPlaneSide";

		protected void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				Gizmos.matrix = base.transform.localToWorldMatrix;
				Gizmos.DrawWireCube(Vector3.zero, new Vector3(1f, 0f, 1f));
				Gizmos.DrawLine(Vector3.zero, Vector3.up * -0.5f);
			}
		}

		protected override void Initialize()
		{
			base.Initialize();
			clipPlaneID = Shader.PropertyToID("_ClipPlane");
		}

		protected override void UpdateShaderProperties(MaterialPropertyBlock materialPropertyBlock)
		{
			Vector3 up = base.transform.up;
			materialPropertyBlock.SetVector(value: new Vector4(up.x, up.y, up.z, Vector3.Dot(up, base.transform.position)), nameID: clipPlaneID);
		}
	}
	[ExecuteAlways]
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Rendering/ClippingPrimitive.html")]
	public abstract class ClippingPrimitive : MonoBehaviour, IMaterialInstanceOwner
	{
		public enum Side
		{
			Inside = 1,
			Outside = -1
		}

		[Tooltip("The renderer(s) that should be affected by the primitive.")]
		[SerializeField]
		protected List<Renderer> renderers = new List<Renderer>();

		[Tooltip("Which side of the primitive to clip pixels against.")]
		[SerializeField]
		protected Side clippingSide = Side.Inside;

		[SerializeField]
		[Tooltip("Toggles whether the primitive will use the Camera OnPreRender event")]
		private bool useOnPreRender;

		protected MaterialPropertyBlock materialPropertyBlock;

		private int clippingSideID;

		private CameraEventRouter cameraMethods;

		public Side ClippingSide
		{
			get
			{
				return clippingSide;
			}
			set
			{
				clippingSide = value;
			}
		}

		public bool UseOnPreRender
		{
			get
			{
				return useOnPreRender;
			}
			set
			{
				if (cameraMethods == null)
				{
					cameraMethods = EnsureComponent<CameraEventRouter>(Camera.main.gameObject);
				}
				if (value)
				{
					cameraMethods.OnCameraPreRender += OnCameraPreRender;
				}
				else
				{
					cameraMethods.OnCameraPreRender -= OnCameraPreRender;
				}
				useOnPreRender = value;
			}
		}

		protected abstract string Keyword { get; }

		protected abstract string ClippingSideProperty { get; }

		public void AddRenderer(Renderer _renderer)
		{
			if (_renderer != null)
			{
				if (!renderers.Contains(_renderer))
				{
					renderers.Add(_renderer);
				}
				MaterialInstance materialInstance = EnsureComponent<MaterialInstance>(_renderer.gameObject);
				ToggleClippingFeature(materialInstance.AcquireMaterials(this), base.gameObject.activeInHierarchy);
			}
		}

		public void RemoveRenderer(Renderer _renderer)
		{
			renderers.Remove(_renderer);
			if (_renderer != null)
			{
				MaterialInstance component = _renderer.GetComponent<MaterialInstance>();
				if (component != null)
				{
					ToggleClippingFeature(component.AcquireMaterials(this, instance: false), keywordOn: false);
					component.ReleaseMaterial(this);
				}
			}
		}

		public void ClearRenderers()
		{
			if (renderers != null)
			{
				for (int num = renderers.Count - 1; num >= 0; num--)
				{
					RemoveRenderer(renderers[0]);
				}
			}
		}

		public IEnumerable<Renderer> GetRenderersCopy()
		{
			return new List<Renderer>(renderers);
		}

		protected void OnEnable()
		{
			Initialize();
			UpdateRenderers();
			ToggleClippingFeature(keywordOn: true);
			if (useOnPreRender)
			{
				cameraMethods = EnsureComponent<CameraEventRouter>(Camera.main.gameObject);
				cameraMethods.OnCameraPreRender += OnCameraPreRender;
			}
		}

		protected void OnDisable()
		{
			UpdateRenderers();
			ToggleClippingFeature(keywordOn: false);
			if (cameraMethods != null)
			{
				cameraMethods.OnCameraPreRender -= OnCameraPreRender;
			}
		}

		protected void LateUpdate()
		{
			if (!useOnPreRender)
			{
				UpdateRenderers();
			}
		}

		protected void OnCameraPreRender(CameraEventRouter router)
		{
			UpdateRenderers();
		}

		protected void OnDestroy()
		{
			ClearRenderers();
		}

		public void OnMaterialChanged(MaterialInstance materialInstance)
		{
			if (materialInstance != null)
			{
				ToggleClippingFeature(materialInstance.AcquireMaterials(this), base.gameObject.activeInHierarchy);
			}
			UpdateRenderers();
		}

		protected virtual void Initialize()
		{
			materialPropertyBlock = new MaterialPropertyBlock();
			clippingSideID = Shader.PropertyToID(ClippingSideProperty);
		}

		protected virtual void UpdateRenderers()
		{
			if (renderers == null)
			{
				return;
			}
			for (int i = 0; i < renderers.Count; i++)
			{
				Renderer renderer = renderers[i];
				if (!(renderer == null))
				{
					renderer.GetPropertyBlock(materialPropertyBlock);
					materialPropertyBlock.SetFloat(clippingSideID, (float)clippingSide);
					UpdateShaderProperties(materialPropertyBlock);
					renderer.SetPropertyBlock(materialPropertyBlock);
				}
			}
		}

		protected abstract void UpdateShaderProperties(MaterialPropertyBlock materialPropertyBlock);

		protected void ToggleClippingFeature(bool keywordOn)
		{
			if (renderers == null)
			{
				return;
			}
			for (int i = 0; i < renderers.Count; i++)
			{
				Renderer renderer = renderers[i];
				if (renderer != null)
				{
					MaterialInstance materialInstance = EnsureComponent<MaterialInstance>(renderer.gameObject);
					ToggleClippingFeature(materialInstance.AcquireMaterials(this), keywordOn);
				}
			}
		}

		protected void ToggleClippingFeature(Material[] materials, bool keywordOn)
		{
			if (materials != null)
			{
				foreach (Material material in materials)
				{
					ToggleClippingFeature(material, keywordOn);
				}
			}
		}

		protected void ToggleClippingFeature(Material material, bool keywordOn)
		{
			if (material != null)
			{
				if (keywordOn)
				{
					material.EnableKeyword(Keyword);
				}
				else
				{
					material.DisableKeyword(Keyword);
				}
			}
		}

		private static T EnsureComponent<T>(GameObject go) where T : Component
		{
			T component = go.GetComponent<T>();
			if (!(component == null))
			{
				return component;
			}
			return go.AddComponent<T>();
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Scripts/MRTK/Core/ClippingSphere")]
	public class ClippingSphere : ClippingPrimitive
	{
		protected int clipSphereID;

		public float Radius
		{
			get
			{
				Vector3 vector = base.transform.lossyScale * 0.5f;
				return Mathf.Max(Mathf.Max(vector.x, vector.y), vector.z);
			}
		}

		protected override string Keyword => "_CLIPPING_SPHERE";

		protected override string ClippingSideProperty => "_ClipSphereSide";

		protected void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				Gizmos.DrawWireSphere(base.transform.position, Radius);
			}
		}

		protected override void Initialize()
		{
			base.Initialize();
			clipSphereID = Shader.PropertyToID("_ClipSphere");
		}

		protected override void UpdateShaderProperties(MaterialPropertyBlock materialPropertyBlock)
		{
			Vector3 position = base.transform.position;
			materialPropertyBlock.SetVector(value: new Vector4(position.x, position.y, position.z, Radius), nameID: clipSphereID);
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Rendering/HoverLight.html")]
	[AddComponentMenu("Scripts/MRTK/Core/HoverLight")]
	public class HoverLight : MonoBehaviour
	{
		private const int hoverLightCount = 2;

		private const int hoverLightDataSize = 2;

		private static List<HoverLight> activeHoverLights = new List<HoverLight>(2);

		private static Vector4[] hoverLightData = new Vector4[4];

		private static int _HoverLightDataID;

		private static int lastHoverLightUpdate = -1;

		[Tooltip("Specifies the radius of the HoverLight effect")]
		[SerializeField]
		[Range(0f, 1f)]
		private float radius = 0.15f;

		[Tooltip("Specifies the highlight color")]
		[SerializeField]
		private Color color = new Color(0.3f, 0.3f, 0.3f, 1f);

		public float Radius
		{
			get
			{
				return radius;
			}
			set
			{
				radius = value;
			}
		}

		public Color Color
		{
			get
			{
				return color;
			}
			set
			{
				color = value;
			}
		}

		private void OnEnable()
		{
			AddHoverLight(this);
		}

		private void OnDisable()
		{
			RemoveHoverLight(this);
			UpdateHoverLights(forceUpdate: true);
		}

		private void LateUpdate()
		{
			UpdateHoverLights();
		}

		private void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				Gizmos.color = Color;
				Gizmos.DrawWireSphere(base.transform.position, Radius);
				Gizmos.DrawIcon(base.transform.position + Vector3.right * Radius, string.Empty, allowScaling: false);
				Gizmos.DrawIcon(base.transform.position + Vector3.left * Radius, string.Empty, allowScaling: false);
				Gizmos.DrawIcon(base.transform.position + Vector3.up * Radius, string.Empty, allowScaling: false);
				Gizmos.DrawIcon(base.transform.position + Vector3.down * Radius, string.Empty, allowScaling: false);
				Gizmos.DrawIcon(base.transform.position + Vector3.forward * Radius, string.Empty, allowScaling: false);
				Gizmos.DrawIcon(base.transform.position + Vector3.back * Radius, string.Empty, allowScaling: false);
			}
		}

		private void AddHoverLight(HoverLight light)
		{
			if (activeHoverLights.Count >= 2)
			{
				UnityEngine.Debug.LogWarningFormat("Max hover light count ({0}) exceeded.", 2);
			}
			activeHoverLights.Add(light);
		}

		private void RemoveHoverLight(HoverLight light)
		{
			activeHoverLights.Remove(light);
		}

		private void Initialize()
		{
			_HoverLightDataID = Shader.PropertyToID("_HoverLightData");
		}

		private void UpdateHoverLights(bool forceUpdate = false)
		{
			if (lastHoverLightUpdate == -1)
			{
				Initialize();
			}
			if (!forceUpdate && Time.frameCount == lastHoverLightUpdate)
			{
				return;
			}
			for (int i = 0; i < 2; i++)
			{
				HoverLight hoverLight = ((i >= activeHoverLights.Count) ? null : activeHoverLights[i]);
				int num = i * 2;
				if ((bool)hoverLight)
				{
					hoverLightData[num] = new Vector4(hoverLight.transform.position.x, hoverLight.transform.position.y, hoverLight.transform.position.z, 1f);
					hoverLightData[num + 1] = new Vector4(hoverLight.Color.r, hoverLight.Color.g, hoverLight.Color.b, 1f / Mathf.Clamp(hoverLight.Radius, 0.001f, 1f));
				}
				else
				{
					hoverLightData[num] = Vector4.zero;
				}
			}
			Shader.SetGlobalVectorArray(_HoverLightDataID, hoverLightData);
			lastHoverLightUpdate = Time.frameCount;
		}
	}
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Scripts/MRTK/Core/MeshOutline")]
	public class MeshOutline : BaseMeshOutline
	{
		private const string vertexExtrusionKeyword = "_VERTEX_EXTRUSION";

		private const string vertexExtrusionSmoothNormalsKeyword = "_VERTEX_EXTRUSION_SMOOTH_NORMALS";

		private const string vertexExtrusionValueName = "_VertexExtrusionValue";

		private MeshRenderer meshRenderer;

		private MaterialPropertyBlock propertyBlock;

		private int vertexExtrusionValueID;

		private Material[] defaultMaterials;

		private MeshSmoother createdMeshSmoother;

		private void Awake()
		{
			meshRenderer = GetComponent<MeshRenderer>();
			propertyBlock = new MaterialPropertyBlock();
			vertexExtrusionValueID = Shader.PropertyToID("_VertexExtrusionValue");
			defaultMaterials = meshRenderer.sharedMaterials;
		}

		private void OnEnable()
		{
			ApplyOutlineMaterial();
		}

		private void OnDisable()
		{
			meshRenderer.materials = defaultMaterials;
		}

		private void OnDestroy()
		{
			UnityEngine.Object.Destroy(createdMeshSmoother);
		}

		protected override void ApplyOutlineMaterial()
		{
			if (!(outlineMaterial != null) || !(meshRenderer != null))
			{
				return;
			}
			outlineMaterial.renderQueue = GetMinRenderQueue(defaultMaterials) - 1;
			if (outlineMaterial.IsKeywordEnabled("_VERTEX_EXTRUSION_SMOOTH_NORMALS"))
			{
				MeshSmoother meshSmoother = ((createdMeshSmoother == null) ? base.gameObject.GetComponent<MeshSmoother>() : createdMeshSmoother);
				if (meshSmoother == null)
				{
					createdMeshSmoother = base.gameObject.AddComponent<MeshSmoother>();
					meshSmoother = createdMeshSmoother;
				}
				meshSmoother.SmoothNormals();
			}
			ApplyOutlineWidth();
			List<Material> list = new List<Material>(defaultMaterials);
			list.Add(outlineMaterial);
			meshRenderer.materials = list.ToArray();
		}

		protected override void ApplyOutlineWidth()
		{
			if (meshRenderer != null && propertyBlock != null)
			{
				meshRenderer.GetPropertyBlock(propertyBlock);
				propertyBlock.SetFloat("_VertexExtrusionValue", outlineWidth);
				meshRenderer.SetPropertyBlock(propertyBlock);
			}
		}

		private static int GetMinRenderQueue(Material[] materials)
		{
			int num = int.MaxValue;
			foreach (Material material in materials)
			{
				if (material != null)
				{
					num = Mathf.Min(num, material.renderQueue);
				}
			}
			if (num == int.MaxValue)
			{
				num = 1000;
			}
			return num;
		}
	}
	[AddComponentMenu("Scripts/MRTK/Core/MeshOutlineHierarchy")]
	public class MeshOutlineHierarchy : BaseMeshOutline
	{
		private MeshOutline[] meshOutlines;

		private void Awake()
		{
			MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
			meshOutlines = new MeshOutline[componentsInChildren.Length];
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshOutline meshOutline = componentsInChildren[i].gameObject.AddComponent<MeshOutline>();
				meshOutline.OutlineMaterial = outlineMaterial;
				meshOutline.OutlineWidth = outlineWidth;
				meshOutlines[i] = meshOutline;
			}
		}

		private void OnDestroy()
		{
			MeshOutline[] array = meshOutlines;
			for (int i = 0; i < array.Length; i++)
			{
				UnityEngine.Object.Destroy(array[i]);
			}
		}

		protected override void ApplyOutlineMaterial()
		{
			if (meshOutlines == null)
			{
				return;
			}
			MeshOutline[] array = meshOutlines;
			foreach (MeshOutline meshOutline in array)
			{
				if (meshOutline != null)
				{
					meshOutline.OutlineMaterial = outlineMaterial;
				}
			}
		}

		protected override void ApplyOutlineWidth()
		{
			if (meshOutlines == null)
			{
				return;
			}
			MeshOutline[] array = meshOutlines;
			foreach (MeshOutline meshOutline in array)
			{
				if (meshOutline != null)
				{
					meshOutline.OutlineWidth = outlineWidth;
				}
			}
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html#mesh-outlines")]
	[AddComponentMenu("Scripts/MRTK/Core/MeshSmoother")]
	public class MeshSmoother : MonoBehaviour
	{
		private class MeshReference
		{
			public Mesh Mesh;

			private int referenceCount;

			public MeshReference(Mesh mesh)
			{
				Mesh = mesh;
				referenceCount = 1;
			}

			public void Increment()
			{
				referenceCount++;
			}

			public void Decrement()
			{
				referenceCount--;
			}

			public bool IsReferenced()
			{
				return referenceCount > 0;
			}
		}

		private const int smoothNormalUVChannel = 2;

		[Tooltip("Should this component automatically smooth normals on awake?")]
		[SerializeField]
		private bool smoothNormalsOnAwake;

		private MeshFilter meshFilter;

		private static Dictionary<Mesh, MeshReference> processedMeshes = new Dictionary<Mesh, MeshReference>();

		public void SmoothNormals()
		{
			if (!AcquirePreprocessedMesh(out var mesh))
			{
				List<Vector3> uvs = CalculateSmoothNormals(mesh.vertices, mesh.normals);
				mesh.SetUVs(2, uvs);
			}
		}

		public System.Threading.Tasks.Task SmoothNormalsAsync()
		{
			if (AcquirePreprocessedMesh(out var mesh))
			{
				return System.Threading.Tasks.Task.CompletedTask;
			}
			Vector3[] vertices = mesh.vertices;
			Vector3[] normals = mesh.normals;
			return System.Threading.Tasks.Task.Run(() => CalculateSmoothNormals(vertices, normals)).ContinueWith(delegate(System.Threading.Tasks.Task<List<Vector3>> i)
			{
				mesh.SetUVs(2, i.Result);
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		private void Awake()
		{
			meshFilter = GetComponent<MeshFilter>();
			if (smoothNormalsOnAwake)
			{
				SmoothNormalsAsync();
			}
		}

		private void OnDestroy()
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (sharedMesh != null && processedMeshes.TryGetValue(sharedMesh, out var value))
			{
				value.Decrement();
				if (!value.IsReferenced())
				{
					UnityEngine.Object.Destroy(value.Mesh);
					processedMeshes.Remove(sharedMesh);
				}
			}
		}

		private bool AcquirePreprocessedMesh(out Mesh mesh)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (sharedMesh != null && processedMeshes.TryGetValue(sharedMesh, out var value))
			{
				value.Increment();
				mesh = value.Mesh;
				meshFilter.mesh = mesh;
				return true;
			}
			mesh = meshFilter.mesh;
			value = new MeshReference(mesh);
			processedMeshes[mesh] = value;
			if (sharedMesh != null)
			{
				processedMeshes[sharedMesh] = value;
			}
			return false;
		}

		private static List<Vector3> CalculateSmoothNormals(Vector3[] vertices, Vector3[] normals)
		{
			Stopwatch stopwatch = Stopwatch.StartNew();
			Dictionary<Vector3, List<KeyValuePair<int, Vector3>>> dictionary = new Dictionary<Vector3, List<KeyValuePair<int, Vector3>>>();
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 vector = vertices[i];
				if (!dictionary.TryGetValue(vector, out var value))
				{
					value = (dictionary[vector] = new List<KeyValuePair<int, Vector3>>());
				}
				value.Add(new KeyValuePair<int, Vector3>(i, vector));
			}
			List<Vector3> list2 = new List<Vector3>(normals);
			if (dictionary.Count != vertices.Length)
			{
				foreach (KeyValuePair<Vector3, List<KeyValuePair<int, Vector3>>> item in dictionary)
				{
					List<KeyValuePair<int, Vector3>> value2 = item.Value;
					if (value2.Count == 1)
					{
						continue;
					}
					Vector3 zero = Vector3.zero;
					foreach (KeyValuePair<int, Vector3> item2 in value2)
					{
						zero += normals[item2.Key];
					}
					zero.Normalize();
					foreach (KeyValuePair<int, Vector3> item3 in value2)
					{
						list2[item3.Key] = zero;
					}
				}
			}
			UnityEngine.Debug.LogFormat("CalculateSmoothNormals took {0} ms on {1} vertices.", stopwatch.ElapsedMilliseconds, vertices.Length);
			return list2;
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Rendering/ProximityLight.html")]
	[AddComponentMenu("Scripts/MRTK/Core/ProximityLight")]
	public class ProximityLight : MonoBehaviour
	{
		[Serializable]
		public class LightSettings
		{
			[Header("Proximity Settings")]
			[Tooltip("Specifies the radius of the ProximityLight effect when near to a surface.")]
			[SerializeField]
			[Range(0f, 1f)]
			private float nearRadius = 0.05f;

			[Tooltip("Specifies the radius of the ProximityLight effect when far from a surface.")]
			[SerializeField]
			[Range(0f, 1f)]
			private float farRadius = 0.2f;

			[Tooltip("Specifies the distance a ProximityLight must be from a surface to be considered near.")]
			[SerializeField]
			[Range(0f, 1f)]
			private float nearDistance = 0.02f;

			[Tooltip("When a ProximityLight is near, the smallest size percentage from the far size it can shrink to.")]
			[SerializeField]
			[Range(0f, 1f)]
			private float minNearSizePercentage = 0.35f;

			[Header("Color Settings")]
			[Tooltip("The color of the ProximityLight gradient at the center (RGB) and (A) is gradient extent.")]
			[ColorUsage(true, true)]
			[SerializeField]
			private Color centerColor = new Color(18f / 85f, 0.5568628f, 50f / 51f, 0f);

			[Tooltip("The color of the ProximityLight gradient at the middle (RGB) and (A) is gradient extent.")]
			[SerializeField]
			[ColorUsage(true, true)]
			private Color middleColor = new Color(0.18431373f, 44f / 85f, 1f, 0.2f);

			[Tooltip("The color of the ProximityLight gradient at the outer (RGB) and (A) is gradient extent.")]
			[SerializeField]
			[ColorUsage(true, true)]
			private Color outerColor = new Color(82f / 85f, 31f / 85f, 2.2470589f, 1f);

			public float NearRadius
			{
				get
				{
					return nearRadius;
				}
				set
				{
					nearRadius = value;
				}
			}

			public float FarRadius
			{
				get
				{
					return farRadius;
				}
				set
				{
					farRadius = value;
				}
			}

			public float NearDistance
			{
				get
				{
					return nearDistance;
				}
				set
				{
					nearDistance = value;
				}
			}

			public float MinNearSizePercentage
			{
				get
				{
					return minNearSizePercentage;
				}
				set
				{
					minNearSizePercentage = value;
				}
			}

			public Color CenterColor
			{
				get
				{
					return centerColor;
				}
				set
				{
					centerColor = value;
				}
			}

			public Color MiddleColor
			{
				get
				{
					return middleColor;
				}
				set
				{
					middleColor = value;
				}
			}

			public Color OuterColor
			{
				get
				{
					return outerColor;
				}
				set
				{
					outerColor = value;
				}
			}
		}

		private const int proximityLightCount = 2;

		private const int proximityLightDataSize = 6;

		private static List<ProximityLight> activeProximityLights = new List<ProximityLight>(2);

		private static Vector4[] proximityLightData = new Vector4[12];

		private static int proximityLightDataID;

		private static int lastProximityLightUpdate = -1;

		[SerializeField]
		private LightSettings settings = new LightSettings();

		private float pulseTime;

		private float pulseFade;

		public LightSettings Settings
		{
			get
			{
				return settings;
			}
			set
			{
				settings = value;
			}
		}

		public void Pulse(float pulseDuration = 0.2f, float fadeBegin = 0.8f, float fadeSpeed = 10f)
		{
			if (pulseTime <= 0f)
			{
				StartCoroutine(PulseRoutine(pulseDuration, fadeBegin, fadeSpeed));
			}
		}

		private void OnEnable()
		{
			AddProximityLight(this);
		}

		private void OnDisable()
		{
			RemoveProximityLight(this);
			UpdateProximityLights(forceUpdate: true);
		}

		private void LateUpdate()
		{
			UpdateProximityLights();
		}

		private void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				Vector3[] array = new Vector3[6]
				{
					Vector3.right,
					Vector3.left,
					Vector3.up,
					Vector3.down,
					Vector3.forward,
					Vector3.back
				};
				Gizmos.color = new Color(Settings.CenterColor.r, Settings.CenterColor.g, Settings.CenterColor.b);
				Gizmos.DrawWireSphere(base.transform.position, Settings.NearRadius);
				Vector3[] array2 = array;
				foreach (Vector3 vector in array2)
				{
					Gizmos.DrawIcon(base.transform.position + vector * Settings.NearRadius, string.Empty, allowScaling: false);
				}
				Gizmos.color = new Color(Settings.OuterColor.r, Settings.OuterColor.g, Settings.OuterColor.b);
				Gizmos.DrawWireSphere(base.transform.position, Settings.FarRadius);
				array2 = array;
				foreach (Vector3 vector2 in array2)
				{
					Gizmos.DrawIcon(base.transform.position + vector2 * Settings.FarRadius, string.Empty, allowScaling: false);
				}
			}
		}

		private static void AddProximityLight(ProximityLight light)
		{
			if (activeProximityLights.Count >= 2)
			{
				UnityEngine.Debug.LogWarningFormat("Max proximity light count ({0}) exceeded.", 2);
			}
			activeProximityLights.Add(light);
		}

		private static void RemoveProximityLight(ProximityLight light)
		{
			activeProximityLights.Remove(light);
		}

		private static void Initialize()
		{
			proximityLightDataID = Shader.PropertyToID("_ProximityLightData");
		}

		private static void UpdateProximityLights(bool forceUpdate = false)
		{
			if (lastProximityLightUpdate == -1)
			{
				Initialize();
			}
			if (!forceUpdate && Time.frameCount == lastProximityLightUpdate)
			{
				return;
			}
			for (int i = 0; i < 2; i++)
			{
				ProximityLight proximityLight = ((i >= activeProximityLights.Count) ? null : activeProximityLights[i]);
				int num = i * 6;
				if ((bool)proximityLight)
				{
					proximityLightData[num] = new Vector4(proximityLight.transform.position.x, proximityLight.transform.position.y, proximityLight.transform.position.z, 1f);
					float num2 = 1f + proximityLight.pulseTime;
					proximityLightData[num + 1] = new Vector4(proximityLight.Settings.NearRadius * num2, 1f / Mathf.Clamp(proximityLight.Settings.FarRadius * num2, 0.001f, 1f), 1f / Mathf.Clamp(proximityLight.Settings.NearDistance * num2, 0.001f, 1f), Mathf.Clamp01(proximityLight.Settings.MinNearSizePercentage));
					proximityLightData[num + 2] = new Vector4(proximityLight.Settings.NearDistance * proximityLight.pulseTime, Mathf.Clamp01(1f - proximityLight.pulseFade), 0f, 0f);
					proximityLightData[num + 3] = proximityLight.Settings.CenterColor;
					proximityLightData[num + 4] = proximityLight.Settings.MiddleColor;
					proximityLightData[num + 5] = proximityLight.Settings.OuterColor;
				}
				else
				{
					proximityLightData[num] = Vector4.zero;
				}
			}
			Shader.SetGlobalVectorArray(proximityLightDataID, proximityLightData);
			lastProximityLightUpdate = Time.frameCount;
		}

		private IEnumerator PulseRoutine(float pulseDuration, float fadeBegin, float fadeSpeed)
		{
			float pulseTimer = 0f;
			while (pulseTimer < pulseDuration)
			{
				pulseTimer += Time.deltaTime;
				pulseTime = pulseTimer / pulseDuration;
				if (pulseTime > fadeBegin)
				{
					pulseFade += Time.deltaTime;
				}
				yield return null;
			}
			while (pulseFade < 1f)
			{
				pulseFade += Time.deltaTime * fadeSpeed;
				yield return null;
			}
			pulseTime = 0f;
			while (pulseFade > 0f)
			{
				pulseFade -= Time.deltaTime * fadeSpeed;
				yield return null;
			}
			pulseFade = 0f;
		}
	}
	public static class StandardShaderUtility
	{
		public static readonly string MrtkStandardShaderName = "Mixed Reality Toolkit/Standard";

		private static Shader mrtkStandardShader = null;

		public static Shader MrtkStandardShader
		{
			get
			{
				if (mrtkStandardShader == null)
				{
					mrtkStandardShader = Shader.Find(MrtkStandardShaderName);
				}
				return mrtkStandardShader;
			}
			private set
			{
				mrtkStandardShader = value;
			}
		}

		public static bool IsUsingMrtkStandardShader(Material material)
		{
			return IsMrtkStandardShader((material != null) ? material.shader : null);
		}

		public static bool IsMrtkStandardShader(Shader shader)
		{
			return shader == MrtkStandardShader;
		}
	}
	[AddComponentMenu("Scripts/MRTK/Core/CameraEventRouter")]
	public class CameraEventRouter : MonoBehaviour
	{
		public event Action<CameraEventRouter> OnCameraPreRender;

		private void OnPreRender()
		{
			this.OnCameraPreRender?.Invoke(this);
		}
	}
}
namespace CalmWater
{
	public class MaterialSwitcher : MonoBehaviour
	{
		public MeshRenderer WaterPlane;

		public Material ClassicMat;

		public Material DX11Mat;

		private MirrorReflection m;

		private void Start()
		{
			m = WaterPlane.GetComponent<MirrorReflection>();
		}

		public void SetDX11Mat()
		{
			WaterPlane.material = DX11Mat;
			m.setMaterial();
		}

		public void SetClassicMat()
		{
			WaterPlane.material = ClassicMat;
			m.setMaterial();
		}
	}
	public class SceneSwitcher : MonoBehaviour
	{
		public void SwitchLevel(string level)
		{
			SceneManager.LoadScene(level);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class CameraDepthMode : MonoBehaviour
	{
		private void Start()
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
		}
	}
	[RequireComponent(typeof(Projector))]
	public class CausticAnimator : MonoBehaviour
	{
		[SerializeField]
		private float _frameDuration = 0.1f;

		[SerializeField]
		private Texture2D[] _causticFrames;

		private Projector _projector;

		private Material _mat;

		private WaitForSeconds _delay;

		private int _propID;

		private int _currentFrame;

		private void OnEnable()
		{
			if (_causticFrames.Length < 2)
			{
				base.enabled = false;
			}
			if (_projector == null)
			{
				_projector = GetComponent<Projector>();
			}
			if (_mat == null)
			{
				_mat = _projector.material;
			}
			_currentFrame = 0;
			_propID = Shader.PropertyToID("_CausticTex");
			_delay = new WaitForSeconds(_frameDuration);
		}

		private void OnDisabled()
		{
			StopCoroutine(AnimateCaustic());
		}

		private void Awake()
		{
			StartCoroutine(AnimateCaustic());
		}

		private int NextFrame()
		{
			_currentFrame++;
			_currentFrame = ((_currentFrame < _causticFrames.Length) ? _currentFrame : 0);
			return _currentFrame;
		}

		private IEnumerator AnimateCaustic()
		{
			while (true)
			{
				yield return _delay;
				_mat.SetTexture(_propID, _causticFrames[NextFrame()]);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(MeshRenderer))]
	public class MirrorReflection : MonoBehaviour
	{
		private enum QualityLevels
		{
			High = 1,
			Medium = 2,
			Low = 4,
			VeryLow = 8
		}

		public LayerMask reflectionMask = -1;

		[SerializeField]
		private QualityLevels Quality = QualityLevels.Medium;

		[Tooltip("Color used instead of skybox if you choose to not render it.")]
		public Color clearColor = Color.grey;

		public bool reflectSkybox = true;

		public bool m_DisablePixelLights;

		[Tooltip("You won't be able to select objects in the scene when thi is active.")]
		public bool UpdateSceneView = true;

		public float clipPlaneOffset = 0.07f;

		private string reflectionSampler = "_ReflectionTex";

		private Vector3 m_Oldpos;

		private Camera m_ReflectionCamera;

		private Material m_SharedMaterial;

		private Dictionary<Camera, bool> m_HelperCameras;

		private void OnEnable()
		{
			base.gameObject.layer = LayerMask.NameToLayer("Water");
			setMaterial();
		}

		private void OnDisable()
		{
			if (m_ReflectionCamera != null)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionCamera);
			}
		}

		private void Start()
		{
			base.gameObject.layer = LayerMask.NameToLayer("Water");
			setMaterial();
		}

		public void setMaterial()
		{
			m_SharedMaterial = GetComponent<Renderer>().sharedMaterial;
		}

		private Camera CreateReflectionCameraFor(Camera cam)
		{
			string text = base.gameObject.name + "Reflection" + cam.name;
			GameObject gameObject = GameObject.Find(text);
			if (!gameObject)
			{
				gameObject = new GameObject(text, typeof(Camera));
				gameObject.hideFlags = HideFlags.HideAndDontSave;
			}
			if (!gameObject.GetComponent(typeof(Camera)))
			{
				gameObject.AddComponent(typeof(Camera));
			}
			Camera component = gameObject.GetComponent<Camera>();
			component.backgroundColor = clearColor;
			component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			SetStandardCameraParameter(component, reflectionMask);
			if (!component.targetTexture)
			{
				component.targetTexture = CreateTextureFor(cam);
			}
			return component;
		}

		private void SetStandardCameraParameter(Camera cam, LayerMask mask)
		{
			cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
			cam.backgroundColor = Color.black;
			cam.enabled = false;
		}

		private RenderTexture CreateTextureFor(Camera cam)
		{
			int width = Mathf.FloorToInt(cam.pixelWidth / (int)Quality);
			int height = Mathf.FloorToInt(cam.pixelHeight / (int)Quality);
			return new RenderTexture(width, height, 24)
			{
				hideFlags = HideFlags.DontSave
			};
		}

		public void RenderHelpCameras(Camera currentCam)
		{
			if (m_HelperCameras == null)
			{
				m_HelperCameras = new Dictionary<Camera, bool>();
			}
			if (!m_HelperCameras.ContainsKey(currentCam))
			{
				m_HelperCameras.Add(currentCam, value: false);
			}
			if (!m_HelperCameras[currentCam] || UpdateSceneView)
			{
				if (!m_ReflectionCamera)
				{
					m_ReflectionCamera = CreateReflectionCameraFor(currentCam);
				}
				RenderReflectionFor(currentCam, m_ReflectionCamera);
				m_HelperCameras[currentCam] = true;
			}
		}

		public void LateUpdate()
		{
			if (m_HelperCameras != null)
			{
				m_HelperCameras.Clear();
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			RenderHelpCameras(currentCam);
			if ((bool)m_ReflectionCamera && (bool)m_SharedMaterial)
			{
				m_SharedMaterial.SetTexture(reflectionSampler, m_ReflectionCamera.targetTexture);
			}
		}

		public void OnWillRenderObject()
		{
			WaterTileBeingRendered(base.transform, Camera.current);
		}

		private void RenderReflectionFor(Camera cam, Camera reflectCamera)
		{
			if (!reflectCamera || ((bool)m_SharedMaterial && !m_SharedMaterial.HasProperty(reflectionSampler)))
			{
				return;
			}
			int pixelLightCount = QualitySettings.pixelLightCount;
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = 0;
			}
			reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
			SaneCameraSettings(reflectCamera);
			reflectCamera.backgroundColor = clearColor;
			reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
			{
				Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
				if (!skybox)
				{
					skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
				}
				skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
			}
			GL.invertCulling = true;
			Transform transform = base.transform;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectCamera.transform.position = cam.transform.position;
			Vector3 position = transform.transform.position;
			position.y = transform.position.y;
			Vector3 up = transform.transform.up;
			float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 zero = Matrix4x4.zero;
			zero = CalculateReflectionMatrix(zero, plane);
			m_Oldpos = cam.transform.position;
			Vector3 position2 = zero.MultiplyPoint(m_Oldpos);
			reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
			Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
			Matrix4x4 projectionMatrix = cam.projectionMatrix;
			projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
			reflectCamera.projectionMatrix = projectionMatrix;
			reflectCamera.transform.position = position2;
			Vector3 eulerAngles2 = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			reflectCamera.Render();
			GL.invertCulling = false;
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = pixelLightCount;
			}
		}

		private void SaneCameraSettings(Camera helperCam)
		{
			helperCam.depthTextureMode = DepthTextureMode.None;
			helperCam.backgroundColor = Color.black;
			helperCam.clearFlags = CameraClearFlags.Color;
			helperCam.renderingPath = RenderingPath.Forward;
		}

		private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
		{
			Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
			Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
			projection[2] = vector.x - projection[3];
			projection[6] = vector.y - projection[7];
			projection[10] = vector.z - projection[11];
			projection[14] = vector.w - projection[15];
			return projection;
		}

		private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
			return reflectionMat;
		}

		private static float Sgn(float a)
		{
			if (a > 0f)
			{
				return 1f;
			}
			if (a < 0f)
			{
				return -1f;
			}
			return 0f;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}
	}
}
namespace XftWeapon
{
	public class Spline
	{
		private List<SplineControlPoint> mControlPoints = new List<SplineControlPoint>();

		private List<SplineControlPoint> mSegments = new List<SplineControlPoint>();

		public int Granularity = 20;

		public SplineControlPoint this[int index]
		{
			get
			{
				if (index > -1 && index < mSegments.Count)
				{
					return mSegments[index];
				}
				return null;
			}
		}

		public List<SplineControlPoint> Segments => mSegments;

		public List<SplineControlPoint> ControlPoints => mControlPoints;

		public SplineControlPoint NextControlPoint(SplineControlPoint controlpoint)
		{
			if (mControlPoints.Count == 0)
			{
				return null;
			}
			int num = controlpoint.ControlPointIndex + 1;
			if (num >= mControlPoints.Count)
			{
				return null;
			}
			return mControlPoints[num];
		}

		public SplineControlPoint PreviousControlPoint(SplineControlPoint controlpoint)
		{
			if (mControlPoints.Count == 0)
			{
				return null;
			}
			int num = controlpoint.ControlPointIndex - 1;
			if (num < 0)
			{
				return null;
			}
			return mControlPoints[num];
		}

		public Vector3 NextPosition(SplineControlPoint controlpoint)
		{
			return NextControlPoint(controlpoint)?.Position ?? controlpoint.Position;
		}

		public Vector3 PreviousPosition(SplineControlPoint controlpoint)
		{
			return PreviousControlPoint(controlpoint)?.Position ?? controlpoint.Position;
		}

		public Vector3 PreviousNormal(SplineControlPoint controlpoint)
		{
			return PreviousControlPoint(controlpoint)?.Normal ?? controlpoint.Normal;
		}

		public Vector3 NextNormal(SplineControlPoint controlpoint)
		{
			return NextControlPoint(controlpoint)?.Normal ?? controlpoint.Normal;
		}

		public SplineControlPoint LenToSegment(float t, out float localF)
		{
			SplineControlPoint splineControlPoint = null;
			t = Mathf.Clamp01(t);
			float num = t * mSegments[mSegments.Count - 1].Dist;
			int num2 = 0;
			for (num2 = 0; num2 < mSegments.Count; num2++)
			{
				if (mSegments[num2].Dist >= num)
				{
					splineControlPoint = mSegments[num2];
					break;
				}
			}
			if (num2 == 0)
			{
				localF = 0f;
				return splineControlPoint;
			}
			float num3 = 0f;
			int index = splineControlPoint.SegmentIndex - 1;
			SplineControlPoint splineControlPoint2 = mSegments[index];
			num3 = splineControlPoint.Dist - splineControlPoint2.Dist;
			localF = (num - splineControlPoint2.Dist) / num3;
			return splineControlPoint2;
		}

		public static Vector3 CatmulRom(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			double num = 1.5;
			double num2 = -1.5;
			double num3 = 0.5;
			double num4 = -2.5;
			double num5 = 2.0;
			double num6 = -0.5;
			double num7 = -0.5;
			double num8 = 0.5;
			double num9 = -0.5 * (double)T0.x + num * (double)P0.x + num2 * (double)P1.x + num3 * (double)T1.x;
			double num10 = (double)T0.x + num4 * (double)P0.x + num5 * (double)P1.x + num6 * (double)T1.x;
			double num11 = num7 * (double)T0.x + num8 * (double)P1.x;
			double num12 = P0.x;
			double num13 = -0.5 * (double)T0.y + num * (double)P0.y + num2 * (double)P1.y + num3 * (double)T1.y;
			double num14 = (double)T0.y + num4 * (double)P0.y + num5 * (double)P1.y + num6 * (double)T1.y;
			double num15 = num7 * (double)T0.y + num8 * (double)P1.y;
			double num16 = P0.y;
			double num17 = -0.5 * (double)T0.z + num * (double)P0.z + num2 * (double)P1.z + num3 * (double)T1.z;
			double num18 = (double)T0.z + num4 * (double)P0.z + num5 * (double)P1.z + num6 * (double)T1.z;
			double num19 = num7 * (double)T0.z + num8 * (double)P1.z;
			double num20 = P0.z;
			float x = (float)(((num9 * (double)f + num10) * (double)f + num11) * (double)f + num12);
			float y = (float)(((num13 * (double)f + num14) * (double)f + num15) * (double)f + num16);
			float z = (float)(((num17 * (double)f + num18) * (double)f + num19) * (double)f + num20);
			return new Vector3(x, y, z);
		}

		public Vector3 InterpolateByLen(float tl)
		{
			float localF;
			return LenToSegment(tl, out localF).Interpolate(localF);
		}

		public Vector3 InterpolateNormalByLen(float tl)
		{
			float localF;
			return LenToSegment(tl, out localF).InterpolateNormal(localF);
		}

		public SplineControlPoint AddControlPoint(Vector3 pos, Vector3 up)
		{
			SplineControlPoint splineControlPoint = new SplineControlPoint();
			splineControlPoint.Init(this);
			splineControlPoint.Position = pos;
			splineControlPoint.Normal = up;
			mControlPoints.Add(splineControlPoint);
			splineControlPoint.ControlPointIndex = mControlPoints.Count - 1;
			return splineControlPoint;
		}

		public void Clear()
		{
			mControlPoints.Clear();
		}

		private void RefreshDistance()
		{
			if (mSegments.Count >= 1)
			{
				mSegments[0].Dist = 0f;
				for (int i = 1; i < mSegments.Count; i++)
				{
					float magnitude = (mSegments[i].Position - mSegments[i - 1].Position).magnitude;
					mSegments[i].Dist = mSegments[i - 1].Dist + magnitude;
				}
			}
		}

		public void RefreshSpline()
		{
			mSegments.Clear();
			for (int i = 0; i < mControlPoints.Count; i++)
			{
				if (mControlPoints[i].IsValid)
				{
					mSegments.Add(mControlPoints[i]);
					mControlPoints[i].SegmentIndex = mSegments.Count - 1;
				}
			}
			RefreshDistance();
		}
	}
	public class SplineControlPoint
	{
		public Vector3 Position;

		public Vector3 Normal;

		public int ControlPointIndex = -1;

		public int SegmentIndex = -1;

		public float Dist;

		protected Spline mSpline;

		public SplineControlPoint NextControlPoint => mSpline.NextControlPoint(this);

		public SplineControlPoint PreviousControlPoint => mSpline.PreviousControlPoint(this);

		public Vector3 NextPosition => mSpline.NextPosition(this);

		public Vector3 PreviousPosition => mSpline.PreviousPosition(this);

		public Vector3 NextNormal => mSpline.NextNormal(this);

		public Vector3 PreviousNormal => mSpline.PreviousNormal(this);

		public bool IsValid => NextControlPoint != null;

		private Vector3 GetNext2Position()
		{
			return NextControlPoint?.NextPosition ?? NextPosition;
		}

		private Vector3 GetNext2Normal()
		{
			return NextControlPoint?.NextNormal ?? Normal;
		}

		public Vector3 Interpolate(float localF)
		{
			localF = Mathf.Clamp01(localF);
			return Spline.CatmulRom(PreviousPosition, Position, NextPosition, GetNext2Position(), localF);
		}

		public Vector3 InterpolateNormal(float localF)
		{
			localF = Mathf.Clamp01(localF);
			return Spline.CatmulRom(PreviousNormal, Normal, NextNormal, GetNext2Normal(), localF);
		}

		public void Init(Spline owner)
		{
			mSpline = owner;
			SegmentIndex = -1;
		}
	}
	public class VertexPool
	{
		public class VertexSegment
		{
			public int VertStart;

			public int IndexStart;

			public int VertCount;

			public int IndexCount;

			public VertexPool Pool;

			public VertexSegment(int start, int count, int istart, int icount, VertexPool pool)
			{
				VertStart = start;
				VertCount = count;
				IndexCount = icount;
				IndexStart = istart;
				Pool = pool;
			}

			public void ClearIndices()
			{
				for (int i = IndexStart; i < IndexStart + IndexCount; i++)
				{
					Pool.Indices[i] = 0;
				}
				Pool.IndiceChanged = true;
			}
		}

		public Vector3[] Vertices;

		public int[] Indices;

		public Vector2[] UVs;

		public Color[] Colors;

		public bool IndiceChanged;

		public bool ColorChanged;

		public bool UVChanged;

		public bool VertChanged;

		public bool UV2Changed;

		protected int VertexTotal;

		protected int VertexUsed;

		protected int IndexTotal;

		protected int IndexUsed;

		public bool FirstUpdate = true;

		protected bool VertCountChanged;

		public const int BlockSize = 108;

		public float BoundsScheduleTime = 1f;

		public float ElapsedTime;

		protected XWeaponTrail _owner;

		protected MeshFilter _meshFilter;

		protected Mesh _mesh2d;

		protected Material _material;

		public Mesh MyMesh
		{
			get
			{
				if (_owner.UseWith2D || _owner.UseWithSRP)
				{
					if (_meshFilter == null || _meshFilter.gameObject == null)
					{
						return null;
					}
					return _meshFilter.sharedMesh;
				}
				return _mesh2d;
			}
		}

		public void RecalculateBounds()
		{
			MyMesh.RecalculateBounds();
		}

		public void SetMeshObjectActive(bool flag)
		{
			if (!(_meshFilter == null))
			{
				_meshFilter.gameObject.SetActive(flag);
			}
		}

		private void CreateMeshObj(XWeaponTrail owner, Material material)
		{
			GameObject gameObject = new GameObject("_XWeaponTrailMesh:|material:" + material.name);
			gameObject.layer = owner.gameObject.layer;
			gameObject.AddComponent<MeshFilter>();
			gameObject.AddComponent<MeshRenderer>();
			gameObject.transform.position = Vector3.zero;
			gameObject.transform.rotation = Quaternion.identity;
			_meshFilter = (MeshFilter)gameObject.GetComponent(typeof(MeshFilter));
			MeshRenderer obj = (MeshRenderer)gameObject.GetComponent(typeof(MeshRenderer));
			obj.shadowCastingMode = ShadowCastingMode.Off;
			obj.receiveShadows = false;
			obj.GetComponent<Renderer>().sharedMaterial = material;
			obj.sortingLayerName = _owner.SortingLayerName;
			obj.sortingOrder = _owner.SortingOrder;
			_meshFilter.sharedMesh = new Mesh();
		}

		public void Destroy()
		{
			if (_owner.UseWith2D || _owner.UseWithSRP)
			{
				if (_meshFilter != null)
				{
					UnityEngine.Object.Destroy(_meshFilter.gameObject);
				}
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(_mesh2d);
			}
		}

		public VertexPool(Material material, XWeaponTrail owner)
		{
			VertexTotal = (VertexUsed = 0);
			VertCountChanged = false;
			_owner = owner;
			if (owner.UseWith2D || owner.UseWithSRP)
			{
				CreateMeshObj(owner, material);
			}
			else
			{
				_mesh2d = new Mesh();
			}
			_material = material;
			InitArrays();
			IndiceChanged = (ColorChanged = (UVChanged = (UV2Changed = (VertChanged = true))));
		}

		public VertexSegment GetVertices(int vcount, int icount)
		{
			int num = 0;
			int num2 = 0;
			if (VertexUsed + vcount >= VertexTotal)
			{
				num = (vcount / 108 + 1) * 108;
			}
			if (IndexUsed + icount >= IndexTotal)
			{
				num2 = (icount / 108 + 1) * 108;
			}
			VertexUsed += vcount;
			IndexUsed += icount;
			if (num != 0 || num2 != 0)
			{
				EnlargeArrays(num, num2);
				VertexTotal += num;
				IndexTotal += num2;
			}
			return new VertexSegment(VertexUsed - vcount, vcount, IndexUsed - icount, icount, this);
		}

		protected void InitArrays()
		{
			Vertices = new Vector3[4];
			UVs = new Vector2[4];
			Colors = new Color[4];
			Indices = new int[6];
			VertexTotal = 4;
			IndexTotal = 6;
		}

		public void EnlargeArrays(int count, int icount)
		{
			Vector3[] vertices = Vertices;
			Vertices = new Vector3[Vertices.Length + count];
			vertices.CopyTo(Vertices, 0);
			Vector2[] uVs = UVs;
			UVs = new Vector2[UVs.Length + count];
			uVs.CopyTo(UVs, 0);
			Color[] colors = Colors;
			Colors = new Color[Colors.Length + count];
			colors.CopyTo(Colors, 0);
			int[] indices = Indices;
			Indices = new int[Indices.Length + icount];
			indices.CopyTo(Indices, 0);
			VertCountChanged = true;
			IndiceChanged = true;
			ColorChanged = true;
			UVChanged = true;
			VertChanged = true;
			UV2Changed = true;
		}

		public void LateUpdate()
		{
			if (MyMesh == null)
			{
				return;
			}
			if (VertCountChanged)
			{
				MyMesh.Clear();
			}
			MyMesh.vertices = Vertices;
			if (UVChanged)
			{
				MyMesh.uv = UVs;
			}
			if (ColorChanged)
			{
				MyMesh.colors = Colors;
			}
			if (IndiceChanged)
			{
				MyMesh.triangles = Indices;
			}
			ElapsedTime += Time.deltaTime;
			if (ElapsedTime > BoundsScheduleTime || FirstUpdate)
			{
				RecalculateBounds();
				ElapsedTime = 0f;
			}
			if (ElapsedTime > BoundsScheduleTime)
			{
				FirstUpdate = false;
			}
			VertCountChanged = false;
			IndiceChanged = false;
			ColorChanged = false;
			UVChanged = false;
			UV2Changed = false;
			VertChanged = false;
			if (!_owner.UseWith2D && !_owner.UseWithSRP)
			{
				Matrix4x4 matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one);
				for (int i = 0; i < _material.passCount; i++)
				{
					_material.SetPass(i);
				}
				if (!_owner.UseWithSRP)
				{
					Graphics.DrawMeshNow(MyMesh, matrix);
				}
				else
				{
					Graphics.DrawMesh(MyMesh, Matrix4x4.identity, _material, _owner.gameObject.layer, null, 0, null, castShadows: false, receiveShadows: false);
				}
			}
		}
	}
	public class XWeaponTrail : MonoBehaviour
	{
		public class Element
		{
			public Vector3 PointStart;

			public Vector3 PointEnd;

			public Vector3 Pos => (PointStart + PointEnd) / 2f;

			public Element(Vector3 start, Vector3 end)
			{
				PointStart = start;
				PointEnd = end;
			}

			public Element()
			{
			}
		}

		public class ElementPool
		{
			private readonly Stack<Element> _stack = new Stack<Element>();

			public int CountAll { get; private set; }

			public int CountActive => CountAll - CountInactive;

			public int CountInactive => _stack.Count;

			public ElementPool(int preCount)
			{
				for (int i = 0; i < preCount; i++)
				{
					Element item = new Element();
					_stack.Push(item);
					CountAll++;
				}
			}

			public Element Get()
			{
				Element result;
				if (_stack.Count == 0)
				{
					result = new Element();
					CountAll++;
				}
				else
				{
					result = _stack.Pop();
				}
				return result;
			}

			public void Release(Element element)
			{
				if (_stack.Count > 0 && _stack.Peek() == element)
				{
					UnityEngine.Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
				}
				_stack.Push(element);
			}
		}

		public static string Version = "1.4.3";

		public bool UseWith2D;

		public bool UseWithSRP;

		public string SortingLayerName;

		public int SortingOrder;

		public Transform PointStart;

		public Transform PointEnd;

		public int MaxFrame = 14;

		public int Granularity = 60;

		public float Fps = 60f;

		public Color MyColor = Color.white;

		public Material MyMaterial;

		protected float mTrailWidth;

		protected Element mHeadElem = new Element();

		protected List<Element> mSnapshotList = new List<Element>();

		protected ElementPool mElemPool;

		protected Spline mSpline = new Spline();

		protected float mFadeT = 1f;

		protected bool mIsFading;

		protected float mFadeTime = 1f;

		protected float mElapsedTime;

		protected float mFadeElapsedime;

		protected GameObject mMeshObj;

		protected VertexPool mVertexPool;

		protected VertexPool.VertexSegment mVertexSegment;

		protected bool mInited;

		protected bool mActivated;

		protected Camera _myCamera;

		public float UpdateInterval => 1f / Fps;

		public Vector3 CurHeadPos => (PointStart.position + PointEnd.position) / 2f;

		public float TrailWidth => mTrailWidth;

		public Camera MyCamera
		{
			get
			{
				if (_myCamera == null)
				{
					_myCamera = FindMyCamera();
				}
				return _myCamera;
			}
		}

		protected Camera FindMyCamera()
		{
			int num = 1 << base.gameObject.layer;
			Camera[] allCameras = Camera.allCameras;
			int i = 0;
			for (int num2 = allCameras.Length; i < num2; i++)
			{
				Camera camera = allCameras[i];
				if ((camera.cullingMask & num) != 0)
				{
					return camera;
				}
			}
			UnityEngine.Debug.LogError("can't find proper camera for layer:" + base.gameObject.layer);
			return null;
		}

		public void Init()
		{
			if (!mInited)
			{
				mElemPool = new ElementPool(MaxFrame);
				mTrailWidth = (PointStart.position - PointEnd.position).magnitude;
				InitMeshObj();
				InitOriginalElements();
				InitSpline();
				mInited = true;
			}
		}

		public void Activate()
		{
			if (!mActivated)
			{
				Init();
				mActivated = true;
				base.gameObject.SetActive(value: true);
				mFadeT = 1f;
				mIsFading = false;
				mFadeTime = 1f;
				mFadeElapsedime = 0f;
				mElapsedTime = 0f;
				for (int i = 0; i < mSnapshotList.Count; i++)
				{
					mSnapshotList[i].PointStart = PointStart.position;
					mSnapshotList[i].PointEnd = PointEnd.position;
					mSpline.ControlPoints[i].Position = mSnapshotList[i].Pos;
					mSpline.ControlPoints[i].Normal = mSnapshotList[i].PointEnd - mSnapshotList[i].PointStart;
				}
				RefreshSpline();
				UpdateVertex();
			}
		}

		public void Deactivate()
		{
			mActivated = false;
			base.gameObject.SetActive(value: false);
			mVertexPool.SetMeshObjectActive(flag: false);
		}

		public void StopSmoothly(float fadeTime)
		{
			mIsFading = true;
			mFadeTime = fadeTime;
		}

		private void OnEnable()
		{
			Activate();
			if (!UseWithSRP)
			{
				Camera.onPostRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPostRender, new Camera.CameraCallback(MyPostRender));
				Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(MyPreRender));
			}
		}

		private void OnDisable()
		{
			Deactivate();
			if (!UseWithSRP)
			{
				Camera.onPostRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPostRender, new Camera.CameraCallback(MyPostRender));
				Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(MyPreRender));
			}
		}

		private void LateUpdate()
		{
			if (UseWithSRP)
			{
				MyPreRender(MyCamera);
				MyPostRender(MyCamera);
			}
		}

		public void MyPreRender(Camera cam)
		{
			if (mInited && !(cam != MyCamera))
			{
				UpdateHeadElem();
				mElapsedTime += Time.deltaTime;
				if (mElapsedTime > UpdateInterval)
				{
					mElapsedTime = 0f;
					RecordCurElem();
				}
				RefreshSpline();
				UpdateFade();
				UpdateVertex();
			}
		}

		public void MyPostRender(Camera cam)
		{
			if (mInited && !(cam != MyCamera))
			{
				mVertexPool.SetMeshObjectActive(flag: true);
				mVertexPool.LateUpdate();
			}
		}

		private void OnDestroy()
		{
			if (mInited && mVertexPool != null)
			{
				mVertexPool.Destroy();
			}
		}

		private void Start()
		{
			mInited = false;
			Init();
		}

		private void OnDrawGizmos()
		{
			if (!(PointEnd == null) && !(PointStart == null))
			{
				float magnitude = (PointStart.position - PointEnd.position).magnitude;
				if (!(magnitude < Mathf.Epsilon))
				{
					Gizmos.color = Color.red;
					Gizmos.DrawSphere(PointStart.position, magnitude * 0.04f);
					Gizmos.color = Color.blue;
					Gizmos.DrawSphere(PointEnd.position, magnitude * 0.04f);
				}
			}
		}

		private void InitSpline()
		{
			mSpline.Granularity = Granularity;
			mSpline.Clear();
			for (int i = 0; i < MaxFrame; i++)
			{
				mSpline.AddControlPoint(CurHeadPos, PointStart.position - PointEnd.position);
			}
		}

		private void RefreshSpline()
		{
			for (int i = 0; i < mSnapshotList.Count; i++)
			{
				mSpline.ControlPoints[i].Position = mSnapshotList[i].Pos;
				mSpline.ControlPoints[i].Normal = mSnapshotList[i].PointEnd - mSnapshotList[i].PointStart;
			}
			mSpline.RefreshSpline();
		}

		private void UpdateVertex()
		{
			VertexPool pool = mVertexSegment.Pool;
			for (int i = 0; i < Granularity; i++)
			{
				int num = mVertexSegment.VertStart + i * 3;
				float num2 = (float)i / (float)Granularity;
				float tl = num2 * mFadeT;
				Vector2 zero = Vector2.zero;
				Vector3 vector = mSpline.InterpolateByLen(tl);
				Vector3 vector2 = mSpline.InterpolateNormalByLen(tl);
				Vector3 vector3 = vector + vector2.normalized * mTrailWidth * 0.5f;
				Vector3 vector4 = vector - vector2.normalized * mTrailWidth * 0.5f;
				pool.Vertices[num] = vector3;
				pool.Colors[num] = MyColor;
				zero.x = 0f;
				zero.y = num2;
				pool.UVs[num] = zero;
				pool.Vertices[num + 1] = vector;
				pool.Colors[num + 1] = MyColor;
				zero.x = 0.5f;
				zero.y = num2;
				pool.UVs[num + 1] = zero;
				pool.Vertices[num + 2] = vector4;
				pool.Colors[num + 2] = MyColor;
				zero.x = 1f;
				zero.y = num2;
				pool.UVs[num + 2] = zero;
			}
			mVertexSegment.Pool.UVChanged = true;
			mVertexSegment.Pool.VertChanged = true;
			mVertexSegment.Pool.ColorChanged = true;
		}

		private void UpdateIndices()
		{
			VertexPool pool = mVertexSegment.Pool;
			for (int i = 0; i < Granularity - 1; i++)
			{
				int num = mVertexSegment.VertStart + i * 3;
				int num2 = mVertexSegment.VertStart + (i + 1) * 3;
				int num3 = mVertexSegment.IndexStart + i * 12;
				pool.Indices[num3] = num2;
				pool.Indices[num3 + 1] = num2 + 1;
				pool.Indices[num3 + 2] = num;
				pool.Indices[num3 + 3] = num2 + 1;
				pool.Indices[num3 + 4] = num + 1;
				pool.Indices[num3 + 5] = num;
				pool.Indices[num3 + 6] = num2 + 1;
				pool.Indices[num3 + 7] = num2 + 2;
				pool.Indices[num3 + 8] = num + 1;
				pool.Indices[num3 + 9] = num2 + 2;
				pool.Indices[num3 + 10] = num + 2;
				pool.Indices[num3 + 11] = num + 1;
			}
			pool.IndiceChanged = true;
		}

		private void UpdateHeadElem()
		{
			mSnapshotList[0].PointStart = PointStart.position;
			mSnapshotList[0].PointEnd = PointEnd.position;
		}

		private void UpdateFade()
		{
			if (mIsFading)
			{
				mFadeElapsedime += Time.deltaTime;
				float num = mFadeElapsedime / mFadeTime;
				mFadeT = 1f - num;
				if (mFadeT < 0f)
				{
					Deactivate();
				}
			}
		}

		private void RecordCurElem()
		{
			Element element = mElemPool.Get();
			element.PointStart = PointStart.position;
			element.PointEnd = PointEnd.position;
			if (mSnapshotList.Count < MaxFrame)
			{
				mSnapshotList.Insert(1, element);
				return;
			}
			mElemPool.Release(mSnapshotList[mSnapshotList.Count - 1]);
			mSnapshotList.RemoveAt(mSnapshotList.Count - 1);
			mSnapshotList.Insert(1, element);
		}

		private void InitOriginalElements()
		{
			mSnapshotList.Clear();
			mSnapshotList.Add(new Element(PointStart.position, PointEnd.position));
			mSnapshotList.Add(new Element(PointStart.position, PointEnd.position));
		}

		private void InitMeshObj()
		{
			mVertexPool = new VertexPool(MyMaterial, this);
			mVertexSegment = mVertexPool.GetVertices(Granularity * 3, (Granularity - 1) * 12);
			UpdateIndices();
		}
	}
}
