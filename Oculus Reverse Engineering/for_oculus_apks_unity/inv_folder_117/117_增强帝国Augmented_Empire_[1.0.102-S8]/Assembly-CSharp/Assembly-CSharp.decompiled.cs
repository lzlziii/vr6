using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.IO.IsolatedStorage;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using Coatsink;
using Coatsink.Common;
using FMOD;
using FMOD.Studio;
using Oculus.Platform;
using Oculus.Platform.Models;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.Profiling;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.VR;

[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class AEMesh : ScriptableObject, IJK3DCustomMesh
{
	[Header("UV2 Settings")]
	[Space]
	public bool UV2GenerateUVS = true;

	[Range(0f, 100f)]
	public int UV2PixelMargin = 8;

	[Range(0.0001f, 90f)]
	public float UV2HardAngle = 50f;

	[Range(0.01f, 1f)]
	public float UV2AngleError = 0.08f;

	[Range(0f, 1f)]
	public float UV2AreaError = 0.15f;

	public bool CopyUV2ToUV1;

	public Mesh GetMesh()
	{
		return null;
	}

	public Material GetMaterial()
	{
		return null;
	}
}
public class AEMeshAsset : ScriptableObject
{
	public Mesh mesh;

	public Material material;
}
[Serializable]
public abstract class AnimValue<T>
{
	public Action OnComplete;

	public Action OnInterrupted;

	public Func<float, float> Interpolate = SmoothStep;

	public static readonly Func<float, float> Linear = (float x) => x;

	public static readonly Func<float, float> SmoothStep = (float x) => Mathf.SmoothStep(0f, 1f, x);

	public T vStart = default(T);

	public T vEnd = default(T);

	public T vCurrent = default(T);

	private float animTime;

	private float animTimeMax = 1f;

	private float delayTime;

	public HagletFlag _animating = new HagletFlag();

	public HagletCondition animating => _animating;

	public float Duration => animTimeMax;

	public T Target => vEnd;

	public T Value
	{
		get
		{
			return vCurrent;
		}
		set
		{
			vCurrent = (vStart = (vEnd = value));
		}
	}

	public T Update()
	{
		return Update(Time.deltaTime);
	}

	public abstract T Update(float step);

	public HagletCondition AnimateTo(T value, float duration, float delay = 0f)
	{
		if (duration == 0f)
		{
			vCurrent = (vStart = (vEnd = value));
			_animating.Clear();
		}
		else
		{
			_animating.Set();
		}
		if ((bool)animating && OnInterrupted != null)
		{
			OnInterrupted();
		}
		vStart = vCurrent;
		vEnd = value;
		animTime = (animTimeMax = duration);
		delayTime = delay;
		return animating;
	}

	protected float _UpdateInternals(float step)
	{
		if (delayTime > 0f)
		{
			delayTime -= step;
			return Interpolate(Mathf.Clamp01(1f - animTime / animTimeMax));
		}
		if (animTimeMax <= 0f)
		{
			animTimeMax = 1f;
			animTime = 0f;
		}
		float result = Interpolate(Mathf.Clamp01(1f - animTime / animTimeMax));
		if (animTime > 0f)
		{
			animTime -= step;
		}
		else if ((bool)animating)
		{
			_animating.Clear();
			if (OnComplete != null)
			{
				OnComplete();
			}
		}
		return result;
	}
}
[Serializable]
public class AnimColor : AnimValue<Color>
{
	public AnimColor()
	{
	}

	public AnimColor(Color color)
	{
		AnimateTo(color, 0f);
	}

	public override Color Update(float step)
	{
		return vCurrent = Color.Lerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimFloat : AnimValue<float>
{
	public AnimFloat()
	{
	}

	public AnimFloat(float value)
	{
		AnimateTo(value, 0f);
	}

	public override float Update(float step)
	{
		return vCurrent = vStart + (vEnd - vStart) * _UpdateInternals(step);
	}
}
[Serializable]
public class AnimVec2 : AnimValue<Vector2>
{
	public AnimVec2()
	{
	}

	public AnimVec2(Vector2 value)
	{
		AnimateTo(value, 0f);
	}

	public override Vector2 Update(float step)
	{
		return vCurrent = Vector2.Lerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimVec3 : AnimValue<Vector3>
{
	public AnimVec3()
	{
	}

	public AnimVec3(Vector3 value)
	{
		AnimateTo(value, 0f);
	}

	public override Vector3 Update(float step)
	{
		return vCurrent = Vector3.Lerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimVec4 : AnimValue<Vector4>
{
	public AnimVec4()
	{
	}

	public AnimVec4(Vector4 value)
	{
		AnimateTo(value, 0f);
	}

	public override Vector4 Update(float step)
	{
		return vCurrent = Vector4.Lerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimQuaternion : AnimValue<Quaternion>
{
	public AnimQuaternion()
	{
	}

	public AnimQuaternion(Quaternion value)
	{
		AnimateTo(value, 0f);
	}

	public override Quaternion Update(float step)
	{
		return vCurrent = Quaternion.Slerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimComplexAngle : AnimValue<ComplexAngle>
{
	public AnimComplexAngle()
	{
		vStart = (vEnd = (vCurrent = new ComplexAngle(0f, 1f)));
	}

	public AnimComplexAngle(ComplexAngle value)
	{
		AnimateTo(value, 0f);
	}

	public override ComplexAngle Update(float step)
	{
		return vCurrent = ComplexAngle.Slerp(vStart, vEnd, _UpdateInternals(step));
	}
}
[Serializable]
public class AnimFuncQueue
{
	private struct Func
	{
		public float time;

		public Action func;

		public Action<object> funcWithUserData;

		public object userData;
	}

	private Func[] funcs;

	private uint funcsNum;

	public AnimFuncQueue(int maxSize = 2)
	{
		funcs = new Func[maxSize];
	}

	public void Update(float timeStep)
	{
		uint num = 0u;
		while (num < funcsNum)
		{
			if (funcs[num].time > 0f)
			{
				funcs[num].time -= timeStep;
				if (funcs[num].time < 0f)
				{
					if (funcs[num].func != null)
					{
						funcs[num].func();
					}
					else
					{
						funcs[num].funcWithUserData(funcs[num].userData);
					}
					funcsNum--;
					if (num != funcsNum)
					{
						ref Func reference = ref funcs[num];
						reference = funcs[funcsNum];
						continue;
					}
				}
			}
			num++;
		}
	}

	public void Update()
	{
		Update(Time.deltaTime);
	}

	public void Queue(Action func, float time)
	{
		if (funcsNum == funcs.Length)
		{
			UnityEngine.Debug.LogError("AnimFuncQueue: Ran out of space!");
			return;
		}
		if (time < 0f)
		{
			func();
			return;
		}
		funcs[funcsNum].func = func;
		funcs[funcsNum].time = time;
		funcsNum++;
	}

	public void Queue(Action<object> func, float time, object userData)
	{
		if (funcsNum == funcs.Length)
		{
			UnityEngine.Debug.LogError("AnimFuncQueue: Ran out of space!");
			return;
		}
		if (time < 0f)
		{
			func(userData);
			return;
		}
		funcs[funcsNum].funcWithUserData = func;
		funcs[funcsNum].userData = userData;
		funcs[funcsNum].time = time;
		funcsNum++;
	}
}
[Serializable]
public abstract class AnimValueHaglet<T>
{
	protected HagletHost host;

	protected HagletResettable resettable;

	protected T vStart = default(T);

	protected T vEnd = default(T);

	private Action OnStart;

	private Action OnComplete;

	private Action<T> OnUpdate;

	protected float duration;

	protected float delay;

	private AnimValue<T> animValue => GetAnimValue();

	public float Duration => duration;

	public T Target => vEnd;

	public HagletEvent completed => resettable.completed;

	public bool IsRunning => (bool)resettable.running || resettable.markedToRunBy != null;

	protected AnimValueHaglet()
	{
	}

	public AnimValueHaglet(string name, HagletHost host, Action OnStart, Action<T> OnUpdate, Action OnComplete)
		: this(name, host, OnStart, OnUpdate, OnComplete, HagletStepTime.Update)
	{
	}

	public AnimValueHaglet(string name, HagletHost host, Action OnStart, Action<T> OnUpdate, Action OnComplete, HagletStepTime stepTime)
	{
		this.host = host;
		this.OnStart = OnStart;
		this.OnUpdate = OnUpdate;
		this.OnComplete = OnComplete;
		resettable = new HagletResettable(AnimRoutine(), name, stepTime);
	}

	public abstract AnimValue<T> GetAnimValue();

	public IEnumerator<HagletYieldTerm> AnimRoutine()
	{
		animValue.Value = vStart;
		animValue.AnimateTo(vEnd, duration, delay);
		if (OnUpdate != null)
		{
			OnUpdate(vStart);
		}
		while ((bool)animValue.animating)
		{
			yield return null;
			OnUpdate(animValue.Update(Time.deltaTime));
		}
		if (OnComplete != null)
		{
			OnComplete();
		}
	}

	public virtual void Start(T target, float duration, float delay = 0f)
	{
		vEnd = target;
		this.duration = duration;
		this.delay = delay;
		if (duration == 0f)
		{
			if (OnStart != null)
			{
				OnStart();
			}
			animValue.Value = vStart;
			animValue.AnimateTo(vEnd, 1f, delay);
			animValue.Update(1f);
			OnUpdate(vEnd);
			if (OnComplete != null)
			{
				OnComplete();
			}
		}
		else
		{
			HagletResettable.StartOrReset(resettable, host);
			if (OnStart != null)
			{
				OnStart();
			}
		}
	}

	public virtual void Start(T start, T target, float duration, float delay)
	{
		vStart = start;
		Start(target, duration, delay);
	}

	public virtual void StartCustom(T start, T target, float duration, float delay = 0f)
	{
		vStart = start;
		Start(target, duration, delay);
	}

	public void Stop()
	{
		if (IsRunning)
		{
			host.Pause(resettable);
			resettable.Reset();
		}
	}

	public void Reset()
	{
		resettable.Reset();
	}
}
[Serializable]
public class AnimFloatHaglet : AnimValueHaglet<float>
{
	private AnimFloat animFloat = new AnimFloat();

	public AnimFloatHaglet(string name, HagletHost host, Action OnStart, Action<float> OnUpdate, Action OnComplete = null, HagletStepTime stepTime = HagletStepTime.Update)
		: base(name, host, OnStart, OnUpdate, OnComplete, stepTime)
	{
	}

	protected AnimFloatHaglet()
	{
	}

	public override AnimValue<float> GetAnimValue()
	{
		return animFloat;
	}
}
namespace Coatsink
{
	[RequireComponent(typeof(Animation))]
	public class SimpleAnimationControl : MonoBehaviour
	{
		[HideInInspector]
		[SerializeField]
		private Animation anim;

		[Header("Changing the animation clip or", order = 0)]
		[Header("the normalised flag in play mode", order = 1)]
		[Header("is not currently supported.", order = 2)]
		[Space(25f, order = 3)]
		public float timeOffset;

		public float speed = 1f;

		public bool normalisedTimeOffset = true;

		public bool normalisedSpeed = true;

		private AnimationState animState;

		private float prevTimeOffset;

		private void Reset()
		{
			anim = GetComponent<Animation>();
		}

		private void OnValidate()
		{
			if (anim == null)
			{
				anim = GetComponent<Animation>();
			}
			if (UnityEngine.Application.isPlaying && !(anim.clip == null) && animState != null)
			{
				Apply();
			}
		}

		private void Start()
		{
			if (anim == null)
			{
				anim = GetComponent<Animation>();
			}
			if (!(anim.clip == null))
			{
				animState = anim[anim.clip.name];
				prevTimeOffset = 0f;
				Apply();
			}
		}

		private void Apply()
		{
			if (normalisedTimeOffset)
			{
				animState.normalizedTime += timeOffset - prevTimeOffset;
			}
			else
			{
				animState.time += timeOffset - prevTimeOffset;
			}
			if (normalisedSpeed)
			{
				animState.normalizedSpeed = speed;
			}
			else
			{
				animState.speed = speed;
			}
			prevTimeOffset = timeOffset;
		}
	}
}
[AttributeUsage(AttributeTargets.Method, Inherited = true)]
public class IntAsEnumAttribute : Attribute
{
	public readonly Type enumType;

	public IntAsEnumAttribute(Type enumType)
	{
		if (!enumType.IsEnum)
		{
			throw new Exception("Not an enum type");
		}
		this.enumType = enumType;
	}
}
public class FloatAsPackedPairAttribute : Attribute
{
}
public interface AnimationTestModeListener
{
	void OnTestModeBegan(GameObject Object);

	void OnTestModeEnded();
}
internal static class PS4Razor
{
	[DllImport("PS4Razor")]
	private static extern void MarkerPush_IMPL(string name, uint marker);

	[DllImport("PS4Razor")]
	private static extern void MarkerPop_IMPL();

	public static void MarkerPush(string name)
	{
	}

	public static void MarkerPop()
	{
	}
}
namespace Coatsink.Common
{
	public static class ComponentX
	{
		public static int GetFirstComponentTypePresent(this GameObject thisGo, out UnityEngine.Component component, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				component = thisGo.GetComponent(types[i]);
				if (component != null)
				{
					return i;
				}
			}
			component = null;
			return -1;
		}

		public static int GetFirstComponentTypePresent(this UnityEngine.Component thisComp, out UnityEngine.Component component, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				component = thisComp.GetComponent(types[i]);
				if (component != null)
				{
					return i;
				}
			}
			component = null;
			return -1;
		}

		public static int GetFirstBehaviourTypePresent(this GameObject thisGo, out Behaviour behaviour, bool includeDisabled = true, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				behaviour = thisGo.GetComponent(types[i]) as Behaviour;
				if (behaviour != null && (includeDisabled || behaviour.enabled))
				{
					return i;
				}
			}
			behaviour = null;
			return -1;
		}

		public static int GetFirstBehaviourTypePresent(this UnityEngine.Component thisComp, out Behaviour behaviour, bool includeDisabled = true, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				behaviour = thisComp.GetComponent(types[i]) as Behaviour;
				if (behaviour != null && (includeDisabled || behaviour.enabled))
				{
					return i;
				}
			}
			behaviour = null;
			return -1;
		}

		public static T GetComponentInAscendant<T>(this GameObject go, bool includeSelf = true, int depth = -1) where T : class
		{
			Transform transform = ((!includeSelf) ? go.transform.parent : go.transform);
			while (transform != null)
			{
				T component = transform.GetComponent<T>();
				if (component != null)
				{
					return component;
				}
				depth--;
				if (depth == 0)
				{
					break;
				}
				transform = transform.parent;
			}
			return (T)null;
		}

		public static T GetComponentInAscendant<T>(this UnityEngine.Component comp, bool includeSelf = true, int depth = -1) where T : class
		{
			Transform transform = ((!includeSelf) ? comp.transform.parent : comp.transform);
			while (transform != null)
			{
				T component = transform.GetComponent<T>();
				if (component != null)
				{
					return component;
				}
				depth--;
				if (depth == 0)
				{
					break;
				}
				transform = transform.parent;
			}
			return (T)null;
		}
	}
	public static class CollectionsX
	{
		public struct IndexValuePair<T>
		{
			public int index;

			public T value;
		}

		public static T[] Generate<T>(int qty) where T : new()
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = new T();
			}
			return array;
		}

		public static T[] Generate<T>(int qty, T initVal)
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = initVal;
			}
			return array;
		}

		public static List<T> GenerateList<T>(int qty) where T : new()
		{
			List<T> list = new List<T>(qty);
			while (--qty >= 0)
			{
				list.Add(new T());
			}
			return list;
		}

		public static T[] Population<T>(Func<T> generator, int qty)
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = generator();
			}
			return array;
		}

		public static void Remove<T>(this List<T> list, params IEnumerable<T>[] ranges)
		{
			foreach (IEnumerable<T> enumerable in ranges)
			{
				foreach (T item in enumerable)
				{
					list.Remove(item);
				}
			}
		}

		public static T GetValueAtWrappedOffset<T>(this IList<T> list, T member, int offset)
		{
			return list[(list.IndexOf(member) + offset).Wrap(list.Count)];
		}

		public static bool ContainsName(this IList<GameObject> enumerable, string name)
		{
			if (enumerable.FirstOfName(name) == null)
			{
				return false;
			}
			return true;
		}

		public static T FirstOfName<T>(this IList<T> list, string name) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				T result = list[i];
				if (result.name == name)
				{
					return result;
				}
			}
			return (T)null;
		}

		public static T RemoveByName<T>(this IList<T> list, string name, bool single = true) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				T result = list[i];
				if (result.name == name)
				{
					list.RemoveAt(i--);
					if (single)
					{
						return result;
					}
				}
			}
			return (T)null;
		}

		public static T[] Concat<T>(params T[][] arrays)
		{
			int num = 0;
			int num2 = 0;
			foreach (T[] array in arrays)
			{
				num += array.Length;
			}
			T[] array2 = new T[num];
			foreach (T[] array3 in arrays)
			{
				array3.CopyTo(array2, num2);
				num2 += array3.Length;
			}
			return array2;
		}

		public static T FirstOrDefault<T>(this IList<T> source, Func<T, bool> predicate, T defaultVal)
		{
			foreach (T item in source)
			{
				if (predicate(item))
				{
					return item;
				}
			}
			return defaultVal;
		}

		public static bool TryFirst<T>(this IList<T> source, Func<T, bool> predicate, ref T destination)
		{
			foreach (T item in source)
			{
				if (predicate(item))
				{
					destination = item;
					return true;
				}
			}
			return false;
		}

		public static IEnumerable<T> ConcatArgs<T>(this IEnumerable<T> collection, params T[] newMembers)
		{
			return collection.Concat(newMembers);
		}

		public static IEnumerable<T> RemoveWithIndices<T>(this IEnumerable<T> source, IEnumerable<int> indices)
		{
			int count = source.Count();
			IEnumerable<int> wrappedIndeces = indices.Select((int idx) => idx.Wrap(count));
			return from elem in source.ZipWithIndices()
				where !wrappedIndeces.Contains(elem.index)
				select elem.value;
		}

		public static IEnumerable<T> RemoveWithIndices<T>(this IEnumerable<T> collection, params int[] indices)
		{
			return collection.RemoveWithIndices((IEnumerable<int>)indices);
		}

		public static T[] RemoveValues<T>(this T[] array, params T[] values)
		{
			List<T> list = new List<T>(array.Length);
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				if (!values.Contains(array[i]))
				{
					list.Add(array[i]);
				}
			}
			return list.ToArray();
		}

		public static T[] InsertValuesAtIndices<T>(this T[] array, IDictionary<int, T[]> newMembers)
		{
			int num = array.Length;
			int num2 = num;
			foreach (KeyValuePair<int, T[]> newMember in newMembers)
			{
				num2 += newMember.Value.Length;
			}
			T[] array2 = new T[num2];
			int num3 = 0;
			int num4 = 0;
			T[] value;
			while (num4 < num)
			{
				if (newMembers.TryGetValue(num4, out value))
				{
					value.CopyTo(array2, num3);
					num3 += value.Length;
				}
				array2[num3++] = array[num4++];
			}
			if (newMembers.TryGetValue(num, out value))
			{
				value.CopyTo(array2, num3);
			}
			return array2;
		}

		public static T[] InsertValueAtIndex<T>(this T[] array, T newMember, int newIndex = -1)
		{
			if (newIndex == -1)
			{
				newIndex = array.Length;
			}
			int num = array.Length + 1;
			T[] array2 = new T[num];
			int num2 = newIndex;
			while (--num2 >= 0)
			{
				array2[num2] = array[num2];
			}
			array2[newIndex] = newMember;
			int num3 = num;
			while (--num3 > newIndex)
			{
				array2[num3] = array[num3];
			}
			return array2;
		}

		public static IEnumerable<IndexValuePair<T>> ZipWithIndices<T>(this IEnumerable<T> enumerable)
		{
			int index = 0;
			foreach (T member in enumerable)
			{
				yield return new IndexValuePair<T>
				{
					index = index++,
					value = member
				};
			}
		}

		public static void SetValues<T>(this T[] array, params T[] values)
		{
			int i = 0;
			for (int num = Mathf.Min(array.Length, values.Length); i < num; i++)
			{
				array[i] = values[i];
			}
		}

		public static IEnumerable<T> Sequence<T>(params T[] elements)
		{
			return elements;
		}

		public static IEnumerable<T> SimpleShuffle<T>(this IEnumerable<T> enumerable)
		{
			return enumerable.OrderBy((T idx) => UnityEngine.Random.value);
		}

		public static IEnumerator<T> GetPrecachedEnumerator<T>(this IEnumerable<T> enumerable)
		{
			return ((IEnumerable<T>)enumerable.ToArray()).GetEnumerator();
		}

		public static IEnumerable<TRes> AllPermutationsOf<TRes, T1, T2>(this Func<T1, T2, TRes> generate, IEnumerable<T1> col1, IEnumerable<T2> col2)
		{
			foreach (T1 elemFrom1 in col1)
			{
				foreach (T2 elemFrom2 in col2)
				{
					yield return generate(elemFrom1, elemFrom2);
				}
			}
		}

		public static IEnumerable<TRes> AllPermutationsOf<TRes, T1, T2, T3>(this Func<T1, T2, T3, TRes> generate, IEnumerable<T1> col1, IEnumerable<T2> col2, IEnumerable<T3> col3)
		{
			foreach (T1 elemFrom1 in col1)
			{
				foreach (T2 elemFrom2 in col2)
				{
					foreach (T3 elemFrom3 in col3)
					{
						yield return generate(elemFrom1, elemFrom2, elemFrom3);
					}
				}
			}
		}

		public static IEnumerable<TRes> AllPermutationsOf<TRes, T1, T2, T3, T4>(this Func<T1, T2, T3, T4, TRes> generate, IEnumerable<T1> col1, IEnumerable<T2> col2, IEnumerable<T3> col3, IEnumerable<T4> col4)
		{
			foreach (T1 elemFrom1 in col1)
			{
				foreach (T2 elemFrom2 in col2)
				{
					foreach (T3 elemFrom3 in col3)
					{
						foreach (T4 elemFrom4 in col4)
						{
							yield return generate(elemFrom1, elemFrom2, elemFrom3, elemFrom4);
						}
					}
				}
			}
		}

		public static void Zip<T1, T2>(T1[] col1, T2[] col2, Action<T1, T2> zipper)
		{
			int num = Math.Min(col1.Length, col2.Length);
			for (int i = 0; i < num; i++)
			{
				zipper(col1[i], col2[i]);
			}
		}

		public static void Zip<T1, T2>(IEnumerable<T1> col1, IEnumerable<T2> col2, Action<T1, T2> zipper)
		{
			IEnumerator<T1> enumerator = col1.GetEnumerator();
			IEnumerator<T2> enumerator2 = col2.GetEnumerator();
			while (enumerator.MoveNext() & enumerator2.MoveNext())
			{
				zipper(enumerator.Current, enumerator2.Current);
			}
		}

		public static void ShuffleArray<T>(T[] array)
		{
			for (int num = array.Length - 1; num > 0; num--)
			{
				int num2 = UnityEngine.Random.Range(0, num);
				T val = array[num];
				array[num] = array[num2];
				array[num2] = val;
			}
		}

		public static void Order<T>(ref T smaller, ref T larger) where T : IComparable<T>
		{
			if (smaller.CompareTo(larger) > 0)
			{
				Misc.Swap(ref smaller, ref larger);
			}
		}
	}
	[Serializable]
	public class ConstArray<T>
	{
		public T[] _data;

		[ReadOnly]
		[SerializeField]
		[HideInInspector]
		public uint _dataNum;

		public T this[uint key]
		{
			get
			{
				return _data[key];
			}
			set
			{
				_data[key] = value;
			}
		}

		public T this[int key]
		{
			get
			{
				return _data[key];
			}
			set
			{
				_data[key] = value;
			}
		}

		public uint Length => _dataNum;

		public int sLength => (int)_dataNum;

		public int MaxSize => _data.Length;

		public ConstArray(uint size)
		{
			_data = new T[size];
		}

		protected ConstArray()
		{
		}

		public void Add(T obj)
		{
			if (_dataNum < _data.Length)
			{
				_data[_dataNum] = obj;
				_dataNum++;
			}
			else
			{
				UnityEngine.Debug.LogError("Array Out of Bounds: Increase Size (" + _data[0].ToString() + ")");
			}
		}

		public void Insert(T obj, uint index)
		{
			if (index > _dataNum)
			{
				Add(obj);
			}
			else if (_dataNum < _data.Length)
			{
				_dataNum++;
				T val = _data[index];
				T val2 = _data[index];
				for (uint num = index + 1; num < _dataNum; num++)
				{
					val = _data[num];
					_data[num] = val2;
					val2 = val;
				}
				_data[index] = obj;
			}
			else
			{
				UnityEngine.Debug.LogError("Array Out of Bounds: Increase Size (" + _data[0].ToString() + ")");
			}
		}

		public void Remove(T objectT)
		{
			for (int i = 0; i < _dataNum; i++)
			{
				if (_data[i].Equals(objectT))
				{
					_data[i] = _data[_dataNum - 1];
					_dataNum--;
					break;
				}
			}
		}

		public void RemoveAtIndex(uint index)
		{
			_data[index] = _data[_dataNum - 1];
			_dataNum--;
		}

		public bool Contains(T objectT)
		{
			for (int i = 0; i < _dataNum; i++)
			{
				if (_data[i].Equals(objectT))
				{
					return true;
				}
			}
			return false;
		}

		public void RemoveStable(T objectT)
		{
			uint num = uint.MaxValue;
			for (uint num2 = 0u; num2 < _dataNum; num2++)
			{
				if (objectT.Equals(_data[num2]))
				{
					num = num2;
					break;
				}
			}
			if (num < _dataNum)
			{
				RemoveAtIndexStable(num);
			}
		}

		public void RemoveAtIndexStable(uint index)
		{
			for (uint num = index; num < _dataNum - 1; num++)
			{
				_data[num] = _data[num + 1];
			}
			_dataNum--;
		}

		public void Clear()
		{
			_dataNum = 0u;
		}

		public void ClearToDefault()
		{
			for (int i = 0; i < _data.Length; i++)
			{
				_data[i] = default(T);
			}
			Clear();
		}

		public T[] ToArray()
		{
			T[] array = new T[_dataNum];
			for (int i = 0; i < _dataNum; i++)
			{
				array[i] = _data[i];
			}
			return array;
		}

		public void CopyTo(ConstArray<T> dest)
		{
			T[] data = dest._data;
			uint num = Math.Min((uint)data.Length, _dataNum);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = ((i >= num) ? default(T) : _data[i]);
			}
			dest._dataNum = num;
		}
	}
	public class ConstQueue<T> where T : new()
	{
		public T[] _data;

		private int _dataIndexCurrent;

		private int _dataIndexTarget;

		public int FrontIndex => _dataIndexCurrent;

		public int MaxSize => _data.Length;

		public bool Any => _dataIndexTarget != _dataIndexCurrent;

		public T this[int index]
		{
			get
			{
				return _data[(_dataIndexCurrent + index) % _data.Length];
			}
			set
			{
				_data[(_dataIndexCurrent + index) % _data.Length] = value;
			}
		}

		public int Length
		{
			get
			{
				return Mathf.Abs(_dataIndexTarget - _dataIndexCurrent);
			}
			set
			{
				_dataIndexTarget = (_dataIndexCurrent + value) % _data.Length;
			}
		}

		public ConstQueue(int size)
		{
			_data = new T[size];
			for (uint num = 0u; num < size; num++)
			{
				_data[num] = new T();
			}
			_dataIndexCurrent = (_dataIndexTarget = 0);
		}

		public void Enqueue(T obj)
		{
			_data[_dataIndexTarget] = obj;
			_dataIndexTarget = (_dataIndexTarget + 1) % _data.Length;
		}

		public T Dequeue()
		{
			T result = _data[_dataIndexCurrent];
			_dataIndexCurrent = (_dataIndexCurrent + 1) % _data.Length;
			return result;
		}

		public void Clear()
		{
			_dataIndexTarget = _dataIndexCurrent;
		}

		public T Peek()
		{
			return _data[_dataIndexCurrent];
		}
	}
	public static class ArrayX
	{
		public static bool IsNullOrEmpty(Array array)
		{
			return array == null || array.Length == 0;
		}

		public static bool Contains(this Array array, object value)
		{
			int num = array.Length;
			while (--num >= 0)
			{
				if (array.GetValue(num) == value)
				{
					return true;
				}
			}
			return false;
		}

		public static bool HasDuplicates(this Array array)
		{
			int num = array.Length;
			while (--num >= 0)
			{
				int num2 = array.Length;
				while (--num2 >= 0)
				{
					if (num != num2 && array.GetValue(num) == array.GetValue(num2))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void Shuffle<T>(this T[] array)
		{
			int num = array.Length;
			while (num > 1)
			{
				num--;
				int num2 = UnityEngine.Random.Range(0, num);
				T val = array[num2];
				array[num2] = array[num];
				array[num] = val;
			}
		}
	}
	public class DynamicSet<T> : IEnumerable<T>, IEnumerable
	{
		private class Frame : IDisposable, IEnumerator<T>, IEnumerator
		{
			private readonly DynamicSet<T> owner;

			public readonly IEnumerator<T> server;

			public bool free;

			object IEnumerator.Current => server.Current;

			public T Current => server.Current;

			public Frame(DynamicSet<T> owner, IEnumerator<T> server)
			{
				this.server = server;
				this.owner = owner;
				free = true;
			}

			public bool MoveNext()
			{
				return server.MoveNext();
			}

			public void Reset()
			{
				server.Reset();
			}

			protected virtual void Dispose(bool disposing)
			{
				if (!free && disposing)
				{
					owner.Reset(this);
				}
			}

			void IDisposable.Dispose()
			{
				Dispose(disposing: true);
			}
		}

		private readonly FieldInfo sourcePC;

		private readonly FieldInfo serverPC;

		private readonly IEnumerable<T> factory;

		private readonly Frame[] frames;

		private readonly object resetPoint;

		private static readonly object defaultResetPoint = 0;

		private static readonly object preStartedResetPoint = 1;

		public DynamicSet(IEnumerable<T> factory, bool prestep = false, int cap = 1)
		{
			this.factory = factory;
			frames = new Frame[cap];
			IEnumerator<T> enumerator = null;
			IEnumerator<T> enumerator2 = null;
			for (int i = 0; i < cap; i++)
			{
				enumerator = factory.GetEnumerator();
				if (prestep)
				{
					enumerator.MoveNext();
				}
				frames[i] = new Frame(this, enumerator2 = Server(enumerator));
			}
			resetPoint = ((!prestep) ? defaultResetPoint : preStartedResetPoint);
			sourcePC = enumerator.GetType().GetField("$PC", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			serverPC = enumerator2.GetType().GetField("$PC", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<T>)this).GetEnumerator();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			Frame frame = null;
			int i = 0;
			for (int num = frames.Length; i < num; i++)
			{
				if (frames[i].free)
				{
					frame = frames[i];
					break;
				}
			}
			serverPC.SetValue(frame.server, defaultResetPoint);
			frame.free = false;
			return frame;
		}

		private IEnumerator<T> Server(IEnumerator<T> sourceRoutine)
		{
			sourcePC.SetValue(sourceRoutine, resetPoint);
			while (sourceRoutine.MoveNext())
			{
				if (Test(sourceRoutine.Current))
				{
					yield return sourceRoutine.Current;
				}
			}
		}

		public virtual bool Test(T element)
		{
			return true;
		}

		private void Reset(Frame frame)
		{
			serverPC.SetValue(frame.server, defaultResetPoint);
			frame.free = true;
		}
	}
	public class DynamicFilteredSet<T> : DynamicSet<T>
	{
		private readonly Func<T, bool> filter;

		public DynamicFilteredSet(IEnumerable<T> factory, Func<T, bool> filter, bool prestep = false, int cap = 1)
			: base(factory, prestep, cap)
		{
			this.filter = filter;
		}

		public override bool Test(T element)
		{
			return filter(element);
		}
	}
	public class DynamicFilteredSet<T, PT> : DynamicSet<T>
	{
		private readonly Func<T, PT, bool> filter;

		public PT paramVal { get; private set; }

		public DynamicFilteredSet(IEnumerable<T> factory, Func<T, PT, bool> filter = null, bool prestep = false, int cap = 1)
			: base(factory, prestep, cap)
		{
			this.filter = filter;
		}

		public override bool Test(T element)
		{
			return filter(element, paramVal);
		}

		public static DynamicFilteredSet<T, PT> operator |(DynamicFilteredSet<T, PT> set, PT paramVal)
		{
			set.paramVal = paramVal;
			return set;
		}
	}
	public static class DynamicSetExtensions
	{
		public static DynamicSet<T> ToSet<T>(this IEnumerable<T> factory, Func<T, bool> filter = null, bool prestep = false, int cap = 1)
		{
			if (filter != null)
			{
				return new DynamicFilteredSet<T>(factory, filter, prestep, cap);
			}
			return new DynamicSet<T>(factory, prestep, cap);
		}

		public static DynamicFilteredSet<T, PT> ToSet<T, PT>(this IEnumerable<T> factory, Func<T, PT, bool> filter, bool prestep = false, int cap = 1)
		{
			return new DynamicFilteredSet<T, PT>(factory, filter, prestep, cap);
		}
	}
	public class InspectorButton : PropertyAttribute
	{
		public interface IPressable
		{
			void Press();
		}

		public readonly string title;

		public InspectorButton(string title = null)
		{
			this.title = title;
		}
	}
	public static class Misc
	{
		public static T OrIfNull<T>(this T objA, T objB) where T : UnityEngine.Object
		{
			return (!objA) ? objB : objA;
		}

		public static bool IsOneOf<T>(this T tThis, params T[] tParams) where T : class
		{
			foreach (T val in tParams)
			{
				if (tThis == val)
				{
					return true;
				}
			}
			return false;
		}

		public static void Swap<T>(ref T a, ref T b)
		{
			T val = a;
			a = b;
			b = val;
		}

		public static void CopyTo(this Stream input, Stream output, byte[] buffer)
		{
			int count;
			while ((count = input.Read(buffer, 0, buffer.Length)) > 0)
			{
				output.Write(buffer, 0, count);
			}
		}

		public static void MeshDeepCopy(Mesh destMesh, Mesh srcMesh)
		{
			destMesh.name = srcMesh.name;
			destMesh.Clear();
			destMesh.vertices = srcMesh.vertices;
			destMesh.normals = srcMesh.normals;
			destMesh.tangents = srcMesh.tangents;
			destMesh.uv = srcMesh.uv;
			destMesh.uv2 = srcMesh.uv2;
			destMesh.uv3 = srcMesh.uv3;
			destMesh.uv4 = srcMesh.uv4;
			destMesh.colors = srcMesh.colors;
			destMesh.colors32 = srcMesh.colors32;
			destMesh.triangles = srcMesh.triangles;
			destMesh.boneWeights = srcMesh.boneWeights;
			destMesh.bounds = srcMesh.bounds;
		}

		public static Mesh AllocateLightmappedMesh(Mesh srcMesh, Vector4 lightmapScaleOffset)
		{
			Mesh mesh = new Mesh();
			mesh.name = "LM_" + srcMesh.name;
			mesh.vertices = srcMesh.vertices;
			mesh.triangles = srcMesh.triangles;
			mesh.uv = srcMesh.uv;
			mesh.normals = srcMesh.normals;
			mesh.colors = srcMesh.colors;
			mesh.tangents = srcMesh.tangents;
			Vector2[] uv = srcMesh.uv2;
			if (uv == null || uv.Length == 0)
			{
				UnityEngine.Debug.LogWarning("'" + srcMesh.name + "' has no UV2's!", srcMesh);
				return mesh;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				uv[i].x = uv[i].x * lightmapScaleOffset.x + lightmapScaleOffset.z;
				uv[i].y = uv[i].y * lightmapScaleOffset.y + lightmapScaleOffset.w;
			}
			mesh.uv2 = uv;
			return mesh;
		}

		public static void TryMakeFTPFolder(string url)
		{
			Stream stream = null;
			FtpWebResponse ftpWebResponse = null;
			try
			{
				FtpWebRequest ftpWebRequest = (FtpWebRequest)WebRequest.Create(url);
				ftpWebRequest.ReadWriteTimeout = 1000;
				ftpWebRequest.Credentials = new NetworkCredential("anonymous", string.Empty);
				ftpWebRequest.Method = "MKD";
				ftpWebRequest.UseBinary = true;
				ftpWebResponse = (FtpWebResponse)ftpWebRequest.GetResponse();
				stream = ftpWebResponse.GetResponseStream();
				stream.Close();
				stream = null;
				ftpWebResponse.Close();
				ftpWebResponse = null;
			}
			catch (WebException ex)
			{
				if (!ex.Message.Contains("already exists"))
				{
				}
			}
			catch (Exception ex2)
			{
				stream?.Close();
				ftpWebResponse?.Close();
				throw ex2;
			}
		}

		public static void TryCopyLocalFileToFTP(string path, string url)
		{
			Stream stream = null;
			FtpWebResponse ftpWebResponse = null;
			try
			{
				byte[] array = File.ReadAllBytes(path);
				FtpWebRequest ftpWebRequest = (FtpWebRequest)WebRequest.Create(url);
				ftpWebRequest.ReadWriteTimeout = 1000;
				ftpWebRequest.Credentials = new NetworkCredential("anonymous", string.Empty);
				ftpWebRequest.Method = "STOR";
				ftpWebRequest.ContentLength = array.Length;
				stream = ftpWebRequest.GetRequestStream();
				stream.Write(array, 0, array.Length);
				stream.Close();
				stream = null;
				ftpWebResponse = (FtpWebResponse)ftpWebRequest.GetResponse();
				ftpWebResponse.Close();
				ftpWebResponse = null;
			}
			catch (Exception ex)
			{
				stream?.Close();
				ftpWebResponse?.Close();
				throw ex;
			}
		}

		public static T PushTo<T>(this T lt, ref T rt)
		{
			T result = rt;
			rt = lt;
			return result;
		}

		public static string ExtractStreamingAssetsToDataPath(string filepathInStreamingAssets)
		{
			string text = "jar:file://" + UnityEngine.Application.dataPath + "!/assets";
			string url = text + "/" + filepathInStreamingAssets;
			string text2 = UnityEngine.Application.persistentDataPath + "/" + filepathInStreamingAssets;
			Directory.CreateDirectory(Path.GetDirectoryName(text2));
			if (File.Exists(text2))
			{
				File.Delete(text2);
			}
			WWW wWW = new WWW(url);
			while (!wWW.isDone)
			{
			}
			UnityEngine.Debug.Log("Android unpacked jar path: " + text2);
			File.WriteAllBytes(text2, wWW.bytes);
			return text2;
		}
	}
	public static class Wrapper
	{
		public static Wrapper<T> Around<T>(T valIn = default(T))
		{
			return new Wrapper<T>(valIn);
		}
	}
	[Serializable]
	public class Wrapper<T>
	{
		public T val;

		public Wrapper(T valIn)
		{
			val = valIn;
		}

		public static explicit operator T(Wrapper<T> wrapper)
		{
			return wrapper.val;
		}

		public override string ToString()
		{
			return (val == null) ? "null" : val.ToString();
		}
	}
	public static class CLArguments
	{
		public static Dictionary<string, List<string>> _commandLineArgs;

		public static Dictionary<string, List<string>> commandLineArgs
		{
			get
			{
				if (_commandLineArgs == null)
				{
					_commandLineArgs = new Dictionary<string, List<string>>();
					string[] array = Environment.GetCommandLineArgs();
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i].StartsWith("-"))
						{
							string key = array[i].Substring(1);
							string item = ((i >= array.Length - 1 || array[i + 1].StartsWith("-")) ? null : array[i + 1]);
							if (_commandLineArgs.TryGetValue(key, out var value))
							{
								value.Add(item);
								continue;
							}
							value = new List<string>();
							value.Add(item);
							_commandLineArgs.Add(key, value);
						}
					}
				}
				return _commandLineArgs;
			}
		}

		public static string GetArgument(string keyname, string defaultValue)
		{
			List<string> value;
			return (!commandLineArgs.TryGetValue(keyname, out value)) ? defaultValue : value[0];
		}

		public static string[] GetArgumentsOrNull(string keyname)
		{
			List<string> value;
			return (!commandLineArgs.TryGetValue(keyname, out value)) ? null : value.ToArray();
		}

		public static bool GetArgumentExists(string keyname)
		{
			return commandLineArgs.ContainsKey(keyname);
		}

		public static int GetIntArgument(string keyname, int defaultValue)
		{
			int result = defaultValue;
			if (commandLineArgs.TryGetValue(keyname, out var value))
			{
				result = int.Parse(value[0]);
			}
			return result;
		}

		public static T FirstOrDefault<T>(this IEnumerable<T> source, Func<T, bool> predicate, T defaultVal)
		{
			foreach (T item in source)
			{
				if (predicate(item))
				{
					return item;
				}
			}
			return defaultVal;
		}

		public static string Truncate(this string str, int maxLen)
		{
			if (str.Length > maxLen)
			{
				return str.Substring(0, maxLen);
			}
			return str;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct primitive
	{
		[FieldOffset(0)]
		public readonly bool @bool;

		[FieldOffset(0)]
		public readonly char @char;

		[FieldOffset(0)]
		public readonly byte @byte;

		[FieldOffset(0)]
		public readonly ushort @ushort;

		[FieldOffset(0)]
		public readonly uint @uint;

		[FieldOffset(0)]
		public readonly ulong @ulong;

		[FieldOffset(0)]
		public readonly sbyte @sbyte;

		[FieldOffset(0)]
		public readonly short @short;

		[FieldOffset(0)]
		public readonly int @int;

		[FieldOffset(0)]
		public readonly long @long;

		[FieldOffset(0)]
		public readonly float @float;

		[FieldOffset(0)]
		public readonly double @double;

		[FieldOffset(0)]
		public readonly bool bool_0;

		[FieldOffset(1)]
		public readonly bool bool_1;

		[FieldOffset(2)]
		public readonly bool bool_2;

		[FieldOffset(3)]
		public readonly bool bool_3;

		[FieldOffset(4)]
		public readonly bool bool_4;

		[FieldOffset(5)]
		public readonly bool bool_5;

		[FieldOffset(6)]
		public readonly bool bool_6;

		[FieldOffset(7)]
		public readonly bool bool_7;

		[FieldOffset(0)]
		public readonly byte byte_0;

		[FieldOffset(1)]
		public readonly byte byte_1;

		[FieldOffset(2)]
		public readonly byte byte_2;

		[FieldOffset(3)]
		public readonly byte byte_3;

		[FieldOffset(4)]
		public readonly byte byte_4;

		[FieldOffset(5)]
		public readonly byte byte_5;

		[FieldOffset(6)]
		public readonly byte byte_6;

		[FieldOffset(7)]
		public readonly byte byte_7;

		[FieldOffset(0)]
		public readonly int int_0;

		[FieldOffset(4)]
		public readonly int int_1;

		[FieldOffset(0)]
		public readonly float float_0;

		[FieldOffset(4)]
		public readonly float float_1;

		public primitive(bool val)
		{
			this = default(primitive);
			@bool = val;
		}

		public primitive(char val)
		{
			this = default(primitive);
			@char = val;
		}

		public primitive(byte val)
		{
			this = default(primitive);
			@byte = val;
		}

		public primitive(ushort val)
		{
			this = default(primitive);
			@ushort = val;
		}

		public primitive(uint val)
		{
			this = default(primitive);
			@uint = val;
		}

		public primitive(ulong val)
		{
			this = default(primitive);
			@ulong = val;
		}

		public primitive(sbyte val)
		{
			this = default(primitive);
			@sbyte = val;
		}

		public primitive(short val)
		{
			this = default(primitive);
			@short = val;
		}

		public primitive(int val)
		{
			this = default(primitive);
			@int = val;
		}

		public primitive(long val)
		{
			this = default(primitive);
			@long = val;
		}

		public primitive(float val)
		{
			this = default(primitive);
			@float = val;
		}

		public primitive(double val)
		{
			this = default(primitive);
			@double = val;
		}

		public primitive(DateTime val)
		{
			this = default(primitive);
			@long = val.ToBinary();
		}

		public primitive(IntPtr val)
		{
			this = default(primitive);
			if (IntPtr.Size == 4)
			{
				@int = val.ToInt32();
			}
			else
			{
				@long = val.ToInt64();
			}
		}

		public primitive(UIntPtr val)
		{
			this = default(primitive);
			if (UIntPtr.Size == 4)
			{
				@uint = val.ToUInt32();
			}
			else
			{
				@ulong = val.ToUInt64();
			}
		}

		public primitive(object obj)
			: this(obj, Convert.GetTypeCode(obj))
		{
		}

		public primitive(object obj, TypeCode code)
		{
			this = default(primitive);
			switch (code)
			{
			case TypeCode.Boolean:
				@bool = (bool)obj;
				break;
			case TypeCode.Char:
				@char = (char)obj;
				break;
			case TypeCode.Byte:
				@byte = (byte)obj;
				break;
			case TypeCode.UInt16:
				@ushort = (ushort)obj;
				break;
			case TypeCode.UInt32:
				@uint = (uint)obj;
				break;
			case TypeCode.UInt64:
				@ulong = (ulong)obj;
				break;
			case TypeCode.SByte:
				@sbyte = (sbyte)obj;
				break;
			case TypeCode.Int16:
				@short = (short)obj;
				break;
			case TypeCode.Int32:
				@int = (int)obj;
				break;
			case TypeCode.Int64:
				@long = (long)obj;
				break;
			case TypeCode.Single:
				@float = (float)obj;
				break;
			case TypeCode.Double:
				@double = (double)obj;
				break;
			case TypeCode.DateTime:
				@long = ((DateTime)obj).ToBinary();
				break;
			case TypeCode.Decimal:
				break;
			}
		}

		public static implicit operator primitive(bool val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(char val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(byte val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(ushort val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(uint val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(ulong val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(sbyte val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(short val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(int val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(long val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(float val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(double val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(DateTime val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(IntPtr val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(UIntPtr val)
		{
			return new primitive(val);
		}

		public static implicit operator bool(primitive prim)
		{
			return prim.@bool;
		}

		public static implicit operator char(primitive prim)
		{
			return prim.@char;
		}

		public static implicit operator byte(primitive prim)
		{
			return prim.@byte;
		}

		public static implicit operator ushort(primitive prim)
		{
			return prim.@ushort;
		}

		public static implicit operator uint(primitive prim)
		{
			return prim.@uint;
		}

		public static implicit operator ulong(primitive prim)
		{
			return prim.@ulong;
		}

		public static implicit operator sbyte(primitive prim)
		{
			return prim.@sbyte;
		}

		public static implicit operator short(primitive prim)
		{
			return prim.@short;
		}

		public static implicit operator int(primitive prim)
		{
			return prim.@int;
		}

		public static implicit operator long(primitive prim)
		{
			return prim.@long;
		}

		public static implicit operator float(primitive prim)
		{
			return prim.@float;
		}

		public static implicit operator double(primitive prim)
		{
			return prim.@double;
		}

		public static implicit operator DateTime(primitive prim)
		{
			return DateTime.FromBinary(prim.@long);
		}

		public static implicit operator IntPtr(primitive prim)
		{
			return (IntPtr.Size != 4) ? new IntPtr(prim.@long) : new IntPtr(prim.@int);
		}

		public static implicit operator UIntPtr(primitive prim)
		{
			return (UIntPtr.Size != 4) ? new UIntPtr(prim.@ulong) : new UIntPtr(prim.@uint);
		}

		public string ToString(TypeCode code, string format = null)
		{
			return code switch
			{
				TypeCode.Boolean => @bool.ToString(), 
				TypeCode.Char => @char.ToString(), 
				TypeCode.Byte => @byte.ToString(format), 
				TypeCode.UInt16 => @ushort.ToString(format), 
				TypeCode.UInt32 => @uint.ToString(format), 
				TypeCode.UInt64 => @ulong.ToString(format), 
				TypeCode.SByte => @sbyte.ToString(format), 
				TypeCode.Int16 => @short.ToString(format), 
				TypeCode.Int32 => @int.ToString(format), 
				TypeCode.Int64 => @long.ToString(format), 
				TypeCode.Single => @float.ToString(format), 
				TypeCode.Double => @double.ToString(format), 
				TypeCode.DateTime => DateTime.FromBinary(@long).ToString(format), 
				_ => null, 
			};
		}

		public object Get(TypeCode code)
		{
			return code switch
			{
				TypeCode.Boolean => @bool, 
				TypeCode.Char => @char, 
				TypeCode.Byte => @byte, 
				TypeCode.UInt16 => @ushort, 
				TypeCode.UInt32 => @uint, 
				TypeCode.UInt64 => @ulong, 
				TypeCode.SByte => @sbyte, 
				TypeCode.Int16 => @short, 
				TypeCode.Int32 => @int, 
				TypeCode.Int64 => @long, 
				TypeCode.Single => @float, 
				TypeCode.Double => @double, 
				TypeCode.DateTime => DateTime.FromBinary(@long), 
				_ => null, 
			};
		}

		public static bool operator ==(primitive left, primitive right)
		{
			return left.@long == right.@long;
		}

		public static bool operator !=(primitive left, primitive right)
		{
			return left.@long != right.@long;
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return @long.GetHashCode();
		}
	}
	public static class PrimitiveExtensions
	{
		public static Type GetCodedType(this TypeCode code)
		{
			return code switch
			{
				TypeCode.Boolean => typeof(bool), 
				TypeCode.Char => typeof(char), 
				TypeCode.Byte => typeof(byte), 
				TypeCode.UInt16 => typeof(ushort), 
				TypeCode.UInt32 => typeof(uint), 
				TypeCode.UInt64 => typeof(ulong), 
				TypeCode.SByte => typeof(sbyte), 
				TypeCode.Int16 => typeof(short), 
				TypeCode.Int32 => typeof(int), 
				TypeCode.Int64 => typeof(long), 
				TypeCode.Single => typeof(float), 
				TypeCode.Double => typeof(double), 
				TypeCode.DateTime => typeof(DateTime), 
				TypeCode.String => typeof(string), 
				_ => null, 
			};
		}
	}
	public struct oprimitive
	{
		public readonly TypeCode type;

		public readonly primitive prim;

		public readonly object obj;

		public oprimitive(bool val)
			: this(TypeCode.Boolean, val)
		{
		}

		public oprimitive(char val)
			: this(TypeCode.Char, val)
		{
		}

		public oprimitive(byte val)
			: this(TypeCode.Byte, val)
		{
		}

		public oprimitive(ushort val)
			: this(TypeCode.UInt16, val)
		{
		}

		public oprimitive(uint val)
			: this(TypeCode.UInt32, val)
		{
		}

		public oprimitive(ulong val)
			: this(TypeCode.UInt64, val)
		{
		}

		public oprimitive(sbyte val)
			: this(TypeCode.SByte, val)
		{
		}

		public oprimitive(short val)
			: this(TypeCode.Int16, val)
		{
		}

		public oprimitive(int val)
			: this(TypeCode.Int32, val)
		{
		}

		public oprimitive(long val)
			: this(TypeCode.Int64, val)
		{
		}

		public oprimitive(float val)
			: this(TypeCode.Single, val)
		{
		}

		public oprimitive(double val)
			: this(TypeCode.Double, val)
		{
		}

		public oprimitive(DateTime val)
			: this(TypeCode.DateTime, val)
		{
		}

		public oprimitive(string str)
		{
			if (str != null)
			{
				type = TypeCode.String;
				prim = str.Length;
			}
			else
			{
				type = TypeCode.Empty;
				prim = 0;
			}
			obj = str;
		}

		public oprimitive(TypeCode type, primitive prim)
		{
			this.type = type;
			this.prim = prim;
			obj = null;
		}

		public oprimitive(object obj)
		{
			type = Convert.GetTypeCode(obj);
			prim = new primitive(obj);
			this.obj = obj;
		}

		public static implicit operator oprimitive(bool val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(char val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(byte val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(ushort val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(uint val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(ulong val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(sbyte val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(short val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(int val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(long val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(float val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(double val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(DateTime val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(string val)
		{
			return new oprimitive(val?.ToString());
		}

		public static implicit operator bool(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@bool;
		}

		public static implicit operator char(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@char;
		}

		public static implicit operator byte(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@byte;
		}

		public static implicit operator ushort(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@ushort;
		}

		public static implicit operator uint(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@uint;
		}

		public static implicit operator ulong(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@ulong;
		}

		public static implicit operator sbyte(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@sbyte;
		}

		public static implicit operator short(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@short;
		}

		public static implicit operator int(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@int;
		}

		public static implicit operator long(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@long;
		}

		public static implicit operator float(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@float;
		}

		public static implicit operator double(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return primitive2.@double;
		}

		public static implicit operator DateTime(oprimitive sprim)
		{
			primitive primitive2 = sprim.prim;
			return DateTime.FromBinary(primitive2.@long);
		}

		public static implicit operator string(oprimitive sprim)
		{
			return sprim.ToString();
		}

		public override string ToString()
		{
			if (type == TypeCode.String)
			{
				return (string)obj;
			}
			return prim.ToString(type);
		}

		public object Get()
		{
			switch (type)
			{
			case TypeCode.Object:
			case TypeCode.String:
				return obj;
			case TypeCode.Empty:
				return null;
			default:
				return prim.Get(type);
			}
		}

		public static bool operator ==(oprimitive left, oprimitive right)
		{
			if (left.type != right.type)
			{
				return false;
			}
			if (left.prim != right.prim)
			{
				return false;
			}
			if (left.obj != right.obj)
			{
				return false;
			}
			return true;
		}

		public static bool operator !=(oprimitive left, oprimitive right)
		{
			if (left.type != right.type)
			{
				return true;
			}
			if (left.prim != right.prim)
			{
				return true;
			}
			if (left.obj != right.obj)
			{
				return true;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			if (type != TypeCode.Object && type != TypeCode.String)
			{
				primitive primitive2 = prim;
				return primitive2.@long.GetHashCode();
			}
			return (obj != null) ? obj.GetHashCode() : 0;
		}
	}
	public static class Extensions
	{
		public static bool TryWrite(this BinaryWriter writer, TypeCode code, primitive pr)
		{
			switch (code)
			{
			case TypeCode.Boolean:
				writer.Write(pr.@bool);
				return true;
			case TypeCode.Char:
				writer.Write(pr.@char);
				return true;
			case TypeCode.Byte:
				writer.Write(pr.@byte);
				return true;
			case TypeCode.UInt16:
				writer.Write(pr.@ushort);
				return true;
			case TypeCode.UInt32:
				writer.Write(pr.@uint);
				return true;
			case TypeCode.UInt64:
				writer.Write(pr.@ulong);
				return true;
			case TypeCode.SByte:
				writer.Write(pr.@sbyte);
				return true;
			case TypeCode.Int16:
				writer.Write(pr.@short);
				return true;
			case TypeCode.Int32:
				writer.Write(pr.@int);
				return true;
			case TypeCode.Int64:
				writer.Write(pr.@long);
				return true;
			case TypeCode.Single:
				writer.Write(pr.@float);
				return true;
			case TypeCode.Double:
				writer.Write(pr.@double);
				return true;
			case TypeCode.DateTime:
				writer.Write(pr.@long);
				return true;
			default:
				return false;
			}
		}

		public static bool TryRead(this BinaryReader reader, TypeCode code, ref primitive pr)
		{
			switch (code)
			{
			case TypeCode.Boolean:
				pr = reader.ReadBoolean();
				return true;
			case TypeCode.Char:
				pr = reader.ReadChar();
				return true;
			case TypeCode.Byte:
				pr = reader.ReadByte();
				return true;
			case TypeCode.UInt16:
				pr = reader.ReadUInt16();
				return true;
			case TypeCode.UInt32:
				pr = reader.ReadUInt32();
				return true;
			case TypeCode.UInt64:
				pr = reader.ReadUInt64();
				return true;
			case TypeCode.SByte:
				pr = reader.ReadSByte();
				return true;
			case TypeCode.Int16:
				pr = reader.ReadInt16();
				return true;
			case TypeCode.Int32:
				pr = reader.ReadInt32();
				return true;
			case TypeCode.Int64:
				pr = reader.ReadInt64();
				return true;
			case TypeCode.Single:
				pr = reader.ReadSingle();
				return true;
			case TypeCode.Double:
				pr = reader.ReadDouble();
				return true;
			case TypeCode.DateTime:
				pr = reader.ReadInt64();
				return true;
			default:
				return false;
			}
		}

		public static primitive ToPrim(this long val)
		{
			return new primitive(val);
		}

		public static bool Includes(this HagletStepTime left, HagletStepTime right)
		{
			return (left & right) != 0;
		}

		public static HagletStepTime GetFlags(this IList<HagletStepTime> stepTimes)
		{
			HagletStepTime hagletStepTime = HagletStepTime.Unspecified;
			int i = 0;
			for (int count = stepTimes.Count; i < count; i++)
			{
				hagletStepTime |= stepTimes[i];
			}
			return hagletStepTime;
		}
	}
	public static class ReflectionX
	{
		public static class CastTo<T>
		{
			private static class Cache<S>
			{
				public static readonly Func<S, T> caster = Get();

				private static Func<S, T> Get()
				{
					ParameterExpression parameterExpression = Expression.Parameter(typeof(S), "source");
					UnaryExpression body = Expression.ConvertChecked(parameterExpression, typeof(T));
					return Expression.Lambda<Func<S, T>>(body, new ParameterExpression[1] { parameterExpression }).Compile();
				}
			}

			public static T From<S>(S s)
			{
				return Cache<S>.caster(s);
			}
		}

		public static bool IsOfTypeOrSubType(this object obj, Type type)
		{
			Type type2 = obj.GetType();
			return type2 == type || type2.IsSubclassOf(type);
		}

		public static bool IsTypeOrSubType(this Type type1, Type type2)
		{
			return type1 == type2 || type1.IsSubclassOf(type2);
		}

		public static FieldInfo[] GetPublicInstFields(this object obj)
		{
			return obj.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public);
		}

		public static bool IsSubclassOfRawGeneric(this Type type, Type rawGenericType)
		{
			if (type == rawGenericType)
			{
				return false;
			}
			while (type != null && type != typeof(object))
			{
				if (rawGenericType == ((!type.IsGenericType) ? type : type.GetGenericTypeDefinition()))
				{
					return true;
				}
				type = type.BaseType;
			}
			return false;
		}

		public static bool HasAttr<T>(this MemberInfo element, bool inherit = false) where T : Attribute
		{
			return Attribute.IsDefined(element, typeof(T), inherit);
		}

		public static T GetAttr<T>(this MemberInfo element, bool inherit = false) where T : Attribute
		{
			return (T)Attribute.GetCustomAttribute(element, typeof(T), inherit);
		}

		public static bool IsBacking(this FieldInfo field)
		{
			return field.HasAttr<CompilerGeneratedAttribute>() && field.Name.StartsWith("<") && field.Name.EndsWith(">k__BackingField");
		}

		public static PropertyInfo GetBackedProperty(this FieldInfo field)
		{
			string name = field.Name.Substring(1, field.Name.IndexOf('>') - 1);
			return field.DeclaringType.GetProperty(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		public static int PrimitiveSize(this Type type)
		{
			if (type == typeof(bool))
			{
				return 1;
			}
			if (type == typeof(char))
			{
				return 2;
			}
			if (type == typeof(sbyte))
			{
				return 1;
			}
			if (type == typeof(short))
			{
				return 2;
			}
			if (type == typeof(int))
			{
				return 4;
			}
			if (type == typeof(long))
			{
				return 8;
			}
			if (type == typeof(byte))
			{
				return 1;
			}
			if (type == typeof(ushort))
			{
				return 2;
			}
			if (type == typeof(uint))
			{
				return 4;
			}
			if (type == typeof(ulong))
			{
				return 8;
			}
			if (type == typeof(float))
			{
				return 4;
			}
			if (type == typeof(double))
			{
				return 8;
			}
			throw new InvalidOperationException();
		}
	}
	public static class SceneX
	{
		public static bool IsAncestorOf(this UnityEngine.Component a, UnityEngine.Component c)
		{
			Transform parent = c.transform.parent;
			while (!object.ReferenceEquals(parent, null))
			{
				if (object.ReferenceEquals(parent, a))
				{
					return true;
				}
				parent = parent.parent;
			}
			return false;
		}

		public static UnityEngine.Component GetClosestInAncestry<TA, TB>(this UnityEngine.Component c, out TA aa, out TB ab, bool includeSelf) where TA : UnityEngine.Component where TB : UnityEngine.Component
		{
			aa = (TA)null;
			ab = (TB)null;
			Transform transform = ((!includeSelf) ? c.transform.parent : c.transform);
			while (transform != null)
			{
				if (!object.ReferenceEquals(aa = transform.GetComponent<TA>(), null))
				{
					return aa;
				}
				if (!object.ReferenceEquals(ab = transform.GetComponent<TB>(), null))
				{
					return ab;
				}
				transform = transform.parent;
			}
			return null;
		}

		public static void SetLocalPosY(this Transform xform, float y)
		{
			xform.localPosition = xform.localPosition.RepY(y);
		}
	}
	public static class ShellCommand
	{
		public static bool Exists(string command, bool defaultTo = false)
		{
			try
			{
				UnityEngine.Debug.LogWarning("Cannot currently check command existance on this platform.");
				return defaultTo;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running \"where\" command for \"{command}\": {ex.Message}");
				return defaultTo;
			}
		}

		public static string ExecuteSync(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				process.Start();
				process.WaitForExit();
				return process.StandardOutput.ReadToEnd();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
			}
			return string.Empty;
		}

		public static bool ExecuteASync(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				return process.Start();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
			}
			return false;
		}

		public static string ExecuteSyncNoException(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				process.Start();
				process.WaitForExit();
				return process.StandardOutput.ReadToEnd();
			}
			catch
			{
			}
			return string.Empty;
		}

		public static bool ExecuteASyncNoException(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				return process.Start();
			}
			catch
			{
			}
			return false;
		}
	}
	public static class StringX
	{
		public static string StringSplitIntoLines(string text, int maxCharsInLine)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < text.Length; i++)
			{
				char c = text[i];
				if (char.IsWhiteSpace(c))
				{
					num = i + 1;
				}
				if (i - num2 > maxCharsInLine)
				{
					stringBuilder.Append(text, num2, num - num2);
					stringBuilder.Append("\n");
					num2 = num;
				}
			}
			if (num2 != text.Length)
			{
				stringBuilder.Append(text, num2, text.Length - num2);
			}
			return stringBuilder.ToString();
		}

		public static string RemoveUpToChar(this string str, char chr, bool includeChar = false)
		{
			for (int i = 0; i < str.Length; i++)
			{
				if (str[i] == chr)
				{
					if (includeChar)
					{
						return str.Remove(0, i + 1);
					}
					return str.Remove(0, i);
				}
			}
			return str;
		}

		public static bool IsNullOrWhiteSpace(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return true;
			}
			for (int i = 0; i < str.Length; i++)
			{
				if (!char.IsWhiteSpace(str[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static void AddFormat(this IList<string> stringList, string format, params object[] args)
		{
			stringList.Add(string.Format(format, args));
		}

		public static string PrettyName(this Type type)
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendPrettyName(type);
			return stringBuilder.ToString();
		}

		public static void AppendPrettyName(this StringBuilder builder, Type type)
		{
			builder.Append(type.Name);
			if (type.IsGenericType)
			{
				builder.Remove(builder.Length - 2, 2);
				builder.Append('<');
				Type[] genericArguments = type.GetGenericArguments();
				builder.AppendPrettyName(genericArguments[0]);
				int i = 1;
				for (int num = genericArguments.Length; i < num; i++)
				{
					builder.Append(", ");
					builder.AppendPrettyName(genericArguments[i]);
				}
				builder.Append('>');
			}
			else if (type.IsArray && type.GetArrayRank() > 1)
			{
				builder.Remove(builder.Length - 1, 1);
				for (int j = 1; j < type.GetArrayRank(); j++)
				{
					builder.Append(',');
				}
				builder.Append(']');
			}
		}

		public static int WriteCropped(this TextWriter writer, int size, string str)
		{
			int i = 0;
			for (int num = ((str.Length >= size) ? size : str.Length); i < num; i++)
			{
				writer.Write(str[i]);
			}
			return i;
		}

		public static void WriteFixed(this TextWriter writer, int size, string str)
		{
			for (int i = writer.WriteCropped(size, str); i < size; i++)
			{
				writer.Write(' ');
			}
		}

		public static void WriteFixed(this TextWriter writer, int size, string format, object arg0, object arg1 = null, object arg2 = null, object arg3 = null)
		{
			writer.WriteFixed(size, string.Format(format, arg0, arg1, arg2, arg3));
		}

		public static int GetHashCode(this string thisStr, int start, int length)
		{
			int num = start + length;
			int num2 = 0;
			for (int i = start; i < num; i++)
			{
				num2 = (num2 << 5) - (num2 + thisStr[i]);
			}
			return num2;
		}
	}
}
public class NonSceneAssetAttribute : PropertyAttribute
{
}
public class ReadOnlyAttribute : PropertyAttribute
{
}
namespace Coatsink.Common
{
	public static class DebugX
	{
		public delegate void DrawLine(Vector3 posA, Vector3 posB, Color color);

		public static void ClearConsole()
		{
			UnityEngine.Debug.ClearDeveloperConsole();
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawX(Vector3 centre, float size, Color color, float duration = 0f, bool depthTest = true)
		{
			size *= 0.5f;
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, 0f - size, 0f - size), centre + new Vector3(size, size, size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, 0f - size, size), centre + new Vector3(size, size, 0f - size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, size, 0f - size), centre + new Vector3(size, 0f - size, size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, size, size), centre + new Vector3(size, 0f - size, 0f - size), color, duration, depthTest);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawBounds(Bounds bounds, Color color, float duration = 0f, bool depthTest = true)
		{
			Vector3 min = bounds.min;
			Vector3 max = bounds.max;
			UnityEngine.Debug.DrawLine(new Vector3(min.x, min.y, min.z), new Vector3(min.x, max.y, min.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(min.x, max.y, min.z), new Vector3(max.x, max.y, min.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, max.y, min.z), new Vector3(max.x, min.y, min.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, min.y, min.z), new Vector3(min.x, min.y, min.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(min.x, min.y, max.z), new Vector3(min.x, max.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(min.x, max.y, max.z), new Vector3(max.x, max.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, max.y, max.z), new Vector3(max.x, min.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, min.y, max.z), new Vector3(min.x, min.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(min.x, min.y, min.z), new Vector3(min.x, min.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(min.x, max.y, min.z), new Vector3(min.x, max.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, max.y, min.z), new Vector3(max.x, max.y, max.z), color);
			UnityEngine.Debug.DrawLine(new Vector3(max.x, min.y, min.z), new Vector3(max.x, min.y, max.z), color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color, DrawLine drawLineDelegate)
		{
			for (int i = 0; i < 32; i++)
			{
				float num = (float)i / 32f;
				float num2 = (float)(i + 1) / 32f;
				Vector3 vector = (rotationUp * Mathf.Cos((float)Math.PI * 2f * num) + rotationRight * Mathf.Sin((float)Math.PI * 2f * num)) * radius;
				Vector3 vector2 = (rotationUp * Mathf.Cos((float)Math.PI * 2f * num2) + rotationRight * Mathf.Sin((float)Math.PI * 2f * num2)) * radius;
				drawLineDelegate(pos + vector, pos + vector2, color);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 normal, float radius, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 normal, float radius, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(normal, out var _, out var _);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRectangle(Vector3 pos, Vector3 up, Vector3 right, Color color, DrawLine drawLineDelegate)
		{
			Vector3 vector = pos + up + right;
			Vector3 vector2 = pos - up + right;
			Vector3 vector3 = pos - up - right;
			Vector3 vector4 = pos + up - right;
			drawLineDelegate(vector, vector2, color);
			drawLineDelegate(vector2, vector3, color);
			drawLineDelegate(vector3, vector4, color);
			drawLineDelegate(vector4, vector, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawOrthoNormal(Vector3 pos, Vector3 right, Vector3 up, Vector3 forward)
		{
			UnityEngine.Debug.DrawRay(pos, right, Color.red);
			UnityEngine.Debug.DrawRay(pos, up, Color.green);
			UnityEngine.Debug.DrawRay(pos, forward, Color.blue);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRectangle(Vector3 pos, Vector3 up, Vector3 right, Color color)
		{
		}
	}
}
public class ControllerDisconnectHandler : MonoBehaviour
{
	private bool lastControllerConnected = true;

	private static float kQueryRate = 1f;

	private float timeTillNextCheck;

	public Action OnEventControllerConnect;

	public Action OnEventControllerDisconnect;

	public GameObject warningMessage;

	private MeshRenderer[] warningRenderers;

	public bool ControllerConnected
	{
		get
		{
			string[] joystickNames = Input.GetJoystickNames();
			int num = joystickNames.Length;
			string[] array = joystickNames;
			foreach (string value in array)
			{
				if (string.IsNullOrEmpty(value))
				{
					num = Mathf.Max(--num, 0);
				}
			}
			return num > 0;
		}
	}

	private void Awake()
	{
		warningRenderers = warningMessage.GetComponentsInChildren<MeshRenderer>(includeInactive: true);
	}

	private void Update()
	{
		timeTillNextCheck -= Time.deltaTime;
		if (!(timeTillNextCheck < 0f))
		{
			return;
		}
		timeTillNextCheck = kQueryRate;
		bool controllerConnected = ControllerConnected;
		if (lastControllerConnected != controllerConnected)
		{
			if (controllerConnected)
			{
				if (OnEventControllerConnect != null)
				{
					OnEventControllerConnect();
				}
				if (warningMessage != null)
				{
					SetWarningMessageEnabled(enabled: false);
				}
			}
			else if (!controllerConnected)
			{
				if (OnEventControllerDisconnect != null)
				{
					OnEventControllerDisconnect();
				}
				if (warningMessage != null)
				{
					SetWarningMessageEnabled(enabled: true);
				}
			}
		}
		lastControllerConnected = controllerConnected;
	}

	public void SetWarningMessageEnabled(bool enabled)
	{
		MeshRenderer[] array = warningRenderers;
		foreach (MeshRenderer meshRenderer in array)
		{
			meshRenderer.enabled = enabled;
		}
	}
}
namespace UnityStandardAssets.ImageEffects
{
	[ExecuteInEditMode]
	public class BilateralBlur : MonoBehaviour
	{
		public Shader blurShader;

		public int iterations = 3;

		public float blurSpread = 1f;

		public float depthFalloff = 3f;

		private static Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(blurShader);
					m_Material.hideFlags = HideFlags.DontSave;
				}
				return m_Material;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!blurShader || !material.shader.isSupported)
			{
				base.enabled = false;
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration, Vector2 direction)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			material.SetFloat("_BlurSpread", blurSpread);
			material.SetFloat("_DepthFalloff", depthFalloff);
			material.SetVector("_BlurDirection", new Vector4(direction.x, direction.y, 0f, 0f));
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int width = source.width / 2;
			int height = source.height / 2;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 24, RenderTextureFormat.ARGB32);
			DownSample(source, renderTexture);
			for (int i = 0; i < iterations; i++)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 24, RenderTextureFormat.ARGB32);
				FourTapCone(renderTexture, temporary, i, new Vector2(1f, 0f));
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 24, RenderTextureFormat.ARGB32);
				FourTapCone(temporary, temporary2, i, new Vector2(0f, 1f));
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture.ReleaseTemporary(temporary);
				renderTexture = temporary2;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
}
public class InitialiseOnLoad : MonoBehaviour
{
}
public class OculusPlatformController : MonoBehaviour
{
}
public class PeripheralMonitoring : MonoBehaviour
{
	public float interval = 0.2f;

	public bool enableInEditor;

	public bool useFakeHMDPresent;

	public bool useFakeHMDPresentAtStartup;

	public bool useFakeTrackerPresent;

	public bool useFakeContPresent;

	public bool useFakeInFocus;

	public bool useFakeUserPresent;

	public bool fakeHMDPresent = true;

	public bool fakeHMDPresentAtStartup = true;

	public bool fakeTrackerPresent = true;

	public bool fakeContPresent = true;

	public bool fakeInFocus = true;

	public bool fakeUserPresent = true;

	private bool hmdReallyPresent = true;

	private bool hmdReallyPresentAtStartup = true;

	private bool trackerReallyPresent = true;

	private bool controllerReallyPresent = true;

	private bool reallyInFocus = true;

	private bool hmdReallyUserPresent = true;

	private Coroutine monitoring;

	private static bool checkedHMDPresentAtStartup;

	public bool hmdPresent
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveHMDPresent;
		}
	}

	public bool hmdPresentAtStartup
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveHMDPresentAtStartup;
		}
	}

	public bool trackerPresent
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveTrackerPresent;
		}
	}

	public bool hmdUserPresent
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveHDMUserPresent;
		}
	}

	public bool controllerPresent
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveControllerPresent;
		}
	}

	public bool inFocus
	{
		get
		{
			if (!base.enabled)
			{
				throw new InvalidOperationException();
			}
			return effectiveInFocus;
		}
	}

	public bool allPresent => effectiveHMDPresent && effectiveTrackerPresent && effectiveControllerPresent && effectiveInFocus && effectiveHDMUserPresent;

	private bool effectiveHMDPresent => EffectivePresence(useFakeHMDPresent, fakeHMDPresent, hmdReallyPresent);

	private bool effectiveHMDPresentAtStartup => EffectivePresence(useFakeHMDPresentAtStartup, fakeHMDPresentAtStartup, hmdReallyPresentAtStartup);

	private bool effectiveTrackerPresent => EffectivePresence(useFakeTrackerPresent, fakeTrackerPresent, trackerReallyPresent);

	private bool effectiveControllerPresent => EffectivePresence(useFakeContPresent, fakeContPresent, controllerReallyPresent);

	private bool effectiveInFocus => EffectivePresence(useFakeInFocus, fakeInFocus, reallyInFocus);

	private bool effectiveHDMUserPresent => EffectivePresence(useFakeUserPresent, fakeUserPresent, hmdReallyUserPresent);

	public event Action gotHMD;

	public event Action gotTracker;

	public event Action gotController;

	public event Action gotFocus;

	public event Action gotHMDUserPresent;

	public event Action gotAny;

	public event Action lostHMD;

	public event Action lostTracker;

	public event Action lostController;

	public event Action lostFocus;

	public event Action lostHMDUserPresent;

	public event Action lostAny;

	private bool EffectivePresence(bool useFake, bool fake, bool real)
	{
		return useFake ? fake : ((!enableInEditor && UnityEngine.Application.isEditor) || real);
	}

	private void Awake()
	{
		if (!checkedHMDPresentAtStartup)
		{
			hmdReallyPresentAtStartup = VRDevice.isPresent;
			checkedHMDPresentAtStartup = true;
		}
	}

	private void Start()
	{
		StartCoroutine(InitialiseController());
	}

	private void OnEnable()
	{
		monitoring = StartCoroutine(Monitor());
	}

	private void OnDisable()
	{
		StopCoroutine(monitoring);
		monitoring = null;
	}

	private void OnApplicationFocus(bool gotFocus)
	{
		reallyInFocus = gotFocus;
	}

	private IEnumerator Monitor()
	{
		bool hmdWasPresent = true;
		bool trackerWasPresent = true;
		bool contWasPresent = true;
		bool wasInFocus = true;
		bool wasUserPresent = true;
		while (true)
		{
			hmdReallyPresent = VRDevice.isPresent;
			_ = VRSettings.loadedDevice;
			controllerReallyPresent = Input.GetJoystickNames().Any((string joystickName) => !string.IsNullOrEmpty(joystickName));
			trackerReallyPresent = true;
			CheckPresence(effectiveHMDPresent, ref hmdWasPresent, this.gotHMD, this.lostHMD);
			CheckPresence(effectiveTrackerPresent, ref trackerWasPresent, this.gotTracker, this.lostTracker);
			CheckPresence(effectiveControllerPresent, ref contWasPresent, this.gotController, this.lostController);
			CheckPresence(effectiveInFocus, ref wasInFocus, this.gotFocus, this.lostFocus);
			CheckPresence(effectiveHDMUserPresent, ref wasUserPresent, this.gotHMDUserPresent, this.lostHMDUserPresent);
			yield return new WaitForSeconds(interval);
		}
	}

	private IEnumerator InitialiseController()
	{
		yield return new WaitForSeconds(1.5f);
	}

	private void CheckPresence(bool presentNow, ref bool wasPresent, Action onGotten, Action onLost)
	{
		if (presentNow == wasPresent)
		{
			return;
		}
		if (presentNow)
		{
			onGotten?.Invoke();
			if (this.gotAny != null)
			{
				this.gotAny();
			}
		}
		else
		{
			onLost?.Invoke();
			if (this.lostAny != null)
			{
				this.lostAny();
			}
		}
		wasPresent = presentNow;
	}
}
[ExecuteInEditMode]
public class ShadowRT : MonoBehaviour
{
	public static Camera shadowCam;

	public Texture noiseTX;

	private float lastScreenWidth;

	private float lastScreenHeight;

	private RenderTexture renderTexture;

	private Camera thisCamera;

	private Shader shadowShader;

	private void Awake()
	{
		thisCamera = GetComponent<Camera>();
		thisCamera.depthTextureMode = DepthTextureMode.Depth;
		shadowShader = Shader.Find("Custom/ShadowPass");
		thisCamera.SetReplacementShader(shadowShader, "RenderType");
		lastScreenWidth = Screen.width;
		lastScreenHeight = Screen.height;
		if (shadowCam == null)
		{
			shadowCam = GameObject.Find("P_ShadowCamera").GetComponent<Camera>();
		}
		if (shadowCam != null)
		{
			shadowCam.transform.localPosition = Vector3.zero;
			shadowCam.transform.localRotation = Quaternion.identity;
		}
		Invoke("SetupCamera", 1.1f);
	}

	private void SetupCamera()
	{
		if (thisCamera.targetTexture != null)
		{
			thisCamera.targetTexture.Release();
		}
		int width = Screen.width;
		int height = Screen.height;
		thisCamera.transform.localEulerAngles = Vector3.zero;
		renderTexture = new RenderTexture(width, height, 24);
		thisCamera.targetTexture = renderTexture;
		Shader.SetGlobalTexture("_NoiseTex", noiseTX);
		Shader.SetGlobalTexture("_ShadowBuffer", renderTexture);
	}

	private void Update()
	{
		if (lastScreenWidth != (float)Screen.width || lastScreenHeight != (float)Screen.height)
		{
			lastScreenWidth = Screen.width;
			lastScreenHeight = Screen.height;
			SetupCamera();
		}
	}
}
public interface IPoolEvents
{
	void OnSpawn();

	void OnDespawn();

	void OnAllocate();

	void OnDeallocate();
}
public abstract class GameObjectPool<T, W> : MonoBehaviour where T : UnityEngine.Component where W : GameObjectPool<T, W>.GOFromPool
{
	public class GOFromPool : MonoBehaviour
	{
		[NonSerialized]
		public PoolReferences pr;

		public virtual void OnReady()
		{
		}

		public virtual void OnStop()
		{
		}

		protected virtual void OnDisable()
		{
			IPoolEvents[] eventComps = pr.eventComps;
			foreach (IPoolEvents poolEvents in eventComps)
			{
				poolEvents.OnDespawn();
			}
			OnStop();
			if (base.gameObject.activeSelf || pr == null)
			{
				return;
			}
			if (pr.pool == null)
			{
				IPoolEvents[] eventComps2 = pr.eventComps;
				foreach (IPoolEvents poolEvents2 in eventComps2)
				{
					poolEvents2.OnDeallocate();
				}
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				pr.pool.Return(pr);
			}
		}
	}

	public class PoolReferences
	{
		public GameObjectPool<T, W> pool;

		public readonly T component;

		public readonly W watcher;

		public readonly GameObject go;

		public readonly IPoolEvents[] eventComps;

		public PoolReferences(GameObjectPool<T, W> pool_, T component_, W watcher_, GameObject go_)
		{
			pool = pool_;
			component = component_;
			watcher = watcher_;
			go = go_;
			eventComps = go_.GetComponentsInChildren<IPoolEvents>();
		}
	}

	public T sourcePrefab;

	public int initialSize;

	public int maxSize;

	public PoolUpdateRunner updateRunner;

	protected List<PoolReferences> divers = new List<PoolReferences>();

	protected List<PoolReferences> available = new List<PoolReferences>();

	protected List<PoolReferences> activeInstances = new List<PoolReferences>();

	private Action update;

	public IEnumerable<PoolReferences> _activeObjects => activeInstances;

	public int TotalInstCount => divers.Count + available.Count + activeInstances.Count;

	public int ActiveInstCount => activeInstances.Count;

	public int AvailableInstCount => available.Count;

	public virtual void Init(bool fillImmediately = true)
	{
		update = UpdatePool;
		if (maxSize > 0 && maxSize < initialSize)
		{
			maxSize = initialSize;
		}
		if (fillImmediately)
		{
			for (int i = 0; i < initialSize; i++)
			{
				AddInstance();
			}
		}
		else
		{
			updateRunner.RunUpdate(update);
		}
	}

	private void AddInstance()
	{
		T val = UnityEngine.Object.Instantiate(sourcePrefab);
		val.transform.parent = base.transform;
		val.gameObject.SetActive(value: false);
		W val2 = val.gameObject.AddComponent<W>();
		val2.pr = new PoolReferences(this, val, val2, val.gameObject);
		val2.hideFlags = HideFlags.HideInInspector;
		available.Add(val2.pr);
		OnAllocate(val, val2);
		IPoolEvents[] eventComps = val2.pr.eventComps;
		foreach (IPoolEvents poolEvents in eventComps)
		{
			poolEvents.OnAllocate();
		}
	}

	private void UpdatePool()
	{
		if (TotalInstCount < initialSize)
		{
			AddInstance();
			if (TotalInstCount < initialSize)
			{
				updateRunner.RunUpdate(update);
			}
		}
		for (int num = divers.Count - 1; num >= 0; num--)
		{
			PoolReferences poolReferences = divers[num];
			if (poolReferences.go == null)
			{
				UnityEngine.Debug.LogError("Pooled GameObject has been destroyed from " + base.name, this);
			}
			else
			{
				poolReferences.go.transform.parent = base.transform;
				available.Add(poolReferences);
			}
		}
		divers.Clear();
	}

	protected virtual PoolReferences GetRef(Transform parent, Vector3 worldPosition, bool active)
	{
		PoolReferences poolReferences = null;
		if (available.Count > 0)
		{
			poolReferences = available[available.Count - 1];
			available.RemoveAt(available.Count - 1);
		}
		else
		{
			T val = UnityEngine.Object.Instantiate(sourcePrefab);
			val.gameObject.SetActive(active);
			W val2 = val.gameObject.AddComponent<W>();
			poolReferences = (val2.pr = new PoolReferences(this, val, val2, val.gameObject));
			val2.hideFlags = HideFlags.HideInInspector;
			OnAllocate(val, val2);
			IPoolEvents[] eventComps = val2.pr.eventComps;
			foreach (IPoolEvents poolEvents in eventComps)
			{
				poolEvents.OnAllocate();
			}
		}
		poolReferences.go.transform.parent = parent;
		poolReferences.go.transform.position = worldPosition;
		if (active)
		{
			poolReferences.go.SetActive(value: true);
		}
		W watcher = poolReferences.watcher;
		watcher.OnReady();
		IPoolEvents[] eventComps2 = poolReferences.eventComps;
		foreach (IPoolEvents poolEvents2 in eventComps2)
		{
			poolEvents2.OnSpawn();
		}
		activeInstances.Add(poolReferences);
		return poolReferences;
	}

	public virtual T Get(Vector3 worldPostion = default(Vector3), Transform parent = null, bool active = true)
	{
		return GetRef(parent, worldPostion, active).component;
	}

	public virtual T Get(out W watcher, Vector3 worldPostion, Transform parent = null, bool active = true)
	{
		PoolReferences @ref = GetRef(parent, worldPostion, active);
		watcher = @ref.watcher;
		return @ref.component;
	}

	protected virtual void Return(PoolReferences pr)
	{
		activeInstances.Remove(pr);
		if (maxSize > available.Count + divers.Count)
		{
			pr.go.SetActive(value: false);
			divers.Add(pr);
			updateRunner.RunUpdate(update);
			return;
		}
		IPoolEvents[] eventComps = pr.eventComps;
		foreach (IPoolEvents poolEvents in eventComps)
		{
			poolEvents.OnDeallocate();
		}
		UnityEngine.Object.Destroy(pr.watcher);
		UnityEngine.Object.Destroy(pr.go);
	}

	protected virtual void OnAllocate(T newObject, W newWatcher)
	{
	}

	public override string ToString()
	{
		return sourcePrefab.name + " Pool";
	}
}
public class TransformFromPool : GameObjectPool<Transform, TransformFromPool>.GOFromPool
{
}
public class TransformPool : GameObjectPool<Transform, TransformFromPool>
{
}
public class PoolUpdateRunner : MonoBehaviour
{
	private readonly Action[] updatesToRun = new Action[2];

	private int cutr;

	public void RunUpdate(Action update)
	{
		int num;
		Action[] array;
		(array = updatesToRun)[num = cutr] = (Action)Delegate.Remove(array[num], update);
		int num2;
		(array = updatesToRun)[num2 = cutr] = (Action)Delegate.Combine(array[num2], update);
	}

	private void Update()
	{
		int num = cutr;
		if (updatesToRun[num] != null)
		{
			cutr = (cutr + 1) % updatesToRun.Length;
			updatesToRun[num]();
			updatesToRun[num] = null;
		}
	}
}
namespace Coatsink.Common
{
	public class HagletFlag : HagletCondition
	{
		public bool set;

		public HagletFlag()
		{
		}

		public HagletFlag(bool setIn)
		{
			set = setIn;
		}

		protected override bool GetValue()
		{
			return set;
		}

		public void Set()
		{
			set = true;
		}

		public void Clear()
		{
			set = false;
		}
	}
	public class TransformAtOrientation : HagletCondition
	{
		public Transform tform;

		public Vector3 worldFwd;

		public Vector3 worldUp;

		public Vector3 localFwd;

		public Vector3 localUp;

		public Transform dirTform;

		public float tol;

		protected override bool GetValue()
		{
			if (dirTform != null)
			{
				worldFwd = dirTform.forward;
				worldUp = dirTform.up;
			}
			float num = Vector3.Angle(tform.TransformDirection(localFwd), worldFwd);
			float num2 = Vector3.Angle(tform.TransformDirection(localUp), worldUp);
			return num <= tol && num2 <= tol;
		}
	}
	public class TransformAtPosition : HagletCondition
	{
		public Transform tform;

		public Vector3 targWorldPos;

		public Vector3 localOrigin;

		public Transform targTform;

		public float tol;

		protected override bool GetValue()
		{
			if (targTform != null)
			{
				targWorldPos = targTform.position;
			}
			float num = Vector3.Distance(tform.TransformPoint(localOrigin), targWorldPos);
			return num <= tol;
		}
	}
	public class HagletTrigger : HagletEvent
	{
		public HagletTrigger()
		{
		}

		public HagletTrigger(int listCap)
			: base(listCap)
		{
		}

		public bool Trigger()
		{
			return Happen();
		}
	}
	public class Haglet
	{
		protected readonly IEnumerator<HagletYieldTerm> routine;

		public readonly string name;

		public Haglet parent;

		public Haglet prevSib;

		public Haglet nextSib;

		public Haglet firstChild;

		public Haglet skipAdopter;

		public readonly HagletFlag running = new HagletFlag();

		public Haglet markedToRunBy;

		public readonly HagletTrigger started = new HagletTrigger();

		public readonly HagletTrigger stopped = new HagletTrigger();

		public readonly HagletTrigger completed = new HagletTrigger();

		public readonly HagletYieldClause[] yieldClauses;

		public int skipDepth = -1;

		public bool completedWithChildren;

		public int maxYieldClauseDepth;

		public readonly HagletStepTime defaultStepTimes;

		public bool stepped;

		public HagletHost host;

		public bool wasSkipping;

		public bool stepping;

		public bool complete;

		public bool showInStackTrace = true;

		public Exception lastException;

		public Action<Haglet> localExceptionResponse;

		public Action<Haglet> descendantExceptionResponse;

		public static readonly Action<Haglet> pause = delegate(Haglet hag)
		{
			if ((bool)hag.running)
			{
				hag.host.Pause(hag);
			}
		};

		public static readonly Action<Haglet> reset = delegate(Haglet hag)
		{
			if (hag.resettable)
			{
				hag.Reset();
			}
		};

		public static readonly Action<Haglet> pauseAndReset = (Action<Haglet>)Delegate.Combine(pause, reset);

		private string profileSampleName;

		public readonly string profileSampleSkipName;

		public bool skipping => skipDepth != -1;

		public virtual bool resettable => false;

		public Haglet(IEnumerator<HagletYieldTerm> routine, string name = null, HagletStepTime defaultStepTimes = HagletStepTime.Update, int yieldTermCap = 10, HagletHost prestepHost = null, bool showInStackTrace = true, Action<Haglet> localExceptionResponse = null, Action<Haglet> descendantExceptionResponse = null)
		{
			this.showInStackTrace = showInStackTrace;
			if (!string.IsNullOrEmpty(name))
			{
				this.name = name;
			}
			else
			{
				Type type = routine.GetType();
				string text = type.Name;
				this.name = text.Substring(1, text.IndexOf('>') - 1);
			}
			this.routine = routine;
			this.defaultStepTimes = defaultStepTimes;
			this.localExceptionResponse = localExceptionResponse ?? pause;
			this.descendantExceptionResponse = descendantExceptionResponse ?? pause;
			yieldClauses = new HagletYieldClause[yieldTermCap];
			if (prestepHost != null)
			{
				if (HagletHost.currHag != null && prestepHost == HagletHost.current)
				{
					prestepHost.StartAsChild(this, HagletHost.currHag, asFirst: true);
				}
				else
				{
					prestepHost.StartTopLevel(this);
				}
				int continues = 0;
				prestepHost.Step(this, ref continues);
				if ((bool)running)
				{
					prestepHost.Pause(this, afterPrestep: true);
				}
			}
			profileSampleName = "HAGLET: " + this.name + " (STEP)";
			profileSampleSkipName = "HAGLET: " + this.name + " (SKIP)";
		}

		protected Haglet(BinaryReader reader)
		{
			if (!reader.ReadBoolean())
			{
				yieldClauses = new HagletYieldClause[reader.ReadByte()];
			}
		}

		public virtual void Deconstruct(BinaryWriter writer)
		{
			writer.Write(running.set);
			if (!running.set)
			{
				writer.Write((byte)yieldClauses.Length);
			}
		}

		public void InitializeYieldClauses()
		{
			ClearYieldClauses();
			yieldClauses[0].type = HagletYieldClause.Type.ForSteps;
			yieldClauses[0].stepTimes = defaultStepTimes;
			switch (defaultStepTimes)
			{
			case HagletStepTime.Update:
			case HagletStepTime.LateUpdate:
			case HagletStepTime.EditorUpdate:
				yieldClauses[0].targetSteps = host.updateStepCount;
				break;
			case HagletStepTime.FixedUpdate:
			case HagletStepTime.EditorFixedUpdate:
				yieldClauses[0].targetSteps = host.updateStepCountFixed;
				break;
			}
		}

		public void DefaultYieldClauses()
		{
			Array.Clear(yieldClauses, 0, yieldClauses.Length);
		}

		public void Start(HagletHost newHost)
		{
			running.Set();
			markedToRunBy = null;
			started.Trigger();
			host = newHost;
			int i = 0;
			for (int num = yieldClauses.Length; i < num && yieldClauses[i].type == HagletYieldClause.Type.Clear; i++)
			{
			}
		}

		public bool Step()
		{
			stepped = (stepping = true);
			wasSkipping = skipDepth != -1;
			try
			{
				complete = !routine.MoveNext();
				ClearLastException();
			}
			catch (Exception exc)
			{
				HandleException(exc);
			}
			finally
			{
				stepping = false;
			}
			if (complete)
			{
				Complete();
			}
			return complete;
		}

		public void Pause()
		{
			skipDepth = -1;
			ClearYieldClauses();
			nextSib = (prevSib = (parent = (skipAdopter = null)));
			maxYieldClauseDepth = 0;
			running.Clear();
			stopped.Trigger();
			stepped = false;
			host = null;
		}

		public void HandleException(Exception exc)
		{
			lastException = exc;
			for (Haglet haglet = parent; haglet != null; haglet = haglet.parent)
			{
				if (haglet.descendantExceptionResponse != null)
				{
					haglet.descendantExceptionResponse(this);
				}
			}
			if (localExceptionResponse != null)
			{
				localExceptionResponse(this);
			}
		}

		protected void ClearYieldClauses()
		{
			int i = 0;
			for (int num = yieldClauses.Length; i < num; i++)
			{
				yieldClauses[i].remaining = 0u;
				yieldClauses[i].Clear(met: false, propagate: false);
			}
		}

		protected virtual void Complete()
		{
			completed.Trigger();
		}

		public virtual void PostComplete()
		{
		}

		public virtual void MarkResetPoint()
		{
		}

		public virtual void Reset(bool resetDescendants = true)
		{
		}

		public void ClearLastException()
		{
			lastException = null;
		}

		public int GetFreeYieldClauseIdx()
		{
			int i = 0;
			for (int num = yieldClauses.Length; i < num; i++)
			{
				if (yieldClauses[i].type == HagletYieldClause.Type.Clear)
				{
					yieldClauses[i].remaining = 0u;
					yieldClauses[i].stepTimes = defaultStepTimes;
					return i;
				}
			}
			return -1;
		}

		public bool IsAncestorOf(Haglet descendant)
		{
			for (Haglet haglet = descendant.parent; haglet != null; haglet = haglet.parent)
			{
				if (haglet == this)
				{
					return true;
				}
			}
			return false;
		}

		public override string ToString()
		{
			return name;
		}

		[Conditional("CS_DEBUG")]
		public void AppendStackTrace(StringBuilder builder, int indent = 0)
		{
			builder.AppendFormat("\n{0}{1}", new string(' ', indent * 4), this);
			if (firstChild == null)
			{
				HagletYieldClause[] array = yieldClauses;
				for (int i = 0; i < array.Length; i++)
				{
					HagletYieldClause hagletYieldClause = array[i];
					if (hagletYieldClause.type != 0)
					{
						builder.AppendFormat("\n{0}{1}", new string(' ', (indent + 1) * 4), hagletYieldClause.type);
					}
				}
			}
			else
			{
				for (Haglet haglet = firstChild; haglet != null; haglet = haglet.nextSib)
				{
				}
			}
		}
	}
	[Serializer.ExcludeAllFields]
	public abstract class HagletBehaviour : MonoBehaviour
	{
		protected Haglet startHag;

		protected Haglet enabledHag;

		protected virtual HagletHost host => HagletHost.@default;

		protected virtual string startHagletName => string.Format("{0}/{1}/{2}", base.gameObject.GetScenePath(), GetType().Name, "Start Routine");

		protected virtual string enabledHagletName => string.Format("{0}/{1}/{2}", base.gameObject.GetScenePath(), GetType().Name, "Enabled Routine");

		protected virtual HagletStepTime startDefaultStepTimes => HagletStepTime.Update;

		protected virtual HagletStepTime enabledDefaultStepTimes => HagletStepTime.Update;

		protected virtual int startYieldTermCap => 10;

		protected virtual int enabledYieldTermCap => 10;

		protected virtual bool resetEnabled => false;

		protected virtual bool resetEnabledDescendants => true;

		protected virtual void Start()
		{
			IEnumerator<HagletYieldTerm> enumerator = StartRoutine();
			if (enumerator != null)
			{
				host.StartTopLevel(startHag = new Haglet(enumerator, startHagletName, startDefaultStepTimes, startYieldTermCap));
			}
		}

		protected virtual void OnEnable()
		{
			if (enabledHag != null)
			{
				host.StartTopLevel(enabledHag);
				return;
			}
			IEnumerator<HagletYieldTerm> enumerator = EnabledRoutine();
			if (enumerator != null)
			{
				if (resetEnabled)
				{
					enabledHag = new HagletResettable(enumerator, enabledHagletName, enabledDefaultStepTimes, enabledYieldTermCap);
				}
				else
				{
					enabledHag = new Haglet(enumerator, enabledHagletName, enabledDefaultStepTimes, enabledYieldTermCap);
				}
				host.StartTopLevel(enabledHag);
			}
		}

		protected virtual IEnumerator<HagletYieldTerm> StartRoutine()
		{
			return null;
		}

		protected virtual IEnumerator<HagletYieldTerm> EnabledRoutine()
		{
			return null;
		}

		protected virtual void OnDisable()
		{
			if (enabledHag != null)
			{
				if ((bool)enabledHag.running)
				{
					host.Pause(enabledHag);
				}
				if (resetEnabled)
				{
					enabledHag.Reset(resetEnabledDescendants);
				}
			}
		}

		private void OnDestroy()
		{
			if (startHag != null && (bool)startHag.running)
			{
				host.Pause(startHag);
			}
		}
	}
	public abstract class HagletCondition
	{
		private class Never : HagletCondition
		{
			protected override bool GetValue()
			{
				return false;
			}
		}

		public static readonly HagletCondition never = new Never();

		protected abstract bool GetValue();

		public static implicit operator bool(HagletCondition cond)
		{
			return cond.GetValue();
		}
	}
	public abstract class HagletEvent
	{
		public struct Listener : Serializer.ISelfConstructor
		{
			public readonly Haglet haglet;

			[Serializer.Exclude]
			public readonly int clauseIdx;

			public Listener(Haglet haglet, int clauseIdx)
			{
				this.haglet = haglet;
				this.clauseIdx = clauseIdx;
			}

			private Listener(BinaryReader reader)
			{
				haglet = null;
				clauseIdx = reader.ReadByte();
			}

			void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
			{
				writer.Write((byte)clauseIdx);
			}

			public override string ToString()
			{
				if (haglet == null)
				{
					return "null";
				}
				return haglet.ToString();
			}
		}

		private List<Listener> listeners;

		private int count;

		protected HagletEvent(int listCap = 1)
		{
			listeners = new List<Listener>(listCap);
		}

		protected bool Happen()
		{
			if (count == 0)
			{
				return false;
			}
			int num = count;
			while (--num >= 0)
			{
				Haglet haglet = listeners[num].haglet;
				haglet.yieldClauses[listeners[num].clauseIdx].CompleteEventListen();
			}
			return true;
		}

		public void Add(Listener listener)
		{
			listeners.Add(listener);
			count++;
		}

		public void Remove(Listener listener)
		{
			int num = count;
			while (--num >= 0)
			{
				if (listeners[num].haglet == listener.haglet && listeners[num].clauseIdx == listener.clauseIdx)
				{
					listeners.RemoveAt(num);
					count--;
					break;
				}
			}
		}

		public static HagletYieldTerm operator &(HagletEvent evtA, HagletEvent evtB)
		{
			return Wait.Until(evtA) & Wait.Until(evtB);
		}

		public static HagletYieldTerm operator |(HagletEvent evtA, HagletEvent evtB)
		{
			return Wait.Until(evtA) | Wait.Until(evtB);
		}
	}
	public class HagletHost
	{
		private static HagletHost _default;

		public static HagletHost current;

		public const int routineCapacity = 10;

		public const int routineImmediateContinueLimit = 1000;

		public const int routineSkipContinueLimit = 10000;

		public const int routineChildCapacity = 20;

		public static Haglet currHag;

		public static HagletStepTime currStep;

		public readonly string name;

		public Haglet firstHag;

		public Haglet nextHag;

		public double time;

		public double timeFixed;

		public ulong updateStepCount;

		public ulong updateStepCountFixed;

		public static HagletHost @default
		{
			get
			{
				return _default ?? (_default = new HagletHost("Default"));
			}
			set
			{
				_default = value;
			}
		}

		public static bool doingOnSkip { get; private set; }

		public int Count
		{
			get
			{
				int num = 0;
				for (Haglet nextSib = firstHag; nextSib != null; nextSib = nextSib.nextSib)
				{
					num += 1 + GetDescendantCount(nextSib);
				}
				return num;
			}
		}

		public HagletHost(string nameIn = null)
		{
			name = nameIn ?? "Haglet Host";
		}

		private HagletHost()
		{
		}

		public void StartTopLevel(Haglet haglet, Haglet skipAdopter = null, bool prestep = false)
		{
			if ((bool)haglet.running)
			{
				return;
			}
			if (skipAdopter != null && skipAdopter.skipDepth != -1)
			{
				StartAsChild(haglet, skipAdopter, asFirst: true);
			}
			else
			{
				haglet.nextSib = firstHag;
				if (firstHag != null)
				{
					firstHag.prevSib = haglet;
				}
				firstHag = haglet;
				haglet.Start(this);
				haglet.skipAdopter = skipAdopter;
			}
			if (prestep)
			{
				int continues = 0;
				StepYieldClauses(haglet, routineIncomplete: false);
				haglet.DefaultYieldClauses();
				Step(haglet, ref continues);
			}
			else
			{
				haglet.InitializeYieldClauses();
			}
		}

		public void Pause(Haglet haglet, bool afterPrestep = false, bool propagate = true)
		{
			if (propagate)
			{
				while (haglet.firstChild != null)
				{
					Pause(haglet.firstChild);
				}
			}
			if (nextHag == haglet)
			{
				nextHag = haglet.nextSib ?? haglet.parent;
			}
			if (haglet.prevSib == null && haglet.nextSib == null)
			{
				if (haglet.parent != null)
				{
					haglet.parent.firstChild = null;
					if (haglet.parent.skipDepth == -1 && !afterPrestep)
					{
						haglet.parent.InitializeYieldClauses();
					}
					if (haglet == currHag)
					{
						nextHag = haglet.parent;
					}
				}
				else
				{
					firstHag = null;
				}
			}
			else
			{
				if (haglet == currHag && haglet.parent != null && haglet.parent.skipDepth != -1 && haglet.nextSib == null)
				{
					nextHag = haglet.parent;
				}
				if (haglet == firstHag)
				{
					firstHag = haglet.nextSib;
				}
				else if (haglet.parent != null && haglet.parent.firstChild == haglet)
				{
					haglet.parent.firstChild = haglet.nextSib;
				}
				if (haglet.prevSib != null)
				{
					haglet.prevSib.nextSib = haglet.nextSib;
				}
				if (haglet.nextSib != null)
				{
					haglet.nextSib.prevSib = haglet.prevSib;
				}
			}
			haglet.Pause();
		}

		public void PauseAll()
		{
			while (firstHag != null)
			{
				Pause(firstHag);
			}
		}

		public void Step(HagletStepTime time)
		{
			UpdateTime(time);
			if (firstHag == null)
			{
				return;
			}
			current = this;
			currStep = time;
			Haglet haglet = null;
			for (currHag = firstHag; currHag != null; currHag = nextHag)
			{
				while (currHag.firstChild != null)
				{
					currHag = currHag.firstChild;
				}
				nextHag = null;
				for (Haglet parent = currHag; parent != null; parent = parent.parent)
				{
					if (parent.nextSib != null)
					{
						nextHag = parent.nextSib;
						break;
					}
				}
				if (currHag.skipDepth == 0)
				{
					haglet = currHag;
				}
				int continues = 0;
				while (!StepYieldClauses(currHag) && !GetYieldClausesNotClear() && !Step(currHag, ref continues))
				{
					if (haglet == null && currHag.skipDepth == 0)
					{
						haglet = currHag;
					}
				}
				if (haglet == currHag && currHag.skipDepth != 0)
				{
					haglet = null;
				}
			}
			if (haglet != null)
			{
			}
			current = null;
			currStep = HagletStepTime.Unspecified;
			nextHag = null;
		}

		public void StartAsChild(Haglet child, Haglet parent, bool asFirst)
		{
			child.parent = parent;
			if (asFirst)
			{
				if (child.parent.firstChild != null)
				{
					child.nextSib = child.parent.firstChild;
					child.nextSib.prevSib = child;
				}
				parent.firstChild = child;
			}
			else if (parent.firstChild == null)
			{
				parent.firstChild = child;
			}
			else
			{
				Haglet haglet = parent.firstChild;
				while (haglet.nextSib != null)
				{
					haglet = haglet.nextSib;
				}
				haglet.nextSib = child;
				child.prevSib = haglet;
			}
			if (parent.skipDepth != -1)
			{
				SetSkipDepth(child, parent.skipDepth + 1, 1);
			}
			child.Start(this);
			if (currHag != null && (parent == currHag || parent.IsAncestorOf(currHag)))
			{
				nextHag = parent.firstChild;
				while (nextHag.firstChild != null)
				{
					nextHag = nextHag.firstChild;
				}
			}
		}

		public void Skip(Haglet skipper)
		{
			if (skipper.skipDepth != -1)
			{
				return;
			}
			UnityEngine.Debug.LogFormat("Begun skipping {0} on {1}", skipper, GetStackTrace());
			SetSkipDepth(skipper, 0, 1);
			Haglet haglet = firstHag;
			Haglet haglet2 = null;
			while (haglet != null)
			{
				haglet2 = haglet.nextSib;
				if (haglet.skipAdopter == skipper)
				{
					Pause(haglet, afterPrestep: false, propagate: false);
					StartAsChild(haglet, skipper, asFirst: true);
				}
				haglet = haglet2;
			}
		}

		public void StopSkip(Haglet skipper)
		{
			if (skipper.skipDepth != -1)
			{
				UnityEngine.Debug.LogFormat("Stopped skipping {0} on {1}", skipper, GetStackTrace());
				while (skipper.parent != null && skipper.parent.skipDepth != -1)
				{
					skipper = skipper.parent;
				}
				SetSkipDepth(skipper, -1, 0);
			}
		}

		private int GetDescendantCount(Haglet haglet)
		{
			int num = 0;
			for (Haglet haglet2 = haglet.firstChild; haglet2 != null; haglet2 = haglet2.nextSib)
			{
				num += 1 + GetDescendantCount(haglet);
			}
			return num;
		}

		private void UpdateTime(HagletStepTime stepTime)
		{
			switch (stepTime)
			{
			case HagletStepTime.Update:
				time += Time.deltaTime;
				updateStepCount++;
				break;
			case HagletStepTime.FixedUpdate:
				timeFixed += Time.fixedDeltaTime;
				updateStepCountFixed++;
				break;
			}
		}

		private bool StepYieldClauses(Haglet hag, bool routineIncomplete = true)
		{
			HagletHost hagletHost = current;
			Haglet haglet = currHag;
			current = this;
			currHag = hag;
			bool flag = hag.skipDepth != -1 || (routineIncomplete && CurrYieldClausesHasOnlyStarts());
			HagletYieldClause[] yieldClauses = currHag.yieldClauses;
			for (int i = 0; i <= currHag.maxYieldClauseDepth; i++)
			{
				int j = 0;
				for (int num = yieldClauses.Length; j < num; j++)
				{
					if (yieldClauses[j].depth != i)
					{
						continue;
					}
					if (currHag.skipDepth != -1 && yieldClauses[j].OnSkip != null)
					{
						try
						{
							doingOnSkip = true;
							yieldClauses[j].OnSkip(currHag, yieldClauses[j].OnSkipUserData);
						}
						catch (Exception exc)
						{
							currHag.HandleException(exc);
							return true;
						}
						finally
						{
							doingOnSkip = false;
						}
						yieldClauses[j].OnSkip = null;
						yieldClauses[j].OnSkipUserData = null;
						if (!currHag.stepped)
						{
							return true;
						}
						if (currHag.firstChild != null)
						{
							return true;
						}
					}
					switch (yieldClauses[j].type)
					{
					case HagletYieldClause.Type.ResetToHere:
						hag.MarkResetPoint();
						yieldClauses[j].Clear();
						break;
					case HagletYieldClause.Type.Reset:
						hag.Reset();
						yieldClauses[j].Clear();
						break;
					case HagletYieldClause.Type.Start:
						if (flag)
						{
							StartAsChild(yieldClauses[j].newHaglet, hag, asFirst: false);
						}
						else
						{
							StartTopLevel(yieldClauses[j].newHaglet, yieldClauses[j].skipAdopter, prestep: true);
							if (hag.skipDepth != -1)
							{
								Skip(yieldClauses[j].newHaglet);
							}
						}
						yieldClauses[j].Clear();
						break;
					default:
						if (hag.skipDepth != -1)
						{
							yieldClauses[j].Clear(met: false, propagate: false);
						}
						else
						{
							if ((yieldClauses[j].stepTimes & currStep) == 0)
							{
								break;
							}
							bool flag2;
							switch (yieldClauses[j].type)
							{
							case HagletYieldClause.Type.ForSeconds:
								switch (yieldClauses[j].stepTimes)
								{
								case HagletStepTime.Update:
								case HagletStepTime.LateUpdate:
								case HagletStepTime.EditorUpdate:
									break;
								case HagletStepTime.FixedUpdate:
								case HagletStepTime.EditorFixedUpdate:
									goto IL_02dc;
								default:
									goto IL_04fc;
								}
								if (time >= yieldClauses[j].targetTime)
								{
									goto IL_04fc;
								}
								break;
							case HagletYieldClause.Type.ForSteps:
								switch (yieldClauses[j].stepTimes)
								{
								case HagletStepTime.Update:
								case HagletStepTime.LateUpdate:
								case HagletStepTime.EditorUpdate:
									break;
								case HagletStepTime.FixedUpdate:
								case HagletStepTime.EditorFixedUpdate:
									goto IL_0370;
								default:
									goto IL_04fc;
								}
								if (updateStepCount >= yieldClauses[j].targetSteps)
								{
									goto IL_04fc;
								}
								break;
							case HagletYieldClause.Type.UntilFunc:
								flag2 = yieldClauses[j].func();
								goto IL_0406;
							case HagletYieldClause.Type.WhileFunc:
								flag2 = !yieldClauses[j].func();
								goto IL_0406;
							case HagletYieldClause.Type.UntilCond:
								flag2 = yieldClauses[j].cond;
								goto IL_0406;
							case HagletYieldClause.Type.WhileCond:
								flag2 = !yieldClauses[j].cond;
								goto IL_0406;
							case HagletYieldClause.Type.All:
							{
								for (int k = 0; k < yieldClauses[j].subclauseQty; k++)
								{
									if (yieldClauses[yieldClauses[j].GetSubclauseIdx(k)].type != 0)
									{
										goto end_IL_023e;
									}
								}
								goto IL_04fc;
							}
							case HagletYieldClause.Type.Any:
							{
								for (int num2 = 0; num2 < yieldClauses[j].subclauseQty; num2++)
								{
									if (yieldClauses[yieldClauses[j].GetSubclauseIdx(num2)].type == HagletYieldClause.Type.Clear)
									{
										goto IL_04fc;
									}
								}
								break;
							}
							case HagletYieldClause.Type.UntilEvent:
								if (yieldClauses[j].@event != null)
								{
									break;
								}
								goto IL_04fc;
							default:
								goto IL_04fc;
								IL_0370:
								if (updateStepCountFixed >= yieldClauses[j].targetSteps)
								{
									goto IL_04fc;
								}
								break;
								IL_0406:
								if (flag2)
								{
									if (!yieldClauses[j].condCleared)
									{
										yieldClauses[j].condCleared = true;
										goto IL_04fc;
									}
									break;
								}
								yieldClauses[j].condCleared = false;
								break;
								IL_04fc:
								yieldClauses[j].Clear();
								break;
								IL_02dc:
								if (timeFixed >= yieldClauses[j].targetTime)
								{
									goto IL_04fc;
								}
								break;
								end_IL_023e:
								break;
							}
						}
						break;
					}
					if (currHag.skipDepth != -1 && currHag.firstChild != null)
					{
						goto end_IL_0544;
					}
				}
				continue;
				end_IL_0544:
				break;
			}
			current = hagletHost;
			currHag = haglet;
			Haglet haglet2 = hag;
			while (haglet2.skipDepth > 0)
			{
				if (haglet2.prevSib != null)
				{
					nextHag = haglet2.prevSib;
					return true;
				}
				haglet2 = haglet2.parent;
			}
			return hag.firstChild != null;
		}

		private bool GetYieldClausesNotClear()
		{
			HagletYieldClause[] yieldClauses = currHag.yieldClauses;
			int i = 0;
			for (int num = yieldClauses.Length; i < num; i++)
			{
				if (yieldClauses[i].type != 0)
				{
					return true;
				}
			}
			return false;
		}

		public bool Step(Haglet hag, ref int continues)
		{
			if (hag.completedWithChildren)
			{
				if (hag.stepped)
				{
					Pause(hag);
				}
				if (hag.resettable)
				{
					hag.Reset();
				}
				hag.completedWithChildren = false;
				return true;
			}
			HagletHost hagletHost = current;
			Haglet haglet = currHag;
			current = this;
			currHag = hag;
			bool result = true;
			hag.maxYieldClauseDepth = 0;
			bool flag = hag.Step();
			if (hag.lastException != null)
			{
				if (hag.stepped)
				{
					hag.InitializeYieldClauses();
				}
			}
			else if (flag)
			{
				StepYieldClauses(currHag, routineIncomplete: false);
				if (hag.skipDepth != -1 && hag.firstChild != null)
				{
					hag.completedWithChildren = true;
				}
				else
				{
					bool stepped = hag.stepped;
					if (stepped)
					{
						Pause(hag);
					}
					if (hag.resettable)
					{
						hag.Reset();
					}
					if (stepped)
					{
						hag.PostComplete();
					}
				}
			}
			else if ((hag.skipDepth == -1 || hag.firstChild == null) && hag.stepped)
			{
				int num = ((hag.skipDepth == -1) ? 1000 : 10000);
				if (++continues >= num)
				{
					hag.HandleException(new HagletHangException(hag));
				}
				else
				{
					result = false;
				}
			}
			current = hagletHost;
			currHag = haglet;
			return result;
		}

		private void SetSkipDepth(Haglet skipper, int depth, int step)
		{
			skipper.skipDepth = depth;
			for (Haglet haglet = skipper.firstChild; haglet != null; haglet = haglet.nextSib)
			{
				SetSkipDepth(haglet, depth + step, step);
			}
		}

		private bool CurrYieldClausesHasOnlyStarts()
		{
			bool flag = false;
			bool flag2 = false;
			HagletYieldClause[] yieldClauses = currHag.yieldClauses;
			int i = 0;
			for (int num = yieldClauses.Length; i < num; i++)
			{
				switch (yieldClauses[i].type)
				{
				case HagletYieldClause.Type.Start:
					if (flag2)
					{
						return false;
					}
					flag = true;
					break;
				default:
					if (flag)
					{
						return false;
					}
					flag2 = true;
					break;
				case HagletYieldClause.Type.Clear:
					break;
				}
			}
			return flag;
		}

		public override string ToString()
		{
			return name;
		}

		public string GetStackTrace()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendFormat("{0} Stack Trace (FC:{1})", this, Time.frameCount);
			for (Haglet nextSib = firstHag; nextSib != null; nextSib = nextSib.nextSib)
			{
				if (nextSib.showInStackTrace)
				{
				}
			}
			return stringBuilder.ToString();
		}

		public void LogStackTrace(bool error = false)
		{
			if (error)
			{
				UnityEngine.Debug.LogError(GetStackTrace());
			}
			else
			{
				UnityEngine.Debug.Log(GetStackTrace());
			}
		}

		[Conditional("UNITY_EDITOR")]
		public void AddToStackViewer()
		{
		}

		[Conditional("UNITY_EDITOR")]
		public void RemoveFromStackViewer()
		{
		}
	}
	[ExecuteInEditMode]
	public class HagletHostDriver : MonoBehaviour
	{
		public enum HostMode
		{
			SetDefault,
			UseDefault,
			Individual
		}

		public List<HagletStepTime> stepTimes = new List<HagletStepTime>(3);

		public HostMode hostMode;

		public new string name;

		public HagletHost host { get; private set; }

		private void Awake()
		{
			switch (hostMode)
			{
			case HostMode.UseDefault:
				host = HagletHost.@default;
				break;
			case HostMode.SetDefault:
			{
				HagletHost @default = (host = new HagletHost(name));
				HagletHost.@default = @default;
				break;
			}
			case HostMode.Individual:
				host = new HagletHost(name);
				break;
			}
		}

		private void Start()
		{
		}

		private void OnDestroy()
		{
		}

		private void Update()
		{
			if (stepTimes.Contains(HagletStepTime.Update))
			{
				host.Step(HagletStepTime.Update);
			}
		}

		private void LateUpdate()
		{
			if (stepTimes.Contains(HagletStepTime.LateUpdate))
			{
				host.Step(HagletStepTime.LateUpdate);
			}
		}

		private void FixedUpdate()
		{
			if (stepTimes.Contains(HagletStepTime.FixedUpdate))
			{
				host.Step(HagletStepTime.FixedUpdate);
			}
		}
	}
	public static class Panic
	{
		public static void Haglet(string str, params object[] paramsIn)
		{
			if (HagletHost.current != null)
			{
				HagletHost.current.LogStackTrace(error: true);
			}
			throw new InvalidOperationException(string.Format(str, paramsIn));
		}

		[Conditional("CS_DEBUG")]
		public static void HagletBroken()
		{
			Haglet("{0} has broken somehow! Please contact whoever most recently committed changes to Haglet's scripts *before* clearing your console!", HagletHost.current);
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchNull(IEnumerator<HagletYieldTerm> routine, string name)
		{
			if (routine == null)
			{
				Haglet("Haglet '{0}' was constructed with a null routine parameter!", name);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchUnspecified(HagletStepTime stepTimes, string name)
		{
			if (stepTimes == HagletStepTime.Unspecified)
			{
				Haglet("Haglet '{0}' has no specified default step time!", name);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchNotRunning(Haglet haglet)
		{
			if (!haglet.running)
			{
				Haglet("Attempted to pause {0} when it is not running!", haglet);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadStartTopLevel(HagletHost host, Haglet haglet, Haglet skipAdopter)
		{
			if (haglet == null)
			{
				Haglet("Attempted to top-level-start a null haglet on {0}!", host);
			}
			if (haglet == skipAdopter)
			{
				Haglet("Attempted to top-level-start {0} on {1} with itself as its skip adopter!", haglet, host);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadRoutineStart(Haglet haglet, Haglet skipAdopter)
		{
			if (HagletHost.currHag == null)
			{
				Haglet("Called Routine.Start({0}) with no executing haglet or supplied fallback host!", haglet);
			}
			if (haglet == null)
			{
				Haglet("Called Routine.Start(null) during {0}!", HagletHost.currHag);
			}
			if (haglet == HagletHost.currHag)
			{
				Haglet("Called Routine.Start({0}) during {0}!", haglet);
			}
			if (haglet == skipAdopter)
			{
				Haglet("Called Routine.Start({0}) with itself as its skip adopter!", haglet);
			}
			if (haglet.markedToRunBy != null)
			{
				Haglet("Called Routine.Start({0}) in {1} while {0} is marked to run by {2}!", haglet, HagletHost.currHag, haglet.markedToRunBy);
			}
			if ((bool)haglet.running)
			{
				Haglet("Called Routine.Start({0}) in {1} while {0} is already running!", haglet, HagletHost.currHag);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadPause(Haglet paused)
		{
			if (paused == null)
			{
				Haglet("Called Routine.Pause(null) during {0}!", HagletHost.currHag);
			}
			if (!paused.running)
			{
				Haglet("Called Routine.Pause({0}) in {1} while {0} is not running!", paused, HagletHost.currHag);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletNotResettable(Haglet haglet)
		{
			Haglet("Attempted to use {0} as though it were resettable, which it isn't!", haglet);
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadResetPoint(Haglet haglet)
		{
			if (haglet.stepping)
			{
				Haglet("Attempted to mark the reset point of {0} while it was executing. use 'yield return Routine.Reset();' instead.", haglet);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadReset(Haglet haglet)
		{
			if (haglet.stepping)
			{
				Haglet("Attempted to reset {0} while it was executing. use 'yield return Routine.Reset();' instead.", haglet);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletOverYield()
		{
			Haglet("{0} has a yield condition that is too long. Specify a large enough yield capacity or consider using several parallel routines instead of one.", HagletHost.currHag);
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadMetCheck(int clauseIdx)
		{
			if (HagletHost.currHag == null)
			{
				Haglet("HagletYieldTerm.met was called outside of a routine, which is not supported.");
			}
			if (clauseIdx < 0 || clauseIdx > HagletHost.currHag.yieldClauses.Length)
			{
				Haglet("{0} queried a badly constructed yield term. The term must be returned from a successful Wait method.", HagletHost.currHag);
			}
		}

		[Conditional("CS_DEBUG")]
		public static void HagletCatchBadIsolate(int clauseIdx)
		{
			if (HagletHost.currHag == null)
			{
				Haglet("HagletYieldTerm.Isolate() was called outside of a routine, which is not supported.");
			}
			if (clauseIdx < 0 || clauseIdx > HagletHost.currHag.yieldClauses.Length)
			{
				Haglet("{0} queried a badly constructed yield term. The term must be returned from a successful Wait method.", HagletHost.currHag);
			}
		}

		[Conditional("AE_DEBUG")]
		public static void AE(UnityEngine.Object source, string str, params object[] paramsIn)
		{
			UnityEngine.Debug.LogErrorFormat(source, str, paramsIn);
			if (LR.Inst != null && LR.Host != null)
			{
				LR.Host.LogStackTrace(error: true);
			}
			if (MR.Inst != null && MR.Inst.Host != null)
			{
				MR.Inst.Host.LogStackTrace(error: true);
			}
			if (LR.DEBUG_autoTestFilters == null)
			{
				if (MR.Inst == null || string.IsNullOrEmpty(MR.Inst.DEBUG_startingCutscene))
				{
					UnityEngine.Debug.Break();
				}
				if (UIDebug.Inst != null)
				{
					UIDebug.Inst.TryStopAutoSkip();
				}
				return;
			}
			throw new Exception(string.Format(str, paramsIn));
		}

		[Conditional("AE_DEBUG")]
		public static void AE(string str, params object[] paramsIn)
		{
		}

		[Conditional("AE_DEBUG")]
		public static void AE(bool condition, UnityEngine.Object source, string str, params object[] paramsIn)
		{
			if (!condition)
			{
			}
		}

		[Conditional("AE_DEBUG")]
		public static void AE(bool condition, string str, params object[] paramsIn)
		{
		}
	}
	internal class HagletHangException : Exception
	{
		public HagletHangException(Haglet hag)
			: base($"{hag}'s wait condition was immediately met too many times. Indefinite immediate continuation is not supported.")
		{
		}
	}
	public class HagletResettable : Haglet
	{
		private readonly FieldInfo pcField;

		private object resetPoint;

		private static readonly object defaultResetPoint = 0;

		public override bool resettable => true;

		public HagletResettable(IEnumerator<HagletYieldTerm> routineIn, string nameIn = null, HagletStepTime defaultStepTimesIn = HagletStepTime.Update, int initResetPoint = -1, int yieldTermCap = 10, HagletHost prestepHost = null, bool showInStackTrace = true)
			: base(routineIn, nameIn, defaultStepTimesIn, yieldTermCap, prestepHost, showInStackTrace)
		{
			resetPoint = ((initResetPoint == -1) ? defaultResetPoint : ((object)initResetPoint));
			pcField = routine.GetType().GetField("$PC", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		protected HagletResettable(BinaryReader reader)
			: base(reader)
		{
		}

		public override void MarkResetPoint()
		{
			resetPoint = pcField.GetValue(routine);
		}

		public override void Reset(bool resetDescendants = true)
		{
			pcField.SetValue(routine, resetPoint);
			ClearYieldClauses();
			for (Haglet haglet = firstChild; haglet != null; haglet = haglet.nextSib)
			{
				host.Pause(haglet);
				if (resetDescendants)
				{
					haglet.Reset();
				}
			}
			complete = false;
		}

		public static void StartOrReset(HagletResettable resettable, HagletHost host, bool prestep = false)
		{
			if ((bool)resettable.running || resettable.markedToRunBy != null)
			{
				resettable.Reset();
				return;
			}
			bool prestep2 = prestep;
			host.StartTopLevel(resettable, null, prestep2);
		}
	}
	public abstract class HagletScriptable : ScriptableObject
	{
		private Haglet haglet;

		public Haglet GetHaglet(bool resettable = false, HagletStepTime defaultStepTime = HagletStepTime.Update)
		{
			if (haglet == null)
			{
				IEnumerator<HagletYieldTerm> enumerator = Script(resettable);
				if (enumerator == null)
				{
					return null;
				}
				haglet = ((!resettable) ? new Haglet(enumerator, base.name, defaultStepTime) : new HagletResettable(enumerator, base.name, defaultStepTime));
			}
			return haglet;
		}

		protected abstract IEnumerator<HagletYieldTerm> Script(bool resettable);
	}
	public abstract class HagletInstScriptable<T> : HagletScriptable
	{
		public T inst;
	}
	public class HagletScriptableBehaviour : MonoBehaviour
	{
		public HagletScriptableRef fromStart;

		public HagletScriptableRef whileEnabled;

		public HagletStepTime defaultStepTime = HagletStepTime.Update;

		protected bool resetOnDisable;

		private Haglet enabledHaglet;

		protected virtual HagletHost host => HagletHost.@default;

		protected virtual void Start()
		{
			HagletScriptable hagletScriptable = fromStart.Acquire();
			if (!(hagletScriptable == null))
			{
				Haglet haglet = hagletScriptable.GetHaglet(resettable: false, defaultStepTime);
				if (haglet != null)
				{
					host.StartTopLevel(haglet);
				}
			}
		}

		protected virtual void OnEnabled()
		{
			if (enabledHaglet == null)
			{
				HagletScriptable hagletScriptable = whileEnabled.Acquire();
				if (hagletScriptable == null)
				{
					return;
				}
				enabledHaglet = hagletScriptable.GetHaglet(resetOnDisable, defaultStepTime);
				if (enabledHaglet == null)
				{
					return;
				}
			}
			host.StartTopLevel(enabledHaglet);
		}

		protected virtual void OnDisabled()
		{
			if (enabledHaglet != null)
			{
				host.Pause(enabledHaglet);
				if (resetOnDisable)
				{
					enabledHaglet.Reset();
				}
				else
				{
					enabledHaglet = null;
				}
			}
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class HagletScriptableOnly : PropertyAttribute
	{
	}
	public struct HagletScriptableRef
	{
		public enum Instantiation
		{
			None,
			Initial,
			Repeated
		}

		[HagletScriptableOnly]
		public ScriptableObject target;

		public Instantiation instantiation;

		public HagletScriptable Acquire()
		{
			if (target == null)
			{
				return null;
			}
			HagletScriptable result = (HagletScriptable)target;
			if (instantiation != 0)
			{
				result = (HagletScriptable)(target = UnityEngine.Object.Instantiate(target));
				if (instantiation == Instantiation.Initial)
				{
					instantiation = Instantiation.None;
				}
			}
			return result;
		}

		public static implicit operator bool(HagletScriptableRef inst)
		{
			return inst.target != null;
		}
	}
	[Flags]
	public enum HagletStepTime : byte
	{
		Unspecified = 0,
		Update = 1,
		FixedUpdate = 2,
		LateUpdate = 4,
		EditorUpdate = 8,
		EditorLateUpdate = 0x10,
		EditorFixedUpdate = 0x20
	}
	public class HagletTester : MonoBehaviour
	{
		private HagletHost host = new HagletHost("HagletTester Host");

		public HagletTrigger doTestForSeconds;

		public HagletTrigger doTestForSteps;

		public HagletTrigger doTestFunc;

		public HagletTrigger doTestCondition;

		public HagletTrigger doTestReset;

		public HagletTrigger doTestAll;

		public HagletTrigger doTestAny;

		public HagletTrigger doTestMultiWait;

		public bool testFuncValue;

		public HagletFlag testCondition = new HagletFlag();

		public bool testResetOnNext;

		public HagletFlag testOther = new HagletFlag();

		public HagletTrigger testTrigger;

		[Multiline(30)]
		public string stack;

		private void Start()
		{
			host.StartTopLevel(new Haglet(TestForSeconds()));
			host.StartTopLevel(new Haglet(TestForSteps()));
			host.StartTopLevel(new Haglet(TestFunc()));
			host.StartTopLevel(new Haglet(TestCondition()));
			host.StartTopLevel(new HagletResettable(TestReset()));
			host.StartTopLevel(new Haglet(TestAll()));
			host.StartTopLevel(new Haglet(TestAny()));
			host.StartTopLevel(new Haglet(TestMultiWait()));
		}

		private IEnumerator<HagletYieldTerm> TestForSeconds()
		{
			UnityEngine.Debug.Log("TestForSeconds: Ready.");
			while (true)
			{
				yield return doTestForSeconds;
				int i = 0;
				while (i < 4)
				{
					UnityEngine.Debug.LogFormat("TestForSeconds: {0} second(s)...", (float)i++ * 0.5f);
					yield return Wait.ForSeconds(0.5f);
				}
				UnityEngine.Debug.Log("TestForSeconds: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestForSteps()
		{
			UnityEngine.Debug.Log("TestForSteps: Ready.");
			while (true)
			{
				yield return doTestForSteps;
				for (int i = 0; i < 4; i++)
				{
					UnityEngine.Debug.Log("TestForSteps: Waiting for 60 updates...");
					yield return Wait.ForSteps(60uL, HagletStepTime.Update);
				}
				UnityEngine.Debug.Log("TestForSteps: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestFunc()
		{
			Func<bool> testFuncValueTicked = () => testFuncValue;
			UnityEngine.Debug.Log("TestFunc: Ready.");
			while (true)
			{
				yield return doTestFunc;
				for (int i = 0; i < 3; i++)
				{
					UnityEngine.Debug.Log("TestFunc: Waiting until funcValue ticked...");
					yield return Wait.Until(testFuncValueTicked);
					UnityEngine.Debug.Log("TestFunc: Waiting while funcValue ticked...");
					yield return Wait.While(testFuncValueTicked);
				}
				UnityEngine.Debug.Log("TestFunc: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestCondition()
		{
			Func<bool> funcValueTicked = () => testFuncValue;
			UnityEngine.Debug.Log("TestCondition: Ready.");
			while (true)
			{
				yield return doTestCondition;
				for (int i = 0; i < 3; i++)
				{
					UnityEngine.Debug.Log("TestCondition: Waiting until flag");
					yield return Wait.Until(testCondition);
					UnityEngine.Debug.Log("TestCondition: Waiting while flag");
					yield return Wait.While(testCondition);
				}
				UnityEngine.Debug.Log("TestCondition: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestReset()
		{
			UnityEngine.Debug.Log("TestReset: Ready.");
			while (true)
			{
				yield return Routine.ResetToHere();
				yield return doTestReset;
				yield return Routine.ResetToHere();
				UnityEngine.Debug.Log("TestReset: 1...");
				yield return Wait.ForSeconds(0.6f);
				if (testResetOnNext)
				{
					UnityEngine.Debug.Log("TestReset: ResetToHere.");
					yield return Routine.ResetToHere();
					testResetOnNext = false;
				}
				UnityEngine.Debug.Log("TestReset: 2...");
				yield return Wait.ForSeconds(0.6f);
				if (testResetOnNext)
				{
					UnityEngine.Debug.Log("TestReset: ResetToHere.");
					yield return Routine.ResetToHere();
					testResetOnNext = false;
				}
				UnityEngine.Debug.Log("TestReset: 3...");
				yield return Wait.ForSeconds(0.6f);
				if (testResetOnNext)
				{
					UnityEngine.Debug.Log("TestReset: ResetToHere.");
					yield return Routine.ResetToHere();
					testResetOnNext = false;
				}
				UnityEngine.Debug.Log("TestReset: 4...");
				yield return Wait.ForSeconds(0.6f);
				if (testResetOnNext)
				{
					UnityEngine.Debug.Log("TestReset: Finished.");
					testResetOnNext = false;
				}
				else
				{
					UnityEngine.Debug.Log("TestReset: Reset.");
					yield return Routine.Reset();
				}
			}
		}

		private IEnumerator<HagletYieldTerm> TestAll()
		{
			Func<bool> testFuncValueTicked = () => testFuncValue;
			Func<bool> testResetOnNextTicked = () => testResetOnNext;
			UnityEngine.Debug.Log("TestAll: Ready.");
			while (true)
			{
				yield return doTestAll;
				testFuncValue = false;
				testCondition.Clear();
				testResetOnNext = false;
				testOther.Clear();
				UnityEngine.Debug.Log("TestAll: Waiting (until Test Func Value) and (until Test Condition) and (until Test Reset On Next) and (until Test Other).");
				yield return Wait.Until(testFuncValueTicked) & Wait.Until(testCondition) & Wait.Until(testResetOnNextTicked) & Wait.Until(testOther);
				UnityEngine.Debug.Log("TestAll: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestAny()
		{
			Func<bool> testFuncValueTicked = () => testFuncValue;
			Func<bool> testResetOnNextTicked = () => testResetOnNext;
			UnityEngine.Debug.Log("TestAny: Ready.");
			while (true)
			{
				yield return doTestAny;
				testFuncValue = false;
				testCondition.Clear();
				testResetOnNext = false;
				testOther.Clear();
				UnityEngine.Debug.Log("TestAny: Waiting (until Test Func Value) or (until Test Condition) or (until Test Reset On Next) or (until Test Other).");
				yield return Wait.Until(testFuncValueTicked) | Wait.Until(testCondition) | Wait.Until(testResetOnNextTicked) | Wait.Until(testOther);
				UnityEngine.Debug.Log("TestAny: Finished.");
			}
		}

		private IEnumerator<HagletYieldTerm> TestMultiWait()
		{
			UnityEngine.Debug.Log("TestMultiWait: Ready.");
			while (true)
			{
				yield return doTestMultiWait;
				UnityEngine.Debug.Log("TestMultiWait: Waiting until Test Trigger was triggered four times.");
				yield return Wait.Until(testTrigger, 4u);
				UnityEngine.Debug.Log("TestMultiWait: Waiting until Test Condition was true four times.");
				testCondition.Clear();
				yield return Wait.Until(testCondition, 4u);
				UnityEngine.Debug.Log("TestMultiWait: Waiting (until Test Trigger was triggered twice) and (Test Condition was true twice).");
				testCondition.Clear();
				yield return Wait.Until(testTrigger, 2u) & Wait.Until(testCondition, 2u);
				UnityEngine.Debug.Log("TestAny: Finished.");
			}
		}

		private void Update()
		{
			host.Step(HagletStepTime.Update);
			stack = host.GetStackTrace();
		}
	}
	public struct HagletYieldClause : Serializer.ISelfConstructor
	{
		public enum Type : byte
		{
			Clear,
			ForSeconds,
			ForSteps,
			UntilFunc,
			WhileFunc,
			All,
			Any,
			ResetToHere,
			Reset,
			UntilCond,
			WhileCond,
			UntilEvent,
			Start
		}

		[Serializer.Exclude]
		public Type type;

		[Serializer.Exclude]
		public byte depth;

		[Serializer.Exclude]
		public HagletStepTime stepTimes;

		[Serializer.Exclude]
		public uint remaining;

		[Serializer.Exclude]
		public double targetTime;

		[Serializer.Exclude]
		public ulong targetSteps;

		public Func<bool> func;

		public HagletCondition cond;

		[Serializer.Exclude]
		public bool condCleared;

		public HagletEvent @event;

		public HagletEvent.Listener listener;

		[Serializer.Exclude]
		public byte subclauseQty;

		[Serializer.Exclude]
		public ulong subclauses;

		[Serializer.Exclude]
		public Action<Haglet, object> OnSkip;

		[Serializer.Exclude]
		public object OnSkipUserData;

		public Haglet newHaglet;

		public Haglet skipAdopter;

		public bool isolate;

		private HagletYieldClause(BinaryReader reader)
		{
			depth = 0;
			stepTimes = HagletStepTime.Unspecified;
			remaining = 0u;
			targetTime = 0.0;
			targetSteps = 0uL;
			condCleared = false;
			subclauseQty = 0;
			subclauses = 0uL;
			func = null;
			cond = null;
			@event = null;
			listener = default(HagletEvent.Listener);
			OnSkip = null;
			OnSkipUserData = null;
			newHaglet = null;
			skipAdopter = null;
			isolate = false;
			type = (Type)reader.ReadByte();
			if (type != 0)
			{
				depth = reader.ReadByte();
				stepTimes = (HagletStepTime)reader.ReadByte();
				remaining = reader.ReadUInt32();
				switch (type)
				{
				case Type.ForSeconds:
					targetTime = reader.ReadDouble();
					break;
				case Type.ForSteps:
					targetSteps = reader.ReadUInt64();
					break;
				case Type.UntilFunc:
				case Type.WhileFunc:
					throw new NotSupportedException("Func<bool> based haglet yield clauses cannot presently be serialized!");
				case Type.All:
				case Type.Any:
					subclauseQty = reader.ReadByte();
					subclauses = reader.ReadUInt64();
					break;
				case Type.UntilCond:
				case Type.WhileCond:
					condCleared = reader.ReadBoolean();
					break;
				case Type.ResetToHere:
				case Type.Reset:
					break;
				}
			}
		}

		public void Clear(bool met = true, bool propagate = true)
		{
			if (type == Type.Clear || (met && remaining != 0 && --remaining != 0))
			{
				return;
			}
			if (@event != null)
			{
				@event.Remove(listener);
			}
			else if (propagate)
			{
				for (int i = 0; i < subclauseQty; i++)
				{
					HagletHost.currHag.yieldClauses[GetSubclauseIdx(i)].Clear(met: false);
				}
			}
			uint num = remaining;
			this = default(HagletYieldClause);
			remaining = num;
		}

		public void CompleteEventListen()
		{
			if (--remaining == 0)
			{
				@event.Remove(listener);
				@event = null;
			}
		}

		public int GetSubclauseIdx(int idx)
		{
			return (int)(subclauses >> idx * 8) & 0xFF;
		}

		public bool Absorb(ref HagletYieldClause other)
		{
			if (subclauseQty == 8)
			{
				return false;
			}
			subclauses |= other.subclauses << subclauseQty * 8;
			byte b = (byte)(subclauseQty + other.subclauseQty);
			if (b > 8)
			{
				subclauseQty = 8;
				other.subclauseQty = (byte)(b - 8);
				other.subclauses >>= other.subclauseQty * 8;
				return false;
			}
			subclauseQty += other.subclauseQty;
			other.subclauseQty = 0;
			other = default(HagletYieldClause);
			return true;
		}

		public bool AddSubclause(int subClauseIdx)
		{
			if (subclauseQty == 8)
			{
				return false;
			}
			SetSubclauseIdx(subclauseQty++, (sbyte)subClauseIdx);
			return true;
		}

		private void SetSubclauseIdx(int idx, sbyte val)
		{
			subclauses &= (ulong)(~(255L << idx * 8));
			subclauses |= (ulong)((long)val << idx * 8);
		}

		public override string ToString()
		{
			return type.ToString();
		}

		void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
		{
			writer.Write((byte)type);
			if (type != 0)
			{
				writer.Write(depth);
				writer.Write((byte)stepTimes);
				writer.Write(remaining);
				switch (type)
				{
				case Type.ForSeconds:
					writer.Write(targetTime);
					break;
				case Type.ForSteps:
					writer.Write(targetSteps);
					break;
				case Type.UntilFunc:
				case Type.WhileFunc:
					throw new NotSupportedException("Func<bool> based haglet yield clauses cannot presently be serialized!");
				case Type.All:
				case Type.Any:
					writer.Write(subclauseQty);
					writer.Write(subclauses);
					break;
				case Type.UntilCond:
				case Type.WhileCond:
					writer.Write(condCleared);
					break;
				case Type.ResetToHere:
				case Type.Reset:
					break;
				}
			}
		}
	}
	public static class Wait
	{
		public static readonly HagletYieldTerm PreMet = -1;

		public static readonly HagletYieldTerm Invalid = -2;

		public static readonly HagletYieldTerm ForChildren = Invalid;

		public static readonly HagletYieldTerm None = -3;

		public static HagletYieldTerm ForSeconds(float seconds, HagletStepTime stepTime = HagletStepTime.Unspecified)
		{
			if (seconds <= 0f)
			{
				return PreMet;
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			if (stepTime == HagletStepTime.Unspecified)
			{
				stepTime = HagletHost.currHag.defaultStepTimes;
			}
			currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.ForSeconds;
			currHag.yieldClauses[freeYieldClauseIdx].stepTimes = stepTime;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			switch (stepTime)
			{
			case HagletStepTime.Update:
			case HagletStepTime.LateUpdate:
			case HagletStepTime.EditorUpdate:
				currHag.yieldClauses[freeYieldClauseIdx].targetTime = HagletHost.current.time + (double)seconds;
				break;
			case HagletStepTime.FixedUpdate:
			case HagletStepTime.EditorFixedUpdate:
				currHag.yieldClauses[freeYieldClauseIdx].targetTime = HagletHost.current.timeFixed + (double)seconds;
				break;
			}
			return freeYieldClauseIdx;
		}

		public static HagletYieldTerm ForSteps(ulong steps, HagletStepTime stepTime = HagletStepTime.Unspecified)
		{
			if (steps == 0)
			{
				return PreMet;
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			if (stepTime == HagletStepTime.Unspecified)
			{
				stepTime = HagletHost.currHag.defaultStepTimes;
			}
			currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.ForSteps;
			currHag.yieldClauses[freeYieldClauseIdx].stepTimes = stepTime;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			switch (stepTime)
			{
			case HagletStepTime.Update:
			case HagletStepTime.LateUpdate:
			case HagletStepTime.EditorUpdate:
				currHag.yieldClauses[freeYieldClauseIdx].targetSteps = HagletHost.current.updateStepCount + steps;
				break;
			case HagletStepTime.FixedUpdate:
			case HagletStepTime.EditorFixedUpdate:
				currHag.yieldClauses[freeYieldClauseIdx].targetSteps = HagletHost.current.updateStepCountFixed + steps;
				break;
			}
			return freeYieldClauseIdx;
		}

		public static HagletYieldTerm UntilNextUpdate()
		{
			return ForSteps(1uL, HagletStepTime.Update);
		}

		public static HagletYieldTerm UntilNextFixedUpdate()
		{
			return ForSteps(1uL, HagletStepTime.FixedUpdate);
		}

		public static HagletYieldTerm UntilNextLateUpdate()
		{
			return ForSteps(1uL, HagletStepTime.LateUpdate);
		}

		public static HagletYieldTerm UntilNextEditorUpdate()
		{
			return ForSteps(1uL, HagletStepTime.EditorUpdate);
		}

		public static HagletYieldTerm UntilNextEditorFixedUpdate()
		{
			return ForSteps(1uL, HagletStepTime.EditorFixedUpdate);
		}

		public static HagletYieldTerm Until(Func<bool> funcIn, bool returnVal, uint count)
		{
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			currHag.yieldClauses[freeYieldClauseIdx].type = ((!returnVal) ? HagletYieldClause.Type.WhileFunc : HagletYieldClause.Type.UntilFunc);
			currHag.yieldClauses[freeYieldClauseIdx].func = funcIn;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = count;
			return freeYieldClauseIdx;
		}

		public static HagletYieldTerm Until(Func<bool> func, uint count = 1u)
		{
			return Until(func, returnVal: true, count);
		}

		public static HagletYieldTerm While(Func<bool> func, uint count = 1u)
		{
			return Until(func, returnVal: false, count);
		}

		public static HagletYieldTerm Until(HagletCondition cond, bool value, uint count = 1u)
		{
			if ((bool)cond == value)
			{
				return PreMet;
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			currHag.yieldClauses[freeYieldClauseIdx].type = ((!value) ? HagletYieldClause.Type.WhileCond : HagletYieldClause.Type.UntilCond);
			currHag.yieldClauses[freeYieldClauseIdx].cond = cond;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = count;
			return freeYieldClauseIdx;
		}

		public static HagletYieldTerm Until(HagletCondition cond, uint count = 1u)
		{
			return Until(cond, value: true, count);
		}

		public static HagletYieldTerm While(HagletCondition cond, uint count = 1u)
		{
			return Until(cond, value: false, count);
		}

		public static HagletYieldTerm Until(HagletEvent @event, uint count = 1u)
		{
			if (@event == null)
			{
				return None;
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			HagletEvent.Listener listener = new HagletEvent.Listener(HagletHost.currHag, freeYieldClauseIdx);
			currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.UntilEvent;
			currHag.yieldClauses[freeYieldClauseIdx].@event = @event;
			currHag.yieldClauses[freeYieldClauseIdx].listener = listener;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = count;
			@event.Add(listener);
			return freeYieldClauseIdx;
		}
	}
	public static class Routine
	{
		public static HagletYieldTerm ResetToHere()
		{
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.ResetToHere;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			return freeYieldClauseIdx;
		}

		public static HagletYieldTerm Reset()
		{
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.Reset;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			return freeYieldClauseIdx;
		}

		public static void SkipStop()
		{
			if (HagletHost.currHag != null)
			{
				HagletHost.current.StopSkip(HagletHost.currHag);
			}
		}

		public static bool IsSkipping()
		{
			return HagletHost.currHag != null && HagletHost.currHag.skipDepth != -1;
		}

		public static HagletYieldTerm Start(Haglet started, HagletHost fallbackHost = null, Haglet skipAdopter = null)
		{
			if ((HagletHost.currHag == null || !HagletHost.currHag.running) && fallbackHost != null)
			{
				started.markedToRunBy = null;
				fallbackHost.StartTopLevel(started, skipAdopter, prestep: true);
				return Wait.None;
			}
			if ((bool)started.running)
			{
				return Wait.None;
			}
			if (HagletHost.doingOnSkip)
			{
				HagletHost.currHag.host.StartAsChild(started, HagletHost.currHag, asFirst: false);
				return Wait.None;
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			Haglet currHag = HagletHost.currHag;
			currHag.yieldClauses[freeYieldClauseIdx].type = HagletYieldClause.Type.Start;
			currHag.yieldClauses[freeYieldClauseIdx].newHaglet = started;
			currHag.yieldClauses[freeYieldClauseIdx].skipAdopter = skipAdopter;
			currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			started.markedToRunBy = HagletHost.currHag;
			return freeYieldClauseIdx;
		}

		public static void Pause(Haglet paused)
		{
			paused.host.Pause(paused);
		}

		public static HagletYieldTerm Pause()
		{
			HagletHost.current.Pause(HagletHost.currHag);
			return Wait.PreMet;
		}

		public static void GoTopLevel()
		{
			HagletHost.current.Pause(HagletHost.currHag);
			HagletHost.current.StartTopLevel(HagletHost.currHag);
		}

		public static T SkipOverride<T>(this T value, T overrideValue)
		{
			if (HagletHost.currHag != null && (HagletHost.currHag.skipDepth != -1 || HagletHost.currHag.wasSkipping))
			{
				return overrideValue;
			}
			return value;
		}
	}
	public struct HagletYieldTerm
	{
		public int clauseIdx;

		public bool met
		{
			get
			{
				if (this == Wait.PreMet)
				{
					return true;
				}
				if (this == Wait.None)
				{
					return false;
				}
				return HagletHost.currHag.yieldClauses[clauseIdx].remaining == 0;
			}
		}

		public static implicit operator HagletYieldTerm(int clauseIdxIn)
		{
			HagletYieldTerm result = default(HagletYieldTerm);
			result.clauseIdx = (sbyte)clauseIdxIn;
			return result;
		}

		public static implicit operator int(HagletYieldTerm term)
		{
			return term.clauseIdx;
		}

		public static implicit operator HagletYieldTerm(HagletEvent evt)
		{
			if (evt == null)
			{
				return Wait.ForSteps(1uL, HagletHost.currHag.defaultStepTimes);
			}
			return Wait.Until(evt);
		}

		public HagletYieldTerm At(HagletStepTime stepTimes)
		{
			if (this == Wait.PreMet || this == Wait.Invalid)
			{
				return this;
			}
			HagletHost.currHag.yieldClauses[clauseIdx].stepTimes = stepTimes;
			return this;
		}

		public HagletYieldTerm OnSkip(Action<Haglet, object> onSkip, object onSkipUserData = null)
		{
			if (this == Wait.PreMet || this == Wait.Invalid)
			{
				return this;
			}
			HagletHost.currHag.yieldClauses[clauseIdx].OnSkip = onSkip;
			HagletHost.currHag.yieldClauses[clauseIdx].OnSkipUserData = onSkipUserData;
			return this;
		}

		public HagletYieldTerm Isolate()
		{
			HagletHost.currHag.yieldClauses[clauseIdx].isolate = true;
			return this;
		}

		public static HagletYieldTerm operator &(HagletYieldTerm termA, HagletYieldTerm termB)
		{
			if (termA == Wait.Invalid || termB == Wait.Invalid)
			{
				return Wait.Invalid;
			}
			if (termA == Wait.PreMet && termB == Wait.PreMet)
			{
				return Wait.PreMet;
			}
			if (termA == Wait.PreMet || termA == Wait.None)
			{
				return termB;
			}
			if (termB == Wait.PreMet || termA == Wait.None)
			{
				return termA;
			}
			return Operator(HagletYieldClause.Type.All, termA, termB);
		}

		public static HagletYieldTerm operator |(HagletYieldTerm termA, HagletYieldTerm termB)
		{
			if (termA == Wait.Invalid || termB == Wait.Invalid)
			{
				return Wait.Invalid;
			}
			if (termA == Wait.None)
			{
				return termB;
			}
			if (termB == Wait.None)
			{
				return termA;
			}
			if (termA == Wait.PreMet)
			{
				if (termB != Wait.PreMet)
				{
					HagletHost.currHag.yieldClauses[(int)termB].Clear(met: false);
				}
				return Wait.PreMet;
			}
			if (termB == Wait.PreMet)
			{
				HagletHost.currHag.yieldClauses[(int)termA].Clear(met: false);
				return Wait.PreMet;
			}
			return Operator(HagletYieldClause.Type.Any, termA, termB);
		}

		private static HagletYieldTerm Operator(HagletYieldClause.Type type, HagletYieldTerm termA, HagletYieldTerm termB)
		{
			if (!HagletHost.currHag.yieldClauses[(int)termA].isolate && !HagletHost.currHag.yieldClauses[(int)termB].isolate)
			{
				if (HagletHost.currHag.yieldClauses[(int)termA].type == type)
				{
					if (HagletHost.currHag.yieldClauses[(int)termB].type == type)
					{
						if (HagletHost.currHag.yieldClauses[(int)termA].Absorb(ref HagletHost.currHag.yieldClauses[(int)termB]))
						{
							return termA;
						}
					}
					else if (HagletHost.currHag.yieldClauses[(int)termA].AddSubclause(termB))
					{
						return termA;
					}
				}
				else if (HagletHost.currHag.yieldClauses[(int)termB].type == type && HagletHost.currHag.yieldClauses[(int)termB].AddSubclause(termA))
				{
					return termB;
				}
			}
			int freeYieldClauseIdx = HagletHost.currHag.GetFreeYieldClauseIdx();
			byte depth = HagletHost.currHag.yieldClauses[(int)termA].depth;
			byte depth2 = HagletHost.currHag.yieldClauses[(int)termB].depth;
			byte b = (byte)(((depth <= depth2) ? depth2 : depth) + 1);
			HagletStepTime stepTimes = HagletHost.currHag.yieldClauses[(int)termA].stepTimes;
			HagletStepTime stepTimes2 = HagletHost.currHag.yieldClauses[(int)termB].stepTimes;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].type = type;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].depth = b;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].AddSubclause(termA);
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].AddSubclause(termB);
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].stepTimes = stepTimes | stepTimes2;
			HagletHost.currHag.yieldClauses[freeYieldClauseIdx].remaining = 1u;
			HagletHost.currHag.maxYieldClauseDepth = Mathf.Max(HagletHost.currHag.maxYieldClauseDepth, b);
			return freeYieldClauseIdx;
		}

		public static bool operator ==(HagletYieldTerm left, HagletYieldTerm right)
		{
			return left.clauseIdx == right.clauseIdx;
		}

		public static bool operator !=(HagletYieldTerm left, HagletYieldTerm right)
		{
			return left.clauseIdx != right.clauseIdx;
		}

		public override int GetHashCode()
		{
			return clauseIdx;
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		[Conditional("CS_DEBUG")]
		public static void Debug_StoreStackFileAndLineInfo(Haglet hag, HagletYieldTerm term)
		{
			StackTrace stackTrace = new StackTrace(fNeedFileInfo: true);
			StackFrame[] frames = stackTrace.GetFrames();
			FieldInfo field = typeof(StackFrame).GetField("methodBase", BindingFlags.Instance | BindingFlags.NonPublic);
			int i = 0;
			for (int num = frames.Length; i < num; i++)
			{
				StackFrame obj = frames[i];
				if (!(field.GetValue(obj) is MethodInfo methodInfo) || !Attribute.IsDefined(methodInfo.DeclaringType, typeof(CompilerGeneratedAttribute)))
				{
				}
			}
		}
	}
	public class HagletLoop
	{
		public Haglet target;

		public int loops;

		public int remaining { get; private set; }

		public HagletLoop(Haglet targetIn = null, int loopsIn = -1)
		{
			target = targetIn;
			loops = loopsIn;
		}

		public IEnumerator<HagletYieldTerm> Loop()
		{
			while (loops != 0)
			{
				while (loops < 0)
				{
					if (target == null)
					{
						yield break;
					}
					yield return Routine.Start(target);
				}
				remaining = loops;
				while (remaining-- > 0)
				{
					if (target == null)
					{
						yield break;
					}
					yield return Routine.Start(target);
					remaining--;
				}
			}
		}
	}
	public class HagletOrientRigidbody
	{
		public float strengthPerRadian;

		public float dampening;

		public Rigidbody rigidbody;

		public Vector3 targWorldFwd;

		public Vector3 targWorldUp;

		public Vector3 localFwd;

		public Vector3 localUp;

		public IEnumerator<HagletYieldTerm> Routine()
		{
			while (true)
			{
				yield return Wait.UntilNextFixedUpdate();
				if (!(rigidbody == null))
				{
					Vector3 fwdCross = Vector3.Cross(targWorldFwd.normalized, rigidbody.transform.TransformDirection(localFwd));
					if (fwdCross.x != 0f || fwdCross.y != 0f || fwdCross.z != 0f)
					{
						float magnitude = fwdCross.magnitude;
						Vector3 vector = fwdCross / magnitude;
						float num = (float)Math.Asin(magnitude);
						rigidbody.AddTorque(vector * (0f - strengthPerRadian * num));
					}
					Vector3 upCross = Vector3.Cross(targWorldUp.normalized, rigidbody.transform.TransformDirection(localUp));
					if (upCross.x != 0f || upCross.y != 0f || upCross.z != 0f)
					{
						float magnitude2 = upCross.magnitude;
						Vector3 vector2 = upCross / magnitude2;
						float num2 = (float)Math.Asin(magnitude2);
						rigidbody.AddTorque(vector2 * (0f - strengthPerRadian * num2));
					}
					rigidbody.AddTorque((0f - dampening) * rigidbody.angularVelocity);
				}
			}
		}
	}
	public class HagletParallel
	{
		public List<Haglet> targets;

		public HagletParallel(List<Haglet> targetsIn)
		{
			targets = targetsIn;
		}

		public HagletParallel()
		{
		}

		public IEnumerator<HagletYieldTerm> Parallel()
		{
			if (targets == null)
			{
				yield break;
			}
			HagletYieldTerm waitForChildren = Wait.ForChildren;
			int i = 0;
			for (int count = targets.Count; i < count; i++)
			{
				if (targets[i] != null)
				{
					waitForChildren &= Routine.Start(targets[i]);
				}
			}
			yield return waitForChildren;
		}
	}
	public class HagletPositionRigidbody
	{
		public float strengthPerDist;

		public float dampeningPerSpeed;

		public float maxForce;

		public Rigidbody rigidbody;

		public Vector3 targWorldPos;

		public Vector3 localOrigin;

		public IEnumerator<HagletYieldTerm> Routine()
		{
			while (true)
			{
				yield return Wait.UntilNextFixedUpdate();
				if (!(rigidbody == null))
				{
					Transform rbTform = rigidbody.transform;
					Vector3 relPos = targWorldPos - rbTform.TransformPoint(localOrigin);
					rigidbody.AddForce((strengthPerDist * relPos).ClampedToMagnitude(maxForce));
					rigidbody.AddForce(((0f - dampeningPerSpeed) * rigidbody.velocity).ClampedToMagnitude(maxForce));
				}
			}
		}
	}
	public class HagletSequence
	{
		public List<Haglet> targets;

		public int counter;

		public HagletSequence(List<Haglet> targetsIn, int counterIn = 0)
		{
			targets = targetsIn;
			counter = counterIn;
		}

		public HagletSequence(int cap, int counterIn = 0)
		{
			targets = new List<Haglet>(cap);
			counter = counterIn;
		}

		public HagletSequence()
		{
		}

		public IEnumerator<HagletYieldTerm> Sequence()
		{
			if (targets == null)
			{
				yield break;
			}
			while (counter < targets.Count)
			{
				if (targets[counter] != null)
				{
					yield return Routine.Start(targets[counter]);
				}
				counter++;
			}
			counter = 0;
		}
	}
	public class HagletLoopScriptable : HagletInstScriptable<HagletLoop>
	{
		public HagletScriptableRef target;

		protected override IEnumerator<HagletYieldTerm> Script(bool resettable)
		{
			HagletScriptable hagletScriptable = target.Acquire();
			if (hagletScriptable == null)
			{
				return null;
			}
			Haglet haglet = hagletScriptable.GetHaglet(resettable: true);
			if (haglet == null)
			{
				return null;
			}
			if (inst == null)
			{
				inst = new HagletLoop
				{
					target = haglet
				};
			}
			else
			{
				inst.target = haglet;
			}
			return inst.Loop();
		}
	}
	public class HagletParallelScriptable : HagletInstScriptable<HagletParallel>
	{
		public List<HagletScriptableRef> targets;

		protected override IEnumerator<HagletYieldTerm> Script(bool resettable)
		{
			if (targets == null || targets.Count == 0)
			{
				return null;
			}
			int count = targets.Count;
			List<Haglet> list = new List<Haglet>(count);
			for (int i = 0; i < count; i++)
			{
				HagletScriptable hagletScriptable = targets[i].Acquire();
				if (!(hagletScriptable == null))
				{
					Haglet haglet = hagletScriptable.GetHaglet(resettable);
					if (haglet != null)
					{
						list.Add(haglet);
					}
				}
			}
			if (list.Count == 0)
			{
				return null;
			}
			if (inst == null)
			{
				inst = new HagletParallel(list);
			}
			else
			{
				inst.targets = list;
			}
			return inst.Parallel();
		}
	}
}
namespace Coatsink.Common.HagletHelpers
{
	public class HagletOrientRigidbodyScriptable : HagletInstScriptable<HagletOrientRigidbody>
	{
		protected override IEnumerator<HagletYieldTerm> Script(bool resettable)
		{
			return inst.Routine();
		}
	}
	public class HagletPositionRigidbodyScriptable : HagletInstScriptable<HagletPositionRigidbody>
	{
		protected override IEnumerator<HagletYieldTerm> Script(bool resettable)
		{
			return inst.Routine();
		}
	}
}
namespace Coatsink.Common
{
	public class HagletSequenceScriptable : HagletInstScriptable<HagletSequence>
	{
		public List<HagletScriptableRef> targets;

		protected override IEnumerator<HagletYieldTerm> Script(bool resettable)
		{
			if (targets == null || targets.Count == 0)
			{
				return null;
			}
			int count = targets.Count;
			List<Haglet> list = new List<Haglet>(count);
			for (int i = 0; i < count; i++)
			{
				HagletScriptable hagletScriptable = targets[i].Acquire();
				if (!(hagletScriptable == null))
				{
					Haglet haglet = hagletScriptable.GetHaglet(resettable);
					if (haglet != null)
					{
						list.Add(haglet);
					}
				}
			}
			if (list.Count == 0)
			{
				return null;
			}
			if (inst == null)
			{
				inst = new HagletSequence(list);
			}
			else
			{
				inst.targets = list;
			}
			return inst.Sequence();
		}
	}
}
[Serializable]
public class JK3DAtlasMaterial
{
	public string atlasName;

	public string atlasPath;

	public Material staticMat;

	public Material dynamicMat;

	public bool isLightmapped;
}
[Serializable]
public class JK3DAtlasMaterials : ConstArray<JK3DAtlasMaterial>
{
	public JK3DAtlasMaterials(uint size)
		: base(size)
	{
	}

	private JK3DAtlasMaterials()
	{
	}
}
[ExecuteInEditMode]
public class JK3D : MonoBehaviour
{
	private const int kMaxMaterials = 8;

	[ReadOnly]
	[SerializeField]
	private JK3DAtlasMaterials atlasMaterials;

	public JK3DAtlasMaterial[] GetMaterialsForAtlasContaining(string toContain)
	{
		List<JK3DAtlasMaterial> list = new List<JK3DAtlasMaterial>();
		for (int i = 0; i < atlasMaterials.Length; i++)
		{
			JK3DAtlasMaterial jK3DAtlasMaterial = atlasMaterials[i];
			if (jK3DAtlasMaterial.atlasPath.Contains(toContain))
			{
				list.Add(jK3DAtlasMaterial);
			}
		}
		return list.ToArray();
	}

	public JK3DAtlasMaterials GetAtlasMaterialsRaw()
	{
		return atlasMaterials;
	}

	public JK3DAtlasMaterial[] GetAllAtlasMaterials()
	{
		return atlasMaterials.ToArray();
	}

	public void Merge(JK3D jk3d)
	{
		for (int i = 0; i < jk3d.atlasMaterials.Length; i++)
		{
			JK3DAtlasMaterial jK3DAtlasMaterial = jk3d.atlasMaterials[i];
			for (int j = 0; j < atlasMaterials.Length; j++)
			{
				JK3DAtlasMaterial jK3DAtlasMaterial2 = atlasMaterials[j];
				if (jK3DAtlasMaterial2.atlasPath != jK3DAtlasMaterial.atlasPath)
				{
					atlasMaterials.Add(jK3DAtlasMaterial);
					break;
				}
			}
		}
		UnityEngine.Object.Destroy(jk3d);
	}

	public void AddMaterials(Material[] materials)
	{
		foreach (Material material in materials)
		{
			JK3DAtlasMaterial jK3DAtlasMaterial = new JK3DAtlasMaterial();
			jK3DAtlasMaterial.atlasName = material.name;
			jK3DAtlasMaterial.atlasPath = material.name;
			jK3DAtlasMaterial.dynamicMat = material;
			jK3DAtlasMaterial.staticMat = material;
			atlasMaterials.Add(jK3DAtlasMaterial);
		}
	}

	public JK3DAtlasMaterial GetMaterialsWithName(string toContain)
	{
		for (int i = 0; i < atlasMaterials.Length; i++)
		{
			JK3DAtlasMaterial jK3DAtlasMaterial = atlasMaterials[i];
			if (jK3DAtlasMaterial.atlasPath.Contains(toContain))
			{
				return jK3DAtlasMaterial;
			}
		}
		UnityEngine.Debug.Log("JK3D: Failed to find atlas with name '" + toContain + "'");
		return null;
	}
}
public interface IJK3DCustomMesh
{
	Mesh GetMesh();

	Material GetMaterial();
}
public static class JK3DCustomMesh
{
	public static bool ValidType(UnityEngine.Object obj)
	{
		return typeof(IJK3DCustomMesh).IsAssignableFrom(obj.GetType());
	}
}
[Serializable]
public class JK3DAtlas : ScriptableObject, ISerializationCallbackReceiver
{
	[Flags]
	public enum MeshAttribute
	{
		Normals = 1,
		Tangents = 2,
		Colors = 4,
		TexCoords = 8,
		TexCoord2s = 0x10
	}

	[Serializable]
	public struct AdditionalTexture
	{
		public string shaderProperty;

		public Texture texture;
	}

	private struct TextureGroup
	{
		public Texture2D albedo;

		public Texture2D specularSmoothness;

		public Color specularColor;

		public Texture2D emissive;

		public Texture2D normal;

		public Texture2D mask;

		public override int GetHashCode()
		{
			return albedo.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			return ((TextureGroup)obj).albedo == albedo;
		}
	}

	[NonSerialized]
	public static bool ForceJK3DRefNotToSync;

	public bool lightmapBatch = true;

	[FormerlySerializedAs("renderQueue")]
	public int renderQueueStatic = -1;

	public int renderQueueDynamic = -1;

	public MeshAttribute meshAttributes = MeshAttribute.Normals | MeshAttribute.Tangents | MeshAttribute.Colors | MeshAttribute.TexCoords | MeshAttribute.TexCoord2s;

	public List<AdditionalTexture> additionalTextures = new List<AdditionalTexture>();

	private const string kAtlasDataFolderName = "AtlasData";

	private const string kAtlasTexturesFolderName = "AtlasTextures";

	[HideInInspector]
	public JK3DAtlas targetMergeAtlas;

	public void OnBeforeSerialize()
	{
	}

	public void OnAfterDeserialize()
	{
	}
}
[Serializable]
public class JK3DAtlasData : ScriptableObject
{
	public List<Mesh> meshes = new List<Mesh>();

	public Material staticMat;

	public Material dynamicMat;

	public Mesh GetMeshWithModelName(string name)
	{
		foreach (Mesh mesh in meshes)
		{
			if (mesh.name == name)
			{
				return mesh;
			}
		}
		return null;
	}
}
public class JK3DForceFieldSettings : JK3DMeshMod
{
	public Color Border;

	public Color Middle;

	[Range(0.01f, 0.99f)]
	public float TopBeamIntensity;

	[Range(0.01f, 0.99f)]
	public float BottomBeamIntensity;

	public float ForceFieldActive;
}
public class JK3DMSHologramSettings : JK3DMeshMod
{
	public Color color;

	[Range(0f, 1f)]
	public float Alpha = 0.8f;
}
public abstract class JK3DMeshMod : MonoBehaviour
{
	[ReadOnly]
	[SerializeField]
	public Mesh meshClone;

	public virtual void OnEventSyncStarted(JK3DReference jk3dRef)
	{
	}

	public virtual void OnEventSyncComplete(JK3DReference jk3dRef, bool isBuild)
	{
	}
}
public interface IJK3DLightmapSetup
{
	Vector4 lightmapScaleOffset { get; }
}
[ExecuteInEditMode]
public class JK3DReference : MonoBehaviour
{
}
public class JK3DUV2Colorer : JK3DMeshMod
{
	public Vector2 uv2;

	public bool additive;

	public bool clamp01;
}
[ExecuteInEditMode]
[RequireComponent(typeof(JK3DReference))]
public class JK3DUV2Scalar : JK3DMeshMod
{
	public Vector2 tiling = Vector2.one;
}
public class JK3DVertexColorer : JK3DMeshMod
{
	public Color color;

	public bool additive;

	public bool clamp01;
}
public class JK3DWaterSettings : JK3DMeshMod
{
	public float speedX = 0.65f;

	public float speedY = 0.5f;

	[Range(0f, 1f)]
	public float fresnelIntensity = 0.68f;

	[Range(0f, 1f)]
	public float rippleIntensity = 0.65f;

	[Range(0f, 1f)]
	public float alpha = 1f;
}
public class MessageFormat
{
	public bool didSucceed;

	public string messageBack = string.Empty;
}
[ExecuteInEditMode]
public class JimBeast : MonoBehaviour
{
	[Serializable]
	public class WorkerPC
	{
		public enum WorkerStatus
		{
			NONE,
			BUSY,
			READY,
			NO_RESPONSE
		}

		public string hostName;

		public bool use;

		public float weight = 1f;

		public WorkerStatus workerStatus;

		public string progressAmount = string.Empty;

		public int lastMessage = 100;

		public WorkerPC(string hostName, float workloadMultiplier)
		{
			this.hostName = hostName;
			weight = workloadMultiplier;
		}
	}

	private const string kNetworkQueryProgress = "ReportProgress";

	private const string kNetworkQueryStatus = "ReportStatus";

	private const string kNetworkOrderResume = "ResumeBuild";

	private const string kNetworkOrderCancel = "CancelBuild";

	private const string kNetworkReportJobAccept = "Master, Your wish is my command!";

	private const string kNetworkReportCancelled = "Master, I have cancelled the build, performing cleanup, check my status in a few seconds";

	private const string kNetworkReportFree = "WaitingForCommand";

	private const string kNetworkReportBusy = "Busy";

	[Header("GENERAL")]
	public bool unlitMode = true;

	private bool unlitModePrev = true;

	[ReadOnly]
	public Texture2D texAtlasLight;

	[ReadOnly]
	public Texture2D texAtlasSpec;

	[Header("ATLAS SETTINGS")]
	public float resolution = 20f;

	public int atlasSize = 512;

	public int numBounces = 2;

	public int numIterations = -1;

	public bool showBlockColors;

	public Color skyColor = Color.black;

	public float skyBoost = 1f;

	public bool showSurfaceArea;

	public bool calculateDiffuseOnly;

	[Header("JIMBEAST SETTINGS")]
	public int KDTreeMaxTris = 5;

	public int KDTreeMaxDepth = 16;

	[Tooltip("Number of worker threads assign to calculate lighting. A manager thread will always be spawned and does not count towards this value.")]
	public int numWorkerThreads = 6;

	[Tooltip("If FALSE the meshes / textures are never updated on the GPU, freeing up another thread for light calculation.")]
	public bool updateGFX = true;

	public bool forceValidateOnExport = true;

	public bool localBuild = true;

	[SerializeField]
	[HideInInspector]
	public Vector4 lmsoSkylight = new Vector4(0f, 0f, 0f, 0f);

	public static int noResponseTimeout = 500;

	public static int updateTimeout = 5;

	[NonSerialized]
	public static WorkerPC[] workerPCNames = new WorkerPC[15]
	{
		new WorkerPC("Artist-PC", 1f),
		new WorkerPC("Jonny_PC", 1f),
		new WorkerPC("HANNAH-PC", 1f),
		new WorkerPC("JIM-PC", 1f),
		new WorkerPC("JIMMY-PC", 1f),
		new WorkerPC("APHRODITE", 1f),
		new WorkerPC("FENRIR", 1f),
		new WorkerPC("THANATOS", 1f),
		new WorkerPC("YMIR", 1f),
		new WorkerPC("RICKY-PC", 1f),
		new WorkerPC("SIMON-PC", 1f),
		new WorkerPC("Sylvanus-PC", 1f),
		new WorkerPC("TorgerPC", 1f),
		new WorkerPC("Emma-PC", 1f),
		new WorkerPC("SHAUN-PC", 1f)
	};

	[NonSerialized]
	public int[] workersGroupA = new int[5] { 0, 1, 2, 3, 4 };

	[NonSerialized]
	public int[] workersGroupB = new int[5] { 5, 6, 7, 8, 9 };

	[NonSerialized]
	public int[] workersGroupC = new int[5] { 10, 11, 12, 13, 14 };

	public string DEBUG_jimbeastExeDirectory;

	public event Action<Texture2D, Texture2D> OnLightmapBakeComplete;

	private void OnValidate()
	{
		if (unlitMode != unlitModePrev)
		{
			unlitModePrev = unlitMode;
			Texture2D texture2D = new Texture2D(4, 4);
			Color[] array = new Color[16];
			for (int i = 0; i < array.Length; i++)
			{
				ref Color reference = ref array[i];
				reference = new Color(1f, 1f, 1f, 0.25f);
			}
			texture2D.SetPixels(array);
			Texture2D texture2D2 = new Texture2D(4, 4);
			Color[] array2 = new Color[16];
			for (int j = 0; j < array2.Length; j++)
			{
				ref Color reference2 = ref array2[j];
				reference2 = new Color(0f, 0f, 0f, 0f);
			}
			texture2D2.SetPixels(array2);
			if (this.OnLightmapBakeComplete != null)
			{
				this.OnLightmapBakeComplete((!unlitMode) ? texAtlasLight : texture2D, (!unlitMode) ? texAtlasSpec : texture2D2);
			}
		}
	}
}
public class JimBeastCopyLightmap : MonoBehaviour
{
	public JK3DReference referenceToCopy;
}
public class JimBeastLight : MonoBehaviour
{
	public enum Type
	{
		Point,
		Spot
	}

	public Type type;

	[Range(0f, 90f)]
	public float spotAngle = 45f;

	public float intensity = 1f;

	[Tooltip("Radius is the physical size of the light (size of the bulb)")]
	[SerializeField]
	public float radius = 0.5f;

	[Tooltip("Range distance the light can affect objects")]
	[SerializeField]
	public float range = 5f;

	[Range(1f, 100f)]
	public float bounceBoost = 1f;

	public Color color = Color.white;

	public float Radius => radius * VectorX.Max(base.transform.lossyScale);

	public float Range => range * VectorX.Max(base.transform.lossyScale);
}
public class JimBeastMesh : MonoBehaviour
{
	[HideInInspector]
	[SerializeField]
	public IJK3DLightmapSetup lightmapSetupInterface;

	private MeshFilter meshFilter;

	public void OnPrebuild()
	{
	}
}
public class JimBeastMeshUID : MonoBehaviour, IJK3DLightmapSetup
{
	[SerializeField]
	[ReadOnly]
	public Vector4 _lightmapScaleOffset = new Vector4(1f, 1f, 0f, 0f);

	[SerializeField]
	[ReadOnly]
	private string _uID;

	public Vector4 lightmapScaleOffset
	{
		get
		{
			return _lightmapScaleOffset;
		}
		set
		{
			_lightmapScaleOffset = value;
		}
	}
}
public class JimBeastObjectParams : MonoBehaviour
{
	public float lightmapScale = 1f;

	public float metallic;

	public float shininess;

	public bool skyLighting;

	public float skyBoost = 1f;

	public float specularBoost;

	public bool useCustomSkyColor;

	public Color customSkyColor = Color.white;

	public float emissiveMultiplier = 1f;

	public JimBeastViewPoint viewPoint;
}
public class JimBeastRoot : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class JimBeastViewPoint : MonoBehaviour
{
}
public class CubemapNode : MonoBehaviour
{
	public enum Resolution
	{
		x64 = 0x40,
		x128 = 0x80,
		x256 = 0x100,
		x512 = 0x200,
		x1024 = 0x400,
		x2048 = 0x800
	}

	public Cubemap cubemap;

	public Resolution resolution = Resolution.x128;

	private void OnDrawGizmos()
	{
		Color black = Color.black;
		black.a = 0.4f;
		Gizmos.color = black;
		Gizmos.DrawSphere(base.transform.position, 0.15f);
		ReflectionProbe component = base.gameObject.GetComponent<ReflectionProbe>();
		if ((bool)component && (bool)component.texture && component.texture.filterMode != FilterMode.Trilinear)
		{
			component.texture.filterMode = FilterMode.Trilinear;
		}
	}
}
[ExecuteInEditMode]
public class LightmapRoom : MonoBehaviour
{
	public JimBeastViewPoint viewPoint;
}
namespace Coatsink.Common
{
	public static class Bitwise
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct TypeUnion
		{
			[FieldOffset(0)]
			public int Int32Bits;

			[FieldOffset(0)]
			public float FloatBits;
		}

		public static long IntsToLong(int msbs, int lsbs)
		{
			return msbs * 4294967296L + lsbs;
		}

		public static void LongToInts(long theLong, out int msbs, out int lsbs)
		{
			msbs = (int)(theLong / 4294967296L);
			lsbs = (int)theLong;
		}

		public static int BitRotate_u32(int value, int shift)
		{
			return (value << shift) | (value >> 32 - shift);
		}

		public static int BitRotate_u16(int value, int shift)
		{
			return ((value << shift) & 0xFFFF) | (value >> 8 - shift);
		}

		public static int BitRotate_u8(int value, int shift)
		{
			return ((value << shift) & 0xFF) | (value >> 8 - shift);
		}

		public static float PackVector2ToFloat(Vector2 input, float scale = 10000f)
		{
			short num = (short)(input.x * scale);
			short num2 = (short)(input.y * scale);
			TypeUnion typeUnion = default(TypeUnion);
			typeUnion.Int32Bits = (num << 16) | (num2 & 0xFFFF);
			return typeUnion.FloatBits;
		}

		public static Vector2 UnPackFloatToVector2(float input, float scale = 10000f)
		{
			TypeUnion typeUnion = default(TypeUnion);
			typeUnion.FloatBits = input;
			short num = (short)((typeUnion.Int32Bits >> 16) & 0xFFFF);
			short num2 = (short)(typeUnion.Int32Bits & 0xFFFF);
			float num3 = 1f / scale;
			return new Vector2((float)num * num3, (float)num2 * num3);
		}

		public static int PackVector2ToInt32(Vector2 v)
		{
			int num = 0;
			num |= (int)(v.x * 255f) << 0;
			return num | ((int)(v.y * 255f) << 8);
		}

		public static Vector2 UnpackInt32ToVector2(int v)
		{
			Vector2 result = new Vector2(result.x = (float)((v >> 0) & 0xFF) / 255f, result.y = (float)((v >> 8) & 0xFF) / 255f);
			return result;
		}
	}
	public static class ColorX
	{
		public static Color RGB(int r, int g, int b, int a = 255)
		{
			Color result = default(Color);
			result.r = (float)r / 255f;
			result.g = (float)g / 255f;
			result.b = (float)b / 255f;
			result.a = (float)a / 255f;
			return result;
		}

		public static Color RepR(this Color color, float newVal)
		{
			color.r = newVal;
			return color;
		}

		public static Color RepG(this Color color, float newVal)
		{
			color.g = newVal;
			return color;
		}

		public static Color RepB(this Color color, float newVal)
		{
			color.b = newVal;
			return color;
		}

		public static Color RepA(this Color color, float newVal)
		{
			color.a = newVal;
			return color;
		}

		public static Color RepRGB(this Color color, Vector3 rgb)
		{
			color.r = rgb.x;
			color.g = rgb.y;
			color.b = rgb.z;
			return color;
		}

		public static Vector3 GetRGB(this Color color)
		{
			return new Vector3(color.r, color.g, color.b);
		}

		public static Color From(Vector3 rgb, float a)
		{
			return new Color(rgb.x, rgb.y, rgb.z, a);
		}
	}
}
[Serializable]
public struct ComplexAngle
{
	public float r;

	public float i;

	public const float cwRevRadians = (float)Math.PI * -2f;

	public const float cwRevDegrees = 360f;

	public static readonly ComplexAngle radian = FromEuler(1f);

	public static readonly ComplexAngle cwDegree = FromEuler(-360f);

	public static readonly ComplexAngle cwRev = FromEuler((float)Math.PI * -2f);

	public static readonly ComplexAngle zero = FromEuler(0f);

	public static readonly ComplexAngle cwQuarter = FromEuler(-(float)Math.PI / 2f);

	public static readonly ComplexAngle cwHalf = FromEuler(-(float)Math.PI);

	public static readonly ComplexAngle cwThreeQuarters = FromEuler(-4.712389f);

	public float euler => Mathf.Atan2(i, r);

	public Vector2 direction => new Vector2(r, i);

	public Vector3 directionXZ => new Vector3(r, 0f, i);

	public Vector3 directionXY => new Vector3(r, i, 0f);

	public Vector3 directionYZ => new Vector3(0f, r, i);

	public ComplexAngle normalize
	{
		get
		{
			ComplexAngle result = default(ComplexAngle);
			float num = 1f / Mathf.Sqrt(r * r + i * i);
			result.r = r * num;
			result.i = i * num;
			return result;
		}
	}

	public ComplexAngle conjugate => new ComplexAngle(r, 0f - i);

	public ComplexAngle(float r, float c)
	{
		this.r = r;
		i = c;
	}

	public override string ToString()
	{
		return $"({r}, {i})";
	}

	public static ComplexAngle FromEuler(float angle)
	{
		ComplexAngle result = default(ComplexAngle);
		result.r = Mathf.Cos(angle);
		result.i = Mathf.Sin(angle);
		return result;
	}

	public static ComplexAngle FromVec(Vector2 dir)
	{
		dir = dir.normalized;
		return new ComplexAngle(dir.x, dir.y);
	}

	public static ComplexAngle FromVecXZ(Vector3 dir)
	{
		Vector2 normalized = new Vector2(dir.x, dir.z).normalized;
		return new ComplexAngle(normalized.x, normalized.y);
	}

	public static ComplexAngle FromVecPrenormalized(Vector2 direction)
	{
		return new ComplexAngle(direction.x, direction.y);
	}

	public static ComplexAngle FromVecXYPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.x, direction.y);
	}

	public static ComplexAngle FromVecYZPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.y, direction.z);
	}

	public static ComplexAngle FromVecXZPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.x, direction.z);
	}

	public static Vector2 operator *(ComplexAngle a, Vector2 b)
	{
		return new Vector2(a.r * b.x - a.i * b.y, a.r * b.y + a.i * b.x);
	}

	public static ComplexAngle operator *(ComplexAngle a, float s)
	{
		return new ComplexAngle(a.r * s, a.i * s);
	}

	public static ComplexAngle operator -(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r - b.r, a.i - b.i);
	}

	public static ComplexAngle operator +(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r + b.r, a.i + b.i);
	}

	public static ComplexAngle operator *(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);
	}

	public static float GetEulerBetween(ComplexAngle a, ComplexAngle b)
	{
		return (a * b.conjugate).euler;
	}

	public static ComplexAngle Nlerp(ComplexAngle a, ComplexAngle b, float t)
	{
		ComplexAngle complexAngle = default(ComplexAngle);
		complexAngle.r = a.r + (b.r - a.r) * t;
		complexAngle.i = a.i + (b.i - a.i) * t;
		return complexAngle.normalize;
	}

	public static ComplexAngle Slerp(ComplexAngle a, ComplexAngle b, float t)
	{
		t = Mathf.Clamp01(t);
		float num = a.r * b.r + a.i * b.i;
		if (num > 0.9995f)
		{
			return Nlerp(a, b, t);
		}
		ComplexAngle complexAngle = ((!(num < -0.995f)) ? (b - a * num).normalize : new ComplexAngle(0f - a.i, a.r));
		num = Mathf.Clamp(num, -1f, 1f);
		float f = Mathf.Acos(num) * t;
		return a * Mathf.Cos(f) + complexAngle * Mathf.Sin(f);
	}
}
namespace Coatsink.Common
{
	public static class MathfX
	{
		public enum SineRemapEaseType
		{
			In,
			Out,
			InOut
		}

		public const float tau = (float)Math.PI * 2f;

		public const float radsPerDeg = (float)Math.PI / 180f;

		public static float Percent(float min, float max, float value)
		{
			return (value - min) / (max - min);
		}

		public static bool CloseTo(this float source, float other, float maxDist)
		{
			return Mathf.Abs(source - other) < maxDist;
		}

		public static Vector3 ClosestPointLineSegment(Vector3 point, Vector3 start, Vector3 end)
		{
			Vector3 vector = end - start;
			float sqrMagnitude = vector.sqrMagnitude;
			if ((double)sqrMagnitude == 0.0)
			{
				return start;
			}
			float num = Vector3.Dot(point - start, vector) / sqrMagnitude;
			if (num < 0f)
			{
				return start;
			}
			if (num > 1f)
			{
				return end;
			}
			return start + vector * num;
		}

		public static bool IntersectSegmentRectangle(Vector2 seg0, Vector2 seg1, Vector2 rectMin, Vector2 rectMax)
		{
			float x = seg0.x;
			float y = seg0.y;
			float x2 = seg1.x;
			float y2 = seg1.y;
			Vector2 vector = new Vector2(rectMin.x, rectMin.y);
			Vector2 vector2 = new Vector2(rectMin.x, rectMax.y);
			Vector2 vector3 = new Vector2(rectMax.x, rectMin.y);
			Vector2 vector4 = new Vector2(rectMax.x, rectMax.y);
			int num = 0;
			num |= (int)((((y2 - y) * vector.x + (x - x2) * vector.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 0);
			num |= (int)((((y2 - y) * vector2.x + (x - x2) * vector2.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 1);
			num |= (int)((((y2 - y) * vector3.x + (x - x2) * vector3.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 2);
			num |= (int)((((y2 - y) * vector4.x + (x - x2) * vector4.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 3);
			if (num == 15 || num == 0)
			{
				return false;
			}
			if (x > rectMax.x && x2 > rectMax.x)
			{
				return false;
			}
			if (x < rectMin.x && x2 < rectMin.x)
			{
				return false;
			}
			if (y > rectMax.y && y2 > rectMax.y)
			{
				return false;
			}
			if (y < rectMin.y && y2 < rectMin.y)
			{
				return false;
			}
			return true;
		}

		public static float LinearRemapLerp(float value, float valueStart = 0f, float valueEnd = 1f, float resultStart = 0f, float resultEnd = 1f)
		{
			float num = valueEnd - valueStart;
			float num2 = resultEnd - resultStart;
			float num3 = (value - valueStart) / num;
			return resultStart + num3 * num2;
		}

		public static float SineRemapLerp(float value, SineRemapEaseType easeType = SineRemapEaseType.InOut, float valueStart = 0f, float valueEnd = 1f, float resultStart = 0f, float resultEnd = 1f)
		{
			float resultStart2;
			float resultEnd2;
			float valueStart2;
			float valueEnd2;
			switch (easeType)
			{
			case SineRemapEaseType.In:
				resultStart2 = 4.712389f;
				resultEnd2 = (float)Math.PI * 2f;
				valueStart2 = -1f;
				valueEnd2 = 0f;
				break;
			case SineRemapEaseType.Out:
				resultStart2 = 0f;
				resultEnd2 = (float)Math.PI / 2f;
				valueStart2 = 0f;
				valueEnd2 = 1f;
				break;
			default:
				resultStart2 = 4.712389f;
				resultEnd2 = (float)Math.PI / 2f;
				valueStart2 = -1f;
				valueEnd2 = 1f;
				break;
			}
			float f = LinearRemapLerp(value, valueStart, valueEnd, resultStart2, resultEnd2);
			float value2 = Mathf.Sin(f);
			return LinearRemapLerp(value2, valueStart2, valueEnd2, resultStart, resultEnd);
		}

		public static int Wrap(this int left, int right)
		{
			return (left % right + right) % right;
		}

		public static float Wrap(this float left, float right)
		{
			return (left % right + right) % right;
		}

		public static Quaternion LockedAxisBillboard(Vector3 position, Vector3 forward, Vector3 eye)
		{
			return Quaternion.LookRotation(forward, (eye - position).normalized);
		}

		public static float ForceAtEndsOfSpring(float springConst, float currentSpringDisplacement, float dampingCoefficient, float velocity)
		{
			return (0f - Mathf.Abs(springConst)) * currentSpringDisplacement - Mathf.Abs(dampingCoefficient) * velocity;
		}

		public static Bounds GetWorldBounds(this GameObject go)
		{
			Bounds result = ((!(go.GetComponent<Renderer>() == null)) ? go.GetComponent<Renderer>().bounds : new Bounds(go.transform.position, Vector3.zero));
			foreach (Transform item in go.transform)
			{
				result.Encapsulate(item.gameObject.GetWorldBounds());
			}
			return result;
		}

		public static float Step(float edge, float x)
		{
			return (!(x < edge)) ? 1 : 0;
		}

		public static float EaseInCurve(float t)
		{
			return 1f - Mathf.Sin((Mathf.Clamp01(t) + 1f) * (float)Math.PI * 0.5f);
		}

		public static float EaseOutCurve(float t)
		{
			return Mathf.Sin(Mathf.Clamp01(t) * (float)Math.PI * 0.5f);
		}
	}
	public struct Matrix2x2
	{
		public float m00;

		public float m01;

		public float m10;

		public float m11;

		public static readonly Matrix2x2 Identity = new Matrix2x2(1f, 0f, 0f, 1f);

		public Matrix2x2(float m00, float m01, float m10, float m11)
		{
			this.m00 = m00;
			this.m01 = m01;
			this.m10 = m10;
			this.m11 = m11;
		}

		public static Matrix2x2 Rotation(float angle)
		{
			float num = Mathf.Cos(angle);
			float num2 = Mathf.Sin(angle);
			return new Matrix2x2(num, 0f - num2, num2, num);
		}

		public static Matrix2x2 RotationFromVec2(Vector2 vec)
		{
			return new Matrix2x2(vec.x, 0f - vec.y, vec.y, vec.x);
		}

		public static float Mat22GetAngle(Matrix2x2 mat)
		{
			return Mathf.Atan2(mat.m01, mat.m00);
		}

		public static Matrix2x2 Mat22Inverse(Matrix2x2 mat)
		{
			float num = mat.m00 * mat.m11 - mat.m01 * mat.m10;
			if (num != 0f)
			{
				num = 1f / num;
			}
			return new Matrix2x2(num * mat.m11, (0f - num) * mat.m01, (0f - num) * mat.m10, num * mat.m00);
		}

		public static Vector2 operator *(Matrix2x2 mat, Vector2 vec)
		{
			return new Vector2(Vector2.Dot(new Vector2(mat.m00, mat.m01), vec), Vector2.Dot(new Vector2(mat.m10, mat.m11), vec));
		}
	}
	public enum OctDir
	{
		Up,
		UpRight,
		Right,
		DownRight,
		Down,
		DownLeft,
		Left,
		UpLeft
	}
	public static class OctDirX
	{
		public static float AngleCW(this OctDir to, OctDir from = OctDir.Up, float circumference = 360f)
		{
			return ((float)to - (float)from) * (circumference * 0.125f);
		}

		public static OctDir ToSimpleDir(this float angle, float up = 0f, float circumference = 360f)
		{
			return (OctDir)((Mathf.RoundToInt((angle - up) / (circumference / 8f)) % 8 + 8) % 8);
		}

		public static Vector3 ToV3XZ(this OctDir dir)
		{
			switch (dir)
			{
			case OctDir.Up:
			{
				Vector3 result8 = default(Vector3);
				result8.x = 0f;
				result8.z = 1f;
				return result8;
			}
			case OctDir.UpRight:
			{
				Vector3 result7 = default(Vector3);
				result7.x = 1f;
				result7.z = 1f;
				return result7;
			}
			case OctDir.Right:
			{
				Vector3 result6 = default(Vector3);
				result6.x = 1f;
				result6.z = 0f;
				return result6;
			}
			case OctDir.DownRight:
			{
				Vector3 result5 = default(Vector3);
				result5.x = 1f;
				result5.z = -1f;
				return result5;
			}
			case OctDir.Down:
			{
				Vector3 result4 = default(Vector3);
				result4.x = 0f;
				result4.z = -1f;
				return result4;
			}
			case OctDir.DownLeft:
			{
				Vector3 result3 = default(Vector3);
				result3.x = -1f;
				result3.z = -1f;
				return result3;
			}
			case OctDir.Left:
			{
				Vector3 result2 = default(Vector3);
				result2.x = -1f;
				result2.z = 0f;
				return result2;
			}
			default:
			{
				Vector3 result = default(Vector3);
				result.x = -1f;
				result.z = 1f;
				return result;
			}
			}
		}

		public static v2i ToV2i(this OctDir dir)
		{
			switch (dir)
			{
			case OctDir.Up:
			{
				v2i result8 = default(v2i);
				result8.x = 0;
				result8.y = 1;
				return result8;
			}
			case OctDir.UpRight:
			{
				v2i result7 = default(v2i);
				result7.x = 1;
				result7.y = 1;
				return result7;
			}
			case OctDir.Right:
			{
				v2i result6 = default(v2i);
				result6.x = 1;
				result6.y = 0;
				return result6;
			}
			case OctDir.DownRight:
			{
				v2i result5 = default(v2i);
				result5.x = 1;
				result5.y = -1;
				return result5;
			}
			case OctDir.Down:
			{
				v2i result4 = default(v2i);
				result4.x = 0;
				result4.y = -1;
				return result4;
			}
			case OctDir.DownLeft:
			{
				v2i result3 = default(v2i);
				result3.x = -1;
				result3.y = -1;
				return result3;
			}
			case OctDir.Left:
			{
				v2i result2 = default(v2i);
				result2.x = -1;
				result2.y = 0;
				return result2;
			}
			default:
			{
				v2i result = default(v2i);
				result.x = -1;
				result.y = 1;
				return result;
			}
			}
		}

		public static OctDir ToSimpleDirXZ(this Vector3 vect)
		{
			if (vect.x == 0f)
			{
				return (!(vect.z > 0f)) ? OctDir.Down : OctDir.Up;
			}
			if (vect.z == 0f)
			{
				return (!(vect.x > 0f)) ? OctDir.Left : OctDir.Right;
			}
			vect = vect.normalized;
			if (vect.z > 0.9238795f)
			{
				return OctDir.Up;
			}
			if (vect.z < -0.9238795f)
			{
				return OctDir.Down;
			}
			bool flag = vect.x > 0f;
			if (vect.z > 0.38268343f)
			{
				return flag ? OctDir.UpRight : OctDir.UpLeft;
			}
			if (vect.z > -0.38268343f)
			{
				return (!flag) ? OctDir.Left : OctDir.Right;
			}
			return (!flag) ? OctDir.DownLeft : OctDir.DownRight;
		}

		public static OctDir Negative(this OctDir dir)
		{
			int num = (int)(dir + 4);
			if (num > 7)
			{
				num -= 8;
			}
			return (OctDir)num;
		}
	}
	public static class RandomX
	{
		public static bool randomBool => UnityEngine.Random.Range(0, 2) == 1;

		public static float RandomSignedRange(float min, float max)
		{
			float num = UnityEngine.Random.Range(min, max * 2f);
			return (!(num > max)) ? num : (num * -0.5f);
		}

		public static bool PercentChance(this int chance)
		{
			return UnityEngine.Random.Range(0, 100) <= chance;
		}

		public static bool PercentChance(this float chance)
		{
			return UnityEngine.Random.Range(float.Epsilon, 100f) <= chance;
		}

		public static float RandomSign(this float val)
		{
			return (!randomBool) ? (0f - val) : val;
		}
	}
	public static class RectX
	{
		public static bool Overlaps(this Rect rect, IList<Rect> others)
		{
			for (int i = 0; i < others.Count; i++)
			{
				if (rect.Overlaps(others[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static Rect TranslatedBy(this Rect rect, Vector2 centerDelta)
		{
			rect.center += centerDelta;
			return rect;
		}

		public static Rect RecenteredTo(this Rect rect, Vector2 newCenter)
		{
			rect.center = newCenter;
			return rect;
		}

		public static Rect RecenteredBy(this Rect rect, Vector2 offset)
		{
			rect.center += offset;
			return rect;
		}

		public static Rect LerpPosition(Rect start, Rect end, float t)
		{
			return LerpPosition(start, end.center, t);
		}

		public static Rect LerpPosition(Rect start, Vector2 endCenter, float t)
		{
			start.center = Vector2.Lerp(start.center, endCenter, t);
			return start;
		}

		public static Rect RectOfCenterAndSize(Vector2 position, Vector2 size)
		{
			Vector2 vector = position - size / 2f;
			return new Rect(vector.x, vector.y, size.x, size.y);
		}

		public static Rect RectOfSize(Vector2 size)
		{
			return new Rect(0f, 0f, size.x, size.y);
		}

		public static Vector2 XMinYMax(this Rect rect)
		{
			return new Vector2(rect.xMin, rect.yMax);
		}

		public static Vector2 XMaxYMin(this Rect rect)
		{
			return new Vector2(rect.xMax, rect.yMin);
		}

		public static Vector2 XMinYCtr(this Rect rect)
		{
			return new Vector2(rect.xMin, rect.center.y);
		}

		public static Vector2 XMaxYCtr(this Rect rect)
		{
			return new Vector2(rect.xMax, rect.center.y);
		}

		public static Vector2 XCtrYMin(this Rect rect)
		{
			return new Vector2(rect.center.x, rect.yMin);
		}

		public static Vector2 XCtrYMax(this Rect rect)
		{
			return new Vector2(rect.center.x, rect.yMax);
		}

		public static Vector2[] BorderPoints(this Rect rect)
		{
			return new Vector2[8]
			{
				rect.min,
				rect.XMinYCtr(),
				rect.XMinYMax(),
				rect.XCtrYMax(),
				rect.max,
				rect.XMaxYCtr(),
				rect.XMaxYMin(),
				rect.XCtrYMin()
			};
		}

		public static Vector2[] CornerPoints(this Rect rect)
		{
			return new Vector2[4]
			{
				rect.min,
				rect.XMaxYMin(),
				rect.max,
				rect.XMinYMax()
			};
		}

		public static Vector2[] CornerPoints(this Rect rect, Vector2[] outArr)
		{
			ref Vector2 reference = ref outArr[0];
			reference = rect.min;
			ref Vector2 reference2 = ref outArr[1];
			reference2 = rect.XMaxYMin();
			ref Vector2 reference3 = ref outArr[2];
			reference3 = rect.max;
			ref Vector2 reference4 = ref outArr[3];
			reference4 = rect.XMinYMax();
			return outArr;
		}

		public static Rect ExpandedFromCenterBy(this Rect rect, Vector2 expansion)
		{
			rect.yMin -= expansion.y * 0.5f;
			rect.yMax += expansion.y;
			rect.xMin -= expansion.x * 0.5f;
			rect.xMax += expansion.x;
			return rect;
		}

		public static bool Contain(this IList<Rect> rects, Vector2 vect)
		{
			int num = rects.Count;
			while (--num >= 0)
			{
				if (rects[num].Contains(vect))
				{
					return true;
				}
			}
			return false;
		}
	}
	public static class VectorX
	{
		public static float Min(Vector3 v)
		{
			return Mathf.Min(v.x, Mathf.Min(v.y, v.z));
		}

		public static float Max(Vector3 v)
		{
			return Mathf.Max(v.x, Mathf.Max(v.y, v.z));
		}

		public static float Min(Vector2 v)
		{
			return Mathf.Min(v.x, v.y);
		}

		public static float Max(Vector2 v)
		{
			return Mathf.Max(v.x, v.y);
		}

		public static Vector2 Min(Vector2 a, Vector2 b)
		{
			return new Vector2(Mathf.Min(a.x, b.x), Mathf.Min(a.y, b.y));
		}

		public static Vector2 Max(Vector2 a, Vector2 b)
		{
			return new Vector2(Mathf.Max(a.x, b.x), Mathf.Max(a.y, b.y));
		}

		public static void OrthoNormal(Vector3 foward, out Vector3 up, out Vector3 right)
		{
			if (Mathf.Abs(foward.x) < Mathf.Abs(foward.y) || Mathf.Abs(foward.x) < Mathf.Abs(foward.z))
			{
				up = Vector3.Cross(foward, new Vector3(1f, 0f, 0f));
			}
			else if (Mathf.Abs(foward.y) < Mathf.Abs(foward.z))
			{
				up = Vector3.Cross(foward, new Vector3(0f, 1f, 0f));
			}
			else
			{
				up = Vector3.Cross(foward, new Vector3(0f, 0f, 1f));
			}
			right = Vector3.Cross(foward, up);
		}

		public static Vector2? IntersectionWith(this Ray2D ray1, Ray2D ray2)
		{
			Vector2 origin = ray1.origin;
			Vector2 vector = origin + ray1.direction;
			float num = vector.y - origin.y;
			float num2 = origin.x - vector.x;
			float num3 = num * origin.x + num2 * origin.y;
			Vector2 origin2 = ray2.origin;
			Vector2 vector2 = origin2 + ray2.direction;
			float num4 = vector2.y - origin2.y;
			float num5 = origin2.x - vector2.x;
			float num6 = num4 * origin2.x + num5 * origin2.y;
			float num7 = num * num5 - num4 * num2;
			if (num7 == 0f)
			{
				return null;
			}
			num7 = 1f / num7;
			return new Vector2(num5 * num3 - num2 * num6, num * num6 - num4 * num3) * num7;
		}

		public static Vector3 V2ToV3(this Vector2 v2, float z)
		{
			return new Vector3(v2.x, v2.y, z);
		}

		public static Vector2 xz(this Vector3 v)
		{
			return new Vector2(v.x, v.z);
		}

		public static Vector3 xNy(this Vector2 v, float n = 0f)
		{
			return new Vector3(v.x, n, v.y);
		}

		public static Vector4 V2ToV4(this Vector2 v2, float z, float w)
		{
			return new Vector4(v2.x, v2.y, z, w);
		}

		public static Vector4 V3ToV4(this Vector3 v3, float w)
		{
			return new Vector4(v3.x, v3.y, v3.z, w);
		}

		public static Vector3 RepX(this Vector3 vect, float newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector3 RepY(this Vector3 vect, float newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector3 RepZ(this Vector3 vect, float newVal)
		{
			vect.z = newVal;
			return vect;
		}

		public static Vector3 RepXY(this Vector3 vect, float newX, float newY)
		{
			vect.x = newX;
			vect.y = newY;
			return vect;
		}

		public static Vector3 RepXZ(this Vector3 vect, float newX, float newZ)
		{
			vect.x = newX;
			vect.z = newZ;
			return vect;
		}

		public static Vector3 RepYZ(this Vector3 vect, float newY, float newZ)
		{
			vect.y = newY;
			vect.z = newZ;
			return vect;
		}

		public static Vector3 ScaleX(this Vector3 vect, float scale)
		{
			vect.x *= scale;
			return vect;
		}

		public static Vector3 ScaleY(this Vector3 vect, float scale)
		{
			vect.y *= scale;
			return vect;
		}

		public static Vector3 ScaleZ(this Vector3 vect, float scale)
		{
			vect.z *= scale;
			return vect;
		}

		public static Vector3 ScaleXY(this Vector3 vect, float scaleX, float scaleY)
		{
			vect.x *= scaleX;
			vect.y *= scaleY;
			return vect;
		}

		public static Vector3 ScaleXZ(this Vector3 vect, float scaleX, float scaleZ)
		{
			vect.x *= scaleX;
			vect.z *= scaleZ;
			return vect;
		}

		public static Vector3 ScaleYZ(this Vector3 vect, float scaleY, float scaleZ)
		{
			vect.y *= scaleY;
			vect.z *= scaleZ;
			return vect;
		}

		public static Vector2 RepX(this Vector2 vect, float newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector2 RepY(this Vector2 vect, float newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector2 ScaleX(this Vector2 vect, float scale)
		{
			vect.x *= scale;
			return vect;
		}

		public static Vector2 ScaleY(this Vector2 vect, float scale)
		{
			vect.y *= scale;
			return vect;
		}

		public static Vector3 ClampedToMagnitude(this Vector3 vect, float magClamp)
		{
			float num = magClamp * magClamp;
			float sqrMagnitude = vect.sqrMagnitude;
			if (sqrMagnitude > num)
			{
				return vect.normalized * magClamp;
			}
			return vect;
		}

		public static Vector2 ClampedToMagnitude(this Vector2 vect, float magClamp)
		{
			float num = magClamp * magClamp;
			float sqrMagnitude = vect.sqrMagnitude;
			if (sqrMagnitude > num)
			{
				return vect.normalized * magClamp;
			}
			return vect;
		}

		public static Vector2 Rounded(this Vector2 vect)
		{
			vect.x = Mathf.Round(vect.x);
			vect.y = Mathf.Round(vect.y);
			return vect;
		}

		public static Vector2 ClosestTo(this IList<Vector2> vects, Vector2 target)
		{
			float num = float.PositiveInfinity;
			Vector2 result = Vector2.zero;
			for (int i = 0; i < vects.Count; i++)
			{
				float sqrMagnitude = (target - vects[i]).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					result = vects[i];
					num = sqrMagnitude;
				}
			}
			return result;
		}

		public static bool IsCloseTo(this Vector2 vect, Vector2 other, float maxDist)
		{
			float num = maxDist * maxDist;
			return (vect - other).sqrMagnitude < num;
		}

		public static Vector3 V3LerpNoClamp(Vector3 from, Vector3 to, float t)
		{
			return new Vector3(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t);
		}

		public static Vector3 Reciprocal(this Vector3 vect)
		{
			vect.x = 1f / vect.x;
			vect.y = 1f / vect.y;
			vect.z = 1f / vect.z;
			return vect;
		}
	}
}
[Serializable]
[Serializer.ExcludeAllFields]
public struct v2i : Serializer.ISelfConstructor
{
	private class EQComparer : EqualityComparer<v2i>
	{
		public override bool Equals(v2i v1, v2i v2)
		{
			return v1 == v2;
		}

		public override int GetHashCode(v2i v)
		{
			return v.GetHashCode();
		}
	}

	public int x;

	public int y;

	public static readonly v2i zero = new v2i(0, 0);

	public static readonly v2i one = new v2i(1, 1);

	public static readonly v2i left = new v2i(-1, 0);

	public static readonly v2i right = new v2i(1, 0);

	public static readonly v2i up = new v2i(0, 1);

	public static readonly v2i down = new v2i(0, -1);

	public static readonly EqualityComparer<v2i> eqComparer = new EQComparer();

	public float Magnitude => Mathf.Sqrt(x * x + y * y);

	public int this[uint index]
	{
		get
		{
			return index switch
			{
				0u => x, 
				1u => y, 
				_ => int.MaxValue, 
			};
		}
		set
		{
			if (index == 0)
			{
				x = value;
			}
			if (index == 1)
			{
				y = value;
			}
		}
	}

	public v2i(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public v2i(Vector2 v)
	{
		x = (int)v.x;
		y = (int)v.y;
	}

	private v2i(BinaryReader reader)
	{
		x = reader.ReadInt32();
		y = reader.ReadInt32();
	}

	public void Deconstruct(BinaryWriter writer)
	{
		writer.Write(x);
		writer.Write(y);
	}

	public static v2i operator +(v2i lhs, v2i rhs)
	{
		return new v2i(lhs.x + rhs.x, lhs.y + rhs.y);
	}

	public static v2i operator -(v2i lhs, v2i rhs)
	{
		return new v2i(lhs.x - rhs.x, lhs.y - rhs.y);
	}

	public static v2i operator *(v2i lhs, int scalar)
	{
		return new v2i(lhs.x * scalar, lhs.y * scalar);
	}

	public static v2i operator /(v2i lhs, int scalar)
	{
		return new v2i(lhs.x / scalar, lhs.y / scalar);
	}

	public static v2i operator -(v2i v0)
	{
		return new v2i(-v0.x, -v0.y);
	}

	public static v2i operator +(v2i v0, OctDir dir)
	{
		Vector3 vector = dir.ToV3XZ();
		return new v2i(v0.x + (int)vector.x, v0.y + (int)vector.z);
	}

	public static v2i operator -(v2i v0, OctDir dir)
	{
		Vector3 vector = dir.ToV3XZ();
		return new v2i(v0.x - (int)vector.x, v0.y - (int)vector.z);
	}

	public static v2i Scale(v2i v0, v2i v1)
	{
		return new v2i(v0.x * v1.x, v0.y * v1.y);
	}

	public static v2i InvScale(v2i v0, v2i v1)
	{
		return new v2i(v0.x / v1.x, v0.y / v1.y);
	}

	public static Vector2 InvScaleFloat(v2i v0, v2i v1)
	{
		return new Vector2((float)v0.x / (float)v1.x, (float)v0.y / (float)v1.y);
	}

	public static v2i Min(v2i v0, v2i v1)
	{
		return new v2i(Math.Min(v0.x, v1.x), Math.Min(v0.y, v1.y));
	}

	public static v2i Max(v2i v0, v2i v1)
	{
		return new v2i(Math.Max(v0.x, v1.x), Math.Max(v0.y, v1.y));
	}

	public static int Dot(v2i v0, v2i v1)
	{
		return v0.x * v1.x + v0.y * v1.y;
	}

	public static int DistanceSqr(v2i v0, v2i v1)
	{
		v2i v2i2 = v0 - v1;
		return Dot(v2i2, v2i2);
	}

	public static float Distance(v2i v0, v2i v1)
	{
		if (v0 == v1)
		{
			return 0f;
		}
		v2i v2i2 = v0 - v1;
		return Mathf.Sqrt(Dot(v2i2, v2i2));
	}

	public static int ManhattanDistance(v2i v0, v2i v1)
	{
		return Mathf.Abs(v0.x - v1.x) + Mathf.Abs(v0.y - v1.y);
	}

	public static bool IsNeighbour(v2i v0, v2i v1)
	{
		v2i v2i2 = v0 - v1;
		return v2i2.x >= -1 && v2i2.x <= 1 && v2i2.y >= -1 && v2i2.y <= 1;
	}

	public static v2i Normalize(v2i dir)
	{
		if (dir == zero)
		{
			return dir;
		}
		float num = Mathf.Sqrt(Dot(dir, dir));
		v2i result = default(v2i);
		result.x = (int)((float)dir.x / num);
		result.y = (int)((float)dir.y / num);
		return result;
	}

	public static v2i DirectionXZ(Vector3 direction)
	{
		v2i result = default(v2i);
		result.x = ((Mathf.Abs(direction.x) > 0.35355338f) ? ((direction.x > 0f) ? 1 : (-1)) : 0);
		result.y = ((Mathf.Abs(direction.z) > 0.35355338f) ? ((direction.z > 0f) ? 1 : (-1)) : 0);
		return result;
	}

	public static Vector3 DirectionXZ(v2i direction)
	{
		return new Vector3(direction.x, 0f, direction.y).normalized;
	}

	public static bool operator ==(v2i lhs, v2i rhs)
	{
		if (lhs.x != rhs.x)
		{
			return false;
		}
		if (lhs.y != rhs.y)
		{
			return false;
		}
		return true;
	}

	public static bool operator !=(v2i lhs, v2i rhs)
	{
		return !(lhs == rhs);
	}

	public v2i SimpleClamped(float newMaxMag)
	{
		float num = x;
		float num2 = y;
		float num3 = num * num + num2 * num2;
		if (num3 <= newMaxMag * newMaxMag)
		{
			return this;
		}
		float num4 = newMaxMag / Mathf.Sqrt(num3);
		return new v2i(Mathf.FloorToInt(num * num4), Mathf.FloorToInt(num2 * num4));
	}

	public override string ToString()
	{
		return "{" + x + ", " + y + "}";
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return false;
		}
		if (!(obj is v2i v2i2))
		{
			return false;
		}
		return base.Equals(obj) && this == v2i2;
	}

	public override int GetHashCode()
	{
		int num = 1;
		num = 31 * num + x;
		return 31 * num + y;
	}
}
public static class SVN
{
	public struct Info
	{
		private static readonly char[] lineSplit = new char[1] { ':' };

		public readonly string path;

		public readonly string workingCopyRootPath;

		public readonly string url;

		public readonly string relativeUrl;

		public readonly string repositoryRoot;

		public readonly string repositoryRootUUID;

		public readonly int revision;

		public readonly string nodeKind;

		public readonly string schedule;

		public readonly string lastChangedAuthor;

		public readonly int lastChangedRevision;

		public readonly string lastChangedDate;

		public Info(string svnInfoOutput)
		{
			path = string.Empty;
			workingCopyRootPath = string.Empty;
			url = string.Empty;
			relativeUrl = string.Empty;
			repositoryRoot = string.Empty;
			repositoryRootUUID = string.Empty;
			revision = -1;
			nodeKind = string.Empty;
			schedule = string.Empty;
			lastChangedAuthor = string.Empty;
			lastChangedRevision = -1;
			lastChangedDate = string.Empty;
			string[] array = svnInfoOutput.Split('\n');
			foreach (string text in array)
			{
				string[] array2 = text.Split(lineSplit, 2);
				if (array2.Length == 2)
				{
					array2[0] = array2[0].Trim();
					array2[1] = array2[1].Trim();
					switch (array2[0])
					{
					case "Path":
						path = array2[1];
						break;
					case "Working Copy Root Path":
						workingCopyRootPath = array2[1];
						break;
					case "URL":
						url = array2[1];
						break;
					case "Relative URL":
						relativeUrl = array2[1];
						break;
					case "Repository Root":
						repositoryRoot = array2[1];
						break;
					case "Repository UUID":
						repositoryRootUUID = array2[1];
						break;
					case "Revision":
						revision = int.Parse(array2[1]);
						break;
					case "Node Kind":
						nodeKind = array2[1];
						break;
					case "Schedule":
						schedule = array2[1];
						break;
					case "Last Changed Author":
						lastChangedAuthor = array2[1];
						break;
					case "Last Changed Rev":
						lastChangedRevision = int.Parse(array2[1]);
						break;
					case "Last Changed Date":
						lastChangedDate = array2[1];
						break;
					}
				}
			}
		}
	}

	public static readonly bool supported;

	static SVN()
	{
		supported = ShellCommand.Exists("svn");
	}

	public static string RunSVNCommand(string command, string args, int timeoutMS = int.MaxValue)
	{
		try
		{
			ProcessStartInfo processStartInfo = new ProcessStartInfo("svn", $"{command} {args}");
			processStartInfo.RedirectStandardOutput = true;
			processStartInfo.RedirectStandardError = true;
			processStartInfo.UseShellExecute = false;
			processStartInfo.CreateNoWindow = true;
			Process process = new Process();
			process.StartInfo = processStartInfo;
			process.Start();
			string result = null;
			if (process.WaitForExit(timeoutMS))
			{
				result = process.StandardOutput.ReadToEnd();
			}
			else
			{
				process.Kill();
			}
			return result;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
		}
		return null;
	}

	public static Info GetInfo(string path)
	{
		return new Info(RunSVNCommand("info", $"\"{path}\""));
	}

	public static bool NeedsLock(string path)
	{
		string text = RunSVNCommand("propget", $"svn:needs-lock \"{path}\"");
		return text != null && text.Length > 0;
	}

	public static string Lock(params string[] paths)
	{
		return RunSVNCommand("lock", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static string Unlock(params string[] paths)
	{
		return RunSVNCommand("unlock", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static string Delete(params string[] paths)
	{
		return RunSVNCommand("delete", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static Dictionary<string, string> SVNInfo()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string text = ShellCommand.ExecuteSyncNoException("svn", "info \"" + UnityEngine.Application.dataPath + "\\..\"");
		string[] array = text.Split('\n');
		foreach (string text2 in array)
		{
			string[] array2 = text2.Split(new char[1] { ':' }, 2);
			if (array2.Length == 2)
			{
				dictionary.Add(array2[0].Trim(), array2[1].Trim());
			}
		}
		return dictionary;
	}
}
public static class TortoiseSVN
{
	public static readonly bool supported;

	static TortoiseSVN()
	{
		supported = ShellCommand.Exists("tortoiseproc");
	}

	public static void Lock(params string[] paths)
	{
		ShellCommand.ExecuteSync("tortoiseproc", $"/command:lock /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Unlock(params string[] paths)
	{
		ShellCommand.ExecuteSync("tortoiseproc", $"/command:unlock /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Update(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:update /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Log(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:log /path:\"{ToPathArgumentValue(paths)}\"");
	}

	private static string ToPathArgumentValue(params string[] paths)
	{
		return string.Join("*", paths);
	}
}
public class EmptyBehaviour : MonoBehaviour
{
}
namespace Coatsink.Common
{
	public static class Paths
	{
		private static StringBuilder builder;

		public static void Init(int capacity = 256, int maxCapacity = 512, bool overwrite = false)
		{
			if (builder == null || overwrite)
			{
				builder = new StringBuilder(capacity, maxCapacity);
			}
		}

		public static void Cleanup()
		{
			builder = null;
		}

		public static string Make(string seg1, string seg2, string seg3 = null, string seg4 = null, string seg5 = null, string seg6 = null, string seg7 = null)
		{
			Init();
			AppendSegment(seg1, seg2);
			AppendSegment(seg2, seg3);
			AppendSegment(seg3, seg4);
			AppendSegment(seg4, seg5);
			AppendSegment(seg5, seg6);
			AppendSegment(seg6, appendSeparator: false);
			return FinishMake();
		}

		public static string Make(IEnumerable<string> segs)
		{
			Init();
			IEnumerator<string> enumerator = segs.GetEnumerator();
			bool flag = enumerator.MoveNext();
			while (flag)
			{
				string current = enumerator.Current;
				flag = enumerator.MoveNext();
				string current2 = enumerator.Current;
				AppendSegment(current, flag && !string.IsNullOrEmpty(current2));
			}
			return FinishMake();
		}

		public static string Make(IList<string> segs)
		{
			Init();
			int num = -1;
			int count = segs.Count;
			int num2 = count - 1;
			while (++num < count)
			{
				AppendSegment(segs[num], num < num2 && !string.IsNullOrEmpty(segs[num + 1]));
			}
			return FinishMake();
		}

		public static string ToAltPath(this string path)
		{
			return path.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
		}

		public static string GetScenePath(this GameObject gameObject, bool includeSelf = true)
		{
			if (gameObject == null)
			{
				return null;
			}
			Init();
			PrependSegment((!includeSelf) ? gameObject.transform.parent : gameObject.transform);
			return FinishMake();
		}

		public static string GetAnimationPath(this GameObject gameObject)
		{
			Transform transform = gameObject.transform;
			string text;
			if (transform.GetComponent<Animation>() != null)
			{
				text = "/";
			}
			else
			{
				text = transform.name;
				transform = transform.parent;
				while (transform != null)
				{
					Animation component = transform.GetComponent<Animation>();
					if (component == null)
					{
						text = transform.name + "/" + text;
						transform = transform.parent;
						continue;
					}
					break;
				}
			}
			return text;
		}

		public static List<string> GetFilesInDirectoryWithFilter(string dir, string filter)
		{
			List<string> list = new List<string>();
			list.AddRange(Directory.GetFiles(dir, filter));
			string[] directories = Directory.GetDirectories(dir);
			string[] array = directories;
			foreach (string dir2 in array)
			{
				list.AddRange(GetFilesInDirectoryWithFilter(dir2, filter));
			}
			return list;
		}

		private static void AppendSegment(string segment, bool appendSeparator = true)
		{
			if (!string.IsNullOrEmpty(segment))
			{
				int capacity = builder.Capacity;
				builder.Append(segment);
				if (appendSeparator)
				{
					builder.Append(Path.AltDirectorySeparatorChar);
				}
				if (builder.Capacity != capacity)
				{
					UnityEngine.Debug.LogWarningFormat("Coatsink.Common.Paths.builder had to increase its capacity from {0} to {1}.", capacity, builder.Capacity);
				}
			}
		}

		private static void AppendSegment(string segment, string nextSegment)
		{
			AppendSegment(segment, !string.IsNullOrEmpty(nextSegment));
		}

		private static void PrependSegment(Transform tform)
		{
			if (tform.parent != null)
			{
				PrependSegment(tform.parent);
			}
			builder.Append(Path.AltDirectorySeparatorChar);
			builder.Append(tform.name);
		}

		private static string FinishMake()
		{
			string result = builder.ToString();
			builder.Remove(0, builder.Length);
			return result;
		}
	}
}
public class PlayerPrefsX
{
	private enum ArrayType
	{
		Float,
		Int32,
		Bool,
		String,
		Vector2,
		Vector3,
		Quaternion,
		Color
	}

	private static int endianDiff1;

	private static int endianDiff2;

	private static int idx;

	private static byte[] byteBlock;

	public static bool SetBool(string name, bool value)
	{
		try
		{
			PlayerPrefs.SetInt(name, value ? 1 : 0);
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static bool GetBool(string name)
	{
		return PlayerPrefs.GetInt(name) == 1;
	}

	public static bool GetBool(string name, bool defaultValue)
	{
		if (PlayerPrefs.HasKey(name))
		{
			return GetBool(name);
		}
		return defaultValue;
	}

	public static bool SetVector2(string key, Vector2 vector)
	{
		return SetFloatArray(key, new float[2] { vector.x, vector.y });
	}

	private static Vector2 GetVector2(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 2)
		{
			return Vector2.zero;
		}
		return new Vector2(floatArray[0], floatArray[1]);
	}

	public static Vector2 GetVector2(string key, Vector2 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2(key);
		}
		return defaultValue;
	}

	public static bool SetVector3(string key, Vector3 vector)
	{
		return SetFloatArray(key, new float[3] { vector.x, vector.y, vector.z });
	}

	public static Vector3 GetVector3(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 3)
		{
			return Vector3.zero;
		}
		return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
	}

	public static Vector3 GetVector3(string key, Vector3 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3(key);
		}
		return defaultValue;
	}

	public static bool SetQuaternion(string key, Quaternion vector)
	{
		return SetFloatArray(key, new float[4] { vector.x, vector.y, vector.z, vector.w });
	}

	public static Quaternion GetQuaternion(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return Quaternion.identity;
		}
		return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Quaternion GetQuaternion(string key, Quaternion defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternion(key);
		}
		return defaultValue;
	}

	public static bool SetColor(string key, Color color)
	{
		return SetFloatArray(key, new float[4] { color.r, color.g, color.b, color.a });
	}

	public static Color GetColor(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return new Color(0f, 0f, 0f, 0f);
		}
		return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Color GetColor(string key, Color defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColor(key);
		}
		return defaultValue;
	}

	public static bool SetBoolArray(string key, bool[] boolArray)
	{
		if (boolArray.Length == 0)
		{
			UnityEngine.Debug.LogError("The bool array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array = new byte[(boolArray.Length + 7) / 8 + 5];
		array[0] = Convert.ToByte(ArrayType.Bool);
		BitArray bitArray = new BitArray(boolArray);
		bitArray.CopyTo(array, 5);
		Initialize();
		ConvertInt32ToBytes(boolArray.Length, array);
		return SaveBytes(key, array);
	}

	public static bool[] GetBoolArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
			if (array.Length < 6)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new bool[0];
			}
			if (array[0] != 2)
			{
				UnityEngine.Debug.LogError(key + " is not a boolean array");
				return new bool[0];
			}
			Initialize();
			byte[] array2 = new byte[array.Length - 5];
			Array.Copy(array, 5, array2, 0, array2.Length);
			BitArray bitArray = new BitArray(array2);
			bitArray.Length = ConvertBytesToInt32(array);
			bool[] array3 = new bool[bitArray.Count];
			bitArray.CopyTo(array3, 0);
			return array3;
		}
		return new bool[0];
	}

	public static bool[] GetBoolArray(string key, bool defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetBoolArray(key);
		}
		bool[] array = new bool[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetStringArray(string key, string[] stringArray)
	{
		if (stringArray.Length == 0)
		{
			UnityEngine.Debug.LogError("The string array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array = new byte[stringArray.Length + 1];
		array[0] = Convert.ToByte(ArrayType.String);
		Initialize();
		for (int i = 0; i < stringArray.Length; i++)
		{
			if (stringArray[i] == null)
			{
				UnityEngine.Debug.LogError("Can't save null entries in the string array when setting " + key);
				return false;
			}
			if (stringArray[i].Length > 255)
			{
				UnityEngine.Debug.LogError("Strings cannot be longer than 255 characters when setting " + key);
				return false;
			}
			array[idx++] = (byte)stringArray[i].Length;
		}
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(array) + "|" + string.Join(string.Empty, stringArray));
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static string[] GetStringArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			string @string = PlayerPrefs.GetString(key);
			int num = @string.IndexOf("|"[0]);
			if (num < 4)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new string[0];
			}
			byte[] array = Convert.FromBase64String(@string.Substring(0, num));
			if (array[0] != 3)
			{
				UnityEngine.Debug.LogError(key + " is not a string array");
				return new string[0];
			}
			Initialize();
			int num2 = array.Length - 1;
			string[] array2 = new string[num2];
			int num3 = num + 1;
			for (int i = 0; i < num2; i++)
			{
				int num4 = array[idx++];
				if (num3 + num4 > @string.Length)
				{
					UnityEngine.Debug.LogError("Corrupt preference file for " + key);
					return new string[0];
				}
				array2[i] = @string.Substring(num3, num4);
				num3 += num4;
			}
			return array2;
		}
		return new string[0];
	}

	public static string[] GetStringArray(string key, string defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetStringArray(key);
		}
		string[] array = new string[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetIntArray(string key, int[] intArray)
	{
		return SetValue(key, intArray, ArrayType.Int32, 1, ConvertFromInt);
	}

	public static bool SetFloatArray(string key, float[] floatArray)
	{
		return SetValue(key, floatArray, ArrayType.Float, 1, ConvertFromFloat);
	}

	public static bool SetVector2Array(string key, Vector2[] vector2Array)
	{
		return SetValue(key, vector2Array, ArrayType.Vector2, 2, ConvertFromVector2);
	}

	public static bool SetVector3Array(string key, Vector3[] vector3Array)
	{
		return SetValue(key, vector3Array, ArrayType.Vector3, 3, ConvertFromVector3);
	}

	public static bool SetQuaternionArray(string key, Quaternion[] quaternionArray)
	{
		return SetValue(key, quaternionArray, ArrayType.Quaternion, 4, ConvertFromQuaternion);
	}

	public static bool SetColorArray(string key, Color[] colorArray)
	{
		return SetValue(key, colorArray, ArrayType.Color, 4, ConvertFromColor);
	}

	private static bool SetValue<T>(string key, T array, ArrayType arrayType, int vectorNumber, Action<T, byte[], int> convert) where T : IList
	{
		if (array.Count == 0)
		{
			UnityEngine.Debug.LogError("The " + arrayType.ToString() + " array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array2 = new byte[4 * array.Count * vectorNumber + 1];
		array2[0] = Convert.ToByte(arrayType);
		Initialize();
		for (int i = 0; i < array.Count; i++)
		{
			convert(array, array2, i);
		}
		return SaveBytes(key, array2);
	}

	private static void ConvertFromInt(int[] array, byte[] bytes, int i)
	{
		ConvertInt32ToBytes(array[i], bytes);
	}

	private static void ConvertFromFloat(float[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i], bytes);
	}

	private static void ConvertFromVector2(Vector2[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
	}

	private static void ConvertFromVector3(Vector3[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
	}

	private static void ConvertFromQuaternion(Quaternion[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
		ConvertFloatToBytes(array[i].w, bytes);
	}

	private static void ConvertFromColor(Color[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].r, bytes);
		ConvertFloatToBytes(array[i].g, bytes);
		ConvertFloatToBytes(array[i].b, bytes);
		ConvertFloatToBytes(array[i].a, bytes);
	}

	public static int[] GetIntArray(string key)
	{
		List<int> list = new List<int>();
		GetValue(key, list, ArrayType.Int32, 1, ConvertToInt);
		return list.ToArray();
	}

	public static int[] GetIntArray(string key, int defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetIntArray(key);
		}
		int[] array = new int[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static float[] GetFloatArray(string key)
	{
		List<float> list = new List<float>();
		GetValue(key, list, ArrayType.Float, 1, ConvertToFloat);
		return list.ToArray();
	}

	public static float[] GetFloatArray(string key, float defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetFloatArray(key);
		}
		float[] array = new float[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector2[] GetVector2Array(string key)
	{
		List<Vector2> list = new List<Vector2>();
		GetValue(key, list, ArrayType.Vector2, 2, ConvertToVector2);
		return list.ToArray();
	}

	public static Vector2[] GetVector2Array(string key, Vector2 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2Array(key);
		}
		Vector2[] array = new Vector2[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector3[] GetVector3Array(string key)
	{
		List<Vector3> list = new List<Vector3>();
		GetValue(key, list, ArrayType.Vector3, 3, ConvertToVector3);
		return list.ToArray();
	}

	public static Vector3[] GetVector3Array(string key, Vector3 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3Array(key);
		}
		Vector3[] array = new Vector3[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Quaternion[] GetQuaternionArray(string key)
	{
		List<Quaternion> list = new List<Quaternion>();
		GetValue(key, list, ArrayType.Quaternion, 4, ConvertToQuaternion);
		return list.ToArray();
	}

	public static Quaternion[] GetQuaternionArray(string key, Quaternion defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternionArray(key);
		}
		Quaternion[] array = new Quaternion[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Color[] GetColorArray(string key)
	{
		List<Color> list = new List<Color>();
		GetValue(key, list, ArrayType.Color, 4, ConvertToColor);
		return list.ToArray();
	}

	public static Color[] GetColorArray(string key, Color defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColorArray(key);
		}
		Color[] array = new Color[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	private static void GetValue<T>(string key, T list, ArrayType arrayType, int vectorNumber, Action<T, byte[]> convert) where T : IList
	{
		if (!PlayerPrefs.HasKey(key))
		{
			return;
		}
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if ((array.Length - 1) % (vectorNumber * 4) != 0)
		{
			UnityEngine.Debug.LogError("Corrupt preference file for " + key);
			return;
		}
		if ((ArrayType)array[0] != arrayType)
		{
			UnityEngine.Debug.LogError(key + " is not a " + arrayType.ToString() + " array");
			return;
		}
		Initialize();
		int num = (array.Length - 1) / (vectorNumber * 4);
		for (int i = 0; i < num; i++)
		{
			convert(list, array);
		}
	}

	private static void ConvertToInt(List<int> list, byte[] bytes)
	{
		list.Add(ConvertBytesToInt32(bytes));
	}

	private static void ConvertToFloat(List<float> list, byte[] bytes)
	{
		list.Add(ConvertBytesToFloat(bytes));
	}

	private static void ConvertToVector2(List<Vector2> list, byte[] bytes)
	{
		list.Add(new Vector2(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToVector3(List<Vector3> list, byte[] bytes)
	{
		list.Add(new Vector3(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToQuaternion(List<Quaternion> list, byte[] bytes)
	{
		list.Add(new Quaternion(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToColor(List<Color> list, byte[] bytes)
	{
		list.Add(new Color(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	public static void ShowArrayType(string key)
	{
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if (array.Length > 0)
		{
			ArrayType arrayType = (ArrayType)array[0];
			UnityEngine.Debug.Log(key + " is a " + arrayType.ToString() + " array");
		}
	}

	private static void Initialize()
	{
		if (BitConverter.IsLittleEndian)
		{
			endianDiff1 = 0;
			endianDiff2 = 0;
		}
		else
		{
			endianDiff1 = 3;
			endianDiff2 = 1;
		}
		if (byteBlock == null)
		{
			byteBlock = new byte[4];
		}
		idx = 1;
	}

	private static bool SaveBytes(string key, byte[] bytes)
	{
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(bytes));
		}
		catch
		{
			return false;
		}
		return true;
	}

	private static void ConvertFloatToBytes(float f, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(f);
		ConvertTo4Bytes(bytes);
	}

	private static float ConvertBytesToFloat(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToSingle(byteBlock, 0);
	}

	private static void ConvertInt32ToBytes(int i, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(i);
		ConvertTo4Bytes(bytes);
	}

	private static int ConvertBytesToInt32(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToInt32(byteBlock, 0);
	}

	private static void ConvertTo4Bytes(byte[] bytes)
	{
		bytes[idx] = byteBlock[endianDiff1];
		bytes[idx + 1] = byteBlock[1 + endianDiff2];
		bytes[idx + 2] = byteBlock[2 - endianDiff2];
		bytes[idx + 3] = byteBlock[3 - endianDiff1];
		idx += 4;
	}

	private static void ConvertFrom4Bytes(byte[] bytes)
	{
		byteBlock[endianDiff1] = bytes[idx];
		byteBlock[1 + endianDiff2] = bytes[idx + 1];
		byteBlock[2 - endianDiff2] = bytes[idx + 2];
		byteBlock[3 - endianDiff1] = bytes[idx + 3];
		idx += 4;
	}
}
namespace Coatsink.Common
{
	public static class SaveLoad
	{
		public class DispatchRunner : MonoBehaviour
		{
			private void Update()
			{
				RunDispatch();
			}
		}

		public delegate void ResultHandler(Result result);

		[Flags]
		public enum Result
		{
			None = 0,
			Pending = 1,
			Init = 2,
			Metadata = 4,
			Save = 8,
			Load = 0x10,
			Delete = 0x20,
			Success = 0x40,
			Failure = 0x80,
			Busy = 0x100,
			Subsystem = 0x200,
			MissingData = 0x400,
			CorruptedData = 0x800,
			InsufficientSpace = 0x1000,
			Cancelled = 0x2000
		}

		public struct DataHeader
		{
			public string title;

			public string subtitle;

			public string details;

			[NonSerialized]
			public Texture2D icon;

			[SerializeField]
			private byte[] _iconData;

			public byte[] iconData
			{
				get
				{
					return _iconData;
				}
				set
				{
					_iconData = value;
				}
			}

			public DataHeader(string title = null, string subtitle = null, string details = null, Texture2D icon = null)
			{
				this.title = title;
				this.subtitle = subtitle;
				this.details = details;
				this.icon = icon;
				_iconData = null;
			}

			public void EncodeIcon()
			{
				_iconData = ((!(icon != null)) ? null : icon.EncodeToPNG());
			}

			public void DecodeIcon()
			{
				if (_iconData == null)
				{
					icon = null;
					return;
				}
				icon = new Texture2D(0, 0);
				bool flag = icon.LoadImage(_iconData);
				_iconData = null;
				if (flag)
				{
					return;
				}
				throw new FormatException();
			}
		}

		public struct Metadata
		{
			public bool exists;

			public DataHeader header;

			public DateTime saveTime;
		}

		private const int kMetadataSlot = -1;

		private static int retentions;

		private static int slotQty;

		private static volatile ResultHandler handleResult;

		private static volatile Metadata[] metadata;

		private static volatile int slot;

		private static volatile object dataObject;

		private static volatile bool silent;

		private static volatile bool log;

		public static volatile byte[] streamBuffer;

		public static volatile Stream outStream;

		public static readonly string folderName = "Save Data";

		public static Func<bool> fakeMetadataFailureFunc;

		public static Func<bool> fakeSaveFailureFunc;

		public static Func<bool> fakeSaveSuccessFunc;

		public static Func<bool> fakeLoadFailureFunc;

		public static Func<bool> fakeMissingDataFunc;

		public static Func<bool> fakeDeleteFailureFunc;

		private static string folderPath;

		private static string[] filePaths;

		private static volatile string title;

		private static volatile string subtitle;

		private static volatile string details;

		private static volatile Texture2D icon;

		private static volatile byte[] iconData;

		private static Thread thread;

		private static AutoResetEvent signalToThread;

		private static AutoResetEvent signalToDispatchRoutine;

		private static volatile Result threadFlags;

		private static BinaryReader[] fileReaders;

		private static BinaryWriter[] fileWriters;

		public static bool initialised => retentions > 0;

		public static bool busy { get; private set; }

		public static bool fakeMetadataFailure => fakeMetadataFailureFunc != null && fakeMetadataFailureFunc();

		public static bool fakeSaveFailure => fakeSaveFailureFunc != null && fakeSaveFailureFunc();

		public static bool fakeSaveSuccess => fakeSaveSuccessFunc != null && fakeSaveSuccessFunc();

		public static bool fakeLoadFailure => fakeLoadFailureFunc != null && fakeLoadFailureFunc();

		public static bool fakeMissingData => fakeMissingDataFunc != null && fakeMissingDataFunc();

		public static bool fakeDeleteFailure => fakeDeleteFailureFunc != null && fakeDeleteFailureFunc();

		public static Result Retain(int slotQty = 1, ResultHandler handleResultIn = null, bool unthreaded = false, bool silent = false, bool log = false, string basePath = null)
		{
			if (slotQty < 1 || slotQty > 10)
			{
				throw new ArgumentOutOfRangeException("slotQtyIn");
			}
			if (retentions++ > 0 || busy)
			{
				return Dispatch(Result.Init | Result.Success, handleResultIn);
			}
			try
			{
				Serializer.Retain(silent);
				SubInit(slotQty, basePath, unthreaded);
				SaveLoad.slotQty = slotQty;
				streamBuffer = new byte[4096];
				if (!silent)
				{
					UnityEngine.Debug.Log("SaveLoad initialised.");
				}
				if (fakeMetadataFailure)
				{
					Release();
					return Dispatch(Result.Init | Result.Metadata | Result.Failure | Result.Subsystem, handleResultIn);
				}
				return SubInitMetadata(handleResultIn, unthreaded, silent, log);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				Release(silent);
				return Dispatch(Result.Init | Result.Metadata | Result.Failure | Result.Subsystem, handleResultIn);
			}
		}

		public static void Release(bool silent = false)
		{
			if (retentions == 0)
			{
				UnityEngine.Debug.LogError("SaveLoad over-released!");
			}
			else if (--retentions <= 0)
			{
				metadata = null;
				SubRelease();
				Serializer.Release(silent);
				slotQty = 0;
				streamBuffer = null;
				busy = false;
				if (!silent)
				{
					UnityEngine.Debug.Log("SaveLoad cleaned up.");
				}
			}
		}

		public static void ResetMetadata()
		{
			ValidateUsage();
			metadata = new Metadata[slotQty];
		}

		public static bool GetMetadata(ref Metadata metadataOut, int slot = 0)
		{
			ValidateUsage(slot);
			if (metadata == null)
			{
				return false;
			}
			if (!metadata[slot].exists)
			{
				return false;
			}
			metadataOut = metadata[slot];
			return true;
		}

		public static bool DataSavedInSlot(int slot = 0)
		{
			try
			{
				ValidateUsage();
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
				return false;
			}
			return metadata[slot].exists;
		}

		public static Result Save(DataHeader header, object dataObject, ResultHandler handleResult = null, int slot = 0, bool unthreaded = false, bool silent = false, bool log = false)
		{
			if (dataObject == null)
			{
				throw new ArgumentNullException("dataObjectIn");
			}
			ValidateUsage(slot);
			if (fakeSaveSuccess)
			{
				return Dispatch(Result.Save | Result.Success, handleResult);
			}
			if (fakeSaveFailure)
			{
				return Dispatch(Result.Save | Result.Failure | Result.Subsystem, handleResult);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubSave(header, dataObject, handleResult, slot, unthreaded, silent, log);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(Result.Save | Result.Failure | Result.Subsystem, handleResult);
			}
		}

		public static Result Load(ResultHandler handleResult = null, int slot = 0, Stream outStream = null, bool unthreaded = false, bool silent = false, bool log = false)
		{
			ValidateUsage(slot);
			if (fakeMissingData)
			{
				return Dispatch(Result.Load | Result.Failure | Result.MissingData, handleResult);
			}
			if (fakeLoadFailure)
			{
				return Dispatch(Result.Load | Result.Failure | Result.Subsystem, handleResult);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubLoad(handleResult, slot, outStream, unthreaded, silent, log);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(Result.Load | Result.Failure | Result.Subsystem, handleResult);
			}
		}

		public static Result Delete(ResultHandler handleResultIn = null, int slot = 0, bool unthreaded = false, bool silent = false, bool log = false)
		{
			ValidateUsage(slot);
			if (fakeDeleteFailure)
			{
				return Dispatch(Result.Delete | Result.Failure | Result.Subsystem, handleResultIn);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubDelete(handleResultIn, slot, unthreaded, silent, log);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(Result.Delete | Result.Failure | Result.Subsystem, handleResultIn);
			}
		}

		public static T GetAndClearLastLoadedObject<T>() where T : class
		{
			if (dataObject == null)
			{
				return (T)null;
			}
			if (!(dataObject is T result))
			{
				return (T)null;
			}
			dataObject = null;
			return result;
		}

		public static bool Is(this Result result, Result check1, Result check2 = Result.None, Result check3 = Result.None)
		{
			return (result & (check1 | check2 | check3)) != 0;
		}

		public static bool ResultedIn(this Result result, Result check1, Result check2 = Result.None, Result check3 = Result.None)
		{
			return result.Is(check1, check2, check3);
		}

		public static bool Succeeded(this Result result)
		{
			return result.Is(Result.Success);
		}

		public static bool IsSuccess(this Result result)
		{
			return result.Is(Result.Success);
		}

		public static bool Failed(this Result result)
		{
			return result.Is(Result.Failure);
		}

		public static bool IsFailure(this Result result)
		{
			return result.Is(Result.Failure);
		}

		public static bool IsCorrupted(this Result result)
		{
			return result.Is(Result.Failure) && !result.Is(Result.MissingData);
		}

		public static bool IsPending(this Result result)
		{
			return result.Is(Result.Pending);
		}

		public static bool IsNone(this Result result)
		{
			return result == Result.None;
		}

		public static bool Exists(this Result result)
		{
			return !result.IsPending() && !result.IsNone();
		}

		public static bool DidNotComplete(this Result result)
		{
			return result.Is(Result.Pending);
		}

		public static bool WillCompleteLater(this Result result)
		{
			return result.Is(Result.Pending);
		}

		public static bool Completed(this Result result)
		{
			return !result.IsPending() && !result.IsNone();
		}

		private static void ValidateUsage(int slot = 0)
		{
			if (!initialised)
			{
				throw new InvalidOperationException("SaveLoad must be initialised before use.");
			}
			if (busy)
			{
				throw new InvalidOperationException("SaveLoad is busy.");
			}
			if (slot < 0 || slot >= slotQty)
			{
				throw new ArgumentOutOfRangeException("slot");
			}
		}

		private static Result Dispatch(Result result, ResultHandler handleResult = null)
		{
			if (handleResult != null)
			{
				handleResult(result);
			}
			else if (SaveLoad.handleResult != null)
			{
				ResultHandler resultHandler = SaveLoad.handleResult;
				SaveLoad.handleResult = null;
				resultHandler(result);
			}
			return result;
		}

		private static void SubInit(int slotQty, string basePath, bool unthreaded)
		{
			try
			{
				folderPath = Paths.Make(basePath, folderName);
				Directory.CreateDirectory(folderPath);
				filePaths = new string[slotQty + 1];
				fileReaders = new BinaryReader[filePaths.Length];
				fileWriters = new BinaryWriter[filePaths.Length];
				filePaths[0] = Paths.Make(folderPath, "Meta");
				int num = -1;
				while (++num < slotQty)
				{
					filePaths[num + 1] = Paths.Make(folderPath, "Slot" + (num + 1));
				}
				for (int i = 0; i < filePaths.Length; i++)
				{
					fileWriters[i] = new BinaryWriter(new FileStream(filePaths[i], FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read));
					fileReaders[i] = new BinaryReader(new FileStream(filePaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite));
				}
				if (!unthreaded)
				{
					signalToThread = new AutoResetEvent(initialState: false);
					signalToDispatchRoutine = new AutoResetEvent(initialState: false);
					thread = new Thread(Thread);
					thread.Name = "SaveLoad Worker Thread";
					thread.IsBackground = true;
					thread.Start();
				}
			}
			catch (Exception ex)
			{
				SubRelease();
				UnityEngine.Debug.LogException(ex);
				throw ex;
			}
		}

		private static void SubRelease()
		{
			if (fileReaders != null)
			{
				BinaryReader[] array = fileReaders;
				foreach (BinaryReader binaryReader in array)
				{
					try
					{
						binaryReader?.Close();
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
			if (fileWriters != null)
			{
				BinaryWriter[] array2 = fileWriters;
				foreach (BinaryWriter binaryWriter in array2)
				{
					try
					{
						binaryWriter?.Close();
					}
					catch (Exception exception2)
					{
						UnityEngine.Debug.LogException(exception2);
					}
				}
			}
			if (thread != null)
			{
				thread.Abort();
			}
			folderPath = null;
			fileReaders = null;
			fileWriters = null;
			filePaths = null;
			signalToThread = null;
			signalToDispatchRoutine = null;
			thread = null;
		}

		private static Result SubInitMetadata(ResultHandler handleResultIn, bool unthreaded, bool silent, bool log)
		{
			if (unthreaded)
			{
				Result result = ImmediateInitMetadata(silent, log);
				if (result.IsSuccess())
				{
					try
					{
						DecodeAllIcons();
					}
					catch
					{
						metadata = null;
						result = Result.Init | Result.Metadata | Result.Failure | Result.CorruptedData;
					}
				}
				return Dispatch(result, handleResultIn);
			}
			return SendToThread(Result.Metadata, handleResultIn, -1, silent, log);
		}

		private static Result SubSave(DataHeader header, object dataObject, ResultHandler handleResult, int slot, bool unthreaded, bool silent, bool log)
		{
			header.EncodeIcon();
			if (unthreaded)
			{
				return Dispatch(ImmediateSave(header.title, header.subtitle, header.details, header.icon, header.iconData, dataObject, slot, silent, log), handleResult);
			}
			title = header.title;
			subtitle = header.subtitle;
			details = header.details;
			icon = header.icon;
			iconData = header.iconData;
			SaveLoad.dataObject = dataObject;
			return SendToThread(Result.Save, handleResult, slot, silent, log);
		}

		private static Result SubLoad(ResultHandler handleResult, int slot, Stream outStream, bool unthreaded, bool silent, bool log)
		{
			if (unthreaded)
			{
				return Dispatch(ImmediateLoad(slot, outStream, silent, log), handleResult);
			}
			SaveLoad.outStream = outStream;
			return SendToThread(Result.Load, handleResult, slot, silent, log);
		}

		private static Result SubDelete(ResultHandler handleResultIn, int slotIn, bool unthreaded, bool silent, bool log)
		{
			if (unthreaded)
			{
				return Dispatch(ImmediateDelete(slotIn, silent, log), handleResultIn);
			}
			return SendToThread(Result.Delete, handleResultIn, slotIn, silent, log);
		}

		private static BinaryReader PrepareReader(int slotIdx)
		{
			slotIdx++;
			fileReaders[slotIdx].BaseStream.Position = 0L;
			return fileReaders[slotIdx];
		}

		private static BinaryWriter PrepareWriter(int slotIdx)
		{
			slotIdx++;
			fileWriters[slotIdx].Seek(0, SeekOrigin.Begin);
			return fileWriters[slotIdx];
		}

		private static BinaryWriter FlushWriter(int slotIdx)
		{
			slotIdx++;
			fileWriters[slotIdx].BaseStream.SetLength(fileWriters[slotIdx].BaseStream.Position);
			fileWriters[slotIdx].Flush();
			return fileWriters[slotIdx];
		}

		private static void DecodeAllIcons()
		{
			int num = metadata.Length;
			while (--num >= 0)
			{
				DataHeader header = metadata[num].header;
				header.DecodeIcon();
				metadata[num].header = header;
			}
		}

		private static Result SendToThread(Result flags, ResultHandler handleResult, int slot, bool silent, bool log)
		{
			busy = true;
			SaveLoad.handleResult = handleResult;
			SaveLoad.slot = slot;
			SaveLoad.silent = silent;
			SaveLoad.log = log;
			threadFlags = flags;
			signalToThread.Set();
			return flags | Result.Pending;
		}

		private static void SendToDispatch(Result result)
		{
			threadFlags = result;
			signalToDispatchRoutine.Set();
		}

		private static void Thread()
		{
			while (true)
			{
				signalToThread.WaitOne();
				switch (threadFlags)
				{
				case Result.Metadata:
					SendToDispatch(ImmediateInitMetadata(silent, log));
					break;
				case Result.Save:
					SendToDispatch(ImmediateSave(title, subtitle, details, icon, iconData, dataObject, slot, silent, log));
					break;
				case Result.Load:
					SendToDispatch(ImmediateLoad(slot, outStream, silent, log));
					break;
				case Result.Delete:
					SendToDispatch(ImmediateDelete(slot, silent, log));
					break;
				}
			}
		}

		private static Result ImmediateInitMetadata(bool silent, bool log)
		{
			Result result = TryStartRead(fileReaders[0], filePaths[0]);
			if (result.Is(Result.MissingData))
			{
				try
				{
					metadata = new Metadata[slotQty];
				}
				catch
				{
					return Result.Metadata | Result.Failure | Result.Subsystem;
				}
				return Result.Metadata | Result.Success;
			}
			try
			{
				metadata = Serializer.DeserialiseFromReader<Metadata[]>(PrepareReader(-1), log);
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad read from \"{0}\".", filePaths[0]);
				}
			}
			catch
			{
				return Result.Metadata | Result.Failure | Result.Subsystem;
			}
			return Result.Metadata | Result.Success;
		}

		private static Result ImmediateSave(string title, string subtitle, string details, Texture2D icon, byte[] iconData, object dataObject, int slot, bool silent, bool log)
		{
			try
			{
				BinaryWriter binaryWriter = PrepareWriter(slot);
				if (dataObject is Stream input)
				{
					binaryWriter.Write((byte)0);
					input.CopyTo(binaryWriter.BaseStream, streamBuffer);
				}
				else
				{
					binaryWriter.Write((byte)1);
					Serializer.SerializeToWriter(dataObject, binaryWriter, log);
				}
				FlushWriter(slot);
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", filePaths[slot + 1]);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return Result.Save | Result.Failure | Result.Subsystem;
			}
			metadata[slot].exists = true;
			metadata[slot].header.title = title;
			metadata[slot].header.subtitle = subtitle;
			metadata[slot].header.details = details;
			metadata[slot].header.icon = icon;
			metadata[slot].header.iconData = iconData;
			metadata[slot].saveTime = DateTime.Now;
			try
			{
				Serializer.SerializeToWriter(metadata, PrepareWriter(-1), log);
				FlushWriter(-1);
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", filePaths[0]);
				}
			}
			catch
			{
				return Result.Metadata | Result.Save | Result.Failure | Result.Subsystem;
			}
			finally
			{
				metadata[slot].header.iconData = null;
			}
			return Result.Metadata | Result.Save | Result.Success;
		}

		private static Result ImmediateLoad(int slot, Stream outStream, bool silent, bool log)
		{
			Result result = TryStartRead(fileReaders[slot + 1], filePaths[slot + 1]);
			if (result.IsFailure())
			{
				return Result.Load | result;
			}
			try
			{
				BinaryReader binaryReader = PrepareReader(slot);
				bool flag = binaryReader.ReadByte() == 0;
				if (outStream != null)
				{
					binaryReader.BaseStream.CopyTo(outStream, streamBuffer);
				}
				else if (flag)
				{
					dataObject = binaryReader.ReadBytes((int)binaryReader.BaseStream.Length - 1);
				}
				else
				{
					dataObject = Serializer.DeserialiseFromReader<object>(binaryReader, log);
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad read from \"{0}\".", filePaths[slot + 1]);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return Result.Load | Result.Failure | Result.CorruptedData;
			}
			return Result.Load | Result.Success;
		}

		private static Result ImmediateDelete(int slotIn, bool silent, bool log)
		{
			try
			{
				PrepareWriter(slotIn);
				FlushWriter(slotIn);
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad deleted \"{0}\".", filePaths[slotIn + 1]);
				}
			}
			catch (DirectoryNotFoundException)
			{
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return Result.Delete | Result.Failure | Result.Subsystem;
			}
			metadata[slotIn] = default(Metadata);
			try
			{
				BinaryWriter output = PrepareWriter(-1);
				Serializer.SerializeToWriter(metadata, output, log);
				FlushWriter(-1);
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", filePaths[0]);
				}
			}
			catch
			{
				return Result.Metadata | Result.Delete | Result.Failure | Result.Subsystem;
			}
			return Result.Metadata | Result.Delete | Result.Success;
		}

		private static Result TryStartRead(BinaryReader fileReader, string path)
		{
			try
			{
				return (fileReader.BaseStream.Length <= 0) ? (Result.Failure | Result.MissingData) : Result.Success;
			}
			catch (FileNotFoundException)
			{
				return Result.Failure | Result.MissingData;
			}
			catch (DirectoryNotFoundException)
			{
				return Result.Failure | Result.MissingData;
			}
			catch (IsolatedStorageException ex3)
			{
				return Result.Failure | ((!ex3.Message.StartsWith("Could not find")) ? Result.Subsystem : Result.MissingData);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return Result.Failure | Result.Subsystem;
			}
		}

		public static void RunDispatch()
		{
			if (signalToDispatchRoutine == null || !signalToDispatchRoutine.WaitOne(0))
			{
				return;
			}
			Result result = threadFlags;
			threadFlags = Result.None;
			busy = false;
			if (result.Is(Result.Metadata, Result.Success))
			{
				try
				{
					DecodeAllIcons();
				}
				catch
				{
					metadata = null;
					result = Result.Metadata | Result.Failure | Result.CorruptedData;
				}
			}
			Dispatch(result);
		}

		public static void BackupFiles()
		{
			ValidateUsage();
			UnityEngine.Debug.Log("Backing up SaveLoad files...");
			string text = "ftp://10.140.19.142/SaveLoad_Backups";
			UnityEngine.Debug.LogFormat("Creating {0}...", text);
			Misc.TryMakeFTPFolder(text);
			string text2 = text + "/" + DateTime.Now.ToString("dd-MM HH-mm-ss") + $" ({SystemInfo.deviceName}) ({SystemInfo.deviceModel})";
			UnityEngine.Debug.LogFormat("Creating {0}...", text2);
			Misc.TryMakeFTPFolder(text2);
			string[] array = filePaths;
			foreach (string path in array)
			{
				string fileName = Path.GetFileName(path);
				if (!File.Exists(path))
				{
					UnityEngine.Debug.LogFormat("File \"{0}\" does not exist to backup!", fileName);
					continue;
				}
				string text3 = text2 + "/" + fileName;
				UnityEngine.Debug.LogFormat("Backing up \"{0}\" to \"{1}\"!", fileName, text3);
				Misc.TryCopyLocalFileToFTP(path, text3);
			}
			UnityEngine.Debug.Log("SaveLoad files backup complete!");
		}
	}
}
[Serializable]
public class ScriptableResource : ScriptableObject
{
	[ReadOnly]
	[SerializeField]
	private string _resourcePath;

	public string resourcePath => _resourcePath;

	protected virtual bool requiresResourceFolder => true;

	protected virtual void OnValidate()
	{
	}
}
namespace Coatsink
{
	[Serializable]
	public class SerialisableDictionary<TK, TV> : ISerializationCallbackReceiver
	{
		[SerializeField]
		private TK[] keys;

		[SerializeField]
		private TV[] vals;

		public bool autoReconstruct = true;

		private Dictionary<TK, TV> dict_;

		public Dictionary<TK, TV> dict
		{
			get
			{
				if (unconstructed)
				{
					InternalReconstruct();
				}
				return dict_;
			}
		}

		private bool unconstructed => keys != null || dict_ == null;

		public void Reconstruct()
		{
			if (unconstructed)
			{
				InternalReconstruct();
			}
		}

		public void OnBeforeSerialize()
		{
			if (unconstructed)
			{
				return;
			}
			int count = dict_.Count;
			if (count == 0)
			{
				return;
			}
			keys = new TK[count];
			vals = new TV[count];
			int num = 0;
			foreach (KeyValuePair<TK, TV> item in dict_)
			{
				keys[num] = item.Key;
				vals[num++] = item.Value;
			}
		}

		private void InternalReconstruct()
		{
			int num = ((keys != null) ? keys.Length : 0);
			dict_ = new Dictionary<TK, TV>(num);
			if (num != 0)
			{
				CollectionsX.Zip(keys, vals, dict_.Add);
			}
			keys = null;
			vals = null;
		}

		public void OnAfterDeserialize()
		{
			if (autoReconstruct)
			{
				InternalReconstruct();
			}
		}
	}
	[Serializable]
	public class SerialisableHashSet<T> : HashSet<T>, ISerializationCallbackReceiver
	{
		[SerializeField]
		private T[] entries;

		public SerialisableHashSet()
		{
		}

		public SerialisableHashSet(IEnumerable<T> pop)
			: base(pop)
		{
		}

		public void OnBeforeSerialize()
		{
			entries = this.ToArray();
		}

		public void OnAfterDeserialize()
		{
			Clear();
			UnionWith(entries);
			entries = null;
		}
	}
}
namespace Coatsink.Common
{
	public static class Serializer
	{
		private class ColorConstructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Color color = (Color)obj;
				writer.Write(color.r);
				writer.Write(color.g);
				writer.Write(color.b);
				writer.Write(color.a);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Color(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class Vector3Constructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Vector3 vector = (Vector3)obj;
				writer.Write(vector.x);
				writer.Write(vector.y);
				writer.Write(vector.z);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class Vector2Constructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Vector2 vector = (Vector2)obj;
				writer.Write(vector.x);
				writer.Write(vector.y);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Vector2(reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class NameSorter : IComparer<KeyValuePair<string, int>>
		{
			public int Compare(KeyValuePair<string, int> x, KeyValuePair<string, int> y)
			{
				return string.Compare(x.Key, y.Key);
			}
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAllFields : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAllFieldsFromAssignablesTo : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAssignablesTo : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field)]
		public class Exclude : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class ExcludeEnabled : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public abstract class ExternalConstructor : Attribute, IExternalConstructor
		{
			public abstract void Deconstruct(object obj, Type type, BinaryWriter writer);

			public abstract object Reconstruct(Type type, BinaryReader reader);
		}

		[AttributeUsage(AttributeTargets.Class)]
		public abstract class ExternalResourceAcquisitor : Attribute
		{
			public abstract void Deacquire(ScriptableResource obj, Type type, BinaryWriter writer);

			public abstract ScriptableResource Reacquire(string path, Type type, BinaryReader reader);
		}

		[AttributeUsage(AttributeTargets.Class)]
		public abstract class ExternalPrefabReacquisitor : Attribute
		{
			public abstract void Deacquire(Serializer_Prefab instance, BinaryWriter writer);

			public abstract GameObject Reacquire(string path, BinaryReader reader);
		}

		public interface ISelfConstructor
		{
			void Deconstruct(BinaryWriter writer);
		}

		public interface IExternalConstructor
		{
			void Deconstruct(object obj, Type type, BinaryWriter writer);

			object Reconstruct(Type type, BinaryReader reader);
		}

		public interface IMemberSink
		{
			object this[string name] { set; }
		}

		public interface IMemberSource
		{
			object this[string name] { get; }

			bool TryGet<T>(string name, ref T val);

			T Get<T>(string name);
		}

		public interface ISelfComposer
		{
			void Decompose(IMemberSink members);

			void Recompose(IMemberSource members);
		}

		private class TypeProperties
		{
			private const BindingFlags incFields = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

			public readonly Type type;

			public readonly Type arrayType;

			public readonly string assemblyQualifiedName;

			public readonly FieldProperties[] fields;

			public readonly Attribute[] attribs;

			public readonly Attribute[] inheritedAttribs;

			public TypeProperties(Type type)
			{
				this.type = type;
				arrayType = type.GetElementType();
				assemblyQualifiedName = type.AssemblyQualifiedName;
				ParameterExpression parameterExpression = null;
				ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object), "object");
				Expression expression = Expression.ConvertChecked(parameterExpression2, type);
				if (arrayType != null)
				{
					parameterExpression = Expression.Parameter(typeof(int), "index");
					expression = Expression.ArrayIndex(expression, parameterExpression);
				}
				Type type2 = arrayType ?? type;
				List<FieldProperties> list = new List<FieldProperties>();
				Stack<FieldInfo> fieldStack = new Stack<FieldInfo>();
				HashSet<Attribute> thisAttribs = new HashSet<Attribute>(type2.GetCustomAttributes(inherit: false).Cast<Attribute>());
				attribs = thisAttribs.ToArray();
				inheritedAttribs = (from Attribute a in type2.GetCustomAttributes(inherit: true)
					where !thisAttribs.Contains(a)
					select a).ToArray();
				CollectFieldProperties(type2, list, fieldStack, expression, parameterExpression2, parameterExpression, string.Empty);
				fields = list.ToArray();
			}

			public int GetLength(object obj)
			{
				return (arrayType == null) ? 1 : (obj as Array).Length;
			}

			private static void CollectFieldProperties(Type type, List<FieldProperties> propList, Stack<FieldInfo> fieldStack, Expression ownerExpr, ParameterExpression targetPExpr, ParameterExpression indexerPExpr, string ownerField)
			{
				int i = 0;
				for (int count = extraExcludeAllFieldsFromAssignablesTo.Count; i < count; i++)
				{
					if (extraExcludeAllFieldsFromAssignablesTo[i].IsAssignableFrom(type))
					{
						return;
					}
				}
				if (type.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true))
				{
					return;
				}
				for (Type type2 = type; type2 != null; type2 = type2.BaseType)
				{
					if (!extraExcludeAllFields.Contains(type2) && !type2.HasAttr<ExcludeAllFields>())
					{
						FieldInfo[] array = type2.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
						FieldInfo[] array2 = array;
						foreach (FieldInfo fieldInfo in array2)
						{
							if (!fieldInfo.HasAttr<Exclude>())
							{
								string text = ownerField + "." + fieldInfo.Name;
								if (fieldInfo.FieldType.IsValueType && !fieldInfo.FieldType.IsConvertableToPrimitve())
								{
									fieldStack.Push(fieldInfo);
									CollectFieldProperties(fieldInfo.FieldType, propList, fieldStack, Expression.Field(ownerExpr, fieldInfo), targetPExpr, indexerPExpr, text);
									fieldStack.Pop();
								}
								else
								{
									propList.Add(new FieldProperties(fieldInfo, fieldStack, ownerExpr, targetPExpr, indexerPExpr, text));
								}
							}
						}
					}
				}
			}

			public T GetAttr<T>(bool inherit = false) where T : Attribute
			{
				Type typeFromHandle = typeof(T);
				for (int i = 0; i < attribs.Length; i++)
				{
					if (attribs[i].IsOfTypeOrSubType(typeFromHandle))
					{
						return (T)attribs[i];
					}
				}
				if (inherit)
				{
					for (int j = 0; j < inheritedAttribs.Length; j++)
					{
						if (inheritedAttribs[j].IsOfTypeOrSubType(typeFromHandle))
						{
							return (T)inheritedAttribs[j];
						}
					}
				}
				return (T)null;
			}

			public bool HasAttr<T>(bool inherit = false) where T : Attribute
			{
				return GetAttr<T>(inherit) != null;
			}
		}

		private class FieldProperties
		{
			private static MethodInfo dtToBinary = typeof(DateTime).GetMethod("ToBinary", BindingFlags.Instance | BindingFlags.Public);

			public readonly FieldInfo field;

			public readonly Attribute[] attribs;

			public readonly TypeCode typeCode;

			public readonly string fullName;

			public readonly Func<object, primitive> GetPrimitive;

			public readonly Func<object, object> GetObject;

			public readonly Func<object, int, primitive> GetPrimitiveIndexed;

			public readonly Func<object, int, object> GetObjectIndexed;

			private readonly FieldInfo[] fieldStack;

			private readonly object[] objStack;

			public FieldProperties(FieldInfo field, Stack<FieldInfo> fieldStack, Expression ownerExpr, ParameterExpression targetPExpr, ParameterExpression indexerPExpr, string fullName)
			{
				IEnumerable<Attribute> enumerable = field.GetCustomAttributes(inherit: false).Cast<Attribute>();
				Type fieldType = field.FieldType;
				this.field = field;
				this.fullName = fullName;
				this.fieldStack = fieldStack.ToArray();
				objStack = new object[this.fieldStack.Length];
				typeCode = Type.GetTypeCode(fieldType);
				if (field.IsBacking())
				{
					PropertyInfo backedProperty = field.GetBackedProperty();
					if (backedProperty != null)
					{
						enumerable = enumerable.Concat(backedProperty.GetCustomAttributes(inherit: false).Cast<Attribute>());
					}
				}
				attribs = enumerable.ToArray();
				Expression expression = Expression.Field(ownerExpr, field);
				if (fieldType.IsConvertableToPrimitve())
				{
					if (fieldType == typeof(DateTime))
					{
						expression = Expression.ConvertChecked(expression, typeof(DateTime));
						expression = Expression.Call(expression, dtToBinary);
					}
					else if (fieldType.IsEnum)
					{
						expression = Expression.ConvertChecked(expression, Enum.GetUnderlyingType(fieldType));
					}
					expression = Expression.ConvertChecked(expression, typeof(primitive));
					GetObject = null;
					GetObjectIndexed = null;
					if (indexerPExpr == null)
					{
						GetPrimitive = Expression.Lambda<Func<object, primitive>>(expression, new ParameterExpression[1] { targetPExpr }).Compile();
						GetPrimitiveIndexed = null;
					}
					else
					{
						GetPrimitive = null;
						GetPrimitiveIndexed = Expression.Lambda<Func<object, int, primitive>>(expression, new ParameterExpression[2] { targetPExpr, indexerPExpr }).Compile();
					}
				}
				else
				{
					expression = Expression.ConvertChecked(expression, typeof(object));
					GetPrimitive = null;
					GetPrimitiveIndexed = null;
					if (indexerPExpr == null)
					{
						GetObject = Expression.Lambda<Func<object, object>>(expression, new ParameterExpression[1] { targetPExpr }).Compile();
						GetObjectIndexed = null;
					}
					else
					{
						GetObject = null;
						GetObjectIndexed = Expression.Lambda<Func<object, int, object>>(expression, new ParameterExpression[2] { targetPExpr, indexerPExpr }).Compile();
					}
				}
			}

			public void SetObjectValue(object objOwner, object objVal)
			{
				object obj = objOwner;
				for (int num = fieldStack.Length - 1; num >= 0; num--)
				{
					objStack[num] = obj;
					obj = fieldStack[num].GetValue(obj);
				}
				field.SetValue(obj, objVal);
				for (int i = 0; i < fieldStack.Length; i++)
				{
					fieldStack[i].SetValue(objStack[i], obj);
					obj = objStack[i];
				}
			}

			public void SetObjectValueIndexed(Array array, int index, object objVal)
			{
				object value = array.GetValue(index);
				SetObjectValue(value, objVal);
				array.SetValue(value, index);
			}

			public T GetAttr<T>() where T : Attribute
			{
				Type typeFromHandle = typeof(T);
				for (int i = 0; i < attribs.Length; i++)
				{
					if (attribs[i].IsOfTypeOrSubType(typeFromHandle))
					{
						return (T)attribs[i];
					}
				}
				return (T)null;
			}

			public bool HasAttr<T>() where T : Attribute
			{
				return GetAttr<T>() != null;
			}
		}

		private struct DeconstructedObject
		{
			public object obj;

			public Type type;

			public byte hint;

			public int memIdx;

			public int memQty;

			public int elementSize;
		}

		private static class Hint
		{
			public const byte None = 0;

			public const byte String = 1;

			public const byte Enum = 2;

			public const byte Resource = 3;

			public const byte Type = 4;

			public const byte FieldInfo = 5;

			public const byte Array = 6;

			public const byte GameObject = 7;

			public const byte Component = 8;

			public const byte List = 9;

			public const byte Dictionary = 10;
		}

		private struct DeconstructedPrefab
		{
			public byte order;

			public Serializer_Prefab instance;
		}

		private struct DeconstructedMember
		{
			[StructLayout(LayoutKind.Explicit)]
			public struct Value
			{
				[FieldOffset(0)]
				public byte typeCode;

				[FieldOffset(0)]
				public bool custom;

				[FieldOffset(1)]
				public int index;

				[FieldOffset(1)]
				public primitive prim;
			}

			public string name;

			public Value key;

			public Value val;
		}

		private class CustomMemberBuffer : IMemberSink, IMemberSource
		{
			public Dictionary<string, object> members = new Dictionary<string, object>(64);

			public object this[string name]
			{
				get
				{
					return members[name];
				}
				set
				{
					members[name] = value;
				}
			}

			public bool TryGet<T>(string name, ref T val)
			{
				if (members.TryGetValue(name, out var value))
				{
					val = (T)value;
					return true;
				}
				return false;
			}

			public T Get<T>(string name)
			{
				return (T)members[name];
			}
		}

		private static int retentions = 0;

		private const int initialObjectCapacity = 65536;

		private const int initialMemberCapacity = 524288;

		private const int initialParsedPrefabCapacity = 128;

		private const int initialBufferBufferSize = 2048;

		private const int nullValue = -1;

		private const int excluded = -2;

		private static DeconstructedObject[] deconObjs;

		private static int objQty;

		private static int memQty;

		private static int prefabQty;

		private static Dictionary<object, int> deconObjIdxs;

		private static DeconstructedPrefab[] deconPrefabs;

		private static DeconstructedMember[] deconMems;

		private static CustomMemberBuffer customMemberBuffer;

		private static object[] constrParams;

		private static byte[] bufferBuffer;

		private static StringBuilder fieldPathBuilder;

		private static Dictionary<Type, FieldInfo[]> fieldCache;

		private static Dictionary<Type, bool> excludeCache;

		private static FieldInfo[] zeroFieldsArray;

		private static List<FieldInfo> fieldBuffer;

		private static Dictionary<Type, IExternalConstructor> extraExternalConstructor;

		private static HashSet<Type> extraExcludeAllFields;

		private static HashSet<Type> extraExclude;

		private static List<Type> extraExcludeAllFieldsFromAssignablesTo;

		private static List<Type> extraExcludeAssignablesTo;

		private static List<Serializer_Prefab> prefabCompBuffer;

		private static Dictionary<Type, TypeProperties> typePropsCache;

		private static Type genericEqCompTemplate = typeof(EqualityComparer<>).Assembly.GetType("System.Collections.Generic.GenericEqualityComparer`1");

		private const bool logByDefault = false;

		private static TextWriter debugLog;

		private static Stack<string> logStack = new Stack<string>(32);

		private static string logFolderPath;

		private static int mainThreadID;

		private static Dictionary<Type, int> instanceCounts;

		public static bool initialised => retentions > 0;

		public static void Retain(bool silent = false, string logFolder = null)
		{
			if (retentions++ > 0)
			{
				return;
			}
			try
			{
				deconObjs = new DeconstructedObject[65536];
				deconObjIdxs = new Dictionary<object, int>(65536);
				deconPrefabs = new DeconstructedPrefab[128];
				deconMems = new DeconstructedMember[524288];
				customMemberBuffer = new CustomMemberBuffer();
				constrParams = new object[1];
				bufferBuffer = new byte[2048];
				zeroFieldsArray = new FieldInfo[0];
				fieldCache = new Dictionary<Type, FieldInfo[]>(65);
				fieldBuffer = new List<FieldInfo>(128);
				prefabCompBuffer = new List<Serializer_Prefab>(1);
				typePropsCache = new Dictionary<Type, TypeProperties>();
				Dictionary<Type, IExternalConstructor> dictionary = new Dictionary<Type, IExternalConstructor>(64);
				dictionary.Add(typeof(Color), new ColorConstructor());
				dictionary.Add(typeof(Vector3), new Vector3Constructor());
				dictionary.Add(typeof(Vector2), new Vector2Constructor());
				extraExternalConstructor = dictionary;
				HashSet<Type> hashSet = new HashSet<Type>();
				hashSet.Add(typeof(UnityEngine.Object));
				hashSet.Add(typeof(MonoBehaviour));
				hashSet.Add(typeof(UnityEngine.Component));
				hashSet.Add(typeof(Color));
				hashSet.Add(typeof(Vector3));
				hashSet.Add(typeof(Vector2));
				hashSet.Add(typeof(Type));
				hashSet.Add(typeof(FieldInfo));
				extraExcludeAllFields = hashSet;
				List<Type> list = new List<Type>(64);
				list.Add(typeof(Renderer));
				extraExcludeAllFieldsFromAssignablesTo = list;
				hashSet = new HashSet<Type>();
				hashSet.Add(typeof(AnimationCurve));
				hashSet.Add(typeof(Material));
				hashSet.Add(typeof(Texture2D));
				hashSet.Add(typeof(Font));
				extraExclude = hashSet;
				list = new List<Type>(64);
				list.Add(typeof(Delegate));
				list.Add(typeof(Attribute));
				list.Add(typeof(Stream));
				list.Add(typeof(Exception));
				extraExcludeAssignablesTo = list;
				logFolderPath = ((logFolder != null) ? logFolder : UnityEngine.Application.persistentDataPath);
				mainThreadID = Thread.CurrentThread.ManagedThreadId;
				if (!silent)
				{
					UnityEngine.Debug.Log("Serializer initialised.");
				}
			}
			catch (Exception ex)
			{
				Release(silent);
				throw ex;
			}
		}

		public static void Release(bool silent = false)
		{
			if (retentions == 0)
			{
				UnityEngine.Debug.LogError("Serializer over-released!");
			}
			else if (--retentions <= 0)
			{
				deconObjs = null;
				deconObjIdxs = null;
				deconPrefabs = null;
				deconMems = null;
				customMemberBuffer = null;
				fieldPathBuilder = null;
				constrParams = null;
				bufferBuffer = null;
				fieldCache = null;
				fieldBuffer = null;
				prefabCompBuffer = null;
				extraExcludeAllFields = null;
				extraExclude = null;
				extraExcludeAssignablesTo = null;
				extraExternalConstructor = null;
				logFolderPath = null;
				mainThreadID = 0;
				if (!silent)
				{
					UnityEngine.Debug.Log("Serializer cleaned up.");
				}
			}
		}

		public static void PrecacheTypes(IEnumerable<Type> rootTypes, IEnumerable<Type> nonRecursuveTypes, IEnumerable<Assembly> subclassAssemblies)
		{
			HashSet<Type> hashSet = new HashSet<Type>();
			foreach (Type rootType in rootTypes)
			{
				if (hashSet.Add(rootType))
				{
					PrecacheTypes(hashSet, rootType);
				}
			}
			foreach (Type nonRecursuveType in nonRecursuveTypes)
			{
				if (hashSet.Add(nonRecursuveType))
				{
					PrecacheTypes(hashSet, nonRecursuveType, recurse: false);
				}
			}
			Type[] array = (from t in subclassAssemblies.Concat(typePropsCache.Keys.Select((Type t) => t.Assembly)).Distinct().SelectMany((Assembly a) => a.GetTypes())
				where !typePropsCache.ContainsKey(t)
				where t != typeof(object) && t.IsClass && !t.HasAttr<Exclude>() && !extraExclude.Contains(t) && !extraExcludeAssignablesTo.Where((Type eeat) => eeat.IsAssignableFrom(t)).Any()
				select t).ToArray();
			Type[] array2 = typePropsCache.Keys.Where((Type t) => t != typeof(object)).ToArray();
			Type[] array3 = array;
			foreach (Type type in array3)
			{
				if (hashSet.Contains(type))
				{
					continue;
				}
				Type[] array4 = array2;
				foreach (Type type2 in array4)
				{
					if (type2.IsAssignableFrom(type))
					{
						PrecacheTypes(hashSet, type, !type2.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true));
						break;
					}
				}
			}
		}

		private static Type GetDefaultComparerType(Type interfaceType)
		{
			Type[] genericArguments = interfaceType.GetGenericArguments();
			Type type = typeof(IEquatable<>).MakeGenericType(genericArguments);
			if (type.IsAssignableFrom(genericArguments[0]))
			{
				return genericEqCompTemplate.MakeGenericType(genericArguments);
			}
			return typeof(EqualityComparer<>).GetNestedType("DefaultComparer", BindingFlags.NonPublic).MakeGenericType(genericArguments);
		}

		private static void PrecacheTypes(HashSet<Type> foundTypes, Type type, bool recurse = true)
		{
			if (type.IsGenericTypeDefinition || type.HasAttr<Exclude>() || extraExclude.Contains(type) || extraExcludeAssignablesTo.Where((Type eeat) => eeat.IsAssignableFrom(type)).Any())
			{
				return;
			}
			TypeProperties typeProperties = type.GetTypeProperties();
			if (typeProperties.arrayType != null && foundTypes.Add(typeProperties.arrayType))
			{
				PrecacheTypes(foundTypes, typeProperties.arrayType);
			}
			if (!recurse || type.HasAttr<ExternalResourceAcquisitor>(inherit: true) || type.HasAttr<ExcludeAllFields>() || type.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true) || extraExcludeAllFields.Contains(type) || extraExcludeAllFieldsFromAssignablesTo.Where((Type eeaffat) => eeaffat.IsAssignableFrom(type)).Any())
			{
				return;
			}
			foreach (Type item in from fi in typeProperties.fields
				where !fi.HasAttr<Exclude>()
				select fi.field.FieldType into fType
				where !fType.IsValueType
				select fType)
			{
				if (!foundTypes.Add(item))
				{
					continue;
				}
				if (item.IsClass)
				{
					PrecacheTypes(foundTypes, item);
				}
				else if (item.IsGenericType && typeof(IEqualityComparer<>).IsAssignableFrom(item.GetGenericTypeDefinition()))
				{
					Type defaultComparerType = GetDefaultComparerType(item);
					if (foundTypes.Add(defaultComparerType))
					{
						PrecacheTypes(foundTypes, defaultComparerType);
					}
				}
			}
		}

		public static void SerializeToWriter(object obj, BinaryWriter output, bool log = false, string overrideLogPath = null)
		{
			Retain();
			int i = 0;
			try
			{
				if (log)
				{
					StartLogging(obj.GetType(), serialising: true, overrideLogPath);
				}
				LogDeconstructionStart();
				Deconstruct(obj, deconObjs.Length - 1);
				output.Write(prefabQty);
				LogPrefabReadWriteStart();
				byte b = 0;
				while (WritePrefabs(output, b++, prefabQty))
				{
				}
				output.Write(objQty);
				LogObjectReadWriteStart();
				for (; i < objQty; i++)
				{
					WriteObject(output, i);
				}
			}
			catch (Exception ex)
			{
				LogException(ex, i);
				throw ex;
			}
			finally
			{
				ClearAllCache();
				EndLogging(overrideLogPath);
				Release();
			}
		}

		public static void SerializeToStream(object obj, Stream output, bool log = false, string overrideLogPath = null)
		{
			BinaryWriter binaryWriter = new BinaryWriter(output);
			SerializeToWriter(obj, binaryWriter, log, overrideLogPath);
			binaryWriter.Flush();
		}

		public static void SerializeToFile(object obj, string path, bool log = false, string overrideLogPath = null)
		{
			Directory.CreateDirectory(Path.GetDirectoryName(path));
			using FileStream output = File.Create(path);
			SerializeToStream(obj, output, log, overrideLogPath);
		}

		public static byte[] SerializeToMemory(object obj, int capacity = -1, bool log = false, string overrideLogPath = null)
		{
			using MemoryStream memoryStream = ((capacity <= 0) ? new MemoryStream() : new MemoryStream(capacity));
			SerializeToStream(obj, memoryStream, log, overrideLogPath);
			return memoryStream.GetBuffer();
		}

		public static int SerializeToMemory(object obj, byte[] memory, bool clearRemainder = true, int startIndex = 0, int count = -1, bool log = false, string overrideLogPath = null)
		{
			int num = 0;
			using (MemoryStream memoryStream = new MemoryStream(memory, startIndex, (count <= 0) ? memory.Length : count))
			{
				SerializeToStream(obj, memoryStream, log, overrideLogPath);
				num = (int)memoryStream.Position;
			}
			if (clearRemainder)
			{
				Array.Clear(memory, num, memory.Length - num);
			}
			return num;
		}

		public static T DeserialiseFromReader<T>(BinaryReader input, bool log = false, string overrideLogPath = null) where T : class
		{
			Retain();
			int i = 0;
			try
			{
				if (log)
				{
					StartLogging(typeof(T), serialising: false, overrideLogPath);
				}
				prefabQty = input.ReadInt32();
				LogPrefabReadWriteStart();
				for (int j = 0; j < prefabQty; j++)
				{
					ReadPrefab(input);
				}
				objQty = input.ReadInt32();
				LogObjectReadWriteStart();
				ValidateObjectCap(objQty);
				for (; i < objQty; i++)
				{
					ReadObject(input, ref deconObjs[i], i);
				}
				for (i--; i >= 0; i--)
				{
					ReconstructMembers(input, ref deconObjs[i]);
				}
				i = objQty;
				for (i--; i >= 0; i--)
				{
					SelfRecompose(input, i, ref deconObjs[i]);
				}
				return (T)deconObjs[0].obj;
			}
			catch (Exception ex)
			{
				LogException(ex, i);
				throw ex;
			}
			finally
			{
				ClearAllCache();
				EndLogging(overrideLogPath);
				Release();
			}
		}

		public static T DeserialiseFromStream<T>(Stream input, bool log = false, string overrideLogPath = null) where T : class
		{
			using BinaryReader input2 = new BinaryReader(input);
			return DeserialiseFromReader<T>(input2, log, overrideLogPath);
		}

		public static T DeserialiseFromFile<T>(string path, bool log = false, string overrideLogPath = null) where T : class
		{
			using FileStream input = File.OpenRead(path);
			return DeserialiseFromStream<T>(input, log, overrideLogPath);
		}

		public static T DeserialiseFromMemory<T>(byte[] memory, int startIndex = 0, int byteCount = -1, bool log = false, string overrideLogPath = null) where T : class
		{
			using MemoryStream input = new MemoryStream(memory, startIndex, (byteCount <= 0) ? memory.Length : byteCount, writable: false);
			return DeserialiseFromStream<T>(input, log, overrideLogPath);
		}

		public static void AddExternalConstructor<T>(IExternalConstructor constructor)
		{
			extraExternalConstructor[typeof(T)] = constructor;
		}

		public static void RemoveExternalConstructor<T>(IExternalConstructor constructor)
		{
			extraExternalConstructor.Remove(typeof(T));
		}

		public static void AddExcludeAllFields<T>()
		{
			extraExcludeAllFields.Add(typeof(T));
		}

		public static void RemoveExcludeAllFields<T>()
		{
			extraExcludeAllFields.Remove(typeof(T));
		}

		public static void AddExclude<T>()
		{
			extraExclude.Add(typeof(T));
		}

		public static void RemoveExclude<T>()
		{
			extraExclude.Remove(typeof(T));
		}

		public static void AddExcludeAssignablesTo<T>()
		{
			extraExcludeAssignablesTo.Add(typeof(T));
		}

		public static void RemoveExcludeAssignablesTo<T>()
		{
			extraExcludeAssignablesTo.Remove(typeof(T));
		}

		private static bool IsConvertableToPrimitve(this Type type)
		{
			return type.IsPrimitive || type.IsEnum || type == typeof(DateTime);
		}

		private static void ClearAllCache()
		{
			constrParams[0] = null;
			Array.Clear(deconObjs, 0, objQty);
			Array.Clear(deconMems, 0, memQty);
			Array.Clear(deconPrefabs, 0, prefabQty);
			objQty = (memQty = (prefabQty = 0));
			customMemberBuffer.members.Clear();
			deconObjIdxs.Clear();
		}

		private static TypeProperties GetTypeProperties(this Type type)
		{
			if (type == null)
			{
				return null;
			}
			if (!typePropsCache.TryGetValue(type, out var value))
			{
				value = new TypeProperties(type);
				typePropsCache[type] = value;
			}
			return value;
		}

		private static void GetIncludedFields(this Type type, List<FieldInfo> listToFill)
		{
			try
			{
				int i = 0;
				for (int count = extraExcludeAllFieldsFromAssignablesTo.Count; i < count; i++)
				{
					if (extraExcludeAllFieldsFromAssignablesTo[i].IsAssignableFrom(type))
					{
						return;
					}
				}
				TypeProperties typeProperties = type.GetTypeProperties();
				if (typeProperties.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true))
				{
					return;
				}
				Type type2 = type;
				while (type2 != null)
				{
					if (!extraExcludeAllFields.Contains(type2) && !type2.HasAttr<ExcludeAllFields>())
					{
						FieldProperties[] fields = typeProperties.fields;
						int j = 0;
						for (int num = fields.Length; j < num; j++)
						{
							if (!fields[j].HasAttr<Exclude>())
							{
								listToFill.Add(fields[j].field);
							}
						}
					}
					type2 = type2.BaseType;
					typeProperties = type2.GetTypeProperties();
				}
			}
			finally
			{
			}
		}

		public static FieldInfo[] GetIncludedFields(this Type type)
		{
			try
			{
				Retain(silent: true);
				List<FieldInfo> list = new List<FieldInfo>();
				type.GetIncludedFields(list);
				return list.ToArray();
			}
			finally
			{
				Release();
			}
		}

		public static FieldInfo[] GetIncludedFieldsORIG(this Type type)
		{
			Retain(silent: true);
			int i = 0;
			for (int count = extraExcludeAllFieldsFromAssignablesTo.Count; i < count; i++)
			{
				if (extraExcludeAllFieldsFromAssignablesTo[i].IsAssignableFrom(type))
				{
					return new FieldInfo[0];
				}
			}
			if (type.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true))
			{
				return new FieldInfo[0];
			}
			FieldInfo[] value;
			try
			{
				if (fieldCache.TryGetValue(type, out value))
				{
					return value;
				}
			}
			finally
			{
			}
			try
			{
				for (Type type2 = type; type2 != null; type2 = type2.BaseType)
				{
					if (!extraExcludeAllFields.Contains(type2) && !type2.HasAttr<ExcludeAllFields>())
					{
						FieldInfo[] fields = type2.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
						int j = 0;
						for (int num = fields.Length; j < num; j++)
						{
							if (!fields[j].HasAttr<Exclude>() && (!fields[j].IsBacking() || !fields[j].GetBackedProperty().HasAttr<Exclude>()))
							{
								fieldBuffer.Add(fields[j]);
							}
						}
					}
				}
				value = (fieldCache[type] = fieldBuffer.ToArray());
				fieldBuffer.Clear();
			}
			finally
			{
			}
			Release();
			return value;
		}

		private static void ValidateObjectCap(int reqIdx)
		{
			if (reqIdx >= deconObjs.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its object capacity from {0} to {1}", deconObjs.Length, num);
				Array.Resize(ref deconObjs, num);
			}
		}

		private static void ValidateMemberCap(int reqIdx)
		{
			if (reqIdx >= deconMems.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its member capacity from {0} to {1}", deconMems.Length, num);
				Array.Resize(ref deconMems, num);
			}
		}

		private static void ValidatePrefabCap(int reqIdx)
		{
			if (reqIdx >= deconPrefabs.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its prefab capacity from {0} to {1}", deconPrefabs.Length, num);
				Array.Resize(ref deconPrefabs, num);
			}
		}

		private static int Deconstruct(object obj, int referrerIdx)
		{
			bool flag;
			int value;
			Type type;
			UnityEngine.Object @object;
			if (!object.ReferenceEquals(obj, deconObjs[referrerIdx].obj))
			{
				flag = !(obj is ValueType);
				if (flag)
				{
					try
					{
						if (deconObjIdxs.TryGetValue(obj, out value))
						{
							goto IL_082b;
						}
					}
					finally
					{
					}
				}
				type = obj.GetType();
				if (!type.ExcludedBySerializer())
				{
					@object = null;
					ScriptableResource scriptableResource = null;
					if (flag)
					{
						try
						{
							@object = obj as UnityEngine.Object;
							if (!object.ReferenceEquals(@object, null))
							{
								if (@object == null)
								{
									goto IL_081c;
								}
								scriptableResource = @object as ScriptableResource;
							}
						}
						finally
						{
						}
					}
					ValidateObjectCap(objQty + 1);
					value = objQty++;
					if (flag)
					{
						try
						{
							deconObjIdxs[obj] = value;
						}
						finally
						{
						}
					}
					deconObjs[value].type = type;
					deconObjs[value].obj = obj;
					deconObjs[value].memIdx = memQty;
					if (flag)
					{
						if (obj is string)
						{
							deconObjs[value].hint = 1;
						}
						else
						{
							if (!object.ReferenceEquals(scriptableResource, null))
							{
								deconObjs[value].hint = 3;
								if (scriptableResource.resourcePath != null)
								{
									goto IL_082b;
								}
							}
							if (typeof(FieldInfo).IsAssignableFrom(type))
							{
								deconObjs[value].hint = 5;
							}
							else if (typeof(Type).IsAssignableFrom(type))
							{
								deconObjs[value].hint = 4;
							}
							else
							{
								if (!(obj is Array array))
								{
									goto IL_0445;
								}
								TypeProperties typeProperties = type.GetTypeProperties();
								deconObjs[value].hint = 6;
								if (typeProperties.arrayType.IsPrimitive)
								{
									deconObjs[value].memQty = array.Length;
								}
								else
								{
									int length = typeProperties.GetLength(deconObjs[value].obj);
									object[] array2 = ((!typeProperties.arrayType.IsValueType) ? (deconObjs[value].obj as object[]) : null);
									int num = deconObjs[value].memIdx;
									deconObjs[value].elementSize = ((array2 != null) ? 1 : typeProperties.fields.Length);
									for (int i = 0; i < length; i++)
									{
										if (array2 == null)
										{
											for (int j = 0; j < typeProperties.fields.Length; j++)
											{
												deconObjs[value].memQty++;
												memQty++;
												ValidateMemberCap(memQty);
											}
										}
										else
										{
											deconObjs[value].memQty++;
											memQty++;
											ValidateMemberCap(memQty);
										}
									}
									for (int k = 0; k < length; k++)
									{
										if (array2 == null)
										{
											for (int l = 0; l < typeProperties.fields.Length; l++)
											{
												FieldProperties fieldProperties = typeProperties.fields[l];
												deconMems[num].name = fieldProperties.fullName;
												deconMems[num].key.index = l;
												LogPushMember(deconMems[num].name);
												DeconstructIndexedFieldProperties(fieldProperties, k, value, ref deconMems[num].val);
												LogPopMember();
												num++;
											}
										}
										else
										{
											LogPushMemberParse(k);
											DeconstructObjectMember(array2[k], value, ref deconMems[num].val);
											LogPopMember();
											num++;
										}
									}
								}
							}
						}
					}
					else
					{
						if (!type.IsEnum)
						{
							goto IL_0445;
						}
						UnityEngine.Debug.Log("ENUM AS OBJECT!");
						deconObjs[value].hint = 2;
					}
				}
				else
				{
					value = -2;
				}
			}
			else
			{
				value = referrerIdx;
			}
			goto IL_082b;
			IL_082b:
			LogObjectDeconstruct(value, referrerIdx, prefabQty);
			return value;
			IL_081c:
			value = -1;
			goto IL_082b;
			IL_0445:
			LogObjectDeconstruct(value, referrerIdx, prefabQty);
			if (flag)
			{
				GameObject gameObject = null;
				UnityEngine.Component component = null;
				if (!object.ReferenceEquals(@object, null))
				{
					gameObject = @object as GameObject;
					component = @object as UnityEngine.Component;
					TryDeconstructPrefab(gameObject, component, ref prefabQty);
				}
				if (!object.ReferenceEquals(gameObject, null))
				{
					int num2 = memQty++;
					deconMems[num2].name = "activeSelf";
					deconMems[num2].val.typeCode = 3;
					deconMems[num2].val.prim = gameObject.activeSelf;
					LogPrimParse("activeSelf", deconMems[num2].val);
					deconObjs[value].memQty++;
					deconObjs[value].hint = 7;
					return value;
				}
				if (!object.ReferenceEquals(component, null))
				{
					deconObjs[value].memQty++;
					int num3 = memQty++;
					deconMems[num3].name = "gameObject.activeSelf";
					deconMems[num3].val.typeCode = 3;
					deconMems[num3].val.prim = component.gameObject.activeSelf;
					LogPrimParse("gameObject.activeSelf", deconMems[num3].val);
					MonoBehaviour monoBehaviour;
					if (!object.ReferenceEquals(monoBehaviour = obj as MonoBehaviour, null) && !type.HasAttr<ExcludeEnabled>())
					{
						deconObjs[value].memQty++;
						num3 = memQty++;
						deconMems[num3].name = "enabled";
						deconMems[num3].val.typeCode = 3;
						deconMems[num3].val.prim = monoBehaviour.enabled;
						LogPrimParse("enabled", deconMems[num3].val);
					}
					deconObjs[value].hint = 8;
				}
			}
			if (obj is ISelfComposer selfComposer)
			{
				int num4 = deconObjs[value].memIdx + deconObjs[value].memQty;
				try
				{
					selfComposer.Decompose(customMemberBuffer);
				}
				finally
				{
				}
				int count = customMemberBuffer.members.Count;
				deconObjs[value].memQty += count;
				memQty += count;
				ValidateMemberCap(memQty);
				QueryFields(value);
				foreach (KeyValuePair<string, object> member in customMemberBuffer.members)
				{
					deconMems[num4].name = member.Key;
					LogPushMember(member.Key);
					DeconstructObjectMember(member.Value, value, ref deconMems[num4].val);
					LogPopMember();
					deconMems[num4].key.custom = true;
					num4++;
				}
				customMemberBuffer.members.Clear();
				DeconstructFields(value, num4);
				return value;
			}
			int startmi = deconObjs[value].memIdx + deconObjs[value].memQty;
			QueryFields(value);
			DeconstructFields(value, startmi);
			return value;
		}

		public static bool ExcludedBySerializer(this Type type)
		{
			try
			{
				Retain();
				if (extraExclude.Contains(type))
				{
					return true;
				}
				int i = 0;
				for (int count = extraExcludeAssignablesTo.Count; i < count; i++)
				{
					if (extraExcludeAssignablesTo[i].IsAssignableFrom(type))
					{
						return true;
					}
				}
				TypeProperties typeProperties = type.GetTypeProperties();
				if (typeProperties.HasAttr<Exclude>())
				{
					return true;
				}
				if (typeProperties.HasAttr<ExcludeAssignablesTo>(inherit: true))
				{
					return true;
				}
				return false;
			}
			finally
			{
				Release();
			}
		}

		private static void QueryFields(int objIdx)
		{
			TypeProperties typeProperties = deconObjs[objIdx].type.GetTypeProperties();
			for (int i = 0; i < typeProperties.fields.Length; i++)
			{
				deconMems[memQty].key.index = i;
				deconObjs[objIdx].memQty++;
				memQty++;
				ValidateMemberCap(memQty);
			}
		}

		private static void DeconstructFields(int objIdx, int startmi)
		{
			TypeProperties typeProperties = deconObjs[objIdx].type.GetTypeProperties();
			int num = deconObjs[objIdx].memQty - (startmi - deconObjs[objIdx].memIdx);
			for (int i = 0; i < num; i++)
			{
				int num2 = startmi + i;
				int index = deconMems[num2].key.index;
				FieldProperties fieldProperties = typeProperties.fields[index];
				deconMems[num2].name = fieldProperties.fullName;
				LogPushMember(deconMems[num2].name);
				DeconstructFieldProperties(fieldProperties, objIdx, ref deconMems[num2].val);
				LogPopMember();
			}
		}

		private static void DeconstructFieldProperties(FieldProperties fProps, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			if (fProps.GetObject != null)
			{
				DeconstructObjectMember(fProps.GetObject(deconObjs[objIdx].obj), objIdx, ref deconVal);
			}
			else if (fProps.GetPrimitive != null)
			{
				DeconstructPrimitiveMember(fProps.GetPrimitive(deconObjs[objIdx].obj), fProps.typeCode, objIdx, ref deconVal);
			}
			else
			{
				UnityEngine.Debug.LogError("No Getter Found!");
			}
		}

		private static void DeconstructIndexedFieldProperties(FieldProperties fProps, int arrIdx, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			if (fProps.GetObjectIndexed != null)
			{
				DeconstructObjectMember(fProps.GetObjectIndexed(deconObjs[objIdx].obj, arrIdx), objIdx, ref deconVal);
			}
			else if (fProps.GetPrimitiveIndexed != null)
			{
				DeconstructPrimitiveMember(fProps.GetPrimitiveIndexed(deconObjs[objIdx].obj, arrIdx), fProps.typeCode, objIdx, ref deconVal);
			}
			else
			{
				UnityEngine.Debug.LogError("No Getter Found!");
			}
		}

		private static void DeconstructPrimitiveMember(primitive val, TypeCode typeCode, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			deconVal.typeCode = (byte)typeCode;
			deconVal.prim = val;
			LogPrimParse(deconVal);
		}

		private static void DeconstructObjectMember(object val, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			TypeCode typeCode = Convert.GetTypeCode(val);
			if (typeCode != 0)
			{
				if (typeCode != TypeCode.Object && typeCode != TypeCode.String)
				{
					DeconstructPrimitiveMember(new primitive(val, typeCode), typeCode, objIdx, ref deconVal);
					return;
				}
				deconVal.typeCode = 1;
				deconVal.index = Deconstruct(val, objIdx);
				if (deconVal.index != -1)
				{
					return;
				}
			}
			deconVal.typeCode = 0;
			LogObjectDeconstruct(-1, objIdx, 0);
		}

		private static void TryDeconstructPrefab(GameObject go, UnityEngine.Component comp, ref int runningPrefabIdx)
		{
			Transform transform;
			if (!object.ReferenceEquals(comp, null))
			{
				transform = comp.transform;
			}
			else
			{
				if (object.ReferenceEquals(go, null))
				{
					return;
				}
				transform = go.transform;
			}
			transform.GetComponentsInParent(includeInactive: true, prefabCompBuffer);
			if (prefabCompBuffer.Count == 0)
			{
				return;
			}
			Serializer_Prefab serializer_Prefab = prefabCompBuffer[0];
			prefabCompBuffer.Clear();
			string resourcePath = serializer_Prefab.resourcePath;
			for (int i = 0; i < runningPrefabIdx; i++)
			{
				if (object.ReferenceEquals(deconPrefabs[i].instance, serializer_Prefab))
				{
					return;
				}
			}
			int num = runningPrefabIdx++;
			ValidatePrefabCap(num);
			try
			{
				deconPrefabs[num].instance = serializer_Prefab;
				for (int j = 0; j < num; j++)
				{
					if (deconPrefabs[j].instance.IsAncestorOf(serializer_Prefab) && deconPrefabs[j].order >= deconPrefabs[num].order)
					{
						deconPrefabs[num].order = (byte)(deconPrefabs[j].order + 1);
					}
				}
			}
			finally
			{
			}
		}

		private static void StartLogging(Type type, bool serialising, string path)
		{
			try
			{
				string text = string.Format("Srz {0}{1} ({2})", DateTime.Now.ToString("dd-MM-yy HH-mm-ss.ffff"), (!serialising) ? " (de)" : string.Empty, type.Name);
				if (path == null)
				{
					path = text;
					char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
					foreach (char oldChar in invalidFileNameChars)
					{
						path = path.Replace(oldChar, '_');
					}
					path = Paths.Make(logFolderPath, path + ".log");
				}
				debugLog = File.CreateText(path);
				debugLog.Write(text);
				debugLog.Flush();
				instanceCounts = new Dictionary<Type, int>(400);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogFormat("Serializer could not begin logging due to {0}", ex);
			}
		}

		private static void LogDeconstructionStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\nDeconstructing...\n\n");
				debugLog.Flush();
			}
		}

		private static void LogObjectDeconstruct(int idx, int ownerIdx, int prefabQty)
		{
			if (debugLog == null)
			{
				return;
			}
			if (idx >= 0)
			{
				debugLog.Write("[{0:D5}] ", idx);
			}
			else
			{
				debugLog.WriteFixed(8, string.Empty);
			}
			foreach (string item in logStack.Reverse())
			{
				debugLog.Write(item);
			}
			debugLog.Write(" = ");
			switch (idx)
			{
			case -1:
				debugLog.Write("null");
				break;
			case -2:
				debugLog.Write("excluded");
				break;
			default:
			{
				if (idx == ownerIdx)
				{
					debugLog.Write("self");
					break;
				}
				debugLog.Write("({0}) ", deconObjs[idx].type.PrettyName());
				if (deconObjs[idx].obj is ICollection collection)
				{
					debugLog.Write('(');
					debugLog.Write("size: ");
					debugLog.Write(collection.Count);
					debugLog.Write(')');
				}
				else if (deconObjs[idx].obj is string str)
				{
					debugLog.Write('"');
					debugLog.WriteCropped(13, str);
					debugLog.Write('"');
				}
				else if (typeof(Type).IsAssignableFrom(deconObjs[idx].type))
				{
					debugLog.Write(((Type)deconObjs[idx].obj).PrettyName());
				}
				else if (Thread.CurrentThread.ManagedThreadId == mainThreadID)
				{
					debugLog.WriteCropped(15, deconObjs[idx].obj.ToString());
				}
				else
				{
					debugLog.Write("(can't stringify off the main thread)");
				}
				Transform transform = null;
				GameObject gameObject;
				UnityEngine.Component component;
				if ((gameObject = deconObjs[idx].obj as GameObject) != null)
				{
					transform = gameObject.transform;
				}
				else if ((component = deconObjs[idx].obj as UnityEngine.Component) != null)
				{
					transform = component.transform;
				}
				if (!(transform != null))
				{
					break;
				}
				for (int i = 0; i < prefabQty; i++)
				{
					if (object.ReferenceEquals(deconPrefabs[i].instance, transform))
					{
						debugLog.Write(" (prefab: \"");
						debugLog.Write(deconPrefabs[i].instance.resourcePath);
						debugLog.Write("\")");
						break;
					}
				}
				break;
			}
			}
			debugLog.Write('\n');
			debugLog.Flush();
		}

		private static void LogPrimParse(string fieldName, DeconstructedMember.Value valRec)
		{
			LogPushMember(fieldName);
			LogPrimParse(valRec);
			LogPopMember();
		}

		private static void LogPrimParse(DeconstructedMember.Value valRec)
		{
			if (debugLog == null)
			{
				return;
			}
			TypeCode typeCode = (TypeCode)valRec.typeCode;
			debugLog.WriteFixed(8, string.Empty);
			foreach (string item in logStack.Reverse())
			{
				debugLog.Write(item);
			}
			debugLog.Write(" = ({0}) {1}\n", typeCode, valRec.prim.ToString(typeCode));
			debugLog.Flush();
		}

		private static void LogPushMember(string name)
		{
			if (debugLog != null)
			{
				logStack.Push("." + name);
			}
		}

		private static void LogPushMemberParse(int idx)
		{
			if (debugLog != null)
			{
				logStack.Push($"[{idx:D2}]");
			}
		}

		private static void LogPushMemberParse(bool key)
		{
			if (debugLog != null)
			{
				logStack.Push((!key) ? ".val" : ".key");
			}
		}

		private static void LogPopMember()
		{
			if (debugLog != null)
			{
				logStack.Pop();
			}
		}

		private static void LogPrefabReadWriteStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\n{0} prefabs...\n\n", prefabQty);
				debugLog.Flush();
			}
		}

		private static void LogPrefabReadWrite(long pos, string prefabPath, string parentPath, string name, Vector3 position, Exception exc = null)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \"{1}\" => \"{2}/", pos, prefabPath, parentPath);
				debugLog.Write(name);
				debugLog.Write("\" (local pos: {0:F2}, {1:F2}, {2:F2})", position.x, position.y, position.z);
				if (exc != null)
				{
					debugLog.Write(" {0}", exc.Message);
				}
				debugLog.Write('\n');
				debugLog.Flush();
			}
		}

		private static void LogObjectReadWriteStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\n{0} objects and {1} members...\n\n", objQty, memQty);
			}
		}

		private static void LogObjectReadWrite(long pos, int idx, Type type)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: [{1:D5}]\n", pos, idx);
				Type type2 = type;
				while (!object.ReferenceEquals(type2, typeof(object)) && !object.ReferenceEquals(type2, typeof(ValueType)))
				{
					int value = 0;
					instanceCounts.TryGetValue(type2, out value);
					instanceCounts[type2] = value + 1;
					type2 = type2.BaseType;
				}
				debugLog.Flush();
			}
		}

		private static void LogArrMemberReadWrite(long pos, int ind, string name, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t[{1:D2}] => ", pos, ind);
				debugLog.WriteFixed(15, name);
				debugLog.Write(" = ");
				LogMemberReadWrite(valRec);
			}
		}

		private static void LogListMemberReadWrite(long pos, int mi, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t[{1:D2}] => ", pos, mi);
				LogMemberReadWrite(valRec);
			}
		}

		private static void LogDictMemberReadWrite(long pos, DeconstructedMember.Value keyRec, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \tkey => ", pos);
				LogMemberReadWrite(keyRec);
				debugLog.Write("{0:D7}: \tval => ", pos);
				LogMemberReadWrite(valRec);
			}
		}

		private static void LogRegularMemberReadWrite(long pos, string name, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t", pos);
				debugLog.WriteFixed(15, name);
				debugLog.Write(" = ");
				LogMemberReadWrite(valRec);
			}
		}

		private static void LogMemberReadWrite(DeconstructedMember.Value valRec)
		{
			TypeCode typeCode = (TypeCode)valRec.typeCode;
			if (typeCode == TypeCode.Empty)
			{
				goto IL_0076;
			}
			if (typeCode == TypeCode.Object || typeCode == TypeCode.String)
			{
				if (valRec.index == -1)
				{
					goto IL_0076;
				}
				if (valRec.index == -2)
				{
					debugLog.Write("excluded\n");
				}
				else
				{
					debugLog.Write("[{0:D5}]\n", valRec.index);
				}
			}
			else
			{
				debugLog.Write("({0}) {1}\n", typeCode, valRec.prim.ToString(typeCode));
			}
			goto IL_00b2;
			IL_0076:
			debugLog.Write("null\n");
			goto IL_00b2;
			IL_00b2:
			debugLog.Flush();
		}

		private static void LogFailedReacquisition(Type type, string path, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("Failed to reacquire [{0:D5}] ", idx);
				debugLog.Write(type.PrettyName());
				debugLog.Write(" at \"");
				debugLog.Write(path);
				debugLog.Write("\"\n");
				debugLog.Flush();
			}
		}

		private static void LogFailedReconstruction(Type type, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("Failed to reconstruct ");
				debugLog.Write(type.PrettyName());
				debugLog.Write(" [{0:D5}]\n", idx);
				debugLog.Flush();
			}
		}

		private static void LogException(Exception exc, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("\nAt object [{0:D5}], got exception {1}\n", idx, exc);
				debugLog.Flush();
			}
		}

		private static void EndLogging(string overrideLogPath)
		{
			if (debugLog == null)
			{
				return;
			}
			debugLog.Write("\nInstance counts ({0}):\n\n", instanceCounts.Count);
			IOrderedEnumerable<KeyValuePair<string, int>> orderedEnumerable = from ic in instanceCounts
				select new KeyValuePair<string, int>(ic.Key.PrettyName(), ic.Value) into ic
				orderby ic.Value descending
				select ic;
			foreach (KeyValuePair<string, int> item in orderedEnumerable)
			{
				debugLog.Write("\t{0, -45}{1}\n", item.Key, item.Value);
			}
			debugLog.Flush();
			debugLog.Close();
			debugLog = null;
			instanceCounts = null;
		}

		[Conditional("CS_DEBUG")]
		[Conditional("ENABLE_PROFILER")]
		private static void PushProfile(string title)
		{
			if (Thread.CurrentThread.ManagedThreadId == mainThreadID)
			{
			}
		}

		[Conditional("CS_DEBUG")]
		[Conditional("ENABLE_PROFILER")]
		private static void PopProfile()
		{
			if (Thread.CurrentThread.ManagedThreadId == mainThreadID)
			{
			}
		}

		private static void ReadPrefab(BinaryReader reader)
		{
			long position = reader.BaseStream.Position;
			string text = reader.ReadString();
			string text2 = reader.ReadString();
			string name = reader.ReadString();
			bool active = reader.ReadBoolean();
			Vector3 vector = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			Vector3 localScale = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			Quaternion localRotation = new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			string text3 = ((!reader.ReadBoolean()) ? null : reader.ReadString());
			try
			{
				GameObject gameObject = null;
				if (text3 != null)
				{
					Type type = Type.GetType(text3, throwOnError: true);
					ExternalPrefabReacquisitor attr = type.GetAttr<ExternalPrefabReacquisitor>(inherit: true);
					gameObject = attr.Reacquire(text, reader);
				}
				else
				{
					gameObject = Resources.Load<GameObject>(text);
				}
				GameObject gameObject2 = GameObject.Find(text2);
				if (object.ReferenceEquals(gameObject2, null))
				{
					throw new Exception("Could not find recorded parent for prefab instance.");
				}
				if (object.ReferenceEquals(gameObject, null))
				{
					throw new Exception("Could not find prefab at recorded path.");
				}
				GameObject gameObject3 = UnityEngine.Object.Instantiate(gameObject);
				if (object.ReferenceEquals(gameObject3, null))
				{
					throw new Exception("Could not instantiate prefab.");
				}
				gameObject3.name = name;
				gameObject3.gameObject.SetActive(active);
				gameObject3.transform.SetParent(gameObject2.transform);
				gameObject3.transform.localPosition = vector;
				gameObject3.transform.localScale = localScale;
				gameObject3.transform.localRotation = localRotation;
				LogPrefabReadWrite(position, text, text2, name, vector);
			}
			catch (Exception ex)
			{
				LogPrefabReadWrite(position, text, text2, name, vector, ex);
				throw ex;
			}
		}

		private static void ReadObject(BinaryReader reader, ref DeconstructedObject record, int objIdx)
		{
			record.type = Type.GetType(reader.ReadString(), throwOnError: true);
			LogObjectReadWrite(reader.BaseStream.Position, objIdx, record.type);
			if (record.type == typeof(string))
			{
				record.obj = reader.ReadString();
				return;
			}
			if (record.type.IsEnum)
			{
				record.obj = Enum.ToObject(record.type, reader.ReadUInt64());
				return;
			}
			if (typeof(ScriptableResource).IsAssignableFrom(record.type) && reader.ReadBoolean())
			{
				string path = reader.ReadString();
				ExternalResourceAcquisitor attr;
				if ((attr = record.type.GetAttr<ExternalResourceAcquisitor>(inherit: true)) != null)
				{
					record.obj = attr.Reacquire(path, record.type, reader);
				}
				else
				{
					record.obj = Resources.Load<UnityEngine.Object>(path);
				}
				if (object.ReferenceEquals(record.obj, null))
				{
					LogFailedReacquisition(record.type, path, objIdx);
				}
				return;
			}
			if (typeof(Type).IsAssignableFrom(record.type))
			{
				record.obj = Type.GetType(reader.ReadString());
				return;
			}
			if (typeof(FieldInfo).IsAssignableFrom(record.type))
			{
				string typeName = reader.ReadString();
				string name = reader.ReadString();
				Type type = Type.GetType(typeName);
				record.obj = type.GetField(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				return;
			}
			record.memQty = reader.ReadInt32();
			try
			{
				IExternalConstructor value;
				if (typeof(GameObject).IsAssignableFrom(record.type))
				{
					string text = reader.ReadString();
					record.obj = GameObject.Find(text);
					if (object.ReferenceEquals(record.obj, null))
					{
						LogFailedReacquisition(record.type, text, objIdx);
					}
				}
				else if (typeof(UnityEngine.Component).IsAssignableFrom(record.type))
				{
					string text2 = reader.ReadString();
					GameObject gameObject = GameObject.Find(text2);
					if (!object.ReferenceEquals(gameObject, null))
					{
						record.obj = gameObject.GetComponent(record.type);
					}
					else
					{
						LogFailedReacquisition(record.type, text2, objIdx);
					}
				}
				else if ((value = record.type.GetAttr<ExternalConstructor>()) != null)
				{
					record.obj = value.Reconstruct(record.type, reader);
				}
				else if (extraExternalConstructor.TryGetValue(record.type, out value))
				{
					record.obj = value.Reconstruct(record.type, reader);
				}
				else if (typeof(ISelfConstructor).IsAssignableFrom(record.type))
				{
					constrParams[0] = reader;
					record.obj = Activator.CreateInstance(record.type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, constrParams, null);
				}
				else if (typeof(ScriptableObject).IsAssignableFrom(record.type))
				{
					record.obj = ScriptableObject.CreateInstance(record.type);
				}
				else
				{
					if (record.type.IsArray)
					{
						int num = reader.ReadInt32();
						Array array = (Array)(record.obj = Array.CreateInstance(record.type.GetElementType(), num));
						if (record.type.GetElementType().IsPrimitive)
						{
							if (array is byte[] buffer)
							{
								reader.Read(buffer, 0, record.memQty);
							}
							else
							{
								int num2 = record.memQty * record.type.GetElementType().PrimitiveSize();
								for (int i = 0; i < num2; i += bufferBuffer.Length)
								{
									int count = Mathf.Min(bufferBuffer.Length, num2 - i);
									reader.Read(bufferBuffer, 0, count);
									Buffer.BlockCopy(bufferBuffer, 0, array, i, count);
								}
							}
							record.memQty = 0;
							return;
						}
						record.memIdx = memQty;
						record.elementSize = reader.ReadInt32();
						int num3 = record.memIdx;
						TypeProperties typeProperties = record.type.GetTypeProperties();
						if (typeProperties.arrayType.IsValueType)
						{
							for (int j = 0; j < num; j++)
							{
								for (int k = 0; k < record.elementSize; k++)
								{
									deconMems[num3].name = reader.ReadString();
									ReadMemberValue(reader, ref deconMems[num3].val);
									LogArrMemberReadWrite(reader.BaseStream.Position, j, deconMems[num3].name, deconMems[num3].val);
									num3++;
								}
							}
							record.memQty = num3 - record.memIdx;
						}
						else
						{
							for (int l = 0; l < record.memQty; l++)
							{
								long position = reader.BaseStream.Position;
								int num4 = record.memIdx + l;
								ReadMemberValue(reader, ref deconMems[num4].val);
								deconMems[num4].key.custom = reader.ReadBoolean();
								LogListMemberReadWrite(position, l, deconMems[num4].val);
							}
						}
						memQty += record.memQty;
						return;
					}
					record.obj = Activator.CreateInstance(record.type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, null, null);
				}
				if (record.memQty == 0)
				{
					return;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log(ex);
				LogFailedReconstruction(record.type, objIdx);
				throw ex;
			}
			record.memIdx = memQty;
			memQty += record.memQty;
			ValidateMemberCap(record.memIdx + record.memQty);
			for (int m = 0; m < record.memQty; m++)
			{
				long position2 = reader.BaseStream.Position;
				int num5 = record.memIdx + m;
				deconMems[num5].name = reader.ReadString();
				ReadMemberValue(reader, ref deconMems[num5].val);
				deconMems[num5].key.custom = reader.ReadBoolean();
				LogRegularMemberReadWrite(position2, deconMems[num5].name, deconMems[num5].val);
			}
		}

		private static void ReadMemberValue(BinaryReader reader, ref DeconstructedMember.Value val)
		{
			val.typeCode = reader.ReadByte();
			TypeCode typeCode = (TypeCode)val.typeCode;
			if (typeCode != 0 && !reader.TryRead(typeCode, ref val.prim))
			{
				val.index = reader.ReadInt32();
			}
		}

		private static void ReconstructMembers(BinaryReader reader, ref DeconstructedObject record)
		{
			if (record.obj == null || record.memQty == 0)
			{
				return;
			}
			int i = 0;
			object val;
			if (record.obj is Array { Length: var length } array)
			{
				int num = record.memIdx;
				TypeProperties typeProperties = record.type.GetTypeProperties();
				object[] array2 = ((!typeProperties.arrayType.IsValueType) ? (record.obj as object[]) : null);
				if (array2 == null)
				{
					for (int j = 0; j < length; j++)
					{
						for (int k = 0; k < record.elementSize; k++)
						{
							if (!ReconstructMemberValue(deconMems[num].val, out val))
							{
								continue;
							}
							FieldProperties[] fields = typeProperties.fields;
							foreach (FieldProperties fieldProperties in fields)
							{
								if (fieldProperties.fullName == deconMems[num].name)
								{
									fieldProperties.SetObjectValueIndexed(array, j, val);
									break;
								}
							}
							num++;
						}
					}
				}
				else
				{
					for (int m = 0; m < length; m++)
					{
						ReconstructMemberValue(deconMems[record.memIdx + m].val, out val);
						array2[m] = val;
					}
				}
				return;
			}
			GameObject gameObject;
			UnityEngine.Component component;
			if (!object.ReferenceEquals(gameObject = record.obj as GameObject, null))
			{
				int num2 = record.memIdx + i++;
				gameObject.SetActive(deconMems[num2].val.prim.@bool);
			}
			else if (!object.ReferenceEquals(component = record.obj as UnityEngine.Component, null))
			{
				int num3 = record.memIdx + i++;
				component.gameObject.SetActive(deconMems[num3].val.prim.@bool);
				MonoBehaviour monoBehaviour;
				if (!record.type.HasAttr<ExcludeEnabled>() && !object.ReferenceEquals(monoBehaviour = record.obj as MonoBehaviour, null))
				{
					num3 = record.memIdx + i++;
					monoBehaviour.enabled = deconMems[num3].val.prim.@bool;
				}
			}
			FieldProperties[] fields2 = record.type.GetTypeProperties().fields;
			for (; i < record.memQty; i++)
			{
				int num4 = record.memIdx + i;
				if (deconMems[num4].key.custom || !ReconstructMemberValue(deconMems[num4].val, out val))
				{
					continue;
				}
				string name = deconMems[num4].name;
				FieldProperties[] array3 = fields2;
				foreach (FieldProperties fieldProperties2 in array3)
				{
					if (fieldProperties2.fullName == deconMems[num4].name)
					{
						try
						{
							fieldProperties2.SetObjectValue(record.obj, val);
						}
						catch
						{
							UnityEngine.Debug.Log("Wowwee");
						}
						break;
					}
				}
			}
		}

		private static void SelfRecompose(BinaryReader reader, int idx, ref DeconstructedObject record)
		{
			if (!(record.obj is ISelfComposer selfComposer))
			{
				return;
			}
			for (int i = 0; i < record.memQty; i++)
			{
				int num = record.memIdx + i;
				if (deconMems[num].key.custom && ReconstructMemberValue(deconMems[num].val, out var val))
				{
					customMemberBuffer.members[deconMems[num].name] = val;
				}
			}
			selfComposer.Recompose(customMemberBuffer);
			customMemberBuffer.members.Clear();
		}

		private static bool ReconstructMemberValue(DeconstructedMember.Value decon, out object val)
		{
			val = null;
			TypeCode typeCode = (TypeCode)decon.typeCode;
			switch (typeCode)
			{
			case TypeCode.Object:
			case TypeCode.String:
				if (decon.index == -2)
				{
					return false;
				}
				if (decon.index != -1)
				{
					val = deconObjs[decon.index].obj;
				}
				break;
			default:
				val = decon.prim.Get(typeCode);
				break;
			case TypeCode.Empty:
				break;
			}
			return true;
		}

		private static bool WritePrefabs(BinaryWriter writer, byte order, int prefabQty)
		{
			bool result = false;
			for (int i = 0; i < prefabQty; i++)
			{
				if (deconPrefabs[i].order != order)
				{
					continue;
				}
				result = true;
				try
				{
					Serializer_Prefab instance = deconPrefabs[i].instance;
					string resourcePath = instance.resourcePath;
					string scenePath = instance.gameObject.GetScenePath(includeSelf: false);
					string name = instance.name;
					bool activeSelf = instance.gameObject.activeSelf;
					Vector3 localPosition = instance.transform.localPosition;
					Vector3 localScale = instance.transform.localScale;
					Quaternion localRotation = instance.transform.localRotation;
					LogPrefabReadWrite(writer.BaseStream.Position, resourcePath, scenePath, name, localPosition);
					writer.Write(resourcePath);
					writer.Write(scenePath);
					writer.Write(name);
					writer.Write(activeSelf);
					writer.Write(localPosition.x);
					writer.Write(localPosition.y);
					writer.Write(localPosition.z);
					writer.Write(localScale.x);
					writer.Write(localScale.y);
					writer.Write(localScale.z);
					writer.Write(localRotation.x);
					writer.Write(localRotation.y);
					writer.Write(localRotation.z);
					writer.Write(localRotation.w);
					Type type = instance.GetType();
					TypeProperties typeProperties = type.GetTypeProperties();
					ExternalPrefabReacquisitor attr = typeProperties.GetAttr<ExternalPrefabReacquisitor>(inherit: true);
					writer.Write(attr != null);
					if (attr != null)
					{
						writer.Write(typeProperties.assemblyQualifiedName);
						attr.Deacquire(instance, writer);
					}
				}
				finally
				{
				}
			}
			return result;
		}

		private static void WriteObject(BinaryWriter writer, int idx)
		{
			Type type = deconObjs[idx].type;
			TypeProperties typeProperties = type.GetTypeProperties();
			object obj = deconObjs[idx].obj;
			LogObjectReadWrite(writer.BaseStream.Position, idx, type);
			writer.Write(typeProperties.assemblyQualifiedName);
			switch (deconObjs[idx].hint)
			{
			case 1:
				writer.Write((string)obj);
				return;
			case 2:
				writer.Write(Convert.ToInt64(obj));
				return;
			case 3:
			{
				ScriptableResource scriptableResource = (ScriptableResource)obj;
				bool flag = scriptableResource.resourcePath != null;
				writer.Write(flag);
				if (!flag)
				{
					break;
				}
				writer.Write(scriptableResource.resourcePath);
				ExternalResourceAcquisitor attr;
				if ((attr = typeProperties.GetAttr<ExternalResourceAcquisitor>(inherit: true)) != null)
				{
					attr.Deacquire(scriptableResource, type, writer);
				}
				return;
			}
			case 4:
			{
				TypeProperties typeProperties3 = ((Type)obj).GetTypeProperties();
				writer.Write(typeProperties3.assemblyQualifiedName);
				return;
			}
			case 5:
			{
				FieldInfo fieldInfo = (FieldInfo)obj;
				TypeProperties typeProperties2 = fieldInfo.DeclaringType.GetTypeProperties();
				writer.Write(typeProperties2.assemblyQualifiedName);
				writer.Write(fieldInfo.Name);
				return;
			}
			}
			writer.Write(deconObjs[idx].memQty);
			switch (deconObjs[idx].hint)
			{
			case 6:
			{
				if (obj is byte[] array)
				{
					writer.Write(array.Length);
					writer.Write(array, 0, deconObjs[idx].memQty);
					return;
				}
				Array array2 = (Array)obj;
				writer.Write(array2.Length);
				if (typeProperties.arrayType.IsPrimitive)
				{
					int num = deconObjs[idx].memQty * typeProperties.arrayType.PrimitiveSize();
					for (int i = 0; i < num; i += bufferBuffer.Length)
					{
						int count = Mathf.Min(bufferBuffer.Length, num - i);
						Buffer.BlockCopy(array2, i, bufferBuffer, 0, count);
						writer.Write(bufferBuffer, 0, count);
					}
					return;
				}
				int num2 = typeProperties.fields.Length;
				bool isValueType = typeProperties.arrayType.IsValueType;
				writer.Write(deconObjs[idx].elementSize);
				if (isValueType)
				{
					int num3 = deconObjs[idx].memIdx;
					for (int j = 0; j < array2.Length; j++)
					{
						for (int k = 0; k < deconObjs[idx].elementSize; k++)
						{
							LogArrMemberReadWrite(writer.BaseStream.Position, j, deconMems[num3].name, deconMems[num3].val);
							writer.Write(deconMems[num3].name);
							WriteMemberValue(writer, deconMems[num3].val);
							num3++;
						}
					}
				}
				else
				{
					for (int l = 0; l < deconObjs[idx].memQty; l++)
					{
						int num4 = deconObjs[idx].memIdx + l;
						LogListMemberReadWrite(writer.BaseStream.Position, l, deconMems[num4].val);
						WriteMemberValue(writer, deconMems[num4].val);
						writer.Write(deconMems[num4].key.custom);
					}
				}
				return;
			}
			case 7:
				writer.Write(((GameObject)obj).GetScenePath());
				break;
			case 8:
				writer.Write(((UnityEngine.Component)obj).gameObject.GetScenePath());
				break;
			default:
			{
				IExternalConstructor value;
				if ((value = typeProperties.GetAttr<ExternalConstructor>()) != null)
				{
					value.Deconstruct(obj, type, writer);
				}
				else if (extraExternalConstructor.TryGetValue(type, out value))
				{
					value.Deconstruct(obj, type, writer);
				}
				else if (obj is ISelfConstructor selfConstructor)
				{
					selfConstructor.Deconstruct(writer);
				}
				break;
			}
			}
			for (int m = 0; m < deconObjs[idx].memQty; m++)
			{
				int num5 = deconObjs[idx].memIdx + m;
				LogRegularMemberReadWrite(writer.BaseStream.Position, deconMems[num5].name, deconMems[num5].val);
				writer.Write(deconMems[num5].name);
				WriteMemberValue(writer, deconMems[num5].val);
				writer.Write(deconMems[num5].key.custom);
			}
		}

		private static void WriteMemberValue(BinaryWriter writer, DeconstructedMember.Value val)
		{
			writer.Write(val.typeCode);
			TypeCode typeCode = (TypeCode)val.typeCode;
			if (typeCode != 0 && !writer.TryWrite(typeCode, val.prim))
			{
				writer.Write(val.index);
			}
		}
	}
	public class Serializer_ModelPrefab : MonoBehaviour
	{
		[ReadOnly]
		public string path;

		private void Awake()
		{
			UnityEngine.Object.DestroyImmediate(this, allowDestroyingAssets: true);
		}
	}
	public class Serializer_ModelPrefabList : ScriptableResource
	{
		private void Awake()
		{
			UnityEngine.Object.DestroyImmediate(this, allowDestroyingAssets: true);
		}
	}
	public class Serializer_Prefab : MonoBehaviour
	{
		[ReadOnly]
		[SerializeField]
		private string _resourcePath;

		public string resourcePath => _resourcePath;

		protected virtual bool requiresResourceFolder => true;
	}
}
public static class FMODInitEnums
{
	[Flags]
	public enum LowLevelInitFlags
	{
		Normal = 0,
		StreamFromUpdate = 1,
		MixFromUpdate = 2,
		Righthanded3D = 4,
		ChannelLowpass = 0x100,
		ChannelDistanceFilter = 0x200,
		ProfileEnable = 0x10000,
		Vol0BecomesVirtual = 0x20000,
		GeometryUseClosest = 0x40000,
		PreferDolbyDownmix = 0x80000,
		ThreadUnsafe = 0x100000,
		ProfileMeterAll = 0x200000
	}

	[Flags]
	public enum StudioInitFlags
	{
		Normal = 0,
		LiveUpdate = 1,
		AllowMissingPlugins = 2,
		SynchronousUpdate = 4
	}

	public static LowLevelInitFlags ToUnityLLIF(this FMOD.INITFLAGS fmodllif)
	{
		return (LowLevelInitFlags)fmodllif;
	}

	public static FMOD.INITFLAGS ToFMODLLIF(this LowLevelInitFlags unityllif)
	{
		return (FMOD.INITFLAGS)unityllif;
	}

	public static StudioInitFlags ToUnitySTIF(this FMOD.Studio.INITFLAGS fmodstif)
	{
		return (StudioInitFlags)fmodstif;
	}

	public static FMOD.Studio.INITFLAGS ToFMODSTIF(this StudioInitFlags unitystif)
	{
		return (FMOD.Studio.INITFLAGS)unitystif;
	}
}
public class AC : MonoBehaviour
{
	public delegate void BankLoadCallback(Bank bank, LOADING_STATE bankState, LOADING_STATE sampleState);

	private struct GuidAOT
	{
		public class GuidEQ : EqualityComparer<GuidAOT>
		{
			public override bool Equals(GuidAOT x, GuidAOT y)
			{
				return x.theGuid.Equals(y.theGuid);
			}

			public override int GetHashCode(GuidAOT obj)
			{
				return obj.theGuid.GetHashCode();
			}
		}

		private Guid theGuid;

		private GuidAOT(Guid theGuid)
		{
			this.theGuid = theGuid;
		}

		public static implicit operator Guid(GuidAOT guidAOT)
		{
			return guidAOT.theGuid;
		}

		public static implicit operator GuidAOT(Guid guidSys)
		{
			return new GuidAOT(guidSys);
		}
	}

	private struct LoadingTracker
	{
		private readonly Bank bank;

		private readonly BankLoadCallback callback;

		private bool unloadBank;

		private bool completeLoadUnload;

		public LoadingTracker(FMOD.Studio.System sys, string bankPath, bool incSampleData, BankLoadCallback callback)
		{
			if (sys.loadBankFile(bankPath, LOAD_BANK_FLAGS.NONBLOCKING, out bank) != 0)
			{
			}
			completeLoadUnload = incSampleData;
			unloadBank = false;
			this.callback = callback;
		}

		public LoadingTracker(Bank bank, bool unloadBank, bool completeLoadUnload, BankLoadCallback callback)
		{
			this.bank = bank;
			this.unloadBank = unloadBank;
			this.completeLoadUnload = completeLoadUnload;
			this.callback = callback;
		}

		public bool Update()
		{
			bank.getLoadingState(out var state);
			bank.getSampleLoadingState(out var state2);
			if (unloadBank)
			{
				if (completeLoadUnload)
				{
					if (state != 0)
					{
						if (state == LOADING_STATE.LOADED && CommandSucceeded(bank.unload(), "Unload command failed."))
						{
							return false;
						}
						IsExpectedLoadingState(state, LOADING_STATE.UNLOADED, "Unloading failed.");
						return MakeCallback(bank, state, state2);
					}
				}
				else if (state2 != 0)
				{
					if (state2 == LOADING_STATE.LOADED && CommandSucceeded(bank.unloadSampleData(), "Unload sample data command failed."))
					{
						return false;
					}
					IsExpectedLoadingState(state2, LOADING_STATE.UNLOADED, "Sample data unloading failed.");
					return MakeCallback(bank, state, state2);
				}
			}
			else if (state != LOADING_STATE.LOADING)
			{
				if (IsExpectedLoadingState(state, LOADING_STATE.LOADED, "Loading failed."))
				{
					if (!completeLoadUnload)
					{
						return MakeCallback(bank, state, state2);
					}
					if (state2 != LOADING_STATE.LOADING)
					{
						if (state2 == LOADING_STATE.UNLOADED && CommandSucceeded(bank.loadSampleData(), "Load sample data command failed."))
						{
							return false;
						}
						IsExpectedLoadingState(state2, LOADING_STATE.LOADED, "Sample data loading failed.");
						return MakeCallback(bank, state, state2);
					}
				}
				else
				{
					unloadBank = true;
					completeLoadUnload = true;
					if (!CommandSucceeded(bank.unload(), "Unload command failed."))
					{
						return MakeCallback(bank, state, state2);
					}
				}
			}
			return false;
		}

		private bool CommandSucceeded(RESULT result, string errMessage)
		{
			if (result != 0)
			{
				if (bank.getPath(out var path) != 0)
				{
					path = "failed to retrieve path";
				}
				return false;
			}
			return true;
		}

		private bool IsExpectedLoadingState(LOADING_STATE loadingState, LOADING_STATE expectedState, string errMessage)
		{
			if (loadingState != expectedState)
			{
				if (bank.getPath(out var path) != 0)
				{
					path = "failed to retrieve path";
				}
				return false;
			}
			return true;
		}

		private bool MakeCallback(Bank bank, LOADING_STATE bankState, LOADING_STATE sampleState)
		{
			if (callback != null)
			{
				try
				{
					callback(bank, bankState, sampleState);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
			return true;
		}
	}

	private struct ACHandleTransformContainer
	{
		public FMOD.Studio.EventInstance eventInstance;

		public Transform eventTransform;
	}

	private struct ACHandleContainer
	{
		public FMOD.Studio.EventInstance eventInstance;

		public Action onComplete;
	}

	private static AC _instance;

	[EnumFlagsField]
	public FMODInitEnums.LowLevelInitFlags lowLevelInitFlags;

	[EnumFlagsField]
	public FMODInitEnums.StudioInitFlags studioInitFlags;

	public const string mainBankPath = "FMOD Banks/Master Bank.bank";

	public const string stringBankPath = "FMOD Banks/Master Bank.strings.bank";

	public const string externalBankPath = "FMOD Banks/Externals.bank";

	public int maxChannels;

	public float virtualVolume;

	private ConstArray<ACHandleTransformContainer> eventsWithTransforms = new ConstArray<ACHandleTransformContainer>(32u);

	private ConstArray<ACHandleContainer> eventsWithcallbacks = new ConstArray<ACHandleContainer>(32u);

	private readonly Dictionary<GuidAOT, EventDescription> descriptionByGuid = new Dictionary<GuidAOT, EventDescription>(new GuidAOT.GuidEQ());

	private readonly Dictionary<string, EventDescription> descriptionByPath = new Dictionary<string, EventDescription>();

	private readonly List<LoadingTracker> loadingTrackers = new List<LoadingTracker>();

	private Bus subMix;

	private FMOD.Studio.System _sys;

	private static string[] pluginPaths = new string[1] { "ovrfmod" };

	public static AC Inst
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.Instantiate(Resources.Load<AC>("Controllers/P_AudioController"));
				_instance.Initialized = false;
				UnityEngine.Object.DontDestroyOnLoad(_instance);
			}
			return _instance;
		}
	}

	public bool loadingUnloading => loadingTrackers.Count > 0;

	public FMOD.Studio.System sys => _sys;

	public bool Initialized { get; private set; }

	private static string pluginPath
	{
		get
		{
			if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor)
			{
				return UnityEngine.Application.dataPath + "/Plugins/x86";
			}
			if (UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer || UnityEngine.Application.platform == RuntimePlatform.OSXEditor || UnityEngine.Application.platform == RuntimePlatform.OSXPlayer || UnityEngine.Application.platform == RuntimePlatform.OSXDashboardPlayer || UnityEngine.Application.platform == RuntimePlatform.LinuxPlayer)
			{
				return UnityEngine.Application.dataPath + "/Plugins";
			}
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return UnityEngine.Application.persistentDataPath;
			}
			return string.Empty;
		}
	}

	private static FMOD.Studio.System CreateFMODSSys(int maxChannels, float virtualVolume, FMOD.INITFLAGS llInitFlags, FMOD.Studio.INITFLAGS studioInitFlags)
	{
		RESULT rESULT = FMOD.Studio.System.create(out var studiosystem);
		if (rESULT == RESULT.OK)
		{
			if ((studioInitFlags & FMOD.Studio.INITFLAGS.LIVEUPDATE) == FMOD.Studio.INITFLAGS.LIVEUPDATE)
			{
				FMOD.ADVANCEDSETTINGS settings = default(FMOD.ADVANCEDSETTINGS);
				studiosystem.getLowLevelSystem(out var system);
				settings.profilePort = 9265;
				settings.vol0virtualvol = virtualVolume;
				system.setAdvancedSettings(ref settings);
			}
			rESULT = studiosystem.initialize(maxChannels, studioInitFlags, llInitFlags, IntPtr.Zero);
			if (rESULT == RESULT.OK)
			{
				if ((studioInitFlags & FMOD.Studio.INITFLAGS.LIVEUPDATE) == FMOD.Studio.INITFLAGS.LIVEUPDATE)
				{
					studiosystem.flushCommands();
					rESULT = studiosystem.update();
					if (rESULT == RESULT.ERR_NET_SOCKET_ERROR)
					{
						studiosystem.release();
						return CreateFMODSSys(maxChannels, virtualVolume, llInitFlags, studioInitFlags & ~FMOD.Studio.INITFLAGS.LIVEUPDATE);
					}
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Failed to initialize system: " + rESULT);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("Failed to create system: " + rESULT);
		}
		return studiosystem;
	}

	public bool LoadBankSyncIfNotLoaded(string bankPath, bool includeSamples)
	{
		if (!sys.isValid())
		{
			return false;
		}
		sys.getBank(bankPath, out var bank);
		if (bank.isValid())
		{
			return true;
		}
		return LoadBankSync(bankPath, includeSamples);
	}

	public bool LoadBankSync(string bankPath, bool includeSamples)
	{
		if (!sys.isValid())
		{
			return false;
		}
		if (sys.loadBankFile(bankPath, LOAD_BANK_FLAGS.NORMAL, out var bank) != 0)
		{
			return false;
		}
		if (includeSamples)
		{
			LoadBankSamplesSync(bank);
		}
		return true;
	}

	public bool LoadBankSamplesSync(Bank bank)
	{
		if (!sys.isValid())
		{
			return false;
		}
		string path;
		RESULT path2 = bank.getPath(out path);
		if (bank.getPath(out path) != 0)
		{
			path = "failed to retrieve path :" + path2;
		}
		if (bank.loadSampleData() != 0)
		{
			return false;
		}
		while (true)
		{
			sys.update();
			bank.getSampleLoadingState(out var state);
			switch (state)
			{
			case LOADING_STATE.LOADING:
				break;
			default:
				return false;
			case LOADING_STATE.LOADED:
				return true;
			}
		}
	}

	public bool UnloadBankSync(Bank bank, bool justSamples)
	{
		if (!sys.isValid())
		{
			return false;
		}
		RESULT path2 = bank.getPath(out var path);
		if (bank.getPath(out path) != 0)
		{
			path = "failed to retrieve path :" + path2;
		}
		if (((!justSamples) ? bank.unload() : bank.unloadSampleData()) != 0)
		{
			return false;
		}
		LOADING_STATE state;
		do
		{
			sys.update();
			path2 = ((!justSamples) ? bank.getLoadingState(out state) : bank.getSampleLoadingState(out state));
		}
		while (state == LOADING_STATE.UNLOADING && path2 == RESULT.OK);
		if (state != LOADING_STATE.UNLOADED)
		{
			return false;
		}
		return true;
	}

	public void LoadBank(string bankPath, bool includeSamples, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(sys, bankPath, includeSamples, callback));
	}

	public void LoadBankSamples(Bank bank, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(bank, unloadBank: false, completeLoadUnload: true, callback));
	}

	public void UnloadBank(Bank bank, bool justSamples, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(bank, unloadBank: true, !justSamples, callback));
	}

	public EventDescription GetDescription(FMODEventAsset asset)
	{
		EventDescription description = GetDescription(asset.fmodGUID);
		if (!description.isValid())
		{
		}
		return description;
	}

	public EventDescription GetDescription(string path)
	{
		if (!descriptionByPath.TryGetValue(path, out var value))
		{
			if ((sys.isValid() && sys.getEvent(path, out value) != 0) || !value.isValid())
			{
				return default(EventDescription);
			}
			descriptionByPath[path] = value;
		}
		return value;
	}

	public EventDescription GetDescription(Guid fmodGUID)
	{
		if (!descriptionByGuid.TryGetValue(fmodGUID, out var value) || !value.isValid())
		{
			if ((sys.isValid() && sys.getEventByID(fmodGUID, out value) != 0) || !value.isValid())
			{
				return default(EventDescription);
			}
			descriptionByGuid[fmodGUID] = value;
		}
		return value;
	}

	public FMOD.Studio.EventInstance GetHandle(FMODEventAsset asset)
	{
		if (!sys.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		if (asset == null)
		{
			return default(FMOD.Studio.EventInstance);
		}
		FMOD.Studio.EventInstance handle = GetHandle(asset.fmodGUID);
		if (!handle.isValid())
		{
		}
		return handle;
	}

	public FMOD.Studio.EventInstance GetHandle(string path)
	{
		EventDescription description = GetDescription(path);
		if (!description.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		FMOD.Studio.EventInstance handle = GetHandle(description);
		if (!handle.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		return handle;
	}

	public FMOD.Studio.EventInstance GetHandle(Guid fmodGUID)
	{
		EventDescription description = GetDescription(fmodGUID);
		if (!description.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		FMOD.Studio.EventInstance handle = GetHandle(description);
		if (!handle.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		return handle;
	}

	public FMOD.Studio.EventInstance GetHandle(EventDescription desc)
	{
		if (!desc.isValid() || desc.createInstance(out var instance) != 0 || !instance.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		return instance;
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(FMOD.Studio.EventInstance handle, Vector3 position, Action onComplete = null)
	{
		if (!handle.isValid())
		{
			return handle;
		}
		if (SuppressDuringSkip(handle))
		{
			return handle;
		}
		handle.set3DAttributes(position.to3DAttributes());
		handle.start();
		if (onComplete == null)
		{
			handle.release();
		}
		else
		{
			ACHandleContainer obj = default(ACHandleContainer);
			obj.eventInstance = handle;
			obj.onComplete = onComplete;
			eventsWithcallbacks.Add(obj);
		}
		return handle;
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(FMOD.Studio.EventInstance handle, Transform trans, Action onComplete = null, bool suppressDuringSkip = true)
	{
		if (!handle.isValid())
		{
			return handle;
		}
		if (SuppressDuringSkip(handle))
		{
			return handle;
		}
		if (trans != null)
		{
			handle.set3DAttributes(trans.position.to3DAttributes());
			ACHandleTransformContainer obj = default(ACHandleTransformContainer);
			obj.eventInstance = handle;
			obj.eventTransform = trans;
			eventsWithTransforms.Add(obj);
		}
		handle.start();
		if (onComplete == null)
		{
			handle.release();
		}
		else
		{
			ACHandleContainer obj2 = default(ACHandleContainer);
			obj2.eventInstance = handle;
			obj2.onComplete = onComplete;
			eventsWithcallbacks.Add(obj2);
		}
		return handle;
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(FMODEventAsset asset, Vector3 position, Action onComplete = null)
	{
		return PlayOneShot3D(GetHandle(asset), position, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(FMODEventAsset asset, Transform trans, Action onComplete = null)
	{
		return PlayOneShot3D(GetHandle(asset), trans, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(string path, Vector3 position, Action onComplete = null)
	{
		if (string.IsNullOrEmpty(path))
		{
			return default(FMOD.Studio.EventInstance);
		}
		return PlayOneShot3D(GetHandle(path), position, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot3D(string path, Transform trans, Action onComplete = null)
	{
		if (string.IsNullOrEmpty(path))
		{
			return default(FMOD.Studio.EventInstance);
		}
		return PlayOneShot3D(GetHandle(path), trans, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot2D(string path, Action onComplete = null)
	{
		return PlayOneShot3D(path, Vector3.zero, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot2D(FMODEventAsset asset, Action onComplete = null)
	{
		return PlayOneShot3D(asset, Vector3.zero, onComplete);
	}

	public FMOD.Studio.EventInstance PlayOneShot2D(FMOD.Studio.EventInstance handle, Action onComplete = null)
	{
		return PlayOneShot3D(handle, Vector3.zero, onComplete);
	}

	public static void Stop(FMOD.Studio.EventInstance evtInst, bool release = false)
	{
		if (evtInst.isValid())
		{
			evtInst.stop(((bool)MR.Inst && MR.Inst.IsSkipping()) ? STOP_MODE.IMMEDIATE : STOP_MODE.ALLOWFADEOUT);
			if (release)
			{
				evtInst.release();
			}
		}
	}

	private bool SuppressDuringSkip(FMOD.Studio.EventInstance handle)
	{
		if (!MR.Inst)
		{
			return false;
		}
		if (!MR.Inst.IsSkipping())
		{
			return false;
		}
		if (handle.getDescription(out var description) != 0)
		{
			return false;
		}
		if (description.isOneshot(out var oneshot) != 0)
		{
			return false;
		}
		return oneshot;
	}

	public FMOD.Studio.EventInstance PlaySnapshot(string path)
	{
		if (path == null)
		{
			return default(FMOD.Studio.EventInstance);
		}
		EventDescription description = GetDescription(path);
		if (description.isValid())
		{
			description.isSnapshot(out var snapshot);
			if (!snapshot)
			{
				return default(FMOD.Studio.EventInstance);
			}
		}
		FMOD.Studio.EventInstance handle = GetHandle(description);
		if (!handle.isValid())
		{
			return default(FMOD.Studio.EventInstance);
		}
		handle.start();
		handle.release();
		return handle;
	}

	public void Init(bool threaded)
	{
		if (Initialized)
		{
			return;
		}
		ACMisc.EnforceLibraryOrder();
		Action action = delegate
		{
			try
			{
				_sys = CreateFMODSSys(maxChannels, virtualVolume, lowLevelInitFlags.ToFMODLLIF(), studioInitFlags.ToFMODSTIF());
			}
			finally
			{
				Initialized = true;
			}
		};
		if (threaded)
		{
			AEResources.AddThreadTask(action);
		}
		else
		{
			action();
		}
	}

	public void PostMasterInit()
	{
		sys.getBus("bus:/sub mix", out subMix);
		if (!VolumeLevels.Inst.IsLoaded)
		{
			VolumeLevels.Inst.Load();
		}
	}

	public static void LoadPlugins(FMOD.System system)
	{
		string[] array = pluginPaths;
		foreach (string rawName in array)
		{
			string pluginFileName = GetPluginFileName(rawName);
			string text;
			if (UnityEngine.Application.platform == RuntimePlatform.Android || UnityEngine.Application.platform == RuntimePlatform.LinuxPlayer)
			{
				UnpackAndroidPlugin(pluginFileName);
				text = pluginPath;
			}
			text = pluginPath + "/" + pluginFileName;
			ERRCHECK(system.loadPlugin(text, out var _));
		}
	}

	private static void UnpackAndroidPlugin(string fileName)
	{
		string url = "jar:file://" + UnityEngine.Application.dataPath + "!/lib/armeabi-v7a/" + fileName;
		string path = UnityEngine.Application.persistentDataPath + "/" + fileName;
		if (File.Exists(path))
		{
			File.Delete(path);
		}
		WWW wWW = new WWW(url);
		while (!wWW.isDone)
		{
		}
		File.WriteAllBytes(path, wWW.bytes);
	}

	private static void ERRCHECK(RESULT result)
	{
		if (result == RESULT.OK)
		{
		}
	}

	private static string GetPluginFileName(string rawName)
	{
		if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
		{
			return rawName + ".dll";
		}
		if (UnityEngine.Application.platform == RuntimePlatform.OSXEditor || UnityEngine.Application.platform == RuntimePlatform.OSXPlayer || UnityEngine.Application.platform == RuntimePlatform.OSXDashboardPlayer)
		{
			return rawName + ".dylib";
		}
		if (UnityEngine.Application.platform == RuntimePlatform.Android || UnityEngine.Application.platform == RuntimePlatform.LinuxPlayer)
		{
			return rawName + ".so";
		}
		return string.Empty;
	}

	public static string GetStreamingAsset(string fileName)
	{
		return UnityEngine.Application.persistentDataPath + "/" + fileName;
	}

	private void OnDestroy()
	{
		if (sys.isValid())
		{
			sys.release();
		}
		_instance = null;
	}

	private void Update()
	{
		int num = 0;
		while (num < loadingTrackers.Count)
		{
			if (loadingTrackers[num].Update())
			{
				loadingTrackers.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
		if (sys.isValid())
		{
			sys.update();
		}
		uint num2 = 0u;
		while (num2 < eventsWithcallbacks.Length)
		{
			ACHandleContainer aCHandleContainer = eventsWithcallbacks[num2];
			aCHandleContainer.eventInstance.getPlaybackState(out var state);
			if (state == PLAYBACK_STATE.STOPPING || state == PLAYBACK_STATE.STOPPED)
			{
				aCHandleContainer.onComplete();
				eventsWithcallbacks.RemoveAtIndex(num2);
			}
			else
			{
				num2++;
			}
		}
		uint num3 = 0u;
		while (num3 < eventsWithTransforms.Length)
		{
			ACHandleTransformContainer aCHandleTransformContainer = eventsWithTransforms[num3];
			aCHandleTransformContainer.eventInstance.getPlaybackState(out var state2);
			if (state2 == PLAYBACK_STATE.STOPPING || state2 == PLAYBACK_STATE.STOPPED || aCHandleTransformContainer.eventTransform == null)
			{
				eventsWithTransforms.RemoveAtIndex(num3);
				continue;
			}
			aCHandleTransformContainer.eventInstance.set3DAttributes(aCHandleTransformContainer.eventTransform.position.to3DAttributes());
			num3++;
		}
		BarkQueue.Update();
	}

	public void OnFocus(bool focused)
	{
		if (sys.isValid())
		{
			sys.getLowLevelSystem(out var system);
			if (focused)
			{
				system.mixerResume();
			}
			else
			{
				system.mixerSuspend();
			}
			sys.update();
			system.update();
		}
	}

	public void OnPause(bool paused)
	{
		if (subMix.isValid())
		{
			subMix.setPaused(paused);
		}
	}

	public void StopSubMix()
	{
		if (subMix.isValid())
		{
			subMix.stopAllEvents(STOP_MODE.ALLOWFADEOUT);
		}
	}

	public bool IsInstancePlaying(FMOD.Studio.EventInstance eventInstance)
	{
		eventInstance.getPlaybackState(out var state);
		return state != PLAYBACK_STATE.STOPPED;
	}

	[Conditional("AE_DEBUG")]
	private static void LogWarning(string warning)
	{
		UnityEngine.Debug.LogWarning(warning);
	}
}
public static class ACMisc
{
	private static bool librayOrderRan;

	public static void EnforceLibraryOrder()
	{
		if (!librayOrderRan)
		{
			librayOrderRan = true;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.lang.System");
			androidJavaClass.CallStatic("loadLibrary", "fmod");
			androidJavaClass.CallStatic("loadLibrary", "fmodstudio");
			Memory.GetStats(out var _, out var _);
			Util.ParseID(string.Empty, out var _);
		}
	}

	public static VECTOR toFMODVector(this Vector3 vec)
	{
		VECTOR result = default(VECTOR);
		result.x = vec.x;
		result.y = vec.y;
		result.z = vec.z;
		return result;
	}

	public static ATTRIBUTES_3D to3DAttributes(this Vector3 pos)
	{
		ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
		result.forward = Vector3.forward.toFMODVector();
		result.up = Vector3.up.toFMODVector();
		result.position = pos.toFMODVector();
		return result;
	}

	public static ATTRIBUTES_3D to3DAttributes(GameObject go, Rigidbody rigidbody = null)
	{
		ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
		result.forward = go.transform.forward.toFMODVector();
		result.up = go.transform.up.toFMODVector();
		result.position = go.transform.position.toFMODVector();
		if ((bool)rigidbody)
		{
			result.velocity = rigidbody.velocity.toFMODVector();
		}
		return result;
	}
}
public class ACSource : MonoBehaviour
{
	public string eventPath;

	public bool startOnAwake = true;

	public float Volume = 1f;

	private FMOD.Studio.EventInstance evt;

	private bool hasStarted;

	private bool wasPaused;

	private AC manager;

	private bool playing;

	public void Play()
	{
		if (evt.isValid())
		{
			evt.start();
			evt.setVolume(Volume);
		}
	}

	public void PlayOnce()
	{
		if (evt.isValid() && !playing)
		{
			evt.start();
			evt.setVolume(Volume);
			playing = true;
		}
	}

	public void SetVolume(float volume)
	{
		Volume = volume;
		if (evt.isValid())
		{
			evt.setVolume(Volume);
		}
	}

	public float GetVolume()
	{
		return Volume;
	}

	public void Pause()
	{
		if (evt.isValid())
		{
			evt.setPaused(paused: true);
		}
	}

	public void Resume()
	{
		if (evt.isValid())
		{
			evt.setPaused(paused: false);
		}
	}

	public void Stop()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.ALLOWFADEOUT);
			playing = false;
		}
	}

	public ParameterInstance GetParameter(string name)
	{
		if (!evt.isValid())
		{
			return default(ParameterInstance);
		}
		evt.getParameter(name, out var instance);
		return instance;
	}

	public ParameterInstance GetParameter(int index)
	{
		if (!evt.isValid())
		{
			return default(ParameterInstance);
		}
		evt.getParameterByIndex(index, out var instance);
		return instance;
	}

	public PLAYBACK_STATE GetPlaybackState()
	{
		if (!evt.isValid())
		{
			return PLAYBACK_STATE.STOPPED;
		}
		if (evt.getPlaybackState(out var state) == RESULT.OK)
		{
			return state;
		}
		return PLAYBACK_STATE.STOPPED;
	}

	private void Start()
	{
		manager = AC.Inst;
		if (!evt.isValid())
		{
			CacheEventInstance();
		}
		if (startOnAwake)
		{
			StartEvent();
		}
	}

	private void CacheEventInstance()
	{
		if (eventPath != null)
		{
			if (manager == null)
			{
				manager = AC.Inst;
			}
			evt = manager.GetHandle(eventPath);
		}
	}

	private void OnDestroy()
	{
		if (evt.isValid())
		{
			if (GetPlaybackState() != PLAYBACK_STATE.STOPPED)
			{
				evt.stop(STOP_MODE.IMMEDIATE);
			}
			evt.release();
			evt = default(FMOD.Studio.EventInstance);
		}
	}

	private void OnEnable()
	{
		if (evt.isValid())
		{
			evt.setPaused(wasPaused);
		}
	}

	private void OnDisable()
	{
		if (evt.isValid())
		{
			evt.getPaused(out wasPaused);
			if (!wasPaused)
			{
				evt.setPaused(paused: true);
			}
		}
	}

	public void StartEvent()
	{
		if (!evt.isValid())
		{
			CacheEventInstance();
		}
		if (evt.isValid())
		{
			Update3DAttributes();
			evt.start();
			evt.setVolume(Volume);
		}
		hasStarted = true;
	}

	public bool HasFinished()
	{
		if (!hasStarted)
		{
			return false;
		}
		if (!evt.isValid())
		{
			return true;
		}
		return GetPlaybackState() == PLAYBACK_STATE.STOPPED;
	}

	private void Update()
	{
		if (evt.isValid())
		{
			Update3DAttributes();
		}
		else
		{
			evt = default(FMOD.Studio.EventInstance);
		}
	}

	private void Update3DAttributes()
	{
		if (evt.isValid())
		{
			ATTRIBUTES_3D attributes = ACMisc.to3DAttributes(base.gameObject);
			evt.set3DAttributes(attributes);
		}
	}
}
public class FMODBankAsset : FMODBaseAsset
{
	public string bankFilePath;
}
public class FMODBaseAsset : ScriptableObject
{
	public string path;

	[SerializeField]
	private string fmodGUIDStr;

	private Guid? _fmodGUID;

	public Guid fmodGUID
	{
		get
		{
			if (!_fmodGUID.HasValue)
			{
				_fmodGUID = new Guid(fmodGUIDStr);
			}
			return _fmodGUID.Value;
		}
		set
		{
			if (_fmodGUID != value)
			{
				_fmodGUID = value;
				fmodGUIDStr = _fmodGUID.ToString();
			}
		}
	}

	public override bool Equals(object o)
	{
		FMODBaseAsset fMODBaseAsset = o as FMODBaseAsset;
		return fMODBaseAsset != null && fmodGUID.Equals(fMODBaseAsset.fmodGUID);
	}

	public override int GetHashCode()
	{
		return fmodGUID.GetHashCode();
	}

	public override string ToString()
	{
		return path + " " + fmodGUIDStr;
	}
}
public class FMODBusAsset : FMODBaseAsset
{
}
public class FMODEventAsset : FMODBaseAsset
{
	public EventDescription GetDescription(FMOD.Studio.System sys)
	{
		sys.getEventByID(base.fmodGUID, out var _event);
		return _event;
	}

	public FMOD.Studio.EventInstance GetInstance(FMOD.Studio.System sys)
	{
		GetDescription(sys).createInstance(out var instance);
		return instance;
	}
}
public class FMODSnapshotAsset : FMODBaseAsset
{
	public EventDescription GetDescription(FMOD.Studio.System sys)
	{
		sys.getEventByID(base.fmodGUID, out var _event);
		return _event;
	}

	public FMOD.Studio.EventInstance GetInstance(FMOD.Studio.System sys)
	{
		GetDescription(sys).createInstance(out var instance);
		return instance;
	}
}
public class FMODVCAAsset : FMODBaseAsset
{
}
public class BigWillaAnimFuncs_AmbientSubtitleShow : AEAnimEventBase
{
	private delegate void InvokeDelegate(BigWillaAnimFuncs target, DialogData _data, bool _noReIdle);

	private delegate float AcquireDurationDelegate(DialogData _data, bool _noReIdle);

	private delegate string GetDisplayNameDelegate(DialogData _data, bool _noReIdle);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public DialogData _data;

	public bool _noReIdle;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("BigWillaAnimFuncs");
		MethodInfo method = type.GetMethod("AmbientSubtitleShow", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(DialogData),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("AmbientSubtitleShow_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("AmbientSubtitleShow_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((BigWillaAnimFuncs)target, _data, _noReIdle);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_data, _noReIdle);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_data, _noReIdle);
	}
}
public enum Item
{
	Atlantium_Core = -993452213,
	Augment = 1006278257,
	Cabbage = -2091214079,
	Circuitry = -1487087664,
	Grenade_Flux = 1047828090,
	Grenade_Frag = 1047833219,
	Grenade_Stun = 1048223051,
	Jewellery = 555898915,
	Medpack = -1689331259,
	None = 2433880,
	Rejection_Shot = 1412720048,
	Scrap_Metal = -325374759,
	Trap_Flux = -1200500805,
	Trap_Frag = -1200495676,
	Trap_Stun = -1200105844,
	Upgrade_Accuracy1 = 258041781,
	Upgrade_Accuracy2 = 258041782,
	Upgrade_Accuracy3 = 258041783,
	Upgrade_CritChanace1 = 577272797,
	Upgrade_CritChanace2 = 577272798,
	Upgrade_CritChanace3 = 577272799,
	Upgrade_Damage1 = -1502046401,
	Upgrade_Damage2 = -1502046400,
	Upgrade_Damage3 = -1502046399
}
public class KubrickBase_Comment : AEAnimEventBase
{
	private delegate void InvokeDelegate(KubrickBase target, string _comment);

	private delegate float AcquireDurationDelegate(string _comment);

	private delegate string GetDisplayNameDelegate(string _comment);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _comment;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("KubrickBase");
		MethodInfo method = type.GetMethod("Comment", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(string) }, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("Comment_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("Comment_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((KubrickBase)target, _comment);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_comment);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_comment);
	}
}
public class LogicRoot_UnitWalkToTarget : AEAnimEventBase
{
	private delegate void InvokeDelegate(LogicRoot target, string _unitName, string _unitTarget);

	private delegate float AcquireDurationDelegate(string _unitName, string _unitTarget);

	private delegate string GetDisplayNameDelegate(string _unitName, string _unitTarget);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitName;

	public string _unitTarget;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("LogicRoot");
		MethodInfo method = type.GetMethod("UnitWalkToTarget", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(string)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitWalkToTarget_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitWalkToTarget_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((LogicRoot)target, _unitName, _unitTarget);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitName, _unitTarget);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitName, _unitTarget);
	}
}
public class MR_ActivateUnitWithAnimation : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _animationName);

	private delegate float AcquireDurationDelegate(string _unitId, string _animationName);

	private delegate string GetDisplayNameDelegate(string _unitId, string _animationName);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _animationName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("ActivateUnitWithAnimation", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(string)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("ActivateUnitWithAnimation_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("ActivateUnitWithAnimation_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animationName);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animationName);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animationName);
	}
}
public class MR_AmbientSubtitleShow : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, DialogData _data, bool _noReIdle);

	private delegate float AcquireDurationDelegate(DialogData _data, bool _noReIdle);

	private delegate string GetDisplayNameDelegate(DialogData _data, bool _noReIdle);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public DialogData _data;

	public bool _noReIdle;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("AmbientSubtitleShow", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(DialogData),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("AmbientSubtitleShow_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("AmbientSubtitleShow_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _data, _noReIdle);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_data, _noReIdle);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_data, _noReIdle);
	}
}
public class MR_MapShakeOneShot : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("MapShakeOneShot", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("MapShakeOneShot_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("MapShakeOneShot_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class MR_PlayAnimation : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _animationName, bool _pauseForEvent, bool _loop, bool _updateIdleOnComplete);

	private delegate float AcquireDurationDelegate(string _unitId, string _animationName, bool _pauseForEvent, bool _loop, bool _updateIdleOnComplete);

	private delegate string GetDisplayNameDelegate(string _unitId, string _animationName, bool _pauseForEvent, bool _loop, bool _updateIdleOnComplete);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _animationName;

	public bool _pauseForEvent;

	public bool _loop;

	public bool _updateIdleOnComplete;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayAnimation", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[5]
		{
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayAnimation_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayAnimation_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animationName, _pauseForEvent, _loop, _updateIdleOnComplete);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animationName, _pauseForEvent, _loop, _updateIdleOnComplete);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animationName, _pauseForEvent, _loop, _updateIdleOnComplete);
	}
}
public class MR_PlayAnimationAndSnapPos : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _animation, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private delegate float AcquireDurationDelegate(string _unitId, string _animation, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private delegate string GetDisplayNameDelegate(string _unitId, string _animation, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _animation;

	public v2i _coord;

	public bool _snapDir;

	public OctDir _direction;

	public bool _pauseForEvent;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayAnimationAndSnapPos", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[6]
		{
			typeof(string),
			typeof(string),
			typeof(v2i),
			typeof(bool),
			typeof(OctDir),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayAnimationAndSnapPos_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayAnimationAndSnapPos_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animation, _coord, _snapDir, _direction, _pauseForEvent);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animation, _coord, _snapDir, _direction, _pauseForEvent);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animation, _coord, _snapDir, _direction, _pauseForEvent);
	}
}
public class MR_PlayAnimationID : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, UnitModel.AnimID _animationId, bool _pauseForEvent);

	private delegate float AcquireDurationDelegate(string _unitId, UnitModel.AnimID _animationId, bool _pauseForEvent);

	private delegate string GetDisplayNameDelegate(string _unitId, UnitModel.AnimID _animationId, bool _pauseForEvent);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public UnitModel.AnimID _animationId;

	public bool _pauseForEvent;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayAnimationID", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(UnitModel.AnimID),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayAnimationID_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayAnimationID_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animationId, _pauseForEvent);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animationId, _pauseForEvent);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animationId, _pauseForEvent);
	}
}
public class MR_PlayAnimationIDAndSnapPos : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, UnitModel.AnimID _animationId, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private delegate float AcquireDurationDelegate(string _unitId, UnitModel.AnimID _animationId, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private delegate string GetDisplayNameDelegate(string _unitId, UnitModel.AnimID _animationId, v2i _coord, bool _snapDir, OctDir _direction, bool _pauseForEvent);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public UnitModel.AnimID _animationId;

	public v2i _coord;

	public bool _snapDir;

	public OctDir _direction;

	public bool _pauseForEvent;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayAnimationIDAndSnapPos", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[6]
		{
			typeof(string),
			typeof(UnitModel.AnimID),
			typeof(v2i),
			typeof(bool),
			typeof(OctDir),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayAnimationIDAndSnapPos_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayAnimationIDAndSnapPos_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animationId, _coord, _snapDir, _direction, _pauseForEvent);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animationId, _coord, _snapDir, _direction, _pauseForEvent);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animationId, _coord, _snapDir, _direction, _pauseForEvent);
	}
}
public class MR_PlayEnvironmentalAnimation : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _kubrickName, string _fullAnimName, WrapMode _wrapMode);

	private delegate float AcquireDurationDelegate(string _kubrickName, string _fullAnimName, WrapMode _wrapMode);

	private delegate string GetDisplayNameDelegate(string _kubrickName, string _fullAnimName, WrapMode _wrapMode);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _kubrickName;

	public string _fullAnimName;

	public WrapMode _wrapMode;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayEnvironmentalAnimation", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(string),
			typeof(WrapMode)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayEnvironmentalAnimation_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayEnvironmentalAnimation_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _kubrickName, _fullAnimName, _wrapMode);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_kubrickName, _fullAnimName, _wrapMode);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_kubrickName, _fullAnimName, _wrapMode);
	}
}
public class MR_PlayMusic : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _eventPath, float _progress, float _fade);

	private delegate float AcquireDurationDelegate(string _eventPath, float _progress, float _fade);

	private delegate string GetDisplayNameDelegate(string _eventPath, float _progress, float _fade);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public float _progress;

	public float _fade;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayMusic", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(float),
			typeof(float)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayMusic_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayMusic_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _eventPath, _progress, _fade);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _progress, _fade);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _progress, _fade);
	}
}
public class MR_PlayParticleEffect : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, ParticleTypes _particleEffect, v2i _coord);

	private delegate float AcquireDurationDelegate(ParticleTypes _particleEffect, v2i _coord);

	private delegate string GetDisplayNameDelegate(ParticleTypes _particleEffect, v2i _coord);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public ParticleTypes _particleEffect;

	public v2i _coord;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlayParticleEffect", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(ParticleTypes),
			typeof(v2i)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayParticleEffect_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayParticleEffect_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _particleEffect, _coord);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_particleEffect, _coord);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_particleEffect, _coord);
	}
}
public class MR_PlaySoundAt : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _eventPath, FMODParam[] _fmodParams);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlaySoundAt", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(FMODParam[])
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAt_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAt_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _eventPath, _fmodParams);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams);
	}
}
public class MR_PlaySoundAtCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	public v2i _coord;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("PlaySoundAtCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(FMODParam[]),
			typeof(v2i)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAtCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAtCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _eventPath, _fmodParams, _coord);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams, _coord);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams, _coord);
	}
}
public class MR_SetAnimOverride : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, UnitModel.AnimID _animationId, string _animName, bool _updateIdleAnims, bool _clearOverride);

	private delegate float AcquireDurationDelegate(string _unitId, UnitModel.AnimID _animationId, string _animName, bool _updateIdleAnims, bool _clearOverride);

	private delegate string GetDisplayNameDelegate(string _unitId, UnitModel.AnimID _animationId, string _animName, bool _updateIdleAnims, bool _clearOverride);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public UnitModel.AnimID _animationId;

	public string _animName;

	public bool _updateIdleAnims;

	public bool _clearOverride;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetAnimOverride", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[5]
		{
			typeof(string),
			typeof(UnitModel.AnimID),
			typeof(string),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetAnimOverride_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetAnimOverride_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _animationId, _animName, _updateIdleAnims, _clearOverride);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _animationId, _animName, _updateIdleAnims, _clearOverride);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _animationId, _animName, _updateIdleAnims, _clearOverride);
	}
}
public class MR_SetCoverActive : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _coverId, bool _active);

	private delegate float AcquireDurationDelegate(string _coverId, bool _active);

	private delegate string GetDisplayNameDelegate(string _coverId, bool _active);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _coverId;

	public bool _active;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetCoverActive", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetCoverActive_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetCoverActive_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _coverId, _active);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_coverId, _active);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_coverId, _active);
	}
}
public class MR_SetMusicParameter : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, MusicController.MusicParameters _param, float _value);

	private delegate float AcquireDurationDelegate(MusicController.MusicParameters _param, float _value);

	private delegate string GetDisplayNameDelegate(MusicController.MusicParameters _param, float _value);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public MusicController.MusicParameters _param;

	public float _value;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetMusicParameter", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(MusicController.MusicParameters),
			typeof(float)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetMusicParameter_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetMusicParameter_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _param, _value);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_param, _value);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_param, _value);
	}
}
public class MR_SetMusicProgress : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, float _progress);

	private delegate float AcquireDurationDelegate(float _progress);

	private delegate string GetDisplayNameDelegate(float _progress);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public float _progress;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetMusicProgress", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(float) }, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetMusicProgress_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetMusicProgress_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _progress);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_progress);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_progress);
	}
}
public class MR_SetTargetActive : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _targetId, bool _active);

	private delegate float AcquireDurationDelegate(string _targetId, bool _active);

	private delegate string GetDisplayNameDelegate(string _targetId, bool _active);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _targetId;

	public bool _active;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetTargetActive", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetTargetActive_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetTargetActive_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _targetId, _active);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_targetId, _active);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_targetId, _active);
	}
}
public class MR_SetUnitActive : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, bool _active, bool _keepUnitInGame);

	private delegate float AcquireDurationDelegate(string _unitId, bool _active, bool _keepUnitInGame);

	private delegate string GetDisplayNameDelegate(string _unitId, bool _active, bool _keepUnitInGame);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public bool _active;

	public bool _keepUnitInGame;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SetUnitActive", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetUnitActive_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetUnitActive_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _active, _keepUnitInGame);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _active, _keepUnitInGame);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _active, _keepUnitInGame);
	}
}
public class MR_ShowCustomDialogue : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, DialogData.Type _dialogType, string _unitID, string _sfxAssetPath, string _header, string _body, DialogData _internalDialogueRef);

	private delegate float AcquireDurationDelegate(DialogData.Type _dialogType, string _unitID, string _sfxAssetPath, string _header, string _body, DialogData _internalDialogueRef);

	private delegate string GetDisplayNameDelegate(DialogData.Type _dialogType, string _unitID, string _sfxAssetPath, string _header, string _body, DialogData _internalDialogueRef);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public DialogData.Type _dialogType;

	public string _unitID;

	public string _sfxAssetPath;

	public string _header;

	public string _body;

	public DialogData _internalDialogueRef;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("ShowCustomDialogue", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[6]
		{
			typeof(DialogData.Type),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(DialogData)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("ShowCustomDialogue_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("ShowCustomDialogue_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _dialogType, _unitID, _sfxAssetPath, _header, _body, _internalDialogueRef);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_dialogType, _unitID, _sfxAssetPath, _header, _body, _internalDialogueRef);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_dialogType, _unitID, _sfxAssetPath, _header, _body, _internalDialogueRef);
	}
}
public class MR_ShowDialogue : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, DialogData _dialogue);

	private delegate float AcquireDurationDelegate(DialogData _dialogue);

	private delegate string GetDisplayNameDelegate(DialogData _dialogue);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public DialogData _dialogue;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("ShowDialogue", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(DialogData) }, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("ShowDialogue_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("ShowDialogue_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _dialogue);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_dialogue);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_dialogue);
	}
}
public class MR_SnapUnitToCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, v2i _coord);

	private delegate float AcquireDurationDelegate(string _unitId, v2i _coord);

	private delegate string GetDisplayNameDelegate(string _unitId, v2i _coord);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public v2i _coord;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("SnapUnitToCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(v2i)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SnapUnitToCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SnapUnitToCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _coord);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _coord);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _coord);
	}
}
public class MR_StopMusic : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("StopMusic", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("StopMusic_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("StopMusic_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class MR_ToggleMapShake : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, bool _shaking);

	private delegate float AcquireDurationDelegate(bool _shaking);

	private delegate string GetDisplayNameDelegate(bool _shaking);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public bool _shaking;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("ToggleMapShake", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(bool) }, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("ToggleMapShake_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("ToggleMapShake_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _shaking);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_shaking);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_shaking);
	}
}
public class MR_UnitAttackCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, v2i _coord, string _animOverride, bool _updateIdle, bool _pauseForEvent);

	private delegate float AcquireDurationDelegate(string _unitId, v2i _coord, string _animOverride, bool _updateIdle, bool _pauseForEvent);

	private delegate string GetDisplayNameDelegate(string _unitId, v2i _coord, string _animOverride, bool _updateIdle, bool _pauseForEvent);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public v2i _coord;

	public string _animOverride;

	public bool _updateIdle;

	public bool _pauseForEvent;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitAttackCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[5]
		{
			typeof(string),
			typeof(v2i),
			typeof(string),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitAttackCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitAttackCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _coord, _animOverride, _updateIdle, _pauseForEvent);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _coord, _animOverride, _updateIdle, _pauseForEvent);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _coord, _animOverride, _updateIdle, _pauseForEvent);
	}
}
public class MR_UnitAttackUnit : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _targetUnitId, bool _meleeAttack, Combat.HitType _hitType, string _overrideAnim, bool _updateIdle, bool _pauseForEvent, bool _killTarget);

	private delegate float AcquireDurationDelegate(string _unitId, string _targetUnitId, bool _meleeAttack, Combat.HitType _hitType, string _overrideAnim, bool _updateIdle, bool _pauseForEvent, bool _killTarget);

	private delegate string GetDisplayNameDelegate(string _unitId, string _targetUnitId, bool _meleeAttack, Combat.HitType _hitType, string _overrideAnim, bool _updateIdle, bool _pauseForEvent, bool _killTarget);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _targetUnitId;

	public bool _meleeAttack;

	public Combat.HitType _hitType;

	public string _overrideAnim;

	public bool _updateIdle;

	public bool _pauseForEvent;

	public bool _killTarget;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitAttackUnit", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[8]
		{
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(Combat.HitType),
			typeof(string),
			typeof(bool),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitAttackUnit_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitAttackUnit_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _targetUnitId, _meleeAttack, _hitType, _overrideAnim, _updateIdle, _pauseForEvent, _killTarget);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _targetUnitId, _meleeAttack, _hitType, _overrideAnim, _updateIdle, _pauseForEvent, _killTarget);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _targetUnitId, _meleeAttack, _hitType, _overrideAnim, _updateIdle, _pauseForEvent, _killTarget);
	}
}
public class MR_UnitLookAtCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, v2i _coord);

	private delegate float AcquireDurationDelegate(string _unitId, v2i _coord);

	private delegate string GetDisplayNameDelegate(string _unitId, v2i _coord);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public v2i _coord;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitLookAtCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(v2i)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitLookAtCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitLookAtCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _coord);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _coord);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _coord);
	}
}
public class MR_UnitLookAtUnit : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _targetUnitID, bool _keepEyeOn);

	private delegate float AcquireDurationDelegate(string _unitId, string _targetUnitID, bool _keepEyeOn);

	private delegate string GetDisplayNameDelegate(string _unitId, string _targetUnitID, bool _keepEyeOn);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _targetUnitID;

	public bool _keepEyeOn;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitLookAtUnit", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(string),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitLookAtUnit_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitLookAtUnit_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _targetUnitID, _keepEyeOn);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _targetUnitID, _keepEyeOn);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _targetUnitID, _keepEyeOn);
	}
}
public class MR_UnitMoveToCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, v2i _coord, bool _pauseForEvent, float _customSpeed, bool _run, bool _ignoreOtherUnits);

	private delegate float AcquireDurationDelegate(string _unitId, v2i _coord, bool _pauseForEvent, float _customSpeed, bool _run, bool _ignoreOtherUnits);

	private delegate string GetDisplayNameDelegate(string _unitId, v2i _coord, bool _pauseForEvent, float _customSpeed, bool _run, bool _ignoreOtherUnits);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public v2i _coord;

	public bool _pauseForEvent;

	public float _customSpeed;

	public bool _run;

	public bool _ignoreOtherUnits;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitMoveToCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[6]
		{
			typeof(string),
			typeof(v2i),
			typeof(bool),
			typeof(float),
			typeof(bool),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitMoveToCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitMoveToCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _coord, _pauseForEvent, _customSpeed, _run, _ignoreOtherUnits);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _coord, _pauseForEvent, _customSpeed, _run, _ignoreOtherUnits);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _coord, _pauseForEvent, _customSpeed, _run, _ignoreOtherUnits);
	}
}
public class MR_UnitMoveToMapViaExitTile : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _exitTileId, float _customSpeed);

	private delegate float AcquireDurationDelegate(string _unitId, string _exitTileId, float _customSpeed);

	private delegate string GetDisplayNameDelegate(string _unitId, string _exitTileId, float _customSpeed);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _exitTileId;

	public float _customSpeed;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitMoveToMapViaExitTile", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(string),
			typeof(float)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitMoveToMapViaExitTile_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitMoveToMapViaExitTile_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _exitTileId, _customSpeed);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _exitTileId, _customSpeed);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _exitTileId, _customSpeed);
	}
}
public class MR_UnitMoveToTarget : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _unitTargetId, bool _pauseForEvent, float _customSpeed, bool _run);

	private delegate float AcquireDurationDelegate(string _unitId, string _unitTargetId, bool _pauseForEvent, float _customSpeed, bool _run);

	private delegate string GetDisplayNameDelegate(string _unitId, string _unitTargetId, bool _pauseForEvent, float _customSpeed, bool _run);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _unitTargetId;

	public bool _pauseForEvent;

	public float _customSpeed;

	public bool _run;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitMoveToTarget", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[5]
		{
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(float),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitMoveToTarget_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitMoveToTarget_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _unitTargetId, _pauseForEvent, _customSpeed, _run);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _unitTargetId, _pauseForEvent, _customSpeed, _run);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _unitTargetId, _pauseForEvent, _customSpeed, _run);
	}
}
public class MR_UnitMoveToUnit : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _destUnitId, bool _pauseForEvent, float _customSpeed, bool _run);

	private delegate float AcquireDurationDelegate(string _unitId, string _destUnitId, bool _pauseForEvent, float _customSpeed, bool _run);

	private delegate string GetDisplayNameDelegate(string _unitId, string _destUnitId, bool _pauseForEvent, float _customSpeed, bool _run);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _destUnitId;

	public bool _pauseForEvent;

	public float _customSpeed;

	public bool _run;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitMoveToUnit", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[5]
		{
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(float),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitMoveToUnit_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitMoveToUnit_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _destUnitId, _pauseForEvent, _customSpeed, _run);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _destUnitId, _pauseForEvent, _customSpeed, _run);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _destUnitId, _pauseForEvent, _customSpeed, _run);
	}
}
public class MR_UnitTeleportToMapViaEntranceTile : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _entranceTile);

	private delegate float AcquireDurationDelegate(string _unitId, string _entranceTile);

	private delegate string GetDisplayNameDelegate(string _unitId, string _entranceTile);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _entranceTile;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitTeleportToMapViaEntranceTile", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(string)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitTeleportToMapViaEntranceTile_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitTeleportToMapViaEntranceTile_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _entranceTile);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _entranceTile);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _entranceTile);
	}
}
public class MR_UnitTeleportToTarget : AEAnimEventBase
{
	private delegate void InvokeDelegate(MR target, string _unitId, string _unitTargetId);

	private delegate float AcquireDurationDelegate(string _unitId, string _unitTargetId);

	private delegate string GetDisplayNameDelegate(string _unitId, string _unitTargetId);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _unitId;

	public string _unitTargetId;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MR");
		MethodInfo method = type.GetMethod("UnitTeleportToTarget", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(string)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("UnitTeleportToTarget_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("UnitTeleportToTarget_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MR)target, _unitId, _unitTargetId);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_unitId, _unitTargetId);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_unitId, _unitTargetId);
	}
}
public class MapAnimFuncs_PlaySoundAt : AEAnimEventBase
{
	private delegate void InvokeDelegate(MapAnimFuncs target, string _eventPath, FMODParam[] _fmodParams);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MapAnimFuncs");
		MethodInfo method = type.GetMethod("PlaySoundAt", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(FMODParam[])
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAt_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAt_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MapAnimFuncs)target, _eventPath, _fmodParams);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams);
	}
}
public class MapAnimFuncs_PlaySoundAtChildTransform : AEAnimEventBase
{
	private delegate void InvokeDelegate(MapAnimFuncs target, string _eventPath, FMODParam[] _fmodParams, string _childname);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams, string _childname);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams, string _childname);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	public string _childname;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MapAnimFuncs");
		MethodInfo method = type.GetMethod("PlaySoundAtChildTransform", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(FMODParam[]),
			typeof(string)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAtChildTransform_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAtChildTransform_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MapAnimFuncs)target, _eventPath, _fmodParams, _childname);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams, _childname);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams, _childname);
	}
}
public class MapAnimFuncs_PlaySoundAtCoord : AEAnimEventBase
{
	private delegate void InvokeDelegate(MapAnimFuncs target, string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams, v2i _coord);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	public v2i _coord;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MapAnimFuncs");
		MethodInfo method = type.GetMethod("PlaySoundAtCoord", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(FMODParam[]),
			typeof(v2i)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAtCoord_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAtCoord_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MapAnimFuncs)target, _eventPath, _fmodParams, _coord);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams, _coord);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams, _coord);
	}
}
public class MapAnimFuncs_PlaySoundAtPosition : AEAnimEventBase
{
	private delegate void InvokeDelegate(MapAnimFuncs target, string _eventPath, FMODParam[] _fmodParams, Vector3 _pos);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams, Vector3 _pos);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams, Vector3 _pos);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	public Vector3 _pos;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MapAnimFuncs");
		MethodInfo method = type.GetMethod("PlaySoundAtPosition", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(FMODParam[]),
			typeof(Vector3)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAtPosition_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAtPosition_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MapAnimFuncs)target, _eventPath, _fmodParams, _pos);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams, _pos);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams, _pos);
	}
}
public class MapAnimFuncs_SetParameterOnAmbTargetsWithEvents : AEAnimEventBase
{
	private delegate void InvokeDelegate(MapAnimFuncs target, string _parameter, float _value);

	private delegate float AcquireDurationDelegate(string _parameter, float _value);

	private delegate string GetDisplayNameDelegate(string _parameter, float _value);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _parameter;

	public float _value;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("MapAnimFuncs");
		MethodInfo method = type.GetMethod("SetParameterOnAmbTargetsWithEvents", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(float)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("SetParameterOnAmbTargetsWithEvents_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("SetParameterOnAmbTargetsWithEvents_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((MapAnimFuncs)target, _parameter, _value);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_parameter, _value);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_parameter, _value);
	}
}
public class UnitAnimFuncs_HologramMakeInactiveSomehow : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("HologramMakeInactiveSomehow", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("HologramMakeInactiveSomehow_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("HologramMakeInactiveSomehow_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_OnAttack : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("OnAttack", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("OnAttack_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("OnAttack_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_OnInteract : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("OnInteract", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("OnInteract_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("OnInteract_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_OnPickUp : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("OnPickUp", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("OnPickUp_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("OnPickUp_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_PlayFootstep : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("PlayFootstep", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayFootstep_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayFootstep_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_PlayGunMuzzleFlash : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("PlayGunMuzzleFlash", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayGunMuzzleFlash_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayGunMuzzleFlash_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration();
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName();
	}
}
public class UnitAnimFuncs_PlayParticle : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target, ParticleTypes _particletype);

	private delegate float AcquireDurationDelegate(ParticleTypes _particletype);

	private delegate string GetDisplayNameDelegate(ParticleTypes _particletype);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public ParticleTypes _particletype;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("PlayParticle", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(ParticleTypes) }, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlayParticle_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlayParticle_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target, _particletype);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_particletype);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_particletype);
	}
}
public class UnitAnimFuncs_PlaySoundAt : AEAnimEventBase
{
	private delegate void InvokeDelegate(UnitAnimFuncs target, string _eventPath, FMODParam[] _fmodParams, bool _provideSurfaceParam);

	private delegate float AcquireDurationDelegate(string _eventPath, FMODParam[] _fmodParams, bool _provideSurfaceParam);

	private delegate string GetDisplayNameDelegate(string _eventPath, FMODParam[] _fmodParams, bool _provideSurfaceParam);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	public string _eventPath;

	public FMODParam[] _fmodParams;

	public bool _provideSurfaceParam;

	private void Start()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void OnEnable()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
	}

	private void InitialiseDelegates()
	{
		Assembly assembly = Assembly.Load("Assembly-CSharp");
		Type type = assembly.GetType("UnitAnimFuncs");
		MethodInfo method = type.GetMethod("PlaySoundAt", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[3]
		{
			typeof(string),
			typeof(FMODParam[]),
			typeof(bool)
		}, null);
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, method);
		MethodInfo method2 = type.GetMethod("PlaySoundAt_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method2 != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), method2.MakeGenericMethod());
		}
		MethodInfo method3 = type.GetMethod("PlaySoundAt_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if (method3 != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), method3.MakeGenericMethod());
		}
	}

	public override void Invoke(object target)
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		invoke((UnitAnimFuncs)target, _eventPath, _fmodParams, _provideSurfaceParam);
	}

	public override void AcquireDuration()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (acquireDuration != null)
		{
			_duration = acquireDuration(_eventPath, _fmodParams, _provideSurfaceParam);
		}
	}

	public override string GetDisplayName()
	{
		if (invoke == null)
		{
			InitialiseDelegates();
		}
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		return getDisplayName(_eventPath, _fmodParams, _provideSurfaceParam);
	}
}
public class OvrFMODGlobalSettings : MonoBehaviour
{
	public const string strOSP = "ovrfmod";

	[SerializeField]
	private bool bypass;

	[SerializeField]
	private float globalScale = 1f;

	[SerializeField]
	private float gain;

	private bool dirtyReflection;

	[SerializeField]
	private bool enableReflections = true;

	[SerializeField]
	private bool enableReverb;

	[SerializeField]
	private Vector3 dimensions = new Vector3(8f, 2.5f, 5f);

	[SerializeField]
	private Vector2 reflectionLeftRight = new Vector2(0.75f, 0.75f);

	[SerializeField]
	private Vector2 reflectionUpDown = new Vector2(0.85f, 0.25f);

	[SerializeField]
	private Vector2 reflectionFrontBack = new Vector2(0.75f, 0.75f);

	public bool Bypass
	{
		get
		{
			return bypass;
		}
		set
		{
			bypass = value;
			OSP_FMOD_SetBypass(bypass);
		}
	}

	public float GlobalScale
	{
		get
		{
			return globalScale;
		}
		set
		{
			globalScale = Mathf.Clamp(value, 1E-05f, 10000f);
			OSP_FMOD_SetGlobalScale(globalScale);
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, -24f, 24f);
			OSP_FMOD_SetGain(gain);
		}
	}

	public bool EnableReflections
	{
		get
		{
			return enableReflections;
		}
		set
		{
			enableReflections = value;
			dirtyReflection = true;
		}
	}

	public bool EnableReverb
	{
		get
		{
			return enableReverb;
		}
		set
		{
			enableReverb = value;
			dirtyReflection = true;
		}
	}

	public Vector3 Dimensions
	{
		get
		{
			return dimensions;
		}
		set
		{
			dimensions = value;
			dimensions.x = Mathf.Clamp(dimensions.x, 0f, 230f);
			dimensions.y = Mathf.Clamp(dimensions.y, 0f, 230f);
			dimensions.z = Mathf.Clamp(dimensions.z, 0f, 230f);
			dirtyReflection = true;
		}
	}

	public Vector2 ReflectionLeftRight
	{
		get
		{
			return reflectionLeftRight;
		}
		set
		{
			reflectionLeftRight = value;
			reflectionLeftRight.x = Mathf.Clamp(reflectionLeftRight.x, 0f, 0.95f);
			reflectionLeftRight.y = Mathf.Clamp(reflectionLeftRight.y, 0f, 0.95f);
			dirtyReflection = true;
		}
	}

	public Vector2 ReflectionUpDown
	{
		get
		{
			return reflectionUpDown;
		}
		set
		{
			reflectionUpDown = value;
			reflectionUpDown.x = Mathf.Clamp(reflectionUpDown.x, 0f, 0.95f);
			reflectionUpDown.y = Mathf.Clamp(reflectionUpDown.y, 0f, 0.95f);
			dirtyReflection = true;
		}
	}

	public Vector2 ReflectionFrontBack
	{
		get
		{
			return reflectionFrontBack;
		}
		set
		{
			reflectionFrontBack = value;
			reflectionFrontBack.x = Mathf.Clamp(reflectionFrontBack.x, 0f, 0.95f);
			reflectionFrontBack.y = Mathf.Clamp(reflectionFrontBack.y, 0f, 0.95f);
			dirtyReflection = true;
		}
	}

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_Initialize(int SampleRate, int BufferLength);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetBypass(bool Enabled);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetGain(float Gain_dB);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetGlobalScale(float Scale);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetEarlyReflectionsEnabled(bool Enabled);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetLateReverberationEnabled(bool Enabled);

	[DllImport("ovrfmod")]
	private static extern bool OSP_FMOD_SetSimpleBoxRoomParameters(float Width, float Height, float Depth, float RefLeft, float RefRight, float RefUp, float RefDown, float RefBehind, float RefFront);

	private void Start()
	{
		FMOD.System system = null;
		AC.Inst.sys.getLowLevelSystem(out system);
		RESULT rESULT = RESULT.OK;
		int samplerate = 0;
		int numrawspeakers = 0;
		rESULT = system.getSoftwareFormat(out samplerate, out var _, out numrawspeakers);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("OVRA FMOD: Error retreiving state from FMOD: " + rESULT);
		}
		uint bufferlength = 0u;
		int numbuffers = 0;
		rESULT = system.getDSPBufferSize(out bufferlength, out numbuffers);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("OVRA FMOD: Error retreiving state from FMOD: " + rESULT);
		}
		if (!OSP_FMOD_Initialize(samplerate, (int)bufferlength))
		{
			UnityEngine.Debug.LogError("OVRA FMOD: Error initializing Oculus VR audio");
		}
		OSP_FMOD_SetBypass(bypass);
		OSP_FMOD_SetGlobalScale(globalScale);
		OSP_FMOD_SetGain(gain);
		UpdateReflections();
	}

	private void Update()
	{
		if (dirtyReflection)
		{
			UpdateReflections();
		}
	}

	private void UpdateReflections()
	{
		OSP_FMOD_SetSimpleBoxRoomParameters(dimensions.x, dimensions.y, dimensions.z, reflectionLeftRight.x, reflectionLeftRight.y, reflectionUpDown.x, reflectionUpDown.y, reflectionFrontBack.x, reflectionFrontBack.y);
		OSP_FMOD_SetLateReverberationEnabled(enableReverb);
		OSP_FMOD_SetEarlyReflectionsEnabled(enableReflections);
		dirtyReflection = false;
	}
}
public static class OVRExtensions
{
	public static OVRPose ToTrackingSpacePose(this Transform transform)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(VRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(VRNode.Head);
		return oVRPose * transform.ToHeadSpacePose();
	}

	public static OVRPose ToHeadSpacePose(this Transform transform)
	{
		return Camera.current.transform.ToOVRPose().Inverse() * transform.ToOVRPose();
	}

	internal static OVRPose ToOVRPose(this Transform t, bool isLocal = false)
	{
		OVRPose result = default(OVRPose);
		result.orientation = ((!isLocal) ? t.rotation : t.localRotation);
		result.position = ((!isLocal) ? t.position : t.localPosition);
		return result;
	}

	internal static void FromOVRPose(this Transform t, OVRPose pose, bool isLocal = false)
	{
		if (isLocal)
		{
			t.localRotation = pose.orientation;
			t.localPosition = pose.position;
		}
		else
		{
			t.rotation = pose.orientation;
			t.position = pose.position;
		}
	}

	internal static OVRPose ToOVRPose(this OVRPlugin.Posef p)
	{
		OVRPose result = default(OVRPose);
		result.position = new Vector3(p.Position.x, p.Position.y, 0f - p.Position.z);
		result.orientation = new Quaternion(0f - p.Orientation.x, 0f - p.Orientation.y, p.Orientation.z, p.Orientation.w);
		return result;
	}

	internal static OVRTracker.Frustum ToFrustum(this OVRPlugin.Frustumf f)
	{
		OVRTracker.Frustum result = default(OVRTracker.Frustum);
		result.nearZ = f.zNear;
		result.farZ = f.zFar;
		result.fov = new Vector2
		{
			x = 57.29578f * f.fovX,
			y = 57.29578f * f.fovY
		};
		return result;
	}

	internal static Color FromColorf(this OVRPlugin.Colorf c)
	{
		Color result = default(Color);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static OVRPlugin.Colorf ToColorf(this Color c)
	{
		OVRPlugin.Colorf result = default(OVRPlugin.Colorf);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static Vector3 FromVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static Vector3 FromFlippedZVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToFlippedZVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static Quaternion FromQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}
}
[Serializable]
public struct OVRPose
{
	public Vector3 position;

	public Quaternion orientation;

	public static OVRPose identity
	{
		get
		{
			OVRPose result = default(OVRPose);
			result.position = Vector3.zero;
			result.orientation = Quaternion.identity;
			return result;
		}
	}

	public override bool Equals(object obj)
	{
		return obj is OVRPose && this == (OVRPose)obj;
	}

	public override int GetHashCode()
	{
		return position.GetHashCode() ^ orientation.GetHashCode();
	}

	public static bool operator ==(OVRPose x, OVRPose y)
	{
		return x.position == y.position && x.orientation == y.orientation;
	}

	public static bool operator !=(OVRPose x, OVRPose y)
	{
		return !(x == y);
	}

	public static OVRPose operator *(OVRPose lhs, OVRPose rhs)
	{
		OVRPose result = default(OVRPose);
		result.position = lhs.position + lhs.orientation * rhs.position;
		result.orientation = lhs.orientation * rhs.orientation;
		return result;
	}

	public OVRPose Inverse()
	{
		OVRPose result = default(OVRPose);
		result.orientation = Quaternion.Inverse(orientation);
		result.position = result.orientation * -position;
		return result;
	}

	internal OVRPose flipZ()
	{
		OVRPose result = this;
		result.position.z = 0f - result.position.z;
		result.orientation.z = 0f - result.orientation.z;
		result.orientation.w = 0f - result.orientation.w;
		return result;
	}

	internal OVRPlugin.Posef ToPosef()
	{
		OVRPlugin.Posef result = default(OVRPlugin.Posef);
		result.Position = position.ToVector3f();
		result.Orientation = orientation.ToQuatf();
		return result;
	}
}
public class OVRNativeBuffer : IDisposable
{
	private bool disposed;

	private int m_numBytes;

	private IntPtr m_ptr = IntPtr.Zero;

	public OVRNativeBuffer(int numBytes)
	{
		Reallocate(numBytes);
	}

	~OVRNativeBuffer()
	{
		Dispose(disposing: false);
	}

	public void Reset(int numBytes)
	{
		Reallocate(numBytes);
	}

	public int GetCapacity()
	{
		return m_numBytes;
	}

	public IntPtr GetPointer(int byteOffset = 0)
	{
		if (byteOffset < 0 || byteOffset >= m_numBytes)
		{
			return IntPtr.Zero;
		}
		return (byteOffset != 0) ? new IntPtr(m_ptr.ToInt64() + byteOffset) : m_ptr;
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		System.GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
			}
			Release();
			disposed = true;
		}
	}

	private void Reallocate(int numBytes)
	{
		Release();
		if (numBytes > 0)
		{
			m_ptr = Marshal.AllocHGlobal(numBytes);
			m_numBytes = numBytes;
		}
		else
		{
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}

	private void Release()
	{
		if (m_ptr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(m_ptr);
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}
}
public static class OVRInput
{
	[Flags]
	public enum Button
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		Start = 0x100,
		Back = 0x200,
		PrimaryShoulder = 0x1000,
		PrimaryIndexTrigger = 0x2000,
		PrimaryHandTrigger = 0x4000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbstickUp = 0x10000,
		PrimaryThumbstickDown = 0x20000,
		PrimaryThumbstickLeft = 0x40000,
		PrimaryThumbstickRight = 0x80000,
		PrimaryTouchpad = 0x400,
		SecondaryShoulder = 0x100000,
		SecondaryIndexTrigger = 0x200000,
		SecondaryHandTrigger = 0x400000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbstickUp = 0x1000000,
		SecondaryThumbstickDown = 0x2000000,
		SecondaryThumbstickLeft = 0x4000000,
		SecondaryThumbstickRight = 0x8000000,
		SecondaryTouchpad = 0x800,
		DpadUp = 0x10,
		DpadDown = 0x20,
		DpadLeft = 0x40,
		DpadRight = 0x80,
		Up = 0x10000000,
		Down = 0x20000000,
		Left = 0x40000000,
		Right = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum RawButton
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		Start = 0x100000,
		Back = 0x200000,
		LShoulder = 0x800,
		LIndexTrigger = 0x10000000,
		LHandTrigger = 0x20000000,
		LThumbstick = 0x400,
		LThumbstickUp = 0x10,
		LThumbstickDown = 0x20,
		LThumbstickLeft = 0x40,
		LThumbstickRight = 0x80,
		LTouchpad = 0x40000000,
		RShoulder = 8,
		RIndexTrigger = 0x4000000,
		RHandTrigger = 0x8000000,
		RThumbstick = 4,
		RThumbstickUp = 0x1000,
		RThumbstickDown = 0x2000,
		RThumbstickLeft = 0x4000,
		RThumbstickRight = 0x8000,
		RTouchpad = int.MinValue,
		DpadUp = 0x10000,
		DpadDown = 0x20000,
		DpadLeft = 0x40000,
		DpadRight = 0x80000,
		Any = -1
	}

	[Flags]
	public enum Touch
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		PrimaryIndexTrigger = 0x2000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbRest = 0x1000,
		PrimaryTouchpad = 0x400,
		SecondaryIndexTrigger = 0x200000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbRest = 0x100000,
		SecondaryTouchpad = 0x800,
		Any = -1
	}

	[Flags]
	public enum RawTouch
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		LIndexTrigger = 0x1000,
		LThumbstick = 0x400,
		LThumbRest = 0x800,
		LTouchpad = 0x40000000,
		RIndexTrigger = 0x10,
		RThumbstick = 4,
		RThumbRest = 8,
		RTouchpad = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum NearTouch
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryThumbButtons = 2,
		SecondaryIndexTrigger = 4,
		SecondaryThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum RawNearTouch
	{
		None = 0,
		LIndexTrigger = 1,
		LThumbButtons = 2,
		RIndexTrigger = 4,
		RThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum Axis1D
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryHandTrigger = 4,
		SecondaryIndexTrigger = 2,
		SecondaryHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis1D
	{
		None = 0,
		LIndexTrigger = 1,
		LHandTrigger = 4,
		RIndexTrigger = 2,
		RHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum Axis2D
	{
		None = 0,
		PrimaryThumbstick = 1,
		PrimaryTouchpad = 4,
		SecondaryThumbstick = 2,
		SecondaryTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis2D
	{
		None = 0,
		LThumbstick = 1,
		LTouchpad = 4,
		RThumbstick = 2,
		RTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 0x10,
		Touchpad = 0x8000000,
		LTrackedRemote = 0x1000000,
		RTrackedRemote = 0x2000000,
		Active = int.MinValue,
		All = -1
	}

	private abstract class OVRControllerBase
	{
		public class VirtualButtonMap
		{
			public RawButton None;

			public RawButton One;

			public RawButton Two;

			public RawButton Three;

			public RawButton Four;

			public RawButton Start;

			public RawButton Back;

			public RawButton PrimaryShoulder;

			public RawButton PrimaryIndexTrigger;

			public RawButton PrimaryHandTrigger;

			public RawButton PrimaryThumbstick;

			public RawButton PrimaryThumbstickUp;

			public RawButton PrimaryThumbstickDown;

			public RawButton PrimaryThumbstickLeft;

			public RawButton PrimaryThumbstickRight;

			public RawButton PrimaryTouchpad;

			public RawButton SecondaryShoulder;

			public RawButton SecondaryIndexTrigger;

			public RawButton SecondaryHandTrigger;

			public RawButton SecondaryThumbstick;

			public RawButton SecondaryThumbstickUp;

			public RawButton SecondaryThumbstickDown;

			public RawButton SecondaryThumbstickLeft;

			public RawButton SecondaryThumbstickRight;

			public RawButton SecondaryTouchpad;

			public RawButton DpadUp;

			public RawButton DpadDown;

			public RawButton DpadLeft;

			public RawButton DpadRight;

			public RawButton Up;

			public RawButton Down;

			public RawButton Left;

			public RawButton Right;

			public RawButton ToRawMask(Button virtualMask)
			{
				RawButton rawButton = RawButton.None;
				if (virtualMask == Button.None)
				{
					return RawButton.None;
				}
				if ((virtualMask & Button.One) != 0)
				{
					rawButton |= One;
				}
				if ((virtualMask & Button.Two) != 0)
				{
					rawButton |= Two;
				}
				if ((virtualMask & Button.Three) != 0)
				{
					rawButton |= Three;
				}
				if ((virtualMask & Button.Four) != 0)
				{
					rawButton |= Four;
				}
				if ((virtualMask & Button.Start) != 0)
				{
					rawButton |= Start;
				}
				if ((virtualMask & Button.Back) != 0)
				{
					rawButton |= Back;
				}
				if ((virtualMask & Button.PrimaryShoulder) != 0)
				{
					rawButton |= PrimaryShoulder;
				}
				if ((virtualMask & Button.PrimaryIndexTrigger) != 0)
				{
					rawButton |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Button.PrimaryHandTrigger) != 0)
				{
					rawButton |= PrimaryHandTrigger;
				}
				if ((virtualMask & Button.PrimaryThumbstick) != 0)
				{
					rawButton |= PrimaryThumbstick;
				}
				if ((virtualMask & Button.PrimaryThumbstickUp) != 0)
				{
					rawButton |= PrimaryThumbstickUp;
				}
				if ((virtualMask & Button.PrimaryThumbstickDown) != 0)
				{
					rawButton |= PrimaryThumbstickDown;
				}
				if ((virtualMask & Button.PrimaryThumbstickLeft) != 0)
				{
					rawButton |= PrimaryThumbstickLeft;
				}
				if ((virtualMask & Button.PrimaryThumbstickRight) != 0)
				{
					rawButton |= PrimaryThumbstickRight;
				}
				if ((virtualMask & Button.PrimaryTouchpad) != 0)
				{
					rawButton |= PrimaryTouchpad;
				}
				if ((virtualMask & Button.SecondaryShoulder) != 0)
				{
					rawButton |= SecondaryShoulder;
				}
				if ((virtualMask & Button.SecondaryIndexTrigger) != 0)
				{
					rawButton |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Button.SecondaryHandTrigger) != 0)
				{
					rawButton |= SecondaryHandTrigger;
				}
				if ((virtualMask & Button.SecondaryThumbstick) != 0)
				{
					rawButton |= SecondaryThumbstick;
				}
				if ((virtualMask & Button.SecondaryThumbstickUp) != 0)
				{
					rawButton |= SecondaryThumbstickUp;
				}
				if ((virtualMask & Button.SecondaryThumbstickDown) != 0)
				{
					rawButton |= SecondaryThumbstickDown;
				}
				if ((virtualMask & Button.SecondaryThumbstickLeft) != 0)
				{
					rawButton |= SecondaryThumbstickLeft;
				}
				if ((virtualMask & Button.SecondaryThumbstickRight) != 0)
				{
					rawButton |= SecondaryThumbstickRight;
				}
				if ((virtualMask & Button.SecondaryTouchpad) != 0)
				{
					rawButton |= SecondaryTouchpad;
				}
				if ((virtualMask & Button.DpadUp) != 0)
				{
					rawButton |= DpadUp;
				}
				if ((virtualMask & Button.DpadDown) != 0)
				{
					rawButton |= DpadDown;
				}
				if ((virtualMask & Button.DpadLeft) != 0)
				{
					rawButton |= DpadLeft;
				}
				if ((virtualMask & Button.DpadRight) != 0)
				{
					rawButton |= DpadRight;
				}
				if ((virtualMask & Button.Up) != 0)
				{
					rawButton |= Up;
				}
				if ((virtualMask & Button.Down) != 0)
				{
					rawButton |= Down;
				}
				if ((virtualMask & Button.Left) != 0)
				{
					rawButton |= Left;
				}
				if (((uint)virtualMask & 0x80000000u) != 0)
				{
					rawButton |= Right;
				}
				return rawButton;
			}
		}

		public class VirtualTouchMap
		{
			public RawTouch None;

			public RawTouch One;

			public RawTouch Two;

			public RawTouch Three;

			public RawTouch Four;

			public RawTouch PrimaryIndexTrigger;

			public RawTouch PrimaryThumbstick;

			public RawTouch PrimaryThumbRest;

			public RawTouch PrimaryTouchpad;

			public RawTouch SecondaryIndexTrigger;

			public RawTouch SecondaryThumbstick;

			public RawTouch SecondaryThumbRest;

			public RawTouch SecondaryTouchpad;

			public RawTouch ToRawMask(Touch virtualMask)
			{
				RawTouch rawTouch = RawTouch.None;
				if (virtualMask == Touch.None)
				{
					return RawTouch.None;
				}
				if ((virtualMask & Touch.One) != 0)
				{
					rawTouch |= One;
				}
				if ((virtualMask & Touch.Two) != 0)
				{
					rawTouch |= Two;
				}
				if ((virtualMask & Touch.Three) != 0)
				{
					rawTouch |= Three;
				}
				if ((virtualMask & Touch.Four) != 0)
				{
					rawTouch |= Four;
				}
				if ((virtualMask & Touch.PrimaryIndexTrigger) != 0)
				{
					rawTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Touch.PrimaryThumbstick) != 0)
				{
					rawTouch |= PrimaryThumbstick;
				}
				if ((virtualMask & Touch.PrimaryThumbRest) != 0)
				{
					rawTouch |= PrimaryThumbRest;
				}
				if ((virtualMask & Touch.PrimaryTouchpad) != 0)
				{
					rawTouch |= PrimaryTouchpad;
				}
				if ((virtualMask & Touch.SecondaryIndexTrigger) != 0)
				{
					rawTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Touch.SecondaryThumbstick) != 0)
				{
					rawTouch |= SecondaryThumbstick;
				}
				if ((virtualMask & Touch.SecondaryThumbRest) != 0)
				{
					rawTouch |= SecondaryThumbRest;
				}
				if ((virtualMask & Touch.SecondaryTouchpad) != 0)
				{
					rawTouch |= SecondaryTouchpad;
				}
				return rawTouch;
			}
		}

		public class VirtualNearTouchMap
		{
			public RawNearTouch None;

			public RawNearTouch PrimaryIndexTrigger;

			public RawNearTouch PrimaryThumbButtons;

			public RawNearTouch SecondaryIndexTrigger;

			public RawNearTouch SecondaryThumbButtons;

			public RawNearTouch ToRawMask(NearTouch virtualMask)
			{
				RawNearTouch rawNearTouch = RawNearTouch.None;
				if (virtualMask == NearTouch.None)
				{
					return RawNearTouch.None;
				}
				if ((virtualMask & NearTouch.PrimaryIndexTrigger) != 0)
				{
					rawNearTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.PrimaryThumbButtons) != 0)
				{
					rawNearTouch |= PrimaryThumbButtons;
				}
				if ((virtualMask & NearTouch.SecondaryIndexTrigger) != 0)
				{
					rawNearTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.SecondaryThumbButtons) != 0)
				{
					rawNearTouch |= SecondaryThumbButtons;
				}
				return rawNearTouch;
			}
		}

		public class VirtualAxis1DMap
		{
			public RawAxis1D None;

			public RawAxis1D PrimaryIndexTrigger;

			public RawAxis1D PrimaryHandTrigger;

			public RawAxis1D SecondaryIndexTrigger;

			public RawAxis1D SecondaryHandTrigger;

			public RawAxis1D ToRawMask(Axis1D virtualMask)
			{
				RawAxis1D rawAxis1D = RawAxis1D.None;
				if (virtualMask == Axis1D.None)
				{
					return RawAxis1D.None;
				}
				if ((virtualMask & Axis1D.PrimaryIndexTrigger) != 0)
				{
					rawAxis1D |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.PrimaryHandTrigger) != 0)
				{
					rawAxis1D |= PrimaryHandTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryIndexTrigger) != 0)
				{
					rawAxis1D |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryHandTrigger) != 0)
				{
					rawAxis1D |= SecondaryHandTrigger;
				}
				return rawAxis1D;
			}
		}

		public class VirtualAxis2DMap
		{
			public RawAxis2D None;

			public RawAxis2D PrimaryThumbstick;

			public RawAxis2D PrimaryTouchpad;

			public RawAxis2D SecondaryThumbstick;

			public RawAxis2D SecondaryTouchpad;

			public RawAxis2D ToRawMask(Axis2D virtualMask)
			{
				RawAxis2D rawAxis2D = RawAxis2D.None;
				if (virtualMask == Axis2D.None)
				{
					return RawAxis2D.None;
				}
				if ((virtualMask & Axis2D.PrimaryThumbstick) != 0)
				{
					rawAxis2D |= PrimaryThumbstick;
				}
				if ((virtualMask & Axis2D.PrimaryTouchpad) != 0)
				{
					rawAxis2D |= PrimaryTouchpad;
				}
				if ((virtualMask & Axis2D.SecondaryThumbstick) != 0)
				{
					rawAxis2D |= SecondaryThumbstick;
				}
				if ((virtualMask & Axis2D.SecondaryTouchpad) != 0)
				{
					rawAxis2D |= SecondaryTouchpad;
				}
				return rawAxis2D;
			}
		}

		public Controller controllerType;

		public VirtualButtonMap buttonMap = new VirtualButtonMap();

		public VirtualTouchMap touchMap = new VirtualTouchMap();

		public VirtualNearTouchMap nearTouchMap = new VirtualNearTouchMap();

		public VirtualAxis1DMap axis1DMap = new VirtualAxis1DMap();

		public VirtualAxis2DMap axis2DMap = new VirtualAxis2DMap();

		public OVRPlugin.ControllerState2 previousState = default(OVRPlugin.ControllerState2);

		public OVRPlugin.ControllerState2 currentState = default(OVRPlugin.ControllerState2);

		public bool shouldApplyDeadzone = true;

		public OVRControllerBase()
		{
			ConfigureButtonMap();
			ConfigureTouchMap();
			ConfigureNearTouchMap();
			ConfigureAxis1DMap();
			ConfigureAxis2DMap();
		}

		public virtual Controller Update()
		{
			OVRPlugin.ControllerState2 controllerState = OVRPlugin.GetControllerState2((uint)controllerType);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public virtual void SetControllerVibration(float frequency, float amplitude)
		{
			OVRPlugin.SetControllerVibration((uint)controllerType, frequency, amplitude);
		}

		public abstract void ConfigureButtonMap();

		public abstract void ConfigureTouchMap();

		public abstract void ConfigureNearTouchMap();

		public abstract void ConfigureAxis1DMap();

		public abstract void ConfigureAxis2DMap();

		public RawButton ResolveToRawMask(Button virtualMask)
		{
			return buttonMap.ToRawMask(virtualMask);
		}

		public RawTouch ResolveToRawMask(Touch virtualMask)
		{
			return touchMap.ToRawMask(virtualMask);
		}

		public RawNearTouch ResolveToRawMask(NearTouch virtualMask)
		{
			return nearTouchMap.ToRawMask(virtualMask);
		}

		public RawAxis1D ResolveToRawMask(Axis1D virtualMask)
		{
			return axis1DMap.ToRawMask(virtualMask);
		}

		public RawAxis2D ResolveToRawMask(Axis2D virtualMask)
		{
			return axis2DMap.ToRawMask(virtualMask);
		}
	}

	private class OVRControllerTouch : OVRControllerBase
	{
		public OVRControllerTouch()
		{
			controllerType = Controller.Touch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.X;
			touchMap.Four = RawTouch.Y;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.SecondaryThumbstick = RawTouch.RThumbstick;
			touchMap.SecondaryThumbRest = RawTouch.RThumbRest;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.RThumbButtons;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.RHandTrigger;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTouch : OVRControllerBase
	{
		public OVRControllerLTouch()
		{
			controllerType = Controller.LTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.X;
			buttonMap.Two = RawButton.Y;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.X;
			touchMap.Two = RawTouch.Y;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRTouch : OVRControllerBase
	{
		public OVRControllerRTouch()
		{
			controllerType = Controller.RTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.None;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.RThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.RThumbstickUp;
			buttonMap.Down = RawButton.RThumbstickDown;
			buttonMap.Left = RawButton.RThumbstickLeft;
			buttonMap.Right = RawButton.RThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.RThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.RThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.RThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRemote : OVRControllerBase
	{
		public OVRControllerRemote()
		{
			controllerType = Controller.Remote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadPC : OVRControllerBase
	{
		public OVRControllerGamepadPC()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadMac : OVRControllerBase
	{
		private enum AxisGPC
		{
			None = -1,
			LeftXAxis,
			LeftYAxis,
			RightXAxis,
			RightYAxis,
			LeftTrigger,
			RightTrigger,
			DPad_X_Axis,
			DPad_Y_Axis,
			Max
		}

		public enum ButtonGPC
		{
			None = -1,
			A,
			B,
			X,
			Y,
			Up,
			Down,
			Left,
			Right,
			Start,
			Back,
			LStick,
			RStick,
			LeftShoulder,
			RightShoulder,
			Max
		}

		private bool initialized;

		private const string DllName = "OVRGamepad";

		public OVRControllerGamepadMac()
		{
			controllerType = Controller.Gamepad;
			initialized = OVR_GamepadController_Initialize();
		}

		~OVRControllerGamepadMac()
		{
			if (initialized)
			{
				OVR_GamepadController_Destroy();
			}
		}

		public override Controller Update()
		{
			if (!initialized)
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState2 controllerState = default(OVRPlugin.ControllerState2);
			if (OVR_GamepadController_Update())
			{
				controllerState.ConnectedControllers = 16u;
			}
			if (OVR_GamepadController_GetButton(0))
			{
				controllerState.Buttons |= 1u;
			}
			if (OVR_GamepadController_GetButton(1))
			{
				controllerState.Buttons |= 2u;
			}
			if (OVR_GamepadController_GetButton(2))
			{
				controllerState.Buttons |= 256u;
			}
			if (OVR_GamepadController_GetButton(3))
			{
				controllerState.Buttons |= 512u;
			}
			if (OVR_GamepadController_GetButton(4))
			{
				controllerState.Buttons |= 65536u;
			}
			if (OVR_GamepadController_GetButton(5))
			{
				controllerState.Buttons |= 131072u;
			}
			if (OVR_GamepadController_GetButton(6))
			{
				controllerState.Buttons |= 262144u;
			}
			if (OVR_GamepadController_GetButton(7))
			{
				controllerState.Buttons |= 524288u;
			}
			if (OVR_GamepadController_GetButton(8))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (OVR_GamepadController_GetButton(9))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (OVR_GamepadController_GetButton(10))
			{
				controllerState.Buttons |= 1024u;
			}
			if (OVR_GamepadController_GetButton(11))
			{
				controllerState.Buttons |= 4u;
			}
			if (OVR_GamepadController_GetButton(12))
			{
				controllerState.Buttons |= 2048u;
			}
			if (OVR_GamepadController_GetButton(13))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = OVR_GamepadController_GetAxis(0);
			controllerState.LThumbstick.y = OVR_GamepadController_GetAxis(1);
			controllerState.RThumbstick.x = OVR_GamepadController_GetAxis(2);
			controllerState.RThumbstick.y = OVR_GamepadController_GetAxis(3);
			controllerState.LIndexTrigger = OVR_GamepadController_GetAxis(4);
			controllerState.RIndexTrigger = OVR_GamepadController_GetAxis(5);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
			int node = 0;
			float frequency2 = frequency * 200f;
			OVR_GamepadController_SetVibration(node, amplitude, frequency2);
		}

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Initialize();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Destroy();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Update();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern float OVR_GamepadController_GetAxis(int axis);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_GetButton(int button);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_SetVibration(int node, float strength, float frequency);
	}

	private class OVRControllerGamepadAndroid : OVRControllerBase
	{
		private static class AndroidButtonNames
		{
			public static readonly KeyCode A = KeyCode.JoystickButton0;

			public static readonly KeyCode B = KeyCode.JoystickButton1;

			public static readonly KeyCode X = KeyCode.JoystickButton2;

			public static readonly KeyCode Y = KeyCode.JoystickButton3;

			public static readonly KeyCode Start = KeyCode.JoystickButton10;

			public static readonly KeyCode Back = KeyCode.JoystickButton11;

			public static readonly KeyCode LThumbstick = KeyCode.JoystickButton8;

			public static readonly KeyCode RThumbstick = KeyCode.JoystickButton9;

			public static readonly KeyCode LShoulder = KeyCode.JoystickButton4;

			public static readonly KeyCode RShoulder = KeyCode.JoystickButton5;
		}

		private static class AndroidAxisNames
		{
			public static readonly string LThumbstickX = "Oculus_GearVR_LThumbstickX";

			public static readonly string LThumbstickY = "Oculus_GearVR_LThumbstickY";

			public static readonly string RThumbstickX = "Oculus_GearVR_RThumbstickX";

			public static readonly string RThumbstickY = "Oculus_GearVR_RThumbstickY";

			public static readonly string LIndexTrigger = "Oculus_GearVR_LIndexTrigger";

			public static readonly string RIndexTrigger = "Oculus_GearVR_RIndexTrigger";

			public static readonly string DpadX = "Oculus_GearVR_DpadX";

			public static readonly string DpadY = "Oculus_GearVR_DpadY";
		}

		private bool joystickDetected;

		private float joystickCheckInterval = 1f;

		private float joystickCheckTime;

		public OVRControllerGamepadAndroid()
		{
			controllerType = Controller.Gamepad;
		}

		private bool ShouldUpdate()
		{
			if (Time.realtimeSinceStartup - joystickCheckTime > joystickCheckInterval)
			{
				joystickCheckTime = Time.realtimeSinceStartup;
				joystickDetected = false;
				string[] joystickNames = Input.GetJoystickNames();
				for (int i = 0; i < joystickNames.Length; i++)
				{
					if (joystickNames[i] != string.Empty)
					{
						joystickDetected = true;
						break;
					}
				}
			}
			return joystickDetected;
		}

		public override Controller Update()
		{
			if (!ShouldUpdate())
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState2 controllerState = default(OVRPlugin.ControllerState2);
			controllerState.ConnectedControllers = 16u;
			if (Input.GetKey(AndroidButtonNames.A))
			{
				controllerState.Buttons |= 1u;
			}
			if (Input.GetKey(AndroidButtonNames.B))
			{
				controllerState.Buttons |= 2u;
			}
			if (Input.GetKey(AndroidButtonNames.X))
			{
				controllerState.Buttons |= 256u;
			}
			if (Input.GetKey(AndroidButtonNames.Y))
			{
				controllerState.Buttons |= 512u;
			}
			if (Input.GetKey(AndroidButtonNames.Start))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (Input.GetKey(AndroidButtonNames.Back) || Input.GetKey(KeyCode.Escape))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (Input.GetKey(AndroidButtonNames.LThumbstick))
			{
				controllerState.Buttons |= 1024u;
			}
			if (Input.GetKey(AndroidButtonNames.RThumbstick))
			{
				controllerState.Buttons |= 4u;
			}
			if (Input.GetKey(AndroidButtonNames.LShoulder))
			{
				controllerState.Buttons |= 2048u;
			}
			if (Input.GetKey(AndroidButtonNames.RShoulder))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = Input.GetAxisRaw(AndroidAxisNames.LThumbstickX);
			controllerState.LThumbstick.y = Input.GetAxisRaw(AndroidAxisNames.LThumbstickY);
			controllerState.RThumbstick.x = Input.GetAxisRaw(AndroidAxisNames.RThumbstickX);
			controllerState.RThumbstick.y = Input.GetAxisRaw(AndroidAxisNames.RThumbstickY);
			controllerState.LIndexTrigger = Input.GetAxisRaw(AndroidAxisNames.LIndexTrigger);
			controllerState.RIndexTrigger = Input.GetAxisRaw(AndroidAxisNames.RIndexTrigger);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			float axisRaw = Input.GetAxisRaw(AndroidAxisNames.DpadX);
			float axisRaw2 = Input.GetAxisRaw(AndroidAxisNames.DpadY);
			if (axisRaw <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 262144u;
			}
			if (axisRaw >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 524288u;
			}
			if (axisRaw2 <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 131072u;
			}
			if (axisRaw2 >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 65536u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
		}
	}

	private class OVRControllerTouchpad : OVRControllerBase
	{
		private OVRPlugin.Vector2f moveAmount;

		private float maxTapMagnitude = 0.1f;

		private float minMoveMagnitude = 0.15f;

		public OVRControllerTouchpad()
		{
			controllerType = Controller.Touchpad;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount = currentState.LTouchpad;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				float magnitude = vector.magnitude;
				if (magnitude < maxTapMagnitude)
				{
					currentState.Buttons |= 1048576u;
					currentState.Buttons |= 1073741824u;
				}
				else if (magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.Start;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerLTrackedRemote()
		{
			controllerType = Controller.LTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.LTouchpad;
			}
			if (GetDown(RawButton.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.LTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}
	}

	private class OVRControllerRTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerRTrackedRemote()
		{
			controllerType = Controller.RTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.RTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.RTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.RTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.RTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.RTouchpad;
			}
			if (GetDown(RawButton.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.RTouchpad, Controller.RTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.RTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.RTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}
	}

	private static readonly float AXIS_AS_BUTTON_THRESHOLD;

	private static readonly float AXIS_DEADZONE_THRESHOLD;

	private static List<OVRControllerBase> controllers;

	private static Controller activeControllerType;

	private static Controller connectedControllerTypes;

	private static bool useFixedPoses;

	private static int fixedUpdateCount;

	private static bool _pluginSupportsActiveController;

	private static bool _pluginSupportsActiveControllerCached;

	private static Version _pluginSupportsActiveControllerMinVersion;

	private static bool pluginSupportsActiveController
	{
		get
		{
			if (!_pluginSupportsActiveControllerCached)
			{
				bool flag = true;
				_pluginSupportsActiveController = false && OVRPlugin.version >= _pluginSupportsActiveControllerMinVersion;
				_pluginSupportsActiveControllerCached = true;
			}
			return _pluginSupportsActiveController;
		}
	}

	static OVRInput()
	{
		AXIS_AS_BUTTON_THRESHOLD = 0.5f;
		AXIS_DEADZONE_THRESHOLD = 0.2f;
		activeControllerType = Controller.None;
		connectedControllerTypes = Controller.None;
		useFixedPoses = false;
		fixedUpdateCount = 0;
		_pluginSupportsActiveController = false;
		_pluginSupportsActiveControllerCached = false;
		_pluginSupportsActiveControllerMinVersion = new Version(1, 9, 0);
		controllers = new List<OVRControllerBase>
		{
			new OVRControllerGamepadAndroid(),
			new OVRControllerTouchpad(),
			new OVRControllerLTrackedRemote(),
			new OVRControllerRTrackedRemote()
		};
	}

	public static void Update()
	{
		connectedControllerTypes = Controller.None;
		useFixedPoses = false;
		fixedUpdateCount = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			connectedControllerTypes |= oVRControllerBase.Update();
			if ((connectedControllerTypes & oVRControllerBase.controllerType) != 0 && (Get(RawButton.Any, oVRControllerBase.controllerType) || Get(RawTouch.Any, oVRControllerBase.controllerType)))
			{
				activeControllerType = oVRControllerBase.controllerType;
			}
		}
		if (activeControllerType == Controller.LTouch || activeControllerType == Controller.RTouch)
		{
			activeControllerType = Controller.Touch;
		}
		if ((connectedControllerTypes & activeControllerType) == 0)
		{
			activeControllerType = Controller.None;
		}
		if (activeControllerType == Controller.None)
		{
			if ((connectedControllerTypes & Controller.RTrackedRemote) != 0)
			{
				activeControllerType = Controller.RTrackedRemote;
			}
			else if ((connectedControllerTypes & Controller.LTrackedRemote) != 0)
			{
				activeControllerType = Controller.LTrackedRemote;
			}
		}
		if (pluginSupportsActiveController)
		{
			connectedControllerTypes = (Controller)OVRPlugin.GetConnectedControllers();
			activeControllerType = (Controller)OVRPlugin.GetActiveController();
		}
	}

	public static void FixedUpdate()
	{
		useFixedPoses = true;
		double predictionSeconds = (double)fixedUpdateCount * (double)Time.fixedDeltaTime / (double)Mathf.Max(Time.timeScale, 1E-06f);
		fixedUpdateCount++;
		OVRPlugin.UpdateNodePhysicsPoses(0, predictionSeconds);
	}

	public static bool GetControllerOrientationTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static bool GetControllerPositionTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static Vector3 GetLocalControllerPosition(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Quaternion GetLocalControllerRotation(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation;
		default:
			return Quaternion.identity;
		}
	}

	public static Quaternion GetLocalControllerAngularVelocity(Controller controllerType)
	{
		return controllerType switch
		{
			Controller.LTouch => OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation, 
			Controller.RTouch => OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation, 
			_ => Quaternion.identity, 
		};
	}

	public static Quaternion GetLocalControllerAngularAcceleration(Controller controllerType)
	{
		return controllerType switch
		{
			Controller.LTouch => OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation, 
			Controller.RTouch => OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation, 
			_ => Quaternion.identity, 
		};
	}

	public static bool Get(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(virtualMask, RawButton.None, controllerMask);
	}

	public static bool Get(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButton(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetDown(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonDown(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetUp(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonUp(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) == 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool Get(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouch(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetDown(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchDown(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetUp(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchUp(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) == 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool Get(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouch(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetDown(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchDown(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetUp(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchUp(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) == 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static float Get(Axis1D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(virtualMask, RawAxis1D.None, controllerMask);
	}

	public static float Get(RawAxis1D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(Axis1D.None, rawMask, controllerMask);
	}

	private static float GetResolvedAxis1D(Axis1D virtualMask, RawAxis1D rawMask, Controller controllerMask)
	{
		float num = 0f;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis1D rawAxis1D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis1D.LIndexTrigger & rawAxis1D) != 0)
			{
				float num2 = oVRControllerBase.currentState.LIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num2 = CalculateDeadzone(num2, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num2);
			}
			if ((RawAxis1D.RIndexTrigger & rawAxis1D) != 0)
			{
				float num3 = oVRControllerBase.currentState.RIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num3 = CalculateDeadzone(num3, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num3);
			}
			if ((RawAxis1D.LHandTrigger & rawAxis1D) != 0)
			{
				float num4 = oVRControllerBase.currentState.LHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num4 = CalculateDeadzone(num4, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num4);
			}
			if ((RawAxis1D.RHandTrigger & rawAxis1D) != 0)
			{
				float num5 = oVRControllerBase.currentState.RHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num5 = CalculateDeadzone(num5, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num5);
			}
		}
		return num;
	}

	public static Vector2 Get(Axis2D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(virtualMask, RawAxis2D.None, controllerMask);
	}

	public static Vector2 Get(RawAxis2D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(Axis2D.None, rawMask, controllerMask);
	}

	private static Vector2 GetResolvedAxis2D(Axis2D virtualMask, RawAxis2D rawMask, Controller controllerMask)
	{
		Vector2 vector = Vector2.zero;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis2D rawAxis2D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis2D.LThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector2 = new Vector2(oVRControllerBase.currentState.LThumbstick.x, oVRControllerBase.currentState.LThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector2 = CalculateDeadzone(vector2, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector2);
			}
			if ((RawAxis2D.LTouchpad & rawAxis2D) != 0)
			{
				Vector2 b = new Vector2(oVRControllerBase.currentState.LTouchpad.x, oVRControllerBase.currentState.LTouchpad.y);
				vector = CalculateAbsMax(vector, b);
			}
			if ((RawAxis2D.RThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector3 = new Vector2(oVRControllerBase.currentState.RThumbstick.x, oVRControllerBase.currentState.RThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector3 = CalculateDeadzone(vector3, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector3);
			}
			if ((RawAxis2D.RTouchpad & rawAxis2D) != 0)
			{
				Vector2 b2 = new Vector2(oVRControllerBase.currentState.RTouchpad.x, oVRControllerBase.currentState.RTouchpad.y);
				vector = CalculateAbsMax(vector, b2);
			}
		}
		return vector;
	}

	public static Controller GetConnectedControllers()
	{
		return connectedControllerTypes;
	}

	public static bool IsControllerConnected(Controller controller)
	{
		return (connectedControllerTypes & controller) == controller;
	}

	public static Controller GetActiveController()
	{
		return activeControllerType;
	}

	public static void SetControllerVibration(float frequency, float amplitude, Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.SetControllerVibration(frequency, amplitude);
			}
		}
	}

	private static Vector2 CalculateAbsMax(Vector2 a, Vector2 b)
	{
		float sqrMagnitude = a.sqrMagnitude;
		float sqrMagnitude2 = b.sqrMagnitude;
		if (sqrMagnitude >= sqrMagnitude2)
		{
			return a;
		}
		return b;
	}

	private static float CalculateAbsMax(float a, float b)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		float num2 = ((!(b >= 0f)) ? (0f - b) : b);
		if (num >= num2)
		{
			return a;
		}
		return b;
	}

	private static Vector2 CalculateDeadzone(Vector2 a, float deadzone)
	{
		if (a.sqrMagnitude <= deadzone * deadzone)
		{
			return Vector2.zero;
		}
		a *= (a.magnitude - deadzone) / (1f - deadzone);
		if (a.sqrMagnitude > 1f)
		{
			return a.normalized;
		}
		return a;
	}

	private static float CalculateDeadzone(float a, float deadzone)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		if (num <= deadzone)
		{
			return 0f;
		}
		a *= (num - deadzone) / (1f - deadzone);
		if (a * a > 1f)
		{
			return (!(a >= 0f)) ? (-1f) : 1f;
		}
		return a;
	}

	private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)
	{
		bool result = false;
		if ((controllerType & controllerMask) == controllerType)
		{
			result = true;
		}
		if ((controllerMask & Controller.Touch) == Controller.Touch && (controllerType & Controller.Touch) != 0 && (controllerType & Controller.Touch) != Controller.Touch)
		{
			result = false;
		}
		return result;
	}
}
internal static class OVRPlugin
{
	private struct GUID
	{
		public int a;

		public short b;

		public short c;

		public byte d0;

		public byte d1;

		public byte d2;

		public byte d3;

		public byte d4;

		public byte d5;

		public byte d6;

		public byte d7;
	}

	public enum Bool
	{
		False,
		True
	}

	public enum Eye
	{
		None = -1,
		Left,
		Right,
		Count
	}

	public enum Tracker
	{
		None = -1,
		Zero,
		One,
		Two,
		Three,
		Count
	}

	public enum Node
	{
		None = -1,
		EyeLeft,
		EyeRight,
		EyeCenter,
		HandLeft,
		HandRight,
		TrackerZero,
		TrackerOne,
		TrackerTwo,
		TrackerThree,
		Head,
		Count
	}

	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 16,
		Touchpad = 134217728,
		LTrackedRemote = 16777216,
		RTrackedRemote = 33554432,
		Active = int.MinValue,
		All = -1
	}

	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		Count
	}

	public enum RecenterFlags
	{
		Default = 0,
		Controllers = 1073741824,
		IgnoreAll = int.MinValue,
		Count = -2147483647
	}

	public enum BatteryStatus
	{
		Charging,
		Discharging,
		Full,
		NotCharging,
		Unknown
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3
	}

	public enum PlatformUI
	{
		None = -1,
		GlobalMenu,
		ConfirmQuit,
		GlobalMenuTutorial
	}

	public enum SystemRegion
	{
		Unspecified,
		Japan,
		China
	}

	public enum SystemHeadset
	{
		None = 0,
		GearVR_R320 = 1,
		GearVR_R321 = 2,
		GearVR_R322 = 3,
		GearVR_R323 = 4,
		Rift_DK1 = 4096,
		Rift_DK2 = 4097,
		Rift_CV1 = 4098
	}

	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4
	}

	private enum OverlayFlag
	{
		None = 0,
		OnTop = 1,
		HeadLocked = 2,
		ShapeFlag_Quad = 0,
		ShapeFlag_Cylinder = 16,
		ShapeFlag_Cubemap = 32,
		ShapeFlag_OffcenterCubemap = 64,
		ShapeFlagRangeMask = 240
	}

	public struct Vector2f
	{
		public float x;

		public float y;
	}

	public struct Vector3f
	{
		public float x;

		public float y;

		public float z;
	}

	public struct Quatf
	{
		public float x;

		public float y;

		public float z;

		public float w;
	}

	public struct Posef
	{
		public Quatf Orientation;

		public Vector3f Position;
	}

	public struct ControllerState2
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public ControllerState2(ControllerState cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
			RTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
		}
	}

	public struct ControllerState
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;
	}

	public struct HapticsBuffer
	{
		public IntPtr Samples;

		public int SamplesCount;
	}

	public struct HapticsState
	{
		public int SamplesAvailable;

		public int SamplesQueued;
	}

	public struct HapticsDesc
	{
		public int SampleRateHz;

		public int SampleSizeInBytes;

		public int MinimumSafeSamplesQueued;

		public int MinimumBufferSamplesCount;

		public int OptimalBufferSamplesCount;

		public int MaximumBufferSamplesCount;
	}

	public struct AppPerfFrameStats
	{
		public int HmdVsyncIndex;

		public int AppFrameIndex;

		public int AppDroppedFrameCount;

		public float AppMotionToPhotonLatency;

		public float AppQueueAheadTime;

		public float AppCpuElapsedTime;

		public float AppGpuElapsedTime;

		public int CompositorFrameIndex;

		public int CompositorDroppedFrameCount;

		public float CompositorLatency;

		public float CompositorCpuElapsedTime;

		public float CompositorGpuElapsedTime;

		public float CompositorCpuStartToGpuEndElapsedTime;

		public float CompositorGpuEndToVsyncElapsedTime;
	}

	public struct AppPerfStats
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
		public AppPerfFrameStats[] FrameStats;

		public int FrameStatsCount;

		public Bool AnyFrameStatsDropped;

		public float AdaptiveGpuPerformanceScale;
	}

	public struct Sizei
	{
		public int w;

		public int h;
	}

	public struct Frustumf
	{
		public float zNear;

		public float zFar;

		public float fovX;

		public float fovY;
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public Bool IsTriggering;

		public float ClosestDistance;

		public Vector3f ClosestPoint;

		public Vector3f ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public Colorf Color;
	}

	public struct BoundaryGeometry
	{
		public BoundaryType BoundaryType;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		public Vector3f[] Points;

		public int PointsCount;
	}

	public struct Colorf
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}

	private static class OVRP_0_1_0
	{
		public static readonly Version version = new Version(0, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Sizei ovrp_GetEyeTextureSize(Eye eyeId);
	}

	private static class OVRP_0_1_1
	{
		public static readonly Version version = new Version(0, 1, 1);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad2(Bool onTop, Bool headLocked, IntPtr texture, IntPtr device, Posef pose, Vector3f scale);
	}

	private static class OVRP_0_1_2
	{
		public static readonly Version version = new Version(0, 1, 2);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerVibration(uint controllerMask, float frequency, float amplitude);
	}

	private static class OVRP_0_1_3
	{
		public static readonly Version version = new Version(0, 1, 3);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration(Node nodeId);
	}

	private static class OVRP_0_5_0
	{
		public static readonly Version version = new Version(0, 5, 0);
	}

	private static class OVRP_1_0_0
	{
		public static readonly Version version = new Version(1, 0, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern TrackingOrigin ovrp_GetTrackingOriginType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOriginType(TrackingOrigin originType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetTrackingCalibratedOrigin();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_RecenterTrackingOrigin(uint flags);
	}

	private static class OVRP_1_1_0
	{
		public static readonly Version version = new Version(1, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetNativeSDKVersion")]
		private static extern IntPtr _ovrp_GetNativeSDKVersion();

		public static string ovrp_GetNativeSDKVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetNativeSDKVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioOutId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioInId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeTextureScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeTextureScale(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOrientationEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingPositionEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePresent(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodeOrientationTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePositionTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Frustumf ovrp_GetNodeFrustum(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState ovrp_GetControllerState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemCpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemCpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemGpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemGpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemPowerSavingMode();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemDisplayFrequency();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemVSyncCount();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemVolume();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BatteryStatus ovrp_GetSystemBatteryStatus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryTemperature();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetSystemProductName")]
		private static extern IntPtr _ovrp_GetSystemProductName();

		public static string ovrp_GetSystemProductName()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetSystemProductName());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ShowSystemUI(PlatformUI ui);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppMonoscopic();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppMonoscopic(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppHasVrFocus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldQuit();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldRecenter();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetAppLatencyTimings")]
		private static extern IntPtr _ovrp_GetAppLatencyTimings();

		public static string ovrp_GetAppLatencyTimings()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetAppLatencyTimings());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetUserPresent();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserIPD();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserIPD(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeDepth();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeDepth(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeHeight();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeHeight(float value);
	}

	private static class OVRP_1_2_0
	{
		public static readonly Version version = new Version(1, 2, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemVSyncCount(int vsyncCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrpi_SetTrackingCalibratedOrigin();
	}

	private static class OVRP_1_3_0
	{
		public static readonly Version version = new Version(1, 3, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetEyeOcclusionMeshEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeOcclusionMeshEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemHeadphonesPresent();
	}

	private static class OVRP_1_5_0
	{
		public static readonly Version version = new Version(1, 5, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemRegion ovrp_GetSystemRegion();
	}

	private static class OVRP_1_6_0
	{
		public static readonly Version version = new Version(1, 6, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingIPDEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingIPDEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsDesc ovrp_GetControllerHapticsDesc(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsState ovrp_GetControllerHapticsState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad3(uint flags, IntPtr textureLeft, IntPtr textureRight, IntPtr device, Posef pose, Vector3f scale, int layerIndex);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeRecommendedResolutionScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppCpuStartToGpuEndTime();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemRecommendedMSAALevel();
	}

	private static class OVRP_1_7_0
	{
		public static readonly Version version = new Version(1, 7, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppChromaticCorrection();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppChromaticCorrection(Bool value);
	}

	private static class OVRP_1_8_0
	{
		public static readonly Version version = new Version(1, 8, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryConfigured();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryNode(Node nodeId, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryPoint(Vector3f point, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetBoundaryLookAndFeel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryGeometry ovrp_GetBoundaryGeometry(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Vector3f ovrp_GetBoundaryDimensions(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryVisible();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryVisible(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_Update2(int stateId, int frameIndex, double predictionSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration2(int stateId, Node nodeId);
	}

	private static class OVRP_1_9_0
	{
		public static readonly Version version = new Version(1, 9, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemHeadset ovrp_GetSystemHeadsetType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetActiveController();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetConnectedControllers();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern AppPerfStats ovrp_GetAppPerfStats();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetAppPerfStats();
	}

	private static class OVRP_1_10_0
	{
		public static readonly Version version = new Version(1, 10, 0);
	}

	private static class OVRP_1_11_0
	{
		public static readonly Version version = new Version(1, 11, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetDesiredEyeTextureFormat(EyeTextureFormat value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern EyeTextureFormat ovrp_GetDesiredEyeTextureFormat();
	}

	private static class OVRP_1_12_0
	{
		public static readonly Version version = new Version(1, 12, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState2 ovrp_GetControllerState2(uint controllerMask);
	}

	public static readonly Version wrapperVersion = OVRP_1_12_0.version;

	private static Version _version;

	private static Version _nativeSDKVersion;

	private const int OverlayShapeFlagShift = 4;

	public const int AppPerfFrameStatsMaxCount = 5;

	private static Guid _cachedAudioOutGuid;

	private static string _cachedAudioOutString;

	private static Guid _cachedAudioInGuid;

	private static string _cachedAudioInString;

	private const string pluginName = "OVRPlugin";

	private static Version _versionZero = new Version(0, 0, 0);

	public static Version version
	{
		get
		{
			if (_version == null)
			{
				try
				{
					string text = OVRP_1_1_0.ovrp_GetVersion();
					if (text != null)
					{
						text = text.Split('-')[0];
						_version = new Version(text);
					}
					else
					{
						_version = _versionZero;
					}
				}
				catch
				{
					_version = _versionZero;
				}
				if (_version == OVRP_0_5_0.version)
				{
					_version = OVRP_0_1_0.version;
				}
				if (_version > _versionZero && _version < OVRP_1_3_0.version)
				{
					throw new PlatformNotSupportedException(string.Concat("Oculus Utilities version ", wrapperVersion, " is too new for OVRPlugin version ", _version.ToString(), ". Update to the latest version of Unity."));
				}
			}
			return _version;
		}
	}

	public static Version nativeSDKVersion
	{
		get
		{
			if (_nativeSDKVersion == null)
			{
				try
				{
					string empty = string.Empty;
					empty = ((!(version >= OVRP_1_1_0.version)) ? _versionZero.ToString() : OVRP_1_1_0.ovrp_GetNativeSDKVersion());
					if (empty != null)
					{
						empty = empty.Split('-')[0];
						_nativeSDKVersion = new Version(empty);
					}
					else
					{
						_nativeSDKVersion = _versionZero;
					}
				}
				catch
				{
					_nativeSDKVersion = _versionZero;
				}
			}
			return _nativeSDKVersion;
		}
	}

	public static bool initialized => OVRP_1_1_0.ovrp_GetInitialized() == Bool.True;

	public static bool chromatic
	{
		get
		{
			if (version >= OVRP_1_7_0.version)
			{
				return OVRP_1_7_0.ovrp_GetAppChromaticCorrection() == Bool.True;
			}
			return false;
		}
		set
		{
			if (version >= OVRP_1_7_0.version)
			{
				OVRP_1_7_0.ovrp_SetAppChromaticCorrection(ToBool(value));
			}
		}
	}

	public static bool monoscopic
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetAppMonoscopic() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetAppMonoscopic(ToBool(value));
		}
	}

	public static bool rotation
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingOrientationEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingOrientationEnabled(ToBool(value));
		}
	}

	public static bool position
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingPositionEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingPositionEnabled(ToBool(value));
		}
	}

	public static bool useIPDInPositionTracking
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetTrackingIPDEnabled() == Bool.True;
			}
			return true;
		}
		set
		{
			if (version >= OVRP_1_6_0.version)
			{
				OVRP_1_6_0.ovrp_SetTrackingIPDEnabled(ToBool(value));
			}
		}
	}

	public static bool positionSupported => OVRP_1_1_0.ovrp_GetTrackingPositionSupported() == Bool.True;

	public static bool positionTracked => OVRP_1_1_0.ovrp_GetNodePositionTracked(Node.EyeCenter) == Bool.True;

	public static bool powerSaving => OVRP_1_1_0.ovrp_GetSystemPowerSavingMode() == Bool.True;

	public static bool hmdPresent => OVRP_1_1_0.ovrp_GetNodePresent(Node.EyeCenter) == Bool.True;

	public static bool userPresent => OVRP_1_1_0.ovrp_GetUserPresent() == Bool.True;

	public static bool headphonesPresent => OVRP_1_3_0.ovrp_GetSystemHeadphonesPresent() == Bool.True;

	public static int recommendedMSAALevel
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetSystemRecommendedMSAALevel();
			}
			return 2;
		}
	}

	public static SystemRegion systemRegion
	{
		get
		{
			if (version >= OVRP_1_5_0.version)
			{
				return OVRP_1_5_0.ovrp_GetSystemRegion();
			}
			return SystemRegion.Unspecified;
		}
	}

	public static string audioOutId
	{
		get
		{
			try
			{
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioOutId();
				if (intPtr != IntPtr.Zero)
				{
					GUID gUID = (GUID)Marshal.PtrToStructure(intPtr, typeof(GUID));
					Guid guid = new Guid(gUID.a, gUID.b, gUID.c, gUID.d0, gUID.d1, gUID.d2, gUID.d3, gUID.d4, gUID.d5, gUID.d6, gUID.d7);
					if (guid != _cachedAudioOutGuid)
					{
						_cachedAudioOutGuid = guid;
						_cachedAudioOutString = _cachedAudioOutGuid.ToString();
					}
					return _cachedAudioOutString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static string audioInId
	{
		get
		{
			try
			{
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioInId();
				if (intPtr != IntPtr.Zero)
				{
					GUID gUID = (GUID)Marshal.PtrToStructure(intPtr, typeof(GUID));
					Guid guid = new Guid(gUID.a, gUID.b, gUID.c, gUID.d0, gUID.d1, gUID.d2, gUID.d3, gUID.d4, gUID.d5, gUID.d6, gUID.d7);
					if (guid != _cachedAudioInGuid)
					{
						_cachedAudioInGuid = guid;
						_cachedAudioInString = _cachedAudioInGuid.ToString();
					}
					return _cachedAudioInString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static bool hasVrFocus => OVRP_1_1_0.ovrp_GetAppHasVrFocus() == Bool.True;

	public static bool shouldQuit => OVRP_1_1_0.ovrp_GetAppShouldQuit() == Bool.True;

	public static bool shouldRecenter => OVRP_1_1_0.ovrp_GetAppShouldRecenter() == Bool.True;

	public static string productName => OVRP_1_1_0.ovrp_GetSystemProductName();

	public static string latency => OVRP_1_1_0.ovrp_GetAppLatencyTimings();

	public static float eyeDepth
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeDepth();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeDepth(value);
		}
	}

	public static float eyeHeight
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeHeight();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeHeight(value);
		}
	}

	public static float batteryLevel => OVRP_1_1_0.ovrp_GetSystemBatteryLevel();

	public static float batteryTemperature => OVRP_1_1_0.ovrp_GetSystemBatteryTemperature();

	public static int cpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemCpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemCpuLevel(value);
		}
	}

	public static int gpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemGpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemGpuLevel(value);
		}
	}

	public static int vsyncCount
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemVSyncCount();
		}
		set
		{
			OVRP_1_2_0.ovrp_SetSystemVSyncCount(value);
		}
	}

	public static float systemVolume => OVRP_1_1_0.ovrp_GetSystemVolume();

	public static float ipd
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserIPD();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserIPD(value);
		}
	}

	public static bool occlusionMesh
	{
		get
		{
			return OVRP_1_3_0.ovrp_GetEyeOcclusionMeshEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_3_0.ovrp_SetEyeOcclusionMeshEnabled(ToBool(value));
		}
	}

	public static BatteryStatus batteryStatus => OVRP_1_1_0.ovrp_GetSystemBatteryStatus();

	public static Posef GetEyeVelocity(Eye eyeId)
	{
		return GetNodeVelocity((Node)eyeId, usePhysicsPose: false);
	}

	public static Posef GetEyeAcceleration(Eye eyeId)
	{
		return GetNodeAcceleration((Node)eyeId, usePhysicsPose: false);
	}

	public static Frustumf GetEyeFrustum(Eye eyeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)eyeId);
	}

	public static Sizei GetEyeTextureSize(Eye eyeId)
	{
		return OVRP_0_1_0.ovrp_GetEyeTextureSize(eyeId);
	}

	public static Posef GetTrackerPose(Tracker trackerId)
	{
		return GetNodePose((Node)(trackerId + 5), usePhysicsPose: false);
	}

	public static Frustumf GetTrackerFrustum(Tracker trackerId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)(trackerId + 5));
	}

	public static bool ShowUI(PlatformUI ui)
	{
		return OVRP_1_1_0.ovrp_ShowSystemUI(ui) == Bool.True;
	}

	public static bool SetOverlayQuad(bool onTop, bool headLocked, IntPtr leftTexture, IntPtr rightTexture, IntPtr device, Posef pose, Vector3f scale, int layerIndex = 0, OverlayShape shape = OverlayShape.Quad)
	{
		if (version >= OVRP_1_6_0.version)
		{
			uint num = 0u;
			if (onTop)
			{
				num |= 1u;
			}
			if (headLocked)
			{
				num |= 2u;
			}
			if (shape == OverlayShape.Cylinder || shape == OverlayShape.Cubemap)
			{
				if (!(version >= OVRP_1_7_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.OffcenterCubemap)
			{
				if (!(version >= OVRP_1_11_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			return OVRP_1_6_0.ovrp_SetOverlayQuad3(num, leftTexture, rightTexture, device, pose, scale, layerIndex) == Bool.True;
		}
		if (layerIndex != 0)
		{
			return false;
		}
		return OVRP_0_1_1.ovrp_SetOverlayQuad2(ToBool(onTop), ToBool(headLocked), leftTexture, device, pose, scale) == Bool.True;
	}

	public static bool UpdateNodePhysicsPoses(int frameIndex, double predictionSeconds)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_Update2(0, frameIndex, predictionSeconds) == Bool.True;
		}
		return false;
	}

	public static Posef GetNodePose(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodePose2(0, nodeId);
		}
		return OVRP_0_1_2.ovrp_GetNodePose(nodeId);
	}

	public static Posef GetNodeVelocity(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodeVelocity2(0, nodeId);
		}
		return OVRP_0_1_3.ovrp_GetNodeVelocity(nodeId);
	}

	public static Posef GetNodeAcceleration(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodeAcceleration2(0, nodeId);
		}
		return OVRP_0_1_3.ovrp_GetNodeAcceleration(nodeId);
	}

	public static bool GetNodePresent(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePresent(nodeId) == Bool.True;
	}

	public static bool GetNodeOrientationTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeOrientationTracked(nodeId) == Bool.True;
	}

	public static bool GetNodePositionTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePositionTracked(nodeId) == Bool.True;
	}

	public static ControllerState GetControllerState(uint controllerMask)
	{
		return OVRP_1_1_0.ovrp_GetControllerState(controllerMask);
	}

	public static ControllerState2 GetControllerState2(uint controllerMask)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetControllerState2(controllerMask);
		}
		return new ControllerState2(OVRP_1_1_0.ovrp_GetControllerState(controllerMask));
	}

	public static bool SetControllerVibration(uint controllerMask, float frequency, float amplitude)
	{
		return OVRP_0_1_2.ovrp_SetControllerVibration(controllerMask, frequency, amplitude) == Bool.True;
	}

	public static HapticsDesc GetControllerHapticsDesc(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsDesc(controllerMask);
		}
		return default(HapticsDesc);
	}

	public static HapticsState GetControllerHapticsState(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsState(controllerMask);
		}
		return default(HapticsState);
	}

	public static bool SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_SetControllerHaptics(controllerMask, hapticsBuffer) == Bool.True;
		}
		return false;
	}

	public static float GetEyeRecommendedResolutionScale()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetEyeRecommendedResolutionScale();
		}
		return 1f;
	}

	public static float GetAppCpuStartToGpuEndTime()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetAppCpuStartToGpuEndTime();
		}
		return 0f;
	}

	public static bool GetBoundaryConfigured()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryConfigured() == Bool.True;
		}
		return false;
	}

	public static BoundaryTestResult TestBoundaryNode(Node nodeId, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryNode(nodeId, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static BoundaryTestResult TestBoundaryPoint(Vector3f point, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryPoint(point, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static bool SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryLookAndFeel(lookAndFeel) == Bool.True;
		}
		return false;
	}

	public static bool ResetBoundaryLookAndFeel()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_ResetBoundaryLookAndFeel() == Bool.True;
		}
		return false;
	}

	public static BoundaryGeometry GetBoundaryGeometry(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryGeometry(boundaryType);
		}
		return default(BoundaryGeometry);
	}

	public static bool GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount)
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetBoundaryGeometry2(boundaryType, points, ref pointsCount) == Bool.True;
		}
		pointsCount = 0;
		return false;
	}

	public static AppPerfStats GetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetAppPerfStats();
		}
		return default(AppPerfStats);
	}

	public static bool ResetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_ResetAppPerfStats() == Bool.True;
		}
		return false;
	}

	public static EyeTextureFormat GetDesiredEyeTextureFormat()
	{
		if (version >= OVRP_1_11_0.version)
		{
			uint num = (uint)OVRP_1_11_0.ovrp_GetDesiredEyeTextureFormat();
			if (num == 1)
			{
				num = 0u;
			}
			return (EyeTextureFormat)num;
		}
		return EyeTextureFormat.Default;
	}

	public static bool SetDesiredEyeTextureFormat(EyeTextureFormat value)
	{
		if (version >= OVRP_1_11_0.version)
		{
			return OVRP_1_11_0.ovrp_SetDesiredEyeTextureFormat(value) == Bool.True;
		}
		return false;
	}

	public static Vector3f GetBoundaryDimensions(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryDimensions(boundaryType);
		}
		return default(Vector3f);
	}

	public static bool GetBoundaryVisible()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryVisible() == Bool.True;
		}
		return false;
	}

	public static bool SetBoundaryVisible(bool value)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryVisible(ToBool(value)) == Bool.True;
		}
		return false;
	}

	public static SystemHeadset GetSystemHeadsetType()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetSystemHeadsetType();
		}
		return SystemHeadset.None;
	}

	public static Controller GetActiveController()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetActiveController();
		}
		return Controller.None;
	}

	public static Controller GetConnectedControllers()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetConnectedControllers();
		}
		return Controller.None;
	}

	private static Bool ToBool(bool b)
	{
		return b ? Bool.True : Bool.False;
	}

	public static TrackingOrigin GetTrackingOriginType()
	{
		return OVRP_1_0_0.ovrp_GetTrackingOriginType();
	}

	public static bool SetTrackingOriginType(TrackingOrigin originType)
	{
		return OVRP_1_0_0.ovrp_SetTrackingOriginType(originType) == Bool.True;
	}

	public static Posef GetTrackingCalibratedOrigin()
	{
		return OVRP_1_0_0.ovrp_GetTrackingCalibratedOrigin();
	}

	public static bool SetTrackingCalibratedOrigin()
	{
		return OVRP_1_2_0.ovrpi_SetTrackingCalibratedOrigin() == Bool.True;
	}

	public static bool RecenterTrackingOrigin(RecenterFlags flags)
	{
		return OVRP_1_0_0.ovrp_RecenterTrackingOrigin((uint)flags) == Bool.True;
	}
}
public class OVRTracker
{
	public struct Frustum
	{
		public float nearZ;

		public float farZ;

		public Vector2 fov;
	}

	public bool isPresent
	{
		get
		{
			if (!OVRPlugin.hmdPresent)
			{
				return false;
			}
			return OVRPlugin.positionSupported;
		}
	}

	public bool isPositionTracked => OVRPlugin.positionTracked;

	public bool isEnabled
	{
		get
		{
			if (!OVRPlugin.hmdPresent)
			{
				return false;
			}
			return OVRPlugin.position;
		}
		set
		{
			if (OVRPlugin.hmdPresent)
			{
				OVRPlugin.position = value;
			}
		}
	}

	public int count
	{
		get
		{
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				if (GetPresent(i))
				{
					num++;
				}
			}
			return num;
		}
	}

	public Frustum GetFrustum(int tracker = 0)
	{
		if (!OVRPlugin.hmdPresent)
		{
			return default(Frustum);
		}
		return OVRPlugin.GetTrackerFrustum((OVRPlugin.Tracker)tracker).ToFrustum();
	}

	public OVRPose GetPose(int tracker = 0)
	{
		if (!OVRPlugin.hmdPresent)
		{
			return OVRPose.identity;
		}
		OVRPose oVRPose;
		switch (tracker)
		{
		case 0:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, usePhysicsPose: false).ToOVRPose();
			break;
		case 1:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerOne, usePhysicsPose: false).ToOVRPose();
			break;
		case 2:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerTwo, usePhysicsPose: false).ToOVRPose();
			break;
		case 3:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerThree, usePhysicsPose: false).ToOVRPose();
			break;
		default:
			return OVRPose.identity;
		}
		OVRPose result = default(OVRPose);
		result.position = oVRPose.position;
		result.orientation = oVRPose.orientation * Quaternion.Euler(0f, 180f, 0f);
		return result;
	}

	public bool GetPoseValid(int tracker = 0)
	{
		if (!OVRPlugin.hmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}

	public bool GetPresent(int tracker = 0)
	{
		if (!OVRPlugin.hmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}
}
public class OVRCubemapCapture : MonoBehaviour
{
	public bool autoTriggerAfterLaunch = true;

	public float autoTriggerDelay = 1f;

	private float autoTriggerElapse;

	public KeyCode triggeredByKey = KeyCode.F8;

	public string pathName;

	public int cubemapSize = 2048;

	private void Update()
	{
		if (autoTriggerAfterLaunch)
		{
			autoTriggerElapse += Time.deltaTime;
			if (autoTriggerElapse >= autoTriggerDelay)
			{
				autoTriggerAfterLaunch = false;
				TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
			}
		}
		if (Input.GetKeyDown(triggeredByKey))
		{
			TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
		}
	}

	public static void TriggerCubemapCapture(Vector3 capturePos, int cubemapSize = 2048, string pathName = null)
	{
		GameObject gameObject = new GameObject("CubemapCamera", typeof(Camera));
		gameObject.hideFlags = HideFlags.HideAndDontSave;
		gameObject.transform.position = capturePos;
		gameObject.transform.rotation = Quaternion.identity;
		Camera component = gameObject.GetComponent<Camera>();
		component.farClipPlane = 10000f;
		component.enabled = false;
		Cubemap cubemap = new Cubemap(cubemapSize, TextureFormat.RGB24, mipmap: false);
		RenderIntoCubemap(component, cubemap);
		SaveCubemapCapture(cubemap, pathName);
		UnityEngine.Object.DestroyImmediate(cubemap);
		UnityEngine.Object.DestroyImmediate(gameObject);
	}

	public static void RenderIntoCubemap(Camera ownerCamera, Cubemap outCubemap)
	{
		int width = outCubemap.width;
		int height = outCubemap.height;
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		Vector3[] array2 = new Vector3[6]
		{
			new Vector3(0f, 90f, 0f),
			new Vector3(0f, -90f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};
		RenderTexture active = RenderTexture.active;
		float fieldOfView = ownerCamera.fieldOfView;
		float aspect = ownerCamera.aspect;
		Quaternion rotation = ownerCamera.transform.rotation;
		RenderTexture renderTexture = new RenderTexture(width, height, 24);
		renderTexture.antiAliasing = 8;
		renderTexture.dimension = TextureDimension.Tex2D;
		renderTexture.hideFlags = HideFlags.HideAndDontSave;
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGB24, mipmap: false);
		texture2D.hideFlags = HideFlags.HideAndDontSave;
		ownerCamera.targetTexture = renderTexture;
		ownerCamera.fieldOfView = 90f;
		ownerCamera.aspect = 1f;
		Color[] array3 = new Color[texture2D.height * texture2D.width];
		for (int i = 0; i < array.Length; i++)
		{
			ownerCamera.transform.eulerAngles = array2[i];
			ownerCamera.Render();
			RenderTexture.active = renderTexture;
			texture2D.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
			Color[] pixels = texture2D.GetPixels();
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref Color reference = ref array3[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			outCubemap.SetPixels(array3, array[i]);
		}
		outCubemap.SmoothEdges();
		RenderTexture.active = active;
		ownerCamera.fieldOfView = fieldOfView;
		ownerCamera.aspect = aspect;
		ownerCamera.transform.rotation = rotation;
		ownerCamera.targetTexture = active;
		UnityEngine.Object.DestroyImmediate(texture2D);
		UnityEngine.Object.DestroyImmediate(renderTexture);
	}

	public static bool SaveCubemapCapture(Cubemap cubemap, string pathName = null)
	{
		int width = cubemap.width;
		int height = cubemap.height;
		int num = 0;
		int y = 0;
		bool flag = true;
		string text;
		string text2;
		if (string.IsNullOrEmpty(pathName))
		{
			text = UnityEngine.Application.persistentDataPath + "/OVR_ScreenShot360/";
			text2 = null;
		}
		else
		{
			text = Path.GetDirectoryName(pathName);
			text2 = Path.GetFileName(pathName);
			if (text[text.Length - 1] != '/' || text[text.Length - 1] != '\\')
			{
				text += "/";
			}
		}
		if (string.IsNullOrEmpty(text2))
		{
			text2 = "OVR_" + DateTime.Now.ToString("hh_mm_ss") + ".png";
		}
		string extension = Path.GetExtension(text2);
		if (extension == ".png")
		{
			flag = true;
		}
		else
		{
			if (!(extension == ".jpg"))
			{
				UnityEngine.Debug.LogError("Unsupported file format" + extension);
				return false;
			}
			flag = false;
		}
		try
		{
			Directory.CreateDirectory(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Failed to create path " + text + " since " + ex.ToString());
			return false;
		}
		Texture2D texture2D = new Texture2D(width * 6, height, TextureFormat.RGB24, mipmap: false);
		if (texture2D == null)
		{
			UnityEngine.Debug.LogError("[OVRScreenshotWizard] Failed creating the texture!");
			return false;
		}
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		for (int i = 0; i < array.Length; i++)
		{
			Color[] array2 = null;
			Color[] pixels = cubemap.GetPixels(array[i]);
			array2 = new Color[pixels.Length];
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref Color reference = ref array2[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			texture2D.SetPixels(num, y, width, height, array2);
			num += width;
		}
		try
		{
			byte[] bytes = ((!flag) ? texture2D.EncodeToJPG() : texture2D.EncodeToPNG());
			File.WriteAllBytes(text + text2, bytes);
			UnityEngine.Debug.Log("Cubemap file created " + text + text2);
		}
		catch (Exception ex2)
		{
			UnityEngine.Debug.LogError("Failed to save cubemap file since " + ex2.ToString());
			return false;
		}
		UnityEngine.Object.DestroyImmediate(texture2D);
		return true;
	}
}
namespace Oculus.Platform
{
	public enum AchievementType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create(string.Empty, 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				UnityEngine.Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				UnityEngine.Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
namespace Oculus.Platform
{
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					ref ovrKeyValuePair reference = ref array[num];
					reference = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					ref ovrKeyValuePair reference2 = ref array[num];
					reference2 = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (item.Value.GetType() != typeof(double))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					ref ovrKeyValuePair reference3 = ref array[num];
					reference3 = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers, UIntPtr count)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data, uint numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data, uint numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);
	}
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			CallbackRunner callbackRunner = UnityEngine.Object.FindObjectOfType<CallbackRunner>();
			if (callbackRunner != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public enum CloudStorageDataStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType : uint
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated
	}
	public enum LeaderboardFilterType : uint
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt : uint
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum MatchmakingCriterionImportance : uint
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetUserProof = 578880643u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Oculus.Platform.Models.Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool flag = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (flag)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Oculus.Platform.Models.Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Oculus.Platform.Models.Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					UnityEngine.Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementDefinitionArray(obj);
			return new AchievementDefinitionList(a);
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementProgressArray(obj);
			return new AchievementProgressList(a);
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAchievementUpdate(obj);
			return new AchievementUpdate(o);
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetApplicationVersion(obj);
			return new ApplicationVersion(o);
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageConflictMetadata(obj);
			return new CloudStorageConflictMetadata(o);
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageData(obj);
			return new CloudStorageData(o);
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageMetadata(obj);
			return new CloudStorageMetadata(o);
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCloudStorageMetadataArray(obj);
			return new CloudStorageMetadataList(a);
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageUpdateResponse(obj);
			return new CloudStorageUpdateResponse(o);
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetInstalledApplicationArray(obj);
			return new InstalledApplicationList(a);
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLeaderboardEntryArray(obj);
			return new LeaderboardEntryList(a);
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStatus(obj);
			return new LivestreamingStatus(o);
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingAdminSnapshot(obj);
			return new MatchmakingAdminSnapshot(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResult(obj);
			return new MatchmakingEnqueueResult(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(obj);
			return new MatchmakingEnqueueResultAndRoom(o);
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingStats(obj);
			return new MatchmakingStats(o);
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetOrgScopedID(obj);
			return new OrgScopedID(o);
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPidArray(obj);
			return new PidList(a);
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetProductArray(obj);
			return new ProductList(a);
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPurchase(obj);
			return new Purchase(o);
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPurchaseArray(obj);
			return new PurchaseList(a);
		}
	}
	public class MessageWithRoom : Message<Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomArray(obj);
			return new RoomList(a);
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomInviteNotificationArray(obj);
			return new RoomInviteNotificationList(a);
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemVoipState(obj);
			return new SystemVoipState(o);
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUser(obj);
			return new User(o);
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserArray(obj);
			return new UserList(a);
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserProof(obj);
			return new UserProof(o);
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), (!flag) ? new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)) : null);
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr obj2 = CAPI.ovr_Message_GetLeaderboardUpdateStatus(obj);
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(obj2);
		}
	}
	public class MessageWithMatchmakingNotification : Message<Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingBrowseResult(obj);
			return new MatchmakingBrowseResult(o);
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetHttpTransferUpdate(obj);
			return new HttpTransferUpdate(o);
		}
	}
	public class MicrophoneInputNative : IMicrophone
	{
		private IntPtr mic;

		private int tempBufferSize = 9600;

		private float[] tempBuffer;

		public MicrophoneInputNative()
		{
			mic = CAPI.ovr_Microphone_Create();
			CAPI.ovr_Microphone_Start(mic);
			tempBuffer = new float[tempBufferSize];
			UnityEngine.Debug.Log(mic);
		}

		public float[] Update()
		{
			ulong num = (ulong)CAPI.ovr_Microphone_ReadData(mic, tempBuffer, (UIntPtr)(ulong)tempBufferSize);
			if (num != 0)
			{
				float[] array = new float[num];
				Array.Copy(tempBuffer, array, (int)num);
				return array;
			}
			return null;
		}

		public void Start()
		{
		}

		public void Stop()
		{
			CAPI.ovr_Microphone_Stop(mic);
			CAPI.ovr_Microphone_Destroy(mic);
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public int Count => _Data.Count;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LaunchDetails
	{
		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			Users = new UserList(CAPI.ovr_LaunchDetails_GetUsers(o));
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool LivestreamingEnabled;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			AdminSnapshot = new MatchmakingAdminSnapshot(CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o));
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec => (!pingTimeUsec.HasValue) ? 0 : pingTimeUsec.Value;

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class Product
	{
		public readonly string Sku;

		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public Product(IntPtr o)
		{
			Sku = CAPI.ovr_Product_GetSKU(o);
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly string Sku;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public Purchase(IntPtr o)
		{
			Sku = CAPI.ovr_Purchase_GetSKU(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ID;

		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ID = CAPI.ovr_Room_GetID(o);
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			InvitedUsers = new UserList(CAPI.ovr_Room_GetInvitedUsers(o));
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			Owner = new User(CAPI.ovr_Room_GetOwner(o));
			Type = CAPI.ovr_Room_GetType(o);
			Users = new UserList(CAPI.ovr_Room_GetUsers(o));
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
}
namespace Oculus.Platform
{
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			System.GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		public static void Initialize(string appId = null)
		{
			bool flag = UnityEngine.Application.platform == RuntimePlatform.WindowsEditor && !PlatformSettings.UseStandalonePlatform;
			if (!UnityEngine.Application.isEditor || flag)
			{
				string appIDFromConfig = GetAppIDFromConfig(flag);
				if (string.IsNullOrEmpty(appId))
				{
					if (string.IsNullOrEmpty(appIDFromConfig))
					{
						throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
					}
					appId = appIDFromConfig;
				}
				else if (!string.IsNullOrEmpty(appIDFromConfig))
				{
					UnityEngine.Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is clobbering appId ({1}) that you passed in to Platform.Core.Init.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
				}
			}
			if (flag)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform.Initialize(appId);
			}
			else if (UnityEngine.Application.isEditor)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				IsPlatformInitialized = standalonePlatform.InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				AndroidPlatform androidPlatform = new AndroidPlatform();
				IsPlatformInitialized = androidPlatform.Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.WindowsPlayer)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				WindowsPlatform windowsPlatform2 = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform2.Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig(bool forceWindows)
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			if (UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer || forceWindows)
			{
				return PlatformSettings.AppID;
			}
			return null;
		}
	}
	public static class Rooms
	{
		public static Request<Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToNotifications = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToNotifications));
			}
			return null;
		}

		public static Request<Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request<Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Room> Join(ulong roomID, bool subscribeToNotifications = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join(roomID, subscribeToNotifications));
			}
			return null;
		}

		public static Request<Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static Request<Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus lockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, lockStatus));
			}
			return null;
		}

		public static Request<Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array, (uint)array.Length));
			}
			return null;
		}

		public static Request<Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Room> UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static void SetUpdateNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData ovrMatchmakingCustomQueryData = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length > 0)
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					ovrMatchmakingCustomQueryData.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = 0u;
					ovrMatchmakingCustomQueryData.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = (uint)data.Count;
					ovrMatchmakingCustomQueryData.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = 0u;
					ovrMatchmakingCustomQueryData.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ovrMatchmakingCustomQueryData));
				Marshal.StructureToPtr(ovrMatchmakingCustomQueryData, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToNotifications = false, CustomQuery customQuery = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToNotifications, customQuery?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Room> CreateRoom(string pool, uint maxUsers, bool subscribeToNotifications = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToNotifications));
			}
			return null;
		}

		public static Request<Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQuery = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQuery?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array, (uint)array.Length));
			}
			return null;
		}

		public static Request Enqueue(string pool, CustomQuery customQuery = null)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Enqueue(pool, customQuery?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request EnqueueRoom(ulong roomID, CustomQuery customQuery = null)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQuery?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static Request Cancel(string pool, string traceID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, traceID));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}

		public static Request<Room> JoinRoom(ulong roomID, bool subscribeToNotifications = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToNotifications));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			return Core.IsInitialized() && CAPI.ovr_Net_IsConnected(userID);
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
			}
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
			}
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, names.Length));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, names.Length));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (uint)data.Length, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, skus.Length));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_GetInstalledApplications = 1376744524u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_Post = 1798743375u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.Party_Leave:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.GraphAPI_Post:
				result = new MessageWithString(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = string.Empty;

		[SerializeField]
		private string ovrMobileAppID = string.Empty;

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinPolicy : uint
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomJoinability : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomMembershipLockStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SendPolicy : uint
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		public bool InitializeInEditor()
		{
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformAccessToken))
			{
				throw new UnityException("Update your access token by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			return Initialize(StandalonePlatformSettings.OculusPlatformAccessToken);
		}

		public bool Initialize(string accessToken)
		{
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitWrapperStandalone(accessToken, IntPtr.Zero);
			return true;
		}
	}
	public sealed class StandalonePlatformSettings : ScriptableObject
	{
		private const string OculusPlatformAccessTokenKey = "OculusPlatformAccessToken";

		public static string OculusPlatformAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum UserOrdering : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						UnityEngine.Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					UnityEngine.Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				for (int i = 0; i < num; i++)
				{
					float num5 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num5;
					}
				}
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging = true;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			FilterReadDelegate component = audioSource.gameObject.GetComponent<FilterReadDelegate>();
			component.parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				UnityEngine.Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					UnityEngine.Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipMuteState : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, IntPtr.Zero);
			return true;
		}
	}
}
public class Oculus_Splash : MonoBehaviour
{
	private bool isAnimationComplete;

	private HagletResettable loadFrontEndRoutine;

	private Animator splashAnimator;

	private int totalTasks;

	private int completedTasks;

	private Func<float> currentTaskProgress;

	private void Awake()
	{
		totalTasks = 9;
		totalTasks += 4;
		totalTasks += 3;
		totalTasks += 20;
		splashAnimator = GetComponent<Animator>();
		UnityEngine.Object.Instantiate(Resources.Load<UILoadingBar>("UI/P_UILoadingBar")).Awake();
		UILoadingBar.Inst.SetRelativeCamera(base.transform.parent.GetComponentInChildren<Camera>().transform);
		AEResources.Initialise();
		AEMisc.PrefetchUnityPaths();
		loadFrontEndRoutine = new HagletResettable(LoadFrontEndRoutine());
		LR.Host.StartTopLevel(loadFrontEndRoutine);
	}

	private void Update()
	{
		LR.Host.Step(HagletStepTime.Update);
	}

	private void LateUpdate()
	{
		LR.Host.Step(HagletStepTime.LateUpdate);
		if (UILoadingBar.Inst.IsShown)
		{
			while (completedTasks > 0)
			{
				UILoadingBar.Inst.IncrementProgressChunks();
				completedTasks--;
			}
			if (currentTaskProgress != null)
			{
				UILoadingBar.Inst.SetProgressToNextChunk(currentTaskProgress());
			}
		}
	}

	public void AnimationEnd()
	{
		isAnimationComplete = true;
		UILoadingBar.Inst.Show(totalTasks);
	}

	private IEnumerator<HagletYieldTerm> LoadFrontEndRoutine()
	{
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		completedTasks = 0;
		AC.Inst.Init(threaded: true);
		splashAnimator.SetTrigger("Start");
		yield return Wait.Until(() => AC.Inst.Initialized);
		completedTasks++;
		yield return Localisation.Instance.LoadLocalization(synchronous: false);
		completedTasks++;
		yield return AEResources.UnpackFileFromJar("FMOD Banks/Master Bank.bank", AEMisc.GetUnpackedPath("FMOD Banks/Master Bank.bank"));
		completedTasks++;
		yield return AEResources.UnpackFileFromJar("FMOD Banks/Master Bank.strings.bank", AEMisc.GetUnpackedPath("FMOD Banks/Master Bank.strings.bank"));
		completedTasks++;
		yield return AEResources.UnpackFileFromJar("FMOD Banks/Externals.bank", AEMisc.GetUnpackedPath("FMOD Banks/Externals.bank"));
		completedTasks++;
		AC.Inst.LoadBank(AEMisc.GetUnpackedPath("FMOD Banks/Master Bank.strings.bank"), includeSamples: false, null);
		yield return Wait.While(() => AC.Inst.loadingUnloading);
		completedTasks++;
		AC.Inst.LoadBank(AEMisc.GetUnpackedPath("FMOD Banks/Master Bank.bank"), includeSamples: false, null);
		yield return Wait.While(() => AC.Inst.loadingUnloading);
		completedTasks++;
		AC.Inst.LoadBank(AEMisc.GetUnpackedPath("FMOD Banks/Externals.bank"), includeSamples: false, null);
		yield return Wait.While(() => AC.Inst.loadingUnloading);
		completedTasks++;
		AC.Inst.PostMasterInit();
		yield return VOController.Inst.LoadAllVOGuids(synchronous: false);
		completedTasks++;
		yield return Wait.Until(() => isAnimationComplete);
		AEResources.LoadBundle("assetbundles/core.unity3d");
		yield return Wait.ForChildren;
		completedTasks++;
		AEResources.LoadBundle("assetbundles/core_scenes.unity3d");
		yield return Wait.ForChildren;
		completedTasks++;
		currentTaskProgress = () => (float)PSC.Inst.LoadedPoolCount / (float)PSC.Inst.TotalPoolCount;
		yield return Wait.Until(PSC.Inst.allPoolsLoaded);
		currentTaskProgress = null;
		completedTasks++;
		AEResources.LoadBundle("assetbundles/external.unity3d");
		yield return Wait.ForChildren;
		completedTasks++;
		AEResources.LoadBundle("assetbundles/external_scenes.unity3d");
		yield return Wait.ForChildren;
		completedTasks++;
		yield return SaveData.Retain(unthreaded: false, silent: true);
		completedTasks++;
		UnityEngine.AsyncOperation loadSceneOp = SceneManager.LoadSceneAsync("_FrontEnd");
		loadSceneOp.allowSceneActivation = false;
		currentTaskProgress = () => loadSceneOp.progress;
		yield return Wait.While(() => loadSceneOp.progress < 0.9f);
		currentTaskProgress = null;
		completedTasks++;
		yield return Wait.ForSeconds(0.5f);
		System.GC.Collect();
		loadSceneOp.allowSceneActivation = true;
	}

	[Conditional("AE_DEBUG")]
	private void Log(string message)
	{
		UnityEngine.Debug.Log("[SPLASH] " + message);
	}
}
[Serializable]
public class AEAnimClip : AEScriptableResource
{
	public AnimationClip clipRef;

	[NonSerialized]
	[HideInInspector]
	public new string name;

	public List<AEAnimEvent> events = new List<AEAnimEvent>();

	[NonSerialized]
	[HideInInspector]
	public HagletTrigger OnComplete = new HagletTrigger();

	public AnimationClip prefixAnimation;

	public AnimationClip suffixAnimation;

	[HideInInspector]
	public AEAnimClip prefixClipWithEvents;

	[HideInInspector]
	public AEAnimClip suffixClipWithEvents;

	public string AssetName
	{
		get
		{
			return base.name;
		}
		set
		{
			base.name = value;
		}
	}

	public float Duration { get; private set; }

	public void OnAwake()
	{
		if ((bool)clipRef)
		{
			Duration = clipRef.length;
			return;
		}
		Duration = 0f;
		for (int i = 0; i < events.Count; i++)
		{
			Duration = Mathf.Max(Duration, events[i].time + events[i].GetDuration());
		}
	}

	public void AcquireDuration()
	{
		if (clipRef == null)
		{
			Duration = 0f;
			for (int i = 0; i < events.Count; i++)
			{
				events[i].data.AcquireDuration();
				Duration = Mathf.Max(Duration, events[i].time + events[i].GetDuration());
			}
		}
	}

	public override string ToString()
	{
		return name;
	}
}
[Serializable]
public struct AEAnimEvent
{
	public class Comparer : IComparer<AEAnimEvent>
	{
		public int Compare(AEAnimEvent evtA, AEAnimEvent evtB)
		{
			if (evtA.time != evtB.time)
			{
				return (int)Mathf.Sign(evtA.time - evtB.time);
			}
			return evtA.GetHashCode() - evtB.GetHashCode();
		}
	}

	public float time;

	public AEAnimEventBase data;

	public int row;

	public static readonly IComparer<AEAnimEvent> chronOrder = new Comparer();

	public void Invoke(object target)
	{
		data.Invoke(target);
	}

	public float GetDuration()
	{
		data.AcquireDuration();
		return (!(data != null)) ? 0f : data.duration;
	}

	public UnityEngine.Component GetAnimFuncComponent(GameObject context, AEAnimClip clip)
	{
		Assembly assembly = typeof(AEAnimClip).Assembly;
		Type type = assembly.GetType(data.targetType);
		return context.GetComponent(type);
	}

	public AEAnimEvent Clone()
	{
		AEAnimEvent result = default(AEAnimEvent);
		result.time = time;
		result.data = UnityEngine.Object.Instantiate(data);
		result.row = row;
		return result;
	}
}
public abstract class AEAnimEventBase : ScriptableObject
{
	[HideInInspector]
	[SerializeField]
	public string targetType;

	[HideInInspector]
	[SerializeField]
	protected float _duration = 0.1f;

	public float duration => _duration;

	public abstract void Invoke(object target);

	public abstract void AcquireDuration();

	public abstract string GetDisplayName();
}
public class CharAnimSet : ScriptableObject
{
	public enum AnimID
	{
		Idle,
		Walk,
		Shoot,
		Die,
		Dead
	}

	[Serializable]
	public class FrameSet
	{
		public Sprite[] frames;
	}

	[Serializable]
	public class Anim
	{
		public FrameSet[] dirs;

		public float fps;
	}

	public Anim[] anims;
}
[Serializable]
public struct KubrickAnimatorAndClip
{
	public string animator;

	public string clipName;
}
public class KubrickAnimator : KubrickBase
{
	public const float defaultBlendTime = 0.25f;

	[ReadOnly]
	[NonSceneAsset]
	public AnimationClip[] clips;

	[HideInInspector]
	public float blending = 0.25f;

	public bool setGameObjectInactiveOnAwake;

	private Animation animComp;

	protected override void Awake()
	{
		base.Awake();
		if (setGameObjectInactiveOnAwake)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	protected override void OnAwake()
	{
		animComp = GetComponent<Animation>();
		if (animComp == null)
		{
			animComp = base.gameObject.AddComponent<Animation>();
		}
		animComp.clip = null;
		animComp.playAutomatically = false;
		animComp.animatePhysics = false;
		foreach (AnimationState item in animComp)
		{
			animComp.RemoveClip(item.clip);
		}
		string rawClipNamePrefixFirstHalf = GetRawClipNamePrefixFirstHalf(base.name);
		for (int i = 0; i < clips.Length; i++)
		{
			AEAnimClip aEAnimClip = ScriptableObject.CreateInstance<AEAnimClip>();
			string text2 = (aEAnimClip.AssetName = rawClipNamePrefixFirstHalf + clips[i].name);
			aEAnimClip.name = text2;
			aEAnimClip.clipRef = clips[i];
			AddClip(aEAnimClip);
		}
	}

	protected override void OnAwakeAnimClip(AEAnimClip clip)
	{
		animComp.AddClip(clip.clipRef, clip.clipRef.name);
	}

	protected override void AnimNameRemap(string oldName, string newName)
	{
		AnimationClip clip = animComp.GetClip(oldName);
		animComp.RemoveClip(oldName);
		animComp.AddClip(clip, newName);
	}

	protected override void OnPlay(string clipName)
	{
		if ((bool)MR.Inst && MR.Inst.IsSkipping() && animComp.GetClip(clipName) != null)
		{
			if (animComp.Play(clipName, PlayMode.StopAll))
			{
				animComp[clipName].normalizedTime = 1f;
				if (LR.DEBUG_autoTestFilters == null)
				{
					animComp.Sample();
				}
			}
		}
		else if (blending > 0f)
		{
			animComp.CrossFade(clipName, blending);
		}
		else
		{
			animComp.Play(clipName, PlayMode.StopAll);
		}
	}

	protected override void OnStop()
	{
	}

	public override void SetPaused(bool paused)
	{
		base.SetPaused(paused);
		if (animCurrent != null)
		{
			animComp[animCurrent.name].speed = (base.IsPlaying ? 1 : 0);
		}
	}

	protected override bool ClipExists(string clipName)
	{
		return animComp.GetClip(clipName) != null;
	}

	protected override void OnWrapModeChanged(WrapMode wrapMode)
	{
		animComp.wrapMode = wrapMode;
	}

	public void AddClip(AnimationClip clip)
	{
		AEMisc.ArrayAdd(ref clips, clip);
	}

	public override void SetTime(float time)
	{
		if (animCurrent != null)
		{
			base.SetTime(time);
			animComp[animCurrent.name].time = base.time;
		}
	}

	public void SampleAnimation(string clipName, float normalizedTime)
	{
		if (animComp.Play(clipName, PlayMode.StopAll))
		{
			animComp[clipName].normalizedTime = normalizedTime;
			animComp.Sample();
			animComp.Stop();
		}
	}
}
[RequireComponent(typeof(KubrickAnimator))]
public class KubrickAutoPlay : MonoBehaviour
{
	public string clipName;

	public float offset;

	private KubrickAnimator kubrickAnimator;

	private void Start()
	{
		kubrickAnimator = kubrickAnimator ?? GetComponent<KubrickAnimator>();
		kubrickAnimator.WrapMode = WrapMode.Loop;
		kubrickAnimator.Play(clipName);
		kubrickAnimator.SetTime(offset);
	}

	private void OnEnable()
	{
		if (kubrickAnimator != null && !string.IsNullOrEmpty(clipName))
		{
			kubrickAnimator.WrapMode = WrapMode.Loop;
			kubrickAnimator.Play(clipName);
			kubrickAnimator.SetTime(offset);
		}
	}
}
public class AEAnimFunc : Attribute
{
}
public abstract class KubrickBase : MonoBehaviour
{
	[ReadOnly]
	public AEAnimClip[] clipsWithEvents = new AEAnimClip[0];

	private UnityEngine.Component[][] clipEventTargets;

	protected float time;

	private float animDuration;

	private int eventIndex;

	protected AEAnimClip animCurrent;

	private int animCurrentIndex;

	[NonSerialized]
	public HagletTrigger OnAnimEnded = new HagletTrigger();

	private Dictionary<string, int> mapAnimNameToAnimIndex = new Dictionary<string, int>();

	private int pauseRequests;

	private Action onComplete;

	private HagletResettable skipClip;

	private string skipClipName;

	private WrapMode wrapMode;

	public bool IsPlaying => animCurrent != null && pauseRequests == 0;

	public WrapMode WrapMode
	{
		get
		{
			return wrapMode;
		}
		set
		{
			wrapMode = value;
			OnWrapModeChanged(value);
		}
	}

	public AEAnimClip GetCurrentClip => animCurrent;

	public float GetCurrentClipTime => time;

	public int GetCurrentEventIndex => eventIndex;

	protected abstract void OnPlay(string clipName);

	protected abstract void OnStop();

	protected virtual void OnAwakeAnimClip(AEAnimClip clip)
	{
	}

	protected virtual void OnAwake()
	{
	}

	protected virtual bool ClipExists(string clipName)
	{
		return true;
	}

	protected virtual void OnRemoveAllClips()
	{
	}

	protected virtual void OnWrapModeChanged(WrapMode wrapMode)
	{
	}

	protected virtual void AnimNameRemap(string oldName, string newName)
	{
	}

	protected virtual void Awake()
	{
		OnAwake();
		SyncAnimClips();
		skipClip = new HagletResettable(SkipClipRoutine(), "Skip Kubrick Animation Clip");
	}

	public void SyncAnimClips()
	{
		clipEventTargets = new UnityEngine.Component[clipsWithEvents.Length][];
		for (int i = 0; i < clipsWithEvents.Length; i++)
		{
			AEAnimClip aEAnimClip = clipsWithEvents[i];
			aEAnimClip.events.Sort(AEAnimEvent.chronOrder);
			ResolveEvents(aEAnimClip, i);
			aEAnimClip.OnAwake();
		}
		MapAnimNames();
		string rawClipNamePrefixSecondHalf = GetRawClipNamePrefixSecondHalf(base.name);
		for (int j = 0; j < clipsWithEvents.Length; j++)
		{
			AEAnimClip aEAnimClip2 = clipsWithEvents[j];
			if (aEAnimClip2.prefixAnimation != null)
			{
				aEAnimClip2.prefixClipWithEvents = GetClipByName(aEAnimClip2.prefixAnimation.name.Replace(rawClipNamePrefixSecondHalf, string.Empty));
			}
			if (aEAnimClip2.suffixAnimation != null)
			{
				aEAnimClip2.suffixClipWithEvents = GetClipByName(aEAnimClip2.suffixAnimation.name.Replace(rawClipNamePrefixSecondHalf, string.Empty));
			}
			OnAwakeAnimClip(aEAnimClip2);
		}
		foreach (KeyValuePair<string, int> item in mapAnimNameToAnimIndex)
		{
			AEAnimClip aEAnimClip3 = clipsWithEvents[item.Value];
			if (aEAnimClip3.clipRef != null)
			{
				AnimNameRemap(aEAnimClip3.clipRef.name, item.Key);
			}
		}
	}

	public HagletEvent Play(string clipName, Action onComplete = null)
	{
		this.onComplete = onComplete;
		if (IsPlaying)
		{
			Stop();
		}
		time = 0f;
		eventIndex = 0;
		OnPlay(clipName);
		if (!mapAnimNameToAnimIndex.TryGetValue(clipName, out animCurrentIndex))
		{
			animCurrent = null;
			animDuration = 0f;
			return null;
		}
		animCurrent = clipsWithEvents[animCurrentIndex];
		animCurrent.AcquireDuration();
		animDuration = animCurrent.Duration;
		return animCurrent.OnComplete;
	}

	public void Stop()
	{
		OnStop();
		OnAnimEnded.Trigger();
		animCurrent.OnComplete.Trigger();
		animCurrent = null;
	}

	public bool HasClip(string clipName)
	{
		if (HasEventClip(clipName))
		{
			return true;
		}
		if (ClipExists(clipName))
		{
			return true;
		}
		return false;
	}

	public void AddClip(AEAnimClip clip)
	{
		AEMisc.ArrayAdd(ref clipsWithEvents, clip);
	}

	public bool HasEventClip(string clipName)
	{
		return mapAnimNameToAnimIndex.ContainsKey(clipName);
	}

	public int GetEventCount<T>(string clipName) where T : AEAnimEventBase
	{
		int num = 0;
		if (mapAnimNameToAnimIndex.TryGetValue(clipName, out var value))
		{
			List<AEAnimEvent> events = clipsWithEvents[value].events;
			for (int i = 0; i < events.Count; i++)
			{
				if (events[i].data.GetType() == typeof(T))
				{
					num++;
				}
			}
		}
		return num;
	}

	public AEAnimClip TryGetClipByName(string animName)
	{
		int value = 0;
		if (!string.IsNullOrEmpty(animName) && mapAnimNameToAnimIndex.TryGetValue(animName, out value))
		{
			return clipsWithEvents[value];
		}
		return null;
	}

	public AEAnimClip GetClipByName(string animName)
	{
		int value = 0;
		if (!string.IsNullOrEmpty(animName) && mapAnimNameToAnimIndex.TryGetValue(animName, out value))
		{
			return clipsWithEvents[value];
		}
		UnityEngine.Debug.LogWarning("KUBRICK : Could not find animation clip with name '" + animName + "'", this);
		return null;
	}

	public virtual void Update()
	{
		if (!IsPlaying)
		{
			return;
		}
		List<AEAnimEvent> events = animCurrent.events;
		time += Time.deltaTime;
		while (eventIndex < events.Count)
		{
			AEAnimEvent aEAnimEvent = events[eventIndex];
			if (time > aEAnimEvent.time)
			{
				UnityEngine.Component target = clipEventTargets[animCurrentIndex][eventIndex];
				aEAnimEvent.Invoke(target);
				eventIndex++;
				continue;
			}
			break;
		}
		if (!(time > animDuration))
		{
			return;
		}
		switch (wrapMode)
		{
		case WrapMode.Default:
		case WrapMode.Once:
		case WrapMode.ClampForever:
			if (onComplete != null)
			{
				onComplete();
				onComplete = null;
			}
			Stop();
			break;
		case WrapMode.Loop:
			time -= animDuration;
			eventIndex = 0;
			break;
		}
	}

	public virtual void OnValidate()
	{
	}

	public virtual bool IsPaused()
	{
		return pauseRequests > 0;
	}

	public virtual void SetPaused(bool paused)
	{
		if (paused)
		{
			pauseRequests++;
		}
		else
		{
			pauseRequests--;
		}
	}

	private void MapAnimNames()
	{
		string fullRawClipNamePrefix = GetFullRawClipNamePrefix(base.name);
		mapAnimNameToAnimIndex = new Dictionary<string, int>();
		for (int i = 0; i < clipsWithEvents.Length; i++)
		{
			AEAnimClip aEAnimClip = clipsWithEvents[i];
			string key = (clipsWithEvents[i].name = clipsWithEvents[i].AssetName.Replace(fullRawClipNamePrefix, string.Empty));
			mapAnimNameToAnimIndex[key] = i;
		}
	}

	public string GetRawClipNamePrefixFirstHalf(string clipName)
	{
		return clipName.Replace("(Clone)", string.Empty) + "@";
	}

	public string GetRawClipNamePrefixSecondHalf(string clipName)
	{
		return clipName.Replace("(Clone)", string.Empty) + "_";
	}

	public string GetFullRawClipNamePrefix(string clipName)
	{
		return GetRawClipNamePrefixFirstHalf(clipName) + GetRawClipNamePrefixSecondHalf(clipName);
	}

	public string RemovePrefix(string clipNameWithPrefix)
	{
		string text = clipNameWithPrefix;
		while (text.Contains(base.name))
		{
			text = text.Remove(0, base.name.Length + 1);
		}
		return text;
	}

	public void ResolveEvents(AEAnimClip clip, int clipIndex)
	{
		clipEventTargets[clipIndex] = new UnityEngine.Component[clip.events.Count];
		for (int i = 0; i < clip.events.Count; i++)
		{
			AEAnimEvent aEAnimEvent = clip.events[i];
			clipEventTargets[clipIndex][i] = aEAnimEvent.GetAnimFuncComponent(base.gameObject, clip);
		}
	}

	[AEAnimFunc]
	private void Comment(string comment)
	{
		UnityEngine.Debug.Log("Kubrick: " + comment);
	}

	public HagletTrigger SkipClip(string customClip = "", int fromEvent = 0)
	{
		eventIndex = fromEvent;
		skipClipName = customClip;
		Routine.Start(skipClip, MR.Inst.Host);
		return OnAnimEnded;
	}

	public IEnumerator<HagletYieldTerm> SkipClipRoutine()
	{
		int eIndex = eventIndex;
		Play(skipClipName);
		for (List<AEAnimEvent> events = animCurrent.events; eIndex < events.Count; eIndex++)
		{
			UnityEngine.Component target = clipEventTargets[animCurrentIndex][eIndex];
			events[eIndex].Invoke(target);
			yield return Wait.ForChildren;
		}
		Stop();
	}

	public virtual float GetTime()
	{
		return time;
	}

	public virtual void SetTime(float time)
	{
		if (time > animDuration)
		{
			this.time = animDuration;
		}
		else
		{
			this.time = time;
		}
	}
}
public class KubrickDirector : KubrickBase
{
	public AEAnimClip DEBUG_lastEditedCutscene;

	protected override void OnPlay(string clipName)
	{
	}

	protected override void OnStop()
	{
	}
}
public class ModelSpriteAnimGenerator : MonoBehaviour
{
	[Serializable]
	public class NamedAngle
	{
		public string name;

		public float angle;
	}

	public Camera cam;

	public Transform target;

	public int width;

	public int height;

	public int defaultFPS;

	public int ppu;

	public string animSetsSubpath;

	public string framesSubpath;

	public string packingTag;

	public Vector2 pivot;
}
public class ModelSpriteGenerationSettings : MonoBehaviour
{
	[Serializable]
	public class FPSOverride
	{
		public string anim;

		public float fps;
	}

	public bool includeUp;

	public bool includeUpRight;

	public bool includeRight;

	public bool includeDownRight;

	public bool includeDown;

	public bool includeDownLeft;

	public bool includeLeft;

	public bool includeUpLeft;

	public FPSOverride[] fpsOverrides;

	public void Reset()
	{
		includeUp = true;
		includeUpRight = true;
		includeRight = true;
		includeDownRight = true;
		includeDown = true;
		includeDownLeft = true;
		includeLeft = true;
		includeUpLeft = true;
		fpsOverrides = new FPSOverride[0];
	}

	public bool IncludesDir(OctDir dir)
	{
		return dir switch
		{
			OctDir.Up => includeUp, 
			OctDir.UpRight => includeUpRight, 
			OctDir.Right => includeRight, 
			OctDir.DownRight => includeDownRight, 
			OctDir.Down => includeDown, 
			OctDir.DownLeft => includeDownLeft, 
			OctDir.Left => includeLeft, 
			_ => includeUpLeft, 
		};
	}

	public float GetFPS(string anim, float defaultFPS)
	{
		int num = fpsOverrides.Length;
		while (--num >= 0)
		{
			if (fpsOverrides[num].anim == anim)
			{
				return fpsOverrides[num].fps;
			}
		}
		return defaultFPS;
	}
}
[Serializable]
public class AIC : Singleton<AIC>, ITeamController
{
	public enum YAGATE
	{
		Frag,
		Stun,
		Flux
	}

	public interface IHasAIInventory
	{
		int AIInventory { get; }
	}

	[Serializable]
	public class AIParameters
	{
		[Range(0f, 1f)]
		public float aggression = 0.5f;

		[Range(0f, 1f)]
		public float selfishness = 0.5f;

		[Range(0f, 1f)]
		public float impatience = 0.1f;

		[Range(0f, 1f)]
		public float healingRatio = 0.4f;

		public YAGATE grenadeOrTrapType;

		public int startingInventory = 1;

		public int startingMedkits;

		[Range(0f, 8f)]
		public int maxActiveTraps = 1;
	}

	private class AIProperties
	{
		public float impatience;
	}

	private struct UnitThresholds
	{
		public readonly Unit unit;

		public readonly int healingHP;

		public readonly float hitChanceThreat;

		public readonly float totalThreat;

		public readonly float hitChance;

		public readonly float killThreatChance;

		public UnitThresholds(Unit unit, List<Unit> aiUnits)
		{
			this.unit = unit;
			AIProperties aIProperties = aiPropertiesByUnit[unit];
			healingHP = Mathf.FloorToInt((float)unit.GetHPMax() * unit.aiParameters.healingRatio);
			bool flag = aiUnits.Count == 1 && unit.IsMelee;
			totalThreat = ((!flag) ? ((float)unit.HP * Mathf.Lerp(0.2f, 0.7f, unit.aiParameters.aggression)) : float.MaxValue);
			totalThreat += ((float)unit.HP - totalThreat) * aIProperties.impatience;
			hitChance = (float)CharacterStats.LUT_WeaponBaseAccuracyRanged[unit.ClassID, unit.Level] / Mathf.Lerp(3f, 7f, unit.aiParameters.aggression) * 0.01f;
			killThreatChance = (float)(CharacterStats.LUT_WeaponBaseAccuracyRanged[unit.ClassID, unit.Level] / 2) * 0.01f;
			hitChanceThreat = 0.15f;
		}
	}

	private struct v2iPair
	{
		public v2i v1;

		public v2i v2;
	}

	private class v2iPairComp : IEqualityComparer<v2iPair>
	{
		public bool Equals(v2iPair x, v2iPair y)
		{
			return x.v1 == y.v1 && x.v2 == y.v2;
		}

		public int GetHashCode(v2iPair obj)
		{
			int num = 1;
			num = 31 * num + obj.v1.GetHashCode();
			return 31 * num + obj.v2.GetHashCode();
		}
	}

	private struct ThreatData
	{
		public readonly v2i coord;

		public readonly float totalThreat;

		public readonly float maxThreat;

		public readonly Unit maxThreatUnit;

		public ThreatData(v2i coord, float totalThreat, float maxThreat, Unit maxThreatUnit)
		{
			this.coord = coord;
			this.totalThreat = totalThreat;
			this.maxThreat = maxThreat;
			this.maxThreatUnit = maxThreatUnit;
		}
	}

	private struct RepositionTarget
	{
		public readonly v2i coord;

		public readonly float bestHitChance;

		public readonly Unit bestTarget;

		public readonly float totalThreat;

		public RepositionTarget(v2i coord, float bestHitChance, Unit bestTarget, float totalThreat)
		{
			this.coord = coord;
			this.bestHitChance = bestHitChance;
			this.bestTarget = bestTarget;
			this.totalThreat = totalThreat;
		}
	}

	private class AreaCalculation : IEnumerable<KeyValuePair<v2i, int>>, IEnumerable
	{
		private readonly HagletResettable hr;

		private readonly Area scratchArea = new Area();

		private readonly Dictionary<v2i, int> distByCoord = new Dictionary<v2i, int>();

		private readonly List<v2i> allCoords = new List<v2i>();

		private NC.PathingCellValidator pathValidator;

		private int minRange;

		private bool removeBlockedEPTiles;

		private bool removeUnitCoords;

		public Dictionary<v2i, int> DistByCoord => distByCoord;

		public List<v2i> AllCoords => allCoords;

		public AreaCalculation()
		{
			hr = new HagletResettable(HagletRoutine(), "Area Calculation");
		}

		public HagletYieldTerm Run(Unit unit, int minRange = 0, int maxRange = -1, bool includePathing = true, NC.PathingCellValidator pathValidator = null, bool removeBlockedEPTiles = false, bool removeUnitCoords = true)
		{
			this.minRange = minRange;
			this.pathValidator = pathValidator;
			this.removeBlockedEPTiles = removeBlockedEPTiles;
			this.removeUnitCoords = removeUnitCoords;
			scratchArea.startCoord = unit.coord;
			scratchArea.map = unit.map;
			scratchArea.includePathing = includePathing;
			scratchArea.allowVaults = unit.IsVaultAllowed;
			scratchArea.range = ((maxRange >= 0) ? maxRange : ((!unit.IsMovementDisabled) ? (unit.GetMovementDistancePerTurn() * unit.AP) : 0));
			v2i maxMapSize = Map.maxMapSize;
			int x = maxMapSize.x;
			v2i maxMapSize2 = Map.maxMapSize;
			int a = Mathf.Max(x, maxMapSize2.y);
			scratchArea.range = Mathf.Min(a, scratchArea.range);
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			yield return Wait.While(NC.Inst.CalculateArea(scratchArea, pathValidator));
			distByCoord.Clear();
			allCoords.Clear();
			v2i start = scratchArea.startCoord;
			v2i maxMapSize = Map.maxMapSize;
			int maxX = Mathf.Min(maxMapSize.x - 1, start.x + scratchArea.range);
			v2i maxMapSize2 = Map.maxMapSize;
			int maxY = Mathf.Min(maxMapSize2.y - 1, start.y + scratchArea.range);
			for (int i = Mathf.Max(0, start.x - scratchArea.range); i <= maxX; i++)
			{
				for (int j = Mathf.Max(0, start.y - scratchArea.range); j <= maxY; j++)
				{
					v2i v2i2 = new v2i(i, j);
					int cost = scratchArea.GetCost(v2i2);
					if (cost <= scratchArea.range && cost >= minRange)
					{
						distByCoord.Add(v2i2, cost);
					}
				}
			}
			if (removeUnitCoords)
			{
				ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
				for (int k = 0; k < unitsActive.Length; k++)
				{
					distByCoord.Remove(unitsActive[k].coord);
				}
			}
			if (removeBlockedEPTiles)
			{
				foreach (KeyValuePair<v2i, TileDangerType> dangerousTile in dangerousTiles)
				{
					if ((dangerousTile.Value & TileDangerType.DontStandOn) != 0)
					{
						distByCoord.Remove(dangerousTile.Key);
					}
				}
			}
			foreach (KeyValuePair<v2i, int> item in distByCoord)
			{
				allCoords.Add(item.Key);
			}
		}

		public IEnumerator<KeyValuePair<v2i, int>> GetEnumerator()
		{
			return distByCoord.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return distByCoord.GetEnumerator();
		}
	}

	private class TrapPlacement
	{
		private readonly HagletResettable hr;

		private readonly AIUseAbility abilityRoutine = new AIUseAbility();

		private Unit unit;

		private v2i avoidCoord;

		private Ability_Trap trapAb;

		private AreaCalculation areaCalc;

		public bool PlacedTrap { get; private set; }

		public TrapPlacement()
		{
			hr = new HagletResettable(HagletRoutine(), "Trap Placement");
		}

		public HagletYieldTerm Run(Unit unit, int apReserve, v2i avoidCoord, AreaCalculation areaCalc)
		{
			PlacedTrap = false;
			trapAb = GetAbility<Ability_Trap>(unit);
			if (trapAb != null && unit.AP - trapAb.APCost(unit) >= apReserve && trapAb.GetFreeTrap() != null)
			{
				this.unit = unit;
				this.avoidCoord = avoidCoord;
				this.areaCalc = areaCalc;
				return Routine.Start(hr);
			}
			return Wait.None;
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			yield return areaCalc.Run(unit, 0, trapAb.SelectionRange(unit), includePathing: false);
			float aoeSqr = trapAb.SelectionEffectRange(unit);
			aoeSqr *= aoeSqr;
			v2i? bestCoord = null;
			int bestDistSqr = int.MaxValue;
			Unit bestTarget2 = null;
			foreach (KeyValuePair<v2i, int> item in areaCalc)
			{
				v2i key = item.Key;
				if (!((float)v2i.DistanceSqr(key, avoidCoord) <= aoeSqr))
				{
					int closestDistSqr;
					Unit closestUnit = GetClosestUnit(key, UnitTeam.Type.Player, out closestDistSqr);
					if (!(closestUnit == null) && !((float)closestDistSqr <= aoeSqr) && closestDistSqr < bestDistSqr)
					{
						bestDistSqr = closestDistSqr;
						bestCoord = key;
						bestTarget2 = closestUnit;
					}
				}
			}
			if (bestCoord.HasValue)
			{
				yield return abilityRoutine.Run(trapAb, unit, bestCoord.Value, new UIAbilityWheelChoice
				{
					subAbilityIdx = (int)unit.aiParameters.grenadeOrTrapType
				});
				PlacedTrap = true;
			}
		}
	}

	private class FlurryEval
	{
		private readonly HagletResettable hr;

		private readonly AIUseAbility abilityRoutine = new AIUseAbility();

		private Unit unit;

		private ConstArray<Unit> unitRadiusCA = new ConstArray<Unit>(8u);

		private Ability_Flurry flurryAb;

		public bool UsedAbility { get; private set; }

		public FlurryEval()
		{
			hr = new HagletResettable(HagletRoutine(), "Flurry Evaluation");
		}

		public HagletYieldTerm Run(Unit unit, int apReserve)
		{
			UsedAbility = false;
			flurryAb = GetAbility<Ability_Flurry>(unit);
			if (flurryAb != null && unit.AP - apReserve >= flurryAb.APCost(unit))
			{
				this.unit = unit;
				return Routine.Start(hr);
			}
			return Wait.None;
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			unitRadiusCA.Clear();
			Unit.GatherUnitsInRadius(unit.coord, flurryAb.EffectiveRadius, unitRadiusCA, UnitTeam.Type.Player.ToMask());
			RemoveInvalidTargets(unitRadiusCA);
			if (unitRadiusCA.Length > 1)
			{
				yield return abilityRoutine.Run(flurryAb, unit);
				UsedAbility = true;
			}
		}
	}

	private class GroundPoundEval
	{
		private readonly HagletResettable hr;

		private readonly AIUseAbility abilityRoutine = new AIUseAbility();

		private readonly List<v2i> validNavCoords = new List<v2i>();

		private readonly ConstArray<Unit> areaTargetsCA = new ConstArray<Unit>(8u);

		private Unit unit;

		private Ability_Ground_Pound ability;

		private uint minTargets;

		public bool UsedAbility { get; private set; }

		public GroundPoundEval()
		{
			hr = new HagletResettable(HagletRoutine(), "Ground Pound Evaluation");
		}

		public HagletYieldTerm Run(Unit unit, uint minTargets = 2u)
		{
			UsedAbility = false;
			ability = GetAbility<Ability_Ground_Pound>(unit);
			if (ability != null)
			{
				this.unit = unit;
				this.minTargets = minTargets;
				return Routine.Start(hr);
			}
			return Wait.None;
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			v2i coord = v2i.zero;
			v2i mapSize = unit.map.size;
			validNavCoords.Clear();
			for (int i = 0; i < mapSize.x; i++)
			{
				coord.x = i;
				for (int j = 0; j < mapSize.y; j++)
				{
					coord.y = j;
					if (!unit.map.GetCoordBlocked(coord))
					{
						validNavCoords.Add(coord);
					}
				}
			}
			v2i bestCoord = v2i.zero;
			uint bestUnitCount = 0u;
			for (int k = 0; k < validNavCoords.Count; k++)
			{
				coord = validNavCoords[k];
				Unit.GatherUnitsInRadius(coord, ability.SelectionEffectRange(unit), areaTargetsCA, UnitTeam.Type.Player.ToMask());
				RemoveInvalidTargets(areaTargetsCA);
				uint length = areaTargetsCA.Length;
				if (length > bestUnitCount)
				{
					bestUnitCount = length;
					bestCoord = coord;
				}
			}
			if (bestUnitCount >= minTargets && ability.ValidateTileSelection(unit, bestCoord))
			{
				yield return abilityRoutine.Run(ability, unit, bestCoord);
				UsedAbility = true;
			}
		}
	}

	private class AIAttackRoutine
	{
		private readonly HagletResettable hr;

		private readonly AIUseAbility abilityRoutine = new AIUseAbility();

		private IEnumerable<Unit> friendlyUnits;

		private Unit attacker;

		private Unit target;

		public AIAttackRoutine()
		{
			hr = new HagletResettable(HagletRoutine(), "AIAttackRoutine");
		}

		public HagletYieldTerm Run(Unit attacker, Unit target, IEnumerable<Unit> friendlyUnits)
		{
			this.attacker = attacker;
			this.target = target;
			this.friendlyUnits = friendlyUnits;
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			Ability_Focus abilityFocus = GetAbility<Ability_Focus>(attacker);
			if (abilityFocus != null && attacker.AP > abilityFocus.APCost(attacker) && abilityFocus.ValidateUnitSelection(attacker, target))
			{
				yield return abilityRoutine.Run(abilityFocus, attacker);
				if ((bool)GC.Inst.flagEndTurnMode)
				{
					yield break;
				}
			}
			foreach (Unit unit in friendlyUnits)
			{
				Ability_Upgrade abilityUpgrade = GetAbility<Ability_Upgrade>(unit);
				if (abilityUpgrade != null && !abilityUpgrade.IsUpgraded && unit.AP > 1 && ValidateUnitSelection(abilityUpgrade, unit, attacker))
				{
					yield return abilityRoutine.Run(abilityUpgrade, unit, attacker);
					if ((bool)GC.Inst.flagEndTurnMode)
					{
						yield break;
					}
				}
			}
			Ability_Spray_And_Pray abilityRapidFire = GetAbility<Ability_Spray_And_Pray>(attacker);
			AIProperties aiProps = aiPropertiesByUnit[attacker];
			if (abilityRapidFire != null && ValidateUnitSelection(abilityRapidFire, attacker, target))
			{
				aiProps.impatience = Mathf.Clamp01(aiProps.impatience -= attacker.aiParameters.impatience);
				yield return abilityRoutine.Run(abilityRapidFire, attacker, target);
				yield break;
			}
			Ability_Grab abilityGrab = GetAbility<Ability_Grab>(attacker);
			if (abilityGrab != null && attacker.AP == 1 && ValidateUnitSelection(abilityGrab, attacker, target))
			{
				yield return abilityRoutine.Run(abilityGrab, attacker, target);
				yield break;
			}
			attacker.GetTeam()._SetTeamLeader(attacker);
			aiProps.impatience = Mathf.Clamp01(aiProps.impatience -= attacker.aiParameters.impatience);
			attacker.StartAttack(target, attacker.mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.DodgeWhamBar);
			yield return Wait.ForChildren;
		}
	}

	private class AIMovementRoutine
	{
		private readonly HagletResettable hr;

		private readonly AreaCalculation areaCalc = new AreaCalculation();

		private readonly List<ThreatData>[] coordThreatByAP = new List<ThreatData>[4]
		{
			new List<ThreatData>(),
			new List<ThreatData>(),
			new List<ThreatData>(),
			new List<ThreatData>()
		};

		private Unit unit;

		public AIMovementRoutine()
		{
			hr = new HagletResettable(MovementRoutine(), "AIMovementRoutine");
		}

		public HagletYieldTerm Run(Unit unit)
		{
			this.unit = unit;
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> MovementRoutine()
		{
			AreaCalculation areaCalculation = areaCalc;
			Unit unit = this.unit;
			NC.PathingCellValidator pathCellValidator = Singleton<AIC>.Inst.pathCellValidator;
			yield return areaCalculation.Run(unit, 0, -1, includePathing: true, pathCellValidator, removeBlockedEPTiles: true);
			UnitThresholds thresholds = thresholdsByUnit[this.unit];
			for (int ap = 1; ap <= this.unit.AP; ap++)
			{
				List<ThreatData> threatList = coordThreatByAP[ap - 1];
				threatList.Clear();
				foreach (KeyValuePair<v2i, int> item in areaCalc)
				{
					v2i key = item.Key;
					int num = DistToAp(item.Value, this.unit.GetMovementDistancePerTurn());
					if (!(key == this.unit.coord) && num <= ap)
					{
						threatList.Add(Singleton<AIC>.Inst.GetThreatForUnitAtCoord(this.unit, key));
					}
				}
				threatList.Sort(totalThreatComp);
				for (int i = 0; i < threatList.Count; i++)
				{
					ThreatData t = threatList[i];
					if (t.totalThreat >= thresholds.totalThreat)
					{
						break;
					}
					float bestHitChance;
					Unit bestTarget = Singleton<AIC>.Inst.GetBestHitChance(this.unit, t.coord, out bestHitChance);
					if (!(bestHitChance < thresholds.hitChance))
					{
						yield return Singleton<AIC>.Inst.trapPlacement.Run(this.unit, ap, t.coord, areaCalc);
						if (!Singleton<AIC>.Inst.trapPlacement.PlacedTrap || !GC.Inst.flagEndTurnMode)
						{
							yield return Singleton<AIC>.Inst.StartMovement(this.unit, t.coord, ap);
						}
						yield break;
					}
				}
			}
		}
	}

	private class AIUseAbility
	{
		private enum SelectionType
		{
			None,
			Unit,
			Coord
		}

		private readonly HagletResettable hr;

		private readonly ConstArray<Unit> unitSel = new ConstArray<Unit>(3u);

		private readonly ConstArray<v2i> coordSel = new ConstArray<v2i>(1u);

		private SelectionType type;

		private Unit unit;

		private AbilityImplBase ability;

		private UIAbilityWheelChoice choice;

		public AIUseAbility()
		{
			hr = new HagletResettable(AbilityRoutine(), "AIAbilityRoutine");
		}

		public HagletYieldTerm Run(AbilityImplBase ability, Unit unit, UIAbilityWheelChoice choice = default(UIAbilityWheelChoice))
		{
			this.ability = ability;
			this.unit = unit;
			this.choice = choice;
			type = SelectionType.None;
			return Routine.Start(hr);
		}

		public HagletYieldTerm Run(AbilityImplBase ability, Unit unit, Unit selected, UIAbilityWheelChoice choice = default(UIAbilityWheelChoice))
		{
			this.ability = ability;
			this.unit = unit;
			this.choice = choice;
			unitSel.Add(selected);
			type = SelectionType.Unit;
			return Routine.Start(hr);
		}

		public HagletYieldTerm Run(AbilityImplBase ability, Unit unit, v2i selected, UIAbilityWheelChoice choice = default(UIAbilityWheelChoice))
		{
			this.ability = ability;
			this.unit = unit;
			this.choice = choice;
			coordSel.Add(selected);
			type = SelectionType.Coord;
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> AbilityRoutine()
		{
			yield return null;
			unit.GetTeam()._SetTeamLeader(unit);
			try
			{
				switch (type)
				{
				case SelectionType.None:
					ability.OnActivateImmediatelyBase(unit, choice);
					break;
				case SelectionType.Unit:
					if (ability.SelectionAllowStepOut(unit))
					{
						v2i steppedOutCoord;
						yield return unit.TryStepOut(unit.coord, unitSel[0].coord, out steppedOutCoord);
					}
					ability.OnActivateWithUnitsSelectedBase(unit, unitSel, choice);
					yield return Wait.ForChildren;
					if (unit.IsSteppedOut)
					{
						unit.StartStepBackIn();
						yield return Wait.ForChildren;
					}
					break;
				case SelectionType.Coord:
					ability.OnActivateWithTilesSelectedBase(unit, coordSel, choice);
					break;
				}
			}
			finally
			{
				unitSel.ClearToDefault();
				coordSel.ClearToDefault();
			}
			yield return Wait.ForChildren;
		}
	}

	private class PathCalculation
	{
		private readonly HagletResettable hr;

		private readonly NC.PathRequestComplete prc;

		private Unit unit;

		private v2i start;

		private v2i end;

		public NC.Path path { get; private set; }

		public PathCalculation()
		{
			hr = new HagletResettable(HagletRoutine(), "AIAttackRoutine");
			prc = OnPathCalculationComplete;
		}

		public HagletYieldTerm Run(Unit unit, v2i start, v2i end)
		{
			this.unit = unit;
			this.start = start;
			this.end = end;
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			yield return Wait.While(NC.Inst.CalculatePath(unit, start, end, includeObservedTiles: false, prc, unit.IsVaultAllowed));
		}

		private void OnPathCalculationComplete(NC.Path path, Unit unitAssociated)
		{
			this.path = path;
		}
	}

	[Flags]
	private enum TileDangerType
	{
		None = 0,
		AIGrenade = 1,
		PlayerGrenade = 2,
		AITrap = 4,
		PlayerTrap = 8,
		AIGroundPound = 0x10,
		DontStandOn = 0x1F,
		DontWalkOn = 4
	}

	private static readonly Dictionary<v2i, TileDangerType> dangerousTiles = new Dictionary<v2i, TileDangerType>();

	private static readonly Dictionary<Unit, UnitThresholds> thresholdsByUnit = new Dictionary<Unit, UnitThresholds>();

	private static readonly Dictionary<Unit, AIProperties> aiPropertiesByUnit = new Dictionary<Unit, AIProperties>();

	private static readonly ConstArray<Unit> singleUnitCA = new ConstArray<Unit>(1u);

	private static readonly ConstArray<v2i> singleCoordCA = new ConstArray<v2i>(1u);

	private static int aiDetectCooldown = 1;

	private static readonly Comparison<ThreatData> totalThreatComp = (ThreatData t1, ThreatData t2) => t1.totalThreat.CompareTo(t2.totalThreat);

	private static readonly Comparison<RepositionTarget> hitChanceComp = (RepositionTarget h1, RepositionTarget h2) => h1.bestHitChance.CompareTo(h2.bestHitChance);

	private static readonly Comparison<Unit> hpComp = delegate(Unit u1, Unit u2)
	{
		float num = (float)u1.HP / (float)thresholdsByUnit[u1].healingHP;
		float value = (float)u2.HP / (float)thresholdsByUnit[u2].healingHP;
		return num.CompareTo(value);
	};

	private static readonly Func<Unit, bool> notSuppressed = (Unit unit) => GetProxyAbility<Ability_Covering_Fire_Proxy>(unit) == null;

	private static Func<AbilityImplBase, bool> onlyProxyAbilities = (AbilityImplBase ability) => ability.IsProxyAbility();

	private static Func<AbilityImplBase, bool> onlyNonProxyAbilities = (AbilityImplBase ability) => !ability.IsProxyAbility();

	private Comparison<Unit> unitTheatComp;

	private UnitTeam.Type activeTeamType = UnitTeam.Type.Enemy;

	[NonSerialized]
	[HideInInspector]
	public readonly HagletTrigger OnExternalAIComplete = new HagletTrigger();

	[NonSerialized]
	[ReadOnly]
	public HagletTrigger OnExternalAIBegan;

	[NonSerialized]
	[ReadOnly]
	public bool AwaitingExternalInstructions;

	private HagletResettable turnControl;

	private readonly AreaCalculation[] areaCalc = CollectionsX.Generate<AreaCalculation>(5);

	private readonly TrapPlacement trapPlacement = new TrapPlacement();

	private readonly FlurryEval flurryEval = new FlurryEval();

	private readonly GroundPoundEval groundPoundEval = new GroundPoundEval();

	private readonly AIAttackRoutine aiAttackRoutine = new AIAttackRoutine();

	private readonly AIMovementRoutine aiMovementRoutine = new AIMovementRoutine();

	private readonly PathCalculation pathCalculation = new PathCalculation();

	private readonly AIUseAbility abilityRoutine = new AIUseAbility();

	private const int unitListInitialSize = 16;

	private readonly List<Unit> playerUnits = new List<Unit>(16);

	private readonly List<Unit> visiblePlayerUnits = new List<Unit>(16);

	private readonly List<Unit> cloakedPlayerUnits = new List<Unit>(16);

	private readonly List<Unit> aiUnits = new List<Unit>(16);

	private readonly List<Unit> unitsByHP = new List<Unit>(16);

	private readonly List<v2i> coordDistanceList = new List<v2i>();

	private readonly AbilityImplBase[] abilityTempArray = new AbilityImplBase[3];

	private ConstArray<Unit> areaTargetsCA = new ConstArray<Unit>(8u);

	private Dictionary<Unit, ThreatData> curThreatByUnit = new Dictionary<Unit, ThreatData>(16);

	private List<Unit> unitsByTotalThreat = new List<Unit>(16);

	private NC.PathingCellValidator pathCellValidator;

	private readonly List<ThreatData>[] coordThreatByAP = new List<ThreatData>[4]
	{
		new List<ThreatData>(),
		new List<ThreatData>(),
		new List<ThreatData>(),
		new List<ThreatData>()
	};

	private readonly List<RepositionTarget>[] coordHitByAP = new List<RepositionTarget>[4]
	{
		new List<RepositionTarget>(),
		new List<RepositionTarget>(),
		new List<RepositionTarget>(),
		new List<RepositionTarget>()
	};

	public AbilityImplBase activeAbility => null;

	private static float GetDodgeHitMult(float percentDodge)
	{
		return 1f - percentDodge * 0.75f;
	}

	private static float GetHitChance(Unit att, v2i attCoord, Unit def, v2i defCoord)
	{
		AttackData ad;
		return GetHitChance(att, attCoord, def, defCoord, out ad);
	}

	private static float GetHitChance(Unit a, v2i aCoord, Unit d, v2i dCoord, out AttackData ad)
	{
		if (a.IsMelee && !v2i.IsNeighbour(aCoord, dCoord))
		{
			ad = default(AttackData);
			return 0f;
		}
		float num = (float)a.GetHitChance(aCoord, d, dCoord, a.mainWeapon, reactionAttack: false, isCombatCalculation: false, out ad) * 0.01f;
		if (d.teamType == UnitTeam.Type.Enemy)
		{
			num *= GetDodgeHitMult((float)d.GetDodgeChance(a) * 0.01f);
		}
		return num;
	}

	private static float GetHitChance(Unit a, v2i aCoord, Unit d, v2i dCoord, AttackData ad)
	{
		if (a.IsMelee && !v2i.IsNeighbour(aCoord, dCoord))
		{
			return 0f;
		}
		return (float)a.GetHitChance(aCoord, d, dCoord, a.mainWeapon, reactionAttack: false, isCombatCalculation: false, ad) * 0.01f;
	}

	private static int DistToAp(int distance, int movement)
	{
		return distance / movement + ((distance % movement > 0) ? 1 : 0);
	}

	private static int ApToTurn(int ap, int apPerTurn)
	{
		return ap / apPerTurn + ((ap % apPerTurn > 0) ? 1 : 0);
	}

	private static int DistToTurn(int distance, int movement, int apPerTurn)
	{
		return ApToTurn(DistToAp(distance, movement), apPerTurn);
	}

	private static T GetProxyAbility<T>(Unit unit) where T : AbilityImplBase
	{
		if (unit == null)
		{
			return (T)null;
		}
		return unit.abilities.AbilityGetByType<T>(unit, onlyProxyAbilities);
	}

	private static T GetAbility<T>(Unit unit) where T : AbilityImplBase
	{
		if (unit == null)
		{
			return (T)null;
		}
		T val = unit.abilities.AbilityGetByType<T>(unit, onlyNonProxyAbilities);
		if (val == null)
		{
			return (T)null;
		}
		if (!val.Enabled || val.HasCooldownRemaining || val.APCost(unit) > unit.AP)
		{
			return (T)null;
		}
		return (val is IHasAIInventory { AIInventory: <=0 }) ? ((T)null) : val;
	}

	private static Unit GetClosestUnit(v2i coord, UnitTeam.Type teamType, out int closestDistSqr)
	{
		ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType(teamType).GetActiveMembers();
		Unit result = null;
		closestDistSqr = int.MaxValue;
		for (int i = 0; i < activeMembers.Length; i++)
		{
			int num = v2i.DistanceSqr(activeMembers[i].coord, coord);
			if (num < closestDistSqr)
			{
				closestDistSqr = num;
				result = activeMembers[i];
			}
		}
		return result;
	}

	private static float GetBackupThreatMod(bool isUpgraded)
	{
		float num = GetDodgeHitMult(30f);
		if (isUpgraded)
		{
			num *= 0.9f;
		}
		return num;
	}

	private static bool ValidateUnitSelection(AbilityImplBase ability, Unit unit, Unit selection)
	{
		return ability.ValidateUnitSelection(unit, selection) && (unit.teamType == selection.teamType || !selection.IsCloaked) && (!ability.SelectionRequireLineOfSight(unit) || unit.map.HasLineOfSight(unit.coord, selection.coord, ability.SelectionAllowStepOut(unit))) && selection.IsTargetable;
	}

	private int UnitThreatComp(Unit u1, Unit u2)
	{
		return curThreatByUnit[u2].totalThreat.CompareTo(curThreatByUnit[u1].totalThreat);
	}

	protected override void Awake()
	{
		base.Awake();
		pathCellValidator = AIPathValidator;
		unitTheatComp = UnitThreatComp;
		turnControl = new HagletResettable(TurnControlRoutine(), "Turn Control");
	}

	public void OnTeamInitialize(UnitTeam team)
	{
	}

	private HagletYieldTerm StartMovement(Unit unit, v2i coord, int apCost)
	{
		unit.GetTeam()._SetTeamLeader(unit);
		v2i? destCoord = coord;
		NC.PathingCellValidator pathingCellValidator = pathCellValidator;
		unit.StartMovement(destCoord, null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: false, avoidUnits: false, shouldReserveTile: true, forceWalk: false, ignoreTileTriggers: false, pathingCellValidator);
		unit.APDecrement(apCost);
		return Wait.ForChildren;
	}

	private float GetTargetChance(Unit d, v2i dCoord, Unit a, v2i aCoord, float hitChance)
	{
		List<Unit> list = ((d.teamType != activeTeamType) ? visiblePlayerUnits : aiUnits);
		float num = hitChance;
		foreach (Unit item in list)
		{
			if (!(d == item))
			{
				num += GetHitChance(a, aCoord, item, item.coord);
			}
		}
		float num2 = num / (float)list.Count;
		float num3 = 1f / (float)list.Count;
		return num3 * (hitChance / num2);
	}

	private float GetThreatForUnitAtCoordFromUnit(Unit unit, v2i coord, Unit attacker, v2i attackerCoord)
	{
		if (attacker.IsCloaked || attacker.IsAttackingDisabled)
		{
			return 0f;
		}
		Ability_Taunt_Proxy proxyAbility = GetProxyAbility<Ability_Taunt_Proxy>(attacker);
		if (proxyAbility != null && proxyAbility.target != unit)
		{
			return 0f;
		}
		UnitThresholds unitThresholds = thresholdsByUnit[unit];
		AttackData ad;
		float hitChance = GetHitChance(attacker, attackerCoord, unit, coord, out ad);
		if (hitChance <= unitThresholds.hitChanceThreat)
		{
			return 0f;
		}
		int num = Mathf.Min(attacker.GetDamageValue(isCriticalHit: false, unit, attacker.mainWeapon, isCombatCalculation: false), unit.HP);
		float targetChance = GetTargetChance(unit, coord, attacker, attackerCoord, hitChance);
		float num2 = targetChance * hitChance * (float)num * (float)attacker.GetAPMax();
		if (!unit.IsMelee && (ad.coverType == CoverType.Flanked || ad.coverType == CoverType.None))
		{
			num2 *= 1.5f;
		}
		return num2;
	}

	private ThreatData GetThreatForUnitAtCoord(Unit unit, v2i coord)
	{
		float num = 0f;
		float num2 = 0f;
		Unit maxThreatUnit = null;
		foreach (Unit visiblePlayerUnit in visiblePlayerUnits)
		{
			float threatForUnitAtCoordFromUnit = GetThreatForUnitAtCoordFromUnit(unit, coord, visiblePlayerUnit, visiblePlayerUnit.coord);
			if (threatForUnitAtCoordFromUnit > num2)
			{
				num2 = threatForUnitAtCoordFromUnit;
				maxThreatUnit = visiblePlayerUnit;
			}
			num += threatForUnitAtCoordFromUnit;
		}
		return new ThreatData(coord, num, num2, maxThreatUnit);
	}

	private float GetTeamThreatForUnit(Unit pUnit)
	{
		return GetTeamThreatForUnit(pUnit, pUnit.coord);
	}

	private float GetTeamThreatForUnit(Unit pUnit, v2i pCoord)
	{
		float num = 0f;
		foreach (Unit aiUnit in aiUnits)
		{
			num += GetThreatForUnitAtCoordFromUnit(aiUnit, aiUnit.coord, pUnit, pCoord);
		}
		return num;
	}

	private Unit GetBiggestTeamThreatForUnits(Unit inLOSof = null, Func<Unit, bool> predicate = null)
	{
		float num = 0f;
		Unit result = null;
		foreach (Unit visiblePlayerUnit in visiblePlayerUnits)
		{
			if ((!(inLOSof != null) || inLOSof.map.HasLineOfSight(inLOSof.coord, visiblePlayerUnit.coord, isSideStepAllowed: true)) && (predicate == null || predicate(visiblePlayerUnit)))
			{
				float teamThreatForUnit = GetTeamThreatForUnit(visiblePlayerUnit);
				if (teamThreatForUnit > num)
				{
					num = teamThreatForUnit;
					result = visiblePlayerUnit;
				}
			}
		}
		return result;
	}

	private void CalculateCoordsInRadius(v2i startCoord, int radius)
	{
		coordDistanceList.Clear();
		v2i maxMapSize = Map.maxMapSize;
		int num = Mathf.Min(maxMapSize.x, startCoord.x + radius);
		v2i maxMapSize2 = Map.maxMapSize;
		int num2 = Mathf.Min(maxMapSize2.y, startCoord.y + radius);
		for (int i = Mathf.Max(0, startCoord.x - radius); i <= num; i++)
		{
			for (int j = Mathf.Max(0, startCoord.y - radius); j <= num2; j++)
			{
				v2i v2i2 = new v2i(i, j);
				if (v2i.Distance(startCoord, v2i2) <= (float)radius)
				{
					coordDistanceList.Add(v2i2);
				}
			}
		}
	}

	private static void RemoveInvalidTargets(ConstArray<Unit> units, bool filterCloaked = true, Unit requiresLOS = null, bool directLOS = false)
	{
		for (uint num = 0u; num < units.Length; num++)
		{
			Unit unit = units[num];
			if ((filterCloaked && unit.IsCloaked) || (requiresLOS != null && !requiresLOS.map.HasLineOfSight(requiresLOS.coord, unit.coord, !directLOS)))
			{
				units.RemoveAtIndex(num);
				num--;
			}
		}
	}

	private bool AIPathValidator(v2i coord)
	{
		if ((GetTileDanger(coord) & TileDangerType.AITrap) != 0)
		{
			return false;
		}
		return true;
	}

	private TileDangerType GetTileDanger(v2i coord)
	{
		TileDangerType value;
		return dangerousTiles.TryGetValue(coord, out value) ? value : TileDangerType.None;
	}

	private TileDangerType AddTileDanger(v2i coord, TileDangerType dangerType)
	{
		TileDangerType value = ((!dangerousTiles.TryGetValue(coord, out value)) ? dangerType : (value | dangerType));
		dangerousTiles[coord] = value;
		return value;
	}

	private bool SafeToStandOn(v2i coord)
	{
		return (GetTileDanger(coord) & TileDangerType.DontStandOn) == 0;
	}

	private void DangerousTilesByUnit(Unit unit)
	{
		Ability_Ground_Pound ability_Ground_Pound = unit.abilities.AbilityGetByType<Ability_Ground_Pound>(unit);
		if (ability_Ground_Pound != null && ability_Ground_Pound.IsJumping)
		{
			float num = ability_Ground_Pound.SelectionEffectRange(unit);
			CalculateCoordsInRadius(ability_Ground_Pound.GroundPoundTarget, (int)num);
			for (int i = 0; i < coordDistanceList.Count; i++)
			{
				AddTileDanger(coordDistanceList[i], TileDangerType.AIGroundPound);
			}
		}
	}

	private void GrenadeDangerForTeam(UnitTeam.Type teamType)
	{
		IEnumerable<AbilityImplBase> enumerable = GC.Inst.GetTeamOfType(teamType).abilities.OnTeam();
		TileDangerType dangerType = ((teamType == UnitTeam.Type.Enemy) ? TileDangerType.AIGrenade : TileDangerType.PlayerGrenade);
		foreach (AbilityImplBase item in enumerable)
		{
			if (!(item is Ability_Grenade ability_Grenade))
			{
				continue;
			}
			float num = ability_Grenade.SelectionEffectRange(ability_Grenade.owner);
			for (int i = 0; i < ability_Grenade.Grenades.Length; i++)
			{
				CalculateCoordsInRadius(ability_Grenade.Grenades[i].target, (int)num);
				for (int j = 0; j < coordDistanceList.Count; j++)
				{
					AddTileDanger(coordDistanceList[j], dangerType);
				}
			}
		}
	}

	private int CountValidDisruptAbilities(Unit unit)
	{
		int num = 0;
		uint num2 = unit.abilities.AbilityGetCount();
		for (int i = 0; i < num2; i++)
		{
			AbilityImplBase abilityImplBase = unit.abilities.AbilityGetByIndex(i);
			if (abilityImplBase.IsManuallyActivated() && !abilityImplBase.IsProxyAbility() && abilityImplBase.Enabled)
			{
				num++;
			}
		}
		return num;
	}

	private Unit FindBestHCUnit(bool findSafest = false)
	{
		Unit result = null;
		float num = ((!findSafest) ? 0f : float.MaxValue);
		foreach (Unit visiblePlayerUnit in visiblePlayerUnits)
		{
			float num2 = 0f;
			foreach (Unit aiUnit in aiUnits)
			{
				float hitChance = GetHitChance(aiUnit, aiUnit.coord, visiblePlayerUnit, visiblePlayerUnit.coord);
				num2 += hitChance;
			}
			if (findSafest && num2 < num)
			{
				num = num2;
				result = visiblePlayerUnit;
			}
			else if (!findSafest && num2 > num)
			{
				num = num2;
				result = visiblePlayerUnit;
			}
		}
		return result;
	}

	private int GetNumPotentialAttackers(Unit pUnit, v2i pCoord)
	{
		int num = 0;
		foreach (Unit aiUnit in aiUnits)
		{
			float hitChance = GetHitChance(aiUnit, aiUnit.coord, pUnit, pCoord);
			if (hitChance > thresholdsByUnit[aiUnit].hitChance)
			{
				num++;
			}
		}
		return num;
	}

	private float ChanceOfDealingDamage(Unit att, v2i attCoord, WeaponAttributes attWeapon, Unit def, v2i defCoord, int minDamage = 1, Ability_Headshot abilityHeadshot = null)
	{
		AttackData ad;
		float hitChance = GetHitChance(att, attCoord, def, defCoord, out ad);
		float num = (float)att.GetCriticalHitChance(attCoord, def, defCoord, attWeapon, ad, isCombatCalculation: false) * 0.01f;
		float num2 = (float)att.GetCriticalHitSize(def, attWeapon, isCombatCalculation: false) * 0.01f;
		if (hitChance == 0f)
		{
			return 0f;
		}
		if (abilityHeadshot == null)
		{
			int damageValue = att.GetDamageValue(isCriticalHit: false, att, attWeapon, isCombatCalculation: false);
			if (damageValue >= minDamage)
			{
				return hitChance;
			}
		}
		int damageValue2 = att.GetDamageValue(isCriticalHit: true, att, attWeapon, isCombatCalculation: false);
		if (damageValue2 >= minDamage)
		{
			if (abilityHeadshot == null)
			{
				return hitChance * num * num2;
			}
			return (!abilityHeadshot.IsUpgraded) ? (hitChance * num2) : hitChance;
		}
		return 0f;
	}

	private Unit GetBestHitChance(Unit attacker, v2i coord, out float bestHitChance)
	{
		Unit result = null;
		bestHitChance = 0f;
		foreach (Unit visiblePlayerUnit in visiblePlayerUnits)
		{
			if (visiblePlayerUnit.IsTargetable)
			{
				float hitChance = GetHitChance(attacker, coord, visiblePlayerUnit, visiblePlayerUnit.coord);
				if (hitChance > bestHitChance)
				{
					result = visiblePlayerUnit;
					bestHitChance = hitChance;
				}
			}
		}
		return result;
	}

	private Unit GetClosestUnitWithAbility<T>(v2i coord, ConstArray<Unit> units, out int closestDistSqr) where T : AbilityImplBase
	{
		Unit result = null;
		closestDistSqr = int.MaxValue;
		for (int i = 0; i < units.Length; i++)
		{
			if (GetAbility<T>(units[i]) != null)
			{
				int num = v2i.DistanceSqr(units[i].coord, coord);
				if (num < closestDistSqr)
				{
					closestDistSqr = num;
					result = units[i];
				}
			}
		}
		return result;
	}

	private Unit ChooseHighest(Unit self, Unit other, float selfVal, float otherVal)
	{
		float num = 0f - (self.aiParameters.selfishness - 0.5f) * 2f;
		selfVal += selfVal * num;
		return (!(otherVal > selfVal)) ? self : other;
	}

	private bool AbilityIncorporeal(Unit unit)
	{
		Ability_Incorporeal ability = GetAbility<Ability_Incorporeal>(unit);
		if (ability != null)
		{
			abilityRoutine.Run(ability, unit);
			return true;
		}
		return false;
	}

	private IEnumerator<HagletYieldTerm> TurnControlRoutine()
	{
		activeTeamType = GC.Inst.GetActiveTeamType();
		if (activeTeamType != UnitTeam.Type.Enemy)
		{
			yield break;
		}
		UnitTeam thisTeam = GetTeam();
		ConstArray<Unit> aiUnitsCA = thisTeam.GetActiveMembers();
		ConstArray<Unit> playerUnitsCA = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
		playerUnits.Clear();
		visiblePlayerUnits.Clear();
		cloakedPlayerUnits.Clear();
		aiUnits.Clear();
		for (int l = 0; l < playerUnitsCA.Length; l++)
		{
			Unit unit11 = playerUnitsCA[l];
			if (!unit11.charData.environmental)
			{
				playerUnits.Add(unit11);
				((!unit11.IsCloaked) ? visiblePlayerUnits : cloakedPlayerUnits).Add(unit11);
			}
		}
		for (int m = 0; m < aiUnitsCA.Length; m++)
		{
			Unit unit12 = aiUnitsCA[m];
			if (!unit12.charData.environmental)
			{
				aiUnits.Add(unit12);
			}
		}
		yield return null;
		yield return Wait.While(GC.Inst.InCutsceneMode);
		if ((bool)GC.Inst.flagEndTurnMode)
		{
			yield break;
		}
		bool waitForPopups = true;
		while (waitForPopups)
		{
			waitForPopups = false;
			ConstArray<Unit> units = GC.Inst.GetUnitsAllInWorld();
			for (int n = 0; n < units.Length; n++)
			{
				Unit unit13 = units[n];
				if (unit13.IsAlive() && unit13.popupBar.IsAnimating())
				{
					waitForPopups = true;
					break;
				}
			}
			yield return null;
		}
		if (OnExternalAIBegan != null)
		{
			OnExternalAIBegan.Trigger();
			AwaitingExternalInstructions = true;
			yield return OnExternalAIComplete;
			AwaitingExternalInstructions = false;
			yield break;
		}
		foreach (Unit unit in aiUnits)
		{
			yield return null;
			if (!aiPropertiesByUnit.ContainsKey(unit))
			{
				aiPropertiesByUnit.Add(unit, new AIProperties());
			}
			thresholdsByUnit[unit] = new UnitThresholds(unit, aiUnits);
			if (unit.decoyUnit != null)
			{
				if (!aiPropertiesByUnit.ContainsKey(unit.decoyUnit))
				{
					aiPropertiesByUnit.Add(unit.decoyUnit, new AIProperties());
				}
				thresholdsByUnit[unit.decoyUnit] = new UnitThresholds(unit.decoyUnit, aiUnits);
			}
		}
		unitsByHP.AddRange(aiUnits);
		unitsByHP.Sort(hpComp);
		foreach (Unit unit2 in aiUnits)
		{
			yield return null;
			Ability_Restore aRestore = GetAbility<Ability_Restore>(unit2);
			if (aRestore == null)
			{
				continue;
			}
			UnitThresholds thresholds = thresholdsByUnit[unit2];
			bool unitInjured = unit2.HP <= thresholds.healingHP;
			for (int k = 0; k < unitsByHP.Count; k++)
			{
				Unit otherUnit = unitsByHP[k];
				if (unit2 == otherUnit)
				{
					continue;
				}
				UnitThresholds otherUnitThreshold = thresholdsByUnit[otherUnit];
				if (otherUnit.HP > otherUnitThreshold.healingHP)
				{
					break;
				}
				if (unitInjured)
				{
					Unit unit14 = ChooseHighest(unit2, otherUnit, (float)unit2.HP / (float)thresholds.healingHP, (float)otherUnit.HP / (float)otherUnitThreshold.healingHP);
					if (unit14 == otherUnit)
					{
						break;
					}
				}
				if (ValidateUnitSelection(aRestore, unit2, otherUnit))
				{
					yield return abilityRoutine.Run(aRestore, unit2, otherUnit);
					yield break;
				}
			}
			if (!unitInjured || !ValidateUnitSelection(aRestore, unit2, unit2))
			{
				continue;
			}
			yield return abilityRoutine.Run(aRestore, unit2, unit2);
			yield break;
		}
		foreach (Unit unit3 in aiUnits)
		{
			yield return null;
			UnitThresholds thresholds2 = thresholdsByUnit[unit3];
			if (unit3.HP <= thresholds2.healingHP)
			{
				Ability_Combat_Medic_Small medkit = GetAbility<Ability_Combat_Medic_Small>(unit3);
				if (medkit != null && ValidateUnitSelection(medkit, unit3, unit3))
				{
					yield return abilityRoutine.Run(medkit, unit3, unit3);
					yield break;
				}
			}
		}
		foreach (Unit unit4 in aiUnits)
		{
			yield return null;
			if (aiDetectCooldown > 0)
			{
				continue;
			}
			Ability_Detect abilityDetect = GetAbility<Ability_Detect>(unit4);
			if (abilityDetect == null)
			{
				continue;
			}
			int hiddenPlayerTraps = 0;
			Map curMap = Singleton<MC>.Inst.GetActiveMap();
			ConstArray<TileTrapTrigger> allTraps = curMap.trapTiles;
			for (int num = 0; num < allTraps.Length; num++)
			{
				TileTrapTrigger tileTrapTrigger = allTraps[num];
				if (tileTrapTrigger.teamType != UnitTeam.Type.Enemy && !tileTrapTrigger.discovered)
				{
					hiddenPlayerTraps++;
				}
			}
			if (cloakedPlayerUnits.Count > 0 || hiddenPlayerTraps > 0)
			{
				Unit target = aiUnits[UnityEngine.Random.Range(0, aiUnits.Count)];
				v2i targetCoord = target.coord + new v2i(UnityEngine.Random.Range(-2, 2), UnityEngine.Random.Range(-2, 2));
				targetCoord.x = Mathf.Clamp(targetCoord.x, 0, curMap.size.x);
				targetCoord.y = Mathf.Clamp(targetCoord.y, 0, curMap.size.y);
				if (abilityDetect.ValidateTileSelection(unit4, targetCoord))
				{
					aiDetectCooldown = 2;
					yield return abilityRoutine.Run(abilityDetect, unit4, targetCoord);
					yield break;
				}
			}
		}
		dangerousTiles.Clear();
		foreach (Unit unit5 in aiUnits)
		{
			yield return null;
			DangerousTilesByUnit(unit5);
		}
		GrenadeDangerForTeam(UnitTeam.Type.Enemy);
		GrenadeDangerForTeam(UnitTeam.Type.Player);
		Map map = Singleton<MC>.Inst.GetActiveMap();
		for (int num2 = 0; num2 < map.trapTiles.Length; num2++)
		{
			TileTrapTrigger tileTrapTrigger2 = map.trapTiles[num2];
			bool flag = tileTrapTrigger2.teamType == UnitTeam.Type.Enemy;
			if (flag || tileTrapTrigger2.discovered)
			{
				TileDangerType dangerType = ((!flag) ? TileDangerType.PlayerTrap : TileDangerType.AITrap);
				CalculateCoordsInRadius(tileTrapTrigger2.GetCoord(), tileTrapTrigger2.CircleSize);
				for (int num3 = 0; num3 < coordDistanceList.Count; num3++)
				{
					AddTileDanger(coordDistanceList[num3], dangerType);
				}
			}
		}
		foreach (Unit unit6 in aiUnits)
		{
			yield return null;
			yield return flurryEval.Run(unit6, 1);
			if (flurryEval.UsedAbility)
			{
				yield break;
			}
			Ability_Break abilityBreak = GetAbility<Ability_Break>(unit6);
			if (abilityBreak != null)
			{
				foreach (Unit pUnit in visiblePlayerUnits)
				{
					if (pUnit.abilities.AbilityGetByType<Ability_Break_Proxy>(pUnit) != null || !ValidateUnitSelection(abilityBreak, unit6, pUnit))
					{
						continue;
					}
					yield return abilityRoutine.Run(abilityBreak, unit6, pUnit);
					yield break;
				}
			}
			yield return groundPoundEval.Run(unit6);
			if (groundPoundEval.UsedAbility)
			{
				yield break;
			}
			Ability_Upgrade abilityUpgrade = GetAbility<Ability_Upgrade>(unit6);
			if (abilityUpgrade != null && abilityUpgrade.IsUpgraded && unit6.AP > 1)
			{
				yield return areaCalc[0].Run(unit6, 0, abilityUpgrade.SelectionRange(unit6), includePathing: false, null, removeBlockedEPTiles: false, removeUnitCoords: false);
				uint bestTargetCount = 0u;
				v2i bestTarget = v2i.zero;
				foreach (KeyValuePair<v2i, int> item in areaCalc[0])
				{
					v2i key = item.Key;
					areaTargetsCA.Clear();
					Unit.GatherUnitsInRadius(key, abilityUpgrade.SelectionEffectRange(unit6), areaTargetsCA, UnitTeam.Type.Enemy.ToMask());
					uint length = areaTargetsCA.Length;
					if (length > bestTargetCount)
					{
						bestTargetCount = areaTargetsCA.Length;
						bestTarget = key;
					}
				}
				if (bestTargetCount > 1 && abilityUpgrade.ValidateTileSelection(unit6, bestTarget))
				{
					yield return abilityRoutine.Run(abilityUpgrade, unit6, bestTarget);
					yield break;
				}
			}
			Ability_Decoy abilityDecoy = GetAbility<Ability_Decoy>(unit6);
			if (abilityDecoy != null && !unit6.IsCloaked && unit6.AP > abilityDecoy.APCost(unit6) && !unit6.decoyUnit.IsAlive() && abilityDecoy.ValidateTileSelection(unit6, unit6.coord))
			{
				yield return areaCalc[0].Run(unit6, 0, abilityDecoy.SelectionRange(unit6), includePathing: false, pathCellValidator);
				List<v2i> allCoords = areaCalc[0].AllCoords;
				yield return abilityRoutine.Run(abilityDecoy, unit6, allCoords[UnityEngine.Random.Range(0, allCoords.Count)]);
				thresholdsByUnit[unit6.decoyUnit] = new UnitThresholds(unit6.decoyUnit, aiUnits);
				Unit unitMove1 = ((!50.PercentChance()) ? unit6.decoyUnit : unit6);
				Unit unitMove2 = ((!(unitMove1 == unit6)) ? unit6 : unit6.decoyUnit);
				yield return aiMovementRoutine.Run(unitMove1);
				if (!GC.Inst.flagEndTurnMode)
				{
					yield return aiMovementRoutine.Run(unitMove2);
				}
				yield break;
			}
			Ability_Shove shoveAbility = GetAbility<Ability_Shove>(unit6);
			if (shoveAbility != null && unit6.AP > 1)
			{
				foreach (Unit pUnit2 in visiblePlayerUnits)
				{
					if (v2i.IsNeighbour(unit6.coord, pUnit2.coord) && ValidateUnitSelection(shoveAbility, unit6, pUnit2))
					{
						OctDir dir = (OctDir)NC.DirectionToIndex(pUnit2.coord - unit6.coord);
						yield return pUnit2.ShoveCoordCalc.Run(pUnit2.coord, dir, mustMove: false, shoveAbility.ShoveDist);
						v2i endCoord = pUnit2.ShoveCoordCalc.EndCoord;
						int curAttackers = GetNumPotentialAttackers(pUnit2, pUnit2.coord) - 1;
						int dstAttackers = GetNumPotentialAttackers(pUnit2, endCoord);
						float curGlobalThreat = GetTeamThreatForUnit(pUnit2);
						float dstGlobalThreat = ((!shoveAbility.IsUpgraded || !pUnit2.ShoveCoordCalc.HitObstruction) ? GetTeamThreatForUnit(pUnit2, endCoord) : 0f);
						if ((dstAttackers >= curAttackers && dstGlobalThreat < curGlobalThreat) || (dstAttackers > curAttackers && dstGlobalThreat <= curGlobalThreat))
						{
							yield return abilityRoutine.Run(shoveAbility, unit6, pUnit2);
							yield break;
						}
					}
				}
			}
			if (unit6.IsAttackingDisabled || !unit6.IsMelee || unit6.AP != unit6.GetAPMax())
			{
				continue;
			}
			foreach (Unit pUnit3 in visiblePlayerUnits)
			{
				if (v2i.IsNeighbour(unit6.coord, pUnit3.coord))
				{
					yield return aiAttackRoutine.Run(unit6, pUnit3, aiUnits);
					yield break;
				}
			}
		}
		curThreatByUnit.Clear();
		foreach (Unit unit7 in aiUnits)
		{
			yield return null;
			curThreatByUnit[unit7] = GetThreatForUnitAtCoord(unit7, unit7.coord);
		}
		unitsByTotalThreat.Clear();
		unitsByTotalThreat.AddRange(aiUnits);
		unitsByTotalThreat.Sort(unitTheatComp);
		for (int i = unitsByTotalThreat.Count - 1; i >= 0; i--)
		{
			Unit assister = aiUnits[i];
			abilityTempArray[0] = GetAbility<Ability_Disable>(assister);
			abilityTempArray[1] = GetAbility<Ability_Backup>(assister);
			abilityTempArray[2] = GetAbility<Ability_Taunt>(assister);
			AbilityImplBase[] array = abilityTempArray;
			foreach (AbilityImplBase abilityToUse in array)
			{
				if (abilityToUse == null)
				{
					continue;
				}
				ThreatData assisterT = curThreatByUnit[assister];
				float assisterTTThresh = thresholdsByUnit[assister].totalThreat;
				bool isBackup = abilityToUse is Ability_Backup;
				bool isTaunt = !isBackup && abilityToUse is Ability_Taunt;
				float threatMult = 1f;
				bool considerSelf = assisterT.totalThreat >= assisterTTThresh;
				if (isBackup)
				{
					threatMult = GetBackupThreatMod(abilityToUse.IsUpgraded);
					considerSelf &= assisterT.totalThreat * threatMult < assisterTTThresh;
				}
				else
				{
					considerSelf &= assisterT.totalThreat - assisterT.maxThreat < assisterTTThresh;
				}
				Unit actualAssistee = null;
				Unit targetUnit = null;
				foreach (Unit item2 in unitsByTotalThreat)
				{
					if (item2 == assister)
					{
						continue;
					}
					ThreatData threatData = curThreatByUnit[item2];
					float num5 = thresholdsByUnit[item2].totalThreat;
					if (threatData.totalThreat < num5)
					{
						continue;
					}
					if (considerSelf)
					{
						actualAssistee = ChooseHighest(assister, item2, assisterT.totalThreat / assisterTTThresh, threatData.totalThreat / num5);
						if (actualAssistee == assister)
						{
							if (isTaunt)
							{
								continue;
							}
							threatData = assisterT;
							num5 = assisterTTThresh;
						}
					}
					else
					{
						actualAssistee = item2;
					}
					Ability_Taunt_Proxy proxyAbility = GetProxyAbility<Ability_Taunt_Proxy>(threatData.maxThreatUnit);
					if (isTaunt && proxyAbility != null)
					{
						continue;
					}
					if (isBackup)
					{
						if (threatData.totalThreat * threatMult < num5 && ValidateUnitSelection(abilityToUse, assister, item2))
						{
							targetUnit = actualAssistee;
							break;
						}
					}
					else if (threatData.totalThreat - threatData.maxThreat < num5 && ValidateUnitSelection(abilityToUse, assister, threatData.maxThreatUnit))
					{
						targetUnit = threatData.maxThreatUnit;
						break;
					}
				}
				if (!(targetUnit == null))
				{
					yield return abilityRoutine.Run(abilityToUse, assister, targetUnit);
					yield break;
				}
			}
		}
		foreach (Unit unit8 in aiUnits)
		{
			yield return null;
			UnitThresholds thresholds3 = thresholdsByUnit[unit8];
			ThreatData curThreat = curThreatByUnit[unit8];
			bool coordIsSafe = SafeToStandOn(unit8.coord);
			if ((coordIsSafe && curThreat.totalThreat < thresholds3.totalThreat) || unit8.IsMovementDisabled || unit8.AP <= 0)
			{
				continue;
			}
			if (coordIsSafe && !unit8.IsAttackingDisabled && curThreat.totalThreat - curThreat.maxThreat < thresholds3.totalThreat)
			{
				float killChance = ChanceOfDealingDamage(unit8, unit8.coord, unit8.mainWeapon, curThreat.maxThreatUnit, curThreat.maxThreatUnit.coord, curThreat.maxThreatUnit.HP);
				if (killChance >= thresholds3.killThreatChance && !unit8.IsMelee)
				{
					yield return aiAttackRoutine.Run(unit8, curThreat.maxThreatUnit, aiUnits);
					yield break;
				}
				Ability_Headshot abilityHeadshot2 = GetAbility<Ability_Headshot>(unit8);
				if (abilityHeadshot2 != null)
				{
					float hsKillChance = ChanceOfDealingDamage(unit8, unit8.coord, unit8.mainWeapon, curThreat.maxThreatUnit, curThreat.maxThreatUnit.coord, curThreat.maxThreatUnit.HP, abilityHeadshot2);
					if (hsKillChance >= thresholds3.killThreatChance && ValidateUnitSelection(abilityHeadshot2, unit8, curThreat.maxThreatUnit))
					{
						yield return abilityRoutine.Run(abilityHeadshot2, unit8, curThreat.maxThreatUnit);
						yield break;
					}
				}
			}
			int distPerAP2 = unit8.GetMovementDistancePerTurn();
			Ability_Leap leap2 = GetAbility<Ability_Leap>(unit8);
			ThreatData? bestLeapThreat = null;
			Unit leapTarget = null;
			float leapHitChance = 0f;
			if (leap2 != null)
			{
				yield return areaCalc[0].Run(unit8, 0, leap2.SelectionRange(unit8), includePathing: false, pathCellValidator, removeBlockedEPTiles: true);
				foreach (KeyValuePair<v2i, int> item3 in areaCalc[0])
				{
					v2i coord2 = item3.Key;
					if (leap2.ValidateTileSelection(unit8, coord2))
					{
						ThreatData t2 = GetThreatForUnitAtCoord(unit8, coord2);
						float bestHitChance;
						Unit bestTarget3 = GetBestHitChance(unit8, t2.coord, out bestHitChance);
						if ((!bestLeapThreat.HasValue || t2.totalThreat < bestLeapThreat.Value.totalThreat) && (t2.totalThreat < thresholds3.totalThreat || bestTarget3 != null))
						{
							leapTarget = bestTarget3;
							leapHitChance = bestHitChance;
							bestLeapThreat = t2;
						}
						if (!(bestHitChance < thresholds3.hitChance) && !(t2.totalThreat >= thresholds3.totalThreat))
						{
							yield return abilityRoutine.Run(leap2, unit8, coord2);
							yield break;
						}
					}
				}
			}
			Ability_Dash dash = GetAbility<Ability_Dash>(unit8);
			if (dash != null)
			{
				foreach (Unit pUnit4 in visiblePlayerUnits)
				{
					if (!ValidateUnitSelection(dash, unit8, pUnit4))
					{
						continue;
					}
					v2i endCoord2 = dash.GetEndCoord(unit8.coord, pUnit4.coord);
					if (!SafeToStandOn(endCoord2))
					{
						continue;
					}
					ThreatData t3 = GetThreatForUnitAtCoord(unit8, endCoord2);
					if (t3.totalThreat >= thresholds3.totalThreat && dash.IsUpgraded)
					{
						float threatForUnitAtCoordFromUnit = GetThreatForUnitAtCoordFromUnit(unit8, endCoord2, pUnit4, pUnit4.coord);
						if (t3.totalThreat - threatForUnitAtCoordFromUnit >= thresholds3.totalThreat)
						{
							continue;
						}
						float num6 = ChanceOfDealingDamage(unit8, unit8.coord, unit8.mainWeapon, pUnit4, pUnit4.coord, pUnit4.HP);
						if (num6 < thresholds3.killThreatChance)
						{
							continue;
						}
					}
					float hitChance2 = GetHitChance(unit8, endCoord2, pUnit4, pUnit4.coord);
					yield return abilityRoutine.Run(dash, unit8, pUnit4);
					yield break;
				}
			}
			AreaCalculation obj = areaCalc[0];
			Unit unit15 = unit8;
			NC.PathingCellValidator pathValidator = pathCellValidator;
			yield return obj.Run(unit15, 0, -1, includePathing: true, pathValidator, removeBlockedEPTiles: true);
			for (int ap3 = 1; ap3 <= unit8.AP; ap3++)
			{
				List<ThreatData> threatList3 = coordThreatByAP[ap3 - 1];
				threatList3.Clear();
				foreach (KeyValuePair<v2i, int> item4 in areaCalc[0])
				{
					v2i key2 = item4.Key;
					int num7 = DistToAp(item4.Value, distPerAP2);
					if (!(key2 == unit8.coord) && num7 == ap3)
					{
						threatList3.Add(GetThreatForUnitAtCoord(unit8, key2));
					}
				}
				threatList3.Sort(totalThreatComp);
				for (int j = 0; j < threatList3.Count; j++)
				{
					ThreatData t4 = threatList3[j];
					if (t4.totalThreat >= thresholds3.totalThreat)
					{
						break;
					}
					float bestHitChance2;
					Unit bestTarget8 = GetBestHitChance(unit8, t4.coord, out bestHitChance2);
					if (!(bestHitChance2 < thresholds3.hitChance))
					{
						yield return trapPlacement.Run(unit8, ap3, t4.coord, areaCalc[1]);
						if (!trapPlacement.PlacedTrap || !GC.Inst.flagEndTurnMode)
						{
							yield return StartMovement(unit8, t4.coord, ap3);
						}
						yield break;
					}
				}
			}
			float unusedHC;
			Unit possibleTarget = GetBestHitChance(unit8, unit8.coord, out unusedHC);
			ThreatData bestMoveThreat = curThreat;
			int apCost = -1;
			for (int num8 = 1; num8 <= unit8.AP; num8++)
			{
				List<ThreatData> list = coordThreatByAP[num8 - 1];
				for (int num9 = 0; num9 < list.Count; num9++)
				{
					ThreatData threatData2 = list[num9];
					if (threatData2.totalThreat >= bestMoveThreat.totalThreat)
					{
						break;
					}
					Unit bestHitChance3 = GetBestHitChance(unit8, threatData2.coord, out unusedHC);
					if (possibleTarget == null || bestHitChance3 != null)
					{
						possibleTarget = bestHitChance3;
						bestMoveThreat = threatData2;
						apCost = num8;
						break;
					}
				}
			}
			if (apCost != -1 && (!bestLeapThreat.HasValue || bestMoveThreat.totalThreat < bestLeapThreat.Value.totalThreat))
			{
				yield return trapPlacement.Run(unit8, apCost, bestMoveThreat.coord, areaCalc[1]);
				if (!trapPlacement.PlacedTrap || !GC.Inst.flagEndTurnMode)
				{
					yield return StartMovement(unit8, bestMoveThreat.coord, apCost);
				}
				yield break;
			}
			if (bestLeapThreat.HasValue)
			{
				ThreatData td = bestLeapThreat.Value;
				yield return trapPlacement.Run(unit8, leap2.APCost(unit8), bestMoveThreat.coord, areaCalc[1]);
				if (!trapPlacement.PlacedTrap || !GC.Inst.flagEndTurnMode)
				{
					yield return abilityRoutine.Run(leap2, unit8, td.coord);
				}
				yield break;
			}
			if (AbilityIncorporeal(unit8))
			{
				yield return Wait.ForChildren;
				yield break;
			}
			Ability_Hunker_Down aHunker = GetAbility<Ability_Hunker_Down>(unit8);
			if (aHunker == null || unit8.AP != 1)
			{
				continue;
			}
			yield return abilityRoutine.Run(aHunker, unit8);
			yield break;
		}
		foreach (Unit unit10 in aiUnits)
		{
			yield return null;
			Ability_Ricochet abilityRicochet = GetAbility<Ability_Ricochet>(unit10);
			if (abilityRicochet != null)
			{
				Unit bestTarget7 = FindBestHCUnit(findSafest: true);
				if (bestTarget7 != null && ValidateUnitSelection(abilityRicochet, unit10, bestTarget7))
				{
					yield return abilityRoutine.Run(abilityRicochet, unit10, bestTarget7);
					yield break;
				}
			}
			Ability_Disrupt abilityDisrupt = GetAbility<Ability_Disrupt>(unit10);
			if (abilityDisrupt != null)
			{
				Unit bestUnit = null;
				foreach (Unit visiblePlayerUnit in visiblePlayerUnits)
				{
					Ability_Disrupt_Proxy ability_Disrupt_Proxy = visiblePlayerUnit.abilities.AbilityGetByType<Ability_Disrupt_Proxy>();
					if (ability_Disrupt_Proxy != null || !ValidateUnitSelection(abilityDisrupt, unit10, visiblePlayerUnit))
					{
						continue;
					}
					int num10 = CountValidDisruptAbilities(visiblePlayerUnit);
					int num11 = ((!abilityDisrupt.IsUpgraded) ? 1 : 2);
					if (num10 >= num11)
					{
						if (visiblePlayerUnit.charData.Class == CharacterClass.Programmer)
						{
							bestUnit = visiblePlayerUnit;
							break;
						}
						bestUnit = visiblePlayerUnit;
					}
				}
				if (bestUnit != null)
				{
					yield return abilityRoutine.Run(abilityDisrupt, unit10, bestUnit);
					yield break;
				}
			}
			Ability_Grenade abilityGrenade = GetAbility<Ability_Grenade>(unit10);
			if (abilityGrenade != null)
			{
				v2i bestTarget6 = v2i.zero;
				uint bestTargetCount3 = 0u;
				yield return areaCalc[0].Run(unit10, 0, abilityGrenade.SelectionRange(unit10), includePathing: false, null, removeBlockedEPTiles: false, removeUnitCoords: false);
				foreach (KeyValuePair<v2i, int> item5 in areaCalc[0])
				{
					v2i key3 = item5.Key;
					if ((GetTileDanger(key3) & TileDangerType.AIGrenade) == 0)
					{
						areaTargetsCA.Clear();
						Unit.GatherUnitsInRadius(key3, abilityGrenade.SelectionEffectRange(unit10), areaTargetsCA, UnitTeam.Type.Player.ToMask());
						RemoveInvalidTargets(areaTargetsCA);
						uint length2 = areaTargetsCA.Length;
						Unit.GatherUnitsInRadius(key3, abilityGrenade.SelectionEffectRange(unit10), areaTargetsCA, UnitTeam.Type.Enemy.ToMask());
						if (areaTargetsCA.Length == 0 && length2 > bestTargetCount3)
						{
							bestTargetCount3 = length2;
							bestTarget6 = key3;
						}
					}
				}
				if (bestTargetCount3 > 1 && abilityGrenade.ValidateTileSelection(unit10, bestTarget6))
				{
					yield return abilityRoutine.Run(abilityGrenade, unit10, bestTarget6, new UIAbilityWheelChoice
					{
						subAbilityIdx = (int)unit10.aiParameters.grenadeOrTrapType
					});
					yield break;
				}
			}
			Ability_Area_Shot abilityAreaShot = GetAbility<Ability_Area_Shot>(unit10);
			if (abilityAreaShot != null)
			{
				v2i bestTarget5 = v2i.zero;
				uint bestTargetCount2 = 0u;
				yield return areaCalc[0].Run(unit10, 0, abilityAreaShot.SelectionRange(unit10), includePathing: false, null, removeBlockedEPTiles: false, removeUnitCoords: false);
				foreach (KeyValuePair<v2i, int> item6 in areaCalc[0])
				{
					v2i key4 = item6.Key;
					areaTargetsCA.Clear();
					Unit.GatherUnitsInRadius(key4, abilityAreaShot.SelectionEffectRange(unit10), areaTargetsCA, UnitTeam.Type.Player.ToMask());
					ConstArray<Unit> units2 = areaTargetsCA;
					RemoveInvalidTargets(units2, filterCloaked: true, unit10, directLOS: true);
					uint length3 = areaTargetsCA.Length;
					if (length3 > bestTargetCount2)
					{
						bestTargetCount2 = areaTargetsCA.Length;
						bestTarget5 = key4;
					}
				}
				if (bestTargetCount2 > 1 && abilityAreaShot.ValidateTileSelection(unit10, bestTarget5))
				{
					yield return abilityRoutine.Run(abilityAreaShot, unit10, bestTarget5);
					yield break;
				}
			}
			Ability_Spot abilitySpot = GetAbility<Ability_Spot>(unit10);
			if (abilitySpot != null)
			{
				Unit bestTarget4 = FindBestHCUnit();
				if (bestTarget4 != null && unit10.map.HasLineOfSight(unit10.coord, bestTarget4.coord, isSideStepAllowed: true) && ValidateUnitSelection(abilitySpot, unit10, bestTarget4))
				{
					yield return abilityRoutine.Run(abilitySpot, unit10, bestTarget4);
					yield break;
				}
			}
			Ability_Bleed abilityBleed = GetAbility<Ability_Bleed>(unit10);
			if (abilityBleed != null)
			{
				Unit biggestTeamThreat2 = GetBiggestTeamThreatForUnits(unit10);
				if (biggestTeamThreat2 != null && ValidateUnitSelection(abilityBleed, unit10, biggestTeamThreat2))
				{
					yield return abilityRoutine.Run(abilityBleed, unit10, biggestTeamThreat2);
					yield break;
				}
			}
			yield return flurryEval.Run(unit10, 0);
			if (flurryEval.UsedAbility)
			{
				yield break;
			}
		}
		foreach (Unit unit9 in aiUnits)
		{
			yield return null;
			if (unit9.AP == 0 || unit9.IsAttackingDisabled)
			{
				continue;
			}
			UnitThresholds thresholds4 = thresholdsByUnit[unit9];
			Ability_Covering_Fire abilityCoveringFire = GetAbility<Ability_Covering_Fire>(unit9);
			if (abilityCoveringFire != null)
			{
				Unit biggestTeamThreat = GetBiggestTeamThreatForUnits(unit9, notSuppressed);
				if (biggestTeamThreat != null && ValidateUnitSelection(abilityCoveringFire, unit9, biggestTeamThreat))
				{
					yield return abilityRoutine.Run(abilityCoveringFire, unit9, biggestTeamThreat);
					yield break;
				}
			}
			float curHitChance;
			Unit curBestTarget = GetBestHitChance(unit9, unit9.coord, out curHitChance);
			if (curBestTarget != null && (unit9.IsMelee || curHitChance >= thresholds4.hitChance))
			{
				Ability_Lookout abilityLookout = GetAbility<Ability_Lookout>(unit9);
				if (abilityLookout != null && unit9.AP - abilityLookout.APCost(unit9) > 0 && abilityLookout.ValidateTileSelection(unit9, curBestTarget.coord))
				{
					yield return abilityRoutine.Run(abilityLookout, unit9, curBestTarget.coord);
					if ((bool)GC.Inst.flagEndTurnMode)
					{
						yield break;
					}
				}
				Ability_Limb_Shot abilityLimbShot = GetAbility<Ability_Limb_Shot>(unit9);
				if (abilityLimbShot != null && ValidateUnitSelection(abilityLimbShot, unit9, curBestTarget))
				{
					yield return abilityRoutine.Run(abilityLimbShot, unit9, curBestTarget);
					yield break;
				}
				Ability_Headshot abilityHeadshot = GetAbility<Ability_Headshot>(unit9);
				if (abilityHeadshot != null && abilityHeadshot.IsUpgraded && ValidateUnitSelection(abilityHeadshot, unit9, curBestTarget))
				{
					int regDamage = unit9.GetDamageValue(isCriticalHit: false, curBestTarget, unit9.mainWeapon, isCombatCalculation: false);
					if (curBestTarget.HP > regDamage)
					{
						yield return abilityRoutine.Run(abilityHeadshot, unit9, curBestTarget);
						yield break;
					}
				}
				yield return aiAttackRoutine.Run(unit9, curBestTarget, aiUnits);
				yield break;
			}
			if (unit9.IsMovementDisabled)
			{
				if (!(curBestTarget != null))
				{
					continue;
				}
				yield return aiAttackRoutine.Run(unit9, curBestTarget, aiUnits);
				yield break;
			}
			AreaCalculation obj2 = areaCalc[0];
			Unit unit15 = unit9;
			NC.PathingCellValidator pathValidator = pathCellValidator;
			yield return obj2.Run(unit15, 0, -1, includePathing: true, pathValidator, removeBlockedEPTiles: true);
			int distPerAP = unit9.GetMovementDistancePerTurn();
			for (int ap2 = 1; ap2 <= unit9.AP; ap2++)
			{
				List<ThreatData> threatList2 = coordThreatByAP[ap2 - 1];
				threatList2.Clear();
				foreach (KeyValuePair<v2i, int> kvp in areaCalc[0])
				{
					v2i coord = kvp.Key;
					int moveCost = DistToAp(kvp.Value, distPerAP);
					if (coord == unit9.coord || moveCost != ap2)
					{
						continue;
					}
					ThreatData threat = GetThreatForUnitAtCoord(unit9, coord);
					if (threat.totalThreat < thresholds4.totalThreat)
					{
						threatList2.Add(threat);
					}
					else if (ap2 >= unit9.AP - unit9.GetMaxAPToUseWithAttack())
					{
						continue;
					}
					float hitChance;
					Unit bestTarget2 = GetBestHitChance(unit9, coord, out hitChance);
					if (!(hitChance >= thresholds4.hitChance))
					{
						continue;
					}
					yield return StartMovement(unit9, coord, ap2);
					if (unit9.AP > 0 && unit9.coord == coord && !GC.Inst.flagEndTurnMode)
					{
						yield return aiAttackRoutine.Run(unit9, bestTarget2, aiUnits);
					}
					yield break;
				}
			}
			Ability_Overwatch abilitySentry = GetAbility<Ability_Overwatch>(unit9);
			if (abilitySentry != null)
			{
				yield return abilityRoutine.Run(abilitySentry, unit9);
				yield break;
			}
			if (curBestTarget != null)
			{
				yield return aiAttackRoutine.Run(unit9, curBestTarget, aiUnits);
				yield break;
			}
			yield return groundPoundEval.Run(unit9, 1u);
			if (groundPoundEval.UsedAbility)
			{
				yield break;
			}
			if (AbilityIncorporeal(unit9))
			{
				yield return Wait.ForChildren;
				yield break;
			}
			int apPerTurn = unit9.GetAPMax();
			for (int turn = 2; turn <= 4; turn++)
			{
				int baseAP = (turn - 1) * apPerTurn;
				int minR = baseAP * distPerAP;
				int maxR = turn * apPerTurn * distPerAP;
				Ability_Leap leap = GetAbility<Ability_Leap>(unit9);
				yield return areaCalc[0].Run(unit9, minR, maxR);
				if (leap != null)
				{
					yield return areaCalc[1].Run(unit9, 0, leap.SelectionRange(unit9), includePathing: false, pathCellValidator, removeBlockedEPTiles: true);
				}
				for (int apOffset = 1; apOffset <= apPerTurn; apOffset++)
				{
					List<RepositionTarget> hitList = coordHitByAP[apOffset - 1];
					hitList.Clear();
					foreach (KeyValuePair<v2i, int> item7 in areaCalc[0])
					{
						if (DistToAp(item7.Value, distPerAP) != baseAP + apOffset)
						{
							continue;
						}
						v2i key5 = item7.Key;
						ThreatData threatForUnitAtCoord = GetThreatForUnitAtCoord(unit9, key5);
						if (!(threatForUnitAtCoord.totalThreat >= thresholds4.totalThreat))
						{
							float bestHitChance4;
							Unit bestHitChance5 = GetBestHitChance(unit9, key5, out bestHitChance4);
							if (!(bestHitChance4 < thresholds4.hitChance))
							{
								hitList.Add(new RepositionTarget(key5, bestHitChance4, bestHitChance5, threatForUnitAtCoord.totalThreat));
							}
						}
					}
					hitList.Sort(hitChanceComp);
					for (int num12 = 1; num12 <= unit9.AP; num12++)
					{
						coordThreatByAP[num12 - 1].Sort(totalThreatComp);
					}
					foreach (RepositionTarget hitD in hitList)
					{
						if (leap != null && areaCalc[1].DistByCoord.ContainsKey(hitD.coord))
						{
							yield return abilityRoutine.Run(leap, unit9, hitD.coord);
							yield break;
						}
						ThreatData? bestTD = null;
						int bestCost = areaCalc[0].DistByCoord[hitD.coord];
						int bestAP = 0;
						for (int ap = 1; ap <= unit9.AP; ap++)
						{
							List<ThreatData> threatList = coordThreatByAP[ap - 1];
							foreach (ThreatData t in threatList)
							{
								yield return pathCalculation.Run(unit9, t.coord, hitD.coord);
								if (pathCalculation.path.status == NC.PathStatus.Complete && pathCalculation.path.cost < bestCost)
								{
									bestCost = pathCalculation.path.cost;
									bestTD = t;
									bestAP = ap;
								}
							}
						}
						if (bestTD.HasValue)
						{
							yield return StartMovement(unit9, bestTD.Value.coord, bestAP);
							yield break;
						}
					}
				}
			}
		}
		for (int num13 = 0; num13 < aiUnitsCA.Length; num13++)
		{
			Unit unit16 = aiUnitsCA[num13];
			if (unit16.AP > 0)
			{
				if (aiPropertiesByUnit.TryGetValue(unit16, out var value))
				{
					value.impatience = Mathf.Clamp01(value.impatience + unit16.aiParameters.impatience * (float)unit16.AP);
				}
				unit16.APDecrement(unit16.AP);
				break;
			}
		}
	}

	public void OnTurnModeEnter()
	{
	}

	public void OnTurnModeExit()
	{
	}

	public void OnUnitFinishedMoving(Unit unit)
	{
	}

	public Unit GetLeader()
	{
		return GetTeam().GetTeamLeader();
	}

	public HagletYieldTerm TakeAction()
	{
		return Routine.Start(turnControl);
	}

	public void OnTurnEnd()
	{
		aiDetectCooldown--;
		unitsByHP.Clear();
		curThreatByUnit.Clear();
		unitsByTotalThreat.Clear();
		playerUnits.Clear();
		visiblePlayerUnits.Clear();
		cloakedPlayerUnits.Clear();
		aiUnits.Clear();
	}

	public void OnRPGModeEnter(UnitTeam.Type teamType)
	{
	}

	public void OnRPGModeExit(UnitTeam.Type teamType)
	{
	}

	public void OnUnitDeath(Unit unit)
	{
	}

	public UnitTeam GetTeam()
	{
		return GC.Inst.GetTeamOfType(activeTeamType);
	}

	[Conditional("AE_DEBUG")]
	public static void Thought(string thought)
	{
	}

	[Conditional("AE_DEBUG")]
	public static void Thought(Unit currentUnit, string thought)
	{
		if (GC.Inst.DEBUG_LogAIThoughts)
		{
			string text = "AI: ";
			text += ((!(currentUnit == null)) ? (currentUnit.charData.charName + ": ") : "GLOBAL: ");
			UnityEngine.Debug.Log(text + thought, currentUnit);
		}
	}

	[Conditional("AE_DEBUG")]
	public static void Error(Unit currentUnit, string error)
	{
		string text = "AIERROR: ";
		text += ((!(currentUnit == null)) ? (currentUnit.charData.charName + ": ") : "GLOBAL: ");
		UnityEngine.Debug.LogError(text + error, currentUnit);
	}

	[Conditional("AE_DEBUG")]
	public static void Panic(Unit currentUnit, string error)
	{
	}

	[Conditional("AE_DEBUG")]
	public static void Panic(bool condition, Unit currentUnit, string error)
	{
	}
}
public class DC
{
	public enum GameSection
	{
		ONE,
		TWO_A,
		TWO_B,
		THREE
	}

	private static DC _instance;

	public static DC Inst => _instance;

	public static void Instantiate()
	{
		if (_instance == null)
		{
			_instance = new DC();
		}
	}

	public void RegisterDialogResponse(GameSection section, int value)
	{
		SaveData.data.honestyTrackDict[section] += value;
	}

	public bool WasHonestThroughoutSection(GameSection section)
	{
		int value = 0;
		SaveData.data.honestyTrackDict.TryGetValue(section, out value);
		return value > 0;
	}

	public bool WasHonestThroughoutSection(GameSection sectionA, GameSection sectionB)
	{
		int value = 0;
		SaveData.data.honestyTrackDict.TryGetValue(sectionA, out value);
		int value2 = 0;
		SaveData.data.honestyTrackDict.TryGetValue(sectionA, out value2);
		return value + value2 > 0;
	}

	public bool HasHonestyChangedBetweenSections(GameSection lhs, GameSection rhs)
	{
		return WasHonestThroughoutSection(lhs) == WasHonestThroughoutSection(rhs);
	}

	public HagletEvent PlayInterplay()
	{
		SaveData.Interplay interplay = null;
		UnitTeam teamOfType = GC.Inst.GetTeamOfType(UnitTeam.Type.Player);
		ConstArray<Unit> activeMembers = teamOfType.GetActiveMembers();
		for (int i = 0; i < activeMembers.Length; i++)
		{
			PartyMemberID partyMemberID = activeMembers[i].charData.partyMemberID;
			if (!SaveData.data.InterplayPartyMemberIsValid(partyMemberID))
			{
				continue;
			}
			for (int j = i + 1; j < activeMembers.Length; j++)
			{
				PartyMemberID partyMemberID2 = activeMembers[j].charData.partyMemberID;
				if (!SaveData.data.InterplayPartyMemberIsValid(partyMemberID2) || partyMemberID == partyMemberID2)
				{
					continue;
				}
				SaveData.InterplayPair pair = SaveData.data.InterplayGetPair(partyMemberID, partyMemberID2);
				SaveData.Interplay interplay2 = SaveData.data.InterplayGetInterplay(pair);
				if (interplay == null)
				{
					if (interplay2.index < interplay2.dialogs.Length)
					{
						interplay = interplay2;
					}
				}
				else if (interplay2.index < interplay.index)
				{
					interplay = interplay2;
				}
			}
		}
		if (interplay != null)
		{
			DialogData dialogData = interplay.dialogs[interplay.index];
			interplay.index++;
			UIAmbientSubtitles.Inst.Show(dialogData);
			return dialogData.OnComplete;
		}
		return null;
	}
}
[ExecuteInEditMode]
public class GameTypeController : MonoBehaviour
{
	private static GameTypeController _instance;

	public GameTypeAsset gameTypeAsset;

	public static GameTypeController Instance => _instance;

	public bool IsFullGame => gameTypeAsset.gameType == GameTypeAsset.GameType.FullGame;

	public bool IsOculusTouchDemo => gameTypeAsset.gameType == GameTypeAsset.GameType.OculusTouchDemo;

	public bool IgnoreAttainment => gameTypeAsset.ignoreAttainment;

	private void Awake()
	{
		_instance = this;
	}
}
public interface ITeamController
{
	AbilityImplBase activeAbility { get; }

	void OnTeamInitialize(UnitTeam team);

	void OnRPGModeEnter(UnitTeam.Type teamType);

	void OnRPGModeExit(UnitTeam.Type teamType);

	void OnTurnModeEnter();

	void OnTurnModeExit();

	HagletYieldTerm TakeAction();

	void OnTurnEnd();

	void OnUnitFinishedMoving(Unit unit);

	void OnUnitDeath(Unit unit);

	Unit GetLeader();

	UnitTeam GetTeam();
}
public class Localisation
{
	public interface IUseLocalisation
	{
		void OnLanguageChanged(Language newLanguage);
	}

	private struct FontData
	{
		public string path;

		public Font font;

		public Material material;

		public FontType fontType;

		public FontData(string fontPath, FontType type)
		{
			path = fontPath;
			fontType = type;
			font = null;
			material = null;
		}
	}

	public enum FontType
	{
		Regular = 0,
		Bold = 1,
		Italic = 2,
		Outline = 3,
		ERROR = -1
	}

	public enum Language
	{
		ENGLISH,
		SPANISH,
		GERMAN,
		KOREAN,
		FRENCH,
		CHINESE,
		LANGUAGE_MAX
	}

	private static Localisation _instance;

	private int languageIndex;

	private Dictionary<string, string[]> database;

	private FontData[] fontData = new FontData[12]
	{
		new FontData("PT_Sans_Regular", FontType.Regular),
		new FontData("PT_Sans_Thick", FontType.Bold),
		new FontData("PT_Sans_Italic", FontType.Italic),
		new FontData("PT_Sans_Regular_outline", FontType.Outline),
		new FontData("dotum_Regular", FontType.Regular),
		new FontData("dotum_Thick", FontType.Bold),
		new FontData("dotum_Italic", FontType.Italic),
		new FontData("dotum_Regular_outline", FontType.Outline),
		new FontData("SourceHanSans_Regular", FontType.Regular),
		new FontData("SourceHanSans_Thick", FontType.Bold),
		new FontData("SourceHanSans_Italic", FontType.Italic),
		new FontData("SourceHanSans_Regular_outline", FontType.Outline)
	};

	private static int kFontStyleCount = 4;

	private readonly List<IUseLocalisation> localisationUsers = new List<IUseLocalisation>(512);

	public static Localisation Instance
	{
		get
		{
			return (_instance != null) ? _instance : (_instance = new Localisation());
		}
		set
		{
			_instance = value;
		}
	}

	public Language CurrentLanguage => (Language)languageIndex;

	private Localisation()
	{
		languageIndex = PlayerPrefs.GetInt("Language", -1);
		if (languageIndex == -1)
		{
			switch (UnityEngine.Application.systemLanguage)
			{
			case SystemLanguage.Korean:
				languageIndex = 3;
				break;
			case SystemLanguage.French:
				languageIndex = 4;
				break;
			case SystemLanguage.German:
				languageIndex = 2;
				break;
			case SystemLanguage.Spanish:
				languageIndex = 1;
				break;
			case SystemLanguage.Chinese:
				languageIndex = 5;
				break;
			case SystemLanguage.ChineseSimplified:
				languageIndex = 5;
				break;
			case SystemLanguage.ChineseTraditional:
				languageIndex = 5;
				break;
			default:
				languageIndex = 0;
				break;
			}
			PlayerPrefs.SetInt("Language", languageIndex);
			PlayerPrefs.Save();
		}
	}

	public static void RefreshDataBase(Dictionary<string, string[]> injectedDatabase = null)
	{
		if (injectedDatabase != null)
		{
			Instance.database = injectedDatabase;
			return;
		}
		Instance.database = null;
		Instance.database = GetDatabaseImmediate();
	}

	private static Dictionary<string, string[]> ParseCSVIntoDictionary(string csvData)
	{
		Dictionary<string, string[]> dictionary = new Dictionary<string, string[]>();
		bool flag = false;
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		string text = null;
		for (int i = 0; i < csvData.Length; i++)
		{
			char c = csvData[i];
			if ((c == ',' || c == '\n') && !flag)
			{
				if (text == null)
				{
					text = stringBuilder.ToString();
					stringBuilder.Length = 0;
					string[] value = new string[6];
					if (dictionary.ContainsKey(text))
					{
						continue;
					}
					dictionary.Add(text, value);
				}
				else if (num < 6)
				{
					dictionary[text][num] = stringBuilder.ToString().Trim();
					num++;
					stringBuilder.Length = 0;
				}
				if (c == '\n')
				{
					int num2 = 5;
					string text2 = dictionary[text][num2];
					if (text2 == null)
					{
					}
					text = null;
					stringBuilder.Length = 0;
					flag = false;
					num = 0;
				}
			}
			else if (c == '"')
			{
				if (flag)
				{
					if (i + 1 < csvData.Length && csvData[i + 1] == '"')
					{
						stringBuilder.Append(csvData[i + 1]);
						i++;
					}
					else
					{
						flag = false;
					}
				}
				else
				{
					flag = true;
				}
			}
			else
			{
				stringBuilder.Append(c);
			}
		}
		return dictionary;
	}

	public HagletYieldTerm LoadLocalization(bool synchronous)
	{
		if (database != null)
		{
			return Wait.PreMet;
		}
		if (synchronous)
		{
			database = GetDatabaseImmediate();
			LoadFontsImmediate();
			return Wait.PreMet;
		}
		return Routine.Start(new HagletResettable(LoadRoutine()));
	}

	private IEnumerator<HagletYieldTerm> LoadRoutine()
	{
		ResourceRequest resRequest = Resources.LoadAsync<TextAsset>("Localisation/localisation_script");
		yield return Wait.Until(() => resRequest.isDone);
		if (resRequest.asset == null)
		{
			UnityEngine.Debug.LogError("LocalisationController: Failed to open 'localisation_script.csv'!");
			yield break;
		}
		string csvData = ((TextAsset)resRequest.asset).text;
		AEResources.AddThreadTask(delegate
		{
			database = ParseCSVIntoDictionary(csvData);
		});
		yield return Wait.While(AEResources.ThreadBusy);
		for (int i = 0; i < fontData.Length; i++)
		{
			ResourceRequest fontLoader = Resources.LoadAsync<Font>(fontData[i].path);
			yield return Wait.Until(() => fontLoader.isDone);
			fontData[i].font = (Font)fontLoader.asset;
			fontLoader = Resources.LoadAsync<Material>(fontData[i].path);
			yield return Wait.Until(() => fontLoader.isDone);
			fontData[i].material = (Material)fontLoader.asset;
		}
	}

	private static Dictionary<string, string[]> GetDatabaseImmediate()
	{
		TextAsset textAsset = Resources.Load<TextAsset>("Localisation/localisation_script");
		if (textAsset == null)
		{
			UnityEngine.Debug.LogError("LocalisationController: Failed to open 'localisation_script.csv'!");
			return null;
		}
		return ParseCSVIntoDictionary(textAsset.text);
	}

	public static bool IsKeyValid(string key)
	{
		Instance.LoadLocalization(synchronous: true);
		string[] value;
		if (!string.IsNullOrEmpty(key))
		{
			return Instance.database.TryGetValue(key, out value);
		}
		return false;
	}

	public static string Retrieve(string key)
	{
		return RetrieveSpecific(key, (Language)Instance.languageIndex);
	}

	public static string RetrieveSpecific(string key, Language specificLanguage)
	{
		if (!Instance.database.TryGetValue(key, out var value))
		{
			return null;
		}
		string text = value[(int)specificLanguage];
		return (string.IsNullOrEmpty(key) || !string.IsNullOrEmpty(text)) ? text : "[Missing Text]";
	}

	public static string[] GetAllKeys()
	{
		string[] array = new string[Instance.database.Keys.Count];
		Instance.database.Keys.CopyTo(array, 0);
		return array;
	}

	public void ChangeLanguage(Language language)
	{
		if (language < Language.LANGUAGE_MAX)
		{
			languageIndex = (int)language;
			PlayerPrefs.SetInt("Language", languageIndex);
			NotifyLocalisationUsers(CurrentLanguage);
		}
	}

	private static int GetFontIndex(Language language, FontType type)
	{
		int num = 0;
		switch (language)
		{
		case Language.KOREAN:
			num = 1;
			break;
		case Language.CHINESE:
			num = 2;
			break;
		}
		return (int)(num * kFontStyleCount + type);
	}

	private void LoadFontsImmediate()
	{
		for (int i = 0; i < fontData.Length; i++)
		{
			if (fontData[i].font == null)
			{
				fontData[i].font = Resources.Load<Font>(fontData[i].path);
			}
			if (fontData[i].material == null)
			{
				fontData[i].material = Resources.Load<Material>(fontData[i].path);
			}
		}
	}

	public static Font GetFontByName(string fontName)
	{
		for (int i = 0; i < Instance.fontData.Length; i++)
		{
			if (Instance.fontData[i].font.name == fontName)
			{
				return Instance.fontData[i].font;
			}
		}
		return null;
	}

	public static Material GetFontMaterialByName(string fontName)
	{
		for (int i = 0; i < Instance.fontData.Length; i++)
		{
			if (Instance.fontData[i].font.name == fontName)
			{
				return Instance.fontData[i].material;
			}
		}
		return null;
	}

	public static FontType GetFontType(Font font)
	{
		for (int i = 0; i < Instance.fontData.Length; i++)
		{
			if (Instance.fontData[i].font == font)
			{
				return Instance.fontData[i].fontType;
			}
		}
		return FontType.ERROR;
	}

	public static void SetLocalisedFont(UITextbox tb)
	{
		SetLocalisedFont(tb, (!tb.enforceEnglish) ? ((Language)Instance.languageIndex) : Language.ENGLISH);
	}

	public static void SetLocalisedFont(UITextbox tb, Language language)
	{
		if (!(tb.font == null))
		{
			FontType fontType = GetFontType(tb.font);
			if (fontType != FontType.ERROR)
			{
				Font localisedFont = GetLocalisedFont(fontType, language);
				Material localisedFontMaterial = GetLocalisedFontMaterial(fontType, language);
				tb.SetFont(localisedFont, localisedFontMaterial);
			}
		}
	}

	private static FontData GetLocalisedFontData(FontType type, Language language)
	{
		return Instance.fontData[GetFontIndex(language, type)];
	}

	public static Font GetLocalisedFont(FontType type, Language language)
	{
		return GetLocalisedFontData(type, language).font;
	}

	public static Material GetLocalisedFontMaterial(FontType type, Language language)
	{
		return GetLocalisedFontData(type, language).material;
	}

	public void AddUsesLocalisation(IUseLocalisation localisationUser)
	{
		localisationUsers.Add(localisationUser);
	}

	public void RemoveUsesLocalisation(IUseLocalisation localisationUser)
	{
		localisationUsers.Remove(localisationUser);
	}

	private void NotifyLocalisationUsers(Language newLanguage)
	{
		foreach (IUseLocalisation localisationUser in localisationUsers)
		{
			localisationUser.OnLanguageChanged(newLanguage);
		}
	}
}
public static class LocalisationKeys
{
	public const string UIAbilityWheel_APCost = "UIABILITYWHEEL_APCOST";

	public const string UICharacterDetails_AbilityDetail_UpgradeAvailableAtRank = "UICHARACTERDETAILS_ABILITYDETAIL_UPGRADEAVAILABLEATRANK";

	public const string UICharacterDetails_AbilityDetail_UpgradeCapacityReached = "UICHARACTERDETAILS_ABILITYDETAIL_UPGRADECAPACITYREACHED";

	public const string UILoadout_MemberLevel = "UILOADOUT_MEMBERLEVEL";

	public const string UIMainMenu_ManageTeam = "UIMAINMENU_MANAGETEAM";

	public const string UIMainMenu_NewGame = "UIMAINMENU_NEWGAME";

	public const string UIMainMenu_ContinueGame = "UIMAINMENU_CONTINUEGAME";

	public const string UIMissionEnd_Level = "UIMISSIONEND_LEVEL";

	public const string UIStatusBar_EndTurn = "UISTATUSBAR_ENDTURN";

	public const string UIStatusBar_EnemyTurn = "UISTATUSBAR_ENEMYTURN";

	public const string UIStatusBar_Infinity = "UISTATUSBAR_INFINITY";

	public const string UIStatusBar_Nil = "UISTATUSBAR_NIL";

	public const string UIWhamBar_ResultText_Hit = "UIWHAMBAR_RESULTTEXT_HIT";

	public const string UIWhamBar_ResultText_Crit = "UIWHAMBAR_RESULTTEXT_CRIT";

	public const string UIWhamBar_ResultText_Miss = "UIWHAMBAR_RESULTTEXT_MISS";

	public const string UIWhamBar_ResultText_TryAgain = "UIWHAMBAR_RESULTTEXT_TRYAGAIN";

	public const string UIWhamBar_ResultText_Dodge = "UIWHAMBAR_RESULTTEXT_DODGE";

	public const string UIWhamBar_ResultText_Grazed = "UIWHAMBAR_RESULTTEXT_GRAZED";

	public const string UIWhamBar_ResultText_Endure = "UIWHAMBAR_RESULTTEXT_ENDURE";

	public const string UIWhamBar_ResultText_Reaction = "UIWHAMBAR_RESULTTEXT_REACTION";

	public const string UIWhamBar_ResultText_Reflect = "UIWHAMBAR_RESULTTEXT_REFLECT";

	public const string UIWhamBar_ResultText_Status = "UIWHAMBAR_RESULTTEXT_STATUS";

	public const string UIWhamBar_ResultText_Invalid = "UIWHAMBAR_RESULTTEXT_INVALID";

	public const string ClassName_Ghost = "CLASSNAME_GHOST";

	public const string ClassName_Muscle = "CLASSNAME_MUSCLE";

	public const string ClassName_Programmer = "CLASSNAME_PROGRAMMER";

	public const string ClassName_Soldier = "CLASSNAME_SOLDIER";

	public const string ClassName_Runner = "CLASSNAME_RUNNER";

	public const string ClassName_Trigger = "CLASSNAME_TRIGGER";

	public const string PopupBar_Stun_AccuracyDown = "POPUPBAR_STUN_ACCURACYDOWN";

	public const string PopupBar_Flux_Hack = "POPUPBAR_FLUX_HACK";

	public const string PopupBar_TileAction_InsufficientAP = "POPUPBAR_TILEACTION_INSUFFICIENTAP";

	public const string PopupBar_Ability_Backstab = "POPUPBAR_ABILITY_BACKSTAB";

	public const string PopupBar_Ability_CloakAndDagger = "POPUPBAR_ABILITY_CLOAKANDDAGGER";

	public const string PopupBar_Ability_LastPush = "POPUPBAR_ABILITY_LASTPUSH";

	public const string PopupBar_Ability_AccuracyProxy_Reduced = "POPUPBAR_ABILITY_ACCURACYPROXY_REDUCED";

	public const string PopupBar_Ability_AccuracyProxy_Restored = "POPUPBAR_ABILITY_ACCURACYPROXY_RESTORED";

	public const string PopupBar_Ability_CritChanceProxy_Reduced = "POPUPBAR_ABILITY_CRITCHANCEPROXY_REDUCED";

	public const string PopupBar_Ability_CritChanceProxy_Restored = "POPUPBAR_ABILITY_CRITCHANCEPROXY_RESTORED";

	public const string PopupBar_Ability_MovementProxy_Reduced = "POPUPBAR_ABILITY_MOVEMENTPROXY_REDUCED";

	public const string PopupBar_Ability_MovementProxy_Restored = "POPUPBAR_ABILITY_MOVEMENTPROXY_RESTORED";

	public const string PopupBar_Ability_Vault = "POPUPBAR_ABILITY_VAULT";

	public const string PopupBar_Ability_StunnedProxy_Stunned = "POPUPBAR_ABILITY_STUNNEDPROXY_STUNNED";

	public const string PopupBar_Ability_StunnedProxy_Unstunned = "POPUPBAR_ABILITY_STUNNEDPROXY_UNSTUNNED";

	public const string PopupBar_Ability_Metabolism = "POPUPBAR_ABILITY_METABOLISM";

	public const string PopupBar_Ability_Grab_Grabbed = "POPUPBAR_ABILITY_GRAB_GRABBED";

	public const string PopupBar_Ability_Grab_Released = "POPUPBAR_ABILITY_GRAB_RELEASED";

	public const string PopupBar_Ability_Plant_DamageReduce = "POPUPBAR_ABILITY_PLANT_DAMAGEREDUCE";

	public const string PopupBar_Ability_Plant_Unplanted = "POPUPBAR_ABILITY_PLANT_UNPLANTED";

	public const string PopupBar_Ability_Hitback = "POPUPBAR_ABILITY_HITBACK";

	public const string PopupBar_Ability_Hitback_Plus = "POPUPBAR_ABILITY_HITBACK_PLUS";

	public const string PopupBar_Ability_Shove_Missed = "POPUPBAR_ABILITY_SHOVE_MISSED";

	public const string PopupBar_Ability_Break = "POPUPBAR_ABILITY_BREAK";

	public const string PopupBar_Ability_Break_Missed = "POPUPBAR_ABILITY_BREAK_MISSED";

	public const string PopupBar_Ability_Disrupt_NoMore = "POPUPBAR_ABILITY_DISRUPT_NOMORE";

	public const string PopupBar_Ability_Disrupt_Disabled = "POPUPBAR_ABILITY_DISRUPT_DISABLED";

	public const string PopupBar_Ability_Disrupt_Enabled = "POPUPBAR_ABILITY_DISRUPT_ENABLED";

	public const string PopupBar_Ability_Detect = "POPUPBAR_ABILITY_DETECT";

	public const string PopupBar_Ability_Disable = "POPUPBAR_ABILITY_DISABLE";

	public const string PopupBar_Ability_Taunted = "STATUSEFFECT_Taunted_NAME_L";

	public const string PopupBar_Ability_Supressed = "STATUSEFFECT_Suppressed_NAME_L";

	public const string PopupBar_Ability_CQC = "POPUPBAR_ABILITY_CQC";

	public const string PopupBar_Ability_Frenzy = "POPUPBAR_ABILITY_FRENZY";

	public const string PopupBar_Ability_BulletTime = "POPUPBAR_ABILITY_BULLETTIME";

	public const string PopupBar_Ability_DangerZone = "POPUPBAR_ABILITY_DANGERZONE";

	public const string PopupBar_Ability_Backfist = "POPUPBAR_ABILITY_BACKFIST";

	public const string PopupBar_Ability_MultiShot = "POPUPBAR_ABILITY_MULTISHOT";

	public const string PopupBar_Ability_PointBlank = "POPUPBAR_ABILITY_POINTBLANK";

	public const string PopupBar_Ability_PiercingBullet = "POPUPBAR_ABILITY_PIERCINGBULLET";

	public const string PopupBar_Ability_Focus = "POPUPBAR_ABILITY_FOCUS";

	public const string PopupBar_Ability_FarShot_Stunned = "POPUPBAR_ABILITY_FARSHOT_STUNNED";

	public const string PopupBar_Ability_FarShot_AccDebuff = "POPUPBAR_ABILITY_FARSHOT_ACCDEBUFF";

	public const string PopupBar_Ability_Spot = "POPUPBAR_ABILITY_SPOT";

	public const string PopupBar_Ability_Overwatch = "POPUPBAR_ABILITY_OVERWATCH";

	public const string PopupBar_Ability_SecondShot = "POPUPBAR_ABILITY_SECONDSHOT";

	public const string PopupBar_A3O5_AddFluxGrenades = "POPUPBAR_A3O5_ADDFLUXGRENADES";

	public const string PopupBar_UnitAttack_Reflect = "POPUPBAR_UNITATTACK_REFLECT";

	public const string PopupBar_UnitAttack_Miss = "POPUPBAR_UNITATTACK_MISS";

	public const string PopupBar_UnitAttack_Dodged = "POPUPBAR_UNITATTACK_DODGED";

	public const string PopupBar_UnitAttack_Grazed = "POPUPBAR_UNITATTACK_GRAZED";

	public const string PopupBar_UnitAttack_Endured = "POPUPBAR_UNITATTACK_ENDURED";

	public const string PopupBar_UnitAttack_Shocked = "POPUPBAR_UNITATTACK_SHOCKED";

	public const string PopupBar_TriggeredTrap_Frag = "POPUPBAR_TRIGGEREDTRAP_FRAG";

	public const string PopupBar_TriggeredTrap_Stun = "POPUPBAR_TRIGGEREDTRAP_STUN";

	public const string PopupBar_TriggeredTrap_Flux = "POPUPBAR_TRIGGEREDTRAP_FLUX";

	public const string PopupBar_Inventory_Full = "POPUP_INVENTORY_FULL";

	public const string AbilityWheelDisabled_NoUnitsInSight = "ABILITYWHEELDISABLED_NOUNITSINSIGHT";

	public const string AbilityWheelDisabled_NotInCover = "ABILITYWHEELDISABLED_NOTINCOVER";

	public const string AbilityWheelDisabled_NoMedPacks = "ABILITYWHEELDISABLED_NOMEDPACKS";

	public const string AbilityWheelDisabled_AllUnitsFullHealth = "ABILITYWHEELDISABLED_ALLUNITSFULLHEALTH";

	public const string AbilityWheelDisabled_NoUnitsInRange = "ABILITYWHEELDISABLED_NOUNITSINRANGE";

	public const string AbilityWheelDisabled_NoFragGrenades = "ABILITYWHEELDISABLED_NOFRAGGRENADES";

	public const string AbilityWheelDisabled_NoStunGrenades = "ABILITYWHEELDISABLED_NOSTUNGRENADES";

	public const string AbilityWheelDisabled_NoFluxGrenades = "ABILITYWHEELDISABLED_NOFLUXGRENADES";

	public const string AbilityWheelDisabled_NoFragTraps = "ABILITYWHEELDISABLED_NOFRAGTRAPS";

	public const string AbilityWheelDisabled_NoStunTraps = "ABILITYWHEELDISABLED_NOSTUNTRAPS";

	public const string AbilityWheelDisabled_NoFluxTraps = "ABILITYWHEELDISABLED_NOFLUXTRAPS";

	public const string AbilityWheelDisabled_NoTraps = "ABILITYWHEELDISABLED_NOTRAPS";

	public const string AbilityWheelDisabled_AlreadyGrab = "ABILITYWHEELDISABLED_ALREADYGRAB";

	public const string AbilityWheelDisabled_EnemyNotInRange = "ABILITYWHEELDISABLED_ENEMYNOTINRANGE";

	public const string AbilityWheelDisabled_NoAbilityTargets = "ABILITYWHEELDISABLED_NOABILITYTARGETS";

	public const string AbilityWheelDisabled_NoTargets = "ABILITYWHEELDISABLED_NOTARGETS";

	public const string AbilityWheelDisabled_NoEnemiesInRadius = "ABILITYWHEELDISABLED_NOENEMIESINRADIUS";

	public const string AbilityWheelDisabled_NotInCombatMode = "ABILITYWHEELDISABLED_NOTINCOMBATMODE";

	public const string AbilityWheelDisabled_Disabled = "ABILITYWHEELDISABLED_DISABLED";

	public const string AbilityWheelDisabled_InCooldown = "ABILITYWHEELDISABLED_INCOOLDOWN";

	public const string AbilityWheelDisabled_NotEnoughAP = "ABILITYWHEELDISABLED_NOTENOUGHAP";

	public const string AbilityWheelDisabled_ReqMovement = "ABILITYWHEELDISABLED_REQMOVEMENT";

	public const string AbilityWheelDisabled_ReqAttack = "ABILITYWHEELDISABLED_REQATTACK";

	public const string AbilityWheelDisabled_NotWilla = "ABILITYWHEELDISABLED_NOTWILLA";

	public const string AbilityWheelDisabled_TrapInUse = "ABILITYWHEELDISABLED_TRAPINUSE";

	public const string AbilityWheelDisabled_DecoyInUse = "ABILITYWHEELDISABLED_DECOYINUSE";

	public const string AbilityWheelDisabled_NotWhileConcealed = "ABILITYWHEELDISABLED_NOTWHILECONCEALED";

	public const string UnitStatusBar_Decoy = "UNITSTATUSBAR_DECOY";

	public const string UIOptionsMenu_Language = "UIOPTIONSMENU_LANGUAGE";

	public const string UIOptionsMenu_Language_Apply = "UIOPTIONSMENU_LANGUAGE_APPLY";

	public const string Currency = "CURRENCY";
}
public class AMC : MonoBehaviour
{
	private static AMC _instance;

	private AudioMixer mixer;

	private AudioMixerSnapshot[] snapshots;

	private AudioMixerGroup[] mixerGroups;

	public static AMC Inst => _instance;

	private void Awake()
	{
		_instance = this;
	}

	public void LoadAudioMixer(string mixerName)
	{
		mixer = AEResources.LoadFirstResource<AudioMixer>("AudioMixers/" + mixerName);
		if (mixer == null)
		{
			UnityEngine.Debug.LogError("AudioMixerController: Audio Mixer with name: " + mixerName + " was not found");
		}
	}

	public void LoadAudioMixerSnapshots(string[] snapshotsToLoad)
	{
		if (mixer == null)
		{
			UnityEngine.Debug.LogError("AudioMixerController: Cannot load Snapshots groups when there is no valid AudioMixer loaded");
			return;
		}
		List<AudioMixerSnapshot> list = new List<AudioMixerSnapshot>();
		for (int i = 0; i < snapshotsToLoad.Length; i++)
		{
			AudioMixerSnapshot audioMixerSnapshot = mixer.FindSnapshot(snapshotsToLoad[i]);
			if (audioMixerSnapshot == null)
			{
				UnityEngine.Debug.LogError("AudioMixerController: Cannot find a snapshot with name: " + snapshotsToLoad[i]);
			}
			else
			{
				list.Add(audioMixerSnapshot);
			}
		}
		snapshots = list.ToArray();
	}

	public void LoadAudioMixerGroups(string[] groupNamesToLoad)
	{
		if (mixer == null)
		{
			UnityEngine.Debug.LogError("AudioMixerController: Cannot load AudioMixer groups when there is no valid AudioMixer loaded");
			return;
		}
		List<AudioMixerGroup> list = new List<AudioMixerGroup>();
		AudioMixerGroup[] array = mixer.FindMatchingGroups("Master");
		foreach (string value in groupNamesToLoad)
		{
			AudioMixerGroup[] array2 = array;
			foreach (AudioMixerGroup audioMixerGroup in array2)
			{
				if (audioMixerGroup.name.Equals(value))
				{
					list.Add(audioMixerGroup);
				}
			}
		}
		mixerGroups = list.ToArray();
	}

	public AudioMixerGroup GetMixerGroup(string groupName)
	{
		for (int i = 0; i < mixerGroups.Length; i++)
		{
			if (mixerGroups[i].name.Equals(groupName))
			{
				return mixerGroups[i];
			}
		}
		return null;
	}

	public bool TransitionToSnapshot(string snapshotName, float transitionTime)
	{
		for (int i = 0; i < snapshots.Length; i++)
		{
			if (snapshots[i].name.Equals(snapshotName))
			{
				snapshots[i].TransitionTo(transitionTime);
				return true;
			}
		}
		return false;
	}
}
public class CC : Singleton<CC>
{
	[HideInInspector]
	public AnimationCurve curveCameraShakeNoise;

	private AnimFloat animShakeStrength = new AnimFloat(0f);

	[HideInInspector]
	public Camera _camera;

	public Transform transformCamera { get; private set; }

	public HartmanLookAtPoint hartmanLookAtPoint { get; private set; }

	public Camera Camera => _camera;

	public void OnAwakeLR()
	{
		int num = 60;
		for (int i = 0; i < num; i++)
		{
			float num2 = (float)i / (float)(num - 1);
			float pos = num2 * (float)Math.PI * 2f;
			float value = NoiseWrapped(pos, 3f) * 0.8f + NoiseWrapped(pos, 6f) * 0.5f;
			curveCameraShakeNoise.AddKey(num2, value);
		}
		curveCameraShakeNoise.postWrapMode = WrapMode.Loop;
		transformCamera = base.transform.Find("Camera");
		hartmanLookAtPoint = GetComponent<HartmanLookAtPoint>();
		_camera = GetComponentInChildren<Camera>();
		_camera.opaqueSortMode = OpaqueSortMode.NoDistanceSort;
		_camera.transparencySortMode = TransparencySortMode.Orthographic;
		_camera.clearFlags = CameraClearFlags.Depth;
	}

	public void OnStartLR()
	{
	}

	private float NoiseWrapped(float pos, float freq)
	{
		float x = (0.5f + Mathf.Sin(pos) * 0.5f) * freq;
		float y = (0.5f + Mathf.Cos(pos) * 0.5f) * freq;
		return Mathf.Clamp01(Mathf.PerlinNoise(x, y)) * 2f - 1f;
	}

	private void Update()
	{
		float num = animShakeStrength.Update();
		Vector3 zero = Vector3.zero;
		if (num > 0f)
		{
			float num2 = curveCameraShakeNoise.Evaluate(Time.time * 1.01f + 0.01f) * num;
			float num3 = curveCameraShakeNoise.Evaluate(Time.time * 0.98f + 0.5f) * num;
			zero += transformCamera.right * num2;
			zero += transformCamera.up * num3;
		}
		if (AC.Inst.sys.isValid())
		{
			ATTRIBUTES_3D attributes = default(ATTRIBUTES_3D);
			attributes.position = transformCamera.position.toFMODVector();
			attributes.forward = transformCamera.forward.toFMODVector();
			attributes.up = transformCamera.up.toFMODVector();
			attributes.velocity = Vector3.zero.toFMODVector();
			AC.Inst.sys.setListenerAttributes(0, attributes);
		}
	}

	public void ResetOrientation()
	{
		InputTracking.Recenter();
	}

	public void Shake(float time, float strength = 0.01f, AnimationCurve curve = null)
	{
		if (curve != null)
		{
			animShakeStrength.Interpolate = (float x) => curve.Evaluate(x);
		}
		animShakeStrength.AnimateTo(strength, time);
	}

	public void StopShakeSudden()
	{
		animShakeStrength.AnimateTo(0f, 0.1f);
	}

	private void ToggleCursor()
	{
		if (!Cursor.visible)
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		else
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
	}
}
public class GC : MonoBehaviour
{
	[Flags]
	public enum State
	{
		RPG = 1,
		Combat = 2,
		Stealth = 8
	}

	[Serializable]
	private class TurnModeOutro : HagletResettable
	{
		public UnitTeam winners;

		public TurnModeOutro()
			: base(Inst.TurnModeOutroRoutine(), "Turn Mode Outro")
		{
		}

		private TurnModeOutro(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private class AbilityCache
	{
		public AbilityImplBase[] abilites;

		public int numUsed;
	}

	private static GC _instance;

	[NonSerialized]
	public HagletTrigger _OnCombatComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnTurnModeBegan = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger _OnRPGModeBegan = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger _OnStealthBroken = new HagletTrigger();

	private static readonly Color[] stateColors = new Color[4]
	{
		ColorX.RGB(30, 50, 105),
		ColorX.RGB(163, 64, 79),
		ColorX.RGB(0, 202, 255),
		ColorX.RGB(30, 50, 105)
	};

	public const float stateColorAnimTime = 0.35f;

	private const int teamsNum = 4;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_LogAIThoughts = true;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_skipAITurns;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_doNotDecrementHPplayer;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_doNotDecrementHPenemy;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_doNotDecrementAP;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_disablePassiveAbilities;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_gottaGoFast;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_unlimitedMovementRange;

	[NonSerialized]
	[ReadOnly]
	[Serializer.Exclude]
	public bool DEBUG_showTrueAccuracy;

	private bool isInCutSceneMode;

	private float endTurnDelay = 1f;

	private State state;

	[ReadOnly]
	private readonly ConstArray<Unit> unitsInWorld = new ConstArray<Unit>(64u);

	[ReadOnly]
	[Serializer.Exclude]
	private readonly ConstArray<Unit> unitsActive = new ConstArray<Unit>(16u);

	private UnitTeam[] teams = new UnitTeam[4];

	private readonly Dictionary<string, uint> dictUnitIdToIndex = new Dictionary<string, uint>();

	private UnitTeam activeTeam;

	[NonSerialized]
	public UnitTeam HACK_stealthBreakers;

	[ReadOnly]
	public HagletFlag flagEndTurnMode = new HagletFlag();

	[Serializer.Exclude]
	private CutsceneEvents cutsceneEvents = new CutsceneEvents();

	[Serializer.Exclude]
	public HagletResettable turnMode;

	[Serializer.Exclude]
	public HagletResettable cleanupActiveTeamRoutine;

	private bool cleanupisCombatEnd;

	[NonSerialized]
	[HideInInspector]
	public Material sharedUnitUIMaterials;

	public static bool HACK_missionFailed = false;

	public static bool HACK_missionComplete = false;

	public static bool HACK_multiplayerMission = false;

	private Unit closestUnit;

	private ConstArray<Unit> closestUnitNeighbours = new ConstArray<Unit>(16u);

	private ConstArray<Unit> prevClosestUnitNeighbours = new ConstArray<Unit>(16u);

	private const float timeToFadeAlpha = 0.25f;

	private const float neighbourLowAlpha = 0.25f;

	private const float closestUnitDistanceCheck = 1f;

	private const int _combatStartBarkNumber = 5;

	private PartyMemberID[] _combatStartBarkOrder = new PartyMemberID[5]
	{
		PartyMemberID.Archi,
		PartyMemberID.Noot,
		PartyMemberID.Ambrosia,
		PartyMemberID.Margot,
		PartyMemberID.Willa
	};

	private TurnModeOutro turnModeOutro;

	private Unit savedRpgLeader;

	private HagletTrigger _newRpgLeaderWasSet = new HagletTrigger();

	private static Dictionary<Type, AbilityCache> cachedAbilityImpl;

	public static GC Inst => _instance;

	public Func<bool> AnyUnitActing { get; private set; }

	public Func<bool> AnyUnitStatusBarAnimating { get; private set; }

	public Func<bool> InCutsceneMode { get; private set; }

	public int combatCheckPointIndex { get; private set; }

	public HagletEvent _OnTurnModeStarted => turnMode.started;

	public HagletTrigger NewRpgLeaderWasSet => _newRpgLeaderWasSet;

	public State GetState()
	{
		return state;
	}

	public bool IsInRPGMode()
	{
		return state == State.RPG && (RC.Inst.IsMapOpen || SaveData.resumingMission);
	}

	public bool IsInTurnMode()
	{
		return (state == State.Combat || state == State.Stealth) && (RC.Inst.IsMapOpen || SaveData.resumingMission);
	}

	public bool IsInCombatMode()
	{
		return state == State.Combat && (RC.Inst.IsMapOpen || SaveData.resumingMission);
	}

	public bool IsInStealthMode()
	{
		return state == State.Stealth && (RC.Inst.IsMapOpen || SaveData.resumingMission);
	}

	public bool IsInCutsceneMode()
	{
		return isInCutSceneMode;
	}

	public static Color GetStateBackgroundColor(State forState, bool cutsceneMode)
	{
		if (cutsceneMode)
		{
			return stateColors[2];
		}
		return forState switch
		{
			State.Combat => stateColors[1], 
			State.Stealth => stateColors[3], 
			_ => stateColors[0], 
		};
	}

	public Color GetStateBackgroundColor()
	{
		return GetStateBackgroundColor(state, isInCutSceneMode);
	}

	public bool IsInMultiplayer()
	{
		return GetTeamOfType(UnitTeam.Type.Opponent).GetMembersInWorld().Length != 0;
	}

	public void OnAwakeLR()
	{
		_instance = this;
		AnyUnitActing = IsAnyUnitActing;
		AnyUnitStatusBarAnimating = IsAnyUnitStatusBarAnimating;
		InCutsceneMode = IsInCutsceneMode;
		cutsceneEvents.OnAwakeLR();
		InitialiseAbilityCache();
		turnMode = new HagletResettable(TurnModeRoutine(), "GC TurnControl", HagletStepTime.Update, -1, 50);
		cleanupActiveTeamRoutine = new HagletResettable(CleanupActiveTeamRoutine(), "GC CleanupTeam");
		turnModeOutro = new TurnModeOutro();
	}

	public void OnMissionSceneLoaded(MR mr)
	{
	}

	public void OnMissionStart(MR mr)
	{
		HACK_missionFailed = (HACK_missionComplete = false);
		for (uint num = 0u; num < 4; num++)
		{
			ITeamController inst = Singleton<PC>.Inst;
			if (!UnitTeam.IsPlayerControlled[num])
			{
				inst = Singleton<AIC>.Inst;
			}
			UnitTeam unitTeam = (teams[num] = new UnitTeam((UnitTeam.Type)num, inst));
			unitTeam.controller.OnTeamInitialize(unitTeam);
			unitTeam.IsFirstTurn = true;
		}
		UnitSpawnBase[] componentsInChildren = mr.GetComponentsInChildren<UnitSpawnBase>(includeInactive: false);
		foreach (UnitSpawnBase unitSpawnBase in componentsInChildren)
		{
			if (unitSpawnBase.teamType != 0 || (long)(unitSpawnBase as UnitSpawn).memberInLoadout < (long)Party.Inst.GetContributedPartyMembers().Length)
			{
				for (int j = 0; j < unitSpawnBase.GetSpawnCount(); j++)
				{
					Unit obj = unitSpawnBase.Spawn(j);
					unitsInWorld.Add(obj);
				}
			}
		}
		savedRpgLeader = GetTeamOfType(UnitTeam.Type.Player).GetMemberAtIndex(0);
		HACK_multiplayerMission = IsInMultiplayer();
		for (uint num2 = 0u; num2 < unitsInWorld.Length; num2++)
		{
			Unit unit = unitsInWorld[num2];
			string generatedID = unit.generatedID;
			dictUnitIdToIndex.Add(generatedID, num2);
			unitsInWorld[num2].Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		}
	}

	public void CallSpawnEvents()
	{
		for (int i = 0; i < unitsInWorld.Length; i++)
		{
			Unit unit = unitsInWorld[i];
			if ((bool)unit.spawnPoint)
			{
				ISpawnEvents[] componentsInChildren = unit.spawnPoint.GetComponentsInChildren<ISpawnEvents>();
				for (int j = 0; j < componentsInChildren.Length; j++)
				{
					componentsInChildren[j].OnSpawned(unit);
				}
			}
		}
	}

	public void OnMissionResume(MR mr)
	{
		RC.Inst.BackgroundColorRGBAnimate(GetStateBackgroundColor(), 0.35f, Singleton<MC>.Inst.GetActiveMap());
	}

	public void OnMissionSceneUnloaded(MR mr)
	{
		MusicController.Inst.Stop();
		if (unitsInWorld != null)
		{
			for (int i = 0; i < unitsInWorld.Length; i++)
			{
				unitsInWorld[i].OnDespawn();
			}
		}
		for (uint num = 0u; num < 4; num++)
		{
			if (teams[num] != null)
			{
				teams[num].RemoveAll();
			}
		}
		unitsInWorld.ClearToDefault();
		unitsActive.ClearToDefault();
		dictUnitIdToIndex.Clear();
		RC.Inst.BackgroundColorRGBAnimate(stateColors[0], 0.35f);
	}

	private IEnumerator<HagletYieldTerm> TurnModeRoutine()
	{
		turnModeOutro.winners = null;
		activeTeam.OnTurnStarted.Trigger();
		yield return null;
		if (!flagEndTurnMode)
		{
			Singleton<MC>.Inst.GetActiveMap().OnTurnModeEnter();
			OnTurnModeBegan.Trigger();
			yield return Wait.While(AnyUnitActing);
			HagletYieldTerm waitForAnimInCombat = default(HagletYieldTerm);
			for (uint num = 0u; num < 4; num++)
			{
				teams[num].controller.OnTurnModeEnter();
			}
			uint num2 = 0u;
			for (uint length = unitsActive.Length; num2 < length; num2++)
			{
				Unit unit = unitsActive[num2];
				if ((unit.teamType == UnitTeam.Type.Player || unit.teamType == UnitTeam.Type.Enemy || unit.teamType == UnitTeam.Type.Opponent) && unit.unitModel.animName != unit.unitModel.GetAnimName(UnitModel.AnimID.CombatIdle))
				{
					waitForAnimInCombat &= (HagletYieldTerm)unit.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
				}
			}
			yield return waitForAnimInCombat | Wait.ForSeconds(1.5f);
			uint num3 = 0u;
			for (uint length2 = unitsActive.Length; num3 < length2; num3++)
			{
				Unit unit2 = unitsActive[num3];
				unit2.OnTurnModeEnter();
				unit2.APRefill();
				unit2.UpdateIdleAnim();
			}
			ShowAllUnitStatusBars();
			if (Routine.IsSkipping())
			{
				turnModeOutro.winners = GetTeamOfType(UnitTeam.Type.Player);
				if (!SaveData.resumingMission)
				{
					CombatSkipKillTeam(UnitTeam.Type.Enemy);
					yield return Wait.ForChildren;
				}
			}
			else
			{
				while (true)
				{
					yield return null;
					if (!MR.Inst.IsSkipping() && (Singleton<MC>.Inst.transitioning || (bool)turnModeOutro.running || IsAnyUnitActing()))
					{
						continue;
					}
					ConstArray<Unit> activeUnits = GetUnitsActive();
					for (int j = 0; j < activeUnits.sLength; j++)
					{
						if (activeUnits[j].IsSteppedOut)
						{
							activeUnits[j].StartStepBackIn();
						}
					}
					if (HACK_stealthBreakers != null && GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers().Length != 0)
					{
						AC.Inst.PlayOneShot2D("event:/sfx/ui/stealth into combat");
						yield return cutsceneEvents.StealthBrokenCutscene();
						Inst._CombatBegin(HACK_stealthBreakers.type);
						_OnStealthBroken.Trigger();
						HACK_stealthBreakers = null;
						continue;
					}
					Map mapAtStartOfTurn = Singleton<MC>.Inst.GetActiveMap();
					if (activeTeam.GetTeamLeader() != null)
					{
						mapAtStartOfTurn.VFXTiles.UnitSelectedShow(activeTeam.GetTeamLeader(), forcePing: true);
						UIStatusEffects.Inst.SetTarget(activeTeam.GetTeamLeader());
					}
					if (GetNextActiveTeam(activeTeam) == activeTeam)
					{
						turnModeOutro.winners = activeTeam;
						flagEndTurnMode.Set();
						break;
					}
					yield return activeTeam.controller.TakeAction();
					CheckAndFadeStatusBars();
					if (Routine.IsSkipping())
					{
						turnModeOutro.winners = GetTeamOfType(UnitTeam.Type.Player);
						CombatSkipKillTeam(UnitTeam.Type.Enemy);
						CombatSkipKillTeam(UnitTeam.Type.Opponent);
						yield return Wait.ForChildren;
						flagEndTurnMode.Set();
						yield return null;
					}
					if ((bool)flagEndTurnMode || mapAtStartOfTurn != Singleton<MC>.Inst.GetActiveMap())
					{
						break;
					}
					yield return null;
					UnitTeam nextActiveTeam = GetNextActiveTeam(activeTeam);
					if (nextActiveTeam == GetActiveTeam() || Singleton<MC>.Inst.transitioning)
					{
						turnModeOutro.winners = GetActiveTeam();
					}
					else if (nextActiveTeam == GetNextActiveTeam(nextActiveTeam))
					{
						turnModeOutro.winners = nextActiveTeam;
					}
					else if (activeTeam.FindNextUnitWithAP() == null)
					{
						yield return Wait.ForSeconds(endTurnDelay);
						yield return CleanupActiveTeam(isCombatEnd: false);
						activeTeam = nextActiveTeam;
						UpdateAllUnitIdles();
						activeTeam.OnTurnStarted.Trigger();
						yield return null;
						if ((bool)flagEndTurnMode)
						{
							break;
						}
						activeTeam.APRefill();
						UIStatusBar.Inst.Refresh();
						if (activeTeam.type != 0)
						{
							UIStatusEffects.Inst.HideAll();
						}
						else
						{
							UIStatusEffects.Inst.ShowAll();
						}
						ConstArray<Unit> teamMembers = activeTeam.GetActiveMembers();
						for (uint i = 0u; i < teamMembers.Length; i++)
						{
							Unit member = teamMembers[i];
							member.OnTurnStart();
							yield return Wait.ForChildren;
							yield return Wait.While(member.popupBar.IsPopUpVisable);
						}
						Unit leader = Inst.GetActiveUnit();
						leader.map.VFXTiles.UnitSelectedHide();
						leader.map.VFXTiles.UnitSelectedShow(leader);
					}
					if (turnModeOutro.winners != null)
					{
						yield return Wait.ForSeconds(endTurnDelay);
						if (turnModeOutro.winners.type != UnitTeam.Type.Enemy)
						{
							yield return Routine.Start(turnModeOutro);
						}
						flagEndTurnMode.Set();
						break;
					}
				}
			}
		}
		if (turnModeOutro.winners == null || turnModeOutro.winners.type == UnitTeam.Type.Player)
		{
			yield return Singleton<PC>.Inst.ReviveAllMembers();
			if (HAGIS.IsAutoHealingEnabled)
			{
				GetTeamOfType(UnitTeam.Type.Player).HPRefill();
			}
			if (turnModeOutro.winners == null)
			{
				SaveData.OnCombatCancelled();
			}
			else
			{
				SaveData.OnCombatWon();
			}
			yield return Wait.ForChildren;
		}
		flagEndTurnMode.Clear();
		yield return CleanupActiveTeam(isCombatEnd: true);
		HideUnitUI();
		Singleton<MC>.Inst.GetActiveMap().OnTurnModeExit();
		uint num4 = 0u;
		for (uint length3 = unitsInWorld.Length; num4 < length3; num4++)
		{
			Unit unit3 = unitsInWorld[num4];
			unit3.OnTurnModeEnd();
			unit3.OnCombatModeEnd();
		}
		int k = 0;
		for (int num5 = teams.Length; k < num5; k++)
		{
			teams[k].abilities.RemoveAllProxies();
			teams[k].UpdateTeamIdleAnims();
		}
		for (int l = 0; l < teams.Length; l++)
		{
			teams[l].controller.OnTurnModeExit();
		}
		if (Routine.IsSkipping())
		{
			SetState(State.RPG);
		}
	}

	public void _FlagEndOfTurnMode()
	{
		flagEndTurnMode.Set();
	}

	private void Update()
	{
		if (unitsInWorld == null || HACK_missionFailed || !IsInTurnMode())
		{
			return;
		}
		if (!turnMode.running)
		{
			if (turnModeOutro.winners != null && turnModeOutro.winners.type != 0)
			{
				LR.Inst.SetPauseState(paused: true, withPauseMenu: false);
				HAGIS.MissionFailed();
			}
			else
			{
				SetState(State.RPG);
			}
			turnModeOutro.winners = null;
		}
		else
		{
			UpdateUnitStatusBarRender();
		}
	}

	public void CutsceneBegin()
	{
		isInCutSceneMode = true;
		if (Singleton<MC>.Inst.GetActiveMap() != null)
		{
			Singleton<MC>.Inst.GetActiveMap().VFXTiles.UnitSelectedHide();
		}
	}

	public void CutsceneEnd()
	{
		isInCutSceneMode = false;
		if (Inst.GetRPGLeader() != null && Singleton<MC>.Inst.GetActiveMap() != null)
		{
			Singleton<MC>.Inst.GetActiveMap().VFXTiles.UnitSelectedShow(Inst.GetRPGLeader(), forcePing: true);
		}
	}

	public void _CombatBegin(UnitTeam.Type startingTeam, bool playOpeningBark = true)
	{
		activeTeam = teams[(int)startingTeam];
		SetState(State.Combat);
		if (playOpeningBark)
		{
			PlayCombatStartBark();
		}
		MusicController.Inst.SetIntensity(0.12f);
	}

	public void _CombatBeginWaves(UnitTeam.Type startingTeam)
	{
		Singleton<MC>.Inst.GetActiveMap().WavesEnableAllWaveSpawns();
		_CombatBegin(startingTeam);
	}

	public void StealthBegin()
	{
		activeTeam = teams[0];
		SetState(State.Stealth);
	}

	public void HideUnitUI()
	{
		int num = 4;
		while (--num >= 0)
		{
			UnitTeam unitTeam = teams[num];
			ConstArray<Unit> activeMembers = unitTeam.GetActiveMembers();
			for (uint num2 = 0u; num2 < activeMembers.Length; num2++)
			{
				activeMembers[num2].HideStatusBar();
				activeMembers[num2].HideMovementArea();
			}
		}
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		activeMap.VFXTiles.UnitAttackHighlightHide();
		activeMap.VFXTiles.CoverPredictorHide();
	}

	public void PlayCombatStartBark()
	{
		ConstArray<Unit> activeMembers = GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
		Unit unit = null;
		for (int i = 0; i < 5; i++)
		{
			for (int j = 0; j < activeMembers.Length; j++)
			{
				if (activeMembers[j].charData.partyMemberID == _combatStartBarkOrder[i])
				{
					unit = activeMembers[j];
					break;
				}
			}
			if (unit != null)
			{
				break;
			}
		}
		if (!(unit != null))
		{
			return;
		}
		GangType gangTypeForTeam = GetTeamOfType(UnitTeam.Type.Enemy).GetGangTypeForTeam();
		if (unit.charData.partyMemberID == PartyMemberID.Archi)
		{
			switch (gangTypeForTeam)
			{
			case GangType.Shiners:
				unit.PlayBark(BarkTypes.ArchiCombatStartsShiners);
				break;
			case GangType.Fusels:
				unit.PlayBark(BarkTypes.ArchiCombatStartsFusels);
				break;
			case GangType.Compilers:
				unit.PlayBark(BarkTypes.ArchiCombatStartsCompilers);
				break;
			case GangType.Tuckers:
				unit.PlayBark(BarkTypes.ArchiCombatStartsTuckers);
				break;
			case GangType.Underclocks:
				unit.PlayBark(BarkTypes.ArchiCombatStartsUnderclocks);
				break;
			case GangType.Deusoft:
				unit.PlayBark(BarkTypes.ArchiCombatStartsDeusoft);
				break;
			case GangType.Chumleys:
				unit.PlayBark(BarkTypes.ArchiCombatStartsChumleys);
				break;
			}
		}
		else if (gangTypeForTeam.IsHumanGang())
		{
			unit.PlayBark(BarkTypes.GangCombatStarts);
		}
		else if (gangTypeForTeam.IsDroidGang())
		{
			unit.PlayBark(BarkTypes.DroidCombatStarts);
		}
	}

	private HagletYieldTerm CleanupActiveTeam(bool isCombatEnd)
	{
		if (activeTeam == null)
		{
			return null;
		}
		cleanupisCombatEnd = isCombatEnd;
		return Routine.Start(cleanupActiveTeamRoutine);
	}

	private IEnumerator<HagletYieldTerm> CleanupActiveTeamRoutine()
	{
		activeTeam.IsFirstTurn = false;
		ConstArray<Unit> members = activeTeam.GetActiveMembers();
		for (uint i = 0u; i < members.Length; i++)
		{
			members[i].OnTurnEnd(cleanupisCombatEnd);
			yield return Wait.ForChildren;
			yield return Wait.While(members[i].popupBar.IsPopUpVisable);
		}
		activeTeam.controller.OnTurnEnd();
		UIAbilityWheel.Inst.HideAll();
		activeTeam = null;
	}

	public int GetTeamIndex(UnitTeam team)
	{
		return (int)team.type;
	}

	public UnitTeam GetNextActiveTeam(UnitTeam startTeam)
	{
		int num = GetTeamIndex(startTeam);
		for (int i = 0; i < 4; i++)
		{
			num = (num + 1) % 4;
			UnitTeam unitTeam = teams[num];
			if (unitTeam.type == UnitTeam.Type.NPC)
			{
				continue;
			}
			ConstArray<Unit> activeMembers = unitTeam.GetActiveMembers();
			for (int j = 0; j < activeMembers.Length; j++)
			{
				if (activeMembers[j].IsAlive() && (!activeMembers[j].charData.environmental || activeMembers[j].teamType == UnitTeam.Type.Player))
				{
					return unitTeam;
				}
			}
		}
		Singleton<PC>.Inst.ReviveAllMembers();
		return GetTeamOfType(UnitTeam.Type.Player);
	}

	public void SetState(State newState)
	{
		State state = this.state;
		switch (state)
		{
		case State.RPG:
		{
			for (uint num = 0u; num < 4; num++)
			{
				teams[num].controller.OnRPGModeExit((UnitTeam.Type)num);
			}
			break;
		}
		}
		this.state = newState;
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		if ((bool)activeMap)
		{
			activeMap.OnChangedGameState();
		}
		UIStatusBar.Inst.Refresh();
		if (IsInCutsceneMode())
		{
			CutsceneEnd();
		}
		RC.Inst.BackgroundColorRGBAnimate(GetStateBackgroundColor(), 0.35f, activeMap);
		switch (newState)
		{
		case State.RPG:
		{
			combatCheckPointIndex = -1;
			MusicController.Inst.ApplyAmbienceSnapshot(value: false);
			Singleton<PC>.Inst.SetSelectedUnit(savedRpgLeader ?? GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers()[0]);
			if (state == State.Combat || state == State.Stealth)
			{
				_OnCombatComplete.Trigger();
				_OnRPGModeBegan.Trigger();
			}
			for (uint num3 = 0u; num3 < 4; num3++)
			{
				teams[num3].controller.OnRPGModeEnter((UnitTeam.Type)num3);
			}
			UpdateAllUnitIdles();
			break;
		}
		case State.Combat:
			combatCheckPointIndex = SaveData.mission.checkPointCount - 1;
			MusicController.Inst.ApplyAmbienceSnapshot(value: true);
			if (state != State.Stealth)
			{
				flagEndTurnMode.Clear();
				StartTurnModeRoutine();
			}
			break;
		case State.Stealth:
		{
			uint num2 = 0u;
			for (uint length = unitsActive.Length; num2 < length; num2++)
			{
				unitsActive[num2].OnStealthModeBegin();
			}
			MusicController.Inst.ApplyAmbienceSnapshot(value: true);
			flagEndTurnMode.Clear();
			StartTurnModeRoutine();
			break;
		}
		}
	}

	private void StartTurnModeRoutine()
	{
		Routine.Start(turnMode, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public void ForceSubmitTurn()
	{
		ConstArray<Unit> activeMembers = activeTeam.GetActiveMembers();
		uint num = 0u;
		for (uint length = activeMembers.Length; num < length; num++)
		{
			Unit unit = activeMembers[num];
			unit.APDecrement(unit.AP, notifyAbilites: false);
		}
	}

	private void CombatSkipKillTeam(UnitTeam.Type type)
	{
		ConstArray<Unit> activeMembers = GetTeamOfType(type).GetActiveMembers();
		uint num = 0u;
		for (uint length = activeMembers.Length; num < length; num++)
		{
			Unit unit = activeMembers[num];
			if (!unit.charData.environmental && (LR.HACK_tutorialMode || unit.IsTargetable || unit.IsCloaked) && unit.abilities.AbilityGetByType<Ability_DEBUG_CantDieWontKill>() == null && unit.abilities.AbilityGetByType<Ability_DEBUG_CantDie>() == null)
			{
				unit.HPDecrement(unit.HP);
			}
		}
	}

	public HagletYieldTerm DistractionUnitNotFound(Unit enemyUnit)
	{
		return cutsceneEvents.StealthUnitNotFoundCutscene(enemyUnit);
	}

	private IEnumerator<HagletYieldTerm> TurnModeOutroRoutine()
	{
		Singleton<PC>.Inst.SetSelectedUnit(savedRpgLeader ?? GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers()[0]);
		yield return turnModeOutro.winners.MoveTeamToDefaultPositions(clearActionTilesOnly: true);
	}

	public Unit GetActiveUnit()
	{
		if (activeTeam == null)
		{
			return null;
		}
		return activeTeam.controller.GetLeader();
	}

	public void UpdateAllUnitIdles()
	{
		uint num = 0u;
		for (uint length = unitsActive.Length; num < length; num++)
		{
			unitsActive[num].UpdateIdleAnim();
		}
	}

	public void SetRPGLeader(Unit newLeader)
	{
		if (IsInRPGMode())
		{
			Singleton<PC>.Inst.SetSelectedUnit(newLeader);
			SC.Inst.SetLeader(newLeader);
		}
		if (savedRpgLeader != newLeader)
		{
			_newRpgLeaderWasSet.Trigger();
		}
		savedRpgLeader = newLeader;
	}

	public Unit GetRPGLeader()
	{
		return savedRpgLeader;
	}

	public UnitTeam.Type GetActiveTeamType()
	{
		return (activeTeam != null) ? activeTeam.type : UnitTeam.Type.Player;
	}

	public UnitTeam GetActiveTeam()
	{
		return activeTeam;
	}

	public UnitTeam GetTeamOfType(UnitTeam.Type type)
	{
		return teams[(int)type];
	}

	public bool IsAnyUnitActing()
	{
		for (int i = 0; i < unitsActive.Length; i++)
		{
			if (unitsActive[i].IsActing)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsAnyUnitStatusBarAnimating()
	{
		for (int i = 0; i < unitsActive.Length; i++)
		{
			if (unitsActive[i].statusBar.IsAnimating)
			{
				return true;
			}
		}
		return false;
	}

	public void OnUnitDeath(Unit unit)
	{
		UnitTeam team = unit.GetTeam();
		unit.teamController.OnUnitDeath(unit);
		if (team.type == UnitTeam.Type.Enemy && team.GetActiveMembers().Length == 0)
		{
			Map activeMap = Singleton<MC>.Inst.GetActiveMap();
			if (activeMap.WaveCombatAllowed && activeMap.WaveIndex < activeMap.WaveCount)
			{
				activeMap.WavesSpawnWave();
				GetTeamOfType(UnitTeam.Type.Player).APRefill();
			}
		}
	}

	public void ShowAllUnitStatusBars()
	{
		uint num = 0u;
		for (uint length = unitsActive.Length; num < length; num++)
		{
			Unit unit = unitsActive[num];
			unit.ShowStatusBar();
		}
		CheckAndFadeStatusBars();
	}

	public void HideAllUnitStatusBars()
	{
		uint num = 0u;
		for (uint length = unitsActive.Length; num < length; num++)
		{
			Unit unit = unitsActive[num];
			unit.HideStatusBar();
		}
	}

	public void CheckAndFadeStatusBars()
	{
		uint num = 0u;
		for (uint length = unitsActive.Length; num < length; num++)
		{
			Unit unit = unitsActive[num];
			if (SC.Inst.unitHighlighted != unit && unit.HasNeighboursCombat)
			{
				FadeOutUnit(unit);
			}
			else
			{
				FadeInUnit(unit);
			}
		}
	}

	public Unit TryGetUnitByPartyMember(PartyMember member)
	{
		ConstArray<Unit> membersInWorld = GetTeamOfType(UnitTeam.Type.Player).GetMembersInWorld();
		for (int num = membersInWorld.sLength - 1; num >= 0; num--)
		{
			if (membersInWorld[num].charData.partyMemberID == member.characterData.partyMemberID && membersInWorld[num].generatedID != "Decoy")
			{
				return membersInWorld[num];
			}
		}
		return null;
	}

	public Unit GetUnitAtCoord(v2i coord, bool includeDead = false)
	{
		int num = (int)unitsActive.Length;
		while (--num >= 0)
		{
			Unit unit = unitsActive[num];
			if (unit.coord == coord && !unit.moving && unit.gameObject.activeInHierarchy && (includeDead || unit.IsAlive()))
			{
				return unit;
			}
		}
		return null;
	}

	public Unit GetUnitAtCoord(v2i coord, Func<Unit, bool> predicate)
	{
		int num = (int)unitsActive.Length;
		while (--num >= 0)
		{
			Unit unit = unitsActive[num];
			if (unit.coord == coord && !unit.moving && unit.gameObject.activeInHierarchy && predicate(unit))
			{
				return unit;
			}
		}
		return null;
	}

	public Unit GetUnitAtCoordOnMap(Map map, v2i coord, bool includeDead = false)
	{
		int num = (int)unitsInWorld.Length;
		while (--num >= 0)
		{
			Unit unit = unitsInWorld[num];
			if (unit.map == map && unit.coord == coord && !unit.moving && unit.gameObject.activeInHierarchy && (includeDead || unit.IsAlive()))
			{
				return unit;
			}
		}
		return null;
	}

	public ConstArray<Unit> GetUnitsAllInWorld()
	{
		return unitsInWorld;
	}

	public ConstArray<Unit> GetUnitsActive()
	{
		return unitsActive;
	}

	public Unit GetUnitWithId(string name, bool optional = false)
	{
		if (optional)
		{
			if (dictUnitIdToIndex.TryGetValue(name, out var value))
			{
				return unitsInWorld[value];
			}
			return null;
		}
		return unitsInWorld[dictUnitIdToIndex[name]];
	}

	public Unit TryGetUnitWithId(string name)
	{
		uint value = 0u;
		if (dictUnitIdToIndex.TryGetValue(name, out value))
		{
			return unitsInWorld[value];
		}
		return null;
	}

	public string TryGetUnitDisplayName(string unitId)
	{
		if (!string.IsNullOrEmpty(unitId) && dictUnitIdToIndex.TryGetValue(unitId, out var value))
		{
			return unitsInWorld[value].charData.charName;
		}
		return "Unit";
	}

	public HagletYieldTerm ShowAllUnitsOnMap(UnitTeam.Type? ignoreTeam = null, bool onlyShowEnvironmental = false)
	{
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		activeMap.IsUnitsVisible = true;
		for (uint num = 0u; num < unitsInWorld.Length; num++)
		{
			Unit unit = unitsInWorld[num];
			if ((unit.teamType != ignoreTeam.GetValueOrDefault() || !ignoreTeam.HasValue) && unit.gameObject.activeInHierarchy && !(unit.map != activeMap) && (!onlyShowEnvironmental || unit.charData.environmental))
			{
				unit.Show();
			}
		}
		if (IsInMultiplayer())
		{
			for (int i = 0; i < unitsActive.Length; i++)
			{
				Unit unit2 = unitsActive[i];
				if (unit2.HP != 0)
				{
					unit2.ShowStatusBar();
				}
			}
		}
		return Wait.ForChildren;
	}

	public HagletYieldTerm HideAllUnitsOnMap(bool removeFromActiveUnitList, bool immediate = false)
	{
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		activeMap.IsUnitsVisible = false;
		for (uint num = 0u; num < unitsInWorld.Length; num++)
		{
			Unit unit = unitsInWorld[num];
			if (removeFromActiveUnitList)
			{
				Inst._RemoveActiveUnit(unit);
			}
			if (!(unit.map != activeMap))
			{
				unit.Hide(makeInactive: false, immediate ? Unit.HologramAnim.IMMEDIATE : Unit.HologramAnim.DEFAULT);
			}
		}
		return Wait.ForChildren;
	}

	public bool AnyUnitsVisible()
	{
		for (uint num = 0u; num < unitsInWorld.Length; num++)
		{
			if (unitsInWorld[num].IsShown)
			{
				return true;
			}
		}
		return false;
	}

	public void _AddActiveUnit(Unit unit)
	{
		unitsActive.Add(unit);
		unit.GetTeam().AddActiveMember(unit);
	}

	public void _RemoveActiveUnit(Unit unit)
	{
		unitsActive.RemoveStable(unit);
		unit.GetTeam().RemoveActiveMember(unit);
	}

	public static void InitialiseAbilityCache()
	{
		cachedAbilityImpl = new Dictionary<Type, AbilityCache>();
		Type[] types = typeof(AbilityImplBase).Assembly.GetTypes();
		for (int i = 0; i < types.Length; i++)
		{
			if (types[i].IsSubclassOf(typeof(AbilityImplBase)))
			{
				AbilityCache abilityCache = new AbilityCache();
				Type type = types[i];
				abilityCache.abilites = new AbilityImplBase[64];
				AbilityMeta meta = PartyLevelLUT.abilityTypesToMetas[types[i]];
				for (int j = 0; j < abilityCache.abilites.Length; j++)
				{
					abilityCache.abilites[j] = (AbilityImplBase)Activator.CreateInstance(types[i]);
					abilityCache.abilites[j].meta = meta;
				}
				cachedAbilityImpl[types[i]] = abilityCache;
			}
		}
	}

	public static AbilityImplBase GetAbilityInstance(Type type, Unit owner, AbilityImplBase caster)
	{
		AbilityCache abilityCache = cachedAbilityImpl[type];
		AbilityImplBase abilityImplBase = abilityCache.abilites[abilityCache.numUsed++];
		abilityImplBase.caster = caster;
		abilityImplBase.owner = owner;
		return abilityImplBase;
	}

	public static T GetAbilityInstance<T>(Unit owner, AbilityImplBase caster) where T : AbilityImplBase
	{
		return (T)GetAbilityInstance(typeof(T), owner, caster);
	}

	public static void ReturnAbilityInstance(AbilityImplBase instance)
	{
		Type type = instance.GetType();
		AbilityCache abilityCache = cachedAbilityImpl[type];
		for (int i = 0; i < abilityCache.numUsed; i++)
		{
			if (instance == abilityCache.abilites[i])
			{
				abilityCache.abilites[i] = abilityCache.abilites[--abilityCache.numUsed];
				abilityCache.abilites[abilityCache.numUsed] = instance;
				break;
			}
		}
	}

	public void ActivateGadget(bool isTrap, GadgetType gadgetType, v2i source, ConstArray<Unit> targets, AbilityImplBase caster)
	{
		Map map = caster.owner.map;
		switch (gadgetType)
		{
		case GadgetType.FRAG:
		{
			PSC.Inst.Play(ParticleTypes.BarrelExplosion, map.CoordToLocalPos(source), Quaternion.identity, new Vector3(1f, 1f, 1f), map.transform);
			Singleton<MC>.Inst.MapShake.ShakeOneShot(0.5f);
			AC.Inst.PlayOneShot2D("event:/sfx/character/common/attack/grenade explosion");
			for (int j = 0; j < targets.Length; j++)
			{
				caster.owner.DamageAttackTarget(targets[j], Combat.HitType.Hit, 4);
			}
			break;
		}
		case GadgetType.STUN:
		{
			PSC.Inst.Play(ParticleTypes.Ground_Pound, map.CoordToLocalPos(source), Quaternion.identity, new Vector3(1f, 1f, 1f), map.transform);
			Singleton<MC>.Inst.MapShake.ShakeOneShot(0.25f);
			AC.Inst.PlayOneShot2D("event:/sfx/character/common/attack/grenade explosion");
			for (int k = 0; k < targets.Length; k++)
			{
				Ability_Stunned_Proxy ability_Stunned_Proxy = targets[k].abilities.Add<Ability_Stunned_Proxy>(caster, isUpgraded: false);
				if (targets[k].teamType == caster.owner.teamType)
				{
					ability_Stunned_Proxy.friendlyFire = true;
					if (isTrap)
					{
						ability_Stunned_Proxy.isTrap = true;
					}
				}
			}
			break;
		}
		case GadgetType.STATIC:
			break;
		case GadgetType.DUD:
			break;
		case GadgetType.FLUX:
		case GadgetType.FAKEFLUX:
		{
			PSC.Inst.Play(ParticleTypes.Shockwave, map.CoordToLocalPos(source), Quaternion.identity, new Vector3(1f, 1f, 1f), map.transform);
			Singleton<MC>.Inst.MapShake.ShakeOneShot(0.5f);
			AC.Inst.PlayOneShot2D("event:/sfx/ability/experimental tech");
			for (int i = 0; i < targets.Length; i++)
			{
				if (gadgetType == GadgetType.FAKEFLUX)
				{
					PSC.Inst.Play(ParticleTypes.Break, map, targets[i].coord);
					targets[i].unitModel.Play(targets[i].unitModel.GetAnimName(UnitModel.AnimID.CombatHit), looping: true);
				}
				else if (isTrap && GetTeamOfType(targets[i].teamType).GetActiveMembers().Length > 1 && 50.PercentChance())
				{
					PSC.Inst.Play(ParticleTypes.Break, map, targets[i].coord);
					targets[i].popupBar.Enqueue("POPUPBAR_FLUX_HACK");
					Ability_Break_Proxy ability_Break_Proxy = targets[i].abilities.Add<Ability_Break_Proxy>(caster, isUpgraded: false);
					ability_Break_Proxy.turnCounter = 3;
					ability_Break_Proxy.originalTeamType = targets[i].teamType;
					targets[i].SetTeamType(caster.owner.teamType);
				}
				else
				{
					targets[i].Kill();
				}
			}
			break;
		}
		}
	}

	private void UpdateUnitStatusBarRender()
	{
		bool flag = false;
		v2i? displayCoord = SC.Inst.displayCoord;
		if (displayCoord.HasValue)
		{
			for (int i = 0; i < unitsActive.Length; i++)
			{
				Unit unit = unitsActive[i];
				if (unit.statusBar.IsShown)
				{
					int num = Mathf.Abs(displayCoord.Value.x - unit.coord.x) + Mathf.Abs(displayCoord.Value.y - unit.coord.y);
					int newOrder = (32 - num) * 4;
					unit.statusBar.UpdateRenderOrder(newOrder);
					if (!flag)
					{
						flag = unit.IsAttacking || (bool)unit.moving || unit.IsDying || unit.IsTeleporting;
					}
				}
			}
		}
		if (flag)
		{
			return;
		}
		Unit unit2 = SC.Inst.unitHighlighted;
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		float num2 = float.MaxValue;
		if (unit2 == null)
		{
			Vector3 position = IC.Inst.transform.position;
			Vector3 forward = IC.Inst.transform.forward;
			if (new Plane(activeMap.transform.up, activeMap.transform.position).Raycast(new Ray(position, forward), out var enter))
			{
				Vector3 vector = activeMap.WorldPosToLocalPos(position + forward * enter);
				for (int j = 0; j < unitsActive.Length; j++)
				{
					Unit unit3 = unitsActive[j];
					if (!unit3.statusBar.IsShown)
					{
						continue;
					}
					Vector3 vector2 = activeMap.CoordToLocalPos(unit3.coord);
					float num3 = (vector - vector2).magnitude * 0.25f;
					if (!(num3 < num2))
					{
						continue;
					}
					bool flag2 = false;
					for (int k = 0; k < unitsActive.Length; k++)
					{
						Unit unit4 = unitsActive[k];
						if (j != k && unit4.statusBar.IsShown)
						{
							int num4 = unit4.coord.x - unit3.coord.x;
							int num5 = unit4.coord.y - unit3.coord.y;
							if (num4 >= -1 && num4 <= 1 && num5 >= -1 && num5 <= 1)
							{
								flag2 = true;
								break;
							}
						}
					}
					if (flag2)
					{
						num2 = num3;
						unit2 = unit3;
					}
				}
			}
		}
		else
		{
			num2 = 0f;
		}
		if (unit2 != null && (closestUnit == null || closestUnit.name != unit2.name))
		{
			if (closestUnit != null && closestUnit.HasNeighboursCombat)
			{
				FadeOutUnit(closestUnit);
			}
			if (num2 < 1f)
			{
				FadeInUnit(unit2);
				closestUnit = unit2;
			}
			else
			{
				closestUnit = null;
			}
		}
		else if (closestUnit != null && num2 >= 1f && closestUnit.HasNeighboursCombat)
		{
			FadeOutUnit(closestUnit);
			closestUnit = null;
		}
	}

	public void FadeInUnit(Unit unit)
	{
		float alpha = unit.statusBar.GetAlpha();
		float actualFadeInTime = GetActualFadeInTime(alpha);
		unit.statusBar.StartFade(1f, actualFadeInTime);
	}

	public void FadeOutUnit(Unit unit)
	{
		float alpha = unit.statusBar.GetAlpha();
		float actualFadeOutTime = GetActualFadeOutTime(alpha);
		unit.statusBar.StartFade(0.25f, actualFadeOutTime);
	}

	private float GetActualFadeInTime(float current)
	{
		return (1f - current) / 0.75f * 0.25f;
	}

	private float GetActualFadeOutTime(float current)
	{
		return (current - 0.25f) / 0.75f * 0.25f;
	}
}
public enum GadgetType
{
	FRAG,
	STUN,
	STATIC,
	DUD,
	FLUX,
	FAKEFLUX
}
public class GSC
{
	public class PlayerPrefsX
	{
		public static void SetBool(string name, bool value)
		{
			PlayerPrefs.SetInt(name, value ? 1 : 0);
		}

		public static bool GetBool(string name)
		{
			return PlayerPrefs.GetInt(name) == 1;
		}

		public static bool GetBool(string name, bool defaultValue)
		{
			if (PlayerPrefs.HasKey(name))
			{
				return GetBool(name);
			}
			return defaultValue;
		}
	}

	private static GSC _instance;

	private static readonly string kKeyIsFirstPlaythrough = "isFirstPlaythrough";

	private bool _isLoaded;

	private bool _isFirstPlaythrough = true;

	public Action OnEventResetData;

	public static GSC Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = new GSC();
			}
			return _instance;
		}
	}

	public bool IsLoaded => _isLoaded;

	public bool IsFirstPlaythrough
	{
		get
		{
			_IsLoadedSanityCheck();
			return _isFirstPlaythrough;
		}
	}

	private GSC()
	{
	}

	public void Save(bool autoSave = false)
	{
		PlayerPrefsX.SetBool(kKeyIsFirstPlaythrough, value: false);
		_isFirstPlaythrough = false;
		PlayerPrefs.Save();
	}

	public void Load()
	{
		_isFirstPlaythrough = PlayerPrefsX.GetBool(kKeyIsFirstPlaythrough, defaultValue: true);
		if (_isFirstPlaythrough)
		{
		}
		_isLoaded = true;
	}

	private void _IsLoadedSanityCheck()
	{
		if (!IsLoaded)
		{
			UnityEngine.Debug.LogWarning("Attainment has not been loaded!");
		}
	}
}
public class IC : MonoBehaviour
{
	public enum InputType
	{
		Touch,
		GamePad,
		XboxController,
		GearVRController
	}

	public struct AndroidInputSettings
	{
		public float kSensitivity;

		public float kNonLinearity;

		public float kMaxRange;
	}

	public class AndroidInput
	{
		public float deadzone = 2f;

		public AndroidInputSettings settings;

		public Vector2 axisStart;

		public Vector2 axisLast;

		public Vector2 axisCurrent;

		public bool AxisXInDeadZone => Mathf.Abs(axisStart.x - axisCurrent.x) <= deadzone;

		public bool AxisYInDeadZone => Mathf.Abs(axisStart.y - axisCurrent.y) <= deadzone;
	}

	private static IC _instance;

	private const float timeForLongHoldBackButtonMax = 1.5f;

	private float timeForLongHoldBackButton;

	private bool longHoldBackButtonPressed;

	private bool longHoldActionRelinquished;

	private bool shortHoldBackButtonEvent;

	public static float timeForLongHoldActionButtonMax = 0.25f;

	public static float timeForLongHoldActionButtonController = 0.25f;

	private float timeForLongHoldActionButton;

	private bool longHoldActionButtonPressed;

	private bool longHoldActionButtonEvent;

	private bool actionButtonUpEvent;

	private bool actionButtonDownEvent;

	private float lastGamepadCheckTime;

	private ParticlePrefab selectedCoordFX;

	private OVRInput.Controller currentGearVRController;

	private OVRInput.Controller activeController;

	private UIButton buttonCurrent;

	public static InputType controlInputType;

	[NonSerialized]
	public AndroidInput androidInput = new AndroidInput();

	private HagletTrigger _actionDown = new HagletTrigger();

	private HagletTrigger _actionUp = new HagletTrigger();

	private HagletTrigger _longHoldAction = new HagletTrigger();

	private HagletTrigger _gearVRWheelDown = new HagletTrigger();

	private HagletTrigger _gearVRWheelUp = new HagletTrigger();

	private HagletTrigger _back = new HagletTrigger();

	private bool HACK_inputEnabled = true;

	public static IC Inst => _instance;

	public UIButton buttonCurrentFocused { get; private set; }

	public static HagletEvent longHoldAction => Inst._longHoldAction;

	public static HagletEvent actionDown => Inst._actionDown;

	public static HagletEvent actionUp => Inst._actionUp;

	public static HagletEvent back => Inst._back;

	public static HagletEvent gearVRWheelDown => Inst._gearVRWheelDown;

	public static HagletEvent gearVRWheelUp => Inst._gearVRWheelUp;

	public static bool actionDownFiring => Inst.actionButtonDownEvent;

	public static bool actionUpFiring => Inst.actionButtonUpEvent;

	public bool HACK_InputEnabled
	{
		get
		{
			return HACK_inputEnabled;
		}
		set
		{
			if (!value)
			{
				Crosshair.Inst.SetRadialBarFill(0f);
				Crosshair.Inst.SetContext(UICrosshairContext.None);
			}
			HACK_inputEnabled = value;
		}
	}

	public void OnAwakeLR()
	{
		_instance = this;
	}

	private void Update()
	{
		ResetInputData();
		if (LR.Inst.IsInitialised && !Singleton<UIC>.Inst.IsStackAnimating() && HACK_inputEnabled)
		{
			CollectInputData();
			ProcessInputData();
		}
		CollectOVRInputData();
	}

	private void HandleLookedAtCollider(RaycastHit hit, ref bool actionTriggered)
	{
		UIButton uIButton = null;
		if (hit.collider.gameObject.layer == 5)
		{
			uIButton = hit.collider.GetComponent<UIButton>();
		}
		if (uIButton != null && (!uIButton.enabled || !uIButton.interactable))
		{
			uIButton = null;
		}
		if (hit.collider.gameObject.layer == 9)
		{
			uIButton = hit.collider.GetComponent<UIButton>();
		}
		if (uIButton == null)
		{
			if ((bool)buttonCurrentFocused)
			{
				buttonCurrentFocused.FocusExit();
			}
			buttonCurrentFocused = null;
			buttonCurrent = null;
			return;
		}
		if (buttonCurrentFocused == null)
		{
			buttonCurrentFocused = uIButton;
			buttonCurrentFocused.FocusEnter();
		}
		if (buttonCurrentFocused != uIButton)
		{
			buttonCurrentFocused.FocusExit();
			buttonCurrentFocused = uIButton;
			buttonCurrentFocused.FocusEnter();
		}
		if (uIButton == null && buttonCurrentFocused != null)
		{
			buttonCurrentFocused.FocusExit();
			buttonCurrentFocused = null;
		}
		if (buttonCurrentFocused != null)
		{
			buttonCurrentFocused.FocusStay();
		}
		if (OnActionButtonDown() && buttonCurrent == null)
		{
			buttonCurrent = uIButton;
			buttonCurrent.TapDown();
		}
		if (OnActionButtonHeld() && buttonCurrent != null)
		{
			buttonCurrent.TapHeld();
		}
		if (actionTriggered && buttonCurrent != null)
		{
			bool flag = buttonCurrent.TapUp();
			buttonCurrent = null;
			if (flag)
			{
				actionTriggered = false;
			}
		}
		if (!OnActionButtonHeld() && buttonCurrent != null)
		{
			buttonCurrent = null;
		}
	}

	private void ResetInputData()
	{
		shortHoldBackButtonEvent = false;
		longHoldActionButtonEvent = false;
	}

	private void CollectOVRInputData()
	{
		OVRInput.Update();
		if (activeController != OVRInput.GetActiveController())
		{
			activeController = OVRInput.GetActiveController();
			if (activeController == OVRInput.Controller.Gamepad)
			{
				controlInputType = InputType.GamePad;
			}
			else if (activeController == OVRInput.Controller.RTrackedRemote)
			{
				controlInputType = InputType.GearVRController;
			}
			else if (activeController == OVRInput.Controller.LTrackedRemote)
			{
				controlInputType = InputType.GearVRController;
			}
			else
			{
				controlInputType = InputType.Touch;
			}
		}
	}

	private void CollectInputData()
	{
		if (!longHoldBackButtonPressed && OnBackButtonUp())
		{
			shortHoldBackButtonEvent = true;
			timeForLongHoldBackButton = 1.5f;
			longHoldBackButtonPressed = false;
		}
		if (OnBackButtonHeld())
		{
			timeForLongHoldBackButton -= Time.deltaTime;
		}
		else
		{
			timeForLongHoldBackButton = 1.5f;
			longHoldBackButtonPressed = false;
		}
		if (timeForLongHoldBackButton < 0f && !longHoldBackButtonPressed)
		{
			longHoldBackButtonPressed = true;
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.GlobalMenu);
		}
		if (OnActionButtonDown() && SC.Inst != null && SC.Inst.coord.HasValue && SC.Inst.IsMapInteractable())
		{
			if (selectedCoordFX != null)
			{
				selectedCoordFX.StopParticles();
			}
			selectedCoordFX = PSC.Inst.Play(ParticleTypes.TileEnterFocus, Singleton<MC>.Inst.GetActiveMap(), SC.Inst.coord.Value);
			AC.Inst.PlayOneShot2D("event:/sfx/ui/select");
		}
		if (longHoldActionRelinquished && OnActionButtonHeld() && SC.Inst != null && SC.Inst.coord.HasValue && Singleton<MC>.Inst.GetActiveMap() != null)
		{
			if (!(selectedCoordFX == null))
			{
				v2i value = Singleton<MC>.Inst.GetActiveMap().WorldPosToCoord(selectedCoordFX.transform.position);
				v2i? coord = SC.Inst.coord;
				if (!(value != coord))
				{
					goto IL_0230;
				}
			}
			if (selectedCoordFX != null)
			{
				selectedCoordFX.StopParticles();
			}
			selectedCoordFX = PSC.Inst.Play(ParticleTypes.TileEnterFocus, Singleton<MC>.Inst.GetActiveMap(), SC.Inst.coord.Value);
			timeForLongHoldActionButton = timeForLongHoldActionButtonMax;
		}
		goto IL_0230;
		IL_0230:
		if (OnActionButtonUp() && selectedCoordFX != null)
		{
			selectedCoordFX.StopParticles();
		}
		if (!IsControllerConnected())
		{
			if (OnActionButtonHeld() && longHoldActionRelinquished)
			{
				timeForLongHoldActionButton -= Time.deltaTime;
			}
			else
			{
				timeForLongHoldActionButton += Time.deltaTime * 10f;
				longHoldActionButtonPressed = false;
				if (!OnActionButtonHeld())
				{
					longHoldActionRelinquished = true;
				}
			}
			timeForLongHoldActionButton = Mathf.Clamp(timeForLongHoldActionButton, 0f, timeForLongHoldActionButtonMax);
			if (timeForLongHoldActionButton <= 0f && !longHoldActionButtonPressed)
			{
				if (longHoldActionRelinquished)
				{
					longHoldActionButtonEvent = true;
				}
				longHoldActionRelinquished = false;
				if (selectedCoordFX != null)
				{
					selectedCoordFX.StopParticles();
				}
			}
			Crosshair.Inst.SetRadialBarFill((timeForLongHoldActionButtonMax - timeForLongHoldActionButton) / timeForLongHoldActionButtonMax);
			return;
		}
		if (OnActionButtonHeld())
		{
			timeForLongHoldActionButton = 0.001f;
		}
		else
		{
			timeForLongHoldActionButton += Time.deltaTime * 10f;
		}
		timeForLongHoldActionButton = Mathf.Clamp(timeForLongHoldActionButton, 0.001f, timeForLongHoldActionButtonMax);
		if (OnActionButtonUp())
		{
			longHoldActionButtonEvent = true;
			longHoldActionRelinquished = true;
			if (selectedCoordFX != null)
			{
				selectedCoordFX.StopParticles();
			}
			timeForLongHoldActionButton = 0f;
		}
		Crosshair.Inst.SetRadialBarFill((timeForLongHoldActionButtonMax - timeForLongHoldActionButton) / timeForLongHoldActionButtonMax);
	}

	public static bool IsControllerConnected()
	{
		return controlInputType != InputType.Touch;
	}

	private void ProcessInputData()
	{
		bool actionTriggered = longHoldActionButtonEvent;
		actionButtonUpEvent = false;
		actionButtonDownEvent = false;
		if (OnActionButtonDown())
		{
			_actionDown.Trigger();
			actionButtonDownEvent = true;
		}
		if (OnActionButtonUp())
		{
			_actionUp.Trigger();
			actionButtonUpEvent = true;
		}
		if (OnBackButtonShortEvent() && !Singleton<UIC>.Inst.OnBackButton())
		{
			_back.Trigger();
		}
		if (OnGearVRControllerTouchpadButtonUp())
		{
			_gearVRWheelUp.Trigger();
			actionTriggered = actionTriggered || true;
		}
		int layerMask = 32;
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, float.PositiveInfinity, layerMask))
		{
			HandleLookedAtCollider(hitInfo, ref actionTriggered);
		}
		else
		{
			if (actionTriggered && (bool)buttonCurrent)
			{
				buttonCurrent.TapUp();
				actionTriggered = false;
			}
			if ((bool)buttonCurrentFocused)
			{
				buttonCurrentFocused.FocusExit();
			}
			buttonCurrentFocused = null;
			buttonCurrent = null;
		}
		if (actionTriggered && Singleton<UIC>.Inst.OnActionButton())
		{
			actionTriggered = false;
		}
		if (actionTriggered)
		{
			_longHoldAction.Trigger();
			actionTriggered = false;
		}
	}

	public static Vector2 GetAxis()
	{
		return new Vector2(GetAxisX(), GetAxisY());
	}

	public static float GetAxisX()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetAxis("Android:Joy 1:Left_X_Axis");
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetAxis("Win:Joy 1:Left_X_Axis");
		}
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad).x;
		}
		return Input.GetAxis("Mouse X");
	}

	public static float GetAxisY()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetAxis("Android:Joy 1:Left_Y_Axis");
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetAxis("Win:Joy 1:Left_Y_Axis");
		}
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad).y;
		}
		return Input.GetAxis("Mouse Y");
	}

	public static bool OnGearVRControllerTouchpadButtonDown()
	{
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad);
		}
		return false;
	}

	public static bool OnGearVRControllerTouchpadButtonUp()
	{
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad);
		}
		return false;
	}

	public static bool IsGearVRControllerTouchpadBeingTouched()
	{
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.Get(OVRInput.Touch.PrimaryTouchpad);
		}
		return false;
	}

	public static bool OnTriggerButtonDown()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonDown("Android:Joy 1:Right Shoulder") || Input.GetButtonDown("Android:Joy 1:Left Shoulder");
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetAxis("Win:Joy 1:LeftTrigger") > 0.7f || Input.GetAxis("Win:Joy 1:RightTrigger") > 0.7f;
		}
		return Input.GetMouseButtonDown(0);
	}

	public static bool OnTriggerButtonHeld()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButton("Android:Joy 1:Right Shoulder") || Input.GetButton("Android:Joy 1:Left Shoulder");
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetAxis("Win:Joy 1:LeftTrigger") > 0.7f || Input.GetAxis("Win:Joy 1:RightTrigger") > 0.7f;
		}
		return Input.GetMouseButton(0);
	}

	public static bool OnTriggerButtonUp()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonUp("Android:Joy 1:Right Shoulder") || Input.GetButtonUp("Android:Joy 1:Left Shoulder");
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetAxis("Win:Joy 1:LeftTrigger") > 0.7f || Input.GetAxis("Win:Joy 1:RightTrigger") > 0.7f;
		}
		return Input.GetMouseButtonUp(0);
	}

	public static bool OnActionButtonDown()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonDown("Android:Joy 1:Button A") || Input.GetMouseButtonDown(0);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButtonDown("Win:Joy 1:Button A") || Input.GetMouseButtonDown(0);
		}
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad);
		}
		return Input.GetMouseButtonDown(0);
	}

	public static bool OnActionButtonHeld()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButton("Android:Joy 1:Button A") || Input.GetMouseButton(0);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButton("Win:Joy 1:Button A") || Input.GetMouseButton(0);
		}
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.PrimaryTouchpad);
		}
		return Input.GetMouseButton(0);
	}

	public static bool OnActionButtonUp()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonUp("Android:Joy 1:Button A") || Input.GetMouseButtonUp(0);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButtonUp("Win:Joy 1:Button A") || Input.GetMouseButtonUp(0);
		}
		if (controlInputType == InputType.GearVRController)
		{
			return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad);
		}
		return Input.GetMouseButtonUp(0);
	}

	public static bool OnBackButtonDown()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonDown("Android:Joy 1:Start") || Input.GetButtonDown("Android:Joy 1:Button B") || Input.GetKeyDown(KeyCode.Escape);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButtonDown("Win:Joy 1:Start") || Input.GetKeyDown(KeyCode.Escape);
		}
		return Input.GetKeyDown(KeyCode.Escape);
	}

	public static bool OnBackButtonHeld()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButton("Android:Joy 1:Start") || Input.GetButton("Android:Joy 1:Button B") || Input.GetKey(KeyCode.Escape);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButton("Win:Joy 1:Start") || Input.GetKey(KeyCode.Escape);
		}
		return Input.GetKey(KeyCode.Escape);
	}

	public static bool OnBackButtonUp()
	{
		if (controlInputType == InputType.GamePad)
		{
			return Input.GetButtonUp("Android:Joy 1:Start") || Input.GetButtonUp("Android:Joy 1:Button B") || Input.GetKeyUp(KeyCode.Escape);
		}
		if (controlInputType == InputType.XboxController)
		{
			return Input.GetButtonUp("Win:Joy 1:Start") || Input.GetKeyUp(KeyCode.Escape);
		}
		return Input.GetKeyUp(KeyCode.Escape);
	}

	public static bool OnBackButtonShortEvent()
	{
		return _instance.shortHoldBackButtonEvent;
	}

	public static bool OnActionButtonLongTap()
	{
		return _instance.longHoldActionButtonEvent;
	}
}
public class MC : Singleton<MC>
{
	public delegate void OnMapTransitionCompleteForUnit(Map map, Unit unit);

	public delegate void OnMapTransitionEvent(Map currentMap, Map targetMap);

	public enum MapTransitionState
	{
		Complete,
		FadeOutBegin,
		FadeOutComplete,
		FadeInComplete
	}

	[Serializable]
	private class Transition : HagletResettable
	{
		public OnMapTransitionEvent eventCurrentMapHidden;

		public OnMapTransitionEvent eventTargetMapVisible;

		public Map mapTarget;

		public float timer;

		public AnimFloat animDriver = new AnimFloat(0f);

		public bool missionStart;

		public bool fadeOutUnits;

		public KubrickAnimatorAndClip? entryAnimation;

		public KubrickAnimatorAndClip? exitAnimation;

		public float? overrideFadeTime;

		public Transition(MC mc)
			: base(mc.TransitionRoutine(), "Map Transition", HagletStepTime.Update, -1, 20)
		{
		}

		protected Transition(BinaryReader reader)
			: base(reader)
		{
		}
	}

	[Serializer.Exclude]
	private Map[] maps;

	[Serializer.Exclude]
	private Map _mapActive;

	private Map mapPrev;

	[HideInInspector]
	[Serializer.Exclude]
	public VFXTileController VFXTiles;

	[Serializer.Exclude]
	public Transform mapPivot;

	[Serializer.Exclude]
	public Transform mapPivotStart;

	[HideInInspector]
	public const float mapScale = 0.08f;

	[Range(0f, 1f)]
	public float holoTime;

	public const float kMapLoadFadeTime = 5f;

	public const float kMapTransitionFadeTime = 1.25f;

	public float tableAngle = -14f;

	[Serializer.Exclude]
	private Transition transition;

	public HagletTrigger hiddenAndReadyForRoom = new HagletTrigger();

	[Serializer.Exclude]
	private Dictionary<string, uint> dictMapNameToIndex = new Dictionary<string, uint>();

	[Serializer.Exclude]
	private Dictionary<LogicSceneMeta, uint> dictMapMetaToIndex = new Dictionary<LogicSceneMeta, uint>();

	[Serializer.Exclude]
	private Dictionary<string, LogicRoot> dictLogicNameToRoot = new Dictionary<string, LogicRoot>();

	private Map mapActive
	{
		get
		{
			return _mapActive;
		}
		set
		{
			_mapActive = value;
			if (value != null)
			{
				VFXTiles.transform.parent = mapActive.transform;
				VFXTiles.transform.localRotation = Quaternion.identity;
			}
		}
	}

	[Serializer.Exclude]
	public ShakeObject MapShake { get; private set; }

	public HagletEvent TransitionStopped => transition.stopped;

	public bool transitioning => transition.running;

	public void OnAwakeLR()
	{
		mapPivot = LR.Get<Transform>("/LevelRoot/MapController/MapPivot");
		mapPivotStart = LR.Get<Transform>("/LevelRoot/MapController/MapPivotStart");
		transition = new Transition(this);
	}

	public void OnMissionSceneLoaded(MR mr)
	{
		MapShake = mr.gameObject.AddComponent<ShakeObject>();
		MapShake.lockLocalYAxis = true;
		mapPivot.transform.localScale = Vector3.one * 0.08f;
		maps = mr.GetComponentsInChildren<Map>();
		Array.Sort(maps, (Map lhs, Map rhs) => (lhs.gameObject.scene == rhs.gameObject.scene) ? lhs.transform.GetSiblingIndex().CompareTo(rhs.transform.GetSiblingIndex()) : 0);
		uint num = 0u;
		Map[] array = maps;
		foreach (Map map in array)
		{
			map.OnMissionSceneLoaded();
			dictMapNameToIndex.Add(map.name, num);
			dictMapMetaToIndex.Add(map.SceneMetaLogic, num);
			dictLogicNameToRoot.Add(map.SceneMetaLogic.sceneName.Replace("LOGIC_", string.Empty), map.logicRoot);
			num++;
		}
		Map[] array2 = maps;
		foreach (Map map2 in array2)
		{
			map2.PrepareMapSwapTiles(dictMapMetaToIndex);
			TileObjectBase[] componentsInChildren = map2.GetComponentsInChildren<TileObjectBase>(includeInactive: true);
			foreach (TileObjectBase tileObjectBase in componentsInChildren)
			{
				tileObjectBase.OnMissionSceneLoaded();
			}
		}
		for (uint num2 = 0u; num2 < maps.Length; num2++)
		{
			maps[num2].HideImmediate();
		}
	}

	public void OnMissionStart(MR mr)
	{
	}

	public void OnMissionResume(MR mr)
	{
	}

	public void OnMissionSceneUnloaded(MR mr)
	{
		maps = null;
		mapActive = null;
		mapPrev = null;
		dictMapNameToIndex = new Dictionary<string, uint>();
		dictMapMetaToIndex = new Dictionary<LogicSceneMeta, uint>();
		dictLogicNameToRoot = new Dictionary<string, LogicRoot>();
	}

	public Map GetActiveMap()
	{
		return mapActive;
	}

	public Map GetLastMap()
	{
		return mapPrev;
	}

	public Map GetMapWithIndex(uint index)
	{
		return maps[index];
	}

	public Map[] GetAllMaps()
	{
		return maps;
	}

	public uint GetIndexWithMap(Map map)
	{
		return (uint)Array.IndexOf(maps, map);
	}

	public Map GetMapWithName(string name)
	{
		return GetMapWithIndex(dictMapNameToIndex[name]);
	}

	public LogicRoot GetLogicWithName(string name)
	{
		return dictLogicNameToRoot[name];
	}

	public HagletYieldTerm TransitionToMap(Map map, OnMapTransitionEvent onMapTransitionCurrentMapHidden = null, OnMapTransitionEvent onMapTransitionTargetMapVisible = null, float hideMapDelay = 0f, bool missionStart = true, KubrickAnimatorAndClip? entryAnimation = null, KubrickAnimatorAndClip? exitAnimation = null, float? overrideFadeTime = null, bool fadeOutUnits = true)
	{
		if (map == transition.mapTarget && map != null)
		{
			return Wait.PreMet;
		}
		transition.eventCurrentMapHidden = onMapTransitionCurrentMapHidden;
		transition.eventTargetMapVisible = onMapTransitionTargetMapVisible;
		transition.mapTarget = map;
		transition.timer = hideMapDelay;
		transition.missionStart = missionStart;
		transition.entryAnimation = entryAnimation;
		transition.exitAnimation = exitAnimation;
		transition.overrideFadeTime = overrideFadeTime;
		transition.fadeOutUnits = fadeOutUnits;
		if ((bool)transition.running)
		{
			transition.host.Pause(transition);
		}
		transition.Reset();
		return Routine.Start(transition, LR.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> TransitionRoutine()
	{
		bool wasTransitionFromRoom = true;
		KubrickAnimatorAndClip? exitAnimation = transition.exitAnimation;
		if (exitAnimation.HasValue)
		{
			KubrickAnimatorAndClip? exitAnimation2 = transition.exitAnimation;
			KubrickAnimatorAndClip exitAnimData = exitAnimation2.Value;
			KubrickAnimator animator2 = Singleton<MC>.Inst.GetActiveMap().GetDynamicAnimator(exitAnimData.animator);
			animator2.blending = 0f;
			yield return animator2.Play(exitAnimData.clipName);
			animator2.blending = 0.25f;
		}
		UILoadingBar.Inst.SetProgressToNextChunk(0.1f);
		if (!string.IsNullOrEmpty(MR.Inst.DEBUG_startingCutscene) || LR.DEBUG_autoTestFilters != null || (LR.DEBUG_autoReload && transition.mapTarget == null && !HAGIS.HACK_InShowRoomPhase))
		{
			SkipTransition();
		}
		if ((bool)mapActive)
		{
			wasTransitionFromRoom = false;
			mapActive.VFXTiles.ClearAllGroups();
			mapActive.VFXTiles.UnitSelectHighlightHide();
			SC.Inst.enabled = false;
			if (transition.fadeOutUnits)
			{
				GC.Inst.HideAllUnitsOnMap(removeFromActiveUnitList: true);
			}
			if (Routine.IsSkipping())
			{
				yield return Wait.ForChildren;
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.2f);
			float fadeTime2 = ((!transition.overrideFadeTime.HasValue) ? 1.25f : transition.overrideFadeTime.Value);
			transition.animDriver.AnimateTo(0f, fadeTime2);
			mapActive.HideBegin(fadeTime2);
			if (Routine.IsSkipping())
			{
				transition.animDriver.Update(transition.animDriver.Duration);
			}
			do
			{
				UpdateTransitionAnim(isMapIntroAnimation: false);
				yield return Wait.ForSteps(1uL);
			}
			while ((bool)transition.animDriver.animating);
			UILoadingBar.Inst.SetProgressToNextChunk(0.3f);
			if (!transition.fadeOutUnits)
			{
				GC.Inst.HideAllUnitsOnMap(removeFromActiveUnitList: true, immediate: true);
				yield return Wait.ForChildren;
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.4f);
			while (GC.Inst.AnyUnitsVisible().SkipOverride(overrideValue: false))
			{
				yield return Wait.ForSteps(1uL);
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.5f);
			mapActive.HideEnd();
		}
		Map mapPrevious = mapActive;
		if (transition.eventCurrentMapHidden != null)
		{
			transition.eventCurrentMapHidden(mapActive, transition.mapTarget);
		}
		mapPrev = mapActive;
		mapActive = transition.mapTarget;
		if ((bool)mapActive)
		{
			if (MR.Inst.roomInteraction != null)
			{
				MR.Inst.roomInteraction.transform.localPosition = Vector3.zero;
				MR.Inst.roomInteraction.transform.localRotation = Quaternion.identity;
			}
			mapActive.HologamColor = RC.Inst.bkColorAnim.Value;
			mapActive.transform.localScale = Vector3.one * 0.08f;
			if (wasTransitionFromRoom)
			{
				mapActive.transform.position = mapPivotStart.transform.position;
				mapActive.transform.rotation = mapPivotStart.transform.rotation;
			}
			else
			{
				mapActive.transform.position = mapPivot.transform.position;
				mapActive.transform.rotation = mapPivot.transform.rotation;
			}
			float fadeTime = ((!wasTransitionFromRoom) ? 1.25f : 5f);
			transition.animDriver.AnimateTo(1f, fadeTime);
			mapActive.ShowBegin(fadeTime);
			if (transition.missionStart)
			{
				if (mapActive.logicRoot.unitsMoveToDefaultPositions)
				{
					GC.Inst.GetTeamOfType(UnitTeam.Type.Player).MoveTeamToDefaultPositions();
				}
				else
				{
					mapActive.logicRoot.unitsMoveToDefaultPositions = true;
				}
			}
			GC.Inst.ShowAllUnitsOnMap(UnitTeam.Type.Player, onlyShowEnvironmental: true);
			if (Routine.IsSkipping())
			{
				yield return Wait.ForChildren;
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.6f);
			if (Routine.IsSkipping())
			{
				transition.animDriver.Update(transition.animDriver.Duration);
			}
			do
			{
				UpdateTransitionAnim(wasTransitionFromRoom);
				yield return Wait.ForSteps(1uL);
			}
			while ((bool)transition.animDriver.animating);
			UILoadingBar.Inst.SetProgressToNextChunk(0.7f);
			GC.Inst.ShowAllUnitsOnMap(UnitTeam.Type.Player);
			if (Routine.IsSkipping())
			{
				yield return Wait.ForChildren;
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.8f);
			mapActive.OnMapVisible.Trigger();
			KubrickAnimatorAndClip? entryAnimation = transition.entryAnimation;
			if (entryAnimation.HasValue)
			{
				KubrickAnimatorAndClip? entryAnimation2 = transition.entryAnimation;
				KubrickAnimatorAndClip entryAnimData = entryAnimation2.Value;
				KubrickAnimator animator = Singleton<MC>.Inst.GetActiveMap().GetDynamicAnimator(entryAnimData.animator);
				animator.blending = 0f;
				yield return animator.Play(entryAnimData.clipName);
				animator.blending = 0.25f;
			}
			UILoadingBar.Inst.SetProgressToNextChunk(0.9f);
			yield return GC.Inst.ShowAllUnitsOnMap();
			UILoadingBar.Inst.SetProgressToNextChunk(1f);
			GC.Inst.SetRPGLeader(GC.Inst.GetRPGLeader());
			if (transition.eventTargetMapVisible != null)
			{
				transition.eventTargetMapVisible(mapPrevious, mapActive);
			}
			Unit leader = GC.Inst.GetActiveUnit();
			if ((bool)leader)
			{
				mapActive.VFXTiles.UnitSelectedShow(leader);
			}
			SC.Inst.enabled = true;
			mapActive.ShowEnd();
		}
		else
		{
			yield return null;
			hiddenAndReadyForRoom.Trigger();
			if (MR.Inst.roomInteraction != null)
			{
				MR.Inst.roomInteraction.transform.position = Vector3.zero;
				MR.Inst.roomInteraction.transform.rotation = Quaternion.identity;
			}
		}
	}

	public void SkipTransition()
	{
		transition.host.Skip(transition);
	}

	private void UpdateTransitionAnim(bool isMapIntroAnimation)
	{
		float num = transition.animDriver.Update();
		if (isMapIntroAnimation)
		{
			mapActive.transform.position = Vector3.LerpUnclamped(mapPivotStart.position, mapPivot.position, LR.Inst.animMapPivotLinearOffset.Evaluate(num));
			mapActive.transform.rotation = Quaternion.LerpUnclamped(mapPivotStart.rotation, mapPivot.rotation, LR.Inst.animMapPivotAngularOffset.Evaluate(num));
		}
		float holoFrameFadeScale = ((!isMapIntroAnimation) ? LR.Inst.animHoloFrameFadeScaleFastMode.Evaluate(num) : LR.Inst.animHoloFrameFadeScale.Evaluate(num));
		float holoFrameWidth = ((!isMapIntroAnimation) ? LR.Inst.animHoloFrameWidthFastMode.Evaluate(num) : LR.Inst.animHoloFrameWidth.Evaluate(num));
		mapActive.UpdateMapHologramMaterials(mapActive.transform.worldToLocalMatrix, num, holoFrameWidth, LR.Inst.animHoloFrameHeight.Evaluate(num), holoFrameFadeScale);
	}

	public void ClearVFXControllerParent()
	{
		VFXTiles.transform.parent = base.transform;
	}
}
public class NC : MonoBehaviour
{
	private struct NavCoordMeta
	{
		public int indexListOpen;

		public int indexListClosed;

		public uint costMod;
	}

	public delegate void PathRequestComplete(Path path, Unit unitAssociated);

	public delegate void AreaRequestComplete(Area area, Unit unitAssociated);

	public delegate void NeighborRequestComplete(Neighbors neighbors, Unit unitAssociated);

	private class PathNodePool
	{
		private ConstArray<PathNode> open;

		private ConstArray<PathNode> closed;

		private ConstArray<PathNode> pool;

		public PathNodePool(uint size)
		{
			pool = new ConstArray<PathNode>(size);
			open = new ConstArray<PathNode>(size);
			closed = new ConstArray<PathNode>(size);
			for (int i = 0; i < size; i++)
			{
				pool.Add(new PathNode(v2i.zero, null));
			}
		}

		public uint GetOpenSize()
		{
			return open.Length;
		}

		public void Reset()
		{
			pool._dataNum += open.Length + closed.Length;
			open.Clear();
			closed.Clear();
		}

		public PathNode AddNodetoOpenSet(v2i coord, PathNode parent)
		{
			PathNode pathNode = pool._data[pool.Length - 1];
			pool._dataNum--;
			pathNode.coord = coord;
			pathNode.parent = parent;
			pathNode.costG = 0u;
			pathNode.costH = 0u;
			pathNode.costF = 0u;
			pathNode.numObservers = 0u;
			open.Add(pathNode);
			return pathNode;
		}

		public int GetLowestIndexOnOpenSet()
		{
			uint num = uint.MaxValue;
			int result = -1;
			int sLength = open.sLength;
			for (int i = 0; i < sLength; i++)
			{
				PathNode pathNode = open._data[i];
				if (pathNode.costF < num)
				{
					num = pathNode.costF;
					result = i;
				}
			}
			return result;
		}

		public PathNode GetOpenNodeAtIndex(int index)
		{
			if (index >= 0)
			{
				return open._data[index];
			}
			return null;
		}

		public void MoveNodeToClosed(int index)
		{
			PathNode obj = open._data[index];
			closed.Add(obj);
			open.RemoveAtIndex((uint)index);
		}
	}

	private class PathRequest
	{
		public Unit unit;

		public v2i start;

		public v2i end;

		public bool includeObservedTiles;

		public bool allowVaulting;

		public bool ignoreUnitAtDestination;

		public bool avoidUnits;

		public PathingCellValidator pathCellValidator;

		public PathRequestComplete onComplete;
	}

	private class AreaRequest
	{
		public Area area;
	}

	private class NeighborRequest
	{
		public v2i coordStart;

		public Unit unitAssociated;

		public uint directionIndex;

		public uint neighborNum;

		public bool includeObstructedDiagonals;

		public NeighborRequestComplete onComplete;

		public UnityEngine.Object userData;
	}

	public enum PathStatus
	{
		Complete,
		Failed
	}

	[Serializable]
	public class Path
	{
		public PathStatus status;

		public List<Vector3> positions = new List<Vector3>();

		public v2i coordStart;

		public v2i coordEnd;

		public List<uint> pathInfo = new List<uint>();

		public int cost;

		public UnityEngine.Object userData;

		public bool usedObservedTiles;
	}

	public delegate bool PathingCellValidator(v2i coord);

	[Serializable]
	public class Neighbors
	{
		public PathStatus status;

		public v2i coordTarget;

		public List<v2i> coordsNeighbors = new List<v2i>();

		public UnityEngine.Object userData;
	}

	[Serializable]
	private class PathNode
	{
		public v2i coord;

		public PathNode parent;

		public uint costG;

		public uint costH;

		public uint costF;

		public uint numObservers;

		public PathNode(v2i coord, PathNode parent)
		{
			this.coord = coord;
			this.parent = parent;
		}
	}

	private static NC _instance;

	private NavCoordMeta[,] navData;

	private PathNodePool pathPool;

	private PathNodePool areaPool;

	public const int kPathInfoDirPrevOffset = 0;

	public const int kPathInfoDirPrevMask = 255;

	public const int kPathInfoDirNextOffset = 8;

	public const int kPathInfoDirNextMask = 65280;

	public const int kPathInfoPrevNodeVaultMask = 65536;

	public const int kPathInfoNextNodeVaultMask = 131072;

	public const int kPathInfoNodeObservedMask = 262144;

	private static readonly v2i[] LUT_Direction = new v2i[16]
	{
		new v2i(0, 1),
		new v2i(1, 1),
		new v2i(1, 0),
		new v2i(1, -1),
		new v2i(0, -1),
		new v2i(-1, -1),
		new v2i(-1, 0),
		new v2i(-1, 1),
		new v2i(0, 2),
		new v2i(2, 2),
		new v2i(2, 0),
		new v2i(2, -2),
		new v2i(0, -2),
		new v2i(-2, -2),
		new v2i(-2, 0),
		new v2i(-2, 2)
	};

	private static readonly uint[] LUT_CostG = new uint[16]
	{
		10u, 14u, 10u, 14u, 10u, 14u, 10u, 14u, 20u, 20u,
		20u, 20u, 20u, 20u, 20u, 20u
	};

	private const uint XX = uint.MaxValue;

	private static uint[] LUT_DirectionToIndex = new uint[25]
	{
		15u, 4294967295u, 8u, 4294967295u, 9u, 4294967295u, 7u, 0u, 1u, 4294967295u,
		14u, 6u, 4294967295u, 2u, 10u, 4294967295u, 5u, 4u, 3u, 4294967295u,
		13u, 4294967295u, 12u, 4294967295u, 11u
	};

	public static NC Inst => _instance;

	public HagletCondition calculating => HagletCondition.never;

	public void OnAwakeLR()
	{
		_instance = this;
		v2i maxMapSize = Map.maxMapSize;
		int x = maxMapSize.x;
		v2i maxMapSize2 = Map.maxMapSize;
		int num = x + maxMapSize2.y - 1;
		v2i maxMapSize3 = Map.maxMapSize;
		int x2 = maxMapSize3.x;
		v2i maxMapSize4 = Map.maxMapSize;
		navData = new NavCoordMeta[num, x2 + maxMapSize4.y - 1];
		v2i maxMapSize5 = Map.maxMapSize;
		int x3 = maxMapSize5.x;
		v2i maxMapSize6 = Map.maxMapSize;
		pathPool = new PathNodePool((uint)(x3 * maxMapSize6.y));
		v2i maxMapSize7 = Map.maxMapSize;
		int x4 = maxMapSize7.x;
		v2i maxMapSize8 = Map.maxMapSize;
		areaPool = new PathNodePool((uint)(x4 * maxMapSize8.y));
	}

	public HagletCondition CalculatePath(Unit unit, v2i targetCoord, bool includeObservedTiles, PathRequestComplete onPathRequestComplete, bool allowVaulting = true, bool ignoreUnitAtDestination = false, PathingCellValidator pathCellValidator = null)
	{
		return CalculatePath(unit, unit.coord, targetCoord, includeObservedTiles, onPathRequestComplete, allowVaulting, ignoreUnitAtDestination, pathCellValidator);
	}

	public HagletCondition CalculatePath(Unit unit, v2i startCoord, v2i targetCoord, bool includeObservedTiles, PathRequestComplete onPathRequestComplete, bool allowVaulting = true, bool ignoreUnitAtDestination = false, PathingCellValidator pathCellValidator = null)
	{
		PathRequest pathRequest = new PathRequest();
		pathRequest.unit = unit;
		pathRequest.start = startCoord;
		pathRequest.end = targetCoord;
		pathRequest.includeObservedTiles = includeObservedTiles;
		pathRequest.onComplete = onPathRequestComplete;
		pathRequest.pathCellValidator = pathCellValidator;
		pathRequest.allowVaulting = allowVaulting;
		pathRequest.ignoreUnitAtDestination = ignoreUnitAtDestination;
		pathRequest.avoidUnits = GC.Inst.InCutsceneMode() || GC.Inst.IsInRPGMode();
		PathRequest request = pathRequest;
		ProcessPathRequest(request);
		return calculating;
	}

	public HagletCondition CalculateArea(Area area, PathingCellValidator pathValidator = null)
	{
		AreaRequest areaRequest = new AreaRequest();
		areaRequest.area = area;
		AreaRequest request = areaRequest;
		ProcessAreaRequest(request, pathValidator);
		return calculating;
	}

	public HagletCondition CalculateNeighbors(v2i coordSearchingFrom, v2i coordToPrioritiseDirection, uint neighborNum, Unit unitAssociated, bool includeObstructedDiagonals, NeighborRequestComplete onNeighborRequestComplete, UnityEngine.Object userData = null)
	{
		NeighborRequest neighborRequest = new NeighborRequest();
		neighborRequest.coordStart = coordSearchingFrom;
		neighborRequest.directionIndex = DirectionToIndex(coordSearchingFrom, coordToPrioritiseDirection);
		neighborRequest.unitAssociated = unitAssociated;
		neighborRequest.neighborNum = neighborNum;
		neighborRequest.onComplete = onNeighborRequestComplete;
		neighborRequest.includeObstructedDiagonals = includeObstructedDiagonals;
		neighborRequest.userData = userData;
		NeighborRequest request = neighborRequest;
		ProcessNeighborRequest(request);
		return calculating;
	}

	private bool GetNavDataCoordIsOnListOpen(v2i coord)
	{
		return navData[coord.x, coord.y].indexListOpen != -1;
	}

	private int GetNavDataCoordListOpenIndex(v2i coord)
	{
		return navData[coord.x, coord.y].indexListOpen;
	}

	private void SetNavDataCoordOnListOpen(v2i coord, int index)
	{
		navData[coord.x, coord.y].indexListOpen = index;
	}

	private void SetCostModAtCoord(v2i coord, uint costMod)
	{
		navData[coord.x, coord.y].costMod = costMod;
	}

	private uint GetCostModAtCoord(v2i coord)
	{
		return navData[coord.x, coord.y].costMod;
	}

	private bool GetNavDataCoordIsOnListClosed(v2i coord)
	{
		try
		{
			return navData[coord.x, coord.y].indexListClosed != -1;
		}
		catch
		{
		}
		return false;
	}

	private void SetNavDataCoordOnListClosed(v2i coord, int index)
	{
		navData[coord.x, coord.y].indexListClosed = index;
	}

	private void CleanNavData()
	{
		v2i v2i2 = new v2i(navData.GetLength(0), navData.GetLength(1));
		for (int i = 0; i < v2i2.x; i++)
		{
			for (int j = 0; j < v2i2.y; j++)
			{
				navData[i, j].indexListClosed = -1;
				navData[i, j].indexListOpen = -1;
				navData[i, j].costMod = 0u;
			}
		}
	}

	public static uint DirectionToIndex(v2i coord)
	{
		int num = (2 - coord.y) * 5 + (coord.x + 2);
		return LUT_DirectionToIndex[num];
	}

	public static uint DirectionToIndex(v2i startCoord, v2i endCoord)
	{
		int num = endCoord.x - startCoord.x;
		int num2 = endCoord.y - startCoord.y;
		if (num < 0)
		{
			num = -1;
		}
		if (num > 0)
		{
			num = 1;
		}
		if (num2 < 0)
		{
			num2 = -1;
		}
		if (num2 > 0)
		{
			num2 = 1;
		}
		return DirectionToIndex(new v2i(num, num2));
	}

	public static v2i IndexToDirection(uint index)
	{
		return LUT_Direction[index];
	}

	private bool ProcessPathRequest(PathRequest request)
	{
		Map map = request.unit.map;
		Path path = new Path();
		path.coordStart = request.start;
		path.coordEnd = request.end;
		path.usedObservedTiles = request.includeObservedTiles;
		if (!request.ignoreUnitAtDestination && (map.GetCoordBlocked(path.coordStart) || map.GetCoordBlocked(path.coordEnd) || GC.Inst.GetUnitAtCoord(path.coordEnd) != null))
		{
			path.status = PathStatus.Failed;
			request.onComplete(path, request.unit);
			return false;
		}
		CleanNavData();
		bool allowVaulting = request.allowVaulting;
		pathPool.Reset();
		if (request.avoidUnits)
		{
			ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
			for (int i = 0; i < unitsActive.Length; i++)
			{
				Unit unit = unitsActive[i];
				if (!(unit == request.unit) && !unit.moving && map.CoordExists(unit.coord))
				{
					if (unit.charData.environmental)
					{
						SetNavDataCoordOnListClosed(unit.coord, int.MinValue);
					}
					else
					{
						SetCostModAtCoord(unit.coord, 10u);
					}
				}
			}
		}
		PathNode pathNode = null;
		pathPool.AddNodetoOpenSet(path.coordStart, null);
		bool flag = false;
		while (pathPool.GetOpenSize() != 0 || !flag)
		{
			int lowestIndexOnOpenSet = pathPool.GetLowestIndexOnOpenSet();
			PathNode openNodeAtIndex = pathPool.GetOpenNodeAtIndex(lowestIndexOnOpenSet);
			if (openNodeAtIndex == null)
			{
				path.status = PathStatus.Failed;
				request.onComplete(path, request.unit);
				return false;
			}
			SetNavDataCoordOnListClosed(openNodeAtIndex.coord, lowestIndexOnOpenSet);
			SetNavDataCoordOnListOpen(openNodeAtIndex.coord, lowestIndexOnOpenSet);
			pathPool.MoveNodeToClosed(lowestIndexOnOpenSet);
			if (openNodeAtIndex.coord.x == path.coordEnd.x && openNodeAtIndex.coord.y == path.coordEnd.y)
			{
				pathNode = openNodeAtIndex;
				flag = true;
				break;
			}
			int num = ((!allowVaulting) ? 8 : 16);
			int num2 = map.CoordToDataIndex(openNodeAtIndex.coord);
			if (num2 < 0 || num2 >= map.tileInfo.Length)
			{
				UnityEngine.Debug.LogWarning("Nav Data Index " + num2 + " is out of Range (for coord " + openNodeAtIndex.coord.x + ", " + openNodeAtIndex.coord.y + ")");
				continue;
			}
			uint num3 = map.tileInfo[num2];
			for (int j = 0; j < num; j++)
			{
				int num4 = 1 << j;
				if ((num4 & num3) != 0)
				{
					v2i v2i2 = LUT_Direction[j];
					v2i coord = openNodeAtIndex.coord;
					coord.x += v2i2.x;
					coord.y += v2i2.y;
					if (!GetNavDataCoordIsOnListClosed(coord) && (request.pathCellValidator == null || request.pathCellValidator(coord)) && !GetNavDataCoordIsOnListOpen(coord))
					{
						PathNode pathNode2 = pathPool.AddNodetoOpenSet(coord, openNodeAtIndex);
						SetNavDataCoordOnListOpen(coord, (int)(pathPool.GetOpenSize() - 1));
						pathNode2.costG = LUT_CostG[j] + pathNode2.parent.costG;
						pathNode2.numObservers = map.GetTileObserverCount(coord);
						uint num5 = (uint)Math.Abs(pathNode2.coord.x - path.coordEnd.x);
						uint num6 = (uint)Math.Abs(pathNode2.coord.y - path.coordEnd.y);
						pathNode2.costH = num5 + num6;
						pathNode2.costF = pathNode2.costG + pathNode2.costH + (request.includeObservedTiles ? (pathNode2.numObservers * 10) : 0) + GetCostModAtCoord(coord);
					}
				}
			}
		}
		if (flag)
		{
			PathNode pathNode3 = pathNode;
			v2i? coordNext = null;
			v2i? v2i3 = null;
			while (pathNode3.parent != null)
			{
				v2i3 = ((pathNode3.parent == null) ? null : new v2i?(pathNode3.parent.coord));
				InsertPathNode(map, path, pathNode3.coord, v2i3, coordNext, pathNode3.numObservers != 0);
				coordNext = pathNode3.coord;
				pathNode3 = pathNode3.parent;
			}
			InsertPathNode(map, path, path.coordStart, null, coordNext, isObserved: false);
			path.positions[0] = map.WorldPosToLocalPos(request.unit.GetPositionWS());
			path.cost = Mathf.CeilToInt((float)pathNode.costF * 0.1f);
			request.onComplete(path, request.unit);
			return true;
		}
		return false;
	}

	private void InsertPathNode(Map map, Path path, v2i coord, v2i? coordPrev, v2i? coordNext, bool isObserved)
	{
		uint num = (isObserved ? 262144u : 0u);
		if (coordPrev.HasValue)
		{
			v2i coord2 = coordPrev.Value - coord;
			int num2 = (int)DirectionToIndex(coord2);
			if (num2 >= 8)
			{
				num |= 0x10000u;
				num2 -= 8;
			}
			num |= (uint)(1 << num2);
		}
		if (coordNext.HasValue)
		{
			v2i coord3 = coordNext.Value - coord;
			int num3 = (int)DirectionToIndex(coord3);
			if (num3 >= 8)
			{
				num |= 0x20000u;
				num3 -= 8;
			}
			num |= (uint)(1 << num3 + 8);
		}
		path.pathInfo.Insert(0, num);
		path.positions.Insert(0, map.CoordToLocalPos(coord));
	}

	private bool ProcessAreaRequest(AreaRequest request, PathingCellValidator pathValidator)
	{
		Map map = request.area.map;
		int num = 0;
		while (true)
		{
			int num2 = num;
			v2i maxMapSize = Map.maxMapSize;
			int x = maxMapSize.x;
			v2i maxMapSize2 = Map.maxMapSize;
			if (num2 >= x * maxMapSize2.y)
			{
				break;
			}
			request.area.costs[num] = int.MaxValue;
			num++;
		}
		v2i startCoord = request.area.startCoord;
		if (!map.CoordExists(startCoord))
		{
			request.area.status = PathStatus.Failed;
			return false;
		}
		bool flag = GC.Inst.IsInTurnMode() && request.area.allowVaults;
		CleanNavData();
		areaPool.Reset();
		areaPool.AddNodetoOpenSet(startCoord, null);
		bool flag2 = false;
		if (request.area.includePathing)
		{
			while (areaPool.GetOpenSize() != 0 || !flag2)
			{
				int lowestIndexOnOpenSet = areaPool.GetLowestIndexOnOpenSet();
				PathNode openNodeAtIndex = areaPool.GetOpenNodeAtIndex(lowestIndexOnOpenSet);
				if (openNodeAtIndex == null)
				{
					flag2 = true;
					break;
				}
				SetNavDataCoordOnListClosed(openNodeAtIndex.coord, lowestIndexOnOpenSet);
				SetNavDataCoordOnListOpen(openNodeAtIndex.coord, lowestIndexOnOpenSet);
				areaPool.MoveNodeToClosed(lowestIndexOnOpenSet);
				int num3 = ((!flag) ? 8 : 16);
				uint num4 = map.tileInfo[map.CoordToDataIndex(openNodeAtIndex.coord)];
				for (int i = 0; i < num3; i++)
				{
					int num5 = 1 << i;
					if ((num5 & num4) != 0)
					{
						v2i v2i2 = LUT_Direction[i];
						v2i coord = openNodeAtIndex.coord;
						coord.x += v2i2.x;
						coord.y += v2i2.y;
						if (!GetNavDataCoordIsOnListClosed(coord) && (pathValidator == null || pathValidator(coord)) && !GetNavDataCoordIsOnListOpen(coord))
						{
							PathNode pathNode = areaPool.AddNodetoOpenSet(coord, openNodeAtIndex);
							SetNavDataCoordOnListOpen(coord, (int)(areaPool.GetOpenSize() - 1));
							pathNode.costG = LUT_CostG[i] + pathNode.parent.costG;
							pathNode.costH = 0u;
							pathNode.costF = pathNode.costG + pathNode.costH;
							int[] costs = request.area.costs;
							int x2 = coord.x;
							int y = coord.y;
							v2i maxMapSize3 = Map.maxMapSize;
							costs[x2 + y * maxMapSize3.x] = Mathf.CeilToInt((float)pathNode.costF * 0.1f);
						}
					}
				}
			}
		}
		else
		{
			v2i v2i3 = default(v2i);
			for (int j = 0; j < map.size.x; j++)
			{
				v2i3.x = j;
				for (int k = 0; k < map.size.y; k++)
				{
					v2i3.y = k;
					if ((map.GetTileInfo(v2i3) & 0x10000) == 0)
					{
						int num6 = Mathf.RoundToInt(v2i.Distance(v2i3, startCoord));
						int[] costs2 = request.area.costs;
						int num7 = j;
						int num8 = k;
						v2i maxMapSize4 = Map.maxMapSize;
						costs2[num7 + num8 * maxMapSize4.x] = num6;
					}
				}
			}
			flag2 = true;
		}
		if (flag2)
		{
			int[] costs3 = request.area.costs;
			int x3 = startCoord.x;
			int y2 = startCoord.y;
			v2i maxMapSize5 = Map.maxMapSize;
			costs3[x3 + y2 * maxMapSize5.x] = 0;
			return true;
		}
		return false;
	}

	private bool ProcessNeighborRequest(NeighborRequest request)
	{
		Map map = request.unitAssociated.map;
		Neighbors neighbors = new Neighbors();
		neighbors.coordTarget = request.coordStart;
		neighbors.userData = request.userData;
		neighbors.status = PathStatus.Failed;
		int num = (int)request.directionIndex;
		if (num == -1)
		{
			num = 0;
		}
		v2i coordStart = request.coordStart;
		bool includeObstructedDiagonals = request.includeObstructedDiagonals;
		bool coordBlocked = map.GetCoordBlocked(coordStart);
		neighbors.coordsNeighbors.Clear();
		for (int i = 0; i < 5; i++)
		{
			if (i == 0)
			{
				uint num2 = (uint)num;
				v2i v2i2 = coordStart + LUT_Direction[num2];
				if (!map.GetCoordBlocked(v2i2) && (coordBlocked || includeObstructedDiagonals || !map.GetCoordDirectionBlocked(coordStart, num2)) && !GC.Inst.GetUnitAtCoord(v2i2))
				{
					neighbors.coordsNeighbors.Add(v2i2);
				}
			}
			else
			{
				uint num3 = (uint)((num + i + 8) % 8);
				uint num4 = (uint)((num - i + 8) % 8);
				v2i v2i3 = coordStart + LUT_Direction[num3];
				v2i v2i4 = coordStart + LUT_Direction[num4];
				int num5 = 0;
				if (includeObstructedDiagonals && i % 2 == 1)
				{
					num5 = Bitwise.BitRotate_u32(131, num);
				}
				if (!map.GetCoordBlocked(v2i3) && (coordBlocked || includeObstructedDiagonals || !map.GetCoordDirectionBlocked(coordStart, num3)) && !GC.Inst.GetUnitAtCoord(v2i3))
				{
					neighbors.coordsNeighbors.Add(v2i3);
				}
				if (!map.GetCoordBlocked(v2i4) && (coordBlocked || includeObstructedDiagonals || !map.GetCoordDirectionBlocked(coordStart, num4)) && !GC.Inst.GetUnitAtCoord(v2i4))
				{
					neighbors.coordsNeighbors.Add(v2i4);
				}
			}
			if (neighbors.coordsNeighbors.Count >= request.neighborNum)
			{
				neighbors.status = PathStatus.Complete;
				request.onComplete(neighbors, request.unitAssociated);
				return true;
			}
		}
		request.onComplete(neighbors, request.unitAssociated);
		return false;
	}

	public void ShortenPath(Path path, int length)
	{
		if (length < 1)
		{
			length = 1;
		}
		int num = path.positions.Count - length;
		if (num > 0)
		{
			path.positions.RemoveRange(length, num);
			path.pathInfo.RemoveRange(length, num);
			path.coordEnd = Singleton<MC>.Inst.GetActiveMap().LocalPosToCoord(path.positions[length - 1]);
			path.cost = 1000000;
		}
	}
}
public class PC : Singleton<PC>, ITeamController
{
	public enum SelectionResult
	{
		UnitIsNull,
		UnitAlreadySelected,
		UnitIsNotPlayer,
		UnitIsMoving,
		UnitIsDead,
		Success
	}

	private class UseAbility : HagletResettable
	{
		public enum Result
		{
			Used,
			Failed,
			Cancelled
		}

		public Unit leader;

		public Result result;

		public readonly Wrapper<UIAbilityWheelChoice> chosenAbility = Wrapper.Around<UIAbilityWheelChoice>();

		public UseAbility(PC pc)
			: base(pc.UseAbilityRoutine(), "PC_UseAbility", HagletStepTime.Update, -1, 5)
		{
		}

		protected UseAbility(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private class RPGControl : HagletResettable
	{
		public class GotLeaderCondition : HagletCondition, Serializer.ISelfConstructor
		{
			private readonly PC pc;

			public GotLeaderCondition(PC pc)
			{
				this.pc = pc;
			}

			public GotLeaderCondition(BinaryReader reader)
			{
			}

			void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
			{
			}

			protected override bool GetValue()
			{
				return pc.GetLeader() != null;
			}
		}

		public bool resettingForMissionResume = true;

		public Unit.Movement.Result moveResult;

		public readonly Unit.Movement.ResultHandler storeMoveResult;

		public RPGControl(PC pc)
			: base(pc.RPGControlRoutine(), "PC RPG Control")
		{
			storeMoveResult = delegate(Unit unit, Unit.Movement.Result res)
			{
				moveResult = res;
			};
		}

		public RPGControl(BinaryReader reader)
			: base(reader)
		{
			storeMoveResult = delegate(Unit unit, Unit.Movement.Result res)
			{
				moveResult = res;
			};
		}

		public void ResetOnMissionResume()
		{
			resettingForMissionResume = true;
			Reset();
		}
	}

	private UnitTeam.Type activeTeamType;

	private UseAbility useAbility;

	private RPGControl rpgControl;

	private HagletResettable turnControl;

	public AbilityImplBase activeAbility => (!useAbility.running) ? null : useAbility.chosenAbility.val.ability;

	public void OnAwakeLR()
	{
	}

	public void OnMissionSceneLoaded(MR mr)
	{
	}

	public void OnMissionStart(MR mr)
	{
		turnControl = new HagletResettable(TurnControl(), "PC Turn Control");
		rpgControl = new RPGControl(this);
		useAbility = new UseAbility(this);
		SetSelectedUnit(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMemberAtIndex(0));
	}

	public void OnMissionResume(MR mr)
	{
		rpgControl.ResetOnMissionResume();
	}

	public void OnMissionSceneUnloaded(MR mr)
	{
	}

	public void OnTeamInitialize(UnitTeam team)
	{
	}

	public SelectionResult SetSelectedUnit(Unit unit)
	{
		if (unit == null)
		{
			return SelectionResult.UnitIsNull;
		}
		if (!unit.IsAlive())
		{
			return SelectionResult.UnitIsDead;
		}
		if (unit.GetTeamType() != activeTeamType)
		{
			return SelectionResult.UnitIsNotPlayer;
		}
		if (unit == GetLeader())
		{
			return SelectionResult.UnitAlreadySelected;
		}
		if ((bool)unit.moving)
		{
			return SelectionResult.UnitIsMoving;
		}
		if ((bool)GetLeader())
		{
			GetLeader().OnSelectExit();
		}
		unit.GetTeam()._SetTeamLeader(unit);
		unit.OnSelectEnter();
		unit.map.VFXTiles.UnitSelectedShow(unit, forcePing: true);
		return SelectionResult.Success;
	}

	public Unit GetLeader()
	{
		return GetTeam().GetTeamLeader();
	}

	public UnitTeam GetTeam()
	{
		return GC.Inst.GetTeamOfType(activeTeamType);
	}

	public HagletYieldTerm ReviveAllMembers()
	{
		ConstArray<Unit> membersInWorld = GetTeam().GetMembersInWorld();
		for (int i = 0; i < membersInWorld.Length; i++)
		{
			Unit unit = membersInWorld[i];
			if (!unit.IsAlive() && !unit.HACK_isDecoyUnit)
			{
				unit.Revive();
				unit.HPDecrement(unit.HP - 1);
			}
			if (unit.HACK_isDecoyUnit && unit.IsAlive())
			{
				unit.KillIfDecoyUnit();
			}
		}
		return Wait.ForChildren;
	}

	public void OnUnitFinishedMoving(Unit unit)
	{
	}

	private HagletYieldTerm StartUseAbility(Unit leader)
	{
		useAbility.chosenAbility.val = default(UIAbilityWheelChoice);
		useAbility.leader = leader;
		return Routine.Start(useAbility);
	}

	public IEnumerator<HagletYieldTerm> UseAbilityRoutine()
	{
		ConstArray<Unit> abilityUnits = new ConstArray<Unit>(3u);
		ConstArray<v2i> abilityTiles = new ConstArray<v2i>(1u);
		yield return Routine.ResetToHere();
		Singleton<UIC>.Inst.Push<UIAbilityWheel>().SetState(useAbility.leader, useAbility.chosenAbility);
		HagletYieldTerm wheelCancelled = Wait.Until(UIAbilityWheel.Inst.OnCancelled);
		yield return UIAbilityWheel.Inst.OnAbilitySelected | wheelCancelled;
		AbilityImplBase ability = useAbility.chosenAbility.val.ability;
		useAbility.result = UseAbility.Result.Used;
		if (wheelCancelled.met)
		{
			useAbility.result = UseAbility.Result.Cancelled;
			yield break;
		}
		if (ability == null)
		{
			useAbility.result = UseAbility.Result.Cancelled;
			yield break;
		}
		ability.isActive = true;
		if (ability.IsAvailable(ability.owner) != 0)
		{
			useAbility.result = UseAbility.Result.Failed;
			ability.isActive = false;
			yield break;
		}
		if (ability.RequireUnitSelection() || ability.RequireTileSelection())
		{
			ability.OnSelectionBegin(ability.owner);
			ability.owner.map.VFXTiles.UnitSelectedHide();
			while (true)
			{
				UIStatusBar.Inst.HideEndTurnButtonForAbility(hide: true);
				uint abilityTeamMask = ability.SelectionMask(ability.owner);
				bool tileMode = ability.RequireTileSelection();
				SC.Inst.SetLeader(ability.owner).SetActiveAbility(ability).SetShowPath(showPath: true)
					.SetRangeFromLeader(ability.SelectionRange(ability.owner), ability.RequiresPathing())
					.SetVaultAllowed(ability.owner.IsVaultAllowed)
					.SetUnitSelectionTeamMask(abilityTeamMask)
					.SetPathTeamMask(abilityTeamMask)
					.SetTileMode(tileMode)
					.SetAreaFromCursor(ability.SelectionEffectRange(ability.owner), ability.RequireUnitSelection())
					.SetShowUnitTargets(ability.RequireUnitSelection())
					.SetExtraUnitFilter(ability.extraUnitFilter)
					.SetExtraTileFilter(ability.extraTileFilter)
					.SetShowUnitSelection(SC.UnitSelection.Any);
				if (tileMode)
				{
					SC.Inst.SetRequireUnblockedTile(ability.RequireTileUnblocked());
					SC.Inst.SetTileSelectionVFX(ability.tileSelectionVFX);
				}
				if (ability.RequiresPathing())
				{
					if (ability.SelectionRange(ability.owner) < int.MaxValue)
					{
						if (useAbility.leader.AP > 1)
						{
							SC.Inst.SetOpponentReachability(SC.UnitReachability.Reachable);
						}
						else
						{
							SC.Inst.SetOpponentReachability(SC.UnitReachability.Neighbour);
						}
					}
					else
					{
						SC.Inst.SetOpponentReachability(SC.UnitReachability.Any);
					}
				}
				else if (ability.SelectionRequireLineOfSight(ability.owner))
				{
					if (ability.SelectionAllowStepOut(ability.owner))
					{
						SC.Inst.SetOpponentReachability(SC.UnitReachability.LineOfSight);
					}
					else
					{
						SC.Inst.SetOpponentReachability(SC.UnitReachability.DirectLineOfSight);
					}
				}
				HagletYieldTerm hagletYieldTerm = IC.longHoldAction;
				HagletYieldTerm hagletYieldTerm2;
				HagletYieldTerm turnModeEndFlagged = (hagletYieldTerm2 = Wait.Until(GC.Inst.flagEndTurnMode));
				HagletYieldTerm hagletYieldTerm3 = hagletYieldTerm | hagletYieldTerm2;
				HagletYieldTerm backPressed = (hagletYieldTerm2 = IC.back);
				yield return hagletYieldTerm3 | hagletYieldTerm2;
				SC.Inst.Clear(cleanup: false);
				UIStatusBar.Inst.HideEndTurnButtonForAbility(hide: false);
				if (turnModeEndFlagged.met)
				{
					useAbility.result = UseAbility.Result.Cancelled;
					ability.isActive = false;
					yield break;
				}
				if (backPressed.met)
				{
					if (SC.Inst.ability != null)
					{
						SC.Inst.ability.OnSelectionCancel(SC.Inst.ability.owner);
					}
					ability.owner.map.VFXTiles.UnitSelectedShow(ability.owner, forcePing: true);
					useAbility.result = UseAbility.Result.Cancelled;
					ability.isActive = false;
					yield break;
				}
				if (ability.RequireUnitSelection())
				{
					if (SC.Inst.unitHighlighted == null)
					{
						continue;
					}
					BarkTypes? barkType = ability.GetAbilityBarkType(ability.owner).GetBarkType();
					if (barkType.HasValue)
					{
						ability.owner.PlayBark(barkType.Value);
					}
					abilityUnits.Add(SC.Inst.unitHighlighted);
					ability.OnActivateWithUnitsSelectedBase(ability.owner, abilityUnits, useAbility.chosenAbility.val);
					abilityUnits.Clear();
					break;
				}
				if (!ability.RequireTileSelection())
				{
					break;
				}
				if (!SC.Inst.coord.HasValue)
				{
					continue;
				}
				BarkTypes? barkType2 = ability.GetAbilityBarkType(ability.owner).GetBarkType();
				if (barkType2.HasValue)
				{
					ability.owner.PlayBark(barkType2.Value);
				}
				abilityTiles.Add(SC.Inst.coord.Value);
				ability.OnActivateWithTilesSelectedBase(ability.owner, abilityTiles, useAbility.chosenAbility.val);
				abilityTiles.Clear();
				break;
			}
		}
		else
		{
			BarkTypes? abilityBark = ability.GetAbilityBarkType(ability.owner).GetBarkType();
			if (abilityBark.HasValue)
			{
				ability.owner.PlayBark(abilityBark.Value);
			}
			ability.OnActivateImmediatelyBase(ability.owner, useAbility.chosenAbility.val);
			yield return Wait.ForChildren;
		}
		yield return Wait.ForChildren;
		ability.isActive = false;
	}

	public void OnRPGModeEnter(UnitTeam.Type teamType)
	{
		if (teamType == UnitTeam.Type.Player)
		{
			MR.Inst.Host.StartTopLevel(rpgControl, MR.Inst.mainHagisSequence);
		}
	}

	public void OnRPGModeExit(UnitTeam.Type teamType)
	{
		if (teamType == UnitTeam.Type.Player)
		{
			SC.Inst.Clear();
			if ((bool)GetLeader().moving)
			{
				GetLeader().StopMovement(immediate: true);
			}
			if ((bool)rpgControl.running)
			{
				MR.Inst.Host.Pause(rpgControl);
				rpgControl.Reset();
			}
		}
	}

	private IEnumerator<HagletYieldTerm> RPGControlRoutine()
	{
		Unit leader = null;
		RPGControl.GotLeaderCondition gotLeader = new RPGControl.GotLeaderCondition(this);
		yield return Routine.ResetToHere();
		rpgControl.resettingForMissionResume = false;
		while (true)
		{
			Routine.GoTopLevel();
			yield return Wait.Until(gotLeader);
			leader = GetLeader();
			if (Routine.IsSkipping() || leader == null)
			{
				continue;
			}
			int movementDistancePerTurn = leader.GetMovementDistancePerTurn();
			SC.Inst.SetLeader(leader).SetRangeFromLeader((movementDistancePerTurn != 0) ? int.MaxValue : 0, rangeRequiresPathing: true).SetShowPath(showPath: false)
				.SetUnitSelectionTeamMask(0u)
				.SetVaultAllowed(vaultAllowed: false)
				.SetTileActionAccessibility(SC.TileActionAccessibility.ReachableAndClearOfLeader);
			HagletYieldTerm hagletYieldTerm = IC.longHoldAction;
			HagletYieldTerm hagletYieldTerm2;
			HagletYieldTerm newRpgLeaderSet = (hagletYieldTerm2 = Wait.Until(GC.Inst.NewRpgLeaderWasSet));
			yield return hagletYieldTerm | hagletYieldTerm2;
			if (newRpgLeaderSet.met)
			{
				continue;
			}
			while (true)
			{
				if (SC.Inst.tileAction != null)
				{
					TileActionBase tileAction = SC.Inst.tileAction;
					NC.Path path2 = SC.Inst.path;
					if (tileAction.SpecificUnit != null && tileAction.SpecificUnit != leader)
					{
						break;
					}
					if (path2 != null)
					{
						RPGControl rPGControl = rpgControl;
						Unit unit = leader;
						v2i? destCoord = null;
						NC.Path path3 = path2;
						Unit.Movement.ResultHandler storeMoveResult = rpgControl.storeMoveResult;
						OctDir? actionDir = tileAction.actionDir;
						RPGControl skipAdopter = rpgControl;
						rPGControl.moveResult = unit.StartMovement(destCoord, path3, storeMoveResult, actionDir, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, skipAdopter);
						if (rpgControl.moveResult.IsFailure())
						{
							break;
						}
					}
					AC.Inst.PlayOneShot2D(tileAction.GetInteractFMODPath());
					if (tileAction is TileActionSwapMap)
					{
						leader.PlayBark(BarkTypes.MoveLeave);
					}
					if (path2 == null)
					{
						yield return tileAction.StartAction();
						break;
					}
					while (true)
					{
						HagletYieldTerm hagletYieldTerm3 = leader.movementStopped;
						HagletYieldTerm actionPressed = (hagletYieldTerm2 = IC.longHoldAction);
						yield return hagletYieldTerm3 | hagletYieldTerm2;
						if (!actionPressed.met)
						{
							break;
						}
						if (SC.Inst.path == null || SC.Inst.tileAction == tileAction)
						{
							continue;
						}
						goto IL_0394;
					}
					if (rpgControl.moveResult.IsSuccess())
					{
						while (!Singleton<UIC>.Inst.IsShown<UIStatusBar>())
						{
							yield return null;
						}
						yield return tileAction.StartAction();
					}
				}
				else
				{
					if (SC.Inst.path == null)
					{
						break;
					}
					NC.Path path = SC.Inst.path;
					if (leader.StartMovement(null, path).Failed())
					{
						break;
					}
					AC.Inst.PlayOneShot2D("event:/sfx/ui/movement confirm");
					while (true)
					{
						HagletYieldTerm hagletYieldTerm4 = leader.movementStopped;
						HagletYieldTerm actionPressed = (hagletYieldTerm2 = IC.longHoldAction);
						yield return hagletYieldTerm4 | hagletYieldTerm2 | GC.Inst.NewRpgLeaderWasSet;
						if (actionPressed.met)
						{
							if (SC.Inst.path == null || (SC.Inst.tileAction == null && SC.Inst.path.coordEnd == path.coordEnd))
							{
								continue;
							}
							goto IL_055e;
						}
						break;
					}
				}
				break;
				IL_055e:
				leader.StopMovement(immediate: true);
				continue;
				IL_0394:
				leader.StopMovement(immediate: true);
			}
		}
	}

	public void OnTurnModeEnter()
	{
	}

	public void OnTurnModeExit()
	{
		if (!GC.Inst.IsInMultiplayer())
		{
			activeTeamType = UnitTeam.Type.Player;
		}
	}

	public HagletYieldTerm TakeAction()
	{
		return Routine.Start(turnControl);
	}

	public void OnTurnEnd()
	{
		SC.Inst.Clear();
	}

	private IEnumerator<HagletYieldTerm> TurnControl()
	{
		UnitTeam team = null;
		Func<bool> noUnitWithAP = () => team.FindNextUnitWithAP() == null;
		Unit.Movement.Result moveResult;
		Unit.Movement.ResultHandler storeMoveResult = delegate(Unit unit, Unit.Movement.Result res)
		{
			moveResult = res;
		};
		yield return Routine.ResetToHere();
		activeTeamType = GC.Inst.GetActiveTeamType();
		team = GC.Inst.GetActiveTeam();
		Unit leader = GetLeader();
		if (leader.AP <= 0)
		{
			ChangeLeaderToNextWithAP();
		}
		while (true)
		{
			yield return Wait.While(GC.Inst.AnyUnitActing);
			SC inst = SC.Inst;
			Unit leader3;
			leader = (leader3 = GetLeader());
			inst.SetLeader(leader3).SetRangeFromLeader((leader.AP > 0) ? leader.GetMovementDistancePerTurn() : 0, rangeRequiresPathing: true).SetShowPath(showPath: true)
				.SetVaultAllowed(leader.IsVaultAllowed);
			if (leader.mainWeapon.IsRanged)
			{
				SC.Inst.SetOpponentReachability(SC.UnitReachability.LineOfSight);
			}
			else if (leader.AP > 1)
			{
				SC.Inst.SetOpponentReachability(SC.UnitReachability.Reachable);
			}
			else
			{
				SC.Inst.SetOpponentReachability(SC.UnitReachability.Neighbour);
			}
			if (leader.AP > 0)
			{
				SC.Inst.SetTileActionAccessibility(SC.TileActionAccessibility.ReachableAndClear);
			}
			else
			{
				SC.Inst.SetTileActionAccessibility(SC.TileActionAccessibility.None);
			}
			if (leader.IsAttackingDisabled || (GC.Inst.IsInMultiplayer() && GetTeam().IsFirstTurn) || leader.AP <= 0)
			{
				SC.Inst.SetUnitSelectionTeamMask(activeTeamType.ToMask());
				SC.Inst.SetPathTeamMask(0u);
			}
			else
			{
				SC.Inst.SetUnitSelectionTeamMask(UnitTeam.Type.Player.ToMask() | UnitTeam.Type.Enemy.ToMask() | UnitTeam.Type.Opponent.ToMask());
				SC.Inst.SetPathTeamMask(~activeTeamType.ToMask() & ~UnitTeam.Type.NPC.ToMask());
			}
			HagletYieldTerm hagletYieldTerm = IC.longHoldAction | IC.gearVRWheelUp;
			HagletYieldTerm hagletYieldTerm2;
			HagletYieldTerm turnModeEndFlagged = (hagletYieldTerm2 = Wait.Until(GC.Inst.flagEndTurnMode));
			HagletYieldTerm hagletYieldTerm3 = hagletYieldTerm | hagletYieldTerm2;
			HagletYieldTerm teamLostAllAP = (hagletYieldTerm2 = Wait.Until(noUnitWithAP));
			yield return hagletYieldTerm3 | hagletYieldTerm2;
			SC.Inst.Clear(cleanup: false);
			if (Routine.IsSkipping())
			{
				yield break;
			}
			if (teamLostAllAP.met || turnModeEndFlagged.met)
			{
				break;
			}
			TileActionBase tileAction2;
			TileActionBase tileAction = (tileAction2 = SC.Inst.tileAction);
			if (tileAction2 != null)
			{
				bool tileActionRequiresMovement = SC.Inst.path != null && SC.Inst.path.coordEnd != SC.Inst.path.coordStart;
				int tileActionApCost = 0;
				if (tileAction.costsAp)
				{
					tileActionApCost++;
				}
				if (tileActionRequiresMovement)
				{
					tileActionApCost++;
				}
				if (leader.AP < tileActionApCost)
				{
					leader.popupBar.Enqueue("POPUPBAR_TILEACTION_INSUFFICIENTAP");
					continue;
				}
				if (tileActionRequiresMovement)
				{
					moveResult = leader.StartMovement(null, SC.Inst.path, storeMoveResult, tileAction.actionDir);
					if (moveResult.IsFailure())
					{
						continue;
					}
					leader.APDecrement(1);
				}
				else if (tileAction.actionDir.HasValue)
				{
					leader.LookInDirection(tileAction.actionDir.Value);
				}
				if (tileAction.SpecificUnit != null && tileAction.SpecificUnit != leader)
				{
					continue;
				}
				yield return Wait.ForChildren;
				yield return tileAction.StartAction();
				if (tileAction.costsAp)
				{
					leader.APDecrement(1);
				}
			}
			else if (SC.Inst.unitHighlighted == leader && !LR.Inst.IsPaused())
			{
				if (!UIAbilityWheel.Inst.HACK_disableDuringTutorial)
				{
					yield return StartUseAbility(leader);
					if (useAbility.result != 0)
					{
						continue;
					}
				}
			}
			else if (SC.Inst.unitHighlighted == null)
			{
				if (SC.Inst.path == null)
				{
					continue;
				}
				AC.Inst.PlayOneShot2D("event:/sfx/ui/movement confirm");
				if (leader.StartMovement(null, SC.Inst.path).Failed())
				{
					continue;
				}
				leader.APDecrement(1);
				yield return Wait.ForChildren;
			}
			else
			{
				if (SC.Inst.unitHighlighted.teamType == activeTeamType)
				{
					if (SC.Inst.unitHighlighted != leader)
					{
						ChangeLeader(ref leader, SC.Inst.unitHighlighted);
						break;
					}
					continue;
				}
				Unit victim = SC.Inst.unitHighlighted;
				if (!leader.mainWeapon.IsRanged && !v2i.IsNeighbour(leader.coord, victim.coord))
				{
					if (SC.Inst.path == null || leader.AP < 2 || leader.StartMovement(null, SC.Inst.path).Failed())
					{
						continue;
					}
					leader.APDecrement(1);
					yield return Wait.ForChildren;
				}
				if (victim.IsAlive())
				{
					if (!leader.StartAttack(victim, leader.mainWeapon, costsAP: true, Unit.IfTooFar.InvalidateAction, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.AttackWhamBar))
					{
						continue;
					}
					yield return Wait.ForChildren;
				}
			}
			if (team.GetActiveMembers().Length != 0)
			{
				yield return null;
				if (leader.AP <= 0 && ChangeLeaderToNextWithAP())
				{
				}
			}
			break;
		}
		yield return Wait.While(GC.Inst.AnyUnitActing) & Wait.While(GC.Inst.InCutsceneMode);
	}

	public bool ChangeLeaderToNextWithAP()
	{
		Unit leader = GetLeader();
		Unit unit = leader.GetTeam().FindNextUnitWithAP();
		if (unit == null)
		{
			return false;
		}
		ChangeLeader(ref leader, unit);
		return true;
	}

	private void ChangeLeader(ref Unit leader, Unit newLeader)
	{
		leader.OnSelectExit();
		leader = newLeader;
		GetTeam()._SetTeamLeader(leader);
		leader.OnSelectEnter();
		SC.Inst.SetLeader(leader);
	}

	public void OnUnitDeath(Unit unit)
	{
	}
}
public class ParticleSystemFromPool : GameObjectPool<ParticlePrefab, ParticleSystemFromPool>.GOFromPool
{
	public ParticlePrefab prefab;

	private float timeToDestroy;

	public override void OnReady()
	{
		timeToDestroy = pr.component.duration * 2f;
	}

	public override void OnStop()
	{
		timeToDestroy = 0f;
		base.gameObject.SetActive(value: false);
	}

	private void LateUpdate()
	{
		if (timeToDestroy > 0f)
		{
			if ((!pr.component.loop || !pr.component.isPlaying) && !pr.component.IsPaused)
			{
				timeToDestroy -= Time.deltaTime;
			}
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class ParticlePrefabPool : GameObjectPool<ParticlePrefab, ParticleSystemFromPool>
{
	protected override void OnAllocate(ParticlePrefab newObject, ParticleSystemFromPool newWatcher)
	{
		Renderer[] componentsInChildren = newObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		Renderer[] array = componentsInChildren;
		foreach (Renderer render in array)
		{
			VFXTileController.SetSortingOrder(render);
		}
		newWatcher.prefab = newObject.GetComponent<ParticlePrefab>();
		if ((bool)newWatcher.prefab)
		{
			newWatcher.prefab.ps = newObject.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
			newWatcher.prefab.particleType = newObject.particleType;
		}
	}
}
public class PSC : MonoBehaviour
{
	private static PSC _inst;

	public readonly HagletFlag allPoolsLoaded = new HagletFlag();

	private bool paused;

	private ParticlePrefabPool[] particlePrefabPools;

	private ParticlePrefab[] loadedPrefabs;

	private PoolUpdateRunner updateRunner;

	public static PSC Inst
	{
		get
		{
			if (_inst == null)
			{
				_inst = UnityEngine.Object.Instantiate(Resources.Load<PSC>("Controllers/P_ParticleSystemController"));
				UnityEngine.Object.DontDestroyOnLoad(_inst);
			}
			return _inst;
		}
	}

	public int LoadedPoolCount { get; private set; }

	public int TotalPoolCount => particlePrefabPools.Length;

	private void Awake()
	{
		updateRunner = base.gameObject.AddComponent<PoolUpdateRunner>();
		loadedPrefabs = AEResources.LoadAllResources<ParticlePrefab>("Particles");
		particlePrefabPools = new ParticlePrefabPool[loadedPrefabs.Length];
		allPoolsLoaded.Clear();
		Routine.Start(new HagletResettable(SetupParticleSystems()), LR.Host);
	}

	public IEnumerator<HagletYieldTerm> SetupParticleSystems()
	{
		int i;
		for (i = 0; i < loadedPrefabs.Length; i++)
		{
			SetupPrefabPool(loadedPrefabs[i].particleType);
			if (particlePrefabPools[i] == null)
			{
				UnityEngine.Debug.LogError("Failed to setup pool for " + loadedPrefabs[i].particleType);
				yield return null;
			}
			else
			{
				yield return Wait.While(() => particlePrefabPools[i].TotalInstCount < particlePrefabPools[i].initialSize);
			}
			LoadedPoolCount++;
		}
		HashSet<Material> mpSet = new HashSet<Material>();
		Material[] pp = Inst.GetAllParticleMaterials();
		Material[] array = pp;
		foreach (Material item in array)
		{
			mpSet.Add(item);
		}
		foreach (Material item2 in mpSet)
		{
			item2.DisableKeyword("HOLOGRAM_ON");
		}
		allPoolsLoaded.Set();
	}

	public ParticlePrefabPool SetupPrefabPool(ParticleTypes pt)
	{
		if (loadedPrefabs == null)
		{
			return null;
		}
		ParticlePrefab particlePrefab = null;
		int num = 0;
		for (int i = 0; i < loadedPrefabs.Length; i++)
		{
			if (loadedPrefabs[i].particleType == pt)
			{
				particlePrefab = loadedPrefabs[i];
				num = i;
				break;
			}
		}
		if (particlePrefab != null && particlePrefabPools[num] == null)
		{
			ParticlePrefabPool particlePrefabPool = base.gameObject.AddComponent<ParticlePrefabPool>();
			particlePrefabPools[num] = particlePrefabPool;
			particlePrefabPool.updateRunner = updateRunner;
			particlePrefabPool.sourcePrefab = particlePrefab;
			particlePrefabPool.initialSize = 5;
			particlePrefabPool.maxSize = 10;
			particlePrefabPool.Init(fillImmediately: false);
			ParticleSystemRenderer component = particlePrefabPool.sourcePrefab.GetComponent<ParticleSystemRenderer>();
			if ((bool)component && (bool)component.sharedMaterial)
			{
				component.sharedMaterial.renderQueue = 3600;
			}
			return particlePrefabPool;
		}
		return null;
	}

	public ParticlePrefab Play(ParticleTypes particleType, Transform parent)
	{
		return Play(particleType, Vector3.zero, Quaternion.identity, Vector3.one, parent);
	}

	public ParticlePrefab Play(ParticleTypes particleType, Map map, v2i coord)
	{
		return Play(particleType, map.CoordToLocalPos(coord), Quaternion.identity, Vector3.one, map.transform);
	}

	public ParticlePrefab Play(ParticleTypes particleType, Vector3 localPosition, Quaternion localRotation, Vector3 localScale, Transform parent = null, bool clear = false)
	{
		Vector3 worldPostion = ((!(parent == null)) ? parent.TransformPoint(localPosition) : localPosition);
		ParticlePrefab particlePrefab = Get(particleType, worldPostion, parent);
		Transform transform = particlePrefab.transform;
		transform.localRotation = localRotation;
		transform.localScale = localScale;
		Vector3 vector = Vector3.up * 0.01f;
		transform.localPosition += vector;
		if (clear)
		{
			particlePrefab.StopParticles();
			particlePrefab.ClearParticles();
		}
		particlePrefab.PlayParticles();
		return particlePrefab;
	}

	public ParticlePrefab PlayAt(ParticleTypes particleType, Vector3 position, bool clear = true)
	{
		ParticlePrefab particlePrefab = Get(particleType, position);
		Transform transform = particlePrefab.transform;
		if (clear)
		{
			particlePrefab.StopParticles();
			particlePrefab.ClearParticles();
		}
		particlePrefab.PlayParticles();
		return particlePrefab;
	}

	public ParticlePrefab Get(ParticleTypes particleType, Vector3 worldPostion, Transform parent = null, bool active = true)
	{
		ParticlePrefabPool pool = GetPool(particleType);
		ParticleSystemFromPool watcher;
		return pool.Get(out watcher, worldPostion, parent, active);
	}

	public ParticlePrefabPool GetPool(ParticleTypes particleType)
	{
		ParticlePrefabPool particlePrefabPool = null;
		for (int i = 0; i < particlePrefabPools.Length; i++)
		{
			if (!(particlePrefabPools[i] == null) && particlePrefabPools[i].sourcePrefab.particleType == particleType)
			{
				particlePrefabPool = particlePrefabPools[i];
				break;
			}
		}
		if (particlePrefabPool == null)
		{
			particlePrefabPool = SetupPrefabPool(particleType);
		}
		return particlePrefabPool;
	}

	public void SetPaused(bool pause)
	{
		if (paused == pause)
		{
			return;
		}
		for (int i = 0; i < particlePrefabPools.Length; i++)
		{
			if (!(particlePrefabPools[i] != null))
			{
				continue;
			}
			foreach (GameObjectPool<ParticlePrefab, ParticleSystemFromPool>.PoolReferences activeObject in particlePrefabPools[i]._activeObjects)
			{
				if (pause)
				{
					activeObject.component.PauseParticles();
				}
				else
				{
					activeObject.component.PlayParticles();
				}
			}
		}
		paused = pause;
	}

	public Material[] GetAllParticleMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < loadedPrefabs.Length; i++)
		{
			Renderer[] componentsInChildren = loadedPrefabs[i].GetComponentsInChildren<Renderer>();
			Renderer[] array = componentsInChildren;
			foreach (Renderer renderer in array)
			{
				if (renderer.sharedMaterial != null)
				{
					hashSet.Add(renderer.sharedMaterial);
				}
			}
		}
		return hashSet.ToArray();
	}
}
[Serializer.ExcludeEnabled]
public class SC : HagletBehaviour
{
	public enum CursorAreaType
	{
		Tiles,
		Units
	}

	public enum UnitReachability
	{
		Any,
		LineOfSight,
		Reachable,
		Neighbour,
		DirectLineOfSight
	}

	public enum UnitSelection
	{
		None,
		Leader,
		Any
	}

	public enum TileActionAccessibility
	{
		None,
		ReachableAndClearOfLeader,
		ReachableAndClear
	}

	[Serializable]
	private struct UnitHighlightState
	{
		public enum Type
		{
			Select,
			Attack
		}

		public Unit unit;

		public Type type;

		public static bool operator ==(UnitHighlightState left, UnitHighlightState right)
		{
			return left.unit == right.unit && left.type == right.type;
		}

		public static bool operator !=(UnitHighlightState left, UnitHighlightState right)
		{
			return left.unit != right.unit || left.type != right.type;
		}
	}

	[Serializable]
	private struct AreaState
	{
		public v2i? origin;

		public int range;

		public bool pathing;

		public static bool operator ==(AreaState left, AreaState right)
		{
			v2i? v2i2 = left.origin;
			bool hasValue = v2i2.HasValue;
			v2i? v2i3 = right.origin;
			return hasValue == v2i3.HasValue && (!v2i2.HasValue || v2i2.GetValueOrDefault() == v2i3.GetValueOrDefault()) && left.range == right.range && left.pathing == right.pathing;
		}

		public static bool operator !=(AreaState left, AreaState right)
		{
			v2i? v2i2 = left.origin;
			bool hasValue = v2i2.HasValue;
			v2i? v2i3 = right.origin;
			return hasValue != v2i3.HasValue || (v2i2.HasValue && v2i2.GetValueOrDefault() != v2i3.GetValueOrDefault()) || left.range != right.range || left.pathing != right.pathing;
		}
	}

	[Serializable]
	private struct PathState
	{
		public Vector3? start;

		public v2i? end;

		public bool show;

		public static bool operator ==(PathState left, PathState right)
		{
			Vector3? vector = left.start;
			bool hasValue = vector.HasValue;
			Vector3? vector2 = right.start;
			int result;
			if (hasValue == vector2.HasValue && (!vector.HasValue || vector.GetValueOrDefault() == vector2.GetValueOrDefault()))
			{
				v2i? v2i2 = left.end;
				bool hasValue2 = v2i2.HasValue;
				v2i? v2i3 = right.end;
				if (hasValue2 == v2i3.HasValue && (!v2i2.HasValue || v2i2.GetValueOrDefault() == v2i3.GetValueOrDefault()))
				{
					result = ((left.show == right.show) ? 1 : 0);
					goto IL_00b3;
				}
			}
			result = 0;
			goto IL_00b3;
			IL_00b3:
			return (byte)result != 0;
		}

		public static bool operator !=(PathState left, PathState right)
		{
			Vector3? vector = left.start;
			bool hasValue = vector.HasValue;
			Vector3? vector2 = right.start;
			int result;
			if (hasValue == vector2.HasValue && (!vector.HasValue || !(vector.GetValueOrDefault() != vector2.GetValueOrDefault())))
			{
				v2i? v2i2 = left.end;
				bool hasValue2 = v2i2.HasValue;
				v2i? v2i3 = right.end;
				if (hasValue2 == v2i3.HasValue && (!v2i2.HasValue || !(v2i2.GetValueOrDefault() != v2i3.GetValueOrDefault())))
				{
					result = ((left.show != right.show) ? 1 : 0);
					goto IL_00b6;
				}
			}
			result = 1;
			goto IL_00b6;
			IL_00b6:
			return (byte)result != 0;
		}
	}

	[Serializable]
	private struct CursorAreaState
	{
		public v2i? origin;

		public float radius;

		public bool unitType;

		public VFXTileController.TileAreaVFXDel tileSelectionVFX;

		public static bool operator ==(CursorAreaState left, CursorAreaState right)
		{
			v2i? v2i2 = left.origin;
			bool hasValue = v2i2.HasValue;
			v2i? v2i3 = right.origin;
			return hasValue == v2i3.HasValue && (!v2i2.HasValue || v2i2.GetValueOrDefault() == v2i3.GetValueOrDefault()) && left.radius == right.radius && left.tileSelectionVFX == right.tileSelectionVFX;
		}

		public static bool operator !=(CursorAreaState left, CursorAreaState right)
		{
			return !(left == right);
		}
	}

	[Serializable]
	private struct Configuration
	{
		public Unit leader;

		public AbilityImplBase activeAbility;

		public int rangeFromLeader;

		public bool showPath;

		public bool rangeRequiresPathing;

		public bool vaultAllowed;

		public bool tileMode;

		public bool requireUnblockedTile;

		public bool cursorAreaUnitType;

		public bool showUnitTargets;

		public UnitSelection showUnitSelection;

		public uint unitSelectionTeamMask;

		public uint pathTeamMask;

		public UnitReachability opponentReachability;

		public TileActionAccessibility tileActionAccessibility;

		public float cursorAreaRadius;

		public Func<Unit, bool> extraUnitFilter;

		public Func<v2i, bool> extraTileFilter;

		public VFXTileController.TileAreaVFXDel tileSelectionVFX;

		public static bool operator ==(Configuration left, Configuration right)
		{
			return left.leader == right.leader && left.activeAbility == right.activeAbility && left.rangeFromLeader == right.rangeFromLeader && left.showPath == right.showPath && left.rangeRequiresPathing == right.rangeRequiresPathing && left.vaultAllowed == right.vaultAllowed && left.tileMode == right.tileMode && left.requireUnblockedTile == right.requireUnblockedTile && left.cursorAreaUnitType == right.cursorAreaUnitType && left.showUnitTargets == right.showUnitTargets && left.showUnitSelection == right.showUnitSelection && left.unitSelectionTeamMask == right.unitSelectionTeamMask && left.pathTeamMask == right.pathTeamMask && left.opponentReachability == right.opponentReachability && left.tileActionAccessibility == right.tileActionAccessibility && left.cursorAreaRadius == right.cursorAreaRadius && left.extraUnitFilter == right.extraUnitFilter && left.extraTileFilter == right.extraTileFilter && left.tileSelectionVFX == right.tileSelectionVFX;
		}

		public static bool operator !=(Configuration left, Configuration right)
		{
			return !(left == right);
		}
	}

	private Configuration conf;

	[Serializer.Exclude]
	private Configuration cConf;

	[Serializer.Exclude]
	private Map map;

	[Serializer.Exclude]
	private bool mapInteractable;

	[Serializer.Exclude]
	private Area area;

	[Serializer.Exclude]
	private UnitHighlightState unitHighlightState;

	[Serializer.Exclude]
	private AreaState rangeFromLeaderState;

	[Serializer.Exclude]
	private PathState pathState;

	[Serializer.Exclude]
	private CursorAreaState cursorAreaState;

	[Serializer.Exclude]
	private HagletResettable calculatePath;

	[Serializer.Exclude]
	private HagletResettable updateAllUnitStatusBarsRoutine;

	private static readonly VFXTileController.TileAreaVFXDel invalidAreaVFX = (v2i centerCoord, v2i coord) => VFXTileController.TileType.AreaSelectionInvalid;

	public bool HACK_tutorialMode;

	private bool updateStatusBarCover;

	public static SC Inst { get; private set; }

	[Serializer.Exclude]
	public v2i? coord { get; private set; }

	[Serializer.Exclude]
	public v2i? displayCoord { get; private set; }

	[Serializer.Exclude]
	public TileActionBase tileAction { get; private set; }

	[Serializer.Exclude]
	public Unit unitHighlighted { get; private set; }

	public Unit unitLookedAt { get; private set; }

	[Serializer.Exclude]
	public NC.Path path { get; private set; }

	public AbilityImplBase ability => cConf.activeAbility;

	[Serializer.Exclude]
	public Unit xrayUnit { get; private set; }

	protected override HagletHost host => LR.Host;

	protected override string enabledHagletName => "Selection Control";

	protected override int enabledYieldTermCap => 1;

	protected override bool resetEnabled => true;

	private void Awake()
	{
		Inst = this;
		calculatePath = new HagletResettable(CalculatePath(), "Calculate Path", HagletStepTime.Update, -1, 1);
		updateAllUnitStatusBarsRoutine = new HagletResettable(UpdateAllUnitStatusBarsRoutine(), "UpdateUnitSatusBars");
		area = new Area();
		Clear();
	}

	public void OnDestroy()
	{
		Inst = null;
	}

	public SC SetLeader(Unit leader)
	{
		conf.leader = leader;
		return this;
	}

	public Unit GetLeader()
	{
		return conf.leader;
	}

	public SC SetActiveAbility(AbilityImplBase ability)
	{
		conf.activeAbility = ability;
		return this;
	}

	public AbilityImplBase GetActiveAbility()
	{
		return conf.activeAbility;
	}

	public SC SetRangeFromLeader(int rangeFromLeader, bool rangeRequiresPathing)
	{
		conf.rangeFromLeader = rangeFromLeader;
		conf.rangeRequiresPathing = rangeRequiresPathing;
		return this;
	}

	public SC SetShowPath(bool showPath)
	{
		conf.showPath = showPath;
		return this;
	}

	public SC SetUnitSelectionTeamMask(uint teamMask)
	{
		conf.unitSelectionTeamMask = teamMask;
		return this;
	}

	public SC SetPathTeamMask(uint teamMask)
	{
		conf.pathTeamMask = teamMask;
		return this;
	}

	public SC SetVaultAllowed(bool vaultAllowed)
	{
		conf.vaultAllowed = vaultAllowed;
		return this;
	}

	public SC SetOpponentReachability(UnitReachability opponentReachability)
	{
		conf.opponentReachability = opponentReachability;
		return this;
	}

	public SC SetRequireUnblockedTile(bool requireUnblockedTile)
	{
		conf.requireUnblockedTile = requireUnblockedTile;
		return this;
	}

	public SC SetTileSelectionVFX(VFXTileController.TileAreaVFXDel tileSelectionVFX)
	{
		conf.tileSelectionVFX = tileSelectionVFX;
		return this;
	}

	public SC SetTileActionAccessibility(TileActionAccessibility tileActionAccessibility)
	{
		conf.tileActionAccessibility = tileActionAccessibility;
		return this;
	}

	public SC SetTileMode(bool enabled)
	{
		conf.tileMode = enabled;
		return this;
	}

	public SC SetAreaFromCursor(float cursorAreaRadius, bool cursorAreaUnitType)
	{
		conf.cursorAreaRadius = cursorAreaRadius;
		conf.cursorAreaUnitType = cursorAreaUnitType;
		return this;
	}

	public SC SetShowUnitTargets(bool showUnitTargets)
	{
		conf.showUnitTargets = showUnitTargets;
		return this;
	}

	public SC SetShowUnitSelection(UnitSelection showUnitSelection)
	{
		conf.showUnitSelection = showUnitSelection;
		return this;
	}

	public SC SetExtraUnitFilter(Func<Unit, bool> extraUnitFilter)
	{
		conf.extraUnitFilter = extraUnitFilter;
		return this;
	}

	public SC SetExtraTileFilter(Func<v2i, bool> extraTileFilter)
	{
		conf.extraTileFilter = extraTileFilter;
		return this;
	}

	public SC Clear(bool cleanup = true)
	{
		SetLeader(null);
		SetActiveAbility(null);
		SetRangeFromLeader(int.MaxValue, rangeRequiresPathing: true);
		SetShowPath(showPath: false);
		SetUnitSelectionTeamMask(uint.MaxValue);
		SetPathTeamMask(uint.MaxValue);
		SetVaultAllowed(vaultAllowed: false);
		SetOpponentReachability(UnitReachability.Any);
		SetTileActionAccessibility(TileActionAccessibility.None);
		SetTileMode(enabled: false);
		SetRequireUnblockedTile(requireUnblockedTile: false);
		SetAreaFromCursor(0f, cursorAreaUnitType: false);
		SetShowUnitTargets(showUnitTargets: false);
		SetTileSelectionVFX(null);
		SetShowUnitSelection(UnitSelection.Any);
		if (!HACK_tutorialMode)
		{
			SetExtraUnitFilter(null);
			SetExtraTileFilter(null);
		}
		if (cleanup)
		{
			CleanupUnitHighlighted();
			CleanupUnitHighlight();
			CleanupUnitLookedAt();
			CleanupTileAction();
			CleanupRangeFromLeader();
			CleanupPath();
			CleanupXRayUnit();
			CleanupCursorArea();
		}
		return this;
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		map = Singleton<MC>.Inst.GetActiveMap();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		coord = null;
		CleanupUnitHighlighted();
		CleanupUnitHighlight();
		CleanupUnitLookedAt();
		CleanupTileAction();
		CleanupRangeFromLeader();
		CleanupPath();
		CleanupXRayUnit();
		CleanupCursorArea();
	}

	protected override IEnumerator<HagletYieldTerm> EnabledRoutine()
	{
		while (true)
		{
			Unit rayUnit = null;
			TileActionBase rayTileAction = null;
			UpdateMapInteractable();
			bool hasConfigUpdated = cConf != conf;
			cConf = conf;
			if (hasConfigUpdated)
			{
				UpdateUnitColliders();
			}
			yield return UpdateRangeFromLeader();
			UpdateCoordAndRay(ref rayUnit, ref rayTileAction);
			yield return UpdatePath(rayUnit, rayTileAction);
			UpdateUnit(rayUnit);
			UpdateUnitHighlight();
			UpdateUnitLookedAt(rayUnit);
			UpdateTileAction(rayTileAction);
			UpdateXRayUnit();
			UpdateCursorArea();
			if (hasConfigUpdated)
			{
				UpdateUnitTargets();
				Unit activeUnit = GC.Inst.GetActiveUnit();
				if (activeUnit != null)
				{
					UpdateAllUnitStatusBars();
				}
			}
			yield return Wait.ForSteps(1uL);
		}
	}

	public void UpdateAllUnitStatusBars(bool updateCover = false)
	{
		updateStatusBarCover = updateCover;
		HagletResettable.StartOrReset(updateAllUnitStatusBarsRoutine, LR.Host);
	}

	private IEnumerator<HagletYieldTerm> UpdateAllUnitStatusBarsRoutine()
	{
		ConstArray<Unit> allActiveUnits = GC.Inst.GetUnitsActive();
		int i = 0;
		for (int q = allActiveUnits.sLength; i < q; i++)
		{
			if (!GC.Inst.IsInCombatMode())
			{
				break;
			}
			if (allActiveUnits[i].IsAlive())
			{
				UIUnitStatusBar statusBar = allActiveUnits[i].statusBar;
				bool updateCover = updateStatusBarCover;
				statusBar.UpdateDisplay(immediate: false, updateCover);
				yield return null;
			}
		}
	}

	private void UpdateMapInteractable()
	{
		mapInteractable = false;
		if (!GC.Inst.IsInCutsceneMode() && !UIAbilityWheel.Inst.IsWheelShown && !Singleton<MC>.Inst.transitioning && Singleton<UIC>.Inst.IsShown<UIStatusBar>() && !UIWhamBar.Inst.IsShown)
		{
			mapInteractable = true;
		}
	}

	public bool IsMapInteractable()
	{
		return mapInteractable;
	}

	private HagletYieldTerm UpdateRangeFromLeader()
	{
		AreaState areaState = default(AreaState);
		if (mapInteractable && cConf.leader != null && cConf.rangeFromLeader > 0 && cConf.rangeFromLeader < int.MaxValue)
		{
			areaState.origin = cConf.leader.coord;
			areaState.range = cConf.rangeFromLeader;
			areaState.pathing = cConf.rangeRequiresPathing;
		}
		if (areaState == rangeFromLeaderState)
		{
			return Wait.None;
		}
		CleanupRangeFromLeader();
		v2i? origin = areaState.origin;
		if (origin.HasValue)
		{
			rangeFromLeaderState = areaState;
			return area.Update(map, rangeFromLeaderState.origin.Value, rangeFromLeaderState.range, rangeFromLeaderState.pathing, showArea: true, cConf.vaultAllowed);
		}
		return Wait.None;
	}

	private void CleanupRangeFromLeader()
	{
		v2i? origin = rangeFromLeaderState.origin;
		if (origin.HasValue)
		{
			map.VFXTiles.AreaHide();
			area.Clear();
			rangeFromLeaderState = default(AreaState);
		}
	}

	private void UpdateCoordAndRay(ref Unit rayUnit, ref TileActionBase rayTileAction)
	{
		Map.TileHit hit = default(Map.TileHit);
		bool flag = map.Raycast(IC.Inst.transform.position, IC.Inst.transform.forward, out hit, out rayUnit, out rayTileAction, GC.Inst.GetState());
		if (flag)
		{
			v2i value = hit.coord;
			v2i? v2i2 = displayCoord;
			if (value != v2i2)
			{
				displayCoord = hit.coord;
			}
		}
		else
		{
			displayCoord = null;
		}
		bool flag2 = false;
		if (mapInteractable && flag)
		{
			v2i? v2i3 = coord;
			if ((!v2i3.HasValue || v2i3.GetValueOrDefault() != hit.coord) && (!cConf.tileMode || !cConf.requireUnblockedTile || !map.GetCoordBlocked(hit.coord)))
			{
				if (!(cConf.leader == null))
				{
					v2i? origin = rangeFromLeaderState.origin;
					if (origin.HasValue && area.GetCost(hit.coord) > cConf.rangeFromLeader)
					{
						goto IL_021c;
					}
				}
				if (cConf.extraTileFilter == null || cConf.extraTileFilter(hit.coord))
				{
					coord = hit.coord;
					if (coord.HasValue && !map.GetCoordBlocked(coord.Value))
					{
						PSC.Inst.Play(ParticleTypes.TileEnterFocus, map, hit.coord);
					}
					Unit activeUnit = GC.Inst.GetActiveUnit();
					if (activeUnit != null)
					{
						UpdateAllUnitStatusBars();
					}
					flag2 = true;
				}
			}
		}
		goto IL_021c;
		IL_021c:
		if (!flag2)
		{
			v2i? v2i4 = coord;
			if (!v2i4.HasValue || v2i4.GetValueOrDefault() != hit.coord)
			{
				coord = null;
			}
		}
	}

	private HagletYieldTerm UpdatePath(Unit rayUnit, TileActionBase rayTileAction)
	{
		PathState newPathState = default(PathState);
		if (mapInteractable && cConf.leader != null && cConf.rangeFromLeader > 0 && cConf.rangeRequiresPathing && cConf.leader.map.IsActive)
		{
			if (rayUnit != null)
			{
				if ((rayUnit.teamMask & cConf.pathTeamMask) != 0 && cConf.opponentReachability != UnitReachability.LineOfSight && cConf.opponentReachability != UnitReachability.DirectLineOfSight && cConf.opponentReachability != UnitReachability.Neighbour && !v2i.IsNeighbour(rayUnit.coord, cConf.leader.coord))
				{
					GetClearReachableNeighbour(ref newPathState, rayUnit.coord);
				}
			}
			else if (rayTileAction != null && (rayTileAction.availableIn & GC.Inst.GetState()) != 0)
			{
				Unit unitAtCoord = GC.Inst.GetUnitAtCoord(rayTileAction.GetCoord());
				if (cConf.tileActionAccessibility != 0 && (cConf.tileActionAccessibility != TileActionAccessibility.ReachableAndClearOfLeader || unitAtCoord != cConf.leader) && (cConf.tileActionAccessibility != TileActionAccessibility.ReachableAndClear || unitAtCoord == null) && (cConf.rangeFromLeader == int.MaxValue || area.GetCost(rayTileAction.GetCoord()) <= cConf.rangeFromLeader))
				{
					if (unitAtCoord == null)
					{
						newPathState.start = cConf.leader.GetPositionWS();
						newPathState.end = rayTileAction.GetCoord();
						newPathState.show = cConf.showPath;
					}
					else
					{
						GetClearReachableNeighbour(ref newPathState, rayTileAction.GetCoord());
					}
				}
			}
			else if (coord.HasValue && (cConf.rangeFromLeader == int.MaxValue || area.GetCost(coord.Value) <= cConf.rangeFromLeader))
			{
				newPathState.start = cConf.leader.GetPositionWS();
				newPathState.end = coord;
				newPathState.show = cConf.showPath;
			}
		}
		if (newPathState == pathState)
		{
			return Wait.None;
		}
		CleanupPath();
		Vector3? start = newPathState.start;
		if (start.HasValue)
		{
			pathState = newPathState;
			return Routine.Start(calculatePath, MR.Inst.Host);
		}
		return Wait.None;
	}

	private void GetClearReachableNeighbour(ref PathState newPathState, v2i centerCoord)
	{
		int num = int.MaxValue;
		Unit unitAtCoord = GC.Inst.GetUnitAtCoord(centerCoord);
		for (uint num2 = 0u; num2 < 8; num2++)
		{
			v2i value = centerCoord + (OctDir)num2;
			if (map.CoordExists(value) && !map.GetCoordBlocked(value) && (!map.GetCoordDirectionBlocked(centerCoord, num2) || unitAtCoord.GetTeamType() == UnitTeam.Type.Enemy) && GC.Inst.GetUnitAtCoord(value) == null && map.GetTileAction(value) == null)
			{
				int cost = area.GetCost(value);
				if (cost != int.MaxValue && cost <= cConf.rangeFromLeader && cost < num)
				{
					newPathState.start = cConf.leader.GetPositionWS();
					newPathState.end = value;
					newPathState.show = cConf.showPath;
					num = cost;
				}
			}
		}
	}

	private IEnumerator<HagletYieldTerm> CalculatePath()
	{
		NC.PathRequestComplete storePath = delegate(NC.Path p, Unit u)
		{
			this.path = p;
		};
		yield return Routine.ResetToHere();
		yield return Wait.While(NC.Inst.CalculatePath(cConf.leader, pathState.end.Value, includeObservedTiles: true, storePath, cConf.vaultAllowed, ignoreUnitAtDestination: true));
		if (this.path.status == NC.PathStatus.Complete && this.path.positions.Count > 1)
		{
			VFXTileController vFXTiles = map.VFXTiles;
			NC.Path path = this.path;
			bool showPath = cConf.showPath;
			CoverType? coverType = map.GetCoverBetweenAllEnemies(this.path.coordEnd, cConf.leader);
			vFXTiles.PathShow(path, showPath, showSelectionBox: true, usePathDrawBounds: false, startTrickleEffect: false, makePathRed: false, coverType);
		}
		else
		{
			this.path = null;
		}
	}

	private void CleanupPath()
	{
		Vector3? start = pathState.start;
		if (start.HasValue)
		{
			path = null;
			if (GC.Inst.GetActiveUnit() == null || !GC.Inst.GetActiveUnit().moving)
			{
				map.VFXTiles.PathHide();
			}
			pathState = default(PathState);
		}
	}

	private void UpdateUnitTargets()
	{
		map.VFXTiles.UnitTargetHideAll();
		if (!cConf.showUnitTargets)
		{
			return;
		}
		for (int i = 0; i < GC.Inst.GetUnitsActive().Length; i++)
		{
			Unit unit = GC.Inst.GetUnitsActive()[i];
			if (IsUnitValid(unit))
			{
				map.VFXTiles.UnitTargetShow(unit.coord);
			}
		}
	}

	public bool IsUnitValid(Unit unit)
	{
		if (mapInteractable && unit != null && unit.IsAlive() && !unit.moving && (unit.teamMask & cConf.unitSelectionTeamMask) != 0 && !unit.IsMidGroundPound)
		{
			if (cConf.leader == null)
			{
				if (cConf.extraUnitFilter == null || cConf.extraUnitFilter(unit))
				{
					return true;
				}
			}
			else if (cConf.rangeRequiresPathing || (area.status == NC.PathStatus.Complete && area.GetCost(unit.coord) <= cConf.rangeFromLeader))
			{
				if (unit.teamType == cConf.leader.teamType)
				{
					if (cConf.extraUnitFilter == null || cConf.extraUnitFilter(unit))
					{
						return true;
					}
				}
				else if (!cConf.leader.IsAttackingDisabled && unit.IsTargetable)
				{
					switch (cConf.opponentReachability)
					{
					case UnitReachability.Reachable:
						if (v2i.IsNeighbour(cConf.leader.coord, unit.coord) || path != null)
						{
							goto case UnitReachability.Any;
						}
						break;
					case UnitReachability.Neighbour:
						if (v2i.IsNeighbour(cConf.leader.coord, unit.coord))
						{
							goto case UnitReachability.Any;
						}
						break;
					case UnitReachability.LineOfSight:
						if (map.HasLineOfSight(cConf.leader.coord, unit.coord, isSideStepAllowed: true))
						{
							goto case UnitReachability.Any;
						}
						break;
					case UnitReachability.DirectLineOfSight:
						if (map.HasLineOfSight(cConf.leader.coord, unit.coord, isSideStepAllowed: false))
						{
							goto case UnitReachability.Any;
						}
						break;
					case UnitReachability.Any:
						if (cConf.extraUnitFilter == null || cConf.extraUnitFilter(unit))
						{
							return true;
						}
						break;
					}
				}
			}
		}
		return false;
	}

	private void UpdateUnit(Unit rayUnit)
	{
		Unit unit = ((!IsUnitValid(rayUnit)) ? null : rayUnit);
		if (!(unitHighlighted == unit))
		{
			CleanupUnitHighlighted();
			CleanupTileAction();
			if (unit != null)
			{
				unitHighlighted = unit;
				unitHighlighted.OnHighlightEnter();
			}
		}
	}

	private void CleanupUnitHighlighted()
	{
		if (unitHighlighted != null)
		{
			unitHighlighted.OnHighlightExit();
			unitHighlighted = null;
		}
	}

	private void UpdateUnitLookedAt(Unit rayUnit)
	{
		if (unitLookedAt == rayUnit)
		{
			return;
		}
		CleanupUnitLookedAt();
		if (rayUnit != null)
		{
			unitLookedAt = rayUnit;
			if (GC.Inst.GetActiveUnit() != null)
			{
				UpdateAllUnitStatusBars();
			}
		}
	}

	private void CleanupUnitLookedAt()
	{
		if (unitLookedAt != null)
		{
			unitLookedAt = null;
			if (GC.Inst.GetActiveUnit() != null)
			{
				UpdateAllUnitStatusBars();
			}
		}
	}

	private void UpdateUnitHighlight()
	{
		UnitHighlightState unitHighlightState = default(UnitHighlightState);
		Unit unit = this.unitHighlightState.unit;
		if (mapInteractable && cConf.leader != null && unitHighlighted != null)
		{
			if (unitHighlighted.teamType == cConf.leader.teamType)
			{
				unitHighlightState.unit = unitHighlighted;
				unitHighlightState.type = UnitHighlightState.Type.Select;
			}
			else
			{
				unitHighlightState.unit = unitHighlighted;
				unitHighlightState.type = UnitHighlightState.Type.Attack;
			}
		}
		if (this.unitHighlightState == unitHighlightState)
		{
			return;
		}
		CleanupUnitHighlight();
		if ((cConf.showUnitSelection == UnitSelection.Any || (cConf.showUnitSelection == UnitSelection.Leader && unitHighlightState.unit == cConf.leader)) && unitHighlightState.unit != null)
		{
			this.unitHighlightState = unitHighlightState;
			switch (this.unitHighlightState.type)
			{
			case UnitHighlightState.Type.Select:
				if (cConf.leader.IsSteppedOut)
				{
					cConf.leader.StartStepBackIn();
				}
				map.VFXTiles.UnitSelectHighlightShow(this.unitHighlightState.unit);
				break;
			case UnitHighlightState.Type.Attack:
			{
				Unit leader = cConf.leader;
				Vector3 positionWS = unitHighlightState.unit.GetPositionWS();
				Crosshair.Inst.SetContext(UICrosshairContext.Target);
				if (leader.mainWeapon.IsMelee && (conf.activeAbility == null || !conf.activeAbility.SelectionRequireLineOfSight(leader)))
				{
					leader.LookAt(positionWS);
				}
				else if (map.HasLineOfSight(leader.coord, unitHighlightState.unit.coord, isSideStepAllowed: false))
				{
					if (leader.IsSteppedOut)
					{
						leader.StartStepBackIn();
					}
					if (conf.activeAbility == null)
					{
						leader.AimAtTarget(positionWS);
					}
					else
					{
						leader.LookAt(positionWS);
					}
				}
				else
				{
					AttackData attackData = map.GetAttackData(leader.coord, unitHighlightState.unit.coord);
					if (attackData.attackFromCoord != leader.coord)
					{
						v2i v2i2 = attackData.attackFromCoord - leader.coord;
						Vector3 vect = new Vector3(v2i2.x, 0f, v2i2.y);
						leader.StartStepOut(vect.ToSimpleDirXZ(), unitHighlightState.unit);
					}
					else
					{
						leader.LookAt(positionWS);
					}
				}
				map.VFXTiles.UnitAttackHighlightShow(this.unitHighlightState.unit);
				break;
			}
			}
		}
		else if (cConf.leader != null && GC.Inst.IsInTurnMode())
		{
			UnitModel unitModel = cConf.leader.unitModel;
			if (cConf.leader.IsSteppedOut)
			{
				cConf.leader.StartStepBackIn();
			}
			else
			{
				unitModel.Play(UnitModel.AnimID.CombatIdle);
			}
		}
	}

	private void CleanupUnitHighlight()
	{
		if (unitHighlightState.unit != null)
		{
			Crosshair.Inst.SetContext(UICrosshairContext.None);
			switch (unitHighlightState.type)
			{
			case UnitHighlightState.Type.Select:
				map.VFXTiles.UnitSelectHighlightHide();
				break;
			case UnitHighlightState.Type.Attack:
				map.VFXTiles.UnitAttackHighlightHide();
				break;
			}
			unitHighlightState = default(UnitHighlightState);
		}
	}

	private void UpdateTileAction(TileActionBase rayTileAction)
	{
		TileActionBase tileActionBase = null;
		if (rayTileAction != null && mapInteractable && cConf.leader != null && cConf.rangeFromLeader > 0 && cConf.rangeRequiresPathing && cConf.leader.map.IsActive && (path != null || cConf.leader.coord == rayTileAction.GetCoord()) && (rayTileAction.availableIn & GC.Inst.GetState()) != 0)
		{
			tileActionBase = rayTileAction;
		}
		if (tileAction == tileActionBase || unitLookedAt != null)
		{
			return;
		}
		CleanupTileAction();
		if (tileActionBase != null)
		{
			tileAction = tileActionBase;
			tileAction.OnFocusEnter();
			Crosshair.Inst.SetContext(tileAction.crosshairContext);
			if (tileAction.showPOIHighlight)
			{
				map.VFXTiles.TileActionHighlightShow(tileAction);
			}
		}
	}

	private void CleanupTileAction()
	{
		if (tileAction != null)
		{
			tileAction.OnFocusExit();
			Crosshair.Inst.SetContext(UICrosshairContext.None);
			if (tileAction.showPOIHighlight)
			{
				map.VFXTiles.TileActionHighlightHide();
			}
			tileAction = null;
		}
	}

	private void UpdateXRayUnit()
	{
		Unit unit = null;
		if (mapInteractable && displayCoord.HasValue)
		{
			ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
			float num = float.MaxValue;
			uint num2 = 0u;
			for (uint length = unitsActive.Length; num2 < length; num2++)
			{
				Unit unit2 = unitsActive[num2];
				int num3 = v2i.DistanceSqr(unit2.coord, displayCoord.Value);
				if ((float)num3 < num && !unit2.showHide.running && (GC.Inst.IsInTurnMode() || unit2.GetTeamType() != UnitTeam.Type.Enemy) && unit2.teamType != UnitTeam.Type.NPC)
				{
					num = num3;
					unit = unit2;
				}
			}
		}
		if (!(xrayUnit == unit))
		{
			CleanupXRayUnit();
			if (unit != null)
			{
				xrayUnit = unit;
				xrayUnit.unitModel.ShowXRayHighlight();
			}
		}
	}

	private void CleanupXRayUnit()
	{
		if ((bool)xrayUnit)
		{
			xrayUnit.unitModel.HideXRayHighlight();
			xrayUnit = null;
		}
	}

	private void UpdateCursorArea()
	{
		CursorAreaState cursorAreaState = default(CursorAreaState);
		if (mapInteractable && cConf.cursorAreaRadius > 0f && displayCoord.HasValue)
		{
			cursorAreaState.origin = displayCoord;
			cursorAreaState.radius = cConf.cursorAreaRadius;
			cursorAreaState.unitType = cConf.cursorAreaUnitType;
			cursorAreaState.tileSelectionVFX = ((!coord.HasValue) ? invalidAreaVFX : cConf.tileSelectionVFX);
		}
		if (!(cursorAreaState == this.cursorAreaState))
		{
			CleanupCursorArea();
			v2i? origin = cursorAreaState.origin;
			if (origin.HasValue)
			{
				this.cursorAreaState = cursorAreaState;
				map.VFXTiles.AreaSelectionShow(this.cursorAreaState.origin.Value, this.cursorAreaState.radius, cursorAreaState.tileSelectionVFX);
			}
		}
	}

	private void CleanupCursorArea()
	{
		v2i? origin = cursorAreaState.origin;
		if (origin.HasValue)
		{
			map.VFXTiles.AreaSelectionHide();
			cursorAreaState = default(CursorAreaState);
		}
	}

	private void UpdateUnitColliders()
	{
		ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
		for (int i = 0; i < unitsAllInWorld.sLength; i++)
		{
			unitsAllInWorld[i].colliderEnabled = IsUnitValid(unitsAllInWorld[i]);
		}
	}
}
public class MusicController : MonoBehaviour
{
	public enum MusicParameters
	{
		NONE,
		INTENSITY,
		PROGRESS,
		FADE
	}

	private static MusicController _instance;

	private const string kAmbienceDucker = "snapshot:/battle music ducks background";

	[ReadOnly]
	public string currentMusicEvent;

	private FMOD.Studio.EventInstance musicHandle;

	private FMOD.Studio.EventInstance musicSnapShot;

	private float currentIntensity;

	public static MusicController Inst => _instance;

	public float CurrentProgress { get; private set; }

	private void Awake()
	{
		_instance = this;
	}

	public void Play(string eventPath, float progress, float fade)
	{
		if (string.IsNullOrEmpty(eventPath))
		{
			Stop();
			return;
		}
		AC.Stop(musicHandle);
		musicHandle = AC.Inst.PlayOneShot2D(eventPath);
		SetProgress(progress);
		SetFade(fade);
		SetIntensity(0f);
		currentMusicEvent = eventPath;
	}

	public void Stop()
	{
		AC.Stop(musicHandle);
		currentMusicEvent = null;
	}

	public void SetIntensity(float intensity)
	{
		if (musicHandle.isValid())
		{
			musicHandle.setParameterValue("intensity", intensity);
		}
		currentIntensity = intensity;
	}

	public void SetProgress(float progress)
	{
		if (musicHandle.isValid())
		{
			musicHandle.setParameterValue("progress", progress);
		}
		CurrentProgress = progress;
	}

	public void SetFade(float fade)
	{
		if (musicHandle.isValid())
		{
			musicHandle.setParameterValue("fade", fade);
		}
	}

	public void SetMusicParameter(MusicParameters param, float value)
	{
		if (musicHandle.isValid())
		{
			switch (param)
			{
			case MusicParameters.INTENSITY:
				SetIntensity(value);
				break;
			case MusicParameters.PROGRESS:
				SetProgress(value);
				break;
			case MusicParameters.FADE:
				SetFade(value);
				break;
			}
		}
	}

	public void SetMusicSnapShotIntensity(float value)
	{
		if (musicSnapShot.isValid())
		{
			musicSnapShot.setParameterValue("Intensity", value);
		}
	}

	public void ApplyAmbienceSnapshot(bool value)
	{
		if (value)
		{
			if (!musicSnapShot.isValid())
			{
				musicSnapShot = AC.Inst.PlaySnapshot("snapshot:/battle music ducks background");
				SetMusicSnapShotIntensity((float)VolumeLevels.Inst.MusicIndex / 4f * 100f);
			}
		}
		else if (musicSnapShot.isValid())
		{
			musicSnapShot.stop(STOP_MODE.ALLOWFADEOUT);
			musicSnapShot = default(FMOD.Studio.EventInstance);
		}
	}
}
[Serializable]
public class Party : Serializer.ISelfConstructor
{
	private const int maxPartySize = 7;

	[SerializeField]
	private ConstArray<PartyMember> unlockedMembers = new ConstArray<PartyMember>(7u);

	[SerializeField]
	private ConstArray<PartyMember> contributedMembers = new ConstArray<PartyMember>(7u);

	private static readonly string[] partyCharPaths = new string[6] { "CharacterData/CData_Ambrosia", "CharacterData/CData_Archi", "CharacterData/CData_Chris", "CharacterData/CData_Margot", "CharacterData/CData_Noot", "CharacterData/CData_Willa" };

	[SerializeField]
	public List<ItemStackInstance> inventoryItems = new List<ItemStackInstance>(50);

	[SerializeField]
	private uint _currency;

	private static readonly Item[] sellableItems = new Item[3]
	{
		Item.Scrap_Metal,
		Item.Circuitry,
		Item.Jewellery
	};

	public static Party Inst => SaveData.data.party;

	public int HightestPartyMemberLevel
	{
		get
		{
			int num = 0;
			for (int i = 0; i < unlockedMembers.Length; i++)
			{
				if (unlockedMembers[i].Level > num)
				{
					num = unlockedMembers[i].Level;
				}
			}
			return num;
		}
	}

	public uint currency
	{
		get
		{
			return _currency;
		}
		set
		{
			_currency = value;
		}
	}

	public Party()
	{
	}

	public Party(Party other)
	{
		uint length = other.unlockedMembers.Length;
		unlockedMembers = new ConstArray<PartyMember>(7u);
		for (int i = 0; i < length; i++)
		{
			unlockedMembers.Add(other.unlockedMembers[i]);
		}
		uint length2 = other.contributedMembers.Length;
		contributedMembers = new ConstArray<PartyMember>(7u);
		for (int j = 0; j < length2; j++)
		{
			contributedMembers.Add(other.contributedMembers[j]);
		}
		inventoryItems = new List<ItemStackInstance>(other.inventoryItems.Capacity);
		int k = 0;
		for (int count = other.inventoryItems.Count; k < count; k++)
		{
			inventoryItems.Add(new ItemStackInstance(other.inventoryItems[k]));
		}
		currency = other.currency;
	}

	public Party(BinaryReader reader)
	{
	}

	void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
	{
	}

	public PartyMember GetPartyLeader()
	{
		return contributedMembers[0];
	}

	public PartyMember GetPartySubleader()
	{
		return contributedMembers[1];
	}

	public void UnlockAllParty()
	{
		int num = partyCharPaths.Length;
		while (--num >= 0)
		{
			UnlockPartyMember(AEResources.LoadFirstResource<CharacterData>(partyCharPaths[num]));
		}
	}

	public void UnlockPartyMember(CharacterData character)
	{
		if (!(character != null) || character.partyMemberID == PartyMemberID.None || character.partyMemberID == PartyMemberID.MAX)
		{
			return;
		}
		for (int i = 0; i < unlockedMembers.Length; i++)
		{
			if (unlockedMembers[i].characterData == character)
			{
				return;
			}
		}
		PartyMember partyMember = new PartyMember(character);
		partyMember.SetFirstAbilityChoiceAtLevel(0);
		partyMember.SetSecondAbilityChoiceAtLevel(0);
		if (partyMember.Level > 0)
		{
			partyMember.SetFirstAbilityChoiceAtLevel(1);
		}
		if (character.partyMemberID == PartyMemberID.Ashley)
		{
			partyMember.SetSecondAbilityChoiceAtLevel(4);
			partyMember.SetSecondAbilityChoiceAtLevel(5);
		}
		unlockedMembers.Add(partyMember);
	}

	public void LockPartyMember(CharacterData character)
	{
		for (int num = unlockedMembers.sLength - 1; num >= 0; num--)
		{
			if (unlockedMembers[num].characterData == character)
			{
				unlockedMembers.RemoveAtIndex((uint)num);
			}
		}
	}

	public ConstArray<PartyMember> GetUnlockedPartyMembers()
	{
		return unlockedMembers;
	}

	public PartyMember GetUnlockedPartyMemberAtIndex(int index)
	{
		return unlockedMembers[index];
	}

	public PartyMember GetUnlockedPartyMember(CharacterData characterData)
	{
		if (characterData != null)
		{
			for (int i = 0; i < unlockedMembers.Length; i++)
			{
				if (unlockedMembers[i].characterData == characterData)
				{
					return unlockedMembers[i];
				}
			}
		}
		return null;
	}

	public int GetUnlockedPartyMemberIndex(CharacterData characterData)
	{
		if (characterData != null)
		{
			for (int i = 0; i < unlockedMembers.Length; i++)
			{
				if (unlockedMembers[i].characterData == characterData)
				{
					return i;
				}
			}
		}
		return -1;
	}

	public bool TryGetUnlockedPartyMember(CharacterData characterData, out PartyMember partyMember)
	{
		if (characterData != null && characterData.partyMemberID != 0 && characterData.partyMemberID != PartyMemberID.MAX)
		{
			for (int i = 0; i < unlockedMembers.Length; i++)
			{
				if (unlockedMembers[i].characterData == characterData)
				{
					partyMember = unlockedMembers[i];
					return true;
				}
			}
		}
		partyMember = null;
		return false;
	}

	public PartyMember GetContributedPartyMember(CharacterData characterData)
	{
		if (characterData != null)
		{
			for (int i = 0; i < contributedMembers.Length; i++)
			{
				if (contributedMembers[i].characterData == characterData)
				{
					return contributedMembers[i];
				}
			}
		}
		return null;
	}

	public void ClearContributedPartyMembers()
	{
		for (int i = 0; i < contributedMembers.Length; i++)
		{
			contributedMembers[i].Reset();
		}
		contributedMembers.Clear();
	}

	public void TryAddContributedPartyMember(CharacterData characterData)
	{
		if (characterData.partyMemberID != 0 && characterData.partyMemberID != PartyMemberID.Ashley)
		{
			PartyMember unlockedPartyMember = GetUnlockedPartyMember(characterData);
			if (unlockedPartyMember == null)
			{
				UnlockPartyMember(characterData);
				unlockedPartyMember = GetUnlockedPartyMember(characterData);
			}
			if (GetContributedPartyMember(characterData) == null)
			{
				contributedMembers.Add(unlockedPartyMember);
			}
		}
	}

	public void TryRemoveContributedPartyMember(CharacterData characterData)
	{
		if (characterData.partyMemberID != 0)
		{
			int unlockedPartyMemberIndex = GetUnlockedPartyMemberIndex(characterData);
			if (unlockedPartyMemberIndex != -1)
			{
				contributedMembers.RemoveAtIndex((uint)unlockedPartyMemberIndex);
			}
		}
	}

	public void SetPartyLeaderAtRuntime(Unit leader)
	{
		SetContributedMemberAtRuntime(leader, 0);
	}

	public void SetPartySubleaderAtRuntime(Unit subleader)
	{
		SetContributedMemberAtRuntime(subleader, 1);
	}

	private void SetContributedMemberAtRuntime(Unit leader, int index)
	{
		for (int i = 0; i < contributedMembers.Length; i++)
		{
			if (contributedMembers[i].characterData == leader.charData)
			{
				PartyMember value = contributedMembers[index];
				contributedMembers[index] = contributedMembers[i];
				contributedMembers[i] = value;
			}
		}
	}

	public ConstArray<PartyMember> GetContributedPartyMembers()
	{
		return contributedMembers;
	}

	public int GetUnlockedPartyMembersNum()
	{
		return unlockedMembers.sLength;
	}

	public void OnMissionComplete()
	{
		for (int i = 0; i < contributedMembers.Length; i++)
		{
			contributedMembers[i].OnMissionComplete();
		}
	}

	[Conditional("AE_DEBUG")]
	public void ValidateItemStack(ItemStackInstance stack)
	{
	}

	public bool IsSellableItem(ItemStackMeta meta)
	{
		for (int i = 0; i < sellableItems.Length; i++)
		{
			if (meta.ItemEnum == sellableItems[i])
			{
				return true;
			}
		}
		return false;
	}

	public ItemStackInstance FindStackByMeta(ItemStackMeta meta)
	{
		ItemStackInstance itemStackInstance = null;
		for (int i = 0; i < inventoryItems.Count; i++)
		{
			itemStackInstance = inventoryItems[i];
			if (itemStackInstance.meta == meta)
			{
				return itemStackInstance;
			}
		}
		itemStackInstance = new ItemStackInstance(meta, ItemImpl.Instantiate(meta.itemImplName));
		inventoryItems.Add(itemStackInstance);
		return itemStackInstance;
	}

	public bool AddItemToInventory(ItemStackMeta meta, int amount)
	{
		ItemStackInstance itemStackInstance = FindStackByMeta(meta);
		if (itemStackInstance.count < itemStackInstance.meta.StorageLimit)
		{
			itemStackInstance.count = Mathf.Min(itemStackInstance.count + amount, (int)itemStackInstance.meta.StorageLimit);
			itemStackInstance.OnAcquired.Trigger();
			itemStackInstance.hasEverBeenPickedUp = true;
			return true;
		}
		return false;
	}

	public bool RemoveItemFromInventory(ItemStackMeta meta, int amount)
	{
		ItemStackInstance itemStackInstance = FindStackByMeta(meta);
		if (itemStackInstance.count > 0)
		{
			itemStackInstance.count = Mathf.Max(itemStackInstance.count - amount, 0);
			return true;
		}
		return false;
	}

	public void RemoveAllOfItem(ItemStackMeta meta)
	{
		ItemStackInstance itemStackInstance = FindStackByMeta(meta);
		itemStackInstance.count = 0;
	}

	public int GetItemCount(ItemStackMeta meta)
	{
		ItemStackInstance itemStackInstance = FindStackByMeta(meta);
		return itemStackInstance.count;
	}

	public void HACK_Ensure10AugmentsCoresAndShots()
	{
		ItemStackMeta meta = Item.Augment.ToMeta();
		ItemStackMeta meta2 = Item.Atlantium_Core.ToMeta();
		ItemStackMeta meta3 = Item.Rejection_Shot.ToMeta();
		int itemCount = GetItemCount(meta);
		int itemCount2 = GetItemCount(meta2);
		int itemCount3 = GetItemCount(meta3);
		if (itemCount < 10)
		{
			int amount = 10 - itemCount;
			AddItemToInventory(meta, amount);
		}
		if (itemCount2 < 10)
		{
			int amount2 = 10 - itemCount2;
			AddItemToInventory(meta2, amount2);
		}
		if (itemCount3 < 10)
		{
			int amount3 = 10 - itemCount3;
			AddItemToInventory(meta3, amount3);
		}
	}
}
[Serializable]
public class PartyAbility : Serializer.ISelfConstructor
{
	public Type ability;

	public bool upgraded;

	public PartyAbility(Type ability)
	{
		this.ability = ability;
		upgraded = false;
	}

	public PartyAbility(PartyAbility other)
	{
		ability = other.ability;
		upgraded = other.upgraded;
	}

	public PartyAbility(BinaryReader reader)
	{
	}

	void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
	{
	}
}
[Serializable]
public class PartyMember : Serializer.ISelfConstructor
{
	public CharacterData characterData;

	[SerializeField]
	private int _level;

	[SerializeField]
	private int _upgrades;

	[SerializeField]
	private int _missionsCompleted;

	[SerializeField]
	private bool _justLeveledUp;

	[SerializeField]
	private PartyAbility[] abilities;

	public int Level
	{
		get
		{
			int num = PartyLevelLUT.startingLevels[(int)characterData.partyMemberID];
			if (_level < num)
			{
				return num;
			}
			return _level;
		}
		private set
		{
			int num = PartyLevelLUT.startingLevels[(int)characterData.partyMemberID];
			if (value < num)
			{
				_level = num;
			}
			else
			{
				_level = value;
			}
		}
	}

	public int Upgrades
	{
		get
		{
			return _upgrades;
		}
		private set
		{
			_upgrades = value;
		}
	}

	public int MissionsCompleted
	{
		get
		{
			return _missionsCompleted;
		}
		private set
		{
			_missionsCompleted = value;
		}
	}

	public bool JustLeveledUp
	{
		get
		{
			return _justLeveledUp;
		}
		private set
		{
			_justLeveledUp = value;
		}
	}

	public PartyMember(CharacterData character)
	{
		characterData = character;
		_level = PartyLevelLUT.startingLevels[(int)character.partyMemberID];
		_upgrades = 0;
		_missionsCompleted = 0;
		_justLeveledUp = false;
		abilities = new PartyAbility[12];
	}

	public PartyMember()
	{
	}

	public PartyMember(PartyMember other)
	{
		characterData = other.characterData;
		_level = other._level;
		_upgrades = other._upgrades;
		_missionsCompleted = other._missionsCompleted;
		_justLeveledUp = other._justLeveledUp;
		abilities = new PartyAbility[other.abilities.Length];
		int i = 0;
		for (int num = other.abilities.Length; i < num; i++)
		{
			abilities[i] = ((other.abilities[i] == null) ? null : new PartyAbility(other.abilities[i]));
		}
	}

	public PartyMember(BinaryReader reader)
	{
	}

	void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
	{
	}

	public void Reset()
	{
		JustLeveledUp = false;
	}

	public void OnMissionComplete()
	{
		MissionsCompleted++;
		for (int i = 0; i < 10; i++)
		{
			if (MissionsCompleted == GetAbsMissionNeededToLevelUp())
			{
				Level++;
				JustLeveledUp = true;
			}
			int absLevelNeededToGainUpgrade = GetAbsLevelNeededToGainUpgrade();
			if (Level >= absLevelNeededToGainUpgrade && absLevelNeededToGainUpgrade != 0)
			{
				Upgrades++;
			}
		}
	}

	public int GetAbsMissionNeededToLevelUp()
	{
		int partyMemberID = (int)characterData.partyMemberID;
		if (Level >= 10)
		{
			return 0;
		}
		return PartyLevelLUT.missionsNeededToLevelUp[partyMemberID, Level];
	}

	public int GetMissionsBetweenLevels(int level1, int level2)
	{
		int partyMemberID = (int)characterData.partyMemberID;
		int num = 0;
		int num2 = int.MaxValue;
		if (PartyLevelLUT.missionsNeededToLevelUp.GetLength(1) > level1)
		{
			num = PartyLevelLUT.missionsNeededToLevelUp[partyMemberID, level1];
		}
		if (PartyLevelLUT.missionsNeededToLevelUp.GetLength(1) > level2)
		{
			num2 = PartyLevelLUT.missionsNeededToLevelUp[partyMemberID, level2];
		}
		return num2 - num;
	}

	public int GetAbsLevelNeededToGainUpgrade()
	{
		if (Upgrades >= 4)
		{
			return 0;
		}
		return PartyLevelLUT.levelsNeededToAddUpgrade[Upgrades];
	}

	public int GetRemainingMissionsNeededToLevelUp()
	{
		if (Level >= 10)
		{
			return 0;
		}
		int absMissionNeededToLevelUp = GetAbsMissionNeededToLevelUp();
		return absMissionNeededToLevelUp - MissionsCompleted;
	}

	public AbilityMeta GetFirstAbilityAtLevel(int level)
	{
		return GetAbilityAtLevelAndIndex(level, 0);
	}

	public AbilityMeta GetSecondAbilityAtLevel(int level)
	{
		return GetAbilityAtLevelAndIndex(level, 1);
	}

	private AbilityMeta GetAbilityAtLevelAndIndex(int level, int abilityIndex)
	{
		if (level == 1)
		{
			abilityIndex = 0;
		}
		Type key = CharacterStats.abilityTree[(int)characterData.Class, level, abilityIndex];
		return PartyLevelLUT.abilityTypesToMetas[key];
	}

	public void SetFirstAbilityChoiceAtLevel(int level)
	{
		SetAbilityAtLevel(level, 0);
	}

	public void SetSecondAbilityChoiceAtLevel(int level)
	{
		SetAbilityAtLevel(level, 1);
	}

	private void SetAbilityAtLevel(int level, int abilityIndex)
	{
		int num = level + 1;
		switch (level)
		{
		case 0:
			num = abilityIndex;
			break;
		case 1:
			abilityIndex = 0;
			break;
		}
		PartyAbility partyAbility = new PartyAbility(CharacterStats.abilityTree[(int)characterData.Class, level, abilityIndex]);
		abilities[num] = partyAbility;
	}

	public void RemoveAbilityAtLevel(int level, int abilityIndex)
	{
		int num = level + 1;
		if (level == 0)
		{
			num = abilityIndex;
		}
		abilities[num] = null;
	}

	public void RemoveAbilityAtIndex(int levelIndex)
	{
		abilities[levelIndex] = null;
	}

	public int GetAbilitiesNum()
	{
		int num = 0;
		int num2 = abilities.Length;
		while (--num2 >= 0)
		{
			if (abilities[num2] != null)
			{
				num++;
			}
		}
		return num;
	}

	public int GetMaxNumberOfAbilities()
	{
		return abilities.Length;
	}

	public int GetUpgradedAbilitiesNum()
	{
		int num = 0;
		int num2 = abilities.Length;
		while (--num2 >= 0)
		{
			PartyAbility abilityAtIndex = GetAbilityAtIndex(num2);
			if (abilityAtIndex != null && abilityAtIndex.upgraded)
			{
				num++;
			}
		}
		return num;
	}

	[Conditional("AE_DEBUG")]
	private void ValidateAbilityLevel(int level)
	{
	}

	public PartyAbility GetAbilityAtLevel(int level)
	{
		return abilities[level];
	}

	public PartyAbility GetAbilityAtIndex(int index)
	{
		return abilities[index];
	}

	public void UpgradeAbilityAtLevel(int level)
	{
		abilities[level].upgraded = true;
	}
}
public enum PartyMemberID
{
	None,
	Willa,
	Archi,
	Margot,
	Noot,
	Chris,
	Ambrosia,
	Ashley,
	MAX
}
public static class PartyLevelLUT
{
	public const int kLevelCap = 11;

	public static readonly int[] startingLevels = new int[8] { 0, 0, 1, 2, 2, 2, 3, 5 };

	public static readonly int[,] missionsNeededToLevelUp = new int[8, 11]
	{
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			1, 2, 3, 6, 8, 10, 12, 14, 16, 20,
			0
		},
		{
			0, 1, 2, 3, 5, 7, 9, 11, 13, 15,
			0
		},
		{
			0, 0, 1, 2, 3, 4, 6, 8, 10, 12,
			0
		},
		{
			0, 0, 1, 2, 3, 4, 5, 7, 9, 11,
			0
		},
		{
			0, 0, 1, 2, 3, 4, 5, 7, 9, 11,
			0
		},
		{
			0, 0, 0, 1, 2, 4, 6, 8, 12, 14,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		}
	};

	public const int kUpgradeCap = 4;

	public static readonly int[] levelsNeededToAddUpgrade = new int[4] { 3, 6, 9, 10 };

	public static Dictionary<Type, AbilityMeta> abilityTypesToMetas;

	public static AbilityMeta GetAbilityMeta(Type abilityType)
	{
		return abilityTypesToMetas[abilityType];
	}

	public static void Initialise()
	{
		abilityTypesToMetas = new Dictionary<Type, AbilityMeta>();
		Type[] types = typeof(AbilityImplBase).Assembly.GetTypes();
		foreach (Type type in types)
		{
			if (type.IsSubclassOf(typeof(AbilityImplBase)))
			{
				AbilityMeta abilityMeta = null;
				Type type2 = type;
				while (abilityMeta == null && type2 != typeof(AbilityImplBase))
				{
					abilityMeta = AEResources.LoadFirstResource<AbilityMeta>("Abilities/" + type2.Name);
					type2 = type2.BaseType;
				}
				abilityTypesToMetas.Add(type, abilityMeta);
			}
		}
	}
}
public class RC : MonoBehaviour
{
	private static RC _instance;

	private Transform xFormTableMapPivot;

	private AnimFloat animFog = new AnimFloat(0f);

	private static float kFogSpeed = 0.5f;

	private static int kHoloShaderColorID;

	private static int kMinFogColorID;

	private static int kMaxFogColorID;

	public Material roomWireframeMaterial;

	private HagletResettable bkAnimColorRoutine;

	private HagletResettable midMissionRoomToMap;

	[NonSerialized]
	public HagletTrigger OnRoomVisibleComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnRoomHiddenComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnRoomLoadedIn = new HagletTrigger();

	private GameObject roomWireframe;

	private Action OnFogInComplete;

	private bool missionStart;

	private Map overrideLastMap;

	private Action _OnUserRoomShowComplete;

	public AnimColor bkColorAnim = new AnimColor();

	private Map holoMap;

	public static RC Inst => _instance;

	public bool IsMapOpen { get; private set; }

	public float FogValue => animFog.Value;

	public bool WireframeVisible => !Mathf.Approximately(roomWireframeMaterial.GetColor(kHoloShaderColorID).a, 0f);

	public void OnAwakeLR()
	{
		_instance = this;
		bkAnimColorRoutine = new HagletResettable(BackgroundAnimRoutineColor(), null, HagletStepTime.Update, -1, 1);
		midMissionRoomToMap = new HagletResettable(TransitionToLastMap(), null, HagletStepTime.Update, -1, 1);
		xFormTableMapPivot = LR.Get<Transform>("/LevelRoot/MapController/MapPivot");
		Transform parent = base.transform.Find("UI_Stub");
		Transform parent2 = base.transform.Find("Shared Artwork/SM_Telephone");
		roomWireframe = LR.Get<STUB_RoomWireframe>().gameObject;
		roomWireframe.SetActive(value: false);
		MeshRenderer componentInChildren = roomWireframe.GetComponentInChildren<MeshRenderer>();
		roomWireframeMaterial = componentInChildren.material;
		componentInChildren.sortingOrder = -200;
		GameObject gameObject = LR.LoadPrefabResource("UI/P_UIRoomMenu", base.transform);
		GameObject gameObject2 = LR.LoadPrefabResource("UI/P_UITelephone", parent2);
		GameObject gameObject3 = LR.LoadPrefabResource("UI/P_UICharacters", base.transform);
		GameObject gameObject4 = LR.LoadPrefabResource("UI/P_UIGameOver", parent);
		GameObject gameObject5 = LR.LoadPrefabResource("UI/P_UIAbilityChoice", parent);
		OnFogInComplete = delegate
		{
			OnRoomHiddenComplete.Trigger();
			RR.Inst.HideArtwork();
			if ((bool)MR.Inst && (bool)MR.Inst.roomInteraction)
			{
				MR.Inst.roomInteraction.SetActive(value: false);
			}
			xFormTableMapPivot.gameObject.SetActive(value: true);
			AECameraFullscreenPass.Inst.StartFadeToClear(0.25f);
		};
		kMinFogColorID = Shader.PropertyToID("_ColorSkyboxMin");
		kMaxFogColorID = Shader.PropertyToID("_ColorSkyboxMax");
		kHoloShaderColorID = Shader.PropertyToID("_ColorHolo");
	}

	public void ShowLastMap(bool start = false, Map overrideMap = null)
	{
		missionStart = start;
		overrideLastMap = overrideMap;
		Routine.Start(midMissionRoomToMap, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> TransitionToLastMap()
	{
		RoomHide();
		yield return Wait.Until(OnRoomHiddenComplete);
		if (!Singleton<MC>.Inst.GetLastMap())
		{
		}
		Map nextMap = Singleton<MC>.Inst.GetLastMap();
		if (overrideLastMap != null)
		{
			nextMap = overrideLastMap;
		}
		MC inst = Singleton<MC>.Inst;
		Map map = nextMap;
		bool flag = missionStart;
		inst.TransitionToMap(map, null, null, 0f, flag);
		overrideLastMap = null;
	}

	public void MapShow(uint startingMapIndex, bool missionStart = true)
	{
		RoomHide();
		MC inst = Singleton<MC>.Inst;
		Map map = Singleton<MC>.Inst.GetAllMaps()[startingMapIndex];
		bool flag = missionStart;
		inst.TransitionToMap(map, null, null, 0f, flag);
	}

	public void RoomHide()
	{
		IsMapOpen = true;
		animFog.Value = 0f;
		animFog.OnComplete = OnFogInComplete;
		animFog.AnimateTo(1f, kFogSpeed);
		VOController.Inst.VOStop();
		OnRoomHide();
	}

	public void RoomShow(Action OnComplete = null)
	{
		_OnUserRoomShowComplete = OnComplete;
		IsMapOpen = false;
		if (Singleton<MC>.Inst != null)
		{
			if (Singleton<MC>.Inst.GetActiveMap() != null || !IsMapOpen)
			{
				Singleton<MC>.Inst.TransitionToMap(null, OnRoomShowComplete);
			}
			else
			{
				OnRoomShowComplete(null, null);
			}
		}
		else
		{
			MSR.Inst.Hide(OnRoomShowComplete);
		}
		OnRoomShow();
	}

	private void OnRoomShowComplete(Map mapHidden, Map mapInvalid)
	{
		if (_OnUserRoomShowComplete != null)
		{
			_OnUserRoomShowComplete();
		}
		if (LR.Inst.roomMetaToLoad != null && LR.Inst.roomMetaLoaded != LR.Inst.roomMetaToLoad)
		{
			LR.Inst.LoadRoomSceneIntoFrontend(LR.Inst.roomMetaToLoad);
		}
		else
		{
			RR.Inst.ShowArtwork();
		}
		if ((bool)MR.Inst && (bool)MR.Inst.roomInteraction)
		{
			MR.Inst.roomInteraction.SetActive(value: true);
		}
		OnRoomLoadedIn.Trigger();
		animFog.OnComplete = null;
		animFog.AnimateTo(0f, kFogSpeed);
		animFog.OnComplete = OnFogOutComplete;
		xFormTableMapPivot.gameObject.SetActive(value: false);
	}

	private void OnFogOutComplete()
	{
		OnRoomVisibleComplete.Trigger();
	}

	public void OnRoomHide()
	{
		roomWireframe.SetActive(value: true);
	}

	public void OnRoomShow()
	{
		roomWireframe.SetActive(value: false);
	}

	private void OnFadeOutComplete()
	{
	}

	public float FogUpdate()
	{
		if (!animFog.animating)
		{
			return 0f;
		}
		return animFog.Update();
	}

	public void BackgroundColorRGBSet(Color color)
	{
		_BackgroundColorSetRGB(color);
		bkColorAnim.Value = color;
	}

	public HagletEvent BackgroundColorRGBAnimate(Color color, float time, Map map = null)
	{
		holoMap = map;
		bkColorAnim.AnimateTo(color, time);
		if (!bkAnimColorRoutine.running)
		{
			LR.Host.StartTopLevel(bkAnimColorRoutine);
		}
		else
		{
			bkAnimColorRoutine.Reset();
		}
		return bkAnimColorRoutine.completed;
	}

	private IEnumerator<HagletYieldTerm> BackgroundAnimRoutineColor()
	{
		do
		{
			_BackgroundColorSetRGB(bkColorAnim.Update());
			yield return Wait.ForSteps(1uL);
		}
		while ((bool)bkColorAnim.animating);
	}

	private void _BackgroundColorSetRGB(Color color)
	{
		roomWireframeMaterial.SetColor(kHoloShaderColorID, color);
		if (holoMap != null)
		{
			holoMap.HologamColor = color;
		}
	}

	public void SetWireframAlpha(float a)
	{
		Color color = roomWireframeMaterial.GetColor(kHoloShaderColorID);
		roomWireframeMaterial.SetColor(kHoloShaderColorID, color.RepA(a));
	}

	public void SetWireframeSkyboxColors(Color min, Color max)
	{
		roomWireframeMaterial.SetColor(kMinFogColorID, min);
		roomWireframeMaterial.SetColor(kMaxFogColorID, max);
	}
}
[Flags]
public enum QueueProperty
{
	Queue = 1,
	Interrupt = 2,
	Instant = 4,
	OnlyPlayIfQueueEmpty = 8,
	OnlyPlayIfOutOfSequence = 0x10,
	Reverse = 0x20,
	Loop = 0x40
}
public struct ANClip
{
	public AnimationClip data;

	public QueueProperty properties;

	public int layer;

	public Action onComplete;

	public AnimationState state;

	public float normalisedStartTime;
}
public class RootBase : MonoBehaviour
{
	[HideInInspector]
	public JK3D jk3d;

	[SerializeField]
	[ReadOnly]
	private SceneMeta sceneMeta;

	[ReadOnly]
	[SerializeField]
	public Texture2D rootLightmap;

	[ReadOnly]
	[SerializeField]
	public Texture2D rootSpecmap;

	public SceneMeta SceneMeta => sceneMeta;

	public virtual void Setup()
	{
		jk3d = GetComponentInChildren<JK3D>();
		JK3DAtlasMaterial[] allAtlasMaterials = jk3d.GetAllAtlasMaterials();
		foreach (JK3DAtlasMaterial jK3DAtlasMaterial in allAtlasMaterials)
		{
			if (jK3DAtlasMaterial.dynamicMat == null)
			{
				int num = 0;
			}
			if (jK3DAtlasMaterial.staticMat == null)
			{
				int num2 = 0;
			}
			if (jK3DAtlasMaterial.isLightmapped)
			{
				if (rootLightmap != null)
				{
					jK3DAtlasMaterial.dynamicMat.SetTexture("_TextureLight", rootLightmap);
					jK3DAtlasMaterial.staticMat.SetTexture("_TextureLight", rootLightmap);
				}
				if (rootSpecmap != null)
				{
					jK3DAtlasMaterial.dynamicMat.SetTexture("_TextureSpec", rootSpecmap);
					jK3DAtlasMaterial.staticMat.SetTexture("_TextureSpec", rootSpecmap);
				}
			}
		}
	}

	public void InitialiseAllHagisUnderRoot()
	{
		HAGIS[] componentsInChildren = GetComponentsInChildren<HAGIS>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnAwakeRoot();
		}
	}

	public GameObject GetGameObjectInRoot(string name)
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
		}
		return transform.gameObject;
	}

	public static RootBase GetRoot(UnityEngine.Component component)
	{
		return GetRoot(component.gameObject);
	}

	public static RootBase GetRoot(GameObject go)
	{
		return GetRoot(go);
	}

	public static RootBase GetRoot(Scene scene)
	{
		GameObject[] rootGameObjects = scene.GetRootGameObjects();
		for (int i = 0; i < rootGameObjects.Length; i++)
		{
			RootBase component = rootGameObjects[i].GetComponent<RootBase>();
			if ((bool)component)
			{
				return component;
			}
		}
		return null;
	}
}
public class LR : RootBase
{
	private class LoadingScene
	{
		private UnityEngine.AsyncOperation asyncOp;

		public Func<bool> _IsFinished;

		public LoadingScene(string name, bool allowActivation = true)
		{
			_IsFinished = IsFinished;
			asyncOp = SceneManager.LoadSceneAsync(name, LoadSceneMode.Additive);
			asyncOp.allowSceneActivation = allowActivation;
		}

		public bool IsFinished()
		{
			return (!asyncOp.allowSceneActivation) ? (asyncOp.progress >= 0.9f) : asyncOp.isDone;
		}

		public void ToggleSceneActivation(bool value)
		{
			asyncOp.allowSceneActivation = value;
		}

		public float GetProgress()
		{
			return asyncOp.progress;
		}
	}

	private struct VOSource
	{
		public Transform tform;

		public float volume;

		public static VOSource clear = new VOSource
		{
			tform = null,
			volume = 1f
		};
	}

	private const string kMissionSelectSceneName = "_MissionSelect";

	[ReadOnly]
	public RoomSceneMeta DEBUG_roomSceneMeta;

	public static MissionSceneMeta DEBUG_missionScene;

	public static string[] DEBUG_autoTestFilters;

	public static string DEBUG_autoTestPostURL;

	public static string DEBUG_autoTestPath;

	public static bool DEBUG_autoTestSaveLoad = false;

	public static int DEBUG_autoTestStartingCheckpoint = -1;

	public static bool DEBUG_useRadialTicker = true;

	public static bool HACK_tutorialMode = false;

	public static bool HACK_hideCombatUI = false;

	public static bool DEBUG_autoReload = false;

	public bool DEBUG_scaleEnemies;

	public AnimationCurve animHoloFrameWidth;

	public AnimationCurve animHoloFrameWidthFastMode;

	public AnimationCurve animHoloFrameHeight;

	public AnimationCurve animHoloFrameFadeScale;

	public AnimationCurve animHoloFrameFadeScaleFastMode;

	public AnimationCurve animMapPivotLinearOffset;

	public AnimationCurve animMapPivotAngularOffset;

	public AnimationCurve logoFadeCurve;

	[NonSerialized]
	public static HagletHost Host = new HagletHost("Level Root");

	private HagletResettable lrStart;

	private HagletResettable lrAwake;

	private HagletResettable loadMissionIntoFrontEndRoutine;

	private HagletResettable unloadMissionRoutine;

	private SpriteRenderer ae_logo;

	private static bool HACK_isS6Device;

	private bool ovrWaitingForUserToReturn;

	private static readonly AnimationCurve impactIntensityCurve = new AnimationCurve(new Keyframe(0f, 1f, -1f, -2.5f), new Keyframe(1f, 0f, 0f, 0f));

	private const AudioRolloffMode VODefaultRolloffMode = AudioRolloffMode.Logarithmic;

	private const float VODefaultMinDist = 10f;

	private const float VODefaultMaxDist = 100f;

	private const float VODefaultVolume = 1f;

	private bool _isPaused;

	[NonSerialized]
	public HagletTrigger OnLoadMissionComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnLoadMissionFailed = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnloadMissionComplete = new HagletTrigger();

	protected static LR _instance;

	public bool IsInitialised { get; private set; }

	public static Exception lastMissionLoadException { get; private set; }

	public static bool CanSaveLoad
	{
		get
		{
			if (GC.Inst != null && (GC.Inst.IsInTurnMode() || GC.Inst.IsInCutsceneMode()))
			{
				return false;
			}
			return true;
		}
	}

	public MissionSceneMeta missionMetaToLoad { get; private set; }

	public MissionSceneMeta missionMetaLoaded { get; private set; }

	public RoomSceneMeta roomMetaToLoad { get; private set; }

	public RoomSceneMeta roomMetaLoaded { get; private set; }

	public bool MissionIsOpen { get; private set; }

	public bool MissionIsUnloading { get; private set; }

	public static LR Inst => _instance;

	private void Awake()
	{
		IsInitialised = false;
		_instance = this;
		string deviceModel = SystemInfo.deviceModel;
		if (deviceModel != null)
		{
			HACK_isS6Device = deviceModel.Contains("samsung SM-G920") || deviceModel.Contains("samsung SM-G925");
		}
		lrAwake = new HagletResettable(AwakeRoutine(), "LR Awake");
		lrStart = new HagletResettable(StartRoutine(), "LR Start");
		Routine.Start(lrAwake, Host);
	}

	private IEnumerator<HagletYieldTerm> AwakeRoutine()
	{
		CC cc = GetComponent<CC>();
		cc.OnAwakeLR();
		UILoadingBar.Inst.SetRelativeCamera(cc.Camera.transform);
		Localisation.Instance.LoadLocalization(synchronous: true);
		try
		{
			Core.Initialize();
		}
		catch
		{
		}
		OVRPlugin.cpuLevel = 1;
		OVRPlugin.gpuLevel = 2;
		yield return IncrementLoadProgress();
		InitialiseAllHagisUnderRoot();
		yield return IncrementLoadProgress();
		PartyLevelLUT.Initialise();
		ItemImpl.Initialise();
		UnitModel.InitialiseStringToAnimIDDict();
		StatusEffect.Initialise();
		Tutorials.Initialize();
		yield return IncrementLoadProgress();
		HagletHost.@default = Host;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		Setup();
		DC.Instantiate();
		LoadPrefabResource("Controllers/P_SubtitleController");
		LoadPrefabResource("Controllers/P_MusicController");
		LoadPrefabResource("Controllers/P_UIController");
		yield return IncrementLoadProgress();
		GetComponent<RC>().OnAwakeLR();
		GetComponentInChildren<IC>().OnAwakeLR();
		GetComponentInChildren<UIC>().OnAwakeLR();
		GetComponentInChildren<UIFlow>().OnAwakeLR();
		yield return IncrementLoadProgress();
		PSC psc = GetComponentInChildren<PSC>();
		GetComponentOnRoot<GameTypeController>();
		GetComponentInChildren<JK3D>();
		InitialiseUIHierarchy(base.transform);
		yield return IncrementLoadProgress();
		LoadUIResource("UI/P_UIDebug");
		LoadUIResource("UI/P_UIAmbientSubtitles");
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UIWhamBar>(LoadUIResource("UI/P_UIWhamBar"));
		Singleton<UIC>.Inst.Register<UIStoreFront>(LoadUIResource("UI/P_UIStoreFront"));
		Singleton<UIC>.Inst.Register<UINarrativeDialog>(LoadUIResource("UI/P_UINarrativeDialog"));
		Singleton<UIC>.Inst.Register<UIHotspot>(LoadUIResource("UI/P_UIHotspot"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UIStatusBar>(LoadUIResource("UI/P_UIStatusBar"));
		Singleton<UIC>.Inst.Register<UIAbilityWheel>(LoadUIResource("UI/P_UIAbilityWheel"));
		Singleton<UIC>.Inst.Register<UISlotChamp>(LoadUIResource("UI/P_UISlotChamp"));
		Singleton<UIC>.Inst.Register<UIEmpty>(LoadUIResource("UI/P_UIEmpty"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UIMainMenu>(LoadUIResource("UI/P_UIMainMenu"));
		Singleton<UIC>.Inst.Register<UIPauseMenu>(LoadUIResource("UI/P_UIPauseMenu"));
		Singleton<UIC>.Inst.Register<UIOptionsMenu>(LoadUIResource("UI/P_UIOptionsMenu"));
		Singleton<UIC>.Inst.Register<UICredits>(LoadUIResource("UI/P_UICredits"));
		Singleton<UIC>.Inst.Register<UIMissionFailed>(LoadUIResource("UI/P_UIMissionFailed"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UIOculusDemo>(LoadUIResource("UI/P_UIOculusDemo"));
		Singleton<UIC>.Inst.Register<UILoadout>(LoadUIResource("UI/P_UILoadout"));
		Singleton<UIC>.Inst.Register<UIMissionEnd>(LoadUIResource("UI/P_UIMissionEnd"));
		Singleton<UIC>.Inst.Register<UIInventory>(LoadUIResource("UI/P_UIInventory"));
		Singleton<UIC>.Inst.Register<UICharacterDetails>(LoadUIResource("UI/P_UICharacterDetails"));
		Singleton<UIC>.Inst.Register<UIHartmanCutscene>(LoadUIResource("UI/P_UIHartmanCutscene"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UIDemoScreen>(LoadUIResource("UI/P_UIDemoScreen"));
		Singleton<UIC>.Inst.Register<UIDemoExitScreen>(LoadUIResource("UI/P_UIDemoExitScreen"));
		Singleton<UIC>.Inst.Register<UIDemoThanks>(LoadUIResource("UI/P_UIDemoThanks"));
		Singleton<UIC>.Inst.Register<UIMissionBriefing>(LoadUIResource("UI/P_UIMissionBrief"));
		Singleton<UIC>.Inst.Register<UITutorialPanel>(LoadUIResource("UI/P_UITutorialPanel"));
		Singleton<UIC>.Inst.Register<UITutorialMenu>(LoadUIResource("UI/P_UITutorialMenu"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryAbilityWheel>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryAbilityWheel"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryActionGauge>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryActionGauge"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryCombatBar>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryCombatBar"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryCursorIcons>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryCursorIcons"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryInstallingAugments>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryInstallingAugments"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryItemsCurrency>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryItemsCurrency"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_GlossaryStatusEffects>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_GlossaryStatusEffects"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameAbilityGaugeOverride>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameAbilityGaugeOverride"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameAbilityGaugeReact>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameAbilityGaugeReact"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameAbilityGaugeStun>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameAbilityGaugeStun"));
		yield return IncrementLoadProgress();
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameAbilityGaugeV1>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameAbilityGaugeV1"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameAbilityWheel>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameAbilityWheel"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameCombatBar>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameCombatBar"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameEffectSpinner>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameEffectSpinner"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameFlanking>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameFlanking"));
		Singleton<UIC>.Inst.Register<UITutorialGroup_InGameStatusEffects>(LoadUIResource("UI/TutorialGroups/P_UITutorialGroup_InGameStatusEffects"));
		yield return IncrementLoadProgress();
		loadMissionIntoFrontEndRoutine = new HagletResettable(LoadMissionIntoFrontEndRoutine(), "Load Mission into Front End");
		unloadMissionRoutine = new HagletResettable(UnloadMissionRoutine(), "Unload Mission");
		HAGIS.ResumeAllUnderRoot(base.transform, Host);
		ae_logo = Get<SpriteRenderer>("Logo");
		SetLogoAlpha(0f);
		Resources.UnloadUnusedAssets();
		yield return IncrementLoadProgress();
		yield return Routine.Start(lrStart, Host);
	}

	public static UIContainer LoadUIResource(string path)
	{
		GameObject gameObject = LoadPrefabResource(path);
		InitialiseUIHierarchy(gameObject.transform);
		UIContainer component = gameObject.GetComponent<UIContainer>();
		component.HideAll();
		return component;
	}

	public static GameObject LoadPrefabResource(string path, Transform parent = null, Vector3 localPosition = default(Vector3), Quaternion localRotation = default(Quaternion))
	{
		GameObject original = AEResources.LoadFirstResource<GameObject>(path);
		GameObject gameObject = null;
		try
		{
			gameObject = UnityEngine.Object.Instantiate(original, (!parent) ? Inst.transform : parent);
			gameObject.transform.localPosition = localPosition;
			gameObject.transform.localRotation = localRotation;
			gameObject.transform.localScale = Vector3.one;
			return gameObject;
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			if (gameObject != null)
			{
				gameObject.gameObject.SetActive(value: false);
			}
		}
		return null;
	}

	public static void InitialiseUIHierarchy(Transform uiRoot)
	{
		try
		{
			UIElement[] componentsInChildren = uiRoot.GetComponentsInChildren<UIElement>(includeInactive: true);
			UIElement[] array = componentsInChildren;
			foreach (UIElement uIElement in array)
			{
				uIElement.OnAwakeLR();
			}
			UIContainer[] componentsInChildren2 = uiRoot.GetComponentsInChildren<UIContainer>(includeInactive: true);
			UIContainer[] array2 = componentsInChildren2;
			foreach (UIContainer uIContainer in array2)
			{
				uIContainer.Initialise();
			}
			UIContainer[] array3 = componentsInChildren2;
			foreach (UIContainer uIContainer2 in array3)
			{
				uIContainer2.OnAwakeLR();
			}
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			uiRoot.gameObject.SetActive(value: false);
		}
	}

	private IEnumerator<HagletYieldTerm> StartRoutine()
	{
		Singleton<CC>.Inst.OnStartLR();
		yield return IncrementLoadProgress();
		yield return SaveData.Retain();
		if (SaveData.lastResult.IsFailure())
		{
			UnityEngine.Application.Quit();
			yield break;
		}
		yield return IncrementLoadProgress();
		LoadMissionSelectIntoFrontend();
		yield return IncrementLoadProgress();
		if (DEBUG_autoTestFilters != null)
		{
			FinishedInitialization();
			yield break;
		}
		if (SaveData.gotSavedProgress)
		{
			yield return SaveData.LoadProgress(forceLog: false);
			if (SaveData.lastResult.IsFailure())
			{
				SaveData.ClearProgress();
			}
		}
		LoadRoomSceneIntoFrontend(SaveData.data.roomSceneMeta);
		yield return null;
		yield return IncrementLoadProgress();
		FinishedInitialization();
		Singleton<UIFlow>.Inst.StartFrame0ToMainMenu();
		yield return Wait.ForChildren;
	}

	private void FinishedInitialization()
	{
		UnityEngine.Debug.Log("FinishedInitialization");
		IsInitialised = true;
		UILoadingBar.Inst.Hide();
	}

	private HagletYieldTerm IncrementLoadProgress()
	{
		UILoadingBar.Inst.IncrementProgressChunks();
		return Wait.ForSteps(1uL);
	}

	private void Update()
	{
		if (!ovrWaitingForUserToReturn && !OVRPlugin.userPresent && !IsPaused())
		{
			UnityEngine.Debug.Log("User left!");
			ovrWaitingForUserToReturn = true;
			OnApplicationFocus(focus: false);
		}
		else if (ovrWaitingForUserToReturn && OVRPlugin.userPresent)
		{
			UnityEngine.Debug.Log("User returned!");
			ovrWaitingForUserToReturn = false;
			OnApplicationFocus(focus: true);
		}
		if (missionMetaToLoad != null && AreMissionDependenciesLoaded(missionMetaToLoad))
		{
			MissionSceneMeta missionSceneMeta = missionMetaToLoad;
			try
			{
				_OnLoadMissionComplete(SceneManager.GetSceneByName(missionSceneMeta.sceneName));
				OnLoadMissionComplete.Trigger();
			}
			catch (Exception exc)
			{
				CleanupFailedMissionLoad(missionSceneMeta, exc);
			}
		}
		if (!ovrWaitingForUserToReturn)
		{
			Host.Step(HagletStepTime.Update);
		}
	}

	private void _HACKSetTimeScale(float time)
	{
		Time.timeScale = time;
		UnityEngine.Debug.Log("Made the timescale " + Time.timeScale);
	}

	private void CleanupFailedMissionLoad(MissionSceneMeta outgoingMission, Exception exc)
	{
		UnityEngine.Debug.LogErrorFormat("Mission load failed with {0}!", exc);
		lastMissionLoadException = exc;
		if (DEBUG_autoTestFilters != null)
		{
			HAGIS.HACK_MissionException = exc;
		}
		try
		{
			UnloadMissionScene(immediate: true);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogErrorFormat("Unloading failed mission (original exception below) failed with {0}! Force unloading scene.", ex);
			FinalMissionSceneUnload(outgoingMission);
		}
		finally
		{
			missionMetaToLoad = null;
			OnLoadMissionFailed.Trigger();
		}
		Singleton<UIC>.Inst.ClearImmediate();
		Singleton<UIC>.Inst.Push<UIMainMenu>();
		AECameraFullscreenPass.Inst.StartFadeToClear(0.1f);
	}

	private void LateUpdate()
	{
		if (!IsPaused())
		{
			Host.Step(HagletStepTime.LateUpdate);
		}
	}

	public void OnApplicationPause(bool pause)
	{
		if (IsInitialised)
		{
			if (pause && !IsPaused())
			{
				SetPauseState(paused: true);
			}
			else if (!IsPaused())
			{
				SetPauseState(paused: false);
			}
		}
	}

	public void OnApplicationFocus(bool focus)
	{
		SetFocus(focus);
	}

	private void SetFocus(bool focus)
	{
		if (focus)
		{
			UnityEngine.Debug.Log("APPLICATION FOCUSED");
		}
		else
		{
			UnityEngine.Debug.Log("APPLICATION UNFOCUSED");
		}
		if (!IsInitialised)
		{
			return;
		}
		if (!Singleton<UIC>.Inst.IsInStack<UIPauseMenu>())
		{
			if (!focus && !IsPaused())
			{
				SetPauseState(paused: true);
			}
			else if (!IsPaused())
			{
				SetPauseState(paused: false);
			}
			else if (IsPaused() && !Singleton<UIC>.Inst.IsShown<UIPauseMenu>())
			{
				SetPauseState(paused: false);
			}
		}
		AC.Inst.OnFocus(focus);
	}

	public void SetPauseState(bool paused, bool withPauseMenu = true)
	{
		bool flag = IsPaused();
		if (paused && Singleton<UIC>.Inst.IsShown<UIGameOver>())
		{
			return;
		}
		if ((bool)MR.Inst && flag != paused)
		{
			if (paused && withPauseMenu && AECameraFullscreenPass.Inst.CurrentColour.a == 0f)
			{
				Singleton<UIC>.Inst.Push<UIPauseMenu>();
			}
			MR.Inst.KubrickDirector.SetPaused(paused);
			UIWhamBar.Inst.OnPauseUnpause(paused);
			UISlotChamp.Inst.OnPauseUnpause(paused);
			if (GC.Inst != null)
			{
				ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
				int i = 0;
				for (int sLength = unitsActive.sLength; i < sLength; i++)
				{
					unitsActive[i].OnPauseStateChanged(paused);
				}
			}
			if (MR.Inst.hagisSequences != null && paused != flag)
			{
				for (int j = 0; j < MR.Inst.hagisSequences.Count; j++)
				{
					for (int k = 0; k < MR.Inst.hagisSequences[j].Hagii.Length; k++)
					{
						MR.Inst.hagisSequences[j].Hagii[k].OnPauseStateChanged(paused);
					}
				}
			}
		}
		if (Singleton<Hartman>.Inst != null && flag != paused)
		{
			Singleton<Hartman>.Inst.animator.SetPaused(paused);
		}
		if ((bool)Singleton<MC>.Inst && flag != paused)
		{
			Map activeMap = Singleton<MC>.Inst.GetActiveMap();
			Singleton<MC>.Inst.MapShake.Paused = paused;
			if ((bool)activeMap)
			{
				activeMap.SetParticlesPaused(paused);
				activeMap.SetDynamicAnimatorsPaused(paused);
			}
		}
		if ((bool)PSC.Inst)
		{
			PSC.Inst.SetPaused(paused);
		}
		AC.Inst.OnPause(paused);
		_isPaused = paused;
	}

	public bool IsPaused()
	{
		return _isPaused;
	}

	public static void PrepareRadialMaterial(Material radialMaterial, Sprite radialSprite)
	{
		Texture2D texture = radialSprite.texture;
		Rect textureRect = radialSprite.textureRect;
		radialMaterial.SetVector("_RadialUVCenter", new Vector4(textureRect.center.x / (float)texture.width, textureRect.center.y / (float)texture.height, 0f, 0f));
	}

	public T GetSceneMetaFromAssetPath<T>(string sceneMetaPath) where T : SceneMeta
	{
		return AEResources.LoadFirstAsset<T>(sceneMetaPath);
	}

	public T GetSceneMetaFromResourcePath<T>(string sceneMetaPath) where T : SceneMeta
	{
		return AEResources.LoadFirstResource<T>(sceneMetaPath);
	}

	public void LoadRoomSceneIntoFrontend(string sceneMetaPath)
	{
		RoomSceneMeta sceneMetaFromAssetPath = GetSceneMetaFromAssetPath<RoomSceneMeta>(sceneMetaPath);
		LoadRoomSceneIntoFrontend(sceneMetaFromAssetPath);
	}

	public void ShowRoom(RoomSceneMeta room)
	{
		if (room != null)
		{
			roomMetaToLoad = room;
		}
		RC.Inst.RoomShow();
	}

	public void LoadRoomSceneIntoFrontend(RoomSceneMeta sceneMeta)
	{
		roomMetaToLoad = sceneMeta;
		if (roomMetaLoaded == null)
		{
			SceneManager.LoadScene(roomMetaToLoad.sceneName, LoadSceneMode.Additive);
		}
		else if (roomMetaLoaded != sceneMeta)
		{
			SceneManager.UnloadScene(roomMetaLoaded.sceneName);
			SceneManager.LoadScene(roomMetaToLoad.sceneName, LoadSceneMode.Additive);
		}
		roomMetaLoaded = sceneMeta;
	}

	public void LoadMissionSelectIntoFrontend()
	{
		if (MSR.Inst == null)
		{
			SceneManager.LoadScene("_MissionSelect", LoadSceneMode.Additive);
		}
	}

	public void LoadMissionIntoFrontend(MissionSceneMeta sceneMeta, bool immediate = false)
	{
		lastMissionLoadException = null;
		missionMetaToLoad = sceneMeta;
		if (MissionIsOpen)
		{
			UnloadMissionScene(immediate);
		}
		else if (immediate)
		{
			_LoadMissionIntoFrontend();
		}
		else if ((bool)AECameraFullscreenPass.Inst.IsFadedToClear)
		{
			AECameraFullscreenPass inst = AECameraFullscreenPass.Inst;
			inst.OnFadeToColor = (Action)Delegate.Combine(inst.OnFadeToColor, new Action(_LoadMissionIntoFrontend));
			AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, 0.125f);
		}
		else
		{
			_LoadMissionIntoFrontend();
		}
	}

	private void _LoadMissionIntoFrontend()
	{
		AECameraFullscreenPass inst = AECameraFullscreenPass.Inst;
		inst.OnFadeToColor = (Action)Delegate.Remove(inst.OnFadeToColor, new Action(_LoadMissionIntoFrontend));
		MissionIsOpen = true;
		Routine.Start(loadMissionIntoFrontEndRoutine, Host);
	}

	private IEnumerator<HagletYieldTerm> LoadMissionIntoFrontEndRoutine()
	{
		MissionSceneMeta mmToLoad = missionMetaToLoad;
		int loadingSegments = missionMetaToLoad.logicMaps.Length * 2 + 1;
		float percentPerSegement = 1f / (float)loadingSegments;
		float totalProgress3 = 0f;
		UILoadingBar.Inst.Show();
		UILoadingBar.Inst.SetLoadProgress(totalProgress3);
		LoadingScene currentSceneLoad3 = new LoadingScene(mmToLoad.name);
		while (!currentSceneLoad3.IsFinished())
		{
			UILoadingBar.Inst.SetLoadProgress(totalProgress3 + percentPerSegement * currentSceneLoad3.GetProgress());
			yield return null;
		}
		totalProgress3 += percentPerSegement;
		LogicSceneMeta[] logicmaps = missionMetaToLoad.logicMaps;
		foreach (LogicSceneMeta logic in logicmaps)
		{
			LoadingScene currentSceneLoad2 = new LoadingScene(logic.sceneName);
			while (!currentSceneLoad2.IsFinished())
			{
				UILoadingBar.Inst.SetLoadProgress(totalProgress3 + percentPerSegement * currentSceneLoad2.GetProgress());
				yield return null;
			}
			totalProgress3 += percentPerSegement;
			LoadingScene currentSceneLoad = new LoadingScene(logic.artScene.sceneName);
			while (!currentSceneLoad.IsFinished())
			{
				UILoadingBar.Inst.SetLoadProgress(totalProgress3 + percentPerSegement * currentSceneLoad.GetProgress());
				yield return null;
			}
			totalProgress3 += percentPerSegement;
		}
		UILoadingBar.Inst.SetLoadProgress(totalProgress3);
		yield return null;
		UILoadingBar.Inst.Hide();
		UIDebug.Inst.HideAll();
	}

	private void _OnLoadMissionComplete(Scene scene)
	{
		MR component = scene.GetRootGameObjects()[0].GetComponent<MR>();
		component.Setup();
		GameObject gameObject = scene.GetRootGameObjects()[0];
		LogicSceneMeta[] logicMaps = missionMetaToLoad.logicMaps;
		Map map = null;
		foreach (LogicSceneMeta logicSceneMeta in logicMaps)
		{
			map = null;
			Scene sceneByName = SceneManager.GetSceneByName(logicSceneMeta.artScene.sceneName);
			GameObject[] rootGameObjects = sceneByName.GetRootGameObjects();
			for (int j = 0; j < rootGameObjects.Length; j++)
			{
				map = sceneByName.GetRootGameObjects()[j].GetComponent<Map>();
				if (map != null)
				{
					break;
				}
			}
			Transform transform = map.transform;
			transform.SetParent(gameObject.transform, worldPositionStays: false);
			transform.localPosition = Vector3.zero;
			transform.localScale = Vector3.one * 0.08f;
			Transform parent = transform;
			map.Setup();
			LogicRoot component2 = SceneManager.GetSceneByName(logicSceneMeta.sceneName).GetRootGameObjects()[0].GetComponent<LogicRoot>();
			Transform transform2 = component2.transform;
			transform2.SetParent(parent, worldPositionStays: false);
			transform2.localScale = Vector3.one;
			transform2.localPosition = Vector3.zero;
			component2.Setup();
			map.jk3d.Merge(component2.jk3d);
			SceneManager.UnloadScene(logicSceneMeta.artScene.sceneName);
			SceneManager.UnloadScene(logicSceneMeta.sceneName);
		}
		GameObject gameObject2 = LoadPrefabResource("Controllers/P_VFXTileController", component.transform);
		if (map != null)
		{
			gameObject2.transform.parent = map.transform;
			gameObject2.transform.localPosition = new Vector3(0f, 0f, 0f);
			gameObject2.transform.localRotation = Quaternion.identity;
			gameObject2.transform.localScale = new Vector3(1f, 1f, 1f);
		}
		missionMetaLoaded = missionMetaToLoad;
		missionMetaToLoad = null;
		GameObject gameObject3 = LoadPrefabResource("Controllers/P_MapController", MR.Inst.transform);
		MC component3 = gameObject3.GetComponent<MC>();
		JK3D component4 = gameObject3.GetComponent<JK3D>();
		component3.VFXTiles = gameObject2.GetComponent<VFXTileController>();
		component3.VFXTiles.AwakeOnLR();
		component4.AddMaterials(component3.VFXTiles.GetMaterials());
		gameObject3.GetComponent<PC>().OnAwakeLR();
		gameObject3.GetComponent<GC>().OnAwakeLR();
		gameObject3.GetComponent<MC>().OnAwakeLR();
		gameObject3.GetComponent<NC>().OnAwakeLR();
		InitialiseUIHierarchy(gameObject3.transform);
		component.PrepareTileObjectDictionary();
		bool flag = MR.Inst.DEBUG_startingMap != null;
		bool flag2 = flag || missionMetaLoaded.resourcePath != SaveData.loadedMission;
		if (flag2)
		{
			SaveData.OnMissionStart();
		}
		component.OnMissionSceneLoaded(component);
		Singleton<MC>.Inst.OnMissionSceneLoaded(component);
		Singleton<PC>.Inst.OnMissionSceneLoaded(component);
		GC.Inst.OnMissionSceneLoaded(component);
		UIWhamBar.Inst.OnMissionSceneLoaded(component);
		Singleton<NPCWanderController>.Inst.OnMissionSceneLoaded(component);
		MR.Inst.OnMissionStart(component);
		GC.Inst.OnMissionStart(component);
		TileObjectBase[] componentsInChildren = component.transform.GetComponentsInChildren<TileObjectBase>(includeInactive: true);
		foreach (TileObjectBase tileObjectBase in componentsInChildren)
		{
			tileObjectBase.OnMissionStart();
		}
		Singleton<MC>.Inst.OnMissionStart(component);
		Singleton<PC>.Inst.OnMissionStart(component);
		UIObjectives.Inst.OnMissionStart();
		UIAmbientSubtitles.Inst.OnMissionStart();
		Singleton<NPCWanderController>.Inst.OnMissionStart(component);
		if (Singleton<UIBiometricImager>.Inst != null)
		{
			Singleton<UIBiometricImager>.Inst.OnMissionStart();
		}
		GC.Inst.CallSpawnEvents();
		SaveData.data.OnMissionLoad();
		Map[] allMaps = Singleton<MC>.Inst.GetAllMaps();
		foreach (Map map2 in allMaps)
		{
			map2.RenderFogPrepass();
		}
		if (!flag)
		{
			HAGIS.ResumeAllUnderRoot(MR.Inst.transform, MR.Inst.Host);
			if (MR.Inst.mainHagisSequence == null)
			{
				RC.Inst.MapShow(0u);
			}
			else if (flag2)
			{
				RC.Inst.RoomHide();
			}
			return;
		}
		Map map3 = null;
		Map[] allMaps2 = Singleton<MC>.Inst.GetAllMaps();
		foreach (Map map4 in allMaps2)
		{
			if (MR.Inst.DEBUG_startingMap == map4.SceneMetaArt)
			{
				map3 = map4;
			}
		}
		if ((bool)map3)
		{
			Unit unit = null;
			ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
			for (int n = 0; n < unitsAllInWorld.Length; n++)
			{
				if (unitsAllInWorld[n].GetTeamType() == UnitTeam.Type.Player)
				{
					unit = unitsAllInWorld[n];
					break;
				}
			}
			if (!unit)
			{
				unit = unitsAllInWorld[0];
			}
			Singleton<PC>.Inst.SetSelectedUnit(unit);
			RC.Inst.MapShow(Singleton<MC>.Inst.GetIndexWithMap(map3));
			unit.StartTeleport(map3.GetSwapTileAtIndex(0u).coord, map3);
		}
		else
		{
			RC.Inst.MapShow(0u);
		}
		GC.Inst.SetState(GC.State.RPG);
	}

	public HagletEvent UnloadMissionScene(bool immediate = false)
	{
		if (MissionIsUnloading)
		{
			return OnUnloadMissionComplete;
		}
		roomMetaToLoad = SaveData.data.roomSceneMeta;
		if (MR.Inst != null && MR.Inst.Host != null)
		{
			MR.Inst.Host.PauseAll();
		}
		VOController.Inst.VOStop();
		UIAmbientSubtitles.Inst.OnMissionUnloading();
		MissionIsUnloading = true;
		if (immediate)
		{
			OnMissionSceneUnloadComplete();
		}
		else
		{
			Host.StartTopLevel(unloadMissionRoutine);
		}
		return OnUnloadMissionComplete;
	}

	private static bool AreMissionDependenciesLoaded(MissionSceneMeta meta)
	{
		if (!SceneManager.GetSceneByName(meta.sceneName).isLoaded)
		{
			return false;
		}
		LogicSceneMeta[] logicMaps = meta.logicMaps;
		foreach (LogicSceneMeta logicSceneMeta in logicMaps)
		{
			if (!SceneManager.GetSceneByName(logicSceneMeta.sceneName).isLoaded)
			{
				return false;
			}
			if (!SceneManager.GetSceneByName(logicSceneMeta.artScene.sceneName).isLoaded)
			{
				return false;
			}
		}
		return true;
	}

	private void OnMissionSceneUnloadComplete()
	{
		MR inst = MR.Inst;
		Singleton<PC>.Inst.OnMissionSceneUnloaded(inst);
		Singleton<MC>.Inst.OnMissionSceneUnloaded(inst);
		GC.Inst.OnMissionSceneUnloaded(inst);
		UIObjectives.Inst.OnMissionUnloaded();
		UIAmbientSubtitles.Inst.HideAll();
		UIWhamBar.Inst.OnMissionUnloaded();
		UISlotChamp.Inst.OnMissionUnloaded();
		UIStatusBar.Inst.OnMissionUnloaded();
		UIAbilityWheel.Inst.OnMissionUnloaded();
		MR.Inst.OnMissionSceneUnloaded(inst);
		Singleton<NPCWanderController>.Inst.OnMissionSceneUnloaded(inst);
		FinalMissionSceneUnload(missionMetaLoaded);
	}

	public static bool IsS6Device()
	{
		return HACK_isS6Device;
	}

	private IEnumerator<HagletYieldTerm> UnloadMissionRoutine()
	{
		UILoadingBar.Inst.Show(2);
		RC.Inst.RoomShow();
		yield return Wait.ForChildren;
		UILoadingBar.Inst.IncrementProgressChunks();
		MR mr = MR.Inst;
		Singleton<PC>.Inst.OnMissionSceneUnloaded(mr);
		Singleton<MC>.Inst.OnMissionSceneUnloaded(mr);
		GC.Inst.OnMissionSceneUnloaded(mr);
		UIObjectives.Inst.OnMissionUnloaded();
		UIAmbientSubtitles.Inst.HideAll();
		UIWhamBar.Inst.OnMissionUnloaded();
		UISlotChamp.Inst.OnMissionUnloaded();
		UIStatusBar.Inst.OnMissionUnloaded();
		UIAbilityWheel.Inst.OnMissionUnloaded();
		MR.Inst.OnMissionSceneUnloaded(mr);
		Singleton<NPCWanderController>.Inst.OnMissionSceneUnloaded(mr);
		UnityEngine.AsyncOperation unload = SceneManager.UnloadSceneAsync(missionMetaLoaded.sceneName);
		while (!unload.isDone)
		{
			UILoadingBar.Inst.SetProgressToNextChunk(unload.progress);
			yield return null;
		}
		UILoadingBar.Inst.SetProgressToNextChunk(unload.progress);
		yield return null;
		missionMetaLoaded = null;
		MissionIsUnloading = false;
		OnUnloadMissionComplete.Trigger();
		MissionIsOpen = false;
		SaveData.OnMissionSceneUnload();
		UILoadingBar.Inst.Hide();
	}

	private void FinalMissionSceneUnload(MissionSceneMeta mission)
	{
		SceneManager.UnloadScene(mission.sceneName);
		missionMetaLoaded = null;
		MissionIsUnloading = false;
		OnUnloadMissionComplete.Trigger();
		MissionIsOpen = false;
		SaveData.OnMissionSceneUnload();
		UILoadingBar.Inst.Hide();
	}

	public void SetLogoAlpha(float alpha)
	{
		ae_logo.color = ae_logo.color.RepA(alpha);
		if (Mathf.Approximately(alpha, 0f))
		{
			ae_logo.gameObject.SetActive(value: false);
		}
		else
		{
			ae_logo.gameObject.SetActive(value: true);
		}
	}

	public static T Get<T>(string path) where T : UnityEngine.Component
	{
		return Inst.GetComponent<T>(path);
	}

	public static T Get<T>(bool includeInActive = true) where T : UnityEngine.Component
	{
		return Inst.GetComponent<T>(includeInActive);
	}

	public static Transform Get(string path)
	{
		return Inst.GetComponent<Transform>(path);
	}

	public static T[] GetAll<T>(string path, bool includeInActive) where T : UnityEngine.Component
	{
		return Inst.GetComponents<T>(path, includeInActive);
	}

	public static T[] GetAll<T>(bool includeInActive) where T : UnityEngine.Component
	{
		return Inst.GetComponentsInChildren<T>(includeInActive);
	}

	public static Transform[] GetAll(string path)
	{
		return Inst.GetComponents<Transform>(path);
	}

	protected T GetComponent<T>(bool includeInactive = true) where T : UnityEngine.Component
	{
		T componentInChildren = GetComponentInChildren<T>(includeInactive);
		if (componentInChildren == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component !");
			return (T)null;
		}
		return componentInChildren;
	}

	protected T GetComponent<T>(string name) where T : UnityEngine.Component
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
			return (T)null;
		}
		T component = transform.GetComponent<T>();
		if (component == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from gameobject " + transform.name + "!");
			return (T)null;
		}
		return component;
	}

	public T[] GetComponents<T>(string name, bool includeInactive = true) where T : UnityEngine.Component
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
			return null;
		}
		T[] componentsInChildren = transform.GetComponentsInChildren<T>(includeInactive);
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from gameobject " + transform.name + "!");
			return null;
		}
		return componentsInChildren;
	}

	protected T GetComponentOnRoot<T>() where T : UnityEngine.Component
	{
		T component = ((UnityEngine.Component)this).GetComponent<T>();
		if (component == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from LevelRoot!");
			return (T)null;
		}
		return component;
	}
}
[ExecuteInEditMode]
public class LogicRoot : RootBase
{
	public bool unitsMoveToDefaultPositions = true;

	public static bool disableArtCoload;

	public string ambTonePathOverride = string.Empty;

	public float ambAdjustmentParameter;

	private FMOD.Studio.EventInstance ambHandle;

	public bool NPC_Accessible;

	public bool CanTeammatesFollow;

	public Map Map { get; private set; }

	public LogicSceneMeta SceneMetaLogic => base.SceneMeta as LogicSceneMeta;

	public override void Setup()
	{
		base.Setup();
		Map = base.gameObject.GetComponentInAscendant<Map>();
	}

	public void AmbFadeIn()
	{
		if (string.IsNullOrEmpty(ambTonePathOverride))
		{
			ambHandle = AC.Inst.PlayOneShot2D(Map.ambTonePath);
			ambHandle.setParameterValue("AmbientAdjustment", ambAdjustmentParameter);
			Map.SetAmbTargetAjustment();
		}
		else
		{
			ambHandle = AC.Inst.PlayOneShot2D(ambTonePathOverride);
		}
	}

	public void AmbFadeOut()
	{
		AC.Stop(ambHandle);
	}

	[AEAnimFunc]
	public void UnitWalkToTarget(string unitName, string unitTarget)
	{
	}
}
public class MR : RootBase
{
	[NonSceneAsset]
	public ArtSceneMeta DEBUG_startingMap;

	[NonSerialized]
	public HagletHost Host;

	[NonSerialized]
	public Haglet mainHagisSequence;

	[NonSerialized]
	public List<HAGIS.Sequence> hagisSequences;

	[NonSerialized]
	public GameObject roomInteraction;

	[Serializer.Exclude]
	private bool preloadingMission;

	protected static MR _instance;

	private Dictionary<string, TileObjectBase> mapGeneratedIDsToTileObjects = new Dictionary<string, TileObjectBase>();

	public string DEBUG_startingCutscene;

	public string DEBUG_skipToOnStart;

	private ConstArray<HagletEvent> pauseEvents = new ConstArray<HagletEvent>(8u);

	private HagletResettable pauseCutsceneForEvents;

	private DialogData currentCutsceneDialogue;

	private static NC.Path path;

	private static readonly NC.PathRequestComplete storePath = delegate(NC.Path pathIn, Unit unit)
	{
		path = pathIn;
	};

	public MissionSceneMeta SceneMetaMission => base.SceneMeta as MissionSceneMeta;

	public static MR Inst => _instance;

	public KubrickDirector KubrickDirector { get; private set; }

	public void Awake()
	{
		_instance = this;
		KubrickDirector = GetComponent<KubrickDirector>();
		if (SceneMetaMission.roomInteractionsPrefab != null)
		{
			roomInteraction = UnityEngine.Object.Instantiate(SceneMetaMission.roomInteractionsPrefab, base.transform);
		}
		InitialiseAllHagisUnderRoot();
	}

	public void OnMissionSceneLoaded(MR mr)
	{
		preloadingMission = false;
		if (!Singleton<UIC>.Inst.IsInStack<UIStatusBar>())
		{
			Singleton<UIC>.Inst.Push<UIStatusBar>();
		}
	}

	public void OnMissionSceneUnloaded(MR mr)
	{
		if (Host != null && mainHagisSequence != null && (bool)mainHagisSequence.running)
		{
			Host.Pause(mainHagisSequence);
		}
	}

	public void OnMissionStart(MR mr)
	{
		Host = new HagletHost("Mission Root");
		SetupMRCutscenes();
		hagisSequences = new List<HAGIS.Sequence>(10);
	}

	public void OnMissionResume(MR mr)
	{
		SetupMRCutscenes();
	}

	public void Skip(bool stopAtTurnModeEndInTurnMode = true)
	{
		if (Singleton<UIC>.Inst.IsShown<UINarrativeDialog>())
		{
			Singleton<UIC>.Inst.Get<UINarrativeDialog>().Skip();
		}
		UIAmbientSubtitles.Inst.Skip();
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		if ((bool)activeMap)
		{
			activeMap.reservedCoords.Clear();
		}
		if (GC.Inst.IsInTurnMode() && stopAtTurnModeEndInTurnMode)
		{
			Host.Skip(GC.Inst.turnMode);
		}
		else
		{
			Host.Skip(mainHagisSequence);
		}
	}

	public bool IsSkipping()
	{
		return mainHagisSequence != null && mainHagisSequence.skipDepth != -1;
	}

	public bool IsOrWasSkipping()
	{
		return mainHagisSequence != null && (mainHagisSequence.skipDepth != -1 || mainHagisSequence.wasSkipping);
	}

	private void Update()
	{
		if (IC.OnBackButtonShortEvent() && !UIAbilityWheel.Inst.IsShown && (SC.Inst == null || SC.Inst.ability == null) && !UIHotspot.Inst.IsShown && !UIStoreFront.Inst.IsShown && !UIMissionFailed.Inst.IsShown && AECameraFullscreenPass.Inst.CurrentColour.a == 0f && !LR.Inst.IsPaused())
		{
			LR.Inst.SetPauseState(paused: true);
		}
		if (!LR.Inst.IsPaused() && Host != null)
		{
			Host.Step(HagletStepTime.Update);
			PostStepCheck();
		}
	}

	public void LateUpdate()
	{
		if (pauseEvents.Length != 0 && !pauseCutsceneForEvents.running)
		{
			Host.StartTopLevel(pauseCutsceneForEvents, mainHagisSequence);
		}
		if (!LR.Inst.IsPaused() && Host != null)
		{
			Host.Step(HagletStepTime.LateUpdate);
			PostStepCheck();
		}
	}

	private void PostStepCheck()
	{
		if (!LR.Inst.MissionIsUnloading && (IsSkipping() || HAGIS.HACK_MissionException != null))
		{
			Singleton<UIFlow>.Inst.StartMissionToMainMenu();
		}
	}

	public void PrepareTileObjectDictionary()
	{
		TileObjectBase[] componentsInChildren = GetComponentsInChildren<TileObjectBase>();
		int num = componentsInChildren.Length;
		for (int i = 0; i < num; i++)
		{
			TileObjectBase tileObjectBase = componentsInChildren[i];
			if (tileObjectBase.GetType() != typeof(TileBlock))
			{
				mapGeneratedIDsToTileObjects.Add(tileObjectBase.idGenerated, tileObjectBase);
			}
		}
	}

	public T GetTileObject<T>(string generatedId, bool tryGet = false) where T : TileObjectBase
	{
		return (T)mapGeneratedIDsToTileObjects[generatedId];
	}

	public TileTrigger GetTileTrigger(string generatedId)
	{
		return GetTileObject<TileTrigger>(generatedId);
	}

	public UnitTarget GetUnitTarget(string generatedId)
	{
		return GetTileObject<UnitTarget>(generatedId);
	}

	public TileActionSwapMap GetTileActionSwapMap(string generatedId)
	{
		return GetTileObject<TileActionSwapMap>(generatedId);
	}

	public TileActionDialog GetTileActionDialog(string generatedId)
	{
		return GetTileObject<TileActionDialog>(generatedId);
	}

	public TileActionInteraction GetTileActionInteraction(string generatedId)
	{
		return GetTileObject<TileActionInteraction>(generatedId);
	}

	public TileActionGiveLoot GetTileActionGiveLoot(string generatedId)
	{
		return GetTileObject<TileActionGiveLoot>(generatedId);
	}

	public TileActionHotspot GetTileActionHotspot(string generatedId)
	{
		return GetTileObject<TileActionHotspot>(generatedId);
	}

	public TileBlockDynamic GetTileBlockDynamic(string generatedId)
	{
		return GetTileObject<TileBlockDynamic>(generatedId);
	}

	public StoreFront GetStoreFront(string generatedId)
	{
		return GetTileObject<StoreFront>(generatedId);
	}

	public Unit GetUnit(string generatedId)
	{
		return GC.Inst.GetUnitWithId(generatedId);
	}

	public string TryGetUnitTargetName(string generatedId)
	{
		if (!string.IsNullOrEmpty(generatedId) && mapGeneratedIDsToTileObjects.ContainsKey(generatedId))
		{
			UnitTarget unitTarget = GetUnitTarget(generatedId);
			if (unitTarget != null)
			{
				return unitTarget.name;
			}
			return "Target " + generatedId + " DOES NOT EXIST";
		}
		return "UnitTarget";
	}

	public T GetHagis<T>() where T : HAGIS
	{
		return GetComponentInChildren<T>();
	}

	private void SetupMRCutscenes()
	{
		pauseCutsceneForEvents = new HagletResettable(PauseForEventsRoutine(), "Pause Cutscene for Events");
	}

	public HagletEvent CutscenePlay(string cutsceneName)
	{
		return KubrickDirector.Play(cutsceneName);
	}

	[AEAnimFunc]
	private void UnitTeleportToMapViaEntranceTile(string unitId, string entranceTile)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		TileActionSwapMap tileActionSwapMap = GetTileActionSwapMap(entranceTile);
		if (!unitWithId.StartSwapMap(tileActionSwapMap, isSwapTileFromCurrentMap: false, isTeleportIn: true).Failed())
		{
		}
	}

	private static string UnitTeleportToMapViaEntranceTile_GetDisplayName(string unitId, string entranceTile)
	{
		if (GC.Inst == null)
		{
			return "UnitTeleportToMapViaEntranceTile";
		}
		return GC.Inst.GetUnitWithId(unitId).charData.charName + "Teleport to Map";
	}

	[AEAnimFunc]
	private void UnitMoveToMapViaExitTile(string unitId, string exitTileId, float customSpeed)
	{
		Unit unit = GC.Inst.TryGetUnitWithId(unitId);
		TileActionSwapMap tileActionSwapMap = GetTileActionSwapMap(exitTileId);
		if (!(unit == null))
		{
			float? num = null;
			if (customSpeed > 0f)
			{
				num = customSpeed;
			}
			TileActionSwapMap swapTile = tileActionSwapMap;
			bool isSwapTileFromCurrentMap = true;
			bool isTeleportIn = false;
			float? overrideSpeed = num;
			if (!unit.StartSwapMap(swapTile, isSwapTileFromCurrentMap, isTeleportIn, null, overrideSpeed).Failed())
			{
			}
		}
	}

	private static string UnitMoveToMapViaExitTile_GetDisplayName(string unitId, string entranceTile, float customSpeed)
	{
		if (GC.Inst == null)
		{
			return "UnitMoveToMapViaExitTile";
		}
		return GC.Inst.GetUnitWithId(unitId).charData.charName + "Move to Map";
	}

	[AEAnimFunc]
	private void UnitTeleportToTarget(string unitId, string unitTargetId)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		UnitTarget unitTarget = GetUnitTarget(unitTargetId);
		unitWithId.StartTeleport(unitTarget);
	}

	private static float UnitTeleportToTarget_GetDuration(string unitId, string unitTargetId)
	{
		return 1f;
	}

	private static string UnitTeleportToTarget_GetDisplayName(string unitId, string unitTargetId)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(unitTargetId))
		{
			return "UnitTeleport";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "TeleportTo" + Inst.TryGetUnitTargetName(unitTargetId);
	}

	[AEAnimFunc]
	private void UnitMoveToTarget(string unitId, string unitTargetId, bool pauseForEvent, float customSpeed, bool run)
	{
		UnitTarget unitTarget = GetUnitTarget(unitTargetId);
		UnitMoveToCoord(unitId, unitTarget.GetCoord(), pauseForEvent, customSpeed, run);
	}

	private static string UnitMoveToTarget_GetDisplayName(string unitId, string unitTargetId, bool pauseForEvent, float customSpeed, bool run)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(unitTargetId))
		{
			return "UnitMoveToTarget";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "MoveTo" + Inst.TryGetUnitTargetName(unitTargetId);
	}

	[AEAnimFunc]
	private void UnitMoveToUnit(string unitId, string destUnitId, bool pauseForEvent, float customSpeed, bool run)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(destUnitId);
		UnitMoveToCoord(unitId, unitWithId.coord, pauseForEvent, customSpeed, run);
	}

	private static string UnitMoveToUnit_GetDisplayName(string unitId, string destUnitId, bool pauseForEvent, float customSpeed, bool run, bool ignoreOtherUnits)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return "UnitMoveToCoord";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "MoveTo" + GC.Inst.TryGetUnitDisplayName(destUnitId);
	}

	[AEAnimFunc]
	private void UnitMoveToCoord(string unitId, v2i coord, bool pauseForEvent, float customSpeed, bool run, bool ignoreOtherUnits = false)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if ((bool)unitWithId.moving)
		{
			unitWithId.StopMovement(immediate: true);
		}
		v2i? destCoord = coord;
		float? overrideSpeed = ((!(customSpeed > 0f)) ? null : new float?(customSpeed));
		bool ignoreShortMovementAnim = run;
		bool ignoreUnitAtDestination = ignoreOtherUnits;
		unitWithId.StartMovement(destCoord, null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, overrideSpeed, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination, null, ignoreShortMovementAnim);
		HagletEvent movementStopped = unitWithId.movementStopped;
		if (pauseForEvent && !Inst.IsSkipping() && coord != unitWithId.coord)
		{
			pauseEvents.Add(movementStopped);
		}
	}

	private static string UnitMoveToCoord_GetDisplayName(string unitId, v2i coord, bool pauseForEvent, float customSpeed, bool run, bool ignoreOtherUnits)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return "UnitMoveToCoord";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "MoveTo" + coord;
	}

	[AEAnimFunc]
	private void SnapUnitToCoord(string unitId, v2i coord)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		unitWithId.SetCoord(coord);
	}

	private static float SnapUnitToCoord_GetDuration(string unitId, v2i coord)
	{
		return 0.1f;
	}

	private static string SnapUnitToCoord_GetDisplayName(string unitId, v2i coord)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return "PlayAnimation";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "SnapTo" + coord;
	}

	[AEAnimFunc]
	private void UnitLookAtUnit(string unitId, string targetUnitID, bool keepEyeOn)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		Unit unitWithId2 = GC.Inst.GetUnitWithId(targetUnitID);
		if ((bool)unitWithId.moving)
		{
			unitWithId.StopMovement(immediate: true);
		}
		if (unitWithId != null && unitWithId2 != null)
		{
			unitWithId.LookAt(unitWithId2._GetTransform(), keepEyeOn);
		}
	}

	private static string UnitLookAtUnit_GetDisplayName(string unitId, string targetUnitID, bool keepEyeOn)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(targetUnitID))
		{
			return "UnitLookAtUnit";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "LookAt" + GC.Inst.TryGetUnitDisplayName(targetUnitID);
	}

	[AEAnimFunc]
	private void UnitLookAtCoord(string unitId, v2i coord)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if ((bool)unitWithId.moving)
		{
			unitWithId.StopMovement(immediate: true);
		}
		unitWithId.LookAt(coord);
	}

	private static string UnitLookAtCoord_GetDisplayName(string unitId, v2i coord)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return "UnitLookAtCoord";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "LookAt" + coord;
	}

	private static float UnitMove_GetDuration(string unitId, string unitTargetId, bool pauseForEvent)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		UnitTarget unitTarget = Inst.GetUnitTarget(unitTargetId);
		NC.Inst.CalculatePath(unitWithId, unitTarget.GetCoord(), includeObservedTiles: true, storePath);
		float num = 0f;
		Vector3 b = path.positions[0];
		int i = 1;
		for (int count = path.positions.Count; i < count; i++)
		{
			Vector3 vector = path.positions[i];
			num += unitWithId.CalculateMoveTime(vector, b);
			b = vector;
		}
		path = null;
		return num;
	}

	private static string UnitMove_GetDisplayName(string unitId, string unitTargetId, bool pauseForEvent)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(unitTargetId))
		{
			return "UnitMove";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "MoveTo" + Inst.TryGetUnitTargetName(unitTargetId);
	}

	[AEAnimFunc]
	private void AmbientSubtitleShow(DialogData data, bool noReIdle)
	{
		UIAmbientSubtitles inst = UIAmbientSubtitles.Inst;
		bool dontReturnToIdle = noReIdle;
		inst.Show(data, null, null, dontReturnToIdle);
	}

	private static float AmbientSubtitleShow_GetDuration(DialogData data, bool noReIdle)
	{
		if ((bool)data)
		{
			float num = 0f;
			for (int i = 0; i < data.dialogs.Length; i++)
			{
				DialogData.Dialog dialog = data.dialogs[i];
				AC.Inst.GetDescription(VOController.Inst.GetVOGuid(dialog.bodyKey)).getLength(out var length);
				num += Mathf.Max((float)length * 0.001f, data.dialogs[i].subtitleTime);
				num += dialog.bufferTime;
			}
			return num;
		}
		return 0f;
	}

	private static string AmbientSubtitleShow_GetDisplayName(DialogData data, bool noReIdle)
	{
		if (GC.Inst == null || data == null)
		{
			return "AmbientSubtitleShow";
		}
		return data.name;
	}

	[AEAnimFunc]
	private void ShowDialogue(DialogData dialogue)
	{
		dialogue.Prepare();
		currentCutsceneDialogue = dialogue;
		try
		{
			if (!Inst.IsSkipping())
			{
				pauseEvents.Add(HAGIS.DialogShow(dialogue));
			}
			UnityEngine.Debug.Log(pauseEvents.Length);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	private static string ShowDialogue_GetDisplayName(DialogData dialogue)
	{
		if (GC.Inst == null || dialogue == null)
		{
			return "ShowDialogue";
		}
		return dialogue.name;
	}

	[AEAnimFunc]
	public void PlayMusic(string eventPath, float progress, float fade)
	{
		if (MusicController.Inst != null)
		{
			MusicController.Inst.Play(eventPath, progress, fade);
		}
	}

	private static string PlayMusic_GetDisplayName(string eventPath, float progress, float fade)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(eventPath))
		{
			return "PlayMusic";
		}
		return eventPath;
	}

	[AEAnimFunc]
	public void StopMusic()
	{
		if (MusicController.Inst != null)
		{
			MusicController.Inst.Stop();
		}
	}

	private static string StopMusic_GetDisplayName()
	{
		return "StopMusic";
	}

	[AEAnimFunc]
	public void SetMusicProgress(float progress)
	{
		if (MusicController.Inst != null)
		{
			MusicController.Inst.SetProgress(progress);
		}
	}

	private static string SetMusicProgress_GetDisplayName()
	{
		return "SetMusicProgress";
	}

	[AEAnimFunc]
	public void SetMusicParameter(MusicController.MusicParameters param, float value)
	{
		MusicController.Inst.SetMusicParameter(param, value);
	}

	[AEAnimFunc]
	public void PlaySoundAt(string eventPath, FMODParam[] fmodParams)
	{
		FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot2D(eventPath);
		if (eventInstance.isValid())
		{
			for (int i = 0; i < fmodParams.Length; i++)
			{
				eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
			}
		}
	}

	private static string PlaySoundAt_GetDisplayName(string eventPath, FMODParam[] fmodParams)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(eventPath))
		{
			return "PlaySoundAt";
		}
		return eventPath;
	}

	[AEAnimFunc]
	public void PlaySoundAtCoord(string eventPath, FMODParam[] fmodParams, v2i coord)
	{
		FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot3D(eventPath, Singleton<MC>.Inst.GetActiveMap().CoordToWorldPos(coord));
		if (eventInstance.isValid())
		{
			for (int i = 0; i < fmodParams.Length; i++)
			{
				eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
			}
		}
	}

	private static string PlaySoundAtCoord_GetDisplayName(string eventPath, FMODParam[] fmodParams, v2i coord)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(eventPath))
		{
			return "PlaySoundAtCoord";
		}
		return eventPath;
	}

	[AEAnimFunc]
	private void ToggleMapShake(bool shaking)
	{
		HAGIS.ToggleShakeEnvironment(shaking);
	}

	[AEAnimFunc]
	private void MapShakeOneShot()
	{
		HAGIS.ShakeOneShot();
	}

	[AEAnimFunc]
	private void PlayEnvironmentalAnimation(string kubrickName, string fullAnimName, WrapMode wrapMode)
	{
		KubrickAnimator dynamicAnimator = Singleton<MC>.Inst.GetActiveMap().GetDynamicAnimator(kubrickName);
		dynamicAnimator.blending = 0f;
		dynamicAnimator.Play(fullAnimName);
		dynamicAnimator.WrapMode = wrapMode;
	}

	private static float PlayEnvironmentalAnimation_GetDuration(string kubrickName, string fullAnimName, WrapMode wrapMode)
	{
		if (Singleton<MC>.Inst == null || Singleton<MC>.Inst.GetActiveMap() == null || string.IsNullOrEmpty(kubrickName) || string.IsNullOrEmpty(fullAnimName))
		{
			return 0f;
		}
		KubrickAnimator kubrickAnimator = Singleton<MC>.Inst.GetActiveMap().TryGetDynamicAnimator(kubrickName);
		if (kubrickAnimator != null)
		{
			AEAnimClip aEAnimClip = kubrickAnimator.TryGetClipByName(fullAnimName);
			if (aEAnimClip != null)
			{
				return aEAnimClip.Duration;
			}
		}
		return 1f;
	}

	private static string PlayEnvironmentalAnimation_GetDisplayName(string kubrickName, string fullAnimName, WrapMode wrapMode)
	{
		return "PlayMapAnim:" + fullAnimName;
	}

	[AEAnimFunc]
	private void PlayAnimation(string unitId, string animationName, bool pauseForEvent, bool loop, bool updateIdleOnComplete)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		UnitModel unitModel = unitWithId.unitModel;
		bool looping = loop;
		bool updateIdleOnComplete2 = updateIdleOnComplete;
		HagletEvent obj = unitModel.Play(animationName, looping, crouched: false, interacting: false, updateIdleOnComplete2);
		if (pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private static float PlayAnimation_GetDuration(string unitId, string animationName, bool pauseForEvent, bool loop, bool updateIdleOnComplete)
	{
		if (pauseForEvent || GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(animationName))
		{
			return 0f;
		}
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if (unitWithId != null)
		{
			return unitWithId.unitModel.GetAnimDuration(animationName);
		}
		return 1f;
	}

	private static string PlayAnimation_GetDisplayName(string unitId, string animationName, bool pauseForEvent, bool loop, bool updateIdleOnComplete)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(animationName))
		{
			return "PlayAnimation";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "Play" + animationName;
	}

	[AEAnimFunc]
	private void ActivateUnitWithAnimation(string unitId, string animationName)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		unitWithId.SetActiveWithAnimation(animationName);
	}

	private static float ActivateUnitWithAnimation_GetDuration(string unitId, string animationName)
	{
		return PlayAnimation_GetDuration(unitId, animationName, pauseForEvent: false, loop: false, updateIdleOnComplete: false);
	}

	private static string ActivateUnitWithAnimation_GetDisplayName(string unitId, string animationName)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId) || string.IsNullOrEmpty(animationName))
		{
			return "ActivateUnitWithAnimation";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "ActivateAndPlay" + animationName;
	}

	[AEAnimFunc]
	private void PlayAnimationID(string unitId, UnitModel.AnimID animationId, bool pauseForEvent)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		HagletEvent obj = unitWithId.unitModel.Play(animationId);
		if (pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private static float PlayAnimationID_GetDuration(string unitId, UnitModel.AnimID animationId, bool pauseForEvent)
	{
		if (pauseForEvent || GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return 0f;
		}
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if (unitWithId != null)
		{
			return unitWithId.unitModel.GetAnimDuration(animationId);
		}
		return 1f;
	}

	private static string PlayAnimationID_GetDisplayName(string unitId, UnitModel.AnimID animationId, bool pauseForEvent)
	{
		if (GC.Inst == null)
		{
			return "PlayAnimationID";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "Play" + animationId;
	}

	[AEAnimFunc]
	private void PlayAnimationIDAndSnapPos(string unitId, UnitModel.AnimID animationId, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		unitWithId.unitModel.SetBlending(blend: false);
		HagletEvent obj = unitWithId.unitModel.Play(animationId);
		unitWithId.StartSnapToPosition(coord, (!snapDir) ? null : new OctDir?(direction), waitForModelToSnap: true);
		if (pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private static float PlayAnimationIDAndSnapPos_GetDuration(string unitId, UnitModel.AnimID animationId, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		return PlayAnimationID_GetDuration(unitId, animationId, pauseForEvent);
	}

	private static string PlayAnimationIDAndSnapPos_GetDisplayName(string unitId, UnitModel.AnimID animationId, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		if (GC.Inst == null)
		{
			return "PlayAnimIDAndSnapPos";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "Play" + animationId.ToString() + "At" + coord.ToString();
	}

	[AEAnimFunc]
	private void PlayAnimationAndSnapPos(string unitId, string animation, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		unitWithId.unitModel.SetBlending(blend: false);
		HagletEvent obj = unitWithId.unitModel.Play(animation);
		unitWithId.StartSnapToPosition(coord, (!snapDir) ? null : new OctDir?(direction), waitForModelToSnap: true);
		if (pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private static float PlayAnimationAndSnapPos_GetDuration(string unitId, string animation, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		return PlayAnimation_GetDuration(unitId, animation, pauseForEvent, loop: false, updateIdleOnComplete: false);
	}

	private static string PlayAnimationAndSnapPos_GetDisplayName(string unitId, string animation, v2i coord, bool snapDir, OctDir direction, bool pauseForEvent)
	{
		if (GC.Inst == null)
		{
			return "PlayAnimAndSnapPos";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "Play" + animation + "At" + coord.ToString();
	}

	[AEAnimFunc]
	private void PlayParticleEffect(ParticleTypes particleEffect, v2i coord)
	{
		PSC.Inst.Play(particleEffect, Singleton<MC>.Inst.GetActiveMap(), coord);
	}

	private static string PlayParticleEffect_GetDisplayName(ParticleTypes particleEffect, v2i coord)
	{
		return "Play" + particleEffect.ToString() + "At" + coord.ToString();
	}

	[AEAnimFunc]
	private void SetAnimOverride(string unitId, UnitModel.AnimID animationId, string animName, bool updateIdleAnims, bool clearOverride)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if ((bool)unitWithId)
		{
			if (clearOverride)
			{
				unitWithId.unitModel.SetAnimOverride(animationId, unitWithId.unitModel.GetAnimName(animationId, ignoreOverride: true));
			}
			else
			{
				unitWithId.unitModel.SetAnimOverride(animationId, animName);
			}
			if (updateIdleAnims)
			{
				unitWithId.UpdateIdleAnim();
			}
		}
	}

	private static string SetAnimOverride_GetDisplayName(string unitId, UnitModel.AnimID animationId, string animName, bool updateIdleAnims, bool clearOverride)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return ((!clearOverride) ? "Set" : "Clear") + animationId.ToString() + "Override";
		}
		try
		{
			if (clearOverride)
			{
				return "Clear" + GC.Inst.TryGetUnitDisplayName(unitId) + animationId.ToString() + "Override";
			}
			return "Set" + GC.Inst.TryGetUnitDisplayName(unitId) + animationId.ToString() + " to " + animName;
		}
		catch
		{
			return ((!clearOverride) ? "Set" : "Clear") + animationId.ToString() + "Override";
		}
	}

	[AEAnimFunc]
	private void SetTargetActive(string targetId, bool active)
	{
		GetUnitTarget(targetId).gameObject.SetActive(active);
	}

	private static string SetTargetActive_GetDisplayName(string targetId, bool active)
	{
		if (_instance == null)
		{
			return "SetUnitTarget " + active;
		}
		return "Set " + Inst.TryGetUnitTargetName(targetId) + " " + active;
	}

	[AEAnimFunc]
	private void SetUnitActive(string unitId, bool active, bool keepUnitInGame)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		if (!unitWithId)
		{
			return;
		}
		if (active)
		{
			if (unitWithId.gameObject.activeSelf)
			{
				unitWithId.OnEnable();
			}
			else
			{
				unitWithId.gameObject.SetActive(value: true);
			}
		}
		else
		{
			unitWithId.Hide(!keepUnitInGame);
		}
	}

	private static string SetUnitActive_GetDisplayName(string unitId, bool active, bool keepUnitInGame)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(unitId))
		{
			return "SetUnitActive";
		}
		try
		{
			return "Set" + GC.Inst.TryGetUnitDisplayName(unitId) + ((!active) ? "Inactive" : "Active");
		}
		catch
		{
			return "SetUnitActive";
		}
	}

	[AEAnimFunc]
	public void UnitAttackUnit(string unitId, string targetUnitId, bool meleeAttack, Combat.HitType hitType, string overrideAnim, bool updateIdle = true, bool pauseForEvent = true, bool killTarget = false)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		Unit unitWithId2 = GC.Inst.GetUnitWithId(targetUnitId);
		if (killTarget)
		{
			unitWithId2.HPDecrement(unitWithId2.HP - 1);
		}
		Combat.CombatData combatData = default(Combat.CombatData);
		combatData.hitType = hitType;
		combatData.critChance = 0;
		combatData.dodgeChance = 0;
		combatData.hitChance = 100;
		combatData.additionalEffect = Combat.HitType.None;
		Combat.CombatData value = combatData;
		Unit target = unitWithId2;
		WeaponAttributes weapon = ((!meleeAttack) ? unitWithId.RangedWeapon : unitWithId.MeleeWeapon);
		bool costsAP = false;
		Combat.CombatData? overrideCombatData = value;
		bool updateIdleOnComplete = updateIdle;
		if (unitWithId.StartAttack(target, weapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, overrideAnim, 1, Combat.CombatMinigame.None, overrideCombatData, updateIdleOnComplete) && pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(unitWithId.OnFinishedAttack);
		}
	}

	private static string UnitAttackUnit_GetDisplayName(string unitId, string targetUnitId, bool meleeAttack, Combat.HitType hitType, string overrideAnim, bool updateIdle = true, bool pauseForEvent = true, bool killTarget = false)
	{
		if (GC.Inst == null)
		{
			return "Unit" + ((!killTarget) ? "Attack" : "Kill") + "Unit";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + ((!killTarget) ? "Attack" : "Kill") + GC.Inst.TryGetUnitDisplayName(targetUnitId);
	}

	[AEAnimFunc]
	public void UnitAttackCoord(string unitId, v2i coord, string animOverride, bool updateIdle, bool pauseForEvent)
	{
		Unit unitWithId = GC.Inst.GetUnitWithId(unitId);
		HagletEvent obj = unitWithId.StartFakeAttack(coord, updateIdle, animOverride);
		if (pauseForEvent && !Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private static string UnitAttackCoord_GetDisplayName(string unitId, v2i coord, string animOverride, bool updateIdle, bool pauseForEvent)
	{
		if (GC.Inst == null)
		{
			return "UnitAttackCoord";
		}
		return GC.Inst.TryGetUnitDisplayName(unitId) + "Attack" + coord;
	}

	[AEAnimFunc]
	public void SetCoverActive(string coverId, bool active)
	{
		TileBlockDynamic tileBlockDynamic = GetTileBlockDynamic(coverId);
		tileBlockDynamic.gameObject.SetActive(active);
	}

	public static string SetCoverActive_GetDisplayName(string coverId, bool active)
	{
		if (string.IsNullOrEmpty(coverId) || coverId.Length < 3)
		{
			return "Setting invalid Cover " + active;
		}
		return "Setting Cover " + coverId.Substring(0, 3) + " " + active;
	}

	[AEAnimFunc]
	private void ShowCustomDialogue(DialogData.Type dialogType, string unitID, string sfxAssetPath, string header, string body, DialogData internalDialogueRef)
	{
		currentCutsceneDialogue = internalDialogueRef;
		HagletEvent obj = HAGIS.DialogShow(currentCutsceneDialogue);
		if (!Inst.IsSkipping())
		{
			pauseEvents.Add(obj);
		}
	}

	private IEnumerator<HagletYieldTerm> PauseForEventsRoutine()
	{
		KubrickDirector.SetPaused(paused: true);
		HagletYieldTerm pauseTerm = Wait.None;
		uint num = 0u;
		for (uint length = pauseEvents.Length; num < length; num++)
		{
			pauseTerm &= (HagletYieldTerm)pauseEvents[num];
		}
		pauseEvents.Clear();
		yield return pauseTerm;
		KubrickDirector.SetPaused(paused: false);
	}
}
public class MSR : RootBase
{
	private UIMissionSelect uiRoot;

	protected static MSR _instance;

	public static MSR Inst => _instance;

	private void Awake()
	{
		_instance = this;
		uiRoot = base.transform.Find("Root").GetComponent<UIMissionSelect>();
		Setup();
		LR.InitialiseUIHierarchy(uiRoot.transform);
		Singleton<UIC>.Inst.Register<UIMissionSelect>(uiRoot);
	}

	private void Start()
	{
		uiRoot.HideAll();
	}

	public void Hide(Action<Map, Map> onComplete)
	{
		onComplete(null, null);
	}

	public static T Get<T>(string path) where T : UnityEngine.Component
	{
		return Inst.GetComponent<T>(path);
	}

	public static T Get<T>(bool includeInActive = true) where T : UnityEngine.Component
	{
		return Inst.GetComponent<T>(includeInActive);
	}

	public static Transform Get(string path)
	{
		return Inst.GetComponent<Transform>(path);
	}

	public static T[] GetAll<T>(string path, bool includeInActive) where T : UnityEngine.Component
	{
		return Inst.GetComponents<T>(path, includeInActive);
	}

	public static T[] GetAll<T>(bool includeInActive) where T : UnityEngine.Component
	{
		return Inst.GetComponentsInChildren<T>(includeInActive);
	}

	public static Transform[] GetAll(string path)
	{
		return Inst.GetComponents<Transform>(path);
	}

	protected T GetComponent<T>(bool includeInactive = true) where T : UnityEngine.Component
	{
		T componentInChildren = GetComponentInChildren<T>(includeInactive);
		if (componentInChildren == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component !");
			return (T)null;
		}
		return componentInChildren;
	}

	protected T GetComponent<T>(string name) where T : UnityEngine.Component
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
			return (T)null;
		}
		T component = transform.GetComponent<T>();
		if (component == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from gameobject " + transform.name + "!");
			return (T)null;
		}
		return component;
	}

	public T[] GetComponents<T>(string name, bool includeInactive = true) where T : UnityEngine.Component
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
			return null;
		}
		T[] componentsInChildren = transform.GetComponentsInChildren<T>(includeInactive);
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from gameobject " + transform.name + "!");
			return null;
		}
		return componentsInChildren;
	}

	protected T GetComponentOnRoot<T>() where T : UnityEngine.Component
	{
		T component = ((UnityEngine.Component)this).GetComponent<T>();
		if (component == null)
		{
			UnityEngine.Debug.LogWarning("Failed to get: '" + typeof(T).FullName + "' component from LevelRoot!");
			return (T)null;
		}
		return component;
	}
}
public class RR : RootBase
{
	public class RoomHagisResettable : HagletResettable
	{
		public GameObject currentHagis;

		public RoomHagisResettable()
			: base(Inst.RoomHagisRoutine(), "Room Hagis Routine")
		{
		}

		protected RoomHagisResettable(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public Mesh skyboxMesh;

	public Material skyboxMaterial;

	private GameObject skyboxGameObject;

	private FMOD.Studio.EventInstance ambienceHandle;

	private FMOD.Studio.EventInstance reverbHandle;

	public string ambTonePath;

	private Color colorSkyboxMin;

	private Color colorSkyboxMax;

	private int shaderID_ColorSkyboxMin;

	private int shaderID_ColorSkyboxMax;

	private Material[] roomMaterials;

	private MeshRenderer[] meshRenderersInRoom;

	private GameObject[] childGameObjects;

	private Transform[] cutoutGameObjects;

	private Dictionary<string, KubrickBase> roomAnimators = new Dictionary<string, KubrickBase>();

	private Dictionary<string, ParticleSystem> roomPfx = new Dictionary<string, ParticleSystem>();

	[NonSceneAsset]
	public GameObject DEBUG_hartmanScript;

	public Dictionary<string, Transform> roomAudioSources = new Dictionary<string, Transform>();

	private float hartmanPotterSpeed = 1f;

	private bool shouldPotter;

	private bool randomPotter;

	public HagletResettable hartmanPotteringRoutine;

	private HartmanPotterPoint[] potterPoints;

	private RoomHagisResettable roomHagisResettable;

	protected static RR _instance;

	public HagletEvent roomHagisCompleted => roomHagisResettable.completed;

	public static RR Inst => _instance;

	public void Awake()
	{
		Setup();
		KubrickBase[] componentsInChildren = GetComponentsInChildren<KubrickBase>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!roomAnimators.ContainsKey(componentsInChildren[i].name))
			{
				roomAnimators.Add(componentsInChildren[i].name, componentsInChildren[i]);
			}
		}
		ParticleSystem[] componentsInChildren2 = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		for (int j = 0; j < componentsInChildren2.Length; j++)
		{
			if (!roomPfx.ContainsKey(componentsInChildren2[j].name) && componentsInChildren2[j].GetComponentInAscendant<ParticleSystem>(includeSelf: false) == null)
			{
				roomPfx.Add(componentsInChildren2[j].name, componentsInChildren2[j]);
			}
		}
		SpawnPrefab<STUB_HartmanSpawn>("P_Hartman");
		_instance = this;
		JK3DAtlasMaterial materialsWithName = jk3d.GetMaterialsWithName("RoomDiffuse");
		HashSet<Material> hashSet = new HashSet<Material>();
		meshRenderersInRoom = GetComponentsInChildren<MeshRenderer>();
		for (uint num = 0u; num < meshRenderersInRoom.Length; num++)
		{
			hashSet.Add(meshRenderersInRoom[num].sharedMaterial);
		}
		SkinnedMeshRenderer[] componentsInChildren3 = Singleton<Hartman>.Inst.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (uint num2 = 0u; num2 < componentsInChildren3.Length; num2++)
		{
			hashSet.Add(componentsInChildren3[num2].sharedMaterial);
		}
		shaderID_ColorSkyboxMin = Shader.PropertyToID("_ColorSkyboxMin");
		shaderID_ColorSkyboxMax = Shader.PropertyToID("_ColorSkyboxMax");
		colorSkyboxMin = skyboxMaterial.GetColor(shaderID_ColorSkyboxMin);
		colorSkyboxMax = skyboxMaterial.GetColor(shaderID_ColorSkyboxMax);
		RC.Inst.SetWireframeSkyboxColors(colorSkyboxMin, colorSkyboxMax);
		roomMaterials = hashSet.ToArray();
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.transform)
		{
			if (item.name != "Shared Artwork")
			{
				list.Add(item.gameObject);
			}
		}
		childGameObjects = list.ToArray();
		STUB_RoomCutout componentInChildren = GetComponentInChildren<STUB_RoomCutout>();
		cutoutGameObjects = componentInChildren.GetComponentsInChildren<Transform>();
		componentInChildren.transform.position = Vector3.zero;
		for (int k = 0; k < cutoutGameObjects.Length; k++)
		{
			cutoutGameObjects[k].gameObject.SetActive(value: false);
		}
		skyboxGameObject = new GameObject("skybox");
		skyboxGameObject.transform.SetParent(base.transform, worldPositionStays: false);
		skyboxGameObject.layer = 16;
		skyboxGameObject.transform.localScale = new Vector3(15f, 15f, 15f);
		Material sharedMaterial = new Material(skyboxMaterial);
		MeshRenderer meshRenderer = skyboxGameObject.AddComponent<MeshRenderer>();
		meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		meshRenderer.receiveShadows = false;
		meshRenderer.motionVectorGenerationMode = MotionVectorGenerationMode.ForceNoMotion;
		meshRenderer.lightProbeUsage = LightProbeUsage.Off;
		meshRenderer.reflectionProbeUsage = ReflectionProbeUsage.Off;
		meshRenderer.sharedMaterial = sharedMaterial;
		MeshFilter meshFilter = skyboxGameObject.AddComponent<MeshFilter>();
		meshFilter.sharedMesh = skyboxMesh;
		skyboxGameObject.SetActive(value: false);
		meshRenderer.sortingOrder = -200;
		roomHagisResettable = new RoomHagisResettable();
		hartmanPotteringRoutine = new HagletResettable(HartmanPotteringRoutine(), "Hartman Potter Routine");
		potterPoints = GetComponentsInChildren<HartmanPotterPoint>();
		STUB_RoomAudioSource[] componentsInChildren4 = GetComponentsInChildren<STUB_RoomAudioSource>();
		STUB_RoomAudioSource[] array = componentsInChildren4;
		foreach (STUB_RoomAudioSource sTUB_RoomAudioSource in array)
		{
			roomAudioSources.Add(sTUB_RoomAudioSource.name, sTUB_RoomAudioSource.transform);
		}
		InitialiseAllHagisUnderRoot();
		Material[] array2 = roomMaterials;
		foreach (Material material in array2)
		{
			material.EnableKeyword("PENTHOUSE_ON");
		}
	}

	public Transform GetRoomAudioSource(string name)
	{
		Transform value = null;
		if (roomAudioSources.TryGetValue(name, out value))
		{
			return value;
		}
		return null;
	}

	private void SpawnPrefab<T>(string resourceName) where T : UnityEngine.Component
	{
		T componentInChildren = GetComponentInChildren<T>();
		if ((bool)componentInChildren)
		{
			GameObject gameObject = AEResources.LoadFirstResource<GameObject>(resourceName);
			if ((bool)gameObject)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, componentInChildren.transform.position, componentInChildren.transform.rotation);
				gameObject2.name = gameObject2.name.Replace("(Clone)", string.Empty);
				gameObject2.transform.parent = componentInChildren.transform.parent;
			}
		}
	}

	private void Start()
	{
		RoomAmbiencePlay();
	}

	private void LateUpdate()
	{
		float newVal = RC.Inst.FogUpdate();
		Color value = colorSkyboxMin.RepA(newVal);
		Material[] array = roomMaterials;
		foreach (Material material in array)
		{
			material.SetColor(shaderID_ColorSkyboxMin, value);
			material.SetColor(shaderID_ColorSkyboxMax, colorSkyboxMax);
		}
	}

	public void ShowArtwork()
	{
		for (int i = 0; i < childGameObjects.Length; i++)
		{
			childGameObjects[i].SetActive(value: true);
		}
		skyboxGameObject.SetActive(value: false);
		Material[] array = roomMaterials;
		foreach (Material material in array)
		{
			material.EnableKeyword("PENTHOUSE_ON");
		}
		RoomAmbiencePlay();
	}

	public void HideArtwork()
	{
		for (int i = 0; i < childGameObjects.Length; i++)
		{
			childGameObjects[i].SetActive(value: false);
		}
		skyboxGameObject.SetActive(value: true);
		Material[] array = roomMaterials;
		foreach (Material material in array)
		{
			material.DisableKeyword("PENTHOUSE_ON");
		}
		RoomAmbienceStop();
	}

	private void RoomAmbiencePlay()
	{
		RoomAmbienceStop();
		ambienceHandle = AC.Inst.PlayOneShot2D(ambTonePath);
		reverbHandle = AC.Inst.PlaySnapshot("snapshot:/reverb");
		if (reverbHandle.isValid())
		{
			reverbHandle.setParameterValue("reverb", 0.25f);
		}
	}

	private void RoomAmbienceStop()
	{
		AC.Stop(ambienceHandle);
		AC.Stop(reverbHandle);
	}

	public IEnumerator<HagletYieldTerm> RoomHagisRoutine()
	{
		Singleton<UIC>.Inst.Push<UIHartmanCutscene>();
		yield return Singleton<UIC>.Inst.pushPopComplete;
		GameObject hagis = UnityEngine.Object.Instantiate(roomHagisResettable.currentHagis);
		HAGIS hagisScript = hagis.GetComponent<HAGIS>();
		roomHagisResettable.currentHagis = null;
		hagisScript.OnAwakeRoot();
		Haglet hagisHaglet = new Haglet(hagisScript.OnLogic(), hagis.name, HagletStepTime.LateUpdate, 10, LR.Host);
		Haglet started = hagisHaglet;
		Haglet currHag = HagletHost.currHag;
		yield return Routine.Start(started, null, currHag);
		yield return null;
		while ((bool)hagisHaglet.running)
		{
			yield return null;
		}
		UnityEngine.Object.Destroy(hagis);
		yield return Singleton<UIC>.Inst.Pop();
	}

	public HagletYieldTerm PlayRoomHagis(GameObject hagisScript)
	{
		roomHagisResettable.currentHagis = hagisScript;
		return Routine.Start(roomHagisResettable, LR.Host, HagletHost.currHag);
	}

	public void TrySkipRoomHAGIS()
	{
		if ((bool)roomHagisResettable.running)
		{
			roomHagisResettable.host.Skip(roomHagisResettable);
		}
	}

	public KubrickBase GetRoomAnimator(string animatorName)
	{
		return roomAnimators[animatorName];
	}

	public ParticleSystem GetRoomPfx(string pfxName)
	{
		return roomPfx[pfxName];
	}

	public void StartHartmanPottering(bool randomStart = true)
	{
		randomPotter = randomStart;
		shouldPotter = true;
		if ((bool)hartmanPotteringRoutine.running)
		{
			hartmanPotteringRoutine.host.Pause(hartmanPotteringRoutine);
			hartmanPotteringRoutine.Reset();
		}
		LR.Host.StartTopLevel(hartmanPotteringRoutine);
	}

	public void StopHartmanPottering()
	{
		shouldPotter = false;
	}

	public IEnumerator<HagletYieldTerm> HartmanPotteringRoutine()
	{
		if (potterPoints == null || potterPoints.Length < 2)
		{
			yield break;
		}
		Hartman hartman = Singleton<Hartman>.Inst;
		HartmanPotterPoint currentPoint = null;
		hartman.currentMood = Hartman.Mood.Default;
		if (hartman.currentAnimation != hartman.GetIdleAnimName())
		{
			hartman.PlayAnimation(hartman.GetIdleAnimName(), playIdleOnComplete: true);
		}
		if (randomPotter)
		{
			currentPoint = potterPoints[UnityEngine.Random.Range(0, potterPoints.Length)];
			hartman.TeleportToPointWithLookAt(currentPoint.position, currentPoint.GetLookPoint());
		}
		while (shouldPotter)
		{
			HartmanPotterPoint nextPoint2 = null;
			if (currentPoint == null || currentPoint.reachablePoints.Length == 0)
			{
				nextPoint2 = potterPoints[UnityEngine.Random.Range(0, potterPoints.Length)];
				while (nextPoint2 == currentPoint)
				{
					nextPoint2 = potterPoints[UnityEngine.Random.Range(0, potterPoints.Length)];
				}
			}
			else
			{
				nextPoint2 = currentPoint.reachablePoints[UnityEngine.Random.Range(0, currentPoint.reachablePoints.Length)];
			}
			currentPoint = nextPoint2;
			yield return hartman.MoveToPosition(time: Vector3.Distance(hartman.transform.position, currentPoint.position) / hartmanPotterSpeed, point: currentPoint.position, lookAtPlayerOnComplete: false);
			if (!shouldPotter)
			{
				break;
			}
			yield return null;
			yield return hartman.LookAtPoint(currentPoint.GetLookPoint(), 1f);
			if (!shouldPotter)
			{
				break;
			}
			yield return Wait.ForSeconds(currentPoint.waitTime);
		}
	}
}
public class ScreenshotController : MonoBehaviour
{
	public const float holdTime = 0.5f;

	private Camera screenshotCam;

	private void Start()
	{
		screenshotCam = GetComponent<Camera>();
		screenshotCam.targetTexture = new RenderTexture(Screen.width, Screen.height, 24);
	}

	private void Update()
	{
	}
}
public class SubtitleController : UIContainer
{
	private struct Subtitle
	{
		public int strIndexBegin;

		public int strIndexEnd;

		public string source;

		public float duration;
	}

	private static SubtitleController _instance;

	private Transform containerAll;

	private UITextbox textContent;

	private AnimFloat visibility = new AnimFloat(0f);

	private Vector3 presentPos;

	private const float animDur = 0.3f;

	private const float zCourse = 0.04f;

	private const float textDurationMin = 0.15f;

	private const float textDurationMax = 5.05f;

	private const float textLineMax = 110f;

	private const float animTimeInOut = 0.4f;

	private float advanceCountdown;

	private ConstQueue<Subtitle> subtitleQueue = new ConstQueue<Subtitle>(32);

	public static SubtitleController Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		HideAll();
		containerAll = base.transform.GetChild(0);
		textContent = GetElement<UITextbox>("Content");
		presentPos = base.transform.position;
	}

	public void Show(string text, float timeInSeconds)
	{
		ShowAll();
		GC.Inst.CutsceneBegin();
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < text.Length; i++)
		{
			char c = text[i];
			if (c == '.' || c == '?' || c == '!' || c == ';')
			{
				num2 = num;
				num = i + 1;
				EnqueueSubtitle(text, num2, num, timeInSeconds);
			}
		}
		if (num != text.Length)
		{
			EnqueueSubtitle(text, num, text.Length, timeInSeconds);
		}
		AdvanceQueue(0.3f);
		visibility.AnimateTo(1f, 0.3f);
		Update();
	}

	private void Update()
	{
		if ((bool)visibility.animating)
		{
			float num = visibility.Update();
			base.transform.position = presentPos + Vector3.back * 0.04f * (-1f + num);
			textContent.color = textContent.color.RepA(num);
			if (!visibility.animating && num == 0f)
			{
				HideAll();
			}
		}
		if (!isShown)
		{
			return;
		}
		containerAll.transform.LookAt(base.transform.position + (base.transform.position - Singleton<CC>.Inst.Camera.transform.position), Vector3.up);
		if ((advanceCountdown -= Time.deltaTime) <= 0f)
		{
			if (subtitleQueue.Length > 0)
			{
				AdvanceQueue();
			}
			else if (!visibility.animating)
			{
				visibility.AnimateTo(0f, 0.3f);
			}
		}
	}

	private void EnqueueSubtitle(string source, int indexStart, int indexEnd, float clipLength)
	{
		Subtitle obj = default(Subtitle);
		obj.source = source;
		obj.strIndexBegin = indexStart;
		obj.strIndexEnd = indexEnd;
		float num = indexEnd - indexStart;
		float num2 = num / (float)source.Length;
		obj.duration = clipLength * num2;
		subtitleQueue.Enqueue(obj);
	}

	public void ClearSubtitleQueue()
	{
		if (isShown)
		{
			subtitleQueue.Clear();
			visibility.AnimateTo(0f, visibility.Value / 1f * 0.3f);
		}
	}

	private void AdvanceQueue(float extraCountdown = 0f)
	{
		Subtitle subtitle = subtitleQueue.Dequeue();
		textContent.Clear();
		textContent.Append(subtitle.source, subtitle.strIndexBegin, subtitle.strIndexEnd - subtitle.strIndexBegin);
		textContent.Present();
		advanceCountdown = subtitle.duration + extraCountdown;
	}
}
public class UIStatusBar : UIContainer
{
	private static UIStatusBar _instance;

	private UIButton buttonEndTurn;

	private UITextbox textboxEndTurn;

	private UIContainer combatContainer;

	private Vector3 endTurnOriginRot;

	private string nextTurnText = string.Empty;

	private bool endTurnButtonFlipped;

	private HagletResettable changeTurnText;

	public bool HACK_showEndTurnButton = true;

	private bool HACK_hideEndTurnButtonForAbility;

	private const string turnText = " turn";

	public static UIStatusBar Inst => _instance;

	public void HideEndTurnButtonForAbility(bool hide)
	{
		HACK_hideEndTurnButtonForAbility = hide;
		buttonEndTurn.gameObject.SetActive(!HACK_hideEndTurnButtonForAbility && HACK_showEndTurnButton);
	}

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		HACK_hideEndTurnButtonForAbility = false;
		base.transform.position = Vector3.zero;
		combatContainer = GetContainer("Combat");
		buttonEndTurn = combatContainer.GetElement<UIButton>("ButtonEndTurn");
		textboxEndTurn = combatContainer.GetElement<UITextbox>("ButtonEndTurnText");
		endTurnOriginRot = buttonEndTurn.transform.localRotation.eulerAngles;
		changeTurnText = new HagletResettable(ChangeTurnTextRoutine(), "Change Turn Button Text");
		buttonEndTurn.OnTapUp += delegate
		{
			UnitTeam.Type activeTeamType = GC.Inst.GetActiveTeamType();
			if (activeTeamType != 0 && activeTeamType != UnitTeam.Type.Opponent)
			{
				return true;
			}
			GC.Inst.ForceSubmitTurn();
			if (GC.Inst.GetActiveTeam() != null)
			{
				UnitTeam nextActiveTeam = GC.Inst.GetNextActiveTeam(GC.Inst.GetActiveTeam());
				if (nextActiveTeam != null)
				{
					Refresh(nextActiveTeam.type);
				}
			}
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		ResetTurnButton();
		Refresh();
	}

	public override bool HideAll()
	{
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	public void Refresh(UnitTeam.Type? forceTeamType = null)
	{
		GC inst = GC.Inst;
		RC inst2 = RC.Inst;
		if (!inst)
		{
			return;
		}
		GC.State state = inst.GetState();
		if (state == GC.State.Combat)
		{
			if (!combatContainer.IsShown)
			{
				combatContainer.ShowAll();
			}
			if (inst.GetActiveTeam() != null)
			{
				UnitTeam.Type type = inst.GetActiveTeamType();
				if (forceTeamType.HasValue)
				{
					type = forceTeamType.Value;
				}
				buttonEndTurn.gameObject.SetActive(HACK_showEndTurnButton && !HACK_hideEndTurnButtonForAbility);
				if (type == UnitTeam.Type.Player || type == UnitTeam.Type.Opponent)
				{
					ChangeTurnText("UISTATUSBAR_ENDTURN");
				}
				else
				{
					ChangeTurnText("UISTATUSBAR_ENEMYTURN");
				}
			}
		}
		else if (combatContainer.IsShown)
		{
			combatContainer.HideAll();
		}
	}

	public override bool OnBackButtonPressed()
	{
		return false;
	}

	private void ChangeTurnText(string localisationKey)
	{
		if (!(nextTurnText == localisationKey))
		{
			nextTurnText = localisationKey;
			if ((bool)changeTurnText.running)
			{
				changeTurnText.Reset();
			}
			else
			{
				Routine.Start(changeTurnText, MR.Inst.Host);
			}
		}
	}

	private IEnumerator<HagletYieldTerm> ChangeTurnTextRoutine()
	{
		float t = 0f;
		float animTime = 0.25f;
		bool setTurnText = false;
		bool startFlipped = endTurnButtonFlipped;
		while (t < animTime)
		{
			t += Time.deltaTime;
			float progress = t / animTime;
			float alphaProgress = progress;
			if (progress < 0.25f)
			{
				alphaProgress *= 4f;
				alphaProgress = 1f - alphaProgress;
			}
			else if (progress > 0.75f)
			{
				alphaProgress = 1f - alphaProgress;
				alphaProgress *= 4f;
				alphaProgress = 1f - alphaProgress;
			}
			else
			{
				alphaProgress = 0f;
			}
			textboxEndTurn.alpha = alphaProgress;
			progress = MathfX.EaseOutCurve(progress);
			float currAngle2 = 180f * progress;
			currAngle2 += endTurnOriginRot.x + ((!startFlipped) ? 0f : 180f);
			buttonEndTurn.transform.localRotation = Quaternion.Euler(endTurnOriginRot.RepX(currAngle2));
			if (!setTurnText && progress > 0.5f)
			{
				endTurnButtonFlipped = !endTurnButtonFlipped;
				textboxEndTurn.SetKey(nextTurnText);
				textboxEndTurn.transform.localRotation = Quaternion.Euler(endTurnButtonFlipped ? 180 : 0, 0f, 0f);
				setTurnText = true;
			}
			yield return null;
		}
		textboxEndTurn.alpha = 1f;
		float finalAngle = endTurnOriginRot.x + (float)(endTurnButtonFlipped ? 180 : 0);
		buttonEndTurn.transform.localRotation = Quaternion.Euler(finalAngle, 0f, 0f);
	}

	private void ResetTurnButton()
	{
		UnitTeam.Type activeTeamType = GC.Inst.GetActiveTeamType();
		if (activeTeamType == UnitTeam.Type.Player || activeTeamType == UnitTeam.Type.Opponent)
		{
			textboxEndTurn.SetKey("UISTATUSBAR_ENDTURN");
			nextTurnText = "UISTATUSBAR_ENDTURN";
		}
		else
		{
			textboxEndTurn.SetKey("UISTATUSBAR_ENEMYTURN");
			nextTurnText = "UISTATUSBAR_ENEMYTURN";
		}
	}

	public void OnMissionUnloaded()
	{
		HACK_hideEndTurnButtonForAbility = false;
		HACK_showEndTurnButton = true;
	}
}
public interface VFXTileEvents
{
	void OnAwakeLR();
}
public class VFXTileController : MonoBehaviour
{
	public delegate TileType TileAreaVFXDel(v2i centerCoord, v2i coord);

	public class TilePool
	{
		public GameObject[] tiles;

		public UIImage[] uiImages;

		public uint tilesNum;
	}

	public enum TileType
	{
		PathStraight = 0,
		PathCorner = 1,
		PathEnd = 2,
		PathEnd45 = 3,
		Path45Straight = 4,
		Path45Corner = 5,
		Path45CornerR = 6,
		PathStraight_Danger = 7,
		PathCorner_Danger = 8,
		PathEnd_Danger = 9,
		PathEnd45_Danger = 10,
		Path45Straight_Danger = 11,
		Path45Corner_Danger = 12,
		Path45CornerR_Danger = 13,
		PathVault = 14,
		PathVault_Danger = 15,
		Area0001 = 16,
		Area0011 = 17,
		Area0101 = 18,
		Area0111 = 19,
		HighlightUnit = 20,
		HighlightSelectedUnit = 21,
		HighlightPing = 22,
		HighlightAttackUnit = 23,
		HighlightSelectUnit = 24,
		HighlightTileAction = 25,
		CoverFull = 26,
		CoverHalf = 27,
		FullCoverPredictor = 28,
		HalfCoverPredictor = 29,
		NoneCoverPredictor = 30,
		PathEndSingle = 31,
		PathEndCombat = 32,
		TriggerDefault = 33,
		TriggerYellow = 34,
		NoticeStealth = 35,
		DistractionStealth = 36,
		DistractionUnitNotFound = 37,
		AreaSelection = 38,
		AreaSelectionOffensive = 39,
		AreaSelectionInvalid = 40,
		AreaSelectionUnit = 41,
		AreaSelectionUnitAttack = 42,
		TacticalCoverIndicator = 43,
		UnitTarget = 44,
		Arrow = 45,
		DangerZone3 = 46,
		DangerZone5 = 47,
		DangerZone7 = 48,
		MAX = 49,
		MIN = 0
	}

	public enum TileGroup
	{
		Path,
		Area,
		HighlightUnit,
		HighlightSelectedUnit,
		HighlightPing,
		HighlightAttackUnit,
		HighlightSelectUnit,
		HighlightTileAction,
		Cover,
		CoverPrediction,
		Trigger,
		Stealth,
		AreaSelection,
		UnitTargets,
		TacticalCoverIndicator,
		DangerZone,
		MAX
	}

	private static int particleSortingOrderOffset = 50;

	private static int spriteSortingOrderOffset = 100;

	private static int meshSortingOrderOffset = 150;

	private static readonly Quaternion kSpriteRotation = Quaternion.Euler(90f, 0f, 0f);

	public GameObject[] vfxTilePrefabs = new GameObject[49];

	private TilePool[] vfxPools = new TilePool[49];

	private int[] vfxPoolSizes = new int[49];

	private const float kTileFloorOffset = 0.0065f;

	private const float kTileSpriteOffset = 0.001f;

	private const float kTileFloorOffsetTriggerTileType = 0.006f;

	private ConstArray<Material> materials = new ConstArray<Material>(8u);

	private Unit unitSelected;

	private Unit unitHighlighted;

	private UIImage activeUnitHighlight;

	private static byte[] LUT_PathDirectionFieldToVFXTileIndex;

	private static Quaternion[] LUT_PathDirectionFieldToRotation;

	private Quaternion[] LUT_PathIndexToRotation;

	public static byte[] LUT_AreaTileIndexToVFXTileIndex = new byte[16]
	{
		49, 16, 16, 17, 16, 18, 17, 19, 16, 17,
		18, 19, 17, 19, 19, 49
	};

	public static Quaternion[] LUT_AreaTileIndexToRotation = new Quaternion[16]
	{
		Quaternion.identity,
		Quaternion.identity,
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.identity,
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.identity,
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.identity,
		Quaternion.Euler(0f, -90f, 0f),
		Quaternion.Euler(0f, -90f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, -90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.identity
	};

	private Quaternion[] LUT_CoverTileRotation = new Quaternion[4]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 270f, 0f)
	};

	private Quaternion spriteUpRotation = Quaternion.Euler(-90f, 0f, 0f);

	private Color unitNotFoundColour;

	private ConstArray<VFXTilesContainer> tileArrayContainers = new ConstArray<VFXTilesContainer>(32u);

	private ConstArray<VFXTileContainer> tileContainers = new ConstArray<VFXTileContainer>(32u);

	private NC.Path currentPath;

	private HagletResettable trickleInPathVFX;

	private bool currentPathIsRed;

	public v2i pathVFXDrawBounds = new v2i(0, int.MaxValue);

	[Serializer.Exclude]
	private Map map => Singleton<MC>.Inst.GetActiveMap();

	public static void SetSortingOrder(Renderer render, int offset = 0)
	{
		if (render.GetType() == typeof(SpriteRenderer))
		{
			render.sortingOrder = spriteSortingOrderOffset + offset;
		}
		else if (render.GetType() == typeof(ParticleSystemRenderer))
		{
			render.sortingOrder = particleSortingOrderOffset + offset;
		}
		else if (render.GetType() == typeof(MeshRenderer))
		{
			render.sortingOrder = meshSortingOrderOffset + offset;
		}
	}

	public void AwakeOnLR()
	{
		trickleInPathVFX = new HagletResettable(TrickleInPathVFXRoutine(), "Trickle Path VFX in");
		for (int i = 0; i < tileContainers.MaxSize; i++)
		{
			tileContainers.Add(new VFXTileContainer());
		}
		for (uint num = 0u; num < vfxPoolSizes.Length; num++)
		{
			vfxPoolSizes[num] = 4;
		}
		vfxPoolSizes[20] = 1;
		vfxPoolSizes[21] = 1;
		vfxPoolSizes[22] = 1;
		vfxPoolSizes[23] = 1;
		vfxPoolSizes[24] = 1;
		vfxPoolSizes[25] = 1;
		vfxPoolSizes[26] = 0;
		vfxPoolSizes[27] = 0;
		vfxPoolSizes[31] = 1;
		vfxPoolSizes[32] = 4;
		vfxPoolSizes[2] = 16;
		vfxPoolSizes[3] = 16;
		vfxPoolSizes[4] = 64;
		vfxPoolSizes[1] = 64;
		vfxPoolSizes[5] = 64;
		vfxPoolSizes[6] = 64;
		vfxPoolSizes[0] = 64;
		vfxPoolSizes[9] = 16;
		vfxPoolSizes[10] = 16;
		vfxPoolSizes[11] = 64;
		vfxPoolSizes[7] = 64;
		vfxPoolSizes[8] = 64;
		vfxPoolSizes[12] = 64;
		vfxPoolSizes[13] = 64;
		vfxPoolSizes[14] = 6;
		vfxPoolSizes[15] = 6;
		vfxPoolSizes[16] = 128;
		vfxPoolSizes[17] = 128;
		vfxPoolSizes[18] = 64;
		vfxPoolSizes[19] = 64;
		vfxPoolSizes[35] = 4;
		vfxPoolSizes[36] = 4;
		vfxPoolSizes[37] = 1;
		vfxPoolSizes[28] = 1;
		vfxPoolSizes[29] = 1;
		vfxPoolSizes[30] = 1;
		vfxPoolSizes[38] = 32;
		vfxPoolSizes[39] = 32;
		vfxPoolSizes[40] = 32;
		vfxPoolSizes[41] = 32;
		vfxPoolSizes[42] = 8;
		vfxPoolSizes[33] = 16;
		vfxPoolSizes[34] = 1;
		vfxPoolSizes[43] = 4;
		vfxPoolSizes[44] = 6;
		vfxPoolSizes[45] = 8;
		vfxPoolSizes[46] = 8;
		vfxPoolSizes[47] = 8;
		vfxPoolSizes[48] = 8;
		for (uint num2 = 0u; num2 < vfxPools.Length; num2++)
		{
			TilePool tilePool = (vfxPools[num2] = new TilePool());
			tilePool.tiles = new GameObject[vfxPoolSizes[num2]];
			tilePool.uiImages = new UIImage[vfxPoolSizes[num2]];
			tilePool.tilesNum = 0u;
			for (uint num3 = 0u; num3 < tilePool.tiles.Length; num3++)
			{
				GameObject gameObject = (tilePool.tiles[num3] = UnityEngine.Object.Instantiate(vfxTilePrefabs[num2], Vector3.zero, Quaternion.identity, base.transform));
				UIImage uIImage = (tilePool.uiImages[num3] = gameObject.GetComponentInChildren<UIImage>());
				if ((bool)uIImage)
				{
					uIImage.OnAwakeLR();
				}
				VFXTileEvents[] componentsInChildren = gameObject.GetComponentsInChildren<VFXTileEvents>();
				int j = 0;
				for (int num4 = componentsInChildren.Length; j < num4; j++)
				{
					componentsInChildren[j].OnAwakeLR();
				}
				Renderer[] componentsInChildren2 = gameObject.GetComponentsInChildren<Renderer>(includeInactive: true);
				for (int k = 0; k < componentsInChildren2.Length; k++)
				{
					SetSortingOrder(componentsInChildren2[k], (int)num2);
					Material sharedMaterial = componentsInChildren2[k].sharedMaterial;
					if (!materials.Contains(sharedMaterial))
					{
						materials.Add(sharedMaterial);
					}
				}
				gameObject.SetActive(value: false);
			}
		}
		unitNotFoundColour = new Color(20f / 51f, 40f / 51f, 40f / 51f, 1f);
		LUT_PathIndexToRotation = new Quaternion[8];
		for (int l = 0; l < 8; l++)
		{
			ref Quaternion reference = ref LUT_PathIndexToRotation[l];
			reference = Quaternion.Euler(0f, l * 45, 0f);
		}
		if (LUT_PathDirectionFieldToVFXTileIndex != null)
		{
			return;
		}
		LUT_PathDirectionFieldToVFXTileIndex = new byte[256];
		LUT_PathDirectionFieldToRotation = new Quaternion[256];
		for (uint num5 = 0u; num5 < 256; num5++)
		{
			byte b = 0;
			Quaternion quaternion = Quaternion.identity;
			for (int m = 0; m < 8; m++)
			{
				if (num5 == 1 << m)
				{
					b = (byte)((m % 2 != 0) ? 3 : 2);
					quaternion = LUT_PathIndexToRotation[m];
				}
				else if (num5 == Bitwise.BitRotate_u8(5, m))
				{
					b = 1;
					quaternion = LUT_PathIndexToRotation[m];
				}
				else if (num5 == Bitwise.BitRotate_u8(17, m))
				{
					b = (byte)((m % 2 != 0) ? 4 : 0);
					quaternion = LUT_PathIndexToRotation[m];
				}
				else if (num5 == Bitwise.BitRotate_u8(9, m))
				{
					if (m % 2 == 1)
					{
						b = 6;
						quaternion = LUT_PathIndexToRotation[m] * Quaternion.Euler(0f, -45f, 0f);
					}
					else
					{
						b = 5;
						quaternion = LUT_PathIndexToRotation[m] * Quaternion.Euler(0f, 180f, 0f);
					}
				}
			}
			LUT_PathDirectionFieldToVFXTileIndex[num5] = b;
			LUT_PathDirectionFieldToRotation[num5] = quaternion;
		}
	}

	private Vector3 GetFloorOffset(TileType tileType)
	{
		switch (tileType)
		{
		case TileType.TriggerDefault:
		case TileType.TriggerYellow:
		case TileType.AreaSelection:
		case TileType.AreaSelectionInvalid:
			return Vector3.up * 0.006f;
		default:
			return Vector3.up * 0.0065f;
		}
	}

	public Material[] GetMaterials()
	{
		return materials.ToArray();
	}

	public bool CreateTile(TileType vfxTile, Vector3 worldPosition, Quaternion localRotation)
	{
		TilePool tilePool = vfxPools[(int)vfxTile];
		uint num = tilePool.tilesNum++;
		GameObject gameObject = tilePool.tiles[num];
		Transform transform = gameObject.transform;
		transform.position = worldPosition;
		transform.localRotation = localRotation;
		transform.localPosition += GetFloorOffset(vfxTile);
		gameObject.SetActive(value: true);
		return true;
	}

	private UIImage CreateSprite(TileType vfxTile, Vector3 worldPosition, Quaternion localRotation, Color? color = null)
	{
		if (CreateTile(vfxTile, worldPosition, localRotation))
		{
			TilePool tilePool = vfxPools[(int)vfxTile];
			uint num = tilePool.tilesNum - 1;
			UIImage uIImage = tilePool.uiImages[num];
			if ((bool)uIImage)
			{
				if (color.HasValue)
				{
					uIImage.color = color.Value;
				}
				uIImage.Show();
				uIImage.transform.localPosition += Vector3.up * 0.001f;
				return uIImage;
			}
		}
		return null;
	}

	public void ClearAllGroups()
	{
		for (TileType tileType = TileType.PathStraight; tileType < TileType.MAX; tileType++)
		{
			ClearPool(tileType);
		}
	}

	public void ClearGroup(TileGroup vfxGroup)
	{
		switch (vfxGroup)
		{
		case TileGroup.Path:
			ClearPool(TileType.PathCorner);
			ClearPool(TileType.PathEnd);
			ClearPool(TileType.PathEnd45);
			ClearPool(TileType.PathStraight);
			ClearPool(TileType.Path45Straight);
			ClearPool(TileType.Path45Corner);
			ClearPool(TileType.Path45CornerR);
			ClearPool(TileType.PathEndSingle);
			ClearPool(TileType.PathEndCombat);
			ClearPool(TileType.PathStraight_Danger);
			ClearPool(TileType.PathCorner_Danger);
			ClearPool(TileType.PathEnd_Danger);
			ClearPool(TileType.PathEnd45_Danger);
			ClearPool(TileType.Path45Straight_Danger);
			ClearPool(TileType.Path45Corner_Danger);
			ClearPool(TileType.Path45CornerR_Danger);
			ClearPool(TileType.PathVault);
			ClearPool(TileType.PathVault_Danger);
			break;
		case TileGroup.Area:
			ClearPool(TileType.Area0001);
			ClearPool(TileType.Area0011);
			ClearPool(TileType.Area0101);
			ClearPool(TileType.Area0111);
			break;
		case TileGroup.HighlightUnit:
			ClearPool(TileType.HighlightUnit);
			break;
		case TileGroup.HighlightSelectedUnit:
			ClearPool(TileType.HighlightSelectedUnit);
			break;
		case TileGroup.Cover:
			ClearPool(TileType.CoverFull);
			ClearPool(TileType.CoverHalf);
			break;
		case TileGroup.HighlightPing:
			ClearPool(TileType.HighlightPing);
			break;
		case TileGroup.HighlightAttackUnit:
			ClearPool(TileType.HighlightAttackUnit);
			break;
		case TileGroup.HighlightSelectUnit:
			ClearPool(TileType.HighlightSelectUnit);
			break;
		case TileGroup.HighlightTileAction:
			ClearPool(TileType.HighlightTileAction);
			break;
		case TileGroup.CoverPrediction:
			ClearPool(TileType.FullCoverPredictor);
			ClearPool(TileType.HalfCoverPredictor);
			ClearPool(TileType.NoneCoverPredictor);
			break;
		case TileGroup.Trigger:
			ClearPool(TileType.TriggerDefault);
			ClearPool(TileType.TriggerYellow);
			break;
		case TileGroup.Stealth:
			ClearPool(TileType.NoticeStealth);
			ClearPool(TileType.DistractionStealth);
			ClearPool(TileType.DistractionUnitNotFound);
			break;
		case TileGroup.AreaSelection:
			ClearPool(TileType.AreaSelection);
			ClearPool(TileType.AreaSelectionOffensive);
			ClearPool(TileType.AreaSelectionInvalid);
			ClearPool(TileType.AreaSelectionUnit);
			ClearPool(TileType.AreaSelectionUnitAttack);
			break;
		case TileGroup.UnitTargets:
			ClearPool(TileType.UnitTarget);
			break;
		case TileGroup.TacticalCoverIndicator:
			ClearPool(TileType.TacticalCoverIndicator);
			break;
		case TileGroup.DangerZone:
			ClearPool(TileType.DangerZone3);
			ClearPool(TileType.DangerZone5);
			ClearPool(TileType.DangerZone7);
			break;
		}
	}

	private void ClearPool(TileType tileType)
	{
		VFXTilesContainer[] data = tileArrayContainers._data;
		for (int num = (int)(tileArrayContainers.Length - 1); num >= 0; num--)
		{
			if (data[num].tileType == tileType)
			{
				TilesHide(data[num]);
			}
		}
		VFXTileContainer[] data2 = tileContainers._data;
		for (int num2 = data2.Length - 1; num2 >= 0; num2--)
		{
			if (data2[num2].tileType == tileType)
			{
				TileHide(data2[num2]);
			}
		}
		TilePool tilePool = vfxPools[(int)tileType];
		for (uint num3 = 0u; num3 < tilePool.tilesNum; num3++)
		{
			tilePool.tiles[num3].SetActive(value: false);
		}
		tilePool.tilesNum = 0u;
	}

	private IEnumerator<HagletYieldTerm> TrickleInPathVFXRoutine()
	{
		if (currentPath == null)
		{
			yield break;
		}
		pathVFXDrawBounds.y = 1;
		for (int i = 0; i < currentPath.positions.Count; i++)
		{
			yield return Wait.ForSeconds(0.035f);
			if (currentPath == null || i >= currentPath.positions.Count)
			{
				break;
			}
			pathVFXDrawBounds.y++;
			VFXTileController vFXTileController = this;
			NC.Path path = currentPath;
			bool complete = true;
			bool showSelectionBox = false;
			bool usePathDrawBounds = true;
			bool makePathRed = currentPathIsRed;
			vFXTileController.PathShow(path, complete, showSelectionBox, usePathDrawBounds, startTrickleEffect: false, makePathRed);
		}
		pathVFXDrawBounds.y = int.MaxValue;
	}

	public void PathShow(NC.Path path, bool complete, bool showSelectionBox = true, bool usePathDrawBounds = false, bool startTrickleEffect = false, bool makePathRed = false, CoverType? coverType = null)
	{
		currentPathIsRed = makePathRed;
		ClearGroup(TileGroup.Path);
		currentPath = path;
		if (startTrickleEffect)
		{
			if ((bool)trickleInPathVFX.running)
			{
				MR.Inst.Host.Pause(trickleInPathVFX);
			}
			Routine.Start(trickleInPathVFX, MR.Inst.Host);
		}
		bool flag = false;
		int num = (usePathDrawBounds ? pathVFXDrawBounds.x : 0);
		int num2 = ((!usePathDrawBounds) ? int.MaxValue : pathVFXDrawBounds.y);
		if (complete)
		{
			if (num2 > path.pathInfo.Count)
			{
				num2 = path.pathInfo.Count;
			}
			if (showSelectionBox && num2 == path.pathInfo.Count)
			{
				num2--;
			}
			for (int i = num; i < num2; i++)
			{
				uint num3 = path.pathInfo[i];
				bool flag2 = (num3 & 0x10000) != 0;
				bool flag3 = (num3 & 0x20000) != 0;
				Vector3 worldPosition = map.LocalPosToWorldPos(path.positions[i]);
				uint num4 = 0u;
				if (!flag2)
				{
					num4 |= (num3 & 0xFF) >> 0;
				}
				if (!flag3)
				{
					num4 |= (num3 & 0xFF00) >> 8;
				}
				else
				{
					uint num5 = (num3 & 0xFF00) >> 8;
					Quaternion localRotation = LUT_PathDirectionFieldToRotation[num5];
					if (makePathRed)
					{
						CreateTile(TileType.PathVault_Danger, worldPosition, localRotation);
					}
					else
					{
						CreateTile(TileType.PathVault, worldPosition, localRotation);
					}
				}
				if (num4 != 0)
				{
					TileType tileType = (TileType)LUT_PathDirectionFieldToVFXTileIndex[num4];
					Quaternion localRotation2 = LUT_PathDirectionFieldToRotation[num4];
					flag = flag || (num3 & 0x40000) != 0;
					if (flag || makePathRed)
					{
						tileType += 7;
					}
					CreateTile(tileType, worldPosition, localRotation2);
				}
			}
			if (showSelectionBox && coverType.HasValue)
			{
				CoverPredictorShow(path.coordEnd, coverType.Value);
				CreateTile(TileType.PathEndCombat, map.CoordToWorldPos(path.coordEnd), Quaternion.identity);
			}
		}
		else
		{
			Vector3 worldPosition2 = map.CoordToWorldPos(path.coordEnd);
			CreateSprite(TileType.PathEndSingle, worldPosition2, kSpriteRotation, new Color(0.5f, 1f, 1f, 0f));
		}
	}

	public void PathHide()
	{
		ClearGroup(TileGroup.Path);
		CoverPredictorHide();
	}

	public void UnitTargetShow(v2i coord)
	{
		CreateSprite(TileType.UnitTarget, map.CoordToWorldPos(coord), kSpriteRotation, new Color(0.5f, 1f, 1f, 0f));
	}

	public void UnitTargetHideAll()
	{
		ClearGroup(TileGroup.UnitTargets);
	}

	public void AreaHide()
	{
		ClearGroup(TileGroup.Area);
	}

	public void TilesInRadiusShow(v2i coord, float radius, VFXTilesContainer tilesCache)
	{
		if (tileArrayContainers.Contains(tilesCache))
		{
			TilesHide(tilesCache);
		}
		if (tilesCache.tiles.Length != 0)
		{
			TilesHide(tilesCache);
		}
		v2i v2i2 = default(v2i);
		int num = Mathf.CeilToInt(radius);
		TilePool tilePool = vfxPools[(int)tilesCache.tileType];
		for (int i = coord.x - num; i <= coord.x + num; i++)
		{
			for (int j = coord.y - num; j <= coord.y + num; j++)
			{
				v2i2.x = i;
				v2i2.y = j;
				if (map.CoordExists(v2i2) && !map.GetCoordBlocked(v2i2) && v2i.Distance(v2i2, coord) <= radius)
				{
					CreateTile(tilesCache.tileType, map.CoordToWorldPos(v2i2), Quaternion.identity);
					tilesCache.tiles.Add(tilePool.tiles[tilePool.tilesNum - 1]);
				}
			}
		}
		if (tilesCache.tiles.Length != 0)
		{
			tileArrayContainers.Add(tilesCache);
		}
	}

	public void TilesInSquareShow(v2i coord, v2i size, VFXTilesContainer tilesCache, Quaternion rot)
	{
		if (tileArrayContainers.Contains(tilesCache))
		{
			TilesHide(tilesCache);
		}
		int num = coord.x - size.x;
		int num2 = coord.x + size.x;
		int num3 = coord.y - size.y;
		int num4 = coord.y + size.y;
		if (tilesCache.tiles.Length != 0)
		{
			TilesHide(tilesCache);
		}
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				v2i coord2 = new v2i(i, j);
				if (map.CoordExists(coord2))
				{
					CreateTile(tilesCache.tileType, map.CoordToWorldPos(coord2), rot);
					TilePool tilePool = vfxPools[(int)tilesCache.tileType];
					uint num5 = tilePool.tilesNum - 1;
					tilesCache.tiles.Add(tilePool.tiles[num5]);
				}
			}
		}
		if (tilesCache.tiles.Length != 0)
		{
			tileArrayContainers.Add(tilesCache);
		}
	}

	public VFXTileContainer TileShow(v2i coord, TileType type)
	{
		VFXTileContainer vFXTileContainer = null;
		for (int i = 0; i < tileContainers.Length; i++)
		{
			if (tileContainers[i].tile == null)
			{
				vFXTileContainer = tileContainers[i];
				break;
			}
		}
		vFXTileContainer.tileType = type;
		if (map.CoordExists(coord) && !map.GetCoordBlocked(coord))
		{
			TilePool tilePool = vfxPools[(int)vFXTileContainer.tileType];
			CreateTile(vFXTileContainer.tileType, map.CoordToWorldPos(coord), Quaternion.identity);
			vFXTileContainer.tile = tilePool.tiles[tilePool.tilesNum - 1];
		}
		return vFXTileContainer;
	}

	private void PatchPoolHole(TilePool pool, int holeSize)
	{
		int num = -1;
		for (int i = 0; i < pool.tilesNum; i++)
		{
			if (!pool.tiles[i].activeSelf && i < pool.tilesNum)
			{
				num = i;
				break;
			}
		}
		if (num < 0 || num == pool.tilesNum - holeSize)
		{
			pool.tilesNum -= (uint)holeSize;
			return;
		}
		int num2 = 0;
		for (int j = num + holeSize; j < pool.tilesNum; j++)
		{
			SwapPoolElements(pool, j, num + num2);
			num2++;
		}
		pool.tilesNum -= (uint)holeSize;
	}

	private void SwapPoolElements(TilePool pool, int a, int b)
	{
		GameObject gameObject = pool.tiles[a];
		UIImage uIImage = pool.uiImages[a];
		pool.tiles[a] = pool.tiles[b];
		pool.uiImages[a] = pool.uiImages[b];
		pool.tiles[b] = gameObject;
		pool.uiImages[a] = uIImage;
	}

	public void TileHide(VFXTileContainer tileCache)
	{
		if (!(tileCache.tile == null))
		{
			TilePool pool = vfxPools[(int)tileCache.tileType];
			tileCache.tile.SetActive(value: false);
			PatchPoolHole(pool, 1);
			tileCache.tile = null;
		}
	}

	public void TilesHide(VFXTilesContainer tilesCache)
	{
		if (tilesCache.tiles.Length != 0)
		{
			TilePool pool = vfxPools[(int)tilesCache.tileType];
			for (uint num = 0u; num < tilesCache.tiles.Length; num++)
			{
				tilesCache.tiles[num].SetActive(value: false);
			}
			PatchPoolHole(pool, (int)tilesCache.tiles.Length);
			tilesCache.tiles.Clear();
			tileArrayContainers.Remove(tilesCache);
		}
	}

	public void TriggerHideAll()
	{
		ClearGroup(TileGroup.Trigger);
	}

	public void TacticalCoverIndicatorShow(v2i coord, OctDir dir)
	{
		CreateTile(TileType.TacticalCoverIndicator, map.CoordToWorldPos(coord), Quaternion.Euler(0f, 45 * (int)dir, 0f));
	}

	public void TacticalCoverIndicatorHide()
	{
		ClearGroup(TileGroup.TacticalCoverIndicator);
	}

	public void AreaSelectionShow(v2i coord, float range, TileAreaVFXDel typeOverride = null)
	{
		v2i v2i2 = default(v2i);
		int num = Mathf.CeilToInt(range);
		for (int i = coord.x - num; i <= coord.x + num; i++)
		{
			for (int j = coord.y - num; j <= coord.y + num; j++)
			{
				v2i2.x = i;
				v2i2.y = j;
				if (map.GetCoordBlocked(v2i2))
				{
					continue;
				}
				float num2 = v2i.Distance(v2i2, coord);
				if (num2 <= range)
				{
					TileType tileType = typeOverride?.Invoke(coord, v2i2) ?? TileType.AreaSelection;
					switch (tileType)
					{
					case TileType.AreaSelection:
					case TileType.AreaSelectionOffensive:
					case TileType.AreaSelectionInvalid:
					{
						UIImage uIImage = CreateSprite(tileType, map.CoordToWorldPos(v2i2), spriteUpRotation);
						uIImage.color = uIImage.color.RepA(Mathf.Lerp(1f, 0.333f, num2 / range));
						break;
					}
					case TileType.AreaSelectionUnit:
					case TileType.AreaSelectionUnitAttack:
						CreateTile(tileType, map.CoordToWorldPos(v2i2), Quaternion.identity);
						break;
					}
				}
			}
		}
	}

	public void AreaSelectionHide()
	{
		ClearGroup(TileGroup.AreaSelection);
	}

	public void UnitNoticedStealthShow(Unit unit)
	{
		CreateSprite(TileType.NoticeStealth, unit.GetPositionWS(), Quaternion.identity, Color.white);
	}

	public void UnitNoticedStealthHide()
	{
		ClearGroup(TileGroup.Stealth);
	}

	public void UnitDistractedStealthShow(Unit unit)
	{
		CreateSprite(TileType.DistractionStealth, unit.GetPositionWS(), Quaternion.identity, Color.yellow);
	}

	public void UnitDistractedStealthHide()
	{
		ClearGroup(TileGroup.Stealth);
	}

	public void UnitDistractionUnitNotFoundShow(Unit unit)
	{
		CreateSprite(TileType.DistractionStealth, unit.GetPositionWS(), Quaternion.identity, unitNotFoundColour);
	}

	public void UnitDistractionUnitNotFoundHide()
	{
		ClearGroup(TileGroup.Stealth);
	}

	public void UnitAttackHighlightShow(Unit unit)
	{
		ClearGroup(TileGroup.HighlightAttackUnit);
		CreateTile(TileType.HighlightAttackUnit, unit.GetPositionWS(), Quaternion.identity);
	}

	public void UnitAttackHighlightHide()
	{
		ClearGroup(TileGroup.HighlightAttackUnit);
	}

	public void UnitSelectHighlightShow(Unit unit)
	{
		ClearGroup(TileGroup.HighlightSelectUnit);
		CreateTile(TileType.HighlightSelectUnit, unit.GetPositionWS(), Quaternion.identity);
	}

	public void UnitSelectHighlightHide()
	{
		ClearGroup(TileGroup.HighlightSelectUnit);
	}

	public void UnitHighlightShow(Unit unit)
	{
	}

	public void UnitHighlightHide()
	{
	}

	public void TileActionHighlightShow(TileActionBase tile)
	{
		ClearGroup(TileGroup.HighlightTileAction);
		CreateSprite(TileType.HighlightTileAction, tile.transform.position, kSpriteRotation, UnitTeam.GetTeamColor(UnitTeam.Type.NPC));
	}

	public void TileActionHighlightHide()
	{
		ClearGroup(TileGroup.HighlightTileAction);
	}

	public void UnitSelectedShow(Unit unit, bool forcePing = false)
	{
		bool flag = forcePing;
		if ((unit.teamType == UnitTeam.Type.Enemy && unit.IsCloaked) || unit.unitModel.HACK_BirdMode)
		{
			return;
		}
		Color teamColor = UnitTeam.GetTeamColor(unit);
		unitSelected = unit;
		ClearGroup(TileGroup.HighlightSelectedUnit);
		if (!GC.Inst.InCutsceneMode())
		{
			activeUnitHighlight = CreateSprite(TileType.HighlightSelectedUnit, unit.GetPositionWS(), kSpriteRotation, teamColor);
			if (activeUnitHighlight != null)
			{
				activeUnitHighlight.transform.SetParent(unit.unitModel.BlobShadow.transform);
				activeUnitHighlight.transform.localPosition = new Vector3(0f, 0f, 0f);
				activeUnitHighlight.transform.localRotation = Quaternion.identity;
			}
			if (flag)
			{
				ClearGroup(TileGroup.HighlightPing);
				CreateSprite(TileType.HighlightPing, unit.GetPositionWS(), kSpriteRotation, teamColor);
			}
		}
	}

	public void UnitSelectedHide()
	{
		unitSelected = null;
		ClearGroup(TileGroup.HighlightSelectedUnit);
		if (activeUnitHighlight != null)
		{
			activeUnitHighlight.transform.SetParent(base.transform);
		}
	}

	public Unit GetUnitSelected()
	{
		return unitSelected;
	}

	public Unit GetUnitHighlighted()
	{
		return unitHighlighted;
	}

	public void CoverPredictorShow(v2i coords, CoverType coverType)
	{
		CoverPredictorHide();
		TileType vfxTile;
		if (coverType.Is(CoverType.Full))
		{
			vfxTile = TileType.FullCoverPredictor;
		}
		else if (coverType.Is(CoverType.Half))
		{
			vfxTile = TileType.HalfCoverPredictor;
		}
		else
		{
			if (!coverType.Is(CoverType.None))
			{
				return;
			}
			vfxTile = TileType.NoneCoverPredictor;
		}
		Color value = UnitTeam.ColorCoverTypes[0, (int)coverType.GetCoverUIType()];
		CreateSprite(vfxTile, Singleton<MC>.Inst.GetActiveMap().CoordToWorldPos(coords), kSpriteRotation, value);
	}

	public void CoverPredictorHide()
	{
		ClearGroup(TileGroup.CoverPrediction);
	}
}
[Serializable]
public class Area
{
	public v2i startCoord;

	public Map map;

	public int range;

	public byte[] borderData;

	public int[] costs;

	public NC.PathStatus status;

	public bool showArea;

	public bool includePathing;

	public bool costDirty;

	public bool borderDirty;

	public bool allowVaults;

	private HagletResettable routine;

	public Area()
	{
		v2i maxMapSize = Map.maxMapSize;
		int num = maxMapSize.x + 1;
		v2i maxMapSize2 = Map.maxMapSize;
		borderData = new byte[num * (maxMapSize2.y + 1)];
		v2i maxMapSize3 = Map.maxMapSize;
		int x = maxMapSize3.x;
		v2i maxMapSize4 = Map.maxMapSize;
		costs = new int[x * maxMapSize4.y];
		base..ctor();
		routine = new HagletResettable(DrawBorder());
	}

	public void Clear()
	{
		startCoord = default(v2i);
		map = null;
		range = 0;
		Array.Clear(borderData, 0, borderData.Length);
		Array.Clear(costs, 0, costs.Length);
		status = NC.PathStatus.Complete;
		showArea = (includePathing = (costDirty = (borderDirty = (allowVaults = false))));
	}

	public int GetCost(v2i coord)
	{
		int[] array = costs;
		int y = coord.y;
		v2i maxMapSize = Map.maxMapSize;
		return array[y * maxMapSize.x + coord.x];
	}

	public void Hide()
	{
		if (map != null)
		{
			map.VFXTiles.AreaHide();
		}
		if ((bool)routine.running)
		{
			routine.host.Pause(routine);
			routine.Reset();
		}
	}

	public HagletEvent Update(Map newMap, v2i newCoord, int newRange, bool newIncludePathing, bool showArea, bool newAllowVaults)
	{
		if (map != newMap || startCoord != newCoord || includePathing != newIncludePathing || allowVaults != newAllowVaults)
		{
			map = newMap;
			startCoord = newCoord;
			includePathing = newIncludePathing;
			allowVaults = newAllowVaults;
			costDirty = true;
			borderDirty = true;
		}
		if (range != newRange)
		{
			range = newRange;
			borderDirty = true;
		}
		this.showArea = showArea;
		if ((bool)routine.running)
		{
			routine.Reset();
		}
		else
		{
			MR.Inst.Host.StartTopLevel(routine);
		}
		return routine.completed;
	}

	private IEnumerator<HagletYieldTerm> DrawBorder()
	{
		if (costDirty)
		{
			yield return Wait.While(NC.Inst.CalculateArea(this));
		}
		if (!showArea || status != 0)
		{
			yield break;
		}
		if (borderDirty)
		{
			GenerateAreaBorder();
		}
		VFXTileController vfxTiles = map.VFXTiles;
		vfxTiles.ClearGroup(VFXTileController.TileGroup.Area);
		int j = 0;
		while (true)
		{
			int num = j;
			v2i maxMapSize = Map.maxMapSize;
			if (num >= maxMapSize.y + 1)
			{
				break;
			}
			int i = 0;
			while (true)
			{
				int num2 = i;
				v2i maxMapSize2 = Map.maxMapSize;
				if (num2 >= maxMapSize2.x + 1)
				{
					break;
				}
				int num3 = i;
				int num4 = j;
				v2i maxMapSize3 = Map.maxMapSize;
				int index = num3 + num4 * (maxMapSize3.x + 1);
				int borderID = borderData[index];
				VFXTileController.TileType idx = (VFXTileController.TileType)VFXTileController.LUT_AreaTileIndexToVFXTileIndex[borderID];
				if (idx != VFXTileController.TileType.MAX)
				{
					Vector3 pos2 = map.CoordToLocalPos(new v2i(i, j));
					pos2 -= new Vector3(0.5f, 0f, 0.5f);
					pos2 = map.LocalPosToWorldPos(pos2);
					Quaternion rot = VFXTileController.LUT_AreaTileIndexToRotation[borderID];
					vfxTiles.CreateTile(idx, pos2, rot);
					if ((i & 2) == 0)
					{
						yield return null;
					}
				}
				i++;
			}
			j++;
		}
		AC.Inst.PlayOneShot2D("event:/sfx/ui/move border draw");
	}

	private void GenerateAreaBorder()
	{
		v2i maxMapSize = Map.maxMapSize;
		int x = maxMapSize.x;
		v2i maxMapSize2 = Map.maxMapSize;
		int y = maxMapSize2.y;
		for (int i = 0; i < y + 1; i++)
		{
			for (int j = 0; j < x + 1; j++)
			{
				int num = 0;
				int num2 = j - 1;
				int num3 = i - 1;
				num = ((num2 >= 0 && num3 >= 0) ? ((costs[num2 + num3 * x] > range) ? 8 : 0) : 8);
				num |= ((num2 + 1 < x && num3 >= 0) ? ((costs[num2 + 1 + num3 * x] > range) ? 4 : 0) : 4);
				num |= ((num2 + 1 < x && num3 + 1 < y) ? ((costs[num2 + 1 + (num3 + 1) * x] > range) ? 2 : 0) : 2);
				num |= ((num2 < 0 || num3 + 1 >= y) ? 1 : ((costs[num2 + (num3 + 1) * x] > range) ? 1 : 0));
				int num4 = j + i * (x + 1);
				borderData[num4] = (byte)num;
			}
		}
	}
}
public class VFXTileContainer
{
	public GameObject tile;

	public VFXTileController.TileType tileType;
}
public class VFXTilesContainer
{
	public ConstArray<GameObject> tiles;

	public VFXTileController.TileType tileType;

	public VFXTilesContainer(ConstArray<GameObject> tiles, VFXTileController.TileType tileType)
	{
		this.tiles = tiles;
		this.tileType = tileType;
	}

	private VFXTilesContainer()
	{
	}
}
public class VOController : MonoBehaviour
{
	public enum VOQueueProperty
	{
		Queue = 1,
		Interrupt = 2,
		Instant = 4,
		OnlyPlayIfQueueEmpty = 8
	}

	public enum VOCompletion
	{
		Finished,
		Stopped,
		Interrupted,
		Ignored
	}

	public struct VOClip
	{
		public string key;

		public VOQueueProperty properties;

		public Action<VOCompletion> onComplete;

		public float delayTime;

		public FMOD.Studio.EventInstance handle;

		public FMOD.Studio.EventInstance voDuckerSnapshot;

		public Transform source;

		public Unit sourceUnit;
	}

	private static VOController _instance;

	private const int kQueueSize = 8;

	private const int kVOTrackNum = 1;

	private ConstQueue<VOClip> voQueue = new ConstQueue<VOClip>(8);

	private Dictionary<string, Guid> dictKeyToGUID;

	public FMODBankAsset stringBankAsset;

	public static VOController Inst
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.Instantiate(Resources.Load<VOController>("Controllers/P_VOController"));
				UnityEngine.Object.DontDestroyOnLoad(_instance);
			}
			return _instance;
		}
	}

	public HagletYieldTerm LoadAllVOGuids(bool synchronous)
	{
		if (dictKeyToGUID != null)
		{
			return Wait.PreMet;
		}
		Action action = delegate
		{
			AC.Inst.sys.getBankByID(stringBankAsset.fmodGUID, out var bank);
			bank.getStringCount(out var count);
			string[] array = new string[count];
			Guid[] array2 = new Guid[count];
			dictKeyToGUID = new Dictionary<string, Guid>(count, StringComparer.OrdinalIgnoreCase);
			string text = "event:/vo/";
			int length = text.Length;
			for (int i = 0; i < count; i++)
			{
				bank.getStringInfo(i, out var id, out var path);
				if (path.Length >= length && path.IndexOf(text, 0, length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					dictKeyToGUID[path.Substring(length)] = id;
				}
			}
		};
		if (synchronous)
		{
			action();
			return Wait.PreMet;
		}
		AEResources.AddThreadTask(action);
		return Wait.While(AEResources.ThreadBusy);
	}

	public Guid GetVOGuid(string key)
	{
		if (dictKeyToGUID.TryGetValue(key, out var value))
		{
			return value;
		}
		return default(Guid);
	}

	private void Update()
	{
		if (voQueue.Length <= 0)
		{
			return;
		}
		VOClip value = voQueue[0];
		if (value.delayTime <= 0f)
		{
			if (!value.handle.isValid())
			{
				if (!dictKeyToGUID.TryGetValue(value.key, out var value2))
				{
					UnityEngine.Debug.LogError("Failed to find VO " + value.key);
					return;
				}
				value.handle = AC.Inst.GetHandle(value2);
				value.handle.start();
				value.voDuckerSnapshot = AC.Inst.PlaySnapshot("snapshot:/vo ducker");
			}
			if (value.source != null && (value.sourceUnit == null || Singleton<MC>.Inst == null || Singleton<MC>.Inst.GetActiveMap() == null || value.sourceUnit.map == Singleton<MC>.Inst.GetActiveMap()))
			{
				value.handle.set3DAttributes(value.source.position.to3DAttributes());
			}
			value.handle.getPlaybackState(out var state);
			if (state == PLAYBACK_STATE.STOPPED)
			{
				value.handle.release();
				if (value.voDuckerSnapshot.isValid())
				{
					value.voDuckerSnapshot.stop(STOP_MODE.ALLOWFADEOUT);
				}
				voQueue.Dequeue();
				if (value.onComplete != null)
				{
					value.onComplete(VOCompletion.Finished);
				}
				return;
			}
		}
		else
		{
			value.delayTime -= Time.deltaTime;
		}
		voQueue[0] = value;
	}

	public bool IsVOQueueEmpty()
	{
		return voQueue.Length == 0;
	}

	public bool VOPlayClip(string clipName, VOQueueProperty properties, Action<VOCompletion> onComplete, float delayTime = 0f, Transform source = null, Unit sourceUnit = null)
	{
		if ((bool)MR.Inst && MR.Inst.IsSkipping())
		{
			return false;
		}
		bool flag = (properties & VOQueueProperty.OnlyPlayIfQueueEmpty) != 0;
		if (!dictKeyToGUID.ContainsKey(clipName))
		{
			clipName = "MISSINGVOCLIP";
		}
		if (flag && !IsVOQueueEmpty())
		{
			onComplete?.Invoke(VOCompletion.Ignored);
			return false;
		}
		if ((properties & VOQueueProperty.Interrupt) != 0)
		{
			_VOStop(interruption: true);
			VOClipEnqueue(clipName, properties, onComplete, delayTime, source, sourceUnit);
		}
		else
		{
			VOClipEnqueue(clipName, properties, onComplete, delayTime, source, sourceUnit);
		}
		return true;
	}

	private void _VOStop(bool interruption)
	{
		if (!IsVOQueueEmpty())
		{
			VOClip vOClip = voQueue.Peek();
			vOClip.handle.stop(STOP_MODE.ALLOWFADEOUT);
			vOClip.handle.release();
			vOClip.voDuckerSnapshot.stop(STOP_MODE.ALLOWFADEOUT);
			voQueue.Clear();
			SubtitleController.Inst.ClearSubtitleQueue();
			voQueue.Peek().onComplete?.Invoke((!interruption) ? VOCompletion.Stopped : VOCompletion.Interrupted);
		}
	}

	public void VOStop()
	{
		_VOStop(interruption: false);
	}

	private void VOClipEnqueue(string key, VOQueueProperty properties, Action<VOCompletion> onComplete, float delayTime, Transform source = null, Unit sourceUnit = null)
	{
		VOClip obj = default(VOClip);
		obj.key = key;
		obj.properties = properties;
		obj.onComplete = onComplete;
		obj.delayTime = delayTime;
		obj.source = source;
		obj.sourceUnit = sourceUnit;
		voQueue.Enqueue(obj);
	}
}
[Serializable]
public class Ability_Backstab : AbilityImplBase
{
	private const int kRemainCloakedChance = 20;

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (weapon != null && weapon.IsMelee && unit.IsCloaked && (barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}

	public override void ApplyAttackerDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (weapon != null && weapon.IsMelee && unit.IsCloaked && (barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		if (unit.IsCloaked && weapon != null && weapon.IsMelee)
		{
			PlayParticles(unit);
		}
	}

	public override bool OnUnitAttackShouldUncloak(Unit unit)
	{
		if (base.IsUpgraded && 20.PercentChance())
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_BACKSTAB");
			return false;
		}
		return true;
	}
}
[Serializable]
public class Ability_Leap : AbilityImplBase
{
	private const float kLeapDistanceModifier = 1.5f;

	private const float kLeapDistanceUpgradedModifier = 2f;

	private HagletResettable leapRoutine;

	private v2i teleportTarget;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		leapRoutine = new HagletResettable(LeapRoutine(), "Ability_Leap", HagletStepTime.Update, -1, 5);
	}

	private IEnumerator<HagletYieldTerm> LeapRoutine()
	{
		PlayParticles(owner);
		owner.StartTeleport(teleportTarget);
		yield return Wait.ForChildren;
		PlayParticles(owner, ParticleTypes.Leap_Target, teleportTarget);
		owner.UpdateIdleAnim();
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 2;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override int SelectionRange(Unit unit)
	{
		return Mathf.RoundToInt((float)unit.GetMovementDistancePerTurn() * ((!base.IsUpgraded) ? 1.5f : 2f));
	}

	public override bool ValidateTileSelection(Unit unit, v2i selection)
	{
		return GC.Inst.GetUnitAtCoordOnMap(unit.map, selection) == null;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		teleportTarget = selection[0];
		Routine.Start(leapRoutine, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_Conceal : AbilityImplBase
{
	private const float kDistanceToEnemy = 1f;

	private bool shouldCloakBecauseNotTargetted;

	public override void OnUnitSpawn(Unit unit)
	{
		OnUnitTurnModeBegin(unit);
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		if (GC.Inst.IsInCombatMode() && unit.teamType != UnitTeam.Type.NPC)
		{
			PlayParticles(unit);
			unit.OnEnterCloak();
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (shouldCloakBecauseNotTargetted)
		{
			unit.OnEnterCloak();
			shouldCloakBecauseNotTargetted = false;
		}
		if (base.IsUpgraded && !unit.IsCloaked)
		{
			shouldCloakBecauseNotTargetted = true;
		}
	}

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		if (base.IsUpgraded && isCombatCalculation && !target.IsCloaked)
		{
			shouldCloakBecauseNotTargetted = false;
		}
		return 0f;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		ConstArray<Unit> constArray = null;
		switch (unit.teamType)
		{
		case UnitTeam.Type.Player:
			constArray = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers();
			break;
		case UnitTeam.Type.Enemy:
			constArray = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
			break;
		}
		if (constArray != null && !isCombatEnd)
		{
			for (int i = 0; i < (int)constArray.Length && !ExitCloakIfCloseToUnit(unit, constArray[i]); i++)
			{
			}
		}
	}

	public override void OnOtherUnitEnteredCoord(Unit unit, Unit other, v2i coord)
	{
		ExitCloakIfCloseToUnit(unit, other);
	}

	protected bool ExitCloakIfCloseToUnit(Unit unit, Unit other)
	{
		if (other.teamType != unit.teamType && v2i.Distance(unit.coord, other.coord) < 1f)
		{
			unit.OnExitCloak();
			return true;
		}
		return false;
	}
}
[Serializable]
public class Ability_Cloak_and_Dagger : AbilityImplBase
{
	private const float kDistanceToEnemy = 2f;

	private bool _activeAtStartOfAttack;

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		_activeAtStartOfAttack = unit.IsCloaked;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		for (int i = 0; i < unit.AttackTargets.Length; i++)
		{
			if (!unit.IsCloaked && !unit.AttackTargets[i].IsAlive() && (base.IsUpgraded || 50.PercentChance()) && !unit.AttackTargets[i].charData.environmental)
			{
				PlayParticles(unit);
				unit.popupBar.Enqueue("POPUPBAR_ABILITY_CLOAKANDDAGGER");
				unit.OnEnterCloak();
			}
		}
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		ConstArray<Unit> constArray = null;
		switch (unit.teamType)
		{
		case UnitTeam.Type.Player:
			constArray = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers();
			break;
		case UnitTeam.Type.Enemy:
			constArray = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
			break;
		}
		if (constArray != null && !isCombatEnd)
		{
			for (int i = 0; i < (int)constArray.Length && !ExitCloakIfCloseToUnit(unit, constArray[i]); i++)
			{
			}
		}
	}

	public override bool OnUnitAttackShouldUncloak(Unit unit)
	{
		return _activeAtStartOfAttack;
	}

	public override void OnOtherUnitEnteredCoord(Unit unit, Unit other, v2i coord)
	{
		ExitCloakIfCloseToUnit(unit, other);
	}

	private bool ExitCloakIfCloseToUnit(Unit unit, Unit other)
	{
		if (!unit.IsCloaked)
		{
			return false;
		}
		if (other.teamType != unit.teamType && v2i.Distance(unit.coord, other.coord) < 2f)
		{
			unit.OnExitCloak();
			return true;
		}
		return false;
	}
}
[Serializable]
public class Ability_Decoy : AbilityImplBase
{
	private HagletResettable decoyRoutine;

	private v2i targetPos;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override int SelectionRange(Unit unit)
	{
		return unit.GetMovementDistancePerTurn();
	}

	public override bool RequiresMovement()
	{
		return true;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		unit.SpawnDecoyUnitIfNonExistant();
		decoyRoutine = new HagletResettable(DecoyRoutine(), "Ability_Decoy", HagletStepTime.Update, -1, 5);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		if (owner.decoyUnit.IsAlive())
		{
			owner.decoyUnit.Kill();
		}
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (unit.IsCloaked)
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_NOTWHILECONCEALED");
			}
			return AbilityWheelVisibility.Disabled;
		}
		if (unit.decoyUnit.IsAlive())
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_DECOYINUSE");
			}
			return AbilityWheelVisibility.Disabled;
		}
		return AbilityWheelVisibility.Enabled;
	}

	private IEnumerator<HagletYieldTerm> DecoyRoutine()
	{
		UnitModel unitModel = owner.unitModel;
		string abilityAnimationName = GetAbilityAnimationName();
		bool crouched = owner.unitModel.crouched;
		yield return unitModel.Play(abilityAnimationName, looping: false, crouched, interacting: false, updateIdleOnComplete: true);
		if (base.IsUpgraded)
		{
			owner.OnEnterCloak();
		}
		yield return owner.decoyUnit.SetCoord(owner.coord, owner.map);
		owner.decoyUnit.Revive(Unit.HologramAnim.IMMEDIATE);
		owner.decoyUnit.AP = owner.AP;
		owner.decoyUnit.HP = owner.HP;
		owner.decoyUnit.SetTeamType(owner.teamType);
		owner.decoyUnit.unitModel.LookAtDirectionLS(owner.unitModel.GetLookAtDirectionLS());
		yield return Wait.ForChildren;
		if (owner.teamType == UnitTeam.Type.Player || 50.PercentChance())
		{
			owner.decoyUnit.StartMovement(targetPos);
		}
		else
		{
			owner.StartMovement(targetPos);
		}
		yield return Wait.ForChildren;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		targetPos = selection[0];
		Routine.Start(decoyRoutine, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_Incorporeal : AbilityImplBase
{
	private bool hasBeenActivated;

	private bool hasBeenAttacked;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		hasBeenActivated = false;
		unit.unitModel.EnableIncorporealEffect(enabled: false);
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		hasBeenActivated = true;
		hasBeenAttacked = false;
		PlayParticles(unit);
		unit.unitModel.EnableIncorporealEffect(enabled: true);
	}

	public override void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
		hasBeenAttacked = true;
		if (!base.IsUpgraded)
		{
			unit.unitModel.EnableIncorporealEffect(enabled: false);
		}
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (hasBeenActivated && (base.IsUpgraded || !hasBeenAttacked))
		{
			barData.ResetValues();
			barData.defaultResult = UIWhamBar.WhamResult.Dodge;
			barData.whamState |= WhamStates.Dodge;
			barData.SetBarPositionValue(BarTypes.Dodge, 0f);
			barData.SetBarSizeValue(BarTypes.Dodge, 1f);
		}
	}

	public override void ApplyTargetedAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData)
	{
		if (hasBeenActivated && (base.IsUpgraded || !hasBeenAttacked))
		{
			barData.ResetValues();
		}
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_Nightcrawler : AbilityImplBase
{
	private const int kMovementDistanceMod = 2;

	private const int kMovementDistanceModUpgraded = 4;

	public override int GetUnitMaxMoveDistanceModifier(Unit unit)
	{
		if (unit.IsCloaked)
		{
			return (!base.IsUpgraded) ? 2 : 4;
		}
		return 0;
	}
}
[Serializable]
public class Ability_Sap : AbilityImplBase
{
	private int health_Gain = -1;

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (base.IsUpgraded || hitType == Combat.HitType.HitCritical)
		{
			PlayParticles(unit);
			unit.HPDecrement(health_Gain);
		}
	}
}
[Serializable]
public class Ability_Assassin : AbilityImplBase
{
	private int meleeMod = -1;

	private int rangedMod = 1;

	private int attackCount;

	private bool uncloak;

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		attackCount = 0;
		uncloak = false;
	}

	public override bool OnUnitAttackShouldUncloak(Unit unit)
	{
		return uncloak;
	}

	public override int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return (weapon.WeaponType != WeaponType.Melee) ? rangedMod : meleeMod;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (weapon.WeaponType == WeaponType.Ranged && base.IsUpgraded)
		{
			uncloak = attackCount > 0;
			attackCount++;
			if (owner.teamType == UnitTeam.Type.Enemy)
			{
				PlayAbilityEffects();
			}
		}
		else
		{
			uncloak = true;
		}
	}
}
[Serializable]
public class Ability_Bleed : AbilityImplBase
{
	private int intialDamage = 3;

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		return AbilityWheelVisibility.Enabled;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		UnitModel unitModel = owner.unitModel;
		string abilityAnimationName = GetAbilityAnimationName();
		bool crouched = owner.unitModel.crouched;
		unitModel.Play(abilityAnimationName, looping: false, crouched, interacting: false, updateIdleOnComplete: true);
		for (int i = 0; i < selection.Length; i++)
		{
			selection[i].HPDecrement(intialDamage, unit);
			PlayParticles(selection[i]);
			Ability_Bleed_Proxy ability_Bleed_Proxy = selection[i].abilities.Add<Ability_Bleed_Proxy>(this, isUpgraded: false);
			ability_Bleed_Proxy.upgraded = base.IsUpgraded;
		}
	}
}
[Serializable]
public class Ability_Bleed_Proxy : AbilityImplBase
{
	public bool upgraded;

	private const int bleedDamage = 3;

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (unit.HP > 0 && !isCombatEnd)
		{
			PlayParticles(unit);
			unit.HPDecrement(3, unit, null, Combat.HitType.Hit, notifyAbilites: true, shouldDecloak: false);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override void OnUnitRestoredHealth(Unit unit)
	{
		if (!upgraded)
		{
			unit.abilities.Remove(this);
		}
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		if (!upgraded)
		{
			effects.Add(StatusEffect.Create(StatusEffect.Type.Bleeding, this, int.MaxValue));
		}
		else
		{
			effects.Add(StatusEffect.Create(StatusEffect.Type.BleedingOverloaded, this, int.MaxValue));
		}
	}
}
[Serializable]
public class Ability_Secondary_Attack : AbilityImplBase
{
	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override int GetPendingDamage(Unit unit, Unit target)
	{
		return unit.GetDamageValue(isCriticalHit: false, target, unit.secondaryWeapon, isCombatCalculation: false);
	}

	public override int APCost(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Triggerman)
		{
			return (unit.AP == 0) ? 1 : unit.AP;
		}
		return 1;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		Unit target = selection[0];
		PlayParticles(unit);
		unit.StartAttack(target, unit.RangedWeapon, costsAP: false, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, Combat.CombatMinigame.AttackWhamBar);
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit2 = unitsActive[i];
			if (unit2.teamType != unit.teamType && unit2.teamType != UnitTeam.Type.NPC && unit2.IsTargetable && unit.map.GetAttackData(unit.coord, unit2.coord).coverType != CoverType.Obscured)
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		if (contextToFill != null)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_NOUNITSINSIGHT");
		}
		return AbilityWheelVisibility.Disabled;
	}
}
[Serializable]
public class Ability_Concussive_Shot : Ability_Secondary_Attack
{
}
[Serializable]
public class Ability_Throwing_Knives : Ability_Secondary_Attack
{
}
[Serializable]
public class Ability_Pea_Shooter : Ability_Secondary_Attack
{
}
[Serializable]
public class Ability_Hunker_Down : AbilityImplBase
{
	private HagletResettable hunkerdownRoutine;

	private Unit target;

	private const float AccuracyDebuff = 0.2f;

	public bool isProxy;

	private bool isStandingByCover;

	private bool hasBeenActivated;

	public override int APCost(Unit unit)
	{
		if (isProxy)
		{
			return 0;
		}
		return Mathf.Max(unit.AP, 1);
	}

	public override int CooldownMax()
	{
		if (isProxy)
		{
			return 0;
		}
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		if (isProxy)
		{
			return false;
		}
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (isProxy)
		{
			return AbilityBarkType.None;
		}
		return AbilityBarkType.Defence;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		hunkerdownRoutine = new HagletResettable(HunkerdownRoutine());
	}

	public override bool IsProxyAbility()
	{
		return isProxy;
	}

	public override void OnAbilityCasted()
	{
		isStandingByCover = false;
		hasBeenActivated = false;
		isProxy = false;
	}

	private bool IsHunkerInEffect(Unit target, Unit attacker)
	{
		if (!hasBeenActivated)
		{
			return false;
		}
		if (!isStandingByCover)
		{
			return false;
		}
		CoverType coverBetween = target.map.GetCoverBetween(attacker.coord, target.coord);
		if (coverBetween.Is(CoverType.None) || coverBetween.Is(CoverType.Flanked))
		{
			return false;
		}
		return true;
	}

	private void UpdateState(Unit unit)
	{
		isStandingByCover = unit.map.GetAdjacentCoverDirection(unit.coord, out var _, includeDiagonals: true);
	}

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		if (IsHunkerInEffect(target, attacker))
		{
			return -0.2f;
		}
		return 0f;
	}

	public override void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
		if (base.IsUpgraded)
		{
			target = attacker;
			Routine.Start(hunkerdownRoutine);
		}
	}

	public IEnumerator<HagletYieldTerm> HunkerdownRoutine()
	{
		if (owner.unitModel.crouched)
		{
			yield return owner.unitModel.Play(UnitModel.AnimID.TransCCrouchToCIdle);
		}
		WeaponAttributes weapon = owner.RangedWeapon;
		if (owner.mainWeapon.IsMelee)
		{
			if (v2i.IsNeighbour(owner.coord, target.coord))
			{
				weapon = owner.mainWeapon;
			}
		}
		else if (owner.mainWeapon.IsRanged)
		{
			owner.AimAtTarget(target._GetTransform().position);
		}
		yield return PlayAbilityEffects();
		Unit unit = owner;
		Unit unit2 = target;
		WeaponAttributes weapon2 = weapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(unit2, weapon2, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
		yield return Wait.ForChildren;
	}

	public override void OnUnitMoveEnd(Unit unit)
	{
		UpdateState(unit);
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (!isStandingByCover && (bool)contextToFill)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_NOTINCOVER");
		}
		return (!isStandingByCover) ? AbilityWheelVisibility.Disabled : AbilityWheelVisibility.Enabled;
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		hasBeenActivated = true;
		PlayParticles(owner);
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		hasBeenActivated = false;
		UpdateState(unit);
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (IsHunkerInEffect(target, unit))
		{
			barData.defaultResult = UIWhamBar.WhamResult.Hit;
			if ((barData.whamState & WhamStates.Crit) != 0)
			{
				barData.whamState &= (WhamStates)(-3);
			}
		}
	}
}
[Serializable]
internal class Ability_Combat_Medic_Small : AbilityImplBase, AIC.IHasAIInventory
{
	private Unit target;

	private HagletResettable combatMedicRoutine;

	private HagletResettable hideStatusBars;

	public int AIInventory { get; private set; }

	public override int APCost(Unit unit)
	{
		return GC.Inst.IsInTurnMode() ? 1 : 0;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override int SelectionRange(Unit unit)
	{
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return unit.teamMask;
	}

	public override AbilityMode GetAbilityMode()
	{
		return AbilityMode.Combat | AbilityMode.RPG;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		hideStatusBars = new HagletResettable(HideStatusBarsAfterDelay(), "Hide Status Bars for Medpack");
		combatMedicRoutine = new HagletResettable(CombatMedicRoutine(), "Medpack Routine");
		AIInventory = unit.aiParameters.startingMedkits;
	}

	private bool IsUnitSelectionValid(Unit unit)
	{
		if (unit.HP == unit.GetHPMax() || unit.charData.hackable)
		{
			return false;
		}
		return true;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return IsUnitSelectionValid(selection);
	}

	public override void OnSelectionBegin(Unit unit)
	{
		if (GC.Inst.IsInRPGMode())
		{
			if ((bool)hideStatusBars.running)
			{
				hideStatusBars.host.Pause(hideStatusBars);
				hideStatusBars.Reset();
			}
			ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
			uint num = 0u;
			for (uint length = activeMembers.Length; num < length; num++)
			{
				activeMembers[num].ShowStatusBar();
				activeMembers[num].statusBar.UpdateDisplay(immediate: true);
			}
		}
	}

	public override void OnSelectionCancel(Unit unit)
	{
		if (GC.Inst.IsInRPGMode())
		{
			if ((bool)hideStatusBars.running)
			{
				hideStatusBars.host.Pause(hideStatusBars);
				hideStatusBars.Reset();
			}
			ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
			uint num = 0u;
			for (uint length = activeMembers.Length; num < length; num++)
			{
				activeMembers[num].HideStatusBar();
			}
		}
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		Routine.Start(combatMedicRoutine, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> CombatMedicRoutine()
	{
		HagletTrigger animCompete = null;
		if (GC.Inst.IsInTurnMode() && owner.unitModel.HasAnim("CombatUseItem"))
		{
			animCompete = owner.unitModel.Play("CombatUseItem", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		}
		else
		{
			UnityEngine.Debug.LogWarning("We have no RPG Item interaction Animation yet (boo)");
		}
		target.HPDecrement((!base.IsUpgraded) ? (-4) : (-8));
		owner.PlayBark(BarkTypes.RestoreHealth);
		if (owner.teamType == UnitTeam.Type.Player)
		{
			Party.Inst.RemoveItemFromInventory(Item.Medpack.ToMeta(), 1);
		}
		else
		{
			AIInventory--;
		}
		PlayParticles(target);
		if (GC.Inst.IsInRPGMode())
		{
			if ((bool)hideStatusBars.running)
			{
				hideStatusBars.host.Pause(hideStatusBars);
				hideStatusBars.Reset();
			}
			yield return Routine.Start(hideStatusBars, MR.Inst.Host);
		}
		yield return animCompete;
	}

	public override QuantityInfo GetQuantityInfo(int abilitySubIdx)
	{
		QuantityInfo result = default(QuantityInfo);
		result.visible = true;
		result.amount = Party.Inst.GetItemCount(Item.Medpack.ToMeta());
		return result;
	}

	private IEnumerator<HagletYieldTerm> HideStatusBarsAfterDelay()
	{
		yield return Wait.ForSeconds(1f);
		if (GC.Inst.IsInRPGMode())
		{
			ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
			uint num = 0u;
			for (uint length = activeMembers.Length; num < length; num++)
			{
				activeMembers[num].HideStatusBar();
			}
		}
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (unit.GetTeam().type == UnitTeam.Type.Player && Party.Inst.GetItemCount(Item.Medpack.ToMeta()) <= 0)
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_NOMEDPACKS");
			}
			return AbilityWheelVisibility.Disabled;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit2 = unitsActive[i];
			if (unit2.teamType != UnitTeam.Type.NPC && IsUnitSelectionValid(unit2))
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		if ((bool)contextToFill)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_ALLUNITSFULLHEALTH");
		}
		return AbilityWheelVisibility.Disabled;
	}
}
[Serializable]
public class Ability_Last_Push : AbilityImplBase
{
	private bool hasBeenUsedInThisCombatSession;

	private bool isBoostingAP;

	private bool heal;

	private HagletResettable particleEffectsRoutine;

	public override void OnUnitSpawn(Unit unit)
	{
		particleEffectsRoutine = new HagletResettable(ParticleEffectsRoutine());
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		hasBeenUsedInThisCombatSession = false;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		isBoostingAP = false;
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (hasBeenUsedInThisCombatSession || unit.HP <= 0)
		{
			return;
		}
		float num = (float)unit.HP / (float)unit.GetHPMax();
		if (!(num <= 0.251f))
		{
			return;
		}
		hasBeenUsedInThisCombatSession = true;
		isBoostingAP = true;
		heal = false;
		unit.APDecrement(-1);
		if (base.IsUpgraded && (unit.teamType != 0 || Party.Inst.GetItemCount(Item.Medpack.ToMeta()) > 0))
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_LASTPUSH");
			unit.HPDecrement(-3);
			heal = true;
			if (unit.teamType == UnitTeam.Type.Player)
			{
				Party.Inst.RemoveItemFromInventory(Item.Medpack.ToMeta(), 1);
			}
		}
		Routine.Start(particleEffectsRoutine);
	}

	public override int GetUnitAPMaxModifier(Unit unit)
	{
		return isBoostingAP ? 1 : 0;
	}

	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (base.IsUpgraded)
		{
			return isBoostingAP ? 100 : 0;
		}
		return 0;
	}

	private IEnumerator<HagletYieldTerm> ParticleEffectsRoutine()
	{
		ParticlePrefab particle = PlayParticles(owner);
		yield return null;
		if (heal)
		{
			yield return particle.OnDespawned;
			PlayParticles(owner, ParticleTypes.Combat_Medic);
		}
	}
}
[Serializable]
public class Ability_DEBUG_SilentAccuracyMod : AbilityImplBase
{
	public float accuracyMod;

	public override void OnAbilityCasted()
	{
		accuracyMod = 0f;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyMod;
	}
}
[Serializable]
public class Ability_DEBUG_SilentDodgeMod : AbilityImplBase
{
	public int dodgeChanceMod;

	public float dodgeSizeMod;

	public override void OnAbilityCasted()
	{
		dodgeChanceMod = 0;
	}

	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return dodgeChanceMod;
	}

	public override float GetUnitDodgeSizeModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return dodgeSizeMod;
	}
}
[Serializable]
public class Ability_Accuracy_Proxy : AbilityImplBase
{
	public float accuracyMod;

	public int duration;

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyMod;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		duration--;
		if (duration == 0 && !isCombatEnd)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_ACCURACYPROXY_RESTORED");
			unit.abilities.Remove(this);
		}
	}

	public override void OnUnitRestoredHealth(Unit unit)
	{
		unit.popupBar.Enqueue("POPUPBAR_ABILITY_ACCURACYPROXY_RESTORED");
		unit.abilities.Remove(this);
	}

	public override void OnAbilityCasted()
	{
		owner.popupBar.Enqueue("POPUPBAR_ABILITY_ACCURACYPROXY_REDUCED");
		accuracyMod = 0f;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.ReducedAccuracy, this, (duration > 0) ? duration : int.MaxValue));
	}
}
[Serializable]
public class Ability_CritChance_Proxy : AbilityImplBase
{
	public int critMod;

	public int duration;

	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return critMod;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		duration--;
		if (duration == 0 && !isCombatEnd)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_CRITCHANCEPROXY_RESTORED");
			unit.abilities.Remove(this);
		}
	}

	public override void OnUnitRestoredHealth(Unit unit)
	{
		unit.popupBar.Enqueue("POPUPBAR_ABILITY_CRITCHANCEPROXY_RESTORED");
		unit.abilities.Remove(this);
	}

	public override void OnAbilityCasted()
	{
		owner.popupBar.Enqueue("POPUPBAR_ABILITY_CRITCHANCEPROXY_REDUCED");
		critMod = 0;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}
}
[Serializable]
public class Ability_Movement_Proxy : AbilityImplBase
{
	public int movementMod;

	public override int GetUnitMaxMoveDistanceModifier(Unit unit)
	{
		return movementMod;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		owner.popupBar.Enqueue("POPUPBAR_ABILITY_MOVEMENTPROXY_REDUCED");
		movementMod = 0;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.ReducedMovement, this, 1));
	}
}
[Serializable]
public class Ability_DEBUG_Movement_Proxy : AbilityImplBase
{
	public int movementMod;

	public override int GetUnitMaxMoveDistanceModifier(Unit unit)
	{
		return movementMod;
	}

	public override void OnAbilityCasted()
	{
		movementMod = 0;
	}
}
[Serializable]
public class Ability_ReceiveShot_Proxy : AbilityImplBase
{
	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		Unit unit = caster.owner;
		Unit target = owner;
		WeaponAttributes rangedWeapon = unit.RangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((unit.teamType != UnitTeam.Type.Enemy) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(target, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, minigame);
	}

	public override void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
		unit.abilities.Remove(this);
	}
}
[Serializable]
public class Ability_Vault : AbilityImplBase
{
	public override void OnUnitSpawn(Unit unit)
	{
		unit.IsVaultAllowed = true;
	}

	public override void OnUnitVaulted(Unit unit, v2i vaultStart, v2i vaultEnd)
	{
		if (base.IsUpgraded && 20.PercentChance())
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_VAULT");
			unit.APDecrement(-1);
		}
	}
}
[Serializable]
public class Ability_VaultKick : AbilityImplBase
{
	private const int kStunChance = 50;

	private HagletResettable vaultKickRoutine;

	private ConstArray<Unit> nearbyUnits = new ConstArray<Unit>(9u);

	private Unit vaultingUnit;

	private v2i vaultLandingCoord;

	public override void OnUnitSpawn(Unit unit)
	{
		vaultKickRoutine = new HagletResettable(VaultKickRoutine(), "Vault Kick");
		unit.IsVaultAllowed = true;
	}

	public override void OnUnitStartedVault(Unit unit, v2i vaultStart, v2i vaultEnd)
	{
		vaultingUnit = unit;
		vaultLandingCoord = vaultEnd;
		Routine.Start(vaultKickRoutine, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> VaultKickRoutine()
	{
		Unit hitUnit = GC.Inst.GetUnitAtCoord(vaultLandingCoord);
		if (hitUnit == null)
		{
			Unit.GatherUnitsInRadius(vaultLandingCoord, 1f, nearbyUnits, ~owner.teamMask);
			if (nearbyUnits.Length != 0)
			{
				hitUnit = nearbyUnits[0];
			}
		}
		if (!(hitUnit == null) && hitUnit.teamType != owner.teamType)
		{
			vaultingUnit.popupBar.Enqueue("Ability_VaultKick_NAME");
			yield return Wait.ForSeconds(0.5f);
			vaultingUnit.DamageAttackTarget(hitUnit, Combat.HitType.Hit, vaultingUnit.GetDamageValue(isCriticalHit: false, hitUnit, vaultingUnit.MeleeWeapon, isCombatCalculation: true));
			if (base.IsUpgraded && 50.PercentChance())
			{
				hitUnit.popupBar.Enqueue("POPUPBAR_ABILITY_STUNNEDPROXY_STUNNED");
				hitUnit.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			}
		}
	}
}
[Serializable]
public class Ability_Stunned_Proxy : AbilityImplBase
{
	private ParticlePrefab pp;

	public int duration = 1;

	public bool stopIfHit;

	public bool showStunnedBanner = true;

	public bool showStatusEffect = true;

	public bool playAnimation = true;

	public bool playParticle = true;

	public bool friendlyFire;

	public bool isTrap;

	private bool decrementAtStart = true;

	private HagletResettable showStunVisuals;

	public Ability_Stunned_Proxy()
	{
		showStunVisuals = new HagletResettable(PlayStunVisualsRoutine(), "Play Stun Visual FX");
	}

	public override bool GetUnitAttackingDisabled(Unit unit)
	{
		return true;
	}

	public override bool GetUnitMovementDisabled(Unit unit)
	{
		return true;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (!decrementAtStart || friendlyFire)
		{
			DecrementDuration(unit, isCombatEnd);
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if ((decrementAtStart && !friendlyFire) || isTrap)
		{
			DecrementDuration(unit, isCombatEnd: false);
		}
		if (duration > 0)
		{
			if (showStunnedBanner)
			{
				unit.popupBar.Enqueue("POPUPBAR_ABILITY_STUNNEDPROXY_STUNNED");
			}
			unit.APDecrement(unit.AP);
		}
	}

	private void DecrementDuration(Unit unit, bool isCombatEnd)
	{
		duration--;
		if (duration == 0)
		{
			if (!isCombatEnd)
			{
				unit.popupBar.Enqueue("POPUPBAR_ABILITY_STUNNEDPROXY_UNSTUNNED");
			}
			unit.abilities.Remove(this);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (stopIfHit)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_STUNNEDPROXY_UNSTUNNED");
			unit.abilities.Remove(this);
		}
	}

	public override void OnAbilityCasted()
	{
		duration = 1;
		showStatusEffect = true;
		stopIfHit = false;
		playAnimation = true;
		playParticle = true;
		decrementAtStart = GC.Inst.GetActiveTeamType() == owner.teamType;
		owner.APDecrement(owner.AP);
		foreach (AbilityImplBase item in owner.abilities.OnUnitAndTeam())
		{
			item.OnUnitStunned(owner);
		}
		Routine.Start(showStunVisuals, MR.Inst.Host);
	}

	public override void OnAbilityUncasted()
	{
		if ((bool)pp)
		{
			pp.StopParticles();
			pp = null;
		}
	}

	private IEnumerator<HagletYieldTerm> PlayStunVisualsRoutine()
	{
		yield return null;
		if (playAnimation && owner.IsAlive())
		{
			owner.Hit();
		}
		if (playParticle && owner.IsAlive())
		{
			pp = PlayParticles(owner);
		}
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		if (showStatusEffect)
		{
			effects.Add(StatusEffect.Create(StatusEffect.Type.Stunned, this, 1));
		}
	}
}
[Serializable]
public class Ability_Grenade : AbilityImplBase, AIC.IHasAIInventory
{
	[Serializable]
	public struct Grenade
	{
		public int turnCount;

		public v2i target;

		public ParticleGrenade particle;

		public VFXTileContainer radiusVfx;

		public GadgetType type;
	}

	private const float kAOERadius = 2f;

	private const float kUpgradedAOERadius = 3f;

	public GadgetType? typeOverride;

	private ConstArray<Grenade> grenades = new ConstArray<Grenade>(4u);

	private ConstArray<Unit> targets = new ConstArray<Unit>(8u);

	[NonSerialized]
	private VFXTilesContainer vfxCache;

	private HagletResettable grenadeThrowRoutine;

	private HagletResettable grenadeExplodeRoutine;

	private Grenade thrownGrenade;

	public HagletTrigger OnGrenadeThrown = new HagletTrigger();

	public int AIInventory { get; private set; }

	public ConstArray<Grenade> Grenades => grenades;

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override int SelectionRange(Unit unit)
	{
		return 10;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 2f : 3f;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override bool IsTeamAbility()
	{
		return true;
	}

	public override VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		return VFXTileController.TileType.AreaSelectionOffensive;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		grenadeThrowRoutine = new HagletResettable(GrenadeThrowRoutine(), "Grenade Throw");
		grenadeExplodeRoutine = new HagletResettable(GrenadeExplodeRoutine(), "Grenade Explode");
		AIInventory = unit.aiParameters.startingInventory;
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (Party.Inst.GetItemCount(Item.Grenade_Frag.ToMeta()) > 0 || Party.Inst.GetItemCount(Item.Grenade_Stun.ToMeta()) > 0 || Party.Inst.GetItemCount(Item.Grenade_Flux.ToMeta()) > 0)
		{
			return AbilityWheelVisibility.Enabled;
		}
		return AbilityWheelVisibility.Disabled;
	}

	public override AbilityMeta GetAbilityWheelSubAbilityMetaAtIdx(int idx)
	{
		return meta.subAbilities[idx];
	}

	public static AbilityWheelVisibility GetAvailability(Item type, AbilityMeta abilityMeta, UITextbox contextToFill = null)
	{
		ItemStackMeta itemStackMeta = type.ToMeta();
		if (!Party.Inst.FindStackByMeta(itemStackMeta).hasEverBeenPickedUp)
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (Party.Inst.GetItemCount(itemStackMeta) == 0)
		{
			if (contextToFill != null)
			{
				switch (type)
				{
				case Item.Grenade_Frag:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOFRAGGRENADES");
					break;
				case Item.Grenade_Stun:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOSTUNGRENADES");
					break;
				case Item.Grenade_Flux:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOFLUXGRENADES");
					break;
				case Item.Trap_Frag:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOFRAGTRAPS");
					break;
				case Item.Trap_Stun:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOSTUNTRAPS");
					break;
				case Item.Trap_Flux:
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOFLUXTRAPS");
					break;
				}
			}
			return AbilityWheelVisibility.Disabled;
		}
		return AbilityWheelVisibility.Enabled;
	}

	public override AbilityWheelVisibility GetAbilityWheelSubAbilityIsAvailableAtIdx(int idx, UITextbox contextToFill = null)
	{
		return idx switch
		{
			0 => GetAvailability(Item.Grenade_Frag, GetAbilityWheelSubAbilityMetaAtIdx(0), contextToFill), 
			1 => GetAvailability(Item.Grenade_Stun, GetAbilityWheelSubAbilityMetaAtIdx(1), contextToFill), 
			2 => GetAvailability(Item.Grenade_Flux, GetAbilityWheelSubAbilityMetaAtIdx(2), contextToFill), 
			_ => AbilityWheelVisibility.Enabled, 
		};
	}

	private IEnumerator<HagletYieldTerm> GrenadeThrowRoutine()
	{
		int attackEventCount = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(GetAbilityAnimationName());
		HagletTrigger animComplete = owner.unitModel.Play(GetAbilityAnimationName(), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		if (attackEventCount > 0)
		{
			yield return owner.WaitForAttackAnimEvent();
		}
		else
		{
			yield return animComplete;
		}
		Vector3 localStartPoint = ((!(owner.unitModel.PropXForm != null)) ? owner.map.WorldPosToLocalPos(owner._GetTransform().position) : owner.map.transform.InverseTransformPoint(owner.unitModel.PropXForm.transform.position));
		thrownGrenade.particle = (ParticleGrenade)PSC.Inst.Play(ParticleTypes.Grenade, localStartPoint, Quaternion.identity, new Vector3(1f, 1f, 1f), owner.map.transform);
		thrownGrenade.turnCount = 1;
		yield return thrownGrenade.particle.AnimateToTarget(owner.map, localStartPoint, owner.map.CoordToLocalPos(thrownGrenade.target));
		VFXTileController.TileType tileType = (base.IsUpgraded ? VFXTileController.TileType.DangerZone7 : VFXTileController.TileType.DangerZone5);
		thrownGrenade.radiusVfx = owner.map.VFXTiles.TileShow(thrownGrenade.target, tileType);
		grenades.Add(thrownGrenade);
		OnGrenadeThrown.Trigger();
		thrownGrenade = default(Grenade);
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		Item item = Item.Grenade_Frag;
		thrownGrenade.target = selection[0];
		GadgetType? gadgetType = typeOverride;
		if (!gadgetType.HasValue)
		{
			switch (choice.subAbilityIdx)
			{
			case 0:
				thrownGrenade.type = GadgetType.FRAG;
				item = Item.Grenade_Frag;
				break;
			case 1:
				thrownGrenade.type = GadgetType.STUN;
				item = Item.Grenade_Stun;
				break;
			case 2:
				thrownGrenade.type = GadgetType.FLUX;
				item = Item.Grenade_Flux;
				break;
			}
		}
		else
		{
			ref Grenade reference = ref thrownGrenade;
			GadgetType? gadgetType2 = typeOverride;
			reference.type = gadgetType2.Value;
		}
		if (unit.teamType == UnitTeam.Type.Player)
		{
			Party.Inst.RemoveItemFromInventory(item.ToMeta(), 1);
		}
		else
		{
			AIInventory--;
		}
		Routine.Start(grenadeThrowRoutine, MR.Inst.Host);
	}

	public override QuantityInfo GetQuantityInfo(int abilitySubIdx)
	{
		QuantityInfo result = default(QuantityInfo);
		result.visible = true;
		switch (abilitySubIdx)
		{
		case 0:
			result.amount = Party.Inst.GetItemCount(Item.Grenade_Frag.ToMeta());
			break;
		case 1:
			result.amount = Party.Inst.GetItemCount(Item.Grenade_Stun.ToMeta());
			break;
		case 2:
			result.amount = Party.Inst.GetItemCount(Item.Grenade_Flux.ToMeta());
			break;
		}
		return result;
	}

	private IEnumerator<HagletYieldTerm> GrenadeExplodeRoutine()
	{
		yield return Wait.ForSeconds(0.5f);
		uint i = 0u;
		while (i < grenades.Length)
		{
			if (grenades._data[i].turnCount <= 0)
			{
				string beepSFX = "event:/sfx/character/common/attack/grenade beep";
				AC.Inst.PlayOneShot2D(beepSFX);
				yield return Wait.ForSeconds(0.5f);
				targets.Clear();
				GadgetType grenadeType = grenades._data[i].type;
				v2i target = grenades[i].target;
				float radius = SelectionEffectRange(owner);
				ConstArray<Unit> unitArrayToFill = targets;
				bool hackableUnitsOnly = grenadeType == GadgetType.FLUX;
				Unit.GatherUnitsInRadius(target, radius, unitArrayToFill, 4294967279u, includeNPCs: false, hackableUnitsOnly);
				GC.Inst.ActivateGadget(isTrap: false, grenadeType, grenades[i].target, targets, this);
				grenades[i].particle.StopParticles();
				owner.map.VFXTiles.TileHide(grenades[i].radiusVfx);
				grenades.RemoveAtIndex(i);
				yield return Wait.ForSeconds(1f);
			}
			else
			{
				i++;
			}
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		for (uint num = 0u; num < grenades.Length; num++)
		{
			grenades._data[num].turnCount--;
		}
		Routine.Start(grenadeExplodeRoutine, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		typeOverride = null;
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		for (uint num = 0u; num < grenades.Length; num++)
		{
			grenades[num].particle.StopParticles();
			owner.map.VFXTiles.TileHide(grenades[num].radiusVfx);
		}
		grenades.Clear();
	}
}
[Serializable]
public class Ability_Grenade_Frag : AbilityImplBase
{
}
[Serializable]
public class Ability_Grenade_Stun : AbilityImplBase
{
}
[Serializable]
public class Ability_Grenade_Flux : AbilityImplBase
{
}
[Serializable]
public class Ability_Trap : AbilityImplBase, AIC.IHasAIInventory
{
	public const int kTrapPoolSize = 8;

	private const int kMaxPlayerTraps = 1;

	private const int kTrapRadius = 1;

	private const int kUpgradedTrapRadius = 2;

	private TileTrapTrigger[] trapPool = new TileTrapTrigger[8];

	private Transform dormantTrapsParent;

	private v2i lastTrapTarget;

	private GadgetType trapType;

	private Item trapItem;

	private HagletResettable trap;

	public int AIInventory { get; private set; }

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		return VFXTileController.TileType.AreaSelectionOffensive;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int SelectionRange(Unit unit)
	{
		return 7;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 1 : 2;
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (Party.Inst.GetItemCount(Item.Trap_Frag.ToMeta()) < 1 && Party.Inst.GetItemCount(Item.Trap_Stun.ToMeta()) < 1 && Party.Inst.GetItemCount(Item.Trap_Flux.ToMeta()) < 1)
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_NOTRAPS");
			}
			return AbilityWheelVisibility.Disabled;
		}
		TileTrapTrigger freeTrap = GetFreeTrap();
		if (freeTrap == null)
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_TRAPINUSE");
			}
			return AbilityWheelVisibility.Disabled;
		}
		return AbilityWheelVisibility.Enabled;
	}

	public override AbilityWheelVisibility GetAbilityWheelSubAbilityIsAvailableAtIdx(int idx, UITextbox contextToFill = null)
	{
		TileTrapTrigger freeTrap = GetFreeTrap();
		if (freeTrap == null)
		{
			if (contextToFill != null)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_TRAPINUSE");
			}
			return AbilityWheelVisibility.Hidden;
		}
		return idx switch
		{
			0 => Ability_Grenade.GetAvailability(Item.Trap_Frag, GetAbilityWheelSubAbilityMetaAtIdx(0), contextToFill), 
			1 => Ability_Grenade.GetAvailability(Item.Trap_Stun, GetAbilityWheelSubAbilityMetaAtIdx(1), contextToFill), 
			2 => Ability_Grenade.GetAvailability(Item.Trap_Flux, GetAbilityWheelSubAbilityMetaAtIdx(2), contextToFill), 
			_ => AbilityWheelVisibility.Enabled, 
		};
	}

	public override AbilityMeta GetAbilityWheelSubAbilityMetaAtIdx(int idx)
	{
		return meta.subAbilities[idx];
	}

	public override QuantityInfo GetQuantityInfo(int abilitySubIdx)
	{
		QuantityInfo result = default(QuantityInfo);
		result.visible = true;
		switch (abilitySubIdx)
		{
		case 0:
			result.amount = Party.Inst.GetItemCount(Item.Trap_Frag.ToMeta());
			break;
		case 1:
			result.amount = Party.Inst.GetItemCount(Item.Trap_Stun.ToMeta());
			break;
		case 2:
			result.amount = Party.Inst.GetItemCount(Item.Trap_Flux.ToMeta());
			break;
		}
		return result;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		trap = new HagletResettable(TrapRoutine(), owner.charData.charName + " Trap");
		dormantTrapsParent = new GameObject("Traps").transform;
		dormantTrapsParent.SetParent(unit._GetTransform());
		trapPool[0] = LR.LoadPrefabResource("Gameplay/P_TTrapTrigger").GetComponent<TileTrapTrigger>();
		for (int i = 0; i < trapPool.Length; i++)
		{
			if (i > 0)
			{
				trapPool[i] = UnityEngine.Object.Instantiate(trapPool[0]);
			}
			trapPool[i].InitialiseTrap(dormantTrapsParent, this);
			trapPool[i].size.x = ((!base.IsUpgraded) ? 1 : 2);
			Renderer[] componentsInChildren = trapPool[i].GetComponentsInChildren<Renderer>(includeInactive: true);
			Renderer[] array = componentsInChildren;
			foreach (Renderer render in array)
			{
				VFXTileController.SetSortingOrder(render);
			}
		}
		AIInventory = unit.aiParameters.startingInventory;
	}

	public override bool ValidateTileSelection(Unit unit, v2i selection)
	{
		if (GC.Inst.GetUnitAtCoord(selection) == null && unit.map.GetTileAction(selection) == null && unit.map.GetTrap(selection, unit.teamType) == null)
		{
			return true;
		}
		return false;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		lastTrapTarget = selection[0];
		switch (choice.subAbilityIdx)
		{
		case 0:
			trapType = GadgetType.FRAG;
			trapItem = Item.Trap_Frag;
			break;
		case 1:
			trapType = GadgetType.STUN;
			trapItem = Item.Trap_Stun;
			break;
		case 2:
			trapType = GadgetType.FLUX;
			trapItem = Item.Trap_Flux;
			break;
		}
		Routine.Start(trap, MR.Inst.Host);
	}

	public TileTrapTrigger GetFreeTrap()
	{
		int num = Mathf.Min(8, (owner.teamType == UnitTeam.Type.Player) ? 1 : owner.aiParameters.maxActiveTraps);
		for (int i = 0; i < num; i++)
		{
			if (!trapPool[i].gameObject.activeSelf)
			{
				return trapPool[i];
			}
		}
		return null;
	}

	private IEnumerator<HagletYieldTerm> TrapRoutine()
	{
		if (owner.teamType == UnitTeam.Type.Player)
		{
			Party.Inst.RemoveItemFromInventory(trapItem.ToMeta(), 1);
		}
		else
		{
			AIInventory--;
		}
		TileTrapTrigger newTrap = GetFreeTrap();
		PlayParticles(owner, ParticleTypes.ShockwaveLarge);
		int attackEventCount = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(GetAbilityAnimationName());
		HagletTrigger animComplete = owner.unitModel.Play(GetAbilityAnimationName());
		if (attackEventCount > 0)
		{
			yield return owner.WaitForAttackAnimEvent();
		}
		else
		{
			yield return animComplete;
		}
		PlayParticles(owner, ParticleTypes.ShockImplodeLarge, lastTrapTarget);
		newTrap.size.x = ((!base.IsUpgraded) ? 1 : 2);
		newTrap.teamType = owner.teamType;
		owner.map.PlaceTrap(trapType, newTrap, lastTrapTarget, owner.GetTeam().type == UnitTeam.Type.Player);
		if (owner.unitModel.IsPlayingAnim(GetAbilityAnimationName()))
		{
			yield return animComplete;
		}
		owner.UpdateIdleAnim();
	}
}
[Serializable]
public class Ability_Trap_Frag : AbilityImplBase
{
}
[Serializable]
public class Ability_Trap_Stun : AbilityImplBase
{
}
[Serializable]
public class Ability_Trap_Flux : AbilityImplBase
{
}
[Serializable]
public class Ability_DEBUG_InfiniteAccuracy : AbilityImplBase
{
	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 10f;
	}
}
[Serializable]
public class Ability_DEBUG_InfiniteDodge : AbilityImplBase
{
	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return 1000;
	}
}
[Serializable]
public class Ability_DEBUG_InfiniteCritChance : AbilityImplBase
{
	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 1000;
	}
}
[Serializable]
public class Ability_DEBUG_NoCritChance : AbilityImplBase
{
	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return -1000;
	}
}
[Serializable]
public class Ability_DEBUG_NoDodgeChance : AbilityImplBase
{
	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return -1000;
	}
}
[Serializable]
public class Ability_DEBUG_Particle : AbilityImplBase
{
	public override uint SelectionMask(Unit unit)
	{
		return uint.MaxValue;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		PlayParticles(selection[0]);
	}
}
[Serializable]
public class Ability_MISSING_ABILITY : AbilityImplBase
{
	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		PlayParticles(unit);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_DEBUG_Log : AbilityImplBase
{
	public override void OnUnitTurnBegin(Unit unit)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnUnitTurnBegin({0})", unit.charData.charName);
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnUnitTurnEnd({0})", unit.charData.charName);
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnUnitTurnModeBegin({0})", unit.charData.charName);
	}

	public override void OnAbilityCasted()
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnAbilityCasted({0})", owner.charData.charName);
	}

	public override void OnAbilityUncasted()
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnAbilityUncasted({0})", owner.charData.charName);
	}

	public override int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (isCombatCalculation)
		{
			UnityEngine.Debug.LogFormat("ABILITY_DEBUG: GetUnitDamageModifier({0})", unit.charData.charName);
		}
		return 0;
	}

	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		if (isCombatCalculation)
		{
			UnityEngine.Debug.LogFormat("ABILITY_DEBUG: GetUnitDodgeChanceModifier({0})", unit.charData.charName);
		}
		return 0;
	}

	public override void OnSelectionBegin(Unit unit)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnSelectionBegin({0})", unit.charData.charName);
	}

	public override void OnSelectionCancel(Unit unit)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnSelectionCancel({0})", unit.charData.charName);
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnUnitAttackBegin({0})", unit.charData.charName);
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		UnityEngine.Debug.LogFormat("ABILITY_DEBUG: OnUnitAttackEnd({0})", unit.charData.charName);
	}
}
[Serializable]
public class Ability_MaxHP : AbilityImplBase
{
	private int hpMod = 10;

	public void SetHPMod(int hpMod)
	{
		this.hpMod = hpMod;
		owner._SetLevel(owner.Level);
	}

	public override int GetUnitHPMaxModifier(Unit unit)
	{
		return hpMod;
	}
}
public class Ability_Self_Destruct : AbilityImplBase
{
	private const float kAOERadius = 2f;

	private const float kUpgradedAOERadius = 3f;

	private const string kDeathAnimName = "CombatExplode";

	private bool exploded;

	private bool waitForDeath = true;

	private bool HACK_combatEnded;

	private HagletResettable explosionResettable;

	private HagletResettable fadeOutRadiusPFX;

	private ParticlePrefab radiusPFX;

	private ConstArray<Unit> targets = new ConstArray<Unit>(8u);

	public override void OnUnitSpawn(Unit unit)
	{
		explosionResettable = new HagletResettable(Explode());
		fadeOutRadiusPFX = new HagletResettable(FadeOutRadiusPFXRoutine());
	}

	public override int GetUnitHPMaxModifier(Unit unit)
	{
		if (unit.HP <= 1)
		{
			return 0;
		}
		return -(unit.HP - 1);
	}

	public override void OnUnitRestoredHealth(Unit unit)
	{
		unit.HPDecrement(unit.HP - 1, unit);
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		HACK_combatEnded = false;
		unit.HPDecrement(unit.HP - 1, unit);
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 2f : 3f;
	}

	public override bool GetUnitMovementDisabled(Unit unit)
	{
		UnitTeam.Type teamType = unit.GetTeamType();
		return teamType == UnitTeam.Type.Enemy;
	}

	public override bool GetUnitAttackingDisabled(Unit unit)
	{
		UnitTeam.Type teamType = unit.GetTeamType();
		return teamType == UnitTeam.Type.Enemy;
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		unit.HPDecrement(unit.HP, unit);
		Routine.Start(explosionResettable);
	}

	public override string GetUnitDeathAnimName()
	{
		return "CombatExplode";
	}

	public override Unit.HologramAnim GetUnitDeathHologramAnim()
	{
		return Unit.HologramAnim.IMMEDIATE;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		if (!explosionResettable.running)
		{
			waitForDeath = false;
			Routine.Start(explosionResettable);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		StopRadiusFx();
		HACK_combatEnded = true;
	}

	public override void OnUserFocusedOnUnit(Unit unit)
	{
		if (GC.Inst.IsInTurnMode() && !HACK_combatEnded)
		{
			PlayRadiusFx();
		}
	}

	public override void OnUserUnFocusedOnUnit(Unit unit)
	{
		StopRadiusFx();
	}

	public IEnumerator<HagletYieldTerm> Explode()
	{
		if (exploded)
		{
			yield return null;
		}
		if (waitForDeath)
		{
			yield return Wait.Until(owner.OnDeathComplete);
		}
		yield return Wait.ForSeconds(0.15f);
		Unit unit = owner;
		exploded = true;
		targets.Clear();
		Unit.GatherUnitsInRadius(unit.coord, SelectionEffectRange(owner), targets);
		GC.Inst.ActivateGadget(isTrap: false, GadgetType.FRAG, unit.coord, targets, this);
		yield return Wait.ForChildren;
		StopRadiusFx();
	}

	private IEnumerator<HagletYieldTerm> FadeOutRadiusPFXRoutine()
	{
		radiusPFX.StopParticlesFade();
		yield return null;
		while (radiusPFX.IsFadingOut)
		{
			yield return null;
		}
		radiusPFX = null;
	}

	private void PlayRadiusFx()
	{
		if (radiusPFX != null && (bool)fadeOutRadiusPFX.running)
		{
			fadeOutRadiusPFX.host.Pause(fadeOutRadiusPFX);
			fadeOutRadiusPFX.Reset();
			radiusPFX.CancelFadeOut();
		}
		else
		{
			radiusPFX = PSC.Inst.Play((!HACK_isUpgraded) ? ParticleTypes.GrenadeRadiusSmall : ParticleTypes.GrenadeRadiusLarge, owner.map, owner.coord);
		}
	}

	private void StopRadiusFx()
	{
		if (radiusPFX != null)
		{
			if ((bool)fadeOutRadiusPFX.running)
			{
				fadeOutRadiusPFX.host.Pause(fadeOutRadiusPFX);
				fadeOutRadiusPFX.Reset();
			}
			if (fadeOutRadiusPFX.markedToRunBy == null)
			{
				Routine.Start(fadeOutRadiusPFX);
			}
		}
	}
}
[Serializable]
public class Ability_Static_Skin : AbilityImplBase
{
	private Unit target;

	private Wrapper<Type> abilityPointer = new Wrapper<Type>(null);

	private HagletResettable staticSkinRoutine;

	public override void OnUnitSpawn(Unit unit)
	{
		staticSkinRoutine = new HagletResettable(StaticSkinRoutine(), "Static skin routine");
		SaveData.data.HACK_hasStaticSkin = true;
	}

	public override void OnOtherUnitEnteredCoord(Unit unit, Unit other, v2i coord)
	{
		if (!staticSkinRoutine.running && !(v2i.Distance(unit.coord, other.coord) > 2f) && other.charData.hackable && !other.abilities.Exists<Ability_Static_Skin_Proxy>())
		{
			target = other;
			PlayParticles(unit);
			UISlotChamp.Inst.Clear();
			UISlotChamp.Inst.AddEffect<Ability_Nothing_Proxy>(5);
			UISlotChamp.Inst.AddEffect<Ability_Damage_Unit_Proxy>(2);
			UISlotChamp.Inst.AddEffect<Ability_Disable>(2);
			UISlotChamp.Inst.AddEffect<Ability_Break_Proxy>(1);
			Routine.Start(staticSkinRoutine);
		}
	}

	private IEnumerator<HagletYieldTerm> StaticSkinRoutine()
	{
		yield return PlayAbilityEffects();
		abilityPointer.val = null;
		yield return UISlotChamp.Inst.ShowSlotChamp(this, abilityPointer);
		yield return Wait.ForSeconds(0.25f);
		target.abilities.Add<Ability_Static_Skin_Proxy>(this, isUpgraded: false);
		if (abilityPointer.val == typeof(Ability_Damage_Unit_Proxy))
		{
			target.abilities.Add(abilityPointer.val, this, isUpgraded: false);
		}
		else if (abilityPointer.val == typeof(Ability_Disrupt_Proxy))
		{
			yield return Wait.ForChildren;
		}
		else if (abilityPointer.val == typeof(Ability_Disable))
		{
			Ability_Stunned_Proxy ability_Stunned_Proxy = (Ability_Stunned_Proxy)target.abilities.Add(typeof(Ability_Stunned_Proxy), this, isUpgraded: false);
			ability_Stunned_Proxy.duration = 2;
		}
		else if (abilityPointer.val == typeof(Ability_Break_Proxy))
		{
			Ability_Break_Proxy ability_Break_Proxy = (Ability_Break_Proxy)target.abilities.Add(abilityPointer.val, this, isUpgraded: false);
			ability_Break_Proxy.originalTeamType = target.teamType;
			target.SetTeamType(owner.teamType);
		}
		abilityPointer.val = null;
	}
}
[Serializable]
public class Ability_Damage_Unit_Proxy : AbilityImplBase
{
	private int damage = 1;

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		owner.HPDecrement(damage, caster.owner);
		caster.owner.NotifyAttackTarget(Combat.HitType.Hit, owner, playReactionAnimations: true);
		owner.abilities.Remove(this);
	}
}
[Serializable]
public class Ability_Nothing_Proxy : AbilityImplBase
{
	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		owner.abilities.Remove(this);
	}
}
[Serializable]
public class Ability_Static_Skin_Proxy : AbilityImplBase
{
	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		unit.abilities.Remove(this);
	}
}
[Serializable]
public class Ability_RefuseAttack : AbilityImplBase
{
	public override bool IsProxyAbility()
	{
		return true;
	}

	public override bool IsTeamAbility()
	{
		return true;
	}

	public override Combat.CombatMinigame OverrideAttackMinigame(Combat.CombatMinigame currentMinigame)
	{
		return Combat.CombatMinigame.RefuseAttackWhamBar;
	}
}
[Serializable]
public class Ability_DEBUG_CantDieWontKill : AbilityImplBase
{
	public override int OnUnitWillBeDamaged(Unit unit, int damage, Unit attacker, Combat.HitType hitType)
	{
		if (damage >= owner.HP)
		{
			damage = owner.HP - 1;
		}
		return damage;
	}

	public override int OnUnitTargetWillSustainDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (damageAmount >= target.HP)
		{
			damageAmount = target.HP - 1;
		}
		return damageAmount;
	}
}
[Serializable]
public class Ability_DEBUG_CantDie : AbilityImplBase
{
	public override int OnUnitWillBeDamaged(Unit unit, int damage, Unit attacker, Combat.HitType hitType)
	{
		if (damage >= owner.HP)
		{
			damage = owner.HP - 1;
		}
		return damage;
	}
}
[Serializable]
public class Ability_TestStatusEffects : AbilityImplBase
{
	private int numStatusEffects;

	public override void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
		numStatusEffects++;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		numStatusEffects--;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		for (int i = 0; i < numStatusEffects; i++)
		{
			int type = i % 10;
			int cooldown = 1;
			if (i % 2 == 0)
			{
				cooldown = int.MaxValue;
			}
			effects.Add(StatusEffect.Create((StatusEffect.Type)type, this, cooldown));
		}
	}
}
[Serializable]
public class Ability_Berserk : AbilityImplBase
{
	private const float kDamageIncreaseAmount = 0.5f;

	private float upgradedDamageModifierOverTime;

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		upgradedDamageModifierOverTime = 0f;
	}

	public override int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		int num = 0;
		if (base.IsUpgraded)
		{
			return (int)upgradedDamageModifierOverTime;
		}
		float num2 = (float)unit.GetHPMax() - (float)unit.HP;
		return (int)(num2 * 0.5f);
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		PlayAbilityEffects();
		PlayParticles(owner);
		if (base.IsUpgraded)
		{
			upgradedDamageModifierOverTime += (float)amount * 0.5f;
		}
	}
}
[Serializable]
public class Ability_Taunt : AbilityImplBase
{
	private const int kCoolDown = 2;

	private const int kCoolDownUpgraded = 0;

	private Unit target;

	private HagletResettable taunt;

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return (!base.IsUpgraded) ? 2 : 0;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return selection.abilities.AbilityGetByType<Ability_Taunt_Proxy>(selection) == null;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (unit.charData.partyMemberID == PartyMemberID.Noot)
		{
			return AbilityBarkType.Taunt;
		}
		return AbilityBarkType.General;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		taunt = new HagletResettable(TauntRoutine(), owner.charData.charName + " Taunt");
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		Routine.Start(taunt, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> TauntRoutine()
	{
		Ability_Taunt_Proxy tauntProxy2 = null;
		tauntProxy2 = ((!target.abilities.Exists<Ability_Taunt_Proxy>()) ? target.abilities.Add<Ability_Taunt_Proxy>(this, isUpgraded: false) : target.abilities.AbilityGetByType<Ability_Taunt_Proxy>());
		tauntProxy2.target = owner;
		PlayParticles(owner);
		yield return Wait.Until(owner.unitModel.Play(GetAbilityAnimationName()));
		owner.UpdateIdleAnim();
	}
}
[Serializable]
public class Ability_Taunt_Proxy : AbilityImplBase
{
	public Unit target;

	private ConstArray<v2i> rangedCoords;

	private NC.Path movePath;

	private HagletResettable tauntRoutine;

	private NC.Path scratchPath;

	private Area scratchArea;

	private ParticlePrefab pp;

	private NC.PathingCellValidator runToPathValidator;

	public Ability_Taunt_Proxy()
	{
		v2i maxMapSize = Map.maxMapSize;
		int x = maxMapSize.x;
		v2i maxMapSize2 = Map.maxMapSize;
		rangedCoords = new ConstArray<v2i>((uint)(x * maxMapSize2.y));
		scratchArea = new Area();
		base..ctor();
		runToPathValidator = RunToPathValidator;
		tauntRoutine = new HagletResettable(TauntProxyRoutine(), "Ability_Taunt_Proxy", HagletStepTime.Update, -1, 1);
	}

	public void StartEffect(Unit unit)
	{
		if (!pp)
		{
			pp = PlayParticles(owner, owner.unitModel.AnimCompTransform);
		}
	}

	public void StopEffect()
	{
		if ((bool)pp)
		{
			pp.StopParticles();
			pp = null;
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (!target.IsAlive())
		{
			owner.abilities.Remove(this);
		}
		else
		{
			Routine.Start(tauntRoutine, MR.Inst.Host, MR.Inst.mainHagisSequence);
		}
	}

	private bool CanAttack()
	{
		return owner.AP > 0 && ((!owner.mainWeapon.IsRanged) ? v2i.IsNeighbour(owner.coord, target.coord) : owner.map.HasLineOfSight(owner.coord, target.coord, isSideStepAllowed: true));
	}

	private HagletYieldTerm PerformAttack()
	{
		Unit unit = owner;
		Unit unit2 = target;
		WeaponAttributes mainWeapon = owner.mainWeapon;
		Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(unit2, mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, minigame);
		return Wait.ForChildren;
	}

	private bool RunToPathValidator(v2i coord)
	{
		return coord == target.coord || !v2i.IsNeighbour(coord, target.coord) || GC.Inst.GetUnitAtCoord(coord) == null;
	}

	private int GetCost(v2i coord)
	{
		int cost = scratchArea.GetCost(coord);
		int movementDistancePerTurn = owner.GetMovementDistancePerTurn();
		return cost / movementDistancePerTurn + ((cost % movementDistancePerTurn > 0) ? 1 : 0);
	}

	private IEnumerator<HagletYieldTerm> TauntProxyRoutine()
	{
		yield return PlayAbilityEffects("STATUSEFFECT_Taunted_NAME_L", playSound: false);
		WeaponAttributes weapon = owner.mainWeapon;
		if (CanAttack())
		{
			yield return PerformAttack();
		}
		else if (owner.IsMovementDisabled)
		{
			owner.popupBar.Enqueue("ABILITYWHEELDISABLED_REQMOVEMENT");
			owner.APDecrement(owner.AP);
		}
		else
		{
			scratchArea.startCoord = owner.coord;
			scratchArea.map = owner.map;
			scratchArea.range = owner.GetMovementDistancePerTurn() * owner.GetAPMax();
			scratchArea.includePathing = true;
			scratchArea.allowVaults = owner.IsVaultAllowed;
			yield return Wait.While(NC.Inst.CalculateArea(scratchArea));
			if (weapon.IsRanged)
			{
				rangedCoords.Clear();
				int lowestApCost = int.MaxValue;
				v2i start = scratchArea.startCoord;
				v2i maxMapSize = Map.maxMapSize;
				int maxX = Mathf.Min(maxMapSize.x - 1, start.x + scratchArea.range);
				v2i maxMapSize2 = Map.maxMapSize;
				int maxY = Mathf.Min(maxMapSize2.y - 1, start.y + scratchArea.range);
				for (int i = Mathf.Max(0, start.x - scratchArea.range); i <= maxX; i++)
				{
					for (int j = Mathf.Max(0, start.y - scratchArea.range); j <= maxY; j++)
					{
						v2i v2i2 = new v2i(i, j);
						int cost2 = GetCost(v2i2);
						if (cost2 < owner.GetAPMax() && owner.map.HasLineOfSight(v2i2, target.coord, isSideStepAllowed: true) && GC.Inst.GetUnitAtCoord(v2i2) == null)
						{
							lowestApCost = Math.Min(cost2, lowestApCost);
							rangedCoords.Add(v2i2);
						}
					}
				}
				if (rangedCoords.Length != 0)
				{
					v2i moveCoord = v2i.zero;
					float bestHitChance = 0f;
					for (int k = 0; k < rangedCoords.Length; k++)
					{
						if (GetCost(rangedCoords[k]) == lowestApCost)
						{
							int hitChance = owner.GetHitChance(rangedCoords[k], target, weapon, reactionAttack: false, isCombatCalculation: false);
							if ((float)hitChance > bestHitChance)
							{
								bestHitChance = hitChance;
								moveCoord = rangedCoords[k];
							}
						}
					}
					owner.APDecrement(GetCost(moveCoord));
					owner.StartMovement(moveCoord);
					yield return Wait.ForChildren;
					if (owner.IsAlive() && target.IsAlive())
					{
						yield return null;
						yield return PerformAttack();
					}
					goto IL_07f9;
				}
			}
			yield return Wait.While(NC.Inst.CalculatePath(owner, target.coord, includeObservedTiles: true, OnPathCalculationComplete, owner.IsVaultAllowed, ignoreUnitAtDestination: true, runToPathValidator));
			List<Vector3> pathPoints = movePath.positions;
			int pointCount = pathPoints.Count - 1;
			for (int pointI = pointCount - 1; pointI > 1; pointI--)
			{
				v2i pathCoord = owner.map.LocalPosToCoord(pathPoints[pointI]);
				int cost = GetCost(pathCoord);
				if (cost <= owner.GetAPMax() && GC.Inst.GetUnitAtCoord(pathCoord) == null)
				{
					owner.APDecrement(cost);
					owner.StartMovement(pathCoord);
					yield return Wait.ForChildren;
					if (owner.IsAlive() && target.IsAlive() && CanAttack())
					{
						yield return null;
						yield return PerformAttack();
					}
					break;
				}
			}
		}
		goto IL_07f9;
		IL_07f9:
		owner.abilities.Remove(this);
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		owner.abilities.Remove(this);
	}

	private void OnPathCalculationComplete(NC.Path path, Unit unitAssociated)
	{
		movePath = path;
	}

	public override void OnUnitMapTransitionBegin(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override void OnOtherUnitMapTransitionBegin(Unit unit, Unit other)
	{
		if (other == target)
		{
			unit.abilities.Remove(this);
		}
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		StartEffect(owner);
		target = null;
	}

	public override void OnAbilityUncasted()
	{
		StopEffect();
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.Taunted, this, 1));
	}
}
[Serializable]
public class Ability_Endurance : AbilityImplBase
{
	private const int kChanceToEndure = 35;

	private bool endure;

	public override void OnUnitAttackedBegin(Unit unit, Unit attacker, WeaponAttributes attackerWeapon, bool reactionAttack)
	{
		endure = base.IsUpgraded || 35.PercentChance();
		if (endure)
		{
			PlayParticles(unit);
		}
	}

	public override int OnUnitWillBeDamaged(Unit unit, int damage, Unit attacker, Combat.HitType hitType)
	{
		if (endure)
		{
			owner.popupBar.Enqueue("POPUPBAR_UNITATTACK_ENDURED");
			return Mathf.Clamp(damage - 1, 0, int.MaxValue);
		}
		return damage;
	}
}
[Serializable]
public class Ability_Metabolism : AbilityImplBase
{
	private const int kRestoreHP = -1;

	private const int kUpgradedRestoreHP = -2;

	private bool attackedThisTurn;

	private bool restoreHP;

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (restoreHP)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_METABOLISM");
			PlayParticles(unit);
			unit.HPDecrement((!base.IsUpgraded) ? (-1) : (-2), null, null, Combat.HitType.Hit, notifyAbilites: false);
			restoreHP = false;
		}
		attackedThisTurn = false;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		attackedThisTurn = true;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (!attackedThisTurn)
		{
			restoreHP = true;
		}
	}
}
[Serializable]
public class Ability_Grab : AbilityImplBase
{
	private Unit target;

	private Ability_Stunned_Proxy proxySelf;

	private Ability_Stunned_Proxy proxyTarget;

	private const int kGrabStunTurns = 3;

	private const int kGrabStunTurnsUpgraded = 5;

	private HagletResettable grabTarget;

	private HagletResettable releaseGrabbedTarget;

	private bool releasingByBeingHit;

	private Unit releasingTarget;

	private ParticlePrefab pp_graber;

	private ParticlePrefab pp_grabie;

	public override int APCost(Unit unit)
	{
		return Mathf.Max(unit.AP, 1);
	}

	public override int CooldownMax()
	{
		return 4;
	}

	public override int SelectionRange(Unit unit)
	{
		return 1;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool IsManualHitAnimation()
	{
		return target != null;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		grabTarget = new HagletResettable(GrabTargetRoutine(), owner.name + " grabbing Target");
		releaseGrabbedTarget = new HagletResettable(ReleaseGrabbedTargetRoutine(), owner.name + " release grabbed Target");
	}

	private void PlayEffect(Unit unit, Unit target)
	{
		if (!pp_graber && !pp_grabie)
		{
			pp_graber = PlayParticles(unit);
			pp_grabie = PlayParticles(target);
		}
	}

	private void StopEffect()
	{
		if ((bool)pp_graber && (bool)pp_grabie)
		{
			pp_graber.StopParticles();
			pp_grabie.StopParticles();
		}
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (contextToFill != null && target != null)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_ALREADYGRAB");
			return AbilityWheelVisibility.Disabled;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		uint num = 0u;
		for (uint length = unitsActive.Length; num < length; num++)
		{
			Unit unit2 = unitsActive[num];
			if (unit2.teamType != unit.teamType && unit2.teamType != UnitTeam.Type.NPC && v2i.Distance(unit2.coord, unit.coord) < 1.5f)
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		if ((bool)contextToFill)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_ENEMYNOTINRANGE");
		}
		return AbilityWheelVisibility.Disabled;
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (!base.IsUpgraded)
		{
			ReleaseGrabbedTarget(releaseByBeingHit: true);
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		ReleaseGrabbedTarget(releaseByBeingHit: true);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		ReleaseGrabbedTarget(releaseByBeingHit: false);
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (target != null)
		{
			if (!target.HPDecrement(1, unit))
			{
				ReleaseGrabbedTarget(releaseByBeingHit: false);
			}
			else
			{
				PlayAbilityEffects();
			}
		}
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		Routine.Start(grabTarget, MR.Inst.Host);
	}

	public void ReleaseGrabbedTarget(bool releaseByBeingHit)
	{
		if (!(target == null))
		{
			releasingByBeingHit = releaseByBeingHit;
			releasingTarget = target;
			target = null;
			Routine.Start(releaseGrabbedTarget, MR.Inst.Host);
		}
	}

	private IEnumerator<HagletYieldTerm> GrabTargetRoutine()
	{
		int grabStunTurns = ((!base.IsUpgraded) ? 3 : 5);
		proxySelf = owner.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
		proxySelf.showStunnedBanner = false;
		proxySelf.playAnimation = false;
		proxySelf.playParticle = false;
		proxySelf.duration = grabStunTurns;
		proxySelf.showStatusEffect = false;
		target.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatCrouch");
		target.unitModel.SetAnimOverride(UnitModel.AnimID.TransCCrouchToCIdle, "CombatCrouch");
		target.unitModel.SetAnimOverride(UnitModel.AnimID.TransCIdleToCCrouch, "CombatCrouch");
		target.UpdateIdleAnim();
		int attacks = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>("TransCIdleToGIdle");
		HagletTrigger animComplete = owner.unitModel.Play("TransCIdleToGIdle", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		if (attacks > 0)
		{
			yield return owner.WaitForAttackAnimEvent();
		}
		else
		{
			yield return animComplete;
		}
		owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "AbilityGrab");
		owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "AbilityGrab");
		owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatHit, "AbilityGrabHit");
		owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchHit, "AbilityGrabHit");
		target.popupBar.Enqueue("POPUPBAR_ABILITY_GRAB_GRABBED");
		proxyTarget = target.abilities.Add<Ability_Grab_Proxy>(this, isUpgraded: false);
		proxyTarget.duration = grabStunTurns;
		proxyTarget.playAnimation = false;
		PlayEffect(owner, target);
	}

	private IEnumerator<HagletYieldTerm> ReleaseGrabbedTargetRoutine()
	{
		yield return Wait.ForSteps(3uL);
		owner.abilities.Remove(proxySelf);
		releasingTarget.abilities.Remove(proxyTarget);
		proxySelf = null;
		proxyTarget = null;
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHit);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouchHit);
		releasingTarget.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		releasingTarget.unitModel.ClearAnimOverride(UnitModel.AnimID.TransCCrouchToCIdle);
		releasingTarget.unitModel.ClearAnimOverride(UnitModel.AnimID.TransCIdleToCCrouch);
		releasingTarget.UpdateIdleAnim();
		StopEffect();
		if (releasingTarget.IsAlive())
		{
			releasingTarget.popupBar.Enqueue("POPUPBAR_ABILITY_GRAB_RELEASED");
		}
		if (releasingTarget.IsAlive() && GC.Inst.GetActiveTeamType() == releasingTarget.teamType)
		{
			releasingTarget.APRefill();
		}
		if (owner.IsAlive())
		{
			owner.unitModel.Play("TransGIdleToCIdle", looping: false, crouched: false, interacting: true, updateIdleOnComplete: true);
		}
		if (releasingTarget == SC.Inst.GetLeader())
		{
			releasingTarget.ShowMovementArea();
			SC.Inst.SetRangeFromLeader((releasingTarget.AP > 0) ? releasingTarget.GetMovementDistancePerTurn() : 0, rangeRequiresPathing: true);
			SC.Inst.SetShowPath(showPath: true);
			SC.Inst.SetVaultAllowed(releasingTarget.IsVaultAllowed);
		}
	}
}
[Serializable]
internal class Ability_Grab_Proxy : Ability_Stunned_Proxy
{
	public Ability_Grab_Proxy()
	{
		showStunnedBanner = false;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		base.OnUnitTurnBegin(unit);
		if (duration <= 0)
		{
			((Ability_Grab)caster).ReleaseGrabbedTarget(releaseByBeingHit: false);
		}
	}

	public override void OnUnitChangedTeam(Unit unit, UnitTeam.Type teamType)
	{
		((Ability_Grab)caster).ReleaseGrabbedTarget(releaseByBeingHit: false);
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		base.OnUnitTurnEnd(unit, isCombatEnd);
		if (duration <= 0)
		{
			((Ability_Grab)caster).ReleaseGrabbedTarget(releaseByBeingHit: false);
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		base.OnUnitDeathComplete(unit);
		((Ability_Grab)caster).ReleaseGrabbedTarget(releaseByBeingHit: false);
	}
}
[Serializable]
public class Ability_Ground_Pound : AbilityImplBase
{
	private const int kDamageMod = 2;

	private const float kAOERange = 2f;

	private const float kAOERangeUpgraded = 3f;

	private bool jumping;

	private v2i groundPoundTarget;

	private HagletResettable startGroundPound;

	private HagletResettable endGroundPound;

	private ConstArray<Unit> targets = new ConstArray<Unit>(32u);

	public bool IsJumping => jumping;

	public v2i GroundPoundTarget => groundPoundTarget;

	private float AOERadius => (!base.IsUpgraded) ? 2f : 3f;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		startGroundPound = new HagletResettable(StartGroundPoundRoutine(), "Start Ground Pound");
		endGroundPound = new HagletResettable(EndGroundPoundRoutine(), "End Ground Pound");
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override int APCost(Unit unit)
	{
		return Mathf.Max(unit.AP, 2);
	}

	public override int CooldownMax()
	{
		return 4;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return AOERadius;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override bool RequiresMovement()
	{
		return true;
	}

	public override bool GetUnitAttackingDisabled(Unit unit)
	{
		return jumping;
	}

	public override bool GetUnitMovementDisabled(Unit unit)
	{
		return jumping;
	}

	public override bool GetUnitTargetable(Unit unit)
	{
		return !jumping;
	}

	public override VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		if (centerCoord == coord)
		{
			Unit unitAtCoord = GC.Inst.GetUnitAtCoord(coord);
			if (unitAtCoord != null && unitAtCoord != owner)
			{
				return VFXTileController.TileType.AreaSelectionUnitAttack;
			}
			return VFXTileController.TileType.AreaSelectionUnit;
		}
		return VFXTileController.TileType.AreaSelectionOffensive;
	}

	private IEnumerator<HagletYieldTerm> StartGroundPoundRoutine()
	{
		owner.OnExitTile();
		jumping = true;
		owner.APDecrement(owner.AP);
		owner.unitModel.Play("AbilityGroundPoundStart");
		yield return Wait.ForSeconds(0.5f);
		AC.Inst.PlayOneShot3D("event:/sfx/ability/ground pound take off", owner._GetTransform().position);
		owner.StartTeleport(groundPoundTarget, null, null, manuallyHandleShowing: true, deactivateForTeleport: false, lookAtDest: false, null, null, null, ignoreAnimation: true);
		yield return Wait.ForChildren;
		yield return owner.SetCoord(-v2i.one);
	}

	private IEnumerator<HagletYieldTerm> EndGroundPoundRoutine()
	{
		Unit unitOnLandingCoord = GC.Inst.GetUnitAtCoord(groundPoundTarget);
		owner.SetCoord(groundPoundTarget);
		jumping = false;
		owner.unitModel.PlayAndReturnToIdle("AbilityGroundPoundEnd");
		owner.Show(null, Unit.HologramAnim.DEFAULT, updateIdleAnim: false);
		yield return Wait.ForSeconds(0.5f);
		PlayParticles(owner);
		Singleton<MC>.Inst.MapShake.ShakeOneShot(0.5f, 0.025f);
		AC.Inst.PlayOneShot3D("event:/sfx/ability/ground pound impact", owner._GetTransform().position);
		owner.APDecrement(Mathf.Max(owner.AP - 1, 0));
		Unit.GatherUnitsInRadius(owner.coord, AOERadius, targets);
		int damage = CharacterStats.LUT_WeaponBaseDamageMelee[owner.ClassID, owner.Level] + 2;
		int num = targets.sLength;
		while (--num >= 0)
		{
			if (!(targets[num] == owner))
			{
				owner.DamageAttackTarget(targets[num], Combat.HitType.Hit, damage);
			}
		}
		if (unitOnLandingCoord != null && unitOnLandingCoord != owner)
		{
			unitOnLandingCoord.StartShove(OctDir.Up, 1, Combat.HitType.Miss, 10f, mustMove: true);
		}
		owner.Area.Update(owner.map, owner.coord, owner.GetMovementDistancePerTurn(), newIncludePathing: true, showArea: false, owner.IsVaultAllowed);
		yield return Wait.ForSeconds(1.5f);
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		if (!jumping)
		{
			groundPoundTarget = selection[0];
			Routine.Start(startGroundPound, MR.Inst.Host);
		}
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		if (!jumping)
		{
			groundPoundTarget = selection[0].coord;
			Routine.Start(startGroundPound, MR.Inst.Host);
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (jumping)
		{
			Routine.Start(endGroundPound, MR.Inst.Host);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		if (jumping)
		{
			Routine.Start(endGroundPound, MR.Inst.Host);
		}
	}
}
[Serializable]
public class Ability_Plant : AbilityImplBase
{
	private const float kOwnerAccuracyDebuff = 0.2f;

	private const float kOwnerAccuracyDebuffUpgraded = 0f;

	private const int kOwnerDamageReductionBuff = 1;

	private const float kTeammateAccuracyBuff = -0.2f;

	private readonly string kMsgOwnerDamageReduction = "Plant Damage -" + 1;

	private readonly string kMsgOwnerUnplanted = "Unplanted";

	private bool planted;

	private ParticlePrefab pp;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		if (!planted)
		{
			return 0f;
		}
		if (target == owner)
		{
			return (!base.IsUpgraded) ? 0.2f : 0f;
		}
		if (v2i.IsNeighbour(targetCoord, owner.coord))
		{
			return -0.2f;
		}
		return 0f;
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (planted && unit == owner)
		{
			StopEffect();
			planted = false;
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_PLANT_UNPLANTED");
		}
	}

	public override int OnUnitWillBeDamaged(Unit unit, int damage, Unit attacker, Combat.HitType hitType)
	{
		if (planted && unit == owner)
		{
			return Mathf.Max(damage - 1, 0);
		}
		return damage;
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		planted = true;
		PlayEffect(unit);
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (planted && unit == owner)
		{
			if (!base.IsUpgraded && (barData.whamState & WhamStates.Graze) != 0)
			{
				barData.whamState &= (WhamStates)(-9);
			}
			if ((barData.whamState & WhamStates.Dodge) != 0)
			{
				barData.whamState &= (WhamStates)(-5);
			}
			if ((barData.whamState & WhamStates.Hit) != 0)
			{
				barData.whamState &= (WhamStates)(-2);
			}
			if (!base.IsUpgraded)
			{
				float num = barData.GetBarSizeValue(BarTypes.Crit) * 1.5f;
				float newVal = Mathf.Min(barData.GetBarPositionValue(BarTypes.Crit), 1f - num);
				barData.SetBarSizeValue(BarTypes.Crit, num);
				barData.SetBarPositionValue(BarTypes.Crit, newVal);
			}
		}
	}

	public override bool GetUnitMovementDisabled(Unit unit)
	{
		return planted && owner == unit;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool IsTeamAbility()
	{
		return true;
	}

	public override int APCost(Unit unit)
	{
		return Mathf.Max(unit.AP, 1);
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public void PlayEffect(Unit unit)
	{
		if (!pp)
		{
			pp = PlayParticles(unit);
		}
	}

	public void StopEffect()
	{
		if ((bool)pp)
		{
			pp.StopParticles();
			pp = null;
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		planted = false;
		StopEffect();
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		planted = false;
		StopEffect();
	}
}
[Serializable]
public class Ability_Hitback : AbilityImplBase
{
	private bool hitByAdjacent;

	private bool usedThisTurn;

	private HagletResettable hitbackRoutine;

	private Unit hitbackRoutineTarget;

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (v2i.IsNeighbour(unit.coord, attacker.coord))
		{
			hitByAdjacent = true;
		}
	}

	public override void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
		if (!usedThisTurn && hitByAdjacent && !reactionAttack && unit.IsAlive() && hitType != Combat.HitType.Dodged)
		{
			hitByAdjacent = false;
			usedThisTurn = true;
			hitbackRoutineTarget = attacker;
			Routine.Start(hitbackRoutine, MR.Inst.Host);
		}
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		hitByAdjacent = false;
		usedThisTurn = false;
	}

	private IEnumerator<HagletYieldTerm> HitbackRoutine()
	{
		Unit target = hitbackRoutineTarget;
		hitbackRoutineTarget = null;
		int targetHealthBeforeAttack = target.HP;
		PlayParticles(owner);
		Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		bool result = !target.IsCloaked && owner.StartAttack(target, owner.MeleeWeapon, costsAP: false, Unit.IfTooFar.InvalidateAction, null, isReactionAttack: true, isAbilityAttack: true, null, 1, minigame);
		yield return Wait.ForChildren;
		if (base.IsUpgraded && target.HP < targetHealthBeforeAttack)
		{
			target.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			owner.popupBar.Enqueue("POPUPBAR_ABILITY_HITBACK_PLUS");
		}
		else
		{
			owner.popupBar.Enqueue("POPUPBAR_ABILITY_HITBACK");
		}
	}

	public override void OnUnitSpawn(Unit unit)
	{
		hitbackRoutine = new HagletResettable(HitbackRoutine(), "Hitback Routine " + unit.charData.charName);
	}

	public override bool RequiresAttack()
	{
		return true;
	}
}
[Serializable]
public class Ability_Shove : AbilityImplBase
{
	private const int kShoveDist = 2;

	private const int kUpgradedShoveDist = 3;

	private const int kHitObstructionDamage = 1;

	private const int kUpgradedHitObstructionStunChance = 50;

	private HagletResettable shove;

	private Unit shoveTarget;

	private ConstArray<Combat.CombatData> data = new ConstArray<Combat.CombatData>(1u);

	public int ShoveDist => (!base.IsUpgraded) ? 2 : 3;

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override int SelectionRange(Unit unit)
	{
		return 1;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		shove = new HagletResettable(ShoveRoutine(), "Shove");
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		shoveTarget = selection[0];
		Routine.Start(shove, MR.Inst.Host);
	}

	public IEnumerator<HagletYieldTerm> ShoveRoutine()
	{
		Unit.Shove.Result shoveResult = new Unit.Shove.Result();
		yield return Routine.ResetToHere();
		OctDir shoveDir = (shoveTarget.GetPositionWS() - owner.GetPositionWS()).ToSimpleDirXZ();
		Combat.CombatData shoveData = default(Combat.CombatData);
		Combat.CombatMinigame minigame = ((shoveTarget.teamType != 0) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		shoveData.hitChance = 30;
		shoveData.critChance = 0;
		shoveData.dodgeChance = shoveTarget.GetDodgeChance(owner);
		shoveData.critSize = 0;
		shoveData.dodgeSize = shoveTarget.GetDodgeSize(owner);
		shoveData.whamState = owner.GetDefaultWhamState(minigame, shoveData, shoveTarget);
		shoveData.attacker = owner;
		shoveData.target = shoveTarget;
		shoveData.weapon = owner.MeleeWeapon;
		shoveData.additionalEffect = Combat.HitType.None;
		data.Clear();
		data.Add(shoveData);
		yield return UIWhamBar.Inst.StartWhamBar(minigame, data, isReaction: false);
		HagletEvent attackanim = owner.unitModel.Play(UnitModel.AnimID.CombatAttackMelee, null, updateIdleOnComplete: true);
		yield return owner.WaitForAttackAnimEvent();
		owner.unitModel.LookAtDirectionLS(shoveDir.ToV3XZ());
		if (data[0].hitType == Combat.HitType.Miss)
		{
			shoveTarget.popupBar.Enqueue("POPUPBAR_ABILITY_SHOVE_MISSED");
			yield break;
		}
		shoveTarget.StartShove(shoveDir, ShoveDist, data[0].hitType, 10f, mustMove: false, shoveResult, owner);
		yield return Wait.ForChildren;
		if (shoveResult.value == Unit.Shove.ResultEnum.UnitHitObstruction)
		{
			if (base.IsUpgraded && 50.PercentChance())
			{
				shoveTarget.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			}
			shoveTarget.HPDecrement(1, owner);
			PlayParticles(shoveTarget);
		}
		if (owner.unitModel.currentClip.name == owner.unitModel.GetAnimName(UnitModel.AnimID.CombatAttackMelee))
		{
			yield return owner.unitModel.OnAnimComplete;
		}
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_Rebound : AbilityImplBase
{
	private bool BATTTTTEERRRUPPPP;

	public override void OnUnitAttackedBegin(Unit unit, Unit attacker, WeaponAttributes attackerWeapon, bool reactionAttack)
	{
		bool isRanged = attackerWeapon.IsRanged;
		CoverType coverBetween = unit.map.GetCoverBetween(attacker.coord, unit.coord);
		bool flag = !v2i.IsNeighbour(unit.coord, attacker.coord);
		bool flag2 = coverBetween.Is(CoverType.Flanked) || coverBetween.Is(CoverType.None);
		BATTTTTEERRRUPPPP = base.IsUpgraded || (isRanged && flag && flag2);
		if (BATTTTTEERRRUPPPP)
		{
			PlayParticles(unit);
		}
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (BATTTTTEERRRUPPPP)
		{
			float barSizeValue = barData.GetBarSizeValue(BarTypes.Dodge);
			float num = 0f;
			num = ((!base.IsUpgraded) ? UnityEngine.Random.Range(0f, 1f - barSizeValue) : barData.GetBarPositionValue(BarTypes.Dodge));
			barData.whamState |= WhamStates.Reflect;
			barData.SetBarSizeValue(BarTypes.Reflect, barSizeValue);
			barData.SetBarPositionValue(BarTypes.Reflect, num);
			barData.SetBarOverlay(BarTypes.Reflect, Overlay: true);
		}
	}
}
[Serializable]
public class Ability_Break : AbilityImplBase
{
	private Unit target;

	private Unit attacker;

	private bool HACK_AIActiveOverride;

	private bool broken;

	private ConstArray<Combat.CombatData> data = new ConstArray<Combat.CombatData>(1u);

	private HagletResettable breakRoutine;

	private bool breaking => (bool)breakRoutine.running || breakRoutine.markedToRunBy != null;

	public override int APCost(Unit unit)
	{
		return 2;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return selection.charData.hackable;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		breakRoutine = new HagletResettable(BreakRoutine(), "Vault Kick");
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit2 = unitsActive[i];
			if (unit2.teamType != unit.teamType && unit2.charData.hackable)
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		return AbilityWheelVisibility.Disabled;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		attacker = unit;
		target = selection[0];
		Routine.Start(breakRoutine, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> BreakRoutine()
	{
		HACK_AIActiveOverride = true;
		Combat.CombatData statusData = default(Combat.CombatData);
		statusData.additionalEffect = Combat.HitType.None;
		Combat.CombatMinigame combatMinigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		statusData.hitChance = owner.GetHitChance(owner.coord, target, owner.mainWeapon, reactionAttack: false, isCombatCalculation: true);
		statusData.critChance = owner.GetCriticalHitChance(target, owner.mainWeapon, isCombatCalculation: true);
		statusData.dodgeChance = target.GetDodgeChance(owner);
		statusData.critSize = owner.GetCriticalHitSize(target, owner.mainWeapon, isCombatCalculation: true);
		statusData.dodgeSize = target.GetDodgeSize(owner);
		statusData.whamState = owner.GetDefaultWhamState(combatMinigame, statusData, target);
		statusData.attacker = owner;
		statusData.target = target;
		data.Clear();
		data.Add(statusData);
		UnitModel unitModel = attacker.unitModel;
		string abilityAnimationName = GetAbilityAnimationName();
		bool crouched = attacker.unitModel.crouched;
		yield return unitModel.Play(abilityAnimationName, looping: false, crouched, interacting: false, updateIdleOnComplete: true);
		yield return UIWhamBar.Inst.StartWhamBar(combatMinigame, data, isReaction: false);
		if ((owner.teamType == UnitTeam.Type.Player && data[0].hitType == Combat.HitType.Status) || (owner.teamType == UnitTeam.Type.Enemy && data[0].hitType != Combat.HitType.Dodged))
		{
			target.popupBar.Enqueue("POPUPBAR_ABILITY_BREAK");
			if (target.GetTeam().GetActiveMembers().Length <= 1 && target.GetTeamType() != UnitTeam.Type.NPC)
			{
				target.HPDecrement(target.HP, owner, null, Combat.HitType.Hit, notifyAbilites: false);
			}
			else
			{
				Ability_Break_Proxy ability_Break_Proxy = target.abilities.AbilityGetByType<Ability_Break_Proxy>();
				if (ability_Break_Proxy != null)
				{
					ability_Break_Proxy.RemoveProxy(target);
				}
				else
				{
					Ability_Break_Proxy ability_Break_Proxy2 = target.abilities.Add<Ability_Break_Proxy>(this, isUpgraded: false);
					ability_Break_Proxy2.turnCounter = ((!base.IsUpgraded) ? 2 : int.MaxValue);
					ability_Break_Proxy2.originalTeamType = target.teamType;
					target.SetTeamType(attacker.teamType);
					target.APRefill();
					target.unitModel.Play(UnitModel.AnimID.CombatHacked, null, updateIdleOnComplete: true);
				}
			}
			PlayParticles(target);
		}
		else
		{
			target.popupBar.Enqueue("POPUPBAR_ABILITY_BREAK_MISSED");
		}
		HACK_AIActiveOverride = false;
	}

	public override void ApplyAttackerDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (isActive || HACK_AIActiveOverride)
		{
			barData.whamState = WhamStates.Dodge;
		}
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (isActive || HACK_AIActiveOverride)
		{
			float barPositionValue = barData.GetBarPositionValue(BarTypes.Hit);
			float barSizeValue = barData.GetBarSizeValue(BarTypes.Hit);
			barData.ResetValues();
			barData.whamState = WhamStates.Status;
			barData.SetBarPositionValue(BarTypes.Status, barPositionValue);
			barData.SetBarSizeValue(BarTypes.Status, barSizeValue);
			barData.SetSpriteOverride(BarTypes.Status, meta.overrideSprite);
		}
	}

	public override string OverrideWhamResultText(Unit unit, UIWhamBar.WhamResult result, string orginal)
	{
		return (!breaking || result != UIWhamBar.WhamResult.Status) ? orginal : meta.GetDisplayName(owner.charData);
	}
}
[Serializable]
public class Ability_Break_Proxy : AbilityImplBase
{
	public UnitTeam.Type originalTeamType;

	public int turnCounter;

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (turnCounter != int.MaxValue)
		{
			turnCounter--;
		}
		if (turnCounter <= 0)
		{
			RemoveProxy(unit);
		}
	}

	public override void OnAbilityCasted()
	{
		turnCounter = 0;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		RemoveProxy(unit);
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		RemoveProxy(unit);
	}

	public void RemoveProxy(Unit unit)
	{
		if (originalTeamType != UnitTeam.Type.NPC && GC.Inst.GetTeamOfType(originalTeamType).GetActiveMembers().Length == 0)
		{
			owner.HPDecrement(owner.HP, caster.owner, null, Combat.HitType.Hit, notifyAbilites: false);
		}
		turnCounter = 0;
		unit.SetTeamType(originalTeamType);
		unit.abilities.Remove(this);
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.Overridden, this, turnCounter));
	}
}
[Serializable]
public class Ability_Backup_Proxy : AbilityImplBase
{
	public const int kDodgeModifier = 30;

	public bool upgraded;

	public override void OnUnitTurnBegin(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return 30;
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (upgraded)
		{
			if ((barData.whamState & WhamStates.Crit) != 0)
			{
				barData.whamState &= (WhamStates)(-3);
			}
			barData.defaultResult = UIWhamBar.WhamResult.Hit;
		}
	}
}
[Serializable]
public class Ability_Backup : AbilityImplBase
{
	private HagletResettable backupRoutine;

	private Unit target;

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return unit.teamMask;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionIncludeSelf(Unit unit)
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		backupRoutine = new HagletResettable(BackupRoutine());
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		Routine.Start(backupRoutine);
	}

	public IEnumerator<HagletYieldTerm> BackupRoutine()
	{
		PlayParticles(target);
		Ability_Backup_Proxy proxy = target.abilities.Add<Ability_Backup_Proxy>(this, isUpgraded: false);
		proxy.upgraded = base.IsUpgraded;
		yield return owner.unitModel.Play(GetAbilityAnimationName(), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
	}
}
[Serializable]
public class Ability_Disrupt : AbilityImplBase
{
	private DisruptImpl disruptImpl;

	private Unit target;

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		for (int i = 0; i < GC.Inst.GetUnitsActive().Length; i++)
		{
			Unit unit2 = GC.Inst.GetUnitsActive()[i];
			if (unit2.teamType != unit.teamType && unit.map.HasLineOfSight(unit.coord, unit2.coord, isSideStepAllowed: false) && unit2.abilities.GetActiveManualAbilityCount() > 0)
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		if ((bool)contextToFill)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_NOABILITYTARGETS");
		}
		return AbilityWheelVisibility.Disabled;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return selection.abilities.GetActiveManualAbilityCount() > 0;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		disruptImpl = new DisruptImpl();
		disruptImpl.Allocate();
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		disruptImpl.StartDisrupt(this, target, base.IsUpgraded);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
public class DisruptImpl
{
	private HagletResettable disruptResettable;

	private HagletResettable applyRandomAbility;

	private Wrapper<Type> typeWrapper = new Wrapper<Type>(null);

	private ConstArray<AbilityImplBase> abilityScratchSpace;

	private AbilityImplBase caster;

	private Unit target;

	private bool isUpgraded;

	public void Allocate()
	{
		disruptResettable = new HagletResettable(AbilityRoutine(), "Disrupt Routine");
		applyRandomAbility = new HagletResettable(ApplyRandomAbility(), "Apply Random Ability");
		abilityScratchSpace = new ConstArray<AbilityImplBase>(16u);
	}

	public void StartDisrupt(AbilityImplBase caster, Unit target, bool isUpgraded)
	{
		this.caster = caster;
		this.target = target;
		this.isUpgraded = isUpgraded;
		Routine.Start(disruptResettable, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> AbilityRoutine()
	{
		AbilityMeta meta = caster.meta;
		Unit owner = caster.owner;
		abilityScratchSpace.Clear();
		uint num = target.abilities.AbilityGetCount();
		for (int i = 0; i < num; i++)
		{
			AbilityImplBase abilityImplBase = target.abilities.AbilityGetByIndex(i);
			if (abilityImplBase.IsManuallyActivated() && !abilityImplBase.IsProxyAbility() && abilityImplBase.Enabled && abilityImplBase.GetType() != typeof(Ability_Combat_Medic_Small))
			{
				abilityScratchSpace.Add(target.abilities.AbilityGetByIndex(i));
			}
		}
		yield return owner.StartAttackAnimationWithAttackEvent(caster.GetAbilityAnimationName());
		ParticleBullet particle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, target.map, target.coord);
		yield return Wait.While(particle.AnimateToTarget(owner, target, Combat.HitType.Hit));
		yield return Routine.Start(applyRandomAbility, MR.Inst.Host, MR.Inst.mainHagisSequence);
		if (isUpgraded)
		{
			yield return Routine.Start(applyRandomAbility, MR.Inst.Host, MR.Inst.mainHagisSequence);
		}
		caster.PlayParticles(target);
		target.Hit();
		yield return null;
	}

	private IEnumerator<HagletYieldTerm> ApplyRandomAbility()
	{
		if (abilityScratchSpace.Length == 0)
		{
			target.popupBar.Enqueue("POPUPBAR_ABILITY_DISRUPT_NOMORE");
			yield break;
		}
		uint abilityIdx = 0u;
		if (target.teamType == UnitTeam.Type.Player)
		{
			abilityIdx = (uint)UnityEngine.Random.Range(0, (int)abilityScratchSpace.Length);
		}
		else
		{
			UISlotChamp.Inst.Clear();
			for (int i = 0; i < 10; i++)
			{
				AbilityImplBase abilityImplBase = abilityScratchSpace[i % (int)abilityScratchSpace.Length];
				UISlotChamp.Inst.AddEffect(abilityImplBase.GetType(), 1);
			}
			yield return UISlotChamp.Inst.ShowSlotChamp(caster, typeWrapper);
			for (uint num = 0u; num < abilityScratchSpace.Length; num++)
			{
				if (abilityScratchSpace[num].GetType() == typeWrapper.val)
				{
					abilityIdx = num;
					break;
				}
			}
		}
		Ability_Disrupt_Proxy proxy = target.abilities.Add<Ability_Disrupt_Proxy>(caster, isUpgraded: false);
		proxy.disabledAbility = abilityScratchSpace[abilityIdx];
		proxy.disabledAbility.Enabled = false;
		abilityScratchSpace.RemoveAtIndex(abilityIdx);
		target.popupBar.Enqueue("POPUPBAR_ABILITY_DISRUPT_DISABLED");
	}
}
[Serializable]
public class Ability_Disrupt_Proxy : AbilityImplBase
{
	public AbilityImplBase disabledAbility;

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		disabledAbility.Enabled = true;
		unit.abilities.Remove(this);
		disabledAbility = null;
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnAbilityCasted()
	{
		disabledAbility = null;
	}
}
[Serializable]
public class Ability_Restore : AbilityImplBase
{
	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return selection.HP != selection.GetHPMax();
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		Unit unit2 = selection[0];
		int num = ((!base.IsUpgraded) ? 4 : (unit2.GetHPMax() - unit2.HP));
		unit2.HPDecrement(-num, unit);
		PlayParticles(unit2);
		unit.PlayBark(BarkTypes.RestoreHealth);
		unit.unitModel.Play(GetAbilityAnimationName(), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}
}
[Serializable]
public class Ability_Inspire : AbilityImplBase
{
	private const float kAccuracyBonusPerTurn = 0.1f;

	private const int kCriticalBonusPerTurn = 5;

	private float accuracyBonus;

	private int criticalBonus;

	private Dictionary<Unit, ParticlePrefab> particles = new Dictionary<Unit, ParticlePrefab>();

	private Unit[] teamMembers;

	public override void OnUnitSpawn(Unit unit)
	{
		if (!(unit == owner))
		{
			return;
		}
		particles.Clear();
		teamMembers = unit.GetTeam().GetActiveMembers().ToArray();
		for (int i = 0; i < teamMembers.Length; i++)
		{
			Unit key = teamMembers[i];
			if (!particles.TryGetValue(key, out var _))
			{
				particles.Add(key, null);
			}
		}
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		if (!(unit == owner))
		{
			return;
		}
		particles.Clear();
		teamMembers = unit.GetTeam().GetActiveMembers().ToArray();
		for (int i = 0; i < teamMembers.Length; i++)
		{
			Unit key = teamMembers[i];
			if (!particles.TryGetValue(key, out var _))
			{
				particles.Add(key, null);
			}
		}
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyBonus;
	}

	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return base.IsUpgraded ? criticalBonus : 0;
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (unit == owner && accuracyBonus != 0f)
		{
			PlayAllEffects();
			PlayAbilityEffects();
		}
	}

	private void PlayAllEffects()
	{
		owner.unitModel.PlayAndReturnToIdle(GetAbilityAnimationName());
		for (int i = 0; i < teamMembers.Length; i++)
		{
			Unit unit = teamMembers[i];
			if (unit.IsAlive() && !particles[unit])
			{
				particles[unit] = PlayParticles(unit, unit.unitModel.AnimCompTransform);
			}
		}
	}

	private void StopEffect(Unit unit)
	{
		if (particles.TryGetValue(unit, out var _) && (bool)particles[unit])
		{
			particles[unit].StopParticles();
			particles[unit] = null;
		}
	}

	private void StopAllEffects()
	{
		for (int i = 0; i < teamMembers.Length; i++)
		{
			Unit key = teamMembers[i];
			if ((bool)particles[key])
			{
				particles[key].StopParticles();
				particles[key] = null;
			}
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		StopEffect(unit);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		StopEffect(unit);
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (unit == owner && !isCombatEnd)
		{
			accuracyBonus += 0.1f;
			if (base.IsUpgraded)
			{
				criticalBonus += 5;
			}
			StopAllEffects();
		}
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (unit == owner)
		{
			accuracyBonus = 0f;
			criticalBonus = 0;
			StopAllEffects();
		}
	}

	public override bool IsTeamAbility()
	{
		return true;
	}
}
public class Ability_Detect : AbilityImplBase
{
	private const float kAreaOfEffect = 2f;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (unit.charData.partyMemberID == PartyMemberID.Chris)
		{
			return AbilityBarkType.Scan;
		}
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return 2f;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		PerformDetect(unit, selection[0]);
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (base.IsUpgraded)
		{
			PerformDetect(unit, unit.coord);
		}
	}

	private void PerformDetect(Unit unit, v2i coord)
	{
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			if (unitsActive[i].teamType != unit.teamType && unitsActive[i].IsCloaked && v2i.Distance(coord, unitsActive[i].coord) <= 2f)
			{
				unitsActive[i].OnExitCloak();
				unitsActive[i].popupBar.Enqueue("POPUPBAR_ABILITY_DETECT");
			}
		}
		ConstArray<TileTrapTrigger> trapTiles = Singleton<MC>.Inst.GetActiveMap().trapTiles;
		for (int j = 0; j < trapTiles.Length; j++)
		{
			TileTrapTrigger tileTrapTrigger = trapTiles[j];
			Ability_Trap ability_Trap = (Ability_Trap)tileTrapTrigger.Caster;
			v2i v2i2 = Singleton<MC>.Inst.GetActiveMap().WorldPosToCoord(tileTrapTrigger.transform.position);
			if (!ability_Trap.IsUpgraded)
			{
				v2i v2i3 = v2i2;
				int circleSize = tileTrapTrigger.CircleSize;
				v2i maxMapSize = Map.maxMapSize;
				int num = Mathf.Min(maxMapSize.x, v2i3.x + circleSize);
				v2i maxMapSize2 = Map.maxMapSize;
				int num2 = Mathf.Min(maxMapSize2.y, v2i3.y + circleSize);
				bool flag = false;
				for (int k = Mathf.Max(0, v2i3.x - circleSize); k <= num; k++)
				{
					for (int l = Mathf.Max(0, v2i3.y - circleSize); l <= num2; l++)
					{
						v2i v = new v2i(k, l);
						if (v2i.Distance(coord, v) <= 2f)
						{
							tileTrapTrigger.SetVisability(visability: true);
							tileTrapTrigger.discovered = true;
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
			}
			else if (v2i.Distance(coord, v2i2) <= 2f)
			{
				trapTiles[j].SetVisability(visability: true);
				trapTiles[j].discovered = true;
			}
		}
		UnitModel unitModel = unit.unitModel;
		string abilityAnimationName = GetAbilityAnimationName();
		bool crouched = unit.unitModel.crouched;
		unitModel.Play(abilityAnimationName, looping: false, crouched, interacting: false, updateIdleOnComplete: true);
		PlayParticles(unit, coord);
	}
}
public class Ability_Disable : AbilityImplBase
{
	private const int kStunTurns = 1;

	private HagletResettable routineResettable;

	private Unit target;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override AbilityMode GetAbilityMode()
	{
		return AbilityMode.Combat | AbilityMode.Stealth;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		target = selection[0];
		Routine.Start(routineResettable, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return base.IsUpgraded || selection.charData.hackable;
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox f = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		if (base.IsUpgraded)
		{
			return AbilityWheelVisibility.Enabled;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit2 = unitsActive[i];
			if (unit2.teamType != unit.teamType && unit2.teamType != UnitTeam.Type.NPC && unit2.charData.hackable)
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		return AbilityWheelVisibility.Disabled;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		routineResettable = new HagletResettable(AbilityRoutine(), "Ability_Disrupt", HagletStepTime.Update, -1, 2);
	}

	private IEnumerator<HagletYieldTerm> AbilityRoutine()
	{
		yield return owner.StartAttackAnimationWithAttackEvent(GetAbilityAnimationName());
		ParticleBullet particle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, target.map, target.coord);
		yield return Wait.While(particle.AnimateToTarget(owner, target, Combat.HitType.Hit));
		Ability_Stunned_Proxy stun = target.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
		stun.duration = 1;
		target.popupBar.Enqueue("POPUPBAR_ABILITY_DISABLE");
		PlayParticles(target);
	}
}
[Serializable]
public class Ability_Upgrade : AbilityImplBase
{
	private float kAOERadius = 1f;

	private ConstArray<Unit> affectedUnits = new ConstArray<Unit>(5u);

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return !selection.abilities.Exists<Ability_Upgrade_Proxy>() && !base.IsUpgraded;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 0f : kAOERadius;
	}

	public override bool RequireUnitSelection()
	{
		return !base.IsUpgraded;
	}

	public override bool RequireTileSelection()
	{
		return base.IsUpgraded;
	}

	public override uint SelectionMask(Unit unit)
	{
		return (!base.IsUpgraded) ? unit.teamMask : 0u;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		PlayParticles(selection[0]);
		selection[0].abilities.Add<Ability_Upgrade_Proxy>(this, isUpgraded: false);
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		return AbilityWheelVisibility.Enabled;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		Unit.GatherUnitsInRadius(selection[0], kAOERadius, affectedUnits, unit.teamMask);
		for (int i = 0; i < affectedUnits.Length; i++)
		{
			Unit unit2 = affectedUnits[i];
			if (unit2 != null && unit2.GetTeam() == unit.GetTeam() && !unit2.abilities.Exists<Ability_Upgrade_Proxy>())
			{
				PlayParticles(unit2);
				unit2.abilities.Add<Ability_Upgrade_Proxy>(this, isUpgraded: false);
			}
		}
	}
}
[Serializable]
public class Ability_Upgrade_Proxy : AbilityImplBase
{
	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (unit == owner)
		{
			unit.abilities.Remove(this);
		}
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if ((barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}
}
[Serializable]
public class Ability_Shock : AbilityImplBase
{
	public int kAccuracyMod = -10;

	public int kMovementMod = -1;

	public int kDuraction = 1;

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if ((barData.whamState & WhamStates.Status) == 0)
		{
			barData.whamState |= WhamStates.Status;
		}
		barData.SetBarPositionValue(BarTypes.Status, barData.GetBarPositionValue(BarTypes.Hit));
		barData.SetBarSizeValue(BarTypes.Status, barData.GetBarSizeValue(BarTypes.Hit) / 2f);
		barData.SetSpriteOverride(BarTypes.Status, meta.overrideSprite);
	}

	public override void OnUnitTargetAvoidedDamage(Unit unit, Unit target, Combat.HitType hitType, WeaponAttributes weapon = null)
	{
		if (unit == owner && hitType == Combat.HitType.Status)
		{
			PlayParticles(target);
			target.popupBar.Enqueue("POPUPBAR_UNITATTACK_SHOCKED");
			Ability_Shock_Proxy ability_Shock_Proxy = target.abilities.Add<Ability_Shock_Proxy>(this, isUpgraded: false);
			if (base.IsUpgraded)
			{
				int damage = weapon.Damage;
				damage = ((!weapon.IsRanged) ? (damage + CharacterStats.LUT_WeaponBaseDamageMelee[unit.ClassID, unit.Level]) : (damage + CharacterStats.LUT_WeaponBaseDamageRanged[unit.ClassID, unit.Level]));
				target.HPDecrement(damage);
			}
		}
	}

	public override string OverrideWhamResultText(Unit unit, UIWhamBar.WhamResult result, string orginal)
	{
		return (!(unit == owner) || result != UIWhamBar.WhamResult.Status) ? orginal : meta.GetDisplayName(owner.charData);
	}
}
[Serializable]
public class Ability_Shock_Proxy : AbilityImplBase
{
	public int movementMod = -1;

	public float accuracyMod = -0.1f;

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		unit.abilities.Remove(this);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.abilities.Remove(this);
	}

	public override int GetUnitMaxMoveDistanceModifier(Unit unit)
	{
		return movementMod;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyMod;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.ReducedAccuracy, this, 1));
		effects.Add(StatusEffect.Create(StatusEffect.Type.ReducedMovement, this, 1));
	}
}
[Serializable]
public class Ability_Auto_Revive : AbilityImplBase
{
	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override bool SelectionIncludeSelf(Unit unit)
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return unit.teamMask;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return !selection.abilities.Exists<Ability_Auto_Revive_Proxy>();
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		return AbilityWheelVisibility.Enabled;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		Ability_Auto_Revive_Proxy ability_Auto_Revive_Proxy = selection[0].abilities.Add<Ability_Auto_Revive_Proxy>(this, isUpgraded: false);
		ability_Auto_Revive_Proxy.upgraded = base.IsUpgraded;
		ability_Auto_Revive_Proxy.protectionEffect = PlayParticles(selection[0], selection[0].unitModel.AnimCompTransform);
	}
}
[Serializable]
public class Ability_Auto_Revive_Proxy : AbilityImplBase
{
	public ParticlePrefab protectionEffect;

	public bool upgraded;

	public override bool IsProxyAbility()
	{
		return true;
	}

	private void StopProtectionEffect()
	{
		if ((bool)protectionEffect)
		{
			protectionEffect.StopParticles();
			protectionEffect = null;
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (!upgraded)
		{
			StopProtectionEffect();
			unit.abilities.Remove(this);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		StopProtectionEffect();
		unit.abilities.Remove(this);
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		if (unit.HP == 0)
		{
			StopProtectionEffect();
			PlayParticles(unit);
			unit.HPDecrement(-Mathf.CeilToInt((float)unit.GetHPMax() / 2f));
			owner.popupBar.Enqueue(caster.meta.GetDisplayName(owner.charData), 0, 0.5f);
			unit.abilities.Remove(this);
		}
	}
}
[Serializable]
public class Ability_CQC : AbilityImplBase
{
	private const float kCqcRange = 1.5f;

	private const float kAccuracyReduction = -0.2f;

	private const float kAccuracyReductionUpgraded = 0f;

	private bool isAttacking;

	public override void OnUnitSpawn(Unit unit)
	{
		unit.OnEnterOverwatch(1.5f, closeRange: true);
	}

	public override bool OnUnitEnteredCoord(Unit unit, Unit unitEnteringCoord, v2i startCoord)
	{
		if (!GC.Inst.IsInStealthMode() && !unitEnteringCoord.IsCloaked && !v2i.IsNeighbour(unit.coord, startCoord))
		{
			isAttacking = true;
			PlayParticles(unit);
			unit.StartAttack(unitEnteringCoord, unit.MeleeWeapon, costsAP: false, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: true, null, 1, (unit.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_CQC");
			if (base.IsUpgraded)
			{
				unitEnteringCoord.APDecrement(unitEnteringCoord.AP);
			}
			return true;
		}
		return false;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		isAttacking = false;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		float result = 0f;
		if (isAttacking)
		{
			result = ((!base.IsUpgraded) ? (-0.2f) : 0f);
		}
		return result;
	}

	public override bool RequiresAttack()
	{
		return true;
	}
}
[Serializable]
public class Ability_Dance : AbilityImplBase
{
	private bool showPopUp = true;

	private const int kDodgeBonus = 10;

	private ParticlePrefab pp_dance;

	private bool IsOutOfCover(Unit unit)
	{
		OctDir dir;
		return !unit.map.GetAdjacentCoverDirection(unit.coord, out dir, includeDiagonals: true);
	}

	public override int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		if (IsOutOfCover(unit))
		{
			return 10;
		}
		return 0;
	}

	public override void OnUnitMoveEnd(Unit unit)
	{
		if (unit.AP <= 0 && IsOutOfCover(unit) && showPopUp && GC.Inst.IsInCombatMode())
		{
			PlayAbilityEffects();
			showPopUp = false;
		}
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (base.IsUpgraded && IsOutOfCover(target) && (barData.whamState & WhamStates.Crit) != 0)
		{
			barData.SetBarPositionValue(BarTypes.Crit, 0f);
			barData.SetBarSizeValue(BarTypes.Crit, 0f);
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		StopEffect();
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		showPopUp = true;
		StopEffect();
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (IsOutOfCover(unit) && !isCombatEnd)
		{
			PlayEffect(unit);
			if (showPopUp)
			{
				PlayAbilityEffects();
				showPopUp = false;
			}
		}
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		if (IsOutOfCover(unit))
		{
			PlayEffect(unit);
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		StopEffect();
	}

	private void PlayEffect(Unit unit)
	{
		if (!pp_dance)
		{
			pp_dance = PlayParticles(unit);
		}
	}

	private void StopEffect()
	{
		if ((bool)pp_dance)
		{
			pp_dance.StopParticles();
			pp_dance = null;
		}
	}
}
[Serializable]
public class Ability_Frenzy : AbilityImplBase
{
	private ConstArray<Unit> enemiesHitThisTurn = new ConstArray<Unit>(4u);

	public override void OnUnitTurnBegin(Unit unit)
	{
		enemiesHitThisTurn.Clear();
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (target.HP <= 0 && !enemiesHitThisTurn.Contains(target))
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_FRENZY");
			unit.APRefill();
			PlayParticles(unit);
		}
		if (!base.IsUpgraded)
		{
			enemiesHitThisTurn.Add(target);
		}
	}
}
[Serializable]
public class Ability_Flurry : AbilityImplBase
{
	private const float kRadius = 3f;

	private const float kRadiusUpgraded = 5f;

	private const float kFlurryMoveSpeed = 7f;

	private ConstArray<Unit> unitCheckArray;

	private HagletResettable flurry;

	public float EffectiveRadius => (!base.IsUpgraded) ? 3f : 5f;

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		unitCheckArray = new ConstArray<Unit>(8u);
		flurry = new HagletResettable(FlurryRoutine(), owner.charData.charName + " Flurry");
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		Unit.GatherUnitsInRadius(owner.coord, EffectiveRadius, unitCheckArray, ~owner.teamMask);
		if (unitCheckArray.Length != 0)
		{
			return AbilityWheelVisibility.Enabled;
		}
		if (contextToFill != null)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_NOENEMIESINRADIUS");
		}
		return AbilityWheelVisibility.Disabled;
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		Routine.Start(flurry, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> FlurryRoutine()
	{
		Unit.GatherUnitsInRadius(owner.coord, EffectiveRadius, unitCheckArray, ~owner.teamMask);
		int attackEventCount = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>("AbilityBrawl");
		UnitModel unitModel = owner.unitModel;
		string animName = "AbilityBrawl";
		bool crouched = owner.unitModel.crouched;
		HagletTrigger animComplete = unitModel.Play(animName, looping: false, crouched);
		if (attackEventCount > 0)
		{
			yield return owner.WaitForAttackAnimEvent();
		}
		else
		{
			yield return animComplete;
		}
		PlayParticles(owner);
		yield return Wait.ForSeconds(0.5f);
		for (int i = 0; i < unitCheckArray.Length; i++)
		{
			Unit unit = unitCheckArray[i];
			UnitModel unitModel2 = unit.unitModel;
			animName = "CombatCrouchHit";
			crouched = unit.unitModel.crouched;
			unitModel2.Play(animName, looping: false, crouched);
			unit.HPDecrement(owner.GetDamageValue(isCriticalHit: false, unit, owner.MeleeWeapon, isCombatCalculation: false), owner);
		}
		owner.UpdateIdleAnim();
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (unit.IsPerformingAbilityAttack)
		{
			barData.SetBarPositionValue(BarTypes.Hit, 0f);
		}
	}
}
[Serializable]
public class Ability_Bullet_Time : AbilityImplBase
{
	private bool activatedBulletTimeThisTurn;

	private bool activateBulletTime;

	private bool isReactionAttack;

	public override int GetPriority()
	{
		return 15;
	}

	public override void OnUnitAttackedBegin(Unit unit, Unit attacker, WeaponAttributes attackerWeapon, bool reactionAttack)
	{
		isReactionAttack = reactionAttack;
		if (!activatedBulletTimeThisTurn && reactionAttack)
		{
			activatedBulletTimeThisTurn = true;
			activateBulletTime = true;
		}
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if ((base.IsUpgraded || activateBulletTime) && isReactionAttack)
		{
			float barPositionValue = barData.GetBarPositionValue(BarTypes.Graze);
			float barSizeValue = barData.GetBarSizeValue(BarTypes.Graze);
			barData.SetBarPositionValue(BarTypes.Graze, 0f);
			barData.SetBarSizeValue(BarTypes.Graze, 0f);
			barData.whamState |= WhamStates.Dodge;
			barData.SetBarPositionValue(BarTypes.Dodge, barPositionValue);
			barData.SetBarSizeValue(BarTypes.Dodge, barSizeValue);
		}
		isReactionAttack = false;
	}

	public override void OnUnitAvoidedDamage(Unit unit, Unit attacker, WeaponAttributes weapon = null)
	{
		if (activateBulletTime)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_BULLETTIME");
			PlayParticles(unit);
			activateBulletTime = false;
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		activateBulletTime = false;
		activatedBulletTimeThisTurn = false;
	}
}
public class Ability_Danger_Zone : AbilityImplBase
{
	private bool showPopUp = true;

	private bool inTheDangerZone;

	private bool performedCritical;

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (!unit.map.GetAdjacentCoverDirection(unit.coord, out var _, includeDiagonals: true))
		{
			inTheDangerZone = true;
			if (showPopUp)
			{
				PlayAbilityEffects();
				showPopUp = false;
			}
		}
		else
		{
			inTheDangerZone = false;
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		showPopUp = true;
	}

	public override int OnUnitAPWillChange(Unit unit, int amount)
	{
		if (unit.AP - amount <= 0 && showPopUp)
		{
			PlayAbilityEffects();
			showPopUp = false;
		}
		return amount;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		bool flag = base.IsUpgraded && unit.AP == 1;
		if (inTheDangerZone || flag)
		{
			PlayParticles(unit);
		}
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		bool flag = base.IsUpgraded && unit.AP == 0;
		if (inTheDangerZone || flag)
		{
			if ((barData.whamState & WhamStates.Crit) == 0)
			{
				barData.whamState |= WhamStates.Crit;
			}
			performedCritical = true;
			inTheDangerZone = false;
		}
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (performedCritical)
		{
			performedCritical = false;
		}
	}
}
public class Ability_Dash : AbilityImplBase
{
	private const float kDashSpeed = 7f;

	private HagletResettable dash;

	private Unit routineTarget;

	public override void OnUnitSpawn(Unit unit)
	{
		dash = new HagletResettable(DashRoutine(), null, HagletStepTime.Update, -1, 1);
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Ghost)
		{
			return AbilityBarkType.Attack;
		}
		if (unit.charData.Class == CharacterClass.Runner)
		{
			return AbilityBarkType.Defence;
		}
		return AbilityBarkType.General;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool RequiresMovement()
	{
		return true;
	}

	public override bool RequiresPathing()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return base.IsUpgraded;
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		if (!unit.map.Raymarch(unit.coord, selection.coord, blockedByHalfCover: true).HasValue && GC.Inst.GetUnitAtCoord(GetEndCoord(unit.coord, selection.coord)) == null)
		{
			return true;
		}
		return false;
	}

	public override AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		if (GC.Inst.IsInRPGMode())
		{
			return AbilityWheelVisibility.Hidden;
		}
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit2 = unitsActive[i];
			if (unit2.teamType != unit.teamType && unit2.teamType != UnitTeam.Type.NPC && ValidateUnitSelection(unit, unitsActive[i]))
			{
				return AbilityWheelVisibility.Enabled;
			}
		}
		if ((bool)contextToFill)
		{
			contextToFill.AppendKey("ABILITYWHEELDISABLED_NOUNITSINRANGE");
		}
		return AbilityWheelVisibility.Disabled;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		routineTarget = selection[0];
		Routine.Start(dash, MR.Inst.Host);
	}

	public v2i GetEndCoord(v2i unitCoord, v2i targetCoord)
	{
		return targetCoord + v2i.Normalize(unitCoord - targetCoord);
	}

	private IEnumerator<HagletYieldTerm> DashRoutine()
	{
		ParticlePrefab dashPFX = PlayParticles(owner, owner.unitModel.AnimCompTransform);
		owner.StartMovement(GetEndCoord(owner.coord, routineTarget.coord), null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: true, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, 7f);
		yield return Wait.ForChildren;
		if (base.IsUpgraded)
		{
			Unit unit = owner;
			Unit target = routineTarget;
			WeaponAttributes meleeWeapon = owner.MeleeWeapon;
			bool costsAP = false;
			Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
			unit.StartAttack(target, meleeWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, minigame);
			yield return Wait.ForChildren;
			dashPFX.StopParticles();
		}
		else
		{
			yield return Wait.ForSeconds(0.5f);
			dashPFX.StopParticles();
		}
		routineTarget = null;
	}
}
public class Ability_Backfist : AbilityImplBase
{
	private bool shouldCancel;

	private bool isWhamming;

	private Unit attacker;

	private HagletResettable backfist;

	private ConstArray<Combat.CombatData> combatData = new ConstArray<Combat.CombatData>(1u);

	public override void OnUnitSpawn(Unit unit)
	{
		backfist = new HagletResettable(BackfistRoutine(), unit.charData.DisplayName + " Backfist");
	}

	public override void OnUnitAttackedBegin(Unit unit, Unit attacker, WeaponAttributes attackerWeapon, bool reactionAttack)
	{
		shouldCancel = false;
		if (attacker.IsCloaked)
		{
			Combat.CombatData combatData = default(Combat.CombatData);
			combatData.hitChance = attacker.GetHitChance(attacker.coord, unit, attacker.mainWeapon, reactionAttack: false, isCombatCalculation: true);
			combatData.critChance = attacker.GetCriticalHitChance(unit, attacker.mainWeapon, isCombatCalculation: true);
			combatData.dodgeChance = unit.GetDodgeChance(attacker);
			combatData.critSize = attacker.GetCriticalHitSize(unit, attacker.mainWeapon, isCombatCalculation: true);
			combatData.dodgeSize = unit.GetDodgeSize(attacker);
			combatData.whamState = attacker.GetDefaultWhamState(Combat.CombatMinigame.DodgeWhamBar, combatData, unit);
			combatData.attacker = attacker;
			combatData.target = unit;
			combatData.weapon = unit.MeleeWeapon;
			combatData.additionalEffect = Combat.HitType.None;
			this.combatData.Clear();
			this.combatData.Add(combatData);
			this.attacker = attacker;
			Routine.Start(backfist, MR.Inst.Host);
		}
	}

	public override bool OnUnitAttackedShouldCancel(Unit unit, Unit attacker)
	{
		if (shouldCancel)
		{
			attacker.OnExitCloak();
			if (base.IsUpgraded)
			{
				attacker.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			}
		}
		return shouldCancel;
	}

	private IEnumerator<HagletYieldTerm> BackfistRoutine()
	{
		yield return PlayAbilityEffects();
		PlayParticles(owner);
		isWhamming = true;
		yield return UIWhamBar.Inst.StartWhamBar(Combat.CombatMinigame.DodgeWhamBar, combatData, isReaction: true);
		isWhamming = false;
		if (combatData[0].hitType == Combat.HitType.Reaction || combatData[0].additionalEffect == Combat.HitType.Reaction)
		{
			string overrideAnim = null;
			if (owner.charData.partyMemberID == PartyMemberID.Ambrosia)
			{
				overrideAnim = "AbilityBackFist";
			}
			Unit unit = owner;
			Unit target = attacker;
			WeaponAttributes meleeWeapon = owner.MeleeWeapon;
			bool costsAP = false;
			Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
			unit.StartAttack(target, meleeWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, overrideAnim, 1, minigame);
			yield return Wait.ForChildren;
			shouldCancel = true;
		}
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (isWhamming)
		{
			float barSizeValue = barData.GetBarSizeValue(BarTypes.Graze);
			float barSizeValue2 = barData.GetBarSizeValue(BarTypes.Dodge);
			float num = Mathf.Max(barSizeValue, barSizeValue2);
			float newVal = UnityEngine.Random.Range(0f, 1f - num);
			barData.SetBarSizeValue(BarTypes.Crit, 0f);
			barData.SetBarSizeValue(BarTypes.Dodge, 0f);
			barData.SetBarSizeValue(BarTypes.Graze, 0f);
			barData.SetBarPositionValue(BarTypes.Crit, 0f);
			barData.SetBarPositionValue(BarTypes.Dodge, 0f);
			barData.SetBarPositionValue(BarTypes.Graze, 0f);
			barData.whamState |= WhamStates.Reaction;
			barData.SetBarSizeValue(BarTypes.Reaction, num);
			barData.SetBarPositionValue(BarTypes.Reaction, newVal);
		}
	}
}
[Serializable]
public class Ability_Multi_Shot : AbilityImplBase
{
	private const int kProccChance = 20;

	private const int kUpgradeProccChance = 35;

	private bool procced;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		if (GC.Inst.IsInTurnMode() && !unit.IsPerformingAbilityAttack && !LR.HACK_tutorialMode)
		{
			if (base.IsUpgraded && 35.PercentChance())
			{
				procced = true;
			}
			else if (!base.IsUpgraded && 20.PercentChance())
			{
				procced = true;
			}
			if (procced)
			{
				unit.popupBar.Enqueue("POPUPBAR_ABILITY_MULTISHOT");
				PlayParticles(unit);
			}
		}
	}

	public override int GetAdditionalAttacks(Unit unit, WeaponAttributes weapon)
	{
		if (procced)
		{
			return 1;
		}
		return 0;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (procced)
		{
			procced = false;
		}
	}

	public override string GetUnitAttackAnimName()
	{
		if (procced && owner.charData.partyMemberID == PartyMemberID.Ambrosia)
		{
			return "CombatAttackMeleeMulti";
		}
		return base.GetUnitAttackAnimName();
	}
}
[Serializable]
public class Ability_Covering_Fire : AbilityImplBase
{
	private Ability_Covering_Fire_Proxy proxy;

	private ParticlePrefab pp_suppresing;

	private HagletResettable intialSuppressingFireRoutine;

	private HagletResettable suppressingFireRoutine;

	private bool supressing = true;

	private int shotNumber = 3;

	private float timeBetween = 2f;

	private bool HACK_cancelled;

	public Unit target;

	private Func<bool> SuppressionInterupted;

	private bool active => (bool)intialSuppressingFireRoutine.running || intialSuppressingFireRoutine.markedToRunBy != null || (bool)suppressingFireRoutine.running || suppressingFireRoutine.markedToRunBy != null;

	public override bool SelectionAllowStepOut(Unit unit)
	{
		return false;
	}

	public override int APCost(Unit unit)
	{
		return unit.AP;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		intialSuppressingFireRoutine = new HagletResettable(IntialSuppressingFireRoutine());
		suppressingFireRoutine = new HagletResettable(SuppressingFireRoutine(), unit.name + " Suppressing Fire Routine");
		SuppressionInterupted = hasSuppessionBeenInterupted;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		if (owner.unitModel.HasAnim("CombatAimIdle"))
		{
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatAimIdle");
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatAimIdle");
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.TransAIdleToCIdle, "CombatAimIdle");
		}
		else
		{
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatIdle");
			owner.unitModel.SetAnimOverride(UnitModel.AnimID.TransAIdleToCIdle, "CombatIdle");
		}
		owner.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchHit, "CombatHit");
		target = selection[0];
		Routine.Start(intialSuppressingFireRoutine);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public void StartSuppression()
	{
		supressing = true;
		MR.Inst.Host.StartTopLevel(suppressingFireRoutine);
	}

	public HagletYieldTerm StopSuppressing()
	{
		supressing = false;
		return Wait.While(suppressingFireRoutine.running);
	}

	public void StopAbility(bool updateIdle)
	{
		StopSuppressing();
		if (proxy != null)
		{
			proxy.RemoveProxy();
		}
		pp_suppresing.StopParticles();
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.TransAIdleToCIdle);
		owner.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouchHit);
		if (updateIdle)
		{
			owner.UpdateIdleAnim();
		}
		HACK_cancelled = true;
	}

	public override void OnUnitStunned(Unit unit)
	{
		if (active)
		{
			StopAbility(updateIdle: false);
		}
	}

	public override void OnUnitDeathBegun(Unit unit)
	{
		if (active)
		{
			StopAbility(updateIdle: false);
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		if (active)
		{
			StopAbility(updateIdle: false);
		}
	}

	private bool hasSuppessionBeenInterupted()
	{
		return owner.unitModel.animName != GetAbilityAnimationName() || HACK_cancelled;
	}

	public IEnumerator<HagletYieldTerm> SuppressingFireRoutine()
	{
		while (supressing)
		{
			yield return Wait.ForSeconds(timeBetween);
			if (!supressing)
			{
				break;
			}
			int attackEventCount = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(GetAbilityAnimationName());
			if (attackEventCount > 0)
			{
				for (int i = 0; i < shotNumber; i++)
				{
					if (!supressing)
					{
						yield break;
					}
					HagletTrigger animComplete = owner.unitModel.Play(GetAbilityAnimationName());
					yield return owner.WaitForAttackAnimEvent() | Wait.Until(SuppressionInterupted);
					if (hasSuppessionBeenInterupted() || !supressing)
					{
						break;
					}
					ParticleBullet particle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, target.map, target.coord);
					HagletYieldTerm animCompleted = Wait.Until(animComplete);
					yield return Wait.While(particle.AnimateToTarget(owner, target, Combat.HitType.Miss)) | animCompleted | Wait.Until(SuppressionInterupted);
					if (hasSuppessionBeenInterupted() || !supressing)
					{
						break;
					}
					if (!animCompleted.met)
					{
						yield return animComplete;
					}
				}
				owner.UpdateIdleAnim();
				continue;
			}
			StopAbility(updateIdle: true);
			break;
		}
	}

	public IEnumerator<HagletYieldTerm> IntialSuppressingFireRoutine()
	{
		if (owner.unitModel.HasAnim("TransCIdleToAIdle"))
		{
			yield return owner.unitModel.PlayAndReturnToIdle("TransCIdleToAIdle");
		}
		pp_suppresing = PlayParticles(target);
		int attackEventCount = owner.unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(GetAbilityAnimationName());
		if (attackEventCount > 0)
		{
			for (int i = 0; i < shotNumber; i++)
			{
				HagletTrigger animComplete = owner.unitModel.Play(GetAbilityAnimationName());
				yield return owner.WaitForAttackAnimEvent();
				ParticleBullet particle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, target.map, target.coord);
				yield return Wait.While(particle.AnimateToTarget(owner, target, Combat.HitType.Miss)) & animComplete;
			}
			proxy = target.abilities.Add<Ability_Covering_Fire_Proxy>(this, isUpgraded: false);
			proxy.Initialise();
			proxy.covering = this;
			StartSuppression();
		}
		else
		{
			StopAbility(updateIdle: true);
		}
	}
}
[Serializable]
public class Ability_Covering_Fire_Proxy : AbilityImplBase
{
	private const float kHitPenalty = 0.2f;

	public ParticlePrefab pp;

	public Ability_Covering_Fire covering;

	private HagletResettable suppressingMoveRoutine;

	private HagletResettable suppressingAttackRoutine;

	public void Initialise()
	{
		suppressingMoveRoutine = new HagletResettable(SuppressingMoveRoutine());
		suppressingAttackRoutine = new HagletResettable(SuppressingAttackRoutine());
	}

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		return 0.2f;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		if (covering.IsUpgraded)
		{
			Routine.Start(suppressingAttackRoutine);
		}
	}

	public override void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
		Routine.Start(suppressingMoveRoutine);
	}

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		covering.StopAbility(updateIdle: true);
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		covering.StopAbility(updateIdle: true);
	}

	public void RemoveProxy()
	{
		owner.abilities.Remove(this);
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		if (!caster.IsUpgraded)
		{
			effects.Add(StatusEffect.Create(StatusEffect.Type.Suppressed, this, 1));
		}
		else
		{
			effects.Add(StatusEffect.Create(StatusEffect.Type.SuppressedOverloaded, this, int.MaxValue));
		}
	}

	private IEnumerator<HagletYieldTerm> SuppressingMoveRoutine()
	{
		yield return covering.StopSuppressing() & covering.PlayAbilityEffects();
		Unit unit = covering.owner;
		Unit target = owner;
		WeaponAttributes rangedWeapon = covering.owner.RangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((covering.owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(target, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
		yield return Wait.ForChildren;
		covering.StopAbility(updateIdle: true);
	}

	private IEnumerator<HagletYieldTerm> SuppressingAttackRoutine()
	{
		yield return covering.StopSuppressing() & covering.PlayAbilityEffects();
		Unit unit = covering.owner;
		Unit target = owner;
		WeaponAttributes rangedWeapon = covering.owner.RangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((covering.owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(target, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
		yield return Wait.ForChildren;
		covering.StartSuppression();
	}
}
[Serializable]
public class Ability_Point_Blank : AbilityImplBase
{
	private const int kNearRange = 3;

	private const int kAdjecentRange = 1;

	private int kNearRangeCritChance = 15;

	private int kAdjecentRangeCritChance = 30;

	private bool critApplied;

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		critApplied = false;
		if (base.IsUpgraded)
		{
			if (v2i.Distance(unit.coord, target.coord) <= 3f)
			{
				if ((barData.whamState & WhamStates.Crit) == 0)
				{
					barData.whamState |= WhamStates.Crit;
				}
				critApplied = true;
			}
		}
		else if (v2i.IsNeighbour(unit.coord, target.coord))
		{
			if (30.PercentChance())
			{
				if ((barData.whamState & WhamStates.Crit) == 0)
				{
					barData.whamState |= WhamStates.Crit;
				}
				critApplied = true;
			}
		}
		else if (v2i.Distance(unit.coord, target.coord) <= 3f && 15.PercentChance())
		{
			if ((barData.whamState & WhamStates.Crit) == 0)
			{
				barData.whamState |= WhamStates.Crit;
			}
			critApplied = true;
		}
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (critApplied && hitType == Combat.HitType.HitCritical)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_POINTBLANK");
		}
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		Unit unit2 = unit.AttackTargets[0];
		if (v2i.Distance(unit.coord, unit2.coord) <= 3f)
		{
			PlayParticles(unit);
		}
	}
}
[Serializable]
public class Ability_Tactical_Cover : AbilityImplBase
{
	private float kHalfCoverMissBonus = -0.5f;

	private float kUpgradedFullCoverAdditional = -0.5f;

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		float num = 0f;
		if (target.map.GetCoverBetween(attacker.coord, target.coord).Is(CoverType.Half))
		{
			num += kHalfCoverMissBonus;
		}
		if (base.IsUpgraded)
		{
			for (OctDir octDir = OctDir.Up; octDir <= OctDir.UpLeft; octDir++)
			{
				if (target.map.GetCoverHeight(targetCoord + octDir) == TileObjectBase.Height.Full)
				{
					num += kUpgradedFullCoverAdditional;
				}
			}
		}
		return num;
	}

	public override void OnUnitMoveEnd(Unit unit)
	{
		for (OctDir octDir = OctDir.Up; octDir <= OctDir.Left; octDir += 2)
		{
			if (unit.map.GetCoverHeight(owner.coord + octDir) == TileObjectBase.Height.Full)
			{
				unit.map.VFXTiles.TacticalCoverIndicatorShow(unit.coord, octDir);
			}
		}
	}

	public override void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
		unit.map.VFXTiles.TacticalCoverIndicatorHide();
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		unit.map.VFXTiles.TacticalCoverIndicatorHide();
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.map.VFXTiles.TacticalCoverIndicatorHide();
	}

	public override void OnUnitMapTransitionBegin(Unit unit)
	{
		unit.map.VFXTiles.TacticalCoverIndicatorHide();
	}
}
[Serializable]
public class Ability_Limb_Shot : AbilityImplBase
{
	private const float kAccuracyPenalty = -0.2f;

	private const int kMovementPenalty = -1;

	private Unit target;

	private Wrapper<Type> abilityPointer = new Wrapper<Type>(null);

	private HagletResettable limbShotRoutine;

	public override void OnUnitSpawn(Unit unit)
	{
		limbShotRoutine = new HagletResettable(LimbShotRoutine(), "Limb shot routine");
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Triggerman)
		{
			return (unit.AP == 0) ? 1 : unit.AP;
		}
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return !selection.charData.environmental;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		base.Cooldown = CooldownMax();
		WeaponAttributes rangedWeapon = unit.RangedWeapon;
		target = selection[0];
		UISlotChamp.Inst.Clear();
		if (base.IsUpgraded)
		{
			UISlotChamp.Inst.AddEffect<Ability_Movement_Proxy>(5);
			UISlotChamp.Inst.AddEffect<Ability_Accuracy_Proxy>(5);
		}
		else
		{
			UISlotChamp.Inst.AddEffect<Ability_Movement_Proxy>(3);
			UISlotChamp.Inst.AddEffect<Ability_Accuracy_Proxy>(3);
			UISlotChamp.Inst.AddEffect<Ability_ReceiveShot_Proxy>(4);
		}
		Routine.Start(limbShotRoutine);
	}

	private IEnumerator<HagletYieldTerm> LimbShotRoutine()
	{
		PlayParticles(owner);
		abilityPointer.val = null;
		if (owner.teamType == UnitTeam.Type.Player)
		{
			yield return UISlotChamp.Inst.ShowSlotChamp(this, abilityPointer);
		}
		else
		{
			abilityPointer.val = ((!target.IsMelee) ? typeof(Ability_Accuracy_Proxy) : typeof(Ability_Movement_Proxy));
		}
		yield return Wait.ForSeconds(0.25f);
		Unit unit = owner;
		Unit unit2 = target;
		WeaponAttributes rangedWeapon = owner.RangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((owner.teamType != UnitTeam.Type.Enemy) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(unit2, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, minigame);
		yield return Wait.ForChildren;
		yield return Wait.ForSeconds(0.5f);
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (abilityPointer.val == typeof(Ability_Accuracy_Proxy))
		{
			Ability_Accuracy_Proxy ability_Accuracy_Proxy = (Ability_Accuracy_Proxy)target.abilities.Add(abilityPointer.val, this, isUpgraded: false);
			ability_Accuracy_Proxy.duration = 0;
			ability_Accuracy_Proxy.accuracyMod = -0.2f;
		}
		else if (abilityPointer.val == typeof(Ability_Movement_Proxy))
		{
			Ability_Movement_Proxy ability_Movement_Proxy = (Ability_Movement_Proxy)target.abilities.Add(abilityPointer.val, this, isUpgraded: false);
			ability_Movement_Proxy.movementMod = -1;
		}
		abilityPointer.val = null;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}
}
[Serializable]
public class Ability_Return_Fire : AbilityImplBase
{
	private Unit target;

	private HagletResettable returnfireRoutine;

	private const int kReturnFireChance = 40;

	public override void OnUnitSpawn(Unit unit)
	{
		returnfireRoutine = new HagletResettable(ReturnfireRoutine());
	}

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if (!isReaction && unit.map.HasLineOfSight(unit.coord, target.coord, isSideStepAllowed: true) && 40.PercentChance())
		{
			barData.whamState |= WhamStates.Reaction;
			float num = barData.GetBarSizeValue(BarTypes.Dodge);
			if (base.IsUpgraded)
			{
				num = Mathf.Clamp01(num * 1.5f);
			}
			barData.SetBarPositionValue(BarTypes.Reaction, UnityEngine.Random.Range(0f, 1f - num));
			barData.SetBarSizeValue(BarTypes.Reaction, num);
			barData.SetBarOverlay(BarTypes.Reaction, Overlay: true);
		}
	}

	public override void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
		if ((hitType == Combat.HitType.Reaction || additionalEffect == Combat.HitType.Reaction) && !reactionAttack)
		{
			target = attacker;
			Routine.Start(returnfireRoutine);
		}
	}

	public IEnumerator<HagletYieldTerm> ReturnfireRoutine()
	{
		if (owner.unitModel.crouched)
		{
			yield return owner.unitModel.Play(UnitModel.AnimID.TransCCrouchToCIdle);
		}
		WeaponAttributes weapon = owner.RangedWeapon;
		if (owner.mainWeapon.IsMelee)
		{
			if (v2i.IsNeighbour(owner.coord, target.coord))
			{
				weapon = owner.mainWeapon;
			}
		}
		else if (owner.mainWeapon.IsRanged)
		{
			owner.AimAtTarget(target._GetTransform().position);
		}
		yield return PlayAbilityEffects();
		PlayParticles(owner);
		Unit unit = owner;
		Unit unit2 = target;
		WeaponAttributes weapon2 = weapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(unit2, weapon2, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
		yield return Wait.ForChildren;
	}
}
[Serializable]
public class Ability_Spray_And_Pray : AbilityImplBase
{
	private const float kAccuracyPenalty = -0.77f;

	private const int kNumberOfAttacks = 3;

	private const int kUpgradedNumberOfAttacks = 4;

	private float accuracyModifier;

	public override int APCost(Unit unit)
	{
		return Mathf.Max(unit.AP, 1);
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override int SelectionRange(Unit unit)
	{
		if (owner.mainWeapon.IsMelee)
		{
			return 1;
		}
		return int.MaxValue;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyModifier;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		base.Cooldown = CooldownMax();
		accuracyModifier = -0.77f;
		Unit unit2 = selection[0];
		WeaponAttributes mainWeapon = unit.mainWeapon;
		if (!unit.StartAttack(unit2, mainWeapon, costsAP: false, Unit.IfTooFar.InvalidateAction, attackCount: (!base.IsUpgraded) ? 3 : 4, customTargetCoord: null, isReactionAttack: false, isAbilityAttack: true, overrideAnimationName: (!mainWeapon.IsMelee) ? null : GetAbilityAnimationName(), minigame: (unit.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar))
		{
			accuracyModifier = 0f;
		}
	}

	public override void OnSelectionBegin(Unit unit)
	{
		accuracyModifier = -0.77f;
		PlayParticles(unit);
	}

	public override void OnSelectionCancel(Unit unit)
	{
		accuracyModifier = 0f;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		accuracyModifier = 0f;
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (isActive)
		{
			if ((barData.whamState & WhamStates.Crit) != 0)
			{
				barData.whamState &= (WhamStates)(-3);
			}
			float barSizeValue = barData.GetBarSizeValue(BarTypes.Hit);
			float newVal = UnityEngine.Random.Range(0.2f, 1f - barSizeValue);
			barData.SetBarPositionValue(BarTypes.Hit, newVal);
		}
	}
}
public class Ability_Area_Shot : AbilityImplBase
{
	private const float kRadius = 2f;

	private const float kUpgradedRadius = 3f;

	private readonly ConstArray<Unit> testTargets = new ConstArray<Unit>(32u);

	private Unit attacker;

	private v2i targetCoord;

	private HagletResettable areaShotRoutine;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		return 2;
	}

	public override int CooldownMax()
	{
		return 4;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override bool RequireTileUnblocked()
	{
		return false;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 2f : 3f;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override bool ValidateTileSelection(Unit unit, v2i selection)
	{
		return true;
	}

	public override VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		if (!owner.map.HasLineOfSight(owner.coord, coord, isSideStepAllowed: false))
		{
			return VFXTileController.TileType.AreaSelectionInvalid;
		}
		Unit unitAtCoord = GC.Inst.GetUnitAtCoord(coord);
		if (unitAtCoord != null && unitAtCoord.teamType != owner.teamType)
		{
			return VFXTileController.TileType.AreaSelectionUnitAttack;
		}
		return VFXTileController.TileType.AreaSelectionOffensive;
	}

	public override void OnUnitSpawn(Unit unit)
	{
		areaShotRoutine = new HagletResettable(AreaShotRoutine(), "Area Shot routine");
	}

	private IEnumerator<HagletYieldTerm> AreaShotRoutine()
	{
		GetValidTargets(attacker, targetCoord, testTargets);
		ParticlePrefab pp = PlayParticles(attacker, targetCoord);
		if (testTargets.Length != 0)
		{
			testTargets.CopyTo(attacker.AttackTargets);
			Unit unit = attacker;
			WeaponAttributes rangedWeapon = attacker.RangedWeapon;
			bool costsAP = false;
			string abilityAnimationName = GetAbilityAnimationName();
			Combat.CombatMinigame minigame = ((attacker.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
			unit.StartAttack(rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, abilityAnimationName, 1, minigame);
			yield return Wait.ForChildren;
		}
		else
		{
			attacker.popupBar.Enqueue("ABILITYWHEELDISABLED_NOTARGETS");
			yield return Wait.While(attacker.popupBar.IsPopUpVisable);
			yield return Wait.ForSeconds(0.75f);
		}
		pp.StopParticles();
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		attacker = unit;
		targetCoord = selection[0];
		Routine.Start(areaShotRoutine);
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (isActive)
		{
			float newVal = barData.GetBarSizeValue(BarTypes.Hit) / 3f;
			barData.SetBarSizeValue(BarTypes.Hit, newVal);
		}
	}

	private void GetValidTargets(Unit unit, v2i coord, ConstArray<Unit> targets)
	{
		Unit.GatherUnitsInRadius(coord, (!base.IsUpgraded) ? 2f : 3f, targets, ~unit.teamMask);
		for (uint num = 0u; num < targets.Length; num++)
		{
			Unit unit2 = targets[num];
			if (unit2.IsCloaked || !unit.map.HasLineOfSight(unit.coord, unit2.coord, isSideStepAllowed: false))
			{
				targets.RemoveAtIndex(num);
				num--;
			}
		}
	}
}
public class Ability_Hardiness : AbilityImplBase
{
	private const int kCritImmunityChance = 40;

	private const int kAugCritImmunityChance = 100;

	public override void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
		if ((!base.IsUpgraded) ? 40.PercentChance() : 100.PercentChance())
		{
			if ((barData.whamState & WhamStates.Crit) != 0)
			{
				barData.whamState &= (WhamStates)(-3);
			}
			barData.defaultResult = UIWhamBar.WhamResult.Hit;
		}
	}
}
public class Ability_Reflex : AbilityImplBase
{
	private const int kRange = 3;

	private const int kAugmentedRange = 4;

	private bool reflexActive;

	public bool firedThisTurn;

	private Unit target;

	private HagletResettable reflexRoutine;

	public override void OnUnitSpawn(Unit unit)
	{
		reflexRoutine = new HagletResettable(ReflexRoutine());
	}

	public override void OnUnitTurnModeBegin(Unit unit)
	{
		int num = ((!base.IsUpgraded) ? 3 : 4);
		unit.OnEnterOverwatch(num, closeRange: true);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		unit.OnExitOverwatch();
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		firedThisTurn = false;
	}

	public override bool OnUnitEnteredCoord(Unit unit, Unit unitEnteringCoord, v2i startCoord)
	{
		if (!GC.Inst.IsInTurnMode() || GC.Inst.InCutsceneMode())
		{
			return false;
		}
		if (firedThisTurn)
		{
			return false;
		}
		if (unitEnteringCoord.IsCloaked)
		{
			return false;
		}
		if (unitEnteringCoord.teamType == unit.teamType)
		{
			return false;
		}
		if (unit.teamType == UnitTeam.Type.NPC)
		{
			return false;
		}
		if (unitEnteringCoord.coord == unit.coord)
		{
			return false;
		}
		target = unitEnteringCoord;
		Routine.Start(reflexRoutine);
		return false;
	}

	private IEnumerator<HagletYieldTerm> ReflexRoutine()
	{
		target.UpdateIdleAnim();
		owner.AimAtTarget(target._GetTransform().position);
		yield return PlayAbilityEffects();
		PlayParticles(owner);
		reflexActive = true;
		Unit unit = owner;
		Unit unit2 = target;
		WeaponAttributes rangedWeapon = owner.RangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((owner.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(unit2, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
		firedThisTurn = true;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (reflexActive)
		{
			reflexActive = false;
			return -0.5f;
		}
		return 0f;
	}
}
public class Ability_Auto_Cover : AbilityImplBase
{
	private bool attackedThisTurn;

	private Ability_Hunker_Down hunkerDown;

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		attackedThisTurn = true;
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		attackedThisTurn = false;
		CleanUp(unit);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		CleanUp(unit);
	}

	private void CleanUp(Unit unit)
	{
		if (hunkerDown != null)
		{
			unit.abilities.Remove(hunkerDown);
			hunkerDown.isProxy = false;
			hunkerDown = null;
		}
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		if (unit.map.GetAdjacentCoverDirection(unit.coord, out var _) && (!attackedThisTurn || base.IsUpgraded) && !isCombatEnd)
		{
			hunkerDown = unit.abilities.Add<Ability_Hunker_Down>(this, isUpgraded: false);
			hunkerDown.isProxy = true;
			hunkerDown.OnActivateImmediatelyBase(unit, default(UIAbilityWheelChoice));
		}
	}
}
[Serializable]
public class Ability_Piercing_Bullet : AbilityImplBase
{
	private bool applyRangedDamageBoost;

	private const int damageBoost = 1;

	private const int damageBoostAugmented = 2;

	public override void OnUnitTurnBegin(Unit unit)
	{
		applyRangedDamageBoost = true;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		if (applyRangedDamageBoost && weapon.IsRanged)
		{
			unit.popupBar.Enqueue("POPUPBAR_ABILITY_PIERCINGBULLET");
		}
	}

	public override int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (!applyRangedDamageBoost || !weapon.IsRanged)
		{
			return 0;
		}
		return (!base.IsUpgraded) ? 1 : 2;
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (weapon.IsRanged)
		{
			applyRangedDamageBoost = false;
		}
	}
}
[Serializable]
public class Ability_Headshot : AbilityImplBase
{
	private const float kAccuracyPenalty = -0.2f;

	private bool selected;

	private float accuracyModifier;

	private ParticlePrefab pp;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Triggerman)
		{
			return (unit.AP == 0) ? 1 : unit.AP;
		}
		return 1;
	}

	public override int CooldownMax()
	{
		return 2;
	}

	public override void OnSelectionBegin(Unit unit)
	{
		accuracyModifier = ((!base.IsUpgraded) ? (-0.2f) : 0f);
		selected = true;
	}

	public override void OnSelectionCancel(Unit unit)
	{
		accuracyModifier = 0f;
		selected = false;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return accuracyModifier;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		base.Cooldown = CooldownMax();
		WeaponAttributes rangedWeapon = unit.RangedWeapon;
		Unit unit2 = selection[0];
		Unit target = unit2;
		WeaponAttributes weapon = rangedWeapon;
		bool costsAP = false;
		Combat.CombatMinigame minigame = ((unit.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		bool flag = unit.StartAttack(target, weapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, minigame);
		pp = PlayParticles(unit2);
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		selected = false;
		accuracyModifier = 0f;
		if (pp != null)
		{
			pp.StopParticles();
		}
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (!selected)
		{
			return;
		}
		if ((barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
		if (base.IsUpgraded)
		{
			if ((barData.whamState & WhamStates.Hit) != 0)
			{
				barData.whamState &= (WhamStates)(-2);
			}
			barData.SetBarSizeValue(BarTypes.Crit, barData.GetBarSizeValue(BarTypes.Hit));
			barData.SetBarPositionValue(BarTypes.Crit, barData.GetBarPositionValue(BarTypes.Hit));
		}
		else if ((barData.whamState & WhamStates.Hit) != 0)
		{
			barData.whamState &= (WhamStates)(-2);
		}
	}
}
[Serializable]
public class Ability_Ricochet : AbilityImplBase
{
	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override int CooldownMax()
	{
		return (!base.IsUpgraded) ? 3 : 2;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool RequiresAttack()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return false;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Attack;
	}

	public override int APCost(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Triggerman)
		{
			return (unit.AP == 0) ? 1 : unit.AP;
		}
		return 1;
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		Unit unit2 = selection[0];
		Combat.CombatData combatData = default(Combat.CombatData);
		combatData.hitChance = unit.GetHitChance(unit.coord, unit2, unit2.coord, unit.RangedWeapon, reactionAttack: false, isCombatCalculation: true, ignoreCover: true);
		combatData.critChance = unit.GetCriticalHitChance(unit2, unit.RangedWeapon, isCombatCalculation: true);
		combatData.dodgeChance = unit2.GetDodgeChance(unit);
		combatData.critSize = unit.GetCriticalHitSize(unit2, unit.RangedWeapon, isCombatCalculation: true);
		combatData.dodgeSize = unit2.GetDodgeSize(unit);
		combatData.weapon = owner.RangedWeapon;
		combatData.additionalEffect = Combat.HitType.None;
		if (unit.teamType == UnitTeam.Type.Player)
		{
			combatData.whamState = unit.GetDefaultWhamState(Combat.CombatMinigame.AttackWhamBar, combatData, unit2);
		}
		else
		{
			combatData.whamState = unit.GetDefaultWhamState(Combat.CombatMinigame.DodgeWhamBar, combatData, unit2);
		}
		combatData.attacker = unit;
		combatData.target = unit2;
		Unit target = unit2;
		WeaponAttributes rangedWeapon = unit.RangedWeapon;
		bool costsAP = false;
		Combat.CombatData? overrideCombatData = combatData;
		Combat.CombatMinigame minigame = ((unit.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
		unit.StartAttack(target, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: true, null, 1, minigame, overrideCombatData, updateIdleOnComplete: true, Unit.Bullet.BulletType.Ricochet);
	}
}
[Serializable]
public class Ability_Pick_Off : AbilityImplBase
{
	private const int critBuff = 15;

	private bool isExposed;

	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		CoverType coverBetween = attacker.map.GetCoverBetween(attackerCoord, targetCoord);
		if (isExposed)
		{
			return 15;
		}
		return 0;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		Unit unit2 = unit.AttackTargets[0];
		CoverType coverBetween = unit.map.GetCoverBetween(unit.coord, unit2.coord);
		if (isExposed = coverBetween.Is(CoverType.None) || coverBetween.Is(CoverType.Flanked))
		{
			PlayParticles(unit);
		}
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		CoverType coverBetween = unit.map.GetCoverBetween(unit.coord, target.coord);
		if ((coverBetween.Is(CoverType.None) || (coverBetween.Is(CoverType.Flanked) && base.IsUpgraded)) && (barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}
}
[Serializable]
public class Ability_Focus : AbilityImplBase
{
	private const float kAccuracyBuff = 0.5f;

	private const float kCriticalBuff = 0.5f;

	private bool focusActive;

	private ParticlePrefab pp;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (focusActive && weapon.IsRanged)
		{
			return 0.5f;
		}
		return 0f;
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (focusActive && base.IsUpgraded)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		focusActive = true;
		pp = PlayParticles(unit);
		unit.popupBar.Enqueue("POPUPBAR_ABILITY_FOCUS");
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (weapon.IsRanged)
		{
			CancelFocus(unit);
		}
	}

	public override void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
		CancelFocus(unit);
	}

	public override void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
		CancelFocus(unit);
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		CancelFocus(unit);
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	private void CancelFocus(Unit unit)
	{
		if (focusActive)
		{
			focusActive = false;
			pp.StopParticles();
		}
	}
}
[Serializable]
public class Ability_Far_Shot : AbilityImplBase
{
	private const int k5TileDamage = 1;

	private const int k10TileDamage = 2;

	private bool shouldStun;

	private const int kAccuracyDebuffAugment = -20;

	private float distToTarget;

	public override int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (weapon.IsRanged)
		{
			if (distToTarget >= 10f)
			{
				return 2;
			}
			if (distToTarget >= 5f)
			{
				return 1;
			}
		}
		return 0;
	}

	public override void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
		Unit unit2 = unit.AttackTargets[0];
		distToTarget = v2i.Distance(unit2.coord, unit.coord);
		if (distToTarget >= 5f)
		{
			PlayAbilityEffects();
			PlayParticles(unit);
		}
		shouldStun = unit.IsAlive() && base.IsUpgraded && weapon != null && weapon.IsRanged && distToTarget >= 8f;
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon = null)
	{
		if (shouldStun)
		{
			barData.whamState |= WhamStates.Status;
			barData.SetBarPositionValue(BarTypes.Status, barData.GetBarPositionValue(BarTypes.Hit));
			barData.SetBarSizeValue(BarTypes.Status, barData.GetBarSizeValue(BarTypes.Hit) / 2f);
			barData.SetSpriteOverride(BarTypes.Status, meta.overrideSprite);
			barData.SetBarOverlay(BarTypes.Status, Overlay: true);
		}
	}

	public override void OnUnitTargetRecievedHitType(Unit unit, Unit target, Combat.HitType hitType)
	{
		if (shouldStun && hitType == Combat.HitType.Status)
		{
			target.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			target.popupBar.Enqueue("POPUPBAR_ABILITY_FARSHOT_STUNNED");
		}
	}
}
[Serializable]
public class Ability_Spot : AbilityImplBase
{
	private const float kAccuracyBoost = 0.2f;

	private const int kCriticalBoostAugmented = 20;

	private Unit target;

	private ParticlePrefab pp;

	private Ability_Spot_Proxy proxy;

	private HagletResettable spotRoutine;

	public override void OnUnitSpawn(Unit unit)
	{
		spotRoutine = new HagletResettable(SpotRoutine());
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool RequireUnitSelection()
	{
		return true;
	}

	public override uint SelectionMask(Unit unit)
	{
		return ~unit.teamMask & ~UnitTeam.Type.NPC.ToMask();
	}

	protected override void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		base.Cooldown = CooldownMax();
		target = selection[0];
		proxy = target.abilities.Add<Ability_Spot_Proxy>(this, isUpgraded: false);
		proxy.accuracyBoost = 0.2f;
		proxy.isSpotAugmented = base.IsUpgraded;
		proxy.criticalBoost = (base.IsUpgraded ? 20 : 0);
		pp = PlayParticles(target);
		target.popupBar.Enqueue("POPUPBAR_ABILITY_SPOT");
		Routine.Start(spotRoutine);
	}

	private IEnumerator<HagletYieldTerm> SpotRoutine()
	{
		yield return owner.unitModel.Play(GetAbilityAnimationName(), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		RemoveSpot();
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		RemoveSpot();
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override bool SelectionRequireLineOfSight(Unit unit)
	{
		return true;
	}

	private void RemoveSpot()
	{
		if (target != null)
		{
			target.abilities.Remove(proxy);
			pp.StopParticles();
			target = null;
			proxy = null;
		}
	}
}
[Serializable]
public class Ability_Spot_Proxy : AbilityImplBase
{
	public float accuracyBoost;

	public bool isSpotAugmented;

	public int criticalBoost;

	public override bool IsProxyAbility()
	{
		return true;
	}

	public override float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		return accuracyBoost;
	}

	public override int GetTargettedCriticalHitChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, bool isCombatCalculation)
	{
		return criticalBoost;
	}

	public override void AppendStatusEffects(StatusEffects effects)
	{
		effects.Add(StatusEffect.Create(StatusEffect.Type.Spotted, this, 1));
	}
}
[Serializable]
public class Ability_Graze : AbilityImplBase
{
	private const int kGrazeDamageModAugmented = 1;

	public override int GetTargetedGrazeDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return base.IsUpgraded ? 1 : 0;
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (!unit.IsPerformingAbilityAttack)
		{
			barData.backgroundSpriteOverride = meta.overrideSprite;
			barData.backgroundResult = UIWhamBar.WhamResult.Graze;
			if ((barData.whamState & WhamStates.Dodge) != 0)
			{
				barData.whamState &= (WhamStates)(-5);
			}
			if ((barData.whamState & WhamStates.Graze) != 0)
			{
				barData.whamState &= (WhamStates)(-9);
			}
		}
	}
}
public class Ability_Overwatch : AbilityImplBase
{
	private bool stunEnemy;

	public override bool IsAvailableInTutorial()
	{
		return true;
	}

	public override int APCost(Unit unit)
	{
		return Mathf.Max(unit.AP, 1);
	}

	public override int CooldownMax()
	{
		return 1;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (unit.charData.Class == CharacterClass.Soldier)
		{
			return AbilityBarkType.Attack;
		}
		if (unit.charData.Class == CharacterClass.Triggerman)
		{
			return AbilityBarkType.Defence;
		}
		return AbilityBarkType.General;
	}

	protected override void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
		unit.OnEnterOverwatch(float.MaxValue, closeRange: true);
		unit.popupBar.Enqueue("POPUPBAR_ABILITY_OVERWATCH");
		PlayParticles(unit);
	}

	public override bool OnUnitEnteredCoord(Unit unit, Unit unitEnteringCoord, v2i startCoord)
	{
		if (!unitEnteringCoord.IsCloaked)
		{
			unitEnteringCoord.UpdateIdleAnim();
			if (base.IsUpgraded)
			{
				stunEnemy = true;
			}
			WeaponAttributes rangedWeapon = unit.RangedWeapon;
			bool costsAP = false;
			Combat.CombatMinigame minigame = ((unit.teamType == UnitTeam.Type.Player) ? Combat.CombatMinigame.AttackWhamBar : Combat.CombatMinigame.DodgeWhamBar);
			unit.StartAttack(unitEnteringCoord, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: true, isAbilityAttack: false, null, 1, minigame);
			unit.OnExitOverwatch();
			return base.IsUpgraded;
		}
		return false;
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (stunEnemy && (hitType == Combat.HitType.Hit || hitType == Combat.HitType.HitCritical) && target.IsAlive())
		{
			target.abilities.Add<Ability_Stunned_Proxy>(this, isUpgraded: false);
			stunEnemy = false;
		}
	}

	public override void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
		if (stunEnemy)
		{
			stunEnemy = false;
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (unit.IsInOverwatch)
		{
			unit.OnExitOverwatch();
		}
	}
}
[Serializable]
public class Ability_Overview : AbilityImplBase
{
	private const int kCritChanceBoostPerEnemy = 10;

	private const float kAccuracyBoostPerEnemy = 0.1f;

	private int enemiesSeen;

	private ParticlePrefab overviewPS;

	public override int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		int num = CalculateNumberOfEnemiesSeen(attacker.map, attackerCoord, attacker.teamType);
		int num2 = Math.Max(num - 1, 0);
		return num2 * 10;
	}

	public override float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (base.IsUpgraded)
		{
			int num = Math.Max(enemiesSeen - 1, 0);
			return (float)num * 0.1f;
		}
		return 0f;
	}

	private int CalculateNumberOfEnemiesSeen(Map map, v2i unitCoord, UnitTeam.Type unitTeam)
	{
		int unitsSeen = 0;
		for (int i = 0; i < 4; i++)
		{
			if (i != 2 && i != (int)unitTeam)
			{
				GetLineOfSightAgainstTeam(map, unitCoord, (UnitTeam.Type)i, ref unitsSeen);
			}
		}
		return unitsSeen;
	}

	private void GetLineOfSightAgainstTeam(Map map, v2i unitCoord, UnitTeam.Type teamType, ref int unitsSeen)
	{
		ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType(teamType).GetActiveMembers();
		for (int i = 0; i < activeMembers.Length; i++)
		{
			if (map.HasLineOfSight(unitCoord, activeMembers[i].coord, isSideStepAllowed: true))
			{
				unitsSeen++;
			}
		}
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		enemiesSeen = CalculateNumberOfEnemiesSeen(unit.map, unit.coord, unit.teamType);
		if (enemiesSeen > 1)
		{
			PlayEffect(unit);
		}
	}

	public override void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
		CleanUpEffect();
	}

	public override void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
		CleanUpEffect();
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		CleanUpEffect();
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		CleanUpEffect();
	}

	public override void OnUnitMoveEnd(Unit unit)
	{
		enemiesSeen = CalculateNumberOfEnemiesSeen(unit.map, unit.coord, unit.teamType);
		if (enemiesSeen > 1)
		{
			PlayEffect(unit);
		}
	}

	private void PlayEffect(Unit unit)
	{
		if (overviewPS == null && GC.Inst.GetState() == GC.State.Combat)
		{
			overviewPS = PlayParticles(unit);
		}
	}

	private void CleanUpEffect()
	{
		if (overviewPS != null)
		{
			overviewPS.StopParticles();
			overviewPS = null;
		}
	}
}
[Serializable]
public class Ability_Triggerman_Attack : AbilityImplBase
{
	public override int GetUnitAttackAPModifier(Unit unit)
	{
		return unit.AP;
	}
}
[Serializable]
public class Ability_Second_Shot : AbilityImplBase
{
	private bool hasOccurredThisTurn;

	public override void OnUnitTurnBegin(Unit unit)
	{
		hasOccurredThisTurn = false;
	}

	public override void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		if (hasOccurredThisTurn || (hitType != Combat.HitType.Hit && hitType != Combat.HitType.HitCritical))
		{
			return;
		}
		if (base.IsUpgraded)
		{
			UseSecondShot(unit);
			return;
		}
		for (int i = 0; i < unit.AttackTargets.Length; i++)
		{
			if (!unit.AttackTargets[i].IsAlive())
			{
				UseSecondShot(unit);
				break;
			}
		}
	}

	private void UseSecondShot(Unit unit)
	{
		PlayParticles(unit);
		int num = 1;
		UIUnitPopupBar popupBar = unit.popupBar;
		string desc = "POPUPBAR_ABILITY_SECONDSHOT";
		int? localisationNumber = num;
		popupBar.Enqueue(desc, 0, 0f, null, null, localisationNumber);
		unit.APDecrement(-num);
		hasOccurredThisTurn = true;
	}
}
[Serializable]
public class Ability_Lookout : AbilityImplBase
{
	private const float kRadius = 2f;

	private const float kUpgradedRadius = 3f;

	private const int kLookoutTurns = 2;

	private v2i lookoutSource;

	private int lookoutCountdown;

	private ParticlePrefab lookoutPS;

	public override AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		return AbilityBarkType.Defence;
	}

	public override bool RequireTileSelection()
	{
		return true;
	}

	public override int APCost(Unit unit)
	{
		return 1;
	}

	public override int CooldownMax()
	{
		return 3;
	}

	public override bool IsManuallyActivated()
	{
		return true;
	}

	public override VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		return VFXTileController.TileType.AreaSelectionOffensive;
	}

	public override float SelectionEffectRange(Unit unit)
	{
		return (!base.IsUpgraded) ? 2f : 3f;
	}

	protected override void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		UnitTeam.Type type = ((owner.teamType == UnitTeam.Type.Player) ? UnitTeam.Type.Enemy : UnitTeam.Type.Player);
		lookoutSource = selection[0];
		lookoutCountdown = 2;
		unit.unitModel.Play(GetAbilityAnimationName(), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		lookoutPS = PlayParticles(unit, lookoutSource);
	}

	public override void OnUnitTurnBegin(Unit unit)
	{
		if (lookoutCountdown > 0)
		{
			lookoutCountdown--;
			if (lookoutCountdown == 0)
			{
				CleanUpLookout();
			}
		}
	}

	public override void OnUnitCombatModeEnd(Unit unit)
	{
		if (lookoutCountdown > 0)
		{
			CleanUpLookout();
		}
	}

	public override void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
		if (lookoutCountdown > 0 && v2i.Distance(lookoutSource, target.coord) <= ((!base.IsUpgraded) ? 2f : 3f) && (barData.whamState & WhamStates.Crit) == 0)
		{
			barData.whamState |= WhamStates.Crit;
		}
	}

	public override void OnUnitDeathComplete(Unit unit)
	{
		CleanUpLookout();
	}

	private void CleanUpLookout()
	{
		lookoutCountdown = 0;
		if (lookoutPS != null)
		{
			lookoutPS.StopParticles();
			lookoutPS = null;
		}
	}
}
[Serializable]
[CreateAssetMenu]
public class AbilityMeta : AEScriptableResource
{
	[SerializeField]
	[ReadOnly]
	private string _Name;

	[SerializeField]
	[HideInInspector]
	private string _NameImpl;

	public string DisplayName;

	[SerializeField]
	[ReadOnly]
	private Sprite icon;

	[SerializeField]
	[ReadOnly]
	private Sprite slotChampIcon;

	public string animationName;

	public string backupAnimationName = "CombatUseItem";

	public ParticleTypes particleEffect;

	public ParticleTypes upgradedParticleEffect;

	public Sprite overrideSprite;

	[TextArea(5, 10)]
	public string description;

	[TextArea(5, 10)]
	public string augmentDescription;

	public AbilityMeta[] subAbilities;

	public string Name => _Name;

	private new string name => base.name;

	public string NameImpl => _NameImpl;

	public Sprite Icon => icon;

	public Sprite SlotChampIcon => slotChampIcon;

	public Type GetImplementationType()
	{
		if (string.IsNullOrEmpty(_NameImpl))
		{
			return null;
		}
		return typeof(AbilityImplBase).Assembly.GetType(_NameImpl);
	}

	public string GetDisplayName(CharacterData charData = null)
	{
		if (charData == null)
		{
			return (!(DisplayName == string.Empty)) ? DisplayName : Name;
		}
		Type implementationType = GetImplementationType();
		if (implementationType == typeof(Ability_Secondary_Attack))
		{
			switch (charData.partyMemberID)
			{
			case PartyMemberID.Margot:
				return "THROWING KNIVES";
			case PartyMemberID.Ambrosia:
				return "CONCUSSIVE SHOT";
			case PartyMemberID.Noot:
				return "PEA SHOOTER";
			}
		}
		return (!(DisplayName == string.Empty)) ? DisplayName : Name;
	}
}
public enum AbilityWheelVisibility
{
	Enabled,
	Disabled,
	Cooldown,
	Hidden
}
public enum AbilityBarkType
{
	None,
	General,
	Attack,
	Defence,
	Taunt,
	Scan
}
public struct QuantityInfo
{
	public bool visible;

	public int amount;
}
[Serializable]
public abstract class AbilityImplBase
{
	[Flags]
	public enum AbilityMode
	{
		None = 0,
		Combat = 1,
		Stealth = 2,
		RPG = 4
	}

	public const int kMaxSelectedUnits = 3;

	public const int kMaxSelectedTiles = 1;

	public AbilityMeta meta;

	private HagletResettable playAbilityEffectsRoutine;

	private HagletResettable onActivateImmediatelyBaseRoutine;

	private HagletResettable onActivateWithTilesSelectedBaseRoutine;

	private HagletResettable onActivateWithUnitsSelectedRoutine;

	private Unit castingUnit;

	private ConstArray<Unit> unitSelection = new ConstArray<Unit>(3u);

	private ConstArray<v2i> tileSelection = new ConstArray<v2i>(1u);

	private UIAbilityWheelChoice abilityChoice;

	public Unit owner;

	public AbilityImplBase caster;

	public bool HACK_isUpgraded;

	public bool isActive;

	private Func<Unit, bool> _extraUnitFilter;

	private Func<v2i, bool> _extraTileFilter;

	private VFXTileController.TileAreaVFXDel _tileSelectionVFX;

	private int _cooldownRemaining;

	private bool _cooldownSetThisTurn;

	public bool Enabled = true;

	private bool playAbilitySound;

	private string abilityPopup = string.Empty;

	public bool IsUpgraded => HACK_isUpgraded;

	public VFXTileController.TileAreaVFXDel tileSelectionVFX => _tileSelectionVFX ?? (_tileSelectionVFX = GetTileSelectionVFX);

	public int Cooldown
	{
		get
		{
			return _cooldownRemaining;
		}
		set
		{
			_cooldownRemaining = value;
			_cooldownSetThisTurn = true;
		}
	}

	public Func<Unit, bool> extraUnitFilter => (Unit unit) => ValidateUnitSelection(owner, unit);

	public Func<v2i, bool> extraTileFilter => (v2i coord) => ValidateTileSelection(owner, coord);

	public bool HasCooldownRemaining => _cooldownRemaining > 0;

	public bool IsAbilityAvailableInCurrentState
	{
		get
		{
			AbilityMode abilityModeForCurrentGameState = GetAbilityModeForCurrentGameState();
			return (GetAbilityMode() & abilityModeForCurrentGameState) == abilityModeForCurrentGameState;
		}
	}

	public AbilityImplBase()
	{
		playAbilityEffectsRoutine = new HagletResettable(PlayAbilityEffectsRoutine());
		onActivateImmediatelyBaseRoutine = new HagletResettable(OnActivateImmediatelyBaseRoutine());
		onActivateWithTilesSelectedBaseRoutine = new HagletResettable(OnActivateWithTilesSelectedBaseRoutine());
		onActivateWithUnitsSelectedRoutine = new HagletResettable(OnActivateWithUnitsSelectedRoutine());
	}

	public AbilityMode GetAbilityModeForCurrentGameState()
	{
		return GC.Inst.GetState() switch
		{
			GC.State.Combat => AbilityMode.Combat, 
			GC.State.Stealth => AbilityMode.Stealth, 
			GC.State.RPG => AbilityMode.RPG, 
			_ => AbilityMode.None, 
		};
	}

	public virtual AbilityBarkType GetAbilityBarkType(Unit unit)
	{
		if (IsManuallyActivated())
		{
			return AbilityBarkType.General;
		}
		return AbilityBarkType.None;
	}

	public virtual bool IsAvailableInTutorial()
	{
		return false;
	}

	public virtual void OnUnitSpawn(Unit unit)
	{
	}

	public virtual void OnUnitTurnModeBegin(Unit unit)
	{
	}

	public virtual void OnUnitCombatModeEnd(Unit unit)
	{
	}

	public virtual void OnUnitTurnBegin(Unit unit)
	{
	}

	public virtual void OnUnitTurnEnd(Unit unit, bool isCombatEnd)
	{
	}

	public virtual void OnUnitMoveBegin(Unit unit, v2i targetCoord)
	{
	}

	public virtual void OnUnitMoveEnd(Unit unit)
	{
	}

	public virtual void OnUnitStartedVault(Unit unit, v2i vaultStart, v2i vaultEnd)
	{
	}

	public virtual void OnUnitVaulted(Unit unit, v2i vaultStart, v2i vaultEnd)
	{
	}

	public virtual void OnUnitMapTransitionBegin(Unit unit)
	{
	}

	public virtual void OnOtherUnitMapTransitionBegin(Unit unit, Unit other)
	{
	}

	public virtual void OnOtherUnitEnteredCoord(Unit unit, Unit other, v2i coord)
	{
	}

	public virtual void OnUnitUsedAbility(Unit unit, AbilityImplBase ability)
	{
	}

	public virtual void OnUnitAttackBegin(Unit unit, WeaponAttributes weapon)
	{
	}

	public virtual void OnUnitAttackPostWhamBar(Unit unit)
	{
	}

	public virtual void OnUnitAttackEnd(Unit unit, WeaponAttributes weapon)
	{
	}

	public virtual int GetAdditionalAttacks(Unit unit, WeaponAttributes weapon)
	{
		return 0;
	}

	public virtual int OnUnitWillBeDamaged(Unit unit, int damage, Unit attacker, Combat.HitType hitType)
	{
		return damage;
	}

	public virtual int OnUnitAPWillChange(Unit unit, int amount)
	{
		return amount;
	}

	public virtual void OnUnitSustainedDamage(Unit unit, Unit attacker, int amount, WeaponAttributes weapon = null)
	{
	}

	public virtual void OnUnitAvoidedDamage(Unit unit, Unit attacker, WeaponAttributes weapon = null)
	{
	}

	public virtual void OnUnitRestoredHealth(Unit unit)
	{
	}

	public virtual void OnUnitDeathBegun(Unit unit)
	{
	}

	public virtual void OnUnitDeathComplete(Unit unit)
	{
	}

	public virtual int OnUnitTargetWillSustainDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
		return damageAmount;
	}

	public virtual void OnUnitTargetRecievedHitType(Unit unit, Unit target, Combat.HitType hitType)
	{
	}

	public virtual void OnUnitTargetSustainedDamage(Unit unit, Unit target, Combat.HitType hitType, int damageAmount, WeaponAttributes weapon = null)
	{
	}

	public virtual void OnUnitTargetAvoidedDamage(Unit unit, Unit target, Combat.HitType hitType, WeaponAttributes weapon = null)
	{
	}

	public virtual void OnUnitChangedTeam(Unit unit, UnitTeam.Type teamType)
	{
	}

	public virtual void OnUnitAttackedBegin(Unit unit, Unit attacker, WeaponAttributes attackerWeapon, bool reactionAttack)
	{
	}

	public virtual void OnUnitAttackedEnd(Unit unit, Unit attacker, bool reactionAttack, Combat.HitType hitType, Combat.HitType additionalEffect)
	{
	}

	public virtual bool OnUnitAttackShouldUncloak(Unit unit)
	{
		return true;
	}

	public virtual bool OnUnitAttackTargetSuppressWound(Unit unit, Unit target)
	{
		return false;
	}

	public virtual bool OnUnitAttackedShouldCancel(Unit unit, Unit attacker)
	{
		return false;
	}

	public virtual bool OnUnitEnteredCoord(Unit unit, Unit unitEnteringCoord, v2i startCoord)
	{
		return false;
	}

	public virtual bool IsManuallyActivated()
	{
		return false;
	}

	public virtual bool IsManualHitAnimation()
	{
		return false;
	}

	public virtual bool IsTeamAbility()
	{
		return false;
	}

	public virtual AbilityWheelVisibility IsAvailableOnWheel(Unit unit, UITextbox contextToFill = null)
	{
		return AbilityWheelVisibility.Enabled;
	}

	public virtual int GetPriority()
	{
		if (IsManuallyActivated())
		{
			return 0;
		}
		return 10;
	}

	public virtual bool RequiresMovement()
	{
		return false;
	}

	public virtual bool RequiresPathing()
	{
		return false;
	}

	public virtual bool RequiresAttack()
	{
		return false;
	}

	public virtual float GetTargettedAccuracyChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual float GetUnitAccuracyChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual int GetUnitCriticalHitChanceModifier(Unit attacker, v2i attackerCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 0;
	}

	public virtual int GetTargettedCriticalHitChanceModifier(Unit target, v2i targetCoord, Unit attacker, v2i attackerCoord, bool isCombatCalculation)
	{
		return 0;
	}

	public virtual int GetUnitDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return 0;
	}

	public virtual float GetTargettedDodgeChanceModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual float GetUnitCriticalHitSizeModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual float GetTargettedCriticalHitSizeModifier(Unit target, Unit attacker, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual float GetUnitDodgeSizeModifier(Unit unit, Unit target, bool reactionAttack, bool isCombatCalculation)
	{
		return 0f;
	}

	public virtual int GetTargetedGrazeDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 0;
	}

	public virtual int GetUnitDamageModifier(Unit unit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		return 0;
	}

	public virtual int GetUnitAttackAPModifier(Unit unit)
	{
		return 0;
	}

	public virtual void ApplyAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
	}

	public virtual void ApplyTargetedAttackWhamBarModifiers(Unit unit, Unit target, whamBarData barData)
	{
	}

	public virtual void ApplyDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, bool isReaction)
	{
	}

	public virtual void ApplyAttackerDodgeWhamBarModifiers(Unit unit, Unit target, whamBarData barData, WeaponAttributes weapon)
	{
	}

	public virtual string OverrideWhamResultText(Unit unit, UIWhamBar.WhamResult result, string orginal)
	{
		return orginal;
	}

	public virtual bool GetUnitAttackingDisabled(Unit unit)
	{
		return false;
	}

	public virtual bool GetUnitMovementDisabled(Unit unit)
	{
		return false;
	}

	public virtual bool GetUnitTargetable(Unit unit)
	{
		return true;
	}

	public virtual int GetUnitMaxMoveDistanceModifier(Unit unit)
	{
		return 0;
	}

	public virtual int GetUnitAPMaxModifier(Unit unit)
	{
		return 0;
	}

	public virtual int GetUnitHPMaxModifier(Unit unit)
	{
		return 0;
	}

	public virtual bool RequireUnitSelection()
	{
		return false;
	}

	public virtual bool RequireTileSelection()
	{
		return false;
	}

	public virtual bool RequireTileUnblocked()
	{
		return true;
	}

	public virtual int SelectionRange(Unit unit)
	{
		return int.MaxValue;
	}

	public virtual float SelectionEffectRange(Unit unit)
	{
		if (RequireTileSelection())
		{
			return 0.5f;
		}
		return 0f;
	}

	public virtual bool SelectionRequireLineOfSight(Unit unit)
	{
		return false;
	}

	public virtual bool SelectionAllowStepOut(Unit unit)
	{
		return true;
	}

	public virtual uint SelectionMask(Unit unit)
	{
		return unit.teamMask;
	}

	public virtual bool SelectionIncludeSelf(Unit unit)
	{
		return true;
	}

	public virtual void OnSelectionBegin(Unit unit)
	{
	}

	public virtual void OnSelectionCancel(Unit unit)
	{
	}

	protected virtual void OnActivateImmediately(Unit unit, UIAbilityWheelChoice choice)
	{
	}

	protected virtual void OnActivateWithUnitsSelected(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
	}

	protected virtual void OnActivateWithTilesSelected(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
	}

	public virtual void OnUnitStunned(Unit unit)
	{
	}

	public virtual int APCost(Unit unit)
	{
		return 0;
	}

	public virtual int CooldownMax()
	{
		return 0;
	}

	public virtual void OnAbilityCasted()
	{
	}

	public virtual void OnAbilityUncasted()
	{
	}

	public virtual AbilityMode GetAbilityMode()
	{
		return AbilityMode.Combat;
	}

	public virtual bool IsProxyAbility()
	{
		return false;
	}

	public virtual string GetUnitAttackAnimName()
	{
		return null;
	}

	public virtual string GetUnitDeathAnimName()
	{
		return null;
	}

	public virtual Unit.HologramAnim GetUnitDeathHologramAnim()
	{
		return Unit.HologramAnim.UNIT_DEATH;
	}

	public virtual Combat.CombatMinigame OverrideAttackMinigame(Combat.CombatMinigame currentMinigame)
	{
		return currentMinigame;
	}

	public virtual void OnUserFocusedOnUnit(Unit unit)
	{
	}

	public virtual void OnUserUnFocusedOnUnit(Unit unit)
	{
	}

	public virtual void AppendStatusEffects(StatusEffects effects)
	{
	}

	public virtual QuantityInfo GetQuantityInfo(int abilitySubIdx)
	{
		return default(QuantityInfo);
	}

	public virtual int GetPendingDamage(Unit unit, Unit target)
	{
		return 0;
	}

	public virtual VFXTileController.TileType GetTileSelectionVFX(v2i centerCoord, v2i coord)
	{
		return VFXTileController.TileType.AreaSelection;
	}

	public void _OnAbilityTurnBegin()
	{
		_cooldownSetThisTurn = false;
	}

	public void _OnAbilityTurnEnd()
	{
		if (!_cooldownSetThisTurn && _cooldownRemaining > 0)
		{
			_cooldownRemaining--;
		}
	}

	public void _ResetCoolDown()
	{
		_cooldownRemaining = 0;
		_cooldownSetThisTurn = false;
	}

	protected virtual void DecrementAP(Unit unit)
	{
		if (IsManuallyActivated())
		{
			int num = APCost(unit);
			if (num > 0)
			{
				unit.APDecrement(num);
			}
		}
	}

	public void OnActivateWithTilesSelectedBase(Unit unit, ConstArray<v2i> selection, UIAbilityWheelChoice choice)
	{
		foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
		{
			item.OnUnitUsedAbility(unit, this);
		}
		Cooldown = CooldownMax();
		castingUnit = unit;
		selection.CopyTo(tileSelection);
		abilityChoice = choice;
		Routine.Start(onActivateWithTilesSelectedBaseRoutine);
	}

	private IEnumerator<HagletYieldTerm> OnActivateWithTilesSelectedBaseRoutine()
	{
		if (tileSelection[0] == castingUnit.coord)
		{
			yield return PlayAbilityEffects();
		}
		else
		{
			yield return PlayAbilityEffects() & Wait.While(castingUnit.LookAt(tileSelection[0]));
		}
		OnActivateWithTilesSelected(castingUnit, tileSelection, abilityChoice);
		DecrementAP(castingUnit);
		yield return Wait.ForChildren;
	}

	public void OnActivateWithUnitsSelectedBase(Unit unit, ConstArray<Unit> selection, UIAbilityWheelChoice choice)
	{
		if (SelectionRequireLineOfSight(unit))
		{
			Map activeMap = Singleton<MC>.Inst.GetActiveMap();
			for (int i = 0; i < selection.Length; i++)
			{
				if (selection[i] != null && !activeMap.HasLineOfSight(unit.coord, selection[i].coord, SelectionAllowStepOut(unit)))
				{
					return;
				}
			}
		}
		foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
		{
			item.OnUnitUsedAbility(unit, this);
		}
		Cooldown = CooldownMax();
		castingUnit = unit;
		selection.CopyTo(unitSelection);
		abilityChoice = choice;
		Routine.Start(onActivateWithUnitsSelectedRoutine);
	}

	private IEnumerator<HagletYieldTerm> OnActivateWithUnitsSelectedRoutine()
	{
		if (castingUnit == unitSelection[0])
		{
			yield return PlayAbilityEffects();
		}
		else
		{
			yield return PlayAbilityEffects() & Wait.While(castingUnit.LookAt(unitSelection[0]));
		}
		OnActivateWithUnitsSelected(castingUnit, unitSelection, abilityChoice);
		DecrementAP(castingUnit);
		yield return Wait.ForChildren;
	}

	public virtual bool ValidateTileSelection(Unit unit, v2i selection)
	{
		return true;
	}

	public virtual bool ValidateUnitSelection(Unit unit, Unit selection)
	{
		return true;
	}

	public virtual AbilityMeta GetAbilityWheelSubAbilityMetaAtIdx(int idx)
	{
		return null;
	}

	public virtual AbilityWheelVisibility GetAbilityWheelSubAbilityIsAvailableAtIdx(int idx, UITextbox contextToFill = null)
	{
		return AbilityWheelVisibility.Enabled;
	}

	public void OnActivateImmediatelyBase(Unit unit, UIAbilityWheelChoice choice)
	{
		foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
		{
			item.OnUnitUsedAbility(unit, this);
		}
		Cooldown = CooldownMax();
		castingUnit = unit;
		abilityChoice = choice;
		Routine.Start(onActivateImmediatelyBaseRoutine);
	}

	private IEnumerator<HagletYieldTerm> OnActivateImmediatelyBaseRoutine()
	{
		yield return PlayAbilityEffects();
		OnActivateImmediately(castingUnit, abilityChoice);
		DecrementAP(castingUnit);
		yield return Wait.ForChildren;
	}

	public bool IsUnitInMultiplayerFirstTurn(Unit unit)
	{
		return unit.GetTeam().IsFirstTurn && GC.Inst.IsInMultiplayer();
	}

	public AbilityWheelVisibility IsAvailable(Unit unit, UITextbox contextToFill = null)
	{
		if (!Enabled)
		{
			if ((bool)contextToFill)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_DISABLED");
			}
			return AbilityWheelVisibility.Disabled;
		}
		if (HasCooldownRemaining)
		{
			if ((bool)contextToFill)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_INCOOLDOWN", Cooldown);
			}
			return AbilityWheelVisibility.Cooldown;
		}
		if (IsUnitInMultiplayerFirstTurn(unit))
		{
			if ((bool)contextToFill)
			{
				contextToFill.Append("ABILITIES UNAVAILABLE FOR FIRST TURN");
			}
			return AbilityWheelVisibility.Disabled;
		}
		AbilityWheelVisibility abilityWheelVisibility = AbilityWheelVisibility.Enabled;
		if (owner.IsAbilityUseDisabled)
		{
			abilityWheelVisibility = AbilityWheelVisibility.Disabled;
			if ((bool)contextToFill)
			{
				if (!string.IsNullOrEmpty(owner.reasonForDisablingAbilities))
				{
					contextToFill.AppendKey(owner.reasonForDisablingAbilities);
				}
				else
				{
					contextToFill.AppendKey("ABILITYWHEELDISABLED_DISABLED");
				}
			}
		}
		else
		{
			abilityWheelVisibility = IsAvailableOnWheel(unit, contextToFill);
		}
		if (abilityWheelVisibility != 0)
		{
			return abilityWheelVisibility;
		}
		if (!IsAbilityAvailableInCurrentState)
		{
			if (GC.Inst.IsInRPGMode())
			{
				return AbilityWheelVisibility.Hidden;
			}
			if ((bool)contextToFill)
			{
				AbilityMode abilityModeForCurrentGameState = GetAbilityModeForCurrentGameState();
				if (abilityModeForCurrentGameState == AbilityMode.Combat)
				{
					contextToFill.AppendKey("ABILITYWHEELDISABLED_NOTINCOMBATMODE");
				}
			}
			return AbilityWheelVisibility.Disabled;
		}
		if (unit.AP < APCost(unit))
		{
			if ((bool)contextToFill)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_NOTENOUGHAP");
			}
			return AbilityWheelVisibility.Disabled;
		}
		if (RequiresAttack() && unit.IsAttackingDisabled)
		{
			if ((bool)contextToFill)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_REQATTACK");
			}
			return AbilityWheelVisibility.Disabled;
		}
		if (RequiresMovement() && unit.IsMovementDisabled)
		{
			if ((bool)contextToFill)
			{
				contextToFill.AppendKey("ABILITYWHEELDISABLED_REQMOVEMENT");
			}
			return AbilityWheelVisibility.Disabled;
		}
		return AbilityWheelVisibility.Enabled;
	}

	public HagletYieldTerm PlayAbilityEffects(bool playSound = true)
	{
		playAbilitySound = playSound;
		abilityPopup = meta.GetDisplayName(owner.charData);
		if ((bool)playAbilityEffectsRoutine.running)
		{
			playAbilityEffectsRoutine.host.Pause(playAbilityEffectsRoutine);
			playAbilityEffectsRoutine.Reset();
		}
		return Routine.Start(playAbilityEffectsRoutine);
	}

	public HagletYieldTerm PlayAbilityEffects(string popup, bool playSound = true)
	{
		playAbilitySound = playSound;
		abilityPopup = popup;
		if ((bool)playAbilityEffectsRoutine.running)
		{
			playAbilityEffectsRoutine.host.Pause(playAbilityEffectsRoutine);
			playAbilityEffectsRoutine.Reset();
		}
		return Routine.Start(playAbilityEffectsRoutine);
	}

	private IEnumerator<HagletYieldTerm> PlayAbilityEffectsRoutine()
	{
		if (playAbilitySound)
		{
			AC.Inst.PlayOneShot2D("event:/sfx/ability/ability activate");
		}
		if (!owner.IsCloaked || owner.teamType == UnitTeam.Type.Player)
		{
			owner.popupBar.Enqueue(abilityPopup, 0, 0.5f);
		}
		yield return Wait.While(owner.popupBar.IsPopUpVisable);
	}

	public void PlayAbilitySelectedSound()
	{
		if (RequireTileSelection() || RequireUnitSelection())
		{
			AC.Inst.PlayOneShot2D("event:/sfx/ui/ability select");
		}
	}

	public string GetAbilityAnimationName()
	{
		if (string.IsNullOrEmpty(meta.animationName) || !owner.unitModel.HasAnim(meta.animationName))
		{
			return meta.backupAnimationName;
		}
		return meta.animationName;
	}

	private ParticleTypes GetParticleType()
	{
		return (meta.upgradedParticleEffect == (ParticleTypes)0 || !IsUpgraded) ? meta.particleEffect : meta.upgradedParticleEffect;
	}

	public ParticlePrefab PlayParticles(Unit unit)
	{
		return PlayParticles(unit, GetParticleType());
	}

	public ParticlePrefab PlayParticles(Unit unit, ParticleTypes effect)
	{
		return PlayParticles(unit, effect, unit._GetTransform());
	}

	public ParticlePrefab PlayParticles(Unit unit, v2i coord)
	{
		return PlayParticles(unit, GetParticleType(), coord);
	}

	public ParticlePrefab PlayParticles(Unit unit, ParticleTypes effect, v2i coord)
	{
		if (unit.teamType == UnitTeam.Type.Enemy && unit.IsCloaked)
		{
			return null;
		}
		return PSC.Inst.Play(effect, unit.map, coord);
	}

	public ParticlePrefab PlayParticles(Unit unit, Transform attachedTo)
	{
		if (unit.teamType == UnitTeam.Type.Enemy && unit.IsCloaked)
		{
			return null;
		}
		return PSC.Inst.Play(GetParticleType(), attachedTo);
	}

	public ParticlePrefab PlayParticles(Unit unit, ParticleTypes effect, Transform attachedTo)
	{
		if (unit.teamType == UnitTeam.Type.Enemy && unit.IsCloaked)
		{
			return null;
		}
		return PSC.Inst.Play(effect, attachedTo);
	}
}
[Serializable]
public class AbilityList : IEnumerator<AbilityImplBase>, IDisposable, IEnumerator
{
	[Serializable]
	private struct StackIterator
	{
		public int listIdx;

		public bool isIteratingUnitList;

		public bool skipDisabledAbilities;
	}

	private enum Filter
	{
		All,
		Unit,
		Team
	}

	[Serializable]
	public class EnumerableWrapper : IEnumerable<AbilityImplBase>, IEnumerable
	{
		private AbilityList owner;

		public EnumerableWrapper(AbilityList owner)
		{
			this.owner = owner;
		}

		private EnumerableWrapper()
		{
		}

		public IEnumerator<AbilityImplBase> GetEnumerator()
		{
			return owner;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return owner;
		}
	}

	private ConstArray<AbilityImplBase> abilities = new ConstArray<AbilityImplBase>(32u);

	private Unit unitOwner;

	private UnitTeam _unitTeam;

	private StackIterator[] stackIterators = new StackIterator[4];

	private int stackLevel = -1;

	private Filter filter;

	private EnumerableWrapper enumerable;

	object IEnumerator.Current
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	private UnitTeam UnitTeam
	{
		get
		{
			if (unitOwner != null)
			{
				return unitOwner.GetTeam();
			}
			return _unitTeam;
		}
	}

	private int listIdx
	{
		get
		{
			return stackIterators[stackLevel].listIdx;
		}
		set
		{
			stackIterators[stackLevel].listIdx = value;
		}
	}

	private bool isIteratingUnitList
	{
		get
		{
			return stackIterators[stackLevel].isIteratingUnitList;
		}
		set
		{
			stackIterators[stackLevel].isIteratingUnitList = value;
		}
	}

	private bool skipDisabledAbilities
	{
		get
		{
			return stackIterators[stackLevel].skipDisabledAbilities;
		}
		set
		{
			stackIterators[stackLevel].skipDisabledAbilities = value;
		}
	}

	public AbilityImplBase Current => (!isIteratingUnitList) ? UnitTeam.abilities.abilities[listIdx] : unitOwner.abilities.abilities[listIdx];

	public AbilityList(Unit unit)
	{
		unitOwner = unit;
		_unitTeam = null;
		enumerable = new EnumerableWrapper(this);
	}

	public AbilityList(UnitTeam unitTeam)
	{
		unitOwner = null;
		_unitTeam = unitTeam;
		enumerable = new EnumerableWrapper(this);
	}

	private AbilityList()
	{
	}

	private void Push()
	{
		stackLevel++;
		listIdx = -1;
	}

	private void Pop()
	{
		listIdx = -1;
		stackLevel--;
	}

	public IEnumerable<AbilityImplBase> OnTeam()
	{
		Push();
		filter = Filter.Team;
		return enumerable;
	}

	public IEnumerable<AbilityImplBase> OnUnitAndTeam(bool skipDisabledAbilities = true)
	{
		Push();
		isIteratingUnitList = true;
		this.skipDisabledAbilities = skipDisabledAbilities;
		filter = Filter.All;
		return enumerable;
	}

	public bool MoveNext()
	{
		listIdx++;
		AbilityList abilityList = null;
		if (isIteratingUnitList)
		{
			abilityList = unitOwner.abilities;
		}
		AbilityList abilityList2 = UnitTeam.abilities;
		AbilityImplBase abilityImplBase = null;
		switch (filter)
		{
		case Filter.All:
			if (isIteratingUnitList)
			{
				if (listIdx >= abilityList.abilities.Length)
				{
					listIdx = 0;
					isIteratingUnitList = false;
				}
				else
				{
					abilityImplBase = abilityList.abilities[listIdx];
				}
			}
			if (!isIteratingUnitList)
			{
				if (listIdx >= abilityList2.abilities.Length)
				{
					return false;
				}
				abilityImplBase = abilityList2.abilities[listIdx];
			}
			break;
		case Filter.Unit:
			isIteratingUnitList = true;
			if (listIdx >= abilityList.abilities.Length)
			{
				return false;
			}
			abilityImplBase = abilityList.abilities[listIdx];
			break;
		case Filter.Team:
			isIteratingUnitList = false;
			if (listIdx >= abilityList2.abilities.Length)
			{
				return false;
			}
			abilityImplBase = abilityList2.abilities[listIdx];
			break;
		}
		if (abilityImplBase == null)
		{
			return false;
		}
		if (skipDisabledAbilities && !abilityImplBase.Enabled)
		{
			return MoveNext();
		}
		return true;
	}

	private void Add(AbilityImplBase impl, uint index)
	{
		abilities.Insert(impl, index);
		for (int i = 0; i < stackLevel; i++)
		{
			if (stackIterators[i].listIdx >= index)
			{
				stackIterators[i].listIdx++;
			}
		}
	}

	public T Add<T>(AbilityImplBase caster, bool isUpgraded) where T : AbilityImplBase
	{
		return (T)Add(typeof(T), caster, isUpgraded);
	}

	public AbilityImplBase Add(Type type, AbilityImplBase caster, bool isUpgraded)
	{
		AbilityImplBase abilityInstance = GC.GetAbilityInstance(type, unitOwner, caster);
		if (!abilityInstance.IsTeamAbility())
		{
			unitOwner.abilities.Add(abilityInstance, GetSortedIndexForAbility(abilityInstance, unitOwner.abilities));
		}
		else
		{
			UnitTeam.abilities.Add(abilityInstance, GetSortedIndexForAbility(abilityInstance, UnitTeam.abilities));
		}
		abilityInstance.HACK_isUpgraded = isUpgraded;
		if (abilityInstance.IsProxyAbility())
		{
			abilityInstance.OnAbilityCasted();
		}
		else
		{
			abilityInstance.OnUnitSpawn(unitOwner);
		}
		return abilityInstance;
	}

	public bool Exists<T>(AbilityImplBase caster)
	{
		return Exists(typeof(T), caster);
	}

	public bool Exists(Type type, AbilityImplBase caster)
	{
		uint num = 0u;
		for (uint length = abilities.Length; num < length; num++)
		{
			AbilityImplBase abilityImplBase = abilities[num];
			if (abilityImplBase.GetType() == type && (abilityImplBase.caster == null || abilityImplBase.caster == caster))
			{
				return true;
			}
		}
		return false;
	}

	public bool Exists(Type type)
	{
		uint num = 0u;
		for (uint length = abilities.Length; num < length; num++)
		{
			AbilityImplBase abilityImplBase = abilities[num];
			if (abilityImplBase.GetType() == type)
			{
				return true;
			}
		}
		return false;
	}

	public bool Exists<T>()
	{
		uint num = 0u;
		for (uint length = abilities.Length; num < length; num++)
		{
			AbilityImplBase abilityImplBase = abilities[num];
			if (abilityImplBase.GetType() == typeof(T))
			{
				return true;
			}
		}
		return false;
	}

	public AbilityImplBase GetAbilityByCaster<T>(AbilityImplBase caster)
	{
		Type typeFromHandle = typeof(T);
		uint num = 0u;
		for (uint length = abilities.Length; num < length; num++)
		{
			AbilityImplBase abilityImplBase = abilities[num];
			if (abilityImplBase.GetType() == typeFromHandle && abilityImplBase.caster == caster)
			{
				return abilityImplBase;
			}
		}
		return null;
	}

	private void Remove(uint index)
	{
		AbilityImplBase abilityImplBase = abilities[index];
		abilities.RemoveAtIndexStable(index);
		for (int i = 0; i < stackLevel; i++)
		{
			if (stackIterators[i].listIdx >= index)
			{
				stackIterators[i].listIdx--;
			}
		}
		if (abilityImplBase.IsProxyAbility())
		{
			abilityImplBase.OnAbilityUncasted();
		}
		GC.ReturnAbilityInstance(abilityImplBase);
	}

	public void Remove(AbilityImplBase abilityToRemove, bool isProxy = true)
	{
		for (uint num = 0u; num < abilities.Length; num++)
		{
			if (abilities[num] == abilityToRemove)
			{
				Remove(num);
				break;
			}
		}
	}

	public void RemoveAllProxies()
	{
		for (uint num = 0u; num < abilities.Length; num++)
		{
			AbilityImplBase abilityImplBase = abilities[num];
			if (abilityImplBase.IsProxyAbility())
			{
				Remove(num);
				num--;
			}
		}
	}

	public void _MoveAllAbilities(AbilityList abilitiesNew, Unit owner)
	{
		uint num = 0u;
		while (num < abilities.Length)
		{
			if (abilities[num].owner == owner)
			{
				AbilityImplBase abilityImplBase = abilities[num];
				abilities.RemoveAtIndexStable(num);
				abilitiesNew.abilities.Insert(abilityImplBase, GetSortedIndexForAbility(abilityImplBase, UnitTeam.abilities));
			}
			else
			{
				num++;
			}
		}
	}

	public T AbilityGetByType<T>(Unit owner, Func<AbilityImplBase, bool> predicate) where T : AbilityImplBase
	{
		foreach (AbilityImplBase item in OnUnitAndTeam())
		{
			if (item is T val && val.owner == owner && predicate(val))
			{
				return val;
			}
		}
		return (T)null;
	}

	public T AbilityGetByType<T>(Unit owner) where T : AbilityImplBase
	{
		Type typeFromHandle = typeof(T);
		foreach (AbilityImplBase item in OnUnitAndTeam())
		{
			if (item.GetType() == typeFromHandle && item.owner == owner)
			{
				return (T)item;
			}
		}
		return (T)null;
	}

	public T AbilityGetByType<T>() where T : AbilityImplBase
	{
		return AbilityGetByType(typeof(T)) as T;
	}

	public AbilityImplBase AbilityGetByType(Type type)
	{
		foreach (AbilityImplBase item in OnUnitAndTeam())
		{
			if (item.GetType() == type)
			{
				return item;
			}
		}
		return null;
	}

	public uint AbilityGetCount()
	{
		return abilities.Length;
	}

	public AbilityImplBase AbilityGetByIndex(int index)
	{
		return abilities[index];
	}

	public void Reset()
	{
		throw new NotImplementedException();
	}

	public void Dispose()
	{
		Pop();
	}

	public uint GetSortedIndexForAbility(AbilityImplBase ability, AbilityList abilityList)
	{
		int priority = ability.GetPriority();
		ConstArray<AbilityImplBase> constArray = abilityList.abilities;
		for (uint num = 0u; num < constArray.Length; num++)
		{
			if (priority >= constArray[num].GetPriority())
			{
				return num;
			}
		}
		return constArray.Length;
	}

	private IEnumerator<AbilityImplBase> GetEnumerator()
	{
		return this;
	}

	public static AbilityList GetNextHighestPriority(AbilityList abilitiesA, AbilityList abilitiesB, AbilityImplBase ability)
	{
		if (abilitiesA.Current == null && abilitiesB.Current == null)
		{
			return null;
		}
		if (abilitiesA.Current == null)
		{
			ability = abilitiesA.Current;
			return abilitiesA;
		}
		if (abilitiesB.Current == null)
		{
			ability = abilitiesB.Current;
			return abilitiesB;
		}
		if (abilitiesA.Current.GetPriority() >= abilitiesB.Current.GetPriority())
		{
			ability = abilitiesA.Current;
			abilitiesA.MoveNext();
			return abilitiesA;
		}
		ability = abilitiesB.Current;
		abilitiesB.MoveNext();
		return abilitiesB;
	}

	public int GetActiveManualAbilityCount()
	{
		int num = 0;
		for (int i = 0; i < abilities.Length; i++)
		{
			if (abilities[i].Enabled && abilities[i].IsManuallyActivated() && !abilities[i].IsProxyAbility())
			{
				num++;
			}
		}
		return num;
	}
}
public enum CharacterClass
{
	Ghost,
	Muscle,
	Programmer,
	Soldier,
	Runner,
	Triggerman,
	MAX
}
public enum DialogExpression
{
	Neutral,
	Happy,
	Sad,
	Devastated,
	Scared,
	Angry,
	Screaming
}
public enum BarkTypes
{
	AttackReady,
	AttackCritical,
	AttackMiss,
	SpecialAbility,
	SpecialAbilityAttack,
	SpecialAbilityDefence,
	RestoreHealth,
	CollectGeneral,
	CollectCombat,
	CannotCollect,
	Investigate,
	GangCombatStarts,
	DroidCombatStarts,
	KillGeneric,
	KillFemale,
	KillMale,
	KillRobot,
	FinalKill,
	MoveLeave,
	MoveCombatGeneric,
	MoveFlanking,
	MoveHalfCover,
	MoveFullCover,
	Damage,
	SeriousDamage,
	Dodge,
	Death,
	BugsyKillMargot,
	BugsyKillNotMargot,
	ArchiCombatStartsShiners,
	ArchiCombatStartsFusels,
	ArchiCombatStartsCompilers,
	ArchiCombatStartsTuckers,
	ArchiCombatStartsUnderclocks,
	ArchiCombatStartsDeusoft,
	ArchiCombatStartsChumleys,
	NootSpecialTaunt,
	ChrisChumleySpecialScan,
	MAX
}
public enum CharacterSex
{
	None,
	Male,
	Female,
	Robot
}
public enum GangType
{
	None,
	Shiners,
	Fusels,
	Compilers,
	Tuckers,
	Underclocks,
	Deusoft,
	Chumleys,
	MAX
}
public static class GangTypeExtensions
{
	public static bool IsHumanGang(this GangType gangType)
	{
		if (gangType == GangType.Shiners || gangType == GangType.Fusels || gangType == GangType.Compilers || gangType == GangType.Tuckers || gangType == GangType.Underclocks)
		{
			return true;
		}
		return false;
	}

	public static bool IsDroidGang(this GangType gangType)
	{
		if (gangType == GangType.Deusoft || gangType == GangType.Chumleys)
		{
			return true;
		}
		return false;
	}
}
public static class BarkTypeExtensions
{
	public static BarkTypes? GetBarkType(this AbilityBarkType barkType)
	{
		return barkType switch
		{
			AbilityBarkType.Attack => BarkTypes.SpecialAbilityAttack, 
			AbilityBarkType.Defence => BarkTypes.SpecialAbilityDefence, 
			AbilityBarkType.Taunt => BarkTypes.NootSpecialTaunt, 
			AbilityBarkType.Scan => BarkTypes.ChrisChumleySpecialScan, 
			AbilityBarkType.General => BarkTypes.SpecialAbility, 
			_ => null, 
		};
	}
}
public class CharacterData : AEScriptableResource
{
	[Serializable]
	public class AbilityMetaUpgraded
	{
		public AbilityMeta meta;

		public bool forceOverride;

		public int overrideLevel;

		public bool upgraded;
	}

	[Serializable]
	public struct VariantData
	{
		public string name;

		public SpriteSet narrativePortraits;

		public Sprite icon;

		public Sprite loadoutX4;

		public Sprite loadoutX6;

		public Sprite details;

		public Sprite missionBrief;
	}

	[Serializable]
	public class SpriteSet
	{
		[SerializeField]
		private Sprite[] _spriteForExpression;

		public Sprite[] spriteForExpression => _spriteForExpression;

		public static bool UpdateReturnDirty(ref SpriteSet set, Sprite[] sprites)
		{
			bool result = false;
			if (set == null)
			{
				set = new SpriteSet();
				result = true;
			}
			if (set._spriteForExpression == null || set._spriteForExpression.Length != sprites.Length)
			{
				set._spriteForExpression = new Sprite[sprites.Length];
				result = true;
			}
			for (int i = 0; i < sprites.Length; i++)
			{
				if (set._spriteForExpression[i] != sprites[i])
				{
					set._spriteForExpression[i] = sprites[i];
					result = true;
				}
			}
			return result;
		}

		public Sprite GetSpriteForExpression(DialogExpression expression)
		{
			if (ArrayX.IsNullOrEmpty(_spriteForExpression))
			{
				return null;
			}
			if (expression < DialogExpression.Neutral || (int)expression >= _spriteForExpression.Length || _spriteForExpression[(int)expression] == null)
			{
				return _spriteForExpression[0];
			}
			return _spriteForExpression[(int)expression];
		}
	}

	[Serializable]
	public struct BioInfo
	{
		[SerializeField]
		[TextArea(1, 10)]
		public string bio_Quote;

		[SerializeField]
		[TextArea(1, 10)]
		public string bio_Age;

		[SerializeField]
		[TextArea(1, 10)]
		public string bio_Class;

		[SerializeField]
		[TextArea(1, 10)]
		public string bio_GGS;

		[SerializeField]
		[TextArea(1, 10)]
		public string bio_Augments;
	}

	[ReadOnly]
	public string charName;

	public string _displayName;

	public string _statusEffectsDisplayNameOverride;

	public PartyMemberID partyMemberID;

	private static CharacterStats kDefaultCharacterAttributes;

	private static WeaponAttributes kDefaultRangedWeaponAttributes;

	private static WeaponAttributes kDefaultMeleeWeaponAttributes;

	[SerializeField]
	[FormerlySerializedAs("bio")]
	private BioInfo _bio;

	public BioInfo[] additionalBios = new BioInfo[0];

	[SerializeField]
	private CharacterStats _attribs;

	[SerializeField]
	private CharacterClass _class;

	[SerializeField]
	private CharacterSex _sex;

	[SerializeField]
	private GangType _gangType;

	public string weaponNameKey;

	[FormerlySerializedAs("_mainWeaponAttributes")]
	public WeaponAttributes mainWeaponAttributes;

	[FormerlySerializedAs("_secondaryWeaponAttributes")]
	public WeaponAttributes secondaryWeaponAttributes;

	public WeaponAttributes propWeaponAttributes;

	public GameObject modelRig;

	public GameObject modelRigVariant;

	public SkinQuality skinQuality;

	public float movementSpeed = 10f;

	public float movementSpeedInCombat = 10f;

	public float movementSpeedShortDist = 3f;

	public string ambientMovementSound;

	[Range(1f, 8f)]
	public uint lineOfSightDistance = 3u;

	public AIC.AIParameters aiParameters;

	[SerializeField]
	private string footstepPath;

	[SerializeField]
	private string[] variationNames = new string[0];

	[SerializeField]
	[HideInInspector]
	public VariantData[] variantData;

	public bool hackable;

	public bool environmental;

	public string barksFolder;

	public static string[] LUT_characterBarkStrings = new string[38]
	{
		"attack_ready_", "attack_critical_", "attack_miss_", "special_ability_", "special_ability_attack_", "special_ability_defence_", "restore_health_", "collect_general_", "collect_combat_", "cannot_collect_",
		"investigate_general_", "gang_combat_starts_", "droid_combat_starts_", "kill_generic_", "kill_female_", "kill_male_", "kill_robot_", "final_kill_", "move_leave_", "move_combat_",
		"move_flanking_", "move_half_cover_", "move_full_cover_", "damage_", "serious_damage_", "dodge_", "death_", "attack_kill_margot_", "attack_kill_not_margot_", "shiners_",
		"fusel_", "compilers_", "tucker_", "underclocks_", "deusoft_", "chumleys_", "special_ability_taunt_", "special_ability_scan_"
	};

	[Space]
	public bool hasAbilities = true;

	public bool DEBUG_augmentAllAbilities;

	public AbilityMeta[] DEBUG_abilities;

	[Space]
	[HideInInspector]
	public List<AbilityMetaUpgraded> loadedAbilities;

	public BioInfo bio
	{
		get
		{
			if (partyMemberID == PartyMemberID.Willa && SaveData.initialised)
			{
				if (SaveData.data.IsMissionComplete("MISSION_A3S1_Rotgut"))
				{
					return additionalBios[1];
				}
				if (SaveData.data.IsMissionComplete("MISSION_A1O8_HeistSetup2"))
				{
					return additionalBios[0];
				}
			}
			return _bio;
		}
		set
		{
			_bio = value;
		}
	}

	public CharacterClass Class => _class;

	public CharacterSex Sex => _sex;

	public GangType GangType => _gangType;

	public CharacterStats attribs
	{
		get
		{
			if (_attribs == null)
			{
				if (kDefaultCharacterAttributes == null)
				{
					_attribs = (kDefaultCharacterAttributes = AEResources.LoadFirstResource<CharacterStats>("CharacterAttributes/CAData_Soldier"));
				}
				return kDefaultCharacterAttributes;
			}
			return _attribs;
		}
	}

	public string FootstepPath => footstepPath;

	private new string name => base.name;

	public string DisplayName => (_displayName != null && !(_displayName == string.Empty)) ? _displayName : charName;

	public string UIStatusEffectsDisplayName => (!string.IsNullOrEmpty(_statusEffectsDisplayNameOverride)) ? _statusEffectsDisplayNameOverride : DisplayName;

	public string ClassName => CharacterStats.LUT_ClassName[(int)_class];

	public void OnSpawn(Unit unit)
	{
		if ((bool)mainWeaponAttributes)
		{
			unit.mainWeapon = UnityEngine.Object.Instantiate(mainWeaponAttributes);
		}
		if ((bool)secondaryWeaponAttributes)
		{
			unit.secondaryWeapon = UnityEngine.Object.Instantiate(secondaryWeaponAttributes);
		}
		unit.aiParameters = aiParameters ?? new AIC.AIParameters();
	}

	public int HPMax(int characterLevel)
	{
		return CharacterStats.LUT_HealthMax[(int)_class, characterLevel];
	}

	public int APMax(int characterLevel)
	{
		return CharacterStats.LUT_APPerTurn[(int)_class, characterLevel];
	}

	public int MovementDistancePerTurn(int characterLevel)
	{
		return CharacterStats.LUT_MovementDistance[(int)_class, characterLevel];
	}

	public int ChanceToDodge(int characterLevel)
	{
		return CharacterStats.LUT_DodgeChance[(int)_class, characterLevel];
	}

	public int ChanceToSecondChance(int characterLevel)
	{
		return CharacterStats.LUT_SecondChance[(int)_class, characterLevel];
	}

	public int StealthMovementMod(int characterLevel)
	{
		return CharacterStats.LUT_StealthMovementMod[(int)_class, characterLevel];
	}

	public Sprite GetDialogSprite(DialogExpression expression)
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (variantData[currentVariantIndex].narrativePortraits != null) ? variantData[currentVariantIndex].narrativePortraits.GetSpriteForExpression(expression) : variantData[0].narrativePortraits.GetSpriteForExpression(expression);
	}

	public Sprite GetIconSprite()
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (!(variantData[currentVariantIndex].icon == null)) ? variantData[currentVariantIndex].icon : variantData[0].icon;
	}

	public Sprite GetLoadoutX4Sprite()
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (!(variantData[currentVariantIndex].loadoutX4 == null)) ? variantData[currentVariantIndex].loadoutX4 : variantData[0].loadoutX4;
	}

	public Sprite GetLoadoutX6Sprite()
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (!(variantData[currentVariantIndex].loadoutX6 == null)) ? variantData[currentVariantIndex].loadoutX6 : variantData[0].loadoutX6;
	}

	public Sprite GetDetailsSprite()
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (!(variantData[currentVariantIndex].details == null)) ? variantData[currentVariantIndex].details : variantData[0].details;
	}

	public Sprite GetMissionBriefSprite()
	{
		int currentVariantIndex = GetCurrentVariantIndex();
		return (!(variantData[currentVariantIndex].missionBrief == null)) ? variantData[currentVariantIndex].missionBrief : variantData[0].missionBrief;
	}

	public bool GetUseAlternativeModel()
	{
		return GetCurrentVariantIndex() > 0;
	}

	public string GetCurrentVariant()
	{
		return SaveData.data.GetCharacterVariation(charName);
	}

	public int GetCurrentVariantIndex()
	{
		string currentVariant = GetCurrentVariant();
		for (int i = 0; i < variantData.Length; i++)
		{
			if (variantData[i].name == currentVariant)
			{
				return i;
			}
		}
		UnityEngine.Debug.LogWarning("Character variation " + currentVariant + " not found in character data!a", this);
		return 0;
	}
}
public class CharacterStats : AEScriptableResource
{
	public static readonly string[] LUT_ClassName = new string[6] { "CLASSNAME_GHOST", "CLASSNAME_MUSCLE", "CLASSNAME_PROGRAMMER", "CLASSNAME_SOLDIER", "CLASSNAME_RUNNER", "CLASSNAME_TRIGGER" };

	public static readonly int[,] LUT_HealthMax = new int[6, 11]
	{
		{
			10, 11, 11, 12, 12, 13, 13, 15, 18, 18,
			18
		},
		{
			12, 12, 13, 14, 14, 15, 15, 17, 20, 20,
			20
		},
		{
			9, 10, 10, 11, 11, 12, 12, 14, 17, 17,
			17
		},
		{
			12, 12, 12, 13, 13, 14, 14, 16, 18, 18,
			19
		},
		{
			11, 11, 11, 12, 12, 13, 13, 14, 17, 17,
			17
		},
		{
			11, 11, 11, 12, 12, 13, 13, 15, 18, 18,
			18
		}
	};

	public static readonly int[,] LUT_APPerTurn = new int[6, 11]
	{
		{
			3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
			3
		},
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2
		},
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2
		},
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2
		},
		{
			3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
			3
		},
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2
		}
	};

	public static readonly int[,] LUT_MovementDistance = new int[6, 11]
	{
		{
			5, 5, 5, 6, 6, 6, 7, 7, 7, 8,
			8
		},
		{
			4, 4, 4, 5, 5, 6, 6, 7, 7, 7,
			7
		},
		{
			4, 4, 4, 4, 5, 5, 5, 5, 6, 6,
			6
		},
		{
			4, 4, 4, 5, 5, 5, 6, 6, 6, 7,
			7
		},
		{
			6, 6, 6, 7, 7, 7, 7, 8, 8, 8,
			9
		},
		{
			4, 4, 4, 4, 5, 5, 5, 5, 6, 6,
			6
		}
	};

	public static readonly int[,] LUT_StealthMovementMod = new int[6, 11]
	{
		{
			1, 1, 1, 1, 2, 2, 3, 3, 3, 4,
			4
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		}
	};

	public static readonly int[,] LUT_DodgeChance = new int[6, 11]
	{
		{
			5, 5, 5, 10, 10, 15, 20, 20, 25, 30,
			35
		},
		{
			5, 5, 5, 5, 5, 7, 7, 10, 10, 13,
			15
		},
		{
			5, 5, 5, 5, 5, 7, 7, 10, 10, 13,
			15
		},
		{
			6, 5, 5, 10, 10, 15, 15, 20, 20, 25,
			25
		},
		{
			8, 8, 11, 14, 17, 20, 23, 26, 29, 35,
			37
		},
		{
			2, 2, 4, 6, 8, 10, 12, 14, 16, 18,
			20
		}
	};

	public static readonly int[,] LUT_DodgeSize = new int[6, 11]
	{
		{
			15, 15, 15, 20, 20, 25, 25, 30, 35, 40,
			40
		},
		{
			15, 15, 15, 15, 15, 17, 17, 20, 20, 23,
			25
		},
		{
			15, 15, 15, 15, 15, 17, 17, 20, 20, 23,
			25
		},
		{
			16, 15, 15, 20, 20, 25, 25, 30, 30, 35,
			35
		},
		{
			18, 18, 21, 24, 27, 30, 33, 36, 39, 42,
			45
		},
		{
			12, 12, 14, 16, 18, 20, 22, 24, 26, 28,
			30
		}
	};

	public static readonly int[,] LUT_SecondChance = new int[6, 11]
	{
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 5, 5, 10, 10, 15, 15, 20, 20,
			25
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		},
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0
		}
	};

	public static readonly int[,] LUT_WeaponBaseCritical = new int[6, 11]
	{
		{
			5, 5, 10, 10, 15, 15, 20, 20, 25, 25,
			30
		},
		{
			5, 5, 10, 10, 15, 15, 20, 20, 25, 25,
			30
		},
		{
			23, 23, 26, 29, 32, 35, 38, 41, 44, 47,
			50
		},
		{
			5, 5, 5, 10, 10, 15, 15, 20, 20, 25,
			25
		},
		{
			5, 5, 5, 10, 10, 15, 15, 20, 20, 25,
			25
		},
		{
			5, 5, 10, 10, 15, 15, 20, 20, 25, 25,
			30
		}
	};

	public static readonly int[,] LUT_WeaponBaseCriticalSize = new int[6, 11]
	{
		{
			10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
			30
		},
		{
			10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
			30
		},
		{
			20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
			40
		},
		{
			6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
			26
		},
		{
			6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
			26
		},
		{
			10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
			30
		}
	};

	public static readonly int[,] LUT_WeaponBaseDamageMelee = new int[6, 11]
	{
		{
			2, 2, 2, 3, 3, 3, 4, 4, 4, 5,
			5
		},
		{
			4, 4, 5, 5, 5, 6, 6, 6, 7, 7,
			7
		},
		{
			0, 0, 0, 1, 1, 1, 1, 1, 1, 2,
			2
		},
		{
			1, 1, 1, 1, 1, 2, 2, 2, 2, 3,
			3
		},
		{
			2, 2, 3, 3, 3, 3, 4, 4, 4, 5,
			5
		},
		{
			0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
			2
		}
	};

	public static readonly int[,] LUT_WeaponBaseDamageRanged = new int[6, 11]
	{
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2
		},
		{
			2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
			3
		},
		{
			2, 2, 2, 2, 2, 3, 3, 3, 4, 4,
			4
		},
		{
			3, 3, 3, 3, 3, 4, 4, 4, 5, 5,
			5
		},
		{
			1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
			2
		},
		{
			4, 4, 4, 4, 5, 5, 5, 6, 6, 7,
			7
		}
	};

	public static readonly int[,] LUT_WeaponBaseAccuracyMelee = new int[6, 11]
	{
		{
			77, 77, 77, 80, 80, 87, 87, 92, 92, 96,
			99
		},
		{
			80, 80, 80, 85, 85, 90, 90, 95, 95, 99,
			99
		},
		{
			60, 60, 65, 70, 75, 80, 85, 90, 95, 99,
			99
		},
		{
			60, 60, 65, 70, 75, 80, 85, 90, 95, 99,
			99
		},
		{
			73, 73, 76, 79, 82, 85, 88, 91, 94, 96,
			99
		},
		{
			60, 60, 65, 70, 75, 80, 85, 90, 95, 99,
			99
		}
	};

	public static readonly int[,] LUT_WeaponBaseAccuracyRanged = new int[6, 11]
	{
		{
			60, 60, 65, 65, 70, 70, 75, 75, 80, 80,
			85
		},
		{
			40, 40, 45, 45, 50, 50, 55, 55, 60, 60,
			65
		},
		{
			60, 60, 60, 65, 70, 75, 80, 85, 90, 95,
			99
		},
		{
			60, 60, 65, 70, 75, 80, 85, 90, 95, 95,
			95
		},
		{
			40, 40, 45, 45, 50, 50, 55, 55, 60, 60,
			65
		},
		{
			80, 80, 80, 90, 90, 95, 95, 95, 99, 99,
			99
		}
	};

	public static readonly int[] LUT_AccuracyRangeMin = new int[6] { 2, 0, 2, 4, 0, 0 };

	public static readonly int[] LUT_AccuracyRangeFalloff = new int[6] { 3, 5, 3, 4, 5, 2 };

	public static readonly Type[,,] abilityTree = new Type[6, 11, 2]
	{
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Conceal),
				null
			},
			{
				typeof(Ability_Cloak_and_Dagger),
				typeof(Ability_Trap)
			},
			{
				typeof(Ability_Backstab),
				typeof(Ability_Assassin)
			},
			{
				typeof(Ability_Leap),
				typeof(Ability_Nightcrawler)
			},
			{
				typeof(Ability_Decoy),
				typeof(Ability_Detect)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Incorporeal)
			},
			{
				typeof(Ability_Reflex),
				typeof(Ability_Disable)
			},
			{
				typeof(Ability_VaultKick),
				typeof(Ability_Point_Blank)
			},
			{
				typeof(Ability_Dash),
				typeof(Ability_Shock)
			},
			{
				typeof(Ability_Bleed),
				typeof(Ability_Sap)
			}
		},
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Endurance),
				null
			},
			{
				typeof(Ability_Backup),
				typeof(Ability_Taunt)
			},
			{
				typeof(Ability_Grenade),
				typeof(Ability_Trap)
			},
			{
				typeof(Ability_Plant),
				typeof(Ability_Metabolism)
			},
			{
				typeof(Ability_Hardiness),
				typeof(Ability_Hitback)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Auto_Cover)
			},
			{
				typeof(Ability_Shove),
				typeof(Ability_Danger_Zone)
			},
			{
				typeof(Ability_Flurry),
				typeof(Ability_Grab)
			},
			{
				typeof(Ability_Ground_Pound),
				typeof(Ability_Rebound)
			},
			{
				typeof(Ability_Frenzy),
				typeof(Ability_Berserk)
			}
		},
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Break),
				null
			},
			{
				typeof(Ability_Backup),
				typeof(Ability_Restore)
			},
			{
				typeof(Ability_Trap),
				typeof(Ability_Detect)
			},
			{
				typeof(Ability_Bullet_Time),
				typeof(Ability_Auto_Cover)
			},
			{
				typeof(Ability_Covering_Fire),
				typeof(Ability_Disrupt)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Disable)
			},
			{
				typeof(Ability_Overview),
				typeof(Ability_Shock)
			},
			{
				typeof(Ability_Spot),
				typeof(Ability_Decoy)
			},
			{
				typeof(Ability_Inspire),
				typeof(Ability_Hardiness)
			},
			{
				typeof(Ability_Auto_Revive),
				typeof(Ability_Upgrade)
			}
		},
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Multi_Shot),
				null
			},
			{
				typeof(Ability_Spray_And_Pray),
				typeof(Ability_Auto_Cover)
			},
			{
				typeof(Ability_Grenade),
				typeof(Ability_Covering_Fire)
			},
			{
				typeof(Ability_Vault),
				typeof(Ability_Headshot)
			},
			{
				typeof(Ability_Reflex),
				typeof(Ability_Overwatch)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Return_Fire)
			},
			{
				typeof(Ability_Endurance),
				typeof(Ability_Hardiness)
			},
			{
				typeof(Ability_Point_Blank),
				typeof(Ability_Graze)
			},
			{
				typeof(Ability_Limb_Shot),
				typeof(Ability_Spot)
			},
			{
				typeof(Ability_Area_Shot),
				typeof(Ability_Pick_Off)
			}
		},
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Vault),
				null
			},
			{
				typeof(Ability_Bullet_Time),
				typeof(Ability_Dance)
			},
			{
				typeof(Ability_Trap),
				typeof(Ability_Multi_Shot)
			},
			{
				typeof(Ability_Metabolism),
				typeof(Ability_VaultKick)
			},
			{
				typeof(Ability_Overview),
				typeof(Ability_Danger_Zone)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Backfist)
			},
			{
				typeof(Ability_Leap),
				typeof(Ability_Dash)
			},
			{
				typeof(Ability_Graze),
				typeof(Ability_Incorporeal)
			},
			{
				typeof(Ability_CQC),
				typeof(Ability_Flurry)
			},
			{
				typeof(Ability_Frenzy),
				typeof(Ability_Point_Blank)
			}
		},
		{
			{
				typeof(Ability_Hunker_Down),
				typeof(Ability_Combat_Medic_Small)
			},
			{
				typeof(Ability_Headshot),
				null
			},
			{
				typeof(Ability_Focus),
				typeof(Ability_Overview)
			},
			{
				typeof(Ability_Grenade),
				typeof(Ability_Overwatch)
			},
			{
				typeof(Ability_Graze),
				typeof(Ability_Multi_Shot)
			},
			{
				typeof(Ability_Lookout),
				typeof(Ability_Spot)
			},
			{
				typeof(Ability_Last_Push),
				typeof(Ability_Detect)
			},
			{
				typeof(Ability_Covering_Fire),
				typeof(Ability_Disrupt)
			},
			{
				typeof(Ability_Return_Fire),
				typeof(Ability_Pick_Off)
			},
			{
				typeof(Ability_Ricochet),
				typeof(Ability_Limb_Shot)
			},
			{
				typeof(Ability_Second_Shot),
				typeof(Ability_Far_Shot)
			}
		}
	};

	public static int GetLevelRequired(CharacterClass characterClass, Type ability)
	{
		for (int i = 0; i < abilityTree.GetLength(1); i++)
		{
			if (abilityTree[(int)characterClass, i, 0] == ability || abilityTree[(int)characterClass, i, 1] == ability)
			{
				return i;
			}
		}
		return -1;
	}
}
public static class Combat
{
	public enum CombatMinigame
	{
		None,
		AttackWhamBar,
		DodgeWhamBar,
		RefuseAttackWhamBar
	}

	public struct CombatData
	{
		public Unit attacker;

		public Unit target;

		public WeaponAttributes weapon;

		public int hitChance;

		public int critChance;

		public int dodgeChance;

		public int critSize;

		public int dodgeSize;

		public HitType hitType;

		public HitType additionalEffect;

		public WhamStates whamState;

		public void SetHitType(HitType hitType)
		{
			this.hitType = hitType;
		}
	}

	public enum HitType
	{
		None = -1,
		Miss,
		Dodged,
		Hit,
		HitCritical,
		Graze,
		Reaction,
		Reflect,
		Status
	}

	public const string textMultiplayerFirstTurn = "ABILITIES UNAVAILABLE FOR FIRST TURN";

	public const int kHiddenHitBoost = 10;

	public static bool IsHit(this HitType hitType)
	{
		return hitType == HitType.Hit || hitType == HitType.HitCritical || hitType == HitType.Graze;
	}
}
[CreateAssetMenu]
public class DebugParties : ScriptableObject
{
	[Serializable]
	public struct Team
	{
		public UnitTeam.Type type;

		public CharacterData character0;

		public CharacterData character1;

		public CharacterData character2;
	}

	public Team[] teams;

	private void OnValidate()
	{
		int num = 4;
		if (teams.Length != num)
		{
			Array.Resize(ref teams, num);
		}
		for (int i = 0; i < num; i++)
		{
			teams[i].type = (UnitTeam.Type)i;
		}
	}
}
[CreateAssetMenu]
public class DebugParty : ScriptableObject
{
	[Serializable]
	public struct Team
	{
		public UnitTeam.Type type;

		public CharacterData character0;

		public CharacterData character1;

		public CharacterData character2;
	}

	public Team[] teams;

	private void OnValidate()
	{
		int num = 4;
		if (teams.Length != num)
		{
			Array.Resize(ref teams, num);
		}
		for (int i = 0; i < num; i++)
		{
			teams[i].type = (UnitTeam.Type)i;
		}
	}
}
[RequireComponent(typeof(Unit))]
public class ExplosiveBarrel : MonoBehaviour
{
	[Range(1f, 3f)]
	public int maxRange = 3;

	[Range(1f, 8f)]
	public int maxDamage = 6;

	private bool hasExploded;

	private MeshRenderer aliveBarrelRenderer;

	private MeshRenderer deadBarrelRenderer;

	private const float explosionDelayTime = 0.5f;

	private SpriteRenderer spriteRange;

	private AnimFloat spriteAnim = new AnimFloat(0f);

	private AnimFuncQueue delayExpl = new AnimFuncQueue();

	private void Start()
	{
		aliveBarrelRenderer = base.transform.FindChild("SM_OilDrum").GetComponent<MeshRenderer>();
		deadBarrelRenderer = base.transform.FindChild("SM_OilDrum_Dead").GetComponent<MeshRenderer>();
		deadBarrelRenderer.gameObject.SetActive(value: false);
		spriteRange = base.transform.Find("RangeSprite").GetComponent<SpriteRenderer>();
		Unit component = GetComponent<Unit>();
		component.OnUnitDeathComplete = (Action)Delegate.Combine(component.OnUnitDeathComplete, new Action(Explode));
		component.OnUnitReset = (Action)Delegate.Combine(component.OnUnitReset, new Action(Reset));
		component.OnUnitFocusEnter = (Action)Delegate.Combine(component.OnUnitFocusEnter, new Action(OnUnitFocusEnter));
		component.OnUnitFocusExit = (Action)Delegate.Combine(component.OnUnitFocusExit, new Action(OnUnitFocusExit));
	}

	private void OnUnitFocusEnter()
	{
		if (GC.Inst.IsInTurnMode() && !hasExploded)
		{
			spriteAnim.AnimateTo(1f, 0.25f);
		}
	}

	private void OnUnitFocusExit()
	{
		spriteAnim.AnimateTo(0f, 0.25f);
	}

	private void Update()
	{
		float num = spriteAnim.Update();
		if (num > 0f)
		{
			num *= Mathf.Sin(Time.time * 2f * (float)Math.PI) * 0.25f + 0.75f;
			spriteRange.color = spriteRange.color.RepA(num);
			spriteRange.enabled = true;
		}
		else
		{
			spriteRange.color = spriteRange.color.RepA(0f);
			spriteRange.enabled = false;
		}
		delayExpl.Update();
	}

	private void Explode()
	{
		if (!hasExploded)
		{
			PSC.Inst.PlayAt(ParticleTypes.BarrelExplosion, base.transform.position);
			spriteAnim.AnimateTo(0f, 0.25f);
			aliveBarrelRenderer.gameObject.SetActive(value: false);
			deadBarrelRenderer.gameObject.SetActive(value: true);
			hasExploded = true;
			delayExpl.Queue(HACKDelayExplosion, 0.5f);
		}
	}

	private void DealDamage()
	{
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		v2i v = Singleton<MC>.Inst.GetActiveMap().WorldPosToCoord(base.transform.position);
		for (int i = 0; i < unitsActive.Length; i++)
		{
			Unit unit = unitsActive[i];
			if (unit == null)
			{
				continue;
			}
			v2i coord = unit.coord;
			float num = v2i.Distance(coord, v);
			if (num <= (float)maxRange && num > 0f)
			{
				float num2 = ((num != 1f) ? ((num - 1f) / (float)maxRange) : 0f);
				int num3 = (int)Mathf.Ceil((float)maxDamage * (1f - num2));
				if (num3 > 0)
				{
					unit.HPDecrement(num3);
				}
			}
		}
	}

	private void Reset()
	{
		aliveBarrelRenderer.gameObject.SetActive(value: true);
		deadBarrelRenderer.gameObject.SetActive(value: false);
		hasExploded = false;
	}

	private void HACKDelayExplosion()
	{
		DealDamage();
	}

	private void OnValidate()
	{
		if (base.gameObject.activeInHierarchy)
		{
			spriteRange = base.transform.Find("RangeSprite").GetComponent<SpriteRenderer>();
			switch (maxRange)
			{
			default:
				spriteRange.transform.localScale = Vector3.one;
				break;
			case 2:
				spriteRange.transform.localScale = Vector3.one * 1.7f;
				break;
			case 3:
				spriteRange.transform.localScale = Vector3.one * 2.5f;
				break;
			}
		}
	}
}
public abstract class HAGIS : MonoBehaviour
{
	public enum MoveType
	{
		Default,
		Walk,
		Run
	}

	public class Sequence : Haglet
	{
		private readonly bool isMission;

		public HAGIS[] Hagii { get; private set; }

		public Sequence(HAGIS[] hagii, bool isMission, bool isMissionMain)
			: base(HAGISSequence(hagii, isMission, isMissionMain), hagii[0].name + " HAGIS Sequence", HagletStepTime.LateUpdate, 20)
		{
			this.isMission = isMission;
			Hagii = hagii;
			if (isMission)
			{
				MR.Inst.hagisSequences.Add(this);
				if (isMissionMain)
				{
					MR.Inst.mainHagisSequence = this;
				}
			}
			Setup();
		}

		protected Sequence(BinaryReader reader)
			: base(reader)
		{
			Setup();
		}

		private void Setup()
		{
			if (isMission)
			{
				HACK_MissionException = null;
				localExceptionResponse = (descendantExceptionResponse = abortMission);
				return;
			}
			localExceptionResponse = (descendantExceptionResponse = delegate
			{
				host.Pause(this);
				UnityEngine.Application.Quit();
			});
		}
	}

	private class PlayCutscene : HagletResettable
	{
		public string target;

		public PlayCutscene()
			: base(CutscenePlayRoutine(), "Play Cutscene", HagletStepTime.LateUpdate, -1, 64)
		{
		}

		protected PlayCutscene(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public enum TutorialScreen
	{
		AbilityGaugeBasics,
		AbilityGaugeStun,
		AbilityGaugeReact,
		AbilityGaugeOverride,
		AbilityWheel,
		CombatBar,
		EffectSpinner,
		Flanking,
		StatusEffects
	}

	protected struct LoopingSFX
	{
		private readonly string eventPath;

		private readonly Vector3? pos;

		private FMOD.Studio.EventInstance handle;

		public LoopingSFX(string eventPath)
		{
			this.eventPath = eventPath;
			pos = null;
			handle = AC.Inst.PlayOneShot2D(eventPath);
		}

		public LoopingSFX(string eventPath, Vector3 pos)
		{
			this.eventPath = eventPath;
			this.pos = pos;
			handle = AC.Inst.PlayOneShot3D(eventPath, pos);
		}

		public void Restart()
		{
			Stop();
			handle = ((!pos.HasValue) ? AC.Inst.PlayOneShot2D(eventPath) : AC.Inst.PlayOneShot3D(eventPath, pos.Value));
		}

		public void Stop()
		{
			AC.Stop(handle);
		}

		public void SetParameter(string param, float value)
		{
			if (handle.isValid())
			{
				handle.setParameterValue(param, value);
			}
		}
	}

	protected HagletTrigger voComplete = new HagletTrigger();

	protected HagletTrigger animComplete = new HagletTrigger();

	protected HagletTrigger unitMoveToMapAndTeleportComplete = new HagletTrigger();

	[Serializer.Exclude]
	private Action triggerVOComplete;

	[Serializer.Exclude]
	private Action triggerAnimComplete;

	[Serializer.Exclude]
	private Unit.Teleport.ResultHandler moveUnitAfterTeleport;

	[Serializer.Exclude]
	private Unit.Movement.ResultHandler teleportToSwapMapTileTarget;

	[Serializer.Exclude]
	private Unit.Movement.ResultHandler triggerOnUnitMoveToMapAndTeleportComplete;

	private TileActionSwapMap swapMapTile;

	private UnitTarget unitTarget;

	private Haglet haglet;

	private static PlayCutscene playCutscene = new PlayCutscene();

	public Dictionary<string, HartmanMovementPoint> hartmanMovementPoints = new Dictionary<string, HartmanMovementPoint>();

	public Dictionary<string, HartmanLookAtPoint> hartmanLookAtPoints = new Dictionary<string, HartmanLookAtPoint>();

	public Dictionary<string, UIButtonHaglet> uiButtonHaglets = new Dictionary<string, UIButtonHaglet>();

	public Dictionary<string, KubrickAnimator> animators = new Dictionary<string, KubrickAnimator>();

	protected ConstArray<ParticlePrefab> allTutorialParticles = new ConstArray<ParticlePrefab>(4u);

	protected bool autoHealingEnabled = true;

	public static Exception HACK_MissionException;

	private static readonly Action<Haglet> abortMission = delegate(Haglet hag)
	{
		MusicController.Inst.Stop();
		HACK_MissionException = hag.lastException;
		foreach (Sequence hagisSequence in MR.Inst.hagisSequences)
		{
			if ((bool)hagisSequence.running)
			{
				hagisSequence.host.Pause(hagisSequence);
			}
		}
	};

	private Action<Haglet, object> OnSkipMapWaitUntilVisible = delegate(Haglet owner, object userData)
	{
		Map map3 = (Map)userData;
		if (!Singleton<MC>.Inst.transitioning && (bool)map3 && map3 != Singleton<MC>.Inst.GetActiveMap())
		{
			TileActionSwapMap tileActionSwapMap3 = map3.GetSwapMapTileLinkToTargetMap(Singleton<MC>.Inst.GetActiveMap(), willPanicOnFailure: false);
			if (!tileActionSwapMap3)
			{
				tileActionSwapMap3 = map3.GetSwapTileAtIndex(0u);
			}
			UnitTeam team = Singleton<PC>.Inst.GetTeam();
			team.TransitionTeamToMap(tileActionSwapMap3);
			map3 = null;
		}
	};

	private Action<Haglet, object> OnSkipTileWaitUntil = delegate(Haglet owner, object userData)
	{
		TileObjectBase tileObjectBase = (TileObjectBase)userData;
		Map activeMap2 = Singleton<MC>.Inst.GetActiveMap();
		Map map2 = tileObjectBase.GetMap();
		if (activeMap2 != map2 && !Singleton<MC>.Inst.transitioning)
		{
			TileActionSwapMap tileActionSwapMap2 = map2.GetSwapMapTileLinkToTargetMap(activeMap2, willPanicOnFailure: false);
			if (tileActionSwapMap2 == null)
			{
				tileActionSwapMap2 = map2.GetSwapTileAtIndex(0u);
			}
			Singleton<PC>.Inst.GetTeam().TransitionTeamToMap(tileActionSwapMap2);
		}
		else if (!Singleton<PC>.Inst.GetTeam().GetTeamLeader().teleporting)
		{
			Singleton<PC>.Inst.GetTeam().GetTeamLeader().StartTeleport(tileObjectBase.GetCoord());
		}
	};

	private Action<Haglet, object> OnSkipTileWaitUntilDialogComplete = delegate(Haglet owner, object userData)
	{
		TileActionDialog tileActionDialog = (TileActionDialog)userData;
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		Map map = tileActionDialog.GetMap();
		if (activeMap != map && !Singleton<MC>.Inst.transitioning)
		{
			TileActionSwapMap tileActionSwapMap = map.GetSwapMapTileLinkToTargetMap(activeMap, willPanicOnFailure: false);
			if (tileActionSwapMap == null)
			{
				tileActionSwapMap = map.GetSwapTileAtIndex(0u);
			}
			Singleton<PC>.Inst.GetTeam().TransitionTeamToMap(tileActionSwapMap);
			tileActionDialog.dialog.currentResponseLine = 1u;
		}
		else if (!Singleton<PC>.Inst.GetTeam().GetTeamLeader().teleporting)
		{
			Singleton<PC>.Inst.GetTeam().GetTeamLeader().StartTeleport(tileActionDialog.GetCoord());
			tileActionDialog.dialog.currentResponseLine = 1u;
		}
	};

	private static v2i explicitTile;

	private static readonly Func<v2i, bool> explicitTileFilter = (v2i coord) => coord == explicitTile;

	private static Unit explicitUnit;

	private static readonly Func<Unit, bool> explicitUnitFilter = (Unit unit) => unit == explicitUnit;

	[Serializer.Exclude]
	public LogicRoot logicRoot { get; private set; }

	public static bool IsAutoHealingEnabled
	{
		get
		{
			if (MR.Inst == null)
			{
				return false;
			}
			List<Sequence> hagisSequences = MR.Inst.hagisSequences;
			for (int i = 0; i < hagisSequences.Count; i++)
			{
				HAGIS[] hagii = hagisSequences[i].Hagii;
				for (int j = 0; j < hagii.Length; j++)
				{
					if (!hagii[j].autoHealingEnabled)
					{
						return false;
					}
				}
			}
			return true;
		}
	}

	public static bool inheritMidCombatSkip { get; protected set; }

	public static bool HACK_InShowRoomPhase { get; private set; }

	public void SetAutoHealing(bool toggle)
	{
		autoHealingEnabled = toggle;
	}

	public virtual void OnAwakeRoot()
	{
		triggerVOComplete = delegate
		{
			voComplete.Trigger();
		};
		triggerAnimComplete = delegate
		{
			animComplete.Trigger();
		};
		triggerOnUnitMoveToMapAndTeleportComplete = delegate
		{
			unitMoveToMapAndTeleportComplete.Trigger();
		};
		moveUnitAfterTeleport = MoveUnitAfterTeleport;
		teleportToSwapMapTileTarget = TeleportToSwapMapTileTarget;
		logicRoot = base.gameObject.GetComponentInAscendant<LogicRoot>();
		HartmanMovementPoint[] componentsInChildren = GetComponentsInChildren<HartmanMovementPoint>(includeInactive: true);
		HartmanLookAtPoint[] componentsInChildren2 = GetComponentsInChildren<HartmanLookAtPoint>(includeInactive: true);
		UIButtonHaglet[] componentsInChildren3 = GetComponentsInChildren<UIButtonHaglet>(includeInactive: true);
		KubrickAnimator[] componentsInChildren4 = GetComponentsInChildren<KubrickAnimator>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			hartmanMovementPoints.Add(componentsInChildren[i].name, componentsInChildren[i]);
		}
		for (int j = 0; j < componentsInChildren2.Length; j++)
		{
			hartmanLookAtPoints.Add(componentsInChildren2[j].name, componentsInChildren2[j]);
		}
		for (int k = 0; k < componentsInChildren3.Length; k++)
		{
			componentsInChildren3[k].OnAwakeLR();
			uiButtonHaglets.Add(componentsInChildren3[k].name, componentsInChildren3[k]);
		}
		foreach (KubrickAnimator kubrickAnimator in componentsInChildren4)
		{
			animators.Add(kubrickAnimator.name, kubrickAnimator);
		}
		HACK_InShowRoomPhase = false;
	}

	private void Start()
	{
	}

	private void OnDestroy()
	{
		explicitUnit = null;
	}

	public static void ResumeAllUnderRoot(Transform root, HagletHost host)
	{
		bool flag = MR.Inst != null && host == MR.Inst.Host;
		Transform[] componentsInChildren = root.GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			HAGIS[] components = transform.GetComponents<HAGIS>();
			bool flag2 = flag && transform.gameObject == MR.Inst.gameObject;
			if (components.Length == 0)
			{
				if (flag2)
				{
					GC.Inst.SetState(GC.State.RPG);
				}
			}
			else
			{
				Sequence sequence = new Sequence(components, flag, flag2);
				host.StartTopLevel(sequence);
			}
		}
	}

	private static IEnumerator<HagletYieldTerm> HAGISSequence(HAGIS[] hagii, bool isMission, bool isMain)
	{
		foreach (HAGIS hAGIS in hagii)
		{
			hAGIS.haglet = new Haglet(hAGIS.OnLogic(), hAGIS.GetType().Name, HagletStepTime.LateUpdate, 20, (!isMission) ? null : HagletHost.current);
		}
		yield return null;
		if (AECameraFullscreenPass.Inst.IsFadingToClear)
		{
			yield return Wait.Until(AECameraFullscreenPass.Inst.IsFadedToClear);
		}
		if (isMission && isMain)
		{
			inheritMidCombatSkip = false;
			RC.Inst.BackgroundColorRGBSet(GC.GetStateBackgroundColor(GC.State.RPG, cutsceneMode: false));
			Map targetMap = Singleton<MC>.Inst.GetMapWithIndex(0u);
			if (!(LR.Inst.missionMetaLoaded.resourcePath != SaveData.loadedMission))
			{
				SaveData.BeginMissionResumeSkip();
			}
			else if (LR.DEBUG_autoTestFilters == null && string.IsNullOrEmpty(MR.Inst.DEBUG_skipToOnStart))
			{
				SaveData.SaveMissionIfAllowed();
			}
			yield return Singleton<MC>.Inst.TransitionToMap(targetMap);
			GC.Inst.SetState(GC.State.RPG);
		}
		foreach (HAGIS hagis in hagii)
		{
			if (hagis.enabled && !hagis.haglet.complete)
			{
				yield return Routine.Start(hagis.haglet);
			}
		}
		if (isMission && isMain && !GC.HACK_missionFailed)
		{
			MissionComplete();
		}
	}

	public void OnPauseStateChanged(bool pause)
	{
		foreach (KeyValuePair<string, KubrickAnimator> animator in animators)
		{
			animator.Value.SetPaused(pause);
		}
	}

	public abstract IEnumerator<HagletYieldTerm> OnLogic();

	protected HagletYieldTerm CreateTimeCondition(float time)
	{
		return Wait.ForSeconds(time);
	}

	protected HagletYieldTerm CreateAndCondition(HagletYieldTerm term1, HagletYieldTerm term2)
	{
		return term1 & term2;
	}

	protected HagletYieldTerm CreateAndCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3)
	{
		return term1 & term2 & term3;
	}

	protected HagletYieldTerm CreateAndCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4)
	{
		return term1 & term2 & term3 & term4;
	}

	protected HagletYieldTerm CreateAndCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4, HagletYieldTerm term5)
	{
		return term1 & term2 & term3 & term4 & term5;
	}

	protected HagletYieldTerm CreateAndCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4, HagletYieldTerm term5, HagletYieldTerm term6)
	{
		return term1 & term2 & term3 & term4 & term5 & term6;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2)
	{
		return term1 | term2;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3)
	{
		return term1 | term2 | term3;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4)
	{
		return term1 | term2 | term3 | term4;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4, HagletYieldTerm term5)
	{
		return term1 | term2 | term3 | term4 | term5;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4, HagletYieldTerm term5, HagletYieldTerm term6)
	{
		return term1 | term2 | term3 | term4 | term5 | term6;
	}

	protected HagletYieldTerm CreateOrCondition(HagletYieldTerm term1, HagletYieldTerm term2, HagletYieldTerm term3, HagletYieldTerm term4, HagletYieldTerm term5, HagletYieldTerm term6, HagletYieldTerm term7)
	{
		return term1 | term2 | term3 | term4 | term5 | term6 | term7;
	}

	protected HagletYieldTerm CreateTriggerCondition(HagletEvent tb)
	{
		return tb;
	}

	protected HagletEvent ShowRoom(RoomSceneMeta roomMeta = null)
	{
		if (!Singleton<MC>.Inst.GetActiveMap())
		{
		}
		if (MR.Inst.IsSkipping() || LR.DEBUG_autoTestFilters != null)
		{
			roomMeta = null;
		}
		LR.Inst.ShowRoom(roomMeta);
		HACK_InShowRoomPhase = true;
		if (Singleton<MC>.Inst != null)
		{
			return Singleton<MC>.Inst.hiddenAndReadyForRoom;
		}
		return RC.Inst.OnRoomLoadedIn;
	}

	protected RoomSceneMeta GetRoomMeta(string roomMetaName)
	{
		return AEResources.LoadFirstResource<RoomSceneMeta>("SceneMetas/" + roomMetaName);
	}

	protected HagletYieldTerm ShowMap(Map map = null)
	{
		if ((bool)Singleton<MC>.Inst.GetActiveMap())
		{
		}
		RC.Inst.ShowLastMap(start: false, map);
		HACK_InShowRoomPhase = false;
		return Wait.ForChildren;
	}

	protected void SKIP_POINT(string skipMessage)
	{
		bool resumingMission = SaveData.resumingMission;
		if (!HACK_InShowRoomPhase)
		{
			SaveData.OnCheckpoint();
		}
		if (LR.DEBUG_autoTestFilters != null || SaveData.resumingMission)
		{
			UnityEngine.Debug.Log("IGNORED SKIP POINT: " + skipMessage);
			return;
		}
		MR.Inst.DEBUG_skipToOnStart = string.Empty;
		if (Routine.IsSkipping())
		{
			Routine.SkipStop();
			SaveData.SaveMissionIfAllowed();
		}
	}

	public void ReviveAndHeal(Unit unit)
	{
		if (!unit.IsAlive())
		{
			unit.Revive();
		}
		unit.HPRefill();
	}

	protected HagletYieldTerm AnimStopLooping(int trackIndex)
	{
		return Wait.Invalid;
	}

	protected void AnimStopTrackCurrent(int trackIndex)
	{
	}

	public static void MissionComplete()
	{
		if (GC.Inst.IsInCutsceneMode())
		{
			GC.Inst.CutsceneEnd();
		}
		GC.HACK_missionComplete = true;
		if (LR.DEBUG_autoTestFilters != null)
		{
			LR.Inst.UnloadMissionScene();
		}
		else
		{
			Singleton<UIFlow>.Inst.StartMissionToMainMenu();
		}
	}

	public static void MissionFailed()
	{
		GC.HACK_missionFailed = true;
		Singleton<UIFlow>.Inst.StartMissionToMissionFailed();
	}

	protected void CutsceneBegin()
	{
		GC.Inst.CutsceneBegin();
	}

	protected void CutsceneEnd()
	{
		GC.Inst.CutsceneEnd();
	}

	protected HagletTrigger CutscenePlay(string cutsceneName)
	{
		playCutscene.target = cutsceneName;
		if (MR.Inst.IsSkipping())
		{
			return MR.Inst.KubrickDirector.SkipClip(cutsceneName);
		}
		if ((bool)playCutscene.running)
		{
			playCutscene.host.Pause(playCutscene);
		}
		playCutscene.Reset();
		Routine.Start(playCutscene, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return MR.Inst.KubrickDirector.OnAnimEnded;
	}

	private static IEnumerator<HagletYieldTerm> CutscenePlayRoutine()
	{
		GC.Inst.CutsceneBegin();
		yield return MR.Inst.CutscenePlay(playCutscene.target);
		KubrickDirector cutsceneDirector = MR.Inst.KubrickDirector;
		if (MR.Inst.IsSkipping() && cutsceneDirector.GetCurrentClip != null && cutsceneDirector.GetCurrentClip.name == playCutscene.target)
		{
			cutsceneDirector.SkipClip(playCutscene.target, cutsceneDirector.GetCurrentEventIndex);
		}
		GC.Inst.CutsceneEnd();
		playCutscene.target = null;
	}

	protected HagletYieldTerm EndTurnMode()
	{
		SaveData.OnEndTurnMode();
		if (!GC.Inst.IsInTurnMode())
		{
			return Wait.PreMet;
		}
		GC.Inst._FlagEndOfTurnMode();
		return Wait.Until(GC.Inst._OnRPGModeBegan);
	}

	protected HagletYieldTerm UnitMoveToTarget(Unit unit, UnitTarget target, OctDir? endFacingDirection = null, float? speed = null, bool optionalUnit = false, bool ignoreUnitAtDestination = false, bool shouldReserveTile = true, MoveType movementType = MoveType.Default)
	{
		if (optionalUnit && unit == null)
		{
			return Wait.None;
		}
		unit.StopMovement(immediate: true);
		v2i? destCoord = target.GetCoord();
		bool shouldReserveTile2 = shouldReserveTile;
		bool ignoreShortMovementAnim = movementType == MoveType.Run;
		bool forceWalk = movementType == MoveType.Walk;
		unit.StartMovement(destCoord, null, null, endFacingDirection, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, speed, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination, null, ignoreShortMovementAnim, avoidUnits: false, shouldReserveTile2, forceWalk);
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitMoveToTarget(Unit unit, TileActionSwapMap swapMapTile, float? speed = null, MoveType movementType = MoveType.Default)
	{
		unit.StopMovement(immediate: true);
		v2i? destCoord = swapMapTile.coord;
		bool ignoreShortMovementAnim = movementType == MoveType.Run;
		bool forceWalk = movementType == MoveType.Walk;
		unit.StartMovement(destCoord, null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, speed, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim, avoidUnits: false, shouldReserveTile: true, forceWalk);
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitHide(Unit unit, bool makeInactive = true)
	{
		unit.Hide(makeInactive);
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitShow(Unit unit)
	{
		if (unit.gameObject.activeSelf)
		{
			unit.Show();
		}
		else
		{
			unit.gameObject.SetActive(value: true);
		}
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitMoveToMapViaExitTile(Unit unit, TileActionSwapMap swapTileExit, UnitTarget target = null, float? customSpeed = null, bool faceExit = false)
	{
		float? overrideSpeed = null;
		if (customSpeed.HasValue && customSpeed.GetValueOrDefault() > 0f)
		{
			overrideSpeed = customSpeed;
		}
		if (unit.StartSwapMap(swapTileExit, isSwapTileFromCurrentMap: true, isTeleportIn: false, target, overrideSpeed, faceExit).Failed())
		{
			return Wait.Invalid;
		}
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitTeleportToMapViaEntranceTile(Unit unit, TileActionSwapMap swapTileEntrance, UnitTarget movementTargetAfterTeleport = null, float? speed = null)
	{
		if (unit.StartSwapMap(swapTileEntrance, isSwapTileFromCurrentMap: false, isTeleportIn: true, movementTargetAfterTeleport, speed).Failed())
		{
			return Wait.Invalid;
		}
		return Wait.ForChildren;
	}

	protected HagletYieldTerm UnitTeleportToTarget(Unit unit, UnitTarget target)
	{
		unit.StartTeleport(target);
		return Wait.ForChildren;
	}

	protected HagletTrigger UnitPlayAnimation(Unit unit, string anim, bool loop = false, bool updateIdle = false)
	{
		UnitModel unitModel = unit.unitModel;
		bool looping = loop;
		bool updateIdleOnComplete = updateIdle;
		return unitModel.Play(anim, looping, crouched: false, interacting: false, updateIdleOnComplete);
	}

	protected HagletYieldTerm TeamMoveToMapViaEntranceTile(TileActionSwapMap entranceTile, bool ignoreMovement = false)
	{
		Singleton<PC>.Inst.GetTeam().TransitionTeamToMap(entranceTile, ignoreMovement);
		return Wait.ForChildren;
	}

	private void TeleportToSwapMapTileTarget(Unit unit, Unit.Movement.Result result)
	{
		if (result.IsFailure())
		{
			unitMoveToMapAndTeleportComplete.Trigger();
			return;
		}
		Map targetLinkedMap = swapMapTile.targetLinkedMap;
		if (unit.map == targetLinkedMap)
		{
			MoveUnitAfterTeleport(unit, success: true);
		}
		else
		{
			unit.StartTeleport(targetLinkedMap.GetSwapTileCoordAtIndex(swapMapTile.targetSwapTileIndex), targetLinkedMap, moveUnitAfterTeleport);
		}
	}

	private void MoveUnitAfterTeleport(Unit unit, bool success)
	{
		if (success)
		{
			if (unitTarget == null)
			{
				unitTarget = null;
				swapMapTile = null;
				unitMoveToMapAndTeleportComplete.Trigger();
			}
			else
			{
				unit.StartMovement(unitTarget.GetCoord(), null, triggerOnUnitMoveToMapAndTeleportComplete);
				unitTarget = null;
				swapMapTile = null;
			}
		}
	}

	protected HagletEvent UnitMoveToUnit(Unit unit, Unit target, float? customSpeed = null)
	{
		unit.StopMovement(immediate: true);
		v2i? destCoord = target.coord;
		unit.StartMovement(destCoord, null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, customSpeed);
		return unit.movementStopped;
	}

	protected HagletCondition UnitLookInDirection(Unit unit, OctDir dir, bool optionalUnit = false)
	{
		if (optionalUnit && unit == null)
		{
			return null;
		}
		return unit.LookInDirection(dir);
	}

	protected HagletYieldTerm CreateUnitLookInDirectionCondition(Unit unit, OctDir dir, bool optionalUnit = false)
	{
		if (optionalUnit && unit == null)
		{
			return Wait.None;
		}
		return Wait.Until(UnitLookInDirection(unit, dir));
	}

	protected HagletYieldTerm MapGoto(Map map)
	{
		return Singleton<MC>.Inst.TransitionToMap(map);
	}

	protected HagletYieldTerm MapGoto(LogicRoot logic)
	{
		return MapGoto(logic.Map);
	}

	protected void HagisLog(string log)
	{
	}

	public static void ToggleShakeEnvironment(bool on)
	{
		if (on)
		{
			Singleton<MC>.Inst.MapShake.ShakePermanent(1f, 0.0015f);
		}
		else
		{
			Singleton<MC>.Inst.MapShake.StopShake(1f);
		}
	}

	public static void ShakeOneShot()
	{
		Singleton<MC>.Inst.MapShake.ShakeOneShot(0.5f);
	}

	protected HagletYieldTerm MapWaitUntilMidTransition(LogicRoot mapLogic)
	{
		return Wait.Until(mapLogic.Map.OnMapVisible).OnSkip(OnSkipMapWaitUntilVisible, mapLogic.Map);
	}

	protected HagletYieldTerm MapWaitUntilVisible(Map map)
	{
		return Wait.Until(map._OnShowComplete).OnSkip(OnSkipMapWaitUntilVisible, map);
	}

	protected HagletEvent PlayMapAnimation(Map map, string kubrickAnimatorName, string clipName, bool loop = false)
	{
		KubrickAnimator dynamicAnimator = map.GetDynamicAnimator(kubrickAnimatorName);
		dynamicAnimator.blending = 0f;
		dynamicAnimator.WrapMode = (loop ? WrapMode.Loop : WrapMode.Default);
		return dynamicAnimator.Play(clipName);
	}

	protected HagletEvent CombatBegin(UnitTeam.Type startingTeam, bool playOpeningBark = true)
	{
		SaveData.OnCombatBegin();
		GC.Inst._CombatBegin(startingTeam, playOpeningBark);
		return CombatWaitUntilComplete();
	}

	protected void CombatBeginWaves(UnitTeam.Type startingTeam)
	{
		GC.Inst._CombatBeginWaves(startingTeam);
	}

	protected HagletYieldTerm WaitUntilTurnMode()
	{
		return GC.Inst._OnTurnModeStarted;
	}

	protected HagletYieldTerm TurnModeWaitForPlayerTurnStart(uint turnCount = 1u, bool includeCombatComplete = true)
	{
		if (!GC.Inst.IsInTurnMode())
		{
			return Wait.PreMet;
		}
		HagletYieldTerm hagletYieldTerm = Wait.Until(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnTurnStarted, turnCount);
		return (!includeCombatComplete) ? hagletYieldTerm : (hagletYieldTerm | CombatWaitUntilComplete());
	}

	protected HagletYieldTerm TurnModeWaitForEnemyTurnStart(uint turnCount = 1u)
	{
		if (!GC.Inst.IsInTurnMode())
		{
			return Wait.PreMet;
		}
		return Wait.Until(GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).OnTurnStarted, turnCount) | CombatWaitUntilComplete();
	}

	protected HagletYieldTerm TeamWaitForMemberDeathComplete(UnitTeam.Type teamType, int count = 1)
	{
		return Wait.Until(GC.Inst.GetTeamOfType(teamType).OnMemberDied, (uint)count);
	}

	protected HagletEvent CombatWaitUntilComplete()
	{
		if (!GC.Inst.IsInTurnMode())
		{
			return null;
		}
		return GC.Inst._OnCombatComplete;
	}

	protected HagletYieldTerm StealthWaitUntilBroken()
	{
		return GC.Inst._OnStealthBroken;
	}

	protected HagletYieldTerm TileWaitUntilTriggered(TileTrigger tileTrigger)
	{
		return Wait.Until(tileTrigger._OnTriggered).OnSkip(OnSkipTileWaitUntil, tileTrigger);
	}

	protected HagletYieldTerm TileWaitUntilInteracted(TileActionInteraction tileAction)
	{
		return Wait.Until(tileAction.OnTriggered).OnSkip(OnSkipTileWaitUntil, tileAction);
	}

	protected HagletYieldTerm TileWaitUntilDialogComplete(TileActionDialog tileDialog)
	{
		return Wait.Until(tileDialog.OnDialogComplete).OnSkip(OnSkipTileWaitUntilDialogComplete, tileDialog);
	}

	protected void TileSetAvailability(TileActionBase tile, GC.State state, bool available)
	{
		if (available)
		{
			tile.availableIn |= state;
		}
		else
		{
			tile.availableIn &= ~state;
		}
	}

	protected HagletYieldTerm WaitForUnitsToFinishingActing()
	{
		return Wait.While(GC.Inst.AnyUnitActing);
	}

	protected bool IsUnitInTeam(Unit unit, UnitTeam.Type teamType)
	{
		UnitTeam teamOfType = GC.Inst.GetTeamOfType(teamType);
		ConstArray<Unit> activeMembers = teamOfType.GetActiveMembers();
		for (int i = 0; i < activeMembers.Length; i++)
		{
			if (activeMembers[i].charData == unit.charData)
			{
				return true;
			}
		}
		return false;
	}

	protected bool IsUnitInParty(Unit unit)
	{
		return Party.Inst.GetContributedPartyMember(unit.charData) != null;
	}

	protected HagletYieldTerm ItemAquired(Item item)
	{
		return Party.Inst.FindStackByMeta(ItemImpl.GetItemMeta(item)).OnAcquired;
	}

	protected void _ItemGive(Item item, int amount = 1)
	{
		Party.Inst.AddItemToInventory(ItemImpl.GetItemMeta(item), amount);
	}

	protected void ItemRemove(Item item, int amount = 1)
	{
		Party.Inst.RemoveItemFromInventory(ItemImpl.GetItemMeta(item), amount);
	}

	protected int GetItemCount(Item item)
	{
		return Party.Inst.GetItemCount(ItemImpl.GetItemMeta(item));
	}

	protected LogicRoot GetLogicUsingArtName(string mapName)
	{
		Map mapWithName = Singleton<MC>.Inst.GetMapWithName(mapName);
		if (mapWithName == null)
		{
			return null;
		}
		return mapWithName.logicRoot;
	}

	protected LogicRoot GetLogicByName(string logicName)
	{
		return Singleton<MC>.Inst.GetLogicWithName(logicName);
	}

	public static DialogData DialogLoad(string path)
	{
		DialogData dialogData = AEResources.LoadFirstResource<DialogData>(path);
		dialogData.Prepare();
		return dialogData;
	}

	public static HagletEvent DialogShow(DialogData dialogData, string overrideDisplayName = null)
	{
		if (Routine.IsSkipping())
		{
			DialogData.Dialog[] dialogs = dialogData.dialogs;
			foreach (DialogData.Dialog dialog in dialogs)
			{
				dialog.OnShow();
			}
			dialogData.currentResponseLine = 1u;
			dialogData.completed = true;
			return null;
		}
		return Singleton<UIFlow>.Inst.DisplayDialog(dialogData, null, overrideDisplayName);
	}

	protected HagletYieldTerm DialogWaitForAmbient()
	{
		return Wait.While(UIAmbientSubtitles.Inst.running);
	}

	public HartmanMovementPoint GetHartmanMovementPoint(string id)
	{
		return hartmanMovementPoints[id];
	}

	public HartmanLookAtPoint GetHartmanLookAtPoint(string id)
	{
		return hartmanLookAtPoints[id];
	}

	public UIButtonHaglet GetUIButtonHaglet(string id)
	{
		return uiButtonHaglets[id];
	}

	public KubrickAnimator GetAnimator(string id)
	{
		return animators[id];
	}

	public void Hartman_TeleportToPoint(HartmanMovementPoint point)
	{
		Singleton<Hartman>.Inst.TeleportToPoint(point.position);
	}

	public void Hartman_TeleportToPointWithLookAt(HartmanMovementPoint point, HartmanLookAtPoint lookAt)
	{
		Singleton<Hartman>.Inst.TeleportToPointWithLookAt(point.position, lookAt.position);
	}

	public HagletYieldTerm Hartman_MoveToPoint(HartmanMovementPoint point, float time, bool lookAtPlayerOnComplete = false, bool animateMovement = true)
	{
		return Singleton<Hartman>.Inst.MoveToPosition(point.position, time, lookAtPlayerOnComplete, animateMovement);
	}

	public HagletYieldTerm Hartman_LookAtPoint(HartmanLookAtPoint point, float time)
	{
		return Singleton<Hartman>.Inst.LookAtPoint(point.position, time);
	}

	public HagletYieldTerm Hartman_PlayAnimation(string animationName, bool playIdleOnComplete = true)
	{
		return Singleton<Hartman>.Inst.PlayAnimation(animationName, playIdleOnComplete);
	}

	public HagletYieldTerm Hartman_PlayTalkAnimation()
	{
		return Singleton<Hartman>.Inst.PlayTalkAnimation();
	}

	public HagletYieldTerm Hartman_StopAnimation()
	{
		return Singleton<Hartman>.Inst.StopAnimation();
	}

	public void Hartman_SetMood(Hartman.Mood mood)
	{
		Singleton<Hartman>.Inst.currentMood = mood;
	}

	public void SetExplicitTileMovement(v2i coord)
	{
		explicitTile = coord;
		SC.Inst.SetExtraTileFilter(explicitTileFilter);
	}

	public void RemoveExplicitTileMovement()
	{
		SC.Inst.SetExtraTileFilter(null);
	}

	public void SetExplicitUnitToAttack(Unit unit)
	{
		explicitUnit = unit;
		SC.Inst.SetExtraUnitFilter(explicitUnitFilter);
	}

	public void RemoveExplicitUnitToAttack()
	{
		explicitUnit = null;
		SC.Inst.SetExtraUnitFilter(null);
	}

	public HagletEvent ShowTutorialScreen(TutorialScreen screen)
	{
		if (!MR.Inst.IsSkipping())
		{
			switch (screen)
			{
			case TutorialScreen.AbilityGaugeBasics:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameAbilityGaugeV1>().OnTutorialComplete;
			case TutorialScreen.AbilityGaugeStun:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameAbilityGaugeStun>().OnTutorialComplete;
			case TutorialScreen.AbilityGaugeReact:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameAbilityGaugeReact>().OnTutorialComplete;
			case TutorialScreen.AbilityGaugeOverride:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameAbilityGaugeOverride>().OnTutorialComplete;
			case TutorialScreen.AbilityWheel:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameAbilityWheel>().OnTutorialComplete;
			case TutorialScreen.CombatBar:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameCombatBar>().OnTutorialComplete;
			case TutorialScreen.EffectSpinner:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameEffectSpinner>().OnTutorialComplete;
			case TutorialScreen.Flanking:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameFlanking>().OnTutorialComplete;
			case TutorialScreen.StatusEffects:
				return Singleton<UIC>.Inst.Push<UITutorialGroup_InGameStatusEffects>().OnTutorialComplete;
			}
		}
		return null;
	}

	protected LoopingSFX LoopingSFXPlay(string eventPath)
	{
		return new LoopingSFX(eventPath);
	}

	protected LoopingSFX LoopingSFXPlayAtRoomObject(string eventPath, string objectName)
	{
		if ((bool)RR.Inst)
		{
			Transform roomAudioSource = RR.Inst.GetRoomAudioSource(objectName);
			if ((bool)roomAudioSource)
			{
				return new LoopingSFX(eventPath, roomAudioSource.position);
			}
		}
		return LoopingSFXPlay(eventPath);
	}

	protected void SFXPlay(string eventPath)
	{
		AC.Inst.PlayOneShot2D(eventPath);
	}

	protected void SFXPlayAtCoord(string eventPath, TileObjectBase source)
	{
		Vector3 position = Singleton<MC>.Inst.GetActiveMap().CoordToWorldPos(source.GetCoord());
		AC.Inst.PlayOneShot3D(eventPath, position);
	}

	protected void MusicPlay(string eventPath, float progress = 0f, float fade = 0f)
	{
		MusicController.Inst.Play(eventPath, progress, fade);
	}

	protected void MusicStop()
	{
		MusicController.Inst.Stop();
	}

	protected void MusicSetProgress(float progress)
	{
		MusicController.Inst.SetProgress(progress);
	}

	protected void MusicSetFade(float fade)
	{
		MusicController.Inst.SetFade(fade);
	}

	protected void MusicSetIntensity(float intensity)
	{
		MusicController.Inst.SetIntensity(intensity);
	}

	protected static bool WasHonestThroughoutSection(DC.GameSection section)
	{
		return DC.Inst.WasHonestThroughoutSection(section);
	}

	protected static bool WasHonestThroughoutSection(DC.GameSection sectionA, DC.GameSection sectionB)
	{
		return DC.Inst.WasHonestThroughoutSection(sectionA, sectionB);
	}

	protected static bool HasHonestyChangedBetweenSections(DC.GameSection lhs, DC.GameSection rhs)
	{
		return DC.Inst.HasHonestyChangedBetweenSections(lhs, rhs);
	}

	public HagletEvent PlayInterplay()
	{
		return DC.Inst.PlayInterplay();
	}

	protected ParticlePrefab ShowCoordSelect(v2i coord)
	{
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		if (GC.Inst.GetUnitAtCoord(coord) != null)
		{
			return PSC.Inst.Play(ParticleTypes.CoordSelectUnit, activeMap, coord);
		}
		return PSC.Inst.Play(ParticleTypes.CoordSelectTile, activeMap, coord);
	}

	protected void SetUnitsMoveToDefaultPositionsAfterTurnMode(bool move)
	{
	}

	protected HagletEvent UnitAttackUnit(Unit attacker, Unit target, Combat.HitType hitType, bool kill = false)
	{
		Combat.CombatData combatData = default(Combat.CombatData);
		combatData.hitType = hitType;
		combatData.critChance = 0;
		combatData.dodgeChance = 0;
		combatData.hitChance = 100;
		combatData.weapon = attacker.RangedWeapon;
		combatData.additionalEffect = Combat.HitType.None;
		Combat.CombatData value = combatData;
		if (kill)
		{
			target.HPDecrement(target.HP - 1, attacker);
		}
		WeaponAttributes rangedWeapon = attacker.RangedWeapon;
		bool costsAP = false;
		Combat.CombatData? overrideCombatData = value;
		if (attacker.StartAttack(target, rangedWeapon, costsAP, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.None, overrideCombatData))
		{
			return attacker.OnFinishedAttack;
		}
		return null;
	}

	protected void FadeToBlack()
	{
		float fadeTime = ((!Routine.IsSkipping()) ? 0.25f : 0f);
		AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, fadeTime);
	}

	protected void FadeToClear()
	{
		float fadeTime = ((!Routine.IsSkipping()) ? 0.25f : 0f);
		AECameraFullscreenPass.Inst.StartFadeToClear(fadeTime);
	}

	protected KubrickBase GetRoomAnimator(string roomAnimator)
	{
		return RR.Inst.GetRoomAnimator(roomAnimator);
	}

	protected ParticleSystem GetRoomParticle(string roomPfx)
	{
		return RR.Inst.GetRoomPfx(roomPfx);
	}

	protected void CleanUpTutorial()
	{
		Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
		RemoveExplicitTileMovement();
		RemoveExplicitUnitToAttack();
		Singleton<AIC>.Inst.OnExternalAIBegan = null;
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
		LR.HACK_tutorialMode = false;
		SC.Inst.HACK_tutorialMode = false;
		UIStatusBar.Inst.HACK_showEndTurnButton = true;
		UIAbilityWheel.Inst.HACK_tutorialMode = false;
		UIWhamBar.Inst.tutorialCannotLose = false;
		UIWhamBar.Inst.tutorialTapText = false;
		UIWhamBar.Inst.tutorialAllowCrits = true;
		for (int i = 0; i < allTutorialParticles.Length; i++)
		{
			allTutorialParticles[i].StopParticles();
		}
		allTutorialParticles.Clear();
	}

	protected HagletYieldTerm HAGISWaitForHAGIS(HAGIS other)
	{
		if (Routine.IsSkipping())
		{
			if ((bool)other.haglet.running)
			{
				other.haglet.host.Pause(other.haglet);
			}
			return Routine.Start(other.haglet);
		}
		return other.haglet.completed;
	}

	protected int SizeOfEnemyTeam()
	{
		return GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers().sLength;
	}

	protected int SizeOfPlayerTeam()
	{
		return GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers().sLength;
	}

	protected HagletYieldTerm DontWait()
	{
		return Wait.None;
	}

	protected Unit TeamGetFirstPlayerUnit()
	{
		return GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers()[0];
	}

	protected bool IsMissionComplete(string missionMeta)
	{
		return SaveData.data.IsMissionComplete(missionMeta);
	}

	public static HagletYieldTerm HACK_WaitIfDialogIsNotComplete(DialogData dialog)
	{
		if (dialog.completed)
		{
			return Wait.None;
		}
		return dialog.OnComplete;
	}
}
public class Hagis_GroupOccasionalAnim : HAGIS
{
	public string[] unitIds;

	public string occasionalAnimation;

	private ConstArray<Unit> units = new ConstArray<Unit>(10u);

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		string[] array = unitIds;
		foreach (string text in array)
		{
			Unit unitWithId = GC.Inst.GetUnitWithId(text);
			if ((bool)unitWithId)
			{
				units.Add(unitWithId);
			}
		}
		yield return null;
		if (string.IsNullOrEmpty(occasionalAnimation))
		{
			yield break;
		}
		while (units.Length != 0)
		{
			yield return Wait.ForSeconds(UnityEngine.Random.Range(2f, 5f));
			for (int j = 0; j < units.Length - 1; j++)
			{
				units[j].unitModel.Play(occasionalAnimation, looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
			}
			yield return units[units.Length - 1].unitModel.Play(occasionalAnimation, looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		}
	}
}
public class Hartman : Singleton<Hartman>
{
	public enum Mood
	{
		Default,
		Happy,
		Angry,
		Concerned,
		Sad
	}

	private SkinnedMeshRenderer skinnedMeshRenderer;

	public AnimationCurve movementSmoothingCurve;

	public Mood currentMood;

	public string MovementEvent;

	public string currentAnimation = string.Empty;

	private bool playIdleOnComplete;

	private bool shouldMoodBlend;

	private Vector3 startWorldPos;

	private Vector3 targetWorldPos;

	private Vector3 lookAtPoint;

	private float travelTime;

	private float spinTime;

	private bool lookAtPlayerOnComplete;

	private bool animateMovement;

	private HagletResettable movement;

	private HagletResettable rotation;

	private HagletResettable _animation;

	private float defaultHartmanBlend = 0.25f;

	private int sunPosition;

	public KubrickAnimator animator { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		animator = GetComponentInChildren<KubrickAnimator>();
		skinnedMeshRenderer = GetComponentInChildren<SkinnedMeshRenderer>();
		movement = new HagletResettable(Movement(), "Hartman Movement");
		rotation = new HagletResettable(Rotation(), "Hartman Rotation");
		_animation = new HagletResettable(Animation(), "Hartman Animation Routine");
		sunPosition = Shader.PropertyToID("_SunPos");
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		UnityEngine.Debug.Log("Hartman was destroyed!");
	}

	public void TeleportToPoint(Vector3 point)
	{
		base.transform.position = point.RepY(0f);
	}

	public void TeleportToPointWithLookAt(Vector3 point, Vector3 lookAt)
	{
		base.transform.position = point.RepY(0f);
		Vector3 lookDirection = GetLookDirection(lookAt);
		base.transform.forward = lookDirection;
	}

	public HagletYieldTerm MoveToPosition(Vector3 point, float time, bool lookAtPlayerOnComplete, bool animateMovement = true)
	{
		lookAtPoint = point;
		startWorldPos = base.transform.position.RepY(0f);
		targetWorldPos = point.RepY(0f);
		travelTime = time;
		this.lookAtPlayerOnComplete = lookAtPlayerOnComplete;
		this.animateMovement = animateMovement;
		if (movement.markedToRunBy == HagletHost.currHag)
		{
			return Wait.ForChildren;
		}
		if ((bool)movement.running)
		{
			movement.host.Pause(movement);
			movement.Reset();
		}
		HagletResettable started = movement;
		Haglet currHag = HagletHost.currHag;
		return Routine.Start(started, null, currHag);
	}

	public HagletYieldTerm LookAtPoint(Vector3 point, float spinTime)
	{
		lookAtPoint = point;
		this.spinTime = spinTime;
		if ((bool)rotation.running)
		{
			rotation.host.Pause(rotation);
			rotation.Reset();
		}
		if (rotation.markedToRunBy == HagletHost.currHag)
		{
			return Wait.None;
		}
		if (rotation.markedToRunBy != null)
		{
			return Wait.ForChildren;
		}
		HagletResettable started = rotation;
		Haglet currHag = HagletHost.currHag;
		return Routine.Start(started, null, currHag);
	}

	public HagletYieldTerm PlayTalkAnimation()
	{
		return PlayAnimation(GetTalkAnimName(), playIdleOnComplete: true);
	}

	public HagletYieldTerm PlayAnimation(string animName, bool playIdleOnComplete, bool moodBlend = false)
	{
		currentAnimation = animName;
		shouldMoodBlend = moodBlend;
		this.playIdleOnComplete = playIdleOnComplete;
		if ((bool)_animation.running)
		{
			_animation.host.Pause(_animation);
			_animation.Reset();
		}
		if (_animation.markedToRunBy == HagletHost.currHag)
		{
			return Wait.ForChildren;
		}
		if (ShouldAnimLoop(currentAnimation))
		{
			HagletHost.current.StartTopLevel(_animation, HagletHost.currHag);
			return Wait.None;
		}
		HagletResettable animation = _animation;
		Haglet currHag = HagletHost.currHag;
		return Routine.Start(animation, null, currHag);
	}

	public HagletYieldTerm StopAnimation()
	{
		if (!_animation.running)
		{
			return Wait.None;
		}
		animator.Stop();
		return _animation.completed;
	}

	private IEnumerator<HagletYieldTerm> Movement()
	{
		if (animateMovement)
		{
			PlayAnimation(GetWalkAnimName(), playIdleOnComplete: true, moodBlend: true);
		}
		FMOD.Studio.EventInstance handle = default(FMOD.Studio.EventInstance);
		if (!string.IsNullOrEmpty(MovementEvent))
		{
			handle = AC.Inst.PlayOneShot3D(MovementEvent, base.transform.position);
		}
		float t = 0f;
		while (t < 1f)
		{
			t += Time.deltaTime / travelTime;
			base.transform.position = Vector3.Lerp(startWorldPos, targetWorldPos, movementSmoothingCurve.Evaluate(t));
			Vector3 lookDir = GetLookDirection(lookAtPoint);
			if (lookDir != Vector3.zero)
			{
				Quaternion b = Quaternion.LookRotation(lookDir);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, Time.deltaTime * 5f);
			}
			if (handle.isValid())
			{
				handle.set3DAttributes(base.transform.position.to3DAttributes());
			}
			yield return null;
		}
		if (animateMovement)
		{
			yield return StopAnimation();
		}
		AC.Stop(handle);
		if (lookAtPlayerOnComplete)
		{
			yield return LookAtPoint(Singleton<CC>.Inst.hartmanLookAtPoint.position, 0.5f);
		}
	}

	private IEnumerator<HagletYieldTerm> Rotation()
	{
		float t = 0f;
		Quaternion startRot = base.transform.rotation;
		Vector3 lookDir = GetLookDirection(lookAtPoint);
		if (!(lookDir == Vector3.zero))
		{
			Quaternion tarRot = Quaternion.LookRotation(lookDir);
			while (t < 1f)
			{
				t += Time.deltaTime / spinTime;
				base.transform.rotation = Quaternion.Lerp(startRot, tarRot, t);
				yield return null;
			}
		}
	}

	private IEnumerator<HagletYieldTerm> Animation()
	{
		animator.WrapMode = (ShouldAnimLoop(currentAnimation) ? WrapMode.Loop : WrapMode.Default);
		animator.blending = ((!shouldMoodBlend) ? defaultHartmanBlend : GetBlendValue());
		yield return animator.Play(currentAnimation);
		if (playIdleOnComplete)
		{
			animator.WrapMode = WrapMode.Loop;
			animator.Play(GetIdleAnimName());
		}
	}

	private bool ShouldAnimLoop(string animName)
	{
		switch (animName)
		{
		case "DefaultIdle":
		case "DefaultWalk":
		case "HappyIdle":
		case "HappyWalk":
		case "AngryIdle":
		case "AngryWalk":
		case "ConcernedIdle":
		case "ConcernedWalk":
		case "FixTableIdle":
		case "SadIdle":
		case "SadWalk":
		case "DeathPose":
			return true;
		default:
			return false;
		}
	}

	public string GetIdleAnimName()
	{
		string text;
		switch (currentMood)
		{
		case Mood.Angry:
			text = "AngryIdle";
			break;
		case Mood.Concerned:
			text = "ConcernedIdle";
			break;
		case Mood.Happy:
			text = "HappyIdle";
			break;
		case Mood.Sad:
			text = "SadIdle";
			break;
		default:
			return "DefaultIdle";
		}
		if (animator.HasClip(text))
		{
			return text;
		}
		return "DefaultIdle";
	}

	private string GetTalkAnimName()
	{
		string text;
		switch (currentMood)
		{
		case Mood.Angry:
			text = "AngryTalk";
			break;
		case Mood.Concerned:
			text = "ConcernedTalk";
			break;
		case Mood.Happy:
			text = "HappyTalk";
			break;
		default:
			return "DefaultTalk";
		}
		if (animator.HasClip(text))
		{
			return text;
		}
		return "DefaultTalk";
	}

	private string GetWalkAnimName()
	{
		string text;
		switch (currentMood)
		{
		case Mood.Angry:
			text = "AngryWalk";
			break;
		case Mood.Concerned:
			text = "ConcernedWalk";
			break;
		case Mood.Happy:
			text = "HappyWalk";
			break;
		case Mood.Sad:
			text = "SadWalk";
			break;
		default:
			return "DefaultWalk";
		}
		if (animator.HasClip(text))
		{
			return text;
		}
		return "DefaultWalk";
	}

	private float GetBlendValue()
	{
		return currentMood switch
		{
			Mood.Angry => 0.5f, 
			Mood.Concerned => 0.5f, 
			Mood.Happy => 0.5f, 
			Mood.Sad => 0.5f, 
			_ => defaultHartmanBlend, 
		};
	}

	private Vector3 GetLookDirection(Vector3 worldPos)
	{
		return (base.transform.position - worldPos).RepY(0f).normalized;
	}

	public void SetSunPosition(float x, float y, float z)
	{
		Vector3 vector = new Vector3(x, y, z);
		skinnedMeshRenderer.sharedMaterial.SetVector(sunPosition, vector);
	}

	public void ResetOutside()
	{
		base.transform.localPosition = Vector3.zero.RepZ(1.53f);
		base.transform.localRotation = Quaternion.identity;
		base.transform.localScale = Vector3.one;
		animator.SampleAnimation("Intro", 0f);
	}
}
public class HAGIS_Hartman_BeforeA3S3 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_OurGuest = HAGIS.DialogLoad("Dialogs/PostA3S2/Ambiant_OurGest");
		DialogData ambient_ReachedCelestia = HAGIS.DialogLoad("Dialogs/PostA3S2/Ambient_ReachedCelestia");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_Intro = GetHartmanMovementPoint("M_HartStart");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_Crate = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		KubrickBase FrontDoor = GetRoomAnimator("MA_FrontDoor");
		KubrickBase Violin = GetRoomAnimator("MA_ViolinCase");
		Violin.gameObject.SetActive(value: false);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Default);
		yield return CreateTimeCondition(3f);
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_door knock");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("Intro");
		yield return Wait.ForSteps(1uL);
		Hartman_TeleportToPoint(move_Intro);
		yield return CreateTimeCondition(1.8f);
		SFXPlay("event:/sfx/doors/wooden with creak");
		yield return CreateTimeCondition(0.2f);
		FrontDoor.Play("Open");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_ReachedCelestia);
		yield return CreateTimeCondition(4f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransHIdleToCIdle");
		Hartman_LookAtPoint(look_player, 1f);
		Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransCIdleToHIdle");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		Hartman_MoveToPoint(move_Intro, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_OurGuest);
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("TransDIdleToFixTable");
		yield return CreateTimeCondition(0.3f);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("TransFixTableToDIdle");
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("DefaultBashTable");
		yield return CreateTimeCondition(1.1f);
		SFXPlay("event:/sfx/character v2/weapon/punch heavy");
		yield return CreateTimeCondition(1.1f);
		Hartman_MoveToPoint(move_Intro, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		Hartman_LookAtPoint(look_Crate, 2f);
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_Hartman_PostA1O1 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ImFixing = HAGIS.DialogLoad("Dialogs/PostA1O1/Ambient_ImFixing");
		DialogData ambient_TakeAWhile = HAGIS.DialogLoad("Dialogs/PostA1O1/Ambient_TakeAWhile");
		DialogData ambient_TakeAWhile2 = HAGIS.DialogLoad("Dialogs/PostA1O1/Ambient_TakeAWhile2");
		DialogData ambient_TedFawkesShow = HAGIS.DialogLoad("Dialogs/PostA1O1/Ambient_TedFawkesShow");
		DialogData ambient_TwoDown = HAGIS.DialogLoad("Dialogs/PostA1O1/Ambient_TwoDown");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableFrontFixing = GetHartmanMovementPoint("M_TableFrontFxing");
		HartmanMovementPoint move_HartStart = GetHartmanMovementPoint("M_HartStart");
		HartmanMovementPoint moveTo_RoomBoard = GetHartmanMovementPoint("M_RoomBoard");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_Table = GetHartmanLookAtPoint("L_Table");
		HartmanLookAtPoint Lookat_Right = GetHartmanLookAtPoint("L_Right");
		HartmanLookAtPoint Lookat_Left = GetHartmanLookAtPoint("L_Left");
		HartmanLookAtPoint Lookat_Gramaphone = GetHartmanLookAtPoint("L_Gramaphone");
		HartmanLookAtPoint Lookat_Board = GetHartmanLookAtPoint("L_Board");
		HartmanLookAtPoint Lookat_Board2 = GetHartmanLookAtPoint("L_Board2");
		UIButtonHaglet button_gramaphone = GetUIButtonHaglet("P_Gramaphone");
		HartmanMovementPoint moveTo_InspectingFront = GetHartmanMovementPoint("M_InspectingFront");
		HartmanMovementPoint moveTo_PhoneWindow = GetHartmanMovementPoint("M_PhoneWindow");
		HartmanLookAtPoint lookAt_WindowRight = GetHartmanLookAtPoint("L_WindowRight");
		HartmanLookAtPoint lookAt_WindowLeft = GetHartmanLookAtPoint("L_WindowLeft");
		HartmanMovementPoint moveTo_WindowBehind = GetHartmanMovementPoint("M_WindowBehind");
		HartmanLookAtPoint lookAt_WindowBehindBooksRight = GetHartmanLookAtPoint("L_WindowBehindBooksRight");
		HartmanLookAtPoint lookAt_WindowBehindCentre = GetHartmanLookAtPoint("L_WindowBehindCentre");
		HartmanLookAtPoint lookAt_WindowBehindLeftt = GetHartmanLookAtPoint("L_WindowBehindLeft");
		HartmanLookAtPoint lookAt_L_Fridge = GetHartmanLookAtPoint("L_Fridge");
		yield return null;
		Hartman_TeleportToPoint(move_HartStart);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_ImFixing);
		Hartman_MoveToPoint(move_tableRight, 4f);
		yield return CreateTimeCondition(1.2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		Hartman_LookAtPoint(Lookat_Right, 1f);
		yield return Hartman_PlayAnimation("HappyIdle");
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(Lookat_Left, 1f);
		yield return CreateTimeCondition(0.8f);
		yield return Hartman_StopAnimation();
		Hartman_PlayAnimation("HappyTalk");
		HagisLog("OH I FOUND");
		yield return Hartman_LookAtPoint(look_player, 0.7f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(1.7f);
		HagisLog("i'LL BE A MIN HERE");
		Hartman_MoveToPoint(move_tableFrontFixing, 2f);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("TransDIdleToFixTable");
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_PlayAnimation("FixTableIdle");
		HagletYieldTerm WaitedFor16 = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_gramaphone.OnTapUp, WaitedFor16);
		if (WaitedFor16.met)
		{
			HAGIS.DialogShow(ambient_TakeAWhile);
			HagletYieldTerm WaitedFor15 = CreateTimeCondition(15f);
			yield return CreateOrCondition(button_gramaphone.OnTapUp, WaitedFor15);
			if (WaitedFor15.met)
			{
				HAGIS.DialogShow(ambient_TakeAWhile2);
				yield return button_gramaphone.OnTapUp;
			}
		}
		FMOD.Studio.EventInstance duckStuff = AC.Inst.PlaySnapshot("snapshot:/gramaphone ducks hartman fixing");
		yield return HAGIS.DialogShow(ambient_TedFawkesShow);
		duckStuff.stop(STOP_MODE.ALLOWFADEOUT);
		yield return Hartman_PlayAnimation("TransFixTableToDIdle");
		SFXPlay("event:/sfx/script/act 1/a1o1/hollow map table power up");
		yield return Hartman_LookAtPoint(Lookat_Gramaphone, 1f);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		HAGIS.DialogShow(ambient_TwoDown);
		yield return CreateTimeCondition(0.3f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(0.7f);
		HagisLog("We still need");
		Hartman_MoveToPoint(moveTo_RoomBoard, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_PlayAnimation("DefaultObjectiveBoard");
		Hartman_LookAtPoint(Lookat_Board, 1f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.8f);
		HagisLog("WHERE TO?");
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return Hartman_PlayAnimation("HappyTalk");
		Hartman_MoveToPoint(move_tableRight, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(0.4f);
	}
}
public class HAGIS_Hartman_PostA1O2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		KubrickBase Painting = GetRoomAnimator("MA_Apartment_Painting_01");
		DialogData ambient_WhateverWeStole = HAGIS.DialogLoad("Dialogs/PostA1O2/Ambient_WhateverWeStole");
		DialogData ambient_CheckTheShip = HAGIS.DialogLoad("Dialogs/PostA1O2/Ambient_CheckTheShip");
		DialogData ambient_whereNext = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_WhereNext");
		DialogData ambeint_LetsHitThis = HAGIS.DialogLoad("Dialogs/PostA1O2/Ambeint_LetsHitThis");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_PaintingUp = GetHartmanMovementPoint("M_PaintingPutUp");
		HartmanMovementPoint move_PosterAdmiring = GetHartmanMovementPoint("M_PosterAdmiring");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_safe = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_Poster = GetHartmanLookAtPoint("L_MargotPoster");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HAGIS_Hartman_PostPhoneMolly phoneMollyHagis = GetComponentInChildren<HAGIS_Hartman_PostPhoneMolly>();
		phoneMollyHagis.OnAwakeRoot();
		yield return null;
		Painting.gameObject.SetActive(value: true);
		Transform PaintingLight = RR.Inst.transform.Find("DynamicArt").Find("SM_Museum_PictureLight");
		PaintingLight.gameObject.SetActive(value: true);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_TeleportToPointWithLookAt(move_PaintingUp, look_player);
		Hartman_PlayAnimation("DefaultPainting");
		Painting.Play("MA_Painting");
		yield return CreateTimeCondition(0.5f);
		HAGIS.DialogShow(ambient_WhateverWeStole);
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(6.5f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransDIdleToHIdle");
		HAGIS.DialogShow(ambient_CheckTheShip);
		yield return CreateTimeCondition(0.5f);
		HagisLog("get the details");
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_Poster, 0.7f);
		yield return CreateTimeCondition(3f);
		Hartman_MoveToPoint(move_window, 2f);
		Hartman_LookAtPoint(look_window, 1f);
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(look_player, 1f);
		bool missionA1o2Complete = IsMissionComplete("MISSION_A1O2_RecruitMargot");
		bool missionA1o3Complete = IsMissionComplete("MISSION_A1O3_RecruitAmbrosiaAtt1");
		bool missionA1o4Complete = IsMissionComplete("MISSION_A1O4_RecruitChris");
		if ((!missionA1o2Complete || !missionA1o3Complete || !missionA1o4Complete) && !HAGIS_Hartman_PostPhoneMolly.HACK_gotoPhoneMollyHagis)
		{
			Hartman_SetMood(Hartman.Mood.Concerned);
			Hartman_PlayAnimation("TransHIdleToCIdle");
			HagisLog("Where next?");
			HAGIS.DialogShow(ambient_whereNext);
			yield return CreateTimeCondition(3f);
		}
		else
		{
			yield return phoneMollyHagis.PlayPhoneMolly();
		}
	}
}
public class HAGIS_Hartman_PostA1O3 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_letsHitThis = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_LetsHitThis");
		DialogData ambient_thatWasWeird = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_ThatWasWeird");
		DialogData ambient_whereNext = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_WhereNext");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_safe = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_windowOther = GetHartmanLookAtPoint("L_WindowOther");
		HAGIS_Hartman_PostPhoneMolly phoneMollyHagis = GetComponentInChildren<HAGIS_Hartman_PostPhoneMolly>();
		phoneMollyHagis.OnAwakeRoot();
		KubrickBase Painting = GetRoomAnimator("MA_Apartment_Painting_01");
		bool missionA1o2Complete = IsMissionComplete("MISSION_A1O2_RecruitMargot");
		Transform PaintingLight = RR.Inst.transform.Find("DynamicArt").Find("SM_Museum_PictureLight");
		yield return null;
		if (!missionA1o2Complete)
		{
			Painting.gameObject.SetActive(value: false);
			PaintingLight.gameObject.SetActive(value: false);
		}
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		yield return CreateTimeCondition(0.75f);
		HAGIS.DialogShow(ambient_thatWasWeird);
		Hartman_LookAtPoint(look_windowOther, 0.4f);
		yield return CreateTimeCondition(1f);
		yield return Hartman_LookAtPoint(look_window, 0.4f);
		yield return CreateTimeCondition(0.7f);
		HagisLog("not the woman");
		yield return Hartman_LookAtPoint(look_windowOther, 0.6f);
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_LookAtPoint(look_player, 0.25f);
		HagisLog("i mean will");
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2f);
		HagisLog("zero patience");
		yield return Hartman_LookAtPoint(look_window, 2f);
		yield return CreateTimeCondition(1f);
		bool missionA1o3Complete = IsMissionComplete("MISSION_A1O3_RecruitAmbrosiaAtt1");
		bool missionA1o4Complete = IsMissionComplete("MISSION_A1O4_RecruitChris");
		if ((!missionA1o2Complete || !missionA1o3Complete || !missionA1o4Complete) && !HAGIS_Hartman_PostPhoneMolly.HACK_gotoPhoneMollyHagis)
		{
			Hartman_SetMood(Hartman.Mood.Default);
			Hartman_PlayAnimation("DefaultIdle");
			yield return Hartman_MoveToPoint(move_tableLeft, 1.5f);
			Hartman_LookAtPoint(look_player, 0.5f);
			HagisLog("lets hit this");
			Hartman_PlayAnimation("DefaultTalk");
			yield return CreateTimeCondition(0.3f);
			HAGIS.DialogShow(ambient_letsHitThis);
			yield return CreateTimeCondition(3f);
		}
		else
		{
			yield return phoneMollyHagis.PlayPhoneMolly();
		}
	}
}
public class HAGIS_Hartman_PostA1O4 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		KubrickBase Painting = GetRoomAnimator("MA_Apartment_Painting_01");
		DialogData ambient_FluxCompression = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_FluxCompression");
		DialogData ambient_PhoneMolly = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_PhoneMolly");
		DialogData ambient_MollyPhoneCall = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_MollyPhoneCall");
		DialogData ambient_OkayWhereTo = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_OkayWhereTo");
		DialogData ambient_whereNext = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_WhereNext");
		HartmanMovementPoint M_TableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint M_TableRight2 = GetHartmanMovementPoint("M_TableRight2");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint L_Safe = GetHartmanLookAtPoint("L_Safe");
		UIButtonHaglet button_PhoneMolly = GetUIButtonHaglet("P_PhoneMolly");
		bool missionA1o2Complete = IsMissionComplete("MISSION_A1O2_RecruitMargot");
		HAGIS_Hartman_PostPhoneMolly phoneMollyHagis = GetComponentInChildren<HAGIS_Hartman_PostPhoneMolly>();
		phoneMollyHagis.OnAwakeRoot();
		Transform PaintingLight = RR.Inst.transform.Find("DynamicArt").Find("SM_Museum_PictureLight");
		yield return null;
		if (!missionA1o2Complete)
		{
			Painting.gameObject.SetActive(value: false);
			PaintingLight.gameObject.SetActive(value: false);
		}
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("SadIdle");
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(0.2f);
		HagisLog("Flux compression?...");
		HAGIS.DialogShow(ambient_FluxCompression);
		yield return CreateTimeCondition(1.2f);
		Hartman_LookAtPoint(look_window, 0.7f);
		HagisLog("Yikes");
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return CreateTimeCondition(0.5f);
		bool missionA1o3Complete = IsMissionComplete("MISSION_A1O3_RecruitAmbrosiaAtt1");
		bool missionA1o4Complete = IsMissionComplete("MISSION_A1O4_RecruitChris");
		if ((!missionA1o2Complete || !missionA1o3Complete || !missionA1o4Complete) && !HAGIS_Hartman_PostPhoneMolly.HACK_gotoPhoneMollyHagis)
		{
			yield return Hartman_LookAtPoint(look_player, 1f);
			Hartman_SetMood(Hartman.Mood.Concerned);
			Hartman_PlayAnimation("TransDIdleToCIdle");
			yield return HAGIS.DialogShow(ambient_whereNext);
			yield return CreateTimeCondition(0.5f);
			Hartman_LookAtPoint(L_Safe, 0.5f);
			yield return Hartman_MoveToPoint(M_TableRight2, 4f);
			Hartman_LookAtPoint(L_Safe, 1f);
		}
		else
		{
			yield return phoneMollyHagis.PlayPhoneMolly();
		}
	}
}
public class HAGIS_Hartman_PostA1O5 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_MundGunning = HAGIS.DialogLoad("Dialogs/PostA1O5/Ambient_MundGunning");
		DialogData ambient_SpeakToAmbrosia = HAGIS.DialogLoad("Dialogs/PostA1O5/Ambient_SpeakToAmbrosia");
		DialogData ambient_Finaly = HAGIS.DialogLoad("Dialogs/PostA1O6/Ambient_Finaly");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_sideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_PosterView = GetHartmanMovementPoint("M_PosterView");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_Board = GetHartmanMovementPoint("M_Board");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint L_FrontDoor = GetHartmanLookAtPoint("L_FrontDoor");
		HartmanLookAtPoint L_Board = GetHartmanLookAtPoint("L_Board");
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		HAGIS_Hartman_PostA1O6andA1O5 PostA1O5AndA1O6Hagis = GetComponentInChildren<HAGIS_Hartman_PostA1O6andA1O5>();
		PostA1O5AndA1O6Hagis.OnAwakeRoot();
		yield return null;
		if (!HAGIS_Hartman_PostA1O6andA1O5.HACK_gotoPostA1O5AndA1O6Hagis && !IsMissionComplete("MISSION_A1O6_RecruitAmbrosiaAtt2"))
		{
			Hartman_SetMood(Hartman.Mood.Concerned);
			Hartman_PlayAnimation("ConcernedIdle");
			yield return CreateTimeCondition(0.5f);
			HagisLog("munds gonna be");
			HAGIS.DialogShow(ambient_MundGunning);
			Hartman_PlayAnimation("ConcernedIdleAlt");
			yield return CreateTimeCondition(2f);
			Hartman_LookAtPoint(L_FrontDoor, 0.5f);
			yield return CreateTimeCondition(1f);
			Hartman_LookAtPoint(look_window, 0.5f);
			yield return CreateTimeCondition(0.5f);
			yield return Hartman_PlayAnimation("ConcernedTalk");
			yield return Hartman_MoveToPoint(move_PosterView, 2f);
			HagisLog("it gets more dangerous");
			yield return CreateTimeCondition(1f);
			yield return Hartman_MoveToPoint(move_tableLeft, 2f, lookAtPlayerOnComplete: true);
			Hartman_SetMood(Hartman.Mood.Default);
			Hartman_PlayAnimation("DefaultIdle");
			HAGIS.DialogShow(ambient_SpeakToAmbrosia);
			yield return CreateTimeCondition(1f);
			yield return Hartman_PlayAnimation("DefaultTalk");
			yield return CreateTimeCondition(3f);
		}
		else
		{
			yield return PostA1O5AndA1O6Hagis.PlayDoublePostCutscene();
		}
	}
}
public class HAGIS_Hartman_PostA1O6 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_Fixed = HAGIS.DialogLoad("Dialogs/PostA1O6/Ambient_Fixed");
		DialogData ambient_ThatsFive1 = HAGIS.DialogLoad("Dialogs/PostA1O6/Ambient_ThatsFive1");
		DialogData ambient_ThatsFive2 = HAGIS.DialogLoad("Dialogs/PostA1O6/Ambient_ThatsFive2");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_sideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_PosterView = GetHartmanMovementPoint("M_PosterView");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_Rug = GetHartmanMovementPoint("M_Rug");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint L_FrontDoor = GetHartmanLookAtPoint("L_FrontDoor");
		HartmanLookAtPoint Look_Poster = GetHartmanLookAtPoint("L_Safe");
		HAGIS_Hartman_PostA1O6andA1O5 PostA1O5AndA1O6Hagis = GetComponentInChildren<HAGIS_Hartman_PostA1O6andA1O5>();
		PostA1O5AndA1O6Hagis.OnAwakeRoot();
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		if (!HAGIS_Hartman_PostA1O6andA1O5.HACK_gotoPostA1O5AndA1O6Hagis && !IsMissionComplete("MISSION_A1O5_RecrootNoot"))
		{
			Hartman_SetMood(Hartman.Mood.Default);
			Hartman_PlayAnimation("FixTableIdle");
			yield return CreateTimeCondition(2f);
			HAGIS.DialogShow(ambient_Fixed);
			Hartman_PlayAnimation("TransFixTableToDIdle");
			yield return CreateTimeCondition(1f);
			Hartman_MoveToPoint(move_Rug, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
			Hartman_LookAtPoint(look_window, 1f);
			Hartman_SetMood(Hartman.Mood.Happy);
			Hartman_PlayAnimation("HappyIdle");
			yield return CreateTimeCondition(1.5f);
			yield return Hartman_LookAtPoint(look_player, 0.5f);
			Hartman_SetMood(Hartman.Mood.Concerned);
			Hartman_PlayAnimation("ConcernedTalk");
			yield return CreateTimeCondition(0.5f);
			HAGIS.DialogShow(ambient_ThatsFive1);
			yield return CreateTimeCondition(3f);
			Hartman_LookAtPoint(Look_Poster, 0.7f);
			yield return Hartman_MoveToPoint(move_PosterView, 1.5f, lookAtPlayerOnComplete: false, animateMovement: false);
			HAGIS.DialogShow(ambient_ThatsFive2);
			yield return CreateTimeCondition(1.5f);
			Hartman_LookAtPoint(look_player, 0.5f);
			Hartman_SetMood(Hartman.Mood.Happy);
			yield return Hartman_PlayAnimation("TransCIdleToHIdle");
			yield return Hartman_PlayAnimation("HappyTalk");
			yield return CreateTimeCondition(2f);
		}
		else
		{
			yield return PostA1O5AndA1O6Hagis.PlayDoublePostCutscene();
		}
	}
}
public class HAGIS_Hartman_PostA1O6andA1O5 : HAGIS
{
	private HagletResettable _onLogic;

	public static bool HACK_gotoPostA1O5AndA1O6Hagis;

	private DialogData ambient_Finaly;

	private HartmanMovementPoint M_TableRight;

	private HartmanMovementPoint move_tableLeft;

	private HartmanMovementPoint move_window;

	private HartmanMovementPoint move_sideRoom;

	private HartmanMovementPoint move_Board;

	private HartmanMovementPoint move_Rug;

	private HartmanMovementPoint move_BathroomDoor;

	private HartmanLookAtPoint look_player;

	private HartmanLookAtPoint look_window;

	private HartmanLookAtPoint L_LookAtPhone;

	private HartmanLookAtPoint L_Safe;

	private HartmanLookAtPoint L_Board;

	public override void OnAwakeRoot()
	{
		base.OnAwakeRoot();
		_onLogic = new HagletResettable(OnLogic(), "Phone Molly");
		InitVars();
	}

	public HagletEvent PlayDoublePostCutscene()
	{
		Routine.Start(_onLogic, LR.Host);
		return _onLogic.completed;
	}

	public void InitVars()
	{
		ambient_Finaly = HAGIS.DialogLoad("Dialogs/PostA1O6/Ambient_Finaly");
		M_TableRight = GetHartmanMovementPoint("M_TableRight");
		move_Rug = GetHartmanMovementPoint("M_Rug");
		move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		move_window = GetHartmanMovementPoint("M_Window");
		move_sideRoom = GetHartmanMovementPoint("M_SideRoom");
		move_Board = GetHartmanMovementPoint("M_Board");
		move_BathroomDoor = GetHartmanMovementPoint("M_BathroomDoor");
		look_player = GetHartmanLookAtPoint("L_Player");
		look_window = GetHartmanLookAtPoint("L_Window");
		L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		L_Safe = GetHartmanLookAtPoint("L_Safe");
		L_Board = GetHartmanLookAtPoint("L_Board");
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("HappyIdle");
		Hartman_TeleportToPointWithLookAt(move_sideRoom, look_window);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_Finaly);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		yield return Hartman_StopAnimation();
		yield return CreateTimeCondition(1f);
		HagisLog("for the aug we stole");
		yield return Hartman_MoveToPoint(move_tableLeft, 2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TranHIdleToCIdle");
		yield return Hartman_PlayAnimation("ConcernedTalk");
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransCIdleToDIdle");
		yield return Hartman_PlayAnimation("DefaultTalk");
		yield return Hartman_MoveToPoint(move_Rug, 1f);
		yield return Hartman_MoveToPoint(move_Board, 1f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return Hartman_PlayAnimation("DefaultObjectiveBoard");
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(3f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_MoveToPoint(move_BathroomDoor, 1f);
		yield return Hartman_MoveToPoint(move_window, 2f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window, 0.5f);
		yield return CreateTimeCondition(3f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("HappyIdle");
		Hartman_LookAtPoint(look_player, 2f);
	}
}
public class HAGIS_Hartman_PostA1O8 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_AllSet = HAGIS.DialogLoad("Dialogs/PostA1O8/Ambient_AllSet");
		DialogData ambient_WeNeedMolly = HAGIS.DialogLoad("Dialogs/PostA1O8/Ambient_WeNeedMolly");
		DialogData ambient_MyFavourite = HAGIS.DialogLoad("Dialogs/PostA1O8/Ambient_MyFavourite");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_Board = GetHartmanMovementPoint("M_Board");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_PhoneCloser = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_Sideroom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_board = GetHartmanLookAtPoint("L_Board");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		UIButtonHaglet button_PhoneMolly = GetUIButtonHaglet("P_PhoneMolly");
		yield return null;
		button_PhoneMolly.gameObject.SetActive(value: false);
		Hartman_TeleportToPointWithLookAt(move_Board, look_board);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("DefaultIdle");
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_AllSet);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return Hartman_PlayAnimation("DefaultObjectiveBoard");
		Hartman_LookAtPoint(look_board, 0.5f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(3f);
		Hartman_MoveToPoint(move_TableLeft, 3f);
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		button_PhoneMolly.gameObject.SetActive(value: true);
		HagletYieldTerm WaitedFor5 = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_PhoneMolly.OnTapUp, WaitedFor5);
		if (WaitedFor5.met)
		{
			Hartman_LookAtPoint(look_player, 0.5f);
			Hartman_PlayAnimation("ConcernedTalk");
			yield return CreateTimeCondition(0.5f);
			HAGIS.DialogShow(ambient_WeNeedMolly);
			HagisLog("Reminder");
			yield return button_PhoneMolly.OnTapUp;
		}
		SFXPlay("event:/sfx/script/act 1/a1o4/phone call");
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransCIdleToDIdle");
		Hartman_MoveToPoint(move_PhoneCloser, 1f);
		yield return CreateTimeCondition(1.1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(6f);
		HAGIS.DialogShow(ambient_MyFavourite);
		yield return CreateTimeCondition(4f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(1f);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1.8f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.3f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransCIdleToDIdle");
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_PlayAnimation("DefaultTalk");
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		Hartman_PlayAnimation("HappyTalk");
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_TableLeft, 1f);
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return CreateTimeCondition(1.5f);
		Hartman_MoveToPoint(move_Sideroom, 3f);
		yield return CreateTimeCondition(3.2f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("DefaultIdle");
	}
}
public class HAGIS_Hartman_PostA1S1 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ImSorry = HAGIS.DialogLoad("Dialogs/PostA1S1/Ambient_ImSorry");
		DialogData Ambient_OverHere = HAGIS.DialogLoad("Dialogs/PostA1S1/Ambient_OverHere");
		DialogData Ambient_AshleysPlan = HAGIS.DialogLoad("Dialogs/PostA1S1/Ambient_AshleysPlan");
		DialogData Ambient_TryingToMakePoint = HAGIS.DialogLoad("Dialogs/PostA1S1/Ambient_TryingToMakePoint");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Board = GetHartmanMovementPoint("M_Board");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_board = GetHartmanLookAtPoint("L_Board");
		HartmanLookAtPoint look_Photo = GetHartmanLookAtPoint("L_Photo");
		UIButtonHaglet button_BoardPlan = GetUIButtonHaglet("P_BoardPlan");
		button_BoardPlan.SetSparkleEnabled(enabled: false);
		button_BoardPlan.SetSparkleOptional(isOptional: false);
		Transform SparksObject = RR.Inst.transform.Find("ParticleSystems").Find("P_PenthouseSparks_R");
		SparksObject.gameObject.SetActive(value: false);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("SadIdle");
		Hartman_TeleportToPointWithLookAt(move_tableRight, look_Photo);
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_ImSorry);
		Hartman_LookAtPoint(look_player, 1f);
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(3.5f);
		HagisLog("..remarkable");
		Hartman_LookAtPoint(look_window, 1f);
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_window, 2f);
		Hartman_LookAtPoint(look_window, 1f);
		yield return CreateTimeCondition(2f);
		yield return CreateTimeCondition(3f);
		HagisLog("..we can't loose her too");
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return Hartman_LookAtPoint(look_player, 2f);
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_LookAtPoint(look_window, 1.5f);
		yield return CreateTimeCondition(3.3f);
		HagisLog("but..we've got a job");
		yield return Hartman_StopAnimation();
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("DefaultIdle");
		yield return CreateTimeCondition(0.4f);
		HagisLog("keep her safe, like we promised");
		yield return Hartman_LookAtPoint(look_player, 1f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_ImSorry);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_board, 0.25f);
		yield return CreateTimeCondition(2f);
		yield return Hartman_MoveToPoint(move_tableRight, 2f);
		yield return Hartman_MoveToPoint(move_Board, 1f);
		HagletYieldTerm WaitedFor16 = CreateTimeCondition(7f);
		button_BoardPlan.SetSparkleEnabled(enabled: true);
		yield return CreateOrCondition(button_BoardPlan.OnFocusEnter, WaitedFor16);
		button_BoardPlan.SetSparkleEnabled(enabled: false);
		if (WaitedFor16.met)
		{
			HAGIS.DialogShow(Ambient_OverHere);
			HagletYieldTerm WaitedFor15 = CreateTimeCondition(15f);
			yield return CreateOrCondition(button_BoardPlan.OnFocusEnter, WaitedFor15);
			if (WaitedFor15.met)
			{
				HAGIS.DialogShow(Ambient_TryingToMakePoint);
				yield return CreateOrCondition(term2: CreateTimeCondition(10f), term1: button_BoardPlan.OnFocusEnter);
			}
		}
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_AshleysPlan);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(1.2f);
		Hartman_LookAtPoint(look_Photo, 0.25f);
		yield return CreateTimeCondition(1.2f);
		Hartman_PlayAnimation("DefaultTalk");
		Hartman_LookAtPoint(look_board, 0.25f);
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_MoveToPoint(move_tableFront, 2f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(Ambient_AshleysPlan);
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_Hartman_PostA1S2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_PushedOurLuck = HAGIS.DialogLoad("Dialogs/PostA1S2/Ambient_PushedOurLuck");
		DialogData ambient_WeNeedMolly = HAGIS.DialogLoad("Dialogs/PostA1O8/Ambient_WeNeedMolly");
		DialogData ambient_MyFavourite = HAGIS.DialogLoad("Dialogs/PostA1O8/Ambient_MyFavourite");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_WindowOther = GetHartmanLookAtPoint("L_WindowOther");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_photo = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_window, look_WindowOther);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("DefaultIdle");
		Hartman_MoveToPoint(move_tableRight, 3f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(1.7f);
		HAGIS.DialogShow(ambient_PushedOurLuck);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(0.4f);
		HagisLog("pushed our luck");
		Hartman_LookAtPoint(look_player, 0.7f);
		yield return CreateTimeCondition(1.4f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(1.4f);
		Hartman_MoveToPoint(move_TableLeft, 3f);
		Hartman_LookAtPoint(look_window, 0.7f);
		yield return CreateTimeCondition(2f);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(2f);
		yield return Hartman_MoveToPoint(move_tableFront, 1f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		yield return Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_LookAtPoint(look_WindowOther, 0.2f);
		yield return CreateTimeCondition(0.3f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_window, 2f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_WindowOther, 0.25f);
		Hartman_LookAtPoint(look_window, 0.25f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.25f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2f);
		yield return Hartman_LookAtPoint(look_photo, 0.5f);
		yield return CreateTimeCondition(0.2f);
		yield return Hartman_LookAtPoint(look_WindowOther, 0.5f);
		yield return CreateTimeCondition(0.6f);
		yield return Hartman_LookAtPoint(look_window, 0.5f);
		yield return CreateTimeCondition(2f);
		HagisLog("Ended the cutscene");
	}
}
public class HAGIS_Hartman_PostA2O2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_GoszWorks = HAGIS.DialogLoad("Dialogs/PostA2O2/Ambient_GoszWorks");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_Sideroom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_Sideroom, look_window);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_GoszWorks);
		yield return Hartman_MoveToPoint(move_tableRight, 1f, lookAtPlayerOnComplete: true);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return Hartman_MoveToPoint(move_tableFront, 1f, lookAtPlayerOnComplete: true);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(1.5f);
		Hartman_MoveToPoint(move_window, 2f);
		yield return CreateTimeCondition(3f);
	}
}
public class HAGIS_Hartman_PostA2O3 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ItsTime = HAGIS.DialogLoad("Dialogs/PostA2O3/Ambeint_ItsTime");
		DialogData ambeint_DidSomeDigging1 = HAGIS.DialogLoad("Dialogs/PostA2O3/Ambeint_DidSomeDigging1");
		DialogData ambeint_DidSomeDigging2 = HAGIS.DialogLoad("Dialogs/PostA2O3/Ambeint_DidSomeDigging2");
		DialogData ambeint_DidSomeDigging3 = HAGIS.DialogLoad("Dialogs/PostA2O3/Ambeint_DidSomeDigging3");
		DialogData ambeint_DidSomeDigging4 = HAGIS.DialogLoad("Dialogs/PostA2O3/Ambeint_DidSomeDigging4");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_Sideroom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_Safe = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_WindowOther = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_butterflies, look_window);
		Hartman_PlayAnimation("DefaultIdle");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_ItsTime);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_TableLeft, 1.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambeint_DidSomeDigging1);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(1f);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2.5f);
		yield return Hartman_MoveToPoint(move_window, 1f);
		Hartman_LookAtPoint(look_window, 0.5f);
		HAGIS.DialogShow(ambeint_DidSomeDigging2);
		yield return CreateTimeCondition(1f);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(2.5f);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransCIdleToHIdle");
		HAGIS.DialogShow(ambeint_DidSomeDigging3);
		yield return CreateTimeCondition(4.5f);
		yield return Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(0.5f);
		yield return Hartman_MoveToPoint(move_tableFront, 1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		HAGIS.DialogShow(ambeint_DidSomeDigging4);
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(2f);
	}
}
public class HAGIS_Hartman_PostA2O4 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_MiteBeAble = HAGIS.DialogLoad("Dialogs/PostA2O4/Ambient_MiteBeAble");
		DialogData ambeint_IdontLikeThis = HAGIS.DialogLoad("Dialogs/PostA2O4/Ambeint_IdontLikeThis");
		DialogData ambient_LetsCall = HAGIS.DialogLoad("Dialogs/PostA2O4/Ambient_LetsCall");
		DialogData ambient_TruckersOffice = HAGIS.DialogLoad("Dialogs/PostA2O4/Ambient_TruckersOffice");
		DialogData ambient_HeSeemedHappy = HAGIS.DialogLoad("Dialogs/PostA2O4/Ambient_HeSeemedHappy");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		UIButtonHaglet button_PhoneBugsy = GetUIButtonHaglet("P_PhoneBugsy");
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_tableFront, look_player);
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(0.3f);
		HAGIS.DialogShow(ambient_MiteBeAble);
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_tableLeft, 2f);
		yield return CreateTimeCondition(2.5f);
		Hartman_PlayAnimation("SadTalk");
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		HagletYieldTerm WaitedFor16 = CreateTimeCondition(8f);
		yield return CreateOrCondition(button_PhoneBugsy.OnTapUp, WaitedFor16);
		if (WaitedFor16.met)
		{
			HAGIS.DialogShow(ambeint_IdontLikeThis);
			Hartman_MoveToPoint(move_tableRight, 2f);
			yield return CreateTimeCondition(1.5f);
			Hartman_LookAtPoint(look_player, 0.5f);
			HagletYieldTerm WaitedFor15 = CreateTimeCondition(15f);
			yield return CreateOrCondition(button_PhoneBugsy.OnTapUp, WaitedFor15);
			if (WaitedFor15.met)
			{
				HAGIS.DialogShow(ambient_LetsCall);
				Hartman_MoveToPoint(move_tableLeft, 2f);
				yield return CreateTimeCondition(1.5f);
				Hartman_LookAtPoint(look_player, 0.5f);
				yield return button_PhoneBugsy.OnTapUp;
			}
		}
		SFXPlay("event:/sfx/script/act 1/a1o4/phone call");
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return Hartman_MoveToPoint(move_butterflies, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(5f);
		HAGIS.DialogShow(ambient_TruckersOffice);
		yield return CreateTimeCondition(2.3f);
		Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(0.9f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.2f);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(0.6f);
		Hartman_PlayAnimation("TransCIdleToDIdle");
		yield return CreateTimeCondition(6f);
		Hartman_LookAtPoint(look_player, 0.2f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.2f);
		yield return CreateTimeCondition(3f);
		yield return Hartman_LookAtPoint(look_player, 5f);
		yield return CreateTimeCondition(1.2f);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_window, 3f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 0.1f);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		HAGIS.DialogShow(ambient_HeSeemedHappy);
		yield return CreateTimeCondition(4f);
		yield return Hartman_LookAtPoint(look_window, 3f);
	}
}
public class HAGIS_Hartman_PostA2O5 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_WannaGetThat = HAGIS.DialogLoad("Dialogs/PostA2O5/Ambient_WannaGetThat");
		DialogData ambient_PhoneOnLeft = HAGIS.DialogLoad("Dialogs/PostA2O5/Ambient_PhoneOnLeft");
		DialogData ambient_CraveAndHart = HAGIS.DialogLoad("Dialogs/PostA2O5/Ambient_CraveAndHart");
		DialogData ambient_ThatsOminous = HAGIS.DialogLoad("Dialogs/PostA2O5/Ambient_ThatsOminous");
		DialogData Ambient_BioImager = HAGIS.DialogLoad("Dialogs/PostA2O5/Ambient_BioImager");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Sideroom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_TableRightImager = GetHartmanMovementPoint("M_TableRightImager");
		HartmanMovementPoint move_butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_BioImager = GetHartmanLookAtPoint("L_BioImager");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint look_board = GetHartmanLookAtPoint("L_Board");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		UIButtonHaglet button_Phone = GetUIButtonHaglet("P_Phone");
		KubrickBase PhoneJiggle = GetRoomAnimator("MA_Apartment_Telephone_01");
		yield return null;
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		Hartman_TeleportToPointWithLookAt(move_Sideroom, look_player);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_BioImager);
		yield return Hartman_MoveToPoint(move_tableRight, 1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_BioImager, 0.5f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2.5f);
		Hartman_LookAtPoint(look_Butterflies, 0.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_butterflies, 2f);
		Hartman_LookAtPoint(look_Butterflies, 0.5f);
		yield return CreateTimeCondition(1f);
		LoopingSFX PhoneRinging = LoopingSFXPlayAtRoomObject("event:/sfx/script/act 1/a1o4/phone ringing", "SM_Apartment_Telephone");
		PhoneJiggle.Play("MA_Telephone");
		PhoneJiggle.WrapMode = WrapMode.Loop;
		HagletYieldTerm WaitedFor16 = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor16);
		if (WaitedFor16.met)
		{
			HAGIS.DialogShow(ambient_WannaGetThat);
			Hartman_LookAtPoint(look_player, 1f);
			Hartman_PlayAnimation("DefaultTalk");
			HagletYieldTerm WaitedFor15 = CreateTimeCondition(15f);
			yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor15);
			if (WaitedFor15.met)
			{
				HAGIS.DialogShow(ambient_PhoneOnLeft);
				Hartman_PlayAnimation("DefaultTalk");
				yield return button_Phone.OnTapUp;
			}
		}
		SFXPlay("event:/sfx/script/act 1/a1o4/phone pick up");
		PhoneRinging.Stop();
		PhoneJiggle.WrapMode = WrapMode.Once;
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return Hartman_MoveToPoint(move_tableLeft, 1f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		HAGIS.DialogShow(ambient_CraveAndHart);
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(2.2f);
		yield return Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(5.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(6f);
		Hartman_LookAtPoint(look_player, 1.4f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.7f);
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(look_player, 0.2f);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.2f);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return CreateTimeCondition(3.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		HAGIS.DialogShow(ambient_ThatsOminous);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		Hartman_LookAtPoint(look_player, 0.3f);
		yield return Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_window, 1f);
		yield return CreateTimeCondition(1.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_window, 0.5f);
		yield return CreateTimeCondition(4f);
	}
}
public class HAGIS_Hartman_PostA2O6 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_CallHim = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_CallHim");
		DialogData ambient_CallTrucker = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_CallTrucker");
		DialogData ambinet_IWannaWord = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambinet_IWannaWord");
		DialogData ambient_CallTrucker2 = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_CallTrucker2");
		DialogData ambient_LessAngry = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_LessAngry");
		DialogData ambient_BugsySmug = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_BugsySmug");
		DialogData ambient_Trophy = HAGIS.DialogLoad("Dialogs/PostA2O6/ambient_Trophy");
		DialogData ambient_ReachCelestia = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_ReachCelestia");
		DialogData ambient_LetsStealIt = HAGIS.DialogLoad("Dialogs/PostA2O6/Ambient_LetsStealIt");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft2 = GetHartmanMovementPoint("M_TableLeft2");
		HartmanMovementPoint move_tableLeft3 = GetHartmanMovementPoint("M_TableLeft3");
		HartmanMovementPoint move_tableLeft4 = GetHartmanMovementPoint("M_TableLeft4");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_SideRoom2 = GetHartmanMovementPoint("M_SideRoom2");
		HartmanMovementPoint move_SideRoom3 = GetHartmanMovementPoint("M_SideRoom3");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_window2 = GetHartmanLookAtPoint("L_Window2");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_FrontDoor = GetHartmanLookAtPoint("L_FrontDoor");
		UIButtonHaglet button_Phone = GetUIButtonHaglet("P_Phone");
		yield return null;
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("AngryIdle");
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.2f);
		yield return CreateTimeCondition(0.7f);
		yield return HAGIS.DialogShow(ambient_CallHim);
		yield return Hartman_MoveToPoint(move_SideRoom, 1f);
		Hartman_LookAtPoint(look_OtherRoom, 0.3f);
		Hartman_LookAtPoint(look_FrontDoor, 0.3f);
		HagletYieldTerm WaitedFor5 = CreateTimeCondition(4f);
		yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor5);
		if (WaitedFor5.met)
		{
			HAGIS.DialogShow(ambient_CallTrucker);
			yield return CreateTimeCondition(1f);
			Hartman_PlayAnimation("AngryTalk");
			Hartman_LookAtPoint(look_player, 0.2f);
			yield return Hartman_MoveToPoint(move_tableRight, 1f);
			yield return Hartman_MoveToPoint(move_tableLeft, 1f);
			yield return Hartman_MoveToPoint(move_tableRight, 1f);
			yield return Hartman_MoveToPoint(move_tableLeft, 1f);
			Hartman_LookAtPoint(L_LookAtPhone, 0.2f);
			HagletYieldTerm WaitedFor6 = CreateTimeCondition(7f);
			yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor6);
			if (WaitedFor6.met)
			{
				Hartman_LookAtPoint(look_player, 0.2f);
				HAGIS.DialogShow(ambinet_IWannaWord);
				Hartman_PlayAnimation("AngryTalk");
				yield return Hartman_MoveToPoint(move_tableRight, 0.7f);
				yield return Hartman_MoveToPoint(move_SideRoom, 0.7f);
				Hartman_LookAtPoint(look_OtherRoom, 0.5f);
				yield return CreateTimeCondition(0.5f);
				Hartman_PlayAnimation("AngryTalk");
				HagletYieldTerm WaitedFor7 = CreateTimeCondition(8f);
				yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor7);
				if (WaitedFor7.met)
				{
					Hartman_LookAtPoint(look_player, 0.5f);
					HAGIS.DialogShow(ambient_CallTrucker2);
					Hartman_SetMood(Hartman.Mood.Default);
					Hartman_PlayAnimation("TransAIdleToDIdle");
					yield return CreateTimeCondition(2f);
					Hartman_SetMood(Hartman.Mood.Angry);
					Hartman_PlayAnimation("TransDIdleToAIdle");
					yield return CreateTimeCondition(1.5f);
					Hartman_PlayAnimation("AngryTalk");
					yield return Hartman_MoveToPoint(move_window, 1.5f);
					yield return Hartman_MoveToPoint(move_tableRight, 1f);
					yield return Hartman_MoveToPoint(move_SideRoom2, 1f);
					yield return Hartman_MoveToPoint(move_SideRoom3, 0.5f);
					HagletYieldTerm WaitedFor4 = CreateTimeCondition(6f);
					yield return CreateOrCondition(button_Phone.OnTapUp, WaitedFor4);
					if (WaitedFor4.met)
					{
						HAGIS.DialogShow(ambient_LessAngry);
						Hartman_SetMood(Hartman.Mood.Default);
						Hartman_PlayAnimation("TransAIdleToDIdle");
						yield return Hartman_MoveToPoint(move_SideRoom2, 1f);
						yield return Hartman_MoveToPoint(move_tableRight, 2f, lookAtPlayerOnComplete: true);
						yield return Hartman_PlayAnimation("DefaultTalk");
						yield return CreateTimeCondition(1.2f);
						Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
						yield return CreateTimeCondition(1.5f);
						Hartman_LookAtPoint(look_player, 0.5f);
						yield return button_Phone.OnTapUp;
					}
				}
			}
		}
		SFXPlay("event:/sfx/script/act 1/a1o4/phone call");
		yield return CreateTimeCondition(7f);
		HAGIS.DialogShow(ambient_BugsySmug);
		yield return Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("AngryIdle");
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_tableLeft, 1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		Hartman_PlayAnimation("AngryTalk");
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_tableLeft2, 1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		yield return CreateTimeCondition(22.5f);
		Hartman_MoveToPoint(move_tableLeft3, 1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransAIdleToDIdle");
		yield return CreateTimeCondition(0.6f);
		Hartman_PlayAnimation("DefaultBashTable");
		yield return CreateTimeCondition(1.1f);
		SFXPlay("event:/sfx/character v2/weapon/punch heavy");
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return CreateTimeCondition(1f);
		yield return Hartman_LookAtPoint(look_window, 0.25f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_tableLeft4, 1.5f);
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Sad);
		yield return Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(2.3f);
		HAGIS.DialogShow(ambient_Trophy);
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return Hartman_LookAtPoint(look_window2, 1f);
		HAGIS.DialogShow(ambient_ReachCelestia);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return CreateTimeCondition(4f);
		yield return Hartman_MoveToPoint(move_tableRight, 1f);
		yield return CreateTimeCondition(0.2f);
		Hartman_PlayAnimation("HappyTalk");
		yield return Hartman_MoveToPoint(move_tableLeft, 1f);
		yield return CreateTimeCondition(0.2f);
		yield return Hartman_MoveToPoint(move_tableRight, 1f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(2.5f);
		HAGIS.DialogShow(ambient_LetsStealIt);
		Hartman_LookAtPoint(look_player, 0.25f);
		Hartman_MoveToPoint(move_tableFront, 2f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(0.5f);
		Hartman_MoveToPoint(move_window, 1f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(1f);
		yield return Hartman_LookAtPoint(look_window, 0.25f);
	}
}
public class HAGIS_Hartman_PostA2O7 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_GetEveryone = HAGIS.DialogLoad("Dialogs/PostA2O7/Ambient_GetEveryone");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_tableLeft, look_player);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(0.5f);
		HAGIS.DialogShow(ambient_GetEveryone);
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_tableRight, 2f, lookAtPlayerOnComplete: true);
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_tableLeft, 2f, lookAtPlayerOnComplete: true);
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_tableRight, 1.5f, lookAtPlayerOnComplete: true);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(1.6f);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_window, 3f);
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_Hartman_PostA2S1 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ChuckedBernard = HAGIS.DialogLoad("Dialogs/PostA2S1/Ambient_ChuckedBernard");
		DialogData Ambient_Overheated = HAGIS.DialogLoad("Dialogs/PostA2S1/Ambient_Overheated");
		DialogData Ambient_TryItNow = HAGIS.DialogLoad("Dialogs/PostA2S1/Ambient_TryItNow");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_TableRoughFixingLeft = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_TableRoughFixingRight = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		Hartman_TeleportToPointWithLookAt(move_tableFront, look_window);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("SadIdle");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("TransSIdleToAIdle");
		yield return CreateTimeCondition(0.6f);
		HAGIS.DialogShow(Ambient_Overheated);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransAIdleToDIdle");
		yield return CreateTimeCondition(1.5f);
		HAGIS.DialogShow(ambient_ChuckedBernard);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("TransDIdleToFixTable");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(14f);
		yield return CreateTimeCondition(2f);
		yield return Hartman_PlayAnimation("TransFixTableToDIdle");
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("DefaultIdle");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_TryItNow);
		yield return CreateTimeCondition(0.2f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
	}
}
public class HAGIS_Hartman_PostA2S2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_No = HAGIS.DialogLoad("Dialogs/PostA2S2/Ambient_No");
		DialogData ambient_Redo = HAGIS.DialogLoad("Dialogs/PostA2S2/Ambient_Redo");
		DialogData ambient_WhereIsShe = HAGIS.DialogLoad("Dialogs/PostA2S2/Ambient_WhereIsShe");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_RoomCentre = GetHartmanMovementPoint("M_RoomCentre");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_tableFront, look_player);
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("AngryIdle");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_No);
		Hartman_LookAtPoint(look_Safe, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_OtherRoom, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_Safe, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_OtherRoom, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_Safe, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_OtherRoom, 0.25f);
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_OtherRoom, 0.25f);
		Hartman_PlayAnimation("AngryTalk");
		yield return CreateTimeCondition(1.3f);
		Hartman_PlayAnimation("TransAIdleToDIdle");
		yield return CreateTimeCondition(0.28f);
		HAGIS.DialogShow(ambient_Redo);
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(0.3f);
		yield return Hartman_MoveToPoint(move_tableRight, 0.7f);
		yield return Hartman_MoveToPoint(move_Butterflies, 1f);
		yield return Hartman_MoveToPoint(move_SideRoom, 0.7f);
		yield return Hartman_MoveToPoint(move_tableLeft, 1.5f);
		yield return Hartman_MoveToPoint(move_RoomCentre, 1.5f);
		Hartman_LookAtPoint(look_player, 0.5f);
		HAGIS.DialogShow(ambient_WhereIsShe);
		yield return CreateTimeCondition(3.5f);
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(3f);
	}
}
public class HAGIS_Hartman_PostA3O1 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_TheShiners = HAGIS.DialogLoad("Dialogs/PostA3O1/Ambient_TheShiners");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_tableLeft, look_window);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_TheShiners);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("HappyIdle");
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(2.1f);
		Hartman_PlayAnimation("HappyTalk");
		Hartman_MoveToPoint(move_Butterflies, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_OtherRoom, 0.2f);
		yield return CreateTimeCondition(2.4f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(3f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransHIdleToCIdle");
		yield return CreateTimeCondition(3f);
	}
}
public class HAGIS_Hartman_PostA3O2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_WithRupert = HAGIS.DialogLoad("Dialogs/PostA3O2/Ambient_WithRupert");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_window2 = GetHartmanLookAtPoint("L_Window2");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_tableRight, look_window);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return null;
		Hartman_MoveToPoint(move_tableLeft, 2f);
		yield return CreateTimeCondition(0.5f);
		HAGIS.DialogShow(ambient_WithRupert);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_window, 0.6f);
		yield return CreateTimeCondition(0.9f);
		Hartman_MoveToPoint(move_Butterflies, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_Butterflies, 0.6f);
		Hartman_SetMood(Hartman.Mood.Sad);
		yield return Hartman_PlayAnimation("TransDIdleToSIdle");
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return CreateTimeCondition(1.2f);
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("DefaultTalk");
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		Hartman_MoveToPoint(move_window, 1.5f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_window, 0.2f);
		yield return CreateTimeCondition(1.7f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_window2, 1f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(3f);
	}
}
public class HAGIS_Hartman_PostA3O3 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_WannaGetThat = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_WannaGetThat");
		DialogData ambient_JulesPhoneCall = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_JulesPhoneCall");
		DialogData ambient_GiveUp = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_GiveUp");
		DialogData ambient_LostControl = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_LostControl");
		DialogData ambient_CallGosz = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_CallGosz");
		DialogData ambient_StopTheDroids = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_StopTheDroids");
		DialogData ambient_PhoneCallGosz = HAGIS.DialogLoad("Dialogs/PostA3O3/Ambient_PhoneCallGosz");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_window2 = GetHartmanMovementPoint("M_Window2");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_window2 = GetHartmanLookAtPoint("L_Window2");
		HartmanLookAtPoint look_window3 = GetHartmanLookAtPoint("L_Window3");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		UIButtonHaglet button_Phone = GetUIButtonHaglet("P_Phone");
		UIButtonHaglet button_PhoneGosz = GetUIButtonHaglet("P_PhoneGosz");
		KubrickBase PhoneJiggle = GetRoomAnimator("MA_Apartment_Telephone_01");
		button_PhoneGosz.gameObject.SetActive(value: false);
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_Butterflies, look_Butterflies);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(2f);
		LoopingSFX PhoneRinging = LoopingSFXPlayAtRoomObject("event:/sfx/script/act 1/a1o4/phone ringing", "SM_Apartment_Telephone");
		PhoneJiggle.Play("MA_Telephone");
		PhoneJiggle.WrapMode = WrapMode.Loop;
		yield return CreateTimeCondition(1.5f);
		HAGIS.DialogShow(ambient_WannaGetThat);
		yield return button_Phone.OnTapUp;
		PhoneRinging.Stop();
		SFXPlay("event:/sfx/script/act 1/a1o4/phone pick up");
		PhoneJiggle.WrapMode = WrapMode.Once;
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("TransFixTableToDIdle");
		HAGIS.DialogShow(ambient_JulesPhoneCall);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_SideRoom, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("TransDIdleToSIdle");
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_tableLeft, 1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		yield return CreateTimeCondition(3f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(6f);
		Hartman_PlayAnimation("SadTalk");
		Hartman_LookAtPoint(look_player, 0.6f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window3, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.3f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.3f);
		yield return CreateTimeCondition(7f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_JulesPhoneCall);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TransSIdleToDIdle");
		HAGIS.DialogShow(ambient_GiveUp);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_GiveUp);
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("AngryIdle");
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		HAGIS.DialogShow(ambient_LostControl);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("AngryTalk");
		yield return CreateTimeCondition(5f);
		yield return CreateTimeCondition(4f);
		Hartman_SetMood(Hartman.Mood.Sad);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return Hartman_PlayAnimation("TransAIdleToDIdle");
		Hartman_LookAtPoint(look_player, 1f);
		yield return Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window, 0.5f);
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_MoveToPoint(move_window2, 1f);
		yield return Hartman_MoveToPoint(move_window, 1f);
		yield return CreateTimeCondition(3f);
		yield return Hartman_PlayAnimation("TransSIdleToDIdle");
		Hartman_SetMood(Hartman.Mood.Concerned);
		HAGIS.DialogShow(ambient_CallGosz);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		button_Phone.gameObject.SetActive(value: false);
		button_PhoneGosz.gameObject.SetActive(value: true);
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_CallGosz);
		Hartman_LookAtPoint(look_window2, 0.5f);
		HagletYieldTerm WaitedFor5 = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_PhoneGosz.OnTapUp, WaitedFor5);
		if (WaitedFor5.met)
		{
			HAGIS.DialogShow(ambient_StopTheDroids);
			Hartman_LookAtPoint(look_player, 0.5f);
			Hartman_PlayAnimation("ConcernedTalk");
			HagisLog("Reminder");
			yield return button_PhoneGosz.OnTapUp;
		}
		SFXPlay("event:/sfx/script/act 1/a1o4/phone call");
		yield return CreateTimeCondition(7f);
		HAGIS.DialogShow(ambient_PhoneCallGosz);
		yield return Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("ConcernedTalk");
		Hartman_LookAtPoint(look_window, 1f);
		yield return CreateTimeCondition(2f);
		yield return Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(1f);
		yield return Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_PhoneCallGosz);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		yield return CreateTimeCondition(2f);
	}
}
public class HAGIS_Hartman_PostA3O4 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_WhatNow = HAGIS.DialogLoad("Dialogs/PostA3O4/Ambient_WhatNow");
		DialogData ambient_CallThemOff = HAGIS.DialogLoad("Dialogs/PostA3O4/Ambient_CallThemOff");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		UIButtonHaglet button_Phone = GetUIButtonHaglet("P_Phone");
		KubrickBase PhoneJiggle = GetRoomAnimator("MA_Apartment_Telephone_01");
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_window, look_window);
		Hartman_SetMood(Hartman.Mood.Default);
		LoopingSFX PhoneRinging = LoopingSFXPlayAtRoomObject("event:/sfx/script/act 1/a1o4/phone ringing", "SM_Apartment_Telephone");
		PhoneJiggle.Play("MA_Telephone");
		PhoneJiggle.WrapMode = WrapMode.Loop;
		yield return CreateTimeCondition(1.3f);
		Hartman_SetMood(Hartman.Mood.Angry);
		Hartman_PlayAnimation("TransDIdleToAIdle");
		HAGIS.DialogShow(ambient_WhatNow);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return button_Phone.OnTapUp;
		PhoneRinging.Stop();
		SFXPlay("event:/sfx/script/act 1/a1o4/phone pick up");
		PhoneJiggle.WrapMode = WrapMode.Once;
		HAGIS.DialogShow(ambient_CallThemOff);
		yield return Hartman_MoveToPoint(move_tableLeft, 0.5f);
		Hartman_PlayAnimation("AngryTalk");
		Hartman_LookAtPoint(L_LookAtPhone, 0.3f);
		yield return CreateTimeCondition(1.1f);
		HagisLog("SFX OF EXPLOSIONS IN BACKGROUND");
		Hartman_SetMood(Hartman.Mood.Sad);
		yield return Hartman_PlayAnimation("TransAIdleToDIdle");
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(0.9f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		HagisLog("MORE EXPLOSIONS IN BACKGROUND");
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(7f);
		HagisLog("SFX OF PHONE DIAL TONE");
		yield return Hartman_LookAtPoint(look_player, 0.7f);
	}
}
public class HAGIS_Hartman_PostA3O5 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_Transmitter = HAGIS.DialogLoad("Dialogs/PostA3O5/Ambient_Transmitter");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_window2 = GetHartmanLookAtPoint("L_Window2");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_SideRoom, look_Butterflies);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_Transmitter);
		Hartman_MoveToPoint(move_tableLeft, 3f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_Butterflies, 0.25f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdel");
		yield return CreateTimeCondition(4f);
		Hartman_MoveToPoint(move_window, 1f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window, 0.25f);
		yield return CreateTimeCondition(1.3f);
		Hartman_PlayAnimation("ConcernedTalk");
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_window, 0.6f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window2, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransCIdleToDIdle");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransDIdleToHIdle");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(0.5f);
	}
}
public class HAGIS_Hartman_PostA3O8 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_WeTried = HAGIS.DialogLoad("Dialogs/PostA3O8/Ambient_WeTried");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		yield return null;
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("SadIdel");
		Hartman_TeleportToPointWithLookAt(move_SideRoom, look_OtherRoom);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_WeTried);
		Hartman_PlayAnimation("SadTalk");
		yield return Hartman_LookAtPoint(look_player, 0.9f);
		yield return CreateTimeCondition(0.6f);
		yield return Hartman_LookAtPoint(look_Safe, 0.3f);
		yield return CreateTimeCondition(0.1f);
		yield return Hartman_LookAtPoint(look_player, 0.3f);
		yield return CreateTimeCondition(0.1f);
		yield return Hartman_LookAtPoint(look_Safe, 0.3f);
		yield return CreateTimeCondition(0.1f);
		yield return Hartman_LookAtPoint(look_player, 0.3f);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_OtherRoom, 1f);
		yield return CreateTimeCondition(2f);
		yield return CreateTimeCondition(0.7f);
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_Hartman_PostA3S1 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ShesStrong = HAGIS.DialogLoad("Dialogs/PostA3S1/Ambient_ShesStrong");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		Hartman_TeleportToPointWithLookAt(move_Butterflies, look_Safe);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_ShesStrong);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_player, 0.7f);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_window, 4f);
		Hartman_LookAtPoint(look_window, 0.25f);
		yield return CreateTimeCondition(1.5f);
		Hartman_MoveToPoint(move_window, 4f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(1.8f);
		Hartman_LookAtPoint(look_window, 0.5f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(3f);
	}
}
public class HAGIS_Hartman_PostA3S2 : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_OurGuest = HAGIS.DialogLoad("Dialogs/PostA3S2/Ambiant_OurGest");
		DialogData ambient_ReachedCelestia = HAGIS.DialogLoad("Dialogs/PostA3S2/Ambient_ReachedCelestia");
		DialogData ambient_craven = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_Craven");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_Intro = GetHartmanMovementPoint("M_HartStart");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_Crate = GetHartmanLookAtPoint("L_Safe");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		UIButtonHaglet button_HolomapTurnOn = GetUIButtonHaglet("P_Holomap");
		KubrickBase FrontDoor = GetRoomAnimator("MA_FrontDoor");
		GameObject Violin = RR.Inst.transform.Find("DynamicArt").Find("MA_ViolinCase").gameObject;
		GameObject HartHat = RR.Inst.transform.Find("DynamicArt").Find("SM_Character_Hartman_Hat").gameObject;
		HartHat.gameObject.SetActive(value: false);
		Violin.gameObject.SetActive(value: false);
		button_HolomapTurnOn.gameObject.SetActive(value: false);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Default);
		Singleton<Hartman>.Inst.ResetOutside();
		yield return CreateTimeCondition(2f);
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_door knock");
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/script/act 1/a1o1/open penthouse door");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("Intro");
		yield return Wait.ForSteps(1uL);
		Hartman_TeleportToPoint(move_Intro);
		yield return CreateTimeCondition(1.5f);
		FrontDoor.Play("Open");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_ReachedCelestia);
		yield return CreateTimeCondition(2.99f);
		HartHat.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransHIdleToCIdle");
		Hartman_LookAtPoint(look_player, 1f);
		Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransCIdleToHIdle");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		Hartman_MoveToPoint(move_Intro, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_OurGuest);
		Hartman_PlayAnimation("TransDIdleToFixTable");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(2f);
		yield return Hartman_PlayAnimation("TransFixTableToDIdle");
		Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("DefaultBashTable");
		yield return CreateTimeCondition(1.1f);
		SFXPlay("event:/sfx/character v2/weapon/punch heavy");
		yield return CreateTimeCondition(0.5f);
		SFXPlay("event:/sfx/script/act 1/a1o1/hollow map table power up");
		yield return CreateTimeCondition(0.6f);
		Hartman_MoveToPoint(move_Intro, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		Hartman_LookAtPoint(look_Crate, 2f);
	}
}
public class HAGIS_Hartman_PostA3S3 : HAGIS
{
	private bool happyAvailable;

	private bool sadAvailable;

	private Transform TransViolin;

	private GameObject GoCaseCard;

	private GameObject GoodEndingSticker;

	private GameObject EvilEndingSticker;

	private KubrickBase AnimBusinessCard;

	private KubrickBase AnimCaseOpening;

	private KubrickBase AnimAtlantium;

	private UIButtonHaglet button_BusinessCard;

	private UIButtonHaglet button_Atlantium;

	private UIButtonHaglet button_BusinessCardConfirmChoice;

	private UIButtonHaglet button_AtlantiumConfirmChoice;

	private void ResetButtonState()
	{
		button_BusinessCard.gameObject.SetActive(happyAvailable);
		button_BusinessCardConfirmChoice.gameObject.SetActive(happyAvailable);
		AnimBusinessCard.gameObject.SetActive(happyAvailable);
		GoCaseCard.gameObject.SetActive(value: false);
		button_Atlantium.gameObject.SetActive(sadAvailable);
		button_AtlantiumConfirmChoice.gameObject.SetActive(sadAvailable);
		AnimAtlantium.gameObject.SetActive(value: true);
		button_BusinessCardConfirmChoice.gameObject.SetActive(value: false);
		button_AtlantiumConfirmChoice.gameObject.SetActive(value: false);
	}

	private void TurnOffAllStateButtons()
	{
		button_BusinessCard.gameObject.SetActive(value: false);
		button_BusinessCardConfirmChoice.gameObject.SetActive(value: false);
		button_Atlantium.gameObject.SetActive(value: false);
		button_AtlantiumConfirmChoice.gameObject.SetActive(value: false);
		button_BusinessCardConfirmChoice.gameObject.SetActive(value: false);
		button_AtlantiumConfirmChoice.gameObject.SetActive(value: false);
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_TheyFoundIt = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_TheyFoundIt");
		DialogData ambient_ItsHere = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_ItsHere");
		DialogData ambient_IfYouDestroy = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_IfYouDestroy");
		DialogData ambient_IsThis = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_IsThis");
		DialogData ambient_ItsWhoWeAre = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_ItsWhoWeAre");
		DialogData ambient_ItsOurs = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_ItsOurs");
		DialogData ambient_ItsOurs2 = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_ItsOurs2");
		DialogData ambiant_GiveAwayAtlantium = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambiant_GiveAwayAtlantium");
		DialogData ambiant_WhatYouWant = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambiant_WhatYouWant");
		DialogData ambient_WeDidIt = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_WeDidIt");
		DialogData ambient_TimeToPlug = HAGIS.DialogLoad("Dialogs/PostA3S3/Ambient_TimeToPullPlug");
		DialogData Dialog_PlayerDecision2 = HAGIS.DialogLoad("Dialogs/PostA3S3/Dialog_PlayerDecision2");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_Butterflies = GetHartmanMovementPoint("M_Butterflies");
		HartmanMovementPoint move_SideRoom = GetHartmanMovementPoint("M_SideRoom");
		HartmanMovementPoint move_OutsideA3S3 = GetHartmanMovementPoint("M_OutsideEndA3S3");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_window2 = GetHartmanLookAtPoint("L_Window2");
		HartmanLookAtPoint look_Butterflies = GetHartmanLookAtPoint("L_Butterflies");
		HartmanLookAtPoint look_OtherRoom = GetHartmanLookAtPoint("L_OtherRoom");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		button_BusinessCard = GetUIButtonHaglet("P_BusinessCard");
		button_Atlantium = GetUIButtonHaglet("P_Atlantium");
		button_BusinessCardConfirmChoice = GetUIButtonHaglet("P_BusinessCardConfirmChoice");
		button_AtlantiumConfirmChoice = GetUIButtonHaglet("P_AtlantiumConfirmChoice");
		bool HappyEnding = false;
		bool BothChoiceEnding2 = false;
		bool FullTragicEnding = false;
		GameObject HartHat = RR.Inst.transform.Find("DynamicArt").Find("SM_Character_Hartman_Hat").gameObject;
		HartHat.gameObject.SetActive(value: false);
		TransViolin = RR.Inst.transform.GetComponentInChildren<STUB_Violin>(includeInactive: true).transform;
		TransViolin.gameObject.SetActive(value: true);
		GoCaseCard = TransViolin.transform.Find("MA_CaseOpener").Find("SM_Apartment_ViolinCase_Lid").Find("SM_Apartment_BusinessCard")
			.gameObject;
		GoodEndingSticker = TransViolin.transform.Find("MA_CaseOpener").Find("SM_Apartment_ViolinCase_Lid").Find("SM_Apartment_ViolinCase_Sticker_01")
			.gameObject;
		EvilEndingSticker = TransViolin.transform.Find("MA_CaseOpener").Find("SM_Apartment_ViolinCase_Lid").Find("SM_Apartment_ViolinCase_Sticker_02")
			.gameObject;
		AnimBusinessCard = GetRoomAnimator("MA_BusinessCard");
		AnimCaseOpening = GetRoomAnimator("MA_CaseOpener");
		AnimAtlantium = GetRoomAnimator("MA_ATLANTIUM");
		GoodEndingSticker.gameObject.SetActive(value: false);
		EvilEndingSticker.gameObject.SetActive(value: false);
		AnimBusinessCard.gameObject.SetActive(value: false);
		GoCaseCard.SetActive(value: true);
		button_BusinessCardConfirmChoice.gameObject.SetActive(value: false);
		button_AtlantiumConfirmChoice.gameObject.SetActive(value: false);
		button_Atlantium.gameObject.SetActive(value: false);
		button_BusinessCard.gameObject.SetActive(value: false);
		button_BusinessCard.OnFocusEnterWithUserData += delegate
		{
			AnimBusinessCard.WrapMode = WrapMode.Loop;
			AnimBusinessCard.Play("Hover");
		};
		button_BusinessCard.OnFocusExitWithUserData += delegate
		{
			AnimBusinessCard.WrapMode = WrapMode.Once;
		};
		button_BusinessCard.SetSparkleEnabled(enabled: true);
		button_BusinessCard.SetSparkleOptional(isOptional: true);
		button_Atlantium.OnFocusEnterWithUserData += delegate
		{
			AnimAtlantium.WrapMode = WrapMode.Loop;
			AnimAtlantium.Play("Hover");
		};
		button_Atlantium.OnFocusExitWithUserData += delegate
		{
			AnimAtlantium.WrapMode = WrapMode.Once;
		};
		yield return null;
		Hartman_TeleportToPointWithLookAt(move_tableRight, look_player);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		HAGIS.DialogShow(ambient_TheyFoundIt);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_Safe, 0.5f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_tableFront, 1f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 0.5f);
		bool flag = HAGIS.WasHonestThroughoutSection(DC.GameSection.ONE);
		bool flag2 = HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_A, DC.GameSection.TWO_B);
		bool flag3 = HAGIS.WasHonestThroughoutSection(DC.GameSection.THREE);
		if (flag && flag2 && flag3)
		{
			happyAvailable = false;
			sadAvailable = true;
		}
		else if (flag && flag2 && !flag3)
		{
			happyAvailable = true;
			sadAvailable = true;
		}
		else if (flag && !flag2 && flag3)
		{
			happyAvailable = true;
			sadAvailable = false;
		}
		else if (flag && !flag2 && !flag3)
		{
			happyAvailable = true;
			sadAvailable = true;
		}
		else if (!flag && flag2 && flag3)
		{
			happyAvailable = true;
			sadAvailable = true;
		}
		else if (!flag && flag2 && !flag3)
		{
			happyAvailable = true;
			sadAvailable = false;
		}
		else if (!flag && !flag2 && flag3)
		{
			happyAvailable = true;
			sadAvailable = true;
		}
		else if (!flag && !flag2 && !flag3)
		{
			happyAvailable = false;
			sadAvailable = true;
		}
		if (!happyAvailable)
		{
			sadAvailable = true;
		}
		ResetButtonState();
		GoCaseCard.gameObject.SetActive(happyAvailable);
		LoopingSFX Atlantium = LoopingSFXPlayAtRoomObject("event:/music/tracks/bespoke/atlantium decision", "MA_ViolinCase");
		AnimCaseOpening.Play("Open");
		AnimBusinessCard.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(2f);
		GoCaseCard.SetActive(value: false);
		AnimBusinessCard.gameObject.SetActive(happyAvailable);
		yield return CreateTimeCondition(1f);
		HagisLog("POST: Entering Selection Loop, Happy Ending " + happyAvailable + ", Bad Ending " + sadAvailable);
		bool focusingAtlantium = false;
		bool focusingCard = false;
		bool HasGoodVOBeenPlayed = false;
		bool EvilVOHasPlayed = false;
		while (!HappyEnding && !FullTragicEnding && !BothChoiceEnding2)
		{
			HagletYieldTerm businessCardTapped = CreateTriggerCondition(button_BusinessCard.OnTapUp);
			HagletYieldTerm atlantiumTapped = CreateTriggerCondition(button_Atlantium.OnTapUp);
			HagletYieldTerm confirmBusinessCardTapped = CreateTriggerCondition(button_BusinessCardConfirmChoice.OnTapUp);
			HagletYieldTerm confirmAtlantiumTapped = CreateTriggerCondition(button_AtlantiumConfirmChoice.OnTapUp);
			yield return businessCardTapped | atlantiumTapped | confirmBusinessCardTapped | confirmAtlantiumTapped;
			button_AtlantiumConfirmChoice.SetSparkleEnabled(enabled: false);
			button_BusinessCardConfirmChoice.SetSparkleEnabled(enabled: false);
			HagisLog("POST: Selected something!");
			if (businessCardTapped.met)
			{
				HagisLog("POST: Selected Card");
				TurnOffAllStateButtons();
				Atlantium.SetParameter("progress", 0.1f);
				if (!HasGoodVOBeenPlayed)
				{
					HasGoodVOBeenPlayed = true;
					HAGIS.DialogShow(ambiant_GiveAwayAtlantium);
					yield return CreateTimeCondition(3f);
					yield return Hartman_PlayAnimation("TransCIdleToHIdle");
					yield return Hartman_PlayAnimation("TransHIdleToCIdle");
					yield return CreateTimeCondition(4f);
					Hartman_PlayAnimation("ConcernedTalk");
					yield return CreateTimeCondition(6f);
					Hartman_PlayAnimation("ConcernedIdleAlt");
					Hartman_LookAtPoint(look_Safe, 0.5f);
					yield return CreateTimeCondition(1f);
					Hartman_LookAtPoint(look_player, 0.5f);
					yield return CreateTimeCondition(4f);
				}
				ResetButtonState();
				button_BusinessCardConfirmChoice.gameObject.SetActive(value: true);
				button_BusinessCardConfirmChoice.SetSparkleEnabled(enabled: true);
				button_BusinessCard.gameObject.SetActive(value: false);
				HAGIS.DialogShow(ambient_IsThis);
				Hartman_PlayAnimation("ConcernedIdleAlt");
				AnimBusinessCard.gameObject.SetActive(value: true);
				AnimBusinessCard.Play("Selected");
				AnimBusinessCard.WrapMode = WrapMode.Once;
				focusingCard = true;
				if (focusingAtlantium)
				{
					AnimAtlantium.WrapMode = WrapMode.Once;
					AnimAtlantium.Play("PutBack");
					button_AtlantiumConfirmChoice.gameObject.SetActive(value: false);
					button_Atlantium.gameObject.SetActive(value: true);
					focusingAtlantium = false;
				}
			}
			else if (atlantiumTapped.met)
			{
				HagisLog("POST: Selected Atlantium");
				TurnOffAllStateButtons();
				Atlantium.SetParameter("progress", 0.2f);
				if (!EvilVOHasPlayed)
				{
					EvilVOHasPlayed = true;
					HAGIS.DialogShow(ambient_IfYouDestroy);
					yield return CreateTimeCondition(2f);
					Hartman_LookAtPoint(look_Safe, 0.5f);
					yield return CreateTimeCondition(3f);
					Hartman_LookAtPoint(look_player, 0.5f);
					yield return CreateTimeCondition(3f);
					yield return Hartman_PlayAnimation("TransCIdleToHIdle");
					yield return Hartman_PlayAnimation("TransHIdleToCIdle");
					yield return CreateTimeCondition(3f);
					Hartman_LookAtPoint(look_window, 0.5f);
					yield return CreateTimeCondition(1f);
					Hartman_MoveToPoint(move_window, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
					Hartman_LookAtPoint(look_window, 0.5f);
					yield return CreateTimeCondition(1f);
					Hartman_SetMood(Hartman.Mood.Default);
					Hartman_PlayAnimation("TransCIdleToDIdle");
					yield return CreateTimeCondition(2f);
					Hartman_LookAtPoint(look_player, 1f);
					Hartman_PlayAnimation("DefaultTalk");
					yield return CreateTimeCondition(2f);
					Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
					yield return CreateTimeCondition(1.8f);
					Hartman_SetMood(Hartman.Mood.Concerned);
					Hartman_PlayAnimation("TransDIdleToCIdle");
					Hartman_LookAtPoint(look_player, 1f);
					yield return CreateTimeCondition(1f);
				}
				ResetButtonState();
				button_AtlantiumConfirmChoice.gameObject.SetActive(value: true);
				button_AtlantiumConfirmChoice.SetSparkleEnabled(enabled: true);
				button_Atlantium.gameObject.SetActive(value: false);
				HAGIS.DialogShow(ambient_IsThis);
				Hartman_PlayAnimation("ConcernedTalk");
				AnimAtlantium.Play("Selected");
				AnimAtlantium.WrapMode = WrapMode.Once;
				focusingAtlantium = true;
				if (focusingCard)
				{
					AnimBusinessCard.WrapMode = WrapMode.Once;
					AnimBusinessCard.Play("PutBack");
					button_BusinessCardConfirmChoice.gameObject.SetActive(value: false);
					button_BusinessCard.gameObject.SetActive(value: true);
					focusingCard = false;
				}
			}
			else if (confirmBusinessCardTapped.met)
			{
				HagisLog("POST: Confirmed Card");
				HappyEnding = true;
				TurnOffAllStateButtons();
				AnimBusinessCard.WrapMode = WrapMode.Once;
				HAGIS.DialogShow(ambient_WeDidIt);
				Atlantium.SetParameter("progress", 0.3f);
				yield return CreateTimeCondition(0.3f);
				GoodEndingSticker.gameObject.SetActive(value: true);
				AnimBusinessCard.Play("PutBack");
				Hartman_MoveToPoint(move_SideRoom, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
				Hartman_LookAtPoint(look_player, 0.5f);
				yield return CreateTimeCondition(0.3f);
				Hartman_SetMood(Hartman.Mood.Happy);
				Hartman_PlayAnimation("TransCIdleToHIdle");
				yield return CreateTimeCondition(0.7f);
				AnimBusinessCard.gameObject.SetActive(value: false);
				GoCaseCard.SetActive(happyAvailable);
				AnimCaseOpening.Play("Close");
				Atlantium.Stop();
				yield return CreateTimeCondition(1f);
				Hartman_LookAtPoint(look_OtherRoom, 1f);
				yield return CreateTimeCondition(1f);
			}
			else if (confirmAtlantiumTapped.met)
			{
				HagisLog("POST: Confirmed Atlantium");
				FullTragicEnding = true;
				TurnOffAllStateButtons();
				AnimAtlantium.WrapMode = WrapMode.Once;
				HAGIS.DialogShow(ambient_ItsWhoWeAre);
				Atlantium.SetParameter("progress", 0.3f);
				yield return CreateTimeCondition(0.3f);
				Hartman_SetMood(Hartman.Mood.Default);
				Hartman_PlayAnimation("TransCIdleToDIdle");
				EvilEndingSticker.gameObject.SetActive(value: true);
				AnimAtlantium.Play("PutBack");
				yield return CreateTimeCondition(2f);
				AnimBusinessCard.gameObject.SetActive(value: false);
				GoCaseCard.SetActive(happyAvailable);
				yield return CreateTimeCondition(1f);
				Atlantium.Stop();
				AnimCaseOpening.Play("Close");
			}
		}
		BothChoiceEnding2 = happyAvailable && sadAvailable;
		HagisLog("About to enter the final bit");
		if (HappyEnding)
		{
			yield return CreateTimeCondition(1f);
			HAGIS.DialogShow(ambient_TimeToPlug);
			yield return CreateTimeCondition(1.3f);
			Hartman_SetMood(Hartman.Mood.Default);
			Hartman_PlayAnimation("TransHIdleToDIdle");
			yield return CreateTimeCondition(1.5f);
			Hartman_LookAtPoint(look_player, 1f);
			yield return CreateTimeCondition(2f);
			Hartman_LookAtPoint(look_Butterflies, 1f);
			UICredits.Inst.PlayCreditsTheme();
			yield return CreateTimeCondition(2f);
			Hartman_MoveToPoint(move_tableLeft, 3.5f);
			Hartman_LookAtPoint(look_Butterflies, 0.5f);
			yield return CreateTimeCondition(4f);
			Hartman_LookAtPoint(look_player, 1f);
		}
		else if (FullTragicEnding)
		{
			yield return CreateTimeCondition(1f);
			HAGIS.DialogShow(ambient_ItsOurs);
			SFXPlay("event:/sfx/script/act 2/a2o7/ominous thunder rumble");
			Hartman_LookAtPoint(look_Safe, 2f);
			yield return CreateTimeCondition(3f);
			HAGIS.DialogShow(ambient_ItsOurs2);
			Hartman_MoveToPoint(move_tableLeft, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
			Hartman_LookAtPoint(look_window, 0.5f);
			yield return CreateTimeCondition(2f);
			Hartman_PlayAnimation("DefaultTalk");
			yield return CreateTimeCondition(2f);
			yield return Hartman_LookAtPoint(look_window2, 1f);
			UICredits.Inst.PlayCreditsTheme();
			Hartman_LookAtPoint(look_player, 0.5f);
			Hartman_SetMood(Hartman.Mood.Happy);
			yield return Hartman_PlayAnimation("TransDIdleToHIdle");
			Hartman_PlayAnimation("HappyIdle");
			yield return CreateTimeCondition(2f);
			Hartman_SetMood(Hartman.Mood.Default);
			yield return Hartman_PlayAnimation("TransHIdleToDIdle");
			Hartman_PlayAnimation("DefaultIdle");
			yield return Hartman_LookAtPoint(look_Butterflies, 2f);
		}
		yield return CreateTimeCondition(2f);
		Hartman_MoveToPoint(move_Butterflies, 4.5f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_Butterflies, 0.5f);
		yield return CreateTimeCondition(5f);
		Hartman_PlayAnimation("DefaultUnplug");
		yield return CreateTimeCondition(0.2f);
		SFXPlay("event:/sfx/ability/brawl regular");
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/ability/sap");
		yield return CreateTimeCondition(1f);
		FadeToBlack();
		yield return CreateTimeCondition(2.5f);
		Hartman_TeleportToPointWithLookAt(move_OutsideA3S3, look_player);
		float t = 0f;
		while (t < 1f)
		{
			LR.Inst.SetLogoAlpha(LR.Inst.logoFadeCurve.Evaluate(t));
			t += Time.deltaTime / 5f;
			yield return null;
		}
		yield return Wait.ForSeconds(3f);
		while (t > 0f)
		{
			LR.Inst.SetLogoAlpha(LR.Inst.logoFadeCurve.Evaluate(t));
			t -= Time.deltaTime / 3f;
			yield return null;
		}
		RC.Inst.RoomHide();
		yield return CreateTimeCondition(0.5f);
		FadeToClear();
		yield return AECameraFullscreenPass.Inst.OnFadeToClearComplete;
		SaveData.data.chosenMission = null;
		SaveData.SaveProgress();
		UICredits.Inst.autoPlayMusic = false;
		UICredits credits = Singleton<UIC>.Inst.Push<UICredits>();
		yield return credits.OnHide;
		TransViolin.gameObject.SetActive(value: false);
		RC.Inst.RoomShow();
	}
}
public class HAGIS_Hartman_PostPhoneMolly : HAGIS
{
	private HagletResettable _onLogic;

	public static bool HACK_gotoPhoneMollyHagis;

	private DialogData ambient_FluxCompression;

	private DialogData ambient_FluxCompression2;

	private DialogData ambient_PhoneMolly;

	private DialogData ambient_MollyPhoneCall;

	private DialogData ambient_OkayWhereTo;

	private DialogData ambient_whereNext;

	private HartmanMovementPoint M_TableRight;

	private HartmanMovementPoint M_TableRight2;

	private HartmanMovementPoint move_tableLeft;

	private HartmanMovementPoint move_window;

	private HartmanLookAtPoint look_player;

	private HartmanLookAtPoint look_window;

	private HartmanLookAtPoint L_LookAtPhone;

	private HartmanLookAtPoint L_Safe;

	private UIButtonHaglet button_PhoneMolly;

	public override void OnAwakeRoot()
	{
		base.OnAwakeRoot();
		_onLogic = new HagletResettable(OnLogic(), "Phone Molly");
		InitVars();
	}

	public HagletEvent PlayPhoneMolly()
	{
		Routine.Start(_onLogic, LR.Host);
		return _onLogic.completed;
	}

	public void InitVars()
	{
		ambient_FluxCompression = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_FluxCompression");
		ambient_FluxCompression2 = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_FluxCompression2");
		ambient_PhoneMolly = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_PhoneMolly");
		ambient_MollyPhoneCall = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_MollyPhoneCall");
		ambient_OkayWhereTo = HAGIS.DialogLoad("Dialogs/PostA1O4/Ambient_OkayWhereTo");
		ambient_whereNext = HAGIS.DialogLoad("Dialogs/PostA1O3/Ambient_WhereNext");
		M_TableRight = GetHartmanMovementPoint("M_TableRight");
		M_TableRight2 = GetHartmanMovementPoint("M_TableRight2");
		move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		move_window = GetHartmanMovementPoint("M_Window");
		look_player = GetHartmanLookAtPoint("L_Player");
		look_window = GetHartmanLookAtPoint("L_Window");
		L_LookAtPhone = GetHartmanLookAtPoint("L_LookAtPhone");
		L_Safe = GetHartmanLookAtPoint("L_Safe");
		button_PhoneMolly = GetUIButtonHaglet("P_PhoneMolly");
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		button_PhoneMolly.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(4f);
		HAGIS.DialogShow(ambient_FluxCompression2);
		HagisLog("speaking of dangerous");
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1.5f);
		HagisLog("we to get this");
		Hartman_MoveToPoint(M_TableRight, 2f);
		Hartman_LookAtPoint(L_Safe, 0.5f);
		yield return CreateTimeCondition(2f);
		HagisLog("mollys a local");
		Hartman_LookAtPoint(look_player, 0.5f);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2f);
		HagisLog("hit her up");
		Hartman_LookAtPoint(L_LookAtPhone, 1f);
		yield return CreateTimeCondition(3f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransCIdleToDIdle");
		Hartman_LookAtPoint(look_player, 1f);
		button_PhoneMolly.gameObject.SetActive(value: true);
		HagletYieldTerm WaitedFor5 = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_PhoneMolly.OnTapUp, WaitedFor5);
		if (WaitedFor5.met)
		{
			Hartman_PlayAnimation("DefaultTalk");
			HAGIS.DialogShow(ambient_PhoneMolly);
			HagisLog("Reminder");
			yield return button_PhoneMolly.OnTapUp;
		}
		button_PhoneMolly.gameObject.SetActive(value: false);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone call");
		yield return Hartman_MoveToPoint(move_tableLeft, 1f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.5f);
		yield return CreateTimeCondition(6f);
		HAGIS.DialogShow(ambient_MollyPhoneCall);
		yield return CreateTimeCondition(1f);
		HagisLog("Crave and hart mam");
		yield return Hartman_PlayAnimation("DefaultTalk");
		HagisLog("oh hey");
		yield return CreateTimeCondition(2f);
		HagisLog("need something delivered");
		yield return Hartman_PlayAnimation("DefaultTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		yield return Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1.5f);
		HagisLog("hmmm nahh");
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(1f);
		yield return Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		HagisLog("and the second?");
		yield return CreateTimeCondition(2f);
		HagisLog("looking for a runner");
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransCIdleToHIdle");
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(4f);
		HagisLog("Ambro? yeah.");
		Hartman_LookAtPoint(L_LookAtPhone, 0.25f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(2f);
		HagisLog("oh yeah, we've met.");
		Hartman_PlayAnimation("DefaultTalk");
		Hartman_LookAtPoint(look_player, 0.4f);
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(L_LookAtPhone, 0.4f);
		HagisLog("send me whatever");
		yield return CreateTimeCondition(3f);
		SFXPlay("event:/sfx/script/act 1/a1o4/phone put down");
		Hartman_LookAtPoint(look_player, 0.4f);
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("ConcernedIdle");
		HAGIS.DialogShow(ambient_OkayWhereTo);
		yield return CreateTimeCondition(2f);
	}
}
public class HAGIS_Hartman_Prologue : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData ambient_ashleyCity = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_AshleyCity");
		DialogData ambient_ashleyCity2 = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_AshleyCity2");
		DialogData ambient_ashleyCity3 = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_AshleyCity3");
		DialogData ambient_craven = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_Craven");
		DialogData ambient_notThrilled = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_NotThrilled");
		DialogData ambient_shutUp = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_ShutUp");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_TableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_Intro = GetHartmanMovementPoint("M_HartStart");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanMovementPoint move_Board = GetHartmanMovementPoint("M_Board");
		HartmanLookAtPoint look_board = GetHartmanLookAtPoint("L_Board");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		KubrickBase FrontDoor = GetRoomAnimator("MA_FrontDoor");
		UIButtonHaglet button_HolomapTurnOn = GetUIButtonHaglet("P_Holomap");
		button_HolomapTurnOn.gameObject.SetActive(value: false);
		ParticleSystem ShortoutSparks = GetRoomParticle("P_PenthouseSparks_R");
		Transform SparksObject = RR.Inst.transform.Find("ParticleSystems").Find("P_PenthouseSparks_R");
		SparksObject.gameObject.SetActive(value: false);
		yield return null;
		Hartman_SetMood(Hartman.Mood.Default);
		yield return CreateTimeCondition(3f);
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_door knock");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_craven);
		SFXPlay("event:/sfx/script/act 1/a1o1/open penthouse door");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("Intro");
		yield return Wait.ForSteps(1uL);
		Hartman_TeleportToPoint(move_Intro);
		yield return CreateTimeCondition(1.5f);
		FrontDoor.Play("Open");
		yield return CreateTimeCondition(0.2f);
		HAGIS.DialogShow(ambient_ashleyCity);
		yield return CreateTimeCondition(4.6f);
		Hartman_PlayAnimation("defaultIdle");
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_ashleyCity2);
		yield return Hartman_PlayAnimation("ConcernedIdleAlt");
		Hartman_SetMood(Hartman.Mood.Happy);
		yield return Hartman_PlayAnimation("TransCIdleToHIdle");
		yield return Hartman_PlayAnimation("HappyTalk");
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Concerned);
		yield return Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(1.5f);
		yield return Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransCIdleToDIdle");
		yield return CreateTimeCondition(0.8f);
		HAGIS.DialogShow(ambient_ashleyCity3);
		Hartman_PlayAnimation("TransDIdleToFixTable");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(6f);
		Hartman_PlayAnimation("TransFixTableToDIdle");
		yield return CreateTimeCondition(0.9f);
		SFXPlay("event:/sfx/script/act 1/a1o1/hollow map table broken");
		yield return CreateTimeCondition(0.2f);
		Hartman_MoveToPoint(move_tableFront, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(1.3f);
		ShortoutSparks.Play();
		SparksObject.gameObject.SetActive(value: true);
		Hartman_SetMood(Hartman.Mood.Sad);
		yield return Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(1.5f);
		HAGIS.DialogShow(ambient_shutUp);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransSIdleToDIdle");
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("DefaultBashTable");
		yield return CreateTimeCondition(1.5f);
		ShortoutSparks.Play();
		SFXPlay("event:/sfx/script/act 1/a1o1/hollow map table power up");
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_Intro, 2f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_LookAtPoint(look_player, 1f);
		yield return CreateTimeCondition(2.2f);
		HAGIS.DialogShow(ambient_notThrilled);
		Hartman_MoveToPoint(move_tableRight, 2.5f, lookAtPlayerOnComplete: false, animateMovement: false);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 1f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransCIdleToHIdle");
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("TransHIdleToDIdle");
		yield return CreateTimeCondition(1f);
		button_HolomapTurnOn.gameObject.SetActive(value: true);
		Hartman_PlayAnimation("DefaultTalk");
		yield return button_HolomapTurnOn.OnTapUp;
	}
}
public class HAGIS_Hartman_SwaginTest : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		GetHartmanMovementPoint("M_Window");
		GetHartmanMovementPoint("M_TableFront");
		GetHartmanMovementPoint("M_TableLeft");
		GetHartmanMovementPoint("M_TableRight");
		GetHartmanMovementPoint("M_SideRoom");
		GetHartmanMovementPoint("M_Butterflies");
		GetHartmanLookAtPoint("L_Player");
		GetHartmanLookAtPoint("L_Safe");
		GetHartmanLookAtPoint("L_FrontDoor");
		GetHartmanLookAtPoint("L_Window");
		GetHartmanLookAtPoint("L_Butterflies");
		yield break;
	}
}
public class ItemModel : MonoBehaviour
{
	public void OnSpawn(Transform parent)
	{
		base.transform.SetParent(parent, worldPositionStays: false);
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		base.transform.localScale = Vector3.one;
	}
}
public static class ItemImpl
{
	[Serializer.Exclude]
	private static Dictionary<string, Type> LUT_ItemImplNameToType = new Dictionary<string, Type>();

	[Serializer.Exclude]
	private static Dictionary<Item, ItemStackMeta> LUT_ItemEnumToMeta = new Dictionary<Item, ItemStackMeta>();

	public static void Initialise()
	{
		if (LUT_ItemImplNameToType.Count > 0)
		{
			UnityEngine.Debug.LogWarning("ItemImpl LUT already initalised!");
			return;
		}
		for (int i = 0; i < 10; i++)
		{
			ItemImplNames itemImplNames = (ItemImplNames)i;
			string text = itemImplNames.ToString();
			Type type = Type.GetType(text);
			LUT_ItemImplNameToType.Add(text, type);
		}
		ItemStackMeta[] array = AEResources.LoadAllResources<ItemStackMeta>("Items");
		ItemStackMeta[] array2 = array;
		foreach (ItemStackMeta itemStackMeta in array2)
		{
			if (!LUT_ItemEnumToMeta.ContainsKey(itemStackMeta.ItemEnum))
			{
				LUT_ItemEnumToMeta.Add(itemStackMeta.ItemEnum, itemStackMeta);
			}
		}
	}

	private static Type GetItemImplType(ItemImplNames value)
	{
		string key = value.ToString();
		Type value2 = null;
		if (LUT_ItemImplNameToType.TryGetValue(key, out value2))
		{
			return value2;
		}
		return null;
	}

	public static Type ToItemImplType(this ItemImplNames value)
	{
		return GetItemImplType(value);
	}

	public static ItemStackImplBase Instantiate(ItemImplNames value)
	{
		Type type = value.ToItemImplType();
		return (ItemStackImplBase)Activator.CreateInstance(type);
	}

	public static ItemStackMeta GetItemMeta(Item item)
	{
		if (LUT_ItemEnumToMeta.ContainsKey(item))
		{
			return LUT_ItemEnumToMeta[item];
		}
		return null;
	}

	public static ItemStackMeta ToMeta(this Item item)
	{
		return GetItemMeta(item);
	}
}
public enum ItemImplNames
{
	Item_None,
	Item_Recoil_Buffer,
	Item_Iron_Sights,
	Item_Rubber_Grip,
	Item_Muzzle_Break,
	Item_Aperture_Sights,
	Item_Ergonomic_Grip,
	Item_Gyroscopic_Stabilizer,
	Item_Laser_Sights,
	Item_Combat_Stock,
	MAX
}
[Serializable]
internal class Item_None : ItemStackImplBase
{
}
[Serializable]
internal class Item_Recoil_Buffer : ItemStackImplBase
{
	public override int GetDamageModifer()
	{
		return 1;
	}
}
[Serializable]
internal class Item_Iron_Sights : ItemStackImplBase
{
	public override int GetAccuracyModifer()
	{
		return 5;
	}
}
[Serializable]
internal class Item_Rubber_Grip : ItemStackImplBase
{
	public override int GetCriticalChanceModifer()
	{
		return 5;
	}
}
[Serializable]
internal class Item_Muzzle_Break : ItemStackImplBase
{
	public override int GetDamageModifer()
	{
		return 2;
	}
}
[Serializable]
internal class Item_Aperture_Sights : ItemStackImplBase
{
	public override int GetAccuracyModifer()
	{
		return 10;
	}
}
[Serializable]
internal class Item_Ergonomic_Grip : ItemStackImplBase
{
	public override int GetCriticalChanceModifer()
	{
		return 10;
	}
}
[Serializable]
internal class Item_Gyroscopic_Stabilizer : ItemStackImplBase
{
	public override int GetDamageModifer()
	{
		return 3;
	}
}
[Serializable]
internal class Item_Laser_Sights : ItemStackImplBase
{
	public override int GetAccuracyModifer()
	{
		return 15;
	}
}
[Serializable]
internal class Item_Combat_Stock : ItemStackImplBase
{
	public override int GetCriticalChanceModifer()
	{
		return 15;
	}
}
public enum ItemType
{
	CONSUMABLE,
	SPECIAL,
	JUNK,
	ESSENTIAL,
	WEAPON_UPGRADE,
	MAX
}
public enum ItemUsage
{
	InventoryMenu = 1,
	CharacterScreen
}
[Serializable]
[CreateAssetMenu]
public class ItemStackMeta : AEScriptableResource
{
	[SerializeField]
	[ReadOnly]
	private string _Name;

	[SerializeField]
	[HideInInspector]
	private string _NameImpl;

	public string displayName;

	public string shortDisplayName;

	public int price = 10;

	public string descriptionShort = "Missing short description";

	[TextArea(5, 10)]
	public string descriptionLong = "The long description is missing!";

	[SerializeField]
	[ReadOnly]
	private Sprite icon;

	public ItemModel model;

	public ItemType category;

	[SerializeField]
	[ReadOnly]
	private Item itemEnum;

	[EnumFlagsField]
	public ItemUsage usage = (ItemUsage)3;

	public ItemImplNames itemImplName;

	public string pickupFmodEventPath;

	private static readonly uint[] LUT_StorageLimit = new uint[5] { 20u, 1000u, 1000u, 10u, 6u };

	public string Name => _Name;

	private new string name => base.name;

	public string NameImpl => _NameImpl;

	public Sprite Icon => icon;

	public Item ItemEnum => itemEnum;

	public uint StorageLimit => LUT_StorageLimit[(int)category];
}
[Serializable]
public class ItemStackInstance
{
	[Serializer.Exclude]
	private HagletTrigger onAcquired = new HagletTrigger();

	public int count;

	public bool hasEverBeenPickedUp;

	public ItemStackMeta meta { get; private set; }

	public ItemStackImplBase impl { get; private set; }

	public HagletTrigger OnAcquired => onAcquired;

	public ItemStackInstance(ItemStackMeta meta, ItemStackImplBase impl)
	{
		this.meta = meta;
		this.impl = impl;
	}

	public ItemStackInstance()
	{
	}

	public ItemStackInstance(ItemStackInstance other)
	{
		meta = other.meta;
		impl = other.impl;
		count = other.count;
		hasEverBeenPickedUp = other.hasEverBeenPickedUp;
	}
}
[Serializable]
public abstract class ItemStackImplBase
{
	public virtual int GetDamageModifer()
	{
		return 0;
	}

	public virtual int GetAccuracyModifer()
	{
		return 0;
	}

	public virtual int GetCriticalChanceModifer()
	{
		return 0;
	}
}
[Serializable]
[CreateAssetMenu]
public class StoreDatabase : AEScriptableResource
{
	[Serializable]
	public struct ItemStock
	{
		public ItemStackMeta itemMeta;

		public float costModifier;

		public int stock;

		public ItemStock(ItemStackMeta itemMeta, float costModifier, int stock)
		{
			this.itemMeta = itemMeta;
			this.costModifier = costModifier;
			this.stock = stock;
		}
	}

	public string shopName = "Cool Store For Cool Guys";

	[NonSceneAsset]
	public DialogData preShowDialog;

	[NonSceneAsset]
	public DialogData postShowDialog;

	[NonSceneAsset]
	public Sprite vendorIcon;

	public float shopRate = 1f;

	public ItemStock[] sellOrder;

	public ItemStock[] buyOrder;

	public uint GetStoreSellPrice(ItemStackMeta item)
	{
		return (uint)item.price;
	}

	public uint GetStoreBuyPrice(ItemStackMeta item)
	{
		return (uint)item.price;
	}
}
public class StoreFront : TileActionBase
{
	public class StoreRoutine : HagletResettable
	{
		public StoreRoutine(StoreFront store)
			: base(store.storeRoutine(), store.database.shopName + " Store Routine")
		{
		}

		protected StoreRoutine(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private const float kDefaultBuyOrderModifier = 0.3f;

	[NonSceneAsset]
	public StoreDatabase database;

	public OptionalDirection direction;

	[SerializeField]
	[HideInInspector]
	private StoreDatabase.ItemStock[] sellOrderCached;

	[SerializeField]
	[HideInInspector]
	private StoreInstance dataAndItemStacks;

	private StoreRoutine storeRoutineCache;

	public override OctDir? actionDir
	{
		get
		{
			if (direction == OptionalDirection.None)
			{
				return null;
			}
			return (OctDir)direction;
		}
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		sellOrderCached = database.sellOrder;
		storeRoutineCache = new StoreRoutine(this);
	}

	public override void OnMissionStart()
	{
		base.OnMissionStart();
		if (!SaveData.mission.storeStocks.TryGetValue(base.idGenerated, out dataAndItemStacks))
		{
			StoreInstance value = new StoreInstance(database);
			SaveData.mission.storeStocks[base.idGenerated] = value;
			dataAndItemStacks = value;
		}
	}

	protected override HagletYieldTerm PerformAction()
	{
		return Routine.Start(storeRoutineCache, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> storeRoutine()
	{
		Singleton<UIC>.Inst.Push<UIEmpty>();
		yield return Singleton<UIC>.Inst.pushPopComplete;
		if (database.preShowDialog != null)
		{
			yield return HAGIS.DialogShow(database.preShowDialog);
		}
		yield return Singleton<UIC>.Inst.Push<UIStoreFront>().SetState(dataAndItemStacks);
		if (database.postShowDialog != null)
		{
			yield return HAGIS.DialogShow(database.postShowDialog);
		}
		yield return Singleton<UIC>.Inst.Pop();
	}

	public bool BuyItemFromVendor(ItemStackMeta itemMeta)
	{
		int vendorPrice = GetVendorPrice(itemMeta);
		if (Party.Inst.currency < vendorPrice)
		{
			return false;
		}
		if (Party.Inst.GetItemCount(itemMeta) == itemMeta.StorageLimit)
		{
			return false;
		}
		Party.Inst.currency -= (uint)vendorPrice;
		Party.Inst.AddItemToInventory(itemMeta, 1);
		DecrementItemStock(itemMeta, 1);
		return true;
	}

	public bool SellItemToVendor(ItemStackMeta itemMeta)
	{
		int playerPrice = GetPlayerPrice(itemMeta);
		Party.Inst.currency += (uint)playerPrice;
		Party.Inst.RemoveItemFromInventory(itemMeta, 1);
		return true;
	}

	private StoreDatabase.ItemStock? GetItemFromSellOrder(ItemStackMeta itemMeta)
	{
		for (int i = 0; i < sellOrderCached.Length; i++)
		{
			if (sellOrderCached[i].itemMeta == itemMeta)
			{
				return sellOrderCached[i];
			}
		}
		return null;
	}

	private StoreDatabase.ItemStock GetItemFromBuyOrder(ItemStackMeta itemMeta)
	{
		for (int i = 0; i < database.buyOrder.Length; i++)
		{
			if (database.buyOrder[i].itemMeta == itemMeta)
			{
				return database.buyOrder[i];
			}
		}
		return new StoreDatabase.ItemStock(itemMeta, 0.3f, -1);
	}

	private void DecrementItemStock(ItemStackMeta itemMeta, int value)
	{
		for (int i = 0; i < sellOrderCached.Length; i++)
		{
			if (sellOrderCached[i].itemMeta == itemMeta)
			{
				if (sellOrderCached[i].stock != -1)
				{
					sellOrderCached[i].stock -= Mathf.Min(value, sellOrderCached[i].stock);
				}
				break;
			}
		}
	}

	public int GetVendorStockCount(ItemStackMeta itemMeta)
	{
		StoreDatabase.ItemStock? itemFromSellOrder = GetItemFromSellOrder(itemMeta);
		if (!itemFromSellOrder.HasValue)
		{
			return -1;
		}
		return itemFromSellOrder.Value.stock;
	}

	public int GetVendorPrice(ItemStackMeta itemMeta)
	{
		StoreDatabase.ItemStock? itemFromSellOrder = GetItemFromSellOrder(itemMeta);
		if (!itemFromSellOrder.HasValue || itemFromSellOrder.Value.stock == 0)
		{
			return -1;
		}
		StoreDatabase.ItemStock value = itemFromSellOrder.Value;
		return (int)((float)value.itemMeta.price * value.costModifier * database.shopRate);
	}

	public int GetPlayerPrice(ItemStackMeta itemMeta)
	{
		StoreDatabase.ItemStock itemFromBuyOrder = GetItemFromBuyOrder(itemMeta);
		return (int)((float)itemFromBuyOrder.itemMeta.price * itemFromBuyOrder.costModifier);
	}
}
[Flags]
public enum CoverType
{
	None = 1,
	Half = 2,
	Full = 4,
	Flanked = 8,
	Obscured = 0x10
}
public enum CoverUIType
{
	None,
	Half,
	Full,
	MAX
}
public static class Extensions
{
	public static bool Is(this CoverType type, CoverType other)
	{
		return (type & other) == other;
	}

	public static CoverUIType GetCoverUIType(this CoverType type)
	{
		if (type.Is(CoverType.Full))
		{
			return CoverUIType.Full;
		}
		if (type.Is(CoverType.Half))
		{
			return CoverUIType.Half;
		}
		return CoverUIType.None;
	}

	public static uint ToMask(this UnitTeam.Type teamType)
	{
		return (uint)(1 << (int)teamType);
	}

	public static bool Is(this Unit.Movement.Result result, Unit.Movement.Result check1, Unit.Movement.Result check2 = Unit.Movement.Result.None, Unit.Movement.Result check3 = Unit.Movement.Result.None)
	{
		return (result & (check1 | check2 | check3)) != 0;
	}

	public static bool ResultedIn(this Unit.Movement.Result result, Unit.Movement.Result check1, Unit.Movement.Result check2 = Unit.Movement.Result.None, Unit.Movement.Result check3 = Unit.Movement.Result.None)
	{
		return result.Is(check1, check2, check3);
	}

	public static bool Failed(this Unit.Movement.Result result)
	{
		return result.Is(Unit.Movement.Result.Invalid);
	}

	public static bool IsFailure(this Unit.Movement.Result result)
	{
		return result.Is(Unit.Movement.Result.Invalid);
	}

	public static bool Succeeded(this Unit.Movement.Result result)
	{
		return result.Is(Unit.Movement.Result.Arrived);
	}

	public static bool IsSuccess(this Unit.Movement.Result result)
	{
		return result.Is(Unit.Movement.Result.Arrived);
	}

	public static bool Is(this Unit.SwapMap.Result result, Unit.SwapMap.Result check1, Unit.SwapMap.Result check2 = Unit.SwapMap.Result.None, Unit.SwapMap.Result check3 = Unit.SwapMap.Result.None)
	{
		return (result & (check1 | check2 | check3)) != 0;
	}

	public static bool ResultedIn(this Unit.SwapMap.Result result, Unit.SwapMap.Result check1, Unit.SwapMap.Result check2 = Unit.SwapMap.Result.None, Unit.SwapMap.Result check3 = Unit.SwapMap.Result.None)
	{
		return result.Is(check1, check2, check3);
	}

	public static bool Failed(this Unit.SwapMap.Result result)
	{
		return result.Is(Unit.SwapMap.Result.Invalid);
	}

	public static bool IsFailure(this Unit.SwapMap.Result result)
	{
		return result.Is(Unit.SwapMap.Result.Invalid);
	}

	public static bool Succeeded(this Unit.SwapMap.Result result)
	{
		return !result.Failed();
	}
}
[Serializable]
public struct AttackData
{
	public int hitChance;

	public v2i attackFromCoord;

	public CoverType coverType;
}
[Serializable]
public class TileData
{
	public List<TileActionBase> tileActions = new List<TileActionBase>();

	public float surfaceSFXValue;
}
[ExecuteInEditMode]
[RequireComponent(typeof(BloomPrepass))]
public class Map : RootBase
{
	[Serializable]
	public struct TileCollision
	{
		public byte center;

		public uint observerCount;

		public float elevation;
	}

	[Serializable]
	public struct TileHit
	{
		public uint tile;

		public v2i coord;
	}

	private static readonly uint[] LUT_BFSDirection = new uint[8] { 0u, 2u, 4u, 6u, 1u, 3u, 5u, 7u };

	private readonly Queue<v2i> bfsQueue = new Queue<v2i>();

	private readonly HashSet<v2i> bfsVisited = new HashSet<v2i>();

	[HideInInspector]
	[Serializer.Exclude]
	public v2i size;

	[HideInInspector]
	public v2i offset;

	public static readonly v2i maxMapSize = new v2i(32, 32);

	[NonSerialized]
	[HideInInspector]
	private TileActionSwapMap[] mapSwapTiles;

	public ConstArray<TileTrapTrigger> trapTiles = new ConstArray<TileTrapTrigger>(32u);

	[NonSerialized]
	[HideInInspector]
	public Map[] mapLinks;

	[HideInInspector]
	public const float tableAngle = -14f;

	private bool particlesPlaying;

	[HideInInspector]
	[Serializer.Exclude]
	private ParticleSystem[] mapParticles;

	public string ambTonePath = string.Empty;

	[Header("Map SFX Values")]
	public FloorSurface defaultSurface = FloorSurface.Concrete;

	public float defaultReverb;

	public string fmodSnapshot;

	[Header("Map Sun Values")]
	public Color unitSunColor = Color.white;

	public Color unitShadowColor = Color.white;

	public Color unitColorRim = Color.white;

	[Header("Debug")]
	public bool debugShowNavigation;

	[Header("Debug")]
	public bool debugShowTiles;

	public bool useWindShader;

	public bool useFogShader;

	public bool useIncorporealShader;

	public bool useForceFieldShader;

	public bool useDodgeShader;

	public bool useEmpShader;

	public bool useRainingShader = true;

	public bool useMapReflections = true;

	[HideInInspector]
	[SerializeField]
	public Bounds preCalcMapBounds;

	public Vector2 hologramFrameOffsetX = default(Vector2);

	public Vector2 hologramFrameOffsetY = default(Vector2);

	public Vector2 hologramFrameOffsetZ = default(Vector2);

	private Bounds hologramFrameBounds = default(Bounds);

	[NonSerialized]
	[HideInInspector]
	public static readonly Type[] behaviourCuller = new Type[11]
	{
		typeof(KubrickAnimator),
		typeof(LookAtPlayerYRotation),
		typeof(LookAtPlayer),
		typeof(Animation),
		typeof(ExplosiveBarrel),
		typeof(SurveillanceCamera),
		typeof(Light),
		typeof(ScrollingWalls),
		typeof(TileActionBase),
		typeof(TileTrigger),
		typeof(SFXAmbTarget)
	};

	[Serializer.Exclude]
	private BehaviourCache behaviourCache = new BehaviourCache();

	[Serializer.Exclude]
	private Vector3 originalPosition;

	private HAGIS[] hagisScripts;

	private Dictionary<string, KubrickAnimator> dynamicAnimators = new Dictionary<string, KubrickAnimator>();

	[NonSerialized]
	public HagletTrigger _OnShowComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnHideComplete = new HagletTrigger();

	[HideInInspector]
	private Color hologramColor = new Color(0.23529412f, 48f / 85f, 0.9490196f, 1f);

	private readonly string[] hologramAtlasNames = new string[9] { "MapDiffuse", "Water", "Neon", "Decals", "Whitebox", "Alpha", "Glass", "VFXTiles", "Ocean" };

	[HideInInspector]
	[Serializer.Exclude]
	public ConstArray<Material> hologramMaterials = new ConstArray<Material>(32u);

	private int holoShaderColorID;

	private int holoShaderMapXFormID;

	private int holoShaderL2WMapXFormID;

	private int holoShaderCursorPosRadiID;

	private int holoShaderFrameOffsetID;

	private int holoShaderFrameExtents_ScaleID;

	private int holoShaderCursorFadeTime;

	private int holoShaderEmpIntensity;

	private int holoShaderEmpCutoff;

	private int holoShaderEmpActive;

	private int holoShaderEmpRandBounds;

	[Serializer.Exclude]
	private BloomPrepass fogPrepass;

	[Serializer.Exclude]
	private AnimFloatHaglet cursorPulseDriver;

	private Vector3 cursorPosition;

	private FMOD.Studio.EventInstance reverbSnapshotHandle;

	public const byte kTileCollisionHeightNone = 0;

	public const byte kTileCollisionHeightFlat = 1;

	public const byte kTileCollisionHeightHalf = 2;

	public const byte kTileCollisionHeightFull = 3;

	public const byte kTileCollisionHeightMask = 3;

	public const byte kTileCollisionIsLarge = 4;

	public const byte kTileCollisionEdgeU = 0;

	public const byte kTileCollisionEdgeR = 1;

	public const byte kTileCollisionEdgeD = 2;

	public const byte kTileCollisionEdgeL = 3;

	[HideInInspector]
	public uint[] tileInfo;

	[HideInInspector]
	[Serializer.Exclude]
	public TileCollision[] tileCollision;

	[HideInInspector]
	[Serializer.Exclude]
	public TileData[] tileData;

	[HideInInspector]
	[Serializer.Exclude]
	public TileActionBase[] tileActions;

	[HideInInspector]
	[Serializer.Exclude]
	public TileObjectEvents[] tileObjectsWithUnitEvents;

	[HideInInspector]
	[Serializer.Exclude]
	public SFXAmbTarget[] ambTargets;

	private SitAnchor[] sitAnchors;

	[HideInInspector]
	public ConstArray<v2i> reservedCoords = new ConstArray<v2i>(16u);

	[HideInInspector]
	[Serializer.Exclude]
	public UnitSpawnWaves[] unitWaveSpawnPoints;

	private TileActionGiveLoot[] deathLootTiles;

	public const uint kTileNavU = 1u;

	public const uint kTileNavUR = 2u;

	public const uint kTileNavR = 4u;

	public const uint kTileNavDR = 8u;

	public const uint kTileNavD = 16u;

	public const uint kTileNavDL = 32u;

	public const uint kTileNavL = 64u;

	public const uint kTileNavUL = 128u;

	public const uint kTileNavMask = 255u;

	public const int kTileNavVaultOffset = 8;

	public const uint kTileNavVaultU = 256u;

	public const uint kTileNavVaultUR = 512u;

	public const uint kTileNavVaultR = 1024u;

	public const uint kTileNavVaultDR = 2048u;

	public const uint kTileNavVaultD = 4096u;

	public const uint kTileNavVaultDL = 8192u;

	public const uint kTileNavVaultL = 16384u;

	public const uint kTileNavVaultUL = 32768u;

	public const uint kTileNavVaultMask = 65280u;

	public const uint kTileNavBlock = 65536u;

	public const uint kTileError = 2147483648u;

	private static readonly uint[] tileNavOctDirLUT = new uint[8] { 1u, 2u, 4u, 8u, 16u, 32u, 64u, 128u };

	[HideInInspector]
	public const float scale = 0.08f;

	public const float scaleInv = 12.5f;

	private AnimFloatHaglet EmpHagletFloat;

	private int _activateEMP;

	private Vector4 _EMPBounds;

	private HagletResettable empRand;

	private static readonly Vector3[] LUT_edgeOffset = new Vector3[4]
	{
		new Vector3(0f, 0f, 0.475f),
		new Vector3(0.475f, 0f, 0f),
		new Vector3(0f, 0f, -0.475f),
		new Vector3(-0.475f, 0f, 0f)
	};

	private static readonly Vector3[] LUT_edgeSize = new Vector3[4]
	{
		new Vector3(1f, 0f, 0.05f),
		new Vector3(0.05f, 0f, 1f),
		new Vector3(1f, 0f, 0.05f),
		new Vector3(0.05f, 0f, 1f)
	};

	[ReadOnly]
	[Serializer.Exclude]
	public LogicRoot logicRoot;

	public float ambTargetAdjustmentParameter;

	private static readonly Vector2 raymarchExtent = Vector2.one * 0.35f;

	public TileDefaultUnitPosition[] DefaultUnitPositions { get; private set; }

	public HagletTrigger OnMapVisible { get; private set; }

	public Color HologamColor
	{
		get
		{
			return hologramColor;
		}
		set
		{
			hologramColor = value;
			for (uint num = 0u; num < hologramMaterials.Length; num++)
			{
				hologramMaterials[num].SetColor(holoShaderColorID, hologramColor);
			}
		}
	}

	[HideInInspector]
	[Serializer.Exclude]
	public VFXTileController VFXTiles => Singleton<MC>.Inst.VFXTiles;

	public bool IsShown { get; private set; }

	public uint WaveIndex { get; private set; }

	public uint WaveCount { get; private set; }

	public bool WaveCombatAllowed { get; private set; }

	public bool IsActive => this == Singleton<MC>.Inst.GetActiveMap();

	public bool IsUnitsVisible { get; set; }

	public ArtSceneMeta SceneMetaArt => (ArtSceneMeta)base.SceneMeta;

	[Serializer.Exclude]
	public LogicSceneMeta SceneMetaLogic { get; private set; }

	public v2i WorldPosToCoord(Vector3 position)
	{
		return LocalPosToCoord(WorldPosToLocalPos(position));
	}

	public Vector3 WorldPosToLocalPos(Vector3 pos)
	{
		return base.transform.InverseTransformPoint(pos);
	}

	public v2i LocalPosToCoord(Vector3 pos)
	{
		return new v2i(Mathf.FloorToInt(pos.x) + offset.x, Mathf.FloorToInt(pos.z) + offset.y);
	}

	public Vector3 LocalPosToCoordSpace(Vector3 pos)
	{
		return new Vector3(pos.x + (float)offset.x, 0f, pos.z + (float)offset.y);
	}

	public Vector3 CoordToWorldPos(v2i coord)
	{
		return LocalPosToWorldPos(CoordToLocalPos(coord));
	}

	public Vector3 CoordToLocalPos(v2i coord)
	{
		return new Vector3((float)(coord.x - offset.x) + 0.5f, 0f, (float)(coord.y - offset.y) + 0.5f);
	}

	public Vector3 LocalPosToWorldPos(Vector3 pos)
	{
		return base.transform.TransformPoint(pos);
	}

	public Vector3 LocalVecToWorldVec(Vector3 vec)
	{
		return base.transform.TransformVector(vec);
	}

	public float LocalSizeToWorldSize(float size)
	{
		return base.transform.lossyScale.x * size;
	}

	[Conditional("UNITY_EDITOR")]
	public void DEBUG_DrawX(v2i coord, float size, Color color, float duration = 0f, bool depthTest = true)
	{
	}

	public int CoordToDataIndex(int x, int y)
	{
		return x + y * size.x;
	}

	public int CoordToDataIndex(v2i coord)
	{
		return coord.x + coord.y * size.x;
	}

	public bool CoordExists(v2i coord)
	{
		if (coord.x < 0)
		{
			return false;
		}
		if (coord.y < 0)
		{
			return false;
		}
		if (coord.x >= size.x)
		{
			return false;
		}
		if (coord.y >= size.y)
		{
			return false;
		}
		return true;
	}

	public bool GetCoordBlocked(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return true;
		}
		return (GetTileInfo(coord) & 0x10000) != 0;
	}

	public bool GetCoordDirectionBlocked(v2i coord, uint directionIndex)
	{
		uint num = (uint)(1 << (int)directionIndex);
		uint tileDirectionField = GetTileDirectionField(coord);
		return (tileDirectionField & num) == 0;
	}

	public bool IsReachableNeighbour(v2i start, v2i end)
	{
		return v2i.IsNeighbour(start, end) && !GetCoordBlocked(end) && !GetCoordDirectionBlocked(start, NC.DirectionToIndex(end - start));
	}

	public void SetTileInfo(v2i coord, uint tile)
	{
		if (CoordExists(coord))
		{
			tileInfo[CoordToDataIndex(coord)] = tile;
		}
	}

	public void SetTileInfoBitClear(v2i coord, uint bits)
	{
		SetTileInfo(coord, GetTileInfo(coord) & ~bits);
	}

	public void SetTileInfoBitSet(v2i coord, uint bits)
	{
		SetTileInfo(coord, GetTileInfo(coord) | bits);
	}

	public uint GetTileInfo(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return 0u;
		}
		return tileInfo[CoordToDataIndex(coord)];
	}

	public TileActionBase GetTileAction(v2i coord)
	{
		for (int i = 0; i < tileActions.Length; i++)
		{
			if (tileActions[i].GetCoord() == coord && (tileActions[i].availableIn & GC.Inst.GetState()) != 0)
			{
				return tileActions[i];
			}
		}
		return null;
	}

	public TileTrapTrigger GetTrap(v2i coord, UnitTeam.Type teamType)
	{
		for (int i = 0; i < trapTiles.Length; i++)
		{
			if (trapTiles[i].GetCoord() == coord && trapTiles[i].teamType == teamType)
			{
				return trapTiles[i];
			}
		}
		return null;
	}

	public TileCollision GetTileCollision(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return default(TileCollision);
		}
		return tileCollision[CoordToDataIndex(coord)];
	}

	public void SetTileCollision(v2i coord, byte tileCenter)
	{
		if (CoordExists(coord))
		{
			tileCollision[CoordToDataIndex(coord)].center = tileCenter;
		}
	}

	public void SetTileElevation(v2i coord, float elevation)
	{
		if (CoordExists(coord))
		{
			tileCollision[CoordToDataIndex(coord)].elevation = elevation;
		}
	}

	public float GetTileElevation(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return 0f;
		}
		return tileCollision[CoordToDataIndex(coord)].elevation;
	}

	public float GetTileElevationInterpolated(Vector3 localPositionInMap)
	{
		localPositionInMap -= new Vector3(0.5f, 0f, 0.5f);
		v2i v2i2 = LocalPosToCoord(localPositionInMap);
		float tileElevation = GetTileElevation(v2i2);
		float tileElevation2 = GetTileElevation(v2i2 + v2i.right);
		float tileElevation3 = GetTileElevation(v2i2 + v2i.up);
		float tileElevation4 = GetTileElevation(v2i2 + v2i.one);
		Vector3 vector = LocalPosToCoordSpace(localPositionInMap) - new Vector3(v2i2.x, 0f, v2i2.y);
		float a = Mathf.LerpUnclamped(tileElevation, tileElevation2, vector.x);
		float b = Mathf.LerpUnclamped(tileElevation3, tileElevation4, vector.x);
		return Mathf.LerpUnclamped(a, b, vector.z);
	}

	public void SetCoverHeight(v2i coord, TileObjectBase.Height height, bool isLarge)
	{
		if (CoordExists(coord))
		{
			byte b = 1;
			switch (height)
			{
			case TileObjectBase.Height.Half:
				b = 2;
				break;
			case TileObjectBase.Height.Full:
				b = 3;
				break;
			}
			if (isLarge)
			{
				b = (byte)(b | 4u);
			}
			SetTileCollision(coord, b);
		}
	}

	public TileObjectBase.Height GetCoverHeight(v2i coord)
	{
		return (GetTileCollision(coord).center & 3) switch
		{
			3 => TileObjectBase.Height.Full, 
			2 => TileObjectBase.Height.Half, 
			_ => TileObjectBase.Height.Zero, 
		};
	}

	public uint GetTileObserverCount(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return 0u;
		}
		return tileCollision[CoordToDataIndex(coord)].observerCount;
	}

	public void SetTileObserverCount(v2i coord, uint observerCount)
	{
		if (CoordExists(coord))
		{
			tileCollision[CoordToDataIndex(coord)].observerCount = observerCount;
		}
	}

	public TileData GetTileData(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return new TileData();
		}
		return tileData[CoordToDataIndex(coord)];
	}

	public TileData GetTileData(int index)
	{
		if (index < 0 || index >= tileInfo.Length)
		{
			return new TileData();
		}
		return tileData[index];
	}

	public int GetTileCount()
	{
		return tileInfo.Length;
	}

	public byte GetTileDirectionField(v2i coord)
	{
		return GetDirectionFieldFromTileInfo(tileInfo[CoordToDataIndex(coord)]);
	}

	public SitAnchor TryGetAdjacentSitAnchor(v2i coord)
	{
		Vector3 vector = CoordToLocalPos(coord);
		SitAnchor result = null;
		float num = float.MaxValue;
		for (int i = 0; i < sitAnchors.Length; i++)
		{
			float sqrMagnitude = (sitAnchors[i].transform.localPosition - vector).sqrMagnitude;
			if (sqrMagnitude < 1.5f && sqrMagnitude < num)
			{
				num = sqrMagnitude;
				result = sitAnchors[i];
			}
		}
		return result;
	}

	public bool ReserveAccessToCoord(v2i coord, bool overridePriorReservation = false)
	{
		if (!IsCoordReserved(coord) || overridePriorReservation)
		{
			reservedCoords.Add(coord);
			return true;
		}
		return false;
	}

	public bool IsCoordReserved(v2i coord)
	{
		return reservedCoords.Contains(coord);
	}

	public void UnreserveAccessToCoord(v2i coord)
	{
		reservedCoords.Remove(coord);
	}

	public static byte GetDirectionFieldFromTileInfo(uint tileInfo)
	{
		return (byte)(tileInfo & 0xFFu);
	}

	public static byte GetDirectionVaultFieldFromTileInfo(uint tileInfo)
	{
		return (byte)((tileInfo & 0xFF00) >> 8);
	}

	public TileActionSwapMap GetSwapTileAtIndex(uint index)
	{
		return mapSwapTiles[index];
	}

	public v2i GetSwapTileCoordAtIndex(uint index)
	{
		return WorldPosToCoord(mapSwapTiles[index].transform.position);
	}

	public TileActionSwapMap GetSwapMapTileLinkToTargetMap(Map targetMap, bool willPanicOnFailure = true)
	{
		for (int i = 0; i < mapSwapTiles.Length; i++)
		{
			TileActionSwapMap tileActionSwapMap = mapSwapTiles[i];
			Map targetLinkedMap = tileActionSwapMap.targetLinkedMap;
			if (targetLinkedMap == targetMap)
			{
				return tileActionSwapMap;
			}
		}
		if (willPanicOnFailure)
		{
		}
		return null;
	}

	public bool Raycast(Vector3 origin, Vector3 direction, out TileHit hit, out Unit hitUnit)
	{
		TileActionBase hitTAB;
		return Raycast(origin, direction, out hit, out hitUnit, out hitTAB, 1024);
	}

	public bool Raycast(Vector3 origin, Vector3 direction, out TileHit hit, out Unit hitUnit, out TileActionBase hitTAB, GC.State currentState)
	{
		int num = 1024;
		num |= Layer.GetStateMask(currentState);
		return Raycast(origin, direction, out hit, out hitUnit, out hitTAB, num);
	}

	private bool Raycast(Vector3 origin, Vector3 direction, out TileHit hit, out Unit hitUnit, out TileActionBase hitTAB, int layerMask)
	{
		hit = default(TileHit);
		hitUnit = null;
		hitTAB = null;
		if (Physics.Raycast(origin, direction, out var hitInfo, float.PositiveInfinity, layerMask))
		{
			bool result = false;
			if (((uint)layerMask & 0x400u) != 0)
			{
				hitUnit = hitInfo.collider.GetComponent<Unit>();
				if (hitUnit != null)
				{
					result = true;
					hit.coord = hitUnit.coord;
					hit.tile = GetTileInfo(hit.coord);
				}
			}
			if (((uint)layerMask & 0x7000u) != 0)
			{
				hitTAB = hitInfo.collider.GetComponentInParent<TileActionBase>();
				if (hitTAB != null)
				{
					result = true;
					hit.coord = hitTAB.GetCoord();
					hitUnit = null;
					return true;
				}
			}
			return result;
		}
		if (new Plane(base.transform.up, base.transform.position).Raycast(new Ray(origin, direction), out var enter))
		{
			Vector3 position = origin + direction * enter;
			v2i coord = WorldPosToCoord(position);
			if (CoordExists(coord))
			{
				hit.coord = coord;
				hit.tile = GetTileInfo(coord);
				hitTAB = GetTileAction(hit.coord);
				if (hitTAB != null && !hitTAB.isActiveAndEnabled)
				{
					hitTAB = null;
				}
				hitUnit = GC.Inst.GetUnitAtCoord(hit.coord, includeDead: true);
				return true;
			}
		}
		return false;
	}

	public void RenderFogPrepass()
	{
		BloomPrepass[] componentsInChildren = GetComponentsInChildren<BloomPrepass>();
		for (uint num = 0u; num < componentsInChildren.Length; num++)
		{
			componentsInChildren[num].RenderPrepass();
		}
	}

	public AttackData GetAttackData(v2i attackCoord, v2i targetCoord)
	{
		AttackData result = default(AttackData);
		result.coverType = GetCoverBetween(attackCoord, targetCoord);
		result.attackFromCoord = attackCoord;
		if (result.coverType.Is(CoverType.Obscured) && GetAdjacentCoverDirection(attackCoord, out var _))
		{
			Vector2 vector = CoordToLocalPos(attackCoord).xz();
			Vector2 vector2 = CoordToLocalPos(targetCoord).xz();
			Vector2 normalized = (vector2 - vector).normalized;
			v2i v2i2 = LocalPosToCoord((vector + normalized).xNy());
			bool flag;
			if (CoordIsCover(v2i2, includeHalfCover: true))
			{
				flag = true;
			}
			else
			{
				int num = (int)NC.DirectionToIndex(v2i2 - attackCoord);
				int index = (num - 1).Wrap(8);
				int index2 = (num + 1).Wrap(8);
				v2i coord = attackCoord + NC.IndexToDirection((uint)index);
				v2i coord2 = attackCoord + NC.IndexToDirection((uint)index2);
				flag = CoordIsCover(coord, includeHalfCover: true) || CoordIsCover(coord2, includeHalfCover: true);
			}
			if (flag)
			{
				Vector2 vector3 = new Vector2(normalized.y, 0f - normalized.x);
				v2i v2i3 = LocalPosToCoord((vector - vector3).xNy());
				v2i v2i4 = LocalPosToCoord((vector + vector3).xNy());
				uint directionIndex = NC.DirectionToIndex(attackCoord, v2i3);
				uint directionIndex2 = NC.DirectionToIndex(attackCoord, v2i4);
				bool coordDirectionBlocked = GetCoordDirectionBlocked(attackCoord, directionIndex);
				bool coordDirectionBlocked2 = GetCoordDirectionBlocked(attackCoord, directionIndex2);
				CoverType coverType = ((!coordDirectionBlocked) ? GetCoverBetween(v2i3, targetCoord) : CoverType.Obscured);
				CoverType coverType2 = ((!coordDirectionBlocked2) ? GetCoverBetween(v2i4, targetCoord) : CoverType.Obscured);
				if (coverType.Is(CoverType.Obscured))
				{
					result.coverType = coverType2;
					result.attackFromCoord = v2i4;
				}
				else if (coverType2.Is(CoverType.Obscured))
				{
					result.coverType = coverType;
					result.attackFromCoord = v2i3;
				}
				else if (coverType.Is(CoverType.Half))
				{
					result.coverType = coverType2;
					result.attackFromCoord = v2i4;
				}
				else
				{
					result.coverType = coverType;
					result.attackFromCoord = v2i3;
				}
			}
		}
		if (result.coverType.Is(CoverType.Obscured))
		{
			result.attackFromCoord = attackCoord;
		}
		result.hitChance = (result.coverType.Is(CoverType.Half) ? (-20) : 0);
		return result;
	}

	public bool HasLineOfSight(v2i attackCoord, v2i targetCoord, bool isSideStepAllowed)
	{
		if (isSideStepAllowed)
		{
			return GetAttackData(attackCoord, targetCoord).coverType != CoverType.Obscured;
		}
		return !Raymarch(attackCoord, targetCoord).HasValue;
	}

	public TileObjectBase.Height GetGreatestNeighbourHeight(v2i coord)
	{
		if (GetCoordBlocked(coord))
		{
			return TileObjectBase.Height.Zero;
		}
		TileObjectBase.Height greatest = TileObjectBase.Height.Zero;
		if (CompareHeight(coord + new v2i(0, 1), ref greatest) && CompareHeight(coord + new v2i(1, 1), ref greatest) && CompareHeight(coord + new v2i(1, 0), ref greatest) && CompareHeight(coord + new v2i(1, -1), ref greatest) && CompareHeight(coord + new v2i(0, -1), ref greatest) && CompareHeight(coord + new v2i(-1, -1), ref greatest) && CompareHeight(coord + new v2i(-1, 0), ref greatest))
		{
			CompareHeight(coord + new v2i(-1, 1), ref greatest);
		}
		return greatest;
	}

	private bool CompareHeight(v2i coord, ref TileObjectBase.Height greatest)
	{
		if (coord.x < 0)
		{
			return true;
		}
		if (coord.x >= size.x)
		{
			return true;
		}
		if (coord.y < 0)
		{
			return true;
		}
		if (coord.y >= size.y)
		{
			return true;
		}
		switch (GetTileCollision(coord).center & 3)
		{
		case 3:
			greatest = TileObjectBase.Height.Full;
			return false;
		case 2:
			greatest = TileObjectBase.Height.Half;
			break;
		}
		return true;
	}

	public CoverType GetCoverBetween(v2i attackCoord, v2i targetCoord)
	{
		if (Raymarch(attackCoord, targetCoord).HasValue)
		{
			return CoverType.Obscured;
		}
		v2i? v2i2;
		v2i? v2i3 = (v2i2 = Raymarch(targetCoord, attackCoord, blockedByHalfCover: true));
		if (v2i3.HasValue && v2i.IsNeighbour(v2i2.Value, targetCoord))
		{
			return CoverType.Half;
		}
		if (GetAdjacentCoverDirection(targetCoord, out var _, includeDiagonals: true))
		{
			return CoverType.Flanked;
		}
		return CoverType.None;
	}

	public CoverType GetGreatestNeighbourHeightAsCoverType(v2i coord)
	{
		int result;
		switch (GetGreatestNeighbourHeight(coord))
		{
		case TileObjectBase.Height.Zero:
			return CoverType.None;
		case TileObjectBase.Height.Full:
			result = 4;
			break;
		default:
			result = 2;
			break;
		}
		return (CoverType)result;
	}

	public CoverType GetCoverBetweenAllEnemies(v2i coord, Unit unit)
	{
		CoverType coverType = GetGreatestNeighbourHeightAsCoverType(coord);
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		UnitTeam.Type teamType = unit.GetTeamType();
		int num = (int)unitsActive.Length;
		while (--num >= 0)
		{
			Unit unit2 = unitsActive[num];
			if (!unit2.IsActiveOnMap() || unit2.GetTeamType() == teamType || unit2.GetTeamType() == UnitTeam.Type.NPC || !GetCoverBetween(unit2.coord, coord).Is(CoverType.Flanked))
			{
				continue;
			}
			coverType |= CoverType.Flanked;
			break;
		}
		return coverType;
	}

	public v2i GetNearestFreeCoord(v2i coord)
	{
		bfsQueue.Clear();
		bfsVisited.Clear();
		bfsVisited.Add(coord);
		bfsQueue.Enqueue(coord);
		while (bfsQueue.Count > 0)
		{
			v2i v2i2 = bfsQueue.Dequeue();
			if (v2i2 != coord && !GetCoordBlocked(v2i2) && GC.Inst.GetUnitAtCoord(v2i2) == null)
			{
				return v2i2;
			}
			for (int i = 0; i < LUT_BFSDirection.Length; i++)
			{
				v2i item = v2i2 + NC.IndexToDirection(LUT_BFSDirection[i]);
				if (bfsVisited.Add(item))
				{
					bfsQueue.Enqueue(item);
				}
			}
		}
		return coord;
	}

	public bool GetAdjacentFreeCoord(v2i coord, out OctDir dir, bool includeDiagonals = false)
	{
		dir = OctDir.Up;
		v2i coord2 = coord + new v2i(0, 1);
		if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
		{
			dir = OctDir.Up;
			return true;
		}
		coord2 = coord + new v2i(1, 0);
		if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
		{
			dir = OctDir.Right;
			return true;
		}
		coord2 = coord + new v2i(0, -1);
		if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
		{
			dir = OctDir.Down;
			return true;
		}
		coord2 = coord + new v2i(-1, 0);
		if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
		{
			dir = OctDir.Left;
			return true;
		}
		if (includeDiagonals)
		{
			coord2 = coord + new v2i(1, 1);
			if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
			{
				dir = OctDir.UpRight;
				return true;
			}
			coord2 = coord + new v2i(-1, 1);
			if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
			{
				dir = OctDir.UpLeft;
				return true;
			}
			coord2 = coord + new v2i(1, -1);
			if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
			{
				dir = OctDir.DownRight;
				return true;
			}
			coord2 = coord + new v2i(-1, -1);
			if (!GetCoordBlocked(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null)
			{
				dir = OctDir.DownLeft;
				return true;
			}
		}
		return false;
	}

	public bool GetAdjacentCoverDirection(v2i coord, out OctDir dir, bool includeDiagonals = false, CoverType? specificCoverType = null)
	{
		dir = OctDir.Up;
		if (GetCoordBlocked(coord))
		{
			return false;
		}
		int num = 2;
		if (specificCoverType.HasValue)
		{
			if (!specificCoverType.HasValue)
			{
				goto IL_0065;
			}
			switch (specificCoverType.Value)
			{
			case CoverType.None:
				break;
			case CoverType.Half:
				goto IL_0057;
			case CoverType.Full:
				goto IL_005e;
			default:
				goto IL_0065;
			}
			num = 0;
		}
		else
		{
			num = 3;
		}
		goto IL_006e;
		IL_0057:
		num = 2;
		goto IL_006e;
		IL_006e:
		if ((GetTileCollision(coord + new v2i(0, 1)).center & num) != 0)
		{
			dir = OctDir.Up;
			return true;
		}
		if ((GetTileCollision(coord + new v2i(1, 0)).center & num) != 0)
		{
			dir = OctDir.Right;
			return true;
		}
		if ((GetTileCollision(coord + new v2i(0, -1)).center & num) != 0)
		{
			dir = OctDir.Down;
			return true;
		}
		if ((GetTileCollision(coord + new v2i(-1, 0)).center & num) != 0)
		{
			dir = OctDir.Left;
			return true;
		}
		return false;
		IL_005e:
		num = 3;
		goto IL_006e;
		IL_0065:
		return false;
	}

	public ConstArray<Material> GetAllMapMaterials()
	{
		return hologramMaterials;
	}

	private Material PrepareMaterial(Material matSrc)
	{
		if (useRainingShader)
		{
			matSrc.EnableKeyword("WATER_ON");
		}
		if (useWindShader)
		{
			matSrc.EnableKeyword("WIND_ON");
		}
		if (useFogShader)
		{
			matSrc.EnableKeyword("FOG_ON");
		}
		if (useIncorporealShader)
		{
			matSrc.EnableKeyword("INCORPOREAL_ON");
		}
		if (useForceFieldShader)
		{
			matSrc.EnableKeyword("FORCEFIELD_ON");
		}
		if (useDodgeShader)
		{
			matSrc.EnableKeyword("DODGE_ON");
		}
		if (useEmpShader)
		{
			matSrc.EnableKeyword("EMP_ON");
		}
		else
		{
			matSrc.DisableKeyword("EMP_ON");
		}
		if (useMapReflections)
		{
			matSrc.EnableKeyword("SPECULAR_ON");
		}
		else
		{
			matSrc.DisableKeyword("SPECULAR_ON");
		}
		return matSrc;
	}

	public void OnMissionSceneLoaded()
	{
		OnMapVisible = new HagletTrigger();
		LogicRoot componentInChildren = GetComponentInChildren<LogicRoot>();
		SceneMetaLogic = componentInChildren.SceneMetaLogic;
		logicRoot = componentInChildren;
		originalPosition = base.transform.position;
		KubrickAnimator[] componentsInChildren = GetComponentsInChildren<KubrickAnimator>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!dynamicAnimators.ContainsKey(componentsInChildren[i].name))
			{
				dynamicAnimators.Add(componentsInChildren[i].name, componentsInChildren[i]);
			}
		}
		for (int j = 0; j < hologramAtlasNames.Length; j++)
		{
			JK3DAtlasMaterial[] materialsForAtlasContaining = jk3d.GetMaterialsForAtlasContaining(hologramAtlasNames[j]);
			foreach (JK3DAtlasMaterial jK3DAtlasMaterial in materialsForAtlasContaining)
			{
				hologramMaterials.Add(PrepareMaterial(jK3DAtlasMaterial.staticMat));
				hologramMaterials.Add(PrepareMaterial(jK3DAtlasMaterial.dynamicMat));
			}
		}
		Material material = new Material(Shader.Find("AE/UnitModel"));
		hologramMaterials.Add(PrepareMaterial(material));
		HashSet<SkinnedMeshRenderer> hashSet = new HashSet<SkinnedMeshRenderer>();
		KubrickAnimator[] array = componentsInChildren;
		foreach (KubrickAnimator kubrickAnimator in array)
		{
			SkinnedMeshRenderer componentInChildren2 = kubrickAnimator.GetComponentInChildren<SkinnedMeshRenderer>(includeInactive: true);
			if (componentInChildren2 != null && componentInChildren2.name != "Ref_SM_Character_Hartman" && componentInChildren2.name != "SM_Character_WillaHigh_body" && componentInChildren2.name != "SM_Character_WillaHigh_head" && hashSet.Add(componentInChildren2))
			{
				componentInChildren2.sharedMaterial = material;
				UnitModel.MergeAndAtlasAttachments(componentInChildren2);
			}
		}
		behaviourCache.Build(base.gameObject, behaviourCuller);
		behaviourCache.CullParentType<Unit>();
		Singleton<MC>.Inst.ClearVFXControllerParent();
		behaviourCache.SetEnabled(enabled: false, affectColliders: false);
		ambTargets = GetComponentsInChildren<SFXAmbTarget>(includeInactive: true);
		Transform transform = componentInChildren.transform.FindChild("DeathLoot");
		if (transform != null)
		{
			deathLootTiles = transform.GetComponentsInChildren<TileActionGiveLoot>();
			for (int m = 0; m < deathLootTiles.Length; m++)
			{
				deathLootTiles[m].gameObject.SetActive(value: false);
			}
		}
		else
		{
			deathLootTiles = new TileActionGiveLoot[0];
		}
		sitAnchors = GetComponentsInChildren<SitAnchor>();
		ambTargets = GetComponentsInChildren<SFXAmbTarget>();
		tileActions = GetComponentsInChildren<TileActionBase>(includeInactive: true);
		CalculateTileData();
		for (int n = 0; n < tileActions.Length; n++)
		{
			TileActionBase tileActionBase = tileActions[n];
			v2i coord = WorldPosToCoord(tileActionBase.transform.position);
			if (CoordExists(coord))
			{
				int num = CoordToDataIndex(coord);
				tileData[num].tileActions.Add(tileActionBase);
			}
		}
		tileObjectsWithUnitEvents = GetComponentsInChildren<TileObjectEvents>(includeInactive: true);
		unitWaveSpawnPoints = GetComponentsInChildren<UnitSpawnWaves>();
		for (int num2 = 0; num2 < unitWaveSpawnPoints.Length; num2++)
		{
			WaveCount = (uint)Mathf.Max((int)WaveCount, unitWaveSpawnPoints[num2].wavesCharacterData.Length);
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		Material[] allParticleMaterials = PSC.Inst.GetAllParticleMaterials();
		Material[] array2 = allParticleMaterials;
		foreach (Material item in array2)
		{
			hashSet2.Add(item);
		}
		mapParticles = GetComponentsInChildren<ParticleSystem>();
		ParticleSystem[] array3 = mapParticles;
		foreach (ParticleSystem particleSystem in array3)
		{
			Renderer[] componentsInChildren2 = particleSystem.GetComponentsInChildren<Renderer>();
			Renderer[] array4 = componentsInChildren2;
			foreach (Renderer renderer in array4)
			{
				VFXTileController.SetSortingOrder(renderer);
				if (renderer.sharedMaterial != null)
				{
					hashSet2.Add(renderer.sharedMaterial);
				}
			}
		}
		foreach (Material item2 in hashSet2)
		{
			hologramMaterials.Add(item2);
		}
		mapSwapTiles = GetComponentsInChildren<TileActionSwapMap>();
		DefaultUnitPositions = GetComponentsInChildren<TileDefaultUnitPosition>();
		Array.Sort(mapSwapTiles, (TileActionSwapMap lhs, TileActionSwapMap rhs) => lhs.myIndex.CompareTo(rhs.myIndex));
		HoloFrameUpdateBounds();
		fogPrepass = GetComponent<BloomPrepass>();
		hagisScripts = GetComponentsInChildren<HAGIS>();
		holoShaderColorID = Shader.PropertyToID("_ColorHolo");
		holoShaderMapXFormID = Shader.PropertyToID("_MapWorldToLocal");
		holoShaderL2WMapXFormID = Shader.PropertyToID("_MapLocalToWorld");
		holoShaderFrameOffsetID = Shader.PropertyToID("_HoloFrameOffset");
		holoShaderFrameExtents_ScaleID = Shader.PropertyToID("_HoloFrameExtents_Scale");
		holoShaderCursorPosRadiID = Shader.PropertyToID("_CursorOriginAndRadius");
		holoShaderCursorFadeTime = Shader.PropertyToID("_CursorFadeTime");
		holoShaderEmpIntensity = Shader.PropertyToID("_EmpIntensity");
		holoShaderEmpCutoff = Shader.PropertyToID("_TexEmpCutoff");
		Texture2D noiseAndCutoffEMP = AEResources.LoadFirstResource<Texture2D>("DodgeTextures/TX_NoiseAndCutoff");
		holoShaderEmpActive = Shader.PropertyToID("_EmpActive");
		holoShaderEmpRandBounds = Shader.PropertyToID("_EmpRandPos");
		cursorPulseDriver = new AnimFloatHaglet("MapScan", LR.Host, delegate
		{
			for (int num17 = 0; num17 < hologramMaterials.Length; num17++)
			{
				hologramMaterials[num17].EnableKeyword("PULSE_ON");
				hologramMaterials[num17].SetFloat(holoShaderCursorFadeTime, cursorPulseDriver.Target);
			}
		}, delegate(float x)
		{
			for (int num16 = 0; num16 < hologramMaterials.Length; num16++)
			{
				hologramMaterials[num16].SetVector(holoShaderCursorPosRadiID, new Vector4(cursorPosition.x, cursorPosition.y, cursorPosition.z, x));
			}
		}, delegate
		{
			for (int num15 = 0; num15 < hologramMaterials.Length; num15++)
			{
				hologramMaterials[num15].DisableKeyword("PULSE_ON");
			}
		});
		empRand = new HagletResettable(EmpRand(), "EMP_Random_Vec4", HagletStepTime.Update, -1, 5);
		EmpHagletFloat = new AnimFloatHaglet("EMP", LR.Host, delegate
		{
			for (int num12 = 0; num12 < hologramMaterials.Length; num12++)
			{
				hologramMaterials[num12].SetTexture(holoShaderEmpCutoff, noiseAndCutoffEMP);
				hologramMaterials[num12].EnableKeyword("EMP_ON");
				hologramMaterials[num12].SetVector(holoShaderEmpRandBounds, new Vector4(0f, 0f, 0f, 0f));
			}
			ConstArray<Unit> unitsAllInWorld3 = GC.Inst.GetUnitsAllInWorld();
			for (int num13 = 0; num13 < unitsAllInWorld3.Length; num13++)
			{
				Material[] unitMaterials3 = unitsAllInWorld3[num13].unitModel.UnitMaterials;
				for (int num14 = 0; num14 < unitMaterials3.Length; num14++)
				{
					unitMaterials3[num14].SetTexture(holoShaderEmpCutoff, noiseAndCutoffEMP);
					unitMaterials3[num14].EnableKeyword("EMP_ON");
					unitMaterials3[num14].SetVector(holoShaderEmpRandBounds, new Vector4(0f, 0f, 0f, 0f));
				}
			}
		}, delegate(float x)
		{
			for (int num9 = 0; num9 < hologramMaterials.Length; num9++)
			{
				hologramMaterials[num9].SetVector(holoShaderEmpIntensity, new Vector4(x, _activateEMP, 0f, 0f));
				hologramMaterials[num9].SetVector(holoShaderEmpRandBounds, _EMPBounds);
			}
			ConstArray<Unit> unitsAllInWorld2 = GC.Inst.GetUnitsAllInWorld();
			for (int num10 = 0; num10 < unitsAllInWorld2.Length; num10++)
			{
				Material[] unitMaterials2 = unitsAllInWorld2[num10].unitModel.UnitMaterials;
				for (int num11 = 0; num11 < unitMaterials2.Length; num11++)
				{
					unitMaterials2[num11].SetVector(holoShaderEmpIntensity, new Vector4(x, _activateEMP, 0f, 0f));
					unitMaterials2[num11].SetVector(holoShaderEmpRandBounds, _EMPBounds);
				}
			}
		}, delegate
		{
			if (_activateEMP == 0)
			{
				for (int num6 = 0; num6 < hologramMaterials.Length; num6++)
				{
					hologramMaterials[num6].DisableKeyword("EMP_ON");
				}
				ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
				for (int num7 = 0; num7 < unitsAllInWorld.Length; num7++)
				{
					Material[] unitMaterials = unitsAllInWorld[num7].unitModel.UnitMaterials;
					for (int num8 = 0; num8 < unitMaterials.Length; num8++)
					{
						unitMaterials[num8].DisableKeyword("EMP_ON");
					}
				}
			}
			else
			{
				MR.Inst.Host.StartTopLevel(empRand, null, prestep: true);
			}
		});
	}

	public TileActionGiveLoot TryGetOnDeathLootTrigger(Item item)
	{
		for (int i = 0; i < deathLootTiles.Length; i++)
		{
			if (!deathLootTiles[i].gameObject.activeSelf && deathLootTiles[i].item.ItemEnum == item)
			{
				return deathLootTiles[i];
			}
		}
		return null;
	}

	private void CalculateTileData()
	{
		tileData = new TileData[size.x * size.y];
		for (int i = 0; i < tileData.Length; i++)
		{
			tileData[i] = new TileData();
			tileData[i].surfaceSFXValue = TileSurfaceType.SurfaceToParam(defaultSurface);
		}
		TileSurfaceType[] componentsInChildren = GetComponentsInChildren<TileSurfaceType>();
		TileSurfaceType[] array = componentsInChildren;
		foreach (TileSurfaceType tileSurfaceType in array)
		{
			v2i v2i2 = WorldPosToCoord(tileSurfaceType.transform.position);
			for (int k = v2i2.x - tileSurfaceType.size.x; k < v2i2.x + tileSurfaceType.size.x; k++)
			{
				for (int l = v2i2.y - tileSurfaceType.size.y; l < v2i2.y + tileSurfaceType.size.y; l++)
				{
					v2i coord = new v2i(k, l);
					if (CoordExists(coord))
					{
						GetTileData(coord).surfaceSFXValue = tileSurfaceType.GetSurfaceParam();
					}
				}
			}
		}
	}

	public TileDefaultUnitPosition GetClosestDefaultUnitPositions(v2i coord)
	{
		Vector3 vector = CoordToWorldPos(coord);
		TileDefaultUnitPosition result = null;
		float num = float.MaxValue;
		for (int i = 0; i < DefaultUnitPositions.Length; i++)
		{
			TileDefaultUnitPosition tileDefaultUnitPosition = DefaultUnitPositions[i];
			float sqrMagnitude = (vector - tileDefaultUnitPosition.transform.position).sqrMagnitude;
			v2i coord2 = WorldPosToCoord(tileDefaultUnitPosition.transform.position);
			if (!IsCoordReserved(coord2) && GC.Inst.GetUnitAtCoord(coord2) == null && tileDefaultUnitPosition.isActiveAndEnabled && sqrMagnitude < num)
			{
				result = tileDefaultUnitPosition;
				num = sqrMagnitude;
			}
		}
		return result;
	}

	public void PrepareMapSwapTiles(Dictionary<LogicSceneMeta, uint> dictMapMetaToIndex)
	{
		TileActionSwapMap[] array = mapSwapTiles;
		foreach (TileActionSwapMap tileActionSwapMap in array)
		{
			tileActionSwapMap.targetLinkedMap = Singleton<MC>.Inst.GetMapWithIndex(dictMapMetaToIndex[tileActionSwapMap.targetMap]);
		}
	}

	public void PlaceTrap(GadgetType gadgetType, TileTrapTrigger trap, v2i coord, bool visable)
	{
		trap.SetMap(this);
		trap.transform.SetParent(base.transform, worldPositionStays: false);
		trap.transform.position = CoordToWorldPos(coord);
		trap.transform.localScale = new Vector3(1f, 1f, 1f);
		trap.transform.localRotation = default(Quaternion);
		trap.gameObject.SetActive(value: true);
		trap.SetVisability(visable);
		trap.TrapType = gadgetType;
		trapTiles.Add(trap);
	}

	public void RemoveTrap(TileTrapTrigger trap)
	{
		trapTiles.Remove(trap);
		trap.gameObject.SetActive(value: false);
		trap.transform.SetParent(trap.ParentWhenInactive);
	}

	public void CleanupAllTraps()
	{
		int num = trapTiles.sLength;
		while (--num >= 0)
		{
			trapTiles[num].gameObject.SetActive(value: false);
			trapTiles[num].transform.SetParent(trapTiles[num].ParentWhenInactive);
		}
		trapTiles.Clear();
	}

	public KubrickAnimator TryGetDynamicAnimator(string animatorName)
	{
		KubrickAnimator value = null;
		dynamicAnimators.TryGetValue(animatorName, out value);
		return value;
	}

	public KubrickAnimator GetDynamicAnimator(string animatorName)
	{
		return dynamicAnimators[animatorName];
	}

	public void SetDynamicAnimatorsPaused(bool paused)
	{
		foreach (KeyValuePair<string, KubrickAnimator> dynamicAnimator in dynamicAnimators)
		{
			dynamicAnimator.Value.SetPaused(paused);
		}
	}

	private void EnableHologramShader()
	{
		for (uint num = 0u; num < hologramMaterials.Length; num++)
		{
			Material material = hologramMaterials[num];
			material.EnableKeyword("HOLOGRAM_ON");
			material.SetTexture("_TextureLight", rootLightmap);
			material.SetTexture("_TextureSpec", rootSpecmap);
		}
	}

	private void DisableHologramShader()
	{
		for (uint num = 0u; num < hologramMaterials.Length; num++)
		{
			hologramMaterials[num].DisableKeyword("HOLOGRAM_ON");
		}
	}

	private Bounds GetHoloFrameBounds(float holoFrameWidthScale, float holoFrameHeightOffset)
	{
		Bounds result = hologramFrameBounds;
		result.min += new Vector3(0f - hologramFrameOffsetX.x, 0f - hologramFrameOffsetY.y, 0f - hologramFrameOffsetZ.x);
		result.max -= new Vector3(0f - hologramFrameOffsetX.y, 0f - hologramFrameOffsetY.x, 0f - hologramFrameOffsetZ.y);
		result.extents = result.extents.RepX(result.extents.x * holoFrameWidthScale);
		result.max = result.max.RepY(result.max.y + holoFrameHeightOffset);
		return result;
	}

	private void HoloFrameUpdateBounds()
	{
		Bounds bounds = preCalcMapBounds;
		hologramFrameBounds = bounds;
	}

	public void ShowBegin(float transitionDuration)
	{
		AC.Inst.PlayOneShot2D("event:/sfx/ui/map transition/map transition open");
		reverbSnapshotHandle = AC.Inst.PlaySnapshot(fmodSnapshot);
		if (reverbSnapshotHandle.isValid())
		{
			reverbSnapshotHandle.setParameterValue("reverb", defaultReverb);
		}
		EnableHologramShader();
		ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
		for (int i = 0; i < unitsAllInWorld.Length; i++)
		{
			unitsAllInWorld[i].unitModel.SetSunAndRimColor(unitSunColor, unitShadowColor, unitColorRim);
		}
		logicRoot.AmbFadeIn();
		IsShown = true;
		behaviourCache.SetEnabled(enabled: true, affectColliders: false);
		fogPrepass.Show(transitionDuration);
		ShowParticles();
	}

	public void ShowEnd()
	{
		DisableHologramShader();
		behaviourCache.SetEnabledColliders(enabled: true);
		_OnShowComplete.Trigger();
		Singleton<NPCWanderController>.Inst.ResumeWandering();
	}

	public void HideBegin(float transitionDuration)
	{
		AC.Inst.PlayOneShot2D("event:/sfx/ui/map transition/map transition close");
		AC.Stop(reverbSnapshotHandle);
		EnableHologramShader();
		logicRoot.AmbFadeOut();
		behaviourCache.SetEnabledColliders(enabled: false);
		behaviourCache.SetEnabledBehaviours<SFXAmbTarget>(enabled: false);
		fogPrepass.Hide(transitionDuration);
		Singleton<NPCWanderController>.Inst.PauseWandering();
	}

	public void HideEnd()
	{
		HideImmediate();
	}

	public void HideImmediate()
	{
		DisableHologramShader();
		IsShown = false;
		HideParticles();
		Singleton<MC>.Inst.ClearVFXControllerParent();
		behaviourCache.SetEnabled(enabled: false, affectColliders: true);
		base.transform.position = originalPosition;
		OnHideComplete.Trigger();
	}

	private void UpdateMapHologramMaterial(Material targetMaterial, Matrix4x4 xformMapWorldToLocal, Matrix4x4 xformMapLocalToWorld, float hologramValue, ref Bounds bounds, float holoFrameFadeScale)
	{
		targetMaterial.SetColor(holoShaderColorID, hologramColor);
		targetMaterial.SetMatrix(holoShaderMapXFormID, xformMapWorldToLocal);
		targetMaterial.SetMatrix(holoShaderL2WMapXFormID, xformMapLocalToWorld);
		targetMaterial.SetVector(holoShaderFrameOffsetID, bounds.center.V3ToV4(holoFrameFadeScale));
		targetMaterial.SetVector(holoShaderFrameExtents_ScaleID, bounds.extents.V3ToV4(holoFrameFadeScale));
	}

	public void SetEMPBounds()
	{
		float num = Time.time * 20f;
		float z = Mathf.Sin(num * 2f);
		float w = Mathf.Sin(num * 5f);
		float x = Mathf.Sin(num * 3f);
		float y = Mathf.Sin(num * 7f);
		_EMPBounds = new Vector4(x, y, z, w);
	}

	public void EnableEmpEffect(bool enabled)
	{
		if (_activateEMP == 1 != enabled)
		{
			if (enabled)
			{
				_activateEMP = 1;
				EmpHagletFloat.Start(0f, 1f, 1.2f.SkipOverride(0f), 0f);
			}
			else
			{
				_activateEMP = 0;
				EmpHagletFloat.Start(1f, 0f, 1.2f.SkipOverride(0f), 0.1f.SkipOverride(0f));
			}
		}
	}

	private IEnumerator<HagletYieldTerm> EmpRand()
	{
		bool enabled = true;
		while (enabled)
		{
			enabled = false;
			SetEMPBounds();
			for (int i = 0; i < hologramMaterials.Length; i++)
			{
				hologramMaterials[i].SetVector(holoShaderEmpRandBounds, _EMPBounds);
			}
			ConstArray<Unit> units = GC.Inst.GetUnitsAllInWorld();
			if (units != null)
			{
				for (int j = 0; j < units.Length; j++)
				{
					Material[] unitMaterials = units[j].unitModel.UnitMaterials;
					for (int k = 0; k < unitMaterials.Length; k++)
					{
						unitMaterials[k].SetVector(holoShaderEmpRandBounds, _EMPBounds);
					}
				}
			}
			if (_activateEMP > 0)
			{
				enabled = true;
			}
			yield return Wait.ForSteps(1uL);
		}
	}

	public void UpdateMapHologramMaterials(Matrix4x4 mapPivotMatrix, float hologramValue, float holoFrameWidth, float holoFrameHeight, float holoFrameFadeScale)
	{
		hologramColor.a = hologramValue;
		Matrix4x4 xformMapWorldToLocal = mapPivotMatrix;
		Matrix4x4 inverse = xformMapWorldToLocal.inverse;
		Bounds bounds = GetHoloFrameBounds(holoFrameWidth, holoFrameHeight);
		for (uint num = 0u; num < hologramMaterials.Length; num++)
		{
			UpdateMapHologramMaterial(hologramMaterials[num], xformMapWorldToLocal, inverse, hologramValue, ref bounds, holoFrameFadeScale);
		}
		ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
		for (int i = 0; i < unitsAllInWorld.Length; i++)
		{
			Material[] unitMaterials = unitsAllInWorld[i].unitModel.UnitMaterials;
			for (int j = 0; j < unitMaterials.Length; j++)
			{
				UpdateMapHologramMaterial(unitMaterials[j], xformMapWorldToLocal, inverse, hologramValue, ref bounds, holoFrameFadeScale);
			}
		}
	}

	public void CursorPulse(v2i coord, float radius = 1f, float duration = 0.25f)
	{
		cursorPulseDriver.Start(radius, duration);
		cursorPosition = CoordToLocalPos(coord);
	}

	public void OnTurnModeEnter()
	{
		int num = tileObjectsWithUnitEvents.Length;
		while (--num >= 0)
		{
			tileObjectsWithUnitEvents[num].OnEnterTurnMode();
		}
	}

	public void OnTurnModeExit()
	{
		int num = tileObjectsWithUnitEvents.Length;
		while (--num >= 0)
		{
			tileObjectsWithUnitEvents[num].OnExitTurnMode();
		}
		CleanupAllTraps();
		VFXTiles.AreaHide();
	}

	public void OnChangedGameState()
	{
		int num = tileObjectsWithUnitEvents.Length;
		while (--num >= 0)
		{
			tileObjectsWithUnitEvents[num].OnChangedGameState();
		}
	}

	public void WavesEnableAllWaveSpawns()
	{
		WaveCombatAllowed = true;
		for (int i = 0; i < unitWaveSpawnPoints.Length; i++)
		{
			unitWaveSpawnPoints[i].gameObject.SetActive(value: true);
			unitWaveSpawnPoints[i].enabled = true;
		}
		WavesSpawnWave();
	}

	public void WavesSpawnWave()
	{
		for (int i = 0; i < unitWaveSpawnPoints.Length; i++)
		{
			unitWaveSpawnPoints[i].ActivateUnitWithWaveIndex(WaveIndex);
		}
		WaveIndex++;
	}

	public void AddTileBlock(v2i coord, bool isLarge, TileObjectBase.Height height)
	{
		if (CoordExists(coord))
		{
			uint num = tileInfo[CoordToDataIndex(coord)];
			num &= 0xFFFFFF00u;
			num = (((num & 0x10000) == 0) ? (num | 0x10000u) : (num | 0x80000000u));
			tileInfo[CoordToDataIndex(coord)] = num;
			if (isLarge)
			{
				SetTileInfoBitClear(coord + v2i.left, 14u);
				SetTileInfoBitClear(coord + v2i.right, 224u);
				SetTileInfoBitClear(coord + v2i.up, 56u);
				SetTileInfoBitClear(coord + v2i.down, 131u);
			}
			else
			{
				SetTileInfoBitClear(coord + v2i.left, 4u);
				SetTileInfoBitClear(coord + v2i.right, 64u);
				SetTileInfoBitClear(coord + v2i.up, 16u);
				SetTileInfoBitClear(coord + v2i.down, 1u);
			}
			SetTileInfoBitClear(coord, 21760u);
			SetTileInfoBitClear(coord + v2i.left + v2i.left, 1024u);
			SetTileInfoBitClear(coord + v2i.right + v2i.right, 16384u);
			SetTileInfoBitClear(coord + v2i.up + v2i.up, 4096u);
			SetTileInfoBitClear(coord + v2i.down + v2i.down, 256u);
			SetTileInfoBitClear(coord + v2i.up + v2i.left, 8u);
			SetTileInfoBitClear(coord + v2i.up + v2i.right, 32u);
			SetTileInfoBitClear(coord + v2i.down + v2i.left, 2u);
			SetTileInfoBitClear(coord + v2i.down + v2i.right, 128u);
			SetCoverHeight(coord, height, isLarge);
		}
	}

	public void RemoveTileBlock(v2i coord)
	{
		if (!CoordExists(coord))
		{
			return;
		}
		tileInfo[CoordToDataIndex(coord)] = 255u;
		SetTileCollision(coord, 0);
		ClearVaultData(coord);
		for (int i = 0; i < 8; i++)
		{
			v2i v2i2 = coord + ((OctDir)i).ToV2i();
			if (CoordExists(v2i2))
			{
				int num = CoordToDataIndex(v2i2);
				tileInfo[num] |= tileNavOctDirLUT[(i + 4) % 8];
				if (i % 2 == 0)
				{
					v2i coord2 = v2i2 + ((OctDir)((i + 3) % 8)).ToV2i();
					v2i coord3 = v2i2 + ((OctDir)((i + 5) % 8)).ToV2i();
					if (CoordExists(coord2))
					{
						tileInfo[num] |= tileNavOctDirLUT[(i + 3) % 8];
					}
					if (CoordExists(coord3))
					{
						tileInfo[num] |= tileNavOctDirLUT[(i + 5) % 8];
					}
				}
			}
			else
			{
				SetTileInfoBitClear(coord, tileNavOctDirLUT[i]);
			}
		}
		for (int j = 0; j < 8; j++)
		{
			v2i coord4 = coord + ((OctDir)j).ToV2i();
			if (!CoordExists(coord4) || !GetCoordBlocked(coord4))
			{
				continue;
			}
			bool flag = (GetTileCollision(coord4).center & 4) != 0;
			tileInfo[CoordToDataIndex(coord4)] = 65536u;
			SetTileInfoBitClear(coord, tileNavOctDirLUT[j]);
			v2i coord5 = coord + ((OctDir)((j + 1) % 8)).ToV2i();
			v2i coord6 = coord + ((OctDir)((j + 7) % 8)).ToV2i();
			if (j % 2 == 0)
			{
				SetTileInfoBitClear(coord5, tileNavOctDirLUT[(j + 6) % 8]);
				SetTileInfoBitClear(coord6, tileNavOctDirLUT[(j + 2) % 8]);
				v2i coord7 = coord + ((OctDir)((j + 2) % 8)).ToV2i();
				v2i coord8 = coord + ((OctDir)((j + 6) % 8)).ToV2i();
				SetTileInfoBitClear(coord7, tileNavOctDirLUT[(j + 7) % 8]);
				SetTileInfoBitClear(coord8, tileNavOctDirLUT[(j + 1) % 8]);
				if (flag)
				{
					SetTileInfoBitClear(coord, tileNavOctDirLUT[(j + 1) % 8]);
					SetTileInfoBitClear(coord, tileNavOctDirLUT[(j + 7) % 8]);
					SetTileInfoBitClear(coord5, tileNavOctDirLUT[(j + 5) % 8]);
					SetTileInfoBitClear(coord6, tileNavOctDirLUT[(j + 3) % 8]);
				}
				SetVaultData(coord + ((OctDir)j).ToV2i());
			}
			else
			{
				SetTileInfoBitClear(coord5, tileNavOctDirLUT[(j + 7) % 8]);
				SetTileInfoBitClear(coord6, tileNavOctDirLUT[(j + 1) % 8]);
				if (flag)
				{
					SetTileInfoBitClear(coord5, tileNavOctDirLUT[(j + 6) % 8]);
					SetTileInfoBitClear(coord6, tileNavOctDirLUT[(j + 2) % 8]);
				}
			}
		}
	}

	public void ClearVaultData(v2i coord)
	{
		v2i coord2 = coord + v2i.left;
		v2i coord3 = coord + v2i.right;
		if (!GetCoordBlocked(coord2) && !GetCoordBlocked(coord3))
		{
			SetTileInfoBitClear(coord2, 1024u);
			SetTileInfoBitClear(coord3, 16384u);
		}
		v2i coord4 = coord + v2i.up;
		v2i coord5 = coord + v2i.down;
		if (!GetCoordBlocked(coord4) && !GetCoordBlocked(coord5))
		{
			SetTileInfoBitClear(coord4, 4096u);
			SetTileInfoBitClear(coord5, 256u);
		}
	}

	public void SetVaultData(v2i coord)
	{
		uint num = tileInfo[CoordToDataIndex(coord)];
		if ((GetTileCollision(coord).center & 3) == 2)
		{
			v2i coord2 = coord + v2i.left;
			v2i coord3 = coord + v2i.right;
			if (!GetCoordBlocked(coord2) && !GetCoordBlocked(coord3))
			{
				SetTileInfoBitSet(coord2, 1024u);
				SetTileInfoBitSet(coord3, 16384u);
			}
			v2i coord4 = coord + v2i.up;
			v2i coord5 = coord + v2i.down;
			if (!GetCoordBlocked(coord4) && !GetCoordBlocked(coord5))
			{
				SetTileInfoBitSet(coord4, 4096u);
				SetTileInfoBitSet(coord5, 256u);
			}
		}
	}

	private void DrawNavLine(Vector3 pos, Vector3 dir, byte directionField, uint mask)
	{
		Gizmos.color = Color.green * 0.6f;
		if ((directionField & mask) != 0)
		{
			Gizmos.DrawRay(pos, dir);
		}
	}

	private void DrawVaultLine(Vector3 pos, Vector3 dir, byte directionField, uint mask)
	{
		Gizmos.color = Color.yellow;
		if ((directionField & mask) != 0)
		{
			int num = 20;
			for (int i = 0; i < num; i++)
			{
				float t = (float)i / (float)num;
				float t2 = (float)(i + 1) / (float)num;
				t = Mathf.SmoothStep(0f, 1f, t);
				t2 = Mathf.SmoothStep(0f, 1f, t2);
				float num2 = Mathf.Sqrt(1f - Mathf.Pow(2f * t - 1f, 2f));
				float num3 = Mathf.Sqrt(1f - Mathf.Pow(2f * t2 - 1f, 2f));
				Vector3 vector = new Vector3(dir.x * t * 2f, num2 * 1.5f, dir.z * t * 2f);
				Gizmos.DrawLine(to: pos + new Vector3(dir.x * t2 * 2f, num3 * 1.5f, dir.z * t2 * 2f), from: pos + vector);
			}
		}
	}

	private void OnDrawGizmos()
	{
		if ((bool)Camera.current && Vector3.Distance(Camera.current.transform.position, base.transform.position) > 30f)
		{
			return;
		}
		Gizmos.color = Color.white;
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.DrawWireCube(Vector3.zero, new Vector3(20f, 0f, 10f));
		Bounds holoFrameBounds = GetHoloFrameBounds(1f, 1f);
		Gizmos.DrawWireCube(holoFrameBounds.center, holoFrameBounds.extents * 2f);
		for (int i = 0; i < size.x; i++)
		{
			for (int j = 0; j < size.y; j++)
			{
				v2i coord = new v2i(i, j);
				Vector3 vector = CoordToLocalPos(coord) + Vector3.up * 0.001f;
				uint num = tileInfo[CoordToDataIndex(coord)];
				if (debugShowTiles)
				{
					float num2 = (((i + j) % 2 != 0) ? 1f : 0.85f);
					TileCollision tileCollision = GetTileCollision(coord);
					if ((tileCollision.center & 3u) != 0)
					{
						if ((tileCollision.center & 3) == 1)
						{
							Gizmos.color = new Color(0.4f, 0.1f, 0.8f, 0.3f) * num2;
						}
						else if ((tileCollision.center & 3) == 2)
						{
							Gizmos.color = new Color(0.4f, 0.5f, 0.8f, 0.3f) * num2;
						}
						else if ((tileCollision.center & 3) == 3)
						{
							Gizmos.color = new Color(0.4f, 0.9f, 0.9f, 0.3f) * num2;
						}
					}
					else
					{
						Gizmos.color = new Color(0.8f, 0.8f, 1f, 0.3f) * num2;
					}
					if ((tileCollision.center & 3) != 2)
					{
						Color color = Gizmos.color;
						Gizmos.color = new Color(color.r, color.g, 1f, color.a);
					}
					if ((num & 0x80000000u) != 0)
					{
						Gizmos.color = new Color(1f, 0f, 0f, 0.3f) * num2;
					}
					Gizmos.DrawCube(vector, new Vector3(1f, 0f, 1f));
					Gizmos.color = new Color(0f, 0.4f, 0f, 1f);
				}
				if (debugShowNavigation)
				{
					byte directionFieldFromTileInfo = GetDirectionFieldFromTileInfo(num);
					byte directionVaultFieldFromTileInfo = GetDirectionVaultFieldFromTileInfo(num);
					DrawNavLine(vector, Vector3.forward * 0.5f, directionFieldFromTileInfo, 1u);
					DrawNavLine(vector, Vector3.back * 0.5f, directionFieldFromTileInfo, 16u);
					DrawNavLine(vector, Vector3.right * 0.5f, directionFieldFromTileInfo, 4u);
					DrawNavLine(vector, Vector3.left * 0.5f, directionFieldFromTileInfo, 64u);
					DrawNavLine(vector, (Vector3.forward + Vector3.left) * 0.5f, directionFieldFromTileInfo, 128u);
					DrawNavLine(vector, (Vector3.forward + Vector3.right) * 0.5f, directionFieldFromTileInfo, 2u);
					DrawNavLine(vector, (Vector3.back + Vector3.left) * 0.5f, directionFieldFromTileInfo, 32u);
					DrawNavLine(vector, (Vector3.back + Vector3.right) * 0.5f, directionFieldFromTileInfo, 8u);
					DrawVaultLine(vector, Vector3.right, directionVaultFieldFromTileInfo, 4u);
					DrawVaultLine(vector, Vector3.forward, directionVaultFieldFromTileInfo, 1u);
				}
			}
		}
	}

	public bool CoordIsCover(v2i coord, bool includeHalfCover)
	{
		return TileCollisionIsCover(GetTileCollision(coord).center, includeHalfCover);
	}

	private bool TileCollisionIsCover(byte tcCenter, bool includeHalfCover)
	{
		int num = tcCenter & 3;
		if (num == 1 || num == 0)
		{
			return false;
		}
		if (!includeHalfCover && num == 2)
		{
			return false;
		}
		return true;
	}

	public bool Raymarch_HitTest(int x, int y, Vector2 start, Vector2 end, bool blockedByHalfCover)
	{
		TileCollision tileCollision = this.tileCollision[x + y * size.x];
		if (!TileCollisionIsCover(tileCollision.center, blockedByHalfCover))
		{
			return false;
		}
		if ((tileCollision.center & 4u) != 0)
		{
			return true;
		}
		Vector2 vector = new Vector2((float)(x - offset.x) + 0.5f, (float)(y - offset.y) + 0.5f);
		return MathfX.IntersectSegmentRectangle(start, end, vector - raymarchExtent, vector + raymarchExtent);
	}

	public v2i? Raymarch(v2i srcCoord, v2i targCoord, bool blockedByHalfCover = false)
	{
		Vector2 start = CoordToLocalPos(srcCoord).xz();
		Vector2 end = CoordToLocalPos(targCoord).xz();
		if (!CoordExists(targCoord) || !CoordExists(srcCoord))
		{
			return srcCoord;
		}
		int x = srcCoord.x;
		int x2 = targCoord.x;
		int y = srcCoord.y;
		int y2 = targCoord.y;
		int num = y;
		int num2 = x;
		int num3 = x2 - x;
		int num4 = y2 - y;
		if (Raymarch_HitTest(x, y, start, end, blockedByHalfCover))
		{
			return new v2i(x, y);
		}
		int num5;
		if (num4 < 0)
		{
			num5 = -1;
			num4 = -num4;
		}
		else
		{
			num5 = 1;
		}
		int num6;
		if (num3 < 0)
		{
			num6 = -1;
			num3 = -num3;
		}
		else
		{
			num6 = 1;
		}
		int num7 = 2 * num4;
		int num8 = 2 * num3;
		if (num8 >= num7)
		{
			int num9;
			int num10 = (num9 = num3);
			for (int i = 0; i < num3; i++)
			{
				num2 += num6;
				num9 += num7;
				if (num9 > num8)
				{
					num += num5;
					num9 -= num8;
					if (num9 + num10 < num8)
					{
						if (Raymarch_HitTest(num2, num - num5, start, end, blockedByHalfCover))
						{
							return new v2i(num2, num - num5);
						}
					}
					else if (num9 + num10 > num8 && Raymarch_HitTest(num2 - num6, num, start, end, blockedByHalfCover))
					{
						return new v2i(num2 - num6, num);
					}
				}
				if (Raymarch_HitTest(num2, num, start, end, blockedByHalfCover))
				{
					return new v2i(num2, num);
				}
				num10 = num9;
			}
		}
		else
		{
			int num9;
			int num10 = (num9 = num4);
			for (int j = 0; j < num4; j++)
			{
				num += num5;
				num9 += num8;
				if (num9 > num7)
				{
					num2 += num6;
					num9 -= num7;
					if (num9 + num10 < num7)
					{
						if (Raymarch_HitTest(num2 - num6, num, start, end, blockedByHalfCover))
						{
							return new v2i(num2 - num6, num);
						}
					}
					else if (num9 + num10 > num7 && Raymarch_HitTest(num2, num - num5, start, end, blockedByHalfCover))
					{
						return new v2i(num2, num - num5);
					}
				}
				if (Raymarch_HitTest(num2, num, start, end, blockedByHalfCover))
				{
					return new v2i(num2, num);
				}
				num10 = num9;
			}
		}
		return null;
	}

	public void SetParticlesPaused(bool pause)
	{
		if (!particlesPlaying)
		{
			return;
		}
		ParticleSystem[] array = mapParticles;
		foreach (ParticleSystem particleSystem in array)
		{
			if (pause)
			{
				particleSystem.Pause();
			}
			else
			{
				particleSystem.Play();
			}
		}
	}

	public void ShowParticles()
	{
		if (!particlesPlaying)
		{
			ParticleSystem[] array = mapParticles;
			foreach (ParticleSystem particleSystem in array)
			{
				particleSystem.Play();
			}
			particlesPlaying = true;
		}
	}

	public void HideParticles()
	{
		if (particlesPlaying)
		{
			ParticleSystem[] array = mapParticles;
			foreach (ParticleSystem particleSystem in array)
			{
				particleSystem.Stop();
				particleSystem.Clear();
			}
			particlesPlaying = false;
		}
	}

	public void SetAmbTargetAjustment()
	{
		SFXAmbTarget[] array = ambTargets;
		foreach (SFXAmbTarget sFXAmbTarget in array)
		{
			sFXAmbTarget.SetParameter("AmbientAdjustment", ambTargetAdjustmentParameter);
		}
	}
}
public class MapReference : MonoBehaviour
{
	public Map map;
}
public class HAGIS_A1O1 : HAGIS
{
	private Unit archi;

	private Unit Willa;

	private Unit SlagShinner;

	private Unit FuselGangMember1;

	private Unit FuselGangMember2;

	private Unit FuselGangMember3;

	private Unit nervousShiner1;

	private Unit nervousShiner2;

	private Unit Rupert;

	private Unit helpfulNPCChar;

	private Unit PanicNPC;

	private Unit SlagEntNPC1;

	private Unit SlagEntNPC2;

	private Unit TrainNPC;

	private Unit TrainNPC2;

	private Unit NPC_Family1;

	private Unit NPC_Family2;

	private Unit NPC_Family3;

	private Unit NPC_Shady;

	private Unit NPC_Wanderer;

	private UnitTarget ArchiToBar;

	private UnitTarget ArchiToLeader;

	private UnitTarget WillaToLeader;

	private UnitTarget Gang1Rummage;

	private UnitTarget Gang2Rummage;

	private UnitTarget Gang1Jump;

	private UnitTarget Gang2Jump;

	private UnitTarget GangApproach;

	private UnitTarget WillaToCorner;

	private UnitTarget PanicNPCRunTo;

	private UnitTarget helpfulNPCFacingDir;

	private UnitTarget WillaToBar;

	private UnitTarget ArchiNeedsDrink;

	private UnitTarget Shiner1ToArchi;

	private UnitTarget Shiner2ToArchi;

	private UnitTarget Shiner1ToDoor;

	private UnitTarget Shiner2ToDoor;

	private UnitTarget ArchiToDoor;

	private UnitTarget T_DoorToDist;

	private UnitTarget archiToDistExit;

	private UnitTarget WillaToSlagDoor;

	private UnitTarget Shiner1AlemDist;

	private UnitTarget Shiner2AlemDist;

	private UnitTarget ArchiToSlagEnt;

	private UnitTarget WillaToDoor;

	private UnitTarget Shiner1ToChair;

	private UnitTarget Shiner2ToChair;

	private UnitTarget RupertToSlags;

	private UnitTarget ArchiToRupertSlags;

	private UnitTarget WillaToRupertSlags;

	private UnitTarget WillaToCover;

	private UnitTarget ArchiToCover;

	private UnitTarget RupertToChair;

	private UnitTarget ArchiToExit;

	private UnitTarget ArchiSlagEntrace;

	private UnitTarget WillaSlagEntrace;

	private UnitTarget WillaTrainTarget;

	private UnitTarget ArchiSlagsExit;

	private UnitTarget ArchiExitToSubway;

	private UnitTarget ConterFlap;

	private UnitTarget dentistChair;

	private DialogData dialog_willaInChute;

	private DialogData dialog_willaGrossedOut;

	private DialogData dialog_WillaApproached;

	private DialogData dialog_willaBreakDown;

	private DialogData dialog_AFewFavs;

	private DialogData dialog_AFewFavsCont;

	private DialogData dialog_AnyCheddar;

	private DialogData dialog_HelpfulNPC;

	private DialogData dialog_ArchiUnconscious;

	private DialogData dialog_ArchiUnconscious2;

	private DialogData dialog_ArchiWaiting;

	private DialogData dialog_Hepatitis;

	private DialogData dialog_ArchiDrink;

	private DialogData dialog_FulfillingJob;

	private DialogData dialog_Argument;

	private DialogData dialog_CombatWon;

	private DialogData dialog_WillaMother;

	private DialogData dialog_BarBuyDrink;

	private DialogData dialog_PimDickBarbot1;

	private DialogData dialog_PimDickDoorman1;

	private DialogData dialog_PimDickDoorman2;

	private DialogData dialog_ArchiSlagEnt;

	private DialogData dialog_ArchiQuits;

	private DialogData dialog_AlemDistLeader;

	private DialogData dialog_FineWork;

	private DialogData dialog_YouWin;

	private DialogData ambient_WillaShit;

	private DialogData ambient_AllThisForAChair;

	private DialogData ambient_TrainConvo;

	private DialogData dialog_HartmanCompassionate;

	private DialogData dialog_HartmanHonest;

	private DialogData dialog_ArchiToBar;

	private DialogData ambient_Graffiti;

	private DialogData ambient_Graffiti41;

	private DialogData ambient_SlagsSign;

	private DialogData ambient_HeadForCambridge;

	private DialogData ambient_YouStillThereNod;

	private DialogData ambient_YouStillThereShake;

	private DialogData ambient_YouStillThereNone;

	private DialogData ambient_WeDoingThis;

	private DialogData dialog_SmellsOfGasoline;

	private DialogData ambient_youLookFamiliar;

	private DialogData ambient_HelloThereDearie;

	private DialogData ambient_YouStillThere;

	private DialogData tutorial_MarksmanIntro;

	private DialogData tutorial_OncePerTurn;

	private DialogData tutorial_SwitchTeamMember;

	private DialogData tutorial_Grenade;

	private DialogData tutorial_AvoidTheBlast;

	private DialogData tutorial_Augment;

	private TileTrigger ArchiWaitingTrigger;

	private TileTrigger WillaTriesToLeave;

	private TileTrigger WillaApproachesAugment;

	private TileTrigger WillaApprochesSubway;

	private TileTrigger WillaPickupAugment;

	private TileActionInteraction ArchiInteraction;

	private TileActionInteraction ArchiBarInteraction;

	private TileActionInteraction WillaLootInteraction;

	private TileActionDialog NPCSlagEntConvo;

	private TileActionDialog NPCTrain1Convo;

	private TileActionDialog HelpfulNPC;

	private TileActionDialog FamilyInteraction;

	private TileActionDialog ShadyInteraction;

	private TileActionDialog ShadyInteractionCam;

	private TileActionDialog RupertInteraction;

	private TileActionDialog RupertSlagsDialog;

	private TileActionSwapMap EnterSlags;

	private TileActionSwapMap SlagsToEnt;

	private TileActionSwapMap TigerToCam;

	private TileActionSwapMap CamToPimDick;

	private TileActionSwapMap PimDickToDist;

	private TileActionSwapMap PimDickToCam;

	private TileActionSwapMap DistToPimDick;

	private TileActionSwapMap ToSlagsEnt;

	private TileActionSwapMap SubwayFromCamStation;

	private TileActionSwapMap ToCambridge;

	private TileActionSwapMap ToTrain;

	private TileActionSwapMap TrainToSlagsEnt;

	private TileActionSwapMap FromTrain;

	private TileActionSwapMap CamToSubway;

	private string objEFightInTheSlagHeap = "OBJECTIVES_A1O1_01";

	private string objDefeatTheGangsters = "OBJECTIVES_A1O1_02";

	private string objLeaveSlagHeapString = "OBJECTIVES_A1O1_03";

	private string objTakeTheSubway = "OBJECTIVES_A1O1_04";

	private string objAskAboutArchiString = "OBJECTIVES_A1O1_05";

	private string objBuySomeLithomol = "OBJECTIVES_A1O1_06";

	private string objWakeArchiString = "OBJECTIVES_A1O1_07";

	private string objFollowArchiString = "OBJECTIVES_A1O1_08";

	private string objGoToSlagHeapString = "OBJECTIVES_A1O1_09";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot camLogic = GetLogicUsingArtName("T1Cambridge");
		LogicRoot PimDickLogic = GetLogicUsingArtName("T1PimDickles");
		LogicRoot AlemDistLogic = GetLogicUsingArtName("T1AlembicDistillery");
		LogicRoot slagEntLogic = GetLogicUsingArtName("T1Slags_Ent");
		LogicRoot slagLogic = GetLogicUsingArtName("T1Slags");
		LogicRoot subwayCambridge = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot subwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot subwayLogicSlag = GetLogicUsingArtName("T1Subway_Station_Slags");
		archi = GC.Inst.GetUnitWithId("902_T1Cambridge_UnitSpawn");
		archi.AddInitialPartyAbilities();
		Willa = GC.Inst.GetUnitWithId("0E5_T1Slags_UnitSpawn");
		SlagShinner = GC.Inst.GetUnitWithId("97B_T1Slags_UnitSpawn");
		FuselGangMember1 = GC.Inst.GetUnitWithId("171_T1Slags_UnitSpawn");
		FuselGangMember2 = GC.Inst.GetUnitWithId("98C_T1Slags_UnitSpawn");
		FuselGangMember3 = GC.Inst.GetUnitWithId("4D7_T1Slags_UnitSpawn");
		nervousShiner1 = GC.Inst.GetUnitWithId("EF1_T1PimDickles_UnitSpawn");
		nervousShiner2 = GC.Inst.GetUnitWithId("78D_T1PimDickles_UnitSpawn");
		Rupert = GC.Inst.GetUnitWithId("C1A_T1AlembicDistillery_UnitSpawn");
		helpfulNPCChar = GC.Inst.GetUnitWithId("081_T1Cambridge_UnitSpawn");
		PanicNPC = GC.Inst.GetUnitWithId("2E6_T1Slags_Ent_UnitSpawn");
		SlagEntNPC1 = GC.Inst.GetUnitWithId("27F_T1Slags_Ent_UnitSpawn");
		SlagEntNPC2 = GC.Inst.GetUnitWithId("875_T1Slags_Ent_UnitSpawn");
		TrainNPC = GC.Inst.GetUnitWithId("3A4_T1Subway_TrainInterior_UnitSpawn");
		TrainNPC2 = GC.Inst.GetUnitWithId("7AA_T1Subway_TrainInterior_UnitSpawn");
		NPC_Family1 = GC.Inst.GetUnitWithId("BC4_T1Subway_Station_Slags_UnitSpawn");
		NPC_Family2 = GC.Inst.GetUnitWithId("885_T1Subway_Station_Slags_UnitSpawn");
		NPC_Family3 = GC.Inst.GetUnitWithId("3A5_T1Subway_Station_Slags_UnitSpawn");
		NPC_Shady = GC.Inst.GetUnitWithId("C78_T1Subway_Station_Slags_UnitSpawn");
		NPC_Wanderer = GC.Inst.GetUnitWithId("810_T1Subway_Station_Slags_UnitSpawn");
		dialog_willaInChute = HAGIS.DialogLoad("Dialogs/A1O1/DialogWillaInChute");
		dialog_willaGrossedOut = HAGIS.DialogLoad("Dialogs/A1O1/DialogWillaGrossedOut");
		dialog_WillaApproached = HAGIS.DialogLoad("Dialogs/A1O1/DialogWillaApproached");
		ambient_WillaShit = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_WillaShit");
		dialog_willaBreakDown = HAGIS.DialogLoad("Dialogs/A1O1/DialogWillaBreakDown");
		dialog_ArchiSlagEnt = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiWaitingAtSlagEnt");
		dialog_AFewFavs = HAGIS.DialogLoad("Dialogs/A1O1/DialogAFewFavours");
		dialog_AFewFavsCont = HAGIS.DialogLoad("Dialogs/A1O1/DialogAFewFavoursCont");
		ambient_Graffiti = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Graffiti");
		ambient_Graffiti41 = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Graffiti41");
		ambient_SlagsSign = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_SlagsSign");
		ambient_HeadForCambridge = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_HeadForCambridge");
		dialog_SmellsOfGasoline = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_SmellsOfGasoline");
		ambient_youLookFamiliar = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_YouLookFamiliar");
		ambient_HelloThereDearie = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_HelloThereDearie");
		ambient_YouStillThere = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_YouStillThere");
		ambient_YouStillThereNod = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_YouStillThereNod");
		ambient_YouStillThereShake = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_YouStillThereShake");
		ambient_YouStillThereNone = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_YouStillThereNone");
		dialog_AnyCheddar = HAGIS.DialogLoad("Dialogs/A1O1/DialogAnyCheddar");
		dialog_HelpfulNPC = HAGIS.DialogLoad("Dialogs/A1O1/DialogPimDickBarbot1");
		dialog_ArchiUnconscious = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiUnconscious");
		dialog_ArchiWaiting = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiWaiting");
		dialog_ArchiUnconscious2 = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiUnconscious2");
		dialog_ArchiQuits = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiQuits");
		dialog_ArchiDrink = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiNeedsDrink");
		ambient_AllThisForAChair = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_AllThisForAChair");
		ambient_TrainConvo = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_TrainConvo");
		dialog_ArchiToBar = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiToBar");
		dialog_PimDickBarbot1 = HAGIS.DialogLoad("Dialogs/A1O1/DialogPimDickBarbot1");
		dialog_PimDickDoorman1 = HAGIS.DialogLoad("Dialogs/A1O1/DialogPimDickDoorman1");
		dialog_PimDickDoorman2 = HAGIS.DialogLoad("Dialogs/A1O1/DialogPimDickDoorman2");
		dialog_Hepatitis = HAGIS.DialogLoad("Dialogs/A1O1/DialogHepatitis");
		dialog_FulfillingJob = HAGIS.DialogLoad("Dialogs/A1O1/DialogFulfillingJob");
		ambient_WeDoingThis = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_WeDoingThis");
		dialog_BarBuyDrink = HAGIS.DialogLoad("Dialogs/A1O1/DialogBarBuyDrink");
		dialog_Argument = HAGIS.DialogLoad("Dialogs/A1O1/DialogArgument");
		dialog_CombatWon = HAGIS.DialogLoad("Dialogs/A1O1/DialogCombatWon");
		dialog_WillaMother = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_WillaMother");
		dialog_FineWork = HAGIS.DialogLoad("Dialogs/A1O1/DialogFineWork");
		dialog_YouWin = HAGIS.DialogLoad("Dialogs/A1O1/DialogArchiYouWin");
		dialog_HartmanCompassionate = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_HartmanCompassionate");
		dialog_HartmanHonest = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_HartmanHonest");
		dialog_AlemDistLeader = HAGIS.DialogLoad("Dialogs/A1O1/DialogAlembicDistilleryLeader");
		tutorial_MarksmanIntro = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_MarksmanIntro");
		tutorial_OncePerTurn = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_OncePerTurn");
		tutorial_SwitchTeamMember = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_SwitchTeamMember");
		tutorial_Grenade = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_Grenade");
		tutorial_AvoidTheBlast = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_AvoidTheBlast");
		tutorial_Augment = HAGIS.DialogLoad("Dialogs/A1O1/TutorialDialogs/Tutorial_CravenWhatsThat");
		ArchiWaitingTrigger = MR.Inst.GetTileTrigger("51E_T1Cambridge_TileTrigger");
		WillaApprochesSubway = MR.Inst.GetTileTrigger("F5F_T1Slags_Ent_TileTrigger");
		WillaTriesToLeave = MR.Inst.GetTileTrigger("B86_T1PimDickles_TileTrigger");
		WillaApproachesAugment = MR.Inst.GetTileTrigger("1B0_T1Slags_Ent_TileTrigger");
		WillaPickupAugment = MR.Inst.GetTileTrigger("AAC_T1Slags_Ent_TileLootTrigger");
		WillaLootInteraction = MR.Inst.GetTileActionInteraction("4BA_T1Slags_Ent_TileActionInteraction");
		HelpfulNPC = MR.Inst.GetTileActionDialog("B23_T1Cambridge_TileActionDialog");
		ArchiInteraction = MR.Inst.GetTileActionInteraction("5AA_T1Cambridge_TileActionInteraction");
		ArchiBarInteraction = MR.Inst.GetTileActionInteraction("0C1_T1PimDickles_TileActionInteraction");
		FamilyInteraction = MR.Inst.GetTileActionDialog("985_T1Subway_Station_Slags_TileActionDialog");
		ShadyInteraction = MR.Inst.GetTileActionDialog("8AF_T1Subway_Station_Slags_TileActionDialog");
		ShadyInteractionCam = MR.Inst.GetTileActionDialog("0FE_T1Cambridge_TileActionDialog");
		NPCSlagEntConvo = MR.Inst.GetTileActionDialog("CD4_T1Slags_Ent_TileActionDialog");
		NPCTrain1Convo = MR.Inst.GetTileActionDialog("F38_T1Subway_TrainInterior_TileActionDialog");
		RupertInteraction = MR.Inst.GetTileActionDialog("AF3_T1AlembicDistillery_TileActionDialog");
		RupertSlagsDialog = MR.Inst.GetTileActionDialog("2E1_T1Slags_TileActionDialog");
		SlagsToEnt = MR.Inst.GetTileActionSwapMap("F43_T1Slags_TileActionSwapMap");
		EnterSlags = MR.Inst.GetTileActionSwapMap("E07_T1Slags_Ent_TileActionSwapMap");
		CamToPimDick = MR.Inst.GetTileActionSwapMap("D87_T1Cambridge_TileActionSwapMap");
		PimDickToDist = MR.Inst.GetTileActionSwapMap("0D6_T1PimDickles_TileActionSwapMap");
		PimDickToCam = MR.Inst.GetTileActionSwapMap("147_T1PimDickles_TileActionSwapMap");
		DistToPimDick = MR.Inst.GetTileActionSwapMap("BD3_T1AlembicDistillery_TileActionSwapMap");
		ToCambridge = MR.Inst.GetTileActionSwapMap("98B_T1Subway_Station_TileActionSwapMap");
		ToSlagsEnt = MR.Inst.GetTileActionSwapMap("7F6_T1Subway_Station_Slags_TileActionSwapMap");
		SubwayFromCamStation = MR.Inst.GetTileActionSwapMap("C52_T1Subway_TrainInterior_TileActionSwapMap");
		ToTrain = MR.Inst.GetTileActionSwapMap("21C_T1Subway_Station_TileActionSwapMap");
		FromTrain = MR.Inst.GetTileActionSwapMap("C47_T1Subway_TrainInterior_TileActionSwapMap");
		TrainToSlagsEnt = MR.Inst.GetTileActionSwapMap("0B0_T1Subway_TrainInterior_TileActionSwapMap");
		CamToSubway = MR.Inst.GetTileActionSwapMap("A0B_T1Cambridge_TileActionSwapMap");
		TileActionSwapMap SlagEntToStation = MR.Inst.GetTileActionSwapMap("204_T1Slags_Ent_TileActionSwapMap");
		TileActionSwapMap ToSlagsStation = MR.Inst.GetTileActionSwapMap("447_T1Subway_TrainInterior_TileActionSwapMap");
		TileActionSwapMap SlagsStToTrain = MR.Inst.GetTileActionSwapMap("156_T1Subway_Station_Slags_TileActionSwapMap");
		ArchiToBar = MR.Inst.GetUnitTarget("CFD_T1PimDickles_UnitTarget");
		ArchiToLeader = MR.Inst.GetUnitTarget("994_T1AlembicDistillery_UnitTarget");
		WillaToLeader = MR.Inst.GetUnitTarget("F2E_T1AlembicDistillery_UnitTarget");
		Gang1Rummage = MR.Inst.GetUnitTarget("6A2_T1Slags_UnitTarget");
		Gang2Rummage = MR.Inst.GetUnitTarget("DC4_T1Slags_UnitTarget");
		Gang1Jump = MR.Inst.GetUnitTarget("D2B_T1Slags_UnitTarget");
		Gang2Jump = MR.Inst.GetUnitTarget("8CD_T1Slags_UnitTarget");
		GangApproach = MR.Inst.GetUnitTarget("417_T1Slags_UnitTarget");
		WillaToCorner = MR.Inst.GetUnitTarget("DBA_T1Slags_Ent_UnitTarget");
		PanicNPCRunTo = MR.Inst.GetUnitTarget("248_T1Slags_Ent_UnitTarget");
		helpfulNPCFacingDir = MR.Inst.GetUnitTarget("1C8_T1Cambridge_UnitTarget");
		ArchiNeedsDrink = MR.Inst.GetUnitTarget("F42_T1Cambridge_UnitTarget");
		archiToDistExit = MR.Inst.GetUnitTarget("6DF_T1AlembicDistillery_UnitTarget");
		WillaToBar = MR.Inst.GetUnitTarget("E34_T1PimDickles_UnitTarget");
		Shiner1ToArchi = MR.Inst.GetUnitTarget("D74_T1PimDickles_UnitTarget");
		Shiner2ToArchi = MR.Inst.GetUnitTarget("C26_T1PimDickles_UnitTarget");
		Shiner1ToDoor = MR.Inst.GetUnitTarget("92D_T1PimDickles_UnitTarget");
		Shiner2ToDoor = MR.Inst.GetUnitTarget("4F8_T1PimDickles_UnitTarget");
		ArchiToDoor = MR.Inst.GetUnitTarget("3F3_T1PimDickles_UnitTarget");
		WillaToSlagDoor = MR.Inst.GetUnitTarget("104_T1Slags_Ent_UnitTarget");
		WillaToDoor = MR.Inst.GetUnitTarget("7E3_T1PimDickles_UnitTarget");
		Shiner1AlemDist = MR.Inst.GetUnitTarget("6A5_T1AlembicDistillery_UnitTarget");
		Shiner2AlemDist = MR.Inst.GetUnitTarget("E08_T1AlembicDistillery_UnitTarget");
		ArchiToSlagEnt = MR.Inst.GetUnitTarget("562_T1Slags_Ent_UnitTarget");
		Shiner1ToChair = MR.Inst.GetUnitTarget("2CD_T1Slags_UnitTarget");
		Shiner2ToChair = MR.Inst.GetUnitTarget("FA7_T1Slags_UnitTarget");
		RupertToSlags = MR.Inst.GetUnitTarget("940_T1Slags_UnitTarget");
		ArchiToRupertSlags = MR.Inst.GetUnitTarget("298_T1Slags_UnitTarget");
		WillaToRupertSlags = MR.Inst.GetUnitTarget("D1D_T1Slags_UnitTarget");
		WillaToCover = MR.Inst.GetUnitTarget("F8A_T1Slags_UnitTarget");
		ArchiToCover = MR.Inst.GetUnitTarget("C72_T1Slags_UnitTarget");
		RupertToChair = MR.Inst.GetUnitTarget("F6B_T1Slags_UnitTarget");
		ArchiToExit = MR.Inst.GetUnitTarget("2CE_T1Slags_UnitTarget");
		ArchiSlagEntrace = MR.Inst.GetUnitTarget("A5D_T1Slags_UnitTarget");
		WillaSlagEntrace = MR.Inst.GetUnitTarget("DA9_T1Slags_UnitTarget");
		WillaTrainTarget = MR.Inst.GetUnitTarget("8A2_T1Subway_TrainInterior_UnitTarget");
		T_DoorToDist = MR.Inst.GetUnitTarget("2EE_T1PimDickles_UnitTarget");
		ArchiSlagsExit = MR.Inst.GetUnitTarget("CD8_T1Slags_Ent_UnitTarget");
		ArchiExitToSubway = MR.Inst.GetUnitTarget("CD8_T1Slags_Ent_UnitTarget");
		ConterFlap = MR.Inst.GetUnitTarget("B8C_T1PimDickles_UnitTarget");
		dentistChair = MR.Inst.GetUnitTarget("F70_T1AlembicDistillery_UnitTarget");
		Unit Barrel = GC.Inst.GetUnitWithId("746_T1Slags_UnitSpawn");
		Unit Barrel2 = GC.Inst.GetUnitWithId("613_T1Slags_UnitSpawn");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("918_T1Slags_TileBlockDynamic");
		TileBlockDynamic ArchiBlock = MR.Inst.GetTileBlockDynamic("7CF_T1PimDickles_TileBlockDynamic");
		UnitTarget AugTarget = MR.Inst.GetUnitTarget("E67_T1Slags_Ent_UnitTarget");
		EnterSlags.gameObject.SetActive(value: false);
		FuselGangMember1.gameObject.SetActive(value: false);
		FuselGangMember2.gameObject.SetActive(value: false);
		FuselGangMember3.gameObject.SetActive(value: false);
		RupertSlagsDialog.gameObject.SetActive(value: false);
		WillaApprochesSubway.gameObject.SetActive(value: false);
		Dynamicblock.gameObject.SetActive(value: false);
		PanicNPC.gameObject.SetActive(value: false);
		PimDickToDist.gameObject.SetActive(value: false);
		WillaTriesToLeave.gameObject.SetActive(value: false);
		nervousShiner1.gameObject.SetActive(value: false);
		nervousShiner2.gameObject.SetActive(value: false);
		ArchiWaitingTrigger.triggersInState = (GC.State)0;
		ArchiInteraction.gameObject.SetActive(value: false);
		ToCambridge.gameObject.SetActive(value: false);
		FromTrain.gameObject.SetActive(value: false);
		SubwayFromCamStation.gameObject.SetActive(value: false);
		CamToPimDick.gameObject.SetActive(value: false);
		TrainToSlagsEnt.gameObject.SetActive(value: false);
		dentistChair.gameObject.SetActive(value: false);
		NPCSlagEntConvo.gameObject.SetActive(value: false);
		SlagEntNPC1.gameObject.SetActive(value: false);
		SlagEntNPC2.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: false);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		TrainNPC2.gameObject.SetActive(value: false);
		SlagsToEnt.gameObject.SetActive(value: false);
		SlagEntToStation.gameObject.SetActive(value: false);
		PlayMapAnimation(PimDickLogic.Map, "MA_CounterFlap_01", "Close");
		ConstArray<v2i> grenadeTarget = new ConstArray<v2i>(1u);
		grenadeTarget.Add(new v2i(15, 12));
		CutsceneBegin();
		yield return null;
		SFXPlay("event:/sfx/script/act 1/a1o1/willa in chute");
		yield return CreateTimeCondition(6f);
		Willa.gameObject.SetActive(value: true);
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultUnconscious");
		yield return CutscenePlay("A1O1_Cutscene_WillaDrop");
		Dynamicblock.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEFightInTheSlagHeap);
		MusicPlay("event:/music/tracks/combat/light tension combat");
		yield return null;
		MusicSetProgress(0.1f);
		CutsceneEnd();
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		SKIP_POINT("Initial cutscene occurred");
		CombatBegin(UnitTeam.Type.Player);
		CutsceneBegin();
		if (!SaveData.resumingMission)
		{
			Ability_Grenade ability_Grenade = SlagShinner.abilities.Add<Ability_Grenade>(null, isUpgraded: true);
			UIAbilityWheelChoice choice = default(UIAbilityWheelChoice);
			choice.ability = ability_Grenade;
			choice.subAbilityIdx = 0;
			ability_Grenade.OnUnitSpawn(SlagShinner);
			ability_Grenade.OnActivateWithTilesSelectedBase(SlagShinner, grenadeTarget, choice);
		}
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(tutorial_Grenade);
		yield return HAGIS.DialogShow(tutorial_AvoidTheBlast);
		CutsceneEnd();
		yield return CombatWaitUntilComplete();
		SlagsToEnt.gameObject.SetActive(value: true);
		yield return null;
		MusicStop();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "TransDIdleToCIdle");
		SKIP_POINT("Skipped combat in the Slags");
		yield return null;
		HAGIS.DialogShow(ambient_WillaShit);
		UIObjectives.Inst.CompleteAndSetMainObjective(objLeaveSlagHeapString);
		HagletYieldTerm reachedMapEntrance = MapWaitUntilVisible(slagEntLogic.Map);
		yield return CreateOrCondition(reachedMapEntrance, CreateTriggerCondition(ambient_WillaShit.OnComplete));
		if (!reachedMapEntrance.met)
		{
			MusicPlay("event:/music/tracks/exploration/random dark 1");
			yield return MapWaitUntilVisible(slagEntLogic.Map);
			MusicStop();
		}
		else if (!ambient_WillaShit.completed)
		{
			CutsceneBegin();
			yield return CreateTriggerCondition(ambient_WillaShit.OnComplete);
			CutsceneEnd();
		}
		SKIP_POINT("Player escaped the slag heap");
		yield return null;
		yield return CutscenePlay("A1O1_Cutscene_WillaBreakDown");
		SKIP_POINT("Cutscene in the slagheap entrance occured");
		HAGIS.DialogShow(ambient_HeadForCambridge);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTakeTheSubway);
		yield return null;
		yield return TileWaitUntilTriggered(WillaApproachesAugment);
		Willa.LookInDirection(OctDir.Down);
		HAGIS.DialogShow(tutorial_Augment);
		yield return CreateTimeCondition(1f);
		ParticlePrefab AugHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, AugTarget.transform.GetChild(0));
		yield return CreateTriggerCondition(WillaLootInteraction.OnTriggered);
		WillaLootInteraction.gameObject.SetActive(value: false);
		AugHightlight.StopParticles();
		yield return null;
		yield return CreateTimeCondition(5f);
		SlagEntToStation.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(subwayLogicSlag.Map);
		PlayMapAnimation(subwayLogicSlag.Map, "MA_SubwayTrain", "Arriving");
		MusicStop();
		yield return HAGIS.DialogShow(dialog_SmellsOfGasoline);
		SKIP_POINT("skipped long dialog sequence after the slags");
		SKIP_POINT("about to board train");
		yield return MapWaitUntilMidTransition(subwayTrain);
		yield return MapWaitUntilVisible(subwayTrain.Map);
		UIObjectives.Inst.CompleteObjective(objTakeTheSubway);
		PanicNPC.gameObject.SetActive(value: false);
		ToCambridge.gameObject.SetActive(value: true);
		ToSlagsEnt.gameObject.SetActive(value: false);
		NPC_Wanderer.gameObject.SetActive(value: false);
		NPC_Family1.gameObject.SetActive(value: false);
		NPC_Family2.gameObject.SetActive(value: false);
		NPC_Family3.gameObject.SetActive(value: false);
		NPC_Shady.gameObject.SetActive(value: false);
		FamilyInteraction.gameObject.SetActive(value: false);
		ShadyInteraction.gameObject.SetActive(value: false);
		ToSlagsStation.gameObject.SetActive(value: false);
		CutsceneBegin();
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return UnitMoveToTarget(Willa, WillaTrainTarget);
		yield return HAGIS.DialogShow(ambient_YouStillThere);
		yield return HAGIS.DialogShow(ambient_YouStillThereNod);
		FromTrain.gameObject.SetActive(value: true);
		HAGIS.ToggleShakeEnvironment(on: false);
		CutsceneEnd();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Cambridge_L0");
		PlayMapAnimation(subwayTrain.Map, "MA_SubwayDoors", "Open");
		yield return MapWaitUntilVisible(camLogic.Map);
		ToTrain.gameObject.SetActive(value: false);
		yield return MapGoto(camLogic.Map);
		TrainNPC.gameObject.SetActive(value: false);
		TrainNPC2.gameObject.SetActive(value: true);
		NPCTrain1Convo.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/basic/stealth old 1");
		SKIP_POINT("Wake Archi");
		Barrel.Revive();
		Barrel2.Revive();
		UIObjectives.Inst.CompleteAndSetMainObjective(objWakeArchiString);
		ArchiInteraction.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(ArchiInteraction.OnTriggered);
		yield return CreateTimeCondition(0.5f);
		ArchiBlock.gameObject.SetActive(value: false);
		yield return CutscenePlay("A1O1_Cutscene_RecruitArchi");
		HelpfulNPC.gameObject.SetActive(value: false);
		ShadyInteractionCam.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objWakeArchiString);
		CutsceneBegin();
		yield return UnitMoveToTarget(archi, ArchiNeedsDrink, OctDir.Left, 2f);
		yield return UnitTeleportToMapViaEntranceTile(archi, PimDickToCam);
		yield return CreateTimeCondition(0.5f);
		CamToPimDick.gameObject.SetActive(value: true);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowArchiString);
		yield return null;
		archi.SetCoord(ArchiToBar.GetCoord());
		archi.unitModel.LookAtDirectionLS(new Vector3(-1f, 0f, 0f));
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		SKIP_POINT("Waiting for player to enter PIM DICKLE");
		yield return MapWaitUntilVisible(PimDickLogic.Map);
		MusicStop();
		yield return CreateTriggerCondition(ArchiBarInteraction.OnTriggered);
		ArchiBarInteraction.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objFollowArchiString);
		yield return CutscenePlay("A1O1_Cutscene_BarScene");
		CutsceneBegin();
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return UnitMoveToTarget(Willa, Shiner1ToArchi, OctDir.UpRight);
		UnitLookInDirection(nervousShiner2, OctDir.Down);
		UnitLookInDirection(archi, OctDir.DownLeft);
		yield return HAGIS.DialogShow(dialog_PimDickDoorman2);
		UnitLookInDirection(Willa, OctDir.Up);
		yield return CreateTimeCondition(0.5f);
		UnitLookInDirection(archi, OctDir.Up);
		yield return UnitMoveToTarget(nervousShiner1, T_DoorToDist, OctDir.Up);
		UnitTeleportToMapViaEntranceTile(nervousShiner1, DistToPimDick, Shiner1AlemDist);
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(archi, T_DoorToDist, OctDir.Up);
		UnitTeleportToMapViaEntranceTile(archi, DistToPimDick, ArchiToLeader);
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(nervousShiner2, T_DoorToDist, OctDir.Up);
		UnitTeleportToMapViaEntranceTile(nervousShiner2, DistToPimDick, Shiner2AlemDist);
		PimDickToDist.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("About To Meet Rupert");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowArchiString);
		yield return MapWaitUntilVisible(AlemDistLogic.Map);
		MusicPlay("event:/music/tracks/basic/shiner theme 1");
		DistToPimDick.gameObject.SetActive(value: false);
		archi.LookAt(Rupert);
		UIObjectives.Inst.CompleteObjective(objFollowArchiString);
		UnitMoveToTarget(Willa, WillaToLeader, OctDir.UpRight);
		nervousShiner1.LookInDirection(OctDir.Left);
		nervousShiner2.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(1.5f);
		yield return HAGIS.DialogShow(dialog_AlemDistLeader);
		yield return UnitMoveToTarget(archi, archiToDistExit);
		yield return UnitTeleportToMapViaEntranceTile(archi, PimDickToCam);
		archi.unitModel.LookAtDirectionLS(new Vector3(-1f, 0f, 0f));
		archi.SetCoord(ArchiToBar.GetCoord());
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		DistToPimDick.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowArchiString);
		yield return MapWaitUntilVisible(PimDickLogic.Map);
		WillaTriesToLeave.gameObject.SetActive(value: true);
		ArchiBarInteraction.gameObject.SetActive(value: true);
		PimDickToDist.gameObject.SetActive(value: false);
		SKIP_POINT("Cutscene in the Pim Dickle occurred");
		PanicNPC.gameObject.SetActive(value: false);
		PimDickToCam.gameObject.SetActive(value: false);
		yield return CreateOrCondition(ArchiBarInteraction.OnTriggered, WillaTriesToLeave._OnTriggered);
		CutsceneBegin();
		WillaTriesToLeave.gameObject.SetActive(value: false);
		Willa.LookAt(archi);
		yield return HAGIS.DialogShow(ambient_WeDoingThis);
		PimDickToCam.gameObject.SetActive(value: true);
		yield return archi.unitModel.Play("CsTransSitToDIdle");
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		archi.UpdateIdleAnim();
		archi.LookAt(Willa);
		archi.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoToSlagHeapString);
		CutsceneEnd();
		PimDickLogic.CanTeammatesFollow = true;
		camLogic.CanTeammatesFollow = true;
		subwayCambridge.CanTeammatesFollow = true;
		yield return MapWaitUntilMidTransition(camLogic);
		MusicPlay("event:/music/tracks/basic/stealth old 2");
		yield return MapWaitUntilVisible(camLogic.Map);
		MusicPlay("event:/music/tracks/basic/stealth old 2");
		HAGIS.DialogShow(ambient_AllThisForAChair);
		SubwayFromCamStation.gameObject.SetActive(value: true);
		CamToPimDick.gameObject.SetActive(value: false);
		SKIP_POINT("Heading back to train");
		PlayMapAnimation(subwayTrain.Map, "MA_SubwayDoors", "Close");
		yield return MapWaitUntilMidTransition(subwayCambridge);
		PlayMapAnimation(subwayCambridge.Map, "MA_SubwayTrain", "Arriving");
		yield return MapWaitUntilVisible(subwayCambridge.Map);
		yield return CreateTimeCondition(5f);
		ToTrain.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(subwayTrain.Map);
		HAGIS.ToggleShakeEnvironment(on: true);
		UIObjectives.Inst.CompleteObjective(objFollowArchiString);
		ToCambridge.gameObject.SetActive(value: false);
		SKIP_POINT("back on the train to the slags");
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, WillaTrainTarget);
		FromTrain.gameObject.SetActive(value: false);
		SubwayFromCamStation.gameObject.SetActive(value: false);
		HAGIS.ToggleShakeEnvironment(on: false);
		NPCSlagEntConvo.gameObject.SetActive(value: true);
		SlagEntNPC1.gameObject.SetActive(value: true);
		SlagEntNPC2.gameObject.SetActive(value: true);
		Willa.LookAt(archi);
		archi.LookAt(Willa);
		yield return HAGIS.DialogShow(ambient_TrainConvo);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoToSlagHeapString);
		yield return TeamMoveToMapViaEntranceTile(SlagEntToStation);
		SlagEntToStation.gameObject.SetActive(value: false);
		MusicStop();
		CutsceneEnd();
		SKIP_POINT("At Slags entrance");
		EnterSlags.gameObject.SetActive(value: false);
		CutsceneBegin();
		Willa.LookAt(archi);
		yield return HAGIS.DialogShow(dialog_ArchiSlagEnt);
		MusicPlay("event:/music/tracks/basic/drone 1");
		CutsceneEnd();
		EnterSlags.gameObject.SetActive(value: true);
		SKIP_POINT("Final cutscene in the slag heap occurs");
		yield return MapWaitUntilVisible(slagLogic.Map);
		FuselGangMember1.gameObject.SetActive(value: true);
		FuselGangMember2.gameObject.SetActive(value: true);
		FuselGangMember3.gameObject.SetActive(value: true);
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		Willa.LookInDirection(OctDir.Up);
		yield return HAGIS.DialogShow(dialog_Argument);
		CutsceneEnd();
		archi.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(archi);
		yield return null;
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		SKIP_POINT("Player returns to the slag heap and has to fight enemies");
		CombatBegin(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objDefeatTheGangsters);
		UnitMoveToTarget(Willa, WillaToCover);
		UnitMoveToTarget(archi, ArchiToCover);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefeatTheGangsters);
		CutsceneBegin();
		yield return HAGIS.DialogShow(tutorial_MarksmanIntro);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(tutorial_OncePerTurn);
		CutsceneEnd();
		yield return TurnModeWaitForPlayerTurnStart();
		yield return HAGIS.DialogShow(tutorial_SwitchTeamMember);
		yield return CombatWaitUntilComplete();
		GC.Inst.SetRPGLeader(Willa);
		yield return null;
		SKIP_POINT("Skipped Slag fight");
		CutsceneBegin();
		HagisLog("ERROR EASDLKNAS:DLKJNASL:KLCDBN:AKSHD;lkj");
		MusicPlay("event:/music/tracks/basic/willa underscore");
		yield return UnitMoveToTarget(Willa, WillaToRupertSlags, OctDir.Right);
		yield return UnitMoveToTarget(archi, ArchiToCover, OctDir.Left);
		Willa.LookAt(archi);
		archi.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_CombatWon);
		yield return UnitMoveToTarget(archi, ArchiSlagEntrace, null, 2f);
		Willa.LookAt(archi);
		yield return HAGIS.DialogShow(dialog_WillaMother);
		archi.LookAt(Willa);
		yield return CreateTimeCondition(2f);
		MusicPlay("event:/music/tracks/basic/shiner theme 1");
		yield return UnitTeleportToMapViaEntranceTile(Rupert, SlagsToEnt);
		yield return UnitTeleportToMapViaEntranceTile(nervousShiner1, SlagsToEnt);
		yield return UnitTeleportToMapViaEntranceTile(nervousShiner2, SlagsToEnt);
		UnitMoveToTarget(nervousShiner1, Shiner1ToChair);
		yield return UnitMoveToTarget(nervousShiner2, Shiner2ToChair);
		yield return CreateTimeCondition(1f);
		nervousShiner1.LookInDirection(OctDir.Up);
		nervousShiner2.LookInDirection(OctDir.Up);
		UnitMoveToTarget(Rupert, RupertToSlags);
		yield return UnitMoveToTarget(archi, ArchiToRupertSlags, null, 2f);
		Willa.LookAt(Rupert);
		archi.LookAt(Rupert);
		yield return HAGIS.DialogShow(dialog_FineWork);
		yield return HAGIS.DialogShow(dialog_ArchiQuits);
		yield return UnitMoveToTarget(archi, ArchiToExit);
		yield return CreateTimeCondition(1f);
		UnitMoveToTarget(Rupert, RupertToChair, OctDir.Down);
		RupertSlagsDialog.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(dialog_YouWin);
		EnterSlags.gameObject.SetActive(value: true);
		archi.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(archi, ArchiToExit);
		yield return UnitTeleportToMapViaEntranceTile(archi, EnterSlags, ArchiSlagsExit);
		archi.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		SKIP_POINT("Final cutscene in the slag heap occurs");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowArchiString);
		yield return MapWaitUntilVisible(slagEntLogic.Map);
		SlagEntToStation.gameObject.SetActive(value: true);
		archi.LookInDirection(OctDir.Right);
		WillaApprochesSubway.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(WillaApprochesSubway._OnTriggered);
		UIObjectives.Inst.CompleteObjective(objFollowArchiString);
		if (HAGIS.WasHonestThroughoutSection(DC.GameSection.ONE))
		{
			yield return HAGIS.DialogShow(dialog_HartmanHonest);
		}
		else
		{
			yield return HAGIS.DialogShow(dialog_HartmanCompassionate);
		}
		archi.LookInDirection(OctDir.Left);
		yield return UnitMoveToTarget(archi, ArchiExitToSubway);
		archi.gameObject.SetActive(value: false);
		UnitMoveToTarget(Willa, ArchiExitToSubway);
		PartyMember partyLeader = Party.Inst.GetPartyLeader();
		partyLeader.SetFirstAbilityChoiceAtLevel(1);
	}
}
public class HAGIS_A1O1_CigaretteMachine : HAGIS
{
	private DialogData dialog_ShadyNPC;

	private TileActionInteraction CigaretteMachine;

	private Unit Willa;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Willa = GC.Inst.GetUnitWithId("0E5_T1Slags_UnitSpawn");
		CigaretteMachine = MR.Inst.GetTileActionInteraction("88D_T1PimDickles_TileActionInteraction");
		yield return null;
		yield return CreateTriggerCondition(CigaretteMachine.OnTriggered);
		CutsceneBegin();
		yield return Willa.unitModel.Play("DefaultInteract");
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		yield return null;
	}
}
public class HAGIS_A1O1_HelpfulNPC : HAGIS
{
	private Unit helpfulNPCChar;

	private Unit archi;

	private DialogData dialog_HelpfulNPC2;

	private DialogData dialog_PimDickBarbot1;

	private UnitTarget helpfulNPCFacingDir;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		helpfulNPCChar = GC.Inst.GetUnitWithId("081_T1Cambridge_UnitSpawn");
		archi = GC.Inst.GetUnitWithId("902_T1Cambridge_UnitSpawn");
		dialog_PimDickBarbot1 = HAGIS.DialogLoad("Dialogs/A1O1/DialogPimDickBarbot1");
		helpfulNPCFacingDir = MR.Inst.GetUnitTarget("1C8_T1Cambridge_UnitTarget");
		TileActionDialog HelpfulNPC = MR.Inst.GetTileActionDialog("B23_T1Cambridge_TileActionDialog");
		yield return null;
		yield return HelpfulNPC.OnDialogComplete;
		helpfulNPCChar.LookAt(archi);
		yield return CreateTimeCondition(2f);
		helpfulNPCChar.LookAt(helpfulNPCFacingDir.transform);
	}
}
public class HAGIS_A1O1_ShadyNPC : HAGIS
{
	private DialogData dialog_ShadyNPC;

	private TileActionDialog ShadyNPC;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		dialog_ShadyNPC = HAGIS.DialogLoad("Dialogs/A1O1/DialogShadyNPC");
		ShadyNPC = MR.Inst.GetTileActionDialog("0FE_T1Cambridge_TileActionDialog");
		yield return CreateTriggerCondition(dialog_ShadyNPC.OnComplete);
	}
}
public class HAGIS_A1O1_TimeToGo : HAGIS
{
	private DialogData ambient_Chair;

	private DialogData ambient_Garbage1;

	private DialogData ambient_Garbage2;

	private DialogData ambient_Garbage3;

	private DialogData ambient_Garbage4;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		ambient_Chair = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Chair");
		ambient_Garbage1 = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Garbage1");
		ambient_Garbage2 = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Garbage2");
		ambient_Garbage3 = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Garbage3");
		ambient_Garbage4 = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_Garbage4");
		yield return null;
		int Triggers = 0;
		while (true)
		{
			yield return CreateOrCondition(CreateTriggerCondition(ambient_Chair.OnComplete), CreateTriggerCondition(ambient_Garbage1.OnComplete), CreateTriggerCondition(ambient_Garbage2.OnComplete), CreateTriggerCondition(ambient_Garbage3.OnComplete), CreateTriggerCondition(ambient_Garbage4.OnComplete));
			int num;
			Triggers = (num = Triggers + 1);
			switch (num)
			{
			case 1:
				break;
			default:
				yield break;
			}
		}
	}
}
public class HAGIS_A1O1_TimeToGoDis : HAGIS
{
	private DialogData Dialog_ShinerGap;

	private DialogData Dialog_ShinerBoxOfAugs;

	private DialogData Dialog_MissionStatement;

	private DialogData Dialog_Book;

	private DialogData Ambient_FindArchi;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Dialog_ShinerGap = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_ShinerGap");
		Dialog_ShinerBoxOfAugs = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_ShinerBoxOfAugs");
		Dialog_MissionStatement = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_MissionStatement");
		Dialog_Book = HAGIS.DialogLoad("Dialogs/A1O1/Dialog_Book");
		Ambient_FindArchi = HAGIS.DialogLoad("Dialogs/A1O1/Ambient_FindArchi");
		yield return null;
		int Triggers = 0;
		while (true)
		{
			yield return CreateOrCondition(CreateTriggerCondition(Dialog_ShinerGap.OnComplete), CreateTriggerCondition(Dialog_ShinerBoxOfAugs.OnComplete), CreateTriggerCondition(Dialog_MissionStatement.OnComplete), CreateTriggerCondition(Dialog_Book.OnComplete));
			int num;
			Triggers = (num = Triggers + 1);
			switch (num)
			{
			case 1:
				break;
			default:
				yield break;
			case 2:
				yield return CreateTimeCondition(1f);
				yield return HAGIS.DialogShow(Ambient_FindArchi);
				yield break;
			}
		}
	}
}
public class HAGIS_A1S1_HydroReminder : HAGIS
{
	private DialogData dialog_tickTock;

	private TileActionDialog HydroPlantStation1;

	private TileActionDialog HydroPlantStation2;

	private TileActionDialog HydroPlantStation3;

	private TileActionDialog HydroPlantStation4;

	private TileActionDialog HydroPlantStation5;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		dialog_tickTock = HAGIS.DialogLoad("Dialogs/A1S1/HydroponicsPlant/DialogAshChecks3Stations");
		HydroPlantStation1 = MR.Inst.GetTileActionDialog("9D0_T2Hydroponics_TileActionDialog");
		HydroPlantStation2 = MR.Inst.GetTileActionDialog("6D3_T2BillysHilltopFarm_TileActionDialog");
		HydroPlantStation3 = MR.Inst.GetTileActionDialog("0D3_T2Hydroponics_TileActionDialog");
		HydroPlantStation4 = MR.Inst.GetTileActionDialog("75C_T2BillysHilltopFarm_TileActionDialog");
		HydroPlantStation5 = MR.Inst.GetTileActionDialog("EF5_T2BillysHilltopFarm_TileActionDialog");
		yield return null;
		int stationCount = 0;
		do
		{
			HagletYieldTerm HydroPlantStation1USED = CreateTriggerCondition(HydroPlantStation1.OnDialogComplete);
			yield return CreateOrCondition(term2: CreateTriggerCondition(HydroPlantStation2.OnDialogComplete), term3: CreateTriggerCondition(HydroPlantStation3.OnDialogComplete), term4: CreateTriggerCondition(HydroPlantStation4.OnDialogComplete), term5: CreateTriggerCondition(HydroPlantStation5.OnDialogComplete), term1: HydroPlantStation1USED);
			if (HydroPlantStation1USED.met)
			{
				HagisLog("Im working!");
			}
			stationCount++;
		}
		while (stationCount < 3);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(dialog_tickTock);
	}
}
public class HAGIS_A1O2 : HAGIS
{
	private Unit margot;

	private Unit willa;

	private Unit archi;

	private Unit thirdMember;

	private Unit noot;

	private Unit eugene;

	private Unit Patron2;

	private Unit WonderingBarDroid;

	private Unit port1Muscle;

	private Unit port1Trigger;

	private Unit trainShiner1;

	private Unit trainShiner2;

	private Unit shinerVictim;

	private Unit femalePassenger;

	private Unit femalePassenger2;

	private Unit leglessGuy;

	private Unit Fusel1;

	private Unit Fusel2;

	private Unit Fusel3;

	private Unit BackstageMuscle;

	private Unit BackstageMuscle2;

	private Unit BackstageMuscle3;

	private Unit BackstageSolly;

	private UnitTarget stageTarget;

	private UnitTarget barTarget;

	private UnitTarget archiConferenceTarget;

	private UnitTarget T_BlindTiger;

	private UnitTarget margotBackstageSpot;

	private UnitTarget margotRevealSpot;

	private UnitTarget nootTarget;

	private UnitTarget EugeneTarget;

	private UnitTarget margotsDeskTarget;

	private UnitTarget archiDeskTarget;

	private UnitTarget BackstageMuscleTarget;

	private UnitTarget BackstageSollyTarget;

	private UnitTarget archiCutsceneTarget;

	private UnitTarget nootCutsceneTarget;

	private UnitTarget GoonTarget;

	private UnitTarget T_WillaHide;

	private UnitTarget T_ChrisHide;

	private UnitTarget T_ArchiHide;

	private UnitTarget ArchiBTCover;

	private UnitTarget WillaBTCover;

	private UnitTarget ThirdBTCover;

	private UnitTarget T_MargotStage;

	private UnitTarget endTargetSpot0;

	private UnitTarget endTargetSpot1;

	private UnitTarget endTargetSpot2;

	private UnitTarget EndTargetEugene;

	private UnitTarget EndTargetNoot;

	private UnitTarget endTargetSpot3;

	private UnitTarget endTargetSpot4;

	private UnitTarget endTargetSpot5;

	private UnitTarget margotCambridgeSpot;

	private UnitTarget WillaTarget;

	private UnitTarget ArchiTarget;

	private UnitTarget WillaEntersTrain;

	private UnitTarget willaEntersPort1;

	private UnitTarget ArchiEntersPort1;

	private UnitTarget ThirdMemEntersPort1;

	private UnitTarget ThirdMemToCover;

	private UnitTarget MuscleToCover;

	private UnitTarget TriggerToCover;

	private UnitTarget willaEntranceTarget;

	private UnitTarget archiEntranceTarget;

	private UnitTarget margotEntersPort1;

	private UnitTarget margotEntranceTarget;

	private UnitTarget MargotAfterFight;

	private UnitTarget T_MargotToBackStage;

	private TileActionDialog TalkPatron1;

	private TileActionDialog TalkPatron2;

	private TileActionDialog TalkPatron3;

	private TileActionDialog margotStageDialog;

	private TileActionDialog margotIntroTrigger;

	private TileActionDialog BartenderDialog;

	private TileActionDialog conferenceDialog;

	private TileActionDialog TalkToMargot;

	private TileActionDialog TalkToMargot2;

	private TileActionDialog CantLeaveYet;

	private TileActionDialog CantLeaveYet2;

	private TileActionDialog D_MundInsists;

	private TileActionDialog D_TalkToMundAgain;

	private TileActionDialog D_NootEject;

	private TileActionDialog confrontTrainShiners;

	private TileActionDialog leglessTrainMan;

	private TileActionDialog confrontTrainFusel;

	private TileActionSwapMap cambridgeToBar;

	private TileActionSwapMap cambridgeToSubway;

	private TileActionSwapMap barToBackstage;

	private TileActionSwapMap barToCambridge;

	private TileActionSwapMap backstageToBar;

	private TileActionSwapMap portEntToSubwayPort;

	private TileActionSwapMap entranceToDock;

	private TileActionSwapMap dockToEntrance;

	private TileActionSwapMap subwayCamToCam;

	private TileActionSwapMap subwayCamToTrain;

	private TileActionSwapMap trainToStationCam;

	private TileActionSwapMap trainToStationPort;

	private TileActionSwapMap trainToCam;

	private TileActionSwapMap subwayPortToPort;

	private TileTrigger portTrigger;

	private TileTrigger backstageTrigger;

	private TileTrigger lockedDockTransitionTrigger;

	private TileBlockDynamic ShipmentOpenCol1;

	private TileBlockDynamic ShipmentOpenCol2;

	private TileActionInteraction margotsDesk;

	private TileActionInteraction lockedDockTransitionA;

	private TileActionInteraction lockedDockTransitionB;

	private TileActionInteraction secretThing;

	private TileActionInteraction SubwayCutsceneTrigger;

	private TileActionInteraction TalkToMund;

	private DialogData dialog_searchStart;

	private DialogData dialog_patron1;

	private DialogData dialog_patron2;

	private DialogData dialog_patron2b;

	private DialogData dialog_patron3;

	private DialogData dialog_bartender;

	private DialogData dialog_keepLooking1;

	private DialogData dialog_keepLooking2;

	private DialogData dialog_margotIntro;

	private DialogData dialog_checkingDresser;

	private DialogData dialog_trespass;

	private DialogData dialog_afterFight;

	private DialogData dialog_afterFight2;

	private DialogData dialog_margotReturns;

	private DialogData dialog_eugenesMission;

	private DialogData dialog_margotOutside;

	private DialogData dialog_stealth;

	private DialogData dialog_margotHelps;

	private DialogData dialog_gotItem;

	private DialogData dialog_endMission;

	private DialogData dialog_MargotJoins;

	private DialogData Dialog_WillaHeard;

	private DialogData tutorial_GhostIntro;

	private DialogData ambient_missionStart;

	private DialogData ambient_LuckyIdiot;

	private DialogData ambient_conference;

	private DialogData ambient_wait;

	private DialogData ambient_dontPester;

	private DialogData ambient_headBackstage;

	private DialogData ambient_headBackstage2;

	private DialogData ambient_checkDresser;

	private DialogData ambient_archiResists;

	private DialogData ambient_eugeneInsists;

	private DialogData ambient_margotHelps;

	private DialogData ambient_gotItem;

	private DialogData Ambient_Eject;

	private string objGoToBarString = "OBJECTIVES_A1O2_01";

	private string objAskAroundString = "OBJECTIVES_A1O2_02";

	private string objFollowMargotString = "OBJECTIVES_A1O2_03";

	private string objSnoopAround = "OBJECTIVES_A1O2_04";

	private string objGoToPortHaraString = "OBJECTIVES_A1O2_05";

	private string objClearDock = "OBJECTIVES_A1O2_06";

	private string objSearchForThingString = "OBJECTIVES_A1O2_07";

	private string objReturnToMundString = "OBJECTIVES_A1O2_08";

	private string objLeaveTheBlindTiger = "OBJECTIVES_A1O2_09";

	private string objClearBasment = "OBJECTIVES_A1O2_10";

	private string objGetPastGuardsString = "OBJECTIVES_A1O2_11";

	private string objTalkToMargot = "OBJECTIVES_A1O2_12";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot cambridgeLogic = GetLogicUsingArtName("T1Cambridge");
		LogicRoot barLogic = GetLogicUsingArtName("T1Bar1_BlindTiger");
		LogicRoot backstageLogic = GetLogicUsingArtName("T1Bar2_BehindTheTiger");
		LogicRoot portEntranceLogic = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot portLogic = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot SubwayCam = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot SubwayPort = GetLogicUsingArtName("T1Subway_Station_PortHara");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		margot = GC.Inst.GetUnitWithId("5DB_T1Bar1_BlindTiger_UnitSpawn");
		margot.AddInitialPartyAbilities();
		willa = GC.Inst.GetUnitWithId("CCA_T1Cambridge_UnitSpawn");
		thirdMember = GC.Inst.TryGetUnitWithId("272_T1Cambridge_UnitSpawn");
		archi = GC.Inst.GetUnitWithId("3F5_T1Cambridge_UnitSpawn");
		noot = GC.Inst.GetUnitWithId("538_T1Bar2_BehindTheTiger_UnitSpawn");
		eugene = GC.Inst.GetUnitWithId("7A1_T1Bar2_BehindTheTiger_UnitSpawn");
		BackstageMuscle = GC.Inst.GetUnitWithId("442_T1Bar2_BehindTheTiger_UnitSpawn");
		BackstageMuscle2 = GC.Inst.GetUnitWithId("EE7_T1Bar2_BehindTheTiger_UnitSpawn");
		BackstageMuscle3 = GC.Inst.GetUnitWithId("74D_T1Bar2_BehindTheTiger_UnitSpawn");
		BackstageSolly = GC.Inst.GetUnitWithId("B2D_T1Bar2_BehindTheTiger_UnitSpawn");
		Patron2 = GC.Inst.GetUnitWithId("F72_T1Bar1_BlindTiger_UnitSpawn");
		WonderingBarDroid = GC.Inst.GetUnitWithId("C73_T1Bar1_BlindTiger_UnitSpawn");
		port1Muscle = GC.Inst.GetUnitWithId("3D7_T1Port1_HaraEntrance_UnitSpawn");
		port1Trigger = GC.Inst.GetUnitWithId("BE4_T1Port1_HaraEntrance_UnitSpawn");
		trainShiner1 = GC.Inst.GetUnitWithId("7D9_T1Subway_TrainInterior_UnitSpawn");
		trainShiner2 = GC.Inst.GetUnitWithId("A95_T1Subway_TrainInterior_UnitSpawn");
		shinerVictim = GC.Inst.GetUnitWithId("554_T1Subway_TrainInterior_UnitSpawn");
		femalePassenger = GC.Inst.GetUnitWithId("1CF_T1Subway_TrainInterior_UnitSpawn");
		femalePassenger2 = GC.Inst.GetUnitWithId("A37_T1Subway_TrainInterior_UnitSpawn");
		leglessGuy = GC.Inst.GetUnitWithId("72A_T1Subway_TrainInterior_UnitSpawn");
		Fusel1 = GC.Inst.GetUnitWithId("039_T1Subway_TrainInterior_UnitSpawn");
		Fusel2 = GC.Inst.GetUnitWithId("A53_T1Subway_TrainInterior_UnitSpawn");
		Fusel3 = GC.Inst.GetUnitWithId("66C_T1Subway_TrainInterior_UnitSpawn");
		cambridgeToBar = MR.Inst.GetTileActionSwapMap("A5E_T1Cambridge_TileActionSwapMap");
		cambridgeToSubway = MR.Inst.GetTileActionSwapMap("69A_T1Cambridge_TileActionSwapMap");
		barToBackstage = MR.Inst.GetTileActionSwapMap("0F1_T1Bar1_BlindTiger_TileActionSwapMap");
		barToCambridge = MR.Inst.GetTileActionSwapMap("C67_T1Bar1_BlindTiger_TileActionSwapMap");
		backstageToBar = MR.Inst.GetTileActionSwapMap("396_T1Bar2_BehindTheTiger_TileActionSwapMap");
		portEntToSubwayPort = MR.Inst.GetTileActionSwapMap("037_T1Port1_HaraEntrance_TileActionSwapMap");
		entranceToDock = MR.Inst.GetTileActionSwapMap("004_T1Port1_HaraEntrance_TileActionSwapMap");
		dockToEntrance = MR.Inst.GetTileActionSwapMap("E9F_T1Port2_HaraMainBay_TileActionSwapMap");
		subwayCamToCam = MR.Inst.GetTileActionSwapMap("DE4_T1Subway_Station_Cambridge_TileActionSwapMap");
		subwayCamToTrain = MR.Inst.GetTileActionSwapMap("768_T1Subway_Station_Cambridge_TileActionSwapMap");
		trainToStationCam = MR.Inst.GetTileActionSwapMap("820_T1Subway_TrainInterior_TileActionSwapMap");
		trainToStationPort = MR.Inst.GetTileActionSwapMap("A9C_T1Subway_TrainInterior_TileActionSwapMap");
		subwayPortToPort = MR.Inst.GetTileActionSwapMap("ECF_T1Subway_Station_PortHara_TileActionSwapMap");
		trainToCam = MR.Inst.GetTileActionSwapMap("BBE_T1Subway_TrainInterior_TileActionSwapMap");
		margotStageDialog = MR.Inst.GetTileActionDialog("2A2_T1Bar1_BlindTiger_TileActionDialog");
		margotIntroTrigger = MR.Inst.GetTileActionDialog("BF3_T1Bar1_BlindTiger_TileActionDialog");
		conferenceDialog = MR.Inst.GetTileActionDialog("52E_T1Bar1_BlindTiger_TileActionDialog");
		BartenderDialog = MR.Inst.GetTileActionDialog("20D_T1Bar1_BlindTiger_TileActionDialog");
		TalkToMargot = MR.Inst.GetTileActionDialog("A0E_T1Cambridge_TileActionDialog");
		TalkToMargot2 = MR.Inst.GetTileActionDialog("24D_T1Cambridge_TileActionDialog");
		CantLeaveYet = MR.Inst.GetTileActionDialog("4F1_T1Cambridge_TileActionDialog");
		CantLeaveYet2 = MR.Inst.GetTileActionDialog("FE4_T1Cambridge_TileActionDialog");
		D_MundInsists = MR.Inst.GetTileActionDialog("CF1_T1Bar2_BehindTheTiger_TileActionDialog");
		D_TalkToMundAgain = MR.Inst.GetTileActionDialog("D82_T1Bar1_BlindTiger_TileActionDialog");
		TalkPatron1 = MR.Inst.GetTileActionDialog("07E_T1Bar1_BlindTiger_TileActionDialog");
		TalkPatron2 = MR.Inst.GetTileActionDialog("70F_T1Bar1_BlindTiger_TileActionDialog");
		TalkPatron3 = MR.Inst.GetTileActionDialog("B72_T1Bar1_BlindTiger_TileActionDialog");
		confrontTrainShiners = MR.Inst.GetTileActionDialog("C2E_T1Subway_TrainInterior_TileActionDialog");
		leglessTrainMan = MR.Inst.GetTileActionDialog("D4C_T1Subway_TrainInterior_TileActionDialog");
		confrontTrainFusel = MR.Inst.GetTileActionDialog("8EF_T1Subway_Station_Cambridge_TileActionDialog");
		margotsDesk = MR.Inst.GetTileActionInteraction("6DF_T1Bar2_BehindTheTiger_TileActionInteraction");
		secretThing = MR.Inst.GetTileActionInteraction("350_T1Port2_HaraMainBay_TileActionInteraction");
		TalkToMund = MR.Inst.GetTileActionInteraction("A02_T1Bar1_BlindTiger_TileActionInteraction");
		SubwayCutsceneTrigger = MR.Inst.GetTileActionInteraction("ABD_T1Subway_TrainInterior_TileActionInteraction");
		stageTarget = MR.Inst.GetUnitTarget("BE1_T1Bar1_BlindTiger_UnitTarget");
		barTarget = MR.Inst.GetUnitTarget("36E_T1Bar1_BlindTiger_UnitTarget");
		archiConferenceTarget = MR.Inst.GetUnitTarget("260_T1Bar1_BlindTiger_UnitTarget");
		ArchiBTCover = MR.Inst.GetUnitTarget("5AE_T1Bar2_BehindTheTiger_UnitTarget");
		WillaBTCover = MR.Inst.GetUnitTarget("BE5_T1Bar2_BehindTheTiger_UnitTarget");
		ThirdBTCover = MR.Inst.GetUnitTarget("848_T1Bar2_BehindTheTiger_UnitTarget");
		T_MargotStage = MR.Inst.GetUnitTarget("B10_T1Bar1_BlindTiger_UnitTarget");
		margotBackstageSpot = MR.Inst.GetUnitTarget("300_T1Bar2_BehindTheTiger_UnitTarget");
		margotRevealSpot = MR.Inst.GetUnitTarget("C8D_T1Bar2_BehindTheTiger_UnitTarget");
		nootTarget = MR.Inst.GetUnitTarget("587_T1Bar2_BehindTheTiger_UnitTarget");
		EugeneTarget = MR.Inst.GetUnitTarget("301_T1Bar2_BehindTheTiger_UnitTarget");
		margotsDeskTarget = MR.Inst.GetUnitTarget("1DA_T1Bar2_BehindTheTiger_UnitTarget");
		archiDeskTarget = MR.Inst.GetUnitTarget("F39_T1Bar2_BehindTheTiger_UnitTarget");
		archiCutsceneTarget = MR.Inst.GetUnitTarget("CA9_T1Bar2_BehindTheTiger_UnitTarget");
		nootCutsceneTarget = MR.Inst.GetUnitTarget("079_T1Bar2_BehindTheTiger_UnitTarget");
		BackstageSollyTarget = MR.Inst.GetUnitTarget("65F_T1Bar2_BehindTheTiger_UnitTarget");
		BackstageMuscleTarget = MR.Inst.GetUnitTarget("1EB_T1Bar2_BehindTheTiger_UnitTarget");
		GoonTarget = MR.Inst.GetUnitTarget("D34_T1Bar2_BehindTheTiger_UnitTarget");
		T_BlindTiger = MR.Inst.GetUnitTarget("004_T1Cambridge_UnitTarget");
		T_WillaHide = MR.Inst.GetUnitTarget("1BD_T1Bar2_BehindTheTiger_UnitTarget");
		T_ArchiHide = MR.Inst.GetUnitTarget("BCD_T1Bar2_BehindTheTiger_UnitTarget");
		T_ChrisHide = MR.Inst.GetUnitTarget("290_T1Bar2_BehindTheTiger_UnitTarget");
		UnitTarget TR_LootTriggerCore = MR.Inst.GetUnitTarget("DED_T1Port2_HaraMainBay_UnitTarget");
		endTargetSpot0 = MR.Inst.GetUnitTarget("F4A_T1Bar1_BlindTiger_UnitTarget");
		endTargetSpot1 = MR.Inst.GetUnitTarget("533_T1Bar1_BlindTiger_UnitTarget");
		endTargetSpot2 = MR.Inst.GetUnitTarget("C10_T1Bar1_BlindTiger_UnitTarget");
		EndTargetEugene = MR.Inst.GetUnitTarget("7B3_T1Bar1_BlindTiger_UnitTarget");
		EndTargetNoot = MR.Inst.GetUnitTarget("8D7_T1Bar1_BlindTiger_UnitTarget");
		endTargetSpot3 = MR.Inst.GetUnitTarget("36B_T1Cambridge_UnitTarget");
		endTargetSpot4 = MR.Inst.GetUnitTarget("8A9_T1Cambridge_UnitTarget");
		endTargetSpot5 = MR.Inst.GetUnitTarget("EC7_T1Cambridge_UnitTarget");
		margotCambridgeSpot = MR.Inst.GetUnitTarget("550_T1Cambridge_UnitTarget");
		WillaTarget = MR.Inst.GetUnitTarget("409_T1Cambridge_UnitTarget");
		ArchiTarget = MR.Inst.GetUnitTarget("723_T1Cambridge_UnitTarget");
		WillaEntersTrain = MR.Inst.GetUnitTarget("32E_T1Subway_TrainInterior_UnitTarget");
		willaEntersPort1 = MR.Inst.GetUnitTarget("E9C_T1Port1_HaraEntrance_UnitTarget");
		ArchiEntersPort1 = MR.Inst.GetUnitTarget("864_T1Port1_HaraEntrance_UnitTarget");
		ThirdMemEntersPort1 = MR.Inst.GetUnitTarget("84C_T1Port1_HaraEntrance_UnitTarget");
		ThirdMemToCover = MR.Inst.GetUnitTarget("169_T1Port1_HaraEntrance_UnitTarget");
		MuscleToCover = MR.Inst.GetUnitTarget("636_T1Port1_HaraEntrance_UnitTarget");
		TriggerToCover = MR.Inst.GetUnitTarget("6D9_T1Port1_HaraEntrance_UnitTarget");
		willaEntranceTarget = MR.Inst.GetUnitTarget("5A2_T1Port1_HaraEntrance_UnitTarget");
		archiEntranceTarget = MR.Inst.GetUnitTarget("360_T1Port1_HaraEntrance_UnitTarget");
		margotEntersPort1 = MR.Inst.GetUnitTarget("18F_T1Port1_HaraEntrance_UnitTarget");
		margotEntranceTarget = MR.Inst.GetUnitTarget("383_T1Port1_HaraEntrance_UnitTarget");
		T_MargotToBackStage = MR.Inst.GetUnitTarget("B60_T1Bar1_BlindTiger_UnitTarget");
		MargotAfterFight = MR.Inst.GetUnitTarget("239_T1Port1_HaraEntrance_UnitTarget");
		ShipmentOpenCol1 = MR.Inst.GetTileBlockDynamic("B9F_T1Port2_HaraMainBay_TileBlockDynamic");
		ShipmentOpenCol2 = MR.Inst.GetTileBlockDynamic("1DD_T1Port2_HaraMainBay_TileBlockDynamic");
		UnitTarget sfx_margot_glass_smash_port_hara = MR.Inst.GetUnitTarget("5A2_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget sfx_willa_collects_NS380 = MR.Inst.GetUnitTarget("169_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget sfx_willa_delivers_NS380_to_mund = MR.Inst.GetUnitTarget("7B3_T1Bar1_BlindTiger_UnitTarget");
		dialog_searchStart = HAGIS.DialogLoad("Dialogs/A1O2/DialogSearchStart");
		dialog_patron1 = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron1");
		dialog_patron2 = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron2");
		dialog_patron2b = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron2b");
		dialog_patron3 = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron3");
		dialog_bartender = HAGIS.DialogLoad("Dialogs/A1O2/DialogBartender");
		dialog_keepLooking1 = HAGIS.DialogLoad("Dialogs/A1O2/DialogKeepLooking");
		dialog_keepLooking2 = HAGIS.DialogLoad("Dialogs/A1O2/DialogKeepLooking2");
		dialog_margotIntro = HAGIS.DialogLoad("Dialogs/A1O2/DialogMargotIntro");
		dialog_checkingDresser = HAGIS.DialogLoad("Dialogs/A1O2/DialogCheckingDresser");
		dialog_trespass = HAGIS.DialogLoad("Dialogs/A1O2/DialogTrespass");
		dialog_afterFight = HAGIS.DialogLoad("Dialogs/A1O2/DialogAfterFight");
		dialog_afterFight2 = HAGIS.DialogLoad("Dialogs/A1O2/DialogAfterFight2");
		dialog_margotReturns = HAGIS.DialogLoad("Dialogs/A1O2/DialogMargotReturns");
		dialog_eugenesMission = HAGIS.DialogLoad("Dialogs/A1O2/DialogEugenesMission");
		dialog_margotOutside = HAGIS.DialogLoad("Dialogs/A1O2/DialogMargotOutside");
		dialog_stealth = HAGIS.DialogLoad("Dialogs/A1O2/DialogStealth");
		dialog_margotHelps = HAGIS.DialogLoad("Dialogs/A1O2/DialogMargotHelps");
		dialog_gotItem = HAGIS.DialogLoad("Dialogs/A1O2/DialogGotItem");
		dialog_endMission = HAGIS.DialogLoad("Dialogs/A1O2/DialogEndMission");
		dialog_MargotJoins = HAGIS.DialogLoad("Dialogs/A1O2/DialogMargotJoins");
		Dialog_WillaHeard = HAGIS.DialogLoad("Dialogs/A1O2/Dialog_WillaHeard");
		ambient_missionStart = HAGIS.DialogLoad("Dialogs/A1O2/AmbientMissionStart");
		ambient_LuckyIdiot = HAGIS.DialogLoad("Dialogs/A1O2/Ambient_LuckyIdiot");
		ambient_conference = HAGIS.DialogLoad("Dialogs/A1O2/AmbientConference");
		ambient_wait = HAGIS.DialogLoad("Dialogs/A1O2/AmbientWait");
		ambient_dontPester = HAGIS.DialogLoad("Dialogs/A1O2/AmbientDontPester");
		ambient_headBackstage = HAGIS.DialogLoad("Dialogs/A1O2/AmbientHeadBackstage");
		ambient_headBackstage2 = HAGIS.DialogLoad("Dialogs/A1O2/AmbientHeadBackstage2");
		ambient_checkDresser = HAGIS.DialogLoad("Dialogs/A1O2/AmbientCheckDresser");
		ambient_archiResists = HAGIS.DialogLoad("Dialogs/A1O2/AmbientArchiResists");
		ambient_eugeneInsists = HAGIS.DialogLoad("Dialogs/A1O2/AmbientEugeneInsists");
		ambient_margotHelps = HAGIS.DialogLoad("Dialogs/A1O2/AmbientMargotHelps");
		ambient_gotItem = HAGIS.DialogLoad("Dialogs/A1O2/AmbientGotItem");
		Ambient_Eject = HAGIS.DialogLoad("Dialogs/A1O2/Ambient_Eject");
		tutorial_GhostIntro = HAGIS.DialogLoad("Dialogs/A1O2/TutorialDialogs/Tutorial_GhostIntro");
		cambridgeToBar.gameObject.SetActive(value: false);
		barToBackstage.gameObject.SetActive(value: false);
		barToCambridge.gameObject.SetActive(value: false);
		cambridgeToSubway.gameObject.SetActive(value: false);
		entranceToDock.gameObject.SetActive(value: false);
		TalkToMund.gameObject.SetActive(value: false);
		subwayCamToCam.gameObject.SetActive(value: false);
		subwayCamToTrain.gameObject.SetActive(value: false);
		trainToStationCam.gameObject.SetActive(value: false);
		trainToStationPort.gameObject.SetActive(value: false);
		subwayPortToPort.gameObject.SetActive(value: false);
		trainToCam.gameObject.SetActive(value: false);
		SubwayCutsceneTrigger.gameObject.SetActive(value: false);
		margotStageDialog.gameObject.SetActive(value: false);
		margotIntroTrigger.gameObject.SetActive(value: false);
		conferenceDialog.gameObject.SetActive(value: false);
		margotsDesk.gameObject.SetActive(value: false);
		TalkToMargot.gameObject.SetActive(value: false);
		TalkToMargot2.gameObject.SetActive(value: false);
		CantLeaveYet2.gameObject.SetActive(value: false);
		CantLeaveYet.gameObject.SetActive(value: false);
		noot.gameObject.SetActive(value: false);
		eugene.gameObject.SetActive(value: false);
		BackstageMuscle.gameObject.SetActive(value: false);
		BackstageMuscle2.gameObject.SetActive(value: false);
		BackstageMuscle3.gameObject.SetActive(value: false);
		BackstageSolly.gameObject.SetActive(value: false);
		D_TalkToMundAgain.gameObject.SetActive(value: false);
		D_MundInsists.gameObject.SetActive(value: false);
		Fusel1.gameObject.SetActive(value: false);
		Fusel2.gameObject.SetActive(value: false);
		Fusel3.gameObject.SetActive(value: false);
		confrontTrainFusel.gameObject.SetActive(value: false);
		ShipmentOpenCol1.gameObject.SetActive(value: false);
		ShipmentOpenCol2.gameObject.SetActive(value: false);
		TR_LootTriggerCore.gameObject.SetActive(value: false);
		yield return null;
		MusicStop();
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSing");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk");
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		if (thirdMember != null)
		{
			thirdMember.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		}
		cambridgeLogic.CanTeammatesFollow = false;
		CutsceneBegin();
		UnitMoveToTarget(archi, ArchiTarget, null, 2f);
		yield return UnitMoveToTarget(willa, WillaTarget, null, 2f);
		willa.LookAt(archi);
		HAGIS.DialogShow(ambient_missionStart);
		yield return CreateTimeCondition(1f);
		archi.LookAt(willa);
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_missionStart);
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return UnitMoveToTarget(archi, T_BlindTiger);
		yield return UnitTeleportToMapViaEntranceTile(archi, barToCambridge);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoToBarString);
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		if (thirdMember != null)
		{
			thirdMember.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		}
		CutsceneEnd();
		yield return null;
		cambridgeToBar.gameObject.SetActive(value: true);
		cambridgeLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped starting cutscene");
		yield return MapWaitUntilVisible(barLogic.Map);
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		archi.SetTeamType(UnitTeam.Type.NPC);
		barLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped moving to Blind Tiger");
		yield return HAGIS.DialogShow(dialog_searchStart);
		UIObjectives.Inst.CompleteAndSetMainObjective(objAskAroundString);
		margotStageDialog.gameObject.SetActive(value: true);
		HagisLog("Ask around");
		yield return CreateAndCondition(CreateTriggerCondition(dialog_bartender.OnComplete), CreateOrCondition(CreateTriggerCondition(dialog_patron1.OnComplete), CreateTriggerCondition(dialog_patron2b.OnComplete), CreateTriggerCondition(dialog_patron3.OnComplete)));
		HagisLog("We have asked the bartedner and at least one other patron");
		HagisLog("Archi is moving to conference spot");
		margotStageDialog.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(archi, archiConferenceTarget, null, 2f);
		UIObjectives.Inst.CompleteObjective(objAskAroundString);
		HagisLog("Archi has moved to conference spot");
		conferenceDialog.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(ambient_conference);
		margotStageDialog.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(dialog_keepLooking1.OnComplete);
		GC.Inst.CutsceneBegin();
		barLogic.CanTeammatesFollow = false;
		willa.LookAt(margot);
		yield return CreateTimeCondition(1f);
		archi.LookAt(margot);
		yield return HAGIS.DialogShow(dialog_keepLooking2);
		MusicSetProgress(0.1f);
		yield return margot.unitModel.Play("CsTransSingToMartini");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultMartini");
		margot.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultMartiniWalk");
		yield return UnitMoveToTarget(margot, T_MargotStage, null, 2f);
		yield return UnitHide(margot);
		yield return CreateTimeCondition(1f);
		yield return UnitTeleportToMapViaEntranceTile(margot, barToBackstage);
		yield return UnitMoveToTarget(margot, barTarget, null, 2f);
		TalkPatron1.gameObject.SetActive(value: false);
		TalkPatron2.gameObject.SetActive(value: false);
		TalkPatron3.gameObject.SetActive(value: false);
		GC.Inst.CutsceneEnd();
		barLogic.CanTeammatesFollow = true;
		BartenderDialog.gameObject.SetActive(value: false);
		margotStageDialog.gameObject.SetActive(value: false);
		margotIntroTrigger.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped moving to Blind Tiger");
		MusicPlay("event:/music/tracks/diagetic/bt piano");
		yield return CreateTriggerCondition(margotIntroTrigger.OnDialogShow);
		CutsceneBegin();
		barLogic.CanTeammatesFollow = false;
		UnitMoveToUnit(archi, margot, 2f);
		Wait.While(archi.LookAt(margot));
		yield return CreateTriggerCondition(dialog_margotIntro.OnComplete);
		margotIntroTrigger.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		UnitMoveToTarget(margot, EndTargetNoot, null, 2f);
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(margot, T_MargotToBackStage, null, 2f);
		HagisLog("margot went to backstage");
		yield return UnitHide(margot);
		yield return UnitTeleportToMapViaEntranceTile(margot, backstageToBar);
		yield return UnitTeleportToTarget(margot, margotBackstageSpot);
		willa.LookAt(archi);
		HAGIS.DialogShow(ambient_headBackstage);
		yield return UnitPlayAnimation(archi, "DefaultTalk");
		yield return UnitPlayAnimation(willa, "DefaultTalk");
		barToBackstage.gameObject.SetActive(value: true);
		CutsceneEnd();
		archi.SetTeamType(UnitTeam.Type.Player);
		archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		SKIP_POINT("Follow Margot into the back room");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowMargotString);
		barLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped to Backstage");
		yield return CreateOrCondition(MapWaitUntilVisible(backstageLogic.Map), CreateTimeCondition(10f));
		if (!backstageLogic.Map.IsShown)
		{
			HAGIS.DialogShow(ambient_headBackstage2);
			yield return MapWaitUntilVisible(backstageLogic.Map);
		}
		MusicPlay("event:/music/tracks/basic/muffled piano");
		backstageToBar.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(ambient_checkDresser);
		margotsDesk.gameObject.SetActive(value: true);
		conferenceDialog.gameObject.SetActive(value: false);
		UnitMoveToTarget(archi, archiDeskTarget);
		archi.SetTeamType(UnitTeam.Type.NPC);
		UIObjectives.Inst.CompleteAndSetMainObjective(objSnoopAround);
		yield return CreateTriggerCondition(margotsDesk.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objSnoopAround);
		CutsceneBegin();
		backstageToBar.gameObject.SetActive(value: false);
		margotsDesk.gameObject.SetActive(value: false);
		yield return UnitPlayAnimation(willa, "DefaultInteract");
		archi.LookAt(willa);
		yield return HAGIS.DialogShow(dialog_checkingDresser);
		yield return willa.PickupItem(Item.Atlantium_Core.ToMeta());
		yield return CreateTimeCondition(10f);
		willa.LookInDirection(OctDir.UpLeft);
		BackstageMuscle.gameObject.SetActive(value: true);
		UnitMoveToTarget(BackstageMuscle, BackstageMuscleTarget, OctDir.Right);
		BackstageSolly.gameObject.SetActive(value: true);
		UnitMoveToTarget(BackstageSolly, BackstageSollyTarget);
		yield return CreateTimeCondition(1f);
		MusicStop();
		HAGIS.DialogShow(dialog_trespass);
		yield return CreateTimeCondition(1f);
		BackstageSolly.LookAt(willa);
		yield return CreateTimeCondition(2f);
		UnitPlayAnimation(willa, "DefaultLookAround");
		willa.LookAt(archi);
		yield return CreateTimeCondition(2f);
		BackstageSolly.LookAt(BackstageMuscle);
		BackstageMuscle.LookAt(BackstageSolly);
		yield return CreateTimeCondition(2f);
		BackstageSolly.LookAt(willa);
		BackstageMuscle.LookAt(willa);
		yield return CreateTimeCondition(2f);
		if (thirdMember != null)
		{
			HAGIS_A1O2 hAGIS_A1O = this;
			HAGIS_A1O2 hAGIS_A1O2 = this;
			Unit unit = thirdMember;
			UnitTarget thirdBTCover = ThirdBTCover;
			float? speed = thirdMember.charData.movementSpeedInCombat;
			HagletYieldTerm term = hAGIS_A1O2.UnitMoveToTarget(unit, thirdBTCover, null, speed);
			HAGIS_A1O2 hAGIS_A1O3 = this;
			unit = archi;
			thirdBTCover = ArchiBTCover;
			speed = archi.charData.movementSpeedInCombat;
			HagletYieldTerm term2 = hAGIS_A1O3.UnitMoveToTarget(unit, thirdBTCover, null, speed);
			HAGIS_A1O2 hAGIS_A1O4 = this;
			unit = willa;
			thirdBTCover = WillaBTCover;
			speed = willa.charData.movementSpeedInCombat;
			yield return hAGIS_A1O.CreateAndCondition(term, term2, hAGIS_A1O4.UnitMoveToTarget(unit, thirdBTCover, null, speed));
		}
		else
		{
			HAGIS_A1O2 hAGIS_A1O5 = this;
			HAGIS_A1O2 hAGIS_A1O6 = this;
			Unit unit = archi;
			UnitTarget thirdBTCover = ArchiBTCover;
			float? speed = archi.charData.movementSpeedInCombat;
			HagletYieldTerm term3 = hAGIS_A1O6.UnitMoveToTarget(unit, thirdBTCover, null, speed);
			HAGIS_A1O2 hAGIS_A1O7 = this;
			unit = willa;
			thirdBTCover = WillaBTCover;
			speed = willa.charData.movementSpeedInCombat;
			yield return hAGIS_A1O5.CreateAndCondition(term3, hAGIS_A1O7.UnitMoveToTarget(unit, thirdBTCover, null, speed));
		}
		CutsceneEnd();
		archi.SetTeamType(UnitTeam.Type.Player);
		SKIP_POINT("Skipped checking dresser");
		MusicPlay("event:/music/tracks/combat/underclocks");
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return CreateTimeCondition(1f);
		SKIP_POINT("Skipped combat");
		CutsceneBegin();
		MusicStop();
		if (thirdMember != null)
		{
			UnitMoveToTarget(thirdMember, T_ChrisHide, OctDir.Up);
		}
		UnitMoveToTarget(archi, archiCutsceneTarget);
		yield return UnitMoveToTarget(willa, T_WillaHide);
		willa.LookAt(archi);
		archi.LookAt(willa);
		yield return HAGIS.DialogShow(Dialog_WillaHeard);
		CutsceneEnd();
		SKIP_POINT("Skipped dialog after fight");
		yield return CutscenePlay("A1O2_Cutscene_Surrounded");
		SKIP_POINT("Skipped Cutscene_Surrounded");
		yield return CutscenePlay("A1O2_Cutscene_NootBeatsArchi");
		SKIP_POINT("Skipped Cutscene_NootBeatsArchi");
		yield return CutscenePlay("A1O2_Cutscene_MargotStormsOff");
		yield return UnitTeleportToMapViaEntranceTile(margot, cambridgeToSubway, margotCambridgeSpot);
		margot.LookInDirection(OctDir.Down);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoToPortHaraString);
		D_MundInsists.gameObject.SetActive(value: true);
		backstageLogic.CanTeammatesFollow = true;
		backstageToBar.gameObject.SetActive(value: true);
		barToCambridge.gameObject.SetActive(value: true);
		HagletYieldTerm playerLeft = MapWaitUntilMidTransition(barLogic);
		yield return CreateOrCondition(playerLeft, Wait.ForSeconds(60f));
		if (!playerLeft.met && Singleton<MC>.Inst.transitioning)
		{
			yield return MapWaitUntilMidTransition(barLogic);
		}
		else if (!playerLeft.met)
		{
			willa.StopMovement(immediate: true);
			yield return HAGIS.DialogShow(Ambient_Eject);
			UnitTeleportToMapViaEntranceTile(archi, barToBackstage);
			UnitTeleportToMapViaEntranceTile(willa, barToBackstage);
			if (thirdMember != null)
			{
				UnitTeleportToMapViaEntranceTile(thirdMember, barToBackstage);
			}
			MapGoto(barLogic);
			yield return MapWaitUntilMidTransition(barLogic);
		}
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultMartini");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultMartiniWalk");
		barToBackstage.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped back to bar");
		HAGIS.DialogShow(ambient_LuckyIdiot);
		yield return MapWaitUntilVisible(cambridgeLogic.Map);
		MusicStop();
		cambridgeLogic.CanTeammatesFollow = true;
		cambridgeToBar.gameObject.SetActive(value: false);
		TalkToMargot.gameObject.SetActive(value: true);
		CantLeaveYet.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped leaveing the bar");
		yield return CreateTriggerCondition(dialog_margotOutside.OnComplete);
		TalkToMargot.gameObject.SetActive(value: false);
		CantLeaveYet.gameObject.SetActive(value: false);
		cambridgeToSubway.gameObject.SetActive(value: true);
		margot.SetTeamType(UnitTeam.Type.Player);
		yield return UnitPlayAnimation(margot, "CsTransMartiniToDIdlePutAway");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		margot.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/basic/stealth old 1");
		SKIP_POINT("Skipped talking to margot");
		yield return MapWaitUntilMidTransition(SubwayCam);
		PlayMapAnimation(SubwayCam.Map, "MA_SubwayTrain", "Arriving");
		SubwayCam.CanTeammatesFollow = true;
		cambridgeToSubway.gameObject.SetActive(value: false);
		PlayInterplay();
		yield return CreateTimeCondition(5f);
		subwayCamToTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped moving to Subway Cam");
		yield return MapWaitUntilMidTransition(SubwayTrain);
		subwayCamToTrain.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		subwayCamToTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped getting on the Subway Train");
		CutsceneBegin();
		yield return UnitMoveToTarget(willa, WillaEntersTrain, OctDir.UpLeft);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		CutsceneEnd();
		HAGIS.ToggleShakeEnvironment(on: false);
		SubwayTrain.CanTeammatesFollow = true;
		port1Muscle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		port1Trigger.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
		subwayPortToPort.gameObject.SetActive(value: true);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_PortHara_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		yield return CreateTimeCondition(2f);
		trainToStationPort.gameObject.SetActive(value: true);
		yield return MapWaitUntilMidTransition(portEntranceLogic);
		yield return MapWaitUntilVisible(portEntranceLogic.Map);
		yield return null;
		SKIP_POINT("Skipped to Port Hara Entrance");
		CutsceneBegin();
		UnitMoveToTarget(archi, ArchiEntersPort1, OctDir.UpLeft);
		if (thirdMember != null)
		{
			UnitMoveToTarget(thirdMember, ThirdMemEntersPort1, OctDir.UpLeft);
		}
		UnitMoveToTarget(willa, willaEntersPort1, OctDir.UpLeft);
		margot.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitMoveToTarget(margot, margotEntersPort1, OctDir.Up);
		HAGIS.DialogShow(dialog_stealth);
		HagletYieldTerm margotMove = UnitMoveToTarget(margot, margotEntranceTarget, OctDir.Left, 2f);
		HagletYieldTerm stealthDialogComplete = CreateTriggerCondition(dialog_stealth.OnComplete);
		yield return CreateAndCondition(margotMove, stealthDialogComplete);
		yield return UnitPlayAnimation(margot, "CsTransDIdleToMartini");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultMartini");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultMartiniWalk");
		margot.UpdateIdleAnim();
		UnitMoveToTarget(archi, archiEntranceTarget, OctDir.Up);
		if (thirdMember != null)
		{
			UnitMoveToTarget(thirdMember, ThirdMemToCover, OctDir.Up);
		}
		yield return UnitMoveToTarget(willa, willaEntranceTarget, OctDir.Up);
		yield return UnitPlayAnimation(port1Trigger, "TransCCrouchToCIdle");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultMartini");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "DefaultSlowWalk");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultMartini");
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/tucker combat");
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		CutsceneBegin();
		UnitMoveToTarget(port1Trigger, TriggerToCover, OctDir.Down, 4.5f);
		yield return UnitMoveToTarget(port1Muscle, MuscleToCover, OctDir.Down, 2f);
		yield return UnitPlayAnimation(margot, "CsDefaultMartiniDrink");
		margot.UpdateIdleAnim();
		CutsceneEnd();
		SKIP_POINT("Skipped to Port Hara Entrance fight");
		MusicSetIntensity(0.1f);
		UIObjectives.Inst.CompleteAndSetMainObjective(objClearDock);
		yield return CombatWaitUntilComplete();
		UIObjectives.Inst.CompleteObjective(objClearDock);
		SKIP_POINT("Skipped Port Hara Entrance fight");
		MusicStop();
		CutsceneBegin();
		yield return null;
		UnitMoveToTarget(margot, MargotAfterFight, null, 2f);
		margot.LookAt(willa);
		willa.LookAt(margot);
		archi.LookAt(margot);
		yield return HAGIS.DialogShow(dialog_margotHelps);
		yield return UnitMoveToTarget(margot, MargotAfterFight, null, 2f);
		margot.LookInDirection(OctDir.UpLeft);
		yield return CreateTimeCondition(1f);
		margot.LookInDirection(OctDir.Down);
		margot.unitModel.Play("CsTransMartiniToDIdle");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		margot.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		entranceToDock.gameObject.SetActive(value: true);
		portEntToSubwayPort.gameObject.SetActive(value: false);
		margot.SetTeamType(UnitTeam.Type.Player);
		yield return UnitMoveToTarget(margot, entranceToDock);
		margot.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(ambient_margotHelps);
		CutsceneEnd();
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CombatWalk");
		margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		yield return TeamMoveToMapViaEntranceTile(dockToEntrance);
		SKIP_POINT("Skipped to Port Hara fight");
		UIObjectives.Inst.CompleteAndSetMainObjective(objClearDock);
		trainShiner1.gameObject.SetActive(value: false);
		trainShiner2.gameObject.SetActive(value: false);
		shinerVictim.gameObject.SetActive(value: false);
		femalePassenger.gameObject.SetActive(value: false);
		femalePassenger2.gameObject.SetActive(value: false);
		leglessGuy.gameObject.SetActive(value: false);
		confrontTrainShiners.gameObject.SetActive(value: false);
		leglessTrainMan.gameObject.SetActive(value: false);
		Fusel1.gameObject.SetActive(value: true);
		Fusel2.gameObject.SetActive(value: true);
		Fusel3.gameObject.SetActive(value: true);
		confrontTrainFusel.gameObject.SetActive(value: true);
		CombatBegin(UnitTeam.Type.Player);
		CutsceneBegin();
		yield return HAGIS.DialogShow(tutorial_GhostIntro);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/tucker combat");
		MusicSetIntensity(0.1f);
		yield return CombatWaitUntilComplete();
		yield return null;
		CutsceneBegin();
		MusicStop();
		willa.LookAt(margot);
		archi.LookAt(margot);
		yield return HAGIS.DialogShow(dialog_gotItem);
		CutsceneEnd();
		yield return null;
		GC.Inst.GetTeamOfType(UnitTeam.Type.Player).MoveTeamToDefaultPositions();
		portLogic.CanTeammatesFollow = true;
		UIObjectives.Inst.CompleteAndSetMainObjective(objSearchForThingString);
		dockToEntrance.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped Port Hara fight");
		yield return CreateTriggerCondition(secretThing.OnTriggered);
		CutsceneBegin();
		ShipmentOpenCol1.gameObject.SetActive(value: true);
		ShipmentOpenCol2.gameObject.SetActive(value: true);
		yield return UnitPlayAnimation(willa, "DefaultInteract", loop: false, updateIdle: true);
		SFXPlayAtCoord("event:/sfx/doors/bt cellar door keycard", sfx_willa_collects_NS380);
		yield return PlayMapAnimation(portLogic.Map, "CH_Port_AugmentCrate", "DefaultOpen");
		yield return UnitPlayAnimation(willa, "DefaultInteract", loop: false, updateIdle: true);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/pick up augment", sfx_willa_collects_NS380);
		PlayMapAnimation(portLogic.Map, "CH_Port_AugmentCrate", "DefaultEmpty");
		yield return HAGIS.DialogShow(ambient_gotItem);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturnToMundString);
		yield return CreateTimeCondition(1f);
		TR_LootTriggerCore.gameObject.SetActive(value: true);
		portEntToSubwayPort.gameObject.SetActive(value: true);
		dockToEntrance.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped collecting shippment");
		yield return MapWaitUntilVisible(portEntranceLogic.Map);
		entranceToDock.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(2f);
		PlayInterplay();
		portEntToSubwayPort.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped to Hara Entrance again");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Close");
		yield return MapWaitUntilMidTransition(SubwayTrain);
		HAGIS.ToggleShakeEnvironment(on: true);
		subwayPortToPort.gameObject.SetActive(value: false);
		trainToStationPort.gameObject.SetActive(value: false);
		MusicStop();
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		SKIP_POINT("Skipped to Subway train");
		CutsceneBegin();
		yield return UnitMoveToTarget(willa, WillaEntersTrain, OctDir.UpLeft);
		yield return PlayInterplay();
		cambridgeToBar.gameObject.SetActive(value: true);
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		yield return null;
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Cambridge_L0");
		yield return PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		SubwayCutsceneTrigger.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(SubwayCutsceneTrigger.OnTriggered);
		yield return CutscenePlay("A1O2_Cutscene_MargotSwapsAug");
		WonderingBarDroid.gameObject.SetActive(value: false);
		cambridgeLogic.CanTeammatesFollow = true;
		yield return MapGoto(cambridgeLogic);
		SKIP_POINT("Skipped moving to Cambridge");
		barLogic.CanTeammatesFollow = false;
		SKIP_POINT("cutscene at the blind tiger");
		TalkToMund.gameObject.SetActive(value: true);
		UnitTeleportToMapViaEntranceTile(eugene, barToBackstage, EndTargetEugene);
		UnitTeleportToMapViaEntranceTile(noot, barToBackstage, EndTargetNoot);
		yield return MapWaitUntilVisible(barLogic.Map);
		MusicPlay("event:/music/tracks/diagetic/bt piano");
		yield return CreateTriggerCondition(TalkToMund.OnTriggered);
		CutsceneBegin();
		MusicPlay("event:/music/tracks/basic/mund theme");
		eugene.LookAt(willa);
		noot.LookAt(willa);
		margot.LookAt(eugene);
		yield return CreateTimeCondition(1f);
		willa.unitModel.Play("DefaultGiveItem", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/show augment", sfx_willa_delivers_NS380_to_mund);
		eugene.unitModel.Play("DefaultReceiveItem", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return UnitMoveToUnit(margot, eugene);
		margot.LookAt(eugene);
		yield return HAGIS.DialogShow(dialog_endMission);
		margot.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitMoveToMapViaExitTile(margot, barToCambridge, margotCambridgeSpot);
		TalkToMargot2.gameObject.SetActive(value: true);
		CutsceneEnd();
		D_TalkToMundAgain.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objLeaveTheBlindTiger);
		SKIP_POINT("Skipped cutscene at the blind tiger");
		yield return MapWaitUntilVisible(cambridgeLogic.Map);
		cambridgeToBar.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objLeaveTheBlindTiger);
		MusicPlay("event:/music/tracks/basic/thoughtful music");
		SKIP_POINT("Skipped moving to cam again");
		TalkToMargot2.gameObject.SetActive(value: true);
		CantLeaveYet2.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(dialog_MargotJoins.OnComplete);
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_A1O2_Patron2 : HAGIS
{
	private Unit patron;

	private TileActionDialog patron2Dialog;

	private DialogData dialog_patron2;

	private DialogData dialog_patron2b;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		patron = GC.Inst.GetUnitWithId("F72_T1Bar1_BlindTiger_UnitSpawn");
		dialog_patron2 = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron2");
		dialog_patron2b = HAGIS.DialogLoad("Dialogs/A1O2/DialogPatron2b");
		patron2Dialog = MR.Inst.GetTileActionDialog("70F_T1Bar1_BlindTiger_TileActionDialog");
		yield return null;
		yield return CreateTriggerCondition(dialog_patron2.OnComplete);
		patron2Dialog.gameObject.SetActive(value: false);
		yield return CutscenePlay("A1O2_Cutscene_PatronFlees");
		patron.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A1O2_TableDecalAnim : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		KubrickAnimator tableAnimator = GetComponent<KubrickAnimator>();
		yield return null;
		while (true)
		{
			tableAnimator.Play("Idle");
			tableAnimator.SetTime(UnityEngine.Random.Range(0.5f, 2.5f));
			yield return Wait.ForSeconds(UnityEngine.Random.Range(30f, 60f));
			yield return tableAnimator.Play("OnOff");
			tableAnimator.Play("Off");
			yield return Wait.ForSeconds(UnityEngine.Random.Range(30f, 60f));
			yield return tableAnimator.Play("OffOn");
		}
	}
}
public class HAGIS_A1O3 : HAGIS
{
	private Unit Archi;

	private Unit Willa;

	private Unit Ambrosia;

	private Unit ThirdMember;

	private Unit Compiler1;

	private Unit Compiler2;

	private Unit Holden;

	private Unit Civ1;

	private Unit Civ3;

	private Unit Civ4;

	private Unit Civ5;

	private UnitTarget CompilerCover1;

	private UnitTarget CompilerCover2;

	private UnitTarget CompilerCover3;

	private UnitTarget TargetWilla;

	private UnitTarget TargetGraveEnterWilla;

	private UnitTarget TargetArchi;

	private UnitTarget TargetArchi1;

	private UnitTarget TargetArchiToBridge;

	private UnitTarget TargetHolden;

	private UnitTarget ArchiEnters;

	private UnitTarget ThirdMemeberEnters;

	private UnitTarget WillaToGraveCover;

	private UnitTarget ArchiToGraveCover;

	private UnitTarget ArchiReturnsToPark;

	private UnitTarget WillaReturnsToPark;

	private UnitTarget ThirdMemberReturns;

	private DialogData ambient_ThatSmell;

	private DialogData ambient_WillaPunks;

	private DialogData dialog_AmbrosiaEarnIt;

	private DialogData dialog_AmbrosiaTheScrag;

	private DialogData dialog_ArchiHoldUp;

	private DialogData dialog_ArchiSheLooksWise;

	private DialogData dialog_ArchiSpooky;

	private DialogData dialog_HoldenHoldEmUp;

	private DialogData dialog_WillaATalkInThePark;

	private DialogData dialog_WillaDeadBeforeIWasBorn;

	private TileActionSwapMap ToThePark;

	private TileActionSwapMap ParkToGrave;

	private TileActionSwapMap ParkToSubway;

	private TileActionSwapMap GraveToPark;

	private TileActionDialog CompilerGraffiti;

	private TileActionDialog TalkToArchi;

	private TileActionDialog TalkToArchi1;

	private TileActionDialog TalkToArchiOnBridge;

	private TileActionInteraction CrazyLadyConvo;

	private TileActionHotspot Tomb;

	private TileActionHotspot Grave1;

	private TileActionHotspot Grave2;

	private TileActionHotspot Grave3;

	private TileActionHotspot ScragGrave;

	private string objFindTheScragString = "OBJECTIVES_A1O3_01";

	private string objHeadToTheGraveYard = "OBJECTIVES_A1O3_02";

	private string objRemoveFoulPresenceString = "OBJECTIVES_A1O3_03";

	private string objExploreGraveyardString = "OBJECTIVES_A1O3_04";

	private string objReturnToTheOldWoman = "OBJECTIVES_A1O3_05";

	private string objReportToOldLadyString = "OBJECTIVES_A1O3_06";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot parkLogic = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot graveLogic = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot SubwayStationLogic = GetLogicUsingArtName("T1Subway_Station_Files");
		Archi = GC.Inst.GetUnitWithId("C5B_T1DetritumPark_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("8B5_T1DetritumPark_UnitSpawn");
		ThirdMember = GC.Inst.TryGetUnitWithId("EBF_T1Subway_Station_Files_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("EF6_T1DetritumPark_UnitSpawn");
		Holden = GC.Inst.GetUnitWithId("1DB_T1DetritumGraveyard_UnitSpawn");
		Compiler1 = GC.Inst.GetUnitWithId("27C_T1DetritumGraveyard_UnitSpawn");
		Compiler2 = GC.Inst.GetUnitWithId("6A0_T1DetritumGraveyard_UnitSpawn");
		Civ1 = GC.Inst.GetUnitWithId("9DB_T1DetritumPark_UnitSpawn");
		Civ3 = GC.Inst.GetUnitWithId("884_T1DetritumPark_UnitSpawn");
		Civ4 = GC.Inst.GetUnitWithId("929_T1DetritumPark_UnitSpawn");
		Civ5 = GC.Inst.GetUnitWithId("C3F_T1DetritumPark_UnitSpawn");
		ToThePark = MR.Inst.GetTileActionSwapMap("3DB_T1Subway_Station_TileActionSwapMap");
		ParkToGrave = MR.Inst.GetTileActionSwapMap("766_T1DetritumPark_TileActionSwapMap");
		ParkToSubway = MR.Inst.GetTileActionSwapMap("391_T1DetritumPark_TileActionSwapMap");
		GraveToPark = MR.Inst.GetTileActionSwapMap("9D8_T1DetritumGraveyard_TileActionSwapMap");
		CompilerGraffiti = MR.Inst.GetTileActionDialog("594_T1Subway_Station_TileActionDialog");
		TalkToArchi = MR.Inst.GetTileActionDialog("159_T1DetritumPark_TileActionDialog");
		TalkToArchi1 = MR.Inst.GetTileActionDialog("149_T1DetritumGraveyard_TileActionDialog");
		TalkToArchiOnBridge = MR.Inst.GetTileActionDialog("CC7_T1DetritumPark_TileActionDialog");
		CrazyLadyConvo = MR.Inst.GetTileActionInteraction("B3A_T1DetritumPark_TileActionInteraction");
		Tomb = MR.Inst.GetTileActionHotspot("59B_T1DetritumGraveyard_TileActionHotspot");
		Grave1 = MR.Inst.GetTileActionHotspot("63E_T1DetritumGraveyard_TileActionHotspot");
		Grave2 = MR.Inst.GetTileActionHotspot("809_T1DetritumGraveyard_TileActionHotspot");
		Grave3 = MR.Inst.GetTileActionHotspot("B04_T1DetritumGraveyard_TileActionHotspot");
		ScragGrave = MR.Inst.GetTileActionHotspot("EE3_T1DetritumGraveyard_TileActionHotspot");
		CompilerCover1 = MR.Inst.GetUnitTarget("17F_T1DetritumGraveyard_UnitTarget");
		CompilerCover2 = MR.Inst.GetUnitTarget("C46_T1DetritumGraveyard_UnitTarget");
		CompilerCover3 = MR.Inst.GetUnitTarget("AE5_T1DetritumGraveyard_UnitTarget");
		TargetWilla = MR.Inst.GetUnitTarget("E1A_T1DetritumPark_UnitTarget");
		TargetGraveEnterWilla = MR.Inst.GetUnitTarget("78D_T1DetritumGraveyard_UnitTarget");
		TargetArchi = MR.Inst.GetUnitTarget("711_T1DetritumPark_UnitTarget");
		TargetArchi1 = MR.Inst.GetUnitTarget("C1E_T1DetritumGraveyard_UnitTarget");
		TargetArchiToBridge = MR.Inst.GetUnitTarget("7B0_T1DetritumPark_UnitTarget");
		TargetHolden = MR.Inst.GetUnitTarget("169_T1DetritumGraveyard_UnitTarget");
		WillaToGraveCover = MR.Inst.GetUnitTarget("E7F_T1DetritumGraveyard_UnitTarget");
		ArchiToGraveCover = MR.Inst.GetUnitTarget("DC3_T1DetritumGraveyard_UnitTarget");
		ArchiReturnsToPark = MR.Inst.GetUnitTarget("E9D_T1DetritumPark_UnitTarget");
		WillaReturnsToPark = MR.Inst.GetUnitTarget("502_T1DetritumPark_UnitTarget");
		ArchiEnters = MR.Inst.GetUnitTarget("79B_T1DetritumGraveyard_UnitTarget");
		ThirdMemeberEnters = MR.Inst.GetUnitTarget("680_T1DetritumGraveyard_UnitTarget");
		ThirdMemberReturns = MR.Inst.GetUnitTarget("80F_T1DetritumPark_UnitTarget");
		ambient_WillaPunks = HAGIS.DialogLoad("Dialogs/A1O3/AmbientWillaPunks");
		ambient_ThatSmell = HAGIS.DialogLoad("Dialogs/A1O3/Ambient_ThatSmell");
		dialog_HoldenHoldEmUp = HAGIS.DialogLoad("Dialogs/A1O3/DialogHoldenHoldEmUp");
		dialog_WillaATalkInThePark = HAGIS.DialogLoad("Dialogs/A1O3/DialogWillaATalkInThePark");
		dialog_WillaDeadBeforeIWasBorn = HAGIS.DialogLoad("Dialogs/A1O3/DialogWillaDeadBeforeIWasBorn");
		dialog_ArchiHoldUp = HAGIS.DialogLoad("Dialogs/A1O3/DialogArchiHoldUp");
		dialog_ArchiSheLooksWise = HAGIS.DialogLoad("Dialogs/A1O3/DialogArchiSheLooksWise");
		dialog_ArchiSpooky = HAGIS.DialogLoad("Dialogs/A1O3/DialogArchiSpooky");
		dialog_AmbrosiaTheScrag = HAGIS.DialogLoad("Dialogs/A1O3/DialogAmbrosiaTheScrag");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("515_T1DetritumGraveyard_TileBlockDynamic");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindTheScragString);
		TalkToArchi1.gameObject.SetActive(value: false);
		TalkToArchiOnBridge.gameObject.SetActive(value: false);
		TalkToArchi.gameObject.SetActive(value: false);
		Grave1.gameObject.SetActive(value: false);
		Grave2.gameObject.SetActive(value: false);
		Grave3.gameObject.SetActive(value: false);
		ScragGrave.gameObject.SetActive(value: false);
		Tomb.gameObject.SetActive(value: false);
		ParkToGrave.gameObject.SetActive(value: false);
		yield return null;
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		MusicPlay("event:/music/tracks/basic/lights out full");
		yield return null;
		yield return CreateTimeCondition(1f);
		PlayInterplay();
		yield return MapWaitUntilVisible(parkLogic.Map);
		CutsceneBegin();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		yield return null;
		UnitMoveToTarget(Archi, TargetArchi, OctDir.Left, 2f);
		yield return UnitMoveToTarget(Willa, TargetWilla, OctDir.Left, 2f);
		HAGIS.DialogShow(ambient_ThatSmell);
		TalkToArchi.gameObject.SetActive(value: true);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		CutsceneEnd();
		parkLogic.CanTeammatesFollow = true;
		ParkToSubway.gameObject.SetActive(value: false);
		ParkToGrave.gameObject.SetActive(value: false);
		SKIP_POINT("Cutscene in the park completed. Waiting for player to talk with Ambrosia.");
		yield return CreateTriggerCondition(CrazyLadyConvo.OnTriggered);
		UnitMoveToTarget(Archi, TargetArchiToBridge);
		yield return HAGIS.DialogShow(dialog_WillaATalkInThePark);
		CutsceneBegin();
		parkLogic.CanTeammatesFollow = false;
		yield return UnitPlayAnimation(Ambrosia, "CsTransSitToDIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		TalkToArchi.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(dialog_AmbrosiaTheScrag);
		yield return CreateTimeCondition(1f);
		Archi.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadToTheGraveYard);
		MusicStop();
		SKIP_POINT("Finished chatting to Ambro, waiting to enter Graveyard");
		TalkToArchiOnBridge.gameObject.SetActive(value: true);
		ParkToGrave.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(graveLogic.Map);
		CutsceneBegin();
		UnitMoveToTarget(Archi, ArchiEnters, OctDir.Up);
		if (ThirdMember != null)
		{
			UnitMoveToTarget(ThirdMember, ThirdMemeberEnters, OctDir.UpRight, null, optionalUnit: true);
		}
		MusicPlay("event:/music/tracks/basic/compilers intro");
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(Willa, TargetGraveEnterWilla);
		Willa.LookInDirection(OctDir.Up);
		Archi.SetTeamType(UnitTeam.Type.Player);
		TalkToArchiOnBridge.gameObject.SetActive(value: false);
		GraveToPark.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objRemoveFoulPresenceString);
		Compiler1.LookAt(Archi);
		Compiler2.LookAt(Willa);
		HagisLog("Holden moving");
		yield return UnitMoveToTarget(Holden, TargetHolden, OctDir.DownLeft);
		Willa.LookAt(Holden);
		yield return HAGIS.DialogShow(dialog_HoldenHoldEmUp);
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Player meets holden. Player must fight them!");
		MusicPlay("event:/music/tracks/basic/compilers main");
		CombatBegin(UnitTeam.Type.Enemy);
		UnitMoveToTarget(Compiler1, CompilerCover1);
		UnitMoveToTarget(Compiler2, CompilerCover2);
		UnitMoveToTarget(Willa, WillaToGraveCover);
		UnitMoveToTarget(Archi, ArchiToGraveCover);
		yield return UnitMoveToTarget(Holden, CompilerCover3);
		yield return CombatWaitUntilComplete();
		MusicPlay("event:/music/tracks/basic/new savannah ex light");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_WillaPunks);
		yield return CreateTriggerCondition(ambient_WillaPunks.OnComplete);
		Grave1.gameObject.SetActive(value: true);
		Grave2.gameObject.SetActive(value: true);
		Grave3.gameObject.SetActive(value: true);
		ScragGrave.gameObject.SetActive(value: true);
		Tomb.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objExploreGraveyardString);
		yield return UnitMoveToTarget(Archi, TargetArchi1);
		Archi.LookInDirection(OctDir.UpLeft);
		TalkToArchi1.gameObject.SetActive(value: true);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		graveLogic.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(ScragGrave.OnHotspotComplete);
		HAGIS.DialogShow(dialog_WillaDeadBeforeIWasBorn);
		yield return CreateTriggerCondition(dialog_WillaDeadBeforeIWasBorn.OnComplete);
		Archi.LookInDirection(OctDir.DownLeft);
		yield return UnitMoveToTarget(Archi, TargetGraveEnterWilla);
		Archi.LookInDirection(OctDir.Down);
		ScragGrave.gameObject.SetActive(value: false);
		Ambrosia.gameObject.SetActive(value: false);
		CrazyLadyConvo.gameObject.SetActive(value: false);
		SKIP_POINT("Player talked to Archie by the grave. Player must speak with Ambrosia.");
		yield return null;
		Archi.SetTeamType(UnitTeam.Type.Player);
		GraveToPark.gameObject.SetActive(value: true);
		ParkToSubway.gameObject.SetActive(value: true);
		TalkToArchi1.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturnToTheOldWoman);
		Civ1.gameObject.SetActive(value: false);
		Civ3.gameObject.SetActive(value: false);
		Civ4.gameObject.SetActive(value: false);
		Civ5.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(parkLogic.Map);
		UnitMoveToTarget(Archi, ArchiReturnsToPark, OctDir.Down);
		if (ThirdMember != null)
		{
			UnitMoveToTarget(ThirdMember, ThirdMemberReturns, null, null, optionalUnit: true);
		}
		MusicStop();
		CutsceneBegin();
		UIObjectives.Inst.CompleteObjective(objReturnToTheOldWoman);
		UnitMoveToTarget(Willa, WillaReturnsToPark);
		ParkToSubway.gameObject.SetActive(value: false);
		ParkToGrave.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(3f);
		Archi.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_ArchiSpooky);
		CutsceneEnd();
	}
}
public class HAGIS_A1O3_Ambrosia : HAGIS
{
	private Unit Ambrosia;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Ambrosia = GC.Inst.GetUnitWithId("EF6_T1DetritumPark_UnitSpawn");
		yield return null;
	}
}
public class HAGIS_A1O3_CrowAnimations : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Unit GraveCrow = GC.Inst.GetUnitWithId("B83_T1DetritumGraveyard_UnitSpawn");
		Unit GraveCrow2 = GC.Inst.GetUnitWithId("7FB_T1DetritumGraveyard_UnitSpawn");
		GraveCrow.unitModel.HACK_BirdMode = true;
		GraveCrow2.unitModel.HACK_BirdMode = true;
		TileTrigger TT_ACTIVITEBIRDS = MR.Inst.GetTileTrigger("C1C_T1DetritumGraveyard_TileTrigger");
		LogicRoot GraveYard = GetLogicUsingArtName("T1DetritumGraveyard");
		yield return null;
		yield return TT_ACTIVITEBIRDS._OnTriggered;
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(GraveCrow, "DefaultTakeOff");
		GraveCrow.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultTakeOff");
		yield return CreateTimeCondition(3.5f);
		GraveCrow.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		GraveCrow.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		GraveCrow.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		yield return CreateTimeCondition(0.5f);
		UnitPlayAnimation(GraveCrow2, "DefaultTakeOff");
		GraveCrow2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultTakeOff");
		yield return CreateTimeCondition(5f);
		GraveCrow2.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		GraveCrow2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		GraveCrow2.unitModel.Play(UnitModel.AnimID.DefaultIdle);
	}
}
public class HAGIS_A1O4 : HAGIS
{
	[HideInInspector]
	public Unit chosenChar;

	[HideInInspector]
	public Unit willa;

	[HideInInspector]
	public Unit compiler1;

	[HideInInspector]
	public Unit compiler2;

	[HideInInspector]
	public Unit chris;

	[HideInInspector]
	public Unit molly;

	[HideInInspector]
	public Unit turret;

	[HideInInspector]
	public Unit turret2;

	[HideInInspector]
	public Unit SecurityDroid1;

	[HideInInspector]
	public Unit SecurityDroid2;

	[HideInInspector]
	public Unit SecurityDroid3;

	[HideInInspector]
	public Unit SecurityDroid4;

	[HideInInspector]
	public Unit WatchingDroidBottom;

	[HideInInspector]
	public Unit WatchingDroidTop;

	[HideInInspector]
	public Unit droidAttendant1;

	[HideInInspector]
	public Unit droidAttendant2;

	[HideInInspector]
	public Unit TF_Compiler1;

	[HideInInspector]
	public Unit TF_Compiler2;

	[HideInInspector]
	public Unit TF_Compiler3;

	[HideInInspector]
	public Unit TF_Compiler1Fight;

	[HideInInspector]
	public Unit TF_Compiler2Fight;

	[HideInInspector]
	public Unit TF_Compiler3Fight;

	[HideInInspector]
	public Unit filesCiv1;

	[HideInInspector]
	public Unit filesCiv2;

	[HideInInspector]
	public Unit filesCiv3;

	[HideInInspector]
	public Unit filesCiv4;

	[HideInInspector]
	public Unit filesCiv5;

	[HideInInspector]
	public Unit trainNpc1;

	[HideInInspector]
	public Unit trainNpc2;

	[HideInInspector]
	public Unit trainNpc3;

	[HideInInspector]
	public Unit trainNpc4;

	[HideInInspector]
	public Unit trainNpc6;

	[HideInInspector]
	public Unit trainNpc7;

	[HideInInspector]
	public Unit DERYK;

	[HideInInspector]
	public UnitTarget willaToDesk;

	[HideInInspector]
	public UnitTarget chosenCharToDesk;

	[HideInInspector]
	public UnitTarget mollyToDesk;

	[HideInInspector]
	public UnitTarget mollyToMeeting;

	[HideInInspector]
	public UnitTarget chosenCharToMeeting;

	[HideInInspector]
	public UnitTarget willaToMeeting;

	[HideInInspector]
	public UnitTarget willaInStation;

	[HideInInspector]
	public UnitTarget willaOnTrain;

	[HideInInspector]
	public UnitTarget chrisToTerminal1;

	[HideInInspector]
	public UnitTarget chrisToTerminal2;

	[HideInInspector]
	public UnitTarget T_WillaMoveForChris;

	[HideInInspector]
	public UnitTarget T_WillaCover;

	[HideInInspector]
	public UnitTarget T_TeamCover;

	[HideInInspector]
	public UnitTarget T_EnemyCover1;

	[HideInInspector]
	public UnitTarget T_EnemyCover2;

	[HideInInspector]
	public UnitTarget T_EnemyCover3;

	[HideInInspector]
	public UnitTarget T_EnemyCover4;

	[HideInInspector]
	public UnitTarget chosenCharToTable;

	[HideInInspector]
	public UnitTarget Droid1Ready;

	[HideInInspector]
	public UnitTarget Droid2Ready;

	[HideInInspector]
	public UnitTarget Droid3Ready;

	[HideInInspector]
	public UnitTarget Droid4Ready;

	[HideInInspector]
	public UnitTarget ChrisReady;

	[HideInInspector]
	public UnitTarget ChosenCharReady;

	[HideInInspector]
	public UnitTarget willaToCover;

	[HideInInspector]
	public UnitTarget FilesFightCover1;

	[HideInInspector]
	public UnitTarget FilesFightCover2;

	[HideInInspector]
	public UnitTarget FilesFightCover3;

	[HideInInspector]
	public UnitTarget T_ChosenChar_BR;

	[HideInInspector]
	public UnitTarget mollyTeleportPointTEMP;

	[HideInInspector]
	public DialogData ambient_Attendant1;

	[HideInInspector]
	public DialogData ambient_Attendant2;

	[HideInInspector]
	public DialogData ambient_Attendant3;

	[HideInInspector]
	public DialogData ambient_Attendant4;

	[HideInInspector]
	public DialogData ambient_GotAnyAugs1;

	[HideInInspector]
	public DialogData ambient_GotAnyAugs2;

	[HideInInspector]
	public DialogData ambient_GotAnyAugs3;

	[HideInInspector]
	public DialogData ambient_UnauthorisedAccess;

	[HideInInspector]
	public DialogData ambient_Swarm;

	[HideInInspector]
	public DialogData ambient_HowMany;

	[HideInInspector]
	public DialogData ambient_Locked;

	[HideInInspector]
	public DialogData ambeint_BackToMollys;

	[HideInInspector]
	public DialogData ambeint_KeepLookOut;

	[HideInInspector]
	public DialogData ambient_BoxHead;

	[HideInInspector]
	public DialogData dialog_AreYouMercs1;

	[HideInInspector]
	public DialogData dialog_AreYouMercs2;

	[HideInInspector]
	public DialogData dialog_AreYouMercs3;

	[HideInInspector]
	public DialogData dialog_AreYouMolly;

	[HideInInspector]
	public DialogData dialog_BeYourself;

	[HideInInspector]
	public DialogData dialog_ChrisDoneJob;

	[HideInInspector]
	public DialogData dialog_ChrisDidntHack;

	[HideInInspector]
	public DialogData dialog_ChrisGetsMolly;

	[HideInInspector]
	public DialogData dialog_ChrisWelcomes;

	[HideInInspector]
	public DialogData dialog_ImAfterAProgrammer;

	[HideInInspector]
	public DialogData dialog_MollyDeal;

	[HideInInspector]
	public DialogData dialog_MollyImpressed;

	[HideInInspector]
	public DialogData dialog_MollyIntro;

	[HideInInspector]
	public DialogData dialog_MollyLaugh;

	[HideInInspector]
	public DialogData dialog_WillaOhNo;

	[HideInInspector]
	public DialogData dialog_GotSomething;

	[HideInInspector]
	public DialogData dialog_ChrisWoah;

	[HideInInspector]
	public DialogData dialog_LetsRock;

	[HideInInspector]
	public DialogData dialog_ChrisWait;

	[HideInInspector]
	public DialogData dialog_SlowDown;

	[HideInInspector]
	public DialogData dialog_DidThatOnPurpose;

	[HideInInspector]
	public DialogData dialog_WhatAmIDoing;

	[HideInInspector]
	public DialogData dialog_LetsMove;

	[HideInInspector]
	public DialogData dialog_Punks;

	[HideInInspector]
	public DialogData dialog_DontBeAStranger;

	[HideInInspector]
	public DialogData tutorial_ProgrammerIntro;

	[HideInInspector]
	public TileTrigger ExitCamWithChris;

	[HideInInspector]
	public TileActionSwapMap filesToFilesSubway;

	[HideInInspector]
	public TileActionSwapMap filesSubwayToFiles;

	[HideInInspector]
	public TileActionSwapMap filesSubwayToTrain;

	[HideInInspector]
	public TileActionSwapMap trainToFilesSubway;

	[HideInInspector]
	public TileActionSwapMap trainToCam;

	[HideInInspector]
	public TileActionSwapMap CamToTrain;

	[HideInInspector]
	public TileActionSwapMap trainToFiles;

	[HideInInspector]
	public TileActionSwapMap FilesToTrain;

	[HideInInspector]
	public TileActionSwapMap filesToAndroidServicing;

	[HideInInspector]
	public TileActionSwapMap BackRoomToVita;

	[HideInInspector]
	public TileActionSwapMap AndroidServicingToFiles;

	[HideInInspector]
	public TileActionSwapMap ToVitaBackRoom;

	[HideInInspector]
	public TileActionSwapMap CamToVita;

	[HideInInspector]
	public TileActionSwapMap VitaSoftToCam;

	private TileActionDialog D_ILikeYourShop;

	private TileActionDialog D_BoxOfAugs;

	private TileActionDialog D_BoxHead;

	private TileActionDialog D_WhatAmIDoing;

	private TileActionDialog D_FilesHouse;

	private TileActionDialog D_FilesGang;

	private TileActionDialog D_FilesNpcCouple;

	private TileActionDialog D_TrainMuscleNPC;

	private TileActionDialog AmbientAttendant1;

	private TileActionDialog AmbientAttendant2;

	private TileActionDialog AmbientAttendant3;

	private TileActionDialog AmbientAttendant4;

	private TileActionDialog ArmAugment;

	private TileActionDialog AugmentCore;

	private TileActionDialog LarynxAugment;

	private TileActionDialog LegAugment;

	private TileActionDialog TalkToValerie;

	private TileActionDialog D_TrainNPC6;

	private TileActionInteraction terminal;

	private TileActionInteraction I_ToBackRoom;

	private TileActionInteraction TalkToChris;

	private string objRocketScienceString = "OBJECTIVES_A1O4_01";

	private string objSpeakToMolly = "OBJECTIVES_A1O4_02";

	private string objSpeakToChris = "OBJECTIVES_A1O4_03";

	private string objHeadToDeusoftInCambridge = "OBJECTIVES_A1O4_04";

	private string objEnterTheStockRoom = "OBJECTIVES_A1O4_05";

	private string objSubdueSecurity = "OBJECTIVES_A1O4_06";

	private string objDistractSecurity = "OBJECTIVES_A1O4_07";

	private string objReturnToMolly = "OBJECTIVES_A1O4_08";

	private string objDefeatHolden = "OBJECTIVES_A1O4_09";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot filesLogic = GetLogicByName("A1O4_T1TheFiles");
		LogicRoot androidServicingLogic = GetLogicByName("A1O4_T1AndroidServicing");
		LogicRoot camLogic = GetLogicByName("A1O4_T1Cambridge");
		LogicRoot vitaLogic = GetLogicByName("A1O4_T1VitaSoft");
		LogicRoot VitaSoftBackRoomLogic = GetLogicByName("A1O4_T1VitaSoftBackRoom");
		LogicRoot SubwayStationLogic = GetLogicByName("A1O4_T1Subway_Station");
		LogicRoot SubwayTrainLogic = GetLogicByName("A1O4_T1Subway_TrainInterior");
		chosenChar = GC.Inst.GetUnitWithId("12A_T1TheFiles_UnitSpawn");
		willa = GC.Inst.GetUnitWithId("02E_T1TheFiles_UnitSpawn");
		chris = GC.Inst.GetUnitWithId("94F_T1AndroidServicing_UnitSpawn");
		chris.AddInitialPartyAbilities();
		molly = GC.Inst.GetUnitWithId("772_T1AndroidServicing_UnitSpawn");
		turret = GC.Inst.GetUnitWithId("693_T1VitaSoftBackRoom_UnitSpawn");
		turret2 = GC.Inst.GetUnitWithId("15D_T1VitaSoftBackRoom_UnitSpawn");
		SecurityDroid1 = GC.Inst.GetUnitWithId("BB6_T1VitaSoftBackRoom_UnitSpawn");
		SecurityDroid2 = GC.Inst.GetUnitWithId("A6F_T1VitaSoftBackRoom_UnitSpawn");
		SecurityDroid3 = GC.Inst.GetUnitWithId("48F_T1VitaSoftBackRoom_UnitSpawn");
		SecurityDroid4 = GC.Inst.GetUnitWithId("205_T1VitaSoftBackRoom_UnitSpawn");
		WatchingDroidBottom = GC.Inst.GetUnitWithId("F1F_T1VitaSoft_UnitSpawn");
		WatchingDroidTop = GC.Inst.GetUnitWithId("C40_T1VitaSoft_UnitSpawn");
		droidAttendant1 = GC.Inst.GetUnitWithId("3FD_T1VitaSoft_UnitSpawn");
		droidAttendant2 = GC.Inst.GetUnitWithId("5C4_T1VitaSoft_UnitSpawn");
		TF_Compiler1 = GC.Inst.GetUnitWithId("185_T1TheFiles_UnitSpawn");
		TF_Compiler2 = GC.Inst.GetUnitWithId("957_T1TheFiles_UnitSpawn");
		TF_Compiler3 = GC.Inst.GetUnitWithId("AE4_T1TheFiles_UnitSpawn");
		TF_Compiler1Fight = GC.Inst.GetUnitWithId("1EF_T1TheFiles_UnitSpawn");
		TF_Compiler2Fight = GC.Inst.GetUnitWithId("AAB_T1TheFiles_UnitSpawn");
		TF_Compiler3Fight = GC.Inst.GetUnitWithId("032_T1TheFiles_UnitSpawn");
		filesCiv1 = GC.Inst.GetUnitWithId("AC8_T1TheFiles_UnitSpawn");
		filesCiv2 = GC.Inst.GetUnitWithId("A32_T1TheFiles_UnitSpawn");
		filesCiv3 = GC.Inst.GetUnitWithId("67D_T1Subway_Station_Files_UnitSpawn");
		filesCiv4 = GC.Inst.GetUnitWithId("CF7_T1Subway_Station_Files_UnitSpawn");
		filesCiv5 = GC.Inst.GetUnitWithId("A93_T1TheFiles_UnitSpawn");
		Unit Barrel = GC.Inst.GetUnitWithId("BB7_T1TheFiles_UnitSpawn");
		trainNpc1 = GC.Inst.GetUnitWithId("5F1_T1Subway_TrainInterior_UnitSpawn");
		trainNpc2 = GC.Inst.GetUnitWithId("1FD_T1Subway_TrainInterior_UnitSpawn");
		trainNpc3 = GC.Inst.GetUnitWithId("1A8_T1Subway_TrainInterior_UnitSpawn");
		trainNpc4 = GC.Inst.GetUnitWithId("305_T1Subway_TrainInterior_UnitSpawn");
		trainNpc6 = GC.Inst.GetUnitWithId("23F_T1Subway_TrainInterior_UnitSpawn");
		trainNpc7 = GC.Inst.GetUnitWithId("B2C_T1Subway_TrainInterior_UnitSpawn");
		DERYK = GC.Inst.GetUnitWithId("BBB_T1AndroidServicing_UnitSpawn");
		ExitCamWithChris = MR.Inst.GetTileTrigger("371_T1TheFiles_TileTrigger");
		filesToFilesSubway = MR.Inst.GetTileActionSwapMap("0A1_T1TheFiles_TileActionSwapMap");
		filesSubwayToFiles = MR.Inst.GetTileActionSwapMap("E62_T1Subway_Station_Files_TileActionSwapMap");
		filesSubwayToTrain = MR.Inst.GetTileActionSwapMap("C72_T1Subway_Station_Files_TileActionSwapMap");
		trainToFilesSubway = MR.Inst.GetTileActionSwapMap("82D_T1Subway_TrainInterior_TileActionSwapMap");
		trainToCam = MR.Inst.GetTileActionSwapMap("EC0_T1Subway_TrainInterior_TileActionSwapMap");
		CamToTrain = MR.Inst.GetTileActionSwapMap("EB5_T1Cambridge_TileActionSwapMap");
		trainToFiles = MR.Inst.GetTileActionSwapMap("0CF_T1Subway_TrainInterior_TileActionSwapMap");
		FilesToTrain = MR.Inst.GetTileActionSwapMap("2A9_T1TheFiles_TileActionSwapMap");
		filesToAndroidServicing = MR.Inst.GetTileActionSwapMap("279_T1TheFiles_TileActionSwapMap");
		BackRoomToVita = MR.Inst.GetTileActionSwapMap("058_T1VitaSoft_TileActionSwapMap");
		CamToVita = MR.Inst.GetTileActionSwapMap("896_T1Cambridge_TileActionSwapMap");
		VitaSoftToCam = MR.Inst.GetTileActionSwapMap("C8C_T1VitaSoft_TileActionSwapMap");
		ToVitaBackRoom = MR.Inst.GetTileActionSwapMap("CA3_T1VitaSoft_TileActionSwapMap");
		AndroidServicingToFiles = MR.Inst.GetTileActionSwapMap("53B_T1AndroidServicing_TileActionSwapMap");
		TalkToValerie = MR.Inst.GetTileActionDialog("CB0_T1AndroidServicing_TileActionDialog");
		D_BoxOfAugs = MR.Inst.GetTileActionDialog("838_T1AndroidServicing_TileActionDialog");
		D_BoxHead = MR.Inst.GetTileActionDialog("ED9_T1AndroidServicing_TileActionDialog");
		D_ILikeYourShop = MR.Inst.GetTileActionDialog("11B_T1AndroidServicing_TileActionDialog");
		D_WhatAmIDoing = MR.Inst.GetTileActionDialog("7CF_T1AndroidServicing_TileActionDialog");
		D_FilesHouse = MR.Inst.GetTileActionDialog("8A9_T1TheFiles_TileActionDialog");
		D_FilesGang = MR.Inst.GetTileActionDialog("2C4_T1TheFiles_TileActionDialog");
		D_FilesNpcCouple = MR.Inst.GetTileActionDialog("9DD_T1TheFiles_TileActionDialog");
		D_TrainMuscleNPC = MR.Inst.GetTileActionDialog("229_T1Subway_TrainInterior_TileActionDialog");
		AmbientAttendant1 = MR.Inst.GetTileActionDialog("397_T1VitaSoft_TileActionDialog");
		AmbientAttendant2 = MR.Inst.GetTileActionDialog("702_T1VitaSoft_TileActionDialog");
		AmbientAttendant3 = MR.Inst.GetTileActionDialog("50C_T1VitaSoft_TileActionDialog");
		AmbientAttendant4 = MR.Inst.GetTileActionDialog("8E6_T1VitaSoft_TileActionDialog");
		ArmAugment = MR.Inst.GetTileActionDialog("B04_T1VitaSoft_TileActionDialog");
		AugmentCore = MR.Inst.GetTileActionDialog("6D1_T1VitaSoft_TileActionDialog");
		LarynxAugment = MR.Inst.GetTileActionDialog("072_T1VitaSoft_TileActionDialog");
		LegAugment = MR.Inst.GetTileActionDialog("502_T1VitaSoft_TileActionDialog");
		D_TrainNPC6 = MR.Inst.GetTileActionDialog("EEA_T1Subway_TrainInterior_TileActionDialog");
		TalkToChris = MR.Inst.GetTileActionInteraction("95A_T1AndroidServicing_TileActionInteraction");
		I_ToBackRoom = MR.Inst.GetTileActionInteraction("95C_T1VitaSoft_TileActionInteraction");
		willaToDesk = MR.Inst.GetUnitTarget("9EA_T1AndroidServicing_UnitTarget");
		chosenCharToDesk = MR.Inst.GetUnitTarget("A70_T1AndroidServicing_UnitTarget");
		mollyToDesk = MR.Inst.GetUnitTarget("D5A_T1AndroidServicing_UnitTarget");
		mollyToMeeting = MR.Inst.GetUnitTarget("E7F_T1AndroidServicing_UnitTarget");
		chosenCharToMeeting = MR.Inst.GetUnitTarget("81A_T1AndroidServicing_UnitTarget");
		willaToMeeting = MR.Inst.GetUnitTarget("390_T1AndroidServicing_UnitTarget");
		willaInStation = MR.Inst.GetUnitTarget("B84_T1Subway_Station_Files_UnitTarget");
		willaOnTrain = MR.Inst.GetUnitTarget("331_T1AndroidServicing_UnitTarget");
		chrisToTerminal1 = MR.Inst.GetUnitTarget("752_T1VitaSoft_UnitTarget");
		chrisToTerminal2 = MR.Inst.GetUnitTarget("731_T1VitaSoft_UnitTarget");
		chosenCharToTable = MR.Inst.GetUnitTarget("4C0_T1VitaSoft_UnitTarget");
		T_WillaMoveForChris = MR.Inst.GetUnitTarget("47D_T1VitaSoftBackRoom_UnitTarget");
		T_WillaCover = MR.Inst.GetUnitTarget("296_T1VitaSoftBackRoom_UnitTarget");
		T_TeamCover = MR.Inst.GetUnitTarget("A08_T1VitaSoftBackRoom_UnitTarget");
		T_EnemyCover1 = MR.Inst.GetUnitTarget("51B_T1VitaSoftBackRoom_UnitTarget");
		T_EnemyCover2 = MR.Inst.GetUnitTarget("BAB_T1VitaSoftBackRoom_UnitTarget");
		T_EnemyCover3 = MR.Inst.GetUnitTarget("312_T1VitaSoftBackRoom_UnitTarget");
		T_EnemyCover4 = MR.Inst.GetUnitTarget("DA4_T1VitaSoftBackRoom_UnitTarget");
		Droid1Ready = MR.Inst.GetUnitTarget("BAD_T1VitaSoft_UnitTarget");
		Droid2Ready = MR.Inst.GetUnitTarget("C14_T1VitaSoft_UnitTarget");
		Droid3Ready = MR.Inst.GetUnitTarget("3F4_T1VitaSoft_UnitTarget");
		Droid4Ready = MR.Inst.GetUnitTarget("212_T1VitaSoft_UnitTarget");
		ChrisReady = MR.Inst.GetUnitTarget("E32_T1VitaSoft_UnitTarget");
		willaToCover = MR.Inst.GetUnitTarget("A69_T1VitaSoft_UnitTarget");
		ChosenCharReady = MR.Inst.GetUnitTarget("228_T1VitaSoft_UnitTarget");
		FilesFightCover1 = MR.Inst.GetUnitTarget("DDC_T1TheFiles_UnitTarget");
		FilesFightCover2 = MR.Inst.GetUnitTarget("CE5_T1TheFiles_UnitTarget");
		FilesFightCover3 = MR.Inst.GetUnitTarget("51F_T1TheFiles_UnitTarget");
		mollyTeleportPointTEMP = MR.Inst.GetUnitTarget("F7E_T1AndroidServicing_UnitTarget");
		T_ChosenChar_BR = MR.Inst.GetUnitTarget("C9E_T1VitaSoftBackRoom_UnitTarget");
		UnitTarget sfx_locked_deusoft_door = MR.Inst.GetUnitTarget("752_T1VitaSoft_UnitTarget");
		UnitTarget sfx_chris_unlocked_deusoft_door = MR.Inst.GetUnitTarget("752_T1VitaSoft_UnitTarget");
		ambient_Attendant1 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientAttendant1");
		ambient_Attendant2 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientAttendant2");
		ambient_Attendant3 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientAttendant3");
		ambient_Attendant4 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientAttendant4");
		ambient_GotAnyAugs1 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientGotAnyAugs1");
		ambient_GotAnyAugs2 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientGotAnyAugs2");
		ambient_GotAnyAugs3 = HAGIS.DialogLoad("Dialogs/A1O4/AmbientGotAnyAugs3");
		ambient_UnauthorisedAccess = HAGIS.DialogLoad("Dialogs/A1O4/AmbientUnauthorisedAccess");
		ambient_Swarm = HAGIS.DialogLoad("Dialogs/A1O4/Ambient_Swarm");
		ambient_HowMany = HAGIS.DialogLoad("Dialogs/A1O4/Ambeint_HowMany");
		ambeint_KeepLookOut = HAGIS.DialogLoad("Dialogs/A1O4/Ambeint_KeepLookOut");
		ambeint_BackToMollys = HAGIS.DialogLoad("Dialogs/A1O4/Ambeint_BackToMollys");
		ambient_Locked = HAGIS.DialogLoad("Dialogs/A1O4/Ambient_Locked");
		ambient_BoxHead = HAGIS.DialogLoad("Dialogs/A1O4/Ambeint_BoxHead");
		dialog_AreYouMercs1 = HAGIS.DialogLoad("Dialogs/A1O4/DialogAreYouMercs1");
		dialog_AreYouMercs2 = HAGIS.DialogLoad("Dialogs/A1O4/DialogAreYouMercs2");
		dialog_AreYouMercs3 = HAGIS.DialogLoad("Dialogs/A1O4/DialogAreYouMercs3");
		dialog_AreYouMolly = HAGIS.DialogLoad("Dialogs/A1O4/DialogAreYouMolly");
		dialog_BeYourself = HAGIS.DialogLoad("Dialogs/A1O4/DialogBeYourself");
		dialog_ChrisDoneJob = HAGIS.DialogLoad("Dialogs/A1O4/DialogChrisDoneJob");
		dialog_ChrisDidntHack = HAGIS.DialogLoad("Dialogs/A1O4/DialogChrisDidntHack");
		dialog_ChrisGetsMolly = HAGIS.DialogLoad("Dialogs/A1O4/DialogChrisGetsMolly");
		dialog_ChrisWelcomes = HAGIS.DialogLoad("Dialogs/A1O4/DialogChrisWelcomes");
		dialog_ImAfterAProgrammer = HAGIS.DialogLoad("Dialogs/A1O4/DialogImAfterAProgrammer");
		dialog_MollyDeal = HAGIS.DialogLoad("Dialogs/A1O4/DialogMollyDeal");
		dialog_MollyImpressed = HAGIS.DialogLoad("Dialogs/A1O4/DialogMollyImpressed");
		dialog_MollyIntro = HAGIS.DialogLoad("Dialogs/A1O4/DialogMollyIntro");
		dialog_MollyLaugh = HAGIS.DialogLoad("Dialogs/A1O4/DialogMollyLaugh");
		dialog_WillaOhNo = HAGIS.DialogLoad("Dialogs/A1O4/DialogWillaOhNo");
		dialog_GotSomething = HAGIS.DialogLoad("Dialogs/A1O4/Dialog_GotSomething");
		dialog_ChrisWoah = HAGIS.DialogLoad("Dialogs/A1O4/Dialog_ChrisWoah");
		dialog_LetsRock = HAGIS.DialogLoad("Dialogs/A1O4/DialogLetsRock");
		dialog_ChrisWait = HAGIS.DialogLoad("Dialogs/A1O4/DialogChrisWait");
		dialog_SlowDown = HAGIS.DialogLoad("Dialogs/A1O4/DialogSlowDown");
		dialog_DidThatOnPurpose = HAGIS.DialogLoad("Dialogs/A1O4/DialogDidThatOnPurpose");
		dialog_WhatAmIDoing = HAGIS.DialogLoad("Dialogs/A1O4/Dialog_WhatAmIDoing");
		dialog_LetsMove = HAGIS.DialogLoad("Dialogs/A1O4/Dialog_LetsMove");
		dialog_Punks = HAGIS.DialogLoad("Dialogs/A1O4/Dialog_Punks");
		dialog_DontBeAStranger = HAGIS.DialogLoad("Dialogs/A1O4/DialogDontBeAStranger");
		tutorial_ProgrammerIntro = HAGIS.DialogLoad("Dialogs/A1O4/TutorialDialogs/Tutorial_ProgrammerIntro");
		UIObjectives.Inst.CompleteAndSetMainObjective(objRocketScienceString);
		trainToCam.gameObject.SetActive(value: false);
		D_ILikeYourShop.gameObject.SetActive(value: false);
		ToVitaBackRoom.gameObject.SetActive(value: false);
		turret.IsMovementDisabled = true;
		turret2.IsMovementDisabled = true;
		D_BoxOfAugs.gameObject.SetActive(value: false);
		D_BoxHead.gameObject.SetActive(value: false);
		D_WhatAmIDoing.gameObject.SetActive(value: false);
		TF_Compiler1Fight.gameObject.SetActive(value: false);
		TF_Compiler2Fight.gameObject.SetActive(value: false);
		TF_Compiler3Fight.gameObject.SetActive(value: false);
		filesToFilesSubway.gameObject.SetActive(value: false);
		trainToFiles.gameObject.SetActive(value: false);
		FilesToTrain.gameObject.SetActive(value: false);
		AndroidServicingToFiles.gameObject.SetActive(value: false);
		ExitCamWithChris.gameObject.SetActive(value: false);
		molly.gameObject.SetActive(value: false);
		filesToAndroidServicing.gameObject.SetActive(value: false);
		filesSubwayToTrain.gameObject.SetActive(value: false);
		Barrel.gameObject.SetActive(value: false);
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		DERYK.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		yield return null;
		MusicStop();
		filesLogic.CanTeammatesFollow = true;
		HAGIS.DialogShow(ambient_HowMany);
		yield return CreateTimeCondition(8f);
		filesToAndroidServicing.gameObject.SetActive(value: true);
		yield return MapWaitUntilMidTransition(androidServicingLogic);
		FMOD.Studio.EventInstance sfx_chris_typing_loop = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o8/typing");
		yield return MapWaitUntilVisible(androidServicingLogic.Map);
		GC.Inst.CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_BeYourself);
		yield return UnitMoveToTarget(willa, willaToDesk);
		yield return UnitMoveToTarget(chosenChar, chosenCharToDesk);
		chosenChar.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(dialog_ImAfterAProgrammer);
		GC.Inst.CutsceneEnd();
		SKIP_POINT("Skipped android severcing intro");
		UIObjectives.Inst.CompleteAndSetMainObjective(objSpeakToChris);
		yield return CreateTriggerCondition(TalkToChris.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objSpeakToChris);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_ChrisWelcomes);
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(willa, "DefaultInteract", loop: false, updateIdle: true);
		AC.Stop(sfx_chris_typing_loop, release: true);
		CutsceneEnd();
		yield return CutscenePlay("A1O4_Cutscene_WelcomeToAndroidServicing");
		CutsceneBegin();
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk");
		chosenChar.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		TalkToChris.gameObject.SetActive(value: false);
		TalkToValerie.gameObject.SetActive(value: false);
		chosenChar.LookInDirection(OctDir.Down);
		willa.LookInDirection(OctDir.UpRight);
		yield return HAGIS.DialogShow(dialog_MollyLaugh);
		molly.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(molly, mollyToDesk);
		yield return null;
		yield return Wait.While(molly.LookAt(willa));
		willa.LookAt(molly);
		chris.unitModel.PlayAndReturnToIdle("CsTransLookUpToSit");
		yield return HAGIS.DialogShow(dialog_MollyIntro);
		yield return UnitMoveToTarget(molly, mollyToMeeting);
		molly.LookInDirection(OctDir.Right);
		willa.LookAt(molly);
		UnitMoveToTarget(chosenChar, chosenCharToMeeting, null, 2f);
		yield return UnitMoveToTarget(willa, willaToMeeting, null, 2f);
		willa.LookAt(molly);
		yield return UnitPlayAnimation(molly, "CsTransDIdleToInviting");
		UnitPlayAnimation(molly, "CsDefaultInviting", loop: true);
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(molly, "CsTransInvitingToDIdle");
		molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		molly.UpdateIdleAnim();
		yield return null;
		yield return HAGIS.DialogShow(dialog_MollyDeal);
		yield return HAGIS.DialogShow(dialog_AreYouMercs1);
		willa.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(dialog_AreYouMercs2);
		willa.LookAt(molly);
		yield return HAGIS.DialogShow(dialog_AreYouMercs3);
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return UnitPlayAnimation(chris, "CsTransSitToDIdle");
		chris.UpdateIdleAnim();
		chris.LookAt(willa);
		willa.LookAt(chris);
		chosenChar.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		D_BoxOfAugs.gameObject.SetActive(value: true);
		D_BoxHead.gameObject.SetActive(value: true);
		D_WhatAmIDoing.gameObject.SetActive(value: true);
		CutsceneEnd();
		D_FilesHouse.gameObject.SetActive(value: false);
		willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultSlowWalk);
		SKIP_POINT("Skipped chris cutscene");
		yield return CreateTimeCondition(1f);
		molly.LookInDirection(OctDir.Up);
		yield return CreateTimeCondition(1f);
		SKIP_POINT("Skipped Molly cutscene");
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadToDeusoftInCambridge);
		chris.SetTeamType(UnitTeam.Type.Player);
		filesToFilesSubway.gameObject.SetActive(value: true);
		D_ILikeYourShop.gameObject.SetActive(value: true);
		AndroidServicingToFiles.gameObject.SetActive(value: true);
		ExitCamWithChris.gameObject.SetActive(value: true);
		yield return MapWaitUntilMidTransition(filesLogic);
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		yield return MapWaitUntilVisible(filesLogic.Map);
		molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultTable");
		UnitPlayAnimation(molly, "CsDefaultTable", loop: true);
		SKIP_POINT("Skipped getting to the files");
		yield return CreateTriggerCondition(ExitCamWithChris._OnTriggered);
		HagletEvent chrisConvo = HAGIS.DialogShow(ambient_GotAnyAugs1);
		TF_Compiler1.LookAt(willa);
		yield return MapWaitUntilVisible(SubwayStationLogic.Map);
		TF_Compiler1.LookInDirection(OctDir.UpLeft);
		SubwayStationLogic.CanTeammatesFollow = true;
		yield return CreateOrCondition(CreateTimeCondition(8f), chrisConvo);
		PlayMapAnimation(SubwayStationLogic.Map, "MA_SubwayTrain", "Arriving");
		filesSubwayToTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped getting to subway");
		yield return MapWaitUntilMidTransition(SubwayTrainLogic);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return MapWaitUntilVisible(SubwayTrainLogic.Map);
		SKIP_POINT("Skipped getting to subway train");
		trainToFilesSubway.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return UnitMoveToTarget(willa, willaOnTrain);
		willa.LookAt(chris);
		chris.LookAt(willa);
		yield return HAGIS.DialogShow(ambient_GotAnyAugs2);
		trainToCam.gameObject.SetActive(value: true);
		CutsceneEnd();
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Cambridge_L0");
		PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Open");
		SubwayTrainLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped got any augs");
		yield return MapWaitUntilVisible(camLogic.Map);
		filesSubwayToTrain.gameObject.SetActive(value: false);
		camLogic.CanTeammatesFollow = true;
		D_TrainMuscleNPC.gameObject.SetActive(value: false);
		CamToTrain.gameObject.SetActive(value: false);
		trainToCam.gameObject.SetActive(value: false);
		yield return null;
		SKIP_POINT("Skipped to cam");
		yield return MapWaitUntilMidTransition(vitaLogic);
		AmbientAttendant1.gameObject.SetActive(value: false);
		AmbientAttendant2.gameObject.SetActive(value: false);
		AmbientAttendant3.gameObject.SetActive(value: false);
		AmbientAttendant4.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/basic/deusoft");
		yield return MapWaitUntilVisible(vitaLogic.Map);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEnterTheStockRoom);
		vitaLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped to DeuSoft");
		yield return HAGIS.DialogShow(ambient_GotAnyAugs3);
		vitaLogic.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(I_ToBackRoom.OnTriggered);
		CutsceneBegin();
		yield return UnitPlayAnimation(willa, "DefaultInteract");
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o4/deusoft back room door locked", sfx_locked_deusoft_door);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_Locked);
		yield return UnitMoveToTarget(chris, chrisToTerminal1);
		chris.LookInDirection(OctDir.Left);
		willa.LookAt(chris);
		yield return HAGIS.DialogShow(ambeint_KeepLookOut);
		yield return UnitPlayAnimation(chris, "CsTransDIdleToKneelHack");
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		chris.UpdateIdleAnim();
		FMOD.Studio.EventInstance sfx_chris_hacking_loop = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o4/chris hacking loop");
		yield return CreateTimeCondition(1.5f);
		AC.Stop(sfx_chris_hacking_loop, release: true);
		chris.SetTeamType(UnitTeam.Type.NPC);
		AmbientAttendant1.gameObject.SetActive(value: true);
		AmbientAttendant2.gameObject.SetActive(value: true);
		AmbientAttendant3.gameObject.SetActive(value: true);
		AmbientAttendant4.gameObject.SetActive(value: true);
		I_ToBackRoom.gameObject.SetActive(value: false);
		CutsceneEnd();
		SKIP_POINT("Skipped hacking door");
		UIObjectives.Inst.CompleteAndSetMainObjective(objDistractSecurity);
		for (int attendantsUsed = 0; attendantsUsed < 2; attendantsUsed++)
		{
			HagletYieldTerm attendantBottom = CreateTriggerCondition(AmbientAttendant4.OnDialogShow);
			yield return CreateOrCondition(attendantBottom, CreateTriggerCondition(AmbientAttendant2.OnDialogShow));
			if (SaveData.SplitPoint(attendantBottom.met))
			{
				WatchingDroidBottom.LookInDirection(OctDir.Right);
			}
			else
			{
				WatchingDroidTop.LookInDirection(OctDir.Right);
			}
		}
		yield return DialogWaitForAmbient();
		yield return CreateTimeCondition(2f);
		SKIP_POINT("Skipped door hack sequence");
		yield return null;
		CutsceneBegin();
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o4/chris hacks open deusoft back room door", sfx_chris_unlocked_deusoft_door);
		PlayMapAnimation(vitaLogic.Map, "MA_DeusoftBackDoors", "Open");
		ToVitaBackRoom.gameObject.SetActive(value: true);
		yield return UnitPlayAnimation(chris, "CsTransKneelHackToDIdle");
		yield return UnitPlayAnimation(chris, "DefaultIdle");
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		chris.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialog_LetsRock);
		willa.LookAt(chris);
		UnitTeleportToMapViaEntranceTile(chris, BackRoomToVita, chrisToTerminal2);
		yield return CreateTimeCondition(1f);
		willa.LookAt(I_ToBackRoom.GetCoord());
		yield return HAGIS.DialogShow(dialog_ChrisWait);
		yield return null;
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objEnterTheStockRoom);
		yield return MapWaitUntilVisible(VitaSoftBackRoomLogic.Map);
		MusicStop();
		chris.LookInDirection(OctDir.Up);
		VitaSoftBackRoomLogic.CanTeammatesFollow = true;
		AmbientAttendant1.gameObject.SetActive(value: false);
		AmbientAttendant2.gameObject.SetActive(value: false);
		AmbientAttendant3.gameObject.SetActive(value: false);
		AmbientAttendant4.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objEnterTheStockRoom);
		SKIP_POINT("moving to back room");
		BackRoomToVita.gameObject.SetActive(value: false);
		CutsceneBegin();
		willa.LookInDirection(OctDir.UpLeft);
		yield return UnitPlayAnimation(chris, "CsTransDIdleToKneelHack");
		yield return UnitPlayAnimation(chris, "CsDefaultKneelHack");
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		chris.UpdateIdleAnim();
		FMOD.Studio.EventInstance sfx_chris_hacking_loop2 = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o4/chris hacking loop");
		yield return UnitMoveToTarget(willa, T_WillaMoveForChris);
		willa.LookAt(chris);
		yield return HAGIS.DialogShow(dialog_SlowDown);
		AC.Stop(sfx_chris_hacking_loop2, release: true);
		SFXPlay("event:/sfx/script/act 1/a1o4/deusoft back room unauthorised access alarm");
		yield return CreateTimeCondition(1f);
		SecurityDroid1.SetTeamType(UnitTeam.Type.Enemy);
		SecurityDroid2.SetTeamType(UnitTeam.Type.Enemy);
		UnitMoveToTarget(SecurityDroid1, T_EnemyCover1);
		UnitMoveToTarget(SecurityDroid2, T_EnemyCover2);
		yield return CreateTimeCondition(1f);
		chosenChar.LookInDirection(OctDir.Down);
		SecurityDroid3.SetTeamType(UnitTeam.Type.Enemy);
		SecurityDroid4.SetTeamType(UnitTeam.Type.Enemy);
		UnitMoveToTarget(SecurityDroid3, T_EnemyCover3);
		UnitMoveToTarget(SecurityDroid4, T_EnemyCover4);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_UnauthorisedAccess);
		SecurityDroid1.LookAt(chris);
		SecurityDroid1.LookAt(chris);
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		chris.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		yield return CreateAndCondition(UnitPlayAnimation(willa, "TransDIdleToCIdle", loop: false, updateIdle: true), UnitPlayAnimation(chris, "CsTransKneelHackToDIdle"));
		yield return UnitPlayAnimation(chris, "DefaultIdle", loop: false, updateIdle: true);
		yield return CreateAndCondition(UnitMoveToTarget(willa, T_WillaCover, null, 5f), UnitMoveToTarget(chris, T_TeamCover));
		chris.LookInDirection(OctDir.Left);
		willa.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(dialog_DidThatOnPurpose);
		willa.LookInDirection(OctDir.Left);
		yield return null;
		CutsceneEnd();
		SKIP_POINT("Skipped enemies becoming active");
		chris.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(chris);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objSubdueSecurity);
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		CombatBegin(UnitTeam.Type.Player);
		CutsceneBegin();
		yield return HAGIS.DialogShow(tutorial_ProgrammerIntro);
		CutsceneEnd();
		yield return ShowTutorialScreen(TutorialScreen.AbilityGaugeOverride);
		bool hackedTurret = false;
		HagletYieldTerm playerSecondTurn = TurnModeWaitForPlayerTurnStart(1u, includeCombatComplete: false);
		HagletYieldTerm playerTeamGrew = CreateTriggerCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnUnitAddedToTeam);
		yield return playerSecondTurn | playerTeamGrew | CombatWaitUntilComplete();
		bool met;
		hackedTurret = (met = playerTeamGrew.met);
		if (met)
		{
			yield return CombatWaitUntilComplete();
		}
		else if (playerSecondTurn.met)
		{
			if (chris.IsAlive() && willa.IsAlive())
			{
				yield return HAGIS.DialogShow(ambient_Swarm);
			}
			playerTeamGrew = CreateTriggerCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnUnitAddedToTeam);
			yield return playerTeamGrew | CombatWaitUntilComplete();
			hackedTurret = (met = playerTeamGrew.met);
			if (met)
			{
				yield return CombatWaitUntilComplete();
			}
		}
		hackedTurret = SaveData.SplitPoint(hackedTurret, skipOverride: false);
		yield return CreateTimeCondition(1f);
		GC.Inst.SetRPGLeader(willa);
		yield return null;
		willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		SKIP_POINT("Skipped combat");
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturnToMolly);
		yield return null;
		MusicStop();
		CutsceneBegin();
		yield return UnitMoveToTarget(chris, chrisToTerminal2);
		chris.LookInDirection(OctDir.Up);
		yield return UnitPlayAnimation(chris, "CsTransDIdleToKneelHack");
		yield return UnitPlayAnimation(chris, "CsDefaultKneelHack");
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		chris.UpdateIdleAnim();
		FMOD.Studio.EventInstance sfx_chris_hacking_loop3 = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o4/chris hacking loop");
		UnitMoveToTarget(chosenChar, T_ChosenChar_BR, OctDir.UpRight);
		yield return UnitMoveToTarget(willa, T_WillaMoveForChris, OctDir.Up);
		if (hackedTurret)
		{
			yield return HAGIS.DialogShow(dialog_ChrisDoneJob);
			AC.Stop(sfx_chris_hacking_loop3, release: true);
			SFXPlay("event:/sfx/script/act 1/a1o4/hack complete");
		}
		else
		{
			yield return HAGIS.DialogShow(dialog_ChrisDidntHack);
			AC.Stop(sfx_chris_hacking_loop3, release: true);
			SFXPlay("event:/sfx/script/act 1/a1o4/hack complete");
		}
		turret.SetTeamType(UnitTeam.Type.NPC);
		turret2.SetTeamType(UnitTeam.Type.NPC);
		SecurityDroid1.SetTeamType(UnitTeam.Type.NPC);
		SecurityDroid2.SetTeamType(UnitTeam.Type.NPC);
		SecurityDroid3.SetTeamType(UnitTeam.Type.NPC);
		SecurityDroid4.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitPlayAnimation(chris, "CsTransKneelHackToDIdle");
		yield return UnitPlayAnimation(chris, "DefaultIdle");
		chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		chris.UpdateIdleAnim();
		BackRoomToVita.gameObject.SetActive(value: true);
		yield return null;
		CutsceneEnd();
		SKIP_POINT("Skipped hack");
		yield return MapWaitUntilMidTransition(vitaLogic);
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		yield return MapWaitUntilVisible(vitaLogic.Map);
		CutsceneBegin();
		WatchingDroidTop.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		WatchingDroidBottom.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		droidAttendant1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		droidAttendant2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return CreateAndCondition(UnitPlayAnimation(WatchingDroidTop, "TransDIdleToCIdle"), UnitPlayAnimation(WatchingDroidBottom, "TransDIdleToCIdle"), UnitPlayAnimation(droidAttendant1, "TransDIdleToCIdle"), UnitPlayAnimation(droidAttendant2, "TransDIdleToCIdle"));
		HagletYieldTerm droid1InCover = UnitMoveToTarget(WatchingDroidTop, Droid3Ready);
		HagletYieldTerm droid2InCover = UnitMoveToTarget(WatchingDroidBottom, Droid1Ready);
		HagletYieldTerm droid3InCover = UnitMoveToTarget(droidAttendant1, Droid2Ready);
		HagletYieldTerm droid4InCover = UnitMoveToTarget(droidAttendant2, Droid4Ready);
		yield return CreateAndCondition(droid1InCover, droid2InCover, droid3InCover, droid4InCover);
		UnitPlayAnimation(WatchingDroidTop, "CombatIdle", loop: true);
		UnitPlayAnimation(WatchingDroidBottom, "CombatIdle", loop: true);
		UnitPlayAnimation(droidAttendant1, "CombatIdle", loop: true);
		UnitPlayAnimation(droidAttendant2, "CombatIdle", loop: true);
		yield return null;
		WatchingDroidTop.LookInDirection(OctDir.Left);
		WatchingDroidBottom.LookInDirection(OctDir.Left);
		droidAttendant1.LookInDirection(OctDir.Left);
		droidAttendant2.LookInDirection(OctDir.Left);
		WatchingDroidBottom.SetTeamType(UnitTeam.Type.Enemy);
		WatchingDroidTop.SetTeamType(UnitTeam.Type.Enemy);
		droidAttendant1.SetTeamType(UnitTeam.Type.Enemy);
		droidAttendant2.SetTeamType(UnitTeam.Type.Enemy);
		yield return HAGIS.DialogShow(dialog_WillaOhNo);
		UIObjectives.Inst.CompleteAndSetMainObjective(objSubdueSecurity);
		UnitMoveToTarget(willa, willaToCover);
		UnitMoveToTarget(chris, ChrisReady);
		yield return UnitMoveToTarget(chosenChar, ChosenCharReady);
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/deusoft");
		yield return HAGIS.DialogShow(dialog_LetsMove);
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturnToMolly);
		yield return null;
		SKIP_POINT("Skipped to end of DeuSoft sequence");
		yield return MapWaitUntilVisible(camLogic.Map);
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		CamToVita.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(ambeint_BackToMollys);
		CamToTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped to Cam");
		SKIP_POINT("Skipped to subway station");
		TF_Compiler1Fight.gameObject.SetActive(value: true);
		TF_Compiler2Fight.gameObject.SetActive(value: true);
		TF_Compiler3Fight.gameObject.SetActive(value: true);
		Barrel.gameObject.SetActive(value: true);
		TF_Compiler1.gameObject.SetActive(value: false);
		TF_Compiler2.gameObject.SetActive(value: false);
		TF_Compiler3.gameObject.SetActive(value: false);
		filesCiv1.gameObject.SetActive(value: false);
		filesCiv2.gameObject.SetActive(value: false);
		filesCiv3.gameObject.SetActive(value: false);
		filesCiv4.gameObject.SetActive(value: false);
		filesCiv5.gameObject.SetActive(value: false);
		D_FilesGang.gameObject.SetActive(value: false);
		D_FilesNpcCouple.gameObject.SetActive(value: false);
		trainNpc1.gameObject.SetActive(value: false);
		trainNpc2.gameObject.SetActive(value: false);
		trainNpc3.gameObject.SetActive(value: false);
		trainNpc4.gameObject.SetActive(value: false);
		trainNpc6.gameObject.SetActive(value: false);
		D_TrainNPC6.gameObject.SetActive(value: false);
		trainNpc7.gameObject.SetActive(value: false);
		yield return MapWaitUntilMidTransition(SubwayTrainLogic);
		PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Close");
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return MapWaitUntilVisible(SubwayTrainLogic.Map);
		SubwayTrainLogic.CanTeammatesFollow = false;
		yield return UnitMoveToTarget(willa, willaOnTrain);
		willa.LookAt(chris);
		chris.LookAt(willa);
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Files_L0");
		PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Open");
		trainToFiles.gameObject.SetActive(value: true);
		FilesToTrain.gameObject.SetActive(value: true);
		UnitMoveToTarget(molly, mollyToMeeting);
		yield return MapWaitUntilMidTransition(filesLogic);
		MusicPlay("event:/music/tracks/basic/light tension 1");
		yield return MapWaitUntilVisible(filesLogic.Map);
		trainToFiles.gameObject.SetActive(value: false);
		filesToFilesSubway.gameObject.SetActive(value: false);
		FilesToTrain.gameObject.SetActive(value: false);
		CutsceneBegin();
		SKIP_POINT("Skipped to the files");
		yield return HAGIS.DialogShow(dialog_GotSomething);
		UnitMoveToTarget(willa, FilesFightCover1);
		UnitMoveToTarget(chris, FilesFightCover2);
		yield return UnitMoveToTarget(chosenChar, FilesFightCover3);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefeatHolden);
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		yield return HAGIS.DialogShow(dialog_Punks);
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturnToMolly);
		SKIP_POINT("Skipped fight in the files");
		molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultTable");
		molly.UpdateIdleAnim();
		yield return MapWaitUntilMidTransition(androidServicingLogic);
		yield return MapWaitUntilVisible(androidServicingLogic.Map);
		UIObjectives.Inst.CompleteObjective(objReturnToMolly);
		SKIP_POINT("Skipped to the androis servercing");
		yield return CutscenePlay("A1O4_Cutscene_ReturnAndroidServicing");
		molly.unitModel.Play("DefaultGiveItem");
		willa.unitModel.Play("DefaultReceiveItem");
		yield return HAGIS.DialogShow(dialog_DontBeAStranger);
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_A1O4_CraneAnim : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AndroidServicing = GetLogicUsingArtName("T1AndroidServicing");
		yield return null;
		while (true)
		{
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LtoR");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RIdle");
			yield return CreateTimeCondition(8f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RtoL");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LIdle");
			yield return CreateTimeCondition(12f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LtoR");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RIdle");
			yield return CreateTimeCondition(5f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RtoL");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LIdle");
			yield return CreateTimeCondition(20f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LtoR");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RIdle");
			yield return CreateTimeCondition(3f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RtoL");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LIdle");
			yield return CreateTimeCondition(15f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LtoR");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RIdle");
			yield return CreateTimeCondition(9f);
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "RtoL");
			yield return PlayMapAnimation(AndroidServicing.Map, "CH_ASCrane", "LIdle");
			yield return CreateTimeCondition(18f);
		}
	}
}
public class HAGIS_A1O4_RobotArmsAnim : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		KubrickAnimator armAnim = GetComponentInChildren<KubrickAnimator>();
		yield return null;
		armAnim.Play("Idle");
		yield return CreateTimeCondition(UnityEngine.Random.Range(5f, 30f));
		while (true)
		{
			yield return armAnim.Play("IdleAlt");
			yield return CreateTimeCondition(UnityEngine.Random.Range(30f, 60f));
			armAnim.Play("Idle");
		}
	}
}
public class HAGIS_A1O4_Turret1 : HAGIS
{
	private Unit Chris;

	private Unit Turret1;

	private Unit Turret2;

	private TileActionInteraction InteractionHack1;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Chris = GC.Inst.GetUnitWithId("94F_T1AndroidServicing_UnitSpawn");
		Turret1 = GC.Inst.GetUnitWithId("693_T1VitaSoftBackRoom_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("15D_T1VitaSoftBackRoom_UnitSpawn");
		InteractionHack1 = MR.Inst.GetTileActionInteraction("FC6_T1VitaSoftBackRoom_TileActionInteraction");
		yield return null;
		yield return CreateTriggerCondition(InteractionHack1.OnTriggered);
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Chris, "CsTransCIdleToCCrouch");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatCrouch");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		Ability_Break_Proxy breakProxy = Turret1.abilities.Add<Ability_Break_Proxy>(null, isUpgraded: false);
		breakProxy.turnCounter = int.MaxValue;
		breakProxy.originalTeamType = Turret1.teamType;
		Turret1.SetTeamType(UnitTeam.Type.Player);
		Turret1.unitModel.Play(UnitModel.AnimID.CombatHacked);
		breakProxy = Turret2.abilities.Add<Ability_Break_Proxy>(null, isUpgraded: false);
		breakProxy.turnCounter = int.MaxValue;
		breakProxy.originalTeamType = Turret2.teamType;
		Turret2.SetTeamType(UnitTeam.Type.Player);
		Turret2.unitModel.Play(UnitModel.AnimID.CombatHacked);
		InteractionHack1.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A1O4_Turret1HackTracker : HAGIS
{
	private Unit Turret1;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Turret1 = GC.Inst.GetUnitWithId("693_T1VitaSoftBackRoom_UnitSpawn");
		LogicRoot DeusoftBackroom = GetLogicByName("A1O4_T1VitaSoftBackRoom");
		yield return null;
		Turret1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		Turret1.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "DefaultIdle");
		Turret1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatHacked, "TransDIdleToCIdle");
		yield return MapWaitUntilVisible(DeusoftBackroom.Map);
		while (true)
		{
			HagletYieldTerm combatCompleted = CreateTriggerCondition(CombatWaitUntilComplete());
			yield return CreateOrCondition(CreateTriggerCondition(Turret1.OnUnitSwitchedTeam), combatCompleted);
			if (combatCompleted.met)
			{
				break;
			}
			HagisLog("Turret 1 switched team to " + Turret1.teamType);
			if (Turret1.teamType == UnitTeam.Type.NPC)
			{
				yield return Turret1.unitModel.Play(UnitModel.AnimID.TransCIdleToDIdle);
				Turret1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
			}
			else
			{
				Turret1.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
			}
		}
		if (Turret1.teamType != UnitTeam.Type.NPC)
		{
			Turret1.SetTeamType(UnitTeam.Type.NPC);
			yield return Turret1.unitModel.Play(UnitModel.AnimID.TransCIdleToDIdle);
		}
		Turret1.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Turret1.unitModel.ClearAnimOverride(UnitModel.AnimID.TransDIdleToCIdle);
		Turret1.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHacked);
	}
}
public class HAGIS_A1O4_Turret2HackTracker : HAGIS
{
	private Unit Turret2;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Turret2 = GC.Inst.GetUnitWithId("15D_T1VitaSoftBackRoom_UnitSpawn");
		LogicRoot DeusoftBackroom = GetLogicByName("A1O4_T1VitaSoftBackRoom");
		yield return null;
		Turret2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		Turret2.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "DefaultIdle");
		Turret2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatHacked, "TransDIdleToCIdle");
		yield return MapWaitUntilVisible(DeusoftBackroom.Map);
		while (true)
		{
			HagletYieldTerm combatCompleted = CreateTriggerCondition(CombatWaitUntilComplete());
			yield return CreateOrCondition(CreateTriggerCondition(Turret2.OnUnitSwitchedTeam), combatCompleted);
			if (combatCompleted.met)
			{
				break;
			}
			HagisLog("Turret 2 switched team to " + Turret2.teamType);
			if (Turret2.teamType == UnitTeam.Type.NPC)
			{
				yield return Turret2.unitModel.Play(UnitModel.AnimID.TransCIdleToDIdle);
				Turret2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
			}
			else
			{
				Turret2.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
			}
		}
		if (Turret2.teamType != UnitTeam.Type.NPC)
		{
			Turret2.SetTeamType(UnitTeam.Type.NPC);
			yield return Turret2.unitModel.Play(UnitModel.AnimID.TransCIdleToDIdle);
		}
		Turret2.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Turret2.unitModel.ClearAnimOverride(UnitModel.AnimID.TransDIdleToCIdle);
		Turret2.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHacked);
	}
}
public class HAGIS_A1O5 : HAGIS
{
	private Unit doorman;

	private Unit noot;

	private Unit eugene;

	private Unit willa;

	private Unit fighterBig;

	private Unit fighterFast;

	private Unit round2Goon1;

	private Unit round2Goon2;

	private Unit finalGoon1;

	private Unit finalGoon2;

	private Unit finalGoon3;

	private Unit player1;

	private Unit player2;

	private int chosenPlayer;

	private UnitTarget targetDoorman;

	private UnitTarget targetFightRunStart;

	private UnitTarget targetFightBigStart;

	private UnitTarget targetFightRun1;

	private UnitTarget targetFightRun2;

	private UnitTarget targetFightRun3;

	private UnitTarget targetFightRun4;

	private UnitTarget targetFightRunEnd;

	private UnitTarget targetBigWins;

	private UnitTarget targetNoot1;

	private UnitTarget targetNoot2;

	private UnitTarget targetNoot3;

	private UnitTarget targetNoot4;

	private UnitTarget targetNootChair;

	private UnitTarget targetUlyssesTantrum;

	private UnitTarget targetCageEntrance;

	private UnitTarget targetWillaToCage;

	private UnitTarget targetCageExit;

	private UnitTarget targetFightEntrance;

	private UnitTarget targetFightRound2a;

	private UnitTarget targetFightRound2b;

	private UnitTarget targetGuard;

	private UnitTarget targetGuardMove;

	private UnitTarget targetFinalPlayer;

	private UnitTarget targetFinalGoon1Spawn;

	private UnitTarget targetFinalGoon2Spawn;

	private UnitTarget targetFinalGoon1;

	private UnitTarget targetFinalGoon2;

	private UnitTarget targetNootCamEnd;

	private UnitTarget targetWillaCamEnd;

	private TileActionDialog dialogTriggerDoorman;

	private TileActionDialog dialogTriggerDoormanMoved;

	private TileActionDialog dialogTriggerNoot;

	private TileActionDialog dialogEugene;

	private TileActionSwapMap camToBar;

	private TileActionSwapMap barToArena;

	private TileActionSwapMap arenaToBar;

	private TileActionSwapMap barToCam;

	private TileActionInteraction InteractionTalkToNoot;

	private TileActionInteraction NootOutro;

	private DialogData AmbientMissionStart;

	private DialogData dialogReassure;

	private DialogData dialogDoorman;

	private DialogData dialogDoorman2;

	private DialogData dialogDoormanIknowYou;

	private DialogData ambientWillaCocky;

	private DialogData dialogNootIntro;

	private DialogData dialogFighterWins;

	private DialogData dialogEugeneDemandsFighters0;

	private DialogData dialogEugeneDemandsFighters1;

	private DialogData dialogEugeneDemandsFighters2;

	private DialogData dialogDoubleOrNothing;

	private DialogData dialogDoubleOrNothing2;

	private DialogData dialogEugenePissed;

	private DialogData dialogAllBetsFinal;

	private DialogData dialogNootOutro;

	private DialogData dialogTakeNote;

	private DialogData dialogGotYou;

	private DialogData ambientThankNoot;

	private DialogData dialogDoSomething;

	private DialogData DialogExhausedWilla;

	private DialogData DialogPhoneCallReminder;

	private DialogData DialogTheresNoot;

	private DialogData tutorial_MuscleIntro;

	private string objGainEntryString = "OBJECTIVES_A1O5_01";

	private string objRecruitFighterString = "OBJECTIVES_A1O5_02";

	private string objWinFightString = "OBJECTIVES_A1O5_03";

	private string objLeaveString = "OBJECTIVES_A1O5_04";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot camLogic = GetLogicUsingArtName("T1Cambridge");
		LogicRoot barLogic = GetLogicUsingArtName("T1Bar1_BlindTiger");
		LogicRoot arenaLogic = GetLogicUsingArtName("T1Bar3_BlindTigerArena");
		TileBlockDynamic DynamicCageColLeft = MR.Inst.GetTileBlockDynamic("0E1_T1Bar3_BlindTigerArena_TileBlockDynamic");
		TileBlockDynamic DynamicCageColRight = MR.Inst.GetTileBlockDynamic("A3F_T1Bar3_BlindTigerArena_TileBlockDynamic");
		doorman = GC.Inst.GetUnitWithId("1F2_T1Bar1_BlindTiger_UnitSpawn");
		noot = GC.Inst.GetUnitWithId("00B_T1Bar3_BlindTigerArena_UnitSpawn");
		noot.AddInitialPartyAbilities();
		eugene = GC.Inst.GetUnitWithId("91D_T1Bar3_BlindTigerArena_UnitSpawn");
		willa = GC.Inst.GetUnitWithId("3F1_T1Bar1_BlindTiger_UnitSpawn");
		fighterBig = GC.Inst.GetUnitWithId("FD2_T1Bar3_BlindTigerArena_UnitSpawn");
		fighterFast = GC.Inst.GetUnitWithId("DDE_T1Bar3_BlindTigerArena_UnitSpawn");
		round2Goon1 = GC.Inst.GetUnitWithId("5EA_T1Bar3_BlindTigerArena_UnitSpawn");
		round2Goon2 = GC.Inst.GetUnitWithId("A30_T1Bar3_BlindTigerArena_UnitSpawn");
		finalGoon1 = GC.Inst.GetUnitWithId("2AD_T1Bar3_BlindTigerArena_UnitSpawn");
		finalGoon2 = GC.Inst.GetUnitWithId("4B3_T1Bar3_BlindTigerArena_UnitSpawn");
		finalGoon3 = GC.Inst.GetUnitWithId("75B_T1Bar3_BlindTigerArena_UnitSpawn");
		player1 = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMemberAtIndex(0);
		player2 = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMemberAtIndex(1);
		dialogTriggerDoorman = MR.Inst.GetTileActionDialog("854_T1Bar1_BlindTiger_TileActionDialog");
		dialogTriggerDoormanMoved = MR.Inst.GetTileActionDialog("58E_T1Bar1_BlindTiger_TileActionDialog");
		HAGIS_A1O5_CageFight cageFightLogic = MR.Inst.GetHagis<HAGIS_A1O5_CageFight>();
		camToBar = MR.Inst.GetTileActionSwapMap("D5F_T1Bar1_BlindTiger_TileActionSwapMap");
		barToArena = MR.Inst.GetTileActionSwapMap("C02_T1Bar1_BlindTiger_TileActionSwapMap");
		arenaToBar = MR.Inst.GetTileActionSwapMap("45D_T1Bar3_BlindTigerArena_TileActionSwapMap");
		barToCam = MR.Inst.GetTileActionSwapMap("4FE_T1Bar1_BlindTiger_TileActionSwapMap");
		targetDoorman = MR.Inst.GetUnitTarget("08D_T1Bar1_BlindTiger_UnitTarget");
		targetFightRunStart = MR.Inst.GetUnitTarget("92D_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightBigStart = MR.Inst.GetUnitTarget("2E5_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun1 = MR.Inst.GetUnitTarget("F71_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun2 = MR.Inst.GetUnitTarget("D8F_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun3 = MR.Inst.GetUnitTarget("36E_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun4 = MR.Inst.GetUnitTarget("592_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRunEnd = MR.Inst.GetUnitTarget("CE7_T1Bar3_BlindTigerArena_UnitTarget");
		targetBigWins = MR.Inst.GetUnitTarget("501_T1Bar3_BlindTigerArena_UnitTarget");
		targetNoot1 = MR.Inst.GetUnitTarget("D94_T1Bar3_BlindTigerArena_UnitTarget");
		targetNoot2 = MR.Inst.GetUnitTarget("E0F_T1Bar3_BlindTigerArena_UnitTarget");
		targetNoot3 = MR.Inst.GetUnitTarget("0BB_T1Bar3_BlindTigerArena_UnitTarget");
		targetNoot4 = MR.Inst.GetUnitTarget("9C7_T1Bar3_BlindTigerArena_UnitTarget");
		targetNootChair = MR.Inst.GetUnitTarget("310_T1Bar3_BlindTigerArena_UnitTarget");
		targetCageEntrance = MR.Inst.GetUnitTarget("8E8_T1Bar3_BlindTigerArena_UnitTarget");
		targetCageExit = MR.Inst.GetUnitTarget("101_T1Bar3_BlindTigerArena_UnitTarget");
		targetWillaToCage = MR.Inst.GetUnitTarget("78C_T1Bar3_BlindTigerArena_UnitTarget");
		targetUlyssesTantrum = MR.Inst.GetUnitTarget("5CF_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightEntrance = MR.Inst.GetUnitTarget("58E_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRound2a = MR.Inst.GetUnitTarget("B69_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRound2b = MR.Inst.GetUnitTarget("83B_T1Bar3_BlindTigerArena_UnitTarget");
		targetGuard = MR.Inst.GetUnitTarget("926_T1Bar3_BlindTigerArena_UnitTarget");
		targetGuardMove = MR.Inst.GetUnitTarget("17D_T1Bar3_BlindTigerArena_UnitTarget");
		targetFinalPlayer = MR.Inst.GetUnitTarget("004_T1Bar3_BlindTigerArena_UnitTarget");
		targetFinalGoon1Spawn = MR.Inst.GetUnitTarget("1F6_T1Bar3_BlindTigerArena_UnitTarget");
		targetFinalGoon2Spawn = MR.Inst.GetUnitTarget("6A4_T1Bar3_BlindTigerArena_UnitTarget");
		targetFinalGoon1 = MR.Inst.GetUnitTarget("296_T1Bar3_BlindTigerArena_UnitTarget");
		targetFinalGoon2 = MR.Inst.GetUnitTarget("15B_T1Bar3_BlindTigerArena_UnitTarget");
		targetNootCamEnd = MR.Inst.GetUnitTarget("894_T1Cambridge_UnitTarget");
		targetWillaCamEnd = MR.Inst.GetUnitTarget("5CC_T1Cambridge_UnitTarget");
		UnitTarget sfx_noot_returns_augments = MR.Inst.GetUnitTarget("004_T1Bar3_BlindTigerArena_UnitTarget");
		AmbientMissionStart = HAGIS.DialogLoad("Dialogs/A1O5/AmbientMissionStart");
		dialogReassure = HAGIS.DialogLoad("Dialogs/A1O5/DialogReassurance");
		dialogDoorman = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoorman");
		dialogDoorman2 = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoorman2");
		dialogDoormanIknowYou = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoormanIknowYou");
		ambientWillaCocky = HAGIS.DialogLoad("Dialogs/A1O5/AmbientWillaCocky");
		dialogNootIntro = HAGIS.DialogLoad("Dialogs/A1O5/DialogNootIntro");
		dialogFighterWins = HAGIS.DialogLoad("Dialogs/A1O5/DialogFighterWins");
		dialogEugeneDemandsFighters0 = HAGIS.DialogLoad("Dialogs/A1O5/DialogEugeneDemandsFighters0");
		dialogEugeneDemandsFighters1 = HAGIS.DialogLoad("Dialogs/A1O5/DialogEugeneDemandsFighters1");
		dialogEugeneDemandsFighters2 = HAGIS.DialogLoad("Dialogs/A1O5/DialogEugeneDemandsFighters2");
		dialogDoubleOrNothing = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoubleOrNothing");
		dialogDoubleOrNothing2 = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoubleOrNothing2");
		dialogEugenePissed = HAGIS.DialogLoad("Dialogs/A1O5/DialogEugenePissed");
		dialogAllBetsFinal = HAGIS.DialogLoad("Dialogs/A1O5/DialogAllBetsFinal");
		dialogNootOutro = HAGIS.DialogLoad("Dialogs/A1O5/DialogNootOutro");
		dialogTakeNote = HAGIS.DialogLoad("Dialogs/A1O5/DialogTakeNote");
		dialogGotYou = HAGIS.DialogLoad("Dialogs/A1O5/DialogGotYou");
		ambientThankNoot = HAGIS.DialogLoad("Dialogs/A1O5/AmbientThankNoot");
		dialogDoSomething = HAGIS.DialogLoad("Dialogs/A1O5/DialogDoSomething");
		DialogExhausedWilla = HAGIS.DialogLoad("Dialogs/A1O5/DialogExhausedWilla");
		DialogPhoneCallReminder = HAGIS.DialogLoad("Dialogs/A1O5/DialogPhoneCallReminder");
		DialogTheresNoot = HAGIS.DialogLoad("Dialogs/A1O5/DialogTheresNoot");
		tutorial_MuscleIntro = HAGIS.DialogLoad("Dialogs/A1O5/TutorialDialogs/Tutorial_MuscleIntro");
		InteractionTalkToNoot = MR.Inst.GetTileActionInteraction("0B3_T1Bar3_BlindTigerArena_TileActionInteraction");
		NootOutro = MR.Inst.GetTileActionInteraction("366_T1Cambridge_TileActionInteraction");
		Ability_MaxHP fighterBigyHP = fighterBig.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		fighterBigyHP.SetHPMod(4);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGainEntryString);
		barToArena.gameObject.SetActive(value: false);
		dialogTriggerDoormanMoved.gameObject.SetActive(value: false);
		dialogTriggerDoorman.gameObject.SetActive(value: false);
		round2Goon1.gameObject.SetActive(value: false);
		round2Goon2.gameObject.SetActive(value: false);
		DynamicCageColLeft.gameObject.SetActive(value: true);
		DynamicCageColRight.gameObject.SetActive(value: true);
		NootOutro.gameObject.SetActive(value: false);
		round2Goon1.abilities.AbilityGetByType<Ability_Taunt>(round2Goon1).Enabled = false;
		round2Goon2.abilities.AbilityGetByType<Ability_Taunt>(round2Goon2).Enabled = false;
		finalGoon3.abilities.AbilityGetByType<Ability_Taunt>(finalGoon3).Enabled = false;
		finalGoon1.abilities.AbilityGetByType<Ability_Spray_And_Pray>(finalGoon1).Enabled = false;
		noot.abilities.Add<Ability_Taunt>(null, isUpgraded: false);
		noot.abilities.Add<Ability_Ground_Pound>(null, isUpgraded: false);
		yield return null;
		MusicStop();
		yield return HAGIS.DialogShow(AmbientMissionStart);
		camLogic.CanTeammatesFollow = true;
		SKIP_POINT("Finished starting dialog");
		yield return CreateTimeCondition(2f);
		PlayInterplay();
		yield return MapWaitUntilVisible(barLogic.Map);
		MusicPlay("event:/music/tracks/basic/bt piano");
		barLogic.CanTeammatesFollow = true;
		UIObjectives.Inst.CompleteObjective(objGainEntryString);
		willa.LookInDirection(OctDir.Left);
		yield return HAGIS.DialogShow(dialogReassure);
		dialogTriggerDoorman.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(dialogDoormanIknowYou.OnComplete);
		UnitPlayAnimation(doorman, "TransDIdleToCIdle");
		doorman.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialogDoorman);
		UnitPlayAnimation(doorman, "TransCIdleToDIdle");
		doorman.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return HAGIS.DialogShow(dialogDoorman2);
		CutsceneEnd();
		dialogTriggerDoorman.gameObject.SetActive(value: false);
		dialogTriggerDoormanMoved.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(doorman, targetDoorman, OctDir.DownRight);
		barToArena.gameObject.SetActive(value: true);
		yield return null;
		SKIP_POINT("Player has spoken to the doorman. Player needs to enter Arena.");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		yield return MapWaitUntilVisible(arenaLogic.Map);
		MusicPlay("event:/music/tracks/basic/bt arena intro");
		arenaToBar.gameObject.SetActive(value: false);
		GC.Inst.CutsceneBegin();
		yield return CreateTimeCondition(0.5f);
		willa.LookAt(fighterBig);
		yield return CreateTimeCondition(4f);
		yield return HAGIS.DialogShow(ambientWillaCocky);
		UIObjectives.Inst.CompleteAndSetMainObjective(objRecruitFighterString);
		GC.Inst.CutsceneEnd();
		SKIP_POINT("Cutscene in the Arena has occurred. Player needs to talk to Noot.");
		yield return CreateTriggerCondition(InteractionTalkToNoot.OnTriggered);
		GC.Inst.CutsceneBegin();
		willa.LookInDirection(OctDir.Left);
		yield return UnitPlayAnimation(noot, "CsTransSitToDIdle");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		noot.LookAt(willa);
		yield return null;
		yield return HAGIS.DialogShow(dialogNootIntro);
		noot.LookInDirection(OctDir.Left);
		GC.Inst.CutsceneEnd();
		yield return HAGISWaitForHAGIS(cageFightLogic);
		GC.Inst.CutsceneBegin();
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return UnitMoveToTarget(fighterBig, targetUlyssesTantrum);
		fighterBig.LookInDirection(OctDir.Up);
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatAttackMelee);
		SKIP_POINT("Ulysses has gone done a won");
		yield return HAGIS.DialogShow(dialogFighterWins);
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatAttackMelee);
		yield return PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "OpenVertical");
		DynamicCageColRight.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(noot, targetCageExit);
		noot.LookInDirection(OctDir.Up);
		GC.Inst.CutsceneEnd();
		yield return CutscenePlay("A1O5_Cutscene_NootBeatsFighter");
		GC.Inst.CutsceneBegin();
		noot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		yield return UnitMoveToTarget(noot, targetNootChair);
		PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "CloseVertical");
		yield return Wait.While(noot.LookInDirection(OctDir.Up));
		DynamicCageColRight.gameObject.SetActive(value: true);
		SKIP_POINT("Cutscene 2 in the Arena has occurred. Player needs to choose a fighter.");
		yield return null;
		noot.unitModel.SetBlending(blend: false);
		noot.StartSnapToPosition(noot.coord, OctDir.Down, waitForModelToSnap: true);
		yield return UnitPlayAnimation(noot, "CsTransDIdleToSit");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		noot.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialogEugeneDemandsFighters0);
		eugene.LookAt(willa);
		yield return UnitMoveToTarget(willa, targetWillaToCage);
		willa.LookAt(eugene);
		yield return HAGIS.DialogShow(dialogEugeneDemandsFighters1);
		player2.SetTeamType(UnitTeam.Type.NPC);
		player2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		player2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		eugene.LookInDirection(OctDir.Down);
		DynamicCageColRight.gameObject.SetActive(value: false);
		yield return PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "OpenVertical");
		yield return UnitMoveToTarget(player1, targetCageExit);
		DynamicCageColRight.gameObject.SetActive(value: true);
		yield return fighterBig.unitModel.Play("CsTransStunnedToCIdle", looping: false, crouched: true);
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		yield return CreateTimeCondition(1f);
		fighterBig.LookInDirection(OctDir.Right);
		yield return UnitMoveToTarget(fighterBig, targetFightRunStart);
		PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "CloseVertical");
		UnitMoveToTarget(player1, targetFinalGoon2Spawn);
		yield return CreateTimeCondition(1f);
		fighterBig.LookAt(player1);
		player1.LookAt(fighterBig);
		UIObjectives.Inst.CompleteAndSetMainObjective(objWinFightString);
		fighterBig.SetTeamType(UnitTeam.Type.Enemy);
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatIdle);
		GC.Inst.CutsceneEnd();
		SKIP_POINT("Cutscene 3 in the Arena has occurred. Player needs to fight.");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultSit");
		eugene.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		finalGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		finalGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultSit");
		eugene.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		finalGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		finalGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		round2Goon1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		round2Goon2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		finalGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		finalGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return CreateTimeCondition(1f);
		MusicPlay("event:/music/tracks/combat/bt arena");
		EnsureFighterBigHasExtraMovement();
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return null;
		MusicStop();
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		yield return Wait.While(willa.LookAt(eugene));
		eugene.LookAt(willa);
		yield return HAGIS.DialogShow(dialogDoubleOrNothing);
		eugene.LookInDirection(OctDir.Down);
		yield return UnitPlayAnimation(noot, "CsTransSitToDIdle");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "DefaultIdle");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		noot.LookInDirection(OctDir.Left);
		yield return HAGIS.DialogShow(dialogDoubleOrNothing2);
		DynamicCageColLeft.gameObject.SetActive(value: false);
		round2Goon1.gameObject.SetActive(value: true);
		yield return UnitTeleportToTarget(round2Goon1, targetFightEntrance);
		yield return UnitMoveToTarget(finalGoon1, targetGuardMove, null, 5f);
		finalGoon1.LookInDirection(OctDir.Down);
		yield return UnitMoveToTarget(round2Goon1, targetFightRound2b, null, 5f);
		round2Goon2.gameObject.SetActive(value: true);
		yield return UnitTeleportToTarget(round2Goon2, targetFightEntrance);
		yield return UnitMoveToTarget(round2Goon2, targetFightRound2a, null, 5f);
		yield return UnitMoveToTarget(finalGoon1, targetGuard, null, 5f);
		finalGoon1.LookInDirection(OctDir.Right);
		DynamicCageColLeft.gameObject.SetActive(value: true);
		player2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		player2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		DynamicCageColRight.gameObject.SetActive(value: false);
		yield return PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "OpenVertical");
		yield return UnitMoveToTarget(player2, targetNoot4, OctDir.Left);
		DynamicCageColRight.gameObject.SetActive(value: true);
		PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "CloseVertical");
		player2.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/bt arena");
		yield return CombatBegin(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objWinFightString);
		MusicStop();
		willa.LookAt(eugene);
		eugene.LookAt(willa);
		player2.LookAt(eugene);
		SKIP_POINT("Cutscene 4 in the Arena has occurred. Player needs to fight.");
		yield return UnitMoveToTarget(player1, targetCageExit);
		yield return HAGIS.DialogShow(dialogEugenePissed);
		eugene.LookInDirection(OctDir.Down);
		GC.Inst.CutsceneBegin();
		DynamicCageColLeft.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(dialogDoSomething);
		UnitMoveToTarget(finalGoon1, targetFinalPlayer, null, 5f);
		UnitMoveToTarget(finalGoon2, targetFightRun3, null, 5f);
		yield return UnitMoveToTarget(finalGoon3, targetFightRun1, null, 5f);
		yield return UnitMoveToTarget(player1, targetFinalGoon2Spawn, null, 5f);
		player1.LookAt(finalGoon1);
		finalGoon1.LookAt(player1);
		finalGoon2.LookAt(player1);
		finalGoon3.LookAt(player1);
		DynamicCageColRight.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(noot, targetCageEntrance, OctDir.Left);
		UnitPlayAnimation(noot, "DefaultInteract");
		yield return PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "OpenVertical");
		yield return UnitMoveToTarget(noot, targetNoot4, null, 5f);
		DynamicCageColLeft.gameObject.SetActive(value: true);
		DynamicCageColRight.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(dialogGotYou);
		finalGoon1.SetTeamType(UnitTeam.Type.Enemy);
		finalGoon2.SetTeamType(UnitTeam.Type.Enemy);
		finalGoon3.SetTeamType(UnitTeam.Type.Enemy);
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		finalGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		finalGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		noot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		finalGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		finalGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		finalGoon3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		noot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/bt arena");
		CombatBegin(UnitTeam.Type.Player);
		PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "CloseVertical");
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(tutorial_MuscleIntro);
		CutsceneEnd();
		yield return CombatWaitUntilComplete();
		yield return PlayMapAnimation(arenaLogic.Map, "MA_BlindTigerFence_RDoor", "OpenVertical");
		yield return null;
		MusicStop();
		GC.Inst.CutsceneBegin();
		noot.SetTeamType(UnitTeam.Type.NPC);
		yield return null;
		SKIP_POINT("Skipped all Arena Combat - Mund and Noot Cutscene");
		yield return UnitMoveToTarget(noot, targetFightBigStart);
		noot.LookAt(eugene);
		willa.LookAt(eugene);
		player2.LookAt(eugene);
		yield return HAGIS.DialogShow(dialogAllBetsFinal);
		yield return UnitMoveToTarget(noot, targetFinalPlayer, OctDir.Up);
		yield return null;
		yield return noot.unitModel.Play(UnitModel.AnimID.DefaultPickup);
		yield return CreateTimeCondition(0.5f);
		noot.unitModel.Play(UnitModel.AnimID.DefaultInteract);
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/show augment", sfx_noot_returns_augments);
		yield return CreateTimeCondition(1f);
		DynamicCageColRight.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(noot, arenaToBar);
		noot.LookInDirection(OctDir.Down);
		UnitTeleportToMapViaEntranceTile(noot, camToBar, targetNootCamEnd);
		eugene.LookAt(willa);
		yield return HAGIS.DialogShow(dialogTakeNote);
		GC.Inst.CutsceneEnd();
		yield return CutscenePlay("A1O5_Cutscene_MundLeaves");
		MusicStop();
		DynamicCageColLeft.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objLeaveString);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(DialogExhausedWilla);
		arenaToBar.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(barLogic.Map);
		NootOutro.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/basic/bt piano");
		yield return HAGIS.DialogShow(ambientThankNoot);
		yield return MapWaitUntilVisible(camLogic.Map);
		SKIP_POINT("Back outside in Cambridge for final cutscene");
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objLeaveString);
		camLogic.CanTeammatesFollow = false;
		UnitMoveToTarget(noot, targetNootCamEnd);
		noot.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(1.5f);
		HAGIS.DialogShow(DialogTheresNoot);
		yield return CreateTriggerCondition(NootOutro.OnTriggered);
		GC.Inst.CutsceneBegin();
		willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialogNootOutro);
		yield return CreateTimeCondition(1f);
		GC.Inst.CutsceneEnd();
	}

	private void EnsureFighterBigHasExtraMovement()
	{
		if (!fighterBig.abilities.Exists<Ability_DEBUG_Movement_Proxy>())
		{
			Ability_DEBUG_Movement_Proxy ability_DEBUG_Movement_Proxy = fighterBig.abilities.Add<Ability_DEBUG_Movement_Proxy>(null, isUpgraded: false);
			int movementMod = 1;
			ability_DEBUG_Movement_Proxy.movementMod = movementMod;
		}
	}
}
public class HAGIS_A1O5_CageFight : HAGIS
{
	private Unit fighterBig;

	private Unit fighterFast;

	private UnitTarget ulyssesOriginPos;

	private UnitTarget targetFightRun1;

	private UnitTarget targetFightRun2;

	private UnitTarget targetFightRun3;

	private UnitTarget targetFightRun4;

	private UnitTarget targetFightRun5;

	private UnitTarget targetFightRun6;

	private UnitTarget targetFightRun7;

	private UnitTarget targetFastToBig;

	private DialogData dialogNootIntro;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		dialogNootIntro = HAGIS.DialogLoad("Dialogs/A1O5/DialogNootIntro");
		fighterBig = GC.Inst.GetUnitWithId("FD2_T1Bar3_BlindTigerArena_UnitSpawn");
		fighterFast = GC.Inst.GetUnitWithId("DDE_T1Bar3_BlindTigerArena_UnitSpawn");
		ulyssesOriginPos = MR.Inst.GetUnitTarget("2E5_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun1 = MR.Inst.GetUnitTarget("F71_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun2 = MR.Inst.GetUnitTarget("D8F_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun3 = MR.Inst.GetUnitTarget("36E_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun4 = MR.Inst.GetUnitTarget("592_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun5 = MR.Inst.GetUnitTarget("92D_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun6 = MR.Inst.GetUnitTarget("9C7_T1Bar3_BlindTigerArena_UnitTarget");
		targetFightRun7 = MR.Inst.GetUnitTarget("296_T1Bar3_BlindTigerArena_UnitTarget");
		targetFastToBig = MR.Inst.GetUnitTarget("FE9_T1Bar3_BlindTigerArena_UnitTarget");
		LogicRoot arenaLogic = GetLogicUsingArtName("T1Bar3_BlindTigerArena");
		yield return null;
		yield return MapWaitUntilVisible(arenaLogic.Map);
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		fighterFast.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		fighterFast.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		float ulyssesCombatSpeed = 4.5f;
		float triggerCombatSpeed = 5.5f;
		fighterFast.LookAt(fighterBig);
		fighterBig.SetTeamType(UnitTeam.Type.Enemy);
		do
		{
			yield return UnitMoveToTarget(fighterBig, targetFightRun2, null, ulyssesCombatSpeed);
			fighterBig.LookAt(fighterFast);
			yield return CreateTimeCondition(0.2f);
			fighterBig.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
			yield return CreateTimeCondition(0.5f);
			fighterBig.unitModel.PlayAndReturnToIdle("CombatAttackMelee");
			yield return UnitMoveToTarget(fighterFast, targetFightRun5, null, triggerCombatSpeed);
			fighterFast.LookAt(fighterBig);
			if (dialogNootIntro.completed)
			{
				break;
			}
			yield return CreateTimeCondition(0.2f);
			yield return fighterFast.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
			yield return CreateTimeCondition(0.2f);
			MR.Inst.UnitAttackUnit(fighterFast.generatedID, fighterBig.generatedID, meleeAttack: false, Combat.HitType.Miss, string.Empty, updateIdle: true, pauseForEvent: false);
			yield return Wait.ForChildren;
			yield return CreateTimeCondition(0.25f);
			fighterBig.LookAt(fighterFast);
			if (dialogNootIntro.completed)
			{
				break;
			}
			yield return CreateTimeCondition(0.5f);
			yield return UnitMoveToTarget(fighterBig, targetFightRun1, null, ulyssesCombatSpeed);
			yield return CreateTimeCondition(0.1f);
			fighterBig.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
			yield return CreateTimeCondition(0.5f);
			fighterBig.unitModel.PlayAndReturnToIdle("CombatAttackMelee");
			yield return CreateTimeCondition(0.2f);
			yield return UnitMoveToTarget(fighterFast, targetFightRun6, null, triggerCombatSpeed);
			fighterFast.LookAt(fighterBig);
			yield return CreateTimeCondition(0.1f);
			yield return fighterFast.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
			yield return CreateTimeCondition(0.2f);
			MR.Inst.UnitAttackUnit(fighterFast.generatedID, fighterBig.generatedID, meleeAttack: false, Combat.HitType.Miss, string.Empty, updateIdle: true, pauseForEvent: false);
			yield return Wait.ForChildren;
			yield return CreateTimeCondition(0.25f);
			if (dialogNootIntro.completed)
			{
				break;
			}
			yield return UnitMoveToTarget(fighterBig, targetFightRun7, null, ulyssesCombatSpeed);
			yield return CreateTimeCondition(0.1f);
			fighterBig.unitModel.PlayAndReturnToIdle("CombatAttackMelee");
			yield return CreateTimeCondition(0.2f);
			yield return UnitMoveToTarget(fighterFast, targetFightRun3, null, triggerCombatSpeed);
			fighterFast.LookAt(fighterBig);
			if (dialogNootIntro.completed)
			{
				break;
			}
			yield return UnitMoveToTarget(fighterBig, ulyssesOriginPos, null, ulyssesCombatSpeed);
			fighterFast.LookAt(fighterBig);
			fighterBig.LookAt(fighterFast);
			yield return CreateTimeCondition(0.5f);
			yield return fighterBig.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
			yield return CreateTimeCondition(1f);
		}
		while (!dialogNootIntro.completed);
		fighterBig.SetTeamType(UnitTeam.Type.NPC);
		fighterBig.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		fighterFast.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		GC.Inst.CutsceneBegin();
		yield return UnitMoveToTarget(fighterBig, ulyssesOriginPos, OctDir.Down);
		fighterFast.LookAt(fighterBig);
		fighterBig.unitModel.Play(UnitModel.AnimID.TransDIdleToCIdle);
		yield return CreateTimeCondition(1f);
		fighterBig.unitModel.Play(UnitModel.AnimID.TransCIdleToCCrouch);
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatCrouchHit);
		yield return UnitMoveToTarget(fighterFast, targetFastToBig);
		fighterFast.LookAt(fighterBig);
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatAttackMelee);
		yield return CreateTimeCondition(0.2f);
		fighterFast.unitModel.Play(UnitModel.AnimID.CombatDeath);
		yield return CreateTimeCondition(1f);
		fighterBig.LookInDirection(OctDir.Right);
		string attackAnimName = "CsCombatSmash";
		float attackAnimLength = fighterBig.unitModel.GetAnimDuration("CsCombatSmash");
		fighterBig.unitModel.Play(attackAnimName, looping: true);
		yield return Wait.ForSeconds(attackAnimLength * 3f);
		fighterFast.Hide(makeInactive: true);
		fighterBig.unitModel.Play(UnitModel.AnimID.CombatIdle);
		yield return CreateTimeCondition(1f);
		GC.Inst.CutsceneEnd();
	}
}
public class HAGIS_A1O6 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Noot;

	private Unit Ambrosia;

	private Unit SisterA;

	private Unit SisterB;

	private Unit Train1Compiler;

	private Unit Train1Compiler2;

	private Unit Train1LeglessNPC;

	private Unit Train2Fusel;

	private Unit Train2Fusel2;

	private Unit Train2FuselVictim;

	private Unit Train3SittingWoman;

	private UnitTarget TargetWilla;

	private UnitTarget TargetAmbrosia1;

	private UnitTarget TargetAmbrosia2;

	private UnitTarget TargetAmbrosia3;

	private UnitTarget TargetAmbrosia4;

	private UnitTarget T_SlagsToGraveyard;

	private UnitTarget TargetArchi;

	private UnitTarget TargetArchi1;

	private UnitTarget T_AdaPort;

	private UnitTarget T_AdaPortConfrontation;

	private UnitTarget TargetSisterA01;

	private UnitTarget TargetSisterA02;

	private UnitTarget TargetSisterAToCover;

	private UnitTarget TargetWillaToSister;

	private UnitTarget TargetArchiToSister;

	private UnitTarget TargetChosenCharToSis;

	private UnitTarget TargetNootToSis;

	private UnitTarget TargetSisterB01;

	private UnitTarget TargetSisterB02;

	private UnitTarget T_WillaCoverS;

	private UnitTarget T_NootCoverS;

	private UnitTarget T_ArchiCoverS;

	private UnitTarget T_PortWilla;

	private UnitTarget T_PortNoot;

	private UnitTarget T_PortNootIntro;

	private UnitTarget T_PortNootIntro2;

	private UnitTarget T_PortArchiIntro;

	private UnitTarget T_PortArchiIntro2;

	private UnitTarget T_SecondSisterPostCombatSpot;

	private TileActionDialog TalkToAmbrosia;

	private TileActionDialog TalkToAmbrosia1;

	private TileActionDialog TalkToLady;

	private TileActionDialog TalkToSlagFolk;

	private TileActionDialog D_TalkToFisherman;

	private TileActionDialog D_Train1Compilers;

	private TileActionDialog D_Train1LeglessNPC;

	private TileActionDialog D_Train2Fusels;

	private TileActionSwapMap ParkToSubway;

	private TileActionSwapMap ParkToGraveyard;

	private TileActionSwapMap SubwayToThePark;

	private TileActionSwapMap SubwayToTrain;

	private TileActionSwapMap TrainToSubwayFiles;

	private TileActionSwapMap TrainToSubwayPort;

	private TileActionSwapMap TrainToSubwaySlags;

	private TileActionSwapMap SlagsToSlagCrater;

	private TileActionSwapMap SlagsToSubway;

	private TileActionSwapMap SlagsToSlagsEnt;

	private TileActionSwapMap SubwaySlagsToSlagsEnt;

	private TileActionSwapMap SubwaySlagsToTrain;

	private TileActionSwapMap PortEntToPort;

	private TileActionSwapMap PortEntToSubway;

	private TileActionSwapMap PortMainToPortEnt;

	private TileActionSwapMap PortSubwayToPortEnt;

	private TileActionSwapMap PortSubwayToTrain;

	private TileActionSwapMap PortMainToGraveyard;

	private TileActionSwapMap SlagsToGraveyard;

	private TileActionSwapMap GraveyardToPark;

	private TileActionInteraction TrainToPark;

	private TileActionInteraction I_TalkToAmrita;

	private TileActionInteraction I_TalkToAmbro;

	private TileActionInteraction TrainToPortEnt;

	private TileActionInteraction TrainToSlagsEnt;

	private TileActionInteraction AN231Core1;

	private TileActionInteraction AN251Core2;

	private TileTrigger T_SiterBTrigger;

	private DialogData dialog_AmbrosiaFormer1;

	private DialogData dialog_AmbrosiaFormer2;

	private DialogData dialog_AmbrosiaFormer3;

	private DialogData dialog_WhatShouldISay;

	private DialogData dialog_AmbrosiaOnTheBench;

	private DialogData dialog_AmbrosiaScrag;

	private DialogData dialog_GoAway;

	private DialogData dialog_WillaNoProblem;

	private DialogData dialog_WillaWhereIsShe;

	private DialogData dialog_ImBeingPunished;

	private DialogData dialog_AfterBattel;

	private DialogData dialog_AmbrosiaCongratulations;

	private DialogData dialog_AmbrosiaMyParents;

	private DialogData dialog_LikeWedLetYou;

	private DialogData dialog_MissionComplete;

	private DialogData dialog_AdaDramatic;

	private DialogData dialog_IKnowYoureThere;

	private DialogData dialog_WillaGolden;

	private DialogData dialog_AmritaEnough;

	private DialogData dialog_MySisterSentYou;

	private DialogData dialog_SpreadOut;

	private DialogData dialog_AfterBattle1;

	private DialogData ambient_AmritaRetreats;

	private DialogData ambient_WillaSuccess;

	private DialogData ambient_AdaOnDefeat;

	private DialogData ambient_AmritaOnDefeat;

	private DialogData ambient_WillaRealisation;

	private DialogData ambient_ADARetreats;

	private DialogData ambient_Fisherman1;

	private DialogData tutorial_RunnerIntro;

	private string objFindAmbrosiaString = "OBJECTIVES_A1O6_01";

	private string objKillSisterAString = "OBJECTIVES_A1O6_02";

	private string objPickUpCore1String = "OBJECTIVES_A1O6_03";

	private string objKillSisterBString = "OBJECTIVES_A1O6_04";

	private string objPickUpCore2String = "OBJECTIVES_A1O6_05";

	private string objTalkToAmbrosiaString = "OBJECTIVES_A1O6_06";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot DetGraveyardLogic = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot DetParkLogic = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot SlagEntLogic = GetLogicUsingArtName("T1Slags_Ent");
		LogicRoot SlagLogic = GetLogicUsingArtName("T1Slags");
		LogicRoot PortEnt = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot PortLogic = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot SubwayLogic = GetLogicUsingArtName("T1Subway_Station_Files");
		LogicRoot SubwayPort = GetLogicUsingArtName("T1Subway_Station_PortHara");
		LogicRoot SubwaySlags = GetLogicUsingArtName("T1Subway_Station_Slags");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		Archi = GC.Inst.GetUnitWithId("92C_T1Slags_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("586_T1DetritumPark_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("1B1_T1DetritumPark_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("A65_T1DetritumPark_UnitSpawn");
		Train1Compiler = GC.Inst.GetUnitWithId("B3B_T1Subway_TrainInterior_UnitSpawn");
		Train1Compiler2 = GC.Inst.GetUnitWithId("A2F_T1Subway_Station_Files_UnitSpawn");
		Train1LeglessNPC = GC.Inst.GetUnitWithId("AEC_T1Subway_TrainInterior_UnitSpawn");
		Train2Fusel = GC.Inst.GetUnitWithId("CD4_T1Subway_TrainInterior_UnitSpawn");
		Train2Fusel2 = GC.Inst.GetUnitWithId("4F8_T1Subway_TrainInterior_UnitSpawn");
		Train2FuselVictim = GC.Inst.GetUnitWithId("C50_T1Subway_TrainInterior_UnitSpawn");
		Train3SittingWoman = GC.Inst.GetUnitWithId("192_T1Subway_TrainInterior_UnitSpawn");
		Ambrosia.AddInitialPartyAbilities();
		SisterA = GC.Inst.GetUnitWithId("19B_T1Slags_UnitSpawn");
		SisterB = GC.Inst.GetUnitWithId("AD2_T1Port2_HaraMainBay_UnitSpawn");
		TalkToAmbrosia1 = MR.Inst.GetTileActionDialog("594_T1DetritumPark_TileActionDialog");
		D_TalkToFisherman = MR.Inst.GetTileActionDialog("9F9_T1Port1_HaraEntrance_TileActionDialog");
		TalkToSlagFolk = MR.Inst.GetTileActionDialog("25A_T1Slags_Ent_TileActionDialog");
		D_Train1Compilers = MR.Inst.GetTileActionDialog("158_T1Subway_Station_Files_TileActionDialog");
		D_Train1LeglessNPC = MR.Inst.GetTileActionDialog("3ED_T1Subway_TrainInterior_TileActionDialog");
		D_Train2Fusels = MR.Inst.GetTileActionDialog("2A4_T1Subway_TrainInterior_TileActionDialog");
		TrainToPark = MR.Inst.GetTileActionInteraction("7C4_T1Subway_TrainInterior_TileActionInteraction");
		TrainToPortEnt = MR.Inst.GetTileActionInteraction("448_T1Subway_TrainInterior_TileActionInteraction");
		TrainToSlagsEnt = MR.Inst.GetTileActionInteraction("1EE_T1Subway_TrainInterior_TileActionInteraction");
		I_TalkToAmbro = MR.Inst.GetTileActionInteraction("B56_T1DetritumGraveyard_TileActionInteraction");
		ParkToSubway = MR.Inst.GetTileActionSwapMap("863_T1DetritumPark_TileActionSwapMap");
		ParkToGraveyard = MR.Inst.GetTileActionSwapMap("D3B_T1DetritumPark_TileActionSwapMap");
		SubwayToThePark = MR.Inst.GetTileActionSwapMap("654_T1Subway_Station_TileActionSwapMap");
		SubwayToTrain = MR.Inst.GetTileActionSwapMap("85B_T1Subway_Station_TileActionSwapMap");
		TrainToSubwayFiles = MR.Inst.GetTileActionSwapMap("788_T1Subway_TrainInterior_TileActionSwapMap");
		TrainToSubwayPort = MR.Inst.GetTileActionSwapMap("6B5_T1Subway_TrainInterior_TileActionSwapMap");
		TrainToSubwaySlags = MR.Inst.GetTileActionSwapMap("191_T1Subway_TrainInterior_TileActionSwapMap");
		SlagsToSlagCrater = MR.Inst.GetTileActionSwapMap("088_T1Slags_Ent_TileActionSwapMap");
		SlagsToSubway = MR.Inst.GetTileActionSwapMap("1BE_T1Slags_Ent_TileActionSwapMap");
		SlagsToSlagsEnt = MR.Inst.GetTileActionSwapMap("CD8_T1Slags_TileActionSwapMap");
		SubwaySlagsToSlagsEnt = MR.Inst.GetTileActionSwapMap("4A6_T1Subway_Station_Slags_TileActionSwapMap");
		SubwaySlagsToTrain = MR.Inst.GetTileActionSwapMap("18E_T1Subway_Station_Slags_TileActionSwapMap");
		PortEntToPort = MR.Inst.GetTileActionSwapMap("B58_T1Port2_HaraMainBay_TileActionSwapMap");
		PortEntToSubway = MR.Inst.GetTileActionSwapMap("5F7_T1Port1_HaraEntrance_TileActionSwapMap");
		PortMainToPortEnt = MR.Inst.GetTileActionSwapMap("972_T1Port2_HaraMainBay_TileActionSwapMap");
		PortSubwayToPortEnt = MR.Inst.GetTileActionSwapMap("446_T1Subway_Station_PortHara_TileActionSwapMap");
		PortSubwayToTrain = MR.Inst.GetTileActionSwapMap("37A_T1Subway_Station_PortHara_TileActionSwapMap");
		GraveyardToPark = MR.Inst.GetTileActionSwapMap("348_T1DetritumGraveyard_TileActionSwapMap");
		PortMainToGraveyard = MR.Inst.GetTileActionSwapMap("111_T1Port2_HaraMainBay_TileActionSwapMap");
		SlagsToGraveyard = MR.Inst.GetTileActionSwapMap("32A_T1Slags_TileActionSwapMap");
		AN231Core1 = MR.Inst.GetTileActionInteraction("7F4_T1Slags_TileActionInteraction");
		AN251Core2 = MR.Inst.GetTileActionInteraction("BF3_T1Port2_HaraMainBay_TileActionInteraction");
		I_TalkToAmrita = MR.Inst.GetTileActionInteraction("1EF_T1Slags_TileActionInteraction");
		T_SiterBTrigger = MR.Inst.GetTileTrigger("AFF_T1Port2_HaraMainBay_TileTrigger");
		TargetWilla = MR.Inst.GetUnitTarget("8DF_T1DetritumGraveyard_UnitTarget");
		TargetArchi = MR.Inst.GetUnitTarget("2D7_T1Port2_HaraMainBay_UnitTarget");
		TargetArchi1 = MR.Inst.GetUnitTarget("030_T1DetritumGraveyard_UnitTarget");
		TargetAmbrosia1 = MR.Inst.GetUnitTarget("D2C_T1DetritumGraveyard_UnitTarget");
		TargetAmbrosia2 = MR.Inst.GetUnitTarget("58B_T1DetritumGraveyard_UnitTarget");
		TargetAmbrosia3 = MR.Inst.GetUnitTarget("49D_T1DetritumPark_UnitTarget");
		TargetAmbrosia4 = MR.Inst.GetUnitTarget("AD3_T1DetritumGraveyard_UnitTarget");
		TargetSisterA01 = MR.Inst.GetUnitTarget("C9E_T1DetritumGraveyard_UnitTarget");
		TargetSisterA02 = MR.Inst.GetUnitTarget("E66_T1Slags_UnitTarget");
		TargetSisterAToCover = MR.Inst.GetUnitTarget("F5A_T1Slags_UnitTarget");
		TargetWillaToSister = MR.Inst.GetUnitTarget("433_T1Slags_UnitTarget");
		TargetArchiToSister = MR.Inst.GetUnitTarget("519_T1Slags_UnitTarget");
		TargetChosenCharToSis = MR.Inst.GetUnitTarget("68F_T1Slags_UnitTarget");
		T_AdaPort = MR.Inst.GetUnitTarget("5F2_T1Port2_HaraMainBay_UnitTarget");
		T_AdaPortConfrontation = MR.Inst.GetUnitTarget("1B7_T1Port2_HaraMainBay_UnitTarget");
		TargetSisterB01 = MR.Inst.GetUnitTarget("BD2_T1DetritumGraveyard_UnitTarget");
		TargetSisterB02 = MR.Inst.GetUnitTarget("3D2_T1Port2_HaraMainBay_UnitTarget");
		T_WillaCoverS = MR.Inst.GetUnitTarget("EB5_T1Slags_UnitTarget");
		T_ArchiCoverS = MR.Inst.GetUnitTarget("D96_T1Slags_UnitTarget");
		UnitTarget T_SisterToDropPoint = MR.Inst.GetUnitTarget("0A9_T1Slags_UnitTarget");
		T_NootCoverS = MR.Inst.GetUnitTarget("AF6_T1Slags_UnitTarget");
		TargetNootToSis = MR.Inst.GetUnitTarget("6C2_T1Slags_UnitTarget");
		T_SlagsToGraveyard = MR.Inst.GetUnitTarget("671_T1Slags_UnitTarget");
		T_PortWilla = MR.Inst.GetUnitTarget("8EC_T1Port2_HaraMainBay_UnitTarget");
		T_PortNoot = MR.Inst.GetUnitTarget("77B_T1Port2_HaraMainBay_UnitTarget");
		T_PortNootIntro = MR.Inst.GetUnitTarget("BF8_T1Port2_HaraMainBay_UnitTarget");
		T_PortArchiIntro = MR.Inst.GetUnitTarget("F83_T1Port2_HaraMainBay_UnitTarget");
		T_PortArchiIntro2 = MR.Inst.GetUnitTarget("729_T1Port2_HaraMainBay_UnitTarget");
		T_PortNootIntro2 = MR.Inst.GetUnitTarget("F6C_T1Port2_HaraMainBay_UnitTarget");
		UnitTarget sfx_first_sister_drops_core = MR.Inst.GetUnitTarget("F5A_T1Slags_UnitTarget");
		UnitTarget sfx_second_sister_drops_core = MR.Inst.GetUnitTarget("8EA_T1Port2_HaraMainBay_UnitTarget");
		UnitTarget sfx_core_1_pickup = MR.Inst.GetUnitTarget("0A9_T1Slags_UnitTarget");
		UnitTarget sfx_core_2_pickup = MR.Inst.GetUnitTarget("729_T1Port2_HaraMainBay_UnitTarget");
		T_SecondSisterPostCombatSpot = MR.Inst.GetUnitTarget("8EA_T1Port2_HaraMainBay_UnitTarget");
		dialog_AmbrosiaFormer1 = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogAmbrosiaFormer1");
		dialog_AmbrosiaFormer2 = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogAmbrosiaFormer2");
		dialog_AmbrosiaFormer3 = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogAmbrosiaFormer3");
		dialog_WhatShouldISay = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogWhatShouldISay");
		dialog_GoAway = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogGoAway");
		dialog_AmbrosiaOnTheBench = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogAmbrosiaOnTheBench");
		dialog_AmbrosiaScrag = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogAmbrosiaScrag");
		dialog_WillaNoProblem = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogWillaNoProblem");
		dialog_WillaWhereIsShe = HAGIS.DialogLoad("Dialogs/A1O6/Park/DialogWillaWhereIsShe");
		dialog_AmbrosiaCongratulations = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/DialogAmbrosiaCongratulations");
		dialog_AmbrosiaMyParents = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/DialogAmbrosiaMyParents");
		dialog_LikeWedLetYou = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/DialogLikeWedLetYou");
		dialog_AfterBattle1 = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/DialogAfterBattle1");
		dialog_MissionComplete = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/DialogMissionComplete");
		ambient_AdaOnDefeat = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/AmbientAdaDefeated");
		ambient_WillaRealisation = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/AmbientWillaRealisation");
		ambient_AmritaOnDefeat = HAGIS.DialogLoad("Dialogs/A1O6/Graveyard/AmbientAmritaDefeated");
		dialog_AdaDramatic = HAGIS.DialogLoad("Dialogs/A1O6/PortCenter/DialogAdaDramatic");
		dialog_IKnowYoureThere = HAGIS.DialogLoad("Dialogs/A1O6/PortCenter/DialogIKnowYoureThere");
		dialog_WillaGolden = HAGIS.DialogLoad("Dialogs/A1O6/PortCenter/DialogWillaGolden");
		ambient_ADARetreats = HAGIS.DialogLoad("Dialogs/A1O6/PortCenter/AmbientADARetreats");
		ambient_Fisherman1 = HAGIS.DialogLoad("Dialogs/A1O6/PortCenter/Ambeint_Fisherman1");
		dialog_MySisterSentYou = HAGIS.DialogLoad("Dialogs/A1O6/SlagCrater/DialogMySisterSentYou");
		dialog_AmritaEnough = HAGIS.DialogLoad("Dialogs/A1O6/SlagCrater/DialogAmritaEnough");
		dialog_SpreadOut = HAGIS.DialogLoad("Dialogs/A1O6/SlagCrater/DialogSpreadOut");
		ambient_WillaSuccess = HAGIS.DialogLoad("Dialogs/A1O6/SlagCrater/AmbientWillaSuccess");
		ambient_AmritaRetreats = HAGIS.DialogLoad("Dialogs/A1O6/SlagCrater/AmbientAmritaRetreats");
		dialog_ImBeingPunished = HAGIS.DialogLoad("Dialogs/A1O6/Subway/DialogImBeingPunished");
		tutorial_RunnerIntro = HAGIS.DialogLoad("Dialogs/A1O6/TutorialDialogs/Tutorial_RunnerIntro");
		Ability_MaxHP SisterAHP = SisterA.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		SisterAHP.SetHPMod(10);
		Ability_MaxHP SisterBHP = SisterB.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		SisterBHP.SetHPMod(10);
		ParkToSubway.gameObject.SetActive(value: false);
		ParkToGraveyard.gameObject.SetActive(value: false);
		SubwayToThePark.gameObject.SetActive(value: false);
		SubwayToTrain.gameObject.SetActive(value: false);
		TrainToSubwayFiles.gameObject.SetActive(value: false);
		TrainToSubwayPort.gameObject.SetActive(value: false);
		TrainToSubwaySlags.gameObject.SetActive(value: false);
		SlagsToSlagCrater.gameObject.SetActive(value: false);
		SlagsToSubway.gameObject.SetActive(value: false);
		SlagsToSlagsEnt.gameObject.SetActive(value: false);
		SubwaySlagsToSlagsEnt.gameObject.SetActive(value: false);
		SubwaySlagsToTrain.gameObject.SetActive(value: false);
		PortEntToPort.gameObject.SetActive(value: false);
		PortEntToSubway.gameObject.SetActive(value: false);
		PortMainToPortEnt.gameObject.SetActive(value: false);
		PortSubwayToPortEnt.gameObject.SetActive(value: false);
		PortSubwayToTrain.gameObject.SetActive(value: false);
		AN231Core1.gameObject.SetActive(value: false);
		AN251Core2.gameObject.SetActive(value: false);
		TrainToPark.gameObject.SetActive(value: false);
		TrainToPortEnt.gameObject.SetActive(value: false);
		TrainToSlagsEnt.gameObject.SetActive(value: false);
		PortMainToGraveyard.gameObject.SetActive(value: false);
		SlagsToGraveyard.gameObject.SetActive(value: false);
		Train2Fusel.gameObject.SetActive(value: false);
		Train2Fusel2.gameObject.SetActive(value: false);
		Train2FuselVictim.gameObject.SetActive(value: false);
		Train3SittingWoman.gameObject.SetActive(value: false);
		D_Train2Fusels.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindAmbrosiaString);
		yield return null;
		MusicPlay("event:/music/tracks/basic/ambrosia underscore");
		DetParkLogic.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(dialog_WhatShouldISay.OnComplete);
		UIObjectives.Inst.CompleteObjective(objFindAmbrosiaString);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_GoAway);
		yield return UnitPlayAnimation(Ambrosia, "CsDefaultSitToDIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return UnitPlayAnimation(Ambrosia, "DefaultIdle");
		Ambrosia.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/basic/ambrosia theme");
		yield return HAGIS.DialogShow(dialog_AmbrosiaScrag);
		yield return UnitMoveToUnit(Ambrosia, Willa);
		yield return HAGIS.DialogShow(dialog_AmbrosiaFormer1);
		Willa.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(dialog_AmbrosiaFormer2);
		Willa.LookInDirection(OctDir.Left);
		yield return HAGIS.DialogShow(dialog_AmbrosiaFormer3);
		yield return UnitMoveToTarget(Ambrosia, TargetAmbrosia3);
		Ambrosia.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_WillaNoProblem);
		yield return UnitPlayAnimation(Ambrosia, "CsDefaultDIdleToSit");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		Ambrosia.UpdateIdleAnim();
		HAGIS.DialogShow(dialog_AmbrosiaOnTheBench);
		yield return CreateTriggerCondition(dialog_AmbrosiaOnTheBench.OnComplete);
		TalkToAmbrosia1.gameObject.SetActive(value: false);
		CutsceneEnd();
		SKIP_POINT("Mission Intro with Ambro completed");
		UIObjectives.Inst.CompleteAndSetMainObjective(objKillSisterAString);
		ParkToSubway.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/basic/stealth old full");
		yield return MapWaitUntilVisible(SubwayLogic.Map);
		PlayMapAnimation(SubwayLogic.Map, "MA_SubwayTrain", "Arriving");
		SubwayLogic.CanTeammatesFollow = true;
		yield return HAGIS.DialogShow(dialog_ImBeingPunished);
		yield return CreateTimeCondition(2f);
		PlayInterplay();
		SubwayToTrain.gameObject.SetActive(value: true);
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Close");
		yield return MapWaitUntilMidTransition(SubwayTrain);
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		HAGIS.ToggleShakeEnvironment(on: true);
		SubwayTrain.CanTeammatesFollow = true;
		SKIP_POINT("Player has entered the train");
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		TrainToSlagsEnt.gameObject.SetActive(value: true);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Slags_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		yield return CreateTriggerCondition(TrainToSlagsEnt.OnTriggered);
		yield return TeamMoveToMapViaEntranceTile(SlagsToSubway);
		yield return MapGoto(SlagEntLogic);
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Close");
		Train1LeglessNPC.gameObject.SetActive(value: false);
		Train1Compiler.gameObject.SetActive(value: false);
		Train1Compiler2.gameObject.SetActive(value: false);
		D_Train1LeglessNPC.gameObject.SetActive(value: false);
		D_Train1Compilers.gameObject.SetActive(value: false);
		D_Train2Fusels.gameObject.SetActive(value: true);
		Train2Fusel.gameObject.SetActive(value: true);
		Train2Fusel2.gameObject.SetActive(value: true);
		Train2FuselVictim.gameObject.SetActive(value: true);
		MusicStop();
		SlagEntLogic.CanTeammatesFollow = true;
		yield return null;
		TrainToSlagsEnt.gameObject.SetActive(value: false);
		SlagsToSlagCrater.gameObject.SetActive(value: true);
		SKIP_POINT("Player has entered the Slags");
		yield return MapWaitUntilVisible(SlagLogic.Map);
		MusicPlay("event:/music/tracks/basic/ambrosia theme");
		SlagLogic.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(I_TalkToAmrita.OnTriggered);
		UnitMoveToTarget(Archi, TargetArchiToSister, OctDir.Up);
		UnitMoveToTarget(Noot, TargetChosenCharToSis, OctDir.Up);
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(SisterA, "CsTransRiflingToDIdle");
		SisterA.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		SisterA.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return UnitPlayAnimation(SisterA, "DefaultIdle");
		SisterA.UpdateIdleAnim();
		SisterA.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialog_MySisterSentYou);
		UnitMoveToTarget(SisterA, TargetSisterAToCover, null, 5f);
		UnitMoveToTarget(Archi, T_ArchiCoverS);
		UnitMoveToTarget(Willa, T_WillaCoverS);
		yield return HAGIS.DialogShow(dialog_SpreadOut);
		CutsceneEnd();
		SKIP_POINT("Cutscene with First Sister Complete in Slags");
		MusicPlay("event:/music/tracks/combat/ada amrita");
		yield return CombatBegin(UnitTeam.Type.Enemy);
		SKIP_POINT("First Sister Drops Core");
		CutsceneBegin();
		yield return null;
		SisterA.Revive();
		yield return UnitMoveToTarget(SisterA, T_SisterToDropPoint);
		SisterA.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_AmritaEnough);
		UnitPlayAnimation(SisterA, "CsDefaultDropItem");
		yield return CreateTimeCondition(2.1f);
		AN231Core1.transform.position = SlagLogic.Map.CoordToWorldPos(SisterA.coord);
		AN231Core1.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_AmritaRetreats);
		Willa.LookAt(SisterA.gameObject.transform, keepEyeOn: true);
		Archi.LookAt(SisterA.gameObject.transform, keepEyeOn: true);
		Noot.LookAt(SisterA.gameObject.transform, keepEyeOn: true);
		yield return null;
		UnitMoveToMapViaExitTile(SisterA, SlagsToGraveyard, null, 5f);
		MusicPlay("event:/music/tracks/basic/stealth old full");
		yield return CreateTimeCondition(2f);
		Willa.LookAt(Archi);
		Archi.LookAt(Willa);
		yield return null;
		CutsceneEnd();
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objPickUpCore1String);
		SKIP_POINT("First Sister Defeated in the Slags");
		yield return CreateTriggerCondition(AN231Core1.OnTriggered);
		CutsceneBegin();
		yield return UnitPlayAnimation(Willa, "DefaultPickup");
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/pick up augment", sfx_core_1_pickup);
		AN231Core1.gameObject.SetActive(value: false);
		HAGIS.DialogShow(ambient_WillaSuccess);
		CutsceneEnd();
		yield return null;
		SlagsToSlagsEnt.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objKillSisterBString);
		yield return MapWaitUntilVisible(SlagEntLogic.Map);
		TalkToSlagFolk.gameObject.SetActive(value: false);
		TrainToSubwaySlags.gameObject.SetActive(value: true);
		SlagsToSlagCrater.gameObject.SetActive(value: false);
		SlagsToSubway.gameObject.SetActive(value: true);
		SisterA.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped to Slags Entrance");
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		TrainToSubwaySlags.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped to Subway Train");
		yield return CreateTimeCondition(2f);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_PortHara_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		TrainToPortEnt.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(TrainToPortEnt.OnTriggered);
		yield return TeamMoveToMapViaEntranceTile(PortEntToSubway);
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Close");
		yield return MapGoto(PortEnt);
		D_Train2Fusels.gameObject.SetActive(value: false);
		Train2Fusel.gameObject.SetActive(value: false);
		Train2Fusel2.gameObject.SetActive(value: false);
		Train2FuselVictim.gameObject.SetActive(value: false);
		Train3SittingWoman.gameObject.SetActive(value: true);
		MusicStop();
		PortEnt.CanTeammatesFollow = true;
		SKIP_POINT("Skipped to Port Ent");
		TrainToPortEnt.gameObject.SetActive(value: false);
		PortEntToPort.gameObject.SetActive(value: true);
		PlayMapAnimation(PortLogic.Map, "CH_Port_AugmentCrate", "DefaultEmpty");
		yield return MapWaitUntilVisible(PortLogic.Map);
		UnitMoveToTarget(Archi, T_PortArchiIntro, OctDir.Left, 3f);
		UnitMoveToTarget(Noot, T_PortNootIntro, OctDir.Left, 3f);
		MusicPlay("event:/music/tracks/basic/ambrosia theme");
		PortLogic.CanTeammatesFollow = true;
		PortEntToPort.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(T_SiterBTrigger._OnTriggered);
		CutsceneBegin();
		UnitMoveToTarget(Archi, T_PortArchiIntro2, OctDir.Down, 3f);
		yield return null;
		UnitMoveToTarget(Noot, T_PortNootIntro2, OctDir.Left, 3f);
		yield return UnitPlayAnimation(SisterB, "CsTransRiflingToDIdle");
		SisterB.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		SisterB.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return UnitPlayAnimation(SisterB, "DefaultIdle");
		SisterB.UpdateIdleAnim();
		yield return UnitMoveToTarget(SisterB, T_AdaPortConfrontation, null, 3f);
		SisterB.LookAt(Willa);
		Willa.LookAt(SisterB);
		Archi.LookAt(SisterB);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialog_IKnowYoureThere);
		UnitMoveToTarget(SisterB, T_AdaPort, null, 5f);
		yield return CreateAndCondition(UnitMoveToTarget(Noot, T_PortNoot, null, 4f), UnitMoveToTarget(Archi, TargetArchi, null, 4f), UnitMoveToTarget(Willa, T_PortWilla, null, 4f));
		CutsceneEnd();
		SKIP_POINT("Second Sister Fight started");
		MusicPlay("event:/music/tracks/combat/ada amrita");
		yield return CombatBegin(UnitTeam.Type.Enemy);
		MusicPlay("event:/music/tracks/basic/safety in numbers 1");
		SKIP_POINT("Second Sister Drops Core");
		CutsceneBegin();
		SisterB.Revive();
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(SisterB, T_SecondSisterPostCombatSpot, null, 3f);
		SisterB.LookAt(Willa.gameObject.transform);
		HAGIS.DialogShow(dialog_AdaDramatic);
		yield return CreateTimeCondition(2f);
		UnitPlayAnimation(SisterB, "CsDefaultDropItem");
		yield return CreateTimeCondition(1.4f);
		AN251Core2.transform.position = PortLogic.Map.CoordToWorldPos(SisterB.coord);
		AN251Core2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.8f);
		UnitMoveToMapViaExitTile(SisterB, PortMainToGraveyard, null, 5f);
		HAGIS.DialogShow(ambient_ADARetreats);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objPickUpCore2String);
		SKIP_POINT("Second Sister has been defeated");
		yield return CreateTriggerCondition(AN251Core2.OnTriggered);
		CutsceneBegin();
		yield return UnitPlayAnimation(Willa, "DefaultPickup");
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/pick up augment", sfx_core_2_pickup);
		AN251Core2.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(dialog_WillaGolden);
		CutsceneEnd();
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, GraveyardToPark, TargetAmbrosia2);
		UnitMoveToTarget(Ambrosia, TargetAmbrosia2);
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UnitPlayAnimation(Ambrosia, "DefaultIdle");
		Ambrosia.UpdateIdleAnim();
		yield return null;
		UnitLookInDirection(Ambrosia, OctDir.Up);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTalkToAmbrosiaString);
		PortMainToPortEnt.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(PortEnt.Map);
		D_TalkToFisherman.gameObject.SetActive(value: false);
		PortEntToSubway.gameObject.SetActive(value: true);
		TrainToSubwayPort.gameObject.SetActive(value: true);
		yield return MapWaitUntilMidTransition(SubwayTrain);
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		TrainToSubwayPort.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Files_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		TrainToPark.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(TrainToPark.OnTriggered);
		yield return TeamMoveToMapViaEntranceTile(ParkToSubway);
		yield return MapGoto(DetParkLogic);
		MusicStop();
		ParkToSubway.gameObject.SetActive(value: false);
		SisterB.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(dialog_WillaWhereIsShe);
		ParkToGraveyard.gameObject.SetActive(value: true);
		SKIP_POINT("Second Sister has been defeated");
		yield return MapWaitUntilVisible(DetGraveyardLogic.Map);
		UIObjectives.Inst.CancelObjective(objTalkToAmbrosiaString);
		MusicPlay("event:/music/tracks/basic/new savannah ex light");
		DetGraveyardLogic.CanTeammatesFollow = true;
		SKIP_POINT("Skipped moving to Graveyard");
		yield return CreateTriggerCondition(I_TalkToAmbro.OnTriggered);
		yield return CutscenePlay("A1O6_Cutscene_GivingAmbrosiaCores");
		SKIP_POINT("Skipped Graveyard cutscene");
		CutsceneBegin();
		MusicPlay("event:/music/tracks/basic/light tension 1");
		SisterA.gameObject.SetActive(value: true);
		SisterB.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(SisterA, TargetSisterA01, null, 4f);
		yield return UnitMoveToTarget(SisterB, TargetSisterB01, null, 4f);
		yield return Wait.While(Ambrosia.LookAt(SisterA));
		yield return Wait.While(Willa.LookAt(SisterB));
		yield return Wait.While(SisterA.LookAt(Ambrosia));
		yield return Wait.While(SisterB.LookAt(Ambrosia));
		HAGIS.DialogShow(ambient_WillaRealisation);
		yield return CreateTriggerCondition(ambient_WillaRealisation.OnComplete);
		Archi.LookAt(SisterA.gameObject.transform);
		Noot.LookAt(SisterB.gameObject.transform);
		HAGIS.DialogShow(dialog_LikeWedLetYou);
		yield return CreateTriggerCondition(dialog_LikeWedLetYou.OnComplete);
		UnitMoveToTarget(Ambrosia, TargetAmbrosia1, null, 5f);
		UnitMoveToTarget(Willa, TargetWilla, null, 5f);
		yield return UnitMoveToTarget(Archi, TargetArchi1, null, 5f);
		CutsceneEnd();
		GraveyardToPark.gameObject.SetActive(value: false);
		SKIP_POINT("fight the grannies!");
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/combat/amrita boss");
		MusicSetIntensity(0.1f);
		CutsceneBegin();
		yield return HAGIS.DialogShow(tutorial_RunnerIntro);
		CutsceneEnd();
		while (GC.Inst.IsInTurnMode())
		{
			HagletYieldTerm SisterADead = Wait.Until(SisterA.OnDeathComplete);
			HagletYieldTerm SisterBDead = Wait.Until(SisterB.OnDeathComplete);
			yield return CreateOrCondition(SisterADead, SisterBDead, CombatWaitUntilComplete());
			if (SisterADead.met)
			{
				yield return HAGIS.DialogShow(ambient_AmritaOnDefeat);
			}
			if (SisterBDead.met)
			{
				yield return HAGIS.DialogShow(ambient_AdaOnDefeat);
			}
		}
		MusicPlay("event:/music/tracks/basic/ambrosia underscore");
		CutsceneBegin();
		yield return UnitMoveToTarget(Ambrosia, TargetAmbrosia4);
		Ambrosia.LookAt(Willa.gameObject.transform);
		yield return UnitMoveToUnit(Willa, Ambrosia);
		Willa.LookAt(Ambrosia.gameObject.transform);
		yield return HAGIS.DialogShow(dialog_AfterBattle1);
		yield return UnitMoveToTarget(Ambrosia, GraveyardToPark);
		Ambrosia.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(dialog_MissionComplete);
		CutsceneEnd();
	}
}
public class HAGIS_A1O6_CrateOpen : HAGIS
{
	private TileActionGiveLoot crate;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot portLogic = GetLogicUsingArtName("T1Port2_HaraMainBay");
		crate = MR.Inst.GetTileActionGiveLoot("A3D_T1Port2_HaraMainBay_TileActionGiveLoot");
		yield return null;
		yield return CreateTriggerCondition(crate.OnTriggered);
		HagisLog("crate open");
	}
}
public class HAGIS_A1O8 : HAGIS
{
	[HideInInspector]
	public Unit Willa;

	[HideInInspector]
	public Unit Archi;

	[HideInInspector]
	public Unit Ambrosia;

	[HideInInspector]
	public Unit ThirdMember;

	[HideInInspector]
	public Unit Rupert;

	[HideInInspector]
	public Unit Molly;

	[HideInInspector]
	public Unit Mund;

	[HideInInspector]
	public Unit FuselGanster1;

	[HideInInspector]
	public Unit FuselGanster2;

	[HideInInspector]
	public Unit FuselC1;

	[HideInInspector]
	public Unit FuselC2;

	[HideInInspector]
	public Unit FuselC3;

	[HideInInspector]
	public Unit FuselS1;

	[HideInInspector]
	public Unit FuselS2;

	[HideInInspector]
	public Unit FuselS3;

	[HideInInspector]
	public Unit Shiner1;

	[HideInInspector]
	public Unit Shiner2;

	[HideInInspector]
	public Unit Shiner3;

	[HideInInspector]
	public Unit Shiner4;

	[HideInInspector]
	public Unit Shiner5;

	[HideInInspector]
	public Unit Shiner6;

	[HideInInspector]
	public Unit TrainNPC1;

	[HideInInspector]
	public Unit TrainNPC2;

	[HideInInspector]
	public Unit TrainNPC3;

	[HideInInspector]
	public Unit TrainNPC4;

	[HideInInspector]
	public Unit CambSubwayNPC1;

	[HideInInspector]
	public Unit CambSubwayNPC2;

	[HideInInspector]
	public Unit CambSubwayNPC3;

	[HideInInspector]
	public Unit CambSubwayNPC4;

	[HideInInspector]
	public Unit CambSubwayNPC5;

	[HideInInspector]
	public UnitTarget WillaSittingPoint;

	[HideInInspector]
	public UnitTarget T_Archi;

	[HideInInspector]
	public UnitTarget T_Ambrosia;

	[HideInInspector]
	public UnitTarget T_Chris;

	[HideInInspector]
	public UnitTarget TargetOffTrain;

	[HideInInspector]
	public UnitTarget TargetOffTrain2;

	[HideInInspector]
	public UnitTarget TargetWillaD1;

	[HideInInspector]
	public UnitTarget TargetAmbrosiaD1;

	[HideInInspector]
	public UnitTarget TargetAmbrosiaD2;

	[HideInInspector]
	public UnitTarget TargetArchiD1;

	[HideInInspector]
	public UnitTarget TargetArchiD2;

	[HideInInspector]
	public UnitTarget TargetChrisD1;

	[HideInInspector]
	public UnitTarget TargetRupertD1;

	[HideInInspector]
	public UnitTarget TargetRupertD2;

	[HideInInspector]
	public UnitTarget TargetAmbrosiaS1;

	[HideInInspector]
	public UnitTarget TargetArchiS1;

	[HideInInspector]
	public UnitTarget TargetChrisS1;

	[HideInInspector]
	public UnitTarget TargetWillaS1;

	[HideInInspector]
	public UnitTarget TargetWillaST1;

	[HideInInspector]
	public UnitTarget TargetArchiST1;

	[HideInInspector]
	public UnitTarget TargetAmbrosiaST1;

	[HideInInspector]
	public UnitTarget TargetChrisST1;

	[HideInInspector]
	public UnitTarget TargetTrain;

	[HideInInspector]
	public UnitTarget TargetWaveEnemy1Enters;

	[HideInInspector]
	public UnitTarget TargetWaveEnemy2Enters;

	[HideInInspector]
	public UnitTarget AmbrosiaCover1;

	[HideInInspector]
	public UnitTarget ArchiCover1;

	[HideInInspector]
	public UnitTarget ArchiCover2;

	[HideInInspector]
	public UnitTarget ChrisCover1;

	[HideInInspector]
	public UnitTarget ChrisCover2;

	[HideInInspector]
	public UnitTarget WillaCover1;

	[HideInInspector]
	public UnitTarget FuselCover1;

	[HideInInspector]
	public UnitTarget FuselCover2;

	[HideInInspector]
	public UnitTarget FuselCover3;

	[HideInInspector]
	public UnitTarget TargetTrain1;

	[HideInInspector]
	public UnitTarget TargetTrain2;

	[HideInInspector]
	public UnitTarget TargetTrain3;

	[HideInInspector]
	public UnitTarget TargetTrain4;

	[HideInInspector]
	public UnitTarget TargetMoveArchi;

	[HideInInspector]
	public UnitTarget TargetMoveChris;

	[HideInInspector]
	public UnitTarget targetShiner1Cutscene;

	[HideInInspector]
	public UnitTarget targetShiner1Cover;

	[HideInInspector]
	public UnitTarget targetShiner2Cover;

	[HideInInspector]
	public UnitTarget T_Vent;

	[HideInInspector]
	public TileActionSwapMap MollysToFiles;

	[HideInInspector]
	public TileActionSwapMap FilesToMollys;

	[HideInInspector]
	public TileActionSwapMap ToStation;

	[HideInInspector]
	public TileActionSwapMap ToSubwayTrain;

	[HideInInspector]
	public TileActionSwapMap SubwayToFiles;

	[HideInInspector]
	public TileActionSwapMap ToTunnel;

	[HideInInspector]
	public TileActionSwapMap ToPlatform;

	[HideInInspector]
	public TileActionSwapMap ToDistillery;

	[HideInInspector]
	public TileActionSwapMap CamToSubwayStation;

	[HideInInspector]
	public TileActionSwapMap CambStationToCamb;

	[HideInInspector]
	public TileActionSwapMap ToCamStation;

	[HideInInspector]
	public TileActionSwapMap ToFilesStation;

	[HideInInspector]
	public TileActionSwapMap CamStationToTrain;

	[HideInInspector]
	public TileActionSwapMap ToPims;

	[HideInInspector]
	public TileActionSwapMap PimGickToCam;

	[HideInInspector]
	public TileActionSwapMap PimGickToDist;

	[HideInInspector]
	public TileActionSwapMap ToBar;

	[HideInInspector]
	public TileActionSwapMap ToTunnel1;

	[HideInInspector]
	public TileTrigger TriggerBetterIdea;

	[HideInInspector]
	public TileTrigger TriggerBetterIdea2;

	[HideInInspector]
	public TileTrigger TriggerLadder;

	[HideInInspector]
	public TileTrigger TriggerRupertCutscene;

	private TileActionInteraction InteractionLadder;

	private TileActionInteraction InteractionTalkToWilla;

	private TileActionInteraction I_TalkToWilla;

	private TileActionInteraction I_PlayerLeaves;

	private TileActionDialog CambStaionDialogTile1;

	private TileActionDialog CambStaionDialogTile2;

	[HideInInspector]
	public DialogData dialog_FuselGoon;

	[HideInInspector]
	public DialogData dialog_AmbrosiaAfterOpp;

	[HideInInspector]
	public DialogData dialog_ArchiAtTheDoor;

	[HideInInspector]
	public DialogData dialog_ArchiCheckingOnWilla2;

	[HideInInspector]
	public DialogData dialog_ArchiSubwayTrain;

	[HideInInspector]
	public DialogData dialog_ArchiCallToArmsChris;

	[HideInInspector]
	public DialogData dialog_ArchiCallToArmsMargot;

	[HideInInspector]
	public DialogData dialog_ArchiCallToArmsNoot;

	[HideInInspector]
	public DialogData dialog_CautiousWilla;

	[HideInInspector]
	public DialogData dialog_WhenYoureDone;

	[HideInInspector]
	public DialogData dialog_WhenYoureDone2;

	[HideInInspector]
	public DialogData dialog_EmptyViolinCase;

	[HideInInspector]
	public DialogData dialog_ThePlan;

	[HideInInspector]
	public DialogData dialog_ThePlanCont;

	[HideInInspector]
	public DialogData dialog_RupertTerrified;

	[HideInInspector]
	public DialogData dialog_WillaInTheChair;

	[HideInInspector]
	public DialogData dialog_HartmanEncourages;

	[HideInInspector]
	public DialogData ambient_ArchiAtTheStation1;

	[HideInInspector]
	public DialogData ambient_ArchiCheckingOnWilla1;

	[HideInInspector]
	public DialogData ambient_ArchiAfterTrainDeparts;

	[HideInInspector]
	public DialogData ambient_ArchiAfterStealth;

	[HideInInspector]
	public DialogData ambient_ArchiTrainAlmostHere;

	[HideInInspector]
	public DialogData ambient_ArchiAtTheLadder;

	[HideInInspector]
	public DialogData ambient_AmbrosiaHooligans;

	[HideInInspector]
	public DialogData ambient_RupertRunsAway;

	[HideInInspector]
	public DialogData ambient_WillaOnTheTracks;

	[HideInInspector]
	public DialogData ambient_WillaGroan1;

	[HideInInspector]
	public DialogData ambient_WillaGroan2;

	[HideInInspector]
	public DialogData ambient_WillaGroan3;

	[HideInInspector]
	public DialogData cutscene_AWalkOnTheTracks;

	[HideInInspector]
	public DialogData AmbientGoMove;

	private string objHeadToShinersSurgeryString = "OBJECTIVES_A1O8_01";

	private string objGetOnTheTracks = "OBJECTIVES_A1O8_02";

	private string objDefeatShinersString = "OBJECTIVES_A1O8_03";

	private string objDefendBar = "OBJECTIVES_A1O8_04";

	private string objCheckOnOthersString = "OBJECTIVES_A1O8_05";

	private string objProtectWillaAndAmbrosiaString = "OBJECTIVES_A1O8_06";

	private string objEscapeToTheSubwayString = "OBJECTIVES_A1O8_07";

	private string objGetBackToMolly = "OBJECTIVES_A1O8_08";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AndroidServicing = GetLogicUsingArtName("T1AndroidServicing");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot SubwayStationLogic = GetLogicUsingArtName("T1Subway_Station_Files");
		LogicRoot SubwayTrainLogic = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot CambridgeStation = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot SubwayTunnelLogic = GetLogicUsingArtName("T1Subway_Tunnel");
		LogicRoot PimGricklesLogic = GetLogicUsingArtName("T1PimDickles");
		LogicRoot CamLogic = GetLogicUsingArtName("T1Cambridge");
		LogicRoot DistilleryLogic = GetLogicUsingArtName("T1AlembicDistillery");
		TileBlockDynamic DynamicCurtainColL = MR.Inst.GetTileBlockDynamic("0DB_T1AlembicDistillery_TileBlockDynamic");
		TileBlockDynamic DynamicCurtainColR = MR.Inst.GetTileBlockDynamic("CBE_T1AlembicDistillery_TileBlockDynamic");
		Archi = GC.Inst.GetUnitWithId("30A_T1AndroidServicing_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("011_T1AndroidServicing_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("6F3_T1AndroidServicing_UnitSpawn");
		ThirdMember = GC.Inst.GetUnitWithId("0E8_T1AndroidServicing_UnitSpawn");
		Molly = GC.Inst.GetUnitWithId("0E6_T1AndroidServicing_UnitSpawn");
		Rupert = GC.Inst.GetUnitWithId("247_T1AlembicDistillery_UnitSpawn");
		Mund = GC.Inst.GetUnitWithId("F33_T1AndroidServicing_UnitSpawn");
		string CurtainAnimator = "CH_DistilleryCurtain";
		string ArmAnimatorName = "CH_SArm";
		string train = "MA_SubwayTrain";
		FuselGanster1 = GC.Inst.GetUnitWithId("F81_T1AndroidServicing_UnitSpawn");
		FuselGanster2 = GC.Inst.GetUnitWithId("9C0_T1AndroidServicing_UnitSpawn");
		FuselC1 = GC.Inst.GetUnitWithId("587_T1Cambridge_UnitSpawn");
		FuselC2 = GC.Inst.GetUnitWithId("74F_T1Cambridge_UnitSpawn");
		FuselC3 = GC.Inst.GetUnitWithId("5EE_T1Cambridge_UnitSpawn");
		FuselS1 = GC.Inst.GetUnitWithId("602_T1Subway_Station_Cambridge_UnitSpawn");
		FuselS2 = GC.Inst.GetUnitWithId("E32_T1Subway_Station_Cambridge_UnitSpawn");
		FuselS3 = GC.Inst.GetUnitWithId("3D0_T1Subway_Station_Cambridge_UnitSpawn");
		Shiner1 = GC.Inst.GetUnitWithId("547_T1AlembicDistillery_UnitSpawn");
		Shiner2 = GC.Inst.GetUnitWithId("0E6_T1AlembicDistillery_UnitSpawn");
		Shiner3 = GC.Inst.GetUnitWithId("B8C_T1PimDickles_UnitSpawn");
		Shiner4 = GC.Inst.GetUnitWithId("654_T1PimDickles_UnitSpawn");
		Shiner5 = GC.Inst.GetUnitWithId("08A_T1AlembicDistillery_UnitSpawn");
		Shiner6 = GC.Inst.GetUnitWithId("058_T1AlembicDistillery_UnitSpawn");
		TrainNPC1 = GC.Inst.GetUnitWithId("70D_T1Subway_TrainInterior_UnitSpawn");
		TrainNPC2 = GC.Inst.GetUnitWithId("8C4_T1Subway_TrainInterior_UnitSpawn");
		TrainNPC3 = GC.Inst.GetUnitWithId("DCD_T1Subway_TrainInterior_UnitSpawn");
		TrainNPC4 = GC.Inst.GetUnitWithId("979_T1Subway_TrainInterior_UnitSpawn");
		CambSubwayNPC1 = GC.Inst.GetUnitWithId("CCE_T1Subway_TrainInterior_UnitSpawn");
		CambSubwayNPC2 = GC.Inst.GetUnitWithId("265_T1Subway_Station_Cambridge_UnitSpawn");
		CambSubwayNPC3 = GC.Inst.GetUnitWithId("EBA_T1Subway_Station_Cambridge_UnitSpawn");
		CambSubwayNPC4 = GC.Inst.GetUnitWithId("D24_T1Subway_Station_Cambridge_UnitSpawn");
		CambSubwayNPC5 = GC.Inst.GetUnitWithId("E26_T1Subway_Station_Cambridge_UnitSpawn");
		MollysToFiles = MR.Inst.GetTileActionSwapMap("975_T1AndroidServicing_TileActionSwapMap");
		ToStation = MR.Inst.GetTileActionSwapMap("745_T1TheFiles_TileActionSwapMap");
		FilesToMollys = MR.Inst.GetTileActionSwapMap("3D0_T1TheFiles_TileActionSwapMap");
		ToSubwayTrain = MR.Inst.GetTileActionSwapMap("E0D_T1Subway_Station_TileActionSwapMap");
		SubwayToFiles = MR.Inst.GetTileActionSwapMap("D99_T1Subway_Station_TileActionSwapMap");
		ToCamStation = MR.Inst.GetTileActionSwapMap("1FA_T1Subway_TrainInterior_TileActionSwapMap");
		ToFilesStation = MR.Inst.GetTileActionSwapMap("0EB_T1Subway_TrainInterior_TileActionSwapMap");
		CamStationToTrain = MR.Inst.GetTileActionSwapMap("EEE_T1Subway_Station_Cambridge_TileActionSwapMap");
		PimGickToCam = MR.Inst.GetTileActionSwapMap("AFA_T1PimDickles_TileActionSwapMap");
		PimGickToDist = MR.Inst.GetTileActionSwapMap("61D_T1PimDickles_TileActionSwapMap");
		ToTunnel = MR.Inst.GetTileActionSwapMap("A59_T1Subway_Station_Cambridge_TileActionSwapMap");
		ToTunnel1 = MR.Inst.GetTileActionSwapMap("983_T1AlembicDistillery_TileActionSwapMap");
		ToPlatform = MR.Inst.GetTileActionSwapMap("26F_T1Subway_Tunnel_TileActionSwapMap");
		ToDistillery = MR.Inst.GetTileActionSwapMap("5B5_T1Subway_Tunnel_TileActionSwapMap");
		ToPims = MR.Inst.GetTileActionSwapMap("352_T1Cambridge_TileActionSwapMap");
		ToBar = MR.Inst.GetTileActionSwapMap("649_T1AlembicDistillery_TileActionSwapMap");
		CamToSubwayStation = MR.Inst.GetTileActionSwapMap("B2B_T1Cambridge_TileActionSwapMap");
		CambStationToCamb = MR.Inst.GetTileActionSwapMap("C28_T1Subway_Station_Cambridge_TileActionSwapMap");
		InteractionLadder = MR.Inst.GetTileActionInteraction("F16_T1Subway_Tunnel_TileActionInteraction");
		I_PlayerLeaves = MR.Inst.GetTileActionInteraction("006_T1AndroidServicing_TileActionInteraction");
		I_TalkToWilla = MR.Inst.GetTileActionInteraction("254_T1AlembicDistillery_TileActionInteraction");
		CambStaionDialogTile1 = MR.Inst.GetTileActionDialog("AEA_T1Subway_Station_Files_TileActionDialog");
		TileActionDialog TrainDialog1 = MR.Inst.GetTileActionDialog("767_T1Subway_TrainInterior_TileActionDialog");
		TileActionDialog TrainDialog2 = MR.Inst.GetTileActionDialog("72B_T1Subway_TrainInterior_TileActionDialog");
		TileActionDialog TrainStationDialog1 = MR.Inst.GetTileActionDialog("AEA_T1Subway_Station_Files_TileActionDialog");
		WillaSittingPoint = MR.Inst.GetUnitTarget("7C3_T1Subway_TrainInterior_UnitTarget");
		T_Archi = MR.Inst.GetUnitTarget("CD8_T1Subway_TrainInterior_UnitTarget");
		T_Chris = MR.Inst.GetUnitTarget("7F1_T1Subway_TrainInterior_UnitTarget");
		T_Ambrosia = MR.Inst.GetUnitTarget("0C1_T1Subway_TrainInterior_UnitTarget");
		T_Vent = MR.Inst.GetUnitTarget("4E4_T1AlembicDistillery_UnitTarget");
		TargetOffTrain = MR.Inst.GetUnitTarget("D5E_T1Subway_Station_Cambridge_UnitTarget");
		TargetOffTrain2 = MR.Inst.GetUnitTarget("FEE_T1Subway_Station_Cambridge_UnitTarget");
		TargetWillaD1 = MR.Inst.GetUnitTarget("1A6_T1AlembicDistillery_UnitTarget");
		TargetAmbrosiaD1 = MR.Inst.GetUnitTarget("7D5_T1AlembicDistillery_UnitTarget");
		TargetAmbrosiaD2 = MR.Inst.GetUnitTarget("9DC_T1AlembicDistillery_UnitTarget");
		TargetArchiD1 = MR.Inst.GetUnitTarget("543_T1AlembicDistillery_UnitTarget");
		TargetArchiD2 = MR.Inst.GetUnitTarget("1D6_T1AlembicDistillery_UnitTarget");
		TargetChrisD1 = MR.Inst.GetUnitTarget("2A5_T1AlembicDistillery_UnitTarget");
		TargetRupertD1 = MR.Inst.GetUnitTarget("1DB_T1AlembicDistillery_UnitTarget");
		TargetRupertD2 = MR.Inst.GetUnitTarget("9BF_T1AlembicDistillery_UnitTarget");
		TargetAmbrosiaS1 = MR.Inst.GetUnitTarget("A46_T1Subway_Station_Cambridge_UnitTarget");
		TargetArchiS1 = MR.Inst.GetUnitTarget("E64_T1Subway_Station_Cambridge_UnitTarget");
		TargetChrisS1 = MR.Inst.GetUnitTarget("23F_T1Subway_Station_Cambridge_UnitTarget");
		TargetWillaS1 = MR.Inst.GetUnitTarget("9E1_T1Subway_Station_Cambridge_UnitTarget");
		TargetAmbrosiaST1 = MR.Inst.GetUnitTarget("D1D_T1Subway_Tunnel_UnitTarget");
		TargetArchiST1 = MR.Inst.GetUnitTarget("069_T1Subway_Tunnel_UnitTarget");
		TargetWillaST1 = MR.Inst.GetUnitTarget("896_T1Subway_Tunnel_UnitTarget");
		TargetChrisST1 = MR.Inst.GetUnitTarget("B60_T1Subway_Tunnel_UnitTarget");
		TargetTrain1 = MR.Inst.GetUnitTarget("A6E_T1Subway_Station_Cambridge_UnitTarget");
		TargetTrain2 = MR.Inst.GetUnitTarget("D5F_T1Subway_Station_Cambridge_UnitTarget");
		TargetTrain3 = MR.Inst.GetUnitTarget("5BA_T1Subway_Station_Cambridge_UnitTarget");
		TargetTrain4 = MR.Inst.GetUnitTarget("85A_T1Subway_Station_Cambridge_UnitTarget");
		AmbrosiaCover1 = MR.Inst.GetUnitTarget("749_T1Cambridge_UnitTarget");
		ArchiCover1 = MR.Inst.GetUnitTarget("7E7_T1PimDickles_UnitTarget");
		ArchiCover2 = MR.Inst.GetUnitTarget("11A_T1Cambridge_UnitTarget");
		ChrisCover1 = MR.Inst.GetUnitTarget("273_T1PimDickles_UnitTarget");
		ChrisCover2 = MR.Inst.GetUnitTarget("0DB_T1Cambridge_UnitTarget");
		WillaCover1 = MR.Inst.GetUnitTarget("822_T1Cambridge_UnitTarget");
		FuselCover1 = MR.Inst.GetUnitTarget("32D_T1Cambridge_UnitTarget");
		FuselCover2 = MR.Inst.GetUnitTarget("8DB_T1Cambridge_UnitTarget");
		FuselCover3 = MR.Inst.GetUnitTarget("3DD_T1Cambridge_UnitTarget");
		TargetMoveArchi = MR.Inst.GetUnitTarget("E52_T1PimDickles_UnitTarget");
		TargetMoveChris = MR.Inst.GetUnitTarget("74D_T1PimDickles_UnitTarget");
		TargetWaveEnemy1Enters = MR.Inst.GetUnitTarget("64C_T1AlembicDistillery_UnitTarget");
		TargetWaveEnemy2Enters = MR.Inst.GetUnitTarget("402_T1AlembicDistillery_UnitTarget");
		targetShiner1Cutscene = MR.Inst.GetUnitTarget("47A_T1AlembicDistillery_UnitTarget");
		targetShiner1Cover = MR.Inst.GetUnitTarget("992_T1AlembicDistillery_UnitTarget");
		targetShiner2Cover = MR.Inst.GetUnitTarget("BB1_T1AlembicDistillery_UnitTarget");
		UnitTarget T_MollyToTable = MR.Inst.GetUnitTarget("5EA_T1AndroidServicing_UnitTarget");
		UnitTarget T_MollyMoveToTeam = MR.Inst.GetUnitTarget("938_T1AndroidServicing_UnitTarget");
		UnitTarget T_ArchiToTunnel = MR.Inst.GetUnitTarget("CF1_T1Subway_Station_Cambridge_UnitTarget");
		dialog_CautiousWilla = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogCautiousWilla");
		dialog_WhenYoureDone = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogWhenYoureDone");
		dialog_WhenYoureDone2 = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogWhenYoureDone2");
		dialog_EmptyViolinCase = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogEmptyViolinCase");
		dialog_ThePlan = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogThePlan");
		dialog_ThePlanCont = HAGIS.DialogLoad("Dialogs/A1O8/AndroidServicing/DialogThePlanCont");
		dialog_ArchiSubwayTrain = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTrain/DialogArchiSubwayTrain");
		dialog_ArchiCheckingOnWilla2 = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTrain/DialogArchiCheckingOnWilla2");
		dialog_HartmanEncourages = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTrain/DialogHartmanEncourages");
		ambient_WillaGroan1 = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTrain/AmbientWillaGroan1");
		ambient_ArchiCheckingOnWilla1 = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTrain/AmbientArchiCheckingOnWilla1");
		ambient_ArchiAfterTrainDeparts = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/AmbientArchiAfterTrainDeparts");
		ambient_ArchiAtTheStation1 = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/AmbientArchiAtTheStation1");
		ambient_ArchiTrainAlmostHere = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/AmbientArchiTrainAlmostHere");
		ambient_WillaOnTheTracks = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/AmbientWillaOnTheTracks");
		cutscene_AWalkOnTheTracks = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/CutsceneAWalkOnTheTracks");
		AmbientGoMove = HAGIS.DialogLoad("Dialogs/A1O8/SubwayStation/AmbientGoMove");
		ambient_ArchiAtTheLadder = HAGIS.DialogLoad("Dialogs/A1O8/SubwayTunnel/AmbientArchiAtTheLadder");
		ambient_AmbrosiaHooligans = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/AmbientAmbrosiaHooligans");
		ambient_ArchiAfterStealth = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/AmbientArchiAfterStealth");
		ambient_RupertRunsAway = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/AmbientRupertRunsAway");
		ambient_WillaGroan2 = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/AmbientWillaGroan2");
		dialog_AmbrosiaAfterOpp = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogAmbrosiaAfterOpp");
		dialog_ArchiAtTheDoor = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogArchiAtTheDoor");
		dialog_ArchiCallToArmsChris = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogArchiCallToArmsChris");
		dialog_ArchiCallToArmsMargot = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogArchiCallToArmsMargot");
		dialog_ArchiCallToArmsNoot = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogArchiCallToArmsNoot");
		dialog_RupertTerrified = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogRupertTerrified");
		dialog_WillaInTheChair = HAGIS.DialogLoad("Dialogs/A1O8/Distillery/DialogWillaInTheChair");
		ambient_WillaGroan3 = HAGIS.DialogLoad("Dialogs/A1O8/PimGricklesBar/AmbientWillaGroan3");
		dialog_FuselGoon = HAGIS.DialogLoad("Dialogs/A1O8/Cambridge/DialogFuselGoon");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("934_T1AlembicDistillery_TileBlockDynamic");
		TileBlockDynamic Dynamicblock2 = MR.Inst.GetTileBlockDynamic("7BF_T1AlembicDistillery_TileBlockDynamic");
		Mund.gameObject.SetActive(value: false);
		FuselGanster1.gameObject.SetActive(value: false);
		FuselGanster2.gameObject.SetActive(value: false);
		ToTunnel.gameObject.SetActive(value: false);
		PimGickToCam.gameObject.SetActive(value: false);
		Rupert.gameObject.SetActive(value: false);
		Shiner5.gameObject.SetActive(value: false);
		Shiner6.gameObject.SetActive(value: false);
		FuselS1.gameObject.SetActive(value: false);
		FuselS2.gameObject.SetActive(value: false);
		FuselS3.gameObject.SetActive(value: false);
		Shiner3.gameObject.SetActive(value: false);
		Shiner4.gameObject.SetActive(value: false);
		ToDistillery.gameObject.SetActive(value: false);
		MollysToFiles.gameObject.SetActive(value: false);
		ToCamStation.gameObject.SetActive(value: false);
		CambStationToCamb.gameObject.SetActive(value: false);
		ToFilesStation.gameObject.SetActive(value: false);
		CamStationToTrain.gameObject.SetActive(value: false);
		Dynamicblock.gameObject.SetActive(value: false);
		Dynamicblock2.gameObject.SetActive(value: false);
		DynamicCurtainColL.gameObject.SetActive(value: false);
		DynamicCurtainColR.gameObject.SetActive(value: false);
		ToSubwayTrain.gameObject.SetActive(value: false);
		ToPlatform.gameObject.SetActive(value: false);
		I_TalkToWilla.gameObject.SetActive(value: false);
		T_Vent.gameObject.SetActive(value: false);
		I_PlayerLeaves.gameObject.SetActive(value: false);
		ToTunnel1.gameObject.SetActive(value: false);
		ToBar.gameObject.SetActive(value: false);
		Shiner6.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Shiner5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Close");
		AndroidServicing.unitsMoveToDefaultPositions = false;
		SubwayTrainLogic.unitsMoveToDefaultPositions = false;
		DistilleryLogic.unitsMoveToDefaultPositions = false;
		yield return null;
		Molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultTable");
		Molly.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/exploration/techtonics");
		yield return CreateTimeCondition(1f);
		yield return CutscenePlay("A1O8_Cutscene_MollyOpensParcel");
		Molly.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		ThirdMember.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		I_PlayerLeaves.gameObject.SetActive(value: true);
		SKIP_POINT("Time To leave");
		GC.Inst.SetRPGLeader(Archi);
		yield return CreateTriggerCondition(I_PlayerLeaves.OnTriggered);
		CutsceneBegin();
		MollysToFiles.gameObject.SetActive(value: true);
		yield return UnitMoveToMapViaExitTile(Archi, MollysToFiles);
		yield return UnitMoveToTarget(ThirdMember, MollysToFiles);
		yield return UnitMoveToMapViaExitTile(ThirdMember, MollysToFiles);
		yield return UnitMoveToTarget(Ambrosia, MollysToFiles);
		yield return UnitMoveToMapViaExitTile(Ambrosia, MollysToFiles);
		MusicStop();
		Willa.LookInDirection(OctDir.Down);
		Molly.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_CautiousWilla);
		MusicStop();
		yield return UnitMoveToTarget(Willa, MollysToFiles);
		yield return UnitMoveToMapViaExitTile(Willa, MollysToFiles);
		yield return MapGoto(TheFiles);
		I_PlayerLeaves.gameObject.SetActive(value: false);
		FilesToMollys.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return null;
		GC.Inst.SetRPGLeader(Archi);
		MusicPlay("event:/music/tracks/exploration/random dark 1");
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadToShinersSurgeryString);
		TheFiles.CanTeammatesFollow = true;
		SKIP_POINT("Entering the files");
		yield return MapWaitUntilVisible(SubwayStationLogic.Map);
		UIObjectives.Inst.CompleteObjective(objEscapeToTheSubwayString);
		SubwayStationLogic.CanTeammatesFollow = true;
		PlayInterplay();
		PlayMapAnimation(SubwayStationLogic.Map, "MA_SubwayTrain", "Arriving");
		yield return CreateTimeCondition(6f);
		ToSubwayTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Waiting to board train");
		PlayMapAnimation(CambridgeStation.Map, "MA_SubwayTrain", "ArrivingNoEvents");
		SubwayTrainLogic.unitsMoveToDefaultPositions = true;
		yield return MapWaitUntilVisible(SubwayTrainLogic.Map);
		SubwayTrainLogic.CanTeammatesFollow = false;
		yield return null;
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, WillaSittingPoint);
		while ((bool)Archi.moving || (bool)ThirdMember.moving || (bool)Ambrosia.moving)
		{
			yield return null;
		}
		Archi.LookAt(Willa);
		ThirdMember.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		Willa.LookInDirection(OctDir.Up);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return Willa.unitModel.Play("CsTransDIdleToDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		yield return HAGIS.DialogShow(ambient_WillaGroan1);
		yield return HAGIS.DialogShow(dialog_HartmanEncourages);
		ToSubwayTrain.gameObject.SetActive(value: false);
		Willa.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return Willa.unitModel.Play("CsTransDefeatedToDIdle");
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.UpdateIdleAnim();
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Cambridge_L0");
		yield return PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Open");
		ToCamStation.gameObject.SetActive(value: true);
		SubwayTrainLogic.CanTeammatesFollow = true;
		FilesToMollys.gameObject.SetActive(value: true);
		MusicStop();
		CambridgeStation.CanTeammatesFollow = true;
		yield return MapWaitUntilVisible(CambridgeStation.Map);
		PlayMapAnimation(CambridgeStation.Map, "MA_SubwayTrain", "Leaving");
		SKIP_POINT("Left train, entered subway station");
		UIObjectives.Inst.CompleteAndSetMainObjective(objGetOnTheTracks);
		GC.Inst.CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_ArchiAtTheStation1);
		yield return UnitMoveToTarget(Archi, T_ArchiToTunnel, OctDir.Down);
		CambridgeStation.CanTeammatesFollow = false;
		yield return Archi.unitModel.Play("CsTransDIdleToKneel");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneel");
		Archi.UpdateIdleAnim();
		UnitMoveToUnit(Willa, Archi);
		UnitMoveToTarget(Ambrosia, TargetOffTrain);
		yield return UnitMoveToTarget(ThirdMember, TargetOffTrain2);
		Willa.LookAt(Archi);
		Ambrosia.LookAt(Archi);
		ThirdMember.LookAt(Archi);
		yield return HAGIS.DialogShow(ambient_ArchiAfterTrainDeparts);
		yield return HAGIS.DialogShow(ambient_WillaOnTheTracks);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		ThirdMember.SetTeamType(UnitTeam.Type.NPC);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		UnitTeleportToMapViaEntranceTile(Willa, ToPlatform, TargetWillaST1);
		UnitTeleportToMapViaEntranceTile(Archi, ToPlatform, TargetArchiST1);
		UnitTeleportToMapViaEntranceTile(ThirdMember, ToPlatform, TargetChrisST1);
		UnitTeleportToMapViaEntranceTile(Ambrosia, ToPlatform, TargetAmbrosiaST1);
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return MapGoto(SubwayTunnelLogic);
		Willa.LookAt(Archi);
		Ambrosia.LookAt(Archi);
		ThirdMember.LookAt(Archi);
		GC.Inst.CutsceneEnd();
		SKIP_POINT("Entered the subway tunnel");
		UIObjectives.Inst.CompleteObjective(objGetOnTheTracks);
		TrainNPC1.gameObject.SetActive(value: false);
		TrainNPC2.gameObject.SetActive(value: false);
		TrainNPC3.gameObject.SetActive(value: false);
		TrainNPC4.gameObject.SetActive(value: false);
		CambSubwayNPC1.gameObject.SetActive(value: false);
		CambSubwayNPC2.gameObject.SetActive(value: false);
		CambSubwayNPC3.gameObject.SetActive(value: false);
		CambSubwayNPC4.gameObject.SetActive(value: false);
		CambSubwayNPC5.gameObject.SetActive(value: false);
		TrainDialog1.gameObject.SetActive(value: false);
		TrainDialog2.gameObject.SetActive(value: false);
		TrainStationDialog1.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(InteractionLadder.OnTriggered);
		CutsceneBegin();
		HAGIS.DialogShow(ambient_ArchiAtTheLadder);
		yield return CreateTriggerCondition(ambient_ArchiAtTheLadder.OnComplete);
		ToDistillery.gameObject.SetActive(value: true);
		UnitMoveToTarget(Archi, ToDistillery);
		yield return UnitTeleportToMapViaEntranceTile(Archi, ToTunnel1);
		Archi.gameObject.SetActive(value: false);
		PlayMapAnimation(DistilleryLogic.Map, CurtainAnimator, "Open");
		CutsceneEnd();
		yield return null;
		yield return MapGoto(DistilleryLogic);
		SKIP_POINT("Skipped Subway tunnel");
		CutsceneBegin();
		UnitMoveToTarget(Shiner1, targetShiner1Cutscene);
		yield return CreateTimeCondition(2f);
		yield return PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Open");
		yield return CreateTimeCondition(1f);
		Archi.gameObject.SetActive(value: true);
		UnitMoveToTarget(Archi, TargetAmbrosiaD1);
		yield return CreateTimeCondition(1f);
		yield return PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Close");
		Shiner1.LookAt(Archi);
		Shiner2.LookAt(Archi);
		Archi.LookAt(Shiner1);
		yield return CreateTimeCondition(0.5f);
		HAGIS_A1O8 hAGIS_A1O = this;
		Unit archi = Archi;
		UnitTarget targetArchiD = TargetArchiD1;
		float? speed = Archi.charData.movementSpeedInCombat;
		HagletYieldTerm archiMoved = hAGIS_A1O.UnitMoveToTarget(archi, targetArchiD, null, speed);
		HAGIS_A1O8 hAGIS_A1O2 = this;
		archi = Shiner1;
		targetArchiD = targetShiner1Cover;
		speed = Shiner1.charData.movementSpeedInCombat;
		HagletYieldTerm shiner1Moved = hAGIS_A1O2.UnitMoveToTarget(archi, targetArchiD, null, speed);
		HAGIS_A1O8 hAGIS_A1O3 = this;
		archi = Shiner2;
		targetArchiD = targetShiner2Cover;
		speed = Shiner2.charData.movementSpeedInCombat;
		HagletYieldTerm shiner2Moved = hAGIS_A1O3.UnitMoveToTarget(archi, targetArchiD, null, speed);
		yield return CreateAndCondition(archiMoved, shiner1Moved, shiner2Moved);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefeatShinersString);
		MusicPlay("event:/music/tracks/combat/shiner combat");
		CutsceneEnd();
		SKIP_POINT("fight begins inside Distillery");
		yield return CombatBegin(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objDefeatShinersString);
		MusicStop();
		yield return HAGIS.DialogShow(ambient_ArchiAfterStealth);
		SKIP_POINT("Cleared out enemies");
		CutsceneBegin();
		yield return PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Open");
		yield return UnitTeleportToMapViaEntranceTile(Willa, ToTunnel1, TargetWillaD1);
		yield return UnitTeleportToMapViaEntranceTile(ThirdMember, ToTunnel1, TargetChrisD1);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, ToTunnel1, TargetAmbrosiaD1);
		Willa.LookInDirection(OctDir.Up);
		PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Close");
		ThirdMember.LookAt(Willa);
		ThirdMember.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		I_TalkToWilla.gameObject.SetActive(value: true);
		CutsceneEnd();
		yield return null;
		yield return CreateTriggerCondition(I_TalkToWilla.OnTriggered);
		I_TalkToWilla.gameObject.SetActive(value: false);
		yield return CutscenePlay("A1O8_Cutscene_OppInterRupert");
		Dynamicblock.gameObject.SetActive(value: true);
		Dynamicblock2.gameObject.SetActive(value: true);
		KubrickAnimator armAnimator = DistilleryLogic.Map.GetDynamicAnimator(ArmAnimatorName);
		PlayMapAnimation(DistilleryLogic.Map, ArmAnimatorName, "CsDefaultPowerUp");
		FMOD.Studio.EventInstance sfx_augment_machine_loop = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o8/augment installation machine");
		HAGIS.DialogShow(ambient_WillaGroan2);
		while (!MR.Inst.IsSkipping() && armAnimator.IsPlaying)
		{
			yield return null;
		}
		PlayMapAnimation(DistilleryLogic.Map, ArmAnimatorName, "CsDefaultSurgery", loop: true);
		SKIP_POINT("Shinners arrive and Archi and Chris must defend!");
		Shiner3.gameObject.SetActive(value: true);
		Shiner4.gameObject.SetActive(value: true);
		ToBar.gameObject.SetActive(value: true);
		SFXPlay("event:/sfx/script/act 1/a1o8/bar fight next door");
		Archi.LookInDirection(OctDir.Down);
		switch (SaveData.SplitPoint((int)ThirdMember.charData.partyMemberID))
		{
		case 5:
			yield return HAGIS.DialogShow(dialog_ArchiCallToArmsChris);
			break;
		case 3:
			yield return HAGIS.DialogShow(dialog_ArchiCallToArmsMargot);
			break;
		case 4:
			yield return HAGIS.DialogShow(dialog_ArchiCallToArmsNoot);
			break;
		}
		yield return MapWaitUntilVisible(PimGricklesLogic.Map);
		AC.Stop(sfx_augment_machine_loop, release: true);
		UnitMoveToTarget(Archi, ArchiCover1);
		yield return UnitMoveToTarget(ThirdMember, ChrisCover1);
		PimGickToDist.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefendBar);
		MusicSetProgress(0.1f);
		yield return CombatBegin(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objDefendBar);
		MusicSetProgress(0.2f);
		yield return CreateTimeCondition(1f);
		SKIP_POINT("Skipped Combat in Pims Bar");
		CutsceneBegin();
		UnitMoveToTarget(ThirdMember, TargetMoveChris, OctDir.DownRight);
		yield return UnitMoveToTarget(Archi, TargetMoveArchi, OctDir.DownRight);
		HAGIS.DialogShow(ambient_WillaGroan3);
		UnitLookInDirection(Archi, OctDir.UpLeft);
		UnitLookInDirection(ThirdMember, OctDir.Up);
		yield return null;
		PimGickToDist.gameObject.SetActive(value: true);
		Rupert.gameObject.SetActive(value: false);
		Willa.SetVariant("Augmented");
		Willa.unitModel.Play("CsDefaultSurgery", looping: true);
		Willa.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return MapWaitUntilVisible(DistilleryLogic.Map);
		PimGricklesLogic.CanTeammatesFollow = true;
		CutsceneBegin();
		sfx_augment_machine_loop = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o8/augment installation machine");
		ToBar.gameObject.SetActive(value: false);
		UnitMoveToTarget(Archi, TargetWillaD1, OctDir.Up);
		yield return UnitMoveToTarget(ThirdMember, TargetArchiD2, OctDir.Up);
		yield return CreateTimeCondition(1f);
		T_Vent.gameObject.SetActive(value: true);
		yield return null;
		yield return PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Open");
		Shiner6.Show();
		yield return UnitMoveToTarget(Shiner6, TargetWaveEnemy1Enters, OctDir.DownLeft, 5f);
		Shiner5.Show();
		UnitMoveToTarget(Shiner5, TargetWaveEnemy2Enters, OctDir.Left, 5f);
		yield return PlayMapAnimation(DistilleryLogic.Map, "MA_DistilleryHatch_01", "Close");
		T_Vent.gameObject.SetActive(value: false);
		UnitPlayAnimation(Ambrosia, "CsTransSurgeryToDIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.UpdateIdleAnim();
		Ambrosia.LookAt(Shiner6);
		yield return HAGIS.DialogShow(ambient_AmbrosiaHooligans);
		Ambrosia.LookInDirection(OctDir.Up);
		UnitPlayAnimation(Ambrosia, "CsTransDIdleToSurgery");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSurgery");
		Ambrosia.UpdateIdleAnim();
		UnitMoveToTarget(Archi, TargetArchiD1);
		yield return UnitMoveToTarget(ThirdMember, TargetChrisD1);
		CutsceneEnd();
		SKIP_POINT("About to fight the shiner waves");
		UIObjectives.Inst.CompleteAndSetMainObjective(objProtectWillaAndAmbrosiaString);
		MusicPlay("event:/music/tracks/combat/generic combat 2");
		yield return CreateTimeCondition(1f);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultSurgery");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultSurgery");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultSurgery");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CsDefaultDruggedWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultSurgery");
		Willa.PreferWalk = true;
		TileObjectBase.Height blockHeight = (Dynamicblock2.BlockHeight = TileObjectBase.Height.Full);
		Dynamicblock.BlockHeight = blockHeight;
		yield return null;
		CombatBegin(UnitTeam.Type.Player);
		HagletYieldTerm combatCompleted = Wait.Until(CombatWaitUntilComplete());
		HagletYieldTerm willaDied = CreateTriggerCondition(Willa.OnDeathComplete);
		HagletYieldTerm ambrosiaDied = CreateTriggerCondition(Ambrosia.OnDeathComplete);
		yield return CreateOrCondition(combatCompleted, willaDied, ambrosiaDied);
		if (combatCompleted.met)
		{
			HagisLog("All enemies are dead, player won!");
		}
		if (willaDied.met)
		{
			HagisLog("Willa died, player lost!");
		}
		if (ambrosiaDied.met)
		{
			HagisLog("Ambrosia died, player lost!");
		}
		Shiner3.Hide(makeInactive: true);
		Shiner4.Hide(makeInactive: true);
		Dynamicblock.gameObject.SetActive(value: false);
		Dynamicblock2.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objProtectWillaAndAmbrosiaString);
		yield return null;
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		CutsceneBegin();
		float armAnimTime = armAnimator.GetTime();
		armAnimator.WrapMode = WrapMode.Once;
		armAnimator.Play("CsDefaultSurgery");
		armAnimator.SetTime(armAnimTime);
		yield return null;
		while (!MR.Inst.IsSkipping() && armAnimator.IsPlaying)
		{
			yield return null;
		}
		AC.Stop(sfx_augment_machine_loop, release: true);
		CutsceneEnd();
		yield return CutscenePlay("A1O8_Cutscene_WillaGetsOutOfChair");
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Ambrosia.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		Ambrosia.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		ToBar.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEscapeToTheSubwayString);
		PimGickToCam.gameObject.SetActive(value: true);
		SKIP_POINT("After operation");
		MusicStop();
		yield return MapWaitUntilVisible(CamLogic.Map);
		CambStationToCamb.gameObject.SetActive(value: false);
		CutsceneBegin();
		SKIP_POINT("Cambridge streets");
		yield return null;
		UnitMoveToTarget(Willa, WillaCover1);
		HAGIS.DialogShow(dialog_FuselGoon);
		yield return CreateTimeCondition(2f);
		yield return CreateAndCondition(UnitPlayAnimation(FuselC1, "TransDIdleToCIdle"), UnitPlayAnimation(FuselC2, "TransDIdleToCIdle"), UnitPlayAnimation(FuselC3, "TransDIdleToCIdle"));
		FuselC1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		FuselC1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		FuselC2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		FuselC2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		FuselC3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		FuselC3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.IsAttackingDisabled = true;
		Willa.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitPlayAnimation(Willa, "CsTransDruggedToDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultDefeated");
		Willa.UpdateIdleAnim();
		CamToSubwayStation.gameObject.SetActive(value: false);
		ToPims.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objProtectWillaAndAmbrosiaString);
		yield return null;
		yield return CreateAndCondition(UnitMoveToTarget(FuselC1, FuselCover1, null, 5f), UnitMoveToTarget(FuselC2, FuselCover2, null, 5f), UnitMoveToTarget(FuselC3, FuselCover3, null, 5f), UnitMoveToTarget(Ambrosia, AmbrosiaCover1), UnitMoveToTarget(Archi, ArchiCover2), UnitMoveToTarget(ThirdMember, ChrisCover1));
		MusicPlay("event:/music/tracks/combat/willas combat");
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return UnitPlayAnimation(Willa, "CsTransDefeatedToDIdle");
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		Willa.UpdateIdleAnim();
		UIObjectives.Inst.CompleteAndSetMainObjective(objEscapeToTheSubwayString);
		MusicPlay("event:/music/tracks/basic/light tension 1");
		CamLogic.CanTeammatesFollow = true;
		CamToSubwayStation.gameObject.SetActive(value: true);
		yield return MapWaitUntilMidTransition(CambridgeStation);
		SKIP_POINT("Cambridge station");
		yield return null;
		CutsceneBegin();
		ToCamStation.gameObject.SetActive(value: false);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		PlayMapAnimation(SubwayTrainLogic.Map, "MA_SubwayDoors", "Close");
		PlayMapAnimation(CambridgeStation.Map, "MA_SubwayTrain", "Arriving");
		ToStation.gameObject.SetActive(value: true);
		HAGIS.DialogShow(AmbientGoMove);
		UnitMoveToTarget(Archi, TargetTrain1);
		UnitMoveToTarget(ThirdMember, TargetTrain2);
		UnitMoveToTarget(Willa, TargetTrain3);
		yield return UnitMoveToTarget(Ambrosia, TargetTrain4);
		Archi.LookInDirection(OctDir.Down);
		Ambrosia.LookInDirection(OctDir.Down);
		ThirdMember.LookInDirection(OctDir.Down);
		Willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(0.5f);
		yield return UnitTeleportToMapViaEntranceTile(Willa, ToCamStation);
		yield return UnitTeleportToMapViaEntranceTile(ThirdMember, ToCamStation);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, ToCamStation);
		yield return UnitTeleportToMapViaEntranceTile(Archi, ToCamStation);
		CutsceneEnd();
		yield return null;
		CutsceneBegin();
		UnitMoveToTarget(Archi, T_Archi);
		yield return MapGoto(SubwayTrainLogic);
		UIObjectives.Inst.CompleteObjective(objEscapeToTheSubwayString);
		HAGIS.ToggleShakeEnvironment(on: true);
		MusicPlay("event:/music/tracks/basic/willa theme");
		Archi.LookInDirection(OctDir.Down);
		yield return UnitMoveToTarget(Willa, WillaSittingPoint);
		yield return CreateTimeCondition(1f);
		Willa.LookInDirection(OctDir.Up);
		Archi.LookAt(Willa);
		ThirdMember.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return Willa.unitModel.Play("CsTransDruggedToDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		yield return HAGIS.DialogShow(dialog_ArchiSubwayTrain);
		yield return UnitMoveToUnit(Archi, Willa);
		Archi.LookAt(Willa);
		yield return Archi.unitModel.Play("CsTransDIdleToKneel");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneel");
		yield return HAGIS.DialogShow(ambient_ArchiCheckingOnWilla1);
		yield return HAGIS.DialogShow(dialog_ArchiCheckingOnWilla2);
		yield return null;
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		ThirdMember.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitTeleportToMapViaEntranceTile(Willa, MollysToFiles);
		yield return UnitTeleportToMapViaEntranceTile(ThirdMember, MollysToFiles);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, MollysToFiles);
		yield return UnitTeleportToMapViaEntranceTile(Archi, MollysToFiles);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		ThirdMember.gameObject.SetActive(value: false);
		Ambrosia.gameObject.SetActive(value: false);
		Mund.gameObject.SetActive(value: true);
		FuselGanster1.gameObject.SetActive(value: true);
		FuselGanster2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		MusicPlay("event:/music/tracks/basic/mund theme");
		yield return MapGoto(AndroidServicing);
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Android servicing cutscene Start");
		CamStationToTrain.gameObject.SetActive(value: false);
		ToFilesStation.gameObject.SetActive(value: true);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultSlowWalk);
		Willa.PreferWalk = false;
		yield return CutscenePlay("A1O8_Cutscene_MollySurrounded");
		yield return CutscenePlay("A1O8_Cutscene_WillaEnters");
	}
}
public class HAGIS_A1S1 : HAGIS
{
	private Unit Ashley;

	private Unit droidFirst;

	private Unit enemyDroid1;

	private Unit enemyDroid2;

	private Unit willa;

	private Unit terri;

	private Unit bernard;

	private Unit nursaryDroid;

	private Unit nursaryDroid2;

	private Unit museumUsher;

	private Unit platformDroid1;

	private Unit platformDroid2;

	private Unit TheoRobot;

	private Unit theo;

	private Unit WonderingNPC;

	private Unit WonderingNPC1;

	private Unit WonderingNPC2;

	private Unit WonderingNPC3;

	private Unit WonderingNPC4;

	private int whatToDo;

	private UnitTarget ashBalcony;

	private UnitTarget suspiciousDroid;

	private UnitTarget droid1ToPos;

	private UnitTarget droid2ToPos;

	private UnitTarget ashExitsSkyway;

	private UnitTarget ashSkywayGlass;

	private UnitTarget ashToCityCentreCover;

	private UnitTarget ashLookAtMuseum;

	private UnitTarget terriInterupted;

	private UnitTarget terriToDoor;

	private UnitTarget bernardToWilla;

	private UnitTarget willaToBernard;

	private UnitTarget terriToStation;

	private UnitTarget willaToBin;

	private UnitTarget willaToPoster;

	private UnitTarget ashHidesNursery;

	private UnitTarget droidToAsh;

	private UnitTarget flankingDroid;

	private UnitTarget otherDroid;

	private UnitTarget UsherMove;

	private UnitTarget ashAfterFight;

	private UnitTarget willaAfterFight;

	private UnitTarget ashHidesFromTheo;

	private UnitTarget willaFromVent;

	private UnitTarget willaToEarpiece;

	private UnitTarget T_Willa_RM;

	private UnitTarget willaToScreen;

	private UnitTarget willaWalkAway;

	private UnitTarget willaToChute;

	private UnitTarget willaLookAtChute;

	private TileTrigger tenoryCityCoverHighlight;

	private TileTrigger usherTrigger;

	private TileTrigger TT_Chute1;

	private TileActionSwapMap TenorToSkyway;

	private TileActionSwapMap skywayToTenor;

	private TileActionSwapMap skywayToFarm;

	private TileActionSwapMap farmWindow;

	private TileActionSwapMap farmToSkyway;

	private TileActionSwapMap tenorToMuseum;

	private TileActionSwapMap museumToExhibit;

	private TileActionSwapMap FrissionToCityCentre;

	private TileActionSwapMap platformToExhibit;

	private TileActionSwapMap fissionToPlatform;

	private TileActionSwapMap fissionToMaintenance;

	private TileActionSwapMap maintenanceToFission;

	private TileActionSwapMap outsideToMaintenance;

	private TileActionDialog dialogTenorCityNPC;

	private TileActionDialog DialogPlants;

	private TileActionDialog DialogPoster;

	private TileActionDialog nursaryWindow;

	private TileActionDialog DialogPod1;

	private TileActionDialog DialogPod3;

	private TileActionDialog DialogPod4;

	private TileActionDialog DialogPod5;

	private TileActionDialog DialogNursWindow;

	private TileActionDialog I_Museum;

	private TileActionInteraction escapeWindow;

	private TileActionInteraction escapeWindowSecondInt;

	private TileActionInteraction I_ToSkyway;

	private TileActionInteraction TT_Chute2;

	private TileActionHotspot I_Map;

	private TileActionHotspot I_MuseumSign;

	private TileActionHotspot InteractionBin;

	private TileActionHotspot DialogBinAlreadyChecked;

	private TileBlockDynamic vent1;

	private TileBlockDynamic vent2;

	private TileBlockDynamic maintenanceVent;

	private TileBlockDynamic MundBlock;

	private DialogData dialog_droidSeesAsh;

	private DialogData dialog_aLittleHelp;

	private DialogData dialog_ashToSkyway;

	private DialogData dialog_tellCravenMusLocked;

	private DialogData tutorial_Surrounded;

	private DialogData tutorial_BehindCover;

	private DialogData dialog_tutorial_Headset;

	private DialogData dialog_tutorial_Controller;

	private DialogData tutorial_PlayerMisses;

	private DialogData tutorial_PlayerMissesAgain;

	private DialogData tutorial_PlayerMissesThirdTime;

	private DialogData tutorial_PlayerHitsEnemy;

	private DialogData tutorial_EnemyAttacks_Headset;

	private DialogData tutorial_EnemyAttacks_Gamepad;

	private DialogData tutorial_EnemyAttacks_GearVRRemote;

	private DialogData tutorial_PlayerDodges;

	private DialogData tutorial_PlayerHit;

	private DialogData tutorial_CombatTutOver;

	private DialogData tutorial_RPGBegins;

	private DialogData dialog_GoOn;

	private DialogData dialog_goodNight;

	private DialogData dialog_thanksTerri;

	private DialogData dialog_bernardGivesGun;

	private DialogData dialog_bernardGivesTicket;

	private DialogData dialog_immigrationPapers;

	private DialogData dialog_NicePlants;

	private DialogData dialog_NicePoster;

	private DialogData dialog_hasToLeave;

	private DialogData dialog_inviteTerri;

	private DialogData dialog_terriExcuse;

	private DialogData dialog_sadThanks;

	private DialogData dialog_speaksToMom;

	private DialogData dialog_visitingHours;

	private DialogData dialog_checkBin;

	private DialogData dialog_lootsBin;

	private DialogData dialog_tickTock;

	private DialogData dialog_willaGoodNight;

	private DialogData dialog_startsInFive;

	private DialogData dialog_ticket;

	private DialogData dialog_liveInSixty;

	private DialogData dialog_callingWilla;

	private DialogData dialog_ashleyApproach;

	private DialogData dialog_willaScream;

	private DialogData dialog_dontShootWilla;

	private DialogData dialog_droidJoin;

	private DialogData dialog_inTrouble;

	private DialogData dialog_drowning;

	private DialogData dialog_sorryToWilla;

	private DialogData dialog_whatToAsh;

	private DialogData dialog_sorryAgain;

	private DialogData ambient_KeepAshSafe;

	private DialogData dialog_willaProtest;

	private DialogData dialog_cantMuzzle;

	private DialogData dialog_Forties;

	private DialogData dialog_letHerGo;

	private DialogData dialog_ashShoutsDont;

	private DialogData dialog_willaHoldsAsh;

	private DialogData dialog_ashleyDies;

	private DialogData dialog_faceTimeBernard;

	private DialogData dialog_linkToScreen;

	private DialogData dialog_willaMeetsCraven;

	private DialogData dialog_theoReturns;

	private DialogData dialog_whatToDo;

	private DialogData dialog_entersFromVent;

	private DialogData dialog_hartmanSpeaksToWilla;

	private DialogData dialog_kiddingWindow;

	private DialogData dialog_windowAgain;

	private DialogData ambient_BayTakeABreath;

	private DialogData dialog_getToTheChute;

	private DialogData dialog_wannaGoHome;

	private DialogData dialog_aboutToJump;

	private DialogData dialog_willaQuestion;

	private DialogData dialog_lie;

	private string objDefendString = "OBJECTIVES_A1S1_01";

	private string objCheckMap = "OBJECTIVES_A1S1_02";

	private string objGetToWillaString = "OBJECTIVES_A1S1_03";

	private string objFindTicketsString = "OBJECTIVES_A1S1_04";

	private string objMuseumString = "OBJECTIVES_A1S1_05";

	private string objShowTicketString = "OBJECTIVES_A1S1_06";

	private string objWillaString = "OBJECTIVES_A1S1_07";

	private string objConvinceWillaString = "OBJECTIVES_A1S1_08";

	private string objDroidsString = "OBJECTIVES_A1S1_09";

	private string objEscapeString = "OBJECTIVES_A1S1_10";

	private string objChuteString = "OBJECTIVES_A1S1_11";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot tenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot maintenanceBay = GetLogicUsingArtName("T2RobotMaintenanceBay");
		LogicRoot outsideTheCity = GetLogicUsingArtName("T2OutsideTheCity");
		LogicRoot museumOfCulture = GetLogicUsingArtName("T2MuseumOfCulture");
		LogicRoot fissionTechtonics = GetLogicUsingArtName("T2FissionTechtonicsExhibit");
		LogicRoot billysHilltopFarm = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot ascensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		LogicRoot ascensionPlatform = GetLogicUsingArtName("T2AscensionPlatform");
		LogicRoot skyway = GetLogicUsingArtName("T2Skyway");
		Ashley = GC.Inst.GetUnitWithId("829_T2TenorCityCentre_UnitSpawn");
		droidFirst = GC.Inst.GetUnitWithId("D15_T2TenorCityCentre_UnitSpawn");
		enemyDroid1 = GC.Inst.GetUnitWithId("507_T2TenorCityCentre_UnitSpawn");
		enemyDroid2 = GC.Inst.GetUnitWithId("FE3_T2TenorCityCentre_UnitSpawn");
		willa = GC.Inst.GetUnitWithId("BE1_T1Subway_TrainInterior_UnitSpawn");
		terri = GC.Inst.GetUnitWithId("F3D_T2BillysHilltopFarm_UnitSpawn");
		bernard = GC.Inst.GetUnitWithId("F62_T2BillysHilltopFarm_UnitSpawn");
		nursaryDroid = GC.Inst.GetUnitWithId("799_T2BillysHilltopFarm_UnitSpawn");
		nursaryDroid2 = GC.Inst.GetUnitWithId("F9A_T2BillysHilltopFarm_UnitSpawn");
		museumUsher = GC.Inst.GetUnitWithId("571_T2MuseumOfCulture_UnitSpawn");
		platformDroid1 = GC.Inst.GetUnitWithId("F59_T2BillysHilltopFarm_UnitSpawn");
		platformDroid2 = GC.Inst.GetUnitWithId("B8B_T2BillysHilltopFarm_UnitSpawn");
		theo = GC.Inst.GetUnitWithId("735_T2AscensionPlatform_UnitSpawn");
		TheoRobot = GC.Inst.GetUnitWithId("9BB_T2AscensionPlatform_UnitSpawn");
		WonderingNPC = GC.Inst.GetUnitWithId("B96_T2MuseumOfCulture_UnitSpawn");
		WonderingNPC1 = GC.Inst.GetUnitWithId("492_T2TenorCityCentre_UnitSpawn");
		WonderingNPC2 = GC.Inst.GetUnitWithId("B2E_T2TenorCityCentre_UnitSpawn");
		WonderingNPC3 = GC.Inst.GetUnitWithId("FF9_T2TenorCityCentre_UnitSpawn");
		WonderingNPC4 = GC.Inst.GetUnitWithId("FCB_T2TenorCityCentre_UnitSpawn");
		TileTrigger hydroponicsCoverHighlight = MR.Inst.GetTileTrigger("6C8_T2Hydroponics_TileTrigger");
		tenoryCityCoverHighlight = MR.Inst.GetTileTrigger("238_T2TenorCityCentre_TileTrigger");
		TT_Chute1 = MR.Inst.GetTileTrigger("108_T2OutsideTheCity_TileTrigger");
		TenorToSkyway = MR.Inst.GetTileActionSwapMap("AF6_T2TenorCityCentre_TileActionSwapMap");
		skywayToTenor = MR.Inst.GetTileActionSwapMap("DAE_T2Skyway_TileActionSwapMap");
		skywayToFarm = MR.Inst.GetTileActionSwapMap("89E_T2Skyway_TileActionSwapMap");
		farmWindow = MR.Inst.GetTileActionSwapMap("1F7_T2BillysHilltopFarm_TileActionSwapMap");
		farmToSkyway = MR.Inst.GetTileActionSwapMap("0EB_T1Subway_TrainInterior_TileActionSwapMap");
		nursaryWindow = MR.Inst.GetTileActionDialog("B40_T2BillysHilltopFarm_TileActionDialog");
		tenorToMuseum = MR.Inst.GetTileActionSwapMap("895_T2TenorCityCentre_TileActionSwapMap");
		museumToExhibit = MR.Inst.GetTileActionSwapMap("2AE_T2MuseumOfCulture_TileActionSwapMap");
		platformToExhibit = MR.Inst.GetTileActionSwapMap("68F_T2AscensionPlatform_TileActionSwapMap");
		fissionToPlatform = MR.Inst.GetTileActionSwapMap("A3D_T2FissionTechtonicsExhibit_TileActionSwapMap");
		fissionToMaintenance = MR.Inst.GetTileActionSwapMap("B23_T2FissionTechtonicsExhibit_TileActionSwapMap");
		maintenanceToFission = MR.Inst.GetTileActionSwapMap("E1C_T1AndroidServicing_TileActionSwapMap");
		FrissionToCityCentre = MR.Inst.GetTileActionSwapMap("357_T2FissionTechtonicsExhibit_TileActionSwapMap");
		escapeWindow = MR.Inst.GetTileActionInteraction("35A_T2RobotMaintenanceBay_TileActionInteraction");
		escapeWindowSecondInt = MR.Inst.GetTileActionInteraction("42F_T2RobotMaintenanceBay_TileActionInteraction");
		I_ToSkyway = MR.Inst.GetTileActionInteraction("E14_T2TenorCityCentre_TileActionInteraction");
		TT_Chute2 = MR.Inst.GetTileActionInteraction("33C_T2OutsideTheCity_TileActionInteraction");
		outsideToMaintenance = MR.Inst.GetTileActionSwapMap("17B_T2OutsideTheCity_TileActionSwapMap");
		dialogTenorCityNPC = MR.Inst.GetTileActionDialog("B23_T1Cambridge_TileActionDialog");
		DialogPod1 = MR.Inst.GetTileActionDialog("EF5_T2BillysHilltopFarm_TileActionDialog");
		DialogPod3 = MR.Inst.GetTileActionDialog("9D0_T2Hydroponics_TileActionDialog");
		DialogPod4 = MR.Inst.GetTileActionDialog("75C_T2BillysHilltopFarm_TileActionDialog");
		DialogPod5 = MR.Inst.GetTileActionDialog("6D3_T2BillysHilltopFarm_TileActionDialog");
		DialogNursWindow = MR.Inst.GetTileActionDialog("B40_T2BillysHilltopFarm_TileActionDialog");
		I_Museum = MR.Inst.GetTileActionDialog("B22_T2TenorCityCentre_TileActionDialog");
		I_Map = MR.Inst.GetTileActionHotspot("9C2_T2TenorCityCentre_TileActionHotspot");
		I_MuseumSign = MR.Inst.GetTileActionHotspot("BD7_T2TenorCityCentre_TileActionHotspot");
		TileActionHotspot I_JulesStatu = MR.Inst.GetTileActionHotspot("262_T2TenorCityCentre_TileActionHotspot");
		TileActionHotspot I_Propeganda = MR.Inst.GetTileActionHotspot("E2D_T2TenorCityCentre_TileActionHotspot");
		InteractionBin = MR.Inst.GetTileActionHotspot("3CB_T2Hydroponics_TileActionHotspot");
		DialogBinAlreadyChecked = MR.Inst.GetTileActionHotspot("6E6_T2Hydroponics_TileActionHotspot");
		I_JulesStatu.dialog = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/Dialog_BrassPlaque");
		I_Propeganda.dialog = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/DialogAshleyMoansAboutBadGrammar");
		ashBalcony = MR.Inst.GetUnitTarget("633_T2TenorCityCentre_UnitTarget");
		suspiciousDroid = MR.Inst.GetUnitTarget("370_T2TenorCityCentre_UnitTarget");
		droid1ToPos = MR.Inst.GetUnitTarget("232_T2TenorCityCentre_UnitTarget");
		droid2ToPos = MR.Inst.GetUnitTarget("B92_T2TenorCityCentre_UnitTarget");
		ashExitsSkyway = MR.Inst.GetUnitTarget("633_T2Skyway_UnitTarget");
		ashSkywayGlass = MR.Inst.GetUnitTarget("613_T2Skyway_UnitTarget");
		UsherMove = MR.Inst.GetUnitTarget("B3E_T2MuseumOfCulture_UnitTarget");
		ashToCityCentreCover = MR.Inst.GetUnitTarget("02A_T2TenorCityCentre_UnitTarget");
		ashLookAtMuseum = MR.Inst.GetUnitTarget("1E7_T2TenorCityCentre_UnitTarget");
		terriInterupted = MR.Inst.GetUnitTarget("9EB_T2BillysHilltopFarm_UnitTarget");
		terriToDoor = MR.Inst.GetUnitTarget("A72_T2BillysHilltopFarm_UnitTarget");
		bernardToWilla = MR.Inst.GetUnitTarget("53D_T2BillysHilltopFarm_UnitTarget");
		willaToBernard = MR.Inst.GetUnitTarget("CBB_T2BillysHilltopFarm_UnitTarget");
		terriToStation = MR.Inst.GetUnitTarget("5F8_T2BillysHilltopFarm_UnitTarget");
		willaToBin = MR.Inst.GetUnitTarget("67A_T2BillysHilltopFarm_UnitTarget");
		willaToPoster = MR.Inst.GetUnitTarget("722_T2BillysHilltopFarm_UnitTarget");
		ashHidesNursery = MR.Inst.GetUnitTarget("BB4_T2BillysHilltopFarm_UnitTarget");
		droidToAsh = MR.Inst.GetUnitTarget("945_T2BillysHilltopFarm_UnitTarget");
		flankingDroid = MR.Inst.GetUnitTarget("A4E_T2BillysHilltopFarm_UnitTarget");
		otherDroid = MR.Inst.GetUnitTarget("8E5_T2Hydroponics_UnitTarget");
		UnitTarget droidToAshTut = MR.Inst.GetUnitTarget("98E_T2Hydroponics_UnitTarget");
		ashAfterFight = MR.Inst.GetUnitTarget("42A_T2AscensionPlatform_UnitTarget");
		willaAfterFight = MR.Inst.GetUnitTarget("448_T2AscensionPlatform_UnitTarget");
		willaToScreen = MR.Inst.GetUnitTarget("6C5_T2FissionTechtonicsExhibit_UnitTarget");
		willaWalkAway = MR.Inst.GetUnitTarget("393_T2FissionTechtonicsExhibit_UnitTarget");
		vent1 = MR.Inst.GetTileBlockDynamic("F84_T2FissionTechtonicsExhibit_TileBlockDynamic");
		vent2 = MR.Inst.GetTileBlockDynamic("AD6_T2FissionTechtonicsExhibit_TileBlockDynamic");
		maintenanceVent = MR.Inst.GetTileBlockDynamic("83D_T2RobotMaintenanceBay_TileBlockDynamic");
		MundBlock = MR.Inst.GetTileBlockDynamic("FF3_T2AscensionPlatform_TileBlockDynamic");
		willaFromVent = MR.Inst.GetUnitTarget("F26_T2RobotMaintenanceBay_UnitTarget");
		willaToEarpiece = MR.Inst.GetUnitTarget("197_T2RobotMaintenanceBay_UnitTarget");
		T_Willa_RM = MR.Inst.GetUnitTarget("218_T2RobotMaintenanceBay_UnitTarget");
		willaToChute = MR.Inst.GetUnitTarget("833_T2OutsideTheCity_UnitTarget");
		willaLookAtChute = MR.Inst.GetUnitTarget("4C8_T2OutsideTheCity_UnitTarget");
		dialog_droidSeesAsh = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/DialogUCDroidSeesAsh");
		dialog_aLittleHelp = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/DialogALittleHelp");
		dialog_ashToSkyway = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/DialogPointAshToSkyway");
		dialog_tutorial_Headset = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_Headset");
		dialog_tutorial_Controller = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_Controller");
		tutorial_Surrounded = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_Surrounded");
		tutorial_BehindCover = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_BehindCover");
		tutorial_PlayerMisses = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMisses");
		tutorial_PlayerMissesAgain = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMissesAgain");
		tutorial_PlayerMissesThirdTime = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMissesThirdTime");
		tutorial_PlayerHitsEnemy = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerHitsEnemy");
		tutorial_EnemyAttacks_Gamepad = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_EnemyAttacks_Gamepad");
		tutorial_EnemyAttacks_GearVRRemote = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_EnemyAttacks_GearVRRemote");
		tutorial_EnemyAttacks_Headset = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_EnemyAttacks_Headset");
		tutorial_PlayerDodges = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerDodges");
		tutorial_PlayerHit = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerHit");
		tutorial_CombatTutOver = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_CombatTutOver");
		tutorial_RPGBegins = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_RPGBegins");
		DialogData Tutorial_SurroundedAgain = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_SurroundedAgain");
		DialogData Tutorial_GetTactical = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_GetTactical");
		DialogData Tutorial_Overwatch = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_Overwatch");
		DialogData Tutorial_OverwatchHit = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_OverwatchHit");
		DialogData Tutorial_OverwatchMiss = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_OverwatchMiss");
		DialogData Tutorial_Experiment = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_Experiment");
		dialog_tellCravenMusLocked = HAGIS.DialogLoad("Dialogs/A1S1/TenorCityCentre/DialogAshleySkyrideToFarm");
		dialog_GoOn = HAGIS.DialogLoad("Dialogs/A1S1/Skyway/DialogWellGoOnAhead");
		dialog_visitingHours = HAGIS.DialogLoad("Dialogs/A1S1/HydroponicsPlant/DialogFarmVisitingHours");
		dialog_checkBin = HAGIS.DialogLoad("Dialogs/A1S1/HydroponicsPlant/DialogHartmanCheckTheBin");
		dialog_lootsBin = HAGIS.DialogLoad("Dialogs/A1S1/HydroponicsPlant/DialogAshleyLooksBin");
		dialog_startsInFive = HAGIS.DialogLoad("Dialogs/A1S1/MuseumOfCulture/DialogFiveMinsToGo");
		dialog_ticket = HAGIS.DialogLoad("Dialogs/A1S1/MuseumOfCulture/DialogUsherAshleyTicket");
		dialog_liveInSixty = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogLiveInSixty");
		dialog_callingWilla = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshleyUnderstood");
		dialog_ashleyApproach = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshleyApproachesWilla");
		dialog_willaScream = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaScreamsForTheWatch");
		dialog_dontShootWilla = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshDontShootWilla");
		dialog_droidJoin = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogDroidJoinsWillaAshFight");
		dialog_inTrouble = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshWillaFightInTrouble");
		dialog_drowning = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshWillaFightDrowning");
		dialog_sorryToWilla = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshSaysSophia");
		dialog_whatToAsh = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaSaysWhatToAsh");
		dialog_sorryAgain = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaSaysWhatToAsh2");
		dialog_willaProtest = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaProtestsExecution");
		dialog_cantMuzzle = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshMuzzleEveryone");
		dialog_Forties = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogTheoWorkedInTheForties");
		dialog_letHerGo = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaTremblingLetHerGo");
		dialog_ashShoutsDont = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshProtectsWilla");
		dialog_willaHoldsAsh = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogWillaHoldsAsh");
		dialog_ashleyDies = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/DialogAshleyDies");
		ambient_KeepAshSafe = HAGIS.DialogLoad("Dialogs/A1S1/AscensionPlatform/Ambient_KeepAshSafe");
		dialog_faceTimeBernard = HAGIS.DialogLoad("Dialogs/A1S1/FissionTechtonics/DialogWillaFaceTimesBernard");
		dialog_linkToScreen = HAGIS.DialogLoad("Dialogs/A1S1/FissionTechtonics/DialogHartmanLinksFirstScreen");
		dialog_willaMeetsCraven = HAGIS.DialogLoad("Dialogs/A1S1/FissionTechtonics/DialogWillaAndCravenMeet");
		dialog_theoReturns = HAGIS.DialogLoad("Dialogs/A1S1/FissionTechtonics/DialogTheoIsNearby");
		dialog_whatToDo = HAGIS.DialogLoad("Dialogs/A1S1/FissionTechtonics/DialogCravenSaysPlease");
		dialog_entersFromVent = HAGIS.DialogLoad("Dialogs/A1S1/RobotMaintenanceBay/AmbientWillaEntersGrossMaintenanceBay");
		dialog_hartmanSpeaksToWilla = HAGIS.DialogLoad("Dialogs/A1S1/RobotMaintenanceBay/DialogHartmanSpeaksToWillaInBayFirstTime");
		dialog_kiddingWindow = HAGIS.DialogLoad("Dialogs/A1S1/RobotMaintenanceBay/DialogWillaKiddingWindow");
		dialog_windowAgain = HAGIS.DialogLoad("Dialogs/A1S1/RobotMaintenanceBay/DialogWillaKiddingWindowSecondTime");
		ambient_BayTakeABreath = HAGIS.DialogLoad("Dialogs/A1S1/RobotMaintenanceBay/Ambient_BayTakeABreath");
		dialog_getToTheChute = HAGIS.DialogLoad("Dialogs/A1S1/OutsideTheCity/DialogDescentChute1");
		dialog_wannaGoHome = HAGIS.DialogLoad("Dialogs/A1S1/OutsideTheCity/DialogDescentChute2");
		dialog_aboutToJump = HAGIS.DialogLoad("Dialogs/A1S1/OutsideTheCity/DialogDescentChute3");
		dialog_willaQuestion = HAGIS.DialogLoad("Dialogs/A1S1/OutsideTheCity/DialogDescentChuteWereYouWatching");
		dialog_lie = HAGIS.DialogLoad("Dialogs/A1S1/OutsideTheCity/DialogImportantCravenLie");
		I_Museum.gameObject.SetActive(value: false);
		TenorToSkyway.gameObject.SetActive(value: false);
		tenoryCityCoverHighlight.gameObject.SetActive(value: false);
		hydroponicsCoverHighlight.gameObject.SetActive(value: false);
		skywayToFarm.gameObject.SetActive(value: false);
		farmToSkyway.gameObject.SetActive(value: false);
		terri.gameObject.SetActive(value: false);
		bernard.gameObject.SetActive(value: false);
		InteractionBin.gameObject.SetActive(value: false);
		DialogBinAlreadyChecked.gameObject.SetActive(value: false);
		nursaryWindow.gameObject.SetActive(value: false);
		tenorToMuseum.gameObject.SetActive(value: false);
		museumToExhibit.gameObject.SetActive(value: false);
		platformDroid1.gameObject.SetActive(value: false);
		platformDroid2.gameObject.SetActive(value: false);
		theo.gameObject.SetActive(value: false);
		escapeWindow.gameObject.SetActive(value: false);
		escapeWindowSecondInt.gameObject.SetActive(value: false);
		DialogNursWindow.gameObject.SetActive(value: false);
		DialogPod1.gameObject.SetActive(value: false);
		DialogPod3.gameObject.SetActive(value: false);
		DialogPod4.gameObject.SetActive(value: false);
		DialogPod5.gameObject.SetActive(value: false);
		TenorToSkyway.gameObject.SetActive(value: false);
		I_ToSkyway.gameObject.SetActive(value: false);
		TheoRobot.gameObject.SetActive(value: false);
		fissionToMaintenance.gameObject.SetActive(value: false);
		Ashley.gameObject.SetActive(value: false);
		enemyDroid1.gameObject.SetActive(value: false);
		enemyDroid2.gameObject.SetActive(value: false);
		FrissionToCityCentre.gameObject.SetActive(value: false);
		dialogTenorCityNPC.gameObject.SetActive(value: false);
		WonderingNPC.gameObject.SetActive(value: false);
		WonderingNPC1.gameObject.SetActive(value: false);
		WonderingNPC2.gameObject.SetActive(value: false);
		WonderingNPC3.gameObject.SetActive(value: false);
		WonderingNPC4.gameObject.SetActive(value: false);
		MundBlock.gameObject.SetActive(value: false);
		Ability_MaxHP droidHP1 = nursaryDroid.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		droidHP1.SetHPMod(-4);
		Ability_MaxHP droidHP2 = nursaryDroid2.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		droidHP2.SetHPMod(-4);
		Ability_MaxHP tutEnemyHP1 = enemyDroid1.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		tutEnemyHP1.SetHPMod(-5);
		Ability_MaxHP tutEnemyHP2 = enemyDroid2.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		tutEnemyHP2.SetHPMod(-5);
		Ability_DEBUG_CantDie droid1CantDieInFirstShot = enemyDroid1.abilities.Add<Ability_DEBUG_CantDie>(null, isUpgraded: false);
		PlayMapAnimation(tenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainInvisible");
		yield return null;
		Singleton<NPCWanderController>.Inst.PauseWandering();
		while (droidFirst.HP > 1)
		{
			droidFirst.HPDecrement(1);
		}
		bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleWeapon");
		yield return null;
		bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkWeapon");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleClipboard");
		TheoRobot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		TheoRobot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "DefaultWalk");
		enemyDroid1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatIdle");
		enemyDroid1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchHit, "CombatHit");
		enemyDroid1.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchDodge, "CombatDodge");
		willa.UpdateIdleAnim();
		yield return CutscenePlay("A1S1_Cutscene0");
		SKIP_POINT("Skipped half of cutscene");
		yield return CutscenePlay("A1S1_Cutscene1");
		UIStatusBar.Inst.HACK_showEndTurnButton = false;
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
		droidFirst.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped to Combat Tutorial");
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefendString);
		enemyDroid1.IsMovementDisabled = true;
		enemyDroid2.IsMovementDisabled = true;
		enemyDroid1.IsTargetable = false;
		enemyDroid2.IsTargetable = false;
		LR.HACK_tutorialMode = true;
		UIWhamBar.Inst.tutorialCannotLose = true;
		UIWhamBar.Inst.tutorialTapText = true;
		UIWhamBar.Inst.tutorialAllowCrits = false;
		SC.Inst.HACK_tutorialMode = true;
		UIStatusBar.Inst.HACK_showEndTurnButton = false;
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
		AshleySafelyRemoveAbility<Ability_Combat_Medic_Small>();
		AshleySafelyRemoveAbility<Ability_Hunker_Down>();
		AshleySafelyRemoveAbility<Ability_Headshot>();
		AshleySafelyRemoveAbility<Ability_Overwatch>();
		CombatBegin(UnitTeam.Type.Player);
		if (!MR.Inst.IsSkipping())
		{
			HAGIS.inheritMidCombatSkip = true;
			CutsceneBegin();
			yield return HAGIS.DialogShow(tutorial_Surrounded);
			tenoryCityCoverHighlight.gameObject.SetActive(value: true);
			yield return null;
			CutsceneEnd();
			ParticlePrefab findCoverParticle = ShowCoordSelect(tenoryCityCoverHighlight.GetCoord());
			allTutorialParticles.Add(findCoverParticle);
			SetExplicitTileMovement(tenoryCityCoverHighlight.GetCoord());
			yield return CreateTriggerCondition(tenoryCityCoverHighlight._OnTriggered);
			findCoverParticle.StopParticles();
			allTutorialParticles.Remove(findCoverParticle);
			CutsceneBegin();
			yield return HAGIS.DialogShow(tutorial_BehindCover);
			Ashley.IsMovementDisabled = true;
			enemyDroid1.IsTargetable = true;
			SetExplicitTileMovement(enemyDroid1.coord);
			SetExplicitUnitToAttack(enemyDroid1);
			CutsceneEnd();
			ParticlePrefab attackEnemyDroid1Particle = ShowCoordSelect(enemyDroid1.coord);
			allTutorialParticles.Add(attackEnemyDroid1Particle);
			Ability_DEBUG_SilentAccuracyMod accDebuff = Ashley.abilities.Add<Ability_DEBUG_SilentAccuracyMod>(null, isUpgraded: false);
			accDebuff.accuracyMod -= 0.25f;
			yield return Ashley.OnFinishedAttack;
			attackEnemyDroid1Particle.StopParticles();
			allTutorialParticles.Remove(findCoverParticle);
			Ashley.abilities.Remove(accDebuff, isProxy: false);
			CutsceneBegin();
			yield return HAGIS.DialogShow(tutorial_PlayerHitsEnemy);
			yield return CreateTimeCondition(0.5f);
			switch (IC.controlInputType)
			{
			case IC.InputType.GamePad:
			case IC.InputType.XboxController:
				yield return HAGIS.DialogShow(tutorial_EnemyAttacks_Gamepad);
				break;
			case IC.InputType.GearVRController:
				yield return HAGIS.DialogShow(tutorial_EnemyAttacks_GearVRRemote);
				break;
			case IC.InputType.Touch:
				yield return HAGIS.DialogShow(tutorial_EnemyAttacks_Headset);
				break;
			}
			UIWhamBar.Inst.firstTutorialAttempt = false;
			UIWhamBar.Inst.tutorialMissDialog = false;
			CutsceneEnd();
			Ability_DEBUG_SilentDodgeMod dodgeBuff = Ashley.abilities.Add<Ability_DEBUG_SilentDodgeMod>(null, isUpgraded: false);
			dodgeBuff.dodgeChanceMod = 200;
			dodgeBuff.dodgeSizeMod = 0.2f;
			enemyDroid1.StartAttack(Ashley, enemyDroid1.mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.DodgeWhamBar);
			yield return enemyDroid1.OnFinishedAttack;
			Ashley.abilities.Remove(dodgeBuff, isProxy: false);
			CutsceneBegin();
			yield return HAGIS.DialogShow(tutorial_PlayerDodges);
			yield return CreateTimeCondition(0.5f);
			yield return HAGIS.DialogShow(tutorial_CombatTutOver);
			yield return ShowTutorialScreen(TutorialScreen.AbilityGaugeBasics);
			CutsceneEnd();
			UIWhamBar.Inst.tutorialCannotLose = false;
			UIWhamBar.Inst.tutorialTapText = false;
			enemyDroid1.IsMovementDisabled = false;
			enemyDroid2.IsMovementDisabled = false;
			enemyDroid2.IsTargetable = true;
			Ashley.IsMovementDisabled = false;
			HAGIS.inheritMidCombatSkip = false;
		}
		if (enemyDroid1.abilities.Exists<Ability_DEBUG_CantDie>())
		{
			enemyDroid1.abilities.Remove(droid1CantDieInFirstShot, isProxy: false);
		}
		enemyDroid1.APDecrement(enemyDroid1.AP);
		enemyDroid2.APDecrement(enemyDroid2.AP);
		CleanUpTutorial();
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
		yield return CombatWaitUntilComplete();
		if (MR.Inst.IsSkipping())
		{
			if (enemyDroid1.IsAlive())
			{
				enemyDroid1.Kill();
			}
			if (enemyDroid2.IsAlive())
			{
				enemyDroid2.Kill();
			}
		}
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
		HagisLog("yup, combat complete");
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objDefendString);
		yield return CreateTimeCondition(2f);
		Ashley.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ashley.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		SKIP_POINT("First combat tutorial skipped");
		HAGIS.DialogShow(tutorial_RPGBegins);
		UIObjectives.Inst.CompleteAndSetMainObjective(objCheckMap);
		yield return CreateTriggerCondition(I_MuseumSign.OnHotspotComplete);
		PlayMapAnimation(tenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainEnter");
		I_Museum.gameObject.SetActive(value: true);
		I_MuseumSign.gameObject.SetActive(value: false);
		I_ToSkyway.gameObject.SetActive(value: true);
		CutsceneBegin();
		Ashley.LookAt(I_Museum.transform);
		yield return HAGIS.DialogShow(dialog_tellCravenMusLocked);
		UIObjectives.Inst.CompleteObjective(objCheckMap);
		CutsceneEnd();
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objGetToWillaString);
		yield return CreateTriggerCondition(I_ToSkyway.OnTriggered);
		yield return HAGIS.DialogShow(dialog_GoOn);
		Ashley.SetTeamType(UnitTeam.Type.NPC);
		SKIP_POINT("skyway wait skipped");
		Singleton<NPCWanderController>.Inst.ResumeWandering();
		CutsceneBegin();
		UnitTeleportToMapViaEntranceTile(Ashley, farmWindow);
		Ashley.unitModel.LookAtDirectionLS(new Vector3(1f, 0f, 0f));
		Ashley.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objGetToWillaString);
		yield return PlayMapAnimation(tenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainExit");
		yield return MapGoto(billysHilltopFarm.Map);
		farmWindow.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return CutscenePlay("A1S1_Cutscene2");
		SKIP_POINT("cutscene of willa talking to bernard skipped");
		Ashley.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ashley.UpdateIdleAnim();
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UnitTeleportToMapViaEntranceTile(willa, platformToExhibit, willaAfterFight);
		yield return null;
		CutsceneBegin();
		farmWindow.gameObject.SetActive(value: false);
		nursaryWindow.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		Singleton<NPCWanderController>.Inst.DisableNPCWander(nursaryDroid);
		Singleton<NPCWanderController>.Inst.DisableNPCWander(nursaryDroid2);
		UnitMoveToTarget(nursaryDroid, flankingDroid, OctDir.Down);
		yield return UnitMoveToTarget(nursaryDroid2, otherDroid, OctDir.Left);
		yield return HAGIS.DialogShow(dialog_visitingHours);
		yield return null;
		Ashley.SetTeamType(UnitTeam.Type.Player);
		nursaryDroid.SetTeamType(UnitTeam.Type.Enemy);
		nursaryDroid2.SetTeamType(UnitTeam.Type.Enemy);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindTicketsString);
		SKIP_POINT("Overwatch Tutorial");
		UIStatusBar.Inst.HACK_showEndTurnButton = false;
		CombatBegin(UnitTeam.Type.Player);
		if (!MR.Inst.IsSkipping())
		{
			HAGIS.inheritMidCombatSkip = true;
			MusicSetIntensity(0.1f);
			LR.HACK_tutorialMode = true;
			SC.Inst.HACK_tutorialMode = true;
			UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
			UIWhamBar.Inst.firstTutorialAttempt = false;
			UIWhamBar.Inst.tutorialTapText = false;
			UIWhamBar.Inst.tutorialCannotLose = false;
			hydroponicsCoverHighlight.gameObject.SetActive(value: true);
			ParticlePrefab findCoverParticle = ShowCoordSelect(hydroponicsCoverHighlight.GetCoord());
			allTutorialParticles.Add(findCoverParticle);
			SetExplicitTileMovement(hydroponicsCoverHighlight.GetCoord());
			HAGIS.DialogShow(Tutorial_SurroundedAgain);
			nursaryDroid.IsTargetable = false;
			nursaryDroid.IsMovementDisabled = true;
			nursaryDroid.IsAttackingDisabled = true;
			nursaryDroid2.IsTargetable = false;
			nursaryDroid2.IsMovementDisabled = true;
			nursaryDroid2.IsAttackingDisabled = true;
			yield return CreateTriggerCondition(hydroponicsCoverHighlight._OnTriggered);
			findCoverParticle.StopParticles();
			allTutorialParticles.Remove(findCoverParticle);
			Ashley.abilities.Add<Ability_Overwatch>(null, isUpgraded: false);
			UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
			Ashley.IsMovementDisabled = true;
			CutsceneBegin();
			yield return HAGIS.DialogShow(Tutorial_GetTactical);
			CutsceneEnd();
			ParticlePrefab useOverwatchParticle = ShowCoordSelect(Ashley.coord);
			allTutorialParticles.Add(useOverwatchParticle);
			yield return UIAbilityWheel.Inst.OnShow;
			CutsceneBegin();
			yield return HAGIS.DialogShow(Tutorial_Overwatch);
			CutsceneEnd();
			yield return CreateTriggerCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).OnTurnStarted);
			Ashley.ShowStatusBar();
			useOverwatchParticle.StopParticles();
			allTutorialParticles.Remove(useOverwatchParticle);
			Ashley.IsAttackingDisabled = false;
			if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
			{
				yield return Singleton<AIC>.Inst.OnExternalAIBegan;
			}
			nursaryDroid.APDecrement(1);
			yield return UnitMoveToTarget(nursaryDroid, droidToAshTut, OctDir.Right);
			CutsceneBegin();
			if (nursaryDroid.HP < nursaryDroid.GetHPMax())
			{
				yield return HAGIS.DialogShow(Tutorial_OverwatchHit);
				yield return ShowTutorialScreen(TutorialScreen.AbilityWheel);
				HagisLog("HIT OVERWATCH");
			}
			else
			{
				yield return HAGIS.DialogShow(Tutorial_OverwatchMiss);
				yield return ShowTutorialScreen(TutorialScreen.AbilityWheel);
				HagisLog("MISSED OVERWATCH");
			}
			CutsceneEnd();
			HAGIS.inheritMidCombatSkip = false;
		}
		CleanUpTutorial();
		Ashley.IsMovementDisabled = false;
		Ashley.IsAttackingDisabled = false;
		Ashley.IsTargetable = true;
		nursaryDroid.IsMovementDisabled = false;
		nursaryDroid.IsAttackingDisabled = false;
		nursaryDroid.IsTargetable = true;
		nursaryDroid2.IsMovementDisabled = false;
		nursaryDroid2.IsAttackingDisabled = false;
		nursaryDroid2.IsTargetable = true;
		HAGIS.DialogShow(Tutorial_Experiment);
		Ashley.abilities.Add<Ability_Combat_Medic_Small>(null, isUpgraded: false);
		Ashley.abilities.Add<Ability_Headshot>(null, isUpgraded: false);
		Ashley.abilities.Add<Ability_Hunker_Down>(null, isUpgraded: false);
		yield return CombatWaitUntilComplete();
		if (nursaryDroid.IsAlive())
		{
			nursaryDroid.Kill();
		}
		if (nursaryDroid2.IsAlive())
		{
			nursaryDroid2.Kill();
		}
		MusicStop();
		UIObjectives.Inst.CompleteAndSetMainObjective(objMuseumString);
		SKIP_POINT("Nursary Droid combat skipped");
		CutsceneBegin();
		InteractionBin.gameObject.SetActive(value: true);
		Ashley.IsMovementDisabled = false;
		DialogNursWindow.gameObject.SetActive(value: true);
		DialogPod1.gameObject.SetActive(value: true);
		DialogPod3.gameObject.SetActive(value: true);
		DialogPod4.gameObject.SetActive(value: true);
		DialogPod5.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(dialog_checkBin);
		CutsceneEnd();
		yield return null;
		yield return CreateTriggerCondition(InteractionBin.OnHotspotShow);
		InteractionBin.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objShowTicketString);
		DialogBinAlreadyChecked.gameObject.SetActive(value: true);
		farmToSkyway.gameObject.SetActive(value: true);
		skywayToFarm.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped bin");
		dialogTenorCityNPC.gameObject.SetActive(value: true);
		WonderingNPC.gameObject.SetActive(value: true);
		WonderingNPC1.gameObject.SetActive(value: true);
		WonderingNPC2.gameObject.SetActive(value: true);
		WonderingNPC3.gameObject.SetActive(value: true);
		WonderingNPC4.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(tenorCityCentre.Map);
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		UIObjectives.Inst.CompleteObjective(objShowTicketString);
		WonderingNPC3.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
		SKIP_POINT("Tenor city wait skipped");
		I_Museum.gameObject.SetActive(value: false);
		TenorToSkyway.gameObject.SetActive(value: false);
		tenorToMuseum.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(museumOfCulture.Map);
		UIObjectives.Inst.CompleteAndSetMainObjective(objWillaString);
		SKIP_POINT("Skipped getting into museum");
		MusicStop();
		yield return dialog_ticket.OnComplete;
		museumToExhibit.gameObject.SetActive(value: true);
		SKIP_POINT("show ticket to usher skipped");
		yield return MapWaitUntilVisible(ascensionExhibit.Map);
		PlayMapAnimation(ascensionExhibit.Map, "CH_AscensionCurtain", "Open");
		MusicPlay("event:/music/tracks/diagetic/new savannah bgm muffled");
		UIObjectives.Inst.CompleteAndSetMainObjective(objConvinceWillaString);
		SKIP_POINT("skipped to Ascension Exhibit");
		yield return MapWaitUntilVisible(ascensionPlatform.Map);
		fissionToPlatform.gameObject.SetActive(value: false);
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objConvinceWillaString);
		SKIP_POINT("skipped to Ascension Platform");
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
		platformToExhibit.gameObject.SetActive(value: false);
		willa.gameObject.SetActive(value: true);
		yield return CutscenePlay("A1S1_Cutscene3");
		yield return CutscenePlay("A1S1_Cutscene4");
		SKIP_POINT("meet willa skipped");
		CutsceneBegin();
		willa.SetTeamType(UnitTeam.Type.Enemy);
		yield return HAGIS.DialogShow(ambient_KeepAshSafe);
		CutsceneEnd();
		yield return ShowTutorialScreen(TutorialScreen.CombatBar);
		CombatBegin(UnitTeam.Type.Player);
		willa.IsTargetable = false;
		UIObjectives.Inst.CompleteAndSetMainObjective(objDroidsString);
		yield return TurnModeWaitForPlayerTurnStart(2u);
		yield return HAGIS.DialogShow(dialog_dontShootWilla);
		yield return TurnModeWaitForPlayerTurnStart(3u);
		yield return EndTurnMode();
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Ashley.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Ashley.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		CutsceneBegin();
		yield return CreateTimeCondition(2f);
		willa.LookAt(Ashley);
		platformDroid1.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(willa, willaAfterFight);
		yield return UnitMoveToUnit(platformDroid1, willa);
		willa.LookAt(platformDroid1);
		yield return CreateTimeCondition(1f);
		platformDroid2.gameObject.SetActive(value: true);
		platformDroid1.LookAt(Ashley);
		yield return HAGIS.DialogShow(dialog_droidJoin);
		platformDroid1.LookAt(Ashley);
		Ashley.HPRefill();
		CutsceneEnd();
		willa.SetTeamType(UnitTeam.Type.NPC);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEscapeString);
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
		CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		MusicSetIntensity(0.1f);
		HagletYieldTerm ashleyWasHurt = CreateTriggerCondition(Ashley.OnUnitSustainedDamage);
		yield return CreateOrCondition(ashleyWasHurt, CombatWaitUntilComplete());
		if (ashleyWasHurt.met)
		{
			yield return HAGIS.DialogShow(dialog_inTrouble);
			ashleyWasHurt = CreateTriggerCondition(Ashley.OnUnitSustainedDamage);
			yield return CreateOrCondition(ashleyWasHurt, CombatWaitUntilComplete());
			if (ashleyWasHurt.met)
			{
				yield return HAGIS.DialogShow(dialog_drowning);
				yield return CombatWaitUntilComplete();
			}
		}
		SKIP_POINT("combat with willa and droids skipped");
		MusicStop();
		yield return null;
		Ashley.HPRefill();
		UIObjectives.Inst.CompleteObjective(objEscapeString);
		CutsceneBegin();
		willa.StartMovement(new v2i(5, 4), null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: true, avoidUnits: false, shouldReserveTile: false);
		Ashley.StartMovement(new v2i(8, 3), null, null, null, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: true, avoidUnits: false, shouldReserveTile: false);
		yield return null;
		while ((bool)willa.moving || (bool)Ashley.moving)
		{
			yield return null;
		}
		CutsceneEnd();
		yield return CutscenePlay("A1S1_Cutscene5");
		SKIP_POINT("Skipped cutscene 5");
		Ashley.SetTeamType(UnitTeam.Type.NPC);
		GC.Inst.SetRPGLeader(willa);
		yield return UnitTeleportToMapViaEntranceTile(willa, fissionToPlatform);
		SKIP_POINT("theo arrives and ash dies skipped");
		yield return MapGoto(fissionTechtonics);
		CutsceneBegin();
		vent1.gameObject.SetActive(value: false);
		vent2.gameObject.SetActive(value: false);
		maintenanceVent.gameObject.SetActive(value: false);
		willa.gameObject.SetActive(value: true);
		yield return null;
		CutsceneEnd();
		yield return CutscenePlay("A1S1_Cutscene7");
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk");
		yield return CutscenePlay("A1S1_Cutscene8");
		SKIP_POINT("meet craven skipped");
		yield return MapGoto(maintenanceBay);
		CutsceneBegin();
		MusicStop();
		willa.SetTeamType(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteAndSetMainObjective(objChuteString);
		fissionToMaintenance.gameObject.SetActive(value: true);
		maintenanceToFission.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return CutscenePlay("A1S1_Cutscene9");
		CutsceneBegin();
		vent1.gameObject.SetActive(value: true);
		vent2.gameObject.SetActive(value: true);
		maintenanceVent.gameObject.SetActive(value: true);
		CutsceneEnd();
		escapeWindow.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(escapeWindow.OnTriggered);
		yield return HAGIS.DialogShow(dialog_kiddingWindow);
		whatToDo = (int)dialog_kiddingWindow.currentResponseLine;
		switch (whatToDo)
		{
		case 1:
			yield return UnitPlayAnimation(willa, "CsDefaultClimbOutWindow");
			yield return UnitTeleportToMapViaEntranceTile(willa, outsideToMaintenance);
			willa.LookInDirection(OctDir.Right);
			yield return MapGoto(outsideTheCity.Map);
			break;
		case 2:
			yield return UnitMoveToTarget(willa, T_Willa_RM);
			HAGIS.DialogShow(ambient_BayTakeABreath);
			escapeWindow.gameObject.SetActive(value: false);
			escapeWindowSecondInt.gameObject.SetActive(value: true);
			while (true)
			{
				yield return CreateTriggerCondition(escapeWindowSecondInt.OnTriggered);
				yield return HAGIS.DialogShow(dialog_windowAgain);
				switch (dialog_windowAgain.currentResponseLine)
				{
				case 1u:
					yield return UnitPlayAnimation(willa, "CsDefaultClimbOutWindow");
					yield return UnitTeleportToMapViaEntranceTile(willa, outsideToMaintenance);
					willa.LookInDirection(OctDir.Right);
					yield return MapGoto(outsideTheCity.Map);
					break;
				case 2u:
					yield return UnitMoveToTarget(willa, T_Willa_RM);
					continue;
				}
				break;
			}
			break;
		}
		SKIP_POINT("skipped climb out window");
		yield return null;
		willa.gameObject.SetActive(value: true);
		outsideToMaintenance.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(TT_Chute1._OnTriggered);
		yield return HAGIS.DialogShow(dialog_getToTheChute);
		SKIP_POINT("skipped moving towards chute");
		yield return CreateTriggerCondition(TT_Chute2.OnTriggered);
		yield return null;
		willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk");
		yield return CutscenePlay("A1S1_Cutscene10");
		UIObjectives.Inst.CompleteObjective(objChuteString);
		ConstArray<PartyMember> members = Party.Inst.GetContributedPartyMembers();
		for (int i = 0; i < members.Length; i++)
		{
			if (members[i] != null && members[i].characterData.partyMemberID == PartyMemberID.Ashley)
			{
				Party.Inst.TryRemoveContributedPartyMember(members[i].characterData);
			}
		}
		PartyMember unlockedAsh = null;
		if (Party.Inst.TryGetUnlockedPartyMember(Ashley.charData, out unlockedAsh))
		{
			Party.Inst.LockPartyMember(Ashley.charData);
		}
	}

	private void AshleySafelyRemoveAbility<T>()
	{
		if (Ashley.abilities.Exists<T>())
		{
			Ashley.abilities.Remove(Ashley.abilities.AbilityGetByType(typeof(T)), isProxy: false);
		}
	}
}
public class HAGIS_A1S1_BrokenRobot : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		KubrickAnimator BrokenRobot = GetComponentInChildren<KubrickAnimator>();
		TileActionInteraction RobotInteraction = MR.Inst.GetTileActionInteraction("D00_T2RobotMaintenanceBay_TileActionInteraction");
		yield return null;
		yield return CreateTriggerCondition(RobotInteraction.OnTriggered);
		yield return BrokenRobot.Play("CsDefaultBroken");
	}
}
public class HAGIS_A1S2 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Ambrosia;

	private Unit Chris;

	private Unit Margot;

	private Unit Noot;

	private Unit Droid1;

	private Unit Droid2;

	private Unit Droid3;

	private Unit Droid4;

	private Unit Droid5;

	private Unit Droid6;

	private Unit Droid7;

	private Unit Droid8;

	private Unit Turret1;

	private Unit Turret2;

	private Unit WellnessOfficer;

	private Unit WellnessMinion1;

	private Unit WellnessMinion2;

	private UnitTarget TargetWillaAV;

	private UnitTarget TargetWillaAV1;

	private UnitTarget TargetWillaS1;

	private UnitTarget TargetWillaS2;

	private UnitTarget TargetArchiS1;

	private UnitTarget TargetArchiS2;

	private UnitTarget TargetTrainExit;

	private UnitTarget TargetChrisS1;

	private UnitTarget TargetNootS1;

	private UnitTarget TargetMargotS1;

	private UnitTarget TargetAmbrosiaS1;

	private UnitTarget TargetRobot1;

	private UnitTarget TargetRobot2;

	private UnitTarget TargetRobot3;

	private UnitTarget CoverWilla;

	private UnitTarget TargetChrisKI;

	private UnitTarget TargetAmbrosiaKI;

	private UnitTarget TargetMargotKI;

	private UnitTarget TargetArchiKI;

	private UnitTarget TargetWillaMT1;

	private UnitTarget TargetArchiMT;

	private UnitTarget TargetArchiMTCover;

	private UnitTarget TargetAmbrosiaMT;

	private UnitTarget TargetWillaMT;

	private UnitTarget TargetArchiMT1;

	private UnitTarget TargetArchiMT2;

	private UnitTarget TargetAmbrosiaMT1;

	private UnitTarget TargetArchiAV1;

	private UnitTarget TargetArchiAV2;

	private UnitTarget ViolinCase;

	private UnitTarget ViolinCase1;

	private UnitTarget TargetChrisKE;

	private UnitTarget UnitPos17;

	private UnitTarget UnitPos18;

	private UnitTarget UnitPos19;

	private UnitTarget UnitPos21;

	private UnitTarget UnitPos22;

	private UnitTarget CoverPoint_1;

	private UnitTarget CoverPoint_2;

	private UnitTarget CoverPoint_3;

	private UnitTarget UnitPos24;

	private UnitTarget TargetDroid1;

	private UnitTarget TargetDroid2;

	private UnitTarget TargetDroid3;

	private UnitTarget TargetOfficer;

	private UnitTarget TargetMinion1;

	private UnitTarget TargetMinion2;

	private UnitTarget TargetCore;

	private UnitTarget TargetDynamicBlock;

	private UnitTarget WillaVentTarget;

	private UnitTarget TargetConsole;

	private UnitTarget Target_Willa_KDoor;

	private TileTrigger VentTrigger;

	private TileTrigger TurretTrigger;

	private TileTrigger KeypadTrigger;

	private TileActionSwapMap ToKeydockExterior;

	private TileActionSwapMap ToKeydockInterior;

	private TileActionSwapMap ToSubway;

	private TileActionSwapMap TrainToStation;

	private TileActionSwapMap FromCarriage;

	private TileActionSwapMap ToVault;

	private TileActionSwapMap FromKaydockInteriorToExtirior;

	private TileActionSwapMap FromKeydockInteriorToTunnel;

	private TileActionSwapMap FromMineTunnel;

	private TileActionSwapMap ToMineTunnel;

	private TileActionSwapMap ToVent;

	private TileActionSwapMap FromVent;

	private TileActionDialog ControlePannel;

	private TileActionDialog DoorWithOutKey;

	private TileActionDialog DoorInteraction;

	private TileActionDialog TurbinesINT;

	private TileActionDialog AccumilatorINT;

	private TileActionDialog Keypad;

	private TileActionDialog Lift;

	private TileActionDialog Poster;

	private TileActionDialog Window;

	private TileActionInteraction I_ToOpenDoor;

	private TileActionInteraction VentInteraction;

	private TileActionInteraction I_SmartCard;

	private TileActionInteraction I_Atlantium;

	private TileBlockDynamic VentBlock;

	private DialogData ambient_AnnouncerCrime;

	private DialogData ambient_AnnouncerDeface;

	private DialogData ambient_AnnouncerDetected;

	private DialogData ambient_AnnouncerDefeated;

	private DialogData ambient_AnnouncerMainBay;

	private DialogData ambient_ChrisMillionYears;

	private DialogData ambient_HartmanClearEntrance;

	private DialogData ambient_HartmanConsole;

	private DialogData ambient_HartmanGetTheDoor;

	private DialogData ambient_HartmanHeadThrough;

	private DialogData ambient_HartmanTeams;

	private DialogData ambient_HartmanTides;

	private DialogData ambient_HartmanWilla;

	private DialogData ambient_WillaAh;

	private DialogData ambient_WillaArms;

	private DialogData ambient_WillaLocked;

	private DialogData ambient_ArchiHydroPlant;

	private DialogData dialog_ArchiAwed;

	private DialogData dialog_ArchiWhatTheHell;

	private DialogData dialog_ArchiYouBuyThis;

	private DialogData ambient_ChrisWoah;

	private DialogData dialog_HartmanGetToVault;

	private DialogData dialog_HartmanHoldOn;

	private DialogData Dialog_HartmanAhsylyPhoto;

	private DialogData dialog_HartmanKeypad;

	private DialogData dialog_NootWhatWeGot;

	private DialogData dialog_WillaINeedChris;

	private DialogData dialog_WillaKeypad;

	private DialogData dialog_WillaIsItSafe;

	private DialogData dialog_WillaNervous;

	private DialogData dialog_WillaNotMyFight;

	private DialogData dialog_WillaSmartCard;

	private DialogData dialog_WillaSorryCarlos;

	private DialogData dialog_WillaWhatAreWeStealing;

	private DialogData dialog_WillaWontChange;

	private DialogData dialog_WillaTrust;

	private DialogData dialog_WillaTrain;

	private string objPhase1 = "OBJECTIVES_A1S2_01";

	private string objPhase2 = "OBJECTIVES_A1S2_02";

	private string objPhase3 = "OBJECTIVES_A1S2_03";

	private string objPhase4 = "OBJECTIVES_A1S2_04";

	private string objPhase3b = "OBJECTIVES_A1S2_05";

	private string objPhase5 = "OBJECTIVES_A1S2_06";

	private string objPhase3c = "OBJECTIVES_A1S2_07";

	private string objPhase6 = "OBJECTIVES_A1S2_08";

	private string objPhase7 = "OBJECTIVES_A1S2_09";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_PhotoClose = GetHartmanMovementPoint("M_PhotoClose");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint L_AshelyPhoto = GetHartmanLookAtPoint("L_AshelyPhoto");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		UIButtonHaglet button_AshelyPhotoCode = GetUIButtonHaglet("P_AshelyPhotoCode");
		LogicRoot TrainInterior = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot SubwayStationLogic = GetLogicUsingArtName("T1Subway_Station_Kaydock");
		LogicRoot KaydockExtiriorLogic = GetLogicUsingArtName("T1Kaydock_PlantExterior");
		LogicRoot KaydockInteriorLogic = GetLogicUsingArtName("T1Kaydock_ControlRoom");
		LogicRoot MineTunnelLogic = GetLogicUsingArtName("T1VaultEntrance");
		LogicRoot AtlantiumVaultLogic = GetLogicUsingArtName("T1AtlantiumVault");
		Willa = GC.Inst.GetUnitWithId("20C_T1Subway_TrainInterior_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("B10_T1Subway_TrainInterior_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("932_T1Subway_TrainInterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("DF3_T1Subway_TrainInterior_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("638_T1Subway_TrainInterior_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("D26_T1Subway_TrainInterior_UnitSpawn");
		Droid1 = GC.Inst.GetUnitWithId("83A_T1MineTunnel_UnitSpawn");
		Droid2 = GC.Inst.GetUnitWithId("4E8_T1MineTunnel_UnitSpawn");
		Droid3 = GC.Inst.GetUnitWithId("683_T1MineTunnel_UnitSpawn");
		Droid7 = GC.Inst.GetUnitWithId("DDF_T1Kaydock_ControlRoom_UnitSpawn");
		Droid8 = GC.Inst.GetUnitWithId("D18_T1Kaydock_ControlRoom_UnitSpawn");
		Turret1 = GC.Inst.GetUnitWithId("A96_T1Kaydock_PlantExterior_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("847_T1Kaydock_PlantExterior_UnitSpawn");
		WellnessOfficer = GC.Inst.GetUnitWithId("0DF_T1Kaydock_ControlRoom_UnitSpawn");
		WellnessMinion1 = GC.Inst.GetUnitWithId("823_T1Kaydock_ControlRoom_UnitSpawn");
		WellnessMinion2 = GC.Inst.GetUnitWithId("961_T1Kaydock_ControlRoom_UnitSpawn");
		ToKeydockExterior = MR.Inst.GetTileActionSwapMap("AB1_T2AscensionExhibit_TileActionSwapMap");
		ToSubway = MR.Inst.GetTileActionSwapMap("AF6_T2TenorCityCentre_TileActionSwapMap");
		TrainToStation = MR.Inst.GetTileActionSwapMap("E25_T1Subway_TrainInterior_TileActionSwapMap");
		FromCarriage = MR.Inst.GetTileActionSwapMap("322_T1Subway_Station_TileActionSwapMap");
		ToKeydockInterior = MR.Inst.GetTileActionSwapMap("042_T1Kaydock_PlantExterior_TileActionSwapMap");
		ToMineTunnel = MR.Inst.GetTileActionSwapMap("8DD_T1Kaydock_ControlRoom_TileActionSwapMap");
		ToVault = MR.Inst.GetTileActionSwapMap("68F_T2AscensionPlatform_TileActionSwapMap");
		FromKaydockInteriorToExtirior = MR.Inst.GetTileActionSwapMap("89E_T2Skyway_TileActionSwapMap");
		FromKeydockInteriorToTunnel = MR.Inst.GetTileActionSwapMap("910_T1MineTunnel_TileActionSwapMap");
		FromMineTunnel = MR.Inst.GetTileActionSwapMap("FED_T1AtlantiumVault_TileActionSwapMap");
		ToVent = MR.Inst.GetTileActionSwapMap("871_T1Kaydock_PlantExterior_TileActionSwapMap");
		FromVent = MR.Inst.GetTileActionSwapMap("CF4_T1Kaydock_ControlRoom_TileActionSwapMap");
		KeypadTrigger = MR.Inst.GetTileTrigger("022_T1MineTunnel_TileTrigger");
		VentTrigger = MR.Inst.GetTileTrigger("1F3_T1Kaydock_PlantExterior_TileTrigger");
		TurretTrigger = MR.Inst.GetTileTrigger("BB7_T1Kaydock_PlantExterior_TileTrigger");
		Keypad = MR.Inst.GetTileActionDialog("103_T1MineTunnel_TileActionDialog");
		ControlePannel = MR.Inst.GetTileActionDialog("478_T1Kaydock_ControlRoom_TileActionDialog");
		DoorWithOutKey = MR.Inst.GetTileActionDialog("111_T1Kaydock_ControlRoom_TileActionDialog");
		DoorInteraction = MR.Inst.GetTileActionDialog("099_T1Kaydock_PlantExterior_TileActionDialog");
		Lift = MR.Inst.GetTileActionDialog("204_T1MineTunnel_TileActionDialog");
		Window = MR.Inst.GetTileActionDialog("71D_T1MineTunnel_TileActionDialog");
		TurbinesINT = MR.Inst.GetTileActionDialog("23D_T1Kaydock_ControlRoom_TileActionDialog");
		AccumilatorINT = MR.Inst.GetTileActionDialog("54E_T1Kaydock_ControlRoom_TileActionDialog");
		I_ToOpenDoor = MR.Inst.GetTileActionInteraction("A01_T1Kaydock_ControlRoom_TileActionInteraction");
		VentInteraction = MR.Inst.GetTileActionInteraction("292_T1Kaydock_PlantExterior_TileActionInteraction");
		I_Atlantium = MR.Inst.GetTileActionInteraction("A93_T1AtlantiumVault_TileActionInteraction");
		I_SmartCard = MR.Inst.GetTileActionInteraction("2AA_T1Kaydock_ControlRoom_TileActionInteraction");
		VentBlock = MR.Inst.GetTileBlockDynamic("54A_T1Kaydock_PlantExterior_TileBlockDynamic");
		TargetWillaS1 = MR.Inst.GetUnitTarget("7DB_T1Subway_Station_UnitTarget");
		TargetWillaS2 = MR.Inst.GetUnitTarget("424_T1Subway_Station_UnitTarget");
		TargetArchiS1 = MR.Inst.GetUnitTarget("01D_T1Subway_Station_UnitTarget");
		TargetArchiS2 = MR.Inst.GetUnitTarget("C53_T1Subway_Station_UnitTarget");
		TargetTrainExit = MR.Inst.GetUnitTarget("58A_T1Subway_TrainInterior_UnitTarget");
		TargetAmbrosiaS1 = MR.Inst.GetUnitTarget("13D_T1Subway_Station_UnitTarget");
		TargetChrisS1 = MR.Inst.GetUnitTarget("87E_T1Subway_Station_UnitTarget");
		TargetMargotS1 = MR.Inst.GetUnitTarget("98E_T1Subway_Station_UnitTarget");
		TargetNootS1 = MR.Inst.GetUnitTarget("1F3_T1Subway_Station_UnitTarget");
		CoverWilla = MR.Inst.GetUnitTarget("543_T1Kaydock_ControlRoom_UnitTarget");
		TargetChrisKI = MR.Inst.GetUnitTarget("E24_T1Kaydock_ControlRoom_UnitTarget");
		TargetArchiKI = MR.Inst.GetUnitTarget("469_T1Kaydock_ControlRoom_UnitTarget");
		TargetMargotKI = MR.Inst.GetUnitTarget("F40_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget tutMovePoint = MR.Inst.GetUnitTarget("670_T1Kaydock_ControlRoom_UnitTarget");
		TargetAmbrosiaKI = MR.Inst.GetUnitTarget("57B_T1Kaydock_ControlRoom_UnitTarget");
		TargetArchiMT = MR.Inst.GetUnitTarget("7A2_T1MineTunnel_UnitTarget");
		TargetWillaMT1 = MR.Inst.GetUnitTarget("E7A_T1VaultEntrance_UnitTarget");
		TargetArchiMTCover = MR.Inst.GetUnitTarget("A5A_T1VaultEntrance_UnitTarget");
		TargetAmbrosiaMT = MR.Inst.GetUnitTarget("805_T1MineTunnel_UnitTarget");
		TargetWillaMT = MR.Inst.GetUnitTarget("458_T1MineTunnel_UnitTarget");
		TargetArchiMT1 = MR.Inst.GetUnitTarget("71B_T1MineTunnel_UnitTarget");
		TargetArchiMT2 = MR.Inst.GetUnitTarget("B9F_T1VaultEntrance_UnitTarget");
		TargetAmbrosiaMT1 = MR.Inst.GetUnitTarget("2E1_T1MineTunnel_UnitTarget");
		TargetArchiAV1 = MR.Inst.GetUnitTarget("F11_T1AtlantiumVault_UnitTarget");
		TargetArchiAV2 = MR.Inst.GetUnitTarget("D12_T1AtlantiumVault_UnitTarget");
		TargetWillaAV = MR.Inst.GetUnitTarget("EB1_T1AtlantiumVault_UnitTarget");
		TargetWillaAV1 = MR.Inst.GetUnitTarget("C88_T1AtlantiumVault_UnitTarget");
		ViolinCase = MR.Inst.GetUnitTarget("BE8_T1MineTunnel_UnitTarget");
		ViolinCase1 = MR.Inst.GetUnitTarget("9F2_T1AtlantiumVault_UnitTarget");
		TargetChrisKE = MR.Inst.GetUnitTarget("720_T1Kaydock_PlantExterior_UnitTarget");
		UnitPos17 = MR.Inst.GetUnitTarget("D3E_T1Kaydock_ControlRoom_UnitTarget");
		UnitPos18 = MR.Inst.GetUnitTarget("671_T1Kaydock_PlantExterior_UnitTarget");
		UnitPos19 = MR.Inst.GetUnitTarget("782_T1Kaydock_ControlRoom_UnitTarget");
		UnitPos21 = MR.Inst.GetUnitTarget("06E_T1Kaydock_PlantExterior_UnitTarget");
		UnitPos22 = MR.Inst.GetUnitTarget("C1E_T1Kaydock_ControlRoom_UnitTarget");
		CoverPoint_1 = MR.Inst.GetUnitTarget("354_T1Kaydock_PlantExterior_UnitTarget");
		CoverPoint_2 = MR.Inst.GetUnitTarget("5D8_T1Kaydock_PlantExterior_UnitTarget");
		CoverPoint_3 = MR.Inst.GetUnitTarget("265_T1Kaydock_PlantExterior_UnitTarget");
		UnitPos24 = MR.Inst.GetUnitTarget("57F_T1Kaydock_ControlRoom_UnitTarget");
		TargetDroid1 = MR.Inst.GetUnitTarget("141_T1MineTunnel_UnitTarget");
		TargetDroid2 = MR.Inst.GetUnitTarget("B4E_T1MineTunnel_UnitTarget");
		TargetDroid3 = MR.Inst.GetUnitTarget("5AC_T1MineTunnel_UnitTarget");
		TargetOfficer = MR.Inst.GetUnitTarget("7DF_T1Kaydock_ControlRoom_UnitTarget");
		TargetMinion1 = MR.Inst.GetUnitTarget("B42_T1Kaydock_ControlRoom_UnitTarget");
		TargetMinion2 = MR.Inst.GetUnitTarget("674_T1Kaydock_ControlRoom_UnitTarget");
		TargetCore = MR.Inst.GetUnitTarget("AD4_T1AtlantiumVault_UnitTarget");
		TargetDynamicBlock = MR.Inst.GetUnitTarget("684_T1Kaydock_PlantExterior_UnitTarget");
		WillaVentTarget = MR.Inst.GetUnitTarget("26E_T1Kaydock_PlantExterior_UnitTarget");
		Target_Willa_KDoor = MR.Inst.GetUnitTarget("67A_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget static_skin_near_vent = MR.Inst.GetUnitTarget("720_T1Kaydock_PlantExterior_UnitTarget");
		UnitTarget PassTarget = MR.Inst.GetUnitTarget("C58_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget willa_opens_shutter = MR.Inst.GetUnitTarget("D3E_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget static_skin_near_vault = MR.Inst.GetUnitTarget("B9F_T1VaultEntrance_UnitTarget");
		UnitTarget willa_entering_vault_code = MR.Inst.GetUnitTarget("B9F_T1VaultEntrance_UnitTarget");
		UnitTarget vault_door_opens = MR.Inst.GetUnitTarget("B9F_T1VaultEntrance_UnitTarget");
		ambient_AnnouncerCrime = HAGIS.DialogLoad("Dialogs/A1S2/AmbientAnnouncerCrime");
		ambient_AnnouncerDeface = HAGIS.DialogLoad("Dialogs/A1S2/AmbientAnnouncerDeface");
		ambient_AnnouncerDetected = HAGIS.DialogLoad("Dialogs/A1S2/AmbientAnnouncerDetected");
		ambient_AnnouncerDefeated = HAGIS.DialogLoad("Dialogs/A1S2/AmbientAnnouncerDefeated");
		ambient_AnnouncerMainBay = HAGIS.DialogLoad("Dialogs/A1S2/AmbientAnnouncerMainBay");
		ambient_ChrisMillionYears = HAGIS.DialogLoad("Dialogs/A1S2/AmbientChrisMillionYears");
		ambient_HartmanClearEntrance = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanClearEntrance");
		ambient_HartmanConsole = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanConsole");
		ambient_HartmanGetTheDoor = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanGetTheDoor");
		ambient_HartmanHeadThrough = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanHeadThrough");
		ambient_HartmanTeams = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanTeams");
		ambient_HartmanTides = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanTides");
		ambient_HartmanWilla = HAGIS.DialogLoad("Dialogs/A1S2/AmbientHartmanWilla");
		ambient_WillaAh = HAGIS.DialogLoad("Dialogs/A1S2/AmbientWillaAh");
		ambient_WillaArms = HAGIS.DialogLoad("Dialogs/A1S2/AmbientWillaArms");
		ambient_WillaLocked = HAGIS.DialogLoad("Dialogs/A1S2/AmbientWillaLocked");
		ambient_ArchiHydroPlant = HAGIS.DialogLoad("Dialogs/A1S2/AmbientArchiHydroPlant");
		dialog_ArchiAwed = HAGIS.DialogLoad("Dialogs/A1S2/DialogArchiAwed");
		dialog_ArchiWhatTheHell = HAGIS.DialogLoad("Dialogs/A1S2/DialogArchiWhatTheHell");
		dialog_ArchiYouBuyThis = HAGIS.DialogLoad("Dialogs/A1S2/DialogArchiYouBuyThis");
		ambient_ChrisWoah = HAGIS.DialogLoad("Dialogs/A1S2/AmbientChrisWoah");
		dialog_HartmanGetToVault = HAGIS.DialogLoad("Dialogs/A1S2/DialogHartmanGetToVault");
		dialog_HartmanHoldOn = HAGIS.DialogLoad("Dialogs/A1S2/DialogHartmanHoldOn");
		Dialog_HartmanAhsylyPhoto = HAGIS.DialogLoad("Dialogs/A1S2/DialogHartmanAhsylyPhoto");
		dialog_HartmanKeypad = HAGIS.DialogLoad("Dialogs/A1S2/DialogHartmanKeypad");
		dialog_NootWhatWeGot = HAGIS.DialogLoad("Dialogs/A1S2/DialogNootWhatWeGot");
		dialog_WillaINeedChris = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaINeedChris");
		dialog_WillaIsItSafe = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaIsItSafe");
		dialog_WillaNervous = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaNervous");
		dialog_WillaNotMyFight = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaNotMyFight");
		dialog_WillaKeypad = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaKeypad");
		dialog_WillaSmartCard = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaSmartCard");
		dialog_WillaSorryCarlos = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaSorryCarlos");
		dialog_WillaWhatAreWeStealing = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaWhatAreWeStealing");
		dialog_WillaWontChange = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaWontChange");
		dialog_WillaTrust = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaTrust");
		dialog_WillaTrain = HAGIS.DialogLoad("Dialogs/A1S2/DialogWillaTrain");
		HagletTrigger myAI = new HagletTrigger();
		Ability_Taunt droid8Taunt = Droid8.abilities.AbilityGetByType<Ability_Taunt>(Droid8);
		if (droid8Taunt != null)
		{
			droid8Taunt.Enabled = false;
		}
		Ability_MaxHP WellnessOfficerHP = WellnessOfficer.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		WellnessOfficerHP.SetHPMod(5);
		string VaultDoor = "MA_VaultDoor";
		WellnessOfficer.gameObject.SetActive(value: false);
		WellnessMinion1.gameObject.SetActive(value: false);
		WellnessMinion2.gameObject.SetActive(value: false);
		ViolinCase.gameObject.SetActive(value: false);
		ViolinCase1.gameObject.SetActive(value: false);
		ToKeydockExterior.gameObject.SetActive(value: false);
		VentTrigger.gameObject.SetActive(value: false);
		VentInteraction.gameObject.SetActive(value: false);
		DoorInteraction.gameObject.SetActive(value: false);
		ToVent.gameObject.SetActive(value: false);
		DoorWithOutKey.gameObject.SetActive(value: false);
		I_ToOpenDoor.gameObject.SetActive(value: false);
		ControlePannel.gameObject.SetActive(value: false);
		I_SmartCard.gameObject.SetActive(value: false);
		Window.gameObject.SetActive(value: false);
		Lift.gameObject.SetActive(value: false);
		KeypadTrigger.gameObject.SetActive(value: false);
		Keypad.gameObject.SetActive(value: false);
		ToVault.gameObject.SetActive(value: false);
		TurbinesINT.gameObject.SetActive(value: false);
		AccumilatorINT.gameObject.SetActive(value: false);
		ToMineTunnel.gameObject.SetActive(value: false);
		Turret1.IsMovementDisabled = true;
		Turret2.IsMovementDisabled = true;
		FromCarriage.gameObject.SetActive(value: false);
		FromKeydockInteriorToTunnel.gameObject.SetActive(value: false);
		TrainToStation.gameObject.SetActive(value: false);
		yield return null;
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultRunViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CsDefaultWalkViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultInteractViolin");
		Archi.UpdateIdleAnim();
		yield return null;
		MusicPlay("event:/music/tracks/basic/thoughtful music");
		if (!Willa.abilities.Exists<Ability_Static_Skin>())
		{
			Willa.abilities.Add<Ability_Static_Skin>(null, isUpgraded: false);
		}
		HAGIS.ToggleShakeEnvironment(on: true);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_WillaTrain);
		yield return PlayInterplay();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return Willa.unitModel.Play("CsTransDefeatedToDIdle", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		MusicStop();
		PlayMapAnimation(SubwayStationLogic.Map, "MA_SubwayTrain", "Arriving");
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_KayDock_L0");
		yield return PlayMapAnimation(TrainInterior.Map, "MA_SubwayDoors", "Open");
		TrainToStation.gameObject.SetActive(value: true);
		HAGIS.ToggleShakeEnvironment(on: false);
		Archi.LookInDirection(OctDir.UpLeft);
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.unitModel.Play("CsDefaultSitToDIdle", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		Archi.LookInDirection(OctDir.Up);
		Willa.LookInDirection(OctDir.Up);
		CutsceneEnd();
		GC.Inst.SetRPGLeader(Willa);
		yield return null;
		yield return MapWaitUntilVisible(SubwayStationLogic.Map);
		CutsceneBegin();
		PlayMapAnimation(SubwayStationLogic.Map, "MA_SubwayTrain", "Leaving");
		yield return UnitMoveToTarget(Willa, TargetWillaS1);
		Willa.LookAt(Archi);
		Archi.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		Noot.LookAt(Willa);
		Margot.LookAt(Willa);
		Chris.LookAt(Willa);
		yield return HAGIS.DialogShow(ambient_HartmanClearEntrance);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase1);
		CutsceneEnd();
		Chris.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Margot);
		yield return null;
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		yield return null;
		SKIP_POINT("Dialog happened here");
		ToKeydockExterior.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(KaydockExtiriorLogic.Map);
		ToSubway.gameObject.SetActive(value: false);
		ToKeydockInterior.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(Margot, UnitPos21);
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		CombatBegin(UnitTeam.Type.Player);
		HagletYieldTerm turretTerminalReached = CreateTriggerCondition(TurretTrigger._OnTriggered);
		yield return CreateOrCondition(CombatWaitUntilComplete(), turretTerminalReached);
		if (turretTerminalReached.met)
		{
			Turret1.SetTeamType(UnitTeam.Type.Player);
			Turret2.SetTeamType(UnitTeam.Type.Player);
			yield return CombatWaitUntilComplete();
		}
		else
		{
			CutsceneBegin();
			yield return UnitMoveToTarget(Chris, TargetChrisKE);
			Chris.LookInDirection(OctDir.Left);
			yield return Chris.unitModel.Play("CsTransDIdleToKneelHack");
			Chris.unitModel.Play("CsDefaultKneelHack", looping: true);
			TurretTrigger.gameObject.SetActive(value: false);
			Turret1.SetTeamType(UnitTeam.Type.Player);
			Turret2.SetTeamType(UnitTeam.Type.Player);
			CutsceneEnd();
		}
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		CutsceneBegin();
		UnitTeleportToMapViaEntranceTile(Willa, ToSubway, CoverPoint_3);
		yield return CreateTimeCondition(1f);
		UnitTeleportToMapViaEntranceTile(Noot, ToSubway, CoverPoint_1);
		yield return CreateTimeCondition(1f);
		yield return UnitTeleportToMapViaEntranceTile(Archi, ToSubway, CoverPoint_2);
		Archi.LookInDirection(OctDir.Up);
		Noot.LookInDirection(OctDir.Up);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		CutsceneEnd();
		SKIP_POINT("Skipped normal combat in this area");
		DoorInteraction.gameObject.SetActive(value: true);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Turret1.SetTeamType(UnitTeam.Type.NPC);
		Turret2.SetTeamType(UnitTeam.Type.NPC);
		yield return null;
		SKIP_POINT("Skipped other charcters entering");
		yield return HAGIS.DialogShow(ambient_ChrisWoah);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase2);
		VentTrigger.gameObject.SetActive(value: true);
		VentInteraction.gameObject.SetActive(value: true);
		SKIP_POINT("Looking for vent");
		yield return CreateTriggerCondition(VentTrigger._OnTriggered);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1s2/static skin", static_skin_near_vent);
		yield return CreateTimeCondition(0.3f);
		HAGIS.DialogShow(ambient_WillaArms);
		Willa.unitModel.Play("CsDefaultCheckAug");
		yield return CreateTimeCondition(0.6f);
		PlayMapAnimation(KaydockExtiriorLogic.Map, "MA_StaticField_01", "Disable");
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(ambient_HartmanHeadThrough);
		yield return null;
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, WillaVentTarget);
		Willa.LookInDirection(OctDir.Left);
		VentBlock.gameObject.SetActive(value: false);
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToCrawl");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultCrawlIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultCrawl");
		Willa.UpdateIdleAnim();
		yield return UnitMoveToTarget(Willa, TargetDynamicBlock, null, 1f);
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromVent);
		Willa.gameObject.SetActive(value: false);
		PlayMapAnimation(KaydockExtiriorLogic.Map, "MA_StaticField_01", "Enable");
		yield return HAGIS.DialogShow(dialog_WillaNervous);
		CutsceneEnd();
		SKIP_POINT("Skipped finding vent");
		yield return MapGoto(KaydockInteriorLogic);
		MusicStop();
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase3);
		Willa.LookInDirection(OctDir.Right);
		yield return CutscenePlay("A1S2_Cutscene_WillaCrawls");
		FromVent.gameObject.SetActive(value: false);
		FromKaydockInteriorToExtirior.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/combat/jank");
		Singleton<AIC>.Inst.OnExternalAIBegan = myAI;
		CombatBegin(UnitTeam.Type.Enemy);
		Ability_Reflex reflex = null;
		if (Willa.abilities.Exists<Ability_Reflex>())
		{
			reflex = Willa.abilities.AbilityGetByType<Ability_Reflex>();
			reflex.Enabled = false;
		}
		yield return CreateTimeCondition(1f);
		yield return ShowTutorialScreen(TutorialScreen.EffectSpinner);
		if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
		{
			yield return Singleton<AIC>.Inst.OnExternalAIBegan;
		}
		Droid7.APDecrement(2);
		yield return UnitMoveToTarget(Droid7, tutMovePoint);
		yield return UnitMoveToTarget(Droid7, TargetMargotKI, OctDir.DownLeft);
		Singleton<AIC>.Inst.OnExternalAIBegan = null;
		Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
		yield return TurnModeWaitForPlayerTurnStart();
		if (reflex != null)
		{
			reflex.Enabled = true;
		}
		yield return CombatWaitUntilComplete();
		SKIP_POINT("Skipped stealth");
		v2i smartcardCoord = Droid7.coord;
		HagisLog("smartcard was at: " + smartcardCoord);
		if (smartcardCoord.x <= 2 && smartcardCoord.y >= 8 && smartcardCoord.y <= 10)
		{
			smartcardCoord = new v2i(3, 9);
		}
		else if (smartcardCoord.x >= 13 && smartcardCoord.y == 8)
		{
			smartcardCoord = new v2i(smartcardCoord.x, 9);
		}
		else if (smartcardCoord.y == 11 && smartcardCoord.x >= 4 && smartcardCoord.x <= 5)
		{
			smartcardCoord = new v2i(smartcardCoord.x, 12);
		}
		HagisLog("smartcard now at: " + smartcardCoord);
		I_SmartCard.transform.position = KaydockInteriorLogic.Map.CoordToWorldPos(smartcardCoord);
		I_SmartCard.gameObject.SetActive(value: true);
		ParticlePrefab PassHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, PassTarget.transform);
		DoorWithOutKey.gameObject.SetActive(value: true);
		ControlePannel.gameObject.SetActive(value: true);
		yield return null;
		HAGIS.DialogShow(ambient_HartmanGetTheDoor);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase4);
		TurbinesINT.gameObject.SetActive(value: true);
		AccumilatorINT.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(I_SmartCard.OnTriggered);
		CutsceneBegin();
		PassHightlight.StopParticles();
		yield return UnitPlayAnimation(Willa, "DefaultPickup");
		I_SmartCard.gameObject.SetActive(value: false);
		HAGIS.DialogShow(dialog_WillaSorryCarlos);
		CutsceneEnd();
		yield return null;
		DoorWithOutKey.gameObject.SetActive(value: false);
		I_ToOpenDoor.gameObject.SetActive(value: true);
		ParticlePrefab ConsoleHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, I_ToOpenDoor.transform);
		yield return CreateTriggerCondition(I_ToOpenDoor.OnTriggered);
		CutsceneBegin();
		UIObjectives.Inst.CompleteObjective(objPhase4);
		ConsoleHightlight.StopParticles();
		I_ToOpenDoor.gameObject.SetActive(value: false);
		ControlePannel.gameObject.SetActive(value: false);
		yield return Willa.unitModel.Play(UnitModel.AnimID.DefaultInteract);
		yield return CreateTimeCondition(0.9f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1s2/shutter rolls open", willa_opens_shutter);
		Willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(2f);
		yield return UnitMoveToTarget(Willa, Target_Willa_KDoor);
		yield return HAGIS.DialogShow(dialog_WillaWhatAreWeStealing);
		CutsceneEnd();
		SKIP_POINT("Skipped finding smart card");
		yield return HAGIS.DialogShow(ambient_AnnouncerMainBay);
		CutsceneBegin();
		MusicPlay("event:/music/tracks/combat/team wellness");
		WellnessOfficer.gameObject.SetActive(value: true);
		WellnessMinion1.gameObject.SetActive(value: true);
		WellnessMinion2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(2f);
		Willa.LookAt(WellnessOfficer);
		yield return HAGIS.DialogShow(ambient_WillaAh);
		Chris.unitModel.PlayAndReturnToIdle("CsTransKneelHackToDIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "CombatIdle");
		yield return UnitTeleportToMapViaEntranceTile(Noot, FromKaydockInteriorToExtirior, UnitPos19);
		Noot.LookInDirection(OctDir.Up);
		yield return UnitTeleportToMapViaEntranceTile(Chris, FromKaydockInteriorToExtirior, UnitPos17);
		Chris.LookInDirection(OctDir.Up);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Noot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		yield return HAGIS.DialogShow(ambient_AnnouncerDetected);
		UnitMoveToTarget(WellnessOfficer, TargetOfficer);
		UnitMoveToTarget(WellnessMinion1, TargetMinion1);
		yield return UnitMoveToTarget(WellnessMinion2, TargetMinion2);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase3b);
		TurbinesINT.gameObject.SetActive(value: false);
		AccumilatorINT.gameObject.SetActive(value: false);
		CutsceneEnd();
		SKIP_POINT("Skipped droid apearing and team running in");
		CombatBegin(UnitTeam.Type.Player);
		Noot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Noot.unitModel.ClearAnimOverride(UnitModel.AnimID.TransDIdleToCIdle);
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.TransDIdleToCIdle);
		HagletYieldTerm combatComplete = CreateTriggerCondition(CombatWaitUntilComplete());
		UIObjectives.Inst.CompleteObjective(objPhase3b);
		yield return CreateOrCondition(CreateTriggerCondition(WellnessOfficer.OnUnitSustainedDamage), combatComplete);
		HAGIS.DialogShow(ambient_AnnouncerCrime);
		if (!combatComplete.met)
		{
			combatComplete = CombatWaitUntilComplete();
			yield return CreateOrCondition(CreateTriggerCondition(WellnessOfficer.OnUnitSustainedDamage), combatComplete);
		}
		if (!combatComplete.met)
		{
			combatComplete = CombatWaitUntilComplete();
			yield return CreateOrCondition(CreateTriggerCondition(WellnessOfficer.OnUnitSustainedDamage), combatComplete);
			HAGIS.DialogShow(ambient_AnnouncerDeface);
		}
		if (!combatComplete.met)
		{
			yield return CombatWaitUntilComplete();
			HAGIS.DialogShow(ambient_AnnouncerDefeated);
		}
		MusicStop();
		TurbinesINT.gameObject.SetActive(value: true);
		AccumilatorINT.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped combat");
		GC.Inst.CutsceneBegin();
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		Chris.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		yield return null;
		yield return UnitTeleportToMapViaEntranceTile(Archi, FromKaydockInteriorToExtirior, UnitPos19);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, FromKaydockInteriorToExtirior, UnitPos17);
		yield return UnitTeleportToMapViaEntranceTile(Margot, FromKaydockInteriorToExtirior);
		Archi.LookInDirection(OctDir.Up);
		Ambrosia.LookInDirection(OctDir.Up);
		Margot.LookInDirection(OctDir.Up);
		yield return HAGIS.DialogShow(ambient_HartmanConsole);
		UnitMoveToTarget(Chris, TargetChrisKI);
		UnitMoveToTarget(Willa, UnitPos22);
		UnitMoveToTarget(Noot, UnitPos24);
		UnitMoveToTarget(Archi, TargetArchiKI);
		UnitMoveToTarget(Margot, TargetMargotKI);
		yield return UnitMoveToTarget(Ambrosia, TargetAmbrosiaKI);
		Willa.LookAt(Chris);
		Ambrosia.LookAt(Chris);
		Archi.LookAt(Chris);
		Noot.LookAt(Chris);
		Margot.LookAt(Chris);
		yield return Chris.unitModel.Play("CsTransDIdleToKneelHack");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		Chris.UpdateIdleAnim();
		yield return HAGIS.DialogShow(ambient_ChrisMillionYears);
		yield return CreateTimeCondition(1f);
		yield return Chris.unitModel.Play("CsTransKneelHackToDIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.UpdateIdleAnim();
		SKIP_POINT("Skipped everyone moving");
		SFXPlayAtCoord("event:/sfx/script/act 1/a1s2/secret door open", ToMineTunnel);
		PlayMapAnimation(KaydockInteriorLogic.Map, "MA_HiddenEntranceDoor_01", "Open");
		Willa.LookAt(ToMineTunnel.transform);
		Chris.LookAt(ToMineTunnel.transform);
		Ambrosia.LookAt(ToMineTunnel.transform);
		Noot.LookAt(ToMineTunnel.transform);
		Margot.LookAt(ToMineTunnel.transform);
		Archi.LookAt(ToMineTunnel.transform);
		yield return HAGIS.DialogShow(ambient_HartmanTides);
		ToMineTunnel.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase5);
		yield return HAGIS.DialogShow(ambient_HartmanTeams);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.CutsceneEnd();
		yield return MapWaitUntilVisible(MineTunnelLogic.Map);
		CutsceneBegin();
		MusicPlay("event:/music/tracks/basic/drone 1");
		UIObjectives.Inst.CompleteObjective(objPhase5);
		SKIP_POINT("Skipped Ready to enter mine");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return UnitMoveToTarget(Willa, TargetWillaMT, null, 5f);
		UnitMoveToTarget(Droid2, TargetDroid2, null, 5f);
		UnitMoveToTarget(Droid3, TargetDroid3, null, 5f);
		Archi.unitModel.Play("CsTransDIdleViolinToDIdle");
		yield return CreateTimeCondition(0.6f);
		ViolinCase.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.6f);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultSlowWalk);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultInteract);
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Archi.UpdateIdleAnim();
		yield return null;
		yield return UnitMoveToTarget(Archi, TargetArchiMTCover, null, 5f);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase3c);
		MusicPlay("event:/music/tracks/combat/underclocks");
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Ambrosia.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Ambrosia.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		yield return null;
		SKIP_POINT("Skipped combat in the mines");
		MusicPlay("event:/music/tracks/exploration/random dark 1");
		GC.Inst.SetRPGLeader(Willa);
		UIObjectives.Inst.CompleteObjective(objPhase3c);
		yield return UnitMoveToTarget(Archi, TargetArchiMT);
		yield return Wait.While(Archi.LookInDirection(OctDir.Down));
		Archi.unitModel.Play("CsTransDIdleToDIdleViolin");
		yield return CreateTimeCondition(0.6f);
		ViolinCase.gameObject.SetActive(value: false);
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultRunViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CsDefaultWalkViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultInteractViolin");
		Archi.UpdateIdleAnim();
		yield return CreateTimeCondition(0.6f);
		Window.gameObject.SetActive(value: true);
		Lift.gameObject.SetActive(value: true);
		KeypadTrigger.gameObject.SetActive(value: true);
		Keypad.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase6);
		yield return CreateTriggerCondition(KeypadTrigger._OnTriggered);
		yield return CreateTriggerCondition(dialog_WillaKeypad.OnComplete);
		CutsceneBegin();
		UnitMoveToTarget(Archi, TargetArchiMT1);
		yield return UnitMoveToTarget(Ambrosia, TargetAmbrosiaMT1);
		Archi.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		SKIP_POINT("Mid Mission Room Cutscene");
		yield return HAGIS.DialogShow(dialog_HartmanHoldOn);
		MusicStop();
		yield return ShowRoom();
		button_AshelyPhotoCode.gameObject.SetActive(value: false);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		Hartman_TeleportToPointWithLookAt(move_tableRight, look_player);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Dialog_HartmanAhsylyPhoto);
		yield return CreateTimeCondition(0.4f);
		Hartman_LookAtPoint(L_AshelyPhoto, 0.25f);
		yield return CreateTimeCondition(0.9f);
		Hartman_PlayAnimation("ConcernedTalk");
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(L_AshelyPhoto, 1f);
		yield return CreateTimeCondition(1.5f);
		button_AshelyPhotoCode.gameObject.SetActive(value: true);
		yield return button_AshelyPhotoCode.OnTapUp;
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_PhotoClose, 1f);
		Hartman_LookAtPoint(L_AshelyPhoto, 0.25f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_window, 0.5f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(2f);
		yield return ShowMap();
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialog_HartmanKeypad);
		MusicStop();
		yield return UnitMoveToTarget(Willa, TargetWillaMT1, OctDir.Up);
		Willa.unitModel.Play("CsDefaultTyping", looping: true);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1s2/vault code", willa_entering_vault_code);
		yield return CreateTimeCondition(2f);
		yield return Willa.unitModel.Play("CsTransTypingToDIdle");
		Willa.UpdateIdleAnim();
		SKIP_POINT("Vault opening");
		yield return UnitMoveToTarget(Archi, TargetArchiMT2);
		Archi.LookInDirection(OctDir.Up);
		yield return Archi.unitModel.Play("CsDefaultInteractViolin");
		UnitMoveToTarget(Archi, TargetArchiMT1);
		yield return CreateTimeCondition(1f);
		Archi.LookInDirection(OctDir.Up);
		SKIP_POINT("Skipped Vault opening cutscene");
		yield return PlayMapAnimation(MineTunnelLogic.Map, VaultDoor, "Open");
		CutsceneEnd();
		ToVault.gameObject.SetActive(value: true);
		PlayMapAnimation(AtlantiumVaultLogic.Map, "MA_Atlantium_01", "IdleFloat", loop: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase7);
		yield return MapWaitUntilVisible(AtlantiumVaultLogic.Map);
		FromMineTunnel.gameObject.SetActive(value: false);
		yield return CutscenePlay("A1S2_Cutscene_AtlantiumVault");
		yield return CreateTriggerCondition(I_Atlantium.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objPhase7);
		yield return CutscenePlay("A1S2_Cutscene_AtlantiumVault_2");
		yield return CreateTimeCondition(0.5f);
	}
}
public class HAGIS_A1S2_GoldCoins : HAGIS
{
	private TileActionInteraction I_GoldCoins;

	private TileActionDialog I_EnoughCoins;

	private DialogData Ambient_GoldCoins;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		I_GoldCoins = MR.Inst.GetTileActionInteraction("490_T1AtlantiumVault_TileActionGiveLoot");
		I_EnoughCoins = MR.Inst.GetTileActionDialog("420_T1AtlantiumVault_TileActionDialog");
		Ambient_GoldCoins = HAGIS.DialogLoad("Dialogs/A1S2/Ambient_GoldCoins");
		I_EnoughCoins.gameObject.SetActive(value: false);
		yield return null;
		yield return CreateTriggerCondition(Ambient_GoldCoins.OnComplete);
		HagisLog("you got an money for the inventory!");
		I_GoldCoins.gameObject.SetActive(value: false);
		I_EnoughCoins.gameObject.SetActive(value: true);
	}
}
public class HAGIS_A1S2_Sarcophagus : HAGIS
{
	private TileActionDialog D_Sarcophagus;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		D_Sarcophagus = MR.Inst.GetTileActionDialog("D07_T1AtlantiumVault_TileActionGiveLoot");
		yield return null;
		yield return CreateTriggerCondition(D_Sarcophagus.OnDialogComplete);
		HagisLog("you got an aug for the inventory!");
		D_Sarcophagus.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A2O2 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Margot;

	private Unit Chris;

	private Unit Noot;

	private Unit Ambrosia;

	private Unit FuselGang3;

	private Unit FuselGang4;

	private Unit Holden;

	private Unit Gosz;

	private Unit Compilervictim;

	private Unit CompilerG1;

	private Unit CompilerG2;

	private Unit ProgrammerMR;

	private UnitTarget TargetWilla;

	private UnitTarget TargetGosz;

	private UnitTarget TargetMargot;

	private UnitTarget TargetVictim;

	private UnitTarget GangTarget1;

	private UnitTarget GangTarget2;

	private UnitTarget PosPH1;

	private UnitTarget PosPH2;

	private UnitTarget TargetTrain;

	private UnitTarget TargetTrain1;

	private UnitTarget TargetNoot;

	private UnitTarget TargetNoot2;

	private UnitTarget TargetAmbrosia;

	private UnitTarget TargetAmbrosiaUE;

	private UnitTarget TargetNootUE;

	private UnitTarget TargetLookAtUE;

	private UnitTarget Target1;

	private UnitTarget Target2;

	private UnitTarget Target3;

	private UnitTarget NootCombatTarget;

	private UnitTarget AmberCombatTarget;

	private UnitTarget HoldenTarget;

	private UnitTarget PosArchi;

	private UnitTarget TargetArchiUE;

	private UnitTarget TargetMargotUE;

	private UnitTarget TargetChrisUE;

	private UnitTarget TargetWillaUE;

	private UnitTarget T_NootPE;

	private UnitTarget T_AmbrosiaPE;

	private UnitTarget ViolinCase;

	private UnitTarget T_AmbroTrain;

	private UnitTarget T_NootTrain;

	private UnitTarget IdlePoint1;

	private UnitTarget IdlePoint2;

	private UnitTarget IdlePoint3;

	private UnitTarget T_NootOpensElevator;

	private UnitTarget OptionalRobots;

	private UnitTarget P_TUnitTargetToy;

	private TileActionSwapMap SkywayToFactoryExt;

	private TileActionSwapMap SkywayToUnderclock;

	private TileActionSwapMap ChumExtToGoszHQ;

	private TileActionSwapMap ChumExtToSkyway;

	private TileActionSwapMap GoszToChumExt;

	private TileActionSwapMap ShipToPortHara;

	private TileActionSwapMap PortMainToFrieghter;

	private TileActionSwapMap PortMainToPortEnt;

	private TileActionSwapMap PortEntToSubway;

	private TileActionSwapMap TrainToSubwayFiles;

	private TileActionSwapMap TrainToSubwayPort;

	private TileActionSwapMap ParkToSubway;

	private TileActionSwapMap ParkToGraveyard;

	private TileActionSwapMap GraveToPark;

	private TileActionSwapMap ElevatorToUnderclockers;

	private TileActionSwapMap MeetingRoomToElevator;

	private TileActionSwapMap MeetingRoomToStreet;

	private TileActionSwapMap StreetToMeetingRoom;

	private TileActionSwapMap StreetToSkyway;

	private TileActionInteraction I_ToGoszHQ;

	private TileActionInteraction I_GraveToTomb;

	private TileActionHotspot H_ChumleysPlaque;

	private TileActionHotspot H_TombElevatorPlaque;

	private TileActionHotspot H_TombElevatorPlaque2;

	private TileActionDialog TalkToHolden;

	private TileActionDialog CompilerVictim;

	private DialogData ambient_WillaDeepBreath;

	private DialogData ambient_WeCant;

	private DialogData ambient_TheGraveyard;

	private DialogData ambient_UnderclocksHQ;

	private DialogData ambient_Grunt;

	private DialogData dialog_WhoIsThis;

	private DialogData dialog_CompilerBusiness;

	private DialogData ambient_PrettyStandard;

	private DialogData dialog_TheTomb;

	private DialogData dialog_DontLeaveUs;

	private DialogData dialog_Guess;

	private DialogData ambient_Wow;

	private DialogData dialog_ArchiWelcome;

	private DialogData dialog_ChrisDuchess;

	private DialogData dialog_MissEntitled;

	private DialogData dialog_NootOh;

	private DialogData ambient_Amatol;

	private DialogData dialog_GoszIntro;

	private DialogData dialog_PostHug;

	private DialogData dialog_TheyreTrapped;

	private DialogData ambient_ComeInPeace;

	private DialogData ambinet_CompilerConversation;

	private DialogData dialog_ThanksBothOfYou;

	private DialogData ambient_ExpectedMore;

	private DialogData dialog_Node;

	private DialogData dialog_OpenThat;

	private DialogData dialog_StatueInteraction;

	private DialogData Ambient_Go;

	private string objGoszHQ = "OBJECTIVES_A2O2_01";

	private string objChumleys = "OBJECTIVES_A2O2_05";

	private string objCityWatch = "OBJECTIVES_A2O2_02";

	private string objSubway = "OBJECTIVES_A2O2_03";

	private string objGraveyard = "OBJECTIVES_A2O2_04";

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = -2f;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot ChumleysExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot GoszHQ = GetLogicUsingArtName("T2GoszsHQ");
		LogicRoot FreighterDeck = GetLogicUsingArtName("T1FreighterDeck");
		LogicRoot PortHara = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot HaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot Park = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot Graveyard = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot Elevator = GetLogicUsingArtName("T1RotgutPrison_Elevator");
		LogicRoot UnderclockersMeetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		LogicRoot UnderclockersExterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		Willa = GC.Inst.GetUnitWithId("A06_T2Skyway_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("1E9_T2Skyway_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("AC7_T2Skyway_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("625_T2Skyway_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("50A_T1FreighterDeck_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("18E_T1FreighterDeck_UnitSpawn");
		Holden = GC.Inst.GetUnitWithId("A80_T1DetritumGraveyard_UnitSpawn");
		FuselGang3 = GC.Inst.GetUnitWithId("7A9_T1FreighterDeck_UnitSpawn");
		FuselGang4 = GC.Inst.GetUnitWithId("F54_T1FreighterDeck_UnitSpawn");
		Gosz = GC.Inst.GetUnitWithId("5E0_T2GoszsHQ_UnitSpawn");
		Compilervictim = GC.Inst.GetUnitWithId("045_T1DetritumGraveyard_UnitSpawn");
		CompilerG1 = GC.Inst.GetUnitWithId("A2B_T1DetritumGraveyard_UnitSpawn");
		CompilerG2 = GC.Inst.GetUnitWithId("2B0_T1DetritumGraveyard_UnitSpawn");
		ProgrammerMR = GC.Inst.GetUnitWithId("A56_T2UnderclockMeetingRoom_UnitSpawn");
		TargetVictim = MR.Inst.GetUnitTarget("A13_T1DetritumGraveyard_UnitTarget");
		GangTarget1 = MR.Inst.GetUnitTarget("B64_T1Port2_HaraMainBay_UnitTarget");
		GangTarget2 = MR.Inst.GetUnitTarget("DEE_T1Port2_HaraMainBay_UnitTarget");
		TargetWilla = MR.Inst.GetUnitTarget("083_T2GoszsHQ_UnitTarget");
		TargetGosz = MR.Inst.GetUnitTarget("3C8_T2GoszsHQ_UnitTarget");
		TargetMargot = MR.Inst.GetUnitTarget("E4A_T2GoszsHQ_UnitTarget");
		PosPH1 = MR.Inst.GetUnitTarget("D38_T1Port2_HaraMainBay_UnitTarget");
		PosPH2 = MR.Inst.GetUnitTarget("C8D_T1Port2_HaraMainBay_UnitTarget");
		TargetNoot = MR.Inst.GetUnitTarget("B48_T2UnderclockMeetingRoom_UnitTarget");
		TargetNoot2 = MR.Inst.GetUnitTarget("0D8_T2UnderclockMeetingRoom_UnitTarget");
		TargetAmbrosia = MR.Inst.GetUnitTarget("54C_T2UnderclockMeetingRoom_UnitTarget");
		TargetNootUE = MR.Inst.GetUnitTarget("B61_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		TargetAmbrosiaUE = MR.Inst.GetUnitTarget("A61_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		TargetLookAtUE = MR.Inst.GetUnitTarget("612_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		Target1 = MR.Inst.GetUnitTarget("21E_T1DetritumGraveyard_UnitTarget");
		Target2 = MR.Inst.GetUnitTarget("9CB_T1DetritumGraveyard_UnitTarget");
		Target3 = MR.Inst.GetUnitTarget("71D_T1DetritumGraveyard_UnitTarget");
		NootCombatTarget = MR.Inst.GetUnitTarget("817_T1DetritumGraveyard_UnitTarget");
		AmberCombatTarget = MR.Inst.GetUnitTarget("77B_T1DetritumGraveyard_UnitTarget");
		HoldenTarget = MR.Inst.GetUnitTarget("B4C_T1DetritumGraveyard_UnitTarget");
		PosArchi = MR.Inst.GetUnitTarget("F3A_T1RotgutPrison_Elevator_UnitTarget");
		TargetArchiUE = MR.Inst.GetUnitTarget("90F_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		TargetChrisUE = MR.Inst.GetUnitTarget("42C_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		TargetMargotUE = MR.Inst.GetUnitTarget("520_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		TargetWillaUE = MR.Inst.GetUnitTarget("ECA_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		T_NootPE = MR.Inst.GetUnitTarget("1F2_T1Port1_HaraEntrance_UnitTarget");
		T_AmbrosiaPE = MR.Inst.GetUnitTarget("C9E_T1Port1_HaraEntrance_UnitTarget");
		ViolinCase = MR.Inst.GetUnitTarget("6D5_T2GoszsHQ_UnitTarget");
		T_AmbroTrain = MR.Inst.GetUnitTarget("D87_T1Subway_TrainInterior_UnitTarget");
		T_NootTrain = MR.Inst.GetUnitTarget("7B0_T1Subway_TrainInterior_UnitTarget");
		T_NootOpensElevator = MR.Inst.GetUnitTarget("A45_T1DetritumGraveyard_UnitTarget");
		OptionalRobots = MR.Inst.GetUnitTarget("265_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		P_TUnitTargetToy = MR.Inst.GetUnitTarget("C79_T2GoszsHQ_UnitTarget");
		UnitTarget sfx_noot_clears_branches = MR.Inst.GetUnitTarget("A45_T1DetritumGraveyard_UnitTarget");
		IdlePoint1 = MR.Inst.GetUnitTarget("BE1_T2Skyway_UnitTarget");
		IdlePoint2 = MR.Inst.GetUnitTarget("96F_T2Skyway_UnitTarget");
		IdlePoint3 = MR.Inst.GetUnitTarget("ECA_T2Skyway_UnitTarget");
		SkywayToFactoryExt = MR.Inst.GetTileActionSwapMap("B93_T2Skyway_TileActionSwapMap");
		SkywayToUnderclock = MR.Inst.GetTileActionSwapMap("EA1_T2Skyway_TileActionSwapMap");
		ChumExtToGoszHQ = MR.Inst.GetTileActionSwapMap("5C3_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		ChumExtToSkyway = MR.Inst.GetTileActionSwapMap("4B0_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		GoszToChumExt = MR.Inst.GetTileActionSwapMap("4E2_T2GoszsHQ_TileActionSwapMap");
		ShipToPortHara = MR.Inst.GetTileActionSwapMap("994_T1FreighterDeck_TileActionSwapMap");
		PortMainToFrieghter = MR.Inst.GetTileActionSwapMap("A73_T1Port2_HaraMainBay_TileActionSwapMap");
		PortMainToPortEnt = MR.Inst.GetTileActionSwapMap("BA7_T1Port2_HaraMainBay_TileActionSwapMap");
		PortEntToSubway = MR.Inst.GetTileActionSwapMap("172_T1Port1_HaraEntrance_TileActionSwapMap");
		TrainToSubwayFiles = MR.Inst.GetTileActionSwapMap("F10_T1Subway_TrainInterior_TileActionSwapMap");
		TrainToSubwayPort = MR.Inst.GetTileActionSwapMap("276_T1Subway_TrainInterior_TileActionSwapMap");
		ParkToSubway = MR.Inst.GetTileActionSwapMap("DE5_T1DetritumPark_TileActionSwapMap");
		ParkToGraveyard = MR.Inst.GetTileActionSwapMap("373_T1DetritumPark_TileActionSwapMap");
		GraveToPark = MR.Inst.GetTileActionSwapMap("FA7_T1DetritumGraveyard_TileActionSwapMap");
		ElevatorToUnderclockers = MR.Inst.GetTileActionSwapMap("B89_T1RotgutPrison_Elevator_TileActionSwapMap");
		MeetingRoomToElevator = MR.Inst.GetTileActionSwapMap("1EF_T2UnderclockMeetingRoom_TileActionSwapMap");
		MeetingRoomToStreet = MR.Inst.GetTileActionSwapMap("2C5_T2UnderclockMeetingRoom_TileActionSwapMap");
		StreetToMeetingRoom = MR.Inst.GetTileActionSwapMap("EEB_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		StreetToSkyway = MR.Inst.GetTileActionSwapMap("F0D_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		TalkToHolden = MR.Inst.GetTileActionDialog("BE6_T1DetritumGraveyard_TileActionDialog");
		CompilerVictim = MR.Inst.GetTileActionDialog("77A_T1DetritumGraveyard_TileActionDialog");
		I_GraveToTomb = MR.Inst.GetTileActionInteraction("483_T1DetritumGraveyard_TileActionInteraction");
		I_ToGoszHQ = MR.Inst.GetTileActionInteraction("3D3_T2ChumleysAutomatons_Exterior_TileActionInteraction");
		H_ChumleysPlaque = MR.Inst.GetTileActionHotspot("14E_T2ChumleysAutomatons_Exterior_TileActionHotspot");
		H_TombElevatorPlaque = MR.Inst.GetTileActionHotspot("255_T1DetritumGraveyard_TileActionHotspot");
		H_TombElevatorPlaque2 = MR.Inst.GetTileActionHotspot("59B_T1DetritumGraveyard_TileActionHotspot");
		ambient_WillaDeepBreath = HAGIS.DialogLoad("Dialogs/A2O2/ChumleysFactoryExterior/AmbientWillaDeepBreath");
		dialog_WhoIsThis = HAGIS.DialogLoad("Dialogs/A2O2/ChumleysFactoryExterior/DialogWhoIsThis");
		dialog_Node = HAGIS.DialogLoad("Dialogs/A2O2/ChumleysFactoryExterior/DialogNode");
		dialog_StatueInteraction = HAGIS.DialogLoad("Dialogs/A2O2/ChumleysFactoryExterior/DialogStatueInteraction");
		ambient_Grunt = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientGrunt");
		ambinet_CompilerConversation = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientMyClavicles");
		ambient_ExpectedMore = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientExpectedMore");
		dialog_CompilerBusiness = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogCompilerBusiness");
		ambient_PrettyStandard = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientPrettyStandard");
		dialog_TheTomb = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogTheTomb");
		dialog_Guess = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogGuess");
		dialog_ThanksBothOfYou = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogThanksBothOfYou");
		dialog_OpenThat = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogOpenThat");
		ambient_WeCant = HAGIS.DialogLoad("Dialogs/A2O2/PortHara/AmbientWeCant");
		ambient_TheGraveyard = HAGIS.DialogLoad("Dialogs/A2O2/SubwayTrain/AmbientTheGraveyard");
		ambient_UnderclocksHQ = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksMeetingRoom/AmbientUnderclocksHQ");
		Ambient_Go = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksMeetingRoom/Ambient_Go");
		dialog_DontLeaveUs = HAGIS.DialogLoad("Dialogs/A2O2/FreighterDeck/DialogDontLeaveUs");
		ambient_Wow = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksExterior/Ambient_Wow");
		dialog_ArchiWelcome = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksExterior/Dialog_ArchiWelcome");
		dialog_ChrisDuchess = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksExterior/Dialog_ChrisDuchess");
		dialog_MissEntitled = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksExterior/Dialog_MissEntitled");
		dialog_NootOh = HAGIS.DialogLoad("Dialogs/A2O2/UnderclocksExterior/Dialog_NootOh");
		dialog_GoszIntro = HAGIS.DialogLoad("Dialogs/A2O2/GoszsHQ/DialogGoszIntro");
		dialog_PostHug = HAGIS.DialogLoad("Dialogs/A2O2/GoszsHQ/DialogPostHug");
		dialog_TheyreTrapped = HAGIS.DialogLoad("Dialogs/A2O2/GoszsHQ/DialogTheyreTrapped");
		ambient_ComeInPeace = HAGIS.DialogLoad("Dialogs/A2O2/GoszsHQ/AmbientComeInPeace");
		ambient_Amatol = HAGIS.DialogLoad("Dialogs/A2O2/GoszsHQ/AmbientAmatol");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("515_T1DetritumGraveyard_TileBlockDynamic");
		ProgrammerMR.abilities.Add<Ability_Restore>(null, isUpgraded: false);
		elevatorWalls = Elevator.Map.GetComponentInChildren<ScrollingWalls>();
		P_TUnitTargetToy.gameObject.SetActive(value: false);
		H_TombElevatorPlaque2.gameObject.SetActive(value: false);
		ViolinCase.gameObject.SetActive(value: false);
		Compilervictim.gameObject.SetActive(value: false);
		CompilerG2.gameObject.SetActive(value: false);
		TalkToHolden.gameObject.SetActive(value: false);
		SkywayToFactoryExt.gameObject.SetActive(value: false);
		ChumExtToGoszHQ.gameObject.SetActive(value: false);
		ChumExtToSkyway.gameObject.SetActive(value: false);
		GoszToChumExt.gameObject.SetActive(value: false);
		ShipToPortHara.gameObject.SetActive(value: false);
		PortMainToFrieghter.gameObject.SetActive(value: false);
		PortMainToPortEnt.gameObject.SetActive(value: false);
		PortEntToSubway.gameObject.SetActive(value: false);
		TrainToSubwayFiles.gameObject.SetActive(value: false);
		ParkToGraveyard.gameObject.SetActive(value: false);
		GraveToPark.gameObject.SetActive(value: false);
		I_GraveToTomb.gameObject.SetActive(value: false);
		ElevatorToUnderclockers.gameObject.SetActive(value: false);
		MeetingRoomToElevator.gameObject.SetActive(value: false);
		MeetingRoomToStreet.gameObject.SetActive(value: false);
		StreetToMeetingRoom.gameObject.SetActive(value: false);
		CompilerVictim.gameObject.SetActive(value: false);
		SkywayToUnderclock.gameObject.SetActive(value: false);
		I_ToGoszHQ.gameObject.SetActive(value: false);
		OptionalRobots.gameObject.SetActive(value: false);
		yield return null;
		HAGIS.ToggleShakeEnvironment(on: true);
		MusicPlay("event:/music/tracks/exploration/random light 1");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultRunViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CsDefaultWalkViolin");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultInteractViolin");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDetonatorIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultDetonatorWalk");
		Compilervictim.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultScaredRun");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnitMoveToTarget(Margot, IdlePoint1);
		UnitMoveToTarget(Chris, IdlePoint2);
		yield return UnitMoveToTarget(Archi, IdlePoint3);
		Chris.LookAt(Willa.gameObject.transform);
		Margot.LookAt(Willa.gameObject.transform);
		GC.Inst.SetRPGLeader(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialog_WhoIsThis);
		UIObjectives.Inst.CompleteAndSetMainObjective(objChumleys);
		Skyway.CanTeammatesFollow = true;
		SKIP_POINT("Mission Intro completed");
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_Chumleys_L0");
		SkywayToFactoryExt.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(ChumleysExterior.Map);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoszHQ);
		PlayMapAnimation(ChumleysExterior.Map, "MA_TenorCityCentre_Train", "TrainExit");
		HAGIS.DialogShow(ambient_WillaDeepBreath);
		ChumleysExterior.CanTeammatesFollow = true;
		SKIP_POINT("Skipped getting off the train");
		yield return CreateTriggerCondition(H_ChumleysPlaque.OnHotspotComplete);
		CutsceneBegin();
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToCrouch");
		yield return UnitPlayAnimation(Willa, "CsDefaultCrouch");
		yield return HAGIS.DialogShow(dialog_Node);
		yield return CreateTimeCondition(0.5f);
		SFXPlay("event:/sfx/doors/bt cellar door keycard");
		yield return CreateTimeCondition(0.2f);
		PlayMapAnimation(ChumleysExterior.Map, "MA_HiddenStatueDoor", "Open");
		yield return CreateTimeCondition(0.1f);
		SFXPlay("event:/sfx/doors/heavy smooth open");
		yield return CreateTimeCondition(1.5f);
		yield return HAGIS.DialogShow(dialog_StatueInteraction);
		yield return TeamMoveToMapViaEntranceTile(GoszToChumExt);
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Skipped locating hideout");
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objGoszHQ);
		SKIP_POINT("Skipped entering hideout");
		PlayMapAnimation(GoszHQ.Map, "MA_GoszDoor", "Open");
		yield return CutscenePlay("A2O2_Cutscene_MeetingGosz");
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultSlowWalk);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultInteract);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Noot);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		yield return null;
		SKIP_POINT("Skipped hideout cutscene");
		yield return MapGoto(FreighterDeck);
		MusicStop();
		yield return HAGIS.DialogShow(dialog_DontLeaveUs);
		SKIP_POINT("Skiped to fight on ship");
		UIObjectives.Inst.CompleteAndSetMainObjective(objCityWatch);
		MusicPlay("event:/music/tracks/combat/underclocks");
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return null;
		MusicPlay("event:/music/tracks/basic/lights out 2");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.UpdateIdleAnim();
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.UpdateIdleAnim();
		yield return null;
		FreighterDeck.CanTeammatesFollow = true;
		SKIP_POINT("Skiped Combat");
		ShipToPortHara.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteObjective(objCityWatch);
		yield return MapWaitUntilMidTransition(PortHara);
		Noot.LookInDirection(OctDir.Up);
		yield return MapWaitUntilVisible(PortHara.Map);
		SKIP_POINT("Skip to Port Hara");
		CutsceneBegin();
		yield return Wait.While(FuselGang4.LookAt(Ambrosia));
		yield return Wait.While(FuselGang3.LookAt(Ambrosia));
		FuselGang4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		FuselGang3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return CreateAndCondition(UnitMoveToTarget(Ambrosia, PosPH1), UnitMoveToTarget(Noot, PosPH2), UnitMoveToTarget(FuselGang4, GangTarget2, null, 5f), UnitMoveToTarget(FuselGang3, GangTarget1, null, 5f));
		CutsceneEnd();
		yield return null;
		MusicPlay("event:/music/tracks/combat/tucker combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return null;
		MusicStop();
		PortMainToPortEnt.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(ambient_WeCant);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objSubway);
		PortHara.CanTeammatesFollow = true;
		yield return MapWaitUntilVisible(HaraEntrance.Map);
		SKIP_POINT("Skip to Port Hara Entrance");
		UnitMoveToTarget(Noot, T_NootPE);
		UnitMoveToTarget(Ambrosia, T_AmbrosiaPE);
		yield return null;
		MusicPlay("event:/music/tracks/exploration/techtonics");
		HaraEntrance.CanTeammatesFollow = true;
		yield return CreateTimeCondition(2f);
		PlayInterplay();
		SKIP_POINT("Skip Port Hara Entrance combat");
		PortEntToSubway.gameObject.SetActive(value: true);
		TrainToSubwayPort.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		UIObjectives.Inst.CompleteObjective(objSubway);
		SKIP_POINT("Skip to subway train");
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(0.25f);
		yield return CutscenePlay("A2O2_Cutscene_SittingOnTrain");
		UIObjectives.Inst.CompleteAndSetMainObjective(objGraveyard);
		yield return PlayInterplay();
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Files_L0");
		yield return PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		TrainToSubwayFiles.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(Park.Map);
		MusicStop();
		ParkToSubway.gameObject.SetActive(value: false);
		Park.CanTeammatesFollow = true;
		yield return CreateTimeCondition(2f);
		PlayInterplay();
		ParkToGraveyard.gameObject.SetActive(value: true);
		SKIP_POINT("Skip to Park");
		GraveToPark.gameObject.SetActive(value: false);
		Compilervictim.gameObject.SetActive(value: true);
		CompilerG2.gameObject.SetActive(value: true);
		Holden.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(Graveyard.Map);
		MusicPlay("event:/music/tracks/basic/compilers intro");
		UIObjectives.Inst.CompleteObjective(objGraveyard);
		SKIP_POINT("Skip to Graveyard");
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambinet_CompilerConversation);
		CutsceneEnd();
		TalkToHolden.gameObject.SetActive(value: true);
		Graveyard.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(TalkToHolden.OnDialogComplete);
		TalkToHolden.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_Guess);
		HAGIS_A2O2 hAGIS_A2O = this;
		Unit holden = Holden;
		UnitTarget holdenTarget = HoldenTarget;
		float? speed = Holden.charData.movementSpeedInCombat;
		hAGIS_A2O.UnitMoveToTarget(holden, holdenTarget, null, speed);
		HAGIS_A2O2 hAGIS_A2O2 = this;
		holden = CompilerG1;
		holdenTarget = Target1;
		speed = CompilerG1.charData.movementSpeedInCombat;
		hAGIS_A2O2.UnitMoveToTarget(holden, holdenTarget, null, speed);
		HAGIS_A2O2 hAGIS_A2O3 = this;
		holden = CompilerG2;
		holdenTarget = Target2;
		speed = CompilerG2.charData.movementSpeedInCombat;
		hAGIS_A2O3.UnitMoveToTarget(holden, holdenTarget, null, speed);
		HAGIS_A2O2 hAGIS_A2O4 = this;
		holden = Ambrosia;
		holdenTarget = AmberCombatTarget;
		speed = Ambrosia.charData.movementSpeedInCombat;
		hAGIS_A2O4.UnitMoveToTarget(holden, holdenTarget, null, speed);
		HAGIS_A2O2 hAGIS_A2O5 = this;
		holden = Noot;
		holdenTarget = NootCombatTarget;
		speed = Noot.charData.movementSpeedInCombat;
		yield return hAGIS_A2O5.UnitMoveToTarget(holden, holdenTarget, null, speed);
		yield return CreateTimeCondition(0.5f);
		HAGIS_A2O2 hAGIS_A2O6 = this;
		holden = Compilervictim;
		holdenTarget = TargetVictim;
		speed = Compilervictim.charData.movementSpeedInCombat;
		yield return hAGIS_A2O6.UnitMoveToTarget(holden, holdenTarget, null, speed);
		Compilervictim.LookInDirection(OctDir.Right);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/basic/compilers main");
		yield return CombatBegin(UnitTeam.Type.Player);
		H_TombElevatorPlaque.gameObject.SetActive(value: false);
		H_TombElevatorPlaque2.gameObject.SetActive(value: true);
		yield return null;
		MusicStop();
		GC.Inst.SetRPGLeader(Noot);
		CompilerVictim.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(dialog_TheTomb);
		SKIP_POINT("Skip Graveyard Fight");
		yield return CreateTriggerCondition(H_TombElevatorPlaque2.OnHotspotComplete);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_OpenThat);
		yield return UnitMoveToTarget(Noot, T_NootOpensElevator, OctDir.Up);
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(Noot, "CsDefaultOpenTomb");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(ambient_Grunt);
		yield return CreateTimeCondition(0.7f);
		PlayMapAnimation(Graveyard.Map, "MA_Graveyard_Tomb", "Open");
		yield return PlayMapAnimation(Graveyard.Map, "MA_GraveyardDoors", "Open");
		Dynamicblock.gameObject.SetActive(value: false);
		UnitMoveToTarget(Ambrosia, Target3, OctDir.UpRight);
		MusicPlay("event:/music/tracks/basic/techtonics pt 2");
		yield return HAGIS.DialogShow(ambient_PrettyStandard);
		H_TombElevatorPlaque2.gameObject.SetActive(value: false);
		yield return UnitTeleportToMapViaEntranceTile(Noot, ElevatorToUnderclockers);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, ElevatorToUnderclockers);
		yield return MapGoto(Elevator);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		SKIP_POINT("Skip to Elevator");
		Dynamicblock.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Noot, PosArchi);
		Noot.LookAt(Ambrosia);
		Ambrosia.LookAt(Noot);
		yield return null;
		elevatorWalls.speed = elevatorSpeed;
		MusicStop();
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		HAGIS.ToggleShakeEnvironment(on: false);
		elevatorWalls.speed = 0f;
		ElevatorToUnderclockers.gameObject.SetActive(value: true);
		yield return UnitMoveToMapViaExitTile(Ambrosia, ElevatorToUnderclockers);
		yield return UnitMoveToMapViaExitTile(Noot, ElevatorToUnderclockers);
		yield return MapGoto(UnderclockersMeetingRoom);
		UnitMoveToTarget(Noot, TargetNoot);
		yield return UnitMoveToTarget(Ambrosia, TargetAmbrosia);
		yield return HAGIS.DialogShow(ambient_UnderclocksHQ);
		yield return null;
		yield return UnitMoveToTarget(Noot, TargetNoot2, null, 4f);
		UIObjectives.Inst.CompleteAndSetMainObjective(objCityWatch);
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Skip to UnderclockMeetingroom");
		yield return null;
		MusicPlay("event:/music/tracks/combat/underclock combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		MeetingRoomToStreet.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteObjective(objCityWatch);
		UnderclockersMeetingRoom.CanTeammatesFollow = true;
		yield return CreateTimeCondition(1f);
		yield return MapWaitUntilVisible(UnderclockersExterior.Map);
		SKIP_POINT("Skipped UnderclockMeetingroom");
		MusicPlay("event:/music/tracks/basic/safety in numbers 2");
		yield return CutscenePlay("A2O2_Cutscene_WelcomeToTenor");
	}
}
public class HAGIS_A2O2_CompilerInteraction : HAGIS
{
	private Unit Noot;

	private Unit Ambrosia;

	private Unit CompilerG1;

	private UnitTarget Target7;

	private DialogData ambient_ExpectedMore;

	private DialogData dialog_ThanksBothOfYou;

	private TileActionDialog CompilerVictimTrigger;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		CompilerG1 = GC.Inst.GetUnitWithId("045_T1DetritumGraveyard_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("50A_T1FreighterDeck_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("18E_T1FreighterDeck_UnitSpawn");
		Target7 = MR.Inst.GetUnitTarget("9BF_T1DetritumGraveyard_UnitTarget");
		ambient_ExpectedMore = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientExpectedMore");
		dialog_ThanksBothOfYou = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/DialogThanksBothOfYou");
		CompilerVictimTrigger = MR.Inst.GetTileActionDialog("77A_T1DetritumGraveyard_TileActionDialog");
		yield return null;
		yield return CreateTriggerCondition(CompilerVictimTrigger.OnDialogShow);
		Ambrosia.LookAt(Noot);
		UnitPlayAnimation(CompilerG1, "CsTransScaredToDIdle");
		CompilerG1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle", ignoreIdleUpdate: true);
		CompilerG1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalk", ignoreIdleUpdate: true);
		yield return CreateTriggerCondition(dialog_ThanksBothOfYou.OnComplete);
		HAGIS_A2O2_CompilerInteraction hAGIS_A2O2_CompilerInteraction = this;
		Unit compilerG = CompilerG1;
		UnitTarget target = Target7;
		float? speed = CompilerG1.charData.movementSpeed;
		yield return hAGIS_A2O2_CompilerInteraction.UnitMoveToTarget(compilerG, target, null, speed);
		CompilerG1.Hide(makeInactive: true);
		Noot.LookAt(Ambrosia);
		yield return HAGIS.DialogShow(ambient_ExpectedMore);
	}
}
public class HAGIS_A2O2_CrowAnimations : HAGIS
{
	private DialogData ambient_Grunt;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		ambient_Grunt = HAGIS.DialogLoad("Dialogs/A2O2/DetriumGraveyard/AmbientGrunt");
		Unit GraveCrow = GC.Inst.GetUnitWithId("4FD_T1DetritumGraveyard_UnitSpawn");
		Unit GraveCrow2 = GC.Inst.GetUnitWithId("1AF_T1DetritumGraveyard_UnitSpawn");
		GraveCrow.unitModel.HACK_BirdMode = true;
		TileTrigger TT_ACTIVITEBIRDS = MR.Inst.GetTileTrigger("9B5_T1DetritumGraveyard_TileTrigger");
		LogicRoot GraveYard = GetLogicUsingArtName("T1DetritumGraveyard");
		yield return null;
		yield return TT_ACTIVITEBIRDS._OnTriggered;
		yield return CreateTimeCondition(0.5f);
		UnitPlayAnimation(GraveCrow, "DefaultTakeOff");
		GraveCrow.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultTakeOff");
		yield return CreateTimeCondition(3f);
		GraveCrow.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		yield return null;
		GraveCrow.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		GraveCrow.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		yield return ambient_Grunt.OnComplete;
		GraveCrow2.unitModel.HACK_BirdMode = true;
		UnitPlayAnimation(GraveCrow2, "DefaultTakeOff");
		GraveCrow2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultTakeOff");
		yield return CreateTimeCondition(3f);
		GraveCrow2.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		yield return null;
		GraveCrow2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		GraveCrow2.unitModel.Play(UnitModel.AnimID.DefaultIdle);
	}
}
public class HAGIS_A2O3 : HAGIS
{
	private Unit Willa;

	private Unit TeamMember2;

	private Unit TeamMember3;

	private Unit RobotRunner1;

	private Unit RobotRunner2;

	private Unit RobotRunner3;

	private Unit RobotSoldier;

	private Unit RobotMuscle1;

	private Unit RobotMuscle2;

	private Unit RobotTrigger;

	private Unit RobotProgrammer;

	private Unit UVitaSoftMuscle;

	private Unit Gosz;

	private UnitTarget TargetWillaPE;

	private UnitTarget TargetArchiPE;

	private UnitTarget TargetChrisPE;

	private UnitTarget TargetWillaTB;

	private UnitTarget TargetArchiTB;

	private UnitTarget TargetChrisTB;

	private UnitTarget targetMuscle1;

	private UnitTarget targetMuscle2;

	private UnitTarget targetSoldier;

	private UnitTarget targetTrigger;

	private UnitTarget targetRunner1;

	private UnitTarget targetRunner2;

	private UnitTarget targetRunner3;

	private UnitTarget targetProgrammer;

	private UnitTarget targetRobotCutscene1;

	private UnitTarget targetRobotCutscene3;

	private UnitTarget targetRobotCutscene2;

	private UnitTarget TargetGoszCI;

	private UnitTarget TargetGoszCI2;

	private UnitTarget TargetGoszTB;

	private UnitTarget TargetGoszTB1;

	private UnitTarget TargetRobot1;

	private UnitTarget TargetRobot2;

	private UnitTarget TargetRobot3;

	private UnitTarget TargetRobot4;

	private UnitTarget TargetSkyway;

	private TileActionSwapMap ToFactoryEXT;

	private TileActionSwapMap ToPlantInterior;

	private TileActionSwapMap FromExterior;

	private TileActionSwapMap ToTestBay;

	private TileActionSwapMap ToGozsHQ;

	private TileActionSwapMap ToMain;

	private TileActionDialog DialogImpressed;

	private TileActionDialog DialogWhatsTheRush;

	private TileActionDialog DialogAndroidparts;

	private TileActionDialog D_BeepBoop;

	private TileActionDialog D_WallControl;

	private TileActionDialog D_AtTheVilla;

	private TileActionDialog D_AnAxe;

	private TileActionDialog D_TheresBlood;

	private TileActionInteraction I_BackToFactoryINT;

	private TileBlockDynamic TL1;

	private TileBlockDynamic TL2;

	private TileBlockDynamic TL3;

	private TileBlockDynamic TM1;

	private TileBlockDynamic TM2;

	private TileBlockDynamic TM3;

	private TileBlockDynamic TR1;

	private TileBlockDynamic TR2;

	private TileBlockDynamic TR3;

	private TileBlockDynamic BL1;

	private TileBlockDynamic BL2;

	private TileBlockDynamic BL3;

	private TileBlockDynamic BM1;

	private TileBlockDynamic BM2;

	private TileBlockDynamic BM3;

	private TileBlockDynamic BR1;

	private TileBlockDynamic BR2;

	private TileBlockDynamic BR3;

	private TileBlockDynamic M1;

	private TileBlockDynamic M2;

	private TileBlockDynamic M3;

	private TileBlockDynamic R1;

	private TileBlockDynamic R2;

	private TileBlockDynamic R3;

	private TileBlockDynamic DD1;

	private TileBlockDynamic DD2;

	private TileBlockDynamic DD3;

	private TileBlockDynamic DD4;

	private DialogData ambient_GoszTrail;

	private DialogData ambient_WillaDeepBreath;

	private DialogData ambient_GoszIsWaiting;

	private DialogData dialog_Compassionate;

	private DialogData dialog_CompThenComp;

	private DialogData dialog_CompThenHon;

	private DialogData dialog_Honest;

	private DialogData dialog_HonThenComp;

	private DialogData dialog_HonThenHon;

	private DialogData dialog_SorryAboutYourFarther;

	private DialogData dialog_CravensPlan;

	private DialogData dialog_CravensPlanCont;

	private DialogData dialog_WhatsTheRush;

	private DialogData ambient_CheckTheView;

	private DialogData dialog_WillaImpressed;

	private DialogData dialog_AugmentCrisis;

	private DialogData dialog_MagnumOpus;

	private DialogData ambient_KeepThisSafe;

	private DialogData ambient_Sentient;

	private DialogData ambient_WonRound1;

	private DialogData ambient_WonRound2;

	private DialogData ambient_WonRound3;

	private DialogData ambient_WonRound4;

	private DialogData dialog_FailedRound1;

	private DialogData ambient_GoszTrick;

	private DialogData ambient_QADepartment;

	private DialogData ambient_OtherFirstHit;

	private DialogData dialog_NeverGetsOld;

	private DialogData ambient_FirstKO;

	private DialogData dialog_TestComplete;

	private DialogData ambient_WillaFirstHit;

	private DialogData dialog_ContinueToRound2;

	private DialogData dialog_ContinueToRound3;

	private DialogData dialog_ContinueToRound4;

	private DialogData ambient_HitWilla;

	private DialogData ambient_TwoKOs;

	private string objEnter = "OBJECTIVES_A2O3_01";

	private string objTest = "OBJECTIVES_A2O3_02";

	private string objExit = "OBJECTIVES_A2O3_03";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot GoszsHQ = GetLogicUsingArtName("T2GoszsHQ");
		LogicRoot ChumleysExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot ChumleysInterior = GetLogicUsingArtName("T2ChumleysFactory");
		LogicRoot ChumleysTestbay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("AFE_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		Willa = GC.Inst.GetUnitWithId("0D9_T2GoszsHQ_UnitSpawn");
		TeamMember2 = GC.Inst.GetUnitWithId("AAE_T2ChumleysAutomatons_Exterior_UnitSpawn");
		TeamMember3 = GC.Inst.GetUnitWithId("C8A_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Gosz = GC.Inst.GetUnitWithId("FC2_T2ChumleysAutomatons_Exterior_UnitSpawn");
		RobotRunner1 = GC.Inst.GetUnitWithId("DD3_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotRunner2 = GC.Inst.GetUnitWithId("F06_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotRunner3 = GC.Inst.GetUnitWithId("F96_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotSoldier = GC.Inst.GetUnitWithId("007_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotMuscle1 = GC.Inst.GetUnitWithId("F1D_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotMuscle2 = GC.Inst.GetUnitWithId("6AC_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotTrigger = GC.Inst.GetUnitWithId("78C_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		RobotProgrammer = GC.Inst.GetUnitWithId("263_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		UVitaSoftMuscle = GC.Inst.GetUnitWithId("2AF_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		TargetWillaPE = MR.Inst.GetUnitTarget("3D1_T2ChumleysAutomatons_Exterior_UnitTarget");
		TargetArchiPE = MR.Inst.GetUnitTarget("BD5_T2ChumleysAutomatons_Exterior_UnitTarget");
		TargetChrisPE = MR.Inst.GetUnitTarget("030_T2ChumleysAutomatons_Exterior_UnitTarget");
		TargetWillaTB = MR.Inst.GetUnitTarget("DC4_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetArchiTB = MR.Inst.GetUnitTarget("E53_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetChrisTB = MR.Inst.GetUnitTarget("731_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetMuscle1 = MR.Inst.GetUnitTarget("4DE_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetMuscle2 = MR.Inst.GetUnitTarget("B0A_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetSoldier = MR.Inst.GetUnitTarget("4BB_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetTrigger = MR.Inst.GetUnitTarget("72B_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRunner1 = MR.Inst.GetUnitTarget("8A0_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRunner2 = MR.Inst.GetUnitTarget("7A4_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRunner3 = MR.Inst.GetUnitTarget("497_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetProgrammer = MR.Inst.GetUnitTarget("474_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRobotCutscene1 = MR.Inst.GetUnitTarget("DD1_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRobotCutscene3 = MR.Inst.GetUnitTarget("A20_T2ChumleysFactory_TestingControlBay_UnitTarget");
		targetRobotCutscene2 = MR.Inst.GetUnitTarget("048_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetGoszCI = MR.Inst.GetUnitTarget("AD9_T2ChumleysFactory_UnitTarget");
		TargetGoszCI2 = MR.Inst.GetUnitTarget("5A4_T2ChumleysFactory_UnitTarget");
		TargetGoszTB = MR.Inst.GetUnitTarget("71C_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetGoszTB1 = MR.Inst.GetUnitTarget("994_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetRobot1 = MR.Inst.GetUnitTarget("F09_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetRobot2 = MR.Inst.GetUnitTarget("912_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetRobot3 = MR.Inst.GetUnitTarget("334_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetRobot4 = MR.Inst.GetUnitTarget("D3D_T2ChumleysFactory_TestingControlBay_UnitTarget");
		TargetSkyway = MR.Inst.GetUnitTarget("870_T2ChumleysAutomatons_Exterior_UnitTarget");
		ToFactoryEXT = MR.Inst.GetTileActionSwapMap("7C9_T2GoszsHQ_TileActionSwapMap");
		ToPlantInterior = MR.Inst.GetTileActionSwapMap("11F_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		FromExterior = MR.Inst.GetTileActionSwapMap("4C2_T2ChumleysFactory_TileActionSwapMap");
		ToTestBay = MR.Inst.GetTileActionSwapMap("5C0_T2ChumleysFactory_TileActionSwapMap");
		ToMain = MR.Inst.GetTileActionSwapMap("019_T2ChumleysFactory_TestingControlBay_TileActionSwapMap");
		ToGozsHQ = MR.Inst.GetTileActionSwapMap("E57_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		DialogImpressed = MR.Inst.GetTileActionDialog("800_T2ChumleysFactory_TileActionDialog");
		DialogWhatsTheRush = MR.Inst.GetTileActionDialog("FF1_T2ChumleysFactory_TileActionDialog");
		DialogAndroidparts = MR.Inst.GetTileActionDialog("CAE_T2GoszsHQ_TileActionDialog");
		D_BeepBoop = MR.Inst.GetTileActionDialog("E99_T2ChumleysFactory_TileActionDialog");
		D_WallControl = MR.Inst.GetTileActionDialog("4F2_T2ChumleysFactory_TileActionDialog");
		D_AtTheVilla = MR.Inst.GetTileActionDialog("997_T2ChumleysFactory_TileActionDialog");
		D_AnAxe = MR.Inst.GetTileActionDialog("546_T2ChumleysFactory_TestingControlBay_TileActionDialog");
		D_TheresBlood = MR.Inst.GetTileActionDialog("78F_T2ChumleysFactory_TestingControlBay_TileActionDialog");
		I_BackToFactoryINT = MR.Inst.GetTileActionInteraction("DEA_T2ChumleysFactory_TestingControlBay_TileActionInteraction");
		ambient_WillaDeepBreath = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/AmbientWillaDeepBreath");
		ambient_GoszIsWaiting = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/Ambient_GoszIsWaiting");
		dialog_Compassionate = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogCompassionate");
		dialog_CompThenComp = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogCompThenComp");
		dialog_CompThenHon = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogCompThenHon");
		dialog_Honest = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogHonest");
		dialog_HonThenComp = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogHonThenComp");
		dialog_HonThenHon = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogHonThenHon");
		dialog_SorryAboutYourFarther = HAGIS.DialogLoad("Dialogs/A2O3/GoszsHQ/DialogSorryAboutYourFarther");
		ambient_GoszTrail = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryExterior/AmbientGoszTrail");
		dialog_CravensPlan = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryExterior/DialogCravensPlan");
		dialog_CravensPlanCont = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryExterior/DialogCravensPlanCont");
		dialog_MagnumOpus = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryInterior/DialogMagnumOpus");
		dialog_AugmentCrisis = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryInterior/DialogAugmentCrisis");
		dialog_WillaImpressed = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryInterior/DialogWillaImpressed");
		ambient_CheckTheView = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryInterior/AmbientCheckTheView");
		dialog_WhatsTheRush = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactoryInterior/DialogWhatsTheRush");
		ambient_KeepThisSafe = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientKeepThisSafe");
		ambient_HitWilla = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientHitWilla");
		ambient_TwoKOs = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientTwoKOs");
		ambient_OtherFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientOtherFirstHit");
		dialog_FailedRound1 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogFailedRound1");
		ambient_WonRound1 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientWonRound1");
		ambient_WonRound2 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientWonRound2");
		ambient_WonRound3 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientWonRound3");
		ambient_WonRound4 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientWonRound4");
		dialog_ContinueToRound2 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogContinueToRound2");
		dialog_ContinueToRound3 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogContinueToRound3");
		dialog_ContinueToRound4 = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogContinueToRound4");
		ambient_WillaFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientHitWilla");
		dialog_TestComplete = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogTestComplete");
		ambient_FirstKO = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientFirstKO");
		dialog_NeverGetsOld = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/DialogNeverGetsOld");
		ambient_QADepartment = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientQADepartment");
		ambient_Sentient = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientSentient");
		ambient_GoszTrick = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientGoszTrick");
		string coverAnimator = "MA_Cover";
		TL1 = MR.Inst.GetTileBlockDynamic("857_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TL2 = MR.Inst.GetTileBlockDynamic("EAB_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TL3 = MR.Inst.GetTileBlockDynamic("90F_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM1 = MR.Inst.GetTileBlockDynamic("C31_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM2 = MR.Inst.GetTileBlockDynamic("35C_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM3 = MR.Inst.GetTileBlockDynamic("CE7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR1 = MR.Inst.GetTileBlockDynamic("89B_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR2 = MR.Inst.GetTileBlockDynamic("9E5_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR3 = MR.Inst.GetTileBlockDynamic("1E9_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL1 = MR.Inst.GetTileBlockDynamic("36F_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL2 = MR.Inst.GetTileBlockDynamic("6D0_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL3 = MR.Inst.GetTileBlockDynamic("8FF_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM1 = MR.Inst.GetTileBlockDynamic("B95_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM2 = MR.Inst.GetTileBlockDynamic("9D7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM3 = MR.Inst.GetTileBlockDynamic("6F2_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR1 = MR.Inst.GetTileBlockDynamic("5C6_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR2 = MR.Inst.GetTileBlockDynamic("643_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR3 = MR.Inst.GetTileBlockDynamic("67E_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M1 = MR.Inst.GetTileBlockDynamic("D24_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M2 = MR.Inst.GetTileBlockDynamic("2D7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M3 = MR.Inst.GetTileBlockDynamic("AA5_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R1 = MR.Inst.GetTileBlockDynamic("D48_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R2 = MR.Inst.GetTileBlockDynamic("A7E_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R3 = MR.Inst.GetTileBlockDynamic("8CB_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DD1 = MR.Inst.GetTileBlockDynamic("897_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DD2 = MR.Inst.GetTileBlockDynamic("192_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DD3 = MR.Inst.GetTileBlockDynamic("53B_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DD4 = MR.Inst.GetTileBlockDynamic("3D4_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		ToTestBay.gameObject.SetActive(value: false);
		RobotRunner1.gameObject.SetActive(value: false);
		RobotRunner2.gameObject.SetActive(value: false);
		RobotRunner3.gameObject.SetActive(value: false);
		RobotSoldier.gameObject.SetActive(value: false);
		RobotMuscle1.gameObject.SetActive(value: false);
		RobotMuscle2.gameObject.SetActive(value: false);
		RobotTrigger.gameObject.SetActive(value: false);
		RobotProgrammer.gameObject.SetActive(value: false);
		UVitaSoftMuscle.gameObject.SetActive(value: false);
		D_AnAxe.gameObject.SetActive(value: false);
		D_TheresBlood.gameObject.SetActive(value: false);
		D_AtTheVilla.gameObject.SetActive(value: false);
		I_BackToFactoryINT.gameObject.SetActive(value: false);
		ToMain.gameObject.SetActive(value: false);
		Dynamicblock.gameObject.SetActive(value: false);
		R1.gameObject.SetActive(value: false);
		R2.gameObject.SetActive(value: false);
		R3.gameObject.SetActive(value: false);
		TL1.gameObject.SetActive(value: false);
		TL2.gameObject.SetActive(value: false);
		TL3.gameObject.SetActive(value: false);
		TM1.gameObject.SetActive(value: false);
		TM2.gameObject.SetActive(value: false);
		TM3.gameObject.SetActive(value: false);
		TR1.gameObject.SetActive(value: false);
		TR2.gameObject.SetActive(value: false);
		TR3.gameObject.SetActive(value: false);
		BM1.gameObject.SetActive(value: false);
		BM2.gameObject.SetActive(value: false);
		BM3.gameObject.SetActive(value: false);
		BR1.gameObject.SetActive(value: false);
		BR2.gameObject.SetActive(value: false);
		BR3.gameObject.SetActive(value: false);
		M1.gameObject.SetActive(value: false);
		M2.gameObject.SetActive(value: false);
		M3.gameObject.SetActive(value: false);
		ToGozsHQ.gameObject.SetActive(value: false);
		FromExterior.gameObject.SetActive(value: false);
		ToTestBay.gameObject.SetActive(value: false);
		ToFactoryEXT.gameObject.SetActive(value: false);
		ToPlantInterior.gameObject.SetActive(value: false);
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalkSlow");
		PlayMapAnimation(ChumleysExterior.Map, "MA_HiddenStatueDoor", "AlreadyOpen");
		yield return null;
		MusicStop();
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_WillaDeepBreath);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(dialog_SorryAboutYourFarther);
		if (HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_A))
		{
			yield return HAGIS.DialogShow(dialog_Honest);
		}
		else
		{
			yield return HAGIS.DialogShow(dialog_Compassionate);
		}
		bool HonSect1 = HAGIS.WasHonestThroughoutSection(DC.GameSection.ONE);
		bool HonSect2 = HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_A);
		if (!HonSect1 && !HonSect2)
		{
			yield return HAGIS.DialogShow(dialog_CompThenComp);
		}
		else if (!HonSect1 && HonSect2)
		{
			yield return HAGIS.DialogShow(dialog_CompThenHon);
		}
		else if (HonSect1 && !HonSect2)
		{
			yield return HAGIS.DialogShow(dialog_HonThenComp);
		}
		else if (HonSect1 && HonSect2)
		{
			yield return HAGIS.DialogShow(dialog_HonThenHon);
		}
		yield return Willa.unitModel.Play("CsTransDefeatedToDIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.UpdateIdleAnim();
		yield return null;
		CutsceneEnd();
		ToFactoryEXT.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/basic/stealth old 1");
		yield return HAGIS.DialogShow(ambient_GoszIsWaiting);
		yield return MapWaitUntilVisible(ChumleysExterior.Map);
		MusicStop();
		CutsceneBegin();
		UnitMoveToTarget(Willa, TargetWillaPE);
		UnitMoveToTarget(TeamMember2, TargetArchiPE);
		yield return UnitMoveToTarget(TeamMember3, TargetChrisPE);
		Willa.LookAt(Gosz);
		TeamMember2.LookAt(Gosz);
		TeamMember3.LookAt(Gosz);
		yield return HAGIS.DialogShow(ambient_GoszTrail);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEnter);
		yield return UnitMoveToMapViaExitTile(Gosz, ToPlantInterior, TargetGoszCI);
		CutsceneEnd();
		ToPlantInterior.gameObject.SetActive(value: true);
		SKIP_POINT("Skip convo with Gosz");
		TeamMember2.SetTeamType(UnitTeam.Type.Player);
		TeamMember3.SetTeamType(UnitTeam.Type.Player);
		yield return MapWaitUntilVisible(ChumleysInterior.Map);
		MusicPlay("event:/music/tracks/basic/chumleys theme");
		Gosz.LookInDirection(OctDir.Down);
		UIObjectives.Inst.CompleteObjective(objEnter);
		yield return HAGIS.DialogShow(ambient_CheckTheView);
		Gosz.LookInDirection(OctDir.Up);
		yield return CreateTriggerCondition(dialog_WillaImpressed.OnComplete);
		CutsceneBegin();
		Willa.LookInDirection(OctDir.Right);
		Gosz.LookInDirection(OctDir.Left);
		yield return HAGIS.DialogShow(dialog_MagnumOpus);
		Gosz.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		DialogWhatsTheRush.gameObject.SetActive(value: false);
		DialogImpressed.gameObject.SetActive(value: false);
		ToTestBay.gameObject.SetActive(value: true);
		UnitMoveToMapViaExitTile(Gosz, ToTestBay, TargetGoszTB1);
		D_BeepBoop.gameObject.SetActive(value: false);
		D_WallControl.gameObject.SetActive(value: false);
		CutsceneEnd();
		SKIP_POINT("Skip convo in main area");
		PlayMapAnimation(ChumleysTestbay.Map, coverAnimator, "InstantEmpty");
		yield return MapWaitUntilVisible(ChumleysTestbay.Map);
		MusicStop();
		CutsceneBegin();
		Gosz.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(ambient_QADepartment);
		UnitMoveToTarget(TeamMember2, TargetArchiTB);
		UnitMoveToTarget(Willa, TargetWillaTB);
		yield return UnitMoveToTarget(TeamMember3, TargetChrisTB);
		yield return HAGIS.DialogShow(ambient_HitWilla);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTest);
		yield return CreateTimeCondition(3f);
		yield return HAGIS.DialogShow(ambient_KeepThisSafe);
		Dynamicblock.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Skip to start of first fight");
		MusicPlay("event:/music/tracks/combat/droid combat");
		int tries = 0;
		while (true)
		{
			CutsceneBegin();
			yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Open");
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Open");
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Open");
			DD1.gameObject.SetActive(value: false);
			DD2.gameObject.SetActive(value: false);
			DD3.gameObject.SetActive(value: false);
			yield return CreateTimeCondition(0.5f);
			RobotRunner1.gameObject.SetActive(value: true);
			RobotRunner2.gameObject.SetActive(value: true);
			RobotRunner3.gameObject.SetActive(value: true);
			UnitMoveToTarget(TeamMember2, TargetArchiTB);
			UnitMoveToTarget(Willa, TargetWillaTB);
			UnitMoveToTarget(TeamMember3, TargetChrisTB);
			UnitMoveToTarget(RobotRunner1, targetProgrammer);
			UnitMoveToTarget(RobotRunner2, targetRunner2);
			yield return UnitMoveToTarget(RobotRunner3, targetMuscle1);
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Close");
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Close");
			PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Close");
			DD2.gameObject.SetActive(value: true);
			DD3.gameObject.SetActive(value: true);
			DD4.gameObject.SetActive(value: true);
			if (tries == 0)
			{
				PlayMapAnimation(ChumleysTestbay.Map, coverAnimator, "EmptyToWave2");
			}
			SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
			TL1.gameObject.SetActive(value: true);
			TL2.gameObject.SetActive(value: true);
			TL3.gameObject.SetActive(value: true);
			TM1.gameObject.SetActive(value: true);
			TM2.gameObject.SetActive(value: true);
			TM3.gameObject.SetActive(value: true);
			TR1.gameObject.SetActive(value: true);
			TR2.gameObject.SetActive(value: true);
			TR3.gameObject.SetActive(value: true);
			TileBlockDynamic tL = TL1;
			TileObjectBase.Height height = TileObjectBase.Height.Full;
			TL3.BlockHeight = height;
			height = height;
			TL2.BlockHeight = height;
			tL.BlockHeight = height;
			TileBlockDynamic tM = TM1;
			height = TileObjectBase.Height.Full;
			TM3.BlockHeight = height;
			height = height;
			TM2.BlockHeight = height;
			tM.BlockHeight = height;
			TileBlockDynamic tR = TR1;
			height = TileObjectBase.Height.Full;
			TR2.BlockHeight = height;
			height = height;
			TR3.BlockHeight = height;
			tR.BlockHeight = height;
			BL1.gameObject.SetActive(value: true);
			BL2.gameObject.SetActive(value: true);
			BL3.gameObject.SetActive(value: true);
			BM1.gameObject.SetActive(value: true);
			BM2.gameObject.SetActive(value: true);
			BM3.gameObject.SetActive(value: true);
			BR1.gameObject.SetActive(value: true);
			BR2.gameObject.SetActive(value: true);
			BR3.gameObject.SetActive(value: true);
			TileBlockDynamic bL = BL1;
			height = TileObjectBase.Height.Full;
			BL3.BlockHeight = height;
			height = height;
			BL2.BlockHeight = height;
			bL.BlockHeight = height;
			TileBlockDynamic bM = BM1;
			height = TileObjectBase.Height.Full;
			BM3.BlockHeight = height;
			height = height;
			BM2.BlockHeight = height;
			bM.BlockHeight = height;
			TileBlockDynamic bR = BR1;
			height = TileObjectBase.Height.Full;
			BR2.BlockHeight = height;
			height = height;
			BR3.BlockHeight = height;
			bR.BlockHeight = height;
			R1.gameObject.SetActive(value: true);
			R2.gameObject.SetActive(value: true);
			R3.gameObject.SetActive(value: true);
			TileBlockDynamic r = R1;
			height = TileObjectBase.Height.Full;
			R3.BlockHeight = height;
			height = height;
			R2.BlockHeight = height;
			r.BlockHeight = height;
			CutsceneEnd();
			CombatBegin(UnitTeam.Type.Player);
			while (true)
			{
				HagletYieldTerm combatCompleted = CreateTriggerCondition(CombatWaitUntilComplete());
				yield return CreateOrCondition(combatCompleted, Willa.OnDeathComplete, TeamMember3.OnDeathComplete, TeamMember2.OnDeathComplete);
				if (!SaveData.SplitPoint(combatCompleted.met, skipOverride: true))
				{
					if (SaveData.SplitPoint(SizeOfPlayerTeam() > 1))
					{
						continue;
					}
					yield return EndTurnMode();
					CutsceneBegin();
					HAGIS.DialogShow(ambient_TwoKOs);
					yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
					RobotRunner1.Kill();
					RobotRunner2.Kill();
					RobotRunner3.Kill();
					yield return Wait.ForChildren;
					CutsceneEnd();
					int num;
					tries = (num = tries + 1);
					if (num < 3)
					{
						yield return HAGIS.DialogShow(dialog_FailedRound1);
						if (SaveData.SplitPoint(dialog_FailedRound1.currentResponseLine == 1, skipOverride: false))
						{
							break;
						}
					}
				}
				else
				{
					CutsceneBegin();
					MusicStop();
					yield return HAGIS.DialogShow(dialog_ContinueToRound2);
					CutsceneEnd();
					if (!SaveData.SplitPoint(dialog_ContinueToRound2.currentResponseLine == 2, skipOverride: false))
					{
						MusicPlay("event:/music/tracks/combat/droid combat");
						int tries2 = 0;
						do
						{
							CutsceneBegin();
							ReviveAndHeal(TeamMember2);
							ReviveAndHeal(TeamMember3);
							ReviveAndHeal(Willa);
							RobotRunner1.HPRefill();
							RobotRunner2.HPRefill();
							RobotRunner3.HPRefill();
							yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
							PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Open");
							PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_04", "Open");
							DD4.gameObject.SetActive(value: false);
							DD2.gameObject.SetActive(value: false);
							yield return CreateTimeCondition(0.5f);
							yield return RobotRunner1.SetCoord(TargetRobot3.GetCoord());
							yield return RobotRunner2.SetCoord(TargetRobot2.GetCoord());
							yield return RobotRunner3.SetCoord(TargetRobot1.GetCoord());
							RobotProgrammer.gameObject.SetActive(value: true);
							RobotTrigger.gameObject.SetActive(value: true);
							UnitMoveToTarget(TeamMember2, TargetArchiTB);
							UnitMoveToTarget(Willa, TargetWillaTB);
							UnitMoveToTarget(TeamMember3, TargetChrisTB);
							UnitMoveToTarget(RobotProgrammer, targetRunner3, null, 5f);
							yield return CreateTimeCondition(1f);
							UVitaSoftMuscle.gameObject.SetActive(value: true);
							UnitMoveToTarget(UVitaSoftMuscle, targetRunner2);
							yield return UnitMoveToTarget(RobotTrigger, targetMuscle1);
							PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Close");
							PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_04", "Close");
							DD4.gameObject.SetActive(value: true);
							DD2.gameObject.SetActive(value: true);
							if (tries2 == 0)
							{
								PlayMapAnimation(ChumleysTestbay.Map, coverAnimator, "Wave2ToWave3");
							}
							SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
							TileBlockDynamic tL2 = TL1;
							height = TileObjectBase.Height.Half;
							TL3.BlockHeight = height;
							height = height;
							TL2.BlockHeight = height;
							tL2.BlockHeight = height;
							TileBlockDynamic tM2 = TM1;
							height = TileObjectBase.Height.Half;
							TM3.BlockHeight = height;
							height = height;
							TM2.BlockHeight = height;
							tM2.BlockHeight = height;
							TileBlockDynamic tR2 = TR1;
							height = TileObjectBase.Height.Half;
							TR2.BlockHeight = height;
							height = height;
							TR3.BlockHeight = height;
							tR2.BlockHeight = height;
							M1.gameObject.SetActive(value: true);
							M2.gameObject.SetActive(value: true);
							M3.gameObject.SetActive(value: true);
							TileBlockDynamic m = M1;
							height = TileObjectBase.Height.Full;
							M3.BlockHeight = height;
							height = height;
							M2.BlockHeight = height;
							m.BlockHeight = height;
							TileBlockDynamic bL2 = BL1;
							height = TileObjectBase.Height.Half;
							BL3.BlockHeight = height;
							height = height;
							BL2.BlockHeight = height;
							bL2.BlockHeight = height;
							TileBlockDynamic bM2 = BM1;
							height = TileObjectBase.Height.Half;
							BM3.BlockHeight = height;
							height = height;
							BM2.BlockHeight = height;
							bM2.BlockHeight = height;
							TileBlockDynamic bR2 = BR1;
							height = TileObjectBase.Height.Half;
							BR2.BlockHeight = height;
							height = height;
							BR3.BlockHeight = height;
							bR2.BlockHeight = height;
							TileBlockDynamic r2 = R1;
							height = TileObjectBase.Height.Half;
							R3.BlockHeight = height;
							height = height;
							R2.BlockHeight = height;
							r2.BlockHeight = height;
							CutsceneEnd();
							CombatBegin(UnitTeam.Type.Player);
							while (true)
							{
								HagletYieldTerm combatCompleted2 = CreateTriggerCondition(CombatWaitUntilComplete());
								yield return CreateOrCondition(combatCompleted2, Willa.OnDeathComplete, TeamMember3.OnDeathComplete, TeamMember2.OnDeathComplete);
								if (SaveData.SplitPoint(combatCompleted2.met, skipOverride: true))
								{
									break;
								}
								if (SaveData.SplitPoint(SizeOfPlayerTeam() > 1))
								{
									continue;
								}
								goto IL_2cb0;
							}
							CutsceneBegin();
							MusicStop();
							yield return HAGIS.DialogShow(dialog_ContinueToRound4);
							CutsceneEnd();
							if (SaveData.SplitPoint(dialog_ContinueToRound4.currentResponseLine == 2, skipOverride: false))
							{
								break;
							}
							MusicPlay("event:/music/tracks/combat/droid combat");
							int tries3 = 0;
							int num;
							do
							{
								CutsceneBegin();
								ReviveAndHeal(TeamMember2);
								ReviveAndHeal(TeamMember3);
								ReviveAndHeal(Willa);
								yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Open");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Open");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Open");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_04", "Open");
								DD1.gameObject.SetActive(value: false);
								DD2.gameObject.SetActive(value: false);
								DD3.gameObject.SetActive(value: false);
								DD4.gameObject.SetActive(value: false);
								yield return CreateTimeCondition(0.5f);
								yield return RobotMuscle1.SetCoord(TargetRobot4.GetCoord());
								yield return RobotMuscle2.SetCoord(TargetRobot1.GetCoord());
								yield return RobotSoldier.SetCoord(TargetRobot2.GetCoord());
								yield return RobotTrigger.SetCoord(TargetRobot3.GetCoord());
								ReviveAndHeal(RobotMuscle1);
								ReviveAndHeal(RobotMuscle2);
								ReviveAndHeal(RobotSoldier);
								ReviveAndHeal(RobotTrigger);
								yield return null;
								RobotMuscle1.gameObject.SetActive(value: true);
								RobotMuscle2.gameObject.SetActive(value: true);
								RobotSoldier.gameObject.SetActive(value: true);
								RobotTrigger.gameObject.SetActive(value: true);
								UnitMoveToTarget(RobotMuscle1, targetMuscle2);
								UnitMoveToTarget(RobotMuscle2, targetRunner3);
								UnitMoveToTarget(RobotSoldier, targetSoldier);
								yield return UnitMoveToTarget(RobotTrigger, targetRunner1);
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Close");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Close");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Close");
								PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_04", "Close");
								DD1.gameObject.SetActive(value: true);
								DD2.gameObject.SetActive(value: true);
								DD3.gameObject.SetActive(value: true);
								DD4.gameObject.SetActive(value: true);
								if (tries3 == 0)
								{
									PlayMapAnimation(ChumleysTestbay.Map, coverAnimator, "Wave3ToWave4");
								}
								SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
								TileBlockDynamic tL3 = TL1;
								height = TileObjectBase.Height.Full;
								TL3.BlockHeight = height;
								tL3.BlockHeight = height;
								TL2.BlockHeight = TileObjectBase.Height.Half;
								TileBlockDynamic tM3 = TM1;
								height = TileObjectBase.Height.Half;
								TM3.BlockHeight = height;
								height = height;
								TM2.BlockHeight = height;
								tM3.BlockHeight = height;
								TileBlockDynamic tR3 = TR1;
								height = TileObjectBase.Height.Full;
								TR3.BlockHeight = height;
								tR3.BlockHeight = height;
								TR2.BlockHeight = TileObjectBase.Height.Half;
								M1.gameObject.SetActive(value: false);
								M2.gameObject.SetActive(value: false);
								M3.gameObject.SetActive(value: false);
								TileBlockDynamic m2 = M1;
								height = TileObjectBase.Height.Zero;
								M3.BlockHeight = height;
								height = height;
								M2.BlockHeight = height;
								m2.BlockHeight = height;
								TileBlockDynamic bL3 = BL1;
								height = TileObjectBase.Height.Half;
								BL3.BlockHeight = height;
								height = height;
								BL2.BlockHeight = height;
								bL3.BlockHeight = height;
								TileBlockDynamic bM3 = BM1;
								height = TileObjectBase.Height.Full;
								BM3.BlockHeight = height;
								height = height;
								BM2.BlockHeight = height;
								bM3.BlockHeight = height;
								TileBlockDynamic bR3 = BR1;
								height = TileObjectBase.Height.Half;
								BR3.BlockHeight = height;
								bR3.BlockHeight = height;
								BR2.BlockHeight = TileObjectBase.Height.Full;
								TileBlockDynamic r3 = R1;
								height = TileObjectBase.Height.Full;
								R3.BlockHeight = height;
								height = height;
								R2.BlockHeight = height;
								r3.BlockHeight = height;
								CutsceneEnd();
								CombatBegin(UnitTeam.Type.Player);
								while (true)
								{
									HagletYieldTerm combatCompleted3 = CreateTriggerCondition(CombatWaitUntilComplete());
									yield return CreateOrCondition(combatCompleted3, Willa.OnDeathComplete, TeamMember3.OnDeathComplete, TeamMember2.OnDeathComplete);
									if (SaveData.SplitPoint(combatCompleted3.met, skipOverride: true))
									{
										break;
									}
									if (SaveData.SplitPoint(SizeOfPlayerTeam() > 1))
									{
										continue;
									}
									goto IL_36d9;
								}
								CutsceneBegin();
								RobotMuscle2.Revive();
								RobotSoldier.Revive();
								RobotMuscle1.Revive();
								RobotTrigger.Revive();
								RobotMuscle2.gameObject.SetActive(value: false);
								RobotSoldier.gameObject.SetActive(value: false);
								RobotMuscle1.gameObject.SetActive(value: false);
								RobotTrigger.gameObject.SetActive(value: false);
								UnitMoveToTarget(RobotMuscle2, TargetRobot1);
								UnitMoveToTarget(RobotSoldier, TargetRobot2);
								UnitMoveToTarget(RobotMuscle1, TargetRobot3);
								UnitMoveToTarget(RobotTrigger, TargetRobot4);
								yield return null;
								HAGIS.DialogShow(ambient_WonRound4);
								yield return CreateTriggerCondition(ambient_WonRound4.OnComplete);
								CutsceneEnd();
								MusicStop();
								break;
								IL_36d9:
								yield return EndTurnMode();
								CutsceneBegin();
								HAGIS.DialogShow(ambient_TwoKOs);
								yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
								RobotMuscle1.Kill();
								RobotMuscle2.Kill();
								RobotSoldier.Kill();
								RobotTrigger.Kill();
								yield return Wait.ForChildren;
								CutsceneEnd();
								tries3 = (num = tries3 + 1);
								if (num < 3)
								{
									yield return HAGIS.DialogShow(dialog_FailedRound1);
									continue;
								}
								break;
							}
							while (SaveData.SplitPoint(dialog_FailedRound1.currentResponseLine == 1, skipOverride: false));
							break;
							IL_2cb0:
							yield return EndTurnMode();
							CutsceneBegin();
							HAGIS.DialogShow(ambient_TwoKOs);
							yield return Gosz.unitModel.Play("CsDefaultChumleysInteract");
							RobotProgrammer.Kill();
							UVitaSoftMuscle.Kill();
							RobotTrigger.Kill();
							yield return Wait.ForChildren;
							CutsceneEnd();
							tries2 = (num = tries2 + 1);
							if (num < 3)
							{
								yield return HAGIS.DialogShow(dialog_FailedRound1);
								continue;
							}
							break;
						}
						while (SaveData.SplitPoint(dialog_FailedRound1.currentResponseLine == 1, skipOverride: false));
					}
				}
				PlayMapAnimation(ChumleysTestbay.Map, coverAnimator, "Wave4ToEmpty");
				SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
				TileBlockDynamic tL4 = TL1;
				height = TileObjectBase.Height.Zero;
				TL3.BlockHeight = height;
				height = height;
				TL2.BlockHeight = height;
				tL4.BlockHeight = height;
				TileBlockDynamic tM4 = TM1;
				height = TileObjectBase.Height.Zero;
				TM3.BlockHeight = height;
				height = height;
				TM2.BlockHeight = height;
				tM4.BlockHeight = height;
				TileBlockDynamic tR4 = TR1;
				height = TileObjectBase.Height.Zero;
				TR2.BlockHeight = height;
				height = height;
				TR3.BlockHeight = height;
				tR4.BlockHeight = height;
				TileBlockDynamic m3 = M1;
				height = TileObjectBase.Height.Zero;
				M3.BlockHeight = height;
				height = height;
				M2.BlockHeight = height;
				m3.BlockHeight = height;
				TileBlockDynamic bL4 = BL1;
				height = TileObjectBase.Height.Zero;
				BL3.BlockHeight = height;
				height = height;
				BL2.BlockHeight = height;
				bL4.BlockHeight = height;
				TileBlockDynamic bM4 = BM1;
				height = TileObjectBase.Height.Zero;
				BM3.BlockHeight = height;
				height = height;
				BM2.BlockHeight = height;
				bM4.BlockHeight = height;
				TileBlockDynamic bR4 = BR1;
				height = TileObjectBase.Height.Zero;
				BR2.BlockHeight = height;
				height = height;
				BR3.BlockHeight = height;
				bR4.BlockHeight = height;
				TileBlockDynamic r4 = R1;
				height = TileObjectBase.Height.Zero;
				R3.BlockHeight = height;
				height = height;
				R2.BlockHeight = height;
				r4.BlockHeight = height;
				TL1.gameObject.SetActive(value: false);
				TL2.gameObject.SetActive(value: false);
				TL3.gameObject.SetActive(value: false);
				TM1.gameObject.SetActive(value: false);
				TM2.gameObject.SetActive(value: false);
				TM3.gameObject.SetActive(value: false);
				TR1.gameObject.SetActive(value: false);
				TR2.gameObject.SetActive(value: false);
				TR3.gameObject.SetActive(value: false);
				M1.gameObject.SetActive(value: false);
				M2.gameObject.SetActive(value: false);
				M3.gameObject.SetActive(value: false);
				R1.gameObject.SetActive(value: false);
				R2.gameObject.SetActive(value: false);
				R3.gameObject.SetActive(value: false);
				BL1.gameObject.SetActive(value: false);
				BL2.gameObject.SetActive(value: false);
				BL3.gameObject.SetActive(value: false);
				BM1.gameObject.SetActive(value: false);
				BM2.gameObject.SetActive(value: false);
				BM3.gameObject.SetActive(value: false);
				BR1.gameObject.SetActive(value: false);
				BR2.gameObject.SetActive(value: false);
				BR3.gameObject.SetActive(value: false);
				SKIP_POINT("Skip to start of testbay cutscene");
				CutsceneBegin();
				yield return HAGIS.DialogShow(ambient_GoszTrick);
				HAGIS.DialogShow(ambient_Sentient);
				UnitMoveToTarget(TeamMember3, TargetChrisTB);
				UnitMoveToTarget(TeamMember2, TargetArchiTB);
				yield return CreateAndCondition(UnitPlayAnimation(TeamMember3, "TransDIdleToCIdle"), UnitPlayAnimation(TeamMember2, "TransDIdleToCIdle"), UnitPlayAnimation(Willa, "TransDIdleToCIdle"));
				UnitPlayAnimation(TeamMember3, "CombatIdle", loop: true);
				UnitPlayAnimation(TeamMember2, "CombatIdle", loop: true);
				UnitPlayAnimation(Willa, "CombatIdle", loop: true);
				ReviveAndHeal(RobotMuscle2);
				ReviveAndHeal(RobotSoldier);
				ReviveAndHeal(RobotMuscle1);
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Open");
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Open");
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Open");
				DD1.gameObject.SetActive(value: false);
				DD2.gameObject.SetActive(value: false);
				DD3.gameObject.SetActive(value: false);
				yield return CreateTimeCondition(0.5f);
				yield return RobotMuscle2.SetCoord(TargetRobot1.GetCoord());
				yield return RobotSoldier.SetCoord(TargetRobot2.GetCoord());
				yield return RobotMuscle1.SetCoord(TargetRobot3.GetCoord());
				RobotSoldier.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
				RobotMuscle2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
				RobotSoldier.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
				RobotSoldier.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
				RobotMuscle1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
				RobotMuscle1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
				RobotMuscle1.UpdateIdleAnim();
				RobotMuscle2.UpdateIdleAnim();
				RobotSoldier.UpdateIdleAnim();
				RobotMuscle1.gameObject.SetActive(value: true);
				RobotSoldier.gameObject.SetActive(value: true);
				RobotMuscle2.gameObject.SetActive(value: true);
				HAGIS_A2O3 hAGIS_A2O = this;
				Unit robotMuscle = RobotMuscle1;
				UnitTarget target = targetRobotCutscene1;
				float? speed = RobotMuscle1.charData.movementSpeedInCombat;
				hAGIS_A2O.UnitMoveToTarget(robotMuscle, target, null, speed);
				HAGIS_A2O3 hAGIS_A2O2 = this;
				robotMuscle = RobotSoldier;
				target = targetRobotCutscene2;
				speed = RobotSoldier.charData.movementSpeedInCombat;
				hAGIS_A2O2.UnitMoveToTarget(robotMuscle, target, null, speed);
				HAGIS_A2O3 hAGIS_A2O3 = this;
				robotMuscle = RobotMuscle2;
				target = targetRobotCutscene3;
				speed = RobotMuscle2.charData.movementSpeedInCombat;
				yield return hAGIS_A2O3.UnitMoveToTarget(robotMuscle, target, null, speed);
				RobotMuscle1.LookAt(Willa);
				RobotSoldier.LookAt(TeamMember2);
				RobotMuscle2.LookAt(TeamMember3);
				yield return CreateTimeCondition(3f);
				yield return CreateAndCondition(UnitPlayAnimation(RobotMuscle1, "TransCIdleToDIdle"), UnitPlayAnimation(RobotSoldier, "TransCIdleToDIdle"), UnitPlayAnimation(RobotMuscle2, "TransCIdleToDIdle"));
				yield return CreateAndCondition(UnitPlayAnimation(RobotMuscle1, "DefaultConfusion"), UnitPlayAnimation(RobotSoldier, "DefaultConfusion"), UnitPlayAnimation(RobotMuscle2, "DefaultConfusion"));
				RobotMuscle1.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
				RobotMuscle1.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
				RobotMuscle2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
				RobotMuscle2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
				RobotSoldier.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
				RobotSoldier.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
				yield return UnitPlayAnimation(Willa, "TransCIdleToDIdle");
				Willa.UpdateIdleAnim();
				Willa.LookAt(Gosz);
				Gosz.LookAt(Willa);
				yield return HAGIS.DialogShow(dialog_NeverGetsOld);
				UnitMoveToTarget(RobotMuscle1, TargetRobot2);
				UnitMoveToTarget(RobotMuscle2, TargetRobot1);
				yield return UnitMoveToTarget(RobotSoldier, TargetRobot3);
				RobotRunner1.gameObject.SetActive(value: false);
				RobotRunner2.gameObject.SetActive(value: false);
				RobotRunner3.gameObject.SetActive(value: false);
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_01", "Close");
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_02", "Close");
				PlayMapAnimation(ChumleysTestbay.Map, "MA_ChumleysRobotDoors_03", "Close");
				DD1.gameObject.SetActive(value: true);
				DD2.gameObject.SetActive(value: true);
				DD3.gameObject.SetActive(value: true);
				yield return CreateAndCondition(UnitPlayAnimation(TeamMember3, "TransCIdleToDIdle"), UnitPlayAnimation(TeamMember2, "TransCIdleToDIdle"));
				TeamMember2.UpdateIdleAnim();
				TeamMember3.UpdateIdleAnim();
				MusicPlay("event:/music/tracks/exploration/techtonics");
				yield return HAGIS.DialogShow(dialog_TestComplete);
				Dynamicblock.gameObject.SetActive(value: false);
				UIObjectives.Inst.CompleteObjective(objTest);
				UnitMoveToTarget(Gosz, TargetGoszTB);
				R1.gameObject.SetActive(value: true);
				R2.gameObject.SetActive(value: true);
				R3.gameObject.SetActive(value: true);
				TL1.gameObject.SetActive(value: true);
				TL2.gameObject.SetActive(value: true);
				TL3.gameObject.SetActive(value: true);
				TM1.gameObject.SetActive(value: true);
				TM2.gameObject.SetActive(value: true);
				TM3.gameObject.SetActive(value: true);
				TR1.gameObject.SetActive(value: true);
				TR2.gameObject.SetActive(value: true);
				TR3.gameObject.SetActive(value: true);
				BL1.gameObject.SetActive(value: true);
				BL2.gameObject.SetActive(value: true);
				BL3.gameObject.SetActive(value: true);
				BM1.gameObject.SetActive(value: true);
				BM2.gameObject.SetActive(value: true);
				BM3.gameObject.SetActive(value: true);
				BR1.gameObject.SetActive(value: true);
				BR2.gameObject.SetActive(value: true);
				BR3.gameObject.SetActive(value: true);
				M1.gameObject.SetActive(value: true);
				M2.gameObject.SetActive(value: true);
				M3.gameObject.SetActive(value: true);
				CutsceneEnd();
				SKIP_POINT("Skip to end cutscene of testbay");
				D_AnAxe.gameObject.SetActive(value: true);
				D_TheresBlood.gameObject.SetActive(value: true);
				I_BackToFactoryINT.gameObject.SetActive(value: true);
				ToMain.gameObject.SetActive(value: false);
				DialogImpressed.gameObject.SetActive(value: false);
				ToTestBay.gameObject.SetActive(value: false);
				yield return CreateTriggerCondition(I_BackToFactoryINT.OnTriggered);
				CutsceneBegin();
				yield return UnitTeleportToMapViaEntranceTile(Gosz, ToTestBay, null, 5f);
				UnitMoveToTarget(Gosz, TargetGoszCI2, null, 5f);
				yield return TeamMoveToMapViaEntranceTile(ToTestBay);
				MusicPlay("event:/music/tracks/basic/chumleys theme");
				CutsceneEnd();
				CutsceneBegin();
				yield return UnitMoveToUnit(Willa, Gosz);
				ToPlantInterior.gameObject.SetActive(value: false);
				Willa.LookAt(Gosz);
				Gosz.LookAt(Willa);
				yield return HAGIS.DialogShow(dialog_AugmentCrisis);
				UIObjectives.Inst.CompleteAndSetMainObjective(objExit);
				CutsceneEnd();
				D_AtTheVilla.gameObject.SetActive(value: true);
				D_BeepBoop.gameObject.SetActive(value: true);
				D_WallControl.gameObject.SetActive(value: true);
				FromExterior.gameObject.SetActive(value: true);
				SKIP_POINT("Skip to end cutscene");
				yield return MapWaitUntilVisible(ChumleysExterior.Map);
				MusicStop();
				UIObjectives.Inst.CompleteObjective(objExit);
				CutsceneBegin();
				UnitMoveToTarget(TeamMember3, TargetSkyway);
				yield return CreateTimeCondition(0.5f);
				yield return CreateAndCondition(UnitMoveToTarget(TeamMember2, TargetSkyway), UnitMoveToTarget(Willa, TargetWillaPE));
				TeamMember2.gameObject.SetActive(value: false);
				TeamMember3.gameObject.SetActive(value: false);
				yield return HAGIS.DialogShow(dialog_CravensPlan);
				yield return HAGIS.DialogShow(dialog_CravensPlanCont);
				yield return UnitMoveToTarget(Willa, TargetSkyway);
				yield break;
			}
		}
	}
}
public class HAGIS_A2O3_ArchiChrisWillaResponse : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Chris;

	private DialogData ambient_FirstKO;

	private DialogData ambient_OtherFirstHit;

	private DialogData ambient_WillaFirstHit;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HagisLog("No more");
		Willa = GC.Inst.GetUnitWithId("0D9_T2GoszsHQ_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("AAE_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("C8A_T2ChumleysAutomatons_Exterior_UnitSpawn");
		LogicRoot ChumleysTestbay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		ambient_FirstKO = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientFirstKO");
		ambient_OtherFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientOtherFirstHit");
		ambient_WillaFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientHitWilla");
		ConstArray<Unit> TeamMembers = Willa.GetTeam().GetActiveMembers();
		yield return null;
		yield return CreateOrCondition(Archi.OnDeathComplete, Chris.OnDeathComplete, Willa.OnDeathComplete);
		yield return HAGIS.DialogShow(ambient_FirstKO);
	}
}
public class HAGIS_A2O3_ArchiChrisResponse : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Chris;

	private DialogData ambient_TwoKOs;

	private DialogData ambient_OtherFirstHit;

	private DialogData ambient_WillaFirstHit;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HagisLog("Falls");
		Willa = GC.Inst.GetUnitWithId("0D9_T2GoszsHQ_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("AAE_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("C8A_T2ChumleysAutomatons_Exterior_UnitSpawn");
		LogicRoot ChumleysTestbay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		ambient_TwoKOs = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientTwoKOs");
		ambient_OtherFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientOtherFirstHit");
		ambient_WillaFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientHitWilla");
		ConstArray<Unit> TeamMembers = Willa.GetTeam().GetActiveMembers();
		yield return null;
		yield return CreateOrCondition(Archi.OnUnitSustainedDamage, Chris.OnUnitSustainedDamage);
		yield return HAGIS.DialogShow(ambient_OtherFirstHit);
	}
}
public class HAGIS_A2O3_WillaResponse : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Chris;

	private DialogData ambient_TwoKOs;

	private DialogData ambient_OtherFirstHit;

	private DialogData ambient_WillaFirstHit;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HagisLog("Gallifrey");
		Willa = GC.Inst.GetUnitWithId("0D9_T2GoszsHQ_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("AAE_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("C8A_T2ChumleysAutomatons_Exterior_UnitSpawn");
		LogicRoot ChumleysTestbay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		ambient_TwoKOs = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientTwoKOs");
		ambient_OtherFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientOtherFirstHit");
		ambient_WillaFirstHit = HAGIS.DialogLoad("Dialogs/A2O3/ChumleysFactorytestbay/AmbientHitWilla");
		ConstArray<Unit> TeamMembers = Willa.GetTeam().GetActiveMembers();
		yield return null;
	}
}
public class HAGIS_A2O4 : HAGIS
{
	private Unit chosenCharSubLead;

	private Unit chosenCharThird;

	private Unit chosenCharLead;

	private Unit NPCArchi;

	private Unit NPCMargot;

	private Unit NPCWilla;

	private Unit NPCNoot;

	private Unit NPCAmbrosia;

	private Unit mallDroid1;

	private Unit deusoftDroid1;

	private Unit deusoftDroid2;

	private Unit deusoftDroid3;

	private Unit deusoftDroid4;

	private Unit deusoftDroid5;

	private UnitTarget chrisToLockedDoor;

	private UnitTarget chosenCharEntersMall;

	private UnitTarget triesDeusoftDoor;

	private UnitTarget stepBack;

	private UnitTarget chosenChar1EntersDS;

	private UnitTarget chosenChar2EntersDS;

	private UnitTarget chosenChar3EntersDS;

	private UnitTarget chrisHacksTibia;

	private UnitTarget chosenChar1ToTibia;

	private UnitTarget droidMuscleCover;

	private UnitTarget droidTriggerCover;

	private UnitTarget chosenChar1EntersCC;

	private UnitTarget chosenChar2EntersCC;

	private UnitTarget chosenChar3EntersCC;

	private UnitTarget chosenChar1ToWindow;

	private UnitTarget IdlePoint1;

	private UnitTarget IdlePoint2;

	private UnitTarget IdlePoint3;

	private UnitTarget MoveTo1;

	private UnitTarget MoveTo2;

	private UnitTarget MoveTo3;

	private UnitTarget MoveTo4;

	private TileActionSwapMap carparkToMall;

	private TileActionDialog shutterInteract;

	private TileActionSwapMap mallToTenorCity;

	private TileActionSwapMap mallToDeusoft;

	private TileActionSwapMap mallToCarPark;

	private TileActionInteraction fakeDeusoftDoor;

	private TileActionInteraction fakeDoor;

	private TileActionInteraction I_CustomTibia;

	private TileActionSwapMap deusoftToMall;

	private TileActionSwapMap cityCentreToMall;

	private TileActionSwapMap cityCentreToSkyway;

	private TileActionSwapMap skywayToCityCentre;

	private TileActionSwapMap skywayToFactory;

	private TileActionSwapMap ToGoszsHQ;

	private TileActionSwapMap FromSkyway;

	private TileActionSwapMap FromFactoryEXT;

	private DialogData ambient_mallsLockedDown;

	private DialogData dialog_workYourMagic;

	private DialogData ambient_openForBusiness;

	private DialogData ambient_laxSecurity;

	private DialogData ambient_LawAbidingArchi;

	private DialogData ambient_LawAbidingMargot;

	private DialogData ambient_LawAbidingNoot;

	private DialogData dialog_customTibia;

	private DialogData ambient_whewTiming;

	private DialogData ambient_moreComing;

	private DialogData ambient_getTheHellOutOfHere;

	private DialogData dialog_stillGonnaPew;

	private DialogData ambient_takeTheSkywalk;

	private DialogData AmbientDontWorry;

	private DialogData AmbientIsImagerWorking;

	private DialogData AmbientWaiting;

	private DialogData DialogAdjust;

	private DialogData DialogArchibaldWilliams;

	private DialogData DialogCantbuyAlcohol;

	private DialogData DialogMilk;

	private DialogData DialogTobacco;

	private DialogData Dialog_IfYouWanna;

	private DialogData Dialog_MakingTheCall;

	private DialogData DialogDownToOne;

	private string objEnterString = "OBJECTIVES_A2O4_01";

	private string objStealString = "OBJECTIVES_A2O4_02";

	private string objEscapeString = "OBJECTIVES_A2O4_03";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot carPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		LogicRoot cityCentreMall = GetLogicUsingArtName("T2TenorCityCentreMall");
		LogicRoot deusoftCosmetics = GetLogicUsingArtName("T2DeusoftCosmetics");
		LogicRoot tenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot FactoryExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot GoszsHQ = GetLogicUsingArtName("T2GoszsHQ");
		chosenCharSubLead = GC.Inst.GetUnitWithId("5B1_T2TheKaydockArenaCarPark_UnitSpawn");
		chosenCharThird = GC.Inst.GetUnitWithId("8F0_T2TheKaydockArenaCarPark_UnitSpawn");
		chosenCharLead = GC.Inst.GetUnitWithId("E60_T2TheKaydockArenaCarPark_UnitSpawn");
		NPCArchi = GC.Inst.GetUnitWithId("1FC_T2GoszsHQ_UnitSpawn");
		NPCMargot = GC.Inst.GetUnitWithId("DB3_T2GoszsHQ_UnitSpawn");
		NPCWilla = GC.Inst.GetUnitWithId("F01_T2GoszsHQ_UnitSpawn");
		NPCNoot = GC.Inst.GetUnitWithId("593_T2GoszsHQ_UnitSpawn");
		NPCAmbrosia = GC.Inst.GetUnitWithId("AB6_T2GoszsHQ_UnitSpawn");
		deusoftDroid1 = GC.Inst.GetUnitWithId("554_T2DeusoftCosmetics_UnitSpawn");
		deusoftDroid2 = GC.Inst.GetUnitWithId("36F_T2DeusoftCosmetics_UnitSpawn");
		deusoftDroid3 = GC.Inst.GetUnitWithId("5CC_T1VitaSoft_UnitSpawn");
		deusoftDroid4 = GC.Inst.GetUnitWithId("29E_T1VitaSoft_UnitSpawn");
		deusoftDroid5 = GC.Inst.GetUnitWithId("D6B_T1VitaSoft_UnitSpawn");
		chrisToLockedDoor = MR.Inst.GetUnitTarget("1E2_T2TheKaydockArenaCarPark_UnitTarget");
		chosenCharEntersMall = MR.Inst.GetUnitTarget("F9C_T2TenorCityCentreMall_UnitTarget");
		triesDeusoftDoor = MR.Inst.GetUnitTarget("3B4_T2TenorCityCentreMall_UnitTarget");
		stepBack = MR.Inst.GetUnitTarget("7BB_T2TenorCityCentreMall_UnitTarget");
		chosenChar1EntersDS = MR.Inst.GetUnitTarget("FD1_T2DeusoftCosmetics_UnitTarget");
		chosenChar2EntersDS = MR.Inst.GetUnitTarget("499_T1VitaSoft_UnitTarget");
		chosenChar3EntersDS = MR.Inst.GetUnitTarget("629_T2DeusoftCosmetics_UnitTarget");
		chrisHacksTibia = MR.Inst.GetUnitTarget("439_T1VitaSoft_UnitTarget");
		chosenChar1ToTibia = MR.Inst.GetUnitTarget("DD3_T1VitaSoft_UnitTarget");
		droidMuscleCover = MR.Inst.GetUnitTarget("AED_T1VitaSoft_UnitTarget");
		droidTriggerCover = MR.Inst.GetUnitTarget("011_T1VitaSoft_UnitTarget");
		chosenChar1EntersCC = MR.Inst.GetUnitTarget("410_T2TenorCityCentre_UnitTarget");
		chosenChar2EntersCC = MR.Inst.GetUnitTarget("39D_T2TenorCityCentre_UnitTarget");
		chosenChar3EntersCC = MR.Inst.GetUnitTarget("F88_T2TenorCityCentre_UnitTarget");
		chosenChar1ToWindow = MR.Inst.GetUnitTarget("AB2_T2Skyway_UnitTarget");
		UnitTarget sfx_chris_unlocks_cabinet = MR.Inst.GetUnitTarget("439_T1VitaSoft_UnitTarget");
		UnitTarget sfx_imager_picked_up = MR.Inst.GetUnitTarget("439_T1VitaSoft_UnitTarget");
		UnitTarget sfx_chris_takes_out_imager = MR.Inst.GetUnitTarget("394_T2GoszsHQ_UnitTarget");
		IdlePoint1 = MR.Inst.GetUnitTarget("94C_T2ChumleysAutomatons_Exterior_UnitTarget");
		IdlePoint2 = MR.Inst.GetUnitTarget("A07_T2ChumleysAutomatons_Exterior_UnitTarget");
		IdlePoint3 = MR.Inst.GetUnitTarget("DA5_T2ChumleysAutomatons_Exterior_UnitTarget");
		MoveTo1 = MR.Inst.GetUnitTarget("6D0_T2GoszsHQ_UnitTarget");
		MoveTo2 = MR.Inst.GetUnitTarget("FBF_T2GoszsHQ_UnitTarget");
		MoveTo3 = MR.Inst.GetUnitTarget("394_T2GoszsHQ_UnitTarget");
		MoveTo4 = MR.Inst.GetUnitTarget("BE5_T2GoszsHQ_UnitTarget");
		carparkToMall = MR.Inst.GetTileActionSwapMap("202_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		mallToTenorCity = MR.Inst.GetTileActionSwapMap("FB0_T2TenorCityCentreMall_TileActionSwapMap");
		mallToDeusoft = MR.Inst.GetTileActionSwapMap("729_T2TenorCityCentreMall_TileActionSwapMap");
		mallToCarPark = MR.Inst.GetTileActionSwapMap("172_T2TenorCityCentreMall_TileActionSwapMap");
		deusoftToMall = MR.Inst.GetTileActionSwapMap("CF1_T2DeusoftCosmetics_TileActionSwapMap");
		cityCentreToMall = MR.Inst.GetTileActionSwapMap("4FA_T2TenorCityCentre_TileActionSwapMap");
		cityCentreToSkyway = MR.Inst.GetTileActionSwapMap("99E_T2TenorCityCentre_TileActionSwapMap");
		skywayToCityCentre = MR.Inst.GetTileActionSwapMap("489_T2Skyway_TileActionSwapMap");
		skywayToFactory = MR.Inst.GetTileActionSwapMap("6DC_T2Skyway_TileActionSwapMap");
		ToGoszsHQ = MR.Inst.GetTileActionSwapMap("BDD_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		FromFactoryEXT = MR.Inst.GetTileActionSwapMap("870_T2GoszsHQ_TileActionSwapMap");
		FromSkyway = MR.Inst.GetTileActionSwapMap("2C7_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		fakeDeusoftDoor = MR.Inst.GetTileActionInteraction("E9A_T2TenorCityCentreMall_TileActionInteraction");
		fakeDoor = MR.Inst.GetTileActionInteraction("F88_T2TheKaydockArenaCarPark_TileActionInteraction");
		I_CustomTibia = MR.Inst.GetTileActionInteraction("7BC_T2DeusoftCosmetics_TileActionInteraction");
		TileActionDialog customTibiaTile = MR.Inst.GetTileActionDialog("DDE_T1VitaSoft_TileActionDialog");
		ambient_mallsLockedDown = HAGIS.DialogLoad("Dialogs/A2O4/KaydockArenaCarPark/AmbientMallsLockedDown");
		dialog_workYourMagic = HAGIS.DialogLoad("Dialogs/A2O4/KaydockArenaCarPark/DialogWorkYourMagic");
		ambient_openForBusiness = HAGIS.DialogLoad("Dialogs/A2O4/KaydockArenaCarPark/AmbientOpenForBusiness");
		ambient_laxSecurity = HAGIS.DialogLoad("Dialogs/A2O4/TenorCityCentre/AmbientLaxSecurity");
		dialog_customTibia = HAGIS.DialogLoad("Dialogs/A2O4/DeusoftCosmetics/DialogCustomTibia");
		ambient_whewTiming = HAGIS.DialogLoad("Dialogs/A2O4/DeusoftCosmetics/AmbientWhewTiming");
		ambient_moreComing = HAGIS.DialogLoad("Dialogs/A2O4/DeusoftCosmetics/AmbientMoreComing");
		ambient_getTheHellOutOfHere = HAGIS.DialogLoad("Dialogs/A2O4/DeusoftCosmetics/AmbientGetTheHellOutOfHere");
		dialog_stillGonnaPew = HAGIS.DialogLoad("Dialogs/A2O4/DeusoftCosmetics/DialogStillGonnaPew");
		ambient_takeTheSkywalk = HAGIS.DialogLoad("Dialogs/A2O4/TenorCityCentreEXT/AmbientTakeTheSkywalk");
		ambient_LawAbidingArchi = HAGIS.DialogLoad("Dialogs/A2O4/TenorCityCentre/AmbientLawAbidingArchi");
		ambient_LawAbidingMargot = HAGIS.DialogLoad("Dialogs/A2O4/TenorCityCentre/AmbientLawAbidingMargot");
		ambient_LawAbidingNoot = HAGIS.DialogLoad("Dialogs/A2O4/TenorCityCentre/AmbientLawAbidingNoot");
		AmbientDontWorry = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/AmbientDontWorry");
		AmbientIsImagerWorking = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/AmbientIsImagerWorking");
		AmbientWaiting = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/AmbientWaiting");
		DialogAdjust = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogAdjust");
		DialogArchibaldWilliams = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogArchibaldWilliams");
		DialogTobacco = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogTobacco");
		DialogMilk = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogMilk");
		DialogCantbuyAlcohol = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogCantBuyAlcohol");
		DialogDownToOne = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/DialogDownToOne");
		Dialog_IfYouWanna = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/Dialog_IfYouWanna");
		Dialog_MakingTheCall = HAGIS.DialogLoad("Dialogs/A2O4/GoszsHQ/Dialog_MakingTheCall");
		PlayMapAnimation(deusoftCosmetics.Map, "MA_DeusoftCosmetics_Augment_01", "IdleFloat");
		carparkToMall.gameObject.SetActive(value: false);
		mallToTenorCity.gameObject.SetActive(value: false);
		mallToDeusoft.gameObject.SetActive(value: false);
		deusoftDroid1.gameObject.SetActive(value: false);
		deusoftDroid2.gameObject.SetActive(value: false);
		deusoftDroid3.gameObject.SetActive(value: false);
		deusoftDroid4.gameObject.SetActive(value: false);
		deusoftDroid5.gameObject.SetActive(value: false);
		NPCArchi.gameObject.SetActive(value: false);
		NPCMargot.gameObject.SetActive(value: false);
		NPCWilla.gameObject.SetActive(value: false);
		NPCNoot.gameObject.SetActive(value: false);
		NPCAmbrosia.gameObject.SetActive(value: false);
		ToGoszsHQ.gameObject.SetActive(value: false);
		skywayToFactory.gameObject.SetActive(value: false);
		deusoftToMall.gameObject.SetActive(value: false);
		mallToCarPark.gameObject.SetActive(value: false);
		FromFactoryEXT.gameObject.SetActive(value: false);
		customTibiaTile.gameObject.SetActive(value: false);
		I_CustomTibia.gameObject.SetActive(value: false);
		PlayMapAnimation(deusoftCosmetics.Map, "MA_DeusoftCosmetics_Augment_01", "IdleFloat", loop: true);
		yield return null;
		bool yt_isArchiInParty = IsUnitInTeam(NPCArchi, UnitTeam.Type.Player);
		bool yt_isMargotInParty = IsUnitInTeam(NPCMargot, UnitTeam.Type.Player);
		bool yt_isWillaInParty = IsUnitInTeam(NPCWilla, UnitTeam.Type.Player);
		bool yt_isNootInParty = IsUnitInTeam(NPCNoot, UnitTeam.Type.Player);
		bool yt_isAmbrosiaInParty = IsUnitInTeam(NPCAmbrosia, UnitTeam.Type.Player);
		if (yt_isArchiInParty)
		{
			HagisLog("Archi is in party");
			Unit unitRef = ((!(chosenCharSubLead.charData == NPCArchi.charData)) ? chosenCharThird : chosenCharSubLead);
			DialogAdjust.dialogs[2].unitRef = unitRef;
			AmbientIsImagerWorking.dialogs[0].unitRef = unitRef;
			Dialog_IfYouWanna.dialogs[2].unitRef = unitRef;
			DialogDownToOne.dialogs[2].unitRef = unitRef;
			DialogDownToOne.dialogs[3].unitRef = unitRef;
			DialogMilk.dialogs[1].unitRef = unitRef;
		}
		if (yt_isMargotInParty)
		{
			Unit unitRef2 = ((!(chosenCharSubLead.charData == NPCMargot.charData)) ? chosenCharThird : chosenCharSubLead);
			Dialog_IfYouWanna.dialogs[1].unitRef = unitRef2;
			Dialog_IfYouWanna.dialogs[3].unitRef = unitRef2;
		}
		MusicStop();
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_mallsLockedDown);
		CutsceneEnd();
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objEnterString);
		PlayInterplay();
		yield return CreateTriggerCondition(fakeDoor.OnTriggered);
		CutsceneBegin();
		yield return HAGIS.DialogShow(dialog_workYourMagic);
		CutsceneEnd();
		yield return CutscenePlay("A2O4_Cutscene_ChrisHack");
		CutsceneBegin();
		yield return UnitMoveToMapViaExitTile(chosenCharLead, carparkToMall);
		yield return UnitMoveToMapViaExitTile(chosenCharSubLead, carparkToMall);
		yield return UnitMoveToMapViaExitTile(chosenCharThird, carparkToMall);
		CutsceneEnd();
		SKIP_POINT("skipped car park area");
		yield return MapGoto(cityCentreMall);
		yield return CreateTriggerCondition(fakeDeusoftDoor.OnTriggered);
		cityCentreMall.CanTeammatesFollow = true;
		fakeDeusoftDoor.gameObject.SetActive(value: false);
		mallToCarPark.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(ambient_laxSecurity);
		yield return HAGIS.DialogShow(ambient_LawAbidingArchi);
		SKIP_POINT("skipped getting to mall");
		yield return TeamMoveToMapViaEntranceTile(deusoftToMall);
		MusicStop();
		deusoftCosmetics.CanTeammatesFollow = true;
		UIObjectives.Inst.CompleteAndSetMainObjective(objStealString);
		I_CustomTibia.gameObject.SetActive(value: true);
		SKIP_POINT("skipped getting into Deusoft");
		ParticlePrefab BioImagerHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, I_CustomTibia.transform);
		yield return TileWaitUntilInteracted(I_CustomTibia);
		BioImagerHightlight.StopParticles();
		yield return HAGIS.DialogShow(dialog_customTibia);
		yield return CutscenePlay("A2O4_Cutscene_ChrisHack2");
		chosenCharLead.SetTeamType(UnitTeam.Type.NPC);
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return null;
		SKIP_POINT("skipped first Deusoft fight");
		MusicPlay("event:/music/tracks/basic/drone 2");
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2o4/chris unlocks cabinet", sfx_chris_unlocks_cabinet);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_whewTiming);
		chosenCharLead.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		chosenCharLead.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		yield return chosenCharLead.unitModel.Play("CsTransKneelHackToDIdle", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		chosenCharLead.unitModel.Play("DefaultReceiveItem", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return CreateTimeCondition(0.8f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o2/pick up augment", sfx_imager_picked_up);
		yield return CreateTimeCondition(0.2f);
		PlayMapAnimation(deusoftCosmetics.Map, "MA_DeusoftCosmetics_Augment_01", "TurnOff");
		UIObjectives.Inst.CompleteObjective(objStealString);
		UnitMoveToTarget(chosenCharThird, chosenChar1EntersDS);
		yield return UnitMoveToTarget(chosenCharSubLead, chosenChar2EntersDS);
		UIObjectives.Inst.CompleteAndSetMainObjective(objEscapeString);
		yield return HAGIS.DialogShow(ambient_moreComing);
		deusoftDroid3.gameObject.SetActive(value: true);
		deusoftDroid4.gameObject.SetActive(value: true);
		deusoftDroid5.gameObject.SetActive(value: true);
		UnitMoveToTarget(deusoftDroid3, droidMuscleCover);
		yield return UnitMoveToTarget(deusoftDroid4, droidTriggerCover);
		chosenCharLead.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return HAGIS.DialogShow(ambient_getTheHellOutOfHere);
		deusoftToMall.gameObject.SetActive(value: true);
		SKIP_POINT("skipped second Deusoft fight");
		yield return MapWaitUntilVisible(cityCentreMall.Map);
		UIObjectives.Inst.CompleteObjective(objEscapeString);
		mallToDeusoft.gameObject.SetActive(value: false);
		mallToTenorCity.gameObject.SetActive(value: true);
		SKIP_POINT("skipped getting to the mall");
		yield return MapWaitUntilVisible(tenorCityCentre.Map);
		CutsceneBegin();
		cityCentreToMall.gameObject.SetActive(value: false);
		cityCentreToSkyway.gameObject.SetActive(value: false);
		UnitMoveToTarget(chosenCharSubLead, chosenChar1EntersCC);
		UnitMoveToTarget(chosenCharThird, chosenChar2EntersCC);
		yield return UnitMoveToTarget(chosenCharLead, chosenChar3EntersCC);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/generic combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/exploration/additional exploration");
		tenorCityCentre.CanTeammatesFollow = true;
		cityCentreToSkyway.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(ambient_takeTheSkywalk);
		SKIP_POINT("skipped city centre combat section");
		yield return MapWaitUntilVisible(skyway.Map);
		SKIP_POINT("skipped to Skyway");
		CutsceneBegin();
		skywayToCityCentre.gameObject.SetActive(value: false);
		skywayToFactory.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(chosenCharLead, chosenChar1ToWindow);
		chosenCharLead.LookAt(chosenCharThird.gameObject.transform);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		skywayToFactory.gameObject.SetActive(value: true);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_Chumleys_L0");
		PlayMapAnimation(FactoryExterior.Map, "MA_HiddenStatueDoor", "AlreadyOpen");
		CutsceneEnd();
		skyway.CanTeammatesFollow = true;
		yield return MapWaitUntilVisible(FactoryExterior.Map);
		MusicStop();
		FactoryExterior.CanTeammatesFollow = true;
		SKIP_POINT("skipped to factory exterior");
		FromSkyway.gameObject.SetActive(value: false);
		ToGoszsHQ.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(GoszsHQ.Map);
		MusicPlay("event:/music/tracks/basic/safety in numbers 1");
		SKIP_POINT("skipped to HQ");
		if (!yt_isWillaInParty)
		{
			NPCWilla.gameObject.SetActive(value: true);
		}
		if (!yt_isMargotInParty)
		{
			HagisLog("Margot is not in party");
			NPCMargot.gameObject.SetActive(value: true);
		}
		if (!yt_isAmbrosiaInParty)
		{
			NPCAmbrosia.gameObject.SetActive(value: true);
		}
		if (!yt_isNootInParty)
		{
			NPCNoot.gameObject.SetActive(value: true);
		}
		if (!yt_isArchiInParty)
		{
			HagisLog("Archi not in party");
			NPCArchi.gameObject.SetActive(value: true);
			UnitMoveToTarget(chosenCharThird, MoveTo2);
			yield return CreateTimeCondition(0.5f);
			UnitMoveToTarget(chosenCharLead, MoveTo3);
			yield return CreateTimeCondition(0.5f);
			yield return UnitMoveToTarget(chosenCharSubLead, MoveTo1);
			chosenCharLead.LookAt(NPCArchi);
			chosenCharSubLead.LookAt(chosenCharLead);
			chosenCharThird.LookAt(chosenCharLead);
			yield return HAGIS.DialogShow(AmbientWaiting);
		}
		else
		{
			HagisLog("Archi in party");
			UnitMoveToTarget(chosenCharThird, MoveTo2);
			yield return CreateTimeCondition(0.5f);
			UnitMoveToTarget(chosenCharLead, MoveTo3);
			yield return CreateTimeCondition(0.5f);
			yield return UnitMoveToTarget(chosenCharSubLead, MoveTo1);
			chosenCharLead.LookAt(chosenCharSubLead);
			chosenCharSubLead.LookAt(chosenCharLead);
			chosenCharThird.LookAt(chosenCharLead);
			yield return HAGIS.DialogShow(AmbientIsImagerWorking);
		}
		CutsceneBegin();
		SFXPlayAtCoord("event:/sfx/script/act 2/a2o4/chris takes out imager", sfx_chris_takes_out_imager);
		chosenCharLead.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultHoldImager");
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultDIdleToHoldImager");
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogArchibaldWilliams);
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogAdjust);
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogDownToOne);
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogCantbuyAlcohol);
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogTobacco);
		yield return chosenCharLead.unitModel.PlayAndReturnToIdle("CsDefaultTapImager");
		yield return HAGIS.DialogShow(DialogMilk);
		yield return HAGIS.DialogShow(AmbientDontWorry);
		yield return HAGIS.DialogShow(Dialog_IfYouWanna);
		yield return CreateTimeCondition(3f);
		yield return HAGIS.DialogShow(Dialog_MakingTheCall);
		CutsceneEnd();
	}
}
public class HAGIS_A2O5 : HAGIS
{
	private Unit Willa;

	private Unit Bugsy;

	private Unit NervousBarbot;

	private Unit NervousBarbot2;

	private Unit replacementBarbot;

	private Unit MargotSkyway;

	private Unit ChosenCharSkyway;

	private Unit MargotHydro;

	private Unit ChosenCharHydro;

	private Unit securityDroid1;

	private Unit securityDroid2;

	private Unit securityDroid3;

	private Unit Terri;

	private Unit InfinateDroid1;

	private Unit InfinateDroid2;

	private Unit BugsyCarPark;

	private Unit BugsysMuscle;

	private UnitTarget willaFromElevator;

	private UnitTarget barbotLeaves;

	private UnitTarget willaInSkyway;

	private UnitTarget margotLooksAway;

	private UnitTarget willaExitsSkyway;

	private UnitTarget chosenCharExitsSkyway;

	private UnitTarget willaToCover;

	private UnitTarget droidSpawner1;

	private UnitTarget droidSpawner2;

	private UnitTarget margotCover;

	private UnitTarget chosenCharCover;

	private UnitTarget EnemyCover_2;

	private UnitTarget EnemyCover_3;

	private UnitTarget EnemyCover_4;

	private UnitTarget TerriCover;

	private UnitTarget TerriCover2;

	private UnitTarget willaCollect1;

	private UnitTarget willaCollect2;

	private UnitTarget willaFinishedCollecting;

	private UnitTarget willaToCar;

	private UnitTarget bugsyLeaves;

	private UnitTarget bugsysMuscleLeaves;

	private UnitTarget bugsyChokesWilla;

	private UnitTarget muscleToChosenChar;

	private TileActionSwapMap arenaBarToSkyway;

	private TileActionSwapMap arenaToCarpark;

	private TileActionSwapMap carParkToArena;

	private TileActionDialog arenaBarBarbot;

	private TileActionDialog arenaBugsy;

	private TileActionDialog arenaDartBoard;

	private TileActionDialog arenaWindow1;

	private TileActionDialog arenaWindow2;

	private TileActionDialog replacementBarbotDialog;

	private TileActionSwapMap skywayToArenaBar;

	private TileActionSwapMap skywayToHydroponics;

	private TileActionSwapMap hydroponicsToSkyway;

	private TileTrigger boxReminder1;

	private TileTrigger boxReminder2;

	private TileTrigger boxReminder3;

	private TileTrigger boxReminder4;

	private TileTrigger boxReminder5;

	private TileTrigger hydroponicsConsole;

	private TileTrigger hydroTeamExit;

	private TileTrigger hydroWillaExit;

	private TileLootTrigger Pod1one;

	private TileLootTrigger Pod2one;

	private TileLootTrigger Pod3one;

	private TileLootTrigger Pod4one;

	private TileLootTrigger Pod5one;

	private TileActionDialog Pod1Dry;

	private TileActionDialog Pod2Dry;

	private TileActionDialog Pod3Dry;

	private TileActionDialog Pod4Dry;

	private TileActionDialog Pod5Dry;

	private TileTrigger consoleReached;

	private DialogData dialog_finalAdvice;

	private DialogData ambient_youMook;

	private DialogData ambient_facesWilla;

	private DialogData dialog_jobForBugsy;

	private DialogData dialog_WasntListening;

	private DialogData ambient_scepticalMargot;

	private DialogData ambient_willaSnaps;

	private DialogData dialog_breakItUp;

	private DialogData dialog_margotWarns;

	private DialogData ambient_margotNotComing;

	private DialogData dialog_GuysADick;

	private DialogData dialog_TerriWilla;

	private DialogData ambient_sortSecurity;

	private DialogData dialog_willaStruggling;

	private DialogData ambient_nearlyThere;

	private DialogData ambient_harvestedWithHelpCombat;

	private DialogData ambient_Eurgh;

	private DialogData ambient_HowLongWereYouHere;

	private DialogData AmbientKeepWatch;

	private DialogData dialog_overFriendly;

	private DialogData dialog_wheresMargot;

	private DialogData dialog_bugsyAngry;

	private DialogData ambient_bugsyLetsGo;

	private DialogData dialog_worriedAboutWilla;

	private bool gotIntoAFight;

	private string objBugsyString = "OBJECTIVES_A2O5_01";

	private string objFarmString = "OBJECTIVES_A2O5_02";

	private string objFindBoxString = "OBJECTIVES_A2O5_03";

	private string objSkywayString = "OBJECTIVES_A2O5_05";

	private string objDeliverString = "OBJECTIVES_A2O5_06";

	public bool PickedUpCabbageBox { get; private set; }

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot kaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot hydroponicsPlant = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot kaydockArenaCarPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		Willa = GC.Inst.GetUnitWithId("4C1_T2TheKaydockArenaBar_UnitSpawn");
		Bugsy = GC.Inst.GetUnitWithId("DEB_T2TheKaydockArenaBar_UnitSpawn");
		NervousBarbot = GC.Inst.GetUnitWithId("73E_T2TheKaydockArenaBar_UnitSpawn");
		NervousBarbot2 = GC.Inst.GetUnitWithId("9AC_T2TheKaydockArenaBar_UnitSpawn");
		replacementBarbot = GC.Inst.GetUnitWithId("A93_T2TheKaydockArenaBar_UnitSpawn");
		MargotSkyway = GC.Inst.GetUnitWithId("10D_T2Skyway_UnitSpawn");
		ChosenCharSkyway = GC.Inst.GetUnitWithId("886_T2Skyway_UnitSpawn");
		MargotHydro = GC.Inst.GetUnitWithId("C12_T2BillysHilltopFarm_UnitSpawn");
		ChosenCharHydro = GC.Inst.GetUnitWithId("C01_T2BillysHilltopFarm_UnitSpawn");
		securityDroid1 = GC.Inst.GetUnitWithId("9DA_T2BillysHilltopFarm_UnitSpawn");
		securityDroid2 = GC.Inst.GetUnitWithId("2E9_T2BillysHilltopFarm_UnitSpawn");
		securityDroid3 = GC.Inst.GetUnitWithId("11E_T2Hydroponics_UnitSpawn");
		BugsyCarPark = GC.Inst.GetUnitWithId("26C_T2TheKaydockArenaCarPark_UnitSpawn");
		BugsysMuscle = GC.Inst.GetUnitWithId("0DD_T2TheKaydockArenaCarPark_UnitSpawn");
		Terri = GC.Inst.GetUnitWithId("3AD_T2Hydroponics_UnitSpawn");
		arenaBarToSkyway = MR.Inst.GetTileActionSwapMap("F6C_T2TheKaydockArenaBar_TileActionSwapMap");
		skywayToArenaBar = MR.Inst.GetTileActionSwapMap("00C_T2Skyway_TileActionSwapMap");
		skywayToHydroponics = MR.Inst.GetTileActionSwapMap("54F_T2Skyway_TileActionSwapMap");
		hydroponicsToSkyway = MR.Inst.GetTileActionSwapMap("3E6_T2BillysHilltopFarm_TileActionSwapMap");
		arenaToCarpark = MR.Inst.GetTileActionSwapMap("D41_T2TheKaydockArenaBar_TileActionSwapMap");
		carParkToArena = MR.Inst.GetTileActionSwapMap("4F5_T2BillysHilltopFarm_TileActionSwapMap");
		arenaBarBarbot = MR.Inst.GetTileActionDialog("54C_T2TheKaydockArenaBar_TileActionDialog");
		arenaBugsy = MR.Inst.GetTileActionDialog("A1D_T2TheKaydockArenaBar_TileActionDialog");
		hydroWillaExit = MR.Inst.GetTileTrigger("CC0_T2BillysHilltopFarm_TileTrigger");
		replacementBarbotDialog = MR.Inst.GetTileActionDialog("68D_T2TheKaydockArenaBar_TileActionDialog");
		arenaWindow1 = MR.Inst.GetTileActionDialog("7BC_T2TheKaydockArenaBar_TileActionDialog");
		TileActionInteraction pickupBox = MR.Inst.GetTileActionInteraction("83B_T2Hydroponics_TileActionInteraction");
		TileTrigger putDownBox = MR.Inst.GetTileTrigger("0DF_T2Hydroponics_TileTrigger");
		TileActionInteraction I_Boot = MR.Inst.GetTileActionInteraction("FA5_T2TheKaydockArenaCarPark_TileActionInteraction");
		willaFromElevator = MR.Inst.GetUnitTarget("0B9_T2TheKaydockArenaBar_UnitTarget");
		barbotLeaves = MR.Inst.GetUnitTarget("B43_T2TheKaydockArenaBar_UnitTarget");
		willaInSkyway = MR.Inst.GetUnitTarget("50A_T2Skyway_UnitTarget");
		margotLooksAway = MR.Inst.GetUnitTarget("751_T2Skyway_UnitTarget");
		willaToCover = MR.Inst.GetUnitTarget("858_T2BillysHilltopFarm_UnitTarget");
		droidSpawner1 = MR.Inst.GetUnitTarget("5C4_T2BillysHilltopFarm_UnitTarget");
		willaExitsSkyway = MR.Inst.GetUnitTarget("060_T2Skyway_UnitTarget");
		chosenCharExitsSkyway = MR.Inst.GetUnitTarget("03F_T2Skyway_UnitTarget");
		willaToCar = MR.Inst.GetUnitTarget("913_T2TheKaydockArenaCarPark_UnitTarget");
		bugsyLeaves = MR.Inst.GetUnitTarget("33D_T2TheKaydockArenaCarPark_UnitTarget");
		bugsysMuscleLeaves = MR.Inst.GetUnitTarget("221_T2TheKaydockArenaCarPark_UnitTarget");
		bugsyChokesWilla = MR.Inst.GetUnitTarget("BE0_T2TheKaydockArenaCarPark_UnitTarget");
		muscleToChosenChar = MR.Inst.GetUnitTarget("420_T2TheKaydockArenaCarPark_UnitTarget");
		margotCover = MR.Inst.GetUnitTarget("CCF_T2BillysHilltopFarm_UnitTarget");
		chosenCharCover = MR.Inst.GetUnitTarget("A11_T2BillysHilltopFarm_UnitTarget");
		willaCollect1 = MR.Inst.GetUnitTarget("9E5_T2Hydroponics_UnitTarget");
		willaCollect2 = MR.Inst.GetUnitTarget("747_T2Hydroponics_UnitTarget");
		willaFinishedCollecting = MR.Inst.GetUnitTarget("DD2_T2Hydroponics_UnitTarget");
		UnitTarget move_chosen_skyway_char_in_bar = MR.Inst.GetUnitTarget("6FB_T2TheKaydockArenaBar_UnitTarget");
		EnemyCover_2 = MR.Inst.GetUnitTarget("C21_T2Hydroponics_UnitTarget");
		EnemyCover_3 = MR.Inst.GetUnitTarget("977_T2Hydroponics_UnitTarget");
		EnemyCover_4 = MR.Inst.GetUnitTarget("91C_T2Hydroponics_UnitTarget");
		TerriCover = MR.Inst.GetUnitTarget("9D0_T2Hydroponics_UnitTarget");
		TerriCover2 = MR.Inst.GetUnitTarget("BFE_T2Hydroponics_UnitTarget");
		UnitTarget sfx_willa_collects_box = MR.Inst.GetUnitTarget("3E4_T2Hydroponics_UnitTarget");
		UnitTarget sfx_willa_puts_down_box = MR.Inst.GetUnitTarget("747_T2Hydroponics_UnitTarget");
		dialog_finalAdvice = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaBar/DialogFinalAdvice");
		ambient_youMook = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaBar/AmbientYouMook");
		ambient_facesWilla = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaBar/AmbientFacesWilla");
		dialog_jobForBugsy = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaBar/DialogJobForBugsy");
		dialog_WasntListening = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaBar/DialogWasntListening");
		ambient_scepticalMargot = HAGIS.DialogLoad("Dialogs/A2O5/Skyway/AmbientScepticalMargot");
		ambient_willaSnaps = HAGIS.DialogLoad("Dialogs/A2O5/Skyway/AmbientWillaSnaps");
		dialog_breakItUp = HAGIS.DialogLoad("Dialogs/A2O5/Skyway/DialogBreakItUp");
		dialog_margotWarns = HAGIS.DialogLoad("Dialogs/A2O5/Skyway/DialogMargotWarns");
		ambient_sortSecurity = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientSortSecurity");
		dialog_willaStruggling = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/DialogWillaStruggling");
		ambient_nearlyThere = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientNearlyThere");
		ambient_harvestedWithHelpCombat = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientHarvestedWithHelpCombat");
		ambient_Eurgh = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/Ambient_Eurgh");
		ambient_HowLongWereYouHere = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/Ambient_HowLongWereYouHere");
		dialog_GuysADick = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/Dialog_GuysADick");
		dialog_TerriWilla = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/Dialog_TerriWilla");
		ambient_margotNotComing = HAGIS.DialogLoad("Dialogs/A2O5/Skyway/AmbientMargotNotComing");
		dialog_overFriendly = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaCarPark/DialogOverfriendly");
		dialog_wheresMargot = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaCarPark/DialogWheresMargot");
		dialog_bugsyAngry = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaCarPark/DialogBugsyAngry");
		ambient_bugsyLetsGo = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaCarPark/AmbientBugsyLetsGo");
		dialog_worriedAboutWilla = HAGIS.DialogLoad("Dialogs/A2O5/KaydockArenaCarPark/DialogWorriedAboutWilla");
		AmbientKeepWatch = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientKeepWatch");
		DialogData DroidDestroyed1 = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroid1Destroyed");
		DialogData DroidDestroyed2 = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroid2Destroyed");
		DialogData DroidDestroyed3 = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroidOtherDestroyed");
		UnitTarget carTarget = MR.Inst.GetUnitTarget("0E5_T2TheKaydockArenaCarPark_UnitTarget");
		Willa.gameObject.SetActive(value: false);
		arenaBarToSkyway.gameObject.SetActive(value: false);
		MargotHydro.gameObject.SetActive(value: false);
		ChosenCharHydro.gameObject.SetActive(value: false);
		Terri.gameObject.SetActive(value: false);
		securityDroid1.gameObject.SetActive(value: false);
		securityDroid2.gameObject.SetActive(value: false);
		securityDroid3.gameObject.SetActive(value: false);
		putDownBox.gameObject.SetActive(value: false);
		TextMesh harvestText = GameObject.Find("CabbageCounter").GetComponent<TextMesh>();
		TextMesh cabbageCounter = GameObject.Find("Counter").GetComponent<TextMesh>();
		harvestText.gameObject.SetActive(value: false);
		cabbageCounter.gameObject.SetActive(value: false);
		hydroWillaExit.gameObject.SetActive(value: false);
		replacementBarbot.gameObject.SetActive(value: false);
		replacementBarbotDialog.gameObject.SetActive(value: false);
		arenaToCarpark.gameObject.SetActive(value: false);
		I_Boot.gameObject.SetActive(value: false);
		PlayMapAnimation(kaydockArenaBar.Map, "MA_BlindTigerDecal_01", "Idle");
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objBugsyString);
		MusicStop();
		CutsceneBegin();
		kaydockArenaBar.unitsMoveToDefaultPositions = false;
		yield return CreateTimeCondition(2f);
		Willa.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Willa, willaFromElevator);
		Willa.LookAt(Bugsy);
		yield return CreateTimeCondition(2f);
		yield return HAGIS.DialogShow(dialog_finalAdvice);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/diagetic/kaydock bar");
		HagletYieldTerm arenaBarBarbotDialogCompleted = CreateTriggerCondition(arenaBarBarbot.OnDialogComplete);
		HagletYieldTerm arenaBugsyDialogCompleted = CreateTriggerCondition(arenaBugsy.OnDialogComplete);
		yield return CreateOrCondition(arenaBarBarbotDialogCompleted, arenaBugsyDialogCompleted);
		if (SaveData.SplitPoint(arenaBarBarbotDialogCompleted.met, skipOverride: true))
		{
			CutsceneBegin();
			NervousBarbot.LookAt(Bugsy);
			yield return CreateTimeCondition(1f);
			NervousBarbot.LookAt(Willa);
			CutsceneEnd();
			yield return CreateTriggerCondition(arenaBugsy.OnDialogComplete);
			arenaBarBarbot.gameObject.SetActive(value: false);
		}
		else if (SaveData.SplitPoint(arenaBugsyDialogCompleted.met))
		{
			arenaBarBarbot.gameObject.SetActive(value: false);
		}
		CutsceneBegin();
		Willa.LookAt(Bugsy);
		NervousBarbot2.LookAt(Bugsy);
		HAGIS.DialogShow(ambient_youMook);
		yield return CreateTimeCondition(1f);
		Bugsy.LookAt(NervousBarbot2);
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(NervousBarbot2, "CsTransDIdleToScaredIdle");
		NervousBarbot2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultScareIdle");
		UnitPlayAnimation(NervousBarbot2, "CsDefaultScareIdle");
		NervousBarbot2.UpdateIdleAnim();
		yield return CreateTimeCondition(2.3f);
		NervousBarbot2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultSadWalk");
		yield return UnitMoveToTarget(NervousBarbot2, barbotLeaves);
		NervousBarbot2.Hide(makeInactive: true);
		Bugsy.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_facesWilla);
		UIObjectives.Inst.CompleteObjective(objBugsyString);
		yield return HAGIS.DialogShow(dialog_jobForBugsy);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFarmString);
		MusicPlay("event:/music/tracks/diagetic/kaydock bar");
		arenaBarToSkyway.gameObject.SetActive(value: true);
		arenaBugsy.dialog = dialog_WasntListening;
		arenaBugsy.gameObject.SetActive(value: false);
		CutsceneEnd();
		SKIP_POINT("skipped first bar scene");
		yield return MapWaitUntilVisible(skyway.Map);
		UIObjectives.Inst.CompleteObjective(objFarmString);
		MusicPlay("event:/music/tracks/basic/lights out full");
		CutsceneBegin();
		Bugsy.gameObject.SetActive(value: false);
		skywayToArenaBar.gameObject.SetActive(value: false);
		skywayToHydroponics.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(Willa, willaInSkyway);
		HAGIS.ToggleShakeEnvironment(on: true);
		Willa.LookAt(MargotSkyway);
		yield return HAGIS.DialogShow(ambient_scepticalMargot);
		MargotSkyway.LookAt(Willa);
		yield return HAGIS.DialogShow(ambient_willaSnaps);
		yield return HAGIS.DialogShow(dialog_breakItUp);
		MargotSkyway.LookAt(margotLooksAway.transform);
		yield return HAGIS.DialogShow(dialog_margotWarns);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		skywayToHydroponics.gameObject.SetActive(value: true);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_Hydroponics_L0");
		MargotSkyway.SetTeamType(UnitTeam.Type.Player);
		ChosenCharSkyway.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		SKIP_POINT("skipped skyway");
		hydroponicsPlant.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(hydroponicsPlant.Map);
		MusicPlay("event:/music/tracks/basic/willa underscore");
		SKIP_POINT("Fucking Cabbages");
		CutsceneBegin();
		hydroponicsToSkyway.gameObject.SetActive(value: false);
		UnitMoveToTarget(MargotSkyway, margotCover);
		UnitMoveToTarget(ChosenCharSkyway, chosenCharCover);
		yield return UnitMoveToTarget(Willa, willaToCover);
		GC.Inst.SetRPGLeader(Willa);
		HAGIS.DialogShow(ambient_sortSecurity);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindBoxString);
		gotIntoAFight = false;
		CutsceneEnd();
		GC.Inst.SetRPGLeader(Willa);
		ParticlePrefab BoxHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, pickupBox.transform);
		yield return CreateTriggerCondition(pickupBox.OnTriggered);
		PickedUpCabbageBox = true;
		BoxHightlight.StopParticles();
		CutsceneBegin();
		Willa.LookInDirection(OctDir.Right);
		UIObjectives.Inst.CompleteObjective(objFindBoxString);
		Willa.unitModel.Play("CsTransDIdleToDIdleBox");
		yield return CreateTimeCondition(0.45f);
		pickupBox.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CsDefaultWalkBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultInteractBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "CsDefaultInteractBox");
		Willa.UpdateIdleAnim();
		yield return CreateTimeCondition(2f);
		yield return HAGIS.DialogShow(dialog_willaStruggling);
		HAGIS.DialogShow(ambient_HowLongWereYouHere);
		yield return UnitMoveToTarget(Willa, willaCollect1, OctDir.Right, Willa.charData.movementSpeedInCombat);
		yield return Willa.unitModel.Play("CsDefaultInteractBox");
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(Willa, willaCollect2, OctDir.Left, Willa.charData.movementSpeedInCombat);
		yield return Willa.unitModel.Play("CsDefaultInteractBox");
		if (!ambient_HowLongWereYouHere.completed)
		{
			yield return CreateTriggerCondition(ambient_HowLongWereYouHere.OnComplete);
		}
		yield return null;
		Terri.gameObject.SetActive(value: true);
		Willa.unitModel.Play("CsDefaultInteractBox");
		yield return UnitMoveToTarget(Terri, TerriCover);
		Willa.LookAt(Terri);
		MargotSkyway.LookAt(Terri);
		ChosenCharSkyway.LookAt(Terri);
		Terri.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_TerriWilla);
		Terri.LookAt(MargotSkyway);
		yield return CreateTimeCondition(1f);
		Terri.LookAt(ChosenCharSkyway);
		yield return CreateTimeCondition(1f);
		Terri.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(Terri, droidSpawner1);
		Terri.Hide(makeInactive: true);
		HAGIS.DialogShow(dialog_GuysADick);
		yield return UnitMoveToTarget(Willa, willaFinishedCollecting, OctDir.Left);
		Willa.unitModel.Play("CsTransDIdleBoxToDIdle");
		yield return CreateTimeCondition(0.85f);
		putDownBox.gameObject.SetActive(value: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatCrouch");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CombatWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "DefaultInteract");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "DefaultPickup");
		Willa.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		if (!dialog_GuysADick.completed)
		{
			yield return CreateTriggerCondition(dialog_GuysADick.OnComplete);
		}
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/script/act 2/a2o5/hydroponics alarm");
		MusicStop();
		Terri.gameObject.SetActive(value: true);
		securityDroid1.gameObject.SetActive(value: true);
		securityDroid2.gameObject.SetActive(value: true);
		securityDroid3.gameObject.SetActive(value: true);
		UnitMoveToTarget(Terri, TerriCover2);
		UnitMoveToTarget(securityDroid1, EnemyCover_2);
		UnitMoveToTarget(securityDroid2, EnemyCover_3);
		yield return UnitMoveToTarget(securityDroid3, EnemyCover_4);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_Eurgh);
		yield return CreateTimeCondition(0.5f);
		CutsceneEnd();
		SKIP_POINT("Hydroponics fight");
		MusicPlay("event:/music/tracks/combat/nursery");
		CombatBegin(UnitTeam.Type.Player);
		int respawns = 0;
		while (true)
		{
			HagletYieldTerm combatComplete = CreateTriggerCondition(CombatWaitUntilComplete());
			HagletYieldTerm droid1Died = CreateTriggerCondition(securityDroid1.OnDeathComplete);
			HagletYieldTerm droid2Died = CreateTriggerCondition(securityDroid2.OnDeathComplete);
			HagletYieldTerm droid3Died = CreateTriggerCondition(securityDroid3.OnDeathComplete);
			yield return CreateOrCondition(combatComplete, droid1Died, droid2Died, droid3Died);
			if (combatComplete.met.SkipOverride(overrideValue: true))
			{
				break;
			}
			if (respawns < 3)
			{
				switch (respawns)
				{
				case 0:
					yield return HAGIS.DialogShow(DroidDestroyed1);
					break;
				case 1:
					yield return HAGIS.DialogShow(DroidDestroyed2);
					break;
				case 2:
					yield return HAGIS.DialogShow(DroidDestroyed3);
					break;
				}
				if (droid1Died.met)
				{
					yield return securityDroid1.SetCoord(securityDroid1.spawnCoords);
					securityDroid1.Revive();
				}
				else if (droid2Died.met)
				{
					yield return securityDroid2.SetCoord(securityDroid2.spawnCoords);
					securityDroid2.Revive();
				}
				else if (droid3Died.met)
				{
					yield return securityDroid3.SetCoord(securityDroid3.spawnCoords);
					securityDroid3.Revive();
				}
				respawns++;
			}
		}
		yield return CreateTimeCondition(1f);
		hydroponicsPlant.unitsMoveToDefaultPositions = true;
		CutsceneBegin();
		yield return GC.Inst.GetTeamOfType(UnitTeam.Type.Player).MoveTeamToDefaultPositions();
		yield return UnitMoveToTarget(Willa, willaFinishedCollecting, OctDir.Left);
		Willa.unitModel.Play("CsTransDIdleToDIdleBox");
		yield return CreateTimeCondition(0.5f);
		putDownBox.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CsDefaultIdleBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CsDefaultWalkBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultInteractBox");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "CsDefaultInteractBox");
		yield return HAGIS.DialogShow(ambient_harvestedWithHelpCombat);
		CutsceneEnd();
		hydroponicsToSkyway.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		MusicPlay("event:/music/tracks/basic/thoughtful music");
		yield return MapWaitUntilVisible(skyway.Map);
		UIObjectives.Inst.CompleteObjective(objSkywayString);
		SKIP_POINT("skipped cabage picking");
		CutsceneBegin();
		skywayToArenaBar.gameObject.SetActive(value: false);
		skywayToHydroponics.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(Willa, willaInSkyway, OctDir.Left);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		arenaBarBarbot.gameObject.SetActive(value: false);
		MargotSkyway.SetTeamType(UnitTeam.Type.NPC);
		HAGIS.ToggleShakeEnvironment(on: false);
		skywayToArenaBar.gameObject.SetActive(value: true);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_KaydockArena_L0");
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(Willa, willaExitsSkyway);
		Willa.LookAt(MargotSkyway);
		HAGIS.DialogShow(ambient_margotNotComing);
		yield return UnitMoveToTarget(ChosenCharSkyway, chosenCharExitsSkyway);
		UnitTeleportToMapViaEntranceTile(ChosenCharSkyway, arenaBarToSkyway, move_chosen_skyway_char_in_bar);
		UnitLookInDirection(ChosenCharSkyway, OctDir.Right);
		skywayToArenaBar.gameObject.SetActive(value: true);
		CutsceneEnd();
		replacementBarbotDialog.gameObject.SetActive(value: true);
		arenaWindow1.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(kaydockArenaBar.Map);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDeliverString);
		MusicStop();
		yield return null;
		ChosenCharSkyway.SetTeamType(UnitTeam.Type.Player);
		arenaBarToSkyway.gameObject.SetActive(value: false);
		PlayInterplay();
		yield return CreateTriggerCondition(replacementBarbotDialog.OnDialogComplete);
		SKIP_POINT("Returning to bugsy");
		arenaToCarpark.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(kaydockArenaCarPark.Map);
		MusicPlay("event:/music/tracks/basic/bugsys theme");
		carParkToArena.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, willaToCar);
		Willa.LookAt(BugsyCarPark);
		ChosenCharSkyway.LookAt(BugsyCarPark);
		BugsyCarPark.LookAt(Willa);
		BugsysMuscle.LookAt(Willa);
		yield return HAGIS.DialogShow(dialog_overFriendly);
		I_Boot.gameObject.SetActive(value: true);
		CutsceneEnd();
		ParticlePrefab carHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, carTarget.transform.GetChild(0));
		yield return CreateTriggerCondition(I_Boot.OnTriggered);
		carHightlight.StopParticles();
		UIObjectives.Inst.CompleteObjective(objDeliverString);
		yield return CutscenePlay("A2O5_Cutscene_DroppingOffCabbages");
	}
}
public class HAGIS_A2O5_HydroDroid : HAGIS
{
	public string droidIDToRevive;

	public string droidSpawnPointID;

	private Unit droid;

	private UnitTarget droidSpawn;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		droid = GC.Inst.GetUnitWithId(droidIDToRevive);
		droidSpawn = MR.Inst.GetUnitTarget(droidSpawnPointID);
		yield return GC.Inst.OnTurnModeBegan;
		while (true)
		{
			HagletYieldTerm combatCompleted = Wait.Until(CombatWaitUntilComplete());
			yield return CreateOrCondition(TurnModeWaitForPlayerTurnStart(3u), combatCompleted);
			if (combatCompleted.met)
			{
				break;
			}
			droid.StartTeleport(droidSpawn);
			droid.Revive();
		}
	}
}
public class HAGIS_A2O5_HydroDroid2 : HAGIS
{
	public string droidIDToRevive;

	public string droidSpawnPointID;

	private Unit droid;

	private UnitTarget droidSpawn;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		droid = GC.Inst.GetUnitWithId(droidIDToRevive);
		droidSpawn = MR.Inst.GetUnitTarget(droidSpawnPointID);
		yield return GC.Inst.OnTurnModeBegan;
		while (true)
		{
			HagletYieldTerm combatCompleted = Wait.Until(CombatWaitUntilComplete());
			yield return CreateOrCondition(TurnModeWaitForPlayerTurnStart(3u), combatCompleted);
			if (combatCompleted.met)
			{
				break;
			}
			droid.StartTeleport(droidSpawn);
			droid.Revive();
		}
	}
}
public class HAGIS_A2O5_HydroEndlessFight : HAGIS
{
	private Unit MargotHydro;

	private Unit ChosenCharHydro;

	private Unit Willa;

	private Unit Terri;

	private Unit RunnerHydrGuard;

	private Unit RunnerHydrGuard2;

	private DialogData Ambient_Droid2Destroyed;

	private DialogData Ambient_DroidOtherDestroyed;

	private DialogData AmbientDroid1Destroyed;

	private string objFindBoxInCombatString = "Survive security! Find a box to harvest with";

	private string objCombatEndlessString = "Escape security! Quickly harvest and leave the plant";

	private string objGotBoxCombatString = "Survive security! Harvest 5 cabbages";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HAGIS_A2O5 A2O5MainHagis = MR.Inst.GetHagis<HAGIS_A2O5>();
		LogicRoot kaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot hydroponicsPlant = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot kaydockArenaCarPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		Terri = GC.Inst.GetUnitWithId("3AD_T2Hydroponics_UnitSpawn");
		MargotHydro = GC.Inst.GetUnitWithId("C12_T2BillysHilltopFarm_UnitSpawn");
		ChosenCharHydro = GC.Inst.GetUnitWithId("C01_T2BillysHilltopFarm_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("4C1_T2TheKaydockArenaBar_UnitSpawn");
		RunnerHydrGuard = GC.Inst.GetUnitWithId("2E9_T2BillysHilltopFarm_UnitSpawn");
		RunnerHydrGuard2 = GC.Inst.GetUnitWithId("9DA_T2BillysHilltopFarm_UnitSpawn");
		AmbientDroid1Destroyed = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroid1Destroyed");
		Ambient_Droid2Destroyed = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroid2Destroyed");
		Ambient_DroidOtherDestroyed = HAGIS.DialogLoad("Dialogs/A2O5/HydroponicsPlant/AmbientDroidOtherDestroyed");
		UnitTarget TargetDroidRespawn1 = MR.Inst.GetUnitTarget("5C4_T2BillysHilltopFarm_UnitTarget");
		yield return StealthWaitUntilBroken();
		if (Singleton<MC>.Inst.GetActiveMap() != hydroponicsPlant.Map)
		{
			yield break;
		}
		HagisLog("CABBAGES: you've broken stealth! and must begin fighting");
		if (!A2O5MainHagis.PickedUpCabbageBox)
		{
			UIObjectives.Inst.CompleteAndSetMainObjective(objFindBoxInCombatString);
		}
		else
		{
			UIObjectives.Inst.CompleteAndSetMainObjective(objGotBoxCombatString);
		}
		MargotHydro.SetTeamType(UnitTeam.Type.Player);
		ChosenCharHydro.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		Terri.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		int deadGuardCount = 0;
		while (true)
		{
			yield return CreateOrCondition(RunnerHydrGuard.OnDeathComplete, RunnerHydrGuard2.OnDeathComplete);
			while (RunnerHydrGuard.HP <= 0 || RunnerHydrGuard2.HP <= 0)
			{
				deadGuardCount++;
				CutsceneBegin();
				Unit deadGuard = RunnerHydrGuard;
				if (RunnerHydrGuard2.HP <= 0)
				{
					deadGuard = RunnerHydrGuard2;
				}
				switch (deadGuardCount)
				{
				case 1:
					yield return HAGIS.DialogShow(AmbientDroid1Destroyed);
					UIObjectives.Inst.CompleteAndSetMainObjective(objCombatEndlessString);
					break;
				case 2:
					yield return HAGIS.DialogShow(Ambient_Droid2Destroyed);
					HagisLog("RunnerHydrGuard is dead! time to get another");
					break;
				default:
					yield return HAGIS.DialogShow(Ambient_DroidOtherDestroyed);
					HagisLog("RunnerHydrGuard is dead! mambo number 3");
					break;
				}
				yield return Wait.ForSeconds(1f);
				yield return deadGuard.SetCoord(TargetDroidRespawn1.GetCoord());
				deadGuard.Revive();
				CutsceneEnd();
			}
		}
	}
}
public class HAGIS_A2O6 : HAGIS
{
	private Unit Willa;

	private Unit Marybelle;

	private Unit Unit1;

	private Unit Unit2;

	private Unit Unit3;

	private Unit Gosz;

	private Unit FilesFusel1;

	private Unit FilesFusel2;

	private Unit FilesFusel3;

	private UnitTarget MarybelleReadyToLeave;

	private UnitTarget trainSpot1;

	private UnitTarget trainSpot2;

	private UnitTarget trainSpot3;

	private UnitTarget trainSpotMary;

	private UnitTarget filesExchange;

	private UnitTarget afterExchange;

	private UnitTarget T_UnitIdel;

	private UnitTarget filesEnemyCover1;

	private UnitTarget filesEnemyCover2;

	private UnitTarget filesEnemyCover3;

	private UnitTarget filesUnitCover1;

	private UnitTarget filesUnitCover2;

	private UnitTarget filesUnitCover3;

	private UnitTarget filesUnitCover4;

	private UnitTarget elevatorSpot1;

	private UnitTarget elevatorSpot2;

	private UnitTarget elevatorSpot3;

	private UnitTarget elevatorSpotMary;

	private UnitTarget chumleysMary1;

	private UnitTarget chumleysMary2;

	private UnitTarget HideoutEntrance;

	private UnitTarget chumleysWilla;

	private UnitTarget chumleysGosz;

	private UnitTarget chumleysUnit1;

	private UnitTarget chumleysUnit2;

	private UnitTarget chumleysUnit3;

	private UnitTarget T_GH_Gosz;

	private UnitTarget WillaExit;

	private UnitTarget WillaEnters;

	private UnitTarget T_MarybelleIdel;

	private UnitTarget CrowbarObject;

	private UnitTarget OptionalRobots;

	private UnitTarget T_Skids1;

	private UnitTarget T_Skids2;

	private TileActionSwapMap AscensionToMuseum;

	private TileActionSwapMap MuseumToAscension;

	private TileActionSwapMap MuseumToTenorCity;

	private TileActionSwapMap UnderclocksExteriorToRoofTop;

	private TileActionSwapMap UnderclocksRooftopToExterior;

	private TileActionSwapMap FilesToStation;

	private TileActionSwapMap TrainToStation;

	private TileActionSwapMap PortEntranceToStation;

	private TileActionSwapMap PortEntranceToSkids;

	private TileActionSwapMap ElevatorToSkids;

	private TileActionSwapMap ElevatorToChumleys;

	private TileActionSwapMap ChumleysToElevator;

	private TileActionSwapMap ChumleysToHideout;

	private TileActionSwapMap HideoutToChumleys;

	private TileActionSwapMap TrainToPortEntrance;

	private TileActionDialog EnterMuseumEarly;

	private TileActionDialog KeyToCity;

	private TileActionDialog D_Window;

	private TileActionDialog ExitMuseumEarly;

	private TileActionDialog UnderclocksSkylight;

	private TileActionInteraction MarybelleIntro;

	private TileActionInteraction ArtworkEmpty1;

	private TileActionInteraction ArtworkEmpty2;

	private TileActionInteraction I_ToSkyway;

	private TileActionInteraction Ventrance;

	private TileActionInteraction Crowbar;

	private TileActionInteraction ElevatorSwitch;

	private TileActionInteraction OpenSkyLight;

	private TileActionInteraction I_TableInteraction;

	private TileTrigger UnderclockVent;

	private TileTrigger skidsElevator;

	private TileActionHotspot Artwork1;

	private TileActionHotspot Artwork2;

	private TileActionHotspot Artwork3;

	private TileActionHotspot Artwork4;

	private DialogData Dialog_Artwork1;

	private DialogData Dialog_Artwork2;

	private DialogData Dialog_Artwork3;

	private DialogData Dialog_Artwork4;

	private DialogData Dialog_ArtworkEmpty;

	private DialogData Dialog_ArtworkReminder;

	private DialogData Dialog_GetTopside;

	private DialogData Dialog_GoszArrives;

	private DialogData Dialog_GoszTrashed;

	private DialogData Dialog_HartmanFreightElevator;

	private DialogData Dialog_MarybelleEscort;

	private DialogData Dialog_MarybelleIntro;

	private DialogData Dialog_MarybelleOutro;

	private DialogData Dialog_MarybelleThanks;

	private DialogData Dialog_HartmanHitTheSwitch;

	private DialogData Dialog_WillaAtHQ;

	private DialogData Dialog_WillaRooftopAccess;

	private DialogData Dialog_WillaSkylight;

	private DialogData Dialog_WillaStolen;

	private DialogData Dialog_ThatsWeird;

	private DialogData Ambient_ArtworkReminder;

	private DialogData Ambient_HartmanBackToSkids;

	private DialogData Ambient_WhatAreTheSlumsLike;

	private DialogData Ambient_HartmanSkyway;

	private DialogData Ambient_HartmanSpeakToMary;

	private DialogData Ambient_MarybelleArrived;

	private DialogData Ambient_WatchHer;

	private DialogData Ambient_WillaCantSee;

	private DialogData Ambient_WillaDammit;

	private DialogData Ambient_LooksGood;

	private DialogData Ambient_WillaPickup;

	private DialogData Cutscene_Exchange;

	private string objMary = "OBJECTIVES_A2O6_01";

	private string objSkyway = "OBJECTIVES_A2O6_02";

	private string objGuard = "OBJECTIVES_A2O6_03";

	private string objOpen = "OBJECTIVES_A2O6_04";

	private string objDeliver = "OBJECTIVES_A2O6_05";

	private string objElevator = "OBJECTIVES_A2O6_06";

	private string objSearch = "OBJECTIVES_A2O6_07";

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = -4f;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot PortHaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot Skids = GetLogicUsingArtName("T1TheSkids");
		LogicRoot SkidsElevator = GetLogicUsingArtName("T1FreightElevator");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot ChumleysExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot MuseumOfCulture = GetLogicUsingArtName("T2TenorCityCentreMall");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot TenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot UnderclockHQExterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclockHQRooftop = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot GoszHideout = GetLogicUsingArtName("T2GoszsHQ_A2O6");
		Willa = GC.Inst.GetUnitWithId("83D_T2UnderclocksPoliceStation_Exterior_UnitSpawn");
		Marybelle = GC.Inst.GetUnitWithId("2B2_T2MuseumOfCulture_MarybelleExhibition_UnitSpawn");
		Unit1 = GC.Inst.GetUnitWithId("6C1_T2AscensionExhibit_UnitSpawn");
		Unit2 = GC.Inst.GetUnitWithId("57D_T2AscensionExhibit_UnitSpawn");
		Unit3 = GC.Inst.GetUnitWithId("DD8_T2AscensionExhibit_UnitSpawn");
		Gosz = GC.Inst.GetUnitWithId("FC2_T2ChumleysAutomatons_Exterior_UnitSpawn");
		FilesFusel1 = GC.Inst.GetUnitWithId("D82_T1TheFiles_UnitSpawn");
		FilesFusel2 = GC.Inst.GetUnitWithId("834_T1TheFiles_UnitSpawn");
		FilesFusel3 = GC.Inst.GetUnitWithId("C2F_T1TheFiles_UnitSpawn");
		MuseumToTenorCity = MR.Inst.GetTileActionSwapMap("DB3_T2MuseumOfCulture_MarybelleExhibition_TileActionSwapMap");
		UnderclocksRooftopToExterior = MR.Inst.GetTileActionSwapMap("EEB_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		TrainToStation = MR.Inst.GetTileActionSwapMap("F10_T1Subway_TrainInterior_TileActionSwapMap");
		PortEntranceToStation = MR.Inst.GetTileActionSwapMap("172_T1Port1_HaraEntrance_TileActionSwapMap");
		PortEntranceToSkids = MR.Inst.GetTileActionSwapMap("329_T1Port1_HaraEntrance_TileActionSwapMap");
		ElevatorToSkids = MR.Inst.GetTileActionSwapMap("AC3_T1FreightElevator_TileActionSwapMap");
		ElevatorToChumleys = MR.Inst.GetTileActionSwapMap("76A_T1FreightElevator_TileActionSwapMap");
		ChumleysToElevator = MR.Inst.GetTileActionSwapMap("3B2_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		ChumleysToHideout = MR.Inst.GetTileActionSwapMap("11F_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		HideoutToChumleys = MR.Inst.GetTileActionSwapMap("4E2_T2GoszsHQ_TileActionSwapMap");
		TrainToPortEntrance = MR.Inst.GetTileActionSwapMap("4B6_T1Subway_TrainInterior_TileActionSwapMap");
		FilesToStation = MR.Inst.GetTileActionSwapMap("050_T1TheFiles_TileActionSwapMap");
		TileActionSwapMap ToElevator = MR.Inst.GetTileActionSwapMap("CD2_T1TheSkids_TileActionSwapMap");
		ExitMuseumEarly = MR.Inst.GetTileActionDialog("421_T2MuseumOfCulture_MarybelleExhibition_TileActionDialog");
		UnderclocksSkylight = MR.Inst.GetTileActionDialog("1EF_T2UnderclocksPoliceStation_Roof_TileActionDialog");
		D_Window = MR.Inst.GetTileActionDialog("1EF_T2UnderclocksPoliceStation_Roof_TileActionDialog");
		MarybelleIntro = MR.Inst.GetTileActionInteraction("352_T2TenorCityCentreMall_TileActionInteraction");
		ArtworkEmpty1 = MR.Inst.GetTileActionInteraction("C60_T2TenorCityCentreMall_TileActionInteraction");
		ArtworkEmpty2 = MR.Inst.GetTileActionInteraction("372_T2TenorCityCentreMall_TileActionInteraction");
		Crowbar = MR.Inst.GetTileActionInteraction("6EA_T2UnderclocksPoliceStation_Roof_TileActionInteraction");
		ElevatorSwitch = MR.Inst.GetTileActionInteraction("3C1_T1FreightElevator_TileActionInteraction");
		I_ToSkyway = MR.Inst.GetTileActionInteraction("3CA_T2TenorCityCentre_TileActionInteraction");
		OpenSkyLight = MR.Inst.GetTileActionInteraction("588_T2UnderclocksPoliceStation_Roof_TileActionInteraction");
		I_TableInteraction = MR.Inst.GetTileActionInteraction("98E_T2GoszsHQ_TileActionInteraction");
		Artwork1 = MR.Inst.GetTileActionHotspot("557_T2TenorCityCentreMall_TileActionHotspot");
		Artwork2 = MR.Inst.GetTileActionHotspot("EFE_T2TenorCityCentreMall_TileActionHotspot");
		Artwork3 = MR.Inst.GetTileActionHotspot("050_T2TenorCityCentreMall_TileActionHotspot");
		Artwork4 = MR.Inst.GetTileActionHotspot("DA3_T2TenorCityCentreMall_TileActionHotspot");
		MarybelleReadyToLeave = MR.Inst.GetUnitTarget("2A6_T2MuseumOfCulture_MarybelleExhibition_UnitTarget");
		trainSpot1 = MR.Inst.GetUnitTarget("8CC_T1Subway_TrainInterior_UnitTarget");
		trainSpot2 = MR.Inst.GetUnitTarget("FCD_T1Subway_TrainInterior_UnitTarget");
		trainSpot3 = MR.Inst.GetUnitTarget("18F_T1Subway_TrainInterior_UnitTarget");
		trainSpotMary = MR.Inst.GetUnitTarget("157_T1Subway_TrainInterior_UnitTarget");
		filesExchange = MR.Inst.GetUnitTarget("EE7_T1TheFiles_UnitTarget");
		afterExchange = MR.Inst.GetUnitTarget("DCF_T1TheFiles_UnitTarget");
		T_UnitIdel = MR.Inst.GetUnitTarget("513_T1TheFiles_UnitTarget");
		filesEnemyCover1 = MR.Inst.GetUnitTarget("2E1_T1TheFiles_UnitTarget");
		filesEnemyCover2 = MR.Inst.GetUnitTarget("429_T1TheFiles_UnitTarget");
		filesEnemyCover3 = MR.Inst.GetUnitTarget("A1D_T1TheFiles_UnitTarget");
		filesUnitCover1 = MR.Inst.GetUnitTarget("614_T1TheFiles_UnitTarget");
		filesUnitCover2 = MR.Inst.GetUnitTarget("6EF_T1TheFiles_UnitTarget");
		filesUnitCover3 = MR.Inst.GetUnitTarget("5FD_T1TheFiles_UnitTarget");
		filesUnitCover4 = MR.Inst.GetUnitTarget("D33_T1TheFiles_UnitTarget");
		elevatorSpot1 = MR.Inst.GetUnitTarget("D4F_T1FreightElevator_UnitTarget");
		elevatorSpot2 = MR.Inst.GetUnitTarget("390_T1FreightElevator_UnitTarget");
		elevatorSpot3 = MR.Inst.GetUnitTarget("9A0_T1FreightElevator_UnitTarget");
		elevatorSpotMary = MR.Inst.GetUnitTarget("28E_T1FreightElevator_UnitTarget");
		chumleysMary1 = MR.Inst.GetUnitTarget("3D1_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysMary2 = MR.Inst.GetUnitTarget("254_T2ChumleysAutomatons_Exterior_UnitTarget");
		HideoutEntrance = MR.Inst.GetUnitTarget("1D9_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysWilla = MR.Inst.GetUnitTarget("BD5_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysGosz = MR.Inst.GetUnitTarget("030_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysUnit1 = MR.Inst.GetUnitTarget("FC6_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysUnit2 = MR.Inst.GetUnitTarget("B4F_T2ChumleysAutomatons_Exterior_UnitTarget");
		chumleysUnit3 = MR.Inst.GetUnitTarget("239_T2ChumleysAutomatons_Exterior_UnitTarget");
		WillaEnters = MR.Inst.GetUnitTarget("655_T2GoszsHQ_UnitTarget");
		WillaExit = MR.Inst.GetUnitTarget("7BE_T2GoszsHQ_UnitTarget");
		T_GH_Gosz = MR.Inst.GetUnitTarget("083_T2GoszsHQ_UnitTarget");
		T_MarybelleIdel = MR.Inst.GetUnitTarget("DD7_T1TheSkids_UnitTarget");
		CrowbarObject = MR.Inst.GetUnitTarget("E0B_T2UnderclocksPoliceStation_Roof_UnitTarget");
		T_Skids1 = MR.Inst.GetUnitTarget("57E_T1TheSkids_UnitTarget");
		T_Skids2 = MR.Inst.GetUnitTarget("9E8_T1TheSkids_UnitTarget");
		OptionalRobots = MR.Inst.GetUnitTarget("265_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		UnitTarget sfx_willa_pickup_crowbar = MR.Inst.GetUnitTarget("E55_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		Dialog_Artwork1 = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_Artwork1");
		Dialog_Artwork2 = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_Artwork2");
		Dialog_Artwork3 = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_Artwork3");
		Dialog_Artwork4 = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_Artwork4");
		Dialog_ArtworkEmpty = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_ArtworkEmpty");
		Dialog_ArtworkReminder = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_ArtworkReminder");
		Dialog_GetTopside = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_GetTopside");
		Dialog_GoszArrives = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_GoszArrives");
		Dialog_GoszTrashed = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_GoszTrashed");
		Dialog_HartmanFreightElevator = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_HartmanFreightElevator");
		Dialog_MarybelleEscort = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_MarybelleEscort");
		Dialog_MarybelleIntro = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_MarybelleIntro");
		Dialog_MarybelleOutro = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_MarybelleOutro");
		Dialog_MarybelleThanks = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_MarybelleThanks");
		Dialog_HartmanHitTheSwitch = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_HartmanHitTheSwitch");
		Dialog_WillaAtHQ = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_WillaAtHQ");
		Dialog_WillaRooftopAccess = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_WillaRooftopAccess");
		Dialog_WillaSkylight = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_WillaSkylight");
		Dialog_WillaStolen = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_WillaStolen");
		Dialog_ThatsWeird = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_ThatsWeird");
		Ambient_ArtworkReminder = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_ArtworkReminder");
		Ambient_HartmanBackToSkids = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_HartmanBackToSkids");
		Ambient_HartmanSkyway = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_HartmanSkyway");
		Ambient_WhatAreTheSlumsLike = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_WhatAreTheSlumsLike");
		Ambient_HartmanSpeakToMary = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_HartmanSpeakToMary");
		Ambient_MarybelleArrived = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_MarybelleArrived");
		Ambient_WatchHer = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_WatchHer");
		Ambient_WillaCantSee = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_WillaCantSee");
		Ambient_WillaPickup = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_WillaPickup");
		Ambient_WillaDammit = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_WillaDammit");
		Ambient_LooksGood = HAGIS.DialogLoad("Dialogs/A2O6/Ambient_ThisLooksGood");
		UnitTarget T_EnemyCover_Port_ENT = MR.Inst.GetUnitTarget("963_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget T_EnemyCover_Port_ENT2 = MR.Inst.GetUnitTarget("E29_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget T_Archi_Port_ENT = MR.Inst.GetUnitTarget("395_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget T_Chris_Port_ENT = MR.Inst.GetUnitTarget("6CD_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget T_Ambro_Port_ENT = MR.Inst.GetUnitTarget("61E_T1Port1_HaraEntrance_UnitTarget");
		UnitTarget T_Marybelle_Port_ENT = MR.Inst.GetUnitTarget("E27_T1Port1_HaraEntrance_UnitTarget");
		Unit PortEnemy = GC.Inst.GetUnitWithId("BF9_T1Port2_HaraMainBay_UnitSpawn");
		Unit PortEnemy2 = GC.Inst.GetUnitWithId("15B_T1Port2_HaraMainBay_UnitSpawn");
		string RoofSkylight = "MA_UnderClocks_SkyLight_02";
		elevatorWalls = SkidsElevator.Map.GetComponentInChildren<ScrollingWalls>();
		Marybelle.IsAttackingDisabled = true;
		OptionalRobots.gameObject.SetActive(value: false);
		Artwork1.gameObject.SetActive(value: false);
		Artwork2.gameObject.SetActive(value: false);
		Artwork3.gameObject.SetActive(value: false);
		Artwork4.gameObject.SetActive(value: false);
		ArtworkEmpty1.gameObject.SetActive(value: false);
		ArtworkEmpty2.gameObject.SetActive(value: false);
		MuseumToTenorCity.gameObject.SetActive(value: false);
		ElevatorToChumleys.gameObject.SetActive(value: false);
		ToElevator.gameObject.SetActive(value: false);
		TrainToPortEntrance.gameObject.SetActive(value: false);
		OpenSkyLight.gameObject.SetActive(value: false);
		I_ToSkyway.gameObject.SetActive(value: false);
		PlayMapAnimation(ChumleysExterior.Map, "MA_HiddenStatueDoor", "AlreadyOpen");
		yield return null;
		MusicPlay("event:/music/tracks/basic/marybelle theme");
		UIObjectives.Inst.CompleteAndSetMainObjective(objMary);
		HagletYieldTerm TalkedToMolly = CreateTriggerCondition(MarybelleIntro.OnTriggered);
		HagletYieldTerm Pre_Artwork1Triggered = CreateTriggerCondition(Artwork1.OnHotspotComplete);
		HagletYieldTerm Pre_Artwork2Triggered = CreateTriggerCondition(Artwork2.OnHotspotComplete);
		HagletYieldTerm Pre_Artwork3Triggered = CreateTriggerCondition(Artwork3.OnHotspotComplete);
		HagletYieldTerm Pre_Artwork4Triggered = CreateTriggerCondition(Artwork4.OnHotspotComplete);
		HagletYieldTerm Pre_ArtworkEmpty1Triggered = CreateTriggerCondition(ArtworkEmpty1.OnTriggered);
		HagletYieldTerm Pre_ArtworkEmpty2Triggered = CreateTriggerCondition(ArtworkEmpty2.OnTriggered);
		yield return CreateOrCondition(TalkedToMolly, Pre_Artwork1Triggered, Pre_Artwork2Triggered, Pre_Artwork3Triggered, Pre_Artwork4Triggered, Pre_ArtworkEmpty1Triggered, Pre_ArtworkEmpty2Triggered);
		Unit1.LookAt(Marybelle);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_MarybelleIntro);
		SKIP_POINT("Examine Paintings");
		Artwork1.gameObject.SetActive(value: true);
		Artwork2.gameObject.SetActive(value: true);
		Artwork3.gameObject.SetActive(value: true);
		Artwork4.gameObject.SetActive(value: true);
		ArtworkEmpty1.gameObject.SetActive(value: true);
		ArtworkEmpty2.gameObject.SetActive(value: true);
		MarybelleIntro.gameObject.SetActive(value: false);
		int nonEmptyArtExamined = 0;
		int artworkExamined = 0;
		UIObjectives.Inst.CompleteObjective(objMary);
		bool playerHasAlreadyWaited = false;
		do
		{
			HagletYieldTerm Artwork1Triggered = CreateTriggerCondition(Artwork1.OnHotspotComplete);
			HagletYieldTerm Artwork2Triggered = CreateTriggerCondition(Artwork2.OnHotspotComplete);
			HagletYieldTerm Artwork3Triggered = CreateTriggerCondition(Artwork3.OnHotspotComplete);
			HagletYieldTerm Artwork4Triggered = CreateTriggerCondition(Artwork4.OnHotspotComplete);
			HagletYieldTerm ArtworkEmpty1Triggered = CreateTriggerCondition(ArtworkEmpty1.OnTriggered);
			HagletYieldTerm ArtworkEmpty2Triggered = CreateTriggerCondition(ArtworkEmpty2.OnTriggered);
			HagletYieldTerm WaitingOnTheplayer = Wait.ForSeconds(20f);
			yield return CreateOrCondition(Artwork1Triggered, Artwork2Triggered, Artwork3Triggered, Artwork4Triggered, ArtworkEmpty1Triggered, ArtworkEmpty2Triggered, WaitingOnTheplayer);
			if (ArtworkEmpty1Triggered.met || ArtworkEmpty2Triggered.met)
			{
				ArtworkEmpty1.gameObject.SetActive(value: false);
				ArtworkEmpty2.gameObject.SetActive(value: false);
				yield return HAGIS.DialogShow(Dialog_ArtworkEmpty);
				artworkExamined++;
				continue;
			}
			if (WaitingOnTheplayer.met)
			{
				if (playerHasAlreadyWaited)
				{
					HAGIS.DialogShow(Ambient_ArtworkReminder);
					continue;
				}
				playerHasAlreadyWaited = true;
				yield return HAGIS.DialogShow(Dialog_ArtworkReminder);
				continue;
			}
			if (Artwork1Triggered.met)
			{
				Artwork1.gameObject.SetActive(value: false);
			}
			else if (Artwork2Triggered.met)
			{
				Artwork2.gameObject.SetActive(value: false);
			}
			else if (Artwork3Triggered.met)
			{
				Artwork3.gameObject.SetActive(value: false);
			}
			else if (Artwork4Triggered.met)
			{
				Artwork4.gameObject.SetActive(value: false);
			}
			switch (nonEmptyArtExamined)
			{
			case 0:
				yield return HAGIS.DialogShow(Dialog_Artwork1);
				break;
			case 1:
				yield return HAGIS.DialogShow(Dialog_Artwork2);
				break;
			case 2:
				yield return HAGIS.DialogShow(Dialog_Artwork3);
				break;
			default:
				yield return HAGIS.DialogShow(Dialog_Artwork4);
				break;
			}
			nonEmptyArtExamined++;
			artworkExamined++;
		}
		while (artworkExamined < 3);
		Artwork1.gameObject.SetActive(value: false);
		Artwork2.gameObject.SetActive(value: false);
		Artwork3.gameObject.SetActive(value: false);
		Artwork4.gameObject.SetActive(value: false);
		ArtworkEmpty1.gameObject.SetActive(value: false);
		ArtworkEmpty2.gameObject.SetActive(value: false);
		MarybelleIntro.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return Marybelle.unitModel.Play("CsTransDSitPaintingToDIdlePainting");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdlePainting");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkPainting");
		UnitMoveToTarget(Marybelle, MarybelleReadyToLeave);
		Unit1.LookAt(Marybelle);
		CutsceneEnd();
		yield return HAGIS.DialogShow(Dialog_MarybelleEscort);
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objSkyway);
		SKIP_POINT("leave with Marybelle");
		ExitMuseumEarly.gameObject.SetActive(value: false);
		MuseumToTenorCity.gameObject.SetActive(value: true);
		PlayMapAnimation(TenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainInvisible");
		yield return MapWaitUntilVisible(TenorCityCentre.Map);
		SKIP_POINT("Walking through Tenor City with Marybelle");
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		PlayMapAnimation(TenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainEnter");
		yield return HAGIS.DialogShow(Ambient_WhatAreTheSlumsLike);
		HAGIS.DialogShow(Ambient_HartmanSkyway);
		I_ToSkyway.gameObject.SetActive(value: true);
		yield return I_ToSkyway.OnTriggered;
		yield return HAGIS.DialogShow(Dialog_HartmanFreightElevator);
		GC.Inst.SetRPGLeader(Willa);
		Unit1.SetTeamType(UnitTeam.Type.NPC);
		Unit2.SetTeamType(UnitTeam.Type.NPC);
		Unit3.SetTeamType(UnitTeam.Type.NPC);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		UnitTeleportToMapViaEntranceTile(Unit1, TrainToStation, trainSpot1);
		UnitTeleportToMapViaEntranceTile(Unit2, TrainToStation, trainSpot2);
		UnitTeleportToMapViaEntranceTile(Unit3, TrainToStation, trainSpot3);
		UnitTeleportToMapViaEntranceTile(Marybelle, TrainToStation, trainSpotMary);
		yield return MapGoto(UnderclockHQExterior);
		SKIP_POINT("Willa at Underclock HQ");
		UIObjectives.Inst.CompleteAndSetMainObjective(objGuard);
		MusicPlay("event:/music/tracks/exploration/random light 1");
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return HAGIS.DialogShow(Dialog_WillaAtHQ);
		yield return MapWaitUntilVisible(UnderclockHQRooftop.Map);
		SKIP_POINT("Willa rooftop combat");
		UnderclocksRooftopToExterior.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/basic/light tension 1");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/exploration/random light 1");
		SKIP_POINT("Open the skylight");
		yield return HAGIS.DialogShow(Dialog_WillaRooftopAccess);
		UIObjectives.Inst.CompleteAndSetMainObjective(objOpen);
		yield return CreateTriggerCondition(Crowbar.OnTriggered);
		CutsceneBegin();
		HAGIS.DialogShow(Ambient_LooksGood);
		yield return CreateTimeCondition(1.5f);
		Willa.unitModel.Play("DefaultPickup");
		yield return Wait.ForSeconds(Willa.GetPickupDelay());
		SFXPlayAtCoord("event:/sfx/script/act 2/a2o6/willa picks up pipe", sfx_willa_pickup_crowbar);
		yield return CreateTimeCondition(0.45f);
		CrowbarObject.gameObject.SetActive(value: false);
		Willa.LookInDirection(OctDir.UpRight);
		yield return HAGIS.DialogShow(Dialog_ThatsWeird);
		OpenSkyLight.gameObject.SetActive(value: true);
		UnderclocksSkylight.gameObject.SetActive(value: false);
		D_Window.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return CreateTriggerCondition(OpenSkyLight.OnTriggered);
		CutsceneBegin();
		Willa.unitModel.Play("CsDefaultOpenSkylight");
		yield return PlayMapAnimation(UnderclockHQRooftop.Map, RoofSkylight, "Open");
		yield return HAGIS.DialogShow(Dialog_WillaSkylight);
		yield return null;
		GC.Inst.SetRPGLeader(Unit1);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		CutsceneEnd();
		TrainToStation.gameObject.SetActive(value: false);
		yield return MapGoto(SubwayTrain);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDeliver);
		SKIP_POINT("Team on train");
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		Unit1.SetTeamType(UnitTeam.Type.Player);
		Unit2.SetTeamType(UnitTeam.Type.Player);
		Unit3.SetTeamType(UnitTeam.Type.Player);
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		Unit1.LookAt(Marybelle);
		Unit2.LookAt(Marybelle);
		Unit3.LookAt(Marybelle);
		Marybelle.LookAt(Unit1);
		CutsceneBegin();
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Files_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		CutsceneEnd();
		TrainToStation.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(TheFiles.Map);
		FilesToStation.gameObject.SetActive(value: false);
		SKIP_POINT("files fight");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Close");
		CutsceneBegin();
		FilesFusel1.LookAt(Unit1.coord);
		HAGIS.DialogShow(Ambient_WatchHer);
		UnitMoveToTarget(FilesFusel1, filesEnemyCover1);
		UnitMoveToTarget(FilesFusel2, filesEnemyCover2);
		UnitMoveToTarget(FilesFusel3, filesEnemyCover3);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(Unit2, filesUnitCover4);
		UnitMoveToTarget(Unit3, filesUnitCover3);
		UnitMoveToTarget(Marybelle, filesUnitCover1);
		yield return UnitMoveToTarget(Unit1, filesUnitCover2);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		CutsceneBegin();
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		UnitMoveToTarget(Unit2, filesUnitCover1);
		UnitMoveToTarget(Unit3, filesUnitCover2);
		yield return UnitMoveToTarget(Unit1, T_UnitIdel);
		Unit1.LookInDirection(OctDir.DownRight);
		Unit2.LookAt(Unit1);
		Unit3.LookAt(Unit1);
		HAGIS.DialogShow(Ambient_MarybelleArrived);
		yield return UnitMoveToTarget(Marybelle, filesExchange);
		Marybelle.LookInDirection(OctDir.Left);
		yield return Marybelle.unitModel.Play("CsTransDIdlePaintToDIdle");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return UnitMoveToTarget(Marybelle, afterExchange);
		Marybelle.LookAt(Unit1);
		yield return HAGIS.DialogShow(Dialog_GetTopside);
		HAGIS.DialogShow(Ambient_HartmanBackToSkids);
		CutsceneEnd();
		TheFiles.CanTeammatesFollow = true;
		UIObjectives.Inst.CompleteAndSetMainObjective(objElevator);
		FilesToStation.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		yield return null;
		TrainToStation.gameObject.SetActive(value: false);
		CutsceneBegin();
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_PortHara_L0");
		yield return PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		CutsceneEnd();
		TrainToPortEntrance.gameObject.SetActive(value: true);
		PortHaraEntrance.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(PortHaraEntrance.Map);
		SKIP_POINT("port Combat");
		MusicStop();
		CutsceneBegin();
		PortEntranceToStation.gameObject.SetActive(value: false);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(PortEnemy, T_EnemyCover_Port_ENT, null, 5f);
		UnitMoveToTarget(PortEnemy2, T_EnemyCover_Port_ENT2, null, 5f);
		UnitMoveToTarget(Marybelle, T_Marybelle_Port_ENT, OctDir.UpLeft);
		UnitMoveToTarget(Unit1, T_Ambro_Port_ENT, OctDir.UpLeft);
		yield return CreateTimeCondition(0.5f);
		UnitMoveToTarget(Unit3, T_Chris_Port_ENT, OctDir.UpLeft);
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(Unit2, T_Archi_Port_ENT, OctDir.UpLeft);
		CutsceneEnd();
		yield return null;
		MusicPlay("event:/music/tracks/combat/underclock combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/drone 1");
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		yield return MapWaitUntilVisible(Skids.Map);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		SKIP_POINT("skids stealth");
		yield return CreateAndCondition(UnitMoveToTarget(Marybelle, T_MarybelleIdel), UnitMoveToTarget(Unit2, T_Skids1), UnitMoveToTarget(Unit3, T_Skids2));
		Marybelle.LookInDirection(OctDir.Down);
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		ToElevator.gameObject.SetActive(value: true);
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		SkidsElevator.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(SkidsElevator.Map);
		ElevatorToSkids.gameObject.SetActive(value: false);
		CutsceneBegin();
		UnitMoveToTarget(Unit2, elevatorSpot2);
		UnitMoveToTarget(Unit3, elevatorSpot3);
		UnitMoveToTarget(Marybelle, elevatorSpotMary, OctDir.Up);
		yield return UnitMoveToTarget(Unit1, elevatorSpot1);
		yield return null;
		Unit1.LookAt(Marybelle);
		Unit2.LookAt(Marybelle);
		Unit3.LookAt(Marybelle);
		SKIP_POINT("freight elevator");
		UIObjectives.Inst.CompleteObjective(objElevator);
		MusicPlay("event:/music/tracks/basic/marybelle underscore");
		yield return HAGIS.DialogShow(Dialog_HartmanHitTheSwitch);
		CutsceneEnd();
		FMOD.Studio.EventInstance cogSfxHandle = AC.Inst.PlayOneShot2D("event:/sfx/script/act 2/a2o6/frieght elevator movement");
		CutscenePlay("A2O6_Cutscene_ElevatorCogs");
		CutsceneBegin();
		yield return null;
		elevatorWalls.speed = elevatorSpeed;
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(2f);
		yield return HAGIS.DialogShow(Dialog_MarybelleThanks);
		yield return UnitTeleportToMapViaEntranceTile(Willa, HideoutToChumleys, chumleysWilla);
		yield return CreateTimeCondition(2f);
		yield return MapGoto(ChumleysExterior);
		HAGIS.ToggleShakeEnvironment(on: false);
		MusicStop();
		yield return CreateTimeCondition(0.5f);
		AC.Stop(cogSfxHandle, release: true);
		elevatorWalls.speed = 0f;
		UnitMoveToMapViaExitTile(Unit2, ElevatorToChumleys);
		UnitMoveToMapViaExitTile(Unit3, ElevatorToChumleys);
		UnitMoveToMapViaExitTile(Marybelle, ElevatorToChumleys);
		yield return UnitMoveToMapViaExitTile(Unit1, ElevatorToChumleys);
		ChumleysToElevator.gameObject.SetActive(value: false);
		SKIP_POINT("marybelle leaves");
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		UnitMoveToTarget(Unit1, chumleysUnit1);
		UnitMoveToTarget(Unit2, chumleysUnit2);
		UnitMoveToTarget(Unit3, chumleysUnit3);
		yield return UnitMoveToTarget(Marybelle, chumleysMary1);
		Unit1.LookAt(Marybelle);
		Unit2.LookAt(Marybelle);
		Unit3.LookAt(Marybelle);
		Willa.LookAt(Marybelle);
		Marybelle.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_MarybelleOutro);
		Unit1.SetTeamType(UnitTeam.Type.NPC);
		Unit2.SetTeamType(UnitTeam.Type.NPC);
		Unit3.SetTeamType(UnitTeam.Type.NPC);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		Willa.SetTeamType(UnitTeam.Type.Player);
		UnitMoveToTarget(Marybelle, chumleysMary2);
		yield return CreateTimeCondition(2f);
		UnitMoveToUnit(Willa, Gosz);
		yield return CreateTimeCondition(2.5f);
		Gosz.LookAt(Willa);
		Willa.LookAt(Gosz);
		HAGIS.DialogShow(Dialog_GoszArrives);
		yield return CreateTimeCondition(3.5f);
		Marybelle.gameObject.SetActive(value: false);
		if (!Dialog_GoszArrives.completed && UINarrativeDialog.Inst.CurrDialogData == Dialog_GoszArrives)
		{
			yield return CreateTriggerCondition(Dialog_GoszArrives.OnComplete);
		}
		yield return UnitMoveToMapViaExitTile(Willa, ChumleysToHideout, null, null, faceExit: true);
		yield return UnitMoveToMapViaExitTile(Gosz, ChumleysToHideout, null, null, faceExit: true);
		CutsceneEnd();
		yield return MapGoto(GoszHideout);
		SKIP_POINT("end scene");
		HideoutToChumleys.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/basic/panic room");
		CutsceneBegin();
		UnitMoveToTarget(Willa, WillaEnters);
		Gosz.LookInDirection(OctDir.Left);
		yield return null;
		HAGIS.DialogShow(Dialog_GoszTrashed);
		yield return UnitPlayAnimation(Gosz, "CsLookAround");
		UIObjectives.Inst.AddObjective(objSearch);
		CutsceneEnd();
		yield return null;
		yield return CreateTriggerCondition(I_TableInteraction.OnTriggered);
		CutsceneBegin();
		HAGIS.DialogShow(Dialog_WillaStolen);
		yield return UnitMoveToTarget(Gosz, T_GH_Gosz, null, 5f);
		Willa.LookAt(Gosz);
		Gosz.LookAt(Willa);
		if (!Dialog_WillaStolen.completed && UINarrativeDialog.Inst.CurrDialogData == Dialog_WillaStolen)
		{
			yield return CreateTriggerCondition(Dialog_WillaStolen.OnComplete);
		}
		UnitMoveToTarget(Willa, WillaExit);
		HAGIS.DialogShow(Ambient_WillaDammit);
		yield return null;
		yield return CreateTimeCondition(2f);
		Willa.Hide(makeInactive: true);
		yield return CreateTimeCondition(2f);
		CutsceneEnd();
		yield return null;
	}
}
public class HAGIS_A2O6_Reminder : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		DialogData Dialog_ArtworkReminder2 = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_ArtworkReminder");
		DialogData Dialog_MarybelleIntro = HAGIS.DialogLoad("Dialogs/A2O6/Dialog_MarybelleIntro");
		TileActionHotspot Artwork1 = MR.Inst.GetTileActionHotspot("557_T2TenorCityCentreMall_TileActionHotspot");
		TileActionHotspot Artwork2 = MR.Inst.GetTileActionHotspot("EFE_T2TenorCityCentreMall_TileActionHotspot");
		TileActionHotspot Artwork3 = MR.Inst.GetTileActionHotspot("050_T2TenorCityCentreMall_TileActionHotspot");
		TileActionHotspot Artwork4 = MR.Inst.GetTileActionHotspot("DA3_T2TenorCityCentreMall_TileActionHotspot");
		TileActionInteraction ArtworkEmpty1 = MR.Inst.GetTileActionInteraction("C60_T2TenorCityCentreMall_TileActionInteraction");
		TileActionInteraction ArtworkEmpty2 = MR.Inst.GetTileActionInteraction("372_T2TenorCityCentreMall_TileActionInteraction");
		yield return null;
		yield return Dialog_MarybelleIntro.OnComplete;
		HagletYieldTerm Artwork1Triggered = CreateTriggerCondition(Artwork1.OnHotspotShow);
		HagletYieldTerm Artwork2Triggered = CreateTriggerCondition(Artwork2.OnHotspotShow);
		HagletYieldTerm Artwork3Triggered = CreateTriggerCondition(Artwork3.OnHotspotShow);
		HagletYieldTerm Artwork4Triggered = CreateTriggerCondition(Artwork4.OnHotspotShow);
		HagletYieldTerm ArtworkEmpty1Triggered = CreateTriggerCondition(ArtworkEmpty1.OnTriggered);
		HagletYieldTerm ArtworkEmpty2Triggered = CreateTriggerCondition(ArtworkEmpty2.OnTriggered);
		bool ArtworkInspected = false;
		yield return CreateOrCondition(Artwork1Triggered, Artwork2Triggered, Artwork3Triggered, Artwork4Triggered, ArtworkEmpty1Triggered, ArtworkEmpty2Triggered);
		if (1 == 0)
		{
			yield return CreateTimeCondition(20f);
			yield return HAGIS.DialogShow(Dialog_ArtworkReminder2);
		}
	}
}
public class HAGIS_A2O6_Statues : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		TileActionDialog statueLeft = MR.Inst.GetTileActionDialog("7AF_T2UnderclocksPoliceStation_Exterior_TileActionDialog");
		TileActionDialog statueRight = MR.Inst.GetTileActionDialog("FDE_T2UnderclocksPoliceStation_Exterior_TileActionDialog");
		yield return null;
		yield return CreateOrCondition(statueLeft.OnDialogShow, statueRight.OnDialogShow);
		statueLeft.gameObject.SetActive(value: false);
		statueRight.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A2O7 : HAGIS
{
	private Unit Ambrosia;

	private Unit Margot;

	private Unit Chris;

	private Unit Underclock2;

	private Unit Underclock3;

	private Unit Underclock13;

	private Unit Underclock14;

	private Unit Underclock15;

	private Unit Underclock16;

	private Unit Underclock17;

	private Unit DeadRobot1;

	private Unit DeadRobot2;

	private UnitTarget TargetUC1;

	private UnitTarget TargetUC2;

	private UnitTarget TargetUC3;

	private UnitTarget TargetChrisF1;

	private UnitTarget TargetMargotF1;

	private UnitTarget TargetAmbrosiaF1;

	private UnitTarget TargetCT1;

	private UnitTarget TargetCT2;

	private UnitTarget TargetCT3;

	private UnitTarget TargetCT4;

	private UnitTarget TargetRoof1;

	private UnitTarget TargetRoof2;

	private UnitTarget TargetRoof3;

	private UnitTarget TargetRoof4;

	private UnitTarget Target_TeamCover;

	private UnitTarget Target_TeamCover1;

	private UnitTarget Target_TeamCover2;

	private UnitTarget Target_DroidCover1;

	private UnitTarget Target_DroidCover2;

	private UnitTarget Target_DroidCover3;

	private UnitTarget Target_DroidCover4;

	private UnitTarget Target_AfterFight1;

	private UnitTarget Target_AfterFight2;

	private UnitTarget Target_AfterFight3;

	private UnitTarget T_TCC_Enemy1;

	private UnitTarget T_TCC_Enemy2;

	private UnitTarget T_TCC_Enemy3;

	private UnitTarget Target_Key;

	private TileActionSwapMap RobotToFrission;

	private TileActionSwapMap FrissionToMuseum;

	private TileActionSwapMap FrissionToRobotBay;

	private TileActionSwapMap MuseumToAscension;

	private TileActionSwapMap MuseumToCityCenter;

	private TileActionSwapMap MuseumToFrission;

	private TileActionSwapMap AscensionToMuseum;

	private TileActionSwapMap CityCenterToMuseum;

	private TileActionSwapMap CityCenterToSkway;

	private TileActionSwapMap SkywayToCityCenter;

	private TileActionSwapMap SkywayToUnderclocksEx;

	private TileActionSwapMap UnderClocksToRoof;

	private TileActionSwapMap UnderclocksToSkyway;

	private TileActionSwapMap RoofToStationEx;

	private TileActionSwapMap RoofToClockTower;

	private TileActionSwapMap ClockTowerToRoof;

	private TileActionInteraction VentInteraction;

	private TileTrigger TriggerMuseum;

	private TileTrigger TriggerAscension;

	private TileTrigger TriggerCity;

	private TileTrigger TriggerGrabKey;

	private TileTrigger TriggerLeaveAscension;

	private TileTrigger TriggerSkyway;

	private TileTrigger TriggerRoof;

	private TileActionDialog D_Submarine;

	private TileActionDialog PlanetaryMobile;

	private TileActionDialog Telescope;

	private TileActionDialog MainScreen;

	private TileActionDialog GetKey;

	private TileActionDialog ClockTowerDoor;

	private TileActionHotspot LorelaiStyme;

	private TileActionHotspot H_Key;

	public bool FoughtInMuseum;

	private DialogData dialog_HowsSecurity;

	private DialogData dialog_HowsSecurityCont;

	private DialogData ambient_GotIt;

	private DialogData ambient_GetTheKey;

	private DialogData dialog_CeesOfCake;

	private DialogData ambient_WhatreWeLookingFor;

	private DialogData ambient_ItsQuiet;

	private DialogData dialog_WhatDoesItSay;

	private DialogData dialog_ItsLatin;

	private DialogData dialog_ItsAnAntique;

	private DialogData dialog_StainedLens;

	private DialogData ambient_WhatIsThisPlace;

	private DialogData ambient_SecuritysRebooted;

	private DialogData ambient_MallsClosed;

	private DialogData dialog_WritingBackHere;

	private DialogData ambient_ThatWasOminous;

	private string objToAscension = "OBJECTIVES_A2O7_01";

	private string objLeaveMuseum = "OBJECTIVES_A2O7_02";

	private string objClockTower = "OBJECTIVES_A2O7_03";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot RobotMaintenanceBay = GetLogicUsingArtName("T2RobotMaintenanceBay");
		LogicRoot FissionTechtonicsExhibit = GetLogicUsingArtName("T2FissionTechtonicsExhibit");
		LogicRoot MuseumOfCulture = GetLogicUsingArtName("T2MuseumOfCulture");
		LogicRoot AscensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		LogicRoot TenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot UnderclocksPoliceStation_Exterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclocksPoliceStation_Roof = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot ClockTower = GetLogicUsingArtName("T2ClockTower");
		Chris = GC.Inst.GetUnitWithId("EA3_T2RobotMaintenanceBay_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("094_T2RobotMaintenanceBay_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("440_T2RobotMaintenanceBay_UnitSpawn");
		Underclock2 = GC.Inst.GetUnitWithId("8B5_T2MuseumOfCulture_UnitSpawn");
		Underclock3 = GC.Inst.GetUnitWithId("915_T2FissionTechtonicsExhibit_UnitSpawn");
		Underclock13 = GC.Inst.GetUnitWithId("19A_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Underclock14 = GC.Inst.GetUnitWithId("072_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Underclock15 = GC.Inst.GetUnitWithId("BEA_T2FissionTechtonicsExhibit_UnitSpawn");
		Underclock16 = GC.Inst.GetUnitWithId("FA2_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Underclock17 = GC.Inst.GetUnitWithId("145_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		DeadRobot1 = GC.Inst.GetUnitWithId("915_T2FissionTechtonicsExhibit_UnitSpawn");
		DeadRobot2 = GC.Inst.GetUnitWithId("BEA_T2FissionTechtonicsExhibit_UnitSpawn");
		TargetUC1 = MR.Inst.GetUnitTarget("BEE_T2AscensionExhibit_UnitTarget");
		TargetUC2 = MR.Inst.GetUnitTarget("3AD_T2AscensionExhibit_UnitTarget");
		TargetUC3 = MR.Inst.GetUnitTarget("668_T2AscensionExhibit_UnitTarget");
		TargetChrisF1 = MR.Inst.GetUnitTarget("958_T2FissionTechtonicsExhibit_UnitTarget");
		TargetAmbrosiaF1 = MR.Inst.GetUnitTarget("533_T2FissionTechtonicsExhibit_UnitTarget");
		TargetMargotF1 = MR.Inst.GetUnitTarget("2B1_T2FissionTechtonicsExhibit_UnitTarget");
		TargetCT1 = MR.Inst.GetUnitTarget("164_T2ClockTower_UnitTarget");
		TargetCT2 = MR.Inst.GetUnitTarget("632_T2ClockTower_UnitTarget");
		TargetCT3 = MR.Inst.GetUnitTarget("5B9_T2ClockTower_UnitTarget");
		TargetCT4 = MR.Inst.GetUnitTarget("5C4_T2ClockTower_UnitTarget");
		TargetRoof1 = MR.Inst.GetUnitTarget("D08_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetRoof2 = MR.Inst.GetUnitTarget("D94_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetRoof3 = MR.Inst.GetUnitTarget("874_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetRoof4 = MR.Inst.GetUnitTarget("4A9_T2UnderclocksPoliceStation_Roof_UnitTarget");
		Target_TeamCover = MR.Inst.GetUnitTarget("C8A_T2Skyway_UnitTarget");
		Target_TeamCover1 = MR.Inst.GetUnitTarget("EDE_T2Skyway_UnitTarget");
		Target_TeamCover2 = MR.Inst.GetUnitTarget("DBA_T2Skyway_UnitTarget");
		Target_DroidCover1 = MR.Inst.GetUnitTarget("C94_T2Skyway_UnitTarget");
		Target_DroidCover2 = MR.Inst.GetUnitTarget("58B_T2Skyway_UnitTarget");
		Target_DroidCover3 = MR.Inst.GetUnitTarget("9EA_T2Skyway_UnitTarget");
		Target_DroidCover4 = MR.Inst.GetUnitTarget("36C_T2Skyway_UnitTarget");
		T_TCC_Enemy1 = MR.Inst.GetUnitTarget("2A9_T2TenorCityCentre_UnitTarget");
		T_TCC_Enemy2 = MR.Inst.GetUnitTarget("E3C_T2TenorCityCentre_UnitTarget");
		T_TCC_Enemy3 = MR.Inst.GetUnitTarget("E36_T2TenorCityCentre_UnitTarget");
		Target_AfterFight1 = MR.Inst.GetUnitTarget("CAD_T2Skyway_UnitTarget");
		Target_AfterFight2 = MR.Inst.GetUnitTarget("F67_T2Skyway_UnitTarget");
		Target_AfterFight3 = MR.Inst.GetUnitTarget("FC1_T2Skyway_UnitTarget");
		Target_Key = MR.Inst.GetUnitTarget("4F5_T2AscensionExhibit_UnitTarget");
		UnitTarget T_Chris = MR.Inst.GetUnitTarget("17B_T2MuseumOfCulture_UnderInvestigation_UnitTarget");
		UnitTarget T_Ambrosia = MR.Inst.GetUnitTarget("9E5_T2MuseumOfCulture_UnderInvestigation_UnitTarget");
		UnitTarget T_Margot = MR.Inst.GetUnitTarget("DDA_T2MuseumOfCulture_UnderInvestigation_UnitTarget");
		UnitTarget T_Chris_Centre = MR.Inst.GetUnitTarget("685_T2TenorCityCentre_UnitTarget");
		UnitTarget T_Ambrosia_Centre = MR.Inst.GetUnitTarget("FFD_T2TenorCityCentre_UnitTarget");
		UnitTarget T_Margot_Centre = MR.Inst.GetUnitTarget("EC9_T2TenorCityCentre_UnitTarget");
		UnitTarget sfx_margot_opens_roof_door = MR.Inst.GetUnitTarget("01C_T2UnderclocksPoliceStation_Roof_UnitTarget");
		UnitTarget sfx_margot_obtains_bugsy_key = MR.Inst.GetUnitTarget("8C7_T2AscensionExhibit_UnitTarget");
		RobotToFrission = MR.Inst.GetTileActionSwapMap("181_T2RobotMaintenanceBay_TileActionSwapMap");
		FrissionToMuseum = MR.Inst.GetTileActionSwapMap("F66_T2FissionTechtonicsExhibit_TileActionSwapMap");
		FrissionToRobotBay = MR.Inst.GetTileActionSwapMap("876_T2FissionTechtonicsExhibit_TileActionSwapMap");
		MuseumToAscension = MR.Inst.GetTileActionSwapMap("741_T2MuseumOfCulture_UnderInvestigation_TileActionSwapMap");
		MuseumToCityCenter = MR.Inst.GetTileActionSwapMap("141_T2FissionTechtonicsExhibit_TileActionSwapMap");
		MuseumToFrission = MR.Inst.GetTileActionSwapMap("A9A_T2MuseumOfCulture_TileActionSwapMap");
		AscensionToMuseum = MR.Inst.GetTileActionSwapMap("9B3_T2AscensionExhibit_TileActionSwapMap");
		CityCenterToMuseum = MR.Inst.GetTileActionSwapMap("875_T2TenorCityCentre_TileActionSwapMap");
		CityCenterToSkway = MR.Inst.GetTileActionSwapMap("BC9_T2TenorCityCentre_TileActionSwapMap");
		SkywayToCityCenter = MR.Inst.GetTileActionSwapMap("7A2_T2Skyway_TileActionSwapMap");
		SkywayToUnderclocksEx = MR.Inst.GetTileActionSwapMap("278_T2Skyway_TileActionSwapMap");
		UnderClocksToRoof = MR.Inst.GetTileActionSwapMap("60A_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		UnderclocksToSkyway = MR.Inst.GetTileActionSwapMap("037_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		RoofToStationEx = MR.Inst.GetTileActionSwapMap("202_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		RoofToClockTower = MR.Inst.GetTileActionSwapMap("BC2_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		ClockTowerToRoof = MR.Inst.GetTileActionSwapMap("37B_T2ClockTower_TileActionSwapMap");
		ClockTowerDoor = MR.Inst.GetTileActionDialog("8FC_T2UnderclocksPoliceStation_Roof_TileActionDialog");
		PlanetaryMobile = MR.Inst.GetTileActionDialog("FE8_T2ClockTower_TileActionDialog");
		Telescope = MR.Inst.GetTileActionDialog("B3D_T2ClockTower_TileActionDialog");
		MainScreen = MR.Inst.GetTileActionDialog("5CF_T2ClockTower_TileActionDialog");
		D_Submarine = MR.Inst.GetTileActionDialog("6E2_T2FissionTechtonicsExhibit_TileActionDialog");
		LorelaiStyme = MR.Inst.GetTileActionHotspot("CA6_T2ClockTower_TileActionHotspot");
		H_Key = MR.Inst.GetTileActionHotspot("265_T2AscensionExhibit_TileActionHotspot");
		ambient_MallsClosed = HAGIS.DialogLoad("Dialogs/A2O7/TenorCityCentre/AmbientMallsClosed");
		dialog_HowsSecurity = HAGIS.DialogLoad("Dialogs/A2O7/RobotMaintenanceBay/DialogHowsSecurity");
		dialog_HowsSecurityCont = HAGIS.DialogLoad("Dialogs/A2O7/RobotMaintenanceBay/DialogHowsSecurityCont");
		ambient_GotIt = HAGIS.DialogLoad("Dialogs/A2O7/AscensionExhibit/AmbientGotIt");
		ambient_GetTheKey = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientGetTheKey");
		dialog_CeesOfCake = HAGIS.DialogLoad("Dialogs/A2O7/Skywalk/DialogCeesOfCake");
		ambient_ItsQuiet = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/Ambient_ItsQuiet");
		dialog_WhatDoesItSay = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/DialogWhatDoesItSay");
		dialog_ItsLatin = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/Dialog_ItsLatin");
		dialog_ItsAnAntique = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/Dialog_ItsAnAntique");
		dialog_StainedLens = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/DialogStainedLens");
		ambient_WhatIsThisPlace = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientWhatIsThisPlace");
		ambient_SecuritysRebooted = HAGIS.DialogLoad("Dialogs/A2O7/AscensionExhibit/AmbientSecuritysRebooted");
		ambient_ThatWasOminous = HAGIS.DialogLoad("Dialogs/A2O7/AscensionExhibit/AmbientThatWasOminous");
		ambient_WhatreWeLookingFor = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/AmbientWhatreWeLookingFor");
		dialog_WritingBackHere = HAGIS.DialogLoad("Dialogs/A2O7/UnderclocksStation/DialogWritingBackHere");
		SkywayToCityCenter.gameObject.SetActive(value: false);
		SkywayToUnderclocksEx.gameObject.SetActive(value: false);
		ClockTowerDoor.gameObject.SetActive(value: false);
		PlanetaryMobile.gameObject.SetActive(value: false);
		Telescope.gameObject.SetActive(value: false);
		MainScreen.gameObject.SetActive(value: false);
		RobotToFrission.gameObject.SetActive(value: false);
		Underclock16.gameObject.SetActive(value: false);
		RoofToClockTower.gameObject.SetActive(value: false);
		MuseumToCityCenter.gameObject.SetActive(value: false);
		MuseumToAscension.gameObject.SetActive(value: false);
		MuseumToFrission.gameObject.SetActive(value: false);
		UnderclocksToSkyway.gameObject.SetActive(value: false);
		PlayMapAnimation(TenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainInvisible");
		yield return null;
		MusicStop();
		yield return CutscenePlay("A2O7_Cutscene_MissionPrep");
		RobotToFrission.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objToAscension);
		RobotMaintenanceBay.CanTeammatesFollow = true;
		SKIP_POINT("Skiped initial cutscene");
		yield return MapWaitUntilVisible(FissionTechtonicsExhibit.Map);
		FissionTechtonicsExhibit.CanTeammatesFollow = true;
		FrissionToRobotBay.gameObject.SetActive(value: false);
		HAGIS.DialogShow(ambient_WhatIsThisPlace);
		yield return MapWaitUntilVisible(MuseumOfCulture.Map);
		yield return CreateAndCondition(UnitMoveToTarget(Chris, T_Chris), UnitMoveToTarget(Ambrosia, T_Ambrosia));
		Chris.LookInDirection(OctDir.Up);
		Ambrosia.LookInDirection(OctDir.Right);
		MuseumToAscension.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(AscensionExhibit.Map);
		AscensionToMuseum.gameObject.SetActive(value: false);
		AscensionExhibit.CanTeammatesFollow = true;
		SKIP_POINT("About to collect key");
		yield return CreateTriggerCondition(H_Key.OnHotspotComplete);
		CutsceneBegin();
		Margot.unitModel.Play("DefaultInteract");
		yield return CreateTimeCondition(0.5f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2o7/margot picks up key", sfx_margot_obtains_bugsy_key);
		yield return CreateTimeCondition(0.35f);
		Margot.UpdateIdleAnim();
		Target_Key.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(ambient_GotIt);
		SFXPlay("event:/sfx/script/act 2/a2o7/security reboots");
		yield return CreateTimeCondition(2.5f);
		yield return HAGIS.DialogShow(ambient_ThatWasOminous);
		Underclock15.SetTeamType(UnitTeam.Type.Enemy);
		Underclock3.SetTeamType(UnitTeam.Type.Enemy);
		Underclock2.SetTeamType(UnitTeam.Type.Enemy);
		Underclock15.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Underclock3.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Underclock2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Underclock15.UpdateIdleAnim();
		Underclock3.UpdateIdleAnim();
		Underclock2.UpdateIdleAnim();
		yield return null;
		CutsceneEnd();
		AscensionToMuseum.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objLeaveMuseum);
		MuseumToAscension.gameObject.SetActive(value: false);
		FrissionToMuseum.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(MuseumOfCulture.Map);
		MusicPlay("event:/music/tracks/combat/generic combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		MuseumToFrission.gameObject.SetActive(value: true);
		SKIP_POINT("Skiped moving back to museum");
		yield return MapWaitUntilVisible(FissionTechtonicsExhibit.Map);
		D_Submarine.gameObject.SetActive(value: false);
		MuseumToCityCenter.gameObject.SetActive(value: true);
		SKIP_POINT("Skiped moving back to Frission");
		yield return MapWaitUntilVisible(TenorCityCentre.Map);
		UIObjectives.Inst.CompleteObjective(objLeaveMuseum);
		SKIP_POINT("Skiped Escaping Museum");
		CityCenterToMuseum.gameObject.SetActive(value: false);
		CityCenterToSkway.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/combat/underclocks");
		CombatBegin(UnitTeam.Type.Player);
		UnitMoveToTarget(Chris, T_Chris_Centre);
		UnitMoveToTarget(Ambrosia, T_Ambrosia_Centre);
		yield return UnitMoveToTarget(Margot, T_Margot_Centre);
		yield return CombatWaitUntilComplete();
		MusicPlay("event:/music/tracks/basic/drone 2");
		yield return CreateTimeCondition(1f);
		SKIP_POINT("Skiped enemies in Tenor City");
		yield return PlayMapAnimation(TenorCityCentre.Map, "MA_TenorCityCentre_Train", "TrainEnter");
		CityCenterToSkway.gameObject.SetActive(value: true);
		HAGIS.DialogShow(ambient_MallsClosed);
		TenorCityCentre.CanTeammatesFollow = true;
		yield return MapWaitUntilVisible(Skyway.Map);
		SKIP_POINT("Skiped getting to skyway");
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return HAGIS.DialogShow(dialog_CeesOfCake);
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_WatchHQ_L0");
		UIObjectives.Inst.CompleteAndSetMainObjective(objClockTower);
		Skyway.CanTeammatesFollow = true;
		SkywayToUnderclocksEx.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(UnderclocksPoliceStation_Exterior.Map);
		UnderclocksPoliceStation_Exterior.CanTeammatesFollow = true;
		SKIP_POINT("Skiped getting to Underclock exterior");
		HAGIS.DialogShow(ambient_ItsQuiet);
		UnderclocksToSkyway.gameObject.SetActive(value: false);
		UnderClocksToRoof.gameObject.SetActive(value: false);
		UnderClocksToRoof.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(UnderclocksPoliceStation_Roof.Map);
		SKIP_POINT("Skiped getting to Underclock roof");
		RoofToStationEx.gameObject.SetActive(value: false);
		UnitMoveToTarget(Underclock13, TargetRoof3);
		UnitMoveToTarget(Underclock14, TargetRoof4);
		UnitMoveToTarget(Underclock17, TargetRoof2);
		MusicPlay("event:/music/tracks/combat/underclocks");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		ClockTowerDoor.gameObject.SetActive(value: true);
		UnderclocksPoliceStation_Roof.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(ClockTowerDoor.OnDialogComplete);
		CutsceneBegin();
		Margot.unitModel.Play("DefaultInteract");
		yield return CreateTimeCondition(0.7f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2o7/margot unlocks roof door", sfx_margot_opens_roof_door);
		yield return CreateTimeCondition(0.6f);
		Margot.UpdateIdleAnim();
		yield return TeamMoveToMapViaEntranceTile(ClockTowerToRoof);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/basic/three heads are better");
		yield return null;
		SKIP_POINT("Skiped getting into Clock tower");
		UIObjectives.Inst.CompleteObjective(objClockTower);
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_WhatreWeLookingFor);
		yield return Margot.unitModel.Play("CsTransDIdleToMartini");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultMartini");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CsDefaultMartiniWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultMartiniWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "CsDefaultMartiniPickUp");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultInteract, "CsDefaultMartiniInteract");
		Margot.UpdateIdleAnim();
		Margot.LookInDirection(OctDir.Up);
		Margot.charData.movementSpeed = 2f;
		CutsceneEnd();
		ClockTower.CanTeammatesFollow = true;
		PlanetaryMobile.gameObject.SetActive(value: true);
		Telescope.gameObject.SetActive(value: true);
		MainScreen.gameObject.SetActive(value: true);
		ClockTowerToRoof.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(LorelaiStyme.OnHotspotComplete);
		yield return HAGIS.DialogShow(dialog_WritingBackHere);
		yield return Margot.unitModel.Play("CsTransMartiniToDIdlePutAway");
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultSlowWalk);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultPickup);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultInteract);
		Margot.UpdateIdleAnim();
		Margot.charData.movementSpeed = 4.5f;
		yield return CutscenePlay("A2O7_Cutscene_StatueBreaks");
		SKIP_POINT("Skiped Cutscene_StatueBreaks");
		yield return CutscenePlay("A2O7_Cutscene_TeamLeaves");
	}
}
public class HAGIS_A2O7_Curtains : HAGIS
{
	private TileActionDialog curtainDialog;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		curtainDialog = MR.Inst.GetTileActionDialog("699_T2AscensionExhibit_TileActionDialog");
		LogicRoot ascensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		yield return null;
		yield return CreateTriggerCondition(curtainDialog.OnDialogShow);
		PlayMapAnimation(ascensionExhibit.Map, "CH_AscensionCurtain", "Open");
	}
}
public class HAGIS_A2O7_TimeToGo : HAGIS
{
	private DialogData ambient_GiantGoldBall;

	private DialogData ambient_AtomicBomb;

	private DialogData ambient_Submarine;

	private DialogData ambient_DeusoftDroids;

	private DialogData ambient_TwoInteractions;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		ambient_GiantGoldBall = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientGiantGoldBall");
		ambient_AtomicBomb = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientAtomicBomb");
		ambient_Submarine = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientSubmarine");
		ambient_DeusoftDroids = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientDeusoftDroids");
		ambient_TwoInteractions = HAGIS.DialogLoad("Dialogs/A2O7/MuseumOfCulturalHistory/AmbientTwoInteractions");
		yield return null;
		int Triggers = 0;
		while (true)
		{
			yield return CreateOrCondition(CreateTriggerCondition(ambient_GiantGoldBall.OnComplete), CreateTriggerCondition(ambient_AtomicBomb.OnComplete), CreateTriggerCondition(ambient_Submarine.OnComplete), CreateTriggerCondition(ambient_DeusoftDroids.OnComplete));
			int num;
			Triggers = (num = Triggers + 1);
			switch (num)
			{
			case 1:
				break;
			default:
				yield break;
			case 2:
				yield return CreateTimeCondition(1f);
				yield return HAGIS.DialogShow(ambient_TwoInteractions);
				yield break;
			}
		}
	}
}
public class HAGIS_A2S1 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Margot;

	private Unit Noot;

	private Unit Ambrosia;

	private Unit Chris;

	private Unit Ulysses;

	private Unit playerChoice2;

	private Unit playerChoice3;

	private Unit playerChoice4;

	private Unit playerChoice5;

	private Unit Goon1;

	private Unit Goon2;

	private Unit Goon3;

	private Unit Goon4;

	private Unit Goon5;

	private Unit Goon7;

	private Unit Goon8;

	private Unit Goon9;

	private Unit Goon10;

	private Unit Goon11;

	private Unit S_Goon1;

	private Unit S_Goon2;

	private Unit S_Goon3;

	private Unit Turret1;

	private Unit Turret2;

	private Unit Guard;

	private Unit Theo;

	private Unit Underclock1;

	private Unit Underclock2;

	private Unit ScaredGaurd;

	private Unit SpawnSoldier;

	private Unit SpawnTrigger;

	private Unit Eugene;

	[HideInInspector]
	public Unit playerChoice1;

	private UnitTarget TargetWillaFromVault;

	private UnitTarget TargetNootPltInt;

	private UnitTarget TargetChrisPltInt;

	private UnitTarget TargetMargotPltInt;

	private UnitTarget TargetConsole;

	private UnitTarget TargetAmbroEnters;

	private UnitTarget TargetNootPltExt;

	private UnitTarget TargetGoon1;

	private UnitTarget TargetGoon2;

	private UnitTarget TargetGoon3;

	private UnitTarget TargetGoon4;

	private UnitTarget TargetGoon5;

	private UnitTarget TargetGoon6;

	private UnitTarget TargetGoon7;

	private UnitTarget TargetTheoPortEnt;

	private UnitTarget TargetUC1PortEnt;

	private UnitTarget TargetUC2PortEnt;

	private UnitTarget T_AmbroWatchesNoot;

	private UnitTarget T_NootRunsToControls;

	private UnitTarget T_NootPostKaydockIntFight;

	private UnitTarget T_ChrisPostKaydockIntFight;

	private UnitTarget T_MargotPostKaydockIntFight;

	private UnitTarget TargetSPCharacter1;

	private UnitTarget TargetSPCharacter2;

	private UnitTarget TargetSPCharacter3;

	private UnitTarget TargetSKGuard;

	private UnitTarget TargetFEWilla;

	private UnitTarget TargetFE1;

	private UnitTarget TargetFE2;

	private UnitTarget TargetFE3;

	private UnitTarget TargetFEMus;

	private UnitTarget TargetFE4;

	private UnitTarget TargetFE5;

	private UnitTarget TargetFE6;

	private UnitTarget TargetFE7;

	private UnitTarget TargetFE8;

	private UnitTarget TargetFE9;

	private UnitTarget TargetFE10;

	private UnitTarget TargetFE11;

	private UnitTarget TargetFE12;

	private UnitTarget TargetWillaDodge;

	private UnitTarget TargetRegroup1;

	private UnitTarget TargetRegroup2;

	private UnitTarget TargetRegroup3;

	private UnitTarget TargetRegroup4;

	private UnitTarget TargetPHGuard;

	private UnitTarget TargetPHGoon1;

	private UnitTarget TargetPHGoon2;

	private UnitTarget T_Noot_Skids;

	private UnitTarget T_Ambro_Skids;

	private UnitTarget T_Goons_Skids;

	private UnitTarget T_TheGoonThatDidntMakeIt;

	private UnitTarget T_AmbroAttacksFourthGoon;

	private UnitTarget T_Willa_Chum;

	private UnitTarget T_Chris_Chum;

	private UnitTarget T_Margot_Chum;

	private UnitTarget T_Archi_Chum;

	private UnitTarget T_Archi_WRoom;

	private UnitTarget T_Archi_WRoom_Letter;

	private UnitTarget T_Chris_WRoom;

	private UnitTarget T_Margot_WRoom;

	private UnitTarget T_P1_Train1;

	private UnitTarget T_P2_Train1;

	private UnitTarget T_P3_Train1;

	private UnitTarget T_All_Train2;

	private UnitTarget T_Willa_Port;

	private UnitTarget T_Willa_Skyway;

	private UnitTarget TargetViolin;

	private UnitTarget TargetViolinWillas;

	private UnitTarget TargetWillaPutsDownViolinAtHome;

	private UnitTarget TargetArchiStepsAside;

	private TileActionSwapMap VaultEnToContolRoom;

	private TileActionSwapMap ControlRoomToPlantEXT;

	private TileActionSwapMap ControlRoomToVaultEnt;

	private TileActionSwapMap PlantExtToControlRoom;

	private TileActionSwapMap PlatExtToSubway;

	private TileActionSwapMap SubwayPlantToCarriage1;

	private TileActionSwapMap SubwayPlantToPlantEXT;

	private TileActionSwapMap Carriage1ToCarriage2;

	private TileActionSwapMap Carriage1ToStationPlant;

	private TileActionSwapMap Carriage2ToCarriage1;

	private TileActionSwapMap Carriage2ToPortHaraEnt;

	private TileActionSwapMap PortEntToSkids;

	private TileActionSwapMap PortEntToSubway;

	private TileActionSwapMap SkidsToFreightElevator;

	private TileActionSwapMap SkidsToPortEnt;

	private TileActionSwapMap ElevatorToChumsExt;

	private TileActionSwapMap ElevatorToSkids;

	private TileActionSwapMap ChumsExtToFreightElevator;

	private TileActionSwapMap ChumsExtToWillasRoom;

	private TileActionSwapMap WillasRoomToChums;

	private TileActionSwapMap SkywayToChumleys;

	private TileActionSwapMap SkywayToWillas;

	private TileActionInteraction MineElevatorInteraction;

	private TileActionInteraction ToTrainInteraction;

	private TileActionInteraction I_SkywayToWillas;

	private TileActionInteraction I_Letter;

	private TileActionInteraction InteractionHack1;

	private TileActionInteraction InteractionHack2;

	private TileTrigger TT_Willa_Chum;

	private TileTrigger TT_LeaveTrain;

	private TileActionDialog D_Food;

	private TileActionDialog D_HisGlasses;

	private TileActionDialog D_Pack;

	private TileActionDialog D_TV;

	private TileActionDialog D_Lamp;

	private TileActionDialog D_Hoody;

	private TileActionDialog D_FamilyPhotos;

	private TileActionDialog D_BalconyDoor;

	private DialogData Ambient_FiveYears;

	private DialogData Dialog_TheSkywayWillTakeUs;

	private DialogData Dialog_HowdHeFindUs;

	private DialogData Dialog_ItsMund;

	private DialogData Dialog_ItsMund_1;

	private DialogData Ambient_KeepAnEyeOnHer;

	private DialogData Ambient_BringIt;

	private DialogData Dialog_Willa;

	private DialogData Ambient_Shit;

	private DialogData Ambient_OldAugs;

	private DialogData Ambient_HeadingNorth;

	private DialogData Ambient_DunnoWhyYouWereWorried;

	private DialogData Dialog_JustGottaGetThisMoving;

	private DialogData Ambient_SeeYouRealSoon;

	private DialogData Ambient_OhNo;

	private DialogData Dialog_ItsTheOnlyWay;

	private DialogData Dialog_AreWeToast;

	private DialogData Dialog_CatchYouThere;

	private DialogData Dialog_StopProtectingHer;

	private DialogData Ambient_GetToTheSubway;

	private DialogData Dialog_AfterTonight;

	private DialogData Dialog_WantMeToTakeThat;

	private DialogData Dialog_IAmShocked;

	private DialogData Dialog_IOwnDetritum;

	private DialogData Dialog_WillaItsMe;

	private DialogData Dialog_LastCall;

	private DialogData Ambient_TheSkids;

	private DialogData Ambient_Go;

	private DialogData Ambient_Crap;

	private DialogData Ambient_HesComing;

	private DialogData Ambient_ItsThatMonolith;

	private DialogData Ambient_Graaah;

	private DialogData Ambient_YourStop;

	private DialogData Ambient_Graaah2;

	private DialogData Ambient_GetOn;

	private DialogData Ambient_MundCantBeFar;

	private DialogData Dialog_ThisArrangement;

	private DialogData Ambient_WarningAnnouncer;

	private DialogData Dialog_WeTrapped;

	private DialogData Ambient_HisReadingGlasses;

	private DialogData Ambient_What;

	private DialogData Ambient_DadQuieter;

	private DialogData Dialog_YourGonnaStopThem;

	private DialogData Ambient_ItsMouldy;

	private DialogData Ambient_DadShaky;

	private DialogData Dialog_DadImHome;

	private DialogData Dialog_LetsBurnItDown;

	private DialogData Dialog_ItsAWarrant;

	private DialogData Dialog_ShesDevastated;

	private DialogData Ambient_FeelsLIkeMonths;

	private DialogData Dialog_HitTheControls;

	private DialogData Ambient_Hoody;

	private DialogData Ambient_BalconyDoor;

	private DialogData Ambient_FamilyPhotos;

	private DialogData Ambient_Lamp;

	private DialogData Ambient_HeDidntPack;

	private DialogData Dialog_TheArrestOfBenard;

	private DialogData Dialog_WhatTeam;

	private DialogData Ambient_GetReady;

	private DialogData Ambient_OrNot;

	private DialogData Dialog_YouMollysFriend;

	private string objReturn = "OBJECTIVES_A2S1_01";

	private string objConsole = "OBJECTIVES_A2S1_02";

	private string objFuselGang = "OBJECTIVES_A2S1_03";

	private string objElevator = "OBJECTIVES_A2S1_04";

	private string objCityWatch = "OBJECTIVES_A2S1_05";

	private string objControls = "OBJECTIVES_A2S1_06";

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = -3f;

	[HideInInspector]
	public HagletTrigger ht_EnemiesKilled1 = new HagletTrigger();

	public HagletTrigger ht_EnemiesKilled2 = new HagletTrigger();

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HAGIS_A2S1_Ulysses Hagis_Ulysses = MR.Inst.GetHagis<HAGIS_A2S1_Ulysses>();
		LogicRoot VaultEntrance = GetLogicUsingArtName("T1VaultEntrance");
		LogicRoot KaydockPlantExt = GetLogicUsingArtName("T1Kaydock_PlantExterior_Cars");
		LogicRoot KaydockPlantInt = GetLogicUsingArtName("T1Kaydock_ControlRoom");
		LogicRoot SubwayStationPlant = GetLogicUsingArtName("T1Subway_Station_Kaydock");
		LogicRoot SubwayTrain1 = GetLogicUsingArtName("T1Subway_TrainInterior2");
		LogicRoot SubwayTrain2 = GetLogicUsingArtName("T1Subway_TrainInterior3");
		LogicRoot PortHaraEnt = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot TheSkids = GetLogicUsingArtName("T1TheSkids");
		LogicRoot FreightElevator = GetLogicUsingArtName("T1FreightElevator");
		LogicRoot ChumFactoryExt = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot WillasRoom = GetLogicUsingArtName("T2WillasRoom");
		Willa = GC.Inst.GetUnitWithId("82D_T1VaultEntrance_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("873_T1VaultEntrance_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("7BA_T1Kaydock_ControlRoom_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("CC0_T1Kaydock_ControlRoom_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("9A6_T1VaultEntrance_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("727_T1Kaydock_ControlRoom_UnitSpawn");
		Ulysses = GC.Inst.GetUnitWithId("FAD_T1Subway_TrainInterior2_UnitSpawn");
		Goon1 = GC.Inst.GetUnitWithId("0E2_T1Kaydock_ControlRoom_UnitSpawn");
		Goon2 = GC.Inst.GetUnitWithId("082_T1Kaydock_ControlRoom_UnitSpawn");
		Goon3 = GC.Inst.GetUnitWithId("B98_T1Kaydock_ControlRoom_UnitSpawn");
		Goon4 = GC.Inst.GetUnitWithId("62B_T1Kaydock_PlantExterior_Cars_UnitSpawn");
		Goon5 = GC.Inst.GetUnitWithId("23D_T1Kaydock_PlantExterior_Cars_UnitSpawn");
		Goon7 = GC.Inst.GetUnitWithId("FF9_T1Kaydock_PlantExterior_Cars_UnitSpawn");
		Goon8 = GC.Inst.GetUnitWithId("9F5_T1Subway_TrainInterior2_UnitSpawn");
		Goon9 = GC.Inst.GetUnitWithId("661_T1Subway_TrainInterior2_UnitSpawn");
		Goon10 = GC.Inst.GetUnitWithId("460_T1Subway_TrainInterior3_UnitSpawn");
		Goon11 = GC.Inst.GetUnitWithId("725_T1Subway_TrainInterior_UnitSpawn");
		S_Goon1 = GC.Inst.GetUnitWithId("C6A_T1TheSkids_UnitSpawn");
		S_Goon2 = GC.Inst.GetUnitWithId("A7F_T1TheSkids_UnitSpawn");
		S_Goon3 = GC.Inst.GetUnitWithId("91A_T1TheSkids_UnitSpawn");
		Turret1 = GC.Inst.GetUnitWithId("579_T1Kaydock_PlantExterior_Cars_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("831_T1Kaydock_PlantExterior_Cars_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("88F_T1Port1_HaraEntrance_UnitSpawn");
		Underclock1 = GC.Inst.GetUnitWithId("FB7_T1Port1_HaraEntrance_UnitSpawn");
		Underclock2 = GC.Inst.GetUnitWithId("225_T1Port1_HaraEntrance_UnitSpawn");
		Eugene = GC.Inst.GetUnitWithId("8E9_T1Port1_HaraEntrance_UnitSpawn");
		Guard = GC.Inst.GetUnitWithId("A07_T1TheSkids_UnitSpawn");
		ScaredGaurd = GC.Inst.GetUnitWithId("4BD_T1Port1_HaraEntrance_UnitSpawn");
		SpawnSoldier = GC.Inst.GetUnitWithId("A84_T1Port1_HaraEntrance_UnitSpawn");
		SpawnTrigger = GC.Inst.GetUnitWithId("16A_T1Port1_HaraEntrance_UnitSpawn");
		TargetNootPltInt = MR.Inst.GetUnitTarget("800_T1Kaydock_ControlRoom_UnitTarget");
		TargetChrisPltInt = MR.Inst.GetUnitTarget("D94_T1Kaydock_ControlRoom_UnitTarget");
		TargetMargotPltInt = MR.Inst.GetUnitTarget("0CB_T1Kaydock_ControlRoom_UnitTarget");
		TargetConsole = MR.Inst.GetUnitTarget("F5B_T1Kaydock_ControlRoom_UnitTarget");
		TargetNootPltExt = MR.Inst.GetUnitTarget("430_T1Kaydock_PlantExterior_Cars_UnitTarget");
		TargetAmbroEnters = MR.Inst.GetUnitTarget("B22_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget CarriageExit1 = MR.Inst.GetUnitTarget("D06_T1Subway_TrainInterior2_UnitTarget");
		UnitTarget CarriageExit2 = MR.Inst.GetUnitTarget("F16_T1Subway_TrainInterior2_UnitTarget");
		UnitTarget CarriageExit3 = MR.Inst.GetUnitTarget("B5A_T1Subway_TrainInterior2_UnitTarget");
		UnitTarget CarriageExit4 = MR.Inst.GetUnitTarget("59A_T1Subway_TrainInterior3_UnitTarget");
		UnitTarget CarriageExit5 = MR.Inst.GetUnitTarget("813_T1Subway_TrainInterior3_UnitTarget");
		UnitTarget CarriageExit6 = MR.Inst.GetUnitTarget("D76_T1Subway_TrainInterior3_UnitTarget");
		UnitTarget T_SelectedPlayer1 = MR.Inst.GetUnitTarget("2B7_T1Kaydock_PlantExterior_Cars_UnitTarget");
		UnitTarget T_SelectedPlayer2 = MR.Inst.GetUnitTarget("368_T1Kaydock_PlantExterior_Cars_UnitTarget");
		TargetWillaFromVault = MR.Inst.GetUnitTarget("E95_T1VaultEntrance_UnitTarget");
		TargetGoon1 = MR.Inst.GetUnitTarget("E27_T1Kaydock_ControlRoom_UnitTarget");
		TargetGoon2 = MR.Inst.GetUnitTarget("E1F_T1Kaydock_ControlRoom_UnitTarget");
		TargetGoon3 = MR.Inst.GetUnitTarget("C30_T1Kaydock_ControlRoom_UnitTarget");
		TargetGoon4 = MR.Inst.GetUnitTarget("603_T1Kaydock_PlantExterior_Cars_UnitTarget");
		TargetGoon5 = MR.Inst.GetUnitTarget("720_T1Kaydock_PlantExterior_Cars_UnitTarget");
		TargetGoon7 = MR.Inst.GetUnitTarget("C65_T1Kaydock_PlantExterior_Cars_UnitTarget");
		TargetSPCharacter1 = MR.Inst.GetUnitTarget("586_T1Port1_HaraEntrance_UnitTarget");
		TargetSPCharacter2 = MR.Inst.GetUnitTarget("7FD_T1Port1_HaraEntrance_UnitTarget");
		TargetSPCharacter3 = MR.Inst.GetUnitTarget("FFE_T1Port1_HaraEntrance_UnitTarget");
		TargetTheoPortEnt = MR.Inst.GetUnitTarget("FCC_T1Port1_HaraEntrance_UnitTarget");
		TargetUC1PortEnt = MR.Inst.GetUnitTarget("428_T1Port1_HaraEntrance_UnitTarget");
		TargetUC2PortEnt = MR.Inst.GetUnitTarget("1F0_T1Port1_HaraEntrance_UnitTarget");
		T_AmbroWatchesNoot = MR.Inst.GetUnitTarget("256_T1TheSkids_UnitTarget");
		T_NootRunsToControls = MR.Inst.GetUnitTarget("1A6_T1TheSkids_UnitTarget");
		T_NootPostKaydockIntFight = MR.Inst.GetUnitTarget("587_T1Kaydock_ControlRoom_UnitTarget");
		T_ChrisPostKaydockIntFight = MR.Inst.GetUnitTarget("1AA_T1Kaydock_ControlRoom_UnitTarget");
		T_MargotPostKaydockIntFight = MR.Inst.GetUnitTarget("438_T1Kaydock_ControlRoom_UnitTarget");
		TargetSKGuard = MR.Inst.GetUnitTarget("BE5_T1TheSkids_UnitTarget");
		TargetFEWilla = MR.Inst.GetUnitTarget("953_T1FreightElevator_UnitTarget");
		TargetFE1 = MR.Inst.GetUnitTarget("1C3_T1FreightElevator_UnitTarget");
		TargetFE2 = MR.Inst.GetUnitTarget("4E9_T1FreightElevator_UnitTarget");
		TargetFE3 = MR.Inst.GetUnitTarget("0E9_T1FreightElevator_UnitTarget");
		TargetFEMus = MR.Inst.GetUnitTarget("ECC_T1FreightElevator_UnitTarget");
		TargetFE4 = MR.Inst.GetUnitTarget("31E_T1FreightElevator_UnitTarget");
		TargetFE5 = MR.Inst.GetUnitTarget("026_T1FreightElevator_UnitTarget");
		TargetFE6 = MR.Inst.GetUnitTarget("EA9_T1FreightElevator_UnitTarget");
		TargetFE7 = MR.Inst.GetUnitTarget("F66_T1FreightElevator_UnitTarget");
		TargetFE8 = MR.Inst.GetUnitTarget("FA5_T1FreightElevator_UnitTarget");
		TargetFE9 = MR.Inst.GetUnitTarget("7C2_T1FreightElevator_UnitTarget");
		TargetFE10 = MR.Inst.GetUnitTarget("332_T1FreightElevator_UnitTarget");
		TargetFE11 = MR.Inst.GetUnitTarget("F48_T1FreightElevator_UnitTarget");
		TargetFE12 = MR.Inst.GetUnitTarget("E78_T1FreightElevator_UnitTarget");
		TargetWillaDodge = MR.Inst.GetUnitTarget("886_T1FreightElevator_UnitTarget");
		TargetRegroup1 = MR.Inst.GetUnitTarget("BF5_T1FreightElevator_UnitTarget");
		TargetRegroup2 = MR.Inst.GetUnitTarget("8E2_T1FreightElevator_UnitTarget");
		TargetRegroup3 = MR.Inst.GetUnitTarget("6E4_T1FreightElevator_UnitTarget");
		TargetRegroup4 = MR.Inst.GetUnitTarget("A2B_T1FreightElevator_UnitTarget");
		TargetPHGuard = MR.Inst.GetUnitTarget("769_T1Port1_HaraEntrance_UnitTarget");
		TargetPHGoon1 = MR.Inst.GetUnitTarget("6AE_T1Port1_HaraEntrance_UnitTarget");
		TargetPHGoon2 = MR.Inst.GetUnitTarget("CAE_T1Port1_HaraEntrance_UnitTarget");
		T_Noot_Skids = MR.Inst.GetUnitTarget("18C_T1TheSkids_UnitTarget");
		T_Ambro_Skids = MR.Inst.GetUnitTarget("D7B_T1TheSkids_UnitTarget");
		T_Goons_Skids = MR.Inst.GetUnitTarget("F90_T1TheSkids_UnitTarget");
		T_TheGoonThatDidntMakeIt = MR.Inst.GetUnitTarget("E9D_T1TheSkids_UnitTarget");
		T_AmbroAttacksFourthGoon = MR.Inst.GetUnitTarget("574_T1TheSkids_UnitTarget");
		T_Willa_Chum = MR.Inst.GetUnitTarget("2AD_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Chris_Chum = MR.Inst.GetUnitTarget("C3B_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Margot_Chum = MR.Inst.GetUnitTarget("3F3_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Archi_Chum = MR.Inst.GetUnitTarget("70B_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Archi_WRoom = MR.Inst.GetUnitTarget("DF0_T2WillasRoom_UnitTarget");
		T_Archi_WRoom_Letter = MR.Inst.GetUnitTarget("84C_T2WillasRoom_UnitTarget");
		T_Margot_WRoom = MR.Inst.GetUnitTarget("D04_T2WillasRoom_UnitTarget");
		T_Chris_WRoom = MR.Inst.GetUnitTarget("160_T2WillasRoom_UnitTarget");
		T_P1_Train1 = MR.Inst.GetUnitTarget("138_T1Subway_TrainInterior2_UnitTarget");
		T_P2_Train1 = MR.Inst.GetUnitTarget("C2B_T1Subway_TrainInterior2_UnitTarget");
		T_P3_Train1 = MR.Inst.GetUnitTarget("A32_T1Subway_TrainInterior2_UnitTarget");
		T_All_Train2 = MR.Inst.GetUnitTarget("D9C_T1Subway_TrainInterior3_UnitTarget");
		T_Willa_Port = MR.Inst.GetUnitTarget("FEC_T1Port1_HaraEntrance_UnitTarget");
		T_Willa_Skyway = MR.Inst.GetUnitTarget("296_T2Skyway_UnitTarget");
		TargetViolin = MR.Inst.GetUnitTarget("7FD_T1FreightElevator_UnitTarget");
		TargetArchiStepsAside = MR.Inst.GetUnitTarget("0F5_T2WillasRoom_UnitTarget");
		TargetViolinWillas = MR.Inst.GetUnitTarget("756_T1FreightElevator_UnitTarget");
		TargetWillaPutsDownViolinAtHome = MR.Inst.GetUnitTarget("71A_T2WillasRoom_UnitTarget");
		UnitTarget sfx_elevator_arrives = MR.Inst.GetUnitTarget("923_T1VaultEntrance_UnitTarget");
		UnitTarget archi_door_lock_1 = MR.Inst.GetUnitTarget("573_T1Subway_TrainInterior2_UnitTarget");
		UnitTarget sfx_ulysees_smash_1 = MR.Inst.GetUnitTarget("573_T1Subway_TrainInterior2_UnitTarget");
		UnitTarget archi_door_lock_2 = MR.Inst.GetUnitTarget("FF0_T1Subway_TrainInterior3_UnitTarget");
		UnitTarget sfx_ulysees_smash_2 = MR.Inst.GetUnitTarget("FF0_T1Subway_TrainInterior3_UnitTarget");
		UnitTarget sfx_noot_console_interact = MR.Inst.GetUnitTarget("685_T1TheSkids_UnitTarget");
		UnitTarget sfx_ulysses_enters_elevator = MR.Inst.GetUnitTarget("EA9_T1FreightElevator_UnitTarget");
		UnitTarget sfx_freight_elevator_door_locking = MR.Inst.GetUnitTarget("F90_T1TheSkids_UnitTarget");
		VaultEnToContolRoom = MR.Inst.GetTileActionSwapMap("CF5_T1VaultEntrance_TileActionSwapMap");
		ControlRoomToPlantEXT = MR.Inst.GetTileActionSwapMap("810_T1Kaydock_ControlRoom_TileActionSwapMap");
		ControlRoomToVaultEnt = MR.Inst.GetTileActionSwapMap("314_T1Kaydock_ControlRoom_TileActionSwapMap");
		PlantExtToControlRoom = MR.Inst.GetTileActionSwapMap("620_T1Kaydock_PlantExterior_Cars_TileActionSwapMap");
		PlatExtToSubway = MR.Inst.GetTileActionSwapMap("9D9_T1Kaydock_PlantExterior_Cars_TileActionSwapMap");
		SubwayPlantToCarriage1 = MR.Inst.GetTileActionSwapMap("325_T1Subway_Station_Kaydock_TileActionSwapMap");
		SubwayPlantToPlantEXT = MR.Inst.GetTileActionSwapMap("A6F_T1Subway_Station_TileActionSwapMap");
		Carriage1ToCarriage2 = MR.Inst.GetTileActionSwapMap("2B2_T1Subway_TrainInterior2_TileActionSwapMap");
		Carriage1ToStationPlant = MR.Inst.GetTileActionSwapMap("078_T1Subway_TrainInterior2_TileActionSwapMap");
		Carriage2ToCarriage1 = MR.Inst.GetTileActionSwapMap("4F2_T1Subway_TrainInterior_TileActionSwapMap");
		Carriage2ToPortHaraEnt = MR.Inst.GetTileActionSwapMap("0C2_T1Subway_TrainInterior3_TileActionSwapMap");
		PortEntToSkids = MR.Inst.GetTileActionSwapMap("B2E_T1Port1_HaraEntrance_TileActionSwapMap");
		PortEntToSubway = MR.Inst.GetTileActionSwapMap("4BF_T1Port1_HaraEntrance_TileActionSwapMap");
		SkidsToFreightElevator = MR.Inst.GetTileActionSwapMap("B9F_T1TheSkids_TileActionSwapMap");
		SkidsToPortEnt = MR.Inst.GetTileActionSwapMap("F6D_T1TheSkids_TileActionSwapMap");
		ElevatorToChumsExt = MR.Inst.GetTileActionSwapMap("75D_T1FreightElevator_TileActionSwapMap");
		ElevatorToSkids = MR.Inst.GetTileActionSwapMap("2B7_T1FreightElevator_TileActionSwapMap");
		ChumsExtToFreightElevator = MR.Inst.GetTileActionSwapMap("A34_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		ChumsExtToWillasRoom = MR.Inst.GetTileActionSwapMap("D9B_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		WillasRoomToChums = MR.Inst.GetTileActionSwapMap("2E2_T2WillasRoom_TileActionSwapMap");
		SkywayToChumleys = MR.Inst.GetTileActionSwapMap("973_T2Skyway_TileActionSwapMap");
		SkywayToWillas = MR.Inst.GetTileActionSwapMap("FF3_T2Skyway_TileActionSwapMap");
		MineElevatorInteraction = MR.Inst.GetTileActionInteraction("C43_T1VaultEntrance_TileActionInteraction");
		ToTrainInteraction = MR.Inst.GetTileActionInteraction("02A_T1Subway_Station_TileActionInteraction");
		InteractionHack1 = MR.Inst.GetTileActionInteraction("9FA_T1Kaydock_PlantExterior_Cars_TileActionInteraction");
		InteractionHack2 = MR.Inst.GetTileActionInteraction("E18_T1Kaydock_PlantExterior_Cars_TileActionInteraction");
		I_SkywayToWillas = MR.Inst.GetTileActionInteraction("666_T2Skyway_TileActionInteraction");
		I_Letter = MR.Inst.GetTileActionInteraction("393_T2WillasRoom_TileActionInteraction");
		TileActionInteraction I_Console = MR.Inst.GetTileActionInteraction("C06_T1Kaydock_ControlRoom_TileActionInteraction");
		TileActionInteraction I_ControlRoom = MR.Inst.GetTileActionInteraction("7C2_T1TheSkids_TileActionInteraction");
		TT_Willa_Chum = MR.Inst.GetTileTrigger("ECE_T2ChumleysAutomatons_Exterior_TileTrigger");
		TT_LeaveTrain = MR.Inst.GetTileTrigger("065_T1Subway_TrainInterior3_TileTrigger");
		D_Food = MR.Inst.GetTileActionDialog("F0A_T2WillasRoom_TileActionDialog");
		D_HisGlasses = MR.Inst.GetTileActionDialog("49F_T2WillasRoom_TileActionDialog");
		D_Pack = MR.Inst.GetTileActionDialog("A2B_T2WillasRoom_TileActionDialog");
		D_TV = MR.Inst.GetTileActionDialog("997_T2WillasRoom_TileActionDialog");
		D_Lamp = MR.Inst.GetTileActionDialog("CE7_T2WillasRoom_TileActionDialog");
		D_Hoody = MR.Inst.GetTileActionDialog("CB4_T2WillasRoom_TileActionDialog");
		D_FamilyPhotos = MR.Inst.GetTileActionDialog("C50_T2WillasRoom_TileActionDialog");
		D_BalconyDoor = MR.Inst.GetTileActionDialog("33E_T2WillasRoom_TileActionDialog");
		Dialog_TheSkywayWillTakeUs = HAGIS.DialogLoad("Dialogs/A2S1/ChumleysFactory/Dialog_TheSkywayWillTakeUs");
		Ambient_FiveYears = HAGIS.DialogLoad("Dialogs/A2S1/ChumleysFactory/Ambient_FiveYears");
		Dialog_HowdHeFindUs = HAGIS.DialogLoad("Dialogs/A2S1/ControlRoom/Dialog_HowdHeFindUs");
		Dialog_ItsMund = HAGIS.DialogLoad("Dialogs/A2S1/ControlRoom/Dialog_ItsMund");
		Dialog_ItsMund_1 = HAGIS.DialogLoad("Dialogs/A2S1/ControlRoom/Dialog_ItsMund_1");
		Ambient_KeepAnEyeOnHer = HAGIS.DialogLoad("Dialogs/A2S1/ControlRoom/Ambient_KeepAnEyeOnHer");
		Ambient_BringIt = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_BringIt");
		Ambient_DunnoWhyYouWereWorried = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_DunnoWhyYouWereWorried");
		Ambient_HeadingNorth = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_HeadingNorth");
		Ambient_OhNo = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_OhNo");
		Ambient_SeeYouRealSoon = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_SeeYouRealSoon");
		Ambient_Shit = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_shit");
		Ambient_OldAugs = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Ambient_OldAugs");
		Dialog_AreWeToast = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Dialog_AreWeToast");
		Dialog_ItsTheOnlyWay = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Dialog_ItsTheOnlyWay");
		Dialog_JustGottaGetThisMoving = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Dialog_JustGottaGetThisMoving");
		Dialog_Willa = HAGIS.DialogLoad("Dialogs/A2S1/FreightElevator/Dialog_Willa");
		Ambient_GetToTheSubway = HAGIS.DialogLoad("Dialogs/A2S1/KaydockPowerPlant/Ambient_GetToTheSubway");
		Dialog_CatchYouThere = HAGIS.DialogLoad("Dialogs/A2S1/KaydockPowerPlant/Dialog_CatchYouThere");
		Dialog_StopProtectingHer = HAGIS.DialogLoad("Dialogs/A2S1/KaydockPowerPlant/Dialog_StopProtectingHer");
		Dialog_WhatTeam = HAGIS.DialogLoad("Dialogs/A2S1/KaydockPowerPlant/Dialog_WhatTeam");
		Dialog_WantMeToTakeThat = HAGIS.DialogLoad("Dialogs/A2S1/MineTunnel/Dialog_WantMeToTakeThat");
		Dialog_AfterTonight = HAGIS.DialogLoad("Dialogs/A2S1/MineTunnel/Dialog_AfterTonight");
		Dialog_IAmShocked = HAGIS.DialogLoad("Dialogs/A2S1/PortEntrance/Dialog_IAmShocked");
		Dialog_IOwnDetritum = HAGIS.DialogLoad("Dialogs/A2S1/PortEntrance/Dialog_IOwnDetritum");
		Dialog_LastCall = HAGIS.DialogLoad("Dialogs/A2S1/PortEntrance/Dialog_LastCall");
		Dialog_WillaItsMe = HAGIS.DialogLoad("Dialogs/A2S1/PortEntrance/Dialog_WillaItsMe");
		Ambient_TheSkids = HAGIS.DialogLoad("Dialogs/A2S1/PortHara&SkidsSubway/Ambient_TheSkids");
		Ambient_GetReady = HAGIS.DialogLoad("Dialogs/A2S1/PortHara&SkidsSubway/Ambient_GetReady");
		Ambient_OrNot = HAGIS.DialogLoad("Dialogs/A2S1/PortHara&SkidsSubway/Ambient_OrNot");
		Ambient_Crap = HAGIS.DialogLoad("Dialogs/A2S1/SubwayStation/Ambient_Crap");
		Ambient_Go = HAGIS.DialogLoad("Dialogs/A2S1/SubwayStation/Ambient_Go");
		Ambient_Graaah = HAGIS.DialogLoad("Dialogs/A2S1/SubwayTrainCarriages/Ambient_Gra-a-ah");
		Ambient_Graaah2 = HAGIS.DialogLoad("Dialogs/A2S1/SubwayTrainCarriages/Ambient_Gra-a-ah2");
		Ambient_HesComing = HAGIS.DialogLoad("Dialogs/A2S1/SubwayTrainCarriages/Ambient_HesComing");
		Ambient_ItsThatMonolith = HAGIS.DialogLoad("Dialogs/A2S1/SubwayTrainCarriages/Ambient_ItsThatMonolith");
		Ambient_YourStop = HAGIS.DialogLoad("Dialogs/A2S1/SubwayTrainCarriages/Ambient_YourStop");
		Ambient_GetOn = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Ambient_GetOn");
		Ambient_MundCantBeFar = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Ambient_MundCantBeFar");
		Ambient_WarningAnnouncer = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Ambient_WarningAnnouncer");
		Dialog_ThisArrangement = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Dialog_ThisArrangement");
		Dialog_WeTrapped = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Dialog_WeTrapped");
		Dialog_YouMollysFriend = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Dialog_YouMollysFriend");
		Dialog_HitTheControls = HAGIS.DialogLoad("Dialogs/A2S1/TheSkids/Ambient_HitTheControls");
		Ambient_FeelsLIkeMonths = HAGIS.DialogLoad("Dialogs/A2S1/Skyway/Ambient_FeelsLikeMonths");
		Ambient_DadQuieter = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_DadQuieter");
		Ambient_DadShaky = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_DadShaky");
		Ambient_HeDidntPack = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_HeDidntPack");
		Ambient_HisReadingGlasses = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_HisReadingGlasses");
		Ambient_ItsMouldy = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_ItsMouldy");
		Ambient_What = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_What...");
		Ambient_Hoody = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_Hoody");
		Ambient_Lamp = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_Lamp");
		Ambient_FamilyPhotos = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_FamilyPhotos");
		Ambient_BalconyDoor = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Ambient_BalconyDoor");
		Dialog_DadImHome = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_DadImHome");
		Dialog_ItsAWarrant = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_ItsAWarrant");
		Dialog_LetsBurnItDown = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_LetsBurnItDown");
		Dialog_ShesDevastated = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_ShesDevastated");
		Dialog_TheArrestOfBenard = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_TheArrestOfBenard");
		Dialog_YourGonnaStopThem = HAGIS.DialogLoad("Dialogs/A2S1/WillasHome/Dialog_YourGonnaStopThem");
		Turret1.gameObject.SetActive(value: false);
		Turret2.gameObject.SetActive(value: false);
		InteractionHack1.gameObject.SetActive(value: false);
		InteractionHack2.gameObject.SetActive(value: false);
		ConstArray<Unit> EnemyTeamMembers = Ulysses.GetTeam().GetActiveMembers();
		UnitTeam teamPlayer = GC.Inst.GetTeamOfType(UnitTeam.Type.Player);
		string VaultDoor = "MA_VaultDoor";
		string train = "MA_SubwayTrain";
		elevatorWalls = FreightElevator.Map.GetComponentInChildren<ScrollingWalls>();
		Goon1.gameObject.SetActive(value: false);
		Goon2.gameObject.SetActive(value: false);
		Goon3.gameObject.SetActive(value: false);
		Ulysses.gameObject.SetActive(value: false);
		Theo.gameObject.SetActive(value: false);
		Eugene.gameObject.SetActive(value: false);
		Underclock1.gameObject.SetActive(value: false);
		Underclock2.gameObject.SetActive(value: false);
		VaultEnToContolRoom.gameObject.SetActive(value: false);
		ControlRoomToPlantEXT.gameObject.SetActive(value: false);
		ControlRoomToVaultEnt.gameObject.SetActive(value: false);
		PlantExtToControlRoom.gameObject.SetActive(value: false);
		PlatExtToSubway.gameObject.SetActive(value: false);
		SubwayPlantToCarriage1.gameObject.SetActive(value: false);
		Carriage1ToCarriage2.gameObject.SetActive(value: false);
		Carriage2ToCarriage1.gameObject.SetActive(value: false);
		SkidsToFreightElevator.gameObject.SetActive(value: false);
		S_Goon1.gameObject.SetActive(value: false);
		S_Goon2.gameObject.SetActive(value: false);
		S_Goon3.gameObject.SetActive(value: false);
		ElevatorToSkids.gameObject.SetActive(value: false);
		Carriage1ToStationPlant.gameObject.SetActive(value: false);
		TT_LeaveTrain.gameObject.SetActive(value: false);
		I_ControlRoom.gameObject.SetActive(value: false);
		ChumsExtToWillasRoom.gameObject.SetActive(value: false);
		ElevatorToChumsExt.gameObject.SetActive(value: false);
		TT_Willa_Chum.gameObject.SetActive(value: false);
		SkywayToWillas.gameObject.SetActive(value: false);
		I_SkywayToWillas.gameObject.SetActive(value: false);
		TargetViolin.gameObject.SetActive(value: false);
		TargetViolinWillas.gameObject.SetActive(value: false);
		Carriage2ToPortHaraEnt.gameObject.SetActive(value: false);
		ScaredGaurd.gameObject.SetActive(value: false);
		SpawnSoldier.gameObject.SetActive(value: false);
		SpawnTrigger.gameObject.SetActive(value: false);
		I_Letter.gameObject.SetActive(value: false);
		I_Console.gameObject.SetActive(value: false);
		ToTrainInteraction.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkViolin");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "CsDefaultPickUpWithViolin");
		PlayMapAnimation(VaultEntrance.Map, VaultDoor, "Staropen");
		Ability_MaxHP UlyssesHP = Ulysses.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		UlyssesHP.SetHPMod(7);
		yield return null;
		MusicStop();
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, TargetWillaFromVault);
		Archi.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_WantMeToTakeThat);
		UIObjectives.Inst.CompleteAndSetMainObjective(objReturn);
		CutsceneEnd();
		VaultEntrance.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(MineElevatorInteraction.OnTriggered);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_AfterTonight);
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/elevator arrives", sfx_elevator_arrives);
		yield return CreateTimeCondition(1f);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		CutsceneEnd();
		yield return MapGoto(KaydockPlantInt);
		yield return null;
		UIObjectives.Inst.CompleteObjective(objReturn);
		SKIP_POINT("Skiped intro at Vault entrance");
		Noot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Noot);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		KaydockPlantInt.CanTeammatesFollow = true;
		yield return PlayInterplay();
		SFXPlay("event:/sfx/script/act 2/a2s1/car and door slam outside");
		yield return CreateTimeCondition(1f);
		UIObjectives.Inst.CompleteAndSetMainObjective(objConsole);
		I_Console.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(I_Console.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objConsole);
		CutsceneBegin();
		HAGIS.DialogShow(Dialog_ItsMund);
		Margot.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(1f);
		Chris.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(0.5f);
		Noot.LookInDirection(OctDir.Down);
		MusicPlay("event:/music/tracks/basic/mund intro");
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_ItsMund_1);
		Noot.LookInDirection(OctDir.Down);
		Margot.LookInDirection(OctDir.Down);
		Chris.LookInDirection(OctDir.Down);
		Goon1.gameObject.SetActive(value: true);
		Goon2.gameObject.SetActive(value: true);
		Goon3.gameObject.SetActive(value: true);
		yield return CreateAndCondition(UnitPlayAnimation(Goon1, "TransDIdleToCIdle"), UnitPlayAnimation(Goon2, "TransDIdleToCIdle"));
		Goon1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateAndCondition(UnitMoveToTarget(Goon1, TargetGoon3, null, 5f), UnitMoveToTarget(Goon2, TargetGoon1, null, 5f), UnitMoveToTarget(Goon3, TargetGoon2, null, 5f), UnitMoveToTarget(Margot, TargetMargotPltInt, null, 5f), UnitMoveToTarget(Noot, TargetNootPltInt, null, 5f), UnitMoveToTarget(Chris, TargetChrisPltInt, null, 5f));
		yield return null;
		CutsceneEnd();
		SKIP_POINT("Skipped to combat in kaydock");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFuselGang);
		MusicPlay("event:/music/tracks/combat/frenzy");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/determined tension");
		UIObjectives.Inst.CompleteObjective(objFuselGang);
		CutsceneBegin();
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(Noot, T_NootPostKaydockIntFight, OctDir.Up);
		UnitMoveToTarget(Chris, T_ChrisPostKaydockIntFight, OctDir.Up);
		UnitMoveToTarget(Margot, T_MargotPostKaydockIntFight, OctDir.Right);
		UnitTeleportToMapViaEntranceTile(Archi, ControlRoomToVaultEnt, TargetConsole);
		yield return CreateTimeCondition(1f);
		UnitTeleportToMapViaEntranceTile(Willa, ControlRoomToVaultEnt, TargetChrisPltInt);
		yield return CreateTimeCondition(1f);
		UnitTeleportToMapViaEntranceTile(Ambrosia, ControlRoomToVaultEnt, TargetAmbroEnters);
		Willa.LookInDirection(OctDir.Left);
		Ambrosia.LookInDirection(OctDir.Down);
		Archi.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(Dialog_StopProtectingHer);
		SKIP_POINT("Skipped kaydock exterior cutscene");
		yield return HAGIS.DialogShow(Dialog_WhatTeam);
		switch (SaveData.SplitPoint(Dialog_WhatTeam.currentResponseLine))
		{
		default:
			Margot.SetTeamType(UnitTeam.Type.Player);
			Ambrosia.SetTeamType(UnitTeam.Type.Player);
			Archi.SetTeamType(UnitTeam.Type.Player);
			playerChoice1 = Archi;
			playerChoice2 = Ambrosia;
			playerChoice3 = Margot;
			playerChoice4 = Chris;
			playerChoice5 = Noot;
			GC.Inst.SetRPGLeader(Archi);
			yield return HAGIS.DialogShow(Dialog_CatchYouThere);
			HAGIS.DialogShow(Ambient_KeepAnEyeOnHer);
			break;
		case 2u:
			Margot.SetTeamType(UnitTeam.Type.Player);
			Archi.SetTeamType(UnitTeam.Type.Player);
			Noot.SetTeamType(UnitTeam.Type.Player);
			playerChoice1 = Archi;
			playerChoice2 = Margot;
			playerChoice3 = Noot;
			playerChoice4 = Chris;
			playerChoice5 = Ambrosia;
			GC.Inst.SetRPGLeader(Archi);
			yield return HAGIS.DialogShow(Dialog_CatchYouThere);
			HAGIS.DialogShow(Ambient_KeepAnEyeOnHer);
			break;
		case 3u:
			Chris.SetTeamType(UnitTeam.Type.Player);
			Archi.SetTeamType(UnitTeam.Type.Player);
			Ambrosia.SetTeamType(UnitTeam.Type.Player);
			playerChoice1 = Archi;
			playerChoice2 = Chris;
			playerChoice3 = Ambrosia;
			playerChoice4 = Noot;
			playerChoice5 = Margot;
			GC.Inst.SetRPGLeader(Archi);
			yield return HAGIS.DialogShow(Dialog_CatchYouThere);
			HAGIS.DialogShow(Ambient_KeepAnEyeOnHer);
			break;
		}
		CutsceneEnd();
		SKIP_POINT("Skipped team selection");
		ControlRoomToPlantEXT.gameObject.SetActive(value: true);
		Turret1.gameObject.SetActive(value: true);
		InteractionHack1.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(KaydockPlantExt.Map);
		MusicPlay("event:/music/tracks/combat/underclock combat");
		PlantExtToControlRoom.gameObject.SetActive(value: false);
		UnitMoveToTarget(playerChoice1, TargetNootPltExt, null, 5f);
		UnitMoveToTarget(playerChoice2, T_SelectedPlayer1, null, 5f);
		UnitMoveToTarget(playerChoice3, T_SelectedPlayer2, null, 5f);
		Goon4.LookInDirection(OctDir.Up);
		Goon5.LookInDirection(OctDir.Up);
		Goon7.LookInDirection(OctDir.Up);
		yield return CreateAndCondition(UnitPlayAnimation(Goon4, "TransDIdleToCIdle"), UnitPlayAnimation(Goon5, "TransDIdleToCIdle"), UnitPlayAnimation(Goon7, "TransDIdleToCIdle"));
		Goon4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon7.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Goon7.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateAndCondition(UnitMoveToTarget(Goon4, TargetGoon4, null, 5f), UnitMoveToTarget(Goon5, TargetGoon5, null, 5f), UnitMoveToTarget(Goon7, TargetGoon7, null, 5f));
		SKIP_POINT("Skipped to Kaydock Ext fight");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFuselGang);
		Turret1.IsMovementDisabled = true;
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		while (true)
		{
			HagletYieldTerm Turret1Term = CreateTriggerCondition(InteractionHack1.OnTriggered);
			HagletYieldTerm Turret2Term = CreateTriggerCondition(InteractionHack2.OnTriggered);
			yield return CreateOrCondition(CombatWaitUntilComplete(), Turret1Term, Turret2Term);
			if (Turret1Term.met)
			{
				Turret1.SetTeamType(UnitTeam.Type.Player);
				InteractionHack1.gameObject.SetActive(value: false);
				continue;
			}
			if (!Turret2Term.met)
			{
				break;
			}
			Turret2.SetTeamType(UnitTeam.Type.Player);
			InteractionHack2.gameObject.SetActive(value: false);
		}
		MusicPlay("event:/music/tracks/basic/determined tension");
		yield return null;
		Turret1.SetTeamType(UnitTeam.Type.NPC);
		Turret2.SetTeamType(UnitTeam.Type.NPC);
		yield return null;
		InteractionHack1.gameObject.SetActive(value: false);
		InteractionHack2.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteObjective(objFuselGang);
		yield return CreateTimeCondition(1f);
		KaydockPlantExt.CanTeammatesFollow = true;
		HAGIS.DialogShow(Ambient_GetToTheSubway);
		PlatExtToSubway.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objElevator);
		yield return MapWaitUntilMidTransition(SubwayStationPlant);
		PlayMapAnimation(SubwayStationPlant.Map, "MA_SubwayTrain", "Arriving");
		yield return MapWaitUntilVisible(SubwayStationPlant.Map);
		SubwayStationPlant.CanTeammatesFollow = true;
		HAGIS.DialogShow(Ambient_Go);
		SubwayPlantToPlantEXT.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(5f);
		ToTrainInteraction.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(ToTrainInteraction.OnTriggered);
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToMapViaExitTile(playerChoice1, SubwayPlantToCarriage1), UnitMoveToMapViaExitTile(playerChoice2, SubwayPlantToCarriage1), UnitMoveToMapViaExitTile(playerChoice3, SubwayPlantToCarriage1));
		PlayMapAnimation(SubwayStationPlant.Map, train, "Leaving");
		HAGIS.DialogShow(Ambient_Crap);
		yield return CreateTimeCondition(4f);
		SKIP_POINT("Skipped to first train carraige");
		yield return MapGoto(SubwayTrain1);
		HAGIS_A2S1 hAGIS_A2S = this;
		Unit unit = playerChoice2;
		UnitTarget t_P2_Train = T_P2_Train1;
		float? speed = playerChoice2.charData.movementSpeedInCombat;
		hAGIS_A2S.UnitMoveToTarget(unit, t_P2_Train, null, speed);
		HAGIS_A2S1 hAGIS_A2S2 = this;
		unit = playerChoice3;
		t_P2_Train = T_P3_Train1;
		speed = playerChoice3.charData.movementSpeedInCombat;
		hAGIS_A2S2.UnitMoveToTarget(unit, t_P2_Train, null, speed);
		MusicPlay("event:/music/tracks/combat/train fight");
		Archi.LookInDirection(OctDir.Left);
		UnitPlayAnimation(playerChoice1, "DefaultInteract");
		yield return CreateTimeCondition(0.7f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/carriage door lock", archi_door_lock_1);
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(playerChoice1, T_P1_Train1);
		yield return HAGIS.DialogShow(Ambient_Graaah);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/ulysses smash off screen", sfx_ulysees_smash_1);
		yield return CreateTimeCondition(1.5f);
		yield return HAGIS.DialogShow(Ambient_ItsThatMonolith);
		CutsceneEnd();
		CombatBegin(UnitTeam.Type.Player);
		yield return CreateOrCondition(CombatWaitUntilComplete(), TurnModeWaitForEnemyTurnStart());
		SKIP_POINT("Ulysses arrives");
		CutsceneBegin();
		HagisLog("ulysses arrives!");
		Ability_DEBUG_CantDie UlyssesCantDie = Ulysses.abilities.Add<Ability_DEBUG_CantDie>(null, isUpgraded: false);
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/ulysess smash through train door 1", sfx_ulysees_smash_1);
		yield return CreateTimeCondition(0.5f);
		Vector3 archiOrigLookDir = playerChoice1.unitModel.AnimCompTransform.forward;
		playerChoice1.LookInDirection(OctDir.Left);
		MusicPlay("event:/music/tracks/combat/train fight", 0.1f);
		MusicSetIntensity(0.1f);
		HAGIS.DialogShow(Ambient_Graaah2);
		Ulysses.gameObject.SetActive(value: true);
		HagisLog("stunned");
		Ability_Stunned_Proxy stun = Ulysses.abilities.Add<Ability_Stunned_Proxy>(null, isUpgraded: false);
		stun.playAnimation = false;
		stun.duration = 1;
		yield return UnitPlayAnimation(Ulysses, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatHit, "CombatDizzyHit");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchHit, "CombatDizzyHit");
		Ulysses.UpdateIdleAnim();
		Ulysses.SetTeamType(UnitTeam.Type.Enemy);
		playerChoice1.unitModel.StartLookAtTarget(playerChoice1.unitModel.AnimCompTransform.position + archiOrigLookDir);
		yield return CreateTimeCondition(3f);
		CutsceneEnd();
		if (SaveData.SplitPoint(SizeOfEnemyTeam() > 1, skipOverride: false))
		{
			yield return CreateOrCondition(TeamWaitForMemberDeathComplete(UnitTeam.Type.Enemy, SizeOfEnemyTeam() - 1), TurnModeWaitForEnemyTurnStart());
			if (SaveData.SplitPoint(SizeOfEnemyTeam() > 1))
			{
				HagisLog("ulysses unstuns!");
				CutsceneBegin();
				yield return UnitPlayAnimation(Ulysses, "TransDizzyToCIdle");
				Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHit);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouchHit);
				Ulysses.UpdateIdleAnim();
				HAGIS.DialogShow(Ambient_Graaah);
				CutsceneEnd();
				MusicPlay("event:/music/tracks/combat/train fight", 0.2f);
				MusicSetIntensity(0.1f);
				yield return TeamWaitForMemberDeathComplete(UnitTeam.Type.Enemy, SizeOfEnemyTeam() - 1);
			}
			yield return EndTurnMode();
		}
		HagisLog("enemies down. move forward");
		MusicPlay("event:/music/tracks/combat/train fight", 0.3f);
		MusicSetIntensity(0.1f);
		yield return CreateTimeCondition(1f);
		Ulysses.SetTeamType(UnitTeam.Type.NPC);
		yield return CreateAndCondition(UnitMoveToTarget(playerChoice1, CarriageExit1), UnitMoveToTarget(playerChoice2, CarriageExit2), UnitMoveToTarget(playerChoice3, CarriageExit3));
		yield return TeamMoveToMapViaEntranceTile(Carriage2ToCarriage1);
		yield return MapGoto(SubwayTrain2);
		SKIP_POINT("Enter Second Carriage");
		CutsceneBegin();
		Archi.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(0.7f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/carriage door lock", archi_door_lock_2);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Ambient_HesComing);
		CutsceneEnd();
		Archi.LookInDirection(OctDir.Right);
		MusicPlay("event:/music/tracks/combat/train fight", 0.4f);
		MusicSetIntensity(0.1f);
		SKIP_POINT("Ulysses Second Carriage");
		CombatBegin(UnitTeam.Type.Player);
		yield return CreateOrCondition(CombatWaitUntilComplete(), TurnModeWaitForEnemyTurnStart());
		CutsceneBegin();
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/ulysses smash through train door 2", sfx_ulysees_smash_2);
		yield return UnitMoveToMapViaExitTile(Ulysses, Carriage1ToCarriage2);
		HAGIS.DialogShow(Ambient_Graaah);
		MusicPlay("event:/music/tracks/combat/train fight", 0.1f);
		MusicSetIntensity(0.1f);
		Ulysses.LookInDirection(OctDir.Right);
		Ability_Stunned_Proxy stunnedAgain = Ulysses.abilities.Add<Ability_Stunned_Proxy>(null, isUpgraded: false);
		stunnedAgain.playAnimation = false;
		stunnedAgain.duration = 1;
		yield return null;
		yield return UnitPlayAnimation(Ulysses, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatHit, "CombatDizzyHit");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouchHit, "CombatDizzyHit");
		Ulysses.UpdateIdleAnim();
		Ulysses.SetTeamType(UnitTeam.Type.Enemy);
		playerChoice1.unitModel.StartLookAtTarget(playerChoice1.unitModel.AnimCompTransform.position + archiOrigLookDir);
		yield return CreateTimeCondition(3f);
		CutsceneEnd();
		if (SaveData.SplitPoint(SizeOfEnemyTeam() > 1, skipOverride: false))
		{
			yield return CreateOrCondition(TeamWaitForMemberDeathComplete(UnitTeam.Type.Enemy, SizeOfEnemyTeam() - 1), TurnModeWaitForEnemyTurnStart());
			if (SaveData.SplitPoint(SizeOfEnemyTeam() > 1))
			{
				CutsceneBegin();
				yield return UnitPlayAnimation(Ulysses, "TransDizzyToCIdle");
				Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHit);
				Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouchHit);
				Ulysses.UpdateIdleAnim();
				HAGIS.DialogShow(Ambient_Graaah);
				CutsceneEnd();
				MusicPlay("event:/music/tracks/combat/train fight", 0.2f);
				MusicSetIntensity(0.1f);
				yield return TeamWaitForMemberDeathComplete(UnitTeam.Type.Enemy, SizeOfEnemyTeam() - 1);
			}
			yield return EndTurnMode();
		}
		MusicPlay("event:/music/tracks/combat/train fight", 0.3f);
		MusicSetIntensity(0.1f);
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_PortHara_L0");
		PlayMapAnimation(SubwayTrain2.Map, "MA_SubwayDoors", "Open");
		HAGIS.DialogShow(Ambient_YourStop);
		if (Ulysses.unitModel.crouched)
		{
			Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
			Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.TransCIdleToDIdle, "CombatCrouch");
			Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.TransCCrouchToCIdle, "CombatCrouch");
		}
		else
		{
			Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
			Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.TransCIdleToDIdle, "CombatIdle");
		}
		yield return EndTurnMode();
		SetUnitsMoveToDefaultPositionsAfterTurnMode(move: false);
		yield return CreateTimeCondition(1f);
		Ulysses.SetTeamType(UnitTeam.Type.NPC);
		Ulysses.abilities.Remove(UlyssesCantDie, isProxy: false);
		yield return CreateAndCondition(UnitMoveToTarget(playerChoice1, CarriageExit4), UnitMoveToTarget(playerChoice2, CarriageExit5), UnitMoveToTarget(playerChoice3, CarriageExit6));
		yield return TeamMoveToMapViaEntranceTile(PortEntToSubway);
		yield return MapGoto(PortHaraEnt);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.TransCIdleToDIdle);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.TransCCrouchToCIdle);
		SKIP_POINT("Escaped Second Carriage");
		PortHaraEnt.unitsMoveToDefaultPositions = false;
		PortEntToSubway.gameObject.SetActive(value: false);
		PortHaraEnt.CanTeammatesFollow = true;
		GC.Inst.SetRPGLeader(Archi);
		SetUnitsMoveToDefaultPositionsAfterTurnMode(move: true);
		SKIP_POINT("Skipped cutscene in subway");
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		yield return MapWaitUntilVisible(TheSkids.Map);
		SKIP_POINT("Skipped to the skids");
		TheSkids.CanTeammatesFollow = true;
		SkidsToPortEnt.gameObject.SetActive(value: false);
		HAGIS.DialogShow(Ambient_MundCantBeFar);
		yield return CreateTriggerCondition(Dialog_YouMollysFriend.OnComplete);
		SFXPlayAtCoord("event:/sfx/script/act 3/a3s2/pod door opening", sfx_freight_elevator_door_locking);
		CutsceneBegin();
		UnitMoveToTarget(Guard, TargetSKGuard, null, 2f);
		yield return HAGIS.DialogShow(Dialog_ThisArrangement);
		UnitMoveToMapViaExitTile(playerChoice1, SkidsToFreightElevator);
		yield return CreateTimeCondition(1f);
		UnitMoveToMapViaExitTile(playerChoice2, SkidsToFreightElevator);
		yield return CreateTimeCondition(1f);
		UnitMoveToMapViaExitTile(playerChoice3, SkidsToFreightElevator);
		yield return CreateTimeCondition(1f);
		playerChoice1.LookInDirection(OctDir.Up);
		playerChoice2.LookInDirection(OctDir.Up);
		playerChoice3.LookInDirection(OctDir.Up);
		UnitTeleportToMapViaEntranceTile(Willa, ElevatorToSkids, TargetFEWilla);
		UnitTeleportToMapViaEntranceTile(playerChoice4, ElevatorToSkids, TargetFE1);
		UnitTeleportToMapViaEntranceTile(playerChoice5, ElevatorToSkids, TargetFE2);
		yield return null;
		UIObjectives.Inst.CompleteObjective(objElevator);
		SKIP_POINT("Skipped to elevator");
		yield return MapGoto(FreightElevator);
		yield return null;
		Guard.gameObject.SetActive(value: false);
		MusicStop();
		UnitMoveToTarget(Archi, TargetFE3, OctDir.Up);
		UnitMoveToTarget(Willa, TargetFE12, OctDir.DownLeft);
		UnitMoveToTarget(playerChoice4, TargetFE8, OctDir.Down);
		yield return UnitMoveToTarget(playerChoice5, TargetFE6, OctDir.Down);
		yield return HAGIS.DialogShow(Ambient_HeadingNorth);
		yield return CreateTimeCondition(2f);
		MusicPlay("event:/music/tracks/basic/mund intro");
		yield return HAGIS.DialogShow(Dialog_Willa);
		yield return HAGIS.DialogShow(Ambient_OhNo);
		yield return UnitMoveToTarget(Willa, TargetFE11);
		yield return null;
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		SKIP_POINT("Skipped to skids cutscene");
		Eugene.gameObject.SetActive(value: true);
		Goon1.Revive();
		Goon2.Revive();
		UnitTeleportToMapViaEntranceTile(Guard, PortEntToSubway, TargetPHGuard);
		ScaredGaurd.gameObject.SetActive(value: true);
		SpawnSoldier.gameObject.SetActive(value: true);
		SpawnTrigger.gameObject.SetActive(value: true);
		SpawnSoldier.LookAt(ScaredGaurd);
		SpawnTrigger.LookAt(ScaredGaurd);
		yield return null;
		yield return MapGoto(PortHaraEnt);
		yield return UnitTeleportToMapViaEntranceTile(Willa, PortEntToSkids);
		yield return UnitMoveToTarget(Willa, T_Willa_Port);
		Willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(0.5f);
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToCrouch");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultCrouch");
		yield return HAGIS.DialogShow(Dialog_IOwnDetritum);
		yield return HAGIS.DialogShow(Dialog_LastCall);
		MusicPlay("event:/music/tracks/basic/theo theme");
		Theo.gameObject.SetActive(value: true);
		Theo.LookInDirection(OctDir.UpLeft);
		Underclock1.gameObject.SetActive(value: true);
		Underclock2.gameObject.SetActive(value: true);
		UnitMoveToTarget(Underclock1, TargetUC1PortEnt);
		UnitMoveToTarget(Underclock2, TargetUC2PortEnt);
		yield return UnitMoveToTarget(Theo, TargetTheoPortEnt);
		Underclock1.LookAt(SpawnTrigger);
		Underclock2.LookAt(SpawnSoldier);
		Theo.LookAt(Eugene);
		yield return null;
		SpawnTrigger.LookAt(Underclock1);
		SpawnSoldier.LookAt(Underclock2);
		yield return HAGIS.DialogShow(Dialog_IAmShocked);
		Theo.LookInDirection(OctDir.Up);
		yield return HAGIS.DialogShow(Dialog_WillaItsMe);
		SKIP_POINT("Skipped back to elevator");
		yield return UnitPlayAnimation(Willa, "CsTransCrouchToDIdle");
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToDIdleViolin");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		yield return MapGoto(FreightElevator);
		MusicStop();
		yield return UnitTeleportToMapViaEntranceTile(Willa, ElevatorToSkids);
		Willa.LookInDirection(OctDir.Up);
		Archi.LookAt(Willa);
		Margot.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		Noot.LookAt(Willa);
		Chris.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_AreWeToast);
		yield return HAGIS.DialogShow(Dialog_JustGottaGetThisMoving);
		yield return HAGIS.DialogShow(Dialog_ItsTheOnlyWay);
		HAGIS.DialogShow(Ambient_SeeYouRealSoon);
		yield return CreateTimeCondition(1f);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		yield return UnitMoveToTarget(Willa, TargetFEWilla);
		Willa.unitModel.Play("CsTransDIdleViolinToDIdle");
		yield return CreateTimeCondition(0.75f);
		TargetViolin.gameObject.SetActive(value: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UnitMoveToMapViaExitTile(Noot, ElevatorToSkids);
		yield return CreateTimeCondition(2f);
		yield return UnitMoveToMapViaExitTile(Ambrosia, ElevatorToSkids);
		CutsceneEnd();
		SKIP_POINT("Skipped back to stealth in skids");
		yield return MapGoto(TheSkids);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objCityWatch);
		SKIP_POINT("Skipped Noot triggering the console");
		UIObjectives.Inst.CompleteObjective(objCityWatch);
		yield return null;
		CutsceneBegin();
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(Ambrosia, T_AmbroWatchesNoot, OctDir.Left);
		yield return UnitMoveToTarget(Noot, T_NootRunsToControls, OctDir.Left);
		HAGIS.DialogShow(Ambient_GetOn);
		Goon1.Revive();
		Goon2.Revive();
		Goon5.Revive();
		CutscenePlay("A2S1_Cutscene_GoonsRushToElevator");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Dialog_HitTheControls);
		yield return CreateTimeCondition(5f);
		UnitPlayAnimation(Ambrosia, "DefaultIdle", loop: true);
		UnitMoveToTarget(Noot, T_Noot_Skids, OctDir.Right);
		yield return CreateTimeCondition(1.2f);
		yield return CreateTimeCondition(1f);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/freight elevator rise", sfx_freight_elevator_door_locking);
		yield return UnitMoveToTarget(Ambrosia, T_Ambro_Skids, OctDir.Right);
		yield return CreateTimeCondition(1f);
		Noot.LookAt(Ambrosia);
		yield return CreateTimeCondition(1f);
		Ambrosia.LookAt(Noot);
		yield return HAGIS.DialogShow(Dialog_WeTrapped);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Ulysses.SetTeamType(UnitTeam.Type.NPC);
		Ulysses.gameObject.SetActive(value: false);
		UnitTeleportToMapViaEntranceTile(Ulysses, ElevatorToSkids, TargetFE6);
		UnitLookInDirection(Ulysses, OctDir.Down);
		UnitMoveToTarget(Chris, TargetRegroup1, OctDir.DownRight);
		UnitMoveToTarget(Margot, TargetRegroup4, OctDir.DownRight);
		UnitMoveToTarget(Archi, TargetRegroup2, OctDir.UpLeft);
		yield return UnitMoveToTarget(Willa, TargetRegroup3, OctDir.DownRight);
		SKIP_POINT("Skipped back to elevator fight");
		yield return MapGoto(FreightElevator);
		MusicPlay("event:/music/tracks/basic/drone 1");
		Goon1.gameObject.SetActive(value: true);
		Goon2.gameObject.SetActive(value: true);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Willa.LookAt(Archi);
		Margot.LookAt(Archi);
		Chris.LookAt(Archi);
		yield return HAGIS.DialogShow(Ambient_DunnoWhyYouWereWorried);
		Willa.LookInDirection(OctDir.Down);
		Archi.LookInDirection(OctDir.Down);
		Chris.LookInDirection(OctDir.Down);
		Margot.LookInDirection(OctDir.Down);
		UnitTeleportToMapViaEntranceTile(Goon1, ElevatorToSkids, TargetFE5);
		UnitTeleportToMapViaEntranceTile(Goon2, ElevatorToSkids, TargetFEMus);
		yield return null;
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		CutscenePlay("A2S1_Cutscene_ElevatorCogs");
		yield return null;
		elevatorWalls.speed = elevatorSpeed;
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return null;
		MusicPlay("event:/music/tracks/combat/underclock combat");
		MusicStop();
		SKIP_POINT("Skip to Ulysses arriving");
		CutsceneBegin();
		HAGIS.DialogShow(Ambient_Graaah);
		yield return CreateTimeCondition(1f);
		Willa.LookAt(Archi);
		Margot.LookAt(Archi);
		Chris.LookAt(Archi);
		Archi.LookAt(Willa);
		SFXPlayAtCoord("event:/sfx/script/act 2/a2s1/ulysses lands in centre of elevator", sfx_ulysses_enters_elevator);
		yield return CreateTimeCondition(2f);
		Ulysses.IsTargetable = true;
		Ulysses.SetTeamType(UnitTeam.Type.Enemy);
		Ulysses.SetActiveWithAnimation("AbilityGroundPoundEnd");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatCrouch, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatDizzy");
		Ulysses.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Ulysses.UpdateIdleAnim();
		Ulysses.HPRefill();
		yield return CreateTimeCondition(0.5f);
		PSC.Inst.Play(ParticleTypes.Ground_Pound, Ulysses.map, Ulysses.coord);
		yield return CreateTimeCondition(0.8f);
		Ulysses.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/combat/ulysses elevator");
		HAGIS.DialogShow(Ambient_Shit);
		yield return null;
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return CreateTimeCondition(1.5f);
		HAGIS.DialogShow(Ambient_OldAugs);
		UnitMoveToTarget(Willa, TargetWillaDodge, OctDir.Down);
		UnitMoveToTarget(Archi, TargetFE7, OctDir.UpLeft);
		UnitMoveToTarget(Margot, TargetFE2, OctDir.DownRight);
		yield return UnitMoveToTarget(Chris, TargetFE4, OctDir.Up);
		Archi.LookAt(Ulysses);
		Willa.LookAt(Ulysses);
		Margot.LookAt(Ulysses);
		Chris.LookAt(Ulysses);
		yield return UnitPlayAnimation(Ulysses, "TransDizzyToCIdle");
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouch);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatHit);
		Ulysses.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatCrouchHit);
		Ulysses.UpdateIdleAnim();
		Ulysses.unitModel.Play("CsCombatSmash");
		CutsceneEnd();
		MusicSetProgress(0.1f);
		yield return CombatBegin(UnitTeam.Type.Enemy, playOpeningBark: false);
		MusicStop();
		yield return null;
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		ElevatorToChumsExt.gameObject.SetActive(value: true);
		GC.Inst.SetRPGLeader(Willa);
		PlayMapAnimation(FreightElevator.Map, "MA_FloorCog_01", "PowerDown");
		PlayMapAnimation(FreightElevator.Map, "MA_MachineCog_01", "PowerDown");
		PlayMapAnimation(FreightElevator.Map, "MA_MachineCog_02", "PowerDown");
		float t = 0f;
		float stopTime = 1.667f;
		float startSpeed = elevatorWalls.speed;
		while (t < stopTime)
		{
			t += Time.deltaTime;
			elevatorWalls.speed = Mathf.Lerp(startSpeed, 0f, t / stopTime);
			yield return null;
		}
		elevatorWalls.speed = 0f;
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return CreateTimeCondition(0.5f);
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, TargetFEWilla, OctDir.Up);
		Willa.unitModel.Play("CsTransDIdleToDIdleViolin");
		yield return CreateTimeCondition(0.75f);
		TargetViolin.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkViolin");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdleViolin");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultPickup, "CsDefaultPickUpWithViolin");
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Skipped to chums");
		yield return MapWaitUntilVisible(ChumFactoryExt.Map);
		ChumsExtToFreightElevator.gameObject.SetActive(value: false);
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		HAGIS.DialogShow(Ambient_FiveYears);
		TT_Willa_Chum.gameObject.SetActive(value: true);
		ChumFactoryExt.CanTeammatesFollow = true;
		yield return CreateTriggerCondition(TT_Willa_Chum._OnTriggered);
		yield return HAGIS.DialogShow(Dialog_TheSkywayWillTakeUs);
		yield return TeamMoveToMapViaEntranceTile(SkywayToChumleys);
		yield return UnitMoveToTarget(Willa, T_Willa_Skyway);
		MusicPlay("event:/music/tracks/diagetic/skyway");
		SkywayToChumleys.gameObject.SetActive(value: false);
		Willa.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(Ambient_FeelsLIkeMonths);
		I_SkywayToWillas.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(I_SkywayToWillas.OnTriggered);
		UnitTeleportToMapViaEntranceTile(Willa, WillasRoomToChums);
		UnitTeleportToMapViaEntranceTile(Chris, WillasRoomToChums);
		UnitTeleportToMapViaEntranceTile(Archi, WillasRoomToChums);
		UnitTeleportToMapViaEntranceTile(Margot, WillasRoomToChums);
		yield return null;
		while ((bool)Willa.teleporting || (bool)Chris.teleporting || (bool)Archi.teleporting || (bool)Margot.teleporting)
		{
			yield return null;
		}
		Chris.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		yield return MapGoto(WillasRoom.Map);
		MusicStop();
		SKIP_POINT("Skipped to willas home");
		WillasRoomToChums.gameObject.SetActive(value: false);
		yield return UnitMoveToTarget(Willa, TargetWillaPutsDownViolinAtHome, OctDir.Right);
		Willa.unitModel.Play("CsTransDIdleViolinToDIdle");
		yield return CreateTimeCondition(0.75f);
		TargetViolinWillas.gameObject.SetActive(value: true);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultPickup);
		UnitMoveToTarget(Willa, T_Margot_WRoom, OctDir.Down);
		yield return HAGIS.DialogShow(Dialog_DadImHome);
		yield return null;
		int Triggers = 0;
		while (true)
		{
			HagletYieldTerm foodShow = CreateTriggerCondition(D_Food.OnDialogShow);
			HagletYieldTerm hisGlassesShow = CreateTriggerCondition(D_HisGlasses.OnDialogShow);
			HagletYieldTerm packShow = CreateTriggerCondition(D_Pack.OnDialogShow);
			HagletYieldTerm tvShow = CreateTriggerCondition(D_TV.OnDialogShow);
			HagletYieldTerm balconyShow = CreateTriggerCondition(D_BalconyDoor.OnDialogShow);
			HagletYieldTerm photosShow = CreateTriggerCondition(D_FamilyPhotos.OnDialogShow);
			yield return CreateOrCondition(term7: CreateTriggerCondition(D_Hoody.OnDialogShow), term1: foodShow, term2: hisGlassesShow, term3: packShow, term4: tvShow, term5: balconyShow, term6: photosShow);
			TileActionDialog triggeringDialog = (foodShow.met ? D_Food : (hisGlassesShow.met ? D_HisGlasses : (packShow.met ? D_Pack : (tvShow.met ? D_TV : (balconyShow.met ? D_BalconyDoor : ((!photosShow.met) ? D_Hoody : D_FamilyPhotos))))));
			yield return CreateTriggerCondition(triggeringDialog.OnDialogComplete);
			int num;
			Triggers = (num = Triggers + 1);
			switch (num)
			{
			case 1:
				HAGIS.DialogShow(Ambient_DadQuieter);
				continue;
			case 2:
			{
				HAGIS.DialogShow(Ambient_DadShaky);
				Chris.gameObject.SetActive(value: true);
				Archi.gameObject.SetActive(value: true);
				Margot.gameObject.SetActive(value: true);
				HagletYieldTerm Mov1 = UnitMoveToTarget(Archi, T_Archi_WRoom, OctDir.Left);
				HagletYieldTerm Mov2 = UnitMoveToTarget(Chris, T_Chris_WRoom, OctDir.Down);
				HagletYieldTerm Mov3 = UnitMoveToTarget(Margot, T_Margot_WRoom, OctDir.DownRight);
				yield return CreateAndCondition(Mov1, Mov2, Mov3);
				continue;
			}
			case 3:
				yield return UnitMoveToTarget(Archi, T_Archi_WRoom_Letter, OctDir.Left);
				I_Letter.gameObject.SetActive(value: true);
				break;
			}
			break;
		}
		SKIP_POINT("End of Mission Cutscene");
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_ItsAWarrant);
		Willa.LookAt(Archi);
		Margot.LookAt(Archi);
		Chris.LookAt(Archi);
		yield return UnitMoveToTarget(Archi, TargetArchiStepsAside, OctDir.Up);
		CutsceneEnd();
		yield return CreateTriggerCondition(I_Letter.OnTriggered);
		CutsceneBegin();
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToIdleLookDown");
		UnitPlayAnimation(Willa, "CsDefaultIdleLookDown", loop: true);
		yield return HAGIS.DialogShow(Dialog_TheArrestOfBenard);
		yield return UnitPlayAnimation(Willa, "CsTransIdleLookDownToDIdle");
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_ShesDevastated);
		yield return HAGIS.DialogShow(Dialog_YourGonnaStopThem);
		yield return UnitPlayAnimation(Willa, "CsTransDefeatedToDIdle");
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_LetsBurnItDown);
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/ability/shock");
		WillasRoom.Map.EnableEmpEffect(enabled: true);
		yield return CreateTimeCondition(0.2f);
		SFXPlay("event:/sfx/ability/death grip");
		SFXPlay("event:/sfx/ability/reflex");
		yield return CreateTimeCondition(0.5f);
		CutsceneEnd();
	}
}
public class HAGIS_A2S1_Ulysses : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
	}
}
public class HAGIS_A2S2 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Noot;

	private Unit Bugsy;

	private Unit Ambrosia;

	private Unit Margot;

	private Unit Chris;

	private Unit Theo;

	private Unit Nate;

	private Unit UnderclockDroid1;

	private Unit UnderclockDroid2;

	private Unit UnderclockDroid3;

	private Unit TheoRoof;

	private Unit UnderclockDroid4;

	private Unit UnderclockDroid5;

	private Unit GangsterTucker1;

	private Unit GangsterTucker2;

	private Unit GangsterTucker3;

	private Unit GangsterTucker4;

	private Unit GangsterMuscle1;

	private Unit GangsterMuscle2;

	private Unit GangsterMuscle3;

	private Unit BugsyBar;

	private Unit TheoBar;

	private Unit TheoClockTower;

	private Unit UnderclockSoldier1;

	private Unit UnderclockSoldier2;

	private Unit UnderclockSoldier3;

	private Unit UnderClockSolider4;

	private Unit UnderClockSolider5;

	private Unit UnderClockSolider6;

	private Unit UnderClockSolider7;

	private Unit ShopKeeperDroid;

	private Unit TheoLandingPad;

	private Unit UC_Droid1;

	private Unit UC_Droid2;

	private UnitTarget TargetEnemy1;

	private UnitTarget TargetEnemy2;

	private UnitTarget TargetEnemy3;

	private UnitTarget TargetMoveTo;

	private UnitTarget MoveToTarget1;

	private UnitTarget MoveToTarget2;

	private UnitTarget MoveToTarget3;

	private UnitTarget MoveToRoomExit;

	private UnitTarget T_WillaCover;

	private UnitTarget T_NootCover;

	private UnitTarget T_MargotCover;

	private UnitTarget T_EnemyCover;

	private UnitTarget T_EnemyCover2;

	private UnitTarget T_EnemyCover3;

	private UnitTarget T_EnemyCover4;

	private UnitTarget WillaFromSkylight;

	private UnitTarget StaticBarrier;

	private UnitTarget ArchiCoverTarget;

	private UnitTarget AmbrosiaCoverTarget;

	private UnitTarget ChrisCoverTarget;

	private UnitTarget TuckerCoverTarget1;

	private UnitTarget TuckerCoverTarget2;

	private UnitTarget ArchiCoverTarget1;

	private UnitTarget ChrisCoverTarget1;

	private UnitTarget AmbrosiaCoverTarget1;

	private UnitTarget T_EnemyCover_1;

	private UnitTarget T_EnemyCover_2;

	private UnitTarget TeamExitToSkyway;

	private UnitTarget BugsyMoveTo;

	private UnitTarget TheoMoveTo;

	private UnitTarget CoverTarget1;

	private UnitTarget CoverTarget2;

	private UnitTarget CoverTarget3;

	private UnitTarget CoverTarget4;

	private UnitTarget CoverTarget5;

	private UnitTarget ArchiCover;

	private UnitTarget ChrisCover;

	private UnitTarget AmbrosiaCover;

	private UnitTarget DroidsMoveTo1;

	private UnitTarget DroidsMoveTo2;

	private UnitTarget DroidsMoveTo3;

	private UnitTarget DroidsMoveTo4;

	private UnitTarget ArchieIdlePoint;

	private UnitTarget NootIdlePoint;

	private UnitTarget AmbrosiaIdlePoint;

	private UnitTarget MargotIdlePoint;

	private UnitTarget ChrisIdlePoint;

	private UnitTarget WillaMoveToPoint;

	private UnitTarget ArchiMoveTo;

	private UnitTarget MargotMoveTo;

	private UnitTarget NateMoveTo;

	private UnitTarget ArchiToCover;

	private UnitTarget NateMoveTo2;

	private UnitTarget Target_Statue1;

	private UnitTarget Target_Statue2;

	private UnitTarget Target_Statue3;

	private UnitTarget Target_Statue4;

	private TileActionSwapMap ToClockTower;

	private TileActionSwapMap SkyligthtToMeetingRoom;

	private TileActionSwapMap ToArenaBar;

	private TileActionSwapMap ToCityCentre;

	private TileActionSwapMap ToRelayTowerExterior;

	private TileActionSwapMap ToBotanicalGardens;

	private TileActionSwapMap ToLandingPad;

	private TileActionSwapMap FromArenaCarPark;

	private TileActionSwapMap FromPark;

	private TileActionSwapMap FromRoof;

	private TileActionSwapMap FromRoofToClocktower;

	private TileActionSwapMap FromTownCentre;

	private TileActionSwapMap FromTowerExterior;

	private TileActionSwapMap FromBotanicalGardens;

	private TileActionSwapMap FromEscapePod;

	private TileActionInteraction InteractionToBar;

	private TileActionInteraction EvasionPointInteraction;

	private TileActionInteraction I_Skylight;

	private TileActionInteraction ToTowerExteriorInteraction;

	private TileActionInteraction NateInteraction;

	private TileActionInteraction I_BackComputer;

	private TileActionInteraction I_SafeAfter;

	private TileTrigger EscapePointTrigger;

	private TileTrigger vaultBarrierOpen;

	private TileTrigger vaultBarrierClose;

	private TileTrigger vaultBarrierClose1;

	private TileTrigger vaultBarrierClose2;

	private TileTrigger GardensTrigger;

	private TileActionDialog OperaHouseDoorInteraction;

	private TileActionDialog SpeakToVendor;

	private TileActionDialog OperaHouseWindowInteraction;

	private TileActionDialog BetaSignInteraction;

	private TileActionDialog OmegaSignInteraction;

	private TileActionDialog OmegaOfficesExit;

	private TileActionDialog WillaSpeaksToArchi;

	private TileActionDialog WillaSpeaksToMargot;

	private TileActionDialog WillaSpeaksToAmbrosia;

	private TileActionDialog WillaSpeaksToChris;

	private TileActionDialog WillaSpeaksToNoot;

	private TileActionDialog FolliageInteraction;

	private TileActionDialog NotThatWay;

	private TileActionDialog D_SafeBefore;

	private TileActionDialog InscriptionInteraction;

	private HAGIS_A2S2_Violin a2s2_Violin;

	private DialogData Dialog_InPosition;

	private DialogData Dialog_HowLongWeGot;

	private DialogData Ambient_GetToTheClockTower;

	private DialogData Ambient_ArchisReady;

	private DialogData Ambient_BackComputer1;

	private DialogData Ambient_BackComputer2;

	private DialogData Ambient_BackComputer3;

	private DialogData Dialog_ImAlteringTheDeal;

	private DialogData Dialog_ContributionToCulture;

	private DialogData Dialog_RunRabbit;

	private DialogData Dialog_Goo;

	private DialogData Ambient_YouDumbHick;

	private DialogData Ambient_HeadUp;

	private DialogData Ambient_HitTheSkyway;

	private DialogData Ambient_TheWoodsRotten;

	private DialogData Ambient_Bad;

	private DialogData Ambient_Willa;

	private DialogData Ambient_Hold;

	private DialogData Ambient_StupidQuestion;

	private DialogData Dialog_ArchiAnyTrouble;

	private DialogData Dialog_Run;

	private DialogData Ambient_ItsSealedTight;

	private DialogData Ambient_GoodMorningCitizen;

	private DialogData Ambient_ItsAlive;

	private DialogData Ambeint_IWasntEvenBorn;

	private DialogData Ambient_BetaBlockAndRelay;

	private DialogData Ambient_OmegaOffices;

	private DialogData Ambient_ItsSealed;

	private DialogData Ambient_WaitHereForUs;

	private DialogData Dialog_WeNeedToKeepGoing;

	private DialogData Dialog_IAlwaysWantedToSing;

	private DialogData Dialog_PearlsOfWisdom;

	private DialogData Dialog_WowThisPlace;

	private DialogData Dialog_SaySomethingNoot;

	private DialogData Dialog_GoodMorning;

	private DialogData Dialog_WeWait;

	private DialogData Dialog_DidYouKnow;

	private DialogData Ambient_UpTheStairs;

	private DialogData Ambient_TheresSomeMachinery;

	private DialogData Ambient_ThoesLegs;

	private DialogData Ambient_Foliage;

	private DialogData Ambient_DedicatedToSerena;

	private DialogData Dialog_AhMyCase;

	private DialogData Dialog_YourFactory;

	private DialogData Dialog_ItsGreatToFinallyMeetYou;

	private DialogData Dialog_CravensToldMeSoMuch;

	private DialogData Dialog_SheWantsTheTruth;

	private DialogData Dialog_ImNotAPuppet;

	private DialogData Dialog_Stop;

	private DialogData Dialog_Go;

	private DialogData Dialog_JulesIsWaiting;

	private DialogData Ambient_ComeOnThink;

	private DialogData Ambient_YouPrick;

	private DialogData Ambient_CrapSorryOnceMore;

	private DialogData Ambient_GrrrahCrap;

	private DialogData Ambient_NoItsWilla;

	private DialogData Ambient_IWontHurtHer;

	private DialogData Ambient_NoNotWilla;

	private DialogData Ambient_Arg;

	private DialogData Ambient_No;

	private DialogData Ambient_NoNextTime;

	private DialogData Ambient_DamnBlinked;

	private DialogData Ambient_ICant;

	private DialogData Ambient_ThisTime;

	private string objPhase1 = "OBJECTIVES_A2S2_01";

	private string objPhase2 = "OBJECTIVES_A2S2_02";

	private string objPhase3 = "OBJECTIVES_A2S2_03";

	private string objPhase4 = "OBJECTIVES_A2S2_04";

	private string objPhase5 = "OBJECTIVES_A2S2_05";

	private string objPhase6 = "OBJECTIVES_A2S2_06";

	private string objStopHer = "OBJECTIVES_A2S2_07";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot T2UnderclockStationRoof = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot T2UnderclockMeetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		LogicRoot T2KaydockArenaCarPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		LogicRoot T2KaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot T2ClockTower = GetLogicUsingArtName("T2ClockTower");
		LogicRoot T2CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot T2RelayTowerExterior = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot T2Nu_TropicsBontanicalGarden = GetLogicUsingArtName("T3BotanicalGardens");
		LogicRoot T2LandingPad = GetLogicUsingArtName("T3LandingPad");
		Willa = GC.Inst.GetUnitWithId("654_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("B38_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("B0F_T2TheKaydockArenaCarPark_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("380_T2TheKaydockArenaCarPark_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("0A9_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("C2E_T1TheFiles_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("2B7_T2UnderclockMeetingRoom_UnitSpawn");
		Bugsy = GC.Inst.GetUnitWithId("BB3_T2UnderclockMeetingRoom_UnitSpawn");
		Nate = GC.Inst.GetUnitWithId("611_T3LandingPad_UnitSpawn");
		ShopKeeperDroid = GC.Inst.GetUnitWithId("67D_T3CelestiaTownCentre_UnitSpawn");
		UnderclockDroid1 = GC.Inst.GetUnitWithId("FCB_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		UnderclockDroid2 = GC.Inst.GetUnitWithId("F8B_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		UnderclockDroid3 = GC.Inst.GetUnitWithId("8DC_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		TheoRoof = GC.Inst.GetUnitWithId("EFF_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		UnderclockDroid4 = GC.Inst.GetUnitWithId("299_T2UnderclockMeetingRoom_UnitSpawn");
		UnderclockDroid5 = GC.Inst.GetUnitWithId("459_T2UnderclockMeetingRoom_UnitSpawn");
		GangsterTucker1 = GC.Inst.GetUnitWithId("F26_T2UnderclockMeetingRoom_UnitSpawn");
		GangsterTucker2 = GC.Inst.GetUnitWithId("979_T2UnderclockMeetingRoom_UnitSpawn");
		GangsterTucker3 = GC.Inst.GetUnitWithId("460_T2TheKaydockArenaCarPark_UnitSpawn");
		GangsterTucker4 = GC.Inst.GetUnitWithId("279_T2TheKaydockArenaCarPark_UnitSpawn");
		GangsterMuscle1 = GC.Inst.GetUnitWithId("B79_T2TheKaydockArenaBar_UnitSpawn");
		GangsterMuscle2 = GC.Inst.GetUnitWithId("427_T2TheKaydockArenaBar_UnitSpawn");
		GangsterMuscle3 = GC.Inst.GetUnitWithId("389_T2TheKaydockArenaBar_UnitSpawn");
		BugsyBar = GC.Inst.GetUnitWithId("55B_T2TheKaydockArenaBar_UnitSpawn");
		TheoBar = GC.Inst.GetUnitWithId("A4D_T2TheKaydockArenaBar_UnitSpawn");
		UnderclockSoldier1 = GC.Inst.GetUnitWithId("E4C_T2ClockTower_UnitSpawn");
		UnderclockSoldier2 = GC.Inst.GetUnitWithId("2B6_T2ClockTower_UnitSpawn");
		UnderclockSoldier3 = GC.Inst.GetUnitWithId("E09_T2ClockTower_UnitSpawn");
		UnderClockSolider4 = GC.Inst.GetUnitWithId("840_T2ClockTower_UnitSpawn");
		UnderClockSolider5 = GC.Inst.GetUnitWithId("492_T2ClockTower_UnitSpawn");
		UnderClockSolider6 = GC.Inst.GetUnitWithId("A2A_T2ClockTower_UnitSpawn");
		UnderClockSolider7 = GC.Inst.GetUnitWithId("BE4_T2ClockTower_UnitSpawn");
		TheoLandingPad = GC.Inst.GetUnitWithId("559_T3LandingPad_UnitSpawn");
		UC_Droid1 = GC.Inst.GetUnitWithId("934_T3LandingPad_UnitSpawn");
		UC_Droid2 = GC.Inst.GetUnitWithId("B8C_T3LandingPad_UnitSpawn");
		UnitTarget sfx_underclock_vault_unlock = MR.Inst.GetUnitTarget("909_T2UnderclockMeetingRoom_UnitTarget");
		UnitTarget sfx_underclock_terminal = MR.Inst.GetUnitTarget("90C_T2UnderclockMeetingRoom_UnitTarget");
		TargetEnemy1 = MR.Inst.GetUnitTarget("EBC_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetEnemy2 = MR.Inst.GetUnitTarget("C7E_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetEnemy3 = MR.Inst.GetUnitTarget("0B1_T2UnderclocksPoliceStation_Roof_UnitTarget");
		TargetMoveTo = MR.Inst.GetUnitTarget("5DD_T2WillasRoom_UnitTarget");
		WillaFromSkylight = MR.Inst.GetUnitTarget("F27_T2UnderclocksPoliceStation_Roof_UnitTarget");
		MoveToTarget1 = MR.Inst.GetUnitTarget("308_T2UnderclockMeetingRoom_UnitTarget");
		MoveToTarget2 = MR.Inst.GetUnitTarget("3EA_T2UnderclockMeetingRoom_UnitTarget");
		MoveToTarget3 = MR.Inst.GetUnitTarget("E76_T2UnderclockMeetingRoom_UnitTarget");
		MoveToRoomExit = MR.Inst.GetUnitTarget("AEE_T2UnderclockMeetingRoom_UnitTarget");
		T_WillaCover = MR.Inst.GetUnitTarget("180_T2UnderclockMeetingRoom_UnitTarget");
		T_NootCover = MR.Inst.GetUnitTarget("811_T2UnderclockMeetingRoom_UnitTarget");
		T_MargotCover = MR.Inst.GetUnitTarget("BAB_T2UnderclockMeetingRoom_UnitTarget");
		T_EnemyCover = MR.Inst.GetUnitTarget("90C_T2UnderclockMeetingRoom_UnitTarget");
		T_EnemyCover2 = MR.Inst.GetUnitTarget("AFD_T2UnderclockMeetingRoom_UnitTarget");
		T_EnemyCover3 = MR.Inst.GetUnitTarget("2F0_T2UnderclockMeetingRoom_UnitTarget");
		T_EnemyCover4 = MR.Inst.GetUnitTarget("909_T2UnderclockMeetingRoom_UnitTarget");
		ArchiCoverTarget = MR.Inst.GetUnitTarget("4B3_T2TheKaydockArenaCarPark_UnitTarget");
		AmbrosiaCoverTarget = MR.Inst.GetUnitTarget("B7A_T2TheKaydockArenaCarPark_UnitTarget");
		ChrisCoverTarget = MR.Inst.GetUnitTarget("FF4_T2TheKaydockArenaCarPark_UnitTarget");
		TuckerCoverTarget1 = MR.Inst.GetUnitTarget("8E4_T2TheKaydockArenaCarPark_UnitTarget");
		TuckerCoverTarget2 = MR.Inst.GetUnitTarget("601_T2TheKaydockArenaCarPark_UnitTarget");
		ArchiCoverTarget1 = MR.Inst.GetUnitTarget("DF1_T2TheKaydockArenaBar_UnitTarget");
		ChrisCoverTarget1 = MR.Inst.GetUnitTarget("EB8_T2TheKaydockArenaBar_UnitTarget");
		AmbrosiaCoverTarget1 = MR.Inst.GetUnitTarget("9D7_T2TheKaydockArenaBar_UnitTarget");
		TeamExitToSkyway = MR.Inst.GetUnitTarget("EEE_T2TheKaydockArenaBar_UnitTarget");
		BugsyMoveTo = MR.Inst.GetUnitTarget("961_T2TheKaydockArenaBar_UnitTarget");
		TheoMoveTo = MR.Inst.GetUnitTarget("16A_T2TheKaydockArenaBar_UnitTarget");
		CoverTarget1 = MR.Inst.GetUnitTarget("C52_T2ClockTower_UnitTarget");
		CoverTarget2 = MR.Inst.GetUnitTarget("719_T2ClockTower_UnitTarget");
		CoverTarget3 = MR.Inst.GetUnitTarget("CD8_T2ClockTower_UnitTarget");
		CoverTarget4 = MR.Inst.GetUnitTarget("E0D_T2ClockTower_UnitTarget");
		CoverTarget5 = MR.Inst.GetUnitTarget("DE2_T2ClockTower_UnitTarget");
		ArchiCover = MR.Inst.GetUnitTarget("4B0_T2ClockTower_UnitTarget");
		ChrisCover = MR.Inst.GetUnitTarget("C19_T2ClockTower_UnitTarget");
		AmbrosiaCover = MR.Inst.GetUnitTarget("139_T2ClockTower_UnitTarget");
		WillaMoveToPoint = MR.Inst.GetUnitTarget("8CB_T3CelestiaTownCentre_UnitTarget");
		T_EnemyCover_1 = MR.Inst.GetUnitTarget("22E_T2ClockTower_UnitTarget");
		T_EnemyCover_2 = MR.Inst.GetUnitTarget("1CF_T2ClockTower_UnitTarget");
		DroidsMoveTo1 = MR.Inst.GetUnitTarget("15B_T2ClockTower_UnitTarget");
		DroidsMoveTo2 = MR.Inst.GetUnitTarget("9FD_T2ClockTower_UnitTarget");
		DroidsMoveTo3 = MR.Inst.GetUnitTarget("BE4_T2ClockTower_UnitTarget");
		DroidsMoveTo4 = MR.Inst.GetUnitTarget("560_T2ClockTower_UnitTarget");
		Target_Statue1 = MR.Inst.GetUnitTarget("B8E_T2ClockTower_UnitTarget");
		Target_Statue2 = MR.Inst.GetUnitTarget("768_T2ClockTower_UnitTarget");
		Target_Statue3 = MR.Inst.GetUnitTarget("009_T2ClockTower_UnitTarget");
		Target_Statue4 = MR.Inst.GetUnitTarget("1CB_T2ClockTower_UnitTarget");
		ArchieIdlePoint = MR.Inst.GetUnitTarget("706_T3CelestiaTownCentre_UnitTarget");
		NootIdlePoint = MR.Inst.GetUnitTarget("87F_T3CelestiaTownCentre_UnitTarget");
		AmbrosiaIdlePoint = MR.Inst.GetUnitTarget("A1A_T3CelestiaTownCentre_UnitTarget");
		MargotIdlePoint = MR.Inst.GetUnitTarget("5FC_T3CelestiaTownCentre_UnitTarget");
		ChrisIdlePoint = MR.Inst.GetUnitTarget("F8A_T3CelestiaTownCentre_UnitTarget");
		ArchiMoveTo = MR.Inst.GetUnitTarget("883_T3LandingPad_UnitTarget");
		NateMoveTo = MR.Inst.GetUnitTarget("C15_T3LandingPad_UnitTarget");
		NateMoveTo2 = MR.Inst.GetUnitTarget("1F7_T3LandingPad_UnitTarget");
		MargotMoveTo = MR.Inst.GetUnitTarget("5D4_T3LandingPad_UnitTarget");
		ArchiToCover = MR.Inst.GetUnitTarget("E9B_T3LandingPad_UnitTarget");
		UnitTarget T_Violin = MR.Inst.GetUnitTarget("390_T2ClockTower_UnitTarget");
		UnitTarget T_ExitPoint = MR.Inst.GetUnitTarget("27C_T3LandingPad_UnitTarget");
		UnitTarget LandingPadViolin = MR.Inst.GetUnitTarget("6EA_T3LandingPad_UnitTarget");
		ToClockTower = MR.Inst.GetTileActionSwapMap("98C_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		FromRoof = MR.Inst.GetTileActionSwapMap("57F_T2UnderclockMeetingRoom_TileActionSwapMap");
		FromRoofToClocktower = MR.Inst.GetTileActionSwapMap("4F3_T2ClockTower_TileActionSwapMap");
		SkyligthtToMeetingRoom = MR.Inst.GetTileActionSwapMap("1C7_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		FromArenaCarPark = MR.Inst.GetTileActionSwapMap("33D_T2TheKaydockArenaBar_TileActionSwapMap");
		ToArenaBar = MR.Inst.GetTileActionSwapMap("10B_T2TheKaydockArenaCarPark_TileActionSwapMap");
		ToCityCentre = MR.Inst.GetTileActionSwapMap("09A_T2ClockTower_TileActionSwapMap");
		FromTownCentre = MR.Inst.GetTileActionSwapMap("26F_T3CelestiaTownCentre_TileActionSwapMap");
		ToRelayTowerExterior = MR.Inst.GetTileActionSwapMap("64C_T3CelestiaTownCentre_TileActionSwapMap");
		FromTowerExterior = MR.Inst.GetTileActionSwapMap("55C_T3RelayTowerExterior_TileActionSwapMap");
		ToBotanicalGardens = MR.Inst.GetTileActionSwapMap("3D0_T3RelayTowerExterior_TileActionSwapMap");
		FromBotanicalGardens = MR.Inst.GetTileActionSwapMap("F18_T3LandingPad_TileActionSwapMap");
		ToLandingPad = MR.Inst.GetTileActionSwapMap("D80_T3BotanicalGardens_TileActionSwapMap");
		EvasionPointInteraction = MR.Inst.GetTileActionInteraction("D70_T2ClockTower_TileActionInteraction");
		ToTowerExteriorInteraction = MR.Inst.GetTileActionInteraction("2D5_T3CelestiaTownCentre_TileActionInteraction");
		NateInteraction = MR.Inst.GetTileActionInteraction("1A7_T3LandingPad_TileActionInteraction");
		a2s2_Violin = GetComponentInChildren<HAGIS_A2S2_Violin>();
		I_BackComputer = MR.Inst.GetTileActionInteraction("4DB_T2UnderclockMeetingRoom_TileActionInteraction");
		I_SafeAfter = MR.Inst.GetTileActionInteraction("143_T2UnderclockMeetingRoom_TileActionInteraction");
		TileActionInteraction I_RottenDoor = MR.Inst.GetTileActionInteraction("BC6_T2ClockTower_TileActionInteraction");
		TileActionInteraction I_ToLandingPad = MR.Inst.GetTileActionInteraction("FF2_T3BotanicalGardens_TileActionInteraction");
		I_Skylight = MR.Inst.GetTileActionInteraction("DE2_T2UnderclocksPoliceStation_Roof_TileActionInteraction");
		vaultBarrierOpen = MR.Inst.GetTileTrigger("534_T2UnderclockMeetingRoom_TileTrigger");
		vaultBarrierClose = MR.Inst.GetTileTrigger("F77_T2UnderclockMeetingRoom_TileTrigger");
		vaultBarrierClose1 = MR.Inst.GetTileTrigger("E28_T2UnderclockMeetingRoom_TileTrigger");
		vaultBarrierClose2 = MR.Inst.GetTileTrigger("B78_T2UnderclockMeetingRoom_TileTrigger");
		TileActionInteraction ToSkywayTrigger = MR.Inst.GetTileActionInteraction("E3A_T2TheKaydockArenaBar_TileActionInteraction");
		GardensTrigger = MR.Inst.GetTileTrigger("74C_T3BotanicalGardens_TileTrigger");
		OperaHouseDoorInteraction = MR.Inst.GetTileActionDialog("62F_T3CelestiaTownCentre_TileActionDialog");
		D_SafeBefore = MR.Inst.GetTileActionDialog("A90_T2UnderclockMeetingRoom_TileActionDialog");
		SpeakToVendor = MR.Inst.GetTileActionDialog("959_T3CelestiaTownCentre_TileActionDialog");
		OperaHouseWindowInteraction = MR.Inst.GetTileActionDialog("E7A_T3CelestiaTownCentre_TileActionDialog");
		BetaSignInteraction = MR.Inst.GetTileActionDialog("6E1_T3CelestiaTownCentre_TileActionDialog");
		OmegaSignInteraction = MR.Inst.GetTileActionDialog("629_T3CelestiaTownCentre_TileActionDialog");
		OmegaOfficesExit = MR.Inst.GetTileActionDialog("B7A_T3CelestiaTownCentre_TileActionDialog");
		WillaSpeaksToArchi = MR.Inst.GetTileActionDialog("FEB_T3CelestiaTownCentre_TileActionDialog");
		WillaSpeaksToMargot = MR.Inst.GetTileActionDialog("BB3_T3CelestiaTownCentre_TileActionDialog");
		WillaSpeaksToAmbrosia = MR.Inst.GetTileActionDialog("C13_T3CelestiaTownCentre_TileActionDialog");
		WillaSpeaksToChris = MR.Inst.GetTileActionDialog("950_T3CelestiaTownCentre_TileActionDialog");
		WillaSpeaksToNoot = MR.Inst.GetTileActionDialog("095_T3CelestiaTownCentre_TileActionDialog");
		FolliageInteraction = MR.Inst.GetTileActionDialog("76B_T3BotanicalGardens_TileActionDialog");
		NotThatWay = MR.Inst.GetTileActionDialog("D1A_T2TheKaydockArenaBar_TileActionDialog");
		Ambient_GetToTheClockTower = HAGIS.DialogLoad("Dialogs/A2S2/UnderclocksStationRoof/Ambient_GetToTheClockTower");
		Ambient_ArchisReady = HAGIS.DialogLoad("Dialogs/A2S2/UnderclocksStationRoof/Ambient_ArchisReady");
		Dialog_InPosition = HAGIS.DialogLoad("Dialogs/A2S2/UnderclocksStationRoof/Dialog_InPosition");
		Dialog_ImAlteringTheDeal = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Dialog_ImAlteringTheDeal");
		Dialog_ContributionToCulture = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Dialog_ContributionsToCulture");
		Dialog_RunRabbit = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Dialog_RunRabbit");
		Dialog_Goo = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Dialog_Go");
		Ambient_BackComputer1 = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Ambient_BackComputer1");
		Ambient_BackComputer2 = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Ambient_BackComputer2");
		Ambient_BackComputer3 = HAGIS.DialogLoad("Dialogs/A2S2/UnderclockMeetingRoom/Ambient_BackComputer3");
		Ambient_YouDumbHick = HAGIS.DialogLoad("Dialogs/A2S2/KaydockArenaCarPark/Ambient_YouDumbHick");
		Ambient_HeadUp = HAGIS.DialogLoad("Dialogs/A2S2/KaydockArenaCarPark/Ambient_HeadUp");
		Ambient_HitTheSkyway = HAGIS.DialogLoad("Dialogs/A2S2/KaydockArenaBar/Ambient_HitTheSkyway");
		Ambient_TheWoodsRotten = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Ambient_TheWoodsRotten");
		Ambient_Bad = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Ambient_Bad!");
		Ambient_Willa = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Ambient_Willa!");
		Ambient_Hold = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Ambient_Hold");
		Ambient_StupidQuestion = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Ambient_StupidQuestion");
		Dialog_ArchiAnyTrouble = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Dialog_ArchiAnyTrouble");
		Dialog_Run = HAGIS.DialogLoad("Dialogs/A2S2/Clocktower/Dialog_Run");
		Ambient_ItsSealedTight = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_ItsSealedTight");
		Ambient_GoodMorningCitizen = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_GoodMorningCitizen");
		Ambient_ItsAlive = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_ItsAlive");
		Ambeint_IWasntEvenBorn = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_IWasntEvenBorn");
		Ambient_BetaBlockAndRelay = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_BetaBlockAndReady");
		Ambient_OmegaOffices = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_OmegaOffices");
		Ambient_ItsSealed = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_ItsSealed");
		Ambient_WaitHereForUs = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Ambient_WaitHereForUs");
		Dialog_WeNeedToKeepGoing = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_WeNeedToKeepGoing");
		Dialog_IAlwaysWantedToSing = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_IAlwaysWantedToSing");
		Dialog_PearlsOfWisdom = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_PearlsOfWisdom");
		Dialog_WowThisPlace = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_WowThisPlace");
		Dialog_SaySomethingNoot = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_SaySomethingNoot");
		Dialog_GoodMorning = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_GoodMorning");
		Dialog_WeWait = HAGIS.DialogLoad("Dialogs/A2S2/CelestiaTownCentre/Dialog_WeWait");
		Dialog_DidYouKnow = HAGIS.DialogLoad("Dialogs/A2S2/RelayTowerExterior/Dialog_DidYouKnow");
		Ambient_UpTheStairs = HAGIS.DialogLoad("Dialogs/A2S2/Nu-TropicsBotanicalGarden/Ambient_UpTheStairs");
		Ambient_TheresSomeMachinery = HAGIS.DialogLoad("Dialogs/A2S2/Nu-TropicsBotanicalGarden/Ambient_TheresSomeMachinery");
		Ambient_DedicatedToSerena = HAGIS.DialogLoad("Dialogs/A2S2/Nu-TropicsBotanicalGarden/Ambient_DedicatedToSerena");
		Ambient_Foliage = HAGIS.DialogLoad("Dialogs/A2S2/Nu-TropicsBotanicalGarden/Ambient_Foliage");
		Dialog_AhMyCase = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_AhMyCase");
		Dialog_YourFactory = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_YourFactory");
		Dialog_ItsGreatToFinallyMeetYou = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_ItsGreatToFinallyMeetYou");
		Dialog_CravensToldMeSoMuch = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_CravensToldMeSoMuch");
		Dialog_SheWantsTheTruth = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_SheWantsTheTruth");
		Dialog_ImNotAPuppet = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_ImNotApuppet");
		Dialog_Stop = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_Stop");
		Dialog_Go = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_Go");
		Dialog_JulesIsWaiting = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Dialog_JulesIsWaiting");
		Ambient_ComeOnThink = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_ComeOnThink");
		Ambient_YouPrick = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_YouPrick");
		Ambient_CrapSorryOnceMore = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_CrapSorryOnceMore");
		Ambient_GrrrahCrap = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_Gr-r-rahCrap");
		Ambient_NoItsWilla = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_NoItsWilla");
		Ambient_IWontHurtHer = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_IWontHurtHer");
		Ambient_NoNotWilla = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_NoNotWilla");
		Ambient_Arg = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_Argh");
		Ambient_No = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_No");
		Ambient_NoNextTime = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_NoNextTime");
		Ambient_DamnBlinked = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_DamnBlinked");
		Ambient_ICant = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_ICant");
		Ambient_ThisTime = HAGIS.DialogLoad("Dialogs/A2S2/LandingPad/Ambient_ThisTime");
		string ClocktowerStatue = "MA_Statue";
		TileBlockDynamic dynColVaultDoor = MR.Inst.GetTileBlockDynamic("9F6_T2UnderclockMeetingRoom_TileBlockDynamic");
		TileBlockDynamic dynColVaultDoor2 = MR.Inst.GetTileBlockDynamic("6DE_T2UnderclockMeetingRoom_TileBlockDynamic");
		TileBlockDynamic dynColBarrier1 = MR.Inst.GetTileBlockDynamic("903_T2UnderclockMeetingRoom_TileBlockDynamic");
		TileBlockDynamic dynColBarrier2 = MR.Inst.GetTileBlockDynamic("EB9_T2UnderclockMeetingRoom_TileBlockDynamic");
		TileBlockDynamic dynColBarrier3 = MR.Inst.GetTileBlockDynamic("522_T2UnderclockMeetingRoom_TileBlockDynamic");
		TileBlockDynamic dynColDoorBlocker1 = MR.Inst.GetTileBlockDynamic("FD6_T2ClockTower_TileBlockDynamic");
		TileBlockDynamic dynColDoorBlocker2 = MR.Inst.GetTileBlockDynamic("733_T2ClockTower_TileBlockDynamic");
		TileBlockDynamic dynColDoorBlocker3 = MR.Inst.GetTileBlockDynamic("EA6_T2ClockTower_TileBlockDynamic");
		TileBlockDynamic dynColDoorBlocker4 = MR.Inst.GetTileBlockDynamic("F4A_T2ClockTower_TileBlockDynamic");
		string RoofSkylight = "MA_UnderClocks_SkyLight_02";
		I_Skylight.gameObject.SetActive(value: false);
		UnderclockDroid1.gameObject.SetActive(value: false);
		UnderclockDroid2.gameObject.SetActive(value: false);
		UnderclockDroid3.gameObject.SetActive(value: false);
		TheoRoof.gameObject.SetActive(value: false);
		ToClockTower.gameObject.SetActive(value: false);
		SkyligthtToMeetingRoom.gameObject.SetActive(value: false);
		UnderclockDroid4.gameObject.SetActive(value: false);
		UnderclockDroid5.gameObject.SetActive(value: false);
		GangsterTucker1.gameObject.SetActive(value: false);
		FromRoof.gameObject.SetActive(value: false);
		vaultBarrierOpen.gameObject.SetActive(value: false);
		vaultBarrierClose.gameObject.SetActive(value: false);
		vaultBarrierClose1.gameObject.SetActive(value: false);
		vaultBarrierClose2.gameObject.SetActive(value: false);
		I_BackComputer.gameObject.SetActive(value: false);
		dynColDoorBlocker1.gameObject.SetActive(value: false);
		dynColDoorBlocker2.gameObject.SetActive(value: false);
		dynColDoorBlocker3.gameObject.SetActive(value: false);
		dynColDoorBlocker4.gameObject.SetActive(value: false);
		I_SafeAfter.gameObject.SetActive(value: false);
		T_Violin.gameObject.SetActive(value: false);
		ToArenaBar.gameObject.SetActive(value: false);
		NotThatWay.gameObject.SetActive(value: false);
		GangsterMuscle1.gameObject.SetActive(value: false);
		GangsterMuscle2.gameObject.SetActive(value: false);
		GangsterMuscle3.gameObject.SetActive(value: false);
		TheoBar.gameObject.SetActive(value: false);
		BugsyBar.gameObject.SetActive(value: false);
		ToSkywayTrigger.gameObject.SetActive(value: false);
		ShopKeeperDroid.gameObject.SetActive(value: false);
		UnderclockSoldier1.gameObject.SetActive(value: false);
		UnderclockSoldier2.gameObject.SetActive(value: false);
		UnderclockSoldier3.gameObject.SetActive(value: false);
		UnderClockSolider4.gameObject.SetActive(value: false);
		UnderClockSolider5.gameObject.SetActive(value: false);
		UnderClockSolider6.gameObject.SetActive(value: false);
		UnderClockSolider7.gameObject.SetActive(value: false);
		TheoLandingPad.gameObject.SetActive(value: false);
		UC_Droid1.gameObject.SetActive(value: false);
		UC_Droid2.gameObject.SetActive(value: false);
		EvasionPointInteraction.gameObject.SetActive(value: false);
		ToTowerExteriorInteraction.gameObject.SetActive(value: false);
		ToCityCentre.gameObject.SetActive(value: false);
		ToRelayTowerExterior.gameObject.SetActive(value: false);
		ToBotanicalGardens.gameObject.SetActive(value: false);
		FromBotanicalGardens.gameObject.SetActive(value: false);
		ToLandingPad.gameObject.SetActive(value: false);
		Nate.gameObject.SetActive(value: false);
		LandingPadViolin.gameObject.SetActive(value: false);
		PlayMapAnimation(T2UnderclockStationRoof.Map, RoofSkylight, "Open");
		UnderclockSoldier1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderclockSoldier2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderclockSoldier3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderClockSolider4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderClockSolider5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderClockSolider6.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderClockSolider7.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		UnderclockSoldier1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderclockSoldier2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderclockSoldier3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderClockSolider4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderClockSolider5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderClockSolider6.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnderClockSolider7.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return null;
		SKIP_POINT("Car park");
		MusicPlay("event:/music/tracks/basic/drone 1");
		GC.Inst.SetRPGLeader(Archi);
		CutsceneBegin();
		UnitMoveToTarget(GangsterTucker3, TuckerCoverTarget1);
		UnitMoveToTarget(GangsterTucker4, TuckerCoverTarget2);
		UnitMoveToTarget(Archi, ArchiCoverTarget);
		UnitMoveToTarget(Chris, ChrisCoverTarget);
		yield return UnitMoveToTarget(Ambrosia, AmbrosiaCoverTarget);
		yield return HAGIS.DialogShow(Ambient_YouDumbHick);
		CutsceneEnd();
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase1);
		SKIP_POINT("Begin Fight");
		MusicPlay("event:/music/tracks/combat/generic combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/combat/tucker combat");
		SKIP_POINT("After car park fight");
		GangsterMuscle1.gameObject.SetActive(value: true);
		GangsterMuscle2.gameObject.SetActive(value: true);
		GangsterMuscle3.gameObject.SetActive(value: true);
		ToArenaBar.gameObject.SetActive(value: true);
		HAGIS.DialogShow(Ambient_HeadUp);
		SKIP_POINT("Car park");
		T2KaydockArenaBar.CanTeammatesFollow = false;
		T2KaydockArenaBar.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(T2KaydockArenaBar.Map);
		yield return null;
		FromArenaCarPark.gameObject.SetActive(value: false);
		yield return null;
		CombatBegin(UnitTeam.Type.Player);
		UnitMoveToTarget(Archi, ArchiCoverTarget1);
		UnitMoveToTarget(Chris, ChrisCoverTarget1);
		UnitMoveToTarget(Ambrosia, AmbrosiaCoverTarget1);
		yield return CombatWaitUntilComplete();
		MusicPlay("event:/music/tracks/basic/stealth old 1");
		T2KaydockArenaBar.CanTeammatesFollow = true;
		HAGIS.DialogShow(Ambient_HitTheSkyway);
		ToSkywayTrigger.gameObject.SetActive(value: true);
		NotThatWay.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase2);
		SKIP_POINT("Bar combat ends");
		yield return ToSkywayTrigger.OnTriggered;
		T2KaydockArenaBar.CanTeammatesFollow = false;
		yield return null;
		CutsceneBegin();
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		UnitMoveToTarget(Ambrosia, TeamExitToSkyway, null, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: false);
		yield return UnitMoveToTarget(Chris, TeamExitToSkyway, null, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: false);
		Chris.Hide(makeInactive: true);
		Archi.Hide(makeInactive: true);
		Ambrosia.Hide(makeInactive: true);
		yield return CreateTimeCondition(1.2f);
		yield return CreateTimeCondition(0.7f);
		MapGoto(T2UnderclockStationRoof.Map);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase3);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		yield return null;
		yield return Wait.ForSeconds(1.5f);
		SKIP_POINT("Transition to roof");
		yield return HAGIS.DialogShow(Ambient_ArchisReady);
		yield return HAGIS.DialogShow(Dialog_InPosition);
		I_Skylight.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(I_Skylight.OnTriggered);
		yield return CutscenePlay("A2S2_Cutscene_WillaEntersSkylight");
		GC.Inst.CutsceneBegin();
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		UnderclockDroid4.gameObject.SetActive(value: true);
		UnderclockDroid5.gameObject.SetActive(value: true);
		GangsterTucker1.gameObject.SetActive(value: true);
		UnitTeleportToMapViaEntranceTile(Willa, FromRoof, MoveToTarget2);
		UnitTeleportToMapViaEntranceTile(Margot, FromRoof, MoveToTarget1);
		UnitTeleportToMapViaEntranceTile(Noot, FromRoof, MoveToTarget3);
		yield return null;
		Willa.LookInDirection(OctDir.Right);
		Margot.LookInDirection(OctDir.Right);
		Noot.LookInDirection(OctDir.Right);
		Willa.gameObject.SetActive(value: false);
		Noot.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		GC.Inst.CutsceneEnd();
		yield return MapGoto(T2UnderclockMeetingRoom);
		MusicPlay("event:/music/tracks/basic/theo theme");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return CutscenePlay("A2S2_Cutscene_MeetingRoom");
		SKIP_POINT("Combat Begin");
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_Goo);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase4);
		Willa.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		Margot.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		Noot.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		GangsterTucker1.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(0.5f);
		UnitPlayAnimation(GangsterTucker1, "TransDIdleToCIdle");
		GangsterTucker1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		GangsterTucker1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		GangsterTucker2.LookInDirection(OctDir.Left);
		UnitPlayAnimation(GangsterTucker2, "TransDIdleToCIdle");
		GangsterTucker2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		GangsterTucker1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		GangsterTucker1.UpdateIdleAnim();
		GangsterTucker2.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		UnitMoveToTarget(Willa, T_WillaCover, null, 5f);
		UnitMoveToTarget(Noot, T_NootCover, null, 5f);
		UnitMoveToTarget(Margot, T_MargotCover, null, 5f);
		yield return CreateAndCondition(UnitMoveToTarget(GangsterTucker2, T_EnemyCover, null, 5f), UnitMoveToTarget(GangsterTucker1, T_EnemyCover3, null, 5f), UnitMoveToTarget(UnderclockDroid5, T_EnemyCover4, null, 5f), UnitMoveToTarget(UnderclockDroid4, T_EnemyCover2, null, 5f));
		GangsterTucker2.LookAt(Willa);
		GangsterTucker1.LookAt(Willa);
		UnderclockDroid5.LookAt(Willa);
		UnderclockDroid4.LookAt(Willa);
		vaultBarrierOpen.gameObject.SetActive(value: true);
		vaultBarrierClose.gameObject.SetActive(value: true);
		vaultBarrierClose1.gameObject.SetActive(value: true);
		vaultBarrierClose2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Noot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		CutsceneEnd();
		FromRoof.gameObject.SetActive(value: false);
		SkyligthtToMeetingRoom.gameObject.SetActive(value: true);
		yield return CombatBegin(UnitTeam.Type.Player);
		SKIP_POINT("Unlock safe");
		I_BackComputer.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/exploration/random light 1");
		ParticlePrefab I_BackComputerHighlight = ShowCoordSelect(I_BackComputer.GetCoord());
		yield return CreateTriggerCondition(I_BackComputer.OnTriggered);
		I_BackComputerHighlight.StopParticles();
		CutsceneBegin();
		D_SafeBefore.gameObject.SetActive(value: false);
		I_SafeAfter.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(Ambient_BackComputer1);
		yield return null;
		UnitPlayAnimation(Willa, "DefaultInteract");
		yield return CreateTimeCondition(0.5f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o4/hack complete", sfx_underclock_terminal);
		yield return HAGIS.DialogShow(Ambient_BackComputer2);
		UnitPlayAnimation(Willa, "DefaultInteract");
		yield return CreateTimeCondition(0.5f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o4/hack complete", sfx_underclock_terminal);
		yield return CreateTimeCondition(0.5f);
		SFXPlayAtCoord("event:/sfx/script/act 1/a1o4/chris hacks open deusoft back room door", sfx_underclock_vault_unlock);
		yield return CreateTimeCondition(0.5f);
		Willa.LookInDirection(OctDir.DownRight);
		yield return HAGIS.DialogShow(Ambient_BackComputer3);
		dynColBarrier1.gameObject.SetActive(value: false);
		dynColBarrier2.gameObject.SetActive(value: false);
		dynColBarrier3.gameObject.SetActive(value: false);
		CutsceneEnd();
		ParticlePrefab I_SafeAfterHighlight = ShowCoordSelect(I_SafeAfter.GetCoord());
		yield return CreateTriggerCondition(I_SafeAfter.OnTriggered);
		I_SafeAfterHighlight.StopParticles();
		dynColVaultDoor.gameObject.SetActive(value: false);
		dynColVaultDoor2.gameObject.SetActive(value: false);
		yield return CutscenePlay("A2S2_Cutscene_WillaOpensSafe");
		dynColVaultDoor.gameObject.SetActive(value: true);
		dynColVaultDoor2.gameObject.SetActive(value: true);
		I_Skylight.gameObject.SetActive(value: false);
		SkyligthtToMeetingRoom.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase5);
		FromRoof.gameObject.SetActive(value: true);
		HagisLog("back to roof");
		yield return MapWaitUntilVisible(T2UnderclockStationRoof.Map);
		MusicStop();
		ToClockTower.gameObject.SetActive(value: true);
		PlayMapAnimation(T2ClockTower.Map, ClocktowerStatue, "RevealDoor");
		Target_Statue1.gameObject.SetActive(value: false);
		Target_Statue2.gameObject.SetActive(value: false);
		Target_Statue3.gameObject.SetActive(value: true);
		Target_Statue4.gameObject.SetActive(value: true);
		SKIP_POINT("Get to the clocktower");
		yield return MapWaitUntilVisible(T2ClockTower.Map);
		MusicPlay("event:/music/tracks/basic/three heads are better");
		yield return CreateTriggerCondition(I_RottenDoor.OnTriggered);
		T2ClockTower.unitsMoveToDefaultPositions = false;
		yield return CutscenePlay("A2S2_Cutscene_ClocktowerDoorOpen");
		CutsceneBegin();
		UnitTeleportToMapViaEntranceTile(Archi, FromRoofToClocktower, ArchiCover);
		yield return CreateTimeCondition(0.5f);
		UnitTeleportToMapViaEntranceTile(Chris, FromRoofToClocktower, ChrisCover);
		yield return CreateTimeCondition(0.5f);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, FromRoofToClocktower, AmbrosiaCover);
		SFXPlay("event:/sfx/script/act 1/a1o8/bar fight next door");
		Willa.LookAt(Archi);
		Chris.LookAt(Archi);
		Ambrosia.LookAt(Archi);
		Noot.LookAt(Archi);
		Margot.LookAt(Archi);
		yield return HAGIS.DialogShow(Dialog_ArchiAnyTrouble);
		UnderclockSoldier1.gameObject.SetActive(value: true);
		UnderclockSoldier2.gameObject.SetActive(value: true);
		UnderclockSoldier3.gameObject.SetActive(value: true);
		yield return CreateOrCondition(UnitMoveToTarget(UnderclockSoldier1, T_EnemyCover_1, null, 5f), UnitMoveToTarget(UnderclockSoldier2, T_EnemyCover_2, null, 5f));
		yield return CreateOrCondition(UnitMoveToTarget(Archi, CoverTarget1), UnitMoveToTarget(Noot, CoverTarget5), UnitMoveToTarget(Chris, CoverTarget4));
		yield return HAGIS.DialogShow(Ambient_StupidQuestion);
		SKIP_POINT("ambrosia, chris and margot head up stair case ");
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		yield return CutscenePlay("A2S2_Cutscene_ClocktowerTeamLeaves");
		ToCityCentre.gameObject.SetActive(value: true);
		yield return null;
		ToCityCentre.gameObject.SetActive(value: false);
		yield return null;
		SKIP_POINT("Time to escape");
		yield return null;
		MusicPlay("event:/music/tracks/combat/frenzy");
		dynColDoorBlocker1.gameObject.SetActive(value: true);
		dynColDoorBlocker2.gameObject.SetActive(value: true);
		dynColDoorBlocker3.gameObject.SetActive(value: true);
		dynColDoorBlocker4.gameObject.SetActive(value: true);
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/new savannah intro");
		yield return null;
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		dynColDoorBlocker1.gameObject.SetActive(value: false);
		dynColDoorBlocker2.gameObject.SetActive(value: false);
		dynColDoorBlocker3.gameObject.SetActive(value: false);
		dynColDoorBlocker4.gameObject.SetActive(value: false);
		yield return CutscenePlay("A2S2_Cutscene_WillaAndTeamExit");
		UnitTeleportToMapViaEntranceTile(Archi, FromTownCentre);
		yield return UnitTeleportToMapViaEntranceTile(Noot, FromTownCentre);
		HagisLog("End of Clocktower");
		CutsceneBegin();
		UnitMoveToTarget(Chris, ChrisIdlePoint, OctDir.Left);
		UnitMoveToTarget(Margot, MargotIdlePoint, OctDir.Down);
		UnitMoveToTarget(Ambrosia, AmbrosiaIdlePoint, OctDir.Left);
		UnitMoveToTarget(Archi, ArchieIdlePoint, OctDir.Right);
		UnitMoveToTarget(Noot, NootIdlePoint, OctDir.Up);
		yield return null;
		ChrisIdlePoint.gameObject.SetActive(value: false);
		NootIdlePoint.gameObject.SetActive(value: false);
		AmbrosiaIdlePoint.gameObject.SetActive(value: false);
		MargotIdlePoint.gameObject.SetActive(value: false);
		ArchieIdlePoint.gameObject.SetActive(value: false);
		yield return MapGoto(T2CelestiaTownCentre);
		CutsceneEnd();
		SKIP_POINT("Town Centre ");
		CutsceneBegin();
		yield return CreateTimeCondition(2f);
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromTownCentre);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		FromTownCentre.gameObject.SetActive(value: false);
		ShopKeeperDroid.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Willa, WillaMoveToPoint);
		yield return Willa.unitModel.Play("CsDefaultLookAroundViolin");
		yield return HAGIS.DialogShow(Dialog_WeWait);
		ToTowerExteriorInteraction.gameObject.SetActive(value: true);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objPhase6);
		yield return CreateTriggerCondition(ToTowerExteriorInteraction.OnTriggered);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Ambient_WaitHereForUs);
		ToBotanicalGardens.gameObject.SetActive(value: true);
		FromBotanicalGardens.gameObject.SetActive(value: true);
		ToRelayTowerExterior.gameObject.SetActive(value: true);
		yield return TeamMoveToMapViaEntranceTile(FromTowerExterior);
		CutsceneEnd();
		SKIP_POINT("Tower exterior");
		MusicStop();
		FromTowerExterior.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Dialog_DidYouKnow);
		yield return MapWaitUntilVisible(T2Nu_TropicsBontanicalGarden.Map);
		SKIP_POINT("Botanical gardens");
		yield return HAGIS.DialogShow(Ambient_UpTheStairs);
		ToLandingPad.gameObject.SetActive(value: false);
		Nate.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(GardensTrigger._OnTriggered);
		CutsceneBegin();
		Willa.LookInDirection(OctDir.DownRight);
		yield return HAGIS.DialogShow(Ambient_Foliage);
		CutsceneEnd();
		yield return CreateTriggerCondition(I_ToLandingPad.OnTriggered);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		yield return CreateAndCondition(UnitTeleportToMapViaEntranceTile(Willa, FromBotanicalGardens), UnitTeleportToMapViaEntranceTile(Archi, FromBotanicalGardens), UnitTeleportToMapViaEntranceTile(Chris, FromBotanicalGardens), UnitTeleportToMapViaEntranceTile(Margot, FromBotanicalGardens));
		Willa.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		Chris.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		FromBotanicalGardens.gameObject.SetActive(value: false);
		yield return MapGoto(T2LandingPad);
		SKIP_POINT("Landing pad");
		MusicPlay("event:/music/tracks/basic/chumleys theme");
		yield return CutscenePlay("A2S2_Cutscene_LandingPadMeeting");
		Willa.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objPhase6);
		yield return CutscenePlay("A2S2_Cutscene_NateConfrontation");
		SKIP_POINT("Just Before Willa fight");
		yield return null;
		yield return CutscenePlay("A2S2_Cutscene_SparksFly");
		SKIP_POINT("Willa fight");
		Willa.SetTeamType(UnitTeam.Type.Enemy);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objStopHer);
		Archi.abilities.Add<Ability_RefuseAttack>(null, isUpgraded: false);
		Chris.abilities.Add<Ability_RefuseAttack>(null, isUpgraded: false);
		Ambrosia.abilities.Add<Ability_RefuseAttack>(null, isUpgraded: false);
		Willa.abilities.Add<Ability_DEBUG_CantDieWontKill>(null, isUpgraded: false);
		ConstArray<Unit> allPlayers = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetActiveMembers();
		for (int i = 0; i < allPlayers.Length; i++)
		{
			Unit unit = allPlayers[i];
			unit.IsAbilityUseDisabled = true;
			unit.reasonForDisablingAbilities = "ABILITYWHEELDISABLED_NOTWILLA";
			foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
			{
				if (!item.IsManuallyActivated())
				{
					unit.abilities.Remove(item, isProxy: false);
				}
			}
		}
		MusicPlay("event:/music/tracks/combat/willas combat");
		CombatBegin(UnitTeam.Type.Player);
		while (true)
		{
			HagletYieldTerm archiAttacked = CreateTriggerCondition(Archi.OnFinishedAttack);
			HagletYieldTerm chrisAttacked = CreateTriggerCondition(Chris.OnFinishedAttack);
			HagletYieldTerm margotAttacked = CreateTriggerCondition(Margot.OnFinishedAttack);
			yield return CreateOrCondition(archiAttacked, chrisAttacked, margotAttacked, TurnModeWaitForEnemyTurnStart());
			if (archiAttacked.met)
			{
				HAGIS.DialogShow(Ambient_CrapSorryOnceMore);
				Archi.APDecrement(Archi.AP);
			}
			else if (chrisAttacked.met)
			{
				HAGIS.DialogShow(Ambient_NoNextTime);
				Chris.APDecrement(Chris.AP);
			}
			else
			{
				if (!margotAttacked.met)
				{
					break;
				}
				HAGIS.DialogShow(Ambient_DamnBlinked);
				Margot.APDecrement(Margot.AP);
			}
			Singleton<PC>.Inst.ChangeLeaderToNextWithAP();
		}
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		HagisLog("Willa's turn, going to turn 2!");
		while (true)
		{
			HagletYieldTerm archiAttacked2 = CreateTriggerCondition(Archi.OnFinishedAttack);
			HagletYieldTerm chrisAttacked2 = CreateTriggerCondition(Chris.OnFinishedAttack);
			HagletYieldTerm margotAttacked2 = CreateTriggerCondition(Margot.OnFinishedAttack);
			yield return CreateOrCondition(archiAttacked2, chrisAttacked2, margotAttacked2, TurnModeWaitForEnemyTurnStart());
			if (archiAttacked2.met)
			{
				HAGIS.DialogShow(Ambient_GrrrahCrap);
				Archi.APDecrement(Archi.AP);
			}
			else if (chrisAttacked2.met)
			{
				HAGIS.DialogShow(Ambient_ICant);
				Chris.APDecrement(Chris.AP);
			}
			else
			{
				if (!margotAttacked2.met)
				{
					break;
				}
				HAGIS.DialogShow(Ambient_ThisTime);
				Margot.APDecrement(Margot.AP);
			}
			Singleton<PC>.Inst.ChangeLeaderToNextWithAP();
		}
		do
		{
			HagletYieldTerm archiAttacked3 = ((Archi.teamType != 0) ? DontWait() : CreateTriggerCondition(Archi.OnFinishedAttack));
			HagletYieldTerm chrisAttacked3 = ((Chris.teamType != 0) ? DontWait() : CreateTriggerCondition(Chris.OnFinishedAttack));
			HagletYieldTerm margotAttacked3 = ((Margot.teamType != 0) ? DontWait() : CreateTriggerCondition(Margot.OnFinishedAttack));
			yield return CreateOrCondition(archiAttacked3, chrisAttacked3, margotAttacked3, TurnModeWaitForEnemyTurnStart());
			Unit attacker = null;
			DialogData unitDialog2 = null;
			if (archiAttacked3.met)
			{
				attacker = Archi;
				unitDialog2 = Ambient_NoItsWilla;
			}
			else if (chrisAttacked3.met)
			{
				attacker = Chris;
				unitDialog2 = Ambient_IWontHurtHer;
			}
			else
			{
				if (!margotAttacked3.met)
				{
					break;
				}
				attacker = Margot;
				unitDialog2 = Ambient_NoNotWilla;
			}
			CutsceneBegin();
			yield return HAGIS.DialogShow(unitDialog2);
			yield return UnitMoveToTarget(attacker, T_ExitPoint, null, null, optionalUnit: false, ignoreUnitAtDestination: true, shouldReserveTile: false);
			attacker.APDecrement(attacker.AP);
			yield return UnitHide(attacker, makeInactive: false);
			attacker.SetTeamType(UnitTeam.Type.NPC);
			CutsceneEnd();
		}
		while (SizeOfPlayerTeam() != 1);
		yield return EndTurnMode();
		CutsceneBegin();
		while (SizeOfPlayerTeam() > 0)
		{
			Unit member = TeamGetFirstPlayerUnit();
			DialogData unitDialog = null;
			switch (member.charData.partyMemberID)
			{
			case PartyMemberID.Archi:
				unitDialog = Ambient_NoItsWilla;
				Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
				break;
			case PartyMemberID.Margot:
				unitDialog = Ambient_NoNotWilla;
				break;
			case PartyMemberID.Chris:
				unitDialog = Ambient_IWontHurtHer;
				break;
			}
			yield return HAGIS.DialogShow(unitDialog);
			yield return UnitMoveToTarget(member, T_ExitPoint, null, null, optionalUnit: false, ignoreUnitAtDestination: true, shouldReserveTile: false);
			yield return UnitHide(member, makeInactive: false);
			member.SetTeamType(UnitTeam.Type.NPC);
		}
		Willa.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		Nate.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		SKIP_POINT("After Willa fight");
		MusicStop();
		yield return CreateTimeCondition(1f);
		yield return CutscenePlay("A2S2_Cutscene_AfterWillaFight");
		SKIP_POINT("Final cutscene");
		yield return CutscenePlay("A2S2_Cutscene_TheoArrives");
		yield return CutscenePlay("A2S2_Cutscene_NateDies");
		HagisLog("Mission end");
	}
}
public class HAGIS_A2S2_BarrierTrigger : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		TileTrigger closeFieldTrigger1 = MR.Inst.GetTileTrigger("F77_T2UnderclockMeetingRoom_TileTrigger");
		TileTrigger closeFieldTrigger2 = MR.Inst.GetTileTrigger("E28_T2UnderclockMeetingRoom_TileTrigger");
		TileTrigger closeFieldTrigger3 = MR.Inst.GetTileTrigger("B78_T2UnderclockMeetingRoom_TileTrigger");
		TileTrigger openFieldTrigger = MR.Inst.GetTileTrigger("534_T2UnderclockMeetingRoom_TileTrigger");
		LogicRoot meetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		Unit Willa = MR.Inst.GetUnit("654_T2UnderclocksPoliceStation_Roof_UnitSpawn");
		yield return null;
		PlayMapAnimation(meetingRoom.Map, "MA_HologramShield_01", "ShieldClose");
		bool shieldOpen = false;
		while (true)
		{
			HagletYieldTerm shieldOpenTriggered = CreateTriggerCondition(openFieldTrigger._OnTriggered);
			HagletYieldTerm shieldCloseTriggered1 = CreateTriggerCondition(closeFieldTrigger1._OnTriggered);
			HagletYieldTerm shieldCloseTriggered2 = CreateTriggerCondition(closeFieldTrigger2._OnTriggered);
			HagletYieldTerm shieldCloseTriggered3 = CreateTriggerCondition(closeFieldTrigger3._OnTriggered);
			yield return shieldOpenTriggered | shieldCloseTriggered1 | shieldCloseTriggered2 | shieldCloseTriggered3;
			if ((shieldCloseTriggered1.met || shieldCloseTriggered2.met || shieldCloseTriggered3.met) && shieldOpen)
			{
				PlayMapAnimation(meetingRoom.Map, "MA_HologramShield_01", "ShieldClose");
				shieldOpen = false;
			}
			if (shieldOpenTriggered.met && !shieldOpen)
			{
				PlayMapAnimation(meetingRoom.Map, "MA_HologramShield_01", "ShieldOpen");
				shieldOpen = true;
			}
		}
	}

	private void LogTrigger(TileTrigger trigger)
	{
		HagisLog((!(trigger.GetAnyUnitInTrigger() == null)) ? (trigger.GetAnyUnitInTrigger().charData.DisplayName + " in Trigger " + trigger.name) : ("No Units in Trigger " + trigger.name));
	}
}
public class HAGIS_A2S2_CrowAnimations : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Unit TownCrow = GC.Inst.GetUnitWithId("21A_T3CelestiaTownCentre_UnitSpawn");
		Unit TownCrow2 = GC.Inst.GetUnitWithId("B95_T3CelestiaTownCentre_UnitSpawn");
		TownCrow.unitModel.HACK_BirdMode = true;
		TownCrow2.unitModel.HACK_BirdMode = true;
		TileTrigger TT_ACTIVITEBIRDS = MR.Inst.GetTileTrigger("01C_T3CelestiaTownCentre_TileTrigger");
		LogicRoot CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		yield return null;
		yield return TT_ACTIVITEBIRDS._OnTriggered;
		yield return null;
		UnitPlayAnimation(TownCrow2, "DefaultTakeOff");
		TownCrow2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultTakeOff");
		yield return CreateTimeCondition(2f);
		UnitPlayAnimation(TownCrow, "DefaultTakeOff");
		yield return CreateTimeCondition(5f);
		TownCrow2.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		TownCrow2.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		yield return CreateTimeCondition(1f);
		TownCrow.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		TownCrow.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		TownCrow.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		TownCrow2.unitModel.Play(UnitModel.AnimID.DefaultIdle);
	}
}
public class HAGIS_A2S2_Violin : HAGIS
{
	[HideInInspector]
	public TileTrigger SkylightTrigger;

	[HideInInspector]
	public TileActionInteraction ViolinPickup;

	[HideInInspector]
	public TileActionInteraction BackToRoof;

	private Unit Willa;

	private TileActionDialog DroidInteraction;

	private DialogData Dialog_GoodMorning;

	private DialogData Ambient_GoodMorningCitizen;

	public string objGetToTheRoof = "Get to the Clock Tower";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
	}
}
public class HAGIS_A3O1 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Ambro;

	private Unit Rupert;

	private Unit Bartender;

	private Unit CutscenePortGuard;

	private Unit PortGuard1;

	private Unit PortGuard2;

	private Unit CamShiner1;

	private Unit CamShiner2;

	private Unit SlagSubwayShinner1;

	private Unit SlagSubwayShinner2;

	private Unit SlagEntShinner1;

	private Unit SlagEntShinner2;

	private Unit SlagMainShinner1;

	private Unit SlagMainShinner2;

	private Unit SlagMainShinner3;

	private UnitTarget WillasCover;

	private UnitTarget PortGuard1Cover;

	private UnitTarget PortGuard2Cover;

	private UnitTarget WillaArgueSpot;

	private UnitTarget ArchiArgueSpot;

	private UnitTarget AmbroRockSpot;

	private UnitTarget T_CamShiner1;

	private UnitTarget T_CamShiner2;

	private UnitTarget WillaCambridgeSubwayMovePoint;

	private UnitTarget ArchiCambridgeSubwayMovePoint;

	private UnitTarget AmbroCambridgeSubwayMovePoint;

	private UnitTarget ArchiSlagSubwayCover;

	private UnitTarget AmbroSlagSubwayCover;

	private UnitTarget WillaSlagSubwayCover;

	private UnitTarget WillaSlagEntrancePoint;

	private UnitTarget ArchiSlagEntrancePoint;

	private UnitTarget AmbroSlagEntrancePoint;

	private UnitTarget AmbroSlagMainCover;

	private UnitTarget WillaSlagMainCover;

	private UnitTarget ArchiSlagMainCover;

	private UnitTarget T_EnemyCover_Slags;

	private UnitTarget AmbroSlagMainCutscene;

	private UnitTarget WillaSlagMainCutscene;

	private UnitTarget ArchiSlagMainCutscene;

	private UnitTarget RupertSlagMainCutscene;

	private UnitTarget RupertsLookBackSpot;

	private UnitTarget P_TUnitTarget_RupertsGun;

	private TileActionSwapMap ToPortEntrance;

	private TileActionSwapMap FromPortHara;

	private TileActionSwapMap PortEntranceToSubway;

	private TileActionSwapMap TrainToAnywhere;

	private TileActionSwapMap TrainFromCam;

	private TileActionSwapMap CambridgeToSubway;

	private TileActionSwapMap CambridgeToGrickle;

	private TileActionSwapMap PimGrickleToCambridge;

	private TileActionSwapMap ToDistillery;

	private TileActionSwapMap FromGrickle;

	private TileActionSwapMap FromCambridge;

	private TileActionSwapMap CambridgeStationToTrain;

	private TileActionSwapMap ToSlagEntrance;

	private TileActionSwapMap FromSlagSubway;

	private TileActionSwapMap SlagEntranceToSlagMain;

	private TileActionSwapMap FromSlagEntrance;

	private TileTrigger SlagSubwaySteatlhTrigger;

	private TileTrigger TT_OnLeave;

	private TileTrigger StartSlagEntraceCombat;

	private TileActionInteraction BarDialogTrigger;

	private TileActionInteraction AmbroDistilleryDialogTile;

	private TileActionInteraction ArchiDistilleryDialogTile;

	private TileActionInteraction I_DoorToSlagEnt;

	private TileActionInteraction MissionEndActionTile;

	private TileActionInteraction TrainToCam;

	private TileActionInteraction TrainToSlags;

	private TileBlockDynamic S1;

	private TileBlockDynamic S2;

	private TileBlockDynamic S3;

	private TileActionDialog D_Bartender;

	private DialogData Ambient_WillaWashedUp;

	private DialogData Ambient_TimeToFindArchi;

	private DialogData Ambient_WillaBringIt;

	private DialogData Ambient_HowsArchiDoing;

	private DialogData Dialog_DontShootArchi;

	private DialogData Ambient_WhereIsHe;

	private DialogData Ambient_WillaCantGoBackThere;

	private DialogData Dialog_WillaGetTheirHelp;

	private DialogData Dialog_WillaReturns;

	private DialogData Dialog_WillaReturnsToAmbroAgain;

	private DialogData Dialog_WillaConfrontingArchi1;

	private DialogData Dialog_WillaConfrontingArchi2;

	private DialogData Dialog_WillaReasoningArchi1;

	private DialogData Dialog_WillaReasoningArchi2;

	private DialogData Dialog_DisilleryDialogEnd;

	private DialogData Ambient_TufoLaserCutter;

	private DialogData Ambient_WillaArchiTrainArgument;

	private DialogData Ambient_SlagBickering;

	private DialogData Ambient_MoreSlagBickering;

	private DialogData Ambient_EvenMoreSlagBicking;

	private DialogData Ambient_SlagBickingEnd;

	private DialogData Dialog_RupertGivesUp;

	private DialogData Dialog_ArchiExilesRupert;

	private DialogData Dialog_TroublesComing;

	private DialogData Dialog_Thanks;

	private DialogData Dialog_ArchiWheresMargot;

	private string objHeadToGrickle = "OBJECTIVES_A3O1_01";

	private string objTalkToArchi = "OBJECTIVES_A3O1_02";

	private string objSearchForRupert = "OBJECTIVES_A3O1_03";

	private string objHeadbackToSlagEntrance = "OBJECTIVES_A3O1_04";

	private Hagis_A3O1_AmbroDialog a3o1_AmbroDialog;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot PortHara = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot PortHaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot Train = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot CambridgeSubwayStation = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot Cambridge = GetLogicUsingArtName("T1Cambridge");
		LogicRoot PimGrickle = GetLogicUsingArtName("T1PimDickles");
		LogicRoot Distillery = GetLogicUsingArtName("T1AlembicDistillery");
		LogicRoot SlagEntrance = GetLogicUsingArtName("T1Slags_Ent");
		LogicRoot SlagMain = GetLogicUsingArtName("T1Slags");
		Willa = GC.Inst.GetUnitWithId("B96_T1Port2_HaraMainBay_UnitSpawn");
		CutscenePortGuard = GC.Inst.GetUnitWithId("E77_T1Port2_HaraMainBay_UnitSpawn");
		PortGuard1 = GC.Inst.GetUnitWithId("122_T1Port2_HaraMainBay_UnitSpawn");
		PortGuard2 = GC.Inst.GetUnitWithId("F75_T1Port2_HaraMainBay_UnitSpawn");
		Bartender = GC.Inst.GetUnitWithId("0D4_T1PimDickles_UnitSpawn");
		Ambro = GC.Inst.GetUnitWithId("5C1_T1AlembicDistillery_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("79D_T1AlembicDistillery_UnitSpawn");
		CamShiner1 = GC.Inst.GetUnitWithId("510_T1Subway_Station_Cambridge_UnitSpawn");
		CamShiner2 = GC.Inst.GetUnitWithId("234_T1Subway_Station_Cambridge_UnitSpawn");
		SlagEntShinner1 = GC.Inst.GetUnitWithId("E8B_T1Slags_Ent_UnitSpawn");
		SlagEntShinner2 = GC.Inst.GetUnitWithId("A75_T1Slags_Ent_UnitSpawn");
		SlagMainShinner1 = GC.Inst.GetUnitWithId("A6A_T1Slags_UnitSpawn");
		SlagMainShinner1 = GC.Inst.GetUnitWithId("737_T1Slags_UnitSpawn");
		SlagMainShinner1 = GC.Inst.GetUnitWithId("025_T1Slags_UnitSpawn");
		Rupert = GC.Inst.GetUnitWithId("43F_T1Slags_UnitSpawn");
		WillasCover = MR.Inst.GetUnitTarget("B6C_T1Port2_HaraMainBay_UnitTarget");
		PortGuard1Cover = MR.Inst.GetUnitTarget("3C0_T1Port2_HaraMainBay_UnitTarget");
		PortGuard2Cover = MR.Inst.GetUnitTarget("6F3_T1Port2_HaraMainBay_UnitTarget");
		WillaArgueSpot = MR.Inst.GetUnitTarget("48F_T1Subway_TrainInterior_UnitTarget");
		ArchiArgueSpot = MR.Inst.GetUnitTarget("ED9_T1Subway_TrainInterior_UnitTarget");
		AmbroRockSpot = MR.Inst.GetUnitTarget("A47_T1Subway_TrainInterior_UnitTarget");
		T_CamShiner1 = MR.Inst.GetUnitTarget("94A_T1Subway_Station_Cambridge_UnitTarget");
		T_CamShiner2 = MR.Inst.GetUnitTarget("6E3_T1Subway_Station_Cambridge_UnitTarget");
		WillaCambridgeSubwayMovePoint = MR.Inst.GetUnitTarget("AE7_T1Subway_Station_Cambridge_UnitTarget");
		ArchiCambridgeSubwayMovePoint = MR.Inst.GetUnitTarget("604_T1Subway_Station_Cambridge_UnitTarget");
		AmbroCambridgeSubwayMovePoint = MR.Inst.GetUnitTarget("6FA_T1Subway_Station_Cambridge_UnitTarget");
		WillaSlagEntrancePoint = MR.Inst.GetUnitTarget("C2C_T1Slags_Ent_UnitTarget");
		ArchiSlagEntrancePoint = MR.Inst.GetUnitTarget("53B_T1Slags_Ent_UnitTarget");
		AmbroSlagEntrancePoint = MR.Inst.GetUnitTarget("FB4_T1Slags_Ent_UnitTarget");
		WillaSlagMainCover = MR.Inst.GetUnitTarget("333_T1Slags_UnitTarget");
		ArchiSlagMainCover = MR.Inst.GetUnitTarget("3FC_T1Slags_UnitTarget");
		AmbroSlagMainCover = MR.Inst.GetUnitTarget("F3D_T1Slags_Ent_UnitTarget");
		T_EnemyCover_Slags = MR.Inst.GetUnitTarget("7B0_T1Slags_Ent_UnitTarget");
		WillaSlagMainCutscene = MR.Inst.GetUnitTarget("441_T1Slags_UnitTarget");
		AmbroSlagMainCutscene = MR.Inst.GetUnitTarget("AE2_T1Slags_UnitTarget");
		ArchiSlagMainCutscene = MR.Inst.GetUnitTarget("590_T1Slags_UnitTarget");
		RupertSlagMainCutscene = MR.Inst.GetUnitTarget("5B9_T1Slags_UnitTarget");
		RupertsLookBackSpot = MR.Inst.GetUnitTarget("1E4_T1Slags_UnitTarget");
		P_TUnitTarget_RupertsGun = MR.Inst.GetUnitTarget("3DF_T1Slags_UnitTarget");
		Ambient_WillaWashedUp = HAGIS.DialogLoad("Dialogs/A3O1/1_PortHara/Ambient_WillaWashedUp");
		Ambient_WillaBringIt = HAGIS.DialogLoad("Dialogs/A3O1/1_PortHara/Ambient_WillaBringIt");
		Ambient_TimeToFindArchi = HAGIS.DialogLoad("Dialogs/A3O1/1_PortHara/Ambient_TimeToFindArchi");
		Ambient_HowsArchiDoing = HAGIS.DialogLoad("Dialogs/A3O1/3_PortSubwayStation/Ambient_HowsArchiDoing");
		Dialog_DontShootArchi = HAGIS.DialogLoad("Dialogs/A3O1/4_Train/Dialog_DontShootArchi");
		Ambient_WhereIsHe = HAGIS.DialogLoad("Dialogs/A3O1/5_Cambridge/Ambient_WhereIsHe");
		Ambient_WillaCantGoBackThere = HAGIS.DialogLoad("Dialogs/A3O1/6_PimGrickle/Ambient_WillaCantGoBackThere");
		Dialog_WillaGetTheirHelp = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaGetTheirHelp");
		Dialog_WillaReturns = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReturns");
		Dialog_WillaReturnsToAmbroAgain = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReturnsToAmbroAgain");
		Dialog_WillaConfrontingArchi1 = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaConfrontingArchi1");
		Dialog_WillaConfrontingArchi2 = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaConfrontingArchi2");
		Dialog_WillaReasoningArchi1 = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReasoningArchi1");
		Dialog_WillaReasoningArchi2 = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReasoningArchi2");
		Dialog_DisilleryDialogEnd = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_DisilleryDialogEnd");
		Ambient_TufoLaserCutter = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Ambient_TufoLaserCutter");
		Ambient_WillaArchiTrainArgument = HAGIS.DialogLoad("Dialogs/A3O1/9_Train/Ambient_WillaArchiTrainArgument");
		Ambient_SlagBickering = HAGIS.DialogLoad("Dialogs/A3O1/10_SlagSubwayStaion/Ambient_SlagBickering");
		Ambient_MoreSlagBickering = HAGIS.DialogLoad("Dialogs/A3O1/11_SlagHeapEntrance/Ambient_MoreSlagBickering");
		Ambient_EvenMoreSlagBicking = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Ambient_EvenMoreSlagBicking");
		Ambient_SlagBickingEnd = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Ambient_SlagBickingEnd");
		Dialog_RupertGivesUp = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Dialog_RupertGivesUp");
		Dialog_ArchiExilesRupert = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Dialog_ArchiExilesRupert");
		Dialog_TroublesComing = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Dialog_TroublesComing");
		Dialog_ArchiWheresMargot = HAGIS.DialogLoad("Dialogs/A3O1/13_SlagHeapEntrance/Dialog_ArchiWheresMargot");
		Dialog_Thanks = HAGIS.DialogLoad("Dialogs/A3O1/12_SlagHeapMain/Dialog_Thanks");
		S1 = MR.Inst.GetTileBlockDynamic("BA9_T1Slags_TileBlockDynamic");
		S2 = MR.Inst.GetTileBlockDynamic("B73_T1Slags_TileBlockDynamic");
		S3 = MR.Inst.GetTileBlockDynamic("512_T1Slags_TileBlockDynamic");
		ToPortEntrance = MR.Inst.GetTileActionSwapMap("9B3_T1Port2_HaraMainBay_TileActionSwapMap");
		FromPortHara = MR.Inst.GetTileActionSwapMap("561_T1Port2_HaraMainBay_TileActionSwapMap");
		PortEntranceToSubway = MR.Inst.GetTileActionSwapMap("508_T1Port1_HaraEntrance_TileActionSwapMap");
		TrainToAnywhere = MR.Inst.GetTileActionSwapMap("9C7_T1Subway_TrainInterior_TileActionSwapMap");
		TrainFromCam = MR.Inst.GetTileActionSwapMap("C73_T1Subway_TrainInterior_TileActionSwapMap");
		CambridgeToSubway = MR.Inst.GetTileActionSwapMap("E2D_T1Cambridge_TileActionSwapMap");
		CambridgeToGrickle = MR.Inst.GetTileActionSwapMap("181_T1Cambridge_TileActionSwapMap");
		PimGrickleToCambridge = MR.Inst.GetTileActionSwapMap("7B8_T1PimDickles_TileActionSwapMap");
		ToDistillery = MR.Inst.GetTileActionSwapMap("C29_T1PimDickles_TileActionSwapMap");
		FromGrickle = MR.Inst.GetTileActionSwapMap("0C3_T1AlembicDistillery_TileActionSwapMap");
		FromCambridge = MR.Inst.GetTileActionSwapMap("B98_T1Subway_Station_Cambridge_TileActionSwapMap");
		CambridgeStationToTrain = MR.Inst.GetTileActionSwapMap("872_T1Subway_Station_Cambridge_TileActionSwapMap");
		FromSlagSubway = MR.Inst.GetTileActionSwapMap("87D_T1Slags_Ent_TileActionSwapMap");
		SlagEntranceToSlagMain = MR.Inst.GetTileActionSwapMap("603_T1Slags_Ent_TileActionSwapMap");
		FromSlagEntrance = MR.Inst.GetTileActionSwapMap("70E_T1Slags_TileActionSwapMap");
		StartSlagEntraceCombat = MR.Inst.GetTileTrigger("328_T1Slags_Ent_TileTrigger");
		TT_OnLeave = MR.Inst.GetTileTrigger("6B9_T1Slags_TileTrigger");
		BarDialogTrigger = MR.Inst.GetTileActionInteraction("24D_T1PimDickles_TileActionInteraction");
		AmbroDistilleryDialogTile = MR.Inst.GetTileActionInteraction("169_T1PimDickles_TileActionInteraction");
		ArchiDistilleryDialogTile = MR.Inst.GetTileActionInteraction("5D3_T1PimDickles_TileActionInteraction");
		MissionEndActionTile = MR.Inst.GetTileActionInteraction("292_T1Subway_Station_TileActionInteraction");
		I_DoorToSlagEnt = MR.Inst.GetTileActionInteraction("F8D_T1Slags_TileActionInteraction");
		TrainToCam = MR.Inst.GetTileActionInteraction("52D_T1Subway_TrainInterior_TileActionInteraction");
		TrainToSlags = MR.Inst.GetTileActionInteraction("2E9_T1Subway_TrainInterior_TileActionInteraction");
		D_Bartender = MR.Inst.GetTileActionDialog("0E9_T1PimDickles_TileActionDialog");
		a3o1_AmbroDialog = GetComponentInChildren<Hagis_A3O1_AmbroDialog>();
		P_TUnitTarget_RupertsGun.gameObject.SetActive(value: false);
		ToPortEntrance.gameObject.SetActive(value: false);
		ToDistillery.gameObject.SetActive(value: false);
		Rupert.gameObject.SetActive(value: false);
		MissionEndActionTile.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: false);
		CambridgeStationToTrain.gameObject.SetActive(value: false);
		I_DoorToSlagEnt.gameObject.SetActive(value: false);
		FromCambridge.gameObject.SetActive(value: false);
		TrainFromCam.gameObject.SetActive(value: false);
		TT_OnLeave.gameObject.SetActive(value: false);
		TrainToAnywhere.gameObject.SetActive(value: false);
		CambridgeToSubway.gameObject.SetActive(value: false);
		TrainToCam.gameObject.SetActive(value: false);
		TrainToSlags.gameObject.SetActive(value: false);
		PlayMapAnimation(Distillery.Map, "CH_DistilleryCurtain", "Open");
		yield return null;
		yield return CutscenePlay("A3O1_Cutscene_WillaCralwsFromTheSea");
		SKIP_POINT("Skiped Opening sequence");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		ToPortEntrance.gameObject.SetActive(value: true);
		SKIP_POINT("Skiped Port fight");
		yield return HAGIS.DialogShow(Ambient_TimeToFindArchi);
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadToGrickle);
		MusicPlay("event:/music/tracks/basic/the rain continues 1");
		yield return MapWaitUntilVisible(PortHaraEntrance.Map);
		FromPortHara.gameObject.SetActive(value: false);
		HAGIS.DialogShow(Ambient_HowsArchiDoing);
		SKIP_POINT("Skip to Port entrance");
		yield return MapWaitUntilVisible(Train.Map);
		CutsceneBegin();
		UnitMoveToTarget(Willa, WillaArgueSpot);
		yield return CreateTimeCondition(0.2f);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return HAGIS.DialogShow(Dialog_DontShootArchi);
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return CreateTimeCondition(0.2f);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Cambridge_L0");
		yield return PlayMapAnimation(Train.Map, "MA_SubwayDoors", "Open");
		TrainToCam.gameObject.SetActive(value: true);
		CutsceneEnd();
		yield return CreateTriggerCondition(TrainToCam.OnTriggered);
		yield return UnitTeleportToMapViaEntranceTile(Willa, CambridgeToSubway);
		TrainToCam.gameObject.SetActive(value: false);
		Willa.LookInDirection(OctDir.Left);
		yield return MapGoto(Cambridge.Map);
		SKIP_POINT("Skip to Cambridge");
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(Ambient_WhereIsHe);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTalkToArchi);
		yield return MapWaitUntilVisible(PimGrickle.Map);
		MusicStop();
		PimGrickleToCambridge.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(BarDialogTrigger.OnTriggered);
		CutsceneBegin();
		Bartender.LookAt(Willa);
		HAGIS.DialogShow(Ambient_WillaCantGoBackThere);
		yield return CreateTimeCondition(0.7f);
		Willa.Hide(makeInactive: true);
		yield return CreateTimeCondition(1.4f);
		Bartender.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(1.3f);
		CutsceneEnd();
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromGrickle);
		yield return MapGoto(Distillery);
		SKIP_POINT("Skiped to the Distillery");
		MusicPlay("event:/music/tracks/basic/safety in numbers 1");
		Willa.gameObject.SetActive(value: true);
		FromGrickle.gameObject.SetActive(value: false);
		D_Bartender.gameObject.SetActive(value: false);
		ToDistillery.gameObject.SetActive(value: true);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Ambient_TufoLaserCutter);
		yield return HAGIS.DialogShow(Dialog_WillaGetTheirHelp);
		CutsceneEnd();
		UIObjectives.Inst.CompleteObjective(objTalkToArchi);
		yield return CreateTriggerCondition(ArchiDistilleryDialogTile.OnTriggered);
		MusicStop();
		CutsceneBegin();
		Ambro.LookAt(Willa);
		Archi.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_WillaConfrontingArchi1);
		yield return CreateTimeCondition(0.5f);
		Archi.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_WillaConfrontingArchi2);
		yield return CreateTimeCondition(0.5f);
		Archi.LookAt(Willa);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_WillaReasoningArchi1);
		yield return CreateTimeCondition(0.5f);
		Archi.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_WillaReasoningArchi2);
		yield return CreateTimeCondition(0.5f);
		Ambro.LookAt(Willa);
		Archi.LookAt(Willa);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_DisilleryDialogEnd);
		CutsceneEnd();
		SKIP_POINT("Skipped Distillery Dialog");
		Archi.SetTeamType(UnitTeam.Type.Player);
		Ambro.SetTeamType(UnitTeam.Type.Player);
		FromGrickle.gameObject.SetActive(value: true);
		ArchiDistilleryDialogTile.gameObject.SetActive(value: false);
		AmbroDistilleryDialogTile.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objSearchForRupert);
		MusicPlay("event:/music/tracks/basic/stealth old full");
		PimGrickleToCambridge.gameObject.SetActive(value: true);
		CambridgeToSubway.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(Cambridge.Map);
		HAGIS.DialogShow(Ambient_WillaArchiTrainArgument);
		yield return MapWaitUntilVisible(CambridgeSubwayStation.Map);
		SKIP_POINT("Skip to Cambridge subway fight");
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		CamShiner1.LookInDirection(OctDir.Up);
		CamShiner2.LookInDirection(OctDir.Up);
		yield return CreateTimeCondition(1f);
		yield return CreateAndCondition(UnitPlayAnimation(CamShiner1, "TransDIdleToCIdle"), UnitPlayAnimation(CamShiner2, "TransDIdleToCIdle"));
		CamShiner1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		CamShiner1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		CamShiner2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		CamShiner2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateAndCondition(UnitMoveToTarget(Willa, WillaCambridgeSubwayMovePoint, null, 5f), UnitMoveToTarget(Archi, ArchiCambridgeSubwayMovePoint, null, 5f), UnitMoveToTarget(Ambro, AmbroCambridgeSubwayMovePoint, null, 5f), UnitMoveToTarget(CamShiner1, T_CamShiner1, OctDir.UpLeft, 5f), UnitMoveToTarget(CamShiner2, T_CamShiner2, null, 5f));
		PlayMapAnimation(Train.Map, "MA_SubwayDoors", "Close");
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/shiner combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		TrainFromCam.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(Ambient_SlagBickering);
		yield return PlayMapAnimation(CambridgeSubwayStation.Map, "MA_SubwayTrain", "Arriving");
		CambridgeStationToTrain.gameObject.SetActive(value: true);
		SKIP_POINT("Skip Cambridge subway fight");
		TrainFromCam.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(Train.Map);
		HAGIS.ToggleShakeEnvironment(on: true);
		MusicPlay("event:/music/tracks/basic/willa underscore");
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToTarget(Willa, WillaArgueSpot), UnitMoveToTarget(Archi, ArchiArgueSpot), UnitMoveToTarget(Ambro, AmbroRockSpot));
		Willa.LookAt(Archi);
		Archi.LookAt(Willa);
		Ambro.LookAt(Willa);
		yield return HAGIS.DialogShow(Ambient_MoreSlagBickering);
		yield return CreateTimeCondition(0.2f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_Slags_L0");
		yield return null;
		yield return PlayMapAnimation(Train.Map, "MA_SubwayDoors", "Open");
		TrainToSlags.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Skipped Train argument");
		yield return CreateTriggerCondition(TrainToSlags.OnTriggered);
		yield return TeamMoveToMapViaEntranceTile(FromSlagSubway);
		yield return MapGoto(SlagEntrance.Map);
		MusicStop();
		FromSlagSubway.gameObject.SetActive(value: false);
		yield return null;
		SKIP_POINT("Skipped to Slag Entrace");
		yield return CreateTriggerCondition(StartSlagEntraceCombat._OnTriggered);
		HagisLog("Trigger Entered");
		CutsceneBegin();
		yield return Wait.While(SlagEntShinner1.LookAt(Willa));
		yield return Wait.While(SlagEntShinner2.LookAt(Willa));
		CutsceneEnd();
		UnitMoveToTarget(SlagEntShinner1, T_EnemyCover_Slags);
		MusicPlay("event:/music/tracks/combat/shiner combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/stealth old 1");
		SlagEntranceToSlagMain.gameObject.SetActive(value: false);
		SlagEntranceToSlagMain.gameObject.SetActive(value: true);
		SKIP_POINT("Skipped Slag Entrance combat");
		SlagMain.unitsMoveToDefaultPositions = true;
		yield return MapWaitUntilVisible(SlagMain.Map);
		Rupert.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultGunWalk");
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToTarget(Willa, WillaSlagMainCover), UnitMoveToTarget(Archi, ArchiSlagMainCover), UnitMoveToTarget(Ambro, AmbroSlagMainCover));
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/frenzy");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objSearchForRupert);
		FromSlagEntrance.gameObject.SetActive(value: false);
		SKIP_POINT("Skipped Slag Main combat");
		yield return CreateTimeCondition(0.3f);
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToTarget(Willa, WillaSlagMainCutscene), UnitMoveToTarget(Archi, ArchiSlagMainCutscene), UnitMoveToTarget(Ambro, AmbroSlagMainCutscene));
		Archi.LookAt(Willa);
		Willa.LookAt(Archi);
		Ambro.LookAt(Archi);
		S1.gameObject.SetActive(value: false);
		S2.gameObject.SetActive(value: false);
		S3.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Ambient_EvenMoreSlagBicking);
		yield return HAGIS.DialogShow(Ambient_SlagBickingEnd);
		Rupert.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.3f);
		Archi.LookAt(Rupert);
		yield return UnitMoveToTarget(Rupert, RupertSlagMainCutscene);
		Rupert.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultGunIdle");
		Rupert.LookAt(Archi);
		Willa.LookAt(Rupert.gameObject.transform, keepEyeOn: true);
		Archi.LookAt(Rupert.gameObject.transform, keepEyeOn: true);
		Ambro.LookAt(Rupert.gameObject.transform, keepEyeOn: true);
		yield return CreateTimeCondition(0.6f);
		yield return UnitPlayAnimation(Archi, "TransDIdleToCIdle");
		yield return UnitPlayAnimation(Archi, "TransCIdleToAIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		Archi.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_RupertGivesUp);
		yield return UnitPlayAnimation(Rupert, "CsTransGunIdleToHandsRaised");
		P_TUnitTarget_RupertsGun.gameObject.SetActive(value: true);
		yield return UnitPlayAnimation(Rupert, "CsDefaultHandsRaised");
		Rupert.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultHandsRaised");
		Rupert.UpdateIdleAnim();
		yield return CreateTimeCondition(0.4f);
		yield return HAGIS.DialogShow(Dialog_ArchiExilesRupert);
		yield return UnitPlayAnimation(Archi, "TransAIdleToCIdle");
		yield return UnitPlayAnimation(Archi, "CombatIdle");
		yield return UnitPlayAnimation(Archi, "TransCIdleToDIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Archi.UpdateIdleAnim();
		yield return UnitPlayAnimation(Rupert, "CsTransHandsRaisedToDIdle");
		yield return UnitPlayAnimation(Rupert, "DefaultIdle");
		Rupert.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Rupert.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Rupert.UpdateIdleAnim();
		yield return null;
		MusicStop();
		yield return UnitMoveToTarget(Rupert, RupertsLookBackSpot);
		Rupert.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_TroublesComing);
		FromSlagEntrance.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Rupert, FromSlagEntrance);
		Rupert.Hide(makeInactive: true);
		FromSlagEntrance.gameObject.SetActive(value: false);
		Willa.LookAt(Archi);
		Archi.LookAt(Willa);
		Ambro.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_Thanks);
		I_DoorToSlagEnt.gameObject.SetActive(value: true);
		TT_OnLeave.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Skipped Ruperts Defeat cutscene");
		MusicPlay("event:/music/tracks/basic/safety in numbers 2");
		S1.gameObject.SetActive(value: true);
		S2.gameObject.SetActive(value: true);
		S3.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(TT_OnLeave._OnTriggered);
		CutsceneBegin();
		yield return UnitMoveToTarget(Archi, RupertsLookBackSpot, OctDir.Down);
		Willa.LookAt(Archi);
		yield return HAGIS.DialogShow(Dialog_ArchiWheresMargot);
		CutsceneEnd();
	}
}
public class Hagis_A3O1_AmbroDialog : HAGIS
{
	private Unit Ambrosia;

	private Unit Willa;

	private TileActionInteraction AmbroInteraction;

	private DialogData Dialog_WillaReturns;

	private DialogData Dialog_WillaReturnsToAmbroAgain;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Ambrosia = GC.Inst.GetUnitWithId("5C1_T1AlembicDistillery_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("B96_T1Port2_HaraMainBay_UnitSpawn");
		AmbroInteraction = MR.Inst.GetTileActionInteraction("169_T1PimDickles_TileActionInteraction");
		Dialog_WillaReturns = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReturns");
		Dialog_WillaReturnsToAmbroAgain = HAGIS.DialogLoad("Dialogs/A3O1/7_Alembic_Distilery/Dialog_WillaReturnsToAmbroAgain");
		yield return null;
		yield return CreateTriggerCondition(AmbroInteraction.OnTriggered);
		CutsceneBegin();
		Ambrosia.LookAt(Willa);
		Willa.LookAt(Ambrosia);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_WillaReturns);
		CutsceneEnd();
		yield return CreateTriggerCondition(AmbroInteraction.OnTriggered);
		CutsceneBegin();
		Ambrosia.LookAt(Willa);
		CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_WillaReturnsToAmbroAgain);
		CutsceneEnd();
	}
}
public class HAGIS_A3O2 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Noot;

	private Unit Chris;

	private Unit Ambrosia;

	private Unit Molly;

	private Unit Fusel1;

	private Unit Fusel2;

	private Unit Fusel3;

	private Unit Fusel4;

	private Unit Fusel5;

	private Unit Fusel6;

	private Unit Fusel7;

	private Unit Mund;

	private Unit Fusel_VE1;

	private Unit Fusel_VE3;

	private Unit Fusel_VE4;

	private Unit Fusel_VE5;

	private Unit Fusel_VE6;

	private Unit Turret1;

	private Unit Turret2;

	private UnitTarget T_Ambrosia_AS;

	private UnitTarget T_Archi_AS;

	private UnitTarget T_Molly_AS;

	private UnitTarget T_MollyLooksAtDoor;

	private UnitTarget T_MollyGetsBackToWork;

	private UnitTarget T_ArchiToAmbro;

	private UnitTarget T_NootsStepsCloser;

	private UnitTarget T_ChrisLIstensIn;

	private UnitTarget T_NootWalksAway;

	private UnitTarget T_Leader_OnTrain;

	private UnitTarget T_Fusel3;

	private UnitTarget T_Fusel4;

	private UnitTarget T_Mund_KI;

	private UnitTarget T_Mund_VE;

	private UnitTarget T_Noot_VE;

	private UnitTarget T_playerChoice2;

	private UnitTarget T_playerChoice3;

	private UnitTarget T_playerChoice4;

	private UnitTarget T_playerChoice5;

	private UnitTarget T_NPC1ToMund;

	private UnitTarget T_NPC2ToMund;

	private TileActionSwapMap AndroidToTheFiles;

	private TileActionSwapMap TheFilesToAndroid;

	private TileActionSwapMap TheFilesToSubway;

	private TileActionSwapMap TrainToSubwayFiles;

	private TileActionSwapMap TrainToSubwayKaydock;

	private TileActionSwapMap KaydockExToInterior;

	private TileActionSwapMap KaydockToSubwayKaydock;

	private TileActionSwapMap InteriorToKaydockEx;

	private TileActionSwapMap InteriorToVaultEnt;

	private TileActionSwapMap VaultEntToInterior;

	private TileActionInteraction I_Vender;

	private TileActionInteraction I_ToMine;

	private TileActionInteraction InteractionHack1;

	private TileActionInteraction InteractionHack2;

	private TileActionDialog D_Molly;

	private TileActionDialog D_Noot;

	private TileActionDialog D_Mund;

	private TileActionDialog D_Archi;

	private DialogData Ambient_GiveYouAChoice;

	private DialogData Ambient_WeBuryrThis;

	private DialogData Ambient_Stop;

	private DialogData Ambient_BeenAWhile;

	private DialogData Ambient_Bored;

	private DialogData Ambient_Guys;

	private DialogData Ambient_IHateYou;

	private DialogData Ambient_Rhetoric;

	private DialogData Ambient_WillaAWord;

	private DialogData Ambient_YourBullshit;

	private DialogData Ambient_YourSuit;

	private DialogData Dialog_ChrisHey;

	private DialogData Dialog_HartmanAdvice;

	private DialogData Dialog_IDontLikeYouEither;

	private DialogData Dialog_ItsBeen;

	private DialogData Dialog_ItsBeen2;

	private DialogData Dialog_MartialLaw;

	private DialogData Dialog_MyAttention;

	private DialogData Dialog_NootImGlad;

	private DialogData Dialog_TellThem;

	private DialogData Dialog_TheMomentOfTruth;

	private DialogData Dialog_Wait;

	private DialogData Dialog_Willa;

	private DialogData Dialog_WillaNews;

	private DialogData Dialog_DontLikeYou;

	private DialogData Dialog_DontLikeYouCon;

	private DialogData Dialog_WeNeedToTalk;

	private string objTalkToNoot = "OBJECTIVES_A3O2_01";

	private string objKaydock = "OBJECTIVES_A3O2_02";

	private string objFollowMund = "OBJECTIVES_A3O2_03";

	private string objSurvive = "OBJECTIVES_A3O2_04";

	private string objTalkToMund = "OBJECTIVES_A3O2_05";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AndroidServicing = GetLogicUsingArtName("T1AndroidServicing");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot KaydockExterior = GetLogicUsingArtName("T1Kaydock_PlantExterior");
		LogicRoot KaydockInterior = GetLogicUsingArtName("T1Kaydock_ControlRoom");
		LogicRoot VaultEntrance = GetLogicUsingArtName("T1VaultEntrance_MundFight");
		Willa = GC.Inst.GetUnitWithId("135_T1AndroidServicing_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("2A4_T1AndroidServicing_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("8C5_T1AndroidServicing_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("D92_T1AndroidServicing_UnitSpawn");
		Molly = GC.Inst.GetUnitWithId("B74_T1AndroidServicing_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("9B7_T1AndroidServicing_UnitSpawn");
		Fusel1 = GC.Inst.GetUnitWithId("607_T1Kaydock_PlantExterior_UnitSpawn");
		Fusel2 = GC.Inst.GetUnitWithId("E95_T1Kaydock_PlantExterior_UnitSpawn");
		Fusel3 = GC.Inst.GetUnitWithId("580_T1Kaydock_PlantExterior_UnitSpawn");
		Fusel4 = GC.Inst.GetUnitWithId("828_T1Kaydock_PlantExterior_UnitSpawn");
		Fusel5 = GC.Inst.GetUnitWithId("A27_T1Kaydock_ControlRoom_UnitSpawn");
		Fusel6 = GC.Inst.GetUnitWithId("861_T1Kaydock_ControlRoom_UnitSpawn");
		Fusel7 = GC.Inst.GetUnitWithId("F6E_T1Kaydock_ControlRoom_UnitSpawn");
		Mund = GC.Inst.GetUnitWithId("CA7_T1Kaydock_ControlRoom_UnitSpawn");
		Fusel_VE1 = GC.Inst.GetUnitWithId("7FB_T1VaultEntrance_UnitSpawn");
		Fusel_VE3 = GC.Inst.GetUnitWithId("3A7_T1VaultEntrance_UnitSpawn");
		Fusel_VE4 = GC.Inst.GetUnitWithId("A42_T1VaultEntrance_UnitSpawn");
		Fusel_VE5 = GC.Inst.GetUnitWithId("CCC_T1VaultEntrance_UnitSpawn");
		Fusel_VE6 = GC.Inst.GetUnitWithId("019_T1VaultEntrance_UnitSpawn");
		Turret1 = GC.Inst.GetUnitWithId("A97_T1Kaydock_PlantExterior_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("3BA_T1Kaydock_PlantExterior_UnitSpawn");
		T_Ambrosia_AS = MR.Inst.GetUnitTarget("37C_T1AndroidServicing_UnitTarget");
		T_Archi_AS = MR.Inst.GetUnitTarget("6B5_T1AndroidServicing_UnitTarget");
		T_Molly_AS = MR.Inst.GetUnitTarget("335_T1AndroidServicing_UnitTarget");
		T_MollyGetsBackToWork = MR.Inst.GetUnitTarget("353_T1AndroidServicing_UnitTarget");
		T_ArchiToAmbro = MR.Inst.GetUnitTarget("F65_T1AndroidServicing_UnitTarget");
		T_MollyLooksAtDoor = MR.Inst.GetUnitTarget("ADE_T1AndroidServicing_UnitTarget");
		T_NootsStepsCloser = MR.Inst.GetUnitTarget("981_T1AndroidServicing_UnitTarget");
		T_ChrisLIstensIn = MR.Inst.GetUnitTarget("6FE_T1AndroidServicing_UnitTarget");
		T_NootWalksAway = MR.Inst.GetUnitTarget("487_T1AndroidServicing_UnitTarget");
		T_Leader_OnTrain = MR.Inst.GetUnitTarget("042_T1Subway_TrainInterior_UnitTarget");
		T_Fusel3 = MR.Inst.GetUnitTarget("0CD_T1Kaydock_PlantExterior_UnitTarget");
		T_Fusel4 = MR.Inst.GetUnitTarget("751_T1Kaydock_PlantExterior_UnitTarget");
		T_Mund_KI = MR.Inst.GetUnitTarget("4B0_T1Kaydock_ControlRoom_UnitTarget");
		T_Mund_VE = MR.Inst.GetUnitTarget("BDE_T1VaultEntrance_UnitTarget");
		T_Noot_VE = MR.Inst.GetUnitTarget("929_T1VaultEntrance_UnitTarget");
		T_NPC1ToMund = MR.Inst.GetUnitTarget("323_T1Kaydock_ControlRoom_UnitTarget");
		T_NPC2ToMund = MR.Inst.GetUnitTarget("095_T1Kaydock_ControlRoom_UnitTarget");
		T_playerChoice4 = MR.Inst.GetUnitTarget("04F_T1Kaydock_ControlRoom_UnitTarget");
		T_playerChoice5 = MR.Inst.GetUnitTarget("788_T1Kaydock_ControlRoom_UnitTarget");
		UnitTarget T_UnitCover1 = MR.Inst.GetUnitTarget("352_T1Kaydock_PlantExterior_UnitTarget");
		UnitTarget T_UnitCover2 = MR.Inst.GetUnitTarget("3E3_T1Kaydock_PlantExterior_UnitTarget");
		UnitTarget T_UnitCover3 = MR.Inst.GetUnitTarget("6BD_T1Kaydock_PlantExterior_UnitTarget");
		AndroidToTheFiles = MR.Inst.GetTileActionSwapMap("BE6_T1AndroidServicing_TileActionSwapMap");
		TheFilesToAndroid = MR.Inst.GetTileActionSwapMap("BE1_T1TheFiles_TileActionSwapMap");
		TheFilesToSubway = MR.Inst.GetTileActionSwapMap("B2C_T1TheFiles_TileActionSwapMap");
		TrainToSubwayFiles = MR.Inst.GetTileActionSwapMap("583_T1Subway_TrainInterior_TileActionSwapMap");
		TrainToSubwayKaydock = MR.Inst.GetTileActionSwapMap("716_T1Subway_TrainInterior_TileActionSwapMap");
		KaydockExToInterior = MR.Inst.GetTileActionSwapMap("283_T1Kaydock_PlantExterior_TileActionSwapMap");
		KaydockToSubwayKaydock = MR.Inst.GetTileActionSwapMap("34B_T1Kaydock_PlantExterior_TileActionSwapMap");
		InteriorToKaydockEx = MR.Inst.GetTileActionSwapMap("FD2_T1Kaydock_ControlRoom_TileActionSwapMap");
		InteriorToVaultEnt = MR.Inst.GetTileActionSwapMap("5D1_T1Kaydock_ControlRoom_TileActionSwapMap");
		VaultEntToInterior = MR.Inst.GetTileActionSwapMap("66B_T1VaultEntrance_TileActionSwapMap");
		I_ToMine = MR.Inst.GetTileActionInteraction("BE0_T1Kaydock_ControlRoom_TileActionInteraction");
		InteractionHack1 = MR.Inst.GetTileActionInteraction("AEA_T1Kaydock_PlantExterior_TileActionInteraction");
		D_Molly = MR.Inst.GetTileActionDialog("1F5_T1AndroidServicing_TileActionDialog");
		D_Noot = MR.Inst.GetTileActionDialog("91B_T1AndroidServicing_TileActionDialog");
		D_Archi = MR.Inst.GetTileActionDialog("E27_T1AndroidServicing_TileActionDialog");
		D_Mund = MR.Inst.GetTileActionDialog("C42_T1VaultEntrance_TileActionDialog");
		Ambient_GiveYouAChoice = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_GiveYouAChoice");
		Ambient_Stop = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_Stop");
		Ambient_BeenAWhile = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_BeenAWhile");
		Ambient_Bored = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_Bored");
		Ambient_Guys = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_Guys");
		Ambient_IHateYou = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_IHateYou");
		Ambient_Rhetoric = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_Rhetoric");
		Ambient_WillaAWord = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_WillaAWord");
		Ambient_YourBullshit = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_YourBullshit");
		Ambient_YourSuit = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_YourSuit");
		Dialog_ChrisHey = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_ChrisHey");
		Dialog_HartmanAdvice = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_HartmanAdvice");
		Dialog_IDontLikeYouEither = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_IDontLikeYouEither");
		Dialog_ItsBeen = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_ItsBeen");
		Dialog_ItsBeen2 = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_ItsBeen2");
		Dialog_MartialLaw = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_MartialLaw");
		Dialog_MyAttention = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_MyAttention");
		Dialog_NootImGlad = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_NootImGlad");
		Dialog_TellThem = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_TellThem");
		Dialog_TheMomentOfTruth = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_TheMomentOfTruth");
		Dialog_Wait = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_Wait");
		Dialog_Willa = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_Willa!");
		Dialog_WillaNews = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_WillaNews");
		Dialog_DontLikeYou = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_DontLikeYou");
		Dialog_DontLikeYouCon = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_DontLikeYouCon");
		Dialog_WeNeedToTalk = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_WeNeedToTalk");
		Ambient_WeBuryrThis = HAGIS.DialogLoad("Dialogs/A3O2/Ambient_WeBuryThis");
		HAGIS_A3O2_ChrisInteraction chrisInteractionHagis = GetComponentInChildren<HAGIS_A3O2_ChrisInteraction>();
		AndroidToTheFiles.gameObject.SetActive(value: false);
		TrainToSubwayKaydock.gameObject.SetActive(value: false);
		InteriorToVaultEnt.gameObject.SetActive(value: false);
		Fusel4.gameObject.SetActive(value: false);
		Fusel3.gameObject.SetActive(value: false);
		VaultEntToInterior.gameObject.SetActive(value: false);
		D_Archi.gameObject.SetActive(value: false);
		D_Noot.gameObject.SetActive(value: false);
		D_Molly.gameObject.SetActive(value: false);
		KaydockExToInterior.gameObject.SetActive(value: false);
		InteriorToKaydockEx.gameObject.SetActive(value: false);
		I_ToMine.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: false);
		PlayMapAnimation(KaydockInterior.Map, "MA_HiddenEntranceDoor_01", "Open");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		yield return null;
		MusicPlay("event:/music/tracks/diagetic/ruins radio");
		chrisInteractionHagis.PlayChrisTypingSFX();
		CutsceneBegin();
		UnitPlayAnimation(Molly, "DefaultTalk");
		yield return CreateTimeCondition(1f);
		Willa.Show();
		yield return UnitMoveToTarget(Willa, T_Archi_AS, OctDir.Down);
		Molly.LookInDirection(OctDir.UpRight);
		yield return CreateTimeCondition(0.5f);
		Archi.LookInDirection(OctDir.Up);
		yield return HAGIS.DialogShow(Dialog_Willa);
		yield return UnitMoveToTarget(Molly, T_Molly_AS, OctDir.UpRight);
		Willa.LookAt(Molly);
		yield return HAGIS.DialogShow(Dialog_ItsBeen);
		Molly.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(Dialog_ItsBeen2);
		Willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Ambient_Bored);
		yield return CreateTimeCondition(0.5f);
		Noot.LookInDirection(OctDir.Down);
		yield return HAGIS.DialogShow(Dialog_HartmanAdvice);
		D_Noot.gameObject.SetActive(value: true);
		D_Molly.gameObject.SetActive(value: true);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objTalkToNoot);
		if (!Dialog_ChrisHey.completed)
		{
			yield return Dialog_ChrisHey.OnComplete;
		}
		if (!Dialog_NootImGlad.completed)
		{
			yield return Dialog_NootImGlad.OnComplete;
		}
		UIObjectives.Inst.CompleteObjective(objTalkToNoot);
		HAGIS.DialogShow(Ambient_WillaAWord);
		D_Archi.gameObject.SetActive(value: true);
		Archi.LookInDirection(OctDir.Left);
		yield return D_Archi.OnDialogShow;
		CutsceneBegin();
		UnitPlayAnimation(Noot, "CsTransSitToDIdle");
		UnitPlayAnimation(Noot, "DefaultIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.UpdateIdleAnim();
		yield return CreateTimeCondition(2.5f);
		UnitMoveToTarget(Noot, T_NootsStepsCloser, OctDir.Down);
		chrisInteractionHagis.StopChrisTypingSFX();
		UnitPlayAnimation(Chris, "CsTransSitToDIdle");
		UnitPlayAnimation(Chris, "DefaultIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.UpdateIdleAnim();
		yield return CreateTimeCondition(2.5f);
		UnitMoveToTarget(Chris, T_ChrisLIstensIn, OctDir.DownLeft);
		UIObjectives.Inst.CompleteObjective(objTalkToNoot);
		D_Molly.gameObject.SetActive(value: false);
		D_Noot.gameObject.SetActive(value: false);
		D_Archi.gameObject.SetActive(value: false);
		Willa.LookInDirection(OctDir.Up);
		yield return HAGIS.DialogShow(Ambient_Guys);
		Archi.LookInDirection(OctDir.Up);
		UnitMoveToTarget(Ambrosia, T_Ambrosia_AS, OctDir.DownLeft);
		Ambrosia.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_TheMomentOfTruth);
		yield return UnitMoveToTarget(Noot, T_NootWalksAway);
		yield return CreateTimeCondition(1f);
		Willa.LookAt(Noot);
		yield return HAGIS.DialogShow(Dialog_DontLikeYou);
		Chris.LookAt(Willa);
		Noot.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_DontLikeYouCon);
		yield return CreateTimeCondition(2f);
		yield return HAGIS.DialogShow(Dialog_IDontLikeYouEither);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		GC.Inst.SetRPGLeader(Noot);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Willa.LookInDirection(OctDir.Up);
		UnitMoveToTarget(Molly, T_MollyGetsBackToWork, OctDir.Up);
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(Archi, T_ArchiToAmbro, OctDir.UpLeft);
		yield return null;
		Ambrosia.LookAt(Archi);
		UnitPlayAnimation(Archi, "DefaultTalk");
		CutsceneEnd();
		SKIP_POINT("Skip to End of opening cutscene");
		MusicPlay("event:/music/tracks/exploration/techtonics");
		AndroidToTheFiles.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objKaydock);
		yield return MapWaitUntilVisible(TheFiles.Map);
		yield return CreateTimeCondition(1.5f);
		PlayInterplay();
		yield return MapWaitUntilVisible(SubwayTrain.Map);
		TrainToSubwayFiles.gameObject.SetActive(value: false);
		UnitMoveToTarget(Noot, T_Leader_OnTrain, OctDir.Up);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(1f);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_KayDock_L0");
		PlayMapAnimation(SubwayTrain.Map, "MA_SubwayDoors", "Open");
		HAGIS.ToggleShakeEnvironment(on: false);
		TrainToSubwayKaydock.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(KaydockExterior.Map);
		yield return CreateAndCondition(UnitMoveToTarget(Willa, T_UnitCover1), UnitMoveToTarget(Chris, T_UnitCover2), UnitMoveToTarget(Noot, T_UnitCover3));
		MusicStop();
		SKIP_POINT("Skiped to fight at Kaydock");
		KaydockToSubwayKaydock.gameObject.SetActive(value: false);
		Turret1.IsMovementDisabled = true;
		Turret2.IsMovementDisabled = true;
		MusicPlay("event:/music/tracks/combat/underclock combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		CutsceneBegin();
		PlayMapAnimation(KaydockExterior.Map, "MA_KaydockPlantGate_01", "Open");
		SFXPlay("event:/sfx/script/act 1/a1s2/shutter rolls open");
		MusicPlay("event:/music/tracks/basic/mund intro");
		Turret1.SetTeamType(UnitTeam.Type.NPC);
		Turret2.SetTeamType(UnitTeam.Type.NPC);
		InteractionHack1.gameObject.SetActive(value: false);
		KaydockExToInterior.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Skiped fights at Kaydock exterior");
		yield return MapWaitUntilVisible(KaydockInterior.Map);
		CutsceneBegin();
		yield return Wait.While(Noot.LookInDirection(OctDir.Up));
		yield return HAGIS.DialogShow(Ambient_BeenAWhile);
		yield return UnitMoveToTarget(Mund, T_Mund_KI);
		UnitTeleportToMapViaEntranceTile(Mund, VaultEntToInterior, T_Mund_VE);
		CutsceneEnd();
		SKIP_POINT("Skipped to fight in Kaydock");
		MusicPlay("event:/music/tracks/combat/willas combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		I_ToMine.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/exploration/techtonics");
		yield return CreateTimeCondition(2f);
		UnitMoveToTarget(Willa, T_NPC1ToMund, OctDir.UpRight);
		UnitMoveToTarget(Chris, T_NPC2ToMund, OctDir.UpRight);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFollowMund);
		SKIP_POINT("Skipped fight in Kaydock ");
		yield return CreateTriggerCondition(I_ToMine.OnTriggered);
		CutsceneBegin();
		Noot.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_Wait);
		yield return null;
		yield return UnitTeleportToMapViaEntranceTile(Noot, VaultEntToInterior, T_Noot_VE);
		UnitTeleportToMapViaEntranceTile(Archi, InteriorToKaydockEx, T_playerChoice4);
		UnitTeleportToMapViaEntranceTile(Ambrosia, InteriorToKaydockEx, T_playerChoice5);
		MapGoto(VaultEntrance);
		yield return null;
		yield return MapWaitUntilMidTransition(VaultEntrance);
		Archi.LookInDirection(OctDir.DownRight);
		Ambrosia.LookInDirection(OctDir.DownRight);
		yield return MapWaitUntilVisible(VaultEntrance.Map);
		MusicStop();
		CutsceneEnd();
		Noot.IsMovementDisabled = true;
		SKIP_POINT("Skipped to easy kill cutscene");
		yield return HAGIS.DialogShow(Dialog_WeNeedToTalk);
		Mund.IsMovementDisabled = true;
		UIObjectives.Inst.CompleteAndSetMainObjective(objSurvive);
		MusicPlay("event:/music/tracks/combat/team wellness");
		CombatBegin(UnitTeam.Type.Player);
		Noot.IsMovementDisabled = false;
		yield return HAGIS.DialogShow(Ambient_IHateYou);
		yield return HAGIS.DialogShow(Ambient_YourSuit);
		yield return HAGIS.DialogShow(Ambient_YourBullshit);
		yield return TurnModeWaitForEnemyTurnStart();
		if (UIAmbientSubtitles.Inst.IsShown)
		{
			yield return UIAmbientSubtitles.Inst.OnHide;
		}
		yield return HAGIS.DialogShow(Ambient_Rhetoric);
		yield return TurnModeWaitForPlayerTurnStart();
		if (UIAmbientSubtitles.Inst.IsShown)
		{
			yield return UIAmbientSubtitles.Inst.OnHide;
		}
		yield return HAGIS.DialogShow(Ambient_GiveYouAChoice);
		yield return TurnModeWaitForEnemyTurnStart();
		if (UIAmbientSubtitles.Inst.IsShown)
		{
			yield return UIAmbientSubtitles.Inst.OnHide;
		}
		yield return HAGIS.DialogShow(Ambient_WeBuryrThis);
		yield return TurnModeWaitForPlayerTurnStart();
		if (UIAmbientSubtitles.Inst.IsShown)
		{
			yield return UIAmbientSubtitles.Inst.OnHide;
		}
		HAGIS.DialogShow(Ambient_Stop);
		yield return EndTurnMode();
		yield return CreateTimeCondition(1f);
		yield return GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).MoveTeamToDefaultPositions();
		MusicStop();
		yield return null;
		SKIP_POINT("Skipped to end of fight with Mund");
		UIObjectives.Inst.CompleteAndSetMainObjective(objTalkToMund);
		yield return CreateTriggerCondition(Dialog_MyAttention.OnComplete);
		CutsceneBegin();
		UIObjectives.Inst.CompleteObjective(objTalkToMund);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		yield return MapGoto(KaydockInterior.Map);
		SKIP_POINT("Skipped moving maps");
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		yield return UnitTeleportToMapViaEntranceTile(Noot, InteriorToVaultEnt);
		Willa.LookInDirection(OctDir.UpRight);
		Ambrosia.LookInDirection(OctDir.UpRight);
		Archi.LookInDirection(OctDir.UpRight);
		Chris.LookInDirection(OctDir.UpRight);
		yield return UnitMoveToUnit(Noot, Ambrosia);
		yield return UnitTeleportToMapViaEntranceTile(Mund, InteriorToVaultEnt);
		yield return UnitMoveToUnit(Mund, Willa);
		Mund.LookAt(Willa);
		Willa.LookAt(Mund);
		Ambrosia.LookAt(Willa);
		Archi.LookAt(Willa);
		Chris.LookAt(Mund);
		Noot.LookAt(Mund);
		yield return HAGIS.DialogShow(Dialog_MartialLaw);
		CutsceneEnd();
		yield return null;
	}
}
public class HAGIS_A3O2_ChrisInteraction : HAGIS
{
	private FMOD.Studio.EventInstance chrisTypingSFX;

	private Unit Willa;

	private Unit Chris;

	private TileActionInteraction D_Chris;

	private DialogData Dialog_ChrisHey;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Willa = GC.Inst.GetUnitWithId("135_T1AndroidServicing_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("D92_T1AndroidServicing_UnitSpawn");
		D_Chris = MR.Inst.GetTileActionInteraction("8F0_T1AndroidServicing_TileActionInteraction");
		Dialog_ChrisHey = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_ChrisHey");
		yield return null;
		yield return CreateTriggerCondition(D_Chris.OnTriggered);
		StopChrisTypingSFX();
		yield return UnitPlayAnimation(Chris, "CsTransSitToLookUp");
		yield return UnitPlayAnimation(Chris, "CsDefaultLookUp");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultLookUp");
		Chris.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_ChrisHey);
		yield return UnitPlayAnimation(Chris, "CsTransLookUpToSit");
		PlayChrisTypingSFX();
		yield return UnitPlayAnimation(Chris, "CsDefaultSit");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		Chris.UpdateIdleAnim();
		D_Chris.gameObject.SetActive(value: false);
	}

	public void PlayChrisTypingSFX()
	{
		StopChrisTypingSFX();
		chrisTypingSFX = AC.Inst.PlayOneShot2D("event:/sfx/script/act 1/a1o8/typing");
	}

	public void StopChrisTypingSFX()
	{
		if (chrisTypingSFX.isValid())
		{
			chrisTypingSFX.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public class HAGIS_A3O2_NootInteraction : HAGIS
{
	private TileActionDialog D_Noot;

	private DialogData Dialog_NootImGlad;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		D_Noot = MR.Inst.GetTileActionDialog("91B_T1AndroidServicing_TileActionDialog");
		Dialog_NootImGlad = HAGIS.DialogLoad("Dialogs/A3O2/Dialog_NootImGlad");
		yield return null;
		yield return CreateTriggerCondition(Dialog_NootImGlad.OnComplete);
		D_Noot.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A3O2_Turret1 : HAGIS
{
	private Unit Chris;

	private Unit Turret1;

	private Unit Turret2;

	private TileActionInteraction InteractionHack1;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Chris = GC.Inst.GetUnitWithId("D92_T1AndroidServicing_UnitSpawn");
		Turret1 = GC.Inst.GetUnitWithId("A97_T1Kaydock_PlantExterior_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("3BA_T1Kaydock_PlantExterior_UnitSpawn");
		InteractionHack1 = MR.Inst.GetTileActionInteraction("AEA_T1Kaydock_PlantExterior_TileActionInteraction");
		yield return null;
		yield return CreateTriggerCondition(InteractionHack1.OnTriggered);
		Turret1.SetTeamType(UnitTeam.Type.Player);
		Turret2.SetTeamType(UnitTeam.Type.Player);
		InteractionHack1.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A3O2_Turret2 : HAGIS
{
	private Unit Chris;

	private Unit Turret2;

	private TileActionInteraction InteractionHack2;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Chris = GC.Inst.GetUnitWithId("D92_T1AndroidServicing_UnitSpawn");
		Turret2 = GC.Inst.GetUnitWithId("3BA_T1Kaydock_PlantExterior_UnitSpawn");
		InteractionHack2 = MR.Inst.GetTileActionInteraction("052_T1Kaydock_PlantExterior_TileActionInteraction");
		yield return null;
		yield return CreateTriggerCondition(InteractionHack2.OnTriggered);
		Turret2.SetTeamType(UnitTeam.Type.Player);
		InteractionHack2.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return UnitPlayAnimation(Chris, "CsTransCIdleToCCrouch");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatCrouch");
		Chris.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Chris, "CsTransCCrouchToCIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		CutsceneEnd();
		yield return CreateTriggerCondition(Turret2.OnDeathComplete);
		Turret2.SetTeamType(UnitTeam.Type.NPC);
		Turret2.gameObject.SetActive(value: false);
	}
}
public class HAGIS_A3O3 : HAGIS
{
	private Unit Margot;

	private Unit Archi;

	private Unit Willa;

	private Unit Noot;

	private Unit Ambrosia;

	private Unit Chris;

	private Unit Bugsy;

	private Unit Marybelle;

	private Unit Theo;

	private Unit Tucker_bar1;

	private Unit Tucker_bar2;

	private Unit Tucker_bar3;

	private Unit Tucker_bar4;

	private Unit Tucker_bar5;

	private Unit Underclock_HQ1;

	private Unit Underclock_HQ2;

	private Unit CarParkGoon1;

	private Unit CarParkGoon2;

	private UnitTarget T_BugsyCover;

	private UnitTarget T_BugsyExit;

	private UnitTarget T_BugsyGiveUp;

	private UnitTarget T_MarybelleExit;

	private UnitTarget T_MarybelleLeaves;

	private UnitTarget T_MarybelleLeaves2;

	private UnitTarget T_MarybelleReturn;

	private UnitTarget T_TeamArrive1;

	private UnitTarget T_TeamArrive2;

	private UnitTarget T_TeamArrive3;

	private UnitTarget T_TeamCover1;

	private UnitTarget T_TeamCover2;

	private UnitTarget T_TeamCover3;

	private UnitTarget T_ArchiAfterFight;

	private UnitTarget T_BugsyApproachesMargot;

	private UnitTarget T_MargotAfterFight;

	private UnitTarget T_MargotCover;

	private UnitTarget T_ArchiCover;

	private UnitTarget T_MargotEntry;

	private UnitTarget T_ArchiEntry;

	private UnitTarget T_WillaEntry;

	private UnitTarget T_Moosehead;

	private UnitTarget T_TuckerPosition1;

	private UnitTarget T_TuckerPosition2;

	private UnitTarget T_WillaAfterfight;

	private UnitTarget T_TheoExit;

	private UnitTarget T_BugsyLanding;

	private UnitTarget P_DefaultUnitPos1;

	private UnitTarget P_DefaultUnitPos2;

	private UnitTarget P_DefaultUnitPos3;

	private UnitTarget T_Marybelle_CT;

	private UnitTarget T_Marybelle_CT2;

	private UnitTarget T_Exit;

	private UnitTarget Target_Statue1;

	private UnitTarget Target_Statue2;

	private UnitTarget Target_Statue3;

	private UnitTarget Target_Statue4;

	private UnitTarget T_MargotCoverPark;

	private UnitTarget T_GoonTalk1Postion;

	private UnitTarget T_GoonTalk2Postion;

	private UnitTarget T_Goon2SpotsMargot;

	private UnitTarget T_Goon1Cover;

	private UnitTarget T_Goon2Cover;

	private TileActionSwapMap S_SkywayToCentre1;

	private TileActionSwapMap S_CentreToMall;

	private TileActionSwapMap S_CentreToSkyway1;

	private TileActionSwapMap S_CentreToSkyway2;

	private TileActionSwapMap S_MallToCarpark;

	private TileActionSwapMap S_MallToCentre;

	private TileActionSwapMap S_CarparkToBar;

	private TileActionSwapMap S_CarparkToMall;

	private TileActionSwapMap S_BarToCarpark;

	private TileActionSwapMap S_BarToSkyway;

	private TileActionSwapMap S_SkywayToBar1;

	private TileActionSwapMap S_SkywayToHQ1;

	private TileActionSwapMap S_HQToRooftop;

	private TileActionSwapMap S_HQToSkyway;

	private TileActionSwapMap S_RoofToClocktower;

	private TileActionSwapMap S_RoofToHQ;

	private TileActionSwapMap S_ClocktowerToCelestia;

	private TileActionSwapMap S_ClocktowerToRoof;

	private TileActionSwapMap S_CelestiaToClocktower;

	private TileActionSwapMap S_CelestiaToRelayTower;

	private TileActionSwapMap S_RelaytowerToCelestia;

	private TileActionSwapMap S_RelayTowerToGarden;

	private TileActionSwapMap S_GardenToRelaytower;

	private TileActionInteraction I_CarparkExitTrigger;

	private TileActionInteraction I_ToCelestia;

	private TileActionInteraction I_Pod;

	private TileActionDialog D_genericDialog;

	private TileTrigger TT_TenorCityStealthExit;

	private TileTrigger TT_MallStealthExit;

	private TileTrigger TT_CarparkStealthExit;

	private DialogData Ambient_ArchiArrives;

	private DialogData Ambient_BugsyMad;

	private DialogData Ambient_BugsyMoose;

	private DialogData Ambient_CelestiaReminder;

	private DialogData Ambient_FloorDroids;

	private DialogData Ambient_GoonChat2;

	private DialogData Ambient_HaveItYourWay;

	private DialogData Ambient_MargotNeedsHelp1;

	private DialogData Ambient_MargotNeedsHelp2;

	private DialogData Ambient_MaryBack;

	private DialogData Ambient_MaryExcusesHerself;

	private DialogData Ambient_MaryHelps;

	private DialogData Ambient_MaryLastWord;

	private DialogData Ambient_TheoKillsBugsy;

	private DialogData Ambient_TheoWhistling;

	private DialogData Ambient_WillaPod;

	private DialogData Ambiant_WillaConcerned;

	private DialogData ambient_ShowHimHowItFeels;

	private DialogData ambient_NoTheo;

	private DialogData ambient_TuckerLookOut;

	private DialogData Ambient_MargotWhew;

	private DialogData Dialog_AmbrosiaStatue;

	private DialogData Dialog_BugsyAtClocktower;

	private DialogData Dialog_BugsyConcedes;

	private DialogData Dialog_BugsyFlirts;

	private DialogData Dialog_BugsyRejectsHelp;

	private DialogData Dialog_BugsyThreatensMary;

	private DialogData Dialog_MargotReunion;

	private DialogData Dialog_MargotsEncore;

	private DialogData Dialog_MargotsHistory;

	private DialogData Dialog_WhatHappenedMargot;

	private DialogData Dialog_MarybelleEscape;

	private DialogData Dialog_MargotInsultsBugsy;

	private DialogData Dialog_MaryPushesBugsy;

	private DialogData Dialog_MaryStormsOff;

	private DialogData Dialog_TuckersFinished;

	private DialogData Dialog_WillaAsksForHelp;

	private DialogData Ambient_BugsyStruggling;

	private string objTenorBar = "OBJECTIVES_A3O3_01";

	private string objHoldOut = "OBJECTIVES_A3O3_02";

	private string objTakeTheSkyway = "OBJECTIVES_A3O3_03";

	private string objDefeatBugsy = "OBJECTIVES_A3O3_04";

	private string objTakeMary = "OBJECTIVES_A3O3_05";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot TenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot ArenaCarPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		LogicRoot KaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot HQExterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot HQRooftop = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot Clocktower = GetLogicUsingArtName("T2ClockTower");
		LogicRoot CelestiaCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot CelestiaRelayTower = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot CelestiaGardens = GetLogicUsingArtName("T3BotanicalGardens");
		Margot = GC.Inst.GetUnitWithId("305_T2Skyway_UnitSpawn");
		Willa = GC.Inst.GetUnitWithId("8DC_T2TheKaydockArenaBar_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("1BD_T2TheKaydockArenaBar_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("A6F_T3CelestiaTownCentre_UnitSpawn");
		Bugsy = GC.Inst.GetUnitWithId("DEB_T2TheKaydockArenaBar_UnitSpawn");
		Marybelle = GC.Inst.GetUnitWithId("4C1_T2TheKaydockArenaBar_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("F77_T2UnderclocksPoliceStation_Exterior_UnitSpawn");
		Tucker_bar1 = GC.Inst.GetUnitWithId("72A_T2TheKaydockArenaBar_UnitSpawn");
		Tucker_bar3 = GC.Inst.GetUnitWithId("9CE_T2TheKaydockArenaBar_UnitSpawn");
		Tucker_bar4 = GC.Inst.GetUnitWithId("5BB_T2TheKaydockArenaBar_UnitSpawn");
		Tucker_bar5 = GC.Inst.GetUnitWithId("512_T2TheKaydockArenaBar_UnitSpawn");
		CarParkGoon1 = GC.Inst.GetUnitWithId("4D6_T2TheKaydockArenaCarPark_UnitSpawn");
		CarParkGoon2 = GC.Inst.GetUnitWithId("76F_T2TheKaydockArenaCarPark_UnitSpawn");
		T_BugsyCover = MR.Inst.GetUnitTarget("C9F_T2ClockTower_UnitTarget");
		T_BugsyExit = MR.Inst.GetUnitTarget("C52_T2ClockTower_UnitTarget");
		T_BugsyGiveUp = MR.Inst.GetUnitTarget("8BB_T2ClockTower_UnitTarget");
		T_MarybelleExit = MR.Inst.GetUnitTarget("9AD_T2ClockTower_UnitTarget");
		T_MarybelleLeaves = MR.Inst.GetUnitTarget("B80_T2ClockTower_UnitTarget");
		T_MarybelleLeaves2 = MR.Inst.GetUnitTarget("EB4_T2ClockTower_UnitTarget");
		T_MarybelleReturn = MR.Inst.GetUnitTarget("844_T2ClockTower_UnitTarget");
		T_TeamArrive1 = MR.Inst.GetUnitTarget("232_T2ClockTower_UnitTarget");
		T_TeamArrive2 = MR.Inst.GetUnitTarget("CA2_T2ClockTower_UnitTarget");
		T_TeamArrive3 = MR.Inst.GetUnitTarget("E28_T2ClockTower_UnitTarget");
		T_TeamCover1 = MR.Inst.GetUnitTarget("368_T2ClockTower_UnitTarget");
		T_TeamCover2 = MR.Inst.GetUnitTarget("78B_T2ClockTower_UnitTarget");
		T_TeamCover3 = MR.Inst.GetUnitTarget("D1A_T2ClockTower_UnitTarget");
		T_ArchiAfterFight = MR.Inst.GetUnitTarget("D0C_T2TheKaydockArenaBar_UnitTarget");
		T_BugsyApproachesMargot = MR.Inst.GetUnitTarget("F49_T2TheKaydockArenaBar_UnitTarget");
		T_MargotAfterFight = MR.Inst.GetUnitTarget("FD3_T2TheKaydockArenaBar_UnitTarget");
		T_MargotCover = MR.Inst.GetUnitTarget("2C9_T2TheKaydockArenaBar_UnitTarget");
		T_MargotEntry = MR.Inst.GetUnitTarget("869_T2TheKaydockArenaBar_UnitTarget");
		T_Moosehead = MR.Inst.GetUnitTarget("0B9_T2TheKaydockArenaBar_UnitTarget");
		T_TuckerPosition1 = MR.Inst.GetUnitTarget("923_T2TheKaydockArenaBar_UnitTarget");
		T_TuckerPosition2 = MR.Inst.GetUnitTarget("41B_T2TheKaydockArenaBar_UnitTarget");
		T_WillaAfterfight = MR.Inst.GetUnitTarget("D76_T2TheKaydockArenaBar_UnitTarget");
		T_BugsyLanding = MR.Inst.GetUnitTarget("25D_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		T_TheoExit = MR.Inst.GetUnitTarget("370_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		P_DefaultUnitPos1 = MR.Inst.GetUnitTarget("A8A_T2Skyway_UnitTarget");
		P_DefaultUnitPos2 = MR.Inst.GetUnitTarget("D35_T2Skyway_UnitTarget");
		P_DefaultUnitPos3 = MR.Inst.GetUnitTarget("B31_T2Skyway_UnitTarget");
		T_Marybelle_CT = MR.Inst.GetUnitTarget("BF6_T3CelestiaTownCentre_UnitTarget");
		T_Marybelle_CT2 = MR.Inst.GetUnitTarget("F15_T3CelestiaTownCentre_UnitTarget");
		T_Exit = MR.Inst.GetUnitTarget("FB1_T3BotanicalGardens_UnitTarget");
		T_ArchiEntry = MR.Inst.GetUnitTarget("ED2_T2TheKaydockArenaBar_UnitTarget");
		T_WillaEntry = MR.Inst.GetUnitTarget("108_T2TheKaydockArenaBar_UnitTarget");
		T_MargotCoverPark = MR.Inst.GetUnitTarget("7A2_T2TheKaydockArenaCarPark_UnitTarget");
		T_GoonTalk1Postion = MR.Inst.GetUnitTarget("74A_T2TheKaydockArenaCarPark_UnitTarget");
		T_GoonTalk2Postion = MR.Inst.GetUnitTarget("5C0_T2TheKaydockArenaCarPark_UnitTarget");
		T_Goon2SpotsMargot = MR.Inst.GetUnitTarget("0AE_T2TheKaydockArenaCarPark_UnitTarget");
		T_Goon1Cover = MR.Inst.GetUnitTarget("D50_T2TheKaydockArenaCarPark_UnitTarget");
		T_Goon2Cover = MR.Inst.GetUnitTarget("C1C_T2TheKaydockArenaCarPark_UnitTarget");
		Target_Statue1 = MR.Inst.GetUnitTarget("B8E_T2ClockTower_UnitTarget");
		Target_Statue2 = MR.Inst.GetUnitTarget("768_T2ClockTower_UnitTarget");
		Target_Statue3 = MR.Inst.GetUnitTarget("009_T2ClockTower_UnitTarget");
		Target_Statue4 = MR.Inst.GetUnitTarget("1CB_T2ClockTower_UnitTarget");
		UnitTarget sfx_elevator_ping = MR.Inst.GetUnitTarget("3DD_T2TheKaydockArenaBar_UnitTarget");
		S_SkywayToCentre1 = MR.Inst.GetTileActionSwapMap("72B_T2Skyway_TileActionSwapMap");
		S_CentreToSkyway1 = MR.Inst.GetTileActionSwapMap("99E_T2TenorCityCentre_TileActionSwapMap");
		S_CentreToSkyway2 = MR.Inst.GetTileActionSwapMap("A72_T2TenorCity_Centre_TileActionSwapMap");
		S_CarparkToBar = MR.Inst.GetTileActionSwapMap("007_T2TheKaydockArenaCarPark_TileActionSwapMap");
		S_CarparkToMall = MR.Inst.GetTileActionSwapMap("202_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		S_BarToCarpark = MR.Inst.GetTileActionSwapMap("D41_T2TheKaydockArenaBar_TileActionSwapMap");
		S_BarToSkyway = MR.Inst.GetTileActionSwapMap("F6C_T2TheKaydockArenaBar_TileActionSwapMap");
		S_SkywayToBar1 = MR.Inst.GetTileActionSwapMap("5FD_T2Skyway_TileActionSwapMap");
		S_SkywayToHQ1 = MR.Inst.GetTileActionSwapMap("67D_T2Skyway_TileActionSwapMap");
		S_HQToRooftop = MR.Inst.GetTileActionSwapMap("EEB_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		S_HQToSkyway = MR.Inst.GetTileActionSwapMap("263_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		S_RoofToClocktower = MR.Inst.GetTileActionSwapMap("98C_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		S_RoofToHQ = MR.Inst.GetTileActionSwapMap("207_T2UnderclocksPoliceStation_Roof_TileActionSwapMap");
		S_ClocktowerToCelestia = MR.Inst.GetTileActionSwapMap("09A_T2ClockTower_TileActionSwapMap");
		S_ClocktowerToRoof = MR.Inst.GetTileActionSwapMap("4F3_T2ClockTower_TileActionSwapMap");
		S_CelestiaToClocktower = MR.Inst.GetTileActionSwapMap("FAC_T3CelestiaTownCentre_TileActionSwapMap");
		S_CelestiaToRelayTower = MR.Inst.GetTileActionSwapMap("229_T3CelestiaTownCentre_TileActionSwapMap");
		S_RelaytowerToCelestia = MR.Inst.GetTileActionSwapMap("55C_T3RelayTowerExterior_TileActionSwapMap");
		S_RelayTowerToGarden = MR.Inst.GetTileActionSwapMap("F30_T3RelayTowerExterior_TileActionSwapMap");
		S_GardenToRelaytower = MR.Inst.GetTileActionSwapMap("421_T3BotanicalGardens_TileActionSwapMap");
		I_CarparkExitTrigger = MR.Inst.GetTileActionInteraction("2FE_T2TheKaydockArenaCarPark_TileActionInteraction");
		I_ToCelestia = MR.Inst.GetTileActionInteraction("BAB_T2ClockTower_TileActionInteraction");
		I_Pod = MR.Inst.GetTileActionInteraction("2D5_T3CelestiaTownCentre_TileActionInteraction");
		Ambient_ArchiArrives = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_ArchiArrives");
		Ambient_BugsyMad = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_BugsyMad");
		Ambient_BugsyMoose = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_BugsyMoose");
		Ambient_CelestiaReminder = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_CelestiaReminder");
		Ambient_FloorDroids = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_FloorDroids");
		Ambient_GoonChat2 = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_GoonChat2");
		Ambient_HaveItYourWay = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_HaveItYourWay");
		Ambient_MargotNeedsHelp1 = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MargotNeedsHelp1");
		Ambient_MargotNeedsHelp2 = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MargotNeedsHelp2");
		Ambient_MaryBack = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MaryBack");
		Ambient_MaryExcusesHerself = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MaryExcusesHerself");
		Ambient_MaryHelps = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MaryHelps");
		Ambient_MaryLastWord = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MaryLastWord");
		Ambient_TheoKillsBugsy = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_TheoKillsBugsy");
		Ambient_TheoWhistling = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_TheoWhistling");
		Ambient_WillaPod = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_WillaPod");
		Ambiant_WillaConcerned = HAGIS.DialogLoad("Dialogs/A3O3/Ambiant_WillaConcerned");
		ambient_ShowHimHowItFeels = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_ShowHimHowItFeels");
		ambient_NoTheo = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_NoTheo");
		ambient_TuckerLookOut = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_TuckerLookOut");
		Ambient_MargotWhew = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_MargotWhew");
		Dialog_AmbrosiaStatue = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_AmbrosiaStatue");
		Dialog_BugsyAtClocktower = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_BugsyAtClocktower");
		Dialog_BugsyConcedes = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_BugsyConcedes");
		Dialog_BugsyFlirts = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_BugsyFlirts");
		Dialog_BugsyRejectsHelp = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_BugsyRejectsHelp");
		Dialog_BugsyThreatensMary = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_BugsyThreatensMary");
		Ambient_BugsyStruggling = HAGIS.DialogLoad("Dialogs/A3O3/Ambient_BugsyStruggling");
		Dialog_MargotReunion = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MargotReunion");
		Dialog_MargotsEncore = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MargotsEncore");
		Dialog_MargotsHistory = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MargotsHistory");
		Dialog_WhatHappenedMargot = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_WhatHappenedMargot");
		Dialog_MarybelleEscape = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MarybelleEscape");
		Dialog_MargotInsultsBugsy = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MargotInsultsBugsy");
		Dialog_MaryPushesBugsy = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MaryPushesBugsy");
		Dialog_MaryStormsOff = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_MaryStormsOff");
		Dialog_TuckersFinished = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_TuckersFinished");
		Dialog_WillaAsksForHelp = HAGIS.DialogLoad("Dialogs/A3O3/Dialog_WillaAsksForHelp");
		string ClocktowerStatue = "MA_Statue";
		Ability_MaxHP BugsyHP = Bugsy.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		BugsyHP.SetHPMod(18);
		HagletTrigger myAI = new HagletTrigger();
		yield return null;
		Tucker_bar5.gameObject.SetActive(value: false);
		Tucker_bar4.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		S_SkywayToBar1.gameObject.SetActive(value: false);
		S_CentreToSkyway1.gameObject.SetActive(value: false);
		S_CentreToSkyway2.gameObject.SetActive(value: false);
		S_SkywayToCentre1.gameObject.SetActive(value: false);
		S_SkywayToHQ1.gameObject.SetActive(value: false);
		S_ClocktowerToCelestia.gameObject.SetActive(value: false);
		S_ClocktowerToRoof.gameObject.SetActive(value: false);
		I_ToCelestia.gameObject.SetActive(value: false);
		S_RelaytowerToCelestia.gameObject.SetActive(value: false);
		Theo.gameObject.SetActive(value: false);
		S_RoofToHQ.gameObject.SetActive(value: false);
		S_CarparkToBar.gameObject.SetActive(value: false);
		S_BarToSkyway.gameObject.SetActive(value: false);
		CarParkGoon1.gameObject.SetActive(value: false);
		CarParkGoon2.gameObject.SetActive(value: false);
		I_CarparkExitTrigger.gameObject.SetActive(value: false);
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultMartini");
		S_CarparkToMall.gameObject.SetActive(value: false);
		Ability_Restore CarParkGoon1Restore = CarParkGoon1.abilities.AbilityGetByType<Ability_Restore>(CarParkGoon1);
		if (CarParkGoon1Restore != null)
		{
			CarParkGoon1Restore.Enabled = false;
		}
		MusicPlay("event:/music/tracks/diagetic/ruins skyway");
		HAGIS.ToggleShakeEnvironment(on: true);
		CutsceneBegin();
		yield return UnitPlayAnimation(Margot, "CsDefaultMartiniDrink");
		UnitPlayAnimation(Margot, "CsDefaultMartini", loop: true);
		yield return HAGIS.DialogShow(Dialog_MargotReunion);
		yield return UnitPlayAnimation(Margot, "CsDefaultMartiniDrink");
		UnitPlayAnimation(Margot, "CsDefaultMartini", loop: true);
		yield return HAGIS.DialogShow(Dialog_MargotsEncore);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTenorBar);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_TenorCityCentre_L0");
		yield return UnitPlayAnimation(Margot, "CsDefaultMartiniDrink");
		UnitPlayAnimation(Margot, "CsDefaultMartini", loop: true);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_HaveItYourWay);
		yield return UnitPlayAnimation(Margot, "CsTransMartiniToDIdlePutAway");
		yield return UnitPlayAnimation(Margot, "DefaultIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToMapViaExitTile(Margot, S_SkywayToCentre1);
		yield return MapGoto(TenorCityCentre);
		MusicPlay("event:/music/tracks/basic/the rain continues 1");
		CutsceneEnd();
		SKIP_POINT("Skipped Skyway cutscene");
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objTenorBar);
		yield return null;
		yield return MapWaitUntilVisible(ArenaCarPark.Map);
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "CombatWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		MusicStop();
		SKIP_POINT("Skipped to Carpark combat");
		yield return null;
		CutsceneBegin();
		CarParkGoon1.gameObject.SetActive(value: true);
		CarParkGoon2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		UnitMoveToTarget(Margot, T_MargotCoverPark, OctDir.DownRight, 4f);
		HAGIS.DialogShow(Ambient_GoonChat2);
		UnitMoveToTarget(CarParkGoon1, T_GoonTalk1Postion, OctDir.DownRight);
		yield return UnitMoveToTarget(CarParkGoon2, T_GoonTalk2Postion, OctDir.UpLeft);
		yield return UnitPlayAnimation(Margot, "TransCIdleToCCrouch");
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(Margot, "CombatCrouch");
		yield return HAGIS.HACK_WaitIfDialogIsNotComplete(Ambient_GoonChat2);
		CarParkGoon2.unitModel.Play("DefaultAlert");
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(CarParkGoon2, T_Goon2SpotsMargot);
		CarParkGoon2.LookAt(Margot);
		yield return CreateTimeCondition(0.5f);
		HAGIS.DialogShow(ambient_TuckerLookOut);
		CarParkGoon2.unitModel.Play("TransDIdleToCIdle");
		yield return CreateTimeCondition(0.5f);
		CarParkGoon1.LookAt(Margot);
		CarParkGoon1.unitModel.Play("TransDIdleToCIdle");
		CarParkGoon1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		CarParkGoon2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Margot, "TransCCrouchToCIdle");
		yield return CreateAndCondition(UnitMoveToTarget(CarParkGoon1, T_Goon1Cover, null, 5f), UnitMoveToTarget(CarParkGoon2, T_Goon2Cover, OctDir.UpLeft, 5f));
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "CombatIdle");
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/tucker combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		I_CarparkExitTrigger.gameObject.SetActive(value: true);
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "DefaultSlowWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.TransDIdleToCIdle, "TransDIdleToCIdle");
		MusicPlay("event:/music/tracks/basic/bugsys theme");
		HAGIS.DialogShow(Ambient_MargotWhew);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTenorBar);
		yield return CreateTriggerCondition(I_CarparkExitTrigger.OnTriggered);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		yield return MapGoto(KaydockArenaBar);
		SKIP_POINT("Skipped Carpark combat");
		MusicStop();
		SKIP_POINT("Skipped to bar");
		UIObjectives.Inst.CompleteObjective(objTenorBar);
		S_BarToCarpark.gameObject.SetActive(value: false);
		CutsceneBegin();
		yield return CreateTimeCondition(0.2f);
		UnitMoveToTarget(Bugsy, T_Moosehead);
		yield return HAGIS.DialogShow(Ambient_BugsyMoose);
		yield return CreateTimeCondition(0.3f);
		SFXPlayAtCoord("event:/sfx/script/act 3/a3o3/bar elevator arrives", sfx_elevator_ping);
		yield return CreateTimeCondition(1f);
		Bugsy.LookAt(T_MargotEntry.transform);
		yield return UnitTeleportToMapViaEntranceTile(Margot, S_BarToCarpark, T_MargotEntry);
		Margot.LookAt(Bugsy);
		Margot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Margot);
		yield return CreateTimeCondition(0.3f);
		yield return HAGIS.DialogShow(Dialog_BugsyFlirts);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		yield return null;
		yield return CutscenePlay("A3O3_Cutscene_ArenaFightStarts");
		yield return null;
		UnitMoveToTarget(Bugsy, T_BugsyExit);
		UnitMoveToTarget(Marybelle, T_MarybelleExit);
		yield return null;
		SKIP_POINT("Skipped bar cutscene");
		UIObjectives.Inst.CompleteAndSetMainObjective(objHoldOut);
		MusicPlay("event:/music/tracks/combat/frenzy");
		CombatBegin(UnitTeam.Type.Player);
		HagletYieldTerm enemyTurnStarted = TurnModeWaitForEnemyTurnStart();
		yield return CreateOrCondition(CombatWaitUntilComplete(), enemyTurnStarted);
		if (SaveData.SplitPoint(enemyTurnStarted.met, skipOverride: true))
		{
			HAGIS.DialogShow(Ambient_MargotNeedsHelp1);
			enemyTurnStarted = TurnModeWaitForEnemyTurnStart();
			yield return CreateOrCondition(CombatWaitUntilComplete(), enemyTurnStarted);
			if (SaveData.SplitPoint(enemyTurnStarted.met, skipOverride: true))
			{
				HAGIS.DialogShow(Ambient_MargotNeedsHelp2);
				yield return TurnModeWaitForPlayerTurnStart();
				yield return EndTurnMode();
			}
		}
		SKIP_POINT("Skipped inital bar fight");
		MusicPlay("event:/music/tracks/basic/drone 1");
		yield return null;
		UIObjectives.Inst.CompleteObjective(objHoldOut);
		CutsceneBegin();
		SFXPlayAtCoord("event:/sfx/script/act 3/a3o3/bar elevator arrives", sfx_elevator_ping);
		yield return CreateTimeCondition(1f);
		Willa.gameObject.SetActive(value: true);
		Archi.gameObject.SetActive(value: true);
		UnitMoveToTarget(Willa, T_WillaEntry);
		yield return UnitMoveToTarget(Archi, T_ArchiEntry);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Willa.SetTeamType(UnitTeam.Type.Player);
		HAGIS.DialogShow(Ambient_ArchiArrives);
		Tucker_bar5.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Tucker_bar5, T_TuckerPosition2);
		CutsceneEnd();
		yield return null;
		GC.Inst.SetRPGLeader(Margot);
		SKIP_POINT("Skipped Willa and Archi arriving fight");
		MusicPlay("event:/music/tracks/combat/generic combat 1");
		yield return CombatBegin(UnitTeam.Type.Player);
		SKIP_POINT("Skipped Combat");
		CutsceneBegin();
		yield return CreateTimeCondition(1.5f);
		MusicStop();
		yield return CreateAndCondition(UnitMoveToTarget(Margot, T_MargotAfterFight), UnitMoveToTarget(Willa, T_WillaAfterfight), UnitMoveToTarget(Archi, T_ArchiAfterFight));
		Margot.LookAt(Archi);
		Willa.LookAt(Archi);
		Archi.LookAt(Margot);
		yield return HAGIS.DialogShow(Dialog_TuckersFinished);
		CutsceneEnd();
		SKIP_POINT("Skipped Cutscene");
		UIObjectives.Inst.CompleteAndSetMainObjective(objTakeTheSkyway);
		yield return null;
		S_BarToSkyway.gameObject.SetActive(value: true);
		Skyway.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilMidTransition(Skyway);
		SKIP_POINT("Skipped moving onto train");
		CutsceneBegin();
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateAndCondition(UnitMoveToTarget(Margot, P_DefaultUnitPos1, OctDir.Left), UnitMoveToTarget(Archi, P_DefaultUnitPos2, OctDir.Right), UnitMoveToTarget(Willa, P_DefaultUnitPos3, OctDir.UpLeft));
		yield return HAGIS.DialogShow(Dialog_WhatHappenedMargot);
		yield return UnitPlayAnimation(Margot, "CsTransDIdleToSadIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSadIdle");
		Margot.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_MargotsHistory);
		yield return UnitPlayAnimation(Margot, "CsTransSadIdleToDIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.UpdateIdleAnim();
		yield return HAGIS.DialogShow(ambient_ShowHimHowItFeels);
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_WatchHQ_L0");
		S_SkywayToHQ1.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		CutsceneEnd();
		SKIP_POINT("Skipped Cutscene");
		yield return MapWaitUntilVisible(HQExterior.Map);
		SKIP_POINT("Skipped to HQ exterior");
		MusicPlay("event:/music/tracks/basic/three heads are better");
		S_HQToSkyway.gameObject.SetActive(value: false);
		HAGIS.DialogShow(Ambient_FloorDroids);
		PlayMapAnimation(Clocktower.Map, ClocktowerStatue, "RevealDoor");
		Target_Statue1.gameObject.SetActive(value: false);
		Target_Statue2.gameObject.SetActive(value: false);
		Target_Statue3.gameObject.SetActive(value: true);
		Target_Statue4.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(HQRooftop.Map);
		MusicPlay("event:/music/tracks/combat/tucker combat");
		yield return CreateTimeCondition(2f);
		SKIP_POINT("Skipped to HQ Roof");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		S_HQToRooftop.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(Clocktower.Map);
		MusicPlay("event:/music/tracks/basic/drone 2");
		UIObjectives.Inst.CompleteObjective(objTakeTheSkyway);
		SKIP_POINT("Skipped to Clocktower");
		CutsceneBegin();
		UnitMoveToTarget(Willa, T_TeamArrive3);
		UnitMoveToTarget(Archi, T_TeamArrive2);
		yield return UnitMoveToTarget(Margot, T_TeamArrive1);
		Willa.LookAt(Bugsy);
		Archi.LookAt(Bugsy);
		Margot.LookAt(Bugsy);
		yield return Wait.While(Bugsy.LookAt(Willa));
		yield return Wait.While(Marybelle.LookAt(Willa));
		yield return HAGIS.DialogShow(Dialog_BugsyAtClocktower);
		yield return UnitPlayAnimation(Bugsy, "CsDefaultThreaten");
		yield return HAGIS.DialogShow(Dialog_BugsyThreatensMary);
		yield return Wait.While(Marybelle.LookAt(Bugsy));
		HAGIS.DialogShow(Ambient_MaryExcusesHerself);
		yield return UnitMoveToTarget(Marybelle, T_MarybelleLeaves);
		Marybelle.LookAt(Bugsy);
		yield return HAGIS.DialogShow(Dialog_MaryStormsOff);
		yield return UnitMoveToTarget(Marybelle, T_MarybelleLeaves2);
		Marybelle.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Dialog_MargotInsultsBugsy);
		HAGIS.DialogShow(Ambient_BugsyMad);
		yield return UnitPlayAnimation(Bugsy, "TransDIdleToCIdle");
		Bugsy.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Bugsy.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Bugsy.UpdateIdleAnim();
		yield return UnitMoveToTarget(Bugsy, T_BugsyCover, null, 5f);
		HAGIS_A3O3 hAGIS_A3O = this;
		Unit willa = Willa;
		UnitTarget t_TeamCover = T_TeamCover1;
		float? speed = Willa.charData.movementSpeedInCombat;
		hAGIS_A3O.UnitMoveToTarget(willa, t_TeamCover, null, speed);
		HAGIS_A3O3 hAGIS_A3O2 = this;
		willa = Archi;
		t_TeamCover = T_TeamCover2;
		speed = Archi.charData.movementSpeedInCombat;
		hAGIS_A3O2.UnitMoveToTarget(willa, t_TeamCover, null, speed);
		HAGIS_A3O3 hAGIS_A3O3 = this;
		willa = Margot;
		t_TeamCover = T_TeamCover3;
		speed = Margot.charData.movementSpeedInCombat;
		yield return hAGIS_A3O3.UnitMoveToTarget(willa, t_TeamCover, null, speed);
		CutsceneEnd();
		SKIP_POINT("Skipped Clocktower cutscene");
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefeatBugsy);
		MusicPlay("event:/music/tracks/combat/frenzy");
		Singleton<AIC>.Inst.OnExternalAIBegan = myAI;
		CombatBegin(UnitTeam.Type.Enemy);
		if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
		{
			yield return Singleton<AIC>.Inst.OnExternalAIBegan;
		}
		ConstArray<v2i> leapTarget = new ConstArray<v2i>(1u);
		ConstArray<Unit> bleedTargets = new ConstArray<Unit>(3u);
		Ability_Leap leap = Bugsy.abilities.AbilityGetByType<Ability_Leap>();
		Ability_Bleed bleed = Bugsy.abilities.AbilityGetByType<Ability_Bleed>();
		bleedTargets.Add(Margot);
		bleedTargets.Add(Willa);
		bleedTargets.Add(Archi);
		bleed.OnActivateWithUnitsSelectedBase(Bugsy, bleedTargets, default(UIAbilityWheelChoice));
		bleedTargets.Clear();
		yield return CreateTimeCondition(3f);
		leapTarget.Add(new v2i(15, 3));
		leap.OnActivateWithTilesSelectedBase(Bugsy, leapTarget, default(UIAbilityWheelChoice));
		leapTarget.Clear();
		Bugsy.APDecrement(Bugsy.AP);
		Singleton<AIC>.Inst.OnExternalAIBegan = null;
		Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
		yield return CombatWaitUntilComplete();
		SKIP_POINT("Skipped Bugsy's boss fight");
		MusicStop();
		Bugsy.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Bugsy.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UIObjectives.Inst.CompleteObjective(objDefeatBugsy);
		yield return null;
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultIdlePistol");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultWalkPistol");
		Marybelle.UpdateIdleAnim();
		Bugsy.Revive();
		yield return CreateTimeCondition(2f);
		Willa.LookAt(Bugsy.gameObject.transform, keepEyeOn: true);
		Archi.LookAt(Bugsy.gameObject.transform, keepEyeOn: true);
		Margot.LookAt(Bugsy.gameObject.transform, keepEyeOn: true);
		yield return CutscenePlay("A3O3_Cutscene_MaryThreatensBugsy");
		yield return CutscenePlay("A3O3_Cutscene_MaryKicksBugsy");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitTeleportToMapViaEntranceTile(Bugsy, S_HQToSkyway, T_BugsyLanding);
		Bugsy.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultOnBack");
		Bugsy.UpdateIdleAnim();
		yield return null;
		yield return MapGoto(HQExterior);
		SKIP_POINT("Bugsy'S death Scene");
		SFXPlayAtCoord("event:/sfx/script/act 3/a3o3/bugsy lands", T_BugsyLanding);
		yield return CutscenePlay("A3O3_Cutscene_TheoKillsBugsy");
		yield return MapGoto(Clocktower);
		yield return null;
		CutsceneBegin();
		Marybelle.LookAt(Willa);
		Willa.LookAt(Marybelle);
		Archi.LookAt(Marybelle);
		Margot.LookAt(Marybelle);
		yield return HAGIS.DialogShow(Dialog_MarybelleEscape);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		I_ToCelestia.gameObject.SetActive(value: true);
		UIObjectives.Inst.CompleteAndSetMainObjective(objTakeMary);
		CutsceneEnd();
		SKIP_POINT("Skipped Bugsy death");
		yield return null;
		GC.Inst.SetRPGLeader(Willa);
		yield return null;
		yield return CreateTriggerCondition(I_ToCelestia.OnTriggered);
		yield return UnitTeleportToMapViaEntranceTile(Willa, S_CelestiaToClocktower);
		yield return UnitMoveToMapViaExitTile(Marybelle, S_ClocktowerToCelestia, T_Marybelle_CT);
		yield return MapGoto(CelestiaCentre);
		SKIP_POINT("Skipped to Celestia");
		MusicStop();
		S_CelestiaToClocktower.gameObject.SetActive(value: false);
		CutsceneBegin();
		HAGIS.DialogShow(Ambiant_WillaConcerned);
		yield return UnitMoveToUnit(Willa, Ambrosia);
		Willa.LookAt(Ambrosia);
		yield return UnitMoveToTarget(Marybelle, T_Marybelle_CT);
		Marybelle.LookInDirection(OctDir.Left);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		Marybelle.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/basic/new savannah underscore");
		yield return MapWaitUntilVisible(CelestiaRelayTower.Map);
		yield return MapWaitUntilVisible(CelestiaGardens.Map);
		SKIP_POINT("Skipped to Botanical Gardens");
		S_GardenToRelaytower.gameObject.SetActive(value: false);
		MusicStop();
		HAGIS.DialogShow(Ambient_MaryBack);
		yield return CreateTriggerCondition(I_Pod.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objTakeMary);
		Marybelle.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		yield return CutscenePlay("A3O3_Cutscene_UncoverPod");
		CutsceneBegin();
		yield return null;
		CutsceneEnd();
		yield return CutscenePlay("A3O3_Cutscene_MarybelleHelps");
		CutsceneBegin();
		yield return null;
		CutsceneEnd();
	}
}
public class HAGIS_A3O3_CrowAnimations : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Unit TownCrow = GC.Inst.GetUnitWithId("21A_T3CelestiaTownCentre_UnitSpawn");
		TownCrow.unitModel.HACK_BirdMode = true;
		TileTrigger TT_ACTIVITEBIRDS = MR.Inst.GetTileTrigger("01C_T3CelestiaTownCentre_TileTrigger");
		LogicRoot CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		yield return null;
		yield return TT_ACTIVITEBIRDS._OnTriggered;
		yield return null;
		UnitPlayAnimation(TownCrow, "DefaultTakeOff");
		yield return CreateTimeCondition(2f);
		TownCrow.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		TownCrow.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		TownCrow.unitModel.Play(UnitModel.AnimID.DefaultIdle);
	}
}
public class HAGIS_A3O4 : HAGIS
{
	private Unit Willa;

	private Unit Gosz;

	private Unit Archi;

	private Unit Margot;

	private Unit Marybelle;

	private Unit Droid_CE1;

	private Unit Droid_CE2;

	private Unit Droid_CE3;

	private Unit Droid_CE10;

	private Unit Droid_CE11;

	private Unit Droid_CE12;

	private Unit Underclock_CE1;

	private Unit Underclock_CE2;

	private Unit Droid1A_TB;

	private Unit Droid1B_TB;

	private Unit Droid2A_TB;

	private Unit Droid2B_TB;

	private Unit Droid3A_TB;

	private Unit Droid3B_TB;

	private Unit Droid4A_TB;

	private Unit Droid4B_TB;

	private Unit Droid5B_TB;

	private Unit NPC1;

	private Unit NPC2;

	private Unit NPC4;

	private Unit NPC5;

	private Unit NPC6;

	private Unit ShockedNPC3;

	private Unit ShockedNPC7;

	private UnitTarget T_Willa_CE;

	private UnitTarget T_Gosz_CE;

	private UnitTarget T_Archi_CE;

	private UnitTarget T_Margot_CE;

	private UnitTarget T_Underclock1_CE1;

	private UnitTarget T_Underclock1_CE2;

	private UnitTarget T_Underclock1_CE3;

	private UnitTarget T_Underclock2_CE1;

	private UnitTarget T_Underclock2_CE2;

	private UnitTarget T_Underclock2_CE3;

	private UnitTarget T_Underclock2_CE4;

	private UnitTarget T_Underclock_CE5;

	private UnitTarget T_Droids_TE1;

	private UnitTarget T_Droids_TE2;

	private UnitTarget T_Droids_TE3;

	private UnitTarget T_Droids_TE4;

	private UnitTarget T_Droids_TE5;

	private UnitTarget T_Droids_TE6;

	private UnitTarget T_Droids_TE7;

	private UnitTarget T_Droids_TE8;

	private UnitTarget T_Droids_TE9;

	private UnitTarget T_Gosz_CI;

	private UnitTarget T_Willa_CI;

	private UnitTarget T_SubToGlass;

	private UnitTarget T_ThirdMemToGlass;

	private UnitTarget T_LeaderToGlass;

	private UnitTarget T_Gosz_TB1;

	private UnitTarget T_Gosz_TB2;

	private UnitTarget T_Gosz_TB3;

	private UnitTarget T_Droid_TB1;

	private UnitTarget T_Droid_TB2;

	private UnitTarget T_Droid_TB3;

	private UnitTarget T_Droid_TB4;

	private UnitTarget T_Droid_TB5;

	private UnitTarget T_Droid_TB6;

	private UnitTarget T_Droid_TB7;

	private UnitTarget T_Droid_TB8;

	private UnitTarget T_Droid_TB9;

	private UnitTarget UnitPos2;

	private UnitTarget UnitPos3;

	private UnitTarget UnitPos4;

	private UnitTarget T_WillaMovesFromDoor;

	private UnitTarget T_ArchiMovesFromDoor;

	private UnitTarget T_MargotMovesFromDoor;

	private TileBlockDynamic TL1;

	private TileBlockDynamic TL2;

	private TileBlockDynamic TL3;

	private TileBlockDynamic TM1;

	private TileBlockDynamic TM2;

	private TileBlockDynamic TM3;

	private TileBlockDynamic TR1;

	private TileBlockDynamic TR2;

	private TileBlockDynamic TR3;

	private TileBlockDynamic BL1;

	private TileBlockDynamic BL2;

	private TileBlockDynamic BL3;

	private TileBlockDynamic BM1;

	private TileBlockDynamic BM2;

	private TileBlockDynamic BM3;

	private TileBlockDynamic BR1;

	private TileBlockDynamic BR2;

	private TileBlockDynamic BR3;

	private TileBlockDynamic M1;

	private TileBlockDynamic M2;

	private TileBlockDynamic M3;

	private TileBlockDynamic R1;

	private TileBlockDynamic R2;

	private TileBlockDynamic R3;

	private TileBlockDynamic DroidDoor1;

	private TileBlockDynamic DroidDoor2;

	private TileBlockDynamic DroidDoor3;

	private TileBlockDynamic DroidDoor4;

	private TileActionSwapMap ChumExToChumInt;

	private TileActionSwapMap ChumExToSkyway;

	private TileActionSwapMap ChumIntToChumExt;

	private TileActionSwapMap ChumIntToTestBay;

	private TileActionSwapMap TestBayToChumInt;

	private TileActionSwapMap BarToSkyway;

	private TileActionSwapMap SkywayToChum;

	private TileActionDialog D_NeedKey;

	private TileActionDialog D_SkywayMiddleman;

	private TileActionInteraction I_KeyCard;

	private TileActionInteraction I_DoorCE;

	private DialogData Ambeint_ComeOn;

	private DialogData Ambient_Alex;

	private DialogData Ambient_Announcer1;

	private DialogData Ambient_Announcer10;

	private DialogData Ambient_Announcer11;

	private DialogData Ambient_Announcer2;

	private DialogData Ambient_Announcer3;

	private DialogData Ambient_Announcer4;

	private DialogData Ambient_Announcer5;

	private DialogData Ambient_Announcer6;

	private DialogData Ambient_Announcer7;

	private DialogData Ambient_Announcer8;

	private DialogData Ambient_Announcer9;

	private DialogData Ambient_CardDosentWork;

	private DialogData Ambient_Corrupt_Announcer1;

	private DialogData Ambient_Corrupt_Announcer2;

	private DialogData Ambient_Corrupt_Announcer3;

	private DialogData Ambient_Corrupt_Announcer4;

	private DialogData Ambient_Corrupt_Announcer5;

	private DialogData Ambient_GetToTheSkyway;

	private DialogData Dialog_ANNOUNCER;

	private DialogData Dialog_Gosz;

	private DialogData Dialog_HowLong;

	private DialogData Dialog_IsAlexOK;

	private DialogData Dialog_TheyDeployed;

	private DialogData Dialog_TimeToGo;

	private DialogData Dialog_TimeToGo2;

	private DialogData Dialog_TradeAgreements;

	private DialogData Dialog_InTwelveHours;

	private string objMeetGosz = "OBJECTIVES_A3O4_01";

	private string objFindAWay = "OBJECTIVES_A3O4_02";

	private string objHeadInside = "OBJECTIVES_A3O4_03";

	private string objProtectGosz = "OBJECTIVES_A3O4_04";

	private string objGetToSkyway = "OBJECTIVES_A3O4_05";

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot ChumExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot ChumIntereior = GetLogicUsingArtName("T2ChumleysFactory");
		LogicRoot TestBay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot KaydockBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		Willa = GC.Inst.GetUnitWithId("FD2_T2TheKaydockArenaBar_UnitSpawn");
		Gosz = GC.Inst.GetUnitWithId("5BA_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("0C8_T2TheKaydockArenaBar_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("6B1_T2TheKaydockArenaBar_UnitSpawn");
		Marybelle = GC.Inst.GetUnitWithId("3DB_T2TheKaydockArenaBar_UnitSpawn");
		Droid_CE1 = GC.Inst.GetUnitWithId("AC4_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid_CE2 = GC.Inst.GetUnitWithId("FCC_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid_CE3 = GC.Inst.GetUnitWithId("097_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid_CE10 = GC.Inst.GetUnitWithId("220_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid_CE11 = GC.Inst.GetUnitWithId("6D2_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid_CE12 = GC.Inst.GetUnitWithId("FD1_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Underclock_CE1 = GC.Inst.GetUnitWithId("48E_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Underclock_CE2 = GC.Inst.GetUnitWithId("F81_T2ChumleysAutomatons_Exterior_UnitSpawn");
		Droid1A_TB = GC.Inst.GetUnitWithId("C73_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid1B_TB = GC.Inst.GetUnitWithId("D06_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid2A_TB = GC.Inst.GetUnitWithId("F4E_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid2B_TB = GC.Inst.GetUnitWithId("7F0_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid3A_TB = GC.Inst.GetUnitWithId("604_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid3B_TB = GC.Inst.GetUnitWithId("EA5_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid4A_TB = GC.Inst.GetUnitWithId("FC6_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid4B_TB = GC.Inst.GetUnitWithId("293_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid5B_TB = GC.Inst.GetUnitWithId("B6C_T2ChumleysFactory_TestingControlBay_UnitSpawn");
		Droid1A_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid1B_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid2A_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid2B_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid3A_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid3B_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid4A_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid4B_TB.SetTeamType(UnitTeam.Type.Enemy);
		Droid5B_TB.SetTeamType(UnitTeam.Type.Enemy);
		NPC1 = GC.Inst.GetUnitWithId("07D_T2Skyway_UnitSpawn");
		NPC2 = GC.Inst.GetUnitWithId("582_T2Skyway_UnitSpawn");
		NPC4 = GC.Inst.GetUnitWithId("374_T2Skyway_UnitSpawn");
		NPC5 = GC.Inst.GetUnitWithId("08A_T2Skyway_UnitSpawn");
		NPC6 = GC.Inst.GetUnitWithId("4C1_T2Skyway_UnitSpawn");
		ShockedNPC3 = GC.Inst.GetUnitWithId("1AE_T2Skyway_UnitSpawn");
		ShockedNPC7 = GC.Inst.GetUnitWithId("9F9_T2Skyway_UnitSpawn");
		T_Willa_CE = MR.Inst.GetUnitTarget("4EB_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Gosz_CE = MR.Inst.GetUnitTarget("F18_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Archi_CE = MR.Inst.GetUnitTarget("515_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Margot_CE = MR.Inst.GetUnitTarget("AB6_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock1_CE1 = MR.Inst.GetUnitTarget("01E_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock1_CE2 = MR.Inst.GetUnitTarget("53B_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock1_CE3 = MR.Inst.GetUnitTarget("136_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock2_CE1 = MR.Inst.GetUnitTarget("B5D_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock2_CE2 = MR.Inst.GetUnitTarget("A79_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock2_CE3 = MR.Inst.GetUnitTarget("2F9_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock2_CE4 = MR.Inst.GetUnitTarget("9BC_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Underclock_CE5 = MR.Inst.GetUnitTarget("923_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE1 = MR.Inst.GetUnitTarget("BD8_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE2 = MR.Inst.GetUnitTarget("0A3_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE3 = MR.Inst.GetUnitTarget("944_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE4 = MR.Inst.GetUnitTarget("4F0_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE5 = MR.Inst.GetUnitTarget("EC3_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE6 = MR.Inst.GetUnitTarget("F9B_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE7 = MR.Inst.GetUnitTarget("CD9_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE8 = MR.Inst.GetUnitTarget("DD1_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Droids_TE9 = MR.Inst.GetUnitTarget("6F0_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_Gosz_CI = MR.Inst.GetUnitTarget("D49_T2ChumleysFactory_UnitTarget");
		T_Willa_CI = MR.Inst.GetUnitTarget("A92_T2ChumleysFactory_UnitTarget");
		T_SubToGlass = MR.Inst.GetUnitTarget("923_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_ThirdMemToGlass = MR.Inst.GetUnitTarget("687_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_LeaderToGlass = MR.Inst.GetUnitTarget("5BF_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Gosz_TB1 = MR.Inst.GetUnitTarget("AB1_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Gosz_TB2 = MR.Inst.GetUnitTarget("9DC_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Gosz_TB3 = MR.Inst.GetUnitTarget("0C6_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB1 = MR.Inst.GetUnitTarget("97C_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB2 = MR.Inst.GetUnitTarget("C0F_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB3 = MR.Inst.GetUnitTarget("5D0_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB4 = MR.Inst.GetUnitTarget("702_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB5 = MR.Inst.GetUnitTarget("D04_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB6 = MR.Inst.GetUnitTarget("496_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB7 = MR.Inst.GetUnitTarget("FF3_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB8 = MR.Inst.GetUnitTarget("915_T2ChumleysFactory_TestingControlBay_UnitTarget");
		T_Droid_TB9 = MR.Inst.GetUnitTarget("36C_T2ChumleysFactory_TestingControlBay_UnitTarget");
		UnitTarget T_Droid_TB10 = MR.Inst.GetUnitTarget("F51_T2ChumleysFactory_TestingControlBay_UnitTarget");
		UnitTarget T_Droid_TB11 = MR.Inst.GetUnitTarget("89E_T2ChumleysFactory_TestingControlBay_UnitTarget");
		UnitPos2 = MR.Inst.GetUnitTarget("EB0_T2ChumleysAutomatons_Exterior_UnitTarget");
		UnitPos3 = MR.Inst.GetUnitTarget("59A_T2ChumleysAutomatons_Exterior_UnitTarget");
		UnitPos4 = MR.Inst.GetUnitTarget("A6C_T2ChumleysAutomatons_Exterior_UnitTarget");
		T_WillaMovesFromDoor = MR.Inst.GetUnitTarget("9AD_T2Skyway_UnitTarget");
		T_ArchiMovesFromDoor = MR.Inst.GetUnitTarget("AD8_T2Skyway_UnitTarget");
		T_MargotMovesFromDoor = MR.Inst.GetUnitTarget("F36_T2Skyway_UnitTarget");
		ChumExToChumInt = MR.Inst.GetTileActionSwapMap("937_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		ChumExToSkyway = MR.Inst.GetTileActionSwapMap("574_T2ChumleysAutomatons_Exterior_TileActionSwapMap");
		ChumIntToChumExt = MR.Inst.GetTileActionSwapMap("257_T2ChumleysFactory_TileActionSwapMap");
		ChumIntToTestBay = MR.Inst.GetTileActionSwapMap("155_T2ChumleysFactory_TileActionSwapMap");
		TestBayToChumInt = MR.Inst.GetTileActionSwapMap("8E5_T2ChumleysFactory_TestingControlBay_TileActionSwapMap");
		BarToSkyway = MR.Inst.GetTileActionSwapMap("8A9_T2TheKaydockArenaBar_TileActionSwapMap");
		SkywayToChum = MR.Inst.GetTileActionSwapMap("72B_T2Skyway_TileActionSwapMap");
		I_KeyCard = MR.Inst.GetTileActionInteraction("3F1_T2ChumleysAutomatons_Exterior_TileActionInteraction");
		I_DoorCE = MR.Inst.GetTileActionInteraction("7EF_T2ChumleysAutomatons_Exterior_TileActionInteraction");
		D_NeedKey = MR.Inst.GetTileActionDialog("000_T2ChumleysAutomatons_Exterior_TileActionDialog");
		D_SkywayMiddleman = MR.Inst.GetTileActionDialog("086_T2Skyway_TileActionDialog");
		string coverAnimator = "MA_Cover";
		TL1 = MR.Inst.GetTileBlockDynamic("857_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TL2 = MR.Inst.GetTileBlockDynamic("EAB_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TL3 = MR.Inst.GetTileBlockDynamic("90F_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM1 = MR.Inst.GetTileBlockDynamic("C31_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM2 = MR.Inst.GetTileBlockDynamic("35C_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TM3 = MR.Inst.GetTileBlockDynamic("CE7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR1 = MR.Inst.GetTileBlockDynamic("89B_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR2 = MR.Inst.GetTileBlockDynamic("9E5_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TR3 = MR.Inst.GetTileBlockDynamic("1E9_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL1 = MR.Inst.GetTileBlockDynamic("36F_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL2 = MR.Inst.GetTileBlockDynamic("6D0_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BL3 = MR.Inst.GetTileBlockDynamic("8FF_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM1 = MR.Inst.GetTileBlockDynamic("B95_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM2 = MR.Inst.GetTileBlockDynamic("9D7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BM3 = MR.Inst.GetTileBlockDynamic("6F2_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR1 = MR.Inst.GetTileBlockDynamic("5C6_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR2 = MR.Inst.GetTileBlockDynamic("643_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		BR3 = MR.Inst.GetTileBlockDynamic("67E_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M1 = MR.Inst.GetTileBlockDynamic("D24_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M2 = MR.Inst.GetTileBlockDynamic("2D7_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		M3 = MR.Inst.GetTileBlockDynamic("AA5_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R1 = MR.Inst.GetTileBlockDynamic("D48_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R2 = MR.Inst.GetTileBlockDynamic("A7E_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		R3 = MR.Inst.GetTileBlockDynamic("8CB_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DroidDoor1 = MR.Inst.GetTileBlockDynamic("897_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DroidDoor2 = MR.Inst.GetTileBlockDynamic("192_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DroidDoor3 = MR.Inst.GetTileBlockDynamic("53B_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		DroidDoor4 = MR.Inst.GetTileBlockDynamic("3D4_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		TileBlockDynamic ContolRoomBlock = MR.Inst.GetTileBlockDynamic("AFE_T2ChumleysFactory_TestingControlBay_TileBlockDynamic");
		UnitTarget PassTarget = MR.Inst.GetUnitTarget("CEC_T2ChumleysAutomatons_Exterior_UnitTarget");
		Ambeint_ComeOn = HAGIS.DialogLoad("Dialogs/A3O4/Ambeint_ComeOn");
		Ambient_Alex = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Alex");
		Ambient_Announcer1 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer1");
		Ambient_Announcer10 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer10");
		Ambient_Announcer11 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer11");
		Ambient_Announcer2 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer2");
		Ambient_Announcer3 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer3");
		Ambient_Announcer4 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer4");
		Ambient_Announcer5 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer5");
		Ambient_Announcer6 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer6");
		Ambient_Announcer7 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer7");
		Ambient_Announcer8 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer8");
		Ambient_Announcer9 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer9");
		Ambient_CardDosentWork = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_CardDosentWork");
		Ambient_Corrupt_Announcer1 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer1");
		Ambient_Corrupt_Announcer2 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer2");
		Ambient_Corrupt_Announcer3 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer3");
		Ambient_Corrupt_Announcer4 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer4");
		Ambient_Corrupt_Announcer5 = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer5");
		Ambient_GetToTheSkyway = HAGIS.DialogLoad("Dialogs/A3O4/Ambient_GetToTheSkyway");
		Dialog_ANNOUNCER = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_ANNOUNCER");
		Dialog_Gosz = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_Gosz");
		Dialog_HowLong = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_HowLong");
		Dialog_IsAlexOK = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_IsAlexOK");
		Dialog_TheyDeployed = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_TheyDeployed");
		Dialog_TimeToGo = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_TimeToGo");
		Dialog_TimeToGo2 = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_TimeToGo2");
		Dialog_TradeAgreements = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_TradeAgreements");
		Dialog_InTwelveHours = HAGIS.DialogLoad("Dialogs/A3O4/Dialog_InTwelveHours");
		List<DialogData> WavesDialogs = new List<DialogData>
		{
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer1"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer10"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer11"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer2"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer3"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer4"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer5"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer6"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer7"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer8"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Announcer9")
		};
		List<DialogData> CorruptDialogs = new List<DialogData>
		{
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer1"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer2"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer3"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer4"),
			HAGIS.DialogLoad("Dialogs/A3O4/Ambient_Corrupt_Announcer5")
		};
		ShockedNPC3.gameObject.SetActive(value: false);
		ShockedNPC7.gameObject.SetActive(value: false);
		ChumExToChumInt.gameObject.SetActive(value: false);
		ChumExToSkyway.gameObject.SetActive(value: false);
		I_KeyCard.gameObject.SetActive(value: false);
		I_DoorCE.gameObject.SetActive(value: false);
		Droid1A_TB.gameObject.SetActive(value: false);
		Droid1B_TB.gameObject.SetActive(value: false);
		Droid2A_TB.gameObject.SetActive(value: false);
		Droid2B_TB.gameObject.SetActive(value: false);
		Droid3A_TB.gameObject.SetActive(value: false);
		Droid3B_TB.gameObject.SetActive(value: false);
		Droid4A_TB.gameObject.SetActive(value: false);
		Droid4B_TB.gameObject.SetActive(value: false);
		Droid5B_TB.gameObject.SetActive(value: false);
		SkywayToChum.gameObject.SetActive(value: false);
		BarToSkyway.gameObject.SetActive(value: false);
		ContolRoomBlock.gameObject.SetActive(value: false);
		yield return null;
		MusicPlay("event:/music/tracks/basic/marybelle theme");
		UIObjectives.Inst.CompleteAndSetMainObjective(objMeetGosz);
		yield return HAGIS.DialogShow(Dialog_TradeAgreements);
		yield return null;
		yield return UnitPlayAnimation(Marybelle, "CsTransPhoneIdleToDIdle");
		yield return UnitPlayAnimation(Marybelle, "DefaultIdle");
		Marybelle.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Marybelle.UpdateIdleAnim();
		Marybelle.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(Dialog_InTwelveHours);
		BarToSkyway.gameObject.SetActive(value: true);
		SKIP_POINT("skipped Opening cutscene");
		yield return MapWaitUntilVisible(Skyway.Map);
		MusicStop();
		SKIP_POINT("skipped to skyway");
		yield return UnitMoveToTarget(Willa, T_WillaMovesFromDoor, OctDir.Down);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return PlayInterplay();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_Chumleys_L0");
		SkywayToChum.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(ChumExterior.Map);
		UIObjectives.Inst.CompleteObjective(objMeetGosz);
		SKIP_POINT("skipped to factory exterior");
		MusicPlay("event:/music/tracks/basic/chumleys military");
		CutsceneBegin();
		PlayMapAnimation(ChumExterior.Map, "MA_ChumleysFactoryExterior_LoadingBayDoor_01", "Open");
		yield return CreateTimeCondition(1f);
		yield return CreateAndCondition(UnitMoveToTarget(Droid_CE1, T_Droids_TE1), UnitMoveToTarget(Droid_CE2, T_Droids_TE2), UnitMoveToTarget(Droid_CE3, T_Droids_TE3));
		Droid_CE1.Hide(makeInactive: true);
		Droid_CE2.Hide(makeInactive: true);
		Droid_CE3.Hide(makeInactive: true);
		yield return CreateAndCondition(UnitMoveToTarget(Droid_CE10, T_Droids_TE1), UnitMoveToTarget(Droid_CE11, T_Droids_TE2), UnitMoveToTarget(Droid_CE12, T_Droids_TE3));
		Droid_CE10.Hide(makeInactive: true);
		Droid_CE11.Hide(makeInactive: true);
		Droid_CE12.Hide(makeInactive: true);
		yield return CreateTimeCondition(1f);
		PlayMapAnimation(ChumExterior.Map, "MA_ChumleysFactoryExterior_LoadingBayDoor_01", "Close");
		yield return HAGIS.DialogShow(Dialog_TheyDeployed);
		Underclock_CE1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Underclock_CE1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Underclock_CE2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Underclock_CE2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		UnitMoveToTarget(Underclock_CE1, T_Underclock1_CE3, null, 5f);
		yield return UnitMoveToTarget(Underclock_CE2, T_Underclock2_CE3, null, 5f);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/old combat");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/chumleys military");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindAWay);
		D_NeedKey.gameObject.SetActive(value: false);
		yield return null;
		I_DoorCE.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(I_DoorCE.OnTriggered);
		yield return UnitPlayAnimation(Willa, "DefaultInteract");
		PlayMapAnimation(TestBay.Map, coverAnimator, "InstantEmpty");
		ChumExterior.unitsMoveToDefaultPositions = true;
		CutsceneBegin();
		yield return TeamMoveToMapViaEntranceTile(TestBayToChumInt);
		yield return MapGoto(TestBay);
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadInside);
		CutsceneEnd();
		TestBayToChumInt.gameObject.SetActive(value: false);
		yield return UnitMoveToMapViaExitTile(Gosz, ChumIntToTestBay);
		UIObjectives.Inst.CompleteObjective(objHeadInside);
		SKIP_POINT("Skiped to Test Bay");
		CutsceneBegin();
		UnitMoveToTarget(Willa, T_Droid_TB6, OctDir.Right);
		yield return UnitMoveToTarget(Gosz, T_Gosz_TB3, null, 5.5f);
		Gosz.LookInDirection(OctDir.Right);
		yield return UnitPlayAnimation(Gosz, "CsTransDIdleToTypeIdle");
		yield return UnitPlayAnimation(Gosz, "CsTypeIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsTypeIdle");
		Gosz.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/combat/waves 3o4");
		yield return HAGIS.DialogShow(Dialog_ANNOUNCER);
		yield return HAGIS.DialogShow(Dialog_HowLong);
		ContolRoomBlock.gameObject.SetActive(value: true);
		DroidDoor1.gameObject.SetActive(value: false);
		DroidDoor3.gameObject.SetActive(value: false);
		Droid4A_TB.Show();
		Droid1A_TB.Show();
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Open");
		yield return null;
		SKIP_POINT("Skiped Test Bay cutscene");
		UIObjectives.Inst.CompleteAndSetMainObjective(objProtectGosz);
		CutsceneEnd();
		CutsceneBegin();
		PlayMapAnimation(TestBay.Map, coverAnimator, "EmptyToWave1");
		SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
		TL1.gameObject.SetActive(value: true);
		TL2.gameObject.SetActive(value: true);
		TL3.gameObject.SetActive(value: true);
		TileBlockDynamic tL = TL1;
		TileObjectBase.Height blockHeight = TileObjectBase.Height.Half;
		TL2.BlockHeight = blockHeight;
		tL.BlockHeight = blockHeight;
		TL3.BlockHeight = TileObjectBase.Height.Full;
		TR1.gameObject.SetActive(value: true);
		TR2.gameObject.SetActive(value: true);
		TR3.gameObject.SetActive(value: true);
		TM1.gameObject.SetActive(value: true);
		TM2.gameObject.SetActive(value: true);
		TM3.gameObject.SetActive(value: true);
		TileBlockDynamic tM = TM1;
		blockHeight = TileObjectBase.Height.Half;
		TM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TM2.BlockHeight = blockHeight;
		tM.BlockHeight = blockHeight;
		TileBlockDynamic tR = TR1;
		blockHeight = TileObjectBase.Height.Full;
		TR3.BlockHeight = blockHeight;
		tR.BlockHeight = blockHeight;
		TR2.BlockHeight = TileObjectBase.Height.Half;
		M1.gameObject.SetActive(value: true);
		M2.gameObject.SetActive(value: true);
		M3.gameObject.SetActive(value: true);
		TileBlockDynamic m = M1;
		blockHeight = TileObjectBase.Height.Half;
		M3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		M2.BlockHeight = blockHeight;
		m.BlockHeight = blockHeight;
		BL1.gameObject.SetActive(value: false);
		BL2.gameObject.SetActive(value: false);
		BL3.gameObject.SetActive(value: false);
		TileBlockDynamic bL = BL1;
		blockHeight = TileObjectBase.Height.Zero;
		BL3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BL2.BlockHeight = blockHeight;
		bL.BlockHeight = blockHeight;
		BM1.gameObject.SetActive(value: true);
		BM2.gameObject.SetActive(value: true);
		BM3.gameObject.SetActive(value: true);
		TileBlockDynamic bM = BM1;
		blockHeight = TileObjectBase.Height.Half;
		BM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BM2.BlockHeight = blockHeight;
		bM.BlockHeight = blockHeight;
		BR1.gameObject.SetActive(value: true);
		BR2.gameObject.SetActive(value: true);
		BR3.gameObject.SetActive(value: true);
		TileBlockDynamic bR = BR1;
		blockHeight = TileObjectBase.Height.Half;
		BR3.BlockHeight = blockHeight;
		bR.BlockHeight = blockHeight;
		BR2.BlockHeight = TileObjectBase.Height.Full;
		TileBlockDynamic r = R1;
		blockHeight = TileObjectBase.Height.Zero;
		R3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		R2.BlockHeight = blockHeight;
		r.BlockHeight = blockHeight;
		CutsceneEnd();
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		CutsceneBegin();
		UnitMoveToTarget(Archi, T_SubToGlass, OctDir.Right);
		UnitMoveToTarget(Margot, T_ThirdMemToGlass, OctDir.Right);
		UnitMoveToTarget(Willa, T_LeaderToGlass, OctDir.Right);
		UnitMoveToTarget(Droid1A_TB, T_Droid_TB1);
		yield return UnitMoveToTarget(Droid4A_TB, T_Droid_TB3);
		yield return null;
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Close");
		DroidDoor1.gameObject.SetActive(value: true);
		DroidDoor3.gameObject.SetActive(value: true);
		CutsceneEnd();
		while (true)
		{
			if (SaveData.SplitPoint(WavesDialogs.Count > 0, skipOverride: false))
			{
				HagletYieldTerm TurnsPassed = TurnModeWaitForPlayerTurnStart((uint)UnityEngine.Random.Range(1, 2));
				yield return CreateOrCondition(CombatWaitUntilComplete(), TurnsPassed);
				if (SaveData.SplitPoint(TurnsPassed.met && GC.Inst.IsInTurnMode(), skipOverride: false))
				{
					DialogData Dialog = WavesDialogs[UnityEngine.Random.Range(0, WavesDialogs.Count)];
					WavesDialogs.Remove(Dialog);
					yield return HAGIS.DialogShow(Dialog);
					continue;
				}
				break;
			}
			yield return CombatWaitUntilComplete();
			break;
		}
		SKIP_POINT("Skipped first test bay fight");
		MusicSetProgress(0.1f);
		CutsceneBegin();
		yield return UnitPlayAnimation(Gosz, "CsTransTypeIdleToDIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UnitPlayAnimation(Gosz, "CsLookAround", loop: false, updateIdle: true);
		DroidDoor1.gameObject.SetActive(value: false);
		DroidDoor2.gameObject.SetActive(value: false);
		DroidDoor3.gameObject.SetActive(value: false);
		Droid2A_TB.Show();
		Droid2B_TB.Show();
		Droid4B_TB.Show();
		GC.Inst.GetTeamOfType(UnitTeam.Type.Player).MoveTeamToDefaultPositions();
		v2i willasNewPos = Singleton<MC>.Inst.GetActiveMap().GetClosestDefaultUnitPositions(Willa.coord).GetCoord();
		Willa.StartMovement(willasNewPos);
		yield return Wait.ForChildren;
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_02", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Open");
		yield return UnitPlayAnimation(Gosz, "CsTransDIdleToTypeIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsTypeIdle");
		Gosz.UpdateIdleAnim();
		CutsceneEnd();
		CutsceneBegin();
		PlayMapAnimation(TestBay.Map, coverAnimator, "Wave1ToWave2");
		SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
		TileBlockDynamic tL2 = TL1;
		blockHeight = TileObjectBase.Height.Full;
		TL3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TL2.BlockHeight = blockHeight;
		tL2.BlockHeight = blockHeight;
		TileBlockDynamic tM2 = TM1;
		blockHeight = TileObjectBase.Height.Full;
		TM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TM2.BlockHeight = blockHeight;
		tM2.BlockHeight = blockHeight;
		TileBlockDynamic tR2 = TR1;
		blockHeight = TileObjectBase.Height.Full;
		TR2.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TR3.BlockHeight = blockHeight;
		tR2.BlockHeight = blockHeight;
		M1.gameObject.SetActive(value: false);
		M2.gameObject.SetActive(value: false);
		M3.gameObject.SetActive(value: false);
		TileBlockDynamic m2 = M1;
		blockHeight = TileObjectBase.Height.Zero;
		M3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		M2.BlockHeight = blockHeight;
		m2.BlockHeight = blockHeight;
		BL1.gameObject.SetActive(value: true);
		BL2.gameObject.SetActive(value: true);
		BL3.gameObject.SetActive(value: true);
		TileBlockDynamic bL2 = BL1;
		blockHeight = TileObjectBase.Height.Full;
		BL3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BL2.BlockHeight = blockHeight;
		bL2.BlockHeight = blockHeight;
		TileBlockDynamic bM2 = BM1;
		blockHeight = TileObjectBase.Height.Full;
		BM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BM2.BlockHeight = blockHeight;
		bM2.BlockHeight = blockHeight;
		TileBlockDynamic bR2 = BR1;
		blockHeight = TileObjectBase.Height.Full;
		BR2.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BR3.BlockHeight = blockHeight;
		bR2.BlockHeight = blockHeight;
		R1.gameObject.SetActive(value: true);
		R2.gameObject.SetActive(value: true);
		R3.gameObject.SetActive(value: true);
		TileBlockDynamic r2 = R1;
		blockHeight = TileObjectBase.Height.Full;
		R3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		R2.BlockHeight = blockHeight;
		r2.BlockHeight = blockHeight;
		CutsceneEnd();
		yield return null;
		MusicSetIntensity(0.1f);
		MusicSetProgress(0.2f);
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		CutsceneBegin();
		UnitMoveToTarget(Droid2A_TB, T_Droid_TB1);
		UnitMoveToTarget(Droid4B_TB, T_Droid_TB9);
		yield return UnitMoveToTarget(Droid2B_TB, T_Droid_TB3);
		DroidDoor2.gameObject.SetActive(value: true);
		DroidDoor3.gameObject.SetActive(value: true);
		DroidDoor1.gameObject.SetActive(value: true);
		yield return null;
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_02", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Close");
		CutsceneEnd();
		while (true)
		{
			if (SaveData.SplitPoint(WavesDialogs.Count > 0, skipOverride: false))
			{
				HagletYieldTerm TurnsPassed2 = TurnModeWaitForPlayerTurnStart((uint)UnityEngine.Random.Range(1, 2));
				yield return CreateOrCondition(CombatWaitUntilComplete(), TurnsPassed2);
				if (SaveData.SplitPoint(TurnsPassed2.met && GC.Inst.IsInTurnMode(), skipOverride: false))
				{
					DialogData Dialog2 = WavesDialogs[UnityEngine.Random.Range(0, WavesDialogs.Count)];
					WavesDialogs.Remove(Dialog2);
					yield return HAGIS.DialogShow(Dialog2);
					continue;
				}
				break;
			}
			yield return CombatWaitUntilComplete();
			break;
		}
		SKIP_POINT("Skipped second test bay fight");
		MusicSetProgress(0.3f);
		CutsceneBegin();
		yield return UnitPlayAnimation(Gosz, "CsTransTypeIdleToDIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UnitPlayAnimation(Gosz, "CsLookAround", loop: false, updateIdle: true);
		DroidDoor1.gameObject.SetActive(value: false);
		DroidDoor2.gameObject.SetActive(value: false);
		DroidDoor3.gameObject.SetActive(value: false);
		DroidDoor4.gameObject.SetActive(value: false);
		Droid3A_TB.Show();
		Droid3B_TB.Show();
		Droid1B_TB.Show();
		Droid5B_TB.Show();
		GC.Inst.GetTeamOfType(UnitTeam.Type.Player).MoveTeamToDefaultPositions();
		v2i willasNewPos2 = Singleton<MC>.Inst.GetActiveMap().GetClosestDefaultUnitPositions(Willa.coord).GetCoord();
		Willa.StartMovement(willasNewPos2);
		yield return Wait.ForChildren;
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_02", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Open");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_04", "Open");
		yield return UnitPlayAnimation(Gosz, "CsTransDIdleToTypeIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsTypeIdle");
		Gosz.UpdateIdleAnim();
		CutsceneEnd();
		CutsceneBegin();
		PlayMapAnimation(TestBay.Map, coverAnimator, "Wave2ToWave3");
		SFXPlay("event:/sfx/script/act 3/a3o4/cover movement");
		TileBlockDynamic tL3 = TL1;
		blockHeight = TileObjectBase.Height.Half;
		TL3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TL2.BlockHeight = blockHeight;
		tL3.BlockHeight = blockHeight;
		TileBlockDynamic tM3 = TM1;
		blockHeight = TileObjectBase.Height.Half;
		TM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TM2.BlockHeight = blockHeight;
		tM3.BlockHeight = blockHeight;
		TileBlockDynamic tR3 = TR1;
		blockHeight = TileObjectBase.Height.Half;
		TR2.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		TR3.BlockHeight = blockHeight;
		tR3.BlockHeight = blockHeight;
		M1.gameObject.SetActive(value: true);
		M2.gameObject.SetActive(value: true);
		M3.gameObject.SetActive(value: true);
		TileBlockDynamic m3 = M1;
		blockHeight = TileObjectBase.Height.Full;
		M3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		M2.BlockHeight = blockHeight;
		m3.BlockHeight = blockHeight;
		TileBlockDynamic bL3 = BL1;
		blockHeight = TileObjectBase.Height.Half;
		BL3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BL2.BlockHeight = blockHeight;
		bL3.BlockHeight = blockHeight;
		TileBlockDynamic bM3 = BM1;
		blockHeight = TileObjectBase.Height.Half;
		BM3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BM2.BlockHeight = blockHeight;
		bM3.BlockHeight = blockHeight;
		TileBlockDynamic bR3 = BR1;
		blockHeight = TileObjectBase.Height.Half;
		BR2.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		BR3.BlockHeight = blockHeight;
		bR3.BlockHeight = blockHeight;
		TileBlockDynamic r3 = R1;
		blockHeight = TileObjectBase.Height.Half;
		R3.BlockHeight = blockHeight;
		blockHeight = blockHeight;
		R2.BlockHeight = blockHeight;
		r3.BlockHeight = blockHeight;
		CutsceneEnd();
		yield return null;
		MusicSetIntensity(0.1f);
		MusicSetProgress(0.4f);
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		CutsceneBegin();
		UnitMoveToTarget(Droid3A_TB, T_Droid_TB5);
		UnitMoveToTarget(Droid3B_TB, T_Droid_TB4);
		UnitMoveToTarget(Droid5B_TB, T_Droid_TB1);
		yield return UnitMoveToTarget(Droid1B_TB, T_Droid_TB2);
		yield return null;
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_01", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_02", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_04", "Close");
		DroidDoor1.gameObject.SetActive(value: true);
		DroidDoor2.gameObject.SetActive(value: true);
		DroidDoor3.gameObject.SetActive(value: true);
		DroidDoor4.gameObject.SetActive(value: true);
		CutsceneEnd();
		while (true)
		{
			if (SaveData.SplitPoint(WavesDialogs.Count > 0, skipOverride: false))
			{
				HagletYieldTerm TurnsPassed3 = TurnModeWaitForPlayerTurnStart((uint)UnityEngine.Random.Range(1, 2));
				yield return CreateOrCondition(CombatWaitUntilComplete(), TurnsPassed3);
				if (SaveData.SplitPoint(TurnsPassed3.met && GC.Inst.IsInTurnMode(), skipOverride: false))
				{
					DialogData Dialog3 = WavesDialogs[UnityEngine.Random.Range(0, WavesDialogs.Count)];
					WavesDialogs.Remove(Dialog3);
					yield return HAGIS.DialogShow(Dialog3);
					continue;
				}
				break;
			}
			yield return CombatWaitUntilComplete();
			break;
		}
		SKIP_POINT("Skipped third test bay fight");
		MusicSetProgress(0.5f);
		DroidDoor1.gameObject.SetActive(value: false);
		DroidDoor2.gameObject.SetActive(value: false);
		DroidDoor3.gameObject.SetActive(value: false);
		DroidDoor4.gameObject.SetActive(value: false);
		yield return CreateAndCondition(UnitTeleportToTarget(Droid4B_TB, T_Droid_TB10), UnitTeleportToTarget(Droid3B_TB, T_Droid_TB7));
		yield return CreateTimeCondition(2f);
		CutsceneBegin();
		yield return UnitPlayAnimation(Gosz, "CsTransTypeIdleToDIdle");
		Gosz.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Gosz.UpdateIdleAnim();
		CutsceneEnd();
		ReviveAndHeal(Droid3B_TB);
		ReviveAndHeal(Droid4B_TB);
		yield return CutscenePlay("A3O4_Cutscene_GoszAxe");
		FMOD.Studio.EventInstance hackingSnap = AC.Inst.PlaySnapshot("snapshot:/duck gosz hacking");
		CutsceneBegin();
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_03", "Close");
		PlayMapAnimation(TestBay.Map, "MA_ChumleysRobotDoors_04", "Close");
		DroidDoor1.gameObject.SetActive(value: true);
		DroidDoor2.gameObject.SetActive(value: true);
		DroidDoor3.gameObject.SetActive(value: true);
		DroidDoor4.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Skipped cutscene in test bay");
		MusicSetProgress(0.6f);
		CombatBegin(UnitTeam.Type.Player);
		yield return null;
		while (true)
		{
			if (SaveData.SplitPoint(CorruptDialogs.Count > 0, skipOverride: false))
			{
				HagletYieldTerm TurnsPassed4 = TurnModeWaitForPlayerTurnStart((uint)UnityEngine.Random.Range(1, 2));
				yield return CreateOrCondition(CombatWaitUntilComplete(), TurnsPassed4);
				if (SaveData.SplitPoint(TurnsPassed4.met && GC.Inst.IsInTurnMode(), skipOverride: false))
				{
					DialogData Dialog4 = CorruptDialogs[UnityEngine.Random.Range(0, CorruptDialogs.Count)];
					CorruptDialogs.Remove(Dialog4);
					yield return HAGIS.DialogShow(Dialog4);
					continue;
				}
				break;
			}
			yield return CombatWaitUntilComplete();
			break;
		}
		AC.Stop(hackingSnap);
		ContolRoomBlock.gameObject.SetActive(value: false);
		yield return null;
		SKIP_POINT("Skipped to last cutscene in test bay");
		MusicStop();
		MusicPlay("event:/music/tracks/bespoke/gosz death");
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		DroidDoor1.gameObject.SetActive(value: false);
		DroidDoor2.gameObject.SetActive(value: false);
		DroidDoor3.gameObject.SetActive(value: false);
		DroidDoor4.gameObject.SetActive(value: false);
		CreateAndCondition(UnitMoveToTarget(Droid2A_TB, T_Droid_TB7), UnitMoveToTarget(Droid4A_TB, T_Droid_TB8), UnitMoveToTarget(Droid3A_TB, T_Droid_TB11));
		UnitMoveToTarget(Droid_CE10, T_Droids_TE4);
		UnitMoveToTarget(Droid_CE11, T_Droids_TE8);
		UnitMoveToTarget(Droid_CE12, T_Droids_TE9);
		UnitMoveToTarget(Droid_CE1, T_Droids_TE7);
		UnitMoveToTarget(Droid_CE2, T_Droids_TE6);
		UnitMoveToTarget(Droid_CE3, T_Droids_TE5);
		Droid2A_TB.SetTeamType(UnitTeam.Type.NPC);
		Droid3A_TB.SetTeamType(UnitTeam.Type.NPC);
		Droid4A_TB.SetTeamType(UnitTeam.Type.NPC);
		UIObjectives.Inst.CompleteObjective(objProtectGosz);
		yield return null;
		Droid2A_TB.HPRefill();
		Droid3A_TB.HPRefill();
		Droid4A_TB.HPRefill();
		yield return CutscenePlay("A3O4_Cutscene_RunForYorLife");
		CutsceneBegin();
		PlayMapAnimation(ChumExterior.Map, "MA_ChumleysFactoryExterior_LoadingBayDoor_01", "Open");
		SKIP_POINT("Heading to ChumExterior");
		Willa.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		yield return MapGoto(ChumExterior);
		SFXPlay("event:/sfx/script/act 3/a3o4/ae_explosion distant");
		I_DoorCE.gameObject.SetActive(value: false);
		Droid_CE10.Show();
		Droid_CE11.Show();
		Droid_CE12.Show();
		Droid_CE1.Show();
		Droid_CE2.Show();
		Droid_CE3.Show();
		yield return CreateAndCondition(UnitMoveToTarget(Droid_CE1, T_Droids_TE1), UnitMoveToTarget(Droid_CE2, T_Droids_TE2), UnitMoveToTarget(Droid_CE3, T_Droids_TE3));
		Droid_CE1.Hide(makeInactive: true);
		Droid_CE2.Hide(makeInactive: true);
		Droid_CE3.Hide(makeInactive: true);
		yield return CreateAndCondition(UnitMoveToTarget(Droid_CE10, T_Droids_TE1), UnitMoveToTarget(Droid_CE11, T_Droids_TE2), UnitMoveToTarget(Droid_CE12, T_Droids_TE3));
		Droid_CE10.Hide(makeInactive: true);
		Droid_CE11.Hide(makeInactive: true);
		Droid_CE12.Hide(makeInactive: true);
		yield return CreateTimeCondition(1f);
		PlayMapAnimation(ChumExterior.Map, "MA_ChumleysFactoryExterior_LoadingBayDoor_01", "Close");
		Archi.gameObject.SetActive(value: true);
		Margot.gameObject.SetActive(value: true);
		yield return null;
		yield return CreateAndCondition(UnitMoveToMapViaExitTile(Archi, ChumExToSkyway, T_ArchiMovesFromDoor), UnitMoveToMapViaExitTile(Margot, ChumExToSkyway, T_MargotMovesFromDoor));
		UnitLookInDirection(Archi, OctDir.Up);
		UnitLookInDirection(Margot, OctDir.Up);
		yield return null;
		Willa.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		SKIP_POINT("Skipped to outside Chums");
		Droid_CE10.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid_CE11.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid_CE12.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid_CE1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid_CE2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid_CE3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		CutsceneBegin();
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Archi.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Margot.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultWalk);
		yield return CreateTimeCondition(1f);
		NPC1.gameObject.SetActive(value: false);
		NPC2.gameObject.SetActive(value: false);
		NPC4.gameObject.SetActive(value: false);
		NPC5.gameObject.SetActive(value: false);
		NPC6.gameObject.SetActive(value: false);
		D_SkywayMiddleman.gameObject.SetActive(value: false);
		ShockedNPC3.gameObject.SetActive(value: true);
		ShockedNPC7.gameObject.SetActive(value: true);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Willa.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Willa, T_Gosz_CE);
		UnitLookInDirection(Willa, OctDir.UpLeft);
		yield return CreateTimeCondition(2f);
		yield return UnitMoveToMapViaExitTile(Willa, ChumExToSkyway);
		MusicStop();
		yield return MapGoto(Skyway.Map);
		SKIP_POINT("Skipped to getting on the skyway");
		Willa.LookInDirection(OctDir.Down);
		yield return UnitMoveToTarget(Willa, T_WillaMovesFromDoor, OctDir.Down);
		yield return UnitPlayAnimation(Willa, "TransCIdleToDIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.UpdateIdleAnim();
		yield return null;
		yield return HAGIS.DialogShow(Dialog_IsAlexOK);
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToDefeated");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		yield return UnitPlayAnimation(Willa, "CsDefaultDefeated");
		CutsceneEnd();
	}
}
public class Hagis_A3O5 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Chris;

	private Unit Ambrosia;

	private Unit Margot;

	private Unit Noot;

	private Unit Molly;

	private Unit Martinez;

	private Unit Su;

	private Unit Holden;

	private Unit CompilerGoon1;

	private Unit CompilerGoon2;

	private Unit CompilerGoon3;

	private Unit GraveCrow;

	private Unit BattleDroid1;

	private Unit BattleDroid2;

	private Unit Fam1Male;

	private Unit Fam1Female;

	private Unit Fam1Child;

	private Unit Fam2Female;

	private Unit Fam2Child1;

	private Unit Fam2Child2;

	private Unit David;

	private Unit BattleDroid3;

	private Unit BattleDroid4;

	private Unit BattleDroid5;

	private Unit BattleDroid6;

	private Unit BettleDroid7;

	private Unit UnderclockGoon;

	private Unit BattleDroid11;

	private Unit BattelDroid12;

	private Unit BattelDroid13;

	private Unit BattelDroid14;

	private Unit BattelDroid15;

	private Unit BattelDroid16;

	private Unit BattelDroid17;

	private Unit AdultNPC1;

	private Unit AdultNPC2;

	private Unit AdultNPC3;

	private Unit AdultNPC4;

	private Unit ChildNPC1;

	private Unit ChildNPC2;

	private Unit ChumleyDroid2;

	private Unit ChumleyDroid4;

	private Unit ChumleyDroid6;

	private UnitTarget MoveToExit;

	private UnitTarget ChrisIdlePoint;

	private UnitTarget AmbrosiaIdlePoint;

	private UnitTarget ChrisMoveTo;

	private UnitTarget AmbrosiaMoveTo;

	private UnitTarget chrisIdlePoint1;

	private UnitTarget AmbrosiaIdlePoint1;

	private UnitTarget CoverPoint1;

	private UnitTarget CoverPoint2;

	private UnitTarget CoverPoint3;

	private UnitTarget HoldenMoveTo;

	private UnitTarget GoonPoint1;

	private UnitTarget GoonPoint2;

	private UnitTarget GoonPoint3;

	private UnitTarget HoldenCover;

	private UnitTarget PostFightTarget;

	private UnitTarget PostFightTarget2;

	private UnitTarget PostFightTarget3;

	private UnitTarget CoverPoint4;

	private UnitTarget CoverPoint5;

	private UnitTarget CoverPoint6;

	private UnitTarget CoverChris;

	private UnitTarget CoverWilla;

	private UnitTarget T_DavidRunsOff;

	private UnitTarget MollyMoveToPoint;

	private UnitTarget ChrisMoveToPoint;

	private UnitTarget AmbrosiaMoveToPoint;

	private UnitTarget MoveToCarriage;

	private UnitTarget MollyMovetoSub;

	private UnitTarget ChrisSubwayCover;

	private UnitTarget WillaSubwayCover;

	private UnitTarget AmbrosiaSubwayCover;

	private UnitTarget CoverPoint7;

	private UnitTarget CoverPoint8;

	private UnitTarget CoverPoint9;

	private UnitTarget WillaMoveTo;

	private UnitTarget MollyMoveTo;

	private UnitTarget DroidApproachesMolly;

	private UnitTarget DroidRunFromGrenade1;

	private UnitTarget DroidMoveToCover;

	private UnitTarget DroidRunFromGrenade2;

	private UnitTarget DroidMoveToCover2;

	private UnitTarget PostFight1;

	private UnitTarget PostFight2;

	private UnitTarget MollyLeaves;

	private UnitTarget WillaIdle;

	private UnitTarget MollyIdle;

	private UnitTarget ChrisMoveToHara;

	private UnitTarget AmbrosiaMoveToHara;

	private UnitTarget WillaPostFight;

	private UnitTarget MollyPostFight;

	private UnitTarget ChrisPostFight;

	private UnitTarget AmbrosiaPostFight;

	private UnitTarget T_ArchiSpawn;

	private UnitTarget T_NootSpawn;

	private UnitTarget T_MargotSpawn;

	private UnitTarget T_ChrisIdle;

	private UnitTarget T_AmbrosiaIdle;

	private UnitTarget T_SkidsCover;

	private UnitTarget T_SkidsCover2;

	private UnitTarget T_SkidsCover3;

	private UnitTarget T_DroidEntryPoint;

	private UnitTarget T_DroidEntryPoint2;

	private UnitTarget T_DroidEntryPoint3;

	private UnitTarget T_WillaToElevator;

	private UnitTarget T_ChrisToWilla;

	private UnitTarget T_AmbroToWilla;

	private UnitTarget T_ArchiToWilla;

	private UnitTarget T_MargotToWilla;

	private UnitTarget T_NootToWilla;

	private UnitTarget T_DroidsSurround2;

	private UnitTarget T_DroidsSurround3;

	private UnitTarget T_DroidsSurround6;

	private UnitTarget T_TeamGather1;

	private UnitTarget T_TeamGather2;

	private UnitTarget T_TeamGather3;

	private UnitTarget T_TeamGather4;

	private UnitTarget T_TeamGather5;

	private UnitTarget T_WillaWalksTowardsElevator;

	private UnitTarget T_ArchiStepsForward;

	private TileActionSwapMap ToUnderClockStationEXT2;

	private TileActionSwapMap FromSkyway;

	private TileActionSwapMap ToUnderclockMeetingRoom;

	private TileActionSwapMap FromStationEXT;

	private TileActionSwapMap ToElevator;

	private TileActionSwapMap ToGraveyard;

	private TileActionSwapMap FromElevator;

	private TileActionSwapMap ToPark;

	private TileActionSwapMap FromGraveyard;

	private TileActionSwapMap ToFiles;

	private TileActionSwapMap FromPark;

	private TileActionSwapMap ToAndroidServicing;

	private TileActionSwapMap FromFiles;

	private TileActionSwapMap ToSubwayStation;

	private TileActionSwapMap FromFilesToStation;

	private TileActionSwapMap ToSubwayCarriage;

	private TileActionSwapMap FromFilesStation;

	private TileActionSwapMap ToPortHaraStation;

	private TileActionSwapMap FromPortStation;

	private TileActionSwapMap ToSkids;

	private TileActionSwapMap FromPortHara;

	private TileActionSwapMap ToPortHaraEntrance;

	private TileActionSwapMap ElevatorToMeetingRoom;

	private TileActionInteraction I_TalkedToDavid;

	private TileActionInteraction ToSubwayCarriageInteraction;

	private TileActionInteraction I_Elevator;

	private TileActionDialog SuAndMartinez1;

	private TileActionDialog SuAndMartinez2;

	private TileActionDialog HoldenDeath;

	private TileActionDialog NotThatWay;

	private TileActionDialog D_ThoseRobots;

	private TileActionDialog D_WheresDavid;

	private TileActionDialog D_Archi;

	private TileActionDialog D_Ambrosia;

	private TileActionDialog D_Chris;

	private TileActionDialog D_Margot;

	private TileActionDialog D_Noot;

	private DialogData Ambient_BeSafe;

	private DialogData Dialog_DidntSoundOKay;

	private DialogData Dialog_HeadSouthEast;

	private DialogData Dialog_TheresAProblem;

	private DialogData Dialog_TimeToWaste;

	private DialogData Dialog_HeadSouth;

	private DialogData Dialog_WhoAreYou;

	private DialogData Dialog_WeShouldExplain;

	private DialogData Dialog_ComeToFinishMeOff;

	private DialogData Dialog_DammitWeDontHaveTime;

	private DialogData Dialog_HaSucker;

	private DialogData Dialog_HehIdiot;

	private DialogData Dialog_HereLiesHolden;

	private DialogData Dialog_IdLikeToTake;

	private DialogData Ambient_ResistanceWillBeMet;

	private DialogData Dialog_IllegalBioelectric;

	private DialogData Ambient_CriticalSystemError;

	private DialogData Dialog_HowManyOfThose;

	private DialogData Dialog_Willa;

	private DialogData Dialog_ICouldMakeMore;

	private DialogData Dialog_MissingDavid;

	private DialogData Ambient_SoFarSoGood;

	private DialogData Ambient_CoolHair;

	private DialogData Ambient_WillaThanks;

	private DialogData Ambient_WeGottaClearRoute;

	private DialogData Ambient_ItsSafeGo;

	private DialogData Dialog_ComeWithMe;

	private DialogData Dialog_NowMolly;

	private DialogData Dialog_SixYearsInRepair;

	private DialogData Dialog_WhatSize;

	private DialogData Dialog_SkidsGo;

	private DialogData Dialog_Incoming;

	private DialogData Ambient_HaveToBeThisWay;

	private DialogData Ambient_Willa;

	private DialogData Dialog_WereYouFollowed;

	private DialogData Dialog_YeahYou;

	private DialogData Dialog_ICanFixThis;

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = 2f;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot UnderclockPoliceStation = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclockMeetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		LogicRoot Elevator = GetLogicUsingArtName("T2ClocktowerElevator");
		LogicRoot Graveyard = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot DetritumPark = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot AndroidServicing = GetLogicUsingArtName("T1AndroidServicing");
		LogicRoot SubwayStation = GetLogicUsingArtName("T1Subway_Station_Files");
		LogicRoot SubwayCarriage = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot PortHaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot Skids = GetLogicUsingArtName("T1TheSkids");
		Willa = GC.Inst.GetUnitWithId("C8A_T2Skyway_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("4CB_T2Skyway_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("D0A_T2Skyway_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("516_T2Skyway_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("2DF_T2Skyway_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("05A_T2Skyway_UnitSpawn");
		Molly = GC.Inst.GetUnitWithId("09F_T1AndroidServicing_UnitSpawn");
		GraveCrow = GC.Inst.TryGetUnitWithId("F73_T1DetritumGraveyard_UnitSpawn");
		Martinez = GC.Inst.GetUnitWithId("257_T2UnderclockMeetingRoom_UnitSpawn");
		Su = GC.Inst.GetUnitWithId("FFD_T2UnderclockMeetingRoom_UnitSpawn");
		Holden = GC.Inst.GetUnitWithId("C36_T1DetritumGraveyard_UnitSpawn");
		CompilerGoon1 = GC.Inst.GetUnitWithId("FAF_T1DetritumGraveyard_UnitSpawn");
		CompilerGoon2 = GC.Inst.GetUnitWithId("852_T1DetritumGraveyard_UnitSpawn");
		CompilerGoon3 = GC.Inst.GetUnitWithId("51C_T1DetritumGraveyard_UnitSpawn");
		BattleDroid1 = GC.Inst.GetUnitWithId("60B_T1TheFiles_UnitSpawn");
		BattleDroid2 = GC.Inst.GetUnitWithId("BC4_T1TheFiles_UnitSpawn");
		Fam1Male = GC.Inst.GetUnitWithId("E2B_T1TheFiles_UnitSpawn");
		Fam1Female = GC.Inst.GetUnitWithId("3B4_T1TheFiles_UnitSpawn");
		Fam1Child = GC.Inst.GetUnitWithId("A3C_T1TheFiles_UnitSpawn");
		Fam2Female = GC.Inst.GetUnitWithId("DA1_T1TheFiles_UnitSpawn");
		Fam2Child1 = GC.Inst.GetUnitWithId("5A9_T1TheFiles_UnitSpawn");
		Fam2Child2 = GC.Inst.GetUnitWithId("723_T1TheFiles_UnitSpawn");
		David = GC.Inst.GetUnitWithId("DB7_T1Subway_Station_Files_UnitSpawn");
		BattleDroid3 = GC.Inst.GetUnitWithId("858_T1AndroidServicing_UnitSpawn");
		BattleDroid4 = GC.Inst.GetUnitWithId("444_T1AndroidServicing_UnitSpawn");
		BattleDroid5 = GC.Inst.GetUnitWithId("134_T1AndroidServicing_UnitSpawn");
		BattleDroid6 = GC.Inst.GetUnitWithId("1A4_T1Subway_TrainInterior_UnitSpawn");
		BettleDroid7 = GC.Inst.GetUnitWithId("CB6_T1Subway_TrainInterior_UnitSpawn");
		UnderclockGoon = GC.Inst.GetUnitWithId("F6E_T1Subway_TrainInterior_UnitSpawn");
		BattleDroid11 = GC.Inst.GetUnitWithId("4BA_T1Port1_HaraEntrance_UnitSpawn");
		BattelDroid12 = GC.Inst.GetUnitWithId("F99_T1Port1_HaraEntrance_UnitSpawn");
		ChumleyDroid2 = GC.Inst.GetUnitWithId("65F_T1TheSkids_UnitSpawn");
		ChumleyDroid4 = GC.Inst.GetUnitWithId("135_T1TheSkids_UnitSpawn");
		ChumleyDroid6 = GC.Inst.GetUnitWithId("101_T1TheSkids_UnitSpawn");
		BattelDroid13 = GC.Inst.GetUnitWithId("A40_T1Port1_HaraEntrance_UnitSpawn");
		BattelDroid14 = GC.Inst.GetUnitWithId("A04_T1Port1_HaraEntrance_UnitSpawn");
		BattelDroid15 = GC.Inst.GetUnitWithId("E3B_T1Port1_HaraEntrance_UnitSpawn");
		BattelDroid16 = GC.Inst.GetUnitWithId("BBE_T1TheSkids_UnitSpawn");
		BattelDroid17 = GC.Inst.GetUnitWithId("EA2_T1TheSkids_UnitSpawn");
		MoveToExit = MR.Inst.GetUnitTarget("D9C_T2Skyway_UnitTarget");
		ChrisIdlePoint = MR.Inst.GetUnitTarget("7A7_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		AmbrosiaIdlePoint = MR.Inst.GetUnitTarget("CEF_T2UnderclocksPoliceStation_Exterior_UnitTarget");
		chrisIdlePoint1 = MR.Inst.GetUnitTarget("E54_T2ClocktowerElevator_UnitTarget");
		AmbrosiaIdlePoint1 = MR.Inst.GetUnitTarget("8C9_T2ClocktowerElevator_UnitTarget");
		CoverPoint1 = MR.Inst.GetUnitTarget("3D3_T1DetritumGraveyard_UnitTarget");
		CoverPoint2 = MR.Inst.GetUnitTarget("B1B_T1DetritumGraveyard_UnitTarget");
		CoverPoint3 = MR.Inst.GetUnitTarget("5D8_T1DetritumGraveyard_UnitTarget");
		HoldenMoveTo = MR.Inst.GetUnitTarget("DB9_T1DetritumGraveyard_UnitTarget");
		GoonPoint1 = MR.Inst.GetUnitTarget("B4A_T1DetritumGraveyard_UnitTarget");
		GoonPoint2 = MR.Inst.GetUnitTarget("CC2_T1DetritumGraveyard_UnitTarget");
		GoonPoint3 = MR.Inst.GetUnitTarget("5D5_T1DetritumGraveyard_UnitTarget");
		HoldenCover = MR.Inst.GetUnitTarget("04B_T1DetritumGraveyard_UnitTarget");
		PostFightTarget = MR.Inst.GetUnitTarget("D75_T1DetritumGraveyard_UnitTarget");
		PostFightTarget2 = MR.Inst.GetUnitTarget("42A_T1DetritumGraveyard_UnitTarget");
		PostFightTarget3 = MR.Inst.GetUnitTarget("DA7_T1DetritumGraveyard_UnitTarget");
		CoverPoint4 = MR.Inst.GetUnitTarget("B69_T1TheFiles_UnitTarget");
		CoverPoint5 = MR.Inst.GetUnitTarget("747_T1TheFiles_UnitTarget");
		CoverPoint6 = MR.Inst.GetUnitTarget("CF0_T1TheFiles_UnitTarget");
		CoverChris = MR.Inst.GetUnitTarget("DC6_T1TheFiles_UnitTarget");
		CoverWilla = MR.Inst.GetUnitTarget("774_T1TheFiles_UnitTarget");
		T_DavidRunsOff = MR.Inst.GetUnitTarget("C57_T1Subway_Station_Files_UnitTarget");
		ChrisMoveTo = MR.Inst.GetUnitTarget("622_T2UnderclockMeetingRoom_UnitTarget");
		AmbrosiaMoveTo = MR.Inst.GetUnitTarget("4FE_T2UnderclockMeetingRoom_UnitTarget");
		CoverPoint7 = MR.Inst.GetUnitTarget("DE7_T1AndroidServicing_UnitTarget");
		CoverPoint8 = MR.Inst.GetUnitTarget("52C_T1AndroidServicing_UnitTarget");
		CoverPoint9 = MR.Inst.GetUnitTarget("74E_T1AndroidServicing_UnitTarget");
		WillaMoveTo = MR.Inst.GetUnitTarget("B7D_T1AndroidServicing_UnitTarget");
		MollyMoveTo = MR.Inst.GetUnitTarget("EA0_T1AndroidServicing_UnitTarget");
		DroidApproachesMolly = MR.Inst.GetUnitTarget("C14_T1AndroidServicing_UnitTarget");
		DroidRunFromGrenade1 = MR.Inst.GetUnitTarget("811_T1AndroidServicing_UnitTarget");
		DroidRunFromGrenade2 = MR.Inst.GetUnitTarget("F5D_T1AndroidServicing_UnitTarget");
		DroidMoveToCover = MR.Inst.GetUnitTarget("654_T1AndroidServicing_UnitTarget");
		DroidMoveToCover2 = MR.Inst.GetUnitTarget("C13_T1AndroidServicing_UnitTarget");
		PostFight1 = MR.Inst.GetUnitTarget("62F_T1AndroidServicing_UnitTarget");
		PostFight2 = MR.Inst.GetUnitTarget("D26_T1AndroidServicing_UnitTarget");
		MollyMoveToPoint = MR.Inst.GetUnitTarget("224_T1Subway_Station_Files_UnitTarget");
		ChrisMoveToPoint = MR.Inst.GetUnitTarget("7A8_T1Subway_Station_Files_UnitTarget");
		AmbrosiaMoveToPoint = MR.Inst.GetUnitTarget("AC3_T1Subway_Station_Files_UnitTarget");
		MoveToCarriage = MR.Inst.GetUnitTarget("07E_T1Subway_Station_Files_UnitTarget");
		MollyMovetoSub = MR.Inst.GetUnitTarget("3B3_T1Subway_TrainInterior_UnitTarget");
		ChrisSubwayCover = MR.Inst.GetUnitTarget("53E_T1Subway_TrainInterior_UnitTarget");
		WillaSubwayCover = MR.Inst.GetUnitTarget("B12_T1Subway_TrainInterior_UnitTarget");
		AmbrosiaSubwayCover = MR.Inst.GetUnitTarget("A0B_T1Subway_TrainInterior_UnitTarget");
		MollyLeaves = MR.Inst.GetUnitTarget("701_T1Port1_HaraEntrance_UnitTarget");
		WillaIdle = MR.Inst.GetUnitTarget("E16_T1Port1_HaraEntrance_UnitTarget");
		MollyIdle = MR.Inst.GetUnitTarget("433_T1Port1_HaraEntrance_UnitTarget");
		ChrisMoveToHara = MR.Inst.GetUnitTarget("CDA_T1Port1_HaraEntrance_UnitTarget");
		AmbrosiaMoveToHara = MR.Inst.GetUnitTarget("485_T1Port1_HaraEntrance_UnitTarget");
		WillaPostFight = MR.Inst.GetUnitTarget("B0F_T1Port1_HaraEntrance_UnitTarget");
		MollyPostFight = MR.Inst.GetUnitTarget("DED_T1Port1_HaraEntrance_UnitTarget");
		ChrisPostFight = MR.Inst.GetUnitTarget("C95_T1Port1_HaraEntrance_UnitTarget");
		AmbrosiaPostFight = MR.Inst.GetUnitTarget("719_T1Port1_HaraEntrance_UnitTarget");
		T_ArchiSpawn = MR.Inst.GetUnitTarget("75B_T1TheSkids_UnitTarget");
		T_NootSpawn = MR.Inst.GetUnitTarget("F52_T1TheSkids_UnitTarget");
		T_MargotSpawn = MR.Inst.GetUnitTarget("873_T1TheSkids_UnitTarget");
		T_ChrisIdle = MR.Inst.GetUnitTarget("C18_T1TheSkids_UnitTarget");
		T_AmbrosiaIdle = MR.Inst.GetUnitTarget("8CD_T1TheSkids_UnitTarget");
		T_SkidsCover = MR.Inst.GetUnitTarget("C10_T1TheSkids_UnitTarget");
		T_SkidsCover2 = MR.Inst.GetUnitTarget("AAD_T1TheSkids_UnitTarget");
		T_SkidsCover3 = MR.Inst.GetUnitTarget("919_T1TheSkids_UnitTarget");
		T_WillaToElevator = MR.Inst.GetUnitTarget("D2D_T1TheSkids_UnitTarget");
		T_ChrisToWilla = MR.Inst.GetUnitTarget("001_T1TheSkids_UnitTarget");
		T_AmbroToWilla = MR.Inst.GetUnitTarget("11D_T1TheSkids_UnitTarget");
		T_ArchiToWilla = MR.Inst.GetUnitTarget("EA1_T1TheSkids_UnitTarget");
		T_MargotToWilla = MR.Inst.GetUnitTarget("074_T1TheSkids_UnitTarget");
		T_NootToWilla = MR.Inst.GetUnitTarget("C25_T1TheSkids_UnitTarget");
		T_DroidEntryPoint = MR.Inst.GetUnitTarget("C17_T1TheSkids_UnitTarget");
		T_DroidEntryPoint2 = MR.Inst.GetUnitTarget("B6D_T1TheSkids_UnitTarget");
		T_DroidEntryPoint3 = MR.Inst.GetUnitTarget("565_T1TheSkids_UnitTarget");
		T_DroidsSurround2 = MR.Inst.GetUnitTarget("199_T1TheSkids_UnitTarget");
		T_DroidsSurround3 = MR.Inst.GetUnitTarget("B89_T1TheSkids_UnitTarget");
		T_DroidsSurround6 = MR.Inst.GetUnitTarget("476_T1TheSkids_UnitTarget");
		T_TeamGather1 = MR.Inst.GetUnitTarget("77B_T1TheSkids_UnitTarget");
		T_TeamGather2 = MR.Inst.GetUnitTarget("FBB_T1TheSkids_UnitTarget");
		T_TeamGather3 = MR.Inst.GetUnitTarget("FD4_T1TheSkids_UnitTarget");
		T_TeamGather4 = MR.Inst.GetUnitTarget("678_T1TheSkids_UnitTarget");
		T_TeamGather5 = MR.Inst.GetUnitTarget("64B_T1TheSkids_UnitTarget");
		T_WillaWalksTowardsElevator = MR.Inst.GetUnitTarget("FAD_T1TheSkids_UnitTarget");
		T_ArchiStepsForward = MR.Inst.GetUnitTarget("029_T1TheSkids_UnitTarget");
		ToUnderClockStationEXT2 = MR.Inst.GetTileActionSwapMap("C0E_T2Skyway_TileActionSwapMap");
		FromSkyway = MR.Inst.GetTileActionSwapMap("DA6_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		ToUnderclockMeetingRoom = MR.Inst.GetTileActionSwapMap("E29_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		FromStationEXT = MR.Inst.GetTileActionSwapMap("F41_T2UnderclockMeetingRoom_TileActionSwapMap");
		ToElevator = MR.Inst.GetTileActionSwapMap("109_T2UnderclockMeetingRoom_TileActionSwapMap");
		ToGraveyard = MR.Inst.GetTileActionSwapMap("F7F_T2ClocktowerElevator_TileActionSwapMap");
		FromElevator = MR.Inst.GetTileActionSwapMap("7FD_T1DetritumGraveyard_TileActionSwapMap");
		ToPark = MR.Inst.GetTileActionSwapMap("D83_T1DetritumGraveyard_TileActionSwapMap");
		FromGraveyard = MR.Inst.GetTileActionSwapMap("9F1_T1DetritumPark_TileActionSwapMap");
		ToFiles = MR.Inst.GetTileActionSwapMap("0D5_T1DetritumPark_TileActionSwapMap");
		FromPark = MR.Inst.GetTileActionSwapMap("858_T1TheFiles_TileActionSwapMap");
		ToAndroidServicing = MR.Inst.GetTileActionSwapMap("887_T1TheFiles_TileActionSwapMap");
		ToSubwayStation = MR.Inst.GetTileActionSwapMap("CB6_T1TheFiles_TileActionSwapMap");
		FromFiles = MR.Inst.GetTileActionSwapMap("345_T1AndroidServicing_TileActionSwapMap");
		ElevatorToMeetingRoom = MR.Inst.GetTileActionSwapMap("EFA_T1FreightElevator_TileActionSwapMap");
		FromFilesToStation = MR.Inst.GetTileActionSwapMap("22A_T1Subway_Station_Files_TileActionSwapMap");
		ToSubwayCarriage = MR.Inst.GetTileActionSwapMap("176_T1Subway_Station_Files_TileActionSwapMap");
		FromFilesStation = MR.Inst.GetTileActionSwapMap("AA1_T1Subway_TrainInterior_TileActionSwapMap");
		ToPortHaraStation = MR.Inst.GetTileActionSwapMap("D9A_T1Subway_TrainInterior_TileActionSwapMap");
		ToPortHaraEntrance = MR.Inst.GetTileActionSwapMap("D9A_T1Subway_TrainInterior_TileActionSwapMap");
		FromPortStation = MR.Inst.GetTileActionSwapMap("A33_T1Port1_HaraEntrance_TileActionSwapMap");
		ToSkids = MR.Inst.GetTileActionSwapMap("F3D_T1Port1_HaraEntrance_TileActionSwapMap");
		FromPortHara = MR.Inst.GetTileActionSwapMap("303_T1TheSkids_TileActionSwapMap");
		ToSubwayCarriageInteraction = MR.Inst.GetTileActionInteraction("F75_T1Subway_Station_Files_TileActionInteraction");
		I_TalkedToDavid = MR.Inst.GetTileActionInteraction("F69_T1Subway_Station_Files_TileActionInteraction");
		I_Elevator = MR.Inst.GetTileActionInteraction("E4D_T1TheSkids_TileActionInteraction");
		SuAndMartinez1 = MR.Inst.GetTileActionDialog("40F_T2UnderclockMeetingRoom_TileActionDialog");
		SuAndMartinez2 = MR.Inst.GetTileActionDialog("D21_T2UnderclockMeetingRoom_TileActionDialog");
		HoldenDeath = MR.Inst.GetTileActionDialog("615_T1DetritumGraveyard_TileActionDialog");
		NotThatWay = MR.Inst.GetTileActionDialog("61D_T1Port1_HaraEntrance_TileActionDialog");
		D_ThoseRobots = MR.Inst.GetTileActionDialog("A0D_T1TheFiles_TileActionDialog");
		D_WheresDavid = MR.Inst.GetTileActionDialog("98B_T1TheFiles_TileActionDialog");
		D_Archi = MR.Inst.GetTileActionDialog("B51_T1TheSkids_TileActionDialog");
		D_Ambrosia = MR.Inst.GetTileActionDialog("2CE_T1TheSkids_TileActionDialog");
		D_Chris = MR.Inst.GetTileActionDialog("786_T1TheSkids_TileActionDialog");
		D_Margot = MR.Inst.GetTileActionDialog("E52_T1TheSkids_TileActionDialog");
		D_Noot = MR.Inst.GetTileActionDialog("CF3_T1TheSkids_TileActionDialog");
		TileBlockDynamic Dynamicblock = MR.Inst.GetTileBlockDynamic("366_T1DetritumGraveyard_TileBlockDynamic");
		Ability_MaxHP HoldenHP = Holden.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		HoldenHP.SetHPMod(6);
		Ability_Covering_Fire CompilerGoon1SupFire = CompilerGoon1.abilities.AbilityGetByType<Ability_Covering_Fire>(CompilerGoon1);
		if (CompilerGoon1SupFire != null)
		{
			CompilerGoon1SupFire.Enabled = false;
		}
		Ambient_BeSafe = HAGIS.DialogLoad("Dialogs/A3O5/Skyway/Ambient_BeSafe");
		Dialog_DidntSoundOKay = HAGIS.DialogLoad("Dialogs/A3O5/Skyway/Dialog_DidntSoundOkay");
		Dialog_HeadSouthEast = HAGIS.DialogLoad("Dialogs/A3O5/Skyway/Dialog_HeadSouthEast");
		Dialog_TheresAProblem = HAGIS.DialogLoad("Dialogs/A3O5/Skyway/Dialog_TheresAProblem");
		Dialog_TimeToWaste = HAGIS.DialogLoad("Dialogs/A3O5/UnderclockStationExterior/Dialog_TimeToWaste");
		Dialog_HeadSouth = HAGIS.DialogLoad("Dialogs/A3O5/UnderclockMeetingRoom/Dialog_HeadSouth");
		Dialog_WhoAreYou = HAGIS.DialogLoad("Dialogs/A3O5/UnderclockMeetingRoom/Dialog_WhoAreYou");
		Dialog_WeShouldExplain = HAGIS.DialogLoad("Dialogs/A3O5/Elevator/Dialog_WeShouldExplain");
		Dialog_ComeToFinishMeOff = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_ComeToFinishMeOff");
		Dialog_DammitWeDontHaveTime = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_DammitWeDontHaveTime");
		Dialog_HaSucker = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_HaSucker");
		Dialog_HehIdiot = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_HehIdiot");
		Dialog_HereLiesHolden = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_HereLiesHolden");
		Dialog_IdLikeToTake = HAGIS.DialogLoad("Dialogs/A3O5/Graveyard/Dialog_IdLikeToTake");
		Ambient_ResistanceWillBeMet = HAGIS.DialogLoad("Dialogs/A3O5/TheFiles/Ambient_ResistanceWillBeMet");
		Dialog_IllegalBioelectric = HAGIS.DialogLoad("Dialogs/A3O5/TheFiles/Dialog_IllegalBioelectric");
		Ambient_CriticalSystemError = HAGIS.DialogLoad("Dialogs/A3O5/RocketScienceAndroidServicing/Ambient_CriticalSystemError");
		Dialog_HowManyOfThose = HAGIS.DialogLoad("Dialogs/A3O5/RocketScienceAndroidServicing/Dialog_HowManyOfThose");
		Dialog_Willa = HAGIS.DialogLoad("Dialogs/A3O5/RocketScienceAndroidServicing/Dialog_Willa");
		Dialog_ICouldMakeMore = HAGIS.DialogLoad("Dialogs/A3O5/RocketScienceAndroidServicing/Dialog_ICouldMakeMore");
		Ambient_SoFarSoGood = HAGIS.DialogLoad("Dialogs/A3O5/SubwayStationFiles/Ambient_SoFarSoGood");
		Ambient_CoolHair = HAGIS.DialogLoad("Dialogs/A3O5/SubwayStationFiles/Ambient_CoolHair");
		Ambient_WillaThanks = HAGIS.DialogLoad("Dialogs/A3O5/SubwayStationFiles/Ambient_WillaThanks");
		Dialog_MissingDavid = HAGIS.DialogLoad("Dialogs/A3O5/SubwayStationFiles/Dialog_MissingDavid");
		Ambient_WeGottaClearRoute = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Ambient_WeGottaClearRoute");
		Ambient_ItsSafeGo = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Ambient_ItsSafeGo");
		Dialog_ComeWithMe = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_ComeWithMe");
		Dialog_NowMolly = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_NowMolly");
		Dialog_SixYearsInRepair = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_SixYearsInRepair");
		Dialog_WhatSize = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_WhatSize");
		Dialog_SkidsGo = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_SkidsGo");
		Dialog_Incoming = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Dialog_Incoming");
		Ambient_HaveToBeThisWay = HAGIS.DialogLoad("Dialogs/A3O5/Skids/Ambient_HaveToBeThisWay");
		Dialog_WereYouFollowed = HAGIS.DialogLoad("Dialogs/A3O5/Skids/Dialog_WereYouFollowed");
		Dialog_YeahYou = HAGIS.DialogLoad("Dialogs/A3O5/Skids/Dialog_YeahYou");
		Dialog_ICanFixThis = HAGIS.DialogLoad("Dialogs/A3O5/Skids/Dialog_ICanFixThis");
		Ambient_Willa = HAGIS.DialogLoad("Dialogs/A3O5/Skids/Ambient_Willa");
		string objFindMolly = "OBJECTIVES_A3O5_01";
		string objProtectMolly = "OBJECTIVES_A3O5_02";
		string objEscortMollyToPortHara = "OBJECTIVES_A3O5_03";
		string objGetToSkids = "OBJECTIVES_A3O5_04";
		string objDefend = "OBJECTIVES_A3O5_05";
		string objFindTheElevator = "OBJECTIVES_A3O5_06";
		elevatorWalls = Elevator.Map.GetComponentInChildren<ScrollingWalls>();
		GraveCrow.unitModel.BlobShadow.gameObject.SetActive(value: false);
		ToUnderClockStationEXT2.gameObject.SetActive(value: false);
		FromSkyway.gameObject.SetActive(value: false);
		ToUnderclockMeetingRoom.gameObject.SetActive(value: false);
		FromStationEXT.gameObject.SetActive(value: false);
		ToElevator.gameObject.SetActive(value: false);
		ToGraveyard.gameObject.SetActive(value: false);
		FromElevator.gameObject.SetActive(value: false);
		ToPark.gameObject.SetActive(value: false);
		FromGraveyard.gameObject.SetActive(value: false);
		ToFiles.gameObject.SetActive(value: false);
		FromPark.gameObject.SetActive(value: false);
		ToAndroidServicing.gameObject.SetActive(value: false);
		FromFiles.gameObject.SetActive(value: false);
		ToSubwayCarriageInteraction.gameObject.SetActive(value: false);
		FromFilesToStation.gameObject.SetActive(value: false);
		ToSubwayStation.gameObject.SetActive(value: false);
		ToSubwayCarriage.gameObject.SetActive(value: false);
		FromFilesStation.gameObject.SetActive(value: false);
		ToPortHaraStation.gameObject.SetActive(value: false);
		ToPortHaraEntrance.gameObject.SetActive(value: false);
		FromPortStation.gameObject.SetActive(value: false);
		Fam1Male.gameObject.SetActive(value: false);
		Fam1Female.gameObject.SetActive(value: false);
		Fam1Child.gameObject.SetActive(value: false);
		Fam2Female.gameObject.SetActive(value: false);
		Fam2Child1.gameObject.SetActive(value: false);
		Fam2Child2.gameObject.SetActive(value: false);
		D_ThoseRobots.gameObject.SetActive(value: false);
		D_WheresDavid.gameObject.SetActive(value: false);
		I_Elevator.gameObject.SetActive(value: false);
		ElevatorToMeetingRoom.gameObject.SetActive(value: false);
		BattelDroid13.gameObject.SetActive(value: false);
		BattelDroid14.gameObject.SetActive(value: false);
		BattelDroid15.gameObject.SetActive(value: false);
		ToSkids.gameObject.SetActive(value: false);
		Dynamicblock.gameObject.SetActive(value: false);
		BattleDroid6.gameObject.SetActive(value: false);
		BettleDroid7.gameObject.SetActive(value: false);
		UnderclockGoon.gameObject.SetActive(value: false);
		ToSubwayCarriageInteraction.gameObject.SetActive(value: false);
		HoldenDeath.gameObject.SetActive(value: false);
		NotThatWay.gameObject.SetActive(value: false);
		Molly.gameObject.SetActive(value: false);
		Molly.IsAttackingDisabled = true;
		SuAndMartinez1.gameObject.SetActive(value: false);
		SuAndMartinez2.gameObject.SetActive(value: false);
		ChumleyDroid4.gameObject.SetActive(value: false);
		ChumleyDroid6.gameObject.SetActive(value: false);
		D_Archi.gameObject.SetActive(value: false);
		D_Ambrosia.gameObject.SetActive(value: false);
		D_Chris.gameObject.SetActive(value: false);
		D_Margot.gameObject.SetActive(value: false);
		D_Noot.gameObject.SetActive(value: false);
		BattelDroid16.gameObject.SetActive(value: false);
		BattelDroid17.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.CombatDeath, "CsTransCCrouchToInjuredIdle");
		ConstArray<v2i> grenadeTarget = new ConstArray<v2i>(1u);
		grenadeTarget.Add(new v2i(5, 4));
		yield return null;
		HAGIS.ToggleShakeEnvironment(on: true);
		MusicStop();
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_TheresAProblem);
		Willa.unitModel.Play("CsTransDefeatedToDIdle", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return HAGIS.DialogShow(Dialog_DidntSoundOKay);
		yield return HAGIS.DialogShow(Dialog_HeadSouthEast);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerSkyway_WatchHQ_L0");
		GC.Inst.SetRPGLeader(Willa);
		FromSkyway.gameObject.SetActive(value: true);
		yield return UnitMoveToMapViaExitTile(Chris, ToUnderClockStationEXT2);
		yield return UnitMoveToMapViaExitTile(Ambrosia, ToUnderClockStationEXT2);
		SKIP_POINT("Willa leaves");
		yield return UnitMoveToTarget(Willa, MoveToExit);
		Willa.LookAt(Archi);
		yield return HAGIS.DialogShow(Ambient_BeSafe);
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromSkyway);
		Willa.LookAt(ToUnderclockMeetingRoom.transform);
		yield return null;
		CutsceneEnd();
		yield return MapGoto(UnderclockPoliceStation.Map);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindMolly);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		yield return HAGIS.DialogShow(Dialog_TimeToWaste);
		MusicPlay("event:/music/tracks/basic/three heads are better");
		ToUnderclockMeetingRoom.gameObject.SetActive(value: true);
		FromSkyway.gameObject.SetActive(value: false);
		SKIP_POINT("Head to meeting room");
		yield return MapWaitUntilVisible(UnderclockMeetingRoom.Map);
		FromStationEXT.gameObject.SetActive(value: false);
		UnderclockMeetingRoom.CanTeammatesFollow = true;
		SuAndMartinez1.gameObject.SetActive(value: true);
		FromStationEXT.gameObject.SetActive(value: false);
		ToElevator.gameObject.SetActive(value: true);
		HagletYieldTerm yt_SuAndMartinezInteraction = CreateTriggerCondition(SuAndMartinez1.OnDialogComplete);
		yield return CreateOrCondition(term2: MapWaitUntilVisible(Elevator.Map), term1: yt_SuAndMartinezInteraction);
		if (SaveData.SplitPoint(yt_SuAndMartinezInteraction.met))
		{
			HagisLog("Dialog swap");
			SuAndMartinez2.gameObject.SetActive(value: true);
			SuAndMartinez1.gameObject.SetActive(value: false);
			yield return MapWaitUntilVisible(Elevator.Map);
		}
		UIObjectives.Inst.CancelObjective(objFindMolly);
		SKIP_POINT("Entering elevator");
		MusicStop();
		HAGIS.ToggleShakeEnvironment(on: true);
		elevatorWalls.speed = elevatorSpeed;
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_WeShouldExplain);
		HAGIS.ToggleShakeEnvironment(on: false);
		elevatorWalls.speed = 0f;
		yield return CreateTimeCondition(1f);
		Willa.LookInDirection(OctDir.Down);
		yield return UnitPlayAnimation(Willa, "DefaultInteract", loop: false, updateIdle: true);
		Graveyard.unitsMoveToDefaultPositions = true;
		yield return TeamMoveToMapViaEntranceTile(FromElevator);
		CutsceneEnd();
		SKIP_POINT("Graveyard combat");
		MusicPlay("event:/music/tracks/basic/compilers full");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindMolly);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_ComeToFinishMeOff);
		yield return HAGIS.DialogShow(Dialog_DammitWeDontHaveTime);
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		FromElevator.gameObject.SetActive(value: false);
		Hagis_A3O5 hagis_A3O = this;
		Unit willa = Willa;
		UnitTarget coverPoint = CoverPoint2;
		float? speed = Willa.charData.movementSpeedInCombat;
		hagis_A3O.UnitMoveToTarget(willa, coverPoint, null, speed);
		UnitMoveToTarget(CompilerGoon1, GoonPoint1);
		UnitMoveToTarget(CompilerGoon2, GoonPoint2);
		UnitMoveToTarget(CompilerGoon3, GoonPoint3);
		Hagis_A3O5 hagis_A3O2 = this;
		willa = Chris;
		coverPoint = CoverPoint3;
		speed = Chris.charData.movementSpeedInCombat;
		hagis_A3O2.UnitMoveToTarget(willa, coverPoint, null, speed);
		Hagis_A3O5 hagis_A3O3 = this;
		willa = Ambrosia;
		coverPoint = CoverPoint1;
		speed = Ambrosia.charData.movementSpeedInCombat;
		hagis_A3O3.UnitMoveToTarget(willa, coverPoint, null, speed);
		yield return UnitMoveToTarget(Holden, HoldenCover);
		CutsceneEnd();
		SKIP_POINT("Tom's super cool fly skip point pre holden attack");
		MusicPlay("event:/music/tracks/combat/underclock combat");
		CombatBegin(UnitTeam.Type.Enemy);
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return CreateTriggerCondition(Holden.OnDeathComplete);
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsInjuredWalk");
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsInjuredIdle");
		Holden.UpdateIdleAnim();
		yield return CombatWaitUntilComplete();
		MusicStop();
		CutsceneBegin();
		UnitMoveToTarget(Willa, PostFightTarget, OctDir.Down);
		UnitMoveToTarget(Chris, PostFightTarget2, OctDir.Down);
		yield return UnitMoveToTarget(Ambrosia, PostFightTarget3, OctDir.Down);
		Holden.Revive();
		yield return CreateTimeCondition(0.5f);
		MusicPlay("event:/music/tracks/basic/three heads are better");
		yield return UnitMoveToTarget(Holden, HoldenMoveTo, null, 1f);
		Holden.LookAt(Willa);
		Willa.LookAt(Holden);
		yield return HAGIS.DialogShow(Dialog_IdLikeToTake);
		yield return UnitPlayAnimation(Holden, "CsInjuredIdleToAimIdle");
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		Holden.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_HaSucker);
		UnitPlayAnimation(Holden, "TransAIdleToCIdle", loop: false, updateIdle: true);
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		MusicStop();
		yield return HAGIS.DialogShow(Dialog_HehIdiot);
		yield return UnitPlayAnimation(Holden, "CombatDeath");
		Dynamicblock.gameObject.SetActive(value: true);
		CutsceneEnd();
		yield return CreateTimeCondition(2f);
		UnderclockMeetingRoom.CanTeammatesFollow = true;
		ToPark.gameObject.SetActive(value: true);
		HoldenDeath.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		MusicPlay("event:/music/tracks/basic/three heads are better");
		yield return MapWaitUntilVisible(DetritumPark.Map);
		ToFiles.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1.5f);
		PlayInterplay();
		yield return MapWaitUntilVisible(TheFiles.Map);
		SKIP_POINT("Files ambush");
		MusicStop();
		TheFiles.CanTeammatesFollow = false;
		yield return CreateOrCondition(UnitMoveToTarget(Willa, CoverPoint4), UnitMoveToTarget(Chris, CoverPoint5), UnitMoveToTarget(Ambrosia, CoverPoint6));
		Willa.LookAt(BattleDroid1);
		yield return HAGIS.DialogShow(Dialog_IllegalBioelectric);
		UnitMoveToTarget(Willa, CoverWilla, null, 5f);
		yield return UnitMoveToTarget(Chris, CoverChris, null, 5f);
		MusicPlay("event:/music/tracks/combat/generic combat 3b");
		CombatBegin(UnitTeam.Type.Player);
		HagletYieldTerm Droid1Hit = BattleDroid1.OnUnitSustainedDamage;
		HagletYieldTerm Droid2Hit = BattleDroid2.OnUnitSustainedDamage;
		yield return CreateOrCondition(Droid1Hit, Droid2Hit);
		yield return HAGIS.DialogShow(Ambient_ResistanceWillBeMet);
		yield return CombatWaitUntilComplete();
		ToAndroidServicing.gameObject.SetActive(value: true);
		yield return null;
		HagisLog("Combat end");
		SKIP_POINT("Files ambush (fight complete)");
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		TheFiles.CanTeammatesFollow = true;
		Molly.gameObject.SetActive(value: true);
		Molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsCombatCrouch");
		BattleDroid4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattleDroid5.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattleDroid4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Molly.IsAttackingDisabled = false;
		Molly.UpdateIdleAnim();
		BattleDroid5.SetTeamType(UnitTeam.Type.Enemy);
		BattleDroid5.HPDecrement(BattleDroid5.HP - 1);
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindMolly);
		yield return MapWaitUntilVisible(AndroidServicing.Map);
		SKIP_POINT("Helping Molly");
		MusicPlay("event:/music/tracks/basic/light tension 1");
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, CoverPoint7);
		Molly.LookAt(BattleDroid5);
		Ability_Grenade mollyGrenade = Molly.abilities.Add<Ability_Grenade>(null, isUpgraded: true);
		yield return UnitMoveToTarget(BattleDroid3, DroidApproachesMolly);
		BattleDroid3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattleDroid3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Willa.LookAt(Molly);
		BattleDroid3.LookAt(Molly);
		mollyGrenade.typeOverride = GadgetType.FAKEFLUX;
		mollyGrenade.OnActivateWithTilesSelectedBase(Molly, grenadeTarget, default(UIAbilityWheelChoice));
		yield return CreateTimeCondition(0.5f);
		UnitMoveToTarget(BattleDroid3, DroidRunFromGrenade1, OctDir.DownLeft, BattleDroid3.charData.movementSpeedInCombat);
		UnitMoveToTarget(BattleDroid4, DroidRunFromGrenade2, OctDir.Left, BattleDroid4.charData.movementSpeedInCombat);
		yield return Wait.ForSeconds(3f);
		mollyGrenade.OnUnitTurnBegin(Molly);
		Molly.UpdateIdleAnim();
		yield return null;
		Willa.LookAt(BattleDroid3);
		yield return CreateTimeCondition(0.5f);
		BattleDroid5.LookInDirection(OctDir.Right);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Ambient_CriticalSystemError);
		BattleDroid5.Kill();
		yield return HAGIS.DialogShow(Dialog_Willa);
		BattleDroid3.LookAt(Willa);
		BattleDroid4.LookAt(Willa);
		yield return CreateTimeCondition(0.5f);
		UnitMoveToTarget(BattleDroid4, DroidMoveToCover2, OctDir.Left, BattleDroid4.charData.movementSpeedInCombat);
		yield return UnitMoveToTarget(BattleDroid3, DroidMoveToCover, OctDir.Right, BattleDroid3.charData.movementSpeedInCombat);
		Molly.IsAttackingDisabled = true;
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objProtectMolly);
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objProtectMolly);
		CutsceneBegin();
		yield return Molly.unitModel.Play("TransCCrouchToDIdle");
		Molly.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return CreateTimeCondition(1f);
		UnitMoveToTarget(Willa, WillaMoveTo, OctDir.Left);
		yield return UnitMoveToTarget(Molly, MollyMoveTo, OctDir.Right);
		UnitMoveToTarget(Ambrosia, PostFight1, OctDir.DownLeft);
		yield return UnitMoveToTarget(Chris, PostFight2, OctDir.UpLeft);
		yield return HAGIS.DialogShow(Dialog_HowManyOfThose);
		Molly.unitModel.PlayAndReturnToIdle("DefaultGiveItem");
		Willa.unitModel.PlayAndReturnToIdle("DefaultReceiveItem");
		Willa.popupBar.Enqueue("POPUPBAR_A3O5_ADDFLUXGRENADES", 0, 0f, null, null, 3);
		Party.Inst.AddItemToInventory(Item.Grenade_Flux.ToMeta(), 3);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_ICouldMakeMore);
		CutsceneEnd();
		PlayMapAnimation(SubwayStation.Map, "MA_SubwayTrain", "Arriving");
		UIObjectives.Inst.CompleteAndSetMainObjective(objEscortMollyToPortHara);
		Molly.SetTeamType(UnitTeam.Type.Player);
		FromFiles.gameObject.SetActive(value: true);
		ToSubwayStation.gameObject.SetActive(value: true);
		Fam1Male.gameObject.SetActive(value: true);
		Fam1Female.gameObject.SetActive(value: true);
		Fam1Child.gameObject.SetActive(value: true);
		Fam2Female.gameObject.SetActive(value: true);
		Fam2Child1.gameObject.SetActive(value: true);
		Fam2Child2.gameObject.SetActive(value: true);
		D_ThoseRobots.gameObject.SetActive(value: true);
		D_WheresDavid.gameObject.SetActive(value: true);
		yield return null;
		SKIP_POINT("Head to Subway");
		MusicPlay("event:/music/tracks/exploration/act 3 exploration");
		yield return MapWaitUntilVisible(SubwayStation.Map);
		ToSubwayCarriageInteraction.gameObject.SetActive(value: true);
		UnitMoveToTarget(Molly, MollyMoveToPoint, OctDir.DownRight);
		UnitMoveToTarget(Chris, ChrisMoveToPoint, OctDir.DownLeft);
		UnitMoveToTarget(Ambrosia, AmbrosiaMoveToPoint, OctDir.DownLeft);
		SKIP_POINT("Board train");
		MusicStop();
		HagletYieldTerm TalkedToDavid = CreateTriggerCondition(I_TalkedToDavid.OnTriggered);
		HagletYieldTerm TrainInteraction = CreateTriggerCondition(ToSubwayCarriageInteraction.OnTriggered);
		yield return CreateOrCondition(TrainInteraction, TalkedToDavid);
		if (SaveData.SplitPoint(TalkedToDavid.met, skipOverride: true, save: false))
		{
			CutsceneBegin();
			yield return HAGIS.DialogShow(Dialog_MissingDavid);
			yield return UnitMoveToTarget(David, T_DavidRunsOff);
			David.Hide(makeInactive: true);
			CutsceneEnd();
			yield return CreateTriggerCondition(ToSubwayCarriageInteraction.OnTriggered);
		}
		CutsceneBegin();
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Molly.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromFilesStation, WillaSubwayCover);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, FromFilesStation, AmbrosiaSubwayCover);
		yield return UnitTeleportToMapViaEntranceTile(Molly, FromFilesStation, MollyMovetoSub);
		yield return UnitTeleportToMapViaEntranceTile(Chris, FromFilesStation, ChrisSubwayCover);
		PlayMapAnimation(SubwayStation.Map, "MA_SubwayTrain", "Leaving");
		yield return CreateTimeCondition(4f);
		yield return MapGoto(SubwayCarriage);
		HAGIS.ToggleShakeEnvironment(on: true);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Molly.SetTeamType(UnitTeam.Type.NPC);
		GC.Inst.SetRPGLeader(Willa);
		yield return null;
		CutsceneEnd();
		yield return null;
		SKIP_POINT("Survive ambush");
		MusicPlay("event:/music/tracks/basic/drone 2");
		Molly.SetTeamType(UnitTeam.Type.Player);
		Molly.HideStatusBar();
		CutsceneBegin();
		Willa.LookAt(Molly);
		Ambrosia.LookAt(Willa);
		Chris.LookAt(Willa);
		Molly.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Ambient_CoolHair);
		yield return HAGIS.DialogShow(Ambient_WillaThanks);
		CutsceneEnd();
		yield return CreateTimeCondition(2f);
		HAGIS.ToggleShakeEnvironment(on: false);
		SFXPlay("event:/vo/TrainAnnouncements_AnnouncerDucts_PortHara_L0");
		ToPortHaraStation.gameObject.SetActive(value: true);
		yield return PlayMapAnimation(SubwayCarriage.Map, "MA_SubwayDoors", "Open");
		yield return MapWaitUntilVisible(PortHaraEntrance.Map);
		SKIP_POINT("Molly leaves");
		yield return null;
		UIObjectives.Inst.CompleteObjective(objEscortMollyToPortHara);
		yield return HAGIS.DialogShow(Ambient_WeGottaClearRoute);
		UnitMoveToTarget(Willa, WillaIdle, OctDir.Up);
		UnitMoveToTarget(Chris, ChrisMoveToHara, OctDir.Up);
		UnitMoveToTarget(Ambrosia, AmbrosiaMoveToHara, OctDir.Up);
		yield return UnitMoveToTarget(Molly, MollyIdle, OctDir.Down);
		yield return null;
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		Molly.SetTeamType(UnitTeam.Type.NPC);
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		SKIP_POINT("Molly has left");
		yield return HAGIS.DialogShow(Ambient_ItsSafeGo);
		CutsceneBegin();
		UnitMoveToTarget(Chris, ChrisPostFight, OctDir.Left);
		UnitMoveToTarget(Ambrosia, AmbrosiaPostFight, OctDir.Left);
		UnitMoveToTarget(Willa, WillaPostFight, OctDir.Left);
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(Molly, MollyPostFight, OctDir.Right);
		MusicPlay("event:/music/tracks/basic/time to leave");
		yield return HAGIS.DialogShow(Dialog_ComeWithMe);
		yield return HAGIS.DialogShow(Dialog_SixYearsInRepair);
		yield return HAGIS.DialogShow(Dialog_WhatSize);
		MusicStop();
		yield return UnitMoveToTarget(Molly, MollyLeaves);
		Molly.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Dialog_NowMolly);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGetToSkids);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/combat/generic combat 3b");
		yield return HAGIS.DialogShow(Dialog_Incoming);
		Willa.LookInDirection(OctDir.Right);
		Chris.LookInDirection(OctDir.Right);
		Ambrosia.LookInDirection(OctDir.Right);
		SKIP_POINT("Droids enter port hara");
		UnitTeleportToMapViaEntranceTile(Archi, FromPortHara, T_ArchiSpawn);
		UnitTeleportToMapViaEntranceTile(Noot, FromPortHara, T_NootSpawn);
		UnitTeleportToMapViaEntranceTile(Margot, FromPortHara, T_MargotSpawn);
		MusicSetIntensity(0f);
		yield return HAGIS.DialogShow(Dialog_SkidsGo);
		ToSkids.gameObject.SetActive(value: true);
		PortHaraEntrance.CanTeammatesFollow = true;
		SKIP_POINT("Leave Via the skids");
		NotThatWay.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(Skids.Map);
		UnitMoveToTarget(Chris, T_SkidsCover2);
		UnitMoveToTarget(Ambrosia, T_SkidsCover3, OctDir.Down);
		yield return UnitMoveToTarget(Willa, T_SkidsCover);
		Willa.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		yield return HAGIS.DialogShow(Dialog_WereYouFollowed);
		ChumleyDroid4.gameObject.SetActive(value: true);
		ChumleyDroid6.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(ChumleyDroid4, T_DroidEntryPoint);
		yield return UnitMoveToTarget(ChumleyDroid6, T_DroidEntryPoint3);
		Willa.LookAt(ChumleyDroid4);
		Chris.LookAt(ChumleyDroid4);
		Ambrosia.LookAt(ChumleyDroid4);
		yield return HAGIS.DialogShow(Dialog_YeahYou);
		UIObjectives.Inst.CompleteAndSetMainObjective(objDefend);
		yield return null;
		MusicPlay("event:/music/tracks/combat/frenzy");
		yield return CombatBegin(UnitTeam.Type.Player);
		FromPortHara.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindTheElevator);
		SKIP_POINT("combat in skids over");
		MusicPlay("event:/music/tracks/basic/jules theme");
		CutsceneBegin();
		BattleDroid11.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattelDroid12.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattleDroid11.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		BattelDroid12.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		BattelDroid16.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattelDroid17.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		BattelDroid16.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		BattelDroid17.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		BattleDroid11.Revive();
		BattelDroid16.gameObject.SetActive(value: true);
		yield return UnitTeleportToMapViaEntranceTile(BattleDroid11, FromPortHara);
		UnitMoveToTarget(BattleDroid11, T_DroidEntryPoint, null, 5f);
		BattelDroid12.Revive();
		BattelDroid17.gameObject.SetActive(value: true);
		yield return UnitTeleportToMapViaEntranceTile(BattelDroid12, FromPortHara);
		UnitMoveToTarget(BattelDroid12, T_DroidEntryPoint2, null, 5f);
		yield return CreateTimeCondition(1f);
		yield return CreateAndCondition(UnitMoveToTarget(Willa, T_TeamGather4, OctDir.Down), UnitMoveToTarget(Margot, T_TeamGather3, OctDir.Up), UnitMoveToTarget(Noot, T_TeamGather2, OctDir.Up), UnitMoveToTarget(Ambrosia, T_TeamGather1, OctDir.Up), UnitMoveToTarget(Chris, T_ChrisIdle, OctDir.Down), UnitMoveToTarget(Archi, T_TeamGather5, OctDir.Down));
		UnitPlayAnimation(Willa, "TransDIdleToCIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Archi, "TransDIdleToCIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Margot, "TransDIdleToCIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Chris, "TransDIdleToCIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Ambrosia, "TransDIdleToCIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Noot, "TransDIdleToCIdle", loop: false, updateIdle: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return null;
		yield return CreateAndCondition(UnitMoveToTarget(BattleDroid11, T_DroidsSurround3, OctDir.Down, 5f), UnitMoveToTarget(BattelDroid12, T_DroidsSurround2, OctDir.Down, 5f), UnitMoveToTarget(BattelDroid16, T_DroidsSurround6, OctDir.Up, 5f), UnitMoveToTarget(BattelDroid17, T_NootSpawn, OctDir.Up, 5f));
		yield return HAGIS.DialogShow(Ambient_HaveToBeThisWay);
		UnitPlayAnimation(BattleDroid11, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(BattelDroid12, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(BattelDroid16, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(BattelDroid17, "TransCIdleToDIdle", loop: false, updateIdle: true);
		BattleDroid11.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		BattelDroid12.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		BattelDroid16.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		BattelDroid17.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(Willa, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Archi, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Margot, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Chris, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Ambrosia, "TransCIdleToDIdle", loop: false, updateIdle: true);
		UnitPlayAnimation(Noot, "TransCIdleToDIdle", loop: false, updateIdle: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return null;
		yield return CreateTimeCondition(1f);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		yield return null;
		yield return UnitMoveToTarget(Willa, T_WillaWalksTowardsElevator, null, 2f);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Noot.LookInDirection(OctDir.Down);
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		yield return CreateAndCondition(UnitMoveToTarget(Archi, T_ArchiStepsForward, OctDir.DownRight, 2f), UnitMoveToTarget(Ambrosia, T_ArchiSpawn, OctDir.Down, 2f), UnitMoveToTarget(Margot, T_MargotSpawn, OctDir.Down, 2f));
		yield return CreateTimeCondition(1f);
		Willa.LookInDirection(OctDir.UpLeft);
		I_Elevator.gameObject.SetActive(value: true);
		D_Archi.gameObject.SetActive(value: true);
		D_Ambrosia.gameObject.SetActive(value: true);
		D_Chris.gameObject.SetActive(value: true);
		D_Margot.gameObject.SetActive(value: true);
		D_Noot.gameObject.SetActive(value: true);
		CutsceneEnd();
		MusicPlay("event:/music/tracks/basic/willa underscore");
		yield return CreateTriggerCondition(I_Elevator.OnTriggered);
		MusicStop();
		yield return HAGIS.DialogShow(Dialog_ICanFixThis);
		HagisLog("Logic ends");
	}
}
public class Hagis_A3O5_CivsRunAway : HAGIS
{
	private Unit Fam1Male;

	private Unit Fam1Female;

	private Unit Fam1Child;

	private Unit Fam2Female;

	private Unit Fam2Child1;

	private Unit Fam2Child2;

	private Unit David;

	private UnitTarget MotherWaits;

	private UnitTarget FamilyLeaves;

	private TileActionSwapMap ToUnderClockStationEXT2;

	private TileActionSwapMap FromSkyway;

	private TileActionSwapMap ToUnderclockMeetingRoom;

	private TileActionSwapMap FromStationEXT;

	private TileActionSwapMap ToElevator;

	private TileActionSwapMap ToGraveyard;

	private TileActionSwapMap FromElevator;

	private TileActionSwapMap ToPark;

	private TileActionSwapMap FromGraveyard;

	private TileActionSwapMap ToFiles;

	private TileActionSwapMap FromPark;

	private TileActionSwapMap ToAndroidServicing;

	private TileActionSwapMap FromFiles;

	private TileActionSwapMap ToSubwayStation;

	private TileActionSwapMap FromFilesToStation;

	private TileActionSwapMap ToSubwayCarriage;

	private TileActionSwapMap FromFilesStation;

	private TileActionSwapMap ToPortHaraStation;

	private TileActionSwapMap FromPortStation;

	private TileActionSwapMap ToSkids;

	private TileActionSwapMap FromPortHara;

	private TileActionSwapMap ToPortHaraEntrance;

	private DialogData Ambient_ItsSafeGo;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot UnderclockPoliceStation = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclockMeetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		LogicRoot Elevator = GetLogicUsingArtName("T2ClocktowerElevator");
		LogicRoot Graveyard = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot DetritumPark = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot AndroidServicing = GetLogicUsingArtName("T1AndroidServicing");
		LogicRoot SubwayStation = GetLogicUsingArtName("T1Subway_Station_Files");
		LogicRoot SubwayCarriage = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot PortHaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot Skids = GetLogicUsingArtName("T1TheSkids");
		Fam1Male = GC.Inst.GetUnitWithId("E2B_T1TheFiles_UnitSpawn");
		Fam1Female = GC.Inst.GetUnitWithId("3B4_T1TheFiles_UnitSpawn");
		Fam1Child = GC.Inst.GetUnitWithId("A3C_T1TheFiles_UnitSpawn");
		Fam2Female = GC.Inst.GetUnitWithId("DA1_T1TheFiles_UnitSpawn");
		Fam2Child1 = GC.Inst.GetUnitWithId("5A9_T1TheFiles_UnitSpawn");
		Fam2Child2 = GC.Inst.GetUnitWithId("723_T1TheFiles_UnitSpawn");
		David = GC.Inst.GetUnitWithId("DB7_T1Subway_Station_Files_UnitSpawn");
		MotherWaits = MR.Inst.GetUnitTarget("200_T1Port1_HaraEntrance_UnitTarget");
		FamilyLeaves = MR.Inst.GetUnitTarget("205_T1Port1_HaraEntrance_UnitTarget");
		ToUnderClockStationEXT2 = MR.Inst.GetTileActionSwapMap("C0E_T2Skyway_TileActionSwapMap");
		FromSkyway = MR.Inst.GetTileActionSwapMap("DA6_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		ToUnderclockMeetingRoom = MR.Inst.GetTileActionSwapMap("E29_T2UnderclocksPoliceStation_Exterior_TileActionSwapMap");
		FromStationEXT = MR.Inst.GetTileActionSwapMap("F41_T2UnderclockMeetingRoom_TileActionSwapMap");
		ToElevator = MR.Inst.GetTileActionSwapMap("109_T2UnderclockMeetingRoom_TileActionSwapMap");
		ToGraveyard = MR.Inst.GetTileActionSwapMap("F7F_T2ClocktowerElevator_TileActionSwapMap");
		FromElevator = MR.Inst.GetTileActionSwapMap("7FD_T1DetritumGraveyard_TileActionSwapMap");
		ToPark = MR.Inst.GetTileActionSwapMap("D83_T1DetritumGraveyard_TileActionSwapMap");
		FromGraveyard = MR.Inst.GetTileActionSwapMap("9F1_T1DetritumPark_TileActionSwapMap");
		ToFiles = MR.Inst.GetTileActionSwapMap("0D5_T1DetritumPark_TileActionSwapMap");
		FromPark = MR.Inst.GetTileActionSwapMap("858_T1TheFiles_TileActionSwapMap");
		ToAndroidServicing = MR.Inst.GetTileActionSwapMap("887_T1TheFiles_TileActionSwapMap");
		ToSubwayStation = MR.Inst.GetTileActionSwapMap("CB6_T1TheFiles_TileActionSwapMap");
		FromFiles = MR.Inst.GetTileActionSwapMap("345_T1AndroidServicing_TileActionSwapMap");
		FromFilesToStation = MR.Inst.GetTileActionSwapMap("22A_T1Subway_Station_Files_TileActionSwapMap");
		ToSubwayCarriage = MR.Inst.GetTileActionSwapMap("176_T1Subway_Station_Files_TileActionSwapMap");
		FromFilesStation = MR.Inst.GetTileActionSwapMap("AA1_T1Subway_TrainInterior_TileActionSwapMap");
		ToPortHaraStation = MR.Inst.GetTileActionSwapMap("D9A_T1Subway_TrainInterior_TileActionSwapMap");
		ToPortHaraEntrance = MR.Inst.GetTileActionSwapMap("D9A_T1Subway_TrainInterior_TileActionSwapMap");
		FromPortStation = MR.Inst.GetTileActionSwapMap("A33_T1Port1_HaraEntrance_TileActionSwapMap");
		ToSkids = MR.Inst.GetTileActionSwapMap("F3D_T1Port1_HaraEntrance_TileActionSwapMap");
		FromPortHara = MR.Inst.GetTileActionSwapMap("303_T1TheSkids_TileActionSwapMap");
		Ambient_ItsSafeGo = HAGIS.DialogLoad("Dialogs/A3O5/PortHaraEntrance/Ambient_ItsSafeGo");
		yield return null;
		yield return CreateTriggerCondition(Ambient_ItsSafeGo.OnComplete);
		UnitTeleportToMapViaEntranceTile(Fam2Child1, FromPortStation);
		UnitTeleportToMapViaEntranceTile(Fam2Female, FromPortStation);
		yield return UnitTeleportToMapViaEntranceTile(Fam1Child, FromPortStation);
		yield return null;
		UnitMoveToTarget(Fam2Female, MotherWaits, OctDir.Down, 1.5f);
		UnitMoveToTarget(Fam2Child1, FamilyLeaves, OctDir.Down, 1.3f);
		yield return CreateTimeCondition(0.6f);
		yield return UnitMoveToTarget(Fam1Child, FamilyLeaves, null, 1.3f);
		Fam1Child.Hide(makeInactive: true);
		Fam2Child1.Hide(makeInactive: true);
		yield return UnitMoveToTarget(Fam2Female, FamilyLeaves);
		Fam2Female.Hide(makeInactive: true);
	}
}
public class HAGIS_A3O8 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Ambro;

	private Unit Chris;

	private Unit Noot;

	private Unit Margot;

	private Unit Jules;

	private Unit Theo;

	private Unit OutsideDroid_1;

	private Unit OutsideDroid_2;

	private Unit OutsideDroid_3;

	private Unit OutsideDroid_4;

	private Unit TowerDroid_1;

	private Unit TowerDroid_2;

	private Unit TowerDroid_3;

	private Unit TowerDroid_4;

	private Unit TheSignalGenerator;

	private UnitTarget ChrisDoorSpot;

	private UnitTarget ArchiToCover;

	private UnitTarget ChrisEnterTower;

	private UnitTarget AmbroEnterTower;

	private UnitTarget ArchiEnterTower;

	private UnitTarget NootEnterTower;

	private UnitTarget MargotEnterTower;

	private UnitTarget AmbroCenterTower;

	private UnitTarget ArchiCenterTower;

	private UnitTarget NootCenterTower;

	private UnitTarget MargotCenterTower;

	private UnitTarget ChrisGeneratorAction;

	private UnitTarget ArchiClocktowerCover;

	private UnitTarget AmbroClocktowerCover;

	private UnitTarget NootClocktowerCover;

	private UnitTarget ChrisClocktowerCover;

	private UnitTarget MargotClocktowerCover;

	private UnitTarget WillaMoveTo;

	private UnitTarget EnemyCoverLeft;

	private UnitTarget EnemyCoverRight;

	private TileActionSwapMap ToBroadcastTower;

	private TileActionSwapMap FromBroadcastTowerExterior;

	private TileActionSwapMap ToOmegaOffice;

	private TileActionSwapMap FromCeleTownCentre;

	private TileTrigger SlagSubwaySteatlhTrigger;

	private TileActionInteraction ChristHacksDoorSpot;

	private TileActionInteraction BarDialogTrigger;

	private DialogData Dialog_A3O8Opening;

	private DialogData Dialog_ProdigalChild;

	private DialogData Dialog_AppreciateJules;

	private DialogData Dialog_JulesWantsRespect;

	private DialogData Dialog_FluxMissile;

	private DialogData ambient_HeartmanOhShit;

	private DialogData ambient_TheyFoundUs;

	private DialogData ambient_GetBacktoWilla;

	private DialogData ambient_UnnervedWilla;

	private DialogData Dialog_WereInTrouble;

	private DialogData ambient_ArchiEntrenceConsole_Path1_Chris;

	private DialogData ambient_ChrisEntrenceConsole_Path1_Cont;

	private DialogData ambient_ArchiWoohoo;

	private DialogData ambient_TowerAnnouncer1;

	private DialogData ambient_TowerAnnouncer2;

	private DialogData ambient_TowerAnnouncer3;

	private DialogData ambient_TowerAnnouncer4;

	private DialogData ambient_TowerAnnouncer5;

	private DialogData dialog_TowerChrisPresent;

	private DialogData dialog_DroidsNotDefeatedYet;

	private DialogData dialog_DroidsNotDefeatedYetPart2;

	private DialogData ambient_DroidsLiveAgain;

	private DialogData dialog_JulesVictory;

	private DialogData ambient_WillaShutEmDown;

	private DialogData dialog_ItsOver_Response;

	private DialogData dialog_ItsOver_Response1_Willa;

	private DialogData dialog_ItsOver_Response2_Willa;

	private DialogData ambient_JulesLosesWilla;

	private DialogData ambient_JulesLosesWillaPart2;

	private string ojbConfrontJules = "OBJECTIVES_A3O8_01";

	private string objBreakIntoTower = "OBJECTIVES_A3O8_02";

	private string objSurviveDoorOpening = "OBJECTIVES_A3O8_03";

	private string objDesotryGenerator = "OBJECTIVES_A3O8_04";

	private static float GetUnitHealthPercentage(Unit unit)
	{
		float num = (float)unit.HP / (float)unit.GetHPMax();
		return num * 100f;
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		RoomSceneMeta Room_5 = GetRoomMeta("ROOM_Penthouse_05");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		LogicRoot OmegaOffice = GetLogicUsingArtName("T3OmegaOffices");
		LogicRoot CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot BroadcastTowerOutside = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot BroadcastTowerInside = GetLogicUsingArtName("T3RelayTowerInterior");
		Willa = GC.Inst.GetUnitWithId("19A_T3CelestiaTownCentre_UnitSpawn");
		Jules = GC.Inst.GetUnitWithId("45D_T3OmegaOffices_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("1EE_T3OmegaOffices_UnitSpawn");
		Ambro = GC.Inst.GetUnitWithId("164_T3RelayTowerExterior_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("8BC_T3RelayTowerExterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("554_T3RelayTowerExterior_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("66C_T3RelayTowerExterior_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("373_T3RelayTowerExterior_UnitSpawn");
		OutsideDroid_1 = GC.Inst.GetUnitWithId("61A_T3RelayTowerExterior_UnitSpawn");
		OutsideDroid_2 = GC.Inst.GetUnitWithId("80D_T3RelayTowerExterior_UnitSpawn");
		OutsideDroid_3 = GC.Inst.GetUnitWithId("ACF_T3RelayTowerExterior_UnitSpawn");
		OutsideDroid_4 = GC.Inst.GetUnitWithId("039_T3RelayTowerExterior_UnitSpawn");
		TowerDroid_1 = GC.Inst.GetUnitWithId("68B_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_2 = GC.Inst.GetUnitWithId("34F_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_3 = GC.Inst.GetUnitWithId("420_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_4 = GC.Inst.GetUnitWithId("62D_T3RelayTowerInterior_UnitSpawn");
		TheSignalGenerator = GC.Inst.GetUnitWithId("F82_T3RelayTowerInterior_UnitSpawn");
		Ability_MaxHP signalGeneratorHP = TheSignalGenerator.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		signalGeneratorHP.SetHPMod(12);
		ChrisDoorSpot = MR.Inst.GetUnitTarget("608_T3RelayTowerInterior_UnitTarget");
		ArchiToCover = MR.Inst.GetUnitTarget("456_T3RelayTowerExterior_UnitTarget");
		ChrisEnterTower = MR.Inst.GetUnitTarget("13C_T3RelayTowerInterior_UnitTarget");
		AmbroEnterTower = MR.Inst.GetUnitTarget("C07_T3RelayTowerInterior_UnitTarget");
		ArchiEnterTower = MR.Inst.GetUnitTarget("75C_T3RelayTowerInterior_UnitTarget");
		NootEnterTower = MR.Inst.GetUnitTarget("F60_T3RelayTowerInterior_UnitTarget");
		MargotEnterTower = MR.Inst.GetUnitTarget("1D8_T3RelayTowerInterior_UnitTarget");
		AmbroCenterTower = MR.Inst.GetUnitTarget("DF5_T3RelayTowerInterior_UnitTarget");
		ArchiCenterTower = MR.Inst.GetUnitTarget("788_T3RelayTowerInterior_UnitTarget");
		NootCenterTower = MR.Inst.GetUnitTarget("4FF_T3RelayTowerInterior_UnitTarget");
		MargotCenterTower = MR.Inst.GetUnitTarget("ED8_T3RelayTowerInterior_UnitTarget");
		ChrisGeneratorAction = MR.Inst.GetUnitTarget("50D_T3RelayTowerInterior_UnitTarget");
		WillaMoveTo = MR.Inst.GetUnitTarget("F0F_T3OmegaOffices_UnitTarget");
		ArchiClocktowerCover = MR.Inst.GetUnitTarget("0EA_T3RelayTowerInterior_UnitTarget");
		AmbroClocktowerCover = MR.Inst.GetUnitTarget("E9E_T3RelayTowerInterior_UnitTarget");
		NootClocktowerCover = MR.Inst.GetUnitTarget("9A5_T3RelayTowerInterior_UnitTarget");
		ChrisClocktowerCover = MR.Inst.GetUnitTarget("31B_T3RelayTowerInterior_UnitTarget");
		MargotClocktowerCover = MR.Inst.GetUnitTarget("C30_T3RelayTowerInterior_UnitTarget");
		EnemyCoverLeft = MR.Inst.GetUnitTarget("F45_T3RelayTowerInterior_UnitTarget");
		EnemyCoverRight = MR.Inst.GetUnitTarget("629_T3RelayTowerInterior_UnitTarget");
		Dialog_A3O8Opening = HAGIS.DialogLoad("Dialogs/A3O8/1_CelestiaTownCentre/Dialog_A3O8Opening");
		Dialog_ProdigalChild = HAGIS.DialogLoad("Dialogs/A3O8/2_OmegaOffice/Dialog_ProdigalChild");
		Dialog_AppreciateJules = HAGIS.DialogLoad("Dialogs/A3O8/2_OmegaOffice/Dialog_AppreciateJules");
		Dialog_JulesWantsRespect = HAGIS.DialogLoad("Dialogs/A3O8/2_OmegaOffice/Dialog_JulesWantsRespect");
		Dialog_FluxMissile = HAGIS.DialogLoad("Dialogs/A3O8/2_OmegaOffice/Dialog_FluxMissile");
		ambient_HeartmanOhShit = HAGIS.DialogLoad("Dialogs/A3O8/2_OmegaOffice/ambient_HeartmanOhShit");
		ambient_TheyFoundUs = HAGIS.DialogLoad("Dialogs/A3O8/3_CravensRoomPentHouse/ambient_TheyFoundUs");
		ambient_GetBacktoWilla = HAGIS.DialogLoad("Dialogs/A3O8/3_CravensRoomPentHouse/ambient_GetBacktoWilla");
		ambient_UnnervedWilla = HAGIS.DialogLoad("Dialogs/A3O8/4_OmegaOffice/ambient_UnnervedWilla");
		Dialog_WereInTrouble = HAGIS.DialogLoad("Dialogs/A3O8/4_OmegaOffice/Dialog_WereInTrouble");
		ambient_ArchiEntrenceConsole_Path1_Chris = HAGIS.DialogLoad("Dialogs/A3O8/5_BroadcastTowerOutside/ambient_ArchiEntrenceConsole_Path1_Chris");
		ambient_ChrisEntrenceConsole_Path1_Cont = HAGIS.DialogLoad("Dialogs/A3O8/5_BroadcastTowerOutside/ambient_ChrisEntrenceConsole_Path1_Cont");
		dialog_TowerChrisPresent = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/dialog_TowerChrisPresent");
		ambient_TowerAnnouncer1 = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_TowerAnnouncer1");
		ambient_TowerAnnouncer2 = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_TowerAnnouncer2");
		ambient_TowerAnnouncer3 = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_TowerAnnouncer3");
		ambient_TowerAnnouncer4 = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_TowerAnnouncer4");
		ambient_TowerAnnouncer5 = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_TowerAnnouncer5");
		ambient_ArchiWoohoo = HAGIS.DialogLoad("Dialogs/A3O8/6_BroadcastTowerInside/ambient_ArchiWoohoo");
		dialog_DroidsNotDefeatedYet = HAGIS.DialogLoad("Dialogs/A3O8/7_OmegaOffice/dialog_DroidsNotDefeatedYet");
		dialog_DroidsNotDefeatedYetPart2 = HAGIS.DialogLoad("Dialogs/A3O8/7_OmegaOffice/dialog_DroidsNotDefeatedYetPart2");
		ambient_DroidsLiveAgain = HAGIS.DialogLoad("Dialogs/A3O8/8_BroadcastTowerInside/ambient_DroidsLiveAgain");
		ambient_WillaShutEmDown = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/ambient_WillaShutEmDown");
		dialog_JulesVictory = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/dialog_JulesVictory");
		dialog_ItsOver_Response = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/dialog_ItsOver_Response");
		dialog_ItsOver_Response1_Willa = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/dialog_ItsOver_Response1_Willa");
		dialog_ItsOver_Response2_Willa = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/dialog_ItsOver_Response2_Willa");
		ambient_JulesLosesWilla = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/ambient_JulesLosesWilla");
		ambient_JulesLosesWillaPart2 = HAGIS.DialogLoad("Dialogs/A3O8/9_OmegaOffice/ambient_JulesLosesWillaPart2");
		ToOmegaOffice = MR.Inst.GetTileActionSwapMap("99A_T3OmegaOffices_TileActionSwapMap");
		FromCeleTownCentre = MR.Inst.GetTileActionSwapMap("10B_T3OmegaOffices_TileActionSwapMap");
		ToBroadcastTower = MR.Inst.GetTileActionSwapMap("284_T3RelayTowerExterior_TileActionSwapMap");
		FromBroadcastTowerExterior = MR.Inst.GetTileActionSwapMap("23C_T3RelayTowerInterior_TileActionSwapMap");
		ChristHacksDoorSpot = MR.Inst.GetTileActionInteraction("CCE_T3RelayTowerInterior_TileActionInteraction");
		TheSignalGenerator.IsMovementDisabled = true;
		TheSignalGenerator.IsAttackingDisabled = true;
		OutsideDroid_1.gameObject.SetActive(value: false);
		OutsideDroid_2.gameObject.SetActive(value: false);
		OutsideDroid_3.gameObject.SetActive(value: false);
		OutsideDroid_4.gameObject.SetActive(value: false);
		TowerDroid_1.gameObject.SetActive(value: false);
		TowerDroid_2.gameObject.SetActive(value: false);
		TowerDroid_3.gameObject.SetActive(value: false);
		TowerDroid_4.gameObject.SetActive(value: false);
		Archi.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		Chris.gameObject.SetActive(value: false);
		Noot.gameObject.SetActive(value: false);
		Ambro.gameObject.SetActive(value: false);
		yield return null;
		MusicPlay("event:/music/tracks/basic/new savannah");
		CutsceneBegin();
		yield return CreateTimeCondition(0.7f);
		yield return HAGIS.DialogShow(Dialog_A3O8Opening);
		CutsceneEnd();
		Willa.SetTeamType(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteAndSetMainObjective(ojbConfrontJules);
		SKIP_POINT("Skiped Opening sequence");
		yield return MapWaitUntilVisible(OmegaOffice.Map);
		UIObjectives.Inst.CompleteObjective(ojbConfrontJules);
		CutsceneBegin();
		SKIP_POINT("Skiped To inside Omega Office");
		MusicStop();
		Willa.LookAt(Jules);
		Theo.LookAt(Willa, keepEyeOn: true);
		FromCeleTownCentre.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_ProdigalChild);
		yield return UnitMoveToTarget(Willa, WillaMoveTo, OctDir.Right);
		yield return UnitPlayAnimation(Jules, "CsDefaultSitOfferSeat", loop: false, updateIdle: true);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_AppreciateJules);
		yield return UnitPlayAnimation(Jules, "CsTransSitToSitLean");
		yield return UnitPlayAnimation(Jules, "CsDefaultSitLean");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSitLean");
		Jules.UpdateIdleAnim();
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_JulesWantsRespect);
		yield return UnitPlayAnimation(Jules, "CsTransSitLeanToSit");
		yield return UnitPlayAnimation(Jules, "CsDefaultSit");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		Jules.UpdateIdleAnim();
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_FluxMissile);
		SKIP_POINT("Skipped Jules confrontation dialog");
		HAGIS.DialogShow(ambient_HeartmanOhShit);
		yield return CreateTimeCondition(0.5f);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(0.7f);
		LoopingSFX EMPSfxEffect = LoopingSFXPlay("event:/sfx/script/act 3/a3o8/map flicker after emp");
		SFXPlay("event:/sfx/script/act 3/a3o8/emp hit with interference");
		yield return CreateTimeCondition(1f);
		OmegaOffice.Map.EnableEmpEffect(enabled: true);
		yield return CreateTimeCondition(3f);
		CutsceneEnd();
		MusicStop();
		EMPSfxEffect.Stop();
		if (!MR.Inst.IsSkipping())
		{
			yield return ShowRoom(Room_5);
			CutsceneBegin();
			Hartman_TeleportToPointWithLookAt(move_window, look_window);
			Hartman_SetMood(Hartman.Mood.Default);
			SFXPlay("event:/sfx/character v2/foley/unique/hartman/death");
			Hartman_PlayAnimation("DefaultDeath");
			yield return CreateTimeCondition(1f);
			Hartman_PlayAnimation("DeathPose");
			yield return CreateTimeCondition(1.5f);
			yield return Hartman_PlayAnimation("TransDeathToDefaultIdle");
			Hartman_PlayAnimation("DefaultIdle");
			yield return CreateTimeCondition(1f);
			Hartman_LookAtPoint(look_player, 1f);
			HAGIS.DialogShow(ambient_TheyFoundUs);
			yield return CreateTimeCondition(0.5f);
			yield return Hartman_MoveToPoint(move_tableFront, 1f);
			Hartman_LookAtPoint(look_player, 0.25f);
			yield return CreateTimeCondition(0.5f);
			Hartman_PlayAnimation("TransDIdleToFixTable");
			yield return CreateTimeCondition(1f);
			Hartman_PlayAnimation("FixTableIdle");
			yield return CreateTimeCondition(2f);
			Hartman_PlayAnimation("TransFixTableToDIdle");
			HAGIS.DialogShow(ambient_GetBacktoWilla);
			yield return CreateTimeCondition(1f);
			HagisLog("SHOULD OF PLAYING GET BACK TO WILLA");
			yield return HAGIS.HACK_WaitIfDialogIsNotComplete(ambient_GetBacktoWilla);
			SFXPlay("event:/sfx/script/act 1/a1o1/hollow map table power up");
			yield return CreateTimeCondition(1f);
			yield return CreateTimeCondition(1f);
			yield return ShowMap();
			CutsceneEnd();
		}
		SKIP_POINT("Skipped Cravens Room Animation");
		MusicPlay("event:/music/tracks/basic/craven glitchy");
		EMPSfxEffect.Restart();
		CutsceneBegin();
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(ambient_UnnervedWilla);
		yield return null;
		yield return UnitPlayAnimation(Willa, "TransDIdleToCIdle");
		UnitPlayAnimation(Willa, "CombatIdle", loop: true);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Willa.UpdateIdleAnim();
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: false);
		yield return HAGIS.DialogShow(Dialog_WereInTrouble);
		OmegaOffice.Map.EnableEmpEffect(enabled: false);
		EMPSfxEffect.Stop();
		CutsceneEnd();
		SKIP_POINT("Skiped Omega Office Dialog after Craven Cutscene");
		Noot.SetTeamType(UnitTeam.Type.Player);
		Ambro.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Archi);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		yield return MapGoto(BroadcastTowerOutside);
		UIObjectives.Inst.CompleteAndSetMainObjective(objBreakIntoTower);
		MusicPlay("event:/music/tracks/basic/stealth 1");
		SKIP_POINT("Skipped to Broadcast Tower");
		Archi.gameObject.SetActive(value: true);
		Margot.gameObject.SetActive(value: true);
		Chris.gameObject.SetActive(value: true);
		Noot.gameObject.SetActive(value: true);
		Ambro.gameObject.SetActive(value: true);
		ToBroadcastTower.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(ChristHacksDoorSpot.OnTriggered);
		ChristHacksDoorSpot.gameObject.SetActive(value: false);
		CutsceneBegin();
		HAGIS.DialogShow(ambient_ArchiEntrenceConsole_Path1_Chris);
		yield return CreateTimeCondition(0.5f);
		yield return UnitMoveToTarget(Chris, ChrisDoorSpot);
		Chris.LookInDirection(OctDir.Up);
		yield return UnitPlayAnimation(Chris, "CsTransDIdleToKneelHack");
		yield return UnitPlayAnimation(Chris, "CsDefaultKneelHack");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultKneelHack");
		Chris.UpdateIdleAnim();
		yield return CreateTimeCondition(0.5f);
		ChristHacksDoorSpot.gameObject.SetActive(value: false);
		ChristHacksDoorSpot.availableIn = (GC.State)0;
		Chris.SetTeamType(UnitTeam.Type.NPC);
		CutsceneEnd();
		OutsideDroid_1.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		OutsideDroid_2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		OutsideDroid_3.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		OutsideDroid_4.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(ambient_ChrisEntrenceConsole_Path1_Cont);
		yield return UnitMoveToTarget(Archi, ArchiToCover);
		SKIP_POINT("Skiped to Start of Outside Tower fight");
		yield return null;
		MusicPlay("event:/music/tracks/combat/old combat");
		CombatBegin(UnitTeam.Type.Player);
		yield return CreateOrCondition(CombatWaitUntilComplete(), TurnModeWaitForPlayerTurnStart(3u));
		yield return UnitPlayAnimation(Chris, "CsTransKneelHackToDIdle");
		yield return UnitPlayAnimation(Chris, "DefaultIdle");
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.CombatIdle);
		Chris.UpdateIdleAnim();
		Chris.SetTeamType(UnitTeam.Type.Player);
		yield return CombatWaitUntilComplete();
		ToBroadcastTower.gameObject.SetActive(value: true);
		SKIP_POINT("Skiped Outside Tower fight");
		MusicPlay("event:/music/tracks/basic/ticking tension");
		yield return MapWaitUntilVisible(BroadcastTowerInside.Map);
		FromBroadcastTowerExterior.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objSurviveDoorOpening);
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToTarget(Archi, ArchiEnterTower, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk), UnitMoveToTarget(Chris, ChrisEnterTower, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk), UnitMoveToTarget(Noot, NootEnterTower, null, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk), UnitMoveToTarget(Margot, MargotEnterTower, null, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk), UnitMoveToTarget(Ambro, AmbroEnterTower, null, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk));
		yield return HAGIS.DialogShow(ambient_TowerAnnouncer1);
		HAGIS_A3O8 hAGIS_A3O = this;
		HagletYieldTerm term = UnitMoveToTarget(Archi, ArchiCenterTower);
		HagletYieldTerm term2 = UnitMoveToTarget(Chris, ChrisGeneratorAction, OctDir.Up);
		HagletYieldTerm term3 = UnitMoveToTarget(Noot, NootCenterTower);
		HagletYieldTerm term4 = UnitMoveToTarget(Margot, MargotCenterTower);
		HAGIS_A3O8 hAGIS_A3O2 = this;
		Unit ambro = Ambro;
		UnitTarget ambroCenterTower = AmbroCenterTower;
		float? speed = Ambro.charData.movementSpeedInCombat;
		yield return hAGIS_A3O.CreateAndCondition(term, term2, term3, term4, hAGIS_A3O2.UnitMoveToTarget(ambro, ambroCenterTower, null, speed));
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Chris, "CsTransDIdleToKneelHack");
		yield return UnitPlayAnimation(Chris, "CsDefaultKneelHack");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneelHack");
		Chris.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialog_TowerChrisPresent);
		yield return UnitPlayAnimation(Chris, "CsTransKneelHackToDIdle");
		yield return UnitPlayAnimation(Chris, "DefaultIdle");
		Chris.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Chris.UpdateIdleAnim();
		UIObjectives.Inst.CompleteAndSetMainObjective(objDesotryGenerator);
		TowerDroid_1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		TowerDroid_2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		TowerDroid_3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		TowerDroid_4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		TowerDroid_3.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		TowerDroid_2.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		TowerDroid_3.gameObject.SetActive(value: true);
		TowerDroid_2.gameObject.SetActive(value: true);
		yield return CreateAndCondition(UnitMoveToTarget(TowerDroid_3, EnemyCoverLeft), UnitMoveToTarget(TowerDroid_2, EnemyCoverRight));
		CutsceneEnd();
		SKIP_POINT("Skipped Tower Figtht Start");
		MusicPlay("event:/music/tracks/combat/frenzy 2");
		CutsceneBegin();
		UnitMoveToTarget(Archi, ArchiClocktowerCover, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Run);
		UnitMoveToTarget(Noot, NootClocktowerCover, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Run);
		UnitMoveToTarget(Margot, MargotClocktowerCover, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Run);
		UnitMoveToTarget(Ambro, AmbroClocktowerCover, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Run);
		yield return null;
		yield return UnitMoveToTarget(Chris, ChrisClocktowerCover, OctDir.Up, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Run);
		CutsceneEnd();
		CombatBegin(UnitTeam.Type.Enemy);
		List<Unit> towerDroids = new List<Unit>(4) { TowerDroid_2, TowerDroid_3 };
		while (GetUnitHealthPercentage(TheSignalGenerator) > 90f)
		{
			HagletYieldTerm enemyTurnStarted = TurnModeWaitForEnemyTurnStart().Isolate();
			yield return CreateOrCondition(enemyTurnStarted, TheSignalGenerator.OnUnitSustainedDamage);
			if (!enemyTurnStarted.met)
			{
				continue;
			}
			for (int d = 0; d < towerDroids.Count; d++)
			{
				if (!towerDroids[d].IsAlive())
				{
					yield return towerDroids[d].SetCoord(towerDroids[d].spawnCoords);
					towerDroids[d].Revive();
				}
			}
		}
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_TowerAnnouncer2);
		yield return HAGIS.DialogShow(ambient_TowerAnnouncer3);
		CutsceneEnd();
		while (GetUnitHealthPercentage(TheSignalGenerator) > 60f)
		{
			HagletYieldTerm enemyTurnStarted2 = TurnModeWaitForEnemyTurnStart().Isolate();
			yield return CreateOrCondition(enemyTurnStarted2, TheSignalGenerator.OnUnitSustainedDamage);
			if (!enemyTurnStarted2.met)
			{
				continue;
			}
			for (int d2 = 0; d2 < towerDroids.Count; d2++)
			{
				if (!towerDroids[d2].IsAlive())
				{
					yield return towerDroids[d2].SetCoord(towerDroids[d2].spawnCoords);
					towerDroids[d2].Revive();
				}
			}
		}
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_TowerAnnouncer4);
		TowerDroid_1.gameObject.SetActive(value: true);
		towerDroids.Add(TowerDroid_1);
		CutsceneEnd();
		while (GetUnitHealthPercentage(TheSignalGenerator) > 40f)
		{
			HagletYieldTerm enemyTurnStarted3 = TurnModeWaitForEnemyTurnStart().Isolate();
			yield return CreateOrCondition(enemyTurnStarted3, TheSignalGenerator.OnUnitSustainedDamage);
			if (!enemyTurnStarted3.met)
			{
				continue;
			}
			for (int d3 = 0; d3 < towerDroids.Count; d3++)
			{
				if (!towerDroids[d3].IsAlive())
				{
					yield return towerDroids[d3].SetCoord(towerDroids[d3].spawnCoords);
					towerDroids[d3].Revive();
				}
			}
		}
		CutsceneBegin();
		yield return HAGIS.DialogShow(ambient_TowerAnnouncer5);
		TowerDroid_4.gameObject.SetActive(value: true);
		towerDroids.Add(TowerDroid_4);
		CutsceneEnd();
		while (GetUnitHealthPercentage(TheSignalGenerator) > 0f)
		{
			HagletYieldTerm enemyTurnStarted4 = TurnModeWaitForEnemyTurnStart().Isolate();
			yield return CreateOrCondition(enemyTurnStarted4, TheSignalGenerator.OnDeathComplete);
			if (!enemyTurnStarted4.met)
			{
				continue;
			}
			for (int d4 = 0; d4 < towerDroids.Count; d4++)
			{
				if (!towerDroids[d4].IsAlive())
				{
					yield return towerDroids[d4].SetCoord(towerDroids[d4].spawnCoords);
					towerDroids[d4].Revive();
				}
			}
		}
		yield return EndTurnMode();
		MusicStop();
		CutsceneBegin();
		UIObjectives.Inst.CompleteObjective(objDesotryGenerator);
		yield return null;
		SKIP_POINT("Skipped to generator defeated");
		for (int num = 3; num >= 0; num--)
		{
			if (!towerDroids[num].IsAlive())
			{
				towerDroids.RemoveAt(num);
			}
		}
		int r = 0;
		while (true)
		{
			for (int i = 0; i < towerDroids.Count; i++)
			{
				towerDroids[i].HideStatusBar();
				PSC.Inst.Play(ParticleTypes.BulletImpact, towerDroids[i].map, towerDroids[i].coord);
			}
			HagletYieldTerm droidsFlinched = DontWait();
			for (int j = 0; j < towerDroids.Count; j++)
			{
				droidsFlinched = CreateAndCondition(droidsFlinched, UnitPlayAnimation(towerDroids[j], "CombatHit"));
			}
			yield return droidsFlinched;
			int num2;
			r = (num2 = r + 1);
			if (num2 == 3)
			{
				break;
			}
			yield return CreateTimeCondition(UnityEngine.Random.Range(0.15f, 0.5f));
		}
		HagletYieldTerm droidsCollapsed = DontWait();
		for (int k = 0; k < towerDroids.Count; k++)
		{
			towerDroids[k].unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
			droidsCollapsed = CreateAndCondition(droidsCollapsed, UnitPlayAnimation(towerDroids[k], "TransCIdleToCCrouch"));
		}
		yield return droidsCollapsed;
		SKIP_POINT("Skipped Tower Fight End");
		yield return CreateAndCondition(UnitMoveToTarget(Archi, ArchiCenterTower), UnitMoveToTarget(Chris, ChrisEnterTower), UnitMoveToTarget(Noot, NootCenterTower), UnitMoveToTarget(Margot, MargotCenterTower), UnitMoveToTarget(Ambro, AmbroCenterTower));
		Archi.LookInDirection(OctDir.Right);
		yield return CreateTimeCondition(1f);
		Archi.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(2f);
		UnitPlayAnimation(Archi, "DefaultTalk");
		yield return null;
		yield return HAGIS.DialogShow(ambient_ArchiWoohoo);
		MusicPlay("event:/music/tracks/basic/drone 1");
		UnitPlayAnimation(TowerDroid_1, "TransCCrouchToCIdle");
		TowerDroid_1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateTimeCondition(0.4f);
		UnitPlayAnimation(TowerDroid_2, "TransCCrouchToCIdle");
		TowerDroid_2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateTimeCondition(0.4f);
		UnitPlayAnimation(TowerDroid_3, "TransCCrouchToCIdle");
		TowerDroid_3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateTimeCondition(0.4f);
		UnitPlayAnimation(TowerDroid_4, "TransCCrouchToCIdle");
		TowerDroid_4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return CreateTimeCondition(0.4f);
		yield return CreateTimeCondition(0.4f);
		TowerDroid_1.LookAt(Archi);
		TowerDroid_2.LookAt(Chris);
		TowerDroid_3.LookAt(Ambro);
		TowerDroid_4.LookAt(Margot);
		yield return CreateTimeCondition(0.5f);
		Archi.LookAt(TowerDroid_1);
		Chris.LookAt(TowerDroid_2);
		Ambro.LookAt(TowerDroid_3);
		Margot.LookAt(TowerDroid_4);
		Noot.LookAt(TowerDroid_2);
		yield return null;
		UnitPlayAnimation(TowerDroid_1, "TransCIdleToAIdle");
		TowerDroid_1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		UnitPlayAnimation(TowerDroid_2, "TransCIdleToAIdle");
		TowerDroid_2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		UnitPlayAnimation(TowerDroid_3, "TransCIdleToAIdle");
		TowerDroid_3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		UnitPlayAnimation(TowerDroid_4, "TransCIdleToAIdle");
		TowerDroid_4.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		yield return HAGIS.DialogShow(ambient_DroidsLiveAgain);
		yield return CreateTimeCondition(0.4f);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Ambro.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		GC.Inst.SetRPGLeader(Willa);
		yield return MapGoto(OmegaOffice);
		MusicPlay("event:/music/tracks/basic/jules theme", 0f, 0.2f);
		SKIP_POINT("Skipped to Omega Office again");
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(dialog_DroidsNotDefeatedYet);
		yield return UnitPlayAnimation(Jules, "CsDefaultSitShowAug", loop: false, updateIdle: true);
		yield return HAGIS.DialogShow(dialog_DroidsNotDefeatedYetPart2);
		Willa.LookAt(Jules);
		yield return UnitPlayAnimation(Willa, "TransCIdleToAIdle");
		yield return UnitPlayAnimation(Willa, "CombatAimIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		Willa.UpdateIdleAnim();
		Theo.LookAt(Willa);
		yield return UnitPlayAnimation(Theo, "TransDIdleToCIdle");
		yield return UnitPlayAnimation(Theo, "TransCIdleToAIdle");
		UnitPlayAnimation(Theo, "CombatAimIdle");
		Theo.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		Theo.UpdateIdleAnim();
		yield return HAGIS.DialogShow(ambient_WillaShutEmDown);
		yield return CreateTimeCondition(3f);
		yield return UnitPlayAnimation(Jules, "CsDefaultSitCalmTheo");
		SFXPlay("event:/sfx/character v2/foley/unique/theodore wells/lower gun");
		yield return UnitPlayAnimation(Theo, "TransAIdleToCIdle");
		yield return UnitPlayAnimation(Theo, "CombatIdle");
		yield return UnitPlayAnimation(Theo, "TransCIdleToDIdle");
		yield return UnitPlayAnimation(Theo, "DefaultIdle");
		Theo.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Theo.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialog_JulesVictory);
		yield return HAGIS.DialogShow(dialog_ItsOver_Response);
		MusicStop();
		yield return UnitPlayAnimation(Willa, "TransAIdleToCIdle");
		yield return UnitPlayAnimation(Willa, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialog_ItsOver_Response1_Willa);
		yield return UnitPlayAnimation(Willa, "TransCIdleToDIdle");
		yield return UnitPlayAnimation(Willa, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(dialog_ItsOver_Response2_Willa);
		yield return CreateTimeCondition(1f);
		Willa.LookInDirection(OctDir.Left);
		yield return UnitMoveToTarget(Willa, FromCeleTownCentre);
		Willa.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(ambient_JulesLosesWilla);
		Willa.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(1f);
		Willa.gameObject.SetActive(value: false);
		OmegaOffice.Map.EnableEmpEffect(enabled: true);
		yield return HAGIS.DialogShow(ambient_JulesLosesWillaPart2);
		yield return CreateTimeCondition(1f);
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
	}
}
public class HAGIS_A3O8_GeneratorFight : HAGIS
{
	private Unit TowerDroid_1;

	private Unit TowerDroid_2;

	private Unit TowerDroid_3;

	private Unit TowerDroid_4;

	private HagletTrigger stopSpawningDroids = new HagletTrigger();

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		TowerDroid_1 = GC.Inst.GetUnitWithId("68B_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_2 = GC.Inst.GetUnitWithId("34F_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_3 = GC.Inst.GetUnitWithId("420_T3RelayTowerInterior_UnitSpawn");
		TowerDroid_4 = GC.Inst.GetUnitWithId("62D_T3RelayTowerInterior_UnitSpawn");
		v2i droid_1SpawnCoord = TowerDroid_1.coord;
		v2i droid_2SpawnCoord = TowerDroid_2.coord;
		v2i droid_3SpawnCoord = TowerDroid_3.coord;
		v2i droid_4SpawnCoord = TowerDroid_4.coord;
		TowerDroid_1.gameObject.SetActive(value: false);
		TowerDroid_2.gameObject.SetActive(value: false);
		TowerDroid_3.gameObject.SetActive(value: false);
		TowerDroid_4.gameObject.SetActive(value: false);
		yield return null;
		HagletYieldTerm wasStopSpawningTriggered = Wait.Until(stopSpawningDroids);
		while (true)
		{
			yield return CreateOrCondition(wasStopSpawningTriggered, TowerDroid_1.OnDeathComplete, TowerDroid_2.OnDeathComplete, TowerDroid_3.OnDeathComplete, TowerDroid_4.OnDeathComplete);
			if (wasStopSpawningTriggered.met)
			{
				break;
			}
			if (TowerDroid_1.HP <= 0)
			{
				yield return TowerDroid_1.SetCoord(droid_1SpawnCoord);
				TowerDroid_1.Revive();
			}
			if (TowerDroid_2.HP <= 0)
			{
				yield return TowerDroid_2.SetCoord(droid_2SpawnCoord);
				TowerDroid_2.Revive();
			}
			if (TowerDroid_3.HP <= 0)
			{
				yield return TowerDroid_3.SetCoord(droid_3SpawnCoord);
				TowerDroid_3.Revive();
			}
			if (TowerDroid_4.HP <= 0)
			{
				yield return TowerDroid_4.SetCoord(droid_4SpawnCoord);
				TowerDroid_4.Revive();
			}
		}
	}

	public void StopSpawningDroids()
	{
		stopSpawningDroids.Trigger();
	}
}
public class HAGIS_A3S1 : HAGIS
{
	private Unit Willa;

	private Unit Theo;

	private Unit Jules;

	private Unit Captain;

	private Unit Bernard;

	private Unit MineGuard;

	private Unit MineGuard2;

	private Unit MineGuard3;

	private Unit Droid;

	private Unit MineGuard4;

	private Unit MineGuard5;

	private Unit Droid2;

	private Unit TuckerTriggerman;

	private Unit TuckerTriggerman2;

	private UnitTarget WillaMoveTo;

	private UnitTarget WillaMoveTo2;

	private UnitTarget WillaMoveTo3;

	private UnitTarget JulesMoveTo;

	private UnitTarget JulesMoveTo2;

	private UnitTarget WillaEnterTo;

	private UnitTarget BernardMoveTo;

	private UnitTarget MineGuardMoveTo;

	private UnitTarget WillaMoveToCover;

	private UnitTarget MoveToMineEntrance;

	private UnitTarget WillaGetGun;

	private UnitTarget StepBackPoint;

	private UnitTarget WillaCoverPoint;

	private UnitTarget BernardCoverPoint;

	private UnitTarget BernardCollapsePoint;

	private UnitTarget WillaKneelPoint;

	private UnitTarget WillaLadderExit;

	private UnitTarget WillaMoveFromManHole;

	private UnitTarget WillaMoveBackTo;

	private UnitTarget WillaEscapepoint;

	private UnitTarget WillaCollapses;

	private UnitTarget BlockTarget;

	private UnitTarget BernardCover;

	private UnitTarget PatrolMoveTo;

	private UnitTarget PatrolMoveTo2;

	private TileBlockDynamic LadderBlocker;

	private TileBlockDynamic LadderBlocker2;

	private TileActionHotspot StaticSkinSign;

	private TileActionSwapMap ElevatorToHolding;

	private TileActionSwapMap HoldingToElevator;

	private TileActionSwapMap ElevatorToMine;

	private TileActionSwapMap MineToElevator;

	private TileActionSwapMap MineToInfirmary;

	private TileActionSwapMap InfirmaryToMine;

	private TileActionSwapMap MineToSecuritytunnel;

	private TileActionSwapMap SecurityTunnelToMine;

	private TileActionSwapMap SecurityTunnelToLadder;

	private TileActionSwapMap LadderToLightHouse;

	private TileActionSwapMap LightHouseToLadder;

	private TileActionSwapMap LightHouseToFreighter;

	private TileActionSwapMap FromLighthouse;

	private TileActionInteraction WeaponLockerInteraction;

	private TileActionInteraction StowawaysPosterInteraction;

	private TileActionInteraction TosecurityTunnel;

	private TileTrigger TT_DontGiveUp;

	private TileActionDialog DroidInteraction;

	private TileActionDialog DoorExitInteraction1;

	private TileActionDialog DoorExitInteraction2;

	private TileActionDialog ItsSoHot;

	private TileActionDialog NoCallButton;

	private TileActionDialog RadiationGear;

	private TileActionDialog CorpseInteraction;

	private TileActionDialog CorpseInteraction2;

	private TileActionDialog SeizedProperty;

	private TileActionDialog FarWallInteraction;

	private TileActionDialog LighthouseInteraction;

	private TileActionDialog Manholeinteraction;

	private TileActionDialog RowBoatInteraction;

	private DialogData Ambient_CanYouHearMe;

	private DialogData Ambient_FairWellCitizen;

	private DialogData Ambient_HehHeh;

	private DialogData Ambient_TheyTookHerEarpiece;

	private DialogData Dialog_AnArmyOfAndroids;

	private DialogData Dialog_ClimbAnymountain;

	private DialogData Dialog_Dammit;

	private DialogData Dialog_IOnlyWantedTheBestForYou;

	private DialogData Dialog_IPromise;

	private DialogData Dialog_IWishThingsWereDifferent;

	private DialogData Dialog_JulesAvalon;

	private DialogData Dialog_MyGrandMotherLeft;

	private DialogData Dialog_SitBeHave;

	private DialogData Dialog_TakeHerToTheMines;

	private DialogData Dialog_WeNeedHerOnSide;

	private DialogData Ambient_DontGiveUp;

	private DialogData Ambient_DropIt;

	private DialogData Ambient_GetAway;

	private DialogData Ambient_HolyShit;

	private DialogData Ambient_InmateIsArmed;

	private DialogData Ambient_ItsSoHot;

	private DialogData Ambient_RadiationGear;

	private DialogData Ambient_TheresNoCallButton;

	private DialogData Ambient_YourShiftStarts;

	private DialogData Ambient_RadiationSickness;

	private DialogData Ambient_ComeOn;

	private DialogData Dialog_CravenWhatsThrough;

	private DialogData Dialog_DontLetMeDie;

	private DialogData Dialog_LetsGoToWork;

	private DialogData Dialog_MoreComing;

	private DialogData Dialog_TheIntercom;

	private DialogData Dialog_ThorneThisWay;

	private DialogData Dialog_WePromise;

	private DialogData Dialog_WhatDoWeDo;

	private DialogData Dialog_WhatDoWeDo2;

	private DialogData Dialog_WhatsThroughHere;

	private DialogData Dialog_WhatDidYouDo;

	private DialogData Ambient_Corpse1;

	private DialogData Ambient_Corpse2;

	private DialogData Ambient_RadiationSign;

	private DialogData Dialog_AnAnarchist;

	private DialogData Dialog_Dad;

	private DialogData Dialog_OnYourFeet;

	private DialogData Dialog_WhatHappened;

	private DialogData Dialog_YouChangedYourHair;

	private DialogData Dialog_RelievedSigh;

	private DialogData Dialog_LetMeHelp;

	private DialogData Dialog_YouHaveAugments;

	private DialogData Dialog_ThatWasMe;

	private DialogData Dialog_TheBioimager;

	private DialogData Dialog_TryAgain;

	private DialogData Dialog_ThatsIt;

	private DialogData Ambient_OhDad;

	private DialogData Ambient_SeizedProperty;

	private DialogData Ambient_TheresNothing;

	private DialogData Dialog_HeGone;

	private DialogData Dialog_WereSafe;

	private DialogData Dialog_WeFoundIt;

	private DialogData Ambient_Huh_Huh;

	private DialogData Dialog_PleaseNotNow;

	private DialogData Ambient_ManholeExit;

	private DialogData Ambeint_RowBoat;

	private DialogData Ambient_TheEtemenCompany;

	private DialogData Dialog_AFreightersComing;

	private DialogData Dialog_BecauseWeCare;

	private DialogData Dialog_HeresYourRide;

	private DialogData Dialog_OnlyBeingHonest;

	private DialogData Dialog_ThereWasNoOneElse;

	private DialogData Dialog_WhatTheHell;

	private DialogData Dialog_YouCouldPretend;

	private DialogData Dialog_YouRemember;

	private DialogData Dialog_LeaveTheIsland;

	private DialogData Dialog_DontInvolveYou;

	private DialogData Dialog_AsLongAs;

	private DialogData Dialog_AsLongAsYouUnderstand;

	private DialogData Dialog_FortyHours;

	private DialogData Dialog_GetOutOfThere;

	private DialogData Dialog_ThanksForYourHonesty;

	private DialogData Dialog_ThanksForYourKindess;

	private DialogData Dialog_WeTriedBeingGentle;

	private DialogData Dialog_WeTriedBeingHonest;

	private string objFindAWayOut = "OBJECTIVES_A3S1_01";

	private string objEscapeTheMine = "OBJECTIVES_A3S1_02";

	private string objLeaveTheIsland = "OBJECTIVES_A3S1_03";

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = 2f;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		RoomSceneMeta Room_4 = GetRoomMeta("ROOM_Penthouse_04");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_tableFixing = GetHartmanMovementPoint("M_TableFixing");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		UIBiometricImager biometricImager = MR.Inst.GetComponentInChildren<UIBiometricImager>();
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint look_Table = GetHartmanLookAtPoint("L_Table");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Photo = GetHartmanLookAtPoint("L_AshelyPhoto");
		HartmanLookAtPoint look_Safe = GetHartmanLookAtPoint("L_Safe");
		UIButtonHaglet button_HolomapTurnOn = GetUIButtonHaglet("P_Holomap");
		UIButtonHaglet button_UseBioImager = GetUIButtonHaglet("P_BioImager");
		UIButtonHaglet button_UseBioImager2 = GetUIButtonHaglet("P_BioImager2");
		LogicRoot MineElevator = GetLogicUsingArtName("T1RotgutPrison_Elevator");
		LogicRoot InterrogationCell = GetLogicUsingArtName("T1RotgutPrison_InterrogationCell");
		LogicRoot MineCore = GetLogicUsingArtName("T1MineCore");
		LogicRoot Infirmary = GetLogicUsingArtName("T1Rotgut_Infirmary");
		LogicRoot HightSecurityTunnel = GetLogicUsingArtName("T1MineHighSecurityTunnel");
		LogicRoot LadderToFreedom = GetLogicUsingArtName("T1LadderToFreedom");
		LogicRoot LighthouseIsland = GetLogicUsingArtName("T1LightHouseIsland");
		LogicRoot FreighterDeck = GetLogicUsingArtName("T1FreighterDeck");
		Willa = GC.Inst.GetUnitWithId("AFF_T1RotgutPrison_Elevator_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("61E_T1RotgutPrison_Elevator_UnitSpawn");
		Jules = GC.Inst.GetUnitWithId("739_T1RotgutPrison_InterrogationCell_UnitSpawn");
		Bernard = GC.Inst.GetUnitWithId("364_T1Rotgut_Infirmary_UnitSpawn");
		MineGuard = GC.Inst.GetUnitWithId("087_T1MineCore_UnitSpawn");
		MineGuard2 = GC.Inst.GetUnitWithId("0F3_T1MineCore_UnitSpawn");
		MineGuard3 = GC.Inst.GetUnitWithId("54D_T1MineCore_UnitSpawn");
		Droid = GC.Inst.GetUnitWithId("3AE_T1MineCore_UnitSpawn");
		MineGuard4 = GC.Inst.GetUnitWithId("8A0_T1MineHighSecurityTunnel_UnitSpawn");
		MineGuard5 = GC.Inst.GetUnitWithId("009_T1MineHighSecurityTunnel_UnitSpawn");
		Droid2 = GC.Inst.GetUnitWithId("AAA_T1MineHighSecurityTunnel_UnitSpawn");
		TuckerTriggerman = GC.Inst.GetUnitWithId("67A_T1FreighterDeck_UnitSpawn");
		TuckerTriggerman2 = GC.Inst.GetUnitWithId("828_T1FreighterDeck_UnitSpawn");
		TileActionInteraction speaker = MR.Inst.GetTileActionInteraction("8D2_T1RotgutPrison_InterrogationCell_TileActionInteraction");
		TileActionInteraction speakerThrown = MR.Inst.GetTileActionInteraction("BF1_T1RotgutPrison_InterrogationCell_TileActionInteraction");
		WillaMoveTo = MR.Inst.GetUnitTarget("E5A_T1RotgutPrison_InterrogationCell_UnitTarget");
		WillaMoveTo2 = MR.Inst.GetUnitTarget("035_T1RotgutPrison_InterrogationCell_UnitTarget");
		WillaMoveTo3 = MR.Inst.GetUnitTarget("F0F_T3OmegaOffices_UnitTarget");
		JulesMoveTo = MR.Inst.GetUnitTarget("F9D_T1RotgutPrison_InterrogationCell_UnitTarget");
		JulesMoveTo2 = MR.Inst.GetUnitTarget("C4B_T1RotgutPrison_InterrogationCell_UnitTarget");
		WillaEnterTo = MR.Inst.GetUnitTarget("68C_T1MineCore_UnitTarget");
		BernardMoveTo = MR.Inst.GetUnitTarget("08A_T1MineCore_UnitTarget");
		MineGuardMoveTo = MR.Inst.GetUnitTarget("463_T1MineCore_UnitTarget");
		WillaMoveToCover = MR.Inst.GetUnitTarget("E95_T1MineCore_UnitTarget");
		MoveToMineEntrance = MR.Inst.GetUnitTarget("723_T1MineCore_UnitTarget");
		WillaGetGun = MR.Inst.GetUnitTarget("5D4_T1MineCore_UnitTarget");
		BernardCover = MR.Inst.GetUnitTarget("957_T1MineCore_UnitTarget");
		StepBackPoint = MR.Inst.GetUnitTarget("3F4_T1Rotgut_Infirmary_UnitTarget");
		WillaCoverPoint = MR.Inst.GetUnitTarget("546_T1MineHighSecurityTunnel_UnitTarget");
		BernardCoverPoint = MR.Inst.GetUnitTarget("F52_T1MineHighSecurityTunnel_UnitTarget");
		BernardCollapsePoint = MR.Inst.GetUnitTarget("885_T1MineHighSecurityTunnel_UnitTarget");
		WillaKneelPoint = MR.Inst.GetUnitTarget("DD7_T1MineHighSecurityTunnel_UnitTarget");
		WillaLadderExit = MR.Inst.GetUnitTarget("673_T1MineHighSecurityTunnel_UnitTarget");
		BlockTarget = MR.Inst.GetUnitTarget("174_T1MineHighSecurityTunnel_UnitTarget");
		UnitTarget sfx_earpiece_turn_on = MR.Inst.GetUnitTarget("68C_T1MineCore_UnitTarget");
		UnitTarget sfx_craven_unlocks_high_security_tunnel_door = MR.Inst.GetUnitTarget("88F_T1MineCore_UnitTarget");
		WillaMoveFromManHole = MR.Inst.GetUnitTarget("CE0_T1LightHouseIsland_UnitTarget");
		WillaMoveBackTo = MR.Inst.GetUnitTarget("D43_T1LightHouseIsland_UnitTarget");
		WillaEscapepoint = MR.Inst.GetUnitTarget("C9F_T1FreighterDeck_UnitTarget");
		WillaCollapses = MR.Inst.GetUnitTarget("DE6_T1FreighterDeck_UnitTarget");
		PatrolMoveTo = MR.Inst.GetUnitTarget("8DE_T1FreighterDeck_UnitTarget");
		PatrolMoveTo2 = MR.Inst.GetUnitTarget("224_T1FreighterDeck_UnitTarget");
		LadderBlocker = MR.Inst.GetTileBlockDynamic("906_T1MineHighSecurityTunnel_TileBlockDynamic");
		LadderBlocker2 = MR.Inst.GetTileBlockDynamic("E8C_T1MineHighSecurityTunnel_TileBlockDynamic");
		StaticSkinSign = MR.Inst.GetTileActionHotspot("A95_T1MineCore_TileActionHotspot");
		ElevatorToHolding = MR.Inst.GetTileActionSwapMap("10E_T1RotgutPrison_Elevator_TileActionSwapMap");
		HoldingToElevator = MR.Inst.GetTileActionSwapMap("2F3_T1RotgutPrison_InterrogationCell_TileActionSwapMap");
		ElevatorToMine = MR.Inst.GetTileActionSwapMap("7AE_T1RotgutPrison_Elevator_TileActionSwapMap");
		MineToElevator = MR.Inst.GetTileActionSwapMap("F6B_T1MineCore_TileActionSwapMap");
		MineToInfirmary = MR.Inst.GetTileActionSwapMap("796_T1MineCore_TileActionSwapMap");
		InfirmaryToMine = MR.Inst.GetTileActionSwapMap("E92_T1Rotgut_Infirmary_TileActionSwapMap");
		MineToSecuritytunnel = MR.Inst.GetTileActionSwapMap("C94_T1MineCore_TileActionSwapMap");
		SecurityTunnelToMine = MR.Inst.GetTileActionSwapMap("C77_T1MineHighSecurityTunnel_TileActionSwapMap");
		SecurityTunnelToLadder = MR.Inst.GetTileActionSwapMap("4D2_T1MineHighSecurityTunnel_TileActionSwapMap");
		LadderToLightHouse = MR.Inst.GetTileActionSwapMap("338_T1LadderToFreedom_TileActionSwapMap");
		LightHouseToLadder = MR.Inst.GetTileActionSwapMap("3BB_T1LightHouseIsland_TileActionSwapMap");
		LightHouseToFreighter = MR.Inst.GetTileActionSwapMap("28B_T1LightHouseIsland_TileActionSwapMap");
		FromLighthouse = MR.Inst.GetTileActionSwapMap("4D0_T1FreighterDeck_TileActionSwapMap");
		TT_DontGiveUp = MR.Inst.GetTileTrigger("8A4_T1MineCore_TileTrigger");
		TosecurityTunnel = MR.Inst.GetTileActionInteraction("DC8_T1MineCore_TileActionInteraction");
		WeaponLockerInteraction = MR.Inst.GetTileActionInteraction("5BA_T1MineCore_TileActionInteraction");
		StowawaysPosterInteraction = MR.Inst.GetTileActionInteraction("8BE_T1FreighterDeck_TileActionInteraction");
		DoorExitInteraction1 = MR.Inst.GetTileActionDialog("016_T1MineCore_TileActionDialog");
		DoorExitInteraction2 = MR.Inst.GetTileActionDialog("008_T1MineCore_TileActionDialog");
		DroidInteraction = MR.Inst.GetTileActionDialog("EF5_T1MineCore_TileActionDialog");
		ItsSoHot = MR.Inst.GetTileActionDialog("6A4_T1MineCore_TileActionDialog");
		NoCallButton = MR.Inst.GetTileActionDialog("65A_T1MineCore_TileActionDialog");
		RadiationGear = MR.Inst.GetTileActionDialog("479_T1MineCore_TileActionDialog");
		CorpseInteraction = MR.Inst.GetTileActionDialog("50C_T1Rotgut_Infirmary_TileActionDialog");
		CorpseInteraction2 = MR.Inst.GetTileActionDialog("3CD_T1Rotgut_Infirmary_TileActionDialog");
		SeizedProperty = MR.Inst.GetTileActionDialog("112_T1MineHighSecurityTunnel_TileActionDialog");
		FarWallInteraction = MR.Inst.GetTileActionDialog("592_T1MineHighSecurityTunnel_TileActionDialog");
		LighthouseInteraction = MR.Inst.GetTileActionDialog("E94_T1LightHouseIsland_TileActionDialog");
		Manholeinteraction = MR.Inst.GetTileActionDialog("19A_T1LightHouseIsland_TileActionDialog");
		RowBoatInteraction = MR.Inst.GetTileActionDialog("0B1_T1LightHouseIsland_TileActionDialog");
		Ambient_CanYouHearMe = HAGIS.DialogLoad("Dialogs/A3S1/MineElevator/Ambient_CanYouHearMe");
		Ambient_FairWellCitizen = HAGIS.DialogLoad("Dialogs/A3S1/MineElevator/Ambient_FairwellCitizen");
		Ambient_HehHeh = HAGIS.DialogLoad("Dialogs/A3S1/MineElevator/Ambient_HehHeh");
		Ambient_TheyTookHerEarpiece = HAGIS.DialogLoad("Dialogs/A3S1/MineElevator/Ambient_TheyTookHerEarpiece");
		Dialog_AnArmyOfAndroids = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_AnArmyOfAndroids");
		Dialog_ClimbAnymountain = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_ClimbAnyMountain");
		Dialog_Dammit = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_Dammit");
		Dialog_IOnlyWantedTheBestForYou = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_IOnlyWantedTheBEsForYou");
		Dialog_IPromise = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_IPromise");
		Dialog_IWishThingsWereDifferent = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_IWishThingsWereDifferent");
		Dialog_JulesAvalon = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_JulesAvalon");
		Dialog_MyGrandMotherLeft = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_MyGrandMotherLeft");
		Dialog_SitBeHave = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_SitBehave");
		Dialog_TakeHerToTheMines = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_TakeHerToTheMines");
		Dialog_WeNeedHerOnSide = HAGIS.DialogLoad("Dialogs/A3S1/InterrogationCell/Dialog_WeNeedHerOnSide");
		Ambient_DontGiveUp = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_DontGiveUp");
		Ambient_DropIt = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_DropIt");
		Ambient_GetAway = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_GetAway");
		Ambient_HolyShit = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_HolyShit");
		Ambient_InmateIsArmed = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_InMateIsArmed");
		Ambient_ItsSoHot = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_ItsSoHot");
		Ambient_RadiationGear = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_RadiationGear");
		Ambient_TheresNoCallButton = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_TheresNoCallButton");
		Ambient_YourShiftStarts = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_YourShiftStarts");
		Ambient_ComeOn = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_ComeOn");
		Ambient_RadiationSickness = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_RadiationSickness");
		Dialog_CravenWhatsThrough = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_CravensWhatsThrough");
		Dialog_DontLetMeDie = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_DontLetMeDie");
		Dialog_LetsGoToWork = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_LetsGoToWork");
		Dialog_MoreComing = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_MoreComing");
		Dialog_TheIntercom = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_TheIntercom");
		Dialog_ThorneThisWay = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_ThorneThisWay");
		Dialog_WePromise = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_WePromise");
		Dialog_WhatDoWeDo = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_WhatDoWeDo");
		Dialog_WhatDoWeDo2 = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_WhatDoWeDo2");
		Dialog_WhatsThroughHere = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_WhatsThroughHere");
		Dialog_WhatDidYouDo = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Dialog_WhatDidYouDo");
		Ambient_Corpse1 = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Ambient_Corpse1");
		Ambient_Corpse2 = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Ambient_Corpse2");
		Ambient_RadiationSign = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Ambient_RadiationSign");
		Dialog_AnAnarchist = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_AnAnarchist");
		Dialog_Dad = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_Dad");
		Dialog_OnYourFeet = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_OnYourFeet");
		Dialog_WhatHappened = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_WhatHappened");
		Dialog_YouChangedYourHair = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_YouChangedYourHair");
		Dialog_LetMeHelp = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_LetMeHelp");
		Dialog_YouHaveAugments = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_YouHaveAugments");
		Dialog_RelievedSigh = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Dialog_RelievedSigh");
		Ambient_Huh_Huh = HAGIS.DialogLoad("Dialogs/A3S1/Infirmary/Ambient_Huh-Huh");
		Dialog_ThatWasMe = HAGIS.DialogLoad("Dialogs/A3S1/CravensRoom/Dialog_ThatWasMe");
		Dialog_TheBioimager = HAGIS.DialogLoad("Dialogs/A3S1/CravensRoom/Dialog_TheBioimager");
		Dialog_TryAgain = HAGIS.DialogLoad("Dialogs/A3S1/CravensRoom/Dialog_TryAgain");
		Dialog_ThatsIt = HAGIS.DialogLoad("Dialogs/A3S1/CravensRoom/Dialog_ThatsIt");
		Ambient_OhDad = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Ambient_OhDad");
		Ambient_SeizedProperty = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Ambient_SeizedProperty");
		Ambient_TheresNothing = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Ambient_TheresNothing");
		Dialog_HeGone = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Dialog_HeGone");
		Dialog_WereSafe = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Dialog_OnYourFeet");
		Dialog_WeFoundIt = HAGIS.DialogLoad("Dialogs/A3S1/HighSecurityTunnel/Dialog_WeFoundIt");
		Dialog_PleaseNotNow = HAGIS.DialogLoad("Dialogs/A3S1/LadderFromMine/Dialog_PleaseNotNow");
		Ambient_ManholeExit = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Ambient_ManholeExit");
		Ambeint_RowBoat = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Ambient_Rowboat");
		Ambient_TheEtemenCompany = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Ambient_TheEtemenCompany");
		Dialog_AFreightersComing = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_AFreightersComing");
		Dialog_BecauseWeCare = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_BecasueWeCare");
		Dialog_HeresYourRide = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_HeresYourRide");
		Dialog_OnlyBeingHonest = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_OnlyBeingHonest");
		Dialog_ThereWasNoOneElse = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_ThereWasNoOneElse");
		Dialog_WhatTheHell = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_WhatTheHell");
		Dialog_YouCouldPretend = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_YouCouldPretend");
		Dialog_YouRemember = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_YouRemember");
		Dialog_LeaveTheIsland = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_LeaveViaRowboat");
		Dialog_DontInvolveYou = HAGIS.DialogLoad("Dialogs/A3S1/LightHouseIsland/Dialog_DontInvolveYou");
		Dialog_AsLongAs = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_AsLongAs");
		Dialog_AsLongAsYouUnderstand = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_AsLongAsYouUnderstand");
		Dialog_FortyHours = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_FortyHours");
		Dialog_GetOutOfThere = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_GetOutOfThere");
		Dialog_ThanksForYourHonesty = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_ThanksForYourHonesty");
		Dialog_ThanksForYourKindess = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_ThanksForYourKindness");
		Dialog_WeTriedBeingGentle = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_WeTriedBeingGentle");
		Dialog_WeTriedBeingHonest = HAGIS.DialogLoad("Dialogs/A3S1/FreighterDeck/Dialog_WeTriedBeingHonest");
		elevatorWalls = MineElevator.Map.GetComponentInChildren<ScrollingWalls>();
		button_HolomapTurnOn.gameObject.SetActive(value: false);
		Bernard.SetVariant("Sick");
		Willa.SetVariant("Augmented");
		MineToSecuritytunnel.gameObject.SetActive(value: false);
		SecurityTunnelToLadder.gameObject.SetActive(value: false);
		ElevatorToHolding.gameObject.SetActive(value: false);
		ElevatorToMine.gameObject.SetActive(value: false);
		DoorExitInteraction1.gameObject.SetActive(value: false);
		DoorExitInteraction2.gameObject.SetActive(value: false);
		MineGuard.gameObject.SetActive(value: false);
		MineGuard2.gameObject.SetActive(value: false);
		MineGuard3.gameObject.SetActive(value: false);
		Droid.gameObject.SetActive(value: false);
		TuckerTriggerman.gameObject.SetActive(value: false);
		TuckerTriggerman2.gameObject.SetActive(value: false);
		Jules.gameObject.SetActive(value: false);
		WeaponLockerInteraction.gameObject.SetActive(value: false);
		TosecurityTunnel.gameObject.SetActive(value: false);
		LightHouseToFreighter.gameObject.SetActive(value: false);
		RowBoatInteraction.gameObject.SetActive(value: false);
		TT_DontGiveUp.gameObject.SetActive(value: false);
		button_UseBioImager2.gameObject.SetActive(value: false);
		BlockTarget.gameObject.SetActive(value: false);
		speakerThrown.gameObject.SetActive(value: false);
		button_UseBioImager.gameObject.SetActive(value: false);
		button_UseBioImager2.gameObject.SetActive(value: false);
		yield return null;
		MusicStop();
		HAGIS.ToggleShakeEnvironment(on: true);
		elevatorWalls.speed = elevatorSpeed;
		CutsceneBegin();
		yield return HAGIS.DialogShow(Ambient_CanYouHearMe);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Ambient_TheyTookHerEarpiece);
		HAGIS.ToggleShakeEnvironment(on: false);
		elevatorWalls.speed = 0f;
		yield return CreateTimeCondition(1f);
		yield return TeamMoveToMapViaEntranceTile(HoldingToElevator);
		SKIP_POINT("Interrogation scene");
		HoldingToElevator.gameObject.SetActive(value: false);
		HAGIS.DialogShow(Dialog_SitBeHave);
		yield return CreateTimeCondition(2f);
		yield return UnitMoveToTarget(Willa, WillaMoveTo);
		Willa.LookInDirection(OctDir.Left);
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(Dialog_WeNeedHerOnSide);
		yield return Dialog_WeNeedHerOnSide.OnAnswer0 | Dialog_WeNeedHerOnSide.OnAnswer1;
		speaker.gameObject.SetActive(value: false);
		yield return UnitPlayAnimation(Willa, "CsDefaultSmashSpeaker");
		speakerThrown.gameObject.SetActive(value: true);
		UnitPlayAnimation(Willa, "DefaultIdle");
		yield return null;
		yield return HAGIS.DialogShow(Dialog_Dammit);
		yield return CreateTimeCondition(1f);
		Jules.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/basic/jules theme", 0f, 0.2f);
		Willa.LookAt(Jules);
		yield return HAGIS.DialogShow(Dialog_JulesAvalon);
		yield return UnitMoveToTarget(Jules, JulesMoveTo, OctDir.Down);
		Willa.LookAt(Jules);
		yield return UnitPlayAnimation(Jules, "CsA3S1TransDIdletoSitIdle");
		UnitPlayAnimation(Jules, "CsA3S1SitIdle");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsA3S1SitIdle");
		Jules.UpdateIdleAnim();
		yield return UnitPlayAnimation(Jules, "CsA3S1SitOfferSeat");
		yield return UnitMoveToTarget(Willa, WillaMoveTo2);
		Willa.LookInDirection(OctDir.Right);
		yield return UnitPlayAnimation(Willa, "CsTransDIdleToInterrogationSit");
		UnitPlayAnimation(Willa, "CsDefaultInterrogationSit");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultInterrogationSit");
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_IWishThingsWereDifferent);
		yield return HAGIS.DialogShow(Dialog_MyGrandMotherLeft);
		yield return UnitPlayAnimation(Jules, "CsA3S1SitShowAug");
		MusicStop();
		yield return HAGIS.DialogShow(Dialog_AnArmyOfAndroids);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_ClimbAnymountain);
		yield return CreateTimeCondition(3f);
		yield return HAGIS.DialogShow(Dialog_IOnlyWantedTheBestForYou);
		yield return HAGIS.DialogShow(Dialog_IPromise);
		yield return HAGIS.DialogShow(Dialog_TakeHerToTheMines);
		yield return CreateTimeCondition(1f);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		SKIP_POINT("Elevator to mine");
		yield return MapGoto(MineElevator.Map);
		MusicStop();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return UnitTeleportToMapViaEntranceTile(Willa, ElevatorToHolding, WillaMoveTo3);
		Willa.LookInDirection(OctDir.Down);
		HAGIS.ToggleShakeEnvironment(on: true);
		elevatorWalls.speed = elevatorSpeed;
		yield return HAGIS.DialogShow(Ambient_HehHeh);
		Theo.LookInDirection(OctDir.Left);
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		UnitPlayAnimation(Theo, "TransDIdleToCIdle");
		yield return CreateTimeCondition(0.5f);
		UnitPlayAnimation(Theo, "CombatAttackMelee");
		yield return CreateTimeCondition(0.5f);
		SFXPlay("event:/sfx/script/act 2/a2o5/bugsy pats willas cheek");
		UnitPlayAnimation(Willa, "DefaultHit");
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Theo, "TransCIdleToDIdle");
		yield return HAGIS.DialogShow(Ambient_FairWellCitizen);
		HAGIS.ToggleShakeEnvironment(on: false);
		elevatorWalls.speed = 0f;
		yield return TeamMoveToMapViaEntranceTile(MineToElevator);
		Droid.gameObject.SetActive(value: true);
		SKIP_POINT("Rotgut mine");
		yield return UnitMoveToTarget(Willa, WillaEnterTo);
		DoorExitInteraction1.gameObject.SetActive(value: true);
		MineToElevator.gameObject.SetActive(value: false);
		SFXPlayAtCoord("event:/sfx/script/act 3/a3s1/earpiece turn on", sfx_earpiece_turn_on);
		yield return HAGIS.DialogShow(Dialog_TheIntercom);
		yield return UnitMoveToTarget(Willa, WillaEnterTo);
		yield return HAGIS.DialogShow(Dialog_DontLetMeDie);
		yield return HAGIS.DialogShow(Dialog_WePromise);
		CutsceneEnd();
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindAWayOut);
		HagisLog("Spoke to droid for the first time");
		HagisLog("Droid interaction changed");
		yield return MapWaitUntilMidTransition(Infirmary);
		MusicPlay("event:/music/tracks/basic/willa theme");
		yield return MapWaitUntilVisible(Infirmary.Map);
		UIObjectives.Inst.CompleteObjective(objFindAWayOut);
		DroidInteraction.gameObject.SetActive(value: false);
		InfirmaryToMine.gameObject.SetActive(value: false);
		StaticSkinSign.gameObject.SetActive(value: false);
		SKIP_POINT("Entering Infirmary");
		yield return CutscenePlay("A3S1_Cutscene_BeardInteraction");
		yield return null;
		CutsceneBegin();
		UnitPlayAnimation(Bernard, "CsDefaultHugWilla");
		UnitPlayAnimation(Willa, "CsDefaultHugBernard");
		HAGIS.DialogShow(Ambient_Huh_Huh);
		yield return CreateTimeCondition(2f);
		CutsceneEnd();
		SKIP_POINT("Cravens room");
		MusicStop();
		Bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsCombatCrouch");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultDefeated");
		yield return ShowRoom(Room_4);
		Hartman_TeleportToPointWithLookAt(move_tableFront, look_Table);
		Hartman_SetMood(Hartman.Mood.Default);
		Hartman_PlayAnimation("FixTableIdle");
		yield return CreateTimeCondition(0.5f);
		Hartman_PlayAnimation("TransFixTableToDIdle");
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Dialog_ThatWasMe);
		yield return CreateTimeCondition(1f);
		Hartman_SetMood(Hartman.Mood.Sad);
		Hartman_PlayAnimation("TransDIdleToSIdle");
		yield return CreateTimeCondition(0.4f);
		Hartman_PlayAnimation("SadTalk");
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_Safe, 1f);
		yield return CreateTimeCondition(2f);
		Hartman_LookAtPoint(look_window, 2f);
		yield return CreateTimeCondition(1f);
		Hartman_MoveToPoint(move_window, 3f);
		Hartman_LookAtPoint(look_window, 1f);
		button_HolomapTurnOn.gameObject.SetActive(value: true);
		yield return button_HolomapTurnOn.OnTapUp;
		yield return CreateTimeCondition(1f);
		yield return ShowMap();
		CutsceneBegin();
		yield return CreateTimeCondition(4f);
		CutsceneEnd();
		yield return null;
		yield return CutscenePlay("A3S1_Cutscene_WillaAndBenard");
		Bernard.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		HAGIS.DialogShow(Dialog_RelievedSigh);
		Party.Inst.AddItemToInventory(Item.Atlantium_Core.ToMeta(), 1);
		Party.Inst.RemoveItemFromInventory(Item.Atlantium_Core.ToMeta(), 1);
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/ability/restore");
		yield return CreateTimeCondition(1f);
		PSC.Inst.Play(ParticleTypes.Static_Skin, Willa.map, Willa.coord);
		SFXPlay("event:/sfx/script/act 1/a1s2/static skin");
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindAWayOut);
		Bernard.SetTeamType(UnitTeam.Type.Player);
		InfirmaryToMine.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(MineCore.Map);
		SKIP_POINT("Returning to rotgut mine");
		Droid.SetTeamType(UnitTeam.Type.Enemy);
		Bernard.SetTeamType(UnitTeam.Type.NPC);
		DoorExitInteraction1.gameObject.SetActive(value: false);
		DoorExitInteraction2.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(Dialog_LetsGoToWork);
		TT_DontGiveUp.gameObject.SetActive(value: true);
		ParticlePrefab WeaponLockerHightlight = PSC.Inst.Play(ParticleTypes.CoordSelectTile, WeaponLockerInteraction.transform);
		bool UsedSecurityDoor = false;
		WeaponLockerInteraction.gameObject.SetActive(value: true);
		HagletYieldTerm yt_ExitInteraction = CreateTriggerCondition(DoorExitInteraction2.OnDialogComplete);
		yield return CreateOrCondition(yt_ExitInteraction, WeaponLockerInteraction.OnTriggered);
		DoorExitInteraction2.gameObject.SetActive(value: false);
		if (yt_ExitInteraction.met)
		{
			DoorExitInteraction2.gameObject.SetActive(value: false);
			UsedSecurityDoor = true;
			yield return WeaponLockerInteraction.OnTriggered;
		}
		CutsceneBegin();
		MusicStop();
		WeaponLockerHightlight.StopParticles();
		PSC.Inst.Play(ParticleTypes.Static_Skin, Willa.map, Willa.coord);
		SFXPlay("event:/sfx/script/act 1/a1s2/static skin");
		yield return CreateTimeCondition(1f);
		PlayMapAnimation(MineCore.Map, "MA_StaticShield", "Deactivate");
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/script/act 2/a2o4/chris unlocks cabinet");
		PlayMapAnimation(MineCore.Map, "MA_WeaponsLocker", "Open");
		Droid.LookAt(Willa);
		yield return UnitPlayAnimation(Droid, "TransDIdleToCIdle");
		yield return UnitPlayAnimation(Droid, "TransCIdleToAIdle");
		UnitPlayAnimation(Droid, "CombatAimIdle", loop: true);
		Droid.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Droid.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		WeaponLockerInteraction.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Ambient_GetAway);
		yield return UnitMoveToTarget(Willa, WillaGetGun, null, 5f);
		yield return UnitPlayAnimation(Willa, "DefaultInteract");
		UnitPlayAnimation(Willa, "TransDIdleToCIdle");
		yield return CreateTimeCondition(0.3f);
		Willa.LookAt(Droid);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Willa.UpdateIdleAnim();
		HAGIS.DialogShow(Ambient_DropIt);
		yield return CreateTimeCondition(0.5f);
		yield return UnitAttackUnit(Droid, Willa, Combat.HitType.Miss);
		yield return UnitMoveToTarget(Willa, WillaMoveToCover, null, 5f);
		HAGIS.DialogShow(Ambient_InmateIsArmed);
		yield return UnitMoveToTarget(Droid, MoveToMineEntrance, null, 4f);
		UnitMoveToTarget(Bernard, BernardCover, null, 4f);
		yield return UnitPlayAnimation(Bernard, "CsTransDIdleToCCrouch");
		UnitPlayAnimation(Bernard, "CsTransDIdleToCCrouch");
		Bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsCombatCrouch");
		CutsceneEnd();
		yield return null;
		MusicPlay("event:/music/tracks/combat/old combat");
		CombatBegin(UnitTeam.Type.Player);
		yield return CombatWaitUntilComplete();
		MusicPlay("event:/music/tracks/basic/determined tension");
		CutsceneBegin();
		MineGuard.gameObject.SetActive(value: true);
		MineGuard2.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(MineGuard, MoveToMineEntrance, null, 5f);
		yield return UnitMoveToTarget(MineGuard2, MineGuardMoveTo, null, 5f);
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_MoreComing);
		MineToInfirmary.gameObject.SetActive(value: false);
		TosecurityTunnel.gameObject.SetActive(value: true);
		yield return CreateTriggerCondition(TosecurityTunnel.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objFindAWayOut);
		if (UsedSecurityDoor)
		{
			yield return HAGIS.DialogShow(Dialog_WhatDoWeDo);
		}
		else
		{
			yield return HAGIS.DialogShow(Dialog_WhatDoWeDo2);
		}
		SKIP_POINT("Craven's Room, Use the Imager!");
		MusicStop();
		yield return ShowRoom(Room_4);
		button_HolomapTurnOn.gameObject.SetActive(value: false);
		button_UseBioImager.gameObject.SetActive(value: true);
		Hartman_SetMood(Hartman.Mood.Concerned);
		biometricImager.DisplayNextKey();
		Hartman_PlayAnimation("ConcernedIdle");
		Hartman_TeleportToPointWithLookAt(move_tableRight, look_Photo);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Dialog_TheBioimager);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_Photo, 0.25f);
		yield return CreateTriggerCondition(Dialog_TheBioimager.OnComplete);
		yield return button_UseBioImager.OnTapUp;
		biometricImager.DisplayNextKey();
		SFXPlay("event:/sfx/ui/combat wheel open");
		yield return CreateTimeCondition(0.1f);
		yield return button_UseBioImager.OnTapUp;
		SFXPlay("event:/sfx/ui/combat wheel open");
		biometricImager.DisplayNextKey();
		yield return CreateTimeCondition(4f);
		SFXPlay("event:/sfx/ui/combat wheel open");
		biometricImager.DisplayNextKey();
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(Dialog_TryAgain);
		button_UseBioImager.gameObject.SetActive(value: false);
		button_UseBioImager2.gameObject.SetActive(value: true);
		Hartman_PlayAnimation("ConcernedTalk");
		yield return CreateTimeCondition(0.3f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(0.5f);
		Hartman_LookAtPoint(look_Photo, 0.25f);
		yield return button_UseBioImager2.OnTapUp;
		Hartman_PlayAnimation("ConcernedIdleAlt");
		yield return CreateTimeCondition(1f);
		biometricImager.DisplayNextKey();
		SFXPlay("event:/sfx/ui/combat wheel open");
		yield return CreateTimeCondition(4f);
		SFXPlay("event:/sfx/ui/combat wheel open");
		biometricImager.DisplayNextKey();
		yield return CreateTimeCondition(1.5f);
		Hartman_PlayAnimation("ConcernedIdleAlt");
		LoopingSFX Errorsound = LoopingSFXPlay("event:/sfx/ui/wham bar/radial countdown");
		yield return CreateTimeCondition(5f);
		SFXPlay("event:/sfx/ui/combat wheel open");
		biometricImager.DisplayNextKey();
		yield return CreateTimeCondition(2f);
		Hartman_SetMood(Hartman.Mood.Happy);
		Hartman_PlayAnimation("TransCIdleToHIdle");
		yield return CreateTimeCondition(3f);
		HAGIS.DialogShow(Dialog_ThatsIt);
		Hartman_LookAtPoint(look_player, 0.25f);
		Hartman_PlayAnimation("HappyTalk");
		yield return CreateTimeCondition(1f);
		Errorsound.Stop();
		yield return CreateTimeCondition(2f);
		yield return ShowMap();
		CutsceneBegin();
		yield return CreateTimeCondition(5f);
		SFXPlayAtCoord("event:/sfx/script/act 3/a3s1/craven unlocks door", sfx_craven_unlocks_high_security_tunnel_door);
		PlayMapAnimation(MineCore.Map, "MA_EscapeDoors", "Open");
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		yield return CreateTimeCondition(1f);
		TosecurityTunnel.gameObject.SetActive(value: false);
		UnitPlayAnimation(Bernard, "CsTransCCrouchToDIdle");
		Bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		yield return HAGIS.DialogShow(Dialog_WhatDidYouDo);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFindAWayOut);
		HAGIS.DialogShow(Ambient_ComeOn);
		Bernard.SetTeamType(UnitTeam.Type.Player);
		UnitMoveToTarget(Bernard, BernardMoveTo);
		yield return HAGIS.DialogShow(Ambient_RadiationSickness);
		yield return TeamMoveToMapViaEntranceTile(SecurityTunnelToMine, ignoreMovement: true);
		CutsceneEnd();
		SKIP_POINT("Entering high security tunnel");
		CutsceneBegin();
		SecurityTunnelToMine.gameObject.SetActive(value: false);
		UnitMoveToTarget(Willa, WillaCoverPoint, null, 5f);
		yield return UnitMoveToTarget(Bernard, BernardCoverPoint);
		yield return UnitPlayAnimation(Bernard, "CsTransDIdleToCCrouch");
		Bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsCombatCrouch");
		Bernard.UpdateIdleAnim();
		Bernard.SetTeamType(UnitTeam.Type.NPC);
		MusicPlay("event:/music/tracks/combat/old combat");
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return UnitPlayAnimation(Bernard, "CsTransCCrouchToDIdle");
		Bernard.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Bernard.UpdateIdleAnim();
		MusicPlay("event:/music/tracks/exploration/tenor city sunset");
		MineToSecuritytunnel.gameObject.SetActive(value: true);
		UnitMoveToTarget(Bernard, BernardCollapsePoint);
		yield return CreateTriggerCondition(SeizedProperty.OnDialogComplete);
		UIObjectives.Inst.CompleteObjective(objFindAWayOut);
		LadderBlocker.gameObject.SetActive(value: false);
		yield return CutscenePlay("A3S1_Cutscene_BernardConversation");
		yield return null;
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, WillaLadderExit);
		Willa.LookAt(Bernard);
		yield return CreateTimeCondition(5f);
		Willa.LookInDirection(OctDir.Up);
		yield return UnitPlayAnimation(Willa, "CsDefaultTunnelClimb");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultLadderToFreedomSQ1");
		Willa.StartTeleport(LadderToLightHouse.coord, LadderToFreedom.Map, null, manuallyHandleShowing: true, deactivateForTeleport: false, lookAtDest: true, null, null, null, ignoreAnimation: true);
		yield return Wait.While(Willa.teleporting);
		yield return MapGoto(LadderToFreedom);
		Willa.unitModel.HACK_BirdMode = true;
		Willa.SetTeamType(UnitTeam.Type.NPC);
		CutsceneEnd();
		yield return null;
		MusicSetProgress(0.1f);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Willa.unitModel.Play("CsDefaultLadderToFreedomSQ1");
		yield return CutscenePlay("A3S1_Cutscene_Climb");
		yield return UnitTeleportToMapViaEntranceTile(Willa, LightHouseToLadder);
		Willa.gameObject.SetActive(value: false);
		Willa.LookInDirection(OctDir.Left);
		yield return MapGoto(LighthouseIsland.Map);
		Willa.unitModel.HACK_BirdMode = false;
		MusicStop();
		SKIP_POINT("Lighthouse");
		yield return CutscenePlay("A3S1_Cutscene_ClimbFinish");
		LightHouseToLadder.gameObject.SetActive(value: false);
		RowBoatInteraction.gameObject.SetActive(value: true);
		Willa.SetTeamType(UnitTeam.Type.Player);
		bool HonSect1 = HAGIS.WasHonestThroughoutSection(DC.GameSection.ONE);
		bool HonSect2 = HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_A);
		bool HonSect3 = HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_B);
		if (HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_ThereWasNoOneElse);
		}
		else
		{
			yield return HAGIS.DialogShow(Dialog_BecauseWeCare);
		}
		if (!HonSect1 && !HonSect2 && !HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_WhatTheHell);
		}
		if (!HonSect1 && HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_YouRemember);
		}
		if (HonSect1 && !HonSect2 && !HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_YouCouldPretend);
		}
		if (HonSect1 && HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_OnlyBeingHonest);
		}
		yield return HAGIS.DialogShow(Dialog_DontInvolveYou);
		Willa.LookInDirection(OctDir.Right);
		yield return HAGIS.DialogShow(Dialog_HeresYourRide);
		bool leftViaRowboat = false;
		while (!leftViaRowboat)
		{
			yield return CreateTriggerCondition(RowBoatInteraction.OnDialogComplete);
			yield return HAGIS.DialogShow(Dialog_LeaveTheIsland);
			switch (Dialog_LeaveTheIsland.currentResponseLine)
			{
			case 1u:
				leftViaRowboat = true;
				break;
			case 2u:
				yield return UnitMoveToTarget(Willa, WillaMoveBackTo, OctDir.Up);
				break;
			}
		}
		Willa.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitTeleportToMapViaEntranceTile(Willa, FromLighthouse);
		Willa.LookInDirection(OctDir.Down);
		Willa.gameObject.SetActive(value: false);
		yield return MapGoto(FreighterDeck.Map);
		SKIP_POINT("Ship");
		MusicStop();
		UIObjectives.Inst.CompleteObjective(objLeaveTheIsland);
		yield return null;
		yield return CutscenePlay("A3S1_Cutscene_CrawlOnToShip");
		if (!HonSect1 && !HonSect2 && !HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_AsLongAs);
		}
		if (!HonSect1 && HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_ThanksForYourHonesty);
		}
		if (HonSect1 && !HonSect2 && !HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_ThanksForYourKindess);
		}
		if (HonSect1 && HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_AsLongAsYouUnderstand);
		}
		if (!HonSect2 && !HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_WeTriedBeingGentle);
		}
		if (HonSect2 && HonSect3)
		{
			yield return HAGIS.DialogShow(Dialog_WeTriedBeingHonest);
		}
		CutsceneBegin();
		TuckerTriggerman.gameObject.SetActive(value: true);
		TuckerTriggerman2.gameObject.SetActive(value: true);
		MusicPlay("event:/music/tracks/basic/drone 1");
		UnitMoveToTarget(TuckerTriggerman, PatrolMoveTo, OctDir.Left, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk);
		UnitMoveToTarget(TuckerTriggerman2, PatrolMoveTo2, OctDir.Left, null, optionalUnit: false, ignoreUnitAtDestination: false, shouldReserveTile: true, MoveType.Walk);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_GetOutOfThere);
		yield return UnitMoveToTarget(Willa, WillaEscapepoint, OctDir.Up);
		UnitLookInDirection(Willa, OctDir.Up);
		Willa.unitModel.Play(UnitModel.AnimID.Vault);
		yield return CreateTimeCondition(0.8f);
		Willa.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		HagisLog("Logic ends");
	}
}
public class HAGIS_A3S1_TriggerDontGiveUp : HAGIS
{
	private UnitTarget WillaMove2;

	private TileTrigger TT_DontGiveUp;

	private DialogData Ambient_DontGiveUp;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		WillaMove2 = MR.Inst.GetUnitTarget("F86_T1MineCore_UnitTarget");
		TT_DontGiveUp = MR.Inst.GetTileTrigger("8A4_T1MineCore_TileTrigger");
		Ambient_DontGiveUp = HAGIS.DialogLoad("Dialogs/A3S1/RotgutMine/Ambient_DontGiveUp");
		yield return null;
		yield return CreateTriggerCondition(TT_DontGiveUp._OnTriggered);
		HAGIS.DialogShow(Ambient_DontGiveUp);
	}
}
public enum WillaOnFloor
{
	BeenAGoodFriend,
	Redemption_ThankyouForFinallyBeingHonest,
	Redemption_ThankyouForActingLikeYouCared,
	GoodThenTragic_ActLikeYouCared,
	GoodThenTragic_WhatHappenedToUsHonest,
	Tragic_BrutalHonesty,
	Tragic_PretendLikeYouCared
}
public enum WillaLeaving
{
	Happy,
	Redemption,
	HappyThenTragic,
	FullTragic
}
public class HAGIS_A3S2 : HAGIS
{
	private TileBlockDynamic[] ascensionPlatformBorder;

	private Unit Willa;

	private Unit Archi;

	private Unit Ambrosia;

	private Unit Noot;

	private Unit Chris;

	private Unit Margot;

	private Unit Jules;

	private Unit Robot_BTInt1;

	private Unit Robot_BTInt2;

	private Unit Robot1_BTExt;

	private Unit Robot2_BTExt;

	private Unit Robot3_BTExt;

	private Unit Robot_CTC1;

	private Unit Robot_CTC2;

	private Unit Robot_CTC3;

	private Unit Theo;

	private Unit WellnessOfficer;

	private Unit ChumleyDroid_1;

	private Unit ChumleyDroid_2;

	private Unit ChumleyDroid_3;

	public HagletTrigger theoBossFight = new HagletTrigger();

	private UnitTarget T_WillaCT;

	private UnitTarget T_Willa_BTInt;

	private UnitTarget T_Willa_BTExt;

	private UnitTarget T_Willa_ExitToGarden;

	private UnitTarget T_Willa_Garden;

	private UnitTarget T_Robot1_BTInt;

	private UnitTarget T_Robot2_BTInt;

	private UnitTarget T_Robot3_BTInt;

	private UnitTarget T_Robot4_BTInt;

	private UnitTarget T_Robot1_BTExt;

	private UnitTarget T_Robot2_BTExt;

	private UnitTarget T_Noot_BTExt;

	private UnitTarget T_Chris_BTExt;

	private UnitTarget T_Archi_BTExt;

	private UnitTarget T_Margot_BTExt;

	private UnitTarget T_Ladder;

	private UnitTarget T_ladder_Archi;

	private UnitTarget T_Ladder_Margot;

	private UnitTarget T_MargotCT;

	private UnitTarget T_AmbroCT;

	private UnitTarget T_ArchiCT;

	private UnitTarget T_NootCT;

	private UnitTarget T_ChrisCT;

	private UnitTarget T_TheoAP;

	private UnitTarget T_Archi;

	private UnitTarget T_Noot;

	private UnitTarget T_Willa;

	private UnitTarget T_Ambro;

	private UnitTarget T_Chris;

	private UnitTarget T_TWO;

	private UnitTarget T_WillaCellExhib;

	private UnitTarget T_WillaCellExhibLeave;

	private UnitTarget T_WillaCellExhibLeave2;

	private UnitTarget T_WillaCellExhibLeave3;

	private UnitTarget T_ArchiCellExhib;

	private UnitTarget T_NootCellExhib;

	private UnitTarget T_ArchiCellExhib2;

	private UnitTarget T_NootCellExhib2;

	private UnitTarget T_ChrisCellExhib;

	private UnitTarget T_AmbrosiaCellExhib;

	private UnitTarget T_MargotCellExhib;

	private UnitTarget T_Willa_Tenor;

	private UnitTarget T_WillaTarget_Omega;

	private UnitTarget T_JulesToLandingPad;

	private UnitTarget T_JulesLandingPad;

	private UnitTarget T_JulesToCover;

	private UnitTarget T_JulesToExit;

	private UnitTarget T_Margot_SurroundsWilla;

	private UnitTarget T_Chris_SurroundsWilla;

	private UnitTarget T_Noot_SurroundsWilla;

	private UnitTarget T_Ambro_SurroundsWilla;

	private UnitTarget T_WillaLandingPad;

	private UnitTarget T_WillaLandingPad2;

	private UnitTarget T_ArchiLandingPad;

	private UnitTarget T_JulesStaggerLandingPad;

	private UnitTarget T_Archi_Fight;

	private TileBlockDynamic EscapePod;

	private TileActionSwapMap CelestiaTCToBTowerEx;

	private TileActionSwapMap BTowerExToBTowerInt;

	private TileActionSwapMap BTowerToCelestiaTown;

	private TileActionSwapMap BTowerToGarden;

	private TileActionSwapMap BTowerIntToBTowerEx;

	private TileActionSwapMap GardenToBTower;

	private TileActionSwapMap EnterTenorCittyCentre;

	private TileActionSwapMap AscensionPlatToAscensionExhibit;

	private TileActionSwapMap AscensionPlatToWelcomeExhibit;

	private TileActionSwapMap TenorCentreToMuseum;

	private TileActionSwapMap AsExhibitToAsPlatform;

	private TileActionSwapMap AsExhibitToTenorCityCentre;

	private TileActionSwapMap WelcomeExToAscensionPlat;

	private TileActionSwapMap WelcomeExToOmegaOffice;

	private TileActionSwapMap OmegaToLandingPad;

	private TileActionSwapMap OmegaToWelcomeExhibit;

	private TileActionSwapMap LandingPadToOmega;

	private TileActionDialog D_BrodcastDoor;

	private TileActionDialog D_ToGardens;

	private TileActionDialog D_WasteTime1;

	private TileActionDialog D_WasteTime2;

	private TileActionInteraction I_ArchiBTInterior;

	private TileActionInteraction I_NootBTExterior;

	private TileActionInteraction I_ChrisBTExterior;

	private TileActionInteraction I_Console;

	private TileActionInteraction I_OmegaOfficeExit;

	private DialogData Ambient_AmbrosiaBehind;

	private DialogData Ambient_ArchiGo;

	private DialogData Ambient_ArchiWilla;

	private DialogData Ambient_ChrisWeTried;

	private DialogData Ambient_FullTragicEndingCom;

	private DialogData Ambient_FullTragicEndingHon;

	private DialogData Ambient_GetMoving;

	private DialogData Ambient_HappyEnding;

	private DialogData Ambient_HartmanGoodKid;

	private DialogData Ambient_HartmanLive;

	private DialogData Ambient_HartmanSaveHer;

	private DialogData Ambient_HartmanWasShe;

	private DialogData Ambient_NootStillIn;

	private DialogData Ambient_RedemptionEndingCom;

	private DialogData Ambient_RedemptionEndingHon;

	private DialogData Ambient_TheoArrest;

	private DialogData Ambient_TheoArrestCONT;

	private DialogData Ambient_TheoBrave;

	private DialogData Ambient_TheoDammit;

	private DialogData Ambient_TheoFinally;

	private DialogData Ambient_WelcomeHome;

	private DialogData Ambient_TragicEndingCom;

	private DialogData Ambient_TragicEndingHon;

	private DialogData Ambient_WillaAlone;

	private DialogData Ambient_WillaCraven;

	private DialogData Ambient_WillaGuys;

	private DialogData Ambient_WillaHeyCravenFullTragic;

	private DialogData Ambient_WillaHeyCravenHappy;

	private DialogData Ambient_WillaHeyCravenRed;

	private DialogData Ambient_WillaHeyCravenTragic;

	private DialogData Ambient_WillaHold;

	private DialogData Ambient_WillaHuh;

	private DialogData Ambient_WillaIncoming;

	private DialogData Ambient_WillaIsThat;

	private DialogData Ambient_WillaItsMe;

	private DialogData Ambient_WillaLookDown1;

	private DialogData Ambient_WillaLookDown2;

	private DialogData Ambient_WillaNo;

	private DialogData Ambient_WillaOver;

	private DialogData Ambient_WillaPlatform;

	private DialogData Ambient_WillaSob;

	private DialogData Dialog_AmbrosiaBeSafe;

	private DialogData Dialog_ArchiComeOn;

	private DialogData Dialog_ArchiComeOn2;

	private DialogData Dialog_ArchiComeOn3;

	private DialogData Dialog_ArchiHey;

	private DialogData Dialog_ArchiNotYou;

	private DialogData Dialog_ArchiRightHere;

	private DialogData Dialog_ArchiSlowDown;

	private DialogData Dialog_ArchiTheDroids;

	private DialogData Dialog_ChrisSuprise;

	private DialogData Dialog_EtemenExhibit;

	private DialogData Dialog_HartmanCalmDown;

	private DialogData Dialog_HartmanDemon;

	private DialogData Dialog_HartmanGetHim;

	private DialogData Dialog_HartmanGetIn;

	private DialogData Dialog_HartmanJules;

	private DialogData Dialog_HartmanLostControl;

	private DialogData Dialog_JulesPlease;

	private DialogData Dialog_JulesShit;

	private DialogData Dialog_KeyToCity;

	private DialogData Dialog_MargotBreath;

	private DialogData Dialog_MargotShutUp;

	private DialogData Dialog_WiallNoot;

	private DialogData Dialog_WillaAreThey;

	private DialogData Dialog_WillaCondem;

	private DialogData Dialog_WillaDropIt;

	private DialogData Dialog_WillaForWhat;

	private DialogData Dialog_WillaForWhatHappy;

	private DialogData Dialog_WillaForWhatTragic;

	private DialogData Dialog_WillaHowDo;

	private DialogData Dialog_WillaJuels;

	private DialogData Dialog_ArchiRightHereCont;

	private DialogData Dialog_WillaOffice;

	private DialogData Dialog_WillaProud;

	private DialogData Dialog_WillaTakeCare;

	private DialogData Dialog_WillaTookEverything;

	private DialogData Dialog_Window;

	private DialogData Dilaog_WillaWasteTime;

	private DialogData Dialog_LevelTenThousand;

	private DialogData ambient_craven;

	private DialogData Dialog_SlowDown;

	private DialogData Dialog_DoesntFeelGreat;

	private DialogData Dialog_DoesntFeelGreatCont;

	private string objHeadForCelestiatower = "OBJECTIVES_A3S2_01";

	private string objGoCheckOnArchi = "OBJECTIVES_A3S2_02";

	private string objGetToPod = "OBJECTIVES_A3S2_03";

	private string objFight = "OBJECTIVES_A3S2_04";

	private string objToAscension = "OBJECTIVES_A3S2_05";

	private string objKillJules = "OBJECTIVES_A3S2_06";

	public bool PastTheoPhaseOne { get; private set; }

	public static WillaOnFloor GetEndingState()
	{
		bool flag = HAGIS.WasHonestThroughoutSection(DC.GameSection.ONE);
		bool flag2 = HAGIS.WasHonestThroughoutSection(DC.GameSection.TWO_A, DC.GameSection.TWO_B);
		bool flag3 = HAGIS.WasHonestThroughoutSection(DC.GameSection.THREE);
		WillaOnFloor result = WillaOnFloor.BeenAGoodFriend;
		if (flag && flag2 && flag3)
		{
			result = WillaOnFloor.Tragic_BrutalHonesty;
		}
		else if (flag && flag2 && !flag3)
		{
			result = WillaOnFloor.Redemption_ThankyouForActingLikeYouCared;
		}
		else if (flag && !flag2 && flag3)
		{
			result = WillaOnFloor.BeenAGoodFriend;
		}
		else if (flag && !flag2 && !flag3)
		{
			result = WillaOnFloor.GoodThenTragic_ActLikeYouCared;
		}
		else if (!flag && flag2 && flag3)
		{
			result = WillaOnFloor.GoodThenTragic_WhatHappenedToUsHonest;
		}
		else if (!flag && flag2 && !flag3)
		{
			result = WillaOnFloor.BeenAGoodFriend;
		}
		else if (!flag && !flag2 && flag3)
		{
			result = WillaOnFloor.Redemption_ThankyouForFinallyBeingHonest;
		}
		else if (!flag && !flag2 && !flag3)
		{
			result = WillaOnFloor.Tragic_PretendLikeYouCared;
		}
		return result;
	}

	public static bool GetEndingHappySad()
	{
		WillaOnFloor endingState = GetEndingState();
		bool result = false;
		if (endingState == WillaOnFloor.BeenAGoodFriend || endingState == WillaOnFloor.Redemption_ThankyouForActingLikeYouCared || endingState == WillaOnFloor.Redemption_ThankyouForFinallyBeingHonest)
		{
			result = true;
		}
		return result;
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		RoomSceneMeta Room_5 = GetRoomMeta("ROOM_Penthouse_05");
		HartmanMovementPoint move_tableFront = GetHartmanMovementPoint("M_TableFront");
		HartmanMovementPoint move_tableRight = GetHartmanMovementPoint("M_TableRight");
		HartmanMovementPoint move_tableLeft = GetHartmanMovementPoint("M_TableLeft");
		HartmanMovementPoint move_window = GetHartmanMovementPoint("M_Window");
		HartmanLookAtPoint look_player = GetHartmanLookAtPoint("L_Player");
		HartmanLookAtPoint L_Phone = GetHartmanLookAtPoint("L_Phone");
		HartmanLookAtPoint look_window = GetHartmanLookAtPoint("L_Window");
		HartmanLookAtPoint look_Photo = GetHartmanLookAtPoint("L_AshelyPhoto");
		UIButtonHaglet button_LookDownDetection = GetUIButtonHaglet("P_LookDownDetection");
		KubrickAnimator BigWilla = GetAnimator("P_Willa");
		LogicRoot CelestiaTownCenter = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot BroadcastTowerExterior = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot BroadcastTowerInterior = GetLogicUsingArtName("T3RelayTowerInterior");
		LogicRoot BotanicalGarden = GetLogicUsingArtName("T3BotanicalGardens");
		LogicRoot AscensionPlatform = GetLogicUsingArtName("T2AscensionPlatform");
		LogicRoot AscensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		LogicRoot TenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot WelcomeToCelestia = GetLogicUsingArtName("T3WelcomeToYourNewWorldExhibit");
		LogicRoot OmegaOffice = GetLogicUsingArtName("T3OmegaOffices");
		LogicRoot LandingPad = GetLogicUsingArtName("T3LandingPad");
		ascensionPlatformBorder = AscensionPlatform.transform.GetComponentsInChildren<TileBlockDynamic>();
		Willa = GC.Inst.GetUnitWithId("563_T3CelestiaTownCentre_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("9F2_T3RelayTowerInterior_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("560_T3RelayTowerExterior_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("F04_T3RelayTowerExterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("7EC_T3RelayTowerExterior_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("A6E_T3RelayTowerExterior_UnitSpawn");
		Jules = GC.Inst.GetUnitWithId("8D6_T3OmegaOffices_UnitSpawn");
		Robot_BTInt1 = GC.Inst.GetUnitWithId("900_T3RelayTowerInterior_UnitSpawn");
		Robot_BTInt2 = GC.Inst.GetUnitWithId("AE1_T3RelayTowerInterior_UnitSpawn");
		Robot1_BTExt = GC.Inst.GetUnitWithId("686_T3RelayTowerExterior_UnitSpawn");
		Robot2_BTExt = GC.Inst.GetUnitWithId("AC7_T3RelayTowerExterior_UnitSpawn");
		Robot3_BTExt = GC.Inst.GetUnitWithId("2D9_T3RelayTowerExterior_UnitSpawn");
		Robot_CTC1 = GC.Inst.GetUnitWithId("0E8_T3CelestiaTownCentre_UnitSpawn");
		Robot_CTC2 = GC.Inst.GetUnitWithId("088_T3CelestiaTownCentre_UnitSpawn");
		Robot_CTC3 = GC.Inst.GetUnitWithId("DCB_T3CelestiaTownCentre_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("152_T2AscensionPlatform_UnitSpawn");
		WellnessOfficer = GC.Inst.GetUnitWithId("71A_T2AscensionPlatform_UnitSpawn");
		ChumleyDroid_1 = GC.Inst.GetUnitWithId("FFC_T3WelcomeToYourNewWorldExhibit_UnitSpawn");
		ChumleyDroid_2 = GC.Inst.GetUnitWithId("EB0_T3WelcomeToYourNewWorldExhibit_UnitSpawn");
		ChumleyDroid_3 = GC.Inst.GetUnitWithId("2B9_T3WelcomeToYourNewWorldExhibit_UnitSpawn");
		EscapePod = MR.Inst.GetTileBlockDynamic("E5A_T3BotanicalGardens_TileBlockDynamic");
		T_WillaCT = MR.Inst.GetUnitTarget("380_T3CelestiaTownCentre_UnitTarget");
		T_Willa_BTInt = MR.Inst.GetUnitTarget("148_T3RelayTowerInterior_UnitTarget");
		T_Willa_BTExt = MR.Inst.GetUnitTarget("E7A_T3RelayTowerExterior_UnitTarget");
		T_Willa_ExitToGarden = MR.Inst.GetUnitTarget("DD9_T3RelayTowerExterior_UnitTarget");
		T_Willa_Garden = MR.Inst.GetUnitTarget("684_T3BotanicalGardens_UnitTarget");
		T_Robot1_BTInt = MR.Inst.GetUnitTarget("D23_T3RelayTowerInterior_UnitTarget");
		T_Robot2_BTInt = MR.Inst.GetUnitTarget("F72_T3RelayTowerInterior_UnitTarget");
		T_Robot3_BTInt = MR.Inst.GetUnitTarget("9C9_T3RelayTowerInterior_UnitTarget");
		T_Robot4_BTInt = MR.Inst.GetUnitTarget("DDC_T3RelayTowerInterior_UnitTarget");
		T_Robot1_BTExt = MR.Inst.GetUnitTarget("591_T3RelayTowerExterior_UnitTarget");
		T_Robot2_BTExt = MR.Inst.GetUnitTarget("EEC_T3RelayTowerExterior_UnitTarget");
		T_Chris_BTExt = MR.Inst.GetUnitTarget("B31_T3RelayTowerExterior_UnitTarget");
		T_Archi_BTExt = MR.Inst.GetUnitTarget("12D_T3RelayTowerExterior_UnitTarget");
		T_Margot_BTExt = MR.Inst.GetUnitTarget("C5B_T3RelayTowerExterior_UnitTarget");
		T_Noot_BTExt = MR.Inst.GetUnitTarget("3AE_T3RelayTowerExterior_UnitTarget");
		T_ladder_Archi = MR.Inst.GetUnitTarget("A59_T3CelestiaTownCentre_UnitTarget");
		T_Ladder_Margot = MR.Inst.GetUnitTarget("42B_T3CelestiaTownCentre_UnitTarget");
		T_Ladder = MR.Inst.GetUnitTarget("EE3_T3CelestiaTownCentre_UnitTarget");
		T_MargotCT = MR.Inst.GetUnitTarget("5B4_T3CelestiaTownCentre_UnitTarget");
		T_AmbroCT = MR.Inst.GetUnitTarget("943_T3CelestiaTownCentre_UnitTarget");
		T_ArchiCT = MR.Inst.GetUnitTarget("CC8_T3CelestiaTownCentre_UnitTarget");
		T_NootCT = MR.Inst.GetUnitTarget("EF1_T3CelestiaTownCentre_UnitTarget");
		T_ChrisCT = MR.Inst.GetUnitTarget("10A_T3CelestiaTownCentre_UnitTarget");
		T_TheoAP = MR.Inst.GetUnitTarget("5CC_T2AscensionPlatform_UnitTarget");
		T_Noot = MR.Inst.GetUnitTarget("4A3_T2AscensionPlatform_UnitTarget");
		T_Archi = MR.Inst.GetUnitTarget("D85_T2AscensionPlatform_UnitTarget");
		T_Willa = MR.Inst.GetUnitTarget("B54_T2AscensionPlatform_UnitTarget");
		T_Ambro = MR.Inst.GetUnitTarget("898_T2AscensionPlatform_UnitTarget");
		T_Chris = MR.Inst.GetUnitTarget("8BE_T2AscensionPlatform_UnitTarget");
		T_TWO = MR.Inst.GetUnitTarget("320_T2AscensionPlatform_UnitTarget");
		T_WillaCellExhib = MR.Inst.GetUnitTarget("04C_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_WillaCellExhibLeave = MR.Inst.GetUnitTarget("B86_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_WillaCellExhibLeave2 = MR.Inst.GetUnitTarget("B8C_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_WillaCellExhibLeave3 = MR.Inst.GetUnitTarget("B86_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_ArchiCellExhib = MR.Inst.GetUnitTarget("A9B_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_NootCellExhib = MR.Inst.GetUnitTarget("E5B_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_ArchiCellExhib2 = MR.Inst.GetUnitTarget("25F_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_NootCellExhib2 = MR.Inst.GetUnitTarget("2C4_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_ChrisCellExhib = MR.Inst.GetUnitTarget("D6D_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_AmbrosiaCellExhib = MR.Inst.GetUnitTarget("EAB_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_MargotCellExhib = MR.Inst.GetUnitTarget("837_T3WelcomeToYourNewWorldExhibit_UnitTarget");
		T_Willa_Tenor = MR.Inst.GetUnitTarget("583_T2TenorCityCentre_UnitTarget");
		T_WillaTarget_Omega = MR.Inst.GetUnitTarget("D10_T3OmegaOffices_UnitTarget");
		T_JulesToCover = MR.Inst.GetUnitTarget("FA7_T3OmegaOffices_UnitTarget");
		T_JulesToExit = MR.Inst.GetUnitTarget("E93_T3OmegaOffices_UnitTarget");
		T_JulesToLandingPad = MR.Inst.GetUnitTarget("D90_T3OmegaOffices_UnitTarget");
		T_JulesLandingPad = MR.Inst.GetUnitTarget("904_T3LandingPad_UnitTarget");
		T_WillaLandingPad = MR.Inst.GetUnitTarget("9FC_T3LandingPad_UnitTarget");
		T_WillaLandingPad2 = MR.Inst.GetUnitTarget("59B_T3LandingPad_UnitTarget");
		T_ArchiLandingPad = MR.Inst.GetUnitTarget("4B6_T3LandingPad_UnitTarget");
		T_JulesStaggerLandingPad = MR.Inst.GetUnitTarget("256_T3LandingPad_UnitTarget");
		T_Margot_SurroundsWilla = MR.Inst.GetUnitTarget("3E0_T3LandingPad_UnitTarget");
		T_Chris_SurroundsWilla = MR.Inst.GetUnitTarget("BAA_T3LandingPad_UnitTarget");
		T_Noot_SurroundsWilla = MR.Inst.GetUnitTarget("076_T3LandingPad_UnitTarget");
		T_Ambro_SurroundsWilla = MR.Inst.GetUnitTarget("EE5_T3LandingPad_UnitTarget");
		T_Archi_Fight = MR.Inst.GetUnitTarget("F8D_T3RelayTowerInterior_UnitTarget");
		UnitTarget sfx_ascension_platform_rises = MR.Inst.GetUnitTarget("B54_T2AscensionPlatform_UnitTarget");
		Ability_MaxHP TheoHP = Theo.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		TheoHP.SetHPMod(10);
		Ability_MaxHP WellnessOfficerHP = WellnessOfficer.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		WellnessOfficerHP.SetHPMod(5);
		Ability_MaxHP JulesHP = Jules.abilities.Add<Ability_MaxHP>(null, isUpgraded: false);
		JulesHP.SetHPMod(6);
		BigWilla.gameObject.SetActive(value: false);
		CelestiaTCToBTowerEx = MR.Inst.GetTileActionSwapMap("F7F_T3CelestiaTownCentre_TileActionSwapMap");
		BTowerExToBTowerInt = MR.Inst.GetTileActionSwapMap("337_T3RelayTowerExterior_TileActionSwapMap");
		BTowerToCelestiaTown = MR.Inst.GetTileActionSwapMap("186_T3RelayTowerExterior_TileActionSwapMap");
		BTowerToGarden = MR.Inst.GetTileActionSwapMap("05A_T3RelayTowerExterior_TileActionSwapMap");
		BTowerIntToBTowerEx = MR.Inst.GetTileActionSwapMap("462_T3RelayTowerInterior_TileActionSwapMap");
		GardenToBTower = MR.Inst.GetTileActionSwapMap("DC9_T3BotanicalGardens_TileActionSwapMap");
		AscensionPlatToAscensionExhibit = MR.Inst.GetTileActionSwapMap("2C1_T2AscensionPlatform_TileActionSwapMap");
		AscensionPlatToWelcomeExhibit = MR.Inst.GetTileActionSwapMap("3E8_T2AscensionPlatform_TileActionSwapMap");
		TenorCentreToMuseum = MR.Inst.GetTileActionSwapMap("7B0_T2TenorCity_Centre_TileActionSwapMap");
		EnterTenorCittyCentre = MR.Inst.GetTileActionSwapMap("3DB_T2TenorCityCentre_TileActionSwapMap");
		AsExhibitToAsPlatform = MR.Inst.GetTileActionSwapMap("73B_T2AscensionExhibit_TileActionSwapMap");
		AsExhibitToTenorCityCentre = MR.Inst.GetTileActionSwapMap("897_T2AscensionExhibit_TileActionSwapMap");
		WelcomeExToAscensionPlat = MR.Inst.GetTileActionSwapMap("F68_T3WelcomeToYourNewWorldExhibit_TileActionSwapMap");
		WelcomeExToOmegaOffice = MR.Inst.GetTileActionSwapMap("3A8_T3WelcomeToYourNewWorldExhibit_TileActionSwapMap");
		OmegaToLandingPad = MR.Inst.GetTileActionSwapMap("00B_T3OmegaOffices_TileActionSwapMap");
		OmegaToWelcomeExhibit = MR.Inst.GetTileActionSwapMap("B7E_T3OmegaOffices_TileActionSwapMap");
		LandingPadToOmega = MR.Inst.GetTileActionSwapMap("FE3_T3LandingPad_TileActionSwapMap");
		I_ArchiBTInterior = MR.Inst.GetTileActionInteraction("A99_T3RelayTowerInterior_TileActionInteraction");
		I_NootBTExterior = MR.Inst.GetTileActionInteraction("E3E_T3RelayTowerExterior_TileActionInteraction");
		I_ChrisBTExterior = MR.Inst.GetTileActionInteraction("B67_T3RelayTowerExterior_TileActionInteraction");
		I_Console = MR.Inst.GetTileActionInteraction("48F_T2AscensionPlatform_TileActionInteraction");
		I_OmegaOfficeExit = MR.Inst.GetTileActionInteraction("358_T3WelcomeToYourNewWorldExhibit_TileActionInteraction");
		D_BrodcastDoor = MR.Inst.GetTileActionDialog("8E4_T3RelayTowerExterior_TileActionDialog");
		D_ToGardens = MR.Inst.GetTileActionDialog("6E1_T3RelayTowerExterior_TileActionDialog");
		D_WasteTime1 = MR.Inst.GetTileActionDialog("2F0_T2AscensionPlatform_TileActionDialog");
		D_WasteTime2 = MR.Inst.GetTileActionDialog("226_T2AscensionPlatform_TileActionDialog");
		ambient_craven = HAGIS.DialogLoad("Dialogs/Prologue/Ambient_Craven");
		Ambient_AmbrosiaBehind = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_AmbrosiaBehind");
		Ambient_ArchiGo = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ArchiGo");
		Ambient_ArchiWilla = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ArchiWilla");
		Ambient_ChrisWeTried = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ChrisWeTried");
		Ambient_FullTragicEndingCom = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_FullTragicEndingCom");
		Ambient_FullTragicEndingHon = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_FullTragicEndingHon");
		Ambient_GetMoving = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_GetMoving");
		Ambient_HappyEnding = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_HappyEnding");
		Ambient_HartmanGoodKid = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_HartmanGoodKid");
		Ambient_HartmanLive = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_HartmanLive");
		Ambient_HartmanSaveHer = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_HartmanSaveHer");
		Ambient_HartmanWasShe = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_HartmanWasShe");
		Ambient_NootStillIn = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_NootStillIn");
		Ambient_RedemptionEndingCom = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_RedemptionEndingCom");
		Ambient_RedemptionEndingHon = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_RedemptionEndingHon");
		Ambient_TheoArrest = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoArrest");
		Ambient_TheoArrestCONT = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoArrestCONT");
		Ambient_TheoBrave = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoBrave");
		Ambient_TheoDammit = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoDammit");
		Ambient_TheoFinally = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoFinally");
		Ambient_WelcomeHome = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WelcomeHome");
		Ambient_TragicEndingCom = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TragicEndingCom");
		Ambient_TragicEndingHon = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TragicEndingHon");
		Ambient_WillaAlone = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaAlone");
		Ambient_WillaCraven = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaCraven");
		Ambient_WillaGuys = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaGuys");
		Ambient_WillaHeyCravenFullTragic = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHeyCravenFullTragic");
		Ambient_WillaHeyCravenHappy = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHeyCravenHappy");
		Ambient_WillaHeyCravenRed = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHeyCravenRed");
		Ambient_WillaHeyCravenTragic = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHeyCravenTragic");
		Ambient_WillaHold = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHold");
		Ambient_WillaHuh = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaHuh");
		Ambient_WillaIncoming = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaIncoming");
		Ambient_WillaIsThat = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaIsThat");
		Ambient_WillaItsMe = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaItsMe");
		Ambient_WillaLookDown1 = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaLookDown1");
		Ambient_WillaLookDown2 = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaLookDown2");
		Ambient_WillaNo = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaNo");
		Ambient_WillaOver = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaOver");
		Ambient_WillaPlatform = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaPlatform");
		Ambient_WillaSob = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaSob");
		Dialog_AmbrosiaBeSafe = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_AmbrosiaBeSafe");
		Dialog_ArchiComeOn = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiComeOn");
		Dialog_ArchiComeOn2 = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiComeOn2");
		Dialog_ArchiComeOn3 = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiComeOn3");
		Dialog_ArchiHey = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiHey");
		Dialog_ArchiNotYou = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiNotYou");
		Dialog_ArchiRightHere = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiRightHere");
		Dialog_ArchiSlowDown = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiSlowDown");
		Dialog_ArchiTheDroids = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiTheDroids");
		Dialog_ChrisSuprise = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ChrisSuprise");
		Dialog_EtemenExhibit = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_EtemenExhibit");
		Dialog_HartmanCalmDown = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanCalmDown");
		Dialog_HartmanDemon = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanDemon");
		Dialog_HartmanGetHim = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanGetHim");
		Dialog_HartmanGetIn = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanGetIn");
		Dialog_HartmanJules = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanJules");
		Dialog_HartmanLostControl = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_HartmanLostControl");
		Dialog_JulesPlease = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_JulesPlease");
		Dialog_JulesShit = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_JulesShit");
		Dialog_KeyToCity = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_KeyToCity");
		Dialog_MargotBreath = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_MargotBreath");
		Dialog_MargotShutUp = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_MargotShutUp");
		Dialog_WiallNoot = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaNoot");
		Dialog_WillaAreThey = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaAreThey");
		Dialog_WillaCondem = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaCondem");
		Dialog_WillaDropIt = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaDropIt");
		Dialog_WillaForWhat = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaForWhat");
		Dialog_WillaForWhatHappy = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaForWhatHappy");
		Dialog_WillaForWhatTragic = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaForWhatTragic");
		Dialog_WillaHowDo = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaHowDo");
		Dialog_WillaJuels = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaJuels");
		Dialog_ArchiRightHereCont = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_ArchiRightHereCont");
		Dialog_WillaOffice = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaOffice");
		Dialog_WillaProud = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaProud");
		Dialog_WillaTakeCare = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaTakeCare");
		Dialog_WillaTookEverything = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaTookEverything");
		Dialog_Window = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_Window");
		Dilaog_WillaWasteTime = HAGIS.DialogLoad("Dialogs/A3S2/Dilaog_WillaWasteTime");
		Dialog_LevelTenThousand = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_levelTenThousand");
		Dialog_SlowDown = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_SlowDown");
		Dialog_DoesntFeelGreat = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_DoesntFeelGreat");
		Dialog_DoesntFeelGreatCont = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_DoesntFeelGreatCont");
		int origAmbientSubtitleSortOrder = UIAmbientSubtitles.Inst.textboxSubtitles.sortingOrder;
		button_LookDownDetection.gameObject.SetActive(value: false);
		ToggleAscensionPlatformBorder(blocking: false);
		Ambrosia.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		Robot1_BTExt.gameObject.SetActive(value: false);
		Robot2_BTExt.gameObject.SetActive(value: false);
		Robot3_BTExt.gameObject.SetActive(value: false);
		BTowerExToBTowerInt.gameObject.SetActive(value: false);
		Robot_CTC1.gameObject.SetActive(value: false);
		Robot_CTC2.gameObject.SetActive(value: false);
		Robot_CTC3.gameObject.SetActive(value: false);
		Theo.gameObject.SetActive(value: false);
		WellnessOfficer.gameObject.SetActive(value: false);
		EscapePod.gameObject.SetActive(value: false);
		ChumleyDroid_1.gameObject.SetActive(value: false);
		ChumleyDroid_2.gameObject.SetActive(value: false);
		ChumleyDroid_3.gameObject.SetActive(value: false);
		EscapePod.gameObject.SetActive(value: false);
		BTowerToCelestiaTown.gameObject.SetActive(value: false);
		OmegaOffice.Map.EnableEmpEffect(enabled: false);
		CelestiaTownCenter.Map.EnableEmpEffect(enabled: false);
		TenorCentreToMuseum.gameObject.SetActive(value: false);
		LandingPadToOmega.gameObject.SetActive(value: false);
		GardenToBTower.gameObject.SetActive(value: false);
		PlayMapAnimation(LandingPad.Map, "MA_LandingPad_Aircraft", "Hidden");
		yield return null;
		MusicPlay("event:/music/tracks/basic/generic combat 3 tension");
		yield return CutscenePlay("A3S2_Cutscene_Console");
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadForCelestiatower);
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultUnconscious");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultUnconscious");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultViolinIdle");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultViolinWalk");
		Robot_BTInt1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Robot_BTInt1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Robot_BTInt2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return MapWaitUntilVisible(BroadcastTowerExterior.Map);
		BTowerToGarden.gameObject.SetActive(value: false);
		HagletTrigger TalkedToChris = I_ChrisBTExterior.OnTriggered;
		yield return CreateAndCondition(term2: I_NootBTExterior.OnTriggered, term1: TalkedToChris);
		I_ChrisBTExterior.gameObject.SetActive(value: false);
		I_NootBTExterior.gameObject.SetActive(value: false);
		BTowerExToBTowerInt.gameObject.SetActive(value: true);
		D_BrodcastDoor.gameObject.SetActive(value: false);
		D_ToGardens.gameObject.SetActive(value: false);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGoCheckOnArchi);
		SKIP_POINT("Save Archi");
		yield return MapWaitUntilVisible(BroadcastTowerInterior.Map);
		MusicPlay("event:/music/tracks/combat/willas combat");
		CutsceneBegin();
		yield return null;
		UnitMoveToTarget(Robot_BTInt1, T_Robot1_BTInt, null, 5f);
		UnitMoveToTarget(Robot_BTInt2, T_Robot2_BTInt, null, 5f);
		yield return UnitMoveToTarget(Willa, T_Willa_BTInt, null, 5f);
		BTowerIntToBTowerEx.gameObject.SetActive(value: false);
		CutsceneEnd();
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicStop();
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		yield return CreateTriggerCondition(I_ArchiBTInterior.OnTriggered);
		CutsceneBegin();
		Willa.LookAt(Archi);
		Willa.unitModel.Play("CsDefaultKickArchie", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return Archi.unitModel.Play("CsDefaultUnconsciousKickReaction", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return CreateTimeCondition(1f);
		Willa.unitModel.Play("CsDefaultKickArchie", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return Archi.unitModel.Play("CsDefaultUnconsciousKickReaction", looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_ArchiNotYou);
		yield return Archi.unitModel.Play("CsTransUnconsciousToDIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		yield return Archi.unitModel.Play("DefaultIdle");
		Archi.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Dialog_HartmanGetHim);
		Archi.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		SKIP_POINT("Woken Archi, must escape the tower interior");
		BTowerIntToBTowerEx.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(BroadcastTowerExterior.Map);
		yield return CreateTimeCondition(1f);
		Archi.IsAttackingDisabled = false;
		SKIP_POINT("Saved Archi");
		MusicPlay("event:/music/tracks/basic/drone 2");
		UIObjectives.Inst.CompleteObjective(objGoCheckOnArchi);
		BTowerExToBTowerInt.gameObject.SetActive(value: false);
		yield return CutscenePlay("A3S2_Cutscene_EscortingArchi");
		MusicStop();
		SFXPlay("event:/sfx/script/act 1/a1s1/pa system feedback");
		SKIP_POINT("Craven's room Being EMP");
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_JulesPlease);
		SFXPlay("event:/sfx/script/act 3/a3o8/emp hit with interference");
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(0.5f);
		LoopingSFX sfxInterferenceLoop = LoopingSFXPlay("event:/sfx/script/act 3/a3o8/map flicker after emp");
		BroadcastTowerExterior.Map.EnableEmpEffect(enabled: true);
		BotanicalGarden.Map.EnableEmpEffect(enabled: true);
		yield return CreateTimeCondition(2f);
		sfxInterferenceLoop.Stop();
		CutsceneEnd();
		yield return ShowRoom(Room_5);
		Willa.unitModel.ClearAnimOverride(UnitModel.AnimID.DefaultIdle);
		Hartman_SetMood(Hartman.Mood.Default);
		SFXPlay("event:/sfx/character v2/foley/unique/hartman/death");
		Hartman_TeleportToPointWithLookAt(move_window, L_Phone);
		Hartman_PlayAnimation("DefaultDeath");
		yield return CreateTimeCondition(0.7f);
		yield return CreateTimeCondition(0.45f);
		Hartman_PlayAnimation("DeathPose");
		yield return CreateTimeCondition(2f);
		Hartman_PlayAnimation("DeathTalk");
		HAGIS.DialogShow(Ambient_HartmanSaveHer);
		yield return CreateTimeCondition(1f);
		Hartman_PlayAnimation("DeathTalk");
		yield return CreateTimeCondition(1.3f);
		Hartman_PlayAnimation("DeathPose", playIdleOnComplete: false);
		yield return CreateTimeCondition(0.45f);
		sfxInterferenceLoop.Restart();
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneel");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultKneel");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultKneel");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CsDefaultKneel");
		yield return ShowMap();
		MusicPlay("event:/music/tracks/basic/craven glitchy");
		CutsceneBegin();
		yield return CreateTimeCondition(4f);
		yield return HAGIS.DialogShow(Dialog_HartmanLostControl);
		UIObjectives.Inst.CompleteAndSetMainObjective(objGetToPod);
		yield return UnitMoveToTarget(Willa, T_Willa_ExitToGarden);
		yield return HAGIS.DialogShow(Dialog_WillaTakeCare);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		yield return TeamMoveToMapViaEntranceTile(GardenToBTower);
		SKIP_POINT("Just before Craven's room cutscene");
		yield return MapGoto(BotanicalGarden);
		CutsceneEnd();
		yield return null;
		yield return CutscenePlay("A3S2_Cutscene_WillaGetsInPod");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultWalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		UIObjectives.Inst.CompleteObjective(objGetToPod);
		EscapePod.gameObject.SetActive(value: true);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Willa.gameObject.SetActive(value: false);
		yield return CreateTimeCondition(1f);
		MusicStop();
		sfxInterferenceLoop.Stop();
		yield return ShowRoom(Room_5);
		SKIP_POINT("willa enters the room");
		yield return CreateTimeCondition(3f);
		SFXPlay("event:/sfx/script/act 3/a3s2/pod impact");
		KubrickBase WillasDoor = GetRoomAnimator("MA_FrontDoor");
		HAGIS.ToggleShakeEnvironment(on: false);
		WillaLeaving endingType = WillaLeaving.Happy;
		CutsceneBegin();
		yield return CreateTimeCondition(6f);
		SFXPlay("event:/sfx/script/act 3/a3s2/pod door opening in penthouse");
		yield return CreateTimeCondition(7f);
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_door knock");
		yield return CreateTimeCondition(2f);
		BigWilla.Play("SQ01");
		WillasDoor.Play("SQ01");
		yield return null;
		BigWilla.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.7f);
		SFXPlay("event:/sfx/script/act 3/a3s2/big willa 1_enters room");
		yield return CreateTimeCondition(3f);
		HAGIS.DialogShow(Ambient_WillaItsMe);
		yield return CreateTimeCondition(9f);
		yield return CreateTimeCondition(11f);
		BigWilla.Play("SQ02_Idle");
		BigWilla.WrapMode = WrapMode.Loop;
		SKIP_POINT("Willa - your a mess");
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(0.1f);
		BigWilla.WrapMode = WrapMode.Once;
		BigWilla.Play("SQ03");
		SKIP_POINT("WAITING FOR PLAYER TO LOWER HEAD CRAVENS ROOM");
		yield return CreateTimeCondition(6f);
		button_LookDownDetection.gameObject.SetActive(value: true);
		HagletYieldTerm WaitedForX = CreateTimeCondition(5f);
		yield return CreateOrCondition(button_LookDownDetection.OnFocusEnter, WaitedForX);
		if (WaitedForX.met)
		{
			BigWilla.WrapMode = WrapMode.Loop;
			BigWilla.Play("SQ02_Idle");
			yield return button_LookDownDetection.OnFocusEnter;
		}
		FadeToBlack();
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_willa fix craven");
		yield return CreateTimeCondition(2f);
		UIAmbientSubtitles.Inst.textboxSubtitles.sortingOrder = 32767;
		UIAmbientSubtitles.Inst.textboxSubtitles.UpdateSortingOrder();
		HAGIS.DialogShow(Ambient_WillaIsThat);
		yield return CreateTimeCondition(4f);
		yield return CreateTimeCondition(8f);
		BigWilla.WrapMode = WrapMode.Loop;
		BigWilla.Play("SQ04");
		yield return CreateTimeCondition(1f);
		FadeToClear();
		UIAmbientSubtitles.Inst.textboxSubtitles.sortingOrder = origAmbientSubtitleSortOrder;
		UIAmbientSubtitles.Inst.textboxSubtitles.UpdateSortingOrder();
		yield return CreateTimeCondition(2f);
		SKIP_POINT("goddamn lipsync willa");
		yield return HAGIS.DialogShow(Ambient_WillaCraven);
		switch (GetEndingState())
		{
		case WillaOnFloor.BeenAGoodFriend:
			HagisLog("YOU GOT HAPPY ENDING");
			yield return CreateTimeCondition(2f);
			endingType = WillaLeaving.Happy;
			yield return HAGIS.DialogShow(Ambient_HappyEnding);
			BigWilla.Play("SQ05_VO39");
			yield return CreateTimeCondition(8f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(3f);
			break;
		case WillaOnFloor.Redemption_ThankyouForFinallyBeingHonest:
			HagisLog("YOU GOT REDEMPTION ENDING 1");
			yield return CreateTimeCondition(2f);
			yield return HAGIS.DialogShow(Ambient_RedemptionEndingHon);
			endingType = WillaLeaving.Redemption;
			BigWilla.Play("SQ05_VO43");
			yield return CreateTimeCondition(10f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		case WillaOnFloor.Redemption_ThankyouForActingLikeYouCared:
			HagisLog("YOU GOT REDEMPTION ENDING 2");
			yield return CreateTimeCondition(2f);
			yield return HAGIS.DialogShow(Ambient_RedemptionEndingCom);
			endingType = WillaLeaving.Redemption;
			BigWilla.Play("SQ05_VO43");
			yield return CreateTimeCondition(9f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		case WillaOnFloor.GoodThenTragic_ActLikeYouCared:
			HagisLog("YOU GOT TRAGIC ENDING 1");
			endingType = WillaLeaving.HappyThenTragic;
			yield return CreateTimeCondition(2f);
			yield return HAGIS.DialogShow(Ambient_TragicEndingHon);
			BigWilla.Play("SQ05_VO49");
			yield return CreateTimeCondition(11f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		case WillaOnFloor.GoodThenTragic_WhatHappenedToUsHonest:
			HagisLog("YOU GOT TRAGIC ENDING 2");
			yield return CreateTimeCondition(2f);
			yield return HAGIS.DialogShow(Ambient_TragicEndingCom);
			endingType = WillaLeaving.HappyThenTragic;
			BigWilla.Play("SQ05_VO49");
			yield return CreateTimeCondition(10f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		case WillaOnFloor.Tragic_PretendLikeYouCared:
			HagisLog("YOU GOT FULL TRAGIC ENDING 1 YOU BIG BASTARD");
			yield return CreateTimeCondition(2f);
			yield return HAGIS.DialogShow(Ambient_FullTragicEndingCom);
			endingType = WillaLeaving.FullTragic;
			BigWilla.Play("SQ05_VO54");
			yield return CreateTimeCondition(8f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		case WillaOnFloor.Tragic_BrutalHonesty:
			HagisLog("YOU GOT FULL TRAGIC ENDING 2 YOU BIG BASTARD");
			yield return CreateTimeCondition(2f);
			endingType = WillaLeaving.FullTragic;
			yield return HAGIS.DialogShow(Ambient_FullTragicEndingHon);
			BigWilla.Play("SQ05_VO54");
			yield return CreateTimeCondition(8f);
			BigWilla.Play("SQ06");
			HagisLog("HERE LET ME");
			yield return CreateTimeCondition(4f);
			break;
		}
		UnitMoveToTarget(Noot, T_Noot_BTExt);
		UnitMoveToTarget(Ambrosia, T_Willa_BTExt);
		UnitMoveToTarget(Chris, T_Chris_BTExt);
		yield return ShowMap(BroadcastTowerExterior.Map);
		sfxInterferenceLoop.Restart();
		SFXPlay("event:/sfx/ability/auto revive");
		SKIP_POINT("Outside broadcast tower");
		BTowerToGarden.gameObject.SetActive(value: false);
		Robot3_BTExt.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(Ambient_WillaGuys);
		UIObjectives.Inst.CompleteAndSetMainObjective(objFight);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Ambrosia.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Noot);
		SFXPlay("event:/sfx/ability/auto revive");
		MusicPlay("event:/music/tracks/combat/willas combat");
		BroadcastTowerExterior.Map.EnableEmpEffect(enabled: false);
		sfxInterferenceLoop.Stop();
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/new savannah underscore");
		UIObjectives.Inst.CompleteObjective(objFight);
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.UpdateIdleAnim();
		Noot.UpdateIdleAnim();
		yield return UnitPlayAnimation(Margot, "CsTransKneelToDIdle");
		yield return Archi.unitModel.Play("CsTransKneelToDIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		Margot.UpdateIdleAnim();
		Archi.UpdateIdleAnim();
		HAGIS.DialogShow(Ambient_GetMoving);
		BTowerToCelestiaTown.gameObject.SetActive(value: true);
		CelestiaTownCenter.unitsMoveToDefaultPositions = false;
		BTowerToGarden.gameObject.SetActive(value: false);
		Robot_CTC1.gameObject.SetActive(value: true);
		Robot_CTC2.gameObject.SetActive(value: true);
		Robot_CTC3.gameObject.SetActive(value: true);
		yield return MapWaitUntilVisible(CelestiaTownCenter.Map);
		CutsceneBegin();
		yield return CreateAndCondition(UnitMoveToTarget(Noot, T_NootCT, null, 5f), UnitMoveToTarget(Ambrosia, T_AmbroCT, null, 5f), UnitMoveToTarget(Chris, T_ChrisCT, null, 5f));
		CutsceneEnd();
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objFight);
		MusicPlay("event:/music/tracks/combat/droid combat 2");
		yield return CombatBegin(UnitTeam.Type.Player);
		MusicPlay("event:/music/tracks/basic/new savannah underscore");
		UIObjectives.Inst.CompleteObjective(objFight);
		CutsceneBegin();
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		yield return UnitTeleportToMapViaEntranceTile(Margot, CelestiaTCToBTowerEx, T_MargotCT);
		yield return UnitTeleportToMapViaEntranceTile(Archi, CelestiaTCToBTowerEx, T_ArchiCT);
		yield return HAGIS.DialogShow(Dialog_WillaOffice);
		yield return UnitMoveToTarget(Noot, T_Ladder);
		Noot.Hide(makeInactive: true);
		yield return UnitMoveToTarget(Chris, T_Ladder);
		Chris.Hide(makeInactive: true);
		yield return UnitMoveToTarget(Ambrosia, T_Ladder);
		Ambrosia.Hide(makeInactive: true);
		UnitMoveToTarget(Archi, T_ladder_Archi);
		yield return CreateTimeCondition(0.2f);
		yield return UnitMoveToTarget(Margot, T_Ladder_Margot);
		Margot.LookAt(Archi);
		Archi.LookAt(Margot);
		yield return HAGIS.DialogShow(Dialog_ArchiHey);
		MusicPlay("event:/music/tracks/bespoke/margot kiss");
		UnitPlayAnimation(Margot, "CsKissArchi");
		yield return UnitPlayAnimation(Archi, "CsDefaultBeingKissed");
		yield return HAGIS.DialogShow(Dialog_MargotShutUp);
		MusicStop();
		yield return UnitMoveToTarget(Margot, T_Ladder);
		Margot.Hide(makeInactive: false);
		yield return UnitMoveToTarget(Archi, T_Ladder);
		Archi.Hide(makeInactive: true);
		yield return HAGIS.DialogShow(Dialog_WillaHowDo);
		yield return CreateTimeCondition(1f);
		yield return MapGoto(AscensionPlatform);
		SKIP_POINT(" Ascension platform ");
		HAGIS.DialogShow(Ambient_WillaPlatform);
		yield return CreateTimeCondition(2f);
		yield return ShowRoom(Room_5);
		yield return null;
		WillasDoor = GetRoomAnimator("MA_FrontDoor");
		SKIP_POINT("Door Ending");
		if (endingType == WillaLeaving.Happy)
		{
			BigWilla.Play("SQ07");
			WillasDoor.Play("SQ07");
			yield return CreateTimeCondition(1f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves the room");
			yield return CreateTimeCondition(12f);
			HAGIS.DialogShow(Ambient_WillaHeyCravenHappy);
			yield return CreateTimeCondition(1f);
			BigWilla.Play("SQ08_A");
			WillasDoor.Play("SQ08_A");
			yield return CreateTimeCondition(3f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves and closes the door");
			BigWilla.WrapMode = WrapMode.Once;
			yield return CreateTimeCondition(6f);
			BigWilla.gameObject.SetActive(value: false);
		}
		if (endingType == WillaLeaving.Redemption)
		{
			BigWilla.Play("SQ07");
			WillasDoor.Play("SQ07");
			yield return CreateTimeCondition(1f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves the room");
			yield return CreateTimeCondition(11f);
			HAGIS.DialogShow(Ambient_WillaHeyCravenRed);
			yield return CreateTimeCondition(2f);
			BigWilla.Play("SQ08_B");
			WillasDoor.Play("SQ08_A");
			yield return CreateTimeCondition(3f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves and closes the door");
			BigWilla.WrapMode = WrapMode.Once;
			yield return CreateTimeCondition(7f);
			BigWilla.gameObject.SetActive(value: false);
		}
		if (endingType == WillaLeaving.HappyThenTragic)
		{
			BigWilla.Play("SQ07");
			WillasDoor.Play("SQ07");
			yield return CreateTimeCondition(1f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves the room");
			yield return CreateTimeCondition(11f);
			HAGIS.DialogShow(Ambient_WillaHeyCravenTragic);
			yield return CreateTimeCondition(2f);
			BigWilla.Play("SQ08_C");
			WillasDoor.Play("SQ08_C");
			yield return CreateTimeCondition(1.6f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves and closes the door");
			BigWilla.WrapMode = WrapMode.Once;
			yield return CreateTimeCondition(4f);
			BigWilla.gameObject.SetActive(value: false);
		}
		if (endingType == WillaLeaving.FullTragic)
		{
			BigWilla.Play("SQ07");
			WillasDoor.Play("SQ07");
			yield return CreateTimeCondition(1f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves the room");
			yield return CreateTimeCondition(11f);
			HAGIS.DialogShow(Ambient_WillaHeyCravenFullTragic);
			yield return CreateTimeCondition(2f);
			BigWilla.Play("SQ08_D");
			WillasDoor.Play("SQ08_C");
			yield return CreateTimeCondition(1.6f);
			SFXPlay("event:/sfx/script/act 3/a3s2/willa leaves and closes the door");
			BigWilla.WrapMode = WrapMode.Once;
			yield return CreateTimeCondition(7f);
			BigWilla.gameObject.SetActive(value: false);
		}
		yield return CreateTimeCondition(3f);
		yield return Hartman_PlayAnimation("TransDeathToDefaultIdle");
		Hartman_PlayAnimation("DefaultIdle");
		yield return CreateTimeCondition(1f);
		Hartman_LookAtPoint(look_Photo, 1f);
		HAGIS.DialogShow(Ambient_HartmanWasShe);
		yield return CreateTimeCondition(1.2f);
		Hartman_LookAtPoint(look_window, 2f);
		yield return CreateTimeCondition(2.2f);
		Hartman_LookAtPoint(look_player, 0.5f);
		yield return CreateTimeCondition(1f);
		yield return Hartman_MoveToPoint(move_tableFront, 2f);
		Hartman_LookAtPoint(look_player, 0.25f);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_HartmanLive);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(1.5f);
		Hartman_SetMood(Hartman.Mood.Default);
		yield return Hartman_PlayAnimation("TransCIdleToDIdle");
		Hartman_PlayAnimation("DefaultBashTable");
		yield return CreateTimeCondition(1.1f);
		SFXPlay("event:/sfx/character v2/weapon/punch heavy");
		yield return CreateTimeCondition(1f);
		SFXPlay("event:/sfx/ability/restore");
		yield return CreateTimeCondition(2f);
		HAGIS.DialogShow(Ambient_HartmanGoodKid);
		Hartman_SetMood(Hartman.Mood.Concerned);
		Hartman_PlayAnimation("TransDIdleToCIdle");
		yield return CreateTimeCondition(2f);
		yield return ShowMap();
		SKIP_POINT("Skipped to Tenor City Center");
		yield return UnitTeleportToMapViaEntranceTile(Willa, EnterTenorCittyCentre);
		EnterTenorCittyCentre.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: false);
		yield return MapGoto(TenorCityCentre);
		CutsceneEnd();
		yield return null;
		MusicPlay("event:/music/tracks/bespoke/sunset sting");
		yield return CutscenePlay("A3S2_Cutscene_WillaTenorCity");
		yield return CreateTimeCondition(1f);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_HartmanDemon);
		yield return UnitTeleportToMapViaEntranceTile(Willa, AsExhibitToTenorCityCentre);
		Willa.LookInDirection(OctDir.Right);
		Archi.gameObject.SetActive(value: false);
		Noot.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		Ambrosia.gameObject.SetActive(value: false);
		Chris.gameObject.SetActive(value: false);
		PlayMapAnimation(AscensionExhibit.Map, "MA_KeyToCity", "Collected");
		yield return null;
		yield return UnitTeleportToMapViaEntranceTile(Archi, AscensionPlatToAscensionExhibit, T_Archi);
		yield return UnitTeleportToMapViaEntranceTile(Noot, AscensionPlatToAscensionExhibit, T_Noot);
		yield return UnitTeleportToMapViaEntranceTile(Margot, AscensionPlatToAscensionExhibit, T_TheoAP);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, AscensionPlatToAscensionExhibit, T_Ambro);
		yield return UnitTeleportToMapViaEntranceTile(Chris, AscensionPlatToAscensionExhibit, T_Chris);
		yield return null;
		Willa.gameObject.SetActive(value: false);
		yield return MapGoto(AscensionExhibit);
		PlayMapAnimation(AscensionExhibit.Map, "CH_AscensionCurtain", "Open");
		Willa.SetTeamType(UnitTeam.Type.Player);
		yield return null;
		Willa.gameObject.SetActive(value: true);
		yield return null;
		AsExhibitToTenorCityCentre.gameObject.SetActive(value: false);
		CutsceneEnd();
		GC.Inst.SetRPGLeader(Willa);
		yield return HAGIS.DialogShow(Dialog_HartmanCalmDown);
		UIObjectives.Inst.CompleteAndSetMainObjective(objToAscension);
		SKIP_POINT("Theo Fight set up");
		yield return MapWaitUntilVisible(AscensionPlatform.Map);
		MusicStop();
		Archi.IsAttackingDisabled = false;
		AscensionPlatToAscensionExhibit.gameObject.SetActive(value: false);
		AscensionPlatToWelcomeExhibit.gameObject.SetActive(value: false);
		yield return CreateTriggerCondition(I_Console.OnTriggered);
		UIObjectives.Inst.CompleteObjective(objToAscension);
		SKIP_POINT("Theo Enters");
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_LevelTenThousand);
		yield return UnitPlayAnimation(Willa, "DefaultInteract", loop: false, updateIdle: true);
		yield return UnitMoveToTarget(Willa, T_Willa);
		UnitLookInDirection(Willa, OctDir.Down);
		yield return CreateTimeCondition(1f);
		yield return UnitPlayAnimation(Willa, "DefaultLookAroundTonedDown", loop: false, updateIdle: true);
		yield return CreateTimeCondition(4f);
		HAGIS.DialogShow(Ambient_TheoArrest);
		yield return UnitPlayAnimation(Willa, "DefaultLookAround", loop: false, updateIdle: true);
		yield return CreateTimeCondition(1f);
		Theo.gameObject.SetActive(value: true);
		Willa.LookAt(Theo);
		yield return UnitMoveToTarget(Theo, T_TheoAP);
		HAGIS.ToggleShakeEnvironment(on: true);
		SFXPlayAtCoord("event:/sfx/script/act 3/a3s2/ascension platform rising", sfx_ascension_platform_rises);
		PlayMapAnimation(AscensionPlatform.Map, "MA_AcsensionPlatform_01", "AcsensionPlatform");
		PlayMapAnimation(AscensionPlatform.Map, "MA_AcsensionCloud_01", "MA_AcsensionPlatform_Cloud_01", loop: true);
		PlayMapAnimation(AscensionPlatform.Map, "MA_AcsensionCloud_02", "MA_AcsensionPlatform_Cloud_02", loop: true);
		PlayMapAnimation(AscensionPlatform.Map, "MA_AcsensionCloud_03", "MA_AcsensionPlatform_03", loop: true);
		PlayMapAnimation(AscensionPlatform.Map, "MA_AcsensionCloud_04", "MA_AcsensionPlatform_Cloud_04", loop: true);
		ToggleAscensionPlatformBorder(blocking: true);
		HAGIS.ToggleShakeEnvironment(on: false);
		Willa.LookAt(Theo);
		Theo.LookAt(Willa);
		yield return CreateAndCondition(UnitPlayAnimation(Theo, "TransDIdleToCIdle"), UnitPlayAnimation(Willa, "TransDIdleToCIdle"));
		yield return CreateAndCondition(UnitPlayAnimation(Theo, "CombatIdle"), UnitPlayAnimation(Willa, "CombatIdle"));
		yield return CreateAndCondition(UnitPlayAnimation(Theo, "TransCIdleToAIdle"), UnitPlayAnimation(Willa, "TransCIdleToAIdle"));
		UnitPlayAnimation(Theo, "CombatAimIdle", loop: true);
		UnitPlayAnimation(Willa, "CombatAimIdle", loop: true);
		HAGIS.DialogShow(Ambient_TheoArrestCONT);
		yield return CreateTimeCondition(3.5f);
		yield return UnitPlayAnimation(Theo, "TransAIdleToCIdle");
		yield return UnitPlayAnimation(Theo, "TransCIdleToDIdle", loop: false, updateIdle: true);
		yield return UnitPlayAnimation(Theo, "DefaultTalk", loop: false, updateIdle: true);
		yield return CreateTimeCondition(7f);
		yield return UnitPlayAnimation(Theo, "TransDIdleToCIdle");
		UnitPlayAnimation(Theo, "CombatIdle");
		CutsceneEnd();
		SKIP_POINT("Theo FightStart");
		yield return CreateTimeCondition(1f);
		CombatBegin(UnitTeam.Type.Enemy);
		if (!MR.Inst.IsSkipping())
		{
			theoBossFight.Trigger();
		}
		yield return Theo.OnDeathComplete;
		MusicSetProgress(0.2f);
		yield return EndTurnMode();
		Ability_DEBUG_CantDie ability_DEBUG_CantDie = Willa.abilities.AbilityGetByType<Ability_DEBUG_CantDie>();
		if (ability_DEBUG_CantDie != null)
		{
			Willa.abilities.Remove(ability_DEBUG_CantDie, isProxy: false);
		}
		MusicSetProgress(0.6f);
		yield return HAGIS.DialogShow(Ambient_TheoFinally);
		CutsceneBegin();
		if (WellnessOfficer.IsActiveOnMap())
		{
			yield return UnitMoveToTarget(WellnessOfficer, T_TWO);
			UnitPlayAnimation(WellnessOfficer, "TransCIdleToCCrouch");
			WellnessOfficer.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
			WellnessOfficer.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatCrouch");
		}
		yield return UnitMoveToTarget(Willa, T_Willa);
		if (!Archi.IsActiveOnMap())
		{
			Archi.SetActiveWithAnimation("CsAbilityGroundPoundEnd", updateIdleOnComplete: true);
		}
		if (!Noot.IsActiveOnMap())
		{
			Noot.SetActiveWithAnimation("AbilityGroundPoundEnd", updateIdleOnComplete: true);
		}
		yield return CreateTimeCondition(1f);
		if (!Chris.IsActiveOnMap())
		{
			Chris.SetActiveWithAnimation("CsAbilityGroundPoundEnd", updateIdleOnComplete: true);
		}
		Archi.LookAt(Willa);
		Noot.LookAt(Willa);
		Chris.LookAt(Willa);
		yield return CreateTimeCondition(0.5f);
		if (!Margot.IsActiveOnMap())
		{
			Margot.SetActiveWithAnimation("TransCCrouchToCIdle", updateIdleOnComplete: true);
		}
		if (!Ambrosia.IsActiveOnMap())
		{
			Ambrosia.SetActiveWithAnimation("TransCCrouchToCIdle", updateIdleOnComplete: true);
		}
		Margot.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		Archi.SetTeamType(UnitTeam.Type.NPC);
		Noot.SetTeamType(UnitTeam.Type.NPC);
		Chris.SetTeamType(UnitTeam.Type.NPC);
		Margot.SetTeamType(UnitTeam.Type.NPC);
		Ambrosia.SetTeamType(UnitTeam.Type.NPC);
		yield return CreateTimeCondition(0.5f);
		yield return CreateAndCondition(UnitMoveToTarget(Noot, T_Noot), UnitMoveToTarget(Archi, T_Archi), UnitMoveToTarget(Ambrosia, T_Ambro), UnitMoveToTarget(Chris, T_Chris), UnitMoveToTarget(Margot, T_TheoAP));
		HAGIS.ToggleShakeEnvironment(on: true);
		yield return CreateTimeCondition(5f);
		UnitTeleportToMapViaEntranceTile(Willa, WelcomeExToAscensionPlat, T_WillaCellExhib);
		UnitTeleportToMapViaEntranceTile(Archi, WelcomeExToAscensionPlat, T_ArchiCellExhib);
		UnitTeleportToMapViaEntranceTile(Noot, WelcomeExToAscensionPlat, T_NootCellExhib);
		UnitTeleportToMapViaEntranceTile(Chris, WelcomeExToAscensionPlat, T_ChrisCellExhib);
		UnitTeleportToMapViaEntranceTile(Margot, WelcomeExToAscensionPlat, T_MargotCellExhib);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, WelcomeExToAscensionPlat, T_AmbrosiaCellExhib);
		HAGIS.ToggleShakeEnvironment(on: false);
		SKIP_POINT("Welcome To Celestia");
		yield return MapGoto(WelcomeToCelestia);
		MusicPlay("event:/music/tracks/basic/new savannah");
		Archi.gameObject.SetActive(value: true);
		Noot.gameObject.SetActive(value: true);
		Margot.gameObject.SetActive(value: true);
		Ambrosia.gameObject.SetActive(value: true);
		Chris.gameObject.SetActive(value: true);
		yield return HAGIS.DialogShow(Ambient_WelcomeHome);
		HAGIS_A3S2 hAGIS_A3S = this;
		Unit willa = Willa;
		UnitTarget t_WillaCellExhibLeave = T_WillaCellExhibLeave;
		float? speed = Willa.charData.movementSpeedInCombat;
		hAGIS_A3S.UnitMoveToTarget(willa, t_WillaCellExhibLeave, null, speed);
		Willa.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		UnitMoveToTarget(Archi, T_ArchiCellExhib2);
		yield return CreateTimeCondition(1.5f);
		UnitMoveToTarget(Noot, T_NootCellExhib2, OctDir.Up);
		Archi.LookAt(Willa);
		Margot.LookAt(Willa);
		Chris.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		WelcomeExToAscensionPlat.gameObject.SetActive(value: false);
		WelcomeExToOmegaOffice.gameObject.SetActive(value: false);
		yield return HAGIS.DialogShow(Ambient_ArchiWilla);
		Willa.LookAt(Archi);
		SKIP_POINT("Waiting on player to leave to face Jules");
		yield return CreateTimeCondition(0.5f);
		yield return HAGIS.DialogShow(Dialog_SlowDown);
		Archi.LookInDirection(OctDir.Up);
		Margot.LookInDirection(OctDir.Up);
		Chris.LookInDirection(OctDir.Left);
		Noot.LookInDirection(OctDir.Up);
		Ambrosia.LookInDirection(OctDir.Up);
		yield return CreateTimeCondition(1f);
		CutsceneEnd();
		bool PlayerLeaves = false;
		while (!PlayerLeaves)
		{
			yield return CreateTriggerCondition(I_OmegaOfficeExit.OnTriggered);
			yield return HAGIS.DialogShow(Dialog_HartmanJules);
			switch (Dialog_HartmanJules.currentResponseLine)
			{
			case 1u:
				PlayerLeaves = true;
				break;
			}
		}
		CutsceneBegin();
		Noot.LookAt(Willa);
		Ambrosia.LookAt(Willa);
		Archi.LookAt(Willa);
		Chris.LookAt(Willa);
		Margot.LookAt(Willa);
		yield return UnitMoveToTarget(Willa, T_WillaCellExhibLeave2);
		yield return CreateTimeCondition(0.5f);
		ChumleyDroid_1.gameObject.SetActive(value: true);
		ChumleyDroid_2.gameObject.SetActive(value: true);
		ChumleyDroid_3.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(0.5f);
		Noot.LookAt(ChumleyDroid_1);
		Ambrosia.LookAt(ChumleyDroid_2);
		Archi.LookAt(ChumleyDroid_3);
		Chris.LookAt(ChumleyDroid_2);
		Margot.LookAt(ChumleyDroid_2);
		Willa.LookAt(ChumleyDroid_3);
		yield return CreateTimeCondition(0.5f);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "DefaultWalk");
		yield return HAGIS.DialogShow(Ambient_WillaNo);
		HAGIS_A3S2 hAGIS_A3S2 = this;
		willa = Willa;
		t_WillaCellExhibLeave = T_WillaCellExhibLeave3;
		speed = Willa.charData.movementSpeedInCombat;
		hAGIS_A3S2.UnitMoveToTarget(willa, t_WillaCellExhibLeave, null, speed);
		Archi.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		Noot.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		Margot.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		Chris.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		Ambrosia.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		ChumleyDroid_1.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		ChumleyDroid_2.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		ChumleyDroid_3.unitModel.PlayAndReturnToIdle("TransDIdleToCIdle");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		ChumleyDroid_1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		ChumleyDroid_2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		ChumleyDroid_3.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		yield return HAGIS.DialogShow(Ambient_ArchiGo);
		Willa.LookInDirection(OctDir.Up);
		Willa.SetTeamType(UnitTeam.Type.NPC);
		HAGIS_A3S2 hAGIS_A3S3 = this;
		willa = Willa;
		t_WillaCellExhibLeave = T_WillaCellExhibLeave2;
		speed = Willa.charData.movementSpeedInCombat;
		yield return hAGIS_A3S3.UnitMoveToTarget(willa, t_WillaCellExhibLeave, null, speed);
		yield return UnitTeleportToMapViaEntranceTile(Willa, OmegaToWelcomeExhibit);
		Willa.gameObject.SetActive(value: false);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultSlowWalk, "DefaultSlowWalk");
		CutsceneEnd();
		yield return MapGoto(OmegaOffice);
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
		SKIP_POINT("Willa entered office");
		MusicPlay("event:/music/tracks/bespoke/jules first fight");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsCombatViolinIdle");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsCombatViolinWalk");
		Jules.UpdateIdleAnim();
		CutsceneBegin();
		Willa.HPRefill();
		OmegaToWelcomeExhibit.gameObject.SetActive(value: false);
		Willa.gameObject.SetActive(value: true);
		yield return CreateAndCondition(UnitMoveToTarget(Jules, T_JulesToLandingPad, null, 4f), UnitMoveToTarget(Willa, T_WillaTarget_Omega));
		yield return HAGIS.DialogShow(Dialog_WillaJuels);
		Jules.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_JulesShit);
		yield return UnitMoveToTarget(Jules, T_JulesToCover, null, 5f);
		Jules.LookAt(Willa);
		Willa.LookAt(Jules);
		yield return HAGIS.DialogShow(Dialog_DoesntFeelGreat);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_DoesntFeelGreatCont);
		Willa.SetTeamType(UnitTeam.Type.Player);
		GC.Inst.SetRPGLeader(Willa);
		UnitPlayAnimation(Jules, "CsTransViolinDIdleToCIdle");
		UnitPlayAnimation(Jules, "CombatIdle");
		yield return CreateTimeCondition(0.75f);
		yield return UnitPlayAnimation(Willa, "TransCIdleToCCrouch");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatCrouch");
		yield return UnitAttackUnit(Jules, Willa, Combat.HitType.Miss);
		yield return UnitPlayAnimation(Jules, "CsCombatViolinPickUp");
		Jules.UpdateIdleAnim();
		UnitPlayAnimation(Willa, "TransCCrouchToCIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
		yield return null;
		yield return UnitMoveToTarget(Jules, T_JulesToExit, null, 5f);
		Willa.LookInDirection(OctDir.UpLeft);
		yield return UnitTeleportToMapViaEntranceTile(Jules, LandingPadToOmega, T_JulesLandingPad);
		Jules.LookInDirection(OctDir.Down);
		UIObjectives.Inst.CompleteAndSetMainObjective(objKillJules);
		CutsceneEnd();
		SKIP_POINT("Deal with jules");
		MusicSetProgress(0.1f);
		Noot.gameObject.SetActive(value: false);
		Margot.gameObject.SetActive(value: false);
		Ambrosia.gameObject.SetActive(value: false);
		Chris.gameObject.SetActive(value: false);
		yield return UnitTeleportToMapViaEntranceTile(Noot, LandingPadToOmega);
		yield return UnitTeleportToMapViaEntranceTile(Margot, LandingPadToOmega);
		yield return UnitTeleportToMapViaEntranceTile(Ambrosia, LandingPadToOmega);
		yield return UnitTeleportToMapViaEntranceTile(Chris, LandingPadToOmega);
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		SKIP_POINT("Go after Jules ");
		yield return MapWaitUntilVisible(LandingPad.Map);
		SKIP_POINT("Cutscene Start");
		MusicStop();
		CutsceneBegin();
		yield return UnitMoveToTarget(Willa, T_WillaLandingPad);
		Willa.LookAt(Jules);
		yield return UnitPlayAnimation(Willa, "TransCIdleToAIdle");
		yield return UnitPlayAnimation(Willa, "CombatAimIdle");
		yield return HAGIS.DialogShow(Dialog_WillaDropIt);
		Jules.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_WillaCondem);
		yield return UnitPlayAnimation(Jules, "CsCombatViolinThrow");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CombatWalk");
		Jules.UpdateIdleAnim();
		HAGIS.DialogShow(Ambient_WillaNo);
		SFXPlay("event:/vo/A3S2_Ambient_WillaNo_L1");
		CutsceneEnd();
		yield return null;
		yield return CutscenePlay("A3S2_Cutscene_WillaVJules");
		yield return null;
		UIObjectives.Inst.CompleteAndSetMainObjective(objKillJules);
		yield return CombatBegin(UnitTeam.Type.Enemy);
		SKIP_POINT("Ending Cutscene");
		MusicPlay("event:/music/tracks/basic/new savannah ex light", 0f, 0.2f);
		Jules.Revive();
		UIObjectives.Inst.CompleteObjective(objKillJules);
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultInjuredIdle");
		Jules.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "CsDefaultInjuredWalk");
		yield return CreateTimeCondition(1f);
		yield return CutscenePlay("A3S2_Cutscene_WillaVJuelsAfter");
		yield return null;
		CutsceneBegin();
		yield return UnitPlayAnimation(Willa, "TransAIdleToCIdle");
		UnitPlayAnimation(Willa, "CombatIdle", loop: true);
		yield return HAGIS.DialogShow(Dialog_WillaForWhat);
		switch (endingType)
		{
		case WillaLeaving.Happy:
		case WillaLeaving.Redemption:
			yield return HAGIS.DialogShow(Dialog_WillaForWhatHappy);
			yield return UnitPlayAnimation(Willa, "TransCIdleToAIdle");
			UnitPlayAnimation(Willa, "CombatAimIdle", loop: true);
			break;
		case WillaLeaving.HappyThenTragic:
		case WillaLeaving.FullTragic:
			yield return HAGIS.DialogShow(Dialog_WillaForWhatTragic);
			yield return UnitPlayAnimation(Willa, "TransCIdleToAIdle");
			UnitPlayAnimation(Willa, "CombatAimIdle", loop: true);
			break;
		}
		SKIP_POINT("Jules got wrecked");
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_WillaProud);
		HAGIS.DialogShow(Ambient_ArchiWilla);
		Archi.LookAt(Willa);
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Margot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultWalk, "DefaultSlowWalk");
		Archi.UpdateIdleAnim();
		Margot.UpdateIdleAnim();
		Chris.UpdateIdleAnim();
		Noot.UpdateIdleAnim();
		Ambrosia.UpdateIdleAnim();
		yield return UnitTeleportToMapViaEntranceTile(Archi, LandingPadToOmega);
		Archi.LookAt(Willa);
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Dialog_ArchiTheDroids);
		SKIP_POINT("Willa tells Archi about her father");
		yield return UnitMoveToTarget(Archi, T_ArchiLandingPad, null, 2f);
		Archi.LookAt(Willa);
		yield return HAGIS.DialogShow(Dialog_ArchiComeOn);
		yield return UnitPlayAnimation(Willa, "TransAIdleToCIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Willa.LookAt(Archi);
		yield return HAGIS.DialogShow(Dialog_ArchiComeOn2);
		Willa.LookInDirection(OctDir.Left);
		yield return UnitPlayAnimation(Willa, "TransCIdleToAIdle");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatAimIdle");
		yield return HAGIS.DialogShow(Dialog_ArchiComeOn3);
		yield return HAGIS.DialogShow(Dialog_ArchiRightHere);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Dialog_ArchiRightHereCont);
		if (GC.Inst.InCutsceneMode())
		{
			CutsceneEnd();
		}
		yield return CreateTimeCondition(1f);
		yield return CutscenePlay("A3S2_Cutscene_WillaArchiHug");
		CutsceneBegin();
		SKIP_POINT("The gang arrives from OMEGA OFFICE");
		Archi.SetTeamType(UnitTeam.Type.Player);
		Margot.gameObject.SetActive(value: true);
		UnitMoveToTarget(Margot, T_Margot_SurroundsWilla, OctDir.Up, 2f);
		yield return CreateTimeCondition(1f);
		Chris.gameObject.SetActive(value: true);
		UnitMoveToTarget(Chris, T_Chris_SurroundsWilla, OctDir.UpLeft, 2f);
		yield return CreateTimeCondition(1f);
		Noot.gameObject.SetActive(value: true);
		UnitMoveToTarget(Noot, T_Noot_SurroundsWilla, OctDir.UpLeft, 2f);
		yield return CreateTimeCondition(1f);
		Ambrosia.gameObject.SetActive(value: true);
		UnitMoveToTarget(Ambrosia, T_Ambro_SurroundsWilla, OctDir.Left, 2f);
		if (!Dialog_ArchiRightHereCont.completed && UINarrativeDialog.Inst.CurrDialogData == Dialog_ArchiRightHereCont)
		{
			yield return CreateTriggerCondition(Dialog_ArchiRightHereCont.OnComplete);
		}
		yield return Wait.ForSeconds(5f);
		SKIP_POINT("End of Mission");
		CutsceneEnd();
		CutsceneBegin();
		yield return Singleton<MC>.Inst.TransitionToMap(null, null, null, 0f, missionStart: true, null, null, 7f, fadeOutUnits: false);
		MusicStop();
		FadeToBlack();
		UIAmbientSubtitles.Inst.textboxSubtitles.sortingOrder = 32767;
		UIAmbientSubtitles.Inst.textboxSubtitles.UpdateSortingOrder();
		yield return CreateTimeCondition(2f);
		SFXPlay("event:/sfx/script/act 3/a3s2/ae_script_door knock");
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(ambient_craven);
		UIAmbientSubtitles.Inst.textboxSubtitles.sortingOrder = origAmbientSubtitleSortOrder;
		UIAmbientSubtitles.Inst.textboxSubtitles.UpdateSortingOrder();
		yield return CreateTimeCondition(1f);
	}

	private void ToggleAscensionPlatformBorder(bool blocking)
	{
		for (int i = 0; i < ascensionPlatformBorder.Length; i++)
		{
			ascensionPlatformBorder[i].gameObject.SetActive(blocking);
		}
	}
}
public class HAGIS_A3S2_ChrisTowerExt : HAGIS
{
	private Unit Chris;

	private DialogData Ambient_ChrisWeTried;

	private TileActionInteraction I_ChrisBTExterior;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Chris = GC.Inst.GetUnitWithId("7EC_T3RelayTowerExterior_UnitSpawn");
		I_ChrisBTExterior = MR.Inst.GetTileActionInteraction("B67_T3RelayTowerExterior_TileActionInteraction");
		Ambient_ChrisWeTried = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ChrisWeTried");
		yield return null;
		yield return I_ChrisBTExterior.OnTriggered;
		yield return UnitPlayAnimation(Chris, "CsTransCCrouchToCIdleSlow");
		Chris.unitModel.Play("CombatIdle", looping: true);
		Chris.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Chris.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Ambient_ChrisWeTried);
	}
}
public class HAGIS_A3S2_DamagedTowerIntAnims : HAGIS
{
	private v2i[] explosionPoints = new v2i[4]
	{
		new v2i(6, 8),
		new v2i(11, 12),
		new v2i(11, 8),
		new v2i(17, 10)
	};

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot BroadcastTowerInterior = GetLogicUsingArtName("T3RelayTowerInterior");
		LogicRoot BroadcastTowerExterior = GetLogicUsingArtName("T3RelayTowerExterior");
		yield return null;
		yield return MapWaitUntilVisible(BroadcastTowerInterior.Map);
		while (Singleton<MC>.Inst.GetActiveMap() == BroadcastTowerInterior.Map)
		{
			PSC.Inst.Play(ParticleTypes.BulletImpact, BroadcastTowerInterior.Map, explosionPoints[UnityEngine.Random.Range(0, explosionPoints.Length)]);
			yield return Wait.ForSeconds(UnityEngine.Random.Range(0.75f, 3f));
		}
	}
}
public class HAGIS_A3S2_NootTowerExt : HAGIS
{
	private Unit Noot;

	private DialogData Ambient_NootStillIn;

	private TileActionInteraction I_NootBTExterior;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Noot = GC.Inst.GetUnitWithId("F04_T3RelayTowerExterior_UnitSpawn");
		I_NootBTExterior = MR.Inst.GetTileActionInteraction("E3E_T3RelayTowerExterior_TileActionInteraction");
		Ambient_NootStillIn = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_NootStillIn");
		yield return null;
		yield return I_NootBTExterior.OnTriggered;
		yield return UnitPlayAnimation(Noot, "CsTransCCrouchToCIdleSlow");
		Noot.unitModel.Play("CombatIdle", looping: true);
		Noot.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Noot.UpdateIdleAnim();
		yield return HAGIS.DialogShow(Ambient_NootStillIn);
	}
}
public class HAGIS_A3S2_TeammateRIPCheck : HAGIS
{
	private Unit Willa;

	private Unit Noot;

	private Unit Archi;

	private Unit Ambro;

	private Unit Margot;

	private Unit Chris;

	private Unit Theo;

	private DialogData Ambient_WillaAlone;

	private DialogData Ambient_WillaOver;

	private TileActionInteraction I_Console;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HAGIS_A3S2_WillaDamageCheck HagisA3S2_DamageCheck = MR.Inst.GetHagis<HAGIS_A3S2_WillaDamageCheck>();
		DialogData Dialog_WillaArchi = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaArchi");
		DialogData Dialog_NootBoom = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_NootBoom");
		DialogData Ambient_AmbrosiaEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_AmbrosiaEnters");
		DialogData Ambient_MargotEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_MargotEnters");
		DialogData Ambient_ChrisEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ChrisEnters");
		UnitTarget T_Noot = MR.Inst.GetUnitTarget("4A3_T2AscensionPlatform_UnitTarget");
		UnitTarget T_Archi = MR.Inst.GetUnitTarget("D85_T2AscensionPlatform_UnitTarget");
		Willa = GC.Inst.GetUnitWithId("563_T3CelestiaTownCentre_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("F04_T3RelayTowerExterior_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("9F2_T3RelayTowerInterior_UnitSpawn");
		Ambro = GC.Inst.GetUnitWithId("560_T3RelayTowerExterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("7EC_T3RelayTowerExterior_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("A6E_T3RelayTowerExterior_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("152_T2AscensionPlatform_UnitSpawn");
		yield return null;
		yield return HagisA3S2_DamageCheck.AlliesSpawned;
		HagletYieldTerm TheoDied3 = CreateTriggerCondition(Theo.OnDeathComplete);
		yield return CreateOrCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnMemberDied, TheoDied3);
		if (TheoDied3.met)
		{
			yield break;
		}
		CutsceneBegin();
		Ambro.SetActiveWithAnimation("TransCCrouchToCIdle", updateIdleOnComplete: true);
		HAGIS.DialogShow(Ambient_AmbrosiaEnters);
		Ambro.SetTeamType(UnitTeam.Type.Player);
		CutsceneEnd();
		MusicSetProgress(0.3f);
		TheoDied3 = CreateTriggerCondition(Theo.OnDeathComplete);
		yield return CreateOrCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnMemberDied, TheoDied3);
		if (!TheoDied3.met)
		{
			CutsceneBegin();
			Margot.SetActiveWithAnimation("TransCCrouchToCIdle", updateIdleOnComplete: true);
			HAGIS.DialogShow(Ambient_MargotEnters);
			Margot.SetTeamType(UnitTeam.Type.Player);
			CutsceneEnd();
			MusicSetProgress(0.4f);
			TheoDied3 = CreateTriggerCondition(Theo.OnDeathComplete);
			yield return CreateOrCondition(GC.Inst.GetTeamOfType(UnitTeam.Type.Player).OnMemberDied, TheoDied3);
			if (!TheoDied3.met)
			{
				CutsceneBegin();
				Chris.SetActiveWithAnimation("CsAbilityGroundPoundEnd", updateIdleOnComplete: true);
				HAGIS.DialogShow(Ambient_ChrisEnters);
				Chris.SetTeamType(UnitTeam.Type.Player);
				CutsceneEnd();
				MusicSetProgress(0.4f);
				yield return null;
				HagisLog("End of sub-HAGIS");
			}
		}
	}
}
public class HAGIS_A3S2_WillaDamageCheck : HAGIS
{
	private Unit Willa;

	private Unit Noot;

	private Unit Archi;

	private Unit Ambro;

	private Unit Margot;

	private Unit Chris;

	private Unit Theo;

	private UnitTarget T_Noot;

	private UnitTarget T_TheoAP;

	private DialogData Ambient_WillaAlone;

	private DialogData Ambient_WillaOver;

	private TileActionInteraction I_Console;

	public HagletTrigger AlliesSpawned = new HagletTrigger();

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		HAGIS_A3S2 HagisA3S2 = MR.Inst.GetHagis<HAGIS_A3S2>();
		Unit WellnessOfficer = GC.Inst.GetUnitWithId("71A_T2AscensionPlatform_UnitSpawn");
		DialogData Ambient_TheoFinally = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoFinally");
		DialogData Ambient_TheoDammit = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoDammit");
		DialogData Ambient_TheoBrave = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_TheoBrave");
		DialogData Dialog_WillaArchi = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_WillaArchi");
		DialogData Dialog_NootBoom = HAGIS.DialogLoad("Dialogs/A3S2/Dialog_NootBoom");
		DialogData Ambient_AmbrosiaEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_AmbrosiaEnters");
		DialogData Ambient_MargotEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_MargotEnters");
		DialogData Ambient_ChrisEnters = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_ChrisEnters");
		UnitTarget T_Noot = MR.Inst.GetUnitTarget("4A3_T2AscensionPlatform_UnitTarget");
		UnitTarget T_Archi = MR.Inst.GetUnitTarget("D85_T2AscensionPlatform_UnitTarget");
		T_TheoAP = MR.Inst.GetUnitTarget("5CC_T2AscensionPlatform_UnitTarget");
		T_Noot = MR.Inst.GetUnitTarget("4A3_T2AscensionPlatform_UnitTarget");
		UnitTarget NootDrop = MR.Inst.GetUnitTarget("4A3_T2AscensionPlatform_UnitTarget");
		Willa = GC.Inst.GetUnitWithId("563_T3CelestiaTownCentre_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("F04_T3RelayTowerExterior_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("9F2_T3RelayTowerInterior_UnitSpawn");
		Ambro = GC.Inst.GetUnitWithId("560_T3RelayTowerExterior_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("7EC_T3RelayTowerExterior_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("A6E_T3RelayTowerExterior_UnitSpawn");
		Theo = GC.Inst.GetUnitWithId("152_T2AscensionPlatform_UnitSpawn");
		Ambient_WillaAlone = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaAlone");
		Ambient_WillaOver = HAGIS.DialogLoad("Dialogs/A3S2/Ambient_WillaOver");
		I_Console = MR.Inst.GetTileActionInteraction("48F_T2AscensionPlatform_TileActionInteraction");
		UnitTarget T_Willa = MR.Inst.GetUnitTarget("B54_T2AscensionPlatform_UnitTarget");
		UnitTarget T_Theo = MR.Inst.GetUnitTarget("5CC_T2AscensionPlatform_UnitTarget");
		UnitTarget T_Theo2 = MR.Inst.GetUnitTarget("2BA_T2AscensionPlatform_UnitTarget");
		LogicRoot AscensionPlatform = GetLogicUsingArtName("T2AscensionPlatform");
		TileActionSwapMap AscensionPlatToAscensionExhibit = MR.Inst.GetTileActionSwapMap("2C1_T2AscensionPlatform_TileActionSwapMap");
		yield return null;
		yield return HagisA3S2.theoBossFight;
		bool willaWentUnder31 = false;
		bool willaWentUnder30 = false;
		bool theoWentUnder50 = false;
		bool ambroSpawned = false;
		bool margotSpawned = false;
		bool chrisSpawned = false;
		HagisLog("Waiting for Theo to RIP");
		Ability_DEBUG_CantDie willaCantDie = Willa.abilities.Add<Ability_DEBUG_CantDie>(null, isUpgraded: false);
		while (Theo.IsAlive() || !theoWentUnder50 || !willaWentUnder30)
		{
			if (!willaWentUnder30 && Willa.HP <= Mathf.CeilToInt((float)Willa.GetHPMax() * 0.3f))
			{
				willaWentUnder30 = true;
				willaWentUnder31 = true;
				HagisLog("Willa under 30% health");
				yield return Wait.While(GC.Inst.AnyUnitActing);
				CutsceneBegin();
				Willa.abilities.Remove(willaCantDie, isProxy: false);
				yield return CreateTimeCondition(2f);
				HAGIS.DialogShow(Ambient_WillaOver);
				yield return CreateTimeCondition(2f);
				Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
				Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "DefaultSlowWalk");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "DefaultIdle");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "DefaultWalk");
				HAGIS_A3S2_WillaDamageCheck hAGIS_A3S2_WillaDamageCheck = this;
				Unit willa = Willa;
				UnitTarget target = T_Willa;
				float? speed = Willa.charData.movementSpeedShortDist;
				yield return hAGIS_A3S2_WillaDamageCheck.UnitMoveToTarget(willa, target, null, speed);
				Willa.LookAt(Theo.gameObject.transform);
				HagisLog("Willa looking at Theo");
				HAGIS.DialogShow(Ambient_TheoBrave);
				HAGIS_A3S2_WillaDamageCheck hAGIS_A3S2_WillaDamageCheck2 = this;
				willa = Theo;
				target = T_Theo;
				speed = Theo.charData.movementSpeedShortDist;
				yield return hAGIS_A3S2_WillaDamageCheck2.UnitMoveToTarget(willa, target, null, speed);
				Theo.LookAt(Willa);
				HagisLog("Theo looking at Willa");
				yield return CreateTimeCondition(2f);
				HagisLog("Theo aims at willa");
				yield return UnitPlayAnimation(Theo, "TransCIdleToAIdle");
				UnitPlayAnimation(Theo, "CombatAimIdle", loop: true);
				yield return CreateTimeCondition(1f);
				PSC.Inst.Play(ParticleTypes.BulletImpact, AscensionPlatform.Map, Theo.coord);
				UnitPlayAnimation(Willa, "DefaultLookAround");
				yield return UnitPlayAnimation(Theo, "CombatHit");
				yield return Theo.unitModel.Play("TransCIdleToCCrouch");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatCrouch");
				yield return CreateTimeCondition(1f);
				MusicPlay("event:/music/tracks/basic/safety in numbers full");
				Archi.SetActiveWithAnimation("CsAbilityGroundPoundEnd");
				Archi.LookAt(Theo);
				Willa.LookAt(Archi);
				yield return HAGIS.DialogShow(Dialog_WillaArchi);
				yield return CreateTimeCondition(1f);
				Noot.SetActiveWithAnimation("AbilityGroundPoundEnd");
				Noot.LookAt(Theo);
				yield return CreateTimeCondition(0.5f);
				PSC.Inst.Play(ParticleTypes.Ground_Pound, AscensionPlatform.Map, Noot.coord);
				SFXPlayAtCoord("event:/sfx/ability/ground pound impact", NootDrop);
				Willa.LookAt(Noot);
				yield return HAGIS.DialogShow(Dialog_NootBoom);
				yield return Theo.unitModel.Play("TransCCrouchToCIdle");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdle");
				Archi.SetTeamType(UnitTeam.Type.Player);
				Noot.SetTeamType(UnitTeam.Type.Player);
				Willa.LookAt(Theo);
				GC.Inst.SetRPGLeader(Willa);
				AlliesSpawned.Trigger();
				Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
				Willa.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CombatWalk");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.CombatIdle, "CombatIdle");
				Theo.unitModel.SetAnimOverride(UnitModel.AnimID.CombatWalk, "CombatWalk");
				yield return UnitMoveToTarget(Theo, T_Theo2);
				CutsceneEnd();
				yield return null;
				MusicPlay("event:/music/tracks/combat/an augmented empire 2");
			}
			else if (!willaWentUnder31 && Willa.HP <= Mathf.CeilToInt((float)Willa.GetHPMax() * 0.7f))
			{
				willaWentUnder31 = true;
				HagisLog("Willa under 70% health");
				HAGIS.DialogShow(Ambient_WillaAlone);
			}
			if (!theoWentUnder50 && Theo.HP <= Mathf.CeilToInt((float)Theo.GetHPMax() * 0.5f))
			{
				HagisLog("Theo half health");
				theoWentUnder50 = true;
				yield return Wait.While(GC.Inst.AnyUnitActing);
				if (!GC.Inst.InCutsceneMode())
				{
					CutsceneBegin();
				}
				HAGIS.DialogShow(Ambient_TheoDammit);
				yield return CreateTimeCondition(1f);
				WellnessOfficer.gameObject.SetActive(value: true);
				yield return CreateTimeCondition(1f);
				MusicSetProgress(0.2f);
				CutsceneEnd();
			}
			yield return null;
		}
		HagisLog("End of sub-HAGIS");
	}
}
public class HAGIS_A3S3 : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Margot;

	private Unit Ashley;

	private Unit Thurgood;

	private UnitTarget T_Willa_OM;

	private UnitTarget T_Thurgood;

	private UnitTarget T_Willa_LP;

	private TileActionSwapMap CityCenterToOmegaOffice;

	private TileActionSwapMap OmegaOfficeToCityCenter;

	private TileActionSwapMap OmegaOfficeToLandingPad;

	private TileActionSwapMap OmegaOfficeToWelcome;

	private TileActionSwapMap WelcomeToOmegaOffice;

	private TileActionSwapMap LandingPadToOffice;

	private TileActionDialog D_BetaBlockTower;

	private TileActionDialog D_MargotPoster;

	private TileActionDialog D_Marybelle;

	private TileActionDialog D_NPC1;

	private TileActionDialog D_NPC3;

	private TileActionDialog D_Ambrosia;

	private TileActionDialog D_Archi;

	private TileActionDialog D_Gosz;

	private TileActionDialog D_Noot;

	private TileActionDialog D_Postcard;

	private TileActionDialog D_Chris;

	private TileActionDialog D_Droid;

	private TileActionDialog D_Margot;

	private TileActionDialog D_Memorial;

	private TileActionDialog D_Thurgood;

	private TileActionInteraction I_TheChopper;

	private DialogData Dialog_ANewAugment;

	private DialogData Dialog_AnythingWeFind;

	private DialogData Dialog_Deprogrammer;

	private DialogData Dialog_DitchedTheCast;

	private DialogData Dialog_FirstGoodNews;

	private DialogData Dialog_HowsLife;

	private DialogData Dialog_ICanHear;

	private DialogData Dialog_JoiningUs;

	private DialogData Dialog_Memorial;

	private DialogData Dialog_MilesInTank;

	private DialogData Dialog_MissThrone;

	private DialogData Dialog_MyCard;

	private DialogData Dialog_Name;

	private DialogData Dialog_NiceStoryAboutHousing;

	private DialogData Dialog_Postcard;

	private DialogData Dialog_Ready;

	private DialogData Dialog_StayAway;

	private DialogData Dialog_TheChopper;

	private DialogData Dialog_TheGuys;

	private DialogData Dialog_ThereWasAnother;

	private DialogData Dialog_TheWorld;

	private DialogData Dialog_TimeTo;

	private DialogData Dialog_Unanointed;

	private DialogData Dialog_WhereveYouBeen;

	private DialogData Dialog_YouGood;

	private DialogData Dialog_Maam;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentreNoSnow");
		LogicRoot CelestiaOmegaOffice = GetLogicUsingArtName("T3OmegaOffices");
		LogicRoot CelestiaWelcomeHome = GetLogicUsingArtName("T3WelcomeToYourNewWorldExhibit");
		LogicRoot CelestiaLandingPad = GetLogicUsingArtName("T3LandingPad");
		Willa = GC.Inst.GetUnitWithId("228_T3CelestiaTownCentre_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("2F2_T3OmegaOffices_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("209_T3WelcomeToYourNewWorldExhibit_UnitSpawn");
		Ashley = GC.Inst.GetUnitWithId("E9B_T3LandingPad_UnitSpawn");
		Thurgood = GC.Inst.GetUnitWithId("EBE_T3LandingPad_UnitSpawn");
		T_Willa_OM = MR.Inst.GetUnitTarget("6B8_T3OmegaOffices_UnitTarget");
		T_Willa_LP = MR.Inst.GetUnitTarget("F25_T3LandingPad_UnitTarget");
		T_Thurgood = MR.Inst.GetUnitTarget("FA1_T3LandingPad_UnitTarget");
		CityCenterToOmegaOffice = MR.Inst.GetTileActionSwapMap("BB5_T3CelestiaTownCentre_TileActionSwapMap");
		OmegaOfficeToCityCenter = MR.Inst.GetTileActionSwapMap("D07_T3OmegaOffices_TileActionSwapMap");
		OmegaOfficeToLandingPad = MR.Inst.GetTileActionSwapMap("31B_T3OmegaOffices_TileActionSwapMap");
		OmegaOfficeToWelcome = MR.Inst.GetTileActionSwapMap("0E9_T3OmegaOffices_TileActionSwapMap");
		WelcomeToOmegaOffice = MR.Inst.GetTileActionSwapMap("414_T3WelcomeToYourNewWorldExhibit_TileActionSwapMap");
		LandingPadToOffice = MR.Inst.GetTileActionSwapMap("CAF_T3LandingPad_TileActionSwapMap");
		I_TheChopper = MR.Inst.GetTileActionInteraction("DEF_T3OmegaOffices_TileActionInteraction");
		D_BetaBlockTower = MR.Inst.GetTileActionDialog("028_T3CelestiaTownCentre_TileActionDialog");
		D_MargotPoster = MR.Inst.GetTileActionDialog("374_T3CelestiaTownCentre_TileActionDialog");
		D_Marybelle = MR.Inst.GetTileActionDialog("D7B_T3CelestiaTownCentre_TileActionDialog");
		D_NPC1 = MR.Inst.GetTileActionDialog("439_T3CelestiaTownCentre_TileActionDialog");
		D_NPC3 = MR.Inst.GetTileActionDialog("23A_T3WelcomeToYourNewWorldExhibit_TileActionDialog");
		D_Ambrosia = MR.Inst.GetTileActionDialog("2E8_T3OmegaOffices_TileActionDialog");
		D_Archi = MR.Inst.GetTileActionDialog("794_T3OmegaOffices_TileActionDialog");
		D_Gosz = MR.Inst.GetTileActionDialog("D78_T3OmegaOffices_TileActionDialog");
		D_Noot = MR.Inst.GetTileActionDialog("34E_T3OmegaOffices_TileActionDialog");
		D_Postcard = MR.Inst.GetTileActionDialog("68E_T3OmegaOffices_TileActionDialog");
		D_Chris = MR.Inst.GetTileActionDialog("F45_T3WelcomeToYourNewWorldExhibit_TileActionDialog");
		D_Droid = MR.Inst.GetTileActionDialog("049_T3WelcomeToYourNewWorldExhibit_TileActionDialog");
		D_Margot = MR.Inst.GetTileActionDialog("73B_T3WelcomeToYourNewWorldExhibit_TileActionDialog");
		D_Memorial = MR.Inst.GetTileActionDialog("086_T3WelcomeToYourNewWorldExhibit_TileActionDialog");
		D_Thurgood = MR.Inst.GetTileActionDialog("7B4_T3LandingPad_TileActionDialog");
		Dialog_ANewAugment = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_ANewAugment");
		Dialog_AnythingWeFind = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_AnythingWeFind");
		Dialog_Deprogrammer = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Deprogrammer");
		Dialog_DitchedTheCast = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_DitchedTheCast");
		Dialog_FirstGoodNews = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_FirstGoodNews");
		Dialog_HowsLife = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_HowsLife");
		Dialog_ICanHear = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_ICanHear");
		Dialog_JoiningUs = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_JoiningUs");
		Dialog_Memorial = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Memorial");
		Dialog_MilesInTank = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_MilesInTank");
		Dialog_MissThrone = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_MissThrone");
		Dialog_MyCard = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_MyCard");
		Dialog_Name = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Name");
		Dialog_Postcard = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Postcard");
		Dialog_Ready = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Ready");
		Dialog_StayAway = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_StayAway");
		Dialog_TheChopper = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_TheChopper");
		Dialog_TheGuys = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_TheGuys");
		Dialog_ThereWasAnother = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_ThereWasAnother");
		Dialog_TheWorld = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_TheWorld");
		Dialog_TimeTo = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_TimeTo");
		Dialog_Unanointed = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Unanointed");
		Dialog_WhereveYouBeen = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_WhereveYouBeen");
		Dialog_YouGood = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_YouGood");
		Dialog_Maam = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_Maam");
		Dialog_NiceStoryAboutHousing = HAGIS.DialogLoad("Dialogs/A3S3/Dialog_NiceStoryAboutHousing");
		HAGIS_A3S3_SwitchDialog SwitchDialogHAGIS = CelestiaWelcomeHome.gameObject.GetComponent<HAGIS_A3S3_SwitchDialog>();
		string Aircraft = "MA_LandingPad_Aircraft";
		Thurgood.gameObject.SetActive(value: false);
		Ashley.gameObject.SetActive(value: false);
		OmegaOfficeToLandingPad.gameObject.SetActive(value: false);
		LandingPadToOffice.gameObject.SetActive(value: false);
		yield return null;
		MusicPlay("event:/music/tracks/basic/all is well");
		yield return MapWaitUntilVisible(CelestiaOmegaOffice.Map);
		SKIP_POINT("Celestia Office");
		MusicStop();
		yield return HAGIS.DialogShow(Dialog_FirstGoodNews);
		HagletYieldTerm visitedWelcomeHomeTerm = MapWaitUntilVisible(CelestiaWelcomeHome.Map);
		yield return CreateOrCondition(CreateTriggerCondition(I_TheChopper.OnTriggered), visitedWelcomeHomeTerm);
		bool visitedWelcomeHome = visitedWelcomeHomeTerm.met;
		if (visitedWelcomeHome)
		{
			yield return CreateTriggerCondition(I_TheChopper.OnTriggered);
		}
		if (visitedWelcomeHome)
		{
			yield return HAGIS.DialogShow(Dialog_ICanHear);
			uint currentResponseLine = Dialog_ICanHear.currentResponseLine;
			if (currentResponseLine != 1)
			{
				if (currentResponseLine == 2)
				{
					yield return UnitMoveToTarget(Willa, T_Willa_OM);
				}
				goto IL_098f;
			}
		}
		else
		{
			yield return HAGIS.DialogShow(Dialog_TheChopper);
			uint currentResponseLine2 = Dialog_TheChopper.currentResponseLine;
			if (currentResponseLine2 != 1)
			{
				if (currentResponseLine2 == 2)
				{
					yield return UnitMoveToTarget(Willa, T_Willa_OM);
				}
				goto IL_098f;
			}
		}
		goto IL_0a8f;
		IL_098f:
		while (true)
		{
			yield return CreateTriggerCondition(I_TheChopper.OnTriggered);
			yield return HAGIS.DialogShow(Dialog_TimeTo);
			switch (Dialog_TimeTo.currentResponseLine)
			{
			default:
				continue;
			case 2u:
				yield return UnitMoveToTarget(Willa, T_Willa_OM);
				continue;
			case 1u:
				break;
			}
			break;
		}
		goto IL_0a8f;
		IL_0a8f:
		yield return UnitMoveToMapViaExitTile(Willa, OmegaOfficeToLandingPad);
		MapGoto(CelestiaLandingPad);
		yield return MapWaitUntilMidTransition(CelestiaLandingPad);
		D_Thurgood.gameObject.SetActive(value: false);
		PlayMapAnimation(CelestiaLandingPad.Map, Aircraft, "Idle");
		CutsceneBegin();
		Thurgood.gameObject.SetActive(value: true);
		yield return UnitMoveToTarget(Thurgood, T_Thurgood, OctDir.Down);
		D_Thurgood.gameObject.SetActive(value: true);
		CutsceneEnd();
		SKIP_POINT("Thurgoods landed and walked out");
		yield return CreateTriggerCondition(D_Thurgood.OnDialogShow);
		MusicStop();
		MusicPlay("event:/music/tracks/basic/thurgood theme");
		yield return CreateTriggerCondition(Dialog_MissThrone.OnComplete);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Dialog_MyCard);
		yield return Willa.unitModel.Play("DefaultReceiveItem");
		yield return HAGIS.DialogShow(Dialog_AnythingWeFind);
		yield return Thurgood.unitModel.Play("CsDefaultDipsHat");
		MusicStop();
		yield return HAGIS.DialogShow(Dialog_Maam);
		SKIP_POINT("Thurgood has just left");
		yield return CreateTimeCondition(2f);
		CutsceneEnd();
		bool happyEnding = HAGIS_A3S2.GetEndingHappySad();
		yield return null;
		if (happyEnding)
		{
			MusicStop();
			PlayMapAnimation(CelestiaLandingPad.Map, Aircraft, "TakeOff");
			HagisLog("You got the Happy Ending");
			yield return CutscenePlay("A3S3_Cutscene1");
			MusicStop();
			HagisLog("Logic ends and so does the main game. we did it");
		}
		else
		{
			MusicStop();
			HagisLog("You got the Tragic Ending");
			PlayMapAnimation(CelestiaLandingPad.Map, Aircraft, "TakeOff");
			yield return CutscenePlay("A3S3_Cutscene2");
			MusicStop();
			HagisLog("Logic ends and so does the main game. we did it");
		}
	}
}
public class HAGIS_A3S3_SwitchDialog : HAGIS
{
	private Unit Willa;

	private Unit Archi;

	private Unit Margot;

	private Unit Thurgood;

	private TileActionSwapMap CityCenterToOmegaOffice;

	private TileActionSwapMap OmegaOfficeToCityCenter;

	private TileActionSwapMap OmegaOfficeToLandingPad;

	private TileActionSwapMap OmegaOfficeToWelcome;

	private TileActionSwapMap WelcomToOmegaOffice;

	private TileActionSwapMap LandingPadToOffice;

	private TileActionDialog D_BetaBlockTower;

	private TileActionDialog D_MargotPoster;

	private TileActionDialog D_Marybelle;

	private TileActionDialog D_NPC1;

	private TileActionDialog D_NPC2;

	private TileActionDialog D_NPC3;

	private TileActionDialog D_NPC4;

	private TileActionDialog D_Ambrosia;

	private TileActionDialog D_Archi;

	private TileActionDialog D_Gosz;

	private TileActionDialog D_Noot;

	private TileActionDialog D_Postcard;

	private TileActionDialog D_TheChopper;

	private TileActionDialog D_Chris;

	private TileActionDialog D_Droid;

	private TileActionDialog D_Margot;

	private TileActionDialog D_Memorial;

	private TileActionDialog D_Thurgood;

	private DialogData Dialog_ANewAugment;

	private DialogData Dialog_AnythingWeFind;

	private DialogData Dialog_Deprogrammer;

	private DialogData Dialog_DitchedTheCast;

	private DialogData Dialog_FirstGoodNews;

	private DialogData Dialog_HowsLife;

	private DialogData Dialog_ICanHear;

	private DialogData Dialog_JoiningUs;

	private DialogData Dialog_Memorial;

	private DialogData Dialog_MilesInTank;

	private DialogData Dialog_MissThrone;

	private DialogData Dialog_MyCard;

	private DialogData Dialog_Name;

	private DialogData Dialog_NiceStoryAboutHousing;

	private DialogData Dialog_NiceStoryAboutPeoplePitchingIn;

	private DialogData Dialog_Postcard;

	private DialogData Dialog_Ready;

	private DialogData Dialog_StayAway;

	private DialogData Dialog_TheChopper;

	private DialogData Dialog_TheGuys;

	private DialogData Dialog_ThereWasAnother;

	private DialogData Dialog_TheWorld;

	private DialogData Dialog_TimeTo;

	private DialogData Dialog_Unanointed;

	private DialogData Dialog_WhereveYouBeen;

	private DialogData Dialog_YouGood;

	private DialogData Dialog_Maam;

	private string objMeetVisitor = "Head to the landing pad to meet visitor";

	public bool VisitedWelcomeHome { get; private set; }

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot CelestiaWelcomeHome = GetLogicUsingArtName("T3WelcomeToYourNewWorldExhibit");
		yield return null;
		yield return MapWaitUntilVisible(CelestiaWelcomeHome.Map);
		HagisLog("Logic ends");
	}
}
public class HAGIS_A4S1 : HAGIS
{
	private Unit Ashley;

	private Unit Archi;

	private Unit Ambrosia;

	private Unit Holden;

	private Unit Underclock_U1;

	private Unit Underclock_U2;

	private Unit Goon_G1;

	private Unit Goon_G2;

	private Unit CivsMale;

	private Unit CivsFemale;

	private Unit CivsChild;

	private Unit ParkCrow;

	private Unit ParkCrow1;

	private Unit ParkCrow2;

	private UnitTarget T_UC1MoveToCover;

	private UnitTarget T_UC2MoveToFlank;

	private UnitTarget T_UC2MoveToOpenPos;

	private UnitTarget T_UC1MoveToAttack;

	private UnitTarget T_UC2MoveUp;

	private UnitTarget T_UC2GrenadeTarget;

	private UnitTarget T_Ashley;

	private UnitTarget T_AshleyStart;

	private UnitTarget T_BackWall;

	private UnitTarget T_Compiler0;

	private UnitTarget T_Compiler1;

	private UnitTarget T_Compiler2;

	private UnitTarget T_Exit;

	private UnitTarget T_UC1Start;

	private UnitTarget T_UC2Start;

	private UnitTarget T_HoldenIntroductionSpot;

	private TileActionSwapMap M_FilesToPark;

	private TileActionSwapMap M_ParkToFiles;

	private TileActionSwapMap M_ParkToGraveyard;

	private TileActionSwapMap M_GraveyardToPark;

	private TileActionDialog D_Ambrosia;

	private TileActionDialog D_PoorNPC;

	private TileActionDialog D_Exit;

	private TileActionInteraction I_TalkToArchi;

	private TileTrigger TT_AshFindSomeCover;

	private TileTrigger TT_AshRunFromGrenade;

	private TileTrigger TT_ThisWay;

	private TileTrigger TT_ACTIVITEBIRDS;

	private DialogData Ambient_ArchiYouGo;

	private DialogData Ambient_AshThisWay;

	private DialogData Ambient_HartmanPreMapLoad2;

	private DialogData Ambient_HartmanPreMapLoad3;

	private DialogData Ambient_HartmanTutorial1;

	private DialogData Ambient_HartmanTutorial3;

	private DialogData Ambient_HartmanTutorial3Dawdle;

	private DialogData Ambient_HartmanTutorial4;

	private DialogData Ambient_HartmanTutorial4Dawdle;

	private DialogData Ambient_HartmanTutorial4WhamBarAppears;

	private DialogData Ambient_HartmanTutorial5;

	private DialogData Ambient_HartmanTutorial5Critical;

	private DialogData Ambient_HartmanTutorial5Miss;

	private DialogData Ambient_HartmanTutorial5MissAgain;

	private DialogData Ambient_HartmanTutorial5MissAgain2;

	private DialogData Ambient_HartmanTutorial6;

	private DialogData Ambient_HartmanTutorial6a;

	private DialogData Ambient_HartmanTutorial6b;

	private DialogData Ambient_HartmanTutorial7;

	private DialogData Ambient_HartmanTutorial7DodgeWhamBarAppears;

	private DialogData Ambient_HartmanTutorial7FailureDodge;

	private DialogData Ambient_HartmanTutorial7SuccesfulDodge;

	private DialogData Ambient_HartmanTutorial8;

	private DialogData Ambient_HartmanTutorial9;

	private DialogData Ambient_HartmanTutorial11;

	private DialogData Ambient_HartmanTutorial13;

	private DialogData Ambient_HartmanTutorial13OverwatchWhamBarSucess;

	private DialogData Ambient_HartmanTutorial15;

	private DialogData Ambient_HartmanTutorialOutsideCombat;

	private DialogData Ambient_HartmanTutorialOutsideCombatSkip;

	private DialogData Dialog_HartTutorialOutsideCombat;

	private DialogData Ambient_Sigh;

	private DialogData Ambient_ToMany;

	private DialogData Dialog_AshHalfNow;

	private DialogData Dialog_AshleyItsOver;

	private DialogData Dialog_AshStayOff;

	private DialogData Dialog_CityMap;

	private DialogData Dialog_HartmanClimb;

	private DialogData Dialog_HartmanCompil;

	private DialogData Dialog_HartmanDammit;

	private DialogData Dialog_HartmanGraveyard;

	private DialogData Dialog_HartmanRestUp;

	private DialogData Dialog_HoldenParkToll;

	private DialogData Dialog_PoorNPC;

	private DialogData Dialog_TalkToAmbro;

	private DialogData Dialog_TalkToArchi;

	private DialogData Dialog_HartmanMuscleWarn;

	private string objSurviveAmbush = "SURVIVE THE UNDERCLOCK AMBUSH";

	private string subObjGetToCover = "TAP/HOLD ON THE TILE TO MOVE TO COVER";

	private string subObjAttackSoldier = "TAP/HOLD ON ENEMY TO ATTACK";

	private string subObjGrenade = "ESCAPE THE GRENADE";

	private string subObjAbility = "TAP/HOLD ON ASHLEY TO SELECT AN ABILITY";

	private string objPark = "HEAD NORTHWEST TO THE PARK";

	private string subObjExplore = "OPTIONAL: EXPLORE THE AREA FOR ANYTHING USEFUL";

	private string subObjTapToMove = "TAP/HOLD ON THE MAP TO MOVE OR INVESTIGATE";

	private string objSpeakToArchi = "HIRE SOME ASSISTANCE";

	private string subObjNPCs = "INTERACT WITH CIVILIANS TO TALK TO THEM";

	private string objHeadToGraves = "HEAD NORTH TO THE CEMETERY";

	private string objDefeat = "DEAL WITH HOLDEN";

	private Func<bool> exitedTutorialMode = () => !LR.HACK_tutorialMode;

	private ConstArray<v2i> grenadeSelection = new ConstArray<v2i>(1u);

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		ConstArray<ParticlePrefab> allTutorialParticles = new ConstArray<ParticlePrefab>(4u);
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot Park = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot Graveyard = GetLogicUsingArtName("T1DetritumGraveyard");
		HagletTrigger Underclock_AI = new HagletTrigger();
		Ashley = GC.Inst.GetUnitWithId("E9B_T3LandingPad_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("4F4_T1DetritumPark_UnitSpawn");
		Ambrosia = GC.Inst.GetUnitWithId("5F6_T1DetritumPark_UnitSpawn");
		Holden = GC.Inst.GetUnitWithId("413_T1DetritumGraveyard_UnitSpawn");
		Underclock_U1 = GC.Inst.GetUnitWithId("FEF_T1TheFiles_UnitSpawn");
		Underclock_U2 = GC.Inst.GetUnitWithId("414_T1TheFiles_UnitSpawn");
		Goon_G1 = GC.Inst.GetUnitWithId("250_T1DetritumGraveyard_UnitSpawn");
		Goon_G2 = GC.Inst.GetUnitWithId("26C_T1DetritumGraveyard_UnitSpawn");
		CivsMale = GC.Inst.GetUnitWithId("1FA_T1DetritumPark_UnitSpawn");
		CivsFemale = GC.Inst.GetUnitWithId("014_T1DetritumPark_UnitSpawn");
		CivsChild = GC.Inst.GetUnitWithId("739_T1DetritumPark_UnitSpawn");
		ParkCrow = GC.Inst.GetUnitWithId("BAF_T1DetritumPark_UnitSpawn");
		ParkCrow1 = GC.Inst.GetUnitWithId("4E1_T1DetritumPark_UnitSpawn");
		ParkCrow2 = GC.Inst.GetUnitWithId("069_T1DetritumPark_UnitSpawn");
		T_UC1MoveToCover = MR.Inst.GetUnitTarget("F97_T1TheFiles_UnitTarget");
		T_UC2MoveToFlank = MR.Inst.GetUnitTarget("83E_T1TheFiles_UnitTarget");
		T_UC2MoveToOpenPos = MR.Inst.GetUnitTarget("831_T1TheFiles_UnitTarget");
		T_UC1MoveToAttack = MR.Inst.GetUnitTarget("F86_T1TheFiles_UnitTarget");
		T_UC2GrenadeTarget = MR.Inst.GetUnitTarget("121_T1TheFiles_UnitTarget");
		T_UC2MoveUp = MR.Inst.GetUnitTarget("F04_T1TheFiles_UnitTarget");
		T_Ashley = MR.Inst.GetUnitTarget("6A1_T1DetritumGraveyard_UnitTarget");
		T_AshleyStart = MR.Inst.GetUnitTarget("337_T1TheFiles_UnitTarget");
		T_BackWall = MR.Inst.GetUnitTarget("9D7_T1DetritumGraveyard_UnitTarget");
		T_Compiler0 = MR.Inst.GetUnitTarget("961_T1DetritumGraveyard_UnitTarget");
		T_Compiler1 = MR.Inst.GetUnitTarget("0AB_T1DetritumGraveyard_UnitTarget");
		T_Compiler2 = MR.Inst.GetUnitTarget("5EB_T1DetritumGraveyard_UnitTarget");
		T_Exit = MR.Inst.GetUnitTarget("A3D_T1DetritumGraveyard_UnitTarget");
		T_UC1Start = MR.Inst.GetUnitTarget("71C_T1TheFiles_UnitTarget");
		T_UC2Start = MR.Inst.GetUnitTarget("33C_T1TheFiles_UnitTarget");
		T_HoldenIntroductionSpot = MR.Inst.GetUnitTarget("1D5_T1DetritumGraveyard_UnitTarget");
		TT_AshFindSomeCover = MR.Inst.GetTileTrigger("7E2_T1TheFiles_TileTrigger");
		TT_AshRunFromGrenade = MR.Inst.GetTileTrigger("245_T1TheFiles_TileTrigger");
		TT_ThisWay = MR.Inst.GetTileTrigger("83C_T1DetritumPark_TileTrigger");
		M_FilesToPark = MR.Inst.GetTileActionSwapMap("80C_T1TheFiles_TileActionSwapMap");
		M_ParkToFiles = MR.Inst.GetTileActionSwapMap("031_T1DetritumPark_TileActionSwapMap");
		M_ParkToGraveyard = MR.Inst.GetTileActionSwapMap("494_T1DetritumPark_TileActionSwapMap");
		M_GraveyardToPark = MR.Inst.GetTileActionSwapMap("F4A_T1DetritumGraveyard_TileActionSwapMap");
		I_TalkToArchi = MR.Inst.GetTileActionInteraction("BC4_T1DetritumPark_TileActionInteraction");
		D_Ambrosia = MR.Inst.GetTileActionDialog("53D_T1DetritumPark_TileActionDialog");
		D_PoorNPC = MR.Inst.GetTileActionDialog("69B_T1DetritumPark_TileActionDialog");
		D_Exit = MR.Inst.GetTileActionDialog("7E4_T1DetritumPark_TileActionDialog");
		Ambient_ArchiYouGo = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_ArchiYouGo");
		Ambient_AshThisWay = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_AshThisWay");
		Ambient_HartmanPreMapLoad2 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanPreMapLoad2");
		Ambient_HartmanPreMapLoad3 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanPreMapLoad3");
		Ambient_HartmanTutorial1 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial1");
		Ambient_HartmanTutorial3 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial3");
		Ambient_HartmanTutorial3Dawdle = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial3Dawdle");
		Ambient_HartmanTutorial4 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial4");
		Ambient_HartmanTutorial4Dawdle = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial4Dawdle");
		Ambient_HartmanTutorial4WhamBarAppears = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial4WhamBarAppears");
		Ambient_HartmanTutorial5 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial5");
		Ambient_HartmanTutorial5Critical = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial5Critical");
		Ambient_HartmanTutorial5Miss = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial5Miss");
		Ambient_HartmanTutorial5MissAgain = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial5MissAgain");
		Ambient_HartmanTutorial5MissAgain2 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial5MissAgain2");
		Ambient_HartmanTutorial6 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial6");
		Ambient_HartmanTutorial6a = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial6a");
		Ambient_HartmanTutorial6b = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial6b");
		Ambient_HartmanTutorial7 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial7");
		Ambient_HartmanTutorial7DodgeWhamBarAppears = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial7DodgeWhamBarAppears");
		Ambient_HartmanTutorial7FailureDodge = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial7FailureDodge");
		Ambient_HartmanTutorial7SuccesfulDodge = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial7SuccesfulDodge");
		Ambient_HartmanTutorial8 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial8");
		Ambient_HartmanTutorial9 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial9");
		Ambient_HartmanTutorial11 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial11");
		Ambient_HartmanTutorial13 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial13");
		Ambient_HartmanTutorial13OverwatchWhamBarSucess = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial13OverwatchWhamBarSucess");
		Ambient_HartmanTutorial15 = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorial15");
		Ambient_HartmanTutorialOutsideCombat = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorialOutsideCombat");
		Ambient_HartmanTutorialOutsideCombatSkip = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorialOutsideCombatSkip");
		Ambient_Sigh = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_Sigh");
		Ambient_ToMany = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_ToMany");
		Dialog_AshHalfNow = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_AshHalfNow");
		Dialog_AshleyItsOver = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_AshleyItsOver");
		Dialog_AshStayOff = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_AshStayOff");
		Dialog_CityMap = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_CityMap");
		Dialog_HartmanClimb = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanClimb");
		Dialog_HartmanCompil = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanCompil");
		Dialog_HartmanDammit = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanDammit");
		Dialog_HartmanGraveyard = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanGraveyard");
		Dialog_HartmanRestUp = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanRestUp");
		Dialog_HoldenParkToll = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HoldenParkToll");
		Dialog_PoorNPC = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_PoorNPC");
		Dialog_TalkToAmbro = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_TalkToAmbro");
		Dialog_TalkToArchi = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_TalkToArchi");
		Dialog_HartmanMuscleWarn = HAGIS.DialogLoad("Dialogs/A4S1/Dialog_HartmanMuscleWarn");
		Dialog_HartTutorialOutsideCombat = HAGIS.DialogLoad("Dialogs/A4S1/Ambient_HartmanTutorialOutsideCombat");
		TT_ThisWay.gameObject.SetActive(value: false);
		M_ParkToGraveyard.gameObject.SetActive(value: false);
		M_FilesToPark.gameObject.SetActive(value: false);
		Party.Inst.RemoveAllOfItem(Item.Medpack.ToMeta());
		Party.Inst.RemoveAllOfItem(Item.Grenade_Frag.ToMeta());
		HAGIS.DialogShow(Ambient_HartmanPreMapLoad2);
		yield return null;
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultUnconscious");
		Ambrosia.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CsDefaultSit");
		ParkCrow.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultIdleWall");
		CutsceneBegin();
		HAGIS.DialogShow(Ambient_HartmanPreMapLoad3);
		yield return UnitMoveToTarget(Ashley, T_AshleyStart);
		UnitMoveToTarget(Underclock_U1, T_UC1Start);
		yield return UnitMoveToTarget(Underclock_U2, T_UC2Start);
		yield return HAGIS.DialogShow(Dialog_AshleyItsOver);
		UIObjectives.Inst.AddObjective(objSurviveAmbush);
		SKIP_POINT("Tutorial");
		MusicPlay("event:/music/a4s1/combat");
		LR.HACK_tutorialMode = true;
		UIWhamBar.Inst.tutorialCannotLose = true;
		UIWhamBar.Inst.tutorialTapText = true;
		SC.Inst.HACK_tutorialMode = true;
		UIStatusBar.Inst.HACK_showEndTurnButton = false;
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = true;
		Singleton<AIC>.Inst.OnExternalAIBegan = Underclock_AI;
		bool hitEndOfTutorial = false;
		CombatBegin(UnitTeam.Type.Player);
		CutsceneBegin();
		yield return HAGIS.DialogShow(Ambient_HartmanTutorial1);
		SetExplicitTileMovement(TT_AshFindSomeCover.GetCoord());
		Ashley.IsAttackingDisabled = true;
		yield return HAGIS.DialogShow(Ambient_HartmanTutorial3) | Wait.Until(exitedTutorialMode);
		if (LR.HACK_tutorialMode)
		{
			CutsceneEnd();
			UIObjectives.Inst.AddObjective(subObjGetToCover, pulse: true);
			ParticlePrefab findSomeCoverParticle = ShowCoordSelect(TT_AshFindSomeCover.GetCoord());
			allTutorialParticles.Add(findSomeCoverParticle);
			float findSomeCoverStartTime = Time.timeSinceLevelLoad;
			while (true)
			{
				HagletYieldTerm fscTrigger = CreateTriggerCondition(TT_AshFindSomeCover._OnTriggered);
				yield return CreateOrCondition(fscTrigger, Wait.ForSeconds(1f)) | Wait.Until(exitedTutorialMode);
				if (!LR.HACK_tutorialMode)
				{
					break;
				}
				if (!fscTrigger.met && !MR.Inst.IsSkipping())
				{
					float timeSinceLevelLoad = Time.timeSinceLevelLoad;
					if (timeSinceLevelLoad - findSomeCoverStartTime > 10f)
					{
						findSomeCoverStartTime = timeSinceLevelLoad;
						HAGIS.DialogShow(Ambient_HartmanTutorial3Dawdle);
					}
					continue;
				}
				findSomeCoverParticle.StopParticles();
				allTutorialParticles.Remove(findSomeCoverParticle);
				UIObjectives.Inst.CompleteObjective(subObjGetToCover);
				Ashley.IsAttackingDisabled = false;
				CutsceneBegin();
				yield return HAGIS.DialogShow(Ambient_HartmanTutorial4) | Wait.Until(exitedTutorialMode);
				if (!LR.HACK_tutorialMode)
				{
					break;
				}
				SetExplicitTileMovement(Underclock_U1.coord);
				SetExplicitUnitToAttack(Underclock_U1);
				CutsceneEnd();
				UIObjectives.Inst.AddObjective(subObjAttackSoldier, pulse: true);
				Underclock_U1.HideStatusBar();
				ParticlePrefab attackUnderclock1Particle = ShowCoordSelect(Underclock_U1.coord);
				allTutorialParticles.Add(attackUnderclock1Particle);
				while (true)
				{
					HagletYieldTerm auc1Trigger = CreateTriggerCondition(Underclock_U1.OnUnitSustainedDamage);
					HagletYieldTerm auc1CritTrigger = CreateTriggerCondition(Underclock_U1.OnUnitSustainedCriticalDamage);
					yield return CreateOrCondition(CreateOrCondition(auc1Trigger, auc1CritTrigger), Wait.ForSeconds(1f)) | Wait.Until(exitedTutorialMode);
					if (!LR.HACK_tutorialMode)
					{
						break;
					}
					if (!auc1Trigger.met && !auc1CritTrigger.met && !MR.Inst.IsSkipping())
					{
						continue;
					}
					Underclock_U1.ShowStatusBar();
					attackUnderclock1Particle.StopParticles();
					allTutorialParticles.Remove(attackUnderclock1Particle);
					if (auc1CritTrigger.met)
					{
						yield return HAGIS.DialogShow(Ambient_HartmanTutorial5Critical) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
					}
					else if (auc1Trigger.met)
					{
						yield return HAGIS.DialogShow(Ambient_HartmanTutorial5) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
					}
					UIObjectives.Inst.CompleteObjective(subObjAttackSoldier);
					int misscount = UIWhamBar.Inst.FailedAttempts;
					yield return HAGIS.DialogShow((misscount <= 0) ? Ambient_HartmanTutorial6b : Ambient_HartmanTutorial6a) | Wait.Until(exitedTutorialMode);
					if (!LR.HACK_tutorialMode)
					{
						break;
					}
					yield return HAGIS.DialogShow(Ambient_HartmanTutorial6) | Wait.Until(exitedTutorialMode);
					if (!LR.HACK_tutorialMode)
					{
						break;
					}
					UIWhamBar.Inst.tutorialCannotLose = false;
					RemoveExplicitTileMovement();
					RemoveExplicitUnitToAttack();
					Ashley.IsAttackingDisabled = true;
					while (Underclock_U1.IsDying && !MR.Inst.IsSkipping())
					{
						yield return Wait.ForSteps(1uL);
					}
					if (!Underclock_U1.IsAlive())
					{
						Underclock_U1.Revive();
					}
					if (Underclock_U1.IsAlive())
					{
						if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
						{
							yield return Singleton<AIC>.Inst.OnExternalAIBegan | Wait.Until(exitedTutorialMode);
							if (!LR.HACK_tutorialMode)
							{
								break;
							}
						}
						Underclock_U1.APDecrement(1);
						yield return UnitMoveToTarget(Underclock_U1, T_UC1MoveToCover);
						yield return HAGIS.DialogShow(Ambient_HartmanTutorial7) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
						if (!Routine.IsSkipping())
						{
							Underclock_U1.StartAttack(Ashley, Underclock_U1.mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.DodgeWhamBar);
							yield return Wait.While(Underclock_U1.attacking);
						}
						int dodgeFailCount = UIWhamBar.Inst.FailedAttempts;
						yield return HAGIS.DialogShow((dodgeFailCount <= 0) ? Ambient_HartmanTutorial7SuccesfulDodge : Ambient_HartmanTutorial7FailureDodge) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
						yield return HAGIS.DialogShow(Ambient_HartmanTutorial8) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
						Underclock_U1.APDecrement(Underclock_U1.AP);
						Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
					}
					if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
					{
						yield return Singleton<AIC>.Inst.OnExternalAIBegan | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
					}
					Underclock_U2.APDecrement(1);
					yield return UnitMoveToTarget(Underclock_U2, T_UC2MoveToFlank);
					Ability_Grenade grenade = Underclock_U2.abilities.Add<Ability_Grenade>(null, isUpgraded: false);
					UIAbilityWheelChoice choice = new UIAbilityWheelChoice
					{
						ability = grenade,
						subAbilityIdx = 0
					};
					grenade.OnUnitSpawn(Underclock_U2);
					grenadeSelection.Add(Ashley.coord);
					grenade.OnActivateWithTilesSelectedBase(Underclock_U2, grenadeSelection, choice);
					yield return CreateTriggerCondition(grenade.OnGrenadeThrown);
					grenadeSelection.Clear();
					Underclock_U2.APDecrement(Underclock_U2.AP);
					Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
					if (!MR.Inst.IsSkipping() && GC.Inst.GetActiveTeamType() == UnitTeam.Type.Enemy)
					{
						GC.Inst.ForceSubmitTurn();
					}
					yield return CreateTriggerCondition(Ashley.GetTeam().OnTurnStarted);
					CutsceneBegin();
					yield return HAGIS.DialogShow(Ambient_HartmanTutorial9) | Wait.Until(exitedTutorialMode);
					if (!LR.HACK_tutorialMode)
					{
						break;
					}
					SetExplicitTileMovement(TT_AshRunFromGrenade.GetCoord());
					CutsceneEnd();
					UIObjectives.Inst.AddObjective(subObjGrenade, pulse: true);
					ParticlePrefab runFromGrenadeParticle = ShowCoordSelect(TT_AshRunFromGrenade.GetCoord());
					allTutorialParticles.Add(runFromGrenadeParticle);
					while (true)
					{
						HagletYieldTerm fcmTrigger = CreateTriggerCondition(TT_AshRunFromGrenade._OnTriggered);
						yield return CreateOrCondition(fcmTrigger, Wait.ForSeconds(1f)) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
						if (!fcmTrigger.met && !MR.Inst.IsSkipping())
						{
							continue;
						}
						runFromGrenadeParticle.StopParticles();
						allTutorialParticles.Remove(runFromGrenadeParticle);
						SetExplicitTileMovement(v2i.zero);
						CutsceneBegin();
						UIObjectives.Inst.CompleteObjective(subObjGrenade);
						UIAbilityWheel.Inst.HACK_tutorialMode = true;
						yield return HAGIS.DialogShow(Ambient_HartmanTutorial11) | Wait.Until(exitedTutorialMode);
						if (!LR.HACK_tutorialMode)
						{
							break;
						}
						UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
						CutsceneEnd();
						UIObjectives.Inst.AddObjective(subObjAbility, pulse: true);
						Ashley.HideStatusBar();
						UnitTeam enemyTeam = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy);
						ParticlePrefab useOverwatchParticle = ShowCoordSelect(TT_AshRunFromGrenade.GetCoord());
						allTutorialParticles.Add(useOverwatchParticle);
						while (true)
						{
							HagletYieldTerm uoTrigger = CreateTriggerCondition(enemyTeam.OnTurnStarted);
							yield return CreateOrCondition(uoTrigger, Wait.ForSeconds(1f)) | Wait.Until(exitedTutorialMode);
							if (!LR.HACK_tutorialMode)
							{
								break;
							}
							if (!uoTrigger.met && !MR.Inst.IsSkipping())
							{
								continue;
							}
							Ashley.ShowStatusBar();
							useOverwatchParticle.StopParticles();
							allTutorialParticles.Remove(useOverwatchParticle);
							Ashley.IsAttackingDisabled = false;
							UIObjectives.Inst.CompleteObjective(subObjAbility);
							if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
							{
								yield return Singleton<AIC>.Inst.OnExternalAIBegan | Wait.Until(exitedTutorialMode);
								if (!LR.HACK_tutorialMode)
								{
									break;
								}
							}
							Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
							if (!Singleton<AIC>.Inst.AwaitingExternalInstructions)
							{
								yield return Singleton<AIC>.Inst.OnExternalAIBegan | Wait.Until(exitedTutorialMode);
								if (!LR.HACK_tutorialMode)
								{
									break;
								}
							}
							Underclock_U2.APDecrement(1);
							yield return UnitMoveToTarget(Underclock_U2, T_UC2MoveUp, OctDir.Left);
							Underclock_U2.APDecrement(1);
							yield return UnitMoveToTarget(Underclock_U2, T_UC2MoveToOpenPos, OctDir.UpLeft);
							if (Underclock_U2.IsAlive())
							{
								if (UIWhamBar.Inst.FailedAttempts > 0)
								{
									if (!Routine.IsSkipping())
									{
										Underclock_U2.StartAttack(Ashley, Underclock_U2.mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.DodgeWhamBar);
										yield return Wait.While(Underclock_U2.attacking);
									}
								}
								else
								{
									yield return HAGIS.DialogShow(Ambient_HartmanTutorial13) | Wait.Until(exitedTutorialMode);
								}
							}
							else
							{
								yield return HAGIS.DialogShow(Ambient_HartmanTutorial13OverwatchWhamBarSucess) | Wait.Until(exitedTutorialMode);
							}
							if (LR.HACK_tutorialMode)
							{
								Underclock_U2.APDecrement(Underclock_U2.AP);
								Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
								Underclock_U1.APDecrement(1);
								yield return UnitMoveToTarget(Underclock_U1, T_UC1MoveToAttack, OctDir.Down);
								if (!Routine.IsSkipping())
								{
									Underclock_U1.StartAttack(Ashley, Underclock_U1.mainWeapon, costsAP: true, Unit.IfTooFar.IgnoreLimits, null, isReactionAttack: false, isAbilityAttack: false, null, 1, Combat.CombatMinigame.DodgeWhamBar);
									yield return Wait.While(Underclock_U1.attacking);
								}
								Underclock_U1.APDecrement(Underclock_U1.AP);
								Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
								hitEndOfTutorial = true;
							}
							break;
						}
						break;
					}
					break;
				}
				break;
			}
		}
		HAGIS.DialogShow(Ambient_HartmanTutorial15);
		UIObjectives.Inst.ClearSubObjectives();
		Unit ashley = Ashley;
		bool flag = false;
		Ashley.IsAttackingDisabled = flag;
		ashley.IsMovementDisabled = flag;
		Unit underclock_U = Underclock_U1;
		flag = false;
		Underclock_U1.IsAttackingDisabled = flag;
		underclock_U.IsMovementDisabled = flag;
		Unit underclock_U2 = Underclock_U1;
		flag = false;
		Underclock_U1.IsAttackingDisabled = flag;
		underclock_U2.IsMovementDisabled = flag;
		RemoveExplicitTileMovement();
		RemoveExplicitUnitToAttack();
		if (GC.Inst.IsInCutsceneMode())
		{
			CutsceneEnd();
		}
		Singleton<AIC>.Inst.OnExternalAIBegan = null;
		UIAbilityWheel.Inst.HACK_disableDuringTutorial = false;
		SC.Inst.HACK_tutorialMode = false;
		UIStatusBar.Inst.HACK_showEndTurnButton = true;
		UIAbilityWheel.Inst.HACK_tutorialMode = false;
		UIWhamBar.Inst.tutorialCannotLose = false;
		UIWhamBar.Inst.tutorialTapText = false;
		for (int i = 0; i < allTutorialParticles.Length; i++)
		{
			allTutorialParticles[i].StopParticles();
		}
		allTutorialParticles.Clear();
		if (!MR.Inst.IsSkipping() && GC.Inst.GetActiveTeamType() == UnitTeam.Type.Enemy)
		{
			Singleton<AIC>.Inst.OnExternalAIComplete.Trigger();
			GC.Inst.ForceSubmitTurn();
		}
		if (!hitEndOfTutorial)
		{
			CutsceneBegin();
			HagletYieldTerm waitForMove1 = Wait.None;
			HagletYieldTerm waitForMove2 = Wait.None;
			if (Underclock_U1.IsAlive())
			{
				waitForMove1 = UnitMoveToTarget(Underclock_U1, T_UC1MoveToAttack);
			}
			if (Underclock_U2.IsAlive())
			{
				waitForMove2 = UnitMoveToTarget(Underclock_U2, T_UC2MoveToOpenPos);
			}
			yield return waitForMove1 & waitForMove2;
			CutsceneEnd();
		}
		LR.HACK_tutorialMode = false;
		yield return CombatWaitUntilComplete();
		SKIP_POINT("Skipped fight");
		MusicPlay("event:/music/a4s1/exploration");
		Ashley.HPRefill();
		yield return HAGIS.DialogShow((!hitEndOfTutorial) ? Ambient_HartmanTutorialOutsideCombatSkip : Ambient_HartmanTutorialOutsideCombat);
		UIObjectives.Inst.CompleteAndSetMainObjective(objPark);
		UIObjectives.Inst.AddObjective(subObjExplore);
		UIObjectives.Inst.AddObjective(subObjTapToMove, pulse: true);
		M_FilesToPark.gameObject.SetActive(value: true);
		HagletYieldTerm goToParkTrigger;
		do
		{
			goToParkTrigger = MapWaitUntilVisible(Park.Map);
			yield return CreateOrCondition(goToParkTrigger, Wait.ForSeconds(1f));
		}
		while (!goToParkTrigger.met && !MR.Inst.IsSkipping());
		MusicSetProgress(0.1f);
		SKIP_POINT("Skipped to Park");
		UIObjectives.Inst.CompleteObjective(subObjTapToMove);
		yield return HAGIS.DialogShow(Dialog_HartmanCompil);
		UIObjectives.Inst.CompleteAndSetMainObjective(objSpeakToArchi);
		yield return CreateTriggerCondition(I_TalkToArchi.OnTriggered);
		CutsceneBegin();
		Ashley.LookInDirection(OctDir.Up);
		yield return CreateTimeCondition(0.5f);
		CutsceneEnd();
		yield return CutscenePlay("A4S1_WakingArchi_Part1");
		CutsceneBegin();
		while (Archi.unitModel.IsPlayingAnim("CsTransUnconsciousToDIdle"))
		{
			yield return null;
		}
		CutsceneEnd();
		yield return CutscenePlay("A4S1_WakingArchi_Part2");
		Archi.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, null);
		UIObjectives.Inst.CompleteAndSetMainObjective(objHeadToGraves);
		M_ParkToGraveyard.gameObject.SetActive(value: true);
		D_Exit.gameObject.SetActive(value: false);
		TT_ThisWay.gameObject.SetActive(value: true);
		M_ParkToFiles.gameObject.SetActive(value: false);
		Archi.SetTeamType(UnitTeam.Type.Player);
		MusicSetProgress(0.2f);
		yield return CreateTimeCondition(1f);
		HAGIS.DialogShow(Ambient_ArchiYouGo);
		yield return CreateTriggerCondition(TT_ThisWay._OnTriggered);
		HAGIS.DialogShow(Ambient_AshThisWay);
		UIObjectives.Inst.CompleteObjective(objHeadToGraves);
		yield return UnitMoveToUnit(Archi, Ashley);
		UIObjectives.Inst.CompleteObjective(subObjExplore);
		MusicStop();
		M_GraveyardToPark.gameObject.SetActive(value: false);
		yield return MapWaitUntilVisible(Graveyard.Map);
		SKIP_POINT("Entered Graveyard");
		CutsceneBegin();
		MusicPlay("event:/music/a4s1/combat 2");
		yield return CreateTimeCondition(1.5f);
		Goon_G1.LookAt(Ashley);
		Holden.LookAt(Ashley);
		yield return CreateTimeCondition(1.2f);
		HAGIS.DialogShow(Dialog_HoldenParkToll);
		UnitMoveToTarget(Holden, T_HoldenIntroductionSpot, OctDir.DownLeft);
		yield return CreateTimeCondition(1.5f);
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(Holden, "TransDIdleToCIdle");
		yield return CreateTimeCondition(0.6f);
		Holden.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Holden.UpdateIdleAnim();
		yield return CreateTimeCondition(0.5f);
		Goon_G2.LookAt(Ashley);
		UnitPlayAnimation(Goon_G1, "TransDIdleToCIdle");
		UnitPlayAnimation(Goon_G2, "TransDIdleToCIdle");
		yield return CreateTimeCondition(0.2f);
		Goon_G1.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon_G1.UpdateIdleAnim();
		Goon_G2.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "CombatIdle");
		Goon_G2.UpdateIdleAnim();
		while (Singleton<UIC>.Inst.IsInStack<UINarrativeDialog>())
		{
			yield return null;
		}
		UnitMoveToTarget(Ashley, T_Ashley, OctDir.Up);
		UnitMoveToTarget(Holden, T_Compiler0);
		UnitMoveToTarget(Goon_G1, T_Compiler1);
		yield return UnitMoveToTarget(Goon_G2, T_Compiler2);
		CutsceneEnd();
		UIObjectives.Inst.AddObjective(objDefeat);
		SKIP_POINT("Skipped to Holden Fight");
		yield return HAGIS.DialogShow(Dialog_HartmanMuscleWarn);
		yield return CombatBegin(UnitTeam.Type.Player);
		UIObjectives.Inst.CompleteObjective(objDefeat);
		SKIP_POINT("Skiped past the Holden fight");
		yield return null;
		MusicStop();
		yield return CutscenePlay("A4S1_SeeingOffArchi");
		CutsceneBegin();
		yield return CreateTimeCondition(1f);
		yield return UnitMoveToTarget(Archi, T_Exit);
		Archi.Hide(makeInactive: true);
		yield return Wait.While(Ashley.LookInDirection(OctDir.Up));
		yield return CreateTimeCondition(1f);
		yield return HAGIS.DialogShow(Ambient_Sigh);
		yield return UnitMoveToTarget(Ashley, T_BackWall);
		yield return Wait.While(Ashley.LookInDirection(OctDir.Up));
		yield return HAGIS.DialogShow(Dialog_HartmanClimb);
		yield return CreateTimeCondition(1f);
		yield return CreateTimeCondition(0.5f);
		UnitPlayAnimation(Ashley, "CsDefaultDemoEnd");
		yield return CreateTimeCondition(4f);
		CutsceneEnd();
		MusicSetProgress(0.1f);
	}
}
public class HAGIS_A4S1_CrowAnimations : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Unit ParkCrow = GC.Inst.GetUnitWithId("BAF_T1DetritumPark_UnitSpawn");
		Unit ParkCrow2 = GC.Inst.GetUnitWithId("069_T1DetritumPark_UnitSpawn");
		Unit ParkCrow3 = GC.Inst.GetUnitWithId("4E1_T1DetritumPark_UnitSpawn");
		ParkCrow.unitModel.HACK_BirdMode = true;
		ParkCrow2.unitModel.HACK_BirdMode = true;
		ParkCrow3.unitModel.HACK_BirdMode = true;
		TileTrigger TT_ACTIVITEBIRDS = MR.Inst.GetTileTrigger("69B_T1DetritumPark_TileTrigger");
		LogicRoot Park = GetLogicUsingArtName("T1DetritumPark");
		yield return null;
		yield return TT_ACTIVITEBIRDS._OnTriggered;
		UnitPlayAnimation(ParkCrow2, "DefaultFly");
		UnitPlayAnimation(ParkCrow3, "DefaultFly");
		yield return CreateTimeCondition(1f);
		UnitPlayAnimation(ParkCrow, "DefaultTakeOffWall");
		yield return CreateTimeCondition(5f);
		ParkCrow2.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		ParkCrow3.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		yield return CreateTimeCondition(1f);
		ParkCrow.Hide(makeInactive: true, Unit.HologramAnim.IMMEDIATE);
		ParkCrow.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		ParkCrow2.unitModel.Play(UnitModel.AnimID.DefaultIdle);
		ParkCrow3.unitModel.Play(UnitModel.AnimID.DefaultIdle);
	}
}
public class HAGIS_A4S1_ParkAnimations : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		Unit Ambrosia = GC.Inst.GetUnitWithId("5F6_T1DetritumPark_UnitSpawn");
		Unit CivsMale = GC.Inst.GetUnitWithId("1FA_T1DetritumPark_UnitSpawn");
		Unit CivsFemale = GC.Inst.GetUnitWithId("014_T1DetritumPark_UnitSpawn");
		Unit CivsChild = GC.Inst.GetUnitWithId("739_T1DetritumPark_UnitSpawn");
		LogicRoot Park = GetLogicUsingArtName("T1DetritumPark");
		yield return null;
		while (true)
		{
			yield return MapWaitUntilVisible(Park.Map);
			while (Singleton<MC>.Inst.GetActiveMap() == Park.Map)
			{
				if (UnityEngine.Random.value > 0.5f)
				{
					yield return UnitPlayAnimation(Ambrosia, "CsDefaultSitAlt");
					yield return UnitPlayAnimation(Ambrosia, "CsDefaultSit");
					Ambrosia.UpdateIdleAnim();
					yield return CreateTimeCondition(4f);
				}
				else
				{
					UnitPlayAnimation(CivsMale, "DefaultFamilyIdleAlt");
					UnitPlayAnimation(CivsFemale, "DefaultFamilyIdleAlt");
					yield return UnitPlayAnimation(CivsChild, "DefaultFamilyIdleAlt");
					CivsMale.UpdateIdleAnim();
					CivsFemale.UpdateIdleAnim();
					CivsChild.UpdateIdleAnim();
					yield return CreateTimeCondition(4f);
				}
			}
		}
	}
}
public class HAGIS_ANIMATION_SI_TESTING : HAGIS
{
	private Unit Willa;

	private Unit Margot;

	private Unit Archi;

	private Unit Noot;

	private Unit Goon;

	private Unit Chris;

	private UnitTarget WillaToGiveItem;

	private UnitTarget ChrisToGetItem;

	private UnitTarget ChristToInteractScenery;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AnimationTestMap = GetLogicUsingArtName("Multiplayer_TestArea");
		Willa = GC.Inst.GetUnitWithId("915_Multiplayer_TestArea_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("01A_Multiplayer_TestArea_UnitSpawn");
		Goon = GC.Inst.GetUnitWithId("EFD_Multiplayer_TestArea_UnitSpawn");
		Margot = GC.Inst.GetUnitWithId("BDB_Multiplayer_TestArea_UnitSpawn");
		Archi = GC.Inst.GetUnitWithId("B21_Multiplayer_TestArea_UnitSpawn");
		Noot = GC.Inst.GetUnitWithId("082_Multiplayer_TestArea_UnitSpawn");
		Goon.gameObject.SetActive(value: false);
		yield return null;
		Willa.SetTeamType(UnitTeam.Type.Player);
		Chris.SetTeamType(UnitTeam.Type.Player);
		Noot.SetTeamType(UnitTeam.Type.Player);
		Archi.SetTeamType(UnitTeam.Type.Player);
		Margot.SetTeamType(UnitTeam.Type.Player);
		Goon.gameObject.SetActive(value: true);
		yield return CreateTimeCondition(1f);
		GC.Inst.StealthBegin();
		yield return Wait.ForSeconds(1E+10f);
	}
}
public class HAGIS_ANIMATION_TEST_MAP : HAGIS
{
	private Unit Willa;

	private Unit Willa2;

	private Unit Chris;

	private UnitTarget WillaToGiveItem;

	private UnitTarget ChrisToGetItem;

	private UnitTarget ChristToInteractScenery;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AnimationTestMap = GetLogicUsingArtName("Multiplayer_TestArea");
		Willa = GC.Inst.GetUnitWithId("915_Multiplayer_TestArea_UnitSpawn");
		Chris = GC.Inst.GetUnitWithId("01A_Multiplayer_TestArea_UnitSpawn");
		WillaToGiveItem = MR.Inst.GetUnitTarget("107_Multiplayer_TestArea_UnitTarget");
		ChrisToGetItem = MR.Inst.GetUnitTarget("590_Multiplayer_TestArea_UnitTarget");
		ChristToInteractScenery = MR.Inst.GetUnitTarget("5F5_Multiplayer_TestArea_UnitTarget");
		CutsceneBegin();
		yield return CreateTimeCondition(2f);
		UnitMoveToTarget(Willa, WillaToGiveItem);
		UnitMoveToTarget(Chris, ChrisToGetItem);
		yield return CreateTimeCondition(3f);
		Chris.unitModel.Play("DefaultGiveItem");
		Willa.unitModel.Play("DefaultReceiveItem");
		yield return CreateTimeCondition(2f);
		UnitMoveToTarget(Chris, ChristToInteractScenery);
		yield return CreateTimeCondition(4f);
		Chris.unitModel.Play("DefaultInteract");
		yield return CreateTimeCondition(2f);
		yield return Willa.unitModel.Play("TransDIdleToCIdle");
		yield return Willa.unitModel.Play("combatIdle");
		yield return CreateTimeCondition(0.4f);
		yield return Willa.unitModel.Play("TransCIdleToDIdle");
		yield return CreateTimeCondition(2f);
		CutsceneEnd();
		yield return Wait.ForSeconds(1E+10f);
	}
}
public class HAGIS_ANIMATION_TEST_MAP2 : HAGIS
{
	private Unit Willa;

	private UnitTarget WillaToGiveItem;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot AnimationTestMap = GetLogicUsingArtName("T1DetritumPark");
		Willa = GC.Inst.GetUnitWithId("915_Multiplayer_TestArea_UnitSpawn");
		WillaToGiveItem = MR.Inst.GetUnitTarget("107_Multiplayer_TestArea_UnitTarget");
		yield return null;
		CutsceneBegin();
		yield return CreateTimeCondition(2f);
		yield return UnitMoveToTarget(Willa, WillaToGiveItem);
		Willa.LookInDirection(OctDir.Down);
		yield return CreateTimeCondition(3f);
		yield return Willa.unitModel.Play("DefaultSit");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultSit");
		Willa.UpdateIdleAnim();
		yield return CreateTimeCondition(3f);
		yield return Willa.unitModel.Play("DefaultSitTalk");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultSitTalk");
		Willa.UpdateIdleAnim();
		yield return CreateTimeCondition(4f);
		yield return Willa.unitModel.Play("DefaultSit");
		Willa.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, "DefaultSit");
		Willa.UpdateIdleAnim();
		CutsceneEnd();
		yield return Wait.ForSeconds(1E+10f);
	}
}
public interface INPCWaypoint
{
	v2i GetCoord();

	OctDir GetDirection();

	void PerformNPCAction(Unit npc);

	bool ShouldReserveTile();

	bool IsValid();
}
public class NPCWaypoint : Serializer.ISelfConstructor
{
	private Map map;

	public INPCWaypoint wayPoint;

	public bool Reserved;

	public NPCWaypoint(Map map, INPCWaypoint wayPoint)
	{
		this.map = map;
		this.wayPoint = wayPoint;
	}

	private NPCWaypoint(BinaryReader reader)
	{
	}

	public void Deconstruct(BinaryWriter writer)
	{
	}

	public bool isOccupied()
	{
		v2i coord = wayPoint.GetCoord();
		return GC.Inst.GetUnitAtCoordOnMap(map, coord) != null || map.IsCoordReserved(coord);
	}
}
public class NPCWanderController : Singleton<NPCWanderController>
{
	private class NPCRoutine : Serializer.ISelfConstructor
	{
		public bool Active;

		private HagletResettable routine;

		private NPCWaypoint currentWaypoint;

		private Unit npc;

		private bool isWandering;

		public NPCRoutine(Unit unit)
		{
			npc = unit;
			routine = new HagletResettable(NPCWanderRoutine(), "NPC WANDERER");
		}

		private NPCRoutine(BinaryReader reader)
		{
		}

		public void Deconstruct(BinaryWriter writer)
		{
		}

		public void EnableWandering()
		{
			npc.ToggleAnimators(value: true);
			isWandering = true;
			if (!routine.running)
			{
				MR.Inst.Host.StartTopLevel(routine);
			}
		}

		public HagletEvent DisableWandering()
		{
			isWandering = false;
			return routine.completed;
		}

		public IEnumerator<HagletYieldTerm> NPCWanderRoutine()
		{
			while (isWandering)
			{
				if (GC.Inst.IsInTurnMode())
				{
					yield return GC.Inst._OnCombatComplete;
				}
				NPCWaypoint nextWaypoint = Singleton<NPCWanderController>.Inst.GetRandomWaypointOnMap(npc.map);
				if (nextWaypoint != null)
				{
					if (currentWaypoint != null)
					{
						currentWaypoint.Reserved = false;
					}
					currentWaypoint = nextWaypoint;
					nextWaypoint.Reserved = true;
					Unit unit = npc;
					v2i? destCoord = currentWaypoint.wayPoint.GetCoord();
					OctDir? endFacing = currentWaypoint.wayPoint.GetDirection();
					unit.StartMovement(destCoord, null, null, endFacing, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: false, avoidUnits: true, currentWaypoint.wayPoint.ShouldReserveTile());
					yield return Wait.ForChildren;
					if (!isWandering)
					{
						break;
					}
					currentWaypoint.wayPoint.PerformNPCAction(npc);
					yield return Wait.ForChildren;
				}
				else
				{
					yield return null;
				}
			}
		}
	}

	private Unit[] wanderingUnits;

	private Dictionary<Map, NPCWaypoint[]> missionWaypoints;

	private bool paused = true;

	private Dictionary<Unit, NPCRoutine> NPCRoutines = new Dictionary<Unit, NPCRoutine>();

	public NPCWaypoint GetRandomWaypointOnMap(Map map)
	{
		if (missionWaypoints.TryGetValue(map, out var value) && value.Length > 0)
		{
			for (int i = 0; i < 5; i++)
			{
				NPCWaypoint nPCWaypoint = value[UnityEngine.Random.Range(0, value.Length)];
				if (!nPCWaypoint.Reserved && !nPCWaypoint.isOccupied())
				{
					return nPCWaypoint;
				}
			}
		}
		return null;
	}

	public void EnableNPCWander(Unit npc)
	{
		NPCRoutines[npc].Active = true;
		if (!paused)
		{
			npc.ToggleAnimators(value: true);
			NPCRoutines[npc].EnableWandering();
		}
	}

	public void DisableNPCWander(Unit npc)
	{
		NPCRoutines[npc].Active = false;
		NPCRoutines[npc].DisableWandering();
	}

	public void PauseWandering()
	{
		paused = true;
		for (int i = 0; i < wanderingUnits.Length; i++)
		{
			NPCRoutine nPCRoutine = NPCRoutines[wanderingUnits[i]];
			if (nPCRoutine.Active)
			{
				nPCRoutine.DisableWandering();
			}
		}
	}

	public void ResumeWandering()
	{
		paused = false;
		for (int i = 0; i < wanderingUnits.Length; i++)
		{
			NPCRoutine nPCRoutine = NPCRoutines[wanderingUnits[i]];
			if (nPCRoutine.Active)
			{
				nPCRoutine.EnableWandering();
			}
		}
	}

	public void OnMissionSceneLoaded(MR mr)
	{
	}

	public void OnMissionStart(MR mr)
	{
		Map[] allMaps = Singleton<MC>.Inst.GetAllMaps();
		missionWaypoints = new Dictionary<Map, NPCWaypoint[]>();
		foreach (Map map in allMaps)
		{
			if (!map.logicRoot.NPC_Accessible)
			{
				continue;
			}
			INPCWaypoint[] componentsInChildren = map.logicRoot.GetComponentsInChildren<INPCWaypoint>();
			List<NPCWaypoint> list = new List<NPCWaypoint>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				if (componentsInChildren[j].IsValid())
				{
					list.Add(new NPCWaypoint(map, componentsInChildren[j]));
				}
			}
			missionWaypoints.Add(map, list.ToArray());
		}
		wanderingUnits = GC.Inst.GetUnitsAllInWorld().ToArray();
		for (int k = 0; k < wanderingUnits.Length; k++)
		{
			NPCRoutines.Add(wanderingUnits[k], new NPCRoutine(wanderingUnits[k]));
		}
	}

	public void OnMissionResume(MR mr)
	{
	}

	public void OnMissionSceneUnloaded(MR mr)
	{
	}

	public bool IsUnitWandering(Unit unit)
	{
		NPCRoutine value = null;
		if (NPCRoutines.TryGetValue(unit, out value))
		{
			return value.Active;
		}
		return false;
	}
}
public class HAGIS_AbilitiesTest : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		Party.Inst.AddItemToInventory(Item.Trap_Frag.ToMeta(), 3);
		Party.Inst.AddItemToInventory(Item.Grenade_Frag.ToMeta(), 3);
		Party.Inst.AddItemToInventory(Item.Trap_Stun.ToMeta(), 3);
		Party.Inst.AddItemToInventory(Item.Grenade_Stun.ToMeta(), 3);
		Party.Inst.AddItemToInventory(Item.Medpack.ToMeta(), 3);
		Unit abilityUnit = null;
		ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
		for (int i = 0; i < unitsAllInWorld.sLength; i++)
		{
			if (unitsAllInWorld[i].IsAlive() && unitsAllInWorld[i].teamType == UnitTeam.Type.Enemy)
			{
				abilityUnit = unitsAllInWorld[i];
				break;
			}
		}
		if ((bool)abilityUnit)
		{
			Ability_Trap caster = abilityUnit.abilities.Add<Ability_Trap>(null, isUpgraded: false);
			TileTrapTrigger component = LR.LoadPrefabResource("Gameplay/P_TTrapTrigger").GetComponent<TileTrapTrigger>();
			TileTrapTrigger tileTrapTrigger = UnityEngine.Object.Instantiate(component);
			component.InitialiseTrap(abilityUnit._GetTransform(), caster);
			component.size.x = 1;
			abilityUnit.map.PlaceTrap(GadgetType.FRAG, component, new v2i(10, 3), visable: false);
			component.transform.localScale = new Vector3(1f, 1f, 1f);
			tileTrapTrigger.InitialiseTrap(abilityUnit._GetTransform(), caster);
			tileTrapTrigger.size.x = 1;
			abilityUnit.map.PlaceTrap(GadgetType.FRAG, tileTrapTrigger, new v2i(14, 3), visable: false);
			tileTrapTrigger.transform.localScale = new Vector3(1f, 1f, 1f);
		}
		UIObjectives.Inst.CompleteAndSetMainObjective("Test Abilities");
		SKIP_POINT("Started combat!");
		while (true)
		{
			yield return CombatBegin(UnitTeam.Type.Player);
			ConstArray<Unit> units = GC.Inst.GetUnitsAllInWorld();
			for (int j = 0; j < units.sLength; j++)
			{
				if (!units[j].IsAlive())
				{
					units[j].Revive();
				}
			}
		}
	}
}
public class HAGIS_AutoTest : HAGIS
{
	[Serializable]
	private class AutoTestResult
	{
		public MissionResult[] missions;
	}

	[Serializable]
	private class MissionResult
	{
		[NonSerialized]
		public MissionSceneMeta meta;

		public string name;

		public string result;
	}

	public static void Log(string message)
	{
		UnityEngine.Debug.logger.filterLogType = LogType.Log;
		UnityEngine.Debug.Log(message);
		UnityEngine.Debug.logger.filterLogType = LogType.Error;
	}

	public static void LogFormat(string format, params object[] args)
	{
		UnityEngine.Debug.logger.filterLogType = LogType.Log;
		UnityEngine.Debug.LogFormat(format, args);
		UnityEngine.Debug.logger.filterLogType = LogType.Error;
	}

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		if (LR.DEBUG_autoTestFilters == null)
		{
			yield break;
		}
		Log("[AUTOTEST] Started!");
		AutoTestResult result = new AutoTestResult
		{
			missions = (from meta in AEResources.LoadAllResources<MissionSceneMeta>("SceneMetas")
				where LR.DEBUG_autoTestFilters.Any((string filter) => meta.name.Contains(filter))
				select new MissionResult
				{
					meta = meta,
					name = meta.name
				}).ToArray()
		};
		LogFormat("[AUTOTEST] Missions:\n{0}", string.Join("\t\n", result.missions.Select((MissionResult mission) => mission.name).ToArray()));
		while (!LR.Inst.IsInitialised)
		{
			yield return null;
		}
		UIDebug.HACK_SetUpParty();
		MissionResult[] missions = result.missions;
		foreach (MissionResult mission2 in missions)
		{
			yield return Wait.ForSeconds(1f);
			if (LR.DEBUG_autoTestSaveLoad)
			{
				LogFormat("[AUTOTEST] Loading Progress for {0}...", mission2.meta.name);
				yield return SaveData.LoadProgress(forceLog: false);
			}
			LogFormat("[AUTOTEST] Starting {0}...", mission2.meta.name);
			while (true)
			{
				try
				{
					LR.Inst.LoadMissionIntoFrontend(mission2.meta, immediate: true);
				}
				catch (Exception exc)
				{
					Log("[AUTOTEST] Mission failed to load!");
					mission2.result = TranslateToResult(exc);
					break;
				}
				HagletYieldTerm hagletYieldTerm = LR.Inst.OnLoadMissionComplete;
				HagletYieldTerm hagletYieldTerm2;
				HagletYieldTerm missionLoadFailed = (hagletYieldTerm2 = LR.Inst.OnLoadMissionFailed);
				yield return hagletYieldTerm | hagletYieldTerm2;
				if (missionLoadFailed.met)
				{
					Log("[AUTOTEST] Mission failed to load!");
					mission2.result = TranslateToResult(LR.lastMissionLoadException);
					break;
				}
				Log("[AUTOTEST] Skipping...");
				MR.Inst.Skip();
				HagletYieldTerm hagletYieldTerm3 = LR.Inst.OnUnloadMissionComplete;
				HagletYieldTerm missionHung = (hagletYieldTerm2 = Wait.ForSeconds((!LR.DEBUG_autoTestSaveLoad) ? 5f : 30f));
				HagletYieldTerm hagletYieldTerm4 = hagletYieldTerm3 | hagletYieldTerm2;
				HagletYieldTerm missionException = (hagletYieldTerm2 = Wait.Until(() => HAGIS.HACK_MissionException != null));
				HagletYieldTerm hagletYieldTerm5 = hagletYieldTerm4 | hagletYieldTerm2;
				HagletYieldTerm missionComplete = (hagletYieldTerm2 = Wait.Until(() => GC.HACK_missionComplete));
				yield return hagletYieldTerm5 | hagletYieldTerm2;
				if (missionHung.met)
				{
					Log("[AUTOTEST] Timed out!");
					if (MR.Inst != null)
					{
						LR.Inst.UnloadMissionScene(immediate: true);
					}
					mission2.result = "Timed out";
					break;
				}
				if (missionException.met)
				{
					Log("[AUTOTEST] Exception!");
					mission2.result = TranslateToResult(HAGIS.HACK_MissionException);
					break;
				}
				if (missionComplete.met)
				{
					mission2.result = "Pass";
					break;
				}
				Log("[AUTOTEST] Loading Mid mission!");
				string savedMission = SaveData.savedMission;
				yield return SaveData.LoadMission(unthreaded: true);
				if (HAGIS.HACK_MissionException != null)
				{
					Log("[AUTOTEST] Load Mission SaveData Exception!");
					mission2.result = TranslateToResult(HAGIS.HACK_MissionException);
					break;
				}
			}
			LogFormat("[AUTOTEST] Completed {0}!", mission2.meta.name);
		}
		Log("[AUTOTEST] Completed test!");
		string json = JsonUtility.ToJson(result, prettyPrint: true);
		LogFormat("[AUTOTEST] Results:...\n{0}", json);
		LogFormat("[AUTOTEST] Writing results to '{0}'...", LR.DEBUG_autoTestPath);
		using (StreamWriter streamWriter = new StreamWriter(File.Create(LR.DEBUG_autoTestPath)))
		{
			streamWriter.WriteLine(json);
		}
		LR.DEBUG_autoTestPostURL = "http://coatsinkserver1/jenkinsnotify/api/autotest";
		if (LR.DEBUG_autoTestPostURL != null)
		{
			LogFormat("[AUTOTEST] Posting results to '{0}'...", LR.DEBUG_autoTestPostURL);
			WWW post = new WWW(headers: new Dictionary<string, string> { { "Content-Type", "application/json" } }, postData: Encoding.UTF8.GetBytes(json), url: LR.DEBUG_autoTestPostURL);
			StartCoroutine(FormRoutine(post));
			yield return Wait.Until(() => post.isDone);
		}
		UnityEngine.Application.Quit();
		UnityEngine.Debug.logger.filterLogType = LogType.Log;
	}

	private static string TranslateToResult(Exception exc)
	{
		try
		{
			string[] value = (from line in exc.StackTrace.Split(new string[1] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
				where !line.Contains("Coatsink.Common.Panic")
				select line).ToArray();
			string text = string.Join(Environment.NewLine, value);
			int num = text.IndexOf(" at ") + 4;
			int num2 = text.IndexOf(" (", num);
			string text2 = text.Substring(num, num2 - num);
			if (UnityEngine.Debug.isDebugBuild)
			{
				int num3 = text.IndexOf(" \r\n", num);
				int num4 = text.LastIndexOf('\\', num3, num3 - num2) + 1;
				string text3 = text.Substring(num4, num3 - num4);
				int num5 = text.IndexOf("\\HAGIS_", num3) + 1;
				if (num5 > 0)
				{
					int num6 = text.IndexOf(" \r\n", num5);
					string text4 = text.Substring(num5, num6 - num5);
					return $"{exc.Message} ({exc.GetType().Name} in {text2} at {text3} from {text4})";
				}
				return $"{exc.Message} ({exc.GetType().Name} in {text2} at {text3})";
			}
			return $"{exc.Message} ({exc.GetType().Name} in {text2})";
		}
		catch
		{
			return $"{exc.Message} ({exc.GetType().Name})";
		}
	}

	private IEnumerator FormRoutine(WWW post)
	{
		yield return post;
		LogFormat("[AUTOTEST] - Post completed, returned text: {0}", post.text);
	}
}
public class HAGIS_CombatTest : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		yield return Wait.ForSeconds(30000f);
		SKIP_POINT("Started combat!");
		yield return CombatBegin(UnitTeam.Type.Player);
		SKIP_POINT("Combat completed!, Waiting for a long time!");
		yield return CreateTimeCondition(30000f);
	}
}
public class MagicClass<T>
{
	private MagicClass(IEnumerator<HagletYieldTerm> routineIn)
	{
	}

	public IEnumerator<HagletYieldTerm> RadFuncBrah(int test)
	{
		test += 4;
		yield break;
	}

	private void Start(T t)
	{
	}
}
public class MagicLessClass
{
	public IEnumerator<HagletYieldTerm> RadFuncBrah(int test)
	{
		yield break;
	}
}
public class HAGIS_InitSaveData : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return SaveData.Retain();
	}
}
public class HAGIS_LocalMultiplayer : HAGIS
{
	public bool DEBUG_UpgradeAllAbilities;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return CreateTimeCondition(1f);
		if (DEBUG_UpgradeAllAbilities)
		{
			for (int i = 0; i < GC.Inst.GetUnitsActive().Length; i++)
			{
				Unit unit = GC.Inst.GetUnitsActive()[i];
				foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
				{
					item.HACK_isUpgraded = true;
				}
			}
		}
		AC.Inst.PlayOneShot2D("event:/sfx/ambience/background/water plant");
		MusicPlay("event:/music/battle/multiplayer demo");
		CombatBegin(UnitTeam.Type.Player);
		yield return CombatWaitUntilComplete();
		yield return CreateTimeCondition(1f);
	}
}
public class HAGIS_OculusDemo : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
	}
}
public class HAGIS_Test : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		Singleton<MC>.Inst.GetActiveMap().logicRoot.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(Singleton<MC>.Inst.GetActiveMap());
		yield return CreateTimeCondition(10000f);
	}
}
public class HAGIS_TestALLART : HAGIS
{
	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		yield return null;
		LogicRoot HightSecurityTunnel = GetLogicUsingArtName("T1MineHighSecurityTunnel");
		LogicRoot LadderToFreedom = GetLogicUsingArtName("T1LadderToFreedom");
		LogicRoot LighthouseIsland = GetLogicUsingArtName("T1LightHouseIsland");
		LogicRoot InterrogationCell = GetLogicUsingArtName("T1RotgutPrison_InterrogationCell");
		LogicRoot MineCore = GetLogicUsingArtName("T1MineCore");
		LogicRoot Infirmary = GetLogicUsingArtName("T1Rotgut_Infirmary");
		LogicRoot FreighterDeck = GetLogicUsingArtName("T1FreighterDeck");
		LogicRoot Elevator = GetLogicUsingArtName("T1RotgutPrison_Elevator");
		LogicRoot parkLogic = GetLogicUsingArtName("T1DetritumPark");
		LogicRoot graveLogic = GetLogicUsingArtName("T1DetritumGraveyard");
		LogicRoot cambridgeLogic = GetLogicUsingArtName("T1Cambridge");
		LogicRoot PimGrickle = GetLogicUsingArtName("T1PimDickles");
		LogicRoot blindtiger = GetLogicUsingArtName("T1Bar1_BlindTiger");
		LogicRoot backstageLogic = GetLogicUsingArtName("T1Bar2_BehindTheTiger");
		LogicRoot arenaLogic = GetLogicUsingArtName("T1Bar3_BlindTigerArena");
		LogicRoot portEntranceLogic = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot portLogic = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot SubwayCam = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot SubwayPort = GetLogicUsingArtName("T1Subway_Station_PortHara");
		LogicRoot TrainInterior = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot SubwayStationLogic = GetLogicUsingArtName("T1Subway_Station_Kaydock");
		LogicRoot KaydockExtiriorLogic = GetLogicUsingArtName("T1Kaydock_PlantExterior");
		LogicRoot KaydockInteriorLogic = GetLogicUsingArtName("T1Kaydock_ControlRoom");
		LogicRoot VaultEntrance = GetLogicUsingArtName("T1VaultEntrance");
		LogicRoot AtlantiumVaultLogic = GetLogicUsingArtName("T1AtlantiumVault");
		LogicRoot tenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot maintenanceBay = GetLogicUsingArtName("T2RobotMaintenanceBay");
		LogicRoot outsideTheCity = GetLogicUsingArtName("T2OutsideTheCity");
		LogicRoot museumOfCulture = GetLogicUsingArtName("T2MuseumOfCulture");
		LogicRoot fissionTechtonics = GetLogicUsingArtName("T2FissionTechtonicsExhibit");
		LogicRoot billysHilltopFarm = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot ascensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		LogicRoot ascensionPlatform = GetLogicUsingArtName("T2AscensionPlatform");
		LogicRoot skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot PortHaraEntrance = GetLogicUsingArtName("T1Port1_HaraEntrance");
		LogicRoot Skids = GetLogicUsingArtName("T1TheSkids");
		LogicRoot SkidsElevator = GetLogicUsingArtName("T1FreightElevator");
		LogicRoot SubwayTrain = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot TheFiles = GetLogicUsingArtName("T1TheFiles");
		LogicRoot ChumleysExterior = GetLogicUsingArtName("T2ChumleysAutomatons_Exterior");
		LogicRoot MuseumOfCulture = GetLogicUsingArtName("T2TenorCityCentreMall");
		LogicRoot Skyway = GetLogicUsingArtName("T2Skyway");
		LogicRoot TenorCityCentre = GetLogicUsingArtName("T2TenorCityCentre");
		LogicRoot UnderclockHQExterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclockHQRooftop = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot GoszHideout_Ruined = GetLogicUsingArtName("T2GoszsHQ_A2O6");
		LogicRoot OmegaOffice = GetLogicUsingArtName("T3OmegaOffices");
		LogicRoot CelestiaTownCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot BroadcastTowerOutside = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot BroadcastTowerInside = GetLogicUsingArtName("T3RelayTowerInterior");
		LogicRoot ChumleysInterior = GetLogicUsingArtName("T2ChumleysFactory");
		LogicRoot ChumleysTestbay = GetLogicUsingArtName("T2ChumleysFactory_TestingControlBay");
		LogicRoot RobotMaintenanceBay = GetLogicUsingArtName("T2RobotMaintenanceBay");
		LogicRoot FissionTechtonicsExhibit = GetLogicUsingArtName("T2FissionTechtonicsExhibit");
		LogicRoot AscensionExhibit = GetLogicUsingArtName("T2AscensionExhibit");
		LogicRoot UnderclocksPoliceStation_Exterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot UnderclocksPoliceStation_Roof = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot ClockTower = GetLogicUsingArtName("T2ClockTower");
		LogicRoot PortHara = GetLogicUsingArtName("T1Port2_HaraMainBay");
		LogicRoot Train = GetLogicUsingArtName("T1Subway_TrainInterior");
		LogicRoot CambridgeSubwayStation = GetLogicUsingArtName("T1Subway_Station_Cambridge");
		LogicRoot Cambridge = GetLogicUsingArtName("T1Cambridge");
		LogicRoot Distillery = GetLogicUsingArtName("T1AlembicDistillery");
		LogicRoot SlagEntrance = GetLogicUsingArtName("T1Slags_Ent");
		LogicRoot SlagMain = GetLogicUsingArtName("T1Slags");
		LogicRoot AlemDistLogic = GetLogicUsingArtName("T1AlembicDistillery");
		LogicRoot subwayLogicSlag = GetLogicUsingArtName("T1Subway_Station_Slags");
		LogicRoot SubwayStationLogicFiles = GetLogicUsingArtName("T1Subway_Station_Files");
		LogicRoot kaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot hydroponicsPlant = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot TenorMall = GetLogicUsingArtName("T2TenorCityCentreMall");
		LogicRoot ArenaCarPark = GetLogicUsingArtName("T2TheKaydockArenaCarPark");
		LogicRoot KaydockArenaBar = GetLogicUsingArtName("T2TheKaydockArenaBar");
		LogicRoot HQExterior = GetLogicUsingArtName("T2UnderclocksPoliceStation_Exterior");
		LogicRoot HQRooftop = GetLogicUsingArtName("T2UnderclocksPoliceStation_Roof");
		LogicRoot Clocktower = GetLogicUsingArtName("T2ClockTower");
		LogicRoot CelestiaCentre = GetLogicUsingArtName("T3CelestiaTownCentre");
		LogicRoot CelestiaRelayTower = GetLogicUsingArtName("T3RelayTowerExterior");
		LogicRoot CelestiaGardens = GetLogicUsingArtName("T3BotanicalGardens");
		LogicRoot androidServicingLogic = GetLogicUsingArtName("T1AndroidServicing");
		LogicRoot CelestiaOmegaOffice = GetLogicUsingArtName("T3OmegaOffices");
		LogicRoot CelestiaWelcomeHome = GetLogicUsingArtName("T3WelcomeToYourNewWorldExhibit");
		LogicRoot CelestiaLandingPad = GetLogicUsingArtName("T3LandingPad");
		LogicRoot CelestiaTownCentreNoSnow = GetLogicUsingArtName("T3CelestiaTownCentreNoSnow");
		LogicRoot T2UnderclockMeetingRoom = GetLogicUsingArtName("T2UnderclockMeetingRoom");
		LogicRoot GoszHQ = GetLogicUsingArtName("T2GoszsHQ");
		LogicRoot WillasRoom = GetLogicUsingArtName("T2WillasRoom");
		LogicRoot FreightElevator = GetLogicUsingArtName("T1FreightElevator");
		LogicRoot TheSkids = GetLogicUsingArtName("T1TheSkids");
		LogicRoot vitaLogic = GetLogicUsingArtName("T1VitaSoft");
		LogicRoot VitaSoftBackRoomLogic = GetLogicUsingArtName("T1VitaSoftBackRoom");
		LogicRoot deusoftCosmetics = GetLogicUsingArtName("T2DeusoftCosmetics");
		LogicRoot SubwayTunnelLogic = GetLogicUsingArtName("T1Subway_Tunnel");
		Singleton<MC>.Inst.GetActiveMap().logicRoot.unitsMoveToDefaultPositions = false;
		yield return MapWaitUntilVisible(Singleton<MC>.Inst.GetActiveMap());
		while (true)
		{
			yield return MapWaitUntilVisible(PimGrickle.Map);
			SKIP_POINT("PimGrickle");
			yield return MapWaitUntilVisible(blindtiger.Map);
			SKIP_POINT("blindtiger");
			yield return MapWaitUntilVisible(backstageLogic.Map);
			SKIP_POINT("backstageLogic");
			yield return MapWaitUntilVisible(arenaLogic.Map);
			SKIP_POINT("arenaLogic");
			yield return MapWaitUntilVisible(SubwayCam.Map);
			SKIP_POINT("SubwayCam");
			yield return MapWaitUntilVisible(SubwayPort.Map);
			SKIP_POINT("SubwayPort");
			yield return MapWaitUntilVisible(subwayLogicSlag.Map);
			SKIP_POINT("subwayLogicSlag");
			yield return MapWaitUntilVisible(SubwayStationLogicFiles.Map);
			SKIP_POINT("SubwayStationLogicFiles");
			yield return MapWaitUntilVisible(SubwayStationLogic.Map);
			SKIP_POINT("SubwayStationLogic");
			yield return MapWaitUntilVisible(KaydockExtiriorLogic.Map);
			SKIP_POINT("KaydockExtiriorLogic");
			yield return MapWaitUntilVisible(KaydockInteriorLogic.Map);
			SKIP_POINT("KaydockInteriorLogic");
			yield return MapWaitUntilVisible(kaydockArenaBar.Map);
			SKIP_POINT("kaydockArenaBar");
			yield return MapWaitUntilVisible(ArenaCarPark.Map);
			SKIP_POINT("ArenaCarPark");
			yield return MapWaitUntilVisible(TenorMall.Map);
			SKIP_POINT("TenorMall");
			yield return MapWaitUntilVisible(TenorCityCentre.Map);
			SKIP_POINT("TenorCityCentre");
			yield return MapWaitUntilVisible(skyway.Map);
			SKIP_POINT("skyway");
			yield return MapWaitUntilVisible(fissionTechtonics.Map);
			SKIP_POINT("fissionTechtonics");
			yield return MapWaitUntilVisible(museumOfCulture.Map);
			SKIP_POINT("museumOfCulture");
			yield return MapWaitUntilVisible(ascensionExhibit.Map);
			SKIP_POINT("ascensionExhibit");
			yield return MapWaitUntilVisible(ascensionPlatform.Map);
			SKIP_POINT("ascensionPlatform");
			yield return MapWaitUntilVisible(CelestiaWelcomeHome.Map);
			SKIP_POINT("CelestiaWelcomeHome");
			yield return MapWaitUntilVisible(OmegaOffice.Map);
			SKIP_POINT("OmegaOffice");
			yield return MapWaitUntilVisible(CelestiaCentre.Map);
			SKIP_POINT("CelestiaCentre");
			yield return MapWaitUntilVisible(CelestiaTownCentreNoSnow.Map);
			SKIP_POINT("CelestiaTownCentreNoSnow");
			yield return MapWaitUntilVisible(BroadcastTowerOutside.Map);
			SKIP_POINT("BroadcastTowerOutside");
			yield return MapWaitUntilVisible(BroadcastTowerInside.Map);
			SKIP_POINT("BroadcastTowerInside");
			yield return MapWaitUntilVisible(CelestiaGardens.Map);
			SKIP_POINT("CelestiaGardens");
			yield return MapWaitUntilVisible(CelestiaLandingPad.Map);
			SKIP_POINT("CelestiaLandingPad");
			yield return MapWaitUntilVisible(Elevator.Map);
			SKIP_POINT("Elevator");
			yield return MapWaitUntilVisible(graveLogic.Map);
			SKIP_POINT("graveLogic");
			yield return MapWaitUntilVisible(parkLogic.Map);
			SKIP_POINT("parkLogic");
			yield return MapWaitUntilVisible(TheFiles.Map);
			SKIP_POINT("TheFiles");
			yield return MapWaitUntilVisible(androidServicingLogic.Map);
			SKIP_POINT("androidServicingLogic");
			yield return MapWaitUntilVisible(ClockTower.Map);
			SKIP_POINT("ClockTower");
			yield return MapWaitUntilVisible(UnderclocksPoliceStation_Roof.Map);
			SKIP_POINT("UnderclocksPoliceStation_Roof");
			yield return MapWaitUntilVisible(T2UnderclockMeetingRoom.Map);
			SKIP_POINT("T2UnderclockMeetingRoom");
			yield return MapWaitUntilVisible(UnderclocksPoliceStation_Exterior.Map);
			SKIP_POINT("UnderclocksPoliceStation_Exterior");
			yield return MapWaitUntilVisible(ChumleysExterior.Map);
			SKIP_POINT("ChumleysExterior");
			yield return MapWaitUntilVisible(ChumleysInterior.Map);
			SKIP_POINT("ChumleysInterior");
			yield return MapWaitUntilVisible(ChumleysTestbay.Map);
			SKIP_POINT("ChumleysTestbay");
			yield return MapWaitUntilVisible(GoszHQ.Map);
			SKIP_POINT("GoszHQ");
			yield return MapWaitUntilVisible(GoszHideout_Ruined.Map);
			SKIP_POINT("GoszHideout_Ruined");
			yield return MapWaitUntilVisible(hydroponicsPlant.Map);
			SKIP_POINT("hydroponicsPlant");
			yield return MapWaitUntilVisible(WillasRoom.Map);
			SKIP_POINT("WillasRoom");
			yield return MapWaitUntilVisible(FreightElevator.Map);
			SKIP_POINT("FreightElevator");
			yield return MapWaitUntilVisible(TheSkids.Map);
			SKIP_POINT("TheSkids");
			yield return MapWaitUntilVisible(PortHaraEntrance.Map);
			SKIP_POINT("PortHaraEntrance");
			yield return MapWaitUntilVisible(PortHara.Map);
			SKIP_POINT("PortHara");
			yield return MapWaitUntilVisible(FreighterDeck.Map);
			SKIP_POINT("FreighterDeck");
			yield return MapWaitUntilVisible(SlagEntrance.Map);
			SKIP_POINT("SlagEntrance");
			yield return MapWaitUntilVisible(SlagMain.Map);
			SKIP_POINT("SlagMain");
			yield return MapWaitUntilVisible(Distillery.Map);
			SKIP_POINT("Distillery");
			yield return MapWaitUntilVisible(MineCore.Map);
			SKIP_POINT("MineCore");
			yield return MapWaitUntilVisible(Infirmary.Map);
			SKIP_POINT("Infirmary");
			yield return MapWaitUntilVisible(HightSecurityTunnel.Map);
			SKIP_POINT("HightSecurityTunnel");
			yield return MapWaitUntilVisible(LadderToFreedom.Map);
			SKIP_POINT("LadderToFreedom");
			yield return MapWaitUntilVisible(LighthouseIsland.Map);
			SKIP_POINT("LighthouseIsland");
			yield return MapWaitUntilVisible(outsideTheCity.Map);
			SKIP_POINT("outsideTheCity");
			yield return MapWaitUntilVisible(RobotMaintenanceBay.Map);
			SKIP_POINT("RobotMaintenanceBay");
			yield return MapWaitUntilVisible(SubwayTrain.Map);
			SKIP_POINT("SubwayTrain");
			yield return MapWaitUntilVisible(SubwayTunnelLogic.Map);
			SKIP_POINT("SubwayTunnelLogic");
			yield return MapWaitUntilVisible(vitaLogic.Map);
			SKIP_POINT("vitaLogic");
			yield return MapWaitUntilVisible(deusoftCosmetics.Map);
			SKIP_POINT("deusoftCosmetics");
			yield return MapWaitUntilVisible(VitaSoftBackRoomLogic.Map);
			SKIP_POINT("VitaSoftBackRoomLogic");
			yield return MapWaitUntilVisible(VaultEntrance.Map);
			SKIP_POINT("VaultEntrance");
			yield return MapWaitUntilVisible(AtlantiumVaultLogic.Map);
			SKIP_POINT("AtlantiumVaultLogic");
		}
	}
}
public class HAGIS_TrailerCaptureMaps : HAGIS
{
	private Unit tenorCity_Ashley;

	private Unit tenorCity_runner;

	private Unit tenorCity_Soldier;

	private Unit elevator_Willa;

	private Unit elevator_Archi;

	private Unit elevator_Tucker1;

	private Unit elevator_Tucker2;

	private Unit elevator_Tucker3;

	private Unit museum_Noot;

	private Unit museum_Ambro;

	private Unit museum_Fusel1;

	private Unit museum_Fusel2;

	private Unit hydro_Willa;

	private Unit hydro_GardenerBot1;

	private Unit hydro_GardenerBot2;

	private Unit hydro_GardenerBot3;

	private ScrollingWalls elevatorWalls;

	private float elevatorSpeed = 3f;

	public override IEnumerator<HagletYieldTerm> OnLogic()
	{
		LogicRoot elevatorLogic = GetLogicUsingArtName("T1FreightElevator");
		LogicRoot hydroLogic = GetLogicUsingArtName("T2Hydroponics");
		LogicRoot museumLogic = GetLogicUsingArtName("T2MuseumOfCulture");
		LogicRoot tenorLogic = GetLogicUsingArtName("T2TenorCityCentre");
		tenorCity_Ashley = GC.Inst.GetUnitWithId("829_T2TenorCityCentre_UnitSpawn");
		tenorCity_runner = GC.Inst.GetUnitWithId("96D_T2TenorCityCentre_UnitSpawn");
		tenorCity_Soldier = GC.Inst.GetUnitWithId("E74_T2TenorCityCentre_UnitSpawn");
		elevator_Willa = GC.Inst.GetUnitWithId("D9D_T1FreightElevator_UnitSpawn");
		elevator_Archi = GC.Inst.GetUnitWithId("95F_T1FreightElevator_UnitSpawn");
		elevator_Tucker1 = GC.Inst.GetUnitWithId("86C_T1FreightElevator_UnitSpawn");
		elevator_Tucker2 = GC.Inst.GetUnitWithId("2B5_T1FreightElevator_UnitSpawn");
		elevator_Tucker3 = GC.Inst.GetUnitWithId("6A8_T1FreightElevator_UnitSpawn");
		museum_Noot = GC.Inst.GetUnitWithId("C76_T2MuseumOfCulture_UnitSpawn");
		museum_Ambro = GC.Inst.GetUnitWithId("427_T2MuseumOfCulture_UnitSpawn");
		museum_Fusel1 = GC.Inst.GetUnitWithId("D09_T2MuseumOfCulture_UnitSpawn");
		museum_Fusel2 = GC.Inst.GetUnitWithId("FA6_T2MuseumOfCulture_UnitSpawn");
		hydro_Willa = GC.Inst.GetUnitWithId("BE1_T1Subway_TrainInterior_UnitSpawn");
		hydro_GardenerBot1 = GC.Inst.GetUnitWithId("C58_T2Hydroponics_UnitSpawn");
		hydro_GardenerBot2 = GC.Inst.GetUnitWithId("B42_T2Hydroponics_UnitSpawn");
		hydro_GardenerBot3 = GC.Inst.GetUnitWithId("75D_T2Hydroponics_UnitSpawn");
		elevatorWalls = elevatorLogic.Map.GetComponentInChildren<ScrollingWalls>();
		yield return null;
		yield return null;
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return CreateTimeCondition(3000f);
		SKIP_POINT("Go to freight elevator combat");
		tenorCity_Ashley.SetTeamType(UnitTeam.Type.NPC);
		tenorCity_runner.SetTeamType(UnitTeam.Type.NPC);
		tenorCity_Soldier.SetTeamType(UnitTeam.Type.NPC);
		elevatorWalls.speed = elevatorSpeed;
		yield return MapGoto(elevatorLogic.Map);
		yield return null;
		elevator_Archi.SetTeamType(UnitTeam.Type.Player);
		elevator_Willa.SetTeamType(UnitTeam.Type.Player);
		elevator_Tucker1.SetTeamType(UnitTeam.Type.Opponent);
		elevator_Tucker2.SetTeamType(UnitTeam.Type.Opponent);
		elevator_Tucker3.SetTeamType(UnitTeam.Type.Opponent);
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return CreateTimeCondition(3000f);
		SKIP_POINT("Go to museum combat");
		elevator_Archi.SetTeamType(UnitTeam.Type.NPC);
		elevator_Willa.SetTeamType(UnitTeam.Type.NPC);
		elevator_Tucker1.SetTeamType(UnitTeam.Type.NPC);
		elevator_Tucker2.SetTeamType(UnitTeam.Type.NPC);
		elevator_Tucker3.SetTeamType(UnitTeam.Type.NPC);
		yield return MapGoto(museumLogic.Map);
		elevatorWalls.speed = 0f;
		yield return null;
		museum_Ambro.SetTeamType(UnitTeam.Type.Player);
		museum_Noot.SetTeamType(UnitTeam.Type.Player);
		museum_Fusel1.SetTeamType(UnitTeam.Type.Opponent);
		museum_Fusel2.SetTeamType(UnitTeam.Type.Opponent);
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return CreateTimeCondition(3000f);
		SKIP_POINT("Go to hydroponics combat");
		museum_Ambro.SetTeamType(UnitTeam.Type.NPC);
		museum_Noot.SetTeamType(UnitTeam.Type.NPC);
		museum_Fusel1.SetTeamType(UnitTeam.Type.NPC);
		museum_Fusel2.SetTeamType(UnitTeam.Type.NPC);
		yield return MapGoto(hydroLogic.Map);
		yield return null;
		hydro_Willa.SetTeamType(UnitTeam.Type.Player);
		hydro_GardenerBot1.SetTeamType(UnitTeam.Type.Opponent);
		hydro_GardenerBot2.SetTeamType(UnitTeam.Type.Opponent);
		yield return CombatBegin(UnitTeam.Type.Player);
		yield return CreateTimeCondition(3000f);
	}
}
public class STUB_HartmanSpawn : MonoBehaviour
{
}
public class STUB_Logo : MonoBehaviour
{
}
public class STUB_RoomInteractable : MonoBehaviour
{
	private void OnEnable()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class STUB_Violin : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class STUB_MapAnimChildTransform : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class STUB_MapPivot : MonoBehaviour
{
}
[Serializable]
[CreateAssetMenu]
public class StatusEffectMeta : AEScriptableResource
{
	public string displayName;

	private new string name;

	[TextArea(5, 10)]
	public string description;

	[ReadOnly]
	public Sprite iconSmall;

	[ReadOnly]
	public Sprite iconLarge;

	private StatusEffect.Type type;
}
public struct StatusEffect
{
	public enum Type
	{
		Bleeding,
		BleedingOverloaded,
		ReducedAccuracy,
		ReducedMovement,
		Overridden,
		Suppressed,
		SuppressedOverloaded,
		Stunned,
		Spotted,
		Taunted,
		MAX
	}

	public StatusEffectMeta meta;

	public int cooldown;

	public AbilityImplBase ability;

	private static Dictionary<Type, StatusEffectMeta> statusEffectMetas = new Dictionary<Type, StatusEffectMeta>();

	public static StatusEffect Create(Type type, AbilityImplBase ability, int cooldown)
	{
		StatusEffect result = default(StatusEffect);
		result.meta = statusEffectMetas[type];
		result.ability = ability;
		result.cooldown = cooldown;
		return result;
	}

	public static void Initialise()
	{
		for (int i = 0; i < 10; i++)
		{
			Type key = (Type)i;
			StatusEffectMeta value = AEResources.LoadFirstResource<StatusEffectMeta>("StatusEffects/" + key);
			statusEffectMetas.Add(key, value);
		}
	}
}
public struct StatusEffects
{
	public ConstArray<StatusEffect> effects;

	public StatusEffects(uint size)
	{
		effects = new ConstArray<StatusEffect>(size);
	}

	public void Add(StatusEffect effect)
	{
		if (!effects.Contains(effect))
		{
			effects.Add(effect);
		}
	}
}
public class TurretUnitModel : UnitModel
{
}
[SelectionBase]
public class Unit : MonoBehaviour, Serializer.ISelfComposer
{
	private struct Overwatch
	{
		public bool active;

		public float range;

		public bool isCloseRange;
	}

	public enum HologramAnim
	{
		DEFAULT,
		IMMEDIATE,
		UNIT_DEATH,
		UNIT_LEAP
	}

	private class SetCoordResettable : HagletResettable
	{
		public v2i targetCoord;

		public Map targetMap;

		public SetCoordResettable(Unit unit)
			: base(unit.SetCoordRoutine(), unit.charData.charName + " Set Coord", HagletStepTime.Update, -1, 1)
		{
		}

		protected SetCoordResettable(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public enum IfTooFar
	{
		IgnoreLimits,
		GoAsFarAsPossible,
		InvalidateAction
	}

	public enum VaultAllowed
	{
		No,
		AskUnit,
		Always
	}

	[Serializable]
	public struct PatrolPoint
	{
		public v2i coord;

		public OctDir direction;
	}

	[Serializable]
	public class ShowHide : HagletResettable
	{
		public bool isShowing;

		public bool isChangingActiveState;

		public HologramAnim context;

		public ShowHide(Unit unit)
			: base(unit.ShowHideRoutine(), unit.charData.charName + " ShowHide")
		{
		}

		protected ShowHide(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private class Attack : HagletResettable
	{
		public ConstArray<Unit> targets = new ConstArray<Unit>(8u);

		public ConstArray<Combat.CombatData> data = new ConstArray<Combat.CombatData>(8u);

		public WeaponAttributes weapon;

		public bool costsAP;

		public IfTooFar ifTargetIsTooFar;

		public v2i? customTargetCoord;

		public Combat.CombatMinigame miniGame;

		public Bullet[] bulletRoutines = new Bullet[8];

		public bool isReactionAttack;

		public bool isAbilityAttack;

		public bool updateIdleOnComplete;

		public string overrideAnimationName;

		public int attackCount;

		public Combat.CombatData? overrideCombatData;

		public bool IsSingleTarget => targets.Length == 1;

		public Attack(Unit unit)
			: base(unit.AttackRoutine(), unit.charData.charName + " Attack")
		{
			for (int i = 0; i < bulletRoutines.Length; i++)
			{
				bulletRoutines[i] = new Bullet(unit, i);
			}
		}

		protected Attack(BinaryReader reader)
			: base(reader)
		{
		}

		protected override void Complete()
		{
			base.Complete();
			targets.Clear();
			weapon = null;
			costsAP = false;
		}
	}

	[Serializer.ExcludeAllFields]
	public class Bullet : HagletResettable
	{
		public enum BulletType
		{
			Default,
			Ricochet
		}

		public int targetIdx;

		public Combat.HitType hitType;

		public Combat.HitType additionalEffect = Combat.HitType.None;

		public BulletType bulletType;

		public Bullet(Unit unit, int idx)
			: base(unit.BulletRoutine(idx), unit.charData.charName + "_Bullet_" + idx)
		{
		}

		protected Bullet(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public struct FakeAttack
	{
		public Vector3 target;

		public bool updateIdleOnComplete;

		public string animOverride;
	}

	[Serializable]
	public class Movement : HagletResettable
	{
		public delegate void ResultHandler(Unit unit, Result result);

		[Flags]
		public enum Result
		{
			None = 0,
			Pending = 0,
			Arrived = 1,
			Invalid = 2,
			NotReady = 6,
			Unreachable = 0xA,
			LackingAP = 0x12,
			Cancelled = 0x22,
			DestReserved = 0x42,
			DestTooFar = 0x82,
			InvalidDest = 0x102,
			Spotted = 0x202
		}

		public v2i destCoord;

		public NC.Path path;

		public ResultHandler handleResult;

		public Result result;

		public IfTooFar tooFarBehaviour;

		public OctDir? endDir;

		public int apAllowance;

		public UnitModel.AnimID? overrideAnimID;

		public float? overrideSpeed;

		public bool reservedDest;

		public bool orientateAlongPath;

		public bool ignoreOverwatch;

		public bool updateIdleOnCompletion;

		public bool ignoreUnitAtDestination;

		public bool isShortMovement;

		public bool shouldReserveTile;

		public bool ignoreTileTriggers;

		public bool ignoreShortMovementAnim;

		public bool forceWalk;

		public bool playArrivalBark;

		public TransitionAnim transitionAnim;

		public VaultAllowed vaultAllowed;

		public ConstArray<HagletResettable> pauseRoutines = new ConstArray<HagletResettable>(8u);

		public NC.Neighbors neighbors;

		public readonly NC.PathRequestComplete storePath;

		public NC.PathingCellValidator pathValidator;

		public readonly NC.NeighborRequestComplete storeNeighbors;

		public Movement(Unit unit)
			: base(unit.MovementRoutine(), unit.charData.charName + " Movement")
		{
			storePath = delegate(NC.Path p, Unit u)
			{
				path = p;
			};
			storeNeighbors = delegate(NC.Neighbors n, Unit u)
			{
				neighbors = n;
			};
		}

		protected Movement(BinaryReader reader)
			: base(reader)
		{
			storePath = delegate(NC.Path p, Unit u)
			{
				path = p;
			};
			storeNeighbors = delegate(NC.Neighbors n, Unit u)
			{
				neighbors = n;
			};
		}
	}

	[Serializable]
	public class Pickup : HagletResettable
	{
		public ItemStackMeta itemMeta;

		public int quantity;

		public bool canPickupItem;

		public TileObjectBase lootTile;

		public string sfxInteractionEventPath;

		public Pickup(Unit unit)
			: base(unit.PickUpItemRoutine(), unit.charData.charName + " Pickup")
		{
		}

		protected Pickup(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public class ShoveCoord
	{
		private readonly HagletResettable hr;

		private readonly NC.NeighborRequestComplete nrc;

		private readonly Unit unit;

		private v2i start;

		private bool mustMove;

		private int distance;

		public NC.Neighbors Neighbors { get; private set; }

		public Shove.ResultEnum? Result { get; private set; }

		public OctDir Direction { get; private set; }

		public v2i EndCoord { get; private set; }

		public bool HitObstruction { get; private set; }

		public ShoveCoord(Unit unit)
		{
			this.unit = unit;
			hr = new HagletResettable(HagletRoutine(), "Shove Coordinate Calculation");
			nrc = OnNeighborRequestComplete;
		}

		public HagletYieldTerm Run(v2i start, OctDir dir, bool mustMove, int distance)
		{
			this.start = start;
			this.mustMove = mustMove;
			this.distance = distance;
			Direction = dir;
			Result = null;
			HitObstruction = false;
			return Routine.Start(hr);
		}

		private IEnumerator<HagletYieldTerm> HagletRoutine()
		{
			uint shoveDirIdx = (uint)Direction;
			v2i dir = NC.IndexToDirection(shoveDirIdx);
			yield return Wait.While(NC.Inst.CalculateNeighbors(start, start + dir, 1u, unit, includeObstructedDiagonals: false, nrc));
			if (Neighbors.status == NC.PathStatus.Failed)
			{
				if (mustMove)
				{
					EndCoord = unit.map.GetNearestFreeCoord(start);
					Result = Shove.ResultEnum.UnitTeleported;
				}
				else
				{
					EndCoord = start;
					Result = Shove.ResultEnum.UnitShoved;
				}
				yield break;
			}
			v2i dirNew = Neighbors.coordsNeighbors[0] - start;
			Direction = (OctDir)NC.DirectionToIndex(dirNew);
			EndCoord = start + dir;
			for (int i = 1; i < distance; i++)
			{
				v2i v2i2 = EndCoord + dir;
				if (unit.map.GetCoordBlocked(EndCoord) || unit.map.GetCoordDirectionBlocked(EndCoord, shoveDirIdx) || (bool)GC.Inst.GetUnitAtCoord(v2i2))
				{
					HitObstruction = true;
					break;
				}
				EndCoord = v2i2;
			}
		}

		private void OnNeighborRequestComplete(NC.Neighbors neighbors, Unit unitAssociated)
		{
			Neighbors = neighbors;
		}
	}

	[Serializable]
	public class Shove : HagletResettable
	{
		public enum ResultEnum
		{
			InProgress,
			UnitTeleported,
			UnitHitObstruction,
			UnitShoved
		}

		[Serializable]
		public class Result
		{
			public ResultEnum value;
		}

		public OctDir direction;

		public int distance;

		public float? speed;

		public Result result;

		public Unit meleeAttacker;

		public Combat.HitType hitType;

		public bool mustMove;

		public Shove(Unit unit)
			: base(unit.ShoveRoutine(), unit.charData.charName + " Shove")
		{
		}

		protected Shove(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public class SnapToPosition : HagletResettable
	{
		public v2i destCoord;

		public OctDir? direction;

		public bool turnOnBlending;

		public bool activate;

		public bool delayForAnimation;

		public SnapToPosition(Unit unit)
			: base(unit.SnapToPositionRoutine(), unit.charData.charName + " Teleport")
		{
		}

		protected SnapToPosition(BinaryReader reader)
			: base(reader)
		{
		}
	}

	[Serializable]
	public class SwapMap : HagletResettable
	{
		public delegate void ResultHandler(Unit unit, Result result);

		public enum Result
		{
			None = 0,
			Completed = 2,
			Invalid = 4
		}

		public Result result;

		public ResultHandler handleResult;

		public TileActionSwapMap swapTile;

		public bool isSwapTileFromCurrentMap;

		public UnitTarget target;

		public bool isTeleport;

		public bool shouldFaceExit;

		public float? overrideSpeed;

		public SwapMap(Unit unit)
			: base(unit.SwapMapRoutine(), unit.charData.charName + " Swap Map")
		{
		}

		protected SwapMap(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public class Teleport : HagletResettable
	{
		public delegate void ResultHandler(Unit unit, bool success);

		public v2i destCoord;

		public Map destMap;

		public ResultHandler handleResult;

		public bool manuallyHandleShowing;

		public bool deactivateForTeleport;

		public bool lookAtDest;

		public bool ignoreAnimation;

		public OctDir? lookDirectionOnTeleportFinished;

		public UnitModel.AnimID? overrideStartAnim;

		public UnitModel.AnimID? overrideArriveAnim;

		public Teleport(Unit unit)
			: base(unit.TeleportRoutine(), unit.charData.charName + " Teleport")
		{
		}

		protected Teleport(BinaryReader reader)
			: base(reader)
		{
		}
	}

	[ReadOnly]
	public CharacterData charData;

	[ReadOnly]
	public ITeamController teamController;

	[ReadOnly]
	public readonly UnitTeam.Type teamType;

	[ReadOnly]
	public UnitModel unitModel;

	[ReadOnly]
	public WeaponAttributes mainWeapon;

	[ReadOnly]
	public WeaponAttributes secondaryWeapon;

	[ReadOnly]
	public Map map;

	[ReadOnly]
	public v2i coord;

	[ReadOnly]
	public UnitSpawnBase spawnPoint;

	[ReadOnly]
	public AIC.AIParameters aiParameters;

	private bool _isSleeping;

	private bool _isShown;

	private bool _isPeeking;

	private bool _isCloaked;

	private bool _isVaultAllowed;

	private bool _IsMovementDisabled;

	private bool _IsAttackingDisabled;

	private bool _willHideOnDeath = true;

	private bool _isAbilityUseDisabled;

	[HideInInspector]
	public string reasonForDisablingAbilities;

	private bool _IsTargetable = true;

	private bool awareOfWound;

	private bool shouldValidateSpawn = true;

	private HagletResettable processAnimationFlags;

	private Overwatch overwatch;

	private string cannotPickupWarning = "Item already held";

	private string cannotAttackWarning = "Carrying Item";

	[ReadOnly]
	public Unit decoyUnit;

	private static Color cloakedUnitColor = new Color(0.4f, 0.4f, 1f, 0.4f);

	private static Color cloakedEnemyMPColor = new Color(1f, 1f, 1f, 0f);

	private Color hologramColor;

	private AnimFloat hologramAnim = new AnimFloat(0f);

	public const float kHologramAnimTime = 0.5f;

	private const float hologramAnimTimeMultiplayer = 0.2f;

	private const float hologramAnimTimeDeath = 1f;

	private const float hologramAnimTimeLeap = 0.8f;

	private HagletTrigger _OnShowComplete;

	private HagletTrigger _OnHideComplete;

	private HagletResettable death;

	public AbilityList abilities;

	private string _name;

	private const float kLevelUpPtcDur = 1f;

	private float levelUpPtcTime;

	[HideInInspector]
	public UIUnitStatusBar statusBar;

	[HideInInspector]
	public UIUnitPopupBar popupBar;

	[Serializer.Exclude]
	private BehaviourCache behaviourCache = new BehaviourCache();

	private Collider unitCollider;

	private bool _updateIdleDirty;

	private bool updateIdleOnActive = true;

	private HologramAnim contextOnActive;

	private string[] barkStrings;

	[NonSerialized]
	public HagletTrigger OnCommandedToMove = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnDeathStart = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnDeathComplete = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnReachedMoveTarget = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnitTurnEnd = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnitSustainedDamage = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnitSustainedCriticalDamage = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnitSwitchedTeam = new HagletTrigger();

	public Action OnUnitDeathComplete;

	public Action OnUnitFocusEnter;

	public Action OnUnitFocusExit;

	public Action OnUnitReset;

	private int _hp;

	private int _ap;

	private static readonly UnitModel.AnimID[] dodgeDirectionLUT = new UnitModel.AnimID[8]
	{
		UnitModel.AnimID.CombatDodgeLeft,
		UnitModel.AnimID.CombatDodgeRight,
		UnitModel.AnimID.CombatDodgeLeft,
		UnitModel.AnimID.CombatDodgeLeft,
		UnitModel.AnimID.CombatDodgeRight,
		UnitModel.AnimID.CombatDodgeRight,
		UnitModel.AnimID.CombatDodgeRight,
		UnitModel.AnimID.CombatDodgeLeft
	};

	private SetCoordResettable setCoordResettable;

	private ConstArray<PatrolPoint> patrolPoints = new ConstArray<PatrolPoint>(16u);

	private uint activePatrolPointIndex;

	public const int maxLineOfSight = 8;

	private v2i[] observedCoords = new v2i[9];

	public ShowHide showHide;

	[ReadOnly]
	private int _levelInitial;

	public const int kMaxTargets = 8;

	public const int kMaxAttacks = 8;

	public const int kMaxBullets = 8;

	public HagletTrigger OnFinishedAttack = new HagletTrigger();

	private Attack attack;

	private HagletResettable fakeAttackHaglet;

	private FakeAttack fakeAttack;

	private Movement movement;

	private HagletResettable onUnitEnterCoord;

	private AnimFloat movementAccelerator = new AnimFloat(1f);

	private Func<Unit, bool> isBlockingUnit;

	private Vector3 stepOutAnimStartLocalPos;

	private Vector3 stepOutAnimEndLocalPos;

	private v2i preStepOutCoord;

	private v2i steppedOutCoord;

	private Unit postStepOutTarget;

	private HagletResettable stepOut;

	public Pickup pickup;

	private bool HACK_messageQueued;

	private Shove shove;

	private SnapToPosition snapToPosition;

	private SwapMap swapMap;

	private Teleport teleport;

	public uint teamMask => (uint)(1 << (int)teamType);

	public GameObject[] modelRig { get; private set; }

	public WeaponModel propModel { get; private set; }

	public string generatedID { get; private set; }

	public bool WillHideOnDeath
	{
		get
		{
			return _willHideOnDeath;
		}
		set
		{
			_willHideOnDeath = value;
		}
	}

	public bool IsAttackingDisabled
	{
		get
		{
			if (_IsAttackingDisabled)
			{
				return true;
			}
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				if (item.GetUnitAttackingDisabled(this))
				{
					return true;
				}
			}
			return false;
		}
		set
		{
			_IsAttackingDisabled = value;
		}
	}

	public bool IsAbilityUseDisabled
	{
		get
		{
			return _isAbilityUseDisabled;
		}
		set
		{
			_isAbilityUseDisabled = value;
		}
	}

	public bool IsMovementDisabled
	{
		get
		{
			if (_IsMovementDisabled)
			{
				return true;
			}
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				if (item.GetUnitMovementDisabled(this))
				{
					return true;
				}
			}
			return false;
		}
		set
		{
			_IsMovementDisabled = value;
			if (GC.Inst.GetActiveUnit() == this)
			{
				ShowMovementArea();
			}
		}
	}

	public bool PreferWalk { get; set; }

	public new Transform transform
	{
		set
		{
		}
	}

	public bool IsTargetable
	{
		get
		{
			if (!_IsTargetable)
			{
				return false;
			}
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				if (!item.GetUnitTargetable(this))
				{
					return false;
				}
			}
			return !IsCloaked;
		}
		set
		{
			_IsTargetable = value;
		}
	}

	public bool IsMelee
	{
		get
		{
			if ((bool)mainWeapon)
			{
				return mainWeapon.IsMelee;
			}
			return false;
		}
	}

	public bool IsShown => _isShown;

	public bool IsPeeking => _isPeeking;

	public bool IsCloaked => _isCloaked;

	public bool IsDying { get; private set; }

	public bool IsVaultAllowed
	{
		get
		{
			return _isVaultAllowed && GC.Inst.IsInTurnMode();
		}
		set
		{
			_isVaultAllowed = value;
		}
	}

	public bool IsActing => IsAttacking || (bool)moving || IsDying || IsTeleporting;

	public bool IsSleeping
	{
		get
		{
			return _isSleeping;
		}
		set
		{
			if (value == _isSleeping)
			{
				return;
			}
			_isSleeping = value;
			if (Singleton<MC>.Inst.GetActiveMap() != map || !IsAlive())
			{
				return;
			}
			if (!_isSleeping)
			{
				if (UnitModel.GetAnimIDByName(unitModel.animName) != UnitModel.AnimID.WakeUp)
				{
					unitModel.Play(UnitModel.AnimID.WakeUp);
				}
				return;
			}
			SetTeamType(UnitTeam.Type.NPC);
			UnitModel.AnimID animIDByName = UnitModel.GetAnimIDByName(unitModel.animName);
			if (animIDByName != UnitModel.AnimID.FallAsleep && animIDByName != UnitModel.AnimID.Sleeping)
			{
				unitModel.Play(UnitModel.AnimID.FallAsleep);
			}
		}
	}

	public bool IsMidGroundPound => abilities.AbilityGetByType<Ability_Ground_Pound>(this)?.IsJumping ?? false;

	public bool IsInOverwatch => overwatch.active;

	public Item DropItemOnDeath { get; private set; }

	public TileActionGiveLoot HeldItem { get; private set; }

	public bool HACK_isDecoyUnit { get; set; }

	public WeaponAttributes RangedWeapon => mainWeapon.IsMelee ? secondaryWeapon : mainWeapon;

	public WeaponAttributes MeleeWeapon => (!mainWeapon.IsMelee) ? secondaryWeapon : mainWeapon;

	public HagletEvent OnShowComplete => _OnShowComplete;

	public HagletEvent OnHideComplete => _OnShowComplete;

	public Area Area { get; private set; }

	public new string name
	{
		get
		{
			return _name;
		}
		set
		{
			base.name = (_name = value);
		}
	}

	public bool colliderEnabled
	{
		set
		{
			unitCollider.enabled = value;
		}
	}

	private UnitAnimFuncs AnimFuncs => unitModel.AnimFuncs;

	private bool updateIdleDirty
	{
		get
		{
			return _updateIdleDirty;
		}
		set
		{
			_updateIdleDirty = value;
			if (_updateIdleDirty)
			{
				SetAnimationFlagDirty();
			}
		}
	}

	public v2i spawnCoords { get; private set; }

	public bool HasNeighboursCombat
	{
		get
		{
			ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
			for (int i = 0; i < unitsActive.Length; i++)
			{
				Unit unit = unitsActive[i];
				if (!(unit.name == name) && unit.statusBar.IsShown && v2i.IsNeighbour(coord, unit.coord))
				{
					return true;
				}
			}
			return false;
		}
	}

	public int HP
	{
		get
		{
			return _hp;
		}
		set
		{
			_hp = value;
		}
	}

	public int AP
	{
		get
		{
			return _ap;
		}
		set
		{
			_ap = value;
		}
	}

	public int ClassID => (int)charData.Class;

	public int Level
	{
		get
		{
			if (Party.Inst.TryGetUnlockedPartyMember(charData, out var partyMember) && partyMember != null)
			{
				return partyMember.Level;
			}
			return _levelInitial;
		}
	}

	public HagletResettable attackBeginPhase { get; private set; }

	public bool IsAttacking => attack.running;

	public HagletCondition attacking => attack.running;

	public ConstArray<Unit> AttackTargets => attack.targets;

	public bool IsPerformingAbilityAttack => attack.isAbilityAttack;

	public HagletCondition moving => movement.running;

	public HagletEvent movementStopped => movement.stopped;

	public bool movementHasPath => movement.path != null;

	private bool movementCancelled => movement.result == Movement.Result.Cancelled;

	private bool movementShouldCancel => movementCancelled && GC.Inst.GetUnitAtCoord(coord, isBlockingUnit) == null;

	public HagletEvent StepOutCompleted => stepOut.completed;

	public bool IsSteppedOut { get; private set; }

	public HagletCondition pickingUp => pickup.running;

	public ShoveCoord ShoveCoordCalc { get; private set; }

	public bool IsShoving => shove.running;

	public HagletCondition shoving => shove.running;

	public HagletCondition snappingToPosition => snapToPosition.running;

	public bool IsSnappingToPosition => snapToPosition.running;

	public HagletCondition swappingMap => swapMap.running;

	public HagletCondition teleporting => teleport.running;

	public bool IsTeleporting => teleport.running;

	public bool IsAlive()
	{
		return HP > 0;
	}

	public bool IsWounded()
	{
		return HP != GetHPMax() && IsAlive() && awareOfWound;
	}

	public bool IsLeaderOnTeam()
	{
		return GetTeam().GetTeamLeader() == this;
	}

	public bool IsActiveOnMap()
	{
		return base.gameObject.activeInHierarchy && IsShown && IsAlive();
	}

	public bool IsPartyMember(PartyMemberID partyMember)
	{
		return charData.partyMemberID == partyMember;
	}

	public bool IsHoldingItem()
	{
		return HeldItem != null;
	}

	private float GetHologramAnimTime(HologramAnim context)
	{
		return context switch
		{
			HologramAnim.UNIT_DEATH => 1f, 
			HologramAnim.UNIT_LEAP => 0.8f, 
			_ => (!GC.Inst.IsInMultiplayer()) ? 0.5f : 0.2f, 
		};
	}

	private void UpdateHologramMaterials()
	{
		hologramColor = hologramColor.RepA(hologramAnim.Value);
		unitModel.SetHologramColor(hologramColor);
	}

	public void ToggleAnimators(bool value)
	{
		behaviourCache.SetEnabledBehaviours<KubrickAnimator>(value);
		behaviourCache.SetEnabledBehaviours<Animation>(value);
	}

	public static void _ForceAddAbility(Unit unit, string abilityMetaResourcePath)
	{
		AbilityMeta abilityMeta = AEResources.LoadFirstResource<AbilityMeta>(abilityMetaResourcePath);
		if (abilityMeta != null)
		{
			unit.abilities.Add(abilityMeta.GetImplementationType(), null, isUpgraded: false);
		}
	}

	private static GameObject SpawnModelRig(GameObject modelRigPrefab, Unit unitTarget)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(modelRigPrefab);
		gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		gameObject.transform.SetParent(unitTarget._GetTransform(), worldPositionStays: false);
		gameObject.name = "modelRig";
		return gameObject;
	}

	public static Unit Spawn(CharacterData data, string genID, int wave, Map map, v2i coord, Quaternion rotation, UnitTeam.Type team, Transform parent, int levelInitial, bool useDebugAbilities, bool makeActiveOnSpawn = true, bool hasAbilities = true, Item dropItemOnDeath = Item.None, AIC.AIParameters aiParamsOverride = null, bool shouldValidateSpawn = true)
	{
		string text = ((wave != 0) ? $"{data.DisplayName} {wave} ({genID})" : $"{data.DisplayName} ({genID})");
		Unit original = AEResources.LoadFirstResource<Unit>("Gameplay/P_Unit");
		Unit unit = UnityEngine.Object.Instantiate(original);
		unit.gameObject.SetActive(makeActiveOnSpawn);
		unit.charData = data;
		unit.name = text;
		unit.generatedID = genID;
		unit.charData.OnSpawn(unit);
		unit.IsTargetable = true;
		unit.DropItemOnDeath = dropItemOnDeath;
		unit.shouldValidateSpawn = shouldValidateSpawn;
		unit._GetTransform().SetParent(parent, worldPositionStays: false);
		unit.modelRig = new GameObject[(!unit.charData.modelRigVariant) ? 1 : 2];
		unit.modelRig[0] = SpawnModelRig(unit.charData.modelRig, unit);
		if ((bool)unit.charData.modelRigVariant)
		{
			unit.modelRig[1] = SpawnModelRig(unit.charData.modelRigVariant, unit);
		}
		if (aiParamsOverride != null)
		{
			unit.aiParameters = aiParamsOverride;
		}
		unit.OnSpawn(team, map, coord, levelInitial);
		unit.barkStrings = new string[38];
		for (int i = 0; i < unit.barkStrings.Length; i++)
		{
			string text2 = unit.charData.barksFolder + CharacterData.LUT_characterBarkStrings[i] + Localisation.RetrieveSpecific(unit.charData.DisplayName, Localisation.Language.ENGLISH).ToLower();
			if (AC.Inst.sys.lookupID(text2, out var guid) == RESULT.OK)
			{
				unit.barkStrings[i] = text2;
				continue;
			}
			text2 = unit.charData.barksFolder + CharacterData.LUT_characterBarkStrings[i] + unit.charData.charName.ToLower();
			if (AC.Inst.sys.lookupID(text2, out guid) == RESULT.OK)
			{
				unit.barkStrings[i] = text2;
			}
		}
		UnitModel component = unit.GetComponent<UnitModel>();
		component.renderers = component.GetComponentsInChildren<Renderer>();
		component.OnSpawn(rotation, unit.mainWeapon, unit.secondaryWeapon, unit.charData.propWeaponAttributes);
		unit.unitModel = component;
		UnitAnimFuncs[] componentsInChildren = unit.GetComponentsInChildren<UnitAnimFuncs>(includeInactive: true);
		foreach (UnitAnimFuncs unitAnimFuncs in componentsInChildren)
		{
			unitAnimFuncs.OnSpawn();
		}
		SkinnedMeshRenderer[] componentsInChildren2 = unit.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		SkinnedMeshRenderer[] array = componentsInChildren2;
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
		{
			skinnedMeshRenderer.quality = data.skinQuality;
		}
		SkinnedMeshRenderer[] array2 = componentsInChildren2;
		foreach (SkinnedMeshRenderer skinned in array2)
		{
			UnitModel.MergeAndAtlasAttachments(skinned);
		}
		component.renderers = component.GetComponentsInChildren<Renderer>();
		unit.behaviourCache.Build(unit.gameObject, Map.behaviourCuller);
		if (hasAbilities)
		{
			switch (unit.charData.partyMemberID)
			{
			case PartyMemberID.Margot:
				_ForceAddAbility(unit, "Abilities/Ability_Throwing_Knives");
				break;
			case PartyMemberID.Ambrosia:
				_ForceAddAbility(unit, "Abilities/Ability_Concussive_Shot");
				break;
			case PartyMemberID.Noot:
				_ForceAddAbility(unit, "Abilities/Ability_Pea_Shooter");
				break;
			}
			if (unit.charData.Class == CharacterClass.Triggerman)
			{
				_ForceAddAbility(unit, "Abilities/Ability_Triggerman_Attack");
			}
			if (unit.charData.partyMemberID == PartyMemberID.Ashley)
			{
				_ForceAddAbility(unit, "Abilities/Ability_Hunker_Down");
				_ForceAddAbility(unit, "Abilities/Ability_Multi_Shot");
				_ForceAddAbility(unit, "Abilities/Ability_Vault");
				_ForceAddAbility(unit, "Abilities/Ability_Overwatch");
			}
			if (unit.charData.partyMemberID == PartyMemberID.Willa && SaveData.data.HACK_hasStaticSkin)
			{
				_ForceAddAbility(unit, "Abilities/Ability_Static_Skin");
			}
			Party.Inst.TryGetUnlockedPartyMember(unit.charData, out var partyMember);
			useDebugAbilities = false;
			if (partyMember == null || useDebugAbilities)
			{
				if (useDebugAbilities)
				{
					AbilityMeta[] dEBUG_abilities = unit.charData.DEBUG_abilities;
					if (dEBUG_abilities != null && dEBUG_abilities.Length > 0)
					{
						for (int m = 0; m < dEBUG_abilities.Length; m++)
						{
							unit.AddAbilityOnSpawn(dEBUG_abilities[m], unit.charData.DEBUG_augmentAllAbilities);
						}
					}
				}
				else
				{
					List<CharacterData.AbilityMetaUpgraded> loadedAbilities = unit.charData.loadedAbilities;
					for (int n = 0; n < loadedAbilities.Count; n++)
					{
						if (loadedAbilities[n].meta == null)
						{
							continue;
						}
						if (!unit.charData.environmental)
						{
							int num = ((!loadedAbilities[n].forceOverride) ? CharacterStats.GetLevelRequired(unit.charData.Class, loadedAbilities[n].meta.GetImplementationType()) : loadedAbilities[n].overrideLevel);
							if (levelInitial < num || num == -1)
							{
								continue;
							}
						}
						unit.AddAbilityOnSpawn(loadedAbilities[n].meta, loadedAbilities[n].upgraded);
					}
				}
			}
			else
			{
				for (int num2 = 0; num2 < partyMember.GetMaxNumberOfAbilities(); num2++)
				{
					PartyAbility abilityAtIndex = partyMember.GetAbilityAtIndex(num2);
					if (abilityAtIndex != null && !unit.abilities.Exists(abilityAtIndex.ability))
					{
						unit.abilities.Add(abilityAtIndex.ability, null, abilityAtIndex.upgraded);
					}
				}
			}
		}
		LR.InitialiseUIHierarchy(unit._GetTransform());
		return unit;
	}

	void Serializer.ISelfComposer.Decompose(Serializer.IMemberSink members)
	{
	}

	void Serializer.ISelfComposer.Recompose(Serializer.IMemberSource members)
	{
		SkinnedMeshRenderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinned in componentsInChildren)
		{
			UnitModel.MergeAndAtlasAttachments(skinned);
		}
		unitModel.renderers = unitModel.GetComponentsInChildren<Renderer>();
		LR.InitialiseUIHierarchy(_GetTransform());
		behaviourCache.Build(base.gameObject, Map.behaviourCuller);
	}

	private void AddAbilityOnSpawn(AbilityMeta meta, bool isUpgraded)
	{
		Type implementationType = meta.GetImplementationType();
		AbilityImplBase abilityImplBase = abilities.Add(implementationType, null, isUpgraded);
	}

	public void SetVariant(string variation)
	{
		SaveData.data.SetCharacterVariation(charData.charName, variation);
		unitModel.useModelRigVariant = charData.GetUseAlternativeModel();
	}

	public void SpawnDecoyUnitIfNonExistant()
	{
		if (!(decoyUnit != null))
		{
			decoyUnit = Spawn(charData, "Decoy " + generatedID, 0, map, coord, GetRotationWS(), teamType, _GetTransform().parent, 0, useDebugAbilities: false, makeActiveOnSpawn: false, hasAbilities: false);
			GC.Inst.GetUnitsAllInWorld().Add(decoyUnit);
			decoyUnit._SetLevel(Level);
			decoyUnit.HACK_isDecoyUnit = true;
			decoyUnit.KillIfDecoyUnit();
		}
	}

	public void KillIfDecoyUnit()
	{
		if (HACK_isDecoyUnit)
		{
			IsAttackingDisabled = true;
			HP = 0;
			GetTeam().RemoveAliveMember(this);
			base.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (levelUpPtcTime < 1f && popupBar.clear)
		{
			if (levelUpPtcTime == 0f)
			{
				ParticlePrefab particlePrefab = PSC.Inst.Play(ParticleTypes.LevelUp, map, coord);
			}
			if (!((levelUpPtcTime += Time.deltaTime) >= 1f))
			{
			}
		}
	}

	public void HideStatusBar()
	{
		statusBar.HideAll();
	}

	public void ShowStatusBar()
	{
		if (GetTeamType() != UnitTeam.Type.NPC && (!charData.environmental || teamType == UnitTeam.Type.Player))
		{
			statusBar.ShowStatusBar();
		}
	}

	public void UpdateIdleAnim()
	{
		if (MR.Inst.IsSkipping())
		{
			_UpdateIdleAnim();
		}
		else
		{
			updateIdleDirty = true;
		}
	}

	private void _UpdateIdleAnim()
	{
		if (!IsAlive() || movementHasPath)
		{
			return;
		}
		OctDir dir;
		if (IsSleeping)
		{
			unitModel.Play(UnitModel.AnimID.Sleeping);
		}
		else if (!GC.Inst.IsInTurnMode() && UnitModel.GetAnimIDByName(unitModel.animName) == UnitModel.AnimID.CombatIdle)
		{
			if (!unitModel.IsAnimOverriden(UnitModel.AnimID.DefaultIdle))
			{
				unitModel.PlayWithTransition(UnitModel.AnimID.TransCIdleToDIdle, UnitModel.AnimID.DefaultIdle);
			}
			else
			{
				unitModel.Play(UnitModel.AnimID.DefaultIdle);
			}
		}
		else if (!GC.Inst.IsInTurnMode() && UnitModel.GetAnimIDByName(unitModel.animName) == UnitModel.AnimID.CombatCrouch)
		{
			if (!unitModel.IsAnimOverriden(UnitModel.AnimID.DefaultIdle))
			{
				unitModel.PlayWithTransition(UnitModel.AnimID.TransCCrouchToCIdle, UnitModel.AnimID.TransCIdleToDIdle, null, updateIdleOnComplete: true);
			}
			else
			{
				unitModel.Play(UnitModel.AnimID.DefaultIdle);
			}
		}
		else if (!GC.Inst.IsInTurnMode())
		{
			unitModel.Play(UnitModel.AnimID.DefaultIdle);
		}
		else if (GC.Inst.IsInStealthMode() && teamType == UnitTeam.Type.Enemy)
		{
			unitModel.Play(UnitModel.AnimID.DefaultIdle);
		}
		else if (unitModel.HasAnim(UnitModel.AnimID.CombatCrouch) && map.GetAdjacentCoverDirection(coord, out dir) && GC.Inst.GetActiveUnit() != this && GC.Inst.IsInTurnMode())
		{
			if (!unitModel.crouched)
			{
				if (!unitModel.IsAnimOverriden(UnitModel.AnimID.CombatCrouch))
				{
					unitModel.PlayWithTransition(UnitModel.AnimID.TransCIdleToCCrouch, UnitModel.AnimID.CombatCrouch, unitModel.AnimCompTransform.position + dir.ToV3XZ());
				}
				else
				{
					unitModel.Play(UnitModel.AnimID.CombatCrouch);
				}
			}
			else if (!unitModel.IsAnimOverriden(UnitModel.AnimID.CombatCrouch))
			{
				unitModel.LookAtDirectionLS(dir.ToV3XZ());
				unitModel.Play(UnitModel.AnimID.CombatCrouch);
			}
		}
		else if (unitModel.crouched)
		{
			if (!unitModel.IsAnimOverriden(UnitModel.AnimID.CombatIdle))
			{
				unitModel.PlayWithTransition(UnitModel.AnimID.TransCCrouchToCIdle, UnitModel.AnimID.CombatIdle);
			}
			else
			{
				unitModel.Play(UnitModel.AnimID.CombatIdle);
			}
		}
		else if (GC.Inst.IsInTurnMode() && UnitModel.GetAnimIDByName(unitModel.animName) == UnitModel.AnimID.DefaultIdle)
		{
			if (!unitModel.IsAnimOverriden(UnitModel.AnimID.CombatIdle))
			{
				unitModel.PlayWithTransition(UnitModel.AnimID.TransDIdleToCIdle, UnitModel.AnimID.CombatIdle);
			}
			else
			{
				unitModel.Play(UnitModel.AnimID.CombatIdle);
			}
		}
		else
		{
			unitModel.Play(UnitModel.AnimID.CombatIdle);
		}
	}

	public void SetAnimationFlagDirty()
	{
		if (MR.Inst.IsSkipping())
		{
			if ((bool)processAnimationFlags.running || processAnimationFlags.markedToRunBy != null)
			{
				MR.Inst.Host.Pause(processAnimationFlags);
			}
			processAnimationFlags.Reset();
			MR.Inst.Host.StartTopLevel(processAnimationFlags);
		}
		else if (!processAnimationFlags.running && processAnimationFlags.markedToRunBy == null)
		{
			MR.Inst.Host.StartTopLevel(processAnimationFlags);
		}
	}

	private IEnumerator<HagletYieldTerm> ProcessAnimationFlagsRoutine()
	{
		yield return Wait.ForSteps(1uL);
		if (updateIdleDirty && !unitModel.PlayIsDirty)
		{
			_UpdateIdleAnim();
		}
		updateIdleDirty = false;
		unitModel.OnLateUpdate();
	}

	private HagletEvent ModelPlayAnim(UnitModel.AnimID animId, Vector3? lookAt = null)
	{
		return unitModel.Play(animId, lookAt);
	}

	private void SetTeamInitial(UnitTeam.Type teamType)
	{
		UnitTeam teamOfType = GC.Inst.GetTeamOfType(teamType);
		teamOfType.AddMember(this);
		hologramColor = UnitTeam.Colors[(int)teamType];
		typeof(Unit).GetField("teamType", BindingFlags.Instance | BindingFlags.Public).SetValue(this, teamType);
	}

	public void SetTeamType(UnitTeam.Type teamType)
	{
		UnitTeam team = GetTeam();
		team.RemoveMember(this);
		if (teamType != team.type)
		{
			UnitTeam teamOfType = GC.Inst.GetTeamOfType(teamType);
			team.abilities._MoveAllAbilities(teamOfType.abilities, this);
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				item.OnUnitChangedTeam(this, teamType);
			}
		}
		SetTeamInitial(teamType);
		if (GC.Inst.IsInTurnMode())
		{
			if (teamType == UnitTeam.Type.NPC)
			{
				HideStatusBar();
			}
			else
			{
				ShowStatusBar();
			}
		}
		statusBar.SetTeamColor(GetTeamIndex());
		OnUnitSwitchedTeam.Trigger();
	}

	public UnitTeam.Type GetTeamType()
	{
		return teamType;
	}

	public uint GetTeamIndex()
	{
		return (uint)teamType;
	}

	public string GetTeamName()
	{
		return UnitTeam.Names[(int)teamType];
	}

	public UnitTeam GetTeam()
	{
		return GC.Inst.GetTeamOfType(teamType);
	}

	public void OnHighlightEnter()
	{
		AC.Inst.PlayOneShot2D("event:/sfx/ui/character hover");
		if (GC.Inst.GetActiveTeam() != null)
		{
			Unit teamLeader = GC.Inst.GetActiveTeam().GetTeamLeader();
			if (teamLeader != null && teamLeader.teamType != teamType && OnUnitFocusEnter != null)
			{
				OnUnitFocusEnter();
			}
		}
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUserFocusedOnUnit(this);
		}
	}

	public void OnHighlightExit()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUserUnFocusedOnUnit(this);
		}
		if (OnUnitFocusEnter != null)
		{
			OnUnitFocusExit();
		}
	}

	public void OnSelectEnter()
	{
		if (GC.Inst.GetActiveTeam() != null)
		{
			ShowMovementArea();
		}
		PSC.Inst.Play(ParticleTypes.Selection, map, coord);
	}

	public void OnSelectExit()
	{
		statusBar.PulseAP(0);
	}

	public void OnEnterTile()
	{
	}

	public void OnExitTile()
	{
		OnUnitExitCoord();
	}

	public void ShowMovementArea()
	{
		if (GC.Inst.IsInTurnMode() && GC.Inst.GetActiveTeam().type == teamType && IsLeaderOnTeam())
		{
			if (AP > 0)
			{
				Area.Update(map, coord, GetMovementDistancePerTurn(), newIncludePathing: true, showArea: true, IsVaultAllowed);
			}
			else
			{
				Area.Hide();
			}
		}
	}

	public void HideMovementArea()
	{
		Area.Hide();
	}

	public void OnEnterPeek()
	{
		_isPeeking = true;
	}

	public void OnExitPeek()
	{
		_isPeeking = false;
	}

	public void OnEnterCloak()
	{
		_isCloaked = true;
		IsTargetable = false;
		unitModel.Tint(cloakedUnitColor);
		if (teamType == UnitTeam.Type.Enemy)
		{
			Hide(makeInactive: false);
		}
	}

	public void OnExitCloak()
	{
		unitModel.RemoveTint();
		IsTargetable = true;
		_isCloaked = false;
		if (teamType == UnitTeam.Type.Enemy)
		{
			Show();
			if (GC.Inst.IsInCombatMode())
			{
				ShowStatusBar();
			}
		}
	}

	public void OnEnterOverwatch(float range, bool closeRange = false)
	{
		overwatch.range = range;
		overwatch.isCloseRange = closeRange;
		overwatch.active = true;
	}

	public void OnExitOverwatch()
	{
		overwatch.active = false;
	}

	public void OnDistractionHeard(v2i distractionCoord)
	{
		map.VFXTiles.UnitDistractedStealthShow(this);
		unitModel.StartLookAtTarget(map.CoordToWorldPos(distractionCoord), null, 0.1f);
	}

	public void OnDistractionUnitNotFound()
	{
		unitModel.Play(UnitModel.AnimID.DefaultConfusion);
		map.VFXTiles.UnitDistractionUnitNotFoundShow(this);
	}

	public void OnTurnStart()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item._OnAbilityTurnBegin();
			item.OnUnitTurnBegin(this);
		}
		if (IsCloaked && GC.Inst.IsInMultiplayer())
		{
			unitModel.Tint(cloakedUnitColor);
		}
	}

	public void OnTurnEnd(bool isCombatEnd)
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item._OnAbilityTurnEnd();
			item.OnUnitTurnEnd(this, isCombatEnd);
		}
		if (IsCloaked && GC.Inst.IsInMultiplayer())
		{
			unitModel.Tint(cloakedEnemyMPColor);
		}
		OnUnitTurnEnd.Trigger();
	}

	public void OnTurnModeEnter()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitTurnModeBegin(this);
		}
	}

	public void OnTurnModeEnd()
	{
		OnExitOverwatch();
	}

	public void OnCombatModeEnd()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item._ResetCoolDown();
			item.OnUnitCombatModeEnd(this);
		}
		if (IsCloaked)
		{
			OnExitCloak();
		}
		abilities.RemoveAllProxies();
	}

	public void OnStealthModeBegin()
	{
		if (teamType == UnitTeam.Type.Enemy)
		{
			CreateNewObserveCounts();
			awareOfWound = false;
		}
	}

	public void OnEnable()
	{
		if (map != null && map.IsUnitsVisible)
		{
			Show(updateIdleAnim: updateIdleOnActive, OnComplete: null, context: contextOnActive);
			updateIdleOnActive = true;
			contextOnActive = HologramAnim.DEFAULT;
			OnEnterTile();
		}
	}

	private void OnDisable()
	{
		if (map != null)
		{
			OnExitTile();
			Hide(makeInactive: true, HologramAnim.IMMEDIATE);
		}
	}

	public void OnSpawn(UnitTeam.Type teamType, Map mapIn, v2i coordIn, int levelInitial)
	{
		movement = new Movement(this);
		teleport = new Teleport(this);
		snapToPosition = new SnapToPosition(this);
		ShoveCoordCalc = new ShoveCoord(this);
		shove = new Shove(this);
		attack = new Attack(this);
		fakeAttackHaglet = new HagletResettable(FakeAttackRoutine(), charData.DisplayName + " Fake Attack");
		stepOut = new HagletResettable(StepOutRoutine(), charData.DisplayName + " Step Out");
		swapMap = new SwapMap(this);
		showHide = new ShowHide(this);
		death = new HagletResettable(Death());
		pickup = new Pickup(this);
		abilities = new AbilityList(this);
		setCoordResettable = new SetCoordResettable(this);
		attackBeginPhase = new HagletResettable(AttackBeginPhase(), "Beginning of " + charData.charName + "'s attack");
		onUnitEnterCoord = new HagletResettable(OnUnitEnterCoordRoutine(), charData.charName + " Enter Coord");
		processAnimationFlags = new HagletResettable(ProcessAnimationFlagsRoutine(), charData.charName + " process animation flags", HagletStepTime.LateUpdate);
		isBlockingUnit = IsBlockingUnit;
		Area = new Area();
		statusBar = GetComponentInChildren<UIUnitStatusBar>();
		popupBar = GetComponentInChildren<UIUnitPopupBar>();
		unitCollider = GetComponentInChildren<Collider>();
		_OnShowComplete = new HagletTrigger(5);
		_OnHideComplete = new HagletTrigger(5);
		_levelInitial = levelInitial;
		map = mapIn;
		WarpToLocalMapPosition(map.CoordToLocalPos(coordIn));
		SetTeamInitial(teamType);
		HP = GetHPMax();
		AP = GetAPMax();
		levelUpPtcTime = 1f;
		spawnCoords = coord;
		if (base.isActiveAndEnabled)
		{
			OnEnterTile();
		}
	}

	public void OnDespawn()
	{
		map = null;
	}

	public void OnPauseStateChanged(bool paused)
	{
		unitModel.SetPaused(paused);
		if (paused)
		{
			HideStatusBar();
		}
		else if (GC.Inst.IsInTurnMode())
		{
			ShowStatusBar();
		}
	}

	public void SetActiveWithAnimation(string anim, bool updateIdleOnComplete = false)
	{
		UnitModel obj = unitModel;
		bool updateIdleOnComplete2 = updateIdleOnComplete;
		obj.Play(anim, looping: false, crouched: false, interacting: false, updateIdleOnComplete2);
		StartSnapToPosition(coord, null, waitForModelToSnap: true, turnOnBlending: true, activate: true);
	}

	public int GetHPMax()
	{
		int num = charData.HPMax(Level);
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetUnitHPMaxModifier(this);
		}
		return num;
	}

	public void APRefill()
	{
		if (GC.Inst.IsInStealthMode() && teamType == UnitTeam.Type.Enemy)
		{
			AP = 1;
		}
		else
		{
			AP = GetAPMax();
		}
	}

	public int GetAPMax()
	{
		int num = charData.APMax(Level);
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetUnitAPMaxModifier(this);
		}
		return Mathf.Clamp(num, 0, 4);
	}

	public void APDecrement(int value, bool notifyAbilites = true)
	{
		if (value == 0)
		{
			return;
		}
		if (notifyAbilites)
		{
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				value = item.OnUnitAPWillChange(this, value);
			}
		}
		AP = Mathf.Clamp(AP - value, 0, GetAPMax());
		if (Math.Abs(value) > 0)
		{
			statusBar.OnAPChanged();
		}
	}

	public void HPRefill()
	{
		HP = GetHPMax();
	}

	public bool HPDecrement(int amount, Unit attacker = null, WeaponAttributes weapon = null, Combat.HitType hitType = Combat.HitType.Hit, bool notifyAbilites = true, bool shouldDecloak = true)
	{
		if ((bool)death.running)
		{
			return false;
		}
		MusicController.Inst.SetIntensity(0.2f);
		if ((bool)attacker && amount > 0 && notifyAbilites)
		{
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				amount = item.OnUnitWillBeDamaged(this, amount, attacker, hitType);
			}
		}
		HP = Mathf.Clamp(HP - amount, 0, GetHPMax());
		if ((bool)attacker && amount > 0 && notifyAbilites)
		{
			foreach (AbilityImplBase item2 in abilities.OnUnitAndTeam())
			{
				item2.OnUnitSustainedDamage(this, attacker, amount, weapon);
			}
		}
		if (amount > 0)
		{
			if (shouldDecloak && IsCloaked)
			{
				OnExitCloak();
			}
			OnUnitSustainedDamage.Trigger();
			if (hitType == Combat.HitType.HitCritical)
			{
				OnUnitSustainedCriticalDamage.Trigger();
			}
		}
		else if (amount < 0 && notifyAbilites)
		{
			foreach (AbilityImplBase item3 in abilities.OnUnitAndTeam())
			{
				item3.OnUnitRestoredHealth(this);
			}
		}
		if (HP == 0)
		{
			if (!IsDying)
			{
				Kill();
			}
			return false;
		}
		return true;
	}

	public int GetDodgeChance(Unit attacker)
	{
		int num = CharacterStats.LUT_DodgeChance[ClassID, Level];
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetUnitDodgeChanceModifier(this, attacker, attacker.attack.isReactionAttack, attacker.IsAttacking);
		}
		return Mathf.Clamp(num, 0, 100);
	}

	public int GetDodgeSize(Unit attacker)
	{
		int num = CharacterStats.LUT_DodgeSize[ClassID, Level];
		int num2 = num;
		float num3 = 0f;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num3 += item.GetUnitDodgeSizeModifier(this, attacker, attacker.attack.isReactionAttack, attacker.IsAttacking);
		}
		num += Mathf.RoundToInt((float)num * num3);
		return Mathf.Clamp(num, 0, 100);
	}

	public WhamStates GetDefaultWhamState(Combat.CombatMinigame miniGame, Combat.CombatData data, Unit target, v2i? customAttackerCoord = null)
	{
		WhamStates whamStates = WhamStates.None;
		switch (miniGame)
		{
		case Combat.CombatMinigame.AttackWhamBar:
		case Combat.CombatMinigame.RefuseAttackWhamBar:
		{
			float chance2 = (float)data.hitChance * ((float)data.critChance * 0.01f);
			whamStates |= WhamStates.Hit;
			if ((whamStates & WhamStates.Crit) == 0 && chance2.PercentChance())
			{
				whamStates |= WhamStates.Crit;
			}
			break;
		}
		case Combat.CombatMinigame.DodgeWhamBar:
		{
			float chance = (float)(100 - data.hitChance) * ((float)data.dodgeChance * 0.01f);
			whamStates |= WhamStates.Crit;
			v2i attackCoord = ((!customAttackerCoord.HasValue) ? coord : customAttackerCoord.Value);
			CoverType coverBetween = map.GetCoverBetween(attackCoord, target.coord);
			if (coverBetween != CoverType.Flanked && coverBetween != CoverType.None)
			{
				whamStates |= WhamStates.Dodge;
			}
			if ((whamStates & WhamStates.Dodge) == 0 && chance.PercentChance())
			{
				whamStates |= WhamStates.Dodge;
			}
			else if ((whamStates & WhamStates.Dodge) == 0 && (whamStates & WhamStates.Graze) == 0)
			{
				whamStates |= WhamStates.Graze;
			}
			break;
		}
		}
		return whamStates;
	}

	public int GetMovementDistancePerTurn()
	{
		if (IsMovementDisabled)
		{
			return 0;
		}
		int num = charData.MovementDistancePerTurn(Level);
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetUnitMaxMoveDistanceModifier(this);
		}
		if (GC.Inst.IsInStealthMode())
		{
			num += charData.StealthMovementMod(Level);
		}
		return num;
	}

	public int GetDamageValue(bool isCriticalHit, Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		if (weapon == null)
		{
			return 0;
		}
		int num = ((!weapon.IsMelee) ? CharacterStats.LUT_WeaponBaseDamageRanged[ClassID, Level] : CharacterStats.LUT_WeaponBaseDamageMelee[ClassID, Level]);
		int num2 = num + weapon.Damage;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num2 += item.GetUnitDamageModifier(this, target, weapon, isCombatCalculation);
		}
		if (isCriticalHit)
		{
			num2 += weapon.CriticalDamage;
		}
		return num2;
	}

	public int GetGrazeDamage(Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		int num = GetDamageValue(isCriticalHit: false, target, weapon, isCombatCalculation) / 2;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetTargetedGrazeDamageModifier(this, target, weapon, isCombatCalculation);
		}
		return num;
	}

	public int GetCriticalHitChance(Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		AttackData attackData;
		return GetCriticalHitChance(coord, target, target.coord, weapon, out attackData, isCombatCalculation);
	}

	public int GetCriticalHitChance(v2i attackCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, out AttackData attackData, bool isCombatCalculation)
	{
		attackData = map.GetAttackData(attackCoord, targetCoord);
		return GetCriticalHitChance(coord, target, target.coord, weapon, attackData, isCombatCalculation);
	}

	public int GetCriticalHitChance(v2i attackCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, AttackData attackData, bool isCombatCalculation)
	{
		int num = CharacterStats.LUT_WeaponBaseCritical[ClassID, Level];
		int num2 = num + weapon.CriticalChance;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num2 += item.GetUnitCriticalHitChanceModifier(this, attackCoord, target, targetCoord, weapon, isCombatCalculation);
		}
		foreach (AbilityImplBase item2 in target.abilities.OnUnitAndTeam())
		{
			num2 += item2.GetTargettedCriticalHitChanceModifier(target, targetCoord, this, attackCoord, isCombatCalculation);
		}
		if (attackData.coverType.Is(CoverType.Flanked) || attackData.coverType.Is(CoverType.None))
		{
			num2 += 20;
		}
		return Mathf.Clamp(num2, 0, 100);
	}

	public int GetCriticalHitSize(Unit target, WeaponAttributes weapon, bool isCombatCalculation)
	{
		int num = CharacterStats.LUT_WeaponBaseCriticalSize[ClassID, Level];
		int num2 = num;
		float num3 = 0f;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num3 += item.GetUnitCriticalHitSizeModifier(this, target, weapon, isCombatCalculation);
		}
		foreach (AbilityImplBase item2 in target.abilities.OnUnitAndTeam())
		{
			num3 += item2.GetTargettedCriticalHitSizeModifier(target, this, isCombatCalculation);
		}
		num += Mathf.RoundToInt((float)num * num3);
		return Mathf.Clamp(num, 0, 100);
	}

	public int GetHitChance(v2i attackCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation, bool ignoreCover = false)
	{
		AttackData attackData;
		return GetHitChance(attackCoord, target, targetCoord, weapon, reactionAttack, isCombatCalculation, out attackData, ignoreCover);
	}

	public int GetHitChance(v2i attackCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation, out AttackData attackData, bool ignoreCover = false)
	{
		attackData = map.GetAttackData(attackCoord, targetCoord);
		return GetHitChance(attackCoord, target, targetCoord, weapon, reactionAttack, isCombatCalculation, attackData, ignoreCover);
	}

	public int GetHitChance(v2i attackCoord, Unit target, v2i targetCoord, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation, AttackData attackData, bool ignoreCover = false)
	{
		int num = 0;
		if (weapon.IsMelee || (weapon.IsRanged && attackData.coverType != CoverType.Obscured) || ignoreCover)
		{
			int num2;
			if (weapon.IsMelee)
			{
				num2 = CharacterStats.LUT_WeaponBaseAccuracyMelee[ClassID, Level];
			}
			else
			{
				num2 = CharacterStats.LUT_WeaponBaseAccuracyRanged[ClassID, Level];
				num2 = Mathf.Clamp(num2, 0, 100);
				int num3 = (int)v2i.Distance(attackCoord, targetCoord);
				int num4 = CharacterStats.LUT_AccuracyRangeMin[ClassID];
				int num5 = CharacterStats.LUT_AccuracyRangeFalloff[ClassID];
				int num6 = num5 * Mathf.Max(0, num3 - num4);
				num2 -= num6;
			}
			num += num2;
			num += attackData.hitChance;
			float num7 = 0f;
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				num7 += item.GetUnitAccuracyChanceModifier(this, attackCoord, target, targetCoord, weapon, isCombatCalculation);
			}
			foreach (AbilityImplBase item2 in target.abilities.OnUnitAndTeam())
			{
				num7 += item2.GetTargettedAccuracyChanceModifier(target, targetCoord, this, attackCoord, weapon, reactionAttack, isCombatCalculation);
			}
			num += Mathf.RoundToInt((float)num * num7);
		}
		return Mathf.Clamp(num, 0, 100);
	}

	public int GetHitChance(v2i attackCoord, Unit target, WeaponAttributes weapon, bool reactionAttack, bool isCombatCalculation)
	{
		return GetHitChance(attackCoord, target, target.coord, weapon, reactionAttack, isCombatCalculation);
	}

	public bool GetCancelIncomingAttack(Unit attacker)
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if (item.OnUnitAttackedShouldCancel(this, attacker))
			{
				return true;
			}
		}
		return false;
	}

	public void Hit()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if (item.IsManualHitAnimation())
			{
				return;
			}
		}
		if (unitModel.crouched)
		{
			unitModel.PlayWithTransition(UnitModel.AnimID.CombatCrouchHit, UnitModel.AnimID.CombatCrouch);
		}
		else
		{
			unitModel.PlayWithTransition(UnitModel.AnimID.CombatHit, UnitModel.AnimID.CombatIdle);
		}
	}

	public void Dodge(Vector3 hitDirLocalSpace)
	{
		Vector3 vector = new Vector3(-1f, 0f, -1f);
		Vector3 vector2 = new Vector3(1f, 0f, -1f);
		v2i v2i2 = v2i.DirectionXZ(hitDirLocalSpace);
		v2i v2i3 = v2i.DirectionXZ(unitModel.GetLookAtDirectionLS());
		int left = (int)(NC.DirectionToIndex(v2i2) - NC.DirectionToIndex(v2i3));
		left = left.Wrap(8);
		UnitModel.AnimID animID = ((!unitModel.crouched) ? UnitModel.AnimID.CombatIdle : UnitModel.AnimID.CombatCrouch);
		unitModel.EnableDodgeEffect(enabled: true);
		PSC.Inst.Play(ParticleTypes.Dodge, map, coord);
	}

	public void Kill()
	{
		IsDying = true;
		APDecrement(AP);
		OnDeathStart.Trigger();
		Routine.Start(death, MR.Inst.Host, MR.Inst.mainHagisSequence);
		if ((bool)decoyUnit)
		{
			decoyUnit.KillIfDecoyUnit();
		}
	}

	private IEnumerator<HagletYieldTerm> Death()
	{
		HagletTrigger triggerAnimComplete = new HagletTrigger();
		yield return Routine.ResetToHere();
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitDeathBegun(this);
		}
		statusBar.PulseAP(0);
		statusBar.HideAll();
		if (base.gameObject.activeInHierarchy)
		{
			string animName = null;
			foreach (AbilityImplBase item2 in abilities.OnUnitAndTeam())
			{
				string unitDeathAnimName = item2.GetUnitDeathAnimName();
				if (!string.IsNullOrEmpty(unitDeathAnimName))
				{
					animName = unitDeathAnimName;
				}
			}
			while (unitModel.isAnimationQueued() || unitModel.PlayIsDirty)
			{
				yield return null;
			}
			if (animName == null)
			{
				yield return ModelPlayAnim(UnitModel.AnimID.CombatDeath);
			}
			else
			{
				yield return unitModel.Play(animName);
			}
			if (DropItemOnDeath != Item.None)
			{
				TileActionGiveLoot tileActionGiveLoot = map.TryGetOnDeathLootTrigger(DropItemOnDeath);
				if (tileActionGiveLoot != null)
				{
					tileActionGiveLoot.transform.localPosition = _GetTransform().localPosition;
					tileActionGiveLoot.gameObject.SetActive(value: true);
					PSC.Inst.Play(ParticleTypes.Shockwave, map, coord);
				}
			}
			HologramAnim holoAnim = HologramAnim.UNIT_DEATH;
			foreach (AbilityImplBase item3 in abilities.OnUnitAndTeam())
			{
				HologramAnim unitDeathHologramAnim = item3.GetUnitDeathHologramAnim();
				if (unitDeathHologramAnim != HologramAnim.UNIT_DEATH)
				{
					holoAnim = unitDeathHologramAnim;
				}
			}
			if (WillHideOnDeath)
			{
				Hide(makeInactive: true, holoAnim);
			}
			else
			{
				GC.Inst._RemoveActiveUnit(this);
			}
			yield return Wait.ForChildren;
		}
		OnExitTile();
		OnDeathComplete.Trigger();
		if (OnUnitDeathComplete != null)
		{
			OnUnitDeathComplete();
		}
		foreach (AbilityImplBase item4 in abilities.OnUnitAndTeam())
		{
			item4.OnUnitDeathComplete(this);
		}
		yield return Wait.ForChildren;
		CleanObservedCount();
		GetTeam().RemoveAliveMember(this);
		GetTeam().OnUnitDeath(this);
		GC.Inst.OnUnitDeath(this);
		IsDying = false;
	}

	public HagletYieldTerm Revive(HologramAnim context = HologramAnim.DEFAULT)
	{
		if (IsAlive())
		{
			return Wait.PreMet;
		}
		GetTeam().AddAliveMember(this);
		contextOnActive = context;
		base.gameObject.SetActive(value: true);
		HPRefill();
		APRefill();
		if (GC.Inst.IsInTurnMode() && GC.Inst.GetActiveTeam() != null)
		{
			ShowStatusBar();
		}
		UpdateIdleAnim();
		return Wait.ForChildren;
	}

	public HagletYieldTerm SetCoord(v2i coord, Map map = null)
	{
		setCoordResettable.targetCoord = coord;
		setCoordResettable.targetMap = map;
		return Routine.Start(setCoordResettable, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> SetCoordRoutine()
	{
		OnExitTile();
		if (setCoordResettable.targetMap != null)
		{
			_GetTransform().SetParent(setCoordResettable.targetMap.transform, worldPositionStays: false);
			map = setCoordResettable.targetMap;
		}
		coord = setCoordResettable.targetCoord;
		WarpToLocalMapPosition(map.CoordToLocalPos(setCoordResettable.targetCoord));
		yield return Routine.Start(onUnitEnterCoord, MR.Inst.Host, MR.Inst.mainHagisSequence);
		OnEnterTile();
		setCoordResettable.targetCoord = default(v2i);
		setCoordResettable.targetMap = null;
	}

	public HagletYieldTerm WaitForAttackAnimEvent()
	{
		return Wait.Until(unitModel.AnimFuncs.TriggerOnEvent(UnitAnimFuncs.Event.Attack));
	}

	public PatrolPoint? GetActivePatrolPoint()
	{
		if (patrolPoints.Length == 0)
		{
			return null;
		}
		if (coord == patrolPoints[activePatrolPointIndex].coord)
		{
			if (activePatrolPointIndex >= patrolPoints.Length - 1)
			{
				activePatrolPointIndex = 0u;
			}
			else
			{
				activePatrolPointIndex++;
			}
		}
		return patrolPoints[activePatrolPointIndex];
	}

	public bool AddPatrolPoint(UnitPatrol patrolObject)
	{
		v2i v2i2 = map.WorldPosToCoord(patrolObject.transform.position);
		if (!map.CoordExists(v2i2))
		{
			return false;
		}
		PatrolPoint obj = default(PatrolPoint);
		obj.coord = v2i2;
		obj.direction = patrolObject.direction;
		patrolPoints.Add(obj);
		return true;
	}

	public bool UpdateObservedTilesAndCheckIfSpotted()
	{
		if (GC.Inst.IsInStealthMode())
		{
			switch (teamType)
			{
			case UnitTeam.Type.Enemy:
			{
				CleanObservedCount();
				CreateNewObserveCounts();
				for (int i = 0; i < charData.lineOfSightDistance && map.CoordExists(observedCoords[i]); i++)
				{
					Unit unitAtCoord = GC.Inst.GetUnitAtCoord(observedCoords[i]);
					if ((bool)unitAtCoord && unitAtCoord.teamType == UnitTeam.Type.Player)
					{
						StopMovement();
						UnitTeam teamOfType2 = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy);
						GC.Inst.HACK_stealthBreakers = teamOfType2;
						return true;
					}
				}
				break;
			}
			case UnitTeam.Type.Player:
				if (map.GetTileObserverCount(coord) != 0)
				{
					UnitTeam teamOfType = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy);
					GC.Inst.HACK_stealthBreakers = teamOfType;
					return true;
				}
				break;
			}
		}
		return false;
	}

	private void CreateNewObserveCounts()
	{
		Vector3 lookAtDirectionLS = unitModel.GetLookAtDirectionLS();
		Vector3 pos = map.CoordToLocalPos(coord);
		for (int i = 0; i <= charData.lineOfSightDistance; i++)
		{
			v2i v2i2 = map.LocalPosToCoord(pos);
			observedCoords[i] = v2i2;
			if (!map.CoordExists(v2i2) || map.GetCoordBlocked(v2i2))
			{
				break;
			}
			pos += lookAtDirectionLS;
			if (i <= 0 || !(observedCoords[i - 1] == v2i2))
			{
				map.SetTileObserverCount(v2i2, map.GetTileObserverCount(v2i2) + 1);
			}
		}
	}

	public void CleanObservedCount()
	{
		for (int i = 0; i <= charData.lineOfSightDistance && map.CoordExists(observedCoords[i]); i++)
		{
			uint tileObserverCount = map.GetTileObserverCount(observedCoords[i]);
			if (tileObserverCount != 0)
			{
				map.SetTileObserverCount(observedCoords[i], tileObserverCount - 1);
			}
			observedCoords[i] = default(v2i);
		}
	}

	public bool IsFlankingAnyEnemyUnit()
	{
		bool result = false;
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			if (unitsActive[i].GetTeamType() != teamType && unitsActive[i].GetTeamType() != UnitTeam.Type.NPC)
			{
				CoverType coverBetween = activeMap.GetCoverBetween(coord, unitsActive[i].coord);
				if (coverBetween.Is(CoverType.Flanked))
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	public Unit GetFlankedEnemy()
	{
		Unit result = null;
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		for (int i = 0; i < unitsActive.Length; i++)
		{
			if (unitsActive[i].GetTeamType() != teamType && unitsActive[i].GetTeamType() != UnitTeam.Type.NPC)
			{
				CoverType coverBetweenAllEnemies = activeMap.GetCoverBetweenAllEnemies(unitsActive[i].coord, unitsActive[i]);
				if (coverBetweenAllEnemies.Is(CoverType.Flanked))
				{
					result = unitsActive[i];
					break;
				}
			}
		}
		return result;
	}

	public HagletCondition LookAt(Unit lookAtTarget, bool keepEyeOn)
	{
		return LookAt(lookAtTarget._GetTransform(), keepEyeOn);
	}

	public HagletCondition LookAt(Transform target, bool keepEyeOn = false)
	{
		if (keepEyeOn)
		{
			unitModel.FocusOnTarget(target);
		}
		else
		{
			unitModel.StartLookAtTarget(target.position);
		}
		return unitModel.IsRotating;
	}

	public HagletCondition LookAt(Unit unit)
	{
		unitModel.StartLookAtTarget(unit.GetPositionWS());
		return unitModel.IsRotating;
	}

	public HagletCondition LookAt(Vector3 worldPos)
	{
		unitModel.StartLookAtTarget(worldPos);
		return unitModel.IsRotating;
	}

	public HagletCondition LookAt(v2i mapPos)
	{
		unitModel.StartLookAtTarget(map.CoordToWorldPos(mapPos));
		return unitModel.IsRotating;
	}

	public HagletCondition LookInDirection(OctDir direction)
	{
		v2i v2i2 = NC.IndexToDirection((uint)direction);
		Vector3 worldPos = map.CoordToWorldPos(coord + v2i2);
		unitModel.StartLookAtTarget(worldPos);
		return unitModel.IsRotating;
	}

	private IEnumerator<HagletYieldTerm> ShowHideRoutine()
	{
		if (showHide.isShowing && !showHide.isChangingActiveState && !base.gameObject.activeInHierarchy)
		{
			yield break;
		}
		yield return null;
		if (showHide.isShowing)
		{
			_isShown = true;
			if (showHide.isChangingActiveState)
			{
				GC.Inst._AddActiveUnit(this);
			}
			behaviourCache.SetEnabled(enabled: true, affectColliders: false);
			unitModel.Show();
			if (GC.Inst.IsInTurnMode() && GC.Inst.GetActiveTeam() != null)
			{
				ShowStatusBar();
			}
			AC.Inst.PlayOneShot2D("event:/sfx/ui/map transition/player spawn");
		}
		else
		{
			if (map.VFXTiles.GetUnitSelected() == this)
			{
				map.VFXTiles.UnitSelectedHide();
			}
			if (map.VFXTiles.GetUnitHighlighted() == this)
			{
				map.VFXTiles.UnitSelectedHide();
			}
			unitModel.Show();
			AC.Inst.PlayOneShot2D("event:/sfx/ui/map transition/player disappear");
		}
		float target = ((!showHide.isShowing) ? 0f : 1f);
		unitModel.BlobShadow.color = unitModel.BlobShadow.color.RepA(1f - target);
		hologramAnim.AnimateTo(target, GetHologramAnimTime(showHide.context));
		if (Routine.IsSkipping())
		{
			hologramAnim.Update(hologramAnim.Duration);
		}
		while ((bool)hologramAnim.animating)
		{
			hologramAnim.Update();
			UpdateHologramMaterials();
			unitModel.BlobShadow.color = unitModel.BlobShadow.color.RepA(hologramAnim.Value);
			yield return Wait.ForSteps(1uL);
		}
		if (showHide.isShowing)
		{
			_OnShowComplete.Trigger();
			yield break;
		}
		yield return Wait.ForChildren;
		_HideImmediate(showHide.isChangingActiveState);
	}

	public bool Show(Action OnComplete = null, HologramAnim context = HologramAnim.DEFAULT, bool updateIdleAnim = true)
	{
		if (!base.gameObject.activeSelf)
		{
			updateIdleOnActive = updateIdleAnim;
			contextOnActive = context;
			base.gameObject.SetActive(value: true);
			return true;
		}
		showHide.isShowing = true;
		if (!GC.Inst.GetUnitsActive().Contains(this))
		{
			showHide.isChangingActiveState = true;
		}
		else
		{
			showHide.isChangingActiveState = false;
		}
		showHide.context = context;
		StartOrResetShowHideRoutine();
		if (updateIdleAnim && !Singleton<NPCWanderController>.Inst.IsUnitWandering(this))
		{
			UpdateIdleAnim();
		}
		return true;
	}

	public void Hide(bool makeInactive, HologramAnim context = HologramAnim.DEFAULT)
	{
		showHide.isShowing = false;
		showHide.context = context;
		if (context != HologramAnim.IMMEDIATE)
		{
			showHide.isChangingActiveState = makeInactive;
			StartOrResetShowHideRoutine();
		}
		else
		{
			_HideImmediate(makeInactive);
		}
	}

	private void _HideImmediate(bool makeInactive)
	{
		unitModel.Hide();
		HideStatusBar();
		HideMovementArea();
		if (makeInactive)
		{
			if (_isShown)
			{
				GC.Inst._RemoveActiveUnit(this);
				base.gameObject.SetActive(value: false);
			}
			behaviourCache.SetEnabled(enabled: false, affectColliders: false);
			if (Singleton<NPCWanderController>.Inst != null && Singleton<NPCWanderController>.Inst.IsUnitWandering(this))
			{
				ToggleAnimators(value: true);
			}
			_OnHideComplete.Trigger();
		}
		_isShown = false;
	}

	private void StartOrResetShowHideRoutine()
	{
		if (showHide.markedToRunBy == null)
		{
			if ((bool)showHide.running)
			{
				showHide.host.Pause(showHide);
				showHide.Reset();
			}
			Routine.Start(showHide, MR.Inst.Host);
		}
	}

	public bool HasBark(BarkTypes barkType)
	{
		string text = barkStrings[(int)barkType];
		if (text == null)
		{
			return false;
		}
		return true;
	}

	public bool PlayBark(BarkTypes barkType, bool provideUnit = false, Unit target = null)
	{
		if (!BarkQueue.ShouldBarkPlay)
		{
			return false;
		}
		if (!HasBark(barkType))
		{
			return false;
		}
		string barkPath = barkStrings[(int)barkType];
		BarkQueue.QueueBark(barkPath, (!provideUnit) ? null : this, target);
		return true;
	}

	public void _SetLevel(int level)
	{
		_levelInitial = level;
		HPRefill();
		APRefill();
		SetTeamType(teamType);
		statusBar.ConstructHPPips();
	}

	public void AddInitialPartyAbilities()
	{
		Type type = CharacterStats.abilityTree[(int)charData.Class, 0, 0];
		Type type2 = CharacterStats.abilityTree[(int)charData.Class, 0, 1];
		Type type3 = CharacterStats.abilityTree[(int)charData.Class, 1, 0];
		if (!abilities.Exists(type))
		{
			abilities.Add(type, null, isUpgraded: false);
		}
		if (!abilities.Exists(type2))
		{
			abilities.Add(type2, null, isUpgraded: false);
		}
		if (!abilities.Exists(type3))
		{
			abilities.Add(type3, null, isUpgraded: false);
		}
	}

	public Transform _GetTransform()
	{
		return base.transform;
	}

	public void WarpToLocalMapPosition(Vector3 localMapPosition)
	{
		coord = map.LocalPosToCoord(localMapPosition);
		localMapPosition.y = map.GetTileElevation(coord);
		base.transform.position = map.LocalPosToWorldPos(localMapPosition);
	}

	public Vector3 GetPositionWS()
	{
		return base.transform.position;
	}

	public Vector3 GetPositionLS()
	{
		return base.transform.localPosition;
	}

	public Quaternion GetRotationWS()
	{
		return base.transform.rotation;
	}

	private IEnumerator<HagletYieldTerm> BulletRoutine(int idx)
	{
		Bullet bul = attack.bulletRoutines[idx];
		yield return Routine.ResetToHere();
		yield return Wait.ForSeconds(0.05f * (float)bul.targetIdx);
		Unit target = attack.targets[bul.targetIdx];
		AttackMuzzleFlash();
		switch (bul.bulletType)
		{
		case Bullet.BulletType.Default:
			yield return Wait.While(FireBulletForAttack(target, bul.hitType));
			if (bul.hitType == Combat.HitType.Reflect || bul.additionalEffect == Combat.HitType.Reflect)
			{
				target.popupBar.Enqueue("POPUPBAR_UNITATTACK_REFLECT");
				yield return Wait.While(target.FireBulletForAttack(this, bul.hitType, reflectAttack: true));
			}
			break;
		case Bullet.BulletType.Ricochet:
		{
			int ricochetTimeout = 8;
			int ricochetCount = 0;
			Vector3 startPos = unitModel.WeaponModelRanged.BarrelXForm.transform.position + _GetTransform().up * 0.08f;
			v2i ricochetStartCoord = coord;
			OctDir ricochetDir = (target.GetPositionWS() - GetPositionWS()).ToSimpleDirXZ();
			Vector3 endPos2 = GetRandomRicochetPoint(ref ricochetStartCoord, ref ricochetDir);
			while (ricochetTimeout > 0)
			{
				ricochetCount++;
				if (startPos != endPos2)
				{
					ParticleBullet particle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, map.transform);
					particle.didHit = true;
					yield return Wait.While(particle.AnimateFromAToB(startPos, endPos2));
					AC.Inst.PlayOneShot3D("event:/sfx/character v2/weapon/projectile ricochet", endPos2);
					startPos = endPos2;
					if (!map.Raymarch(map.WorldPosToCoord(startPos), target.coord).HasValue && ricochetCount > 3)
					{
						break;
					}
				}
				else
				{
					ricochetDir = ricochetDir.Negative();
					yield return null;
				}
				endPos2 = GetRandomRicochetPoint(ref ricochetStartCoord, ref ricochetDir);
				ricochetTimeout--;
			}
			endPos2 = ((bul.hitType == Combat.HitType.Dodged || bul.hitType == Combat.HitType.Miss) ? GetRandomRicochetPoint(ref ricochetStartCoord, ref ricochetDir) : (target._GetTransform().position + _GetTransform().up * 0.08f));
			ParticleBullet lastParticle = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, map.transform);
			yield return Wait.While(lastParticle.AnimateFromAToB(startPos, endPos2));
			break;
		}
		}
		bool playDodgeMissBarks = !bul.hitType.IsHit() && bul.hitType != Combat.HitType.Reflect && bul.additionalEffect != Combat.HitType.Reflect && (!(LR.Inst.missionMetaLoaded.sceneName == "MISSION_A1S1_Inversion") || charData.partyMemberID != PartyMemberID.Willa);
		if (playDodgeMissBarks)
		{
			target.PlayBark(BarkTypes.Dodge, provideUnit: true, this);
			PlayBark(BarkTypes.AttackMiss, provideUnit: true, target);
		}
		HandleAttackResult(target, bul.hitType);
		HandleAttackResult(target, bul.additionalEffect);
		if (!playDodgeMissBarks && (bul.hitType.IsHit() || bul.hitType == Combat.HitType.HitCritical))
		{
			PlayBark(BarkTypes.AttackCritical, provideUnit: true, target);
		}
	}

	private Vector3 GetRandomRicochetPoint(ref v2i ricochetStartCoord, ref OctDir ricochetDir)
	{
		v2i v2i2 = coord;
		int num = 64;
		while (v2i2.x < map.size.x && v2i2.y < map.size.y && v2i2.x >= 0 && v2i2.y >= 0 && num > 0)
		{
			v2i2 += ricochetDir;
			num--;
		}
		v2i2 -= ricochetDir;
		v2i? v2i3 = map.Raymarch(ricochetStartCoord, v2i2);
		if (!v2i3.HasValue)
		{
			v2i3 = v2i2;
		}
		else
		{
			v2i? v2i4 = v2i3;
			v2i3 = ((!v2i4.HasValue) ? null : new v2i?(v2i4.GetValueOrDefault() - ricochetDir));
		}
		ricochetStartCoord = v2i3.Value;
		ricochetDir = (OctDir)UnityEngine.Random.Range(0, 7);
		return map.CoordToWorldPos(v2i3.Value) + _GetTransform().up * 0.08f;
	}

	public int GetPendingDamage(Unit target)
	{
		if (teamController.activeAbility != null)
		{
			return teamController.activeAbility.GetPendingDamage(this, target);
		}
		return GetDamageValue(isCriticalHit: false, target, mainWeapon, isCombatCalculation: false);
	}

	public bool StartAttack(Unit target, WeaponAttributes weapon, bool costsAP = true, IfTooFar ifTargetIsTooFar = IfTooFar.IgnoreLimits, v2i? customTargetCoord = null, bool isReactionAttack = false, bool isAbilityAttack = false, string overrideAnimationName = null, int attackCount = 1, Combat.CombatMinigame minigame = Combat.CombatMinigame.None, Combat.CombatData? overrideCombatData = null, bool updateIdleOnComplete = true, Bullet.BulletType bulletType = Bullet.BulletType.Default)
	{
		if (!ValidateAttackRoutine())
		{
			return false;
		}
		attack.targets.Clear();
		attack.targets.Add(target);
		return StartAttack(weapon, costsAP, ifTargetIsTooFar, customTargetCoord, isReactionAttack, isAbilityAttack, overrideAnimationName, attackCount, minigame, overrideCombatData, updateIdleOnComplete, bulletType);
	}

	public bool StartAttack(WeaponAttributes weapon, bool costsAP = true, IfTooFar ifTargetIsTooFar = IfTooFar.IgnoreLimits, v2i? customTargetCoord = null, bool isReactionAttack = false, bool isAbilityAttack = false, string overrideAnimationName = null, int attackCount = 1, Combat.CombatMinigame minigame = Combat.CombatMinigame.None, Combat.CombatData? overrideCombatData = null, bool updateIdleOnComplete = true, Bullet.BulletType bulletType = Bullet.BulletType.Default)
	{
		if (!ValidateAttackRoutine())
		{
			return false;
		}
		for (int i = 0; i < attack.targets.Length; i++)
		{
			if (!ValidateAttack(attack.targets[i], weapon, costsAP))
			{
				return false;
			}
		}
		attack.weapon = weapon;
		attack.costsAP = costsAP;
		attack.ifTargetIsTooFar = ifTargetIsTooFar;
		attack.customTargetCoord = customTargetCoord;
		attack.isReactionAttack = isReactionAttack;
		attack.isAbilityAttack = isAbilityAttack;
		attack.overrideAnimationName = overrideAnimationName;
		attack.attackCount = attackCount;
		attack.miniGame = minigame;
		attack.overrideCombatData = overrideCombatData;
		attack.updateIdleOnComplete = updateIdleOnComplete;
		for (int j = 0; j < attack.bulletRoutines.Length; j++)
		{
			attack.bulletRoutines[j].bulletType = bulletType;
		}
		Routine.Start(attack, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return true;
	}

	private IEnumerator<HagletYieldTerm> AttackRoutine()
	{
		v2i endAttackOnCoord2 = coord;
		for (int k = 0; k < attack.targets.Length; k++)
		{
			Unit unit = attack.targets[k];
			GC.Inst.FadeInUnit(unit);
		}
		if (!AttackRequiresMovement(attack.weapon))
		{
			v2i? customTargetCoord = attack.customTargetCoord;
			if (!customTargetCoord.HasValue)
			{
				goto IL_0331;
			}
		}
		v2i? customTargetCoord2 = attack.customTargetCoord;
		v2i value;
		if (customTargetCoord2.HasValue)
		{
			v2i? customTargetCoord3 = attack.customTargetCoord;
			value = customTargetCoord3.Value;
		}
		else
		{
			value = attack.targets[0].coord;
		}
		v2i targetCoord = value;
		int movementAPAllowance = AP - 1;
		bool attackValid2 = true;
		if (attack.ifTargetIsTooFar != 0)
		{
			yield return Area.Update(map, coord, GetMovementDistancePerTurn(), newIncludePathing: true, showArea: false, IsVaultAllowed);
			int apNeededToReachTarget = GetAPNeededToReachCoord(targetCoord);
			if (attack.ifTargetIsTooFar == IfTooFar.InvalidateAction && movementAPAllowance < apNeededToReachTarget)
			{
				attackValid2 = false;
				yield break;
			}
			if (attack.ifTargetIsTooFar == IfTooFar.GoAsFarAsPossible && movementAPAllowance < apNeededToReachTarget)
			{
				movementAPAllowance++;
				attackValid2 = false;
			}
		}
		Unit unit2 = this;
		v2i? destCoord = targetCoord;
		int apAllowance = (attack.costsAP ? movementAPAllowance : 0);
		IfTooFar ifTargetIsTooFar = attack.ifTargetIsTooFar;
		if (unit2.StartMovement(destCoord, null, null, null, apAllowance, ifTargetIsTooFar).Failed())
		{
			yield break;
		}
		yield return Wait.ForChildren;
		endAttackOnCoord2 = coord;
		if (!attackValid2)
		{
			yield break;
		}
		goto IL_0331;
		IL_0331:
		destCoord = attack.customTargetCoord;
		if ((!destCoord.HasValue && attack.weapon.IsMelee && attack.ifTargetIsTooFar != 0 && !v2i.IsNeighbour(coord, attack.targets[0].coord)) || !IsAlive())
		{
			yield break;
		}
		bool flag = false;
		for (int l = 0; l < attack.targets.Length; l++)
		{
			if (attack.targets[l].IsAlive())
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			yield break;
		}
		Routine.Start(attackBeginPhase, MR.Inst.Host);
		yield return Wait.ForChildren;
		if (!IsAlive())
		{
			yield break;
		}
		UpdateAPForAttack();
		if (IsAttackCancelled())
		{
			yield break;
		}
		v2i preAttackCoord = coord;
		v2i attackingFromCoord = coord;
		if (attack.IsSingleTarget)
		{
			yield return TryStepOut(coord, AttackTargets[0].coord, out attackingFromCoord);
		}
		Vector3 lookAtTarget = Vector3.zero;
		for (int m = 0; m < attack.targets.Length; m++)
		{
			lookAtTarget += attack.targets[m].GetPositionWS();
		}
		lookAtTarget /= (float)attack.targets.Length;
		unitModel.StartLookAtTarget(lookAtTarget);
		string animationName = attack.overrideAnimationName;
		GetAnimationName(ref animationName);
		if (string.IsNullOrEmpty(animationName) || !unitModel.HasAnim(animationName))
		{
			HandleAttackResult(attack.targets[0], CalculateAttackHitType(attack.targets[0]));
		}
		else
		{
			string prefixAnim = unitModel.GetPrefixAnimation(animationName);
			if (unitModel.currentClip.name != unitModel.GetAnimName(UnitModel.AnimID.CombatAimIdle) && !string.IsNullOrEmpty(prefixAnim) && (unitModel.currentClip.name != prefixAnim || unitModel.IsPlayingAnim(prefixAnim)))
			{
				HagletYieldTerm timeout = Wait.ForSeconds(2.5f);
				yield return unitModel.Play(unitModel.GetPrefixAnimation(animationName)) | timeout;
				if (!timeout.met)
				{
				}
			}
			int attackEventCount = unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(animationName);
			if (attackEventCount <= 0)
			{
				HandleAttackResult(attack.targets[0], CalculateAttackHitType(attack.targets[0]));
			}
			else
			{
				attack.data.Clear();
				int dataIndex = 0;
				int num = 0;
				while (num < attack.attackCount)
				{
					int num2 = 0;
					while (num2 < attackEventCount && num2 < attack.attackCount)
					{
						for (int n = 0; n < attack.targets.Length; n++)
						{
							Combat.CombatData? overrideCombatData = attack.overrideCombatData;
							if (overrideCombatData.HasValue)
							{
								ConstArray<Combat.CombatData> data = attack.data;
								Combat.CombatData? overrideCombatData2 = attack.overrideCombatData;
								data.Add(overrideCombatData2.Value);
								dataIndex++;
								continue;
							}
							Combat.CombatData combatData = default(Combat.CombatData);
							combatData.additionalEffect = Combat.HitType.None;
							if (attack.miniGame == Combat.CombatMinigame.None)
							{
								combatData.hitChance = -1;
								combatData.critChance = -1;
								combatData.dodgeChance = -1;
								combatData.hitType = CalculateAttackHitType(attack.targets[n]);
								combatData.weapon = attack.weapon;
								attack.data.Add(combatData);
								dataIndex++;
							}
							else
							{
								combatData.hitChance = GetHitChance(attackingFromCoord, attack.targets[n], attack.weapon, attack.isReactionAttack, isCombatCalculation: true);
								combatData.critChance = GetCriticalHitChance(attack.targets[n], attack.weapon, isCombatCalculation: true);
								combatData.dodgeChance = attack.targets[n].GetDodgeChance(this);
								combatData.critSize = GetCriticalHitSize(attack.targets[n], attack.weapon, isCombatCalculation: true);
								combatData.dodgeSize = attack.targets[n].GetDodgeSize(this);
								combatData.whamState = GetDefaultWhamState(attack.miniGame, combatData, attack.targets[n], attackingFromCoord);
								combatData.attacker = this;
								combatData.target = attack.targets[n];
								combatData.weapon = attack.weapon;
								attack.data.Add(combatData);
								dataIndex++;
							}
						}
						num2++;
						num++;
					}
				}
				yield return Wait.While(GC.Inst.AnyUnitStatusBarAnimating);
				if (attack.weapon.IsRanged)
				{
					PlayBark(BarkTypes.AttackReady);
				}
				if (attack.miniGame != 0)
				{
					yield return UIWhamBar.Inst.StartWhamBar(attack.miniGame, attack.data, attack.isReactionAttack);
				}
				if (attack.miniGame != Combat.CombatMinigame.RefuseAttackWhamBar)
				{
					if (attack.weapon.IsMelee)
					{
						PlayBark(BarkTypes.AttackReady);
					}
					NotifyAbilitiesPostWhamBar();
					int hitCount = 0;
					int attackNum = 0;
					while (attackNum < attack.attackCount)
					{
						UnitModel obj = unitModel;
						string animName = animationName;
						bool isMelee = IsMelee;
						HagletTrigger attackAnimComplete = obj.Play(animName, looping: false, crouched: false, interacting: false, isMelee);
						int eventNum = 0;
						while (eventNum < attackEventCount && eventNum < attack.attackCount)
						{
							yield return Wait.Until(unitModel.AnimFuncs.TriggerOnEvent(UnitAnimFuncs.Event.Attack));
							for (int num3 = 0; num3 < attack.targets.Length; num3++)
							{
								if (!attack.weapon.IsMelee)
								{
									attack.bulletRoutines[hitCount].hitType = attack.data[hitCount].hitType;
									attack.bulletRoutines[hitCount].additionalEffect = attack.data[hitCount].additionalEffect;
									attack.bulletRoutines[hitCount].targetIdx = num3;
									MR.Inst.Host.StartTopLevel(attack.bulletRoutines[hitCount], attack);
								}
								else
								{
									Unit unit3 = attack.targets[num3];
									if (attack.weapon.MeleeType == WeaponAttributes.MeleeTypes.Blunt)
									{
										PSC.Inst.Play(ParticleTypes.ImpactBlunt, unit3.map, unit3.coord);
									}
									else if (attack.weapon.MeleeType == WeaponAttributes.MeleeTypes.Bladed)
									{
										PSC.Inst.Play(ParticleTypes.ImpactBlade, unit3.map, unit3.coord);
									}
									HandleAttackResult(attack.targets[num3], attack.data[hitCount].hitType);
									HandleAttackResult(attack.targets[num3], attack.data[hitCount].additionalEffect);
								}
								hitCount++;
							}
							eventNum++;
							attackNum++;
						}
						for (int j = 0; j < attackEventCount; j++)
						{
							yield return Wait.While(attack.bulletRoutines[j].running);
						}
						if (unitModel.currentClip != null && unitModel.IsPlayingAnim(animationName))
						{
							yield return attackAnimComplete;
						}
						if (!attack.weapon.IsMelee)
						{
							continue;
						}
						bool flag2 = false;
						int num4 = attack.targets.sLength;
						while (--num4 >= 0)
						{
							if (attack.targets[num4].HP > 0)
							{
								flag2 = true;
								break;
							}
						}
						if (!flag2)
						{
							attackNum = attack.attackCount;
						}
					}
					string suffixAnim = unitModel.GetSuffixAnimation(animationName);
					if (!string.IsNullOrEmpty(suffixAnim) && unitModel.HasAnim(suffixAnim))
					{
						yield return unitModel.Play(suffixAnim);
					}
				}
			}
		}
		yield return null;
		if (IsSteppedOut)
		{
			coord = preAttackCoord;
			StartStepBackIn();
			yield return Wait.ForChildren;
		}
		if (attack.updateIdleOnComplete)
		{
			UpdateIdleAnim();
		}
		for (int i = 0; i < attack.targets.Length; i++)
		{
			while (attack.targets[i].IsDying.SkipOverride(overrideValue: false))
			{
				yield return null;
			}
		}
		NotifyAbilitiesAttackEnd();
		UncloakUnitIfNeeded();
		yield return Wait.ForChildren;
		CheckAndPossiblyEndStealth();
		attack.isReactionAttack = false;
		attack.isAbilityAttack = false;
		if (attack.updateIdleOnComplete)
		{
			UpdateIdleAnim();
		}
		OnFinishedAttack.Trigger();
	}

	public HagletYieldTerm TryStepOut(v2i source, v2i target, out v2i steppedOutCoord)
	{
		AttackData attackData = map.GetAttackData(source, target);
		if (attackData.attackFromCoord != source)
		{
			OctDir stepOutDirection = GetStepOutDirection(coord, attackData.attackFromCoord);
			if (StartStepOut(stepOutDirection))
			{
				steppedOutCoord = attackData.attackFromCoord;
				return StepOutCompleted;
			}
		}
		steppedOutCoord = source;
		return Wait.None;
	}

	public static OctDir GetStepOutDirection(v2i source, v2i destination)
	{
		v2i v2i2 = destination - source;
		Vector3 vect = new Vector3(v2i2.x, 0f, v2i2.y);
		return vect.ToSimpleDirXZ();
	}

	private IEnumerator<HagletYieldTerm> AttackBeginPhase()
	{
		NotifyTargetAbilitiesAttackBegan();
		yield return Wait.ForChildren;
		if (IsAlive() && !IsAttackingDisabled)
		{
			NotifyUnitAbilitiesAttackBegan();
			yield return Wait.ForChildren;
			if (IsAlive())
			{
			}
		}
	}

	public HagletEvent StartFakeAttack(v2i coord, bool updateIdleOnComplete, string animOverride = "")
	{
		FakeAttack fakeAttack = default(FakeAttack);
		fakeAttack.target = map.CoordToWorldPos(coord) + _GetTransform().up * 0.08f;
		fakeAttack.updateIdleOnComplete = updateIdleOnComplete;
		fakeAttack.animOverride = animOverride;
		FakeAttack fakeAttackData = fakeAttack;
		return StartFakeAttack(fakeAttackData);
	}

	public HagletEvent StartFakeAttack(FakeAttack fakeAttackData)
	{
		fakeAttack = fakeAttackData;
		Routine.Start(fakeAttackHaglet, MR.Inst.Host);
		return fakeAttackHaglet.completed;
	}

	private IEnumerator<HagletYieldTerm> FakeAttackRoutine()
	{
		unitModel.StartLookAtTarget(fakeAttack.target);
		string animationName = unitModel.GetAnimName(UnitModel.AnimID.CombatAttackRanged);
		if (!string.IsNullOrEmpty(fakeAttack.animOverride))
		{
			animationName = fakeAttack.animOverride;
		}
		string prefixAnim = unitModel.GetPrefixAnimation(animationName);
		if (unitModel.currentClip.name != unitModel.GetAnimName(UnitModel.AnimID.CombatAimIdle) && !string.IsNullOrEmpty(prefixAnim) && (unitModel.currentClip.name != prefixAnim || unitModel.IsPlayingAnim(prefixAnim)))
		{
			HagletYieldTerm timeout = Wait.ForSeconds(2.5f);
			yield return unitModel.Play(unitModel.GetPrefixAnimation(animationName)) | timeout;
			if (!timeout.met)
			{
			}
		}
		int attackEventCount = unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(animationName);
		HagletTrigger attackAnimComplete = unitModel.Play(animationName);
		for (int i = 0; i < attackEventCount; i++)
		{
			yield return Wait.Until(unitModel.AnimFuncs.TriggerOnEvent(UnitAnimFuncs.Event.Attack));
			AttackMuzzleFlash();
			ParticleBullet bullet = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, map.transform);
			bullet.didHit = true;
			bullet.AnimateFromAToB(unitModel.WeaponModelRanged.BarrelXForm.transform.position, fakeAttack.target);
		}
		if (unitModel.currentClip != null && unitModel.IsPlayingAnim(animationName))
		{
			yield return attackAnimComplete;
		}
		if (!fakeAttack.updateIdleOnComplete)
		{
			unitModel.Play(UnitModel.AnimID.CombatAimIdle);
			yield break;
		}
		string suffixAnim = unitModel.GetSuffixAnimation(animationName);
		if (!string.IsNullOrEmpty(suffixAnim) && unitModel.HasAnim(suffixAnim))
		{
			yield return unitModel.Play(suffixAnim);
		}
		UpdateIdleAnim();
	}

	private void GetAnimationName(ref string animName)
	{
		if (!string.IsNullOrEmpty(animName))
		{
			return;
		}
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			string unitAttackAnimName = item.GetUnitAttackAnimName();
			if (!string.IsNullOrEmpty(unitAttackAnimName))
			{
				animName = unitAttackAnimName;
				return;
			}
		}
		animName = unitModel.GetAnimName((!attack.weapon.IsMelee) ? UnitModel.AnimID.CombatAttackRanged : UnitModel.AnimID.CombatAttackMelee);
	}

	private bool ValidateAttackRoutine()
	{
		if (IsAttacking)
		{
			return false;
		}
		return true;
	}

	private bool ValidateAttack(Unit target, WeaponAttributes weapon, bool costsAP)
	{
		if (!IsAlive())
		{
			return false;
		}
		if (!target.IsAlive())
		{
			return false;
		}
		if (IsAttackingDisabled)
		{
			return false;
		}
		if (costsAP && AP < 1)
		{
			return false;
		}
		if (costsAP && AP < 2 && AttackRequiresMovement(weapon))
		{
			return false;
		}
		return true;
	}

	public int GetMaxAPToUseWithAttack()
	{
		int num = 1;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			num += item.GetUnitAttackAPModifier(this);
		}
		return num;
	}

	private bool AttackRequiresMovement(WeaponAttributes weapon)
	{
		if (!attack.IsSingleTarget)
		{
			return false;
		}
		return weapon.IsMelee && !v2i.IsNeighbour(coord, attack.targets[0].coord);
	}

	private void NotifyUnitAbilitiesAttackBegan()
	{
		bool isMovementDisabled = IsMovementDisabled;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if (!isMovementDisabled || !item.RequiresMovement())
			{
				item.OnUnitAttackBegin(this, attack.weapon);
				attack.attackCount += item.GetAdditionalAttacks(this, attack.weapon);
				attack.miniGame = item.OverrideAttackMinigame(attack.miniGame);
			}
		}
	}

	private void NotifyTargetAbilitiesAttackBegan()
	{
		for (int i = 0; i < attack.targets.Length; i++)
		{
			AbilityList abilityList = attack.targets[i].abilities;
			bool isMovementDisabled = attack.targets[i].IsMovementDisabled;
			bool isAttackingDisabled = attack.targets[i].IsAttackingDisabled;
			foreach (AbilityImplBase item in abilityList.OnUnitAndTeam())
			{
				if ((!isMovementDisabled || !item.RequiresMovement()) && (!isAttackingDisabled || !item.RequiresAttack()))
				{
					item.OnUnitAttackedBegin(attack.targets[i], this, attack.weapon, attack.isReactionAttack);
				}
			}
		}
	}

	private void UpdateAPForAttack()
	{
		if (attack.costsAP)
		{
			APDecrement(GetMaxAPToUseWithAttack());
		}
	}

	public Combat.HitType CalculateAttackHitType(Unit target)
	{
		int hitChance = GetHitChance(coord, target, attack.weapon, reactionAttack: false, isCombatCalculation: true);
		int num = ((target.teamType == UnitTeam.Type.Enemy) ? 10 : 0);
		int num2 = Mathf.Max(UnityEngine.Random.Range(0, 100) - num, 0);
		if (num2 > hitChance)
		{
			return Combat.HitType.Miss;
		}
		if (AttackIsStealth())
		{
			return Combat.HitType.HitCritical;
		}
		if (AttackIsDodged(target))
		{
			return Combat.HitType.Dodged;
		}
		if (AttackIsCritical(target))
		{
			return Combat.HitType.HitCritical;
		}
		return Combat.HitType.Hit;
	}

	private void HandleAttackResult(Unit target, Combat.HitType hitType)
	{
		if (!target.IsAlive() || hitType == Combat.HitType.None)
		{
			return;
		}
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitTargetRecievedHitType(this, target, hitType);
		}
		if (hitType.IsHit())
		{
			int num = 0;
			if (hitType == Combat.HitType.Graze)
			{
				num = GetGrazeDamage(target, attack.weapon, isCombatCalculation: true);
				PSC.Inst.Play(ParticleTypes.Graze, target._GetTransform());
			}
			else
			{
				num = GetDamageValue(hitType == Combat.HitType.HitCritical, target, attack.weapon, isCombatCalculation: true);
			}
			DamageAttackTarget(target, hitType, num, attack.weapon);
			return;
		}
		if (hitType == Combat.HitType.Reflect)
		{
			int damageValue = GetDamageValue(isCriticalHit: false, this, mainWeapon, isCombatCalculation: true);
			DamageAttackTarget(this, Combat.HitType.Hit, damageValue, mainWeapon);
			return;
		}
		bool isMovementDisabled = IsMovementDisabled;
		bool isMovementDisabled2 = target.IsMovementDisabled;
		bool isAttackingDisabled = target.IsAttackingDisabled;
		NotifyAttackTarget(hitType, target, playReactionAnimations: true);
		foreach (AbilityImplBase item2 in abilities.OnUnitAndTeam())
		{
			if (!isMovementDisabled || !item2.RequiresMovement())
			{
				item2.OnUnitTargetAvoidedDamage(this, target, hitType, attack.weapon);
			}
		}
		foreach (AbilityImplBase item3 in target.abilities.OnUnitAndTeam())
		{
			if ((!isMovementDisabled2 || !item3.RequiresMovement()) && (!isAttackingDisabled || !item3.RequiresAttack()))
			{
				item3.OnUnitAvoidedDamage(target, this, attack.weapon);
			}
		}
	}

	private bool AttackIsStealth()
	{
		if (GC.Inst.IsInStealthMode() && attack.weapon.IsMelee)
		{
			return true;
		}
		return false;
	}

	private bool IsAttackCancelled()
	{
		for (int i = 0; i < attack.targets.Length; i++)
		{
			if (attack.targets[i].GetCancelIncomingAttack(this))
			{
				return true;
			}
		}
		return false;
	}

	private bool AttackIsCritical(Unit target)
	{
		int num = UnityEngine.Random.Range(0, 100);
		int criticalHitChance = GetCriticalHitChance(target, attack.weapon, isCombatCalculation: true);
		return num < criticalHitChance;
	}

	private bool AttackIsDodged(Unit target)
	{
		int num = UnityEngine.Random.Range(0, 100);
		int dodgeChance = target.GetDodgeChance(this);
		return num < dodgeChance;
	}

	private HagletCondition FireBulletForAttack(Unit target, Combat.HitType hitType, bool reflectAttack = false)
	{
		ParticleBullet particleBullet = (ParticleBullet)PSC.Inst.Play(ParticleTypes.Bullet, map.transform);
		return particleBullet.AnimateToTarget(this, target, hitType, reflectAttack);
	}

	public void AttackMuzzleFlash()
	{
		PSC.Inst.Play(ParticleTypes.MuzzleFlash, Vector3.zero, Quaternion.identity, Vector3.one, unitModel.WeaponModelRanged.BarrelXForm.transform);
	}

	public void NotifyAttackTarget(Combat.HitType hitType, Unit target, bool playReactionAnimations)
	{
		switch (hitType)
		{
		case Combat.HitType.Miss:
			target.popupBar.Enqueue("POPUPBAR_UNITATTACK_MISS");
			break;
		case Combat.HitType.Dodged:
			target.popupBar.Enqueue("POPUPBAR_UNITATTACK_DODGED");
			if (playReactionAnimations)
			{
				target.Dodge((map.CoordToLocalPos(coord) - map.CoordToLocalPos(target.coord)).normalized);
			}
			break;
		case Combat.HitType.HitCritical:
			target.statusBar.PlayCriticalHitAnimation();
			if (playReactionAnimations)
			{
				target.Hit();
			}
			break;
		case Combat.HitType.Hit:
			if (playReactionAnimations)
			{
				target.Hit();
			}
			break;
		case Combat.HitType.Graze:
			target.popupBar.Enqueue("POPUPBAR_UNITATTACK_GRAZED");
			if (playReactionAnimations)
			{
				target.Hit();
			}
			break;
		case Combat.HitType.Reaction:
			if (playReactionAnimations)
			{
				target.Hit();
			}
			break;
		}
	}

	public void DamageAttackTarget(Unit target, Combat.HitType hitType, int damage, WeaponAttributes weapon = null)
	{
		if (!target.IsAlive())
		{
			return;
		}
		bool flag = false;
		if (target.HP > 1 && target.HP <= damage && target.charData.ChanceToSecondChance(Level).PercentChance())
		{
			damage = target.HP - 1;
			flag = true;
		}
		if (damage > 0)
		{
			bool isMovementDisabled = target.IsMovementDisabled;
			bool isAttackingDisabled = target.IsAttackingDisabled;
			foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
			{
				if ((!isMovementDisabled || !item.RequiresMovement()) && (!isAttackingDisabled || !item.RequiresAttack()))
				{
					damage = item.OnUnitTargetWillSustainDamage(this, target, hitType, damage, weapon);
				}
			}
		}
		bool flag2 = target.HPDecrement(damage, this, weapon, hitType);
		NotifyAttackTarget(hitType, target, flag2);
		if (!flag2)
		{
			target.PlayBark(BarkTypes.Death);
			UnitTeam teamOfType = GC.Inst.GetTeamOfType(target.teamType);
			bool flag3 = teamOfType.GetMemberWithName(target.charData.name) != null;
			uint length = teamOfType.GetActiveMembers().Length;
			if ((!flag3) ? (length == 0) : (length <= 1))
			{
				PlayBark(BarkTypes.FinalKill);
			}
			else if (charData.charName == "Bugsy")
			{
				if (target.charData.partyMemberID == PartyMemberID.Margot)
				{
					PlayBark(BarkTypes.BugsyKillMargot);
				}
				else
				{
					PlayBark(BarkTypes.BugsyKillNotMargot);
				}
			}
			else
			{
				switch (target.charData.Sex)
				{
				case CharacterSex.Male:
					PlayBark(BarkTypes.KillMale);
					break;
				case CharacterSex.Female:
					PlayBark(BarkTypes.KillFemale);
					break;
				case CharacterSex.Robot:
					PlayBark(BarkTypes.KillRobot);
					break;
				default:
					PlayBark(BarkTypes.KillGeneric);
					break;
				}
			}
		}
		else if (hitType.IsHit())
		{
			if (hitType == Combat.HitType.HitCritical)
			{
				target.PlayBark(BarkTypes.SeriousDamage, provideUnit: true, this);
			}
			else
			{
				target.PlayBark(BarkTypes.Damage, provideUnit: true, this);
			}
		}
		else if (hitType == Combat.HitType.Reflect)
		{
			PlayBark(BarkTypes.Damage, provideUnit: true);
		}
		if (damage <= 0)
		{
			return;
		}
		bool isMovementDisabled2 = target.IsMovementDisabled;
		bool isAttackingDisabled2 = target.IsAttackingDisabled;
		target.awareOfWound = true;
		foreach (AbilityImplBase item2 in abilities.OnUnitAndTeam())
		{
			if ((!isMovementDisabled2 || !item2.RequiresMovement()) && (!isAttackingDisabled2 || !item2.RequiresAttack()))
			{
				item2.OnUnitTargetSustainedDamage(this, target, hitType, damage, weapon);
				if (item2.OnUnitAttackTargetSuppressWound(this, target))
				{
					target.awareOfWound = false;
				}
			}
		}
	}

	private void NotifyAbilitiesPostWhamBar()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitAttackPostWhamBar(this);
		}
	}

	private void NotifyAbilitiesAttackEnd()
	{
		bool isMovementDisabled = IsMovementDisabled;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if (!isMovementDisabled || !item.RequiresMovement())
			{
				item.OnUnitAttackEnd(this, attack.weapon);
			}
		}
		for (int i = 0; i < attack.targets.Length; i++)
		{
			Unit unit = attack.targets[i];
			Combat.CombatData combatData = attack.data[i];
			AbilityList abilityList = unit.abilities;
			bool isMovementDisabled2 = unit.IsMovementDisabled;
			bool isAttackingDisabled = unit.IsAttackingDisabled;
			foreach (AbilityImplBase item2 in abilityList.OnUnitAndTeam())
			{
				if ((!isMovementDisabled2 || !item2.RequiresMovement()) && (!isAttackingDisabled || !item2.RequiresAttack()))
				{
					item2.OnUnitAttackedEnd(unit, this, attack.isReactionAttack, combatData.hitType, combatData.additionalEffect);
				}
			}
		}
	}

	public void UncloakUnitIfNeeded()
	{
		if (!IsCloaked)
		{
			return;
		}
		bool flag = true;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if (!item.OnUnitAttackShouldUncloak(this))
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			OnExitCloak();
		}
	}

	private void CheckAndPossiblyEndStealth()
	{
		if (GC.Inst.IsInStealthMode() && (!attack.weapon.IsRanged || !abilities.Exists<Ability_Backstab>(null)) && !attack.weapon.IsMelee)
		{
			GC.Inst.HACK_stealthBreakers = GetTeam();
		}
	}

	public static void GatherUnitsInRadius(v2i worldPoint, float radius, ConstArray<Unit> unitArrayToFill, uint teamMask = 4294967279u, bool includeNPCs = false, bool hackableUnitsOnly = false)
	{
		unitArrayToFill.Clear();
		float num = radius * radius;
		for (int i = 0; i < 4; i++)
		{
			if ((!includeNPCs && i == 2) || (teamMask & (1 << i)) == 0)
			{
				continue;
			}
			ConstArray<Unit> activeMembers = GC.Inst.GetTeamOfType((UnitTeam.Type)i).GetActiveMembers();
			for (int j = 0; j < activeMembers.Length; j++)
			{
				Unit unit = activeMembers[j];
				int num2 = v2i.DistanceSqr(worldPoint, unit.coord);
				if ((float)num2 <= num && (!hackableUnitsOnly || unit.charData.hackable))
				{
					unitArrayToFill.Add(unit);
				}
			}
		}
	}

	public HagletTrigger StartAttackAnimationWithAttackEvent(string animationName)
	{
		UnitModel obj = unitModel;
		bool crouched = unitModel.crouched;
		HagletTrigger result = obj.Play(animationName, looping: false, crouched);
		if (unitModel.GetEventCount<UnitAnimFuncs_OnAttack>(animationName) > 0)
		{
			return unitModel.AnimFuncs.TriggerOnEvent(UnitAnimFuncs.Event.Attack);
		}
		return result;
	}

	public void AimAtTarget(Vector3 target)
	{
		LookAt(target);
		unitModel.Play(UnitModel.AnimID.CombatAimIdle);
		AC.Inst.PlayOneShot3D("event:/sfx/character v2/foley/general/combat/aim", _GetTransform().position);
	}

	public Movement.Result StartMovement(v2i? destCoord, NC.Path path = null, Movement.ResultHandler handleResult = null, OctDir? endFacing = null, int apAllowance = 0, IfTooFar ifDestIsTooFar = IfTooFar.IgnoreLimits, bool ignoreOverwatch = false, bool orientateAlongPath = true, bool updateIdleOnCompletion = true, TransitionAnim transitionAnim = TransitionAnim.InOut, UnitModel.AnimID? overrideAnimationID = null, float? overrideSpeed = null, VaultAllowed vaultAllowed = VaultAllowed.AskUnit, bool ignoreUnitAtDestination = false, Haglet skipAdopter = null, bool ignoreShortMovementAnim = false, bool avoidUnits = false, bool shouldReserveTile = true, bool forceWalk = false, bool ignoreTileTriggers = false, NC.PathingCellValidator pathCellValidator = null, bool playArrivalBark = true)
	{
		Movement.Result result = ValidateMove(destCoord, path, apAllowance, ifDestIsTooFar, pathCellValidator);
		movement.result = Movement.Result.None;
		if (result != 0)
		{
			return Dispatch(result, handleResult);
		}
		if ((bool)stepOut.running)
		{
			stepOut.host.Pause(stepOut);
			stepOut.Reset();
		}
		IsSteppedOut = false;
		movement.destCoord = path?.coordEnd ?? destCoord.Value;
		movement.result = Movement.Result.None;
		movement.path = path;
		movement.handleResult = handleResult;
		movement.endDir = endFacing;
		movement.apAllowance = apAllowance;
		movement.tooFarBehaviour = ifDestIsTooFar;
		movement.reservedDest = false;
		movement.ignoreOverwatch = ignoreOverwatch;
		movement.overrideAnimID = overrideAnimationID;
		movement.orientateAlongPath = orientateAlongPath;
		movement.overrideSpeed = overrideSpeed;
		movement.updateIdleOnCompletion = updateIdleOnCompletion;
		movement.vaultAllowed = vaultAllowed;
		movement.ignoreUnitAtDestination = ignoreUnitAtDestination;
		movement.transitionAnim = transitionAnim;
		movement.pauseRoutines.Clear();
		movement.shouldReserveTile = shouldReserveTile;
		movement.ignoreTileTriggers = ignoreTileTriggers;
		movement.pathValidator = pathCellValidator;
		movement.ignoreShortMovementAnim = ignoreShortMovementAnim;
		movement.forceWalk = forceWalk;
		movement.playArrivalBark = playArrivalBark;
		if (movement.shouldReserveTile)
		{
			movement.reservedDest = map.ReserveAccessToCoord(movement.destCoord, Singleton<PC>.Inst.GetLeader() != this);
		}
		Routine.Start(movement, MR.Inst.Host, skipAdopter ?? MR.Inst.mainHagisSequence);
		if (GC.Inst.GetState() == GC.State.RPG && GetTeam().type == UnitTeam.Type.Player && GetTeam().GetTeamLeader() == this && map.logicRoot.CanTeammatesFollow && !GC.Inst.IsInCutsceneMode())
		{
			ConstArray<Unit> activeMembers = GetTeam().GetActiveMembers();
			for (int i = 0; i < activeMembers.Length; i++)
			{
				if (!(activeMembers[i] != this) || !(activeMembers[i].map == map))
				{
					continue;
				}
				TileDefaultUnitPosition closestDefaultUnitPositions = map.GetClosestDefaultUnitPositions(movement.destCoord);
				if (closestDefaultUnitPositions != null)
				{
					float sqrMagnitude = (map.CoordToWorldPos(movement.destCoord) - activeMembers[i].GetPositionWS()).sqrMagnitude;
					float sqrMagnitude2 = (map.CoordToWorldPos(movement.destCoord) - closestDefaultUnitPositions.transform.position).sqrMagnitude;
					if (sqrMagnitude2 < sqrMagnitude && sqrMagnitude > 0.5f)
					{
						activeMembers[i].StopMovement(immediate: true);
						Unit unit = activeMembers[i];
						v2i? destCoord2 = closestDefaultUnitPositions.GetCoord();
						OctDir? endFacing2 = closestDefaultUnitPositions.direction;
						unit.StartMovement(destCoord2, null, null, endFacing2, 0, IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: false, avoidUnits: true);
					}
				}
			}
		}
		return result;
	}

	public HagletEvent StopMovement(bool immediate = false)
	{
		if (!moving)
		{
			return null;
		}
		movement.result = Movement.Result.Cancelled;
		if (immediate)
		{
			OnMovementComplete();
			MR.Inst.Host.Pause(movement);
			movement.Reset();
			return null;
		}
		return movement.stopped;
	}

	private bool IsBlockingUnit(Unit unit)
	{
		return unit != this && unit.IsAlive();
	}

	private IEnumerator<HagletYieldTerm> MovementRoutine()
	{
		FMOD.Studio.EventInstance ambientLoop = default(FMOD.Studio.EventInstance);
		yield return Routine.ResetToHere();
		int pathPtIdx = 0;
		int lastPathPtIdx = 0;
		bool HACK_unreachableDistractionFlag = false;
		if (movement.path != null)
		{
			goto IL_03da;
		}
		int pathTries = 0;
		v2i originalCoord;
		while (true)
		{
			bool vaultAllowed = false;
			switch (movement.vaultAllowed)
			{
			case VaultAllowed.Always:
				vaultAllowed = true;
				break;
			case VaultAllowed.AskUnit:
				vaultAllowed = IsVaultAllowed;
				break;
			case VaultAllowed.No:
				vaultAllowed = false;
				break;
			}
			yield return Wait.While(NC.Inst.CalculatePath(this, movement.destCoord, teamType == UnitTeam.Type.Player, movement.storePath, vaultAllowed, movement.ignoreUnitAtDestination, movement.pathValidator));
			if (movementCancelled)
			{
				break;
			}
			if (movement.path.status == NC.PathStatus.Complete)
			{
				goto IL_03da;
			}
			int num;
			pathTries = (num = pathTries + 1);
			if (num == 2)
			{
				movement.result = Movement.Result.Invalid;
				break;
			}
			yield return Wait.While(NC.Inst.CalculateNeighbors(movement.destCoord, coord, 1u, this, includeObstructedDiagonals: true, movement.storeNeighbors));
			if (movementCancelled)
			{
				break;
			}
			if (movement.neighbors.status != 0)
			{
				movement.result = Movement.Result.Unreachable;
				break;
			}
			originalCoord = movement.destCoord;
			movement.destCoord = movement.neighbors.coordsNeighbors[0];
			if (movement.reservedDest)
			{
				map.UnreserveAccessToCoord(originalCoord);
				map.ReserveAccessToCoord(movement.destCoord);
			}
			movement.neighbors = null;
			if (!(movement.destCoord == coord))
			{
				continue;
			}
			goto IL_0379;
		}
		goto IL_13f8;
		IL_131d:
		movement.result = Movement.Result.Arrived;
		movement.path = null;
		movement.neighbors = null;
		yield return Wait.ForChildren;
		if (movement.endDir.HasValue)
		{
			yield return Wait.While(LookInDirection(movement.endDir.Value));
		}
		if (GC.Inst.IsInTurnMode() && movement.playArrivalBark)
		{
			BarkForMovementArrival();
		}
		goto IL_13f8;
		IL_13f8:
		AC.Stop(ambientLoop);
		if (movement.pauseRoutines.Length != 0)
		{
			for (int i = movement.pauseRoutines.sLength - 1; i >= 0; i--)
			{
				yield return Wait.While(movement.pauseRoutines[i].running);
				movement.pauseRoutines.RemoveAtIndex((uint)i);
			}
		}
		if (HACK_unreachableDistractionFlag)
		{
			movement.result = Movement.Result.Unreachable;
		}
		OnMovementComplete();
		yield return Wait.ForChildren;
		MR.Inst.Host.Pause(movement);
		yield break;
		IL_0379:
		movement.endDir = (map.CoordToWorldPos(originalCoord) - map.CoordToWorldPos(coord)).ToSimpleDirXZ();
		HACK_unreachableDistractionFlag = true;
		goto IL_131d;
		IL_03da:
		if (movement.ignoreShortMovementAnim || unitModel.IsAnimOverriden(UnitModel.AnimID.DefaultWalk))
		{
			movement.isShortMovement = false;
		}
		else
		{
			movement.isShortMovement = unitModel.HasAnim(UnitModel.AnimID.DefaultSlowWalk) && (PreferWalk || movement.forceWalk || movement.path.positions.Count <= 4);
		}
		bool drawPathingEffect = GC.Inst.IsInTurnMode() && !GC.Inst.InCutsceneMode() && GC.Inst.GetActiveUnit() == this && (teamType != UnitTeam.Type.Enemy || !IsCloaked);
		if (drawPathingEffect && teamType == UnitTeam.Type.Enemy)
		{
			map.VFXTiles.PathShow(movement.path, complete: true, showSelectionBox: false, usePathDrawBounds: true, startTrickleEffect: true, makePathRed: true);
		}
		if (movement.tooFarBehaviour == IfTooFar.GoAsFarAsPossible)
		{
			NC.Inst.ShortenPath(movement.path, GetMovementDistancePerTurn() * movement.apAllowance + 1);
			if (movement.reservedDest)
			{
				map.UnreserveAccessToCoord(movement.destCoord);
				map.ReserveAccessToCoord(movement.path.coordEnd);
			}
			movement.destCoord = movement.path.coordEnd;
		}
		if (GC.Inst.IsInTurnMode())
		{
			if (movement.apAllowance > 0)
			{
				UpdateAPForMovement();
			}
			HideVFXForMovement();
			NotifyAbilitiesMovementBegan();
			yield return Wait.ForChildren;
		}
		Vector3 targetPosNext = movement.path.positions[1];
		targetPosNext = map.LocalPosToWorldPos(targetPosNext);
		if (movement.transitionAnim.IncludesIn() && unitModel.crouched)
		{
			yield return ModelPlayAnim(UnitModel.AnimID.TransCCrouchToCIdle, targetPosNext);
			if (movementCancelled)
			{
				goto IL_13f8;
			}
		}
		OnCommandedToMove.Trigger();
		OnExitTile();
		lastPathPtIdx = movement.path.positions.Count - 1;
		if (!string.IsNullOrEmpty(charData.ambientMovementSound))
		{
			ambientLoop = AC.Inst.PlayOneShot3D(charData.ambientMovementSound, _GetTransform().position);
		}
		for (pathPtIdx = 0; pathPtIdx < lastPathPtIdx; pathPtIdx++)
		{
			if (drawPathingEffect)
			{
				map.VFXTiles.pathVFXDrawBounds.x = pathPtIdx + 1;
				VFXTileController vFXTiles = map.VFXTiles;
				NC.Path path = movement.path;
				bool complete = true;
				bool showSelectionBox = false;
				bool usePathDrawBounds = true;
				bool makePathRed = teamType == UnitTeam.Type.Enemy;
				vFXTiles.PathShow(path, complete, showSelectionBox, usePathDrawBounds, startTrickleEffect: false, makePathRed);
			}
			Vector3 posStart = movement.path.positions[pathPtIdx];
			Vector3 posEnd = movement.path.positions[pathPtIdx + 1];
			uint pathInfo = movement.path.pathInfo[pathPtIdx];
			if ((pathInfo & 0x20000u) != 0)
			{
				UnitModel.AnimID? overrideAnimID = movement.overrideAnimID;
				if (!overrideAnimID.HasValue)
				{
					string animName = unitModel.animName;
					UnitModel.AnimID currentAnim = UnitModel.GetAnimIDByName(animName);
					Vector3 targetPos = map.LocalPosToWorldPos(posEnd);
					v2i startCoord = map.LocalPosToCoord(posStart);
					v2i endCoord = map.LocalPosToCoord(posEnd);
					yield return Wait.While(LookAt(targetPos));
					yield return Wait.ForSteps(3uL);
					if (!movementShouldCancel)
					{
						OnUnitStartedVault(startCoord, endCoord);
						yield return ModelPlayAnim(UnitModel.AnimID.Vault);
						OnUnitVaulted(startCoord, endCoord);
						if (!movementShouldCancel)
						{
							if (pathPtIdx + 1 == lastPathPtIdx)
							{
								ModelPlayAnim(UnitModel.AnimID.CombatIdle);
								animName = unitModel.GetAnimName(UnitModel.AnimID.CombatIdle);
							}
							else
							{
								ModelPlayAnim(currentAnim);
							}
							while (!unitModel.IsPlayingAnim(animName))
							{
								yield return null;
							}
							WarpToLocalMapPosition(posEnd);
							goto IL_0e4c;
						}
					}
					goto IL_13f8;
				}
			}
			PlayMovementAnim();
			float timeMax = CalculateMoveTime(posStart, posEnd);
			if (pathPtIdx == 0)
			{
				movementAccelerator.Value = 0f;
				movementAccelerator.AnimateTo(1f, timeMax * 0.75f);
			}
			else if (pathPtIdx == lastPathPtIdx - 1)
			{
				movementAccelerator.Value = 1f;
				movementAccelerator.AnimateTo(0.25f, timeMax * 0.25f, timeMax * 0.75f);
			}
			else
			{
				movementAccelerator.Value = 1f;
			}
			SC.Inst.UpdateAllUnitStatusBars();
			float time = timeMax;
			while (time > 0f)
			{
				yield return Wait.UntilNextUpdate();
				if (movement.pauseRoutines.Length != 0)
				{
					for (int k = movement.pauseRoutines.sLength - 1; k >= 0; k--)
					{
						yield return Wait.While(movement.pauseRoutines[k].running);
						movement.pauseRoutines.RemoveAtIndex((uint)k);
					}
					PlayMovementAnim();
				}
				movementAccelerator.Update(Time.deltaTime);
				AdvanceMovement(ref time, timeMax, posStart, posEnd, pathPtIdx, lastPathPtIdx);
				if (UpdateObservedTilesAndCheckIfSpotted())
				{
					lastPathPtIdx = pathPtIdx + 1;
					if (movement.reservedDest && movement.shouldReserveTile)
					{
						map.UnreserveAccessToCoord(movement.destCoord);
						movement.reservedDest = false;
					}
					movement.destCoord = map.LocalPosToCoord(movement.path.positions[lastPathPtIdx]);
					movement.result = Movement.Result.Spotted;
				}
				if (ambientLoop.isValid())
				{
					ambientLoop.set3DAttributes(_GetTransform().position.to3DAttributes());
				}
			}
			goto IL_0e4c;
			IL_0e4c:
			if (GC.Inst.IsInTurnMode())
			{
				NotifyAbilitiesEnteredCoordForMovement(map.LocalPosToCoord(posEnd));
			}
			if (!movement.ignoreTileTriggers)
			{
				yield return Routine.Start(onUnitEnterCoord, MR.Inst.Host, MR.Inst.mainHagisSequence);
			}
			if (teamType != UnitTeam.Type.NPC && GC.Inst.IsInTurnMode() && !movement.ignoreOverwatch)
			{
				ConstArray<Unit> activeUnits = GC.Inst.GetUnitsActive();
				int j = 0;
				for (int q = activeUnits.sLength; j < q; j++)
				{
					Unit attacker = activeUnits[j];
					if (attacker.GetTeamType() == teamType || !attacker.IsInOverwatch || !IsAlive())
					{
						continue;
					}
					Unit target = this;
					v2i targetCoord = target.coord;
					if (!(attacker.map == map) || !map.HasLineOfSight(attacker.coord, targetCoord, isSideStepAllowed: false))
					{
						continue;
					}
					float rangeSquared = attacker.overwatch.range * attacker.overwatch.range;
					int distanceSquared = v2i.DistanceSqr(coord, attacker.coord);
					if ((!attacker.overwatch.isCloseRange || !((float)distanceSquared <= rangeSquared)) && (attacker.overwatch.isCloseRange || !((float)distanceSquared > rangeSquared)))
					{
						continue;
					}
					bool attackerMovementDisabled = attacker.IsMovementDisabled;
					bool attackerAttackDisabled = attacker.IsAttackingDisabled;
					foreach (AbilityImplBase ability in attacker.abilities.OnUnitAndTeam())
					{
						if ((attackerMovementDisabled && ability.RequiresMovement()) || (attackerAttackDisabled && ability.RequiresAttack()))
						{
							continue;
						}
						if (ability.OnUnitEnteredCoord(attacker, this, movement.path.coordStart))
						{
							StopMovement();
						}
						yield return Wait.ForChildren;
						if ((bool)attacker.attacking || attacker.attack.markedToRunBy != null)
						{
							ModelPlayAnim(UnitModel.AnimID.CombatIdle);
						}
						yield return Wait.While(attacker.attacking);
						if (IsAlive())
						{
							continue;
						}
						goto IL_13f8;
					}
				}
				if (!movementShouldCancel)
				{
					bool flag = lastPathPtIdx - 1 > pathPtIdx;
					if (!unitModel.PlayIsDirty && flag)
					{
						ModelPlayAnim((!GC.Inst.IsInTurnMode()) ? UnitModel.AnimID.DefaultWalk : UnitModel.AnimID.CombatWalk);
					}
				}
			}
			if (movementShouldCancel)
			{
				goto IL_13f8;
			}
		}
		WarpToLocalMapPosition(map.CoordToLocalPos(movement.destCoord));
		goto IL_131d;
	}

	private Movement.Result ValidateMove(v2i? destCoord, NC.Path path, int apAllowance, IfTooFar tooFarBehaviour, NC.PathingCellValidator pathValidator)
	{
		if ((bool)moving)
		{
			return Movement.Result.NotReady;
		}
		if (apAllowance > 0 && GC.Inst.IsInTurnMode() && AP == 0)
		{
			return Movement.Result.LackingAP;
		}
		if (destCoord.HasValue && destCoord.GetValueOrDefault() == coord)
		{
			return Movement.Result.Arrived;
		}
		if (destCoord.HasValue && !map.CoordExists(destCoord.Value))
		{
			return Movement.Result.InvalidDest;
		}
		if (destCoord.HasValue && pathValidator != null && !pathValidator(destCoord.Value))
		{
			return Movement.Result.InvalidDest;
		}
		if (!GC.Inst.IsInCutsceneMode() && Singleton<PC>.Inst.GetLeader() == this && map.IsCoordReserved((!destCoord.HasValue) ? path.coordEnd : destCoord.Value))
		{
			return Movement.Result.DestReserved;
		}
		return Movement.Result.None;
	}

	public int GetAPNeededToReachCoord(v2i coord, bool allowNeighbouringTiles = true)
	{
		int movementDistancePerTurn = GetMovementDistancePerTurn();
		if (movementDistancePerTurn == 0)
		{
			return 0;
		}
		if (allowNeighbouringTiles && v2i.IsNeighbour(coord, this.coord))
		{
			return 0;
		}
		if (coord == this.coord)
		{
			return 0;
		}
		if (!map.CoordExists(coord))
		{
			return int.MaxValue;
		}
		int[] costs = Area.costs;
		int x = coord.x;
		int y = coord.y;
		v2i maxMapSize = Map.maxMapSize;
		int num = costs[x + y * maxMapSize.x] - 1;
		if (allowNeighbouringTiles)
		{
			num--;
		}
		if (movementDistancePerTurn == 0)
		{
			return int.MaxValue;
		}
		return num / movementDistancePerTurn + 1;
	}

	private void UpdateAPForMovement()
	{
		APDecrement(GetAPNeededToReachCoord(movement.destCoord, allowNeighbouringTiles: false));
	}

	private void HideVFXForMovement()
	{
		HideMovementArea();
		map.VFXTiles.CoverPredictorHide();
	}

	private void NotifyAbilitiesMovementBegan()
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitMoveBegin(this, movement.destCoord);
		}
	}

	private void PlayMovementAnim()
	{
		UnitModel.AnimID? overrideAnimID = movement.overrideAnimID;
		if (!overrideAnimID.HasValue)
		{
			if (GC.Inst.IsInTurnMode())
			{
				ModelPlayAnim(UnitModel.AnimID.CombatWalk);
			}
			else if (movement.isShortMovement)
			{
				ModelPlayAnim(UnitModel.AnimID.DefaultSlowWalk);
			}
			else
			{
				ModelPlayAnim(UnitModel.AnimID.DefaultWalk);
			}
		}
		else
		{
			UnitModel.AnimID? overrideAnimID2 = movement.overrideAnimID;
			ModelPlayAnim(overrideAnimID2.Value);
		}
	}

	private void AdvanceMovement(ref float time, float timeMax, Vector3 posStart, Vector3 posEnd, int pathPtIdx, int lastPathPtIdx)
	{
		time = Mathf.Max(time - Time.deltaTime * movementAccelerator.Value, 0f);
		float t = 1f - time / timeMax;
		Vector3 p = ((pathPtIdx <= 0) ? (posStart - (posEnd - posStart)) : movement.path.positions[pathPtIdx - 1]);
		Vector3 p2 = ((pathPtIdx >= lastPathPtIdx - 1) ? (posEnd + (posEnd - posStart)) : movement.path.positions[pathPtIdx + 2]);
		Vector3 vector = CatmullRom(p, posStart, posEnd, p2, t);
		Vector3 positionLS = GetPositionLS();
		WarpToLocalMapPosition(vector);
		if (movement.orientateAlongPath)
		{
			vector.y = 0f;
			positionLS.y = 0f;
			Vector3 vector2 = vector - positionLS;
			if (vector2.sqrMagnitude > Mathf.Epsilon)
			{
				unitModel.LookAtDirectionLSDIncremental(vector2.normalized);
			}
		}
	}

	private void OnUnitStartedVault(v2i vaultStart, v2i vaultEnd)
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitStartedVault(this, vaultStart, vaultEnd);
		}
	}

	private void OnUnitVaulted(v2i vaultStart, v2i vaultEnd)
	{
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			item.OnUnitVaulted(this, vaultStart, vaultEnd);
		}
	}

	private void NotifyAbilitiesEnteredCoordForMovement(v2i coord)
	{
		ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
		int num = unitsActive.sLength;
		while (--num >= 0)
		{
			Unit unit = unitsActive[num];
			if (unit == this)
			{
				continue;
			}
			bool isMovementDisabled = unit.IsMovementDisabled;
			bool isAttackingDisabled = unit.IsAttackingDisabled;
			foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
			{
				if ((!isMovementDisabled || !item.RequiresMovement()) && (!isAttackingDisabled || !item.RequiresAttack()))
				{
					item.OnOtherUnitEnteredCoord(unit, this, coord);
				}
			}
		}
	}

	private void BarkForMovementArrival()
	{
		CoverType coverBetweenAllEnemies = Singleton<MC>.Inst.GetActiveMap().GetCoverBetweenAllEnemies(coord, this);
		if (coverBetweenAllEnemies.Is(CoverType.None) || coverBetweenAllEnemies.Is(CoverType.Flanked))
		{
			PlayBark(BarkTypes.MoveCombatGeneric);
		}
		else if (IsFlankingAnyEnemyUnit())
		{
			PlayBark(BarkTypes.MoveFlanking);
		}
		else if (coverBetweenAllEnemies.Is(CoverType.Half))
		{
			PlayBark(BarkTypes.MoveHalfCover);
		}
		else
		{
			PlayBark(BarkTypes.MoveFullCover);
		}
	}

	private void NotifyAbilitiesMovementEnded()
	{
		bool isMovementDisabled = IsMovementDisabled;
		bool isAttackingDisabled = IsAttackingDisabled;
		foreach (AbilityImplBase item in abilities.OnUnitAndTeam())
		{
			if ((!isMovementDisabled || !item.RequiresMovement()) && (!isAttackingDisabled || !item.RequiresAttack()))
			{
				item.OnUnitMoveEnd(this);
			}
		}
	}

	public void OnMovementComplete()
	{
		OnEnterTile();
		teamController.OnUnitFinishedMoving(this);
		NotifyAbilitiesMovementEnded();
		SC.Inst.UpdateAllUnitStatusBars(updateCover: true);
		movement.path = null;
		if (movement.updateIdleOnCompletion && !unitModel.interacting && !attacking)
		{
			UpdateIdleAnim();
		}
		Dispatch(movement.result);
		map.VFXTiles.PathHide();
		if (movement.reservedDest && movement.shouldReserveTile)
		{
			map.UnreserveAccessToCoord(movement.destCoord);
		}
		if ((bool)pickingUp)
		{
			_PickUpImmediate(pickup.itemMeta, pickup.quantity, pickup.lootTile);
			pickup.host.Pause(pickup);
			pickup.Reset();
		}
	}

	private Movement.Result Dispatch(Movement.Result result, Movement.ResultHandler handleResultIn = null)
	{
		if (handleResultIn != null)
		{
			handleResultIn(this, result);
		}
		else if (movement.handleResult != null)
		{
			handleResultIn = movement.handleResult;
			movement.handleResult = null;
			handleResultIn(this, result);
		}
		return result;
	}

	public float CalculateMoveTime(Vector3 a, Vector3 b)
	{
		a.y = 0f;
		b.y = 0f;
		float num = Vector3.Distance(a, b);
		float? overrideSpeed = movement.overrideSpeed;
		float num2;
		if (!overrideSpeed.HasValue || movement.overrideSpeed == 0f)
		{
			num2 = (GC.Inst.IsInTurnMode() ? charData.movementSpeedInCombat : ((!movement.isShortMovement) ? charData.movementSpeed : charData.movementSpeedShortDist));
		}
		else
		{
			float? overrideSpeed2 = movement.overrideSpeed;
			num2 = overrideSpeed2.Value;
		}
		float num3 = num / num2;
		return num / num2;
	}

	public static Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
	{
		Vector3 vector = 0.5f * (2f * p1);
		Vector3 vector2 = 0.5f * (p2 - p0);
		Vector3 vector3 = 0.5f * (2f * p0 - 5f * p1 + 4f * p2 - p3);
		Vector3 vector4 = 0.5f * (-p0 + 3f * p1 - 3f * p2 + p3);
		float num = t * t;
		return vector + vector2 * t + vector3 * num + vector4 * num * t;
	}

	public void PauseMovement(HagletResettable waitForRoutine)
	{
		movement.pauseRoutines.Add(waitForRoutine);
	}

	public IEnumerator<HagletYieldTerm> OnUnitEnterCoordRoutine()
	{
		Map startingMap = map;
		int j = map.tileObjectsWithUnitEvents.Length;
		while (true)
		{
			int num;
			j = (num = j - 1);
			if (num < 0 || (MR.Inst.IsSkipping() && (j < 0 || j >= map.tileObjectsWithUnitEvents.Length)))
			{
				break;
			}
			map.tileObjectsWithUnitEvents[j].OnUnitEnterCoord(this);
			yield return Wait.ForChildren;
		}
		int i = map.trapTiles.sLength;
		while (true)
		{
			int num;
			i = (num = i - 1);
			if (num >= 0)
			{
				map.trapTiles[i].OnUnitEnterCoord(this);
				yield return Wait.ForChildren;
				continue;
			}
			break;
		}
	}

	public void OnUnitExitCoord()
	{
		int num = map.tileObjectsWithUnitEvents.Length;
		while (--num >= 0)
		{
			map.tileObjectsWithUnitEvents[num].OnUnitExitCoord(this);
		}
		int num2 = map.trapTiles.sLength;
		while (--num2 >= 0)
		{
			map.trapTiles[num2].OnUnitExitCoord(this);
		}
	}

	public bool StartStepOut(OctDir dir, Unit targetUnit = null)
	{
		if (IsSteppedOut && coord + dir == steppedOutCoord)
		{
			return false;
		}
		if ((bool)stepOut.running)
		{
			coord = preStepOutCoord;
			stepOut.host.Pause(stepOut);
			stepOut.Reset();
		}
		colliderEnabled = false;
		postStepOutTarget = targetUnit;
		preStepOutCoord = coord;
		steppedOutCoord = coord + dir;
		stepOutAnimStartLocalPos = _GetTransform().localPosition;
		stepOutAnimEndLocalPos = Vector3.Lerp(map.CoordToLocalPos(preStepOutCoord), map.CoordToLocalPos(steppedOutCoord), 0.5f);
		IsSteppedOut = true;
		Routine.Start(stepOut, MR.Inst.Host);
		return true;
	}

	public void StartStepBackIn()
	{
		if ((bool)stepOut.running)
		{
			coord = preStepOutCoord;
			stepOut.host.Pause(stepOut);
			stepOut.Reset();
		}
		postStepOutTarget = null;
		stepOutAnimEndLocalPos = map.CoordToLocalPos(preStepOutCoord);
		stepOutAnimStartLocalPos = _GetTransform().localPosition;
		steppedOutCoord = preStepOutCoord;
		IsSteppedOut = false;
		Routine.Start(stepOut, MR.Inst.Host);
	}

	private IEnumerator<HagletYieldTerm> StepOutRoutine()
	{
		Vector3 lookDir = (stepOutAnimEndLocalPos - stepOutAnimStartLocalPos).normalized;
		unitModel.Play(UnitModel.AnimID.CombatWalk);
		float timeMax2 = CalculateMoveTime(stepOutAnimStartLocalPos, stepOutAnimEndLocalPos);
		timeMax2 *= 2f;
		float time2 = 0f;
		while (time2 < timeMax2)
		{
			yield return Wait.UntilNextUpdate();
			time2 += Time.deltaTime;
			time2 = Mathf.Clamp01(time2);
			Vector3 posInterp = Vector3.Lerp(t: Mathf.Sin(time2 / timeMax2 * (float)Math.PI * 0.5f), a: stepOutAnimStartLocalPos, b: stepOutAnimEndLocalPos);
			WarpToLocalMapPosition(posInterp);
			unitModel.LookAtDirectionLSDIncremental(lookDir);
		}
		coord = preStepOutCoord;
		if (postStepOutTarget != null)
		{
			if (SC.Inst.GetActiveAbility() == null)
			{
				AimAtTarget(postStepOutTarget.GetPositionWS());
				yield break;
			}
			UpdateIdleAnim();
			LookAt(postStepOutTarget.GetPositionWS());
		}
		else
		{
			UpdateIdleAnim();
			colliderEnabled = true;
		}
	}

	private IEnumerator<HagletYieldTerm> PickUpItemRoutine()
	{
		if (pickup.canPickupItem)
		{
			if (GC.Inst.IsInCombatMode())
			{
				PlayBark(BarkTypes.CollectCombat);
			}
			else
			{
				PlayBark(BarkTypes.CollectGeneral);
			}
			UnitModel.AnimID pickupAnim = ((!GC.Inst.IsInCombatMode()) ? UnitModel.AnimID.DefaultPickup : UnitModel.AnimID.CombatPickup);
			bool hasPickUpItemEvent = unitModel.GetEventCount<UnitAnimFuncs_OnPickUp>(unitModel.GetAnimName(pickupAnim)) > 0;
			unitModel.Play(unitModel.GetAnimName(pickupAnim), looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
			if (hasPickUpItemEvent)
			{
				yield return Wait.Until(unitModel.AnimFuncs.TriggerOnEvent(UnitAnimFuncs.Event.PickUp));
			}
			else
			{
				yield return Wait.ForChildren;
			}
			_PickUpImmediate(pickup.itemMeta, pickup.quantity, pickup.lootTile);
			if (!MR.Inst.IsSkipping() && !string.IsNullOrEmpty(pickup.sfxInteractionEventPath))
			{
				FMOD.Studio.EventInstance handle = AC.Inst.GetHandle(pickup.sfxInteractionEventPath);
				if (handle.isValid())
				{
					handle.set3DAttributes(ACMisc.to3DAttributes(base.gameObject));
					handle.start();
					handle.release();
				}
			}
			pickup.itemMeta = null;
			pickup.lootTile = null;
			pickup.quantity = 0;
			if (unitModel.currentClip.name == unitModel.GetAnimName(pickupAnim))
			{
				yield return unitModel.OnAnimComplete;
			}
		}
		else
		{
			PlayBark(BarkTypes.CannotCollect);
			if (!HACK_messageQueued)
			{
				popupBar.Enqueue("POPUP_INVENTORY_FULL", 0, 1.5f, null, HACK_CompletePopupQueue);
				HACK_messageQueued = true;
			}
		}
	}

	private void HACK_CompletePopupQueue()
	{
		HACK_messageQueued = false;
	}

	public void _PickUpImmediate(ItemStackMeta itemMeta, int quantity = 1, TileObjectBase lootTile = null)
	{
		if (quantity > 0)
		{
			int itemCount = Party.Inst.GetItemCount(itemMeta);
			uint storageLimit = itemMeta.StorageLimit;
			int num = Mathf.Min(quantity, (int)storageLimit - itemCount);
			if (lootTile != null)
			{
				lootTile.gameObject.SetActive(value: false);
				SaveData.mission.tileObjectActives[lootTile.idGenerated] = false;
			}
			int? num2 = null;
			if (itemMeta.category == ItemType.JUNK)
			{
				num2 = itemMeta.price * quantity;
			}
			UIUnitPopupBar uIUnitPopupBar = popupBar;
			string displayName = itemMeta.displayName;
			int? currency = num2;
			uIUnitPopupBar.Enqueue(displayName, quantity, 0f, null, null, null, currency);
			if (itemMeta.ItemEnum == Item.Scrap_Metal)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.pickedUpScrap, Tutorials.dialogPickedUpScrap);
			}
			else if (itemMeta.ItemEnum == Item.Circuitry)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.pickedUpCircuitry, Tutorials.dialogPickedUpCircuitry);
			}
			else if (itemMeta.ItemEnum == Item.Jewellery)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.pickedUpJewellery, Tutorials.dialogPickedUpJewellery);
			}
			else if (itemMeta.ItemEnum == Item.Atlantium_Core)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.pickedUpAtlatium, Tutorials.dialogPickedUpAtlatium);
			}
			else if (itemMeta.ItemEnum == Item.Rejection_Shot)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.pickedUpRejectionShot, Tutorials.dialogPickedUpRejectionShot);
			}
			else if (itemMeta.ItemEnum == Item.Augment)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.acquiredAugment, Tutorials.dialogAcquiredAugment);
			}
			else if (itemMeta.ItemEnum == Item.Medpack)
			{
				Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.acquiredMedkit, Tutorials.dialogAcquiredMedkit);
			}
			AC.Inst.PlayOneShot2D(itemMeta.pickupFmodEventPath);
			Party.Inst.AddItemToInventory(itemMeta, quantity);
		}
	}

	public HagletYieldTerm PickupItem(ItemStackMeta itemMeta, int quantity = 1, TileObjectBase lootTile = null, string sfxInteractionEventPath = null)
	{
		if ((bool)pickup.running)
		{
			return Wait.While(pickup.running);
		}
		pickup.itemMeta = itemMeta;
		pickup.quantity = quantity;
		pickup.sfxInteractionEventPath = sfxInteractionEventPath;
		int itemCount = Party.Inst.GetItemCount(pickup.itemMeta);
		uint storageLimit = pickup.itemMeta.StorageLimit;
		pickup.canPickupItem = itemCount < storageLimit;
		pickup.lootTile = lootTile;
		HagletYieldTerm result = Routine.Start(pickup, MR.Inst.Host, MR.Inst.mainHagisSequence);
		if ((bool)moving)
		{
			PauseMovement(pickup);
		}
		return result;
	}

	public float GetPickupDelay()
	{
		return 0.9f;
	}

	public float GetInteractDelay()
	{
		return 0.9f;
	}

	public void StartShove(OctDir shovePreferredDirection, int distance, Combat.HitType hitType, float? speed = null, bool mustMove = false, Shove.Result result = null, Unit meleeAttacker = null)
	{
		shove.direction = shovePreferredDirection;
		shove.distance = distance;
		shove.speed = speed;
		shove.result = result;
		shove.meleeAttacker = meleeAttacker;
		shove.hitType = hitType;
		shove.mustMove = mustMove;
		if (shove.result != null)
		{
			shove.result.value = Shove.ResultEnum.InProgress;
		}
		Routine.Start(shove, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	public IEnumerator<HagletYieldTerm> ShoveRoutine()
	{
		yield return Routine.ResetToHere();
		yield return ShoveCoordCalc.Run(coord, shove.direction, shove.mustMove, shove.distance);
		if (ShoveCoordCalc.Result.HasValue && shove.result != null)
		{
			shove.result.value = ShoveCoordCalc.Result.Value;
		}
		Unit attacker = shove.meleeAttacker;
		if (HP > 0 && attacker != null && attacker.MeleeWeapon != null)
		{
			attacker.attack.weapon = attacker.MeleeWeapon;
			Routine.Start(attacker.attackBeginPhase, MR.Inst.Host);
			yield return Wait.ForChildren;
			attacker.NotifyAbilitiesAttackEnd();
			attacker.UncloakUnitIfNeeded();
			attacker.CheckAndPossiblyEndStealth();
		}
		if (ShoveCoordCalc.Result == Shove.ResultEnum.UnitTeleported)
		{
			yield return SetCoord(ShoveCoordCalc.EndCoord);
		}
		else
		{
			Vector3 shoveDir = shove.direction.ToV3XZ();
			unitModel.LookAtDirectionLS(-shoveDir);
			PSC.Inst.Play(ParticleTypes.Shove, GetPositionLS(), Quaternion.LookRotation(shoveDir, Vector3.up), Vector3.one, map.transform);
			StartMovement(ShoveCoordCalc.EndCoord, overrideSpeed: shove.speed, path: null, handleResult: null, endFacing: null, apAllowance: 0, ifDestIsTooFar: IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: false, updateIdleOnCompletion: false, transitionAnim: TransitionAnim.Out, overrideAnimationID: UnitModel.AnimID.CombatHit, vaultAllowed: VaultAllowed.No, ignoreUnitAtDestination: false, skipAdopter: null, ignoreShortMovementAnim: false, avoidUnits: false, shouldReserveTile: true, forceWalk: false, ignoreTileTriggers: false, pathCellValidator: null, playArrivalBark: false);
			yield return Wait.ForChildren;
			if (ShoveCoordCalc.HitObstruction && coord == ShoveCoordCalc.EndCoord)
			{
				Singleton<MC>.Inst.MapShake.ShakeOneShot(0.75f);
				PSC.Inst.Play(ParticleTypes.Shockwave, map, coord);
				if (shove.result != null)
				{
					shove.result.value = Shove.ResultEnum.UnitHitObstruction;
				}
			}
			else if (shove.result != null)
			{
				shove.result.value = Shove.ResultEnum.UnitShoved;
			}
		}
		attacker.HandleAttackResult(this, shove.hitType);
		yield return Wait.ForChildren;
		UpdateIdleAnim();
	}

	public bool StartSnapToPosition(v2i coord, OctDir? direction = null, bool waitForModelToSnap = false, bool turnOnBlending = true, bool activate = false)
	{
		snapToPosition.destCoord = coord;
		snapToPosition.direction = direction;
		snapToPosition.delayForAnimation = waitForModelToSnap;
		snapToPosition.turnOnBlending = turnOnBlending;
		snapToPosition.activate = activate;
		if ((bool)snapToPosition.running)
		{
			snapToPosition.host.Pause(snapToPosition);
			snapToPosition.Reset();
		}
		Routine.Start(snapToPosition, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return true;
	}

	private IEnumerator<HagletYieldTerm> SnapToPositionRoutine()
	{
		if (snapToPosition.delayForAnimation)
		{
			yield return Wait.ForSteps(2uL);
		}
		yield return SetCoord(snapToPosition.destCoord);
		OctDir? direction = snapToPosition.direction;
		if (direction.HasValue)
		{
			UnitModel obj = unitModel;
			OctDir? direction2 = snapToPosition.direction;
			obj.LookAtDirectionLS(direction2.Value.ToV3XZ());
		}
		if (snapToPosition.turnOnBlending)
		{
			unitModel.SetBlending(blend: true);
		}
		if (snapToPosition.activate)
		{
			Show(null, HologramAnim.DEFAULT, updateIdleAnim: false);
		}
	}

	public SwapMap.Result StartSwapMap(TileActionSwapMap swapTile, bool isSwapTileFromCurrentMap, bool isTeleportIn, UnitTarget targetIn = null, float? overrideSpeed = null, bool faceExit = false, SwapMap.ResultHandler handleResultIn = null)
	{
		SwapMap.Result result = ValidateSwapMap();
		if (result != 0)
		{
			return Dispatch(result, handleResultIn);
		}
		swapMap.swapTile = swapTile;
		swapMap.isSwapTileFromCurrentMap = isSwapTileFromCurrentMap;
		swapMap.target = targetIn;
		swapMap.isTeleport = isTeleportIn;
		swapMap.overrideSpeed = overrideSpeed;
		swapMap.shouldFaceExit = faceExit;
		Routine.Start(swapMap, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return result;
	}

	private IEnumerator<HagletYieldTerm> SwapMapRoutine()
	{
		TileActionSwapMap swapTile = swapMap.swapTile;
		if (IsShown && !swapMap.isTeleport)
		{
			OctDir? facedir = null;
			if (swapMap.shouldFaceExit)
			{
				facedir = swapTile.exitDirection;
			}
			Unit unit = this;
			v2i? destCoord = swapTile.coord;
			float? overrideSpeed = swapMap.overrideSpeed;
			unit.StartMovement(destCoord, null, null, facedir, 0, IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, overrideSpeed);
			yield return Wait.ForChildren;
		}
		Map swapTileMap = ((!swapMap.isSwapTileFromCurrentMap) ? swapTile.GetMap() : swapTile.targetLinkedMap);
		v2i swapTileCoord = ((!swapMap.isSwapTileFromCurrentMap) ? swapTile.GetCoord() : swapTileMap.GetSwapTileAtIndex(swapTile.targetSwapTileIndex).coord);
		StartTeleport(swapTileCoord, swapTileMap, null, manuallyHandleShowing: false, deactivateForTeleport: false, lookAtDest: false);
		yield return Wait.ForChildren;
		if (swapMap.target != null)
		{
			if (IsShown)
			{
				Unit unit2 = this;
				v2i? destCoord = swapMap.target.GetCoord();
				float? overrideSpeed = swapMap.overrideSpeed;
				unit2.StartMovement(destCoord, null, null, null, 0, IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, overrideSpeed);
				yield return Wait.ForChildren;
			}
			else
			{
				StartTeleport(swapMap.target);
				yield return Wait.ForChildren;
			}
		}
		swapMap.result = SwapMap.Result.Completed;
		Dispatch(swapMap.result);
		CleanupSwapMap();
	}

	private SwapMap.Result ValidateSwapMap()
	{
		return SwapMap.Result.None;
	}

	public void CleanupSwapMap()
	{
		swapMap.swapTile = null;
		swapMap.isSwapTileFromCurrentMap = false;
		swapMap.target = null;
		swapMap.isTeleport = false;
		SwapMap.Result result = swapMap.result;
		swapMap.result = SwapMap.Result.None;
		MR.Inst.Host.Pause(swapMap);
	}

	private SwapMap.Result Dispatch(SwapMap.Result result, SwapMap.ResultHandler handleResultIn = null)
	{
		if (handleResultIn != null)
		{
			handleResultIn(this, result);
		}
		else if (swapMap.handleResult != null)
		{
			handleResultIn = swapMap.handleResult;
			swapMap.handleResult = null;
			handleResultIn(this, result);
		}
		return result;
	}

	public bool StartTeleport(v2i destCoordIn, Map destMapIn = null, Teleport.ResultHandler handleResultIn = null, bool manuallyHandleShowing = false, bool deactivateForTeleport = false, bool lookAtDest = true, OctDir? lookDirectionOnTeleportFinished = null, UnitModel.AnimID? overrideStartAnim = null, UnitModel.AnimID? overrideArriveAnim = null, bool ignoreAnimation = false)
	{
		if (destMapIn == null)
		{
			destMapIn = map;
		}
		if (!ValidateTeleport(destCoordIn, destMapIn))
		{
			return Dispatch(success: false, handleResultIn);
		}
		teleport.destCoord = destCoordIn;
		teleport.destMap = destMapIn;
		teleport.handleResult = handleResultIn;
		teleport.manuallyHandleShowing = manuallyHandleShowing;
		teleport.deactivateForTeleport = deactivateForTeleport;
		teleport.lookAtDest = lookAtDest;
		teleport.lookDirectionOnTeleportFinished = lookDirectionOnTeleportFinished;
		teleport.overrideStartAnim = overrideStartAnim;
		teleport.overrideArriveAnim = overrideArriveAnim;
		teleport.ignoreAnimation = ignoreAnimation;
		Routine.Start(teleport, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return true;
	}

	public bool StartTeleport(UnitTarget target)
	{
		return StartTeleport(target.GetCoord(), target.GetMap());
	}

	public bool StartTeleport(Vector3 worldPos)
	{
		return StartTeleport(map.WorldPosToCoord(worldPos));
	}

	private IEnumerator<HagletYieldTerm> TeleportRoutine()
	{
		NC.Neighbors neighbors = null;
		NC.NeighborRequestComplete storeNeighbors = delegate(NC.Neighbors n, Unit u)
		{
			neighbors = n;
		};
		yield return Routine.ResetToHere();
		if (GetTeam().GetTeamLeader() == this)
		{
			HideMovementArea();
		}
		yield return Wait.UntilNextUpdate();
		if ((teleport.destMap == null || teleport.destMap == Singleton<MC>.Inst.GetActiveMap()) && GC.Inst.GetUnitAtCoord(teleport.destCoord) != null)
		{
			yield return Wait.While(NC.Inst.CalculateNeighbors(teleport.destCoord, coord, 1u, this, includeObstructedDiagonals: true, storeNeighbors));
			if (neighbors != null && neighbors.coordsNeighbors != null && neighbors.coordsNeighbors.Count > 0)
			{
				teleport.destCoord = neighbors.coordsNeighbors[0];
			}
		}
		if (teleport.lookAtDest && base.isActiveAndEnabled)
		{
			yield return Wait.While(LookAt(map.CoordToWorldPos(teleport.destCoord)));
		}
		if (map.IsUnitsVisible)
		{
			HologramAnim context = HologramAnim.DEFAULT;
			if (GC.Inst.IsInTurnMode())
			{
				context = HologramAnim.UNIT_LEAP;
				if (!teleport.ignoreAnimation)
				{
					UnitModel.AnimID? overrideStartAnim = teleport.overrideStartAnim;
					if (!overrideStartAnim.HasValue)
					{
						unitModel.Play(UnitModel.AnimID.CombatTeleportBegin);
					}
					else
					{
						UnitModel obj = unitModel;
						UnitModel.AnimID? overrideStartAnim2 = teleport.overrideStartAnim;
						obj.Play(overrideStartAnim2.Value);
					}
				}
			}
			Hide(teleport.deactivateForTeleport, context);
			yield return Wait.ForChildren;
		}
		if ((bool)moving)
		{
			StopMovement(immediate: true);
		}
		yield return SetCoord(teleport.destCoord, teleport.destMap);
		OctDir? lookDirectionOnTeleportFinished = teleport.lookDirectionOnTeleportFinished;
		if (lookDirectionOnTeleportFinished.HasValue)
		{
			unitModel.LookAtDirectionLS(lookDirectionOnTeleportFinished.Value.ToV3XZ());
		}
		if (Singleton<MC>.Inst.GetActiveMap() == map && map.IsUnitsVisible && !teleport.manuallyHandleShowing)
		{
			if (!teleport.ignoreAnimation)
			{
				if (GC.Inst.IsInTurnMode())
				{
					UnitModel.AnimID? overrideArriveAnim = teleport.overrideArriveAnim;
					if (!overrideArriveAnim.HasValue)
					{
						unitModel.Play(UnitModel.AnimID.CombatTeleportEnd);
						goto IL_050e;
					}
				}
				UnitModel.AnimID? overrideArriveAnim2 = teleport.overrideArriveAnim;
				if (overrideArriveAnim2.HasValue)
				{
					UnitModel obj2 = unitModel;
					UnitModel.AnimID? overrideArriveAnim3 = teleport.overrideArriveAnim;
					obj2.Play(overrideArriveAnim3.Value);
				}
			}
			goto IL_050e;
		}
		if (Singleton<MC>.Inst.GetActiveMap() != map)
		{
			GC.Inst._RemoveActiveUnit(this);
		}
		goto IL_0570;
		IL_050e:
		Show(null, HologramAnim.DEFAULT, updateIdleAnim: false);
		yield return Wait.ForChildren;
		goto IL_0570;
		IL_0570:
		Dispatch(success: true);
		yield return Wait.ForChildren;
		SC.Inst.UpdateAllUnitStatusBars(updateCover: true);
		CleanupTeleport();
	}

	private bool ValidateTeleport(v2i destCoord, Map destMap)
	{
		if ((bool)teleporting)
		{
			return false;
		}
		if (coord == destCoord && destMap == map)
		{
			return false;
		}
		if (!destMap.CoordExists(destCoord))
		{
			return false;
		}
		return true;
	}

	public void CleanupTeleport()
	{
		teleport.destCoord.x = -10000;
		teleport.destMap = null;
		MR.Inst.Host.Pause(teleport);
	}

	public bool Dispatch(bool success, Teleport.ResultHandler handleResultIn = null)
	{
		if (handleResultIn != null)
		{
			handleResultIn(this, success);
		}
		else if (teleport.handleResult != null)
		{
			handleResultIn = teleport.handleResult;
			teleport.handleResult = null;
			handleResultIn(this, success);
		}
		return false;
	}
}
public class UnitHUD : MonoBehaviour
{
	private void Awake()
	{
	}

	private void LateUpdate()
	{
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - Singleton<CC>.Inst.transform.position, Vector3.up);
	}
}
public class UnitModel : MonoBehaviour, Serializer.ISelfComposer
{
	public enum AnimID
	{
		DefaultIdle,
		CombatIdle,
		CombatAimIdle,
		DefaultWalk,
		CombatWalk,
		DefaultPickup,
		DefaultInteract,
		CombatAttackMelee,
		CombatAttackMeleeMulti,
		CombatAttackRanged,
		CombatAttackRangedMulti,
		CombatCrouch,
		CombatDeath,
		WakeUp,
		FallAsleep,
		Sleeping,
		Vault,
		DefaultAlert,
		DefaultConfusion,
		CombatHit,
		CombatCrouchHit,
		CombatDodge,
		CombatCrouchDodge,
		CombatDodgeLeft,
		CombatDodgeRight,
		CombatTeleportBegin,
		CombatTeleportEnd,
		TransCCrouchToCIdle,
		TransCIdleToCCrouch,
		TransCIdleToDIdle,
		TransDIdleToCIdle,
		TransCIdleToAIdle,
		TransAIdleToCIdle,
		DefaultSlowWalk,
		AbilityTrap,
		AbilityDetect,
		AbilityBreak,
		CombatHacked,
		AbilityGrabHit,
		TransGIdleToCIdle,
		CombatUseItem,
		AbilityBrawl,
		AbilityInspire,
		CombatPickup,
		AbilityGrenade,
		AbilityTaunt,
		AbilityBackFist,
		AbilityDecoy,
		AbilityDisable,
		AbilityGroundPoundEnd,
		AreaShot,
		MAX
	}

	private struct SubModel
	{
		public KubrickAnimator animator;

		public GameObject gameObject;

		public Transform transform;

		public UnitAnimFuncs animFuncs;

		public WeaponModel weaponModelRanged;

		public WeaponXForm weaponXForm;

		public PropXForm propXForm;
	}

	private struct Configuration
	{
		public string animName;

		public bool crouched;

		public bool interacting;

		public bool looping;

		public bool updateIdleOnComplete;

		public static bool ShouldPlayNewAnim(UnitModel unitModel, Configuration current, Configuration newConf)
		{
			if (newConf.animName == null)
			{
				return false;
			}
			if (current != newConf || !current.looping)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(Configuration lhs, Configuration rhs)
		{
			return lhs.animName == rhs.animName && lhs.crouched == rhs.crouched && lhs.interacting == rhs.interacting && lhs.looping == rhs.looping;
		}

		public static bool operator !=(Configuration lhs, Configuration rhs)
		{
			return !(lhs == rhs);
		}
	}

	[Serializable]
	public class LookAt : HagletResettable
	{
		[ReadOnly]
		public UnitModel unitModel;

		public ComplexAngle from;

		public ComplexAngle to;

		public Action onComplete;

		public float duration;

		public LookAt(UnitModel unitToRotate)
			: base(unitToRotate.LookAtTargetRoutine(), unitToRotate.unit.charData.charName + " LookAtTarget")
		{
			unitModel = unitToRotate;
		}

		protected LookAt(BinaryReader reader)
			: base(reader)
		{
		}
	}

	[Serializable]
	private class QueuedAnimation : HagletResettable
	{
		public AnimID transitionAnim;

		public AnimID targetAnim;

		public bool updateIdleOnComplete;

		public QueuedAnimation(UnitModel um)
			: base(um.QueuedAnimationRoutine(), um.unit.charData.charName + " QueuedAnimationRoutine")
		{
		}

		protected QueuedAnimation(BinaryReader reader)
			: base(reader)
		{
		}
	}

	[Serializable]
	public class PlayAndIdle : HagletResettable
	{
		public string anim;

		public PlayAndIdle(UnitModel um)
			: base(um.PlayAndIdleRoutine())
		{
		}

		protected PlayAndIdle(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private static Dictionary<string, AnimID> stringToAnimID;

	[ReadOnly]
	public Unit unit;

	private int animCompActiveIdx;

	private SubModel[] subModels;

	private Transform rootBone;

	private Action updateIdleAction;

	private Configuration futureConfig;

	private Configuration currentConfig;

	private const float kTurnSpeed = 550f;

	private LookAt lookAt;

	private AnimComplexAngle animTurn = new AnimComplexAngle();

	[ReadOnly]
	public SkinnedMeshRenderer[] skinnedMeshRenderers;

	[ReadOnly]
	public Renderer[] renderers;

	[Serializer.Exclude]
	private Material[] unitMaterials;

	private string[] animNames;

	private string[] animOverrides;

	private static int colorHoloID;

	private static int colorTintID;

	private static int colorXRayHoloID;

	private static int colorSunColorID;

	private static int colorShadowColorID;

	private static int colorRimColorID;

	private static int incorpIntensity;

	private static int incorpBaseCol;

	private static int incorpRimCol;

	private static int incorpWaveCol;

	private static int incorpLinesCol;

	private static int dodgeIntensity;

	[Serializer.Exclude]
	private Material[][] materialsXRayHighlighted;

	[Serializer.Exclude]
	private Material[] materialsXRayNonHighlighted;

	private bool _playIsDirty;

	public AnimationCurve curve;

	private const float flagScale = 1E-12f;

	private bool _isBirdMode;

	[Serializer.Exclude]
	private AnimFloatHaglet xrayAnim;

	[Serializer.Exclude]
	private AnimFloatHaglet incorporealHagletFloat;

	private bool hack_enablingIncorporeal;

	[Serializer.Exclude]
	private AnimFloatHaglet dodgeHagletFloat;

	private bool enablingDodge;

	private Transform targetFocus;

	private QueuedAnimation queuedAnimation;

	public PlayAndIdle playAndIdleResettable;

	private new Transform transform => null;

	public Transform AnimCompTransform => AnimComp.transform;

	public SpriteRenderer BlobShadow { get; private set; }

	private KubrickAnimator AnimComp => subModels[animCompActiveIdx].animator;

	public UnitAnimFuncs AnimFuncs => subModels[animCompActiveIdx].animFuncs;

	public WeaponModel WeaponModelRanged => subModels[animCompActiveIdx].weaponModelRanged;

	public PropXForm PropXForm => subModels[animCompActiveIdx].propXForm;

	public WeaponXForm WeaponXForm => subModels[animCompActiveIdx].weaponXForm;

	public bool useModelRigVariant
	{
		get
		{
			return animCompActiveIdx == 1;
		}
		set
		{
			if (value)
			{
				subModels[0].gameObject.SetActive(value: false);
				subModels[1].gameObject.SetActive(value: true);
				subModels[1].transform.localRotation = subModels[0].transform.localRotation;
				animCompActiveIdx = 1;
			}
			else
			{
				if (subModels.Length > 1)
				{
					subModels[1].gameObject.SetActive(value: false);
					subModels[0].transform.localRotation = subModels[1].transform.localRotation;
				}
				subModels[0].gameObject.SetActive(value: true);
				animCompActiveIdx = 0;
			}
			FindRootBone();
		}
	}

	public bool isPlaying => AnimComp.IsPlaying;

	public string animName => futureConfig.animName;

	public AEAnimClip currentClip => (futureConfig.animName != null) ? AnimComp.GetClipByName(futureConfig.animName) : null;

	public bool crouched => futureConfig.crouched;

	public bool interacting => futureConfig.interacting;

	public HagletCondition IsRotating => lookAt.running;

	public Material[] UnitMaterials => unitMaterials;

	public bool PlayIsDirty
	{
		get
		{
			return _playIsDirty;
		}
		private set
		{
			_playIsDirty = value;
			if (_playIsDirty)
			{
				unit.SetAnimationFlagDirty();
			}
		}
	}

	public bool HACK_BirdMode
	{
		get
		{
			return _isBirdMode;
		}
		set
		{
			for (int i = 0; i < unitMaterials.Length; i++)
			{
				if (!value)
				{
					unitMaterials[i].EnableKeyword("HOLOGRAM_UNIT_ON");
				}
				else
				{
					unitMaterials[i].DisableKeyword("HOLOGRAM_UNIT_ON");
				}
			}
			for (int j = 0; j < skinnedMeshRenderers.Length; j++)
			{
				SkinnedMeshRenderer skinnedMeshRenderer = skinnedMeshRenderers[j];
				skinnedMeshRenderer.localBounds = ((!value) ? new Bounds(Vector3.up, new Vector3(1f, 2f, 1f)) : new Bounds(Vector3.zero, Vector3.one * 200f));
			}
			_isBirdMode = value;
			BlobShadow.gameObject.SetActive(!_isBirdMode);
		}
	}

	public HagletEvent OnAnimComplete => AnimComp.OnAnimEnded;

	public static void GetAnimationFlags(AnimID animID, out bool looping, out bool crouched, out bool interacting)
	{
		switch (animID)
		{
		case AnimID.DefaultIdle:
		case AnimID.CombatIdle:
		case AnimID.CombatAimIdle:
		case AnimID.DefaultWalk:
		case AnimID.CombatWalk:
		case AnimID.Sleeping:
		case AnimID.DefaultSlowWalk:
			looping = true;
			crouched = false;
			interacting = false;
			break;
		case AnimID.CombatCrouch:
			looping = true;
			crouched = true;
			interacting = false;
			break;
		case AnimID.CombatAttackMelee:
		case AnimID.CombatAttackMeleeMulti:
		case AnimID.CombatAttackRanged:
		case AnimID.CombatAttackRangedMulti:
		case AnimID.CombatDeath:
		case AnimID.WakeUp:
		case AnimID.FallAsleep:
		case AnimID.Vault:
		case AnimID.DefaultAlert:
		case AnimID.DefaultConfusion:
		case AnimID.CombatHit:
		case AnimID.CombatDodge:
		case AnimID.CombatDodgeLeft:
		case AnimID.CombatDodgeRight:
		case AnimID.CombatTeleportBegin:
		case AnimID.CombatTeleportEnd:
		case AnimID.TransCCrouchToCIdle:
		case AnimID.TransCIdleToDIdle:
		case AnimID.TransDIdleToCIdle:
		case AnimID.TransCIdleToAIdle:
		case AnimID.TransAIdleToCIdle:
		case AnimID.CombatHacked:
			looping = false;
			crouched = false;
			interacting = false;
			break;
		case AnimID.CombatCrouchHit:
		case AnimID.CombatCrouchDodge:
		case AnimID.TransCIdleToCCrouch:
			looping = false;
			crouched = true;
			interacting = false;
			break;
		case AnimID.DefaultPickup:
		case AnimID.DefaultInteract:
			looping = false;
			crouched = false;
			interacting = true;
			break;
		default:
			looping = false;
			crouched = false;
			interacting = false;
			break;
		}
	}

	public static void InitialiseStringToAnimIDDict()
	{
		stringToAnimID = new Dictionary<string, AnimID>();
		for (int i = 0; i < 51; i++)
		{
			Dictionary<string, AnimID> dictionary = stringToAnimID;
			AnimID animID = (AnimID)i;
			dictionary.Add(animID.ToString(), (AnimID)i);
		}
	}

	public static AnimID GetAnimIDByName(string animName)
	{
		if (string.IsNullOrEmpty(animName))
		{
			return AnimID.MAX;
		}
		AnimID value = AnimID.MAX;
		stringToAnimID.TryGetValue(animName, out value);
		return value;
	}

	private void Reset()
	{
		OnValidate();
	}

	private void OnValidate()
	{
		unit = unit.OrIfNull(base.gameObject.GetComponentInAscendant<Unit>());
	}

	public void OnSpawn(Quaternion localRotation, WeaponAttributes weaponAttribsPrimary, WeaponAttributes weaponAttribsSecondary, WeaponAttributes propAttribs)
	{
		animNames = GetAnimNames();
		animOverrides = new string[animNames.Length];
		KubrickAnimator[] componentsInChildren = GetComponentsInChildren<KubrickAnimator>();
		UnitAnimFuncs[] componentsInChildren2 = GetComponentsInChildren<UnitAnimFuncs>();
		subModels = new SubModel[componentsInChildren.Length];
		for (int i = 0; i < subModels.Length; i++)
		{
			SubModel subModel = subModels[i];
			subModel.animator = componentsInChildren[i];
			subModel.transform = subModel.animator.transform;
			subModel.gameObject = subModel.animator.gameObject;
			subModel.animFuncs = componentsInChildren2[i];
			subModel.weaponXForm = subModel.transform.GetComponentInChildren<WeaponXForm>();
			subModel.propXForm = subModel.transform.GetComponentInChildren<PropXForm>();
			if ((bool)subModel.propXForm && (bool)propAttribs)
			{
				WeaponModel weaponModel = UnityEngine.Object.Instantiate(propAttribs.GetWeaponModel(0));
				weaponModel.OnSpawn(subModel.propXForm.transform);
				weaponModel.name = propAttribs.name;
			}
			if ((bool)subModel.weaponXForm && (bool)weaponAttribsPrimary)
			{
				WeaponModel weaponModel2 = UnityEngine.Object.Instantiate(weaponAttribsPrimary.GetWeaponModel(0));
				weaponModel2.OnSpawn(subModel.weaponXForm.transform);
				weaponModel2.name = weaponAttribsPrimary.name;
				subModel.weaponModelRanged = weaponModel2;
			}
			if ((bool)subModel.weaponXForm && (bool)weaponAttribsSecondary)
			{
				WeaponModel weaponModel3 = UnityEngine.Object.Instantiate(weaponAttribsSecondary.GetWeaponModel(0));
				weaponModel3.OnSpawn((!(subModel.propXForm != null)) ? subModel.weaponXForm.transform : subModel.propXForm.transform);
				if (weaponAttribsPrimary.IsMelee && weaponAttribsSecondary.IsRanged)
				{
					subModel.weaponModelRanged = weaponModel3;
				}
			}
			subModels[i] = subModel;
		}
		useModelRigVariant = false;
		unit = base.gameObject.GetComponentInAscendant<Unit>();
		updateIdleAction = delegate
		{
			unit.UpdateIdleAnim();
		};
		animTurn.Interpolate = AnimValue<ComplexAngle>.Linear;
		lookAt = new LookAt(this);
		skinnedMeshRenderers = unit.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		useModelRigVariant = unit.charData.GetUseAlternativeModel();
		LookAtDirectionLS(localRotation * Vector3.forward);
		BlobShadow = GetComponentInChildren<SpriteRenderer>();
		VFXTileController.SetSortingOrder(BlobShadow);
		PrepareMaterials();
		queuedAnimation = new QueuedAnimation(this);
		playAndIdleResettable = new PlayAndIdle(this);
		FindRootBone();
	}

	private void FindRootBone()
	{
		rootBone = AnimCompTransform;
		Transform transform = rootBone.Find("Ref_Grp_Bones_01");
		if (transform == null && rootBone.childCount > 0)
		{
			transform = rootBone.GetChild(0).Find("Ref_Grp_Bones_01");
		}
		if (transform != null)
		{
			transform = transform.Find("Ref_Jnt_Hips_01");
			if (transform != null)
			{
				rootBone = transform;
			}
		}
	}

	void Serializer.ISelfComposer.Decompose(Serializer.IMemberSink members)
	{
	}

	void Serializer.ISelfComposer.Recompose(Serializer.IMemberSource members)
	{
		PrepareMaterials();
	}

	private void PrepareMaterials()
	{
		colorHoloID = Shader.PropertyToID("_ColorHoloModel");
		colorTintID = Shader.PropertyToID("_ColorTint");
		colorXRayHoloID = Shader.PropertyToID("_ColorXRay");
		colorSunColorID = Shader.PropertyToID("_ColorSun");
		colorShadowColorID = Shader.PropertyToID("_ColorShadow");
		colorRimColorID = Shader.PropertyToID("_ColorRim");
		incorpIntensity = Shader.PropertyToID("_IntensityInc");
		incorpBaseCol = Shader.PropertyToID("_ColorInc");
		incorpRimCol = Shader.PropertyToID("_ColorRimInc");
		incorpWaveCol = Shader.PropertyToID("_ColorWavesInc");
		incorpLinesCol = Shader.PropertyToID("_ColorLinesInc");
		dodgeIntensity = Shader.PropertyToID("_IntensityDodge");
		int nameID = Shader.PropertyToID("_SqrTex");
		Texture2D value = AEResources.LoadFirstResource<Texture2D>("DodgeTextures/TX_DodgeSquareAlphaCutoff");
		int nameID2 = Shader.PropertyToID("_NoiseTex");
		Texture2D value2 = AEResources.LoadFirstResource<Texture2D>("DodgeTextures/TX_DodgeNoise");
		List<Material> list = new List<Material>(renderers.Length);
		for (uint num = 0u; num < renderers.Length; num++)
		{
			Renderer renderer = renderers[num];
			if (!(renderer is SpriteRenderer) && unit != null)
			{
				if (unit.charData != null)
				{
				}
				Material material2 = (renderer.sharedMaterial = new Material(renderer.sharedMaterial));
				Material material3 = material2;
				material3.EnableKeyword("HOLOGRAM_UNIT_ON");
				material3.SetColor(colorTintID, Color.white);
				material3.SetTexture(nameID, value);
				material3.SetTexture(nameID2, value2);
				material3.SetColor(incorpBaseCol, new Vector4(0.024f, 0.027f, 0.18f, 0.567f));
				material3.SetColor(incorpRimCol, new Vector4(0.008f, 0.039f, 0.063f, 0.031f));
				material3.SetColor(incorpWaveCol, new Vector4(0.165f, 0.275f, 0.808f, 0.2431f));
				material3.SetColor(incorpLinesCol, new Vector4(0.032f, 0.278f, 0.408f, 0.8863f));
				material3.SetFloat(incorpIntensity, 0f);
				list.Add(material3);
			}
		}
		unitMaterials = list.ToArray();
		Material source = AEResources.LoadFirstResource<Material>("UnitFresnel");
		materialsXRayHighlighted = new Material[skinnedMeshRenderers.Length][];
		materialsXRayNonHighlighted = new Material[skinnedMeshRenderers.Length];
		for (int i = 0; i < skinnedMeshRenderers.Length; i++)
		{
			materialsXRayHighlighted[i] = new Material[2];
			materialsXRayHighlighted[i][0] = skinnedMeshRenderers[i].sharedMaterial;
			materialsXRayHighlighted[i][1] = new Material(source);
			materialsXRayNonHighlighted[i] = skinnedMeshRenderers[i].sharedMaterial;
		}
		xrayAnim = new AnimFloatHaglet("XRayAnim", LR.Host, delegate
		{
			for (int num4 = 0; num4 < skinnedMeshRenderers.Length; num4++)
			{
				skinnedMeshRenderers[num4].sharedMaterials = materialsXRayHighlighted[num4];
			}
		}, delegate(float x)
		{
			uint teamIndex = unit.GetTeamIndex();
			Color color = UnitTeam.Colors[teamIndex];
			for (int num3 = 0; num3 < skinnedMeshRenderers.Length; num3++)
			{
				materialsXRayHighlighted[num3][1].SetColor(colorXRayHoloID, color.RepA(x));
			}
		});
		incorporealHagletFloat = new AnimFloatHaglet("IncorporealEffect", LR.Host, delegate
		{
			if (hack_enablingIncorporeal)
			{
				for (int num2 = 0; num2 < skinnedMeshRenderers.Length; num2++)
				{
					materialsXRayHighlighted[num2][0].EnableKeyword("INCORPOREAL_ON");
				}
			}
		}, delegate(float x)
		{
			for (int n = 0; n < skinnedMeshRenderers.Length; n++)
			{
				materialsXRayHighlighted[n][0].SetFloat(incorpIntensity, x);
			}
		}, delegate
		{
			if (!hack_enablingIncorporeal)
			{
				for (int m = 0; m < skinnedMeshRenderers.Length; m++)
				{
					materialsXRayHighlighted[m][0].DisableKeyword("INCORPOREAL_ON");
				}
			}
		});
		dodgeHagletFloat = new AnimFloatHaglet("DodgeEffect", LR.Host, delegate
		{
			if (enablingDodge)
			{
				for (int l = 0; l < skinnedMeshRenderers.Length; l++)
				{
					materialsXRayHighlighted[l][0].EnableKeyword("DODGE_ON");
					HideXRayHighlight();
				}
			}
		}, delegate(float x)
		{
			for (int k = 0; k < skinnedMeshRenderers.Length; k++)
			{
				materialsXRayHighlighted[k][0].SetFloat(dodgeIntensity, curve.Evaluate(x));
			}
		}, delegate
		{
			if (enablingDodge)
			{
				for (int j = 0; j < skinnedMeshRenderers.Length; j++)
				{
					materialsXRayHighlighted[j][0].DisableKeyword("DODGE_ON");
					enablingDodge = false;
				}
			}
		});
	}

	private static void ApplyScaleOffset(Vector2[] uvs, Vector2 scale, Vector2 offset)
	{
		for (int i = 0; i < uvs.Length; i++)
		{
			uvs[i].Scale(scale);
			uvs[i] += offset;
		}
	}

	public static void MergeAndAtlasAttachments(SkinnedMeshRenderer skinned)
	{
		MeshFilter[] componentsInChildren = skinned.rootBone.GetComponentsInChildren<MeshFilter>(includeInactive: true);
		Transform[] bones = skinned.bones;
		Mesh sharedMesh = skinned.sharedMesh;
		int vertexCount = sharedMesh.vertexCount;
		int[] triangles = sharedMesh.triangles;
		Matrix4x4[] bindposes = sharedMesh.bindposes;
		Vector2[] uv = sharedMesh.uv;
		List<int> list = new List<int>(triangles);
		int num = vertexCount;
		MeshFilter[] array = componentsInChildren;
		foreach (MeshFilter meshFilter in array)
		{
			num += meshFilter.sharedMesh.vertexCount;
		}
		AECharacterWeaponAtlas aECharacterWeaponAtlas = AEResources.LoadFirstResource<AECharacterWeaponAtlas>("CharacterWeaponAtlas/AtlasData");
		Mesh mesh = new Mesh();
		int count = list.Count;
		List<Vector3> list2 = new List<Vector3>(num);
		List<Vector2> list3 = new List<Vector2>(num);
		List<Vector3> list4 = new List<Vector3>(num);
		List<BoneWeight> list5 = new List<BoneWeight>(num);
		List<Matrix4x4> list6 = new List<Matrix4x4>(bindposes.Length + componentsInChildren.Length);
		List<Transform> list7 = new List<Transform>(bones.Length + componentsInChildren.Length);
		CharacterWeaponAtlasRef component = skinned.GetComponent<CharacterWeaponAtlasRef>();
		if (!(component != null) || !aECharacterWeaponAtlas.GetRect(component.texturePath, out var rect))
		{
			return;
		}
		ApplyScaleOffset(uv, rect.size, rect.min);
		list3.AddRange(uv);
		list4.AddRange(sharedMesh.normals);
		list2.AddRange(sharedMesh.vertices);
		list5.AddRange(sharedMesh.boneWeights);
		list6.AddRange(bindposes);
		list7.AddRange(bones);
		int num2 = vertexCount;
		v2i v2i2 = new v2i(64, 64);
		Vector2 vector = new Vector2(0.5f, 0f);
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			MeshFilter meshFilter2 = componentsInChildren[j];
			Transform item = meshFilter2.transform;
			Mesh sharedMesh2 = meshFilter2.sharedMesh;
			int[] triangles2 = sharedMesh2.triangles;
			Vector3[] vertices = sharedMesh2.vertices;
			Vector2[] uv2 = sharedMesh2.uv;
			int boneIndex = bones.Length + j;
			MeshRenderer component2 = meshFilter2.GetComponent<MeshRenderer>();
			component = meshFilter2.GetComponent<CharacterWeaponAtlasRef>();
			list2.AddRange(vertices);
			list4.AddRange(sharedMesh2.normals);
			list6.Add(Matrix4x4.identity);
			list7.Add(item);
			for (int k = 0; k < triangles2.Length; k++)
			{
				triangles2[k] += num2;
			}
			list.AddRange(triangles2);
			for (int l = 0; l < vertices.Length; l++)
			{
				list5.Add(new BoneWeight
				{
					boneIndex0 = boneIndex,
					weight0 = 1f
				});
			}
			if (component != null && aECharacterWeaponAtlas.GetRect(component.texturePath, out rect))
			{
				ApplyScaleOffset(uv2, rect.size, rect.min);
				list3.AddRange(uv2);
				num2 += vertices.Length;
				UnityEngine.Object.DestroyImmediate(component2, allowDestroyingAssets: false);
				UnityEngine.Object.DestroyImmediate(meshFilter2, allowDestroyingAssets: false);
				continue;
			}
			return;
		}
		mesh.bindposes = list6.ToArray();
		mesh.vertices = list2.ToArray();
		mesh.uv = list3.ToArray();
		mesh.normals = list4.ToArray();
		mesh.triangles = list.ToArray();
		mesh.boneWeights = list5.ToArray();
		skinned.sharedMaterial.mainTexture = AEResources.LoadFirstResource<Texture2D>("CharacterWeaponAtlas/TX_AtlasTexture");
		skinned.bones = list7.ToArray();
		skinned.sharedMesh = mesh;
	}

	public string GetAnimName(AnimID animID, bool ignoreOverride = false)
	{
		string text = animOverrides[(int)animID];
		if (!ignoreOverride && !string.IsNullOrEmpty(text))
		{
			return text;
		}
		return animNames[(int)animID];
	}

	public void SetAnimOverride(AnimID animID, string animOverrideName, bool ignoreIdleUpdate = false)
	{
		if (!ignoreIdleUpdate && ((animID == AnimID.DefaultIdle && currentClip != null && currentClip.name == GetAnimName(AnimID.DefaultIdle)) || (animID == AnimID.CombatIdle && currentClip != null && currentClip.name == GetAnimName(AnimID.CombatIdle))))
		{
			animOverrides[(int)animID] = animOverrideName;
			unit.UpdateIdleAnim();
		}
		else
		{
			animOverrides[(int)animID] = animOverrideName;
		}
	}

	public void ClearAnimOverride(AnimID animID)
	{
		unit.unitModel.SetAnimOverride(animID, unit.unitModel.GetAnimName(animID, ignoreOverride: true));
	}

	public bool IsAnimOverriden(AnimID animID)
	{
		string text = animOverrides[(int)animID];
		return !string.IsNullOrEmpty(text) && text != animNames[(int)animID];
	}

	public void ShowXRayHighlight()
	{
		xrayAnim.Start(1f, 0.25f);
	}

	public void HideXRayHighlight()
	{
		for (int i = 0; i < skinnedMeshRenderers.Length; i++)
		{
			skinnedMeshRenderers[i].sharedMaterials = materialsXRayNonHighlighted;
		}
		xrayAnim.Stop();
	}

	public void EnableIncorporealEffect(bool enabled)
	{
		hack_enablingIncorporeal = enabled;
		if (enabled)
		{
			incorporealHagletFloat.Start(0f, 1f, 0.5f, 0f);
		}
		else
		{
			incorporealHagletFloat.Start(1f, 0f, 0.5f, 0f);
		}
	}

	public void EnableDodgeEffect(bool enabled)
	{
		enablingDodge = enabled;
		if (enabled)
		{
			dodgeHagletFloat.Start(1f, 0f, 0.8f, 0f);
		}
	}

	public static string[] GetAnimNames()
	{
		string[] array = new string[51];
		for (int i = 0; i < array.Length; i++)
		{
			int num = i;
			AnimID animID = (AnimID)i;
			array[num] = animID.ToString();
		}
		return array;
	}

	public Bounds GetModelBounds()
	{
		return skinnedMeshRenderers[0].bounds;
	}

	public void SetSunAndRimColor(Color sunColor, Color shadowColor, Color rimColor)
	{
		for (int i = 0; i < unitMaterials.Length; i++)
		{
			Material material = unitMaterials[i];
			material.SetColor(colorSunColorID, sunColor);
			material.SetColor(colorShadowColorID, shadowColor);
			material.SetColor(colorRimColorID, rimColor);
		}
	}

	public HagletEvent Play(AnimID anim, Vector3? lookAt = null, bool updateIdleOnComplete = false)
	{
		if (lookAt.HasValue)
		{
			AEAnimClip clipByName = AnimComp.GetClipByName(GetAnimName(anim));
			if (clipByName != null)
			{
				Vector3 value = lookAt.Value;
				float duration = ((!(clipByName.Duration < 1f)) ? 1f : clipByName.Duration);
				StartLookAtTarget(value, null, duration);
			}
		}
		string text = GetAnimName(anim);
		if (!HasAnim(text))
		{
			AnimID animID = AnimID.DefaultIdle;
			switch (anim)
			{
			case AnimID.DefaultIdle:
				animID = AnimID.CombatIdle;
				break;
			case AnimID.CombatIdle:
				animID = AnimID.DefaultIdle;
				break;
			case AnimID.CombatAimIdle:
				animID = AnimID.CombatIdle;
				break;
			case AnimID.CombatWalk:
				animID = AnimID.DefaultWalk;
				break;
			case AnimID.CombatAttackMelee:
				animID = AnimID.CombatAttackRanged;
				break;
			case AnimID.CombatAttackRanged:
				animID = AnimID.CombatAttackMelee;
				break;
			case AnimID.DefaultWalk:
				animID = AnimID.CombatWalk;
				break;
			case AnimID.CombatCrouchHit:
				animID = AnimID.CombatHit;
				break;
			case AnimID.CombatCrouchDodge:
				animID = AnimID.CombatDodge;
				break;
			case AnimID.FallAsleep:
				animID = AnimID.Sleeping;
				break;
			}
			text = GetAnimName(animID);
		}
		GetAnimationFlags(anim, out var looping, out var flag, out var flag2);
		return Play(text, looping, flag, flag2, updateIdleOnComplete);
	}

	public HagletTrigger Play(string animName, bool looping = false, bool crouched = false, bool interacting = false, bool updateIdleOnComplete = false)
	{
		if (string.IsNullOrEmpty(animName))
		{
			UnityEngine.Debug.LogErrorFormat("Unit {0} attempted to play a null model animation!", unit.charData.charName);
			return null;
		}
		if (!AnimComp.HasClip(animName))
		{
			UnityEngine.Debug.LogErrorFormat("Unit {0} attempted to play missing animation {1}!", unit.charData.charName, animName);
			return null;
		}
		if (!MR.Inst.IsSkipping() && currentConfig != futureConfig)
		{
			AEAnimClip clipByName = AnimComp.GetClipByName(futureConfig.animName);
			clipByName.OnComplete.Trigger();
			if (!queuedAnimation.running)
			{
				return null;
			}
		}
		if (MR.Inst.IsSkipping() && updateIdleOnComplete)
		{
			unit.UpdateIdleAnim();
			return null;
		}
		PlayIsDirty = true;
		futureConfig.animName = animName;
		futureConfig.looping = looping;
		futureConfig.crouched = crouched;
		futureConfig.interacting = interacting;
		futureConfig.updateIdleOnComplete = updateIdleOnComplete;
		if (MR.Inst.IsSkipping())
		{
			OnLateUpdate();
			return null;
		}
		return AnimComp.GetClipByName(animName).OnComplete;
	}

	public string GetPrefixAnimation(string animationName)
	{
		AEAnimClip prefixClipWithEvents = AnimComp.GetClipByName(animationName).prefixClipWithEvents;
		return (!(prefixClipWithEvents != null)) ? null : prefixClipWithEvents.name;
	}

	public string GetSuffixAnimation(string animationName)
	{
		AEAnimClip suffixClipWithEvents = AnimComp.GetClipByName(animationName).suffixClipWithEvents;
		return (!(suffixClipWithEvents != null)) ? null : suffixClipWithEvents.name;
	}

	public void DebugPlay(AnimID anim)
	{
		PlayIsDirty = true;
		Play(anim);
		futureConfig.looping = true;
	}

	public Vector3 GetLookAtDirectionLS()
	{
		return AnimCompTransform.localRotation * Vector3.forward;
	}

	public void FocusOnTarget(Transform target)
	{
		Vector3 position = target.position;
		StartLookAtTarget(position, null, -1f, target);
	}

	public void StartLookAtTarget(Vector3 worldPos, Action OnComplete = null, float duration = -1f, Transform focusTargetAfterRotation = null)
	{
		targetFocus = focusTargetAfterRotation;
		Vector3 lookAtDirectionLS = GetLookAtDirectionLS();
		Vector3 vector = unit.map.WorldPosToLocalPos(worldPos);
		Vector3 positionLS = unit.GetPositionLS();
		Vector3 normalized = (vector - positionLS).RepY(0f).normalized;
		if (duration < 0f)
		{
			float num = Vector3.Angle(lookAtDirectionLS, normalized);
			duration = num / 550f;
			if (GC.Inst.IsInCombatMode())
			{
				duration *= 0.75f;
			}
		}
		Vector2 direction = new Vector2(lookAtDirectionLS.x, lookAtDirectionLS.z);
		Vector2 direction2 = new Vector2(normalized.x, normalized.z);
		lookAt.from = ComplexAngle.FromVecPrenormalized(direction);
		lookAt.to = ComplexAngle.FromVecPrenormalized(direction2);
		lookAt.onComplete = OnComplete;
		lookAt.duration = duration;
		if ((bool)lookAt.running || lookAt.markedToRunBy != null)
		{
			lookAt.Reset();
		}
		else
		{
			Routine.Start(lookAt, MR.Inst.Host, MR.Inst.mainHagisSequence);
		}
	}

	private IEnumerator<HagletYieldTerm> LookAtTargetRoutine()
	{
		if (lookAt.duration < 0.01f && targetFocus == null)
		{
			if (lookAt.onComplete != null)
			{
				lookAt.onComplete();
			}
			yield break;
		}
		animTurn.Value = lookAt.from;
		animTurn.AnimateTo(lookAt.to, lookAt.duration);
		yield return Wait.UntilNextUpdate();
		while ((bool)animTurn.animating)
		{
			Vector3 dirXZ = animTurn.Update().directionXZ;
			LookAtDirectionLS(dirXZ);
			if (lookAt.unitModel.unit.UpdateObservedTilesAndCheckIfSpotted())
			{
				yield break;
			}
			yield return Wait.UntilNextUpdate();
		}
		if (!Routine.IsSkipping())
		{
			while (targetFocus != null)
			{
				LookAtDirectionLS(targetFocus.localPosition - unit.GetPositionLS());
				yield return Wait.UntilNextUpdate();
			}
		}
		if (lookAt.onComplete != null)
		{
			lookAt.onComplete();
		}
	}

	public bool IsPlayingAnim(string animName)
	{
		AEAnimClip clipByName = AnimComp.GetClipByName(animName);
		return clipByName != null && clipByName == currentClip && AnimComp.IsPlaying;
	}

	public bool HasAnim(AnimID animID)
	{
		return HasAnim(GetAnimName(animID));
	}

	public bool HasAnim(string animName)
	{
		return AnimComp.HasClip(animName);
	}

	public bool HasAnimGotEvent<T>(AnimID animID) where T : AEAnimEventBase
	{
		string clipName = GetAnimName(animID);
		int eventCount = AnimComp.GetEventCount<T>(clipName);
		return eventCount > 0;
	}

	public int GetEventCount<T>(AnimID animID) where T : AEAnimEventBase
	{
		return AnimComp.GetEventCount<T>(GetAnimName(animID));
	}

	public int GetEventCount<T>(string animName) where T : AEAnimEventBase
	{
		return AnimComp.GetEventCount<T>(animName);
	}

	public void OnLateUpdate()
	{
		if (PlayIsDirty && Configuration.ShouldPlayNewAnim(this, currentConfig, futureConfig))
		{
			AnimComp.WrapMode = ((!futureConfig.looping) ? WrapMode.Once : WrapMode.Loop);
			if (!string.IsNullOrEmpty(futureConfig.animName))
			{
				AnimComp.Play(futureConfig.animName, (!futureConfig.updateIdleOnComplete) ? null : updateIdleAction);
			}
			currentConfig = futureConfig;
		}
		PlayIsDirty = false;
	}

	private void LateUpdate()
	{
		BlobShadow.transform.position = rootBone.position;
		BlobShadow.transform.localPosition = BlobShadow.transform.localPosition.RepY(0.02f);
	}

	public void LookAtDirectionLS(Vector3 directionLocalSpace)
	{
		AnimCompTransform.localRotation = Quaternion.LookRotation(directionLocalSpace, Vector3.up);
	}

	public void LookAtDirectionLSDIncremental(Vector3 directionLocalSpace, float speed = 10f)
	{
		AnimCompTransform.localRotation = Quaternion.Lerp(AnimCompTransform.localRotation, Quaternion.LookRotation(directionLocalSpace, Vector3.up), speed * Time.deltaTime);
	}

	private void LookAtPositionWS(Vector3 worldPos)
	{
		Vector3 vect = AnimCompTransform.InverseTransformPoint(worldPos);
		vect = vect.RepY(0f).normalized;
		LookAtDirectionLS(vect);
	}

	public void Show()
	{
		for (uint num = 0u; num < renderers.Length; num++)
		{
			renderers[num].enabled = true;
		}
	}

	public void Hide()
	{
		for (uint num = 0u; num < renderers.Length; num++)
		{
			renderers[num].enabled = false;
		}
	}

	public void SetHologramColor(Color color)
	{
		for (uint num = 0u; num < unitMaterials.Length; num++)
		{
			unitMaterials[num].SetColor(colorHoloID, color);
		}
	}

	public void Tint(Color color)
	{
		for (uint num = 0u; num < unitMaterials.Length; num++)
		{
			unitMaterials[num].SetColor(colorTintID, color);
		}
	}

	public void RemoveTint()
	{
		for (uint num = 0u; num < unitMaterials.Length; num++)
		{
			unitMaterials[num].SetColor(colorTintID, Color.white);
		}
	}

	public bool isAnimationQueued()
	{
		return (bool)queuedAnimation.running || queuedAnimation.markedToRunBy != null;
	}

	private IEnumerator<HagletYieldTerm> QueuedAnimationRoutine()
	{
		if (base.gameObject.activeInHierarchy && AnimComp.enabled)
		{
			yield return Play(queuedAnimation.transitionAnim);
		}
		if (currentClip.name == GetAnimName(queuedAnimation.transitionAnim))
		{
			UnitModel unitModel = this;
			AnimID targetAnim = queuedAnimation.targetAnim;
			bool updateIdleOnComplete = queuedAnimation.updateIdleOnComplete;
			unitModel.Play(targetAnim, null, updateIdleOnComplete);
			yield return null;
		}
	}

	public void PlayWithTransition(AnimID transitionAnim, AnimID targetAnim, Vector3? lookAt = null, bool updateIdleOnComplete = false)
	{
		if (!HasAnim(transitionAnim))
		{
			Play(targetAnim, lookAt);
			return;
		}
		if (MR.Inst.IsSkipping())
		{
			Play(targetAnim, lookAt);
			return;
		}
		queuedAnimation.transitionAnim = transitionAnim;
		queuedAnimation.targetAnim = targetAnim;
		queuedAnimation.updateIdleOnComplete = updateIdleOnComplete;
		if (!queuedAnimation.running && queuedAnimation.markedToRunBy == null)
		{
			MR.Inst.Host.StartTopLevel(queuedAnimation, MR.Inst.mainHagisSequence);
		}
		else
		{
			queuedAnimation.Reset();
		}
		if (lookAt.HasValue)
		{
			float duration = AnimComp.GetClipByName(GetAnimName(transitionAnim)).Duration;
			Vector3 value = lookAt.Value;
			float duration2 = ((!(duration < 1f)) ? 1f : duration);
			StartLookAtTarget(value, null, duration2);
		}
	}

	public HagletEvent PlayAndReturnToIdle(string animName)
	{
		return Play(animName, looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
	}

	private IEnumerator<HagletYieldTerm> PlayAndIdleRoutine()
	{
		yield return Play(playAndIdleResettable.anim);
		unit.UpdateIdleAnim();
	}

	public void SetPaused(bool paused)
	{
		AnimComp.SetPaused(paused);
	}

	public void SetBlending(bool blend)
	{
		AnimComp.blending = ((!blend) ? 0f : 0.25f);
	}

	public float GetAnimDuration(AnimID animId)
	{
		return GetAnimDuration(GetAnimName(animId));
	}

	public float GetAnimDuration(string animName)
	{
		AEAnimClip aEAnimClip = AnimComp.TryGetClipByName(animName);
		if (aEAnimClip != null)
		{
			return aEAnimClip.Duration;
		}
		return 0f;
	}

	public bool IsAnimCompPlayingAnim(string animName)
	{
		if (AnimComp.GetCurrentClip == null)
		{
			return false;
		}
		return AnimComp.GetCurrentClip.name == animName && AnimComp.IsPlaying;
	}
}
[Flags]
public enum TransitionAnim
{
	InOut = 3,
	In = 1,
	Out = 2
}
internal static class TransitionAnimX
{
	public static bool IncludesIn(this TransitionAnim ta)
	{
		return (ta & TransitionAnim.In) != 0;
	}

	public static bool IncludesOut(this TransitionAnim ta)
	{
		return (ta & TransitionAnim.Out) != 0;
	}
}
[ExecuteInEditMode]
public class UnitPatrol : TileDirectionalBase
{
}
public enum PartyMemberSelection
{
	None = -1,
	Leader,
	SubLeader,
	ThirdMember,
	FourthMember,
	FifthMember,
	SixthMember
}
public class UnitSpawn : UnitSpawnSingle
{
	[NonSceneAsset]
	public CharacterData characterData;

	public PartyMemberSelection memberInLoadout = PartyMemberSelection.None;

	[ReadOnly]
	public string info;

	public override Unit Spawn(int index)
	{
		CharacterData characterData = this.characterData;
		bool useDebugAbilities = true;
		if ((Party.Inst.TryGetUnlockedPartyMember(characterData, out var _) && LR.DEBUG_missionScene == null) || (characterData.loadedAbilities != null && characterData.loadedAbilities.Count > 0))
		{
			useDebugAbilities = false;
		}
		if (memberInLoadout != PartyMemberSelection.None && LR.DEBUG_missionScene == null)
		{
			ConstArray<PartyMember> contributedPartyMembers = Party.Inst.GetContributedPartyMembers();
			PartyMember partyMember2 = contributedPartyMembers[(int)memberInLoadout];
			if (partyMember2 != null)
			{
				characterData = partyMember2.characterData;
			}
		}
		Unit unit = SpawnSingleCharacter(characterData, useDebugAbilities);
		UnitPatrol[] componentsInChildren = GetComponentsInChildren<UnitPatrol>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			unit.AddPatrolPoint(componentsInChildren[i]);
		}
		return unit;
	}

	public override int GetSpawnCount()
	{
		return 1;
	}
}
public interface ISpawnEvents
{
	void OnSpawned(Unit unit);
}
[SelectionBase]
public abstract class UnitSpawnBase : TileDirectionalBase
{
	public UnitTeam.Type teamType;

	[Range(0f, 10f)]
	public int levelInitial;

	public Item dropItemOnDeath = Item.None;

	[SerializeField]
	[HideInInspector]
	private string validationPassword = string.Empty;

	public string ValidationPassword
	{
		set
		{
			validationPassword = value;
		}
	}

	public bool ShouldValidate => string.IsNullOrEmpty(validationPassword) || validationPassword != "fuckyouVALIDATION";

	public abstract Unit Spawn(int index);

	public Unit SpawnCharacterWithData(CharacterData characterData, string genID, int wave, bool useDebugAbilities, AIC.AIParameters aiParamsOverride = null)
	{
		if (base.map == null)
		{
			base.map = base.gameObject.GetComponentInAscendant<Map>();
		}
		Map map = base.map;
		v2i coord = GetCoord();
		Quaternion rotation = GetRotation();
		UnitTeam.Type team = teamType;
		Transform parent = base.transform.parent;
		int num = levelInitial;
		bool useDebugAbilities2 = useDebugAbilities;
		Item item = dropItemOnDeath;
		Unit unit = Unit.Spawn(characterData, genID, wave, map, coord, rotation, team, parent, num, useDebugAbilities2, makeActiveOnSpawn: true, characterData.hasAbilities, item, aiParamsOverride, ShouldValidate);
		unit.gameObject.SetActive(value: false);
		unit.spawnPoint = this;
		return unit;
	}

	public abstract int GetSpawnCount();

	protected void DisableSpawn()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public abstract class UnitSpawnSingle : UnitSpawnBase
{
	private Unit unitToSpawn;

	public bool overrideAIParameters;

	public AIC.AIParameters aiParameters;

	protected void ActivateSpawnedUnit()
	{
		unitToSpawn.gameObject.SetActive(value: true);
		unitToSpawn = null;
		DisableSpawn();
	}

	public void OnEnable()
	{
		if (map != null && (bool)unitToSpawn)
		{
			ActivateSpawnedUnit();
		}
	}

	protected Unit SpawnSingleCharacter(CharacterData characterData, bool useDebugAbilities)
	{
		Unit result = (unitToSpawn = SpawnCharacterWithData(characterData, base.idGenerated, 0, useDebugAbilities, (!overrideAIParameters) ? null : aiParameters));
		if (base.gameObject.activeInHierarchy && base.enabled)
		{
			ActivateSpawnedUnit();
		}
		return result;
	}
}
public class UnitSpawnBehaviourNPC : MonoBehaviour, ISpawnEvents
{
	public string overrideDefaultIdleAnimation;

	public string occasionalAnimation;

	public bool shouldWander;

	private HagletResettable playOccasionalAnim;

	private Unit unit;

	public void OnSpawned(Unit unit)
	{
		playOccasionalAnim = new HagletResettable(PlayOccasionalAnimRoutine(), "Occasional NPC Anim");
		this.unit = unit;
		if (!string.IsNullOrEmpty(overrideDefaultIdleAnimation))
		{
			unit.unitModel.SetAnimOverride(UnitModel.AnimID.DefaultIdle, overrideDefaultIdleAnimation);
			if (overrideDefaultIdleAnimation.Contains("DefaultSit"))
			{
				SitAnchor sitAnchor = unit.map.TryGetAdjacentSitAnchor(unit.coord);
				if (sitAnchor != null)
				{
					unit.WarpToLocalMapPosition(sitAnchor.transform.localPosition + unit.unitModel.AnimCompTransform.forward * 0.15f);
				}
			}
		}
		if (shouldWander)
		{
			Singleton<NPCWanderController>.Inst.EnableNPCWander(unit);
		}
		if (!string.IsNullOrEmpty(occasionalAnimation))
		{
			Routine.Start(playOccasionalAnim, MR.Inst.Host);
		}
	}

	private IEnumerator<HagletYieldTerm> PlayOccasionalAnimRoutine()
	{
		while (true)
		{
			yield return Wait.ForSeconds(UnityEngine.Random.Range(2f, 5f));
			if (!(unit.unitModel.currentClip == null) && ((!string.IsNullOrEmpty(overrideDefaultIdleAnimation) && unit.unitModel.currentClip.name == overrideDefaultIdleAnimation) || unit.unitModel.currentClip.name == unit.unitModel.GetAnimName(UnitModel.AnimID.DefaultIdle)))
			{
				yield return unit.unitModel.Play(occasionalAnimation, looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
			}
		}
	}
}
public class UnitSpawnWaves : UnitSpawnBase
{
	[NonSceneAsset]
	public CharacterData[] wavesCharacterData = new CharacterData[1];

	[HideInInspector]
	[Serializer.Exclude]
	private Unit[] units;

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		units = new Unit[wavesCharacterData.Length];
	}

	public void ActivateUnitWithWaveIndex(uint waveIndex)
	{
		if (waveIndex < units.Length)
		{
			Unit unit = units[waveIndex];
			if (unit != null)
			{
				unit.gameObject.SetActive(value: true);
				units[waveIndex] = null;
			}
			if (waveIndex >= wavesCharacterData.Length - 1)
			{
				DisableSpawn();
			}
		}
	}

	public override Unit Spawn(int index)
	{
		int num = 0;
		for (int i = 0; i < wavesCharacterData.Length; i++)
		{
			if ((bool)wavesCharacterData[i])
			{
				if (index == 0)
				{
					num = i;
					break;
				}
				index--;
			}
		}
		Unit unit = (units[num] = SpawnCharacterWithData(wavesCharacterData[num], base.idGenerated, num, useDebugAbilities: true));
		unit.gameObject.SetActive(value: false);
		return unit;
	}

	public override int GetSpawnCount()
	{
		int num = 0;
		for (int i = 0; i < wavesCharacterData.Length; i++)
		{
			if ((bool)wavesCharacterData[i])
			{
				num++;
			}
		}
		return num;
	}
}
[RequireComponent(typeof(SpriteRenderer))]
public class UnitSprite : MonoBehaviour
{
	public SpriteRenderer spriteRenderer;

	public CharAnimSet animSet;

	private CharAnimSet.AnimID animID;

	private OctDir dirID;

	private float animEndTime;

	private float animStartTime;

	private float animDuration;

	private void OnValidate()
	{
		spriteRenderer = spriteRenderer ?? GetComponent<SpriteRenderer>();
	}

	public void Start()
	{
		Play(CharAnimSet.AnimID.Idle, OctDir.DownRight);
	}

	public bool Play(CharAnimSet.AnimID animIDIn, OctDir dirIDIn, bool loop = true)
	{
		if (animSet == null)
		{
			return false;
		}
		if (animIDIn == animID && dirIDIn == dirID)
		{
			animEndTime = ((!loop) ? (Time.time + (animDuration - (Time.time - animStartTime) % animDuration)) : float.PositiveInfinity);
			return false;
		}
		CharAnimSet.Anim anim = animSet.anims[(int)animIDIn];
		if (anim.dirs[0].frames.Length == 0)
		{
			UnityEngine.Debug.LogFormat("Tried to use not-yet-created animation {0} of character {1} on unit {2}", animIDIn, animSet.name, base.transform.parent.name);
			return false;
		}
		if (animIDIn != animID)
		{
			animStartTime = Time.time;
			animDuration = (float)anim.dirs[0].frames.Length / anim.fps;
			animEndTime = ((!loop && !float.IsInfinity(animDuration)) ? (animStartTime + animDuration) : float.PositiveInfinity);
			animID = animIDIn;
		}
		dirID = dirIDIn;
		Update();
		return true;
	}

	public bool Play(CharAnimSet.AnimID animIn, bool loop = true)
	{
		return Play(animIn, dirID, loop);
	}

	public bool Play(OctDir dirIn, bool loop = true)
	{
		return Play(animID, dirIn, loop);
	}

	public bool Play(bool loop = true)
	{
		return Play(animID, dirID, loop);
	}

	private void Update()
	{
		if (!(animSet == null) && animSet.anims[(int)animID].dirs[0].frames.Length != 0)
		{
			if (Time.time >= animEndTime)
			{
				Play((animID == CharAnimSet.AnimID.Die) ? CharAnimSet.AnimID.Dead : CharAnimSet.AnimID.Idle, dirID);
				return;
			}
			OctDir octDir = ToVisual(dirID);
			CharAnimSet.Anim anim = animSet.anims[(int)animID];
			CharAnimSet.FrameSet frameSet = anim.dirs[(int)octDir];
			int num = Mathf.FloorToInt((Time.time - animStartTime) * anim.fps % (float)frameSet.frames.Length);
			spriteRenderer.sprite = frameSet.frames[num];
		}
	}

	private OctDir ToVisual(OctDir dir)
	{
		Vector3 to = (base.transform.position - Singleton<CC>.Inst.transform.position).RepY(0f);
		return (dir.AngleCW() - (Vector3.Angle(Vector3.left, to) - 90f)).ToSimpleDir();
	}
}
public class UnitTarget : TileObjectBase
{
}
[Serializable]
public class UnitTeam
{
	public enum Type
	{
		Player,
		Enemy,
		NPC,
		Opponent,
		MAX
	}

	[Serializable]
	private class TransitionToMap : HagletResettable
	{
		public TileActionSwapMap swapTargetEntrance;

		public bool ignoreMovement;

		public KubrickAnimatorAndClip? mapExitAnimation;

		public KubrickAnimatorAndClip? mapEntryAnimation;

		public TransitionToMap(UnitTeam ut)
			: base(ut.TransitionRoutine(), $"UnitTeam {ut.type} Transition To Map")
		{
		}

		protected TransitionToMap(BinaryReader reader)
			: base(reader)
		{
		}
	}

	public Type type;

	public static readonly string[] Names = new string[4] { "Player 1's", "Enemy's", "NPC's", "Player 2's" };

	public static readonly Color[] Colors = new Color[4]
	{
		new Color(7f / 85f, 53f / 85f, 0.9137255f),
		new Color(72f / 85f, 18f / 85f, 0.30980393f),
		Color.white,
		new Color(72f / 85f, 18f / 85f, 0.30980393f)
	};

	public static readonly Color[] ColorAP = new Color[4]
	{
		ColorX.RGB(34, 107, 217),
		ColorX.RGB(50, 52, 180),
		Color.white,
		ColorX.RGB(50, 52, 180)
	};

	public static readonly Color[] ColorHPBorder = new Color[4]
	{
		new Color(7f / 85f, 53f / 85f, 0.9137255f),
		new Color(10f / 51f, 0.20392157f, 0.7058824f),
		Color.white,
		new Color(10f / 51f, 0.20392157f, 0.7058824f)
	};

	public static readonly Color[] ColorNameText = new Color[4]
	{
		new Color(0.5882353f, 40f / 51f, 67f / 85f),
		new Color(72f / 85f, 18f / 85f, 0.30980393f),
		Color.white,
		new Color(72f / 85f, 18f / 85f, 0.30980393f)
	};

	public static readonly Color[,] ColorCoverTypes = new Color[4, 3]
	{
		{
			new Color(52f / 85f, 2f / 3f, 19f / 51f),
			new Color(32f / 51f, 61f / 85f, 31f / 51f),
			new Color(54f / 85f, 0.7647059f, 0.8f)
		},
		{
			new Color(10f / 51f, 0.20392157f, 0.7058824f),
			new Color(0.6901961f, 0.14509805f, 0.61960787f),
			new Color(72f / 85f, 18f / 85f, 0.30980393f)
		},
		{
			Color.white,
			Color.white,
			Color.white
		},
		{
			new Color(10f / 51f, 0.20392157f, 0.7058824f),
			new Color(0.6901961f, 0.14509805f, 0.61960787f),
			new Color(72f / 85f, 18f / 85f, 0.30980393f)
		}
	};

	public static readonly bool[] IsPlayerControlled = new bool[4] { true, false, false, true };

	public ITeamController controller;

	private const uint teamsMembersNumMax = 64u;

	private ConstArray<Unit> membersInWorld = new ConstArray<Unit>(64u);

	private ConstArray<Unit> membersAliveInWorld = new ConstArray<Unit>(64u);

	[Serializer.Exclude]
	private ConstArray<Unit> membersActiveInMap = new ConstArray<Unit>(64u);

	private Unit teamLeader;

	[NonSerialized]
	public HagletTrigger OnTurnStarted = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnMemberDied = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnTeamDied = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnUnitAddedToTeam = new HagletTrigger();

	public AbilityList abilities;

	[SerializeField]
	private TransitionToMap transition;

	private int[] _gangTypesForTeam = new int[8];

	public bool IsFirstTurn { get; set; }

	public bool AreUnitsTeleporting
	{
		get
		{
			ConstArray<Unit> activeMembers = GetActiveMembers();
			int num = (int)activeMembers.Length;
			while (--num >= 0)
			{
				if ((bool)activeMembers[num].teleporting)
				{
					return true;
				}
			}
			return false;
		}
	}

	public HagletEvent OnTransitionCompleted => transition.completed;

	public bool hasAnyAP
	{
		get
		{
			ConstArray<Unit> activeMembers = GetActiveMembers();
			int num = activeMembers.sLength;
			while (--num >= 0)
			{
				if (activeMembers[num].AP > 0)
				{
					return true;
				}
			}
			return false;
		}
	}

	public UnitTeam(Type type, ITeamController controller)
	{
		this.type = type;
		this.controller = controller;
		transition = new TransitionToMap(this);
		abilities = new AbilityList(this);
	}

	private UnitTeam()
	{
	}

	public HagletYieldTerm TransitionTeamToMap(TileActionSwapMap tileEntrance, bool ignoreMovement = false, KubrickAnimatorAndClip? mapExitAnimation = null, KubrickAnimatorAndClip? mapEntryAnimation = null)
	{
		transition.swapTargetEntrance = tileEntrance;
		transition.ignoreMovement = ignoreMovement;
		transition.mapExitAnimation = mapExitAnimation;
		transition.mapEntryAnimation = mapEntryAnimation;
		return Routine.Start(transition, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> TransitionRoutine()
	{
		bool wasInCutsceneMode = GC.Inst.IsInCutsceneMode();
		if (!wasInCutsceneMode)
		{
			GC.Inst.CutsceneBegin();
		}
		ConstArray<Unit> members = GetActiveMembers();
		if (!transition.ignoreMovement)
		{
			TileActionSwapMap walkTarget_SwapTile = transition.swapTargetEntrance.GetTargetSwapTile();
			HagletYieldTerm anybodyHasArrrived = Wait.None;
			for (int i = 0; i < members.Length; i++)
			{
				Unit unit = members[i];
				unit.StopMovement(immediate: true);
				v2i? destCoord = walkTarget_SwapTile.coord;
				NC.Path path = null;
				OctDir? endFacing = walkTarget_SwapTile.exitDirection;
				Unit.Movement.Result result = unit.StartMovement(destCoord, path, null, endFacing, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: false, avoidUnits: false, shouldReserveTile: false, forceWalk: false, ignoreTileTriggers: true);
				if (result == Unit.Movement.Result.Arrived)
				{
					anybodyHasArrrived |= Wait.PreMet;
				}
				else if (anybodyHasArrrived != Wait.PreMet && result.Succeeded())
				{
					anybodyHasArrrived |= (HagletYieldTerm)unit.movementStopped;
				}
			}
			if (anybodyHasArrrived != Wait.PreMet)
			{
				yield return anybodyHasArrrived;
			}
		}
		yield return null;
		Map map;
		for (int j = 0; j < members.Length; j++)
		{
			Unit unit2 = members[j];
			v2i coord = transition.swapTargetEntrance.coord;
			map = transition.swapTargetEntrance.GetMap();
			OctDir? endFacing = transition.swapTargetEntrance.enterDirection;
			unit2.StartTeleport(coord, map, null, manuallyHandleShowing: false, deactivateForTeleport: false, lookAtDest: false, endFacing);
		}
		yield return Wait.ForChildren;
		MC inst = Singleton<MC>.Inst;
		map = transition.swapTargetEntrance.GetMap();
		KubrickAnimatorAndClip? mapEntryAnimation = transition.mapEntryAnimation;
		KubrickAnimatorAndClip? mapExitAnimation = transition.mapExitAnimation;
		yield return inst.TransitionToMap(map, null, null, 0f, missionStart: true, mapEntryAnimation, mapExitAnimation);
		if (!wasInCutsceneMode)
		{
			GC.Inst.CutsceneEnd();
		}
	}

	public HagletYieldTerm PlayTeamWideAnim(UnitModel.AnimID animId)
	{
		ConstArray<Unit> constArray = membersActiveInMap;
		HagletYieldTerm result = default(HagletYieldTerm);
		int num = constArray.sLength;
		while (--num >= 0)
		{
			if (constArray[num].unitModel.currentClip.name != constArray[num].unitModel.GetAnimName(animId))
			{
				result &= (HagletYieldTerm)constArray[num].unitModel.Play(animId);
			}
		}
		return result;
	}

	public void UpdateTeamIdleAnims()
	{
		ConstArray<Unit> constArray = membersActiveInMap;
		int num = constArray.sLength;
		while (--num >= 0)
		{
			constArray[num].UpdateIdleAnim();
		}
	}

	[OnDeserializing]
	public void OnLoad(StreamingContext sender)
	{
		membersInWorld = new ConstArray<Unit>(64u);
		membersAliveInWorld = new ConstArray<Unit>(64u);
		membersActiveInMap = new ConstArray<Unit>(64u);
	}

	public void _SetTeamLeader(Unit unit)
	{
		teamLeader = unit;
		if (GC.Inst.GetActiveTeam() == this || (GC.Inst.IsInRPGMode() && type == Type.Player))
		{
			teamLeader.map.VFXTiles.UnitSelectedHide();
			teamLeader.map.VFXTiles.UnitSelectedShow(teamLeader);
			if (GC.Inst.IsInCombatMode())
			{
				GC.Inst.UpdateAllUnitIdles();
			}
			if (GC.Inst.GetTeamOfType(Type.Player).teamLeader != null)
			{
				SC.Inst.UpdateAllUnitStatusBars(updateCover: true);
			}
			UIStatusEffects.Inst.SetTarget(teamLeader);
			if (type != Type.Enemy && type != Type.NPC)
			{
				SC.Inst.SetLeader(teamLeader);
			}
		}
	}

	public Unit GetTeamLeader()
	{
		return teamLeader;
	}

	public Unit FindNextUnitWithAP()
	{
		ConstArray<Unit> activeMembers = GetActiveMembers();
		for (int i = 0; i < activeMembers.Length; i++)
		{
			if (activeMembers[i].AP > 0)
			{
				return activeMembers[i];
			}
		}
		return null;
	}

	public Unit GetMemberWithName(string name)
	{
		for (int i = 0; i < membersInWorld.Length; i++)
		{
			if (membersInWorld[i].charData.name == name)
			{
				return membersInWorld[i];
			}
		}
		return null;
	}

	public Unit GetMemberAtIndex(int index)
	{
		return membersInWorld[index];
	}

	public void AddActiveMember(Unit member)
	{
		if (!membersActiveInMap.Contains(member))
		{
			membersActiveInMap.Add(member);
			if (teamLeader == null)
			{
				_SetTeamLeader(member);
			}
		}
	}

	private void IfMemberWasLeaderElectNewLeader(Unit member)
	{
		if (member == teamLeader)
		{
			if (membersActiveInMap.Length != 0)
			{
				_SetTeamLeader(membersActiveInMap[0]);
			}
			else
			{
				teamLeader = null;
			}
		}
	}

	public void RemoveActiveMember(Unit member)
	{
		membersActiveInMap.Remove(member);
		IfMemberWasLeaderElectNewLeader(member);
	}

	public void AddAliveMember(Unit member)
	{
		membersAliveInWorld.Add(member);
		if (membersAliveInWorld.Length == 1)
		{
			_SetTeamLeader(member);
		}
	}

	public void RemoveAliveMember(Unit member)
	{
		membersAliveInWorld.Remove(member);
		IfMemberWasLeaderElectNewLeader(member);
	}

	public void AddMember(Unit member)
	{
		member.teamController = controller;
		AddAliveMember(member);
		if (member.IsActiveOnMap())
		{
			AddActiveMember(member);
		}
		membersInWorld.Add(member);
		OnUnitAddedToTeam.Trigger();
	}

	public void RemoveMember(Unit member)
	{
		membersInWorld.Remove(member);
		RemoveActiveMember(member);
		RemoveAliveMember(member);
	}

	public void RemoveAll()
	{
		membersInWorld.Clear();
		membersActiveInMap.Clear();
		membersAliveInWorld.Clear();
		teamLeader = null;
	}

	public ConstArray<Unit> GetActiveMembers()
	{
		return (!GC.Inst.IsInMultiplayer()) ? membersActiveInMap : GetMembersAliveInWorld();
	}

	public ConstArray<Unit> GetMembersInWorld()
	{
		return membersInWorld;
	}

	public ConstArray<Unit> GetMembersAliveInWorld()
	{
		return membersAliveInWorld;
	}

	public GangType GetGangTypeForTeam()
	{
		for (int i = 0; i < _gangTypesForTeam.Length; i++)
		{
			_gangTypesForTeam[i] = 0;
		}
		ConstArray<Unit> activeMembers = GetActiveMembers();
		for (int j = 0; j < activeMembers.Length; j++)
		{
			_gangTypesForTeam[(int)activeMembers[j].charData.GangType]++;
		}
		int num = 0;
		int result = 0;
		for (int k = 0; k < _gangTypesForTeam.Length; k++)
		{
			if (_gangTypesForTeam[k] > num)
			{
				num = _gangTypesForTeam[k];
				result = k;
			}
		}
		return (GangType)result;
	}

	public int GetWoundedMemberInMapCount()
	{
		int num = 0;
		for (int i = 0; i < membersActiveInMap.Length; i++)
		{
			if (membersActiveInMap[i].IsWounded())
			{
				num++;
			}
		}
		return num;
	}

	public void APRefill()
	{
		for (uint num = 0u; num < membersActiveInMap.Length; num++)
		{
			membersActiveInMap[num].APRefill();
		}
	}

	public void HPRefill()
	{
		for (uint num = 0u; num < membersActiveInMap.Length; num++)
		{
			membersActiveInMap[num].HPRefill();
		}
	}

	public void OnUnitDeath(Unit unit)
	{
		OnMemberDied.Trigger();
		if (membersAliveInWorld.Length == 0)
		{
			OnTeamDied.Trigger();
		}
		SC.Inst.UpdateAllUnitStatusBars(updateCover: true);
	}

	public HagletYieldTerm MoveTeamToDefaultPositions(bool clearActionTilesOnly = false)
	{
		if (GC.Inst.IsInMultiplayer())
		{
			return Wait.None;
		}
		for (int i = 0; i < membersAliveInWorld.Length; i++)
		{
			Unit unit = membersAliveInWorld[i];
			if ((clearActionTilesOnly && unit.map.GetTileAction(unit.coord) == null) || (unit.teamType == Type.Enemy && !unit.IsActiveOnMap()))
			{
				continue;
			}
			TileDefaultUnitPosition tileDefaultUnitPosition = null;
			if ((GC.Inst.GetRPGLeader() == null || unit != GC.Inst.GetRPGLeader()) && unit.map == Singleton<MC>.Inst.GetActiveMap())
			{
				tileDefaultUnitPosition = Singleton<MC>.Inst.GetActiveMap().GetClosestDefaultUnitPositions(unit.coord);
				if (tileDefaultUnitPosition != null)
				{
					v2i? destCoord = tileDefaultUnitPosition.GetCoord();
					OctDir? endFacing = tileDefaultUnitPosition.direction;
					unit.StartMovement(destCoord, null, null, endFacing);
				}
			}
		}
		return Wait.ForChildren;
	}

	public void HideTeamUI()
	{
		for (int i = 0; i < membersActiveInMap.Length; i++)
		{
			membersActiveInMap[i].HideStatusBar();
		}
	}

	public static Color GetTeamColor(Unit unit)
	{
		return Colors[(int)unit.teamType];
	}

	public static Color GetTeamColor(Type teamType)
	{
		return Colors[(int)teamType];
	}
}
public enum WeaponType
{
	Ranged,
	Melee,
	MAX
}
[CreateAssetMenu]
public class WeaponAttributes : AEScriptableResource
{
	public enum MeleeTypes
	{
		None,
		Blunt,
		Bladed
	}

	[ReadOnly]
	public string weaponName;

	[SerializeField]
	[HideInInspector]
	public GameObject[] weaponModels;

	[SerializeField]
	[HideInInspector]
	public string weaponModelsFolderPath;

	[SerializeField]
	private WeaponType _WeaponType;

	[SerializeField]
	private ParticleBullet.BulletType _BulletType;

	[SerializeField]
	private MeleeTypes _meleeType;

	[SerializeField]
	private int _Damage;

	[SerializeField]
	private int _CriticalChance;

	[SerializeField]
	private int _CriticalDamage;

	[SerializeField]
	private int _RateOfFire = 1;

	public WeaponType WeaponType => _WeaponType;

	public bool IsRanged => _WeaponType == WeaponType.Ranged;

	public bool IsMelee => _WeaponType == WeaponType.Melee;

	public ParticleBullet.BulletType BulletType => _BulletType;

	public MeleeTypes MeleeType => _meleeType;

	public int Damage => _Damage;

	public int CriticalChance => _CriticalChance;

	public int CriticalDamage => _CriticalDamage;

	public int RateOfFire => _RateOfFire;

	public WeaponModel GetWeaponModel(int index)
	{
		if (index < weaponModels.Length && index >= 0)
		{
			return weaponModels[index].GetComponent<WeaponModel>();
		}
		return null;
	}

	protected override void OnValidate()
	{
		weaponName = base.name.Replace("WeaponAttributes_", string.Empty).Replace("_", " ");
		_Damage = Mathf.Clamp(Damage, 0, int.MaxValue);
		_CriticalChance = Mathf.Clamp(CriticalChance, 0, int.MaxValue);
		_CriticalDamage = Mathf.Clamp(CriticalDamage, 0, int.MaxValue);
		_RateOfFire = Mathf.Clamp(RateOfFire, 1, int.MaxValue);
		if (IsMelee)
		{
			_BulletType = ParticleBullet.BulletType.None;
		}
		base.OnValidate();
	}
}
public class WeaponModel : MonoBehaviour
{
	private BarrelXForm _barrelXForm;

	public BarrelXForm BarrelXForm
	{
		get
		{
			if (_barrelXForm == null)
			{
				_barrelXForm = GetComponentInChildren<BarrelXForm>();
			}
			return _barrelXForm;
		}
	}

	public void OnSpawn(Transform weaponXForm)
	{
		base.transform.SetParent(weaponXForm, worldPositionStays: false);
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		base.transform.localScale = Vector3.one;
	}
}
public class AECameraFullscreenPass : MonoBehaviour
{
	private class FadedToClearCondition : HagletCondition
	{
		protected override bool GetValue()
		{
			return Inst.animFadeAmount.Value < Mathf.Epsilon || !Inst.fullScreenRenderer.gameObject.activeInHierarchy;
		}
	}

	private static AECameraFullscreenPass _instance;

	public HagletTrigger OnFadeToColourComplete = new HagletTrigger();

	public HagletTrigger OnFadeToClearComplete = new HagletTrigger();

	public Action OnFadeToClear;

	public Action OnFadeToColor;

	public AnimationCurve curveLitAmount = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

	private AnimFloat animFadeAmount = new AnimFloat(1f);

	private AnimationCurve customFadeCurve;

	public bool paused;

	private Color fadeColour = new Color(0f, 0f, 0f, 1f);

	private Shader fadeShader;

	private Material matFullscreen;

	private Mesh quadMesh;

	private Camera cameraComp;

	private Vector3[] meshNormals;

	private AnimFloat animBloomIntensity = new AnimFloat(0f);

	private Vector4 bloomCameraFOVAspect;

	private MeshRenderer fullScreenRenderer;

	private int colorTintSID;

	private FadedToClearCondition _IsFadedToClear = new FadedToClearCondition();

	public static AECameraFullscreenPass Inst => _instance;

	public Color CurrentColour { get; private set; }

	public HagletCondition IsFadedToClear => _IsFadedToClear;

	public bool IsFadingToClear => (bool)animFadeAmount.animating && animFadeAmount.Target == 0f;

	public bool IsFadingToColor => (bool)animFadeAmount.animating && animFadeAmount.Target == 1f;

	private void Awake()
	{
		_instance = this;
		quadMesh = new Mesh();
		quadMesh.vertices = new Vector3[4]
		{
			new Vector3(-1f, -1f),
			new Vector3(1f, -1f),
			new Vector3(1f, 1f),
			new Vector3(-1f, 1f)
		};
		meshNormals = new Vector3[4]
		{
			Vector3.forward,
			Vector3.forward,
			Vector3.forward,
			Vector3.forward
		};
		quadMesh.SetIndices(new int[4] { 0, 1, 2, 3 }, MeshTopology.Quads, 0);
		quadMesh.RecalculateBounds();
		fadeShader = Shader.Find("AE/FullscreenFadeShader");
		matFullscreen = new Material(fadeShader);
		matFullscreen.renderQueue = 4999;
		cameraComp = Singleton<CC>.Inst.Camera;
		GameObject gameObject = new GameObject("AECameraFullscreenPass", typeof(MeshFilter), typeof(MeshRenderer));
		gameObject.transform.parent = cameraComp.transform;
		gameObject.transform.localPosition = Vector3.forward * 0.15f;
		gameObject.layer = 1;
		MeshFilter component = gameObject.GetComponent<MeshFilter>();
		component.sharedMesh = quadMesh;
		fullScreenRenderer = gameObject.GetComponent<MeshRenderer>();
		fullScreenRenderer.sharedMaterial = matFullscreen;
		fullScreenRenderer.sortingOrder = 32765;
		colorTintSID = Shader.PropertyToID("_ColorTint");
		animFadeAmount.Interpolate = CustomFadeCurveWrapper;
		SetColor(Color.black);
	}

	private float CustomFadeCurveWrapper(float t)
	{
		if (customFadeCurve != null)
		{
			return customFadeCurve.Evaluate(t);
		}
		return Mathf.SmoothStep(0f, 1f, t);
	}

	public void StartFadeToColor(bool autoFadeBackToClear, float fadeTime, float delay = 0f, AnimationCurve animationCurve = null)
	{
		customFadeCurve = animationCurve;
		fullScreenRenderer.gameObject.SetActive(value: true);
		animFadeAmount.Value = 0f;
		animFadeAmount.OnComplete = delegate
		{
			if (OnFadeToColor != null)
			{
				OnFadeToColor();
			}
			if (autoFadeBackToClear)
			{
				StartFadeToClear(fadeTime);
			}
			OnFadeToColourComplete.Trigger();
		};
		animFadeAmount.AnimateTo(1f, fadeTime, delay);
	}

	public void StartFadeToClear(float fadeTime, float fadeDelay = 0f)
	{
		customFadeCurve = null;
		animFadeAmount.Value = 1f;
		animFadeAmount.OnComplete = delegate
		{
			if (OnFadeToClear != null)
			{
				OnFadeToClear();
			}
			fullScreenRenderer.gameObject.SetActive(value: false);
			OnFadeToClearComplete.Trigger();
		};
		animFadeAmount.AnimateTo(0f, fadeTime, fadeDelay);
	}

	private void Update()
	{
		if (!paused)
		{
			float t = animFadeAmount.Update(Math.Min(Time.deltaTime, 0.1f));
			SetColor(Color.Lerp(Color.clear, fadeColour, t));
		}
		int width = Screen.width;
		int height = Screen.height;
		ref Vector3 reference = ref meshNormals[0];
		reference = -cameraComp.ScreenPointToRay(new Vector3(0f, 0f, 0f)).direction;
		ref Vector3 reference2 = ref meshNormals[1];
		reference2 = -cameraComp.ScreenPointToRay(new Vector3(width, 0f, 0f)).direction;
		ref Vector3 reference3 = ref meshNormals[2];
		reference3 = -cameraComp.ScreenPointToRay(new Vector3(width, height, 0f)).direction;
		ref Vector3 reference4 = ref meshNormals[3];
		reference4 = -cameraComp.ScreenPointToRay(new Vector3(0f, height, 0f)).direction;
		quadMesh.normals = meshNormals;
		if ((bool)animBloomIntensity.animating)
		{
			bloomCameraFOVAspect.z = animBloomIntensity.Update();
			matFullscreen.SetVector("_cameraFOVAspect", bloomCameraFOVAspect);
		}
	}

	public void SetColor(Color color)
	{
		CurrentColour = color;
		matFullscreen.SetColor(colorTintSID, color);
	}

	public void SetBloomIntensity(float intensity)
	{
		ref Vector4 reference = ref bloomCameraFOVAspect;
		animBloomIntensity.Value = intensity;
		reference.z = intensity;
		matFullscreen.SetVector("_cameraFOVAspect", bloomCameraFOVAspect);
	}

	public void AnimateBloomIntensity(float target, float time)
	{
		animBloomIntensity.AnimateTo(target, time);
	}

	public void SetBloomPrepass(RenderTexture rtTexturePrepass, float fov, float aspectRatio)
	{
		matFullscreen.SetTexture("_FogPrepassRT", rtTexturePrepass);
		bloomCameraFOVAspect.x = 1f / Mathf.Tan(fov * ((float)Math.PI / 180f) * 0.5f);
		bloomCameraFOVAspect.y = 1f / aspectRatio;
		bloomCameraFOVAspect.z = 0f;
		matFullscreen.SetVector("_cameraFOVAspect", bloomCameraFOVAspect);
	}
}
public class AECharacterWeaponAtlas : ScriptableObject
{
	[Serializable]
	public class StringToRectDict : SerialisableDictionary<string, Rect>
	{
	}

	public const string atlasResPath = "CharacterWeaponAtlas/AtlasData";

	public const string textureResPath = "CharacterWeaponAtlas/TX_AtlasTexture";

	[SerializeField]
	private StringToRectDict atlasDict = new StringToRectDict();

	public void ClearDict()
	{
		atlasDict.dict.Clear();
	}

	public void AddDictEntry(string path, Rect rect)
	{
		atlasDict.dict.Add(path, rect);
	}

	public bool GetRect(string path, out Rect rect)
	{
		return atlasDict.dict.TryGetValue(path, out rect);
	}
}
public static class AEMisc
{
	public static string StreamingAssetsPath { get; private set; }

	public static string DataPath { get; private set; }

	public static string PersistentDataPath { get; private set; }

	public static void PrefetchUnityPaths()
	{
		StreamingAssetsPath = UnityEngine.Application.streamingAssetsPath;
		DataPath = UnityEngine.Application.dataPath;
		PersistentDataPath = UnityEngine.Application.persistentDataPath;
	}

	public static void ArrayAdd<T>(ref T[] arr, T itemToAdd)
	{
		T[] array;
		if (arr == null)
		{
			array = new T[1];
		}
		else
		{
			array = new T[arr.Length + 1];
			for (int i = 0; i < arr.Length; i++)
			{
				array[i] = arr[i];
			}
		}
		array[array.Length - 1] = itemToAdd;
		arr = array;
	}

	public static string GetJarPath(string path)
	{
		return "jar:file://" + DataPath + "!/assets/" + path;
	}

	public static string GetUnpackedPath(string path)
	{
		return PersistentDataPath + "/" + path;
	}
}
[Acquisitor]
public class AEPrefab : Serializer_Prefab
{
	private class Acquisitor : Serializer.ExternalPrefabReacquisitor
	{
		public override void Deacquire(Serializer_Prefab instance, BinaryWriter writer)
		{
		}

		public override GameObject Reacquire(string path, BinaryReader reader)
		{
			return AEResources.LoadFirstAsset<GameObject>(path);
		}
	}

	protected override bool requiresResourceFolder => false;
}
public static class AEResources
{
	private class _ShutdownWorkerThread : MonoBehaviour
	{
		private const int timeout = 3500;

		private void OnApplicationQuit()
		{
			lock (workerThreadSignal)
			{
				workerThreadRun = false;
				workerThreadTask = null;
				workerThreadSignal.Set();
			}
			if (!workerThread.Join(3500))
			{
				UnityEngine.Debug.LogError(workerThread.Name + " did not terminate after " + 3500 + "ms.");
			}
		}
	}

	public class BundleSpec
	{
		public string name;

		public string fileName;

		public BundleSpec(string name)
		{
			this.name = name;
			fileName = "assetbundles/" + name + ".unity3d";
		}
	}

	public class AssetBundleWrapper
	{
		public enum LoadState
		{
			UNLOADED,
			LOADING,
			LOADED
		}

		public BundleSpec bundleSpec;

		public AssetBundle bundle;

		public AssetFolder[] assetPaths;

		public HagletResettable loadRoutine;

		public LoadState loadState;

		public IEnumerator<HagletYieldTerm> LoadBundleRoutine()
		{
			if (loadState != 0)
			{
				yield break;
			}
			loadState = LoadState.LOADING;
			if (0 == 0)
			{
				string bPath = UnityEngine.Application.streamingAssetsPath + "/" + bundleSpec.fileName;
				AssetBundleCreateRequest bReq = AssetBundle.LoadFromFileAsync(bPath);
				yield return Wait.Until(() => bReq.isDone);
				bundle = bReq.assetBundle;
				string[] assetNames = bundle.GetAllAssetNames();
				AddThreadTask(delegate
				{
					assetPaths = Digest(assetNames);
					assetNames.BuildDictionaries(bundle, ref _assets, ref _resources);
				});
				yield return Wait.While(ThreadBusy);
			}
			loadState = LoadState.LOADED;
		}
	}

	public struct BundleMapper
	{
		public AssetBundle bundle;

		public string assetBundlePath;
	}

	public class AssetFolder
	{
		public string folder;

		public List<string> assetPaths;

		public int endIdx;

		public int nameIdx;

		public HashSet<AssetFolder> dependants = new HashSet<AssetFolder>();

		public static AssetFolder NewAPFromPath(string path)
		{
			AssetFolder assetFolder = new AssetFolder();
			assetFolder.endIdx = ((!Path.HasExtension(path)) ? path.Length : path.LastIndexOf('.'));
			assetFolder.nameIdx = path.LastIndexOf(Path.AltDirectorySeparatorChar);
			assetFolder.folder = path.Truncate(path.LastIndexOf(Path.AltDirectorySeparatorChar));
			assetFolder.assetPaths = new List<string>();
			AssetFolder assetFolder2 = assetFolder;
			assetFolder2.assetPaths.Add(path);
			return assetFolder2;
		}

		public static bool AddPath(AssetFolder ap, string path)
		{
			int maxLen = path.LastIndexOf(Path.AltDirectorySeparatorChar);
			string text = path.Truncate(maxLen);
			if (ap.folder != text)
			{
				return false;
			}
			if (ap.assetPaths.Contains(path))
			{
				return true;
			}
			ap.assetPaths.Add(path);
			return true;
		}

		public string GetIndividualMatch(string filter, int filterEndIdx)
		{
			for (int i = 0; i < assetPaths.Count; i++)
			{
				string text = assetPaths[i];
				int j = 0;
				for (int num = Mathf.Min(filterEndIdx, endIdx); j < num; j++)
				{
					if (text[endIdx - 1 - j] != filter[filterEndIdx - 1 - j])
					{
						return text;
					}
				}
			}
			return null;
		}

		public bool FolderMatch(string filter, int filterEndIdx)
		{
			int i = 0;
			for (int num = Mathf.Min(nameIdx, filterEndIdx); i < num; i++)
			{
				if (folder[nameIdx - 1 - i] != filter[filterEndIdx - 1 - i])
				{
					return false;
				}
			}
			return true;
		}
	}

	private static bool initialised = false;

	private static readonly BundleSpec[] bundleSpecs = new BundleSpec[4]
	{
		new BundleSpec("core"),
		new BundleSpec("external"),
		new BundleSpec("core_scenes"),
		new BundleSpec("external_scenes")
	};

	public static Dictionary<string, List<string>> dependentsFromLastBuild = new Dictionary<string, List<string>>();

	private const string bundlesInEditorPrefsKey = "AEResources - Use Bundles In Editor";

	private const string bundleIDKeyFormat = "AEResources - {0} ID";

	private static AssetBundleWrapper[] bundles;

	private static Dictionary<string, BundleMapper> _assets = new Dictionary<string, BundleMapper>();

	private static Dictionary<string, BundleMapper> _resources = new Dictionary<string, BundleMapper>();

	private static HagletResettable unpackFileFromJarRoutine;

	private static IntPtr cls_AssetCopy_g;

	private static IntPtr mth_AssetCopy_copyAsset;

	private static volatile bool workerThreadRun;

	private static volatile Thread workerThread;

	private static volatile Action workerThreadTask;

	private static readonly AutoResetEvent workerThreadSignal = new AutoResetEvent(initialState: false);

	public static Func<bool> ThreadBusy = _ThreadBusy;

	public static bool wasLoaded = false;

	private static readonly string unityResourcesPathSeg = Path.AltDirectorySeparatorChar + "Resources" + Path.AltDirectorySeparatorChar;

	private static string destUnpackedPath;

	private static string sourceAssetPath;

	public static bool isInitialised()
	{
		return initialised;
	}

	public static void AddThreadTask(Action task)
	{
		lock (workerThreadSignal)
		{
			workerThreadTask = (Action)Delegate.Combine(workerThreadTask, task);
			workerThreadSignal.Set();
		}
	}

	private static bool _ThreadBusy()
	{
		return workerThreadTask != null;
	}

	public static void Initialise()
	{
		if (initialised)
		{
			return;
		}
		bundles = new AssetBundleWrapper[bundleSpecs.Length];
		for (int i = 0; i < bundles.Length; i++)
		{
			bundles[i] = new AssetBundleWrapper();
			bundles[i].bundleSpec = bundleSpecs[i];
			bundles[i].loadRoutine = new HagletResettable(bundles[i].LoadBundleRoutine());
		}
		unpackFileFromJarRoutine = new HagletResettable(UnpackFileFromJarRoutine());
		using (AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
		{
			using AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.coatsink.tools.assetcopy.AssetCopy");
			cls_AssetCopy_g = AndroidJNI.NewGlobalRef(androidJavaClass.GetRawClass());
			mth_AssetCopy_copyAsset = AndroidJNI.GetStaticMethodID(cls_AssetCopy_g, "copyAsset", "(Ljava/lang/String;Ljava/lang/String;)V");
			AndroidJavaObject @static = androidJavaClass2.GetStatic<AndroidJavaObject>("currentActivity");
			androidJavaClass.CallStatic("setActivity", @static);
		}
		workerThread = new Thread((ThreadStart)delegate
		{
			try
			{
				AndroidJNI.AttachCurrentThread();
				UnityEngine.Debug.Log("AEResources worker thread started and JNI attached.");
				while (workerThreadRun)
				{
					try
					{
						workerThreadSignal.WaitOne();
						if (workerThreadRun && workerThreadTask != null)
						{
							lock (workerThreadSignal)
							{
								workerThreadTask();
								workerThreadTask = null;
							}
						}
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
			}
			finally
			{
				AndroidJNI.DetachCurrentThread();
				UnityEngine.Debug.Log("AEResources worker thread terminating and JNI detached.");
			}
		});
		GameObject gameObject = new GameObject("AEResources Thread Shutter Downer");
		gameObject.AddComponent<_ShutdownWorkerThread>();
		UnityEngine.Object.DontDestroyOnLoad(gameObject);
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		workerThreadRun = true;
		workerThread.Name = "AEResources Worker Thread";
		workerThread.IsBackground = true;
		workerThread.Start();
		initialised = true;
	}

	public static void LoadBundle(string bundlePath, bool immediate = false)
	{
		AssetBundleWrapper[] array = bundles;
		foreach (AssetBundleWrapper assetBundleWrapper in array)
		{
			if (assetBundleWrapper.bundleSpec.fileName == bundlePath)
			{
				if (!immediate)
				{
					Routine.Start(assetBundleWrapper.loadRoutine);
				}
				else
				{
					UnityEngine.Debug.LogError("Attempted to call LoadBundleImmediate outside of editor.");
				}
				return;
			}
		}
		string text = "Could not find bundle within bundle list at path: " + bundlePath + "\n Bundles are listed below: \n";
		AssetBundleWrapper[] array2 = bundles;
		foreach (AssetBundleWrapper assetBundleWrapper2 in array2)
		{
			text = text + assetBundleWrapper2.bundleSpec.fileName + "\n";
		}
		UnityEngine.Debug.LogError(text);
	}

	private static void TryLoadBundle(ref AssetBundle bundle, string bundleAssetPath, ref AssetFolder[] paths)
	{
		UnityEngine.Debug.Log("[AEResources] Loading bundle " + bundleAssetPath);
		bundle = AssetBundle.LoadFromFile(bundleAssetPath);
		if (bundle == null)
		{
			paths = null;
			LogError("Failed to load bundle from \"{0}\"!", bundleAssetPath);
		}
		string[] allAssetNames = bundle.GetAllAssetNames();
		paths = Digest(allAssetNames);
		allAssetNames.BuildDictionaries(bundle, ref _assets, ref _resources);
	}

	public static AssetFolder[] Digest(string[] paths)
	{
		List<AssetFolder> list = new List<AssetFolder>();
		Dictionary<string, AssetFolder> dictionary = new Dictionary<string, AssetFolder>();
		foreach (string text in paths)
		{
			string key = text.ToLower().Truncate(text.LastIndexOf(Path.AltDirectorySeparatorChar));
			if (dictionary.TryGetValue(key, out var value))
			{
				AssetFolder.AddPath(value, text);
				continue;
			}
			value = AssetFolder.NewAPFromPath(text);
			dictionary.Add(key, value);
			list.Add(value);
		}
		return list.ToArray();
	}

	private static void BuildDictionaries(this string[] paths, AssetBundle assetBundle, ref Dictionary<string, BundleMapper> dAssets, ref Dictionary<string, BundleMapper> dResources)
	{
		string text = unityResourcesPathSeg.ToLower();
		for (int i = 0; i < paths.Length; i++)
		{
			string text2 = paths[i].ToLower();
			BundleMapper bundleMapper = default(BundleMapper);
			bundleMapper.bundle = assetBundle;
			bundleMapper.assetBundlePath = text2;
			BundleMapper value = bundleMapper;
			dAssets.Add(text2, value);
			if (text2.Contains(text))
			{
				int num = text2.IndexOf(text) + text.Length;
				int num2 = text2.LastIndexOf('.');
				string key = text2.Substring(num, num2 - num);
				dResources.Add(key, value);
			}
		}
	}

	public static T LoadFirstAsset<T>(string filter, Type type = null, bool throwOnError = false) where T : UnityEngine.Object
	{
		filter = filter.ToLower();
		BundleMapper bundleMapper = default(BundleMapper);
		bundleMapper.bundle = null;
		bundleMapper.assetBundlePath = null;
		if (_assets.ContainsKey(filter))
		{
			bundleMapper = _assets[filter];
		}
		if (bundleMapper.assetBundlePath == null)
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resource asset found matching filter \"{filter}\"!");
			}
			LogError("No resource asset found matching filter \"{0}\"", filter);
			return (T)null;
		}
		UnityEngine.Object obj = bundleMapper.bundle.LoadAsset(bundleMapper.assetBundlePath);
		return CastAssetObject<T>(obj);
	}

	public static T LoadFirstResource<T>(string filter, bool throwOnError = false) where T : UnityEngine.Object
	{
		filter = filter.ToLower();
		BundleMapper bundleMapper = default(BundleMapper);
		bundleMapper.bundle = null;
		bundleMapper.assetBundlePath = null;
		if (_resources.ContainsKey(filter))
		{
			bundleMapper = _resources[filter];
		}
		if (bundleMapper.assetBundlePath == null)
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resource asset found matching filter \"{filter}\"!");
			}
			LogError("No resource asset found matching filter \"{0}\"", filter);
			return (T)null;
		}
		UnityEngine.Object obj = bundleMapper.bundle.LoadAsset(bundleMapper.assetBundlePath);
		return CastAssetObject<T>(obj);
	}

	public static T[] LoadAllResources<T>(string filter, bool throwOnError = false, bool silent = false, string nameContainFilter = null) where T : UnityEngine.Object
	{
		List<T> list = new List<T>(32);
		BundleMapper[] assetMappings = GetAssetMappings(filter, nameContainFilter);
		BundleMapper[] array = assetMappings;
		for (int i = 0; i < array.Length; i++)
		{
			BundleMapper bundleMapper = array[i];
			T val = CastAssetObject<T>(bundleMapper.bundle.LoadAsset(bundleMapper.assetBundlePath));
			if (val != null)
			{
				list.Add(val);
			}
		}
		if (list.Count == 0 && !silent)
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resources found matching filter \"{filter}\"!");
			}
			LogError("No resource assets found matching filter \"{0}\"", filter);
			return new T[0];
		}
		return list.ToArray();
	}

	public static BundleMapper[] GetAssetMappings(string filter, string nameContainFilter = null)
	{
		filter = filter.ToLower();
		List<BundleMapper> list = new List<BundleMapper>();
		bool flag = Path.HasExtension(filter);
		int filterEndIdx = ((!flag) ? filter.Length : filter.LastIndexOf('.'));
		if (nameContainFilter != null)
		{
			nameContainFilter = nameContainFilter.ToLower();
		}
		for (int i = 0; i < bundles.Length; i++)
		{
			AssetBundleWrapper assetBundleWrapper = bundles[i];
			AssetFolder[] assetPaths = assetBundleWrapper.assetPaths;
			if (assetPaths == null)
			{
				continue;
			}
			foreach (AssetFolder assetFolder in assetPaths)
			{
				if (!assetFolder.FolderMatch(filter, filterEndIdx))
				{
					continue;
				}
				if (flag)
				{
					string individualMatch = assetFolder.GetIndividualMatch(filter, filterEndIdx);
					if (individualMatch != null)
					{
						list.Add(new BundleMapper
						{
							bundle = assetBundleWrapper.bundle,
							assetBundlePath = individualMatch
						});
						break;
					}
					continue;
				}
				for (int k = 0; k < assetFolder.assetPaths.Count; k++)
				{
					string text = assetFolder.assetPaths[k];
					if (nameContainFilter != null)
					{
						int startIndex = text.LastIndexOf('/') + 1;
						if (text.IndexOf(nameContainFilter, startIndex, StringComparison.Ordinal) < 0)
						{
							continue;
						}
					}
					list.Add(new BundleMapper
					{
						bundle = assetBundleWrapper.bundle,
						assetBundlePath = text
					});
				}
			}
		}
		return list.ToArray();
	}

	private static T CastAssetObject<T>(UnityEngine.Object obj) where T : UnityEngine.Object
	{
		T val = obj as T;
		if (val == null)
		{
			GameObject gameObject = obj as GameObject;
			if (gameObject != null)
			{
				val = gameObject.GetComponent<T>();
			}
		}
		return val;
	}

	private static void LogError(string format, object arg1 = null, object arg2 = null)
	{
		UnityEngine.Debug.LogErrorFormat("[AEResources] " + format, arg1, arg2);
	}

	public static HagletYieldTerm UnpackFileFromJar(string sourcePath, string destPath)
	{
		sourceAssetPath = sourcePath;
		destUnpackedPath = destPath;
		return Routine.Start(unpackFileFromJarRoutine);
	}

	public static IEnumerator<HagletYieldTerm> UnpackFileFromJarRoutine()
	{
		AddThreadTask(delegate
		{
			Directory.CreateDirectory(Path.GetDirectoryName(destUnpackedPath));
			if (File.Exists(destUnpackedPath))
			{
				File.Delete(destUnpackedPath);
			}
			try
			{
				AndroidJNI.PushLocalFrame(5);
				jvalue jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(sourceAssetPath);
				jvalue jvalue2 = jvalue;
				jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(destUnpackedPath);
				jvalue jvalue3 = jvalue;
				AndroidJNI.CallStaticVoidMethod(cls_AssetCopy_g, mth_AssetCopy_copyAsset, new jvalue[2] { jvalue2, jvalue3 });
			}
			finally
			{
				AndroidJNI.PopLocalFrame(IntPtr.Zero);
			}
		});
		yield return Wait.While(ThreadBusy);
		UnityEngine.Debug.Log("[RESOURCES] write of '" + destUnpackedPath + "' completed.");
	}
}
[Acquisitor]
public class AEScriptableResource : ScriptableResource
{
	private class Acquisitor : Serializer.ExternalResourceAcquisitor
	{
		public override void Deacquire(ScriptableResource obj, Type type, BinaryWriter writer)
		{
		}

		public override ScriptableResource Reacquire(string path, Type type, BinaryReader reader)
		{
			return AEResources.LoadFirstAsset<ScriptableResource>(path, type);
		}
	}

	protected override bool requiresResourceFolder => false;
}
public static class BarkQueue
{
	private struct QueuedBark
	{
		public string barkPath;

		public Unit barkingUnit;

		public Unit targetUnit;
	}

	private static Queue<QueuedBark> barkQueue = new Queue<QueuedBark>(8);

	private static FMOD.Studio.EventInstance? activeBark;

	public static bool IsBarkPlaying => activeBark.HasValue && AC.Inst.IsInstancePlaying(activeBark.Value);

	public static bool ShouldBarkPlay => !GC.Inst.IsInCutsceneMode() && !UIAmbientSubtitles.Inst.IsShown && !LR.HACK_tutorialMode;

	public static void QueueBark(string barkPath, Unit barker, Unit target)
	{
		if (MR.Inst.IsSkipping())
		{
			return;
		}
		if (barkQueue.Count == 0 && !IsBarkPlaying)
		{
			if ((barker == null || barker.IsAlive()) && (target == null || target.IsAlive()))
			{
				activeBark = AC.Inst.PlayOneShot2D(barkPath);
			}
		}
		else
		{
			QueuedBark item = default(QueuedBark);
			item.barkPath = barkPath;
			item.barkingUnit = barker;
			item.targetUnit = target;
			barkQueue.Enqueue(item);
		}
	}

	public static void Update()
	{
		if (!activeBark.HasValue || IsBarkPlaying)
		{
			return;
		}
		if (barkQueue.Count == 0)
		{
			activeBark = null;
		}
		else if (!ShouldBarkPlay)
		{
			for (int i = 0; i < barkQueue.Count; i++)
			{
				barkQueue.Dequeue();
			}
			activeBark = null;
		}
		else
		{
			QueuedBark queuedBark = barkQueue.Dequeue();
			if ((queuedBark.barkingUnit == null || queuedBark.barkingUnit.IsAlive()) && (queuedBark.targetUnit == null || queuedBark.targetUnit.IsAlive()))
			{
				activeBark = AC.Inst.PlayOneShot2D(queuedBark.barkPath);
			}
		}
	}
}
public class BarrelXForm : MonoBehaviour
{
}
[Serializable]
public class BehaviourCache
{
	public Renderer[] renderers;

	public Collider[] colliders;

	public Behaviour[] behaviours;

	public void Build(GameObject root, Type[] filter)
	{
		renderers = root.GetComponentsInChildren<Renderer>(includeInactive: true);
		colliders = root.GetComponentsInChildren<Collider>(includeInactive: true);
		List<Behaviour> list = new List<Behaviour>();
		for (int i = 0; i < filter.Length; i++)
		{
			UnityEngine.Component[] componentsInChildren = root.GetComponentsInChildren(filter[i], includeInactive: true);
			UnityEngine.Component[] array = componentsInChildren;
			foreach (UnityEngine.Component component in array)
			{
				list.Add((Behaviour)component);
			}
		}
		behaviours = list.ToArray();
	}

	public void CullParentType<T>() where T : UnityEngine.Component
	{
		renderers = _CullParentType<T, Renderer>(renderers);
		colliders = _CullParentType<T, Collider>(colliders);
		behaviours = _CullParentType<T, Behaviour>(behaviours);
	}

	private C[] _CullParentType<T, C>(C[] components) where T : UnityEngine.Component where C : UnityEngine.Component
	{
		List<C> list = new List<C>(components);
		int num = 0;
		while (num < list.Count)
		{
			if ((bool)list[num].GetComponentInAscendant<T>())
			{
				list.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
		return list.ToArray();
	}

	public void SetEnabled(bool enabled, bool affectColliders)
	{
		int num = renderers.Length;
		for (int i = 0; i < num; i++)
		{
			renderers[i].enabled = enabled;
		}
		int num2 = behaviours.Length;
		for (int j = 0; j < num2; j++)
		{
			behaviours[j].enabled = enabled;
		}
		if (affectColliders)
		{
			SetEnabledColliders(enabled);
		}
	}

	public void SetEnabledColliders(bool enabled)
	{
		int num = colliders.Length;
		for (int i = 0; i < num; i++)
		{
			colliders[i].enabled = enabled;
		}
	}

	public void SetEnabledBehaviours<T>(bool enabled)
	{
		SetEnabledBehaviours(enabled, typeof(T));
	}

	public void SetEnabledBehaviours(bool enabled, Type type = null)
	{
		int num = behaviours.Length;
		for (int i = 0; i < num; i++)
		{
			if (type == null || behaviours[i].IsOfTypeOrSubType(type))
			{
				behaviours[i].enabled = enabled;
			}
		}
	}
}
public class BigWillaAnimFuncs : MonoBehaviour
{
	[AEAnimFunc]
	private void AmbientSubtitleShow(DialogData data, bool noReIdle)
	{
		UIAmbientSubtitles inst = UIAmbientSubtitles.Inst;
		bool dontReturnToIdle = noReIdle;
		inst.Show(data, null, null, dontReturnToIdle);
	}

	private static float AmbientSubtitleShow_GetDuration(DialogData data, bool noReIdle)
	{
		if ((bool)data)
		{
			float num = 0f;
			for (int i = 0; i < data.dialogs.Length; i++)
			{
				DialogData.Dialog dialog = data.dialogs[i];
				AC.Inst.GetDescription(VOController.Inst.GetVOGuid(dialog.bodyKey)).getLength(out var length);
				num += Mathf.Max((float)length * 0.001f, data.dialogs[i].subtitleTime);
				num += dialog.bufferTime;
			}
			return num;
		}
		return 0f;
	}

	private static string AmbientSubtitleShow_GetDisplayName(DialogData data, bool noReIdle)
	{
		if (data == null)
		{
			return "AmbientSubtitleShow";
		}
		return data.name;
	}
}
public class ChairRotation : MonoBehaviour
{
	private Transform target;

	public bool useExactChairRotation;

	private float minDiff = 10f;

	private float maxDiff = 80f;

	public bool useY;

	public void Start()
	{
		if (LR.Inst != null)
		{
			target = Singleton<CC>.Inst._camera.transform;
		}
		else
		{
			CC cC = UnityEngine.Object.FindObjectOfType<CC>();
			target = cC._camera.transform;
		}
		if (useExactChairRotation)
		{
			minDiff = 5f;
			maxDiff = 6f;
		}
	}

	private void Update()
	{
		Vector3 eulerAngles = target.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		Quaternion rotation = base.transform.rotation;
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		float num = Quaternion.Angle(rotation, quaternion);
		float num2 = Mathf.Abs(num);
		if (num2 > minDiff)
		{
			float maxDegreesDelta = ((!(num2 > maxDiff)) ? (Mathf.Max(0.1f, Mathf.Lerp(0f, num, (num2 - minDiff) / (maxDiff - minDiff))) * Time.deltaTime) : (num2 - maxDiff));
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, maxDegreesDelta);
		}
	}
}
public class CharacterWeaponAtlasRef : MonoBehaviour
{
	[ReadOnly]
	public string texturePath;
}
public class Credits
{
	public class Role
	{
		public string name;

		public List<string> people = new List<string>();
	}

	public class Company
	{
		public string name;

		public bool shuffle;

		public List<Role> roles = new List<Role>();
	}

	public List<Company> companies = new List<Company>();

	public static Credits Load(string resourcePath)
	{
		Credits credits = new Credits();
		TextAsset textAsset = Resources.Load<TextAsset>(resourcePath);
		if (textAsset == null)
		{
			UnityEngine.Debug.LogError("CreditsController: Failed to open 'credits_list.csv'!");
			return credits;
		}
		string[] array = textAsset.text.Split("\n"[0]);
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = array[i].Replace("\r", string.Empty);
		}
		Company company = null;
		Role role = null;
		for (int j = 0; j < array.Length; j++)
		{
			string text = array[j].Trim();
			if (array.Length != 0 && !string.IsNullOrEmpty(text) && !text.StartsWith("//"))
			{
				if (text.StartsWith("[GROUP]"))
				{
					text = text.Replace("[GROUP]", string.Empty).TrimEnd();
					Company company2 = new Company();
					company2.name = text;
					company2.shuffle = false;
					company = company2;
					credits.companies.Add(company);
				}
				else if (text.StartsWith("[GROUP_SHUFFLE]"))
				{
					text = text.Replace("[GROUP_SHUFFLE]", string.Empty).TrimEnd();
					Company company2 = new Company();
					company2.name = text;
					company2.shuffle = true;
					company = company2;
					credits.companies.Add(company);
				}
				else if (company == null)
				{
					UnityEngine.Debug.Log("No company defined at line: " + j);
				}
				else if (text.StartsWith("[ROLE]"))
				{
					text = text.Replace("[ROLE]", string.Empty).TrimEnd();
					Role role2 = new Role();
					role2.name = text;
					role = role2;
					company.roles.Add(role);
				}
				else if (role == null)
				{
					UnityEngine.Debug.Log("No role defined at line: " + j);
				}
				else if (!string.IsNullOrEmpty(text))
				{
					role.people.Add(text);
				}
			}
		}
		return credits;
	}
}
public enum UICrosshairContext
{
	None,
	Door,
	Interaction,
	Looting,
	Talking,
	Inspect,
	Target
}
public class Crosshair : UIContainer
{
	public enum CrosshairMode
	{
		Default,
		Framerate,
		Off
	}

	public Sprite[] DEBUG_CrosshairSprites;

	public Sprite DEBUG_WhiteCrosshairSprite;

	[ReadOnly]
	public Transform radialBarTrans;

	private Transform crosshairParent;

	[ReadOnly]
	public Material radialBarMat;

	private int radialCutoffID;

	private HagletResettable radialClickAnim;

	private UIImage sprite;

	private UIImage spriteDebugFrameRate;

	private CrosshairMode _crosshairMode;

	public static Crosshair Inst { get; private set; }

	public static Vector3 cursorPos => Inst.sprite.transform.position;

	public CrosshairMode CrosshairDisplayMode
	{
		get
		{
			return _crosshairMode;
		}
		set
		{
			_crosshairMode = value;
			switch (_crosshairMode)
			{
			case CrosshairMode.Default:
				sprite.enabled = true;
				spriteDebugFrameRate.enabled = false;
				radialBarTrans.gameObject.SetActive(value: true);
				break;
			case CrosshairMode.Framerate:
				sprite.enabled = false;
				spriteDebugFrameRate.enabled = true;
				radialBarTrans.gameObject.SetActive(value: true);
				break;
			case CrosshairMode.Off:
				sprite.enabled = false;
				spriteDebugFrameRate.enabled = false;
				radialBarTrans.gameObject.SetActive(value: false);
				break;
			}
			sprite.gameObject.SetActive(sprite.enabled);
			spriteDebugFrameRate.gameObject.SetActive(spriteDebugFrameRate.enabled);
			UnityEngine.Debug.Log("Cross hair is " + _crosshairMode);
		}
	}

	public void Awake()
	{
		Inst = this;
		radialClickAnim = new HagletResettable(ClickRadialBarRoutine(), "Click Radial Ticker");
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		crosshairParent = base.transform.GetChild(0);
		sprite = GetElement<UIImage>("Context");
		UIImage element = GetElement<UIImage>("RadialBar");
		spriteDebugFrameRate = GetElement<UIImage>("FrameDebugger");
		SpriteRenderer spriteRenderer = element.spriteRenderer;
		radialBarTrans = element.transform;
		radialBarMat = spriteRenderer.material;
		sprite.spriteRenderer.sharedMaterial = radialBarMat;
		sprite.spriteRenderer.color = new Color(0f, 0f, 1f, 1f);
		spriteRenderer.color = new Color(1f, 0f, 1f, 1f);
		radialCutoffID = Shader.PropertyToID("_Cutoff");
		LR.PrepareRadialMaterial(radialBarMat, spriteRenderer.sprite);
		spriteDebugFrameRate.gameObject.SetActive(value: false);
		CrosshairDisplayMode = CrosshairMode.Default;
		SetCrosshairDistance(2f);
		SetContext(UICrosshairContext.None);
	}

	private void Update()
	{
		if (LR.Inst.IsInitialised)
		{
			int layerMask = 1057;
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			if (Physics.Raycast(position, forward, out var hitInfo, float.PositiveInfinity, layerMask))
			{
				SetCrosshairDistance(hitInfo.distance * 0.99f);
			}
			else
			{
				SetCrosshairDistance(2f);
			}
		}
	}

	private IEnumerator<HagletYieldTerm> ClickRadialBarRoutine()
	{
		float reSizeTime = 0.05f;
		Vector3 originalSize = radialBarTrans.localScale;
		Vector3 animSize = originalSize * 1.5f;
		for (float t2 = 0f; t2 < reSizeTime; t2 += Time.deltaTime)
		{
			radialBarTrans.localScale = Vector3.Lerp(originalSize, animSize, t2 / reSizeTime);
			yield return null;
		}
		for (float t = 0f; t < reSizeTime; t += Time.deltaTime)
		{
			radialBarTrans.localScale = Vector3.Lerp(Vector3.zero, animSize, 1f - t / reSizeTime);
			yield return null;
		}
		radialBarTrans.localScale = originalSize;
	}

	public void SetActive(bool active)
	{
		if (crosshairParent.gameObject.activeInHierarchy != active)
		{
			crosshairParent.gameObject.SetActive(active);
		}
	}

	public void SetRadialBarFill(float value)
	{
		if (!radialClickAnim.running)
		{
			radialBarMat.SetFloat(radialCutoffID, value);
			if (value >= 1f)
			{
				Routine.Start(radialClickAnim, LR.Host);
			}
		}
	}

	public void SetContext(UICrosshairContext context)
	{
		sprite.SetImage(DEBUG_CrosshairSprites[(int)context]);
	}

	public void EnableRadialBar(bool enabled)
	{
		if (CrosshairDisplayMode == CrosshairMode.Default || CrosshairDisplayMode == CrosshairMode.Framerate || !enabled)
		{
			radialBarTrans.gameObject.SetActive(enabled);
		}
	}

	private void SetCrosshairDistance(float distance)
	{
		Vector3 localPosition = Vector3.forward * distance * 0.95f;
		Vector3 localScale = Vector3.one * distance;
		Transform transform = crosshairParent;
		transform.localPosition = localPosition;
		transform.localScale = localScale;
	}
}
public class CutsceneEvents
{
	private class StealthSpotted : HagletResettable
	{
		public StealthSpotted(CutsceneEvents ce)
			: base(ce.StealthSpottedRoutine(), "Cutscene Stealth Spotted")
		{
		}

		protected StealthSpotted(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private class StealthDistraction : HagletResettable
	{
		public v2i coord;

		public StealthDistraction(CutsceneEvents ce)
			: base(ce.StealthDistractionRoutine(), "Cutscene Stealth Distraction")
		{
		}

		protected StealthDistraction(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private class StealthUnitNotFound : HagletResettable
	{
		public Unit unit;

		public StealthUnitNotFound(CutsceneEvents ce)
			: base(ce.StealthUnitNotFoundRoutine(), "Cutscene Stealth Unit Not Found")
		{
		}

		protected StealthUnitNotFound(BinaryReader reader)
			: base(reader)
		{
		}
	}

	private StealthSpotted stealthSpotted;

	private StealthDistraction stealthDistraction;

	private StealthUnitNotFound stealthUnitNotFound;

	public void OnAwakeLR()
	{
		stealthSpotted = new StealthSpotted(this);
		stealthDistraction = new StealthDistraction(this);
		stealthUnitNotFound = new StealthUnitNotFound(this);
	}

	private IEnumerator<HagletYieldTerm> StealthSpottedRoutine()
	{
		Singleton<MC>.Inst.MapShake.ShakeOneShot(0.4f, 0.05f);
		ConstArray<Unit> enemyMembers = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers();
		for (int i = 0; i < enemyMembers.Length; i++)
		{
			enemyMembers[i].unitModel.Play(UnitModel.AnimID.DefaultAlert);
			enemyMembers[i].map.VFXTiles.UnitNoticedStealthShow(enemyMembers[i]);
		}
		yield return Wait.ForSeconds(1.75f);
		Singleton<MC>.Inst.GetActiveMap().VFXTiles.UnitNoticedStealthHide();
	}

	public HagletYieldTerm StealthBrokenCutscene()
	{
		return Routine.Start(stealthSpotted, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> StealthDistractionRoutine()
	{
		ConstArray<Unit> enemyMembers = GC.Inst.GetTeamOfType(UnitTeam.Type.Enemy).GetActiveMembers();
		for (int i = 0; i < enemyMembers.Length; i++)
		{
			enemyMembers[i].unitModel.Play(UnitModel.AnimID.DefaultAlert);
			enemyMembers[i].OnDistractionHeard(stealthDistraction.coord);
		}
		yield return Wait.ForSeconds(1.5f);
		Map[] maps = Singleton<MC>.Inst.GetAllMaps();
		for (int j = 0; j < maps.Length; j++)
		{
			maps[j].VFXTiles.UnitDistractedStealthHide();
		}
		stealthDistraction.coord = default(v2i);
	}

	public HagletYieldTerm StealthDistractionCutscene(v2i coord)
	{
		stealthDistraction.coord = coord;
		return Routine.Start(stealthDistraction, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> StealthUnitNotFoundRoutine()
	{
		stealthUnitNotFound.unit.OnDistractionUnitNotFound();
		yield return Wait.ForSeconds(1.5f);
		Map[] maps = Singleton<MC>.Inst.GetAllMaps();
		for (int i = 0; i < maps.Length; i++)
		{
			maps[i].VFXTiles.UnitDistractionUnitNotFoundHide();
		}
		stealthUnitNotFound.unit = null;
	}

	public HagletYieldTerm StealthUnitNotFoundCutscene(Unit unit)
	{
		stealthUnitNotFound.unit = unit;
		return Routine.Start(stealthUnitNotFound, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}
}
public class DebugChangeTintColor : MonoBehaviour
{
	public Color color;

	public MeshRenderer target;

	private void Start()
	{
		if ((bool)target)
		{
			target.material.SetColor("_ColorTint", color);
		}
	}
}
public class DebugEnableDisable : MonoBehaviour
{
	public void OnEnable()
	{
		UnityEngine.Debug.Log(base.gameObject.name + " was enabled!", base.gameObject);
	}

	public void OnDisable()
	{
		UnityEngine.Debug.Log(base.gameObject.name + " was disabled!", base.gameObject);
	}
}
public class DebugViewMesh : MonoBehaviour
{
	public enum Type
	{
		Normals
	}

	public Type type;

	private Mesh mesh;

	public void OnDrawGizmosSelected()
	{
		if (!mesh)
		{
			MeshFilter component = GetComponent<MeshFilter>();
			if ((bool)component)
			{
				mesh = component.sharedMesh;
			}
			return;
		}
		Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
		for (int i = 0; i < mesh.vertexCount; i++)
		{
			Vector3 start = localToWorldMatrix.MultiplyPoint3x4(mesh.vertices[i]);
			if (type == Type.Normals)
			{
				Vector3 vector = mesh.normals[i];
				UnityEngine.Debug.DrawRay(start, localToWorldMatrix * new Vector4(vector.x, vector.y, vector.z, 0f) * 0.1f, Color.green, 0f, depthTest: true);
			}
		}
	}
}
public class DebugViewXForm : MonoBehaviour
{
}
[ExecuteInEditMode]
public class EdgeSnap : MonoBehaviour
{
}
public class EnumFlagsFieldAttribute : PropertyAttribute
{
}
public class HartmanInteractionDialog : UIButton
{
	public enum InteractionType
	{
		TAP_COMPLETE,
		FOCUS_ENTER
	}

	public DialogData data;

	public InteractionType interactionType;

	public bool turnOffOnInteract = true;

	public HagletTrigger OnDialogComplete = new HagletTrigger();

	private void Awake()
	{
		if (!(data == null))
		{
			crosshairContext = UICrosshairContext.Inspect;
			base.OnTapUp -= HartmanInteractionDialog_OnTapUp;
			base.OnTapUp += HartmanInteractionDialog_OnTapUp;
			base.OnFocusEnter -= HartmanInteractionDialog_OnFocusEnter;
			base.OnFocusEnter += HartmanInteractionDialog_OnFocusEnter;
		}
	}

	private void HartmanInteractionDialog_OnFocusEnter()
	{
		if (interactionType == InteractionType.FOCUS_ENTER)
		{
			OnInteract();
		}
	}

	private bool HartmanInteractionDialog_OnTapUp()
	{
		if (interactionType != 0)
		{
			return false;
		}
		OnInteract();
		return true;
	}

	private void OnInteract()
	{
		Singleton<UIFlow>.Inst.DisplayDialog(data, OnDialogComplete);
		if (turnOffOnInteract)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class HartmanLookAtPoint : MonoBehaviour
{
	public Vector3 position => base.transform.position;

	public void OnDrawGizmos()
	{
		Gizmos.color = Color.cyan;
		Gizmos.DrawSphere(base.transform.position, 0.2f);
	}
}
public class HartmanMovementPoint : MonoBehaviour
{
	public Vector3 position => base.transform.position;

	public void OnDrawGizmos()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawSphere(base.transform.position, 0.2f);
	}
}
public class HartmanPotterPoint : MonoBehaviour
{
	public HartmanPotterPoint[] reachablePoints;

	[Range(0f, 360f)]
	public float LookAtAngle;

	public float waitTime = 1f;

	public Vector3 position => base.transform.position;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public Vector3 GetLookPoint()
	{
		Vector3 vector = base.transform.position;
		Vector3 vector2 = new Vector3(0f, 0f, 0.5f);
		vector2 = Quaternion.Euler(0f, LookAtAngle, 0f) * vector2;
		return vector + vector2;
	}
}
public class Hover : MonoBehaviour
{
	public float hoverAmount = 0.05f;

	public float hoverSpeed = 1f;

	private float startY;

	private void Awake()
	{
		startY = base.transform.localPosition.y;
	}

	private void Update()
	{
		float num = Mathf.Sin(Time.time * hoverSpeed * (float)Math.PI) * 0.5f + 1f;
		float y = num * 0.5f * hoverAmount + startY;
		base.transform.localPosition = new Vector3(base.transform.localPosition.x, y, base.transform.localPosition.z);
	}
}
public static class Layer
{
	public const int Default = 0;

	public const int UI = 5;

	public const int Pause = 9;

	public const int Unit = 10;

	public const int FogPrepass = 11;

	public const int StateRPG = 12;

	public const int StateCombat = 13;

	public const int StateStealth = 14;

	public const int Skybox = 16;

	public const int MaskDefault = 1;

	public const int MaskUI = 32;

	public const int MaskPause = 512;

	public const int MaskUnit = 1024;

	public const int MaskFogPrepass = 2048;

	public const int MaskStateRPG = 4096;

	public const int MaskStateCombat = 8192;

	public const int MaskStateStealth = 16384;

	public const int MaskSkybox = 65536;

	public const int MaskStateAll = 28672;

	public static int GetStateMask(GC.State availableIn)
	{
		int num = 0;
		num |= (((availableIn & GC.State.RPG) != 0) ? 4096 : 0);
		num |= (((availableIn & GC.State.Combat) != 0) ? 8192 : 0);
		return num | (((availableIn & GC.State.Stealth) != 0) ? 16384 : 0);
	}
}
public class LookAtPlayer : MonoBehaviour
{
	private void LateUpdate()
	{
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - Singleton<PC>.Inst.transform.position, Vector3.up);
	}
}
public class LookAtPlayerYRotation : MonoBehaviour
{
	private void LateUpdate()
	{
		base.transform.localRotation = Calculate(base.transform, Singleton<MC>.Inst.GetActiveMap(), Singleton<PC>.Inst.transform.position);
	}

	public static Quaternion Calculate(Transform transform, Map map, Vector3 worldPosTarget)
	{
		Vector3 vector = transform.position - worldPosTarget;
		map.transform.InverseTransformDirection(vector);
		vector.y = 0f;
		return Quaternion.LookRotation(vector, Vector3.up);
	}
}
[ExecuteInEditMode]
public class LookAtTargetInEditor : MonoBehaviour
{
	public Transform target;

	[Range(0.1f, 1f)]
	public float distance;

	[Range(0f, 90f)]
	public float angle;

	private void Update()
	{
		base.transform.position = target.position + Quaternion.Euler(angle, 0f, 0f) * (-Vector3.forward * distance);
		base.transform.LookAt(target);
	}
}
public class MapAnimFuncs : MonoBehaviour
{
	private Dictionary<string, Transform> childTransforms = new Dictionary<string, Transform>();

	private void Awake()
	{
		STUB_MapAnimChildTransform[] componentsInChildren = GetComponentsInChildren<STUB_MapAnimChildTransform>(includeInactive: true);
		STUB_MapAnimChildTransform[] array = componentsInChildren;
		foreach (STUB_MapAnimChildTransform sTUB_MapAnimChildTransform in array)
		{
			childTransforms.Add(sTUB_MapAnimChildTransform.name, sTUB_MapAnimChildTransform.transform);
		}
	}

	[AEAnimFunc]
	public void PlaySoundAt(string eventPath, FMODParam[] fmodParams)
	{
		FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot3D(eventPath, base.transform.position);
		if (eventInstance.isValid())
		{
			for (int i = 0; i < fmodParams.Length; i++)
			{
				eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
			}
		}
	}

	private static string PlaySoundAt_GetDisplayName(string eventPath, FMODParam[] fmodParams)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(eventPath))
		{
			return "PlaySoundAt";
		}
		return eventPath;
	}

	[AEAnimFunc]
	public void PlaySoundAtCoord(string eventPath, FMODParam[] fmodParams, v2i coord)
	{
		FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot3D(eventPath, Singleton<MC>.Inst.GetActiveMap().CoordToWorldPos(coord));
		if (eventInstance.isValid())
		{
			for (int i = 0; i < fmodParams.Length; i++)
			{
				eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
			}
		}
	}

	private static string PlaySoundAtCoord_GetDisplayName(string eventPath, FMODParam[] fmodParams, v2i coord)
	{
		if (GC.Inst == null || string.IsNullOrEmpty(eventPath))
		{
			return "PlaySoundAtCoord";
		}
		return eventPath;
	}

	[AEAnimFunc]
	public void SetParameterOnAmbTargetsWithEvents(string parameter, float value)
	{
		if (Singleton<MC>.Inst != null && (bool)Singleton<MC>.Inst.GetActiveMap())
		{
			Map activeMap = Singleton<MC>.Inst.GetActiveMap();
			SFXAmbTarget[] ambTargets = activeMap.ambTargets;
			foreach (SFXAmbTarget sFXAmbTarget in ambTargets)
			{
				sFXAmbTarget.SetParameter(parameter, value);
			}
		}
	}

	[AEAnimFunc]
	public void PlaySoundAtPosition(string eventPath, FMODParam[] fmodParams, Vector3 pos)
	{
		FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot3D(eventPath, pos);
		if (eventInstance.isValid())
		{
			for (int i = 0; i < fmodParams.Length; i++)
			{
				eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
			}
		}
	}

	[AEAnimFunc]
	public void PlaySoundAtChildTransform(string eventPath, FMODParam[] fmodParams, string childname)
	{
		Transform value = null;
		if (childTransforms.TryGetValue(childname, out value))
		{
			FMOD.Studio.EventInstance eventInstance = AC.Inst.PlayOneShot3D(eventPath, value);
			if (eventInstance.isValid())
			{
				for (int i = 0; i < fmodParams.Length; i++)
				{
					eventInstance.setParameterValue(fmodParams[i].name, fmodParams[i].value);
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning("Map Anim tried to play sound at child transform which does not exist: " + childname);
		}
	}
}
[Serializable]
public class MapBounds : ScriptableObject
{
	[SerializeField]
	public Bounds bounds;
}
public class ParticleBullet : ParticlePrefab
{
	public enum BulletType
	{
		None,
		Revolver,
		SciFi
	}

	public static readonly Dictionary<BulletType, float> _bulletSoundValue = new Dictionary<BulletType, float>
	{
		{
			BulletType.None,
			-1f
		},
		{
			BulletType.Revolver,
			0.15f
		},
		{
			BulletType.SciFi,
			0.25f
		}
	};

	private float speed = 4f;

	private float scaleTrailRenderer;

	private Vector3 targetWorldPos;

	private AnimVec3 animPosition = new AnimVec3();

	private AnimFloat animScaleIn = new AnimFloat(0f);

	private AnimFloat animScaleOut = new AnimFloat(0f);

	private Material material;

	private ParticleSystem bulletOrb;

	public bool didHit;

	private Transform xFormTrail;

	private Unit attacker;

	private Unit target;

	private void SetBulletOrb(bool visible)
	{
		bulletOrb.gameObject.SetActive(visible);
	}

	public HagletCondition AnimateFromAToB(Vector3 sourceWorldPos, Vector3 targetWorldPos)
	{
		if (MR.Inst != null && !MR.Inst.IsSkipping())
		{
			SetBulletOrb(visible: true);
		}
		base.transform.rotation = MathfX.LockedAxisBillboard(sourceWorldPos, -(targetWorldPos - sourceWorldPos).normalized, IC.Inst.transform.position);
		base.transform.position = sourceWorldPos;
		float num = Vector3.Distance(sourceWorldPos, targetWorldPos);
		float num2 = num / speed;
		animPosition.Value = sourceWorldPos;
		animPosition.AnimateTo(targetWorldPos, num2);
		animScaleIn.Value = 0f;
		animScaleIn.AnimateTo(1f, num2);
		xFormTrail.localScale = new Vector3(0f, 1f, 1f);
		scaleTrailRenderer = num * 12.5f;
		this.targetWorldPos = targetWorldPos;
		if (MR.Inst != null && MR.Inst.IsSkipping())
		{
			_Update(skip: true);
		}
		return animScaleIn.animating;
	}

	public HagletCondition AnimateToTarget(Unit attacker, Unit target, Combat.HitType hitType, bool reflected = false)
	{
		Vector3 vector = ((!reflected) ? attacker.unitModel.WeaponModelRanged.BarrelXForm.transform.position : (attacker._GetTransform().position + attacker._GetTransform().up * 0.08f));
		Transform transform = target._GetTransform();
		Vector3 vector2 = transform.position + transform.up * 0.08f;
		Vector3 normalized;
		if (hitType == Combat.HitType.Miss)
		{
			Vector3 pos = target.map.WorldPosToLocalPos(vector2);
			pos.x += UnityEngine.Random.Range(0.1f, 0.5f).RandomSign();
			pos.z += UnityEngine.Random.Range(0.1f, 0.5f).RandomSign();
			vector2 = target.map.LocalPosToWorldPos(pos);
			normalized = (vector2 - vector).normalized;
		}
		else
		{
			normalized = (vector2 - vector).normalized;
		}
		if (hitType == Combat.HitType.Miss || hitType == Combat.HitType.Dodged)
		{
			vector2 += normalized * 0.08f * 3f;
		}
		didHit = reflected || hitType.IsHit();
		this.attacker = attacker;
		this.target = target;
		return AnimateFromAToB(vector, vector2);
	}

	private void Awake()
	{
		MeshRenderer componentInChildren = GetComponentInChildren<MeshRenderer>();
		bulletOrb = GetComponentInChildren<ParticleSystem>();
		xFormTrail = componentInChildren.transform;
		material = componentInChildren.material;
		animPosition.OnComplete = OnImpact;
		animScaleOut.OnComplete = StopBullet;
		animScaleIn.Interpolate = AnimValue<float>.Linear;
		animScaleOut.Interpolate = AnimValue<float>.SmoothStep;
		animPosition.Interpolate = AnimValue<Vector3>.Linear;
	}

	private void Update()
	{
		if (!base.IsPaused)
		{
			_Update(skip: false);
		}
	}

	private void _Update(bool skip)
	{
		if (skip)
		{
			animPosition.Update(animPosition.Duration);
		}
		base.transform.position = animPosition.Update();
		int num = 1;
		float num2 = xFormTrail.localScale.x;
		if ((bool)animScaleIn.animating)
		{
			if (skip)
			{
				animScaleIn.Update(animScaleIn.Duration);
			}
			num2 = animScaleIn.Update();
		}
		else if ((bool)animScaleOut.animating)
		{
			if (skip)
			{
				animScaleOut.Update(animScaleOut.Duration);
			}
			num2 = animScaleOut.Update();
		}
		xFormTrail.localScale = new Vector3(num2 * scaleTrailRenderer, num, num);
		float newVal = 1f - Mathf.Pow(num2, 8f);
		material.color = material.color.RepA(newVal);
	}

	private void ScaleOut()
	{
		animScaleOut.Value = 1f;
		animScaleOut.AnimateTo(0f, animScaleIn.Duration * 0.75f);
	}

	private void StopBullet()
	{
		StopParticles();
		base.gameObject.SetActive(value: false);
	}

	private void OnImpact()
	{
		SetBulletOrb(visible: false);
		if (didHit)
		{
			ParticlePrefab particlePrefab = PSC.Inst.Play(ParticleTypes.BulletImpact, Vector3.zero, Quaternion.LookRotation(base.transform.forward, Vector3.up), Vector3.one, Singleton<MC>.Inst.GetActiveMap().transform);
			particlePrefab.transform.position = targetWorldPos;
		}
		ScaleOut();
	}
}
public class ParticleGrenade : ParticlePrefab
{
	public float arcHeightScale = 10f;

	public float animTime = 1f;

	private Vector3 localMapPosStart;

	private Vector3 localMapPosEnd;

	private HagletResettable animDriverRoutine;

	public AnimationCurve animArcCurve = new AnimationCurve();

	private Map map;

	private Rotation rotation;

	public HagletYieldTerm AnimateToTarget(Map map, Vector3 localMapPosStart, Vector3 localMapPosEnd)
	{
		this.map = map;
		base.transform.position = localMapPosStart;
		this.localMapPosStart = localMapPosStart;
		this.localMapPosEnd = localMapPosEnd;
		return Routine.Start(animDriverRoutine, MR.Inst.Host, MR.Inst.mainHagisSequence);
	}

	private IEnumerator<HagletYieldTerm> AnimDriverRoutine()
	{
		float t = 0f;
		rotation.enabled = true;
		int sfxKeyIndex = 1;
		while (t < animTime)
		{
			t = Mathf.Clamp01(t + Time.deltaTime);
			float x = Mathf.Lerp(0f, 1f, t / animTime);
			Vector3 p0 = localMapPosStart;
			Vector3 p1 = localMapPosEnd;
			Vector3 pBase = Vector3.Lerp(p0, p1, x);
			Vector3 pHeight = Vector3.up * animArcCurve.Evaluate(x) * arcHeightScale;
			Vector3 vector = map.LocalPosToWorldPos(pBase + pHeight);
			base.transform.position = vector;
			Vector3 pos = vector;
			if (sfxKeyIndex < animArcCurve.length)
			{
				Keyframe keyframe = animArcCurve[sfxKeyIndex];
				if (keyframe.time < t)
				{
					if (keyframe.value < 0.01f)
					{
						AC.Inst.PlayOneShot3D("event:/sfx/character v2/weapon/grenade bounce", pos);
					}
					sfxKeyIndex++;
				}
			}
			yield return null;
		}
		rotation.enabled = false;
		yield return Wait.ForSeconds(0.25f);
	}

	public override void OnAllocate()
	{
		base.OnAllocate();
		rotation = base.gameObject.GetComponentInChildren<Rotation>();
		animDriverRoutine = new HagletResettable(AnimDriverRoutine(), "Grenade Anim", HagletStepTime.Update, -1, 1);
	}
}
public class ParticlePrefab : MonoBehaviour, IPoolEvents
{
	[ReadOnly]
	public ParticleTypes particleType;

	[HideInInspector]
	public ParticleSystem[] ps;

	[HideInInspector]
	public HagletTrigger OnSpawned = new HagletTrigger();

	[HideInInspector]
	public HagletTrigger OnDespawned = new HagletTrigger();

	private HagletResettable fadeParticleOut;

	public bool IsFadingOut => (bool)fadeParticleOut.running || fadeParticleOut.markedToRunBy != null;

	public bool IsPaused { get; private set; }

	public float duration
	{
		get
		{
			float num = 0f;
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].main.duration > num)
				{
					num = ps[i].main.duration;
				}
			}
			return num;
		}
	}

	public bool isVisable
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].particleCount > 0)
				{
					return true;
				}
			}
			return false;
		}
	}

	public bool loop
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].main.loop)
				{
					return true;
				}
			}
			return false;
		}
	}

	public bool isPlaying
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].isPlaying)
				{
					return true;
				}
			}
			return false;
		}
	}

	public void CancelFadeOut()
	{
		if ((bool)fadeParticleOut.running)
		{
			fadeParticleOut.host.Pause(fadeParticleOut);
			fadeParticleOut.Reset();
		}
		PlayParticles();
	}

	private IEnumerator<HagletYieldTerm> FadeParticleOutRoutine()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Stop();
		}
		while (isVisable)
		{
			yield return null;
		}
		base.gameObject.SetActive(value: false);
	}

	public void PlayParticles()
	{
		if (!(MR.Inst != null) || !MR.Inst.IsSkipping())
		{
			for (int i = 0; i < ps.Length; i++)
			{
				ps[i].Play();
			}
			IsPaused = false;
		}
	}

	public void PauseParticles()
	{
		if (!(MR.Inst != null) || !MR.Inst.IsSkipping())
		{
			for (int i = 0; i < ps.Length; i++)
			{
				ps[i].Pause();
			}
			IsPaused = true;
		}
	}

	public void StopParticles()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Stop();
		}
		base.gameObject.SetActive(value: false);
	}

	public void StopParticlesFade()
	{
		if (base.gameObject.activeSelf && !IsFadingOut)
		{
			LR.Host.StartTopLevel(fadeParticleOut);
		}
	}

	public void ClearParticles()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Clear();
		}
	}

	public virtual void OnSpawn()
	{
		OnSpawned.Trigger();
	}

	public virtual void OnDespawn()
	{
		OnDespawned.Trigger();
	}

	public virtual void OnAllocate()
	{
		fadeParticleOut = new HagletResettable(FadeParticleOutRoutine());
	}

	public virtual void OnDeallocate()
	{
	}
}
public enum ParticleTypes
{
	Area_Shot = 1902356332,
	Area_Shot_Upgraded = -1008848549,
	Aura = 2052483,
	Auto_Revive = -529876507,
	Auto_Revive_Protection = 788783507,
	Backfist = -2108845077,
	BackStab = -2109401111,
	Backup = 1982161378,
	BarrelExplosion = -1147410961,
	Batter_Up = 1509959630,
	Berserk = 1446053114,
	Bleed = 64270106,
	Brawl_Regular = -1592273725,
	Brawl_Upgraded = -12871295,
	Break = 64448735,
	Bullet = 2000900386,
	Bullet_Time = 311333866,
	BulletImpact = 454859016,
	ChumleysExplosion = 1295467333,
	Cloak_and_Dagger = -1394728191,
	Combat_Medic = 1397567195,
	Conceal = -1679290257,
	CoordSelectTile = -1997111681,
	CoordSelectUnit = -1997077163,
	CoverFire = -311678355,
	Dance = 65798035,
	Danger_Zone = 1146568776,
	Dash = 2122674,
	Decoy = 65907020,
	Detect = 2043613891,
	Detect_Reveal = -668881687,
	Detect_Upgraded = -1156540444,
	Disable = -959006008,
	Disrupt = -958481163,
	Dodge = 66205623,
	Double_Hit = -1522445787,
	Endurance = 289247719,
	Far_Shot = 985216866,
	Focus = 68052152,
	Frenzy = 2112440468,
	Grab = 2227820,
	Graze = 69063265,
	Grenade = 1948624174,
	GrenadeRadiusLarge = -1858337861,
	GrenadeRadiusSmall = -1851531897,
	GrenadeSelectLarge = 1131015569,
	GrenadeSelectSmall = 1137821533,
	Ground_Pound = 312713684,
	Headshot = -1050206982,
	Hitback = -1703006502,
	HP_Restore = 993890871,
	Hunker_Down = 1294046762,
	ImpactBlade = -242325934,
	ImpactBlunt = -242306389,
	Incorporeal = 567650686,
	Inspire = -672855366,
	Leap_Source = 1790293202,
	Leap_Target = 1805893192,
	LevelUp = 1734438175,
	Limb_Shot = -766473401,
	Lookout_Regular = -760952980,
	Lookout_Upgraded = -11731976,
	Martial_Arts = 386556561,
	Metabolism = -1008375607,
	MuzzleFlash = -1714539025,
	Overview = 594760089,
	Overwatch = 1258392667,
	PenthouseExplosion = 1692093232,
	Pick_Off = -674475951,
	Plant = 77195851,
	Point_Blank = -2073651803,
	Reflex = -1850955572,
	Restore = -1532794258,
	Return_Fire = 180243429,
	Sap = 82882,
	Second_Shot = 1932334053,
	Second_Wind = 1932454131,
	Secondary_Attack = -1748312141,
	Selection = 288002412,
	Shock = 79860354,
	ShockImplodeLarge = 860967341,
	Shockwave = -460778373,
	ShockwaveLarge = -2143007872,
	Shove = 79860937,
	Spot = 2583842,
	SpottedExclamation = -1758508548,
	Spray_and_Pray = -1352719692,
	Static_Skin = -1742487378,
	Taunt_Source = -1822946740,
	Taunt_Target = -1807346750,
	TileEnterFocus = 844619342,
	TK = 2679,
	Trap = 2615117,
	Trap_Set_Regular = -679019891,
	Trap_Set_Upgraded = -1766773513,
	Upgrade = 1433481724,
	Vault = 82428434,
	Vault_Kick = -722132877
}
public class PropXForm : MonoBehaviour
{
}
public class Rotation : MonoBehaviour
{
	public Vector3 rotation;

	private void Update()
	{
		if (!LR.Inst.IsPaused())
		{
			base.transform.Rotate(rotation * Time.deltaTime, Space.Self);
		}
	}
}
public class SFXAmbTarget : TileObjectBase
{
	public string eventName;

	protected FMOD.Studio.EventInstance handle;

	[Range(0f, 1f)]
	public float volume = 1f;

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		handle = AC.Inst.GetHandle(eventName);
		if (base.isActiveAndEnabled && handle.isValid())
		{
			handle.setVolume(volume);
			handle.set3DAttributes(base.transform.position.to3DAttributes());
			handle.start();
		}
	}

	private void OnDisable()
	{
		AC.Stop(handle);
	}

	private void OnEnable()
	{
		if (handle.isValid())
		{
			handle.setVolume(volume);
			handle.set3DAttributes(base.transform.position.to3DAttributes());
			handle.start();
		}
	}

	protected virtual void OnDestroy()
	{
		if (handle.isValid())
		{
			handle.release();
		}
	}

	public virtual void Update()
	{
		if (handle.isValid())
		{
			handle.setVolume(volume);
			if (base.transform.hasChanged)
			{
				handle.set3DAttributes(base.transform.position.to3DAttributes());
				base.transform.hasChanged = false;
			}
			handle.getPlaybackState(out var state);
			if (!base.isActiveAndEnabled && (state == PLAYBACK_STATE.PLAYING || state == PLAYBACK_STATE.STARTING))
			{
				AC.Stop(handle);
			}
		}
	}

	public void SetParameter(string param, float value)
	{
		if (handle.isValid())
		{
			handle.setParameterValue(param, value);
		}
	}
}
public class SFXAmbTarget_Positional : SFXAmbTarget
{
	public enum Shape
	{
		RADIAL,
		LINEAR
	}

	public Shape shape;

	public Vector2 threshold = new Vector2(1f, 3f);

	public float width = 1f;

	private ParameterInstance distanceParameter;

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		if (handle.isValid())
		{
			handle.getParameter("distance", out distanceParameter);
		}
	}

	public override void Update()
	{
		base.Update();
		if (!handle.isValid())
		{
			return;
		}
		Unit leader = Singleton<PC>.Inst.GetLeader();
		if (leader == null)
		{
			return;
		}
		float num = 0f;
		float a = 0f;
		switch (shape)
		{
		case Shape.RADIAL:
			num = Vector3.Distance(base.transform.localPosition.RepY(0f), leader.GetPositionLS().RepY(0f));
			a = 1f - (num - threshold.x) / (threshold.y - threshold.x);
			break;
		case Shape.LINEAR:
		{
			float num2 = Mathf.Abs(base.transform.InverseTransformPoint(leader.GetPositionWS()).z);
			if (num2 < width || num2.CloseTo(width, 0.1f))
			{
				num = Mathf.Abs(base.transform.InverseTransformPoint(leader.GetPositionWS()).x);
				a = 1f - (num - threshold.x) / (threshold.y - threshold.x);
			}
			else
			{
				a = -1f;
			}
			break;
		}
		}
		handle.getPlaybackState(out var state);
		a = Mathf.Min(a, 1f);
		if (a <= 0f && (state == PLAYBACK_STATE.PLAYING || state == PLAYBACK_STATE.STARTING))
		{
			AC.Stop(handle);
		}
		else if (a > 0f && state != 0 && state != PLAYBACK_STATE.STARTING)
		{
			handle.start();
		}
		if (handle.isValid() && state != PLAYBACK_STATE.STOPPED)
		{
			distanceParameter.setValue(a);
		}
	}
}
public class SFXParticle : MonoBehaviour, IPoolEvents
{
	public string eventPath;

	public void OnSpawn()
	{
		AC.Inst.PlayOneShot3D(eventPath, base.transform.position);
	}

	public void OnDespawn()
	{
	}

	public void OnAllocate()
	{
	}

	public void OnDeallocate()
	{
	}
}
public class STUB_RoomAudioSource : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class STUB_RoomCutout : MonoBehaviour
{
}
public class STUB_RoomWireframe : MonoBehaviour
{
}
public class STUB_StreamingAssetLoader : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class EnableIfMissionComplete : MonoBehaviour
{
	[NonSceneAsset]
	public MissionSceneMeta mission;

	private Renderer render;

	public bool activeIfMissionComplete;

	public void Awake()
	{
		render = GetComponentInChildren<Renderer>();
	}

	public void OnEnable()
	{
		if (SaveData.initialised)
		{
			if (render != null)
			{
				render.enabled = SaveData.data.IsMissionComplete(mission.name);
			}
			if (activeIfMissionComplete)
			{
				base.gameObject.SetActive(SaveData.data.IsMissionComplete(mission.name));
			}
		}
	}
}
[Serializable]
public class SaveData : Serializer.ISelfConstructor
{
	public class Mission : Serializer.ISelfConstructor
	{
		public SaveData progress;

		public int checkPointCount;

		public readonly Dictionary<int, int> splitPoints;

		public readonly Dictionary<string, StoreInstance> storeStocks;

		public readonly Dictionary<string, bool> tileObjectActives;

		public readonly Dictionary<int, Dictionary<string, int>> combatResults;

		public Mission(SaveData globalProgress)
		{
			progress = new SaveData(globalProgress);
			splitPoints = new Dictionary<int, int>(100);
			storeStocks = new Dictionary<string, StoreInstance>(10);
			tileObjectActives = new Dictionary<string, bool>(30);
			combatResults = new Dictionary<int, Dictionary<string, int>>(40);
		}

		private Mission(BinaryReader reader)
		{
		}

		void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
		{
		}
	}

	public struct InterplayPair
	{
		public PartyMemberID a;

		public PartyMemberID b;
	}

	public class Interplay : Serializer.ISelfConstructor
	{
		public string dialogsPath;

		[Serializer.Exclude]
		public DialogData[] dialogs;

		public int index;

		public Interplay(string dialogsPath)
		{
			this.dialogsPath = dialogsPath;
		}

		public Interplay(Interplay other)
		{
			dialogsPath = other.dialogsPath;
			dialogs = other.dialogs;
			index = other.index;
		}

		public Interplay(BinaryReader reader)
		{
		}

		void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
		{
		}
	}

	public struct MissionGroup
	{
		public string groupID;

		public string[] missionNames;

		public int size => missionNames.Length;

		public MissionGroup(string groupID, params string[] missionNames)
		{
			this.groupID = groupID;
			this.missionNames = missionNames;
		}
	}

	public struct Tutorials
	{
		public bool visitedShop;

		public bool appliedAugment;

		public bool viewedRejectionShotTutorial;

		public bool viewedOverloadingTutorial;

		public bool pickedUpScrap;

		public bool pickedUpCircuitry;

		public bool pickedUpJewellery;

		public bool pickedUpAtlatium;

		public bool pickedUpRejectionShot;

		public bool acquiredAugment;

		public bool acquiredMedkit;

		public bool boughtRejectionShot;

		public bool boughtAtlatium;
	}

	private static int retentions = 0;

	private bool _enableMidMissionSaving = true;

	public bool enableSerializerLogging;

	public static StringBuilder detailsBuilder;

	private static int resumeProgress;

	private static readonly MissionGroup[] missionGroups = new MissionGroup[23]
	{
		new MissionGroup("MissionGroup 1", "MISSION_A1S1_Inversion"),
		new MissionGroup("MissionGroup 2", "MISSION_A1O1_Cambridge"),
		new MissionGroup("MissionGroup 3", "MISSION_A1O2_RecruitMargot", "MISSION_A1O3_RecruitAmbrosiaAtt1", "MISSION_A1O4_RecruitChris"),
		new MissionGroup("MissionGroup 4", "MISSION_A1O5_RecrootNoot", "MISSION_A1O6_RecruitAmbrosiaAtt2"),
		new MissionGroup("MissionGroup 5", "MISSION_A1O8_HeistSetup2"),
		new MissionGroup("MissionGroup 6", "MISSION_A1S2_AlphaWaves"),
		new MissionGroup("MissionGroup 7", "MISSION_A2S1_BlownGasket"),
		new MissionGroup("MissionGroup 8", "MISSION_A2O2_Flotsam"),
		new MissionGroup("MissionGroup 9", "MISSION_A2O3_QualityAssurance"),
		new MissionGroup("MissionGroup 9a", "MISSION_A2O4_Hard-Coded"),
		new MissionGroup("MissionGroup 10", "MISSION_A2O5_FeedingTime"),
		new MissionGroup("MissionGroup 11", "MISSION_A2O6_FalseImpressionism"),
		new MissionGroup("MissionGroup 12", "MISSION_A2O7_KeysToTheKingdom"),
		new MissionGroup("MissionGroup 13", "MISSION_A2S2_TheCeilingOfTheWorld"),
		new MissionGroup("MissionGroup 14", "MISSION_A3S1_Rotgut"),
		new MissionGroup("MissionGroup 15", "MISSION_A3O1_TheWarForPeace"),
		new MissionGroup("MissionGroup 16", "MISSION_A3O2_Hornpipe"),
		new MissionGroup("MissionGroup 17", "MISSION_A3O3_Degenerate"),
		new MissionGroup("MissionGroup 18", "MISSION_A3O4_Hacktivism"),
		new MissionGroup("MissionGroup 19", "MISSION_A3O5_AnotherLife"),
		new MissionGroup("MissionGroup 20", "MISSION_A3O8_ProdigalChild"),
		new MissionGroup("MissionGroup 21", "MISSION_A3S2_WelcomeHome"),
		new MissionGroup("MissionGroup 22", "MISSION_A3S3_AugmentedEmpire")
	};

	private static readonly int[] partyMemberOrder = new int[8] { -1, 0, 1, 2, 4, 5, 3, -1 };

	private static SaveData globalProgress;

	private static Dictionary<string, MissionSceneMeta> missionsByName;

	public MissionSceneMeta chosenMission;

	public Party party;

	private bool[][] missionsCompleted;

	public bool HACK_hasStaticSkin;

	public Tutorials tutorials;

	public RoomSceneMeta roomSceneMeta;

	private Dictionary<InterplayPair, Interplay> interplays;

	private Dictionary<string, string> characterVariations;

	public Dictionary<DC.GameSection, int> honestyTrackDict = new Dictionary<DC.GameSection, int>();

	public static SaveData data => midMissionProgress ?? globalProgress ?? (globalProgress = new SaveData());

	public static SaveLoad.Result lastResult { get; private set; }

	public static bool initialised => retentions > 0;

	public bool enableMidMissionSaving
	{
		get
		{
			return LR.DEBUG_autoTestSaveLoad || _enableMidMissionSaving;
		}
		set
		{
			_enableMidMissionSaving = value;
		}
	}

	public static string loadedMission { get; private set; }

	public static bool gotSavedMission => LR.CanSaveLoad && SaveLoad.DataSavedInSlot(1);

	public static string savedMission
	{
		get
		{
			if (!gotSavedMission)
			{
				return null;
			}
			SaveLoad.Metadata metadataOut = default(SaveLoad.Metadata);
			SaveLoad.GetMetadata(ref metadataOut, 1);
			return metadataOut.header.title;
		}
	}

	public static Mission mission { get; private set; }

	private static SaveData midMissionProgress => (mission == null) ? null : mission.progress;

	public static bool resumingMission { get; private set; }

	public static bool gotSavedProgress => LR.CanSaveLoad && initialised && SaveLoad.DataSavedInSlot();

	public SaveData()
	{
		SetupMissionsAndInterplays();
		SetupInterplayDialogs();
		party = new Party();
		roomSceneMeta = AEResources.LoadFirstResource<RoomSceneMeta>("SceneMetas/ROOM_Penthouse_01");
		characterVariations = new Dictionary<string, string>(10);
	}

	public SaveData(BinaryReader reader)
	{
		SetupMissionsAndInterplays();
	}

	public SaveData(SaveData other)
	{
		party = new Party(other.party);
		missionsCompleted = new bool[other.missionsCompleted.Length][];
		int i = 0;
		for (int num = other.missionsCompleted.Length; i < num; i++)
		{
			if (other.missionsCompleted[i] != null)
			{
				int num2 = other.missionsCompleted[i].Length;
				missionsCompleted[i] = new bool[num2];
				for (int j = 0; j < num2; j++)
				{
					missionsCompleted[i][j] = other.missionsCompleted[i][j];
				}
			}
		}
		roomSceneMeta = other.roomSceneMeta;
		interplays = new Dictionary<InterplayPair, Interplay>(other.interplays.Count);
		foreach (InterplayPair key in other.interplays.Keys)
		{
			interplays[key] = ((other.interplays[key] == null) ? null : new Interplay(other.interplays[key]));
		}
		honestyTrackDict = new Dictionary<DC.GameSection, int>(other.honestyTrackDict);
		tutorials = other.tutorials;
		characterVariations = new Dictionary<string, string>(other.characterVariations);
		_enableMidMissionSaving = other._enableMidMissionSaving;
		enableSerializerLogging = other.enableSerializerLogging;
		chosenMission = other.chosenMission;
	}

	[Conditional("AE_DEBUG")]
	public static void ValidateUsage()
	{
		if (!initialised)
		{
			throw new InvalidOperationException("SaveData was used without having been initialized!");
		}
	}

	public static HagletYieldTerm Retain(bool unthreaded = false, bool silent = false)
	{
		if (retentions++ > 0)
		{
			lastResult = SaveLoad.Result.Success;
			return Wait.PreMet;
		}
		try
		{
			if (LR.DEBUG_autoTestFilters != null)
			{
				unthreaded = true;
			}
			GameObject gameObject = new GameObject("__SaveLoad");
			string basePath = UnityEngine.Application.persistentDataPath;
			HagletEvent hagletEvent = Initialize_Progression(unthreaded);
			gameObject.AddComponent<SaveLoad.DispatchRunner>();
			UnityEngine.Object.DontDestroyOnLoad(gameObject);
			Initialize_Mission();
			ThreadStart threadStart = delegate
			{
				Serializer.Retain(silent, basePath);
				Serializer.AddExclude<JK3D>();
				Serializer.AddExcludeAssignablesTo<HagletEvent>();
				Serializer.AddExcludeAssignablesTo<FMOD.Studio.EventInstance>();
				Serializer.AddExcludeAssignablesTo<ParameterInstance>();
				Serializer.PrecacheTypes(new Type[3]
				{
					typeof(SaveData),
					typeof(Mission),
					typeof(SaveLoad.Metadata[])
				}, new Type[1] { typeof(AbilityImplBase) }, new Assembly[3]
				{
					typeof(GameObject).Assembly,
					typeof(SaveData).Assembly,
					typeof(object).Assembly
				});
				int slotQty = 2;
				SaveLoad.ResultHandler handleResultIn = delegate(SaveLoad.Result res)
				{
					lastResult = res;
				};
				bool unthreaded2 = unthreaded;
				bool silent2 = silent;
				string basePath2 = basePath;
				lastResult = SaveLoad.Retain(slotQty, handleResultIn, unthreaded2, silent2, log: false, basePath2);
				if (!silent)
				{
					UnityEngine.Debug.Log("SaveData initialised.");
				}
			};
			if (unthreaded)
			{
				threadStart();
				return Wait.While(() => lastResult.IsPending());
			}
			Thread thread = new Thread(threadStart);
			thread.Name = "SaveData Init Thread";
			thread.Start();
			return Wait.While(() => thread.IsAlive || lastResult.IsPending()) & hagletEvent;
		}
		catch (Exception exception)
		{
			Release(silent);
			UnityEngine.Debug.LogException(exception);
			return Wait.None;
		}
	}

	public static void Release(bool silent = false)
	{
		if (retentions == 0)
		{
			UnityEngine.Debug.LogError("SaveData over-released!");
		}
		else if (--retentions <= 0)
		{
			lastResult = SaveLoad.Result.Pending;
			Cleanup_Mission();
			Cleanup_Progression();
			SaveLoad.Release(silent);
			Serializer.Release(silent);
			globalProgress = null;
			if (!silent)
			{
				UnityEngine.Debug.Log("SaveData cleaned up.");
			}
		}
	}

	void Serializer.ISelfConstructor.Deconstruct(BinaryWriter writer)
	{
	}

	public static void BackupFiles()
	{
		Retain(unthreaded: true);
		try
		{
			SaveLoad.BackupFiles();
		}
		finally
		{
			Release();
		}
	}

	private static void Initialize_Mission()
	{
		detailsBuilder = new StringBuilder(5120);
	}

	private static void Cleanup_Mission()
	{
		detailsBuilder = null;
	}

	public static void OnMissionSceneLoaded()
	{
	}

	public static void OnMissionStart()
	{
		data.chosenMission = LR.Inst.missionMetaLoaded;
		if (!data.chosenMission.devOnly && LR.DEBUG_autoTestFilters == null && string.IsNullOrEmpty(MR.Inst.DEBUG_startingCutscene))
		{
			SaveProgress();
		}
		mission = new Mission(globalProgress);
	}

	public static void OnMissionSceneUnload()
	{
		mission = null;
	}

	public static bool SaveMission(bool unthreaded)
	{
		if (!data.enableMidMissionSaving || SaveLoad.busy)
		{
			lastResult = SaveLoad.Result.Save | SaveLoad.Result.Success;
			return false;
		}
		try
		{
			loadedMission = LR.Inst.missionMetaLoaded.resourcePath;
			string details = null;
			SaveLoad.DataHeader header = new SaveLoad.DataHeader(loadedMission, null, details);
			detailsBuilder.Length = 0;
			SaveLoad.Result result = SaveLoad.Save(header, mission, delegate(SaveLoad.Result res)
			{
				lastResult = res;
			}, 1, unthreaded, silent: true);
			return (!unthreaded) ? result.IsPending() : result.IsSuccess();
		}
		catch (Exception)
		{
			lastResult = SaveLoad.Result.Save | SaveLoad.Result.Failure | SaveLoad.Result.Subsystem;
			return false;
		}
	}

	public static HagletYieldTerm LoadMission(bool unthreaded)
	{
		return Routine.Start(new Haglet(LoadMissionRoutine(unthreaded), "Load Progress Save Data", HagletStepTime.Update, 1), LR.Host);
	}

	public static IEnumerator<HagletYieldTerm> LoadMissionRoutine(bool unthreaded)
	{
		SaveLoad.Metadata meta = default(SaveLoad.Metadata);
		if (!SaveLoad.GetMetadata(ref meta, 1))
		{
			lastResult = SaveLoad.Result.Load | SaveLoad.Result.Failure | SaveLoad.Result.MissingData;
			yield break;
		}
		SaveLoad.ResultHandler storeResult = delegate(SaveLoad.Result res)
		{
			lastResult = res;
		};
		try
		{
			SaveLoad.ResultHandler handleResult = storeResult;
			int slot = 1;
			lastResult = SaveLoad.Load(handleResult, slot, null, unthreaded, silent: true);
		}
		catch (Exception)
		{
			lastResult = SaveLoad.Result.Load | SaveLoad.Result.Failure | SaveLoad.Result.Subsystem;
			yield break;
		}
		yield return Wait.While(() => lastResult.IsPending());
		if (!lastResult.Is(SaveLoad.Result.MissingData) && !lastResult.IsFailure())
		{
			mission = SaveLoad.GetAndClearLastLoadedObject<Mission>();
			loadedMission = meta.header.title;
		}
	}

	public static void BeginMissionResumeSkip()
	{
		resumeProgress = 0;
		if (!StopResumingIfComplete())
		{
			resumingMission = true;
			MR.Inst.Skip();
		}
	}

	public static void OnCheckpoint(bool save = true)
	{
		if (resumingMission)
		{
			ApplyCombatResultsIfPresent();
			resumeProgress++;
			StopResumingIfComplete();
			return;
		}
		mission.checkPointCount++;
		if (save)
		{
			SaveMissionIfAllowed();
		}
	}

	public static void OnCombatBegin()
	{
		if (resumingMission)
		{
			resumeProgress++;
			StopResumingIfComplete();
		}
		else
		{
			mission.checkPointCount++;
			SaveMissionIfAllowed();
		}
	}

	public static void OnCombatWon()
	{
		if (resumingMission)
		{
			if (ApplyCombatResultsIfPresent())
			{
				resumeProgress++;
				StopResumingIfComplete();
			}
			return;
		}
		if (mission.checkPointCount == GC.Inst.combatCheckPointIndex + 1)
		{
			RecordCombatResultsAtIndex(mission.checkPointCount);
			mission.checkPointCount++;
		}
		else
		{
			RecordCombatResultsAtIndex(mission.checkPointCount - 1);
		}
		SaveMissionIfAllowed();
	}

	public static void OnCombatCancelled()
	{
		if (!resumingMission)
		{
			RecordCombatResultsAtIndex(mission.checkPointCount);
			mission.checkPointCount++;
			SaveMissionIfAllowed();
		}
	}

	public static void OnEndTurnMode()
	{
		if (resumingMission && ApplyCombatResultsIfPresent())
		{
			resumeProgress++;
			StopResumingIfComplete();
		}
	}

	public static void OnMissionComplete()
	{
		if (!data.chosenMission.devOnly)
		{
			data.SetMissionComplete(data.chosenMission.sceneName);
			data.roomSceneMeta = data.chosenMission.postMissionRoom;
			if (data == midMissionProgress)
			{
				globalProgress = data;
			}
			ClearMission();
		}
	}

	public static int SplitPoint(int value, bool save = true)
	{
		if (resumingMission)
		{
			value = mission.splitPoints[resumeProgress];
		}
		else
		{
			mission.splitPoints[mission.checkPointCount] = value;
		}
		OnCheckpoint(save);
		return value;
	}

	public static int SplitPoint(int value, int skipOverride, bool save = true)
	{
		if (!resumingMission)
		{
			value = value.SkipOverride(skipOverride);
		}
		return SplitPoint(value, save);
	}

	public static bool SplitPoint(bool value)
	{
		return SplitPoint(value ? 1 : 0) == 1;
	}

	public static bool SplitPoint(bool value, bool skipOverride)
	{
		return SplitPoint(value ? 1 : 0, skipOverride ? 1 : 0) == 1;
	}

	public static bool SplitPoint(bool value, bool skipOverride, bool save)
	{
		return SplitPoint(value ? 1 : 0, skipOverride ? 1 : 0, save) == 1;
	}

	public static uint SplitPoint(uint value)
	{
		return (uint)SplitPoint((int)value);
	}

	public static uint SplitPoint(uint value, uint skipOverride)
	{
		return (uint)SplitPoint((int)value, (int)skipOverride);
	}

	public static uint SplitPoint(uint value, uint skipOverride, bool save)
	{
		return (uint)SplitPoint((int)value, (int)skipOverride, save);
	}

	private static void RecordCombatResultsAtIndex(int index)
	{
		Dictionary<string, int> dictionary = new Dictionary<string, int>(20);
		mission.combatResults[index] = dictionary;
		Dictionary<string, int> results = dictionary;
		RecordCombatResultsForTeam(UnitTeam.Type.Player, results);
		RecordCombatResultsForTeam(UnitTeam.Type.Enemy, results);
	}

	private static void RecordCombatResultsForTeam(UnitTeam.Type type, Dictionary<string, int> results)
	{
		ConstArray<Unit> membersInWorld = GC.Inst.GetTeamOfType(type).GetMembersInWorld();
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		int i = 0;
		for (int sLength = membersInWorld.sLength; i < sLength; i++)
		{
			Unit unit = membersInWorld[i];
			if (unit.map == activeMap && (unit.gameObject.activeInHierarchy || unit.HP == 0) && !unit.HACK_isDecoyUnit)
			{
				if (unit.abilities.Exists<Ability_Break_Proxy>())
				{
					results[unit.generatedID] = 0;
				}
				else
				{
					results[unit.generatedID] = unit.HP;
				}
			}
		}
	}

	private static bool ApplyCombatResultsIfPresent()
	{
		Dictionary<string, int> value = null;
		if (mission.combatResults.TryGetValue(resumeProgress, out value))
		{
			ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
			uint num = 0u;
			for (uint length = unitsAllInWorld.Length; num < length; num++)
			{
				Unit unit = unitsAllInWorld[num];
				if (value.TryGetValue(unit.generatedID, out var value2))
				{
					if (value2 > 0)
					{
						unit.HP = value2;
					}
					else
					{
						unit.HPDecrement(unit.HP);
					}
				}
			}
			return true;
		}
		return false;
	}

	private static bool StopResumingIfComplete()
	{
		if (resumeProgress == mission.checkPointCount)
		{
			if (!LR.DEBUG_autoTestSaveLoad)
			{
				MR.Inst.Host.StopSkip(MR.Inst.mainHagisSequence);
				RC.Inst.RoomHide();
			}
			resumingMission = false;
			return true;
		}
		return false;
	}

	public static void SaveMissionIfAllowed()
	{
		if (data.chosenMission.devOnly || !string.IsNullOrEmpty(MR.Inst.DEBUG_startingCutscene) || SaveLoad.busy || (MR.Inst.IsSkipping() && !LR.DEBUG_autoTestSaveLoad) || (GC.Inst.IsInTurnMode() && !GC.Inst.flagEndTurnMode.set))
		{
			return;
		}
		if (LR.DEBUG_autoReload || LR.DEBUG_autoTestSaveLoad)
		{
			if (mission.checkPointCount > LR.DEBUG_autoTestStartingCheckpoint)
			{
				SaveMission(unthreaded: true);
				MR.Inst.Host.StopSkip(MR.Inst.mainHagisSequence);
				Singleton<UIFlow>.Inst.RestartCheckpoint();
			}
		}
		else
		{
			SaveMission(unthreaded: false);
		}
	}

	public static void ClearMission()
	{
		loadedMission = null;
		mission = null;
		if (UnityEngine.Application.isPlaying)
		{
			Retain(unthreaded: true);
			if (lastResult.IsFailure())
			{
				return;
			}
		}
		else
		{
			SaveLoad.Result result = SaveLoad.Retain(2, null, unthreaded: true, silent: false, log: false, UnityEngine.Application.persistentDataPath);
			if (result.IsFailure())
			{
				return;
			}
		}
		SaveLoad.Result result2 = SaveLoad.Delete(null, 1, unthreaded: true, silent: false, UnityEngine.Application.isPlaying && data.enableSerializerLogging);
		if (!result2.IsFailure())
		{
			if (UnityEngine.Application.isPlaying)
			{
				Release();
			}
			else
			{
				SaveLoad.Release();
			}
		}
	}

	[Conditional("AE_DEBUG")]
	private static void Log(string message, params object[] args)
	{
		if (LR.DEBUG_autoTestFilters != null)
		{
			UnityEngine.Debug.logger.filterLogType = LogType.Log;
		}
		UnityEngine.Debug.LogFormat(message, args);
		if (LR.DEBUG_autoTestFilters != null)
		{
			UnityEngine.Debug.logger.filterLogType = LogType.Error;
		}
	}

	[Conditional("AE_DEBUG")]
	private static void LogError(string message, params object[] args)
	{
		if (LR.DEBUG_autoTestFilters != null)
		{
			UnityEngine.Debug.logger.filterLogType = LogType.Log;
		}
		UnityEngine.Debug.LogFormat(message, args);
		if (LR.DEBUG_autoTestFilters != null)
		{
			UnityEngine.Debug.logger.filterLogType = LogType.Error;
		}
	}

	private static HagletEvent Initialize_Progression(bool unthreaded)
	{
		if (!unthreaded)
		{
			Haglet haglet = new Haglet(InitializeProgressionRoutine());
			LR.Host.StartTopLevel(haglet);
			return haglet.completed;
		}
		MissionSceneMeta[] array = AEResources.LoadAllResources<MissionSceneMeta>("SceneMetas", throwOnError: false, silent: false, "mission");
		missionsByName = new Dictionary<string, MissionSceneMeta>(array.Length);
		MissionSceneMeta[] array2 = array;
		foreach (MissionSceneMeta missionSceneMeta in array2)
		{
			missionsByName.Add(missionSceneMeta.sceneName, missionSceneMeta);
		}
		return null;
	}

	private static IEnumerator<HagletYieldTerm> InitializeProgressionRoutine()
	{
		yield return null;
		AEResources.BundleMapper[] missionAssMaps = AEResources.GetAssetMappings("SceneMetas", "mission");
		missionsByName = new Dictionary<string, MissionSceneMeta>(missionAssMaps.Length);
		AEResources.BundleMapper[] array = missionAssMaps;
		for (int i = 0; i < array.Length; i++)
		{
			AEResources.BundleMapper assMap = array[i];
			AssetBundleRequest assRequest = assMap.bundle.LoadAssetAsync(assMap.assetBundlePath);
			yield return Wait.Until(() => assRequest.isDone);
			MissionSceneMeta msm = assRequest.asset as MissionSceneMeta;
			if (msm != null)
			{
				missionsByName.Add(msm.sceneName, msm);
			}
		}
	}

	private static void Cleanup_Progression()
	{
		missionsByName = null;
	}

	private void SetupMissionsAndInterplays()
	{
		int num = Enum.GetNames(typeof(DC.GameSection)).Length;
		for (int i = 0; i < num; i++)
		{
			honestyTrackDict.Add((DC.GameSection)i, 0);
		}
		missionsCompleted = new bool[missionGroups.Length][];
		for (int j = 0; j < missionsCompleted.Length; j++)
		{
			missionsCompleted[j] = new bool[missionGroups[j].size];
		}
		interplays = new Dictionary<InterplayPair, Interplay>();
		SetupInterplay(PartyMemberID.Willa, PartyMemberID.Archi);
		SetupInterplay(PartyMemberID.Willa, PartyMemberID.Margot);
		SetupInterplay(PartyMemberID.Willa, PartyMemberID.Ambrosia);
		SetupInterplay(PartyMemberID.Willa, PartyMemberID.Noot);
		SetupInterplay(PartyMemberID.Willa, PartyMemberID.Chris);
		SetupInterplay(PartyMemberID.Archi, PartyMemberID.Margot);
		SetupInterplay(PartyMemberID.Archi, PartyMemberID.Ambrosia);
		SetupInterplay(PartyMemberID.Archi, PartyMemberID.Noot);
		SetupInterplay(PartyMemberID.Archi, PartyMemberID.Chris);
		SetupInterplay(PartyMemberID.Margot, PartyMemberID.Ambrosia);
		SetupInterplay(PartyMemberID.Margot, PartyMemberID.Noot);
		SetupInterplay(PartyMemberID.Margot, PartyMemberID.Chris);
		SetupInterplay(PartyMemberID.Ambrosia, PartyMemberID.Noot);
		SetupInterplay(PartyMemberID.Ambrosia, PartyMemberID.Chris);
		SetupInterplay(PartyMemberID.Noot, PartyMemberID.Chris);
	}

	private void SetupInterplayDialogs()
	{
		foreach (Interplay value in interplays.Values)
		{
			value.dialogs = AEResources.LoadAllResources<DialogData>(value.dialogsPath, throwOnError: false, silent: true);
		}
	}

	public string GetCharacterVariation(string charName, string defaultTo = "Default")
	{
		string value;
		return (!characterVariations.TryGetValue(charName, out value)) ? defaultTo : value;
	}

	public void SetCharacterVariation(string charName, string variation)
	{
		characterVariations[charName] = variation;
	}

	public InterplayPair InterplayGetPair(PartyMemberID a, PartyMemberID b)
	{
		if (InterplayMemberOrder(a) > InterplayMemberOrder(b))
		{
			Misc.Swap(ref a, ref b);
		}
		InterplayPair result = default(InterplayPair);
		result.a = a;
		result.b = b;
		return result;
	}

	public Interplay InterplayGetInterplay(InterplayPair pair)
	{
		return interplays[pair];
	}

	public bool InterplayPartyMemberIsValid(PartyMemberID a)
	{
		return partyMemberOrder[(int)a] != -1;
	}

	private int InterplayMemberOrder(PartyMemberID a)
	{
		return partyMemberOrder[(int)a];
	}

	private void SetupInterplay(PartyMemberID a, PartyMemberID b)
	{
		interplays.Add(InterplayGetPair(a, b), new Interplay(string.Concat("Dialogs/Interplay/", a, b)));
	}

	public void OnMissionLoad()
	{
		SetupInterplayDialogs();
		foreach (KeyValuePair<InterplayPair, Interplay> interplay in interplays)
		{
			if (interplay.Value.dialogs == null)
			{
				continue;
			}
			for (int i = 0; i < interplay.Value.dialogs.Length; i++)
			{
				DialogData dialogData = interplay.Value.dialogs[i];
				for (int j = 0; j < dialogData.dialogs.Length; j++)
				{
					ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
					for (int k = 0; k < unitsAllInWorld.Length; k++)
					{
						if (dialogData.dialogs[j].characterReference == unitsAllInWorld[k].charData)
						{
							dialogData.dialogs[j].unitRef = unitsAllInWorld[k];
							break;
						}
					}
				}
			}
		}
	}

	public static int GetMissionGroupNum()
	{
		return missionGroups.Length;
	}

	public bool IsMissionComplete(int groupidx, int missionidx)
	{
		return missionsCompleted[groupidx][missionidx];
	}

	public bool IsMissionComplete(string missionName)
	{
		for (int i = 0; i < missionGroups.Length; i++)
		{
			for (int j = 0; j < missionGroups[i].size; j++)
			{
				if (missionGroups[i].missionNames[j] == missionName)
				{
					return missionsCompleted[i][j];
				}
			}
		}
		return false;
	}

	public bool IsGameComplete()
	{
		for (int i = 0; i < missionGroups.Length; i++)
		{
			for (int j = 0; j < missionGroups[i].size; j++)
			{
				if (!missionsCompleted[i][j])
				{
					return false;
				}
			}
		}
		return chosenMission == null;
	}

	public static MissionGroup GetMissionGroupsAtIdx(int index)
	{
		return missionGroups[index];
	}

	public int GetFurthestMissionGroupIdx()
	{
		for (int i = 0; i < missionGroups.Length; i++)
		{
			for (int j = 0; j < missionGroups[i].size; j++)
			{
				if (!missionsCompleted[i][j])
				{
					return i;
				}
			}
		}
		return missionGroups.Length - 1;
	}

	public MissionGroup GetFurthestMissionGroup()
	{
		return missionGroups[GetFurthestMissionGroupIdx()];
	}

	public MissionSceneMeta GetNextMission()
	{
		int furthestMissionGroupIdx = GetFurthestMissionGroupIdx();
		MissionGroup furthestMissionGroup = GetFurthestMissionGroup();
		for (int i = 0; i < furthestMissionGroup.size; i++)
		{
			if (!IsMissionComplete(furthestMissionGroupIdx, i))
			{
				return GetMissionMetaByName(missionGroups[furthestMissionGroupIdx].missionNames[i]);
			}
		}
		return null;
	}

	public void SetMissionComplete(string missionName)
	{
		for (int i = 0; i < missionGroups.Length; i++)
		{
			for (int j = 0; j < missionGroups[i].size; j++)
			{
				if (missionGroups[i].missionNames[j] == missionName)
				{
					missionsCompleted[i][j] = true;
					break;
				}
			}
		}
	}

	public void ResetLastMissionToIncomplete()
	{
		int num = missionGroups.Length - 1;
		int num2 = missionGroups[num].size - 1;
		missionsCompleted[num][num2] = false;
	}

	public void ResetAllProgress()
	{
		for (int i = 0; i < missionGroups.Length; i++)
		{
			for (int j = 0; j < missionGroups[i].size; j++)
			{
				missionsCompleted[i][j] = false;
			}
		}
	}

	public static MissionSceneMeta GetMissionMetaByName(string missionName)
	{
		missionsByName.TryGetValue(missionName, out var value);
		return value;
	}

	public static void SaveProgressFromMenu()
	{
		SaveProgress();
	}

	public static bool SaveProgress(SaveLoad.ResultHandler handleResult = null, bool unthreaded = false)
	{
		if (!LR.CanSaveLoad)
		{
			return true;
		}
		try
		{
			return SaveLoad.Save(default(SaveLoad.DataHeader), data, delegate(SaveLoad.Result res)
			{
				lastResult = res;
			}, 0, unthreaded, silent: true).IsPending();
		}
		catch (Exception)
		{
			return false;
		}
	}

	public static HagletYieldTerm LoadProgress(bool forceLog)
	{
		return Routine.Start(new Haglet(LoadProgressRoutine(forceLog), "Load Progress Save Data", HagletStepTime.Update, 1), LR.Host);
	}

	public static IEnumerator<HagletYieldTerm> LoadProgressRoutine(bool forceLog)
	{
		yield return null;
		SaveLoad.ResultHandler storeResult = delegate(SaveLoad.Result res)
		{
			lastResult = res;
		};
		try
		{
			if (!data.enableSerializerLogging)
			{
			}
			lastResult = SaveLoad.Load(storeResult, 0, null, unthreaded: true, silent: true);
		}
		catch (Exception)
		{
			yield break;
		}
		yield return Wait.While(() => lastResult.IsPending());
		if (lastResult.Is(SaveLoad.Result.MissingData))
		{
			UnityEngine.Debug.Log("No saved progress found.");
		}
		else if (!lastResult.IsFailure())
		{
			globalProgress = SaveLoad.GetAndClearLastLoadedObject<SaveData>();
			globalProgress.SetupInterplayDialogs();
		}
	}

	public static void ClearProgress()
	{
		if (UnityEngine.Application.isPlaying)
		{
			Retain(unthreaded: true);
		}
		else
		{
			SaveLoad.Retain(2, null, unthreaded: true, silent: false, log: false, UnityEngine.Application.persistentDataPath);
		}
		if (lastResult.IsFailure())
		{
			UnityEngine.Debug.LogErrorFormat("Saved progress clear failed with {0}!", lastResult);
			return;
		}
		SaveLoad.Result result = SaveLoad.Delete(null, 0, unthreaded: true, silent: false, UnityEngine.Application.isPlaying && data.enableSerializerLogging);
		if (result.IsFailure())
		{
			UnityEngine.Debug.LogErrorFormat("Saved progress clear failed with {0}!", result);
			return;
		}
		globalProgress = null;
		if (UnityEngine.Application.isPlaying)
		{
			Release();
		}
		else
		{
			SaveLoad.Release();
		}
		UnityEngine.Debug.Log("Saved progress cleared!");
	}

	public static void ClearDataAndRestart()
	{
		ClearMission();
		ClearProgress();
		Singleton<UIC>.Inst.ClearImmediate();
		LR.Inst.LoadRoomSceneIntoFrontend(data.roomSceneMeta);
		Singleton<UIFlow>.Inst.StartFrame0ToMainMenu();
	}
}
public class SceneLoader : MonoBehaviour
{
}
public class ArtSceneMeta : SceneMeta
{
}
public class LogicSceneMeta : SceneMeta
{
	[Header("Logic data")]
	public ArtSceneMeta artScene;
}
public class MissionSceneMeta : SceneMeta
{
	[Header("Mission data")]
	[Space]
	public string missionTitle;

	[Space]
	[TextArea(3, 5)]
	public string missionDescription;

	[TextArea(3, 5)]
	public string missionObjectives;

	public bool doesNotNeedLoadout;

	public bool doesNotNeedOutroUI;

	[Range(0f, 6f)]
	public int numOfCharactersInLoadout;

	public CharacterData[] missionRequiredCharacters;

	public CharacterData[] suggestedCharacters;

	public CharacterData[] otherCharactersToGainXP;

	public CharacterData[] restrictedCharacters;

	public LogicSceneMeta[] logicMaps;

	public GameObject roomInteractionsPrefab;

	public GameObject postMissionHartmanCutscene;

	public RoomSceneMeta postMissionRoom;

	public string missionCompleteMusicPath;

	[Header("Temporary Music Paths")]
	public string combatMusicPath;

	public string explorationMusicPath;

	public bool devOnly;

	private const string pathImage = "Assets/_Game Assets/Textures/UI/MissionImages/TX_";

	[ReadOnly]
	public Sprite missionBriefImage;

	public static bool Validate(MissionSceneMeta meta)
	{
		bool result = true;
		LogicSceneMeta[] array = meta.logicMaps;
		for (int i = 0; i < array.Length; i++)
		{
			for (int j = i + 1; j < array.Length; j++)
			{
				if (array[i] == array[j])
				{
					result = false;
					UnityEngine.Debug.LogError("Error: Mission meta '" + meta.name + "' has a duplicate logics scene '" + array[i].sceneName + "' in meta!", meta);
				}
			}
		}
		return result;
	}
}
public class RoomSceneMeta : SceneMeta
{
}
public abstract class SceneMeta : AEScriptableResource
{
	public bool enabled = true;

	[ReadOnly]
	public string sceneName;

	[SerializeField]
	[ReadOnly]
	public string path;

	protected new string name;
}
public class ScrollingWalls : MonoBehaviour
{
	public enum Axis
	{
		x,
		y,
		z
	}

	private struct Child
	{
		public Transform xform;

		public Vector3 offset;
	}

	public float speed = 2f;

	public Axis axis;

	private Child[] children = new Child[2];

	public Vector3 minBoundsOffset;

	public Vector3 maxBoundsOffset;

	private Bounds bounds;

	private Map map;

	private void Awake()
	{
		for (int i = 0; i < children.Length; i++)
		{
			Child child = default(Child);
			child.xform = base.transform.GetChild(i);
			Child child2 = child;
			child2.offset = child2.xform.localPosition;
			children[i] = child2;
		}
		bounds = children[0].xform.gameObject.GetWorldBounds();
		bounds.min += minBoundsOffset;
		bounds.max += maxBoundsOffset;
		map = base.gameObject.GetComponentInAscendant<Map>();
	}

	private void OnEnable()
	{
		ConstArray<Material> allMapMaterials = map.GetAllMapMaterials();
		uint num = 0u;
		for (uint length = allMapMaterials.Length; num < length; num++)
		{
			allMapMaterials[num].EnableKeyword("SCROLLING_ON");
		}
	}

	private void OnDisable()
	{
		ConstArray<Material> allMapMaterials = map.GetAllMapMaterials();
		uint num = 0u;
		for (uint length = allMapMaterials.Length; num < length; num++)
		{
			allMapMaterials[num].DisableKeyword("SCROLLING_ON");
		}
	}

	private void Update()
	{
		if (!(Mathf.Abs(speed) > Mathf.Epsilon) || (!(LR.Inst == null) && LR.Inst.IsPaused()))
		{
			return;
		}
		for (int i = 0; i < children.Length; i++)
		{
			Transform xform = children[i].xform;
			int index = (int)axis;
			float num = bounds.extents[index];
			float num2 = num * 2f;
			float num3 = 0f - num2;
			float num4 = speed * Time.deltaTime;
			float num5 = xform.localPosition[index] + num4;
			Color blue = Color.blue;
			if (num5 < num3)
			{
				num5 += num2 * 2f;
				blue = Color.yellow;
			}
			else if (num5 > num2)
			{
				num5 += num3 * 2f;
				blue = Color.green;
			}
			Vector3 localPosition = xform.localPosition;
			localPosition[index] = num5;
			xform.localPosition = localPosition;
		}
	}
}
[SelectionBase]
public class SelectionBase : MonoBehaviour
{
}
public class ShakeObject : MonoBehaviour
{
	[HideInInspector]
	public AnimationCurve curveShakeNoise = new AnimationCurve();

	[HideInInspector]
	public bool lockLocalYAxis;

	private AnimFloat animShakeStrength = new AnimFloat(0f);

	private Vector3 origin;

	private Action onStopShaking;

	private bool paused;

	public bool Paused
	{
		get
		{
			return paused;
		}
		set
		{
			paused = value;
		}
	}

	private void Awake()
	{
		origin = base.transform.localPosition;
		onStopShaking = OnStopShaking;
		animShakeStrength.OnComplete = onStopShaking;
		int num = 120;
		float num2 = UnityEngine.Random.Range(1f, 2f);
		for (int i = 0; i < num; i++)
		{
			float num3 = (float)i / (float)(num - 1) * num2;
			float pos = num3 * (float)Math.PI * 2f;
			float value = NoiseWrapped(pos, 3f) * 0.8f + NoiseWrapped(pos, 6f) * 0.5f;
			curveShakeNoise.AddKey(num3, value);
		}
		curveShakeNoise.postWrapMode = WrapMode.Loop;
	}

	private void Update()
	{
		if (paused)
		{
			return;
		}
		float num = animShakeStrength.Update();
		Vector3 zero = Vector3.zero;
		if (num > 0f)
		{
			float num2 = curveShakeNoise.Evaluate(Time.time * 1.01f + 0.01f) * num;
			float num3 = curveShakeNoise.Evaluate(Time.time * 0.98f + 0.5f) * num;
			float num4 = curveShakeNoise.Evaluate(Time.time * 1.04f + 0.25f) * num;
			zero += base.transform.right * num2;
			zero += base.transform.up * num3;
			zero += base.transform.forward * num4;
			Vector3 localPosition = origin + zero;
			if (lockLocalYAxis)
			{
				localPosition.y = base.transform.localPosition.y;
			}
			base.transform.localPosition = localPosition;
		}
	}

	private float NoiseWrapped(float pos, float freq)
	{
		float x = (0.5f + Mathf.Sin(pos) * 0.5f) * freq;
		float y = (0.5f + Mathf.Cos(pos) * 0.5f) * freq;
		return Mathf.Clamp01(Mathf.PerlinNoise(x, y)) * 2f - 1f;
	}

	public void ResetOrigin()
	{
		origin = base.transform.localPosition;
	}

	public void Shake(float time, float strength = 0.01f, AnimationCurve curve = null)
	{
		if (curve != null)
		{
			animShakeStrength.Interpolate = (float x) => curve.Evaluate(x);
		}
		animShakeStrength.AnimateTo(strength, time);
	}

	public void ShakeOneShot(float time, float strength = 0.01f, AnimationCurve curve = null)
	{
		if (curve != null)
		{
			animShakeStrength.Interpolate = (float x) => curve.Evaluate(x);
		}
		animShakeStrength.Value = strength;
		animShakeStrength.AnimateTo(0f, time);
	}

	public void ShakePermanent(float revUpTime, float strength = 0.01f)
	{
		animShakeStrength.AnimateTo(strength, revUpTime);
	}

	public void StopShake(float time)
	{
		animShakeStrength.AnimateTo(0f, time);
	}

	public void StopShakeSudden()
	{
		animShakeStrength.AnimateTo(0f, 0.1f);
	}

	private void OnStopShaking()
	{
		base.transform.localPosition = origin;
	}
}
public class SinBob : MonoBehaviour
{
	public Vector3 bob;

	public float frequency = 1f;

	private void Update()
	{
		float num = 0.5f * (1f + Mathf.Sin((float)Math.PI * 2f * frequency * Time.time));
		base.transform.localPosition = bob * num;
	}
}
public abstract class Singleton<U> : MonoBehaviour, Serializer.ISelfComposer where U : Singleton<U>
{
	public static U Inst { get; private set; }

	protected virtual void Awake()
	{
		Inst = (U)this;
	}

	protected virtual void OnDestroy()
	{
		Inst = (U)null;
	}

	public virtual void Decompose(Serializer.IMemberSink members)
	{
	}

	public virtual void Recompose(Serializer.IMemberSource members)
	{
		Inst = (U)this;
	}
}
[ExecuteInEditMode]
public class SitAnchor : MonoBehaviour
{
}
[ExecuteInEditMode]
public class Snap : MonoBehaviour
{
}
public class SubtitlePoint : MonoBehaviour
{
	public bool startSubtitlePoint;

	public bool canViewAtOther90DegAngles = true;

	private void OnDrawGizmos()
	{
		Color green = Color.green;
		green.a = 0.3f;
		Gizmos.color = green;
		Gizmos.DrawSphere(base.transform.position, 0.25f);
	}
}
public class SurveillanceCamera : MonoBehaviour
{
	public enum Type
	{
		LookAtPlayer,
		LookAtRandom
	}

	public Type type;

	public float angleXMin = -40f;

	public float angleXMax;

	public float angleYMin = -60f;

	public float angleYMax = 60f;

	private AnimQuaternion animLookAt = new AnimQuaternion();

	private Quaternion initialLookDirection;

	private void Start()
	{
		initialLookDirection = base.transform.rotation;
		animLookAt.Value = initialLookDirection;
		animLookAt.Interpolate = AnimValue<Vector2>.Linear;
		ChooseNewLookTarget(2f);
	}

	private void ChooseNewLookTarget(float delayTime)
	{
		float y = UnityEngine.Random.Range(angleYMin, angleYMax);
		float x = UnityEngine.Random.Range(angleXMin, angleXMax);
		animLookAt.AnimateTo(initialLookDirection * Quaternion.Euler(x, y, 0f), 2.4f, delayTime);
	}

	private void Update()
	{
		if (type == Type.LookAtPlayer && Singleton<PC>.Inst.GetLeader() != null)
		{
			base.transform.LookAt(Singleton<PC>.Inst.GetLeader().GetPositionWS());
			return;
		}
		Quaternion rotation = animLookAt.Update();
		if (!animLookAt.animating)
		{
			ChooseNewLookTarget(UnityEngine.Random.Range(2.5f, 7f));
		}
		base.transform.rotation = rotation;
	}
}
public static class Tutorials
{
	public static DialogData dialogShop;

	public static DialogData dialogFirstAugmentInstall_1;

	public static DialogData dialogFirstAugmentInstall_2;

	public static DialogData dialogFirstAugmentInstall_3;

	public static DialogData dialogFirstAugmentInstall_4;

	public static DialogData dialogFirstAugmentInstall_5;

	public static DialogData dialogOverloadingAbility;

	public static DialogData dialogFirstRejectionShot_1;

	public static DialogData dialogFirstRejectionShot_2;

	public static DialogData dialogPickedUpScrap;

	public static DialogData dialogPickedUpCircuitry;

	public static DialogData dialogPickedUpJewellery;

	public static DialogData dialogPickedUpAtlatium;

	public static DialogData dialogPickedUpRejectionShot;

	public static DialogData dialogBoughtRejectionShot;

	public static DialogData dialogBoughtAtlatium;

	public static DialogData dialogAcquiredAugment;

	public static DialogData dialogAcquiredMedkit;

	public static void Initialize()
	{
		dialogShop = Load("Dialogs/ItemTutorials/Tutorial_Shop");
		dialogFirstAugmentInstall_1 = Load("Dialogs/LevellingCharactersTutorials/Tutorial_FirstAugmentInstall_1");
		dialogFirstAugmentInstall_2 = Load("Dialogs/LevellingCharactersTutorials/Tutorial_FirstAugmentInstall_2");
		dialogFirstAugmentInstall_3 = Load("Dialogs/LevellingCharactersTutorials/Tutorial_FirstAugmentInstall_3");
		dialogFirstAugmentInstall_4 = Load("Dialogs/LevellingCharactersTutorials/Tutorial_FirstAugmentInstall_4");
		dialogFirstAugmentInstall_5 = Load("Dialogs/LevellingCharactersTutorials/Tutorial_FirstAugmentInstall_5");
		dialogFirstRejectionShot_1 = Load("Dialogs/UsingRejectionShotTutorials/Tutorial_FirstRejectionShot_1");
		dialogFirstRejectionShot_2 = Load("Dialogs/UsingRejectionShotTutorials/Tutorial_FirstRejectionShot_2");
		dialogOverloadingAbility = Load("Dialogs/ItemTutorials/Tutorial_OverloadingAbility");
		dialogPickedUpScrap = Load("Dialogs/ItemTutorials/Tutorial_Scrap");
		dialogPickedUpCircuitry = Load("Dialogs/ItemTutorials/Tutorial_Circuitry");
		dialogPickedUpJewellery = Load("Dialogs/ItemTutorials/Tutorial_Jewellery");
		dialogBoughtAtlatium = Load("Dialogs/ItemTutorials/Tutorial_Atlantium");
		dialogPickedUpAtlatium = Load("Dialogs/ItemTutorials/Tutorial_AtlantiumCore");
		dialogPickedUpRejectionShot = Load("Dialogs/ItemTutorials/Tutorial_RejectionShot");
		dialogBoughtRejectionShot = Load("Dialogs/ItemTutorials/Tutorial_RejectionShotShop");
		dialogAcquiredAugment = Load("Dialogs/ItemTutorials/Tutorial_Augment");
		dialogAcquiredMedkit = Load("Dialogs/ItemTutorials/Tutorial_MedKit");
	}

	private static DialogData Load(string path)
	{
		return AEResources.LoadFirstResource<DialogData>(path);
	}

	public static void PlayTutorialDialog(ref bool isPlayed, DialogData dialog)
	{
		if (!isPlayed)
		{
			isPlayed = true;
			UIAmbientSubtitles.Inst.Show(dialog);
		}
	}
}
[Serializable]
public struct FMODParam
{
	public string name;

	public float value;
}
public class UnitAnimFuncs : MonoBehaviour
{
	public enum Event
	{
		None,
		Attack,
		PickUp,
		Interact
	}

	public enum WeaponFoleyState
	{
		None,
		Walk,
		Run
	}

	public const string defaultFootstep = "event:/sfx/character v2/foley/general/footstep/default";

	private Unit unit;

	[HideInInspector]
	public string pickUpDescr;

	[HideInInspector]
	public Action pickUpOnPickUp;

	[HideInInspector]
	public Action pickUpOnFinish;

	[HideInInspector]
	public string interactDescr;

	[HideInInspector]
	public Action interactOnInteract;

	[NonSerialized]
	public Event anticipatedEvent;

	[NonSerialized]
	private HagletTrigger eventTrigger = new HagletTrigger();

	public void OnSpawn()
	{
		unit = base.gameObject.GetComponentInAscendant<Unit>();
	}

	[AEAnimFunc]
	private void OnAttack()
	{
		CheckEventTrigger(Event.Attack);
	}

	[AEAnimFunc]
	private void OnPickUp()
	{
		CheckEventTrigger(Event.PickUp);
	}

	[AEAnimFunc]
	private void OnInteract()
	{
		CheckEventTrigger(Event.Interact);
	}

	[AEAnimFunc]
	private void HologramMakeInactiveSomehow()
	{
		unit.Hide(makeInactive: true);
	}

	[AEAnimFunc]
	public void PlayParticle(ParticleTypes particletype)
	{
		PSC.Inst.Play(particletype, unit.map, unit.coord);
	}

	[AEAnimFunc]
	public void PlayGunMuzzleFlash()
	{
		unit.AttackMuzzleFlash();
	}

	private WeaponFoleyState GetFoleyState()
	{
		if (unit.unitModel.WeaponXForm == null || VectorX.Max(unit.unitModel.WeaponXForm.transform.localScale) < 0.01f)
		{
			return WeaponFoleyState.None;
		}
		UnitModel.AnimID animIDByName = UnitModel.GetAnimIDByName(unit.unitModel.animName);
		if (animIDByName == UnitModel.AnimID.CombatWalk || animIDByName == UnitModel.AnimID.DefaultWalk || animIDByName == UnitModel.AnimID.Vault)
		{
			return WeaponFoleyState.Run;
		}
		return WeaponFoleyState.Walk;
	}

	[AEAnimFunc]
	public void PlayFootstep()
	{
		if (unit.map == Singleton<MC>.Inst.GetActiveMap())
		{
			FMOD.Studio.EventInstance handle = AC.Inst.GetHandle((!string.IsNullOrEmpty(unit.charData.FootstepPath)) ? unit.charData.FootstepPath : "event:/sfx/character v2/foley/general/footstep/default");
			if (handle.isValid())
			{
				handle.setParameterValue("surface", unit.map.GetTileData(unit.coord).surfaceSFXValue);
				handle.setParameterValue("gun foley", (float)GetFoleyState() * 0.1f);
				handle.set3DAttributes(ACMisc.to3DAttributes(unit.gameObject));
				handle.start();
				handle.release();
			}
		}
	}

	[AEAnimFunc]
	public void PlaySoundAt(string eventPath, FMODParam[] fmodParams, bool provideSurfaceParam)
	{
		if (unit != null && unit.map == Singleton<MC>.Inst.GetActiveMap())
		{
			FMOD.Studio.EventInstance handle = AC.Inst.GetHandle(eventPath);
			if (handle.isValid())
			{
				if (provideSurfaceParam)
				{
					handle.setParameterValue("surface", unit.map.GetTileData(unit.coord).surfaceSFXValue);
				}
				for (int i = 0; i < fmodParams.Length; i++)
				{
					handle.setParameterValue(fmodParams[i].name, fmodParams[i].value);
				}
				handle.set3DAttributes(ACMisc.to3DAttributes(unit.gameObject));
				handle.start();
				handle.release();
			}
		}
		else if (base.gameObject.CompareTag("Hartman"))
		{
			FMOD.Studio.EventInstance handle2 = AC.Inst.GetHandle(eventPath);
			for (int j = 0; j < fmodParams.Length; j++)
			{
				handle2.setParameterValue(fmodParams[j].name, fmodParams[j].value);
			}
			if (handle2.isValid())
			{
				handle2.set3DAttributes(ACMisc.to3DAttributes(base.gameObject));
				handle2.start();
				handle2.release();
			}
		}
	}

	public static float PlaySoundAt_GetDuration(string eventPath, FMODParam[] fmodParams, bool provideSurfaceParam)
	{
		return 0.1f;
	}

	public HagletTrigger TriggerOnEvent(Event evt)
	{
		anticipatedEvent = evt;
		return eventTrigger;
	}

	private void CheckEventTrigger(Event currEvt)
	{
		if (currEvt == anticipatedEvent)
		{
			eventTrigger.Trigger();
			anticipatedEvent = Event.None;
		}
	}
}
public class VolumeLevels
{
	private static VolumeLevels _instance;

	private static readonly string musicVCAKey = "vca:/music";

	private static readonly string dialogueVCAKey = "vca:/vo";

	private static readonly string sfxVCAKey = "vca:/sfx";

	private static VCA musicVCA;

	private static VCA dialogueVCA;

	private static VCA sfxVCA;

	private static readonly string musicPrefsKey = "musicVolume";

	private static readonly string dialoguePrefsKey = "dialogueVolume";

	private static readonly string sfxPrefsKey = "sfxVolume";

	private static readonly float soundInterval = 0.25f;

	private static readonly int maxSliderIndex = 4;

	private int? _musicIndex;

	private int? _dialogueIndex;

	private int? _sfxIndex;

	private bool isLoaded;

	public static VolumeLevels Inst
	{
		get
		{
			if (_instance == null)
			{
				_instance = new VolumeLevels();
			}
			return _instance;
		}
	}

	public int MusicIndex
	{
		get
		{
			if (!_musicIndex.HasValue)
			{
				_musicIndex = PlayerPrefs.GetInt(musicPrefsKey, maxSliderIndex);
			}
			return _musicIndex.Value;
		}
		set
		{
			_musicIndex = value;
			musicVCA.setVolume((float)value * 0.25f);
			MusicController.Inst.SetMusicSnapShotIntensity((float)value / 4f * 100f);
			PlayerPrefs.SetInt(musicPrefsKey, value);
		}
	}

	public int DialogueIndex
	{
		get
		{
			if (!_dialogueIndex.HasValue)
			{
				_dialogueIndex = PlayerPrefs.GetInt(dialoguePrefsKey, maxSliderIndex);
			}
			return _dialogueIndex.Value;
		}
		set
		{
			_dialogueIndex = value;
			dialogueVCA.setVolume((float)value * 0.25f);
			PlayerPrefs.SetInt(dialoguePrefsKey, value);
		}
	}

	public int SFXIndex
	{
		get
		{
			if (!_sfxIndex.HasValue)
			{
				_sfxIndex = PlayerPrefs.GetInt(sfxPrefsKey, maxSliderIndex);
			}
			return _sfxIndex.Value;
		}
		set
		{
			_sfxIndex = value;
			sfxVCA.setVolume((float)value * 0.25f);
			PlayerPrefs.SetInt(sfxPrefsKey, value);
		}
	}

	public bool IsLoaded => isLoaded;

	private VolumeLevels()
	{
	}

	public void Load()
	{
		if (!musicVCA.isValid())
		{
			AC.Inst.sys.getVCA(musicVCAKey, out musicVCA);
		}
		if (!dialogueVCA.isValid())
		{
			AC.Inst.sys.getVCA(dialogueVCAKey, out dialogueVCA);
		}
		if (!sfxVCA.isValid())
		{
			AC.Inst.sys.getVCA(sfxVCAKey, out sfxVCA);
		}
		musicVCA.setVolume((float)MusicIndex * soundInterval);
		dialogueVCA.setVolume((float)DialogueIndex * soundInterval);
		sfxVCA.setVolume((float)SFXIndex * soundInterval);
		isLoaded = true;
	}
}
public class WeaponXForm : MonoBehaviour
{
}
public class GameTypeAsset : ScriptableObject
{
	public enum GameType
	{
		FullGame,
		OculusTouchDemo
	}

	public GameType gameType;

	public bool ignoreAttainment;
}
public class PCCamera : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Platform
{
	public static bool debugAndroidTouchInput;

	public static bool debugBuild = true;

	public static bool IsWindowsPlatform => UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer;

	public static bool IsWindowsEditor => UnityEngine.Application.platform == RuntimePlatform.WindowsEditor;

	public static bool IsAndroidPlatform
	{
		get
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return true;
			}
			return false;
		}
	}

	public static bool IsGameControllerUsed => IC.controlInputType != IC.InputType.Touch;
}
public class PrebuildRemoveGameobject : MonoBehaviour
{
}
public class ValidateGameObjectActive : MonoBehaviour
{
	public bool shouldBeActive;
}
public class ValidationIgnore : MonoBehaviour
{
}
[ExecuteInEditMode]
public class AEViewpoint : MonoBehaviour
{
}
[ExecuteInEditMode]
public class AnimateAlpha : MonoBehaviour
{
	public AnimationCurve alphaCurve;

	private SpriteRenderer sr;

	private float startTime;

	private void Awake()
	{
		sr = GetComponent<SpriteRenderer>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
	}

	private void Update()
	{
		sr.color = sr.color.RepA(alphaCurve.Evaluate(Time.time - startTime));
	}
}
public class BloomPrepass : MonoBehaviour
{
	[Range(0f, 2f)]
	public float bloomIntensity = 1f;

	public Color bloomThresholdColor = Color.white;

	[Range(0f, 1f)]
	public float bloomThreshold = 0.3f;

	public int bloomBlurIterations = 1;

	public float bloomBlurSpread = 2.5f;

	public float fov = 110f;

	public static Shader shaderBlendForBloom;

	public static Material matBloomShader;

	private const int renderTargetSizeX = 512;

	private const int renderTargetSizeY = 256;

	[ReadOnly]
	public RenderTexture rtBloomPrepass;

	public float AspectRatio => 2f;

	public void RenderPrepass()
	{
		if (!shaderBlendForBloom)
		{
			shaderBlendForBloom = Shader.Find("AE/Fog Prepass");
			matBloomShader = CheckShaderAndCreateMaterial(shaderBlendForBloom);
		}
		if (!rtBloomPrepass)
		{
			rtBloomPrepass = new RenderTexture(512, 256, 24, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Default);
		}
		CommandBuffer commandBuffer = new CommandBuffer();
		commandBuffer.SetRenderTarget(rtBloomPrepass);
		commandBuffer.ClearRenderTarget(clearDepth: true, clearColor: true, new Color(0f, 0f, 0f, 0f));
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>(includeInactive: false);
		Camera camera = base.gameObject.AddComponent<Camera>();
		camera.AddCommandBuffer(CameraEvent.AfterDepthNormalsTexture, commandBuffer);
		camera.enabled = false;
		GenerateBloomCommands(commandBuffer, rtBloomPrepass);
		AEViewpoint componentInChildren = GetComponentInChildren<AEViewpoint>();
		Vector3 position = componentInChildren.transform.position;
		Quaternion rotation = componentInChildren.transform.rotation;
		Matrix4x4 mat = Matrix4x4.Perspective(fov, AspectRatio, 0.3f, 100f);
		Matrix4x4 inverse = Matrix4x4.TRS(position, rotation, new Vector3(1f, 1f, -1f)).inverse;
		GL.LoadProjectionMatrix(mat);
		GL.modelview = inverse;
		Graphics.ExecuteCommandBuffer(commandBuffer);
	}

	private int GetRTId(string name)
	{
		return Shader.PropertyToID(name);
	}

	private void GenerateBloomCommands(CommandBuffer cb, RenderTexture prepassRT)
	{
		RenderTargetIdentifier renderTargetIdentifier = new RenderTargetIdentifier(prepassRT);
		int rTId = GetRTId("rtHalf");
		int rTId2 = GetRTId("rtQuarter");
		int rTId3 = GetRTId("rtQuarterTemp");
		RenderTextureFormat format = RenderTextureFormat.Default;
		int width = 256;
		int height = 128;
		int width2 = 128;
		int height2 = 64;
		float aspectRatio = AspectRatio;
		float num = 0.001953125f;
		cb.GetTemporaryRT(rTId, width, height, 0, FilterMode.Bilinear, format);
		cb.GetTemporaryRT(rTId2, width2, height2, 0, FilterMode.Bilinear, format);
		cb.GetTemporaryRT(rTId3, width2, height2, 0, FilterMode.Bilinear, format);
		cb.Blit(renderTargetIdentifier, rTId, matBloomShader, 2);
		cb.Blit(rTId, rTId3, matBloomShader, 2);
		cb.Blit(rTId3, rTId2, matBloomShader, 6);
		cb.SetGlobalVector("_Threshhold", bloomThresholdColor * bloomThreshold);
		cb.Blit(rTId2, rTId3, matBloomShader, 12);
		if (bloomBlurIterations < 1)
		{
			bloomBlurIterations = 1;
		}
		else if (bloomBlurIterations > 10)
		{
			bloomBlurIterations = 10;
		}
		for (int i = 0; i < bloomBlurIterations; i++)
		{
			float num2 = (1f + (float)i * 0.25f) * bloomBlurSpread;
			int rTId4 = GetRTId("rtBlurTemp");
			cb.GetTemporaryRT(rTId4, width2, height2, 0, FilterMode.Bilinear, format);
			cb.SetGlobalVector("_Offsets", new Vector4(0f, num2 * num, 0f, 0f));
			cb.Blit(rTId3, rTId4, matBloomShader, 13);
			cb.SetGlobalVector("_Offsets", new Vector4(num2 / aspectRatio * num, 0f, 0f, 0f));
			cb.Blit(rTId4, rTId3, matBloomShader, 13);
			cb.ReleaseTemporaryRT(rTId4);
		}
		cb.Blit(rTId3, renderTargetIdentifier);
		cb.ReleaseTemporaryRT(rTId);
		cb.ReleaseTemporaryRT(rTId2);
		cb.ReleaseTemporaryRT(rTId3);
	}

	protected Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (!s)
		{
			UnityEngine.Debug.Log("Missing shader in " + ToString());
			base.enabled = false;
			return null;
		}
		if (!s.isSupported)
		{
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
			return null;
		}
		Material material = new Material(s);
		material.hideFlags = HideFlags.DontSave;
		if ((bool)material)
		{
			return material;
		}
		return null;
	}

	public void Show(float fadeInDuration)
	{
		AECameraFullscreenPass.Inst.AnimateBloomIntensity(bloomIntensity, fadeInDuration);
		AECameraFullscreenPass.Inst.SetBloomPrepass(rtBloomPrepass, fov, AspectRatio);
	}

	public void Hide(float fadeOutDuration)
	{
		AECameraFullscreenPass.Inst.AnimateBloomIntensity(0f, fadeOutDuration);
	}
}
public class CustomMat<T> where T : Renderer
{
	public Material original;

	public Material clone;

	public T target;

	private bool isEnabled;

	public CustomMat(T target)
	{
		this.target = target;
		original = target.sharedMaterial;
		clone = new Material(original);
	}

	public void Enable()
	{
		target.sharedMaterial = clone;
		isEnabled = true;
	}

	public void Disable()
	{
		target.sharedMaterial = original;
		isEnabled = false;
	}

	public bool IsEnabled()
	{
		return isEnabled;
	}

	public void SetColor(Color color)
	{
		clone.color = color;
	}
}
public class FogShaders : MonoBehaviour
{
}
public class NeonBillboardVertexColorer : JK3DMeshMod
{
	public enum BillboardType
	{
		Flipping,
		Scrolling,
		Flickering
	}

	public Color flickeringRandomness;

	public BillboardType type;

	public float scrollSpeed;

	public float flipTimeOffset;
}
[RequireComponent(typeof(NeonSignVertexWrapper), typeof(JK3DVertexColorer))]
public class NeonSignSFX : SFXAmbTarget_Positional
{
	private JK3DVertexColorer vertColor;

	protected override void Awake()
	{
		base.Awake();
		vertColor = GetComponent<JK3DVertexColorer>();
	}

	public override void Update()
	{
		base.Update();
		float num = MathfX.Step(Mathf.Sin(Time.time * vertColor.color.r * 5f) * 0.5f + 0.5f + Mathf.Sin(Time.time * vertColor.color.g * 20f + 1.5f) * 0.2f + Mathf.Sin(Time.time * vertColor.color.b * 30f + 4.5f) * 0.2f, 0.5f);
		if (handle.isValid())
		{
			handle.setParameterValue("flicker", (!(num > 0f)) ? 0.2f : 0.1f);
		}
	}
}
public class NeonSignVertexWrapper : JK3DMeshMod
{
	public float scrollSpeed;
}
public class STUB_FogQuad : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
[RequireComponent(typeof(Renderer))]
public class SetSortingOrder : MonoBehaviour
{
	public int sortOrder;

	private void OnValidate()
	{
		GetComponent<Renderer>().sortingOrder = sortOrder;
	}
}
public class StaticBatch : MonoBehaviour
{
	public int sortOrder;
}
public static class StaticBatchCombiner
{
	private class MergedMesh
	{
		public List<Vector3> mergedVertices = new List<Vector3>();

		public List<Vector3> mergedNormals = new List<Vector3>();

		public List<Vector4> mergedTangents = new List<Vector4>();

		public List<Color> mergedColors = new List<Color>();

		public List<Vector2> mergedUV0s = new List<Vector2>();

		public List<Vector2> mergedUV1s = new List<Vector2>();

		public List<Vector2> mergedUV2s = new List<Vector2>();

		public List<Vector2> mergedUV3s = new List<Vector2>();

		public List<int> mergedIndices = new List<int>();

		public bool expectNormals;

		public bool expectTangents;

		public bool expectColors;

		public bool expectUV0;

		public bool expectUV1;

		public bool expectUV2;

		public bool expectUV3;

		public Mesh firstMesh;

		public Material sharedMaterial;
	}

	public static void Combine(StaticBatch staticBatch, bool cullBackFaces, Vector3 cullingCameraPos)
	{
		Dictionary<Material, MergedMesh> dictionary = new Dictionary<Material, MergedMesh>();
		MeshRenderer[] componentsInChildren = staticBatch.GetComponentsInChildren<MeshRenderer>();
		for (uint num = 0u; num < componentsInChildren.Length; num++)
		{
			MeshRenderer meshRenderer = componentsInChildren[num];
			MeshFilter component = meshRenderer.GetComponent<MeshFilter>();
			StaticBatchIgnoreBackcull component2 = meshRenderer.GetComponent<StaticBatchIgnoreBackcull>();
			if (meshRenderer.sharedMaterial == null)
			{
				UnityEngine.Debug.LogError("MeshRenderer has a null material", meshRenderer);
				UnityEngine.Debug.Break();
			}
			else
			{
				if (component == null)
				{
					continue;
				}
				if (component.sharedMesh == null)
				{
					UnityEngine.Debug.LogError("MeshFilter has a null mesh", component);
					UnityEngine.Debug.Break();
					continue;
				}
				if (component.sharedMesh.subMeshCount > 1)
				{
					UnityEngine.Debug.LogWarning("Mesh has multiple sub-meshes and cannot be batched!", component);
					UnityEngine.Debug.Break();
					continue;
				}
				if (component.sharedMesh.normals == null)
				{
					UnityEngine.Debug.LogWarning("Mesh has multiple sub-meshes and cannot be batched!", component);
					UnityEngine.Debug.Break();
					continue;
				}
				Mesh sharedMesh = component.sharedMesh;
				Vector3[] array = sharedMesh.vertices;
				Vector3[] array2 = sharedMesh.normals;
				Vector4[] array3 = sharedMesh.tangents;
				Color[] array4 = sharedMesh.colors;
				Vector2[] array5 = sharedMesh.uv;
				Vector2[] array6 = sharedMesh.uv2;
				Vector2[] array7 = sharedMesh.uv3;
				Vector2[] array8 = sharedMesh.uv4;
				int[] array9 = sharedMesh.triangles;
				if (!dictionary.TryGetValue(meshRenderer.sharedMaterial, out var value))
				{
					value = new MergedMesh();
					dictionary.Add(meshRenderer.sharedMaterial, value);
					value.expectNormals = !ArrayX.IsNullOrEmpty(array2);
					value.expectTangents = !ArrayX.IsNullOrEmpty(array3);
					value.expectColors = !ArrayX.IsNullOrEmpty(array4);
					value.expectUV0 = !ArrayX.IsNullOrEmpty(array5);
					value.expectUV1 = !ArrayX.IsNullOrEmpty(array6);
					value.expectUV2 = !ArrayX.IsNullOrEmpty(array7);
					value.expectUV3 = !ArrayX.IsNullOrEmpty(array8);
					value.firstMesh = sharedMesh;
					value.sharedMaterial = meshRenderer.sharedMaterial;
				}
				if (ArrayX.IsNullOrEmpty(array2) == value.expectNormals && array2.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant normals compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array3) == value.expectTangents && array3.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant tangents compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array4) == value.expectColors && array4.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant colors compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array5) == value.expectUV0 && array5.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV1's compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array6) == value.expectUV1 && array6.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV2's compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array7) == value.expectUV2 && array7.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV3's compared with " + value.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array8) == value.expectUV3 && array8.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV4's compared with " + value.firstMesh, component);
					continue;
				}
				if (cullBackFaces && component2 == null)
				{
					List<int> list = new List<int>(array9.Length);
					int[] array10 = new int[array.Length];
					int[] array11 = Enumerable.Range(0, array.Length).ToArray();
					bool flag = false;
					Matrix4x4 localToWorldMatrix = meshRenderer.transform.localToWorldMatrix;
					Matrix4x4 transpose = localToWorldMatrix.inverse.transpose;
					for (int i = 0; i < array9.Length; i += 3)
					{
						Vector3 v = array[array9[i]];
						Vector3 v2 = array[array9[i + 1]];
						Vector3 v3 = array[array9[i + 2]];
						Vector3 vector = localToWorldMatrix * v.V3ToV4(1f);
						Vector3 vector2 = localToWorldMatrix * v2.V3ToV4(1f);
						Vector3 vector3 = localToWorldMatrix * v3.V3ToV4(1f);
						Vector3 vector4 = (vector + vector2 + vector3) / 3f;
						Vector3 normalized = (vector2 - vector).normalized;
						Vector3 normalized2 = (vector2 - vector3).normalized;
						Vector3 normalized3 = Vector3.Cross(normalized2, normalized).normalized;
						Vector3 lhs = normalized3;
						if (Vector3.Dot(lhs, (cullingCameraPos - vector4).normalized) > 0f)
						{
							list.Add(array9[i]);
							list.Add(array9[i + 1]);
							list.Add(array9[i + 2]);
						}
					}
					HashSet<int> hashSet = new HashSet<int>(list);
					for (int j = 0; j < array.Length; j++)
					{
						if (!hashSet.Contains(j))
						{
							array10[j] = -1;
							flag = true;
						}
					}
					if (flag)
					{
						List<Vector3> list2 = new List<Vector3>();
						List<Vector3> list3 = new List<Vector3>();
						List<Vector4> list4 = new List<Vector4>();
						List<Color> list5 = new List<Color>();
						List<Vector2> list6 = new List<Vector2>();
						List<Vector2> list7 = new List<Vector2>();
						List<Vector2> list8 = new List<Vector2>();
						List<Vector2> list9 = new List<Vector2>();
						List<int> list10 = new List<int>();
						int num2 = 0;
						for (int k = 0; k < array.Length; k++)
						{
							array11[k] = k - num2;
							int num3 = array10[k];
							if (num3 == -1)
							{
								num2++;
								continue;
							}
							list2.Add(array[k]);
							if (value.expectNormals)
							{
								list3.Add(array2[k]);
							}
							if (value.expectTangents)
							{
								list4.Add(array3[k]);
							}
							if (value.expectColors)
							{
								list5.Add(array4[k]);
							}
							if (value.expectUV0)
							{
								list6.Add(array5[k]);
							}
							if (value.expectUV1)
							{
								list7.Add(array6[k]);
							}
							if (value.expectUV2)
							{
								list8.Add(array7[k]);
							}
							if (value.expectUV3)
							{
								list9.Add(array8[k]);
							}
						}
						for (int l = 0; l < list.Count; l += 3)
						{
							list10.Add(array11[list[l]]);
							list10.Add(array11[list[l + 1]]);
							list10.Add(array11[list[l + 2]]);
						}
						array = list2.ToArray();
						array9 = list10.ToArray();
						if (value.expectNormals)
						{
							array2 = list3.ToArray();
						}
						if (value.expectTangents)
						{
							array3 = list4.ToArray();
						}
						if (value.expectColors)
						{
							array4 = list5.ToArray();
						}
						if (value.expectUV0)
						{
							array5 = list6.ToArray();
						}
						if (value.expectUV1)
						{
							array6 = list7.ToArray();
						}
						if (value.expectUV2)
						{
							array7 = list8.ToArray();
						}
						if (value.expectUV3)
						{
							array8 = list9.ToArray();
						}
					}
				}
				int count = value.mergedVertices.Count;
				Transform transform = meshRenderer.transform;
				Matrix4x4 localToWorldMatrix2 = transform.localToWorldMatrix;
				Matrix4x4 transpose2 = localToWorldMatrix2.inverse.transpose;
				Vector4 vector5 = new Vector4(0f, 0f, 0f, 1f);
				for (int m = 0; m < array.Length; m++)
				{
					vector5.x = array[m].x;
					vector5.y = array[m].y;
					vector5.z = array[m].z;
					vector5.w = 1f;
					vector5 = localToWorldMatrix2 * vector5;
					array[m].x = vector5.x;
					array[m].y = vector5.y;
					array[m].z = vector5.z;
				}
				value.mergedVertices.AddRange(array);
				if (value.expectNormals)
				{
					Vector4 vector6 = new Vector4(0f, 0f, 0f, 0f);
					for (int n = 0; n < array2.Length; n++)
					{
						Vector3 vector7 = array2[n];
						vector6.x = array2[n].x;
						vector6.y = array2[n].y;
						vector6.z = array2[n].z;
						vector6.w = 0f;
						vector6 = transpose2 * vector6;
						array2[n].x = vector6.x;
						array2[n].y = vector6.y;
						array2[n].z = vector6.z;
					}
					value.mergedNormals.AddRange(array2);
				}
				if (value.expectTangents)
				{
					value.mergedTangents.AddRange(array3);
				}
				if (value.expectColors)
				{
					value.mergedColors.AddRange(array4);
				}
				if (value.expectUV0)
				{
					value.mergedUV0s.AddRange(array5);
				}
				if (value.expectUV1)
				{
					value.mergedUV1s.AddRange(array6);
				}
				if (value.expectUV2)
				{
					value.mergedUV2s.AddRange(array7);
				}
				if (value.expectUV3)
				{
					value.mergedUV3s.AddRange(array8);
				}
				for (int num4 = 0; num4 < array9.Length; num4++)
				{
					array9[num4] += count;
				}
				value.mergedIndices.AddRange(array9);
				UnityEngine.Object.DestroyImmediate(meshRenderer, allowDestroyingAssets: true);
				UnityEngine.Object.DestroyImmediate(component, allowDestroyingAssets: true);
			}
		}
		foreach (KeyValuePair<Material, MergedMesh> item in dictionary)
		{
			MergedMesh value2 = item.Value;
			Mesh mesh = new Mesh();
			mesh.vertices = value2.mergedVertices.ToArray();
			mesh.normals = value2.mergedNormals.ToArray();
			mesh.tangents = value2.mergedTangents.ToArray();
			mesh.colors = value2.mergedColors.ToArray();
			mesh.uv = value2.mergedUV0s.ToArray();
			mesh.uv2 = value2.mergedUV1s.ToArray();
			mesh.uv3 = value2.mergedUV2s.ToArray();
			mesh.uv4 = value2.mergedUV3s.ToArray();
			mesh.triangles = value2.mergedIndices.ToArray();
			GameObject gameObject = new GameObject("MERGED_StaticArtwork_" + value2.sharedMaterial.name);
			gameObject.transform.parent = staticBatch.transform;
			MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
			meshFilter.sharedMesh = mesh;
			MeshRenderer meshRenderer2 = gameObject.AddComponent<MeshRenderer>();
			meshRenderer2.sharedMaterial = value2.sharedMaterial;
			meshRenderer2.receiveShadows = false;
			meshRenderer2.lightProbeUsage = LightProbeUsage.Off;
			meshRenderer2.shadowCastingMode = ShadowCastingMode.Off;
			meshRenderer2.reflectionProbeUsage = ReflectionProbeUsage.Off;
			meshRenderer2.motionVectorGenerationMode = MotionVectorGenerationMode.ForceNoMotion;
			meshRenderer2.sortingOrder = staticBatch.sortOrder;
		}
	}
}
public class StaticBatchIgnoreBackcull : MonoBehaviour
{
}
public class VFXTile : MonoBehaviour
{
}
public enum OptionalDirection
{
	Up,
	UpRight,
	Right,
	DownRight,
	Down,
	DownLeft,
	Left,
	UpLeft,
	None
}
public abstract class TileActionBase : TileObjectBase
{
	public UICrosshairContext crosshairContext = UICrosshairContext.Interaction;

	public bool showPOIHighlight = true;

	public bool turnOffAfterUse;

	public bool costsAp;

	[EnumFlagsField]
	public GC.State availableIn = GC.State.RPG;

	private BoxCollider[][] trigVolumes;

	protected bool isActiveUnitInRange;

	public string specificUnitID;

	private Unit specificUnitRef;

	private const string kBaseInteractFMODPath = "event:/sfx/ui/map transition/exit point click";

	public Unit SpecificUnit => specificUnitRef;

	protected override bool persistentActiveness => turnOffAfterUse;

	public virtual OctDir? actionDir => null;

	public virtual string GetInteractFMODPath()
	{
		return "event:/sfx/ui/map transition/exit point click";
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		BoxCollider[] componentsInChildren = base.transform.GetComponentsInChildren<BoxCollider>(includeInactive: true);
		List<BoxCollider> list = new List<BoxCollider>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i].transform.parent == base.transform && componentsInChildren[i].name.StartsWith("TriggerVolume"))
			{
				list.Add(componentsInChildren[i]);
			}
		}
		trigVolumes = new BoxCollider[list.Count][];
		for (int j = 0; j < list.Count; j++)
		{
			BoxCollider[] array = new BoxCollider[3];
			BoxCollider boxCollider = list[j];
			string text = boxCollider.name;
			trigVolumes[j] = array;
			array[0] = boxCollider;
			array[1] = UnityEngine.Object.Instantiate(boxCollider, base.transform);
			array[2] = UnityEngine.Object.Instantiate(boxCollider, base.transform);
			array[0].gameObject.layer = 12;
			array[1].gameObject.layer = 13;
			array[2].gameObject.layer = 14;
			array[0].gameObject.name = text + " (StateRPG)";
			array[1].gameObject.name = text + " (StateCombat)";
			array[2].gameObject.name = text + " (StateStealth)";
		}
		_SetTriggerVolumesActive(value: true);
	}

	public override void OnMissionStart()
	{
		base.OnMissionStart();
		if (!string.IsNullOrEmpty(specificUnitID))
		{
			specificUnitRef = GC.Inst.GetUnitWithId(specificUnitID);
		}
		if (!turnOffAfterUse)
		{
		}
	}

	public override void OnFocusEnter()
	{
	}

	public HagletYieldTerm StartAction()
	{
		HagletYieldTerm result = PerformAction();
		if (turnOffAfterUse)
		{
			base.gameObject.SetActive(value: false);
			SaveData.mission.tileObjectActives[base.idGenerated] = false;
		}
		return result;
	}

	protected abstract HagletYieldTerm PerformAction();

	private void _SetTriggerSetActive(BoxCollider[] triggerSet, bool value)
	{
		triggerSet[0].gameObject.SetActive(value && (availableIn & GC.State.RPG) != 0);
		triggerSet[1].gameObject.SetActive(value && (availableIn & GC.State.Combat) != 0);
		triggerSet[2].gameObject.SetActive(value && (availableIn & GC.State.Stealth) != 0);
	}

	protected void _SetTriggerVolumesActive(bool value)
	{
		for (int i = 0; i < trigVolumes.Length; i++)
		{
			_SetTriggerSetActive(trigVolumes[i], value);
		}
	}
}
public class TileActionDialog : TileActionBase
{
	[NonSerialized]
	public HagletTrigger OnDialogShow = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnDialogComplete = new HagletTrigger();

	public DialogData dialog;

	public OptionalDirection direction = OptionalDirection.None;

	public bool showSwapMapTile;

	public string speakerId;

	public string overrideDisplayName;

	public string playAnim;

	[Serializer.Exclude]
	private VFXTilesContainer vfxRef = new VFXTilesContainer(new ConstArray<GameObject>(1u), VFXTileController.TileType.Arrow);

	public override OctDir? actionDir
	{
		get
		{
			if (direction == OptionalDirection.None)
			{
				return null;
			}
			return (OctDir)direction;
		}
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
	}

	protected override HagletYieldTerm PerformAction()
	{
		if ((UINarrativeDialog.Inst.IsShown && UINarrativeDialog.Inst.CurrDialogData == dialog) || (UIAmbientSubtitles.Inst.IsShown && UIAmbientSubtitles.Inst.CurrDialogData == dialog) || !base.gameObject.activeSelf)
		{
			return Wait.None;
		}
		Unit unit = null;
		if (!string.IsNullOrEmpty(speakerId))
		{
			unit = GC.Inst.GetUnitWithId(speakerId);
			for (int i = 0; i < dialog.dialogs.Length; i++)
			{
				dialog.dialogs[i].unitRef = unit;
			}
		}
		if (!string.IsNullOrEmpty(playAnim) && unit != null)
		{
			unit.unitModel.Play(playAnim, looping: false, crouched: false, interacting: false, updateIdleOnComplete: true);
		}
		OnDialogShow.Trigger();
		return Singleton<UIFlow>.Inst.DisplayDialog(dialog, OnDialogComplete, overrideDisplayName);
	}

	public bool IsEnabled()
	{
		return base.enabled;
	}

	protected void OnEnable()
	{
		if (map != null && showSwapMapTile && direction != OptionalDirection.None)
		{
			OctDir to = (OctDir)direction;
			map.VFXTiles.TilesInSquareShow(GetCoord(), new v2i(0, 0), vfxRef, Quaternion.AngleAxis(to.AngleCW(OctDir.Right), Vector3.up));
		}
	}

	public virtual void OnDisable()
	{
		if (map != null)
		{
			map.VFXTiles.TilesHide(vfxRef);
		}
	}
}
[RequireComponent(typeof(TileActionBase))]
public class TileActionGiveLoot : TileActionInteraction, TileObjectEvents
{
	[NonSceneAsset]
	[Space]
	public DialogData playDialogOnPickup;

	[Header("Loot Parameters")]
	public ItemStackMeta item;

	public int quantity = 1;

	public bool show3DModel = true;

	private bool pickedUp;

	public string sfxInteractionEventPath;

	[HideInInspector]
	public ItemModel modelInstance;

	private HagletResettable routinePerformAction;

	protected override bool persistentActiveness => true;

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		if (!(item == null))
		{
			routinePerformAction = new HagletResettable(PerformActionRoutine(), null, HagletStepTime.Update, -1, 5);
		}
	}

	protected override HagletYieldTerm PerformAction()
	{
		if (pickedUp)
		{
			return Wait.None;
		}
		Routine.Start(routinePerformAction, MR.Inst.Host, MR.Inst.mainHagisSequence);
		return Wait.None;
	}

	private IEnumerator<HagletYieldTerm> PerformActionRoutine()
	{
		base.PerformAction();
		if (playDialogOnPickup != null)
		{
			yield return HAGIS.DialogShow(playDialogOnPickup);
		}
		yield return Singleton<PC>.Inst.GetLeader().PickupItem(item, quantity, this, sfxInteractionEventPath);
		if (Singleton<PC>.Inst.GetLeader().pickup.itemMeta == null)
		{
			pickedUp = true;
		}
	}

	public new void OnChangedGameState()
	{
		bool active = (availableIn & GC.Inst.GetState()) == GC.Inst.GetState();
		if (modelInstance != null)
		{
			modelInstance.gameObject.SetActive(active);
		}
		_SetTriggerVolumesActive(!GC.Inst.IsInCombatMode());
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		pickedUp = false;
	}
}
public class TileActionHotspot : TileActionBase
{
	[NonSerialized]
	public HagletTrigger OnHotspotShow = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnHotspotComplete = new HagletTrigger();

	public Sprite image;

	public string imageText;

	[TextArea(3, 3)]
	public string descriptionText;

	public TextAlignment descriptionAlignment = TextAlignment.Center;

	public OptionalDirection direction = OptionalDirection.None;

	public DialogData dialog;

	public bool shouldDisableDialogAfterUse = true;

	public override OctDir? actionDir
	{
		get
		{
			if (direction == OptionalDirection.None)
			{
				return null;
			}
			return (OctDir)direction;
		}
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
	}

	protected override HagletYieldTerm PerformAction()
	{
		Singleton<UIC>.Inst.Push<UIHotspot>().SetState(this, imageText, image, descriptionText, descriptionAlignment);
		OnHotspotShow.Trigger();
		Unit teamLeader = Singleton<PC>.Inst.GetTeam().GetTeamLeader();
		teamLeader.PlayBark(BarkTypes.Investigate);
		if (dialog != null)
		{
			UIAmbientSubtitles.Inst.Show(dialog);
			if (shouldDisableDialogAfterUse)
			{
				dialog = null;
			}
		}
		return UIHotspot.Inst.OnComplete;
	}

	public bool IsEnabled()
	{
		return base.enabled;
	}
}
public class TileActionInteraction : TileActionBase, TileObjectEvents
{
	[NonSerialized]
	public HagletTrigger OnTriggered = new HagletTrigger();

	public OptionalDirection direction = OptionalDirection.None;

	public bool showSwapMapTile;

	public string sfxEventPath;

	private v2i coord;

	[Serializer.Exclude]
	private VFXTilesContainer vfxRef = new VFXTilesContainer(new ConstArray<GameObject>(1u), VFXTileController.TileType.Arrow);

	public override OctDir? actionDir
	{
		get
		{
			if (direction == OptionalDirection.None)
			{
				return null;
			}
			return (OctDir)direction;
		}
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		coord = GetCoord();
	}

	protected override HagletYieldTerm PerformAction()
	{
		OnTriggered.Trigger();
		if (!string.IsNullOrEmpty(sfxEventPath))
		{
			AC.Inst.PlayOneShot3D(sfxEventPath, base.transform.position);
		}
		return Wait.None;
	}

	public bool IsEnabled()
	{
		return base.enabled;
	}

	protected virtual void OnEnable()
	{
		if (map != null && showSwapMapTile && direction != OptionalDirection.None)
		{
			OctDir to = (OctDir)direction;
			map.VFXTiles.TilesInSquareShow(coord, new v2i(0, 0), vfxRef, Quaternion.AngleAxis(to.AngleCW(OctDir.Right), Vector3.up));
		}
	}

	public virtual void OnDisable()
	{
		if (map != null)
		{
			map.VFXTiles.TilesHide(vfxRef);
		}
	}

	public void OnChangedGameState()
	{
	}

	public void OnUnitEnterCoord(Unit unit)
	{
	}

	public void OnUnitExitCoord(Unit unit)
	{
	}

	public void OnEnterTurnMode()
	{
	}

	public void OnExitTurnMode()
	{
	}
}
public class TileActionSwapMap : TileActionBase, TileObjectEvents, INPCWaypoint
{
	[NonSceneAsset]
	public LogicSceneMeta targetMap;

	public uint targetSwapTileIndex;

	[HideInInspector]
	public Map targetLinkedMap;

	[Space]
	public uint myIndex;

	[ReadOnly]
	public v2i coord;

	public OctDir exitDirection;

	public KubrickAnimatorAndClip mapAnimationOnEnter;

	public KubrickAnimatorAndClip mapAnimationOnExit;

	public bool isWanderable = true;

	public bool hideSwapVfx;

	private const string uiRootPath = "UI/P_UIMapSwapTileRoot";

	[Serializer.Exclude]
	private UIContainer uiRoot;

	[Serializer.Exclude]
	private VFXTilesContainer vfxRef = new VFXTilesContainer(new ConstArray<GameObject>(1u), VFXTileController.TileType.Arrow);

	public OctDir enterDirection => (OctDir)((int)(exitDirection + 4) % 8);

	public override OctDir? actionDir => exitDirection;

	public bool IsEnabled()
	{
		return base.enabled;
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		GameObject gameObject = LR.LoadPrefabResource("UI/P_UIMapSwapTileRoot", base.transform);
		LR.InitialiseUIHierarchy(gameObject.transform);
		uiRoot = gameObject.GetComponent<UIContainer>();
		TileActionBase component = GetComponent<TileActionBase>();
		coord = component.GetCoord();
		uiRoot.HideAll();
	}

	public TileActionSwapMap GetTargetSwapTile()
	{
		return targetLinkedMap.GetSwapTileAtIndex(targetSwapTileIndex);
	}

	protected override HagletYieldTerm PerformAction()
	{
		if (targetLinkedMap == null)
		{
			return Wait.None;
		}
		UnitTeam team = Singleton<PC>.Inst.GetTeam();
		TileActionSwapMap targetSwapTile = GetTargetSwapTile();
		KubrickAnimatorAndClip? kubrickAnimatorAndClip = ((string.IsNullOrEmpty(mapAnimationOnExit.animator) || string.IsNullOrEmpty(mapAnimationOnExit.clipName)) ? null : new KubrickAnimatorAndClip?(mapAnimationOnExit));
		KubrickAnimatorAndClip? mapEntryAnimation = ((string.IsNullOrEmpty(targetSwapTile.mapAnimationOnEnter.animator) || string.IsNullOrEmpty(targetSwapTile.mapAnimationOnEnter.clipName)) ? null : new KubrickAnimatorAndClip?(targetSwapTile.mapAnimationOnEnter));
		TileActionSwapMap targetSwapTile2 = GetTargetSwapTile();
		KubrickAnimatorAndClip? mapExitAnimation = kubrickAnimatorAndClip;
		return team.TransitionTeamToMap(targetSwapTile2, ignoreMovement: false, mapExitAnimation, mapEntryAnimation);
	}

	private bool ReturnFromPeekButton_OnTapUp()
	{
		HideReturnFromPeekButton();
		Singleton<MC>.Inst.TransitionToMap(targetLinkedMap, null, OnReturnedFromPeek);
		return true;
	}

	private void OnReturnedFromPeek(Map currentMap, Map targetMap)
	{
		Singleton<PC>.Inst.GetLeader().OnExitPeek();
	}

	public void HideReturnFromPeekButton()
	{
		uiRoot.HideAll();
	}

	protected void OnEnable()
	{
		if (map != null && !hideSwapVfx)
		{
			map.VFXTiles.TilesInSquareShow(coord, new v2i(0, 0), vfxRef, Quaternion.AngleAxis(exitDirection.AngleCW(OctDir.Right), Vector3.up));
		}
	}

	public void OnDisable()
	{
		if (map != null)
		{
			map.VFXTiles.TilesHide(vfxRef);
		}
	}

	public void OnUnitEnterCoord(Unit unit)
	{
	}

	public void OnUnitExitCoord(Unit unit)
	{
	}

	public void OnEnterTurnMode()
	{
	}

	public void OnExitTurnMode()
	{
	}

	public void OnChangedGameState()
	{
		if (base.isActiveAndEnabled && (availableIn | GC.Inst.GetState()) == GC.Inst.GetState())
		{
			OnEnable();
		}
		else
		{
			OnDisable();
		}
	}

	public OctDir GetDirection()
	{
		return exitDirection;
	}

	public void PerformNPCAction(Unit npc)
	{
		if (!(targetLinkedMap == null))
		{
			v2i destCoordIn = GetTargetSwapTile().coord;
			Map destMapIn = GetTargetSwapTile().GetMap();
			OctDir? lookDirectionOnTeleportFinished = GetTargetSwapTile().enterDirection;
			npc.StartTeleport(destCoordIn, destMapIn, null, manuallyHandleShowing: false, deactivateForTeleport: false, lookAtDest: false, lookDirectionOnTeleportFinished);
		}
	}

	public bool IsValid()
	{
		return isWanderable && (targetLinkedMap == null || GetTargetSwapTile().map.logicRoot.NPC_Accessible);
	}

	public bool ShouldReserveTile()
	{
		return false;
	}
}
public class TileBlock : TileObjectBase
{
	public const float kNonLargeScale = 0.7f;

	public Height height = Height.Full;

	public bool isLarge = true;
}
public class TileBlockDynamic : TileObjectBase
{
	public const float kNonLargeScale = 0.7f;

	[SerializeField]
	private Height height;

	[SerializeField]
	private bool isLarge;

	public Height BlockHeight
	{
		get
		{
			return height;
		}
		set
		{
			height = value;
			OnPropertyModified();
		}
	}

	public bool IsLarge
	{
		get
		{
			return isLarge;
		}
		set
		{
			isLarge = value;
			OnPropertyModified();
		}
	}

	public override void OnMissionStart()
	{
		UpdateLocalNavData(base.isActiveAndEnabled);
	}

	public override void OnMissionResume()
	{
		UpdateLocalNavData(base.isActiveAndEnabled);
	}

	private void OnEnable()
	{
		if (!(map == null))
		{
			UpdateLocalNavData(isEnabled: true);
		}
	}

	private void OnDisable()
	{
		if (!(map == null))
		{
			UpdateLocalNavData(isEnabled: false);
		}
	}

	private void OnPropertyModified()
	{
		if (base.gameObject.activeInHierarchy)
		{
			v2i coord = GetCoord();
			map.RemoveTileBlock(coord);
			map.AddTileBlock(coord, isLarge, height);
			map.ClearVaultData(coord);
			map.SetVaultData(coord);
		}
	}

	private void UpdateLocalNavData(bool isEnabled)
	{
		if (isEnabled)
		{
			AddTileBlock();
		}
		else
		{
			map.RemoveTileBlock(GetCoord());
		}
	}

	private void AddTileBlock()
	{
		map.AddTileBlock(GetCoord(), IsLarge, BlockHeight);
		map.SetVaultData(GetCoord());
	}
}
public class TileDefaultUnitPosition : TileDirectionalBase
{
	[HideInInspector]
	public bool reservedByUnit;
}
public class TileDirectionalBase : TileObjectBase
{
	public OctDir direction;

	public Quaternion GetRotation()
	{
		return Quaternion.LookRotation(direction.ToV3XZ());
	}
}
public class TileEdgeWall : TileObjectBase
{
	public Height height = Height.Full;

	public float hitChanceBias;
}
public class TileElevation : TileObjectBase
{
	public float height = 0.5f;
}
public class TileLootTrigger : TileTrigger
{
	[Header("Loot Parameters")]
	public ItemStackMeta item;

	private ItemStackMeta prevItem;

	public int quantity = 1;

	public bool show3DModel = true;

	[SerializeField]
	[ReadOnly]
	private ItemModel model3D;

	protected override bool persistentActiveness => true;

	public override void OnMissionSceneLoaded()
	{
		tileVFXType = VFXTileController.TileType.Arrow;
		base.OnMissionSceneLoaded();
		if (!(item == null))
		{
		}
	}

	public override void PerformTrigger(Unit unit)
	{
		base.PerformTrigger(unit);
		unit.PickupItem(item, quantity, this);
	}

	public override void OnChangedGameState()
	{
		base.OnChangedGameState();
	}
}
public class TileNPCWaypoint : TileDirectionalBase, INPCWaypoint
{
	public string EnterAnimation;

	public string EnterToMiddleTransition;

	public float anim_Time_Sec = 1f;

	public bool isLooping;

	public string MiddleAnimation;

	public string MiddleToExitTransition;

	public string ExitAnimation;

	private HagletResettable action;

	private Unit actionNPC;

	public OctDir GetDirection()
	{
		return direction;
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		action = new HagletResettable(actionRoutine(), "NPCWaypointAction", HagletStepTime.Update, -1, 4);
	}

	private IEnumerator<HagletYieldTerm> actionRoutine()
	{
		yield return Wait.ForSeconds(0.5f);
		if (isAnimationValid(EnterAnimation))
		{
			yield return actionNPC.unitModel.PlayAndReturnToIdle(EnterAnimation);
		}
		if (isAnimationValid(EnterToMiddleTransition))
		{
			yield return actionNPC.unitModel.PlayAndReturnToIdle(EnterToMiddleTransition);
		}
		if (isAnimationValid(MiddleAnimation))
		{
			if (isLooping)
			{
				actionNPC.unitModel.Play(MiddleAnimation, looping: true);
				yield return Wait.ForSeconds(anim_Time_Sec);
			}
			else
			{
				yield return actionNPC.unitModel.PlayAndReturnToIdle(MiddleAnimation) & Wait.ForSeconds(anim_Time_Sec);
			}
		}
		else
		{
			yield return Wait.ForSeconds(anim_Time_Sec);
		}
		if (isAnimationValid(MiddleToExitTransition))
		{
			yield return actionNPC.unitModel.PlayAndReturnToIdle(MiddleToExitTransition);
		}
		if (isAnimationValid(ExitAnimation))
		{
			yield return actionNPC.unitModel.PlayAndReturnToIdle(ExitAnimation);
		}
	}

	public void PerformNPCAction(Unit npc)
	{
		actionNPC = npc;
		Routine.Start(action, MR.Inst.Host);
	}

	public bool IsValid()
	{
		return true;
	}

	public bool ShouldReserveTile()
	{
		return true;
	}

	private bool isAnimationValid(string anim)
	{
		if (!string.IsNullOrEmpty(anim) && actionNPC.unitModel.HasAnim(anim) && !actionNPC.unitModel.IsPlayingAnim(anim))
		{
			return true;
		}
		return false;
	}
}
public interface TileObjectEvents
{
	void OnUnitEnterCoord(Unit unit);

	void OnUnitExitCoord(Unit unit);

	void OnEnterTurnMode();

	void OnExitTurnMode();

	void OnChangedGameState();
}
[ExecuteInEditMode]
public abstract class TileObjectBase : MonoBehaviour
{
	public enum Height
	{
		Full = 2,
		Half = 1,
		Zero = 0
	}

	[ReadOnly]
	public string id;

	protected Map map;

	public string idGenerated => id;

	protected virtual bool persistentActiveness => false;

	protected virtual void Awake()
	{
	}

	protected virtual void Start()
	{
	}

	public virtual void OnFocusEnter()
	{
	}

	public virtual void OnFocusExit()
	{
	}

	public bool IsGeneratedIDInvalid()
	{
		return string.IsNullOrEmpty(idGenerated) || idGenerated == "error";
	}

	public virtual void OnMissionSceneLoaded()
	{
		map = base.gameObject.GetComponentInAscendant<Map>();
	}

	public virtual void OnMissionStart()
	{
		if (persistentActiveness && SaveData.mission.tileObjectActives.TryGetValue(idGenerated, out var value))
		{
			base.gameObject.SetActive(value);
		}
	}

	public virtual void OnMissionResume()
	{
	}

	public Map GetMap()
	{
		return map;
	}

	public void SetMap(Map map)
	{
		this.map = map;
	}

	public v2i GetCoord()
	{
		return map.WorldPosToCoord(base.transform.position);
	}

	public static bool Approx(float a, float b)
	{
		return Mathf.Abs(a - b) < 0.001f;
	}
}
public enum FloorSurface
{
	None,
	Concrete,
	Metal,
	Wood
}
public class TileSurfaceType : TileObjectBase
{
	public FloorSurface surfaceType = FloorSurface.Concrete;

	public v2i size = v2i.one;

	public float GetSurfaceParam()
	{
		return SurfaceToParam(surfaceType);
	}

	public static float SurfaceToParam(FloorSurface surfaceType)
	{
		return (float)surfaceType * 0.1f;
	}
}
public class TileTrapTrigger : TileTrigger
{
	[HideInInspector]
	public GadgetType TrapType;

	public bool discovered;

	private ConstArray<Unit> targets = new ConstArray<Unit>(8u);

	private HagletResettable activateTrap;

	private MeshRenderer meshRenderer;

	private VFXTileContainer trapRadiusVfx;

	private KubrickAnimator trapAnimator;

	public Transform ParentWhenInactive { get; private set; }

	public AbilityImplBase Caster { get; private set; }

	public override bool NonLeadersAllowed => true;

	protected override bool IsUnitTeamTypeForTrigger(UnitTeam.Type tType)
	{
		return teamType != tType;
	}

	public void SetVisability(bool visability)
	{
		if ((bool)meshRenderer)
		{
			meshRenderer.enabled = visability;
		}
		if (visability)
		{
			PlayTrapAnim();
			ShowTiles();
		}
		else
		{
			HideTiles();
		}
	}

	protected override void ShowTiles()
	{
		if ((trapRadiusVfx == null || trapRadiusVfx.tile == null) && Caster != null && Caster.owner.teamType == UnitTeam.Type.Player && visibleInGame && map != null)
		{
			VFXTileController.TileType type = VFXTileController.TileType.DangerZone3;
			if (size.x > 1)
			{
				type = VFXTileController.TileType.DangerZone5;
			}
			trapRadiusVfx = map.VFXTiles.TileShow(GetCoord(), type);
		}
	}

	protected override void HideTiles()
	{
		if (trapRadiusVfx != null && trapRadiusVfx.tile != null && map != null)
		{
			map.VFXTiles.TileHide(trapRadiusVfx);
		}
	}

	public void InitialiseTrap(Transform parentWhenInactive, AbilityImplBase caster)
	{
		trapAnimator = GetComponentInChildren<KubrickAnimator>(includeInactive: true);
		OnMissionSceneLoaded();
		meshRenderer = GetComponentInChildren<MeshRenderer>(includeInactive: true);
		if (!GC.Inst.IsInMultiplayer())
		{
			teamType = ((caster.owner.teamType == UnitTeam.Type.Player) ? UnitTeam.Type.Enemy : UnitTeam.Type.Player);
		}
		else
		{
			teamType = ((caster.owner.teamType == UnitTeam.Type.Player) ? UnitTeam.Type.Opponent : UnitTeam.Type.Player);
		}
		circle = true;
		triggersInState = GC.State.Combat | GC.State.Stealth;
		visibleInGame = true;
		base.transform.SetParent(parentWhenInactive);
		cancelPathOnEnter = false;
		base.gameObject.SetActive(value: false);
		activateTrap = new HagletResettable(ActivateTrapRoutine(), string.Concat("Activate ", TrapType, " Trap"));
		ParentWhenInactive = parentWhenInactive;
		Caster = caster;
	}

	public override void PerformTrigger(Unit unit)
	{
		if (TrapType == GadgetType.FLUX)
		{
			bool flag = false;
			int num = unitsInTrigger.sLength;
			while (--num >= 0)
			{
				if (unitsInTrigger[num].charData.hackable)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		base.PerformTrigger(unit);
		Routine.Start(activateTrap, MR.Inst.Host);
		unit.PauseMovement(activateTrap);
		unit.StopMovement();
	}

	private IEnumerator<HagletYieldTerm> ActivateTrapRoutine()
	{
		for (int i = 0; i < unitsInTrigger.Length; i++)
		{
			unitsInTrigger[i].popupBar.Enqueue(GetTriggeredText());
		}
		string beepSFX = "event:/sfx/character/common/attack/grenade beep";
		AC.Inst.PlayOneShot2D(beepSFX);
		yield return Wait.ForSeconds(0.5f);
		v2i coord = GetCoord();
		targets.Clear();
		v2i worldPoint = coord;
		float radius = base.CircleSize;
		ConstArray<Unit> unitArrayToFill = targets;
		bool hackableUnitsOnly = TrapType == GadgetType.FLUX;
		Unit.GatherUnitsInRadius(worldPoint, radius, unitArrayToFill, 4294967279u, includeNPCs: false, hackableUnitsOnly);
		GC.Inst.ActivateGadget(isTrap: true, TrapType, coord, targets, Caster);
		yield return Wait.ForSeconds(1.25f);
		map.RemoveTrap(this);
		yield return null;
	}

	private string GetTriggeredText()
	{
		return TrapType switch
		{
			GadgetType.FRAG => "POPUPBAR_TRIGGEREDTRAP_FRAG", 
			GadgetType.STUN => "POPUPBAR_TRIGGEREDTRAP_STUN", 
			GadgetType.FLUX => "POPUPBAR_TRIGGEREDTRAP_FLUX", 
			_ => "POPUPBAR_TRIGGEREDTRAP_FRAG", 
		};
	}

	public void PlayTrapAnim()
	{
		if ((bool)trapAnimator)
		{
			trapAnimator.Play("SM_TrapAnim_01@MA_TrapAnim_01_Spawn");
		}
	}
}
public class TileTrigger : TileObjectBase, TileObjectEvents
{
	[NonSerialized]
	public HagletTrigger _OnTriggered = new HagletTrigger();

	public UnitTeam.Type teamType;

	[HideInInspector]
	public bool requiresWholeTeam;

	[HideInInspector]
	public string specificItemRequired;

	public string specificUnitRequired;

	private Unit specificUnitRef;

	public int numUnitsRequired = 1;

	public v2i size = v2i.one;

	public bool visibleInGame;

	public OctDir visibleInGameSpriteDirection;

	public bool cancelPathOnEnter = true;

	public bool circle;

	public bool singleUse = true;

	[EnumFlagsField]
	public GC.State triggersInState = GC.State.RPG | GC.State.Combat | GC.State.Stealth;

	private int numUnitsInTrigger;

	protected ConstArray<Unit> unitsInTrigger = new ConstArray<Unit>(16u);

	[Serializer.Exclude]
	private VFXTilesContainer vfxCache;

	protected VFXTileController.TileType tileVFXType = VFXTileController.TileType.TriggerDefault;

	private readonly Quaternion rotation90Y = Quaternion.Euler(0f, -90f, 0f);

	public virtual bool NonLeadersAllowed => false;

	public int CircleSize => (size.x <= size.y) ? size.y : size.x;

	protected virtual bool IsUnitTeamTypeForTrigger(UnitTeam.Type tType)
	{
		return teamType == tType;
	}

	public override void OnMissionSceneLoaded()
	{
		base.OnMissionSceneLoaded();
		vfxCache = new VFXTilesContainer(new ConstArray<GameObject>(32u), tileVFXType);
	}

	public override void OnMissionStart()
	{
		base.OnMissionStart();
		if (!string.IsNullOrEmpty(specificUnitRequired))
		{
			specificUnitRef = GC.Inst.GetUnitWithId(specificUnitRequired);
		}
	}

	private void OnEnable()
	{
		ShowTiles();
	}

	private void OnDisable()
	{
		HideTiles();
	}

	protected virtual void ShowTiles()
	{
		if (visibleInGame && map != null)
		{
			if (circle)
			{
				map.VFXTiles.TilesInRadiusShow(GetCoord(), CircleSize, vfxCache);
			}
			else
			{
				map.VFXTiles.TilesInSquareShow(GetCoord(), size, vfxCache, rotation90Y * Quaternion.LookRotation(visibleInGameSpriteDirection.ToV3XZ()));
			}
		}
	}

	protected virtual void HideTiles()
	{
		if (map != null)
		{
			map.VFXTiles.TilesHide(vfxCache);
		}
	}

	public void OnUnitEnterCoord(Unit unit)
	{
		UpdateUnit(unit, isUnitEnteringTile: true);
	}

	public void OnUnitExitCoord(Unit unit)
	{
		UpdateUnit(unit, isUnitEnteringTile: false);
	}

	public void UpdateUnit(Unit unit, bool isUnitEnteringTile)
	{
		bool flag = UnitShouldTrigger(unit);
		if (flag)
		{
			if (!unitsInTrigger.Contains(unit))
			{
				numUnitsInTrigger++;
				unitsInTrigger.Add(unit);
			}
		}
		else if (unitsInTrigger.Contains(unit))
		{
			unitsInTrigger.Remove(unit);
			numUnitsInTrigger--;
		}
		if (requiresWholeTeam)
		{
			numUnitsRequired = (int)GC.Inst.GetTeamOfType(teamType).GetActiveMembers().Length;
		}
		int num = Mathf.Min(numUnitsRequired, (int)GC.Inst.GetTeamOfType(teamType).GetActiveMembers().Length);
		if (!base.enabled || !base.gameObject.activeInHierarchy || !flag || numUnitsInTrigger < num || !isUnitEnteringTile)
		{
			return;
		}
		if (cancelPathOnEnter && base.gameObject.activeInHierarchy)
		{
			unit.StopMovement(immediate: true);
			if (GC.Inst.GetState() == GC.State.RPG && unit.GetTeam().GetTeamLeader() == unit && map.logicRoot.CanTeammatesFollow)
			{
				ConstArray<Unit> activeMembers = unit.GetTeam().GetActiveMembers();
				for (int i = 0; i < activeMembers.Length; i++)
				{
					if (activeMembers[i] != unit && activeMembers[i].map == unit.map)
					{
						TileDefaultUnitPosition closestDefaultUnitPositions = map.GetClosestDefaultUnitPositions(activeMembers[i].coord);
						if (closestDefaultUnitPositions != null)
						{
							activeMembers[i].StopMovement(immediate: true);
							Unit unit2 = activeMembers[i];
							v2i? destCoord = closestDefaultUnitPositions.GetCoord();
							OctDir? endFacing = closestDefaultUnitPositions.direction;
							unit2.StartMovement(destCoord, null, null, endFacing, 0, Unit.IfTooFar.IgnoreLimits, ignoreOverwatch: false, orientateAlongPath: true, updateIdleOnCompletion: true, TransitionAnim.InOut, null, null, Unit.VaultAllowed.AskUnit, ignoreUnitAtDestination: false, null, ignoreShortMovementAnim: false, avoidUnits: true);
						}
					}
				}
			}
		}
		PerformTrigger(unit);
	}

	public Unit GetAnyUnitInTrigger()
	{
		if (unitsInTrigger.Length != 0)
		{
			return unitsInTrigger[0];
		}
		return null;
	}

	public virtual void PerformTrigger(Unit unit)
	{
		_OnTriggered.Trigger();
		if (singleUse)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private bool UnitShouldTrigger(Unit unit)
	{
		if ((triggersInState & GC.Inst.GetState()) != GC.Inst.GetState())
		{
			return false;
		}
		if (!circle)
		{
			v2i coord = GetCoord();
			int num = coord.x - size.x;
			int num2 = coord.x + size.x;
			int num3 = coord.y - size.y;
			int num4 = coord.y + size.y;
			v2i coord2 = unit.coord;
			if (coord2.x < num || coord2.x > num2 || coord2.y < num3 || coord2.y > num4)
			{
				return false;
			}
		}
		else if (v2i.Distance(unit.coord, GetCoord()) > (float)CircleSize)
		{
			return false;
		}
		if (!unit.IsAlive())
		{
			return false;
		}
		if (!IsUnitTeamTypeForTrigger(unit.teamType))
		{
			return false;
		}
		if (!NonLeadersAllowed && unit != GC.Inst.GetTeamOfType(unit.teamType).GetTeamLeader())
		{
			return false;
		}
		if (specificUnitRef != null && specificUnitRef != unit)
		{
			return false;
		}
		if (!string.IsNullOrEmpty(specificItemRequired))
		{
			if (unit.HeldItem == null)
			{
				return false;
			}
			if (unit.HeldItem.name != specificItemRequired)
			{
				return false;
			}
		}
		return true;
	}

	public void OnEnterTurnMode()
	{
	}

	public void OnExitTurnMode()
	{
	}

	public virtual void OnChangedGameState()
	{
		if (base.isActiveAndEnabled && (triggersInState & GC.Inst.GetState()) == GC.Inst.GetState())
		{
			ShowTiles();
		}
		else
		{
			HideTiles();
		}
	}
}
public class AreaTile : MonoBehaviour
{
}
public class DangerZonePulse : MonoBehaviour, VFXTileEvents
{
	private SpriteRenderer tile;

	private HagletResettable animDriver;

	public void OnAwakeLR()
	{
		tile = GetComponentInChildren<SpriteRenderer>();
		animDriver = new HagletResettable(AnimRoutine(), "DangerZonePulse");
	}

	public void OnEnable()
	{
		if (animDriver != null)
		{
			if ((bool)animDriver.running)
			{
				animDriver.host.Pause(animDriver);
				animDriver.Reset();
			}
			tile.color = tile.color.RepA(0f);
			MR.Inst.Host.StartTopLevel(animDriver);
		}
	}

	public void OnDisabled()
	{
		if (animDriver != null && (bool)animDriver.running)
		{
			animDriver.host.Pause(animDriver);
			animDriver.Reset();
		}
	}

	private IEnumerator<HagletYieldTerm> AnimRoutine()
	{
		float tStart = Time.time;
		while (true)
		{
			tile.color = tile.color.RepA(Mathf.Sin((Time.time - tStart) * 2f + 4.712389f) * 0.5f + 0.5f);
			yield return null;
		}
	}
}
public class SoundSpam : MonoBehaviour
{
	public GameObject text;

	public GameObject soundTracker;

	public float distance = 2f;

	public string[] workingEvents;

	public string[] oneShots;

	public GameObject loopIndicator;

	public GameObject oneShotIndicator;

	private List<FMOD.Studio.EventInstance> handles = new List<FMOD.Studio.EventInstance>();

	private List<FMOD.Studio.EventInstance> shotHandles = new List<FMOD.Studio.EventInstance>();

	private List<GameObject> loopingIndicators = new List<GameObject>();

	private List<GameObject> oneShotIndicators = new List<GameObject>();

	private float nextUpdate;

	private float rate = 1f;

	private int frames;

	private float fps;

	private int i;

	private void Update()
	{
		FPS();
		if (handles.Count > 0)
		{
			Vector3 vector = new Vector3(Mathf.Cos(Time.time) * distance, 0f, Mathf.Sin(Time.time) * distance);
			vector += Singleton<PC>.Inst.transform.position;
			if ((bool)soundTracker)
			{
				soundTracker.transform.position = vector;
			}
			handles[0].set3DAttributes(vector.to3DAttributes());
		}
		for (i = shotHandles.Count - 1; i >= 0; i--)
		{
			shotHandles[i].getPlaybackState(out var state);
			if (state == PLAYBACK_STATE.STOPPED)
			{
				if (oneShotIndicators.Count > i)
				{
					UnityEngine.Object.Destroy(oneShotIndicators[i]);
					oneShotIndicators.RemoveAt(i);
				}
				shotHandles[i].stop(STOP_MODE.IMMEDIATE);
				shotHandles[i].release();
				shotHandles.RemoveAt(i);
			}
		}
	}

	public IEnumerator AddFootsteps(int amount)
	{
		for (int i = 0; i < amount; i++)
		{
			FMOD.Studio.EventInstance handle = AC.Inst.GetHandle(RandomEvent());
			handles.Add(handle);
			if (handles.Count > 1)
			{
				Vector3 vector = new Vector3(UnityEngine.Random.Range(-4f, 4f), 0.5f, UnityEngine.Random.Range(-4f, 4f));
				handle.set3DAttributes(vector.to3DAttributes());
				if ((bool)loopIndicator)
				{
					loopingIndicators.Add(UnityEngine.Object.Instantiate(loopIndicator, vector, default(Quaternion)));
				}
			}
			handle.start();
			yield return null;
		}
	}

	public IEnumerator AddOneShots(int amount)
	{
		for (int i = 0; i < amount; i++)
		{
			FMOD.Studio.EventInstance handle = AC.Inst.GetHandle(RandomOneShot());
			shotHandles.Add(handle);
			Vector3 vec = new Vector3(UnityEngine.Random.Range(-4f, 4f), 0.5f, UnityEngine.Random.Range(-4f, 4f));
			handle.set3DAttributes(vec.to3DAttributes());
			if ((bool)oneShotIndicator)
			{
				oneShotIndicators.Add(UnityEngine.Object.Instantiate(oneShotIndicator, vec, default(Quaternion)));
			}
			handle.start();
			yield return null;
		}
	}

	private void AddSounds(int amount)
	{
		if (handles.Count == 0)
		{
			amount = 1;
		}
		StartCoroutine("AddFootsteps", amount);
	}

	private void OneShot(int amount)
	{
		StartCoroutine("AddOneShots", amount);
	}

	private void RemoveFootsteps(int amount)
	{
		for (i = 0; i < amount; i++)
		{
			if (handles.Count > 0)
			{
				handles[handles.Count - 1].stop(STOP_MODE.IMMEDIATE);
				handles[handles.Count - 1].release();
				handles.RemoveAt(handles.Count - 1);
				if (loopingIndicators.Count > 0)
				{
					UnityEngine.Object.Destroy(loopingIndicators[loopingIndicators.Count - 1]);
					loopingIndicators.RemoveAt(loopingIndicators.Count - 1);
				}
			}
		}
	}

	private string RandomEvent()
	{
		return workingEvents[UnityEngine.Random.Range(0, workingEvents.Length)];
	}

	private string RandomOneShot()
	{
		return oneShots[UnityEngine.Random.Range(0, oneShots.Length)];
	}

	private void FPS()
	{
		frames++;
		nextUpdate += Time.deltaTime;
		if (nextUpdate > rate)
		{
			nextUpdate -= rate;
			fps = Mathf.Round((float)frames / rate);
			frames = 0;
		}
		if (text != null)
		{
			text.GetComponent<TextMesh>().text = "Orbit distance: " + distance + "  Sounds: " + (handles.Count + shotHandles.Count) + "  FPS: " + fps;
		}
	}
}
public class SoundTrigger : MonoBehaviour
{
	public SoundSpam spamScript;

	public string message = "AddSounds";

	public int amount = 10;

	private void OnMouseDown()
	{
		spamScript.SendMessage(message, amount);
	}
}
public class UISoundDebug : UIContainer
{
	private List<FMOD.Studio.EventInstance> handles = new List<FMOD.Studio.EventInstance>();

	private FMOD.Studio.EventInstance PlaySound(string name)
	{
		FMOD.Studio.EventInstance handle = AC.Inst.GetHandle(name);
		handle.start();
		return handle;
	}

	public override void OnAwakeLR()
	{
		GetElement<UIButton>("Comp10").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - comp sound 10"));
			return true;
		};
		GetElement<UIButton>("Comp10FX").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - comp sound 10"));
			return true;
		};
		GetElement<UIButton>("Comp5").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - comp sound 5"));
			return true;
		};
		GetElement<UIButton>("Comp5FX").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - comp sound 5 fx"));
			return true;
		};
		GetElement<UIButton>("Conv").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - conv reverb only"));
			return true;
		};
		GetElement<UIButton>("Scatter").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - scatter"));
			return true;
		};
		GetElement<UIButton>("SpatLoop").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - spatializer loop"));
			return true;
		};
		GetElement<UIButton>("SpatOneshot").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - spatializer one shot"));
			return true;
		};
		GetElement<UIButton>("OneshotFX").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - one shot fx"));
			return true;
		};
		GetElement<UIButton>("LoopFX").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - loop fx"));
			return true;
		};
		GetElement<UIButton>("StandardLoop").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - standard loop"));
			return true;
		};
		GetElement<UIButton>("StandardOneshot").OnTapUp += delegate
		{
			handles.Add(PlaySound("event:/Experiments/Test - standard one shot"));
			return true;
		};
		GetElement<UIButton>("KILL").OnTapUp += delegate
		{
			foreach (FMOD.Studio.EventInstance handle in handles)
			{
				handle.stop(STOP_MODE.IMMEDIATE);
				handle.release();
			}
			handles.Clear();
			return true;
		};
	}

	private void Update()
	{
		float time = Time.time;
		Vector3 vector = Singleton<CC>.Inst.transform.position + new Vector3(Mathf.Sin(time), 0f, Mathf.Cos(time)) * 2f;
		UnityEngine.Debug.DrawRay(vector, Vector3.up, Color.red);
		foreach (FMOD.Studio.EventInstance handle in handles)
		{
			handle.set3DAttributes(vector.to3DAttributes());
		}
	}
}
public class VolumeDrag : MonoBehaviour
{
	public float distance = 2f;

	public SoundSpam spamScript;

	private void OnMouseDown()
	{
		distance = 1f + distance % 5f;
		spamScript.distance = distance;
	}
}
public class DialogData : AEScriptableResource
{
	[Serializable]
	public class CharDataToStringDict : SerialisableDictionary<CharacterData, string>
	{
	}

	public enum DialogType
	{
		Simple,
		Question,
		Response
	}

	public enum LeaderType
	{
		None,
		Leader,
		SubLeader,
		FirstAvailableOrSkip
	}

	public enum DisplayPosition
	{
		UpperUpperPos,
		UpperPos,
		MiddlePos,
		LowerPos
	}

	[Serializable]
	public class Dialog
	{
		public DialogType type;

		public bool foldout;

		public LeaderType leaderType;

		public string animationName;

		public string sfxPath;

		public string musicPath;

		public MusicController.MusicParameters musicParameter;

		public float musicParameterValue;

		public CharacterData characterReference;

		public DialogExpression expression;

		public string unitId;

		public string roomObjectName;

		public string bodyKey;

		public float bufferTime = 0.2f;

		public float subtitleTime = 1.8f;

		public CharDataToStringDict altBodyKeysByCharacter;

		[NonSerialized]
		public Unit unitRef;

		[NonSerialized]
		public Transform roomObjectRef;

		[TextArea(3, 4)]
		public string body;

		public string answer0Key;

		public string answer1Key;

		public string answer2Key;

		public string answer0;

		public string answer1;

		public string answer2;

		public uint response0lineSuccess = 1u;

		public uint response1lineSuccess = 2u;

		public uint response2lineSuccess = 3u;

		public uint responseLine;

		public bool storeResponse;

		public bool answer0Honest;

		public bool answer1Honest;

		public int answerWeighting = 1;

		public DisplayPosition displayPos = DisplayPosition.UpperPos;

		public DC.GameSection gameSection;

		public void OnShow(bool dontReturnToIdle = false)
		{
			if (unitRef != null)
			{
				if (!string.IsNullOrEmpty(animationName))
				{
					if (dontReturnToIdle)
					{
						unitRef.unitModel.Play(animationName);
					}
					else
					{
						unitRef.unitModel.PlayAndReturnToIdle(animationName);
					}
				}
			}
			else if (string.IsNullOrEmpty(animationName))
			{
			}
			if (!string.IsNullOrEmpty(sfxPath))
			{
				AC.Inst.PlayOneShot2D(sfxPath);
			}
			if (!string.IsNullOrEmpty(musicPath))
			{
				if (musicPath == "[STOP]")
				{
					MusicController.Inst.Stop();
				}
				else
				{
					MusicController.Inst.Play(musicPath, 0f, 0f);
				}
			}
		}

		public bool GetCharacterData(out CharacterData cData, ref Unit HACK_unitRef)
		{
			cData = characterReference;
			if (leaderType == LeaderType.Leader)
			{
				PartyMember partyLeader = Party.Inst.GetPartyLeader();
				if (partyLeader != null)
				{
					cData = partyLeader.characterData;
				}
			}
			else if (leaderType == LeaderType.SubLeader)
			{
				PartyMember partySubleader = Party.Inst.GetPartySubleader();
				if (partySubleader != null)
				{
					cData = partySubleader.characterData;
				}
			}
			else if (leaderType == LeaderType.FirstAvailableOrSkip)
			{
				ConstArray<Unit> unitsActive = GC.Inst.GetUnitsActive();
				for (int i = 0; i < unitsActive.Length; i++)
				{
					Unit unit = unitsActive[i];
					CharacterData charData = unit.charData;
					if (charData == characterReference || altBodyKeysByCharacter.dict.ContainsKey(charData))
					{
						cData = charData;
						if (!HACK_unitRef)
						{
							HACK_unitRef = unit;
						}
						return true;
					}
				}
				return false;
			}
			return true;
		}

		public string GetBodyKey()
		{
			Unit HACK_unitRef = null;
			string value = string.Empty;
			GetCharacterData(out var cData, ref HACK_unitRef);
			if (cData != null && altBodyKeysByCharacter != null && altBodyKeysByCharacter.dict != null && altBodyKeysByCharacter.dict.TryGetValue(cData, out value))
			{
				return value;
			}
			return bodyKey;
		}
	}

	public enum Type
	{
		Dialog,
		Player,
		Phone,
		Ambient
	}

	[NonSerialized]
	public HagletTrigger OnAnswer0 = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnAnswer1 = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnAnswer2 = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnComplete = new HagletTrigger();

	public string path;

	public Type type;

	public bool showTapToContinue;

	public Dialog[] dialogs;

	[NonSerialized]
	public uint currentResponseLine;

	[NonSerialized]
	public bool completed;

	public void Prepare()
	{
		completed = false;
		for (uint num = 0u; num < dialogs.Length; num++)
		{
			Dialog dialog = dialogs[num];
			if (!string.IsNullOrEmpty(dialog.unitId))
			{
				dialog.unitRef = GC.Inst.GetUnitWithId(dialog.unitId);
				if (dialog.characterReference == null)
				{
					dialog.characterReference = dialog.unitRef.charData;
				}
			}
			if (!string.IsNullOrEmpty(dialog.roomObjectName))
			{
				dialog.roomObjectRef = RR.Inst.GetRoomAudioSource(dialog.roomObjectName);
				if ((bool)dialog.roomObjectRef)
				{
				}
			}
		}
	}

	public void SetCharacterAtDialogIndex(Unit unit, int index)
	{
		dialogs[index].characterReference = unit.charData;
		dialogs[index].unitRef = unit;
	}
}
public class UITutorialGroup_GlossaryAbilityWheel : UITutorialGroup
{
	private static UITutorialGroup_GlossaryAbilityWheel _instance;

	public static UITutorialGroup_GlossaryAbilityWheel Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryActionGauge : UITutorialGroup
{
	private static UITutorialGroup_GlossaryActionGauge _instance;

	public static UITutorialGroup_GlossaryActionGauge Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryCombatBar : UITutorialGroup
{
	private static UITutorialGroup_GlossaryCombatBar _instance;

	public static UITutorialGroup_GlossaryCombatBar Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryCursorIcons : UITutorialGroup
{
	private static UITutorialGroup_GlossaryCursorIcons _instance;

	public static UITutorialGroup_GlossaryCursorIcons Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryInstallingAugments : UITutorialGroup
{
	private static UITutorialGroup_GlossaryInstallingAugments _instance;

	public static UITutorialGroup_GlossaryInstallingAugments Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryItemsCurrency : UITutorialGroup
{
	private static UITutorialGroup_GlossaryItemsCurrency _instance;

	public static UITutorialGroup_GlossaryItemsCurrency Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_GlossaryStatusEffects : UITutorialGroup
{
	private static UITutorialGroup_GlossaryStatusEffects _instance;

	public static UITutorialGroup_GlossaryStatusEffects Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameAbilityGaugeOverride : UITutorialGroup
{
	private static UITutorialGroup_InGameAbilityGaugeOverride _instance;

	public static UITutorialGroup_InGameAbilityGaugeOverride Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameAbilityGaugeReact : UITutorialGroup
{
	private static UITutorialGroup_InGameAbilityGaugeReact _instance;

	public static UITutorialGroup_InGameAbilityGaugeReact Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameAbilityGaugeStun : UITutorialGroup
{
	private static UITutorialGroup_InGameAbilityGaugeStun _instance;

	public static UITutorialGroup_InGameAbilityGaugeStun Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameAbilityGaugeV1 : UITutorialGroup
{
	private static UITutorialGroup_InGameAbilityGaugeV1 _instance;

	public static UITutorialGroup_InGameAbilityGaugeV1 Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameAbilityWheel : UITutorialGroup
{
	private static UITutorialGroup_InGameAbilityWheel _instance;

	public static UITutorialGroup_InGameAbilityWheel Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameCombatBar : UITutorialGroup
{
	private static UITutorialGroup_InGameCombatBar _instance;

	public static UITutorialGroup_InGameCombatBar Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameEffectSpinner : UITutorialGroup
{
	private static UITutorialGroup_InGameEffectSpinner _instance;

	public static UITutorialGroup_InGameEffectSpinner Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameFlanking : UITutorialGroup
{
	private static UITutorialGroup_InGameFlanking _instance;

	public static UITutorialGroup_InGameFlanking Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UITutorialGroup_InGameStatusEffects : UITutorialGroup
{
	private static UITutorialGroup_InGameStatusEffects _instance;

	public static UITutorialGroup_InGameStatusEffects Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}
}
public class UIAbilityChoice : UIContainer
{
	private static UIAbilityChoice _instance;

	[NonSerialized]
	public HagletTrigger OnOptionOneSelected = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnOptionTwoSelected = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnOptionSelected = new HagletTrigger();

	public static UIAbilityChoice Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		HideAll();
	}

	private void OptionOneSelected()
	{
		OnOptionSelected.Trigger();
		GC.Inst.CutsceneEnd();
		HideAll();
	}

	private void OptionTwoSelected()
	{
		OnOptionSelected.Trigger();
		GC.Inst.CutsceneEnd();
		HideAll();
	}
}
public struct UIAbilityWheelChoice
{
	public AbilityImplBase ability;

	public int subAbilityIdx;

	public void Reset()
	{
		ability = null;
		subAbilityIdx = 0;
	}
}
public class UIAbilityWheel : UIContainer
{
	private class TreeContainer
	{
		public UIContainer container;

		public AbilityButton[] buttons;

		public int numIconsShown;

		public UIImage background1;

		public UIImage background2;

		public UIImage background3;
	}

	private class AbilityButton
	{
		public UIContainer buttonRoot;

		public UIContainer buttonContainer;

		public UIContainer arrowContainer;

		public UIContainer quantityContainer;

		public TreeContainer tree;

		public UIImage abilityBackground;

		public UIImage imageSelected;

		public UIImage imageSelectedGlow;

		public UIImage imageUnselected;

		public UIImage imageSelectedOverloaded;

		public UIImage imageUnselectedOverloaded;

		public UIImage imageDisabledOverloaded;

		public UIImage imageDisabled;

		public UIImage abilityDisabledIcon;

		public UIImage arrowSelected;

		public UIImage arrowUnselected;

		public UIImage arrowDisabled;

		public UIImage quantityEnabled;

		public UIImage quantityDisabled;

		public UITextbox quantityText;

		public UIElement arrowCollider;

		public UIButton button;

		public UIImage icon;

		public AbilityImplWrapper wrapper;
	}

	private struct AbilityImplWrapper
	{
		public AbilityImplBase ability;

		public AbilityMeta meta;

		public AbilityWheelVisibility availability;

		public int idx;

		public int idxTree;

		public int idxSubAbility;
	}

	private struct MapAbility
	{
		public int arrayIndex;

		public int wheelIndex;

		public TileActionSwapMap tile;

		public string name;
	}

	private static UIAbilityWheel _instance;

	private Transform root;

	private UIContainer rootContainer;

	private UIContainer wheelContainer;

	private UIContainer buttonsContainer;

	private UIContainer descriptionContainer;

	private HagletResettable showAllRoutine;

	public HagletTrigger OnAbilitySelected = new HagletTrigger();

	public HagletTrigger OnCancelled = new HagletTrigger();

	private Unit leader;

	private Wrapper<UIAbilityWheelChoice> choice;

	private ConstArray<AbilityImplBase> abilitiesOnWheel = new ConstArray<AbilityImplBase>(12u);

	private AnimFloatHaglet[] buttonAnimators;

	private UITextbox abilityNameTextbox;

	private UITextbox disabledAbilityNameTextbox;

	private UITextbox apCostTextbox;

	private UITextbox disabledReasonTextbox;

	private UITextbox abilityDescriptionTextbox;

	private Renderer abilityNameRenderer;

	private UIImage abilityDescriptionBox;

	private UIImage imageCooldownIcon;

	private UIButton abilityHelpButton;

	private bool isTreeButtonHighlighted;

	private bool inTreeButtonSelectionMode;

	private Action<object> treeOnFocusEnter;

	private Action<object> treeOnFocusExit;

	private Action<object> abilityOnFocusEnter;

	private Action<object> abilityOnFocusExit;

	private int treeSelectedIdx = -1;

	private UIImage touchIndicator;

	private const float kWheelRadiusMin = 0.02f;

	private const float kWheelRadiusMax = 0.18f;

	private const float kWheelRadiusMaxTree = 0.25f;

	private AbilityButton[] abilityButtons = new AbilityButton[9];

	private float buttonHoverTimer;

	private bool buttonFocused;

	private const float hidePrevDescTime = 2f;

	private const float focusHidePrevDescTime = 0.5f;

	private const float showAbilityDescTime = 3f;

	private const float abilityDescFadeTime = 0.3f;

	private HagletResettable hideDescResettable;

	private AbilityButton lastFocusedButton;

	private bool descVisable;

	private const string enterAbilityName = "Enter";

	private const string peekAbilityName = "Peek";

	public AnimationCurve scaleCurve;

	private MapAbility[] mapAbilities = new MapAbility[2];

	private int abilitySelectedIdx = -1;

	public Sprite DEBUG_enterSprite;

	public Sprite DEBUG_peekSprite;

	public Sprite DEBUG_noAbilityIconSprite;

	public bool HACK_disableDuringTutorial;

	public bool HACK_tutorialMode;

	public static UIAbilityWheel Inst => _instance;

	public bool IsWheelShown => wheelContainer.IsShown;

	public override void Initialise()
	{
		UIContainer component = base.transform.Find("Root/Wheel/Buttons/ButtonRootA").GetComponent<UIContainer>();
		for (int i = 0; i < abilityButtons.Length - 1; i++)
		{
			UIContainer uIContainer = UnityEngine.Object.Instantiate(component);
			uIContainer.transform.SetParent(component.transform.parent, worldPositionStays: false);
			UnityEngine.Object.DestroyImmediate(uIContainer.transform.Find("Tree").gameObject);
			LR.InitialiseUIHierarchy(uIContainer.transform);
		}
		base.Initialise();
	}

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		root = base.transform.GetChild(0);
		rootContainer = root.GetComponent<UIContainer>();
		hideDescResettable = new HagletResettable(hideDescRoutine(), "Hide Desc Routine");
		showAllRoutine = new HagletResettable(ShowAllRoutine(), "AbilityWheel", HagletStepTime.Update, -1, 1);
		wheelContainer = rootContainer.GetContainer("Wheel");
		buttonsContainer = wheelContainer.GetContainer("Buttons");
		UIContainer[] array = buttonsContainer.GetContainers();
		buttonAnimators = new AnimFloatHaglet[abilityButtons.Length];
		for (int i = 0; i < abilityButtons.Length; i++)
		{
			AbilityButton abilityButton = (abilityButtons[i] = new AbilityButton());
			UIContainer buttonRoot = (abilityButton.buttonRoot = array[i]);
			UIContainer uIContainer = (abilityButton.buttonContainer = buttonRoot.GetContainer("Button"));
			UIContainer containerOrNull = buttonRoot.GetContainerOrNull("Tree");
			if ((bool)containerOrNull)
			{
				TreeContainer treeContainer = (abilityButton.tree = new TreeContainer());
				abilityButton.tree.buttons = new AbilityButton[3];
				abilityButton.tree.container = containerOrNull;
				UIContainer[] array2 = containerOrNull.GetContainers();
				treeContainer.background1 = containerOrNull.GetElement<UIImage>("TreeBackground1");
				treeContainer.background2 = containerOrNull.GetElement<UIImage>("TreeBackground2");
				treeContainer.background3 = containerOrNull.GetElement<UIImage>("TreeBackground3");
				for (int j = 0; j < abilityButton.tree.buttons.Length; j++)
				{
					AbilityButton abilityButton2 = (abilityButton.tree.buttons[j] = new AbilityButton());
					UIContainer uIContainer2 = (abilityButton2.buttonContainer = array2[j]);
					abilityButton2.imageSelected = uIContainer2.GetElement<UIImage>("Frame_AbilitySelected");
					abilityButton2.imageSelectedGlow = uIContainer2.GetElement<UIImage>("Frame_AbilitySelected_Glow");
					abilityButton2.imageUnselected = uIContainer2.GetElement<UIImage>("Frame_AbilityUnselected");
					abilityButton2.imageDisabled = uIContainer2.GetElement<UIImage>("Frame_AbilityDisabled");
					abilityButton2.abilityDisabledIcon = uIContainer2.GetElement<UIImage>("AbilityDisabledIcon");
					abilityButton2.button = uIContainer2.GetElement<UIButton>("AbilityIcon");
					abilityButton2.icon = abilityButton2.button.image;
					QuantityPrepare(abilityButton2);
				}
			}
			abilityButton.abilityBackground = uIContainer.GetElement<UIImage>("AbilityBackground");
			abilityButton.imageSelected = uIContainer.GetElement<UIImage>("Frame_AbilitySelected");
			abilityButton.imageSelectedGlow = uIContainer.GetElement<UIImage>("Frame_AbilitySelected_Glow");
			abilityButton.imageUnselected = uIContainer.GetElement<UIImage>("Frame_AbilityUnselected");
			abilityButton.imageSelectedOverloaded = uIContainer.GetElement<UIImage>("Frame_AbilitySelectedOL");
			abilityButton.imageDisabledOverloaded = uIContainer.GetElement<UIImage>("Frame_AbilityDisabledOL");
			abilityButton.imageUnselectedOverloaded = uIContainer.GetElement<UIImage>("Frame_AbilityUnselectedOL");
			abilityButton.imageDisabled = uIContainer.GetElement<UIImage>("Frame_AbilityDisabled");
			abilityButton.abilityDisabledIcon = uIContainer.GetElement<UIImage>("AbilityDisabledIcon");
			UIContainer uIContainer3 = (abilityButton.arrowContainer = buttonRoot.GetContainer("Arrows"));
			abilityButton.arrowSelected = uIContainer3.GetElement<UIImage>("SelectedArrow");
			abilityButton.arrowDisabled = uIContainer3.GetElement<UIImage>("DisabledArrow");
			abilityButton.arrowUnselected = uIContainer3.GetElement<UIImage>("UnselectedArrow");
			abilityButton.arrowCollider = uIContainer3.GetElement<UIElement>("ColliderArrow");
			abilityButton.icon = uIContainer.GetElement<UIImage>("AbilityIcon");
			QuantityPrepare(abilityButton);
			buttonAnimators[i] = new AnimFloatHaglet("UIAbilityWheelButtonAnim", LR.Host, delegate
			{
				buttonRoot.transform.localScale = Vector3.LerpUnclamped(Vector3.zero, Vector3.one, scaleCurve.Evaluate(0f));
			}, delegate(float x)
			{
				buttonRoot.transform.localScale = Vector3.LerpUnclamped(Vector3.zero, Vector3.one, scaleCurve.Evaluate(x));
			});
		}
		touchIndicator = wheelContainer.GetElement<UIImage>("TouchIndicator");
		UIContainer container = wheelContainer.GetContainer("AbilityText");
		abilityNameTextbox = container.GetElement<UITextbox>("AbilityName");
		abilityNameRenderer = abilityNameTextbox.GetComponent<Renderer>();
		apCostTextbox = container.GetElement<UITextbox>("APCostText");
		UIContainer container2 = wheelContainer.GetContainer("DisabledAbilityText");
		disabledAbilityNameTextbox = container2.GetElement<UITextbox>("DisabledAbilityName");
		disabledReasonTextbox = container2.GetElement<UITextbox>("DisabledReasonText");
		imageCooldownIcon = container2.GetElement<UIImage>("CooldownIcon");
		abilityHelpButton = wheelContainer.GetElement<UIButton>("HelpButton");
		descriptionContainer = rootContainer.GetContainer("DescriptionBox");
		abilityDescriptionTextbox = descriptionContainer.GetElement<UITextbox>("Description");
		abilityDescriptionBox = descriptionContainer.GetElement<UIImage>("DescBackground");
		mapAbilities[0].tile = null;
		mapAbilities[0].arrayIndex = 0;
		mapAbilities[0].name = "Enter";
		mapAbilities[1].tile = null;
		mapAbilities[1].arrayIndex = 1;
		mapAbilities[1].name = "Peek";
		treeOnFocusEnter = ButtonTree_OnFocusEnterWithUserData;
		treeOnFocusExit = ButtonTree_OnFocusExitWithUserData;
		abilityOnFocusEnter = ButtonWheel_OnFocusEnterWithUserData;
		abilityOnFocusExit = ButtonAbility_OnFocusExitWithUserData;
	}

	private void QuantityPrepare(AbilityButton aButton)
	{
		UIContainer uIContainer = (aButton.quantityContainer = aButton.buttonContainer.GetContainer("Quantity"));
		aButton.quantityEnabled = uIContainer.GetElement<UIImage>("Enabled");
		aButton.quantityDisabled = uIContainer.GetElement<UIImage>("Disabled");
		aButton.quantityText = uIContainer.GetElement<UITextbox>("Text");
	}

	private void SetupDisabledImage(AbilityButton button, AbilityWheelVisibility availability)
	{
		switch (availability)
		{
		case AbilityWheelVisibility.Enabled:
			button.abilityDisabledIcon.Hide();
			button.icon.alpha = 1f;
			break;
		case AbilityWheelVisibility.Disabled:
		case AbilityWheelVisibility.Cooldown:
			button.abilityDisabledIcon.Show();
			button.icon.alpha = 0.2f;
			break;
		}
	}

	private IEnumerator<HagletYieldTerm> ShowAllRoutine()
	{
		base.ShowAll();
		abilitySelectedIdx = -1;
		AC.Inst.PlayOneShot2D("event:/sfx/ui/combat wheel open");
		for (int i = 0; i < abilityButtons.Length; i++)
		{
			abilityButtons[i].buttonRoot.HideAll();
		}
		abilityNameTextbox.Hide();
		disabledAbilityNameTextbox.Hide();
		apCostTextbox.Hide();
		disabledReasonTextbox.Hide();
		abilityHelpButton.Hide();
		imageCooldownIcon.Hide();
		descriptionContainer.HideAll();
		descVisable = false;
		abilitiesOnWheel.Clear();
		foreach (AbilityImplBase item in leader.abilities.OnUnitAndTeam(skipDisabledAbilities: false))
		{
			if (abilitiesOnWheel.Length >= abilityButtons.Length)
			{
				break;
			}
			if ((!item.IsTeamAbility() || !(leader != item.owner)) && item.IsManuallyActivated())
			{
				AbilityWheelVisibility abilityWheelVisibility = item.IsAvailable(item.owner);
				if ((!HACK_tutorialMode || item.IsAvailableInTutorial()) && abilityWheelVisibility != AbilityWheelVisibility.Hidden)
				{
					abilitiesOnWheel.Add(item);
				}
			}
		}
		for (int j = 1; j < abilitiesOnWheel.Length; j++)
		{
			AbilityImplBase abilityImplBase = abilitiesOnWheel[j];
			if (!ArrayX.IsNullOrEmpty(abilityImplBase.meta.subAbilities))
			{
				AbilityImplBase value = abilitiesOnWheel[0];
				abilitiesOnWheel[0] = abilitiesOnWheel[j];
				abilitiesOnWheel[j] = value;
				break;
			}
		}
		int k = 0;
		for (int num = abilityButtons.Length; k < num; k++)
		{
			if (abilityButtons[k].tree != null)
			{
				int l = 0;
				for (int num2 = abilityButtons[k].tree.buttons.Length; l < num2; l++)
				{
					abilityButtons[k].tree.buttons[l].wrapper.ability = null;
				}
			}
		}
		ExitTreeSelectionMode();
		AbilityButton treeHighlightedButton = GetHighlightedButton();
		if (treeHighlightedButton != null)
		{
			ButtonTree_OnFocusExitWithUserData(treeHighlightedButton.wrapper);
		}
		treeSelectedIdx = -1;
		touchIndicator.Hide();
		for (int m = 0; m < abilitiesOnWheel.Length; m++)
		{
			AbilityImplBase abilityImplBase2 = abilitiesOnWheel[m];
			AbilityButton abilityButton = abilityButtons[m];
			_ = abilityButton.icon.color;
			TreeContainer tree = abilityButton.tree;
			if (tree != null)
			{
				tree.container.HideAll();
				tree.numIconsShown = 0;
				for (int n = 0; n < 3; n++)
				{
					tree.buttons[n].wrapper.ability = null;
				}
			}
			if (!ArrayX.IsNullOrEmpty(abilityImplBase2.meta.subAbilities))
			{
				int num3 = abilityImplBase2.meta.subAbilities.Length;
				if (m == 0 && num3 > 1 && tree != null)
				{
					for (int num4 = 0; num4 < num3; num4++)
					{
						AbilityMeta abilityWheelSubAbilityMetaAtIdx = abilityImplBase2.GetAbilityWheelSubAbilityMetaAtIdx(num4);
						AbilityWheelVisibility abilityWheelSubAbilityIsAvailableAtIdx = abilityImplBase2.GetAbilityWheelSubAbilityIsAvailableAtIdx(num4);
						if (abilityWheelSubAbilityIsAvailableAtIdx != AbilityWheelVisibility.Hidden)
						{
							AbilityButton abilityButton2 = tree.buttons[tree.numIconsShown];
							Sprite icon = abilityWheelSubAbilityMetaAtIdx.Icon;
							abilityButton2.icon.SetImage((!icon) ? DEBUG_noAbilityIconSprite : icon);
							abilityButton2.button.userData = (abilityButton2.wrapper = new AbilityImplWrapper
							{
								ability = abilityImplBase2,
								meta = abilityWheelSubAbilityMetaAtIdx,
								availability = abilityWheelSubAbilityIsAvailableAtIdx,
								idx = m,
								idxTree = tree.numIconsShown,
								idxSubAbility = num4
							});
							tree.numIconsShown++;
						}
					}
				}
			}
			AbilityWheelVisibility availability = abilityImplBase2.IsAvailable(abilityImplBase2.owner);
			SetupDisabledImage(abilityButton, availability);
			AbilityImplWrapper abilityImplWrapper = default(AbilityImplWrapper);
			abilityImplWrapper.ability = abilityImplBase2;
			abilityImplWrapper.meta = abilityImplBase2.meta;
			abilityImplWrapper.availability = availability;
			abilityImplWrapper.idx = m;
			abilityImplWrapper.idxTree = 0;
			abilityImplWrapper.idxSubAbility = 0;
			AbilityImplWrapper wrapper = abilityImplWrapper;
			abilityButton.wrapper = wrapper;
			abilityButton.icon.SetImage((!abilityImplBase2.meta.Icon) ? DEBUG_noAbilityIconSprite : abilityImplBase2.meta.Icon);
			abilityButton.imageSelected.Hide();
			abilityButton.imageSelectedGlow.Hide();
			abilityButton.imageSelectedOverloaded.Hide();
			abilityButton.imageDisabledOverloaded.Hide();
			abilityButton.arrowSelected.Hide();
			abilityButton.arrowCollider.Show();
			abilityButton.arrowUnselected.Show();
			if (abilityImplBase2.IsUpgraded)
			{
				abilityButton.imageUnselected.Hide();
			}
			else
			{
				abilityButton.imageUnselectedOverloaded.Hide();
			}
		}
		float num5 = (float)Math.PI * 2f / (float)abilitiesOnWheel.Length;
		float num6 = 360f / (float)abilitiesOnWheel.Length;
		float num7 = 0.145f;
		for (int num8 = 0; num8 < abilitiesOnWheel.Length; num8++)
		{
			AbilityButton abilityButton3 = abilityButtons[num8];
			Vector3 vector = default(Vector3);
			vector.x = Mathf.Sin(num5 * (float)num8);
			vector.y = Mathf.Cos(num5 * (float)num8);
			Vector3 localPosition = new Vector3(vector.x, vector.y) * num7;
			abilityButton3.buttonContainer.transform.localPosition = localPosition;
			Vector3 euler = new Vector3(0f, 0f, (0f - num6) * (float)num8);
			Quaternion localRotation = Quaternion.Euler(euler);
			abilityButton3.arrowContainer.transform.localRotation = localRotation;
			abilityButton3.abilityBackground.Show();
			abilityButton3.icon.Show();
			if (abilitiesOnWheel[num8].IsUpgraded)
			{
				abilityButton3.imageUnselectedOverloaded.Show();
			}
			else
			{
				abilityButton3.imageUnselected.Show();
			}
			if (abilityButton3.wrapper.ability.meta.subAbilities.Length == 0)
			{
				QuantitySetup(abilityButton3);
			}
			buttonAnimators[num8].Start(1f, 0.25f, UnityEngine.Random.Range(0f, 0.2f));
			if (num8 != 0 || abilityButton3.tree == null)
			{
				continue;
			}
			TreeContainer tree2 = abilityButton3.tree;
			int numIconsShown = abilityButton3.tree.numIconsShown;
			float num9 = 0.062f;
			if (numIconsShown == 2)
			{
				num9 *= 1.5f;
			}
			float num10 = (0.5f * (float)numIconsShown - 0.5f) * num9;
			int num11 = 0;
			for (int num12 = 0; num12 < 3; num12++)
			{
				if (tree2.buttons[num12].wrapper.ability != null)
				{
					float num13 = 0f - num10 + num9 * (float)num11;
					Transform transform = tree2.buttons[num12].buttonContainer.transform;
					transform.localPosition = Vector3.right * num13;
					num11++;
				}
			}
		}
		Vector3 wheelPosStart = leader.unitModel.GetModelBounds().center;
		Vector3 position = Singleton<CC>.Inst.transform.position;
		Vector3 forward = wheelPosStart - position;
		Vector3 wheelPosEnd = position + forward.normalized * UIC.kSafeUIDistance;
		root.rotation = Quaternion.LookRotation(forward, Vector3.up);
		float x = 0f;
		float duration = 0.4f;
		float rotationDelay = 0.2f;
		while (x < duration + rotationDelay)
		{
			float t = x / duration;
			wheelContainer.transform.localScale = Vector3.LerpUnclamped(Vector3.zero, Vector3.one, scaleCurve.Evaluate(t));
			root.position = Vector3.LerpUnclamped(wheelPosStart, wheelPosEnd, scaleCurve.Evaluate(t));
			x += Time.deltaTime;
			yield return null;
		}
	}

	private void ButtonWheel_OnFocusEnterWithUserData(object userData)
	{
		AbilityImplWrapper abilityImplWrapper = (AbilityImplWrapper)userData;
		AbilityImplBase ability = abilityImplWrapper.ability;
		AbilityButton button = abilityButtons[abilityImplWrapper.idx];
		disabledReasonTextbox.Clear();
		AbilityWheelVisibility abilityWheelVisibility = ability.IsAvailable(ability.owner, disabledReasonTextbox);
		Vector3 vector = disabledReasonTextbox.Present(returnSize: true);
		if (abilityWheelVisibility == AbilityWheelVisibility.Cooldown)
		{
			imageCooldownIcon.Show();
			imageCooldownIcon.transform.localPosition = disabledReasonTextbox.transform.localPosition;
			float newVal = (0f - vector.x) / 2f - 0.01f;
			imageCooldownIcon.transform.localPosition = imageCooldownIcon.transform.localPosition.RepX(newVal);
		}
		else
		{
			imageCooldownIcon.Hide();
		}
		ButtonOnFocusEnter(button, ability, abilityWheelVisibility, abilityImplWrapper.meta);
	}

	private void ButtonAbility_OnFocusExitWithUserData(object userData)
	{
		buttonHoverTimer = 0f;
		AbilityImplWrapper abilityImplWrapper = (AbilityImplWrapper)userData;
		AbilityImplBase ability = abilityImplWrapper.ability;
		AbilityButton button = abilityButtons[abilityImplWrapper.idx];
		AbilityWheelVisibility availability = ability.IsAvailable(ability.owner);
		ButtonOnFocusExit(button, ability, availability);
	}

	private void ButtonTree_OnFocusEnterWithUserData(object userData)
	{
		isTreeButtonHighlighted = true;
		AbilityImplWrapper abilityImplWrapper = (AbilityImplWrapper)userData;
		AbilityImplBase ability = abilityImplWrapper.ability;
		AbilityButton abilityButton = abilityButtons[abilityImplWrapper.idx];
		AbilityButton button = abilityButton.tree.buttons[abilityImplWrapper.idxTree];
		disabledReasonTextbox.Clear();
		AbilityWheelVisibility abilityWheelSubAbilityIsAvailableAtIdx = ability.GetAbilityWheelSubAbilityIsAvailableAtIdx(abilityImplWrapper.idxSubAbility, disabledReasonTextbox);
		disabledReasonTextbox.Present();
		ButtonOnFocusEnter(button, ability, abilityWheelSubAbilityIsAvailableAtIdx, abilityImplWrapper.meta);
	}

	private void ButtonTree_OnFocusStayWithUserData(object userData)
	{
		AbilityImplWrapper abilityImplWrapper = (AbilityImplWrapper)userData;
		AbilityImplBase ability = abilityImplWrapper.ability;
		AbilityButton abilityButton = abilityButtons[abilityImplWrapper.idx];
		AbilityButton button = abilityButton.tree.buttons[abilityImplWrapper.idxTree];
		ButtonOnFocusStay(button, ability, abilityImplWrapper.meta, isTree: true);
	}

	private void ButtonTree_OnFocusExitWithUserData(object userData)
	{
		isTreeButtonHighlighted = false;
		buttonHoverTimer = 0f;
		AbilityImplWrapper abilityImplWrapper = (AbilityImplWrapper)userData;
		AbilityImplBase ability = abilityImplWrapper.ability;
		if (ability != null)
		{
			AbilityButton abilityButton = abilityButtons[abilityImplWrapper.idx];
			AbilityButton button = abilityButton.tree.buttons[abilityImplWrapper.idxTree];
			AbilityWheelVisibility abilityWheelSubAbilityIsAvailableAtIdx = ability.GetAbilityWheelSubAbilityIsAvailableAtIdx(abilityImplWrapper.idxSubAbility);
			ButtonOnFocusExit(button, ability, abilityWheelSubAbilityIsAvailableAtIdx);
		}
	}

	private void ButtonOnFocusEnter(AbilityButton button, AbilityImplBase ability, AbilityWheelVisibility availability, AbilityMeta meta)
	{
		switch (availability)
		{
		case AbilityWheelVisibility.Enabled:
			button.icon.color.RepA(0.4f);
			if (ability.IsUpgraded && button.imageSelectedOverloaded != null)
			{
				button.imageSelectedOverloaded.Show();
			}
			else
			{
				button.imageSelected.Show();
			}
			button.imageSelectedGlow.Show();
			if ((bool)button.arrowSelected)
			{
				button.arrowSelected.Show();
			}
			abilityNameTextbox.SetKey(meta.GetDisplayName(ability.owner.charData));
			abilityNameTextbox.Show();
			apCostTextbox.SetKey("UIABILITYWHEEL_APCOST", ability.APCost(ability.owner));
			apCostTextbox.Show();
			disabledAbilityNameTextbox.Hide();
			disabledReasonTextbox.Hide();
			button.imageDisabled.Hide();
			break;
		case AbilityWheelVisibility.Disabled:
		case AbilityWheelVisibility.Cooldown:
			if (ability.IsUpgraded)
			{
				button.imageUnselectedOverloaded.Hide();
				button.imageDisabledOverloaded.Show();
			}
			else
			{
				button.imageUnselected.Hide();
				button.imageDisabled.Show();
			}
			if ((bool)button.arrowDisabled)
			{
				button.arrowDisabled.Show();
			}
			abilityNameTextbox.Hide();
			disabledAbilityNameTextbox.SetKey(meta.GetDisplayName(ability.owner.charData));
			disabledAbilityNameTextbox.Show();
			apCostTextbox.Hide();
			disabledReasonTextbox.Show();
			break;
		}
		if (button.tree != null && availability != AbilityWheelVisibility.Disabled && availability != AbilityWheelVisibility.Cooldown)
		{
			TreeContainer tree = button.tree;
			for (int i = 0; i < tree.numIconsShown; i++)
			{
				AbilityButton abilityButton = tree.buttons[i];
				if (abilityButton.wrapper.ability != null)
				{
					abilityButton.buttonContainer.ShowAll();
					QuantitySetup(abilityButton);
					SetupDisabledImage(abilityButton, ability.GetAbilityWheelSubAbilityIsAvailableAtIdx(abilityButton.wrapper.idxSubAbility));
					abilityButton.imageSelected.Hide();
					abilityButton.imageSelectedGlow.Hide();
				}
			}
			switch (tree.numIconsShown)
			{
			case 1:
				tree.background1.Show();
				break;
			case 2:
				tree.background2.Show();
				break;
			case 3:
				tree.background3.Show();
				break;
			}
		}
		buttonFocused = true;
	}

	private void ButtonOnFocusExit(AbilityButton button, AbilityImplBase ability, AbilityWheelVisibility availability)
	{
		switch (availability)
		{
		case AbilityWheelVisibility.Enabled:
			button.icon.color.RepA(1f);
			if (ability.IsUpgraded && button.imageSelectedOverloaded != null)
			{
				button.imageSelectedOverloaded.Hide();
			}
			else
			{
				button.imageSelected.Hide();
			}
			button.imageSelectedGlow.Hide();
			if ((bool)button.arrowSelected)
			{
				button.arrowSelected.Hide();
			}
			break;
		case AbilityWheelVisibility.Disabled:
		case AbilityWheelVisibility.Cooldown:
			if (wheelContainer.IsShown)
			{
				if (ability.IsUpgraded)
				{
					button.imageDisabledOverloaded.Hide();
					button.imageUnselectedOverloaded.Show();
				}
				else
				{
					button.imageDisabled.Hide();
					button.imageUnselected.Show();
				}
				if ((bool)button.arrowDisabled)
				{
					button.arrowDisabled.Hide();
				}
			}
			break;
		}
		if (button.tree != null)
		{
			button.tree.container.HideAll();
		}
		buttonFocused = false;
		HagletResettable.StartOrReset(hideDescResettable, LR.Host);
	}

	private void ButtonOnFocusStay(AbilityButton button, AbilityImplBase ability, AbilityMeta meta, bool isTree)
	{
		if (buttonHoverTimer < 3f)
		{
			buttonHoverTimer += Time.deltaTime;
		}
		if (buttonHoverTimer >= 0.5f && buttonHoverTimer < 3f && descVisable && lastFocusedButton != button)
		{
			ToggleDescription(visable: false);
		}
		else if (buttonHoverTimer >= 3f && !descVisable && !descriptionContainer.IsShown)
		{
			float num = 7f / 32f;
			if (button.buttonContainer.transform.localPosition.y < 0.01f)
			{
				num = 0f - num;
			}
			if (isTree || treeSelectedIdx != -1)
			{
				num = 43f / 160f;
			}
			Transform transform = descriptionContainer.transform;
			transform.localPosition = transform.localPosition.RepY(num);
			abilityDescriptionTextbox.SetKey((!ability.IsUpgraded) ? meta.description : meta.augmentDescription);
			lastFocusedButton = button;
			ToggleDescription(visable: true);
		}
	}

	private bool ButtonAbility_OnTapUpWithUserData(object userData)
	{
		AbilityImplWrapper wrapper = (AbilityImplWrapper)userData;
		SelectAbility(wrapper);
		return true;
	}

	private void SelectAbility(AbilityImplWrapper wrapper)
	{
		if (wrapper.availability == AbilityWheelVisibility.Enabled)
		{
			AbilityImplBase ability = wrapper.ability;
			choice.val.ability = ability;
			choice.val.subAbilityIdx = wrapper.idxSubAbility;
			choice = null;
			OnAbilitySelected.Trigger();
			Singleton<UIC>.Inst.Pop();
			wrapper.ability.PlayAbilitySelectedSound();
		}
	}

	private AbilityButton GetHighlightedButton()
	{
		if (treeSelectedIdx == -1)
		{
			if (abilitySelectedIdx == -1)
			{
				return null;
			}
			return abilityButtons[abilitySelectedIdx];
		}
		return abilityButtons[0].tree.buttons[treeSelectedIdx];
	}

	public void Update()
	{
		SetTreeButtonAlpha(1f);
		touchIndicator.Hide();
		Crosshair.Inst.SetActive(active: true);
		Vector3 position = IC.Inst.transform.position;
		Vector3 forward = IC.Inst.transform.forward;
		CheckForButtonHit(position, forward);
	}

	private void CheckForButtonHit(Vector3 pos, Vector3 forward)
	{
		if (!new Plane(-root.forward, root.position).Raycast(new Ray(pos, forward), out var enter))
		{
			return;
		}
		float num = 17f;
		float dotThreshold = Mathf.Cos(num * ((float)Math.PI / 180f));
		Vector3 vector = pos + forward * enter;
		AbilityButton highlightedButton = GetHighlightedButton();
		bool flag = !inTreeButtonSelectionMode || (inTreeButtonSelectionMode && treeSelectedIdx != -1);
		if (highlightedButton != null && flag)
		{
			bool isTree = highlightedButton.tree != null && highlightedButton.tree.numIconsShown > 0;
			ButtonOnFocusStay(highlightedButton, highlightedButton.wrapper.ability, highlightedButton.wrapper.meta, isTree);
		}
		Vector3 position = root.position;
		Vector3 lookVec = vector - position;
		for (int i = 0; i < abilitiesOnWheel.Length; i++)
		{
			AbilityButton abilityButton = abilityButtons[i];
			bool isHighlighted = CheckIfButtonIsHighlighted(abilityButton, lookVec, position, dotThreshold, abilityButton.tree != null);
			UpdateButton(isHighlighted, i, ref abilitySelectedIdx, abilityButton, highlightedButton, abilityOnFocusEnter, abilityOnFocusExit);
		}
		position = abilityButtons[0].buttonContainer.transform.position;
		lookVec = vector - position;
		if (abilitySelectedIdx == 0)
		{
			for (int j = 0; j < abilityButtons[0].tree.numIconsShown; j++)
			{
				AbilityButton button = abilityButtons[0].tree.buttons[j];
				bool isHighlighted2 = CheckIfButtonIsHighlighted(button, lookVec, position, dotThreshold, useMaxRadius: true);
				UpdateButton(isHighlighted2, j, ref treeSelectedIdx, button, highlightedButton, treeOnFocusEnter, treeOnFocusExit);
			}
		}
	}

	private bool CheckIfButtonIsHighlighted(AbilityButton button, Vector3 lookVec, Vector3 centerPoint, float dotThreshold, bool useMaxRadius)
	{
		Vector3 position = button.buttonContainer.transform.position;
		Vector3 lhs = Vector3.Normalize(position - centerPoint);
		Vector3 vector = Vector3.Normalize(lookVec);
		float num = Vector3.Dot(lhs, vector);
		float num2 = Vector3.Dot(lhs, lookVec);
		UnityEngine.Debug.DrawRay(centerPoint, vector * 0.1f, Color.green);
		float num3 = ((!useMaxRadius) ? 0.18f : 0.25f);
		bool flag = (num > dotThreshold && num2 > 0.02f && num2 < num3) || (button.tree != null && isTreeButtonHighlighted);
		UnityEngine.Debug.DrawLine(centerPoint, position, (!flag) ? Color.blue : Color.red);
		return flag;
	}

	private static void QuantitySetup(AbilityButton button)
	{
		QuantityInfo quantityInfo = button.wrapper.ability.GetQuantityInfo(button.wrapper.idxSubAbility);
		if (quantityInfo.visible)
		{
			button.quantityContainer.ShowAll();
			if (quantityInfo.amount == 0)
			{
				button.quantityEnabled.Hide();
			}
			else
			{
				button.quantityDisabled.Hide();
			}
			button.quantityText.Clear();
			if (quantityInfo.amount == 0)
			{
				button.quantityText.color = ColorX.RGB(215, 54, 79);
			}
			else
			{
				button.quantityText.color = ColorX.RGB(24, 157, 238);
			}
			if (quantityInfo.amount < 10)
			{
				button.quantityText.Append("0");
			}
			button.quantityText.Append(quantityInfo.amount);
			button.quantityText.Present();
		}
		else
		{
			button.quantityContainer.HideAll();
		}
	}

	private void UpdateButton(bool isHighlighted, int index, ref int currentButtonIndex, AbilityButton button, AbilityButton selectedButton, Action<object> onFocusEnter, Action<object> onFocusExit)
	{
		if (isHighlighted)
		{
			if (index != currentButtonIndex)
			{
				selectedButton = GetHighlightedButton();
				if (selectedButton != null)
				{
					onFocusExit(selectedButton.wrapper);
				}
				onFocusEnter(button.wrapper);
				currentButtonIndex = index;
			}
		}
		else if (index == currentButtonIndex)
		{
			onFocusExit(selectedButton.wrapper);
			currentButtonIndex = -1;
		}
	}

	public override void ShowAll()
	{
		base.ShowAll();
		HagletResettable.StartOrReset(showAllRoutine, LR.Host, prestep: true);
	}

	public override bool HideAll()
	{
		base.HideAll();
		abilitiesOnWheel.Clear();
		base.gameObject.SetActive(value: false);
		if (Crosshair.Inst != null)
		{
			Crosshair.Inst.SetActive(active: true);
		}
		return true;
	}

	public void SetState(Unit leader, Wrapper<UIAbilityWheelChoice> choice)
	{
		this.leader = leader;
		this.choice = choice;
	}

	public override bool OnBackButtonPressed()
	{
		Cancel();
		return true;
	}

	public override void OnActionButtonPressed()
	{
		AbilityButton highlightedButton = GetHighlightedButton();
		if (highlightedButton != null)
		{
			if (highlightedButton.tree == null || highlightedButton.tree.numIconsShown == 0)
			{
				SelectAbility(highlightedButton.wrapper);
			}
			else if (highlightedButton.tree != null && highlightedButton.tree.numIconsShown > 0 && inTreeButtonSelectionMode)
			{
				ExitTreeSelectionMode();
				Cancel();
			}
		}
		else
		{
			Cancel();
		}
	}

	private void SetTreeButtonAlpha(float alpha)
	{
		if (abilityButtons[0].tree.container.GetAlpha() != alpha)
		{
			abilityButtons[0].tree.container.SetAlpha(alpha);
		}
	}

	private void SetAbilityAlphaForTreeMode(float alpha)
	{
		for (int i = 1; i < abilityButtons.Length; i++)
		{
			if (abilityButtons[i].buttonRoot.GetAlpha() != alpha)
			{
				abilityButtons[i].buttonRoot.SetAlpha(alpha);
			}
		}
	}

	private void EnterTreeSelectionMode()
	{
		inTreeButtonSelectionMode = true;
		SetTreeButtonAlpha(1f);
		SetAbilityAlphaForTreeMode(0f);
	}

	private void ExitTreeSelectionMode()
	{
		inTreeButtonSelectionMode = false;
		SetTreeButtonAlpha(0.5f);
		SetAbilityAlphaForTreeMode(1f);
	}

	public override bool ConsumesActionButton()
	{
		return true;
	}

	private void Cancel()
	{
		OnCancelled.Trigger();
		Singleton<UIC>.Inst.Pop();
	}

	public void ToggleDescription(bool visable)
	{
		if (visable != descVisable && visable != descriptionContainer.IsShown)
		{
			if (visable)
			{
				descriptionContainer.ShowAll();
				descriptionContainer.SetAlpha(0f);
			}
			descVisable = visable;
			descriptionContainer.StartFade((!visable) ? 0f : 1f, 0.3f, !visable);
		}
	}

	private IEnumerator<HagletYieldTerm> hideDescRoutine()
	{
		yield return Wait.ForSeconds(2f);
		if (!buttonFocused)
		{
			ToggleDescription(visable: false);
		}
	}

	public void OnMissionUnloaded()
	{
		HACK_disableDuringTutorial = false;
		HACK_tutorialMode = false;
	}
}
[ExecuteInEditMode]
public class UIAlignToTextbox : UIElement
{
	public enum AlignmentX
	{
		None,
		Left,
		Right
	}

	public enum AlignmentY
	{
		None,
		Top,
		Bottom
	}

	public AlignmentX alighmentX;

	public AlignmentY alighmentY;

	public UITextbox target;

	private Renderer targetBounds;

	public Vector2 relativeOffset;

	public override void OnAwakeLR()
	{
		targetBounds = target.GetComponent<Renderer>();
		UITextbox uITextbox = target;
		uITextbox.OnTextPresented = (Action)Delegate.Remove(uITextbox.OnTextPresented, new Action(UpdateLayout));
		UITextbox uITextbox2 = target;
		uITextbox2.OnTextPresented = (Action)Delegate.Combine(uITextbox2.OnTextPresented, new Action(UpdateLayout));
	}

	private Vector3 GetBoundsMinLocal()
	{
		return base.transform.parent.InverseTransformPoint(targetBounds.bounds.min);
	}

	private Vector3 GetBoundsMaxLocal()
	{
		return base.transform.parent.InverseTransformPoint(targetBounds.bounds.max);
	}

	private void UpdateLayout()
	{
		Vector3 localPosition = base.transform.localPosition;
		Vector3 boundsMinLocal = GetBoundsMinLocal();
		Vector3 boundsMaxLocal = GetBoundsMaxLocal();
		if (alighmentX == AlignmentX.Left)
		{
			localPosition.x = boundsMinLocal.x + relativeOffset.x;
		}
		else if (alighmentX == AlignmentX.Right)
		{
			localPosition.x = boundsMaxLocal.x + relativeOffset.x;
		}
		if (alighmentY == AlignmentY.Top)
		{
			localPosition.y = boundsMaxLocal.y + relativeOffset.y;
		}
		else if (alighmentY == AlignmentY.Bottom)
		{
			localPosition.y = boundsMinLocal.y + relativeOffset.y;
		}
		base.transform.localPosition = localPosition;
	}
}
public class UIAmbientSubtitles : UIContainer
{
	[Serializable]
	public class ShowDialog : HagletResettable
	{
		public DialogData dialogData;

		public string message;

		public HagletTrigger finished = new HagletTrigger(1);

		public HagletTrigger OnComplete;

		public string overrideDisplayName;

		public bool dontReturnToIdle;

		public ShowDialog(UIAmbientSubtitles subs)
			: base(subs.ShowDialogRoutine())
		{
		}

		protected ShowDialog(BinaryReader reader)
			: base(reader)
		{
		}

		public void Start(DialogData dialogData = null, string message = null, HagletTrigger OnComplete = null, string overrideDisplayName = null, bool dontReturnToIdle = false)
		{
			this.dialogData = dialogData;
			this.message = message;
			this.OnComplete = OnComplete;
			this.overrideDisplayName = overrideDisplayName;
			this.dontReturnToIdle = dontReturnToIdle;
			if (!MR.Inst || !MR.Inst.IsSkipping())
			{
				if ((bool)running)
				{
					finished.Trigger();
				}
				else if ((bool)MR.Inst && !LR.Inst.MissionIsUnloading)
				{
					MR.Inst.Host.StartTopLevel(this);
				}
				else
				{
					LR.Host.StartTopLevel(this);
				}
			}
		}
	}

	[Serializable]
	public class HighlightUnit : Haglet
	{
		public readonly UIElement circle;

		public float time;

		public float rate;

		private Vector3 originalScale = Vector3.one;

		private Quaternion originalRotation;

		public HighlightUnit(UIAmbientSubtitles subs, float pulseRate)
			: base(subs.HighlightUnitRoutine())
		{
			circle = subs.GetElement<UIElement>("UnitHighlight");
			originalRotation = circle.transform.rotation;
			rate = pulseRate;
		}

		protected HighlightUnit(BinaryReader reader)
			: base(reader)
		{
		}

		public void Start(Unit unit)
		{
			circle.transform.SetParent(unit.unitModel.BlobShadow.transform);
			circle.transform.localPosition = Vector3.zero;
			circle.transform.localRotation = Quaternion.identity;
			CalculateNewScale(0f);
			circle.Show();
			time = 0f;
			if (!running)
			{
				LR.Host.StartTopLevel(this);
			}
		}

		public void PauseHighlight()
		{
			if ((bool)running)
			{
				LR.Host.Pause(this);
			}
			circle.Hide();
			circle.transform.SetParent(Inst.transform);
		}

		public void CalculateNewScale(float step)
		{
			circle.transform.localScale = originalScale * 1.25f * MathfX.SineRemapLerp(step, MathfX.SineRemapEaseType.InOut, 0f, 0.2f, 0.9f, 1.1f) * Mathf.Lerp(0f, 1f, step * 4f);
		}
	}

	public float kMinSubtitleTime = 1.8f;

	private const float kHighlightPulseRate = 0.5f;

	private ShowDialog showDialog;

	private int defaultSortingOrder;

	private const string subsPrefsKey = "subs";

	private bool? _showSubtitles;

	[HideInInspector]
	public UITextbox textboxSubtitles;

	public static UIAmbientSubtitles Inst { get; private set; }

	public HagletEvent finished => showDialog.finished;

	public HagletCondition running => showDialog.running;

	public DialogData CurrDialogData => showDialog.dialogData;

	public HighlightUnit highlightUnit { get; private set; }

	[HideInInspector]
	public bool ShowSubtitles
	{
		get
		{
			if (!_showSubtitles.HasValue)
			{
				_showSubtitles = PlayerPrefsX.GetBool("subs", defaultValue: true);
			}
			return _showSubtitles.Value;
		}
		set
		{
			_showSubtitles = value;
			PlayerPrefsX.SetBool("subs", value);
			if ((bool)running)
			{
				if (_showSubtitles.Value)
				{
					textboxSubtitles.Show();
				}
				else
				{
					textboxSubtitles.Hide();
				}
			}
		}
	}

	public override void OnAwakeLR()
	{
		Inst = this;
		base.OnAwakeLR();
		base.transform.position = Vector3.zero;
		textboxSubtitles = GetElement<UITextbox>("Text");
		HideAll();
		showDialog = new ShowDialog(this);
		defaultSortingOrder = textboxSubtitles.sortingOrder;
	}

	public void OnMissionStart()
	{
		highlightUnit = new HighlightUnit(this, 0.5f);
	}

	public void OnMissionResume()
	{
		ResetHaglets();
	}

	public void OnMissionUnloading()
	{
		highlightUnit.PauseHighlight();
	}

	public void RenderOnTop(bool onTop)
	{
		textboxSubtitles.sortingOrder = ((!onTop) ? defaultSortingOrder : 32767);
		textboxSubtitles.UpdateSortingOrder();
	}

	public override bool HideAll()
	{
		base.HideAll();
		if (showDialog != null)
		{
			ResetHaglets();
		}
		return true;
	}

	public void Show(DialogData dialogData, HagletTrigger OnTriggerComplete = null, string overrideDisplayName = null, bool dontReturnToIdle = false)
	{
		ResetHaglets();
		showDialog.Start(dialogData, null, OnTriggerComplete, overrideDisplayName, dontReturnToIdle);
	}

	private void ResetHaglets()
	{
		if ((bool)showDialog.running)
		{
			if (showDialog.dialogData != null)
			{
				showDialog.dialogData.completed = true;
				showDialog.dialogData.OnComplete.Trigger();
			}
			if (showDialog.OnComplete != null)
			{
				showDialog.OnComplete.Trigger();
			}
			showDialog.host.Pause(showDialog);
			if (highlightUnit != null && (bool)highlightUnit.running)
			{
				highlightUnit.PauseHighlight();
			}
		}
		showDialog.Reset();
	}

	public void Skip()
	{
		if ((bool)showDialog.running)
		{
			ResetHaglets();
		}
	}

	private IEnumerator<HagletYieldTerm> ShowDialogRoutine()
	{
		HagletTrigger voComplete = new HagletTrigger(1);
		Action<VOController.VOCompletion> trigVOComplete = delegate
		{
			voComplete.Trigger();
		};
		yield return Routine.ResetToHere();
		if (Inst.ShowSubtitles)
		{
			Inst.textboxSubtitles.Show();
		}
		else
		{
			Inst.textboxSubtitles.Hide();
		}
		if (showDialog.message != null)
		{
			Inst.textboxSubtitles.SetText(showDialog.message);
			yield return Wait.ForSeconds(kMinSubtitleTime);
		}
		else
		{
			showDialog.dialogData.Prepare();
			DialogData.Dialog[] dialogs = showDialog.dialogData.dialogs;
			foreach (DialogData.Dialog dialog in dialogs)
			{
				if (!dialog.GetCharacterData(out var charData, ref dialog.unitRef))
				{
					continue;
				}
				string bodyKey = dialog.GetBodyKey();
				Inst.kMinSubtitleTime = dialog.subtitleTime;
				string displayName = string.Empty;
				string overrideNameKey = showDialog.overrideDisplayName;
				string localisedName = ((overrideNameKey == null) ? string.Empty : Localisation.Retrieve(overrideNameKey));
				if (!string.IsNullOrEmpty(localisedName))
				{
					displayName = showDialog.overrideDisplayName;
				}
				else if (charData != null)
				{
					displayName = charData.DisplayName;
				}
				Inst.textboxSubtitles.Clear();
				if (!string.IsNullOrEmpty(displayName))
				{
					Inst.textboxSubtitles.AppendKey(displayName);
					Inst.textboxSubtitles.Append(": ");
				}
				Inst.textboxSubtitles.AppendKey(bodyKey);
				Inst.textboxSubtitles.Present();
				HagletYieldTerm waitForDialog = Wait.ForSeconds(kMinSubtitleTime);
				Transform voSource = null;
				if (dialog.unitRef != null && dialog.unitRef.IsShown)
				{
					highlightUnit.Start(dialog.unitRef);
					voSource = dialog.unitRef._GetTransform();
				}
				else if (dialog.roomObjectRef != null)
				{
					voSource = dialog.roomObjectRef;
				}
				else if (charData != null && charData.charName == "Hartman")
				{
					voSource = ((!(Singleton<Hartman>.Inst != null)) ? Singleton<CC>.Inst.transformCamera : ((!Singleton<Hartman>.Inst.gameObject.activeInHierarchy) ? Singleton<CC>.Inst.transformCamera : Singleton<Hartman>.Inst.transform));
				}
				MusicController.Inst.SetMusicParameter(dialog.musicParameter, dialog.musicParameterValue);
				if (!string.IsNullOrEmpty(bodyKey))
				{
					VOController inst = VOController.Inst;
					string clipName = bodyKey;
					VOController.VOQueueProperty properties = VOController.VOQueueProperty.Interrupt;
					if (inst.VOPlayClip(clipName, properties, trigVOComplete, 0f, voSource, dialog.unitRef))
					{
						waitForDialog = Wait.Until(voComplete);
					}
				}
				dialog.OnShow(showDialog.dontReturnToIdle);
				yield return waitForDialog;
				if (dialog.unitRef != null && (bool)highlightUnit.running)
				{
					highlightUnit.PauseHighlight();
				}
				yield return Wait.ForSeconds(dialog.bufferTime);
			}
		}
		Inst.textboxSubtitles.Clear();
		Inst.textboxSubtitles.Present();
		Inst.textboxSubtitles.Hide();
		if ((bool)showDialog.dialogData)
		{
			showDialog.dialogData.OnComplete.Trigger();
			showDialog.dialogData.completed = true;
			showDialog.dialogData = null;
		}
		showDialog.message = null;
		showDialog.overrideDisplayName = null;
		showDialog.finished.Trigger();
		if (showDialog.OnComplete != null)
		{
			showDialog.OnComplete.Trigger();
		}
	}

	private IEnumerator<HagletYieldTerm> HighlightUnitRoutine()
	{
		while (true)
		{
			highlightUnit.CalculateNewScale(highlightUnit.time * highlightUnit.rate);
			yield return Wait.UntilNextUpdate();
			highlightUnit.time += Time.deltaTime;
			while (LR.Inst.IsPaused())
			{
				yield return null;
			}
		}
	}
}
public class UIBiometricImager : Singleton<UIBiometricImager>
{
	public struct BioKeySet
	{
		public string[] keys;

		public BioKeySet(string top, string mid, string bottom)
		{
			keys = new string[3];
			keys[0] = top;
			keys[1] = mid;
			keys[2] = bottom;
		}
	}

	private UITextbox[] bioTexts;

	private List<BioKeySet> bioKeys = new List<BioKeySet>();

	private int currentKeyIdx = -1;

	private HagletResettable animTextIn;

	private string[] targetTexts = new string[3];

	public void Start()
	{
		animTextIn = new HagletResettable(AnimTextInRoutine(), "Animate Bioimager Text");
		bioTexts = GetComponentsInChildren<UITextbox>();
		for (int i = 0; i < bioTexts.Length; i++)
		{
			bioTexts[i].OnAwakeLR();
			bioTexts[i].SetText(string.Empty);
		}
		bioKeys.Add(new BioKeySet(string.Empty, string.Empty, string.Empty));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_1_0", "BIOMETRIC_IMAGER_DURING_A3S1_1_0", string.Empty));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_2_ENTER", "BIOMETRIC_IMAGER_DURING_A3S1_2_CITID", string.Empty));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_ID_CONFIRMED", "BIOMETRIC_IMAGER_DURING_A3S1_WTHORNE", "BIOMETRIC_IMAGER_DURING_A3S1_3"));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_ID_CONFIRMED", "BIOMETRIC_IMAGER_DURING_A3S1_WTHORNE", "BIOMETRIC_IMAGER_DURING_A3S1_4"));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_ID_CONFIRMED", "BIOMETRIC_IMAGER_DURING_A3S1_WTHORNE", "BIOMETRIC_IMAGER_DURING_A3S1_5"));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_ID_CONFIRMED", "BIOMETRIC_IMAGER_DURING_A3S1_WTHORNE", "BIOMETRIC_IMAGER_DURING_A3S1_6"));
		bioKeys.Add(new BioKeySet("BIOMETRIC_IMAGER_DURING_A3S1_ID_CONFIRMED", "BIOMETRIC_IMAGER_DURING_A3S1_WTHORNE", "BIOMETRIC_IMAGER_DURING_A3S1_7"));
		currentKeyIdx = -1;
	}

	public void OnMissionStart()
	{
		DisplayNextKey();
	}

	public void ClearDisplay()
	{
		currentKeyIdx = -1;
		DisplayNextKey();
	}

	public void DisplayNextKey()
	{
		currentKeyIdx++;
		if (currentKeyIdx >= bioKeys.Count)
		{
			currentKeyIdx = 0;
		}
		if ((bool)animTextIn.running)
		{
			animTextIn.host.Pause(animTextIn);
			animTextIn.Reset();
		}
		Routine.Start(animTextIn, MR.Inst.Host);
	}

	private void SetBioTextAsCurrentKeySet()
	{
		BioKeySet bioKeySet = bioKeys[currentKeyIdx];
		for (int i = 0; i < bioTexts.Length; i++)
		{
			if (!string.IsNullOrEmpty(bioKeySet.keys[i]))
			{
				bioTexts[i].SetKey(bioKeySet.keys[i]);
			}
			else
			{
				bioTexts[i].SetText(string.Empty);
			}
		}
	}

	private IEnumerator<HagletYieldTerm> AnimTextInRoutine()
	{
		BioKeySet currKey = bioKeys[currentKeyIdx];
		for (int j = 0; j < bioTexts.Length; j++)
		{
			if (!string.IsNullOrEmpty(currKey.keys[j]))
			{
				targetTexts[j] = Localisation.Retrieve(currKey.keys[j]);
			}
			else
			{
				targetTexts[j] = string.Empty;
			}
			bioTexts[j].SetText(string.Empty);
		}
		int lastIdWithText = 0;
		for (int i = 0; i < bioTexts.Length; i++)
		{
			if (string.IsNullOrEmpty(targetTexts[i]))
			{
				continue;
			}
			lastIdWithText = i;
			int c = 1;
			while (c <= targetTexts[i].Length)
			{
				bioTexts[i].Clear();
				bioTexts[i].Append(targetTexts[i].Substring(0, c));
				if (c < targetTexts[i].Length - 1)
				{
					bioTexts[i].Append("|");
				}
				bioTexts[i].Present();
				c++;
				if (c <= targetTexts[i].Length && targetTexts[i][c - 1] == '9')
				{
					yield return Wait.ForSeconds(0.5f);
				}
				else
				{
					yield return Wait.ForSeconds(0.035f);
				}
			}
		}
		bool endOn = true;
		UITextbox lastBoxWithText = bioTexts[lastIdWithText];
		while (!MR.Inst.IsSkipping())
		{
			lastBoxWithText.Clear();
			lastBoxWithText.Append(targetTexts[lastIdWithText]);
			if (endOn)
			{
				lastBoxWithText.Append("|");
			}
			lastBoxWithText.Present();
			endOn = !endOn;
			yield return Wait.ForSeconds(0.25f);
		}
	}
}
public class UIButton : UIElement, UIFocusHighlight.UIFocussable
{
	public string onFocusEnterSound = "event:/sfx/ui/general hover light";

	public string onTapDownSound = string.Empty;

	public string onTapUpSound = "event:/sfx/ui/confirm";

	[HideInInspector]
	public UITextbox textbox;

	[HideInInspector]
	public UITextbox childTextbox;

	[HideInInspector]
	public UIImage image;

	[HideInInspector]
	public UIImage[] childImages;

	public object userData;

	[HideInInspector]
	public UICrosshairContext crosshairContext;

	public event Action OnTapDown;

	public event Action OnTapHeld;

	public event Func<bool> OnTapUp;

	public event Action<object> OnTapDownWithUserData;

	public event Action<object> OnTapHeldWithUserData;

	public event Func<object, bool> OnTapUpWithUserData;

	public event Action OnFocusEnter;

	public event Action OnFocusExit;

	public event Action OnFocusStay;

	public event Action<object> OnFocusEnterWithUserData;

	public event Action<object> OnFocusStayWithUserData;

	public event Action<object> OnFocusExitWithUserData;

	public void Start()
	{
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textbox = GetComponent<UITextbox>();
		childTextbox = GetComponentInChildren<UITextbox>();
		image = GetComponent<UIImage>();
		childImages = GetComponentsInChildren<UIImage>(includeInactive: true);
	}

	public virtual void TapDown()
	{
		if (base.enabled)
		{
			PlayButtonSound(onTapDownSound);
			if (this.OnTapDown != null)
			{
				this.OnTapDown();
			}
			if (this.OnTapDownWithUserData != null)
			{
				this.OnTapDownWithUserData(userData);
			}
		}
	}

	public virtual void TapHeld()
	{
		if (base.enabled)
		{
			if (this.OnTapHeld != null)
			{
				this.OnTapHeld();
			}
			if (this.OnTapHeldWithUserData != null)
			{
				this.OnTapHeldWithUserData(userData);
			}
		}
	}

	public virtual bool TapUp()
	{
		if (base.enabled)
		{
			PlayButtonSound(onTapUpSound);
			bool flag = false;
			if (this.OnTapUp != null)
			{
				flag = this.OnTapUp();
			}
			if (this.OnTapUpWithUserData != null)
			{
				flag |= this.OnTapUpWithUserData(userData);
			}
			return flag;
		}
		return false;
	}

	public virtual void FocusEnter()
	{
		if (base.enabled)
		{
			PlayButtonSound(onFocusEnterSound);
			Crosshair.Inst.SetContext(crosshairContext);
			if (this.OnFocusEnter != null)
			{
				this.OnFocusEnter();
			}
			if (this.OnFocusEnterWithUserData != null)
			{
				this.OnFocusEnterWithUserData(userData);
			}
		}
	}

	public virtual void FocusExit()
	{
		if (base.enabled)
		{
			Crosshair.Inst.SetContext(UICrosshairContext.None);
			if (this.OnFocusExit != null)
			{
				this.OnFocusExit();
			}
			if (this.OnFocusExitWithUserData != null)
			{
				this.OnFocusExitWithUserData(userData);
			}
		}
	}

	public virtual void FocusStay()
	{
		if (base.enabled)
		{
			if (this.OnFocusStay != null)
			{
				this.OnFocusStay();
			}
			if (this.OnFocusStayWithUserData != null)
			{
				this.OnFocusStayWithUserData(userData);
			}
		}
	}

	public override void OnAlphaSet(float alpha)
	{
		if (textbox != null)
		{
			textbox.alpha = alpha;
		}
		if (childTextbox != null)
		{
			childTextbox.alpha = alpha;
		}
		if (image != null)
		{
			image.alpha = alpha;
		}
		UIImage[] array = childImages;
		foreach (UIImage uIImage in array)
		{
			uIImage.alpha = alpha;
		}
	}

	private void PlayButtonSound(string sound)
	{
		if (!string.IsNullOrEmpty(sound))
		{
			AC.Inst.PlayOneShot2D(sound);
		}
	}

	Transform UIFocusHighlight.UIFocussable.get_transform()
	{
		return base.transform;
	}
}
public class UIButtonDebugSwitchRoom : MonoBehaviour
{
}
public class UIButtonGlow : UIImage
{
	private UIButton uiButton;

	public float minGlowPulse = 0.25f;

	public float maxGlowPulse = 0.5f;

	public float glowFrequency = 0.5f;

	public float focusGlowStrength = 0.8f;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButtonHaglet component = GetComponent<UIButtonHaglet>();
		if (!(component != null))
		{
			uiButton = GetComponent<UIButton>();
			uiButton.OnFocusEnter += UiButton_OnFocusEnter;
			uiButton.OnFocusExit += UiButton_OnFocusExit;
		}
	}

	private void OnEnable()
	{
		if (spriteRenderer != null)
		{
			base.alpha = 0f;
			StartButtonHightlight();
		}
	}

	private void OnDisable()
	{
		StopButtonHighlight(0f);
	}

	public void UiButton_OnFocusEnter()
	{
		StopButtonHighlight(focusGlowStrength);
	}

	public void UiButton_OnFocusExit()
	{
		StartButtonHightlight();
	}

	public override void Show()
	{
		base.Show();
		base.alpha = 0f;
		StartButtonHightlight();
	}

	public override void Hide()
	{
		base.Hide();
		StopButtonHighlight(0f);
	}

	private void StartButtonHightlight()
	{
		PulseAlphaStart(LR.Host, minGlowPulse, maxGlowPulse, glowFrequency);
	}

	private void StopButtonHighlight(float stopVal)
	{
		PulseAlphaStop(stopVal);
	}
}
public class UIButtonHaglet : UIButton
{
	public new HagletTrigger OnTapUp = new HagletTrigger();

	public new HagletTrigger OnFocusEnter = new HagletTrigger();

	public new HagletTrigger OnFocusExit = new HagletTrigger();

	private bool isOptionalButton = true;

	private bool sparkleEnabled = true;

	private UIButtonGlow uiButtonGlow;

	private ParticlePrefab tkFx;

	private BoxCollider buttonCollider;

	public UICrosshairContext crosshair = UICrosshairContext.Interaction;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		base.OnTapUp -= TapUpAction;
		base.OnTapUp += TapUpAction;
		base.OnFocusEnter -= FocusEnterAction;
		base.OnFocusEnter += FocusEnterAction;
		base.OnFocusExit -= FocusExitAction;
		base.OnFocusExit += FocusExitAction;
		crosshairContext = crosshair;
		base.gameObject.layer = LayerMask.NameToLayer("UI");
		buttonCollider = GetComponent<BoxCollider>();
		uiButtonGlow = GetComponent<UIButtonGlow>();
		if (uiButtonGlow != null)
		{
			uiButtonGlow.OnAwakeLR();
			base.OnFocusEnter -= uiButtonGlow.UiButton_OnFocusEnter;
			base.OnFocusEnter += uiButtonGlow.UiButton_OnFocusEnter;
			base.OnFocusExit -= uiButtonGlow.UiButton_OnFocusExit;
			base.OnFocusExit += uiButtonGlow.UiButton_OnFocusExit;
		}
	}

	private bool TapUpAction()
	{
		OnTapUp.Trigger();
		return true;
	}

	private void FocusEnterAction()
	{
		OnFocusEnter.Trigger();
		if (isOptionalButton && sparkleEnabled)
		{
			PlaySparkleFx();
		}
	}

	private void FocusExitAction()
	{
		OnFocusExit.Trigger();
		if (isOptionalButton && sparkleEnabled)
		{
			StopSparkleFx();
		}
	}

	public void SetSparkleOptional(bool isOptional)
	{
		isOptionalButton = isOptional;
	}

	public void SetSparkleEnabled(bool enabled)
	{
		sparkleEnabled = enabled;
		crosshairContext = (enabled ? UICrosshairContext.Interaction : UICrosshairContext.None);
		if (IC.Inst.buttonCurrentFocused == this)
		{
			Crosshair.Inst.SetContext(crosshairContext);
		}
		if (sparkleEnabled && !isOptionalButton)
		{
			PlaySparkleFx();
		}
		else if (!sparkleEnabled)
		{
			StopSparkleFx();
		}
	}

	private void PlaySparkleFx()
	{
		if (tkFx != null && tkFx.IsFadingOut)
		{
			tkFx.CancelFadeOut();
			return;
		}
		tkFx = PSC.Inst.Play(ParticleTypes.TK, base.transform);
		if ((bool)buttonCollider)
		{
			tkFx.transform.localScale = buttonCollider.size;
		}
	}

	private void StopSparkleFx()
	{
		if (tkFx != null && tkFx.gameObject.activeSelf && !tkFx.IsFadingOut)
		{
			tkFx.StopParticlesFade();
		}
	}
}
public class UIButtonToggle : UIButton
{
	[ReadOnly]
	public bool toggleValue;

	public override bool TapUp()
	{
		if (base.enabled)
		{
			toggleValue = !toggleValue;
		}
		return base.TapUp();
	}
}
public class UIC : Singleton<UIC>
{
	public struct StackAnim
	{
		public enum Type
		{
			Push,
			Pop,
			PopTo,
			Clear
		}

		public Type type;

		public UIContainer popToContainer;

		public UIContainer newContainer;

		public bool suppressShowAll;
	}

	public static readonly float kSafeUIDistance = 0.5322515f;

	private Stack<UIContainer> stack = new Stack<UIContainer>(16);

	private Dictionary<Type, UIContainer> containers = new Dictionary<Type, UIContainer>();

	[Serializer.Exclude]
	private HagletResettable stackAnimRoutine;

	private ConstArray<StackAnim> queuedPushPops = new ConstArray<StackAnim>(4u);

	public HagletEvent pushPopComplete => stackAnimRoutine.completed;

	public void OnAwakeLR()
	{
		stackAnimRoutine = new HagletResettable(StackAnimRoutine(), "UIC Stack Anim", HagletStepTime.Update, -1, 3);
	}

	public void Register<T>(UIContainer container)
	{
		containers.Add(typeof(T), container);
	}

	private void TryStartStackAnimRoutine()
	{
		if (!stackAnimRoutine.running)
		{
			LR.Host.StartTopLevel(stackAnimRoutine, (!MR.Inst) ? null : MR.Inst.mainHagisSequence, prestep: true);
		}
	}

	public T Push<T>() where T : UIContainer
	{
		T val = (T)containers[typeof(T)];
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Push,
			newContainer = val
		});
		TryStartStackAnimRoutine();
		return val;
	}

	public HagletEvent Pop()
	{
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Pop
		});
		TryStartStackAnimRoutine();
		return pushPopComplete;
	}

	public HagletEvent PopTo<T>(bool supressShowAll = false) where T : UIContainer
	{
		return PopTo(typeof(T), supressShowAll);
	}

	public HagletEvent PopTo(Type type, bool suppressShowAll = false)
	{
		UIContainer popToContainer = Get(type);
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.PopTo,
			popToContainer = popToContainer,
			suppressShowAll = suppressShowAll
		});
		TryStartStackAnimRoutine();
		return pushPopComplete;
	}

	public HagletEvent Clear()
	{
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Clear
		});
		return pushPopComplete;
	}

	public void ClearImmediate()
	{
		if ((bool)stackAnimRoutine.running)
		{
			stackAnimRoutine.host.Pause(stackAnimRoutine);
			stackAnimRoutine.Reset();
		}
		queuedPushPops.Clear();
		if (stack.Count > 0)
		{
			stack.Peek().HideAll();
			for (int num = stack.Count - 1; num >= 0; num--)
			{
				stack.Pop();
			}
		}
	}

	public bool IsShown<T>()
	{
		if (stack.Count == 0)
		{
			return false;
		}
		return stack.Peek().GetType() == typeof(T) || (queuedPushPops.Length != 0 && (bool)queuedPushPops[0].newContainer && queuedPushPops[0].newContainer.GetType() == typeof(T));
	}

	public bool IsShown()
	{
		return stack.Count > 0;
	}

	public T Get<T>() where T : UIContainer
	{
		return containers[typeof(T)] as T;
	}

	public bool IsInStack<T>() where T : UIContainer
	{
		return stack.Contains(Get<T>()) || IsShown<T>();
	}

	public bool IsStackAnimating()
	{
		return queuedPushPops.Length != 0;
	}

	public UIContainer Get(Type type)
	{
		return containers[type];
	}

	private IEnumerator<HagletYieldTerm> StackAnimRoutine()
	{
		while (queuedPushPops.Length != 0)
		{
			yield return Wait.ForSteps(1uL);
			StackAnim stackAnim = queuedPushPops[0];
			switch (stackAnim.type)
			{
			case StackAnim.Type.Push:
			{
				if (stack.Count > 0)
				{
					stack.Peek().HideAll();
				}
				yield return Wait.ForChildren;
				UIContainer container = stackAnim.newContainer;
				stackAnim.newContainer = null;
				container.ShowAll();
				stack.Push(container);
				yield return Wait.ForChildren;
				break;
			}
			case StackAnim.Type.Pop:
			{
				UIContainer popped2 = stack.Pop();
				popped2.HideAll();
				yield return Wait.ForChildren;
				if (stack.Count > 0)
				{
					stack.Peek().ShowAll();
					yield return Wait.ForChildren;
				}
				break;
			}
			case StackAnim.Type.PopTo:
			{
				bool topOfStackHidden = true;
				while (stack.Count > 0 && !(stack.Peek() == stackAnim.popToContainer))
				{
					UIContainer popped = stack.Pop();
					if (topOfStackHidden)
					{
						popped.HideAll();
						yield return Wait.ForChildren;
					}
					topOfStackHidden = false;
				}
				if (!topOfStackHidden && !stackAnim.suppressShowAll && stack.Count > 0)
				{
					stack.Peek().ShowAll();
					yield return Wait.ForChildren;
				}
				break;
			}
			case StackAnim.Type.Clear:
				if (stack.Count > 0)
				{
					stack.Peek().HideAll();
				}
				stack.Clear();
				break;
			}
			queuedPushPops.RemoveAtIndex(0u);
		}
	}

	public bool OnBackButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			return uIContainer.OnBackButtonPressed();
		}
		return false;
	}

	public bool OnActionButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			uIContainer.OnActionButtonPressed();
			return uIContainer.ConsumesActionButton();
		}
		return false;
	}

	public bool ConsumesActionButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			return uIContainer.ConsumesActionButton();
		}
		return false;
	}

	public static void PositionCombatUIPopup(Transform transform)
	{
		int num = 30;
		Quaternion rotation = Singleton<CC>.Inst._camera.transform.rotation;
		Quaternion quaternion = Quaternion.LookRotation(Singleton<MC>.Inst.GetActiveMap().transform.position - Singleton<CC>.Inst._camera.transform.position);
		float num2 = Quaternion.Angle(rotation, quaternion);
		float num3 = Mathf.Clamp(num2, 0f, num);
		Quaternion quaternion2 = Quaternion.Lerp(quaternion, rotation, num3 / num2);
		transform.position = Singleton<CC>.Inst._camera.transform.position + quaternion2 * Vector3.forward * kSafeUIDistance;
		transform.rotation = quaternion2;
		transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.RepZ(0f));
	}
}
public class UICharacterDetails : UIContainer
{
	public enum DetailsScreenState
	{
		FullPartyEdit,
		MissionEnd
	}

	private enum ConfirmButtonState
	{
		UpgradeAbility,
		RejectionShot
	}

	private class UIConfirmDialog
	{
		public UIContainer container;

		public UIContainer yesHighlightContainer;

		public UIContainer noHighlightContainer;

		public UIButton buttonConfirm;

		public UIButton buttonCancel;
	}

	private struct AbilityListItem
	{
		public int index;

		public UIContainer container;

		public UIImage imageUpgraded;

		public UIImage imageIconBorder;

		public UIImage imageIconHighlightedBorder;

		public UIImage imageDisabledIcon;

		public UIImage imageNameShortBG;

		public UIImage imageNameLongBG;

		public UIButton buttonBackground;

		public UIButton buttonIcon;

		public UITextbox textboxEmptySlot;

		public UITextbox textboxName;

		private TextMesh textboxNameMesh;

		public BoxCollider backgroundBoxCollider;

		public AnimFloatHaglet abilityGazeOn;

		public AnimFloatHaglet abilityGazeOff;

		public bool hasLongName
		{
			get
			{
				if (textboxName == null)
				{
					return false;
				}
				if (textboxNameMesh == null)
				{
					textboxNameMesh = textboxName.GetComponent<TextMesh>();
					if (textboxNameMesh == null)
					{
						return false;
					}
				}
				return textboxNameMesh.text.Length > 7;
			}
		}
	}

	private struct AbilitySelectItem
	{
		public UIContainer container;

		public UITextbox textboxName;

		public UITextbox textboxDescription;

		public UIImage imageIconBorder;

		public UIImage imageIconHighlightedBorder;

		public UIButton buttonIcon;

		public UIConfirmDialog dialogAugment;
	}

	public Color buttonSelected;

	private DetailsScreenState state;

	private ConfirmButtonState confirmButtonState;

	private readonly Color kRegularTextColor = ColorX.RGB(153, 204, 204);

	private readonly Color kHighlightTextColor = ColorX.RGB(150, 164, 95);

	[NonSerialized]
	public HagletTrigger OnContinue = new HagletTrigger();

	private UIContainer containerAbilities;

	private UIContainer containerStatsAndBio;

	private UIContainer containerAbilitySelect;

	private UIContainer containerAbilityDetails;

	private UIContainer containerNextPrev;

	private UIButton DEBUG_addMissionButton;

	private ConstArray<PartyMember> activePartyMembers;

	private ConstArray<PartyMember> shownPartyMembers = new ConstArray<PartyMember>(7u);

	private int activeUnitIndex;

	private int? prevActiveUnitIndex;

	private int activeAbilityIndex = -1;

	private bool hasUpgradesAvailable;

	private ConstArray<AbilityListItem> abilityUIList = new ConstArray<AbilityListItem>(12u);

	private UITextbox textboxUpgradeSlots;

	private UITextbox textboxUnitName;

	private UITextbox textboxUnitNameShadow;

	private UIButton buttonNamePrev;

	private UIButton buttonNameNext;

	private UIImage imageNamePrev;

	private UIImage imageNamePrevHighlight;

	private UIImage imageNameNext;

	private UIImage imageNameNextHighlight;

	private bool nameArrows;

	private UIContainer statsContainer;

	private UIContainer bioContainer;

	private UITextbox textboxHP;

	private UITextbox textboxAP;

	private UITextbox textboxSpeed;

	private UITextbox textboxDodge;

	private UITextbox textboxMissionsToLevelUp;

	private UITextbox textboxStatsWeaponName;

	private UITextbox textboxStatsWeaponDamage;

	private UITextbox textboxStatsWeaponAccuracy;

	private UITextbox textboxStatsWeaponCritHitChance;

	private UITextbox textboxBioDescription;

	private UITextbox textboxRejectDescription;

	private UIImage imagePortrait;

	private UIImage imageXPPip1;

	private UIImage imageXPPip2;

	private UIImage imagePreviousHighlight;

	private UIImage imageNextHighlight;

	private UIButton buttonStats;

	private UIButton buttonBio;

	private UIButton buttonPrev;

	private UIButton buttonNext;

	private HagletFlag tutorialOpenedAbility = new HagletFlag();

	private HagletFlag tutorialSelectedAbility = new HagletFlag();

	private readonly Vector3 twoXPPosition = new Vector3(0.22375f, -0.13625f, 0f);

	private readonly Vector3 twoXPScale = new Vector3(0.0775f, 0.05f, 1f);

	private readonly Vector3 threeXPPosition1 = new Vector3(0.21f, -0.13625f, 0f);

	private readonly Vector3 threeXPPosition2 = new Vector3(0.265f, -0.13625f, 0f);

	private readonly Vector3 threeXPScale = new Vector3(0.05f, 0.05f, 1f);

	private AbilitySelectItem[] abilitySelectItems = new AbilitySelectItem[2];

	private UITextbox textboxAugmentNumber;

	private UIButton buttonAbilitySelectDismiss;

	private UIImage imageAbilitySelectDismissHighlight;

	private UITextbox textboxAbilityDetailNameShort;

	private UITextbox textboxAbilityDetailNameLong;

	private UITextbox textboxAbilityDetailDescription;

	private UITextbox textboxBlankDisabledUpgradeHeader;

	private UITextbox textboxBlankDisabledUpgradeDescription;

	private UITextbox textboxBlankDisabledUpgradeAtRank;

	private UITextbox textboxBlankDisabledShotQuantity;

	private UITextbox textboxBlankUpgradeHeader;

	private UITextbox textboxBlankUpgradeUpgradeDescription;

	private UITextbox textboxBlankUpgradeAvailable;

	private UITextbox textboxBlankCoreQuantity;

	private UITextbox textboxBlankShotQuantity;

	private UITextbox textboxUpgradedOverloaded;

	private UITextbox textboxUpgradedUpgradeDescription;

	private UITextbox textboxUpgradedShotQuantity;

	private UIImage imageAbilityDetailIcon;

	private UIImage imageAbilityDetailShortNameBG;

	private UIImage imageAbilityDetailLongNameBG;

	private UIImage imageAbilityDetailDismissHighlight;

	private UIImage imageAbilityDetailBlankDisabledWrapper;

	private UIImage imageAbilityDetailBlankWrapper;

	private UIImage imageAbilityDetailBlankCore;

	private UIImage imageAbilityDetailUpgradedWrapper;

	private UIButton buttonAbilityUpgrade;

	private UIButton buttonRejectAbilityDisabled;

	private UIButton buttonRejectAbility;

	private UIButton buttonRejectUpgrade;

	private UIButton buttonAbilityDetailDismiss;

	private UIContainer detailBlankUpgradeDisabledContainer;

	private UIContainer detailBlankUpgradeContainer;

	private UIContainer detailUpgradedContainer;

	private UIConfirmDialog dialogReject;

	private UIConfirmDialog dialogUpgrade;

	private UIButton buttonContinue;

	private const float abilityScaleDefault = 1f;

	private const float abilityScaleLarge = 1.25f;

	private const float abilityScaleTime = 0.15f;

	private const float abilityFocusCurrent = 0f;

	private const float abilityFocusMax = 1f;

	private bool singleAbilitySelect;

	private HagletResettable tutorialUseAugmentRoutine;

	private HagletResettable tutorialUseAtlantiumCoreRoutine;

	private HagletResettable tutorialUseRejectionShotRoutine;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		tutorialUseAugmentRoutine = new HagletResettable(TutorialUseAugmentRoutine(), null, HagletStepTime.Update, -1, 3);
		tutorialUseRejectionShotRoutine = new HagletResettable(TutorialUseRejectionShotRoutine(), null, HagletStepTime.Update, -1, 3);
		tutorialUseAtlantiumCoreRoutine = new HagletResettable(TutorialUseAtlantiumCore(), null, HagletStepTime.Update, -1, 3);
		textboxUnitName = GetElement<UITextbox>("UnitName");
		textboxUnitNameShadow = GetElement<UITextbox>("UnitNameShadow");
		containerAbilities = GetContainer("Abilities");
		textboxUpgradeSlots = containerAbilities.GetElement<UITextbox>("UpgradeSlotsNum");
		UIContainer[] array = containerAbilities.GetContainers();
		for (int i = 0; i < array.Length; i++)
		{
			UIContainer uIContainer = array[i];
			AbilityListItem listItem = new AbilityListItem
			{
				index = i,
				container = uIContainer,
				imageUpgraded = uIContainer.GetElement<UIImage>("Ability_Upgraded"),
				buttonBackground = uIContainer.GetElement<UIButton>("IconBackground"),
				imageIconBorder = uIContainer.GetElement<UIImage>("IconBorder"),
				buttonIcon = uIContainer.GetElement<UIButton>("Icon"),
				imageDisabledIcon = uIContainer.GetElement<UIImage>("AbilityDisabledIcon"),
				imageIconHighlightedBorder = uIContainer.GetElement<UIImage>("HighlightedAbility"),
				textboxEmptySlot = uIContainer.GetElement<UITextbox>("EmptySlotText"),
				imageNameShortBG = uIContainer.GetElement<UIImage>("AbilityNameShortBG"),
				imageNameLongBG = uIContainer.GetElement<UIImage>("AbilityNameLongBG"),
				textboxName = uIContainer.GetElement<UITextbox>("AbilityName")
			};
			listItem.backgroundBoxCollider = listItem.buttonBackground.GetComponent<BoxCollider>();
			listItem.buttonBackground.userData = i;
			listItem.buttonIcon.image.SetImage(null);
			listItem.buttonIcon.OnTapUpWithUserData += IconButton_OnTapUpWithUserData;
			listItem.buttonIcon.OnFocusEnterWithUserData += IconButton_OnFocusEnterWithUserData;
			listItem.buttonIcon.OnFocusExitWithUserData += IconButton_OnFocusExitWithUserData;
			listItem.abilityGazeOn = new AnimFloatHaglet("AbilityGazeOn - Item " + i, LR.Host, delegate
			{
				listItem.textboxName.Show();
				if (listItem.hasLongName)
				{
					listItem.imageNameLongBG.Show();
				}
				else
				{
					listItem.imageNameShortBG.Show();
				}
			}, delegate(float x)
			{
				float num2 = Mathf.SmoothStep(1f, 1.25f, x);
				listItem.container.transform.localScale = new Vector3(num2, num2, 1f);
				float alpha2 = ((!(x > 0.6f)) ? 0f : ((x - 0.6f) / 0.4f));
				listItem.textboxName.alpha = alpha2;
				if (listItem.hasLongName)
				{
					listItem.imageNameLongBG.alpha = alpha2;
				}
				else
				{
					listItem.imageNameShortBG.alpha = alpha2;
				}
			}, delegate
			{
				listItem.container.transform.localScale = new Vector3(1.25f, 1.25f, 1f);
			});
			listItem.abilityGazeOff = new AnimFloatHaglet("AbilityGazeOff - Item " + i, LR.Host, delegate
			{
			}, delegate(float x)
			{
				float num = Mathf.SmoothStep(1f, 1.25f, x);
				listItem.container.transform.localScale = new Vector3(num, num, 1f);
				float alpha = ((!(x > 0.6f)) ? 0f : ((x - 0.6f) / 0.4f));
				listItem.textboxName.alpha = alpha;
				if (listItem.hasLongName)
				{
					listItem.imageNameLongBG.alpha = alpha;
				}
				else
				{
					listItem.imageNameShortBG.alpha = alpha;
				}
			}, delegate
			{
				listItem.container.transform.localScale = new Vector3(1f, 1f, 1f);
				if (listItem.hasLongName)
				{
					listItem.imageNameLongBG.Hide();
				}
				else
				{
					listItem.imageNameShortBG.Hide();
				}
			});
			abilityUIList.Add(listItem);
		}
		buttonNamePrev = GetElement<UIButton>("PreviousName");
		buttonNamePrev.OnTapUp += ButtonNamePrev_OnTapUp;
		buttonNamePrev.OnFocusEnter += ButtonNamePrev_OnFocusEnter;
		buttonNamePrev.OnFocusExit += ButtonNamePrev_OnFocusExit;
		imageNamePrev = GetElement<UIImage>("PreviousArrow");
		imageNamePrevHighlight = GetElement<UIImage>("PreviousArrowHighlight");
		buttonNameNext = GetElement<UIButton>("NextName");
		buttonNameNext.OnTapUp += ButtonNameNext_OnTapUp;
		buttonNameNext.OnFocusEnter += ButtonNameNext_OnFocusEnter;
		buttonNameNext.OnFocusExit += ButtonNameNext_OnFocusExit;
		imageNameNext = GetElement<UIImage>("NextArrow");
		imageNameNextHighlight = GetElement<UIImage>("NextArrowHighlight");
		containerNextPrev = GetContainer("NextPrev");
		buttonPrev = containerNextPrev.GetElement<UIButton>("Previous");
		buttonPrev.OnTapUp += PreviousButton_OnTapUp;
		buttonPrev.OnFocusEnter += ButtonPrevious_OnFocusEnter;
		buttonPrev.OnFocusExit += ButtonPrevious_OnFocusExit;
		buttonNext = containerNextPrev.GetElement<UIButton>("Next");
		buttonNext.OnTapUp += NextButton_OnTapUp;
		buttonNext.OnFocusEnter += ButtonNext_OnFocusEnter;
		buttonNext.OnFocusExit += ButtonNext_OnFocusExit;
		imagePreviousHighlight = containerNextPrev.GetElement<UIImage>("PreviousArrowHighlight");
		imageNextHighlight = containerNextPrev.GetElement<UIImage>("NextArrowHighlight");
		containerStatsAndBio = GetContainer("StatsAndBio");
		imagePortrait = containerStatsAndBio.GetElement<UIImage>("Portrait");
		buttonStats = containerStatsAndBio.GetElement<UIButton>("StatsTab");
		buttonStats.OnTapUp += StatsTab_OnTapUp;
		buttonBio = containerStatsAndBio.GetElement<UIButton>("BioTab");
		buttonBio.OnTapUp += BioTab_OnTapUp;
		statsContainer = containerStatsAndBio.GetContainer("Stats");
		UITextbox textboxStatsBioTabText = statsContainer.GetElement<UITextbox>("BioTabText");
		Color origBioTabColor = textboxStatsBioTabText.color;
		buttonBio.OnFocusEnter += delegate
		{
			textboxStatsBioTabText.color = buttonSelected;
		};
		buttonBio.OnFocusExit += delegate
		{
			textboxStatsBioTabText.color = origBioTabColor;
		};
		textboxHP = statsContainer.GetElement<UITextbox>("HP");
		textboxAP = statsContainer.GetElement<UITextbox>("AP");
		textboxSpeed = statsContainer.GetElement<UITextbox>("Speed");
		textboxDodge = statsContainer.GetElement<UITextbox>("Dodge");
		textboxMissionsToLevelUp = statsContainer.GetElement<UITextbox>("Missions");
		imageXPPip1 = statsContainer.GetElement<UIImage>("XPPip1");
		imageXPPip2 = statsContainer.GetElement<UIImage>("XPPip2");
		textboxStatsWeaponName = statsContainer.GetElement<UITextbox>("WeaponName");
		textboxStatsWeaponDamage = statsContainer.GetElement<UITextbox>("Damage");
		textboxStatsWeaponAccuracy = statsContainer.GetElement<UITextbox>("Accuracy");
		textboxStatsWeaponCritHitChance = statsContainer.GetElement<UITextbox>("CriticalHit");
		bioContainer = containerStatsAndBio.GetContainer("Bio");
		UITextbox textboxBioStatsTabText = bioContainer.GetElement<UITextbox>("StatsTabText");
		Color origStatsTabColor = textboxBioStatsTabText.color;
		buttonStats.OnFocusEnter += delegate
		{
			textboxBioStatsTabText.color = buttonSelected;
		};
		buttonStats.OnFocusExit += delegate
		{
			textboxBioStatsTabText.color = origStatsTabColor;
		};
		textboxBioDescription = bioContainer.GetElement<UITextbox>("BioDescription");
		containerAbilitySelect = GetContainer("AbilitySelect");
		buttonAbilitySelectDismiss = containerAbilitySelect.GetElement<UIButton>("DismissButton");
		imageAbilitySelectDismissHighlight = containerAbilitySelect.GetElement<UIImage>("DismissButtonHighlight");
		buttonAbilitySelectDismiss.OnTapUp += ButtonCancel_OnTapUp;
		buttonAbilitySelectDismiss.OnFocusEnter += delegate
		{
			imageAbilitySelectDismissHighlight.Show();
		};
		buttonAbilitySelectDismiss.OnFocusExit += delegate
		{
			imageAbilitySelectDismissHighlight.Hide();
		};
		UIContainer uIContainer2 = (abilitySelectItems[0].container = containerAbilitySelect.GetContainer("Choice_01"));
		abilitySelectItems[0].buttonIcon = uIContainer2.GetElement<UIButton>("AbilityIcon");
		abilitySelectItems[0].imageIconBorder = uIContainer2.GetElement<UIImage>("AbilityIconBorder");
		abilitySelectItems[0].imageIconHighlightedBorder = uIContainer2.GetElement<UIImage>("AbilityIconHighlightedBorder");
		abilitySelectItems[0].textboxName = uIContainer2.GetElement<UITextbox>("AbilityName");
		abilitySelectItems[0].textboxDescription = uIContainer2.GetElement<UITextbox>("AbilityDescription");
		abilitySelectItems[0].dialogAugment = new UIConfirmDialog();
		UIContainer uIContainer3 = (abilitySelectItems[0].dialogAugment.container = containerAbilitySelect.GetContainer("Confirm_01"));
		abilitySelectItems[0].dialogAugment.buttonConfirm = uIContainer3.GetElement<UIButton>("Yes");
		abilitySelectItems[0].dialogAugment.buttonConfirm.OnTapUpWithUserData += ButtonAugmentConfirm_OnTapUpWithUserData;
		abilitySelectItems[0].dialogAugment.buttonConfirm.OnFocusEnterWithUserData += ButtonAugmentConfirm_OnFocusEnterWithUserData;
		abilitySelectItems[0].dialogAugment.buttonConfirm.OnFocusExitWithUserData += ButtonAugmentConfirm_OnFocusExitWithUserData;
		abilitySelectItems[0].dialogAugment.yesHighlightContainer = uIContainer3.GetContainer("YesHighlight");
		abilitySelectItems[0].dialogAugment.buttonCancel = uIContainer3.GetElement<UIButton>("No");
		abilitySelectItems[0].dialogAugment.buttonCancel.OnTapUp += ButtonAugmentCancel_OnTapUp;
		abilitySelectItems[0].dialogAugment.buttonCancel.OnFocusEnterWithUserData += ButtonAugmentCancel_OnFocusEnterWithUserData;
		abilitySelectItems[0].dialogAugment.buttonCancel.OnFocusExitWithUserData += ButtonAugmentCancel_OnFocusExitWithUserData;
		abilitySelectItems[0].dialogAugment.noHighlightContainer = uIContainer3.GetContainer("NoHighlight");
		UIContainer uIContainer4 = (abilitySelectItems[1].container = containerAbilitySelect.GetContainer("Choice_02"));
		abilitySelectItems[1].buttonIcon = uIContainer4.GetElement<UIButton>("AbilityIcon");
		abilitySelectItems[1].imageIconBorder = uIContainer4.GetElement<UIImage>("AbilityIconBorder");
		abilitySelectItems[1].imageIconHighlightedBorder = uIContainer4.GetElement<UIImage>("AbilityIconHighlightedBorder");
		abilitySelectItems[1].textboxName = uIContainer4.GetElement<UITextbox>("AbilityName");
		abilitySelectItems[1].textboxDescription = uIContainer4.GetElement<UITextbox>("AbilityDescription");
		abilitySelectItems[1].dialogAugment = new UIConfirmDialog();
		UIContainer uIContainer5 = (abilitySelectItems[1].dialogAugment.container = containerAbilitySelect.GetContainer("Confirm_02"));
		abilitySelectItems[1].dialogAugment.buttonConfirm = uIContainer5.GetElement<UIButton>("Yes");
		abilitySelectItems[1].dialogAugment.buttonConfirm.OnTapUpWithUserData += ButtonAugmentConfirm_OnTapUpWithUserData;
		abilitySelectItems[1].dialogAugment.buttonConfirm.OnFocusEnterWithUserData += ButtonAugmentConfirm_OnFocusEnterWithUserData;
		abilitySelectItems[1].dialogAugment.buttonConfirm.OnFocusExitWithUserData += ButtonAugmentConfirm_OnFocusExitWithUserData;
		abilitySelectItems[1].dialogAugment.yesHighlightContainer = uIContainer5.GetContainer("YesHighlight");
		abilitySelectItems[1].dialogAugment.buttonCancel = uIContainer5.GetElement<UIButton>("No");
		abilitySelectItems[1].dialogAugment.buttonCancel.OnTapUp += ButtonAugmentCancel_OnTapUp;
		abilitySelectItems[1].dialogAugment.buttonCancel.OnFocusEnterWithUserData += ButtonAugmentCancel_OnFocusEnterWithUserData;
		abilitySelectItems[1].dialogAugment.buttonCancel.OnFocusExitWithUserData += ButtonAugmentCancel_OnFocusExitWithUserData;
		abilitySelectItems[1].dialogAugment.noHighlightContainer = uIContainer5.GetContainer("NoHighlight");
		textboxAugmentNumber = containerAbilitySelect.GetElement<UITextbox>("AugmentNumber");
		containerAbilityDetails = GetContainer("AbilityDetail");
		textboxAbilityDetailNameShort = containerAbilityDetails.GetElement<UITextbox>("AbilityNameShort");
		textboxAbilityDetailNameLong = containerAbilityDetails.GetElement<UITextbox>("AbilityNameLong");
		textboxAbilityDetailDescription = containerAbilityDetails.GetElement<UITextbox>("AbilityDescription");
		imageAbilityDetailIcon = containerAbilityDetails.GetElement<UIImage>("AbilityIcon");
		imageAbilityDetailShortNameBG = containerAbilityDetails.GetElement<UIImage>("AbilityNameShortBG");
		imageAbilityDetailLongNameBG = containerAbilityDetails.GetElement<UIImage>("AbilityNameLongBG");
		buttonAbilityDetailDismiss = containerAbilityDetails.GetElement<UIButton>("DismissButton");
		imageAbilityDetailDismissHighlight = containerAbilityDetails.GetElement<UIImage>("DismissButtonHighlight");
		buttonAbilityDetailDismiss.OnTapUp += ButtonCancel_OnTapUp;
		buttonAbilityDetailDismiss.OnFocusEnter += delegate
		{
			imageAbilityDetailDismissHighlight.Show();
		};
		buttonAbilityDetailDismiss.OnFocusExit += delegate
		{
			imageAbilityDetailDismissHighlight.Hide();
		};
		detailBlankUpgradeDisabledContainer = containerAbilityDetails.GetContainer("BlankUpgradeDisabled");
		textboxBlankDisabledUpgradeHeader = detailBlankUpgradeDisabledContainer.GetElement<UITextbox>("AugmentedHeader");
		textboxBlankDisabledUpgradeDescription = detailBlankUpgradeDisabledContainer.GetElement<UITextbox>("AugmentedDescription");
		textboxBlankDisabledUpgradeAtRank = detailBlankUpgradeDisabledContainer.GetElement<UITextbox>("UpgradeAvailableAtRank");
		textboxBlankDisabledShotQuantity = detailBlankUpgradeDisabledContainer.GetElement<UITextbox>("ShotQuantity");
		imageAbilityDetailBlankDisabledWrapper = detailBlankUpgradeDisabledContainer.GetElement<UIImage>("OverloadedWrapper");
		buttonRejectAbilityDisabled = detailBlankUpgradeDisabledContainer.GetElement<UIButton>("Remove");
		buttonRejectAbilityDisabled.OnTapUp += RejectionShotButton_OnTapUp_BlankDisabled;
		buttonRejectAbilityDisabled.userData = false;
		UIConfirmDialog uIConfirmDialog = (dialogReject = new UIConfirmDialog());
		UIContainer uIContainer6 = (dialogReject.container = containerAbilityDetails.GetContainer("RejectConfirm"));
		uIConfirmDialog.buttonConfirm = uIContainer6.GetElement<UIButton>("Yes");
		uIConfirmDialog.buttonConfirm.OnTapUp += ButtonRejectConfirm_OnTapUp;
		uIConfirmDialog.buttonConfirm.OnFocusEnter += ButtonRejectConfirm_OnFocusEnter;
		uIConfirmDialog.buttonConfirm.OnFocusExit += ButtonRejectConfirm_OnFocusExit;
		uIConfirmDialog.yesHighlightContainer = uIContainer6.GetContainer("YesHighlight");
		uIConfirmDialog.buttonCancel = uIContainer6.GetElement<UIButton>("No");
		uIConfirmDialog.buttonCancel.OnTapUp += ButtonRejectCancel_BlankDisabled_OnTapUp;
		uIConfirmDialog.buttonCancel.OnFocusEnter += ButtonRejectCancel_OnFocusEnter;
		uIConfirmDialog.buttonCancel.OnFocusExit += ButtonRejectCancel_OnFocusExit;
		uIConfirmDialog.noHighlightContainer = uIContainer6.GetContainer("NoHighlight");
		textboxRejectDescription = uIContainer6.GetElement<UITextbox>("ConsumesShotText");
		detailBlankUpgradeContainer = containerAbilityDetails.GetContainer("BlankUpgrade");
		textboxBlankUpgradeAvailable = detailBlankUpgradeContainer.GetElement<UITextbox>("UpgradeAvailable");
		imageAbilityDetailBlankCore = detailBlankUpgradeContainer.GetElement<UIImage>("CoreIcon");
		textboxBlankCoreQuantity = detailBlankUpgradeContainer.GetElement<UITextbox>("CoreQuantity");
		textboxBlankShotQuantity = detailBlankUpgradeContainer.GetElement<UITextbox>("ShotQuantity");
		textboxBlankUpgradeHeader = detailBlankUpgradeContainer.GetElement<UITextbox>("AugmentedHeader");
		textboxBlankUpgradeUpgradeDescription = detailBlankUpgradeContainer.GetElement<UITextbox>("AugmentedDescription");
		imageAbilityDetailBlankWrapper = detailBlankUpgradeContainer.GetElement<UIImage>("OverloadedWrapper");
		buttonAbilityUpgrade = detailBlankUpgradeContainer.GetElement<UIButton>("Upgrade");
		buttonAbilityUpgrade.OnTapUp += AbilityUpgradeButton_OnTapUp;
		buttonRejectAbility = detailBlankUpgradeContainer.GetElement<UIButton>("Remove");
		buttonRejectAbility.OnTapUp += RejectionShotButton_OnTapUp_Blank;
		buttonRejectAbility.userData = false;
		detailUpgradedContainer = containerAbilityDetails.GetContainer("Upgraded");
		textboxUpgradedShotQuantity = detailUpgradedContainer.GetElement<UITextbox>("ShotQuantity");
		textboxUpgradedOverloaded = detailUpgradedContainer.GetElement<UITextbox>("Upgraded");
		textboxUpgradedUpgradeDescription = detailUpgradedContainer.GetElement<UITextbox>("AugmentedDescription");
		imageAbilityDetailUpgradedWrapper = detailUpgradedContainer.GetElement<UIImage>("OverloadedWrapper");
		buttonRejectUpgrade = detailUpgradedContainer.GetElement<UIButton>("Remove");
		buttonRejectUpgrade.OnTapUp += RejectionShotButton_OnTapUp_Upgraded;
		buttonRejectUpgrade.userData = true;
		dialogUpgrade = new UIConfirmDialog();
		UIContainer uIContainer7 = (dialogUpgrade.container = detailBlankUpgradeContainer.GetContainer("UpgradeConfirm"));
		dialogUpgrade.buttonConfirm = uIContainer7.GetElement<UIButton>("Yes");
		dialogUpgrade.buttonConfirm.OnTapUp += ButtonAbilityUpgradeConfirm_OnTapUp;
		dialogUpgrade.buttonConfirm.OnFocusEnter += ButtonAbilityUpgradeConfirm_OnFocusEnter;
		dialogUpgrade.buttonConfirm.OnFocusExit += ButtonAbilityUpgradeConfirm_OnFocusExit;
		dialogUpgrade.yesHighlightContainer = uIContainer7.GetContainer("YesHighlight");
		dialogUpgrade.buttonCancel = uIContainer7.GetElement<UIButton>("No");
		dialogUpgrade.buttonCancel.OnTapUp += ButtonAbilityUpgradeCancel_OnTapUp;
		dialogUpgrade.buttonCancel.OnFocusEnter += ButtonAbilityUpgradeCancel_OnFocusEnter;
		dialogUpgrade.buttonCancel.OnFocusExit += ButtonAbilityUpgradeCancel_OnFocusExit;
		dialogUpgrade.noHighlightContainer = uIContainer7.GetContainer("NoHighlight");
		buttonContinue = GetElement<UIButton>("ContinueButton");
		UITextbox continueText = GetElement<UITextbox>("ContinueText");
		Color continueOrigColor = continueText.color;
		buttonContinue.OnTapUp += ContinueButton_OnTapUp;
		buttonContinue.OnFocusEnter += delegate
		{
			continueText.color = buttonSelected;
		};
		buttonContinue.OnFocusExit += delegate
		{
			continueText.color = continueOrigColor;
		};
		HideAll();
	}

	private void ButtonNamePrev_OnFocusEnter()
	{
		imageNamePrevHighlight.Show();
	}

	private void ButtonNamePrev_OnFocusExit()
	{
		imageNamePrevHighlight.Hide();
	}

	private void ButtonNameNext_OnFocusEnter()
	{
		imageNameNextHighlight.Show();
	}

	private void ButtonNameNext_OnFocusExit()
	{
		imageNameNextHighlight.Hide();
	}

	private void BackgroundButton_OnFocusEnterWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			abilityUIList[num.Value].imageIconHighlightedBorder.Show();
		}
	}

	private void BackgroundButton_OnFocusExitWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			abilityUIList[num.Value].imageIconHighlightedBorder.Hide();
		}
	}

	private void ButtonAugmentConfirm_OnFocusEnterWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			UIConfirmDialog dialogAugment = abilitySelectItems[num.Value].dialogAugment;
			dialogAugment.yesHighlightContainer.ShowAll();
			dialogAugment.buttonConfirm.textbox.color = kHighlightTextColor;
		}
	}

	private void ButtonAugmentConfirm_OnFocusExitWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			UIConfirmDialog dialogAugment = abilitySelectItems[num.Value].dialogAugment;
			dialogAugment.yesHighlightContainer.HideAll();
			dialogAugment.buttonConfirm.textbox.color = kRegularTextColor;
		}
	}

	private void ButtonAugmentCancel_OnFocusEnterWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			UIConfirmDialog dialogAugment = abilitySelectItems[num.Value].dialogAugment;
			dialogAugment.noHighlightContainer.ShowAll();
			dialogAugment.buttonCancel.textbox.color = kHighlightTextColor;
		}
	}

	private void ButtonAugmentCancel_OnFocusExitWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			UIConfirmDialog dialogAugment = abilitySelectItems[num.Value].dialogAugment;
			dialogAugment.noHighlightContainer.HideAll();
			dialogAugment.buttonCancel.textbox.color = kRegularTextColor;
		}
	}

	private void IconButton_OnFocusEnterWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			AbilityListItem abilityListItem = abilityUIList[num.Value];
			abilityListItem.imageIconHighlightedBorder.Show();
			if (abilityListItem.abilityGazeOff.IsRunning)
			{
				abilityListItem.abilityGazeOff.Stop();
			}
			float x = abilityListItem.container.transform.localScale.x;
			float num2 = 1f - (x - 1.25f) / -0.25f;
			float duration = (1f - num2) * 0.15f;
			abilityListItem.abilityGazeOn.Start(num2, 1f, duration, 0f);
		}
	}

	private void IconButton_OnFocusExitWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			AbilityListItem abilityListItem = abilityUIList[num.Value];
			abilityListItem.imageIconHighlightedBorder.Hide();
			if (abilityListItem.abilityGazeOn.IsRunning)
			{
				abilityListItem.abilityGazeOn.Stop();
			}
			float x = abilityListItem.container.transform.localScale.x;
			float num2 = (x - 1f) / 0.25f;
			float duration = num2 * 0.15f;
			abilityListItem.abilityGazeOff.Start(num2, 0f, duration, 0f);
		}
	}

	private void AbilityButton_OnFocusEnterWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			AbilitySelectItem abilitySelectItem = abilitySelectItems[num.Value];
			abilitySelectItem.imageIconBorder.Hide();
			abilitySelectItem.imageIconHighlightedBorder.Show();
		}
	}

	private void AbilityButton_OnFocusExitWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			AbilitySelectItem abilitySelectItem = abilitySelectItems[num.Value];
			abilitySelectItem.imageIconBorder.Show();
			abilitySelectItem.imageIconHighlightedBorder.Hide();
		}
	}

	private void ButtonAbilityUpgradeConfirm_OnFocusEnter()
	{
		dialogUpgrade.yesHighlightContainer.ShowAll();
		dialogUpgrade.buttonConfirm.textbox.color = kHighlightTextColor;
	}

	private void ButtonAbilityUpgradeConfirm_OnFocusExit()
	{
		dialogUpgrade.yesHighlightContainer.HideAll();
		dialogUpgrade.buttonConfirm.textbox.color = kRegularTextColor;
	}

	private void ButtonAbilityUpgradeCancel_OnFocusEnter()
	{
		dialogUpgrade.noHighlightContainer.ShowAll();
		dialogUpgrade.buttonCancel.textbox.color = kHighlightTextColor;
	}

	private void ButtonAbilityUpgradeCancel_OnFocusExit()
	{
		dialogUpgrade.noHighlightContainer.HideAll();
		dialogUpgrade.buttonCancel.textbox.color = kRegularTextColor;
	}

	private void ButtonRejectConfirm_OnFocusEnter()
	{
		dialogReject.yesHighlightContainer.ShowAll();
		dialogReject.buttonConfirm.textbox.color = kHighlightTextColor;
	}

	private void ButtonRejectConfirm_OnFocusExit()
	{
		dialogReject.yesHighlightContainer.HideAll();
		dialogReject.buttonConfirm.textbox.color = kRegularTextColor;
	}

	private void ButtonRejectCancel_OnFocusEnter()
	{
		dialogReject.noHighlightContainer.ShowAll();
		dialogReject.buttonCancel.textbox.color = kHighlightTextColor;
	}

	private void ButtonRejectCancel_OnFocusExit()
	{
		dialogReject.noHighlightContainer.HideAll();
		dialogReject.buttonCancel.textbox.color = kRegularTextColor;
	}

	private void ButtonPrevious_OnFocusEnter()
	{
		imagePreviousHighlight.Show();
	}

	private void ButtonPrevious_OnFocusExit()
	{
		imagePreviousHighlight.Hide();
	}

	private void ButtonNext_OnFocusEnter()
	{
		imageNextHighlight.Show();
	}

	private void ButtonNext_OnFocusExit()
	{
		imageNextHighlight.Hide();
	}

	private bool ButtonNamePrev_OnTapUp()
	{
		PreviousCharacter();
		nameArrows = true;
		return true;
	}

	private bool ButtonNameNext_OnTapUp()
	{
		NextCharacter();
		nameArrows = true;
		return true;
	}

	private bool BackgroundButton_OnTapUpWithUserData(object userData)
	{
		int num = (int)userData;
		tutorialOpenedAbility.Set();
		activeAbilityIndex = num - 1;
		AbilityMeta firstAbilityAtLevel = activePartyMembers[activeUnitIndex].GetFirstAbilityAtLevel(activeAbilityIndex);
		AbilityMeta secondAbilityAtLevel = activePartyMembers[activeUnitIndex].GetSecondAbilityAtLevel(activeAbilityIndex);
		singleAbilitySelect = firstAbilityAtLevel.name == secondAbilityAtLevel.name;
		AbilitySelectItem abilitySelectItem = abilitySelectItems[0];
		AbilitySelectItem abilitySelectItem2 = abilitySelectItems[1];
		abilitySelectItem.buttonIcon.image.SetImage(firstAbilityAtLevel.Icon);
		abilitySelectItem.textboxName.SetKey(firstAbilityAtLevel.GetDisplayName(activePartyMembers[activeUnitIndex].characterData));
		abilitySelectItem.textboxDescription.SetKey(firstAbilityAtLevel.description);
		abilitySelectItem.buttonIcon.OnTapUpWithUserData -= AbilityButton_OnTapUpWithUserData;
		abilitySelectItem.buttonIcon.OnFocusEnterWithUserData -= AbilityButton_OnFocusEnterWithUserData;
		abilitySelectItem.buttonIcon.OnFocusExitWithUserData -= AbilityButton_OnFocusExitWithUserData;
		if (!singleAbilitySelect)
		{
			abilitySelectItem2.buttonIcon.image.SetImage(secondAbilityAtLevel.Icon);
			abilitySelectItem2.textboxName.SetKey(secondAbilityAtLevel.GetDisplayName(activePartyMembers[activeUnitIndex].characterData));
			abilitySelectItem2.textboxDescription.SetKey(secondAbilityAtLevel.description);
			abilitySelectItem2.buttonIcon.OnTapUpWithUserData -= AbilityButton_OnTapUpWithUserData;
			abilitySelectItem2.buttonIcon.OnFocusEnterWithUserData -= AbilityButton_OnFocusEnterWithUserData;
			abilitySelectItem2.buttonIcon.OnFocusExitWithUserData -= AbilityButton_OnFocusExitWithUserData;
		}
		containerStatsAndBio.SetInteractable(interactable: false);
		containerAbilitySelect.ShowAll();
		containerAbilityDetails.HideAll();
		imageAbilitySelectDismissHighlight.Hide();
		abilitySelectItem.imageIconHighlightedBorder.Hide();
		abilitySelectItem.dialogAugment.container.HideAll();
		abilitySelectItem2.dialogAugment.container.HideAll();
		if (!singleAbilitySelect)
		{
			abilitySelectItem2.imageIconHighlightedBorder.Hide();
		}
		else
		{
			abilitySelectItem2.container.HideAll();
		}
		int itemCount = Party.Inst.GetItemCount(Item.Augment.ToMeta());
		textboxAugmentNumber.Clear();
		textboxAugmentNumber.Append("x ");
		textboxAugmentNumber.Append(itemCount);
		textboxAugmentNumber.Present();
		if (itemCount > 0)
		{
			abilitySelectItem.buttonIcon.OnTapUpWithUserData += AbilityButton_OnTapUpWithUserData;
			abilitySelectItem.buttonIcon.OnFocusEnterWithUserData += AbilityButton_OnFocusEnterWithUserData;
			abilitySelectItem.buttonIcon.OnFocusExitWithUserData += AbilityButton_OnFocusExitWithUserData;
			abilitySelectItem.buttonIcon.userData = 0;
			abilitySelectItem.buttonIcon.alpha = 1f;
			abilitySelectItem.imageIconBorder.alpha = 1f;
			if (!singleAbilitySelect)
			{
				abilitySelectItem2.buttonIcon.OnTapUpWithUserData += AbilityButton_OnTapUpWithUserData;
				abilitySelectItem2.buttonIcon.OnFocusEnterWithUserData += AbilityButton_OnFocusEnterWithUserData;
				abilitySelectItem2.buttonIcon.OnFocusExitWithUserData += AbilityButton_OnFocusExitWithUserData;
				abilitySelectItem2.buttonIcon.userData = 1;
				abilitySelectItem2.buttonIcon.alpha = 1f;
				abilitySelectItem2.imageIconBorder.alpha = 1f;
			}
		}
		else
		{
			abilitySelectItem.buttonIcon.alpha = UIElement.kDisabledAlpha;
			abilitySelectItem.imageIconBorder.alpha = UIElement.kDisabledAlpha;
			if (!singleAbilitySelect)
			{
				abilitySelectItem2.buttonIcon.alpha = UIElement.kDisabledAlpha;
				abilitySelectItem2.imageIconBorder.alpha = UIElement.kDisabledAlpha;
			}
		}
		return true;
	}

	private bool AbilityButton_OnTapUpWithUserData(object userData)
	{
		int? num = (int)userData;
		if (num.HasValue)
		{
			abilitySelectItems[num.Value].dialogAugment.buttonConfirm.userData = num;
			abilitySelectItems[num.Value].dialogAugment.buttonCancel.userData = num;
			switch (num.Value)
			{
			case 0:
				abilitySelectItems[1].container.HideAll();
				abilitySelectItems[0].dialogAugment.container.ShowAll();
				abilitySelectItems[0].dialogAugment.yesHighlightContainer.HideAll();
				abilitySelectItems[0].dialogAugment.buttonConfirm.textbox.color = kRegularTextColor;
				abilitySelectItems[0].dialogAugment.noHighlightContainer.HideAll();
				abilitySelectItems[0].dialogAugment.buttonCancel.textbox.color = kRegularTextColor;
				break;
			case 1:
				abilitySelectItems[0].container.HideAll();
				abilitySelectItems[1].dialogAugment.container.ShowAll();
				abilitySelectItems[1].dialogAugment.yesHighlightContainer.HideAll();
				abilitySelectItems[1].dialogAugment.buttonConfirm.textbox.color = kRegularTextColor;
				abilitySelectItems[1].dialogAugment.noHighlightContainer.HideAll();
				abilitySelectItems[1].dialogAugment.buttonCancel.textbox.color = kRegularTextColor;
				break;
			}
		}
		return true;
	}

	private void EnableNextPreviousButtons(bool value)
	{
		buttonNext._SetInteractable(value);
		buttonPrev._SetInteractable(value);
		buttonNext.alpha = ((!value) ? UIElement.kDisabledAlpha : 1f);
		buttonPrev.alpha = ((!value) ? UIElement.kDisabledAlpha : 1f);
	}

	private bool ButtonAugmentConfirm_OnTapUpWithUserData(object userData)
	{
		int? num = (int)userData;
		if (num.HasValue)
		{
			Party.Inst.RemoveItemFromInventory(Item.Augment.ToMeta(), 1);
			tutorialSelectedAbility.Set();
			switch (num.Value)
			{
			case 0:
				activePartyMembers[activeUnitIndex].SetFirstAbilityChoiceAtLevel(activeAbilityIndex);
				break;
			case 1:
				activePartyMembers[activeUnitIndex].SetSecondAbilityChoiceAtLevel(activeAbilityIndex);
				break;
			}
			AbilityListItem abilityListItem = abilityUIList[activeAbilityIndex];
			abilityListItem.buttonBackground.OnTapUpWithUserData -= BackgroundButton_OnTapUpWithUserData;
			abilityListItem.buttonBackground.OnFocusEnterWithUserData -= BackgroundButton_OnFocusEnterWithUserData;
			abilityListItem.buttonBackground.OnFocusExitWithUserData -= BackgroundButton_OnFocusExitWithUserData;
			activeAbilityIndex = -1;
			ShowPartyMemberDetails(activeUnitIndex);
		}
		return true;
	}

	private bool ButtonAugmentCancel_OnTapUp()
	{
		abilitySelectItems[0].container.ShowAll();
		abilitySelectItems[0].imageIconHighlightedBorder.Hide();
		abilitySelectItems[0].dialogAugment.container.HideAll();
		if (!singleAbilitySelect)
		{
			abilitySelectItems[1].container.ShowAll();
			abilitySelectItems[1].imageIconHighlightedBorder.Hide();
			abilitySelectItems[1].dialogAugment.container.HideAll();
		}
		return true;
	}

	private bool IconButton_OnTapUpWithUserData(object userData)
	{
		int? num = userData as int?;
		if (num.HasValue)
		{
			PartyMember partyMember = activePartyMembers[activeUnitIndex];
			PartyAbility abilityAtIndex = partyMember.GetAbilityAtIndex(num.Value);
			AbilityMeta abilityMeta = PartyLevelLUT.GetAbilityMeta(abilityAtIndex.ability);
			activeAbilityIndex = num.Value;
			imageAbilityDetailIcon.SetImage(abilityMeta.Icon);
			string displayName = abilityMeta.GetDisplayName(activePartyMembers[activeUnitIndex].characterData);
			string text = Localisation.Retrieve(displayName);
			textboxAbilityDetailDescription.SetKey(abilityMeta.description);
			textboxBlankDisabledUpgradeDescription.SetKey(abilityMeta.augmentDescription);
			textboxBlankUpgradeUpgradeDescription.SetKey(abilityMeta.augmentDescription);
			textboxUpgradedUpgradeDescription.SetKey(abilityMeta.augmentDescription);
			containerStatsAndBio.SetInteractable(interactable: false);
			containerAbilitySelect.HideAll();
			containerAbilityDetails.ShowAll();
			imageAbilityDetailDismissHighlight.Hide();
			if (text.Length > 8)
			{
				textboxAbilityDetailNameShort.Hide();
				imageAbilityDetailShortNameBG.Hide();
				textboxAbilityDetailNameLong.SetKey(displayName);
			}
			else
			{
				textboxAbilityDetailNameLong.Hide();
				imageAbilityDetailLongNameBG.Hide();
				textboxAbilityDetailNameShort.SetKey(displayName);
			}
			dialogReject.container.HideAll();
			dialogUpgrade.container.HideAll();
			int itemCount = Party.Inst.GetItemCount(Item.Rejection_Shot.ToMeta());
			bool flag = CanReject(num.Value);
			if (!abilityAtIndex.upgraded)
			{
				if (hasUpgradesAvailable)
				{
					int itemCount2 = Party.Inst.GetItemCount(Item.Atlantium_Core.ToMeta());
					detailBlankUpgradeDisabledContainer.HideAll();
					detailUpgradedContainer.HideAll();
					textboxBlankCoreQuantity.Clear();
					textboxBlankCoreQuantity.Append("x ");
					textboxBlankCoreQuantity.Append(itemCount2);
					textboxBlankCoreQuantity.Present();
					textboxBlankShotQuantity.Clear();
					textboxBlankShotQuantity.Append("x ");
					textboxBlankShotQuantity.Append(itemCount);
					textboxBlankShotQuantity.Present();
					buttonAbilityUpgrade._SetInteractable(itemCount2 > 0);
					buttonAbilityUpgrade.alpha = ((itemCount2 <= 0) ? UIElement.kDisabledAlpha : 1f);
					buttonRejectAbility._SetInteractable(flag);
					buttonRejectAbility.alpha = ((!flag) ? UIElement.kDisabledAlpha : 1f);
				}
				else
				{
					int absLevelNeededToGainUpgrade = partyMember.GetAbsLevelNeededToGainUpgrade();
					detailBlankUpgradeContainer.HideAll();
					detailUpgradedContainer.HideAll();
					if (absLevelNeededToGainUpgrade == 0)
					{
						textboxBlankDisabledUpgradeAtRank.SetKey("UICHARACTERDETAILS_ABILITYDETAIL_UPGRADECAPACITYREACHED");
					}
					else
					{
						textboxBlankDisabledUpgradeAtRank.SetKey("UICHARACTERDETAILS_ABILITYDETAIL_UPGRADEAVAILABLEATRANK", absLevelNeededToGainUpgrade);
					}
					textboxBlankDisabledShotQuantity.Clear();
					textboxBlankDisabledShotQuantity.Append("x ");
					textboxBlankDisabledShotQuantity.Append(itemCount);
					textboxBlankDisabledShotQuantity.Present();
					buttonRejectAbilityDisabled._SetInteractable(flag);
					buttonRejectAbilityDisabled.alpha = ((!flag) ? UIElement.kDisabledAlpha : 1f);
				}
			}
			else
			{
				detailBlankUpgradeDisabledContainer.HideAll();
				detailBlankUpgradeContainer.HideAll();
				textboxUpgradedShotQuantity.Clear();
				textboxUpgradedShotQuantity.Append("x ");
				textboxUpgradedShotQuantity.Append(itemCount);
				textboxUpgradedShotQuantity.Present();
				buttonRejectUpgrade._SetInteractable(flag);
				buttonRejectUpgrade.alpha = ((!flag) ? UIElement.kDisabledAlpha : 1f);
			}
			if (!SaveData.data.tutorials.viewedOverloadingTutorial)
			{
				if (!TryPlayAtlantiumCoreTutorial(abilityAtIndex) && !SaveData.data.tutorials.viewedRejectionShotTutorial)
				{
					TryPlayRejectionShotTutorial();
				}
			}
			else if (!SaveData.data.tutorials.viewedRejectionShotTutorial)
			{
				TryPlayRejectionShotTutorial();
			}
		}
		return true;
	}

	private bool CanReject(int abilityIndex)
	{
		int itemCount = Party.Inst.GetItemCount(Item.Rejection_Shot.ToMeta());
		return itemCount > 0 && (abilityIndex > 2 || GetSelectedAbility().upgraded);
	}

	private bool CanOverload(PartyAbility ability)
	{
		int itemCount = Party.Inst.GetItemCount(Item.Atlantium_Core.ToMeta());
		return itemCount > 0 && hasUpgradesAvailable && !ability.upgraded;
	}

	private PartyAbility GetSelectedAbility()
	{
		PartyMember partyMember = activePartyMembers[activeUnitIndex];
		return partyMember.GetAbilityAtIndex(activeAbilityIndex);
	}

	private bool IsAbilityInTopRow()
	{
		return activeAbilityIndex <= 2;
	}

	private bool AbilityUpgradeButton_OnTapUp()
	{
		dialogUpgrade.container.ShowAll();
		dialogUpgrade.yesHighlightContainer.HideAll();
		dialogUpgrade.buttonConfirm.textbox.color = kRegularTextColor;
		dialogUpgrade.noHighlightContainer.HideAll();
		dialogUpgrade.buttonCancel.textbox.color = kRegularTextColor;
		textboxAbilityDetailDescription.Hide();
		textboxBlankUpgradeUpgradeDescription.Hide();
		textboxBlankUpgradeHeader.Hide();
		textboxBlankUpgradeAvailable.Hide();
		textboxBlankCoreQuantity.Hide();
		imageAbilityDetailBlankCore.Hide();
		imageAbilityDetailBlankWrapper.Hide();
		DisableOverloadReject();
		return true;
	}

	private void DisableOverloadReject()
	{
		buttonAbilityUpgrade._SetInteractable(interact: false);
		buttonAbilityUpgrade.alpha = UIElement.kDisabledAlpha;
		buttonRejectAbility._SetInteractable(interact: false);
		buttonRejectAbility.alpha = UIElement.kDisabledAlpha;
	}

	private void ShowRejectDialog()
	{
		string key = ((!GetSelectedAbility().upgraded) ? "UI_REJECTION_SHOT_AUGMENT_ONLY" : "UI_REJECTION_SHOT_CORE_AND_AUG");
		if (IsAbilityInTopRow())
		{
			key = "UI_REJECTION_SHOT_CORE_ONLY";
		}
		textboxRejectDescription.SetKey(key);
		dialogReject.container.ShowAll();
		dialogReject.yesHighlightContainer.HideAll();
		dialogReject.buttonConfirm.textbox.color = kRegularTextColor;
		dialogReject.noHighlightContainer.HideAll();
		dialogReject.buttonCancel.textbox.color = kRegularTextColor;
		DisableOverloadReject();
	}

	private bool RejectionShotButton_OnTapUp_BlankDisabled()
	{
		ShowRejectDialog();
		textboxAbilityDetailDescription.Hide();
		textboxBlankDisabledUpgradeDescription.Hide();
		textboxBlankDisabledUpgradeAtRank.Hide();
		textboxBlankDisabledUpgradeHeader.Hide();
		imageAbilityDetailBlankDisabledWrapper.Hide();
		return true;
	}

	private bool RejectionShotButton_OnTapUp_Blank()
	{
		ShowRejectDialog();
		textboxAbilityDetailDescription.Hide();
		textboxBlankUpgradeUpgradeDescription.Hide();
		textboxBlankUpgradeHeader.Hide();
		textboxBlankUpgradeAvailable.Hide();
		textboxBlankCoreQuantity.Hide();
		imageAbilityDetailBlankCore.Hide();
		imageAbilityDetailBlankWrapper.Hide();
		return true;
	}

	private bool RejectionShotButton_OnTapUp_Upgraded()
	{
		ShowRejectDialog();
		textboxAbilityDetailDescription.Hide();
		textboxUpgradedUpgradeDescription.Hide();
		textboxUpgradedOverloaded.Hide();
		imageAbilityDetailUpgradedWrapper.Hide();
		return true;
	}

	private bool ButtonAbilityUpgradeConfirm_OnTapUp()
	{
		PartyAbility selectedAbility = GetSelectedAbility();
		selectedAbility.upgraded = true;
		Party.Inst.RemoveItemFromInventory(Item.Atlantium_Core.ToMeta(), 1);
		activeAbilityIndex = -1;
		ShowPartyMemberDetails(activeUnitIndex);
		return true;
	}

	private bool ButtonAbilityUpgradeCancel_OnTapUp()
	{
		IconButton_OnTapUpWithUserData(activeAbilityIndex);
		return true;
	}

	private bool ButtonRejectConfirm_OnTapUp()
	{
		PartyMember partyMember = activePartyMembers[activeUnitIndex];
		PartyAbility abilityAtIndex = partyMember.GetAbilityAtIndex(activeAbilityIndex);
		if (abilityAtIndex.upgraded)
		{
			Party.Inst.AddItemToInventory(Item.Atlantium_Core.ToMeta(), 1);
		}
		abilityAtIndex.upgraded = false;
		if (!IsAbilityInTopRow())
		{
			partyMember.RemoveAbilityAtIndex(activeAbilityIndex);
		}
		Party.Inst.RemoveItemFromInventory(Item.Rejection_Shot.ToMeta(), 1);
		ShowPartyMemberDetails(activeUnitIndex);
		return true;
	}

	private bool ButtonRejectCancel_BlankDisabled_OnTapUp()
	{
		IconButton_OnTapUpWithUserData(activeAbilityIndex);
		return true;
	}

	private bool ButtonRejectCancel_Blank_OnTapUp()
	{
		dialogReject.container.HideAll();
		textboxAbilityDetailDescription.Show();
		textboxBlankUpgradeUpgradeDescription.Show();
		textboxBlankUpgradeHeader.Show();
		textboxBlankUpgradeAvailable.Show();
		textboxBlankCoreQuantity.Show();
		imageAbilityDetailBlankCore.Show();
		imageAbilityDetailBlankWrapper.Show();
		return true;
	}

	private bool ButtonRejectCancel_Upgraded_OnTapUp()
	{
		dialogReject.container.HideAll();
		textboxAbilityDetailDescription.Show();
		textboxUpgradedUpgradeDescription.Show();
		textboxUpgradedOverloaded.Show();
		imageAbilityDetailUpgradedWrapper.Show();
		return true;
	}

	private bool StatsTab_OnTapUp()
	{
		containerAbilityDetails.HideAll();
		containerAbilitySelect.HideAll();
		containerStatsAndBio.ShowAll();
		imagePreviousHighlight.Hide();
		imageNextHighlight.Hide();
		ResetMissionPips();
		activeAbilityIndex = -1;
		bioContainer.HideAll();
		return true;
	}

	private bool BioTab_OnTapUp()
	{
		containerAbilityDetails.HideAll();
		containerAbilitySelect.HideAll();
		containerStatsAndBio.ShowAll();
		imagePreviousHighlight.Hide();
		imageNextHighlight.Hide();
		activeAbilityIndex = -1;
		statsContainer.HideAll();
		return true;
	}

	private bool PreviousButton_OnTapUp()
	{
		PreviousCharacter();
		nameArrows = false;
		return true;
	}

	private bool NextButton_OnTapUp()
	{
		NextCharacter();
		nameArrows = false;
		return true;
	}

	public bool ContinueButton_OnTapUp()
	{
		if ((bool)tutorialUseRejectionShotRoutine.running)
		{
			tutorialUseRejectionShotRoutine.host.Pause(tutorialUseRejectionShotRoutine);
			tutorialUseRejectionShotRoutine.Reset();
			UIAmbientSubtitles.Inst.HideAll();
			TutorialUseRejectionCleanup(tutorialComplete: false);
		}
		else if ((bool)tutorialUseAtlantiumCoreRoutine.running)
		{
			tutorialUseAtlantiumCoreRoutine.host.Pause(tutorialUseAtlantiumCoreRoutine);
			tutorialUseAtlantiumCoreRoutine.Reset();
			UIAmbientSubtitles.Inst.HideAll();
			TutorialUseAtlantiumCoreCleanup(tutorialComplete: false);
		}
		SaveData.SaveProgress();
		switch (state)
		{
		case DetailsScreenState.MissionEnd:
			OnContinue.Trigger();
			break;
		case DetailsScreenState.FullPartyEdit:
			Singleton<UIC>.Inst.Pop();
			break;
		}
		return true;
	}

	private bool ButtonCancel_OnTapUp()
	{
		ShowPartyMemberDetails(activeUnitIndex);
		return true;
	}

	private void PreviousCharacter()
	{
		activeUnitIndex--;
		if (activeUnitIndex < 0)
		{
			activeUnitIndex = activePartyMembers.sLength - 1;
		}
		ShowPartyMemberDetails(activeUnitIndex);
	}

	private void NextCharacter()
	{
		activeUnitIndex++;
		if (activeUnitIndex >= activePartyMembers.sLength)
		{
			activeUnitIndex = 0;
		}
		ShowPartyMemberDetails(activeUnitIndex);
	}

	public override void ShowAll()
	{
		tutorialOpenedAbility.Clear();
		tutorialSelectedAbility.Clear();
		ShowPartyMemberDetails(0);
	}

	public void SetStateForFullPartyEdit(ConstArray<PartyMember> members)
	{
		state = DetailsScreenState.FullPartyEdit;
		activePartyMembers = members;
	}

	public void SetStateForMissionEnd(ConstArray<PartyMember> members)
	{
		state = DetailsScreenState.MissionEnd;
		activePartyMembers = members;
		shownPartyMembers.Clear();
	}

	private void ShowPartyMemberDetails(int index)
	{
		base.ShowAll();
		activeUnitIndex = index;
		if (activePartyMembers == null)
		{
			return;
		}
		PartyMember partyMember = activePartyMembers[index];
		if (partyMember == null)
		{
			return;
		}
		containerStatsAndBio.SetInteractable(interactable: true);
		containerAbilitySelect.HideAll();
		containerAbilityDetails.HideAll();
		dialogUpgrade.container.HideAll();
		dialogReject.container.HideAll();
		if (activePartyMembers.Length == 1)
		{
			buttonNext.Hide();
			imageNextHighlight.Hide();
			buttonNameNext.Hide();
			buttonPrev.Hide();
			imagePreviousHighlight.Hide();
			buttonNamePrev.Hide();
		}
		else if (!SaveData.data.tutorials.appliedAugment && Party.Inst.FindStackByMeta(Item.Augment.ToMeta()).count > 0 && !tutorialUseAugmentRoutine.running)
		{
			UnityEngine.Debug.Log("STARTED APPLIED AUGMENT TUTORIAL!");
			LR.Host.StartTopLevel(tutorialUseAugmentRoutine, null, prestep: true);
		}
		int num = partyMember.Level + 2;
		int upgrades = partyMember.Upgrades;
		int upgradedAbilitiesNum = partyMember.GetUpgradedAbilitiesNum();
		hasUpgradesAvailable = upgrades > upgradedAbilitiesNum;
		textboxUpgradeSlots.SetNumber(upgrades - upgradedAbilitiesNum);
		if (!shownPartyMembers.Contains(partyMember))
		{
			shownPartyMembers.Add(partyMember);
		}
		for (int i = 0; i < abilityUIList.Length; i++)
		{
			AbilityListItem abilityListItem = abilityUIList[i];
			abilityListItem.imageIconHighlightedBorder.Hide();
			abilityListItem.imageNameShortBG.Hide();
			abilityListItem.imageNameShortBG.alpha = 0f;
			abilityListItem.imageNameLongBG.Hide();
			abilityListItem.imageNameLongBG.alpha = 0f;
			abilityListItem.textboxName.Hide();
			abilityListItem.textboxName.alpha = 0f;
			if (i < num)
			{
				PartyAbility abilityAtIndex = partyMember.GetAbilityAtIndex(i);
				abilityListItem.imageDisabledIcon.Hide();
				if (abilityAtIndex != null)
				{
					AbilityMeta abilityMeta = PartyLevelLUT.GetAbilityMeta(abilityAtIndex.ability);
					abilityListItem.backgroundBoxCollider.enabled = false;
					if (!abilityAtIndex.upgraded)
					{
						abilityListItem.imageUpgraded.Hide();
					}
					string displayName = abilityMeta.GetDisplayName(activePartyMembers[activeUnitIndex].characterData);
					string text = Localisation.Retrieve(displayName);
					abilityListItem.textboxName.SetKey(displayName);
					abilityListItem.buttonBackground.Hide();
					abilityListItem.buttonIcon.image.SetImage(abilityMeta.Icon);
					abilityListItem.buttonIcon.userData = i;
					abilityListItem.textboxEmptySlot.Hide();
				}
				else
				{
					abilityListItem.buttonIcon.Hide();
					abilityListItem.imageUpgraded.Hide();
					abilityListItem.buttonBackground.OnTapUpWithUserData -= BackgroundButton_OnTapUpWithUserData;
					abilityListItem.buttonBackground.OnFocusEnterWithUserData -= BackgroundButton_OnFocusEnterWithUserData;
					abilityListItem.buttonBackground.OnFocusExitWithUserData -= BackgroundButton_OnFocusExitWithUserData;
					abilityListItem.buttonBackground.OnTapUpWithUserData += BackgroundButton_OnTapUpWithUserData;
					abilityListItem.buttonBackground.OnFocusEnterWithUserData += BackgroundButton_OnFocusEnterWithUserData;
					abilityListItem.buttonBackground.OnFocusExitWithUserData += BackgroundButton_OnFocusExitWithUserData;
					abilityListItem.backgroundBoxCollider.enabled = true;
					abilityListItem.buttonBackground.userData = i;
				}
			}
			else
			{
				abilityListItem.buttonBackground.OnTapUpWithUserData -= BackgroundButton_OnTapUpWithUserData;
				abilityListItem.buttonBackground.OnFocusEnterWithUserData -= BackgroundButton_OnFocusEnterWithUserData;
				abilityListItem.buttonBackground.OnFocusExitWithUserData -= BackgroundButton_OnFocusExitWithUserData;
				abilityListItem.backgroundBoxCollider.enabled = false;
				abilityListItem.buttonIcon.Hide();
				abilityListItem.imageUpgraded.Hide();
				abilityListItem.imageIconBorder.Hide();
				abilityListItem.textboxEmptySlot.Hide();
			}
		}
		CharacterData characterData = partyMember.characterData;
		textboxUnitName.SetKey(characterData.DisplayName);
		textboxUnitNameShadow.SetKey(characterData.DisplayName);
		imageNamePrevHighlight.Hide();
		imageNameNextHighlight.Hide();
		imagePortrait.SetImage(characterData.GetDetailsSprite());
		textboxHP.SetNumber(characterData.HPMax(partyMember.Level));
		textboxAP.SetNumber(characterData.APMax(partyMember.Level));
		textboxSpeed.SetNumber(characterData.MovementDistancePerTurn(partyMember.Level));
		textboxDodge.Clear();
		textboxDodge.Append(characterData.ChanceToDodge(partyMember.Level));
		textboxDodge.Append("%");
		textboxDodge.Present();
		ResetMissionPips();
		textboxStatsWeaponName.SetKey(characterData.weaponNameKey);
		int @class = (int)characterData.Class;
		bool isMelee = characterData.mainWeaponAttributes.IsMelee;
		int num2 = ((!isMelee) ? CharacterStats.LUT_WeaponBaseDamageRanged[@class, partyMember.Level] : CharacterStats.LUT_WeaponBaseDamageMelee[@class, partyMember.Level]);
		textboxStatsWeaponDamage.SetNumber(characterData.mainWeaponAttributes.Damage + num2);
		int value = ((!isMelee) ? CharacterStats.LUT_WeaponBaseAccuracyRanged[@class, partyMember.Level] : CharacterStats.LUT_WeaponBaseAccuracyMelee[@class, partyMember.Level]);
		value = Mathf.Clamp(value, 0, 100);
		textboxStatsWeaponAccuracy.Clear();
		textboxStatsWeaponAccuracy.Append(value);
		textboxStatsWeaponAccuracy.Append("%");
		textboxStatsWeaponAccuracy.Present();
		int num3 = CharacterStats.LUT_WeaponBaseCritical[@class, partyMember.Level];
		num3 += characterData.mainWeaponAttributes.CriticalChance;
		num3 = Mathf.Clamp(num3, 0, 100);
		textboxStatsWeaponCritHitChance.Clear();
		textboxStatsWeaponCritHitChance.Append(num3);
		textboxStatsWeaponCritHitChance.Append("%");
		textboxStatsWeaponCritHitChance.Present();
		textboxBioDescription.Clear();
		textboxBioDescription.AppendKey(characterData.bio.bio_Quote);
		textboxBioDescription.Append("\n");
		textboxBioDescription.Append("\n");
		textboxBioDescription.AppendKey(characterData.bio.bio_Age);
		textboxBioDescription.Append("\n");
		textboxBioDescription.AppendKey(characterData.bio.bio_Class);
		textboxBioDescription.Append("\n");
		textboxBioDescription.AppendKey(characterData.bio.bio_GGS);
		textboxBioDescription.Append("\n");
		textboxBioDescription.AppendKey(characterData.bio.bio_Augments);
		textboxBioDescription.Present();
		imagePreviousHighlight.Hide();
		imageNextHighlight.Hide();
		if (prevActiveUnitIndex.HasValue && prevActiveUnitIndex.Value != activeUnitIndex)
		{
			if (prevActiveUnitIndex.Value == activeUnitIndex + 1 || (prevActiveUnitIndex.Value == 0 && activeUnitIndex == activePartyMembers.Length - 1))
			{
				if (nameArrows)
				{
					imageNamePrevHighlight.Show();
					imageNameNextHighlight.Hide();
				}
				else
				{
					imagePreviousHighlight.Show();
					imageNextHighlight.Hide();
				}
			}
			else if (prevActiveUnitIndex.Value == activeUnitIndex - 1 || (prevActiveUnitIndex.Value == activePartyMembers.Length - 1 && activeUnitIndex == 0))
			{
				if (nameArrows)
				{
					imageNamePrevHighlight.Hide();
					imageNameNextHighlight.Show();
				}
				else
				{
					imagePreviousHighlight.Hide();
					imageNextHighlight.Show();
				}
			}
		}
		prevActiveUnitIndex = activeUnitIndex;
		bioContainer.HideAll();
		containerAbilitySelect.HideAll();
		containerAbilityDetails.HideAll();
	}

	public void ResetMissionPips()
	{
		PartyMember partyMember = activePartyMembers[activeUnitIndex];
		int remainingMissionsNeededToLevelUp = partyMember.GetRemainingMissionsNeededToLevelUp();
		int missionsBetweenLevels = partyMember.GetMissionsBetweenLevels(partyMember.Level, partyMember.Level + 1);
		if (remainingMissionsNeededToLevelUp == missionsBetweenLevels || remainingMissionsNeededToLevelUp < 0)
		{
			imageXPPip1.Hide();
			imageXPPip2.Hide();
		}
		else
		{
			switch (missionsBetweenLevels)
			{
			case 2:
				if (remainingMissionsNeededToLevelUp == 1)
				{
					imageXPPip1.transform.localPosition = twoXPPosition;
					imageXPPip1.transform.localScale = twoXPScale;
					imageXPPip2.Hide();
				}
				break;
			case 3:
				if (remainingMissionsNeededToLevelUp < 3)
				{
					imageXPPip1.transform.localPosition = threeXPPosition1;
					imageXPPip1.transform.localScale = threeXPScale;
					if (remainingMissionsNeededToLevelUp < 2)
					{
						imageXPPip2.transform.localPosition = threeXPPosition2;
						imageXPPip2.transform.localScale = threeXPScale;
					}
				}
				break;
			}
		}
		if (remainingMissionsNeededToLevelUp >= 0)
		{
			textboxMissionsToLevelUp.SetNumber(remainingMissionsNeededToLevelUp);
		}
		else
		{
			textboxMissionsToLevelUp.SetNumber(0);
		}
	}

	public override bool OnBackButtonPressed()
	{
		if (containerAbilitySelect.IsShown || containerAbilityDetails.IsShown)
		{
			ShowPartyMemberDetails(activeUnitIndex);
		}
		else
		{
			if ((bool)tutorialUseAtlantiumCoreRoutine.running)
			{
				tutorialUseAtlantiumCoreRoutine.Reset();
				tutorialUseAtlantiumCoreRoutine.host.Pause(tutorialUseAtlantiumCoreRoutine);
				TutorialUseAtlantiumCoreCleanup(tutorialComplete: false);
			}
			if ((bool)tutorialUseAugmentRoutine.running)
			{
				tutorialUseAugmentRoutine.Reset();
				tutorialUseAugmentRoutine.host.Pause(tutorialUseAugmentRoutine);
				TutorialUseAugmentCleanup();
			}
			if ((bool)tutorialUseRejectionShotRoutine.running)
			{
				tutorialUseRejectionShotRoutine.Reset();
				tutorialUseRejectionShotRoutine.host.Pause(tutorialUseRejectionShotRoutine);
				TutorialUseRejectionCleanup(tutorialComplete: false);
			}
			ContinueButton_OnTapUp();
		}
		return true;
	}

	private IEnumerator<HagletYieldTerm> TutorialUseAugmentRoutine()
	{
		AbilityListItem abilityItemToPulse = abilityUIList[3];
		abilityItemToPulse.imageIconBorder.PulseAlphaStart(LR.Host, 0.1f);
		abilityItemToPulse.textboxEmptySlot.PulseAlphaStart(LR.Host, 0.1f);
		EnableNextPreviousButtons(value: false);
		containerNextPrev.SetInteractable(interactable: false);
		buttonContinue._SetInteractable(interact: false);
		buttonContinue.alpha = UIElement.kDisabledAlpha;
		yield return Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstAugmentInstall_1, null);
		HagletYieldTerm waitForTut = Wait.None;
		if (!tutorialOpenedAbility)
		{
			waitForTut |= (HagletYieldTerm)Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstAugmentInstall_3, null);
		}
		yield return waitForTut & Wait.Until(tutorialOpenedAbility);
		abilityItemToPulse.imageIconBorder.PulseAlphaStop();
		abilityItemToPulse.textboxEmptySlot.PulseAlphaStop();
		abilitySelectItems[0].imageIconBorder.PulseAlphaStart(LR.Host, 0.1f);
		yield return Wait.Until(tutorialSelectedAbility) & Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstAugmentInstall_4, null);
		SaveData.data.tutorials.appliedAugment = true;
		abilitySelectItems[0].imageIconBorder.PulseAlphaStop();
		yield return Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstAugmentInstall_5, null);
		TutorialUseAugmentCleanup();
	}

	private void TutorialUseAugmentCleanup()
	{
		UIAmbientSubtitles.Inst.HideAll();
		VOController.Inst.VOStop();
		AbilityListItem abilityListItem = abilityUIList[3];
		abilityListItem.imageIconBorder.PulseAlphaStop();
		abilityListItem.textboxEmptySlot.PulseAlphaStop();
		abilitySelectItems[0].imageIconBorder.PulseAlphaStop();
		EnableNextPreviousButtons(value: true);
		containerNextPrev.SetInteractable(interactable: true);
		buttonContinue._SetInteractable(interact: true);
		buttonContinue.alpha = 1f;
	}

	private bool TryPlayAtlantiumCoreTutorial(PartyAbility partyAbility)
	{
		if (!tutorialUseAtlantiumCoreRoutine.running && !tutorialUseRejectionShotRoutine.running && !tutorialUseAugmentRoutine.running && CanOverload(partyAbility))
		{
			LR.Host.StartTopLevel(tutorialUseAtlantiumCoreRoutine);
			return true;
		}
		return false;
	}

	private IEnumerator<HagletYieldTerm> TutorialUseAtlantiumCore()
	{
		buttonAbilityUpgrade.PulseAlphaStart(LR.Host, 0.1f);
		yield return Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogOverloadingAbility, null);
		TutorialUseAtlantiumCoreCleanup(tutorialComplete: true);
		if (!SaveData.data.tutorials.viewedRejectionShotTutorial)
		{
			TryPlayRejectionShotTutorial();
		}
	}

	private void TutorialUseAtlantiumCoreCleanup(bool tutorialComplete)
	{
		UIAmbientSubtitles.Inst.HideAll();
		VOController.Inst.VOStop();
		buttonAbilityUpgrade.PulseAlphaStop();
		if (tutorialComplete)
		{
			SaveData.data.tutorials.viewedOverloadingTutorial = true;
		}
	}

	private bool TryPlayRejectionShotTutorial()
	{
		if (!tutorialUseRejectionShotRoutine.running && !tutorialUseAugmentRoutine.running && CanReject(activeAbilityIndex))
		{
			LR.Host.StartTopLevel(tutorialUseRejectionShotRoutine);
			return true;
		}
		return false;
	}

	private IEnumerator<HagletYieldTerm> TutorialUseRejectionShotRoutine()
	{
		UnityEngine.Debug.Log("STARTED REJECTION SHOT TUTORIAL!");
		buttonRejectAbility.PulseAlphaStart(LR.Host, 0.1f);
		yield return Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstRejectionShot_1, null);
		yield return Singleton<UIFlow>.Inst.DisplayDialog(Tutorials.dialogFirstRejectionShot_2, null);
		TutorialUseRejectionCleanup(tutorialComplete: true);
	}

	private void TutorialUseRejectionCleanup(bool tutorialComplete)
	{
		UIAmbientSubtitles.Inst.HideAll();
		VOController.Inst.VOStop();
		buttonRejectAbility.PulseAlphaStop();
		if (tutorialComplete)
		{
			SaveData.data.tutorials.viewedRejectionShotTutorial = true;
		}
	}
}
public class UICharacters : UIContainer
{
	private struct CharacterIcon
	{
		public UIImage imageBackdrop;

		public UIImage imageHeaderBackdrop;

		public UIImage imageIcon;

		public UITextbox textHeader;

		public UIButton button;
	}

	private static UICharacters _instance;

	public Sprite[] backdropSprites;

	private const float fadeDur = 0.3f;

	private const float fullShowTime = 1.8000001f;

	private const float fullHideTime = 2.1000001f;

	private const float lookAwayCloseAngle = 15f;

	private UIImage imageBackdrop;

	private CharacterIcon[] charIcons;

	private AnimFloat animTime;

	private AnimationCurve backdropCurve;

	private AnimationCurve[] iconCurves;

	private bool isPeeking;

	private TileActionSwapMap peekingAtTile;

	public static UICharacters Inst => _instance;

	public override void Initialise()
	{
		Transform child = base.transform.GetChild(0);
		for (int i = 1; i <= 5; i++)
		{
			Transform transform = UnityEngine.Object.Instantiate(AEResources.LoadFirstResource<GameObject>("UI/P_UICharacterIcon")).transform;
			Transform transform2 = child.FindChild("Icon Point " + i);
			transform.name = "Icon " + i;
			transform.transform.parent = child;
			transform.transform.localPosition = transform2.localPosition;
			transform.transform.localScale = transform2.localScale;
			transform.transform.localRotation = transform2.localRotation;
		}
		base.Initialise();
	}

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		imageBackdrop = GetElement<UIImage>("Backdrop");
		charIcons = new CharacterIcon[5];
		int num = charIcons.Length;
		while (--num >= 0)
		{
			string text = "Icon " + (num + 1);
			ref CharacterIcon reference = ref charIcons[num];
			CharacterIcon characterIcon = (reference = new CharacterIcon
			{
				imageBackdrop = GetElement<UIImage>("Backdrop", text),
				imageHeaderBackdrop = GetElement<UIImage>("Header Backdrop", "Backdrop", text),
				imageIcon = GetElement<UIImage>("Icon", "Backdrop", text),
				textHeader = GetElement<UITextbox>("Header", "Backdrop", text),
				button = GetElement<UIButton>("Backdrop", text)
			});
			characterIcon.imageBackdrop.OnAwakeLR();
			characterIcon.imageHeaderBackdrop.OnAwakeLR();
			characterIcon.imageIcon.OnAwakeLR();
			characterIcon.textHeader.OnAwakeLR();
			characterIcon.button.OnAwakeLR();
			characterIcon.button.OnTapUpWithUserData += SelectUnit;
		}
		animTime = new AnimFloat(0f);
		backdropCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.3f, 1f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f));
		iconCurves = new AnimationCurve[5]
		{
			new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.3f, 0f), new Keyframe(0.6f, 1f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f)),
			new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.6f, 0f), new Keyframe(0.90000004f, 1f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f)),
			new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.90000004f, 0f), new Keyframe(1.2f, 1f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f)),
			new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1.2f, 0f), new Keyframe(1.5f, 1f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f)),
			new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1.5f, 0f), new Keyframe(1.8000001f, 1f), new Keyframe(2.1000001f, 0f))
		};
		base.HideAll();
	}

	public override void ShowAll()
	{
		if (!isShown)
		{
			base.ShowAll();
			ConstArray<Unit> activeMembers = Singleton<PC>.Inst.GetTeam().GetActiveMembers();
			int length = (int)activeMembers.Length;
			int num = Mathf.Clamp(length - 2, 0, backdropSprites.Length - 1);
			imageBackdrop.SetImage(backdropSprites[num]);
			imageBackdrop.Show();
			int num2 = charIcons.Length;
			while (--num2 >= 0)
			{
				bool flag = num2 < length;
				CharacterIcon characterIcon = charIcons[num2];
				UIImage uIImage = characterIcon.imageBackdrop;
				bool flag2 = flag;
				characterIcon.textHeader.IsShown = flag2;
				flag2 = flag2;
				characterIcon.imageIcon.IsShown = flag2;
				flag2 = flag2;
				characterIcon.imageHeaderBackdrop.IsShown = flag2;
				uIImage.IsShown = flag2;
				if (flag)
				{
					characterIcon.imageIcon.SetImage(activeMembers[num2].charData.GetIconSprite());
					characterIcon.textHeader.SetKey(activeMembers[num2].charData.DisplayName);
					characterIcon.button.userData = activeMembers[num2];
				}
			}
			AC.Inst.PlayOneShot2D("event:/sfx/ui/character panel hover");
		}
		if (animTime.Value < 1.8000001f)
		{
			animTime.AnimateTo(1.8000001f, 1.8000001f - animTime.Value);
		}
		else if (animTime.Value > 1.8000001f)
		{
			animTime.AnimateTo(1.8000001f, 2.1000001f - animTime.Value);
		}
	}

	public override bool HideAll()
	{
		if (!isShown)
		{
			return true;
		}
		AC.Inst.PlayOneShot2D("event:/sfx/ui/character panel close");
		animTime.AnimateTo(2.1000001f, 2.1000001f - animTime.Value);
		return true;
	}

	private void Update()
	{
		if ((bool)animTime.animating)
		{
			animTime.Update();
			UpdateDisplay();
			if (!animTime.animating && animTime.Value == 2.1000001f)
			{
				animTime.Value = 0f;
				base.HideAll();
			}
		}
		else if (isShown)
		{
			Transform transform = IC.Inst.transform;
			Vector3 center = imageBackdrop.spriteRenderer.bounds.center;
			if (Vector3.Angle(IC.Inst.transform.forward, center - transform.position) >= 15f)
			{
				HideAll();
			}
		}
	}

	private void UpdateDisplay()
	{
		imageBackdrop.alpha = backdropCurve.Evaluate(animTime.Value);
		int num = charIcons.Length;
		while (--num >= 0)
		{
			CharacterIcon characterIcon = charIcons[num];
			if (characterIcon.imageBackdrop.IsShown)
			{
				AnimationCurve animationCurve = iconCurves[num];
				characterIcon.imageBackdrop.alpha = animationCurve.Evaluate(animTime.Value);
				characterIcon.imageHeaderBackdrop.alpha = animationCurve.Evaluate(animTime.Value);
				characterIcon.imageIcon.alpha = animationCurve.Evaluate(animTime.Value);
				characterIcon.textHeader.alpha = animationCurve.Evaluate(animTime.Value);
			}
		}
	}

	private bool SelectUnit(object unit)
	{
		Unit unit2 = (Unit)unit;
		Singleton<PC>.Inst.SetSelectedUnit(unit2);
		AC.Inst.PlayOneShot2D("event:/sfx/ui/character panel button");
		if (isPeeking)
		{
			peekingAtTile.HideReturnFromPeekButton();
			if (unit2.IsPeeking)
			{
				Singleton<MC>.Inst.TransitionToMap(unit2.map, null, OnReturnedFromPeek);
			}
		}
		return true;
	}

	public void SetIsPeekingAtTile(TileActionSwapMap swapTile = null)
	{
		peekingAtTile = swapTile;
		if ((bool)peekingAtTile)
		{
			isPeeking = true;
		}
		else
		{
			isPeeking = false;
		}
	}

	private void OnReturnedFromPeek(Map currentMap, Map targetMap)
	{
		Singleton<PC>.Inst.GetLeader().OnExitPeek();
	}
}
public class UICheatBox : MonoBehaviour
{
	private UIButton button;

	private int buttonClicked;

	private void Awake()
	{
		button = GetComponent<UIButton>();
		button.OnTapDown += delegate
		{
			buttonClicked++;
			if (buttonClicked >= 10)
			{
				buttonClicked = 0;
				AC.Inst.PlayOneShot2D("event:/sfx/ui/cheat");
				try
				{
					HAGIS.MissionComplete();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
		};
	}
}
[Serializer.ExcludeAllFieldsFromAssignablesTo]
[Serializer.ExcludeAllFields]
public class UIContainer : MonoBehaviour
{
	protected UIElement[] elements;

	protected UIContainer[] containers;

	private SpriteRenderer[] allImages;

	private UITextbox[] allText;

	[NonSerialized]
	public HagletTrigger OnShow = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnHide = new HagletTrigger();

	public HagletFlag Shown = new HagletFlag();

	[HideInInspector]
	public bool allowShowHideCommands = true;

	protected bool isShown;

	private float _alpha = 1f;

	private float _parentAlpha = 1f;

	private bool _interactable = true;

	public HagletResettable fadeResettable;

	private float fadeStartVal;

	private float fadeTargetVal;

	private float fadeLength;

	private bool fadeHideOnComplete;

	public bool IsShown
	{
		get
		{
			return isShown;
		}
		set
		{
			if (isShown != value)
			{
				if (value)
				{
					ShowAll();
				}
				else
				{
					HideAll();
				}
			}
		}
	}

	public virtual void Initialise()
	{
		elements = GetComponentsInChildren<UIElement>(includeInactive: true);
		List<UIElement> list = new List<UIElement>(elements);
		int num = 0;
		while (num < list.Count)
		{
			if (list[num].GetComponentInAscendant<UIContainer>() != this)
			{
				list.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
		elements = list.ToArray();
		List<UIContainer> list2 = new List<UIContainer>();
		GetComponentsInChildren(includeInactive: true, list2);
		int num2 = 0;
		while (num2 < list2.Count)
		{
			UIContainer uIContainer = list2[num2];
			UIContainer componentInAscendant = uIContainer.transform.parent.GetComponentInAscendant<UIContainer>();
			if (componentInAscendant != this || uIContainer == this)
			{
				list2.RemoveAt(num2);
			}
			else
			{
				num2++;
			}
		}
		containers = list2.ToArray();
		fadeResettable = new HagletResettable(FadeRoutine(), base.name + " Fade Routine");
		ReconstructAllOrderedElementLists();
	}

	public virtual void OnAwakeLR()
	{
	}

	public virtual void ShowAll()
	{
		base.gameObject.SetActive(value: true);
		isShown = true;
		int num = elements.Length;
		while (--num >= 0)
		{
			if (elements[num].allowShowHideCommands)
			{
				elements[num].Show();
			}
		}
		int num2 = containers.Length;
		while (--num2 >= 0)
		{
			if (containers[num2].allowShowHideCommands)
			{
				containers[num2].ShowAll();
			}
		}
		OnBecameVisible();
	}

	public float GetAlpha()
	{
		return _alpha;
	}

	public void SetAlpha(float alpha)
	{
		_alpha = alpha;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetParentAlpha(_alpha * _parentAlpha);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j]._SetParentAlpha(_alpha * _parentAlpha);
		}
	}

	public void _SetParentAlpha(float alpha)
	{
		_parentAlpha = alpha;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetParentAlpha(_alpha * _parentAlpha);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j]._SetParentAlpha(_alpha * _parentAlpha);
		}
	}

	public void SetInteractable(bool interactable)
	{
		_interactable = interactable;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetInteractable(interactable);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j].SetInteractable(interactable);
		}
	}

	protected void ReconstructAllOrderedElementLists()
	{
		allImages = GetComponentsInChildren<SpriteRenderer>(includeInactive: true);
		allText = GetComponentsInChildren<UITextbox>(includeInactive: true);
	}

	public void AddToRenderOrder(int spriteOrderJump)
	{
		int i = 0;
		for (int num = allImages.Length; i < num; i++)
		{
			allImages[i].sortingOrder += spriteOrderJump;
		}
		int j = 0;
		for (int num2 = allText.Length; j < num2; j++)
		{
			allText[j].sortingOrder += spriteOrderJump;
			allText[j].UpdateSortingOrder();
		}
	}

	public void ShowAtIndex(uint index)
	{
		isShown = true;
		elements[index].Show();
	}

	public virtual bool HideAll()
	{
		isShown = false;
		int num = elements.Length;
		while (--num >= 0)
		{
			if (elements[num].allowShowHideCommands)
			{
				elements[num].Hide();
			}
		}
		int num2 = containers.Length;
		while (--num2 >= 0)
		{
			if (containers[num2].allowShowHideCommands)
			{
				containers[num2].HideAll();
			}
		}
		Shown.Clear();
		OnHide.Trigger();
		return true;
	}

	public T GetElement<T>(string name, string parentName = null, string grandParentName = null) where T : UIElement
	{
		for (int i = 0; i < elements.Length; i++)
		{
			UIElement uIElement = elements[i];
			if (uIElement is T && name == uIElement.name && (parentName == null || uIElement.transform.parent.name == parentName) && (grandParentName == null || uIElement.transform.parent.parent.name == grandParentName))
			{
				return (T)uIElement;
			}
		}
		return (T)null;
	}

	public T GetElement<T>(int index) where T : UIElement
	{
		return elements[index] as T;
	}

	public UIContainer GetContainer(string name)
	{
		return GetContainerOrNull(name);
	}

	public UIContainer GetContainerOrNull(string name)
	{
		for (int i = 0; i < containers.Length; i++)
		{
			UIContainer uIContainer = containers[i];
			if (uIContainer.name == name)
			{
				return uIContainer;
			}
		}
		return null;
	}

	public UIContainer[] GetContainers()
	{
		return containers;
	}

	protected void OnBecameVisible()
	{
		Shown.Set();
		OnShow.Trigger();
	}

	public virtual bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	public virtual void OnActionButtonPressed()
	{
	}

	public virtual bool ConsumesActionButton()
	{
		return false;
	}

	public HagletEvent StartFade(float targetVal, float fadeLength, bool hideOnComplete = false)
	{
		fadeStartVal = _alpha;
		fadeTargetVal = targetVal;
		this.fadeLength = fadeLength;
		fadeHideOnComplete = hideOnComplete;
		HagletResettable.StartOrReset(fadeResettable, LR.Host);
		return fadeResettable.completed;
	}

	private IEnumerator<HagletYieldTerm> FadeRoutine()
	{
		float t = 0f;
		while (t < 1f)
		{
			t += Time.deltaTime / fadeLength;
			SetAlpha(Mathf.Lerp(fadeStartVal, fadeTargetVal, t));
			yield return null;
		}
		if (fadeHideOnComplete)
		{
			HideAll();
		}
	}
}
public class UICredits : UIContainer
{
	private static UICredits _instance;

	private Credits credits;

	private System.Random random;

	private UITextbox textboxCompany;

	private UITextbox textboxRole;

	private UIContainer containerNames;

	private UITextbox[] textboxNames;

	private FMOD.Studio.EventInstance creditsMusic;

	public bool autoPlayMusic = true;

	private HagletResettable creditsRoutine;

	public static UICredits Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		creditsRoutine = new HagletResettable(CreditsRoutine());
		credits = Credits.Load("credits");
		random = new System.Random();
		textboxCompany = GetElement<UITextbox>("Company");
		textboxRole = GetElement<UITextbox>("Role");
		containerNames = GetContainer("Names");
		textboxNames = new UITextbox[4]
		{
			containerNames.GetElement<UITextbox>("Name0"),
			containerNames.GetElement<UITextbox>("Name1"),
			containerNames.GetElement<UITextbox>("Name2"),
			containerNames.GetElement<UITextbox>("Name3")
		};
	}

	public override void ShowAll()
	{
		if (autoPlayMusic && SaveData.data.IsMissionComplete(22, 0))
		{
			PlayCreditsTheme();
		}
		LR.Host.StartTopLevel(creditsRoutine);
	}

	private static void Shuffle<T>(IList<T> list, System.Random rnd)
	{
		for (int i = 0; i < list.Count; i++)
		{
			Swap(list, i, rnd.Next(i, list.Count));
		}
	}

	private static void Swap<T>(IList<T> list, int i, int j)
	{
		T value = list[i];
		list[i] = list[j];
		list[j] = value;
	}

	private IEnumerator<HagletYieldTerm> CreditsRoutine()
	{
		base.ShowAll();
		for (int i = 0; i < credits.companies.Count; i++)
		{
			Credits.Company company2 = credits.companies[i];
			if (company2.shuffle)
			{
				for (int j = 0; j < company2.roles.Count; j++)
				{
					Credits.Role role2 = company2.roles[j];
					Shuffle(role2.people, random);
				}
				Shuffle(company2.roles, random);
			}
		}
		bool isVisible = false;
		for (int cIdx = 0; cIdx < credits.companies.Count; cIdx++)
		{
			Credits.Company company = credits.companies[cIdx];
			Credits.Company companyNext = credits.companies[Mathf.Min(cIdx + 1, credits.companies.Count - 1)];
			for (int rIdx = 0; rIdx < company.roles.Count; rIdx++)
			{
				Credits.Role role = company.roles[rIdx];
				Credits.Role roleNext = company.roles[Mathf.Min(rIdx + 1, company.roles.Count - 1)];
				bool isLastRole = rIdx == company.roles.Count - 1;
				for (int personGroupIdx = 0; personGroupIdx < role.people.Count; personGroupIdx += 4)
				{
					bool isLastGroup = personGroupIdx + 4 >= role.people.Count;
					int num = Mathf.Min(role.people.Count, personGroupIdx + 4);
					containerNames.HideAll();
					int num2 = 0;
					for (int k = personGroupIdx; k < num; k++)
					{
						string text = role.people[k];
						textboxNames[num2++].SetText(text);
					}
					containerNames.ShowAll();
					for (int l = num2; l < 4; l++)
					{
						textboxNames[l].Hide();
					}
					textboxCompany.SetText(company.name);
					textboxRole.SetText(role.name);
					if (!isVisible)
					{
						isVisible = true;
						containerNames.SetAlpha(1f);
						SetAlpha(0f);
						yield return StartFade(1f, 0.75f);
					}
					else
					{
						textboxCompany.AlphaAnimate(LR.Host, 1f, 0.5f);
						textboxRole.AlphaAnimate(LR.Host, 1f, 0.5f);
						yield return containerNames.StartFade(1f, 0.5f);
					}
					yield return Wait.ForSeconds(1.45f);
					if (isLastGroup && isLastRole && company.name != companyNext.name)
					{
						textboxCompany.AlphaAnimate(LR.Host, 0f, 0.5f);
					}
					if (isLastGroup && role.name != roleNext.name)
					{
						textboxRole.AlphaAnimate(LR.Host, 0f, 0.5f);
					}
					yield return containerNames.StartFade(0f, 0.5f);
				}
			}
		}
		yield return StartFade(0f, 0.75f, hideOnComplete: true);
		if (creditsMusic.isValid())
		{
			creditsMusic.stop(STOP_MODE.ALLOWFADEOUT);
		}
		yield return Singleton<UIC>.Inst.Pop();
	}

	public override bool OnBackButtonPressed()
	{
		if (creditsMusic.isValid())
		{
			creditsMusic.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if ((bool)creditsRoutine.running)
		{
			creditsRoutine.host.Pause(creditsRoutine);
		}
		creditsRoutine.Reset();
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	public void PlayCreditsTheme()
	{
		creditsMusic = AC.Inst.PlayOneShot2D("event:/music/tracks/basic/credits theme");
	}
}
public class UIDebug : UIContainer
{
	private class RoutineTest : HagletResettable
	{
		public RoutineTest()
			: base(RoutineTestImpl())
		{
		}

		public static IEnumerator<HagletYieldTerm> RoutineTestImpl()
		{
			yield return Wait.ForSeconds(1f);
			yield return Wait.ForSeconds(1f) | Wait.ForSeconds(2f);
			yield return Wait.ForSteps(50uL) | Wait.ForSteps(60uL);
			UnityEngine.Debug.Log("Done!");
		}
	}

	private const float fadeDur = 0.3f;

	private Transform root;

	private UIContainer mainMenu;

	private UIContainer openMissionMenu;

	private UIContainer combatMenu;

	private UIContainer currMenu;

	private UITextbox revision;

	private UITextbox lastSkipPoint;

	private UITextbox timeScale;

	private UIButton upArrow;

	private UIButton downArrow;

	private UIButton bigUpArrow;

	private UIButton bigDownArrow;

	private UIButton returnArrow;

	private UIButton timeUp;

	private UIButton timeDown;

	private Func<object, bool> openMenu;

	private Action<object> openMenuDown;

	private bool lockedToPC;

	private static RoutineTest[] tests = new RoutineTest[1000];

	private static int testsNum = 40;

	private Haglet autoSkip;

	public static UIDebug Inst { get; private set; }

	public bool LockedToPC
	{
		get
		{
			return lockedToPC;
		}
		set
		{
			if (lockedToPC != value)
			{
				lockedToPC = value;
				if (lockedToPC)
				{
					base.transform.SetParent(IC.Inst.transform);
				}
				else
				{
					base.transform.SetParent(null);
				}
			}
		}
	}

	private event Action<int> _scrollAction;

	public event Action<int> scrollAction
	{
		add
		{
			if (value != null)
			{
				_scrollAction += value;
				UIButton uIButton = bigUpArrow;
				bool flag = true;
				downArrow.IsShown = flag;
				flag = flag;
				bigDownArrow.IsShown = flag;
				flag = flag;
				upArrow.IsShown = flag;
				uIButton.IsShown = flag;
			}
		}
		remove
		{
			if (value != null)
			{
				_scrollAction -= value;
			}
		}
	}

	public static void LogAllLoadedTexturesToCSV()
	{
		string text = UnityEngine.Application.persistentDataPath + "/memory_dump_textures.csv";
		using (StreamWriter streamWriter = new StreamWriter(text))
		{
			Texture2D[] array = Resources.FindObjectsOfTypeAll<Texture2D>();
			Texture2D[] array2 = array;
			foreach (Texture2D texture2D in array2)
			{
				long num = Profiler.GetRuntimeMemorySize(texture2D);
				double num2 = (double)num / 1024.0 / 1024.0;
				string text2 = ((!string.IsNullOrEmpty(texture2D.name)) ? texture2D.name : "null");
				streamWriter.WriteLine(text2 + "," + num2.ToString("F2"));
			}
			array = null;
		}
		UnityEngine.Debug.Log("Dumped all loaded textures to '" + text + "'");
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		for (int i = 0; i < tests.Length; i++)
		{
			tests[i] = new RoutineTest();
		}
		Inst = this;
		root = base.transform.GetChild(0);
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].allowShowHideCommands = false;
		}
		int num2 = elements.Length;
		while (--num2 >= 0)
		{
			elements[num2].allowShowHideCommands = false;
		}
		mainMenu = (currMenu = GetContainer("Main Menu"));
		upArrow = GetElement<UIButton>("Up Arrow");
		downArrow = GetElement<UIButton>("Down Arrow");
		bigUpArrow = GetElement<UIButton>("BigUp Arrow");
		bigDownArrow = GetElement<UIButton>("BigDown Arrow");
		returnArrow = GetElement<UIButton>("Return Arrow");
		revision = GetElement<UITextbox>("Revision");
		lastSkipPoint = GetElement<UITextbox>("LastSkipPoint");
		openMenu = delegate(object newMenu)
		{
			int num4 = containers.Length;
			while (--num4 >= 0)
			{
				GameObject obj2 = containers[num4].gameObject;
				bool active2 = containers[num4] == (UIContainer)newMenu;
				containers[num4].IsShown = active2;
				obj2.SetActive(active2);
			}
			currMenu = (UIContainer)newMenu;
			returnArrow.IsShown = currMenu != mainMenu;
			return true;
		};
		openMenuDown = delegate(object newMenu)
		{
			int num3 = containers.Length;
			while (--num3 >= 0)
			{
				GameObject obj = containers[num3].gameObject;
				bool active = containers[num3] == (UIContainer)newMenu;
				containers[num3].IsShown = active;
				obj.SetActive(active);
			}
			currMenu = (UIContainer)newMenu;
			returnArrow.IsShown = currMenu != mainMenu;
		};
		UIButton element = mainMenu.GetElement<UIButton>("Combat");
		element.OnTapUpWithUserData += openMenu;
		element.userData = (combatMenu = GetContainer("Combat Menu"));
		upArrow.OnTapUp += delegate
		{
			this._scrollAction(1);
			return true;
		};
		downArrow.OnTapUp += delegate
		{
			this._scrollAction(-1);
			return true;
		};
		bigUpArrow.OnTapUp += delegate
		{
			this._scrollAction(5);
			return true;
		};
		bigDownArrow.OnTapUp += delegate
		{
			this._scrollAction(-5);
			return true;
		};
		returnArrow.OnTapUpWithUserData += openMenu;
		returnArrow.userData = mainMenu;
		HideAll();
		UIButton element2 = mainMenu.GetElement<UIButton>("Win Mission");
		element2.OnTapUp += delegate
		{
			HAGIS.MissionComplete();
			return true;
		};
		element2.OnTapUp += HideAll;
		UIButton element3 = mainMenu.GetElement<UIButton>("Lose Mission");
		element3.OnTapUp += delegate
		{
			HAGIS.MissionFailed();
			return true;
		};
		element3.OnTapUp += HideAll;
		UIButton element4 = mainMenu.GetElement<UIButton>("Suspend Mission");
		element4.OnTapUp += delegate
		{
			Singleton<UIFlow>.Inst.StartMissionToMainMenu();
			return true;
		};
		element4.OnTapUp += HideAll;
		UIButton element5 = mainMenu.GetElement<UIButton>("Abort Mission");
		element5.OnTapUp += delegate
		{
			SaveData.ClearMission();
			Singleton<UIFlow>.Inst.StartMissionToMainMenu();
			return true;
		};
		element5.OnTapUp += HideAll;
		UIButton toggleAutoReload = mainMenu.GetElement<UIButton>("Toggle Auto-Reload");
		toggleAutoReload.OnTapUp += delegate
		{
			LR.DEBUG_autoReload = !LR.DEBUG_autoReload;
			UnityEngine.Debug.LogFormat("Auto-Reload is now {0}", (!LR.DEBUG_autoReload) ? "off" : "on");
			toggleAutoReload.textbox.SetText((!LR.DEBUG_autoReload) ? "Off!" : "On!");
			DelayResetButton(toggleAutoReload, "Toggle Auto-Reload");
			return true;
		};
		UIButton element6 = mainMenu.GetElement<UIButton>("Haglet Stack");
		Color color = element6.textbox.color;
		color.a *= 0.25f;
		element6.textbox.color = color;
		element6.enabled = false;
		UIButton element7 = mainMenu.GetElement<UIButton>("Play Anim");
		element7.OnTapUpWithUserData += openMenu;
		element7.userData = GetContainer("Play Anim Menu");
		UIButton element8 = mainMenu.GetElement<UIButton>("Game Info");
		element8.OnTapUpWithUserData += openMenu;
		element8.userData = GetContainer("Game Info Menu");
		UIButton element9 = mainMenu.GetElement<UIButton>("Combat");
		element9.OnTapUpWithUserData += openMenu;
		element9.userData = (combatMenu = GetContainer("Combat Menu"));
		UIButton element10 = mainMenu.GetElement<UIButton>("Save Data");
		element10.OnTapUpWithUserData += openMenu;
		element10.userData = (combatMenu = GetContainer("Save Data Menu"));
		mainMenu.GetElement<UIButton>("Skip").OnTapUp += delegate
		{
			if (MR.Inst != null)
			{
				MR.Inst.Skip();
			}
			else if (RR.Inst != null)
			{
				RR.Inst.TrySkipRoomHAGIS();
			}
			return true;
		};
		mainMenu.GetElement<UIButton>("Toggle Auto-Skip").OnTapUp += ToggleAutoSkip;
		UIButton element11 = mainMenu.GetElement<UIButton>("Log Perf Stats");
		Color color2 = element11.textbox.color;
		color2.a *= 0.25f;
		element11.textbox.color = color2;
		element11.enabled = false;
		UIButton element12 = mainMenu.GetElement<UIButton>("Missions");
		element12.OnTapUpWithUserData += openMenu;
		element12.userData = GetContainer("Missions");
		UIButton element13 = mainMenu.GetElement<UIButton>("Misc");
		element13.OnTapUpWithUserData += openMenu;
		element13.userData = GetContainer("Misc Menu");
		UIButton element14 = mainMenu.GetElement<UIButton>("Party Info");
		element14.OnTapDownWithUserData += openMenuDown;
		element14.userData = GetContainer("Party Info Menu");
		UIButton element15 = mainMenu.GetElement<UIButton>("UI Screens");
		element15.OnTapDownWithUserData += openMenuDown;
		element15.userData = GetContainer("UI Screens Menu");
		UIButton element16 = mainMenu.GetElement<UIButton>("Inventory");
		element16.OnTapDownWithUserData += openMenuDown;
		element16.userData = GetContainer("Inventory Menu");
		UIButton element17 = mainMenu.GetElement<UIButton>("Last Exception");
		element17.OnTapDownWithUserData += openMenuDown;
		element17.userData = GetContainer("Last Exception");
		timeScale = mainMenu.GetElement<UITextbox>("TimeTxt");
		timeUp = mainMenu.GetElement<UIButton>("Time++");
		timeUp.OnTapUp += delegate
		{
			Time.timeScale += 1f;
			if (Time.timeScale > 1f)
			{
				GC.Inst.DEBUG_gottaGoFast = true;
			}
			RedrawTime();
			return true;
		};
		timeDown = mainMenu.GetElement<UIButton>("Time--");
		timeDown.OnTapUp += delegate
		{
			Time.timeScale -= 1f;
			if (Time.timeScale < 2f)
			{
				Time.timeScale = 1f;
				GC.Inst.DEBUG_gottaGoFast = false;
			}
			RedrawTime();
			return true;
		};
	}

	public static void DelayResetButton(UIButton button, string originalText)
	{
		if (!(LR.Inst == null) && LR.Host != null)
		{
			LR.Host.StartTopLevel(new Haglet(ResetButton(button, originalText)));
		}
	}

	private static IEnumerator<HagletYieldTerm> ResetButton(UIButton button, string originalText)
	{
		yield return Wait.ForSeconds(1f);
		button.textbox.SetText(originalText);
	}

	public static void StartHagletStressTest()
	{
		for (int i = 0; i < testsNum; i++)
		{
			LR.Host.StartTopLevel(tests[i]);
		}
		testsNum += 10;
	}

	public void PositionToLeft()
	{
		Vector3 position = Singleton<CC>.Inst.transform.position;
		root.position = new Vector3(-0.56f, 1.01f, -0.3f);
		root.LookAt(root.position + (root.position - position), Vector3.up);
	}

	public override void ShowAll()
	{
		base.ShowAll();
		mainMenu.ShowAll();
		currMenu = mainMenu;
		returnArrow.IsShown = false;
		root.position = Crosshair.cursorPos;
		float num = 0.8f;
		Vector3 position = Singleton<CC>.Inst.transform.position;
		Vector3 vector = root.position - position;
		if (vector.magnitude > num)
		{
			vector = vector.normalized * num;
		}
		root.position = position + vector;
		root.LookAt(root.position + (root.position - position), Vector3.up);
		LR.DEBUG_useRadialTicker = false;
		mainMenu.GetElement<UIButton>("Play Anim").enabled = Singleton<PC>.Inst != null;
		RedrawTime();
	}

	public override bool HideAll()
	{
		base.HideAll();
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].HideAll();
		}
		UIButton uIButton = bigUpArrow;
		bool flag = false;
		downArrow.IsShown = flag;
		flag = flag;
		bigDownArrow.IsShown = flag;
		flag = flag;
		upArrow.IsShown = flag;
		uIButton.IsShown = flag;
		LR.DEBUG_useRadialTicker = true;
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void RedrawTime()
	{
		timeScale.Clear();
		timeScale.Append("Time: ");
		timeScale.Append(Time.timeScale.ToString());
		timeScale.Present();
	}

	private void ClearSaveData()
	{
		SaveData.ClearProgress();
		SaveData.ClearMission();
		UnityEngine.Debug.Log("Save data cleared!");
	}

	public bool ToggleAutoSkip()
	{
		if (MR.Inst == null)
		{
			return true;
		}
		HideAll();
		if (autoSkip == null)
		{
			HagletHost host = LR.Host;
			IEnumerator<HagletYieldTerm> routine = AutoRepeatSkip();
			HagletHost host2 = LR.Host;
			host.StartTopLevel(autoSkip = new Haglet(routine, null, HagletStepTime.Update, 20, host2, showInStackTrace: true, delegate
			{
				autoSkip = null;
			}));
		}
		else
		{
			LR.Host.Pause(autoSkip);
			autoSkip = null;
		}
		return true;
	}

	public void TryStopAutoSkip()
	{
		if (autoSkip != null)
		{
			LR.Host.Pause(autoSkip);
			autoSkip = null;
		}
	}

	private IEnumerator<HagletYieldTerm> AutoRepeatSkip()
	{
		do
		{
			MR.Inst.Skip();
			yield return LR.Inst.OnUnloadMissionComplete | Wait.ForSeconds(1f);
		}
		while (LR.Inst.MissionIsOpen);
		autoSkip = null;
	}

	public static void HACK_SetupWillAndArchiOnly()
	{
		SaveData.data.party = new Party();
		CharacterData character = AEResources.LoadFirstResource<CharacterData>("CharacterData/CData_Willa");
		CharacterData character2 = AEResources.LoadFirstResource<CharacterData>("CharacterData/CData_Archi");
		Party.Inst.UnlockPartyMember(character);
		Party.Inst.UnlockPartyMember(character2);
		ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
		for (int i = 0; i < unlockedPartyMembers.Length; i++)
		{
			Party.Inst.TryAddContributedPartyMember(unlockedPartyMembers[i].characterData);
		}
	}

	public static void HACK_SetUpParty()
	{
		Party.Inst.UnlockAllParty();
		ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
		for (int i = 0; i < unlockedPartyMembers.Length; i++)
		{
			Party.Inst.TryAddContributedPartyMember(unlockedPartyMembers[i].characterData);
		}
	}
}
public class UIDebugGameInfo : UIContainer
{
	private UIButton state;

	private UIButton cycleUnits;

	private UIButton cycleVariants;

	private UITextbox stateNext;

	private UITextbox unitAbilities;

	private UITextbox tileStats;

	private UITextbox tileCoord;

	private UITextbox unitWeaponType;

	private UITextbox honestyLevelSec1;

	private UITextbox honestyLevelSec2a;

	private UITextbox honestyLevelSec2b;

	private UITextbox honestyLevelSec3;

	private string unitWithVariant = string.Empty;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		state = GetElement<UIButton>("State");
		stateNext = GetElement<UITextbox>("StateNext");
		tileStats = GetElement<UITextbox>("TileStats");
		tileCoord = GetElement<UITextbox>("TileCoord");
		unitAbilities = GetElement<UITextbox>("UnitAbilities");
		unitWeaponType = GetElement<UITextbox>("UnitWeaponType");
		honestyLevelSec1 = GetElement<UITextbox>("Section_One_Label");
		honestyLevelSec2a = GetElement<UITextbox>("Section_TwoA_Label");
		honestyLevelSec2b = GetElement<UITextbox>("Section_TwoB_Label");
		honestyLevelSec3 = GetElement<UITextbox>("Section_Three_Label");
		cycleUnits = GetElement<UIButton>("CycleUnitsWithVariants");
		cycleUnits.OnTapUp += CycleUnits_OnTapUp;
		cycleVariants = GetElement<UIButton>("CycleVariants");
		cycleVariants.OnTapUp += CycleVariants_OnTapUp;
		UIButton element = GetElement<UIButton>("HurtMePlenty");
		element.OnTapUp += delegate
		{
			GC.Inst.GetActiveTeam().GetTeamLeader().HPDecrement(1);
			return true;
		};
		state.OnTapUp += State_OnTapUp;
		state.OnFocusEnter += delegate
		{
			stateNext.Show();
		};
		state.OnFocusExit += delegate
		{
			stateNext.Hide();
		};
		stateNext.Hide();
		UIButton element2 = GetElement<UIButton>("Section_One_Positive");
		UIButton element3 = GetElement<UIButton>("Section_One_Negative");
		UIButton element4 = GetElement<UIButton>("Section_TwoA_Positive");
		UIButton element5 = GetElement<UIButton>("Section_TwoA_Negative");
		UIButton element6 = GetElement<UIButton>("Section_TwoB_Positive");
		UIButton element7 = GetElement<UIButton>("Section_TwoB_Negative");
		UIButton element8 = GetElement<UIButton>("Section_Three_Positive");
		UIButton element9 = GetElement<UIButton>("Section_Three_Negative");
		element2.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.ONE, 1);
			return true;
		};
		element3.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.ONE, -1);
			return true;
		};
		element4.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.TWO_A, 1);
			return true;
		};
		element5.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.TWO_A, -1);
			return true;
		};
		element6.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.TWO_B, 1);
			return true;
		};
		element7.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.TWO_B, -1);
			return true;
		};
		element8.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.THREE, 1);
			return true;
		};
		element9.OnTapUp += delegate
		{
			DC.Inst.RegisterDialogResponse(DC.GameSection.THREE, -1);
			return true;
		};
	}

	private bool State_OnTapUp()
	{
		GC.State state = GC.Inst.GetState();
		if (state != GC.State.Combat && state == GC.State.RPG)
		{
			GC.Inst._CombatBegin(UnitTeam.Type.Player);
		}
		return true;
	}

	private void UpdateVariantText()
	{
		if (!(GC.Inst == null))
		{
			Unit unitWithId = GC.Inst.GetUnitWithId(unitWithVariant, optional: true);
			if (unitWithId != null)
			{
				CharacterData charData = unitWithId.charData;
				string currentVariant = charData.GetCurrentVariant();
				cycleUnits.textbox.SetText(unitWithId.charData.charName + " (" + currentVariant + ")");
				cycleVariants.textbox.SetText(currentVariant + " (" + (charData.GetCurrentVariantIndex() + 1) + "/" + charData.variantData.Length + ")");
			}
			else
			{
				cycleUnits.textbox.SetText("No Units with Variants");
				cycleVariants.textbox.SetText("N/A");
			}
		}
	}

	private bool CycleUnits_OnTapUp()
	{
		ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
		uint num;
		for (num = 0u; num < unitsAllInWorld.Length && !(unitsAllInWorld[num].generatedID == unitWithVariant); num++)
		{
		}
		uint num2 = num % unitsAllInWorld.Length;
		for (num = (num + 1) % unitsAllInWorld.Length; num != num2; num = (num + 1) % unitsAllInWorld.Length)
		{
			if (unitsAllInWorld[num].charData.variantData != null && unitsAllInWorld[num].charData.variantData.Length > 1)
			{
				unitWithVariant = unitsAllInWorld[num].generatedID;
				break;
			}
		}
		UpdateVariantText();
		return true;
	}

	private bool CycleVariants_OnTapUp()
	{
		if (GC.Inst == null)
		{
			return true;
		}
		Unit unitWithId = GC.Inst.GetUnitWithId(unitWithVariant, optional: true);
		if (unitWithId == null)
		{
			return true;
		}
		CharacterData charData = unitWithId.charData;
		int currentVariantIndex = charData.GetCurrentVariantIndex();
		currentVariantIndex = (currentVariantIndex + 1) % charData.variantData.Length;
		unitWithId.SetVariant(charData.variantData[currentVariantIndex].name);
		UpdateVariantText();
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		unitWithVariant = string.Empty;
		CycleUnits_OnTapUp();
	}

	public override bool HideAll()
	{
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	public void Update()
	{
		state.textbox.SetText("State: " + GC.Inst.GetState());
		switch (GC.Inst.GetState())
		{
		case GC.State.Combat:
			stateNext.SetText("Goto State: " + GC.State.RPG);
			break;
		case GC.State.RPG:
			stateNext.SetText("Goto State: " + GC.State.Combat);
			break;
		}
		Map activeMap = Singleton<MC>.Inst.GetActiveMap();
		if ((bool)activeMap)
		{
			Map.TileHit hit;
			Unit hitUnit;
			string text = ((!activeMap.Raycast(IC.Inst.transform.position, IC.Inst.transform.forward, out hit, out hitUnit)) ? "Out of bounds" : ("Current Tile: [" + hit.coord.x + ", " + hit.coord.y + "] " + activeMap.GetCoverHeight(hit.coord)));
			tileCoord.SetText(text);
		}
		if (GC.Inst.GetActiveTeam() != null)
		{
			Unit teamLeader = GC.Inst.GetActiveTeam().GetTeamLeader();
			if ((bool)teamLeader)
			{
				string text2 = "Unit Weapon Type: " + ((!teamLeader.charData.mainWeaponAttributes.IsMelee) ? "Ranged" : "Melee");
				unitWeaponType.SetText(text2);
			}
		}
		UnitTeam activeTeam = GC.Inst.GetActiveTeam();
		if (activeTeam != null)
		{
			Unit teamLeader2 = activeTeam.GetTeamLeader();
			if ((bool)teamLeader2)
			{
				string text3 = "Unit Abilities: " + teamLeader2.charData.DisplayName + "\n";
				for (int i = 0; i < teamLeader2.abilities.AbilityGetCount(); i++)
				{
					AbilityImplBase abilityImplBase = teamLeader2.abilities.AbilityGetByIndex(i);
					string text4 = text3;
					text3 = text4 + i.ToString() + ": " + abilityImplBase.GetType().Name + ", Upgraded: " + abilityImplBase.IsUpgraded + "\n";
				}
				unitAbilities.SetText(text3);
			}
		}
		UpdateHonestyLevelLabels();
	}

	private void UpdateHonestyLevelLabels()
	{
		int value = 0;
		SaveData.data.honestyTrackDict.TryGetValue(DC.GameSection.ONE, out var value2);
		SaveData.data.honestyTrackDict.TryGetValue(DC.GameSection.TWO_A, out var value3);
		SaveData.data.honestyTrackDict.TryGetValue(DC.GameSection.TWO_B, out var value4);
		SaveData.data.honestyTrackDict.TryGetValue(DC.GameSection.THREE, out value);
		honestyLevelSec1.SetText("Section One: " + value2);
		honestyLevelSec2a.SetText("Section Two_A: " + value3);
		honestyLevelSec2b.SetText("Section Two_B: " + value4);
		honestyLevelSec3.SetText("Section Three: " + value);
	}
}
public class UIDebugHighlight : UIElement
{
	public Color colorHighlight = Color.red;

	public bool highlightImage = true;

	public bool highlightText = true;

	private Color tmColorOrig;

	private Color spColorOrig;

	private bool initialised;

	private TextMesh tm;

	private SpriteRenderer sp;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton component = GetComponent<UIButton>();
		tm = GetComponent<TextMesh>();
		if (tm == null)
		{
			tm = GetComponentInChildren<TextMesh>();
		}
		if ((bool)tm)
		{
			tmColorOrig = tm.color;
			component.OnFocusEnter += delegate
			{
				if (highlightText)
				{
					tmColorOrig = tm.color;
					tm.color = colorHighlight;
				}
			};
			component.OnFocusExit += delegate
			{
				if (highlightText)
				{
					tm.color = tmColorOrig;
				}
			};
		}
		sp = GetComponent<SpriteRenderer>();
		if ((bool)sp)
		{
			spColorOrig = sp.color;
			component.OnFocusEnter += delegate
			{
				if (highlightImage)
				{
					spColorOrig = sp.color;
					sp.color = colorHighlight;
				}
			};
			component.OnFocusExit += delegate
			{
				if (highlightImage)
				{
					sp.color = spColorOrig;
				}
			};
		}
		initialised = true;
	}

	public void OverrideOriginalColor(Color color)
	{
		tmColorOrig = color;
	}

	public void ResetColor(bool text, bool image)
	{
		if (initialised)
		{
			if (text && tm != null)
			{
				tm.color = tmColorOrig;
			}
			if (image && sp != null)
			{
				sp.color = tmColorOrig;
			}
		}
	}
}
public class UIDebug_Combat : UIContainer
{
	private float debugWinLoseCooldown;

	private UIButton debugWin;

	private UIButton debugLose;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		debugWin = GetElement<UIButton>("DebugWin");
		debugLose = GetElement<UIButton>("DebugLose");
		debugWin.OnTapUp += DebugWin_OnTapUp;
		debugLose.OnTapUp += DebugLose_OnTapUp;
		UIButtonToggle logAIThoughts = GetElement<UIButtonToggle>("logAIThoughts");
		logAIThoughts.OnTapUp += delegate
		{
			logAIThoughts.textbox.SetText("logAIThoughts: " + ((!logAIThoughts.toggleValue) ? "0" : "1"));
			return true;
		};
		UIButtonToggle skipAITurns = GetElement<UIButtonToggle>("skipAITurns");
		skipAITurns.OnTapUp += delegate
		{
			skipAITurns.textbox.SetText("skipAITurns: " + ((!skipAITurns.toggleValue) ? "0" : "1"));
			GC.Inst.DEBUG_skipAITurns = skipAITurns.toggleValue;
			return true;
		};
		UIButtonToggle doNotDecrementPlayerHP = GetElement<UIButtonToggle>("doNotDecrementHP");
		doNotDecrementPlayerHP.OnTapUp += delegate
		{
			doNotDecrementPlayerHP.textbox.SetText("doNotDecrementPlayerHP: " + ((!doNotDecrementPlayerHP.toggleValue) ? "0" : "1"));
			GC.Inst.DEBUG_doNotDecrementHPplayer = doNotDecrementPlayerHP.toggleValue;
			return true;
		};
		UIButtonToggle doNotDecrementEnemyHP = GetElement<UIButtonToggle>("doNotDecrementHPEnemy");
		doNotDecrementEnemyHP.OnTapUp += delegate
		{
			doNotDecrementEnemyHP.textbox.SetText("doNotDecrementEnemyHP: " + ((!doNotDecrementEnemyHP.toggleValue) ? "0" : "1"));
			GC.Inst.DEBUG_doNotDecrementHPenemy = doNotDecrementEnemyHP.toggleValue;
			return true;
		};
		UIButtonToggle doNotDecrementAP = GetElement<UIButtonToggle>("doNotDecrementAP");
		doNotDecrementAP.OnTapUp += delegate
		{
			doNotDecrementAP.textbox.SetText("doNotDecrementAP: " + ((!doNotDecrementAP.toggleValue) ? "0" : "1"));
			GC.Inst.DEBUG_doNotDecrementAP = doNotDecrementAP.toggleValue;
			return true;
		};
		UIButtonToggle disablePassiveAbilities = GetElement<UIButtonToggle>("disablePassiveAbilities");
		disablePassiveAbilities.OnTapUp += delegate
		{
			disablePassiveAbilities.textbox.SetText("disablePassiveAbilities: " + ((!disablePassiveAbilities.toggleValue) ? "0" : "1"));
			GC.Inst.DEBUG_disablePassiveAbilities = disablePassiveAbilities.toggleValue;
			return true;
		};
		UIButtonToggle disablePassiveAbilities2 = GetElement<UIButtonToggle>("upgradeAllAbilities");
		disablePassiveAbilities2.OnTapUp += delegate
		{
			if (disablePassiveAbilities2.toggleValue)
			{
				disablePassiveAbilities2.textbox.SetText("downgradeAllAbilities");
			}
			else
			{
				disablePassiveAbilities2.textbox.SetText("upgradeAllAbilities");
			}
			for (int i = 0; i < GC.Inst.GetUnitsActive().Length; i++)
			{
				Unit unit = GC.Inst.GetUnitsActive()[i];
				foreach (AbilityImplBase item in unit.abilities.OnUnitAndTeam())
				{
					item.HACK_isUpgraded = disablePassiveAbilities2.toggleValue;
				}
			}
			return true;
		};
	}

	private bool DebugWin_OnTapUp()
	{
		if (GC.Inst == null)
		{
			return true;
		}
		if (debugWinLoseCooldown > 0f)
		{
			UnityEngine.Debug.LogError("Multi-clicking a game ending Debug tool? SHAMEFUL. STOP BREAKING THE GAME.");
			return true;
		}
		debugWinLoseCooldown = 3f;
		MR.Inst.Skip();
		return true;
	}

	private bool DebugLose_OnTapUp()
	{
		if (GC.Inst == null)
		{
			return true;
		}
		if (debugWinLoseCooldown > 0f)
		{
			UnityEngine.Debug.LogError("Multi-clicking a game ending Debug tool? SHAMEFUL. STOP BREAKING THE GAME.");
			return true;
		}
		debugWinLoseCooldown = 3f;
		UnitTeam teamOfType = GC.Inst.GetTeamOfType(UnitTeam.Type.Player);
		Unit[] array = teamOfType.GetActiveMembers().ToArray();
		foreach (Unit unit in array)
		{
			unit.HPDecrement(unit.HP);
		}
		return true;
	}

	public override bool HideAll()
	{
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void Update()
	{
		if (debugWinLoseCooldown > 0f)
		{
			debugWinLoseCooldown -= Time.deltaTime;
		}
	}
}
public class UIDebug_HagletStack : UIContainer
{
	private UITextbox textbox;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textbox = GetElement<UITextbox>("Text");
	}

	private void Update()
	{
		textbox.Clear();
		if ((bool)MR.Inst)
		{
			textbox.Append(MR.Inst.Host.GetStackTrace());
			textbox.Append("\n\n");
		}
		textbox.Append(LR.Host.GetStackTrace());
		textbox.Present();
	}

	public override bool HideAll()
	{
		base.gameObject.SetActive(value: false);
		base.HideAll();
		return true;
	}
}
public class UIDebug_Inventory : UIContainer
{
	private class ItemUI
	{
		public UIContainer container;

		public UITextbox itemName;

		public UITextbox itemNum;

		public UIButton itemAdd;

		public UIButton itemRemove;
	}

	private int scroll;

	private Action<int> scrollAction;

	private Item[] items;

	private ItemUI[] itemUIs = new ItemUI[14];

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIContainer[] array = GetContainers();
		items = (Item[])Enum.GetValues(typeof(Item));
		for (int i = 0; i < array.Length; i++)
		{
			itemUIs[i] = new ItemUI();
			itemUIs[i].container = array[i];
			itemUIs[i].itemName = array[i].GetElement<UITextbox>("ItemName");
			itemUIs[i].itemNum = array[i].GetElement<UITextbox>("ItemNum");
			itemUIs[i].itemAdd = array[i].GetElement<UIButton>("AddItem");
			itemUIs[i].itemAdd.OnTapUpWithUserData += ItemAdd_OnTapUpWithUserData;
			itemUIs[i].itemAdd.userData = i;
			itemUIs[i].itemRemove = array[i].GetElement<UIButton>("RemoveItem");
			itemUIs[i].itemRemove.OnTapUpWithUserData += ItemRemove_OnTapUpWithUserData;
			itemUIs[i].itemRemove.userData = i;
		}
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
	}

	private bool ItemAdd_OnTapUpWithUserData(object obj)
	{
		int num = (int)obj;
		ItemUI itemUI = itemUIs[num];
		ItemStackMeta itemMeta = GetItemMeta(num);
		if (Party.Inst.GetItemCount(itemMeta) < itemMeta.StorageLimit)
		{
			Party.Inst.AddItemToInventory(itemMeta, 1);
			itemUI.itemNum.SetText(Party.Inst.GetItemCount(itemMeta).ToString());
		}
		return true;
	}

	private bool ItemRemove_OnTapUpWithUserData(object obj)
	{
		int num = (int)obj;
		ItemUI itemUI = itemUIs[num];
		ItemStackMeta itemMeta = GetItemMeta(num);
		if (Party.Inst.GetItemCount(itemMeta) > 0)
		{
			Party.Inst.RemoveItemFromInventory(itemMeta, 1);
			itemUI.itemNum.SetText(Party.Inst.GetItemCount(itemMeta).ToString());
		}
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void UpdateButtons()
	{
		int i = 0;
		for (int num = itemUIs.Length; i < num; i++)
		{
			if (i < items.Length)
			{
				itemUIs[i].container.ShowAll();
				ItemUI itemUI = itemUIs[i];
				ItemStackMeta itemMeta = GetItemMeta(i);
				itemUIs[i].itemName.SetKey(itemMeta.shortDisplayName);
				itemUIs[i].itemNum.SetText(Party.Inst.GetItemCount(itemMeta).ToString());
			}
			else
			{
				itemUIs[i].container.HideAll();
			}
		}
	}

	private ItemStackMeta GetItemMeta(int listPos)
	{
		int num = (listPos + scroll).Wrap(items.Length);
		return items[num].ToMeta();
	}
}
public class UIDebug_LastException : UIContainer
{
	private UITextbox textbox;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textbox = GetElement<UITextbox>("Text");
	}

	public override void ShowAll()
	{
		base.ShowAll();
		if (LR.lastMissionLoadException != null)
		{
			textbox.SetText(LR.lastMissionLoadException.ToString());
		}
		else if (HAGIS.HACK_MissionException != null)
		{
			textbox.SetText(HAGIS.HACK_MissionException.ToString());
		}
		else
		{
			textbox.SetText("None yet. Break something!");
		}
	}

	public override bool HideAll()
	{
		base.gameObject.SetActive(value: false);
		base.HideAll();
		return true;
	}
}
public class UIDebug_Misc : UIContainer
{
	private float debugWinLoseCooldown;

	private UIButton debugWin;

	private UIButton debugLose;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton logAllTextureInMemory = GetElement<UIButton>("LogAllTexturesInMemory");
		logAllTextureInMemory.OnTapUp += delegate
		{
			UIDebug.LogAllLoadedTexturesToCSV();
			logAllTextureInMemory.name = "LogAllTexturesInMemory done!";
			return true;
		};
		UIButtonToggle toggleDebugFrameRate = GetElement<UIButtonToggle>("ToggleFramerateCursor");
		toggleDebugFrameRate.OnTapUp += delegate
		{
			switch (Crosshair.Inst.CrosshairDisplayMode)
			{
			case Crosshair.CrosshairMode.Default:
				Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Framerate;
				break;
			case Crosshair.CrosshairMode.Framerate:
				Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Off;
				break;
			case Crosshair.CrosshairMode.Off:
				Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Default;
				break;
			}
			toggleDebugFrameRate.textbox.SetText(string.Concat("Change Cursor (In ", Crosshair.Inst.CrosshairDisplayMode, " Mode)"));
			return true;
		};
		UIButtonToggle togglePeripheryUI = GetElement<UIButtonToggle>("TogglePeripheryUI");
		togglePeripheryUI.OnTapUp += delegate
		{
			UIStatusBar.Inst.HACK_showEndTurnButton = !UIStatusBar.Inst.HACK_showEndTurnButton;
			togglePeripheryUI.textbox.SetText("Toggle Periphery UI: " + UIStatusBar.Inst.HACK_showEndTurnButton);
			if (GC.Inst != null && !UIStatusBar.Inst.HACK_showEndTurnButton)
			{
				UIObjectives.Inst.HideAll();
			}
			else if (GC.Inst != null)
			{
				UIObjectives.Inst.ShowAll();
			}
			return true;
		};
		UIButtonToggle toggleCombatUI = GetElement<UIButtonToggle>("ToggleCombatUI");
		toggleCombatUI.OnTapUp += delegate
		{
			LR.HACK_hideCombatUI = !LR.HACK_hideCombatUI;
			toggleCombatUI.textbox.SetText("Toggle Combat UI: " + !LR.HACK_hideCombatUI);
			if (GC.Inst != null && GC.Inst.IsInTurnMode())
			{
				GC.Inst.ShowAllUnitStatusBars();
			}
			return true;
		};
	}
}
public class UIDebug_Missions : UIContainer
{
	public struct DebugMenuMission
	{
		public string buttonTxt;

		public MissionSceneMeta meta;

		public bool willaAndArchiOnly;
	}

	private int scroll;

	private Action<int> scrollAction;

	private List<DebugMenuMission> sceneMetas = new List<DebugMenuMission>();

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		RefreshMissions();
		Func<object, bool> value = delegate(object button)
		{
			DebugMenuMission sceneDebugMeta = GetSceneDebugMeta(((UIButton)button).textbox.TextVisible);
			if (!sceneDebugMeta.meta.devOnly)
			{
				if (sceneDebugMeta.willaAndArchiOnly)
				{
					UIDebug.HACK_SetupWillAndArchiOnly();
				}
				else
				{
					UIDebug.HACK_SetUpParty();
				}
			}
			if (LR.Inst.missionMetaLoaded != null)
			{
				HAGIS.MissionComplete();
			}
			RR.Inst.StopHartmanPottering();
			Singleton<UIFlow>.Inst.StartMissionBriefToMissionLoadout(sceneDebugMeta.meta);
			UIDebug.Inst.HideAll();
			return true;
		};
		int i = 0;
		for (int childCount = base.transform.childCount; i < childCount; i++)
		{
			UIButton component = base.transform.GetChild(i).GetComponent<UIButton>();
			component.OnTapUpWithUserData += value;
			component.userData = component;
		}
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void RefreshMissions()
	{
		sceneMetas.Clear();
		MissionSceneMeta[] array = AEResources.LoadAllResources<MissionSceneMeta>("SceneMetas");
		foreach (MissionSceneMeta missionSceneMeta in array)
		{
			DebugMenuMission item = default(DebugMenuMission);
			item.buttonTxt = missionSceneMeta.sceneName.Replace("MISSION_", string.Empty);
			item.meta = missionSceneMeta;
			sceneMetas.Add(item);
			if (item.buttonTxt.Contains("A1O2") || item.buttonTxt.Contains("A1O3") || item.buttonTxt.Contains("A1O4"))
			{
				item.buttonTxt += " (WILLA / ARCHI)";
				item.willaAndArchiOnly = true;
				sceneMetas.Add(item);
			}
		}
	}

	private void UpdateButtons()
	{
		RefreshMissions();
		int i = 0;
		for (int childCount = base.transform.childCount; i < childCount; i++)
		{
			if (i < sceneMetas.Count)
			{
				base.transform.GetChild(i).gameObject.SetActive(value: true);
				base.transform.GetChild(i).GetComponent<UITextbox>().SetText(GetSceneDebugMeta(i).buttonTxt);
			}
			else
			{
				base.transform.GetChild(i).gameObject.SetActive(value: false);
			}
		}
	}

	private DebugMenuMission GetSceneDebugMeta(int listPos)
	{
		int index = (listPos + scroll).Wrap(sceneMetas.Count);
		return sceneMetas[index];
	}

	private DebugMenuMission GetSceneDebugMeta(string btnText)
	{
		for (int i = 0; i < sceneMetas.Count; i++)
		{
			if (sceneMetas[i].buttonTxt == btnText)
			{
				return sceneMetas[i];
			}
		}
		return default(DebugMenuMission);
	}
}
public class UIDebug_PartyInfo : UIContainer
{
	private UIButton[] charSelectButtons;

	private UIButton addLevel;

	private UIButton scaleEnemies;

	private UIButton unlockCharacters;

	private UIButton onlyWillaArchi;

	private UIButton selectedCharName;

	private UITextbox selectedCharInfo;

	private UIButton[] abilitiesChoice1;

	private UIButton[] abilitiesChoice2;

	private UIButton[] abilitiesUpgrade;

	private UIButton toggleStaticSkin;

	private PartyMember selectedMember;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		charSelectButtons = new UIButton[6];
		for (int i = 0; i < charSelectButtons.Length; i++)
		{
			charSelectButtons[i] = GetElement<UIButton>("CharName" + i);
			charSelectButtons[i].OnTapUpWithUserData += SetSelectedCharacter;
		}
		abilitiesChoice1 = new UIButton[12];
		for (int j = 0; j < abilitiesChoice1.Length; j++)
		{
			abilitiesChoice1[j] = GetElement<UIButton>("SelectedCharAbil" + j);
			abilitiesChoice1[j].OnTapUpWithUserData += AddAbilOne;
			abilitiesChoice1[j].userData = j;
		}
		abilitiesChoice2 = new UIButton[12];
		for (int k = 0; k < abilitiesChoice2.Length; k++)
		{
			abilitiesChoice2[k] = GetElement<UIButton>("SelectedCharAbil" + k + " (1)");
			abilitiesChoice2[k].OnTapUpWithUserData += AddAbilTwo;
			abilitiesChoice2[k].userData = k;
		}
		abilitiesUpgrade = new UIButton[12];
		for (int l = 0; l < abilitiesUpgrade.Length; l++)
		{
			abilitiesUpgrade[l] = GetElement<UIButton>("Upgrade" + l);
			abilitiesUpgrade[l].OnTapUpWithUserData += UpgradeDowngradeAbil;
			abilitiesUpgrade[l].userData = l;
		}
		selectedCharName = GetElement<UIButton>("SelectedCharName");
		selectedCharInfo = GetElement<UITextbox>("SelectedCharData");
		selectedCharName.OnTapUp += AddLevelToSelectedMember;
		addLevel = GetElement<UIButton>("AddMissionComplete");
		scaleEnemies = GetElement<UIButton>("ScaleEnemies");
		addLevel.OnTapUp += AddLevelToUnlockedMembers;
		scaleEnemies.OnTapUp += ScaleEnemies;
		unlockCharacters = GetElement<UIButton>("UnlockCharacters");
		unlockCharacters.OnTapUp += delegate
		{
			Party.Inst.UnlockAllParty();
			ShowAll();
			return true;
		};
		toggleStaticSkin = GetElement<UIButton>("AddStaticSkin");
		toggleStaticSkin.OnTapUp += ToggleStaticSkin_OnTapUp;
		UIButton element = GetElement<UIButton>("ClearAbilities");
		element.OnTapUp += delegate
		{
			Unit unit = null;
			if (GC.Inst != null)
			{
				unit = GC.Inst.TryGetUnitByPartyMember(selectedMember);
			}
			for (int m = 0; m < 12; m++)
			{
				if (unit != null && selectedMember.GetAbilityAtIndex(m) != null)
				{
					Type ability = selectedMember.GetAbilityAtIndex(m).ability;
					unit.abilities.Remove(unit.abilities.AbilityGetByType(ability), isProxy: false);
				}
				selectedMember.RemoveAbilityAtIndex(m);
			}
			SetSelectedCharacter(selectedMember);
			return true;
		};
	}

	private bool ToggleStaticSkin_OnTapUp()
	{
		if (GC.Inst == null)
		{
			return true;
		}
		if (selectedMember == null)
		{
			return true;
		}
		if (selectedMember.characterData.partyMemberID != PartyMemberID.Willa)
		{
			return true;
		}
		ConstArray<Unit> membersInWorld = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMembersInWorld();
		for (int i = 0; i < membersInWorld.Length; i++)
		{
			if (membersInWorld[i].charData.partyMemberID == selectedMember.characterData.partyMemberID)
			{
				Unit unit = membersInWorld[i];
				if (unit.abilities.Exists(typeof(Ability_Static_Skin), null))
				{
					unit.abilities.Remove(unit.abilities.AbilityGetByType(typeof(Ability_Static_Skin)), isProxy: false);
					toggleStaticSkin.textbox.SetText("Add Static Skin");
				}
				else
				{
					AbilityImplBase abilityImplBase = unit.abilities.Add(typeof(Ability_Static_Skin), null, isUpgraded: false);
					toggleStaticSkin.textbox.SetText("Remove Static Skin");
				}
				break;
			}
		}
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		for (int i = 0; i < 6; i++)
		{
			charSelectButtons[i].userData = null;
		}
		int num = 0;
		for (int j = 0; j < Party.Inst.GetUnlockedPartyMembersNum(); j++)
		{
			if (num >= 6)
			{
				break;
			}
			PartyMember unlockedPartyMemberAtIndex = Party.Inst.GetUnlockedPartyMemberAtIndex(j);
			if (unlockedPartyMemberAtIndex.characterData.partyMemberID != PartyMemberID.Ashley)
			{
				charSelectButtons[num].textbox.SetKey(unlockedPartyMemberAtIndex.characterData.DisplayName);
				charSelectButtons[num].userData = unlockedPartyMemberAtIndex;
				num++;
			}
		}
		selectedCharName.textbox.SetText(string.Empty);
		selectedCharInfo.SetText(string.Empty);
		selectedMember = null;
		for (int k = 0; k < abilitiesChoice1.Length; k++)
		{
			abilitiesChoice1[k].gameObject.SetActive(value: false);
			abilitiesChoice2[k].gameObject.SetActive(value: false);
			abilitiesUpgrade[k].gameObject.SetActive(value: false);
		}
		addLevel.gameObject.SetActive(value: false);
		toggleStaticSkin.gameObject.SetActive(value: false);
	}

	public override bool HideAll()
	{
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private bool ScaleEnemies()
	{
		LR.Inst.DEBUG_scaleEnemies = !LR.Inst.DEBUG_scaleEnemies;
		scaleEnemies.textbox.SetText((!LR.Inst.DEBUG_scaleEnemies) ? "Enemies UNSCALED" : ("Enemies SCALING (Lvl " + Party.Inst.HightestPartyMemberLevel + ")"));
		if ((bool)GC.Inst && LR.Inst.DEBUG_scaleEnemies)
		{
			ConstArray<Unit> unitsAllInWorld = GC.Inst.GetUnitsAllInWorld();
			int hightestPartyMemberLevel = Party.Inst.HightestPartyMemberLevel;
			for (int i = 0; i < unitsAllInWorld.Length; i++)
			{
				unitsAllInWorld[i]._SetLevel(hightestPartyMemberLevel);
			}
			UnityEngine.Debug.Log("Set all Enemy Levels to " + hightestPartyMemberLevel);
		}
		return true;
	}

	private bool SetSelectedCharacter(object partyMember)
	{
		if (partyMember == null || partyMember.GetType() != typeof(PartyMember))
		{
			return true;
		}
		selectedMember = (PartyMember)partyMember;
		selectedCharName.textbox.Clear();
		selectedCharName.textbox.Append("(");
		selectedCharName.textbox.AppendKey(selectedMember.characterData.DisplayName);
		selectedCharName.textbox.Append(") + Lvl");
		selectedCharName.textbox.Present();
		selectedCharInfo.SetText("Level " + selectedMember.Level + " | Missions Completed " + selectedMember.MissionsCompleted);
		for (int i = 0; i < 12; i++)
		{
			int validLevel = GetValidLevel(i);
			UIButton uIButton = abilitiesChoice1[i];
			UIButton uIButton2 = abilitiesChoice2[i];
			UIButton uIButton3 = abilitiesUpgrade[i];
			PartyAbility abilityAtIndex = selectedMember.GetAbilityAtIndex(i);
			AbilityMeta firstAbilityAtLevel = selectedMember.GetFirstAbilityAtLevel(validLevel);
			AbilityMeta secondAbilityAtLevel = selectedMember.GetSecondAbilityAtLevel(validLevel);
			if (abilityAtIndex == null || abilityAtIndex.ability != firstAbilityAtLevel.GetImplementationType())
			{
				uIButton.textbox.color = Color.red;
			}
			else
			{
				uIButton.textbox.color = Color.green;
			}
			if (abilityAtIndex == null || abilityAtIndex.ability != secondAbilityAtLevel.GetImplementationType())
			{
				uIButton2.textbox.color = Color.red;
			}
			else
			{
				uIButton2.textbox.color = Color.green;
			}
			if (abilityAtIndex == null || !abilityAtIndex.upgraded)
			{
				uIButton3.textbox.color = Color.red;
				uIButton3.textbox.SetText(":c");
			}
			else
			{
				uIButton3.textbox.color = Color.cyan;
				uIButton3.textbox.SetText("C:");
			}
			uIButton.gameObject.SetActive(value: true);
			uIButton2.gameObject.SetActive(value: true);
			uIButton3.gameObject.SetActive(value: true);
			uIButton.textbox.SetKey(firstAbilityAtLevel.GetDisplayName(selectedMember.characterData));
			uIButton2.textbox.SetKey(secondAbilityAtLevel.GetDisplayName(selectedMember.characterData));
		}
		addLevel.gameObject.SetActive(value: true);
		if (GC.Inst != null)
		{
			if (selectedMember.characterData.partyMemberID == PartyMemberID.Willa)
			{
				toggleStaticSkin.gameObject.SetActive(value: true);
				ConstArray<Unit> membersInWorld = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMembersInWorld();
				for (int j = 0; j < membersInWorld.Length; j++)
				{
					if (membersInWorld[j].charData.partyMemberID == selectedMember.characterData.partyMemberID)
					{
						Unit unit = membersInWorld[j];
						if (unit.abilities.Exists(typeof(Ability_Static_Skin), null))
						{
							toggleStaticSkin.textbox.SetText("Remove Static Skin");
						}
						else
						{
							toggleStaticSkin.textbox.SetText("Add Static Skin");
						}
						break;
					}
				}
			}
			else
			{
				toggleStaticSkin.gameObject.SetActive(value: false);
			}
		}
		return true;
	}

	private int GetValidLevel(int i)
	{
		switch (i)
		{
		case 0:
		case 1:
			return 0;
		case 2:
			return 1;
		default:
			return i - 1;
		}
	}

	private bool AddLevelToSelectedMember()
	{
		int num = selectedMember.Level + 1;
		if (num > 10)
		{
			return true;
		}
		UpgradeLevelAndAbilitiesForUnit(selectedMember, num);
		SetSelectedCharacter(selectedMember);
		return true;
	}

	private void UpgradeLevelAndAbilitiesForUnit(PartyMember member, int newLevel)
	{
		while (member.Level < newLevel)
		{
			member.OnMissionComplete();
		}
		if (GC.Inst != null)
		{
			Unit unit = GC.Inst.TryGetUnitByPartyMember(member);
			if (unit != null)
			{
				unit._SetLevel(member.Level);
			}
		}
		for (int i = 0; i <= member.Level + 1; i++)
		{
			if (member.GetAbilityAtIndex(i) == null)
			{
				AddAbil(i, UnityEngine.Random.value > 0.5f, member);
			}
		}
	}

	private bool AddLevelToUnlockedMembers()
	{
		int num = Party.Inst.HightestPartyMemberLevel + 1;
		if (num > 10)
		{
			num = 10;
		}
		ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
		for (int i = 0; i < unlockedPartyMembers.Length; i++)
		{
			PartyMember partyMember = unlockedPartyMembers[i];
			if (partyMember.characterData.partyMemberID != PartyMemberID.Ashley)
			{
				UpgradeLevelAndAbilitiesForUnit(selectedMember, num);
			}
		}
		SetSelectedCharacter(selectedMember);
		return true;
	}

	private bool AddAbilOne(object index)
	{
		AddAbil((int)index, abilOne: true, selectedMember);
		return true;
	}

	private bool AddAbilTwo(object index)
	{
		AddAbil((int)index, abilOne: false, selectedMember);
		return true;
	}

	private bool UpgradeDowngradeAbil(object index)
	{
		PartyAbility abilityAtIndex = selectedMember.GetAbilityAtIndex((int)index);
		if (abilityAtIndex == null)
		{
			SetSelectedCharacter(selectedMember);
			return true;
		}
		abilityAtIndex.upgraded = !abilityAtIndex.upgraded;
		if ((bool)GC.Inst)
		{
			ConstArray<Unit> membersInWorld = GC.Inst.GetTeamOfType(UnitTeam.Type.Player).GetMembersInWorld();
			for (int i = 0; i < membersInWorld.Length; i++)
			{
				if (membersInWorld[i].charData.partyMemberID == selectedMember.characterData.partyMemberID)
				{
					AbilityImplBase abilityImplBase = membersInWorld[i].abilities.AbilityGetByType(abilityAtIndex.ability);
					if (abilityImplBase == null)
					{
						abilityImplBase = membersInWorld[i].GetTeam().abilities.AbilityGetByType(abilityAtIndex.ability);
					}
					if (abilityImplBase != null)
					{
						abilityImplBase.HACK_isUpgraded = abilityAtIndex.upgraded;
					}
					break;
				}
			}
		}
		SetSelectedCharacter(selectedMember);
		return true;
	}

	private void AddAbil(int index, bool abilOne, PartyMember member)
	{
		int validLevel = GetValidLevel(index);
		PartyAbility abilityAtIndex = member.GetAbilityAtIndex(index);
		Type oldAbility = ((abilityAtIndex != null) ? abilityAtIndex.ability : typeof(Ability_MISSING_ABILITY));
		if (abilityAtIndex != null)
		{
			member.RemoveAbilityAtLevel(validLevel, (!abilOne) ? 1 : 0);
		}
		if (abilOne)
		{
			member.SetFirstAbilityChoiceAtLevel(validLevel);
		}
		else
		{
			member.SetSecondAbilityChoiceAtLevel(validLevel);
		}
		SetSelectedCharacter(selectedMember);
		AddAbilityImplementationAtIndex(index, oldAbility, member);
	}

	private void AddAbilityImplementationAtIndex(int index, Type oldAbility, PartyMember member)
	{
		if (!GC.Inst)
		{
			return;
		}
		Unit unit = GC.Inst.TryGetUnitByPartyMember(member);
		if (unit != null)
		{
			if (unit.abilities.Exists(oldAbility, null))
			{
				unit.abilities.Remove(unit.abilities.AbilityGetByType(oldAbility), isProxy: false);
			}
			else if (unit.GetTeam().abilities.Exists(oldAbility, null))
			{
				unit.GetTeam().abilities.Remove(unit.abilities.AbilityGetByType(oldAbility), isProxy: false);
			}
			Type ability = member.GetAbilityAtIndex(index).ability;
			AbilityImplBase abilityImplBase = unit.abilities.Add(ability, null, isUpgraded: false);
		}
	}
}
public class UIDebug_PlayAnim : UIContainer
{
	private int scroll;

	private Action<int> scrollAction;

	private UnitModel targetModel => (!(Singleton<PC>.Inst.GetLeader() != null)) ? null : Singleton<PC>.Inst.GetLeader().unitModel;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		Func<object, bool> value = delegate(object button)
		{
			if (targetModel != null)
			{
				targetModel.DebugPlay(GetAnimID(((UIButton)button).transform.GetSiblingIndex()));
			}
			return true;
		};
		int num = base.transform.childCount;
		while (--num >= 0)
		{
			UIButton component = base.transform.GetChild(num).GetComponent<UIButton>();
			component.OnTapUpWithUserData += value;
			component.userData = component;
		}
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		if (targetModel != null)
		{
			scroll = 0;
			UIDebug.Inst.scrollAction += scrollAction;
		}
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void UpdateButtons()
	{
		if (targetModel != null)
		{
			int num = base.transform.childCount;
			while (--num >= 0)
			{
				UITextbox component = base.transform.GetChild(num).GetComponent<UITextbox>();
				component.SetText(GetAnimID(num).ToString());
				component.gameObject.SetActive(value: true);
			}
		}
		else
		{
			int num2 = base.transform.childCount;
			while (--num2 >= 1)
			{
				base.transform.GetChild(num2).gameObject.SetActive(value: false);
			}
			base.transform.GetChild(0).GetComponent<UITextbox>().SetText("No target!");
		}
	}

	private UnitModel.AnimID GetAnimID(int listPos)
	{
		return (UnitModel.AnimID)(listPos + scroll).Wrap(51);
	}
}
public class UIDebug_SaveData : UIContainer
{
	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton clerProgress = GetElement<UIButton>("Clear Progress");
		clerProgress.OnTapUp += delegate
		{
			SaveData.ClearProgress();
			clerProgress.textbox.SetText("Done!");
			UIDebug.DelayResetButton(clerProgress, "Clear Progress");
			UpdateCompleteCurrent();
			UpdateNextMission();
			GetElement<UIButton>("Complete Current").Show();
			return true;
		};
		UIButton clearMission = GetElement<UIButton>("Clear Mission");
		clearMission.OnTapUp += delegate
		{
			SaveData.ClearMission();
			clearMission.textbox.SetText("Done!");
			UIDebug.DelayResetButton(clearMission, "Clear Mission");
			return true;
		};
		UIButton completeCurrent = GetElement<UIButton>("Complete Current");
		completeCurrent.OnTapUp += delegate
		{
			if (LR.Inst.missionMetaLoaded != null)
			{
				UIDebug.DelayResetButton(completeCurrent, "Quit Mission First!");
				return true;
			}
			int furthestMissionGroupIdx = SaveData.data.GetFurthestMissionGroupIdx();
			SaveData.MissionGroup furthestMissionGroup = SaveData.data.GetFurthestMissionGroup();
			for (int i = 0; i < furthestMissionGroup.size; i++)
			{
				if (!SaveData.data.IsMissionComplete(furthestMissionGroupIdx, i))
				{
					MissionSceneMeta missionMetaByName = SaveData.GetMissionMetaByName(furthestMissionGroup.missionNames[i]);
					SaveData.data.SetMissionComplete(furthestMissionGroup.missionNames[i]);
					SaveData.data.roomSceneMeta = missionMetaByName.postMissionRoom;
					CharacterData[] missionRequiredCharacters = missionMetaByName.missionRequiredCharacters;
					foreach (CharacterData character in missionRequiredCharacters)
					{
						Party.Inst.UnlockPartyMember(character);
					}
					CharacterData[] suggestedCharacters = missionMetaByName.suggestedCharacters;
					foreach (CharacterData character2 in suggestedCharacters)
					{
						Party.Inst.UnlockPartyMember(character2);
					}
					if (missionMetaByName.sceneName.Contains("A1O1"))
					{
						SaveData.data.tutorials.appliedAugment = true;
					}
					break;
				}
			}
			SaveData.data.tutorials.visitedShop = (SaveData.data.tutorials.viewedRejectionShotTutorial = (SaveData.data.tutorials.viewedOverloadingTutorial = (SaveData.data.tutorials.pickedUpScrap = (SaveData.data.tutorials.pickedUpCircuitry = (SaveData.data.tutorials.pickedUpJewellery = (SaveData.data.tutorials.pickedUpAtlatium = (SaveData.data.tutorials.pickedUpRejectionShot = (SaveData.data.tutorials.acquiredAugment = (SaveData.data.tutorials.acquiredMedkit = (SaveData.data.tutorials.boughtRejectionShot = (SaveData.data.tutorials.boughtAtlatium = true)))))))))));
			SaveData.data.chosenMission = null;
			if (SaveData.data.roomSceneMeta != null)
			{
				LR.Inst.LoadRoomSceneIntoFrontend(SaveData.data.roomSceneMeta);
			}
			UpdateCompleteCurrent();
			MissionSceneMeta nextMission = SaveData.data.GetNextMission();
			if (nextMission != null)
			{
				CharacterData[] missionRequiredCharacters2 = nextMission.missionRequiredCharacters;
				foreach (CharacterData character3 in missionRequiredCharacters2)
				{
					Party.Inst.UnlockPartyMember(character3);
				}
				CharacterData[] suggestedCharacters2 = nextMission.suggestedCharacters;
				foreach (CharacterData character4 in suggestedCharacters2)
				{
					Party.Inst.UnlockPartyMember(character4);
				}
			}
			UpdateNextMission();
			SaveData.SaveProgress(null, unthreaded: true);
			return true;
		};
		UIButton backup = GetElement<UIButton>("Backup Files");
		backup.OnTapUp += delegate
		{
			string text = "Done!";
			try
			{
				SaveData.BackupFiles();
			}
			catch (Exception ex)
			{
				text = ex.GetType().Name + "!";
				UnityEngine.Debug.LogErrorFormat("Save data backup failed with {0}", ex.ToString());
			}
			backup.textbox.SetText(text);
			UIDebug.DelayResetButton(backup, "Backup Files");
			return true;
		};
		UIButton unlockChars = GetElement<UIButton>("Unlock All Characters");
		unlockChars.OnTapUp += delegate
		{
			UIDebug.HACK_SetUpParty();
			SaveData.SaveProgress(null, unthreaded: true);
			unlockChars.textbox.SetText("Done!");
			UIDebug.DelayResetButton(unlockChars, "Unlock All Characters");
			return true;
		};
		UIButton element = GetElement<UIButton>("Toggle Mid-Mission Saving");
		element.OnTapUp += delegate
		{
			SaveData.data.enableMidMissionSaving = !SaveData.data.enableMidMissionSaving;
			SaveData.SaveProgress(null, unthreaded: true);
			UpdateMidMission();
			return true;
		};
		UIButton element2 = GetElement<UIButton>("Toggle Serializer Logging");
		element2.OnTapUp += delegate
		{
			SaveData.data.enableSerializerLogging = !SaveData.data.enableSerializerLogging;
			SaveData.SaveProgress(null, unthreaded: true);
			UpdateSerializerLogging();
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UpdateCompleteCurrent();
		UpdateNextMission();
		UpdateMidMission();
		UpdateSerializerLogging();
	}

	private void UpdateCompleteCurrent()
	{
		UIButton element = GetElement<UIButton>("Complete Current");
		int furthestMissionGroupIdx = SaveData.data.GetFurthestMissionGroupIdx();
		SaveData.MissionGroup furthestMissionGroup = SaveData.data.GetFurthestMissionGroup();
		for (int i = 0; i < furthestMissionGroup.size; i++)
		{
			if (!SaveData.data.IsMissionComplete(furthestMissionGroupIdx, i))
			{
				element.enabled = true;
				element.textbox.SetText("Set Current Mission To\n\tComplete!");
				return;
			}
		}
		element.enabled = false;
		element.textbox.SetText("Game is complete!");
	}

	private void UpdateNextMission()
	{
		UITextbox element = GetElement<UITextbox>("Next Mission");
		MissionSceneMeta nextMission = SaveData.data.GetNextMission();
		if (nextMission != null)
		{
			element.Show();
			element.SetText("Next Mission: " + nextMission.sceneName.Replace("MISSION_", string.Empty));
		}
		else
		{
			element.Hide();
		}
	}

	private void UpdateMidMission()
	{
		UIButton element = GetElement<UIButton>("Toggle Mid-Mission Saving");
		bool enableMidMissionSaving = SaveData.data.enableMidMissionSaving;
		element.textbox.SetText("Toggle Mid-Mission Saving " + ((!enableMidMissionSaving) ? "(OFF)" : "(ON)"));
	}

	private void UpdateSerializerLogging()
	{
		UIButton element = GetElement<UIButton>("Toggle Serializer Logging");
		bool enableSerializerLogging = SaveData.data.enableSerializerLogging;
		element.textbox.SetText("Toggle Serializer Logging " + ((!enableSerializerLogging) ? "(OFF)" : "(ON)"));
	}
}
public class UIDebug_UIScreens : UIContainer
{
	private UIButton abilityWheel;

	private UIButton characterDetails;

	private UIButton inventory;

	private UIButton loadout3;

	private UIButton loadoutFull;

	private UIButton missionEnd;

	private UIButton narrDialog;

	private UIButton storeFront;

	private UIButton frontEnd;

	private UIButton cursorSpeedUp;

	private UIButton cursorSpeedDown;

	private UIButton radialToggle;

	private UIButton mainMenu;

	private UIButton missionSelect;

	private UIButton options;

	private UITextbox radialSpeed;

	public static T PushPop<T>() where T : UIContainer
	{
		if (Singleton<UIC>.Inst.IsShown<T>())
		{
			Singleton<UIC>.Inst.Pop();
			return (T)null;
		}
		return Singleton<UIC>.Inst.Push<T>();
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		abilityWheel = GetElement<UIButton>("AbilityWheel");
		abilityWheel.OnTapUp += delegate
		{
			if (UIAbilityWheel.Inst == null)
			{
				UnityEngine.Debug.Log("Not implemented! Sorry boo boo!");
				return true;
			}
			return true;
		};
		characterDetails = GetElement<UIButton>("CharacterDetails");
		characterDetails.OnTapUp += delegate
		{
			PushPop<UICharacterDetails>().SetStateForMissionEnd(Party.Inst.GetUnlockedPartyMembers());
			return true;
		};
		inventory = GetElement<UIButton>("Inventory");
		inventory.OnTapUp += delegate
		{
			PushPop<UIInventory>();
			return true;
		};
		loadout3 = GetElement<UIButton>("Loadout3");
		loadout3.OnTapUp += delegate
		{
			UILoadout uILoadout2 = PushPop<UILoadout>();
			if ((bool)uILoadout2)
			{
				uILoadout2.SetState(3, new CharacterData[0], new CharacterData[0], new CharacterData[0]);
			}
			return true;
		};
		loadoutFull = GetElement<UIButton>("LoadoutFullTeam");
		loadoutFull.OnTapUp += delegate
		{
			UILoadout uILoadout = PushPop<UILoadout>();
			if ((bool)uILoadout)
			{
				uILoadout.SetState(6, new CharacterData[0], new CharacterData[0], new CharacterData[0]);
			}
			return true;
		};
		missionEnd = GetElement<UIButton>("MissionEnd");
		missionEnd.OnTapUp += delegate
		{
			PushPop<UIMissionEnd>();
			return true;
		};
		narrDialog = GetElement<UIButton>("NarrativeDialog");
		narrDialog.OnTapUp += delegate
		{
			PushPop<UINarrativeDialog>();
			return true;
		};
		storeFront = GetElement<UIButton>("StoreFront");
		storeFront.OnTapUp += delegate
		{
			PushPop<UIStoreFront>();
			return true;
		};
		mainMenu = GetElement<UIButton>("MainMenu");
		mainMenu.OnTapUp += delegate
		{
			PushPop<UIMainMenu>();
			return true;
		};
		UIButton element = GetElement<UIButton>("DemoScreen");
		element.OnTapUp += delegate
		{
			PushPop<UIDemoScreen>();
			return true;
		};
		UIButton element2 = GetElement<UIButton>("DemoThanks");
		element2.OnTapUp += delegate
		{
			PushPop<UIDemoThanks>();
			return true;
		};
		missionSelect = GetElement<UIButton>("MissionSelect");
		missionSelect.OnTapUp += delegate
		{
			PushPop<UIMainMenu>();
			return true;
		};
		UIButton element3 = GetElement<UIButton>("TutorialPanel");
		element3.OnTapUp += delegate
		{
			PushPop<UITutorialPanel>();
			return true;
		};
		options = GetElement<UIButton>("Options");
		options.OnTapUp += delegate
		{
			PushPop<UIOptionsMenu>();
			return true;
		};
		radialSpeed = GetElement<UITextbox>("RadialSpeed");
		cursorSpeedUp = GetElement<UIButton>("CursorSpeed");
		cursorSpeedUp.OnTapUp += delegate
		{
			IC.timeForLongHoldActionButtonMax += 0.05f;
			radialSpeed.SetText("RadSpd: " + IC.timeForLongHoldActionButtonMax);
			UnityEngine.Debug.Log("Radial Tick Time: " + IC.timeForLongHoldActionButtonMax);
			return true;
		};
		cursorSpeedDown = GetElement<UIButton>("CursorSlow");
		cursorSpeedDown.OnTapUp += delegate
		{
			IC.timeForLongHoldActionButtonMax -= 0.05f;
			radialSpeed.SetText("RadSpd: " + IC.timeForLongHoldActionButtonMax);
			UnityEngine.Debug.Log("Radial Tick Time: " + IC.timeForLongHoldActionButtonMax);
			return true;
		};
		radialToggle = GetElement<UIButton>("RadialTickerToggle");
		radialToggle.OnTapUp += () => ToggleRadialTicker();
		HideAll();
	}

	private bool ToggleRadialTicker()
	{
		LR.DEBUG_useRadialTicker = !LR.DEBUG_useRadialTicker;
		radialToggle.textbox.SetText("Turn Radial Toggle " + ((!LR.DEBUG_useRadialTicker) ? "On" : "Off"));
		UnityEngine.Debug.Log("Radial Ticker is " + (LR.DEBUG_useRadialTicker ? "On" : "Off"));
		return true;
	}

	public override bool HideAll()
	{
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	public override void ShowAll()
	{
		radialToggle.textbox.SetText("Turn Radial Toggle " + ((!LR.DEBUG_useRadialTicker) ? "On" : "Off"));
		radialSpeed.SetText("RadSpd: " + IC.timeForLongHoldActionButtonMax);
		base.ShowAll();
	}
}
public class UIDemoExitScreen : UIContainer
{
	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton element = GetElement<UIButton>("YesButton");
		element.OnTapUp += delegate
		{
			UnityEngine.Application.Quit();
			return true;
		};
		UIButton element2 = GetElement<UIButton>("NoButton");
		element2.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Pop();
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
	}

	public override bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}
}
public class UIDemoScreen : UIContainer
{
	private UIImage glow;

	private const float fadeTime = 0.5f;

	private HagletResettable showAllRoutine;

	public override void Initialise()
	{
		base.Initialise();
		showAllRoutine = new HagletResettable(ShowAllRoutine());
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		glow = GetElement<UIImage>("LogoGlow");
	}

	public override bool ConsumesActionButton()
	{
		return true;
	}

	public override void OnActionButtonPressed()
	{
		MusicController.Inst.Stop();
		Singleton<UIFlow>.Inst.StartMissionBriefToMissionLoadout(AEResources.LoadFirstResource<MissionSceneMeta>("SceneMetas/MISSION_A4S1_Prologue"));
		SetAlpha(0f);
	}

	public override bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Push<UIDemoExitScreen>();
		return false;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		SetAlpha(0f);
		glow.PulseAlphaStart(LR.Host, 0.25f, 0.75f, 0.8f);
		Routine.Start(showAllRoutine);
	}

	public override bool HideAll()
	{
		base.HideAll();
		glow.PulseAlphaStop();
		return true;
	}

	private IEnumerator<HagletYieldTerm> ShowAllRoutine()
	{
		float timer = 0f;
		while (timer < 0.5f)
		{
			float setAlpha = timer / 0.5f;
			SetAlpha(setAlpha);
			timer += Time.deltaTime;
			yield return null;
		}
	}
}
public class UIDemoThanks : UIContainer
{
	private UITextbox textbox;

	private AnimFloat animAlpha;

	private HagletResettable resettable;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		resettable = new HagletResettable(ThanksRoutine());
		textbox = GetElement<UITextbox>("Thanks");
		animAlpha = new AnimFloat(0f);
	}

	public override void ShowAll()
	{
		base.ShowAll();
		Routine.Start(resettable);
	}

	private IEnumerator<HagletYieldTerm> ThanksRoutine()
	{
		SetAlpha(0f);
		MusicController.Inst.SetProgress(0.1f);
		animAlpha.AnimateTo(1f, 1.5f);
		while ((bool)animAlpha.animating)
		{
			SetAlpha(animAlpha.Update());
			yield return null;
		}
		yield return Wait.ForSeconds(5f);
		animAlpha.AnimateTo(0f, 1f);
		while ((bool)animAlpha.animating)
		{
			SetAlpha(animAlpha.Update());
			yield return null;
		}
	}

	public override bool OnBackButtonPressed()
	{
		return false;
	}
}
public class UIDisplayText : UIContainer
{
	private UITextbox subject;

	private UITextbox description;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		subject = GetElement<UITextbox>("Subject");
		description = GetElement<UITextbox>("Description");
		HideAll();
	}

	public void SetText(string subjectName, string descriptionBody)
	{
		subject.SetText(subjectName);
		description.SetText(descriptionBody);
	}

	public void showName(bool show)
	{
		subject.gameObject.SetActive(show);
	}

	public void showDescription(bool show)
	{
		description.gameObject.SetActive(show);
	}
}
public class UIElement : MonoBehaviour
{
	public static float kDisabledAlpha = 0.3f;

	private const float kMinPulseValueDefault = 0.25f;

	private const float kMaxPulseValueDefault = 1f;

	private const float kPulseFrequencyDefault = 1.5f;

	private const float kPulseStopTimeDefault = 0.25f;

	private HagletResettable routinePulseAlpha;

	private HagletResettable routinePulseScale;

	private HagletResettable routinePulseRGB;

	private HagletResettable routineFadeAlpha;

	[HideInInspector]
	public bool allowShowHideCommands = true;

	private float _alpha = 1f;

	private float _parentAlpha = 1f;

	[HideInInspector]
	public bool interactable = true;

	private bool pulseAlphaStopping;

	private float pulseAlphaMinAlpha;

	private float pulseAlphaMaxAlpha;

	private float pulseAlphaFrequency;

	private float pulseAlphaStoppingTime;

	private bool pulseScaleStopping;

	private float pulseScaleMinScale;

	private float pulseScaleMaxScale;

	private float pulseScaleFrequency;

	private float pulseScaleStoppingTime;

	private Vector3 startingScale;

	private bool pulseRGBStopping;

	private Color pulseRGBColor;

	private Color? pulseRGBStopColor;

	private float pulseRGBFrequency;

	private float pulseRGBStoppingTime;

	private float animateAlphaTarget;

	private float animateAlphaDuration;

	private bool animateAlphaHideWhenFinished;

	public bool IsShown
	{
		get
		{
			return base.gameObject.activeSelf;
		}
		set
		{
			if (value)
			{
				Show();
			}
			else
			{
				Hide();
			}
		}
	}

	public virtual Color color { get; set; }

	public float alpha
	{
		get
		{
			return _alpha;
		}
		set
		{
			_alpha = value;
			OnAlphaSet(alphaInContainer);
		}
	}

	public float alphaInContainer => _alpha * _parentAlpha;

	public bool IsPulseScaling => routinePulseScale.running;

	public virtual void Show()
	{
		if (!IsShown)
		{
			base.gameObject.SetActive(value: true);
		}
	}

	public virtual void Hide()
	{
		if (IsShown)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public virtual void OnAwakeLR()
	{
		startingScale = base.gameObject.transform.localScale;
		routinePulseAlpha = new HagletResettable(PulseAlphaRoutine(), "UI Element Pulse Alpha", HagletStepTime.LateUpdate);
		routinePulseScale = new HagletResettable(PulseScaleRoutine(), "UI Element Pulse Scale", HagletStepTime.LateUpdate);
		routinePulseRGB = new HagletResettable(PulseRGBRoutine(), "UI Element Pulse RGB", HagletStepTime.LateUpdate);
		routineFadeAlpha = new HagletResettable(AnimateToAlphaRoutine(), "UI Element AnimateAlpha");
	}

	public virtual void OnAlphaSet(float alpha)
	{
	}

	public void _SetParentAlpha(float alpha)
	{
		_parentAlpha = alpha;
		OnAlphaSet(alphaInContainer);
	}

	public void _SetInteractable(bool interact)
	{
		interactable = interact;
	}

	public void PulseAlphaStart(HagletHost host, float minVal = 0.25f, float maxVal = 1f, float frequency = 1.5f)
	{
		pulseAlphaMinAlpha = minVal;
		pulseAlphaMaxAlpha = maxVal;
		pulseAlphaFrequency = frequency;
		pulseAlphaStopping = false;
		HagletResettable.StartOrReset(routinePulseAlpha, host);
	}

	public HagletEvent PulseAlphaStop(float stopVal = 1f, float stopTime = 0.25f)
	{
		if (routinePulseAlpha == null || (!routinePulseAlpha.running && routinePulseAlpha.markedToRunBy == null))
		{
			return null;
		}
		if (stopTime == 0f)
		{
			alpha = stopVal;
			pulseAlphaStopping = true;
			return null;
		}
		pulseAlphaMaxAlpha = stopVal;
		pulseAlphaMinAlpha = alpha;
		pulseAlphaStoppingTime = stopTime;
		pulseAlphaStopping = true;
		return routinePulseAlpha.stopped;
	}

	private IEnumerator<HagletYieldTerm> PulseAlphaRoutine()
	{
		while (!pulseAlphaStopping)
		{
			float wave = 0.5f * (1f + Mathf.Sin((float)Math.PI * 2f * pulseAlphaFrequency * Time.time));
			float mul = pulseAlphaMaxAlpha - pulseAlphaMinAlpha;
			float scaledWave = wave * mul;
			alpha = Mathf.Lerp(alpha, pulseAlphaMaxAlpha - scaledWave, Time.deltaTime * 5f);
			yield return null;
		}
		if (pulseAlphaStoppingTime == 0f || !IsShown)
		{
			alpha = pulseAlphaMaxAlpha;
			yield break;
		}
		float t = 0f;
		while (t < pulseAlphaStoppingTime)
		{
			t += Time.deltaTime;
			alpha = Mathf.Lerp(pulseAlphaMinAlpha, pulseAlphaMaxAlpha, t / pulseAlphaStoppingTime);
			yield return null;
		}
	}

	public void PulseScaleStart(HagletHost host, float minScale = 0.9f, float maxScale = 1.1f, float frequency = 0.85f, Vector3? startingScale = null)
	{
		pulseScaleMinScale = minScale;
		pulseScaleMaxScale = maxScale;
		pulseScaleFrequency = frequency;
		pulseScaleStopping = false;
		if (startingScale.HasValue)
		{
			base.gameObject.transform.localScale = startingScale.Value;
		}
		HagletResettable.StartOrReset(routinePulseScale, host);
	}

	public HagletEvent PulseScaleStop(float stopTime = 0.35f, float stopVal = 1f)
	{
		pulseScaleMaxScale = stopVal;
		pulseScaleStoppingTime = stopTime;
		pulseScaleStopping = true;
		return routinePulseScale.stopped;
	}

	private IEnumerator<HagletYieldTerm> PulseScaleRoutine()
	{
		float scale = pulseScaleMinScale;
		while (!pulseScaleStopping)
		{
			scale = Mathf.Lerp(t: 0.5f + Mathf.Sin((float)Math.PI * 2f * pulseScaleFrequency * Time.time) * 0.5f, a: pulseScaleMinScale, b: pulseScaleMaxScale);
			base.gameObject.transform.localScale = startingScale * scale;
			yield return null;
		}
		if (pulseScaleStoppingTime == 0f || !IsShown)
		{
			base.gameObject.transform.localScale = startingScale * pulseScaleMaxScale;
			yield break;
		}
		float t = 0f;
		while (t < pulseScaleStoppingTime)
		{
			t += Time.deltaTime;
			base.gameObject.transform.localScale = startingScale * Mathf.Lerp(scale, pulseScaleMaxScale, t / pulseScaleStoppingTime);
			yield return null;
		}
	}

	public void PulseRGBStart(HagletHost host, Color targetColor, float frequency, Color? startColor = null)
	{
		pulseRGBStopping = false;
		pulseRGBColor = targetColor;
		pulseRGBFrequency = frequency;
		if (startColor.HasValue)
		{
			color = ColorX.From(startColor.Value.GetRGB(), alpha);
		}
		HagletResettable.StartOrReset(routinePulseRGB, host);
	}

	public HagletEvent PulseRGBStop(HagletHost host, float stopTime, Color? stopValue = null)
	{
		pulseRGBStopColor = stopValue;
		pulseRGBStoppingTime = stopTime;
		pulseRGBStopping = true;
		return routinePulseAlpha.stopped;
	}

	private IEnumerator<HagletYieldTerm> PulseRGBRoutine()
	{
		Color startingColor2 = this.color;
		while (!pulseRGBStopping)
		{
			this.color = ColorX.From(Color.Lerp(t: 0.5f + Mathf.Sin((float)Math.PI * 2f * pulseRGBFrequency * Time.time) * 0.5f, a: startingColor2, b: pulseRGBColor).GetRGB(), alpha);
			yield return null;
		}
		if (pulseRGBStoppingTime == 0f || !IsShown)
		{
			this.color = ColorX.From(startingColor2.GetRGB(), alpha);
			yield break;
		}
		float t = 0f;
		startingColor2 = this.color;
		Color? color = pulseRGBStopColor;
		Color finalColor = ((!color.HasValue) ? startingColor2 : pulseRGBStopColor.Value);
		while (t < pulseRGBStoppingTime)
		{
			t += Time.deltaTime;
			this.color = ColorX.From(Color.Lerp(startingColor2, finalColor, t / pulseRGBStoppingTime).GetRGB(), alpha);
			yield return null;
		}
	}

	public void AlphaAnimate(HagletHost host, float alphaTarget, float duration, bool hideWhenFinished = false)
	{
		animateAlphaTarget = alphaTarget;
		animateAlphaDuration = duration;
		animateAlphaHideWhenFinished = hideWhenFinished;
		HagletResettable.StartOrReset(routineFadeAlpha, host);
	}

	private IEnumerator<HagletYieldTerm> AnimateToAlphaRoutine()
	{
		float t = 0f;
		float alphaStart = alpha;
		float alphaEnd = animateAlphaTarget;
		while (t < animateAlphaDuration)
		{
			t += Time.deltaTime;
			alpha = Mathf.Lerp(alphaStart, alphaEnd, t / animateAlphaDuration);
			yield return null;
		}
		if (animateAlphaHideWhenFinished)
		{
			Hide();
		}
	}
}
public class UIEmpty : UIContainer
{
}
public class UIFlow : Singleton<UIFlow>
{
	private FMOD.Studio.EventInstance menuMusic;

	private MissionSceneMeta missionMeta;

	private const float fadeTime = 0.5f;

	private const float showTime = 1f;

	private const float totalTime = 2f;

	private HagletResettable frame0ToMainMenuRoutine;

	private HagletResettable missionSelectToMissionBriefRoutine;

	private HagletResettable missionBriefToMissionLoadoutRoutine;

	private HagletResettable missionLoadoutToMissionRoutine;

	private HagletResettable missionOutro;

	private HagletResettable mainMenuOrMissionToLastCheckPointRoutine;

	private HagletResettable missionToMainMenuRoutine;

	private HagletResettable reenterMissionRoutine;

	private HagletResettable missionToMissionFailedRoutine;

	public void OnAwakeLR()
	{
		frame0ToMainMenuRoutine = new HagletResettable(Frame0ToMainMenuRoutine());
		mainMenuOrMissionToLastCheckPointRoutine = new HagletResettable(MainMenuOrMissionToLastCheckPointRoutine());
		missionBriefToMissionLoadoutRoutine = new HagletResettable(MissionBriefToMissionLoadoutRoutine());
		missionSelectToMissionBriefRoutine = new HagletResettable(MissionSelectToMissionBriefRoutine());
		missionLoadoutToMissionRoutine = new HagletResettable(MissionLoadoutToMissionRoutine());
		IEnumerator<HagletYieldTerm> routineIn = MissionToMainMenuRoutine();
		HagletHost host = LR.Host;
		missionToMainMenuRoutine = new HagletResettable(routineIn, null, HagletStepTime.Update, -1, 10, host);
		reenterMissionRoutine = new HagletResettable(ReenterMissionRoutine());
		missionToMissionFailedRoutine = new HagletResettable(MissionToMissionFailedRoutine());
		missionOutro = new HagletResettable(MissionOutroRoutine());
	}

	public void StartFrame0ToMainMenu()
	{
		LR.Host.StartTopLevel(frame0ToMainMenuRoutine);
	}

	private IEnumerator<HagletYieldTerm> Frame0ToMainMenuRoutine()
	{
		if ((bool)AECameraFullscreenPass.Inst.IsFadedToClear || AECameraFullscreenPass.Inst.IsFadingToClear)
		{
			AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, 0.5f);
			do
			{
				yield return null;
			}
			while (AECameraFullscreenPass.Inst.IsFadingToColor);
			if (RC.Inst != null)
			{
				RC.Inst.RoomShow();
				Singleton<Hartman>.Inst.ResetOutside();
			}
		}
		if (!SaveData.gotSavedProgress)
		{
			yield return Wait.ForSeconds(2f);
			AC.Inst.PlayOneShot2D("event:/sfx/ambience/background v2/detritum/penthouse flourish");
			float t = 0f;
			while (t < 1f)
			{
				LR.Inst.SetLogoAlpha(LR.Inst.logoFadeCurve.Evaluate(t));
				t += Time.deltaTime / 5f;
				yield return null;
			}
			AECameraFullscreenPass.Inst.StartFadeToClear(3f);
			yield return Wait.ForSeconds(3f);
			while (t > 0f)
			{
				LR.Inst.SetLogoAlpha(LR.Inst.logoFadeCurve.Evaluate(t));
				t -= Time.deltaTime / 3f;
				yield return null;
			}
			LR.Inst.SetLogoAlpha(0f);
			yield return Wait.ForSeconds(2f);
			RR.Inst.PlayRoomHagis(AEResources.LoadFirstResource<GameObject>("HartmanCutscenes/P_Hartman_Prologue"));
			yield return Wait.ForChildren;
			IC.Inst.HACK_InputEnabled = false;
			Singleton<UIC>.Inst.Push<UIMainMenu>();
			yield return Singleton<UIC>.Inst.pushPopComplete;
			LR.Inst.LoadMissionIntoFrontend(AEResources.LoadFirstResource<MissionSceneMeta>("SceneMetas/MISSION_A1S1_Inversion"));
			yield return LR.Inst.OnLoadMissionComplete;
			IC.Inst.HACK_InputEnabled = true;
		}
		else
		{
			AECameraFullscreenPass.Inst.StartFadeToClear(0.6f);
			Singleton<UIC>.Inst.Push<UIMainMenu>();
			yield return Singleton<UIC>.Inst.pushPopComplete;
			RR.Inst.StartHartmanPottering();
		}
	}

	public void OpenMainMenu()
	{
		Singleton<UIC>.Inst.Push<UIMissionSelect>();
	}

	public void StartMissionSelectToMissionBrief(MissionSceneMeta missionMeta)
	{
		this.missionMeta = missionMeta;
		LR.Host.StartTopLevel(missionSelectToMissionBriefRoutine);
	}

	private IEnumerator<HagletYieldTerm> MissionSelectToMissionBriefRoutine()
	{
		Singleton<UIC>.Inst.Push<UIMissionBriefing>().SetState(missionMeta);
		yield return Singleton<UIC>.Inst.pushPopComplete;
	}

	public void StartMissionBriefToMissionLoadout(MissionSceneMeta missionMeta)
	{
		this.missionMeta = missionMeta;
		LR.Host.StartTopLevel(missionBriefToMissionLoadoutRoutine);
	}

	private IEnumerator<HagletYieldTerm> MissionBriefToMissionLoadoutRoutine()
	{
		CharacterData[] requiredChars = missionMeta.missionRequiredCharacters;
		for (int i = 0; i < requiredChars.Length; i++)
		{
			Party.Inst.UnlockPartyMember(requiredChars[i]);
		}
		int numInLoadout = missionMeta.numOfCharactersInLoadout;
		if (!missionMeta.doesNotNeedLoadout && numInLoadout > 0)
		{
			Singleton<UIC>.Inst.Push<UILoadout>().SetState(numInLoadout, missionMeta.missionRequiredCharacters, missionMeta.suggestedCharacters, missionMeta.restrictedCharacters);
			yield return Singleton<UIC>.Inst.pushPopComplete;
		}
		else
		{
			StartMissionLoadoutToMission();
		}
	}

	public void StartMissionLoadoutToMission()
	{
		LR.Host.StartTopLevel(missionLoadoutToMissionRoutine);
	}

	private IEnumerator<HagletYieldTerm> MissionLoadoutToMissionRoutine()
	{
		Party.Inst.ClearContributedPartyMembers();
		int numOfMembersInLoadout = Singleton<UIC>.Inst.Get<UILoadout>().GetNumOfMembersInLoadout();
		if (numOfMembersInLoadout >= 6)
		{
			ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
			for (int i = 0; i < unlockedPartyMembers.Length; i++)
			{
				if (unlockedPartyMembers[i].characterData.partyMemberID != PartyMemberID.Ashley)
				{
					Party.Inst.TryAddContributedPartyMember(unlockedPartyMembers[i].characterData);
				}
			}
		}
		else if (missionMeta.doesNotNeedLoadout)
		{
			CharacterData[] missionRequiredCharacters = missionMeta.missionRequiredCharacters;
			for (int j = 0; j < missionRequiredCharacters.Length; j++)
			{
				Party.Inst.TryAddContributedPartyMember(missionRequiredCharacters[j]);
			}
		}
		else
		{
			UILoadout.LoadoutPersonMeta[] membersInLoadout = Singleton<UIC>.Inst.Get<UILoadout>().GetMembersInLoadout();
			for (int k = 0; k < numOfMembersInLoadout; k++)
			{
				Party.Inst.TryAddContributedPartyMember(membersInLoadout[k].charData);
			}
		}
		yield return Singleton<UIC>.Inst.PopTo<UIMainMenu>(supressShowAll: true);
		SaveData.ClearMission();
		if (menuMusic.isValid())
		{
			menuMusic.stop(STOP_MODE.ALLOWFADEOUT);
		}
		LR.Inst.LoadMissionIntoFrontend(missionMeta);
		missionMeta = null;
		yield return LR.Inst.OnLoadMissionComplete;
	}

	public void StartMissionOutro()
	{
		LR.Host.StartTopLevel(missionOutro, null, prestep: true);
	}

	private IEnumerator<HagletYieldTerm> MissionOutroRoutine()
	{
		Singleton<UIC>.Inst.Push<UIEmpty>();
		yield return Singleton<UIC>.Inst.pushPopComplete;
		RR.Inst.PlayRoomHagis(SaveData.data.chosenMission.postMissionHartmanCutscene);
		yield return Wait.UntilNextUpdate();
		RC.Inst.RoomShow();
		yield return RR.Inst.roomHagisCompleted;
		if (SaveData.data.chosenMission != null && !string.IsNullOrEmpty(SaveData.data.chosenMission.missionCompleteMusicPath))
		{
			Transform roomAudioSource = RR.Inst.GetRoomAudioSource("SM_Apartment_GramophonePlayer");
			if ((bool)roomAudioSource)
			{
				menuMusic = AC.Inst.PlayOneShot3D(SaveData.data.chosenMission.missionCompleteMusicPath, roomAudioSource.position);
			}
		}
		RR.Inst.StartHartmanPottering(randomStart: false);
		if (SaveData.data.chosenMission != null && !SaveData.data.chosenMission.doesNotNeedOutroUI)
		{
			Singleton<UIC>.Inst.Push<UIMissionEnd>();
			yield return Singleton<UIC>.Inst.pushPopComplete;
			yield return Singleton<UIC>.Inst.Get<UIMissionEnd>().OnContinue;
			yield return Singleton<UIC>.Inst.Pop();
			yield return Wait.ForSeconds(0.5f);
			if (Party.Inst.GetContributedPartyMembers().Length != 0 && SaveData.data.IsMissionComplete("MISSION_A1O1_Cambridge"))
			{
				UICharacterDetails cd = Singleton<UIC>.Inst.Push<UICharacterDetails>();
				cd.SetStateForMissionEnd(Party.Inst.GetContributedPartyMembers());
				yield return cd.OnContinue;
				yield return Singleton<UIC>.Inst.Pop();
			}
		}
		SaveData.data.chosenMission = null;
		SaveData.SaveProgress();
		yield return Singleton<UIC>.Inst.PopTo<UIMainMenu>();
	}

	public HagletEvent DisplayDialog(DialogData dialogData, HagletTrigger onDialogComplete, string overrideDisplayName = null)
	{
		switch (dialogData.type)
		{
		case DialogData.Type.Ambient:
			UIAmbientSubtitles.Inst.Show(dialogData, onDialogComplete, overrideDisplayName);
			break;
		case DialogData.Type.Dialog:
		case DialogData.Type.Player:
		case DialogData.Type.Phone:
			if (Singleton<UIC>.Inst.IsShown<UINarrativeDialog>() && !Singleton<UIC>.Inst.IsStackAnimating())
			{
				UINarrativeDialog.Inst.Skip();
			}
			else
			{
				UIAmbientSubtitles.Inst.HideAll();
			}
			Singleton<UIC>.Inst.Push<UINarrativeDialog>().SetState(dialogData, onDialogComplete, overrideDisplayName);
			break;
		}
		return dialogData.OnComplete;
	}

	public void StartMainMenuOrMissionToLastCheckPoint()
	{
		LR.Host.StartTopLevel(mainMenuOrMissionToLastCheckPointRoutine);
	}

	private IEnumerator<HagletYieldTerm> MainMenuOrMissionToLastCheckPointRoutine()
	{
		if (SaveData.data.IsMissionComplete(SaveData.data.chosenMission.sceneName))
		{
			StartMissionOutro();
			yield break;
		}
		LR.Inst.SetPauseState(paused: false);
		if (UIMainMenu.Inst.IsShown)
		{
			UIMainMenu.Inst.HideAll();
			yield return Wait.ForChildren;
		}
		else if (!LR.DEBUG_autoReload && LR.DEBUG_missionScene == null)
		{
			yield return Singleton<UIC>.Inst.PopTo<UIMainMenu>(supressShowAll: true);
		}
		if (SaveData.gotSavedMission)
		{
			yield return SaveData.LoadMission(unthreaded: true);
			if (SaveData.lastResult.IsFailure())
			{
				SaveData.ClearMission();
			}
		}
		LR.Inst.LoadMissionIntoFrontend(SaveData.data.chosenMission);
		HagletYieldTerm hagletYieldTerm = LR.Inst.OnLoadMissionComplete;
		HagletYieldTerm hagletYieldTerm2;
		HagletYieldTerm missionLoadFailed = (hagletYieldTerm2 = LR.Inst.OnLoadMissionFailed);
		yield return hagletYieldTerm | hagletYieldTerm2;
		if (missionLoadFailed.met)
		{
			UIMainMenu.Inst.ShowAll();
		}
	}

	public void StartMissionToMainMenu()
	{
		LR.Host.StartTopLevel(missionToMainMenuRoutine, null, prestep: true);
	}

	private IEnumerator<HagletYieldTerm> MissionToMainMenuRoutine()
	{
		Func<bool> readyToSave = () => SaveData.lastResult.Exists();
		yield return Routine.ResetToHere();
		if (LR.Inst.IsPaused())
		{
			LR.Inst.SetPauseState(paused: false);
		}
		AC.Inst.StopSubMix();
		if (AECameraFullscreenPass.Inst.CurrentColour.a != 1f)
		{
			AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, 0.25f);
			yield return AECameraFullscreenPass.Inst.OnFadeToColourComplete;
		}
		if (GC.HACK_missionComplete)
		{
			yield return Wait.Until(readyToSave);
			SaveData.OnMissionComplete();
			CharacterData[] charDatas = SaveData.data.chosenMission.otherCharactersToGainXP;
			for (int i = 0; i < charDatas.Length; i++)
			{
				Party.Inst.TryAddContributedPartyMember(charDatas[i]);
			}
			Party.Inst.OnMissionComplete();
			string[] missionNames = SaveData.data.GetFurthestMissionGroup().missionNames;
			foreach (string missionName in missionNames)
			{
				MissionSceneMeta missionMetaByName = SaveData.GetMissionMetaByName(missionName);
				CharacterData[] missionRequiredCharacters = missionMetaByName.missionRequiredCharacters;
				foreach (CharacterData character in missionRequiredCharacters)
				{
					Party.Inst.UnlockPartyMember(character);
				}
			}
			SaveData.SaveProgress();
		}
		yield return LR.Inst.UnloadMissionScene();
		if (!GC.HACK_missionComplete)
		{
			RR.Inst.StartHartmanPottering();
		}
		AECameraFullscreenPass.Inst.StartFadeToClear(1f);
		if (GC.HACK_missionComplete)
		{
			StartMissionOutro();
			yield break;
		}
		if (AECameraFullscreenPass.Inst.IsFadingToClear)
		{
			yield return AECameraFullscreenPass.Inst.OnFadeToClearComplete;
		}
		if (!Singleton<UIC>.Inst.IsInStack<UIMainMenu>())
		{
			Singleton<UIC>.Inst.ClearImmediate();
			Singleton<UIC>.Inst.Push<UIMainMenu>();
			yield return Singleton<UIC>.Inst.pushPopComplete;
		}
		yield return Singleton<UIC>.Inst.PopTo<UIMainMenu>();
	}

	public void RestartCheckpoint()
	{
		if (!reenterMissionRoutine.running && reenterMissionRoutine.markedToRunBy == null)
		{
			LR.Host.StartTopLevel(reenterMissionRoutine);
		}
	}

	public void RestartMission()
	{
		SaveData.ClearMission();
		LR.Host.StartTopLevel(reenterMissionRoutine);
	}

	private IEnumerator<HagletYieldTerm> ReenterMissionRoutine()
	{
		UIAmbientSubtitles.Inst.RenderOnTop(onTop: false);
		VOController.Inst.VOStop();
		AC.Inst.StopSubMix();
		AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, 0.25f);
		yield return AECameraFullscreenPass.Inst.OnFadeToColourComplete;
		yield return LR.Inst.UnloadMissionScene();
		StartMainMenuOrMissionToLastCheckPoint();
	}

	public void StartMissionToMissionFailed()
	{
		LR.Host.StartTopLevel(missionToMissionFailedRoutine);
	}

	private IEnumerator<HagletYieldTerm> MissionToMissionFailedRoutine()
	{
		Singleton<UIC>.Inst.Push<UIMissionFailed>();
		yield return Singleton<UIC>.Inst.pushPopComplete;
	}
}
public class UIFocusHighlight : MonoBehaviour
{
	public interface UIFocussable
	{
		Transform transform { get; }

		event Action OnFocusEnter;

		event Action OnFocusExit;
	}

	private const float animDur = 0.09f;

	private const float advanceDist = 0.02f;

	private const float scaleIncrease = 0f;

	private UIFocussable focussable;

	private BoxCollider collision;

	private AnimFloat visibility = new AnimFloat(0f);

	private bool inFocus;

	private float startZ;

	private Vector2 startScale;

	private void Start()
	{
		focussable = GetComponent<UIFocussable>();
		focussable.OnFocusEnter += OnFocusEnter;
		focussable.OnFocusExit += OnFocusExit;
		collision = GetComponent<BoxCollider>();
		visibility.Interpolate = (float val) => MathfX.SineRemapLerp(val, MathfX.SineRemapEaseType.Out);
	}

	private void OnFocusEnter()
	{
		if (!inFocus)
		{
			if (!visibility.animating)
			{
				startZ = focussable.transform.localPosition.z;
				startScale = focussable.transform.localScale;
				visibility.AnimateTo(1f, 0.09f);
			}
			AC.Inst.PlayOneShot2D("event:/sfx/ui/general hover light");
			inFocus = true;
		}
	}

	private void OnFocusExit()
	{
		if (inFocus)
		{
			if (!visibility.animating)
			{
				visibility.AnimateTo(0f, 0.09f);
			}
			inFocus = false;
		}
	}

	private void Update()
	{
		if ((bool)visibility.animating)
		{
			float num = visibility.Update();
			Vector3 localPosition = focussable.transform.localPosition.RepZ(startZ - num * 0.02f);
			focussable.transform.localPosition = localPosition;
			if (collision != null)
			{
				collision.size = collision.size.RepZ(localPosition.z - startZ);
				collision.center = collision.center.RepZ(Mathf.Abs(collision.size.z * 0.5f));
			}
			focussable.transform.localScale = focussable.transform.localScale.RepXY(startScale.x + num * 0f, startScale.y + num * 0f);
			if (!visibility.animating && inFocus != (num == 1f))
			{
				visibility.AnimateTo((!inFocus) ? 0f : 1f, 0.09f);
			}
		}
	}
}
public class UIForceTextBoxAwake : MonoBehaviour
{
	private UITextbox textbox;

	private void Start()
	{
		textbox = GetComponent<UITextbox>();
		textbox.OnAwakeLR();
		textbox.UpdateSortingOrder();
	}
}
public class UIGameOver : UIContainer
{
	private static UIGameOver _instance;

	public static UIGameOver Inst => _instance;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_instance = this;
		HideAll();
	}
}
public class UIHartmanCutscene : UIContainer
{
	public override bool OnBackButtonPressed()
	{
		OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		return true;
	}
}
public class UIHologramOutlineRasterizer : MonoBehaviour
{
}
public class UIHotspot : UIContainer
{
	private static UIHotspot _instance;

	private const float kMaxCharacterWidth = 0.41f;

	[HideInInspector]
	public HagletTrigger OnComplete = new HagletTrigger();

	private UITextbox nameTextbox;

	private UITextbox descriptionTextbox;

	private UIImage image;

	private UIImage imageBackground;

	private UIImage headerLargeBackground;

	private UIImage headerSmallBackground;

	private UIImage[] border;

	private UIImage[] descriptionBackground;

	private UIButton descriptionButton;

	private UIContainer header;

	private UIContainer description;

	private Vector3 headerPosOriginal;

	private BoxCollider hotspotCollider;

	private TileActionHotspot hotspot;

	private string nameText;

	private string descriptionText;

	private Sprite sprite;

	public AnimationCurve curveWidth;

	public AnimationCurve curveHeight;

	public AnimationCurve curveContainerAlpha;

	public AnimationCurve curveImageAlpha;

	public AnimationCurve curveBackgroundAlpha;

	public AnimationCurve curveHeaderHeight;

	private HagletResettable showHideRoutine;

	private float animTarget;

	private float animValue;

	private float animTargetPrev;

	public static UIHotspot Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		header = GetContainer("Header");
		headerPosOriginal = header.transform.localPosition;
		headerSmallBackground = header.GetElement<UIImage>("BackgroundSmall");
		headerLargeBackground = header.GetElement<UIImage>("Background");
		nameTextbox = header.GetElement<UITextbox>("NameText");
		image = GetElement<UIImage>("Image");
		imageBackground = GetElement<UIImage>("Background");
		hotspotCollider = imageBackground.GetComponent<BoxCollider>();
		border = new UIImage[4]
		{
			GetElement<UIImage>("TL"),
			GetElement<UIImage>("TR"),
			GetElement<UIImage>("BL"),
			GetElement<UIImage>("BR")
		};
		description = GetContainer("Description");
		UIContainer container = description.GetContainer("Background");
		descriptionTextbox = description.GetElement<UITextbox>("DescriptionText");
		descriptionButton = GetElement<UIButton>("Help");
		descriptionButton.OnTapUp += DescriptionButton_OnTapUp;
		descriptionBackground = new UIImage[2]
		{
			container.GetElement<UIImage>("Left"),
			container.GetElement<UIImage>("Right")
		};
		showHideRoutine = new HagletResettable(ShowHideRoutine(), "Hotspot Show/Hide", HagletStepTime.Update, -1, 4);
	}

	private bool DescriptionButton_OnTapUp()
	{
		if (description.IsShown)
		{
			image.color = Color.white;
			description.HideAll();
		}
		else
		{
			image.color = ColorX.RGB(116, 123, 149);
			float x = descriptionBackground[0].transform.localScale.x;
			descriptionTextbox.wrapWidth = 0.41f * x;
			descriptionTextbox.SetKey(descriptionText);
			description.ShowAll();
		}
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		image.color = Color.white;
		if (!string.IsNullOrEmpty(Localisation.Retrieve(nameText)))
		{
			nameTextbox.SetKey(nameText);
		}
		else
		{
			nameTextbox.Hide();
		}
		ResizeHeaderBackground();
		if (!string.IsNullOrEmpty(Localisation.Retrieve(descriptionText)))
		{
			descriptionButton.Show();
		}
		else
		{
			descriptionButton.Hide();
		}
		description.HideAll();
		if ((bool)sprite)
		{
			image.SetImage(sprite);
		}
		animTargetPrev = animValue;
		animTarget = 1f;
		if (MR.Inst != null)
		{
			AC.Inst.PlayOneShot2D("event:/sfx/ui/hot spot ui open");
		}
		Routine.Start(showHideRoutine);
	}

	public override bool HideAll()
	{
		if (HagletHost.currHag == null)
		{
			base.HideAll();
		}
		else
		{
			animTargetPrev = animValue;
			animTarget = 0f;
			if (MR.Inst != null)
			{
				AC.Inst.PlayOneShot2D("event:/sfx/ui/hot spot ui close");
			}
			Routine.Start(showHideRoutine);
		}
		return true;
	}

	private IEnumerator<HagletYieldTerm> ShowHideRoutine()
	{
		float anim = 0f;
		while (anim < 0.75f)
		{
			anim += Time.deltaTime;
			animValue = Mathf.Lerp(animTargetPrev, animTarget, Mathf.Clamp01(anim / 0.75f));
			EvaluateAnimation(animValue);
			yield return Wait.ForSteps(1uL);
		}
		if (animTarget == 0f)
		{
			base.HideAll();
		}
	}

	private void EvaluateAnimation(float x)
	{
		SetAlpha(curveContainerAlpha.Evaluate(x));
		imageBackground.alpha = curveBackgroundAlpha.Evaluate(x);
		image.alpha = curveImageAlpha.Evaluate(x);
		Vector2 scale = default(Vector2);
		scale.x = curveWidth.Evaluate(x);
		scale.y = curveHeight.Evaluate(x);
		description.SetAlpha(curveImageAlpha.Evaluate(x));
		header.transform.localPosition = headerPosOriginal + Vector3.up * curveHeaderHeight.Evaluate(x);
		LayoutBorder(border, image, scale, 0.025f);
		LayoutDescription(descriptionBackground, image);
	}

	private void LayoutBorder(UIImage[] borderImages, UIImage target, Vector2 scale, float borderSize)
	{
		Bounds bounds = target.spriteRenderer.sprite.bounds;
		Vector3 lossyScale = target.transform.lossyScale;
		float x = lossyScale.x;
		float y = lossyScale.y;
		Vector3 vector = bounds.center + new Vector3(((0f - bounds.extents.x) * x - borderSize) * scale.x, bounds.extents.y * y + borderSize);
		Vector3 localPosition = bounds.center + new Vector3((bounds.extents.x * x + borderSize) * scale.x, bounds.extents.y * y + borderSize);
		Vector3 localPosition2 = bounds.center + new Vector3(((0f - bounds.extents.x) * x - borderSize) * scale.x, bounds.extents.y * y - bounds.extents.y * y * 2f * scale.y - borderSize);
		Vector3 vector2 = bounds.center + new Vector3((bounds.extents.x * x + borderSize) * scale.x, bounds.extents.y * y - bounds.extents.y * y * 2f * scale.y - borderSize);
		borderImages[0].transform.localPosition = vector;
		borderImages[1].transform.localPosition = localPosition;
		borderImages[2].transform.localPosition = localPosition2;
		borderImages[3].transform.localPosition = vector2;
		hotspotCollider.size = vector - vector2;
	}

	private void LayoutDescription(UIImage[] borderImages, UIImage target)
	{
		Bounds bounds = target.spriteRenderer.sprite.bounds;
		Bounds bounds2 = borderImages[0].spriteRenderer.sprite.bounds;
		float num = bounds.extents.x * 1.5f;
		float num2 = bounds2.extents.x * 2f;
		float num3 = Mathf.Clamp01(num / num2);
		borderImages[0].transform.localScale = Vector3.one * num3;
		borderImages[1].transform.localScale = Vector3.one * num3;
	}

	private void ResizeHeaderBackground()
	{
		bool flag = nameTextbox.TextVisible.Length <= 14;
		descriptionButton.transform.localPosition = descriptionButton.transform.localPosition.RepX((!flag) ? 0.1472f : 0.1174f);
		headerSmallBackground.gameObject.SetActive(flag);
		headerLargeBackground.gameObject.SetActive(!flag);
	}

	public void SetState(TileActionHotspot taHotspot, string text, Sprite img, string description, TextAlignment descAlignment)
	{
		hotspot = taHotspot;
		nameText = text;
		sprite = img;
		descriptionText = description;
		descriptionTextbox.alignment = descAlignment;
	}

	public override bool ConsumesActionButton()
	{
		return true;
	}

	public override void OnActionButtonPressed()
	{
		hotspot.OnHotspotComplete.Trigger();
		OnComplete.Trigger();
		Singleton<UIC>.Inst.Pop();
	}

	public override bool OnBackButtonPressed()
	{
		hotspot.OnHotspotComplete.Trigger();
		OnComplete.Trigger();
		Singleton<UIC>.Inst.Pop();
		return true;
	}
}
public class UIImage : UIElement
{
	[HideInInspector]
	public SpriteRenderer spriteRenderer;

	public override Color color
	{
		get
		{
			return spriteRenderer.color;
		}
		set
		{
			spriteRenderer.color = value;
		}
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		spriteRenderer = GetComponent<SpriteRenderer>();
	}

	public void SetImage(Sprite sprite)
	{
		spriteRenderer.sprite = sprite;
	}

	public override void OnAlphaSet(float alpha)
	{
		spriteRenderer.color = spriteRenderer.color.RepA(alpha);
	}
}
[RequireComponent(typeof(UIImage))]
public class UIImageHighlight : UIElement
{
	public Sprite spriteOnUnfocused;

	public Sprite spriteOnFocused;

	private UIImage image;

	private UIButton button;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		image = GetComponent<UIImage>();
		button = GetComponent<UIButton>();
		if ((bool)button)
		{
			button.OnFocusEnter += delegate
			{
				OnFocusEnter();
			};
			button.OnFocusExit += delegate
			{
				OnFocusExit();
			};
		}
	}

	public void OnFocusEnter()
	{
		image.SetImage(spriteOnFocused);
	}

	public void OnFocusExit()
	{
		image.SetImage(spriteOnUnfocused);
	}
}
[RequireComponent(typeof(UIImage))]
public class UIImagePulse : UIElement
{
	public float minAlpha;

	public float maxAlpha;

	public float frequancy;

	private UIImage image;

	private SpriteRenderer spriteRenderer;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		image = GetComponent<UIImage>();
		spriteRenderer = GetComponent<SpriteRenderer>();
	}

	public override void Show()
	{
		base.Show();
		base.alpha = 0f;
	}

	public override void Hide()
	{
		base.Hide();
		StopImagePulse();
	}

	public override void OnAlphaSet(float alpha)
	{
		if (image != null)
		{
			image.alpha = alpha;
		}
	}

	public void StartImagePulse()
	{
		if (spriteRenderer.enabled)
		{
			PulseAlphaStart(LR.Host, minAlpha, maxAlpha, frequancy);
		}
	}

	public void StopImagePulse()
	{
		PulseAlphaStop(0f, 0.15f);
	}
}
public class UIImageSelectionPing : UIImage
{
	private AnimFloat anim = new AnimFloat(0f);

	public override void Show()
	{
		base.Show();
		anim.Value = 1f;
		anim.AnimateTo(0f, 0.2f);
		UpdateSprite(1f);
	}

	public override void Hide()
	{
		base.Hide();
	}

	private void UpdateSprite(float value)
	{
		base.transform.localScale = Vector3.one * (1f + (1f - value) * 2f);
		float a = (0f - Mathf.Cos(Mathf.Pow(value * 2.5f - 2.5f, 2f)) + 1f) / 2f;
		Color color = spriteRenderer.color;
		spriteRenderer.color = new Color(color.r, color.g, color.b, a);
	}

	private void Update()
	{
		float num = anim.Update();
		if (num > 0f)
		{
			UpdateSprite(num);
		}
		else
		{
			base.transform.gameObject.SetActive(value: false);
		}
	}
}
public struct ItemDisplay
{
	public UIImage imageSelectedItem;

	public UITextbox textBoxSelectedName;

	public UITextbox textBoxSelectedCategory;

	public UITextbox textBoxSelectedQuantity;

	public UITextbox textBoxSelectedDescription;

	public ItemStackInstance selectedItemStack;

	public void SetupDisplay(UIContainer displayContainer)
	{
		imageSelectedItem = displayContainer.GetElement<UIImage>("ItemIcon");
		textBoxSelectedName = displayContainer.GetElement<UITextbox>("ItemName");
		textBoxSelectedCategory = displayContainer.GetElement<UITextbox>("ItemCategory");
		textBoxSelectedQuantity = displayContainer.GetElement<UITextbox>("ItemQuantity");
		textBoxSelectedDescription = displayContainer.GetElement<UITextbox>("ItemDescription");
	}

	public void ClearSelectedItem()
	{
		selectedItemStack = null;
		imageSelectedItem.SetImage(null);
		textBoxSelectedName.Clear();
		textBoxSelectedName.Present();
		textBoxSelectedCategory.Clear();
		textBoxSelectedCategory.Present();
		textBoxSelectedQuantity.Clear();
		textBoxSelectedQuantity.Present();
		textBoxSelectedDescription.Clear();
		textBoxSelectedDescription.Present();
	}

	public void SetSelectedItem(ItemStackInstance stack)
	{
		selectedItemStack = stack;
		imageSelectedItem.SetImage(stack.meta.Icon);
		textBoxSelectedName.Clear();
		textBoxSelectedName.Append(stack.meta.Name);
		textBoxSelectedName.Present();
		textBoxSelectedCategory.Clear();
		textBoxSelectedCategory.Append(stack.meta.category.ToString());
		textBoxSelectedCategory.Present();
		textBoxSelectedQuantity.Clear();
		textBoxSelectedQuantity.Append(Party.Inst.GetItemCount(stack.meta));
		textBoxSelectedQuantity.Present();
		textBoxSelectedDescription.Clear();
		textBoxSelectedDescription.Append(stack.meta.descriptionLong);
		textBoxSelectedDescription.Present();
	}
}
public class UIInventory : UIContainer
{
	private class UIInventoryItem
	{
		public Transform xform;

		public GameObject gameObject;

		public UIContainer container;

		public UIButton icon;
	}

	private UITextbox textBoxCurrency;

	private UIButton buttonBack;

	private UIButton buttonUse;

	public v2i gridDimensions = new v2i(6, 4);

	private UIImage gridBackground;

	private float margin = 0.05f;

	private UIInventoryItem[] items;

	private UIContainer anchor;

	private ItemDisplay itemDisplay;

	public override void Initialise()
	{
		items = new UIInventoryItem[gridDimensions.x * gridDimensions.y];
		Transform transform = base.transform.FindChild("Root/Items/Anchor");
		for (int i = 0; i < items.Length; i++)
		{
			UIInventoryItem uIInventoryItem = (items[i] = new UIInventoryItem());
			uIInventoryItem.gameObject = LR.LoadPrefabResource("UI/P_UIInventoryItem", transform);
			uIInventoryItem.xform = uIInventoryItem.gameObject.transform;
			uIInventoryItem.container = uIInventoryItem.gameObject.GetComponent<UIContainer>();
		}
		LR.InitialiseUIHierarchy(transform);
		base.Initialise();
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIContainer container = GetContainer("Items");
		gridBackground = container.GetElement<UIImage>("Background");
		anchor = container.GetContainer("Anchor");
		float num = gridBackground.transform.localScale.x * 2f / (float)gridDimensions.x;
		for (int i = 0; i < items.Length; i++)
		{
			UIInventoryItem uIInventoryItem = items[i];
			uIInventoryItem.icon = uIInventoryItem.gameObject.GetComponent<UIButton>();
			uIInventoryItem.xform.localRotation = Quaternion.identity;
			int num2 = i % gridDimensions.x;
			int num3 = -i / gridDimensions.x;
			uIInventoryItem.xform.localPosition = new Vector3(((float)num2 + margin * (float)num2) * num, ((float)num3 + margin * (float)num3) * num, 0f);
			uIInventoryItem.xform.localScale = (Vector3.one * num).RepZ(0.5f);
			uIInventoryItem.icon.image.spriteRenderer.sortingOrder = gridBackground.spriteRenderer.sortingOrder + 1;
			uIInventoryItem.icon.OnTapUpWithUserData += ShowItemDetails_OnTapUpWithUserData;
		}
		itemDisplay.SetupDisplay(GetContainer("DynamicArea").GetContainer("ItemInfo"));
		textBoxCurrency = GetElement<UITextbox>("Currency");
	}

	private bool ShowItemDetails_OnTapUpWithUserData(object userData)
	{
		ItemStackInstance selectedItem = (ItemStackInstance)userData;
		itemDisplay.SetSelectedItem(selectedItem);
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		for (int i = 0; i < items.Length; i++)
		{
			items[i].container.HideAll();
		}
		for (int j = 0; j < Party.Inst.inventoryItems.Count; j++)
		{
			ItemStackInstance itemStackInstance = Party.Inst.inventoryItems[j];
			UIInventoryItem uIInventoryItem = items[j];
			uIInventoryItem.container.ShowAll();
			uIInventoryItem.icon.image.SetImage(itemStackInstance.meta.Icon);
			uIInventoryItem.icon.userData = Party.Inst.inventoryItems[j];
		}
		textBoxCurrency.Clear();
		textBoxCurrency.Append("");
		textBoxCurrency.Append(Party.Inst.currency);
		textBoxCurrency.Present();
		if (Party.Inst.inventoryItems.Count > 0)
		{
			itemDisplay.SetSelectedItem(Party.Inst.inventoryItems[0]);
		}
	}
}
public class UILoadingBar : MonoBehaviour
{
	private static UILoadingBar _instance;

	private Camera relativeCamera;

	private HagletResettable showHide;

	private bool showing;

	private int totalProgressChunks = -1;

	private int completedProgressChunks;

	private Transform loadingPip;

	private SpriteRenderer[] allRenderers;

	public static UILoadingBar Inst => _instance;

	public bool IsShown => base.gameObject.activeSelf;

	public void Awake()
	{
		if (loadingPip == null)
		{
			_instance = this;
			_instance.transform.position = new Vector3(0f, 1.18f, 4.44f);
			loadingPip = base.transform.Find("LoadingPip");
			allRenderers = GetComponentsInChildren<SpriteRenderer>();
			showHide = new HagletResettable(ShowHideRoutine(), "Loading Bar Show Hide");
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			base.gameObject.SetActive(value: false);
			for (int i = 0; i < allRenderers.Length; i++)
			{
				allRenderers[i].color = allRenderers[i].color.RepA(0f);
			}
		}
	}

	private IEnumerator<HagletYieldTerm> ShowHideRoutine()
	{
		base.gameObject.SetActive(value: true);
		float t = 0f;
		float animTime = 0.2f;
		while (t < animTime)
		{
			t += Time.deltaTime;
			float animProgress = Mathf.Clamp01(t / animTime);
			if (!showing)
			{
				animProgress = 1f - animProgress;
			}
			for (int i = 0; i < allRenderers.Length; i++)
			{
				allRenderers[i].color = allRenderers[i].color.RepA(animProgress);
			}
			yield return null;
		}
		if (!showing)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void Show(int totalProgressChunks = -1)
	{
		this.totalProgressChunks = totalProgressChunks;
		completedProgressChunks = 0;
		loadingPip.localScale = loadingPip.localScale.RepX(0f);
		showing = true;
		if ((bool)showHide.running)
		{
			showHide.Reset();
			showHide.host.Pause(showHide);
		}
		LR.Host.StartTopLevel(showHide);
	}

	public void Hide()
	{
		showing = false;
		if ((bool)showHide.running)
		{
			showHide.Reset();
			showHide.host.Pause(showHide);
		}
		LR.Host.StartTopLevel(showHide);
	}

	public void SetLoadProgress(float progress)
	{
		loadingPip.localScale = loadingPip.localScale.RepX(progress * 29f);
	}

	public void IncrementProgressChunks()
	{
		completedProgressChunks++;
		SetLoadProgress((float)completedProgressChunks / (float)totalProgressChunks);
	}

	public void SetProgressToNextChunk(float subProgress)
	{
		float num = (float)completedProgressChunks / (float)totalProgressChunks;
		float num2 = (float)(completedProgressChunks + 1) / (float)totalProgressChunks;
		SetLoadProgress(num + (num2 - num) * subProgress);
	}

	public void SetRelativeCamera(Transform newCam)
	{
		base.transform.position = newCam.transform.position + new Vector3(0f, 0.3f, 5.95f);
	}
}
public class UILoadout : UIContainer
{
	[Serializable]
	public class LoadoutPersonMeta
	{
		public CharacterData charData;

		public bool required;

		public UIContainer container;

		public UIContainer nameplateContainer;

		public UIContainer lockedContainer;

		public UIContainer emptyContainer;

		public UIContainer swapContainer;

		public UIContainer emptyHighlightContainer;

		public UIContainer swapHighlightContainer;

		public UIImage imageCharacterFrame;

		public UIImage imageFrameBackground;

		public UIImage imagePortrait;

		public UITextbox textboxName;

		public UITextbox textboxLevel;

		public UITextbox textboxClass;

		public UIImage imageLockedFrame;

		public UIImage imageLockedNameplate;

		public UIImage imageLockedButton;

		public UIImage imageLockedIcon;

		public UITextbox textboxEmpty;

		public UIImage imageEmptyBackground;

		public UIImage imageEmptyPlusBackground;

		public UIImage imageEmptyButton;

		public UIImage imageEmptyIcon;

		public UIImage imageEmptyHighlightFrame;

		public UIImage imageEmptyHighlightButton;

		public UIButton buttonAddCharacterButton;

		public UIButton buttonImagePortrait;

		public UIImage imageSwapButton;

		public UIImage imageSwapIcon;

		public UIImage imageSwapButtonHighlight;

		public UIImage imageSwapButtonIconHighlight;
	}

	[Serializable]
	public class MemberSelectMeta
	{
		public CharacterData charData;

		public UIContainer container;

		public UIContainer nameplateContainer;

		public UIButton buttonPortrait;

		public UIImage buttonHighlight;

		public UITextbox textboxName;

		public UITextbox textboxLevel;

		public UITextbox textboxClass;
	}

	public Color buttonSelected;

	private UIImage imageBackgroundLarge;

	private UIImage imageBackgroundSmall;

	private UIImage imageHeaderLarge;

	private UIImage imageHeaderSmall;

	private UITextbox textboxMainTitle;

	private UITextbox textboxMainTitleShadow;

	private UITextbox textboxShopButton;

	private UITextbox textboxContinue;

	private UITextbox textboxManageTeam;

	private UIContainer membersContainer;

	private UIContainer fullPartyContainer;

	private UIContainer memberSelectContainer;

	private UIContainer confirmContainer;

	private Action shopButtonFocusEnterTutorial;

	private Action shopButtonFocusEnterNormal;

	private Action shopButtonFocusExitTutorial;

	private Action shopButtonFocusExitNormal;

	private Func<bool> shopButtonTapUp;

	private Color HACK_textBoxShopColorOriginal;

	private LoadoutPersonMeta[] memberMetas = new LoadoutPersonMeta[4];

	private LoadoutPersonMeta[] fullPartyMemberMetas = new LoadoutPersonMeta[6];

	private bool isFullPartyLoadout;

	private bool tutorialMode;

	private int numOfMembersInLoadout;

	private MemberSelectMeta[] memberSelectMetas = new MemberSelectMeta[6];

	private int loadoutIndex = -1;

	private UIButton buttonBack;

	private UIButton buttonContinue;

	private UIButton buttonShop;

	private UIButton buttonSuggestedChars;

	private UIButton buttonBackMemberSelect;

	private UIButton buttonManageTeam;

	private UIContainer sideButtonContainer;

	private Vector3 sideButtonLeftPos = new Vector3(-0.18f, 0f, 0f);

	private Vector3 sideButtonRightPos = Vector3.zero;

	private CharacterData[] requiredCharDatas;

	private CharacterData[] suggestedCharDatas;

	private CharacterData[] restrictedCharDatas;

	private CharacterData[] selectableMembers = new CharacterData[6];

	private bool SelectedAllMembers
	{
		get
		{
			if (numOfMembersInLoadout >= 6)
			{
				return true;
			}
			for (int i = 0; i < numOfMembersInLoadout; i++)
			{
				if (memberMetas[i].charData == null)
				{
					return false;
				}
			}
			return true;
		}
	}

	public LoadoutPersonMeta[] GetMembersInLoadout()
	{
		return (!isFullPartyLoadout) ? memberMetas : fullPartyMemberMetas;
	}

	public int GetNumOfMembersInLoadout()
	{
		return numOfMembersInLoadout;
	}

	private void UpdateMeta(int index, CharacterData charData, bool required)
	{
		LoadoutPersonMeta loadoutPersonMeta = memberMetas[index];
		loadoutPersonMeta.charData = charData;
		if (charData != null)
		{
			loadoutPersonMeta.imagePortrait.SetImage(charData.GetLoadoutX4Sprite());
			if (base.IsShown)
			{
				loadoutPersonMeta.imagePortrait.Show();
			}
			loadoutPersonMeta.textboxName.SetKey(charData.DisplayName);
			if (base.IsShown)
			{
				loadoutPersonMeta.textboxName.Show();
			}
			PartyMember unlockedPartyMember = Party.Inst.GetUnlockedPartyMember(charData);
			loadoutPersonMeta.textboxLevel.SetKey("UILOADOUT_MEMBERLEVEL", unlockedPartyMember.Level);
			loadoutPersonMeta.textboxClass.SetKey(charData.ClassName);
			if (base.IsShown)
			{
				loadoutPersonMeta.textboxClass.Show();
			}
		}
		else
		{
			loadoutPersonMeta.imagePortrait.Hide();
			loadoutPersonMeta.textboxName.Hide();
			loadoutPersonMeta.textboxLevel.Hide();
			loadoutPersonMeta.textboxClass.Hide();
		}
		loadoutPersonMeta.required = required;
		loadoutPersonMeta.buttonImagePortrait.interactable = !required;
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textboxMainTitle = GetElement<UITextbox>("Title");
		textboxMainTitleShadow = GetElement<UITextbox>("Title_DropShadow");
		imageBackgroundLarge = GetElement<UIImage>("Background");
		imageBackgroundSmall = GetElement<UIImage>("SmallBackground");
		imageHeaderLarge = GetElement<UIImage>("TitleHeader");
		imageHeaderSmall = GetElement<UIImage>("SmallTitleHeader");
		string[] array = new string[6] { "Member0", "Member1", "Member2", "Member3", "Member4", "Member5" };
		membersContainer = GetContainer("Members");
		for (int i = 0; i < memberMetas.Length; i++)
		{
			UIContainer container = membersContainer.GetContainer(array[i]);
			LoadoutPersonMeta loadoutPersonMeta = (memberMetas[i] = new LoadoutPersonMeta());
			loadoutPersonMeta.container = container;
			loadoutPersonMeta.imageCharacterFrame = container.GetElement<UIImage>("CharacterFrame");
			loadoutPersonMeta.imageFrameBackground = container.GetElement<UIImage>("FrameBackground");
			loadoutPersonMeta.imagePortrait = container.GetElement<UIImage>("Portrait");
			loadoutPersonMeta.nameplateContainer = container.GetContainer("Nameplate");
			loadoutPersonMeta.textboxName = loadoutPersonMeta.nameplateContainer.GetElement<UITextbox>("Name");
			loadoutPersonMeta.textboxLevel = loadoutPersonMeta.nameplateContainer.GetElement<UITextbox>("Level");
			loadoutPersonMeta.textboxClass = loadoutPersonMeta.nameplateContainer.GetElement<UITextbox>("Class");
			loadoutPersonMeta.lockedContainer = container.GetContainer("Locked");
			loadoutPersonMeta.emptyContainer = container.GetContainer("EmptySlot");
			loadoutPersonMeta.swapContainer = container.GetContainer("SwapCharacter");
			loadoutPersonMeta.swapHighlightContainer = container.GetContainer("SwapCharacterHighlight");
			loadoutPersonMeta.emptyHighlightContainer = container.GetContainer("EmptySlotHighlight");
			loadoutPersonMeta.buttonImagePortrait = container.GetElement<UIButton>("FrameBackground");
			loadoutPersonMeta.buttonImagePortrait.OnTapUpWithUserData += ButtonCharacterSwap_OnTapUpWithUserData;
			loadoutPersonMeta.buttonImagePortrait.OnFocusEnterWithUserData += ButtonHighlight;
			loadoutPersonMeta.buttonImagePortrait.OnFocusExitWithUserData += ButtonUnHighlight;
			loadoutPersonMeta.buttonImagePortrait.userData = i;
		}
		fullPartyContainer = GetContainer("FullParty");
		for (int j = 0; j < fullPartyMemberMetas.Length; j++)
		{
			UIContainer container2 = fullPartyContainer.GetContainer(array[j]);
			LoadoutPersonMeta loadoutPersonMeta2 = (fullPartyMemberMetas[j] = new LoadoutPersonMeta());
			loadoutPersonMeta2.container = container2;
			loadoutPersonMeta2.imageCharacterFrame = container2.GetElement<UIImage>("CharacterFrame");
			loadoutPersonMeta2.imageFrameBackground = container2.GetElement<UIImage>("FrameBackground");
			loadoutPersonMeta2.imagePortrait = container2.GetElement<UIImage>("Portrait");
			UIContainer container3 = container2.GetContainer("Nameplate");
			loadoutPersonMeta2.textboxName = container3.GetElement<UITextbox>("Name");
			loadoutPersonMeta2.textboxLevel = container3.GetElement<UITextbox>("Level");
			loadoutPersonMeta2.textboxClass = container3.GetElement<UITextbox>("Class");
			UIContainer container4 = container2.GetContainer("Locked");
			loadoutPersonMeta2.imageLockedFrame = container4.GetElement<UIImage>("CharacterFrame_LockedOverlay");
			loadoutPersonMeta2.imageLockedNameplate = container4.GetElement<UIImage>("Nameplate_LockedOverlay");
		}
		memberSelectContainer = GetContainer("ChooseMember");
		string[] array2 = new string[6] { "Character01", "Character02", "Character03", "Character04", "Character05", "Character06" };
		for (int k = 0; k < memberSelectMetas.Length; k++)
		{
			UIContainer container5 = memberSelectContainer.GetContainer(array2[k]);
			MemberSelectMeta meta = (memberSelectMetas[k] = new MemberSelectMeta());
			meta.container = container5;
			meta.buttonPortrait = container5.GetElement<UIButton>("Portrait");
			meta.buttonHighlight = container5.GetElement<UIImage>("PortraitOutlineHighlight");
			meta.buttonPortrait.OnTapUpWithUserData += ButtonPortrait_OnTapUpWithUserData;
			meta.buttonPortrait.OnFocusEnter += delegate
			{
				if (!meta.buttonHighlight.IsShown)
				{
					meta.buttonHighlight.Show();
				}
			};
			meta.buttonPortrait.OnFocusExit += delegate
			{
				if (meta.buttonHighlight.IsShown)
				{
					meta.buttonHighlight.Hide();
				}
			};
			meta.nameplateContainer = container5.GetContainer("Nameplate");
			meta.textboxName = meta.nameplateContainer.GetElement<UITextbox>("Name");
			meta.textboxLevel = meta.nameplateContainer.GetElement<UITextbox>("Level");
			meta.textboxClass = meta.nameplateContainer.GetElement<UITextbox>("Class");
		}
		confirmContainer = GetContainer("ConfirmDialog");
		UIButton element = confirmContainer.GetElement<UIButton>("Yes");
		element.OnTapUp += ButtonConfirm_OnTapUp;
		UIButton element2 = confirmContainer.GetElement<UIButton>("No");
		element2.OnTapUp += ButtonCancel_OnTapUp;
		sideButtonContainer = GetContainer("SideButtonContainer");
		buttonShop = sideButtonContainer.GetElement<UIButton>("ShopButton");
		buttonShop.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UIStoreFront>();
			return true;
		};
		textboxShopButton = sideButtonContainer.GetElement<UITextbox>("ShopText");
		textboxShopButton.SetKey("UILOADOUT_SHOPBUTTON");
		HACK_textBoxShopColorOriginal = textboxShopButton.color;
		shopButtonFocusEnterTutorial = delegate
		{
			textboxShopButton.PulseRGBStop(LR.Host, 0.035f, ColorX.RGB(207, 227, 112));
			textboxShopButton.PulseScaleStop(0.025f);
		};
		shopButtonFocusEnterNormal = delegate
		{
			textboxShopButton.color = ColorX.RGB(207, 227, 112);
		};
		shopButtonFocusExitTutorial = delegate
		{
			textboxShopButton.PulseRGBStart(LR.Host, ColorX.RGB(207, 227, 112), 0.85f, HACK_textBoxShopColorOriginal);
			textboxShopButton.PulseScaleStart(LR.Host, 0.9f, 1.2f);
		};
		shopButtonFocusExitNormal = delegate
		{
			textboxShopButton.color = HACK_textBoxShopColorOriginal;
		};
		buttonShop.OnFocusEnter += shopButtonFocusEnterNormal;
		buttonShop.OnFocusExit += shopButtonFocusExitNormal;
		shopButtonTapUp = delegate
		{
			SaveData.data.tutorials.visitedShop = true;
			return true;
		};
		buttonBack = sideButtonContainer.GetElement<UIButton>("BackButton");
		UITextbox backText = sideButtonContainer.GetElement<UITextbox>("BackText");
		Color origBackColor = backText.color;
		buttonBack.OnFocusEnter += delegate
		{
			backText.color = buttonSelected;
		};
		buttonBack.OnFocusExit += delegate
		{
			backText.color = origBackColor;
		};
		buttonContinue = sideButtonContainer.GetElement<UIButton>("ContinueButton");
		textboxContinue = sideButtonContainer.GetElement<UITextbox>("ContinueText");
		Color origContinueColor = textboxContinue.color;
		buttonContinue.OnTapUp += ButtonContinue_OnTapUp;
		buttonContinue.OnFocusEnter += delegate
		{
			textboxContinue.color = buttonSelected;
		};
		buttonContinue.OnFocusExit += delegate
		{
			float alpha = textboxContinue.alpha;
			textboxContinue.color = origContinueColor;
			textboxContinue.alpha = alpha;
		};
		buttonSuggestedChars = membersContainer.GetElement<UIButton>("ButtonSuggestedChars");
		buttonSuggestedChars.OnTapUp += ButtonSuggestedChars_OnTapUp;
		buttonBackMemberSelect = memberSelectContainer.GetElement<UIButton>("BackButton");
		UITextbox backTextMember = memberSelectContainer.GetElement<UITextbox>("BackText");
		Color origBackColorMember = backTextMember.color;
		buttonBackMemberSelect.OnFocusEnter += delegate
		{
			backTextMember.color = buttonSelected;
		};
		buttonBackMemberSelect.OnFocusExit += delegate
		{
			backTextMember.color = origBackColorMember;
		};
		buttonBackMemberSelect.OnTapUp += ButtonBack_MemberSelect_OnTapUp;
		buttonManageTeam = sideButtonContainer.GetElement<UIButton>("ManageTeamButton");
		textboxManageTeam = sideButtonContainer.GetElement<UITextbox>("ManageText");
		Color origBackColorManage = textboxManageTeam.color;
		buttonManageTeam.OnFocusEnter += delegate
		{
			textboxManageTeam.color = buttonSelected;
		};
		buttonManageTeam.OnFocusExit += delegate
		{
			textboxManageTeam.color = origBackColorManage;
		};
		buttonManageTeam.OnTapUp += ManageTeam_OnTapUp;
		UIImageHighlight buttonIcon = membersContainer.GetElement<UIImageHighlight>("ButtonSuggestedCharsIcon");
		UITextbox buttonText = membersContainer.GetElement<UITextbox>("SuggestedCharsText");
		Color colorOrig = buttonText.color;
		buttonSuggestedChars.OnFocusEnter += delegate
		{
			buttonIcon.OnFocusEnter();
			buttonText.color = buttonSelected;
		};
		buttonSuggestedChars.OnFocusExit += delegate
		{
			buttonIcon.OnFocusExit();
			buttonText.color = colorOrig;
		};
		ResetCharactersToDefault();
	}

	private void ResetCharactersToDefault()
	{
		for (int i = 0; i < memberMetas.Length; i++)
		{
			LoadoutPersonMeta loadoutPersonMeta = memberMetas[i];
			loadoutPersonMeta.textboxName.Hide();
			loadoutPersonMeta.textboxLevel.Hide();
			loadoutPersonMeta.textboxClass.Hide();
			loadoutPersonMeta.imagePortrait.Hide();
			loadoutPersonMeta.charData = null;
			loadoutPersonMeta.required = false;
		}
		numOfMembersInLoadout = 0;
	}

	private bool ButtonCharacterSwap_OnTapUpWithUserData(object obj)
	{
		loadoutIndex = (int)obj;
		ShowMemberSelect();
		return true;
	}

	private bool ManageTeam_OnTapUp()
	{
		Singleton<UIC>.Inst.Push<UICharacterDetails>().SetStateForFullPartyEdit(Party.Inst.GetUnlockedPartyMembers());
		return true;
	}

	private void MemberButtonHighlightFocusEnter(object obj)
	{
		int num = (int)obj;
		memberSelectMetas[num].buttonHighlight.Show();
	}

	private void MemberButtonHighlightFocusExit(object obj)
	{
		int num = (int)obj;
		if (memberSelectMetas[num].buttonHighlight.IsShown)
		{
			memberSelectMetas[num].buttonHighlight.Hide();
		}
	}

	private void ButtonHighlight(object obj)
	{
		int num = (int)obj;
		if (memberMetas[num].swapContainer.IsShown)
		{
			memberMetas[num].swapHighlightContainer.ShowAll();
		}
		else if (memberMetas[num].emptyContainer.IsShown)
		{
			memberMetas[num].emptyHighlightContainer.ShowAll();
		}
	}

	private void ButtonUnHighlight(object obj)
	{
		int num = (int)obj;
		if (memberMetas[num].swapContainer.IsShown && memberMetas[num].swapHighlightContainer.IsShown)
		{
			memberMetas[num].swapHighlightContainer.HideAll();
		}
		else if (memberMetas[num].emptyContainer.IsShown && memberMetas[num].emptyHighlightContainer.IsShown)
		{
			memberMetas[num].emptyHighlightContainer.HideAll();
		}
	}

	private bool ButtonBack_Loadout_OnTapUp()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	private bool ButtonContinue_OnTapUp()
	{
		confirmContainer.ShowAll();
		membersContainer.SetInteractable(interactable: false);
		fullPartyContainer.SetInteractable(interactable: false);
		sideButtonContainer.SetInteractable(interactable: false);
		membersContainer.SetAlpha(0.5f);
		fullPartyContainer.SetAlpha(0.5f);
		sideButtonContainer.SetAlpha(0.5f);
		return true;
	}

	private bool ButtonConfirm_OnTapUp()
	{
		membersContainer.SetInteractable(interactable: true);
		fullPartyContainer.SetInteractable(interactable: true);
		sideButtonContainer.SetInteractable(interactable: true);
		membersContainer.SetAlpha(1f);
		fullPartyContainer.SetAlpha(1f);
		sideButtonContainer.SetAlpha(1f);
		Singleton<UIFlow>.Inst.StartMissionLoadoutToMission();
		return true;
	}

	private bool ButtonCancel_OnTapUp()
	{
		membersContainer.SetInteractable(interactable: true);
		fullPartyContainer.SetInteractable(interactable: true);
		sideButtonContainer.SetInteractable(interactable: true);
		membersContainer.SetAlpha(1f);
		fullPartyContainer.SetAlpha(1f);
		sideButtonContainer.SetAlpha(1f);
		confirmContainer.HideAll();
		return true;
	}

	private bool ButtonPortrait_OnTapUpWithUserData(object obj)
	{
		CharacterData characterData = (CharacterData)obj;
		if (characterData != null)
		{
			SetCharacterSelectState(characterData, loadoutIndex);
			loadoutIndex = -1;
			ShowAll();
		}
		return true;
	}

	private bool ButtonDetails_OnTapUpWithUserData(object obj)
	{
		return true;
	}

	private bool ButtonBack_MemberSelect_OnTapUp()
	{
		loadoutIndex = -1;
		ShowAll();
		return true;
	}

	private bool ButtonSuggestedChars_OnTapUp()
	{
		int num = 0;
		for (int i = 0; i < memberMetas.Length; i++)
		{
			if (!memberMetas[i].required && memberMetas[i].container.IsShown)
			{
				if (Party.Inst.GetUnlockedPartyMember(suggestedCharDatas[num]) != null)
				{
					SetCharacterSelectState(suggestedCharDatas[num], i);
				}
				num++;
			}
		}
		ShowAll();
		return true;
	}

	public void SetState(int numOfMembers, CharacterData[] reqCharDatas, CharacterData[] suggestCharDatas, CharacterData[] restrictedCharDatas)
	{
		ResetCharactersToDefault();
		requiredCharDatas = reqCharDatas;
		suggestedCharDatas = suggestCharDatas;
		this.restrictedCharDatas = restrictedCharDatas;
		int num = 0;
		ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
		for (int i = 0; i < unlockedPartyMembers.Length; i++)
		{
			CharacterData characterData = unlockedPartyMembers[i].characterData;
			if (!ArrayX.Contains(restrictedCharDatas, characterData))
			{
				num++;
			}
		}
		numOfMembersInLoadout = Mathf.Min(num, numOfMembers);
		if (num - requiredCharDatas.Length != 1)
		{
			return;
		}
		CharacterData[] array = requiredCharDatas;
		Array.Resize(ref array, array.Length + 1);
		requiredCharDatas = array;
		for (int j = 0; j < unlockedPartyMembers.Length; j++)
		{
			CharacterData characterData2 = unlockedPartyMembers[j].characterData;
			if (!ArrayX.Contains(restrictedCharDatas, characterData2) && !ArrayX.Contains(requiredCharDatas, characterData2))
			{
				array[array.Length - 1] = characterData2;
				break;
			}
		}
	}

	private void SetCharacterSelectState(CharacterData charData, int index)
	{
		for (int i = 0; i < memberMetas.Length; i++)
		{
			if (memberMetas[i].charData != null && memberMetas[i].charData.charName == charData.charName)
			{
				UpdateMeta(i, memberMetas[index].charData, required: false);
			}
		}
		UpdateMeta(index, charData, required: false);
		if (SelectedAllMembers)
		{
			buttonContinue.Show();
		}
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UIContainer uIContainer = null;
		sideButtonContainer.ShowAll();
		membersContainer.HideAll();
		fullPartyContainer.HideAll();
		memberSelectContainer.HideAll();
		confirmContainer.HideAll();
		buttonBack.OnTapUp -= ButtonBack_Loadout_OnTapUp;
		buttonBack.OnTapUp -= ButtonBack_MemberSelect_OnTapUp;
		buttonBack.OnTapUp += ButtonBack_Loadout_OnTapUp;
		if (numOfMembersInLoadout >= 6)
		{
			fullPartyContainer.ShowAll();
			uIContainer = fullPartyContainer;
			imageBackgroundSmall.Hide();
			imageHeaderSmall.Hide();
			sideButtonContainer.transform.localPosition = sideButtonRightPos;
			buttonContinue.Show();
			for (int i = 0; i < fullPartyMemberMetas.Length; i++)
			{
				LoadoutPersonMeta loadoutPersonMeta = fullPartyMemberMetas[i];
				CharacterData characterData = (loadoutPersonMeta.charData = requiredCharDatas[i]);
				loadoutPersonMeta.imagePortrait.SetImage(characterData.GetLoadoutX6Sprite());
				loadoutPersonMeta.textboxName.SetKey(characterData.DisplayName);
				loadoutPersonMeta.textboxClass.SetKey(characterData.ClassName);
				PartyMember unlockedPartyMember = Party.Inst.GetUnlockedPartyMember(characterData);
				loadoutPersonMeta.textboxLevel.SetKey("UILOADOUT_MEMBERLEVEL", unlockedPartyMember.Level);
				loadoutPersonMeta.container.ShowAll();
			}
		}
		else
		{
			membersContainer.ShowAll();
			if (numOfMembersInLoadout < 3)
			{
				imageBackgroundLarge.Hide();
				imageHeaderLarge.Hide();
				sideButtonContainer.transform.localPosition = sideButtonLeftPos;
			}
			else
			{
				imageBackgroundSmall.Hide();
				imageHeaderSmall.Hide();
				sideButtonContainer.transform.localPosition = sideButtonRightPos;
			}
			if (numOfMembersInLoadout == requiredCharDatas.Length)
			{
				buttonSuggestedChars.Hide();
			}
			else
			{
				buttonSuggestedChars.Show();
			}
			uIContainer = membersContainer;
			for (int j = 0; j < memberMetas.Length; j++)
			{
				memberMetas[j].container.HideAll();
			}
			float num = 0.17f;
			float num2 = 0.4f - (float)(numOfMembersInLoadout - 1) / 2f * num;
			for (int k = 0; k < numOfMembersInLoadout; k++)
			{
				LoadoutPersonMeta loadoutPersonMeta2 = memberMetas[k];
				loadoutPersonMeta2.container.transform.localPosition = loadoutPersonMeta2.container.transform.localPosition.RepX(num2);
				loadoutPersonMeta2.container.ShowAll();
				loadoutPersonMeta2.swapContainer.HideAll();
				loadoutPersonMeta2.swapHighlightContainer.HideAll();
				loadoutPersonMeta2.emptyHighlightContainer.HideAll();
				bool flag = k < requiredCharDatas.Length;
				bool flag2 = loadoutPersonMeta2.charData != null;
				loadoutPersonMeta2.buttonImagePortrait.interactable = !flag && (!flag2 || (flag2 && (!SelectedAllMembers || requiredCharDatas.Length < numOfMembersInLoadout - 1 || Party.Inst.GetUnlockedPartyMembersNum() > numOfMembersInLoadout)));
				if (flag || flag2)
				{
					loadoutPersonMeta2.emptyContainer.HideAll();
					CharacterData characterData2 = (loadoutPersonMeta2.charData = ((!flag) ? loadoutPersonMeta2.charData : requiredCharDatas[k]));
					loadoutPersonMeta2.nameplateContainer.ShowAll();
					if (flag)
					{
						loadoutPersonMeta2.required = true;
						loadoutPersonMeta2.buttonImagePortrait.interactable = !flag;
					}
					else
					{
						loadoutPersonMeta2.lockedContainer.HideAll();
						loadoutPersonMeta2.swapContainer.ShowAll();
					}
					loadoutPersonMeta2.imagePortrait.SetImage(characterData2.GetLoadoutX4Sprite());
					loadoutPersonMeta2.textboxName.SetKey(characterData2.DisplayName);
					PartyMember unlockedPartyMember2 = Party.Inst.GetUnlockedPartyMember(characterData2);
					loadoutPersonMeta2.textboxLevel.SetKey("UILOADOUT_MEMBERLEVEL", unlockedPartyMember2.Level);
					loadoutPersonMeta2.textboxClass.SetKey(characterData2.ClassName);
					loadoutPersonMeta2.textboxClass.Show();
				}
				else
				{
					loadoutPersonMeta2.imagePortrait.Hide();
					loadoutPersonMeta2.nameplateContainer.HideAll();
					loadoutPersonMeta2.lockedContainer.HideAll();
					loadoutPersonMeta2.emptyContainer.ShowAll();
				}
				num2 += num;
			}
			int num3 = Mathf.Min(requiredCharDatas.Length, numOfMembersInLoadout);
			for (int l = 0; l < num3; l++)
			{
				memberMetas[l].required = true;
			}
		}
		if (!SelectedAllMembers)
		{
			buttonContinue.Hide();
		}
		if (SaveData.data.IsMissionComplete("MISSION_A1O1_Cambridge"))
		{
			buttonShop._SetInteractable(interact: true);
			if (!SaveData.data.tutorials.visitedShop)
			{
				uIContainer.SetAlpha(UIElement.kDisabledAlpha);
				uIContainer.SetInteractable(interactable: false);
				textboxContinue.alpha = UIElement.kDisabledAlpha;
				buttonContinue._SetInteractable(interact: false);
				textboxManageTeam.alpha = UIElement.kDisabledAlpha;
				buttonManageTeam._SetInteractable(interact: false);
				textboxShopButton.PulseScaleStart(LR.Host, 0.9f, 1.2f);
				buttonShop.OnFocusEnter -= shopButtonFocusEnterNormal;
				buttonShop.OnFocusExit -= shopButtonFocusExitNormal;
				buttonShop.OnFocusEnter += shopButtonFocusEnterTutorial;
				buttonShop.OnFocusExit += shopButtonFocusExitTutorial;
				buttonShop.OnTapUp += shopButtonTapUp;
				textboxShopButton.alpha = 1f;
				textboxShopButton.PulseRGBStart(LR.Host, ColorX.RGB(207, 227, 112), 0.85f);
				UIAmbientSubtitles.Inst.Show(Tutorials.dialogShop);
				tutorialMode = true;
			}
			else if (tutorialMode)
			{
				uIContainer.SetAlpha(1f);
				uIContainer.SetInteractable(interactable: true);
				textboxContinue.alpha = 1f;
				buttonContinue._SetInteractable(interact: true);
				textboxManageTeam.alpha = 1f;
				buttonManageTeam._SetInteractable(interact: true);
				buttonShop.OnFocusEnter += shopButtonFocusEnterNormal;
				buttonShop.OnFocusExit += shopButtonFocusExitNormal;
				buttonShop.OnFocusEnter -= shopButtonFocusEnterTutorial;
				buttonShop.OnFocusExit -= shopButtonFocusExitTutorial;
				buttonShop.OnTapUp -= shopButtonTapUp;
				textboxShopButton.alpha = 1f;
				textboxShopButton.PulseScaleStop(0.035f);
				textboxShopButton.PulseRGBStop(LR.Host, 0.035f, HACK_textBoxShopColorOriginal);
				tutorialMode = false;
			}
		}
		else
		{
			buttonShop._SetInteractable(interact: false);
			textboxShopButton.alpha = UIElement.kDisabledAlpha;
		}
	}

	public void ShowMemberSelect()
	{
		sideButtonContainer.HideAll();
		memberSelectContainer.ShowAll();
		membersContainer.HideAll();
		for (int i = 0; i < selectableMembers.Length; i++)
		{
			selectableMembers[i] = null;
		}
		ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
		int num = 0;
		for (int j = 0; j < unlockedPartyMembers.Length; j++)
		{
			if (ArrayX.Contains(restrictedCharDatas, unlockedPartyMembers[j].characterData) || (memberMetas[loadoutIndex].charData != null && unlockedPartyMembers[j].characterData.charName == memberMetas[loadoutIndex].charData.charName))
			{
				continue;
			}
			bool flag = false;
			for (int k = 0; k < memberMetas.Length; k++)
			{
				if (memberMetas[k].charData != null && memberMetas[k].required && unlockedPartyMembers[j].characterData.charName == memberMetas[k].charData.charName)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				selectableMembers[num] = unlockedPartyMembers[j].characterData;
				num++;
			}
		}
		for (int l = 0; l < num; l++)
		{
			if (!(selectableMembers[l] != null))
			{
				continue;
			}
			memberSelectMetas[l].container.ShowAll();
			if (l % 3 == 0)
			{
				if (imageBackgroundLarge.IsShown)
				{
					memberSelectMetas[l].container.transform.localPosition = memberSelectMetas[l].container.transform.localPosition.RepX(-0.22f);
				}
				else
				{
					memberSelectMetas[l].container.transform.localPosition = memberSelectMetas[l].container.transform.localPosition.RepX(-0.165f);
				}
			}
			else if (l % 3 == 2)
			{
				if (imageBackgroundLarge.IsShown)
				{
					memberSelectMetas[l].container.transform.localPosition = memberSelectMetas[l].container.transform.localPosition.RepX(0.16f);
				}
				else
				{
					memberSelectMetas[l].container.transform.localPosition = memberSelectMetas[l].container.transform.localPosition.RepX(0.105f);
				}
			}
			memberSelectMetas[l].buttonHighlight.Hide();
			memberSelectMetas[l].charData = selectableMembers[l];
			memberSelectMetas[l].buttonPortrait.image.SetImage(selectableMembers[l].GetIconSprite());
			memberSelectMetas[l].buttonPortrait.userData = selectableMembers[l];
			memberSelectMetas[l].textboxName.SetKey(selectableMembers[l].DisplayName);
			memberSelectMetas[l].textboxLevel.SetKey("UILOADOUT_MEMBERLEVEL", Party.Inst.GetUnlockedPartyMember(selectableMembers[l]).Level);
			memberSelectMetas[l].textboxClass.SetKey(selectableMembers[l].ClassName);
			memberSelectMetas[l].textboxClass.Show();
		}
		for (int m = num; m < memberSelectMetas.Length; m++)
		{
			memberSelectMetas[m].container.HideAll();
		}
	}

	public override bool OnBackButtonPressed()
	{
		if (confirmContainer.IsShown)
		{
			ButtonCancel_OnTapUp();
			return true;
		}
		return base.OnBackButtonPressed();
	}
}
public class UIMainMenu : UIContainer
{
	private UIButton button_showCmdCtr;

	private ParticleSystem tkPs;

	private UIImage imageHighlight;

	private static UIMainMenu _instance;

	public static UIMainMenu Inst => _instance;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_instance = this;
		tkPs = GetComponentInChildren<ParticleSystem>();
		tkPs.Stop();
		button_showCmdCtr = GetElement<UIButton>("commandCenter");
		button_showCmdCtr.OnTapUp += Button_showCmdCtr_OnTapUp;
		button_showCmdCtr.OnFocusEnter += delegate
		{
			tkPs.Play();
		};
		button_showCmdCtr.OnFocusExit += delegate
		{
			tkPs.Stop();
		};
		button_showCmdCtr.crosshairContext = UICrosshairContext.Interaction;
		imageHighlight = GetElement<UIImage>("ButtonHighlight");
	}

	private bool Button_showCmdCtr_OnTapUp()
	{
		Singleton<UIFlow>.Inst.OpenMainMenu();
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		imageHighlight.PulseScaleStart(LR.Host);
	}

	public override bool HideAll()
	{
		imageHighlight.PulseScaleStop();
		return base.HideAll();
	}

	public override bool OnBackButtonPressed()
	{
		OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		return true;
	}
}
public class UIMap_MissionSelect : UIElement
{
	[HideInInspector]
	[Serializer.Exclude]
	public Material[] hologramMaterials;

	private int holoShaderColorID;

	private int holoShaderMapXFormID;

	private int holoShaderL2WMapXFormID;

	private int holoShaderCursorPosRadiID;

	private int holoShaderFrameOffsetID;

	private int holoShaderFrameExtents_ScaleID;

	private int holoShaderCursorFadeTime;

	public Vector2 hologramFrameOffsetX = default(Vector2);

	public Vector2 hologramFrameOffsetY = default(Vector2);

	public Vector2 hologramFrameOffsetZ = default(Vector2);

	private Bounds hologramFrameBounds = default(Bounds);

	[HideInInspector]
	private Color hologramColor = new Color(0.23529412f, 48f / 85f, 0.9490196f, 1f);

	public Color HologamColor
	{
		get
		{
			return hologramColor;
		}
		set
		{
			hologramColor = value;
			Material[] array = hologramMaterials;
			foreach (Material material in array)
			{
				material.SetColor(holoShaderColorID, hologramColor);
			}
		}
	}

	public void Initialise()
	{
		holoShaderColorID = Shader.PropertyToID("_ColorHolo");
		holoShaderMapXFormID = Shader.PropertyToID("_MapWorldToLocal");
		holoShaderL2WMapXFormID = Shader.PropertyToID("_MapLocalToWorld");
		holoShaderFrameOffsetID = Shader.PropertyToID("_HoloFrameOffset");
		holoShaderFrameExtents_ScaleID = Shader.PropertyToID("_HoloFrameExtents_Scale");
		holoShaderCursorPosRadiID = Shader.PropertyToID("_CursorOriginAndRadius");
		holoShaderCursorFadeTime = Shader.PropertyToID("_CursorFadeTime");
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		hologramMaterials = new Material[componentsInChildren.Length];
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			hologramMaterials[i] = new Material(componentsInChildren[i].sharedMaterial);
			componentsInChildren[i].sharedMaterial = hologramMaterials[i];
		}
	}

	private Bounds GetHoloFrameBounds(float holoFrameWidthScale, float holoFrameHeightOffset)
	{
		Bounds result = hologramFrameBounds;
		result.min += new Vector3(0f - hologramFrameOffsetX.x, 0f - hologramFrameOffsetY.y, 0f - hologramFrameOffsetZ.x);
		result.max -= new Vector3(0f - hologramFrameOffsetX.y, 0f - hologramFrameOffsetY.x, 0f - hologramFrameOffsetZ.y);
		result.extents = result.extents.RepX(result.extents.x * holoFrameWidthScale);
		result.max = result.max.RepY(result.max.y + holoFrameHeightOffset);
		return result;
	}

	private void UpdateMapHologramMaterial(Material targetMaterial, Matrix4x4 xformMapWorldToLocal, Matrix4x4 xformMapLocalToWorld, float hologramValue, float holoFrameWidth, float holoFrameHeight, float holoFrameFadeScale)
	{
		targetMaterial.SetColor(holoShaderColorID, hologramColor);
		targetMaterial.SetMatrix(holoShaderMapXFormID, xformMapWorldToLocal);
		targetMaterial.SetMatrix(holoShaderL2WMapXFormID, xformMapLocalToWorld);
		Bounds holoFrameBounds = GetHoloFrameBounds(holoFrameWidth, holoFrameHeight);
		targetMaterial.SetVector(holoShaderFrameOffsetID, holoFrameBounds.center.V3ToV4(holoFrameFadeScale));
		targetMaterial.SetVector(holoShaderFrameExtents_ScaleID, holoFrameBounds.extents.V3ToV4(holoFrameFadeScale));
	}

	public void UpdateMapHologramMaterials(Matrix4x4 mapPivotMatrix, float hologramValue, float holoFrameWidth, float holoFrameHeight, float holoFrameFadeScale)
	{
		hologramColor.a = hologramValue;
		Matrix4x4 xformMapWorldToLocal = mapPivotMatrix;
		Matrix4x4 inverse = xformMapWorldToLocal.inverse;
		Material[] array = hologramMaterials;
		foreach (Material targetMaterial in array)
		{
			UpdateMapHologramMaterial(targetMaterial, xformMapWorldToLocal, inverse, hologramValue, holoFrameWidth, holoFrameHeight, holoFrameFadeScale);
		}
	}
}
public class UIMissionBriefing : UIContainer
{
	private MissionSceneMeta missionMeta;

	private UITextbox uiText_Title;

	private UITextbox uiText_Intel;

	private UITextbox uiText_Objectives;

	private UIButton button_Start;

	private UIButton button_Cancel;

	private UIContainer container_main;

	private UIContainer container_mainContent;

	private UIContainer container_L;

	private UIImage imageMission;

	public AnimationCurve curveButtonPos;

	public AnimationCurve curvePosMainContainer;

	public AnimationCurve curvePosSideContainers;

	public AnimationCurve curveAlphaSideContainers;

	public AnimationCurve curveAlphaMainContainer;

	public AnimationCurve curveAlphaMainContentContainer;

	public Color buttonSelected;

	private float animTarget;

	private float animValue;

	private float animTargetPrev;

	private Vector3 panelLLocalPos;

	private Vector3 panelRLocalPos;

	private Vector3 panelMainLocalPos;

	private HagletResettable showHideRoutine;

	public override void OnAwakeLR()
	{
		container_main = GetContainer("MainPanel");
		container_mainContent = container_main.GetContainer("Content");
		container_L = GetContainer("MissionImagePanel");
		panelLLocalPos = container_L.transform.localPosition;
		panelMainLocalPos = container_main.transform.localPosition;
		UITextbox textStart = container_main.GetElement<UITextbox>("TextStart");
		Color colorOrig2 = textStart.color;
		button_Start = container_main.GetElement<UIButton>("ButtonStartMission");
		button_Start.OnTapUp += delegate
		{
			Singleton<UIFlow>.Inst.StartMissionBriefToMissionLoadout(missionMeta);
			return true;
		};
		button_Start.OnFocusEnter += delegate
		{
			textStart.color = buttonSelected;
		};
		button_Start.OnFocusExit += delegate
		{
			textStart.color = colorOrig2;
		};
		UITextbox textCancel = container_main.GetElement<UITextbox>("TextCancel");
		Color colorOrig = textCancel.color;
		button_Cancel = container_main.GetElement<UIButton>("ButtonCancel");
		button_Cancel.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		button_Cancel.OnFocusEnter += delegate
		{
			textCancel.color = buttonSelected;
		};
		button_Cancel.OnFocusExit += delegate
		{
			textCancel.color = colorOrig;
		};
		uiText_Title = container_main.GetElement<UITextbox>("LabelMission");
		uiText_Intel = container_mainContent.GetElement<UITextbox>("LabelIntel");
		uiText_Objectives = container_mainContent.GetElement<UITextbox>("LabelObjectives");
		imageMission = container_L.GetElement<UIImage>("MissionImage");
		showHideRoutine = new HagletResettable(ShowHideRoutine(), "Mission Briefing Show/Hide", HagletStepTime.Update, -1, 4);
	}

	private IEnumerator<HagletYieldTerm> ShowHideRoutine()
	{
		float anim = 0f;
		while (anim < 0.75f)
		{
			anim += Time.deltaTime;
			animValue = Mathf.Lerp(animTargetPrev, animTarget, Mathf.Clamp01(anim / 0.75f));
			EvaluateAnimation(animValue);
			yield return Wait.ForSteps(1uL);
		}
		if (animTarget == 0f)
		{
			base.HideAll();
		}
	}

	private void EvaluateAnimation(float x)
	{
		button_Start.transform.SetLocalPosY(curveButtonPos.Evaluate(x));
		button_Cancel.transform.SetLocalPosY(curveButtonPos.Evaluate(x));
		container_L.transform.localPosition = panelLLocalPos + Vector3.left * curvePosSideContainers.Evaluate(x);
		container_main.transform.localPosition = panelMainLocalPos + Vector3.up * curvePosMainContainer.Evaluate(x);
		container_L.SetAlpha(curveAlphaSideContainers.Evaluate(x));
		container_main.SetAlpha(curveAlphaMainContainer.Evaluate(x));
		container_mainContent.SetAlpha(curveAlphaMainContentContainer.Evaluate(x));
	}

	public override void ShowAll()
	{
		base.ShowAll();
		uiText_Title.SetKey(missionMeta.missionTitle);
		uiText_Intel.SetKey(missionMeta.missionDescription);
		uiText_Objectives.SetKey(missionMeta.missionObjectives);
		CharacterData characterData = missionMeta.missionRequiredCharacters[0];
		imageMission.SetImage(missionMeta.missionBriefImage);
		animTargetPrev = animValue;
		animTarget = 1f;
		Routine.Start(showHideRoutine);
	}

	public override bool HideAll()
	{
		if (HagletHost.currHag == null)
		{
			base.HideAll();
		}
		else
		{
			animTargetPrev = animValue;
			animTarget = 0f;
			Routine.Start(showHideRoutine);
		}
		return true;
	}

	public void SetState(MissionSceneMeta meta)
	{
		missionMeta = meta;
	}
}
public class UIMissionEnd : UIContainer
{
	public class MissionEndMemberMeta
	{
		public UIContainer container;

		public UITextbox textboxName;

		public UITextbox textboxLevel;

		public UITextbox textboxMissionsLeft;

		public UITextbox textboxRequiredMissions;

		public UIImage imagePortrait;

		public UIImage imageXPPip1;

		public UIImage imageXPPip2;

		public UIImage imageXPPip3;

		public UITextbox textboxLevelUp;

		public UIImage imageLevelUpFrame;

		public UIImage imageLevelUpFrameGlow;

		public UIImage imageLevelUpGradient;
	}

	[NonSerialized]
	public HagletTrigger OnContinue = new HagletTrigger();

	private const int maxPartySizeForUI = 6;

	private readonly Vector3 singleXPPosition = new Vector3(0.03f, -0.034f, 0f);

	private readonly Vector3 singleXPScale = new Vector3(3.09f, 1f, 1f);

	private readonly Vector3 twoXPPosition1 = new Vector3(-0.011f, -0.034f, 0f);

	private readonly Vector3 twoXPPosition2 = new Vector3(0.071f, -0.034f, 0f);

	private readonly Vector3 twoXPScale = new Vector3(1.52f, 1f, 1f);

	private readonly Vector3 threeXPPosition1 = new Vector3(-0.025f, -0.034f, 0f);

	private readonly Vector3 threeXPPosition2 = new Vector3(0.03f, -0.034f, 0f);

	private readonly Vector3 threeXPPosition3 = new Vector3(0.085f, -0.034f, 0f);

	private readonly Vector3 threeXPScale = Vector3.one;

	private UIContainer containerFullTeam;

	private UIContainer containerSmallTeam;

	private UITextbox textboxMissionNameFull;

	private UITextbox textboxMissionNameSmall;

	private MissionEndMemberMeta[] memberMetasFullParty = new MissionEndMemberMeta[6];

	private MissionEndMemberMeta[] memberMetasSmallParty = new MissionEndMemberMeta[3];

	private UIButton buttonContinueFull;

	private UIButton buttonContinueSmall;

	public Color buttonSelected;

	[ReadOnly]
	public UnitTeam.Type activeTeam;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		string[] array = new string[6] { "CharacterA", "CharacterB", "CharacterC", "CharacterD", "CharacterE", "CharacterF" };
		containerFullTeam = GetContainer("FullTeam");
		textboxMissionNameFull = containerFullTeam.GetElement<UITextbox>("MissionName");
		UIContainer container = containerFullTeam.GetContainer("PartyMembers");
		for (int i = 0; i < memberMetasFullParty.Length; i++)
		{
			MissionEndMemberMeta missionEndMemberMeta = (memberMetasFullParty[i] = new MissionEndMemberMeta());
			UIContainer uIContainer = (missionEndMemberMeta.container = container.GetContainer(array[i]));
			missionEndMemberMeta.imagePortrait = uIContainer.GetElement<UIImage>("Portrait");
			missionEndMemberMeta.imageLevelUpFrame = uIContainer.GetElement<UIImage>("LevelUpFrame");
			missionEndMemberMeta.imageLevelUpFrameGlow = uIContainer.GetElement<UIImage>("LevelUpFrameGlow");
			missionEndMemberMeta.textboxName = uIContainer.GetElement<UITextbox>("Name");
			missionEndMemberMeta.textboxLevel = uIContainer.GetElement<UITextbox>("Level");
			missionEndMemberMeta.imageXPPip1 = uIContainer.GetElement<UIImage>("XP_Pip1");
			missionEndMemberMeta.imageXPPip2 = uIContainer.GetElement<UIImage>("XP_Pip2");
			missionEndMemberMeta.imageXPPip3 = uIContainer.GetElement<UIImage>("XP_Pip3");
			missionEndMemberMeta.textboxMissionsLeft = uIContainer.GetElement<UITextbox>("MissionLeftTo");
			missionEndMemberMeta.textboxRequiredMissions = uIContainer.GetElement<UITextbox>("RequiredMissions");
			missionEndMemberMeta.imageLevelUpGradient = uIContainer.GetElement<UIImage>("LevelUpGradient");
			missionEndMemberMeta.textboxLevelUp = uIContainer.GetElement<UITextbox>("LevelUp");
		}
		containerSmallTeam = GetContainer("SmallTeam");
		textboxMissionNameSmall = containerSmallTeam.GetElement<UITextbox>("MissionName");
		UIContainer container2 = containerSmallTeam.GetContainer("PartyMembers");
		for (int j = 0; j < memberMetasSmallParty.Length; j++)
		{
			MissionEndMemberMeta missionEndMemberMeta2 = (memberMetasSmallParty[j] = new MissionEndMemberMeta());
			UIContainer uIContainer2 = (missionEndMemberMeta2.container = container2.GetContainer(array[j]));
			missionEndMemberMeta2.imagePortrait = uIContainer2.GetElement<UIImage>("Portrait");
			missionEndMemberMeta2.imageLevelUpFrame = uIContainer2.GetElement<UIImage>("LevelUpFrame");
			missionEndMemberMeta2.imageLevelUpFrameGlow = uIContainer2.GetElement<UIImage>("LevelUpFrameGlow");
			missionEndMemberMeta2.textboxName = uIContainer2.GetElement<UITextbox>("Name");
			missionEndMemberMeta2.textboxLevel = uIContainer2.GetElement<UITextbox>("Level");
			missionEndMemberMeta2.imageXPPip1 = uIContainer2.GetElement<UIImage>("XP_Pip1");
			missionEndMemberMeta2.imageXPPip2 = uIContainer2.GetElement<UIImage>("XP_Pip2");
			missionEndMemberMeta2.imageXPPip3 = uIContainer2.GetElement<UIImage>("XP_Pip3");
			missionEndMemberMeta2.textboxMissionsLeft = uIContainer2.GetElement<UITextbox>("MissionLeftTo");
			missionEndMemberMeta2.textboxRequiredMissions = uIContainer2.GetElement<UITextbox>("RequiredMissions");
			missionEndMemberMeta2.imageLevelUpGradient = uIContainer2.GetElement<UIImage>("LevelUpGradient");
			missionEndMemberMeta2.textboxLevelUp = uIContainer2.GetElement<UITextbox>("LevelUp");
		}
		buttonContinueFull = containerFullTeam.GetElement<UIButton>("ContinueButton");
		UITextbox continueFullText = containerFullTeam.GetElement<UITextbox>("ContinueText");
		Color origFullTextColor = continueFullText.color;
		buttonContinueFull.OnTapUp += ButtonContinue_OnTapUp;
		buttonContinueFull.OnFocusEnter += delegate
		{
			continueFullText.color = buttonSelected;
		};
		buttonContinueFull.OnFocusExit += delegate
		{
			continueFullText.color = origFullTextColor;
		};
		buttonContinueSmall = containerSmallTeam.GetElement<UIButton>("ContinueButton");
		UITextbox continueSmallText = containerSmallTeam.GetElement<UITextbox>("ContinueText");
		Color origSmallTextColor = continueSmallText.color;
		buttonContinueSmall.OnTapUp += ButtonContinue_OnTapUp;
		buttonContinueSmall.OnFocusEnter += delegate
		{
			continueSmallText.color = buttonSelected;
		};
		buttonContinueSmall.OnFocusExit += delegate
		{
			continueSmallText.color = origSmallTextColor;
		};
	}

	public bool ButtonContinue_OnTapUp()
	{
		HideAll();
		OnContinue.Trigger();
		return true;
	}

	private void ShowPartyDetails(ConstArray<PartyMember> partyMembers)
	{
		bool flag = partyMembers.Length > 3;
		if (flag)
		{
			containerSmallTeam.HideAll();
			containerFullTeam.ShowAll();
		}
		else
		{
			containerSmallTeam.ShowAll();
			containerFullTeam.HideAll();
		}
		MissionEndMemberMeta[] array = ((!flag) ? memberMetasSmallParty : memberMetasFullParty);
		for (int i = 0; i < partyMembers.Length; i++)
		{
			MissionEndMemberMeta missionEndMemberMeta = array[i];
			PartyMember partyMember = partyMembers[i];
			missionEndMemberMeta.container.ShowAll();
			missionEndMemberMeta.textboxName.SetKey(partyMember.characterData.DisplayName);
			missionEndMemberMeta.textboxLevel.SetKey("UIMISSIONEND_LEVEL", partyMember.Level);
			missionEndMemberMeta.imagePortrait.SetImage(partyMember.characterData.GetIconSprite());
			int missionsBetweenLevels;
			if (partyMember.JustLeveledUp)
			{
				missionEndMemberMeta.textboxMissionsLeft.Hide();
				missionEndMemberMeta.textboxRequiredMissions.Hide();
				missionsBetweenLevels = partyMember.GetMissionsBetweenLevels(partyMember.Level - 1, partyMember.Level);
			}
			else
			{
				missionEndMemberMeta.imageLevelUpFrame.Hide();
				missionEndMemberMeta.imageLevelUpFrameGlow.Hide();
				missionEndMemberMeta.imageLevelUpGradient.Hide();
				missionEndMemberMeta.textboxLevelUp.Hide();
				int remainingMissionsNeededToLevelUp = partyMember.GetRemainingMissionsNeededToLevelUp();
				missionEndMemberMeta.textboxRequiredMissions.SetNumber(remainingMissionsNeededToLevelUp);
				missionsBetweenLevels = partyMember.GetMissionsBetweenLevels(partyMember.Level, partyMember.Level + 1);
				switch (missionsBetweenLevels)
				{
				case 1:
					if (remainingMissionsNeededToLevelUp == 1)
					{
						missionEndMemberMeta.imageXPPip1.Hide();
					}
					break;
				case 2:
					if (remainingMissionsNeededToLevelUp > 0)
					{
						missionEndMemberMeta.imageXPPip2.Hide();
						if (remainingMissionsNeededToLevelUp > 1)
						{
							missionEndMemberMeta.imageXPPip1.Hide();
						}
					}
					break;
				case 3:
					if (remainingMissionsNeededToLevelUp <= 0)
					{
						break;
					}
					missionEndMemberMeta.imageXPPip3.Hide();
					if (remainingMissionsNeededToLevelUp > 1)
					{
						missionEndMemberMeta.imageXPPip2.Hide();
						if (remainingMissionsNeededToLevelUp > 2)
						{
							missionEndMemberMeta.imageXPPip1.Hide();
						}
					}
					break;
				}
			}
			switch (missionsBetweenLevels)
			{
			case 1:
				missionEndMemberMeta.imageXPPip2.Hide();
				missionEndMemberMeta.imageXPPip3.Hide();
				missionEndMemberMeta.imageXPPip1.transform.localPosition = singleXPPosition;
				missionEndMemberMeta.imageXPPip1.transform.localScale = singleXPScale;
				break;
			case 2:
				missionEndMemberMeta.imageXPPip3.Hide();
				missionEndMemberMeta.imageXPPip1.transform.localPosition = twoXPPosition1;
				missionEndMemberMeta.imageXPPip1.transform.localScale = twoXPScale;
				missionEndMemberMeta.imageXPPip2.transform.localPosition = twoXPPosition2;
				missionEndMemberMeta.imageXPPip2.transform.localScale = twoXPScale;
				break;
			case 3:
				missionEndMemberMeta.imageXPPip1.transform.localPosition = threeXPPosition1;
				missionEndMemberMeta.imageXPPip1.transform.localScale = threeXPScale;
				missionEndMemberMeta.imageXPPip2.transform.localPosition = threeXPPosition2;
				missionEndMemberMeta.imageXPPip2.transform.localScale = threeXPScale;
				missionEndMemberMeta.imageXPPip3.transform.localPosition = threeXPPosition3;
				missionEndMemberMeta.imageXPPip3.transform.localScale = threeXPScale;
				break;
			default:
				missionEndMemberMeta.imageXPPip1.Hide();
				missionEndMemberMeta.imageXPPip2.Hide();
				missionEndMemberMeta.imageXPPip3.Hide();
				break;
			}
		}
		for (int j = (int)partyMembers.Length; j < array.Length; j++)
		{
			MissionEndMemberMeta missionEndMemberMeta2 = array[j];
			missionEndMemberMeta2.container.HideAll();
		}
	}

	public override void ShowAll()
	{
		base.ShowAll();
		string missionTitle = SaveData.data.chosenMission.missionTitle;
		textboxMissionNameFull.SetKey(missionTitle);
		textboxMissionNameSmall.SetKey(missionTitle);
		ShowPartyDetails(Party.Inst.GetContributedPartyMembers());
	}

	public override bool OnBackButtonPressed()
	{
		return ButtonContinue_OnTapUp();
	}
}
public class UIMissionFailed : UIContainer
{
	private static UIMissionFailed _instance;

	private UIButton retryButton;

	private UIButton restartButton;

	private UIButton exitToMainButton;

	private UIButton yesRestartMissionButton;

	private UIButton noRestartMissionButton;

	private UIButton yesExitToMainButton;

	private UIButton noExitToMainButton;

	private UIContainer restartMissionConfirmDialog;

	private UIContainer exitMissionConfirmDialog;

	public static UIMissionFailed Inst => _instance;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_instance = this;
		retryButton = GetElement<UIButton>("CheckpointRestart");
		retryButton.OnTapUp += delegate
		{
			Singleton<UIFlow>.Inst.RestartCheckpoint();
			Singleton<UIC>.Inst.ClearImmediate();
			Singleton<UIC>.Inst.Push<UIMainMenu>();
			return true;
		};
		restartButton = GetElement<UIButton>("MissionRestart");
		restartButton.OnTapUp += delegate
		{
			restartMissionConfirmDialog.ShowAll();
			return true;
		};
		exitToMainButton = GetElement<UIButton>("ExitMission");
		exitToMainButton.OnTapUp += delegate
		{
			exitMissionConfirmDialog.ShowAll();
			return true;
		};
		restartMissionConfirmDialog = GetContainer("RestartMissionConfirmDialog");
		yesRestartMissionButton = restartMissionConfirmDialog.GetElement<UIButton>("YesRestartMission");
		yesRestartMissionButton.OnTapUp += ButtonYesMissionRestart_OnTapUp;
		noRestartMissionButton = restartMissionConfirmDialog.GetElement<UIButton>("NoRestartMission");
		noRestartMissionButton.OnTapUp += delegate
		{
			restartMissionConfirmDialog.HideAll();
			return true;
		};
		exitMissionConfirmDialog = GetContainer("ExitMissionConfirmDialog");
		yesExitToMainButton = exitMissionConfirmDialog.GetElement<UIButton>("YesExitMission");
		yesExitToMainButton.OnTapUp += ButtonYesExitMission_OnTapUp;
		noExitToMainButton = exitMissionConfirmDialog.GetElement<UIButton>("NoExitMission");
		noExitToMainButton.OnTapUp += delegate
		{
			exitMissionConfirmDialog.HideAll();
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		exitMissionConfirmDialog.HideAll();
		restartMissionConfirmDialog.HideAll();
		AC.Inst.PlayOneShot2D("event:/sfx/ui/game over");
	}

	private bool ButtonYesExitMission_OnTapUp()
	{
		Singleton<UIFlow>.Inst.StartMissionToMainMenu();
		Singleton<UIC>.Inst.ClearImmediate();
		Singleton<UIC>.Inst.Push<UIMainMenu>();
		return true;
	}

	private bool ButtonYesMissionRestart_OnTapUp()
	{
		Singleton<UIFlow>.Inst.RestartMission();
		Singleton<UIC>.Inst.ClearImmediate();
		Singleton<UIC>.Inst.Push<UIMainMenu>();
		return true;
	}

	public override bool OnBackButtonPressed()
	{
		OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		return true;
	}
}
public class UIMissionMap : UIContainer
{
	private UIButton buttonStartMission;

	private UIMissionBriefing uiMissionBrief;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		buttonStartMission = GetElement<UIButton>("StartMission");
		buttonStartMission.OnTapUp += OnStartMission;
		uiMissionBrief = LR.Get<UIMissionBriefing>();
	}

	private bool OnStartMission()
	{
		HideAll();
		uiMissionBrief.ShowAll();
		return true;
	}
}
public class UIMissionSelect : UIContainer
{
	private struct UIMissionGroup
	{
		public UIContainer missionGroup;

		public UIMission[] uiMissions;

		public string[] missionNames;

		public void ShowAll()
		{
			for (int i = 0; i < uiMissions.Length; i++)
			{
				uiMissions[i].PrepareToShow();
			}
			missionGroup.ShowAll();
		}
	}

	private struct UIMission
	{
		public UIButton button;

		public UIContainer selected;

		public UIContainer unselected;

		public UITextbox text;

		public UIImage imgSelectedBaseSmall;

		public UIImage imgUnselectedBaseSmall;

		public UIImage imgGlowSmall;

		public UIImage imgSelectedBaseLarge;

		public UIImage imgUnselectedBaseLarge;

		public UIImage imgGlowLarge;

		private Vector3 originalTextSize;

		public UIImagePulse imgGlowSmallPulse;

		public UIImagePulse imgGlowLargePulse;

		public UIMission(UIContainer missionContainer)
		{
			button = missionContainer.GetElement<UIButton>(missionContainer.name);
			selected = missionContainer.GetContainer("Selected");
			unselected = missionContainer.GetContainer("Unselected");
			text = missionContainer.GetElement<UITextbox>("MissionText");
			imgSelectedBaseSmall = selected.GetElement<UIImage>("BaseSelectedSmall");
			imgUnselectedBaseSmall = unselected.GetElement<UIImage>("BaseUnselectedSmall");
			imgGlowSmall = unselected.GetElement<UIImage>("GlowSmall");
			imgGlowSmallPulse = imgGlowSmall.GetComponent<UIImagePulse>();
			imgSelectedBaseLarge = selected.GetElement<UIImage>("BaseSelectedLarge");
			imgUnselectedBaseLarge = unselected.GetElement<UIImage>("BaseUnselectedLarge");
			imgGlowLarge = unselected.GetElement<UIImage>("GlowLarge");
			imgGlowLargePulse = imgGlowLarge.GetComponent<UIImagePulse>();
			originalTextSize = text.transform.localScale;
		}

		public void PrepareToShow()
		{
			bool flag = text.TextVisible.Length > 12;
			bool flag2 = text.TextVisible.Length > 25;
			if (Localisation.Instance.CurrentLanguage == Localisation.Language.KOREAN || Localisation.Instance.CurrentLanguage == Localisation.Language.CHINESE)
			{
				flag = text.TextVisible.Length >= 6;
				flag2 = text.TextVisible.Length >= 16;
			}
			imgSelectedBaseSmall.spriteRenderer.enabled = !flag;
			imgUnselectedBaseSmall.spriteRenderer.enabled = !flag;
			imgGlowSmall.spriteRenderer.enabled = !flag;
			imgSelectedBaseLarge.spriteRenderer.enabled = flag;
			imgUnselectedBaseLarge.spriteRenderer.enabled = flag;
			imgGlowLarge.spriteRenderer.enabled = flag;
			text.transform.localScale = originalTextSize * ((!flag2) ? 1f : 0.8f);
		}
	}

	private bool playHideSound;

	private const float kFadeTime = 1f;

	public AnimationCurve wireframeAlphaCurve;

	private UIMap_MissionSelect mapActive;

	private UIMissionGroup[] ui_MissionGroups = new UIMissionGroup[SaveData.GetMissionGroupNum()];

	private UIContainer containerSideMenu;

	private UIButton button_teamOrContinue;

	private UIButton button_options;

	private UIButton button_credits;

	private UIButton button_back;

	private UIButton button_quitGame;

	private UIButton button_debug;

	private UIButton button_confirmation_yes;

	private UIButton button_confirmation_no;

	private UIElement[] sideMenuButtons;

	private UIContainer container_confirmation;

	private UIDebugHighlight[] uiHighlights;

	private int currentGroupIndex = -1;

	private HagletResettable showAllRoutine;

	private HagletResettable hideAllRoutine;

	private HagletResettable returnToMenuRoutine;

	private UIContainer containerEndGame;

	private UIButton buttonRestartFinalMission;

	private UIButton buttonDeleteSaveGame;

	private UIButton buttonEndGameConfirm;

	private UIButton buttonEndGameCancel;

	private UITextbox textboxEndGameAreYouSure;

	public AnimFloat animDriver = new AnimFloat(0f);

	[Range(0f, 1f)]
	public float test;

	private bool IsTransitioning => (bool)showAllRoutine.running || (bool)hideAllRoutine.running || (bool)returnToMenuRoutine.running;

	public override void ShowAll()
	{
		Routine.Start(showAllRoutine, LR.Host);
	}

	public void HideAllImmediate()
	{
		base.HideAll();
	}

	public override bool HideAll()
	{
		Routine.Start(hideAllRoutine, LR.Host);
		return true;
	}

	public override bool OnBackButtonPressed()
	{
		ReturnToMenu();
		return true;
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		uiHighlights = GetComponentsInChildren<UIDebugHighlight>(includeInactive: true);
		showAllRoutine = new HagletResettable(ShowAllRoutine(), "UIMissionSelect Show");
		hideAllRoutine = new HagletResettable(HideAllRoutine(), "UIMissionSelect Hide");
		returnToMenuRoutine = new HagletResettable(ReturnToMenuRoutine(), "UIMissionSelect Return To Menu");
		container_confirmation = GetContainer("ConfirmationDialog");
		button_confirmation_yes = container_confirmation.GetElement<UIButton>("confirm");
		button_confirmation_yes.OnTapUpWithUserData += Button_confirmation_yes_OnTapUpWithUserData;
		button_confirmation_no = container_confirmation.GetElement<UIButton>("cancel");
		button_confirmation_no.OnTapUp += Button_confirmation_no_OnTapUp;
		Func<object, bool> value = delegate(object buttonIdx)
		{
			if (IsTransitioning)
			{
				return false;
			}
			int num3 = (int)buttonIdx;
			MissionSceneMeta missionMetaByName = SaveData.GetMissionMetaByName(ui_MissionGroups[currentGroupIndex].missionNames[num3]);
			if (SaveData.gotSavedMission)
			{
				container_confirmation.ShowAll();
				button_confirmation_yes.userData = missionMetaByName;
			}
			else
			{
				Singleton<UIFlow>.Inst.StartMissionSelectToMissionBrief(missionMetaByName);
			}
			return true;
		};
		Action<object> value2 = delegate(object buttonIdx)
		{
			if (!IsTransitioning)
			{
				int num2 = (int)buttonIdx;
				ui_MissionGroups[currentGroupIndex].uiMissions[num2].selected.ShowAll();
				ui_MissionGroups[currentGroupIndex].uiMissions[num2].unselected.HideAll();
				ui_MissionGroups[currentGroupIndex].uiMissions[num2].imgGlowSmallPulse.StopImagePulse();
				ui_MissionGroups[currentGroupIndex].uiMissions[num2].imgGlowLargePulse.StopImagePulse();
			}
		};
		Action<object> value3 = delegate(object buttonIdx)
		{
			if (!IsTransitioning)
			{
				int num = (int)buttonIdx;
				ui_MissionGroups[currentGroupIndex].uiMissions[num].unselected.ShowAll();
				ui_MissionGroups[currentGroupIndex].uiMissions[num].imgGlowSmallPulse.StartImagePulse();
				ui_MissionGroups[currentGroupIndex].uiMissions[num].imgGlowLargePulse.StartImagePulse();
				ui_MissionGroups[currentGroupIndex].uiMissions[num].selected.HideAll();
			}
		};
		for (int i = 0; i < SaveData.GetMissionGroupNum(); i++)
		{
			SaveData.MissionGroup missionGroupsAtIdx = SaveData.GetMissionGroupsAtIdx(i);
			ui_MissionGroups[i].missionGroup = GetContainer(missionGroupsAtIdx.groupID);
			ui_MissionGroups[i].uiMissions = new UIMission[missionGroupsAtIdx.size];
			ui_MissionGroups[i].missionNames = new string[missionGroupsAtIdx.size];
			for (int j = 0; j < missionGroupsAtIdx.size; j++)
			{
				UIContainer container = ui_MissionGroups[i].missionGroup.GetContainer(missionGroupsAtIdx.missionNames[j]);
				UIButton element = container.GetElement<UIButton>(missionGroupsAtIdx.missionNames[j]);
				if ((bool)element)
				{
					element.OnFocusEnterWithUserData += value2;
					element.OnFocusExitWithUserData += value3;
					element.OnTapUpWithUserData += value;
					element.userData = j;
				}
				ui_MissionGroups[i].missionNames[j] = missionGroupsAtIdx.missionNames[j];
				ref UIMission reference = ref ui_MissionGroups[i].uiMissions[j];
				reference = new UIMission(container);
			}
		}
		mapActive = GetComponentInChildren<UIMap_MissionSelect>();
		mapActive.Initialise();
		containerSideMenu = GetContainer("SideMenu");
		button_teamOrContinue = containerSideMenu.GetElement<UIButton>("teamContinue");
		button_options = containerSideMenu.GetElement<UIButton>("options");
		button_credits = containerSideMenu.GetElement<UIButton>("credits");
		button_back = containerSideMenu.GetElement<UIButton>("back");
		button_quitGame = containerSideMenu.GetElement<UIButton>("quitGame");
		button_debug = containerSideMenu.GetElement<UIButton>("debugMenu");
		sideMenuButtons = containerSideMenu.GetComponentsInChildren<UIButton>();
		button_debug.transform.parent.gameObject.SetActive(value: false);
		button_teamOrContinue.OnTapUp += Button_teamOrContinue_OnTapUp;
		button_options.OnTapUp += Button_options_OnTapUp;
		button_credits.OnTapUp += Button_credits_OnTapUp;
		button_back.OnTapUp += Button_back_OnTapUp;
		button_quitGame.OnTapUp += Button_quitGame_OnTapUp;
		containerEndGame = GetContainer("EndGameDialog");
		buttonRestartFinalMission = containerEndGame.GetElement<UIButton>("RestartFinalMission");
		buttonRestartFinalMission.OnTapUp += delegate
		{
			SaveData.data.ResetLastMissionToIncomplete();
			ShowAll();
			return true;
		};
		buttonDeleteSaveGame = containerEndGame.GetElement<UIButton>("DeleteSaveGame");
		buttonDeleteSaveGame.OnTapUp += delegate
		{
			SaveData.ClearDataAndRestart();
			return true;
		};
		textboxEndGameAreYouSure = containerEndGame.GetElement<UITextbox>("AreYouSure");
		buttonEndGameConfirm = containerEndGame.GetElement<UIButton>("Yes");
		buttonEndGameCancel = containerEndGame.GetElement<UIButton>("No");
		RC.Inst.SetWireframAlpha(0f);
		HideAllImmediate();
	}

	private bool Button_confirmation_yes_OnTapUpWithUserData(object arg1)
	{
		if (IsTransitioning)
		{
			return false;
		}
		SaveData.ClearMission();
		MissionSceneMeta missionMeta = (MissionSceneMeta)arg1;
		Singleton<UIFlow>.Inst.StartMissionSelectToMissionBrief(missionMeta);
		button_confirmation_yes.userData = null;
		container_confirmation.HideAll();
		return true;
	}

	private bool Button_confirmation_no_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		button_confirmation_yes.userData = null;
		container_confirmation.HideAll();
		return true;
	}

	private bool Button_teamOrContinue_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		if (SaveData.data.chosenMission != null)
		{
			Singleton<UIFlow>.Inst.StartMainMenuOrMissionToLastCheckPoint();
		}
		else if (Party.Inst.GetUnlockedPartyMembersNum() > 0)
		{
			ConstArray<PartyMember> unlockedPartyMembers = Party.Inst.GetUnlockedPartyMembers();
			ConstArray<PartyMember> constArray = new ConstArray<PartyMember>(Party.Inst.GetUnlockedPartyMembers().Length);
			for (int i = 0; i < unlockedPartyMembers.Length; i++)
			{
				if (unlockedPartyMembers[i].characterData.partyMemberID != PartyMemberID.Ashley || !SaveData.data.IsMissionComplete("MISSION_A1S1_Inversion"))
				{
					constArray.Add(unlockedPartyMembers[i]);
				}
			}
			Singleton<UIC>.Inst.Push<UICharacterDetails>().SetStateForFullPartyEdit(constArray);
		}
		else
		{
			Singleton<UIFlow>.Inst.StartMissionBriefToMissionLoadout(AEResources.LoadFirstResource<MissionSceneMeta>("SceneMetas/MISSION_A1S1_Inversion"));
		}
		return true;
	}

	private bool Button_options_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		Singleton<UIC>.Inst.Push<UIOptionsMenu>().SetStateForOptionsMenu(fromPauseMenu: false);
		return true;
	}

	private bool Button_credits_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		UICredits.Inst.autoPlayMusic = true;
		Singleton<UIC>.Inst.Push<UICredits>();
		return true;
	}

	private bool Button_back_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		ReturnToMenu();
		return true;
	}

	private bool Button_quitGame_OnTapUp()
	{
		if (IsTransitioning)
		{
			return false;
		}
		OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		return true;
	}

	private void ReturnToMenu()
	{
		if ((bool)returnToMenuRoutine.running)
		{
			Routine.Pause(returnToMenuRoutine);
		}
		Routine.Start(returnToMenuRoutine, LR.Host);
	}

	private IEnumerator<HagletYieldTerm> ReturnToMenuRoutine()
	{
		if ((bool)hideAllRoutine.running)
		{
			Routine.Pause(hideAllRoutine);
		}
		ToggleButtonHighlights(val: false);
		animDriver.Value = GetAlpha();
		animDriver.AnimateTo(0f, 0.3f);
		while ((bool)animDriver.animating)
		{
			UpdateUIAlpha(animDriver.Update());
			yield return null;
		}
		AC.Inst.PlayOneShot2D("event:/sfx/ui/penthouse map close");
		animDriver.Value = 1f;
		animDriver.AnimateTo(0f, 1f);
		while ((bool)animDriver.animating)
		{
			UpdateTransitionAnim(animDriver.Update(), updateWireframe: true);
			yield return null;
		}
		base.HideAll();
		RC.Inst.RoomShow();
		yield return Singleton<UIC>.Inst.Pop();
		RR.Inst.StartHartmanPottering(randomStart: false);
		playHideSound = false;
	}

	private IEnumerator<HagletYieldTerm> HideAllRoutine()
	{
		ToggleButtonHighlights(val: false);
		if (playHideSound)
		{
			AC.Inst.PlayOneShot2D("event:/sfx/ui/penthouse map close");
		}
		animDriver.Value = GetAlpha();
		animDriver.AnimateTo(0f, 0.3f);
		while ((bool)animDriver.animating)
		{
			UpdateUIAlpha(animDriver.Update());
			yield return null;
		}
		animDriver.Value = 1f;
		animDriver.AnimateTo(0f, 1f);
		while ((bool)animDriver.animating)
		{
			UpdateTransitionAnim(animDriver.Update(), updateWireframe: false);
			yield return null;
		}
		base.HideAll();
		playHideSound = false;
	}

	private IEnumerator<HagletYieldTerm> ShowAllRoutine()
	{
		bool shouldUpdateWireframe = !RC.Inst.WireframeVisible;
		bool wasntShown = !base.IsShown;
		if (wasntShown)
		{
			UpdateTransitionAnim(0f, shouldUpdateWireframe);
		}
		else
		{
			animDriver.Value = GetAlpha();
			animDriver.AnimateTo(0f, 0.3f);
			while ((bool)animDriver.animating)
			{
				UpdateUIAlpha(animDriver.Update());
				yield return null;
			}
		}
		RR.Inst.StopHartmanPottering();
		RC.Inst.RoomHide();
		yield return RC.Inst.OnRoomHiddenComplete;
		RR.Inst.HideArtwork();
		AC.Inst.PlayOneShot2D("event:/sfx/ui/penthouse map open");
		base.ShowAll();
		container_confirmation.HideAll();
		currentGroupIndex = SaveData.data.GetFurthestMissionGroupIdx();
		SaveData.MissionGroup currentMissionGroup = SaveData.data.GetFurthestMissionGroup();
		for (int i = 0; i < ui_MissionGroups.Length; i++)
		{
			for (int j = 0; j < ui_MissionGroups[i].uiMissions.Length; j++)
			{
				ui_MissionGroups[i].uiMissions[j].button.Hide();
				ui_MissionGroups[i].uiMissions[j].imgGlowLargePulse.StopImagePulse();
				ui_MissionGroups[i].uiMissions[j].imgGlowSmallPulse.StopImagePulse();
			}
		}
		if (SaveData.data.IsGameComplete())
		{
			containerSideMenu.HideAll();
			textboxEndGameAreYouSure.Hide();
			buttonEndGameConfirm.Hide();
			buttonEndGameCancel.Hide();
		}
		else
		{
			containerEndGame.HideAll();
			ui_MissionGroups[currentGroupIndex].ShowAll();
			for (int k = 0; k < currentMissionGroup.size; k++)
			{
				if (SaveData.data.IsMissionComplete(currentGroupIndex, k))
				{
					ui_MissionGroups[currentGroupIndex].uiMissions[k].button.Hide();
					ui_MissionGroups[currentGroupIndex].uiMissions[k].imgGlowLargePulse.StopImagePulse();
					ui_MissionGroups[currentGroupIndex].uiMissions[k].imgGlowSmallPulse.StopImagePulse();
				}
				else
				{
					ui_MissionGroups[currentGroupIndex].uiMissions[k].imgGlowLargePulse.StartImagePulse();
					ui_MissionGroups[currentGroupIndex].uiMissions[k].imgGlowSmallPulse.StartImagePulse();
				}
				ui_MissionGroups[currentGroupIndex].uiMissions[k].selected.HideAll();
			}
			if (SaveData.data.chosenMission != null)
			{
				button_teamOrContinue.childTextbox.SetKey("UIMAINMENU_CONTINUEGAME");
			}
			else if (Party.Inst.GetUnlockedPartyMembersNum() > 0)
			{
				button_teamOrContinue.childTextbox.SetKey("UIMAINMENU_MANAGETEAM");
			}
			else
			{
				button_teamOrContinue.childTextbox.SetKey("UIMAINMENU_NEWGAME");
			}
		}
		base.gameObject.SetActive(value: true);
		isShown = true;
		OnBecameVisible();
		if (wasntShown)
		{
			animDriver.Value = 0f;
			animDriver.AnimateTo(1f, 1f);
		}
		ToggleButtonHighlights(val: false);
		UpdateUIAlpha(0f);
		if (wasntShown)
		{
			while ((bool)animDriver.animating)
			{
				UpdateTransitionAnim(animDriver.Update(), shouldUpdateWireframe);
				yield return null;
			}
		}
		animDriver.Value = 0f;
		animDriver.AnimateTo(1f, 0.5f);
		while ((bool)animDriver.animating)
		{
			UpdateUIAlpha(animDriver.Update());
			yield return null;
		}
		playHideSound = true;
		ToggleButtonHighlights(val: true);
	}

	private void UpdateTransitionAnim(float t, bool updateWireframe)
	{
		float holoFrameFadeScale = LR.Inst.animHoloFrameFadeScale.Evaluate(t);
		float holoFrameWidth = LR.Inst.animHoloFrameWidth.Evaluate(t);
		mapActive.UpdateMapHologramMaterials(mapActive.transform.worldToLocalMatrix, t, holoFrameWidth, LR.Inst.animHoloFrameHeight.Evaluate(t), holoFrameFadeScale);
		if (updateWireframe)
		{
			RC.Inst.SetWireframAlpha(wireframeAlphaCurve.Evaluate(t));
		}
	}

	private void UpdateUIAlpha(float a)
	{
		SetAlpha(a);
		for (int i = 0; i < sideMenuButtons.Length; i++)
		{
			float num = 0.9f;
			float num2 = (float)i / (float)sideMenuButtons.Length * num;
			float t = a * (1f + num) - num2;
			float newVal = Mathf.SmoothStep(0.3f, 0f, Mathf.Lerp(0f, 1f, t));
			UIElement uIElement = sideMenuButtons[i];
			uIElement.transform.localPosition = uIElement.transform.localPosition.RepX(newVal);
		}
	}

	private void ToggleButtonHighlights(bool val)
	{
		for (int i = 0; i < uiHighlights.Length; i++)
		{
			uiHighlights[i].highlightText = val;
			uiHighlights[i].ResetColor(text: true, image: false);
		}
	}
}
public class UINarrativeDialog : UIContainer
{
	private struct UIAnswer
	{
		public UIContainer container;

		public UIButton buttonUnselectedSmall;

		public UIButton buttonUnselectedLarge;

		public UIButton buttonUnselectedXL;

		public UIImage imageSelectedSmall;

		public UIImage imageSelectedLarge;

		public UIImage imageSelectedXL;

		public UITextbox textboxAnswer;
	}

	private struct State
	{
		public DialogData dialogData;

		public HagletTrigger onCompleteTrigger;

		public string overrideDisplayName;
	}

	public delegate void OnDialogQuestionAnswered(int answerIndex);

	private readonly Vector3 diffBetweenSmallHeightBoxes = new Vector3(0f, -0.05f, 0f);

	private readonly Vector3 diffBetweenLargeHeightBoxes = new Vector3(0f, -0.07f, 0f);

	private readonly Vector3 textboxSmallPosition = new Vector3(0.09f, -0.03f, 0f);

	private readonly Vector3 textboxLargePosition = new Vector3(-0.12f, -0.03f, 0f);

	private readonly Vector3 textboxXLPosition = new Vector3(-0.12f, -0.0375f, 0f);

	private const float largeWidthCheck = 0.205f;

	private const float largeHeightCheck = 0.03f;

	private readonly Vector3 kUpperUpperPos = new Vector3(0f, 1.45f, -0.351f);

	private readonly Vector3 kUpperPos = new Vector3(0f, 1.379f, -0.351f);

	private readonly Vector3 kMidPos = new Vector3(0f, 1.16f, -0.351f);

	private readonly Vector3 kLowerPos = new Vector3(0f, 1f, -0.351f);

	private static UINarrativeDialog _instance;

	private UIImage imagePortrait;

	private UIImage imagePortraitFrame;

	private UIImage imagePortraitBackground;

	private UIImage imageBackground;

	private UIImage imageNameBackground;

	private UIImage imageNameLargeBackground;

	private UITextbox textboxName;

	private UITextbox textboxNameLarge;

	private UITextbox textboxBody;

	private UIAnswer[] answers = new UIAnswer[3];

	private UITextbox textboxTapToContinue;

	private Transform containerAll;

	private UIContainer container3XQuestion;

	private State currState;

	private State nextState;

	private DialogData.Dialog currentDialog;

	private DialogData.Dialog nextDialog;

	private uint dialogDataIndex;

	private uint currentResponseLine;

	private uint questionCount;

	private HagletResettable fadeDialogueInOutAnim;

	private HagletResettable changeDialogue;

	private HagletResettable skipLine;

	private AnimFloat visibility = new AnimFloat(0f);

	private const float animDur = 0.3f;

	private const float zCourse = 0.12f;

	[NonSerialized]
	public HagletTrigger OnComplete = new HagletTrigger();

	private Action<VOController.VOCompletion> OnVOComplete;

	public static UINarrativeDialog Inst => _instance;

	public DialogData CurrDialogData => currState.dialogData;

	public override void OnAwakeLR()
	{
		_instance = this;
		fadeDialogueInOutAnim = new HagletResettable(FadeDialogueInOutRoutine(), "Fade Dialogue In or Out");
		changeDialogue = new HagletResettable(ChangeDialogueRoutine(), "Change Dialogue");
		skipLine = new HagletResettable(SkipLine(), "Skip Line");
		base.OnAwakeLR();
		UIContainer container = GetContainer("Name");
		UIContainer container2 = GetContainer("Name Large");
		UIContainer container3 = GetContainer("Portrait");
		container3XQuestion = GetContainer("3xQuestion");
		containerAll = base.transform.GetChild(0);
		imagePortrait = container3.GetElement<UIImage>("Image");
		imagePortraitFrame = container3.GetElement<UIImage>("Frame");
		imagePortraitBackground = container3.GetElement<UIImage>("Background");
		textboxName = container.GetElement<UITextbox>("Name");
		imageNameBackground = container.GetElement<UIImage>("Background");
		textboxNameLarge = container2.GetElement<UITextbox>("Name");
		imageNameLargeBackground = container2.GetElement<UIImage>("Background");
		imageBackground = GetElement<UIImage>("Background");
		textboxBody = GetElement<UITextbox>("BodyText");
		textboxTapToContinue = GetElement<UITextbox>("TapToContinue");
		UIContainer[] array = container3XQuestion.GetContainers();
		for (int i = 0; i < answers.Length; i++)
		{
			UIContainer uIContainer = array[i];
			answers[i] = default(UIAnswer);
			answers[i].container = uIContainer;
			answers[i].buttonUnselectedSmall = uIContainer.GetElement<UIButton>("UnselectedBackgroundS");
			answers[i].imageSelectedSmall = uIContainer.GetElement<UIImage>("SelectedBackgroundS");
			answers[i].buttonUnselectedLarge = uIContainer.GetElement<UIButton>("UnselectedBackgroundL");
			answers[i].imageSelectedLarge = uIContainer.GetElement<UIImage>("SelectedBackgroundL");
			answers[i].buttonUnselectedXL = uIContainer.GetElement<UIButton>("UnselectedBackgroundXL");
			answers[i].imageSelectedXL = uIContainer.GetElement<UIImage>("SelectedBackgroundXL");
			answers[i].textboxAnswer = uIContainer.GetElement<UITextbox>("Answer");
		}
		for (int j = 0; j < answers.Length; j++)
		{
			UIAnswer answer = answers[j];
			answer.buttonUnselectedSmall.userData = j;
			answer.buttonUnselectedLarge.userData = j;
			answer.buttonUnselectedXL.userData = j;
			answer.buttonUnselectedSmall.OnFocusEnterWithUserData += delegate
			{
				answer.imageSelectedSmall.IsShown = true;
			};
			answer.buttonUnselectedLarge.OnFocusEnterWithUserData += delegate
			{
				answer.imageSelectedLarge.IsShown = true;
			};
			answer.buttonUnselectedXL.OnFocusEnterWithUserData += delegate
			{
				answer.imageSelectedXL.IsShown = true;
			};
			answer.buttonUnselectedSmall.OnFocusExitWithUserData += delegate
			{
				answer.imageSelectedSmall.IsShown = false;
			};
			answer.buttonUnselectedLarge.OnFocusExitWithUserData += delegate
			{
				answer.imageSelectedLarge.IsShown = false;
			};
			answer.buttonUnselectedXL.OnFocusExitWithUserData += delegate
			{
				answer.imageSelectedXL.IsShown = false;
			};
		}
		answers[0].buttonUnselectedSmall.OnTapUp += OnButtonAnswer0;
		answers[0].buttonUnselectedLarge.OnTapUp += OnButtonAnswer0;
		answers[0].buttonUnselectedXL.OnTapUp += OnButtonAnswer0;
		answers[1].buttonUnselectedSmall.OnTapUp += OnButtonAnswer1;
		answers[1].buttonUnselectedLarge.OnTapUp += OnButtonAnswer1;
		answers[1].buttonUnselectedXL.OnTapUp += OnButtonAnswer1;
		answers[2].buttonUnselectedSmall.OnTapUp += OnButtonAnswer2;
		answers[2].buttonUnselectedLarge.OnTapUp += OnButtonAnswer2;
		answers[2].buttonUnselectedXL.OnTapUp += OnButtonAnswer2;
		base.transform.localPosition = Vector3.zero;
		visibility.Interpolate = (float val) => MathfX.SineRemapLerp(val, MathfX.SineRemapEaseType.Out);
		OnVOComplete = delegate(VOController.VOCompletion reason)
		{
			if (reason == VOController.VOCompletion.Finished)
			{
				OnButtonNext();
			}
		};
	}

	private IEnumerator<HagletYieldTerm> SkipLine()
	{
		yield return Wait.While(changeDialogue.running);
		OnButtonNext();
	}

	public override void ShowAll()
	{
		if ((bool)changeDialogue.running)
		{
			changeDialogue.host.Pause(changeDialogue);
			changeDialogue.Reset();
		}
		base.ShowAll();
		currState = nextState;
		PrepareDialog(currState.dialogData.dialogs[dialogDataIndex]);
		isShown = true;
		AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/text card appear");
		FadeDialogue(fadeIn: true);
		UITelephone.Inst.Hide();
	}

	public override bool HideAll()
	{
		if ((bool)changeDialogue.running)
		{
			changeDialogue.host.Pause(changeDialogue);
			changeDialogue.Reset();
		}
		if (HagletHost.current == null)
		{
			base.HideAll();
		}
		else
		{
			HideDialog();
		}
		return true;
	}

	public void SetState(DialogData dialogData, HagletTrigger onCompleteTrigger = null, string overrideDisplayName = null)
	{
		if ((bool)changeDialogue.running)
		{
			changeDialogue.host.Pause(changeDialogue);
			changeDialogue.Reset();
		}
		dialogDataIndex = 0u;
		nextState = new State
		{
			dialogData = dialogData,
			onCompleteTrigger = onCompleteTrigger,
			overrideDisplayName = overrideDisplayName
		};
	}

	private void ResetDialog()
	{
		textboxTapToContinue.gameObject.SetActive(value: false);
		for (int i = 0; i < answers.Length; i++)
		{
			UIAnswer uIAnswer = answers[i];
			uIAnswer.imageSelectedSmall.Hide();
			uIAnswer.imageSelectedLarge.Hide();
			uIAnswer.imageSelectedXL.Hide();
		}
		container3XQuestion.HideAll();
	}

	private void PrepareDialog(DialogData.Dialog dialog)
	{
		ResetDialog();
		if (!dialog.GetCharacterData(out var cData, ref dialog.unitRef))
		{
			Routine.Start(skipLine);
			return;
		}
		string bodyKey = dialog.GetBodyKey();
		if (cData == null)
		{
			imagePortrait.Hide();
			textboxName.Hide();
			textboxNameLarge.Hide();
			UnityEngine.Debug.LogWarning(string.Concat("Could not find Sprite for: ", cData, " could not show portrait image!"));
		}
		else
		{
			imagePortrait.Show();
			imagePortrait.SetImage(cData.GetDialogSprite(dialog.expression));
			string empty = string.Empty;
			string value = ((currState.overrideDisplayName == null) ? string.Empty : Localisation.Retrieve(currState.overrideDisplayName));
			empty = (string.IsNullOrEmpty(value) ? cData.DisplayName : currState.overrideDisplayName);
			string text = Localisation.Retrieve(empty);
			if (text.Length < 8)
			{
				imageNameBackground.Show();
				textboxName.Show();
				imageNameLargeBackground.Hide();
				textboxNameLarge.Hide();
				textboxName.SetKey(empty);
			}
			else
			{
				imageNameLargeBackground.Show();
				textboxNameLarge.Show();
				imageNameBackground.Hide();
				textboxName.Hide();
				textboxNameLarge.SetKey(empty);
			}
		}
		if (dialog.type == DialogData.DialogType.Simple)
		{
			container3XQuestion.HideAll();
			textboxBody.SetKey(bodyKey);
			textboxTapToContinue.gameObject.SetActive(currState.dialogData.showTapToContinue);
		}
		else
		{
			questionCount++;
			textboxBody.SetKey(bodyKey);
			container3XQuestion.ShowAll();
			int num = (string.IsNullOrEmpty(dialog.answer2Key) ? 2 : 3);
			for (int i = 0; i < num; i++)
			{
				UIAnswer uIAnswer = answers[i];
				uIAnswer.imageSelectedSmall.Hide();
				uIAnswer.imageSelectedLarge.Hide();
				uIAnswer.imageSelectedXL.Hide();
			}
			string answer0Key = dialog.answer0Key;
			bool flag = !string.IsNullOrEmpty(answer0Key);
			Vector3? size = null;
			if (flag)
			{
				size = answers[0].textboxAnswer.SetKey(answer0Key, returnSize: true);
			}
			string answer1Key = dialog.answer1Key;
			bool flag2 = !string.IsNullOrEmpty(answer1Key);
			Vector3? size2 = null;
			if (flag2)
			{
				size2 = answers[1].textboxAnswer.SetKey(answer1Key, returnSize: true);
			}
			string answer2Key = dialog.answer2Key;
			bool flag3 = !string.IsNullOrEmpty(answer2Key);
			Vector3? size3 = null;
			if (flag3)
			{
				size3 = answers[2].textboxAnswer.SetKey(answer2Key, returnSize: true);
			}
			float num2 = Mathf.Max((!size.HasValue) ? 0f : size.Value.x, Mathf.Max((!size2.HasValue) ? 0f : size2.Value.x, (!size3.HasValue) ? 0f : size3.Value.x));
			bool useLargeBoxes = num2 > 0.205f;
			bool lastAnswerUsedXL = false;
			Vector3 offset = Vector3.zero;
			SetUpAnswer(answers[0], size, useLargeBoxes, ref lastAnswerUsedXL, ref offset, flag, firstBox: true);
			SetUpAnswer(answers[1], size2, useLargeBoxes, ref lastAnswerUsedXL, ref offset, flag2);
			SetUpAnswer(answers[2], size3, useLargeBoxes, ref lastAnswerUsedXL, ref offset, flag3);
		}
		Transform transform = null;
		if (dialog.unitRef != null && dialog.unitRef.IsShown)
		{
			UIAmbientSubtitles.Inst.highlightUnit.Start(dialog.unitRef);
			transform = dialog.unitRef._GetTransform();
		}
		else if (dialog.roomObjectRef != null)
		{
			transform = dialog.roomObjectRef;
		}
		else if (cData != null && cData.charName == "Hartman")
		{
			transform = ((!(Singleton<Hartman>.Inst != null)) ? Singleton<CC>.Inst.transformCamera : ((!Singleton<Hartman>.Inst.gameObject.activeInHierarchy) ? Singleton<CC>.Inst.transformCamera : Singleton<Hartman>.Inst.transform));
		}
		MusicController.Inst.SetMusicParameter(dialog.musicParameter, dialog.musicParameterValue);
		dialog.OnShow();
		if (!string.IsNullOrEmpty(bodyKey) && !LR.Inst.MissionIsUnloading)
		{
			VOController inst = VOController.Inst;
			string clipName = bodyKey;
			VOController.VOQueueProperty properties = VOController.VOQueueProperty.Interrupt;
			Action<VOController.VOCompletion> onComplete = ((dialog.type != 0) ? null : OnVOComplete);
			Transform source = transform;
			inst.VOPlayClip(clipName, properties, onComplete, 0f, source, dialog.unitRef);
		}
		else
		{
			VOController.Inst.VOStop();
		}
		currentDialog = dialog;
		switch (dialog.displayPos)
		{
		case DialogData.DisplayPosition.UpperUpperPos:
			containerAll.localPosition = kUpperUpperPos;
			break;
		case DialogData.DisplayPosition.UpperPos:
			containerAll.localPosition = kUpperPos;
			break;
		case DialogData.DisplayPosition.MiddlePos:
			containerAll.localPosition = kMidPos;
			break;
		case DialogData.DisplayPosition.LowerPos:
			containerAll.localPosition = kLowerPos;
			break;
		}
		containerAll.LookAt(containerAll.position - (Singleton<CC>.Inst.transform.position - containerAll.position));
	}

	private void SetUpAnswer(UIAnswer answer, Vector3? size, bool useLargeBoxes, ref bool lastAnswerUsedXL, ref Vector3 offset, bool hasKey, bool firstBox = false)
	{
		if (hasKey)
		{
			if (lastAnswerUsedXL)
			{
				answer.container.transform.localPosition = (offset += diffBetweenLargeHeightBoxes);
			}
			else if (!firstBox)
			{
				answer.container.transform.localPosition = (offset += diffBetweenSmallHeightBoxes);
			}
			if (!useLargeBoxes)
			{
				answer.buttonUnselectedLarge.Hide();
				answer.buttonUnselectedXL.Hide();
				answer.textboxAnswer.transform.localPosition = textboxSmallPosition;
				return;
			}
			answer.buttonUnselectedSmall.Hide();
			bool flag = size.Value.y > 0.03f;
			if (!flag)
			{
				answer.buttonUnselectedXL.Hide();
				answer.textboxAnswer.transform.localPosition = textboxLargePosition;
			}
			else
			{
				answer.buttonUnselectedLarge.Hide();
				answer.textboxAnswer.transform.localPosition = textboxXLPosition;
			}
			lastAnswerUsedXL = flag;
		}
		else
		{
			answer.container.HideAll();
		}
	}

	private void HideDialog()
	{
		if (MR.Inst != null)
		{
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/text card disappear");
		}
		textboxTapToContinue.PulseAlphaStop();
		FadeDialogue(fadeIn: false);
	}

	private void FadeDialogue(bool fadeIn, bool immediate = false)
	{
		visibility.AnimateTo(fadeIn ? 1 : 0, 0.3f);
		if (immediate)
		{
			visibility.Update(0.3f);
			UpdateFade();
			base.HideAll();
			return;
		}
		if ((bool)fadeDialogueInOutAnim.running)
		{
			fadeDialogueInOutAnim.host.Pause(fadeDialogueInOutAnim);
			fadeDialogueInOutAnim.Reset();
		}
		if (MR.Inst != null)
		{
			Routine.Start(fadeDialogueInOutAnim, MR.Inst.Host);
		}
		else
		{
			LR.Host.StartTopLevel(fadeDialogueInOutAnim);
		}
	}

	private IEnumerator<HagletYieldTerm> FadeDialogueInOutRoutine()
	{
		while ((bool)visibility.animating)
		{
			float visVal = visibility.Update();
			UpdateFade();
			yield return null;
		}
		if (visibility.Value == 0f)
		{
			base.HideAll();
		}
		else if (!visibility.animating && visibility.Value == 1f)
		{
			textboxTapToContinue.PulseAlphaStart(LR.Host);
		}
	}

	private void UpdateFade()
	{
		float value = visibility.Value;
		UIImage uIImage = imageBackground;
		float num = value;
		textboxNameLarge.alpha = num;
		num = num;
		textboxName.alpha = num;
		num = num;
		textboxTapToContinue.alpha = num;
		num = num;
		textboxBody.alpha = num;
		num = num;
		imageNameLargeBackground.alpha = num;
		num = num;
		imageNameBackground.alpha = num;
		num = num;
		imagePortraitBackground.alpha = num;
		num = num;
		imagePortraitFrame.alpha = num;
		num = num;
		imagePortrait.alpha = num;
		uIImage.alpha = num;
		for (int i = 0; i < answers.Length; i++)
		{
			answers[i].container.SetAlpha(value);
		}
	}

	private void ChangeDialogue(DialogData.Dialog nextDialog)
	{
		this.nextDialog = nextDialog;
		if ((bool)changeDialogue.running)
		{
			changeDialogue.host.Pause(changeDialogue);
			changeDialogue.Reset();
		}
		if (MR.Inst != null)
		{
			Routine.Start(changeDialogue, MR.Inst.Host);
		}
		else
		{
			LR.Host.StartTopLevel(changeDialogue);
		}
	}

	private IEnumerator<HagletYieldTerm> ChangeDialogueRoutine()
	{
		float bufferTime = currentDialog.bufferTime;
		bool fade = 0.6f < bufferTime;
		if (fade)
		{
			bufferTime -= 0.6f;
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/text card disappear");
			textboxTapToContinue.PulseAlphaStop();
			FadeDialogue(fadeIn: false);
			yield return Wait.ForSeconds(0.3f);
		}
		yield return Wait.ForSeconds(bufferTime);
		if (!fade)
		{
			imagePortrait.Hide();
			textboxName.Hide();
			textboxNameLarge.Hide();
			container3XQuestion.HideAll();
			textboxBody.SetText(string.Empty);
		}
		else
		{
			base.ShowAll();
		}
		PrepareDialog(nextDialog);
		if (fade)
		{
			isShown = true;
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/text card appear");
			FadeDialogue(fadeIn: true);
			UITelephone.Inst.Hide();
		}
	}

	private void Update()
	{
	}

	public void Skip()
	{
		if (base.IsShown)
		{
			FadeDialogue(fadeIn: false, immediate: true);
			Update();
			OnCompleteDialog();
			Unit leader = Singleton<PC>.Inst.GetLeader();
			if (leader != null && leader.IsShown)
			{
				UIAmbientSubtitles.Inst.highlightUnit.Start(leader);
			}
		}
	}

	private void OnButtonNext()
	{
		if (currState.dialogData == null || (bool)changeDialogue.running || (!MR.Inst.IsSkipping() && ((bool)fadeResettable.running || fadeResettable.markedToRunBy != null || (bool)changeDialogue.running || changeDialogue.markedToRunBy != null || !base.IsShown || LR.Inst.IsPaused())))
		{
			return;
		}
		Unit unitRef = currState.dialogData.dialogs[dialogDataIndex].unitRef;
		if (unitRef != null)
		{
			unitRef.unitModel.playAndIdleResettable.Reset();
		}
		currState.dialogData.currentResponseLine = currentResponseLine;
		dialogDataIndex++;
		while (dialogDataIndex < currState.dialogData.dialogs.Length && currState.dialogData.dialogs[dialogDataIndex].responseLine != 0 && currState.dialogData.dialogs[dialogDataIndex].responseLine != currentResponseLine)
		{
			dialogDataIndex++;
		}
		if (dialogDataIndex != currState.dialogData.dialogs.Length)
		{
			if (dialogDataIndex < currState.dialogData.dialogs.Length)
			{
				ChangeDialogue(currState.dialogData.dialogs[dialogDataIndex]);
			}
		}
		else
		{
			OnCompleteDialog();
		}
	}

	private void OnCompleteDialog()
	{
		DialogData dialogData = currState.dialogData;
		currState.dialogData = null;
		currState.overrideDisplayName = null;
		nextState.dialogData = null;
		nextState.overrideDisplayName = null;
		if ((bool)Singleton<PC>.Inst)
		{
			Unit leader = Singleton<PC>.Inst.GetLeader();
			if (leader != null && leader.IsShown)
			{
				UIAmbientSubtitles.Inst.highlightUnit.Start(leader);
			}
			if (currState.onCompleteTrigger != null)
			{
				currState.onCompleteTrigger.Trigger();
			}
		}
		if (dialogData != null)
		{
			dialogData.OnComplete.Trigger();
			dialogData.completed = true;
		}
		UIAmbientSubtitles.Inst.highlightUnit.PauseHighlight();
		OnComplete.Trigger();
		Singleton<UIC>.Inst.Pop();
	}

	private void OnButtonSimple()
	{
		AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/text card click");
		OnButtonNext();
	}

	private bool OnButtonAnswer0()
	{
		currentResponseLine = currState.dialogData.dialogs[dialogDataIndex].response0lineSuccess;
		if (currState.dialogData.dialogs[dialogDataIndex].storeResponse)
		{
			DC.GameSection gameSection = currState.dialogData.dialogs[dialogDataIndex].gameSection;
			bool answer0Honest = currState.dialogData.dialogs[dialogDataIndex].answer0Honest;
			int answerWeighting = currState.dialogData.dialogs[dialogDataIndex].answerWeighting;
			DC.Inst.RegisterDialogResponse(gameSection, (!answer0Honest) ? (-answerWeighting) : answerWeighting);
		}
		currState.dialogData.OnAnswer0.Trigger();
		OnButtonSelect();
		return true;
	}

	private bool OnButtonAnswer1()
	{
		currentResponseLine = currState.dialogData.dialogs[dialogDataIndex].response1lineSuccess;
		if (currState.dialogData.dialogs[dialogDataIndex].storeResponse)
		{
			DC.GameSection gameSection = currState.dialogData.dialogs[dialogDataIndex].gameSection;
			bool answer1Honest = currState.dialogData.dialogs[dialogDataIndex].answer1Honest;
			int answerWeighting = currState.dialogData.dialogs[dialogDataIndex].answerWeighting;
			DC.Inst.RegisterDialogResponse(gameSection, (!answer1Honest) ? (-answerWeighting) : answerWeighting);
		}
		currState.dialogData.OnAnswer1.Trigger();
		OnButtonSelect();
		return true;
	}

	private bool OnButtonAnswer2()
	{
		currentResponseLine = currState.dialogData.dialogs[dialogDataIndex].response2lineSuccess;
		currState.dialogData.OnAnswer2.Trigger();
		OnButtonSelect();
		return true;
	}

	private void OnButtonSelect()
	{
		AC.Inst.PlayOneShot2D("event:/sfx/ui/dialogue select");
		OnButtonNext();
	}

	public override bool OnBackButtonPressed()
	{
		return false;
	}

	public override bool ConsumesActionButton()
	{
		switch (currentDialog.type)
		{
		case DialogData.DialogType.Simple:
			return true;
		case DialogData.DialogType.Question:
		case DialogData.DialogType.Response:
			return false;
		default:
			return true;
		}
	}

	public override void OnActionButtonPressed()
	{
		if (currentDialog.type == DialogData.DialogType.Simple)
		{
			OnButtonSimple();
		}
	}
}
public class UIObjectives : UIContainer
{
	public enum FinishedState
	{
		Cancelled,
		Completed
	}

	[Serializable]
	public struct StrObjective
	{
		public string text;

		public bool pulse;
	}

	public class UIObjective
	{
		[NonSerialized]
		public UITextbox textBox;

		[NonSerialized]
		public UIImage backdrop;

		[NonSerialized]
		public UIImage completeSprite;

		[NonSerialized]
		public UIImage incompleteSprite;

		[NonSerialized]
		public GameObject go;

		public string objectiveTextNext;

		public bool willPulse;

		[NonSerialized]
		public Vector3 animPosBegin;

		[NonSerialized]
		public Vector3 animPosEnd;

		[NonSerialized]
		public Vector3 animScaleBegin;

		[NonSerialized]
		public Vector3 animScaleEnd;

		[NonSerialized]
		public int displayedAtIndex = -1;

		[NonSerialized]
		public FinishedState finishingState;

		public HagletResettable fadeIn;

		public HagletResettable cancel;

		public HagletResettable complete;

		public HagletResettable shuffle;

		public void SetupObjective(int idx, UIObjectives inst)
		{
			textBox = inst.GetElement<UITextbox>(textBoxElements[idx]);
			backdrop = inst.GetElement<UIImage>(backdropElements[idx]);
			if (idx == 0)
			{
				completeSprite = inst.GetElement<UIImage>("CompleteSprite");
				incompleteSprite = inst.GetElement<UIImage>("IncompleteSprite");
			}
			go = backdrop.gameObject;
			ref Vector3 reference = ref inst.positionsUpper[idx];
			reference = go.transform.localPosition;
			ref Vector3 reference2 = ref inst.positionsLower[idx];
			reference2 = go.transform.localPosition + inst.positionOffsetLower;
			ref Vector3 reference3 = ref inst.scales[idx];
			reference3 = go.transform.localScale;
			fadeIn = new HagletResettable(FadeIn());
			cancel = new HagletResettable(Cancel());
			complete = new HagletResettable(Complete());
			shuffle = new HagletResettable(Shuffle());
		}

		public void CleanUpDisplay()
		{
			CleanUpDisplayAnim(fadeIn);
			CleanUpDisplayAnim(cancel);
			CleanUpDisplayAnim(complete);
			CleanUpDisplayAnim(shuffle);
			objectiveTextNext = string.Empty;
			displayedAtIndex = -1;
			textBox.Hide();
			backdrop.Hide();
			if (incompleteSprite != null)
			{
				incompleteSprite.Hide();
			}
			if (incompleteSprite != null)
			{
				completeSprite.Hide();
			}
		}

		protected void CleanUpDisplayAnim(HagletResettable anim)
		{
			if (anim != null && (bool)anim.running)
			{
				LR.Host.Pause(anim);
				anim.Reset();
			}
		}

		protected IEnumerator<HagletYieldTerm> FadeIn()
		{
			Transform xform = go.transform;
			UIObjectives inst = Inst;
			xform.localPosition = inst.positionsLower[displayedAtIndex];
			xform.localScale = inst.scales[displayedAtIndex];
			textBox.SetKey(objectiveTextNext);
			textBox.alpha = 0f;
			backdrop.alpha = 0f;
			incompleteSprite.alpha = 0f;
			textBox.Show();
			backdrop.Show();
			incompleteSprite.Show();
			textBox.color = Inst.incompleteColor;
			yield return Wait.ForSeconds(0.025f * (float)displayedAtIndex);
			float t2 = 0f;
			while (t2 < 0.3f)
			{
				t2 += Time.deltaTime;
				float normalAnimProgress = t2 / 0.3f;
				textBox.alpha = normalAnimProgress;
				backdrop.alpha = normalAnimProgress;
				incompleteSprite.alpha = normalAnimProgress;
				yield return Wait.UntilNextUpdate();
			}
			textBox.alpha = 1f;
			backdrop.alpha = 1f;
			incompleteSprite.alpha = 1f;
			yield return Wait.ForSeconds(0.025f * (float)displayedAtIndex);
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/mission objective move back");
			float t = 0f;
			while (t < 0.6f)
			{
				t += Time.deltaTime;
				xform.localPosition = Vector3.LerpUnclamped(inst.positionsLower[displayedAtIndex], inst.positionsUpper[displayedAtIndex], inst.curveMovement.Evaluate(t));
				yield return Wait.UntilNextUpdate();
			}
			if (willPulse)
			{
				textBox.PulseAlphaStart(LR.Host);
			}
			textBox.Show();
			backdrop.Show();
		}

		protected IEnumerator<HagletYieldTerm> Cancel()
		{
			Transform xform = go.transform;
			UIObjectives inst = Inst;
			textBox.PulseAlphaStop();
			yield return Wait.ForChildren;
			float t = 0f;
			while (t < 0.3f)
			{
				t += Time.deltaTime;
				float normalAnimProgress = 1f - t / 0.3f;
				textBox.alpha = normalAnimProgress;
				backdrop.alpha = normalAnimProgress;
				yield return Wait.UntilNextUpdate();
			}
			displayedAtIndex = -1;
			objectiveTextNext = null;
			textBox.Hide();
			backdrop.Hide();
		}

		protected IEnumerator<HagletYieldTerm> Complete()
		{
			Transform xform = go.transform;
			UIObjectives inst = Inst;
			if (!textBox.IsShown || !backdrop.IsShown || !incompleteSprite.IsShown)
			{
				textBox.Show();
				backdrop.Show();
				incompleteSprite.Show();
			}
			while (!inst.isActiveAndEnabled)
			{
				yield return null;
			}
			yield return Wait.ForSeconds(0.5f);
			textBox.PulseAlphaStop();
			textBox.color = Inst.completeColor;
			completeSprite.alpha = 1f;
			incompleteSprite.Hide();
			completeSprite.Show();
			yield return Wait.ForChildren;
			yield return Wait.ForSeconds(0.5f);
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/mission objective move forward");
			float t2 = 0f;
			while (t2 < 0.6f)
			{
				t2 += Time.deltaTime;
				xform.localPosition = Vector3.LerpUnclamped(inst.positionsUpper[displayedAtIndex], inst.positionsLower[displayedAtIndex], inst.curveMovement.Evaluate(t2 / 0.6f));
				yield return Wait.UntilNextUpdate();
			}
			yield return Wait.ForSeconds(0.2f);
			AC.Inst.PlayOneShot2D("event:/sfx/ui/text cards/mission objective disappear");
			float t = 0f;
			while (t < 0.3f)
			{
				t += Time.deltaTime;
				float normalAnimProgress = 1f - t / 0.3f;
				textBox.alpha = normalAnimProgress;
				backdrop.alpha = normalAnimProgress;
				completeSprite.alpha = normalAnimProgress;
				xform.localScale = inst.scales[displayedAtIndex] + Vector3.one * (1f - normalAnimProgress) * 0.3f;
				yield return Wait.UntilNextUpdate();
			}
			objectiveTextNext = null;
			textBox.Hide();
			backdrop.Hide();
			completeSprite.Hide();
		}

		protected IEnumerator<HagletYieldTerm> Shuffle()
		{
			Transform xform = go.transform;
			UIObjectives inst = Inst;
			animPosBegin = go.transform.localPosition;
			animPosEnd = inst.positionsUpper[displayedAtIndex];
			animScaleBegin = go.transform.localScale;
			animScaleEnd = inst.scales[displayedAtIndex];
			float t = 0f;
			while (t < 0.5f)
			{
				t += Time.deltaTime;
				float normalAnimProgress = t / 0.5f;
				go.transform.localPosition = Vector3.Lerp(animPosBegin, animPosEnd, normalAnimProgress);
				go.transform.localScale = Vector3.Lerp(animScaleBegin, animScaleEnd, normalAnimProgress);
				yield return Wait.UntilNextUpdate();
			}
		}
	}

	private static UIObjectives _instance;

	public AnimationCurve curveMovement;

	private const int kNumUIObjectives = 3;

	private readonly Vector3 positionOffsetLower = new Vector3(0f, -0.15f, -0.385f);

	private const float fadeDur = 0.3f;

	private const float riseDur = 0.6f;

	private const float zCourse = 0.12f;

	private const float elemDelay = 0.025f;

	private const float rotationDur = 0.35f;

	private const float newObjectiveVisibleDelay = 1f;

	private GameObject rootGO;

	private Vector3[] positionsLower = new Vector3[3];

	private Vector3[] positionsUpper = new Vector3[3];

	private Vector3[] scales = new Vector3[3];

	private StrObjective[] objectives;

	private UIObjective[] objectiveDisplays;

	private HagletFlag objectivesWereEdited;

	private Color incompleteColor;

	private Color completeColor;

	[Serializer.Exclude]
	private Haglet uiObjectivesRoutineCache;

	private HagletResettable uiObjectivesShowRoutine;

	private static readonly IList<string> textBoxElements = new string[3] { "MainObjective", "SubObjective1", "SubObjective2" };

	private static readonly IList<string> backdropElements = new string[3] { "MainObjectiveBackdrop", "SubObjectiveBackdrop1", "SubObjectiveBackdrop2" };

	public static UIObjectives Inst => _instance;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_instance = this;
		InitializeObjectiveDisplays();
		rootGO = base.transform.Find("Root").gameObject;
		uiObjectivesRoutineCache = new HagletResettable(UIObjectiveRoutine());
		objectivesWereEdited = new HagletFlag();
		incompleteColor = ColorX.RGB(14, 170, 249);
		completeColor = ColorX.RGB(150, 164, 95);
		uiObjectivesShowRoutine = new HagletResettable(showObjectives());
		base.HideAll();
	}

	public override void ShowAll()
	{
		if ((bool)uiObjectivesShowRoutine.running || uiObjectivesShowRoutine.markedToRunBy != null)
		{
			LR.Host.Pause(uiObjectivesShowRoutine);
			uiObjectivesShowRoutine.Reset();
			LR.Host.StartTopLevel(uiObjectivesShowRoutine);
		}
		else
		{
			LR.Host.StartTopLevel(uiObjectivesShowRoutine);
		}
	}

	private IEnumerator<HagletYieldTerm> showObjectives()
	{
		do
		{
			yield return null;
		}
		while (GC.Inst.IsInCutsceneMode());
		for (int i = 0; i < objectives.Length; i++)
		{
			if (!string.IsNullOrEmpty(objectives[i].text))
			{
				int objDisplayIndexForObjText = GetObjDisplayIndexForObjText(objectives[i].text);
				if (objDisplayIndexForObjText >= 0)
				{
					objectiveDisplays[objDisplayIndexForObjText].backdrop.Show();
					objectiveDisplays[objDisplayIndexForObjText].textBox.Show();
					objectiveDisplays[objDisplayIndexForObjText].incompleteSprite.Show();
				}
			}
		}
	}

	private void InitializeObjectiveDisplays()
	{
		objectiveDisplays = new UIObjective[3];
		int num = -1;
		while (++num < objectiveDisplays.Length)
		{
			objectiveDisplays[num] = new UIObjective();
			objectiveDisplays[num].SetupObjective(num, this);
		}
	}

	public void OnMissionStart()
	{
		objectives = new StrObjective[3];
		LR.Host.StartTopLevel(uiObjectivesRoutineCache);
	}

	public void OnMissionResume()
	{
		LR.Host.StartTopLevel(uiObjectivesRoutineCache);
		objectivesWereEdited.Set();
	}

	public void OnMissionUnloaded()
	{
		ClearAll();
		if ((bool)uiObjectivesRoutineCache.running)
		{
			LR.Host.Pause(uiObjectivesRoutineCache);
		}
		uiObjectivesRoutineCache.Reset();
		for (int i = 0; i < objectiveDisplays.Length; i++)
		{
			objectiveDisplays[i].CleanUpDisplay();
		}
		HideAll();
	}

	private void RootSetActive()
	{
		rootGO.SetActive(value: true);
	}

	private void RootSetInactive()
	{
		rootGO.SetActive(value: false);
	}

	public void CancelAndSetMainObjective(string objectiveText, bool pulse = false)
	{
		SetMainObjective(objectiveText, FinishedState.Cancelled, pulse);
	}

	public void CompleteAndSetMainObjective(string objectiveText, bool pulse = false)
	{
		SetMainObjective(objectiveText, FinishedState.Completed, pulse);
	}

	public void AddObjective(string objectiveText, bool pulse = false)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			if (string.IsNullOrEmpty(objectives[i].text))
			{
				objectives[i].text = objectiveText;
				objectives[i].pulse = pulse;
				objectivesWereEdited.Set();
				break;
			}
		}
	}

	public void CompleteObjective(string objectiveText)
	{
		RemoveObjective(objectiveText, FinishedState.Completed);
	}

	public void CancelObjective(string objectiveText)
	{
		RemoveObjective(objectiveText, FinishedState.Cancelled);
	}

	public void ClearSubObjectives()
	{
		for (int i = 1; i < objectives.Length; i++)
		{
			objectives[i].text = string.Empty;
			objectives[i].pulse = false;
			objectiveDisplays[i].finishingState = FinishedState.Cancelled;
		}
		objectivesWereEdited.Set();
	}

	public void ClearAll()
	{
		if (objectives != null)
		{
			for (int i = 0; i < objectives.Length; i++)
			{
				objectives[i].text = string.Empty;
				objectives[i].pulse = false;
				objectiveDisplays[i].finishingState = FinishedState.Cancelled;
			}
		}
		objectivesWereEdited.Set();
	}

	private void SetMainObjective(string objectiveText, FinishedState previousMainObjState, bool pulse)
	{
		objectivesWereEdited.Set();
		UIObjective displayObjectiveShowingText = GetDisplayObjectiveShowingText(objectives[0].text);
		if (displayObjectiveShowingText != null)
		{
			displayObjectiveShowingText.finishingState = previousMainObjState;
		}
		for (int i = 1; i < objectives.Length; i++)
		{
			if (objectiveText == objectives[i].text)
			{
				objectives[0].text = objectives[i].text;
				objectives[0].pulse = objectives[i].pulse;
				objectives[i].text = string.Empty;
				objectives[i].pulse = false;
				ShuffleObjectivesUp();
				return;
			}
		}
		objectives[0].text = objectiveText;
		objectives[0].pulse = pulse;
	}

	private void RemoveObjective(string objectiveText, FinishedState finishedState)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			if (objectiveText == objectives[i].text)
			{
				UIObjective displayObjectiveShowingText = GetDisplayObjectiveShowingText(objectiveText);
				if (displayObjectiveShowingText != null)
				{
					displayObjectiveShowingText.finishingState = finishedState;
				}
				objectives[i].text = string.Empty;
				objectives[i].pulse = false;
				ShuffleObjectivesUp();
				objectivesWereEdited.Set();
				break;
			}
		}
	}

	private void ShuffleObjectivesUp()
	{
		bool flag = false;
		while (!flag)
		{
			flag = true;
			for (int i = 0; i < objectives.Length - 1; i++)
			{
				if (string.IsNullOrEmpty(objectives[i].text) && !string.IsNullOrEmpty(objectives[i + 1].text))
				{
					objectives[i].text = objectives[i + 1].text;
					objectives[i].pulse = objectives[i + 1].pulse;
					objectives[i + 1].text = string.Empty;
					objectives[i + 1].pulse = false;
					flag = false;
				}
			}
		}
		objectivesWereEdited.Set();
	}

	private bool ObjArrayContains(string objectiveText, StrObjective[] objectiveArray)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			if (objectiveArray[i].text == objectiveText)
			{
				return true;
			}
		}
		return false;
	}

	private int GetObjDisplayIndexForObjIndex(int index)
	{
		for (int i = 0; i < objectiveDisplays.Length; i++)
		{
			if (objectiveDisplays[i].displayedAtIndex == index)
			{
				return i;
			}
		}
		return -1;
	}

	private int GetObjDisplayIndexForObjText(string objectiveText)
	{
		for (int i = 0; i < objectiveDisplays.Length; i++)
		{
			if (objectiveDisplays[i].objectiveTextNext == objectiveText)
			{
				return i;
			}
		}
		return -1;
	}

	private UIObjective GetDisplayObjectiveShowingText(string objectiveText)
	{
		int objDisplayIndexForObjText = GetObjDisplayIndexForObjText(objectiveText);
		if (objDisplayIndexForObjText < 0)
		{
			return null;
		}
		return objectiveDisplays[objDisplayIndexForObjText];
	}

	private UIObjective GetFreeDisplayObjective()
	{
		for (int i = 0; i < objectiveDisplays.Length; i++)
		{
			if (string.IsNullOrEmpty(objectiveDisplays[i].objectiveTextNext))
			{
				return objectiveDisplays[i];
			}
		}
		return null;
	}

	private IEnumerator<HagletYieldTerm> UIObjectiveRoutine()
	{
		StrObjective[] previousObjectives = new StrObjective[3];
		StrObjective[] currentObjectives = new StrObjective[3];
		yield return Routine.ResetToHere();
		while (true)
		{
			yield return Wait.Until(objectivesWereEdited);
			objectivesWereEdited.Clear();
			for (int j = 0; j < currentObjectives.Length; j++)
			{
				currentObjectives[j].text = objectives[j].text;
				currentObjectives[j].pulse = objectives[j].pulse;
			}
			for (int i = 0; i < objectiveDisplays.Length; i++)
			{
				if (string.IsNullOrEmpty(objectiveDisplays[i].objectiveTextNext) || ObjArrayContains(objectiveDisplays[i].objectiveTextNext, currentObjectives))
				{
					continue;
				}
				UIObjective displayObjective = objectiveDisplays[i];
				if (displayObjective.finishingState == FinishedState.Completed)
				{
					if ((bool)displayObjective.complete.running)
					{
						displayObjective.complete.Reset();
					}
					else
					{
						Routine.Start(displayObjective.complete);
					}
					yield return displayObjective.complete.completed;
				}
			}
			HagletYieldTerm waitForChildren3 = Wait.ForChildren;
			for (int k = 0; k < objectiveDisplays.Length; k++)
			{
				if (!string.IsNullOrEmpty(objectiveDisplays[k].objectiveTextNext) && !ObjArrayContains(objectiveDisplays[k].objectiveTextNext, currentObjectives))
				{
					UIObjective uIObjective = objectiveDisplays[k];
					if (uIObjective.finishingState == FinishedState.Cancelled)
					{
						waitForChildren3 &= Routine.Start(uIObjective.cancel);
						uIObjective.objectiveTextNext = string.Empty;
					}
				}
			}
			yield return waitForChildren3;
			waitForChildren3 = Wait.ForChildren;
			for (int l = 0; l < currentObjectives.Length; l++)
			{
				if (!string.IsNullOrEmpty(currentObjectives[l].text))
				{
					int objDisplayIndexForObjText = GetObjDisplayIndexForObjText(currentObjectives[l].text);
					UIObjective uIObjective2 = ((objDisplayIndexForObjText < 0) ? null : objectiveDisplays[objDisplayIndexForObjText]);
					if (uIObjective2 != null && uIObjective2.displayedAtIndex != l)
					{
						uIObjective2.displayedAtIndex = l;
						waitForChildren3 &= Routine.Start(uIObjective2.shuffle);
					}
				}
			}
			yield return waitForChildren3;
			waitForChildren3 = Wait.ForChildren;
			for (int m = 0; m < currentObjectives.Length; m++)
			{
				if (!string.IsNullOrEmpty(currentObjectives[m].text) && !ObjArrayContains(currentObjectives[m].text, previousObjectives))
				{
					UIObjective freeDisplayObjective = GetFreeDisplayObjective();
					freeDisplayObjective.displayedAtIndex = m;
					freeDisplayObjective.objectiveTextNext = currentObjectives[m].text;
					freeDisplayObjective.willPulse = currentObjectives[m].pulse;
					waitForChildren3 &= Routine.Start(freeDisplayObjective.fadeIn);
				}
			}
			yield return waitForChildren3;
			for (int n = 0; n < previousObjectives.Length; n++)
			{
				previousObjectives[n].text = currentObjectives[n].text;
				previousObjectives[n].pulse = currentObjectives[n].pulse;
			}
			yield return Wait.UntilNextUpdate();
		}
	}
}
public class UIOculusDemo : UIContainer
{
	private StoreDatabase missionStoreDatabase;

	private StoreInstance missionStore;

	private const float fadeDur = 0.3f;

	private Transform root;

	private UIContainer missionMenu;

	private UIContainer restartPrompt;

	private UIContainer currMenu;

	private UIImage backdrop;

	private UIButton nextLevel;

	private UIButton shop;

	private string currMission;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		currMenu = (missionMenu = GetContainer("Mission Menu"));
		restartPrompt = GetContainer("Failure Prompt");
		backdrop = GetElement<UIImage>("Backdrop");
		missionStoreDatabase = AEResources.LoadFirstResource<StoreDatabase>("Store/Store_Swag_Store");
		missionStore = new StoreInstance(missionStoreDatabase);
		UIButton element = currMenu.GetElement<UIButton>("Back");
		element.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		Func<object, bool> value = delegate(object button)
		{
			MissionSceneMeta sceneMetaFromResourcePath = LR.Inst.GetSceneMetaFromResourcePath<MissionSceneMeta>("SceneMetas/" + ((UIButton)button).name);
			Singleton<UIFlow>.Inst.StartMissionBriefToMissionLoadout(sceneMetaFromResourcePath);
			return true;
		};
		UIButton[] componentsInChildren = missionMenu.GetComponentsInChildren<UIButton>();
		foreach (UIButton uIButton in componentsInChildren)
		{
			if (!(uIButton == nextLevel) && !(uIButton == element))
			{
				uIButton.OnTapUpWithUserData += value;
				uIButton.userData = uIButton;
			}
		}
		restartPrompt.GetElement<UIButton>("Select Another").OnTapUp += delegate
		{
			currMission = null;
			restartPrompt.HideAll();
			missionMenu.ShowAll();
			return true;
		};
	}

	private void ShopOpen_OnTapUp()
	{
		Singleton<UIC>.Inst.Push<UIStoreFront>().SetState(missionStore);
	}

	public override void ShowAll()
	{
		isShown = true;
		backdrop.Show();
		(currMenu = missionMenu).ShowAll();
		OnBecameVisible();
	}
}
public class UIOptionsMenu : UIContainer
{
	public struct UISoundSlider
	{
		public UIImage imageSelector;

		public UIImage imageSelectedPip;

		public UIButton buttonLeftArrow;

		public UIButton buttonRightArrow;

		public UIButton buttonPip1;

		public UIButton buttonPip2;

		public UIButton buttonPip3;

		public UIButton buttonPip4;

		public UIButton buttonPip5;
	}

	private UITextbox textboxLanguage;

	private UITextbox textboxLanguageHighlight;

	private UITextbox textboxApplyLanguage;

	private UITextbox textboxSubtitlesOn;

	private UITextbox textboxSubtitlesOnHighlight;

	private UITextbox textboxSubtitlesOff;

	private UITextbox textboxSubtitlesOffHighlight;

	private UIButton buttonLanguageLeft;

	private UIButton buttonLanguageRight;

	private UIButton buttonApplyLanguage;

	private UIButton buttonSubtitlesOn;

	private UIButton buttonSubtitlesOff;

	private UIButton buttonDeleteSaveData;

	private UIButton buttonDeleteYes;

	private UIButton buttonDeleteNo;

	private UIButton buttonExit;

	private UIButton buttonBack;

	private UIImage imageApplySmall;

	private UIImage imageApplyLarge;

	private UIContainer deleteConfirmDialog;

	private UISoundSlider sliderMusic;

	private UISoundSlider sliderDialogue;

	private UISoundSlider sliderSFX;

	private Localisation.Language language;

	private Localisation.Language? _activeLanguage;

	private Vector3 startSelectorPos = new Vector3(0.175f, -0.00125f, 0f);

	private Vector3 startPipPos = new Vector3(0.175f, -1f / 160f, 0f);

	private float pipSeparateX = 0.04f;

	private bool cameFromPauseMenu;

	private Localisation.Language ActiveLanguage
	{
		get
		{
			if (!_activeLanguage.HasValue)
			{
				int @int = PlayerPrefs.GetInt("Language", 0);
				_activeLanguage = (Localisation.Language)@int;
			}
			return _activeLanguage.Value;
		}
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textboxLanguage = GetElement<UITextbox>("LanguageText");
		textboxLanguageHighlight = GetElement<UITextbox>("LanguageTextChanged");
		buttonLanguageLeft = GetElement<UIButton>("LanguageChangeLeft");
		buttonLanguageLeft.OnTapUpWithUserData += ButtonLanguageChange_OnTapUpWithUserData;
		buttonLanguageLeft.userData = -1;
		buttonLanguageRight = GetElement<UIButton>("LanguageChangeRight");
		buttonLanguageRight.OnTapUpWithUserData += ButtonLanguageChange_OnTapUpWithUserData;
		buttonLanguageRight.userData = 1;
		buttonApplyLanguage = GetElement<UIButton>("ApplyButton");
		buttonApplyLanguage.OnTapUp += ButtonApplyLanguage_OnTapUp;
		imageApplySmall = GetElement<UIImage>("ApplyImage");
		imageApplyLarge = GetElement<UIImage>("ApplyImageLarge");
		textboxApplyLanguage = GetElement<UITextbox>("ApplyText");
		buttonSubtitlesOn = GetElement<UIButton>("SubtitlesOnButton");
		buttonSubtitlesOn.OnTapUpWithUserData += ButtonSubtitlesSwitch_OnTapUpWithUserData;
		buttonSubtitlesOn.userData = true;
		textboxSubtitlesOn = GetElement<UITextbox>("SubtitlesOnText");
		textboxSubtitlesOnHighlight = GetElement<UITextbox>("SubtitlesOnTextSelected");
		buttonSubtitlesOff = GetElement<UIButton>("SubtitlesOffButton");
		buttonSubtitlesOff.OnTapUpWithUserData += ButtonSubtitlesSwitch_OnTapUpWithUserData;
		buttonSubtitlesOff.userData = false;
		textboxSubtitlesOff = GetElement<UITextbox>("SubtitlesOffText");
		textboxSubtitlesOffHighlight = GetElement<UITextbox>("SubtitlesOffTextSelected");
		buttonDeleteSaveData = GetElement<UIButton>("DeleteSaveData");
		buttonDeleteSaveData.OnTapUp += ButtonDeleteSaveData_OnTapUp;
		deleteConfirmDialog = GetContainer("DeleteConfirmDialog");
		buttonDeleteYes = deleteConfirmDialog.GetElement<UIButton>("Yes");
		buttonDeleteYes.OnTapUp += ButtonDeleteYes_OnTapUp;
		buttonDeleteNo = deleteConfirmDialog.GetElement<UIButton>("No");
		buttonDeleteNo.OnTapUp += ButtonDeleteNo_OnTapUp;
		UIContainer container = GetContainer("MusicSlider");
		sliderMusic = default(UISoundSlider);
		sliderMusic.buttonLeftArrow = container.GetElement<UIButton>("LeftArrow");
		sliderMusic.buttonLeftArrow.OnTapUpWithUserData += ButtonMusicSlider_OnTapUpWithUserData;
		sliderMusic.buttonLeftArrow.userData = -1;
		sliderMusic.buttonRightArrow = container.GetElement<UIButton>("RightArrow");
		sliderMusic.buttonRightArrow.OnTapUpWithUserData += ButtonMusicSlider_OnTapUpWithUserData;
		sliderMusic.buttonRightArrow.userData = 1;
		sliderMusic.imageSelector = container.GetElement<UIImage>("Selector");
		sliderMusic.imageSelectedPip = container.GetElement<UIImage>("SelectedPip");
		sliderMusic.buttonPip1 = container.GetElement<UIButton>("Pip1");
		sliderMusic.buttonPip1.OnTapUpWithUserData += ButtonMusicPip_OnTapUpWithUserData;
		sliderMusic.buttonPip1.userData = 0;
		sliderMusic.buttonPip2 = container.GetElement<UIButton>("Pip2");
		sliderMusic.buttonPip2.OnTapUpWithUserData += ButtonMusicPip_OnTapUpWithUserData;
		sliderMusic.buttonPip2.userData = 1;
		sliderMusic.buttonPip3 = container.GetElement<UIButton>("Pip3");
		sliderMusic.buttonPip3.OnTapUpWithUserData += ButtonMusicPip_OnTapUpWithUserData;
		sliderMusic.buttonPip3.userData = 2;
		sliderMusic.buttonPip4 = container.GetElement<UIButton>("Pip4");
		sliderMusic.buttonPip4.OnTapUpWithUserData += ButtonMusicPip_OnTapUpWithUserData;
		sliderMusic.buttonPip4.userData = 3;
		sliderMusic.buttonPip5 = container.GetElement<UIButton>("Pip5");
		sliderMusic.buttonPip5.OnTapUpWithUserData += ButtonMusicPip_OnTapUpWithUserData;
		sliderMusic.buttonPip5.userData = 4;
		UIContainer container2 = GetContainer("DialogueSlider");
		sliderDialogue = default(UISoundSlider);
		sliderDialogue.buttonLeftArrow = container2.GetElement<UIButton>("LeftArrow");
		sliderDialogue.buttonLeftArrow.OnTapUpWithUserData += ButtonDialogueSlider_OnTapUpWithUserData;
		sliderDialogue.buttonLeftArrow.userData = -1;
		sliderDialogue.buttonRightArrow = container2.GetElement<UIButton>("RightArrow");
		sliderDialogue.buttonRightArrow.OnTapUpWithUserData += ButtonDialogueSlider_OnTapUpWithUserData;
		sliderDialogue.buttonRightArrow.userData = 1;
		sliderDialogue.imageSelector = container2.GetElement<UIImage>("Selector");
		sliderDialogue.imageSelectedPip = container2.GetElement<UIImage>("SelectedPip");
		sliderDialogue.buttonPip1 = container2.GetElement<UIButton>("Pip1");
		sliderDialogue.buttonPip1.OnTapUpWithUserData += ButtonDialoguePip_OnTapUpWithUserData;
		sliderDialogue.buttonPip1.userData = 0;
		sliderDialogue.buttonPip2 = container2.GetElement<UIButton>("Pip2");
		sliderDialogue.buttonPip2.OnTapUpWithUserData += ButtonDialoguePip_OnTapUpWithUserData;
		sliderDialogue.buttonPip2.userData = 1;
		sliderDialogue.buttonPip3 = container2.GetElement<UIButton>("Pip3");
		sliderDialogue.buttonPip3.OnTapUpWithUserData += ButtonDialoguePip_OnTapUpWithUserData;
		sliderDialogue.buttonPip3.userData = 2;
		sliderDialogue.buttonPip4 = container2.GetElement<UIButton>("Pip4");
		sliderDialogue.buttonPip4.OnTapUpWithUserData += ButtonDialoguePip_OnTapUpWithUserData;
		sliderDialogue.buttonPip4.userData = 3;
		sliderDialogue.buttonPip5 = container2.GetElement<UIButton>("Pip5");
		sliderDialogue.buttonPip5.OnTapUpWithUserData += ButtonDialoguePip_OnTapUpWithUserData;
		sliderDialogue.buttonPip5.userData = 4;
		UIContainer container3 = GetContainer("SFXSlider");
		sliderSFX = default(UISoundSlider);
		sliderSFX.buttonLeftArrow = container3.GetElement<UIButton>("LeftArrow");
		sliderSFX.buttonLeftArrow.OnTapUpWithUserData += ButtonSFXSlider_OnTapUpWithUserData;
		sliderSFX.buttonLeftArrow.userData = -1;
		sliderSFX.buttonRightArrow = container3.GetElement<UIButton>("RightArrow");
		sliderSFX.buttonRightArrow.OnTapUpWithUserData += ButtonSFXSlider_OnTapUpWithUserData;
		sliderSFX.buttonRightArrow.userData = 1;
		sliderSFX.imageSelector = container3.GetElement<UIImage>("Selector");
		sliderSFX.imageSelectedPip = container3.GetElement<UIImage>("SelectedPip");
		sliderSFX.buttonPip1 = container3.GetElement<UIButton>("Pip1");
		sliderSFX.buttonPip1.OnTapUpWithUserData += ButtonSFXPip_OnTapUpWithUserData;
		sliderSFX.buttonPip1.userData = 0;
		sliderSFX.buttonPip2 = container3.GetElement<UIButton>("Pip2");
		sliderSFX.buttonPip2.OnTapUpWithUserData += ButtonSFXPip_OnTapUpWithUserData;
		sliderSFX.buttonPip2.userData = 1;
		sliderSFX.buttonPip3 = container3.GetElement<UIButton>("Pip3");
		sliderSFX.buttonPip3.OnTapUpWithUserData += ButtonSFXPip_OnTapUpWithUserData;
		sliderSFX.buttonPip3.userData = 2;
		sliderSFX.buttonPip4 = container3.GetElement<UIButton>("Pip4");
		sliderSFX.buttonPip4.OnTapUpWithUserData += ButtonSFXPip_OnTapUpWithUserData;
		sliderSFX.buttonPip4.userData = 3;
		sliderSFX.buttonPip5 = container3.GetElement<UIButton>("Pip5");
		sliderSFX.buttonPip5.OnTapUpWithUserData += ButtonSFXPip_OnTapUpWithUserData;
		sliderSFX.buttonPip5.userData = 4;
		buttonExit = GetElement<UIButton>("ExitButton");
		buttonExit.OnTapUp += ButtonExit_OnTapUp;
		buttonBack = GetElement<UIButton>("BackButton");
		buttonBack.OnTapUp += ButtonBack_OnTapUp;
	}

	private bool ButtonLanguageChange_OnTapUpWithUserData(object direction)
	{
		int num = (int)direction;
		int num2 = (int)(language + num);
		if (num2 < 0)
		{
			num2 = 5;
		}
		else if (num2 >= 6)
		{
			num2 = 0;
		}
		language = (Localisation.Language)num2;
		if (language == ActiveLanguage)
		{
			textboxLanguage.Show();
			textboxLanguageHighlight.Hide();
			buttonApplyLanguage.Hide();
		}
		else
		{
			textboxLanguage.Hide();
			textboxLanguageHighlight.SetText(Localisation.RetrieveSpecific("UIOPTIONSMENU_LANGUAGE", language));
			textboxLanguageHighlight.Show();
			string text = Localisation.RetrieveSpecific("UIOPTIONSMENU_LANGUAGE_APPLY", language);
			textboxApplyLanguage.SetText(text);
			buttonApplyLanguage.Show();
			imageApplySmall.IsShown = text.Length <= 6;
			imageApplyLarge.IsShown = text.Length > 6;
		}
		Localisation.SetLocalisedFont(textboxLanguageHighlight, language);
		Localisation.SetLocalisedFont(textboxApplyLanguage, language);
		return true;
	}

	private bool ButtonApplyLanguage_OnTapUp()
	{
		_activeLanguage = language;
		buttonApplyLanguage.Hide();
		textboxLanguageHighlight.Hide();
		textboxLanguage.Show();
		Localisation.Instance.ChangeLanguage(ActiveLanguage);
		return true;
	}

	private bool ButtonSubtitlesSwitch_OnTapUpWithUserData(object subtitles)
	{
		bool flag = (bool)subtitles;
		if (flag)
		{
			textboxSubtitlesOffHighlight.Hide();
			textboxSubtitlesOn.Hide();
			textboxSubtitlesOnHighlight.Show();
			textboxSubtitlesOff.Show();
		}
		else
		{
			textboxSubtitlesOnHighlight.Hide();
			textboxSubtitlesOff.Hide();
			textboxSubtitlesOffHighlight.Show();
			textboxSubtitlesOn.Show();
		}
		UIAmbientSubtitles.Inst.ShowSubtitles = flag;
		return true;
	}

	private bool ButtonDeleteSaveData_OnTapUp()
	{
		SetInteractable(interactable: false);
		deleteConfirmDialog.SetInteractable(interactable: true);
		deleteConfirmDialog.ShowAll();
		return true;
	}

	private bool ButtonDeleteYes_OnTapUp()
	{
		SetInteractable(interactable: true);
		deleteConfirmDialog.HideAll();
		SaveData.ClearDataAndRestart();
		return true;
	}

	private bool ButtonDeleteNo_OnTapUp()
	{
		SetInteractable(interactable: true);
		deleteConfirmDialog.HideAll();
		return true;
	}

	private bool ButtonMusicSlider_OnTapUpWithUserData(object direction)
	{
		int num = (int)direction;
		int musicIndex = VolumeLevels.Inst.MusicIndex;
		if ((num == -1 && musicIndex > 0) || (num == 1 && musicIndex < 4))
		{
			VolumeLevels.Inst.MusicIndex += num;
			UpdateMusicSlider();
		}
		return true;
	}

	private bool ButtonMusicPip_OnTapUpWithUserData(object pipIndex)
	{
		VolumeLevels.Inst.MusicIndex = (int)pipIndex;
		UpdateMusicSlider();
		return true;
	}

	private bool ButtonDialogueSlider_OnTapUpWithUserData(object direction)
	{
		int num = (int)direction;
		int dialogueIndex = VolumeLevels.Inst.DialogueIndex;
		if ((num == -1 && dialogueIndex > 0) || (num == 1 && dialogueIndex < 4))
		{
			VolumeLevels.Inst.DialogueIndex += num;
			UpdateDialogueSlider();
		}
		return true;
	}

	private bool ButtonDialoguePip_OnTapUpWithUserData(object pipIndex)
	{
		VolumeLevels.Inst.DialogueIndex = (int)pipIndex;
		UpdateDialogueSlider();
		return true;
	}

	private bool ButtonSFXSlider_OnTapUpWithUserData(object direction)
	{
		int num = (int)direction;
		int sFXIndex = VolumeLevels.Inst.SFXIndex;
		if ((num == -1 && sFXIndex > 0) || (num == 1 && sFXIndex < 4))
		{
			VolumeLevels.Inst.SFXIndex += num;
			UpdateSFXSlider();
		}
		return true;
	}

	private bool ButtonSFXPip_OnTapUpWithUserData(object pipIndex)
	{
		VolumeLevels.Inst.SFXIndex = (int)pipIndex;
		UpdateSFXSlider();
		return true;
	}

	private bool ButtonExit_OnTapUp()
	{
		LR.Inst.SetPauseState(paused: false);
		Singleton<UIC>.Inst.Pop();
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	private bool ButtonBack_OnTapUp()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	public void SetStateForOptionsMenu(bool fromPauseMenu)
	{
		cameFromPauseMenu = fromPauseMenu;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		language = ActiveLanguage;
		textboxLanguage.SetKey("UIOPTIONSMENU_LANGUAGE");
		textboxLanguageHighlight.SetKey("UIOPTIONSMENU_LANGUAGE");
		textboxLanguageHighlight.Hide();
		buttonApplyLanguage.Hide();
		if (UIAmbientSubtitles.Inst.ShowSubtitles)
		{
			textboxSubtitlesOffHighlight.Hide();
			textboxSubtitlesOn.Hide();
		}
		else
		{
			textboxSubtitlesOff.Hide();
			textboxSubtitlesOnHighlight.Hide();
		}
		if (MR.Inst != null)
		{
			buttonDeleteSaveData.Hide();
		}
		deleteConfirmDialog.HideAll();
		UpdateMusicSlider();
		UpdateDialogueSlider();
		UpdateSFXSlider();
		if (!cameFromPauseMenu)
		{
			buttonExit.Hide();
		}
	}

	public override bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	private void UpdateMusicSlider()
	{
		int musicIndex = VolumeLevels.Inst.MusicIndex;
		sliderMusic.imageSelector.transform.localPosition = startSelectorPos + Vector3.right * pipSeparateX * musicIndex;
		sliderMusic.imageSelectedPip.transform.localPosition = startPipPos + Vector3.right * pipSeparateX * musicIndex;
	}

	private void UpdateDialogueSlider()
	{
		int dialogueIndex = VolumeLevels.Inst.DialogueIndex;
		sliderDialogue.imageSelector.transform.localPosition = startSelectorPos + Vector3.right * pipSeparateX * dialogueIndex;
		sliderDialogue.imageSelectedPip.transform.localPosition = startPipPos + Vector3.right * pipSeparateX * dialogueIndex;
	}

	private void UpdateSFXSlider()
	{
		int sFXIndex = VolumeLevels.Inst.SFXIndex;
		sliderSFX.imageSelector.transform.localPosition = startSelectorPos + Vector3.right * pipSeparateX * sFXIndex;
		sliderSFX.imageSelectedPip.transform.localPosition = startPipPos + Vector3.right * pipSeparateX * sFXIndex;
	}
}
public class UIPathEndSingle : UIImage
{
	private AnimFloat animAlpha = new AnimFloat(0f);

	private AnimFloat scale = new AnimFloat(1f);

	private void Update()
	{
		Color color = this.color;
		this.color = new Color(color.r, color.g, color.b, animAlpha.Update());
		base.transform.localScale = Vector3.one * scale.Update();
	}

	public override void Show()
	{
		base.Show();
		animAlpha.Value = 0f;
		animAlpha.AnimateTo(1f, 0.25f);
		Color color = this.color;
		this.color = new Color(color.r, color.g, color.b, 0f);
		scale.Value = 1.4f;
		scale.AnimateTo(1f, 0.25f);
	}

	public override void Hide()
	{
		animAlpha.AnimateTo(0f, 0.25f);
		Color color = this.color;
		this.color = new Color(color.r, color.g, color.b, 1f);
		scale.Value = 1f;
		scale.AnimateTo(1.4f, 0.25f);
		scale.OnComplete = delegate
		{
			base.Hide();
			scale.OnComplete = null;
		};
		this.color = new Color(color.r, color.g, color.b, animAlpha.Update());
	}
}
public class UIPauseMenu : UIContainer
{
	private UIButton buttonSkipTutorial;

	private UIButton resumeButton;

	private UIButton checkpointRestartButton;

	private UIButton missionRestartButton;

	private UIButton optionsButton;

	private UIButton tutorialsButton;

	private UIButton exitMissionButton;

	private UIButton yesRestartCheckpointButton;

	private UIButton noRestartCheckpointButton;

	private UIButton yesRestartMissionButton;

	private UIButton noRestartMissionButton;

	private UIButton yesExitMissionButton;

	private UIButton noExitMissionButton;

	private UIContainer restartCheckpointConfirmDialog;

	private UIContainer restartMissionConfirmDialog;

	private UIContainer exitMissionConfirmDialog;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		resumeButton = GetElement<UIButton>("Resume");
		resumeButton.OnTapUp += delegate
		{
			LR.Inst.SetPauseState(paused: false);
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		checkpointRestartButton = GetElement<UIButton>("CheckpointRestart");
		checkpointRestartButton.OnTapUp += delegate
		{
			restartCheckpointConfirmDialog.ShowAll();
			return true;
		};
		missionRestartButton = GetElement<UIButton>("MissionRestart");
		missionRestartButton.OnTapUp += delegate
		{
			restartMissionConfirmDialog.ShowAll();
			return true;
		};
		optionsButton = GetElement<UIButton>("Options");
		optionsButton.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UIOptionsMenu>().SetStateForOptionsMenu(fromPauseMenu: true);
			return true;
		};
		tutorialsButton = GetElement<UIButton>("Tutorials");
		tutorialsButton.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialMenu>();
			return true;
		};
		exitMissionButton = GetElement<UIButton>("ExitMission");
		exitMissionButton.OnTapUp += delegate
		{
			exitMissionConfirmDialog.ShowAll();
			return true;
		};
		restartCheckpointConfirmDialog = GetContainer("RestartCheckpointConfirmDialog");
		yesRestartCheckpointButton = restartCheckpointConfirmDialog.GetElement<UIButton>("YesRestartCheckpoint");
		yesRestartCheckpointButton.OnTapUp += ButtonYesCheckpointRestart_OnTapUp;
		noRestartCheckpointButton = restartCheckpointConfirmDialog.GetElement<UIButton>("NoRestartCheckpoint");
		noRestartCheckpointButton.OnTapUp += delegate
		{
			restartCheckpointConfirmDialog.HideAll();
			return true;
		};
		restartMissionConfirmDialog = GetContainer("RestartMissionConfirmDialog");
		yesRestartMissionButton = restartMissionConfirmDialog.GetElement<UIButton>("YesRestartMission");
		yesRestartMissionButton.OnTapUp += ButtonYesMissionRestart_OnTapUp;
		noRestartMissionButton = restartMissionConfirmDialog.GetElement<UIButton>("NoRestartMission");
		noRestartMissionButton.OnTapUp += delegate
		{
			restartMissionConfirmDialog.HideAll();
			return true;
		};
		exitMissionConfirmDialog = GetContainer("ExitMissionConfirmDialog");
		yesExitMissionButton = exitMissionConfirmDialog.GetElement<UIButton>("YesExitMission");
		yesExitMissionButton.OnTapUp += ButtonYesExitMission_OnTapUp;
		noExitMissionButton = exitMissionConfirmDialog.GetElement<UIButton>("NoExitMission");
		noExitMissionButton.OnTapUp += delegate
		{
			exitMissionConfirmDialog.HideAll();
			return true;
		};
		buttonSkipTutorial = GetElement<UIButton>("SkipTutorial");
		buttonSkipTutorial.OnTapUp += delegate
		{
			LR.HACK_tutorialMode = false;
			AC.Inst.PlayOneShot2D("event:/sfx/ui/wham bar/miss");
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		restartCheckpointConfirmDialog.HideAll();
		exitMissionConfirmDialog.HideAll();
		restartMissionConfirmDialog.HideAll();
		missionRestartButton.interactable = true;
		buttonSkipTutorial.Hide();
	}

	public override bool OnBackButtonPressed()
	{
		if (restartMissionConfirmDialog.IsShown)
		{
			restartMissionConfirmDialog.HideAll();
		}
		else if (restartCheckpointConfirmDialog.IsShown)
		{
			restartCheckpointConfirmDialog.HideAll();
		}
		else if (exitMissionConfirmDialog.IsShown)
		{
			exitMissionConfirmDialog.HideAll();
		}
		else
		{
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		}
		return true;
	}

	private void Update()
	{
	}

	private bool ButtonYesExitMission_OnTapUp()
	{
		PauseMenuOptionSelected();
		Singleton<UIFlow>.Inst.StartMissionToMainMenu();
		return true;
	}

	private bool ButtonYesCheckpointRestart_OnTapUp()
	{
		PauseMenuOptionSelected();
		Singleton<UIFlow>.Inst.RestartCheckpoint();
		return true;
	}

	private bool ButtonYesMissionRestart_OnTapUp()
	{
		PauseMenuOptionSelected();
		Singleton<UIFlow>.Inst.RestartMission();
		return true;
	}

	private void PauseMenuOptionSelected()
	{
		LR.Inst.SetPauseState(paused: false);
		Singleton<UIC>.Inst.Pop();
		MusicController.Inst.Stop();
		VOController.Inst.VOStop();
	}
}
[RequireComponent(typeof(UIElement))]
public class UIPulse : MonoBehaviour
{
	public float speed;

	private UIElement element;

	private void Start()
	{
		element = GetComponent<UIElement>();
	}

	private void Update()
	{
		if (element.IsShown)
		{
			element.alpha = Mathf.Lerp(0.5f, 1f, Mathf.Sin(Time.time * speed * (float)Math.PI) * 0.5f + 0.5f);
		}
	}
}
public class UIRoomMenu : UIContainer
{
	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton element = GetElement<UIButton>("ButtonResetEverything");
		element.gameObject.SetActive(value: false);
	}

	private void OnButtonResetEverything()
	{
		AECameraFullscreenPass.Inst.OnFadeToColor = OnCameraFadeToBlack;
		AECameraFullscreenPass.Inst.StartFadeToColor(autoFadeBackToClear: false, 0.25f);
	}

	private void OnCameraFadeToBlack()
	{
		SceneManager.LoadSceneAsync(0);
	}
}
public class UIShowHideHighlight : UIElement
{
	public ConstArray<UIImage> images = new ConstArray<UIImage>(8u);

	private HagletResettable animateSelection;

	private float startAlpha;

	private float t;

	private bool _selected;

	public bool Selected
	{
		get
		{
			return _selected;
		}
		set
		{
			if (_selected != value)
			{
				startAlpha = images[0].alpha;
				t = 0f;
				_selected = value;
				if (!animateSelection.running)
				{
					Routine.Start(animateSelection, LR.Host);
				}
			}
		}
	}

	private IEnumerator<HagletYieldTerm> AnimateSelectionRoutine()
	{
		if (images.Length == 0)
		{
			yield break;
		}
		float animTime = 0.075f;
		while (t <= animTime)
		{
			t += Time.deltaTime;
			float progress = t / animTime;
			for (int i = 0; i < images.Length; i++)
			{
				images[i].alpha = ((!Selected) ? (1f - progress) : progress);
			}
			yield return null;
		}
	}

	public void SetAlphaZeroImmediate()
	{
		for (int i = 0; i < images.Length; i++)
		{
			images[i].alpha = 0f;
		}
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		animateSelection = new HagletResettable(AnimateSelectionRoutine(), "Animate Selection UI");
		UIImage[] componentsInChildren = GetComponentsInChildren<UIImage>();
		int i = 0;
		for (int num = componentsInChildren.Length; i < num; i++)
		{
			images.Add(componentsInChildren[i]);
		}
		UIButton component = GetComponent<UIButton>();
		if ((bool)component)
		{
			component.OnFocusEnter += delegate
			{
				Selected = true;
			};
			component.OnFocusExit += delegate
			{
				Selected = false;
			};
		}
	}

	public override void Show()
	{
		base.Show();
		SetAlphaZeroImmediate();
	}
}
public class UISlotChamp : UIContainer
{
	private static UISlotChamp _inst;

	private const int kSegmentCount = 10;

	private const float kSegmentAngle = 36f;

	private const float kSpinSpeed = 360f;

	private const float kRevolutionLimit = 2f;

	private const float kTimeLimit = 2f;

	private const float kTimerFadeTime = 0.35f;

	private int radialCutoffID;

	private UIImage[] imgs_icons = new UIImage[10];

	private UIContainer cont_segments;

	private UIContainer cont_carot;

	private UIContainer cont_timer;

	private UIContainer[] conts_allSegments = new UIContainer[10];

	private UIImage img_background;

	private UIImage img_timer;

	private HagletResettable slotChampRoutine;

	private Vector3 initialCarotPos;

	public HagletTrigger completed = new HagletTrigger(4);

	private ConstArray<Type> abilities = new ConstArray<Type>(10u);

	private Wrapper<Type> abilityPointer;

	private AbilityImplBase abilityCaster;

	private Material timerMat;

	private FMOD.Studio.EventInstance spinLoopSFXHandle;

	public static UISlotChamp Inst => _inst;

	public override void Initialise()
	{
		base.Initialise();
		_inst = this;
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		cont_segments = GetContainer("Segments");
		img_background = cont_segments.GetElement<UIImage>("Background");
		conts_allSegments = cont_segments.GetContainers();
		for (int i = 0; i < 10; i++)
		{
			imgs_icons[i] = conts_allSegments[i].GetElement<UIImage>("Icon");
		}
		cont_carot = GetContainer("Carot");
		cont_timer = GetContainer("Timer");
		img_timer = cont_timer.GetElement<UIImage>("Ticker");
		slotChampRoutine = new HagletResettable(SlotChampRoutine(), "Slot Champ Routine");
		SpriteRenderer spriteRenderer = img_timer.spriteRenderer;
		timerMat = spriteRenderer.material;
		spriteRenderer.color = new Color(1f, 1f, 1f, 1f);
		radialCutoffID = Shader.PropertyToID("_Cutoff");
		LR.PrepareRadialMaterial(timerMat, spriteRenderer.sprite);
	}

	private IEnumerator<HagletYieldTerm> SlotChampRoutine()
	{
		for (int j = 0; j < abilities.Length; j++)
		{
			AbilityMeta abilityMeta = PartyLevelLUT.abilityTypesToMetas[abilities[j]];
			imgs_icons[j].spriteRenderer.sprite = ((!(abilityMeta.SlotChampIcon != null)) ? abilityMeta.Icon : abilityMeta.SlotChampIcon);
			conts_allSegments[j].SetAlpha(0f);
		}
		cont_carot.transform.localRotation = Quaternion.Euler(0f, 0f, (float)UnityEngine.Random.Range(0, 10) * 36f);
		img_background.transform.rotation = cont_carot.transform.rotation;
		cont_timer.SetAlpha(0f);
		cont_carot.SetAlpha(0f);
		cont_segments.SetAlpha(0f);
		yield return Wait.Until(Shown);
		UIC.PositionCombatUIPopup(base.transform);
		timerMat.SetFloat(radialCutoffID, 1f);
		yield return cont_segments.StartFade(1f, 0.5f);
		for (int i = 0; i < conts_allSegments.Length; i++)
		{
			conts_allSegments[i].StartFade(1f, 0.3f);
			yield return Wait.ForSeconds(0.05f);
		}
		yield return cont_timer.StartFade(1f, 0.35f);
		yield return Wait.ForSeconds(0.15f);
		yield return cont_carot.StartFade(1f, 0.5f);
		yield return Wait.ForSeconds(0.5f);
		float t = 2f;
		int index2 = -1;
		spinLoopSFXHandle = AC.Inst.PlayOneShot2D("event:/sfx/ui/slotchamp spin");
		while (!IC.OnActionButtonDown() && t > 0f)
		{
			t -= Time.deltaTime;
			cont_carot.transform.Rotate(0f, 0f, 0f - 360f * Time.deltaTime, Space.Self);
			img_background.transform.rotation = cont_carot.transform.rotation;
			timerMat.SetFloat(radialCutoffID, t / 2f);
			yield return null;
		}
		index2 = GetHighlightedIndex();
		spinLoopSFXHandle.stop(STOP_MODE.IMMEDIATE);
		AC.Inst.PlayOneShot2D("event:/sfx/ui/slotchamp select");
		yield return cont_timer.StartFade(0f, 0.35f);
		abilityPointer.val = abilities[index2];
		abilityPointer = null;
		for (int k = 0; k < conts_allSegments.Length; k++)
		{
			if (k != index2)
			{
				conts_allSegments[k].StartFade(0f, 0.3f);
			}
		}
		yield return Wait.ForSeconds(1f);
		yield return cont_carot.StartFade(0f, 0.2f) & conts_allSegments[index2].StartFade(0f, 0.2f);
		yield return cont_segments.StartFade(0f, 0.2f);
		yield return Singleton<UIC>.Inst.Pop();
		completed.Trigger();
	}

	public void OnPauseUnpause(bool paused)
	{
		if (spinLoopSFXHandle.isValid())
		{
			spinLoopSFXHandle.setPaused(paused);
		}
	}

	private IEnumerator<HagletYieldTerm> FadeInRoutine()
	{
		yield return null;
	}

	private IEnumerator<HagletYieldTerm> FadeOutRoutine()
	{
		yield return null;
	}

	private int GetHighlightedIndex()
	{
		float num = 360f - cont_carot.transform.localRotation.eulerAngles.z;
		return Mathf.RoundToInt(num / 36f).Wrap(10);
	}

	public void Clear()
	{
		abilities.Clear();
	}

	public void AddEffect<T>(int count) where T : AbilityImplBase
	{
		AddEffect(typeof(T), count);
	}

	public void AddEffect(Type abilityType, int count)
	{
		for (int i = 0; i < count; i++)
		{
			abilities.Add(abilityType);
		}
	}

	public HagletEvent ShowSlotChamp(AbilityImplBase caster, Wrapper<Type> abilityPointer)
	{
		this.abilityPointer = abilityPointer;
		abilityCaster = caster;
		abilities._data.Shuffle();
		Singleton<UIC>.Inst.Push<UISlotChamp>();
		if (HagletHost.currHag != null)
		{
			HagletResettable.StartOrReset(slotChampRoutine, MR.Inst.Host);
		}
		return completed;
	}

	public override bool OnBackButtonPressed()
	{
		return false;
	}

	public void OnMissionUnloaded()
	{
		if ((bool)slotChampRoutine.running)
		{
			LR.Host.Pause(slotChampRoutine);
			slotChampRoutine.Reset();
		}
		if (spinLoopSFXHandle.isValid())
		{
			spinLoopSFXHandle.stop(STOP_MODE.IMMEDIATE);
		}
		HideAll();
	}
}
public class UIStatusEffects : UIContainer
{
	private struct StatusIcon
	{
		public UIContainer container;

		public UIButton button;

		public UIImage icon;

		public UITextbox number;

		public StatusEffect statusEffect;
	}

	private static UIStatusEffects _instance;

	private StatusEffects effects = new StatusEffects(32u);

	private Unit target;

	private UIContainer containerMain;

	private UIContainer containerExtraInfo;

	private UIContainer containerBackgrounds;

	private UIImage[] imageBackgrounds;

	private UITextbox textboxCharacterName;

	private UITextbox textboxInfoName;

	private UITextbox textboxInfoDesc;

	private UITextbox textboxInfoCooldown;

	private UIImage imageHighlightIn;

	private UIImage imageHighlightOut;

	private UIImage imageCharacterIcon;

	private UIImage imageInfoIconLarge;

	private UIImage imageInfoTimeClock;

	private UIImage imageInfoTimeInf;

	private UIElement lookAt;

	private HagletResettable transitionToInfoRoutine;

	private HagletResettable transitionToStatusRoutine;

	private static int[] backgroundLUT = new int[9] { 0, 1, 1, 2, 2, 3, 3, 4, 4 };

	private const int numRows = 2;

	private const int numColumns = 4;

	private int lastBackgroundIdxShown = -1;

	private StatusIcon[] icons = new StatusIcon[8];

	public static UIStatusEffects Inst => _instance;

	public override void Initialise()
	{
		base.Initialise();
		Transform transform = base.transform.Find("Main/StatusEffect_0");
		Transform parent = transform.parent;
		Transform transform2 = base.transform.Find("Main/StatusEffectX");
		Transform transform3 = base.transform.Find("Main/StatusEffectY");
		Vector3 localPosition = transform.transform.localPosition;
		Vector3 vector = transform2.localPosition - localPosition;
		Vector3 vector2 = transform3.localPosition - localPosition;
		int num = 0;
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				if (num == 0)
				{
					num++;
					continue;
				}
				Transform transform4 = UnityEngine.Object.Instantiate(transform, parent);
				transform4.name = "StatusEffect_" + num;
				transform4.transform.localPosition = localPosition + vector * i + vector2 * j;
				transform4.transform.localRotation = Quaternion.identity;
				LR.InitialiseUIHierarchy(transform4.transform);
				num++;
			}
		}
	}

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		containerBackgrounds = GetContainer("Backgrounds");
		containerExtraInfo = GetContainer("ExtraInfo");
		UIContainer uIContainer = containerExtraInfo;
		UIButton element = uIContainer.GetElement<UIButton>("Background");
		element.OnTapUp += delegate
		{
			HagletResettable.StartOrReset(transitionToStatusRoutine, LR.Host);
			return true;
		};
		textboxInfoName = uIContainer.GetElement<UITextbox>("TextStatusName");
		textboxInfoDesc = uIContainer.GetElement<UITextbox>("TextStatusDesc");
		textboxInfoCooldown = uIContainer.GetElement<UITextbox>("TextStatusCooldown");
		imageInfoIconLarge = uIContainer.GetElement<UIImage>("IconLarge");
		imageInfoTimeClock = uIContainer.GetElement<UIImage>("TimeClock");
		imageInfoTimeInf = uIContainer.GetElement<UIImage>("TimeInf");
		containerExtraInfo.HideAll();
		containerMain = GetContainer("Main");
		textboxCharacterName = containerMain.GetElement<UITextbox>("Name");
		imageCharacterIcon = containerMain.GetElement<UIImage>("CharacterIcon");
		lookAt = GetElement<UIElement>("LookAt");
		imageHighlightIn = GetElement<UIImage>("StatusHighlightIn");
		imageHighlightOut = GetElement<UIImage>("StatusHighlightOut");
		imageHighlightIn.Hide();
		imageHighlightOut.Hide();
		imageBackgrounds = new UIImage[5]
		{
			containerBackgrounds.GetElement<UIImage>("Background_00"),
			containerBackgrounds.GetElement<UIImage>("Background_01"),
			containerBackgrounds.GetElement<UIImage>("Background_02"),
			containerBackgrounds.GetElement<UIImage>("Background_03"),
			containerBackgrounds.GetElement<UIImage>("Background_04")
		};
		containerBackgrounds.HideAll();
		transitionToInfoRoutine = new HagletResettable(TransitionToInfo());
		transitionToStatusRoutine = new HagletResettable(TransitionToStatus());
		for (int i = 0; i < icons.Length; i++)
		{
			UIContainer container = (icons[i].container = containerMain.GetContainer("StatusEffect_" + i));
			UIButton uIButton = (icons[i].button = container.GetElement<UIButton>("Icon"));
			icons[i].icon = container.GetElement<UIImage>("Icon");
			icons[i].number = container.GetElement<UITextbox>("Number");
			uIButton.OnFocusEnter += delegate
			{
				if (!containerExtraInfo.IsShown)
				{
					imageHighlightIn.Show();
					imageHighlightIn.transform.localPosition = container.transform.localPosition;
					imageHighlightIn.alpha = 0f;
					imageHighlightIn.AlphaAnimate(LR.Host, 1f, 0.25f);
				}
			};
			uIButton.OnFocusExit += delegate
			{
				if (!containerExtraInfo.IsShown)
				{
					imageHighlightIn.Hide();
					imageHighlightOut.Show();
					imageHighlightOut.transform.localPosition = container.transform.localPosition;
					imageHighlightOut.alpha = 1f;
					imageHighlightOut.AlphaAnimate(LR.Host, 0f, 0.25f);
				}
			};
			uIButton.OnTapUpWithUserData += delegate(object userData)
			{
				int num = (int)userData;
				StatusEffect statusEffect = icons[num].statusEffect;
				textboxInfoName.SetKey(statusEffect.meta.displayName);
				textboxInfoDesc.SetKey(statusEffect.meta.description);
				containerExtraInfo.ShowAll();
				containerExtraInfo.SetAlpha(0f);
				imageHighlightIn.alpha = 0f;
				imageHighlightOut.alpha = 0f;
				imageInfoIconLarge.SetImage(statusEffect.meta.iconLarge);
				if (statusEffect.cooldown == int.MaxValue)
				{
					imageInfoTimeClock.Hide();
					imageInfoTimeInf.Show();
					textboxInfoCooldown.SetKey("UISTATUSBAR_INFINITY");
				}
				else
				{
					imageInfoTimeClock.Show();
					imageInfoTimeInf.Hide();
					textboxInfoCooldown.SetNumber(statusEffect.cooldown);
				}
				HagletResettable.StartOrReset(transitionToInfoRoutine, LR.Host);
				return true;
			};
			uIButton.userData = i;
			icons[i].container.HideAll();
		}
	}

	public override void ShowAll()
	{
		if (GC.Inst.GetActiveTeamType() == UnitTeam.Type.Player)
		{
			base.gameObject.SetActive(value: true);
			Refresh();
		}
		else
		{
			HideAll();
		}
	}

	public override bool HideAll()
	{
		base.gameObject.SetActive(value: false);
		return true;
	}

	public void SetTarget(Unit unit)
	{
		if ((bool)unit && unit.teamType == UnitTeam.Type.Player)
		{
			target = unit;
		}
		Refresh();
	}

	private void BackgroundUpdate(int backgroundIdx)
	{
		if (backgroundIdx != lastBackgroundIdxShown || !imageBackgrounds[backgroundIdx].IsShown)
		{
			if (lastBackgroundIdxShown != -1)
			{
				imageBackgrounds[lastBackgroundIdxShown].AlphaAnimate(LR.Host, 0f, 0.2f, hideWhenFinished: true);
			}
			imageBackgrounds[backgroundIdx].Show();
			imageBackgrounds[backgroundIdx].alpha = 0f;
			imageBackgrounds[backgroundIdx].AlphaAnimate(LR.Host, 1f, 0.2f);
			lastBackgroundIdxShown = backgroundIdx;
		}
	}

	private void Update()
	{
		if (containerExtraInfo.IsShown && !transitionToStatusRoutine.running)
		{
			Vector3 normalized = (lookAt.transform.position - IC.Inst.transform.position).normalized;
			Vector3 forward = IC.Inst.transform.forward;
			if (!(Vector3.Dot(normalized, forward) > Mathf.Cos(0.34906584f)))
			{
				HagletResettable.StartOrReset(transitionToStatusRoutine, LR.Host);
			}
		}
	}

	public void Refresh()
	{
		if ((bool)target)
		{
			if (containerExtraInfo.IsShown)
			{
				return;
			}
			containerMain.ShowAll();
			textboxCharacterName.SetKey(target.charData.UIStatusEffectsDisplayName);
			imageCharacterIcon.SetImage(target.charData.GetDialogSprite(DialogExpression.Neutral));
			effects.effects.Clear();
			foreach (AbilityImplBase item in target.abilities.OnUnitAndTeam())
			{
				item.AppendStatusEffects(effects);
			}
			int num = Mathf.Min((int)effects.effects.Length, 8);
			BackgroundUpdate(backgroundLUT[num]);
			for (int i = 0; i < num; i++)
			{
				StatusEffect statusEffect = effects.effects[i];
				icons[i].container.ShowAll();
				icons[i].icon.SetImage(statusEffect.meta.iconSmall);
				icons[i].statusEffect = statusEffect;
				if (statusEffect.cooldown == int.MaxValue)
				{
					icons[i].number.SetKey("UISTATUSBAR_NIL");
				}
				else
				{
					icons[i].number.SetNumber(statusEffect.cooldown);
				}
			}
			for (int j = num; j < icons.Length; j++)
			{
				icons[j].container.HideAll();
			}
		}
		else
		{
			if (lastBackgroundIdxShown != -1)
			{
				imageBackgrounds[lastBackgroundIdxShown].Hide();
			}
			containerMain.HideAll();
		}
	}

	private IEnumerator<HagletYieldTerm> TransitionToInfo()
	{
		containerBackgrounds.StartFade(0f, 0.1f);
		yield return containerMain.StartFade(0f, 0.1f, hideOnComplete: true);
		yield return containerExtraInfo.StartFade(1f, 0.1f);
	}

	private IEnumerator<HagletYieldTerm> TransitionToStatus()
	{
		yield return containerExtraInfo.StartFade(0f, 0.1f, hideOnComplete: true);
		containerBackgrounds.StartFade(1f, 0.1f);
		Refresh();
		yield return containerMain.StartFade(1f, 0.1f);
	}
}
[Serializable]
public class StoreInstance
{
	[SerializeField]
	public StoreDatabase Database { get; private set; }

	[SerializeField]
	public List<ItemStackInstance> StackInstances { get; private set; }

	public int StockNumber => StackInstances.Count;

	public StoreInstance()
	{
	}

	public StoreInstance(StoreDatabase storeData)
	{
		Database = storeData;
		StackInstances = new List<ItemStackInstance>();
		for (int i = 0; i < Database.sellOrder.Length; i++)
		{
			StackInstances.Add(new ItemStackInstance(Database.sellOrder[i].itemMeta, ItemImpl.Instantiate(Database.sellOrder[i].itemMeta.itemImplName)));
			StackInstances[i].count = Database.sellOrder[i].stock;
		}
	}

	public int GetIndexForSellItem(ItemStackMeta itemMeta)
	{
		int num = StackInstances.Count;
		while (--num >= 0)
		{
			if (StackInstances[num].meta == itemMeta)
			{
				return num;
			}
		}
		return 0;
	}

	public ItemStackInstance GetItemStackInst(ItemStackMeta itemMeta)
	{
		int num = StackInstances.Count;
		while (--num >= 0)
		{
			if (StackInstances[num].meta == itemMeta)
			{
				return StackInstances[num];
			}
		}
		return null;
	}

	public int GetNumberOfItemHeld(ItemStackMeta itemMeta)
	{
		int num = StackInstances.Count;
		while (--num >= 0)
		{
			if (StackInstances[num].meta == itemMeta)
			{
				return StackInstances[num].count;
			}
		}
		return 0;
	}
}
public class UIStoreFront : UIContainer
{
	private enum StoreDisplay
	{
		Resources,
		GrenadesTraps
	}

	private static UIStoreFront _instance;

	private StoreInstance _storeInstance;

	private StoreDisplay storeDisplay;

	private UIStoreItem[] itemButtonUIs;

	private UIStoreItem selectedButton;

	private HagletTrigger _storeHid = new HagletTrigger();

	private UIContainer containerDetails;

	private UIContainer containerMainFrame;

	private UIContainer containerWallet;

	private UIContainer containerBackButton;

	private UIButton buttonResources;

	private UIButton buttonGrenadesTraps;

	private UIButton buttonBack;

	private UITextbox textResources;

	private UITextbox textGrenadesTraps;

	private UITextbox textWalletMod;

	private UITextbox textWallet;

	private UITextbox textSelectionName;

	private UITextbox textSelectionDescription;

	private UITextbox textSelectionCost;

	private UITextbox textBack;

	private UIImage imageSelectionIcon;

	private UIImage imageResourcesTab;

	private UIImage imageGrenadesTrapsTab;

	private UIDebugHighlight resourcesHighlight;

	private UIDebugHighlight grenadesTrapsHighlight;

	private StoreDisplay animatingToDisplay;

	private HagletResettable animToDisplayMode;

	private HagletResettable animWalletMod;

	private HagletResettable animShowHideAll;

	private bool showing;

	public static UIStoreFront Inst => _instance;

	public StoreInstance StoreInstance => _storeInstance;

	public override void Initialise()
	{
		Transform[] array = new Transform[4];
		Transform transform = base.transform.FindChild("Root").FindChild("MainFrame").FindChild("ItemAnchors");
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = transform.GetChild(i);
		}
		itemButtonUIs = new UIStoreItem[4];
		UIStoreItem original = AEResources.LoadFirstResource<UIStoreItem>("UI/P_UIStoreItem");
		for (int j = 0; j < itemButtonUIs.Length; j++)
		{
			itemButtonUIs[j] = UnityEngine.Object.Instantiate(original);
			itemButtonUIs[j].transform.parent = array[j];
			itemButtonUIs[j].transform.localPosition = Vector3.zero;
			itemButtonUIs[j].transform.localRotation = Quaternion.identity;
			itemButtonUIs[j].Initialise();
		}
		base.Initialise();
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_instance = this;
		StoreDatabase storeData = AEResources.LoadFirstResource<StoreDatabase>("Store/Store_Swag_Store");
		_storeInstance = new StoreInstance(storeData);
		for (int i = 0; i < itemButtonUIs.Length; i++)
		{
			itemButtonUIs[i].OnAwakeLR();
			UIElement[] componentsInChildren = itemButtonUIs[i].GetComponentsInChildren<UIElement>(includeInactive: true);
			UIElement[] array = componentsInChildren;
			foreach (UIElement uIElement in array)
			{
				uIElement.OnAwakeLR();
			}
			itemButtonUIs[i].ButtonInfo.OnTapUpWithUserData += SetSelectedItem;
			itemButtonUIs[i].ButtonInfo.userData = itemButtonUIs[i];
			itemButtonUIs[i].HideAll();
			itemButtonUIs[i].ButtonBuy.OnTapUpWithUserData += SetSelectedItem;
			itemButtonUIs[i].ButtonBuy.OnTapUpWithUserData += BuyItem;
			itemButtonUIs[i].ButtonBuy.userData = itemButtonUIs[i];
		}
		animToDisplayMode = new HagletResettable(AnimateToDisplayModeRoutine(), "Animate Store between Display Modes");
		animWalletMod = new HagletResettable(AnimateWalletMod(), "Animate Wallet Modifier in Store");
		animShowHideAll = new HagletResettable(AnimateShowHideAll(), "Animate Show All in Store");
		containerDetails = GetContainer("DetailsPanel");
		containerMainFrame = GetContainer("MainFrame");
		containerWallet = GetContainer("Wallet");
		containerBackButton = GetContainer("Btn_BackButton");
		buttonResources = containerMainFrame.GetElement<UIButton>("Btn_Resources");
		resourcesHighlight = containerMainFrame.GetElement<UIDebugHighlight>("Btn_Resources");
		buttonGrenadesTraps = containerMainFrame.GetElement<UIButton>("Btn_GrenadesTraps");
		grenadesTrapsHighlight = containerMainFrame.GetElement<UIDebugHighlight>("Btn_GrenadesTraps");
		textResources = containerMainFrame.GetElement<UITextbox>("Txt_Resources");
		textGrenadesTraps = containerMainFrame.GetElement<UITextbox>("Txt_GrenadesTraps");
		buttonBack = containerBackButton.GetElement<UIButton>("Btn_BackButton");
		buttonBack.OnTapUp += OnBackButtonPressed;
		buttonResources.OnTapUpWithUserData += AnimateToDisplayMode;
		buttonResources.userData = StoreDisplay.Resources;
		buttonGrenadesTraps.OnTapUpWithUserData += AnimateToDisplayMode;
		buttonGrenadesTraps.userData = StoreDisplay.GrenadesTraps;
		textWalletMod = containerWallet.GetElement<UITextbox>("Txt_WalletMod");
		textWallet = containerWallet.GetElement<UITextbox>("Txt_Wallet");
		textSelectionName = containerDetails.GetElement<UITextbox>("SelectedItemName");
		textSelectionDescription = containerDetails.GetElement<UITextbox>("SelectedItemDescription");
		textSelectionCost = containerDetails.GetElement<UITextbox>("SelectedItemCost");
		textBack = containerBackButton.GetElement<UITextbox>("Txt_Back");
		imageSelectionIcon = containerDetails.GetElement<UIImage>("SelectedItemIcon");
		imageResourcesTab = containerMainFrame.GetElement<UIImage>("TabBackgroundLeft");
		imageGrenadesTrapsTab = containerMainFrame.GetElement<UIImage>("TabBackgroundRight");
	}

	public HagletTrigger SetState(StoreInstance storeInstance)
	{
		_storeInstance = storeInstance;
		return _storeHid;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		SellJunk();
		selectedButton = null;
		for (int i = 0; i < itemButtonUIs.Length; i++)
		{
			itemButtonUIs[i].ShowAll();
			itemButtonUIs[i].BuyBgSelected.Hide();
		}
		SetDisplayMode(StoreDisplay.Resources);
		SetSelectedItem(itemButtonUIs[0]);
		UpdateWallet();
		textWalletMod.Hide();
		showing = true;
		if ((bool)animShowHideAll.running)
		{
			animShowHideAll.host.Pause(animShowHideAll);
			animShowHideAll.Reset();
		}
		Routine.Start(animShowHideAll, LR.Host);
		textGrenadesTraps.transform.localScale = new Vector3(1f, 1f, 1f);
		if (!SaveData.data.IsMissionComplete(0, 0))
		{
			textGrenadesTraps.PulseScaleStart(LR.Host);
		}
	}

	public override bool HideAll()
	{
		for (int i = 0; i < itemButtonUIs.Length; i++)
		{
			itemButtonUIs[i].HideAll();
		}
		_storeHid.Trigger();
		showing = false;
		if ((bool)animShowHideAll.running)
		{
			animShowHideAll.host.Pause(animShowHideAll);
			animShowHideAll.Reset();
		}
		Routine.Start(animShowHideAll, LR.Host);
		return true;
	}

	private IEnumerator<HagletYieldTerm> AnimateShowHideAll()
	{
		float animTime = 0.25f;
		float t = 0f;
		while (t < animTime)
		{
			t += Time.deltaTime;
			if (showing)
			{
				SetAlpha(Mathf.Clamp01(t / animTime));
			}
			else
			{
				SetAlpha(1f - Mathf.Clamp01(t / animTime));
			}
			yield return null;
		}
		if (!showing)
		{
			base.HideAll();
		}
	}

	private bool SetSelectedItem(object itemButton)
	{
		selectedButton = (UIStoreItem)itemButton;
		imageSelectionIcon.SetImage(selectedButton.Item.Icon);
		textSelectionName.SetKey(selectedButton.Item.displayName);
		textSelectionDescription.SetKey(selectedButton.Item.descriptionLong);
		textSelectionCost.SetKey("UISTOREFRONT_SELECTION_COST", (int)StoreInstance.Database.GetStoreSellPrice(selectedButton.Item));
		for (int i = 0; i < itemButtonUIs.Length; i++)
		{
			itemButtonUIs[i].BuyBgSelected.Hide();
		}
		selectedButton.BuyBgSelected.Show();
		return true;
	}

	private bool AnimateToDisplayMode(object displayMode)
	{
		StoreDisplay storeDisplay = (StoreDisplay)displayMode;
		if (storeDisplay == this.storeDisplay)
		{
			return true;
		}
		animatingToDisplay = storeDisplay;
		if ((bool)animToDisplayMode.running)
		{
			animToDisplayMode.host.Pause(animToDisplayMode);
			animToDisplayMode.Reset();
		}
		Routine.Start(animToDisplayMode, LR.Host);
		return true;
	}

	private IEnumerator<HagletYieldTerm> AnimateToDisplayModeRoutine()
	{
		float animTime = 0.1f;
		float t2 = 0f;
		Vector3 startPos = Vector3.zero;
		Vector3 endPos = new Vector3(0.036f, 0f, 0f);
		UIImage animInTab2 = null;
		UIImage animOutTab2 = null;
		if (animatingToDisplay == StoreDisplay.GrenadesTraps)
		{
			endPos.x = 0f - endPos.x;
			animInTab2 = imageGrenadesTrapsTab;
			animOutTab2 = imageResourcesTab;
		}
		else
		{
			animInTab2 = imageResourcesTab;
			animOutTab2 = imageGrenadesTrapsTab;
		}
		animInTab2.spriteRenderer.sortingOrder = 2;
		animOutTab2.spriteRenderer.sortingOrder = 1;
		while (t2 < animTime)
		{
			t2 += Time.deltaTime;
			float progress2 = t2 / animTime;
			for (int i = 0; i < itemButtonUIs.Length; i++)
			{
				itemButtonUIs[i].transform.localPosition = Vector3.Lerp(startPos, endPos, progress2);
				itemButtonUIs[i].SetAlpha(1f - progress2);
			}
			if (animatingToDisplay == StoreDisplay.Resources)
			{
				textGrenadesTraps.alpha = Mathf.Lerp(1f, 0.5f, progress2);
				textResources.alpha = Mathf.Lerp(0.5f, 1f, progress2);
			}
			else
			{
				textGrenadesTraps.alpha = Mathf.Lerp(0.5f, 1f, progress2);
				textResources.alpha = Mathf.Lerp(1f, 0.5f, progress2);
			}
			animInTab2.alpha = progress2;
			yield return null;
		}
		SetDisplayMode(animatingToDisplay);
		animInTab2.alpha = 1f;
		animOutTab2.alpha = 0f;
		if (selectedButton != null)
		{
			selectedButton.BuyBgSelected.Hide();
		}
		t2 = 0f;
		float offset = 0.1f;
		while (t2 < animTime + offset * 3f)
		{
			t2 += Time.deltaTime;
			float progress = MathfX.EaseOutCurve(t2 / animTime);
			for (int j = 0; j < itemButtonUIs.Length; j++)
			{
				itemButtonUIs[j].transform.localPosition = Vector3.Lerp(-endPos, startPos, progress);
				itemButtonUIs[j].SetAlpha(progress);
			}
			animOutTab2.alpha = 1f - progress;
			yield return null;
		}
	}

	private void SetDisplayMode(StoreDisplay displayMode)
	{
		storeDisplay = displayMode;
		switch (displayMode)
		{
		case StoreDisplay.Resources:
			FillItemButtonUI(itemButtonUIs[0], Item.Medpack);
			FillItemButtonUI(itemButtonUIs[1], Item.Rejection_Shot);
			FillItemButtonUI(itemButtonUIs[2], Item.Augment);
			FillItemButtonUI(itemButtonUIs[3], Item.Atlantium_Core);
			textGrenadesTraps.alpha = 0.5f;
			textResources.alpha = 1f;
			imageResourcesTab.alpha = 1f;
			imageGrenadesTrapsTab.alpha = 0f;
			break;
		case StoreDisplay.GrenadesTraps:
			FillItemButtonUI(itemButtonUIs[0], Item.Grenade_Frag);
			FillItemButtonUI(itemButtonUIs[1], Item.Grenade_Stun);
			FillItemButtonUI(itemButtonUIs[2], Item.Trap_Frag);
			FillItemButtonUI(itemButtonUIs[3], Item.Trap_Stun);
			textGrenadesTraps.alpha = 1f;
			textResources.alpha = 0.5f;
			imageResourcesTab.alpha = 0f;
			imageGrenadesTrapsTab.alpha = 1f;
			if (textGrenadesTraps.IsPulseScaling)
			{
				textGrenadesTraps.PulseScaleStop();
			}
			break;
		}
		Color color = new Color(0.10980392f, 0.64705884f, 78f / 85f);
		resourcesHighlight.OverrideOriginalColor(color.RepA(textResources.alpha));
		grenadesTrapsHighlight.OverrideOriginalColor(color.RepA(textGrenadesTraps.alpha));
	}

	private void FillItemButtonUI(UIStoreItem itemButtonUI, Item item)
	{
		ItemStackMeta itemStackMeta = item.ToMeta();
		itemButtonUI.FillUI(itemStackMeta, (StoreInstance == null) ? null : StoreInstance.GetItemStackInst(itemStackMeta));
	}

	private bool BuyItem(object itemButtonUncast)
	{
		UIStoreItem uIStoreItem = (UIStoreItem)itemButtonUncast;
		ItemStackMeta item = uIStoreItem.Item;
		ItemStackInstance itemStackInst = StoreInstance.GetItemStackInst(item);
		uint storeSellPrice = StoreInstance.Database.GetStoreSellPrice(item);
		if (Party.Inst.currency < storeSellPrice || Party.Inst.GetItemCount(item) >= item.StorageLimit)
		{
			return true;
		}
		UnityEngine.Debug.Log("Buying a " + item.Name);
		if (item.ItemEnum == Item.Medpack)
		{
			Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.acquiredMedkit, Tutorials.dialogAcquiredMedkit);
		}
		else if (item.ItemEnum == Item.Rejection_Shot)
		{
			Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.boughtRejectionShot, Tutorials.dialogBoughtRejectionShot);
		}
		else if (item.ItemEnum == Item.Atlantium_Core)
		{
			Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.boughtAtlatium, Tutorials.dialogBoughtAtlatium);
		}
		else if (item.ItemEnum == Item.Augment)
		{
			Tutorials.PlayTutorialDialog(ref SaveData.data.tutorials.acquiredAugment, Tutorials.dialogAcquiredAugment);
		}
		Party.Inst.currency -= storeSellPrice;
		Party.Inst.AddItemToInventory(item, 1);
		SetDisplayMode(storeDisplay);
		UpdateWallet();
		textWalletMod.SetKey("UISTOREFRONT_WALLET_MOD", (int)storeSellPrice, numberIsCurrency: true);
		if ((bool)animWalletMod.running)
		{
			animWalletMod.host.Pause(animWalletMod);
			animWalletMod.Reset();
		}
		Routine.Start(animWalletMod, LR.Host);
		return true;
	}

	private IEnumerator<HagletYieldTerm> AnimateWalletMod()
	{
		textWalletMod.Show();
		textWalletMod.transform.localPosition = Vector3.zero;
		textWalletMod.alpha = 1f;
		float animTime = 1f;
		float t = 0f;
		while (t < animTime)
		{
			t += Time.deltaTime;
			float progress = MathfX.EaseOutCurve(t / animTime);
			textWalletMod.transform.localPosition = Vector3.Lerp(Vector3.zero, new Vector3(0f, 0.075f, 0f), progress);
			textWalletMod.alpha = 1f - progress;
			yield return null;
		}
	}

	private void UpdateWallet()
	{
		textWallet.SetKey("UISTOREFRONT_WALLET_TOTAL", (int)Party.Inst.currency, numberIsCurrency: true);
	}

	private void SellJunk()
	{
		List<ItemStackInstance> inventoryItems = Party.Inst.inventoryItems;
		for (int i = 0; i < inventoryItems.Count; i++)
		{
			ItemStackInstance itemStackInstance = inventoryItems[i];
			if (itemStackInstance.meta.category == ItemType.JUNK)
			{
				Party.Inst.currency += (uint)(itemStackInstance.meta.price * itemStackInstance.count);
				itemStackInstance.count = 0;
			}
		}
	}

	public override bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Pop();
		return false;
	}
}
public class UIStoreItem : UIContainer
{
	private readonly Color affordableColor = new Color(0.5882353f, 40f / 51f, 67f / 85f);

	private readonly Color unaffordableColor = new Color(72f / 85f, 18f / 85f, 0.30980393f);

	public UITextbox Name { get; private set; }

	public UIImage Icon { get; private set; }

	public UIImage BuyBgUnselected { get; private set; }

	public UIImage BuyBgSelected { get; private set; }

	public UITextbox Value { get; private set; }

	public UITextbox Quantity { get; private set; }

	public UITextbox TextSoldOut { get; private set; }

	public UITextbox TextUnaffordable { get; private set; }

	public UITextbox TextBuy { get; private set; }

	public UIButton ButtonBuy { get; private set; }

	public UIButton ButtonInfo { get; private set; }

	public ItemStackMeta Item { get; private set; }

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		Icon = GetElement<UIImage>("ItemIcon");
		BuyBgUnselected = GetElement<UIImage>("BackBackgroundUnselected");
		BuyBgSelected = GetElement<UIImage>("BackBackgroundSelected");
		Name = GetElement<UITextbox>("ItemName");
		Value = GetElement<UITextbox>("Txt_WalletMod");
		Quantity = GetElement<UITextbox>("Stock");
		TextBuy = GetElement<UITextbox>("Txt_Buy");
		TextSoldOut = GetElement<UITextbox>("Txt_SoldOut");
		TextUnaffordable = GetElement<UITextbox>("Txt_NotEnoughCash");
		ButtonBuy = GetElement<UIButton>("Btn_Buy");
		ButtonInfo = GetElement<UIButton>("ItemIcon");
		TextBuy.OnAwakeLR();
		TextSoldOut.OnAwakeLR();
		TextUnaffordable.OnAwakeLR();
	}

	public override void ShowAll()
	{
		base.ShowAll();
		TextBuy.SetKey(TextBuy.localisationKey);
		TextSoldOut.SetKey(TextSoldOut.localisationKey);
		TextUnaffordable.SetKey(TextUnaffordable.localisationKey);
	}

	public void FillUI(ItemStackMeta meta, ItemStackInstance inst)
	{
		int num = meta.price;
		if (UIStoreFront.Inst.StoreInstance != null)
		{
			num = (int)UIStoreFront.Inst.StoreInstance.Database.GetStoreSellPrice(meta);
		}
		Item = meta;
		Name.SetKey(meta.displayName);
		Icon.spriteRenderer.sprite = meta.Icon;
		Value.SetKey("UISTOREITEM_COST", num);
		Quantity.SetKey("UISTOREITEM_STOCK", Party.Inst.GetItemCount(meta));
		if (inst != null && Party.Inst.GetItemCount(meta) < meta.StorageLimit)
		{
			if (num <= Party.Inst.currency)
			{
				TextBuy.Show();
				TextSoldOut.Hide();
				TextUnaffordable.Hide();
				ButtonBuy.Show();
			}
			else
			{
				TextBuy.Hide();
				TextSoldOut.Hide();
				TextUnaffordable.Hide();
				ButtonBuy.Hide();
			}
		}
		else
		{
			TextBuy.Hide();
			TextUnaffordable.Hide();
			TextSoldOut.Show();
			ButtonBuy.Show();
		}
		if (num <= Party.Inst.currency)
		{
			Value.color = affordableColor;
		}
		else
		{
			Value.color = unaffordableColor;
		}
	}
}
public class UITableButton : UIButton
{
	private static UITableButton _instance;

	public AnimFloat animPulse = new AnimFloat(0f);

	public AnimFloat animBrightness = new AnimFloat(0f);

	private Color colorOff = new Color(18f / 85f, 18f / 85f, 18f / 85f, 1f);

	private bool isEnabled;

	private bool isPulsing;

	private Collider buttonCollider;

	private MeshRenderer buttonRenderer;

	private CustomMat<MeshRenderer> customMaterial;

	private UIMissionBriefing briefing;

	public static UITableButton Inst => _instance;

	public override void OnAwakeLR()
	{
	}

	private void OnFocusEnterImpl()
	{
	}

	private void OnFocusExitImpl()
	{
	}

	private bool OnTapUpImpl()
	{
		return true;
	}

	public void EnableAndPulse()
	{
	}

	public void Disable()
	{
	}

	private void Update()
	{
	}
}
public class UITelephone : UIContainer
{
	private struct Call
	{
		public string contactName;

		public DialogData dialog;

		public UIButton button;

		public UITextbox text;
	}

	private static UITelephone _instance;

	[NonSerialized]
	public HagletTrigger[] OnCallBegan = new HagletTrigger[3]
	{
		new HagletTrigger(),
		new HagletTrigger(),
		new HagletTrigger()
	};

	[NonSerialized]
	public HagletTrigger[] OnCallComplete = new HagletTrigger[3]
	{
		new HagletTrigger(),
		new HagletTrigger(),
		new HagletTrigger()
	};

	private Transform containerAll;

	private UIButton buttonTelephone;

	private UITextbox textboxHelp;

	private UIButton buttonBackground;

	private UIImage imageBackground;

	private UIImage imageCallIcon;

	private Call[] callers = new Call[3];

	private float presentZ;

	private bool isInCall;

	private uint callIndex;

	private float hideCountdown;

	private const float hideCountdownMax = 0.5f;

	private const float animDur = 0.3f;

	private const float zCourse = 0.12f;

	private const float buttonsStartBrightness = 0.1f;

	private AnimFloat animMenuAlpha = new AnimFloat(0f);

	private AnimFloat animButtonFlash = new AnimFloat(0f);

	private AnimFloat animButtonBrightness = new AnimFloat(0.1f);

	private bool showForInventory;

	private CustomMat<MeshRenderer> buttonsMaterial;

	public static UITelephone Inst => _instance;

	public bool IsInCall => isInCall;

	private void Awake()
	{
		_instance = this;
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		containerAll = base.transform.GetChild(0);
		textboxHelp = GetElement<UITextbox>("Help");
		callers[0].button = GetElement<UIButton>("CallOption0");
		callers[1].button = GetElement<UIButton>("CallOption1");
		callers[2].button = GetElement<UIButton>("CallOption2");
		callers[0].text = GetElement<UITextbox>("CallOption0");
		callers[1].text = GetElement<UITextbox>("CallOption1");
		callers[2].text = GetElement<UITextbox>("CallOption2");
		imageBackground = GetElement<UIImage>("Background");
		buttonBackground = GetElement<UIButton>("Background");
		buttonTelephone = GetElement<UIButton>("TelephoneButton");
		imageCallIcon = GetElement<UIImage>("CallIcon");
		buttonBackground.OnTapUp += Hide;
		callers[0].button.OnTapUp += CallOption0;
		callers[1].button.OnTapUp += CallOption1;
		callers[2].button.OnTapUp += CallOption2;
		callers[0].button.OnFocusStay += ResetHideCountdown;
		callers[1].button.OnFocusStay += ResetHideCountdown;
		callers[2].button.OnFocusStay += ResetHideCountdown;
		buttonBackground.OnFocusStay += ResetHideCountdown;
		buttonTelephone.OnFocusStay += ResetHideCountdown;
		buttonTelephone.allowShowHideCommands = false;
		buttonTelephone.OnFocusEnter += OnTelephoneFocus;
		buttonTelephone.OnFocusStay += Show;
		HideAll();
		base.transform.localPosition = Vector3.zero;
		UITelephoneButtons uITelephoneButtons = LR.Get<UITelephoneButtons>();
		buttonsMaterial = new CustomMat<MeshRenderer>(uITelephoneButtons.GetComponent<MeshRenderer>());
		buttonsMaterial.Enable();
		buttonsMaterial.SetColor(new Color(0.1f, 0.1f, 0.1f, 1f));
		presentZ = containerAll.localPosition.z;
		animMenuAlpha.Interpolate = (float val) => MathfX.SineRemapLerp(val, MathfX.SineRemapEaseType.Out);
	}

	public void Show()
	{
		if (animMenuAlpha.Value != 0f || (GC.Inst != null && (GC.Inst.IsInCutsceneMode() || Singleton<UIC>.Inst.IsShown<UINarrativeDialog>())) || MR.Inst == null)
		{
			return;
		}
		ShowAll();
		textboxHelp.Show();
		buttonBackground.Show();
		int num = callers.Length;
		while (--num > 0)
		{
			if (callers[num].contactName == null)
			{
				callers[num].button.Hide();
			}
		}
		ButtonFlashEnd();
		ResetHideCountdown();
		animMenuAlpha.AnimateTo(1f, 0.3f);
		Update();
	}

	public bool Hide()
	{
		if (animMenuAlpha.Value != 1f)
		{
			return true;
		}
		animMenuAlpha.AnimateTo(0f, 0.3f);
		Update();
		return true;
	}

	private void ResetHideCountdown()
	{
		hideCountdown = 0.5f;
	}

	private void Update()
	{
		float num = animButtonFlash.Update();
		float num2 = animButtonBrightness.Update();
		float num3 = Mathf.Sin(Time.time * 2f * (float)Math.PI) * 0.5f + 1f;
		float num4 = (1f - num3 * 0.5f * num) * num2;
		buttonsMaterial.SetColor(new Color(num4, num4, num4, 1f));
		if ((bool)animMenuAlpha.animating)
		{
			float num5 = animMenuAlpha.Update();
			containerAll.transform.localPosition = containerAll.transform.localPosition.RepZ(presentZ - 0.12f + num5 * 0.12f);
			UITextbox uITextbox = textboxHelp;
			float num6 = num5;
			imageCallIcon.alpha = num6;
			num6 = num6;
			imageBackground.alpha = num6;
			num6 = num6;
			callers[2].text.alpha = num6;
			num6 = num6;
			callers[1].text.alpha = num6;
			num6 = num6;
			callers[0].text.alpha = num6;
			uITextbox.alpha = num6;
			if (!animMenuAlpha.animating && num5 == 0f)
			{
				HideAll();
			}
		}
		else if (showForInventory)
		{
			showForInventory = Singleton<UIC>.Inst.IsShown<UIInventory>();
		}
		else if (animMenuAlpha.Value == 1f && (hideCountdown -= Time.deltaTime) <= 0f)
		{
			Hide();
		}
	}

	private void OnTelephoneFocus()
	{
		if (animMenuAlpha.Value != 1f)
		{
		}
	}

	private void ButtonFlashBegin()
	{
		buttonsMaterial.Enable();
		animButtonFlash.AnimateTo(1f, 0.5f);
		animButtonBrightness.AnimateTo(1f, 0.5f);
	}

	private void ButtonFlashEnd()
	{
		animButtonFlash.AnimateTo(0f, 0.5f);
	}

	public void SetPhoneShouldFlashForAttention(bool shouldFlash)
	{
		if (shouldFlash)
		{
			ButtonFlashBegin();
		}
		else
		{
			ButtonFlashEnd();
		}
	}

	public void SetHelpText(string text)
	{
		textboxHelp.SetText(text);
	}

	private bool CallOption0()
	{
		Singleton<UIC>.Inst.Push<UIInventory>();
		return true;
	}

	private bool CallOption1()
	{
		if (animMenuAlpha.Value != 1f)
		{
			return true;
		}
		OnCallBegan[1].Trigger();
		OnCallBegin(1u);
		return true;
	}

	private bool CallOption2()
	{
		if (animMenuAlpha.Value != 1f)
		{
			return true;
		}
		OnCallBegan[2].Trigger();
		OnCallBegin(2u);
		return true;
	}

	public void OnCallBegin(uint index)
	{
		imageCallIcon.Show();
		VOController.Inst.VOStop();
		textboxHelp.Hide();
		int num = callers.Length;
		while (--num >= 0)
		{
			callers[num].button.Hide();
		}
		callIndex = index;
		SetHelpText("In call...");
		isInCall = true;
	}

	public void OnTelephoneCallComplete()
	{
		OnCallComplete[callIndex].Trigger();
		Hide();
		isInCall = false;
	}

	public void OnRoomShow()
	{
	}

	public void OnRoomHide()
	{
		Hide();
	}
}
public class UITelephoneButtons : MonoBehaviour
{
}
[RequireComponent(typeof(TextMesh))]
public class UITextbox : UIElement, Localisation.IUseLocalisation
{
	private struct LocalisedKeyNum
	{
		public string keyOrString;

		public bool isKey;

		public int? num;
	}

	public Font font;

	public Material fontMaterial;

	public string localisationKey;

	public bool localisedForController;

	public string controllerLocalisationKey;

	public string gamepadLocalisationKey;

	public bool enforceEnglish;

	private ConstArray<LocalisedKeyNum> localisationKeys = new ConstArray<LocalisedKeyNum>(16u);

	private ConstArray<LocalisedKeyNum> tempKeyArray = new ConstArray<LocalisedKeyNum>(16u);

	[TextArea(3, 10)]
	public string text;

	public float wrapWidth = 0.3f;

	public int sortingOrder = -1;

	public bool wordWrap = true;

	public Vector3 colliderSizeOverride = -Vector3.one;

	private MeshRenderer meshRenderer;

	private TextMesh textMesh;

	private BoxCollider boxCollider;

	private const int MAX_STRING_SIZE = 512;

	private static string strInternal;

	private static StringBuilder strBuilder;

	private static UITextbox currentClient;

	public Action OnTextPresented;

	public Action<UITextbox, Vector3> OnTextPresentedWithSize;

	private float _height;

	public float foreignCharSize;

	private float englishCharSize;

	private bool HACK_initalised;

	private static char[] _intToStrBuffer;

	private const string _numberToken = "[NUMBER]";

	private static FieldInfo _stringBuilderFieldInfo;

	public string TextVisible => textMesh.text;

	public TextMesh TextMesh => textMesh;

	public override Color color
	{
		get
		{
			return textMesh.color;
		}
		set
		{
			textMesh.color = value;
		}
	}

	public TextAlignment alignment
	{
		get
		{
			return textMesh.alignment;
		}
		set
		{
			textMesh.alignment = value;
		}
	}

	static UITextbox()
	{
		strBuilder = new StringBuilder(512, 512);
		currentClient = null;
		_intToStrBuffer = new char[10];
		_stringBuilderFieldInfo = typeof(StringBuilder).GetField("_str", BindingFlags.Instance | BindingFlags.NonPublic);
		strInternal = GarbageFreeString(strBuilder);
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textMesh = GetComponent<TextMesh>();
		meshRenderer = GetComponent<MeshRenderer>();
		boxCollider = GetComponent<BoxCollider>();
		englishCharSize = textMesh.characterSize;
		if (Mathf.Approximately(foreignCharSize, 0f))
		{
			foreignCharSize = textMesh.characterSize;
		}
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		if (!string.IsNullOrEmpty(localisationKey))
		{
			obj.keyOrString = localisationKey;
			obj.isKey = true;
			obj.num = null;
		}
		else
		{
			obj.keyOrString = textMesh.text;
			obj.isKey = false;
			obj.num = null;
		}
		localisationKeys.Add(obj);
		if (font != null)
		{
			string fontName = font.name;
			SetFont(Localisation.GetFontByName(fontName), Localisation.GetFontMaterialByName(fontName));
		}
		OnLanguageChanged(Localisation.Instance.CurrentLanguage);
		HACK_initalised = true;
	}

	private void OnEnable()
	{
		Localisation.Instance.AddUsesLocalisation(this);
		if (HACK_initalised)
		{
			OnLanguageChanged(Localisation.Instance.CurrentLanguage);
		}
	}

	private void OnDisable()
	{
		Localisation.Instance.RemoveUsesLocalisation(this);
	}

	public void Clear()
	{
		currentClient = this;
		strBuilder.Length = 0;
		localisationKeys.Clear();
		_height = 0f;
	}

	public void Append(int number)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = string.Empty;
		obj.isKey = false;
		obj.num = number;
		localisationKeys.Add(obj);
		uint number2;
		if (number < 0)
		{
			strBuilder.Append('-');
			number2 = (uint)(-number);
		}
		else
		{
			number2 = (uint)number;
		}
		Append(number2);
	}

	public void Append(uint number)
	{
		uint num = 0u;
		do
		{
			uint num2 = number % 10;
			_intToStrBuffer[num++] = (char)(48 + num2);
			number /= 10;
		}
		while (number != 0);
		while (num != 0)
		{
			strBuilder.Append(_intToStrBuffer[--num]);
		}
	}

	public void Append(string source, int startIndex, int count)
	{
		float num = 0.1f;
		float num2 = 0f;
		float num3 = textMesh.characterSize * num;
		Font font = textMesh.font;
		float num4 = num3 * (float)font.lineHeight;
		int num5 = 0;
		int num6 = startIndex + count;
		if (wordWrap)
		{
			int num7 = startIndex;
			int num8 = startIndex;
			float num9 = 0f;
			for (int i = startIndex; i < num6; i++)
			{
				char c = source[i];
				switch (c)
				{
				case ' ':
				case '\\':
					num7 = i + 1;
					num9 = num2;
					break;
				case '\n':
					strBuilder.Append(source, num8, i - num8);
					num8 = i;
					num7 = i;
					num5++;
					_height += num4;
					num2 = 0f;
					break;
				}
				if (!font.GetCharacterInfo(c, out var info))
				{
					continue;
				}
				float num10 = (float)info.advance * num3;
				num2 += num10;
				if (!(num2 > wrapWidth))
				{
					continue;
				}
				int num11 = num7 - num8;
				float num12 = num2 - num9;
				if (num11 == 0)
				{
					num11 = i - num8;
					num12 = 0f;
					num7 = i;
					if (num11 == 0)
					{
						num11 = 1;
						num7 = i + 1;
					}
					else
					{
						i--;
					}
				}
				strBuilder.Append(source, num8, num11);
				strBuilder.Append("\n");
				num8 += num11;
				num2 = num12;
				num5++;
				_height += num4;
			}
			if (num8 != num6)
			{
				strBuilder.Append(source, num8, num6 - num8);
				_height += num4;
			}
		}
		else
		{
			strBuilder.Append(source, startIndex, count);
		}
	}

	public void Append(string source, bool isKey = false)
	{
		if (!isKey)
		{
			LocalisedKeyNum obj = default(LocalisedKeyNum);
			obj.keyOrString = source;
			obj.isKey = false;
			obj.num = null;
			localisationKeys.Add(obj);
		}
		Append(source, 0, source.Length);
	}

	public Vector3 SetText(string text, bool returnSize = false)
	{
		Clear();
		Append(text, 0, text.Length);
		return Present(returnSize);
	}

	public Vector3 SetNumber(int number, bool returnSize = false)
	{
		Clear();
		Append(number);
		return Present(returnSize);
	}

	public Vector3 SetKey(string key, bool returnSize = false)
	{
		Clear();
		AppendKey(key);
		return Present(returnSize);
	}

	public Vector3 SetKey(string key, int number, bool numberIsCurrency = false, bool returnSize = false)
	{
		Clear();
		AppendKey(key, number, numberIsCurrency);
		return Present(returnSize);
	}

	public void OnLanguageChanged(Localisation.Language newLanguage)
	{
		if (font != null && fontMaterial != null)
		{
			Localisation.SetLocalisedFont(this);
		}
		bool flag = enforceEnglish || newLanguage == Localisation.Language.ENGLISH;
		textMesh.characterSize = ((!flag) ? foreignCharSize : englishCharSize);
		if (localisationKeys.Length == 0)
		{
			return;
		}
		if (localisationKeys.Length == 1)
		{
			LocalisedKeyNum localisedKeyNum = localisationKeys[0];
			if (!localisedKeyNum.isKey)
			{
				if (localisedKeyNum.num.HasValue)
				{
					SetNumber(localisedKeyNum.num.Value);
				}
				else
				{
					SetText(localisedKeyNum.keyOrString);
				}
				return;
			}
			string key = ((!localisedForController || IC.controlInputType == IC.InputType.Touch) ? localisedKeyNum.keyOrString : ((IC.controlInputType != IC.InputType.GearVRController) ? gamepadLocalisationKey : controllerLocalisationKey));
			if (localisedKeyNum.num.HasValue)
			{
				SetKey(key, localisedKeyNum.num.Value);
			}
			else
			{
				SetKey(key);
			}
			return;
		}
		tempKeyArray.Clear();
		for (int i = 0; i < localisationKeys.Length; i++)
		{
			tempKeyArray.Add(localisationKeys[i]);
		}
		Clear();
		for (int j = 0; j < tempKeyArray.Length; j++)
		{
			LocalisedKeyNum localisedKeyNum2 = tempKeyArray[j];
			if (!localisedKeyNum2.isKey)
			{
				if (localisedKeyNum2.num.HasValue)
				{
					Append(localisedKeyNum2.num.Value);
				}
				else
				{
					Append(localisedKeyNum2.keyOrString);
				}
			}
			else if (localisedKeyNum2.num.HasValue)
			{
				AppendKey(localisedKeyNum2.keyOrString, localisedKeyNum2.num.Value);
			}
			else
			{
				AppendKey(localisedKeyNum2.keyOrString);
			}
		}
		Present();
	}

	public void AppendKey(string key)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = key;
		obj.isKey = true;
		obj.num = null;
		localisationKeys.Add(obj);
		string text = Localisation.Retrieve(key);
		Append(text ?? string.Empty, isKey: true);
	}

	public void AppendKey(string key, int number, bool numberIsCurrency = false)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = key;
		obj.isKey = true;
		obj.num = number;
		localisationKeys.Add(obj);
		string text = Localisation.Retrieve(key);
		int num = text.IndexOf("[NUMBER]");
		if (num != -1)
		{
			int num2 = num + "[NUMBER]".Length;
			if (numberIsCurrency && num - 1 >= 0 && number == 0 && text[num - 1] == 'K')
			{
				num--;
			}
			Append(text, 0, num);
			uint number2;
			if (number < 0)
			{
				strBuilder.Append('-');
				number2 = (uint)(-number);
			}
			else
			{
				number2 = (uint)number;
			}
			Append(number2);
			Append(text, num2, text.Length - num2);
		}
		else
		{
			Append(text);
		}
	}

	public override void OnAlphaSet(float alpha)
	{
		textMesh.color = textMesh.color.RepA(alpha);
	}

	public void UpdateSortingOrder()
	{
		meshRenderer.sortingOrder = sortingOrder;
	}

	public Vector3 Present(bool returnSize = false)
	{
		strBuilder.Append("\0");
		try
		{
			textMesh.text = strInternal;
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		UpdateSortingOrder();
		bool flag = boxCollider != null;
		Vector3 vector = ((!returnSize && !flag && OnTextPresentedWithSize == null) ? default(Vector3) : GetSize(textMesh, strInternal));
		if (flag)
		{
			boxCollider.size = vector.RepZ(boxCollider.size.z);
			Vector3 center = default(Vector3);
			switch (textMesh.anchor)
			{
			case TextAnchor.UpperLeft:
			case TextAnchor.MiddleLeft:
			case TextAnchor.LowerLeft:
				center.x = boxCollider.size.x / 2f;
				break;
			case TextAnchor.UpperCenter:
			case TextAnchor.MiddleCenter:
			case TextAnchor.LowerCenter:
				center.x = 0f;
				break;
			case TextAnchor.UpperRight:
			case TextAnchor.MiddleRight:
			case TextAnchor.LowerRight:
				center.x = (0f - boxCollider.size.x) / 2f;
				break;
			}
			switch (textMesh.anchor)
			{
			case TextAnchor.LowerLeft:
			case TextAnchor.LowerCenter:
			case TextAnchor.LowerRight:
				center.y = boxCollider.size.y / 2f;
				break;
			case TextAnchor.MiddleLeft:
			case TextAnchor.MiddleCenter:
			case TextAnchor.MiddleRight:
				center.y = 0f;
				break;
			case TextAnchor.UpperLeft:
			case TextAnchor.UpperCenter:
			case TextAnchor.UpperRight:
				center.y = (0f - boxCollider.size.y) / 2f;
				break;
			}
			boxCollider.center = center;
			boxCollider.size = new Vector3((!(colliderSizeOverride.x >= 0f)) ? boxCollider.size.x : colliderSizeOverride.x, (!(colliderSizeOverride.y >= 0f)) ? boxCollider.size.y : colliderSizeOverride.y, (!(colliderSizeOverride.z >= 0f)) ? boxCollider.size.z : colliderSizeOverride.z);
		}
		if (OnTextPresented != null)
		{
			OnTextPresented();
		}
		if (OnTextPresentedWithSize != null)
		{
			OnTextPresentedWithSize(this, vector);
		}
		currentClient = null;
		return vector;
	}

	private static Vector3 GetSize(TextMesh mesh, string meshText, int overrideFontSize = -1)
	{
		Vector3 result = new Vector3(0f, mesh.font.lineHeight, 0f);
		float num = 0f;
		int i = 0;
		for (int length = meshText.Length; i < length && meshText[i] != 0; i++)
		{
			if (mesh.font.GetCharacterInfo(meshText[i], out var info, (overrideFontSize != -1) ? overrideFontSize : mesh.fontSize, mesh.fontStyle))
			{
				num += (float)info.advance;
			}
			if (meshText[i] == '\n')
			{
				result.x = Mathf.Max(num, result.x);
				result.y += mesh.font.lineHeight;
				num = 0f;
			}
		}
		result.x = Mathf.Max(num, result.x);
		result *= mesh.characterSize * 0.1f;
		result.z = 0.02f;
		return result;
	}

	public static string GarbageFreeString(StringBuilder sb)
	{
		string result = (string)_stringBuilderFieldInfo.GetValue(sb);
		sb.Length = 0;
		for (int i = 0; i < sb.Capacity; i++)
		{
			sb.Append("\0");
		}
		return result;
	}

	public void SetFont(Font font, Material fontMaterial)
	{
		this.font = font;
		this.fontMaterial = fontMaterial;
		if (textMesh != null && meshRenderer != null)
		{
			textMesh.font = font;
			meshRenderer.material = fontMaterial;
		}
	}
}
[ExecuteInEditMode]
public class UITextboxAligner : UIContainer
{
	public enum TextboxAlignment
	{
		Horizontal,
		Vertical
	}

	public TextboxAlignment alignment = TextboxAlignment.Vertical;

	public float padding;

	private UITextbox[] textboxes;

	private Vector3[] textboxSizes;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		textboxes = GetComponentsInChildren<UITextbox>();
		textboxSizes = new Vector3[textboxes.Length];
		for (int i = 0; i < textboxes.Length; i++)
		{
			UITextbox obj = textboxes[i];
			obj.OnTextPresentedWithSize = (Action<UITextbox, Vector3>)Delegate.Combine(obj.OnTextPresentedWithSize, new Action<UITextbox, Vector3>(UpdateAlignments));
		}
	}

	private void UpdateAlignments(UITextbox textbox, Vector3 textboxSize)
	{
		if (textboxes == null || textboxes.Length == 0)
		{
			return;
		}
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < textboxes.Length; i++)
		{
			if (textboxes[i] == textbox)
			{
				ref Vector3 reference = ref textboxSizes[i];
				reference = textboxSize.RepY(textboxSize.y + padding);
			}
			zero += textboxSizes[i];
		}
		switch (alignment)
		{
		case TextboxAlignment.Vertical:
		{
			int num = textboxes.Length;
			float num2 = zero.y + (float)num * padding;
			float num3 = num2 / 2f;
			float num4 = num3;
			for (int j = 0; j < num; j++)
			{
				UITextbox uITextbox = textboxes[j];
				Vector3 vector = textboxSizes[j];
				float y = vector.y;
				float num5 = y / 2f;
				uITextbox.transform.localPosition = new Vector3(0f, num4 - num5, 0f);
				num4 -= y;
			}
			break;
		}
		}
	}
}
public class UITextboxPulsing : UITextbox
{
	private Color startColor = Color.white;

	public float pulseSpeed = 2f;

	public bool fadeIn = true;

	public float fadeInTime = 1f;

	private AnimFloat alphaAnim = new AnimFloat();

	private float visibleTime;

	[Range(0f, 1f)]
	public float pulseStrength = 0.35f;

	private bool _pulsingEnabled = true;

	public bool PulsingEnabled
	{
		get
		{
			return _pulsingEnabled;
		}
		set
		{
			_pulsingEnabled = value;
			if (!value)
			{
				color = startColor;
			}
		}
	}

	public bool IsVisible => base.alpha == 1f;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		startColor = color;
	}

	private void OnEnable()
	{
		Present();
		if (fadeIn)
		{
			base.alpha = 0f;
			alphaAnim.Value = 0f;
			alphaAnim.AnimateTo(1f, fadeInTime);
			alphaAnim.OnComplete = delegate
			{
				visibleTime = Time.time;
				base.alpha = 1f;
			};
		}
		else
		{
			alphaAnim.Value = 1f;
		}
	}

	private void LateUpdate()
	{
		if (!IsVisible)
		{
			base.alpha = alphaAnim.Update();
		}
		if (PulsingEnabled)
		{
			float num = (Mathf.Sin((Time.time - visibleTime) * pulseSpeed * (float)Math.PI) + 1f) * 0.5f;
			num *= pulseStrength;
			Color color = startColor * (1f - num);
			this.color = color.RepA(base.alpha);
		}
	}
}
public class UITileHighlight : UIImage
{
	public float scaleMin;

	public float scaleMax = 1f;

	public float alphaMin;

	public float alphaMax = 1f;

	public AnimationCurve scaleCurve;

	private Color startColor;

	private Vector3 startLocalScale;

	private float animTimeMax = 0.35f;

	private float timeStart;

	private float timeTarget;

	private HagletResettable onShowHideRoutine;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		onShowHideRoutine = new HagletResettable(OnShowHideRoutine(), null, HagletStepTime.Update, -1, 3);
		SetState(0f);
	}

	public override void Show()
	{
		base.Show();
		timeStart = 0f;
		timeTarget = 1f;
		HagletResettable.StartOrReset(onShowHideRoutine, LR.Host, prestep: true);
	}

	public override void Hide()
	{
		base.Hide();
		timeStart = 1f;
		timeTarget = 0f;
		HagletResettable.StartOrReset(onShowHideRoutine, LR.Host, prestep: true);
	}

	private IEnumerator<HagletYieldTerm> OnShowHideRoutine()
	{
		float t = 0f;
		while (t < animTimeMax)
		{
			t += Time.deltaTime;
			SetState(Mathf.LerpUnclamped(timeStart, timeTarget, t / animTimeMax));
			yield return null;
		}
	}

	private void SetState(float t)
	{
		color = color.RepA(Mathf.LerpUnclamped(alphaMin, alphaMax, t));
		base.transform.localScale = Vector3.LerpUnclamped(Vector3.one * scaleMin, Vector3.one * scaleMax, scaleCurve.Evaluate(t));
	}
}
public class UITileNoticedStealth : UIImage
{
	private static uint calledThisFrame;

	private AnimFloat animTimer = new AnimFloat();

	private Vector3 endAnimPosition = new Vector3(0f, 2.25f, 0f);

	private Vector3 originPosition = Vector3.zero;

	private Vector3 scale = new Vector3(12f, 12f, 12f);

	public void Update()
	{
		if ((bool)animTimer.animating)
		{
			animTimer.Update();
			color = color.RepA(animTimer.Value);
			base.transform.localPosition = originPosition + endAnimPosition * animTimer.Value;
		}
		calledThisFrame = 0u;
	}

	public override void Show()
	{
		base.Show();
		color = color.RepA(0f);
		animTimer.Value = 0f;
		animTimer.AnimateTo(1f, 0.25f, (float)calledThisFrame * 0.1f + 0.15f);
		originPosition = base.transform.localPosition;
		base.transform.localScale = scale;
		calledThisFrame++;
	}
}
public class UITutorialGroup : UIContainer
{
	public HagletTrigger OnTutorialComplete = new HagletTrigger();

	private UIButton buttonReturn;

	private UIButton buttonPrevious;

	private UIButton buttonNext;

	private UIButton buttonOkay;

	private UIImage imageReturn;

	private UIImage imageReturnHighlight;

	private UITextbox textboxCurrentCounter;

	private UITextbox textboxMaximumCounter;

	private UIContainer container3xPip;

	private UIContainer container6xPip;

	private UIImage imageMainProgressBar;

	private UIImage imageHighlightPip;

	private UIContainer[] slides;

	private readonly Vector3 startProgressPipPosition = new Vector3(-0.055f, 0f, 0f);

	private readonly Vector3 endProgressPipPosition = new Vector3(0.055f, 0f, 0f);

	private readonly Vector3 progressPipDistance6x = new Vector3(0.022f, 0f, 0f);

	private readonly Vector3 okayButtonCentralPos = new Vector3(0f, -0.145f, 0f);

	private readonly Vector3 okayButtonRightPos = new Vector3(0.07f, -0.145f, 0f);

	private readonly Color hoverOff = new Color(13f / 85f, 0.4117647f, 0.8745098f);

	private readonly Color hoverOn = new Color(0.10980392f, 0.64705884f, 78f / 85f);

	private int currentCounter;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		imageReturn = GetElement<UIImage>("ReturnImage");
		imageReturnHighlight = GetElement<UIImage>("ReturnImageHighlight");
		buttonReturn = GetElement<UIButton>("ReturnButton");
		buttonReturn.OnTapUp += delegate
		{
			OnTutorialComplete.Trigger();
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		buttonReturn.OnFocusEnter += delegate
		{
			imageReturnHighlight.Show();
		};
		buttonReturn.OnFocusExit += delegate
		{
			imageReturnHighlight.Hide();
		};
		buttonPrevious = GetElement<UIButton>("PreviousButton");
		buttonPrevious.OnTapUp += delegate
		{
			ChangeSlide(-1);
			return true;
		};
		buttonPrevious.OnFocusEnter += delegate
		{
			buttonPrevious.childTextbox.color = hoverOn;
		};
		buttonPrevious.OnFocusExit += delegate
		{
			buttonPrevious.childTextbox.color = hoverOff;
		};
		buttonNext = GetElement<UIButton>("NextButton");
		buttonNext.OnTapUp += delegate
		{
			ChangeSlide(1);
			return true;
		};
		buttonNext.OnFocusEnter += delegate
		{
			buttonNext.childTextbox.color = hoverOn;
		};
		buttonNext.OnFocusExit += delegate
		{
			buttonNext.childTextbox.color = hoverOff;
		};
		buttonOkay = GetElement<UIButton>("OkayButton");
		buttonOkay.OnTapUp += delegate
		{
			OnTutorialComplete.Trigger();
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		buttonOkay.OnFocusEnter += delegate
		{
			buttonOkay.childTextbox.color = hoverOn;
		};
		buttonOkay.OnFocusExit += delegate
		{
			buttonOkay.childTextbox.color = hoverOff;
		};
		UIContainer container = GetContainer("PageCounter");
		textboxCurrentCounter = container.GetElement<UITextbox>("Current");
		textboxMaximumCounter = container.GetElement<UITextbox>("Maximum");
		UIContainer container2 = GetContainer("ProgressBar");
		container3xPip = container2.GetContainer("3xPip");
		container6xPip = container2.GetContainer("6xPip");
		imageMainProgressBar = container2.GetElement<UIImage>("Main Bar");
		imageHighlightPip = container2.GetElement<UIImage>("HighlightPip");
		UIContainer container3 = GetContainer("Slides");
		slides = container3.GetContainers();
	}

	public override void ShowAll()
	{
		base.ShowAll();
		imageReturnHighlight.Hide();
		currentCounter = 0;
		int num = slides.Length;
		for (int i = 1; i < num; i++)
		{
			slides[i].HideAll();
		}
		buttonPrevious.Hide();
		if (num == 1)
		{
			buttonNext.Hide();
			buttonOkay.Show();
			buttonOkay.transform.localPosition = okayButtonCentralPos;
			container6xPip.HideAll();
			imageMainProgressBar.Hide();
			imageHighlightPip.transform.localPosition = Vector3.zero;
		}
		else
		{
			switch (num)
			{
			case 2:
				container3xPip.HideAll();
				container6xPip.HideAll();
				break;
			case 3:
				container6xPip.HideAll();
				break;
			case 6:
				container3xPip.HideAll();
				break;
			}
			buttonNext.Show();
			buttonOkay.Hide();
			buttonOkay.transform.localPosition = okayButtonRightPos;
			imageHighlightPip.transform.localPosition = startProgressPipPosition;
		}
		textboxCurrentCounter.SetNumber(currentCounter + 1);
		textboxMaximumCounter.SetNumber(num);
	}

	public void ChangeSlide(int direction)
	{
		slides[currentCounter].HideAll();
		currentCounter += direction;
		slides[currentCounter].ShowAll();
		int num = slides.Length;
		buttonPrevious.Show();
		if (currentCounter == num - 1)
		{
			buttonNext.Hide();
			buttonOkay.Show();
		}
		else
		{
			if (currentCounter == 0)
			{
				buttonPrevious.Hide();
			}
			buttonNext.Show();
			buttonOkay.Hide();
		}
		switch (num)
		{
		case 2:
			if (currentCounter == 0)
			{
				imageHighlightPip.transform.localPosition = startProgressPipPosition;
			}
			else
			{
				imageHighlightPip.transform.localPosition = endProgressPipPosition;
			}
			break;
		case 3:
			imageHighlightPip.transform.localPosition = startProgressPipPosition + endProgressPipPosition * currentCounter;
			break;
		case 6:
			imageHighlightPip.transform.localPosition = startProgressPipPosition + progressPipDistance6x * currentCounter;
			break;
		default:
			imageHighlightPip.transform.localPosition = Vector3.zero;
			break;
		}
		textboxCurrentCounter.SetNumber(currentCounter + 1);
	}

	public override bool HideAll()
	{
		base.HideAll();
		return true;
	}

	public override bool OnBackButtonPressed()
	{
		OnTutorialComplete.Trigger();
		Singleton<UIC>.Inst.Pop();
		return true;
	}
}
public class UITutorialMenu : UIContainer
{
	private struct UITutorialMenuItem
	{
		public UIContainer container;

		public UIButton button;

		public UITextbox textboxName;

		public UITextbox textboxNameHighlighted;

		public UIImage imageSidePanel;
	}

	private static UITutorialMenu _instance;

	private UIContainer menuItemsContainer;

	private UIContainer sidePanelContainer;

	private UITutorialMenuItem[] menuItems = new UITutorialMenuItem[7];

	private UIButton buttonBack;

	private UIImage prevShownPanelImage;

	private readonly Color hoverOff = new Color(13f / 85f, 0.4117647f, 0.8745098f);

	private readonly Color hoverOn = new Color(0.10980392f, 0.64705884f, 78f / 85f);

	public static UITutorialMenu Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		menuItemsContainer = GetContainer("MenuItems");
		sidePanelContainer = GetContainer("SidePanel");
		ref UITutorialMenuItem reference = ref menuItems[0];
		reference = GetMenuItem("ActionGauge");
		menuItems[0].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryActionGauge>();
			return true;
		};
		ref UITutorialMenuItem reference2 = ref menuItems[1];
		reference2 = GetMenuItem("CombatBar");
		menuItems[1].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryCombatBar>();
			return true;
		};
		ref UITutorialMenuItem reference3 = ref menuItems[2];
		reference3 = GetMenuItem("AbilityWheel");
		menuItems[2].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryAbilityWheel>();
			return true;
		};
		ref UITutorialMenuItem reference4 = ref menuItems[3];
		reference4 = GetMenuItem("StatusEffects");
		menuItems[3].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryStatusEffects>();
			return true;
		};
		ref UITutorialMenuItem reference5 = ref menuItems[4];
		reference5 = GetMenuItem("ItemsCurrency");
		menuItems[4].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryItemsCurrency>();
			return true;
		};
		ref UITutorialMenuItem reference6 = ref menuItems[5];
		reference6 = GetMenuItem("Augments");
		menuItems[5].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryInstallingAugments>();
			return true;
		};
		ref UITutorialMenuItem reference7 = ref menuItems[6];
		reference7 = GetMenuItem("CursorIcons");
		menuItems[6].button.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Push<UITutorialGroup_GlossaryCursorIcons>();
			return true;
		};
		buttonBack = GetElement<UIButton>("BackButton");
		buttonBack.OnTapUp += delegate
		{
			Singleton<UIC>.Inst.Pop();
			return true;
		};
		buttonBack.OnFocusEnter += delegate
		{
			buttonBack.childTextbox.color = hoverOn;
		};
		buttonBack.OnFocusExit += delegate
		{
			buttonBack.childTextbox.color = hoverOff;
		};
	}

	private UITutorialMenuItem GetMenuItem(string containerName)
	{
		UITutorialMenuItem menuItem = default(UITutorialMenuItem);
		UIContainer uIContainer = (menuItem.container = menuItemsContainer.GetContainer(containerName));
		menuItem.button = uIContainer.GetElement<UIButton>("Button");
		menuItem.textboxName = uIContainer.GetElement<UITextbox>("Text");
		menuItem.textboxNameHighlighted = uIContainer.GetElement<UITextbox>("HighlightedText");
		menuItem.imageSidePanel = sidePanelContainer.GetElement<UIImage>(containerName);
		menuItem.button.OnFocusEnter += delegate
		{
			menuItem.textboxName.Hide();
			menuItem.textboxNameHighlighted.Show();
			if (prevShownPanelImage != null)
			{
				prevShownPanelImage.Hide();
			}
			menuItem.imageSidePanel.Show();
			prevShownPanelImage = menuItem.imageSidePanel;
		};
		menuItem.button.OnFocusExit += delegate
		{
			if (base.IsShown)
			{
				menuItem.textboxName.Show();
				menuItem.textboxNameHighlighted.Hide();
			}
		};
		return menuItem;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		for (int i = 0; i < menuItems.Length; i++)
		{
			menuItems[i].textboxNameHighlighted.Hide();
			menuItems[i].imageSidePanel.Hide();
		}
	}

	public override bool HideAll()
	{
		base.HideAll();
		return true;
	}
}
public class UITutorialPanel : UIContainer
{
	private static UITutorialPanel _instance;

	public static UITutorialPanel Inst => _instance;

	public override void OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
	}

	public override void ShowAll()
	{
		base.ShowAll();
	}

	public override bool HideAll()
	{
		base.HideAll();
		return true;
	}
}
public class UIUnitPopupBar : UIContainer
{
	private struct Message
	{
		public int quantity;

		public string text;

		public Action begunCallback;

		public Action endedCallback;

		public float lingerDur;

		public int? localisationNumber;

		public int? currency;
	}

	private const int queueCap = 4;

	private const float fadeDur = 0.35f;

	private const float lingerTime = 0.35f;

	private const float defaultLingerDur = 0.6f;

	[Serializer.Exclude]
	private UITextbox text;

	[Serializer.Exclude]
	private UIImage shortBackdrop;

	[Serializer.Exclude]
	private UIImage longBackdrop;

	private Queue<Message> queue;

	[Serializer.Exclude]
	private AnimFloat animTime;

	[Serializer.Exclude]
	private Vector3 rootLocalPos;

	[Serializer.Exclude]
	private Color color;

	[Serializer.Exclude]
	private float showY;

	[Serializer.Exclude]
	private float showAlpha;

	[Serializer.Exclude]
	private AnimationCurve yCurve;

	[Serializer.Exclude]
	private AnimationCurve alphaCurve;

	[Serializer.Exclude]
	private Action nextEndedCallback;

	public Func<bool> IsPopUpVisable { get; private set; }

	public bool clear => !text.IsShown;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		IsPopUpVisable = IsAnimating;
		text = GetElement<UITextbox>("Text");
		shortBackdrop = GetElement<UIImage>("Short Backdrop");
		longBackdrop = GetElement<UIImage>("Long Backdrop");
		queue = new Queue<Message>(4);
		animTime = new AnimFloat(0f);
		AnimFloat animFloat = animTime;
		animFloat.OnComplete = (Action)Delegate.Combine(animFloat.OnComplete, new Action(Complete));
		rootLocalPos = base.transform.localPosition;
		color = shortBackdrop.color;
		showY = rootLocalPos.y;
		showAlpha = shortBackdrop.color.a;
		float num = 0.95000005f;
		float time = num + 0.35f;
		yCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.35f, showY), new Keyframe(num, showY), new Keyframe(time, showY * 2f));
		alphaCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.35f, showAlpha), new Keyframe(num, showAlpha), new Keyframe(time, 0f));
		base.HideAll();
		if (queue.Count > 0)
		{
			Begin(queue.Dequeue());
		}
	}

	public override void ShowAll()
	{
	}

	public override bool HideAll()
	{
		return true;
	}

	public void Enqueue(string desc, int quantity = 0, float duration = 0f, Action begunCallback = null, Action endedCallback = null, int? localisationNumber = null, int? currency = null)
	{
		if (!MR.Inst.IsSkipping())
		{
			Message message = default(Message);
			message.text = desc;
			message.quantity = quantity;
			message.begunCallback = begunCallback;
			message.endedCallback = endedCallback;
			message.lingerDur = ((duration == 0f) ? 0.6f : duration);
			message.localisationNumber = localisationNumber;
			message.currency = currency;
			Message message2 = message;
			if ((bool)animTime.animating)
			{
				queue.Enqueue(message2);
				return;
			}
			Begin(message2);
			UpdateDisplay();
		}
	}

	private void Begin(Message message)
	{
		animTime.Value = 0f;
		text.Show();
		text.Clear();
		if (message.quantity > 0)
		{
			text.Append("+");
			text.Append(message.quantity);
		}
		text.Append(" ");
		if (message.localisationNumber.HasValue)
		{
			text.AppendKey(message.text, message.localisationNumber.Value);
		}
		else
		{
			text.AppendKey(message.text);
		}
		if (message.currency.HasValue)
		{
			text.Append(" ");
			text.AppendKey("CURRENCY", message.currency.Value);
		}
		float x = text.Present(returnSize: true).x;
		float num = shortBackdrop.spriteRenderer.sprite.bounds.size.x * shortBackdrop.transform.localScale.x;
		float num2 = num * 0.85f;
		((!(x <= num2)) ? longBackdrop : shortBackdrop).Show();
		float num3 = 0.35f + message.lingerDur;
		float num4 = num3 + 0.35f;
		if (num4 < yCurve[3].time)
		{
			yCurve.MoveKey(2, new Keyframe(num3, showY));
			yCurve.MoveKey(3, new Keyframe(num4, showY * 2f));
			alphaCurve.MoveKey(2, new Keyframe(num3, showAlpha));
			alphaCurve.MoveKey(3, new Keyframe(num4, 0f));
		}
		else if (num4 > yCurve[3].time)
		{
			yCurve.MoveKey(3, new Keyframe(num4, showY * 2f));
			yCurve.MoveKey(2, new Keyframe(num3, showY));
			alphaCurve.MoveKey(3, new Keyframe(num4, 0f));
			alphaCurve.MoveKey(2, new Keyframe(num3, showAlpha));
		}
		animTime.AnimateTo(num4, num4);
		if (message.begunCallback != null)
		{
			message.begunCallback();
		}
		nextEndedCallback = message.endedCallback;
	}

	private void Complete()
	{
		if (nextEndedCallback != null)
		{
			nextEndedCallback();
			nextEndedCallback = null;
		}
		base.HideAll();
		if (queue.Count != 0)
		{
			Begin(queue.Dequeue());
		}
	}

	private void Update()
	{
		animTime.Update();
		if ((bool)animTime.animating)
		{
			UpdateDisplay();
		}
	}

	private void UpdateDisplay()
	{
		rootLocalPos.y = yCurve.Evaluate(animTime.Value);
		color.a = alphaCurve.Evaluate(animTime.Value);
		base.transform.localPosition = rootLocalPos;
		text.color = color;
		shortBackdrop.color = color;
		longBackdrop.color = color;
	}

	public bool IsAnimating()
	{
		return queue.Count > 0 || (bool)animTime.animating;
	}

	public int GetQueueLength()
	{
		return queue.Count;
	}
}
[Serializer.ExcludeAllFields]
public class UIUnitStatusBar : UIContainer
{
	private struct CoverUI
	{
		public UIImage imageFullCover;

		public UIImage imageHalfCover;

		public UIImage imageOpenCover;

		public UIImage imageNoLineOfSight;
	}

	private const string kHealthPipPath = "UI/P_UIHealthPip";

	private const float kMinimisedScale = 1f;

	private const float kMaximisedScale = 1.25f;

	public const int kHPPipsMaxCount = 32;

	public const int kAPPipsCount = 4;

	private bool maximised;

	private Unit unit;

	private UIContainer rootContainer;

	private UIContainer hpContainer;

	private UITextbox textboxName;

	private UIImage imageFrameEnemy;

	private UIImage imageFrameAlly;

	private UIImage imageHPBarEnemyMax;

	private UIImage imageHPBarEnemyMin;

	private UIImage imageHPBarAllyMax;

	private UIImage imageHPBarAllyMin;

	private UIImage imageHPStartPip;

	private UIImage imageFlankedEnemy;

	private UIImage imageFlankedAlly;

	public AnimationCurve criticalHitAlphaCurve;

	public AnimationCurve criticalHitScaleCurve;

	private AnimFloatHaglet criticalHitDriver;

	private UIImage imageCriticalHit;

	private CoverUI coverLarge;

	private CoverUI coverSmall;

	private float hpPipHeight = 0.025f;

	private float hpPipWidth = 0.02f;

	private const int startingHPSize = 10;

	private UIImage imageHPPip;

	private UIImage imageHPPipAlpha;

	private UIImage[] imageAPPips = new UIImage[4];

	private const float kTimeBetweenSizes = 0.75f;

	private float currentHPWidthVal;

	private const float kTargetMaxValue = 1f;

	private const float kTimeBetweenScales = 0.35f;

	public AnimationCurve minMaxCurve;

	private Vector3 initialScale;

	private float currentCurvePos;

	private AnimFloatHaglet maximizeDriver;

	private AnimFloatHaglet minimizeDriver;

	private int currentSpriteOrderJump;

	private int prevUnitHP;

	private int prevUnitAP;

	private bool prevActiveUnit;

	private bool prevMaximised;

	private bool showNoLOSImage;

	private CoverType coverType;

	private int currentDamageDisplay;

	private HagletResettable hpRoutine;

	public bool IsAnimating => maximizeDriver.IsRunning || minimizeDriver.IsRunning;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		maximised = false;
		unit = base.gameObject.GetComponentInAscendant<Unit>();
		rootContainer = GetContainer("StatusRoot");
		textboxName = rootContainer.GetElement<UITextbox>("Name");
		imageFrameEnemy = rootContainer.GetElement<UIImage>("FrameEnemy");
		imageFrameAlly = rootContainer.GetElement<UIImage>("FrameAlly");
		imageCriticalHit = rootContainer.GetElement<UIImage>("CriticalHit");
		criticalHitDriver = new AnimFloatHaglet("Critical Hit Animation", LR.Host, delegate
		{
			imageCriticalHit.alpha = 0f;
			imageCriticalHit.Show();
		}, delegate(float x)
		{
			imageCriticalHit.alpha = criticalHitAlphaCurve.Evaluate(x);
			imageCriticalHit.transform.localScale = Vector3.one * criticalHitScaleCurve.Evaluate(x);
		}, delegate
		{
			imageCriticalHit.alpha = 0f;
			imageCriticalHit.Hide();
		});
		coverLarge = default(CoverUI);
		coverLarge.imageFullCover = rootContainer.GetElement<UIImage>("Full Cover");
		coverLarge.imageHalfCover = rootContainer.GetElement<UIImage>("Half Cover");
		coverLarge.imageOpenCover = rootContainer.GetElement<UIImage>("Open Cover");
		coverLarge.imageNoLineOfSight = rootContainer.GetElement<UIImage>("No Line of Sight");
		coverSmall = default(CoverUI);
		coverSmall.imageFullCover = rootContainer.GetElement<UIImage>("Full Cover Small");
		coverSmall.imageHalfCover = rootContainer.GetElement<UIImage>("Half Cover Small");
		coverSmall.imageOpenCover = rootContainer.GetElement<UIImage>("Open Cover Small");
		coverSmall.imageNoLineOfSight = null;
		imageFlankedEnemy = rootContainer.GetElement<UIImage>("FlankedEnemy");
		imageFlankedAlly = rootContainer.GetElement<UIImage>("FlankedAlly");
		ConstructHPPips();
		imageAPPips[0] = rootContainer.GetElement<UIImage>("AP Pip 1");
		imageAPPips[1] = rootContainer.GetElement<UIImage>("AP Pip 2");
		imageAPPips[2] = rootContainer.GetElement<UIImage>("AP Pip 3");
		imageAPPips[3] = rootContainer.GetElement<UIImage>("AP Pip 4 (Special)");
		initialScale = base.transform.localScale;
		currentCurvePos = 0f;
		maximizeDriver = new AnimFloatHaglet($"Maximise '{unit.charData.DisplayName}' Bar", LR.Host, delegate
		{
		}, delegate(float x)
		{
			currentCurvePos = x;
			UpdateMinMaxAnimation(currentCurvePos, maximising: true);
		}, delegate
		{
			currentCurvePos = 1f;
		});
		minimizeDriver = new AnimFloatHaglet($"Minimise '{unit.charData.DisplayName}' Bar", LR.Host, delegate
		{
		}, delegate(float x)
		{
			currentCurvePos = x;
			UpdateMinMaxAnimation(currentCurvePos, maximising: false);
		}, delegate
		{
			currentCurvePos = 0f;
		});
		SetTeamColor(unit.GetTeamIndex());
		hpRoutine = new HagletResettable(HPAnimPulseControl(), unit.charData.name + " HP Animation", HagletStepTime.Update, -1, 1, null, showInStackTrace: false);
		HideAll();
	}

	public void ConstructHPPips()
	{
		hpContainer = rootContainer.GetContainer("HPs");
		imageHPBarEnemyMax = hpContainer.GetElement<UIImage>("HP Bar Enemy Max");
		imageHPBarEnemyMin = hpContainer.GetElement<UIImage>("HP Bar Enemy Min");
		imageHPBarAllyMax = hpContainer.GetElement<UIImage>("HP Bar Ally Max");
		imageHPBarAllyMin = hpContainer.GetElement<UIImage>("HP Bar Ally Min");
		imageHPStartPip = hpContainer.GetElement<UIImage>("HP Start Pip");
		int hPMax = unit.GetHPMax();
		UIElement element = hpContainer.GetElement<UIElement>("HP Anchor");
		UIImage uIImage = (imageHPPip = hpContainer.GetElement<UIImage>("P_UIHealthPip"));
		uIImage.OnAwakeLR();
		uIImage.spriteRenderer.sortingOrder = imageHPStartPip.spriteRenderer.sortingOrder;
		imageHPPipAlpha = hpContainer.GetElement<UIImage>("P_UIHealthPipAlpha");
		imageHPPipAlpha.OnAwakeLR();
		imageHPPipAlpha.spriteRenderer.sortingOrder = imageHPStartPip.spriteRenderer.sortingOrder;
		Vector3 vector = new Vector3(1.06f, 1f, 1f);
		Vector2 vector2 = new Vector2(0.255f, 0.025f);
		Vector3 localScale = new Vector3(vector.x * (10f / (float)unit.GetHPMax()), vector.y, vector.z);
		uIImage.transform.localScale = localScale;
		imageHPPipAlpha.transform.localScale = localScale;
		Vector2 vector3 = new Vector2(vector.x / localScale.x * vector2.x, vector2.y);
		hpPipWidth = vector3.x / (float)unit.GetHPMax();
		hpPipHeight = vector3.y;
		ReconstructAllOrderedElementLists();
	}

	public override bool HideAll()
	{
		UpdateDisplay(immediate: true);
		minimizeDriver.Stop();
		maximizeDriver.Stop();
		if ((bool)hpRoutine.running)
		{
			imageHPPip.spriteRenderer.size = imageHPPip.spriteRenderer.size.RepX((float)unit.HP * hpPipWidth);
			CleanupDamageDisplay();
			MR.Inst.Host.Pause(hpRoutine);
		}
		base.HideAll();
		return true;
	}

	public void ShowStatusBar()
	{
		if (unit.IsCloaked && unit.teamType != 0)
		{
			return;
		}
		base.ShowAll();
		if (!hpRoutine.running)
		{
			MR.Inst.Host.StartTopLevel(hpRoutine);
		}
		if (!criticalHitDriver.IsRunning)
		{
			imageCriticalHit.Hide();
		}
		imageHPPip.Show();
		if (maximised)
		{
			if (unit.HACK_isDecoyUnit && unit.teamType == UnitTeam.Type.Player)
			{
				textboxName.Clear();
				textboxName.AppendKey(unit.charData.DisplayName);
				textboxName.AppendKey("UNITSTATUSBAR_DECOY");
				textboxName.Present();
			}
			else
			{
				textboxName.SetKey(unit.charData.DisplayName);
			}
			imageHPBarEnemyMin.Hide();
			imageHPBarAllyMin.Hide();
			for (int i = unit.AP; i < imageAPPips.Length; i++)
			{
				imageAPPips[i].Hide();
			}
		}
		else
		{
			imageFrameEnemy.Hide();
			imageFrameAlly.Hide();
			imageFlankedEnemy.Hide();
			imageFlankedAlly.Hide();
			imageHPBarEnemyMax.Hide();
			imageHPBarAllyMax.Hide();
			switch (unit.teamType)
			{
			case UnitTeam.Type.Player:
				imageHPBarEnemyMin.Hide();
				break;
			case UnitTeam.Type.Enemy:
			case UnitTeam.Type.Opponent:
				imageHPBarAllyMin.Hide();
				break;
			}
			textboxName.Hide();
			for (int j = 0; j < imageAPPips.Length; j++)
			{
				imageAPPips[j].Hide();
			}
		}
		UpdateCoverDisplay(maximised, updateCover: true);
	}

	public void SetTeamColor(uint team)
	{
		imageHPStartPip.color = UnitTeam.Colors[team];
		imageHPPip.color = UnitTeam.Colors[team];
		imageHPPipAlpha.color = UnitTeam.Colors[team];
		for (int i = 0; i < imageAPPips.Length - 1; i++)
		{
			imageAPPips[i].color = UnitTeam.ColorAP[team];
		}
		textboxName.color = UnitTeam.ColorNameText[team];
	}

	private void UpdateCoverDisplay(bool maximised, bool updateCover = false)
	{
		if (updateCover)
		{
			Map activeMap = Singleton<MC>.Inst.GetActiveMap();
			bool flag = this.unit.teamType == (GC.Inst.IsInTurnMode() ? GC.Inst.GetActiveTeamType() : UnitTeam.Type.Player);
			Unit unit = ((!GC.Inst.IsInTurnMode()) ? GC.Inst.GetRPGLeader() : GC.Inst.GetActiveUnit());
			showNoLOSImage = unit != null && !unit.map.HasLineOfSight(unit.coord, this.unit.coord, isSideStepAllowed: true);
			coverLarge.imageNoLineOfSight.IsShown = showNoLOSImage;
			coverType = CoverType.None;
			if (unit == null || showNoLOSImage)
			{
				coverType = CoverType.None;
			}
			else if (flag)
			{
				coverType = activeMap.GetCoverBetweenAllEnemies(this.unit.coord, this.unit);
			}
			else
			{
				coverType = activeMap.GetCoverBetween(unit.coord, this.unit.coord);
				if (coverType.Is(CoverType.Flanked) || coverType.Is(CoverType.Obscured))
				{
					CoverType greatestNeighbourHeightAsCoverType = activeMap.GetGreatestNeighbourHeightAsCoverType(this.unit.coord);
					coverType |= greatestNeighbourHeightAsCoverType;
				}
			}
		}
		if (maximised)
		{
			coverSmall.imageFullCover.Hide();
			coverSmall.imageHalfCover.Hide();
			coverSmall.imageOpenCover.Hide();
			coverLarge.imageFullCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.Full);
			coverLarge.imageHalfCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.Half);
			coverLarge.imageOpenCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.None);
			switch (this.unit.teamType)
			{
			case UnitTeam.Type.Player:
				imageFrameEnemy.Hide();
				imageFlankedEnemy.Hide();
				imageHPBarEnemyMax.Hide();
				imageFlankedAlly.IsShown = coverType.Is(CoverType.Flanked);
				break;
			case UnitTeam.Type.Enemy:
			case UnitTeam.Type.Opponent:
				imageFrameAlly.Hide();
				imageFlankedAlly.Hide();
				imageHPBarAllyMax.Hide();
				imageFlankedEnemy.IsShown = coverType.Is(CoverType.Flanked);
				break;
			}
			UpdateCoverColor(coverLarge, coverType);
		}
		else
		{
			coverLarge.imageFullCover.Hide();
			coverLarge.imageHalfCover.Hide();
			coverLarge.imageOpenCover.Hide();
			coverSmall.imageFullCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.Full);
			coverSmall.imageHalfCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.Half);
			coverSmall.imageOpenCover.IsShown = !showNoLOSImage && coverType.Is(CoverType.None);
			UpdateCoverColor(coverSmall, coverType);
		}
	}

	public void UpdateDisplay(bool immediate = false, bool updateCover = false)
	{
		if (!isShown)
		{
			return;
		}
		v2i? coord = SC.Inst.coord;
		Unit unitLookedAt = SC.Inst.unitLookedAt;
		AbilityImplBase ability = SC.Inst.ability;
		Unit unit = ((!GC.Inst.IsInTurnMode()) ? GC.Inst.GetRPGLeader() : GC.Inst.GetActiveUnit());
		bool flag = this.unit == unit;
		bool flag2 = !GC.Inst.IsInRPGMode() && (flag || this.unit == unitLookedAt) && !GC.Inst.IsAnyUnitActing();
		UpdateCoverDisplay(flag2, updateCover);
		if (immediate)
		{
			currentCurvePos = ((!flag2) ? 0f : 1f);
			UpdateMinMaxAnimation(currentCurvePos, flag2);
		}
		else if (prevMaximised != flag2)
		{
			if (flag2)
			{
				if (minimizeDriver.IsRunning)
				{
					minimizeDriver.Stop();
				}
				maximizeDriver.StartCustom(currentCurvePos, 1f, (1f - currentCurvePos) * 0.35f);
			}
			else
			{
				if (maximizeDriver.IsRunning)
				{
					maximizeDriver.Stop();
				}
				minimizeDriver.StartCustom(currentCurvePos, 0f, currentCurvePos * 0.35f);
			}
			prevMaximised = flag2;
		}
		if (prevUnitAP != this.unit.AP)
		{
			OnAPChanged();
			prevUnitAP = this.unit.AP;
		}
		if (flag)
		{
			prevActiveUnit = flag;
			int num = 0;
			num = ((ability != null) ? (((!ability.RequireUnitSelection() || (!(unitLookedAt == null) && (ability.SelectionMask(this.unit) & unitLookedAt.teamMask) == unitLookedAt.teamMask)) && (!ability.RequireTileSelection() || coord.HasValue)) ? ability.APCost(this.unit) : 0) : ((unitLookedAt != null && this.unit.teamType != unitLookedAt.teamType) ? this.unit.GetMaxAPToUseWithAttack() : ((coord.HasValue && this.unit.coord != coord.Value) ? this.unit.GetAPNeededToReachCoord(coord.Value, allowNeighbouringTiles: false) : 0)));
			if (coord.HasValue)
			{
				TileActionBase tileAction = this.unit.map.GetTileAction(coord.Value);
				if (tileAction != null && tileAction.costsAp)
				{
					num++;
				}
			}
			PulseAP(num);
		}
		else if (this.unit == unitLookedAt && unit != null && this.unit.teamType != unit.teamType)
		{
			if (!Singleton<MC>.Inst.GetActiveMap().HasLineOfSight(unit.coord, this.unit.coord, isSideStepAllowed: true))
			{
				PulseAP(0);
			}
		}
		else
		{
			PulseAP(0);
		}
	}

	public void PulseAP(int apCost)
	{
		if (apCost < 1)
		{
			int num = imageAPPips.Length;
			while (--num >= 0)
			{
				UIImage obj = imageAPPips[num];
				float stopTime = ((!unit.moving) ? 0.25f : 0f);
				obj.PulseAlphaStop(1f, stopTime);
			}
			return;
		}
		apCost = Mathf.Clamp(apCost, 0, unit.AP);
		for (int i = 0; i < apCost; i++)
		{
			int num2 = unit.AP - 1 - i;
			imageAPPips[num2].PulseAlphaStart(MR.Inst.Host);
		}
		int num3 = unit.GetAPMax() - apCost;
		for (int j = 0; j < num3; j++)
		{
			UIImage obj2 = imageAPPips[j];
			float stopTime = ((!unit.moving) ? 0.25f : 0f);
			obj2.PulseAlphaStop(1f, stopTime);
		}
	}

	public void PlayCriticalHitAnimation()
	{
		criticalHitDriver.Start(1f, 1f);
	}

	public void OnAPChanged()
	{
		bool flag = maximised && (unit.GetTeamType() == UnitTeam.Type.Player || unit.GetTeamType() == UnitTeam.Type.Opponent || (unit.GetTeamType() == UnitTeam.Type.Enemy && GC.Inst.GetActiveUnit() == unit));
		for (int i = 0; i < imageAPPips.Length; i++)
		{
			if (flag && i < unit.AP)
			{
				imageAPPips[i].Show();
				continue;
			}
			UIImage obj = imageAPPips[i];
			float stopTime = ((!unit.moving) ? 0.25f : 0f);
			obj.PulseAlphaStop(1f, stopTime);
			imageAPPips[i].Hide();
		}
	}

	public void UpdateRenderOrder(int newOrder)
	{
		if (newOrder != currentSpriteOrderJump)
		{
			AddToRenderOrder(newOrder - currentSpriteOrderJump);
			currentSpriteOrderJump = newOrder;
		}
	}

	private void UpdateMinMaxAnimation(float curvePosition, bool maximising)
	{
		base.transform.localScale = initialScale * Mathf.Lerp(1f, 1.25f, Mathf.SmoothStep(0f, 1f, currentCurvePos));
		float num = minMaxCurve.Evaluate(currentCurvePos);
		if (num > 0.02f)
		{
			maximised = true;
			if (maximising && !imageFrameAlly.IsShown && !imageFrameEnemy.IsShown)
			{
				ShowStatusBar();
			}
			UITextbox uITextbox = textboxName;
			float num2 = num;
			coverLarge.imageOpenCover.alpha = num2;
			num2 = num2;
			coverLarge.imageHalfCover.alpha = num2;
			num2 = num2;
			coverLarge.imageFullCover.alpha = num2;
			num2 = num2;
			imageHPBarAllyMax.alpha = num2;
			num2 = num2;
			imageHPBarEnemyMax.alpha = num2;
			num2 = num2;
			imageFlankedAlly.alpha = num2;
			num2 = num2;
			imageFlankedEnemy.alpha = num2;
			num2 = num2;
			imageFrameAlly.alpha = num2;
			num2 = num2;
			imageFrameEnemy.alpha = num2;
			uITextbox.alpha = num2;
			for (int i = 0; i < unit.AP; i++)
			{
				imageAPPips[i].alpha = num;
			}
		}
		else
		{
			maximised = false;
			if (!maximising && (imageFrameAlly.IsShown || imageFrameEnemy.IsShown))
			{
				ShowStatusBar();
			}
			float num3 = minMaxCurve.Evaluate(1f - currentCurvePos);
			UIImage uIImage = imageHPBarEnemyMin;
			float num2 = num3;
			coverSmall.imageOpenCover.alpha = num2;
			num2 = num2;
			coverSmall.imageHalfCover.alpha = num2;
			num2 = num2;
			coverSmall.imageFullCover.alpha = num2;
			num2 = num2;
			imageHPBarAllyMin.alpha = num2;
			uIImage.alpha = num2;
		}
	}

	private void UpdateCoverColor(CoverUI coverUI, CoverType coverType)
	{
		Color color = UnitTeam.ColorCoverTypes[unit.GetTeamIndex(), (int)coverType.GetCoverUIType()];
		coverUI.imageFullCover.color = color;
		coverUI.imageHalfCover.color = color;
		coverUI.imageOpenCover.color = color;
	}

	private IEnumerator<HagletYieldTerm> HPAnimPulseControl()
	{
		int prevHP = unit.GetHPMax();
		imageHPPip.spriteRenderer.size = imageHPPip.spriteRenderer.size.RepX((float)unit.GetHPMax() * hpPipWidth);
		imageHPPipAlpha.spriteRenderer.size = imageHPPipAlpha.spriteRenderer.size.RepX(0f);
		while (true)
		{
			yield return Wait.UntilNextUpdate();
			if (unit.HP != prevHP)
			{
				imageHPPip.spriteRenderer.size = imageHPPip.spriteRenderer.size.RepX((float)prevHP * hpPipWidth);
				if (currentDamageDisplay > 0)
				{
					imageHPPipAlpha.spriteRenderer.size = imageHPPipAlpha.spriteRenderer.size.RepX(0f);
					imageHPPipAlpha.PulseAlphaStop();
					imageHPStartPip.PulseAlphaStop();
					currentDamageDisplay = 0;
				}
				Vector2 size;
				float targWidth;
				while (true)
				{
					size = imageHPPip.spriteRenderer.size;
					targWidth = (float)unit.HP * hpPipWidth;
					float rem = targWidth - size.x;
					float delta = Time.deltaTime * 0.8f;
					if (delta > Math.Abs(rem))
					{
						break;
					}
					imageHPPip.spriteRenderer.size = size.RepX(size.x + Mathf.Sign(rem) * delta);
					yield return Wait.UntilNextUpdate();
				}
				imageHPPip.spriteRenderer.size = size.RepX(targWidth);
				prevHP = unit.HP;
			}
			int newDamageDisplay = 0;
			Unit activeUnit = ((!GC.Inst.IsInTurnMode()) ? GC.Inst.GetRPGLeader() : GC.Inst.GetActiveUnit());
			if (activeUnit != null && unit != activeUnit && !activeUnit.attacking && unit == SC.Inst.unitLookedAt && unit.teamType != activeUnit.teamType && activeUnit.AP > 0 && Singleton<MC>.Inst.GetActiveMap().HasLineOfSight(activeUnit.coord, unit.coord, isSideStepAllowed: true))
			{
				newDamageDisplay = activeUnit.GetPendingDamage(unit);
			}
			if (newDamageDisplay == currentDamageDisplay)
			{
				continue;
			}
			if (newDamageDisplay == 0)
			{
				CleanupDamageDisplay();
			}
			else
			{
				int num = Mathf.Clamp(unit.HP - newDamageDisplay, 0, 1000);
				float newVal = (float)num * hpPipWidth;
				float newVal2 = (float)unit.HP * hpPipWidth;
				imageHPPip.spriteRenderer.size = imageHPPip.spriteRenderer.size.RepX(newVal);
				imageHPPipAlpha.spriteRenderer.size = imageHPPipAlpha.spriteRenderer.size.RepX(newVal2);
				imageHPPipAlpha.PulseAlphaStart(MR.Inst.Host);
				if (num == 0)
				{
					imageHPStartPip.PulseAlphaStart(MR.Inst.Host);
				}
			}
			currentDamageDisplay = newDamageDisplay;
		}
	}

	private void CleanupDamageDisplay()
	{
		currentDamageDisplay = 0;
		imageHPPip.spriteRenderer.size = imageHPPip.spriteRenderer.size.RepX((float)unit.HP * hpPipWidth);
		imageHPPipAlpha.spriteRenderer.size = imageHPPipAlpha.spriteRenderer.size.RepX(0f);
		imageHPPipAlpha.PulseAlphaStop();
		imageHPStartPip.PulseAlphaStop();
	}
}
public enum WhamStates
{
	None = 0,
	Hit = 1,
	Crit = 2,
	Dodge = 4,
	Graze = 8,
	Reaction = 0x40,
	Reflect = 0x80,
	Status = 0x200
}
public enum BarTypes
{
	Hit,
	Crit,
	Dodge,
	Graze,
	Reaction,
	Reflect,
	Status,
	Total
}
public struct WhamBarValue
{
	public bool isOverlay;

	public float barSize;

	public float barPos;

	public Sprite spriteOverride;

	public WhamSpriteData spriteData;
}
[Serializable]
public struct WhamSpriteData
{
	public Sprite standardSprite;

	public Sprite defenceSprite;

	public Sprite GetSprite(Combat.CombatMinigame whamstate)
	{
		return (whamstate != Combat.CombatMinigame.AttackWhamBar && whamstate != Combat.CombatMinigame.RefuseAttackWhamBar) ? defenceSprite : standardSprite;
	}
}
public class whamBarData
{
	public UIWhamBar.WhamResult defaultResult;

	public WhamStates whamState;

	private WhamBarValue[] barValues = new WhamBarValue[7];

	public UIWhamBar.WhamResult backgroundResult;

	public Sprite backgroundSpriteOverride;

	public whamBarData(WhamSpriteData[] spriteData)
	{
		for (int i = 0; i < barValues.Length; i++)
		{
			barValues[i].spriteData = spriteData[i];
		}
	}

	public void SetBarOverlay(BarTypes type, bool Overlay)
	{
		barValues[(int)type].isOverlay = Overlay;
	}

	public void SetBarPositionValue(BarTypes type, float newVal)
	{
		barValues[(int)type].barPos = newVal;
	}

	public void SetBarSizeValue(BarTypes type, float newVal)
	{
		barValues[(int)type].barSize = newVal;
	}

	public float GetBarPositionValue(BarTypes type)
	{
		return barValues[(int)type].barPos;
	}

	public float GetBarSizeValue(BarTypes type)
	{
		return barValues[(int)type].barSize;
	}

	public bool GetBarOverlay(BarTypes type)
	{
		return barValues[(int)type].isOverlay;
	}

	public void SetSpriteOverride(BarTypes type, Sprite sprite)
	{
		barValues[(int)type].spriteOverride = sprite;
	}

	public void ResetValues()
	{
		whamState = WhamStates.None;
		backgroundSpriteOverride = null;
		for (int i = 0; i < barValues.Length; i++)
		{
			barValues[i].isOverlay = false;
			barValues[i].barSize = 0f;
			barValues[i].barPos = 0f;
			barValues[i].spriteOverride = null;
		}
	}

	public void ClampValues()
	{
		for (int i = 0; i < barValues.Length; i++)
		{
			barValues[i].barSize = Mathf.Clamp01(barValues[i].barSize);
			barValues[i].barPos = Mathf.Clamp(barValues[i].barPos, 0f, 1f - barValues[i].barSize);
		}
	}

	public WhamBarValue GetBarValues(BarTypes type)
	{
		return barValues[(int)type];
	}
}
public class UIWhamBar : UIContainer
{
	public class Bar
	{
		private UIImage image;

		public float origPos;

		public float origScale;

		public WhamBarValue whamValues;

		private Vector3 textBoxOriginSize;

		public WhamResult result;

		public bool enabled = true;

		public Transform transform => image.transform;

		public void SetPositionAndSize(float position, float size)
		{
			transform.localPosition = new Vector3(position, 0f, 0f);
			float y = ((!whamValues.isOverlay) ? 1f : 1.75f);
			transform.localScale = new Vector3(size, y, 1f);
		}

		public void SetAlpha(float alpha)
		{
			image.alpha = alpha;
		}

		public void Init(UIImage image)
		{
			this.image = image;
		}

		public void Setup(Combat.CombatMinigame whamState, WhamResult result, WhamBarValue whamValues, bool isTutorialWinState = false)
		{
			this.result = result;
			this.whamValues = whamValues;
			if ((bool)whamValues.spriteOverride)
			{
				image.spriteRenderer.sprite = whamValues.spriteOverride;
			}
			else
			{
				image.spriteRenderer.sprite = whamValues.spriteData.GetSprite(whamState);
			}
			enabled = true;
		}
	}

	public struct TapTutorialText
	{
		public UITextbox tapText;

		public HagletResettable pingText;

		public void Init(UITextbox tapText)
		{
			this.tapText = tapText;
			pingText = new HagletResettable(PingTutorialTextRoutine(), "Ping WhamBar Tutorial Text");
		}

		private IEnumerator<HagletYieldTerm> PingTutorialTextRoutine()
		{
			Vector3 origScale = tapText.transform.localScale;
			float t = 0f;
			float pingTime = 0.3f;
			tapText.color = Color.white;
			while (t < pingTime)
			{
				t += Time.deltaTime;
				float progress = t / pingTime;
				tapText.transform.localScale = Vector3.Lerp(origScale, origScale * 1.5f, progress);
				tapText.color = Color.Lerp(Color.white, Color.white.RepA(0f), Mathf.Clamp01(progress * 2f - 1f));
				yield return null;
			}
			tapText.transform.localScale = origScale;
		}

		public void Ping(Bar bar)
		{
			tapText.transform.localPosition = tapText.transform.localPosition.RepX(bar.whamValues.barPos + bar.whamValues.barSize * 0.5f);
			Routine.Start(pingText, LR.Host);
		}

		public bool Running()
		{
			return pingText.running;
		}

		public void Setup()
		{
			tapText.gameObject.SetActive(Inst.tutorialTapText);
			tapText.color = Color.clear;
			switch (IC.controlInputType)
			{
			case IC.InputType.GamePad:
			case IC.InputType.XboxController:
				tapText.SetKey("UIWHAMBAR_TAPTEXT_GAMEPAD");
				break;
			case IC.InputType.GearVRController:
				tapText.SetKey("UIWHAMBAR_TAPTEXT_GEARVR_CONTROLLER");
				break;
			default:
				tapText.SetKey("UIWHAMBAR_TAPTEXT");
				break;
			}
		}
	}

	public enum WhamResult
	{
		None = 0,
		Hit = 1,
		Crit = 2,
		Miss = 4,
		Dodge = 8,
		Graze = 0x10,
		Reaction = 0x40,
		Reflect = 0x80,
		Status = 0x200
	}

	private static readonly float kLeeway = 0.02f;

	private static readonly float kCountdownTime = 0.15f;

	private static readonly float kFirstTutorialCountdownTime = 7f;

	private static readonly float kSecondTutorialCountdownTime = 1f;

	[Header("Attack Wham Settings")]
	[Space(2f)]
	public AnimationCurve hitDifficultyCurve;

	public AnimationCurve hitTimeByDodgeCurve;

	private static readonly float kAtkHitPercentageOfValueGiven = 0.01f;

	private static readonly float kAtkCritPercentageOfValueGiven = 0.01f;

	private static readonly float kAtkHitBarOffsetRatio = 0.33f;

	[Header("Dodge Wham Settings")]
	[Space(2f)]
	public AnimationCurve dodgeDifficultyCurve;

	public AnimationCurve critDifficultyCurve;

	private static readonly float kDodgeTime = 1f;

	private static readonly float kDodgeHitPercentageOfValueGiven = 0.01f;

	private static readonly float kDodgePercentageOfValueGiven = 0.01f;

	private static readonly float kDodgeCritPercentageOfValueGiven = 0.01f;

	private static readonly float kDodgeBarOffsetRatio = 0.25f;

	private static UIWhamBar _inst;

	[HideInInspector]
	public bool tutorialCannotLose;

	[HideInInspector]
	public bool tutorialTapText;

	[HideInInspector]
	public bool tutorialMissDialog = true;

	[HideInInspector]
	public bool tutorialAllowCrits = true;

	[HideInInspector]
	public bool firstTutorialAttempt = true;

	private Bar[] bars;

	private UIImage background;

	private UIImage backgroundBg;

	private UIImage ticker;

	private UIImage countdownImage;

	private UIImage countdownBaseImage;

	private UIImage[] attackCounters;

	private ConstArray<UIImage> activeAttackCounters = new ConstArray<UIImage>(10u);

	private UITextbox outcomeText;

	private TapTutorialText[] tutorialTapTexts;

	private DialogData hartmanWhamTut_Headset;

	private DialogData hartmanWhamTut_GearVRRemote;

	private DialogData hartmanWhamTut_Gamepad;

	private ConstArray<DialogData> hartmanMissLines = new ConstArray<DialogData>(3u);

	private ConstArray<DialogData> hartmanMissLineBag = new ConstArray<DialogData>(3u);

	private Material countdownMat;

	private ShakeObject[] shakeBars;

	private AnimationCurve[] shakeBarCurves;

	private HagletResettable whackAMole;

	private HagletResettable fadeOut;

	private HagletResettable pulseTicker;

	private HagletResettable flashTicker;

	private bool killTickerFlash;

	private bool isReaction;

	private ConstArray<Combat.CombatData> attacks;

	private Combat.CombatMinigame whamType;

	private WhamResult lastResult;

	private WhamResult additionalResult;

	private WhamResult failResult;

	private Vector3 originTickerScale;

	private float countdownTime;

	private float whamTime;

	private FMOD.Studio.EventInstance currentSFXHandle;

	private whamBarData barData;

	public Sprite barBackgroundSprite;

	public WhamSpriteData backgroundSprites;

	public WhamSpriteData tickerSprites;

	public WhamSpriteData countdownBaseSprites;

	public WhamSpriteData countdownSprites;

	public WhamSpriteData attackCounterSprites;

	public WhamSpriteData[] barSprites = new WhamSpriteData[7];

	public static UIWhamBar Inst => _inst;

	public float TutorialCountdownTime => (!firstTutorialAttempt) ? kSecondTutorialCountdownTime : kFirstTutorialCountdownTime;

	public int FailedAttempts { get; private set; }

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		_inst = this;
		barData = new whamBarData(barSprites);
		attackCounters = new UIImage[10];
		for (int i = 0; i < attackCounters.Length; i++)
		{
			attackCounters[i] = GetElement<UIImage>("AttackCount (" + i + ")");
		}
		whackAMole = new HagletResettable(WhackAMoleRoutine(), "Wham Bar");
		fadeOut = new HagletResettable(FadeOutRoutine(), "Fade out Wham Bar");
		pulseTicker = new HagletResettable(PulseTickerRoutine(), "Pulse Wham Bar Ticker");
		flashTicker = new HagletResettable(FlashTickerRoutine(), "Flash Wham Bar Ticker");
		hartmanWhamTut_Headset = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_ActionGauge_Headset");
		hartmanWhamTut_GearVRRemote = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_ActionGauge_GearVRRemote");
		hartmanWhamTut_Gamepad = HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_ActionGauge_Gamepad");
		hartmanMissLines.Add(HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMisses"));
		hartmanMissLines.Add(HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMissesAgain"));
		hartmanMissLines.Add(HAGIS.DialogLoad("Dialogs/A1S1/TutorialDialogs/Tutorial_PlayerMissesThirdTime"));
		bars = new Bar[9];
		for (int j = 0; j < bars.Length; j++)
		{
			bars[j] = new Bar();
			bars[j].Init(GetElement<UIImage>("Bar" + j));
		}
		shakeBars = GetComponentsInChildren<ShakeObject>();
		shakeBarCurves = new AnimationCurve[shakeBars.Length];
		for (int k = 0; k < shakeBars.Length; k++)
		{
			shakeBarCurves[k] = new AnimationCurve(new Keyframe(0f, UnityEngine.Random.Range(-0.5f, 0.5f)), new Keyframe(0.5f, 0f));
		}
		outcomeText = GetElement<UITextbox>("OutcomeText");
		UITextbox[] componentsInChildren = base.transform.FindChild("BarParent").FindChild("TapTextPool").GetComponentsInChildren<UITextbox>();
		tutorialTapTexts = new TapTutorialText[componentsInChildren.Length];
		for (int l = 0; l < componentsInChildren.Length; l++)
		{
			tutorialTapTexts[l].Init(componentsInChildren[l]);
		}
		countdownImage = GetElement<UIImage>("Countdown");
		countdownBaseImage = GetElement<UIImage>("Countdown_Base");
		SpriteRenderer spriteRenderer = countdownImage.spriteRenderer;
		countdownMat = spriteRenderer.material;
		background = GetElement<UIImage>("BarBackground");
		backgroundBg = GetElement<UIImage>("BarBackgroundBg");
		ticker = GetElement<UIImage>("Ticker");
		originTickerScale = ticker.transform.localScale;
	}

	public void OnMissionSceneLoaded(MR mr)
	{
		firstTutorialAttempt = true;
		ticker.transform.localScale = originTickerScale;
		ticker.transform.localPosition = new Vector3(0f, 0f, 0f);
		hartmanMissLineBag.Clear();
		for (int i = 0; i < hartmanMissLines.Length; i++)
		{
			hartmanMissLineBag.Add(hartmanMissLines[i]);
		}
		whackAMole.Reset();
		fadeOut.Reset();
		pulseTicker.Reset();
		flashTicker.Reset();
		for (int j = 0; j < tutorialTapTexts.Length; j++)
		{
			tutorialTapTexts[j].pingText.Reset();
		}
	}

	public void OnMissionUnloaded()
	{
		if ((bool)whackAMole.running)
		{
			LR.Host.Pause(whackAMole);
			whackAMole.Reset();
		}
		if ((bool)fadeOut.running)
		{
			LR.Host.Pause(fadeOut);
			fadeOut.Reset();
		}
		if ((bool)pulseTicker.running)
		{
			LR.Host.Pause(pulseTicker);
			pulseTicker.Reset();
		}
		if ((bool)flashTicker.running)
		{
			LR.Host.Pause(flashTicker);
			flashTicker.Reset();
		}
		if (currentSFXHandle.isValid())
		{
			currentSFXHandle.stop(STOP_MODE.IMMEDIATE);
		}
		HideAll();
		tutorialCannotLose = false;
		tutorialTapText = false;
		tutorialAllowCrits = true;
	}

	private void Update()
	{
		Vector3 vector = Singleton<CC>.Inst._camera.transform.position - base.transform.position;
		base.transform.LookAt(base.transform.position - vector);
	}

	private void SetupWhamBar(Combat.CombatData attack)
	{
		for (int i = 0; i < bars.Length; i++)
		{
			bars[i].enabled = false;
			bars[i].result = WhamResult.None;
			bars[i].whamValues.barPos = 0f;
			bars[i].whamValues.barSize = 0f;
			bars[i].whamValues.isOverlay = false;
			bars[i].whamValues.spriteOverride = null;
			bars[i].whamValues.spriteData.defenceSprite = null;
			bars[i].whamValues.spriteData.standardSprite = null;
		}
		barData.ResetValues();
		barData.whamState = attack.whamState;
		WhamBarValue whamValues = default(WhamBarValue);
		whamValues.isOverlay = false;
		switch (whamType)
		{
		case Combat.CombatMinigame.AttackWhamBar:
		case Combat.CombatMinigame.RefuseAttackWhamBar:
		{
			barData.backgroundResult = WhamResult.Miss;
			float value2 = (float)attack.hitChance * kAtkHitPercentageOfValueGiven;
			float num8 = (float)attack.critSize * kAtkCritPercentageOfValueGiven;
			float num9 = hitDifficultyCurve.Evaluate(Mathf.Clamp01(value2));
			float num10 = Mathf.Clamp01(num9 * num8);
			float num11 = 1f - (num10 + num9);
			float num12 = num11 - num11 * kAtkHitBarOffsetRatio;
			float newVal2 = num12 + num9 + num11 * (kAtkHitBarOffsetRatio / 2f);
			barData.SetBarSizeValue(BarTypes.Hit, num9);
			barData.SetBarPositionValue(BarTypes.Hit, num12);
			barData.SetBarSizeValue(BarTypes.Crit, num10);
			barData.SetBarPositionValue(BarTypes.Crit, newVal2);
			barData.ClampValues();
			barData.defaultResult = WhamResult.Miss;
			foreach (AbilityImplBase item in attack.attacker.abilities.OnUnitAndTeam())
			{
				item.ApplyAttackWhamBarModifiers(attack.attacker, attack.target, barData, attack.weapon);
			}
			foreach (AbilityImplBase item2 in attack.target.abilities.OnUnitAndTeam())
			{
				item2.ApplyTargetedAttackWhamBarModifiers(attack.attacker, attack.target, barData);
			}
			failResult = WhamResult.Miss;
			countdownTime = ((!tutorialCannotLose) ? kCountdownTime : TutorialCountdownTime);
			whamTime = hitTimeByDodgeCurve.Evaluate((float)attack.dodgeChance * 0.01f);
			if ((barData.whamState & WhamStates.Crit) != 0 && tutorialAllowCrits)
			{
				bars[0].Setup(whamType, WhamResult.Crit, barData.GetBarValues(BarTypes.Crit), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Status) != 0)
			{
				bars[1].Setup(whamType, WhamResult.Status, barData.GetBarValues(BarTypes.Status), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Hit) != 0)
			{
				bars[2].Setup(whamType, WhamResult.Hit, barData.GetBarValues(BarTypes.Hit), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Graze) != 0)
			{
				bars[3].Setup(whamType, WhamResult.Graze, barData.GetBarValues(BarTypes.Graze), isTutorialWinState: true);
			}
			whamValues.barSize = 1.5f;
			whamValues.barPos = 0f;
			bars[4].Setup(whamType, barData.backgroundResult, whamValues);
			break;
		}
		case Combat.CombatMinigame.DodgeWhamBar:
		{
			barData.backgroundResult = WhamResult.Hit;
			float num = (float)attack.hitChance * kDodgeHitPercentageOfValueGiven;
			float num2 = (float)attack.dodgeSize * kDodgePercentageOfValueGiven;
			float num3 = (float)attack.critSize * kDodgeCritPercentageOfValueGiven;
			float num4 = num * num3;
			float num5 = 1f - num4;
			float value = num5 * num2;
			num4 = critDifficultyCurve.Evaluate(Mathf.Clamp01(num4));
			value = dodgeDifficultyCurve.Evaluate(Mathf.Clamp01(value));
			float num6 = 1f - (num4 + value);
			float min = num6 * kDodgeBarOffsetRatio;
			float max = num6;
			float num7 = UnityEngine.Random.Range(min, max);
			float newVal = Mathf.Clamp01(num7 + num4);
			barData.SetBarSizeValue(BarTypes.Crit, num4);
			barData.SetBarPositionValue(BarTypes.Crit, num7);
			barData.SetBarSizeValue(BarTypes.Dodge, value);
			barData.SetBarPositionValue(BarTypes.Dodge, newVal);
			barData.SetBarSizeValue(BarTypes.Graze, value);
			barData.SetBarPositionValue(BarTypes.Graze, newVal);
			barData.ClampValues();
			barData.defaultResult = WhamResult.Crit;
			foreach (AbilityImplBase item3 in attack.target.abilities.OnUnitAndTeam())
			{
				item3.ApplyDodgeWhamBarModifiers(attack.attacker, attack.target, barData, isReaction);
			}
			foreach (AbilityImplBase item4 in attack.attacker.abilities.OnUnitAndTeam())
			{
				item4.ApplyAttackerDodgeWhamBarModifiers(attack.attacker, attack.target, barData, attack.weapon);
			}
			failResult = (WhamResult)3;
			countdownTime = ((!tutorialCannotLose) ? kCountdownTime : TutorialCountdownTime);
			whamTime = kDodgeTime;
			if ((barData.whamState & WhamStates.Reaction) != 0)
			{
				bars[0].Setup(whamType, WhamResult.Reaction, barData.GetBarValues(BarTypes.Reaction), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Reflect) != 0)
			{
				bars[1].Setup(whamType, WhamResult.Reflect, barData.GetBarValues(BarTypes.Reflect), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Dodge) != 0)
			{
				bars[2].Setup(whamType, WhamResult.Dodge, barData.GetBarValues(BarTypes.Dodge), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Graze) != 0)
			{
				bars[3].Setup(whamType, WhamResult.Graze, barData.GetBarValues(BarTypes.Graze), isTutorialWinState: true);
			}
			if ((barData.whamState & WhamStates.Crit) != 0)
			{
				bars[4].Setup(whamType, WhamResult.Crit, barData.GetBarValues(BarTypes.Crit));
			}
			whamValues.barSize = 1.5f;
			whamValues.barPos = 0f;
			bars[5].Setup(whamType, barData.backgroundResult, whamValues);
			whamValues.barSize = 0f;
			whamValues.barPos = 1f;
			bars[6].Setup(whamType, barData.backgroundResult, whamValues);
			break;
		}
		}
	}

	private void HandleResult(ref Combat.CombatData attack)
	{
		if (IC.OnActionButtonDown())
		{
			lastResult = EvaluateWhamTicker().result;
			Bar bar = EvaluateWhamTicker(overlay: true);
			if (bar != null)
			{
				additionalResult = EvaluateWhamTicker(overlay: true).result;
			}
			else
			{
				additionalResult = WhamResult.None;
			}
		}
		else
		{
			lastResult = barData.defaultResult;
			additionalResult = WhamResult.None;
		}
		string text = GetResultText(lastResult);
		foreach (AbilityImplBase item in attack.attacker.abilities.OnUnitAndTeam())
		{
			text = item.OverrideWhamResultText(attack.attacker, lastResult, text);
		}
		outcomeText.SetKey(text);
		attack.hitType = GetResultHitType(lastResult, whamType);
		attack.additionalEffect = GetResultHitType(additionalResult, whamType);
	}

	private Combat.HitType GetResultHitType(WhamResult result, Combat.CombatMinigame type)
	{
		switch (whamType)
		{
		case Combat.CombatMinigame.AttackWhamBar:
		case Combat.CombatMinigame.RefuseAttackWhamBar:
			return result switch
			{
				WhamResult.Hit => Combat.HitType.Hit, 
				WhamResult.Crit => Combat.HitType.HitCritical, 
				WhamResult.Status => Combat.HitType.Status, 
				WhamResult.Graze => Combat.HitType.Graze, 
				WhamResult.Miss => Combat.HitType.Miss, 
				_ => Combat.HitType.None, 
			};
		case Combat.CombatMinigame.DodgeWhamBar:
			return result switch
			{
				WhamResult.Hit => Combat.HitType.Hit, 
				WhamResult.Crit => Combat.HitType.HitCritical, 
				WhamResult.Dodge => Combat.HitType.Dodged, 
				WhamResult.Graze => Combat.HitType.Graze, 
				WhamResult.Reaction => Combat.HitType.Reaction, 
				WhamResult.Reflect => Combat.HitType.Reflect, 
				_ => Combat.HitType.None, 
			};
		default:
			return Combat.HitType.None;
		}
	}

	private string GetResultText(WhamResult result)
	{
		return result switch
		{
			WhamResult.Hit => (!tutorialCannotLose || whamType != Combat.CombatMinigame.DodgeWhamBar) ? "UIWHAMBAR_RESULTTEXT_HIT" : "UIWHAMBAR_RESULTTEXT_TRYAGAIN", 
			WhamResult.Crit => (!tutorialCannotLose || whamType != Combat.CombatMinigame.DodgeWhamBar) ? "UIWHAMBAR_RESULTTEXT_CRIT" : "UIWHAMBAR_RESULTTEXT_TRYAGAIN", 
			WhamResult.Miss => (!tutorialCannotLose || whamType != Combat.CombatMinigame.AttackWhamBar) ? "UIWHAMBAR_RESULTTEXT_MISS" : "UIWHAMBAR_RESULTTEXT_TRYAGAIN", 
			WhamResult.Dodge => "UIWHAMBAR_RESULTTEXT_DODGE", 
			WhamResult.Graze => "UIWHAMBAR_RESULTTEXT_GRAZED", 
			WhamResult.Reaction => "UIWHAMBAR_RESULTTEXT_REACTION", 
			WhamResult.Reflect => "UIWHAMBAR_RESULTTEXT_REFLECT", 
			WhamResult.Status => "UIWHAMBAR_RESULTTEXT_STATUS", 
			_ => "UIWHAMBAR_RESULTTEXT_INVALID", 
		};
	}

	private IEnumerator<HagletYieldTerm> WhackAMoleRoutine()
	{
		UIC.PositionCombatUIPopup(base.transform);
		for (int i = 0; i < bars.Length; i++)
		{
			bars[i].SetAlpha(0f);
			bars[i].SetPositionAndSize(0f, 0.5f);
		}
		ShowAll();
		bool isAttack = whamType == Combat.CombatMinigame.AttackWhamBar || whamType == Combat.CombatMinigame.RefuseAttackWhamBar;
		ticker.transform.localPosition = Vector3.zero;
		outcomeText.color = outcomeText.color.RepA(0f);
		countdownMat.SetFloat("_Cutoff", 1f);
		activeAttackCounters.Clear();
		for (int j = 0; j < attackCounters.Length; j++)
		{
			attackCounters[j].alpha = 0f;
			attackCounters[j].transform.localScale = new Vector3(1f, 1f, 1f);
			attackCounters[j].spriteRenderer.sprite = ((!isAttack) ? attackCounterSprites.defenceSprite : attackCounterSprites.standardSprite);
			if (attacks.Length > 1 && j < attacks.Length)
			{
				activeAttackCounters.Add(attackCounters[j]);
			}
		}
		float margin = 0.019f;
		for (int k = 0; k < activeAttackCounters.Length; k++)
		{
			UIImage uIImage = activeAttackCounters[k];
			float newVal = (float)k * margin - (float)activeAttackCounters.Length * margin * 0.5f + margin * 0.5f;
			uIImage.transform.localPosition = uIImage.transform.localPosition.RepX(newVal);
		}
		AC.Inst.PlayOneShot2D("event:/sfx/ui/wham bar/fade in");
		float fadeInTime2 = 0.05f;
		float t3 = 0f;
		while (t3 <= fadeInTime2)
		{
			t3 += Time.deltaTime;
			float progress2 = t3 / fadeInTime2;
			background.color = background.color.RepA(progress2);
			backgroundBg.color = background.color.RepA(Mathf.Clamp(progress2 * 0.5f, 0f, 0.5f));
			ticker.color = ticker.color.RepA(progress2);
			countdownImage.color = countdownImage.color.RepA(progress2);
			countdownBaseImage.color = countdownBaseImage.color.RepA(progress2);
			for (int l = 0; l < activeAttackCounters.Length; l++)
			{
				activeAttackCounters[l].alpha = progress2;
			}
			yield return null;
		}
		FailedAttempts = 0;
		for (int a = 0; a < attacks.sLength; a++)
		{
			Combat.CombatData attack = attacks[a];
			float countdownTimer = 0f;
			if (tutorialCannotLose && firstTutorialAttempt)
			{
				switch (IC.controlInputType)
				{
				case IC.InputType.GamePad:
				case IC.InputType.XboxController:
					HAGIS.DialogShow(hartmanWhamTut_Gamepad);
					break;
				case IC.InputType.GearVRController:
					HAGIS.DialogShow(hartmanWhamTut_GearVRRemote);
					break;
				default:
					HAGIS.DialogShow(hartmanWhamTut_Headset);
					break;
				}
			}
			else
			{
				currentSFXHandle = AC.Inst.PlayOneShot2D("event:/sfx/ui/wham bar/radial countdown");
			}
			SetupWhamBar(attack);
			float fadeInTime3 = 0.05f;
			float t4 = 0f;
			for (int m = 0; m < bars.Length; m++)
			{
				bars[m].origPos = bars[m].transform.localPosition.x;
				bars[m].origScale = bars[m].transform.localScale.x;
			}
			Vector3 originTickerPos = ticker.transform.localPosition;
			backgroundBg.spriteRenderer.sprite = ((!(barData.backgroundSpriteOverride != null)) ? barBackgroundSprite : barData.backgroundSpriteOverride);
			ticker.spriteRenderer.sprite = ((!isAttack) ? tickerSprites.defenceSprite : tickerSprites.standardSprite);
			background.spriteRenderer.sprite = ((!isAttack) ? backgroundSprites.defenceSprite : backgroundSprites.standardSprite);
			countdownImage.spriteRenderer.sprite = ((!isAttack) ? countdownSprites.defenceSprite : countdownSprites.standardSprite);
			countdownBaseImage.spriteRenderer.sprite = ((!isAttack) ? countdownBaseSprites.defenceSprite : countdownBaseSprites.standardSprite);
			LR.PrepareRadialMaterial(countdownMat, countdownImage.spriteRenderer.sprite);
			while (t4 <= fadeInTime3)
			{
				t4 += Time.deltaTime;
				float progress3 = t4 / fadeInTime3;
				for (int n = 0; n < bars.Length; n++)
				{
					bars[n].SetPositionAndSize(Mathf.Lerp(bars[n].origPos, bars[n].whamValues.barPos, progress3), Mathf.Lerp(bars[n].origScale, bars[n].whamValues.barSize, progress3));
					bars[n].SetAlpha(Mathf.Lerp(0f, 1f, progress3));
				}
				ticker.transform.localPosition = Vector3.Lerp(originTickerPos, Vector3.zero, progress3);
				ticker.alpha = Mathf.Lerp(0f, 1f, progress3);
				if (a < activeAttackCounters.Length)
				{
					if (a - 1 >= 0)
					{
						activeAttackCounters[a - 1].alpha = 1f - progress3;
					}
					float num = 1f + progress3 * 0.2f;
					activeAttackCounters[a].transform.localScale = new Vector3(num, num, num);
				}
				countdownTimer += Time.deltaTime;
				float countdownProgress2 = Mathf.Clamp01(1f - countdownTimer / countdownTime);
				countdownMat.SetFloat("_Cutoff", countdownProgress2);
				yield return null;
			}
			if (whamType == Combat.CombatMinigame.RefuseAttackWhamBar)
			{
				int num2 = 0;
				for (int num3 = shakeBars.Length; num2 < num3; num2++)
				{
					shakeBars[num2].ResetOrigin();
					shakeBars[num2].ShakeOneShot(0.25f, 0.25f);
				}
			}
			if (!flashTicker.running)
			{
				Routine.Start(flashTicker, LR.Host);
			}
			while (countdownTimer < countdownTime)
			{
				countdownTimer += Time.deltaTime;
				float countdownProgress = Mathf.Clamp01(1f - countdownTimer / countdownTime);
				countdownMat.SetFloat("_Cutoff", countdownProgress);
				yield return null;
			}
			killTickerFlash = true;
			if (!pulseTicker.running)
			{
				Routine.Start(pulseTicker, LR.Host);
				yield return null;
			}
			if (currentSFXHandle.isValid())
			{
				currentSFXHandle.stop(STOP_MODE.ALLOWFADEOUT);
			}
			if (whamType == Combat.CombatMinigame.RefuseAttackWhamBar)
			{
				yield return Wait.ForSeconds(1.5f);
				attack.hitType = Combat.HitType.Miss;
				lastResult = WhamResult.Miss;
				HandleResult(ref attack);
			}
			else
			{
				bool userInputted2 = false;
				currentSFXHandle = AC.Inst.PlayOneShot2D("event:/sfx/ui/wham bar/ticker progress");
				if (currentSFXHandle.isValid())
				{
					currentSFXHandle.setParameterValue("pitch", 0f);
				}
				Bar lastBar = null;
				for (float t2 = 0f; t2 < whamTime; t2 += Time.deltaTime)
				{
					if (IC.OnActionButtonDown())
					{
						userInputted2 = true;
						break;
					}
					Bar curBar = EvaluateWhamTicker();
					ticker.transform.localPosition = Vector3.Lerp(Vector3.zero, new Vector3(1.1f, 0f, 0f), t2 / whamTime);
					if (currentSFXHandle.isValid())
					{
						currentSFXHandle.setParameterValue("pitch", t2 / whamTime);
					}
					if (tutorialTapText && lastBar != curBar && (failResult & curBar.result) == 0)
					{
						for (int num4 = 0; num4 < tutorialTapTexts.Length; num4++)
						{
							if (!tutorialTapTexts[num4].Running())
							{
								tutorialTapTexts[num4].Ping(curBar);
								break;
							}
						}
					}
					lastBar = curBar;
					yield return null;
				}
				HandleResult(ref attack);
			}
			if (currentSFXHandle.isValid())
			{
				currentSFXHandle.stop(STOP_MODE.ALLOWFADEOUT);
			}
			if (!pulseTicker.running)
			{
				Routine.Start(pulseTicker, MR.Inst.Host);
			}
			bool failed = (failResult & lastResult) != 0;
			if (Routine.IsSkipping())
			{
				failed = false;
			}
			if (failed)
			{
				AC.Inst.PlayOneShot2D("event:/sfx/ui/wham bar/miss");
				FailedAttempts++;
			}
			else
			{
				AC.Inst.PlayOneShot2D("event:/sfx/ability/default use");
			}
			DialogData waitOnHartman = null;
			if (tutorialCannotLose && failed)
			{
				a--;
				int num5 = 0;
				for (int num6 = shakeBars.Length; num5 < num6; num5++)
				{
					shakeBars[num5].ResetOrigin();
					shakeBars[num5].ShakeOneShot(0.25f, 0.25f);
				}
				if (hartmanMissLineBag.Length != 0 && tutorialMissDialog)
				{
					waitOnHartman = hartmanMissLineBag[0];
					hartmanMissLineBag.RemoveAtIndex(0u);
					HAGIS.DialogShow(waitOnHartman);
					waitOnHartman.completed = false;
				}
			}
			else
			{
				attacks[a] = attack;
			}
			if (a == attacks.Length - 1 && !fadeOut.running)
			{
				Routine.Start(fadeOut, MR.Inst.Host);
			}
			float fadeInTime = ((!tutorialCannotLose || !failed) ? 0.25f : 0.5f);
			float t = 0f;
			Vector3 originTextScale = outcomeText.transform.localScale;
			while (t <= fadeInTime)
			{
				t += Time.deltaTime;
				float progress = t / fadeInTime;
				outcomeText.transform.localScale = Vector3.Lerp(originTextScale, originTextScale * 1.5f, progress);
				outcomeText.color = new Color(1f, 1f, 1f, 1f - progress);
				yield return null;
			}
			outcomeText.transform.localScale = originTextScale;
			if ((bool)waitOnHartman && !waitOnHartman.completed)
			{
				yield return waitOnHartman.OnComplete;
			}
			firstTutorialAttempt = false;
		}
		if ((bool)fadeOut.running)
		{
			yield return fadeOut.completed;
		}
		yield return Singleton<UIC>.Inst.Pop();
	}

	private Bar EvaluateWhamTicker(bool overlay = false)
	{
		float x = ticker.transform.localPosition.x;
		for (int i = 0; i < bars.Length; i++)
		{
			if (bars[i].enabled && bars[i].whamValues.isOverlay == overlay && x >= bars[i].whamValues.barPos - kLeeway && x <= bars[i].whamValues.barPos + bars[i].whamValues.barSize + kLeeway)
			{
				return bars[i];
			}
		}
		return null;
	}

	public override bool OnBackButtonPressed()
	{
		return false;
	}

	private IEnumerator<HagletYieldTerm> PulseTickerRoutine()
	{
		float t = 0f;
		float fadeInTime = 0.15f;
		while (t <= fadeInTime)
		{
			t += Time.deltaTime;
			float progress = t / fadeInTime;
			if (progress < 0.5f)
			{
				ticker.transform.localScale = Vector3.Lerp(originTickerScale, originTickerScale * 1.5f, progress * 2f);
			}
			else
			{
				ticker.transform.localScale = Vector3.Lerp(originTickerScale * 1.5f, originTickerScale, (progress - 0.5f) * 2f);
			}
			yield return null;
		}
	}

	private IEnumerator<HagletYieldTerm> FadeOutRoutine()
	{
		float fadeInTime = 0.1f;
		float t = 0f;
		Vector3 originTickerPos = ticker.transform.localPosition;
		Vector3 targetScale = new Vector3(0f, 1f, 1f);
		Vector3 targetPos = new Vector3(0.5f, 0f, 0f);
		while (t <= fadeInTime)
		{
			t += Time.deltaTime;
			float progress = t / fadeInTime;
			countdownMat.SetFloat("_Cutoff", progress);
			background.color = background.color.RepA(1f - progress);
			countdownImage.color = countdownImage.color.RepA(1f - progress);
			countdownBaseImage.color = countdownBaseImage.color.RepA(1f - progress);
			backgroundBg.color = background.color.RepA(Mathf.Clamp(0.5f - progress * 0.5f, 0f, 0.5f));
			for (int i = 0; i < bars.Length; i++)
			{
				bars[i].SetAlpha(Mathf.Lerp(1f, 0f, progress));
			}
			ticker.color = ticker.color.RepA(1f - progress);
			yield return null;
		}
	}

	private IEnumerator<HagletYieldTerm> FlashTickerRoutine()
	{
		float originalpha = ticker.alpha;
		float tickTime = 0.1f;
		do
		{
			for (float t2 = 0f; t2 < tickTime; t2 += Time.deltaTime)
			{
				ticker.alpha = Mathf.Lerp(originalpha, 0f, t2 / tickTime);
				yield return null;
			}
			for (float t = 0f; t < tickTime; t += Time.deltaTime)
			{
				ticker.alpha = Mathf.Lerp(0f, originalpha, t / tickTime);
				yield return null;
			}
		}
		while (!killTickerFlash);
		ticker.alpha = originalpha;
		killTickerFlash = false;
	}

	public override void ShowAll()
	{
		if (!LR.Inst.MissionIsUnloading)
		{
			base.ShowAll();
			for (int i = 0; i < tutorialTapTexts.Length; i++)
			{
				tutorialTapTexts[i].Setup();
			}
			if ((bool)Crosshair.Inst)
			{
				Crosshair.Inst.EnableRadialBar(enabled: false);
			}
		}
	}

	public override bool HideAll()
	{
		base.HideAll();
		if ((bool)Crosshair.Inst)
		{
			Crosshair.Inst.EnableRadialBar(enabled: true);
		}
		return true;
	}

	public void OnPauseUnpause(bool paused)
	{
		if (currentSFXHandle.isValid())
		{
			currentSFXHandle.setPaused(paused);
		}
	}

	public HagletYieldTerm StartWhamBar(Combat.CombatMinigame whamType, ConstArray<Combat.CombatData> attacks, bool isReaction)
	{
		if ((bool)whackAMole.running)
		{
			LR.Host.Pause(whackAMole);
		}
		if (MR.Inst.IsSkipping())
		{
			UnityEngine.Debug.LogWarning("Tried to call the Wham bar while skipping!");
			return Wait.None;
		}
		this.isReaction = isReaction;
		this.whamType = whamType;
		this.attacks = attacks;
		Singleton<UIC>.Inst.Push<UIWhamBar>();
		return Routine.Start(whackAMole, MR.Inst.Host);
	}
}
