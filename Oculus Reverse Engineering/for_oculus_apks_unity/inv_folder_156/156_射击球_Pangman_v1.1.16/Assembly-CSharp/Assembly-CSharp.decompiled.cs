#define DEBUG_LOCOMOTION_PANEL
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using AOT;
using ExitGames.Client.Photon;
using LIV.SDK.Unity;
using MK.Glow.Legacy;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using Photon.Chat;
using Photon.Pun;
using Photon.Realtime;
using Photon.Voice.PUN;
using Photon.Voice.Unity;
using Photon.Voice.Unity.UtilityScripts;
using Progreso;
using TMPro;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.SpatialTracking;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;
using Valve.VR;
using VolumetricFogAndMist;
using VortexStudios.PostProcessing;
using ns3dRudder;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
[HelpURL("https://3drudder-dev.com/docs/3drudder-documentations/3drudder-sdk-unity/")]
public class Controller3dRudder : MonoBehaviour
{
	public uint PortNumber;

	public bool CanForward = true;

	public float SpeedForwardBackward = 1f;

	public bool CanStrafe = true;

	public float SpeedLeftRight = 1f;

	public bool CanUpDown;

	public float SpeedUpDown = 1f;

	public bool CanRotate = true;

	public float SpeedRotation = 1f;

	public IAxesParam axesParam;

	private IEnumerator Start()
	{
		yield return null;
	}

	private void Update()
	{
	}

	private void GetAxes()
	{
	}
}
public class Manager3dRudder : MonoBehaviour
{
	private static Manager3dRudder instance;

	public bool IsInitialized;

	public static Manager3dRudder Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Manager3dRudder>();
				if (instance == null)
				{
					GameObject obj = new GameObject
					{
						name = typeof(Manager3dRudder).Name,
						hideFlags = HideFlags.HideInHierarchy
					};
					instance = obj.AddComponent<Manager3dRudder>();
					UnityEngine.Object.DontDestroyOnLoad(obj);
				}
			}
			return instance;
		}
	}

	private void Awake()
	{
		Sdk3dRudder.Initialize();
		IsInitialized = true;
	}

	private void OnApplicationQuit()
	{
		Sdk3dRudder.Stop();
	}
}
public class oculusTest : MonoBehaviour
{
	private int indexDerecha;

	private int indexIzquierda;

	private bool mandoDerechoCargado;

	private bool mandoIzquierdoCargado;

	private MandoOculusT mandoDerecho;

	private MandoOculusT mandoIzquierdo;

	private MandoOculusT tracker;

	public Transform d;

	public Transform i;

	private void Start()
	{
		mandoDerecho = new MandoOculusT(XRNode.RightHand);
		mandoDerechoCargado = true;
		mandoIzquierdo = new MandoOculusT(XRNode.LeftHand);
		mandoIzquierdoCargado = true;
	}

	private void Update()
	{
		if (mandoDerechoCargado)
		{
			mandoDerecho.LeerBotones();
			d.localPosition = mandoDerecho.localPosition;
			d.localRotation = mandoDerecho.localrotation;
		}
		if (mandoIzquierdoCargado)
		{
			mandoIzquierdo.LeerBotones();
			i.localPosition = mandoIzquierdo.localPosition;
			i.localRotation = mandoIzquierdo.localrotation;
		}
	}
}
public class MandoOculusT
{
	public XRNode index;

	public float trigger;

	public bool triggerPress;

	public bool triggerUp;

	public bool triggerDown;

	public float grip;

	public bool gripPress;

	public bool gripPressDown;

	public bool gripPressUp;

	public bool botonAplicationPress;

	public bool botonAplicationPressDown;

	public bool botonAplicationPressUp;

	public bool touchPress;

	public bool touchPressUp;

	public bool touchPressDown;

	public Vector2 stick;

	public bool botonAXOculusPress;

	public bool botonAXOculusPressUp;

	public bool botonAXOculusPressDown;

	public bool botonBYOculusPress;

	public bool botonBYOculusPressUp;

	public bool botonBYOculusPressDown;

	public bool botonMenu;

	public Vector3 velocidadMando;

	public bool algunBotonTocado;

	private bool pulsandoTrigger;

	private bool pulsandoGrip;

	private bool pulsandoAX;

	private bool pulsandoBY;

	private bool pulsandoMenu;

	public Vector3 localPosition = Vector3.zero;

	public Quaternion localrotation = Quaternion.identity;

	public MandoOculusT(XRNode index)
	{
		this.index = index;
	}

	public void LeerBotones()
	{
		localPosition = ((index == XRNode.RightHand) ? OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch) : OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch));
		localrotation = ((index == XRNode.RightHand) ? OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch) : OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch));
	}
}
public class ApagameSiEsCalidadBaja : MonoBehaviour
{
	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class LanguageManager
{
	public TMP_FontAsset fuenteOccidental;

	public TMP_FontAsset fuenteOccidentalNegra;

	public TMP_FontAsset fuenteOccidentalSinBorde;

	public Font fuenteStandardOccidental;

	public TMP_FontAsset fuenteJaponesa;

	public TMP_FontAsset fuenteJaponesaNegra;

	public TMP_FontAsset fuenteJaponesaSinBorde;

	public Font fuenteStandardJaponesa;

	public TMP_FontAsset fuenteChina;

	public TMP_FontAsset fuenteChinaNegra;

	public TMP_FontAsset fuenteChinaSinBorde;

	public Font fuenteStandardChina;

	public TMP_FontAsset fuenteKoreana;

	public TMP_FontAsset fuenteKoreanaNegra;

	public TMP_FontAsset fuenteKoreanaSinBorde;

	public Font fuenteStandardKoreana;

	public TMP_FontAsset fuenteRusa;

	public TMP_FontAsset fuenteRusaNegra;

	public TMP_FontAsset fuenteRusaSinBorde;

	public Font fuenteStandardRusa;

	private static LanguageManager sharedinstance;

	[HideInInspector]
	public UnityEvent enCambioDeIdioma;

	private List<string> idiomas = new List<string> { "English", "Spanish", "Chinese", "Japanese", "Korean" };

	private Dictionary<string, string> Idioma = new Dictionary<string, string>();

	public string idiomaActual;

	public static LanguageManager instance
	{
		get
		{
			if (sharedinstance == null)
			{
				PersistentDataManager.LoadData();
				sharedinstance = new LanguageManager();
				return sharedinstance;
			}
			return sharedinstance;
		}
	}

	public LanguageManager()
	{
		string text = UnityEngine.Application.systemLanguage.ToString();
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Chinese)
		{
			text = "Chinese";
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.ChineseTraditional)
		{
			text = "Chinese";
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.ChineseSimplified)
		{
			text = "Chinese";
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Catalan)
		{
			text = "Spanish";
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Basque)
		{
			text = "Spanish";
		}
		if (text == "Portuguese")
		{
			text = "Brazilian";
		}
		enCambioDeIdioma = new UnityEvent();
		fuenteOccidental = Resources.Load<TMP_FontAsset>("Font/Go-Medium SDF");
		fuenteOccidentalNegra = Resources.Load<TMP_FontAsset>("Fuentes/Fuente_Occidental_Negra");
		fuenteOccidentalSinBorde = Resources.Load<TMP_FontAsset>("Fuentes/Fuente_Occidental_StandardSinBorde");
		fuenteStandardOccidental = Resources.Load<Font>("Fuentes/FuenteStandard_Occidental");
		fuenteJaponesaSinBorde = Resources.Load<TMP_FontAsset>("Font/Fuente_Japonesa");
		fuenteJaponesa = Resources.Load<TMP_FontAsset>("Font/Fuente_Japonesa");
		fuenteJaponesaNegra = Resources.Load<TMP_FontAsset>("Font/Fuente_Japonesa");
		fuenteStandardJaponesa = Resources.Load<Font>("Font/FuenteStandard_Japones");
		fuenteKoreanaSinBorde = Resources.Load<TMP_FontAsset>("Font/Fuente_Koreano");
		fuenteKoreana = Resources.Load<TMP_FontAsset>("Font/Fuente_Koreano");
		fuenteKoreanaNegra = Resources.Load<TMP_FontAsset>("Font/Fuente_Koreano");
		fuenteStandardKoreana = Resources.Load<Font>("Font/FuenteStandard_Koreano");
		fuenteChinaSinBorde = Resources.Load<TMP_FontAsset>("Font/chino_pang");
		fuenteChina = Resources.Load<TMP_FontAsset>("Font/chino_pang");
		fuenteChinaNegra = Resources.Load<TMP_FontAsset>("Font/chino_pang");
		fuenteStandardChina = Resources.Load<Font>("Font/fuenteChina2");
		fuenteRusaSinBorde = Resources.Load<TMP_FontAsset>("Font/Go-Medium SDF");
		fuenteRusa = Resources.Load<TMP_FontAsset>("Fuentes/Fuente_Ruso_Standard");
		fuenteRusaNegra = Resources.Load<TMP_FontAsset>("Fuentes/Fuente_Ruso_Negra");
		PersistentDataManager.LoadData();
		if (PersistentDataManager.HasKey("Language"))
		{
			idiomaActual = PersistentDataManager.GetString("Language");
		}
		else
		{
			idiomaActual = text;
		}
		if (idiomaActual == "Portuguese")
		{
			idiomaActual = "Brazilian";
		}
		if (ComprobarSiExisteIdioma(idiomaActual))
		{
			PersistentDataManager.SetString("Language", idiomaActual);
		}
		else
		{
			UnityEngine.Debug.Log("El idioma del dispositivo no se encuentra en la lista. Estableciendo 'English' como idioma por defecto");
			idiomaActual = idiomas[0];
			PersistentDataManager.SetString("Language", idiomaActual);
		}
		if (idiomaActual == "Chinese" && !Config.verisionConOnlineCompletamenteAnulado)
		{
			GameManager.instance.verisionConOnlineCompletamenteAnulado = true;
		}
		CargarIdioma(idiomaActual);
	}

	private void CargarIdioma(string idiomaActual)
	{
		if (idiomaActual == "Portuguese")
		{
			idiomaActual = "Brazilian";
		}
		StringReader stringReader = new StringReader(((TextAsset)Resources.Load("Language/" + idiomaActual)).text);
		Idioma.Clear();
		string text;
		while ((text = stringReader.ReadLine()) != null)
		{
			try
			{
				if (text.Length <= 0 || text[0] != '"')
				{
					continue;
				}
				text = text.Replace("\"", "");
				text = text[..text.IndexOf(";")];
				string[] array = text.Split("="[0]);
				if (array != null && array.Length >= 2)
				{
					array[0] = array[0].Replace(" ", "");
					array[1] = array[1].Substring(1, array[1].Length - 1);
					if (!Idioma.ContainsKey(array[0]))
					{
						Idioma.Add(array[0], array[1]);
					}
				}
			}
			catch
			{
				UnityEngine.Debug.Log("sofiso");
			}
		}
		stringReader.Close();
	}

	public string DameTexto(string key, TextMeshProUGUI texto = null, bool fuenteNegra = false, bool fuenteAzulSinBorde = false, bool cambioDeFuente = true)
	{
		TMP_FontAsset fuentePro = GetFuentePro();
		if ((bool)texto && (bool)fuentePro)
		{
			texto.font = GetFuentePro(fuenteNegra, fuenteAzulSinBorde, cambioDeFuente);
		}
		string text = "";
		text = ((!Idioma.ContainsKey(key)) ? key : Idioma[key]);
		text = text.Replace("~", "\n");
		return text.Replace("∫", "");
	}

	public bool EsIdiomaEspecial()
	{
		return idiomaActual switch
		{
			"Chinese" => true, 
			"Japanese" => true, 
			"Korean" => true, 
			"Russian" => true, 
			_ => false, 
		};
	}

	public TMP_FontAsset GetFuentePro(bool fuenteNegra = false, bool fuenteAzulSinBorde = false, bool cambioDeFuente = true)
	{
		return idiomaActual switch
		{
			"Chinese" => fuenteChina, 
			"Japanese" => fuenteJaponesa, 
			"Korean" => fuenteKoreana, 
			"Russian" => fuenteRusa, 
			_ => null, 
		};
	}

	public Font GetFuenteStandar()
	{
		return idiomaActual switch
		{
			"Chinese" => fuenteStandardChina, 
			"Japanese" => fuenteStandardJaponesa, 
			"Korean" => fuenteStandardKoreana, 
			"Russian" => fuenteStandardRusa, 
			_ => null, 
		};
	}

	public string DameTexto(string key, Text texto = null, bool cambioDeFuente = true)
	{
		Font fuenteStandar = GetFuenteStandar();
		if ((bool)texto && (bool)fuenteStandar)
		{
			texto.font = fuenteStandar;
		}
		string text = "";
		text = ((!Idioma.ContainsKey(key)) ? key : Idioma[key]);
		text = text.Replace("~", "\n");
		return text.Replace("∫", "");
	}

	public string DameTexto(string key)
	{
		string text = "";
		text = ((!Idioma.ContainsKey(key)) ? key : Idioma[key]);
		text = text.Replace("~", "\n");
		return text.Replace("∫", "");
	}

	public void CambiarIdioma()
	{
		int num = idiomas.IndexOf(idiomaActual);
		if (num == idiomas.Count - 1)
		{
			idiomaActual = idiomas[0];
		}
		else
		{
			idiomaActual = idiomas[num + 1];
		}
		PersistentDataManager.SetString("Language", idiomaActual);
		if (idiomaActual == "Chinese" && !Config.verisionConOnlineCompletamenteAnulado)
		{
			GameManager.instance.verisionConOnlineCompletamenteAnulado = true;
		}
		else if (idiomaActual != "Chinese" && !Config.verisionConOnlineCompletamenteAnulado)
		{
			GameManager.instance.verisionConOnlineCompletamenteAnulado = false;
		}
		CargarIdioma(idiomaActual);
	}

	public void EventoCambioIdioma()
	{
		enCambioDeIdioma.Invoke();
	}

	private bool ComprobarSiExisteIdioma(string idioma)
	{
		bool result = false;
		for (int i = 0; i < idiomas.Count; i++)
		{
			if (idioma == idiomas[i])
			{
				result = true;
				break;
			}
			result = false;
		}
		return result;
	}
}
[RequireComponent(typeof(TextMeshProUGUI))]
public class TraducirEsteTexto : MonoBehaviour
{
	[HideInInspector]
	public string textoOriginal;

	private TextMeshProUGUI texto;

	public bool fuenteNegra;

	public bool fuenteSinBorde;

	public bool enMinuscula;

	public bool enMayuscula;

	public bool combinar;

	public bool cambiarFuente = true;

	private void Awake()
	{
		texto = GetComponent<TextMeshProUGUI>();
		textoOriginal = texto.text;
	}

	private void OnEnable()
	{
		LanguageManager.instance.enCambioDeIdioma.AddListener(TraducemeEsto);
		if (combinar)
		{
			Combinar();
			return;
		}
		string text = LanguageManager.instance.DameTexto(textoOriginal, texto, fuenteNegra, fuenteSinBorde, cambiarFuente);
		if (enMinuscula && text.Length > 0)
		{
			text = text.Substring(0, 1).ToUpper() + text.Substring(1, text.Length - 1).ToLower();
		}
		else if (enMayuscula && text.Length > 0)
		{
			text = text.ToUpper();
		}
		texto.text = text;
	}

	private void OnDisable()
	{
		LanguageManager.instance.enCambioDeIdioma.RemoveListener(TraducemeEsto);
	}

	private void TraducemeEsto()
	{
		if (combinar)
		{
			Combinar();
			return;
		}
		texto.text = LanguageManager.instance.DameTexto(textoOriginal, texto, fuenteNegra, fuenteSinBorde, cambiarFuente);
		if (enMayuscula)
		{
			string text = texto.text;
			text = text.ToUpper();
			texto.text = text;
		}
	}

	private void Combinar()
	{
		string text = textoOriginal;
		string text2 = "";
		for (int num = textoOriginal.IndexOf('*'); num != -1; num = text.IndexOf('*'))
		{
			string text3 = "";
			text3 = text.Substring(0, num);
			text = text.Substring(num + 1, text.Length - (num + 1));
			text2 = ((text3[0] != '#') ? (text2 + text3 + " ") : (text2 + LanguageManager.instance.DameTexto(text3, texto, fuenteNegra, fuenteSinBorde, cambiarFuente) + " "));
		}
		texto.text = text2;
	}
}
public class TraducirEsteTextoNormal : MonoBehaviour
{
	[HideInInspector]
	public string textoOriginal;

	private Text texto;

	private TextMesh textoM;

	private TextMeshPro textoP;

	public bool TextMesh;

	public bool TextMeshPro;

	public bool fuenteNegra;

	private void Awake()
	{
		if (TextMesh)
		{
			textoM = GetComponent<TextMesh>();
			textoOriginal = textoM.text;
		}
		else if (TextMeshPro)
		{
			textoP = GetComponent<TextMeshPro>();
			textoOriginal = textoP.text;
		}
		else
		{
			texto = GetComponent<Text>();
			textoOriginal = texto.text;
		}
	}

	private void OnEnable()
	{
		if (TextMesh)
		{
			textoM.text = LanguageManager.instance.DameTexto(textoOriginal);
			if ((bool)LanguageManager.instance.GetFuenteStandar())
			{
				textoM.font = LanguageManager.instance.GetFuenteStandar();
			}
		}
		else if (TextMeshPro)
		{
			textoP.text = LanguageManager.instance.DameTexto(textoOriginal, texto);
			if ((bool)LanguageManager.instance.GetFuenteStandar())
			{
				textoP.font = LanguageManager.instance.GetFuentePro();
			}
		}
		else
		{
			texto.text = LanguageManager.instance.DameTexto(textoOriginal);
			if ((bool)LanguageManager.instance.GetFuenteStandar())
			{
				texto.font = LanguageManager.instance.GetFuenteStandar();
			}
		}
		LanguageManager.instance.enCambioDeIdioma.AddListener(TraducemeEsto);
	}

	private void OnDisable()
	{
		LanguageManager.instance.enCambioDeIdioma.RemoveListener(TraducemeEsto);
	}

	private void TraducemeEsto()
	{
		if (TextMesh)
		{
			textoM.text = LanguageManager.instance.DameTexto(textoOriginal, texto);
		}
		else if (TextMeshPro)
		{
			textoP.text = LanguageManager.instance.DameTexto(textoOriginal, texto);
		}
		else
		{
			texto.text = LanguageManager.instance.DameTexto(textoOriginal, texto);
		}
	}
}
public class LoadingCamera : MonoBehaviour
{
	public enum EstadosCamaraLoading
	{
		desactivada,
		enTransicion,
		pantallaNegraActivada,
		cargandoEscena
	}

	public static LoadingCamera instance;

	public Image fondoNegro;

	public GameObject canvasLoading;

	public Transform posicionCabeza;

	public Transform camara;

	private Camera m_camera;

	public EstadosCamaraLoading estadoActual;

	private Coroutine corrutina;

	public bool pararCorrutina;

	private Coroutine cargandoEscena;

	private void RecolocarCamara()
	{
		camara.parent.position = posicionCabeza.position;
		Vector3 vector = camara.transform.position - posicionCabeza.position;
		camara.parent.position -= vector;
	}

	private void Update()
	{
		if (estadoActual != 0 && (bool)GameManager.instance.player)
		{
			base.transform.rotation = GameManager.instance.player.cabeza.transform.rotation;
		}
	}

	private void Awake()
	{
		base.transform.SetParent(null);
		if (instance != null && instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		estadoActual = EstadosCamaraLoading.desactivada;
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		m_camera = camara.GetComponent<Camera>();
		m_camera.enabled = false;
		RecolocarCamara();
	}

	public Coroutine ActivarCamaraNegraAsync(float velocidad = 1f)
	{
		return StartCoroutine(ActivarPantallaNegraSync(velocidad));
	}

	public void ActivarCamaraNegraInstantanea()
	{
		StartCoroutine(ActivarPantallaNegraSync(999f));
	}

	public IEnumerator ActivarPantallaNegraSync(float velocidad = 1f)
	{
		canvasLoading.SetActive(value: true);
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			velocidad *= 3f;
		}
		if (estadoActual == EstadosCamaraLoading.enTransicion)
		{
			yield break;
		}
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			_ = (bool)GameManager.instance.player;
		}
		m_camera.enabled = true;
		RecolocarCamara();
		estadoActual = EstadosCamaraLoading.enTransicion;
		Color aux = fondoNegro.color;
		float t = 0f;
		while (t < 1f)
		{
			if (pararCorrutina)
			{
				yield break;
			}
			t += Time.unscaledDeltaTime * velocidad;
			if (t > 1f)
			{
				t = 1f;
			}
			AudioListener.volume = 1f - t;
			aux.a = t;
			fondoNegro.color = aux;
			yield return null;
		}
		m_camera.clearFlags = CameraClearFlags.Color;
		estadoActual = EstadosCamaraLoading.pantallaNegraActivada;
		AudioListener.volume = 0f;
		if (Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			PersistentDataManager.SaveData();
		}
	}

	public void TerminarTodasLasCorrutinas()
	{
		StopAllCoroutines();
	}

	public Coroutine DesactivarCamaraNegraAsync()
	{
		return StartCoroutine(DesactivarPantallaNegraSync(0.5f));
	}

	public IEnumerator DesactivarPantallaNegraSync(float velocidad = 1f)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			velocidad *= 3f;
		}
		canvasLoading.SetActive(value: true);
		estadoActual = EstadosCamaraLoading.enTransicion;
		m_camera.clearFlags = CameraClearFlags.Depth;
		Color aux = fondoNegro.color;
		float t = 0f;
		while (t < 1f)
		{
			if (pararCorrutina)
			{
				yield break;
			}
			t += Time.unscaledDeltaTime * velocidad;
			if (t > 1f)
			{
				t = 1f;
			}
			aux.a = 1f - t;
			fondoNegro.color = aux;
			AudioListener.volume = t;
			yield return null;
		}
		estadoActual = EstadosCamaraLoading.desactivada;
		m_camera.enabled = false;
		AudioListener.volume = 1f;
	}

	public void CargarEscena(string escena)
	{
		Time.timeScale = 1f;
		if (cargandoEscena == null)
		{
			if ((bool)GameManager.instance && escena == "MenuPrincipal")
			{
				GameManager.instance.bloquearBotones = false;
			}
			cargandoEscena = StartCoroutine(CargarEscenaAsync(escena));
		}
	}

	public IEnumerator CargarEscenaAsync(string escena)
	{
		if (estadoActual == EstadosCamaraLoading.desactivada)
		{
			yield return ActivarPantallaNegraSync(0.5f);
		}
		yield return new WaitForSecondsRealtime(0.5f);
		estadoActual = EstadosCamaraLoading.cargandoEscena;
		yield return new WaitForSecondsRealtime(1f);
		_ = escena;
		UnityEngine.Debug.Log("Cargando escena: " + escena);
		AsyncOperation async = SceneManager.LoadSceneAsync(escena);
		async.allowSceneActivation = false;
		float t = 0f;
		while (t < 0.9f)
		{
			t = async.progress;
			yield return null;
		}
		yield return new WaitForSeconds(1f);
		yield return null;
		cargandoEscena = null;
		async.allowSceneActivation = true;
		while (Config.modoDeJuego != Config.ModosDeJuego.menu && (!GameManager.instance || !GameManager.instance.m_salaManager || !GameManager.instance.m_salaManager.salaCargada))
		{
			yield return new WaitForSeconds(0.5f);
		}
		yield return new WaitForSeconds(1f);
		yield return DesactivarPantallaNegraSync(0.5f);
		m_camera.enabled = false;
	}
}
public class ControladorNaveAdorno : MonoBehaviour
{
	[Serializable]
	public struct Nave
	{
		public Transform tNave;

		public Transform posicionDestino;

		public float velocidadNave;

		public int frecuenciaDeSalida;

		public float esperaParaSalir;

		public float ultimaVezQueSali;

		public bool activo;
	}

	[SerializeField]
	private Vector3 areaSize;

	[SerializeField]
	private float velocidadRotacion = 1f;

	[SerializeField]
	private Nave[] naves;

	private Vector3 direccionObjetivo;

	private int direccionMovimiento;

	private int ticksSubiendoArtificialmente;

	public bool variarDireccionDeMovimiento = true;

	public IEnumerator CorotinaAnimacionDesaparicion(Nave nave)
	{
		float t = 0f;
		float escalaBase = nave.tNave.localScale.x;
		while (t < 1f)
		{
			t += Time.deltaTime / 2f;
			if (t > 1f)
			{
				t = 1f;
			}
			float num = Mathf.Lerp(escalaBase, 0.01f, t);
			nave.tNave.localScale = Vector3.one * num;
			yield return null;
		}
	}

	private void Start()
	{
		direccionMovimiento = 1;
		for (int i = 0; i < naves.Length; i++)
		{
			CalcularSiguienteDestino(i);
		}
	}

	private void CalcularSiguienteDestino(int indexNave)
	{
		naves[indexNave].tNave.localScale = Vector3.one;
		naves[indexNave].ultimaVezQueSali = Time.time;
		naves[indexNave].esperaParaSalir = UnityEngine.Random.Range(naves[indexNave].frecuenciaDeSalida / 2, naves[indexNave].frecuenciaDeSalida);
		naves[indexNave].activo = false;
		Vector3 localPosition = default(Vector3);
		localPosition.y = UnityEngine.Random.Range((0f - areaSize.y) / 2f, areaSize.y / 2f);
		if (indexNave > 0 && localPosition.y == naves[indexNave - 1].tNave.position.y)
		{
			localPosition.y += areaSize.y / 8f;
		}
		naves[indexNave].tNave.gameObject.SetActive(value: false);
		switch (direccionMovimiento)
		{
		case -1:
			localPosition.x = UnityEngine.Random.Range((0f - areaSize.x) / 2f + areaSize.x / 4f, areaSize.x / 2f - areaSize.x / 4f);
			if (localPosition.x > 34f)
			{
				localPosition.x = 34f;
			}
			localPosition.y = 0f;
			localPosition.z = (float)((UnityEngine.Random.Range(0f, 1f) > 0.5f) ? 1 : (-1)) * (areaSize.z / 2f);
			naves[indexNave].posicionDestino.localPosition = localPosition;
			localPosition.x = UnityEngine.Random.Range((0f - areaSize.x) / 2f + areaSize.x / 4f, areaSize.x / 2f - areaSize.x / 4f);
			localPosition.y = 0f;
			localPosition.z = (float)((!(localPosition.z > 0f)) ? 1 : (-1)) * (areaSize.z / 2f);
			naves[indexNave].tNave.localPosition = localPosition;
			break;
		case 1:
			localPosition.x = UnityEngine.Random.Range((0f - areaSize.x) / 2f + areaSize.x / 4f, areaSize.x / 2f - areaSize.x / 4f);
			if (localPosition.x > 34f)
			{
				localPosition.x = 34f;
			}
			localPosition.y = 0f;
			localPosition.z = (float)((UnityEngine.Random.Range(0f, 1f) > 0.5f) ? 1 : (-1)) * (areaSize.z / 2f);
			localPosition.z *= -1f;
			naves[indexNave].posicionDestino.localPosition = localPosition;
			localPosition.x = UnityEngine.Random.Range((0f - areaSize.x) / 2f + areaSize.x / 4f, areaSize.x / 2f - areaSize.x / 4f);
			localPosition.y = 0f;
			localPosition.z = (float)((!(localPosition.z > 0f)) ? 1 : (-1)) * (areaSize.z / 2f);
			localPosition.z *= -1f;
			naves[indexNave].tNave.localPosition = localPosition;
			break;
		}
		naves[indexNave].tNave.rotation = Quaternion.LookRotation((naves[indexNave].posicionDestino.position - naves[indexNave].tNave.position).normalized);
		if (variarDireccionDeMovimiento)
		{
			direccionMovimiento *= -1;
		}
		ticksSubiendoArtificialmente = 0;
	}

	public IEnumerator CorotinaSiguientedestino(int i)
	{
		yield return new WaitForSeconds(3f);
		CalcularSiguienteDestino(i);
	}

	private void Update()
	{
		for (int i = 0; i < naves.Length; i++)
		{
			if (naves[i].activo)
			{
				float num = Vector3.Distance(naves[i].tNave.position, naves[i].posicionDestino.position);
				if (Vector3.Distance(naves[i].tNave.position, naves[i].posicionDestino.position) >= 0.8f)
				{
					if (num < 200f)
					{
						if (naves[i].posicionDestino.localPosition.x > 30f)
						{
							naves[i].posicionDestino.localPosition = new Vector3(25f, naves[i].posicionDestino.localPosition.y, naves[i].posicionDestino.localPosition.z);
						}
						if (ticksSubiendoArtificialmente < 50)
						{
							naves[i].tNave.LookAt(naves[i].posicionDestino.position);
							ticksSubiendoArtificialmente++;
						}
						naves[i].tNave.localScale = Vector3.Lerp(Vector3.one, Vector3.zero, 1f - num / 200f);
					}
					naves[i].tNave.gameObject.SetActive(value: true);
					direccionObjetivo = (naves[i].posicionDestino.position - naves[i].tNave.position).normalized;
					naves[i].tNave.localPosition = Vector3.MoveTowards(naves[i].tNave.localPosition, naves[i].posicionDestino.localPosition, Time.deltaTime * naves[i].velocidadNave);
				}
				else
				{
					CalcularSiguienteDestino(i);
				}
			}
			else if (Time.time - naves[i].ultimaVezQueSali > naves[i].esperaParaSalir)
			{
				naves[i].activo = true;
			}
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.DrawWireCube(base.transform.position, areaSize);
	}
}
public class RotacionEnCadena : MonoBehaviour
{
	public enum SituacionDelJugador
	{
		desconocido,
		cerca,
		lejos
	}

	public List<Transform> partes;

	private Vector3[] escalaInicialPartes;

	public float coldDownRotacion = 1.5f;

	public float VelocidadLerpEscalaRotacion = 5f;

	public float velocidadMovimiento = 5f;

	public float distanciaEntreObjetos = -1.25f;

	private bool puedoGirar;

	private float tGrioPrincipal;

	private float ultimaVezQueCambie;

	private Quaternion giroDestino;

	public float maximaEscala = 4f;

	public Transform objetoQueSigo;

	public bool escalaUniforme;

	public bool sinRotacion;

	public int distanciaAlaQueTengoQueActivarme = 38;

	public Vector3 posicion;

	private int ticksSinActualizar;

	public SituacionDelJugador situacionDelJugador;

	private void Start()
	{
		escalaInicialPartes = new Vector3[partes.Count];
		for (int i = 0; i < partes.Count; i++)
		{
			escalaInicialPartes[i] = partes[i].localScale;
		}
		situacionDelJugador = SituacionDelJugador.cerca;
	}

	private void Update()
	{
		ticksSinActualizar++;
		ticksSinActualizar = 0;
		_ = GameManager.instance.player.cabeza.transform.position;
		_ = base.transform.position;
		situacionDelJugador = SituacionDelJugador.cerca;
		if (situacionDelJugador == SituacionDelJugador.lejos)
		{
			return;
		}
		puedoGirar = true;
		giroDestino = partes[0].localRotation * Quaternion.Euler(Vector3.forward * 45f);
		ultimaVezQueCambie = Time.time;
		for (int i = 0; i < partes.Count; i++)
		{
			_ = Vector3.one * Mathf.Lerp(escalaInicialPartes[i].x, maximaEscala, Time.deltaTime);
			if (i == 0)
			{
				if (objetoQueSigo != null)
				{
					float num = 1f;
					_ = Vector3.up * num + Vector3.forward * num;
					partes[i].position = Vector3.Lerp(partes[i].position, objetoQueSigo.position, Time.deltaTime * 1f);
				}
			}
			else
			{
				try
				{
					partes[i].localRotation = Quaternion.Lerp(partes[i].localRotation, partes[i - 1].localRotation, Time.deltaTime * VelocidadLerpEscalaRotacion);
					partes[i].position = Vector3.Lerp(partes[i].position, partes[i - 1].position + posicion * distanciaEntreObjetos, Time.deltaTime * velocidadMovimiento);
				}
				catch
				{
				}
			}
		}
	}
}
public class EfectoDesaparecer : MonoBehaviour
{
	private Texture texturaSlice;

	public Renderer[] renderers;

	public GameObject[] objetosQueApagarDirectamente;

	public bool sinDestruir;

	public bool sinTiempoLento;

	public bool usarTexturaNivel;

	public bool hacerEfectoVerde;

	[HideInInspector]
	public bool efectoEnSala;

	public bool autoGetRender;

	public GameObject efectoDesaparecerPrefab;

	public Shader shaderDesaparecer;

	public Texture texturaSliceDefault;

	public Texture myText;

	public bool esferaEstaDesapareciendo;

	public ParticleSystem particulasExplosionEsfera;

	public bool fueraDePool;

	public float velocidadAparicion = 1f;

	public float velocidadDesaparicion = 1f;

	[HideInInspector]
	public Bola bola;

	private bool porAparecer;

	private bool apagar = true;

	private Coroutine aparecerCor;

	private Coroutine efectoYDestruirObjeto;

	private List<Material> materiales = new List<Material>();

	private List<Material> startMaterials = new List<Material>();

	private void OnEnable()
	{
	}

	public void Disable()
	{
		if (efectoYDestruirObjeto != null)
		{
			StopCoroutine(efectoYDestruirObjeto);
		}
		if (aparecerCor != null)
		{
			StopCoroutine(aparecerCor);
		}
		base.enabled = false;
		esferaEstaDesapareciendo = false;
		if (startMaterials == null || startMaterials.Count <= 0)
		{
			return;
		}
		int num = 0;
		for (int i = 0; i < renderers.Length; i++)
		{
			Material[] array = new Material[renderers[i].materials.Length];
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				array[j] = startMaterials[num];
				num++;
			}
			renderers[i].materials = array;
		}
	}

	private void OnDisable()
	{
		if (efectoYDestruirObjeto != null)
		{
			StopCoroutine(efectoYDestruirObjeto);
			efectoYDestruirObjeto = null;
		}
		if (aparecerCor != null)
		{
			StopCoroutine(aparecerCor);
			aparecerCor = null;
		}
		if (!sinDestruir && !porAparecer)
		{
			if (!fueraDePool)
			{
				if (GetComponent<PhotonView>().IsMine)
				{
					PoolObjetos.instance.Eliminar(base.gameObject);
				}
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		base.enabled = false;
		esferaEstaDesapareciendo = false;
		int num = 0;
		for (int i = 0; i < renderers.Length; i++)
		{
			Material[] array = new Material[renderers[i].materials.Length];
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				try
				{
					array[j] = startMaterials[num];
				}
				catch
				{
					UnityEngine.Debug.Log("sldijfdlsi");
				}
				num++;
			}
			renderers[i].materials = array;
		}
		startMaterials.Clear();
	}

	public void Aparecer(bool blackTexture = false, bool deleteTexturaBase = false)
	{
		if (aparecerCor != null && startMaterials.Count > 0)
		{
			StopCoroutine(aparecerCor);
			aparecerCor = null;
			int num = 0;
			for (int i = 0; i < renderers.Length; i++)
			{
				Material[] array = new Material[renderers[i].materials.Length];
				for (int j = 0; j < renderers[i].materials.Length; j++)
				{
					array[j] = startMaterials[num];
					num++;
				}
				renderers[i].materials = array;
			}
		}
		porAparecer = true;
		if (blackTexture)
		{
			myText = Texture2D.blackTexture;
		}
		if (usarTexturaNivel)
		{
			myText = GameManager.instance.m_salaManager.matNivel.mainTexture;
		}
		if (!bola)
		{
			bola = GetComponent<Bola>();
		}
		if ((bool)bola)
		{
			if (bola.GetEquipo() == GameManager.instance.player.miEquipo || bola.GetEquipo() == 9)
			{
				Color32 color = new Color32(byte.MaxValue, 210, 210, 1);
				Texture2D texture2D = (Texture2D)myText;
				Color32[] pixels = texture2D.GetPixels32();
				for (int k = 0; k < pixels.Length; k++)
				{
					pixels[k] = color;
				}
				texture2D.SetPixels32(pixels);
				texture2D.Apply();
				myText = texture2D;
			}
			else if (bola.GetEquipo() != GameManager.instance.player.miEquipo && bola.GetEquipo() != 9)
			{
				Color32 color2 = new Color32(210, 210, byte.MaxValue, 1);
				Texture2D texture2D2 = (Texture2D)myText;
				Color32[] pixels2 = texture2D2.GetPixels32();
				for (int l = 0; l < pixels2.Length; l++)
				{
					pixels2[l] = color2;
				}
				texture2D2.SetPixels32(pixels2);
				texture2D2.Apply();
				myText = texture2D2;
			}
		}
		base.gameObject.SetActive(value: true);
		apagar = false;
		base.enabled = true;
		esferaEstaDesapareciendo = true;
		Renderer[] components;
		if (autoGetRender)
		{
			components = GetComponents<MeshRenderer>();
			renderers = components;
		}
		materiales.Clear();
		bool flag = false;
		components = renderers;
		for (int m = 0; m < components.Length; m++)
		{
			Material[] materials = components[m].materials;
			foreach (Material material in materials)
			{
				materiales.Add(material);
				if (material.shader != shaderDesaparecer)
				{
					if (!flag)
					{
						startMaterials.Clear();
					}
					flag = true;
					startMaterials.Add(new Material(material));
				}
			}
		}
		if (efectoYDestruirObjeto != null)
		{
			StopCoroutine(efectoYDestruirObjeto);
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			aparecerCor = StartCoroutine(HacerEfectoAparecer(deleteTexturaBase));
		}
	}

	public void Desaparecer(bool rapido = false)
	{
		if (efectoYDestruirObjeto != null)
		{
			StopCoroutine(efectoYDestruirObjeto);
			int num = 0;
			for (int i = 0; i < renderers.Length; i++)
			{
				Material[] array = new Material[renderers[i].materials.Length];
				for (int j = 0; j < renderers[i].materials.Length; j++)
				{
					array[j] = startMaterials[num];
					num++;
				}
				renderers[i].materials = array;
			}
		}
		porAparecer = false;
		if (!bola)
		{
			bola = GetComponent<Bola>();
		}
		if ((bool)bola)
		{
			if (bola.GetEquipo() == GameManager.instance.player.miEquipo || bola.GetEquipo() == 9)
			{
				Color color = new Color32(byte.MaxValue, 210, 210, 1);
				Texture2D texture2D = (Texture2D)myText;
				Color[] pixels = texture2D.GetPixels();
				for (int k = 0; k < pixels.Length; k++)
				{
					pixels[k] = color;
				}
				texture2D.SetPixels(pixels);
				texture2D.Apply();
				myText = texture2D;
				if ((bool)particulasExplosionEsfera)
				{
					particulasExplosionEsfera.GetComponent<ParticleSystemRenderer>().material.SetColor("_TintColor", color * 7f);
				}
			}
			else if (bola.GetEquipo() != GameManager.instance.player.miEquipo && bola.GetEquipo() != 9)
			{
				Color color2 = new Color32(210, 210, byte.MaxValue, 1);
				Texture2D texture2D2 = (Texture2D)myText;
				Color[] pixels2 = texture2D2.GetPixels();
				for (int l = 0; l < pixels2.Length; l++)
				{
					pixels2[l] = color2;
				}
				texture2D2.SetPixels(pixels2);
				texture2D2.Apply();
				myText = texture2D2;
				if ((bool)particulasExplosionEsfera)
				{
					particulasExplosionEsfera.GetComponent<ParticleSystemRenderer>().material.SetColor("_TintColor", color2 * 7f);
				}
			}
		}
		if (usarTexturaNivel)
		{
			myText = GameManager.instance.m_salaManager.matNivel.mainTexture;
		}
		SphereCollider component = GetComponent<SphereCollider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		apagar = true;
		base.enabled = true;
		esferaEstaDesapareciendo = true;
		Renderer[] components;
		if (autoGetRender)
		{
			components = GetComponents<MeshRenderer>();
			renderers = components;
		}
		components = renderers;
		for (int m = 0; m < components.Length; m++)
		{
			Material[] materials = components[m].materials;
			foreach (Material material in materials)
			{
				materiales.Add(material);
				if (material.shader != shaderDesaparecer)
				{
					startMaterials.Add(new Material(material));
				}
			}
		}
		if ((bool)particulasExplosionEsfera && CalidadManager.instance.GetCalidad() > CalidadManager.Calidad.Baja)
		{
			particulasExplosionEsfera.transform.SetParent(null);
			particulasExplosionEsfera.transform.localScale = base.transform.localScale / 2f;
			particulasExplosionEsfera.gameObject.SetActive(value: true);
			particulasExplosionEsfera.Play();
		}
		if (efectoYDestruirObjeto != null)
		{
			StopCoroutine(efectoYDestruirObjeto);
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			efectoYDestruirObjeto = StartCoroutine(HacerEfectoDesaparecer(rapido));
		}
	}

	private IEnumerator HacerEfectoDesaparecer(bool rapido = false)
	{
		Shader shader = shaderDesaparecer;
		texturaSlice = texturaSliceDefault;
		for (int i = 0; i < materiales.Count; i++)
		{
			materiales[i].shader = shader;
			materiales[i].mainTexture = myText;
			float num = 1.6f;
			if ((bool)particulasExplosionEsfera)
			{
				num = 1.6f;
			}
			materiales[i].SetVector("_Color", Color.white * num);
			materiales[i].SetTexture("_SliceGuide", texturaSlice);
			materiales[i].SetFloat("_SliceAmount", 0.1f);
		}
		float t = 0f;
		while (t < 1f)
		{
			for (int j = 0; j < materiales.Count; j++)
			{
				materiales[j].SetFloat("_SliceAmount", t);
			}
			bool flag = (bool)GameManager.instance && (((bool)NivelCompletado.instance && NivelCompletado.instance.pasandoDeNivel) || ((bool)GameManager.instance.player && GameManager.instance.player.muerto));
			if (sinTiempoLento || rapido || flag)
			{
				t += Time.deltaTime * velocidadDesaparicion;
			}
			else if (TimeManager.GetInstance().GetTiempoMedioGlobal() > 0.1f)
			{
				t += Time.deltaTime * TimeManager.GetInstance().GetTiempoMedioGlobal();
			}
			yield return null;
		}
		if (!sinDestruir)
		{
			PhotonView component = GetComponent<PhotonView>();
			if (!fueraDePool)
			{
				if (((bool)component && component.IsMine) || !component)
				{
					PoolObjetos.instance.Eliminar(base.gameObject);
				}
				else if ((bool)GetComponent<SyncPelota>())
				{
					GetComponent<SyncPelota>().ApagarEncenderMesh(activar: false);
				}
			}
			else if ((bool)component && component.IsMine)
			{
				PhotonNetwork.Destroy(base.gameObject);
			}
			else if (!component)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		esferaEstaDesapareciendo = false;
		efectoYDestruirObjeto = null;
		base.enabled = false;
		if (sinDestruir)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private IEnumerator HacerEfectoAparecer(bool deleteTexturaBase = false)
	{
		Shader shader = shaderDesaparecer;
		texturaSlice = texturaSliceDefault;
		for (int i = 0; i < materiales.Count; i++)
		{
			materiales[i].shader = shader;
			materiales[i].mainTexture = myText;
			float num = 1.6f;
			materiales[i].SetVector("_Color", Color.white * num);
			materiales[i].SetTexture("_SliceGuide", texturaSlice);
			materiales[i].SetFloat("_SliceAmount", 0.1f);
			if (deleteTexturaBase)
			{
				materiales[i].SetTexture("_MainTex", null);
			}
		}
		if (!bola)
		{
			bola = GetComponent<Bola>();
		}
		float t = 1f;
		Material matActual = renderers[0].materials[0];
		while (t > 0f)
		{
			if ((bool)bola && renderers[0].materials[0] != matActual)
			{
				esferaEstaDesapareciendo = false;
				efectoYDestruirObjeto = null;
				Aparecer();
				yield break;
			}
			for (int j = 0; j < materiales.Count; j++)
			{
				if (deleteTexturaBase)
				{
					materiales[j].SetTexture("_MainTex", null);
				}
				materiales[j].SetFloat("_SliceAmount", t);
			}
			t -= Time.deltaTime * velocidadAparicion;
			matActual = renderers[0].materials[0];
			yield return null;
		}
		esferaEstaDesapareciendo = false;
		efectoYDestruirObjeto = null;
		aparecerCor = null;
		base.enabled = false;
	}
}
public class EfectoDesaparecerEscudo : MonoBehaviour
{
	public MeshRenderer mRenderer;

	private Coroutine aparecerEscudoCor;

	public void AparecerEscudo()
	{
		base.enabled = true;
		if (aparecerEscudoCor != null)
		{
			StopCoroutine(aparecerEscudoCor);
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			aparecerEscudoCor = StartCoroutine(HacerEfectoAparecerEscudo());
		}
	}

	private IEnumerator HacerEfectoAparecerEscudo()
	{
		yield return null;
		mRenderer.material.SetFloat("_Opacity", 0f);
		float t = 0f;
		while (t < 1f)
		{
			mRenderer.material.SetFloat("_Opacity", t);
			t += Time.deltaTime;
			yield return null;
		}
		base.enabled = false;
	}

	private void OnDisable()
	{
		if ((bool)mRenderer)
		{
			mRenderer.material.SetFloat("_Opacity", 1f);
		}
		if (aparecerEscudoCor != null)
		{
			StopCoroutine(aparecerEscudoCor);
		}
		base.enabled = false;
	}
}
public static class ME_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material[] materials = componentsInChildren[i].materials;
			if (materials.Length == 0)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				Material[] array2 = materials;
				foreach (Material material in array2)
				{
					if (material.HasProperty(name))
					{
						setMatHUEColor(material, name, hue);
					}
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material[] materials2 = componentsInChildren3[i].materials;
			if (materials2.Length == 0)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				Material[] array2 = materials2;
				foreach (Material material3 in array2)
				{
					if (material3.HasProperty(name3))
					{
						setMatHUEColor(material3, name3, hue);
					}
				}
			}
		}
		MeshRenderer[] componentsInChildren4 = go.GetComponentsInChildren<MeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren4.Length; i++)
		{
			Material[] materials3 = componentsInChildren4[i].materials;
			if (materials3.Length == 0)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				Material[] array2 = materials3;
				foreach (Material material4 in array2)
				{
					if (material4.HasProperty(name4))
					{
						setMatHUEColor(material4, name4, hue);
					}
				}
			}
		}
		Projector[] componentsInChildren5 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren5)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material5 = projector.material;
			if (material5 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name5 in array)
			{
				if (material5.HasProperty(name5))
				{
					projector.material = setMatHUEColor(material5, name5, hue);
				}
			}
		}
		Light[] componentsInChildren6 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren6)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren7 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren7)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int l = 1; l < colorKeys.Length; l++)
			{
				hsbColor2 = ColorToHSV(colorKeys[l].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[l].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class ME_MeshMaterialEffect : MonoBehaviour
{
	public Material Material;

	public bool IsFirstMaterial;
}
[ExecuteInEditMode]
public class PSMeshRendererUpdater : MonoBehaviour
{
	public GameObject MeshObject;

	public Color Color = Color.black;

	private const string materialName = "MeshEffect";

	private List<Material[]> rendererMaterials = new List<Material[]>();

	private List<Material[]> skinnedMaterials = new List<Material[]>();

	private Color oldColor = Color.black;

	private void Start()
	{
		Invoke("Eliminar", 10f);
	}

	private void Update()
	{
		if (Color != oldColor)
		{
			oldColor = Color;
			UpdateColor(Color);
		}
	}

	public void UpdateColor(Color color)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.HSBColor hSBColor = ME_ColorHelper.ColorToHSV(color);
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, hSBColor.H);
		}
	}

	public void UpdateColor(float HUE)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, HUE);
		}
	}

	public void UpdateMeshEffect()
	{
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (!(MeshObject == null))
		{
			UpdatePSMesh(MeshObject);
			AddMaterialToMesh(MeshObject);
		}
	}

	public void UpdateMeshEffect(GameObject go)
	{
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (go == null)
		{
			Debugs.Log("You need set a gameObject");
			return;
		}
		MeshObject = go;
		UpdatePSMesh(MeshObject);
		AddMaterialToMesh(MeshObject);
	}

	private void UpdatePSMesh(GameObject go)
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		MeshRenderer componentInChildren = go.GetComponentInChildren<MeshRenderer>();
		SkinnedMeshRenderer componentInChildren2 = go.GetComponentInChildren<SkinnedMeshRenderer>();
		Light[] componentsInChildren2 = GetComponentsInChildren<Light>();
		ParticleSystem[] array = componentsInChildren;
		foreach (ParticleSystem obj in array)
		{
			obj.transform.gameObject.SetActive(value: false);
			ParticleSystem.ShapeModule shape = obj.shape;
			if (shape.enabled)
			{
				if (componentInChildren != null)
				{
					shape.shapeType = ParticleSystemShapeType.MeshRenderer;
					shape.meshRenderer = componentInChildren;
				}
				if (componentInChildren2 != null)
				{
					shape.shapeType = ParticleSystemShapeType.SkinnedMeshRenderer;
					shape.skinnedMeshRenderer = componentInChildren2;
				}
			}
			obj.transform.gameObject.SetActive(value: true);
		}
		if (componentInChildren != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren.bounds.center;
			}
		}
		if (componentInChildren2 != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren2.bounds.center;
			}
		}
	}

	private void AddMaterialToMesh(GameObject go)
	{
		ME_MeshMaterialEffect componentInChildren = GetComponentInChildren<ME_MeshMaterialEffect>();
		if (!(componentInChildren == null))
		{
			MeshRenderer componentInChildren2 = go.GetComponentInChildren<MeshRenderer>();
			SkinnedMeshRenderer componentInChildren3 = go.GetComponentInChildren<SkinnedMeshRenderer>();
			if (componentInChildren2 != null)
			{
				rendererMaterials.Add(componentInChildren2.sharedMaterials);
				componentInChildren2.sharedMaterials = AddToSharedMaterial(componentInChildren2.sharedMaterials, componentInChildren);
			}
			if (componentInChildren3 != null)
			{
				skinnedMaterials.Add(componentInChildren3.sharedMaterials);
				componentInChildren3.sharedMaterials = AddToSharedMaterial(componentInChildren3.sharedMaterials, componentInChildren);
			}
		}
	}

	private Material[] AddToSharedMaterial(Material[] sharedMaterials, ME_MeshMaterialEffect meshMatEffect)
	{
		if (meshMatEffect.IsFirstMaterial)
		{
			return new Material[1] { meshMatEffect.Material };
		}
		List<Material> list = sharedMaterials.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].name.Contains("MeshEffect"))
			{
				list.RemoveAt(i);
			}
		}
		list.Add(meshMatEffect.Material);
		return list.ToArray();
	}

	private void OnDestroy()
	{
		if (MeshObject == null)
		{
			return;
		}
		MeshRenderer[] componentsInChildren = MeshObject.GetComponentsInChildren<MeshRenderer>();
		SkinnedMeshRenderer[] componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (rendererMaterials.Count == componentsInChildren.Length)
			{
				componentsInChildren[i].sharedMaterials = rendererMaterials[i];
			}
			List<Material> list = componentsInChildren[i].sharedMaterials.ToList();
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].name.Contains("MeshEffect"))
				{
					list.RemoveAt(j);
				}
			}
			componentsInChildren[i].sharedMaterials = list.ToArray();
		}
		for (int k = 0; k < componentsInChildren2.Length; k++)
		{
			if (skinnedMaterials.Count == componentsInChildren2.Length)
			{
				componentsInChildren2[k].sharedMaterials = skinnedMaterials[k];
			}
			List<Material> list2 = componentsInChildren2[k].sharedMaterials.ToList();
			for (int l = 0; l < list2.Count; l++)
			{
				if (list2[l].name.Contains("MeshEffect"))
				{
					list2.RemoveAt(l);
				}
			}
			componentsInChildren2[k].sharedMaterials = list2.ToArray();
		}
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
	}

	private void Eliminar()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
[RequireComponent(typeof(PhotonView))]
public class PartidaSync : MonoBehaviourPunCallbacks, IPunObservable
{
	public class Jugador
	{
		public string nombre = "";

		public int idJugador = -1;

		public int idPhotonObjetoPlayer = int.MinValue;

		public int idJuego = -1;

		public bool isMaster;

		public bool soyJugador;

		public float escalaTiempoJugador;

		public bool estaMuerto;

		public int equipo = -1;

		public int puntos = -1;

		public Jugador(string nombre_, int idJugador_, int idPhotonObjetoPlayer_, int idJuego_, bool master, bool soyJugador_, bool estaMuerto_, int equipo_, int puntos)
		{
			nombre = nombre_;
			idJugador = idJugador_;
			idPhotonObjetoPlayer = idPhotonObjetoPlayer_;
			idJuego = idJuego_;
			isMaster = master;
			soyJugador = soyJugador_;
			estaMuerto = estaMuerto_;
			equipo = equipo_;
		}
	}

	public static PartidaSync instance;

	private bool soyElMasterClient;

	private const int NUM_MAX_JUGADORES_ONLINE = 8;

	public int miIdPhotonObjetoPlayer = -1;

	public List<SyncPelota> pelotasEncendidas = new List<SyncPelota>();

	[HideInInspector]
	public int numPlayersPreparados;

	public Dictionary<int, Jugador> jugadores = new Dictionary<int, Jugador>();

	public Jugador miJugador;

	public List<SyncPelota> pelotasSync = new List<SyncPelota>();

	public int puntuacionEquipo1;

	public int puntuacionEquipo2;

	public int MAXPARTIDASCOMPETITIVO = 7;

	private Transform playerObjetivo;

	private float tiempoSinCambiar;

	[HideInInspector]
	public bool daIgualQueMasterSeDesconecte;

	private Dictionary<int, GameObject> goJugadores = new Dictionary<int, GameObject>();

	private const string RPC_IniciaPartida = "InicializarPartidaPUN";

	private const string RPC_MasterEstosSonMisDatos = "MasterEstosSonMisDatosPUN";

	private const string RPC_Muerte = "MuertePUN";

	private const string RPC_ComunicarMiMuerte = "ComunicarMiMuertePUN";

	private const string RPC_ClienteHasDestruidoUnaEsfera = "ClienteHasDestruidoUnaEsferaPUN";

	private const string RPC_ClienteHazRebotarElGancho = "ClienteHazRebotarElGanchoPUN";

	private const string RPC_MasterHeDestruidoUnaEsfera = "MasterHeDestruidoUnaEsferaPUN";

	private const string RPC_MasterHeDestruidoUnEscudo = "MasterHeDestruidoUnEscudoPUN";

	private const string RPC_ClienteATuBalaLeQuedanXUsos = "ClienteATuBalaLeQuedanXUsosPUN";

	private const string RPC_MasterHeDadoAUnaMina = "MasterHeDadoAUnaMinaPUN";

	private const string RPC_RefrescarListaJugadores = "RefrescarListaJugadoresPUN";

	private const string RPC_MasterHeCogidoLasPistolas = "MasterHeCogidoLasPistolasPUN";

	private const string RPC_QueEmpieceElJuego = "QueEmpieceElJuegoPUN";

	private const string RPC_ClientesPasadDeNivel = "ClientesPasadDeNivelPUN";

	private const string RPC_QuitarTutoPowerUp = "QuitarTutoPowerUpPUN";

	private const string RPC_ActivarPowerUp = "ActivarPowerUpPUN";

	private const string RPC_EstamosTodosMuertos = "EstamosTodosMuertosPUN";

	private const string RPC_Reiniciar = "ReiniciarPUN";

	private const string RPC_MasterReinicia = "MasterReiniciaPUN";

	private const string RPC_ArenaAcabada = "PartidaArenaAcabadaPUN";

	private const string RPC_MasterEstamosTodosMuertos = "MasterEstamosTodosMuertosPUN";

	private const string RPC_Pausad = "PausadPUN";

	private const string RPC_TenemosEquipoGanador = "TenemosEquipoGanadorPUN";

	private void Awake()
	{
		instance = this;
		miIdPhotonObjetoPlayer = -1;
		GetComponent<PhotonView>().ViewID = 900;
		if (PhotonNetwork.IsMasterClient)
		{
			soyElMasterClient = true;
			if (!PhotonNetwork.InRoom)
			{
				PhotonNetwork.CreateRoom("Room");
			}
			string nombre_ = "Player";
			if ((bool)LogrosRecords.instance)
			{
				nombre_ = LogrosRecords.instance.DameMiNombre();
			}
			miJugador = new Jugador(nombre_, PhotonNetwork.LocalPlayer.ActorNumber, int.MinValue, 0, master: true, soyJugador_: true, estaMuerto_: false, 1, 0);
			jugadores.Add(0, miJugador);
		}
		else if (!PhotonNetwork.IsConnected)
		{
			PhotonNetwork.OfflineMode = true;
			PhotonNetwork.JoinRandomRoom();
			soyElMasterClient = true;
			string nombre_2 = "Player";
			if ((bool)LogrosRecords.instance)
			{
				nombre_2 = LogrosRecords.instance.DameMiNombre();
			}
			miJugador = new Jugador(nombre_2, PhotonNetwork.LocalPlayer.ActorNumber, int.MinValue, 0, master: true, soyJugador_: true, estaMuerto_: false, 1, 0);
			jugadores.Add(0, miJugador);
		}
	}

	private void Start()
	{
	}

	public Transform GetPlayerObjetivo()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (tiempoSinCambiar + 2f < Time.time || playerObjetivo == null)
			{
				tiempoSinCambiar = Time.time;
				float num = 99999f;
				foreach (int key in instance.jugadores.Keys)
				{
					if (jugadores[key] == null || jugadores[key].estaMuerto)
					{
						continue;
					}
					PhotonView photonView = PhotonView.Find(jugadores[key].idPhotonObjetoPlayer);
					if (!photonView)
					{
						continue;
					}
					Transform transform = ((jugadores[key] == miJugador) ? GameManager.instance.player.cabeza.transform : null);
					if (!transform)
					{
						transform = photonView.transform.GetChild(1);
						if ((bool)transform)
						{
							transform.GetChild(0);
						}
					}
					if (!transform)
					{
						transform = GameManager.instance.player.cabeza.transform;
					}
					float num2 = Vector3.Distance(transform.position, base.transform.position);
					if (num2 < num)
					{
						playerObjetivo = transform;
						num = num2;
					}
				}
			}
			if (playerObjetivo == null)
			{
				playerObjetivo = GameManager.instance.player.cabeza.transform;
			}
		}
		else
		{
			playerObjetivo = GameManager.instance.player.cabeza.transform;
		}
		return playerObjetivo;
	}

	public override void OnPlayerEnteredRoom(Photon.Realtime.Player newPlayer)
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			return;
		}
		int num = -1;
		for (int i = 0; i < 8; i++)
		{
			if (!jugadores.ContainsKey(i))
			{
				num = i;
				int num2 = ((i % 2 == 0) ? 1 : 2);
				if (Config.modoDePartida == Config.ModoDePartida.Competitivo)
				{
					num2 = ((i < Config.numJugadoresOnline / 2) ? 1 : 2);
				}
				UnityEngine.Debug.Log("EQUIPO: " + num2);
				jugadores.Add(i, new Jugador("Player" + UnityEngine.Random.Range(1, 100), newPlayer.ActorNumber, int.MinValue, i, newPlayer.IsMasterClient, soyJugador_: false, estaMuerto_: false, num2, 0));
				break;
			}
		}
		if (num == -1)
		{
			UnityEngine.Debug.LogError("Numero de juego asignado == -1");
		}
		IniciarPartida(newPlayer, num);
		if (PhotonNetwork.PlayerList.Length >= Config.numJugadoresOnline)
		{
			PhotonNetwork.CurrentRoom.IsOpen = false;
			PhotonNetwork.CurrentRoom.IsVisible = false;
		}
	}

	public override void OnPlayerLeftRoom(Photon.Realtime.Player otherPlayer)
	{
		if (Debugs.logs)
		{
			UnityEngine.Debug.Log("Se ha desconectado jugador online [" + otherPlayer.UserId + "] -- MC: " + PhotonNetwork.IsMasterClient);
		}
		LoadingCamera.instance.CargarEscena("MenuPrincipal");
	}

	public GameObject DameJugadorOnline(int idObjJugador)
	{
		if (!goJugadores.ContainsKey(idObjJugador))
		{
			PhotonView photonView = PhotonView.Find(idObjJugador);
			try
			{
				goJugadores.Add(idObjJugador, photonView.gameObject);
			}
			catch
			{
			}
		}
		return goJugadores[idObjJugador];
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(TimeManager.GetInstance().GetTiempoDeEquipo(1));
			stream.SendNext(TimeManager.GetInstance().GetTiempoDeEquipo(2));
		}
		else
		{
			TimeManager.GetInstance().SetTiempoDeEquipo((float)stream.ReceiveNext(), 1);
			TimeManager.GetInstance().SetTiempoDeEquipo((float)stream.ReceiveNext(), 2);
		}
	}

	public int GetIdJuegoSegunIdPhotonPlayer(int idPlayer)
	{
		foreach (int key in jugadores.Keys)
		{
			if (jugadores[key].idPhotonObjetoPlayer == idPlayer)
			{
				return jugadores[key].idJuego;
			}
		}
		return -1;
	}

	private void IniciarPartida(Photon.Realtime.Player newPlayer, int numeroJuegoAsignado)
	{
		base.photonView.RPC("InicializarPartidaPUN", newPlayer, numeroJuegoAsignado, GameManager.instance.paisActual, Config.numJugadoresOnline);
	}

	[PunRPC]
	private void InicializarPartidaPUN(int numeroJuegoAsignado, int paisActual, int numJugadores)
	{
		GameManager.instance.paisActual = paisActual + 1;
		Config.mundo = "Mundo" + paisActual;
		MasterEstosSonMisDatos(numeroJuegoAsignado);
		Config.numJugadoresOnline = numJugadores;
		if ((bool)InputsController.instance)
		{
			InputsController.instance.EstablecerLimitesSala();
		}
		if ((bool)LoadingCamera.instance)
		{
			LoadingCamera.instance.ActivarCamaraNegraAsync(99f);
		}
	}

	private void MasterEstosSonMisDatos(int numeroJuegoAsignado)
	{
		StartCoroutine(EsperarAPlayer(numeroJuegoAsignado));
	}

	private IEnumerator EsperarAPlayer(int numeroJuegoAsignado)
	{
		while (miIdPhotonObjetoPlayer == -1)
		{
			yield return null;
		}
		string text = "Player" + UnityEngine.Random.Range(1, 100);
		if ((bool)LogrosRecords.instance)
		{
			text = LogrosRecords.instance.DameMiNombre();
		}
		base.photonView.RPC("MasterEstosSonMisDatosPUN", RpcTarget.MasterClient, text, numeroJuegoAsignado, miIdPhotonObjetoPlayer);
		yield return new WaitForSeconds(1f);
		if ((bool)InputsController.instance)
		{
			InputsController.instance.RecolocarCabeza();
		}
		if ((bool)LoadingCamera.instance)
		{
			LoadingCamera.instance.DesactivarCamaraNegraAsync();
		}
	}

	[PunRPC]
	private void MasterEstosSonMisDatosPUN(string nombre, int numeroJuegoAsignado, int numeroidPhotonObjetoPlayer)
	{
		if (!jugadores.ContainsKey(numeroJuegoAsignado))
		{
			UnityEngine.Debug.LogError("No se quien es este jugador que se ha conectado");
			return;
		}
		jugadores[numeroJuegoAsignado].nombre = nombre;
		jugadores[numeroJuegoAsignado].idPhotonObjetoPlayer = numeroidPhotonObjetoPlayer;
		foreach (SyncPelota pelotasEncendida in pelotasEncendidas)
		{
			pelotasEncendida.EnviarAccion(SyncPelota.AccionesBolaOnline.Encender, pelotasEncendida.transform.position, base.transform.localScale);
		}
		RefrescarListaJugadores();
	}

	public void ClienteMuerete(int numeroJuegoAsignado, int idPhotonObjetoMuerte = -1)
	{
		if (jugadores.ContainsKey(numeroJuegoAsignado))
		{
			jugadores[numeroJuegoAsignado].estaMuerto = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No Conzco jugador en MuertePun");
		}
		_ = Config.modoDePartida;
		_ = 2;
		RefrescarListaJugadores(forzarRefresco: false, idPhotonObjetoMuerte);
		base.photonView.RPC("MuertePUN", RpcTarget.Others, numeroJuegoAsignado);
	}

	[PunRPC]
	private void MuertePUN(int numeroJuegoAsignado)
	{
		if (!jugadores.ContainsKey(numeroJuegoAsignado))
		{
			UnityEngine.Debug.LogError("No se quien es este jugador que se ha conectado");
			return;
		}
		jugadores[numeroJuegoAsignado].estaMuerto = true;
		if (jugadores[numeroJuegoAsignado] == miJugador)
		{
			GameManager.instance.player.Morir();
		}
	}

	public void ComunicarMiMuerte(int keyJuego, int idPhotonObjetoMuerte = -1)
	{
		base.photonView.RPC("ComunicarMiMuertePUN", RpcTarget.MasterClient, keyJuego, idPhotonObjetoMuerte);
	}

	[PunRPC]
	private void ComunicarMiMuertePUN(int keyJuego, int idPhotonObjetoMuerte)
	{
		if (jugadores.ContainsKey(keyJuego))
		{
			jugadores[keyJuego].estaMuerto = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No Conzco jugador en cliente ha destruido una esfera");
		}
		DameJugadorOnline(jugadores[keyJuego].idPhotonObjetoPlayer).GetComponent<SyncJugadores>().PonermeFantasma();
		RefrescarListaJugadores(forzarRefresco: false, idPhotonObjetoMuerte);
	}

	public void ClienteHasDestruidoUnaEsfera(Photon.Realtime.Player cliente, bool armaDerecha, bool rebote, int puntos)
	{
		base.photonView.RPC("ClienteHasDestruidoUnaEsferaPUN", cliente, armaDerecha, rebote);
	}

	[PunRPC]
	private void ClienteHasDestruidoUnaEsferaPUN(bool armaDerecha, bool rebote)
	{
		Arma arma = (GameManager.instance.player.rifle ? GameManager.instance.player.rifle : (armaDerecha ? ((!GameManager.instance.player.weaponDer) ? ((Arma)GameManager.instance.player.rifle) : ((Arma)GameManager.instance.player.weaponDer)) : ((!GameManager.instance.player.weaponIzq) ? ((Arma)GameManager.instance.player.rifle) : ((Arma)GameManager.instance.player.weaponIzq))));
		GameManager.instance.m_salaManager.SumarPuntosTotales(400);
		if (!rebote)
		{
			if ((bool)arma.weaponScript)
			{
				arma.municion = arma.municionMaxActual;
				if (arma.municion == 2)
				{
					arma.pantalla.gameObject.SetActive(value: true);
					arma.pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
				}
				else if (arma.municion == 1)
				{
					arma.pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, 0f));
				}
				else
				{
					arma.pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
				}
				arma.weaponScript.gancho.SetActive(value: false);
				arma.weaponScript.pistolaMesh.SetActive(value: true);
			}
			else if (armaDerecha)
			{
				arma.rifleScript.ganchoD.LanzarGancho();
				arma.rifleScript.ganchoD.RebotarGancho();
				arma.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.GanchoI);
			}
			else
			{
				arma.rifleScript.ganchoI.LanzarGancho();
				arma.rifleScript.ganchoI.RebotarGancho();
				arma.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.RecogerGanchos);
			}
		}
		else if ((bool)arma.weaponScript)
		{
			arma.weaponScript.JumpTo(GameManager.instance.player.tJugador.gameObject, arma.fuerzaSalto * 0.7f);
		}
		else if (armaDerecha)
		{
			arma.rifleScript.ganchoD.RebotarGancho();
		}
		else
		{
			arma.rifleScript.ganchoI.RebotarGancho();
		}
	}

	public void ClienteHazRebotarElGancho(Photon.Realtime.Player cliente, bool armaDerecha)
	{
		base.photonView.RPC("ClienteHazRebotarElGanchoPUN", cliente, armaDerecha);
	}

	[PunRPC]
	private void ClienteHazRebotarElGanchoPUN(bool armaDerecha)
	{
		Arma arma = (GameManager.instance.player.rifle ? GameManager.instance.player.rifle : (armaDerecha ? ((!GameManager.instance.player.weaponDer) ? ((Arma)GameManager.instance.player.rifle) : ((Arma)GameManager.instance.player.weaponDer)) : ((!GameManager.instance.player.weaponIzq) ? ((Arma)GameManager.instance.player.rifle) : ((Arma)GameManager.instance.player.weaponIzq))));
		if ((bool)arma.weaponScript)
		{
			arma.weaponScript.rb.velocity = Vector3.zero;
			arma.weaponScript.RebotarGancho();
		}
		else if (armaDerecha)
		{
			arma.rifleScript.ganchoD.RebotarGancho();
		}
		else
		{
			arma.rifleScript.ganchoI.RebotarGancho();
		}
	}

	public void MasterHeDestruidoUnaEsfera(int idPhotonEsferaDestruida, int numJugador, Vector3 velBala)
	{
		if (!GameManager.instance.player.muerto)
		{
			base.photonView.RPC("MasterHeDestruidoUnaEsferaPUN", RpcTarget.MasterClient, idPhotonEsferaDestruida, numJugador, velBala.x, velBala.y, velBala.z);
		}
	}

	[PunRPC]
	private void MasterHeDestruidoUnaEsferaPUN(int idPhotonEsferaDestruida, int numJugador, float xVelBala, float yVelBala, float zVelBala)
	{
		PhotonView photonView = PhotonView.Find(idPhotonEsferaDestruida);
		EsferaScript esferaScript = null;
		if ((bool)photonView)
		{
			esferaScript = photonView.GetComponent<EsferaScript>();
		}
		if (esferaScript.GetEquipo() != jugadores[numJugador].equipo && esferaScript.GetEquipo() != 9)
		{
			GameObject gameObject = DameJugadorOnline(jugadores[numJugador].idPhotonObjetoPlayer);
			esferaScript.DireccionEsferaNormal((esferaScript.transform.position - gameObject.transform.position).normalized);
		}
		else if (!esferaScript.dividiendo)
		{
			esferaScript.Divide(null, 0, porBala: false, xVelBala, yVelBala, zVelBala);
		}
	}

	public void MasterHeDestruidoUnEscudo(int idPhotonEsferaDestruida, int numJugador, int numGolpes, int idBala, int idCliente)
	{
		base.photonView.RPC("MasterHeDestruidoUnEscudoPUN", RpcTarget.MasterClient, idPhotonEsferaDestruida, numJugador, numGolpes, idBala, idCliente);
	}

	[PunRPC]
	private void MasterHeDestruidoUnEscudoPUN(int idPhotonEsferaDestruida, int numJugador, int numGolpes, int idBala, int idCliente)
	{
		PhotonView photonView = PhotonView.Find(idPhotonEsferaDestruida);
		if (!photonView)
		{
			return;
		}
		EsferaScript component = photonView.GetComponent<EsferaScript>();
		if (idCliente != -1)
		{
			if (!component)
			{
				return;
			}
			int num = 0;
			int num2 = 4 - component.GetEstadoEscudo();
			if (num2 > 0)
			{
				num = numGolpes;
				if (num > num2)
				{
					num = num2;
				}
			}
			component.GolpeoEscudo(num);
			ClienteATuBalaLeQuedanXUsos(idBala, num, idCliente);
		}
		else
		{
			photonView.gameObject.GetComponentInChildren<BloqueRompible>().Romper(1000f, 1000f, 1000f, ordenPorRed: false, porTiempo: true);
		}
	}

	public void ClienteATuBalaLeQuedanXUsos(int idPhotonBala, int numGolpes, int idCliente)
	{
		Photon.Realtime.Player player = PhotonNetwork.CurrentRoom.GetPlayer(idCliente);
		if (player != null)
		{
			base.photonView.RPC("ClienteATuBalaLeQuedanXUsosPUN", player, idPhotonBala, numGolpes);
		}
	}

	[PunRPC]
	private void ClienteATuBalaLeQuedanXUsosPUN(int idPhotonBala, int numGolpes)
	{
		PhotonView photonView = PhotonView.Find(idPhotonBala);
		if ((bool)photonView)
		{
			Bala componentInChildren = photonView.gameObject.GetComponentInChildren<Bala>();
			if ((bool)componentInChildren)
			{
				componentInChildren.TocaObjetoBonus();
				componentInChildren.EfectoDesaparecer(numGolpes);
			}
		}
	}

	public void MasterHeDadoAUnaMina(int idPhotonMina, bool esGancho, float x, float y, float z)
	{
		base.photonView.RPC("MasterHeDadoAUnaMinaPUN", RpcTarget.MasterClient, idPhotonMina, esGancho, x, y, z);
	}

	[PunRPC]
	private void MasterHeDadoAUnaMinaPUN(int idPhotonMina, bool esGancho, float x, float y, float z)
	{
		PhotonView photonView = PhotonView.Find(idPhotonMina);
		if (!photonView)
		{
			return;
		}
		Mina componentInChildren = photonView.gameObject.GetComponentInChildren<Mina>();
		if ((bool)componentInChildren)
		{
			if (!esGancho)
			{
				componentInChildren.Explosion();
			}
			else
			{
				componentInChildren.Colision(x, y, z, 300f);
			}
		}
	}

	public void RefrescarListaJugadores(bool forzarRefresco = false, int idPhotonObjetoMuerte = -1)
	{
		Dictionary<int, string> dictionary = new Dictionary<int, string>();
		Dictionary<int, int> dictionary2 = new Dictionary<int, int>();
		Dictionary<int, int> dictionary3 = new Dictionary<int, int>();
		Dictionary<int, int> dictionary4 = new Dictionary<int, int>();
		Dictionary<int, int> dictionary5 = new Dictionary<int, int>();
		Dictionary<int, int> dictionary6 = new Dictionary<int, int>();
		Dictionary<int, int> dictionary7 = new Dictionary<int, int>();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		foreach (int key in jugadores.Keys)
		{
			dictionary.Add(key, jugadores[key].nombre);
			dictionary2.Add(key, jugadores[key].idJugador);
			dictionary3.Add(key, jugadores[key].idPhotonObjetoPlayer);
			dictionary4.Add(key, jugadores[key].isMaster ? 1 : 0);
			dictionary6.Add(key, jugadores[key].equipo);
			dictionary7.Add(key, jugadores[key].puntos);
			if (jugadores[key].equipo == 1)
			{
				num3++;
			}
			else
			{
				num4++;
			}
			if (jugadores[key].estaMuerto)
			{
				dictionary5.Add(key, 1);
				if (jugadores[key].equipo == 1)
				{
					num++;
				}
				else
				{
					num2++;
				}
				DameJugadorOnline(jugadores[key].idPhotonObjetoPlayer).GetComponent<SyncJugadores>().PonermeFantasma();
			}
			else
			{
				dictionary5.Add(key, 0);
			}
		}
		bool flag = num3 > 0 && num >= num3;
		bool flag2 = num4 > 0 && num2 >= num4;
		if (!forzarRefresco && Config.modoDeJuego == Config.ModosDeJuego.Online && PhotonNetwork.PlayerList.Length != 0 && Config.modoDePartida == Config.ModoDePartida.Competitivo && (flag || flag2))
		{
			if (flag && !GameManager.instance.hayEquipoGanador)
			{
				TenemosEquipoGanador(2, idPhotonObjetoMuerte);
			}
			else if (flag2 && !GameManager.instance.hayEquipoGanador)
			{
				TenemosEquipoGanador(1, idPhotonObjetoMuerte);
			}
		}
		else if (!forzarRefresco && Config.modoDeJuego == Config.ModosDeJuego.Online && PhotonNetwork.PlayerList.Length != 0 && Config.modoDePartida == Config.ModoDePartida.Cooperativo && num + num2 >= PhotonNetwork.PlayerList.Length)
		{
			EstamosTodosMuertos();
		}
		else if (!forzarRefresco && Config.modoDeJuego == Config.ModosDeJuego.Online && PhotonNetwork.PlayerList.Length != 0 && Config.modoDePartida == Config.ModoDePartida.Cooperativo && num + num2 == 1 && GameManager.instance.m_salaManager.nivelIniciado)
		{
			NivelCompletado.instance.PoderAcabarConLasEsferasDelOtroPlayer((num == 1) ? 1 : 2, porMuerte: true, 4f);
			base.photonView.RPC("RefrescarListaJugadoresPUN", RpcTarget.Others, dictionary, dictionary2, dictionary3, dictionary4, dictionary5, dictionary6, dictionary7);
		}
		else
		{
			base.photonView.RPC("RefrescarListaJugadoresPUN", RpcTarget.Others, dictionary, dictionary2, dictionary3, dictionary4, dictionary5, dictionary6, dictionary7);
		}
	}

	[PunRPC]
	private void RefrescarListaJugadoresPUN(Dictionary<int, string> nombres, Dictionary<int, int> idsJugador, Dictionary<int, int> idsPhotonObjetoPlayer, Dictionary<int, int> masters, Dictionary<int, int> muertos, Dictionary<int, int> equipos, Dictionary<int, int> puntos)
	{
		Dictionary<int, Jugador> dictionary = new Dictionary<int, Jugador>();
		foreach (int key in nombres.Keys)
		{
			string nombre_ = nombres[key];
			int num = idsJugador[key];
			int idPhotonObjetoPlayer_ = idsPhotonObjetoPlayer[key];
			int idJuego_ = key;
			bool master = masters[key] == 1;
			bool flag = num == PhotonNetwork.LocalPlayer.ActorNumber;
			bool estaMuerto_ = muertos[key] == 1;
			int equipo_ = equipos[key];
			int puntos2 = puntos[key];
			Jugador jugador = new Jugador(nombre_, num, idPhotonObjetoPlayer_, idJuego_, master, flag, estaMuerto_, equipo_, puntos2);
			if (jugador.estaMuerto && !jugadores[key].estaMuerto)
			{
				DameJugadorOnline(jugador.idPhotonObjetoPlayer).GetComponent<SyncJugadores>().PonermeFantasma();
			}
			if (flag)
			{
				miJugador = jugador;
			}
			dictionary.Add(key, jugador);
		}
		jugadores.Clear();
		jugadores = dictionary;
	}

	public void MasterHeCogidoLasPistolas()
	{
		base.photonView.RPC("MasterHeCogidoLasPistolasPUN", RpcTarget.MasterClient);
	}

	[PunRPC]
	private void MasterHeCogidoLasPistolasPUN()
	{
		numPlayersPreparados++;
		if (Config.numJugadoresOnline <= numPlayersPreparados)
		{
			QueEmpieceElJuego();
		}
	}

	public void QueEmpieceElJuego()
	{
		base.photonView.RPC("QueEmpieceElJuegoPUN", RpcTarget.All);
	}

	[PunRPC]
	private void QueEmpieceElJuegoPUN()
	{
		GameManager.instance.comenzarPartidaOnline = true;
	}

	public void ClientesPasadDeNivel()
	{
		base.photonView.RPC("ClientesPasadDeNivelPUN", RpcTarget.All);
	}

	[PunRPC]
	private void ClientesPasadDeNivelPUN()
	{
		NivelCompletado.GetInstance().PasarDeNivel();
	}

	public void QuitarTutoPowerUp()
	{
		base.photonView.RPC("QuitarTutoPowerUpPUN", RpcTarget.Others);
	}

	[PunRPC]
	private void QuitarTutoPowerUpPUN()
	{
		GameManager.instance.player.QuitarTutoPowerup();
	}

	public void ActivarPowerUp(int idPhotonPowUp)
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			base.photonView.RPC("ActivarPowerUpPUN", RpcTarget.Others, idPhotonPowUp);
		}
	}

	[PunRPC]
	private void ActivarPowerUpPUN(int idPhotonPowUp)
	{
		PhotonView photonView = PhotonView.Find(idPhotonPowUp);
		if ((bool)photonView)
		{
			Powerup component = photonView.GetComponent<Powerup>();
			if ((bool)component)
			{
				component.ActivarPowerUp();
			}
		}
	}

	public void EstamosTodosMuertos()
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			MasterEstamosTodosMuertos();
			return;
		}
		foreach (int key in jugadores.Keys)
		{
			jugadores[key].estaMuerto = false;
		}
		numPlayersPreparados = 0;
		RefrescarListaJugadores(forzarRefresco: true);
		base.photonView.RPC("EstamosTodosMuertosPUN", RpcTarget.All);
	}

	[PunRPC]
	private void EstamosTodosMuertosPUN()
	{
		GameManager.instance.player.Morir(null, forzarMuerte: true);
	}

	public void Reiniciar()
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			MasterReinicia();
			return;
		}
		foreach (int key in jugadores.Keys)
		{
			jugadores[key].estaMuerto = false;
		}
		numPlayersPreparados = 0;
		RefrescarListaJugadores(forzarRefresco: true);
		base.photonView.RPC("ReiniciarPUN", RpcTarget.All);
	}

	[PunRPC]
	private void ReiniciarPUN()
	{
		StartCoroutine(Reinicio());
	}

	private IEnumerator Reinicio()
	{
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.GameOver);
		GameManager.instance.player.segReinicio = 10f;
		yield return new WaitForSeconds(10f);
		LoadingCamera.instance.ActivarCamaraNegraAsync();
		yield return new WaitForSeconds(0.5f);
		puntuacionEquipo1 = 0;
		puntuacionEquipo2 = 0;
		if ((bool)GameManager.instance && (bool)GameManager.instance.m_salaManager && (bool)GameManager.instance.m_salaManager.confeti)
		{
			GameManager.instance.m_salaManager.confeti.SetActive(value: false);
		}
		GameManager.instance.player.Morir(null, forzarMuerte: true, porCabeza: true, mano: true, morirFinCompetitivo: true);
		yield return new WaitForSeconds(5f);
		LoadingCamera.instance.DesactivarCamaraNegraAsync();
	}

	public void MasterReinicia()
	{
		base.photonView.RPC("MasterReiniciaPUN", RpcTarget.MasterClient);
	}

	[PunRPC]
	private void MasterReiniciaPUN()
	{
		Reiniciar();
	}

	public void PartidaArenaAcabada()
	{
		base.photonView.RPC("PartidaArenaAcabadaPUN", RpcTarget.All);
	}

	[PunRPC]
	private void PartidaArenaAcabadaPUN()
	{
		GameManager.instance.FelicitarCompetitivoYVolverAMenu();
	}

	public void MasterEstamosTodosMuertos()
	{
		base.photonView.RPC("MasterEstamosTodosMuertosPUN", RpcTarget.MasterClient);
	}

	[PunRPC]
	private void MasterEstamosTodosMuertosPUN()
	{
		EstamosTodosMuertos();
	}

	public void Pausad(bool estado, int idPlayer)
	{
		base.photonView.RPC("PausadPUN", RpcTarget.Others, estado, idPlayer);
	}

	[PunRPC]
	private void PausadPUN(bool estado, int idPlayer)
	{
		GameManager.instance.player.ActivarDesactiarZonaOscura(estado, Player.EstadoZonaNegra.Pausa, desdeSalir: false, idPlayer);
	}

	public void TenemosEquipoGanador(int equipoGanador, int idPhotonObjetoMuerte = -1, bool porEliminacionDeBolas = false)
	{
		GameManager.instance.hayEquipoGanador = true;
		base.photonView.RPC("TenemosEquipoGanadorPUN", RpcTarget.All, equipoGanador, idPhotonObjetoMuerte, porEliminacionDeBolas);
	}

	[PunRPC]
	private void TenemosEquipoGanadorPUN(int equipoGanador, int idPhotonObjetoMuerte, bool porEliminacionDeBolas = false)
	{
		GameManager.instance.hayEquipoGanador = true;
		if (Config.modoDePartida == Config.ModoDePartida.Competitivo)
		{
			GameManager.instance.player.pararTiempo = true;
		}
		GameManager.instance.EquipoGana(equipoGanador, idPhotonObjetoMuerte, porEliminacionDeBolas);
	}
}
public class MonedaMultiplicador : MonoBehaviour
{
	public TextMesh cantidadPuntos;

	public Transform aro;

	public ParticleSystem holy;

	public ParticleSystem shield;

	private Vector3 vectorAux;

	public AudioSource aSource;

	public AudioClip[] audios;

	private void Start()
	{
	}

	private void OnEnable()
	{
		Invoke("Apagar", 2f);
		holy.Play();
		shield.Play();
		base.transform.LookAt(GameManager.instance.player.cabeza.transform);
		vectorAux = base.transform.localEulerAngles;
		vectorAux.z = 0f;
		vectorAux.x = 0f;
		base.transform.localEulerAngles = vectorAux;
	}

	private void Apagar()
	{
		base.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		aro.Rotate(Vector3.up * Time.deltaTime * 200f);
		base.transform.Translate(Vector3.up * Time.deltaTime * 1f);
	}

	public void PonerSonido(int puntos)
	{
		AudioClip clip = audios[0];
		switch (puntos)
		{
		case 5:
			clip = audios[0];
			break;
		case 10:
			clip = audios[1];
			break;
		case 15:
			clip = audios[2];
			break;
		case 20:
			clip = audios[3];
			break;
		case 25:
			clip = audios[4];
			break;
		}
		aSource.clip = clip;
		aSource.Play();
	}
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = headPos,
			headRotation = headRot,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		UnityEngine.Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private bool assetsFinishedLoading;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception ex)
			{
				assetsFinishedLoading = true;
				throw ex;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		string[] devices = Microphone.devices;
		if (devices.Length < 1)
		{
			return false;
		}
		int num = 0;
		string deviceName = devices[num];
		Microphone.GetDeviceCaps(deviceName, out var _, out var maxFreq);
		if (maxFreq == 0)
		{
			maxFreq = 44100;
		}
		if (Microphone.Start(deviceName, loop: true, 1, maxFreq) == null)
		{
			return false;
		}
		Microphone.End(deviceName);
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			UnityEngine.Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return false;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = centerEyePosition,
			headRotation = centerEyeRotation,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height;
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					object[] obj2 = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format;
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format;
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string text = GetAppId();
		if (text == "")
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive<T>(int target) where T : MonoBehaviour
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
			OVRLipSyncContextMorphTarget component = SwitchTargets[i].GetComponent<OVRLipSyncContextMorphTarget>();
			if ((bool)component)
			{
				component.enabled = false;
			}
			OVRLipSyncContextTextureFlip component2 = SwitchTargets[i].GetComponent<OVRLipSyncContextTextureFlip>();
			if ((bool)component2)
			{
				component2.enabled = false;
			}
		}
		SwitchTargets[target].SetActive(value: true);
		MonoBehaviour component3 = SwitchTargets[target].GetComponent<T>();
		if (component3 != null)
		{
			component3.enabled = true;
		}
		return true;
	}
}
public class LipSyncDemo_Control : MonoBehaviour
{
	[Tooltip("Key used to rotate the demo object up to 45 degrees to the left.")]
	public KeyCode rotateLeftKey = KeyCode.LeftArrow;

	[Tooltip("Key used to rotate the demo object up to 45 degrees to the right.")]
	public KeyCode rotateRightKey = KeyCode.RightArrow;

	[Tooltip("Key used to reset demo object rotation.")]
	public KeyCode resetRotationKey = KeyCode.DownArrow;

	private float resetRotation = 180f;

	private float rotationAmount = 20f;

	private float rotationMax = 45f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(rotateLeftKey))
		{
			RotateObject(rotationAmount);
		}
		else if (Input.GetKey(rotateRightKey))
		{
			RotateObject(0f - rotationAmount);
		}
		else if (Input.GetKey(resetRotationKey))
		{
			RotateObject(resetRotation, absolute: true);
		}
	}

	private void RotateObject(float amountDegrees, bool absolute = false)
	{
		GameObject gameObject = GameObject.Find("LipSyncMorphTarget_Female");
		if (gameObject == null)
		{
			gameObject = GameObject.Find("RobotHead_TextureFlip");
		}
		if (!gameObject)
		{
			return;
		}
		if (absolute)
		{
			float num = amountDegrees - gameObject.transform.eulerAngles.y;
			gameObject.transform.Rotate(Vector3.up * num);
			return;
		}
		float num2 = Time.deltaTime * amountDegrees;
		if (num2 + gameObject.transform.eulerAngles.y >= resetRotation - rotationMax && num2 + gameObject.transform.eulerAngles.y <= resetRotation + rotationMax)
		{
			gameObject.transform.Rotate(Vector3.up * num2);
		}
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private int maxTarget = 6;

	private bool XRButtonBeingPressed;

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
		SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesWithCharacteristics(InputDeviceCharacteristics.HeldInHand, list);
		bool flag = false;
		bool flag2 = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.primaryButton, out var value) && value)
			{
				flag = true;
			}
			if (item.TryGetFeatureValue(CommonUsages.secondaryButton, out value) && value)
			{
				flag2 = true;
			}
		}
		if (flag && !XRButtonBeingPressed)
		{
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
		}
		if (flag2 && !XRButtonBeingPressed)
		{
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
		}
		XRButtonBeingPressed = flag || flag2;
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
			break;
		case 1:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(1);
			break;
		case 2:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(2);
			break;
		case 3:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(3);
			break;
		case 4:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(4);
			break;
		case 5:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(5);
			break;
		}
		OVRLipSyncDebugConsole.Clear();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
public class OVRNamedArrayAttribute : PropertyAttribute
{
	public readonly string[] names;

	public OVRNamedArrayAttribute(string[] names)
	{
		this.names = names;
	}
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	public delegate void OVRTouchpadCallback<TouchEvent>(TouchEvent arg);

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	public static Delegate touchPadCallbacks = null;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if ((object)touchPadCallbacks == null)
		{
			return;
		}
		OVRTouchpadCallback<TouchEvent> oVRTouchpadCallback = touchPadCallbacks as OVRTouchpadCallback<TouchEvent>;
		if (move.magnitude < minMovMagnitudeMouse)
		{
			oVRTouchpadCallback(TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				oVRTouchpadCallback(TouchEvent.Left);
			}
			else
			{
				oVRTouchpadCallback(TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			oVRTouchpadCallback(TouchEvent.Down);
		}
		else
		{
			oVRTouchpadCallback(TouchEvent.Up);
		}
	}

	public static void AddListener(OVRTouchpadCallback<TouchEvent> handler)
	{
		touchPadCallbacks = (OVRTouchpadCallback<TouchEvent>)Delegate.Combine((OVRTouchpadCallback<TouchEvent>)touchPadCallbacks, handler);
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum AudioDataType
	{
		S16_Mono,
		S16_Stereo,
		F32_Mono,
		F32_Stereo
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing,
		LaughterAmount
	}

	public enum ContextProviders
	{
		Original,
		Enhanced,
		Enhanced_with_Laughter
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public float laughterScore;

		public void CopyInput(Frame input)
		{
			frameNumber = input.frameNumber;
			frameDelay = input.frameDelay;
			input.Visemes.CopyTo(Visemes, 0);
			laughterScore = input.laughterScore;
		}

		public void Reset()
		{
			frameNumber = 0;
			frameDelay = 0;
			Array.Clear(Visemes, 0, VisemeCount);
			laughterScore = 0f;
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextEx(ref uint context, ContextProviders provider, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameEx(uint context, IntPtr audioBuffer, uint bufferSize, AudioDataType dataType, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount, ref float laughterScore, float[] laughterCategories, int laughterCategoriesLength);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			if (IsInitialized() != 0)
			{
				sInitialized = Initialize();
				if (sInitialized != 0)
				{
					UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
				}
			}
			OVRTouchpad.Create();
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize()
	{
		int outputSampleRate = AudioSettings.outputSampleRate;
		AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(outputSampleRate, bufferLength);
		return sInitialized;
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {sampleRate:F0} BufferSize: {bufferSize:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextEx(ref context, provider, sampleRate, enableAcceleration);
	}

	public static Result CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextWithModelFile(ref context, provider, modelPath, sampleRate, enableAcceleration);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.F32_Stereo : AudioDataType.F32_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}

	public static Result ProcessFrame(uint context, short[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.S16_Stereo : AudioDataType.S16_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	[Tooltip("Allow capturing of keyboard input to control operation.")]
	public bool enableKeyboardInput;

	[Tooltip("Register a mouse/touch callback to control loopback and gain (requires script restart).")]
	public bool enableTouchInput;

	[Tooltip("Play input audio back through audio output.")]
	public bool audioLoopback;

	[Tooltip("Key to toggle audio loopback.")]
	public KeyCode loopbackKey = KeyCode.L;

	[Tooltip("Show viseme scores in an OVRLipSyncDebugConsole display.")]
	public bool showVisemes;

	[Tooltip("Key to toggle viseme score display.")]
	public KeyCode debugVisemesKey = KeyCode.D;

	[Tooltip("Skip data from the Audio Source. Use if you intend to pass audio data in manually.")]
	public bool skipAudioSource;

	[Tooltip("Adjust the linear audio gain multiplier before processing lipsync")]
	public float gain = 1f;

	private bool hasDebugConsole;

	public KeyCode debugLaughterKey = KeyCode.H;

	public bool showLaughter;

	public float laughterScore;

	private void Start()
	{
		if (enableTouchInput)
		{
			OVRTouchpad.AddListener(LocalTouchEventCallback);
		}
		OVRLipSyncDebugConsole[] array = UnityEngine.Object.FindObjectsOfType<OVRLipSyncDebugConsole>();
		if (array.Length != 0)
		{
			hasDebugConsole = array[0];
		}
	}

	private void HandleKeyboard()
	{
		if (Input.GetKeyDown(loopbackKey))
		{
			ToggleAudioLoopback();
		}
		else if (Input.GetKeyDown(debugVisemesKey))
		{
			showVisemes = !showVisemes;
			if (showVisemes)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW VISEMES: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showVisemes = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW VISEMES: DISABLED");
			}
		}
		else if (Input.GetKeyDown(debugLaughterKey))
		{
			showLaughter = !showLaughter;
			if (showLaughter)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showLaughter = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: DISABLED");
			}
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			string text = "LINEAR GAIN: ";
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			string text2 = "LINEAR GAIN: ";
			text2 += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text2);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
	}

	private void Update()
	{
		if (enableKeyboardInput)
		{
			HandleKeyboard();
		}
		laughterScore = base.Frame.laughterScore;
		DebugShowVisemesAndLaughter();
	}

	public void PreprocessAudioSamples(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
	}

	public void PostprocessAudioSamples(float[] data, int channels)
	{
		if (!audioLoopback)
		{
			for (int i = 0; i < data.Length; i++)
			{
				data[i] *= 0f;
			}
		}
	}

	public void ProcessAudioSamplesRaw(float[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamplesRaw(short[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamples(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() == OVRLipSync.Result.Success && !(audioSource == null))
		{
			PreprocessAudioSamples(data, channels);
			ProcessAudioSamplesRaw(data, channels);
			PostprocessAudioSamples(data, channels);
		}
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (!skipAudioSource)
		{
			ProcessAudioSamples(data, channels);
		}
	}

	private void DebugShowVisemesAndLaughter()
	{
		if (!hasDebugConsole)
		{
			return;
		}
		string text = "";
		if (showLaughter)
		{
			text += "Laughter:";
			int num = (int)(50f * base.Frame.laughterScore);
			for (int i = 0; i < num; i++)
			{
				text += "*";
			}
			text += "\n";
		}
		if (showVisemes)
		{
			for (int j = 0; j < base.Frame.Visemes.Length; j++)
			{
				string text2 = text;
				OVRLipSync.Viseme viseme = (OVRLipSync.Viseme)j;
				text = text2 + viseme;
				text += ":";
				int num2 = (int)(50f * base.Frame.Visemes[j]);
				for (int k = 0; k < num2; k++)
				{
					text += "*";
				}
				text += "\n";
			}
		}
		OVRLipSyncDebugConsole.Clear();
		if (text != "")
		{
			OVRLipSyncDebugConsole.Log(text);
		}
	}

	private void ToggleAudioLoopback()
	{
		audioLoopback = !audioLoopback;
		if (hasDebugConsole)
		{
			OVRLipSyncDebugConsole.Clear();
			OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			if (audioLoopback)
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: ENABLED");
			}
			else
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: DISABLED");
			}
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		string text = "LINEAR GAIN: ";
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			ToggleAudioLoopback();
			break;
		case OVRTouchpad.TouchEvent.Up:
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		case OVRTouchpad.TouchEvent.Down:
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	[Tooltip("Which lip sync provider to use for viseme computation.")]
	public OVRLipSync.ContextProviders provider = OVRLipSync.ContextProviders.Enhanced;

	[Tooltip("Enable DSP offload on supported Android devices.")]
	public bool enableAcceleration = true;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	private int _smoothing;

	public int Smoothing
	{
		get
		{
			return _smoothing;
		}
		set
		{
			switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0))
			{
			case OVRLipSync.Result.InvalidParam:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: A viseme smoothing parameter is invalid, it should be between 1 and 100!");
				break;
			default:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: An unexpected error occured.");
				break;
			case OVRLipSync.Result.Success:
				break;
			}
			_smoothing = value;
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider, 0, enableAcceleration) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount))
		{
		case OVRLipSync.Result.InvalidParam:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: Viseme ID is invalid.");
			break;
		default:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: An unexpected error occured.");
			break;
		case OVRLipSync.Result.Success:
			break;
		}
	}

	public void SetLaughterBlend(int amount)
	{
		if (OVRLipSync.SendSignal(context, OVRLipSync.Signals.LaughterAmount, amount, 0) != 0)
		{
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetLaughterBlend: An unexpected error occured.");
		}
	}

	public OVRLipSync.Result ResetContext()
	{
		frame.Reset();
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	[Tooltip("Pre-computed viseme sequence asset. Compute from audio in Unity with Tools -> Oculus -> Generate Lip Sync Assets.")]
	public OVRLipSyncSequence currentSequence;

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	[Tooltip("Skinned Mesh Rendered target to be driven by Oculus Lipsync")]
	public SkinnedMeshRenderer skinnedMeshRenderer;

	[Tooltip("Blendshape index to trigger for each viseme.")]
	public int[] visemeToBlendTargets = Enumerable.Range(0, OVRLipSync.VisemeCount).ToArray();

	[Tooltip("Enable using the test keys defined below to manually trigger each viseme.")]
	public bool enableVisemeTestKeys;

	[Tooltip("Test keys used to manually trigger an individual viseme - by default the QWERTY row of a US keyboard.")]
	public KeyCode[] visemeTestKeys = new KeyCode[15]
	{
		KeyCode.BackQuote,
		KeyCode.Tab,
		KeyCode.Q,
		KeyCode.W,
		KeyCode.E,
		KeyCode.R,
		KeyCode.T,
		KeyCode.Y,
		KeyCode.U,
		KeyCode.I,
		KeyCode.O,
		KeyCode.P,
		KeyCode.LeftBracket,
		KeyCode.RightBracket,
		KeyCode.Backslash
	};

	[Tooltip("Test key used to manually trigger laughter and visualise the results")]
	public KeyCode laughterKey = KeyCode.CapsLock;

	[Tooltip("Blendshape index to trigger for laughter")]
	public int laughterBlendTarget = OVRLipSync.VisemeCount;

	[Range(0f, 1f)]
	[Tooltip("Laughter probability threshold above which the laughter blendshape will be activated")]
	public float laughterThreshold = 0.5f;

	[Range(0f, 3f)]
	[Tooltip("Laughter animation linear multiplier, the final output will be clamped to 1.0")]
	public float laughterMultiplier = 1.5f;

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme, 100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: Please set the target Skinned Mesh Renderer to be controlled!");
			return;
		}
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: No OVRLipSyncContext component on this object!");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
				SetLaughterToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
			if (smoothAmount != lipsyncContext.Smoothing)
			{
				lipsyncContext.Smoothing = smoothAmount;
			}
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeTestKeys)
		{
			for (int i = 0; i < OVRLipSync.VisemeCount; i++)
			{
				CheckVisemeKey(visemeTestKeys[i], i, 100);
			}
		}
		CheckLaughterKey();
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < visemeToBlendTargets.Length; i++)
		{
			if (visemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(visemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void SetLaughterToMorphTarget(OVRLipSync.Frame frame)
	{
		if (laughterBlendTarget != -1)
		{
			float laughterScore = frame.laughterScore;
			laughterScore = ((laughterScore < laughterThreshold) ? 0f : (laughterScore - laughterThreshold));
			laughterScore = Mathf.Min(laughterScore * laughterMultiplier, 1f);
			laughterScore *= 1f / laughterThreshold;
			skinnedMeshRenderer.SetBlendShapeWeight(laughterBlendTarget, laughterScore * 100f);
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], 0);
		}
	}

	private void CheckLaughterKey()
	{
		if (Input.GetKeyDown(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(100);
		}
		if (Input.GetKeyUp(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	[Tooltip("The texture used for each viseme.")]
	[OVRNamedArray(new string[]
	{
		"sil", "PP", "FF", "TH", "DD", "kk", "CH", "SS", "nn", "RR",
		"aa", "E", "ih", "oh", "ou"
	})]
	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme,100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
		if (material == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: Lip sync context texture flip has no material target to control!");
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && material != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				if (lipsyncContext.provider == OVRLipSync.ContextProviders.Original)
				{
					for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
					{
						float num = (float)(smoothAmount - 1) / 100f;
						oldFrame.Visemes[i] = oldFrame.Visemes[i] * num + currentPhonemeFrame.Visemes[i] * (1f - num);
					}
				}
				else
				{
					oldFrame.Visemes = currentPhonemeFrame.Visemes;
				}
				SetVisemeToTexture();
			}
		}
		if (smoothAmount != lipsyncContext.Smoothing)
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncMicInput : MonoBehaviour
{
	public enum micActivation
	{
		HoldToSpeak,
		PushToSpeak,
		ConstantSpeak
	}

	[Tooltip("Manual specification of Audio Source - by default will use any attached to the same object.")]
	public AudioSource audioSource;

	[Tooltip("Enable a keypress to toggle the microphone device selection GUI.")]
	public bool enableMicSelectionGUI;

	[Tooltip("Key to toggle the microphone selection GUI if enabled.")]
	public KeyCode micSelectionGUIKey = KeyCode.M;

	[SerializeField]
	[Range(0f, 100f)]
	[Tooltip("Microphone input volume control.")]
	private float micInputVolume = 100f;

	[SerializeField]
	[Tooltip("Requested microphone input frequency")]
	private int micFrequency = 48000;

	[Tooltip("Microphone input control method. Hold To Speak and Push To Speak are driven with the Mic Activation Key.")]
	public micActivation micControl = micActivation.ConstantSpeak;

	[Tooltip("Key used to drive Hold To Speak and Push To Speak methods of microphone input control.")]
	public KeyCode micActivationKey = KeyCode.Space;

	[Tooltip("Will contain the string name of the selected microphone device - read only.")]
	public string selectedDevice;

	private bool micSelected;

	private int minFreq;

	private int maxFreq;

	private bool focused = true;

	private bool initialized;

	public float MicFrequency
	{
		get
		{
			return micFrequency;
		}
		set
		{
			micFrequency = (int)Mathf.Clamp(value, 0f, 96000f);
		}
	}

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		_ = (bool)audioSource;
	}

	private void Start()
	{
		audioSource.loop = true;
		audioSource.mute = false;
		InitializeMicrophone();
	}

	private void InitializeMicrophone()
	{
		if (!initialized && Microphone.devices.Length != 0)
		{
			selectedDevice = Microphone.devices[0].ToString();
			micSelected = true;
			GetMicCaps();
			initialized = true;
		}
	}

	private void Update()
	{
		if (!focused)
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			return;
		}
		if (!UnityEngine.Application.isPlaying)
		{
			StopMicrophone();
			return;
		}
		if (!initialized)
		{
			InitializeMicrophone();
		}
		audioSource.volume = micInputVolume / 100f;
		if (micControl == micActivation.HoldToSpeak)
		{
			if (Input.GetKey(micActivationKey))
			{
				if (!Microphone.IsRecording(selectedDevice))
				{
					StartMicrophone();
				}
			}
			else if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
		}
		if (micControl == micActivation.PushToSpeak && Input.GetKeyDown(micActivationKey))
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			else if (!Microphone.IsRecording(selectedDevice))
			{
				StartMicrophone();
			}
		}
		if (micControl == micActivation.ConstantSpeak && !Microphone.IsRecording(selectedDevice))
		{
			StartMicrophone();
		}
		if (enableMicSelectionGUI && Input.GetKeyDown(micSelectionGUIKey))
		{
			micSelected = false;
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		focused = focus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		focused = !pauseStatus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnDisable()
	{
		StopMicrophone();
	}

	private void OnGUI()
	{
		MicDeviceGUI(Screen.width / 2 - 150, Screen.height / 2 - 75, 300f, 50f, 10f, -300f);
	}

	public void MicDeviceGUI(float left, float top, float width, float height, float buttonSpaceTop, float buttonSpaceLeft)
	{
		if (Microphone.devices.Length < 1 || !enableMicSelectionGUI || micSelected)
		{
			return;
		}
		for (int i = 0; i < Microphone.devices.Length; i++)
		{
			if (GUI.Button(new Rect(left + (width + buttonSpaceLeft) * (float)i, top + (height + buttonSpaceTop) * (float)i, width, height), Microphone.devices[i].ToString()))
			{
				StopMicrophone();
				selectedDevice = Microphone.devices[i].ToString();
				micSelected = true;
				GetMicCaps();
				StartMicrophone();
			}
		}
	}

	public void GetMicCaps()
	{
		if (micSelected)
		{
			Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
			if (minFreq == 0 && maxFreq == 0)
			{
				UnityEngine.Debug.LogWarning("GetMicCaps warning:: min and max frequencies are 0");
				minFreq = 44100;
				maxFreq = 44100;
			}
			if (micFrequency > maxFreq)
			{
				micFrequency = maxFreq;
			}
		}
	}

	public void StartMicrophone()
	{
		if (micSelected)
		{
			audioSource.clip = Microphone.Start(selectedDevice, loop: true, 1, micFrequency);
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (Microphone.GetPosition(selectedDevice) <= 0 && stopwatch.Elapsed.TotalMilliseconds < 1000.0)
			{
				Thread.Sleep(50);
			}
			if (Microphone.GetPosition(selectedDevice) <= 0)
			{
				throw new Exception("Timeout initializing microphone " + selectedDevice);
			}
			audioSource.Play();
		}
	}

	public void StopMicrophone()
	{
		if (micSelected)
		{
			if (audioSource != null && audioSource.clip != null && audioSource.clip.name == "Microphone")
			{
				audioSource.Stop();
			}
			GetComponent<OVRLipSyncContext>().ResetContext();
			Microphone.End(selectedDevice);
		}
	}

	private float GetAveragedVolume()
	{
		return 0f;
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class OculusNetworkManager : LogrosRecords
{
	private enum TipoOperacion
	{
		obtenerResultados,
		subirRecord
	}

	private struct Operacion
	{
		public TipoOperacion tipoOperacion;

		public string tablaSolicitada;

		public int numeroResultadosQueQuiero;

		public int record;
	}

	private enum TipoDatos
	{
		top,
		alrededorMio
	}

	public static ulong m_myID = 0uL;

	public static string m_myOculusID = "";

	public static bool loginCorrecto = false;

	private string tablaSolicitada = string.Empty;

	private TipoDatos tipoDatosActual;

	private const int kRangoResultados = 100;

	public bool ejecutandoOperacion;

	private List<Operacion> operacionesPendientes;

	private const int kFramesQueMeSalto = 30;

	private int framesQueLlevoSaltados;

	private int nResultadosQueQuiero;

	private List<Resultado> resultadoActual;

	private List<Resultado> resultadosTop;

	private void Start()
	{
		if (Config.plataforma != Config.PlataformaJuego.Oculus)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		operacionesPendientes = new List<Operacion>();
	}

	private void Update()
	{
		if (!ejecutandoOperacion)
		{
			if (framesQueLlevoSaltados >= 30)
			{
				framesQueLlevoSaltados = 0;
				ejecutandoOperacion = true;
				StartCoroutine(SiguienteOperacionConPausa());
			}
			else
			{
				framesQueLlevoSaltados++;
			}
		}
	}

	public override void MostrarTienda()
	{
	}

	public override string DameMiNombre()
	{
		if (m_myOculusID == "")
		{
			return "Player";
		}
		return m_myOculusID;
	}

	public override void GuardarLogros()
	{
	}

	public override void InicializarTablas(List<InfoTabla> tablas)
	{
	}

	public override void InicializarTablas(string[] tablas)
	{
	}

	public override void InicializarLogros()
	{
	}

	public override void MarcarLogroCompletado(string idLogro)
	{
		if (!loginCorrecto)
		{
			if (Debugs.logs)
			{
				UnityEngine.Debug.LogError("*** Intento marcar logro sin login completado :(");
			}
		}
		else
		{
			Achievements.Unlock(idLogro);
		}
	}

	public override void ComprobarYDarLogroPlatino()
	{
		if (PersistentDataManager.GetInt("HeDadoLogroPlatino") != 1)
		{
			Achievements.GetAllProgress()?.OnComplete(AcabarDeComprobarPlatino);
		}
	}

	private void AcabarDeComprobarPlatino(Message<AchievementProgressList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		uint num = 25u;
		int num2 = 0;
		foreach (AchievementProgress datum in msg.Data)
		{
			if (datum.IsUnlocked)
			{
				num2++;
			}
		}
		if (num2 >= num - 1)
		{
			LogrosRecords.instance.MarcarLogroCompletado(LogrosRecords.instance.DameNombreAchivement(Logros.Platino));
			PersistentDataManager.SetInt("HeDadoLogroPlatino", 1);
		}
	}

	public override void ObtenerResultadosAlrededorMioConTop(string tabla, int resultadosQueQuiero, bool esEvento, long record = -1L)
	{
		if (Debugs.logs)
		{
			UnityEngine.Debug.Log("*** Jugador quiere obtener resultados de la tabla:" + tabla);
		}
		if (!loginCorrecto)
		{
			if (Debugs.logs)
			{
				UnityEngine.Debug.LogError("*** Intento obtener resultados alrededor mío sin login completado :(");
			}
			return;
		}
		resultadosTop = null;
		if (resultadosQueQuiero % 2 == 0)
		{
			if (Debugs.logs)
			{
				UnityEngine.Debug.LogError("El número de resultados que quiero DEBE ser impar");
			}
		}
		else
		{
			Operacion item = default(Operacion);
			item.tipoOperacion = TipoOperacion.obtenerResultados;
			item.tablaSolicitada = tabla;
			item.numeroResultadosQueQuiero = resultadosQueQuiero;
			operacionesPendientes.Add(item);
		}
	}

	public override void SubirRecord(string tabla, int record)
	{
		if (!loginCorrecto)
		{
			if (Debugs.logs)
			{
				UnityEngine.Debug.LogError("*** Intento subir record sin login completado :(");
			}
		}
		else
		{
			Operacion item = default(Operacion);
			item.tipoOperacion = TipoOperacion.subirRecord;
			item.tablaSolicitada = tabla;
			item.record = record;
			operacionesPendientes.Add(item);
		}
	}

	private void SubirRecordCallback(Message<bool> msg)
	{
		if (!msg.IsError)
		{
			OnRecordSubido(this, -1, tablaSolicitada);
		}
		ejecutandoOperacion = false;
	}

	private void ResultadosCallback(Message<LeaderboardEntryList> msg)
	{
		if (!msg.IsError || (msg.IsError && msg.Type == Message.MessageType.Leaderboard_GetEntries))
		{
			if (Debugs.logs)
			{
				UnityEngine.Debug.Log("*** Obtenidos " + msg.Data.Count + " resultados, tabla actual: " + tablaSolicitada);
			}
			List<Resultado> list = new List<Resultado>();
			bool flag = false;
			int num = 0;
			long num2 = 0L;
			if (msg.Data == null || msg.Data.Count == 0)
			{
				if (resultadosTop != null)
				{
					list = resultadosTop;
				}
				OnResultadosObtenidos(this, list, dosListados: false, tablaSolicitada);
				ejecutandoOperacion = false;
				resultadoActual = null;
				resultadosTop = null;
				return;
			}
			for (int i = 0; i < msg.Data.Count; i++)
			{
				LeaderboardEntry leaderboardEntry = msg.Data[i];
				if (leaderboardEntry.User.ID == m_myID)
				{
					flag = true;
					num = i;
					num2 = leaderboardEntry.Score;
				}
				Resultado item = default(Resultado);
				item.record = (int)leaderboardEntry.Score;
				string oculusID = leaderboardEntry.User.OculusID;
				item.usuario = oculusID;
				item.posicion = leaderboardEntry.Rank;
				list.Add(item);
			}
			int num3 = 0;
			if (flag)
			{
				using (List<Resultado>.Enumerator enumerator = list.GetEnumerator())
				{
					while (enumerator.MoveNext() && enumerator.Current.record != num2)
					{
						num3++;
					}
				}
				if (num3 != num)
				{
					Resultado item2 = list[num];
					new List<Resultado>();
					list.RemoveAt(num);
					list.Insert(num3, item2);
					num = num3;
				}
			}
			if (tipoDatosActual == TipoDatos.top)
			{
				bool flag2 = flag && num < nResultadosQueQuiero;
				if ((!flag2 && msg.Data.Count < nResultadosQueQuiero) || !flag)
				{
					flag2 = true;
				}
				if (flag2)
				{
					if (list.Count > nResultadosQueQuiero)
					{
						list.RemoveRange(nResultadosQueQuiero, list.Count - nResultadosQueQuiero);
					}
					OnResultadosObtenidos(this, list, dosListados: false, tablaSolicitada);
					ejecutandoOperacion = false;
					resultadoActual = null;
					resultadosTop = null;
				}
				else
				{
					resultadoActual = new List<Resultado>(list);
					tipoDatosActual = TipoDatos.alrededorMio;
					resultadosTop = list;
					Leaderboards.GetEntries(tablaSolicitada, 100, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewer).OnComplete(ResultadosCallback);
				}
				return;
			}
			if (num2 == 0L)
			{
				if (resultadoActual.Count > nResultadosQueQuiero)
				{
					resultadoActual.RemoveRange(nResultadosQueQuiero, resultadoActual.Count - nResultadosQueQuiero);
				}
				OnResultadosObtenidos(this, resultadoActual, dosListados: false, tablaSolicitada);
				ejecutandoOperacion = false;
				resultadoActual = null;
				resultadosTop = null;
				return;
			}
			int num4 = (int)((float)(nResultadosQueQuiero - 1) * 0.5f);
			if (resultadoActual.Count > num4)
			{
				resultadoActual.RemoveRange(num4, resultadoActual.Count - num4);
			}
			int num5 = num4;
			Resultado item3 = default(Resultado);
			item3.posicion = -1;
			item3.usuario = "---";
			item3.record = 0;
			resultadoActual.Add(item3);
			int num6 = (int)((float)(num5 - 1) * 0.5f);
			for (int j = 0; j < num5; j++)
			{
				if (num3 + j - num6 < list.Count)
				{
					resultadoActual.Add(list[num3 + j - num6]);
				}
			}
			ejecutandoOperacion = false;
			OnResultadosObtenidos(this, resultadoActual, dosListados: true, tablaSolicitada);
			resultadoActual = null;
			resultadosTop = null;
		}
		else
		{
			ejecutandoOperacion = false;
			resultadoActual = null;
			resultadosTop = null;
		}
	}

	private IEnumerator SiguienteOperacionConPausa()
	{
		yield return new WaitForSeconds(0.5f);
		SiguienteOperacion();
	}

	private void SiguienteOperacion()
	{
		if (operacionesPendientes != null && operacionesPendientes.Count > 0)
		{
			Operacion operacion = operacionesPendientes[0];
			switch (operacion.tipoOperacion)
			{
			case TipoOperacion.obtenerResultados:
				tipoDatosActual = TipoDatos.top;
				tablaSolicitada = operacion.tablaSolicitada;
				nResultadosQueQuiero = operacion.numeroResultadosQueQuiero;
				Leaderboards.GetEntries(tablaSolicitada, 100, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(ResultadosCallback);
				break;
			case TipoOperacion.subirRecord:
				tablaSolicitada = operacion.tablaSolicitada;
				Leaderboards.WriteEntry(operacion.tablaSolicitada, operacion.record).OnComplete(SubirRecordCallback);
				break;
			default:
				ejecutandoOperacion = false;
				break;
			}
			operacionesPendientes.RemoveAt(0);
		}
		else
		{
			ejecutandoOperacion = false;
		}
	}
}
public class DebugUIBuilder : MonoBehaviour
{
	public delegate void OnClick();

	public delegate void OnToggleValueChange(Toggle t);

	public delegate void OnSlider(float f);

	public delegate bool ActiveUpdate();

	public const int DEBUG_PANE_CENTER = 0;

	public const int DEBUG_PANE_RIGHT = 1;

	public const int DEBUG_PANE_LEFT = 2;

	[SerializeField]
	private RectTransform buttonPrefab;

	[SerializeField]
	private RectTransform labelPrefab;

	[SerializeField]
	private RectTransform sliderPrefab;

	[SerializeField]
	private RectTransform dividerPrefab;

	[SerializeField]
	private RectTransform togglePrefab;

	[SerializeField]
	private RectTransform radioPrefab;

	[SerializeField]
	private GameObject uiHelpersToInstantiate;

	[SerializeField]
	private Transform[] targetContentPanels;

	private bool[] reEnable;

	[SerializeField]
	private List<GameObject> toEnable;

	[SerializeField]
	private List<GameObject> toDisable;

	public static DebugUIBuilder instance;

	private const float elementSpacing = 16f;

	private const float marginH = 16f;

	private const float marginV = 16f;

	private Vector2[] insertPositions;

	private List<RectTransform>[] insertedElements;

	private Vector3 menuOffset;

	private OVRCameraRig rig;

	private Dictionary<string, ToggleGroup> radioGroups = new Dictionary<string, ToggleGroup>();

	private LaserPointer lp;

	private LineRenderer lr;

	public LaserPointer.LaserBeamBehavior laserBeamBehavior;

	public void Awake()
	{
		instance = this;
		menuOffset = base.transform.position;
		base.gameObject.SetActive(value: false);
		rig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		for (int i = 0; i < toEnable.Count; i++)
		{
			toEnable[i].SetActive(value: false);
		}
		insertPositions = new Vector2[targetContentPanels.Length];
		for (int j = 0; j < insertPositions.Length; j++)
		{
			insertPositions[j].x = 16f;
			insertPositions[j].y = -16f;
		}
		insertedElements = new List<RectTransform>[targetContentPanels.Length];
		for (int k = 0; k < insertedElements.Length; k++)
		{
			insertedElements[k] = new List<RectTransform>();
		}
		if ((bool)uiHelpersToInstantiate)
		{
			UnityEngine.Object.Instantiate(uiHelpersToInstantiate);
		}
		lp = UnityEngine.Object.FindObjectOfType<LaserPointer>();
		if (!lp)
		{
			UnityEngine.Debug.LogError("Debug UI requires use of a LaserPointer and will not function without it. Add one to your scene, or assign the UIHelpers prefab to the DebugUIBuilder in the inspector.");
			return;
		}
		lp.laserBeamBehavior = laserBeamBehavior;
		if (!toEnable.Contains(lp.gameObject))
		{
			toEnable.Add(lp.gameObject);
		}
		GetComponent<OVRRaycaster>().pointer = lp.gameObject;
		lp.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		Relayout();
		base.gameObject.SetActive(value: true);
		base.transform.position = rig.transform.TransformPoint(menuOffset);
		Vector3 eulerAngles = rig.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
		if (reEnable == null || reEnable.Length < toDisable.Count)
		{
			reEnable = new bool[toDisable.Count];
		}
		reEnable.Initialize();
		int count = toDisable.Count;
		for (int i = 0; i < count; i++)
		{
			if ((bool)toDisable[i])
			{
				reEnable[i] = toDisable[i].activeSelf;
				toDisable[i].SetActive(value: false);
			}
		}
		count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: true);
		}
		int num = targetContentPanels.Length;
		for (int k = 0; k < num; k++)
		{
			targetContentPanels[k].gameObject.SetActive(insertedElements[k].Count > 0);
		}
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		for (int i = 0; i < reEnable.Length; i++)
		{
			if ((bool)toDisable[i] && reEnable[i])
			{
				toDisable[i].SetActive(value: true);
			}
		}
		int count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: false);
		}
	}

	private void Relayout()
	{
		for (int i = 0; i < targetContentPanels.Length; i++)
		{
			RectTransform component = targetContentPanels[i].GetComponent<RectTransform>();
			List<RectTransform> list = insertedElements[i];
			int count = list.Count;
			float x = 16f;
			float num = -16f;
			float num2 = 0f;
			for (int j = 0; j < count; j++)
			{
				RectTransform rectTransform = list[j];
				rectTransform.anchoredPosition = new Vector2(x, num);
				num -= rectTransform.rect.height + 16f;
				num2 = Mathf.Max(rectTransform.rect.width + 32f, num2);
			}
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 0f - num + 16f);
		}
	}

	private void AddRect(RectTransform r, int targetCanvas)
	{
		if (targetCanvas > targetContentPanels.Length)
		{
			UnityEngine.Debug.LogError("Attempted to add debug panel to canvas " + targetCanvas + ", but only " + targetContentPanels.Length + " panels were provided. Fix in the inspector or pass a lower value for target canvas.");
		}
		else
		{
			r.transform.SetParent(targetContentPanels[targetCanvas], worldPositionStays: false);
			insertedElements[targetCanvas].Add(r);
			if (base.gameObject.activeInHierarchy)
			{
				Relayout();
			}
		}
	}

	public RectTransform AddButton(string label, OnClick handler, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(buttonPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<Button>().onClick.AddListener(delegate
		{
			handler();
		});
		((Text)component.GetComponentsInChildren(typeof(Text), includeInactive: true)[0]).text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddLabel(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(labelPrefab).GetComponent<RectTransform>();
		component.GetComponent<Text>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddSlider(string label, float min, float max, OnSlider onValueChanged, bool wholeNumbersOnly = false, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(sliderPrefab);
		Slider componentInChildren = rectTransform.GetComponentInChildren<Slider>();
		componentInChildren.minValue = min;
		componentInChildren.maxValue = max;
		componentInChildren.onValueChanged.AddListener(delegate(float f)
		{
			onValueChanged(f);
		});
		componentInChildren.wholeNumbers = wholeNumbersOnly;
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddDivider(int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(dividerPrefab);
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, bool defaultValue, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.isOn = defaultValue;
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddRadio(string label, string group, OnToggleValueChange handler, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(radioPrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle tb = rectTransform.GetComponentInChildren<Toggle>();
		if (group == null)
		{
			group = "default";
		}
		ToggleGroup toggleGroup = null;
		bool isOn = false;
		if (!radioGroups.ContainsKey(group))
		{
			toggleGroup = tb.gameObject.AddComponent<ToggleGroup>();
			radioGroups[group] = toggleGroup;
			isOn = true;
		}
		else
		{
			toggleGroup = radioGroups[group];
		}
		tb.group = toggleGroup;
		tb.isOn = isOn;
		tb.onValueChanged.AddListener(delegate
		{
			handler(tb);
		});
		return rectTransform;
	}

	public void ToggleLaserPointer(bool isOn)
	{
		if ((bool)lp)
		{
			if (isOn)
			{
				lp.enabled = true;
			}
			else
			{
				lp.enabled = false;
			}
		}
	}
}
public class HandedInputSelector : MonoBehaviour
{
	private OVRCameraRig m_CameraRig;

	private OVRInputModule m_InputModule;

	private void Start()
	{
		m_CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		m_InputModule = UnityEngine.Object.FindObjectOfType<OVRInputModule>();
	}

	private void Update()
	{
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			SetActiveController(OVRInput.Controller.LTouch);
		}
		else
		{
			SetActiveController(OVRInput.Controller.RTouch);
		}
	}

	private void SetActiveController(OVRInput.Controller c)
	{
		Transform rayTransform = ((c != OVRInput.Controller.LTouch) ? m_CameraRig.rightHandAnchor : m_CameraRig.leftHandAnchor);
		m_InputModule.rayTransform = rayTransform;
	}
}
public class LaserPointer : OVRCursor
{
	public enum LaserBeamBehavior
	{
		On,
		Off,
		OnWhenHitTarget
	}

	public GameObject cursorVisual;

	public float maxLength = 10f;

	private LaserBeamBehavior _laserBeamBehavior;

	private bool m_restoreOnInputAcquired;

	private Vector3 _startPoint;

	private Vector3 _forward;

	private Vector3 _endPoint;

	private bool _hitTarget;

	private LineRenderer lineRenderer;

	public LaserBeamBehavior laserBeamBehavior
	{
		get
		{
			return _laserBeamBehavior;
		}
		set
		{
			_laserBeamBehavior = value;
			if (laserBeamBehavior == LaserBeamBehavior.Off || laserBeamBehavior == LaserBeamBehavior.OnWhenHitTarget)
			{
				lineRenderer.enabled = false;
			}
			else
			{
				lineRenderer.enabled = true;
			}
		}
	}

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
	}

	public override void SetCursorStartDest(Vector3 start, Vector3 dest, Vector3 normal)
	{
		_startPoint = start;
		_endPoint = dest;
		_hitTarget = true;
	}

	public override void SetCursorRay(Transform t)
	{
		_startPoint = t.position;
		_forward = t.forward;
		_hitTarget = false;
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, _startPoint);
		if (_hitTarget)
		{
			lineRenderer.SetPosition(1, _endPoint);
			UpdateLaserBeam(_startPoint, _endPoint);
			if ((bool)cursorVisual)
			{
				cursorVisual.transform.position = _endPoint;
				cursorVisual.SetActive(value: true);
			}
		}
		else
		{
			UpdateLaserBeam(_startPoint, _startPoint + maxLength * _forward);
			lineRenderer.SetPosition(1, _startPoint + maxLength * _forward);
			if ((bool)cursorVisual)
			{
				cursorVisual.SetActive(value: false);
			}
		}
	}

	private void UpdateLaserBeam(Vector3 start, Vector3 end)
	{
		if (laserBeamBehavior == LaserBeamBehavior.Off)
		{
			return;
		}
		if (laserBeamBehavior == LaserBeamBehavior.On)
		{
			lineRenderer.SetPosition(0, start);
			lineRenderer.SetPosition(1, end);
		}
		else
		{
			if (laserBeamBehavior != LaserBeamBehavior.OnWhenHitTarget)
			{
				return;
			}
			if (_hitTarget)
			{
				if (!lineRenderer.enabled)
				{
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, start);
					lineRenderer.SetPosition(1, end);
				}
			}
			else if (lineRenderer.enabled)
			{
				lineRenderer.enabled = false;
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
	}

	public void OnInputFocusLost()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			m_restoreOnInputAcquired = true;
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnInputFocusAcquired()
	{
		if (m_restoreOnInputAcquired && (bool)base.gameObject)
		{
			m_restoreOnInputAcquired = false;
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
	}
}
public class BoundsLockedObject : MonoBehaviour
{
	private Vector3 m_initialOffset;

	public OVRCameraRig m_playerOrigin;

	public GuardianBoundaryEnforcer m_enforcer;

	private Bounds? m_bounds;

	private void Start()
	{
		m_enforcer.TrackingChanged += RefreshDisplay;
		m_initialOffset = base.gameObject.transform.position - m_playerOrigin.transform.position;
		Renderer component = base.gameObject.GetComponent<Renderer>();
		if (component != null)
		{
			m_bounds = component.bounds;
		}
		RefreshDisplay();
	}

	private void RefreshDisplay()
	{
		if (OVRManager.boundary.GetConfigured())
		{
			Vector3[] geometry = OVRManager.boundary.GetGeometry(OVRBoundary.BoundaryType.PlayArea);
			float num = 10000f;
			float num2 = 10000f;
			float num3 = -10000f;
			float num4 = -10000f;
			for (int i = 0; i < geometry.Length; i++)
			{
				geometry[i] = m_enforcer.OrientToOriginalForward * geometry[i];
				num = Mathf.Min(num, geometry[i].x);
				num2 = Mathf.Min(num2, geometry[i].z);
				num3 = Mathf.Max(num3, geometry[i].x);
				num4 = Mathf.Max(num4, geometry[i].z);
			}
			if (m_bounds.HasValue)
			{
				float num5 = m_bounds.Value.size.x * 0.5f;
				float num6 = m_bounds.Value.size.z * 0.5f;
				num += num5;
				num3 -= num5;
				num2 += num6;
				num4 -= num6;
			}
			Vector3 vector = m_initialOffset;
			vector.x = Mathf.Max(Mathf.Min(num3, m_initialOffset.x), num);
			vector.z = Mathf.Max(Mathf.Min(num4, m_initialOffset.z), num2);
			vector.y = base.gameObject.transform.position.y;
			if (m_enforcer.m_AllowRecenter)
			{
				vector = Quaternion.Inverse(m_enforcer.OrientToOriginalForward) * vector;
			}
			base.gameObject.transform.position = vector;
		}
	}
}
public class GuardianBoundaryDisplay : MonoBehaviour
{
	public GuardianBoundaryEnforcer m_enforcer;

	public OVRBoundary.BoundaryType m_boundaryType;

	public GameObject m_errorDisplay;

	private void Start()
	{
		m_enforcer.TrackingChanged += RefreshDisplay;
		RefreshDisplay();
	}

	private void RefreshDisplay()
	{
		bool configured = OVRManager.boundary.GetConfigured();
		if (configured)
		{
			LineRenderer component = GetComponent<LineRenderer>();
			component.positionCount = 0;
			Vector3[] geometry = OVRManager.boundary.GetGeometry(m_boundaryType);
			component.positionCount = geometry.Length + 1;
			Vector3 position;
			for (int i = 0; i < geometry.Length; i++)
			{
				position = geometry[i];
				position.y = 0f;
				component.SetPosition(i, position);
			}
			position = geometry[0];
			position.y = 0f;
			component.SetPosition(geometry.Length, position);
		}
		if ((bool)m_errorDisplay)
		{
			m_errorDisplay.SetActive(!configured);
		}
	}
}
public class GuardianBoundaryEnforcer : MonoBehaviour
{
	public bool m_AllowRecenter = true;

	public OVRCameraRig m_mainCamera;

	private Quaternion m_originalTrackerOrientation;

	private int m_framecount;

	private Quaternion m_orientToOriginalForward;

	public Quaternion OrientToOriginalForward => m_orientToOriginalForward;

	public event Action TrackingChanged;

	private void Start()
	{
		OVRManager.display.RecenteredPose += Recentered;
		m_originalTrackerOrientation = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, OVRPlugin.Step.Render).ToOVRPose().orientation;
	}

	private void Update()
	{
		if (m_framecount < 0)
		{
			return;
		}
		m_framecount++;
		if (m_framecount > 2)
		{
			float num = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, OVRPlugin.Step.Render).ToOVRPose().orientation.eulerAngles.y - m_originalTrackerOrientation.eulerAngles.y;
			m_orientToOriginalForward = Quaternion.Euler(0f, 0f - num, 0f);
			if (!m_AllowRecenter)
			{
				m_mainCamera.trackingSpace.transform.rotation = m_orientToOriginalForward;
			}
			m_framecount = -1;
			if (this.TrackingChanged != null)
			{
				this.TrackingChanged();
			}
		}
	}

	private void Recentered()
	{
		m_framecount = 0;
	}
}
public class CharacterCameraConstraint : MonoBehaviour
{
	private const float FADE_RAY_LENGTH = 0.25f;

	private const float FADE_OVERLAP_MAXIMUM = 0.1f;

	private const float FADE_AMOUNT_MAXIMUM = 1f;

	[Tooltip("This should be a reference to the OVRCameraRig that is usually a child of the PlayerController.")]
	public OVRCameraRig CameraRig;

	[Tooltip("Collision layers to be used for the purposes of fading out the screen when the HMD is inside world geometry and adjusting the capsule height.")]
	public LayerMask CollideLayers;

	[Tooltip("Offset is added to camera's real world height, effectively treating it as though the player was taller/standing higher.")]
	public float HeightOffset;

	[Tooltip("Minimum height that the character capsule can shrink to.  To disable, set to capsule's height.")]
	public float MinimumHeight;

	[Tooltip("Maximum height that the character capsule can grow to.  To disable, set to capsule's height.")]
	public float MaximumHeight;

	private CapsuleCollider _character;

	private SimpleCapsuleWithStickMovement _simplePlayerController;

	private CharacterCameraConstraint()
	{
	}

	private void Awake()
	{
		_character = GetComponent<CapsuleCollider>();
		_simplePlayerController = GetComponent<SimpleCapsuleWithStickMovement>();
	}

	private void OnEnable()
	{
		_simplePlayerController.CameraUpdated += CameraUpdate;
	}

	private void OnDisable()
	{
		_simplePlayerController.CameraUpdated -= CameraUpdate;
	}

	private void CameraUpdate()
	{
		float result = 0f;
		if (CheckCameraOverlapped())
		{
			OVRScreenFade.instance.SetExplicitFade(1f);
		}
		else if (CheckCameraNearClipping(out result))
		{
			float t = Mathf.InverseLerp(0f, 0.1f, result);
			float explicitFade = Mathf.Lerp(0f, 1f, t);
			OVRScreenFade.instance.SetExplicitFade(explicitFade);
		}
		else
		{
			OVRScreenFade.instance.SetExplicitFade(0f);
		}
		float num = 0.25f;
		float value = CameraRig.centerEyeAnchor.localPosition.y + HeightOffset + num;
		float minimumHeight = MinimumHeight;
		minimumHeight = Mathf.Min(_character.height, minimumHeight);
		float b = MaximumHeight;
		if (Physics.SphereCast(_character.transform.position, _character.radius * 0.2f, Vector3.up, out var hitInfo, MaximumHeight - _character.transform.position.y, CollideLayers, QueryTriggerInteraction.Ignore))
		{
			b = hitInfo.point.y;
		}
		b = Mathf.Max(_character.height, b);
		_character.height = Mathf.Clamp(value, minimumHeight, b);
		float y = HeightOffset - _character.height * 0.5f - num;
		CameraRig.transform.localPosition = new Vector3(0f, y, 0f);
	}

	private bool CheckCameraOverlapped()
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3 position = _character.transform.position;
		float num = Mathf.Max(0f, _character.height * 0.5f - component.nearClipPlane - 0.01f);
		position.y = Mathf.Clamp(CameraRig.centerEyeAnchor.position.y, _character.transform.position.y - num, _character.transform.position.y + num);
		Vector3 vector = CameraRig.centerEyeAnchor.position - position;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		RaycastHit hitInfo;
		return Physics.SphereCast(position, component.nearClipPlane, direction, out hitInfo, magnitude, CollideLayers, QueryTriggerInteraction.Ignore);
	}

	private bool CheckCameraNearClipping(out float result)
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3[] array = new Vector3[4];
		component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.nearClipPlane, Camera.MonoOrStereoscopicEye.Mono, array);
		Vector3 vector = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[0])) * 0.25f;
		Vector3 vector2 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[1])) * 0.25f;
		Vector3 vector3 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[2])) * 0.25f;
		Vector3 vector4 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[3])) * 0.25f;
		Vector3 vector5 = (vector2 + vector4) / 2f;
		bool result2 = false;
		result = 0f;
		Vector3[] array2 = new Vector3[5] { vector, vector2, vector3, vector4, vector5 };
		foreach (Vector3 vector6 in array2)
		{
			if (Physics.Linecast(CameraRig.centerEyeAnchor.position, vector6, out var hitInfo, CollideLayers, QueryTriggerInteraction.Ignore))
			{
				result2 = true;
				result = Mathf.Max(result, Vector3.Distance(hitInfo.point, vector6));
			}
		}
		return result2;
	}
}
public class LocomotionController : MonoBehaviour
{
	public OVRCameraRig CameraRig;

	public CapsuleCollider CharacterController;

	public SimpleCapsuleWithStickMovement PlayerController;

	private void Start()
	{
		if (CameraRig == null)
		{
			CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
	}
}
public class LocomotionTeleport : MonoBehaviour
{
	public enum States
	{
		Ready,
		Aim,
		CancelAim,
		PreTeleport,
		CancelTeleport,
		Teleporting,
		PostTeleport
	}

	public enum TeleportIntentions
	{
		None,
		Aim,
		PreTeleport,
		Teleport
	}

	public enum AimCollisionTypes
	{
		Point,
		Sphere,
		Capsule
	}

	public class AimData
	{
		public RaycastHit TargetHitInfo;

		public bool TargetValid;

		public Vector3? Destination;

		public float Radius;

		public List<Vector3> Points { get; private set; }

		public AimData()
		{
			Points = new List<Vector3>();
		}

		public void Reset()
		{
			Points.Clear();
			TargetValid = false;
			Destination = null;
		}
	}

	[Tooltip("Allow linear movement prior to the teleport system being activated.")]
	public bool EnableMovementDuringReady = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableMovementDuringAim = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableMovementDuringPreTeleport = true;

	[Tooltip("Allow linear movement after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableMovementDuringPostTeleport = true;

	[Tooltip("Allow rotation prior to the teleport system being activated.")]
	public bool EnableRotationDuringReady = true;

	[Tooltip("Allow rotation while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableRotationDuringAim = true;

	[Tooltip("Allow rotation while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableRotationDuringPreTeleport = true;

	[Tooltip("Allow rotation after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableRotationDuringPostTeleport = true;

	[NonSerialized]
	public TeleportAimHandler AimHandler;

	[Tooltip("This prefab will be instantiated as needed and updated to match the current aim target.")]
	public TeleportDestination TeleportDestinationPrefab;

	[Tooltip("TeleportDestinationPrefab will be instantiated into this layer.")]
	public int TeleportDestinationLayer;

	[NonSerialized]
	public TeleportInputHandler InputHandler;

	[NonSerialized]
	public TeleportIntentions CurrentIntention;

	[NonSerialized]
	public bool IsPreTeleportRequested;

	[NonSerialized]
	public bool IsTransitioning;

	[NonSerialized]
	public bool IsPostTeleportRequested;

	private TeleportDestination _teleportDestination;

	[Tooltip("When aiming at possible destinations, the aim collision type determines which shape to use for collision tests.")]
	public AimCollisionTypes AimCollisionType;

	[Tooltip("Use the character collision radius/height/skinwidth for sphere/capsule collision tests.")]
	public bool UseCharacterCollisionData;

	[Tooltip("Radius of the sphere or capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionRadius;

	[Tooltip("Height of the capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionHeight;

	public States CurrentState { get; private set; }

	public Quaternion DestinationRotation => _teleportDestination.OrientationIndicator.rotation;

	public LocomotionController LocomotionController { get; private set; }

	public event Action<bool, Vector3?, Quaternion?, Quaternion?> UpdateTeleportDestination;

	public event Action EnterStateReady;

	public event Action EnterStateAim;

	public event Action<AimData> UpdateAimData;

	public event Action ExitStateAim;

	public event Action EnterStateCancelAim;

	public event Action EnterStatePreTeleport;

	public event Action EnterStateCancelTeleport;

	public event Action EnterStateTeleporting;

	public event Action EnterStatePostTeleport;

	public event Action<Transform, Vector3, Quaternion> Teleported;

	public void EnableMovement(bool ready, bool aim, bool pre, bool post)
	{
		EnableMovementDuringReady = ready;
		EnableMovementDuringAim = aim;
		EnableMovementDuringPreTeleport = pre;
		EnableMovementDuringPostTeleport = post;
	}

	public void EnableRotation(bool ready, bool aim, bool pre, bool post)
	{
		EnableRotationDuringReady = ready;
		EnableRotationDuringAim = aim;
		EnableRotationDuringPreTeleport = pre;
		EnableRotationDuringPostTeleport = post;
	}

	public void OnUpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		if (this.UpdateTeleportDestination != null)
		{
			this.UpdateTeleportDestination(isValidDestination, position, rotation, landingRotation);
		}
	}

	public bool AimCollisionTest(Vector3 start, Vector3 end, LayerMask aimCollisionLayerMask, out RaycastHit hitInfo)
	{
		Vector3 vector = end - start;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		switch (AimCollisionType)
		{
		case AimCollisionTypes.Capsule:
		{
			float num;
			float num2;
			if (UseCharacterCollisionData)
			{
				CapsuleCollider characterController = LocomotionController.CharacterController;
				num = characterController.height;
				num2 = characterController.radius;
			}
			else
			{
				num = AimCollisionHeight;
				num2 = AimCollisionRadius;
			}
			return Physics.CapsuleCast(start + new Vector3(0f, num2, 0f), start + new Vector3(0f, num + num2, 0f), num2, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		case AimCollisionTypes.Point:
			return Physics.Raycast(start, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		case AimCollisionTypes.Sphere:
		{
			float radius = ((!UseCharacterCollisionData) ? AimCollisionRadius : LocomotionController.CharacterController.radius);
			return Physics.SphereCast(start, radius, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		default:
			throw new Exception();
		}
	}

	[Conditional("DEBUG_TELEPORT_STATES")]
	protected void LogState(string msg)
	{
		UnityEngine.Debug.Log(Time.frameCount + ": " + msg);
	}

	protected void CreateNewTeleportDestination()
	{
		TeleportDestinationPrefab.gameObject.SetActive(value: false);
		TeleportDestination teleportDestination = UnityEngine.Object.Instantiate(TeleportDestinationPrefab);
		teleportDestination.LocomotionTeleport = this;
		teleportDestination.gameObject.layer = TeleportDestinationLayer;
		_teleportDestination = teleportDestination;
		_teleportDestination.LocomotionTeleport = this;
	}

	private void DeactivateDestination()
	{
		_teleportDestination.OnDeactivated();
	}

	public void RecycleTeleportDestination(TeleportDestination oldDestination)
	{
		if (oldDestination == _teleportDestination)
		{
			CreateNewTeleportDestination();
		}
		UnityEngine.Object.Destroy(oldDestination.gameObject);
	}

	private void EnableMotion(bool enableLinear, bool enableRotation)
	{
		LocomotionController.PlayerController.EnableLinearMovement = enableLinear;
		LocomotionController.PlayerController.EnableRotation = enableRotation;
	}

	private void Awake()
	{
		LocomotionController = GetComponent<LocomotionController>();
		CreateNewTeleportDestination();
	}

	public virtual void OnEnable()
	{
		CurrentState = States.Ready;
		StartCoroutine(ReadyStateCoroutine());
	}

	public virtual void OnDisable()
	{
		StopAllCoroutines();
	}

	protected IEnumerator ReadyStateCoroutine()
	{
		yield return null;
		CurrentState = States.Ready;
		EnableMotion(EnableMovementDuringReady, EnableRotationDuringReady);
		if (this.EnterStateReady != null)
		{
			this.EnterStateReady();
		}
		while (CurrentIntention != TeleportIntentions.Aim)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(AimStateCoroutine());
	}

	public void OnUpdateAimData(AimData aimData)
	{
		if (this.UpdateAimData != null)
		{
			this.UpdateAimData(aimData);
		}
	}

	protected IEnumerator AimStateCoroutine()
	{
		CurrentState = States.Aim;
		EnableMotion(EnableMovementDuringAim, EnableRotationDuringAim);
		if (this.EnterStateAim != null)
		{
			this.EnterStateAim();
		}
		_teleportDestination.gameObject.SetActive(value: true);
		while (CurrentIntention == TeleportIntentions.Aim)
		{
			yield return null;
		}
		if (this.ExitStateAim != null)
		{
			this.ExitStateAim();
		}
		yield return null;
		if ((CurrentIntention == TeleportIntentions.PreTeleport || CurrentIntention == TeleportIntentions.Teleport) && _teleportDestination.IsValidDestination)
		{
			StartCoroutine(PreTeleportStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelAimStateCoroutine());
		}
	}

	protected IEnumerator CancelAimStateCoroutine()
	{
		CurrentState = States.CancelAim;
		if (this.EnterStateCancelAim != null)
		{
			this.EnterStateCancelAim();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator PreTeleportStateCoroutine()
	{
		CurrentState = States.PreTeleport;
		EnableMotion(EnableMovementDuringPreTeleport, EnableRotationDuringPreTeleport);
		if (this.EnterStatePreTeleport != null)
		{
			this.EnterStatePreTeleport();
		}
		while (CurrentIntention == TeleportIntentions.PreTeleport || IsPreTeleportRequested)
		{
			yield return null;
		}
		if (_teleportDestination.IsValidDestination)
		{
			StartCoroutine(TeleportingStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelTeleportStateCoroutine());
		}
	}

	protected IEnumerator CancelTeleportStateCoroutine()
	{
		CurrentState = States.CancelTeleport;
		if (this.EnterStateCancelTeleport != null)
		{
			this.EnterStateCancelTeleport();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator TeleportingStateCoroutine()
	{
		CurrentState = States.Teleporting;
		EnableMotion(enableLinear: false, enableRotation: false);
		if (this.EnterStateTeleporting != null)
		{
			this.EnterStateTeleporting();
		}
		while (IsTransitioning)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(PostTeleportStateCoroutine());
	}

	protected IEnumerator PostTeleportStateCoroutine()
	{
		CurrentState = States.PostTeleport;
		EnableMotion(EnableMovementDuringPostTeleport, EnableRotationDuringPostTeleport);
		if (this.EnterStatePostTeleport != null)
		{
			this.EnterStatePostTeleport();
		}
		while (IsPostTeleportRequested)
		{
			yield return null;
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	public void DoTeleport()
	{
		CapsuleCollider characterController = LocomotionController.CharacterController;
		Transform transform = characterController.transform;
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += characterController.height * 0.5f;
		Quaternion landingRotation = _teleportDestination.LandingRotation;
		if (this.Teleported != null)
		{
			this.Teleported(transform, position, landingRotation);
		}
		transform.position = position;
		transform.rotation = landingRotation;
	}

	public Vector3 GetCharacterPosition()
	{
		return LocomotionController.CharacterController.transform.position;
	}

	public Quaternion GetHeadRotationY()
	{
		Quaternion value = Quaternion.identity;
		InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (deviceAtXRNode.isValid)
		{
			deviceAtXRNode.TryGetFeatureValue(CommonUsages.deviceRotation, out value);
		}
		Vector3 eulerAngles = value.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		return Quaternion.Euler(eulerAngles);
	}

	public void DoWarp(Vector3 startPos, float positionPercent)
	{
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += LocomotionController.CharacterController.height / 2f;
		Transform obj = LocomotionController.CharacterController.transform;
		Vector3 position2 = Vector3.Lerp(startPos, position, positionPercent);
		obj.position = position2;
	}
}
public class SimpleCapsuleWithStickMovement : MonoBehaviour
{
	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed;

	public OVRCameraRig CameraRig;

	private bool ReadyToSnapTurn;

	private Rigidbody _rigidbody;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<OVRCameraRig>();
		}
	}

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		Vector3 position = trackingSpace.position;
		Quaternion rotation = trackingSpace.rotation;
		base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
		trackingSpace.position = position;
		trackingSpace.rotation = rotation;
	}

	private void StickMovement()
	{
		Vector3 eulerAngles = CameraRig.centerEyeAnchor.rotation.eulerAngles;
		eulerAngles.z = (eulerAngles.x = 0f);
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		Vector3 zero = Vector3.zero;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		zero += quaternion * (vector.x * Vector3.right);
		zero += quaternion * (vector.y * Vector3.forward);
		_rigidbody.MovePosition(_rigidbody.position + zero * Speed * Time.fixedDeltaTime);
	}

	private void SnapTurn()
	{
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickLeft)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y -= RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickRight)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y += RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles);
	}
}
public abstract class TeleportAimHandler : TeleportSupport
{
	protected override void OnEnable()
	{
		base.OnEnable();
		base.LocomotionTeleport.AimHandler = this;
	}

	protected override void OnDisable()
	{
		if (base.LocomotionTeleport.AimHandler == this)
		{
			base.LocomotionTeleport.AimHandler = null;
		}
		base.OnDisable();
	}

	public abstract void GetPoints(List<Vector3> points);
}
public class TeleportAimHandlerLaser : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range = 100f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		points.Add(aimRay.origin);
		points.Add(aimRay.origin + aimRay.direction * Range);
	}
}
public class TeleportAimHandlerParabolic : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range;

	[Tooltip("The MinimumElevation is relative to the AimPosition.")]
	public float MinimumElevation = -100f;

	[Tooltip("The Gravity is used in conjunction with AimVelocity and the aim direction to simulate a projectile.")]
	public float Gravity = -9.8f;

	[Tooltip("The AimVelocity is the initial speed of the faked projectile.")]
	[Range(0.001f, 50f)]
	public float AimVelocity = 1f;

	[Tooltip("The AimStep is the how much to subdivide the iteration.")]
	[Range(0.001f, 1f)]
	public float AimStep = 1f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		Vector3 origin = aimRay.origin;
		Vector3 vector = aimRay.direction * AimVelocity;
		float num = Range * Range;
		do
		{
			points.Add(origin);
			Vector3 vector2 = vector;
			vector2.y += Gravity * (1f / 90f) * AimStep;
			vector = vector2;
			origin += vector2 * AimStep;
		}
		while (origin.y - aimRay.origin.y > MinimumElevation && (aimRay.origin - origin).sqrMagnitude <= num);
	}
}
public class TeleportAimVisualLaser : TeleportSupport
{
	[Tooltip("This prefab will be instantiated when the aim visual is awakened, and will be set active when the user is aiming, and deactivated when they are done aiming.")]
	public LineRenderer LaserPrefab;

	private readonly Action _enterAimStateAction;

	private readonly Action _exitAimStateAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	private LineRenderer _lineRenderer;

	private Vector3[] _linePoints;

	public TeleportAimVisualLaser()
	{
		_enterAimStateAction = EnterAimState;
		_exitAimStateAction = ExitAimState;
		_updateAimDataAction = UpdateAimData;
	}

	private void EnterAimState()
	{
		_lineRenderer.gameObject.SetActive(value: true);
	}

	private void ExitAimState()
	{
		_lineRenderer.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		LaserPrefab.gameObject.SetActive(value: false);
		_lineRenderer = UnityEngine.Object.Instantiate(LaserPrefab);
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim += _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateAim -= _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim -= _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
		base.RemoveEventHandlers();
	}

	private void UpdateAimData(LocomotionTeleport.AimData obj)
	{
		_lineRenderer.sharedMaterial.color = (obj.TargetValid ? Color.green : Color.red);
		List<Vector3> points = obj.Points;
		_lineRenderer.positionCount = points.Count;
		for (int i = 0; i < points.Count; i++)
		{
			_lineRenderer.SetPosition(i, points[i]);
		}
	}
}
public class TeleportDestination : MonoBehaviour
{
	[Tooltip("If the target handler provides a target position, this transform will be moved to that position and it's game object enabled. A target position being provided does not mean the position is valid, only that the aim handler found something to test as a destination.")]
	public Transform PositionIndicator;

	[Tooltip("This transform will be rotated to match the rotation of the aiming target. Simple teleport destinations should assign this to the object containing this component. More complex teleport destinations might assign this to a sub-object that is used to indicate the landing orientation independently from the rest of the destination indicator, such as when world space effects are required. This will typically be a child of the PositionIndicator.")]
	public Transform OrientationIndicator;

	[Tooltip("After the player teleports, the character controller will have it's rotation set to this value. It is different from the OrientationIndicator transform.rotation in order to support both head-relative and forward-facing teleport modes (See TeleportOrientationHandlerThumbstick.cs).")]
	public Quaternion LandingRotation;

	[NonSerialized]
	public LocomotionTeleport LocomotionTeleport;

	[NonSerialized]
	public LocomotionTeleport.States TeleportState;

	private readonly Action<bool, Vector3?, Quaternion?, Quaternion?> _updateTeleportDestinationAction;

	private bool _eventsActive;

	public bool IsValidDestination { get; private set; }

	public event Action<TeleportDestination> Deactivated;

	private TeleportDestination()
	{
		_updateTeleportDestinationAction = UpdateTeleportDestination;
	}

	public void OnEnable()
	{
		PositionIndicator.gameObject.SetActive(value: false);
		if (OrientationIndicator != null)
		{
			OrientationIndicator.gameObject.SetActive(value: false);
		}
		LocomotionTeleport.UpdateTeleportDestination += _updateTeleportDestinationAction;
		_eventsActive = true;
	}

	private void TryDisableEventHandlers()
	{
		if (_eventsActive)
		{
			LocomotionTeleport.UpdateTeleportDestination -= _updateTeleportDestinationAction;
			_eventsActive = false;
		}
	}

	public void OnDisable()
	{
		TryDisableEventHandlers();
	}

	public void OnDeactivated()
	{
		if (this.Deactivated != null)
		{
			this.Deactivated(this);
		}
		else
		{
			Recycle();
		}
	}

	public void Recycle()
	{
		LocomotionTeleport.RecycleTeleportDestination(this);
	}

	public virtual void UpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		IsValidDestination = isValidDestination;
		LandingRotation = landingRotation.GetValueOrDefault();
		GameObject gameObject = PositionIndicator.gameObject;
		bool activeInHierarchy = gameObject.activeInHierarchy;
		if (!position.HasValue)
		{
			if (activeInHierarchy)
			{
				gameObject.SetActive(value: false);
			}
			return;
		}
		if (!activeInHierarchy)
		{
			gameObject.SetActive(value: true);
		}
		base.transform.position = position.GetValueOrDefault();
		if (OrientationIndicator == null)
		{
			if (rotation.HasValue)
			{
				base.transform.rotation = rotation.GetValueOrDefault();
			}
			return;
		}
		GameObject gameObject2 = OrientationIndicator.gameObject;
		bool activeInHierarchy2 = gameObject2.activeInHierarchy;
		if (!rotation.HasValue)
		{
			if (activeInHierarchy2)
			{
				gameObject2.SetActive(value: false);
			}
			return;
		}
		OrientationIndicator.rotation = rotation.GetValueOrDefault();
		if (!activeInHierarchy2)
		{
			gameObject2.SetActive(value: true);
		}
	}
}
public abstract class TeleportInputHandler : TeleportSupport
{
	private readonly Action _startReadyAction;

	private readonly Action _startAimAction;

	protected TeleportInputHandler()
	{
		_startReadyAction = delegate
		{
			StartCoroutine(TeleportReadyCoroutine());
		};
		_startAimAction = delegate
		{
			StartCoroutine(TeleportAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.InputHandler = this;
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateReady += _startReadyAction;
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		if (base.LocomotionTeleport.InputHandler == this)
		{
			base.LocomotionTeleport.InputHandler = null;
		}
		base.LocomotionTeleport.EnterStateReady -= _startReadyAction;
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
		base.RemoveEventHandlers();
	}

	private IEnumerator TeleportReadyCoroutine()
	{
		while (GetIntention() != LocomotionTeleport.TeleportIntentions.Aim)
		{
			yield return null;
		}
		base.LocomotionTeleport.CurrentIntention = LocomotionTeleport.TeleportIntentions.Aim;
	}

	private IEnumerator TeleportAimCoroutine()
	{
		LocomotionTeleport.TeleportIntentions intention = GetIntention();
		while (intention == LocomotionTeleport.TeleportIntentions.Aim || intention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			base.LocomotionTeleport.CurrentIntention = intention;
			yield return null;
			intention = GetIntention();
		}
		base.LocomotionTeleport.CurrentIntention = intention;
	}

	public abstract LocomotionTeleport.TeleportIntentions GetIntention();

	public abstract void GetAimData(out Ray aimRay);
}
public class TeleportInputHandlerHMD : TeleportInputHandler
{
	[Tooltip("The button used to begin aiming for a teleport.")]
	public OVRInput.RawButton AimButton;

	[Tooltip("The button used to trigger the teleport after aiming. It can be the same button as the AimButton, however you cannot abort a teleport if it is.")]
	public OVRInput.RawButton TeleportButton;

	[Tooltip("When true, the system will not use the PreTeleport intention which will allow a teleport to occur on a button downpress. When false, the button downpress will trigger the PreTeleport intention and the Teleport intention when the button is released.")]
	public bool FastTeleport;

	public Transform Pointer { get; private set; }

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(TeleportButton))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (OVRInput.GetUp(TeleportButton))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.Get(AimButton))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (AimButton == TeleportButton)
		{
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
		aimRay = new Ray(centerEyeAnchor.position, centerEyeAnchor.forward);
	}
}
public class TeleportInputHandlerTouch : TeleportInputHandlerHMD
{
	public enum InputModes
	{
		CapacitiveButtonForAimAndTeleport,
		SeparateButtonsForAimAndTeleport,
		ThumbstickTeleport,
		ThumbstickTeleportForwardBackOnly
	}

	public enum AimCapTouchButtons
	{
		A,
		B,
		LeftTrigger,
		LeftThumbstick,
		RightTrigger,
		RightThumbstick,
		X,
		Y
	}

	public Transform LeftHand;

	public Transform RightHand;

	[Tooltip("CapacitiveButtonForAimAndTeleport=Activate aiming via cap touch detection, press the same button to teleport.\nSeparateButtonsForAimAndTeleport=Use one button to begin aiming, and another to trigger the teleport.\nThumbstickTeleport=Push a thumbstick to begin aiming, release to teleport.")]
	public InputModes InputMode;

	private readonly OVRInput.RawButton[] _rawButtons = new OVRInput.RawButton[8]
	{
		OVRInput.RawButton.A,
		OVRInput.RawButton.B,
		OVRInput.RawButton.LIndexTrigger,
		OVRInput.RawButton.LThumbstick,
		OVRInput.RawButton.RIndexTrigger,
		OVRInput.RawButton.RThumbstick,
		OVRInput.RawButton.X,
		OVRInput.RawButton.Y
	};

	private readonly OVRInput.RawTouch[] _rawTouch = new OVRInput.RawTouch[8]
	{
		OVRInput.RawTouch.A,
		OVRInput.RawTouch.B,
		OVRInput.RawTouch.LIndexTrigger,
		OVRInput.RawTouch.LThumbstick,
		OVRInput.RawTouch.RIndexTrigger,
		OVRInput.RawTouch.RThumbstick,
		OVRInput.RawTouch.X,
		OVRInput.RawTouch.Y
	};

	[Tooltip("Select the controller to be used for aiming. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller AimingController;

	private OVRInput.Controller InitiatingController;

	[Tooltip("Select the button to use for triggering aim and teleport when InputMode==CapacitiveButtonForAimAndTeleport")]
	public AimCapTouchButtons CapacitiveAimAndTeleportButton;

	[Tooltip("The thumbstick magnitude required to trigger aiming and teleports when InputMode==InputModes.ThumbstickTeleport")]
	public float ThumbstickTeleportThreshold = 0.5f;

	private void Start()
	{
	}

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (InputMode == InputModes.SeparateButtonsForAimAndTeleport)
		{
			return base.GetIntention();
		}
		if (InputMode == InputModes.ThumbstickTeleport || InputMode == InputModes.ThumbstickTeleportForwardBackOnly)
		{
			Vector2 lhs = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 lhs2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			OVRInput.Controller controller = OVRInput.Controller.Touch;
			bool flag = OVRInput.Get(OVRInput.RawTouch.LThumbstick);
			bool flag2 = OVRInput.Get(OVRInput.RawTouch.RThumbstick);
			if (InputMode == InputModes.ThumbstickTeleportForwardBackOnly && base.LocomotionTeleport.CurrentIntention != LocomotionTeleport.TeleportIntentions.Aim)
			{
				num = Mathf.Abs(Vector2.Dot(lhs, Vector2.up));
				num2 = Mathf.Abs(Vector2.Dot(lhs2, Vector2.up));
			}
			else
			{
				num = lhs.magnitude;
				num2 = lhs2.magnitude;
			}
			if (AimingController == OVRInput.Controller.LTouch)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else if (AimingController == OVRInput.Controller.RTouch)
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			else if (num > num2)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			if (!(num3 > ThumbstickTeleportThreshold) && (AimingController != OVRInput.Controller.Touch || !(flag || flag2)) && !(AimingController == OVRInput.Controller.LTouch && flag) && !(AimingController == OVRInput.Controller.RTouch && flag2))
			{
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
				{
					if (!FastTeleport)
					{
						return LocomotionTeleport.TeleportIntentions.PreTeleport;
					}
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
				{
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
			}
			else if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
			{
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			if (num3 > ThumbstickTeleportThreshold)
			{
				InitiatingController = controller;
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			return LocomotionTeleport.TeleportIntentions.None;
		}
		OVRInput.RawButton rawMask = _rawButtons[(int)CapacitiveAimAndTeleportButton];
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(rawMask))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (FastTeleport || OVRInput.GetUp(rawMask))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.GetDown(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && !OVRInput.GetUp(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		OVRInput.Controller controller = AimingController;
		if (controller == OVRInput.Controller.Touch)
		{
			controller = InitiatingController;
		}
		Transform transform = ((controller == OVRInput.Controller.LTouch) ? LeftHand : RightHand);
		aimRay = new Ray(transform.position, transform.forward);
	}
}
public abstract class TeleportOrientationHandler : TeleportSupport
{
	public enum OrientationModes
	{
		HeadRelative,
		ForwardFacing
	}

	private readonly Action _updateOrientationAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	protected LocomotionTeleport.AimData AimData;

	protected TeleportOrientationHandler()
	{
		_updateOrientationAction = delegate
		{
			StartCoroutine(UpdateOrientationCoroutine());
		};
		_updateAimDataAction = UpdateAimData;
	}

	private void UpdateAimData(LocomotionTeleport.AimData aimData)
	{
		AimData = aimData;
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
	}

	private IEnumerator UpdateOrientationCoroutine()
	{
		InitializeTeleportDestination();
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport)
		{
			if (AimData != null)
			{
				UpdateTeleportDestination();
			}
			yield return null;
		}
	}

	protected abstract void InitializeTeleportDestination();

	protected abstract void UpdateTeleportDestination();

	protected Quaternion GetLandingOrientation(OrientationModes mode, Quaternion rotation)
	{
		if (mode != 0)
		{
			return rotation * Quaternion.Euler(0f, 0f - base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.localEulerAngles.y, 0f);
		}
		return rotation;
	}
}
public class TeleportOrientationHandler360 : TeleportOrientationHandler
{
	protected override void InitializeTeleportDestination()
	{
	}

	protected override void UpdateTeleportDestination()
	{
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, null, null);
	}
}
public class TeleportOrientationHandlerHMD : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Should the destination orientation be updated during the aim state in addition to the PreTeleport state?")]
	public bool UpdateOrientationDuringAim;

	[Tooltip("How far from the destination must the HMD be pointing before using it for orientation")]
	public float AimDistanceThreshold;

	[Tooltip("How far from the destination must the HMD be pointing before rejecting the teleport")]
	public float AimDistanceMaxRange;

	private Quaternion _initialRotation;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = Quaternion.identity;
	}

	protected override void UpdateTeleportDestination()
	{
		if (AimData.Destination.HasValue && (UpdateOrientationDuringAim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport))
		{
			Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
			Vector3 valueOrDefault = AimData.Destination.GetValueOrDefault();
			if (new Plane(Vector3.up, valueOrDefault).Raycast(new Ray(centerEyeAnchor.position, centerEyeAnchor.forward), out var enter))
			{
				Vector3 vector = centerEyeAnchor.position + centerEyeAnchor.forward * enter - valueOrDefault;
				vector.y = 0f;
				float magnitude = vector.magnitude;
				if (magnitude > AimDistanceThreshold)
				{
					vector.Normalize();
					Quaternion quaternion = (_initialRotation = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z), Vector3.up));
					if (AimDistanceMaxRange > 0f && magnitude > AimDistanceMaxRange)
					{
						AimData.TargetValid = false;
					}
					base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, quaternion, GetLandingOrientation(OrientationMode, quaternion));
					return;
				}
			}
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _initialRotation, GetLandingOrientation(OrientationMode, _initialRotation));
	}
}
public class TeleportOrientationHandlerThumbstick : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Which thumbstick is to be used for adjusting the teleport orientation. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller Thumbstick;

	[Tooltip("The orientation will only change if the thumbstick magnitude is above this value. This will usually be larger than the TeleportInputHandlerTouch.ThumbstickTeleportThreshold.")]
	public float RotateStickThreshold = 0.8f;

	private Quaternion _initialRotation;

	private Quaternion _currentRotation;

	private Vector2 _lastValidDirection;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
		_currentRotation = _initialRotation;
		_lastValidDirection = default(Vector2);
	}

	protected override void UpdateTeleportDestination()
	{
		float num;
		Vector2 lastValidDirection;
		if (Thumbstick == OVRInput.Controller.Touch)
		{
			Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude > magnitude2)
			{
				num = magnitude;
				lastValidDirection = vector;
			}
			else
			{
				num = magnitude2;
				lastValidDirection = vector2;
			}
		}
		else
		{
			lastValidDirection = ((Thumbstick != OVRInput.Controller.LTouch) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			num = lastValidDirection.magnitude;
		}
		if (!AimData.TargetValid)
		{
			_lastValidDirection = default(Vector2);
		}
		if (num < RotateStickThreshold)
		{
			lastValidDirection = _lastValidDirection;
			num = lastValidDirection.magnitude;
			if (num < RotateStickThreshold)
			{
				_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
				lastValidDirection.x = 0f;
				lastValidDirection.y = 1f;
			}
		}
		else
		{
			_lastValidDirection = lastValidDirection;
		}
		Quaternion rotation = base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.rotation;
		if (num > RotateStickThreshold)
		{
			lastValidDirection /= num;
			Quaternion quaternion = _initialRotation * Quaternion.LookRotation(new Vector3(lastValidDirection.x, 0f, lastValidDirection.y), Vector3.up);
			_currentRotation = rotation * quaternion;
		}
		else
		{
			_currentRotation = rotation * base.LocomotionTeleport.GetHeadRotationY();
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _currentRotation, GetLandingOrientation(OrientationMode, _currentRotation));
	}
}
public class TeleportPoint : MonoBehaviour
{
	public float dimmingSpeed = 1f;

	public float fullIntensity = 1f;

	public float lowIntensity = 0.5f;

	public Transform destTransform;

	private float lastLookAtTime;

	private void Start()
	{
	}

	public Transform GetDestTransform()
	{
		return destTransform;
	}

	private void Update()
	{
		float value = Mathf.SmoothStep(fullIntensity, lowIntensity, (Time.time - lastLookAtTime) * dimmingSpeed);
		GetComponent<MeshRenderer>().material.SetFloat("_Intensity", value);
	}

	public void OnLookAt()
	{
		lastLookAtTime = Time.time;
	}
}
public abstract class TeleportSupport : MonoBehaviour
{
	private bool _eventsActive;

	protected LocomotionTeleport LocomotionTeleport { get; private set; }

	protected virtual void OnEnable()
	{
		LocomotionTeleport = GetComponent<LocomotionTeleport>();
		AddEventHandlers();
	}

	protected virtual void OnDisable()
	{
		RemoveEventHandlers();
		LocomotionTeleport = null;
	}

	[Conditional("DEBUG_TELEPORT_EVENT_HANDLERS")]
	private void LogEventHandler(string msg)
	{
		UnityEngine.Debug.Log("EventHandler: " + GetType().Name + ": " + msg);
	}

	protected virtual void AddEventHandlers()
	{
		_eventsActive = true;
	}

	protected virtual void RemoveEventHandlers()
	{
		_eventsActive = false;
	}
}
public abstract class TeleportTargetHandler : TeleportSupport
{
	[Tooltip("This bitmask controls which game object layers will be included in the targeting collision tests.")]
	public LayerMask AimCollisionLayerMask;

	protected readonly LocomotionTeleport.AimData AimData = new LocomotionTeleport.AimData();

	private readonly Action _startAimAction;

	private readonly List<Vector3> _aimPoints = new List<Vector3>();

	private const float ERROR_MARGIN = 0.1f;

	protected TeleportTargetHandler()
	{
		_startAimAction = delegate
		{
			StartCoroutine(TargetAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
	}

	private IEnumerator TargetAimCoroutine()
	{
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim)
		{
			ResetAimData();
			Vector3 start = base.LocomotionTeleport.transform.position;
			_aimPoints.Clear();
			base.LocomotionTeleport.AimHandler.GetPoints(_aimPoints);
			for (int i = 0; i < _aimPoints.Count; i++)
			{
				Vector3 end = _aimPoints[i];
				AimData.TargetValid = ConsiderTeleport(start, ref end);
				AimData.Points.Add(end);
				if (AimData.TargetValid)
				{
					AimData.Destination = ConsiderDestination(end);
					AimData.TargetValid = AimData.Destination.HasValue;
					break;
				}
				start = _aimPoints[i];
			}
			base.LocomotionTeleport.OnUpdateAimData(AimData);
			yield return null;
		}
	}

	protected virtual void ResetAimData()
	{
		AimData.Reset();
	}

	protected abstract bool ConsiderTeleport(Vector3 start, ref Vector3 end);

	public virtual Vector3? ConsiderDestination(Vector3 location)
	{
		CapsuleCollider characterController = base.LocomotionTeleport.LocomotionController.CharacterController;
		float num = characterController.radius - 0.1f;
		Vector3 vector = location;
		vector.y += num + 0.1f;
		Vector3 end = vector;
		end.y += characterController.height - 0.1f;
		if (Physics.CheckCapsule(vector, end, num, AimCollisionLayerMask, QueryTriggerInteraction.Ignore))
		{
			return null;
		}
		return location;
	}
}
public class TeleportTargetHandlerNavMesh : TeleportTargetHandler
{
	public int NavMeshAreaMask = -1;

	private NavMeshPath _path;

	private void Awake()
	{
		_path = new NavMeshPath();
	}

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}

	public override Vector3? ConsiderDestination(Vector3 location)
	{
		Vector3? result = base.ConsiderDestination(location);
		if (result.HasValue)
		{
			Vector3 characterPosition = base.LocomotionTeleport.GetCharacterPosition();
			Vector3 valueOrDefault = result.GetValueOrDefault();
			NavMesh.CalculatePath(characterPosition, valueOrDefault, NavMeshAreaMask, _path);
			if (_path.status == NavMeshPathStatus.PathComplete)
			{
				return result;
			}
		}
		return null;
	}

	[Conditional("SHOW_PATH_RESULT")]
	private void OnDrawGizmos()
	{
	}
}
public class TeleportTargetHandlerNode : TeleportTargetHandler
{
	[Tooltip("When checking line of sight to the destination, add this value to the vertical offset for targeting collision checks.")]
	public float LOSOffset = 1f;

	[Tooltip("Teleport logic will only work with TeleportPoint components that exist in the layers specified by this mask.")]
	public LayerMask TeleportLayerMask;

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (!base.LocomotionTeleport.AimCollisionTest(start, end, (int)AimCollisionLayerMask | (int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		TeleportPoint component = AimData.TargetHitInfo.collider.gameObject.GetComponent<TeleportPoint>();
		if (component == null)
		{
			return false;
		}
		Vector3 position = component.destTransform.position;
		Vector3 end2 = new Vector3(position.x, position.y + LOSOffset, position.z);
		if (base.LocomotionTeleport.AimCollisionTest(start, end2, (int)AimCollisionLayerMask & ~(int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		end = position;
		return true;
	}
}
public class TeleportTargetHandlerPhysical : TeleportTargetHandler
{
	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}
}
public abstract class TeleportTransition : TeleportSupport
{
	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting += LocomotionTeleportOnEnterStateTeleporting;
		base.AddEventHandlers();
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting -= LocomotionTeleportOnEnterStateTeleporting;
		base.RemoveEventHandlers();
	}

	protected abstract void LocomotionTeleportOnEnterStateTeleporting();
}
public class TeleportTransitionBlink : TeleportTransition
{
	[Tooltip("How long the transition takes. Usually this is greater than Teleport Delay.")]
	[Range(0.01f, 2f)]
	public float TransitionDuration = 0.5f;

	[Tooltip("At what percentage of the elapsed transition time does the teleport occur?")]
	[Range(0f, 1f)]
	public float TeleportDelay = 0.5f;

	[Tooltip("Fade to black over the duration of the transition")]
	public AnimationCurve FadeLevels = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(BlinkCoroutine());
	}

	protected IEnumerator BlinkCoroutine()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		float elapsedTime = 0f;
		float teleportTime = TransitionDuration * TeleportDelay;
		bool teleported = false;
		while (elapsedTime < TransitionDuration)
		{
			yield return null;
			elapsedTime += Time.deltaTime;
			if (!teleported && elapsedTime >= teleportTime)
			{
				teleported = true;
				base.LocomotionTeleport.DoTeleport();
			}
		}
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public class TeleportTransitionInstant : TeleportTransition
{
	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		base.LocomotionTeleport.DoTeleport();
	}
}
public class TeleportTransitionWarp : TeleportTransition
{
	[Tooltip("How much time the warp transition takes to complete.")]
	[Range(0.01f, 1f)]
	public float TransitionDuration = 0.5f;

	[HideInInspector]
	public AnimationCurve PositionLerp = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(DoWarp());
	}

	private IEnumerator DoWarp()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		Vector3 startPosition = base.LocomotionTeleport.GetCharacterPosition();
		float elapsedTime = 0f;
		while (elapsedTime < TransitionDuration)
		{
			elapsedTime += Time.deltaTime;
			float time = elapsedTime / TransitionDuration;
			float positionPercent = PositionLerp.Evaluate(time);
			base.LocomotionTeleport.DoWarp(startPosition, positionPercent);
			yield return null;
		}
		base.LocomotionTeleport.DoWarp(startPosition, 1f);
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public static class NativeVideoPlayer
{
	public enum PlabackState
	{
		Idle = 1,
		Preparing,
		Buffering,
		Ready,
		Ended
	}

	private static IntPtr? _Activity;

	private static IntPtr? _VideoPlayerClass;

	private static readonly jvalue[] EmptyParams = new jvalue[0];

	private static IntPtr getIsPlayingMethodId;

	private static IntPtr getCurrentPlaybackStateMethodId;

	private static IntPtr getDurationMethodId;

	private static IntPtr getPlaybackPositionMethodId;

	private static IntPtr setPlaybackPositionMethodId;

	private static jvalue[] setPlaybackPositionParams;

	private static IntPtr playVideoMethodId;

	private static jvalue[] playVideoParams;

	private static IntPtr stopMethodId;

	private static IntPtr resumeMethodId;

	private static IntPtr pauseMethodId;

	private static IntPtr setPlaybackSpeedMethodId;

	private static jvalue[] setPlaybackSpeedParams;

	private static IntPtr setLoopingMethodId;

	private static jvalue[] setLoopingParams;

	private static IntPtr setListenerRotationQuaternionMethodId;

	private static jvalue[] setListenerRotationQuaternionParams;

	private static IntPtr VideoPlayerClass
	{
		get
		{
			if (!_VideoPlayerClass.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/oculus/videoplayer/NativeVideoPlayer");
					if (intPtr != IntPtr.Zero)
					{
						_VideoPlayerClass = AndroidJNI.NewGlobalRef(intPtr);
						AndroidJNI.DeleteLocalRef(intPtr);
					}
					else
					{
						UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
						_VideoPlayerClass = IntPtr.Zero;
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
					UnityEngine.Debug.LogException(exception);
					_VideoPlayerClass = IntPtr.Zero;
				}
			}
			return _VideoPlayerClass.GetValueOrDefault();
		}
	}

	private static IntPtr Activity
	{
		get
		{
			if (!_Activity.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/unity3d/player/UnityPlayer");
					IntPtr staticFieldID = AndroidJNI.GetStaticFieldID(intPtr, "currentActivity", "Landroid/app/Activity;");
					IntPtr staticObjectField = AndroidJNI.GetStaticObjectField(intPtr, staticFieldID);
					_Activity = AndroidJNI.NewGlobalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(intPtr);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					_Activity = IntPtr.Zero;
				}
			}
			return _Activity.GetValueOrDefault();
		}
	}

	public static bool IsAvailable => VideoPlayerClass != IntPtr.Zero;

	public static bool IsPlaying
	{
		get
		{
			if (getIsPlayingMethodId == IntPtr.Zero)
			{
				getIsPlayingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getIsPlaying", "()Z");
			}
			return AndroidJNI.CallStaticBooleanMethod(VideoPlayerClass, getIsPlayingMethodId, EmptyParams);
		}
	}

	public static PlabackState CurrentPlaybackState
	{
		get
		{
			if (getCurrentPlaybackStateMethodId == IntPtr.Zero)
			{
				getCurrentPlaybackStateMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getCurrentPlaybackState", "()I");
			}
			return (PlabackState)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getCurrentPlaybackStateMethodId, EmptyParams);
		}
	}

	public static long Duration
	{
		get
		{
			if (getDurationMethodId == IntPtr.Zero)
			{
				getDurationMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getDuration", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getDurationMethodId, EmptyParams);
		}
	}

	public static long PlaybackPosition
	{
		get
		{
			if (getPlaybackPositionMethodId == IntPtr.Zero)
			{
				getPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getPlaybackPosition", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getPlaybackPositionMethodId, EmptyParams);
		}
		set
		{
			if (setPlaybackPositionMethodId == IntPtr.Zero)
			{
				setPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackPosition", "(J)V");
				setPlaybackPositionParams = new jvalue[1];
			}
			setPlaybackPositionParams[0].j = value;
			AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackPositionMethodId, setPlaybackPositionParams);
		}
	}

	public static void PlayVideo(string path, string drmLicenseUrl, IntPtr surfaceObj)
	{
		if (playVideoMethodId == IntPtr.Zero)
		{
			playVideoMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "playVideo", "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;Landroid/view/Surface;)V");
			playVideoParams = new jvalue[4];
		}
		IntPtr intPtr = AndroidJNI.NewStringUTF(path);
		IntPtr intPtr2 = AndroidJNI.NewStringUTF(drmLicenseUrl);
		playVideoParams[0].l = Activity;
		playVideoParams[1].l = intPtr;
		playVideoParams[2].l = intPtr2;
		playVideoParams[3].l = surfaceObj;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, playVideoMethodId, playVideoParams);
		AndroidJNI.DeleteLocalRef(intPtr);
		AndroidJNI.DeleteLocalRef(intPtr2);
	}

	public static void Stop()
	{
		if (stopMethodId == IntPtr.Zero)
		{
			stopMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "stop", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, stopMethodId, EmptyParams);
	}

	public static void Play()
	{
		if (resumeMethodId == IntPtr.Zero)
		{
			resumeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "resume", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, resumeMethodId, EmptyParams);
	}

	public static void Pause()
	{
		if (pauseMethodId == IntPtr.Zero)
		{
			pauseMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "pause", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, pauseMethodId, EmptyParams);
	}

	public static void SetPlaybackSpeed(float speed)
	{
		if (setPlaybackSpeedMethodId == IntPtr.Zero)
		{
			setPlaybackSpeedMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackSpeed", "(F)V");
			setPlaybackSpeedParams = new jvalue[1];
		}
		setPlaybackSpeedParams[0].f = speed;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackSpeedMethodId, setPlaybackSpeedParams);
	}

	public static void SetLooping(bool looping)
	{
		if (setLoopingMethodId == IntPtr.Zero)
		{
			setLoopingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setLooping", "(Z)V");
			setLoopingParams = new jvalue[1];
		}
		setLoopingParams[0].z = looping;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setLoopingMethodId, setLoopingParams);
	}

	public static void SetListenerRotation(Quaternion rotation)
	{
		if (setListenerRotationQuaternionMethodId == IntPtr.Zero)
		{
			setListenerRotationQuaternionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setListenerRotationQuaternion", "(FFFF)V");
			setListenerRotationQuaternionParams = new jvalue[4];
		}
		setListenerRotationQuaternionParams[0].f = rotation.x;
		setListenerRotationQuaternionParams[1].f = rotation.y;
		setListenerRotationQuaternionParams[2].f = rotation.z;
		setListenerRotationQuaternionParams[3].f = rotation.w;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setListenerRotationQuaternionMethodId, setListenerRotationQuaternionParams);
	}
}
public class ButtonDownListener : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public event Action onButtonDown;

	public void OnPointerDown(PointerEventData eventData)
	{
		if (this.onButtonDown != null)
		{
			this.onButtonDown();
		}
	}
}
public class MediaPlayerImage : Image
{
	public enum ButtonType
	{
		Play,
		Pause,
		FastForward,
		Rewind,
		SkipForward,
		SkipBack,
		Stop
	}

	[SerializeField]
	private ButtonType m_ButtonType;

	public ButtonType buttonType
	{
		get
		{
			return m_ButtonType;
		}
		set
		{
			if (m_ButtonType != value)
			{
				m_ButtonType = value;
				SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper toFill)
	{
		Rect pixelAdjustedRect = GetPixelAdjustedRect();
		Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
		Color32 color = this.color;
		toFill.Clear();
		switch (m_ButtonType)
		{
		case ButtonType.Play:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			break;
		case ButtonType.Pause:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.w), color, new Vector2(0.35f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.y), color, new Vector2(0.35f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.y), color, new Vector2(0.65f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.w), color, new Vector2(0.65f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(6, 7, 4);
			break;
		case ButtonType.FastForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.Rewind:
			toFill.AddVert(new Vector3(vector.x, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.SkipForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.4375f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.y), color, new Vector2(0.4375f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.w), color, new Vector2(0.4375f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.875f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.y), color, new Vector2(0.875f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.w), color, new Vector2(0.875f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			toFill.AddTriangle(6, 7, 8);
			toFill.AddTriangle(8, 9, 6);
			break;
		case ButtonType.SkipBack:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.w), color, new Vector2(0.125f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.y), color, new Vector2(0.125f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.125f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.w), color, new Vector2(0.5625f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.y), color, new Vector2(0.5625f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5625f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(7, 8, 9);
			break;
		default:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			break;
		}
	}
}
public class MoviePlayerSample : MonoBehaviour
{
	public enum VideoShape
	{
		_360,
		_180,
		Quad
	}

	public enum VideoStereo
	{
		Mono,
		TopBottom,
		LeftRight,
		BottomTop
	}

	private bool videoPausedBeforeAppPause;

	private VideoPlayer videoPlayer;

	private OVROverlay overlay;

	private Renderer mediaRenderer;

	private RenderTexture copyTexture;

	private Material externalTex2DMaterial;

	public string MovieName;

	public string DrmLicenseUrl;

	public bool LoopVideo;

	public VideoShape Shape;

	public VideoStereo Stereo;

	public bool DisplayMono;

	private VideoShape _LastShape = (VideoShape)(-1);

	private VideoStereo _LastStereo = (VideoStereo)(-1);

	private bool _LastDisplayMono;

	public bool IsPlaying { get; private set; }

	public long Duration { get; private set; }

	public long PlaybackPosition { get; private set; }

	private void Awake()
	{
		UnityEngine.Debug.Log("MovieSample Awake");
		mediaRenderer = GetComponent<Renderer>();
		videoPlayer = GetComponent<VideoPlayer>();
		if (videoPlayer == null)
		{
			videoPlayer = base.gameObject.AddComponent<VideoPlayer>();
		}
		videoPlayer.isLooping = LoopVideo;
		overlay = GetComponent<OVROverlay>();
		if (overlay == null)
		{
			overlay = base.gameObject.AddComponent<OVROverlay>();
		}
		overlay.enabled = false;
		overlay.isExternalSurface = NativeVideoPlayer.IsAvailable;
		overlay.enabled = overlay.currentOverlayShape != OVROverlay.OverlayShape.Equirect || UnityEngine.Application.platform == RuntimePlatform.Android;
	}

	private bool IsLocalVideo(string movieName)
	{
		return !movieName.Contains("://");
	}

	private void UpdateShapeAndStereo()
	{
		if (Shape != _LastShape || Stereo != _LastStereo || DisplayMono != _LastDisplayMono)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			switch (Shape)
			{
			case VideoShape._360:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				break;
			case VideoShape._180:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				rect = new Rect(0.25f, 0f, 0.5f, 1f);
				break;
			default:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
				break;
			}
			overlay.overrideTextureRectMatrix = true;
			Rect rect2 = new Rect(0f, 0f, 1f, 1f);
			Rect rect3 = new Rect(0f, 0f, 1f, 1f);
			switch (Stereo)
			{
			case VideoStereo.LeftRight:
				rect2 = new Rect(0f, 0f, 0.5f, 1f);
				rect3 = new Rect(0.5f, 0f, 0.5f, 1f);
				break;
			case VideoStereo.TopBottom:
				rect2 = new Rect(0f, 0.5f, 1f, 0.5f);
				rect3 = new Rect(0f, 0f, 1f, 0.5f);
				break;
			case VideoStereo.BottomTop:
				rect2 = new Rect(0f, 0f, 1f, 0.5f);
				rect3 = new Rect(0f, 0.5f, 1f, 0.5f);
				break;
			}
			overlay.invertTextureRects = false;
			overlay.SetSrcDestRects(rect2, DisplayMono ? rect2 : rect3, rect, rect);
			_LastDisplayMono = DisplayMono;
			_LastStereo = Stereo;
			_LastShape = Shape;
		}
	}

	private IEnumerator Start()
	{
		if (mediaRenderer.material == null)
		{
			UnityEngine.Debug.LogError("No material for movie surface");
			yield break;
		}
		yield return new WaitForSeconds(1f);
		if (!string.IsNullOrEmpty(MovieName))
		{
			if (IsLocalVideo(MovieName))
			{
				Play(UnityEngine.Application.streamingAssetsPath + "/" + MovieName, null);
			}
			else
			{
				Play(MovieName, DrmLicenseUrl);
			}
		}
	}

	public void Play(string moviePath, string drmLicencesUrl)
	{
		if (moviePath != string.Empty)
		{
			UnityEngine.Debug.Log("Playing Video: " + moviePath);
			if (overlay.isExternalSurface)
			{
				OVROverlay.ExternalSurfaceObjectCreated externalSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("Playing ExoPlayer with SurfaceObject");
					NativeVideoPlayer.PlayVideo(moviePath, drmLicencesUrl, overlay.externalSurfaceObject);
					NativeVideoPlayer.SetLooping(LoopVideo);
				};
				if (overlay.externalSurfaceObject == IntPtr.Zero)
				{
					overlay.externalSurfaceObjectCreated = externalSurfaceObjectCreated;
				}
				else
				{
					externalSurfaceObjectCreated();
				}
			}
			else
			{
				UnityEngine.Debug.Log("Playing Unity VideoPlayer");
				videoPlayer.url = moviePath;
				videoPlayer.Prepare();
				videoPlayer.Play();
			}
			UnityEngine.Debug.Log("MovieSample Start");
			IsPlaying = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No media file name provided");
		}
	}

	public void Play()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Play();
		}
		else
		{
			videoPlayer.Play();
		}
		IsPlaying = true;
	}

	public void Pause()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Pause();
		}
		else
		{
			videoPlayer.Pause();
		}
		IsPlaying = false;
	}

	public void SeekTo(long position)
	{
		long num = Math.Max(0L, Math.Min(Duration, position));
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.PlaybackPosition = num;
		}
		else
		{
			videoPlayer.time = (double)num / 1000.0;
		}
	}

	private void Update()
	{
		UpdateShapeAndStereo();
		if (!overlay.isExternalSurface)
		{
			Texture texture = ((videoPlayer.texture != null) ? videoPlayer.texture : Texture2D.blackTexture);
			if (overlay.enabled)
			{
				if (overlay.textures[0] != texture)
				{
					overlay.enabled = false;
					overlay.textures[0] = texture;
					overlay.enabled = true;
				}
			}
			else
			{
				mediaRenderer.material.mainTexture = texture;
				mediaRenderer.material.SetVector("_SrcRectLeft", overlay.srcRectLeft.ToVector());
				mediaRenderer.material.SetVector("_SrcRectRight", overlay.srcRectRight.ToVector());
			}
			IsPlaying = videoPlayer.isPlaying;
			PlaybackPosition = (long)(videoPlayer.time * 1000.0);
			Duration = (long)(videoPlayer.length * 1000.0);
		}
		else
		{
			NativeVideoPlayer.SetListenerRotation(Camera.main.transform.rotation);
			IsPlaying = NativeVideoPlayer.IsPlaying;
			PlaybackPosition = NativeVideoPlayer.PlaybackPosition;
			Duration = NativeVideoPlayer.Duration;
			if (IsPlaying && (int)OVRManager.display.displayFrequency != 60)
			{
				OVRManager.display.displayFrequency = 60f;
			}
			else if (!IsPlaying && (int)OVRManager.display.displayFrequency != 72)
			{
				OVRManager.display.displayFrequency = 72f;
			}
		}
	}

	public void SetPlaybackSpeed(float speed)
	{
		speed = Mathf.Max(0f, speed);
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.SetPlaybackSpeed(speed);
		}
		else
		{
			videoPlayer.playbackSpeed = speed;
		}
	}

	public void Stop()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Stop();
		}
		else
		{
			videoPlayer.Stop();
		}
		IsPlaying = false;
	}

	private void OnApplicationPause(bool appWasPaused)
	{
		UnityEngine.Debug.Log("OnApplicationPause: " + appWasPaused);
		if (appWasPaused)
		{
			videoPausedBeforeAppPause = !IsPlaying;
		}
		if (!videoPausedBeforeAppPause)
		{
			if (appWasPaused)
			{
				Pause();
			}
			else
			{
				Play();
			}
		}
	}
}
public class MoviePlayerSampleControls : MonoBehaviour
{
	private enum PlaybackState
	{
		Playing,
		Paused,
		Rewinding,
		FastForwarding
	}

	public MoviePlayerSample Player;

	public OVRInputModule InputModule;

	public OVRGazePointer GazePointer;

	public GameObject LeftHand;

	public GameObject RightHand;

	public Canvas Canvas;

	public ButtonDownListener PlayPause;

	public MediaPlayerImage PlayPauseImage;

	public Slider ProgressBar;

	public ButtonDownListener FastForward;

	public MediaPlayerImage FastForwardImage;

	public ButtonDownListener Rewind;

	public MediaPlayerImage RewindImage;

	public float TimeoutTime = 10f;

	private bool _isVisible;

	private float _lastButtonTime;

	private bool _didSeek;

	private long _seekPreviousPosition;

	private long _rewindStartPosition;

	private float _rewindStartTime;

	private PlaybackState _state;

	private void Start()
	{
		PlayPause.onButtonDown += OnPlayPauseClicked;
		FastForward.onButtonDown += OnFastForwardClicked;
		Rewind.onButtonDown += OnRewindClicked;
		ProgressBar.onValueChanged.AddListener(OnSeekBarMoved);
		PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
		FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
		RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
		SetVisible(visible: false);
	}

	private void OnPlayPauseClicked()
	{
		switch (_state)
		{
		case PlaybackState.Paused:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.FastForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.Rewind;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Playing:
			Player.Pause();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
			_state = PlaybackState.Paused;
			break;
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		}
	}

	private void OnFastForwardClicked()
	{
		switch (_state)
		{
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			Player.SetPlaybackSpeed(2f);
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Playing:
			Player.SetPlaybackSpeed(2f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition + 15000);
			break;
		}
	}

	private void OnRewindClicked()
	{
		switch (_state)
		{
		case PlaybackState.Playing:
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			Player.Pause();
			_rewindStartPosition = Player.PlaybackPosition;
			_rewindStartTime = Time.time;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.Rewinding;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition - 15000);
			break;
		}
	}

	private void OnSeekBarMoved(float value)
	{
		long num = (long)(value * (float)Player.Duration);
		if (Mathf.Abs(num - Player.PlaybackPosition) > 200f)
		{
			Seek(num);
		}
	}

	private void Seek(long pos)
	{
		_didSeek = true;
		_seekPreviousPosition = Player.PlaybackPosition;
		Player.SeekTo(pos);
	}

	private void Update()
	{
		if (OVRInput.Get(OVRInput.Button.One) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger))
		{
			_lastButtonTime = Time.time;
			if (!_isVisible)
			{
				SetVisible(visible: true);
			}
		}
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			InputModule.rayTransform = LeftHand.transform;
			GazePointer.rayTransform = LeftHand.transform;
		}
		else
		{
			InputModule.rayTransform = RightHand.transform;
			GazePointer.rayTransform = RightHand.transform;
		}
		if (OVRInput.Get(OVRInput.Button.Back) && _isVisible)
		{
			SetVisible(visible: false);
		}
		if (_state == PlaybackState.Rewinding)
		{
			ProgressBar.value = Mathf.Clamp01(((float)_rewindStartPosition - 1000f * (Time.time - _rewindStartTime)) / (float)Player.Duration);
		}
		if (_isVisible && _state == PlaybackState.Playing && Time.time - _lastButtonTime > TimeoutTime)
		{
			SetVisible(visible: false);
		}
		if (_isVisible && (!_didSeek || Mathf.Abs(_seekPreviousPosition - Player.PlaybackPosition) > 50f))
		{
			_didSeek = false;
			if (Player.Duration > 0)
			{
				ProgressBar.value = (float)((double)Player.PlaybackPosition / (double)Player.Duration);
			}
			else
			{
				ProgressBar.value = 0f;
			}
		}
	}

	private void SetVisible(bool visible)
	{
		Canvas.enabled = visible;
		_isVisible = visible;
		Player.DisplayMono = visible;
		LeftHand.SetActive(visible);
		RightHand.SetActive(visible);
		UnityEngine.Debug.Log("Controls Visible: " + visible);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(OVROverlay))]
public class OVROverlayMeshGenerator : MonoBehaviour
{
	private enum CubeFace
	{
		Right,
		Left,
		Top,
		Bottom,
		Front,
		Back,
		COUNT
	}

	private Mesh _Mesh;

	private List<Vector3> _Verts = new List<Vector3>();

	private List<Vector2> _UV = new List<Vector2>();

	private List<int> _Tris = new List<int>();

	private OVROverlay _Overlay;

	private MeshFilter _MeshFilter;

	private MeshCollider _MeshCollider;

	private Transform _CameraRoot;

	private Transform _Transform;

	private OVROverlay.OverlayShape _LastShape;

	private Vector3 _LastPosition;

	private Quaternion _LastRotation;

	private Vector3 _LastScale;

	private Rect _LastRectLeft;

	private Rect _LastRectRight;

	private bool _Awake;

	private static readonly Vector3[] BottomLeft = new Vector3[6]
	{
		new Vector3(-0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, 0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, -0.5f, -0.5f),
		new Vector3(-0.5f, -0.5f, 0.5f)
	};

	private static readonly Vector3[] RightVector = new Vector3[6]
	{
		Vector3.forward,
		Vector3.back,
		Vector3.left,
		Vector3.left,
		Vector3.left,
		Vector3.right
	};

	private static readonly Vector3[] UpVector = new Vector3[6]
	{
		Vector3.up,
		Vector3.up,
		Vector3.forward,
		Vector3.back,
		Vector3.up,
		Vector3.up
	};

	protected void Awake()
	{
		_Overlay = GetComponent<OVROverlay>();
		_MeshFilter = GetComponent<MeshFilter>();
		_MeshCollider = GetComponent<MeshCollider>();
		_Transform = base.transform;
		if ((bool)Camera.main && (bool)Camera.main.transform.parent)
		{
			_CameraRoot = Camera.main.transform.parent;
		}
		_Awake = true;
	}

	private Rect GetBoundingRect(Rect a, Rect b)
	{
		float num = Mathf.Min(a.x, b.x);
		float num2 = Mathf.Max(a.x + a.width, b.x + b.width);
		float num3 = Mathf.Min(a.y, b.y);
		float num4 = Mathf.Max(a.y + a.height, b.y + b.height);
		return new Rect(num, num3, num2 - num, num4 - num3);
	}

	private void Update()
	{
		if (!_Awake)
		{
			Awake();
		}
		if ((bool)_Overlay)
		{
			OVROverlay.OverlayShape currentOverlayShape = _Overlay.currentOverlayShape;
			Vector3 vector = (_CameraRoot ? (_Transform.position - _CameraRoot.position) : _Transform.position);
			Quaternion rotation = _Transform.rotation;
			Vector3 lossyScale = _Transform.lossyScale;
			Rect rect = (_Overlay.overrideTextureRectMatrix ? _Overlay.destRectLeft : new Rect(0f, 0f, 1f, 1f));
			Rect rect2 = (_Overlay.overrideTextureRectMatrix ? _Overlay.destRectRight : new Rect(0f, 0f, 1f, 1f));
			if (_Mesh == null || _LastShape != currentOverlayShape || _LastPosition != vector || _LastRotation != rotation || _LastScale != lossyScale || _LastRectLeft != rect || _LastRectRight != rect2)
			{
				UpdateMesh(currentOverlayShape, vector, rotation, lossyScale, GetBoundingRect(rect, rect2));
				_LastShape = currentOverlayShape;
				_LastPosition = vector;
				_LastRotation = rotation;
				_LastScale = lossyScale;
				_LastRectLeft = rect;
				_LastRectRight = rect2;
			}
		}
	}

	private void UpdateMesh(OVROverlay.OverlayShape shape, Vector3 position, Quaternion rotation, Vector3 scale, Rect rect)
	{
		if ((bool)_MeshFilter)
		{
			if (_Mesh == null)
			{
				_Mesh = new Mesh
				{
					name = "Overlay"
				};
				_Mesh.hideFlags = HideFlags.DontSaveInEditor | HideFlags.DontSaveInBuild;
			}
			_Mesh.Clear();
			_Verts.Clear();
			_UV.Clear();
			_Tris.Clear();
			GenerateMesh(_Verts, _UV, _Tris, shape, position, rotation, scale, rect);
			_Mesh.SetVertices(_Verts);
			_Mesh.SetUVs(0, _UV);
			_Mesh.SetTriangles(_Tris, 0);
			_Mesh.UploadMeshData(markNoLongerReadable: false);
			_MeshFilter.sharedMesh = _Mesh;
			if ((bool)_MeshCollider)
			{
				_MeshCollider.sharedMesh = _Mesh;
			}
		}
	}

	public static void GenerateMesh(List<Vector3> verts, List<Vector2> uvs, List<int> tris, OVROverlay.OverlayShape shape, Vector3 position, Quaternion rotation, Vector3 scale, Rect rect)
	{
		switch (shape)
		{
		case OVROverlay.OverlayShape.Equirect:
			BuildSphere(verts, uvs, tris, position, rotation, scale, rect);
			break;
		case OVROverlay.OverlayShape.Cubemap:
		case OVROverlay.OverlayShape.OffcenterCubemap:
			BuildCube(verts, uvs, tris, position, rotation, scale);
			break;
		case OVROverlay.OverlayShape.Quad:
			BuildQuad(verts, uvs, tris, rect);
			break;
		case OVROverlay.OverlayShape.Cylinder:
			BuildHemicylinder(verts, uvs, tris, scale, rect);
			break;
		case (OVROverlay.OverlayShape)3:
			break;
		}
	}

	private static Vector2 GetSphereUV(float theta, float phi, float expand_coef)
	{
		float x = (theta / ((float)Math.PI * 2f) - 0.5f) / expand_coef + 0.5f;
		float y = phi / (float)Math.PI / expand_coef + 0.5f;
		return new Vector2(x, y);
	}

	private static Vector3 GetSphereVert(float theta, float phi)
	{
		return new Vector3((0f - Mathf.Sin(theta)) * Mathf.Cos(phi), Mathf.Sin(phi), (0f - Mathf.Cos(theta)) * Mathf.Cos(phi));
	}

	public static void BuildSphere(List<Vector3> verts, List<Vector2> uv, List<int> triangles, Vector3 position, Quaternion rotation, Vector3 scale, Rect rect, float worldScale = 800f, int latitudes = 128, int longitudes = 128, float expand_coef = 1f)
	{
		position = Quaternion.Inverse(rotation) * position;
		latitudes = Mathf.CeilToInt((float)latitudes * rect.height);
		longitudes = Mathf.CeilToInt((float)longitudes * rect.width);
		float num = (float)Math.PI * 2f * rect.x;
		float num2 = (float)Math.PI * (0.5f - rect.y - rect.height);
		float num3 = (float)Math.PI * 2f * rect.width / (float)longitudes;
		float num4 = (float)Math.PI * rect.height / (float)latitudes;
		for (int i = 0; i < latitudes + 1; i++)
		{
			for (int j = 0; j < longitudes + 1; j++)
			{
				float theta = num + (float)j * num3;
				float phi = num2 + (float)i * num4;
				Vector2 sphereUV = GetSphereUV(theta, phi, expand_coef);
				uv.Add(new Vector2((sphereUV.x - rect.x) / rect.width, (sphereUV.y - rect.y) / rect.height));
				Vector3 sphereVert = GetSphereVert(theta, phi);
				sphereVert.x = (worldScale * sphereVert.x - position.x) / scale.x;
				sphereVert.y = (worldScale * sphereVert.y - position.y) / scale.y;
				sphereVert.z = (worldScale * sphereVert.z - position.z) / scale.z;
				verts.Add(sphereVert);
			}
		}
		for (int k = 0; k < latitudes; k++)
		{
			for (int l = 0; l < longitudes; l++)
			{
				triangles.Add(k * (longitudes + 1) + l);
				triangles.Add((k + 1) * (longitudes + 1) + l);
				triangles.Add((k + 1) * (longitudes + 1) + l + 1);
				triangles.Add((k + 1) * (longitudes + 1) + l + 1);
				triangles.Add(k * (longitudes + 1) + l + 1);
				triangles.Add(k * (longitudes + 1) + l);
			}
		}
	}

	private static Vector2 GetCubeUV(CubeFace face, Vector2 sideUV, float expand_coef)
	{
		sideUV = (sideUV - 0.5f * Vector2.one) / expand_coef + 0.5f * Vector2.one;
		return face switch
		{
			CubeFace.Bottom => new Vector2(sideUV.x / 3f, sideUV.y / 2f), 
			CubeFace.Front => new Vector2((1f + sideUV.x) / 3f, sideUV.y / 2f), 
			CubeFace.Back => new Vector2((2f + sideUV.x) / 3f, sideUV.y / 2f), 
			CubeFace.Right => new Vector2(sideUV.x / 3f, (1f + sideUV.y) / 2f), 
			CubeFace.Left => new Vector2((1f + sideUV.x) / 3f, (1f + sideUV.y) / 2f), 
			CubeFace.Top => new Vector2((2f + sideUV.x) / 3f, (1f + sideUV.y) / 2f), 
			_ => Vector2.zero, 
		};
	}

	private static Vector3 GetCubeVert(CubeFace face, Vector2 sideUV, float expand_coef)
	{
		return BottomLeft[(int)face] + sideUV.x * RightVector[(int)face] + sideUV.y * UpVector[(int)face];
	}

	public static void BuildCube(List<Vector3> verts, List<Vector2> uv, List<int> triangles, Vector3 position, Quaternion rotation, Vector3 scale, float worldScale = 800f, int subQuads = 1, float expand_coef = 1.01f)
	{
		position = Quaternion.Inverse(rotation) * position;
		int num = (subQuads + 1) * (subQuads + 1);
		for (int i = 0; i < 6; i++)
		{
			for (int j = 0; j < subQuads + 1; j++)
			{
				for (int k = 0; k < subQuads + 1; k++)
				{
					float x = (float)j / (float)subQuads;
					float y = (float)k / (float)subQuads;
					uv.Add(GetCubeUV((CubeFace)i, new Vector2(x, y), expand_coef));
					Vector3 cubeVert = GetCubeVert((CubeFace)i, new Vector2(x, y), expand_coef);
					cubeVert.x = (worldScale * cubeVert.x - position.x) / scale.x;
					cubeVert.y = (worldScale * cubeVert.y - position.y) / scale.y;
					cubeVert.z = (worldScale * cubeVert.z - position.z) / scale.z;
					verts.Add(cubeVert);
				}
			}
			for (int l = 0; l < subQuads; l++)
			{
				for (int m = 0; m < subQuads; m++)
				{
					triangles.Add(num * i + (l + 1) * (subQuads + 1) + m);
					triangles.Add(num * i + l * (subQuads + 1) + m);
					triangles.Add(num * i + (l + 1) * (subQuads + 1) + m + 1);
					triangles.Add(num * i + (l + 1) * (subQuads + 1) + m + 1);
					triangles.Add(num * i + l * (subQuads + 1) + m);
					triangles.Add(num * i + l * (subQuads + 1) + m + 1);
				}
			}
		}
	}

	public static void BuildQuad(List<Vector3> verts, List<Vector2> uv, List<int> triangles, Rect rect)
	{
		verts.Add(new Vector3(rect.x - 0.5f, 1f - rect.y - rect.height - 0.5f, 0f));
		verts.Add(new Vector3(rect.x - 0.5f, 1f - rect.y - 0.5f, 0f));
		verts.Add(new Vector3(rect.x + rect.width - 0.5f, 1f - rect.y - 0.5f, 0f));
		verts.Add(new Vector3(rect.x + rect.width - 0.5f, 1f - rect.y - rect.height - 0.5f, 0f));
		uv.Add(new Vector2(0f, 0f));
		uv.Add(new Vector2(0f, 1f));
		uv.Add(new Vector2(1f, 1f));
		uv.Add(new Vector2(1f, 0f));
		triangles.Add(0);
		triangles.Add(1);
		triangles.Add(2);
		triangles.Add(2);
		triangles.Add(3);
		triangles.Add(0);
	}

	public static void BuildHemicylinder(List<Vector3> verts, List<Vector2> uv, List<int> triangles, Vector3 scale, Rect rect, int longitudes = 128)
	{
		float num = Mathf.Abs(scale.y) * rect.height;
		float z = scale.z;
		float num2 = scale.x * rect.width;
		float num3 = num2 / z;
		float num4 = scale.x * (-0.5f + rect.x) / z;
		int num5 = Mathf.CeilToInt((float)longitudes * num3 / ((float)Math.PI * 2f));
		float num6 = num2 / (float)num5;
		int num7 = Mathf.CeilToInt(num / num6 / 2f);
		for (int i = 0; i < num7 + 1; i++)
		{
			for (int j = 0; j < num5 + 1; j++)
			{
				uv.Add(new Vector2((float)j / (float)num5, 1f - (float)i / (float)num7));
				Vector3 zero = Vector3.zero;
				zero.x = Mathf.Sin(num4 + (float)j * num3 / (float)num5) * z / scale.x;
				zero.y = 0.5f - rect.y - rect.height + rect.height * (1f - (float)i / (float)num7);
				zero.z = Mathf.Cos(num4 + (float)j * num3 / (float)num5) * z / scale.z;
				verts.Add(zero);
			}
		}
		for (int k = 0; k < num7; k++)
		{
			for (int l = 0; l < num5; l++)
			{
				triangles.Add(k * (num5 + 1) + l);
				triangles.Add((k + 1) * (num5 + 1) + l + 1);
				triangles.Add((k + 1) * (num5 + 1) + l);
				triangles.Add((k + 1) * (num5 + 1) + l + 1);
				triangles.Add(k * (num5 + 1) + l);
				triangles.Add(k * (num5 + 1) + l + 1);
			}
		}
	}
}
public static class VectorUtil
{
	public static Vector4 ToVector(this Rect rect)
	{
		return new Vector4(rect.x, rect.y, rect.width, rect.height);
	}
}
public class DebugUISample : MonoBehaviour
{
	private bool inMenu;

	private Text sliderText;

	private void Start()
	{
		DebugUIBuilder.instance.AddButton("Button Pressed", LogButtonPressed);
		DebugUIBuilder.instance.AddLabel("Label");
		RectTransform rectTransform = DebugUIBuilder.instance.AddSlider("Slider", 1f, 10f, SliderPressed, wholeNumbersOnly: true);
		Text[] componentsInChildren = rectTransform.GetComponentsInChildren<Text>();
		sliderText = componentsInChildren[1];
		sliderText.text = rectTransform.GetComponentInChildren<Slider>().value.ToString();
		DebugUIBuilder.instance.AddDivider();
		DebugUIBuilder.instance.AddToggle("Toggle", TogglePressed);
		DebugUIBuilder.instance.AddRadio("Radio1", "group", delegate(Toggle t)
		{
			RadioPressed("Radio1", "group", t);
		});
		DebugUIBuilder.instance.AddRadio("Radio2", "group", delegate(Toggle t)
		{
			RadioPressed("Radio2", "group", t);
		});
		DebugUIBuilder.instance.AddLabel("Secondary Tab", 1);
		DebugUIBuilder.instance.AddDivider(1);
		DebugUIBuilder.instance.AddRadio("Side Radio 1", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 1", "group2", t);
		}, 1);
		DebugUIBuilder.instance.AddRadio("Side Radio 2", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 2", "group2", t);
		}, 1);
		DebugUIBuilder.instance.Show();
		inMenu = true;
	}

	public void TogglePressed(Toggle t)
	{
		UnityEngine.Debug.Log("Toggle pressed. Is on? " + t.isOn);
	}

	public void RadioPressed(string radioLabel, string group, Toggle t)
	{
		UnityEngine.Debug.Log("Radio value changed: " + radioLabel + ", from group " + group + ". New value: " + t.isOn);
	}

	public void SliderPressed(float f)
	{
		UnityEngine.Debug.Log("Slider: " + f);
		sliderText.text = f.ToString();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LogButtonPressed()
	{
		UnityEngine.Debug.Log("Button pressed");
	}
}
public class HandsActiveChecker : MonoBehaviour
{
	[SerializeField]
	private GameObject _notificationPrefab;

	private GameObject _notification;

	private OVRCameraRig _cameraRig;

	private Transform _centerEye;

	private void Awake()
	{
		_notification = UnityEngine.Object.Instantiate(_notificationPrefab);
		StartCoroutine(GetCenterEye());
	}

	private void Update()
	{
		if (OVRPlugin.GetHandTrackingEnabled())
		{
			_notification.SetActive(value: false);
			return;
		}
		_notification.SetActive(value: true);
		if ((bool)_centerEye)
		{
			_notification.transform.position = _centerEye.position + _centerEye.forward * 0.5f;
			_notification.transform.rotation = _centerEye.rotation;
		}
	}

	private IEnumerator GetCenterEye()
	{
		if ((_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>()) != null)
		{
			while (!_centerEye)
			{
				_centerEye = _cameraRig.centerEyeAnchor;
				yield return null;
			}
		}
	}
}
[ExecuteInEditMode]
public class CharacterCapsule : MonoBehaviour
{
	private CharacterController _character;

	private MeshFilter _meshFilter;

	private float _height;

	private float _radius;

	[Range(4f, 32f)]
	public int SubdivisionsU;

	[Range(4f, 32f)]
	public int SubdivisionsV;

	private int _subdivisionU;

	private int _subdivisionV;

	private Vector3[] _vertices;

	private int[] _triangles;

	private void Update()
	{
		if (_character == null)
		{
			_character = GetComponentInParent<CharacterController>();
			if (_character == null)
			{
				return;
			}
		}
		if (_height == _character.height && _radius == _character.radius && _subdivisionU == SubdivisionsU && _subdivisionV == SubdivisionsV)
		{
			return;
		}
		_height = _character.height;
		_radius = _character.radius;
		_subdivisionU = SubdivisionsU;
		_subdivisionV = SubdivisionsV;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = new Vector3(1f, 0f, 0f);
		Vector3 vector2 = new Vector3(0f, _height / 2f - _radius, 0f);
		Vector3 vector3 = new Vector3(0f, _radius - _height / 2f, 0f);
		list.Add(new Vector3(0f, _height / 2f, 0f));
		for (int num = SubdivisionsU - 1; num >= 0; num--)
		{
			float num2 = (float)num / (float)SubdivisionsU;
			for (int i = 0; i < SubdivisionsV; i++)
			{
				float num3 = (float)i / (float)SubdivisionsV;
				Vector3 item = Quaternion.Euler(0f, num3 * 360f, num2 * 90f) * vector * _radius + vector2;
				list.Add(item);
			}
		}
		for (int j = 0; j < SubdivisionsU; j++)
		{
			float num4 = (float)j / (float)SubdivisionsU;
			for (int k = 0; k < SubdivisionsV; k++)
			{
				float num5 = (float)k / (float)SubdivisionsV;
				Vector3 vector4 = Quaternion.Euler(0f, num5 * 360f + 180f, num4 * 90f) * vector;
				vector4 *= _radius;
				Vector3 item2 = vector3 - vector4;
				list.Add(item2);
			}
		}
		list.Add(new Vector3(0f, (0f - _height) / 2f, 0f));
		List<int> list2 = new List<int>();
		int item3;
		for (int l = 0; l < SubdivisionsV; l++)
		{
			item3 = 0;
			list2.Add(item3);
			list2.Add(l);
			list2.Add(l + 1);
		}
		list2.Add(0);
		list2.Add(SubdivisionsV);
		list2.Add(1);
		int num6;
		for (int m = 0; m < SubdivisionsU - 1; m++)
		{
			num6 = m * SubdivisionsV + 1;
			for (int n = 0; n < SubdivisionsV - 1; n++)
			{
				item3 = num6 + n;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		num6 = (SubdivisionsU - 1) * SubdivisionsV + 1;
		for (int num7 = 0; num7 < SubdivisionsV - 1; num7++)
		{
			item3 = num6 + num7;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
			list2.Add(item3 + 1);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + SubdivisionsV + 1);
		}
		item3 = num6 + SubdivisionsV - 1;
		list2.Add(item3);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1);
		for (int num8 = 0; num8 < SubdivisionsU - 1; num8++)
		{
			num6 = num8 * SubdivisionsV + SubdivisionsU * SubdivisionsV + 1;
			for (int num9 = 0; num9 < SubdivisionsV - 1; num9++)
			{
				item3 = num6 + num9;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		int num10 = list.Count - 1;
		int num11 = num10 - SubdivisionsV;
		for (int num12 = 0; num12 < SubdivisionsV; num12++)
		{
			item3 = 0;
			list2.Add(num10);
			list2.Add(num11 + num12 + 1);
			list2.Add(num11 + num12);
		}
		list2.Add(num10);
		list2.Add(num11);
		list2.Add(num10 - 1);
		_vertices = list.ToArray();
		_triangles = list2.ToArray();
		_meshFilter = base.gameObject.GetComponent<MeshFilter>();
		_meshFilter.mesh = new Mesh();
		_meshFilter.sharedMesh.vertices = _vertices;
		_meshFilter.sharedMesh.triangles = _triangles;
		_meshFilter.sharedMesh.RecalculateNormals();
	}
}
public class LocomotionSampleSupport : MonoBehaviour
{
	private LocomotionController lc;

	private bool inMenu;

	private LocomotionTeleport TeleportController => lc.GetComponent<LocomotionTeleport>();

	public void Start()
	{
		lc = UnityEngine.Object.FindObjectOfType<LocomotionController>();
		DebugUIBuilder.instance.AddButton("Node Teleport w/ A", SetupNodeTeleport);
		DebugUIBuilder.instance.AddButton("Dual-stick teleport", SetupTwoStickTeleport);
		DebugUIBuilder.instance.AddButton("L Strafe R Teleport", SetupLeftStrafeRightTeleport);
		DebugUIBuilder.instance.AddButton("Walk Only", SetupWalkOnly);
		if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
		{
			UnityEngine.Debug.LogError("Need EventSystem");
		}
		SetupTwoStickTeleport();
		Physics.IgnoreLayerCollision(0, 4);
	}

	public void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	[Conditional("DEBUG_LOCOMOTION_PANEL")]
	private static void Log(string msg)
	{
		UnityEngine.Debug.Log(msg);
	}

	public static TActivate ActivateCategory<TCategory, TActivate>(GameObject target) where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		TCategory[] components = target.GetComponents<TCategory>();
		Log(string.Concat("Activate ", typeof(TActivate), " derived from ", typeof(TCategory), "[", components.Length, "]"));
		TActivate result = null;
		foreach (MonoBehaviour monoBehaviour in components)
		{
			bool flag = monoBehaviour.GetType() == typeof(TActivate);
			Log(string.Concat(monoBehaviour.GetType(), " is ", typeof(TActivate), " = ", flag.ToString()));
			if (flag)
			{
				result = (TActivate)monoBehaviour;
			}
			if (monoBehaviour.enabled != flag)
			{
				monoBehaviour.enabled = flag;
			}
		}
		return result;
	}

	protected void ActivateHandlers<TInput, TAim, TTarget, TOrientation, TTransition>() where TInput : TeleportInputHandler where TAim : TeleportAimHandler where TTarget : TeleportTargetHandler where TOrientation : TeleportOrientationHandler where TTransition : TeleportTransition
	{
		ActivateInput<TInput>();
		ActivateAim<TAim>();
		ActivateTarget<TTarget>();
		ActivateOrientation<TOrientation>();
		ActivateTransition<TTransition>();
	}

	protected void ActivateInput<TActivate>() where TActivate : TeleportInputHandler
	{
		ActivateCategory<TeleportInputHandler, TActivate>();
	}

	protected void ActivateAim<TActivate>() where TActivate : TeleportAimHandler
	{
		ActivateCategory<TeleportAimHandler, TActivate>();
	}

	protected void ActivateTarget<TActivate>() where TActivate : TeleportTargetHandler
	{
		ActivateCategory<TeleportTargetHandler, TActivate>();
	}

	protected void ActivateOrientation<TActivate>() where TActivate : TeleportOrientationHandler
	{
		ActivateCategory<TeleportOrientationHandler, TActivate>();
	}

	protected void ActivateTransition<TActivate>() where TActivate : TeleportTransition
	{
		ActivateCategory<TeleportTransition, TActivate>();
	}

	protected TActivate ActivateCategory<TCategory, TActivate>() where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		return ActivateCategory<TCategory, TActivate>(lc.gameObject);
	}

	protected void UpdateToggle(Toggle toggle, bool enabled)
	{
		if (enabled != toggle.isOn)
		{
			toggle.isOn = enabled;
		}
	}

	private void SetupNonCap()
	{
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.SeparateButtonsForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
	}

	private void SetupTeleportDefaults()
	{
		TeleportController.enabled = true;
		lc.PlayerController.RotationEitherThumbstick = false;
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		TeleportController.EnableRotation(ready: false, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.CapacitiveButtonForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
		component.CapacitiveAimAndTeleportButton = TeleportInputHandlerTouch.AimCapTouchButtons.A;
		component.FastTeleport = false;
		TeleportInputHandlerHMD component2 = TeleportController.GetComponent<TeleportInputHandlerHMD>();
		component2.AimButton = OVRInput.RawButton.A;
		component2.TeleportButton = OVRInput.RawButton.A;
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.LTouch;
	}

	protected GameObject AddInstance(GameObject template, string label)
	{
		GameObject obj = UnityEngine.Object.Instantiate(template);
		obj.transform.SetParent(base.transform, worldPositionStays: false);
		obj.name = label;
		return obj;
	}

	private void SetupNodeTeleport()
	{
		SetupTeleportDefaults();
		SetupNonCap();
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerLaser, TeleportTargetHandlerNode, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportInputHandlerTouch>().AimingController = OVRInput.Controller.RTouch;
	}

	private void SetupTwoStickTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.Touch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.Touch;
	}

	private void SetupWalkOnly()
	{
		SetupTeleportDefaults();
		TeleportController.enabled = false;
		lc.PlayerController.EnableLinearMovement = true;
		lc.PlayerController.RotationEitherThumbstick = false;
	}

	private void SetupLeftStrafeRightTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: true, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.RTouch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.RTouch;
	}
}
[RequireComponent(typeof(Canvas))]
public class OVROverlayCanvas : MonoBehaviour
{
	public enum DrawMode
	{
		Opaque,
		OpaqueWithClip,
		TransparentDefaultAlpha,
		TransparentCorrectAlpha
	}

	[SerializeField]
	[HideInInspector]
	private Shader _transparentShader;

	[SerializeField]
	[HideInInspector]
	private Shader _opaqueShader;

	private RectTransform _rectTransform;

	private Canvas _canvas;

	private Camera _camera;

	private OVROverlay _overlay;

	private RenderTexture _renderTexture;

	private MeshRenderer _meshRenderer;

	private Mesh _quad;

	private Material _defaultMat;

	public int MaxTextureSize = 1600;

	public int MinTextureSize = 200;

	public float PixelsPerUnit = 1f;

	public int DrawRate = 1;

	public int DrawFrameOffset;

	public bool Expensive;

	public int Layer;

	public DrawMode Opacity = DrawMode.OpaqueWithClip;

	private bool ScaleViewport = UnityEngine.Application.isMobilePlatform;

	private static readonly Plane[] _FrustumPlanes = new Plane[6];

	public bool overlayEnabled
	{
		get
		{
			if ((bool)_overlay)
			{
				return _overlay.enabled;
			}
			return false;
		}
		set
		{
			if ((bool)_overlay)
			{
				_overlay.enabled = value;
				_defaultMat.color = (value ? Color.black : Color.white);
			}
		}
	}

	private void Start()
	{
		_canvas = GetComponent<Canvas>();
		_rectTransform = _canvas.GetComponent<RectTransform>();
		float width = _rectTransform.rect.width;
		float height = _rectTransform.rect.height;
		float num = ((width >= height) ? 1f : (width / height));
		float num2 = ((height >= width) ? 1f : (height / width));
		int num3 = ((!ScaleViewport) ? 8 : 0);
		int num4 = Mathf.CeilToInt(num * (float)(MaxTextureSize - num3 * 2));
		int num5 = Mathf.CeilToInt(num2 * (float)(MaxTextureSize - num3 * 2));
		int num6 = num4 + num3 * 2;
		int num7 = num5 + num3 * 2;
		float x = width * ((float)num6 / (float)num4);
		float num8 = height * ((float)num7 / (float)num5);
		float num9 = (float)num4 / (float)num6;
		float num10 = (float)num5 / (float)num7;
		Vector2 vector = ((Opacity == DrawMode.Opaque) ? new Vector2(0.005f / _rectTransform.lossyScale.x, 0.005f / _rectTransform.lossyScale.y) : Vector2.zero);
		_renderTexture = new RenderTexture(num6, num7, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
		_renderTexture.useMipMap = !ScaleViewport;
		GameObject gameObject = new GameObject(base.name + " Overlay Camera")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		_camera = gameObject.AddComponent<Camera>();
		_camera.stereoTargetEye = StereoTargetEyeMask.None;
		_camera.transform.position = base.transform.position - base.transform.forward;
		_camera.orthographic = true;
		_camera.enabled = false;
		_camera.targetTexture = _renderTexture;
		_camera.cullingMask = 1 << base.gameObject.layer;
		_camera.clearFlags = CameraClearFlags.Color;
		_camera.backgroundColor = Color.clear;
		_camera.orthographicSize = 0.5f * num8 * _rectTransform.localScale.y;
		_camera.nearClipPlane = 0.99f;
		_camera.farClipPlane = 1.01f;
		_quad = new Mesh
		{
			name = base.name + " Overlay Quad",
			hideFlags = HideFlags.HideAndDontSave
		};
		_quad.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f),
			new Vector3(0.5f, 0.5f),
			new Vector3(0.5f, -0.5f)
		};
		_quad.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		_quad.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		_quad.bounds = new Bounds(Vector3.zero, Vector3.one);
		_quad.UploadMeshData(markNoLongerReadable: true);
		switch (Opacity)
		{
		case DrawMode.Opaque:
			_defaultMat = new Material(_opaqueShader);
			break;
		case DrawMode.OpaqueWithClip:
			_defaultMat = new Material(_opaqueShader);
			_defaultMat.EnableKeyword("WITH_CLIP");
			break;
		case DrawMode.TransparentDefaultAlpha:
			_defaultMat = new Material(_transparentShader);
			_defaultMat.EnableKeyword("ALPHA_SQUARED");
			break;
		case DrawMode.TransparentCorrectAlpha:
			_defaultMat = new Material(_transparentShader);
			break;
		}
		_defaultMat.mainTexture = _renderTexture;
		_defaultMat.color = Color.black;
		_defaultMat.mainTextureOffset = new Vector2(0.5f - 0.5f * num9, 0.5f - 0.5f * num10);
		_defaultMat.mainTextureScale = new Vector2(num9, num10);
		GameObject gameObject2 = new GameObject(base.name + " MeshRenderer")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject2.AddComponent<MeshFilter>().sharedMesh = _quad;
		_meshRenderer = gameObject2.AddComponent<MeshRenderer>();
		_meshRenderer.sharedMaterial = _defaultMat;
		gameObject2.layer = Layer;
		gameObject2.transform.localScale = new Vector3(width - vector.x, height - vector.y, 1f);
		GameObject gameObject3 = new GameObject(base.name + " Overlay")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
		_overlay = gameObject3.AddComponent<OVROverlay>();
		_overlay.isDynamic = true;
		_overlay.noDepthBufferTesting = true;
		_overlay.isAlphaPremultiplied = !UnityEngine.Application.isMobilePlatform;
		_overlay.textures[0] = _renderTexture;
		_overlay.currentOverlayType = OVROverlay.OverlayType.Underlay;
		_overlay.transform.localScale = new Vector3(x, num8, 1f);
		_overlay.useExpensiveSuperSample = Expensive;
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(_defaultMat);
		UnityEngine.Object.Destroy(_quad);
		UnityEngine.Object.Destroy(_renderTexture);
	}

	private void OnEnable()
	{
		if ((bool)_overlay)
		{
			_meshRenderer.enabled = true;
			_overlay.enabled = true;
		}
		if ((bool)_camera)
		{
			_camera.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)_overlay)
		{
			_overlay.enabled = false;
			_meshRenderer.enabled = false;
		}
		if ((bool)_camera)
		{
			_camera.enabled = false;
		}
	}

	protected virtual bool ShouldRender()
	{
		if (DrawRate > 1 && Time.frameCount % DrawRate != DrawFrameOffset % DrawRate)
		{
			return false;
		}
		if (Camera.main != null)
		{
			for (int i = 0; i < 2; i++)
			{
				Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
				GeometryUtility.CalculateFrustumPlanes(Camera.main.GetStereoProjectionMatrix(eye) * Camera.main.GetStereoViewMatrix(eye), _FrustumPlanes);
				if (GeometryUtility.TestPlanesAABB(_FrustumPlanes, _meshRenderer.bounds))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (ShouldRender())
		{
			if (ScaleViewport && Camera.main != null)
			{
				float magnitude = (Camera.main.transform.position - base.transform.position).magnitude;
				float value = Mathf.Ceil(PixelsPerUnit * Mathf.Max(_rectTransform.rect.width * base.transform.lossyScale.x, _rectTransform.rect.height * base.transform.lossyScale.y) / magnitude / 8f * (float)_renderTexture.height) * 8f;
				value = Mathf.Clamp(value, MinTextureSize, _renderTexture.height);
				float num = value - 2f;
				_camera.orthographicSize = 0.5f * _rectTransform.rect.height * _rectTransform.localScale.y * value / num;
				float num2 = _rectTransform.rect.width / _rectTransform.rect.height;
				float num3 = num * num2;
				float num4 = Mathf.Ceil((num3 + 2f) * 0.5f) * 2f / (float)_renderTexture.width;
				float num5 = value / (float)_renderTexture.height;
				float num6 = ((Opacity == DrawMode.Opaque) ? 1.001f : 0f);
				float num7 = (num3 - num6) / (float)_renderTexture.width;
				float num8 = (num - num6) / (float)_renderTexture.height;
				_camera.rect = new Rect((1f - num4) / 2f, (1f - num5) / 2f, num4, num5);
				Rect rect = new Rect(0.5f - 0.5f * num7, 0.5f - 0.5f * num8, num7, num8);
				_defaultMat.mainTextureOffset = rect.min;
				_defaultMat.mainTextureScale = rect.size;
				_overlay.overrideTextureRectMatrix = true;
				rect.y = 1f - rect.height - rect.y;
				Rect rect2 = new Rect(0f, 0f, 1f, 1f);
				_overlay.SetSrcDestRects(rect, rect, rect2, rect2);
			}
			_camera.Render();
		}
	}
}
public class StartMenu : MonoBehaviour
{
	public OVROverlay overlay;

	public OVROverlay text;

	public OVRCameraRig vrRig;

	private void Start()
	{
		DebugUIBuilder.instance.AddLabel("Select Sample Scene");
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			string scenePathByBuildIndex = SceneUtility.GetScenePathByBuildIndex(i);
			int sceneIndex = i;
			DebugUIBuilder.instance.AddButton(Path.GetFileNameWithoutExtension(scenePathByBuildIndex), delegate
			{
				LoadScene(sceneIndex);
			});
		}
		DebugUIBuilder.instance.Show();
	}

	private void LoadScene(int idx)
	{
		DebugUIBuilder.instance.Hide();
		UnityEngine.Debug.Log("Load scene: " + idx);
		SceneManager.LoadScene(idx);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			int num = (heightmapResolution - 1) / terrainDecimation + 1;
			int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapResolution3 = terrainData2.heightmapResolution;
			int heightmapResolution4 = terrainData2.heightmapResolution;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
			int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
			int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public static class AppSettingsExtensions
{
	public static ChatAppSettings GetChatSettings(this AppSettings appSettings)
	{
		return new ChatAppSettings
		{
			AppId = appSettings.AppIdChat,
			AppVersion = appSettings.AppVersion,
			FixedRegion = (appSettings.IsBestRegion ? null : appSettings.FixedRegion),
			NetworkLogging = appSettings.NetworkLogging,
			Protocol = appSettings.Protocol,
			Server = (appSettings.IsDefaultNameServer ? null : appSettings.Server)
		};
	}
}
public class ChannelSelector : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public string Channel;

	public void SetChannel(string channel)
	{
		Channel = channel;
		GetComponentInChildren<Text>().text = Channel;
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		UnityEngine.Object.FindObjectOfType<ChatGui>().ShowChannel(Channel);
	}
}
[ExecuteInEditMode]
public class ChatAppIdCheckerUI : MonoBehaviour
{
	public Text Description;

	public void Update()
	{
		if (string.IsNullOrEmpty(PhotonNetwork.PhotonServerSettings.AppSettings.AppIdChat))
		{
			if (Description != null)
			{
				Description.text = "<Color=Red>WARNING:</Color>\nPlease setup a Chat AppId in the PhotonServerSettings file.";
			}
		}
		else if (Description != null)
		{
			Description.text = string.Empty;
		}
	}
}
public class ChatGui : MonoBehaviour, IChatClientListener
{
	public string[] ChannelsToJoinOnConnect;

	public string[] FriendsList;

	public int HistoryLengthToFetch;

	private string selectedChannelName;

	public ChatClient chatClient;

	protected internal ChatAppSettings chatAppSettings;

	public GameObject missingAppIdErrorPanel;

	public GameObject ConnectingLabel;

	public RectTransform ChatPanel;

	public GameObject UserIdFormPanel;

	public InputField InputFieldChat;

	public Text CurrentChannelText;

	public Toggle ChannelToggleToInstantiate;

	public GameObject FriendListUiItemtoInstantiate;

	private readonly Dictionary<string, Toggle> channelToggles = new Dictionary<string, Toggle>();

	private readonly Dictionary<string, FriendItem> friendListItemLUT = new Dictionary<string, FriendItem>();

	public bool ShowState = true;

	public GameObject Title;

	public Text StateText;

	public Text UserIdText;

	private static string HelpText = "\n    -- HELP --\nTo subscribe to channel(s) (channelnames are case sensitive) :  \n\t<color=#E07B00>\\subscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\s</color> <color=green><list of channelnames></color>\n\nTo leave channel(s):\n\t<color=#E07B00>\\unsubscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\u</color> <color=green><list of channelnames></color>\n\nTo switch the active channel\n\t<color=#E07B00>\\join</color> <color=green><channelname></color>\n\tor\n\t<color=#E07B00>\\j</color> <color=green><channelname></color>\n\nTo send a private message: (username are case sensitive)\n\t\\<color=#E07B00>msg</color> <color=green><username></color> <color=green><message></color>\n\nTo change status:\n\t\\<color=#E07B00>state</color> <color=green><stateIndex></color> <color=green><message></color>\n<color=green>0</color> = Offline <color=green>1</color> = Invisible <color=green>2</color> = Online <color=green>3</color> = Away \n<color=green>4</color> = Do not disturb <color=green>5</color> = Looking For Group <color=green>6</color> = Playing\n\nTo clear the current chat tab (private chats get closed):\n\t<color=#E07B00>\\clear</color>";

	public int TestLength = 2048;

	private byte[] testBytes = new byte[2048];

	public string UserName { get; set; }

	public void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		UserIdText.text = "";
		StateText.text = "";
		StateText.gameObject.SetActive(value: true);
		UserIdText.gameObject.SetActive(value: true);
		Title.SetActive(value: true);
		ChatPanel.gameObject.SetActive(value: false);
		ConnectingLabel.SetActive(value: false);
		if (string.IsNullOrEmpty(UserName))
		{
			UserName = "user" + Environment.TickCount % 99;
		}
		chatAppSettings = PhotonNetwork.PhotonServerSettings.AppSettings.GetChatSettings();
		bool flag = !string.IsNullOrEmpty(chatAppSettings.AppId);
		missingAppIdErrorPanel.SetActive(!flag);
		UserIdFormPanel.gameObject.SetActive(flag);
		if (!flag)
		{
			UnityEngine.Debug.LogError("You need to set the chat app ID in the PhotonServerSettings file in order to continue.");
		}
	}

	public void Connect()
	{
		UserIdFormPanel.gameObject.SetActive(value: false);
		chatClient = new ChatClient(this);
		chatClient.UseBackgroundWorkerForSending = true;
		chatClient.AuthValues = new Photon.Chat.AuthenticationValues(UserName);
		chatClient.ConnectUsingSettings(chatAppSettings);
		ChannelToggleToInstantiate.gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("Connecting as: " + UserName);
		ConnectingLabel.SetActive(value: true);
	}

	public void OnDestroy()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void OnApplicationQuit()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void Update()
	{
		if (chatClient != null)
		{
			chatClient.Service();
		}
		if (StateText == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			StateText.gameObject.SetActive(ShowState);
		}
	}

	public void OnEnterSend()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	public void OnClickSend()
	{
		if (InputFieldChat != null)
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	private void SendChatMessage(string inputLine)
	{
		if (string.IsNullOrEmpty(inputLine))
		{
			return;
		}
		if ("test".Equals(inputLine))
		{
			if (TestLength != testBytes.Length)
			{
				testBytes = new byte[TestLength];
			}
			chatClient.SendPrivateMessage(chatClient.AuthValues.UserId, testBytes, forwardAsWebhook: true);
		}
		bool flag = chatClient.PrivateChannels.ContainsKey(selectedChannelName);
		string target = string.Empty;
		if (flag)
		{
			target = selectedChannelName.Split(':')[1];
		}
		if (inputLine[0].Equals('\\'))
		{
			string[] array = inputLine.Split(new char[1] { ' ' }, 2);
			if (array[0].Equals("\\help"))
			{
				PostHelpToCurrentChannel();
			}
			if (array[0].Equals("\\state"))
			{
				int num = 0;
				List<string> list = new List<string>();
				list.Add("i am state " + num);
				string[] array2 = array[1].Split(' ', ',');
				if (array2.Length != 0)
				{
					num = int.Parse(array2[0]);
				}
				if (array2.Length > 1)
				{
					list.Add(array2[1]);
				}
				chatClient.SetOnlineStatus(num, list.ToArray());
			}
			else if ((array[0].Equals("\\subscribe") || array[0].Equals("\\s")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Subscribe(array[1].Split(' ', ','));
			}
			else if ((array[0].Equals("\\unsubscribe") || array[0].Equals("\\u")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Unsubscribe(array[1].Split(' ', ','));
			}
			else if (array[0].Equals("\\clear"))
			{
				ChatChannel channel;
				if (flag)
				{
					chatClient.PrivateChannels.Remove(selectedChannelName);
				}
				else if (chatClient.TryGetChannel(selectedChannelName, flag, out channel))
				{
					channel.ClearMessages();
				}
			}
			else if (array[0].Equals("\\msg") && !string.IsNullOrEmpty(array[1]))
			{
				string[] array3 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (array3.Length >= 2)
				{
					string target2 = array3[0];
					string message = array3[1];
					chatClient.SendPrivateMessage(target2, message);
				}
			}
			else if ((array[0].Equals("\\join") || array[0].Equals("\\j")) && !string.IsNullOrEmpty(array[1]))
			{
				string[] array4 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (channelToggles.ContainsKey(array4[0]))
				{
					ShowChannel(array4[0]);
					return;
				}
				chatClient.Subscribe(new string[1] { array4[0] });
			}
			else
			{
				UnityEngine.Debug.Log("The command '" + array[0] + "' is invalid.");
			}
		}
		else if (flag)
		{
			chatClient.SendPrivateMessage(target, inputLine);
		}
		else
		{
			chatClient.PublishMessage(selectedChannelName, inputLine);
		}
	}

	public void PostHelpToCurrentChannel()
	{
		CurrentChannelText.text += HelpText;
	}

	public void DebugReturn(DebugLevel level, string message)
	{
		switch (level)
		{
		case DebugLevel.ERROR:
			UnityEngine.Debug.LogError(message);
			break;
		case DebugLevel.WARNING:
			UnityEngine.Debug.LogWarning(message);
			break;
		default:
			UnityEngine.Debug.Log(message);
			break;
		}
	}

	public void OnConnected()
	{
		if (ChannelsToJoinOnConnect != null && ChannelsToJoinOnConnect.Length != 0)
		{
			chatClient.Subscribe(ChannelsToJoinOnConnect, HistoryLengthToFetch);
		}
		ConnectingLabel.SetActive(value: false);
		UserIdText.text = "Connected as " + UserName;
		ChatPanel.gameObject.SetActive(value: true);
		if (FriendsList != null && FriendsList.Length != 0)
		{
			chatClient.AddFriends(FriendsList);
			string[] friendsList = FriendsList;
			foreach (string text in friendsList)
			{
				if (FriendListUiItemtoInstantiate != null && text != UserName)
				{
					InstantiateFriendButton(text);
				}
			}
		}
		if (FriendListUiItemtoInstantiate != null)
		{
			FriendListUiItemtoInstantiate.SetActive(value: false);
		}
		chatClient.SetOnlineStatus(2);
	}

	public void OnDisconnected()
	{
		ConnectingLabel.SetActive(value: false);
	}

	public void OnChatStateChange(ChatState state)
	{
		StateText.text = state.ToString();
	}

	public void OnSubscribed(string[] channels, bool[] results)
	{
		foreach (string channelName in channels)
		{
			chatClient.PublishMessage(channelName, "says 'hi'.");
			if (ChannelToggleToInstantiate != null)
			{
				InstantiateChannelButton(channelName);
			}
		}
		UnityEngine.Debug.Log("OnSubscribed: " + string.Join(", ", channels));
		ShowChannel(channels[0]);
	}

	private void InstantiateChannelButton(string channelName)
	{
		if (channelToggles.ContainsKey(channelName))
		{
			UnityEngine.Debug.Log("Skipping creation for an existing channel toggle.");
			return;
		}
		Toggle toggle = UnityEngine.Object.Instantiate(ChannelToggleToInstantiate);
		toggle.gameObject.SetActive(value: true);
		toggle.GetComponentInChildren<ChannelSelector>().SetChannel(channelName);
		toggle.transform.SetParent(ChannelToggleToInstantiate.transform.parent, worldPositionStays: false);
		channelToggles.Add(channelName, toggle);
	}

	private void InstantiateFriendButton(string friendId)
	{
		GameObject obj = UnityEngine.Object.Instantiate(FriendListUiItemtoInstantiate);
		obj.gameObject.SetActive(value: true);
		FriendItem component = obj.GetComponent<FriendItem>();
		component.FriendId = friendId;
		obj.transform.SetParent(FriendListUiItemtoInstantiate.transform.parent, worldPositionStays: false);
		friendListItemLUT[friendId] = component;
	}

	public void OnUnsubscribed(string[] channels)
	{
		foreach (string text in channels)
		{
			if (channelToggles.ContainsKey(text))
			{
				UnityEngine.Object.Destroy(channelToggles[text].gameObject);
				channelToggles.Remove(text);
				UnityEngine.Debug.Log("Unsubscribed from channel '" + text + "'.");
				if (text == selectedChannelName && channelToggles.Count > 0)
				{
					IEnumerator<KeyValuePair<string, Toggle>> enumerator = channelToggles.GetEnumerator();
					enumerator.MoveNext();
					ShowChannel(enumerator.Current.Key);
					enumerator.Current.Value.isOn = true;
				}
			}
			else
			{
				UnityEngine.Debug.Log("Can't unsubscribe from channel '" + text + "' because you are currently not subscribed to it.");
			}
		}
	}

	public void OnGetMessages(string channelName, string[] senders, object[] messages)
	{
		if (channelName.Equals(selectedChannelName))
		{
			ShowChannel(selectedChannelName);
		}
	}

	public void OnPrivateMessage(string sender, object message, string channelName)
	{
		InstantiateChannelButton(channelName);
		if (message is byte[] array)
		{
			UnityEngine.Debug.Log("Message with byte[].Length: " + array.Length);
		}
		if (selectedChannelName.Equals(channelName))
		{
			ShowChannel(channelName);
		}
	}

	public void OnStatusUpdate(string user, int status, bool gotMessage, object message)
	{
		UnityEngine.Debug.LogWarning("status: " + $"{user} is {status}. Msg:{message}");
		if (friendListItemLUT.ContainsKey(user))
		{
			FriendItem friendItem = friendListItemLUT[user];
			if (friendItem != null)
			{
				friendItem.OnFriendStatusUpdate(status, gotMessage, message);
			}
		}
	}

	public void OnUserSubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserSubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void OnUserUnsubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserUnsubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void AddMessageToSelectedChannel(string msg)
	{
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(selectedChannelName, out channel))
		{
			UnityEngine.Debug.Log("AddMessageToSelectedChannel failed to find channel: " + selectedChannelName);
		}
		else
		{
			channel?.Add("Bot", msg, 0);
		}
	}

	public void ShowChannel(string channelName)
	{
		if (string.IsNullOrEmpty(channelName))
		{
			return;
		}
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(channelName, out channel))
		{
			UnityEngine.Debug.Log("ShowChannel failed to find channel: " + channelName);
			return;
		}
		selectedChannelName = channelName;
		CurrentChannelText.text = channel.ToStringMessages();
		UnityEngine.Debug.Log("ShowChannel: " + selectedChannelName);
		foreach (KeyValuePair<string, Toggle> channelToggle in channelToggles)
		{
			channelToggle.Value.isOn = ((channelToggle.Key == channelName) ? true : false);
		}
	}

	public void OpenDashboard()
	{
		UnityEngine.Application.OpenURL("https://dashboard.photonengine.com");
	}
}
public class FriendItem : MonoBehaviour
{
	public Text NameLabel;

	public Text StatusLabel;

	public Text Health;

	[HideInInspector]
	public string FriendId
	{
		get
		{
			return NameLabel.text;
		}
		set
		{
			NameLabel.text = value;
		}
	}

	public void Awake()
	{
		Health.text = string.Empty;
	}

	public void OnFriendStatusUpdate(int status, bool gotMessage, object message)
	{
		StatusLabel.text = status switch
		{
			1 => "Invisible", 
			2 => "Online", 
			3 => "Away", 
			4 => "Do not disturb", 
			5 => "Looking For Game/Group", 
			6 => "Playing", 
			_ => "Offline", 
		};
		if (gotMessage)
		{
			string text = string.Empty;
			if (message != null && message is string[] array && array.Length >= 2)
			{
				text = array[1] + "%";
			}
			Health.text = text;
		}
	}
}
public class IgnoreUiRaycastWhenInactive : MonoBehaviour, ICanvasRaycastFilter
{
	public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		return base.gameObject.activeInHierarchy;
	}
}
[RequireComponent(typeof(ChatGui))]
public class NamePickGui : MonoBehaviour
{
	private const string UserNamePlayerPref = "NamePickUserName";

	public ChatGui chatNewComponent;

	public InputField idInput;

	public void Start()
	{
		chatNewComponent = UnityEngine.Object.FindObjectOfType<ChatGui>();
		string @string = PlayerPrefs.GetString("NamePickUserName");
		if (!string.IsNullOrEmpty(@string))
		{
			idInput.text = @string;
		}
	}

	public void EndEditOnEnter()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			StartChat();
		}
	}

	public void StartChat()
	{
		ChatGui chatGui = UnityEngine.Object.FindObjectOfType<ChatGui>();
		chatGui.UserName = idInput.text.Trim();
		chatGui.Connect();
		base.enabled = false;
		PlayerPrefs.SetString("NamePickUserName", chatGui.UserName);
	}
}
[RequireComponent(typeof(Renderer))]
[RequireComponent(typeof(PhotonView))]
public class ChangeColor : MonoBehaviour
{
	private PhotonView photonView;

	private void Start()
	{
		photonView = GetComponent<PhotonView>();
		Color color = UnityEngine.Random.ColorHSV();
		photonView.RPC("ChangeColour", RpcTarget.All, new Vector3(color.r, color.g, color.b));
	}

	[PunRPC]
	private void ChangeColour(Vector3 randomColor)
	{
		GetComponent<Renderer>().material.SetColor("_Color", new Color(randomColor.x, randomColor.y, randomColor.z));
	}
}
[RequireComponent(typeof(PhotonView))]
public class ChangeName : MonoBehaviour
{
	private void Start()
	{
		PhotonView component = GetComponent<PhotonView>();
		base.name = $"ActorNumber {component.OwnerActorNr}";
	}
}
[RequireComponent(typeof(PhotonVoiceView))]
public class PointersController : MonoBehaviour
{
	[SerializeField]
	private GameObject pointerDown;

	[SerializeField]
	private GameObject pointerUp;

	private PhotonVoiceView photonVoiceView;

	private void Start()
	{
		photonVoiceView = GetComponent<PhotonVoiceView>();
	}

	private void Update()
	{
		SetActiveSafe(pointerDown, photonVoiceView.IsSpeaking);
		SetActiveSafe(pointerUp, photonVoiceView.IsRecording);
	}

	private void SetActiveSafe(GameObject go, bool active)
	{
		if (go != null && go.activeSelf != active)
		{
			go.SetActive(active);
		}
	}
}
[RequireComponent(typeof(Collider))]
[RequireComponent(typeof(Rigidbody))]
public class ProximityVoiceTrigger : VoiceComponent
{
	private List<byte> groupsToAdd = new List<byte>();

	private List<byte> groupsToRemove = new List<byte>();

	[SerializeField]
	private byte[] subscribedGroups;

	private PhotonVoiceView photonVoiceView;

	private PhotonView photonView;

	public byte TargetInterestGroup
	{
		get
		{
			if (photonView != null)
			{
				return (byte)photonView.OwnerActorNr;
			}
			return 0;
		}
	}

	protected override void Awake()
	{
		photonVoiceView = GetComponentInParent<PhotonVoiceView>();
		photonView = GetComponentInParent<PhotonView>();
		GetComponent<Collider>().isTrigger = true;
	}

	private void ToggleTransmission()
	{
		if (!(photonVoiceView.RecorderInUse != null))
		{
			return;
		}
		byte targetInterestGroup = TargetInterestGroup;
		if (photonVoiceView.RecorderInUse.InterestGroup != targetInterestGroup)
		{
			if (base.Logger.IsInfoEnabled)
			{
				base.Logger.LogInfo("Setting RecorderInUse's InterestGroup to {0}", targetInterestGroup);
			}
			photonVoiceView.RecorderInUse.InterestGroup = targetInterestGroup;
		}
		bool flag = subscribedGroups != null && subscribedGroups.Length != 0;
		if (photonVoiceView.RecorderInUse.TransmitEnabled != flag)
		{
			if (base.Logger.IsInfoEnabled)
			{
				base.Logger.LogInfo("Setting RecorderInUse's TransmitEnabled to {0}", flag);
			}
			photonVoiceView.RecorderInUse.TransmitEnabled = flag;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		ProximityVoiceTrigger component = other.GetComponent<ProximityVoiceTrigger>();
		if (component != null)
		{
			byte targetInterestGroup = component.TargetInterestGroup;
			if (base.Logger.IsDebugEnabled)
			{
				base.Logger.LogDebug("OnTriggerEnter {0}", targetInterestGroup);
			}
			if (targetInterestGroup != TargetInterestGroup && targetInterestGroup != 0 && !groupsToAdd.Contains(targetInterestGroup))
			{
				groupsToAdd.Add(targetInterestGroup);
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		ProximityVoiceTrigger component = other.GetComponent<ProximityVoiceTrigger>();
		if (!(component != null))
		{
			return;
		}
		byte targetInterestGroup = component.TargetInterestGroup;
		if (base.Logger.IsDebugEnabled)
		{
			base.Logger.LogDebug("OnTriggerExit {0}", targetInterestGroup);
		}
		if (targetInterestGroup != TargetInterestGroup && targetInterestGroup != 0)
		{
			if (groupsToAdd.Contains(targetInterestGroup))
			{
				groupsToAdd.Remove(targetInterestGroup);
			}
			if (!groupsToRemove.Contains(targetInterestGroup))
			{
				groupsToRemove.Add(targetInterestGroup);
			}
		}
	}

	private void Update()
	{
		if (!PhotonVoiceNetwork.Instance.Client.InRoom)
		{
			subscribedGroups = null;
			return;
		}
		if (groupsToAdd.Count > 0 || groupsToRemove.Count > 0)
		{
			byte[] array = null;
			byte[] array2 = null;
			if (groupsToAdd.Count > 0)
			{
				array = groupsToAdd.ToArray();
			}
			if (groupsToRemove.Count > 0)
			{
				array2 = groupsToRemove.ToArray();
			}
			if (base.Logger.IsInfoEnabled)
			{
				base.Logger.LogInfo("Trying to change groups, to_be_removed#:{0} to_be_added#={1}", groupsToRemove.Count, groupsToAdd.Count);
			}
			if (PhotonVoiceNetwork.Instance.Client.OpChangeGroups(array2, array))
			{
				if (subscribedGroups != null)
				{
					List<byte> list = new List<byte>();
					for (int i = 0; i < subscribedGroups.Length; i++)
					{
						list.Add(subscribedGroups[i]);
					}
					for (int j = 0; j < groupsToRemove.Count; j++)
					{
						if (list.Contains(groupsToRemove[j]))
						{
							list.Remove(groupsToRemove[j]);
						}
					}
					for (int k = 0; k < groupsToAdd.Count; k++)
					{
						if (!list.Contains(groupsToAdd[k]))
						{
							list.Add(groupsToAdd[k]);
						}
					}
					subscribedGroups = list.ToArray();
				}
				else
				{
					subscribedGroups = array;
				}
				groupsToAdd.Clear();
				groupsToRemove.Clear();
			}
			else if (base.Logger.IsErrorEnabled)
			{
				base.Logger.LogError("Error changing groups");
			}
		}
		ToggleTransmission();
	}
}
[Serializable]
public class MouseLookHelper
{
	public float XSensitivity = 2f;

	public float YSensitivity = 2f;

	public bool clampVerticalRotation = true;

	public float MinimumX = -90f;

	public float MaximumX = 90f;

	public bool smooth;

	public float smoothTime = 5f;

	private Quaternion m_CharacterTargetRot;

	private Quaternion m_CameraTargetRot;

	public void Init(Transform character, Transform camera)
	{
		m_CharacterTargetRot = character.localRotation;
		m_CameraTargetRot = camera.localRotation;
	}

	public void LookRotation(Transform character, Transform camera)
	{
		float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
		float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
		m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
		m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
		if (clampVerticalRotation)
		{
			m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
		}
		if (smooth)
		{
			character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
			camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
		}
		else
		{
			character.localRotation = m_CharacterTargetRot;
			camera.localRotation = m_CameraTargetRot;
		}
	}

	private Quaternion ClampRotationAroundXAxis(Quaternion q)
	{
		q.x /= q.w;
		q.y /= q.w;
		q.z /= q.w;
		q.w = 1f;
		float value = 114.59156f * Mathf.Atan(q.x);
		value = Mathf.Clamp(value, MinimumX, MaximumX);
		q.x = Mathf.Tan((float)Math.PI / 360f * value);
		return q;
	}
}
public class SoundsForJoinAndLeave : MonoBehaviourPunCallbacks
{
	public AudioClip JoinClip;

	public AudioClip LeaveClip;

	private AudioSource source;

	public override void OnPlayerEnteredRoom(Photon.Realtime.Player newPlayer)
	{
		if (JoinClip != null)
		{
			if (source == null)
			{
				source = UnityEngine.Object.FindObjectOfType<AudioSource>();
			}
			source.PlayOneShot(JoinClip);
		}
	}

	public override void OnPlayerLeftRoom(Photon.Realtime.Player otherPlayer)
	{
		if (LeaveClip != null)
		{
			if (source == null)
			{
				source = UnityEngine.Object.FindObjectOfType<AudioSource>();
			}
			source.PlayOneShot(LeaveClip);
		}
	}
}
public class GE_ToggleFullScreenUI : MonoBehaviour
{
	private int m_DefWidth;

	private int m_DefHeight;

	private void Start()
	{
		m_DefWidth = Screen.width;
		m_DefHeight = Screen.height;
		if (!UnityEngine.Application.isEditor)
		{
			if (UnityEngine.Application.platform == RuntimePlatform.WebGLPlayer || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer || UnityEngine.Application.platform == RuntimePlatform.OSXPlayer || UnityEngine.Application.platform == RuntimePlatform.LinuxPlayer)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}

	private void Update()
	{
	}

	public void OnButton_ToggleFullScreen()
	{
		if (UnityEngine.Application.isEditor)
		{
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			base.gameObject.GetComponent<Button>().interactable = false;
			{
				foreach (Transform item in base.transform)
				{
					item.gameObject.SetActive(value: true);
				}
				return;
			}
		}
		Screen.fullScreen = !Screen.fullScreen;
		if (!Screen.fullScreen)
		{
			Screen.SetResolution(Screen.currentResolution.width, Screen.currentResolution.height, fullscreen: true);
		}
		else
		{
			Screen.SetResolution(m_DefWidth, m_DefHeight, fullscreen: false);
		}
	}
}
public class GE_UIResponder : MonoBehaviour
{
	public string m_PackageTitle = "-";

	public string m_TargetURL = "www.unity3d.com";

	private void Start()
	{
		GameObject gameObject = GameObject.Find("Text Package Title");
		if (gameObject != null)
		{
			gameObject.GetComponent<Text>().text = m_PackageTitle;
		}
	}

	private void Update()
	{
	}

	public void OnButton_AssetName()
	{
		UnityEngine.Application.OpenURL(m_TargetURL);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoStopLoopedEffect : MonoBehaviour
{
	public float effectDuration = 2.5f;

	private float d;

	private void OnEnable()
	{
		d = effectDuration;
	}

	private void Update()
	{
		if (!(d > 0f))
		{
			return;
		}
		d -= Time.deltaTime;
		if (d <= 0f)
		{
			GetComponent<ParticleSystem>().Stop(withChildren: true);
			CFX_Demo_Translate component = base.gameObject.GetComponent<CFX_Demo_Translate>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
	}
}
public class CFX_Demo_New : MonoBehaviour
{
	public Renderer groundRenderer;

	public Collider groundCollider;

	[Space]
	[Space]
	public Image slowMoBtn;

	public Text slowMoLabel;

	public Image camRotBtn;

	public Text camRotLabel;

	public Image groundBtn;

	public Text groundLabel;

	[Space]
	public Text EffectLabel;

	public Text EffectIndexLabel;

	private GameObject[] ParticleExamples;

	private int exampleIndex;

	private bool slowMo;

	private Vector3 defaultCamPosition;

	private Quaternion defaultCamRotation;

	private List<GameObject> onScreenParticles = new List<GameObject>();

	private void Awake()
	{
		List<GameObject> list = new List<GameObject>();
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject item = base.transform.GetChild(i).gameObject;
			list.Add(item);
		}
		list.Sort((GameObject o1, GameObject o2) => o1.name.CompareTo(o2.name));
		ParticleExamples = list.ToArray();
		defaultCamPosition = Camera.main.transform.position;
		defaultCamRotation = Camera.main.transform.rotation;
		StartCoroutine("CheckForDeletedParticles");
		UpdateUI();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			prevParticle();
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextParticle();
		}
		else if (Input.GetKeyDown(KeyCode.Delete))
		{
			destroyParticles();
		}
		if (Input.GetMouseButtonDown(0))
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (groundCollider.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 9999f))
			{
				GameObject gameObject = spawnParticle();
				gameObject.transform.position = hitInfo.point + gameObject.transform.position;
			}
		}
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if (axis != 0f)
		{
			Camera.main.transform.Translate(Vector3.forward * ((axis < 0f) ? (-1f) : 1f), Space.Self);
		}
		if (Input.GetMouseButtonDown(2))
		{
			Camera.main.transform.position = defaultCamPosition;
			Camera.main.transform.rotation = defaultCamRotation;
		}
	}

	public void OnToggleGround()
	{
		Color white = Color.white;
		groundRenderer.enabled = !groundRenderer.enabled;
		white.a = (groundRenderer.enabled ? 1f : 0.33f);
		groundBtn.color = white;
		groundLabel.color = white;
	}

	public void OnToggleCamera()
	{
		Color white = Color.white;
		CFX_Demo_RotateCamera.rotating = !CFX_Demo_RotateCamera.rotating;
		white.a = (CFX_Demo_RotateCamera.rotating ? 1f : 0.33f);
		camRotBtn.color = white;
		camRotLabel.color = white;
	}

	public void OnToggleSlowMo()
	{
		Color white = Color.white;
		slowMo = !slowMo;
		if (slowMo)
		{
			Time.timeScale = 0.33f;
			white.a = 1f;
		}
		else
		{
			Time.timeScale = 1f;
			white.a = 0.33f;
		}
		slowMoBtn.color = white;
		slowMoLabel.color = white;
	}

	public void OnPreviousEffect()
	{
		prevParticle();
	}

	public void OnNextEffect()
	{
		nextParticle();
	}

	private void UpdateUI()
	{
		EffectLabel.text = ParticleExamples[exampleIndex].name;
		EffectIndexLabel.text = string.Format("{0}/{1}", (exampleIndex + 1).ToString("00"), ParticleExamples.Length.ToString("00"));
	}

	private GameObject spawnParticle()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleExamples[exampleIndex]);
		gameObject.transform.position = new Vector3(0f, gameObject.transform.position.y, 0f);
		gameObject.SetActive(value: true);
		ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
		if (component != null && component.main.loop)
		{
			component.gameObject.AddComponent<CFX_AutoStopLoopedEffect>();
			component.gameObject.AddComponent<CFX_AutoDestructShuriken>();
		}
		onScreenParticles.Add(gameObject);
		return gameObject;
	}

	private IEnumerator CheckForDeletedParticles()
	{
		while (true)
		{
			yield return new WaitForSeconds(5f);
			for (int num = onScreenParticles.Count - 1; num >= 0; num--)
			{
				if (onScreenParticles[num] == null)
				{
					onScreenParticles.RemoveAt(num);
				}
			}
		}
	}

	private void prevParticle()
	{
		exampleIndex--;
		if (exampleIndex < 0)
		{
			exampleIndex = ParticleExamples.Length - 1;
		}
		UpdateUI();
	}

	private void nextParticle()
	{
		exampleIndex++;
		if (exampleIndex >= ParticleExamples.Length)
		{
			exampleIndex = 0;
		}
		UpdateUI();
	}

	private void destroyParticles()
	{
		for (int num = onScreenParticles.Count - 1; num >= 0; num--)
		{
			if (onScreenParticles[num] != null)
			{
				UnityEngine.Object.Destroy(onScreenParticles[num]);
			}
			onScreenParticles.RemoveAt(num);
		}
	}
}
public class CFX_Demo_RandomDir : MonoBehaviour
{
	public Vector3 min = new Vector3(0f, 0f, 0f);

	public Vector3 max = new Vector3(0f, 360f, 0f);

	private void Start()
	{
		base.transform.eulerAngles = new Vector3(UnityEngine.Random.Range(min.x, max.x), UnityEngine.Random.Range(min.y, max.y), UnityEngine.Random.Range(min.z, max.z));
	}
}
public class CFX_Demo_RandomDirectionTranslate : MonoBehaviour
{
	public float speed = 30f;

	public Vector3 baseDir = Vector3.zero;

	public Vector3 axis = Vector3.forward;

	public bool gravity;

	private Vector3 dir;

	private void Start()
	{
		dir = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f)).normalized;
		dir.Scale(axis);
		dir += baseDir;
	}

	private void Update()
	{
		base.transform.Translate(dir * speed * Time.deltaTime);
		if (gravity)
		{
			base.transform.Translate(Physics.gravity * Time.deltaTime);
		}
	}
}
public class CFX_Demo_RotateCamera : MonoBehaviour
{
	public static bool rotating = true;

	public float speed = 30f;

	public Transform rotationCenter;

	private void Update()
	{
		if (rotating)
		{
			base.transform.RotateAround(rotationCenter.position, Vector3.up, speed * Time.deltaTime);
		}
	}
}
public class CFX_Demo_Translate : MonoBehaviour
{
	public float speed = 30f;

	public Vector3 rotation = Vector3.forward;

	public Vector3 axis = Vector3.forward;

	public bool gravity;

	private Vector3 dir;

	private void Start()
	{
		dir = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f));
		dir.Scale(rotation);
		base.transform.localEulerAngles = dir;
	}

	private void Update()
	{
		base.transform.Translate(axis * speed * Time.deltaTime, Space.Self);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoDestructShuriken : MonoBehaviour
{
	public bool OnlyDeactivate;

	private void OnEnable()
	{
		StartCoroutine("CheckIfAlive");
	}

	private IEnumerator CheckIfAlive()
	{
		ParticleSystem ps = GetComponent<ParticleSystem>();
		while (ps != null)
		{
			yield return new WaitForSeconds(0.5f);
			if (!ps.IsAlive(withChildren: true))
			{
				if (OnlyDeactivate)
				{
					base.gameObject.SetActive(value: false);
				}
				else
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
				break;
			}
		}
	}
}
public class CFX_AutoRotate : MonoBehaviour
{
	public Vector3 rotation;

	public Space space = Space.Self;

	private void Update()
	{
		base.transform.Rotate(rotation * Time.deltaTime, space);
	}
}
[RequireComponent(typeof(Light))]
public class CFX_LightFlicker : MonoBehaviour
{
	public bool loop;

	public float smoothFactor = 1f;

	public float addIntensity = 1f;

	private float minIntensity;

	private float maxIntensity;

	private float baseIntensity;

	private void Awake()
	{
		baseIntensity = GetComponent<Light>().intensity;
	}

	private void OnEnable()
	{
		minIntensity = baseIntensity;
		maxIntensity = minIntensity + addIntensity;
	}

	private void Update()
	{
		GetComponent<Light>().intensity = Mathf.Lerp(minIntensity, maxIntensity, Mathf.PerlinNoise(Time.time * smoothFactor, 0f));
	}
}
[RequireComponent(typeof(Light))]
public class CFX_LightIntensityFade : MonoBehaviour
{
	public float duration = 1f;

	public float delay;

	public float finalIntensity;

	private float baseIntensity;

	public bool autodestruct;

	private float p_lifetime;

	private float p_delay;

	private void Start()
	{
		baseIntensity = GetComponent<Light>().intensity;
	}

	private void OnEnable()
	{
		p_lifetime = 0f;
		p_delay = delay;
		if (delay > 0f)
		{
			GetComponent<Light>().enabled = false;
		}
	}

	private void Update()
	{
		if (p_delay > 0f)
		{
			p_delay -= Time.deltaTime;
			if (p_delay <= 0f)
			{
				GetComponent<Light>().enabled = true;
			}
		}
		else if (p_lifetime / duration < 1f)
		{
			GetComponent<Light>().intensity = Mathf.Lerp(baseIntensity, finalIntensity, p_lifetime / duration);
			p_lifetime += Time.deltaTime;
		}
		else if (autodestruct)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("")]
public class FilterBehavior : MonoBehaviour
{
	public Shader shader;

	private Material _Material;

	protected Material material
	{
		get
		{
			if (_Material == null)
			{
				_Material = new Material(shader);
				_Material.hideFlags = HideFlags.HideAndDontSave;
			}
			return _Material;
		}
	}

	protected virtual void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shader || !shader.isSupported)
		{
			base.enabled = false;
		}
	}

	protected virtual void OnDisable()
	{
		if ((bool)_Material)
		{
			UnityEngine.Object.DestroyImmediate(_Material);
		}
	}
}
[ExecuteInEditMode]
public class OLDTVScreen : FilterBehavior
{
	public float screenSaturation;

	public Texture chromaticAberrationPattern;

	public float chromaticAberrationMagnetude = 0.015f;

	public Texture noisePattern;

	public float noiseMagnetude = 0.1f;

	public Texture staticPattern;

	public Texture staticMask;

	public float staticVertical;

	public float staticMagnetude = 0.015f;

	private void Awake()
	{
		if ((bool)CalidadManager.instance && CalidadManager.instance.GetCalidad() < CalidadManager.Calidad.Normal)
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_Saturation", screenSaturation);
		base.material.SetTexture("_ChromaticAberrationTex", chromaticAberrationPattern);
		base.material.SetFloat("_ChromaticAberrationMagnetude", chromaticAberrationMagnetude);
		base.material.SetTexture("_NoiseTex", noisePattern);
		base.material.SetFloat("_NoiseOffsetX", UnityEngine.Random.Range(0f, 1f));
		base.material.SetFloat("_NoiseOffsetY", UnityEngine.Random.Range(0f, 1f));
		base.material.SetFloat("_NoiseMagnetude", noiseMagnetude);
		base.material.SetTexture("_StaticTex", staticPattern);
		base.material.SetTexture("_StaticMask", staticMask);
		base.material.SetFloat("_StaticVertical", staticVertical);
		base.material.SetFloat("_StaticMagnetude", staticMagnetude);
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
public class OLDTVTube : FilterBehavior
{
	public delegate void RepaintAction();

	public Texture scanlinePattern;

	public bool scanlineCountAuto;

	public int scanlineCount = 320;

	public float scanlineBrightMin = 0.75f;

	public float scanlineBrightMax = 1f;

	public Texture mask;

	public Texture reflex;

	public float reflexMagnetude = 0.5f;

	public float radialDistortion = 0.2f;

	public event RepaintAction WantRepaint;

	private void Repaint()
	{
		if (this.WantRepaint != null)
		{
			this.WantRepaint();
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_ScanLine", scanlinePattern);
		if (scanlineCountAuto)
		{
			scanlineCount = Screen.height;
		}
		base.material.SetFloat("_ScanLineCount", scanlineCount / 2);
		base.material.SetFloat("_ScanLineMin", scanlineBrightMin);
		base.material.SetFloat("_ScanLineMax", scanlineBrightMax);
		base.material.SetTexture("_MaskTex", mask);
		base.material.SetTexture("_ReflexTex", reflex);
		base.material.SetFloat("_ReflexMagnetude", reflexMagnetude);
		base.material.SetFloat("_Distortion", radialDistortion);
		Graphics.Blit(source, destination, base.material);
	}
}
public class CameraReflex : MonoBehaviour
{
	private OLDTVTube _oldtvtube;

	private void Start()
	{
	}
}
[ExecuteInEditMode]
public class OLDTVFilter3 : MonoBehaviour
{
	[SerializeField]
	private OLDTVPreset _preset;

	[SerializeField]
	private Camera _camera;

	public bool customAspectRatio;

	[SerializeField]
	private Vector2 _aspectRatio = new Vector2(4f, 3f);

	public bool timeScale;

	public OLDTVPreset preset
	{
		get
		{
			return _preset;
		}
		set
		{
			_preset = value;
		}
	}

	public Vector2 aspectRatio
	{
		get
		{
			return _aspectRatio;
		}
		set
		{
			_aspectRatio = value;
		}
	}

	private void Start()
	{
		OnValidate();
	}

	private void Update()
	{
		if (!(_preset == null) && (!timeScale || Time.timeScale != 0f))
		{
			_preset.compositeFilter.OnFixedUpdate();
			_preset.noiseFilter.OnFixedUpdate();
			_preset.staticFilter.OnFixedUpdate();
			_preset.chromaticAberrationFilter.OnFixedUpdate();
			_preset.scanlineFilter.OnFixedUpdate();
			_preset.televisionFilter.OnFixedUpdate();
			_preset.tubeFilter.OnFixedUpdate();
		}
	}

	private void OnValidate()
	{
		aspectRatio = _aspectRatio;
	}

	private void OnPreRender()
	{
		if (!(_camera != null))
		{
			return;
		}
		if (customAspectRatio)
		{
			float num = (float)Screen.width / (float)Screen.height;
			float num2 = _aspectRatio.x / _aspectRatio.y;
			if (num / num2 >= 1f)
			{
				float num3 = (float)Screen.height / _aspectRatio.y * _aspectRatio.x;
				float x = ((float)Screen.width - num3) / 2f;
				_camera.pixelRect = new Rect(x, 0f, num3, Screen.height);
			}
			else
			{
				float num4 = (float)Screen.width / _aspectRatio.x * _aspectRatio.y;
				float y = ((float)Screen.height - num4) / 2f;
				_camera.pixelRect = new Rect(0f, y, Screen.width, num4);
			}
		}
		else
		{
			_camera.rect = new Rect(0f, 0f, 1f, 1f);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (_preset == null)
		{
			Graphics.Blit(source, destination);
			return;
		}
		source.wrapMode = TextureWrapMode.Repeat;
		if (PostProcessingProfile.SOURCEBUFFER == null || !PostProcessingProfile.SOURCEBUFFER.IsCreated() || PostProcessingProfile.SOURCEBUFFER.width != source.width || PostProcessingProfile.SOURCEBUFFER.height != source.height || PostProcessingProfile.SOURCEBUFFER.depth != source.depth)
		{
			if (PostProcessingProfile.SOURCEBUFFER != null && PostProcessingProfile.SOURCEBUFFER.IsCreated())
			{
				PostProcessingProfile.SOURCEBUFFER.DiscardContents();
			}
			PostProcessingProfile.SOURCEBUFFER = new RenderTexture(source.width, source.height, source.depth);
			PostProcessingProfile.SOURCEBUFFER.antiAliasing = 1;
			PostProcessingProfile.SOURCEBUFFER.anisoLevel = 0;
			PostProcessingProfile.SOURCEBUFFER.autoGenerateMips = false;
			PostProcessingProfile.SOURCEBUFFER.filterMode = FilterMode.Bilinear;
		}
		if (PostProcessingProfile.DESTBUFFER == null || !PostProcessingProfile.DESTBUFFER.IsCreated() || PostProcessingProfile.DESTBUFFER.width != source.width || PostProcessingProfile.DESTBUFFER.height != source.height || PostProcessingProfile.DESTBUFFER.depth != source.depth)
		{
			if (PostProcessingProfile.DESTBUFFER != null && PostProcessingProfile.DESTBUFFER.IsCreated())
			{
				PostProcessingProfile.DESTBUFFER.DiscardContents();
			}
			PostProcessingProfile.DESTBUFFER = new RenderTexture(source.width, source.height, source.depth);
			PostProcessingProfile.DESTBUFFER.antiAliasing = 1;
			PostProcessingProfile.DESTBUFFER.anisoLevel = 0;
			PostProcessingProfile.DESTBUFFER.autoGenerateMips = false;
			PostProcessingProfile.DESTBUFFER.filterMode = FilterMode.Bilinear;
		}
		Graphics.Blit(source, PostProcessingProfile.SOURCEBUFFER);
		if (_preset.noiseFilter.enabled)
		{
			_preset.noiseFilter.OnRenderImage(source);
		}
		if (_preset.staticFilter.enabled)
		{
			_preset.staticFilter.OnRenderImage(source);
		}
		if (_preset.compositeFilter.enabled)
		{
			_preset.compositeFilter.OnRenderImage(source);
		}
		if (_preset.chromaticAberrationFilter.enabled)
		{
			_preset.chromaticAberrationFilter.OnRenderImage(source);
		}
		if (_preset.televisionFilter.enabled)
		{
			_preset.televisionFilter.OnRenderImage(source);
		}
		if (_preset.scanlineFilter.enabled)
		{
			_preset.scanlineFilter.OnRenderImage(source);
		}
		if (_preset.tubeFilter.enabled)
		{
			_preset.tubeFilter.OnRenderImage(source);
		}
		Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, destination);
	}
}
public class CameraReflexNew : MonoBehaviour
{
	private OLDTVFilter3 _oldtvfilter;

	private void Start()
	{
	}
}
public class Rotate : MonoBehaviour
{
	public Vector3 rotation = new Vector3(10f, -15f, 7.5f);

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(rotation * Time.deltaTime);
	}
}
public class AnimacionPuntos : MonoBehaviour
{
	private TextMeshProUGUI texto;

	private Coroutine animacion;

	private void Start()
	{
		texto = GetComponent<TextMeshProUGUI>();
	}

	private void OnEnable()
	{
		texto = GetComponent<TextMeshProUGUI>();
		if (animacion != null)
		{
			StopCoroutine(animacion);
		}
		animacion = StartCoroutine(CorutinaAnimacion());
	}

	private IEnumerator CorutinaAnimacion()
	{
		while (true)
		{
			texto.text = ".";
			yield return new WaitForSeconds(0.5f);
			texto.text = "..";
			yield return new WaitForSeconds(0.5f);
			texto.text = "...";
			yield return new WaitForSeconds(0.5f);
			texto.text = "";
			yield return new WaitForSeconds(0.5f);
		}
	}
}
public class AnimDoorsDown : MonoBehaviour
{
	private Animator anim;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	public void OpenDoors()
	{
		anim.SetBool("keyInserted", value: true);
	}
}
public class AnimDoorsUp : MonoBehaviour
{
	private Animator anim;

	private InputsController iCtr;

	private void Start()
	{
		anim = GetComponent<Animator>();
		iCtr = UnityEngine.Object.FindObjectOfType<InputsController>();
	}

	public void OpenDoors()
	{
		anim.SetBool("keyInserted", value: true);
		iCtr.maxRoomCapacityMovementForward = -10f;
	}
}
public class AnimManos : MonoBehaviour
{
	private Animator anim;

	private void Awake()
	{
	}

	private Animator GetAnim()
	{
		if (!anim)
		{
			anim = GetComponent<Animator>();
		}
		return anim;
	}

	private void Start()
	{
	}

	public void CatchWeapon()
	{
		GetAnim().SetBool("attractGun", value: false);
		GetAnim().SetBool("hasPistol", value: true);
		GetAnim().SetBool("hasHook", value: false);
	}

	public void ReleaseActualWeapon()
	{
		GetAnim().SetBool("hasPistol", value: false);
		GetAnim().SetBool("hasHook", value: false);
	}

	public void FireBullet()
	{
		GetAnim().SetTrigger("triggerPistola");
	}

	public void HoldHook()
	{
		GetAnim().SetBool("hasHook", value: true);
		GetAnim().SetBool("hasPistol", value: false);
	}

	public void AttractWeapon()
	{
		GetAnim().SetBool("attractGun", value: true);
		GetAnim().ResetTrigger("triggerPistola");
	}

	public void EmptyHandTryCatchWeapon()
	{
		GetAnim().SetBool("emptyHandTryCatchWeapon", value: true);
	}

	public void EmptyHandStopTryCatchWeapon()
	{
		GetAnim().SetBool("emptyHandTryCatchWeapon", value: false);
	}

	public void MenuSeñalar()
	{
		GetAnim().SetBool("señalar", value: true);
	}

	public void MenuNormal()
	{
		GetAnim().SetBool("señalar", value: false);
	}
}
public class AnimTransformPistola : MonoBehaviour
{
	private Animator animWeapon;

	[HideInInspector]
	public int idPlayer;

	[HideInInspector]
	public SyncJugadores syncjugador;

	private Weapon _weapon;

	private void Start()
	{
		animWeapon = GetComponent<Animator>();
	}

	public void TransformHookToPistol(Weapon weapon, bool noApagarMeshDisplay = false)
	{
		_weapon = weapon;
		_weapon.pantalla.GetComponent<MeshRenderer>().enabled = false;
		if (!animWeapon)
		{
			animWeapon = GetComponent<Animator>();
		}
		animWeapon.SetBool("attractWeapon", value: true);
	}

	private void OnDisable()
	{
		if ((bool)_weapon && (bool)_weapon.pantalla)
		{
			_weapon.pantalla.GetComponent<MeshRenderer>().enabled = true;
		}
	}

	public void TransformPistolToHook()
	{
		animWeapon.SetBool("attractWeapon", value: false);
	}

	public void ActivarPistolaMesh()
	{
		_weapon.pistolaMesh.SetActive(value: true);
		_weapon.gancho.SetActive(value: false);
		_weapon.pantalla.GetComponent<MeshRenderer>().enabled = true;
	}
}
public class ApagarParticulasYDevolverAlPadre : MonoBehaviour
{
	private float tiempo;

	public float tiempoDesaparicion;

	public GameObject padre;

	private void OnEnable()
	{
		tiempo = 0f;
	}

	private void Update()
	{
		tiempo += Time.deltaTime * TimeManager.GetInstance().GetTiempoMedioGlobal();
		if (tiempo > tiempoDesaparicion)
		{
			try
			{
				base.transform.SetParent(padre.transform);
				base.transform.localPosition = Vector3.zero;
				base.transform.localScale = Vector3.one;
				tiempo = 0f;
				base.gameObject.SetActive(value: false);
			}
			catch
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
public class Ascensor : MonoBehaviour
{
	public GameObject puerta;

	public GameObject meshAscensor;

	public GameObject player;

	public GameObject fondo;

	public float vel;

	public float velPuerta;

	public Transform puntoSuperior;

	public Transform puntoInferior;

	public Transform posPuertaAbierta;

	public Transform posPuertaCerrada;

	public Boton boton;

	public bool playerDentro;

	public bool abajo;

	public bool subir;

	public bool bajar;

	public bool abrirPuerta;

	public bool cerrarPuerta;

	public bool parado;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Player")
		{
			playerDentro = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Player")
		{
			playerDentro = false;
		}
	}

	private void Start()
	{
		parado = true;
		player = GameObject.Find("Player");
		fondo = GameObject.Find("FondoNivel");
	}

	private void Update()
	{
		if (subir)
		{
			player.transform.parent = meshAscensor.transform;
			meshAscensor.transform.position = Vector3.MoveTowards(meshAscensor.transform.position, puntoSuperior.position, vel * Time.unscaledDeltaTime);
			parado = false;
			if (meshAscensor.transform.position == puntoSuperior.transform.position)
			{
				AbrirPuerta();
				player.transform.parent = null;
				abajo = false;
				parado = true;
				subir = false;
				boton.DesactivarBoton();
			}
		}
		else if (bajar)
		{
			player.transform.parent = meshAscensor.transform;
			meshAscensor.transform.position = Vector3.MoveTowards(meshAscensor.transform.position, puntoInferior.position, vel * Time.unscaledDeltaTime);
			parado = false;
			if (meshAscensor.transform.position == puntoInferior.transform.position)
			{
				AbrirPuerta();
				player.transform.parent = null;
				abajo = true;
				parado = true;
				bajar = false;
				boton.DesactivarBoton();
			}
		}
		if (abrirPuerta)
		{
			puerta.transform.position = Vector3.MoveTowards(puerta.transform.position, posPuertaAbierta.position, velPuerta * Time.unscaledDeltaTime);
			if (puerta.transform.position == posPuertaAbierta.position)
			{
				abrirPuerta = false;
			}
		}
		else if (cerrarPuerta)
		{
			puerta.transform.position = Vector3.MoveTowards(puerta.transform.position, posPuertaCerrada.position, velPuerta * Time.unscaledDeltaTime);
			if (puerta.transform.position == posPuertaCerrada.position)
			{
				MoverAscensor();
				cerrarPuerta = false;
			}
		}
	}

	public void MoverAscensor()
	{
		fondo.transform.parent = meshAscensor.transform;
		if (abajo)
		{
			subir = true;
			bajar = false;
		}
		else
		{
			bajar = true;
			subir = false;
		}
	}

	public void AbrirPuerta()
	{
		abrirPuerta = true;
		cerrarPuerta = false;
	}

	public void CerrarPuerta()
	{
		cerrarPuerta = true;
		abrirPuerta = true;
	}
}
public abstract class BossBase : MonoBehaviour
{
	public enum FasesBoss
	{
		Apareciendo,
		Movimiento,
		Invulnerable,
		Vulnerable,
		Invocando,
		Muerte
	}

	public enum ClipsAudioBoss
	{
		Risa,
		Enfado,
		Flotar,
		Invocar,
		GolpeEscudoCorrecto,
		GolpeEscudoIncorrecto,
		EscudoRoto,
		muerte,
		victoria,
		extra1,
		extra2,
		extra3,
		frase,
		Cont
	}

	public FasesBoss faseActual;

	public Bola.TipoEscudo tipoEscudo;

	public bool escudoDestruido;

	public int numeroBalasEscudo;

	[HideInInspector]
	public bool ganchoEnganchado;

	public Texture texturaEscudoNegro;

	protected int golpesTotalesBoss;

	private Animator animatorParaPararElBossInicio;

	protected bool nivelIniciado;

	protected int tickSinHacerCosasEsteticas;

	protected int contadorLevitacion;

	protected bool animacionInicioAcabada;

	[HideInInspector]
	public bool muerto;

	[HideInInspector]
	public int tipoEscudoParaOnline;

	[HideInInspector]
	public PhotonView photonView;

	[HideInInspector]
	public int onlineAuxiliar = -1;

	public Material activado;

	public Material desactivado;

	protected AudioClip[] audioClipsBoss = new AudioClip[13];

	protected AudioSource[] audioSources;

	private int audioSourceAnterior;

	private void Awake()
	{
		photonView = GetComponent<PhotonView>();
		if (!photonView.IsMine)
		{
			Animator component = GetComponent<Animator>();
			if ((bool)component)
			{
				UnityEngine.Object.Destroy(component);
			}
		}
	}

	protected virtual void Start()
	{
		animatorParaPararElBossInicio = GetComponent<Animator>();
		audioSources = base.transform.GetComponents<AudioSource>();
		CargarClipsAudio();
		BuscarReferencias();
		if (photonView.IsMine)
		{
			if ((bool)GameManager.instance.bossNivel)
			{
				PhotonNetwork.Destroy(GameManager.instance.bossNivel.gameObject);
			}
			GameManager.instance.bossNivel = this;
		}
	}

	protected abstract void BuscarReferencias();

	public abstract void Morir();

	public abstract void GolpearBoss(int arma);

	public abstract void InvocarEsferas(int numEsferas, int nivelEsferas);

	protected abstract IEnumerator AnimacionMorir();

	protected abstract void CargarClipsAudio();

	public abstract void PonerEscudoNegro();

	public abstract void PonerEscudo();

	public abstract void QuitarEscudo();

	public abstract int TieneEscudo();

	public void SetGanchoEnganchado(bool enganchado)
	{
		ganchoEnganchado = enganchado;
		if (!photonView.IsMine)
		{
			GetComponent<SyncBoss>().MasterGanchoEnganchado(enganchado);
		}
	}

	public void PonerAudioEnAudioSource(ClipsAudioBoss clipAudio)
	{
		AudioClip audioClip = audioClipsBoss[(int)clipAudio];
		if (!audioClip)
		{
			return;
		}
		int num = 0;
		if (audioSources != null)
		{
			num = audioSources.Length;
		}
		if (num == 0)
		{
			return;
		}
		int num2 = -1;
		for (int i = 0; i < audioSources.Length; i++)
		{
			if (!audioSources[i].isPlaying)
			{
				num2 = i;
				break;
			}
		}
		if (num2 == -1)
		{
			num2 = ((audioSourceAnterior != audioSources.Length - 1) ? (audioSourceAnterior + 1) : 0);
		}
		audioSourceAnterior = num2;
		if (num2 < 999)
		{
			audioSources[num2].clip = audioClip;
			audioSources[num2].Play();
		}
	}

	public Color GetBaseColorShield()
	{
		return tipoEscudo switch
		{
			Bola.TipoEscudo.balas => new Color(0.95f, 0.42f, 0.42f, 1f), 
			Bola.TipoEscudo.gancho => new Color(1f, 0.6f, 0.003f, 1f), 
			Bola.TipoEscudo.laser => new Color(0.35f, 0.61f, 0.68f, 1f), 
			_ => new Color(0.5f, 0.68f, 0.36f, 1f), 
		};
	}

	public Color GetFresnelColorShield()
	{
		return tipoEscudo switch
		{
			Bola.TipoEscudo.balas => new Color(0.9f, 0.14f, 0.64f, 1f), 
			Bola.TipoEscudo.gancho => new Color(0.31f, 0.3f, 0.06f, 1f), 
			Bola.TipoEscudo.laser => new Color(0.16f, 0.47f, 1f, 1f), 
			_ => new Color(0.16f, 1f, 0.32f, 1f), 
		};
	}

	public void PararAnimacion()
	{
		if (photonView.IsMine && !nivelIniciado)
		{
			animatorParaPararElBossInicio.enabled = false;
			animacionInicioAcabada = true;
		}
	}

	public void ActivarAnimacion()
	{
		if (photonView.IsMine)
		{
			animatorParaPararElBossInicio.enabled = true;
		}
	}
}
public class BossDragon : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int vecesEscudoDestruido;

	public int golpesPorFase;

	public MeshRenderer escudoEsfera;

	public Transform bossMesh;

	[HideInInspector]
	public Texture[] iconosEscudos;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public Transform puntoSpawn;

	private Animator anim;

	public GameObject bossGolpeado;

	public ParticleSystem particulasExplosion;

	public RotacionEnCadena efectoDragon;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	public bool dragonBase;

	public List<EsferaScript> esferasFase1;

	public List<EsferaScript> esferasFase2;

	public List<EsferaScript> esferasFase3;

	private bool yaEstanMuertos;

	private int animMovimiento;

	public bool risa;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		if (!dragonBase)
		{
			return;
		}
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			nevaEscala = Vector3.one * 0.4f;
			instanciarEsferasCola();
		}
	}

	private void instanciarEsferasCola()
	{
		GameObject gameObject = base.transform.Find("EsferasFase1").gameObject;
		GameObject gameObject2 = base.transform.Find("EsferasFase2").gameObject;
		GameObject gameObject3 = base.transform.Find("EsferasFase3").gameObject;
		Vector3 position = base.transform.Find("PosEsferasCola").position;
		for (int i = 0; i < 3; i++)
		{
			GameObject gameObject4 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject.transform, 1);
			gameObject4.name = "Esfera";
			if (i == 1)
			{
				gameObject4.name += " (1)";
			}
			if (i == 2)
			{
				gameObject4.name += " (2)";
			}
			EsferaScript component = gameObject4.GetComponent<EsferaScript>();
			component.tipoEsfera = Bola.TipoEsfera.negra;
			component.CalcularColor();
			component.NivelDeBolaInicial = 2;
			component.GetComponent<EfectoDesaparecer>().fueraDePool = false;
			efectoDragon.partes.Add(component.transform);
			gameObject4.SetActive(value: false);
			gameObject4.SetActive(value: true);
			esferasFase1[i] = component;
		}
		for (int j = 0; j < 3; j++)
		{
			GameObject gameObject5 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject2.transform, 1);
			EsferaScript component2 = gameObject5.GetComponent<EsferaScript>();
			gameObject5.name = "Esfera";
			if (j == 1)
			{
				gameObject5.name += " (1)";
			}
			if (j == 2)
			{
				gameObject5.name += " (2)";
			}
			component2.tipoEsfera = Bola.TipoEsfera.negra;
			component2.CalcularColor();
			component2.NivelDeBolaInicial = 2;
			component2.GetComponent<EfectoDesaparecer>().fueraDePool = false;
			gameObject5.SetActive(value: false);
			esferasFase2[j] = component2;
		}
		for (int k = 0; k < 3; k++)
		{
			GameObject gameObject6 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject3.transform, 1);
			EsferaScript component3 = gameObject6.GetComponent<EsferaScript>();
			gameObject6.name = "Esfera";
			if (k == 1)
			{
				gameObject6.name += " (1)";
			}
			if (k == 2)
			{
				gameObject6.name += " (2)";
			}
			component3.tipoEsfera = Bola.TipoEsfera.negra;
			component3.CalcularColor();
			component3.NivelDeBolaInicial = 2;
			component3.GetComponent<EfectoDesaparecer>().fueraDePool = false;
			gameObject6.SetActive(value: false);
			esferasFase3[k] = component3;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			vengoDeZonaOscura = false;
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual == FasesBoss.Vulnerable)
		{
			if (tiempoParaActivarEscudo < 10f)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
				if (!escudoDestruido)
				{
					if (vecesEscudoDestruido == 0)
					{
						if (esferasFase1.Count == 0)
						{
							DestruirEscudo();
						}
					}
					else if (vecesEscudoDestruido == 1)
					{
						if (esferasFase2.Count == 0)
						{
							DestruirEscudo();
						}
					}
					else if (esferasFase3.Count == 0)
					{
						DestruirEscudo();
					}
				}
			}
			else
			{
				PonerEsferas();
				if (vecesEscudoDestruido == 0)
				{
					anim.SetTrigger("finvulnerable1");
				}
				else if (vecesEscudoDestruido == 1)
				{
					anim.SetTrigger("finvulnerable2");
				}
				else
				{
					anim.SetTrigger("finvulnerable3");
				}
				tiempoParaActivarEscudo = 0f;
				CambiarFaseAInvulnerable();
			}
		}
		else if (faseActual == FasesBoss.Invocando && NivelCompletado.instance.listaEsferasEquipo1.Count == 0)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.extra2);
			if (vecesEscudoDestruido == 0)
			{
				anim.SetTrigger("vulnerable1");
			}
			else if (vecesEscudoDestruido == 1)
			{
				anim.SetTrigger("vulnerable2");
			}
			else
			{
				anim.SetTrigger("vulnerable3");
			}
			tiempoParaActivarEscudo = 0f;
			CambiarFaseAVulnerable();
			if ((bool)GameManager.instance.paredMovible)
			{
				GameManager.instance.paredMovible.Apagar();
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAMuerte();
		}
	}

	private void OnDisable()
	{
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].Destruirse();
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].Destruirse();
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].Destruirse();
			}
			catch
			{
			}
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		rb.isKinematic = false;
		anim.enabled = false;
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = vecesEscudoDestruido + 1;
		if (risa)
		{
			anim.SetTrigger("Risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	private void CambiarFaseAInvulnerable()
	{
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		rb.isKinematic = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAVulnerable()
	{
		faseActual = FasesBoss.Vulnerable;
		PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
		tiempoParaActivarEscudo = 0f;
		golpesPorFase = 0;
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].ModificarTipoEsferaIngame((Config.modoDeJuego == Config.ModosDeJuego.Online) ? Bola.TipoEsfera.multiEquipo : Bola.TipoEsfera.roja, this);
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].ModificarTipoEsferaIngame((Config.modoDeJuego == Config.ModosDeJuego.Online) ? Bola.TipoEsfera.multiEquipo : Bola.TipoEsfera.roja, this);
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].ModificarTipoEsferaIngame((Config.modoDeJuego == Config.ModosDeJuego.Online) ? Bola.TipoEsfera.multiEquipo : Bola.TipoEsfera.roja, this);
			}
			catch
			{
			}
		}
	}

	public virtual void QuitarEsferaPool(EsferaScript esfera)
	{
		if (vecesEscudoDestruido == 0)
		{
			if (esferasFase1.Contains(esfera))
			{
				esferasFase1.Remove(esfera);
			}
			if (efectoDragon.partes.Contains(esfera.transform))
			{
				efectoDragon.partes.Remove(esfera.transform);
			}
		}
		else if (vecesEscudoDestruido == 1)
		{
			if (esferasFase2.Contains(esfera))
			{
				esferasFase2.Remove(esfera);
			}
			if (efectoDragon.partes.Contains(esfera.transform))
			{
				efectoDragon.partes.Remove(esfera.transform);
			}
		}
		else
		{
			if (esferasFase3.Contains(esfera))
			{
				esferasFase3.Remove(esfera);
			}
			if (efectoDragon.partes.Contains(esfera.transform))
			{
				efectoDragon.partes.Remove(esfera.transform);
			}
		}
	}

	private void CambiarFaseAMuerte()
	{
		faseActual = FasesBoss.Muerte;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void CambiarFaseInvocar()
	{
		faseActual = FasesBoss.Invocando;
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Activa();
		}
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].gameObject.layer = 21;
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].gameObject.layer = 21;
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].gameObject.layer = 21;
			}
			catch
			{
			}
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.balas;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[4]
		{
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1")
		};
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear || faseActual != FasesBoss.Vulnerable || !escudoDestruido)
		{
			return;
		}
		if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		if (golpesPorFase < golpesTotalesBoss)
		{
			StartCoroutine(TiempoPoderGolpear());
			poderGolpear = false;
			golpesPorFase++;
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
		enAnimacion = true;
		anim.enabled = true;
		vecesEscudoDestruido++;
		escudoDestruido = false;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("golpe1");
			efectoDragon.partes.Clear();
			efectoDragon.partes.Add(base.transform.GetChild(0));
			for (int i = 0; i < esferasFase2.Count; i++)
			{
				efectoDragon.partes.Add(esferasFase2[i].transform);
				esferasFase2[i].gameObject.SetActive(value: true);
			}
		}
		else
		{
			anim.SetTrigger("golpe2");
			efectoDragon.partes.Clear();
			efectoDragon.partes.Add(base.transform.GetChild(0));
			for (int j = 0; j < esferasFase3.Count; j++)
			{
				efectoDragon.partes.Add(esferasFase3[j].transform);
				esferasFase3[j].gameObject.SetActive(value: true);
			}
		}
		golpesPorFase = 0;
		CambiarFaseAInvulnerable();
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	private void FinalAnimacion(float scala)
	{
		enAnimacion = false;
		anim.enabled = false;
		nevaEscala = Vector3.one * scala;
		base.transform.localScale = nevaEscala;
	}

	private void ActivarMuro()
	{
		if (photonView.IsMine && (bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Activa();
		}
	}

	private void PonerTiempoParado()
	{
		TimeManager.instance.tiempoMenu = false;
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		numeroBalasEscudo = 0;
		reiniciarNumeroDisparos = null;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public void DestruirEscudo()
	{
		tiempoParaActivarEscudo = 6f;
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		escudoDestruido = false;
		if (efectoDestruccionEscudo != null)
		{
			StopCoroutine(efectoDestruccionEscudo);
		}
		efectoDestruccionEscudo = null;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	private void InvocarEsfera(int nivel)
	{
		Vector3 position = puntoSpawn.position;
		GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
		EsferaScript component = obj.GetComponent<EsferaScript>();
		component.CalcularColor();
		component.NivelDeBolaInicial = nivel;
		Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
		obj.GetComponent<EsferaScript>().dir = vector;
		obj.GetComponent<EsferaScript>().vel = 1.5f;
		obj.SetActive(value: false);
		obj.SetActive(value: true);
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossThailand);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void PonerEsferas()
	{
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
			}
			catch
			{
			}
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		NivelCompletado.instance.bossVivo = false;
		if ((bool)anim)
		{
			anim.enabled = false;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component = other.GetComponent<Bala>();
		UnityEngine.Debug.Log("EscudoDestruido: " + escudoDestruido.ToString() + " fase actual: " + faseActual);
		if (!escudoDestruido && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.RebotarPlayer();
			}
		}
		else if ((bool)component)
		{
			component.TocaObjetoBonus();
			component.EfectoDesaparecer(1);
		}
		GolpearBoss(0);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			if (faseActual != FasesBoss.Vulnerable)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
				return;
			}
			GolpearBoss(1);
			collision.gameObject.GetComponentInParent<Weapon>().RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}
}
public class BossDragonDebil : BossDragon
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	private Rigidbody rb;

	private Animator anim;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	public GameObject golpeBossDebil;

	private GameObject old_golpeBoss;

	private Vector3 posicionInicio;

	private SphereCollider[] colidersBoss;

	private bool proteccionNoMatable;

	private bool yaEstanMuertos;

	private int animMovimiento;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		PonerEscudoNegro();
		colidersBoss = GetComponents<SphereCollider>();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			nevaEscala = Vector3.one * 0.4f;
			posicionInicio = base.transform.position;
			instanciarEsferasColaDevil();
		}
	}

	private void instanciarEsferasColaDevil()
	{
		GameObject gameObject = base.transform.Find("EsferasFase1").gameObject;
		_ = base.transform.Find("EsferasFase3").gameObject;
		Vector3 position = base.transform.Find("PosEsferasCola").position;
		for (int i = 0; i < 3; i++)
		{
			GameObject gameObject2 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject.transform, 1);
			gameObject2.name = "Esfera";
			if (i == 1)
			{
				gameObject2.name += " (1)";
			}
			if (i == 2)
			{
				gameObject2.name += " (2)";
			}
			EsferaScript component = gameObject2.GetComponent<EsferaScript>();
			component.tipoEsfera = Bola.TipoEsfera.negra;
			component.CalcularColor();
			component.NivelDeBolaInicial = 2;
			component.GetComponent<EfectoDesaparecer>().fueraDePool = false;
			efectoDragon.partes.Add(component.transform);
			gameObject2.SetActive(value: false);
			gameObject2.SetActive(value: true);
			esferasFase1[i] = component;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			vengoDeZonaOscura = false;
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = true;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = true;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
			base.transform.position = posicionInicio;
		}
		if (!escudoEsfera.gameObject.activeInHierarchy && !proteccionNoMatable)
		{
			proteccionNoMatable = true;
			escudoDestruido = true;
			faseActual = FasesBoss.Vulnerable;
			poderGolpear = true;
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual == FasesBoss.Vulnerable)
		{
			if (tiempoParaActivarEscudo < 10f)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
				if (!escudoDestruido)
				{
					if (vecesEscudoDestruido == 0)
					{
						if (esferasFase1.Count == 0)
						{
							DestruirEscudo();
						}
					}
					else if (vecesEscudoDestruido == 1)
					{
						if (esferasFase2.Count == 0)
						{
							DestruirEscudo();
						}
					}
					else if (esferasFase3.Count == 0)
					{
						DestruirEscudo();
					}
				}
			}
			else
			{
				PonerEsferas();
				if (vecesEscudoDestruido == 0)
				{
					anim.SetTrigger("finvulnerable1");
				}
				else if (vecesEscudoDestruido == 1)
				{
					anim.SetTrigger("finvulnerable2");
				}
				else
				{
					anim.SetTrigger("finvulnerable3");
				}
				tiempoParaActivarEscudo = 0f;
				CambiarFaseAInvulnerable();
			}
		}
		else if (faseActual == FasesBoss.Invocando && NivelCompletado.instance.listaEsferasEquipo1.Count == 0)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.extra2);
			if (vecesEscudoDestruido == 0)
			{
				anim.SetTrigger("vulnerable1");
			}
			else if (vecesEscudoDestruido == 1)
			{
				anim.SetTrigger("vulnerable2");
			}
			else
			{
				anim.SetTrigger("vulnerable3");
			}
			tiempoParaActivarEscudo = 0f;
			CambiarFaseAVulnerable();
			if ((bool)GameManager.instance.paredMovible)
			{
				GameManager.instance.paredMovible.Apagar();
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAMuerte();
		}
	}

	private void OnDisable()
	{
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].PonerEsferaDeInicio();
					esferasFase1[i].Destruirse();
				}
				catch
				{
				}
			}
			return;
		}
		for (int j = 0; j < esferasFase3.Count; j++)
		{
			try
			{
				esferasFase3[j].PonerEsferaDeInicio();
				esferasFase3[j].Destruirse();
			}
			catch
			{
			}
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		PonerEscudoNegro();
		SeleccionarMovimientoBoss();
	}

	private void CambiarFaseDebil()
	{
		mesh.material = activado;
		onlineAuxiliar = 1;
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		CambiarFaseEIniciarBoss();
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = vecesEscudoDestruido + 1;
		if (risa)
		{
			anim.SetTrigger("Risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	public void CambiarMaterialOnline(bool enabled)
	{
		if (enabled)
		{
			mesh.material = activado;
		}
		else
		{
			mesh.material = desactivado;
		}
	}

	private void CambiarFaseAInvulnerable()
	{
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		rb.isKinematic = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void VolverAPonerEsferasCola(int fase)
	{
		GameObject gameObject = base.transform.Find("EsferasFase1").gameObject;
		GameObject gameObject2 = base.transform.Find("EsferasFase3").gameObject;
		Vector3 position = base.transform.Find("PosEsferasCola").position;
		if (vecesEscudoDestruido == 0 && esferasFase1.Count < 3)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				esferasFase1[i].transform.parent = null;
				esferasFase1[i].PonerEsferaDeInicio();
				PoolObjetos.instance.Eliminar(esferasFase1[i].gameObject);
			}
			esferasFase1.Clear();
			efectoDragon.partes.Clear();
			efectoDragon.partes.Add(base.transform.GetChild(0));
			for (int j = 0; j < 3; j++)
			{
				GameObject gameObject3 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject.transform, 1);
				gameObject3.name = "Esfera";
				if (j == 1)
				{
					gameObject3.name += " (1)";
				}
				if (j == 2)
				{
					gameObject3.name += " (2)";
				}
				gameObject3.layer = 0;
				EsferaScript component = gameObject3.GetComponent<EsferaScript>();
				component.tipoEsfera = Bola.TipoEsfera.negra;
				component.CalcularColor();
				component.NivelDeBolaInicial = 2;
				component.GetComponent<EfectoDesaparecer>().fueraDePool = false;
				efectoDragon.partes.Add(component.transform);
				gameObject3.SetActive(value: false);
				gameObject3.SetActive(value: true);
				esferasFase1.Add(component);
			}
		}
		else
		{
			if (vecesEscudoDestruido != 2 || esferasFase3.Count >= 3)
			{
				return;
			}
			for (int k = 0; k < esferasFase3.Count; k++)
			{
				esferasFase3[k].transform.parent = null;
				esferasFase3[k].PonerEsferaDeInicio();
				PoolObjetos.instance.Eliminar(esferasFase3[k].gameObject);
			}
			esferasFase3.Clear();
			efectoDragon.partes.Clear();
			efectoDragon.partes.Add(base.transform.GetChild(0));
			for (int l = 0; l < 3; l++)
			{
				GameObject gameObject4 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, gameObject2.transform, 1);
				EsferaScript component2 = gameObject4.GetComponent<EsferaScript>();
				gameObject4.layer = 0;
				gameObject4.name = "Esfera";
				if (l == 1)
				{
					gameObject4.name += " (1)";
				}
				if (l == 2)
				{
					gameObject4.name += " (2)";
				}
				component2.tipoEsfera = Bola.TipoEsfera.negra;
				component2.CalcularColor();
				component2.NivelDeBolaInicial = fase;
				component2.GetComponent<EfectoDesaparecer>().fueraDePool = false;
				efectoDragon.partes.Add(component2.transform);
				gameObject4.SetActive(value: false);
				gameObject4.SetActive(value: true);
				esferasFase3.Add(component2);
			}
		}
	}

	private void CambiarFaseAVulnerable()
	{
		faseActual = FasesBoss.Vulnerable;
		PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
		tiempoParaActivarEscudo = 0f;
		golpesPorFase = 0;
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].ModificarTipoEsferaIngame((Config.modoDeJuego == Config.ModosDeJuego.Online) ? Bola.TipoEsfera.multiEquipo : Bola.TipoEsfera.roja, this);
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			mesh.material = desactivado;
			onlineAuxiliar = 0;
			SphereCollider[] array = colidersBoss;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].enabled = false;
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].ModificarTipoEsferaIngame((Config.modoDeJuego == Config.ModosDeJuego.Online) ? Bola.TipoEsfera.multiEquipo : Bola.TipoEsfera.roja, this);
			}
			catch
			{
			}
		}
	}

	public override void QuitarEsferaPool(EsferaScript esfera)
	{
		if (vecesEscudoDestruido == 0)
		{
			if (esferasFase1.Contains(esfera))
			{
				esferasFase1.Remove(esfera);
			}
			if (efectoDragon.partes.Contains(esfera.transform))
			{
				efectoDragon.partes.Remove(esfera.transform);
			}
		}
		else if (vecesEscudoDestruido != 1)
		{
			if (esferasFase3.Contains(esfera))
			{
				esferasFase3.Remove(esfera);
			}
			if (efectoDragon.partes.Contains(esfera.transform))
			{
				efectoDragon.partes.Remove(esfera.transform);
			}
		}
	}

	private void CambiarFaseAMuerte()
	{
		faseActual = FasesBoss.Muerte;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void CambiarFaseInvocar()
	{
		faseActual = FasesBoss.Invocando;
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Activa();
		}
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].gameObject.layer = 21;
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].gameObject.layer = 21;
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].gameObject.layer = 21;
			}
			catch
			{
			}
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.balas;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear || faseActual != FasesBoss.Vulnerable || !escudoDestruido)
		{
			return;
		}
		if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		if (golpesPorFase < golpesTotalesBoss)
		{
			UnityEngine.Debug.Log("Golpeamos al boss");
			StartCoroutine(TiempoPoderGolpear());
			poderGolpear = false;
			golpesPorFase++;
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			return;
		}
		UnityEngine.Debug.Log("Pasamos de fase");
		PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
		enAnimacion = true;
		anim.enabled = true;
		vecesEscudoDestruido++;
		escudoDestruido = false;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("golpe1");
			old_golpeBoss = bossGolpeado;
			bossGolpeado = golpeBossDebil;
		}
		else
		{
			anim.SetTrigger("golpe2");
			mesh.material = activado;
			onlineAuxiliar = 1;
			SphereCollider[] array = colidersBoss;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
		golpesPorFase = 0;
		CambiarFaseAInvulnerable();
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	private void FinalAnimacion(float scala)
	{
		enAnimacion = false;
		anim.enabled = false;
		nevaEscala = Vector3.one * scala;
		base.transform.localScale = nevaEscala;
	}

	private void ActivarMuro()
	{
		if (photonView.IsMine && (bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Activa();
		}
	}

	private void PonerTiempoParado()
	{
		TimeManager.instance.tiempoMenu = false;
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		numeroBalasEscudo = 0;
		reiniciarNumeroDisparos = null;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		escudoDestruido = false;
		if (efectoDestruccionEscudo != null)
		{
			StopCoroutine(efectoDestruccionEscudo);
		}
		efectoDestruccionEscudo = null;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
		proteccionNoMatable = false;
	}

	private void InvocarEsfera(int nivel)
	{
		Vector3 position = puntoSpawn.position;
		GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
		EsferaScript component = obj.GetComponent<EsferaScript>();
		component.CalcularColor();
		component.NivelDeBolaInicial = nivel;
		Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
		obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
		obj.GetComponent<EsferaScript>().dir = vector / 3f;
		obj.SetActive(value: false);
		obj.SetActive(value: true);
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossUS);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void PonerEsferas()
	{
		if (vecesEscudoDestruido == 0)
		{
			for (int i = 0; i < esferasFase1.Count; i++)
			{
				try
				{
					esferasFase1[i].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
				}
				catch
				{
				}
			}
			return;
		}
		if (vecesEscudoDestruido == 1)
		{
			for (int j = 0; j < esferasFase2.Count; j++)
			{
				try
				{
					esferasFase2[j].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
				}
				catch
				{
				}
			}
			return;
		}
		for (int k = 0; k < esferasFase3.Count; k++)
		{
			try
			{
				esferasFase3[k].ModificarTipoEsferaIngame(Bola.TipoEsfera.negra, this);
			}
			catch
			{
			}
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		if ((bool)anim)
		{
			anim.enabled = false;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component = other.GetComponent<Bala>();
		if (!escudoDestruido && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.RebotarPlayer();
			}
		}
		else if ((bool)component)
		{
			component.TocaObjetoBonus();
			component.EfectoDesaparecer(1);
		}
		if (photonView.IsMine)
		{
			GolpearBoss(0);
		}
		else
		{
			GetComponent<SyncBoss>().MasterGolpeoABoss(0);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		if (photonView.IsMine)
		{
			GolpearBoss(1);
		}
		else
		{
			GetComponent<SyncBoss>().MasterGolpeoABoss(1);
		}
		Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
		if (!componentInParent)
		{
			GanchoRifle componentInParent2 = collision.gameObject.GetComponentInParent<GanchoRifle>();
			if ((bool)componentInParent2 && componentInParent2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
			{
				componentInParent2.RebotarGancho();
			}
		}
		else
		{
			componentInParent.RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}
}
public class BossEscudoBala : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public float vel;

	public float velBoss;

	public float porcentaje;

	public Vector3 dir;

	public int vecesEscudoDestruido;

	public int golpesPorFase;

	public MeshRenderer escudoEsfera;

	public Transform bossMesh;

	[HideInInspector]
	public Texture[] iconosEscudos;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public float tiempoVida;

	[HideInInspector]
	public int tiempoParaQuitarFantasmal = 3;

	public bool fantasmal;

	private Transform puntoSpawn;

	private Animator anim;

	private Vector3 posicionCentro;

	private Vector3 posicionTV;

	private bool invocarEsferas;

	private bool esferasInvocadas;

	private bool ponerEscudo;

	public GameObject bossGolpeado;

	public ParticleSystem particulasExplosion;

	public GameObject muroDerecho;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	private bool yaEstanMuertos;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		puntoSpawn = mesh.transform.GetChild(0);
		PonerEscudoNegro();
		posicionCentro = new Vector3(0f, 3.3f, -1.4f);
		posicionTV = new Vector3(-4.26f, 3.1f, -1.48f);
		muroDerecho.transform.parent = null;
		muroDerecho.SetActive(value: true);
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			nevaEscala = Vector3.one * 0.4f;
		}
	}

	private void Update()
	{
		if (faseActual == FasesBoss.Muerte || !photonView.IsMine)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			muroDerecho.SetActive(value: false);
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			muroDerecho.SetActive(value: true);
			vengoDeZonaOscura = false;
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			Vector3 forward = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		}
		if (faseActual == FasesBoss.Apareciendo)
		{
			return;
		}
		if (faseActual == FasesBoss.Movimiento)
		{
			int num2 = ((Config.modoDeJuego != Config.ModosDeJuego.Online || Config.modoDePartida != Config.ModoDePartida.Competitivo) ? 1 : 2);
			rb.velocity = velocidadSinTrucar * (Time.deltaTime * (float)num2 * velBoss);
		}
		else if (faseActual == FasesBoss.Invulnerable)
		{
			if (enAnimacion)
			{
				return;
			}
			Vector3 vector = posicionCentro - base.transform.position;
			base.transform.position += vector * Time.deltaTime;
			base.transform.localScale = nevaEscala;
			if (Vector3.Distance(vector, Vector3.zero) <= 0.3f)
			{
				if (invocarEsferas)
				{
					CambiarFaseAInvocar();
				}
				else if (ponerEscudo)
				{
					CambiarFaseEIniciarBoss();
				}
				else
				{
					CambiarFaseAVulnerable();
				}
			}
		}
		else if (faseActual == FasesBoss.Vulnerable)
		{
			Vector3 vector2 = posicionTV - base.transform.position;
			QuitarEscudo();
			if (Vector3.Distance(vector2, Vector3.zero) >= 2f)
			{
				base.transform.position += vector2 * (Time.deltaTime / 2f);
				base.transform.localScale = nevaEscala;
				bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(vector2), Time.deltaTime * 15f);
			}
			else
			{
				Vector3 forward2 = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
				bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward2), Time.deltaTime * 10f);
			}
			if (tiempoParaActivarEscudo < 2.5f)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
			}
			else
			{
				if (enAnimacion)
				{
					return;
				}
				tiempoParaActivarEscudo = 0f;
				enAnimacion = true;
				anim.enabled = true;
				if (vecesEscudoDestruido == 0)
				{
					anim.SetTrigger("risa1");
				}
				else if (vecesEscudoDestruido == 1)
				{
					anim.SetTrigger("risa2");
				}
				else
				{
					anim.SetTrigger("risa3");
				}
				CambiarFaseAInvulnerable();
			}
		}
		else if (faseActual == FasesBoss.Invocando && esferasInvocadas)
		{
			int num3 = ((Config.modoDeJuego != Config.ModosDeJuego.Online || Config.modoDePartida != Config.ModoDePartida.Competitivo) ? 1 : 2);
			rb.velocity = velocidadSinTrucar * (Time.deltaTime * (float)num3 * velBoss);
			if (NivelCompletado.instance.listaEsferasEquipo1.Count == 0)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.extra2);
				ponerEscudo = true;
				CambiarFaseAInvulnerable();
				if ((bool)GameManager.instance.paredMovible)
				{
					GameManager.instance.paredMovible.Apagar();
				}
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAMuerte();
		}
	}

	private void OnDisable()
	{
		muroDerecho.SetActive(value: false);
	}

	private void CambiarFaseEIniciarBoss()
	{
		if (photonView.IsMine)
		{
			faseActual = FasesBoss.Movimiento;
			rb.isKinematic = false;
			anim.enabled = false;
			ponerEscudo = false;
			velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
			dir *= vel;
			tiempoVida = 0f;
			PonerEscudo();
		}
	}

	private void CambiarFaseAInvulnerable()
	{
		if (photonView.IsMine)
		{
			faseActual = FasesBoss.Invulnerable;
			PonerEscudoNegro();
			rb.isKinematic = true;
			PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
		}
	}

	private void CambiarFaseAVulnerable()
	{
		if (photonView.IsMine)
		{
			faseActual = FasesBoss.Vulnerable;
			rb.isKinematic = true;
			QuitarEscudo();
			tiempoParaActivarEscudo = 0f;
			PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
			ponerEscudo = true;
			golpesPorFase = 0;
		}
	}

	private void CambiarFaseAInvocar()
	{
		if (photonView.IsMine)
		{
			rb.isKinematic = false;
			faseActual = FasesBoss.Invocando;
			PonerEscudoNegro();
			LlamarAInvocarEsfera();
			PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
		}
	}

	private void CambiarFaseAMuerte()
	{
		if (photonView.IsMine)
		{
			faseActual = FasesBoss.Muerte;
			PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
			Morir();
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.balas;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[4]
		{
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1")
		};
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (photonView.IsMine && faseActual != 0)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoCorrecto);
			if (reiniciarNumeroDisparos != null)
			{
				StopCoroutine(reiniciarNumeroDisparos);
				reiniciarNumeroDisparos = null;
			}
			reiniciarNumeroDisparos = StartCoroutine(ReiniciarNumeroDisparosEscudo());
			numeroBalasEscudo += numGolpes;
			if (numeroBalasEscudo > 3)
			{
				invocarEsferas = false;
				DestruirEscudo();
				CambiarFaseAVulnerable();
			}
			else
			{
				SetTexturaEscudoBalas();
			}
		}
	}

	public void SetTexturaEscudoBalas()
	{
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f * (float)numeroBalasEscudo);
		StartCoroutine(PonerEscudoVertexOffseetInicio());
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear || faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		if (golpesPorFase < golpesTotalesBoss)
		{
			StartCoroutine(TiempoPoderGolpear());
			poderGolpear = false;
			golpesPorFase++;
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
		ponerEscudo = false;
		invocarEsferas = true;
		enAnimacion = true;
		anim.enabled = true;
		vecesEscudoDestruido++;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("golpe1");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		CambiarFaseAInvulnerable();
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	private void FinalAnimacion(float scala)
	{
		if (photonView.IsMine)
		{
			enAnimacion = false;
			anim.enabled = false;
			nevaEscala = Vector3.one * scala;
			base.transform.localScale = nevaEscala;
		}
	}

	private void LlamarAInvocarEsfera()
	{
		if (photonView.IsMine)
		{
			esferasInvocadas = false;
			anim.enabled = true;
			if (vecesEscudoDestruido == 1)
			{
				anim.SetTrigger("Invocar");
			}
			else
			{
				anim.SetTrigger("Invocar2");
			}
			if ((bool)GameManager.instance.paredMovible)
			{
				GameManager.instance.paredMovible.Activa();
			}
			velocidadSinTrucar = (posicionTV - base.transform.position).normalized;
			rb.constraints = RigidbodyConstraints.FreezeAll;
			TimeManager.instance.tiempoMenu = true;
		}
	}

	private void FinalizarInvocarEsferas()
	{
		if (photonView.IsMine)
		{
			invocarEsferas = false;
			esferasInvocadas = true;
			anim.enabled = false;
			rb.constraints = RigidbodyConstraints.FreezeRotation;
		}
	}

	private void PonerTiempoParado()
	{
		if (photonView.IsMine)
		{
			TimeManager.instance.tiempoMenu = false;
		}
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		if (photonView.IsMine)
		{
			esferasInvocadas = false;
		}
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		numeroBalasEscudo = 0;
		reiniciarNumeroDisparos = null;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private void InvocarEsfera(int nivel)
	{
		if (photonView.IsMine)
		{
			Vector3 position = puntoSpawn.position;
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
			EsferaScript component = obj.GetComponent<EsferaScript>();
			component.CalcularColor();
			component.NivelDeBolaInicial = nivel;
			Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
			obj.GetComponent<EsferaScript>().dir = vector / 3f;
			obj.SetActive(value: false);
			obj.SetActive(value: true);
		}
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			GetComponent<SyncBoss>().BossDerrotado();
		}
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossJapan);
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		if (!escudoDestruido && tipoEscudo == Bola.TipoEscudo.balas)
		{
			GameObject gameObject = other.gameObject;
			if (!(balaAcabaDeEntrar != gameObject))
			{
				return;
			}
			balaAcabaDeEntrar = gameObject;
			Bala component = other.GetComponent<Bala>();
			SyncBala syncBala = null;
			if (!component)
			{
				syncBala = other.GetComponent<SyncBala>();
			}
			if (!photonView.IsMine)
			{
				return;
			}
			int num = (component ? component.GetNumUsosRestantes() : syncBala.numUsos);
			int num2 = 1;
			int estadoEscudo = GetEstadoEscudo();
			if (estadoEscudo > 0)
			{
				num2 = num;
				if (num2 > estadoEscudo)
				{
					num2 = estadoEscudo;
				}
			}
			GolpeoEscudo(num2);
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(num2);
			}
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component2 = other.GetComponent<Bala>();
		if (!component2)
		{
			other.GetComponent<SyncBala>();
		}
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component2)
			{
				component2.TocaObjetoBonus();
				component2.EfectoDesaparecer(1);
			}
		}
		else if ((bool)component2)
		{
			component2.TocaObjetoBonus();
			component2.EfectoDesaparecer(1);
		}
		if (photonView.IsMine)
		{
			GolpearBoss(0);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			if (photonView.IsMine)
			{
				dir = PhysicsControl.GetInsatance().Bounce(collision.contacts[0].normal, dir, rb, vel, out velocidadSinTrucar);
				if (dir.y > 0f)
				{
					dir.y = 1f;
				}
				else
				{
					dir.y = -1f;
				}
			}
		}
		else
		{
			if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				return;
			}
			if (faseActual != FasesBoss.Vulnerable)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
				return;
			}
			if (photonView.IsMine)
			{
				GolpearBoss(1);
			}
			collision.gameObject.GetComponentInParent<Weapon>().RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}
}
public class BossEscudoCadena : BossBase
{
	private bool escudoActivo = true;

	public int vecesEscudoDestruido;

	public int golpesPorFase;

	public MeshRenderer escudoEsfera;

	public Transform bossMesh;

	[HideInInspector]
	public Texture iconosEscudos;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	private Vector3 posInicio;

	public Transform puntoSpawn;

	private Animator anim;

	private bool invocarEsferas;

	private bool esferasInvocadas;

	private bool ponerEscudo;

	public GameObject bossGolpeado;

	public ParticleSystem particulasExplosion;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	public bool bossMejorado;

	public float velocidadAnimaciones = 1f;

	private bool yaEstanMuertos;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private int nivelMina;

	private int animMovimiento;

	public bool risa;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 2;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			nevaEscala = Vector3.one * 0.4f;
			posInicio = base.transform.position;
			if (bossMejorado)
			{
				velocidadAnimaciones = 1.5f;
				golpesTotalesBoss = 2;
				anim.SetLayerWeight(anim.GetLayerIndex("Boss2"), 1f);
				anim.SetLayerWeight(anim.GetLayerIndex("Boss1"), 0f);
				anim.SetFloat("velocidad", velocidadAnimaciones);
			}
			else
			{
				anim.SetLayerWeight(anim.GetLayerIndex("Boss2"), 0f);
				anim.SetLayerWeight(anim.GetLayerIndex("Boss1"), 1f);
			}
		}
	}

	private void Update()
	{
		if (!photonView.IsMine)
		{
			return;
		}
		anim.SetFloat("velocidad", velocidadAnimaciones);
		if (faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			anim.enabled = false;
			vengoDeZonaOscura = true;
			return;
		}
		if (vengoDeZonaOscura)
		{
			vengoDeZonaOscura = false;
			UnityEngine.Debug.Log("ActivamosAnimator");
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
			PonerEscudoNegro();
		}
		else if (!GameManager.instance.m_salaManager.nivelIniciado && animacionInicioAcabada)
		{
			PararAnimacion();
			nivelIniciado = false;
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual == FasesBoss.Vulnerable)
		{
			QuitarEscudo();
			if (tiempoParaActivarEscudo < 2.5f)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
			}
			else
			{
				UnityEngine.Debug.Log("ActivamosAnimator");
				anim.enabled = true;
				anim.SetTrigger("EscudoRoto");
				tiempoParaActivarEscudo = 0f;
				risa = true;
				SeleccionarMovimientoBoss();
			}
			if (enAnimacion || anim.enabled)
			{
				return;
			}
			Vector3 vector = posInicio - base.transform.position;
			base.transform.position += vector * Time.deltaTime * 2f;
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			GolpearBoss(1);
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		ponerEscudo = false;
		UnityEngine.Debug.Log("ActivamosAnimator");
		anim.enabled = true;
		SeleccionarMovimientoBoss();
		UnityEngine.Debug.Log("Ponemos escudo");
		PonerEscudoNegro();
		risa = false;
		golpesPorFase = 0;
	}

	private void CambiarFaseAInvulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void DesactivarAnimator()
	{
		anim.enabled = false;
	}

	private void CambiarFaseAVulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		tiempoParaActivarEscudo = 0f;
		risa = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
		ponerEscudo = true;
		golpesPorFase = 0;
	}

	private void CambiarFaseAInvocar()
	{
		faseActual = FasesBoss.Invocando;
		PonerEscudoNegro();
		LlamarAInvocarEsfera();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAMuerte()
	{
		faseActual = FasesBoss.Muerte;
		anim.enabled = false;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.laser;
		iconosEscudos = GetIconosEscudo();
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos);
	}

	public Texture GetIconosEscudo()
	{
		return Resources.Load<Texture>("Texturas/shield_chain");
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (photonView.IsMine && numGolpes == 0)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			anim.SetTrigger("EscudoRoto");
			anim.enabled = false;
			risa = true;
			DestruirEscudo();
			CambiarFaseAVulnerable();
		}
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		if (!escudoDestruido && num == 2)
		{
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
				return;
			}
			escudoDestruido = true;
			GolpeoEscudo(0);
			StartCoroutine(TiempoPoderGolpear(1f));
			poderGolpear = false;
		}
		else
		{
			if (faseActual != FasesBoss.Vulnerable)
			{
				return;
			}
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
			}
			if (golpesPorFase < golpesTotalesBoss)
			{
				StartCoroutine(TiempoPoderGolpear(0.05f));
				poderGolpear = false;
				golpesPorFase++;
				PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
				return;
			}
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			UnityEngine.Debug.Log("ActivamosAnimator");
			anim.enabled = true;
			golpesPorFase = 0;
			if (vecesEscudoDestruido == 0)
			{
				anim.SetTrigger("Golpe1");
			}
			else
			{
				anim.SetTrigger("Golpe2");
			}
			vecesEscudoDestruido++;
			CambiarFaseAInvulnerable();
			risa = false;
		}
	}

	private IEnumerator TiempoPoderGolpear(float tiempo)
	{
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: true);
		}
		yield return new WaitForSeconds(tiempo);
		poderGolpear = true;
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: false);
		}
	}

	private void FinalAnimacion(float scala)
	{
		enAnimacion = false;
		anim.enabled = false;
		nevaEscala = Vector3.one * scala;
		base.transform.localScale = nevaEscala;
	}

	private void LlamarAInvocarEsfera()
	{
		esferasInvocadas = false;
		UnityEngine.Debug.Log("ActivamosAnimator");
		anim.enabled = true;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("Invocar");
		}
		else
		{
			anim.SetTrigger("Invocar2");
		}
		rb.constraints = RigidbodyConstraints.FreezeAll;
		TimeManager.instance.tiempoMenu = true;
	}

	private void FinalizarInvocarEsferas()
	{
		invocarEsferas = false;
		esferasInvocadas = true;
		anim.enabled = false;
		rb.constraints = RigidbodyConstraints.FreezeRotation;
	}

	private void PonerTiempoParado()
	{
		TimeManager.instance.tiempoMenu = false;
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		esferasInvocadas = false;
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos);
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private void InvocarEsfera(int nivel)
	{
		Vector3 position = puntoSpawn.position;
		GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
		EsferaScript component = obj.GetComponent<EsferaScript>();
		component.CalcularColor();
		component.NivelDeBolaInicial = nivel;
		Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
		obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
		obj.GetComponent<EsferaScript>().dir = vector / 3f;
		obj.SetActive(value: false);
		obj.SetActive(value: true);
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		if (bossMejorado)
		{
			GameManager.instance.SetLogro(LogrosRecords.Logros.BossBrazil);
		}
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossRussia);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void SeleccionarMovimientoBoss()
	{
		UnityEngine.Debug.Log("Seleccionar movimiento boss");
		animMovimiento = vecesEscudoDestruido + 1;
		if (risa)
		{
			anim.SetTrigger("Risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("Movimiento" + animMovimiento);
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component = other.GetComponent<Bala>();
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.RebotarPlayer();
			}
		}
		else if ((bool)component)
		{
			component.TocaObjetoBonus();
			component.EfectoDesaparecer(1);
		}
		GolpearBoss(0);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola)) || !collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		GolpearBoss(1);
		Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
		if (!componentInParent)
		{
			GanchoRifle componentInParent2 = collision.gameObject.GetComponentInParent<GanchoRifle>();
			if ((bool)componentInParent2 && componentInParent2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
			{
				componentInParent2.RebotarGancho();
			}
		}
		else
		{
			componentInParent.RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}
}
public class BossHackerMetralleta : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 newScale = Vector3.zero;

	public float vel;

	public float velBoss;

	public float porcentaje;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int VecesGolpeado;

	public int golpesEnFase;

	public GameObject esferaSpawn;

	public Transform bossMesh;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public MeshRenderer escudoEsfera;

	public GameObject bossGolpeado;

	private Animator anim;

	private int animMovimiento;

	public ParticleSystem particulasExplosion;

	private ParedPistola[] torretas;

	public bool bossMejorado;

	public GameObject muroDerecho;

	private bool vengoDeZonaOscura;

	private bool risa;

	public float velocidadAnimaciones = 1f;

	private float tiempoParaActivarLasTorretas;

	private float tiempoParaActivarEscudo;

	private bool yaEstanMuertos;

	public float tiempoVulnerable = 2f;

	private Vector3 ultimoTamaño = Vector3.zero;

	private bool torretasActivas;

	private bool poderGolpear = true;

	private Coroutine efectoDestruccionEscudo;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		muroDerecho.transform.parent = null;
		if (!photonView.IsMine)
		{
			return;
		}
		golpesTotalesBoss = 3;
		if (PlayerProgreso.instance.rachaDerrotas >= 10)
		{
			golpesTotalesBoss -= 2;
		}
		else if (PlayerProgreso.instance.rachaDerrotas >= 5)
		{
			golpesTotalesBoss--;
		}
		NivelCompletado.instance.bossVivo = true;
		velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
		dir *= vel;
		anim = GetComponent<Animator>();
		anim.SetTrigger("Entrada");
		newScale = base.transform.localScale;
		torretas = GameManager.instance.m_salaManager.objetosNivelActual.torretasGo.GetComponentsInChildren<ParedPistola>();
		for (int i = 0; i < torretas.Length; i++)
		{
			try
			{
				torretas[i].audioSoruceTorreta.volume = 0.3f;
			}
			catch
			{
			}
		}
		if (bossMejorado)
		{
			tiempoVulnerable = 3f;
			velocidadAnimaciones = 2f;
			golpesTotalesBoss += 2;
			anim.SetFloat("velocidad", velocidadAnimaciones);
		}
	}

	private void Update()
	{
		if (!photonView.IsMine)
		{
			return;
		}
		anim.SetFloat("velocidad", velocidadAnimaciones);
		if (faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			anim.enabled = true;
			vengoDeZonaOscura = false;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		if (faseActual != FasesBoss.Invulnerable)
		{
			Vector3 forward = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		}
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(PartidaSync.instance.GetPlayerObjetivo());
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual == FasesBoss.Vulnerable)
		{
			if (tiempoParaActivarEscudo < tiempoVulnerable)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
			}
			else
			{
				tiempoParaActivarEscudo = 0f;
				PonerAudioEnAudioSource(ClipsAudioBoss.Risa);
				CambiarFaseEIniciarBoss();
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAVulnerable();
		}
	}

	public void CambiarTamañoEnd()
	{
		ultimoTamaño = base.transform.localScale;
	}

	public void CambiarTamañoStart()
	{
		if (ultimoTamaño != Vector3.zero)
		{
			base.transform.localScale = ultimoTamaño;
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		SeleccionarMovimientoBoss();
		PonerEscudoNegro();
	}

	private void CambiarFaseAVulnerable()
	{
		UnityEngine.Debug.Log("Cambio a fase vulnerable");
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		golpesEnFase = 0;
		risa = true;
		for (int i = 0; i < torretas.Length; i++)
		{
			torretas[i].Activar(GameManager.instance.player.photonView.ViewID);
		}
		TimeManager.instance.tiempoMenu = true;
	}

	private void ActivarTorretas()
	{
		if (!GameManager.instance.vengoDeMuerto)
		{
			for (int i = 0; i < torretas.Length; i++)
			{
				torretas[i].Activar(GameManager.instance.player.photonView.ViewID);
			}
			torretasActivas = true;
		}
	}

	private void DesactivarTorretas()
	{
		if (torretasActivas)
		{
			for (int i = 0; i < torretas.Length; i++)
			{
				torretas[i].Desactivar();
			}
			torretasActivas = false;
		}
	}

	private void CambiarFaseAMuerte()
	{
		anim.enabled = false;
		faseActual = FasesBoss.Muerte;
		for (int i = 0; i < torretas.Length; i++)
		{
			torretas[i].Desactivar();
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = VecesGolpeado + 1;
		if (risa)
		{
			anim.SetTrigger("risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.negro;
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear || faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (VecesGolpeado >= 2 && golpesEnFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		StartCoroutine(TiempoPoderGolpear());
		if (golpesEnFase < golpesTotalesBoss)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			golpesEnFase++;
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		if (VecesGolpeado == 0)
		{
			anim.SetTrigger("golpe");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		VecesGolpeado++;
		golpesEnFase = 0;
		risa = false;
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		GameManager.instance.m_salaManager.nivelIniciado = false;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.1f);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.4f);
		GameManager.instance.m_salaManager.nivelIniciado = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		if (!bossMejorado)
		{
			GameManager.instance.SetLogro(LogrosRecords.Logros.BossEgypt);
		}
		else
		{
			GameManager.instance.SetLogro(LogrosRecords.Logros.BossSpain);
		}
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			Bala component = other.GetComponent<Bala>();
			if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
			{
				if ((bool)component)
				{
					component.TocaObjetoBonus();
					component.RebotarPlayer();
				}
			}
			else if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(1);
			}
			GolpearBoss(0);
		}
		else
		{
			if (!other.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				return;
			}
			GolpearBoss(1);
			Weapon componentInParent2 = other.gameObject.GetComponentInParent<Weapon>();
			if (!componentInParent2)
			{
				GanchoRifle componentInParent3 = other.gameObject.GetComponentInParent<GanchoRifle>();
				if ((bool)componentInParent3 && componentInParent3.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					componentInParent3.RebotarGancho();
				}
			}
			else
			{
				componentInParent2.RebotarGancho();
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && collision.gameObject.tag != "Pistola" && collision.gameObject.tag != "BalaEsfera")
		{
			dir = PhysicsControl.GetInsatance().Bounce(collision.contacts[0].normal, dir, rb, vel, out velocidadSinTrucar);
			if (dir.y > 0f)
			{
				dir.y = 1f;
			}
			else
			{
				dir.y = -1f;
			}
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		throw new NotImplementedException();
	}

	private void QuitarInvunerable()
	{
		faseActual = FasesBoss.Movimiento;
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}
}
public class BossIndeciso : BossBase
{
	private bool escudoActivo = true;

	public int vecesEscudoDestruido;

	public int golpesPorFase;

	public MeshRenderer escudoEsfera;

	public Transform bossMesh;

	[HideInInspector]
	public Texture[] iconosEscudos;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	private Vector3 posInicio;

	public Transform puntoSpawn;

	private Animator anim;

	private bool invocarEsferas;

	private bool esferasInvocadas;

	private bool ponerEscudo;

	public GameObject bossGolpeado;

	public ParticleSystem particulasExplosion;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	private bool yaEstanMuertos;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private bool esferasFase;

	private int contadorEsferas;

	private int animMovimiento;

	public bool risa;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 2;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			nevaEscala = Vector3.one * 0.4f;
			posInicio = base.transform.position;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			anim.enabled = false;
			vengoDeZonaOscura = true;
			return;
		}
		if (vengoDeZonaOscura)
		{
			vengoDeZonaOscura = false;
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
		}
		else if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			GolpearBoss(1);
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		ponerEscudo = false;
		anim.enabled = true;
		SeleccionarMovimientoBoss();
		PonerEscudoNegro();
		risa = false;
		golpesPorFase = 0;
	}

	private void CambiarAInicioGancho()
	{
		if (!ganchoEnganchado)
		{
			faseActual = FasesBoss.Movimiento;
			ponerEscudo = false;
			anim.enabled = true;
			SeleccionarMovimientoBoss();
			PonerEscudoNegro();
			risa = false;
			golpesPorFase = 0;
		}
	}

	private void CambiarFaseAInvulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Invulnerable;
		PonerEscudo();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void DesactivarAnimator()
	{
		anim.enabled = false;
	}

	private void CambiarFaseAVulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		tiempoParaActivarEscudo = 0f;
		risa = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
		ponerEscudo = true;
		golpesPorFase = 0;
	}

	private void CambiarFaseAInvocar()
	{
		faseActual = FasesBoss.Invocando;
		PonerEscudoNegro();
		LlamarAInvocarEsfera();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAMuerte()
	{
		faseActual = FasesBoss.Muerte;
		anim.enabled = false;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.gancho;
		iconosEscudos = GetIconosEscudo();
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[7]
		{
			Resources.Load<Texture>("Texturas/shield_hook"),
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1"),
			Resources.Load<Texture>("Texturas/shield_chain"),
			Resources.Load<Texture>("Texturas/shield_mine")
		};
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (!photonView.IsMine || faseActual != FasesBoss.Invulnerable)
		{
			return;
		}
		switch (tipoEscudo)
		{
		case Bola.TipoEscudo.gancho:
			if (numGolpes == 0)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
				anim.SetTrigger("vulnerable" + 1);
				DestruirEscudo();
				StartCoroutine(TiempoPoderGolpear(1f));
				CambiarFaseAVulnerable();
			}
			break;
		case Bola.TipoEscudo.balas:
			if (numGolpes == 1)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoCorrecto);
				if (reiniciarNumeroDisparos != null)
				{
					StopCoroutine(reiniciarNumeroDisparos);
					reiniciarNumeroDisparos = null;
				}
				reiniciarNumeroDisparos = StartCoroutine(ReiniciarNumeroDisparosEscudo());
				numeroBalasEscudo += numGolpes;
				if (numeroBalasEscudo > 3)
				{
					invocarEsferas = false;
					DestruirEscudo();
					StartCoroutine(TiempoPoderGolpear(1f));
					anim.SetTrigger("vulnerable" + 2);
					CambiarFaseAVulnerable();
				}
				else
				{
					escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo + 1]);
					escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f * (float)numeroBalasEscudo);
					StartCoroutine(PonerEscudoVertexOffseetInicio());
				}
			}
			break;
		case Bola.TipoEscudo.laser:
			if (numGolpes == 2)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
				anim.SetTrigger("vulnerable" + 3);
				StartCoroutine(TiempoPoderGolpear(1f));
				DestruirEscudo();
				CambiarFaseAVulnerable();
			}
			break;
		}
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		numeroBalasEscudo = 0;
		reiniciarNumeroDisparos = null;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo + 1]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		if (!escudoDestruido)
		{
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
			}
			else
			{
				GolpeoEscudo(num);
				poderGolpear = true;
			}
		}
		else
		{
			if (faseActual != FasesBoss.Vulnerable)
			{
				return;
			}
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
			}
			if (golpesPorFase < golpesTotalesBoss)
			{
				StartCoroutine(TiempoPoderGolpear(0.05f));
				poderGolpear = false;
				golpesPorFase++;
				PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
				return;
			}
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			anim.enabled = true;
			golpesPorFase = 0;
			if (vecesEscudoDestruido == 0)
			{
				anim.SetTrigger("Golpe1");
				UnityEngine.Object.Destroy(escudoEsfera.GetComponent<BloqueRompible>());
			}
			else
			{
				anim.SetTrigger("Golpe2");
			}
			vecesEscudoDestruido++;
			CambiarFaseAInvulnerable();
			risa = false;
			esferasFase = false;
			contadorEsferas = 0;
		}
	}

	private IEnumerator TiempoPoderGolpear(float tiempo)
	{
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: true);
		}
		yield return new WaitForSeconds(tiempo);
		poderGolpear = true;
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: false);
		}
	}

	private void FinalAnimacion(float scala)
	{
		enAnimacion = false;
		anim.enabled = false;
		nevaEscala = Vector3.one * scala;
		base.transform.localScale = nevaEscala;
	}

	private void LlamarAInvocarEsfera()
	{
		esferasInvocadas = false;
		anim.enabled = true;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("Invocar");
		}
		else
		{
			anim.SetTrigger("Invocar2");
		}
		rb.constraints = RigidbodyConstraints.FreezeAll;
		TimeManager.instance.tiempoMenu = true;
	}

	private void FinalizarInvocarEsferas()
	{
		invocarEsferas = false;
		esferasInvocadas = true;
		anim.enabled = false;
		rb.constraints = RigidbodyConstraints.FreezeRotation;
	}

	private void PonerTiempoParado()
	{
		TimeManager.instance.tiempoMenu = false;
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		esferasInvocadas = false;
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
		escudoDestruido = false;
		tipoEscudo = Bola.TipoEscudo.negro;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	private void CambiarTipoEscudo()
	{
		switch (vecesEscudoDestruido)
		{
		case 0:
			tipoEscudo = Bola.TipoEscudo.gancho;
			break;
		case 1:
			tipoEscudo = Bola.TipoEscudo.balas;
			break;
		case 2:
			tipoEscudo = Bola.TipoEscudo.laser;
			break;
		default:
			tipoEscudo = Bola.TipoEscudo.gancho;
			break;
		}
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		escudoDestruido = false;
		if (photonView.IsMine)
		{
			CambiarTipoEscudo();
		}
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", ponerIconoDependiendoDelEscudo());
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private Texture ponerIconoDependiendoDelEscudo()
	{
		return tipoEscudo switch
		{
			Bola.TipoEscudo.gancho => iconosEscudos[0], 
			Bola.TipoEscudo.balas => iconosEscudos[1], 
			Bola.TipoEscudo.laser => iconosEscudos[5], 
			_ => iconosEscudos[0], 
		};
	}

	private void marcarEsfera()
	{
		esferasFase = true;
		if (PlayerProgreso.instance.rachaDerrotas < 2)
		{
			esferasFase = false;
		}
		else if (PlayerProgreso.instance.rachaDerrotas < 4)
		{
			if (contadorEsferas > 1)
			{
				esferasFase = true;
			}
			contadorEsferas++;
		}
		else if (PlayerProgreso.instance.rachaDerrotas >= 4)
		{
			esferasFase = true;
		}
	}

	private void InvocarEsfera(int nivel)
	{
		if (!esferasFase)
		{
			Vector3 position = puntoSpawn.position;
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
			EsferaScript component = obj.GetComponent<EsferaScript>();
			component.tipoEsfera = Bola.TipoEsfera.negra;
			component.CalcularColor();
			component.NivelDeBolaInicial = 1;
			Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
			obj.GetComponent<EsferaScript>().dir = vector / 3f;
			obj.SetActive(value: false);
			obj.SetActive(value: true);
			PonerAudioEnAudioSource(ClipsAudioBoss.Invocar);
		}
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossBelgium);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = vecesEscudoDestruido + 1;
		if (risa)
		{
			anim.SetTrigger("Risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("Movimiento" + animMovimiento);
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component = other.GetComponent<Bala>();
		if (!component)
		{
			other.GetComponent<SyncBala>();
		}
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if (faseActual == FasesBoss.Invulnerable && !escudoDestruido)
			{
				if ((bool)component)
				{
					component.TocaObjetoBonus();
					component.EfectoDesaparecer(1);
				}
			}
			else if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.RebotarPlayer();
			}
		}
		else if ((bool)component)
		{
			component.TocaObjetoBonus();
			component.EfectoDesaparecer(1);
		}
		if (photonView.IsMine)
		{
			GolpearBoss(1);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola)) || !collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		GolpearBoss(1);
		Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
		if (!componentInParent)
		{
			GanchoRifle componentInParent2 = collision.gameObject.GetComponentInParent<GanchoRifle>();
			if ((bool)componentInParent2 && componentInParent2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
			{
				componentInParent2.RebotarGancho();
			}
		}
		else
		{
			componentInParent.RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}
}
public class BossLaser : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 newScale = Vector3.zero;

	public float vel;

	public float velBoss;

	public float porcentaje;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int VecesGolpeado;

	public int golpesEnFase;

	public GameObject esferaSpawn;

	public Transform bossMesh;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public MeshRenderer escudoEsfera;

	public GameObject bossGolpeado;

	private Animator anim;

	public Transform puntoSpawn;

	private int animMovimiento;

	[HideInInspector]
	public Texture[] iconosEscudos;

	public ParticleSystem particulasExplosion;

	private bool vengoDeZonaOscura;

	private bool risa;

	private float tiempoParaActivarLasTorretas;

	private float tiempoParaActivarEscudo;

	private bool modoLaser;

	public GameObject ojoAsesino;

	private bool yaEstanMuertos;

	private Vector3 ultimoTamaño = Vector3.zero;

	private bool poderGolpear = true;

	private Coroutine reiniciarNumeroDisparos;

	private Texture noiseEscudo;

	private Coroutine efectoDestruccionEscudo;

	private List<EsferaScript> poolEsferasNegras = new List<EsferaScript>();

	private int contadorEsferas;

	private bool esferasRondaInvocadas;

	private bool poderGirarOjo = true;

	private bool giradoDeOjoLaser;

	private Vector3 posicionEnMomentoDeActivar;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
			dir *= vel;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			newScale = base.transform.localScale;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			anim.enabled = true;
			vengoDeZonaOscura = false;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		if (poderGirarOjo && !giradoDeOjoLaser)
		{
			Vector3 forward = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		}
		else if (giradoDeOjoLaser)
		{
			Vector3 forward2 = posicionEnMomentoDeActivar - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward2), Time.deltaTime);
		}
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(PartidaSync.instance.GetPlayerObjetivo());
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual == FasesBoss.Vulnerable)
		{
			if (tiempoParaActivarEscudo < 2f)
			{
				tiempoParaActivarEscudo += Time.deltaTime;
			}
			else
			{
				tiempoParaActivarEscudo = 0f;
				CambiarFaseEIniciarBoss();
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAVulnerable();
		}
	}

	public void CambiarTamañoEnd()
	{
		ultimoTamaño = base.transform.localScale;
	}

	public void CambiarTamañoStart()
	{
		if (ultimoTamaño != Vector3.zero)
		{
			base.transform.localScale = ultimoTamaño;
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		SeleccionarMovimientoBoss();
		PonerEscudoNegro();
	}

	private void CambiarFaseAVulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		golpesEnFase = 0;
		risa = true;
		TimeManager.instance.tiempoMenu = true;
	}

	private void CambiarFaseAInvulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Invulnerable;
		PonerEscudo();
		rb.isKinematic = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAMuerte()
	{
		anim.enabled = false;
		faseActual = FasesBoss.Muerte;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = VecesGolpeado + 1;
		if (risa)
		{
			anim.SetTrigger("risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.balas;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[4]
		{
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1")
		};
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear || faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (VecesGolpeado >= 2 && golpesEnFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		StartCoroutine(TiempoPoderGolpear());
		if (golpesEnFase < golpesTotalesBoss)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			golpesEnFase++;
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		if (VecesGolpeado == 0)
		{
			anim.SetTrigger("golpe");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		VecesGolpeado++;
		esferasRondaInvocadas = false;
		contadorEsferas = 0;
		golpesEnFase = 0;
		risa = false;
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (photonView.IsMine && faseActual == FasesBoss.Invulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoCorrecto);
			if (reiniciarNumeroDisparos != null)
			{
				StopCoroutine(reiniciarNumeroDisparos);
				reiniciarNumeroDisparos = null;
			}
			reiniciarNumeroDisparos = StartCoroutine(ReiniciarNumeroDisparosEscudo());
			numeroBalasEscudo += numGolpes;
			if (numeroBalasEscudo > 3)
			{
				DestruirEscudo();
				CambiarFaseAVulnerable();
				anim.SetTrigger("vulnerable" + animMovimiento);
			}
			else
			{
				escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
				escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f * (float)numeroBalasEscudo);
				StartCoroutine(PonerEscudoVertexOffseetInicio());
			}
		}
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		if (faseActual == FasesBoss.Vulnerable)
		{
			numeroBalasEscudo = 0;
			reiniciarNumeroDisparos = null;
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
			escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		}
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.1f);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.4f);
		GameManager.instance.m_salaManager.nivelIniciado = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossSingapore);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void InvocarEsfera(int nivel)
	{
		if (!esferasRondaInvocadas)
		{
			Vector3 position = puntoSpawn.position;
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
			EsferaScript component = obj.GetComponent<EsferaScript>();
			poolEsferasNegras.Add(component);
			component.tipoEsfera = Bola.TipoEsfera.negra;
			component.CalcularColor();
			component.NivelDeBolaInicial = 1;
			Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
			obj.GetComponent<EsferaScript>().dir = vector / 3f;
			obj.SetActive(value: false);
			obj.SetActive(value: true);
			PonerAudioEnAudioSource(ClipsAudioBoss.Invocar);
		}
	}

	private void ActivarRotacionOjo()
	{
		onlineAuxiliar = 1;
		poderGirarOjo = true;
	}

	private void DesactivarRotacionOjo()
	{
		poderGirarOjo = false;
		giradoDeOjoLaser = true;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			float num = 99999f;
			posicionEnMomentoDeActivar = Vector3.one * 1000f;
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					continue;
				}
				try
				{
					Transform transform = PhotonView.Find(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer).transform;
					if (Vector3.Distance(transform.position, base.transform.position) < num)
					{
						posicionEnMomentoDeActivar = transform.position;
					}
				}
				catch
				{
				}
			}
			if (posicionEnMomentoDeActivar == Vector3.one * 1000f)
			{
				posicionEnMomentoDeActivar = PartidaSync.instance.GetPlayerObjetivo().position;
			}
		}
		else
		{
			posicionEnMomentoDeActivar = PartidaSync.instance.GetPlayerObjetivo().position;
		}
		posicionEnMomentoDeActivar = PartidaSync.instance.GetPlayerObjetivo().position;
		modoLaser = true;
	}

	private void DesactivarRotacionOjoLaser()
	{
		onlineAuxiliar = 0;
		giradoDeOjoLaser = false;
		poderGirarOjo = true;
	}

	private void PonerModoMovimiento()
	{
		if (faseActual != FasesBoss.Vulnerable)
		{
			risa = true;
			CambiarFaseEIniciarBoss();
		}
	}

	private void MArcarEsferasRondasInvocadas()
	{
		if (PlayerProgreso.instance.rachaDerrotas < 2)
		{
			esferasRondaInvocadas = false;
		}
		else if (PlayerProgreso.instance.rachaDerrotas < 4)
		{
			if (contadorEsferas > 1)
			{
				esferasRondaInvocadas = true;
			}
			contadorEsferas++;
		}
		else if (PlayerProgreso.instance.rachaDerrotas >= 4)
		{
			esferasRondaInvocadas = true;
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		if (!escudoDestruido && tipoEscudo == Bola.TipoEscudo.balas && faseActual == FasesBoss.Invulnerable)
		{
			GameObject gameObject = other.gameObject;
			if (!(balaAcabaDeEntrar != gameObject))
			{
				return;
			}
			balaAcabaDeEntrar = gameObject;
			Bala component = other.GetComponent<Bala>();
			SyncBala syncBala = null;
			if (!component)
			{
				syncBala = other.GetComponent<SyncBala>();
			}
			if (!photonView.IsMine)
			{
				return;
			}
			int num = (component ? component.GetNumUsosRestantes() : syncBala.numUsos);
			int num2 = 1;
			int estadoEscudo = GetEstadoEscudo();
			if (estadoEscudo > 0)
			{
				num2 = num;
				if (num2 > estadoEscudo)
				{
					num2 = estadoEscudo;
				}
			}
			if (photonView.IsMine)
			{
				GolpeoEscudo(num2);
			}
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(num2);
			}
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component2 = other.GetComponent<Bala>();
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component2)
			{
				component2.TocaObjetoBonus();
				component2.RebotarPlayer();
			}
		}
		else if ((bool)component2)
		{
			component2.TocaObjetoBonus();
			component2.EfectoDesaparecer(1);
		}
		GolpearBoss(0);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			dir = PhysicsControl.GetInsatance().Bounce(collision.contacts[0].normal, dir, rb, vel, out velocidadSinTrucar);
			if (dir.y > 0f)
			{
				dir.y = 1f;
			}
			else
			{
				dir.y = -1f;
			}
		}
		else
		{
			if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				return;
			}
			if (faseActual != FasesBoss.Vulnerable)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
				return;
			}
			GolpearBoss(1);
			Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
			if (!componentInParent)
			{
				GanchoRifle componentInParent2 = collision.gameObject.GetComponentInParent<GanchoRifle>();
				if ((bool)componentInParent2 && componentInParent2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					componentInParent2.RebotarGancho();
				}
			}
			else
			{
				componentInParent.RebotarGancho();
			}
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		throw new NotImplementedException();
	}

	private void QuitarInvunerable()
	{
		faseActual = FasesBoss.Movimiento;
	}

	public void EnableLaserOnline(bool enabled)
	{
		ojoAsesino.SetActive(enabled);
	}
}
public class BossMina : BossBase
{
	private bool escudoActivo = true;

	public int vecesEscudoDestruido;

	public int golpesPorFase;

	public GameObject esferaSpawn;

	public MeshRenderer escudoEsfera;

	public Transform bossMesh;

	[HideInInspector]
	public Texture iconosEscudos;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	private Vector3 posInicio;

	private Transform puntoSpawn;

	private Animator anim;

	private bool invocarEsferas;

	private bool esferasInvocadas;

	private bool ponerEscudo;

	public GameObject bossGolpeado;

	public ParticleSystem particulasExplosion;

	private bool vengoDeZonaOscura;

	private bool enAnimacion;

	private float tiempoParaActivarEscudo;

	private bool yaEstanMuertos;

	private Coroutine reiniciarNumeroDisparos;

	private bool poderGolpear = true;

	private Vector3 nevaEscala;

	private Coroutine efectoDestruccionEscudo;

	private Texture noiseEscudo;

	private int nivelMina;

	private int contadorEsferas;

	private bool esferasRondaInvocadas;

	private int animMovimiento;

	public bool risa;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		puntoSpawn = mesh.transform.GetChild(0);
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudo();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 2;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			nevaEscala = Vector3.one * 0.4f;
			posInicio = base.transform.position;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			anim.enabled = false;
			vengoDeZonaOscura = true;
			return;
		}
		if (vengoDeZonaOscura)
		{
			vengoDeZonaOscura = false;
			anim.enabled = true;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			return;
		}
		if (faseActual != FasesBoss.Movimiento)
		{
			if (faseActual == FasesBoss.Invulnerable)
			{
				if (vecesEscudoDestruido == 1)
				{
					base.transform.localScale = Vector3.one * 0.3f;
				}
				else
				{
					base.transform.localScale = Vector3.one * 0.19f;
				}
				if (enAnimacion || anim.enabled)
				{
					return;
				}
				Vector3 vector = posInicio - base.transform.position;
				base.transform.position += vector * Time.deltaTime * 2f;
				if (Vector3.Distance(vector, Vector3.zero) <= 0.05f)
				{
					CambiarFaseEIniciarBoss();
				}
			}
			else if (faseActual == FasesBoss.Vulnerable)
			{
				QuitarEscudo();
				if (tiempoParaActivarEscudo < 2.5f)
				{
					tiempoParaActivarEscudo += Time.deltaTime;
				}
				else if (!(tiempoParaActivarEscudo < 0.5f))
				{
					anim.enabled = true;
					anim.SetTrigger("EscudoRoto");
					tiempoParaActivarEscudo = 0f;
					risa = true;
					CambiarFaseAInvulnerable();
				}
				if (enAnimacion || anim.enabled)
				{
					return;
				}
				Vector3 vector2 = posInicio - base.transform.position;
				base.transform.position += vector2 * Time.deltaTime * 2f;
			}
			else if (faseActual == FasesBoss.Invocando && esferasInvocadas && NivelCompletado.instance.listaEsferasEquipo1.Count == 0)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.extra2);
				ponerEscudo = true;
				CambiarFaseAInvulnerable();
			}
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			GolpearBoss(1);
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		ponerEscudo = false;
		anim.enabled = true;
		PonerEscudo();
		risa = false;
		golpesPorFase = 0;
	}

	private void CambiarFaseAInvulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void DesactivarAnimator()
	{
		anim.enabled = false;
	}

	private void CambiarFaseAVulnerable()
	{
		if (faseActual == FasesBoss.Muerte)
		{
			anim.enabled = false;
			return;
		}
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		tiempoParaActivarEscudo = 0f;
		risa = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.extra1);
		ponerEscudo = true;
		golpesPorFase = 0;
	}

	private void CambiarFaseAInvocar()
	{
		faseActual = FasesBoss.Invocando;
		PonerEscudoNegro();
		LlamarAInvocarEsfera();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAMuerte()
	{
		faseActual = FasesBoss.Muerte;
		anim.enabled = false;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.mina;
		iconosEscudos = GetIconosEscudo();
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos);
	}

	public Texture GetIconosEscudo()
	{
		return Resources.Load<Texture>("Texturas/shield_mine");
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (photonView.IsMine && numGolpes == 0)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			anim.SetTrigger("EscudoRoto");
			anim.enabled = false;
			risa = true;
			DestruirEscudo();
			CambiarFaseAVulnerable();
		}
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		if (!escudoDestruido && num == 5)
		{
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
				return;
			}
			escudoDestruido = true;
			StartCoroutine(TiempoPoderGolpear(1f));
			GolpeoEscudo(0);
			poderGolpear = false;
			UnityEngine.Debug.Log("Sumamos destruccion escudo");
		}
		else
		{
			if (faseActual != FasesBoss.Vulnerable)
			{
				return;
			}
			if (vecesEscudoDestruido > 1 && golpesPorFase >= golpesTotalesBoss)
			{
				DestruirEscudo();
				CambiarFaseAMuerte();
			}
			if (golpesPorFase < 2)
			{
				StartCoroutine(TiempoPoderGolpear(0.05f));
				poderGolpear = false;
				golpesPorFase++;
				PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
				return;
			}
			PonerAudioEnAudioSource(ClipsAudioBoss.extra3);
			anim.enabled = true;
			golpesPorFase = 0;
			if (vecesEscudoDestruido == 0)
			{
				anim.SetTrigger("Golpe1");
			}
			else
			{
				anim.SetTrigger("Golpe2");
			}
			vecesEscudoDestruido++;
			CambiarFaseAInvulnerable();
			risa = false;
			esferasRondaInvocadas = false;
			contadorEsferas = 0;
		}
	}

	private IEnumerator TiempoPoderGolpear(float tiempo)
	{
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: true);
		}
		yield return new WaitForSeconds(tiempo);
		poderGolpear = true;
		if (tiempo != 1f)
		{
			bossGolpeado.SetActive(value: false);
		}
	}

	private void FinalAnimacion(float scala)
	{
		enAnimacion = false;
		anim.enabled = false;
		nevaEscala = Vector3.one * scala;
		base.transform.localScale = nevaEscala;
	}

	private void LlamarAInvocarEsfera()
	{
		esferasInvocadas = false;
		anim.enabled = true;
		if (vecesEscudoDestruido == 1)
		{
			anim.SetTrigger("Invocar");
		}
		else
		{
			anim.SetTrigger("Invocar2");
		}
		rb.constraints = RigidbodyConstraints.FreezeAll;
		TimeManager.instance.tiempoMenu = true;
	}

	private void FinalizarInvocarEsferas()
	{
		invocarEsferas = false;
		esferasInvocadas = true;
		anim.enabled = false;
		rb.constraints = RigidbodyConstraints.FreezeRotation;
	}

	private void PonerTiempoParado()
	{
		TimeManager.instance.tiempoMenu = false;
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		esferasInvocadas = false;
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
		if (reiniciarNumeroDisparos != null)
		{
			StopCoroutine(reiniciarNumeroDisparos);
			reiniciarNumeroDisparos = null;
		}
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos);
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private void InvocarEsfera(int nivel)
	{
		if (nivel == 1)
		{
			Vector3 position = puntoSpawn.position;
			GameObject obj = PhotonNetwork.Instantiate("Prefabs/Mina", position, Quaternion.identity, 0);
			obj.transform.SetParent(base.transform.parent);
			obj.transform.position = position;
			Mina component = obj.GetComponent<Mina>();
			component.generadaPorBoss = true;
			component.nivel = 2;
			component.GetComponent<Rigidbody>().velocity = (PartidaSync.instance.GetPlayerObjetivo().position - position) * 1.5f;
			obj.SetActive(value: false);
			obj.SetActive(value: true);
			PonerAudioEnAudioSource(ClipsAudioBoss.Invocar);
		}
		else if (!esferasRondaInvocadas)
		{
			Vector3 position2 = puntoSpawn.position;
			GameObject obj2 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position2, Quaternion.identity, null, 1);
			EsferaScript component2 = obj2.GetComponent<EsferaScript>();
			component2.tipoEsfera = Bola.TipoEsfera.negra;
			component2.CalcularColor();
			component2.NivelDeBolaInicial = 1;
			Vector3 dir = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			obj2.GetComponent<EsferaScript>().dir = dir;
			obj2.GetComponent<EsferaScript>().vel = 1.5f;
			obj2.SetActive(value: false);
			obj2.SetActive(value: true);
			PonerAudioEnAudioSource(ClipsAudioBoss.Invocar);
		}
	}

	private void MArcarEsferasRondasInvocadas()
	{
		if (PlayerProgreso.instance.rachaDerrotas < 2)
		{
			esferasRondaInvocadas = false;
		}
		else if (PlayerProgreso.instance.rachaDerrotas < 4)
		{
			if (contadorEsferas > 1)
			{
				esferasRondaInvocadas = true;
			}
			contadorEsferas++;
		}
		else if (PlayerProgreso.instance.rachaDerrotas >= 4)
		{
			esferasRondaInvocadas = true;
		}
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.5f);
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossMexico);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = vecesEscudoDestruido + 1;
		if (risa)
		{
			anim.SetTrigger("Risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("Movimiento" + animMovimiento);
		}
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Arma componentInParent = other.GetComponentInParent<Arma>();
			if ((bool)componentInParent)
			{
				bool flag = !componentInParent.weaponScript || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano;
				if (flag && !GameManager.instance.player.muerto)
				{
					if (muerto)
					{
						return;
					}
					PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
					GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
				}
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component = other.GetComponent<Bala>();
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.RebotarPlayer();
			}
		}
		else if ((bool)component)
		{
			component.TocaObjetoBonus();
			component.EfectoDesaparecer(1);
		}
		GolpearBoss(0);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola)) || !collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		GolpearBoss(1);
		Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
		GanchoRifle ganchoRifle = null;
		if (!componentInParent)
		{
			ganchoRifle = collision.gameObject.GetComponentInParent<GanchoRifle>();
		}
		if ((bool)componentInParent)
		{
			componentInParent.RebotarGancho();
		}
		else if ((bool)ganchoRifle && ganchoRifle.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
		{
			ganchoRifle.RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
	}
}
public class BossOjoDebil : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 newScale = Vector3.zero;

	public float vel;

	public float velBoss;

	public float porcentaje;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int VecesGolpeado;

	public int golpesEnFase;

	public GameObject esferaSpawn;

	public Transform bossMesh;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public MeshRenderer escudoEsfera;

	public GameObject bossGolpeado;

	private Animator anim;

	public Transform puntoSpawn;

	private int animMovimiento;

	public ParticleSystem particulasExplosion;

	private SphereCollider[] colidersBoss;

	private bool vengoDeZonaOscura;

	private bool risa;

	private float tiempoParaActivarLasTorretas;

	private float tiempoParaActivarEscudo;

	private bool modoLaser;

	private bool yaEstanMuertos;

	private Vector3 ultimoTamaño = Vector3.zero;

	public bool poderGolpear = true;

	private Texture noiseEscudo;

	private Coroutine efectoDestruccionEscudo;

	private List<EsferaScript> poolEsferasNegras = new List<EsferaScript>();

	private bool esferasRondaInvocadas;

	private bool poderGirarOjo = true;

	private bool giradoDeOjoLaser;

	private Vector3 posicionEnMomentoDeActivar;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		colidersBoss = GetComponents<SphereCollider>();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
			dir *= vel;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			newScale = base.transform.localScale;
		}
	}

	private void Update()
	{
		if (!photonView.IsMine || faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			anim.enabled = true;
			vengoDeZonaOscura = false;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		if (poderGirarOjo && !giradoDeOjoLaser)
		{
			Vector3 forward = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 30f);
		}
		else if (giradoDeOjoLaser)
		{
			Vector3 forward2 = posicionEnMomentoDeActivar - bossMesh.position;
			bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward2), Time.deltaTime);
		}
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(PartidaSync.instance.GetPlayerObjetivo());
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
		}
		else
		{
			_ = faseActual;
			_ = 3;
			if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
			{
				CambiarFaseAVulnerable();
			}
		}
	}

	public void CambiarTamañoEnd()
	{
		ultimoTamaño = base.transform.localScale;
	}

	public void CambiarTamañoStart()
	{
		if (ultimoTamaño != Vector3.zero)
		{
			base.transform.localScale = ultimoTamaño;
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		mesh.material = activado;
		onlineAuxiliar = 1;
		SeleccionarMovimientoBoss();
		PonerEscudoNegro();
	}

	private void CambiarFaseAVulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		mesh.material = desactivado;
		onlineAuxiliar = 0;
		golpesEnFase = 0;
		poderGolpear = true;
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		risa = true;
	}

	private void CambiarMaterial(int estado)
	{
		if (estado == 0)
		{
			PonerEscudo();
			mesh.material = activado;
			onlineAuxiliar = 1;
		}
		else
		{
			QuitarEscudo();
			mesh.material = desactivado;
			onlineAuxiliar = 0;
		}
	}

	private void CambiarFaseAInvulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Invulnerable;
		mesh.material = activado;
		onlineAuxiliar = 1;
		PonerEscudoNegro();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
	}

	private void CambiarFaseAMuerte()
	{
		anim.enabled = false;
		faseActual = FasesBoss.Muerte;
		mesh.material = activado;
		onlineAuxiliar = 1;
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = VecesGolpeado + 1;
		if (risa)
		{
			anim.SetTrigger("risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.nunguno;
	}

	public void CambiarMaterialOnline(bool enabled)
	{
		if (enabled)
		{
			mesh.material = activado;
		}
		else
		{
			mesh.material = desactivado;
		}
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		poderGolpear = false;
		if (faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (VecesGolpeado >= 2 && golpesEnFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		StartCoroutine(TiempoPoderGolpear());
		if (golpesEnFase < golpesTotalesBoss)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			golpesEnFase++;
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		CambiarFaseAInvulnerable();
		if (VecesGolpeado == 0)
		{
			anim.SetTrigger("golpe1");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		VecesGolpeado++;
		esferasRondaInvocadas = false;
		golpesEnFase = 0;
		risa = false;
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		GameManager.instance.m_salaManager.nivelIniciado = false;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.1f);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.4f);
		GameManager.instance.m_salaManager.nivelIniciado = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossChina);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void InvocarEsfera(int nivel)
	{
		Vector3 position = puntoSpawn.position;
		GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
		EsferaScript component = obj.GetComponent<EsferaScript>();
		component.CalcularColor();
		component.NivelDeBolaInicial = nivel;
		Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
		UnityEngine.Debug.Log(vector);
		obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
		obj.GetComponent<EsferaScript>().dir = vector / 3f;
		obj.SetActive(value: false);
		obj.SetActive(value: true);
	}

	private void ActivarRotacionOjo()
	{
		poderGirarOjo = true;
	}

	private void DesactivarRotacionOjo()
	{
		poderGirarOjo = false;
		giradoDeOjoLaser = true;
		posicionEnMomentoDeActivar = GameManager.instance.player.transform.position;
		modoLaser = true;
	}

	private void DesactivarRotacionOjoLaser()
	{
		giradoDeOjoLaser = false;
		poderGirarOjo = true;
	}

	private void PonerModoMovimiento()
	{
		if (faseActual != FasesBoss.Vulnerable)
		{
			risa = true;
			CambiarFaseEIniciarBoss();
		}
	}

	private void MArcarEsferasRondasInvocadas()
	{
		esferasRondaInvocadas = true;
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			Bala component = other.GetComponent<Bala>();
			if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
			{
				if ((bool)component)
				{
					component.TocaObjetoBonus();
					component.RebotarPlayer();
				}
			}
			else if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(1);
			}
			if (photonView.IsMine)
			{
				GolpearBoss(0);
			}
			else
			{
				GetComponent<SyncBoss>().MasterGolpeoABoss(0);
			}
		}
		else
		{
			if (!other.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				return;
			}
			if (photonView.IsMine)
			{
				GolpearBoss(1);
			}
			else
			{
				GetComponent<SyncBoss>().MasterGolpeoABoss(1);
			}
			Weapon componentInParent2 = other.gameObject.GetComponentInParent<Weapon>();
			if (!componentInParent2)
			{
				GanchoRifle componentInParent3 = other.gameObject.GetComponentInParent<GanchoRifle>();
				if ((bool)componentInParent3 && componentInParent3.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					componentInParent3.RebotarGancho();
				}
			}
			else
			{
				componentInParent2.RebotarGancho();
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		if (photonView.IsMine)
		{
			GolpearBoss(1);
		}
		else
		{
			GetComponent<SyncBoss>().MasterGolpeoABoss(1);
		}
		collision.gameObject.GetComponentInParent<Weapon>().RebotarGancho();
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		throw new NotImplementedException();
	}

	private void QuitarInvunerable()
	{
		faseActual = FasesBoss.Movimiento;
	}

	public override void PonerEscudo()
	{
		escudoEsfera.gameObject.SetActive(value: true);
		tipoEscudoParaOnline = 1;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}
}
public class BossSatelites : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 newScale = Vector3.zero;

	public float vel;

	public float velBoss;

	public float porcentaje;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int VecesGolpeado;

	public int golpesEnFase;

	public GameObject esferaSpawn;

	public Transform bossMesh;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public MeshRenderer escudoEsfera;

	public GameObject bossGolpeado;

	private Animator anim;

	public Transform puntoSpawn;

	private int animMovimiento;

	public ParticleSystem particulasExplosion;

	private SphereCollider[] colidersBoss;

	public GameObject[] referenciaEsferasTorretas;

	public GameObject[] esferasTorretas;

	public List<esferaTorreta> esferasTorreta;

	private bool vengoDeZonaOscura;

	private bool risa;

	private float tiempoParaActivarLasTorretas;

	private float tiempoParaActivarEscudo;

	private bool modoLaser;

	private bool yaEstanMuertos;

	public bool poderGolpear = true;

	private Texture noiseEscudo;

	private Coroutine efectoDestruccionEscudo;

	private List<EsferaScript> poolEsferasNegras = new List<EsferaScript>();

	private bool esferasRondaInvocadas;

	private bool poderGirarOjo = true;

	private bool giradoDeOjoLaser;

	private Vector3 posicionEnMomentoDeActivar;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		colidersBoss = GetComponents<SphereCollider>();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
			dir *= vel;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			newScale = base.transform.localScale;
			prepararEsferasTorretaFaseBoss(0);
		}
	}

	private void Update()
	{
		if (!photonView.IsMine)
		{
			return;
		}
		if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			DispararTorretasActivas();
		}
		if (faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			anim.enabled = true;
			vengoDeZonaOscura = false;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 30f);
		esferasTorretas[VecesGolpeado].transform.parent.localEulerAngles = bossMesh.localEulerAngles;
		esferasTorretas[VecesGolpeado].transform.localEulerAngles = new Vector3(0f, 0f, esferasTorretas[VecesGolpeado].transform.localEulerAngles.z + Time.deltaTime * 15f);
		if (faseActual != 0 || nivelIniciado)
		{
			return;
		}
		tickSinHacerCosasEsteticas++;
		if (tickSinHacerCosasEsteticas < 1)
		{
			return;
		}
		tickSinHacerCosasEsteticas = 0;
		base.transform.LookAt(playerObjetivo);
		if (contadorLevitacion >= 0)
		{
			contadorLevitacion++;
			if (contadorLevitacion > 60)
			{
				contadorLevitacion = -1;
			}
			else
			{
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
			}
		}
		else
		{
			contadorLevitacion--;
			if (contadorLevitacion < -60)
			{
				contadorLevitacion = 1;
			}
			else
			{
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
			}
		}
	}

	public void DispararTorretasActivas()
	{
		for (int i = 0; i < esferasTorreta.Count; i++)
		{
			esferasTorreta[i].Destruir();
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		PonerEscudoNegro();
	}

	private void CambiarFaseAVulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		golpesEnFase = 0;
		poderGolpear = true;
		anim.SetTrigger("vulnerable" + (VecesGolpeado + 1));
		risa = true;
	}

	private void CambiarFaseAInvulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
	}

	private void CambiarFaseAMuerte()
	{
		anim.enabled = false;
		faseActual = FasesBoss.Muerte;
		SphereCollider[] array = colidersBoss;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.nunguno;
	}

	public void prepararEsferasTorretaFaseBoss(int fase)
	{
		esferasTorretas[fase].transform.localEulerAngles = new Vector3(0f, -90f, 0f);
		for (int i = 0; i < esferasTorretas[fase].transform.childCount; i++)
		{
			try
			{
				UnityEngine.Object.Destroy(esferasTorretas[fase].transform.GetChild(i).GetChild(0).gameObject);
			}
			catch
			{
			}
		}
		esferasTorreta.Clear();
		for (int j = 0; j < referenciaEsferasTorretas[fase].transform.childCount; j++)
		{
			Transform obj2 = PhotonNetwork.Instantiate("Prefabs/Esferas/esferametralleta", referenciaEsferasTorretas[fase].transform.GetChild(j).position, referenciaEsferasTorretas[fase].transform.GetChild(j).rotation, 0).transform;
			obj2.SetParent(esferasTorretas[fase].transform.GetChild(j));
			obj2.name = (j + 1).ToString();
			esferaTorreta component = obj2.GetComponent<esferaTorreta>();
			component.boss = this;
			esferasTorreta.Add(component);
			obj2.parent.gameObject.SetActive(value: false);
		}
	}

	public void EliminarEsfera(esferaTorreta esfera)
	{
		esferasTorreta.Remove(esfera);
		if (esferasTorreta.Count == 0)
		{
			CambiarFaseAVulnerable();
		}
	}

	public void DispararTorretas(int torreta)
	{
		try
		{
			esferasTorreta[torreta].Disparar();
		}
		catch
		{
		}
	}

	public void EncenderTorretas()
	{
		esferasTorretas[VecesGolpeado].SetActive(value: true);
		for (int i = 0; i < esferasTorreta.Count; i++)
		{
			esferasTorreta[i].transform.parent.gameObject.SetActive(value: true);
		}
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		poderGolpear = false;
		if (faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (VecesGolpeado >= 2 && golpesEnFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		StartCoroutine(TiempoPoderGolpear());
		if (golpesEnFase < golpesTotalesBoss)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			golpesEnFase++;
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		CambiarFaseAInvulnerable();
		if (VecesGolpeado == 0)
		{
			anim.SetTrigger("golpe1");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		VecesGolpeado++;
		prepararEsferasTorretaFaseBoss(VecesGolpeado);
		esferasRondaInvocadas = false;
		golpesEnFase = 0;
		risa = false;
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	public void DestruirEscudo()
	{
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		GameManager.instance.m_salaManager.nivelIniciado = false;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.1f);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.4f);
		GameManager.instance.m_salaManager.nivelIniciado = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		GameManager.instance.SetLogro(LogrosRecords.Logros.BossAustralia);
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void InvocarEsfera(int nivel)
	{
		Vector3 position = puntoSpawn.position;
		GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
		EsferaScript component = obj.GetComponent<EsferaScript>();
		component.CalcularColor();
		component.NivelDeBolaInicial = nivel;
		Vector3 vector = PartidaSync.instance.GetPlayerObjetivo().transform.position - bossMesh.position;
		UnityEngine.Debug.Log(vector);
		obj.GetComponent<EsferaScript>().dirInicial = Vector3.zero;
		obj.GetComponent<EsferaScript>().dir = vector / 3f;
		obj.SetActive(value: false);
		obj.SetActive(value: true);
	}

	private void ActivarRotacionOjo()
	{
		poderGirarOjo = true;
	}

	private void DesactivarRotacionOjo()
	{
		poderGirarOjo = false;
		giradoDeOjoLaser = true;
		posicionEnMomentoDeActivar = GameManager.instance.player.transform.position;
		modoLaser = true;
	}

	private void DesactivarRotacionOjoLaser()
	{
		giradoDeOjoLaser = false;
		poderGirarOjo = true;
	}

	private void PonerModoMovimiento()
	{
		if (faseActual != FasesBoss.Vulnerable)
		{
			risa = true;
			CambiarFaseEIniciarBoss();
		}
	}

	private void MArcarEsferasRondasInvocadas()
	{
		esferasRondaInvocadas = true;
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			Bala component = other.GetComponent<Bala>();
			if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
			{
				if ((bool)component)
				{
					component.TocaObjetoBonus();
					component.RebotarPlayer();
				}
			}
			else if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(1);
			}
			GolpearBoss(0);
		}
		else
		{
			if (!other.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				return;
			}
			GolpearBoss(1);
			Weapon componentInParent2 = other.gameObject.GetComponentInParent<Weapon>();
			if (!componentInParent2)
			{
				GanchoRifle componentInParent3 = other.gameObject.GetComponentInParent<GanchoRifle>();
				if ((bool)componentInParent3 && componentInParent3.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					componentInParent3.RebotarGancho();
				}
			}
			else
			{
				componentInParent2.RebotarGancho();
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			if (faseActual != FasesBoss.Vulnerable)
			{
				PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
				return;
			}
			GolpearBoss(1);
			collision.gameObject.GetComponentInParent<Weapon>().RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/boss1_miedo");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_venganza");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		throw new NotImplementedException();
	}

	private void QuitarInvunerable()
	{
		faseActual = FasesBoss.Movimiento;
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private void OnDestroy()
	{
		for (int i = 0; i < esferasTorreta.Count; i++)
		{
			if ((bool)esferasTorreta[i])
			{
				esferasTorreta[i].Destruir(inmediatamente: true);
			}
		}
	}
}
public class BossTeleport : BossBase
{
	private Vector3 velocidadSinTrucar = Vector3.zero;

	public Vector3 newScale = Vector3.zero;

	public Vector3 dir;

	private bool escudoActivo = true;

	public int VecesGolpeado;

	public int golpesEnFase;

	public GameObject esferaSpawn;

	public Transform bossMesh;

	private Rigidbody rb;

	public SphereCollider[] colider;

	public MeshRenderer mesh;

	public MeshRenderer escudoEsfera;

	public GameObject bossGolpeado;

	private Animator anim;

	public Transform puntoSpawn;

	private int animMovimiento;

	[HideInInspector]
	public Texture[] iconosEscudos;

	public ParticleSystem particulasExplosion;

	private bool vengoDeZonaOscura;

	private bool risa;

	public bool bossMejorado;

	public float velocidadAnimaciones = 1f;

	private float tiempoParaActivarLasTorretas;

	private float tiempoParaActivarEscudo;

	private bool modoLaser;

	private bool yaEstanMuertos;

	private Vector3 ultimoTamaño = Vector3.zero;

	private int rand;

	private bool poderGolpear = true;

	private Coroutine reiniciarNumeroDisparos;

	private Texture noiseEscudo;

	private Coroutine efectoDestruccionEscudo;

	private bool escudoNegro;

	private List<EsferaScript> poolEsferasNegras = new List<EsferaScript>();

	private bool esferasRondaInvocadas;

	private bool poderGirarOjo = true;

	private bool giradoDeOjoLaser;

	private Vector3 posicionEnMomentoDeActivar;

	private GameObject balaAcabaDeEntrar;

	protected override void Start()
	{
		base.Start();
		colider = GetComponents<SphereCollider>();
		rb = GetComponent<Rigidbody>();
		rb.isKinematic = true;
		bossMesh = base.transform.GetChild(0).GetChild(0);
		PonerEscudoNegro();
		if (photonView.IsMine)
		{
			golpesTotalesBoss = 3;
			if (PlayerProgreso.instance.rachaDerrotas >= 10)
			{
				golpesTotalesBoss -= 2;
			}
			else if (PlayerProgreso.instance.rachaDerrotas >= 5)
			{
				golpesTotalesBoss--;
			}
			NivelCompletado.instance.bossVivo = true;
			anim = GetComponent<Animator>();
			anim.SetTrigger("Entrada");
			newScale = base.transform.localScale;
			if (bossMejorado)
			{
				velocidadAnimaciones = 1f;
				golpesTotalesBoss = 2;
				anim.SetLayerWeight(anim.GetLayerIndex("Boss2"), 1f);
				anim.SetLayerWeight(anim.GetLayerIndex("Boss1"), 0f);
				anim.SetFloat("velocidad", velocidadAnimaciones);
			}
			else
			{
				anim.SetLayerWeight(anim.GetLayerIndex("Boss2"), 0f);
				anim.SetLayerWeight(anim.GetLayerIndex("Boss1"), 1f);
			}
		}
	}

	private void Update()
	{
		if (!photonView.IsMine)
		{
			return;
		}
		anim.SetFloat("velocidad", velocidadAnimaciones);
		if (faseActual == FasesBoss.Muerte)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = 0;
			if (yaEstanMuertos)
			{
				return;
			}
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].estaMuerto)
				{
					num++;
				}
			}
			if (num >= PartidaSync.instance.jugadores.Count)
			{
				anim.enabled = false;
				rb.isKinematic = true;
				yaEstanMuertos = true;
				return;
			}
		}
		else if (GameManager.instance.player.muerto)
		{
			anim.enabled = false;
			rb.isKinematic = true;
			return;
		}
		if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa || TimeManager.instance.tiempoMuerto)
		{
			rb.isKinematic = true;
			vengoDeZonaOscura = true;
			anim.enabled = false;
			return;
		}
		if (vengoDeZonaOscura)
		{
			anim.enabled = true;
			vengoDeZonaOscura = false;
			switch (faseActual)
			{
			case FasesBoss.Apareciendo:
				rb.isKinematic = true;
				break;
			case FasesBoss.Movimiento:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invulnerable:
				rb.isKinematic = true;
				break;
			case FasesBoss.Vulnerable:
				rb.isKinematic = false;
				break;
			case FasesBoss.Invocando:
				rb.isKinematic = false;
				break;
			case FasesBoss.Muerte:
				rb.isKinematic = true;
				break;
			}
		}
		if (GameManager.instance.m_salaManager.nivelIniciado && !nivelIniciado && !GameManager.instance.player.roomScale)
		{
			nivelIniciado = true;
			ActivarAnimacion();
		}
		Transform playerObjetivo = PartidaSync.instance.GetPlayerObjetivo();
		Vector3 forward = playerObjetivo.transform.position - bossMesh.position;
		bossMesh.rotation = Quaternion.Slerp(bossMesh.rotation, Quaternion.LookRotation(forward), Time.deltaTime * 10f);
		if (faseActual == FasesBoss.Apareciendo)
		{
			if (nivelIniciado)
			{
				return;
			}
			tickSinHacerCosasEsteticas++;
			if (tickSinHacerCosasEsteticas < 1)
			{
				return;
			}
			tickSinHacerCosasEsteticas = 0;
			base.transform.LookAt(playerObjetivo);
			if (contadorLevitacion >= 0)
			{
				contadorLevitacion++;
				if (contadorLevitacion > 60)
				{
					contadorLevitacion = -1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
			else
			{
				contadorLevitacion--;
				if (contadorLevitacion < -60)
				{
					contadorLevitacion = 1;
				}
				else
				{
					base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.07f * Time.deltaTime, base.transform.position.z);
				}
			}
		}
		else if (Debugs.debugs && Input.GetKeyDown(KeyCode.M))
		{
			CambiarFaseAVulnerable();
		}
	}

	public void CambiarTamañoEnd()
	{
		ultimoTamaño = base.transform.localScale;
	}

	public void CambiarTamañoStart()
	{
		if (ultimoTamaño != Vector3.zero)
		{
			base.transform.localScale = ultimoTamaño;
		}
	}

	private void CambiarFaseEIniciarBoss()
	{
		faseActual = FasesBoss.Movimiento;
		SeleccionarMovimientoBoss();
		PonerEscudoNegro();
	}

	private void CambiarFaseAVulnerable()
	{
		poderGolpear = true;
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Vulnerable;
		QuitarEscudo();
		golpesEnFase = 0;
		risa = true;
		TimeManager.instance.tiempoMenu = true;
	}

	private void CambiarFaseAInvulnerable()
	{
		tiempoParaActivarEscudo = 0f;
		faseActual = FasesBoss.Invulnerable;
		PonerEscudo();
		rb.isKinematic = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.Enfado);
	}

	private void CambiarFaseAMuerte()
	{
		anim.enabled = false;
		faseActual = FasesBoss.Muerte;
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		Morir();
	}

	private void SeleccionarMovimientoBoss()
	{
		animMovimiento = VecesGolpeado + 1;
		if (risa)
		{
			anim.SetTrigger("risa" + animMovimiento);
		}
		else
		{
			anim.SetTrigger("movimiento" + animMovimiento);
		}
	}

	private void SeleccionarPosisicionSpawn()
	{
		int num;
		for (num = UnityEngine.Random.Range(1, 5); num == rand; num = UnityEngine.Random.Range(1, 5))
		{
		}
		rand = num;
		anim.SetInteger("posicion", num);
	}

	private void PonerPosicionACero()
	{
		anim.SetInteger("posicion", 0);
	}

	private void CambiarAMovimentoSiTenemosEscudo()
	{
		if (!escudoDestruido)
		{
			CambiarFaseEIniciarBoss();
		}
	}

	protected override void BuscarReferencias()
	{
		tipoEscudo = Bola.TipoEscudo.balas;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[4]
		{
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1")
		};
	}

	public override void GolpearBoss(int num)
	{
		if (!photonView.IsMine || !poderGolpear)
		{
			return;
		}
		poderGolpear = false;
		if (faseActual != FasesBoss.Vulnerable)
		{
			return;
		}
		if (VecesGolpeado >= 2 && golpesEnFase >= golpesTotalesBoss)
		{
			CambiarFaseAMuerte();
			return;
		}
		StartCoroutine(TiempoPoderGolpear());
		if (golpesEnFase < golpesTotalesBoss)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
			golpesEnFase++;
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.muerte);
		faseActual = FasesBoss.Invulnerable;
		PonerEscudoNegro();
		if (VecesGolpeado == 0)
		{
			anim.SetTrigger("golpe");
		}
		else
		{
			anim.SetTrigger("golpe2");
		}
		VecesGolpeado++;
		esferasRondaInvocadas = false;
		golpesEnFase = 0;
		risa = false;
	}

	public int GetEstadoEscudo()
	{
		return numeroBalasEscudo;
	}

	public void GolpeoEscudo(int numGolpes = 1)
	{
		if (photonView.IsMine && faseActual == FasesBoss.Invulnerable && !escudoNegro)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoCorrecto);
			if (reiniciarNumeroDisparos != null)
			{
				StopCoroutine(reiniciarNumeroDisparos);
				reiniciarNumeroDisparos = null;
			}
			reiniciarNumeroDisparos = StartCoroutine(ReiniciarNumeroDisparosEscudo());
			numeroBalasEscudo += numGolpes;
			if (numeroBalasEscudo > 3)
			{
				DestruirEscudo();
				CambiarFaseAVulnerable();
				anim.SetTrigger("vulnerable");
			}
			else
			{
				escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
				escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f * (float)numeroBalasEscudo);
				StartCoroutine(PonerEscudoVertexOffseetInicio());
			}
		}
	}

	private IEnumerator PonerEscudoVertexOffseetInicio()
	{
		yield return new WaitForSeconds(0.5f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		if (faseActual == FasesBoss.Vulnerable)
		{
			numeroBalasEscudo = 0;
			reiniciarNumeroDisparos = null;
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
			escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		}
	}

	public override void PonerEscudo()
	{
		tipoEscudoParaOnline = 1;
		escudoNegro = false;
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_Fresnelcolor", GetFresnelColorShield());
		escudoEsfera.material.SetColor("_TintColor", GetBaseColorShield());
		escudoEsfera.material.SetTexture("_Noise", noiseEscudo);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.material.SetFloat("_Opacity", 1f);
		escudoDestruido = false;
		numeroBalasEscudo = 0;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo]);
		escudoEsfera.transform.localScale = Vector3.one * 1.3f;
	}

	public override void QuitarEscudo()
	{
		tipoEscudoParaOnline = 0;
		if ((bool)escudoEsfera && escudoEsfera.gameObject.activeInHierarchy)
		{
			escudoEsfera.gameObject.SetActive(value: false);
		}
	}

	public override int TieneEscudo()
	{
		return tipoEscudoParaOnline;
	}

	private IEnumerator TiempoPoderGolpear()
	{
		bossGolpeado.SetActive(value: true);
		yield return new WaitForSeconds(0.05f);
		poderGolpear = true;
		bossGolpeado.SetActive(value: false);
	}

	public void DestruirEscudo()
	{
		escudoNegro = false;
		PonerAudioEnAudioSource(ClipsAudioBoss.EscudoRoto);
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		SetGanchoEnganchado(enganchado: false);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		QuitarEscudo();
		escudoDestruido = true;
		efectoDestruccionEscudo = null;
	}

	public override void PonerEscudoNegro()
	{
		tipoEscudoParaOnline = 2;
		escudoNegro = true;
		if (!noiseEscudo)
		{
			noiseEscudo = escudoEsfera.material.GetTexture("_Noise");
		}
		escudoEsfera.gameObject.SetActive(value: true);
		escudoEsfera.material.SetColor("_TintColor", Color.black);
		escudoEsfera.material.SetColor("_Fresnelcolor", Color.black);
		escudoEsfera.material.SetFloat("_Opacity", 0.5f);
		escudoEsfera.material.SetTexture("_MainTex", texturaEscudoNegro);
		escudoEsfera.material.SetTexture("_Noise", null);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		escudoEsfera.transform.localScale = Vector3.one * 1.185f;
	}

	protected override IEnumerator AnimacionMorir()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				int num = 0;
				yaEstanMuertos = false;
				if (!yaEstanMuertos)
				{
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].estaMuerto)
						{
							num++;
						}
					}
					if (num >= PartidaSync.instance.jugadores.Count)
					{
						yield break;
					}
				}
			}
			else if (GameManager.instance.player.muerto)
			{
				yield break;
			}
			GetComponent<SyncBoss>().BossDerrotado();
		}
		GameManager.instance.player.inmune = true;
		GameManager.instance.m_salaManager.nivelIniciado = false;
		base.transform.GetChild(1).gameObject.SetActive(value: false);
		particulasExplosion.gameObject.SetActive(value: true);
		particulasExplosion.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = true;
		rb.constraints = RigidbodyConstraints.None;
		rb.mass = 10f;
		rb.AddTorque(Vector3.one * -1f, ForceMode.Impulse);
		yield return new WaitForSeconds(0.1f);
		PoolObjetos.instance.EliminarTodosLosObjetos();
		yield return new WaitForSeconds(0.4f);
		GameManager.instance.m_salaManager.nivelIniciado = true;
		PonerAudioEnAudioSource(ClipsAudioBoss.victoria);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(2f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 2f, 1);
		yield return new WaitForSeconds(2f);
		try
		{
			if (bossMejorado)
			{
				GameManager.instance.SetLogro(LogrosRecords.Logros.BossCanada);
			}
			else
			{
				GameManager.instance.SetLogro(LogrosRecords.Logros.BossKorea);
			}
		}
		catch
		{
		}
		NivelCompletado.instance.bossVivo = false;
		NivelCompletado.instance.RestarEsfera(null);
	}

	private void InvocarEsfera(int nivel)
	{
		if (!esferasRondaInvocadas)
		{
			Vector3 position = puntoSpawn.position;
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, position, Quaternion.identity, null, 1);
			obj.GetComponent<EsferaScript>().NivelDeBolaInicial = 2;
			obj.GetComponent<EsferaScript>().dir = puntoSpawn.forward;
			obj.SetActive(value: false);
			obj.SetActive(value: true);
		}
	}

	private void ActivarRotacionOjo()
	{
		poderGirarOjo = true;
	}

	private void DesactivarRotacionOjo()
	{
		poderGirarOjo = false;
		giradoDeOjoLaser = true;
		posicionEnMomentoDeActivar = GameManager.instance.player.transform.position;
		modoLaser = true;
	}

	private void DesactivarRotacionOjoLaser()
	{
		giradoDeOjoLaser = false;
		poderGirarOjo = true;
	}

	private void PonerModoMovimiento()
	{
		if (faseActual != FasesBoss.Vulnerable)
		{
			risa = true;
			CambiarFaseEIniciarBoss();
		}
	}

	private void MArcarEsferasRondasInvocadas()
	{
		esferasRondaInvocadas = true;
	}

	public override void Morir()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.seAcabanDePasarElBoss = true;
		}
		muerto = true;
		GameManager.instance.paisActual++;
		NivelCompletado.instance.Desbloquear();
		GameManager.instance.paisActual--;
		StartCoroutine(AnimacionMorir());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Weapon componentInParent = other.GetComponentInParent<Weapon>();
			if ((bool)componentInParent && (componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano || componentInParent.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano) && !GameManager.instance.player.muerto)
			{
				if (muerto)
				{
					return;
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, componentInParent.miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			return;
		}
		if (!escudoDestruido && tipoEscudo == Bola.TipoEscudo.balas && faseActual == FasesBoss.Invulnerable)
		{
			GameObject gameObject = other.gameObject;
			if (!(balaAcabaDeEntrar != gameObject))
			{
				return;
			}
			balaAcabaDeEntrar = gameObject;
			Bala component = other.GetComponent<Bala>();
			SyncBala syncBala = null;
			if (!component)
			{
				syncBala = other.GetComponent<SyncBala>();
			}
			if (!photonView.IsMine)
			{
				return;
			}
			int num = (component ? component.GetNumUsosRestantes() : syncBala.numUsos);
			int num2 = 1;
			int estadoEscudo = GetEstadoEscudo();
			if (estadoEscudo > 0)
			{
				num2 = num;
				if (num2 > estadoEscudo)
				{
					num2 = estadoEscudo;
				}
			}
			GolpeoEscudo(num2);
			if ((bool)component)
			{
				component.TocaObjetoBonus();
				component.EfectoDesaparecer(num2);
			}
			return;
		}
		PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
		Bala component2 = other.GetComponent<Bala>();
		if (faseActual != FasesBoss.Vulnerable && faseActual != FasesBoss.Muerte)
		{
			if (faseActual == FasesBoss.Invulnerable && !escudoDestruido)
			{
				if ((bool)component2)
				{
					component2.TocaObjetoBonus();
					component2.EfectoDesaparecer(1);
				}
			}
			else if ((bool)component2)
			{
				component2.TocaObjetoBonus();
				component2.RebotarPlayer();
			}
		}
		else if ((bool)component2)
		{
			component2.TocaObjetoBonus();
			component2.EfectoDesaparecer(1);
		}
		GolpearBoss(0);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			return;
		}
		if (faseActual != FasesBoss.Vulnerable)
		{
			PonerAudioEnAudioSource(ClipsAudioBoss.GolpeEscudoIncorrecto);
			return;
		}
		GolpearBoss(1);
		Weapon componentInParent = collision.gameObject.GetComponentInParent<Weapon>();
		if (!componentInParent)
		{
			GanchoRifle componentInParent2 = collision.gameObject.GetComponentInParent<GanchoRifle>();
			if ((bool)componentInParent2 && componentInParent2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
			{
				componentInParent2.RebotarGancho();
			}
		}
		else
		{
			componentInParent.RebotarGancho();
		}
	}

	protected override void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/risa_boss");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/enfado_boss");
		audioClipsBoss[3] = Resources.Load<AudioClip>("EfectosSonido/boss_escupirEsfera");
		audioClipsBoss[4] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[5] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
		audioClipsBoss[7] = Resources.Load<AudioClip>("EfectosSonido/muerte_boss");
		audioClipsBoss[8] = Resources.Load<AudioClip>("EfectosSonido/Musica/victoria_boss2");
		audioClipsBoss[9] = Resources.Load<AudioClip>("EfectosSonido/holograma_abrir");
		audioClipsBoss[10] = Resources.Load<AudioClip>("EfectosSonido/boss_teleport");
		audioClipsBoss[11] = Resources.Load<AudioClip>("EfectosSonido/boss_ImpactoOK2");
		audioClipsBoss[12] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
	}

	public override void InvocarEsferas(int numEsferas, int nivelEsferas)
	{
		throw new NotImplementedException();
	}

	private void QuitarInvunerable()
	{
		faseActual = FasesBoss.Movimiento;
	}
}
public class Boton : MonoBehaviour
{
	public Ascensor ascensor;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Mano")
		{
			ActivarBoton();
		}
	}

	private void ActivarBoton()
	{
		base.transform.localScale = new Vector3(base.transform.localScale.x, 0.01f, base.transform.localScale.z);
		if (ascensor.parado)
		{
			ascensor.CerrarPuerta();
		}
	}

	public void DesactivarBoton()
	{
		base.transform.localScale = new Vector3(base.transform.localScale.x, 0.04f, base.transform.localScale.z);
	}
}
public class BotonInGame : BotonMenu
{
	public bool botonesMute;

	private Coroutine anim;

	private float antimonkey;

	private void Awake()
	{
	}

	public override void AccionBoton()
	{
		StartCoroutine(Accion());
	}

	private IEnumerator Accion()
	{
		GetComponent<AudioSource>().Play();
		yield return new WaitForSeconds(0.2f);
		accionBoton.Invoke();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (botonesMute && (other.name == "ManoDerecha" || other.name == "ManoIzquierda") && antimonkey + 1f < Time.time)
		{
			AccionBoton();
			antimonkey = Time.time;
		}
	}

	private void OnDisable()
	{
		SetFoco(foco: false);
	}
}
public class BotonMenu : MonoBehaviour
{
	public UnityEvent accionBoton;

	public AudioClip sonido;

	protected ControladorMenu m_controladorMenu;

	public bool bloqueado;

	public GameObject sinFoco;

	public GameObject conFoco;

	public GameObject bloqueo;

	private Coroutine anim;

	public bool botonDeCerrar;

	private void Awake()
	{
		m_controladorMenu = GameObject.Find("ControladorMenu").GetComponent<ControladorMenu>();
	}

	public virtual void EjecutarAccion()
	{
		accionBoton.Invoke();
	}

	public void SetFoco(bool foco)
	{
		if ((bool)conFoco)
		{
			conFoco.SetActive(foco);
		}
	}

	public virtual void AccionBoton()
	{
		if (!GameManager.instance.bloquearBotones && conFoco.activeInHierarchy && anim == null)
		{
			anim = StartCoroutine(AnimacionSeleccion());
		}
	}

	private IEnumerator AnimacionSeleccion()
	{
		if ((bool)m_controladorMenu)
		{
			m_controladorMenu.audioSourceMenu.clip = sonido;
			m_controladorMenu.audioSourceMenu.loop = false;
			m_controladorMenu.audioSourceMenu.Play();
			for (float j = 0f; j < 0.5f; j += Time.deltaTime * 7f)
			{
				conFoco.transform.localScale = new Vector3(conFoco.transform.localScale.x + 0.01f, conFoco.transform.localScale.y + 0.01f, conFoco.transform.localScale.z + 0.01f);
				sinFoco.transform.localScale = new Vector3(sinFoco.transform.localScale.x + 0.01f, sinFoco.transform.localScale.y + 0.01f, sinFoco.transform.localScale.z + 0.01f);
				yield return null;
			}
			for (float j = 0f; j < 0.5f; j += Time.deltaTime * 7f)
			{
				conFoco.transform.localScale = new Vector3(conFoco.transform.localScale.x - 0.01f, conFoco.transform.localScale.y - 0.01f, conFoco.transform.localScale.z - 0.01f);
				sinFoco.transform.localScale = new Vector3(sinFoco.transform.localScale.x - 0.01f, sinFoco.transform.localScale.y - 0.01f, sinFoco.transform.localScale.z - 0.01f);
				yield return null;
			}
			conFoco.transform.localScale = new Vector3(1.25f, 1f, 1f);
			sinFoco.transform.localScale = new Vector3(1.25f, 1f, 1f);
		}
		anim = null;
		accionBoton.Invoke();
	}

	private void OnEnable()
	{
		if (botonDeCerrar)
		{
			m_controladorMenu.AccionCerrarActual = accionBoton;
		}
	}

	private void OnDisable()
	{
		if (botonDeCerrar && m_controladorMenu.AccionCerrarActual == accionBoton)
		{
			m_controladorMenu.AccionCerrarActual = null;
		}
		SetFoco(foco: false);
	}
}
public class BotonNivel : BotonMenu
{
	public AudioClip sonidoBlock;

	public int nivel;

	private Coroutine anim;

	private void OnEnable()
	{
		VerSiEstaBloqueado();
	}

	private void VerSiEstaBloqueado()
	{
		if (!Debugs.nivelesDesbloqueados)
		{
			if (PlayerProgreso.instance.ultimoPaisPasado > GameManager.instance.paisActual)
			{
				bloqueado = false;
				bloqueo.SetActive(value: false);
			}
			else if (PlayerProgreso.instance.ultimoNivelPasado < nivel)
			{
				bloqueado = true;
				bloqueo.SetActive(value: true);
			}
			else
			{
				bloqueado = false;
				bloqueo.SetActive(value: false);
			}
		}
	}

	public override void AccionBoton()
	{
		if (bloqueado)
		{
			m_controladorMenu.audioSourceMenu.clip = sonidoBlock;
			m_controladorMenu.audioSourceMenu.loop = false;
			m_controladorMenu.audioSourceMenu.Play();
		}
		else
		{
			base.AccionBoton();
		}
	}
}
public class BotonPais : BotonMenu
{
	public AudioClip sonidoBlock;

	public AudioClip sonidoDesblock;

	public int pais;

	public bool final;

	public GameObject botonLeaderBoard;

	private Coroutine anim;

	private void OnEnable()
	{
		if (!final)
		{
			VerSiEstaBloqueado();
			bool flag = Config.plataforma == Config.PlataformaJuego.SteamVR || Config.plataforma == Config.PlataformaJuego.Oculus || Config.plataforma != Config.PlataformaJuego.PS4;
			if (Config.plataforma == Config.PlataformaJuego.SteamVR && Config.versionConSteamCompletamenteAnulado)
			{
				flag = false;
			}
			if ((!flag || !LogrosRecords.instance) && (bool)botonLeaderBoard)
			{
				botonLeaderBoard.SetActive(value: false);
			}
		}
	}

	private void VerSiEstaBloqueado()
	{
		if (Debugs.nivelesDesbloqueados)
		{
			bloqueado = false;
			bloqueo.SetActive(value: false);
			if (pais != -1 && (bool)botonLeaderBoard)
			{
				botonLeaderBoard.SetActive(value: true);
			}
		}
		else if (pais == 0 && PersistentDataManager.GetInt("IntroVista") == 0)
		{
			bloqueado = true;
			bloqueo.SetActive(value: true);
			if ((bool)botonLeaderBoard)
			{
				botonLeaderBoard.SetActive(value: false);
			}
		}
		else if (PlayerProgreso.instance.ultimoPaisPasado < pais)
		{
			bloqueado = true;
			bloqueo.SetActive(value: true);
			if ((bool)botonLeaderBoard)
			{
				botonLeaderBoard.SetActive(value: false);
			}
		}
		else if (PlayerProgreso.instance.ultimoPaisPasado == pais && GameManager.instance.nuevoPaisDesloqueado)
		{
			GameManager.instance.nuevoPaisDesloqueado = false;
			bloqueado = true;
			bloqueo.SetActive(value: true);
			if ((bool)botonLeaderBoard)
			{
				botonLeaderBoard.SetActive(value: false);
			}
			StartCoroutine(AnimacionDesbloqueo());
		}
	}

	private IEnumerator AnimacionDesbloqueo()
	{
		yield return new WaitForSeconds(0.5f);
		m_controladorMenu.audioSourceMenu.clip = sonidoDesblock;
		m_controladorMenu.audioSourceMenu.loop = false;
		m_controladorMenu.audioSourceMenu.Play();
		Image esfera = bloqueo.transform.GetChild(0).GetComponent<Image>();
		Color colorEsfera = esfera.color;
		Image cuadrado = bloqueo.transform.GetChild(1).GetComponent<Image>();
		Color colorCuadrado = cuadrado.color;
		Image candado = bloqueo.transform.GetChild(2).GetComponent<Image>();
		Color colorCandado = candado.color;
		RectTransform recTransformCandado = candado.GetComponent<RectTransform>();
		for (int i = 0; i < 120; i++)
		{
			colorEsfera.a -= 0.01f;
			colorCuadrado.a -= 0.01f;
			colorCandado.a -= 0.01f;
			esfera.color = colorEsfera;
			cuadrado.color = colorCuadrado;
			candado.color = colorCandado;
			candado.transform.localScale = new Vector3(candado.transform.localScale.x + 0.02f, candado.transform.localScale.y + 0.02f, candado.transform.localScale.z + 0.02f);
			recTransformCandado.localPosition = new Vector3(recTransformCandado.localPosition.x, recTransformCandado.localPosition.y + 0.02f, recTransformCandado.localPosition.z);
			yield return null;
		}
		bloqueado = false;
		bloqueo.SetActive(value: false);
		yield return null;
	}

	public override void AccionBoton()
	{
		if (bloqueado)
		{
			m_controladorMenu.audioSourceMenu.clip = sonidoBlock;
			m_controladorMenu.audioSourceMenu.loop = false;
			m_controladorMenu.audioSourceMenu.Play();
		}
		else
		{
			base.AccionBoton();
		}
	}
}
public class CabezaRoomSccale : MonoBehaviour
{
	private List<Collider> estaDentroDeLosLimites = new List<Collider>();

	[HideInInspector]
	public bool estaFuera;

	private Camera[] cams;

	public LayerMask layerNormal;

	public LayerMask layerLimites;

	public GameObject cuboGrandeLimites;

	public GameObject flecha;

	public GameObject pistolasFake;

	private float ticksSinDesactivar;

	public GameObject ColliderHabitacion;

	private void Start()
	{
		cams = GetComponentsInChildren<Camera>();
		ticksSinDesactivar = -100f;
		if ((bool)GameManager.instance.player)
		{
			GameManager.instance.player.cabezaRoomScaleScript = this;
		}
		else
		{
			StartCoroutine(EsperarAPlayer());
		}
	}

	private void OnEnable()
	{
		if ((bool)GameManager.instance.player)
		{
			GameManager.instance.player.cabezaRoomScaleScript = this;
		}
		else
		{
			StartCoroutine(EsperarAPlayer());
		}
	}

	private IEnumerator EsperarAPlayer()
	{
		while (!GameManager.instance.player)
		{
			yield return null;
		}
		GameManager.instance.player.cabezaRoomScaleScript = this;
	}

	private void OnDisable()
	{
		estaDentroDeLosLimites.Clear();
		ticksSinDesactivar = 0f;
	}

	private void Update()
	{
		if (ticksSinDesactivar > 60f && estaDentroDeLosLimites.Count == 0 && !estaFuera)
		{
			ActivarFueraDeLimites();
		}
		ticksSinDesactivar += 1f;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(GameManager.instance.tagPistola))
		{
			if (ticksSinDesactivar > 60f && estaDentroDeLosLimites.Count > 0 && estaFuera)
			{
				DesactivarFueraDeLimites();
			}
		}
		else if (!estaDentroDeLosLimites.Contains(other))
		{
			estaDentroDeLosLimites.Add(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (estaDentroDeLosLimites.Contains(other))
		{
			estaDentroDeLosLimites.Remove(other);
		}
	}

	public void DesactivarLimite()
	{
		ticksSinDesactivar = 0f;
		if (estaFuera)
		{
			DesactivarFueraDeLimites();
		}
	}

	private IEnumerator DesactivarEnXseg()
	{
		yield return new WaitForSeconds(1f);
		DesactivarFueraDeLimites();
	}

	private void ActivarFueraDeLimites()
	{
		estaFuera = true;
		GameManager.instance.player.fueraDeLimites = true;
		cuboGrandeLimites.transform.SetParent(null);
		cuboGrandeLimites.SetActive(value: true);
		Camera[] array = cams;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].cullingMask = layerLimites;
		}
		if ((bool)GameManager.instance.liv)
		{
			GameManager.instance.liv.SpectatorLayerMask = layerLimites;
		}
		flecha.SetActive(value: true);
		pistolasFake.SetActive(value: true);
		pistolasFake.transform.SetParent(GameManager.instance.player.pistolasPadreRoomScale);
		pistolasFake.transform.position = GameManager.instance.player.pistolasPadreRoomScale.position;
		pistolasFake.transform.rotation = GameManager.instance.player.pistolasPadreRoomScale.rotation;
		pistolasFake.transform.localScale = Vector3.one;
	}

	public void DesactivarFueraDeLimites()
	{
		Camera[] array = cams;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].cullingMask = layerNormal;
		}
		if ((bool)GameManager.instance.liv)
		{
			GameManager.instance.liv.SpectatorLayerMask = -1;
		}
		cuboGrandeLimites.SetActive(value: false);
		flecha.SetActive(value: false);
		pistolasFake.SetActive(value: false);
		estaFuera = false;
		GameManager.instance.player.fueraDeLimites = false;
	}

	public void DesactivarActivarColliderHabitacion(bool accion)
	{
		try
		{
			ColliderHabitacion.SetActive(accion);
		}
		catch
		{
		}
	}

	public void ComprobarSiEstaDentro()
	{
		if (estaDentroDeLosLimites.Count == 0 && !estaFuera)
		{
			ActivarFueraDeLimites();
		}
	}
}
public class CalidadManager : MonoBehaviour
{
	public enum Calidad
	{
		Baja,
		Normal,
		Alta
	}

	public Calidad calidadActual;

	public static CalidadManager instance;

	private void Awake()
	{
		instance = this;
		Time.fixedDeltaTime = 0.0138f;
		Time.maximumParticleDeltaTime = 0.3f;
		Time.maximumDeltaTime = 0.0138f;
		SetCalidad(GetCalidadRecomendada());
	}

	public Calidad GetCalidadRecomendada()
	{
		return Calidad.Baja;
	}

	public Calidad GetCalidad()
	{
		return calidadActual;
	}

	public void SetCalidad(Calidad calidad)
	{
		calidadActual = GetCalidadRecomendada();
		AplicarCalidad();
	}

	public void AplicarCalidad()
	{
		calidadActual = GetCalidadRecomendada();
		switch (calidadActual)
		{
		case Calidad.Baja:
			QualitySettings.SetQualityLevel(0);
			break;
		case Calidad.Normal:
			QualitySettings.SetQualityLevel(1);
			break;
		case Calidad.Alta:
			QualitySettings.SetQualityLevel(2);
			break;
		}
		PersistentDataManager.SetInt("Calidad", (int)calidadActual);
	}
}
public class CamaraBlancoNegro : MonoBehaviour
{
	private Material m_mat;

	public Texture m_overlay;

	public Shader m_shader;

	private Camera cam;

	private void Awake()
	{
		m_shader = Shader.Find("Custom/BlancoNegro");
		cam = GetComponent<Camera>();
		base.enabled = false;
	}

	private void OnRenderImage(RenderTexture _src, RenderTexture _dest)
	{
		if (!m_mat)
		{
			m_mat = new Material(m_shader);
		}
		m_mat.SetTexture("_Mask", _src);
		Graphics.Blit(_src, _dest, m_mat);
	}

	private void OnDisable()
	{
		DestroyMaterial();
	}

	private void OnDestroy()
	{
		base.enabled = true;
	}

	private void DestroyMaterial()
	{
		if ((bool)m_mat)
		{
			UnityEngine.Object.DestroyImmediate(m_mat);
			m_mat = null;
		}
	}

	public void SetActivation(bool _enable)
	{
		base.enabled = _enable;
	}
}
public class CambiarMaterial : MonoBehaviour
{
	private void Start()
	{
		GetComponent<MeshRenderer>().material.SetTexture("_MainTex", RenderSettings.skybox.GetTexture("_RightTex"));
	}
}
public class CambiarMateriales : MonoBehaviour
{
	public Material low_mat;

	public MeshRenderer renderer;

	public CalidadManager.Calidad calidadMinima;

	private bool cambiado;

	private void Awake()
	{
		if (!cambiado && CalidadManager.instance.GetCalidad() <= calidadMinima)
		{
			if (!renderer)
			{
				renderer = GetComponent<MeshRenderer>();
			}
			renderer.material = low_mat;
			cambiado = true;
		}
	}

	public void Init()
	{
		if (!cambiado && CalidadManager.instance.GetCalidad() <= calidadMinima)
		{
			if (!renderer)
			{
				renderer = GetComponent<MeshRenderer>();
			}
			renderer.material = low_mat;
			cambiado = true;
		}
	}
}
public class Config : MonoBehaviour
{
	public enum ModosDeJuego
	{
		Offline,
		Online,
		menu
	}

	public enum ModoDePartida
	{
		Solo,
		Cooperativo,
		Competitivo
	}

	public enum TipoControl
	{
		UnaMano,
		DosManos
	}

	public enum PlataformaJuego
	{
		SteamVR,
		PS4,
		Oculus,
		Pico,
		Nolo,
		ninguna
	}

	public static PlataformaJuego plataforma = PlataformaJuego.Oculus;

	public static bool versionConSteamCompletamenteAnulado = true;

	public static bool verisionConOnlineCompletamenteAnulado = false;

	public static bool cooperativoAnuladoForzosamente = false;

	public static bool arenaAnuladoForzosamente = false;

	public static bool modoDemo = false;

	public static bool esQuest = true;

	public static bool esGO = false;

	public static string mundo = "";

	public static int numJugadoresOnline = 0;

	public static ModosDeJuego modoDeJuego = ModosDeJuego.Offline;

	public static ModoDePartida modoDePartida = ModoDePartida.Cooperativo;

	public static TipoControl tipoDeControl = TipoControl.UnaMano;

	public static bool tiene2Sensores = true;

	public static bool zurdo = false;

	public static bool hayTracker = false;

	public static bool ModoCooperativo()
	{
		if (modoDeJuego == ModosDeJuego.Online)
		{
			return modoDePartida == ModoDePartida.Cooperativo;
		}
		return false;
	}
}
public class ControlInfoServidor : MonoBehaviour
{
	[Serializable]
	public struct InfoServidor
	{
		public enum EstatusOnlineServer
		{
			NoInicializado,
			Offline,
			Online
		}

		public EstatusOnlineServer estatusOnlineServer;

		public string infoStatusOnline;

		public int versionActual;

		public int versionActualObligatoria;

		public int versionQueHaPasadoRevision;
	}

	[HideInInspector]
	public UnityEvent onInfoConseguida;

	public UnityEvent onInfoJugadoresOnlineConseguida;

	public UnityEvent onImagenCargada;

	public UnityEvent onPromocodeComprobado;

	private string[] serverData;

	private string[] datosTorneoRaw;

	private string[] datosNoticiaRaw;

	private string datosStatusOnlineRaw;

	private string[] datosVersionRaw;

	public bool datosObtenidosOk;

	public InfoServidor infoServidor;

	public string[] datosJugadoresOnline;

	private float tiempoEntrePedidas;

	private void CargarInfoDeArchivo()
	{
		string path = UnityEngine.Application.temporaryCachePath + "/TK_serverInfo.dat";
		if (File.Exists(path))
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Open(path, FileMode.Open);
			infoServidor = (InfoServidor)binaryFormatter.Deserialize(fileStream);
			fileStream.Close();
		}
	}

	private void GuardarInfoEnArchivo()
	{
		string path = UnityEngine.Application.temporaryCachePath + "/TK_serverInfo.dat";
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Create(path);
		binaryFormatter.Serialize(fileStream, infoServidor);
		fileStream.Close();
	}

	private void DameStatusOnline()
	{
		if (datosStatusOnlineRaw.Contains("~"))
		{
			string[] array = datosStatusOnlineRaw.Split('~');
			datosStatusOnlineRaw = array[0];
			infoServidor.infoStatusOnline = array[1];
		}
		if (datosStatusOnlineRaw == "-1")
		{
			infoServidor.estatusOnlineServer = InfoServidor.EstatusOnlineServer.Offline;
		}
		else if (datosStatusOnlineRaw == "OFF")
		{
			infoServidor.estatusOnlineServer = InfoServidor.EstatusOnlineServer.Offline;
		}
		else
		{
			infoServidor.estatusOnlineServer = InfoServidor.EstatusOnlineServer.Online;
		}
	}

	private void DameVersiones()
	{
		infoServidor.versionActual = int.Parse(datosVersionRaw[0]);
		if (infoServidor.versionActual >= 0)
		{
			infoServidor.versionActualObligatoria = int.Parse(datosVersionRaw[1]);
		}
		if (datosVersionRaw.Length > 2)
		{
			infoServidor.versionQueHaPasadoRevision = int.Parse(datosVersionRaw[2]);
		}
		else
		{
			infoServidor.versionQueHaPasadoRevision = -1;
		}
	}

	public ControladorMenu.EstadoOnline DameEstadoOnline()
	{
		if (infoServidor.estatusOnlineServer == InfoServidor.EstatusOnlineServer.NoInicializado || infoServidor.estatusOnlineServer == InfoServidor.EstatusOnlineServer.Offline)
		{
			return ControladorMenu.EstadoOnline.ServerOff;
		}
		_ = infoServidor.estatusOnlineServer;
		_ = 2;
		return ControladorMenu.EstadoOnline.Activo;
	}
}
public class ControladorMano : MonoBehaviour
{
	public enum ClipsAudioMano
	{
		Lanzar,
		Atraer,
		Coger,
		TransformarAGancho,
		PowerUp,
		TransformarAPistola,
		Cont
	}

	public enum EstadoDeLaMano
	{
		EstadoInicialSinArma,
		PistolaEnMano,
		GanchoEnMano,
		GanchoLanzandose,
		GanchoPuedeRetornar,
		GanchoVolviendo
	}

	public enum Mano
	{
		Derecha,
		Izquierda
	}

	[HideInInspector]
	public InputsController inputs;

	public GameObject arma;

	public GameObject rifle;

	public GameObject puntoPosicion;

	public GameObject mano3D;

	public GameObject handModel;

	public GameObject laserModel;

	private AudioClip[] audioClipsMano = new AudioClip[6];

	private AudioSource[] audioSources;

	[HideInInspector]
	public Arma armaScript;

	[HideInInspector]
	public bool afectandoTiempo;

	[HideInInspector]
	public ControladorMano otherHand;

	public float fuerzaAlLanzar;

	private Rigidbody weaponRb;

	private Vector3[] posVector = new Vector3[6];

	private int pos;

	public AnimManos animManos;

	public AnimTransformPistola animWeapon;

	private float miValorTrigger;

	private float miValorGrip;

	private float miValorVelocidadValido;

	public bool bTriggerEstaAhoraPulsado;

	public bool bTriggerDown;

	public bool bTriggerUp;

	public bool bGripEstaAhoraPulsado;

	public bool bGripDown;

	public bool bGripUp;

	private bool tirandoPorVelocidad;

	public Vector3 armaImpulsandose;

	public Transform flecha;

	private GameObject panelTutorial;

	public LineRenderer laser;

	public Transform laserDedo;

	public EstadoDeLaMano estadoDeLaMano;

	public Mano mano;

	public ManosRoomScale manoRoomScale;

	public Transform puntoDedo;

	public ControladorManoSecundariaRifle controladorManoSecundariaRifle;

	private const float VELOCIDAD_LANZAMIENTO = 2.5f;

	private InputsController.TipoSensores tipoSensorEnStart;

	private EstadoDeLaMano antiguoEstadoMano;

	private bool disparar;

	private bool dispararGancho;

	private float timeGancho;

	private float timePistola;

	private bool primerTriggerSoltado;

	private bool acaboDeCambiarDeGanchoAPistola;

	private bool forzarLanzar;

	[HideInInspector]
	public bool cogidaConElGrip;

	private Vector3 velocidadMano;

	private Vector3 posOldOld = Vector3.zero;

	private Vector3 posOld = Vector3.zero;

	private bool heHechoCAmbioDeArma;

	private float cooldownTiempoCambioConGripUnaMano;

	private Vector3 primeraRotacionModelo3DMano = Vector3.zero;

	private Vector3 primeraPosicionModelo3DMano = Vector3.zero;

	private float sumadorRotacionExtraGancho;

	private float sumadorPosicionExtraGancho;

	private float tDeltaCambiarAGancho;

	private float ticksDesdeQueCojoArma;

	private bool scalaModificada;

	private Coroutine buscarEsferaMasCercanaDerecha;

	private Coroutine buscarEsferaMasCercanaIzquierda;

	public Transform esferaMasCercana;

	public TextMeshPro distancia;

	private bool inmortal_DEBUG;

	private bool mostrandoMensaje;

	private float tiempoEspera = 0.5f;

	[HideInInspector]
	public ControladorSonidosMensajes audioSourcePanelChica;

	private void Start()
	{
		if (Config.modoDeJuego != Config.ModosDeJuego.menu && Config.tipoDeControl == Config.TipoControl.UnaMano)
		{
			UnityEngine.Object.Destroy(arma);
			arma = rifle;
		}
		else if ((bool)rifle)
		{
			UnityEngine.Object.Destroy(rifle);
		}
		if ((bool)arma)
		{
			armaScript = arma.GetComponent<Arma>();
		}
		if (Config.modoDeJuego != Config.ModosDeJuego.menu && Config.tipoDeControl == Config.TipoControl.UnaMano)
		{
			if (!Config.tiene2Sensores && Debugs.SimularPlayer == 0 && ((Config.zurdo && mano == Mano.Derecha) || (!Config.zurdo && mano == Mano.Izquierda)))
			{
				UnityEngine.Object.Destroy(this);
				base.gameObject.SetActive(value: false);
				return;
			}
			controladorManoSecundariaRifle = base.transform.gameObject.AddComponent<ControladorManoSecundariaRifle>();
			controladorManoSecundariaRifle.mano = mano;
			controladorManoSecundariaRifle.empuñadura = armaScript.rifleScript.puntoManoSecundaria;
			controladorManoSecundariaRifle.rifle = armaScript.rifleScript;
			controladorManoSecundariaRifle.mano3dMia = mano3D.transform;
			if ((bool)otherHand)
			{
				controladorManoSecundariaRifle.mano3dOtro = otherHand.mano3D.transform;
				controladorManoSecundariaRifle.otraMano = otherHand.transform;
			}
			if ((!Config.zurdo && mano == Mano.Izquierda) || (Config.zurdo && mano == Mano.Derecha))
			{
				base.enabled = false;
			}
			else
			{
				controladorManoSecundariaRifle.enabled = false;
				armaScript.miMano = this;
			}
		}
		tirandoPorVelocidad = false;
		CambiarEstadoMano(EstadoDeLaMano.EstadoInicialSinArma);
		animManos = GetComponentInChildren<AnimManos>();
		inputs = base.transform.parent.GetComponent<InputsController>();
		weaponRb = arma.GetComponent<Rigidbody>();
		pos = 0;
		afectandoTiempo = false;
		laser = flecha.GetChild(0).GetChild(0).GetComponent<LineRenderer>();
		panelTutorial = flecha.parent.GetChild(4).gameObject;
		CargarClipsAudio();
		audioSources = base.transform.Find("AudioSources").GetComponents<AudioSource>();
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			flecha.transform.parent.gameObject.SetActive(value: false);
			if ((bool)animManos)
			{
				animManos.MenuSeñalar();
			}
		}
		else
		{
			flecha.transform.parent.gameObject.SetActive(value: true);
		}
		float num = 25f;
		tipoSensorEnStart = GameManager.instance.tipoDeSensores;
		if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.index)
		{
			num += 30f;
		}
		else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
		{
			num += 35f;
		}
		else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.nolo && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			num += 40f;
		}
		mano3D.transform.localEulerAngles = new Vector3(-8.073f + num, -0.367f, -1.942f);
		if (mano == Mano.Izquierda)
		{
			panelTutorial.transform.localScale = new Vector3(panelTutorial.transform.localScale.x * -1f, panelTutorial.transform.localScale.y, panelTutorial.transform.localScale.z);
		}
		CargarReferenciasPanelChica();
	}

	public float GetValorTrigger()
	{
		miValorTrigger = inputs.triggerDerecho;
		if (mano == Mano.Izquierda)
		{
			miValorTrigger = inputs.triggerIzquierdo;
		}
		return miValorTrigger;
	}

	public float GetValorGrip()
	{
		miValorGrip = inputs.gripDerecho;
		if (mano == Mano.Izquierda)
		{
			miValorGrip = inputs.gripIzquierdo;
		}
		return miValorGrip;
	}

	private void OnTriggerStay(Collider other)
	{
		bool flag = other.gameObject.CompareTag(GameManager.instance.tagParedMovible);
		if (estadoDeLaMano != EstadoDeLaMano.GanchoEnMano && !GameManager.instance.player.muerto && (bool)GameManager.instance.m_salaManager && GameManager.instance.m_salaManager.nivelIniciado && (other.CompareTag(GameManager.instance.tagEsfera) || flag || other.gameObject.layer == GameManager.instance.layerMina))
		{
			if (flag && GameManager.instance.player.GetInmortalidad())
			{
				GameManager.instance.player.QuitarInmortalidad();
			}
			PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
			GameManager.instance.player.Morir(flag ? null : other.gameObject, forzarMuerte: false, porCabeza: false, mano == Mano.Derecha);
		}
		else if (estadoDeLaMano == EstadoDeLaMano.EstadoInicialSinArma)
		{
			if (weaponRb == null)
			{
				weaponRb = arma.GetComponent<Rigidbody>();
			}
			miValorTrigger = inputs.triggerDerecho;
			if (mano == Mano.Izquierda)
			{
				miValorTrigger = inputs.triggerIzquierdo;
			}
			miValorGrip = inputs.gripDerecho;
			if (mano == Mano.Izquierda)
			{
				miValorGrip = inputs.gripIzquierdo;
			}
		}
	}

	public void CambiarEstadoMano(EstadoDeLaMano estadoNuevo)
	{
		if ((estadoNuevo == EstadoDeLaMano.PistolaEnMano || estadoNuevo == EstadoDeLaMano.GanchoEnMano) && (antiguoEstadoMano == EstadoDeLaMano.GanchoLanzandose || antiguoEstadoMano == EstadoDeLaMano.GanchoVolviendo || antiguoEstadoMano == EstadoDeLaMano.GanchoPuedeRetornar))
		{
			if (!armaScript.heDestruidoEsferaAlSerLanzado)
			{
				GameManager.instance.m_salaManager.ResetearRacha();
			}
			armaScript.heDestruidoEsferaAlSerLanzado = false;
		}
		if ((estadoNuevo == EstadoDeLaMano.GanchoLanzandose || estadoNuevo == EstadoDeLaMano.GanchoVolviendo || estadoNuevo == EstadoDeLaMano.GanchoPuedeRetornar) && (antiguoEstadoMano == EstadoDeLaMano.PistolaEnMano || antiguoEstadoMano == EstadoDeLaMano.GanchoEnMano))
		{
			armaScript.heDestruidoEsferaAlSerLanzado = false;
		}
		estadoDeLaMano = estadoNuevo;
		antiguoEstadoMano = estadoDeLaMano;
	}

	private void Update()
	{
		if (primeraPosicionModelo3DMano == Vector3.zero)
		{
			primeraPosicionModelo3DMano = mano3D.transform.localPosition;
		}
		if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.index)
		{
			float num = 0f;
			float num2 = 55f;
			if (estadoDeLaMano == EstadoDeLaMano.GanchoEnMano)
			{
				if (sumadorRotacionExtraGancho < 36f)
				{
					sumadorRotacionExtraGancho += Time.deltaTime * 100f;
				}
				num2 += sumadorRotacionExtraGancho;
				if ((double)sumadorPosicionExtraGancho < 0.04)
				{
					sumadorPosicionExtraGancho += Time.deltaTime;
				}
				num = sumadorPosicionExtraGancho;
			}
			else
			{
				if (sumadorRotacionExtraGancho > 0f)
				{
					sumadorRotacionExtraGancho -= Time.deltaTime * 100f;
				}
				if (sumadorPosicionExtraGancho > 0f)
				{
					sumadorPosicionExtraGancho -= Time.deltaTime;
				}
				num2 += sumadorRotacionExtraGancho;
				num = sumadorPosicionExtraGancho;
			}
			mano3D.transform.localPosition = new Vector3(primeraPosicionModelo3DMano.x, primeraPosicionModelo3DMano.y + num, primeraPosicionModelo3DMano.z);
			mano3D.transform.localEulerAngles = new Vector3(-8.073f + num2, -0.367f, -1.942f);
			tipoSensorEnStart = GameManager.instance.tipoDeSensores;
		}
		else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
		{
			float num3 = 0f;
			float num4 = 60f;
			if (estadoDeLaMano == EstadoDeLaMano.GanchoEnMano)
			{
				if (sumadorRotacionExtraGancho < 36f)
				{
					sumadorRotacionExtraGancho += Time.deltaTime * 100f;
				}
				num4 += sumadorRotacionExtraGancho;
				num3 = 0.04f;
			}
			else
			{
				if (sumadorRotacionExtraGancho > 0f)
				{
					sumadorRotacionExtraGancho -= Time.deltaTime * 100f;
				}
				num4 += sumadorRotacionExtraGancho;
			}
			mano3D.transform.localPosition = new Vector3(primeraPosicionModelo3DMano.x, primeraPosicionModelo3DMano.y + num3, primeraPosicionModelo3DMano.z);
			mano3D.transform.localEulerAngles = new Vector3(-8.073f + num4, -0.367f, -1.942f);
		}
		else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.nolo && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			float num5 = 0f;
			float num6 = 40f;
			if (estadoDeLaMano == EstadoDeLaMano.GanchoEnMano)
			{
				if (sumadorRotacionExtraGancho < 36f)
				{
					sumadorRotacionExtraGancho += Time.deltaTime * 100f;
				}
				num6 += sumadorRotacionExtraGancho;
				num5 = 0.04f;
			}
			else
			{
				if (sumadorRotacionExtraGancho > 0f)
				{
					sumadorRotacionExtraGancho -= Time.deltaTime * 100f;
				}
				num6 += sumadorRotacionExtraGancho;
			}
			mano3D.transform.localPosition = new Vector3(primeraPosicionModelo3DMano.x, primeraPosicionModelo3DMano.y + num5, primeraPosicionModelo3DMano.z);
			mano3D.transform.localEulerAngles = new Vector3(-8.073f + num6, -0.367f, -1.942f);
		}
		else
		{
			if (primeraRotacionModelo3DMano == Vector3.zero)
			{
				primeraRotacionModelo3DMano = mano3D.transform.localEulerAngles;
			}
			float num7 = 0f;
			float num8 = 0f;
			if (estadoDeLaMano == EstadoDeLaMano.GanchoEnMano)
			{
				if (sumadorRotacionExtraGancho < 36f)
				{
					sumadorRotacionExtraGancho += Time.deltaTime * 100f;
				}
				num7 += sumadorRotacionExtraGancho;
				num8 = 0.04f;
			}
			else
			{
				if (sumadorRotacionExtraGancho > 0f)
				{
					sumadorRotacionExtraGancho -= Time.deltaTime * 100f;
				}
				num7 += sumadorRotacionExtraGancho;
			}
			mano3D.transform.localPosition = new Vector3(primeraPosicionModelo3DMano.x, primeraPosicionModelo3DMano.y + num8, primeraPosicionModelo3DMano.z);
			mano3D.transform.localEulerAngles = new Vector3(primeraRotacionModelo3DMano.x + num7, primeraRotacionModelo3DMano.y, primeraRotacionModelo3DMano.z);
		}
		if (ticksDesdeQueCojoArma < 60f)
		{
			ticksDesdeQueCojoArma += 1f;
		}
		if (esferaMasCercana != null)
		{
			flecha.LookAt(esferaMasCercana);
		}
		if (mostrandoMensaje)
		{
			if (GameManager.instance.player.roomScale)
			{
				panelTutorial.transform.localPosition = Vector3.zero;
				panelTutorial.transform.localEulerAngles = Vector3.zero;
				panelTutorial.transform.parent.LookAt(GameManager.instance.player.cabezaPlayerRoomScale);
			}
			else
			{
				panelTutorial.transform.LookAt(GameManager.instance.player.cabeza.transform);
			}
		}
		posOldOld = posOld;
		posOld = base.transform.position;
		if (Debugs.SimularPlayer > 0)
		{
			DEBUG();
		}
		if (Debugs.SimularPlayer == 0)
		{
			base.transform.localPosition = ((mano == Mano.Derecha) ? inputs.posicionSensorR : inputs.posicionSensorL);
			base.transform.localEulerAngles = ((mano == Mano.Derecha) ? inputs.rotacionSensorR : inputs.rotacionSensorL);
		}
		posVector[pos] = posOldOld;
		pos++;
		if (pos > 5)
		{
			pos = 0;
		}
		if (!GameManager.instance.player.menu && !GameManager.instance.m_salaManager.nivelIniciado && !GameManager.instance.player.muerto)
		{
			flecha.LookAt(arma.transform);
		}
		if ((GameManager.instance.player.muerto && !Config.ModoCooperativo()) || Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			return;
		}
		velocidadMano = InputsController.instance.rightHandVelocityVector;
		if (mano == Mano.Izquierda)
		{
			velocidadMano = InputsController.instance.leftHandVelocityVector;
		}
		if (mano == Mano.Derecha)
		{
			miValorTrigger = inputs.triggerDerecho;
			miValorGrip = inputs.gripDerecho;
		}
		else
		{
			miValorTrigger = inputs.triggerIzquierdo;
			miValorGrip = inputs.gripIzquierdo;
		}
		bTriggerDown = !bTriggerEstaAhoraPulsado && miValorTrigger > 0.8f;
		bTriggerUp = bTriggerEstaAhoraPulsado && miValorTrigger <= 0.8f;
		bTriggerEstaAhoraPulsado = miValorTrigger > 0.8f;
		bGripDown = !bGripEstaAhoraPulsado && miValorGrip > 0.95f;
		bGripUp = bGripEstaAhoraPulsado && miValorGrip <= 0.95f;
		bGripEstaAhoraPulsado = miValorGrip > 0.95f;
		_ = InputsController.instance.rightHandVelocity;
		if (mano == Mano.Derecha)
		{
			_ = InputsController.instance.rightHandVelocity;
		}
		if (TimeManager.instance.tiempoMuerto)
		{
			return;
		}
		if (Config.tipoDeControl == Config.TipoControl.UnaMano)
		{
			if (!armaScript || !armaScript.rifleScript)
			{
				return;
			}
			bool flag = armaScript.rifleScript.GetEstadoArma() == Rifle.EstadoArma.Escopeta || armaScript.rifleScript.GetEstadoArma() == Rifle.EstadoArma.Laser;
			if (armaScript.nivelIniciado && !armaScript.recargando && ((!flag && bTriggerUp) || (flag && bTriggerEstaAhoraPulsado)) && (primerTriggerSoltado || bGripEstaAhoraPulsado))
			{
				armaScript.puedeDisparar = true;
				armaScript.Disparo();
				timeGancho = 0f;
			}
			if (armaScript.nivelIniciado && !primerTriggerSoltado && (bTriggerUp || bGripUp))
			{
				primerTriggerSoltado = true;
			}
			else if (!armaScript.nivelIniciado)
			{
				primerTriggerSoltado = true;
			}
			bool flag2 = armaScript.rifleScript.GetEstadoArma() == Rifle.EstadoArma.Disparos;
			bool flag3 = armaScript.rifleScript.GetEstadoArma() == Rifle.EstadoArma.GanchoD || armaScript.rifleScript.GetEstadoArma() == Rifle.EstadoArma.GanchoI;
			if (armaScript.nivelIniciado && ((primerTriggerSoltado && bTriggerEstaAhoraPulsado) || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha)) && (flag2 || flag3))
			{
				timeGancho += Time.deltaTime;
				if (timeGancho > 0.5f || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
				{
					if (flag2)
					{
						if (!InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
						{
							primerTriggerSoltado = false;
						}
						armaScript.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.GanchoD);
					}
					else if (flag3)
					{
						if (!InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
						{
							primerTriggerSoltado = false;
						}
						armaScript.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.Disparos);
					}
					InputsController.instance.SetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha, value: false);
					GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala = 0;
					GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha, (bool)armaScript.rifleScript.controladorManoSecundariaRifle && armaScript.rifleScript.controladorManoSecundariaRifle.anclada);
					timeGancho = 0f;
					return;
				}
			}
			else
			{
				timeGancho = 0f;
			}
			if (bGripUp && cooldownTiempoCambioConGripUnaMano + 1f < Time.time && primerTriggerSoltado && !cogidaConElGrip)
			{
				if (flag2)
				{
					if (!InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
					{
						primerTriggerSoltado = false;
					}
					armaScript.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.GanchoD);
				}
				else if (flag3)
				{
					if (!InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
					{
						primerTriggerSoltado = false;
					}
					armaScript.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.Disparos);
				}
				InputsController.instance.SetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha, value: false);
				GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala = 0;
				GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha, (bool)armaScript.rifleScript.controladorManoSecundariaRifle && armaScript.rifleScript.controladorManoSecundariaRifle.anclada);
				timeGancho = 0f;
				primerTriggerSoltado = true;
				cooldownTiempoCambioConGripUnaMano = Time.time;
			}
			if (!bGripEstaAhoraPulsado)
			{
				cogidaConElGrip = false;
			}
			return;
		}
		if (estadoDeLaMano != EstadoDeLaMano.PistolaEnMano)
		{
			timeGancho = 0f;
		}
		if (estadoDeLaMano == EstadoDeLaMano.EstadoInicialSinArma)
		{
			armaScript.heDestruidoEsferaAlSerLanzado = false;
			if ((bool)armaScript && (bool)armaScript.weaponScript && (bool)armaScript.weaponScript.rb)
			{
				armaScript.weaponScript.rb.useGravity = true;
			}
			primerTriggerSoltado = false;
			acaboDeCambiarDeGanchoAPistola = false;
			timePistola = 0f;
			if (bTriggerEstaAhoraPulsado || bGripEstaAhoraPulsado)
			{
				if ((bool)animManos)
				{
					animManos.EmptyHandTryCatchWeapon();
				}
			}
			else if ((bool)animManos)
			{
				animManos.EmptyHandStopTryCatchWeapon();
			}
			if ((bool)armaScript && armaScript.ChocadoPelota)
			{
				armaScript.ChocadoPelota = false;
			}
		}
		if (estadoDeLaMano == EstadoDeLaMano.GanchoEnMano)
		{
			if (armaScript.weaponScript.armaEnFantasmal)
			{
				armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
				armaScript.weaponScript.armaEnFantasmal = false;
			}
			armaScript.weaponScript.rb.useGravity = true;
			armaScript.weaponScript.coliderPistola.SetActive(value: false);
			armaScript.weaponScript.coliderGancho.SetActive(value: true);
			armaScript.municion = 0;
			miValorVelocidadValido = InputsController.instance.rightHandVelocity;
			if (mano == Mano.Izquierda)
			{
				miValorVelocidadValido = InputsController.instance.leftHandVelocity;
			}
			if (ticksDesdeQueCojoArma < 15f)
			{
				miValorVelocidadValido = 0f;
			}
			if (tDeltaCambiarAGancho < 1f && !forzarLanzar)
			{
				arma.transform.SetParent(mano3D.transform);
				tDeltaCambiarAGancho += Time.deltaTime * 10f;
				Transform obj = arma.transform;
				Vector3 a = armaScript.weaponScript.pistolaMesh.transform.localPosition - mano3D.transform.localPosition;
				Vector3 b = (arma.transform.localPosition = new Vector3(-0.0095f, 0.0375f, 0.0198f));
				obj.localPosition = Vector3.Lerp(a, b, tDeltaCambiarAGancho);
				arma.transform.localEulerAngles = Vector3.Lerp(arma.transform.InverseTransformPoint(armaScript.weaponScript.pistolaMesh.transform.localEulerAngles), new Vector3(42.96f, -2.284f, -0.437f), tDeltaCambiarAGancho);
				arma.transform.parent = base.transform;
			}
			else
			{
				arma.transform.SetParent(mano3D.transform);
				if (forzarLanzar)
				{
					mano3D.transform.localEulerAngles = new Vector3(mano3D.transform.localEulerAngles.x + 36f, mano3D.transform.localEulerAngles.y, mano3D.transform.localEulerAngles.z);
				}
				arma.transform.localEulerAngles = new Vector3(42.96f, -2.284f, -0.437f);
				arma.transform.localPosition = new Vector3(-0.0095f, 0.0375f, 0.0198f);
				arma.transform.parent = base.transform;
				if (forzarLanzar)
				{
					mano3D.transform.localEulerAngles = new Vector3(mano3D.transform.localEulerAngles.x - 36f, mano3D.transform.localEulerAngles.y, mano3D.transform.localEulerAngles.z);
				}
			}
			if ((bTriggerUp && miValorVelocidadValido > 2.5f) || tirandoPorVelocidad)
			{
				Vector3 velocidad = velocidadMano;
				tirandoPorVelocidad = true;
				Throw(velocidad);
			}
			else if (forzarLanzar || ((bTriggerUp || bGripUp) && primerTriggerSoltado))
			{
				forzarLanzar = false;
				CambiarEstadoMano(EstadoDeLaMano.GanchoLanzandose);
				ThrowByTrigger();
			}
			if (!heHechoCAmbioDeArma && (bTriggerEstaAhoraPulsado || (primerTriggerSoltado && bGripEstaAhoraPulsado) || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha)) && !tirandoPorVelocidad && miValorVelocidadValido < 2.5f)
			{
				timePistola += Time.deltaTime;
				if (timePistola > 0.5f || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
				{
					TimeManager.instance.ticksConTiempoNormalForzado = 15;
					primerTriggerSoltado = false;
					acaboDeCambiarDeGanchoAPistola = true;
					animManos.CatchWeapon();
					InputsController.instance.SetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha, value: false);
					GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala = 0;
					GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha);
					animWeapon.TransformHookToPistol(armaScript.weaponScript);
					TimeManager.GetInstance().MakeTimeNormal(condicion: false);
					armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
					armaScript.weaponScript.armaEnFantasmal = false;
					timePistola = 0f;
					CambiarEstadoMano(EstadoDeLaMano.PistolaEnMano);
					armaScript.municion = armaScript.municionMaxActual;
					if (armaScript.weaponScript.GetTipoDeArma() == Weapon.TipoDeArma.Normal)
					{
						armaScript.weaponScript.Recarga();
					}
					armaScript.pantalla.gameObject.SetActive(value: true);
					armaScript.miMano.PonerAudioEnAudioSource(ClipsAudioMano.TransformarAPistola);
					heHechoCAmbioDeArma = true;
				}
			}
			else
			{
				timePistola = 0f;
			}
			if (!primerTriggerSoltado && !bTriggerEstaAhoraPulsado && !bGripEstaAhoraPulsado)
			{
				primerTriggerSoltado = true;
			}
			if ((bool)armaScript && armaScript.ChocadoPelota)
			{
				armaScript.ChocadoPelota = false;
			}
		}
		if (estadoDeLaMano == EstadoDeLaMano.PistolaEnMano)
		{
			if (armaScript.weaponScript.armaEnFantasmal)
			{
				armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
				armaScript.weaponScript.armaEnFantasmal = false;
			}
			armaScript.weaponScript.rb.useGravity = true;
			if (timeGancho < 0.5f)
			{
				armaScript.weaponScript.coliderPistola.SetActive(value: true);
				armaScript.weaponScript.coliderGancho.SetActive(value: false);
			}
			arma.transform.SetParent(mano3D.transform);
			if ((bool)armaScript.weaponScript)
			{
				arma.transform.localPosition = new Vector3(-0.006f, 0.0456f, 0.0359f);
			}
			else
			{
				arma.transform.localPosition = new Vector3(-0.0059f, 0.0537f, 0.034f);
			}
			arma.transform.parent = base.transform;
			arma.transform.localEulerAngles = mano3D.transform.localEulerAngles;
			miValorVelocidadValido = InputsController.instance.rightHandVelocity;
			if (mano == Mano.Izquierda)
			{
				miValorVelocidadValido = InputsController.instance.leftHandVelocity;
			}
			if ((bool)armaScript && armaScript.ChocadoPelota)
			{
				armaScript.ChocadoPelota = false;
			}
			if (armaScript.weaponScript.GetTipoDeArma() == Weapon.TipoDeArma.Normal)
			{
				if (armaScript.nivelIniciado && miValorVelocidadValido > 2.5f && bTriggerUp && otherHand.estadoDeLaMano != 0)
				{
					tirandoPorVelocidad = true;
					timeGancho = 0f;
					armaScript.weaponScript.PonerGancho(animManos);
					CambiarEstadoMano(EstadoDeLaMano.GanchoEnMano);
					primerTriggerSoltado = false;
					acaboDeCambiarDeGanchoAPistola = false;
					return;
				}
				if (armaScript.nivelIniciado && bGripUp && !cogidaConElGrip && otherHand.estadoDeLaMano != 0)
				{
					forzarLanzar = true;
					tirandoPorVelocidad = false;
					timeGancho = 0f;
					armaScript.weaponScript.PonerGancho(animManos);
					CambiarEstadoMano(EstadoDeLaMano.GanchoEnMano);
					primerTriggerSoltado = false;
					acaboDeCambiarDeGanchoAPistola = false;
					return;
				}
				if (!heHechoCAmbioDeArma && armaScript.nivelIniciado && (bTriggerEstaAhoraPulsado || (primerTriggerSoltado && bGripEstaAhoraPulsado) || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha)) && otherHand.estadoDeLaMano != 0 && miValorVelocidadValido < 2.5f)
				{
					timeGancho += Time.deltaTime;
					if (timeGancho > 0.5f || InputsController.instance.GetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha))
					{
						tirandoPorVelocidad = false;
						primerTriggerSoltado = false;
						acaboDeCambiarDeGanchoAPistola = false;
						heHechoCAmbioDeArma = true;
						timeGancho = 0f;
						InputsController.instance.SetBotonCambiarPistolaGanchoUp(mano == Mano.Derecha, value: false);
						GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala = 0;
						GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha);
						armaScript.weaponScript.PonerGancho(animManos);
						CambiarEstadoMano(EstadoDeLaMano.GanchoEnMano);
						return;
					}
				}
			}
			else if (bTriggerEstaAhoraPulsado && otherHand.estadoDeLaMano != 0 && armaScript.nivelIniciado && !armaScript.recargando)
			{
				armaScript.puedeDisparar = true;
				armaScript.Disparo();
			}
			if (armaScript.municion <= 0 && !armaScript.recargando)
			{
				armaScript.Recargar();
				return;
			}
			if (bTriggerUp && !armaScript.puedeDisparar && (primerTriggerSoltado || bGripEstaAhoraPulsado) && !armaScript.recargando)
			{
				armaScript.puedeDisparar = true;
			}
			if (armaScript.nivelIniciado && bTriggerUp && !acaboDeCambiarDeGanchoAPistola && (primerTriggerSoltado || bGripEstaAhoraPulsado) && !armaScript.recargando)
			{
				armaScript.Disparo();
				timeGancho = 0f;
			}
			if (bTriggerUp && primerTriggerSoltado)
			{
				if (disparar && !armaScript.recargando)
				{
					disparar = false;
					animManos.FireBullet();
				}
			}
			else if (!disparar && !armaScript.recargando)
			{
				disparar = true;
			}
			if (!primerTriggerSoltado && !bTriggerEstaAhoraPulsado && !bGripEstaAhoraPulsado)
			{
				primerTriggerSoltado = true;
			}
		}
		if (estadoDeLaMano == EstadoDeLaMano.GanchoPuedeRetornar)
		{
			armaScript.weaponScript.rb.useGravity = true;
			primerTriggerSoltado = false;
			acaboDeCambiarDeGanchoAPistola = false;
			if ((bTriggerDown || bTriggerUp || bGripUp || bGripDown) && (!armaScript.weaponScript.bloque || !armaScript.weaponScript.bloque.isEscudo))
			{
				Atraer();
				if (bGripDown)
				{
					cogidaConElGrip = true;
				}
				else
				{
					cogidaConElGrip = false;
				}
				afectandoTiempo = true;
				armaScript.weaponScript.armaEnFantasmal = true;
				CambiarEstadoMano(EstadoDeLaMano.GanchoVolviendo);
				armaScript.weaponScript.bloque = null;
				armaScript.armaEstaEnBloque = false;
				armaScript.armaAncladaABloque = false;
				armaScript.weaponScript.rb.interpolation = RigidbodyInterpolation.Interpolate;
				armaScript.weaponScript.otraPistola.armaEstaEnBloque = false;
			}
			else
			{
				if (armaScript.weaponScript.armaEnFantasmal)
				{
					armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
					armaScript.weaponScript.armaEnFantasmal = false;
				}
				afectandoTiempo = false;
				if (!otherHand.afectandoTiempo)
				{
					TimeManager.GetInstance().MakeTimeNormal(condicion: false);
				}
			}
		}
		if (estadoDeLaMano == EstadoDeLaMano.GanchoVolviendo)
		{
			armaScript.weaponScript.rb.useGravity = true;
			primerTriggerSoltado = false;
			acaboDeCambiarDeGanchoAPistola = false;
			miValorVelocidadValido = InputsController.instance.rightHandVelocity;
			if (mano == Mano.Izquierda)
			{
				miValorVelocidadValido = InputsController.instance.leftHandVelocity;
			}
			if (ticksDesdeQueCojoArma < 15f)
			{
				miValorVelocidadValido = 0f;
			}
			tirandoPorVelocidad = false;
			armaScript.weaponScript.pistolaMesh.SetActive(value: true);
			armaScript.weaponScript.gancho.SetActive(value: false);
			armaScript.weaponScript.coliderPistola.SetActive(value: false);
			armaScript.weaponScript.coliderGancho.SetActive(value: false);
			armaScript.weaponScript.pandreColiders.transform.localPosition = new Vector3(0f, 0.017f, 0.081f);
			if (Vector3.Distance(arma.transform.position, base.transform.position) > 0.1f)
			{
				arma.transform.position = Vector3.MoveTowards(arma.transform.position, base.transform.position, 0.5f);
				armaScript.weaponScript.gancho.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, Quaternion.Euler(0f, 0f, 0f), armaScript.weaponScript.inclinacionParaAnimacionGanchoQueVaDe0A1);
				armaScript.weaponScript.gancho.transform.localPosition = Vector3.Lerp(armaScript.weaponScript.gancho.transform.localPosition, new Vector3(0f, 0.075f, 0.18f), armaScript.weaponScript.inclinacionParaAnimacionGanchoQueVaDe0A1);
			}
			else
			{
				if (armaScript.weaponScript.armaEnFantasmal)
				{
					armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
					armaScript.weaponScript.armaEnFantasmal = false;
				}
				arma.transform.SetParent(mano3D.transform);
				if ((bool)armaScript.weaponScript)
				{
					arma.transform.localPosition = new Vector3(-0.006f, 0.0456f, 0.0359f);
				}
				else
				{
					arma.transform.localPosition = new Vector3(-0.0059f, 0.0537f, 0.034f);
				}
				arma.transform.parent = base.transform;
				arma.transform.localEulerAngles = mano3D.transform.localEulerAngles;
				animManos.CatchWeapon();
				TimeManager.GetInstance().MakeTimeNormal(condicion: false);
				armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
				armaScript.weaponScript.armaEnFantasmal = false;
				armaScript.municion = armaScript.municionMaxActual;
				Grab(armaScript.gameObject);
				CambiarEstadoMano(EstadoDeLaMano.PistolaEnMano);
				armaScript.pantalla.gameObject.SetActive(value: true);
			}
		}
		if (estadoDeLaMano == EstadoDeLaMano.GanchoLanzandose)
		{
			armaScript.weaponScript.rb.useGravity = false;
		}
		if (!bTriggerEstaAhoraPulsado)
		{
			acaboDeCambiarDeGanchoAPistola = false;
			heHechoCAmbioDeArma = false;
		}
		if (!bGripEstaAhoraPulsado)
		{
			cogidaConElGrip = false;
		}
	}

	public void AtraerDesdeAire()
	{
		Atraer(escudo: true);
		afectandoTiempo = true;
		if ((bool)armaScript.weaponScript)
		{
			armaScript.weaponScript.armaEnFantasmal = true;
		}
		else
		{
			armaScript.rifleScript.PonerQuitarFantasmal(activar: true);
		}
		CambiarEstadoMano(EstadoDeLaMano.GanchoVolviendo);
		if ((bool)armaScript.weaponScript.bloque)
		{
			armaScript.weaponScript.bloque.bolaPadre.ponerComoInicio();
		}
		armaScript.weaponScript.bloque = null;
		armaScript.armaEstaEnBloque = false;
		armaScript.weaponScript.rb.interpolation = RigidbodyInterpolation.Interpolate;
		armaScript.armaAncladaABloque = false;
		armaScript.weaponScript.otraPistola.armaEstaEnBloque = false;
	}

	public void Grab(GameObject objeto, bool inicio = false)
	{
		if (GameManager.instance.player.enConfirmacionDeSalir)
		{
			GameManager.instance.player.NoSalir();
		}
		animManos.CatchWeapon();
		if ((bool)manoRoomScale)
		{
			manoRoomScale.animManoRS.CatchWeapon();
		}
		TimeManager.GetInstance().MakeTimeNormal(condicion: false);
		arma = objeto;
		arma.transform.SetParent(mano3D.transform);
		if ((bool)armaScript.weaponScript)
		{
			arma.transform.localPosition = new Vector3(-0.006f, 0.0456f, 0.0359f);
		}
		else
		{
			arma.transform.localPosition = new Vector3(-0.0059f, 0.0537f, 0.034f);
		}
		arma.transform.parent = base.transform;
		arma.transform.localEulerAngles = mano3D.transform.localEulerAngles;
		arma.transform.localScale = Vector3.one;
		armaScript = objeto.GetComponent<Arma>();
		weaponRb.useGravity = true;
		weaponRb.isKinematic = true;
		if (armaScript.ChocadoPelota)
		{
			armaScript.ChocadoPelota = false;
		}
		if (Config.tipoDeControl == Config.TipoControl.DosManos)
		{
			if (inicio)
			{
				armaScript.municion = armaScript.municionMaxNormal;
			}
			if (armaScript.municion > 0)
			{
				armaScript.weaponScript.pistolaMesh.SetActive(value: true);
				armaScript.weaponScript.gancho.SetActive(value: false);
				StopCoroutine(armaScript.weaponScript.TiempoRecarga(0.4f));
				armaScript.animPistola.enabled = false;
			}
			if (estadoDeLaMano == EstadoDeLaMano.PistolaEnMano && !armaScript.nivelIniciado && otherHand.estadoDeLaMano == EstadoDeLaMano.PistolaEnMano)
			{
				InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: true);
				InicioNivel.GetInstance().SetTextWaitingForPlayers();
				StartCoroutine(EsperarParaIniciarNivel());
			}
		}
		else
		{
			if (inicio)
			{
				armaScript.municion = armaScript.municionMaxNormal;
			}
			estadoDeLaMano = EstadoDeLaMano.PistolaEnMano;
			armaScript.rifleScript.CambiarEstadoArma(Rifle.EstadoArma.Disparos);
			armaScript.animPistola.enabled = false;
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: true);
			InicioNivel.GetInstance().SetTextWaitingForPlayers();
			StartCoroutine(EsperarParaIniciarNivel());
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Offline && inicio)
		{
			if ((bool)armaScript.weaponScript && (bool)armaScript.weaponScript.otraPistola)
			{
				if (armaScript.weaponScript.otraPistola.miMano.estadoDeLaMano != 0)
				{
					GameManager.instance.player.Empezar();
				}
			}
			else
			{
				GameManager.instance.player.Empezar();
			}
			InputsController.instance.ResetLastPosHand(mano == Mano.Derecha);
		}
		ticksDesdeQueCojoArma = 0f;
		GameManager.instance.player.Vibra(Player.TipoVibracion.cogerPistolas, mano == Mano.Derecha);
		PonerAudioEnAudioSource(ClipsAudioMano.Coger);
	}

	private IEnumerator EsperarParaIniciarNivel()
	{
		PartidaSync.instance.MasterHeCogidoLasPistolas();
		int numJugadores = PartidaSync.instance.numPlayersPreparados;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.EsperandoJugadores);
		}
		while (!GameManager.instance.comenzarPartidaOnline)
		{
			if (PartidaSync.instance.numPlayersPreparados != numJugadores)
			{
				GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.EsperandoJugadores);
				numJugadores = PartidaSync.instance.numPlayersPreparados;
			}
			yield return null;
		}
		GameManager.instance.comenzarPartidaOnline = false;
		PartidaSync.instance.numPlayersPreparados = 0;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.player.Empezar();
			InputsController.instance.ResetLastPosHand(mano == Mano.Derecha);
			ticksDesdeQueCojoArma = 0f;
		}
		InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.Apagar);
		}
		armaScript.puedeDisparar = true;
		armaScript.recargando = false;
		armaScript.nivelIniciado = true;
		if (Config.tipoDeControl == Config.TipoControl.DosManos)
		{
			armaScript.weaponScript.otraPistola.nivelIniciado = true;
		}
		InicioNivel.GetInstance().IniciarNivel();
		if ((bool)otherHand)
		{
			otherHand.IniciarBusquedaEsferas();
		}
		IniciarBusquedaEsferas();
	}

	public void Atraer(bool escudo = false)
	{
		Weapon component = arma.GetComponent<Weapon>();
		if (!component.nivelIniciado)
		{
			return;
		}
		animManos.AttractWeapon();
		animWeapon.TransformHookToPistol(armaScript.weaponScript);
		Rigidbody component2 = component.GetComponent<Rigidbody>();
		component.ChocadoPelota = false;
		if (component.armaEstaEnPared)
		{
			component.armaEstaEnPared = false;
		}
		if (component.armaEstaEnBloque)
		{
			if (component.bloque.isEscudo)
			{
				component.bloque.GetComponent<SphereCollider>().isTrigger = false;
				component.otraPistola.armaEstaEnBloque = false;
			}
			else
			{
				if ((bool)component.bloque.GetComponent<BoxCollider>())
				{
					component.bloque.GetComponent<BoxCollider>().isTrigger = false;
				}
				component.bloque.transform.parent = null;
			}
			component.armaEstaEnBloque = false;
			component.bloque.pistolaAnclada = false;
			component.bloque = null;
		}
		if (component2.useGravity)
		{
			component2.useGravity = false;
		}
		TimeManager.GetInstance().MakeTimeNormal(condicion: true);
		if (!escudo)
		{
			TimeManager.GetInstance().ticksConTiempoNormalForzado = 20;
		}
		if (component2.isKinematic)
		{
			component2.isKinematic = false;
		}
		component2.velocity = Vector3.zero;
		_ = base.transform.position - arma.transform.position;
		PonerAudioEnAudioSource(ClipsAudioMano.Atraer);
	}

	private void Throw(Vector3 velocidad)
	{
		if (GameManager.instance.player.zonaOscuraActivada)
		{
			return;
		}
		primerTriggerSoltado = false;
		acaboDeCambiarDeGanchoAPistola = false;
		Vector3 vector = Vector3.zero;
		float num = 0f;
		float num2 = 0f;
		for (int i = 1; i < posVector.Length; i++)
		{
			if (Vector3.Distance(posVector[i], posVector[i - 1]) > num2)
			{
				num2 = Vector3.Distance(posVector[i], posVector[i - 1]);
			}
			num += Vector3.Distance(posVector[i], posVector[i - 1]);
		}
		num /= (float)posVector.Length;
		for (int j = 1; j < posVector.Length - 4; j++)
		{
			if (Vector3.Distance(posVector[j], posVector[j - 1]) <= num * (float)posVector.Length / 2f)
			{
				vector += posVector[j] - posVector[j - 1];
			}
		}
		if (vector == Vector3.zero)
		{
			vector = mano3D.transform.forward;
		}
		CambiarEstadoMano(EstadoDeLaMano.GanchoLanzandose);
		animManos.ReleaseActualWeapon();
		StartCoroutine(armaScript.weaponScript.TiempoRecarga(0.1f));
		armaScript.weaponScript.pistolaMesh.SetActive(value: false);
		armaScript.weaponScript.gancho.SetActive(value: true);
		if (weaponRb.isKinematic)
		{
			weaponRb.isKinematic = false;
		}
		if (!weaponRb.useGravity)
		{
			weaponRb.useGravity = true;
		}
		arma.GetComponent<Rigidbody>().velocity = Vector3.zero;
		arma.transform.parent = null;
		armaImpulsandose = vector.normalized * 5f;
		TimeManager.GetInstance().ticksConTiempoNormalForzado = 15;
		GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha);
		PonerAudioEnAudioSource(ClipsAudioMano.Lanzar);
	}

	private void ThrowByTrigger()
	{
		if (!GameManager.instance.player.zonaOscuraActivada)
		{
			primerTriggerSoltado = false;
			acaboDeCambiarDeGanchoAPistola = false;
			animManos.ReleaseActualWeapon();
			StartCoroutine(armaScript.weaponScript.TiempoRecarga(0.1f));
			armaScript.weaponScript.pistolaMesh.SetActive(value: false);
			armaScript.weaponScript.gancho.SetActive(value: true);
			if (weaponRb.isKinematic)
			{
				weaponRb.isKinematic = false;
			}
			if (!weaponRb.useGravity)
			{
				weaponRb.useGravity = true;
			}
			arma.GetComponent<Rigidbody>().velocity = Vector3.zero;
			arma.transform.parent = null;
			armaImpulsandose = armaScript.weaponScript.gancho.transform.forward * 5f;
			TimeManager.GetInstance().ticksConTiempoNormalForzado = 15;
			GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, mano == Mano.Derecha);
			PonerAudioEnAudioSource(ClipsAudioMano.Lanzar);
		}
	}

	public void IniciarBusquedaEsferas()
	{
		if (mano == Mano.Izquierda)
		{
			if (buscarEsferaMasCercanaIzquierda == null)
			{
				buscarEsferaMasCercanaIzquierda = StartCoroutine(BuscarEsferaMasCercana());
			}
			return;
		}
		if (buscarEsferaMasCercanaDerecha == null)
		{
			buscarEsferaMasCercanaDerecha = StartCoroutine(BuscarEsferaMasCercana());
		}
		if (!scalaModificada)
		{
			scalaModificada = true;
			distancia.transform.localScale = new Vector3(distancia.transform.localScale.x * -1f, distancia.transform.localScale.y, distancia.transform.localScale.z);
		}
	}

	private IEnumerator BuscarEsferaMasCercana()
	{
		while (GameManager.instance.m_salaManager.nivelIniciado)
		{
			yield return new WaitForSeconds(1f);
			if (NivelCompletado.instance.listaEsferasEquipo1.Count + NivelCompletado.instance.listaEsferasEquipo2.Count <= 0)
			{
				continue;
			}
			if (NivelCompletado.instance.listaEsferasEquipo1.Count > 0)
			{
				esferaMasCercana = NivelCompletado.instance.listaEsferasEquipo1[0];
			}
			else
			{
				esferaMasCercana = NivelCompletado.instance.listaEsferasEquipo2[0];
			}
			try
			{
				if (NivelCompletado.instance.listaEsferasEquipo1.Count > 1)
				{
					for (int i = 0; i < NivelCompletado.instance.listaEsferasEquipo1.Count; i++)
					{
						if (Vector3.Distance(base.transform.position, NivelCompletado.instance.listaEsferasEquipo1[i].position) < Vector3.Distance(base.transform.position, esferaMasCercana.position))
						{
							esferaMasCercana = NivelCompletado.instance.listaEsferasEquipo1[i];
						}
					}
					for (int j = 0; j < NivelCompletado.instance.listaEsferasEquipo2.Count; j++)
					{
						if (Vector3.Distance(base.transform.position, NivelCompletado.instance.listaEsferasEquipo2[j].position) < Vector3.Distance(base.transform.position, esferaMasCercana.position))
						{
							esferaMasCercana = NivelCompletado.instance.listaEsferasEquipo2[j];
						}
					}
				}
				distancia.text = Math.Round(Vector3.Distance(base.transform.position, esferaMasCercana.position), 1).ToString();
				distancia.transform.LookAt(GameManager.instance.player.cabeza.transform);
			}
			catch (Exception)
			{
			}
		}
		buscarEsferaMasCercanaDerecha = null;
		buscarEsferaMasCercanaIzquierda = null;
		distancia.text = "";
	}

	public void PonerPistolaEnMano()
	{
		primerTriggerSoltado = false;
		acaboDeCambiarDeGanchoAPistola = false;
		animManos.CatchWeapon();
		animWeapon.TransformHookToPistol(armaScript.weaponScript);
		TimeManager.GetInstance().MakeTimeNormal(condicion: false);
		armaScript.weaponScript.meshArma.material = armaScript.weaponScript.materiales[0];
		armaScript.weaponScript.armaEnFantasmal = false;
		timePistola = 0f;
		CambiarEstadoMano(EstadoDeLaMano.PistolaEnMano);
		armaScript.municion = armaScript.municionMaxActual;
		armaScript.weaponScript.Recarga();
		armaScript.pantalla.gameObject.SetActive(value: true);
		armaScript.miMano.PonerAudioEnAudioSource(ClipsAudioMano.TransformarAPistola);
	}

	private void DEBUG()
	{
		if (Input.GetKey(KeyCode.L) && mano == Mano.Derecha)
		{
			inputs.triggerDerecho = 1f;
		}
		if (Input.GetKey(KeyCode.K) && mano == Mano.Izquierda)
		{
			inputs.triggerIzquierdo = 1f;
		}
		if (mano == Mano.Izquierda)
		{
			base.transform.localPosition = new Vector3(-0.1f, -0.05f, 0.34f);
		}
		else
		{
			base.transform.localPosition = new Vector3(0.1f, -0.05f, 0.34f);
		}
		base.transform.localEulerAngles = Vector3.zero;
		mano3D.SetActive(value: true);
		Debugs.SimularPlayer = 2;
		if (Input.GetKey(KeyCode.Alpha1))
		{
			TimeManager.GetInstance().miTiempo = 1f;
		}
		else if (Input.GetKey(KeyCode.Alpha2))
		{
			TimeManager.GetInstance().miTiempo = 0.6f;
		}
		else if (Input.GetKey(KeyCode.Alpha3))
		{
			TimeManager.GetInstance().miTiempo = 0.3f;
		}
		else
		{
			Debugs.SimularPlayer = 1;
		}
		if (Input.GetKeyDown(KeyCode.I))
		{
			inmortal_DEBUG = !inmortal_DEBUG;
			GameManager.instance.player.SetInmortalidad(inmortal_DEBUG);
		}
	}

	private void CargarClipsAudio()
	{
		audioClipsMano[0] = Resources.Load<AudioClip>("EfectosSonido/lanzar_gancho");
		audioClipsMano[1] = Resources.Load<AudioClip>("EfectosSonido/recoger_gancho");
		audioClipsMano[2] = Resources.Load<AudioClip>("EfectosSonido/coger_arma");
		audioClipsMano[3] = Resources.Load<AudioClip>("EfectosSonido/tranformar_pistola_gancho");
		audioClipsMano[4] = Resources.Load<AudioClip>("EfectosSonido/power_up");
		audioClipsMano[5] = Resources.Load<AudioClip>("EfectosSonido/transformar_pistola_gancho_rapido");
	}

	public void PonerAudioEnAudioSource(ClipsAudioMano clipAudio)
	{
		AudioClip audioClip = audioClipsMano[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en ControladorMano.cs " + clipAudio);
			return;
		}
		if (audioSources == null)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en ControladorMano.cs");
			return;
		}
		int num = 0;
		while (audioSources[num].isPlaying)
		{
			num++;
			if (num >= audioSources.Length)
			{
				num = 0;
				audioSources[num].Stop();
			}
		}
		if (num < 999)
		{
			audioSources[num].clip = audioClip;
			audioSources[num].Play();
		}
	}

	public void MostrarOcultarMensajeTrynity(bool estado, string mensaje, bool gatillo = true, bool mensajeIntermedio = false)
	{
		mostrandoMensaje = estado;
		panelTutorial.SetActive(estado);
		if ((bool)flecha)
		{
			flecha.gameObject.SetActive(!estado);
			flecha.transform.parent.GetChild(1).gameObject.SetActive(!estado);
		}
		if ((bool)GameManager.instance.player.hologramaRoomScaleD)
		{
			GameManager.instance.player.hologramaRoomScaleD.SetActive(estado);
		}
		if ((bool)GameManager.instance.player.hologramaRoomScaleI)
		{
			GameManager.instance.player.hologramaRoomScaleI.SetActive(estado);
		}
		if (GameManager.instance.nivelInicioMenu)
		{
			tiempoEspera = 2f;
		}
		else
		{
			tiempoEspera = 0.5f;
		}
		if (mensajeIntermedio)
		{
			return;
		}
		if (estado)
		{
			audioSourcePanelChica.adioSourcesMensajes[0].Play();
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				StartCoroutine(EsperarSegundosPrimerSonido());
			}
		}
		else
		{
			audioSourcePanelChica.adioSourcesMensajes[2].Play();
			audioSourcePanelChica.adioSourcesMensajes[3].Stop();
		}
	}

	private IEnumerator EsperarSegundosPrimerSonido()
	{
		yield return new WaitForSeconds(tiempoEspera);
		audioSourcePanelChica.PonerClipParteParrafo();
		GameManager.instance.nivelInicioMenu = false;
	}

	private void CargarReferenciasPanelChica()
	{
		audioSourcePanelChica = panelTutorial.transform.parent.GetChild(5).GetComponent<ControladorSonidosMensajes>();
	}
}
public class ControladorManoSecundariaRifle : MonoBehaviour
{
	public ControladorMano.Mano mano;

	public bool anclada;

	public Transform empuñadura;

	public Rifle rifle;

	public Transform mano3dOtro;

	public Transform mano3dMia;

	public Transform otraMano;

	private Vector3 posRifleInicial = Vector3.zero;

	private Vector3 rotRifleInicial = Vector3.zero;

	private void Start()
	{
		rifle.controladorManoSecundariaRifle = this;
		float num = 25f;
		if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.index)
		{
			num += 30f;
		}
		if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
		{
			num += 35f;
		}
		if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.nolo && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			num += 40f;
		}
		mano3dMia.transform.localEulerAngles = new Vector3(-8.073f + num, -0.367f, -1.942f);
	}

	private void Update()
	{
		float num = 0.15f;
		float num2 = 0.22f;
		Vector3 localPosition = ((mano == ControladorMano.Mano.Derecha) ? InputsController.instance.posicionSensorR : InputsController.instance.posicionSensorL);
		Vector3 localEulerAngles = ((mano == ControladorMano.Mano.Derecha) ? InputsController.instance.rotacionSensorR : InputsController.instance.rotacionSensorL);
		rifle.sensorDebug.localPosition = localPosition;
		rifle.sensorDebug.localEulerAngles = localEulerAngles;
		if (!anclada)
		{
			base.transform.localPosition = rifle.sensorDebug.localPosition;
			base.transform.localRotation = rifle.sensorDebug.localRotation;
		}
		else
		{
			rifle.transform.LookAt(rifle.sensorDebug, rifle.transform.up);
		}
		localPosition = rifle.sensorDebug.position;
		Vector3 position = empuñadura.position;
		float num3 = Vector3.Distance(localPosition, position);
		if (!anclada && rifle.coliderPistola.activeInHierarchy && num3 < num)
		{
			Anclar(valor: true);
		}
		else if (anclada && (!rifle.coliderPistola.activeInHierarchy || num3 > num2))
		{
			Anclar(valor: false);
		}
	}

	public void Anclar(bool valor)
	{
		if (anclada == valor)
		{
			return;
		}
		GameManager.instance.player.Vibra(Player.TipoVibracion.cogerPistolas, mano == ControladorMano.Mano.Derecha);
		if (valor)
		{
			posRifleInicial = rifle.transform.localPosition;
			rotRifleInicial = rifle.transform.localEulerAngles;
			base.transform.SetParent(empuñadura);
			base.transform.localPosition = Vector3.zero;
			base.transform.localEulerAngles = Vector3.zero;
			base.transform.SetParent(rifle.meshPadre.transform);
			if ((bool)mano3dOtro)
			{
				mano3dOtro.SetParent(rifle.meshPadre.transform);
			}
			if ((bool)mano3dMia)
			{
				mano3dOtro.localEulerAngles = new Vector3(-8f, 0f, 0f);
			}
		}
		else
		{
			base.transform.SetParent(GameManager.instance.player.tJugador);
			rifle.transform.localPosition = posRifleInicial;
			rifle.transform.localEulerAngles = rotRifleInicial;
			if ((bool)mano3dOtro)
			{
				mano3dOtro.SetParent(otraMano);
			}
			float num = 25f;
			if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.index)
			{
				num += 30f;
			}
			else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
			{
				num += 35f;
			}
			if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.nolo && Config.modoDeJuego != Config.ModosDeJuego.menu)
			{
				num += 40f;
			}
			if ((bool)mano3dMia)
			{
				mano3dOtro.localEulerAngles = new Vector3(-8f + num, 0f, 0f);
			}
		}
		anclada = valor;
	}
}
public class ControladorMenu : MonoBehaviour
{
	public enum PosicionEnMenu
	{
		Inicio,
		Opciones,
		LeaderBoard,
		Pais,
		Nivel,
		Historia,
		Final,
		Online,
		InicioEleccionManos
	}

	public enum PosicionEnMenuInicio
	{
		Inicio,
		Single,
		Arena
	}

	public enum EstadoOnline
	{
		Activo,
		ActualizacionNecesaria,
		ServerOff
	}

	public PosicionEnMenu posicionActual;

	public PosicionEnMenuInicio posicionInicio;

	public GameObject[] partesMenu;

	public GameObject[] posicionesInicio;

	public GameObject[] partesPaises;

	public GameObject pantallaDemo;

	public Config.ModoDePartida modoQueQuieroJugar;

	public AudioSource audioSourceMenu;

	public TextMeshProUGUI tituloPais;

	public TextMeshProUGUI tituloPosicionInicio;

	public EstadoOnline estadoOnline;

	public MeshRenderer pantallaTv;

	[HideInInspector]
	public GestorVinetas gestorViñetas;

	private ControladorOpciones m_controladorOpciones;

	private ControlInfoServidor m_infoServidor;

	private ControladorTablaLeaderboards m_TablaLeaderboards;

	public UnityEvent AccionCerrarActual;

	private Coroutine corDesconectarPhoton;

	private bool pausado;

	private bool story;

	private int posicionAnteriorOpciones = 8;

	private bool idiomaInicialEspecial;

	private bool estaCargandoLaTienda;

	private bool numerosPuestosManualmente;

	private string numeroPun = "";

	public TextMeshProUGUI tituloUnirseCrearOnline;

	public TextMeshProUGUI textoIdDeLaSala;

	public TextMeshProUGUI textoIdDelAmigo;

	public TextMeshProUGUI textoMensajeOnline;

	private bool unirseLlamado;

	private bool desactivadoPorSoloUnSensor;

	private int numVecesGolpeArribaIzquierdaOpciones;

	private void Awake()
	{
		if (GameManager.instance.seAcabanDePasarElBoss && GameManager.instance.paisActual + 1 < 15)
		{
			GameManager.instance.Resetear();
			Config.mundo = "Mundo" + (GameManager.instance.paisActual + 1);
			modoQueQuieroJugar = Config.ModoDePartida.Cooperativo;
			GameManager.instance.seAcabanDePasarElBoss = false;
			if (GameManager.instance.acaboDeSerMaster)
			{
				PhotonNetwork.AplicarVersionPUN(PhotonNetwork.versionPUNPropia);
				SeleccionarNivel(0);
			}
			else
			{
				UnirsePartidaOnline();
			}
			return;
		}
		modoQueQuieroJugar = Config.ModoDePartida.Solo;
		GameManager.instance.seAcabanDePasarElBoss = false;
		if (!GameManager.instance.bloquearBotones)
		{
			Config.modoDeJuego = Config.ModosDeJuego.menu;
			GameManager.instance.Resetear();
			GameManager.instance.ultimaRotacionCabeza = Vector3.zero;
			GameManager.instance.ultimaPosicionRelativaCabeza = Vector3.zero;
			m_infoServidor = GetComponent<ControlInfoServidor>();
		}
	}

	private void Start()
	{
		GameManager.instance.bloquearBotones = false;
		GameManager.instance.m_musica.CambiarMusicaATiempoNormal(sinFadeOut: true);
		m_controladorOpciones = GetComponent<ControladorOpciones>();
		m_TablaLeaderboards = partesMenu[2].GetComponent<ControladorTablaLeaderboards>();
		if (GameManager.instance.UltimoModoHaSidoOnline)
		{
			CambiarEstadoMenu(0, inicio: true);
		}
		else if (GameManager.instance.ponerMenuPaisActual)
		{
			CambiarEstadoMenu(3, inicio: true);
			SeleccionarPais(GameManager.instance.paisActual);
		}
		else if (GameManager.instance.vengoDeBoss)
		{
			bool flag = Config.plataforma == Config.PlataformaJuego.SteamVR || Config.plataforma == Config.PlataformaJuego.Oculus || Config.plataforma != Config.PlataformaJuego.PS4;
			if (Config.plataforma == Config.PlataformaJuego.SteamVR && Config.versionConSteamCompletamenteAnulado)
			{
				flag = false;
			}
			if (!flag)
			{
				CambiarEstadoMenu(3, inicio: true);
			}
			else
			{
				AbrirLeaderBoard(GameManager.instance.paisActual - 1);
			}
		}
		else
		{
			CambiarEstadoMenu(8, inicio: true);
		}
		GameManager.instance.UltimoModoHaSidoOnline = false;
		if (GameManager.instance.vengoDeBoss && GameManager.instance.paisActual > 13)
		{
			MostrarFinal();
		}
		if ((bool)LoadingCamera.instance)
		{
			LoadingCamera.instance.ActivarCamaraNegraInstantanea();
		}
		StartCoroutine(DesactivarCamaraOscura());
		DesconectarPhoton();
	}

	public void PararDesconectarPhoton()
	{
		if (corDesconectarPhoton != null)
		{
			StopCoroutine(corDesconectarPhoton);
		}
	}

	private void DesconectarPhoton()
	{
		if (PhotonNetwork.IsConnected)
		{
			corDesconectarPhoton = StartCoroutine(DesconectarPhotonCor());
		}
	}

	private IEnumerator DesconectarPhotonCor()
	{
		while (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
			yield return new WaitForSeconds(2f);
		}
	}

	private IEnumerator DesactivarCamaraOscura()
	{
		while (!GameManager.instance.player)
		{
			yield return null;
		}
		yield return new WaitForSeconds(1f);
		if ((bool)LoadingCamera.instance)
		{
			LoadingCamera.instance.DesactivarCamaraNegraAsync();
		}
	}

	private void Update()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			if (!gestorViñetas)
			{
				gestorViñetas = partesMenu[5].GetComponent<GestorVinetas>();
			}
			if (GameManager.instance.cascoQuitado || GameManager.instance.dashOpened)
			{
				if (!pausado)
				{
					Time.timeScale = 0f;
					gestorViñetas.PausarSonido(pausar: true);
					GameManager.instance.m_musica.ActivarMusica(activar: false);
					pausado = true;
				}
			}
			else if (pausado)
			{
				Time.timeScale = 1f;
				gestorViñetas.PausarSonido(pausar: false);
				GameManager.instance.m_musica.ActivarMusica(activar: true);
				pausado = false;
			}
		}
		if (InputsController.instance.botonAtras && AccionCerrarActual != null)
		{
			AccionCerrarActual.Invoke();
		}
		if (Debugs.SimularPlayer == 1)
		{
			return;
		}
		if (!Config.tiene2Sensores)
		{
			if (!desactivadoPorSoloUnSensor)
			{
				SaltarEleccionNumManos();
			}
		}
		else if (desactivadoPorSoloUnSensor)
		{
			volverAPonerSeleccionNumManos();
		}
	}

	public void CambiarEstadoMenu(int posicion, bool inicio = false)
	{
		switch ((PosicionEnMenu)posicion)
		{
		case PosicionEnMenu.Inicio:
		case PosicionEnMenu.InicioEleccionManos:
			partesMenu[0].SetActive(value: true);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Opciones:
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: true);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.LeaderBoard:
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: true);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Pais:
			posicionAnteriorOpciones = 4;
			if (PersistentDataManager.GetInt("IntroVista") == 0 && !Debugs.nivelesDesbloqueados)
			{
				MostrarHistoria();
				break;
			}
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: true);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Nivel:
			posicionAnteriorOpciones = 5;
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: true);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Historia:
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: true);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Final:
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: true);
			partesMenu[7].SetActive(value: false);
			break;
		case PosicionEnMenu.Online:
			partesMenu[0].SetActive(value: false);
			partesMenu[1].SetActive(value: false);
			partesMenu[2].SetActive(value: false);
			partesMenu[3].SetActive(value: false);
			partesMenu[4].SetActive(value: false);
			partesMenu[5].SetActive(value: false);
			partesMenu[6].SetActive(value: false);
			partesMenu[7].SetActive(value: true);
			AccionIntroducirElId("0");
			textoIdDeLaSala.text = PhotonNetwork.versionPUNPropia.ToString();
			break;
		}
	}

	public void CargarNivel(int num)
	{
		Config.mundo = "Mundo" + num;
		LoadingCamera.instance.CargarEscena("Mundo" + num);
	}

	public void MoverteMenuInicio(int num)
	{
		if (GameManager.instance.verisionConOnlineCompletamenteAnulado)
		{
			switch (num)
			{
			case 0:
				CambiarEstadoMenu(3);
				return;
			default:
				num = 3;
				break;
			case 3:
				break;
			}
		}
		switch (num)
		{
		case 0:
			posicionAnteriorOpciones = 0;
			posicionesInicio[0].SetActive(value: true);
			posicionesInicio[1].SetActive(value: false);
			posicionesInicio[2].SetActive(value: false);
			posicionesInicio[3].SetActive(value: false);
			CambiarEstadoMenu(0);
			if (Config.tipoDeControl == Config.TipoControl.DosManos)
			{
				tituloPosicionInicio.text = LanguageManager.instance.DameTexto("#DosManosSelected", tituloPosicionInicio);
			}
			else
			{
				tituloPosicionInicio.text = LanguageManager.instance.DameTexto("#UnaManoSelected", tituloPosicionInicio);
			}
			break;
		case 1:
			posicionAnteriorOpciones = 1;
			posicionesInicio[0].SetActive(value: false);
			posicionesInicio[1].SetActive(value: true);
			posicionesInicio[2].SetActive(value: false);
			posicionesInicio[3].SetActive(value: false);
			tituloPosicionInicio.text = LanguageManager.instance.DameTexto("#StoryModeSelected", tituloPosicionInicio);
			break;
		case 2:
			posicionAnteriorOpciones = 2;
			posicionesInicio[0].SetActive(value: false);
			posicionesInicio[1].SetActive(value: false);
			posicionesInicio[2].SetActive(value: true);
			posicionesInicio[3].SetActive(value: false);
			tituloPosicionInicio.text = LanguageManager.instance.DameTexto("#ArenaModeSelected", tituloPosicionInicio);
			break;
		case 3:
			posicionAnteriorOpciones = 3;
			posicionesInicio[0].SetActive(value: false);
			posicionesInicio[1].SetActive(value: false);
			posicionesInicio[2].SetActive(value: false);
			posicionesInicio[3].SetActive(value: true);
			CambiarEstadoMenu(0);
			tituloPosicionInicio.text = "";
			break;
		}
	}

	public void AccionStoryMode(int num)
	{
		story = true;
		if (num == 1)
		{
			modoQueQuieroJugar = Config.ModoDePartida.Cooperativo;
			CambiarEstadoMenu(7);
			tituloUnirseCrearOnline.text = LanguageManager.instance.DameTexto("#COOP", tituloUnirseCrearOnline);
		}
		else
		{
			modoQueQuieroJugar = Config.ModoDePartida.Solo;
			CambiarEstadoMenu(3);
		}
	}

	public void AccionEntrarEnArena()
	{
		story = false;
		CambiarEstadoMenu(7);
		tituloUnirseCrearOnline.text = LanguageManager.instance.DameTexto("#ArenaMode", tituloUnirseCrearOnline);
		Config.modoDePartida = Config.ModoDePartida.Competitivo;
		modoQueQuieroJugar = Config.ModoDePartida.Competitivo;
	}

	public void AccionArenaMode(int num)
	{
		story = false;
		switch (num)
		{
		case 0:
			Config.mundo = "MundoOnline1";
			Config.numJugadoresOnline = 2;
			break;
		case 1:
			Config.mundo = "MundoOnline2";
			Config.numJugadoresOnline = 4;
			break;
		case 2:
			Config.mundo = "MundoOnline2";
			Config.numJugadoresOnline = 8;
			break;
		default:
			Config.mundo = "MundoOnline1";
			break;
		}
		Config.modoDePartida = Config.ModoDePartida.Competitivo;
		GameManager.instance.UltimoModoHaSidoOnline = true;
		PhotonNetwork.OfflineMode = false;
		Config.modoDeJuego = Config.ModosDeJuego.Online;
		SceneManager.LoadScene("EscenaIniciandoOnline");
	}

	private void PonerPantallaDemo()
	{
		for (int i = 0; i < partesPaises.Length; i++)
		{
			partesPaises[i].SetActive(value: false);
		}
		pantallaDemo.SetActive(value: true);
	}

	public void CerrarPantallaDemo()
	{
		for (int i = 0; i < partesPaises.Length; i++)
		{
			partesPaises[i].SetActive(value: true);
		}
		pantallaDemo.SetActive(value: false);
	}

	public void ComprarJuego()
	{
		if (Config.plataforma == Config.PlataformaJuego.Oculus && (bool)InputsController.instance && (bool)InputsController.instance.controladorVR && (bool)(ControladorVROculus)InputsController.instance.controladorVR)
		{
			((ControladorVROculus)InputsController.instance.controladorVR).ComprarQuest();
		}
		CerrarPantallaDemo();
	}

	public void SeleccionarPais(int pais)
	{
		if (Config.modoDemo && pais > 0)
		{
			PonerPantallaDemo();
			return;
		}
		GameManager.instance.paisActual = pais;
		Config.mundo = "Mundo" + (pais + 1);
		if (GameManager.instance.paisActual == PlayerProgreso.instance.ultimoPaisPasado && PlayerProgreso.instance.ultimoNivelPasado == 0 && !Debugs.nivelesDesbloqueados && !GameManager.instance.ponerMenuPaisActual)
		{
			SeleccionarNivel(0);
			return;
		}
		GameManager.instance.ponerMenuPaisActual = false;
		CambiarEstadoMenu(4);
		tituloPais.text = GameManager.instance.NombrePais(pais, tituloPais);
	}

	public void SeleccionarNivel(int nivel)
	{
		GameManager.instance.nivelActual = nivel;
		GameManager.instance.bloquearBotones = true;
		GameManager.instance.nivelInicioMenu = true;
		if (modoQueQuieroJugar == Config.ModoDePartida.Cooperativo)
		{
			Config.modoDePartida = Config.ModoDePartida.Cooperativo;
			Config.numJugadoresOnline = 2;
			PhotonNetwork.OfflineMode = false;
			GameManager.instance.UltimoModoHaSidoOnline = true;
			SceneManager.LoadScene("EscenaIniciandoOnline");
			Config.modoDeJuego = Config.ModosDeJuego.Online;
		}
		else if (modoQueQuieroJugar == Config.ModoDePartida.Competitivo)
		{
			Config.modoDePartida = Config.ModoDePartida.Competitivo;
			PhotonNetwork.OfflineMode = false;
			GameManager.instance.UltimoModoHaSidoOnline = true;
			Config.modoDeJuego = Config.ModosDeJuego.Online;
			SceneManager.LoadScene("EscenaIniciandoOnline");
		}
		else
		{
			PararDesconectarPhoton();
			Config.modoDePartida = Config.ModoDePartida.Solo;
			Config.numJugadoresOnline = 0;
			GameManager.instance.UltimoModoHaSidoOnline = false;
			Config.modoDeJuego = Config.ModosDeJuego.Offline;
			PhotonNetwork.OfflineMode = true;
			PhotonNetwork.CreateRoom(null);
			CargarNivel(GameManager.instance.paisActual + 1);
		}
	}

	public void MostrarHistoria()
	{
		CambiarEstadoMenu(5);
	}

	public void MostrarFinal()
	{
		CambiarEstadoMenu(6);
		try
		{
			GameManager.instance.player.controladorManoDerecha.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoDerecha.animManos.MenuNormal();
			GameManager.instance.player.controladorManoIzquierda.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoIzquierda.animManos.MenuNormal();
		}
		catch
		{
		}
	}

	public void Cerrar(int direccion)
	{
		switch (direccion)
		{
		case 0:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(0);
			break;
		case 1:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(1);
			break;
		case 2:
			CambiarEstadoMenu(3);
			break;
		case 3:
			MoverteMenuInicio(3);
			break;
		case 4:
			partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: true);
			partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: false);
			break;
		}
	}

	public void SeleccionarNumManos(int numero)
	{
		Config.tipoDeControl = (Config.TipoControl)numero;
		MoverteMenuInicio(0);
	}

	public void AbrirOpciones()
	{
		CambiarEstadoMenu(1);
		m_controladorOpciones.CargarValoresOpciones();
		idiomaInicialEspecial = LanguageManager.instance.EsIdiomaEspecial();
	}

	public void CerrarOpciones()
	{
		m_controladorOpciones.GuardarAjustes();
		if (!LanguageManager.instance.EsIdiomaEspecial() && idiomaInicialEspecial)
		{
			LoadingCamera.instance.CargarEscena("MenuPrincipal");
			return;
		}
		if (LanguageManager.instance.EsIdiomaEspecial())
		{
			pantallaTv.material.shader = Shader.Find("Unlit/Texture");
		}
		switch (posicionAnteriorOpciones)
		{
		case 0:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(0);
			break;
		case 1:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(1);
			break;
		case 2:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(2);
			break;
		case 3:
			CambiarEstadoMenu(0);
			MoverteMenuInicio(3);
			break;
		case 4:
			CambiarEstadoMenu(3);
			break;
		case 5:
			SeleccionarPais(GameManager.instance.paisActual);
			break;
		case 6:
			partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: true);
			partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: false);
			break;
		case 8:
			volverAPonerSeleccionNumManos();
			break;
		case 7:
			break;
		}
	}

	public void AbrirLeaderBoard(int pais)
	{
		CambiarEstadoMenu(2);
		m_TablaLeaderboards.AbrirTabla("Mundo" + (pais + 1), GameManager.instance.NombrePais(pais), esEvento: false);
	}

	private void PonerTiendaPlus()
	{
		StartCoroutine(PonerNuestroMensajeDeNoPsPlus());
	}

	private IEnumerator PonerNuestroMensajeDeNoPsPlus()
	{
		yield return new WaitForSeconds(0.2f);
		estaCargandoLaTienda = false;
	}

	public void AccionIntroducirElId(string num)
	{
		if (num == "0")
		{
			if (numeroPun.Length > 0)
			{
				numeroPun = numeroPun.Remove(numeroPun.Length - 1);
			}
			if (numeroPun.Length == 0)
			{
				textoIdDelAmigo.text = "______";
				return;
			}
		}
		else if (numeroPun.Length < 4)
		{
			numeroPun += num;
			numerosPuestosManualmente = true;
		}
		textoIdDelAmigo.text = numeroPun;
		int.TryParse(numeroPun, out PhotonNetwork.versionPUNPartida);
	}

	public void UnirsePartidaOnline()
	{
		if ((Config.cooperativoAnuladoForzosamente && modoQueQuieroJugar == Config.ModoDePartida.Cooperativo) || (Config.arenaAnuladoForzosamente && modoQueQuieroJugar == Config.ModoDePartida.Competitivo))
		{
			MostrarMensajeNoActivo();
			return;
		}
		GameManager.instance.UltimoModoHaSidoOnline = true;
		PhotonNetwork.AplicarVersionPUN(PhotonNetwork.versionPUNPartida);
		PhotonNetwork.OfflineMode = false;
		Config.modoDeJuego = Config.ModosDeJuego.Online;
		SceneManager.LoadScene("EscenaIniciandoOnline");
	}

	public void CrearPartidaOnline()
	{
		if (Config.modoDemo)
		{
			MostrarMensajeDemoArena();
			return;
		}
		PhotonNetwork.AplicarVersionPUN(PhotonNetwork.versionPUNPropia);
		if ((Config.cooperativoAnuladoForzosamente && modoQueQuieroJugar == Config.ModoDePartida.Cooperativo) || (Config.arenaAnuladoForzosamente && modoQueQuieroJugar == Config.ModoDePartida.Competitivo))
		{
			MostrarMensajeNoActivo();
			return;
		}
		if (story)
		{
			CambiarEstadoMenu(3);
			return;
		}
		CambiarEstadoMenu(0);
		MoverteMenuInicio(2);
	}

	public void MostrarMensajeOnline(int numeroMensaje)
	{
		partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: true);
		textoMensajeOnline.text = LanguageManager.instance.DameTexto("#TIMEEXPIRED-CONNECTIONLOSED", textoMensajeOnline);
	}

	public void MostrarMensajeNoActivo()
	{
		partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: true);
		partesMenu[7].transform.GetChild(3).gameObject.SetActive(value: false);
		textoMensajeOnline.text = LanguageManager.instance.DameTexto("#OnlineDisabled", textoMensajeOnline);
	}

	public void MostrarMensajeDemoArena()
	{
		partesMenu[7].transform.GetChild(0).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(3).gameObject.SetActive(value: true);
	}

	public void CerrarMensajeDemoArena()
	{
		partesMenu[7].transform.GetChild(0).gameObject.SetActive(value: true);
		partesMenu[7].transform.GetChild(1).gameObject.SetActive(value: true);
		partesMenu[7].transform.GetChild(2).gameObject.SetActive(value: false);
		partesMenu[7].transform.GetChild(3).gameObject.SetActive(value: false);
	}

	private void SaltarEleccionNumManos()
	{
		SeleccionarNumManos(0);
		desactivadoPorSoloUnSensor = true;
		posicionesInicio[0].transform.Find("Cerrar").gameObject.SetActive(value: false);
	}

	private void volverAPonerSeleccionNumManos()
	{
		CambiarEstadoMenu(0);
		MoverteMenuInicio(3);
		desactivadoPorSoloUnSensor = false;
		posicionesInicio[0].transform.Find("Cerrar").gameObject.SetActive(value: true);
	}

	public void AbrirTodo()
	{
		numVecesGolpeArribaIzquierdaOpciones++;
		if (numVecesGolpeArribaIzquierdaOpciones >= 5)
		{
			if (Debugs.debugs)
			{
				Debugs.debugs = false;
				Debugs.nivelesDesbloqueados = false;
			}
			else
			{
				Debugs.debugs = true;
				Debugs.nivelesDesbloqueados = true;
			}
			UnityEngine.Debug.Log("Debugs: " + Debugs.debugs);
			numVecesGolpeArribaIzquierdaOpciones = 0;
			if (Debugs.debugs)
			{
				audioSourceMenu.clip = Resources.Load<AudioClip>("EfectosSonido/seleccionar_boton_menu");
			}
			else
			{
				audioSourceMenu.clip = Resources.Load<AudioClip>("EfectosSonido/seleccionar_boton_menu_cerrar");
			}
			audioSourceMenu.Play();
		}
	}
}
public class ControladorOpciones : MonoBehaviour
{
	public RectTransform sliderMusica;

	public RectTransform sliderFx;

	public TextMeshProUGUI textoIdioma;

	public TextMeshProUGUI textoVoz;

	public TextMeshProUGUI textoVibracion;

	public GameObject PanelBotones;

	public GameObject PanelPreguntaProgreso;

	public MeshRenderer pantallaTv;

	public AudioMixer audioMixer;

	private float nivelMusica = 0.5f;

	private float nivelFx = 0.5f;

	private void Start()
	{
		CargarValoresOpciones();
	}

	private void Update()
	{
	}

	public void CargarValoresOpciones()
	{
		nivelMusica = PersistentDataManager.GetFloat("Volumen_musica", 0.6f);
		SetValorSlider(0, nivelMusica);
		nivelFx = PersistentDataManager.GetFloat("Volumen_fx", 0.6f);
		SetValorSlider(1, nivelFx);
		textoIdioma.text = LanguageManager.instance.DameTexto(LanguageManager.instance.idiomaActual, textoIdioma);
		if (LanguageManager.instance.idiomaActual == "Chinese" || LanguageManager.instance.idiomaActual == "Japanese" || LanguageManager.instance.idiomaActual == "Korean")
		{
			pantallaTv.material.shader = Shader.Find("Unlit/Texture");
		}
		GameManager.instance.vozHabilitada = ((PersistentDataManager.GetInt("Voz", 1) != 0) ? true : false);
		if (GameManager.instance.vozHabilitada)
		{
			textoVoz.text = LanguageManager.instance.DameTexto("#yes", textoVoz);
		}
		else
		{
			textoVoz.text = LanguageManager.instance.DameTexto("#no", textoVoz);
		}
		GameManager.instance.vibracionHabilitada = ((PersistentDataManager.GetInt("Vibracion", 1) != 0) ? true : false);
		if (GameManager.instance.vibracionHabilitada)
		{
			textoVibracion.text = LanguageManager.instance.DameTexto("#yes", textoVibracion);
		}
		else
		{
			textoVibracion.text = LanguageManager.instance.DameTexto("#no", textoVibracion);
		}
	}

	public void GuardarAjustes()
	{
		PersistentDataManager.SetFloat("Volumen_musica", nivelMusica);
		PersistentDataManager.SetFloat("Volumen_fx", nivelFx);
		PersistentDataManager.SetInt("Calidad", (int)CalidadManager.instance.GetCalidad());
		PersistentDataManager.SetInt("Voz", GameManager.instance.vozHabilitada ? 1 : 0);
		PersistentDataManager.SetInt("Vibracion", GameManager.instance.vibracionHabilitada ? 1 : 0);
		PersistentDataManager.SaveData();
	}

	public void AccionBotonIdioma()
	{
		LanguageManager.instance.CambiarIdioma();
		textoIdioma.text = LanguageManager.instance.DameTexto(LanguageManager.instance.idiomaActual, textoIdioma);
	}

	public void AccionRestaurarProgreso()
	{
		PanelPreguntaProgreso.SetActive(value: true);
		PanelBotones.SetActive(value: false);
	}

	public void AccionAceptarReiniciarProgreso()
	{
		PlayerProgreso.instance.ResetearEstado();
		GameManager.instance.vengoDeBoss = false;
		GameManager.instance.nuevoPaisDesloqueado = false;
		GameManager.instance.ponerMenuPaisActual = false;
		SceneManager.LoadScene(SceneManager.GetActiveScene().name);
	}

	public void AccionCancelarReiniciarProgreso()
	{
		PanelPreguntaProgreso.SetActive(value: false);
		PanelBotones.SetActive(value: true);
	}

	public void AccionBotonSubirValorSlider(int indexSlider)
	{
		BajarSubirValorSlider(indexSlider, subir: true);
	}

	public void AccionBotonBajarValorSlider(int indexSlider)
	{
		BajarSubirValorSlider(indexSlider, subir: false);
	}

	private void BajarSubirValorSlider(int indexSlider, bool subir)
	{
		float num = 0f;
		switch (indexSlider)
		{
		case 0:
			num = nivelMusica;
			break;
		case 1:
			num = nivelFx;
			break;
		}
		if (subir)
		{
			num += 0.1f;
			if (num > 1f)
			{
				num = 1f;
			}
		}
		else
		{
			num -= 0.1f;
			if (num < 0f)
			{
				num = 0f;
			}
		}
		SetValorSlider(indexSlider, num);
	}

	private void SetValorSlider(int indexSlider, float valor)
	{
		RectTransform rectTransform = null;
		switch (indexSlider)
		{
		case 0:
			nivelMusica = valor;
			ActualizarAudioMixer("Musica", nivelMusica);
			rectTransform = sliderMusica;
			break;
		case 1:
			nivelFx = valor;
			ActualizarAudioMixer("Fx", nivelFx);
			rectTransform = sliderFx;
			break;
		}
		Vector3 localPosition = rectTransform.localPosition;
		localPosition.x = Mathf.Lerp(-130f, 130f, valor);
		rectTransform.localPosition = localPosition;
	}

	private void ActualizarAudioMixer(string grupo, float valor)
	{
		switch (Mathf.RoundToInt(valor * 10f))
		{
		case 0:
			valor = -80f;
			break;
		case 1:
			valor = -50f;
			break;
		case 2:
			valor = -20f;
			break;
		case 3:
			valor = -10f;
			break;
		case 4:
			valor = -6f;
			break;
		case 5:
			valor = -3f;
			break;
		case 6:
			valor = -1.5f;
			break;
		case 7:
			valor = 0f;
			break;
		case 8:
			valor = 2f;
			break;
		case 9:
			valor = 5f;
			break;
		case 10:
			valor = 10f;
			break;
		}
		audioMixer.SetFloat(grupo, valor);
	}

	public void AccionBotonVoz()
	{
		if (GameManager.instance.vozHabilitada)
		{
			GameManager.instance.vozHabilitada = false;
			textoVoz.text = LanguageManager.instance.DameTexto("#no", textoVoz);
		}
		else
		{
			GameManager.instance.vozHabilitada = true;
			textoVoz.text = LanguageManager.instance.DameTexto("#yes", textoVoz);
		}
	}

	public void AccionBotonVibracion()
	{
		if (GameManager.instance.vibracionHabilitada)
		{
			GameManager.instance.vibracionHabilitada = false;
			textoVibracion.text = LanguageManager.instance.DameTexto("#no", textoVibracion);
		}
		else
		{
			GameManager.instance.vibracionHabilitada = true;
			textoVibracion.text = LanguageManager.instance.DameTexto("#yes", textoVibracion);
		}
	}
}
public class ControladorTVs : MonoBehaviour
{
	public enum PosicionEnMenu
	{
		Inicio,
		Info,
		PowerUp,
		LevelClear,
		GameOver,
		OnlinePlayersMuertos,
		GanadorCompetitivo,
		EsperandoJugadores,
		Apagar
	}

	public PosicionEnMenu posicionActual;

	public GameObject panelLevelClear;

	public GameObject panelInicio;

	public GameObject panelInfo;

	public GameObject panelGameOver;

	public GameObject panelEsperandoJugadores;

	public GameObject panelOnlinePlayersMuertos;

	private TextMeshProUGUI textoNivel;

	public Camera camara;

	public Camera camaraChica;

	public TextMeshProUGUI textoOnlinePlayers;

	public TextMeshProUGUI textoEquipoGanador;

	public TextMeshProUGUI textoJugadoresGanadores;

	public TextMeshProUGUI textoEsperandoJugadores;

	private bool activarCamara;

	public TextMeshProUGUI puntosRacha;

	public TextMeshProUGUI totalPuntos;

	public TextMeshProUGUI totalRacha;

	public GameObject infoEstandar;

	public GameObject mensajeBinarity;

	public OLDTVScreen efectoTele;

	public GameObject EntradaBoss;

	public TextMeshProUGUI nombreBoss;

	public TextMeshProUGUI paisBoss;

	public TextMeshProUGUI fraseBoss;

	public TextMeshProUGUI newRecord;

	public TextMeshProUGUI puntosTotalesFinalNivel;

	public bool enAnimacionBoss;

	private GameObject[] chicas;

	public GameObject[] apagarObjetosGanadorOnline;

	public TextMeshProUGUI textoPuntuacion;

	private Coroutine mostrandoPuntos;

	private string textoRachaBase;

	private int chicaActual;

	private int chicaActualFinal = 3;

	private AudioSource audioSourceEntradaBoss;

	private AudioSource audioSourceEntradaBoss2;

	private AudioClip[] audioFrasesBoss;

	private void Start()
	{
		ApagarPaneles();
		CambiarTextos();
		StartCoroutine(EfectoTV());
		chicas = new GameObject[6];
		for (int i = 0; i < mensajeBinarity.transform.GetChild(4).childCount; i++)
		{
			chicas[i] = mensajeBinarity.transform.GetChild(4).GetChild(i).gameObject;
		}
	}

	private void OnEnable()
	{
		chicas = new GameObject[6];
		for (int i = 0; i < mensajeBinarity.transform.GetChild(4).childCount; i++)
		{
			chicas[i] = mensajeBinarity.transform.GetChild(4).GetChild(i).gameObject;
		}
	}

	private void Update()
	{
		if (activarCamara)
		{
			camara.enabled = true;
			activarCamara = false;
		}
		else if (camara.enabled && !enAnimacionBoss)
		{
			camara.enabled = false;
		}
		if (Debugs.debugs)
		{
			if (Input.GetKeyDown(KeyCode.K))
			{
				ModificarPuntosTotales(1000);
			}
			if (Input.GetKeyDown(KeyCode.L))
			{
				ModificarRacha(50);
			}
			if (Input.GetKeyDown(KeyCode.J))
			{
				MostrarPuntosActuales(500);
			}
		}
	}

	public void CambiarTV(PosicionEnMenu estado, int param1 = 0)
	{
		if (!enAnimacionBoss)
		{
			posicionActual = estado;
			switch (estado)
			{
			case PosicionEnMenu.Apagar:
				ApagarPaneles();
				break;
			case PosicionEnMenu.Inicio:
				InicioNivel();
				break;
			case PosicionEnMenu.Info:
				NivelIniciado();
				break;
			case PosicionEnMenu.LevelClear:
				NivelCompletado();
				break;
			case PosicionEnMenu.GameOver:
				GameOver();
				break;
			case PosicionEnMenu.OnlinePlayersMuertos:
				PlayersMuertos();
				break;
			case PosicionEnMenu.GanadorCompetitivo:
				GanadorOnline(param1);
				break;
			case PosicionEnMenu.EsperandoJugadores:
				EsperandoJugadores();
				break;
			case PosicionEnMenu.PowerUp:
				break;
			}
		}
	}

	public void NivelCompletado()
	{
		ApagarPaneles();
		panelLevelClear.SetActive(value: true);
		puntosTotalesFinalNivel.gameObject.SetActive(value: true);
		puntosTotalesFinalNivel.text = GameManager.instance.m_salaManager.puntosTotalesNivelAnterior.ToString();
		textoEquipoGanador.text = "";
		textoJugadoresGanadores.text = "";
		base.transform.localEulerAngles = new Vector3(-40f, -180f, 0f);
		if ((bool)textoPuntuacion)
		{
			textoPuntuacion.gameObject.SetActive(value: false);
		}
		GameObject[] array = apagarObjetosGanadorOnline;
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: true);
			}
		}
		ActivarDesactivarCamara();
	}

	public void InicioNivel()
	{
		ApagarPaneles();
		CambiarTextos();
		panelInicio.SetActive(value: true);
		base.transform.localEulerAngles = new Vector3(0f, -180f, 0f);
		ActivarDesactivarCamara();
	}

	public void NivelIniciado()
	{
		ApagarPaneles();
		panelInfo.SetActive(value: true);
		base.transform.localEulerAngles = new Vector3(0f, -180f, 0f);
		ActivarDesactivarCamara();
		newRecord.gameObject.SetActive(value: false);
	}

	public void GameOver()
	{
		ApagarPaneles();
		panelGameOver.SetActive(value: true);
		base.transform.localEulerAngles = new Vector3(0f, -180f, 0f);
		ActivarDesactivarCamara();
	}

	public void EsperandoJugadores()
	{
		ApagarPaneles();
		panelEsperandoJugadores.SetActive(value: true);
		textoEsperandoJugadores.text = PartidaSync.instance.numPlayersPreparados + " /" + Config.numJugadoresOnline;
		base.transform.localEulerAngles = new Vector3(0f, -180f, 0f);
		ActivarDesactivarCamara();
	}

	public void PlayersMuertos()
	{
		ApagarPaneles();
		panelOnlinePlayersMuertos.SetActive(value: true);
		base.transform.localEulerAngles = new Vector3(0f, -180f, 0f);
		ActivarDesactivarCamara();
		string text = LanguageManager.instance.DameTexto("#YouAreDead", textoOnlinePlayers) + "<br>-<br>" + LanguageManager.instance.DameTexto("#SpectatorMode", textoOnlinePlayers);
		textoOnlinePlayers.text = text;
	}

	private void GanadorOnline(int equipoGanador)
	{
		NivelCompletado();
		if (Config.modoDePartida == Config.ModoDePartida.Competitivo)
		{
			puntosTotalesFinalNivel.gameObject.SetActive(value: false);
			textoJugadoresGanadores.gameObject.SetActive(value: true);
			textoEquipoGanador.gameObject.SetActive(value: true);
		}
		string text = LanguageManager.instance.DameTexto("#TeamXWin", textoEquipoGanador);
		text = text.Replace("X", equipoGanador.ToString());
		textoEquipoGanador.text = text;
		string text2 = "";
		int num = 0;
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key].equipo == equipoGanador && num < PartidaSync.instance.jugadores[key].puntos)
			{
				num = PartidaSync.instance.jugadores[key].puntos;
			}
		}
		foreach (int key2 in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key2].equipo == equipoGanador)
			{
				text2 = ((num != PartidaSync.instance.jugadores[key2].puntos) ? (text2 + PartidaSync.instance.jugadores[key2].nombre + " - " + PartidaSync.instance.jugadores[key2].puntos + "<br>") : (text2 + "MVP - " + PartidaSync.instance.jugadores[key2].nombre + " - " + PartidaSync.instance.jugadores[key2].puntos + "<br>"));
			}
		}
		if ((bool)textoPuntuacion)
		{
			textoPuntuacion.gameObject.SetActive(value: true);
			textoPuntuacion.text = PartidaSync.instance.puntuacionEquipo1 + " - " + PartidaSync.instance.puntuacionEquipo2;
		}
		GameObject[] array = apagarObjetosGanadorOnline;
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: false);
			}
		}
		textoJugadoresGanadores.text = text2;
		ActivarDesactivarCamara();
	}

	private void ApagarPaneles()
	{
		panelEsperandoJugadores.SetActive(value: false);
		panelInicio.SetActive(value: false);
		panelInfo.SetActive(value: false);
		panelOnlinePlayersMuertos.SetActive(value: false);
		panelGameOver.SetActive(value: false);
		panelLevelClear.SetActive(value: false);
		EntradaBoss.SetActive(value: false);
	}

	private void ActivarDesactivarCamara()
	{
		activarCamara = true;
	}

	private void CambiarTextos()
	{
		string text = ((Config.modoDeJuego != Config.ModosDeJuego.Online || Config.modoDePartida != Config.ModoDePartida.Competitivo) ? (GameManager.instance.NombrePais(GameManager.instance.paisActual) + " " + (GameManager.instance.nivelActual + 1)) : LanguageManager.instance.DameTexto("#CompetitiveArena", textoNivel));
		textoNivel = panelLevelClear.transform.GetChild(3).transform.GetComponent<TextMeshProUGUI>();
		textoNivel.text = text;
		TMP_FontAsset fuentePro = LanguageManager.instance.GetFuentePro();
		if ((bool)fuentePro)
		{
			textoNivel.font = fuentePro;
		}
		textoNivel = panelInicio.transform.GetChild(2).transform.GetComponent<TextMeshProUGUI>();
		textoNivel.text = text;
		if ((bool)fuentePro)
		{
			textoNivel.font = fuentePro;
		}
		textoNivel = infoEstandar.transform.GetChild(2).transform.GetComponent<TextMeshProUGUI>();
		textoNivel.text = text;
		if ((bool)fuentePro)
		{
			textoNivel.font = fuentePro;
		}
		puntosRacha.text = "0";
		if ((bool)fuentePro)
		{
			puntosRacha.font = fuentePro;
		}
		puntosRacha.gameObject.SetActive(value: false);
		totalPuntos.text = "000000";
		if ((bool)fuentePro)
		{
			totalPuntos.font = fuentePro;
		}
		textoRachaBase = LanguageManager.instance.DameTexto("#Racha", totalRacha) + ": ";
		textoRachaBase = LanguageManager.instance.DameTexto("#Racha", paisBoss) + ": ";
		totalRacha.text = textoRachaBase + "00";
		if ((bool)fuentePro)
		{
			totalRacha.font = fuentePro;
		}
		paisBoss.text = text;
	}

	public void MostrarPuntosActuales(int numeroPuntos)
	{
		puntosRacha.text = "+" + numeroPuntos;
		puntosRacha.gameObject.SetActive(value: true);
		activarCamara = true;
		if (mostrandoPuntos != null)
		{
			StopCoroutine(mostrandoPuntos);
		}
		mostrandoPuntos = StartCoroutine(MostrarNumeroPorPantalla());
	}

	private IEnumerator MostrarNumeroPorPantalla()
	{
		yield return new WaitForSeconds(3f);
		puntosRacha.gameObject.SetActive(value: false);
		activarCamara = true;
		mostrandoPuntos = null;
	}

	public void ModificarPuntosTotales(int numeroTotal)
	{
		totalPuntos.text = numeroTotal.ToString().PadLeft(6, '0');
		activarCamara = true;
	}

	public void ModificarRacha(int numeroRacha)
	{
		textoRachaBase = LanguageManager.instance.DameTexto("#Racha", totalRacha) + ": ";
		totalRacha.text = textoRachaBase + numeroRacha.ToString().PadLeft(2, '0');
		activarCamara = true;
	}

	public void MostrarOcultarMensajeTrynity(bool estado, string mensaje, bool gatillo = true, int chica = -1)
	{
		for (int i = 0; i < chicas.Length; i++)
		{
			chicas[i].SetActive(value: false);
		}
		switch (chica)
		{
		case -1:
			if (estado)
			{
				chicaActual++;
				if (chicaActual > 2)
				{
					chicaActual = 0;
				}
				chicas[chicaActual].SetActive(value: true);
			}
			break;
		case 0:
			chicas[5].SetActive(value: true);
			break;
		case 1:
			if (chicaActualFinal > 4)
			{
				chicaActualFinal = 3;
			}
			chicas[chicaActualFinal].SetActive(value: true);
			chicaActualFinal++;
			break;
		}
		if (gatillo)
		{
			mensajeBinarity.transform.GetChild(4).gameObject.SetActive(value: true);
		}
		else
		{
			mensajeBinarity.transform.GetChild(4).gameObject.SetActive(value: false);
		}
		mensajeBinarity.SetActive(estado);
		camaraChica.gameObject.SetActive(estado);
		if (estado)
		{
			StartCoroutine(CargarTextoPorLetras(mensajeBinarity.GetComponentInChildren<TextMeshProUGUI>(), mensaje));
		}
	}

	private IEnumerator CargarTextoPorLetras(TextMeshProUGUI text, string st)
	{
		int cont = 0;
		string textoPintado = "";
		string[] lineas = st.Split('/');
		_ = st.Split('/').Length;
		int lineaActual = 0;
		int countLineas = 0;
		while (cont < st.Length)
		{
			textoPintado += st[cont];
			cont++;
			if (cont < st.Length)
			{
				if (st[cont] == '/')
				{
					UnityEngine.Debug.Log(st[cont]);
					countLineas++;
					if (countLineas > 2)
					{
						textoPintado = lineas[lineaActual];
					}
					lineaActual++;
				}
				else
				{
					textoPintado += st[cont];
				}
				cont++;
			}
			text.text = textoPintado;
			TMP_FontAsset fuentePro = LanguageManager.instance.GetFuentePro();
			if ((bool)fuentePro)
			{
				text.font = fuentePro;
			}
			yield return new WaitForSeconds(0.01f);
		}
	}

	private IEnumerator EfectoTV()
	{
		while (true)
		{
			for (int i = 0; i < 120; i++)
			{
				efectoTele.staticVertical += 0.01f;
				yield return null;
			}
			for (int i = 120; i > 0; i--)
			{
				efectoTele.staticVertical -= 0.01f;
				yield return null;
			}
		}
	}

	public void PonerEntradaBoss(AudioSource aS, AudioSource aS2)
	{
		InicioNivel();
		ApagarPaneles();
		audioSourceEntradaBoss = aS;
		audioSourceEntradaBoss2 = aS2;
		aS.mute = false;
		aS.Play();
		EntradaBoss.SetActive(value: true);
		nombreBoss.text = GameManager.instance.DameNombreBossDelMundo(GameManager.instance.paisActual + 1);
		enAnimacionBoss = true;
		activarCamara = true;
		GameManager.instance.ActivarPanicoBoss();
		audioFrasesBoss = new AudioClip[4];
		audioFrasesBoss[0] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo");
		audioFrasesBoss[1] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo2");
		audioFrasesBoss[2] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo3");
		audioFrasesBoss[3] = Resources.Load<AudioClip>("EfectosSonido/Musica/boss_dialogo4");
	}

	public void CorutinaFinalEntradaBoss()
	{
		StartCoroutine(FinalEntradaBoss());
	}

	private IEnumerator FinalEntradaBoss()
	{
		EntradaBoss.GetComponent<Animator>().enabled = true;
		while (audioSourceEntradaBoss.isPlaying)
		{
			if (audioSourceEntradaBoss.time > 8.5f)
			{
				audioSourceEntradaBoss.Stop();
			}
			yield return null;
		}
		fraseBoss.transform.parent.GetChild(5).gameObject.SetActive(value: false);
		fraseBoss.transform.parent.GetChild(6).GetChild(0).gameObject.SetActive(value: false);
		fraseBoss.transform.parent.GetChild(8).gameObject.SetActive(value: false);
		audioSourceEntradaBoss2.clip = audioFrasesBoss[CalcularSonidoFraseBoss()];
		audioSourceEntradaBoss2.Play();
		yield return new WaitForSeconds(0.2f);
		fraseBoss.gameObject.SetActive(value: true);
		StartCoroutine(CargarTextoPorLetras(fraseBoss, GameManager.instance.DameMensajeBoss()));
		yield return new WaitForSeconds(2f);
		for (float i = 1f; i > 0f; i -= 0.01f)
		{
			audioSourceEntradaBoss2.volume = i;
			yield return null;
		}
		audioSourceEntradaBoss2.Stop();
		fraseBoss.transform.parent.GetChild(5).gameObject.SetActive(value: true);
		fraseBoss.transform.parent.GetChild(6).GetChild(0).gameObject.SetActive(value: true);
		fraseBoss.transform.parent.GetChild(8).gameObject.SetActive(value: true);
		fraseBoss.gameObject.SetActive(value: false);
		audioSourceEntradaBoss2.volume = 1f;
		yield return new WaitForSeconds(1f);
		int num = GameManager.instance.paisActual + 1;
		int num2 = GameManager.instance.nivelActual + 1;
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, num * 10000 + num2 * 100 + 1);
	}

	private int CalcularSonidoFraseBoss()
	{
		int num;
		for (num = GameManager.instance.paisActual; num > 3; num -= 4)
		{
		}
		return num;
	}

	public void MostrarMensajeNuevoRecord()
	{
		newRecord.gameObject.SetActive(value: true);
		activarCamara = true;
	}
}
public class ControlPirateoOculus : MonoBehaviour
{
	public GameObject canvasParaPirata;

	public GameObject canvasNoInternet;

	private string appID = "";

	private void Start()
	{
		if (Config.plataforma != Config.PlataformaJuego.Oculus)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		try
		{
			Core.AsyncInitialize();
			Entitlements.IsUserEntitledToApplication().OnComplete(ResultadoEntitlements);
		}
		catch (UnityException)
		{
			Pirata();
		}
		if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
		{
			canvasNoInternet.SetActive(value: true);
			StartCoroutine(QuitarAvisoInternetEnUnRato());
		}
	}

	private IEnumerator QuitarAvisoInternetEnUnRato()
	{
		yield return new WaitForSeconds(6f);
		canvasNoInternet.SetActive(value: false);
	}

	private void CheckAppID()
	{
		bool flag = false;
		if (appID == "")
		{
			UnityEngine.Debug.LogError("Entitlement Check: Error! missing appID " + Environment.NewLine + " You can create a new application and obtain an App ID from the developer dashboard" + Environment.NewLine + " https://dashboard.oculus.com/");
			flag = true;
		}
		if (flag)
		{
			UnityEngine.Debug.LogWarning("Invalid App ID");
		}
	}

	private void Update()
	{
	}

	private IEnumerator SalDelJuegoEnUnRato()
	{
		yield return new WaitForSeconds(4f);
		UnityEngine.Application.Quit();
	}

	private void ResultadoEntitlements(Message msg)
	{
		if (msg.IsError && !Debugs.OmitirPirateoOculus)
		{
			Pirata();
			return;
		}
		OculusNetworkManager.loginCorrecto = true;
		UnityEngine.Debug.Log("You are entitled to use this app.");
		Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
	}

	private void Pirata()
	{
		LoadingCamera.instance.pararCorrutina = true;
		UnityEngine.Debug.LogError("You are NOT entitled to use this app.");
		canvasParaPirata.SetActive(value: true);
		StartCoroutine(SalDelJuegoEnUnRato());
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("*** Login Oculus incorrecto... WTF?!");
			return;
		}
		OculusNetworkManager.m_myOculusID = msg.GetUser().OculusID;
		OculusNetworkManager.m_myID = msg.GetUser().ID;
	}
}
public class ControladorLluvia : MonoBehaviour
{
	private ParticleSystem particulasRayo;

	public Light luzEscena;

	private float intensidadInicialLuz;

	private float intensidadMaximaLuz;

	public Material materialSkybox;

	private float exposureInicialSkybox;

	private float exposureMaximoSkybox;

	public AudioClip[] clipsLuvia;

	public float probabilidadDeRayoEnCadaTick = 0.5f;

	private float tiempoDelUltimoRayo;

	private float tiempoRandomEntreRayos;

	private bool haciendoRayo;

	private bool rayoIda;

	public float tFadeRayo;

	private float intensidadAcutalLuz;

	private float exposureActualSkybox;

	private const string exposure = "_Exposure";

	private const string truenoSonido = "TruenoSonido";

	private void Start()
	{
		int maxParticles = 1000;
		if (CalidadManager.instance.GetCalidad() == CalidadManager.Calidad.Normal)
		{
			maxParticles = 5000;
		}
		if (CalidadManager.instance.GetCalidad() == CalidadManager.Calidad.Alta)
		{
			maxParticles = 10000;
		}
		ParticleSystem.MainModule main = base.transform.GetComponent<ParticleSystem>().main;
		main.maxParticles = maxParticles;
		particulasRayo = base.transform.GetChild(0).GetComponent<ParticleSystem>();
		particulasRayo.transform.SetParent(null);
		materialSkybox = RenderSettings.skybox;
		exposureInicialSkybox = materialSkybox.GetFloat("_Exposure");
		exposureMaximoSkybox = exposureInicialSkybox * 2f;
		luzEscena = RenderSettings.sun;
		intensidadInicialLuz = luzEscena.intensity;
		intensidadMaximaLuz = intensidadInicialLuz * 4f;
		AudioSource component = GetComponent<AudioSource>();
		component.clip = clipsLuvia[UnityEngine.Random.Range(0, clipsLuvia.Length)];
		component.Play();
	}

	private void ReproduceTruenoRandom()
	{
		UnityEngine.Random.Range(1, 5);
	}

	private void Update()
	{
		if (Time.time - tiempoDelUltimoRayo > tiempoRandomEntreRayos && !haciendoRayo)
		{
			ReproduceTruenoRandom();
			PonerRayoEnPosicionAleatoria();
			particulasRayo.Play();
			tiempoRandomEntreRayos = UnityEngine.Random.Range(1, 10);
			tFadeRayo = 0f;
			haciendoRayo = true;
			rayoIda = true;
		}
		if (!haciendoRayo)
		{
			return;
		}
		if (rayoIda)
		{
			if (tFadeRayo < 1f)
			{
				tFadeRayo += Time.deltaTime * 5f;
				if (tFadeRayo > 1f)
				{
					tFadeRayo = 1f;
				}
				float num = UnityEngine.Random.Range(0.5f, 1f);
				luzEscena.intensity = intensidadMaximaLuz * num;
				materialSkybox.SetFloat("_Exposure", exposureMaximoSkybox * num);
			}
			else
			{
				intensidadAcutalLuz = luzEscena.intensity;
				exposureActualSkybox = materialSkybox.GetFloat("_Exposure");
				tFadeRayo = 0f;
				rayoIda = false;
			}
		}
		else if (tFadeRayo < 1f)
		{
			tFadeRayo += Time.deltaTime * 5f;
			if (tFadeRayo > 1f)
			{
				tFadeRayo = 1f;
			}
			luzEscena.intensity = Mathf.Lerp(intensidadAcutalLuz, intensidadInicialLuz, tFadeRayo);
			materialSkybox.SetFloat("_Exposure", Mathf.Lerp(exposureActualSkybox, exposureInicialSkybox, tFadeRayo));
		}
		else
		{
			haciendoRayo = false;
			tiempoDelUltimoRayo = Time.time;
		}
	}

	private void PonerRayoEnPosicionAleatoria()
	{
		Vector3 position = base.transform.position;
		position.y = particulasRayo.transform.position.y;
		position.x = base.transform.position.x + (float)UnityEngine.Random.Range(-80, 80);
		position.z = base.transform.position.z + (float)UnityEngine.Random.Range(-80, 80);
		particulasRayo.transform.position = position;
	}

	private void OnDestroy()
	{
		if (luzEscena != null)
		{
			luzEscena.intensity = intensidadInicialLuz;
		}
		materialSkybox.SetFloat("_Exposure", exposureInicialSkybox);
	}
}
public class ControladorRudder : ILocomotion
{
	public Vector3 movimientoRudder;

	public override void UpdateAxes(Controller3dRudder controller3dRudder, Vector4 axesWithFactor)
	{
		movimientoRudder.x = axesWithFactor.x;
		movimientoRudder.y = axesWithFactor.z;
		movimientoRudder.z = axesWithFactor.w;
	}

	private void Start()
	{
		if (!Sdk3dRudder.IsDeviceConnected(GetComponent<Controller3dRudder>().PortNumber))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class ControladorSonidosMensajes : MonoBehaviour
{
	public AudioSource[] adioSourcesMensajes;

	public AudioClip clipsDuality;

	private void Awake()
	{
	}

	private void Update()
	{
	}

	public void PonerClipParteParrafo()
	{
		if (!GameManager.instance.vozHabilitada)
		{
			return;
		}
		try
		{
			adioSourcesMensajes[3].clip = clipsDuality;
			adioSourcesMensajes[3].Play();
		}
		catch
		{
		}
	}

	public void CargarClipMensajeNivel(int msg, int parafo)
	{
		int num = GameManager.instance.paisActual + 1;
		int num2 = GameManager.instance.nivelActual + 1;
		if (num == 1 && num2 == 7)
		{
			CargarClipMensajeProTip(2);
			return;
		}
		if (num == 1 && num2 == 4)
		{
			num = 2;
			num2 = 2;
		}
		clipsDuality = Resources.Load<AudioClip>("Duality/Duality_" + num + "_" + num2 + "_" + msg + "_" + (parafo + 1));
	}

	public void CargarClipMensajeNoPower()
	{
		clipsDuality = Resources.Load<AudioClip>("Duality/Duality_Mensaje_No_PowerUp");
	}

	public void CargarClipMensajeEstandar(int msg)
	{
		clipsDuality = Resources.Load<AudioClip>("Duality/Duality_Est_" + msg);
	}

	public void CargarClipMensajeProTip(int msg)
	{
		clipsDuality = Resources.Load<AudioClip>("Duality/Duality_ProTip_" + msg);
	}
}
public class ControladorTablaLeaderboards : MonoBehaviour
{
	public class JugadorEnTabla
	{
		private TextMeshProUGUI txt_Posicion;

		private TextMeshProUGUI txt_NombreJugador;

		private TextMeshProUGUI txt_Tiempo;

		public Transform transform;

		public JugadorEnTabla()
		{
		}

		public JugadorEnTabla(Transform transform)
		{
			this.transform = transform;
			txt_Posicion = transform.Find("Pos").GetComponent<TextMeshProUGUI>();
			txt_NombreJugador = transform.Find("Nombre").GetComponent<TextMeshProUGUI>();
			txt_Tiempo = transform.Find("Tiempo").GetComponent<TextMeshProUGUI>();
		}

		public void SetInfoJugador(LogrosRecords.Resultado info, ref Sprite[] logosEquipos)
		{
			txt_Posicion.text = info.posicion.ToString();
			txt_NombreJugador.text = info.usuario.ToString();
			int record = info.record;
			txt_Tiempo.text = record.ToString();
			transform.gameObject.SetActive(value: true);
		}

		public void SetInfoJugadorTorneo(int posicion, string nombre, int puntos, int rango, string bandera, int coche, ref Sprite[] logosEquipos, ControladorMenu m_ControladorMenu)
		{
			txt_Posicion.text = ((posicion != -1) ? posicion.ToString() : "");
			txt_NombreJugador.text = nombre;
			txt_Tiempo.text = ((puntos != -1) ? puntos.ToString() : "");
			transform.gameObject.SetActive(value: true);
		}
	}

	public class TablaLeaderboard
	{
		public JugadorEnTabla[] jugadores9primeros;

		public JugadorEnTabla[] jugadoresTorneo;

		public JugadorEnTabla[] jugadoresNo9primeros;

		public void BuscarReferencias(Transform padre)
		{
			jugadores9primeros = new JugadorEnTabla[9];
			jugadoresNo9primeros = new JugadorEnTabla[9];
			for (int i = 0; i < 9; i++)
			{
				jugadores9primeros[i] = new JugadorEnTabla(padre.transform.Find("PanelLeaderboards/Tabla9Primeros").GetChild(i));
			}
			for (int j = 1; j < 10; j++)
			{
				if (j != 5)
				{
					jugadoresNo9primeros[j - 1] = new JugadorEnTabla(padre.transform.Find("PanelLeaderboards/TablaNo9Primeros").GetChild(j));
				}
				else
				{
					jugadoresNo9primeros[j - 1] = new JugadorEnTabla();
				}
			}
		}

		public TablaLeaderboard(Transform padre)
		{
			jugadores9primeros = new JugadorEnTabla[9];
			jugadoresNo9primeros = new JugadorEnTabla[9];
			for (int i = 0; i < 9; i++)
			{
				jugadores9primeros[i] = new JugadorEnTabla(padre.transform.Find("PanelLeaderboards/Tabla9Primeros").GetChild(i));
			}
			for (int j = 1; j < 10; j++)
			{
				if (j != 5)
				{
					jugadoresNo9primeros[j - 1] = new JugadorEnTabla(padre.transform.Find("PanelLeaderboards/TablaNo9Primeros").GetChild(j));
				}
				else
				{
					jugadoresNo9primeros[j - 1] = new JugadorEnTabla();
				}
			}
		}
	}

	public GameObject loading;

	public GameObject tablas;

	public GameObject fondoTablaNo9;

	public GameObject errorConexion;

	public GameObject imagenTabla9;

	public UnityEvent accionBotonCerrar;

	public Transform seleccion;

	public TextMeshProUGUI textoNombreCircuito;

	private TablaLeaderboard leaderboardMenu;

	[SerializeField]
	private Sprite[] logosEquipos;

	private Coroutine pedirLeaderboardPS4;

	private bool b_OnResultadosObtenidos;

	private bool OnResultadosObtenidosCreado;

	private bool tablaCargada;

	public GameObject fondoComun;

	public void AbrirTabla(string mundo, string nombrePais, bool esEvento, bool despuesDeCarrera = false)
	{
		if (leaderboardMenu == null)
		{
			leaderboardMenu = new TablaLeaderboard(base.transform);
		}
		textoNombreCircuito.text = LanguageManager.instance.DameTexto("#Ranking", textoNombreCircuito);
		PonerTablaCargando();
		CargarTabla(mundo, esEvento, despuesDeCarrera);
		imagenTabla9.SetActive(value: true);
	}

	public void PonerTablaCargando()
	{
		tablas.SetActive(value: false);
		errorConexion.SetActive(value: false);
		loading.SetActive(value: true);
	}

	public void PonerTablaConectionError()
	{
		tablas.SetActive(value: false);
		errorConexion.SetActive(value: true);
		loading.SetActive(value: false);
		if ((bool)LogrosRecords.instance)
		{
			LogrosRecords.instance.ResultadosObtenidos -= OnResultadosObtenidos;
			LogrosRecords.instance.ResultadosObtenidos += OnResultadosObtenidos;
		}
	}

	public void CargarTabla(string nombreMundo, bool esEvento, bool despuesDeCarrera)
	{
		tablaCargada = false;
		if ((bool)LogrosRecords.instance)
		{
			if (pedirLeaderboardPS4 != null)
			{
				StopCoroutine(pedirLeaderboardPS4);
			}
			pedirLeaderboardPS4 = StartCoroutine(EsperaParaVerSiHayServicios(nombreMundo, esEvento, despuesDeCarrera));
		}
		else
		{
			UnityEngine.Debug.Log("LogrosRecords false");
			if (!despuesDeCarrera)
			{
				PonerTablaConectionError();
			}
			else
			{
				BotonCerrar();
			}
		}
	}

	private IEnumerator EsperaParaVerSiHayServicios(string nombreMundo, bool esEvento, bool despuesDeCarrera)
	{
		UnityEngine.Debug.Log("entramos en corroutina mostrar tabla");
		yield return null;
		yield return null;
		LogrosRecords.instance.ObtenerResultadosAlrededorMioConTop(nombreMundo, 9, esEvento, -1L);
		yield return new WaitForSeconds(5f);
		if (!tablaCargada)
		{
			if (!despuesDeCarrera)
			{
				PonerTablaConectionError();
			}
			else
			{
				BotonCerrar();
			}
		}
	}

	private void OnDisable()
	{
		if (pedirLeaderboardPS4 != null)
		{
			StopCoroutine(pedirLeaderboardPS4);
		}
		tablaCargada = false;
		if ((bool)LogrosRecords.instance)
		{
			LogrosRecords.instance.ResultadosObtenidos -= OnResultadosObtenidos;
			b_OnResultadosObtenidos = false;
		}
	}

	private void OnEnable()
	{
		if ((bool)LogrosRecords.instance && OnResultadosObtenidosCreado)
		{
			LogrosRecords.instance.ResultadosObtenidos += OnResultadosObtenidos;
			b_OnResultadosObtenidos = true;
		}
	}

	private IEnumerator Start()
	{
		yield return new WaitForEndOfFrame();
		if ((bool)LogrosRecords.instance)
		{
			LogrosRecords.instance.ResultadosObtenidos += OnResultadosObtenidos;
			LogrosRecords.instance.RecordSubido += OnRecordSubido;
			OnResultadosObtenidosCreado = true;
		}
	}

	private void OnRecordSubido(object sender, int miScoreRecibido, string tabla)
	{
		LogrosRecords.instance.ObtenerResultadosAlrededorMioConTop(tabla, 9, esEvento: false, -1L);
	}

	private bool ValidarListaResultados(List<LogrosRecords.Resultado> resultados)
	{
		bool result = true;
		List<string> list = new List<string>();
		foreach (LogrosRecords.Resultado resultado in resultados)
		{
			if (list.Contains(resultado.usuario))
			{
				result = false;
				break;
			}
			list.Add(resultado.usuario);
		}
		return result;
	}

	private void OnResultadosObtenidos(object sender, List<LogrosRecords.Resultado> resultados, bool dosListas, string tabla)
	{
		string text = LogrosRecords.instance.DameMiNombre();
		bool flag = true;
		for (int i = 0; i < resultados.Count; i++)
		{
			if (resultados[i].usuario == "")
			{
				LogrosRecords.Resultado resultado = default(LogrosRecords.Resultado);
				resultado = resultados[i];
				resultado.usuario = "---";
				resultados[i] = resultado;
			}
		}
		if (Debugs.logs)
		{
			UnityEngine.Debug.Log("OnResultadosObtenidos en tabla: " + tabla + " RESULTADOS: " + resultados.Count + " Mi Nombre: " + text + " Lista válida:" + flag.ToString());
		}
		if (Debugs.logs)
		{
			UnityEngine.Debug.Log("Mostrando resultados");
		}
		tablaCargada = true;
		seleccion.gameObject.SetActive(value: false);
		if (!flag)
		{
			return;
		}
		bool flag2 = false;
		loading.SetActive(value: false);
		errorConexion.SetActive(value: false);
		tablas.SetActive(value: true);
		if (dosListas)
		{
			fondoTablaNo9.SetActive(value: true);
			leaderboardMenu.jugadores9primeros[0].transform.parent.gameObject.SetActive(value: false);
			leaderboardMenu.jugadoresNo9primeros[0].transform.parent.gameObject.SetActive(value: true);
		}
		else
		{
			fondoTablaNo9.SetActive(value: false);
			leaderboardMenu.jugadores9primeros[0].transform.parent.gameObject.SetActive(value: true);
			leaderboardMenu.jugadoresNo9primeros[0].transform.parent.gameObject.SetActive(value: false);
		}
		for (int j = 0; j < 9; j++)
		{
			if (dosListas)
			{
				if (resultados.Count > j)
				{
					if (resultados[j].posicion >= 0)
					{
						leaderboardMenu.jugadoresNo9primeros[j].SetInfoJugador(resultados[j], ref logosEquipos);
						if (resultados[j].usuario == text)
						{
							seleccion.position = leaderboardMenu.jugadoresNo9primeros[j].transform.position;
							flag2 = true;
						}
					}
				}
				else
				{
					leaderboardMenu.jugadoresNo9primeros[j].transform.gameObject.SetActive(value: false);
				}
			}
			else if (resultados.Count > j)
			{
				if (resultados[j].posicion >= 0)
				{
					leaderboardMenu.jugadores9primeros[j].SetInfoJugador(resultados[j], ref logosEquipos);
					if (resultados[j].usuario == text)
					{
						seleccion.position = leaderboardMenu.jugadores9primeros[j].transform.position;
						flag2 = true;
					}
				}
			}
			else
			{
				leaderboardMenu.jugadores9primeros[j].transform.gameObject.SetActive(value: false);
			}
		}
		if (resultados.Count > 0 && flag2)
		{
			seleccion.gameObject.SetActive(value: true);
		}
	}

	public void BotonCerrar()
	{
		accionBotonCerrar.Invoke();
	}
}
public class Debugs : MonoBehaviour
{
	public static bool debugs = false;

	public static bool logs = false;

	public static bool logsAlex = logs;

	public static bool logsAitor = !logs && false;

	public static bool logsIvan = !logs && false;

	public static bool logsPhoton = !logs && false;

	public static bool dividirBolasConLaLetraO = debugs;

	public static bool PuedoHacermeInmortal = !debugs && false;

	public static int SimularPlayer = (debugs ? 0 : 0);

	public static bool sinMatarEnCompetitivo = debugs || true;

	public static int tiempoBalasCompartidas = (debugs ? 2 : 0);

	public static bool poderPararTiempoSiempre = !debugs && false;

	public static bool contadorFPS = !debugs && false;

	public static bool nivelesDesbloqueados = !debugs && false;

	public static bool OmitirPirateoOculus = false;

	public static void Log(string message, int tipo = -1)
	{
		if ((logs && tipo == -1) || (logsAlex && tipo == 1) || (logsAitor && tipo == 2) || (logsIvan && tipo == 3) || (logsPhoton && tipo == 4))
		{
			UnityEngine.Debug.Log(message);
		}
	}
}
public class PantallaDebug : MonoBehaviour
{
	private string[] Mundos = new string[14]
	{
		"Mundo1", "Mundo2", "Mundo3", "Mundo4", "Mundo5", "Mundo6", "Mundo7", "Mundo8", "Mundo9", "Mundo10",
		"Mundo11", "Mundo12", "Mundo13", "Mundo14"
	};

	private string[] TiposPartida = new string[3] { "Solo", "Cooperativo", "Competitivo" };

	public Dropdown dropMundos;

	private int valorInicialMundos;

	public Dropdown dropNiveles;

	private int valorInicialNiveles;

	public Dropdown dropCantJugOnline;

	private int valorInicialJugOnline;

	public Dropdown dropTipoPartida;

	private int valorInicialTipoPartida;

	public Dropdown dropCalidad;

	private int valorInicialCalidad;

	private void Start()
	{
		List<Dropdown.OptionData> list = new List<Dropdown.OptionData>();
		valorInicialMundos = PersistentDataManager.GetInt("DebugMundo");
		list.Clear();
		for (int i = 0; i < Mundos.Length; i++)
		{
			Dropdown.OptionData optionData = new Dropdown.OptionData();
			optionData.text = Mundos[i];
			list.Add(optionData);
		}
		dropMundos.AddOptions(list);
		dropMundos.value = valorInicialMundos;
		Config.mundo = Mundos[dropMundos.value];
		valorInicialNiveles = PersistentDataManager.GetInt("DebugNivel", 1);
		dropNiveles.value = valorInicialNiveles;
		GameManager.instance.nivelActual = valorInicialNiveles;
		valorInicialJugOnline = PersistentDataManager.GetInt("DebugNJugOnline");
		dropCantJugOnline.value = valorInicialJugOnline;
		Config.numJugadoresOnline = valorInicialJugOnline;
		valorInicialTipoPartida = PersistentDataManager.GetInt("DebugTipoPartida");
		list.Clear();
		for (int j = 0; j < TiposPartida.Length; j++)
		{
			Dropdown.OptionData optionData2 = new Dropdown.OptionData();
			optionData2.text = TiposPartida[j];
			list.Add(optionData2);
		}
		dropTipoPartida.AddOptions(list);
		dropTipoPartida.value = valorInicialTipoPartida;
		Config.modoDePartida = (Config.ModoDePartida)dropTipoPartida.value;
		valorInicialCalidad = PersistentDataManager.GetInt("Calidad", (int)CalidadManager.instance.GetCalidadRecomendada());
		list.Clear();
		for (int k = 0; k < Enum.GetNames(typeof(CalidadManager.Calidad)).Length; k++)
		{
			Dropdown.OptionData optionData3 = new Dropdown.OptionData();
			CalidadManager.Calidad calidad = (CalidadManager.Calidad)k;
			optionData3.text = calidad.ToString();
			list.Add(optionData3);
		}
		dropCalidad.AddOptions(list);
		dropCalidad.value = valorInicialCalidad;
		CalidadManager.instance.SetCalidad((CalidadManager.Calidad)dropCalidad.value);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Return))
		{
			StartGame();
		}
	}

	public void ElegirMundo()
	{
		Config.mundo = Mundos[dropMundos.value];
		PersistentDataManager.SetInt("DebugMundo", dropMundos.value);
	}

	public void ElegirNivel()
	{
		GameManager.instance.nivelActual = dropNiveles.value;
		PersistentDataManager.SetInt("DebugNivel", dropNiveles.value);
	}

	public void ElegirTipoPartida()
	{
		Config.modoDePartida = (Config.ModoDePartida)dropTipoPartida.value;
		PersistentDataManager.SetInt("DebugTipoPartida", dropTipoPartida.value);
	}

	public void ElegirCantidadDeJugOnline()
	{
		Config.numJugadoresOnline = int.Parse(dropCantJugOnline.captionText.text);
		PersistentDataManager.SetInt("DebugNJugOnline", dropCantJugOnline.value);
		if (Config.numJugadoresOnline > 0)
		{
			Config.modoDeJuego = Config.ModosDeJuego.Online;
		}
		else
		{
			Config.modoDeJuego = Config.ModosDeJuego.Offline;
		}
	}

	public void ElegirCalidad()
	{
		CalidadManager.instance.SetCalidad((CalidadManager.Calidad)dropCalidad.value);
		PersistentDataManager.SetInt("Calidad", dropCalidad.value);
	}

	public void StartGame()
	{
		PersistentDataManager.SaveData();
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			PhotonNetwork.OfflineMode = false;
		}
		else
		{
			PhotonNetwork.OfflineMode = true;
		}
		PhotonNetwork.AplicarVersionPUN(10);
		PhotonNetwork.versionPUNPropia = 10;
		PersistentDataManager.SaveData();
		SceneManager.LoadScene("EscenaIniciandoOnline");
	}
}
public class DeteccionDispositivos : MonoBehaviour
{
	private float ticks = 50f;

	[HideInInspector]
	public bool yaNoBuscar;

	private void Start()
	{
	}

	private void Update()
	{
		if (Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			return;
		}
		if (ticks > 100f)
		{
			if (!GameManager.instance.senDer.existe || !GameManager.instance.senIzq.existe)
			{
				DetectarDispositivos();
			}
			bool existe = GameManager.instance.senDer.existe;
			bool existe2 = GameManager.instance.senIzq.existe;
			if (Config.plataforma != Config.PlataformaJuego.Pico)
			{
				if (Debugs.SimularPlayer > 0)
				{
					if (existe && existe2)
					{
						Config.tiene2Sensores = true;
						UnityEngine.Object.Destroy(this);
					}
					return;
				}
				if (existe && existe2)
				{
					Config.tiene2Sensores = true;
					UnityEngine.Object.Destroy(this);
				}
				else if (existe)
				{
					Config.tiene2Sensores = false;
					Config.zurdo = false;
				}
				else if (existe2)
				{
					Config.tiene2Sensores = false;
					Config.zurdo = true;
				}
				else
				{
					Config.tiene2Sensores = false;
				}
			}
			ticks = 0f;
		}
		else
		{
			ticks += 1f;
		}
	}

	public static void CambiarSensorOculusGO(bool oculusGoDer)
	{
		InputsController.JoyInput senDer = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.SensorDerecho, InputsController.TipoSensores.ninguno);
		InputsController.JoyInput senIzq = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.SensorIzquierdo, InputsController.TipoSensores.ninguno);
		if (oculusGoDer)
		{
			InputsController.TipoSensores tipoSensores = InputsController.TipoSensores.oculus;
			Config.esGO = true;
			Config.esQuest = false;
			InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorDerecho;
			senDer = new InputsController.JoyInput(_existe: true, "oculus tracked right", 0, tipo, tipoSensores);
			GameManager.instance.tipoDeSensores = tipoSensores;
		}
		else
		{
			InputsController.TipoSensores tipoSensores2 = InputsController.TipoSensores.oculus;
			Config.esGO = true;
			Config.esQuest = false;
			InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorIzquierdo;
			senIzq = new InputsController.JoyInput(_existe: true, "oculus tracked left", 1, tipo, tipoSensores2);
			GameManager.instance.tipoDeSensores = tipoSensores2;
		}
		GameManager.instance.senDer = senDer;
		GameManager.instance.senIzq = senIzq;
		if ((bool)GameManager.instance.GetComponent<DeteccionDispositivos>())
		{
			GameManager.instance.GetComponent<DeteccionDispositivos>().yaNoBuscar = true;
		}
	}

	private void DetectarDispositivos()
	{
		if (yaNoBuscar)
		{
			return;
		}
		_ = InputsController.instance;
		InputsController.JoyInput senDer = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.SensorDerecho, InputsController.TipoSensores.ninguno);
		InputsController.JoyInput senIzq = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.SensorIzquierdo, InputsController.TipoSensores.ninguno);
		InputsController.JoyInput mando = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.mando, InputsController.TipoSensores.ninguno);
		InputsController.JoyInput rudder = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.rudder, InputsController.TipoSensores.ninguno);
		InputsController.JoyInput tracker = new InputsController.JoyInput(_existe: false, "NONE", -1, InputsController.DispositivosPosibles.tracker, InputsController.TipoSensores.ninguno);
		string[] joystickNames = Input.GetJoystickNames();
		int num = 0;
		for (int i = 0; i < joystickNames.Length; i++)
		{
			if (joystickNames[i].Length > 1)
			{
				num++;
			}
		}
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			senDer = new InputsController.JoyInput(_existe: true, "picoDer", 1, InputsController.DispositivosPosibles.SensorDerecho, InputsController.TipoSensores.pico);
			senIzq = new InputsController.JoyInput(_existe: true, "picoIzq", 0, InputsController.DispositivosPosibles.SensorIzquierdo, InputsController.TipoSensores.pico);
			GameManager.instance.tipoDeSensores = InputsController.TipoSensores.pico;
			GameManager.instance.senDer = senDer;
			GameManager.instance.senIzq = senIzq;
			GameManager.instance.mando = mando;
			GameManager.instance.rudder = rudder;
			GameManager.instance.tracker = tracker;
			return;
		}
		if (Config.plataforma == Config.PlataformaJuego.Nolo)
		{
			senDer = new InputsController.JoyInput(_existe: true, "noloDer", 1, InputsController.DispositivosPosibles.SensorDerecho, InputsController.TipoSensores.nolo);
			senIzq = new InputsController.JoyInput(_existe: true, "noloIzq", 0, InputsController.DispositivosPosibles.SensorIzquierdo, InputsController.TipoSensores.nolo);
			GameManager.instance.tipoDeSensores = InputsController.TipoSensores.nolo;
			Config.tiene2Sensores = true;
			GameManager.instance.senDer = senDer;
			GameManager.instance.senIzq = senIzq;
			GameManager.instance.mando = mando;
			GameManager.instance.rudder = rudder;
			GameManager.instance.tracker = tracker;
			return;
		}
		if (joystickNames.Length > 9)
		{
			UnityEngine.Debug.LogError("Max joystick amount reached, Restarting the game");
			UnityEngine.Application.Quit();
		}
		for (int j = 0; j < joystickNames.Length; j++)
		{
			string text = joystickNames[j].ToLower();
			bool flag = text.Contains("oculus") && text.Contains("tracked") && text.Contains("right");
			bool flag2 = text.Contains("oculus") && text.Contains("tracked") && text.Contains("left");
			if (flag || flag2)
			{
				if (flag)
				{
					InputsController.TipoSensores tipoSensores = InputsController.TipoSensores.oculus;
					Config.esGO = true;
					Config.esQuest = false;
					Config.zurdo = false;
					InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorDerecho;
					senDer = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoSensores);
					GameManager.instance.tipoDeSensores = tipoSensores;
				}
				else if (flag2)
				{
					InputsController.TipoSensores tipoSensores2 = InputsController.TipoSensores.oculus;
					Config.esGO = true;
					Config.esQuest = false;
					Config.zurdo = true;
					InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorIzquierdo;
					senIzq = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoSensores2);
					GameManager.instance.tipoDeSensores = tipoSensores2;
				}
			}
			else if (text.Contains("tracker") || text.Contains("()"))
			{
				InputsController.TipoSensores tipoSensores3 = InputsController.TipoSensores.tracker;
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.tracker;
				tracker = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoSensores3);
				GameManager.instance.tipoDeSensores = tipoSensores3;
			}
			else if (text.Contains("controller") && text.Contains("right"))
			{
				InputsController.TipoSensores tipoSensores4 = InputsController.TipoSensores.ninguno;
				tipoSensores4 = (text.Contains("oculus") ? InputsController.TipoSensores.oculus : (text.Contains("cosmos") ? InputsController.TipoSensores.cosmos : (text.Contains("mr") ? InputsController.TipoSensores.wmr : (text.Contains("knuckles") ? InputsController.TipoSensores.index : ((!text.Contains("vive")) ? InputsController.TipoSensores.oculus : InputsController.TipoSensores.vive)))));
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorDerecho;
				senDer = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoSensores4);
				GameManager.instance.tipoDeSensores = tipoSensores4;
			}
			else if (text.Contains("controller") && text.Contains("left"))
			{
				InputsController.TipoSensores tipoSensores5 = InputsController.TipoSensores.ninguno;
				tipoSensores5 = (text.Contains("oculus") ? InputsController.TipoSensores.oculus : (text.Contains("cosmos") ? InputsController.TipoSensores.cosmos : (text.Contains("mr") ? InputsController.TipoSensores.wmr : (text.Contains("knuckles") ? InputsController.TipoSensores.index : ((!text.Contains("vive")) ? InputsController.TipoSensores.oculus : InputsController.TipoSensores.vive)))));
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.SensorIzquierdo;
				senIzq = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoSensores5);
				GameManager.instance.tipoDeSensores = tipoSensores5;
			}
			else if ((text.Contains("controller") && (text.Contains("xbox") || text.Contains("wireless") || text.Contains("pro"))) || text.Contains("dual"))
			{
				InputsController.TipoSensores tipoDeSensor = InputsController.TipoSensores.ninguno;
				if (text.Contains("xbox"))
				{
					tipoDeSensor = InputsController.TipoSensores.mandoXbox;
				}
				if (text.Contains("pro"))
				{
					tipoDeSensor = InputsController.TipoSensores.mandoSwitch;
				}
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.mando;
				mando = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoDeSensor);
			}
			else if (text.Contains("rudder"))
			{
				InputsController.TipoSensores tipoDeSensor2 = InputsController.TipoSensores.ninguno;
				if (text.Contains("oculus"))
				{
					tipoDeSensor2 = InputsController.TipoSensores.oculus;
				}
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.rudder;
				rudder = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, tipoDeSensor2);
			}
			else if (text != "" && text != "tracker" && !text.Contains("()") && !mando.existe)
			{
				InputsController.DispositivosPosibles tipo = InputsController.DispositivosPosibles.mando;
				mando = new InputsController.JoyInput(_existe: true, joystickNames[j], j + 1, tipo, InputsController.TipoSensores.ninguno);
			}
		}
		GameManager.instance.senDer = senDer;
		GameManager.instance.senIzq = senIzq;
		GameManager.instance.mando = mando;
		GameManager.instance.rudder = rudder;
		GameManager.instance.tracker = tracker;
	}
}
public class DisparoEscopeta : MonoBehaviour
{
	private Rigidbody[] balas;

	public Transform inicio;

	private void OnEnable()
	{
		balas = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < balas.Length; i++)
		{
			Vector3 vector = balas[i].transform.position - inicio.position;
			balas[i].AddForce(vector.normalized * 5f, ForceMode.Impulse);
		}
	}
}
public class ControladorPS : MonoBehaviour
{
	private ParticleSystem pSystem;

	private int ticksVagos;

	public bool tiempoNormalCuandoPasemosNivelOMuramos;

	public bool forzarcuandoNivelNoEstaInicializado;

	public bool tambienAjustarAudioSourcse;

	private AudioSource miAudioSource;

	private void Start()
	{
		ticksVagos = 0;
		pSystem = GetComponent<ParticleSystem>();
		if (tambienAjustarAudioSourcse)
		{
			miAudioSource = GetComponent<AudioSource>();
		}
	}

	private void Update()
	{
		ticksVagos++;
		if (ticksVagos < 4)
		{
			return;
		}
		ticksVagos = 0;
		ParticleSystem.MainModule main = pSystem.main;
		float num = TimeManager.GetInstance().GetTiempoMedioGlobal();
		if (tiempoNormalCuandoPasemosNivelOMuramos && (bool)GameManager.instance && (((bool)NivelCompletado.instance && NivelCompletado.instance.pasandoDeNivel) || ((bool)GameManager.instance.player && GameManager.instance.player.muerto) || ((bool)GameManager.instance.m_salaManager && !GameManager.instance.m_salaManager.nivelIniciado)))
		{
			num = 1f;
		}
		if (forzarcuandoNivelNoEstaInicializado && (bool)GameManager.instance && (bool)GameManager.instance.m_salaManager && GameManager.instance.m_salaManager.nivelIniciado)
		{
			num = 1f;
		}
		if (tambienAjustarAudioSourcse)
		{
			float pitch = miAudioSource.pitch;
			if (num > pitch)
			{
				miAudioSource.pitch = Mathf.Lerp(pitch, num, Time.deltaTime * 20f);
			}
			else
			{
				miAudioSource.pitch = Mathf.Lerp(pitch, num, Time.deltaTime * 10f);
			}
		}
		main.simulationSpeed = num;
	}
}
public class EfectoParpadear : MonoBehaviour
{
	public enum Objeto
	{
		texto,
		imagen
	}

	public Objeto objetoSeleccion;

	public float tiempoEntreEfectos;

	public float velocidadParpadeo;

	public int numeroParpadeos;

	public TextMeshProUGUI textoReferencia;

	public Image imagenReferencia;

	private Coroutine parpadeo;

	private void Start()
	{
		if (objetoSeleccion == Objeto.texto)
		{
			textoReferencia = GetComponent<TextMeshProUGUI>();
		}
		else
		{
			imagenReferencia = GetComponent<Image>();
		}
	}

	private void OnEnable()
	{
		parpadeo = StartCoroutine(AnimacionParpadeoTexto());
	}

	private void OnDisable()
	{
		StopCoroutine(parpadeo);
	}

	private IEnumerator AnimacionParpadeoTexto()
	{
		while (true)
		{
			for (int i = 0; i < numeroParpadeos; i++)
			{
				if (objetoSeleccion == Objeto.texto)
				{
					textoReferencia.enabled = false;
				}
				else
				{
					imagenReferencia.enabled = false;
				}
				yield return new WaitForSeconds(velocidadParpadeo);
				if (objetoSeleccion == Objeto.texto)
				{
					textoReferencia.enabled = true;
				}
				else
				{
					imagenReferencia.enabled = true;
				}
				yield return new WaitForSeconds(velocidadParpadeo);
			}
			yield return new WaitForSeconds(tiempoEntreEfectos);
		}
	}
}
public class ExplosionEsfera : MonoBehaviour
{
	public Rigidbody[] rbTrozos;

	public Transform explosion;

	public Vector3 pos;

	private float tiempo;

	private AudioSource sonidoExplosion;

	public Vector3[] posicionesTrozos;

	public Quaternion[] rotacionesTrozos;

	private GameObject modelo;

	private int contador;

	private bool creado;

	private void Start()
	{
		ActivarTrozos();
		GetComponent<ParticleSystem>().Play();
	}

	private IEnumerator Explosion()
	{
		yield return new WaitForSeconds(0f);
		rbTrozos = base.transform.GetComponentsInChildren<Rigidbody>();
		sonidoExplosion.Play();
		pos = explosion.position;
		for (int i = 0; i < rbTrozos.Length; i++)
		{
			Vector3 normalized = (rbTrozos[i].transform.position - pos).normalized;
			UnityEngine.Debug.DrawRay(pos, normalized, Color.red, 10f);
			rbTrozos[i].AddForce(normalized * 2f, ForceMode.Impulse);
		}
	}

	private void ActivarTrozos()
	{
		sonidoExplosion = GetComponent<AudioSource>();
		tiempo = 0f;
		StartCoroutine(Explosion());
	}
}
public class TrozosEsfera : MonoBehaviour
{
	private int ticksDeVidaMaximo;

	private int ticksDeVida;

	private EfectoDesaparecer miEfecto;

	private void Start()
	{
		ticksDeVidaMaximo = UnityEngine.Random.Range(100, 130);
		ticksDeVida = 0;
		miEfecto = GetComponent<EfectoDesaparecer>();
	}

	private void Update()
	{
		if (ticksDeVida == ticksDeVidaMaximo)
		{
			miEfecto.Desaparecer();
			base.enabled = false;
		}
		else
		{
			ticksDeVida++;
		}
	}
}
public class efectoMaterialFantasmaBoss : MonoBehaviour
{
	private Material miMaterial;

	private int ticksSinModificar;

	private float intensidadDestino = 3f;

	private float intensidadActual = 3f;

	private float rimPowerDestino = 1f;

	private float rimPowerActual = 1f;

	private void Start()
	{
		miMaterial = base.gameObject.GetComponent<Renderer>().sharedMaterial;
	}

	private void Update()
	{
		intensidadActual = Mathf.Lerp(intensidadActual, intensidadDestino, Time.deltaTime * 0.5f);
		rimPowerActual = Mathf.Lerp(rimPowerActual, rimPowerDestino, Time.deltaTime * 0.5f);
		miMaterial.SetFloat("_AllPower", intensidadActual);
		miMaterial.SetFloat("_AlphaPower", rimPowerActual);
		ticksSinModificar++;
		if (ticksSinModificar >= 70)
		{
			ticksSinModificar = 0;
			if (intensidadDestino < 2.5f)
			{
				intensidadDestino = 3f;
			}
			else
			{
				intensidadDestino = 2.3f;
			}
			if (rimPowerDestino > 1f)
			{
				rimPowerDestino = 0.51f;
			}
			else
			{
				rimPowerDestino = 1.67f;
			}
		}
	}
}
public class Bala : MonoBehaviour
{
	private Rigidbody rb;

	public Vector3 velocidadSinTrucar = Vector3.zero;

	public Transform mano;

	public int vel;

	public int equipo = 1;

	private SyncBala balaSync;

	public TrailRenderer trail;

	public ParticleSystem particulas;

	private bool haTocadoObjetoDeBonus;

	public bool deEscopeta;

	private CapsuleCollider capsuleCollider;

	private bool sonidoMetalico;

	private Coroutine efectoDesaparecer;

	private Color colorInicial_P;

	private Color colorFinal_P;

	private float tiempo_P;

	private bool balaRebotada;

	private void Start()
	{
		balaSync = GetComponent<SyncBala>();
		rb = GetComponent<Rigidbody>();
		trail = GetComponent<TrailRenderer>();
		capsuleCollider = GetComponent<CapsuleCollider>();
		float max = (float)PlayerProgreso.instance.rachaDerrotas / 8f;
		max = 1f + Mathf.Clamp(0f, 1f, max);
		capsuleCollider.radius = 0.5f * max;
	}

	public Rigidbody GetRigidBody()
	{
		return rb;
	}

	public void TocaObjetoBonus()
	{
		haTocadoObjetoDeBonus = true;
	}

	private void OnEnable()
	{
		haTocadoObjetoDeBonus = false;
		if (GetComponent<PhotonView>().IsMine && (bool)GameManager.instance.player)
		{
			equipo = GameManager.instance.player.miEquipo;
			GetComponent<SyncBala>().equipo = equipo;
		}
		if ((bool)GameManager.instance.player)
		{
			base.transform.LookAt(GameManager.instance.player.transform);
			base.gameObject.tag = "Bala";
		}
	}

	public void ChangeTrail(bool laser)
	{
		if (laser)
		{
			trail.widthMultiplier = 2f;
		}
		else
		{
			trail.widthMultiplier = 1f;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.gameObject.CompareTag(base.gameObject.tag) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola) && !collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			EfectoDesaparecer(1);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == LayerMask.NameToLayer("PowerUps"))
		{
			TocaObjetoBonus();
			EfectoDesaparecer(1);
		}
		else if (other.CompareTag(GameManager.instance.tagPared) || other.CompareTag(GameManager.instance.tagParedMovible))
		{
			EfectoDesaparecer(99);
		}
		else if (other.CompareTag(GameManager.instance.tagRompible))
		{
			other.GetComponent<BloqueRompible>().Romper(base.transform.position.x, base.transform.position.y, base.transform.position.z);
			TocaObjetoBonus();
			EfectoDesaparecer(1);
		}
		if (balaRebotada && (other.gameObject.CompareTag(GameManager.instance.tagPistola) || other.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline)) && other.gameObject.layer != 16)
		{
			Vector3 worldPosition = new Vector3(other.gameObject.transform.forward.x, 0f - other.gameObject.transform.forward.y, other.gameObject.transform.forward.z);
			base.gameObject.tag = "Bala";
			velocidadSinTrucar = worldPosition;
			base.transform.LookAt(worldPosition);
			if (!GameManager.instance.player.muerto)
			{
				balaSync.PonerAudioRebote();
			}
		}
	}

	public int GetNumUsosRestantes()
	{
		return balaSync.numUsos;
	}

	public void EfectoDesaparecer(int usosQuePierde)
	{
		if (!haTocadoObjetoDeBonus)
		{
			GameManager.instance.m_salaManager.ResetearRacha();
		}
		balaSync.numUsos -= usosQuePierde;
		if (balaSync.numUsos <= 0 && efectoDesaparecer == null)
		{
			efectoDesaparecer = StartCoroutine(CorrutinaDesaparecer());
		}
	}

	private IEnumerator CorrutinaDesaparecer()
	{
		particulas.gameObject.SetActive(value: true);
		rb.velocity = Vector3.zero;
		base.transform.GetChild(0).gameObject.SetActive(value: false);
		trail.enabled = false;
		GetComponent<CapsuleCollider>().enabled = false;
		while (particulas.isEmitting)
		{
			yield return null;
		}
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		particulas.gameObject.SetActive(value: false);
		GetComponent<CapsuleCollider>().enabled = true;
		efectoDesaparecer = null;
		PoolObjetos.GetInstance().Eliminar(base.gameObject);
	}

	public void Disable()
	{
		if (efectoDesaparecer != null)
		{
			StopCoroutine(efectoDesaparecer);
		}
		deEscopeta = false;
		efectoDesaparecer = null;
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		particulas.gameObject.SetActive(value: false);
		GetComponent<CapsuleCollider>().enabled = true;
		base.gameObject.tag = "Bala";
		if (balaRebotada)
		{
			trail.startColor = colorInicial_P;
			trail.endColor = colorFinal_P;
			trail.time = tiempo_P;
		}
		balaRebotada = false;
	}

	private void OnDisable()
	{
		Disable();
		PoolObjetos.GetInstance().Eliminar(base.gameObject);
	}

	private void Update()
	{
		_ = velocidadSinTrucar;
		if (efectoDesaparecer == null)
		{
			float tiempoMedioGlobal;
			if (Config.modoDePartida == Config.ModoDePartida.Cooperativo || (Config.modoDePartida == Config.ModoDePartida.Competitivo && Debugs.tiempoBalasCompartidas == 2))
			{
				tiempoMedioGlobal = TimeManager.GetInstance().GetTiempoMedioGlobal();
			}
			if (Config.modoDePartida == Config.ModoDePartida.Competitivo && Debugs.tiempoBalasCompartidas == 1)
			{
				int numeroEquipo = ((equipo != 1) ? 1 : 2);
				tiempoMedioGlobal = TimeManager.GetInstance().GetTiempoDeEquipo(numeroEquipo);
			}
			else
			{
				tiempoMedioGlobal = TimeManager.GetInstance().GetTiempoDeEquipo(equipo);
			}
			if (deEscopeta)
			{
				tiempoMedioGlobal = 1f;
			}
			rb.velocity = velocidadSinTrucar * tiempoMedioGlobal;
		}
		if ((bool)GameManager.instance.player && Vector3.Distance(GameManager.instance.player.transform.position, base.transform.position) > 15f)
		{
			EfectoDesaparecer(99);
		}
	}

	public void RebotarPlayer()
	{
		balaRebotada = true;
		Vector3 vector = GameManager.instance.player.cabeza.transform.position - base.transform.position;
		float magnitude = vector.magnitude;
		velocidadSinTrucar = vector / magnitude * 3f;
		base.transform.LookAt(GameManager.instance.player.cabeza.transform.position);
		base.gameObject.tag = "BalaEsfera";
		colorInicial_P = trail.startColor;
		colorFinal_P = trail.endColor;
		tiempo_P = trail.time;
		trail.startColor = Color.red;
		trail.endColor = Color.magenta;
		trail.time = 2f;
		SyncBala component = GetComponent<SyncBala>();
		if ((bool)component)
		{
			component.posicionDeinstanciamiento = base.transform.position;
		}
	}
}
public class BloqueRompible : MonoBehaviour
{
	private Weapon arma;

	private GanchoRifle gancho;

	private Rigidbody rb;

	private BoxCollider boxCollider;

	private SphereCollider sphereCollider;

	public bool pistolaAnclada;

	public GameObject bloque;

	public GameObject bloqueRompiendose;

	public Vector3 posInicial;

	public float Fuerza;

	public Drops[] drops;

	private AudioSource audioSource;

	public bool isEscudo;

	public bool isBoss;

	public Bola bolaPadre;

	public Vector3[] posTrozos;

	private bool creado;

	private int contador;

	private float tiempoEnganchado;

	public MeshRenderer escudo;

	private bool rompiendose;

	private void Start()
	{
		creado = false;
		pistolaAnclada = false;
		if (isEscudo || isBoss)
		{
			sphereCollider = GetComponent<SphereCollider>();
		}
		else
		{
			boxCollider = GetComponent<BoxCollider>();
		}
		rb = GetComponent<Rigidbody>();
		posInicial = base.transform.position;
		audioSource = GetComponent<AudioSource>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag(GameManager.instance.tagDestructorDeCubos) || other.gameObject.CompareTag(GameManager.instance.tagPistola) || other.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			Romper(other.transform.position.x, other.transform.position.y, other.transform.position.z);
			if (!isEscudo && !isBoss)
			{
				Romper(other.transform.position.x, other.transform.position.y, other.transform.position.z);
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = collision.gameObject.CompareTag(GameManager.instance.tagPistola) || collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline);
		if (!flag && !collision.gameObject.CompareTag(GameManager.instance.tagBalaEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagBala) && !collision.gameObject.CompareTag(GameManager.instance.tagParedMovible))
		{
			return;
		}
		if (!isEscudo && !isBoss)
		{
			Romper(collision.transform.position.x, collision.transform.position.y, collision.transform.position.z);
		}
		if (!flag)
		{
			return;
		}
		Arma component = collision.transform.GetComponent<Arma>();
		if (!component && (bool)collision.transform.parent)
		{
			component = collision.transform.parent.GetComponent<Arma>();
			if (!component && (bool)collision.transform.parent.parent && (bool)collision.transform.parent.parent.parent)
			{
				component = collision.transform.parent.parent.parent.GetComponent<Arma>();
			}
		}
		if ((bool)component)
		{
			component.heDestruidoEsferaAlSerLanzado = true;
			return;
		}
		GanchoRifle component2 = collision.transform.GetComponent<GanchoRifle>();
		if ((bool)component2)
		{
			component2.heDestruidoEsferaAlSerLanzado = true;
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (collision.gameObject.CompareTag(GameManager.instance.tagPistola) || collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			pistolaAnclada = false;
		}
	}

	public void HacerHijo(GameObject padre)
	{
		base.transform.parent = padre.transform;
		arma = padre.GetComponent<Weapon>();
		if (!arma)
		{
			gancho = padre.GetComponent<GanchoRifle>();
		}
		if (isEscudo || isBoss)
		{
			sphereCollider.isTrigger = true;
		}
		else
		{
			boxCollider.isTrigger = true;
		}
	}

	public void SepararHijo()
	{
	}

	public void HacerPadre(GameObject padre)
	{
		padre.transform.parent = base.transform;
		arma = padre.GetComponent<Weapon>();
		if (!arma)
		{
			gancho = padre.GetComponent<GanchoRifle>();
		}
		if (isEscudo)
		{
			if ((bool)sphereCollider)
			{
				sphereCollider.isTrigger = true;
			}
			else if ((bool)boxCollider)
			{
				boxCollider.isTrigger = true;
			}
		}
	}

	public void SepararPadre()
	{
		if ((bool)arma)
		{
			arma.transform.parent = null;
		}
		else
		{
			gancho.transform.parent = null;
		}
	}

	public void SepararGancho()
	{
		StartCoroutine(TiempoAfectandoFisicas());
	}

	private void LateUpdate()
	{
		if (!isEscudo && !isBoss && base.transform.position != posInicial && !pistolaAnclada)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, posInicial, 1f * Time.deltaTime);
		}
		if (pistolaAnclada)
		{
			tiempoEnganchado += Time.deltaTime;
			float num = tiempoEnganchado * 0.1f;
			if (num < 0.05f)
			{
				num = 0.1f;
			}
			if ((bool)escudo)
			{
				escudo.material.SetFloat("_Vertexoffset", num);
			}
			if (tiempoEnganchado > 1.8f)
			{
				tiempoEnganchado = 0f;
				Romper();
			}
		}
		else
		{
			tiempoEnganchado = 0f;
			rompiendose = false;
		}
	}

	public void Romper(float x = 1000f, float y = 1000f, float z = 1000f, bool ordenPorRed = false, bool porTiempo = false)
	{
		if (rompiendose || (!porTiempo && isEscudo))
		{
			return;
		}
		rompiendose = true;
		Vector3 posicion = base.transform.position;
		if (x < 999f)
		{
			posicion = new Vector3(x, y, z);
		}
		if (!ordenPorRed)
		{
			SyncBloqueRompible component = GetComponent<SyncBloqueRompible>();
			if ((bool)component)
			{
				component.RomperElBloque();
			}
		}
		if (((bool)arma && arma.armaEstaEnBloque) || ((bool)gancho && gancho.armaEstaEnBloque))
		{
			Rigidbody rigidbody = (arma ? arma.GetComponent<Rigidbody>() : gancho.GetComponent<Rigidbody>());
			if (!rigidbody.useGravity)
			{
				rigidbody.useGravity = true;
			}
			if (rigidbody.isKinematic)
			{
				rigidbody.isKinematic = false;
			}
			if ((bool)arma)
			{
				arma.bloque = null;
				arma.armaEstaEnBloque = false;
			}
			else
			{
				gancho.bloque = null;
				gancho.armaEstaEnBloque = false;
			}
			if (isEscudo || isBoss)
			{
				rigidbody.useGravity = false;
				rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
				if ((bool)arma)
				{
					arma.armaAncladaABloque = false;
					arma.otraPistola.armaEstaEnBloque = false;
				}
				else
				{
					gancho.armaAncladaABloque = false;
					gancho.otroGancho.armaEstaEnBloque = false;
				}
			}
			else
			{
				if ((bool)arma)
				{
					arma.otraPistola.armaAncladaABloque = false;
				}
				else
				{
					gancho.otroGancho.armaAncladaABloque = false;
				}
				rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			}
		}
		Explosion(posicion);
	}

	private IEnumerator TiempoAfectandoFisicas()
	{
		yield return new WaitForSeconds(1f);
		rb.isKinematic = true;
		if (isEscudo || isBoss)
		{
			sphereCollider.isTrigger = false;
		}
		else
		{
			boxCollider.isTrigger = false;
		}
	}

	public void Explosion(Vector3 posicion)
	{
		if (isEscudo)
		{
			EsferaScript component = base.transform.parent.parent.GetComponent<EsferaScript>();
			if ((bool)component)
			{
				component.GolpeoEscudo();
			}
			if ((bool)arma)
			{
				SepararPadre();
			}
			else if ((bool)gancho)
			{
				SepararPadre();
			}
			drops = null;
			if ((bool)arma)
			{
				arma.miMano.AtraerDesdeAire();
			}
			else if ((bool)gancho)
			{
				gancho.RebotarGancho();
			}
		}
		else if (isBoss)
		{
			if (GetComponentInParent<PhotonView>().IsMine)
			{
				BossBase componentInParent = base.transform.GetComponentInParent<BossBase>();
				if ((bool)componentInParent)
				{
					componentInParent.GolpearBoss(0);
				}
			}
			else
			{
				base.transform.GetComponentInParent<SyncBoss>().MasterGolpeoABoss(0);
			}
			if ((bool)arma)
			{
				SepararPadre();
			}
			else if ((bool)gancho)
			{
				SepararPadre();
			}
			drops = null;
			if ((bool)arma)
			{
				arma.miMano.AtraerDesdeAire();
			}
			else if ((bool)gancho)
			{
				gancho.RebotarGancho();
			}
		}
		else
		{
			audioSource.Play();
			base.transform.parent = null;
			GetComponent<SyncBloqueRompible>().RomperElBloque();
		}
		Transform tJugador = GameManager.instance.player.tJugador;
		_ = (base.transform.position - tJugador.position).normalized;
		bloque.SetActive(value: false);
		bloqueRompiendose.SetActive(value: true);
		pistolaAnclada = false;
		foreach (Transform item in bloqueRompiendose.transform)
		{
			if ((bool)item.GetComponent<Rigidbody>())
			{
				item.GetComponent<Rigidbody>().AddExplosionForce(Fuerza, posicion, 1f, 1f, ForceMode.Impulse);
			}
		}
		if (drops != null)
		{
			GameObject gameObject = SeleccionarDrop();
			if ((bool)gameObject)
			{
				UnityEngine.Object.Instantiate(gameObject, base.transform.position, Quaternion.identity, null);
			}
		}
		if (!isEscudo && !isBoss)
		{
			UnityEngine.Object.Destroy(GetComponent<BoxCollider>());
			UnityEngine.Object.Destroy(this);
		}
	}

	private GameObject SeleccionarDrop()
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < drops.Length; i++)
		{
			num2 += drops[i].probabilidad;
		}
		if (num2 == 0)
		{
			return null;
		}
		int num3 = 0;
		int[] array = new int[num2];
		for (int j = 0; j < drops.Length; j++)
		{
			for (int k = 0; k < drops[j].probabilidad; k++)
			{
				array[num3] = j;
				num3++;
			}
		}
		num = UnityEngine.Random.Range(0, num2);
		return drops[array[num]].drop;
	}
}
public class Esera : MonoBehaviour
{
	public float vel;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position += new Vector3(vel, 0f, 0f);
	}
}
public class GameManager : MonoBehaviour
{
	public static GameManager instance;

	[HideInInspector]
	public string tagBala = "Bala";

	[HideInInspector]
	public string tagPistola = "Pistola";

	[HideInInspector]
	public string tagPistolaGanchoOnline = "PistolaGanchoOnline";

	[HideInInspector]
	public string tagEsfera = "Esfera";

	[HideInInspector]
	public string tagMano = "Mano";

	[HideInInspector]
	public string tagPared = "Pared";

	[HideInInspector]
	public string tagParedPistola = "ParedPistola";

	[HideInInspector]
	public string tagRompible = "Rompible";

	[HideInInspector]
	public string tagParedMovible = "ParedMovible";

	[HideInInspector]
	public string tagDestructorDeCubos = "DestructorDeCubos";

	[HideInInspector]
	public string tagBalaEsfera = "BalaEsfera";

	[HideInInspector]
	public string tagCadenaOriginal = "CadenaOriginal";

	[HideInInspector]
	public string tagCadena = "Cadena";

	[HideInInspector]
	public string tagBoss = "Boss";

	[HideInInspector]
	public int layerPistolaTrigger = 16;

	[HideInInspector]
	public int layerMina = 25;

	[HideInInspector]
	public int layerBala = 18;

	[HideInInspector]
	public int layerCadenas = 11;

	[HideInInspector]
	public int layerBalasEsfera = 12;

	[HideInInspector]
	public int layerEsfera = 10;

	[HideInInspector]
	public int layerArma = 9;

	[HideInInspector]
	public Player player;

	[HideInInspector]
	public SalasManager m_salaManager;

	[HideInInspector]
	public Musica m_musica;

	[HideInInspector]
	public int paisActual;

	[HideInInspector]
	public int nivelesJugadosSinProTip;

	[HideInInspector]
	public int nivelActual;

	[HideInInspector]
	public bool comenzarPartidaOnline;

	[HideInInspector]
	public bool hayEquipoGanador;

	[HideInInspector]
	public bool bloquearBotones;

	[HideInInspector]
	public ParedMovible paredMovible;

	[HideInInspector]
	public bool estoyMuertoYMeEstanEnseñandoQueMeHaMatado;

	[HideInInspector]
	public List<EsferaScript> esferasActivas = new List<EsferaScript>();

	[HideInInspector]
	public BossBase bossNivel;

	[HideInInspector]
	public bool vengoDeBoss;

	[HideInInspector]
	public bool nuevoPaisDesloqueado;

	[HideInInspector]
	public List<GameObject> torretasEncendidas = new List<GameObject>();

	[HideInInspector]
	public List<GameObject> minasEncendidas = new List<GameObject>();

	[HideInInspector]
	public List<GameObject> bloquesEncendidos = new List<GameObject>();

	[HideInInspector]
	public bool vengoDeMuerto;

	[HideInInspector]
	public Vector3 ultimaRotacionCabeza = Vector3.zero;

	[HideInInspector]
	public Vector3 ultimaPosicionRelativaCabeza = Vector3.zero;

	[HideInInspector]
	public InputsController.TipoSensores tipoDeSensores = InputsController.TipoSensores.ninguno;

	[HideInInspector]
	public InputsController.JoyInput teclado;

	[HideInInspector]
	public InputsController.JoyInput senDer;

	[HideInInspector]
	public InputsController.JoyInput senIzq;

	[HideInInspector]
	public InputsController.JoyInput mando;

	[HideInInspector]
	public InputsController.JoyInput rudder;

	[HideInInspector]
	public InputsController.JoyInput tracker;

	[HideInInspector]
	public SkinnedMeshRenderer neoGigante;

	[HideInInspector]
	public LIV.SDK.Unity.LIV liv;

	public string logFPS = "";

	[HideInInspector]
	public bool vozHabilitada;

	[HideInInspector]
	public bool vibracionHabilitada;

	[HideInInspector]
	public int PartidasAcabadasSinCambiarEntreGanchoBala;

	[HideInInspector]
	public bool nivelInicioMenu;

	[HideInInspector]
	public bool infoServidorObtenida;

	[HideInInspector]
	public bool esperandoCojerPowerUp;

	[HideInInspector]
	public bool UltimoModoHaSidoOnline;

	[HideInInspector]
	public bool seAcabanDePasarElBoss;

	[HideInInspector]
	public bool acaboDeSerMaster;

	[HideInInspector]
	public bool verisionConOnlineCompletamenteAnulado;

	private bool pasarTexto;

	private bool mensajeInGame;

	private bool antiMonkeyActivado;

	private float tiempoMensajeActivado;

	private int mensajeEstandar;

	[HideInInspector]
	public bool powerUpTiempoActivo;

	[HideInInspector]
	public int numEsferasMientrasPWTiempo;

	[HideInInspector]
	public bool jugadoresMuteados;

	[HideInInspector]
	public bool cascoQuitado;

	[HideInInspector]
	public bool dashOpened;

	public bool ponerMenuPaisActual;

	private Coroutine corLerpColorLuz;

	private Coroutine corLerpColorLuzBoss;

	private Coroutine mostrarMensaje;

	private Coroutine quitarMensajeEnXSeg;

	public bool powerUpShotgunActivo;

	public int numEsferasMientrasPWShotgun;

	public bool powerUpLaserActivo;

	public int numEsferasMientrasPWLaser;

	public void Resetear()
	{
		comenzarPartidaOnline = false;
		hayEquipoGanador = false;
		estoyMuertoYMeEstanEnseñandoQueMeHaMatado = false;
		esferasActivas.Clear();
		torretasEncendidas.Clear();
		minasEncendidas.Clear();
		bloquesEncendidos.Clear();
		esperandoCojerPowerUp = false;
		pasarTexto = false;
		mensajeInGame = false;
		antiMonkeyActivado = false;
		mensajeEstandar = 0;
		powerUpTiempoActivo = false;
		numEsferasMientrasPWTiempo = 0;
		StopAllCoroutines();
	}

	private void Awake()
	{
		if ((bool)instance && instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		verisionConOnlineCompletamenteAnulado = Config.verisionConOnlineCompletamenteAnulado;
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(this);
		layerPistolaTrigger = LayerMask.NameToLayer("PistolaTrigger");
		layerMina = LayerMask.NameToLayer("Mina");
		layerBala = LayerMask.NameToLayer("Bala");
		layerCadenas = LayerMask.NameToLayer("Cadenas");
		layerBalasEsfera = LayerMask.NameToLayer("BalasEsfera");
		layerEsfera = LayerMask.NameToLayer("Esfera");
		layerArma = LayerMask.NameToLayer("Arma");
		PersistentDataManager.LoadData();
		PersistentDataManager.SetInt("ArchivoDeGuardadoCreado", 1);
		base.gameObject.AddComponent<DeteccionDispositivos>();
		PhotonNetwork.GenerarVersionPUN();
	}

	private void Start()
	{
		jugadoresMuteados = PersistentDataManager.GetInt("JugadoresMuteados") == 1;
	}

	private void Update()
	{
		if (!InputsController.instance)
		{
			return;
		}
		if (InputsController.instance.triggerDerechoUp && (bool)player && !player.zonaOscuraActivada)
		{
			bool flag = !player.controladorManoDerecha || !player.controladorManoDerecha.audioSourcePanelChica || player.controladorManoDerecha.audioSourcePanelChica.adioSourcesMensajes == null || player.controladorManoDerecha.audioSourcePanelChica.adioSourcesMensajes.Length < 4;
			if (!flag)
			{
				flag = nivelActual + 1 != 10 || !player.controladorManoDerecha.audioSourcePanelChica.adioSourcesMensajes[3].isPlaying;
			}
			if (Config.zurdo || (nivelActual + 1 == 10 && tiempoMensajeActivado + 3f > Time.time))
			{
				flag = false;
			}
			if (flag)
			{
				pasarTexto = true;
				if (mensajeInGame)
				{
					if (quitarMensajeEnXSeg != null)
					{
						StopCoroutine(quitarMensajeEnXSeg);
					}
					MostrarOcultarMensajeBinarity(estado: false, 999, 5f);
				}
			}
		}
		if (InputsController.instance.triggerIzquierdoUp && (bool)player && !player.zonaOscuraActivada)
		{
			bool flag2 = !player.controladorManoIzquierda || !player.controladorManoIzquierda.audioSourcePanelChica || player.controladorManoIzquierda.audioSourcePanelChica.adioSourcesMensajes == null || player.controladorManoIzquierda.audioSourcePanelChica.adioSourcesMensajes.Length < 4;
			if (!flag2)
			{
				flag2 = nivelActual + 1 != 10 || !player.controladorManoIzquierda.audioSourcePanelChica.adioSourcesMensajes[3].isPlaying;
			}
			if (!Config.zurdo || (nivelActual + 1 == 10 && tiempoMensajeActivado + 3f > Time.time))
			{
				flag2 = false;
			}
			if (flag2)
			{
				pasarTexto = true;
				if (mensajeInGame)
				{
					if (quitarMensajeEnXSeg != null)
					{
						StopCoroutine(quitarMensajeEnXSeg);
					}
					MostrarOcultarMensajeBinarity(estado: false, 999, 5f);
				}
			}
		}
		if (powerUpTiempoActivo && TimeManager.instance.GetTiempoParado() <= 0f)
		{
			powerUpTiempoActivo = false;
			numEsferasMientrasPWTiempo = 0;
		}
	}

	public void CargarMenu()
	{
		ponerMenuPaisActual = true;
		mostrarMensaje = null;
		mensajeInGame = false;
		antiMonkeyActivado = false;
		bloquearBotones = false;
		if (LoadingCamera.instance.estadoActual == LoadingCamera.EstadosCamaraLoading.desactivada)
		{
			LoadingCamera.instance.CargarEscena("MenuPrincipal");
		}
	}

	public void FelicitarCompetitivoYVolverAMenu()
	{
		StartCoroutine(Felicitar());
	}

	private IEnumerator Felicitar()
	{
		if ((bool)m_salaManager && (bool)m_salaManager.confeti)
		{
			m_salaManager.confeti.SetActive(value: true);
		}
		yield return new WaitForSeconds(3f);
		PartidaSync.instance.EstamosTodosMuertos();
		yield return new WaitForSeconds(3f);
		if (PhotonNetwork.IsMasterClient)
		{
			instance.player.Reiniciar();
		}
	}

	public string NombrePais(int numero, TextMeshProUGUI texto = null)
	{
		return numero switch
		{
			0 => LanguageManager.instance.DameTexto("#Japan", texto), 
			1 => LanguageManager.instance.DameTexto("#Egypt", texto), 
			2 => LanguageManager.instance.DameTexto("#Mexico", texto), 
			3 => LanguageManager.instance.DameTexto("#Singapore", texto), 
			4 => LanguageManager.instance.DameTexto("#Russia", texto), 
			5 => LanguageManager.instance.DameTexto("#Thailand", texto), 
			6 => LanguageManager.instance.DameTexto("#China", texto), 
			7 => LanguageManager.instance.DameTexto("#Korea", texto), 
			8 => LanguageManager.instance.DameTexto("#Australia", texto), 
			9 => LanguageManager.instance.DameTexto("#Belgium", texto), 
			10 => LanguageManager.instance.DameTexto("#UnitedStates", texto), 
			11 => LanguageManager.instance.DameTexto("#Spain", texto), 
			12 => LanguageManager.instance.DameTexto("#Brazil", texto), 
			13 => LanguageManager.instance.DameTexto("#Canada", texto), 
			_ => "", 
		};
	}

	public void EquipoGana(int equipoGanador, int idPhotonObjetoMuerte, bool porEliminacionDeBolas = false)
	{
		if (equipoGanador == 1)
		{
			PartidaSync.instance.puntuacionEquipo1++;
		}
		else
		{
			PartidaSync.instance.puntuacionEquipo2++;
		}
		if (PartidaSync.instance.miJugador.equipo == equipoGanador)
		{
			player.PonerAudioEnAudioSource(Player.ClipsAudioJugador.Cool);
		}
		else
		{
			player.PonerAudioEnAudioSource(Player.ClipsAudioJugador.Muerte);
		}
		StartCoroutine(EsperarAResetearTrasVisctoria(equipoGanador, idPhotonObjetoMuerte, porEliminacionDeBolas));
	}

	private IEnumerator EsperarAResetearTrasVisctoria(int equipoGanador, int idPhotonObjetoMuerte, bool porEliminacionDeBolas = false)
	{
		hayEquipoGanador = true;
		if ((bool)player.weaponDer)
		{
			player.weaponDer.Apagar();
		}
		if ((bool)player.weaponIzq)
		{
			player.weaponIzq.Apagar();
		}
		if ((bool)player.rifle)
		{
			player.rifle.ApagarRifle();
		}
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key].equipo != equipoGanador)
			{
				PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer).GetComponent<SyncJugadores>().PonermeFantasma();
			}
		}
		PhotonView photonView = null;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
		{
			photonView = PhotonView.Find(idPhotonObjetoMuerte);
		}
		GameObject objetoMuerte = null;
		if ((bool)photonView)
		{
			objetoMuerte = photonView.gameObject;
		}
		if (!porEliminacionDeBolas)
		{
			EliminarObjetos(objetoMuerte, porVictoria: true);
		}
		m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.GanadorCompetitivo, equipoGanador);
		yield return new WaitForSeconds(4f);
		EliminarObjetos(null, porVictoria: true);
		if (Config.modoDePartida == Config.ModoDePartida.Competitivo)
		{
			instance.player.pararTiempo = false;
		}
		if (PhotonNetwork.IsMasterClient)
		{
			if (PartidaSync.instance.puntuacionEquipo1 >= PartidaSync.instance.MAXPARTIDASCOMPETITIVO || PartidaSync.instance.puntuacionEquipo2 >= PartidaSync.instance.MAXPARTIDASCOMPETITIVO)
			{
				PartidaSync.instance.PartidaArenaAcabada();
			}
			else
			{
				PartidaSync.instance.EstamosTodosMuertos();
			}
		}
	}

	public void EliminarObjetos(GameObject objetoMuerte, bool porVictoria = false)
	{
		PoolObjetos.instance.EliminarTodosLosObjetos(objetoMuerte, porVictoria);
		if (PhotonNetwork.IsMasterClient)
		{
			return;
		}
		foreach (SyncPelota item in PartidaSync.instance.pelotasSync)
		{
			if (!(item == null))
			{
				item.activadaSegunRed = false;
				item.ActivarDesactivar(activar: false);
				item.SetEstaActivada(-1);
			}
		}
	}

	public void ApagarMeshesDeLasBolasMenosLaQueMeHaMatadoPorUnRato(GameObject bolaQueMeHaMatado)
	{
		estoyMuertoYMeEstanEnseñandoQueMeHaMatado = true;
		foreach (Transform item in NivelCompletado.instance.listaEsferasEquipo1)
		{
			if (!bolaQueMeHaMatado || !(bolaQueMeHaMatado.transform == item))
			{
				Bola component = item.GetComponent<Bola>();
				if ((bool)component)
				{
					component.mesh.enabled = false;
				}
			}
		}
		foreach (Transform item2 in NivelCompletado.instance.listaEsferasEquipo2)
		{
			if (!bolaQueMeHaMatado || !(bolaQueMeHaMatado.transform == item2))
			{
				Bola component2 = item2.GetComponent<Bola>();
				if ((bool)component2)
				{
					component2.mesh.enabled = false;
				}
			}
		}
		StartCoroutine(EncenderDeNuevoLasBolas());
	}

	private IEnumerator EncenderDeNuevoLasBolas()
	{
		yield return new WaitForSeconds(4f);
		foreach (Transform item in NivelCompletado.instance.listaEsferasEquipo1)
		{
			Bola component = item.GetComponent<Bola>();
			if ((bool)component)
			{
				component.mesh.enabled = true;
			}
		}
		foreach (Transform item2 in NivelCompletado.instance.listaEsferasEquipo2)
		{
			Bola component2 = item2.GetComponent<Bola>();
			if ((bool)component2)
			{
				component2.mesh.enabled = true;
			}
		}
		instance.player.noPoderMoverse = false;
		estoyMuertoYMeEstanEnseñandoQueMeHaMatado = false;
	}

	public float GetTiempoSalidaPared()
	{
		return m_salaManager.niveles[nivelActual].GetComponent<ObjetosDelNivel>().tiempoDeSalidaDePared;
	}

	public void ActivarPanico(AudioSource aS)
	{
		if (corLerpColorLuz != null)
		{
			StopCoroutine(corLerpColorLuz);
		}
		corLerpColorLuz = StartCoroutine(LerpActivarPanico(aS));
	}

	public void DesactivarPanico()
	{
		if (corLerpColorLuz != null)
		{
			StopCoroutine(corLerpColorLuz);
		}
		m_salaManager.lucesSala.material.color = m_salaManager.luzSalaNormalColor;
	}

	private IEnumerator LerpActivarPanico(AudioSource aS)
	{
		Color colorInicial = m_salaManager.lucesSala.material.color;
		Color colorFinal = m_salaManager.luzSalaAlarmaColor * 2f;
		float count = 0f;
		while (m_salaManager.nivelIniciado && (bool)m_salaManager && (bool)aS)
		{
			float num = aS.time / aS.clip.length;
			num = ((num >= 0.3f && num < 0.5f) ? (num - 0.5f) : ((num >= 0.5f) ? ((num - 0.5f) * 2f) : ((!(num <= 0.1f)) ? (num - 0.1f) : (1f - num * 10f))));
			m_salaManager.lucesSala.material.color = Color.Lerp(colorFinal, colorInicial, num);
			count += Time.deltaTime;
			yield return null;
			if (!m_salaManager || !aS)
			{
				break;
			}
		}
	}

	public void ActivarPanicoBoss()
	{
		if (corLerpColorLuzBoss != null)
		{
			StopCoroutine(corLerpColorLuzBoss);
		}
		corLerpColorLuzBoss = StartCoroutine(LerpActivarPanicBoss());
	}

	public void DesactivarPanicoBoss()
	{
		if (corLerpColorLuzBoss != null)
		{
			StopCoroutine(corLerpColorLuzBoss);
		}
		m_salaManager.lucesSala.material.color = m_salaManager.luzSalaNormalColor;
	}

	private IEnumerator LerpActivarPanicBoss()
	{
		yield return new WaitForSeconds(0.5f);
		Color colorInicial = m_salaManager.lucesSala.material.color;
		Color colorFinal = Color.red;
		int ciclos = 0;
		while (ciclos < 3)
		{
			for (int j = 0; j < 120; j++)
			{
				m_salaManager.lucesSala.material.color = Color.Lerp(colorFinal, colorInicial, Time.deltaTime / 2f);
				yield return null;
			}
			for (int j = 0; j < 50; j++)
			{
				m_salaManager.lucesSala.material.color = Color.Lerp(colorInicial, colorFinal, Time.deltaTime / 2f);
				yield return null;
			}
			ciclos++;
			yield return null;
		}
		m_salaManager.controladorTVs.CorutinaFinalEntradaBoss();
	}

	public void MostrarOcultarMensajeBinarity(bool estado, int numeroMensaje, float tiempoMensaje = 999f, int chica = -1)
	{
		if (numeroMensaje == 10501)
		{
			chica = 0;
		}
		if (numeroMensaje == 31001)
		{
			chica = 0;
		}
		if (numeroMensaje == 51001)
		{
			chica = 0;
		}
		if (numeroMensaje == 71001)
		{
			chica = 0;
		}
		if (numeroMensaje == 91001)
		{
			chica = 0;
		}
		if (numeroMensaje == 101001)
		{
			chica = 0;
		}
		if (numeroMensaje == 141001)
		{
			chica = 0;
		}
		if (numeroMensaje == 50201)
		{
			chica = 0;
		}
		if (numeroMensaje == 70201)
		{
			chica = 0;
		}
		int num = numeroMensaje;
		int num2 = 0;
		while (num > 10000)
		{
			num -= 10000;
		}
		while (num > 100)
		{
			num -= 100;
		}
		num2 = num;
		if (Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			if (quitarMensajeEnXSeg != null)
			{
				StopCoroutine(quitarMensajeEnXSeg);
			}
			if (mostrarMensaje == null)
			{
				mostrarMensaje = StartCoroutine(CorroutinaMostrarMensaje(estado, MensajeBinarity(numeroMensaje), num2, tiempoMensaje, chica));
			}
		}
	}

	private IEnumerator CorroutinaMostrarMensaje(bool estado, string mensaje, int numMensaje, float tiempoMensaje, int chica)
	{
		tiempoMensajeActivado = Time.time;
		if (!estado)
		{
			TimeManager.instance.ActivarDesactivarTiempoMuerto(estado);
			if (antiMonkeyActivado)
			{
				yield break;
			}
			mensajeInGame = false;
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.MostrarOcultarMensajeTrynity(estado, "");
			}
			else
			{
				player.controladorManoIzquierda.MostrarOcultarMensajeTrynity(estado, "");
			}
			m_salaManager.controladorTVs.MostrarOcultarMensajeTrynity(estado, "");
			if (player.noPoderMoverse)
			{
				player.noPoderMoverse = false;
			}
			yield return null;
		}
		else if (tiempoMensaje < 999f)
		{
			TimeManager.instance.ActivarDesactivarTiempoMuerto(estado);
			mensajeInGame = true;
			player.noPoderMoverse = true;
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.MostrarOcultarMensajeTrynity(estado, mensaje);
			}
			else
			{
				player.controladorManoIzquierda.MostrarOcultarMensajeTrynity(estado, mensaje);
			}
			m_salaManager.controladorTVs.MostrarOcultarMensajeTrynity(estado, mensaje, gatillo: true, chica);
			quitarMensajeEnXSeg = StartCoroutine(ApagarMensajeBinarityXSegundos(tiempoMensaje));
			antiMonkeyActivado = true;
			yield return new WaitForSeconds(1f);
			antiMonkeyActivado = false;
		}
		else
		{
			string[] aux = mensaje.Split('|');
			pasarTexto = false;
			for (int i = 0; i < aux.Length; i++)
			{
				if (!Config.zurdo)
				{
					player.controladorManoDerecha.MostrarOcultarMensajeTrynity(estado, aux[i], gatillo: true, (i != 0) ? true : false);
				}
				else
				{
					player.controladorManoIzquierda.MostrarOcultarMensajeTrynity(estado, aux[i], gatillo: true, (i != 0) ? true : false);
				}
				m_salaManager.controladorTVs.MostrarOcultarMensajeTrynity(estado, aux[i], gatillo: true, chica);
				while (!pasarTexto)
				{
					yield return null;
				}
				if (!Config.zurdo)
				{
					player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeNivel(numMensaje, i + 1);
					player.controladorManoDerecha.audioSourcePanelChica.PonerClipParteParrafo();
					player.controladorManoDerecha.audioSourcePanelChica.adioSourcesMensajes[1].Play();
				}
				else
				{
					player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeNivel(numMensaje, i + 1);
					player.controladorManoIzquierda.audioSourcePanelChica.PonerClipParteParrafo();
					player.controladorManoIzquierda.audioSourcePanelChica.adioSourcesMensajes[1].Play();
				}
				pasarTexto = false;
			}
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.MostrarOcultarMensajeTrynity(estado: false, "");
			}
			else
			{
				player.controladorManoIzquierda.MostrarOcultarMensajeTrynity(estado: false, "");
			}
			m_salaManager.controladorTVs.MostrarOcultarMensajeTrynity(estado: false, "");
			TimeManager.instance.ActivarDesactivarTiempoMuerto(estado: false);
			player.MostrarPistolas();
			yield return null;
		}
		mostrarMensaje = null;
	}

	private IEnumerator ApagarMensajeBinarityXSegundos(float segundos)
	{
		yield return new WaitForSeconds(segundos);
		MostrarOcultarMensajeBinarity(estado: false, 999, 5f);
	}

	public string MensajeBinarity(int num)
	{
		if (num == 10)
		{
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeNoPower();
			}
			else
			{
				player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeNoPower();
			}
			return LanguageManager.instance.DameTexto("#MensajeNoUsoPoder");
		}
		if (num == 50)
		{
			int num2 = PlayerProgreso.instance.proTipQueTocaMostrar;
			PlayerProgreso.instance.proTipQueTocaMostrar++;
			if (PlayerProgreso.instance.proTipQueTocaMostrar > 4)
			{
				PlayerProgreso.instance.proTipQueTocaMostrar = 1;
			}
			int num3 = instance.paisActual + 1;
			int num4 = instance.nivelActual + 1;
			if (num3 == 1 && num4 == 3)
			{
				num2 = 0;
			}
			if (num3 == 1 && num4 == 6)
			{
				num2 = 2;
			}
			if (num3 == 1 && num4 == 7)
			{
				num2 = 1;
			}
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeProTip(num2);
			}
			else
			{
				player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeProTip(num2);
			}
			return LanguageManager.instance.DameTexto("#ProTip" + num2);
		}
		if (num > 999)
		{
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num > 10000)
			{
				num5++;
				num -= 10000;
			}
			while (num > 100)
			{
				num6++;
				num -= 100;
			}
			num7 = num;
			if (num5 == 1 && num6 == 7)
			{
				if (!Config.zurdo)
				{
					player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeProTip(1);
				}
				else
				{
					player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeProTip(1);
				}
				return LanguageManager.instance.DameTexto("#ProTip1");
			}
			if (!Config.zurdo)
			{
				player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeNivel(num7, 0);
			}
			else
			{
				player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeNivel(num7, 0);
			}
			return LanguageManager.instance.DameTexto("#MensajeNivel" + num5 + "-" + num6 + "_" + num7);
		}
		return MostrarMensajeEstandar();
	}

	private string MostrarMensajeEstandar()
	{
		mensajeEstandar++;
		if (mensajeEstandar > 11)
		{
			mensajeEstandar = 1;
		}
		if (!Config.zurdo)
		{
			player.controladorManoDerecha.audioSourcePanelChica.CargarClipMensajeEstandar(mensajeEstandar);
		}
		else
		{
			player.controladorManoIzquierda.audioSourcePanelChica.CargarClipMensajeEstandar(mensajeEstandar);
		}
		return LanguageManager.instance.DameTexto("#MensajeCelebracion" + mensajeEstandar);
	}

	public string DameMensajeBoss()
	{
		return LanguageManager.instance.DameTexto("#MensajeBoss" + (paisActual + 1));
	}

	public string DameNombreBossDelMundo(int mundo)
	{
		return mundo switch
		{
			1 => "Japanesphere", 
			2 => "Pharaohmference", 
			3 => "Tacosphere", 
			4 => "Singasphere", 
			5 => "Spherovski", 
			6 => "Thai-sphere", 
			7 => "Chinesphere", 
			8 => "Coreameter", 
			9 => "Australference", 
			10 => "Ball-gium", 
			11 => "United Spheres of America", 
			12 => "Flamencumference", 
			13 => "Sambasphere", 
			14 => "Canadiameter", 
			_ => "Boss", 
		};
	}

	public void PararJuegoEsperandoCojerPowerUp()
	{
		if ((bool)m_salaManager && (bool)m_salaManager.FlechaPowerUp)
		{
			esperandoCojerPowerUp = true;
			TimeManager.instance.tiempoMuerto = true;
			m_salaManager.FlechaPowerUp.SetActive(value: true);
			player.noPoderMoverse = true;
		}
	}

	public void SubirRecord(string mundo, int valor)
	{
		if ((bool)LogrosRecords.instance)
		{
			UnityEngine.Debug.Log("Mundo: " + mundo + " Puntuacion: " + valor);
			LogrosRecords.instance.SubirRecord(mundo, valor);
		}
	}

	public void SetLogro(LogrosRecords.Logros logro)
	{
		if ((bool)LogrosRecords.instance)
		{
			LogrosRecords.instance.MarcarLogroCompletado(LogrosRecords.instance.DameNombreAchivement(logro));
			ComprobarLogroPlatino();
		}
	}

	public void ComprobarLogroPlatino()
	{
		if ((bool)LogrosRecords.instance)
		{
			LogrosRecords.instance.ComprobarYDarLogroPlatino();
		}
	}

	public string GetNombreDelJugador()
	{
		return "";
	}

	public void SetNombreDelJugador(string nombre)
	{
	}

	public void SumarEsferaDestruidaDurantePowerUpTiempo()
	{
		numEsferasMientrasPWTiempo++;
		if (numEsferasMientrasPWTiempo == 5)
		{
			SetLogro(LogrosRecords.Logros.TimePW5);
		}
		else if (numEsferasMientrasPWTiempo == 10)
		{
			SetLogro(LogrosRecords.Logros.TimePW10);
		}
	}

	public void SumarEsferaDestruidaDurantePowerUpShotgun()
	{
		numEsferasMientrasPWShotgun++;
		if (numEsferasMientrasPWShotgun == 5)
		{
			SetLogro(LogrosRecords.Logros.ShotgunPW5);
		}
		else if (numEsferasMientrasPWShotgun == 10)
		{
			SetLogro(LogrosRecords.Logros.ShotgunPW10);
		}
	}

	public void SumarEsferaDestruidaDurantePowerUpLaser()
	{
		numEsferasMientrasPWLaser++;
		if (numEsferasMientrasPWLaser == 5)
		{
			SetLogro(LogrosRecords.Logros.LaserPW5);
		}
		else if (numEsferasMientrasPWLaser == 10)
		{
			SetLogro(LogrosRecords.Logros.LaserPW10);
		}
	}

	public void SumarPuntosMundoYEnviarRecord(int puntuacion)
	{
		int num = 0;
		for (int i = 0; i < 10; i++)
		{
			num = ((i != nivelActual) ? (num + PersistentDataManager.GetInt("Record_Mundo" + paisActual + "_Nivel" + i)) : (num + puntuacion));
		}
		SubirRecord("Mundo" + (paisActual + 1), num);
	}
}
public class GestorVinetas : MonoBehaviour
{
	[Serializable]
	public struct TextosViñeta
	{
		public TextMeshProUGUI textosViñetas;

		public string[] contTextosViñetas;

		public AudioClip[] sonidosViñetas;

		public AudioClip musica;
	}

	public bool final;

	public Animator animacion;

	public GameObject[] viñetas;

	public TextosViñeta[] textos;

	private ControladorMenu m_controldorMenu;

	public AudioSource audioSourceMusica;

	public ControladorMenu m_controladorMenu;

	private int viñetaActual;

	private int textoViñetaActual;

	private int sonidoViñetaActual;

	public GameObject botonCerrar;

	private bool estabaReproduciendose;

	private bool pausado;

	private bool cerrarMostrada;

	private void Start()
	{
		m_controldorMenu = GameObject.Find("ControladorMenu").GetComponent<ControladorMenu>();
		m_controladorMenu.gestorViñetas = this;
		CargarTextos();
		viñetas[0].SetActive(value: true);
		viñetaActual = 0;
		textoViñetaActual = 0;
		sonidoViñetaActual = 0;
	}

	private void Update()
	{
		if ((Input.GetKeyDown(KeyCode.Return) || InputsController.instance.triggerDerechoUp || InputsController.instance.triggerIzquierdoUp) && !cerrarMostrada)
		{
			MostrarCerrar();
		}
	}

	private void OnEnable()
	{
		try
		{
			animacion.enabled = true;
			viñetas[0].SetActive(value: true);
			for (int i = 0; i < GameManager.instance.m_musica.audioSourcesMusica.Length; i++)
			{
				GameManager.instance.m_musica.audioSourcesMusica[i].Stop();
			}
			GameManager.instance.player.controladorManoDerecha.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoDerecha.animManos.MenuNormal();
			GameManager.instance.player.controladorManoIzquierda.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoIzquierda.animManos.MenuNormal();
		}
		catch
		{
		}
	}

	private void GestorTexto(int texto)
	{
		StartCoroutine(CargarTextoPorLetras(textos[viñetaActual].textosViñetas, textos[viñetaActual].contTextosViñetas[texto]));
	}

	private void GestorSonido(int sonido, int loop)
	{
		m_controldorMenu.audioSourceMenu.clip = textos[viñetaActual].sonidosViñetas[sonido];
		m_controldorMenu.audioSourceMenu.Play();
		m_controldorMenu.audioSourceMenu.loop = true;
	}

	private IEnumerator CargarTextoPorLetras(TextMeshProUGUI textMesh, string st)
	{
		int cont = 0;
		string textoPintado = "";
		string[] lineas = st.Split('/');
		_ = st.Split('/').Length;
		int lineaActual = 0;
		int countLineas = 0;
		while (cont < st.Length)
		{
			textoPintado += st[cont];
			cont++;
			if (cont < st.Length)
			{
				if (st[cont] == '/')
				{
					UnityEngine.Debug.Log(st[cont]);
					countLineas++;
					if (countLineas > 2)
					{
						textoPintado = lineas[lineaActual];
					}
					lineaActual++;
				}
				else
				{
					textoPintado += st[cont];
				}
				cont++;
			}
			textMesh.text = textoPintado;
			TMP_FontAsset fuentePro = LanguageManager.instance.GetFuentePro();
			if ((bool)fuentePro)
			{
				textMesh.font = fuentePro;
			}
			yield return new WaitForSeconds(0.01f);
		}
		m_controldorMenu.audioSourceMenu.Stop();
	}

	private void CargarSiguienteTexto()
	{
		GestorTexto(textoViñetaActual);
		textoViñetaActual++;
	}

	private void CargarSiguienteSonido(int loop)
	{
		GestorSonido(sonidoViñetaActual, loop);
		sonidoViñetaActual++;
	}

	private void CargarTextos()
	{
		if (!final)
		{
			textos[0].contTextosViñetas = new string[3];
			textos[0].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta1_1");
			textos[0].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVineta1_2");
			textos[0].contTextosViñetas[2] = LanguageManager.instance.DameTexto("#textoVineta1_3");
			textos[1].contTextosViñetas = new string[1];
			textos[1].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta2_1");
			textos[2].contTextosViñetas = new string[2];
			textos[2].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta3_1");
			textos[2].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVineta3_2");
			textos[3].contTextosViñetas = new string[3];
			textos[3].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta4_1");
			textos[3].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVineta4_2");
			textos[3].contTextosViñetas[2] = LanguageManager.instance.DameTexto("#textoVineta4_3");
			textos[4].contTextosViñetas = new string[3];
			textos[4].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta5_1");
			textos[4].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVineta5_2");
			textos[4].contTextosViñetas[2] = LanguageManager.instance.DameTexto("#textoVineta5_3");
			textos[5].contTextosViñetas = new string[3];
			textos[5].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta6_1");
			textos[5].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVineta6_2");
			textos[5].contTextosViñetas[2] = LanguageManager.instance.DameTexto("#textoVineta6_3");
			textos[6].contTextosViñetas = new string[1];
			textos[6].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVineta7_1");
		}
		else
		{
			textos[1].contTextosViñetas = new string[2];
			textos[1].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVinetaFinal2_1");
			textos[1].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVinetaFinal2_2");
			textos[2].contTextosViñetas = new string[2];
			textos[2].contTextosViñetas[0] = LanguageManager.instance.DameTexto("#textoVinetaFinal3_1");
			textos[2].contTextosViñetas[1] = LanguageManager.instance.DameTexto("#textoVinetaFinal3_2");
		}
	}

	private void PonerMusica()
	{
		audioSourceMusica.clip = textos[viñetaActual].musica;
		audioSourceMusica.Play();
	}

	public void PausarSonido(bool pausar)
	{
		if (!audioSourceMusica)
		{
			return;
		}
		if (!pausar)
		{
			if (estabaReproduciendose)
			{
				audioSourceMusica.UnPause();
			}
			pausado = false;
		}
		else if (!pausado)
		{
			audioSourceMusica.Pause();
			pausado = true;
			estabaReproduciendose = true;
		}
	}

	private void CargarVineta(int num)
	{
		viñetas[num].SetActive(value: true);
		animacion.SetTrigger("pasarV");
		viñetaActual++;
		textoViñetaActual = 0;
		sonidoViñetaActual = 0;
		PonerMusica();
	}

	public void CargarNivel1()
	{
		GameManager.instance.paisActual = 0;
		GameManager.instance.nivelActual = 0;
		m_controladorMenu.SeleccionarNivel(0);
		PersistentDataManager.SetInt("IntroVista", 1);
		PersistentDataManager.SaveData();
	}

	public void VolverAlInicio()
	{
		animacion.enabled = false;
		viñetaActual = 0;
		textoViñetaActual = 0;
		sonidoViñetaActual = 0;
		audioSourceMusica.Stop();
		m_controladorMenu.CambiarEstadoMenu(0, inicio: true);
		for (int i = 0; i < viñetas.Length; i++)
		{
			viñetas[i].SetActive(value: false);
		}
		GameManager.instance.m_musica.audioSourcesMusica[0].Play();
		try
		{
			GameManager.instance.player.controladorManoDerecha.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: true);
			GameManager.instance.player.controladorManoDerecha.animManos.MenuSeñalar();
			GameManager.instance.player.controladorManoIzquierda.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: true);
			GameManager.instance.player.controladorManoIzquierda.animManos.MenuSeñalar();
		}
		catch
		{
		}
		base.gameObject.SetActive(value: false);
	}

	public void MostrarCerrar()
	{
		try
		{
			botonCerrar.SetActive(value: true);
			cerrarMostrada = true;
			StartCoroutine(EsperarDesactivarCerrar());
			try
			{
				GameManager.instance.player.controladorManoDerecha.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: true);
				GameManager.instance.player.controladorManoDerecha.animManos.MenuSeñalar();
				GameManager.instance.player.controladorManoIzquierda.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: true);
				GameManager.instance.player.controladorManoIzquierda.animManos.MenuSeñalar();
			}
			catch
			{
			}
		}
		catch
		{
		}
	}

	private IEnumerator EsperarDesactivarCerrar()
	{
		yield return new WaitForSeconds(2f);
		botonCerrar.SetActive(value: false);
		cerrarMostrada = false;
		try
		{
			GameManager.instance.player.controladorManoDerecha.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoDerecha.animManos.MenuNormal();
			GameManager.instance.player.controladorManoIzquierda.transform.GetChild(1).GetChild(2).gameObject.SetActive(value: false);
			GameManager.instance.player.controladorManoIzquierda.animManos.MenuNormal();
		}
		catch
		{
		}
	}
}
public class AnimacionEnFuncionDelTiempo : MonoBehaviour
{
	private Animator anim;

	private int ticks;

	private void Start()
	{
		anim = GetComponent<Animator>();
		ticks = 0;
	}

	private void Update()
	{
		if (ticks > 3)
		{
			anim.SetFloat("velocidad", TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo));
		}
		else
		{
			ticks++;
		}
	}
}
public class MoverOffset : MonoBehaviour
{
	public bool conTiempoParado;

	public float velocidad;

	private float incremento;

	private MeshRenderer material;

	public bool enX = true;

	public bool enY;

	private int ticks;

	private void Start()
	{
		material = GetComponent<MeshRenderer>();
		velocidad = 1f;
		ticks = 0;
	}

	private void Update()
	{
		if (ticks > 3)
		{
			float num = 0f;
			float num2 = 0f;
			incremento += velocidad * TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) / 20000f;
			if (enX)
			{
				num = incremento;
			}
			if (enY)
			{
				num2 = incremento;
			}
			if (!conTiempoParado)
			{
				material.material.SetTextureOffset("_MainTex", new Vector2(num * 2f, num2 * 2f));
			}
			else
			{
				material.material.SetTextureOffset("_MainTex", new Vector2(num, num2));
			}
			ticks = 0;
		}
		else
		{
			ticks++;
		}
	}
}
public class RotarObjeto : MonoBehaviour
{
	public bool conTiempoParado;

	public Vector3 eje = Vector3.forward;

	private void Update()
	{
		if (!conTiempoParado)
		{
			base.transform.Rotate(eje * 2f * TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) * Time.deltaTime, Space.Self);
		}
		else
		{
			base.transform.Rotate(eje * TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo), Space.Self);
		}
	}
}
[ExecuteInEditMode]
public class InverseKinematics : MonoBehaviour
{
	public Transform upperArm;

	public Transform forearm;

	public Transform hand;

	public Transform elbow;

	public Transform target;

	[Space(20f)]
	public Vector3 uppperArm_OffsetRotation;

	public Vector3 forearm_OffsetRotation;

	public Vector3 hand_OffsetRotation;

	[Space(20f)]
	public bool handMatchesTargetRotation = true;

	[Space(20f)]
	public bool debug;

	private float angle;

	private float upperArm_Length;

	private float forearm_Length;

	private float arm_Length;

	private float targetDistance;

	private float adyacent;

	private void Start()
	{
	}

	private void LateUpdate()
	{
		if (!(upperArm != null) || !(forearm != null) || !(hand != null) || !(elbow != null) || !(target != null))
		{
			return;
		}
		upperArm.LookAt(target, elbow.position - upperArm.position);
		upperArm.Rotate(uppperArm_OffsetRotation);
		Vector3 vector = Vector3.Cross(elbow.position - upperArm.position, forearm.position - upperArm.position);
		upperArm_Length = Vector3.Distance(upperArm.position, forearm.position);
		forearm_Length = Vector3.Distance(forearm.position, hand.position);
		arm_Length = upperArm_Length + forearm_Length;
		targetDistance = Vector3.Distance(upperArm.position, target.position);
		targetDistance = Mathf.Min(targetDistance, arm_Length - arm_Length * 0.001f);
		adyacent = (upperArm_Length * upperArm_Length - forearm_Length * forearm_Length + targetDistance * targetDistance) / (2f * targetDistance);
		angle = Mathf.Acos(adyacent / upperArm_Length) * 57.29578f;
		upperArm.RotateAround(upperArm.position, vector, 0f - angle);
		forearm.LookAt(target, vector);
		forearm.Rotate(forearm_OffsetRotation);
		if (handMatchesTargetRotation)
		{
			hand.rotation = target.rotation;
			hand.Rotate(hand_OffsetRotation);
		}
		if (debug)
		{
			if (forearm != null && elbow != null)
			{
				UnityEngine.Debug.DrawLine(forearm.position, elbow.position, Color.blue);
			}
			if (upperArm != null && target != null)
			{
				UnityEngine.Debug.DrawLine(upperArm.position, target.position, Color.red);
			}
		}
	}

	private void OnDrawGizmos()
	{
		if (debug && upperArm != null && elbow != null && hand != null && target != null && elbow != null)
		{
			Gizmos.color = Color.gray;
			Gizmos.DrawLine(upperArm.position, forearm.position);
			Gizmos.DrawLine(forearm.position, hand.position);
			Gizmos.color = Color.red;
			Gizmos.DrawLine(upperArm.position, target.position);
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(forearm.position, elbow.position);
		}
	}
}
public abstract class LogrosRecords : MonoBehaviour
{
	public struct Resultado
	{
		public string usuario;

		public int record;

		public int posicion;

		public ulong id;
	}

	public enum OrdenTabla
	{
		ascendente,
		descendente,
		ninguno
	}

	public struct InfoTabla
	{
		public string nombre;

		public OrdenTabla orden;
	}

	public enum Logros
	{
		Streak5,
		Streak10,
		Streak15,
		Streak20,
		TimePW5,
		TimePW10,
		ShotgunPW5,
		ShotgunPW10,
		LaserPW5,
		LaserPW10,
		BossJapan,
		BossEgypt,
		BossMexico,
		BossSingapore,
		BossRussia,
		BossThailand,
		BossChina,
		BossKorea,
		BossAustralia,
		BossBelgium,
		BossUS,
		BossSpain,
		BossBrazil,
		BossCanada,
		Platino
	}

	public delegate void IGSMTablaEncontradaEventHandler(object sender, string tabla);

	public delegate void IGSMResultadosEventHandler(object sender, List<Resultado> resultados, bool dosListados, string tabla);

	public delegate void IGSMResultadoSubidoEventHandler(object sender, int miMejorResultado, string tabla);

	public static LogrosRecords instance;

	public Config.PlataformaJuego m_Plataforma;

	public const int NUM_LOGROS = 25;

	public event IGSMResultadosEventHandler ResultadosObtenidos;

	public event IGSMTablaEncontradaEventHandler TablaEncontrada;

	public event IGSMResultadoSubidoEventHandler RecordSubido;

	private void Awake()
	{
		bool flag = Config.plataforma == Config.PlataformaJuego.SteamVR || Config.plataforma == Config.PlataformaJuego.Oculus || Config.plataforma != Config.PlataformaJuego.PS4;
		if (Config.plataforma == Config.PlataformaJuego.Oculus && Debugs.OmitirPirateoOculus)
		{
			flag = false;
		}
		if (Config.plataforma == Config.PlataformaJuego.SteamVR && Config.versionConSteamCompletamenteAnulado)
		{
			flag = false;
		}
		if (!flag || ((bool)instance && instance != this))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (m_Plataforma == Config.plataforma)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	protected virtual void OnResultadosObtenidos(object sender, List<Resultado> resultados, bool dosListados, string tabla)
	{
		this.ResultadosObtenidos?.Invoke(this, resultados, dosListados, tabla);
	}

	protected virtual void OnTablaEncontrada(object sender, string tabla)
	{
		this.TablaEncontrada?.Invoke(this, tabla);
	}

	protected virtual void OnRecordSubido(object sender, int miMejorResultado, string tabla)
	{
		this.RecordSubido?.Invoke(this, miMejorResultado, tabla);
	}

	public abstract void GuardarLogros();

	public abstract void InicializarLogros();

	public abstract void InicializarTablas(string[] tablas);

	public abstract void InicializarTablas(List<InfoTabla> tablas);

	public abstract void ObtenerResultadosAlrededorMioConTop(string tabla, int resultadosQueQuiero, bool esEvento, long record = -1L);

	public abstract void SubirRecord(string tabla, int record);

	public abstract void MarcarLogroCompletado(string idLogro);

	public abstract string DameMiNombre();

	public abstract void MostrarTienda();

	public abstract void ComprobarYDarLogroPlatino();

	public string DameNombreAchivement(Logros logro)
	{
		return logro switch
		{
			Logros.Streak5 => "pangman_1", 
			Logros.Streak10 => "pangman_2", 
			Logros.Streak15 => "pangman_3", 
			Logros.Streak20 => "pangman_4", 
			Logros.TimePW5 => "pangman_5", 
			Logros.TimePW10 => "pangman_6", 
			Logros.ShotgunPW5 => "pangman_7", 
			Logros.ShotgunPW10 => "pangman_8", 
			Logros.LaserPW5 => "pangman_9", 
			Logros.LaserPW10 => "pangman_10", 
			Logros.BossJapan => "pangman_11", 
			Logros.BossEgypt => "pangman_12", 
			Logros.BossMexico => "pangman_13", 
			Logros.BossSingapore => "pangman_14", 
			Logros.BossRussia => "pangman_15", 
			Logros.BossThailand => "pangman_16", 
			Logros.BossChina => "pangman_17", 
			Logros.BossKorea => "pangman_18", 
			Logros.BossAustralia => "pangman_19", 
			Logros.BossBelgium => "pangman_20", 
			Logros.BossUS => "pangman_21", 
			Logros.BossSpain => "pangman_22", 
			Logros.BossBrazil => "pangman_23", 
			Logros.BossCanada => "pangman_24", 
			Logros.Platino => "pangman_25", 
			_ => "", 
		};
	}
}
public class LookAtTarget : MonoBehaviour
{
	public Transform target;

	public Transform target2;

	public bool enEjeY;

	public bool puntoSpawn;

	private void Start()
	{
	}

	private void Update()
	{
		Vector3 worldPosition = Vector3.zero;
		if ((bool)target)
		{
			worldPosition = target.position;
		}
		else if ((bool)target2)
		{
			worldPosition = target2.position;
		}
		if (enEjeY)
		{
			worldPosition.y = base.transform.position.y;
		}
		if (puntoSpawn && (bool)GameManager.instance.m_salaManager)
		{
			worldPosition = GameManager.instance.m_salaManager.posicionPlayer.transform.position;
		}
		base.transform.LookAt(worldPosition, Vector3.up);
	}
}
public class LuzInicio : MonoBehaviour
{
}
public class ManoLaser : MonoBehaviour
{
	private int layerMaskUI;

	public Transform laser;

	private bool botonApretado;

	private bool sinVR;

	public LineRenderer lineRenderer;

	private Coroutine focusCorr;

	public float distanciaRayo = 0.02f;

	public bool inGame;

	public bool noApagar;

	public bool clickEnUIUpPendiente;

	private Vector3 auxEscalaLaser;

	private Ray rayo;

	private RaycastHit hit;

	public Transform pantalla;

	public Camera camaraAbajo;

	private bool heClicado;

	private bool distanciaTocando;

	public float trigger;

	public bool triggerSoltado = true;

	private BotonMenu boton;

	private BotonMenu ultimoBoton;

	public bool manoDerecha = true;

	private WaitForSecondsRealtime esperaRayoIA;

	private string tagBoton = "Boton";

	public BotonMenu botonSeleccionado;

	private Coroutine esperaBoton;

	private float tiempoEspera = 2f;

	private void OnEnable()
	{
		if ((bool)lineRenderer)
		{
			lineRenderer.enabled = true;
		}
		botonApretado = false;
		esperaBoton = null;
	}

	private void OnDisable()
	{
	}

	private void Start()
	{
		lineRenderer = GetComponent<LineRenderer>();
		if (Config.modoDeJuego != Config.ModosDeJuego.menu && !noApagar)
		{
			base.gameObject.SetActive(value: false);
		}
		sinVR = Debugs.SimularPlayer > 0;
		distanciaRayo = 20f;
		if (sinVR)
		{
			ControladorMano component = base.transform.parent.parent.GetComponent<ControladorMano>();
			if ((bool)component && component.mano == ControladorMano.Mano.Izquierda)
			{
				base.transform.parent.gameObject.SetActive(value: false);
			}
			else
			{
				base.transform.parent.parent.localPosition = new Vector3(0.05f, -0.02f, 0.3f);
				base.transform.parent.parent.localEulerAngles = new Vector3(8.3f, -22.9f, -17.2f);
			}
		}
		layerMaskUI = LayerMask.GetMask("UI");
		esperaRayoIA = new WaitForSecondsRealtime(0.3f);
	}

	private void Update()
	{
		if (GameManager.instance.bloquearBotones)
		{
			return;
		}
		if (manoDerecha)
		{
			trigger = InputsController.instance.triggerDerecho;
		}
		else
		{
			trigger = InputsController.instance.triggerIzquierdo;
		}
		if (!triggerSoltado && trigger < 0.5f)
		{
			triggerSoltado = true;
			trigger = 1f;
		}
		else if (trigger > 0.5f)
		{
			triggerSoltado = false;
			trigger = 0f;
		}
		if (sinVR && Input.GetMouseButtonDown(0))
		{
			trigger = 1f;
		}
		if (!inGame)
		{
			rayo = new Ray(base.transform.position, base.transform.forward * distanciaRayo);
			if (Physics.Raycast(rayo, out hit, distanciaRayo))
			{
				lineRenderer.SetPosition(1, new Vector3(0f, 0f, hit.distance + 0.1f));
				if ((sinVR && !(trigger > 0.5f)) || !hit.transform.CompareTag("PantallaMenu"))
				{
					return;
				}
				if (hit.distance < 0.05f)
				{
					distanciaTocando = true;
				}
				else
				{
					distanciaTocando = false;
				}
				if (!pantalla)
				{
					pantalla = hit.transform;
				}
				rayo = camaraAbajo.ViewportPointToRay(hit.textureCoord);
				if (Physics.Raycast(rayo, out hit, 5000f))
				{
					if (!hit.transform.CompareTag(tagBoton))
					{
						return;
					}
					BotonMenu component = hit.transform.GetComponent<BotonMenu>();
					if ((bool)boton && boton != component)
					{
						boton.SetFoco(foco: false);
					}
					boton = component;
					if (botonApretado)
					{
						return;
					}
					if (trigger > 0.5f)
					{
						tiempoEspera = 0.3f;
						botonApretado = true;
						lineRenderer.enabled = false;
						if (esperaBoton == null)
						{
							esperaBoton = StartCoroutine(CorutinaFocusUI());
						}
						StartCoroutine(CorrutinaAccion(boton));
						if (Config.modoDeJuego == Config.ModosDeJuego.menu)
						{
							Config.zurdo = !manoDerecha;
						}
					}
					else
					{
						boton.SetFoco(foco: true);
					}
				}
				else if ((bool)boton)
				{
					boton.SetFoco(foco: false);
				}
			}
			else
			{
				lineRenderer.SetPosition(1, new Vector3(0f, 0f, 3f));
			}
			return;
		}
		rayo = new Ray(base.transform.position, base.transform.forward * distanciaRayo);
		if (Physics.Raycast(rayo, out hit, distanciaRayo, LayerMask.GetMask("UI")))
		{
			lineRenderer.SetPosition(1, new Vector3(0f, 0f, hit.distance / 4f));
			if (hit.transform.CompareTag("Boton"))
			{
				BotonMenu component2 = hit.transform.GetComponent<BotonMenu>();
				if (!boton || boton != component2)
				{
					boton = component2;
					boton.SetFoco(foco: true);
					ultimoBoton = boton;
				}
				if (trigger > 0.5f && !botonApretado && trigger > 0.5f)
				{
					tiempoEspera = 0.3f;
					botonApretado = true;
					lineRenderer.enabled = false;
					if (esperaBoton == null)
					{
						esperaBoton = StartCoroutine(CorutinaFocusUI());
					}
					StartCoroutine(CorrutinaAccion(boton));
				}
			}
			else if ((bool)ultimoBoton)
			{
				ultimoBoton.SetFoco(foco: false);
				ultimoBoton = null;
				boton = null;
			}
		}
		else
		{
			if ((bool)ultimoBoton)
			{
				ultimoBoton.SetFoco(foco: false);
				ultimoBoton = null;
				boton = null;
			}
			lineRenderer.SetPosition(1, new Vector3(0f, 0f, 3f));
		}
	}

	private IEnumerator CorutinaFocusUI()
	{
		yield return new WaitForSeconds(tiempoEspera);
		while (LoadingCamera.instance.estadoActual != 0)
		{
			yield return null;
		}
		lineRenderer.enabled = true;
		botonApretado = false;
		esperaBoton = null;
	}

	private IEnumerator CorrutinaAccion(BotonMenu boton)
	{
		boton.SetFoco(foco: true);
		boton.AccionBoton();
		yield return esperaRayoIA;
		boton.SetFoco(foco: false);
	}
}
public class ManosRoomScale : MonoBehaviour
{
	public ControladorMano controladorManoHomonima;

	public AnimManos animManoRS;

	public GameObject manoModel;

	private void Start()
	{
		StartCoroutine(EsperarAEncender());
		animManoRS.transform.parent.gameObject.SetActive(value: false);
	}

	private IEnumerator EsperarAEncender()
	{
		yield return new WaitForSeconds(2f);
		if (Config.tiene2Sensores || (Config.zurdo && controladorManoHomonima.mano == ControladorMano.Mano.Izquierda) || (!Config.zurdo && controladorManoHomonima.mano == ControladorMano.Mano.Derecha))
		{
			animManoRS.transform.parent.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		base.transform.localPosition = ((controladorManoHomonima.mano == ControladorMano.Mano.Derecha) ? InputsController.instance.posicionSensorR : InputsController.instance.posicionSensorL);
		base.transform.localEulerAngles = ((controladorManoHomonima.mano == ControladorMano.Mano.Derecha) ? InputsController.instance.rotacionSensorR : InputsController.instance.rotacionSensorL);
	}

	private void OnTriggerStay(Collider other)
	{
		bool flag = controladorManoHomonima.GetValorTrigger() > 0.8f || controladorManoHomonima.GetValorGrip() > 0.8f;
		if (!(other.gameObject.transform.CompareTag(GameManager.instance.tagPistola) && flag) || !(GameManager.instance.player.tiempoDesdeQueHeSubidoHastaQuePuedoBajar + 2f < Time.time))
		{
			return;
		}
		if (Config.tipoDeControl == Config.TipoControl.DosManos)
		{
			if ((bool)other.transform.parent.GetComponent<Weapon>() && controladorManoHomonima.mano == other.transform.parent.gameObject.GetComponent<Weapon>().miMano.mano && other.transform.parent.gameObject == controladorManoHomonima.arma)
			{
				if (controladorManoHomonima.mano == ControladorMano.Mano.Derecha)
				{
					GameManager.instance.player.pistolaRoomScaleFakeD.SetActive(value: true);
				}
				else
				{
					GameManager.instance.player.pistolaRoomScaleFakeI.SetActive(value: true);
				}
				controladorManoHomonima.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.PistolaEnMano);
				controladorManoHomonima.Grab(other.transform.parent.gameObject, inicio: true);
				if (controladorManoHomonima.GetValorGrip() > 0.8f)
				{
					controladorManoHomonima.cogidaConElGrip = true;
				}
			}
			return;
		}
		Rifle component = other.transform.parent.GetComponent<Rifle>();
		if ((bool)component)
		{
			if (controladorManoHomonima.mano == ControladorMano.Mano.Derecha && Config.zurdo)
			{
				Config.zurdo = false;
				component.miMano = controladorManoHomonima;
				component.controladorManoSecundariaRifle = controladorManoHomonima.controladorManoSecundariaRifle;
				controladorManoHomonima.enabled = true;
				controladorManoHomonima.controladorManoSecundariaRifle.enabled = false;
				controladorManoHomonima.otherHand.enabled = false;
				controladorManoHomonima.otherHand.controladorManoSecundariaRifle.enabled = true;
			}
			else if (controladorManoHomonima.mano == ControladorMano.Mano.Izquierda && !Config.zurdo)
			{
				Config.zurdo = true;
				component.miMano = controladorManoHomonima;
				component.controladorManoSecundariaRifle = controladorManoHomonima.controladorManoSecundariaRifle;
				controladorManoHomonima.enabled = true;
				controladorManoHomonima.controladorManoSecundariaRifle.enabled = false;
				controladorManoHomonima.otherHand.enabled = false;
				controladorManoHomonima.otherHand.controladorManoSecundariaRifle.enabled = true;
			}
			GameManager.instance.player.rifleRommScaleFakeD.SetActive(!Config.zurdo);
			GameManager.instance.player.rifleRommScaleFakeI.SetActive(Config.zurdo);
			controladorManoHomonima.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.PistolaEnMano);
			controladorManoHomonima.Grab(other.transform.parent.gameObject, inicio: true);
			if (controladorManoHomonima.GetValorGrip() > 0.8f)
			{
				controladorManoHomonima.cogidaConElGrip = true;
			}
		}
	}
}
public class Mina : MonoBehaviour
{
	public int nivel = 3;

	public float radius = 1f;

	public float fuerza = 1f;

	public AudioSource audioS;

	public Rigidbody rb;

	private AudioClip audioExplosion;

	public GameObject particulasDestruccion;

	public CambiarMateriales cambiarMateriales;

	[HideInInspector]
	public bool generadaPorBoss;

	private float posStartY;

	private float cont;

	private float tiempoEntreColGanchos;

	private bool explotando;

	private void OnEnable()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			cambiarMateriales.Init();
			base.transform.localScale = GetEscala();
			radius = GetRadius();
			if (!generadaPorBoss)
			{
				GetComponent<EfectoDesaparecer>().Aparecer();
			}
		}
	}

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		if (PhotonNetwork.IsMasterClient)
		{
			posStartY = base.transform.position.y;
		}
	}

	public Vector3 GetEscala()
	{
		int num = ((Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo) ? 4 : 2);
		return nivel switch
		{
			1 => new Vector3(0.175f, 0.175f, 0.175f) * num, 
			2 => new Vector3(0.35f, 0.35f, 0.35f) * num, 
			3 => new Vector3(0.7f, 0.7f, 0.7f) * num, 
			4 => new Vector3(1.4f, 1.4f, 1.4f) * num, 
			5 => new Vector3(2.8f, 2.8f, 2.8f) * num, 
			6 => new Vector3(5.6f, 5.6f, 5.6f) * num, 
			_ => new Vector3(2.8f, 2.8f, 2.8f) * num, 
		};
	}

	public float GetRadius()
	{
		return nivel switch
		{
			1 => 0.75f, 
			2 => 1.5f, 
			3 => 2.25f, 
			4 => 3.75f, 
			5 => 7f, 
			6 => 15f, 
			_ => 1.5f, 
		};
	}

	private void Update()
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			return;
		}
		if (rb.velocity.magnitude > 0f)
		{
			rb.velocity *= 0.99f;
			posStartY = base.transform.position.y;
			cont = 0f;
			if (rb.velocity.magnitude < 0.05f)
			{
				rb.velocity = Vector3.zero;
			}
		}
		else
		{
			Vector3 position = base.transform.position;
			position.y = posStartY + Mathf.Sin(cont) * 0.05f;
			cont += Time.deltaTime;
			base.transform.position = position;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			bool flag = false;
			if (collision.gameObject.CompareTag(GameManager.instance.tagPistola))
			{
				flag = true;
			}
			if (flag)
			{
				PartidaSync.instance.MasterHeDadoAUnaMina(GetComponent<PhotonView>().ViewID, flag, collision.transform.position.x, collision.transform.position.y, collision.transform.position.z);
			}
			return;
		}
		int num = 100;
		if (collision.gameObject.CompareTag(GameManager.instance.tagPistola) || collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			if (tiempoEntreColGanchos + 1f > Time.time)
			{
				return;
			}
			tiempoEntreColGanchos = Time.time;
			num = 300;
			audioS.Play();
			Weapon component = collision.transform.root.GetComponent<Weapon>();
			if ((bool)component)
			{
				if ((bool)component.miMano && component.miMano.estadoDeLaMano != ControladorMano.EstadoDeLaMano.GanchoEnMano)
				{
					component.SaltarAPlayer();
					component.heDestruidoEsferaAlSerLanzado = true;
				}
			}
			else
			{
				GanchoRifle component2 = collision.transform.root.GetComponent<GanchoRifle>();
				if ((bool)component2 && component2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					component2.RebotarGancho();
					component2.heDestruidoEsferaAlSerLanzado = true;
				}
			}
		}
		Colision(collision.transform, num);
	}

	public void Colision(Transform tCollision, float fuerza)
	{
		if (PhotonNetwork.IsMasterClient)
		{
			rb.AddForce((base.transform.position - tCollision.position).normalized * fuerza, ForceMode.Impulse);
		}
	}

	public void Colision(float x, float y, float z, float fuerza)
	{
		if (PhotonNetwork.IsMasterClient)
		{
			rb.AddForce((base.transform.position - new Vector3(x, y, z)).normalized * fuerza, ForceMode.Impulse);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			bool flag = false;
			bool flag2 = false;
			if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
			{
				flag = true;
			}
			else if (other.gameObject.layer == GameManager.instance.layerBala || other.gameObject.layer == GameManager.instance.layerCadenas)
			{
				flag2 = true;
			}
			if (flag || flag2)
			{
				PartidaSync.instance.MasterHeDadoAUnaMina(GetComponent<PhotonView>().ViewID, flag, other.transform.position.x, other.transform.position.y, other.transform.position.z);
			}
		}
		else if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger)
		{
			Arma component = other.transform.parent.GetComponent<Arma>();
			if (!component && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
			{
				component = other.transform.parent.parent.parent.GetComponent<Arma>();
			}
			GanchoRifle ganchoRifle = null;
			if (!component)
			{
				ganchoRifle = other.transform.parent.GetComponent<GanchoRifle>();
				if ((bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
				{
					ganchoRifle = other.transform.parent.parent.parent.GetComponent<GanchoRifle>();
				}
			}
			if ((bool)component || (bool)ganchoRifle)
			{
				if (!ganchoRifle && (((bool)component.weaponScript && component.weaponScript.miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano) || ((bool)component.rifleScript && component.rifleScript.GetEstadoArma() != Rifle.EstadoArma.GanchoD && component.rifleScript.GetEstadoArma() != Rifle.EstadoArma.GanchoI)) && !GameManager.instance.player.muerto)
				{
					PhotonView component2 = base.gameObject.GetComponent<PhotonView>();
					PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, component2 ? component2.ViewID : (-1));
					GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, component.miMano.mano == ControladorMano.Mano.Derecha);
				}
				return;
			}
			SyncJugadores component3 = other.transform.root.GetComponent<SyncJugadores>();
			if (!component3)
			{
				return;
			}
			ControladorMano.EstadoDeLaMano estadoDeLaMano = component3.GanchoPuedeDestruirEsfera(other.transform.parent);
			if (estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano)
			{
				int num = -1;
				foreach (int key in PartidaSync.instance.jugadores.Keys)
				{
					if (PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer == component3.GetComponent<PhotonView>().ViewID)
					{
						num = key;
						break;
					}
				}
				if (num != -1)
				{
					PhotonView component4 = base.gameObject.GetComponent<PhotonView>();
					PartidaSync.instance.ClienteMuerete(num, component4 ? component4.ViewID : (-1));
				}
			}
			else
			{
				_ = 2;
			}
		}
		else
		{
			if (other.gameObject.layer != GameManager.instance.layerBala && other.gameObject.layer != GameManager.instance.layerBalasEsfera && other.gameObject.layer != GameManager.instance.layerCadenas)
			{
				return;
			}
			if (other.transform.CompareTag(GameManager.instance.tagBala))
			{
				Bala component5 = other.transform.GetComponent<Bala>();
				if (!component5)
				{
					other.transform.GetComponent<SyncBala>().TocoObjetoBonus();
				}
				else
				{
					component5.TocaObjetoBonus();
					component5.EfectoDesaparecer(1);
				}
			}
			Explosion();
		}
	}

	public void Explosion()
	{
		if (explotando)
		{
			return;
		}
		explotando = true;
		if (PhotonNetwork.IsMasterClient)
		{
			GetComponent<SyncMina>().Exploto();
		}
		Collider[] array = Physics.OverlapSphere(base.transform.position, radius);
		particulasDestruccion.SetActive(value: true);
		Collider component = GetComponent<SphereCollider>();
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			if (collider == component)
			{
				continue;
			}
			Rigidbody component2 = collider.GetComponent<Rigidbody>();
			EsferaScript component3 = collider.GetComponent<EsferaScript>();
			Mina mina = null;
			BloqueRompible bloqueRompible = null;
			if (component3 == null)
			{
				mina = collider.GetComponent<Mina>();
			}
			if (component3 == null && mina == null)
			{
				bloqueRompible = collider.GetComponent<BloqueRompible>();
			}
			if ((bool)mina && Vector3.Distance(mina.transform.position, base.transform.position) < GetRadius() / 2f)
			{
				mina.Explosion();
			}
			else if ((bool)bloqueRompible)
			{
				if (!bloqueRompible.isEscudo && Vector3.Distance(bloqueRompible.transform.position, base.transform.position) < GetRadius())
				{
					bloqueRompible.Romper();
				}
				else if (component2 != null)
				{
					component2.AddExplosionForce(fuerza * 2f * (float)nivel, base.transform.position, radius, 1f, ForceMode.VelocityChange);
				}
			}
			if (component3 != null)
			{
				if (component3.GetTipoEscudo() == Bola.TipoEscudo.mina)
				{
					component3.DestruirEscudo();
				}
				Vector3 vector = component3.transform.position - base.transform.position;
				float magnitude = vector.magnitude;
				Vector3 newDir = vector / magnitude;
				component3.CambiarDireccion(newDir, magnitude);
			}
		}
		if ((bool)GameManager.instance.bossNivel && Vector3.Distance(base.transform.position, GameManager.instance.bossNivel.transform.position) < radius + 1.5f + GameManager.instance.bossNivel.transform.localScale.x)
		{
			GameManager.instance.bossNivel.GolpearBoss(5);
		}
		StartCoroutine(Destruir());
		GetComponent<SphereCollider>().enabled = false;
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}

	public void ExplosionFake()
	{
		if (!explotando)
		{
			explotando = true;
			particulasDestruccion.SetActive(value: true);
			GetComponent<SphereCollider>().enabled = false;
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}

	private IEnumerator Destruir()
	{
		yield return new WaitForSeconds(2f);
		PhotonNetwork.Destroy(base.gameObject);
	}
}
public class ControladorMono : MonoBehaviour
{
	public Transform manoDerecha;

	public Transform manoIzquierda;

	public Transform cabeza;

	public Transform controladorManoDerecha;

	public Transform controladorManoIzquierda;

	public Transform controladorCabeza;

	private Quaternion rotacionManoDInicial;

	private Quaternion rotacionManoIInicial;

	private Vector3 posicionManoDInicial;

	private Vector3 posicionManoIInicial;

	private GameObject copiaCabeza;

	private GameObject copiaManoD;

	private GameObject copiaManoI;

	private IEnumerator Start()
	{
		GameManager.instance.neoGigante = base.transform.parent.GetChild(1).GetComponent<SkinnedMeshRenderer>();
		while (!GameManager.instance.player)
		{
			yield return new WaitForSeconds(0.1f);
		}
		cabeza = GameManager.instance.player.cabeza.transform;
		if ((bool)GameManager.instance.player.controladorManoDerecha && GameManager.instance.player.controladorManoDerecha.enabled)
		{
			manoDerecha = GameManager.instance.player.controladorManoDerecha.transform;
		}
		if ((bool)GameManager.instance.player.controladorManoIzquierda && GameManager.instance.player.controladorManoIzquierda.enabled)
		{
			manoIzquierda = GameManager.instance.player.controladorManoIzquierda.transform;
		}
		posicionManoDInicial = cabeza.position;
		posicionManoIInicial = cabeza.position;
		rotacionManoDInicial = Quaternion.Euler(-81f, 92f, 12f);
		rotacionManoIInicial = Quaternion.Euler(100f, 40f, -67f);
		copiaCabeza = new GameObject();
		copiaManoD = new GameObject();
		copiaManoI = new GameObject();
		copiaCabeza.transform.SetParent(null);
		copiaManoD.transform.SetParent(null);
		copiaManoI.transform.SetParent(null);
	}

	private void Update()
	{
		if ((bool)cabeza)
		{
			controladorCabeza.localEulerAngles = new Vector3(0f, cabeza.transform.localEulerAngles.z, 0f - cabeza.transform.localEulerAngles.x);
			copiaCabeza.transform.SetPositionAndRotation(cabeza.transform.position, cabeza.transform.rotation);
			if ((bool)manoDerecha)
			{
				copiaManoD.transform.SetPositionAndRotation(manoDerecha.transform.position, manoDerecha.transform.rotation);
			}
			if ((bool)manoIzquierda)
			{
				copiaManoI.transform.SetPositionAndRotation(manoIzquierda.transform.position, manoIzquierda.transform.rotation);
			}
			copiaCabeza.transform.localEulerAngles -= new Vector3(0f, 0f - cabeza.transform.localEulerAngles.y, 0f);
			float num = 11f;
			float num2 = -15f;
			if ((bool)manoDerecha)
			{
				controladorManoDerecha.localPosition = posicionManoDInicial + new Vector3(-1f, num2 + 1f + copiaManoD.transform.localPosition.y * num, 6f);
				controladorManoDerecha.localRotation = rotacionManoDInicial;
			}
			if ((bool)manoIzquierda)
			{
				controladorManoIzquierda.localPosition = posicionManoIInicial + new Vector3(-3f, num2 + 1f + copiaManoI.transform.localPosition.y * num, 4f);
				controladorManoIzquierda.localRotation = rotacionManoIInicial;
			}
		}
	}
}
public class ObjetosDelNivel : MonoBehaviour
{
	private BolaDummy[] esferasSolo;

	private BolaDummy[] esferasOnline;

	public GameObject esferas1Player;

	public GameObject esferas2Player;

	public GameObject torretasGo;

	private TorretaDummy[] torretas;

	public GameObject bloquesRompiblesGo;

	private BloqueRompibleDummy[] bloquesRompibles;

	public GameObject powerupsGo;

	private PowerupDummy[] powerups;

	private BossDummy[] boss;

	public float tiempoDeSalidaDePared = 20f;

	private void Awake()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (esferasOnline == null || esferasOnline.Length == 0)
			{
				esferasOnline = esferas2Player.transform.GetComponentsInChildren<BolaDummy>();
			}
			esferas2Player.SetActive(value: true);
			UnityEngine.Object.Destroy(esferas1Player);
		}
		else
		{
			if (esferasSolo == null || esferasSolo.Length == 0)
			{
				esferasSolo = esferas1Player.transform.GetComponentsInChildren<BolaDummy>();
			}
			esferas1Player.SetActive(value: true);
			UnityEngine.Object.Destroy(esferas2Player);
		}
		if ((bool)torretasGo && (torretas == null || torretas.Length == 0))
		{
			torretas = torretasGo.transform.GetComponentsInChildren<TorretaDummy>();
		}
		if ((bool)bloquesRompiblesGo && (bloquesRompibles == null || bloquesRompibles.Length == 0))
		{
			bloquesRompibles = bloquesRompiblesGo.transform.GetComponentsInChildren<BloqueRompibleDummy>();
		}
		if ((bool)powerupsGo && (powerups == null || powerups.Length == 0))
		{
			powerups = powerupsGo.transform.GetComponentsInChildren<PowerupDummy>();
		}
	}

	public BolaDummy[] GetEsferasNivel()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (esferasOnline == null || esferasOnline.Length == 0)
			{
				esferasOnline = esferas2Player.transform.GetComponentsInChildren<BolaDummy>();
			}
			return esferasOnline;
		}
		if (esferasSolo == null || esferasSolo.Length == 0)
		{
			esferasSolo = esferas1Player.transform.GetComponentsInChildren<BolaDummy>();
		}
		return esferasSolo;
	}

	public TorretaDummy[] GetTorretasNivel()
	{
		if ((bool)torretasGo && (torretas == null || torretas.Length == 0))
		{
			torretas = torretasGo.transform.GetComponentsInChildren<TorretaDummy>();
		}
		return torretas;
	}

	public BloqueRompibleDummy[] GetBloqueRompiblesNivel()
	{
		if ((bool)bloquesRompiblesGo && (bloquesRompibles == null || bloquesRompibles.Length == 0))
		{
			bloquesRompibles = bloquesRompiblesGo.transform.GetComponentsInChildren<BloqueRompibleDummy>();
		}
		return bloquesRompibles;
	}

	public PowerupDummy[] GetPowerupsNivel()
	{
		if ((bool)powerupsGo && (powerups == null || powerups.Length == 0))
		{
			powerups = powerupsGo.transform.GetComponentsInChildren<PowerupDummy>();
		}
		return powerups;
	}

	public BossDummy[] GetBossNivel()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (boss == null || boss.Length == 0)
			{
				boss = esferas2Player.transform.GetComponentsInChildren<BossDummy>();
			}
			return boss;
		}
		if (boss == null || boss.Length == 0)
		{
			boss = esferas1Player.transform.GetComponentsInChildren<BossDummy>();
		}
		return boss;
	}

	public void Destruirme()
	{
		for (int i = 0; i < PoolObjetos.instance.esferas.Count; i++)
		{
			if (PoolObjetos.instance.esferas[i].transform.parent != PoolObjetos.instance.transform)
			{
				PoolObjetos.instance.esferas[i].transform.SetParent(PoolObjetos.instance.transform);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
[RequireComponent(typeof(PhotonView))]
public class SyncBala : MonoBehaviourPun, IPunObservable
{
	public MonoBehaviour[] localScripts;

	public GameObject[] localObjectDes;

	public GameObject[] localObjectAct;

	public Component[] componentsToDestroy;

	private Vector3 latestPos;

	private Quaternion latestRot;

	public int equipo = 1;

	private TrailRenderer trail;

	private GameObject meshObj;

	private float tiempoSinRespuesta;

	private Bala bala;

	private BalaEsfera balaEsfera;

	private int seActiva;

	public int idObjPhotonPlayer;

	private Collider collider;

	public Vector3 posicionDeinstanciamiento = Vector3.zero;

	private AudioSource audioSourceBala;

	private AudioClip audioClipBala;

	public AudioClip audioClipBalaReboteMetalico;

	[HideInInspector]
	public int numUsos = 1;

	private float mult = 15f;

	private Coroutine corVolverAPonerSonido;

	private const string RPC_TocoObjetoBonus = "TocoObjetoBonusPUN";

	private void Start()
	{
		if (!bala)
		{
			bala = GetComponent<Bala>();
		}
		if (!bala && !balaEsfera)
		{
			balaEsfera = GetComponent<BalaEsfera>();
		}
		if (base.photonView.IsMine)
		{
			for (int i = 0; i < localObjectAct.Length; i++)
			{
				UnityEngine.Object.Destroy(localObjectAct[i]);
				if ((bool)bala)
				{
					equipo = bala.equipo;
				}
				else if ((bool)balaEsfera)
				{
					equipo = balaEsfera.equipo;
				}
			}
		}
		else
		{
			if ((bool)balaEsfera)
			{
				UnityEngine.Object.Destroy(balaEsfera);
			}
			else if ((bool)bala)
			{
				UnityEngine.Object.Destroy(bala);
			}
			for (int j = 0; j < localObjectDes.Length; j++)
			{
				UnityEngine.Object.Destroy(localObjectDes[j]);
			}
			for (int k = 0; k < localObjectAct.Length; k++)
			{
				localObjectAct[k].SetActive(value: true);
			}
			for (int l = 0; l < componentsToDestroy.Length; l++)
			{
				UnityEngine.Object.Destroy(componentsToDestroy[l]);
			}
			trail = GetComponent<TrailRenderer>();
			if ((bool)trail)
			{
				trail.enabled = false;
			}
			Transform child = base.transform.GetChild(0);
			if ((bool)child)
			{
				meshObj = child.gameObject;
			}
			if ((bool)meshObj)
			{
				meshObj.SetActive(value: false);
			}
			collider = GetComponent<Collider>();
			collider.enabled = false;
			base.gameObject.SetActive(value: true);
		}
		posicionDeinstanciamiento = base.transform.position;
		audioSourceBala = GetComponent<AudioSource>();
		audioClipBala = audioSourceBala.clip;
	}

	private void Update()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if (!base.photonView || base.photonView.IsMine)
		{
			return;
		}
		if (seActiva == 1)
		{
			collider.enabled = true;
			base.transform.position = latestPos;
			base.transform.rotation = latestRot;
			if ((bool)trail)
			{
				trail.enabled = true;
			}
			if ((bool)meshObj)
			{
				meshObj.SetActive(value: true);
			}
			posicionDeinstanciamiento = base.transform.position;
			seActiva = 2;
		}
		if (seActiva == 2 && tiempoSinRespuesta + 1f < Time.time)
		{
			collider.enabled = false;
			base.transform.position = Vector3.one * 500f;
			if ((bool)trail)
			{
				trail.enabled = false;
			}
			if ((bool)meshObj)
			{
				meshObj.SetActive(value: false);
			}
			seActiva = 0;
		}
		else if (seActiva == 2)
		{
			base.transform.LookAt(latestPos);
			Vector3 vector = (latestPos - base.transform.position).normalized;
			if ((latestPos - base.transform.position).magnitude < vector.magnitude)
			{
				vector = latestPos - base.transform.position;
			}
			base.transform.position += vector * Time.deltaTime * mult;
			if (Vector3.Distance(base.transform.position, latestPos) >= 10f)
			{
				base.transform.position = latestPos;
			}
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, latestRot, Time.deltaTime * 1f);
		}
	}

	private void OnEnable()
	{
		seActiva = 0;
		posicionDeinstanciamiento = base.transform.position;
	}

	private void OnDisable()
	{
		Disable();
	}

	public void Disable()
	{
		if (corVolverAPonerSonido != null)
		{
			StopCoroutine(corVolverAPonerSonido);
		}
		numUsos = 1;
	}

	public void ChangeTrail(bool laser)
	{
		if (!bala)
		{
			bala = GetComponent<Bala>();
		}
		bala.ChangeTrail(laser);
	}

	public void PonerAudioRebote()
	{
		audioSourceBala.clip = audioClipBalaReboteMetalico;
		audioSourceBala.Play();
		if (corVolverAPonerSonido != null)
		{
			StopCoroutine(corVolverAPonerSonido);
		}
		corVolverAPonerSonido = StartCoroutine(VolverAPonerClip());
	}

	private IEnumerator VolverAPonerClip()
	{
		yield return null;
		while (audioSourceBala.isPlaying)
		{
			yield return null;
		}
		audioSourceBala.clip = audioClipBala;
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			if ((bool)bala || (bool)balaEsfera)
			{
				stream.SendNext(base.transform.position);
				stream.SendNext(base.transform.rotation);
				if ((bool)bala)
				{
					stream.SendNext(bala.equipo);
				}
				else
				{
					stream.SendNext(balaEsfera.equipo);
				}
			}
			return;
		}
		if (seActiva == 0)
		{
			seActiva = 1;
			posicionDeinstanciamiento = base.transform.position;
		}
		latestPos = (Vector3)stream.ReceiveNext();
		latestRot = (Quaternion)stream.ReceiveNext();
		equipo = (int)stream.ReceiveNext();
		tiempoSinRespuesta = Time.time;
	}

	public void TocoObjetoBonus()
	{
		int num = -1;
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer == idObjPhotonPlayer)
			{
				num = PartidaSync.instance.jugadores[key].idJugador;
				break;
			}
		}
		if (num != -1)
		{
			if (!base.photonView)
			{
				GetComponent<PhotonView>();
			}
			if ((bool)base.photonView)
			{
				base.photonView.RPC("TocoObjetoBonusPUN", PhotonNetwork.CurrentRoom.GetPlayer(num));
			}
		}
	}

	[PunRPC]
	private void TocoObjetoBonusPUN(int accion)
	{
		bala.TocaObjetoBonus();
		bala.EfectoDesaparecer(1);
	}
}
public class SyncBloqueRompible : MonoBehaviourPun, IPunObservable
{
	public CambiarMateriales cambiarMateriales;

	private const string RPC_RomperElBloque = "RomperElBloquePUN";

	private void OnEnable()
	{
		cambiarMateriales.Init();
		GameManager.instance.bloquesEncendidos.Add(base.gameObject);
		GetComponent<EfectoDesaparecer>().Aparecer();
	}

	private void OnDisable()
	{
		GameManager.instance.bloquesEncendidos.Remove(base.gameObject);
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}

	public void RomperElBloque()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("RomperElBloquePUN", RpcTarget.Others);
		}
	}

	[PunRPC]
	private void RomperElBloquePUN()
	{
		BloqueRompible component = GetComponent<BloqueRompible>();
		if ((bool)component)
		{
			component.Romper(1000f, 1000f, 1000f, ordenPorRed: true);
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class SyncBoss : MonoBehaviourPun, IPunObservable
{
	private BossBase boss;

	private int escudoAntiguo = -1;

	private int tipoEscudo = -1;

	private int oldNumeroBalasEscudo = -1;

	public Transform parpado;

	public Transform bbos;

	private BossEscudoBala bossEscudoBala;

	private BossLaser bossLaser;

	private BossOjoDebil bossOjoDebil;

	private BossDragonDebil bossDragonDebil;

	private PhotonView pv;

	private int auxiliar = -1;

	private int oldAuxiliar = -1;

	private Vector3 rotacionDeseadaBoss = Vector3.zero;

	private const string RPC_MasterGolpeoABoss = "MasterGolpeoABossPUN";

	private const string RPC_SateliteDestruido = "SateliteDestruidoPUN";

	private const string RPC_BossDerrotado = "BossDerrotadoPUN";

	private const string RPC_MasterGanchoEnganchado = "MasterGanchoEnganchadoPUN";

	private void Start()
	{
		pv = GetComponent<PhotonView>();
		boss = GetComponent<BossBase>();
		bossEscudoBala = GetComponent<BossEscudoBala>();
		bossLaser = GetComponent<BossLaser>();
		bossOjoDebil = GetComponent<BossOjoDebil>();
		bossDragonDebil = GetComponent<BossDragonDebil>();
		if ((bool)parpado && !pv.IsMine)
		{
			parpado.gameObject.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (!boss || !boss.photonView || boss.photonView.IsMine)
		{
			return;
		}
		if (escudoAntiguo != tipoEscudo)
		{
			if (tipoEscudo > 0)
			{
				if (tipoEscudo == 1)
				{
					boss.PonerEscudo();
				}
				else
				{
					boss.PonerEscudoNegro();
					QuitarGanchos();
				}
				escudoAntiguo = tipoEscudo;
			}
			else
			{
				boss.QuitarEscudo();
				QuitarGanchos();
				escudoAntiguo = tipoEscudo;
			}
		}
		if (oldNumeroBalasEscudo != boss.numeroBalasEscudo)
		{
			if ((bool)bossEscudoBala)
			{
				if (boss.numeroBalasEscudo <= 3)
				{
					bossEscudoBala.SetTexturaEscudoBalas();
				}
				else
				{
					boss.QuitarEscudo();
				}
			}
			oldNumeroBalasEscudo = boss.numeroBalasEscudo;
		}
		if (auxiliar != oldAuxiliar)
		{
			if ((bool)bossLaser)
			{
				if (auxiliar == 0)
				{
					bossLaser.EnableLaserOnline(enabled: false);
				}
				else if (auxiliar == 1)
				{
					bossLaser.EnableLaserOnline(enabled: true);
				}
			}
			else if ((bool)bossOjoDebil)
			{
				if (auxiliar == 0)
				{
					bossOjoDebil.CambiarMaterialOnline(enabled: false);
				}
				else if (auxiliar == 1)
				{
					bossOjoDebil.CambiarMaterialOnline(enabled: true);
				}
			}
			else if ((bool)bossDragonDebil)
			{
				if (auxiliar == 0)
				{
					bossDragonDebil.CambiarMaterialOnline(enabled: false);
				}
				else if (auxiliar == 1)
				{
					bossDragonDebil.CambiarMaterialOnline(enabled: true);
				}
			}
			oldAuxiliar = auxiliar;
		}
		if ((bool)bbos)
		{
			bbos.localRotation = Quaternion.Lerp(bbos.localRotation, Quaternion.Euler(rotacionDeseadaBoss), Time.deltaTime * 2f);
		}
	}

	private void QuitarGanchos()
	{
		if ((bool)GameManager.instance.player.weaponDer && GameManager.instance.player.weaponDer.armaAncladaABloque)
		{
			QuitarGancho(GameManager.instance.player.weaponDer, null);
		}
		if ((bool)GameManager.instance.player.weaponIzq && GameManager.instance.player.weaponIzq.armaAncladaABloque)
		{
			QuitarGancho(GameManager.instance.player.weaponIzq, null);
		}
		if ((bool)GameManager.instance.player.rifle && GameManager.instance.player.rifle.ganchoD.armaAncladaABloque)
		{
			QuitarGancho(null, GameManager.instance.player.rifle.ganchoD);
		}
		if ((bool)GameManager.instance.player.rifle && GameManager.instance.player.rifle.ganchoI.armaAncladaABloque)
		{
			QuitarGancho(null, GameManager.instance.player.rifle.ganchoI);
		}
	}

	private void QuitarGancho(Weapon arma, GanchoRifle gancho)
	{
		Rigidbody rigidbody = (arma ? arma.GetComponent<Rigidbody>() : gancho.GetComponent<Rigidbody>());
		if (!rigidbody.useGravity)
		{
			rigidbody.useGravity = true;
		}
		if (rigidbody.isKinematic)
		{
			rigidbody.isKinematic = false;
		}
		if ((bool)arma)
		{
			arma.bloque = null;
			arma.armaEstaEnBloque = false;
		}
		else
		{
			gancho.bloque = null;
			gancho.armaEstaEnBloque = false;
		}
		rigidbody.useGravity = false;
		rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
		if ((bool)arma)
		{
			arma.armaAncladaABloque = false;
			arma.otraPistola.armaEstaEnBloque = false;
		}
		else
		{
			gancho.armaAncladaABloque = false;
			gancho.otroGancho.armaEstaEnBloque = false;
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			if ((bool)boss)
			{
				stream.SendNext(boss.TieneEscudo());
				stream.SendNext(boss.escudoDestruido);
				stream.SendNext(boss.numeroBalasEscudo);
				stream.SendNext((int)boss.faseActual);
				stream.SendNext((int)boss.tipoEscudo);
				if ((bool)parpado)
				{
					stream.SendNext(parpado.localEulerAngles);
				}
				if ((bool)bbos)
				{
					stream.SendNext(bbos.localEulerAngles);
				}
				stream.SendNext(boss.onlineAuxiliar);
			}
			return;
		}
		tipoEscudo = (int)stream.ReceiveNext();
		bool escudoDestruido = (bool)stream.ReceiveNext();
		if ((bool)boss)
		{
			boss.escudoDestruido = escudoDestruido;
		}
		int numeroBalasEscudo = (int)stream.ReceiveNext();
		if ((bool)boss)
		{
			boss.numeroBalasEscudo = numeroBalasEscudo;
		}
		numeroBalasEscudo = (int)stream.ReceiveNext();
		if ((bool)boss)
		{
			boss.faseActual = (BossBase.FasesBoss)numeroBalasEscudo;
		}
		numeroBalasEscudo = (int)stream.ReceiveNext();
		if ((bool)boss)
		{
			boss.tipoEscudo = (Bola.TipoEscudo)numeroBalasEscudo;
		}
		if ((bool)parpado)
		{
			parpado.localEulerAngles = (Vector3)stream.ReceiveNext();
		}
		if ((bool)bbos)
		{
			rotacionDeseadaBoss = (Vector3)stream.ReceiveNext();
		}
		auxiliar = (int)stream.ReceiveNext();
	}

	public void MasterGolpeoABoss(int arma)
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("MasterGolpeoABossPUN", RpcTarget.MasterClient, arma);
		}
	}

	[PunRPC]
	private void MasterGolpeoABossPUN(int arma)
	{
		GetComponent<BossBase>().GolpearBoss(arma);
	}

	public void SateliteDestruido(int photonviewSatelite)
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("SateliteDestruidoPUN", RpcTarget.Others, photonviewSatelite);
		}
	}

	[PunRPC]
	private void SateliteDestruidoPUN(int photonviewSatelite)
	{
		PhotonView photonView = PhotonView.Find(photonviewSatelite);
		if ((bool)photonView)
		{
			photonView.GetComponent<EfectoDesaparecer>().Desaparecer();
		}
	}

	public void BossDerrotado()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("BossDerrotadoPUN", RpcTarget.Others);
		}
	}

	[PunRPC]
	private void BossDerrotadoPUN()
	{
		GetComponent<BossBase>().Morir();
	}

	public void MasterGanchoEnganchado(bool enganchado)
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("MasterGanchoEnganchadoPUN", RpcTarget.MasterClient, enganchado);
		}
	}

	[PunRPC]
	private void MasterGanchoEnganchadoPUN(bool enganchado)
	{
		GetComponent<BossBase>().SetGanchoEnganchado(enganchado);
	}
}
[RequireComponent(typeof(PhotonView))]
public class SyncEsferaMetralleta : MonoBehaviourPun, IPunObservable
{
	private Vector3 pos = Vector3.one * 1000f;

	private Vector3 rot = Vector3.one * 1000f;

	public Transform objeto;

	private void Update()
	{
		if (!base.photonView.IsMine && !(pos == Vector3.one * 1000f))
		{
			base.transform.position = Vector3.Lerp(base.transform.position, pos, Time.deltaTime * 3f);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.Euler(rot), Time.deltaTime * 3f);
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(objeto.position);
			stream.SendNext(objeto.eulerAngles);
		}
		else
		{
			pos = (Vector3)stream.ReceiveNext();
			rot = (Vector3)stream.ReceiveNext();
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class SyncJugadores : MonoBehaviourPun, IPunObservable
{
	private bool zurdo;

	private bool dosManos;

	private bool dosSensores;

	public MonoBehaviour[] localScripts;

	public GameObject[] localObjectDes;

	public GameObject[] localObjectAct;

	public Transform cabeza;

	public Transform manoD;

	public Transform manoI;

	public Transform cabezaJugOnline;

	public Transform manoDJugOnline;

	public Transform manoIJugOnline;

	private Vector3 latestPosCuerpo;

	private Vector3 latestPosCabeza;

	private Vector3 latestPosManoD;

	private Vector3 latestPosManoI;

	private Vector3 latestPosGanchoD;

	private Vector3 latestPosGanchoI;

	private Vector3 posIniGanchoD;

	private Vector3 posIniGanchoI;

	private Vector3 rotIniGanchoD;

	private Vector3 rotIniGanchoI;

	private Vector3 posIniGanchoRifleD;

	private Vector3 posIniGanchoRifleI;

	private Vector3 rotIniGanchoRifleD;

	private Vector3 rotIniGanchoRifleI;

	private Quaternion latestRotCuerpo;

	private Quaternion latestRotCabeza;

	private Quaternion latestRotManoD;

	private Quaternion latestRotManoI;

	private Quaternion latestRotGanchoD;

	private Quaternion latestRotGanchoI;

	private int miIdJuego = -1;

	private int miIdPhoton = -1;

	private ControladorMano.EstadoDeLaMano estadoManoOnlineDerecha;

	private ControladorMano.EstadoDeLaMano estadoManoOnlineIzquierda;

	private ControladorMano.EstadoDeLaMano anteriorEstadoManoOnlineDerecha;

	private ControladorMano.EstadoDeLaMano anteriorEstadoManoOnlineIzquierda;

	private Rifle.EstadoArmaOnline estadoRifleOnline;

	private Rifle.EstadoArmaOnline anteriorEstadoRifleOnline;

	public Transform pistolaComplejaD;

	public Transform pistolaComplejaI;

	public Transform ganchoRifleD;

	public Transform ganchoRifleI;

	public GameObject pistolaOnlineSimpleD;

	public GameObject pistolaOnlineSimpleI;

	public GameObject pistolaOnlineComplejaD;

	public GameObject pistolaOnlineComplejaI;

	public GameObject pistolaOnlineRifleD;

	public GameObject pistolaOnlineRifleI;

	public GameObject pistolaOnlineComplejaGanchoD;

	public GameObject pistolaOnlineComplejaGanchoI;

	public ControladorCadenaOnline controladorCadenaOnline;

	public SkinnedMeshRenderer meshManoD;

	public SkinnedMeshRenderer meshManoI;

	public SkinnedMeshRenderer meshManoJugOnlineD;

	public SkinnedMeshRenderer meshManoJugOnlineI;

	public Material fantasmalMat;

	private Material materialMano;

	private Material materialCabeza;

	private Material materialPistola;

	private Material materialRifle;

	public int equipo = 1;

	private int Activado;

	private Transform padre;

	public TextMeshProUGUI nombreTxt;

	public Image imgSpeaker;

	public Image micButton;

	public Image speakerButton;

	public Sprite micOn;

	public Sprite micOff;

	public Sprite speakerOn;

	public Sprite speakerOff;

	private MeshRenderer meshPistolaOnlineSimpleD;

	private MeshRenderer meshPistolaOnlineSimpleI;

	private MeshRenderer meshRifleOnlineI;

	private MeshRenderer meshRifleOnlineD;

	private MeshRenderer[] meshesPistolaOnlineComplejaD;

	private MeshRenderer[] meshesPistolaOnlineComplejaI;

	private MeshRenderer[] meshesRifleOnlineComplejaD;

	private MeshRenderer[] meshesRifleOnlineComplejaI;

	[HideInInspector]
	public bool empezar;

	private int idPhotonVoiceView = -1;

	private bool nombreColocado;

	private bool yoMuteado;

	private float velocidadLerpGancho = 7.5f;

	private bool ganchoDActivo;

	private bool ganchoIActivo;

	private AudioSource asVozSpeaker;

	private bool estoyFantasmal;

	private Material neoMat;

	private void Start()
	{
		if (PhotonNetwork.IsMasterClient && base.photonView.IsMine)
		{
			equipo = 1;
		}
		else if ((PhotonNetwork.IsMasterClient && !base.photonView.IsMine) || (!PhotonNetwork.IsMasterClient && base.photonView.IsMine))
		{
			equipo = 2;
		}
		else
		{
			equipo = 1;
		}
		padre = base.transform.parent;
		if ((bool)meshManoJugOnlineD)
		{
			materialMano = meshManoJugOnlineD.material;
		}
		if ((bool)cabezaJugOnline)
		{
			materialCabeza = cabezaJugOnline.GetChild(0).GetComponent<MeshRenderer>().material;
		}
		if ((bool)pistolaOnlineSimpleD)
		{
			meshPistolaOnlineSimpleD = pistolaOnlineSimpleD.GetComponentInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineSimpleI)
		{
			meshPistolaOnlineSimpleI = pistolaOnlineSimpleI.GetComponentInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineRifleD)
		{
			meshRifleOnlineD = pistolaOnlineRifleD.GetComponentInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineRifleI)
		{
			meshRifleOnlineI = pistolaOnlineRifleI.GetComponentInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineComplejaD)
		{
			meshesPistolaOnlineComplejaD = pistolaOnlineComplejaD.GetComponentsInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineComplejaI)
		{
			meshesPistolaOnlineComplejaI = pistolaOnlineComplejaI.GetComponentsInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineComplejaGanchoD)
		{
			meshesRifleOnlineComplejaD = pistolaOnlineComplejaGanchoD.GetComponentsInChildren<MeshRenderer>();
		}
		if ((bool)pistolaOnlineComplejaGanchoI)
		{
			meshesRifleOnlineComplejaI = pistolaOnlineComplejaGanchoI.GetComponentsInChildren<MeshRenderer>();
		}
		if ((bool)meshPistolaOnlineSimpleD)
		{
			materialPistola = meshPistolaOnlineSimpleD.material;
		}
		if ((bool)meshRifleOnlineD)
		{
			materialRifle = meshRifleOnlineD.material;
		}
		if (base.photonView.IsMine)
		{
			for (int i = 0; i < localObjectAct.Length; i++)
			{
				UnityEngine.Object.Destroy(localObjectAct[i]);
			}
		}
		else
		{
			for (int j = 0; j < localScripts.Length; j++)
			{
				UnityEngine.Object.Destroy(localScripts[j]);
			}
			for (int k = 0; k < localObjectDes.Length; k++)
			{
				UnityEngine.Object.Destroy(localObjectDes[k]);
			}
			posIniGanchoD = pistolaOnlineComplejaD.transform.localPosition;
			posIniGanchoI = pistolaOnlineComplejaI.transform.localPosition;
			rotIniGanchoD = pistolaOnlineComplejaD.transform.localEulerAngles;
			rotIniGanchoI = pistolaOnlineComplejaI.transform.localEulerAngles;
			posIniGanchoRifleD = pistolaOnlineComplejaGanchoD.transform.localPosition;
			rotIniGanchoRifleD = pistolaOnlineComplejaGanchoD.transform.localEulerAngles;
			posIniGanchoRifleI = pistolaOnlineComplejaGanchoI.transform.localPosition;
			rotIniGanchoRifleI = pistolaOnlineComplejaGanchoI.transform.localEulerAngles;
			base.transform.position = Vector3.one * 3000f;
			pistolaOnlineComplejaD.GetComponent<AnimTransformPistola>().idPlayer = base.photonView.ViewID;
			pistolaOnlineComplejaI.GetComponent<AnimTransformPistola>().idPlayer = base.photonView.ViewID;
			pistolaOnlineComplejaD.GetComponent<AnimTransformPistola>().syncjugador = this;
			pistolaOnlineComplejaI.GetComponent<AnimTransformPistola>().syncjugador = this;
		}
		yoMuteado = PersistentDataManager.GetInt("YoMuteado") == 1;
		yoMuteado = !yoMuteado;
		MutearMe();
	}

	private void Activar()
	{
		for (int i = 0; i < localObjectAct.Length; i++)
		{
			localObjectAct[i].SetActive(value: true);
		}
	}

	private void Update()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if (!base.photonView || base.photonView.IsMine)
		{
			return;
		}
		if (!nombreColocado)
		{
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer == base.photonView.ViewID)
				{
					nombreTxt.text = PartidaSync.instance.jugadores[key].nombre;
					nombreColocado = true;
					break;
				}
			}
		}
		if (Activado == 1 || Vector3.Distance(base.transform.position, latestPosCuerpo) > 1f)
		{
			base.transform.position = latestPosCuerpo;
			base.transform.rotation = latestRotCuerpo;
			cabezaJugOnline.position = latestPosCabeza;
			cabezaJugOnline.rotation = latestRotCabeza;
			if (dosSensores)
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.position = latestPosManoD;
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.rotation = latestRotManoD;
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.position = latestPosManoI;
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.rotation = latestRotManoI;
				}
			}
			else if (zurdo)
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: false);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.position = latestPosManoI;
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.rotation = latestRotManoI;
				}
			}
			else
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: false);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.position = latestPosManoD;
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.rotation = latestRotManoD;
				}
			}
			if (!dosManos)
			{
				if ((bool)pistolaOnlineComplejaD && (bool)pistolaOnlineComplejaD.transform.parent)
				{
					pistolaOnlineComplejaD.transform.parent.gameObject.SetActive(value: false);
				}
				if ((bool)pistolaOnlineComplejaI && (bool)pistolaOnlineComplejaI.transform.parent)
				{
					pistolaOnlineComplejaI.transform.parent.gameObject.SetActive(value: false);
				}
				if ((bool)pistolaOnlineSimpleD)
				{
					pistolaOnlineSimpleD.transform.parent.gameObject.SetActive(value: false);
				}
				if ((bool)pistolaOnlineSimpleI)
				{
					pistolaOnlineSimpleI.transform.parent.gameObject.SetActive(value: false);
				}
				if ((bool)pistolaOnlineRifleD)
				{
					pistolaOnlineRifleD.SetActive(value: true);
				}
				if ((bool)pistolaOnlineRifleI)
				{
					pistolaOnlineRifleI.SetActive(value: true);
				}
			}
			else
			{
				if ((bool)pistolaOnlineComplejaD && (bool)pistolaOnlineComplejaD.transform.parent)
				{
					pistolaOnlineComplejaD.transform.parent.gameObject.SetActive(value: true);
				}
				if ((bool)pistolaOnlineComplejaI && (bool)pistolaOnlineComplejaI.transform.parent)
				{
					pistolaOnlineComplejaI.transform.parent.gameObject.SetActive(value: true);
				}
				if ((bool)pistolaOnlineSimpleD)
				{
					pistolaOnlineSimpleD.transform.parent.gameObject.SetActive(value: true);
				}
				if ((bool)pistolaOnlineSimpleI)
				{
					pistolaOnlineSimpleI.transform.parent.gameObject.SetActive(value: true);
				}
				if ((bool)pistolaOnlineRifleD)
				{
					pistolaOnlineRifleD.SetActive(value: false);
				}
				if ((bool)pistolaOnlineRifleI)
				{
					pistolaOnlineRifleI.SetActive(value: false);
				}
			}
			CambiarEstadoPistola(estadoManoOnlineDerecha, manoDerecha: true);
			anteriorEstadoManoOnlineDerecha = estadoManoOnlineDerecha;
			CambiarEstadoPistola(estadoManoOnlineDerecha, manoDerecha: false);
			anteriorEstadoManoOnlineIzquierda = estadoManoOnlineIzquierda;
			if (Activado == 1)
			{
				Activar();
			}
			Activado = 2;
		}
		else if (Activado == 2)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, latestPosCuerpo, Time.deltaTime * 5f);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, latestRotCuerpo, Time.deltaTime * 5f);
			cabezaJugOnline.position = Vector3.Lerp(cabezaJugOnline.position, latestPosCabeza, Time.deltaTime * 5f);
			cabezaJugOnline.rotation = Quaternion.Lerp(cabezaJugOnline.rotation, latestRotCabeza, Time.deltaTime * 5f);
			if (dosSensores)
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.position = Vector3.Lerp(manoDJugOnline.position, latestPosManoD, Time.deltaTime * 5f);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.rotation = Quaternion.Lerp(manoDJugOnline.rotation, latestRotManoD, Time.deltaTime * 5f);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.position = Vector3.Lerp(manoIJugOnline.position, latestPosManoI, Time.deltaTime * 5f);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.rotation = Quaternion.Lerp(manoIJugOnline.rotation, latestRotManoI, Time.deltaTime * 5f);
				}
			}
			else if (zurdo)
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: false);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.position = Vector3.Lerp(manoIJugOnline.position, latestPosManoI, Time.deltaTime * 5f);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.rotation = Quaternion.Lerp(manoIJugOnline.rotation, latestRotManoI, Time.deltaTime * 5f);
				}
			}
			else
			{
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.gameObject.SetActive(value: true);
				}
				if ((bool)manoIJugOnline)
				{
					manoIJugOnline.gameObject.SetActive(value: false);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.position = Vector3.Lerp(manoDJugOnline.position, latestPosManoD, Time.deltaTime * 5f);
				}
				if ((bool)manoDJugOnline)
				{
					manoDJugOnline.rotation = Quaternion.Lerp(manoDJugOnline.rotation, latestRotManoD, Time.deltaTime * 5f);
				}
			}
		}
		if (dosManos)
		{
			if (anteriorEstadoManoOnlineDerecha != estadoManoOnlineDerecha)
			{
				CambiarEstadoPistola(estadoManoOnlineDerecha, manoDerecha: true);
				anteriorEstadoManoOnlineDerecha = estadoManoOnlineDerecha;
			}
			if (anteriorEstadoManoOnlineIzquierda != estadoManoOnlineIzquierda)
			{
				CambiarEstadoPistola(estadoManoOnlineIzquierda, manoDerecha: false);
				anteriorEstadoManoOnlineIzquierda = estadoManoOnlineIzquierda;
			}
			if (estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoEnMano || estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoLanzandose || estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar || estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoVolviendo)
			{
				bool fueraDelPadre = true;
				if (estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoEnMano)
				{
					fueraDelPadre = false;
				}
				MoverGancho(manoDerecha: true, latestPosGanchoD, latestRotGanchoD, fueraDelPadre, !ganchoDActivo);
				ganchoDActivo = true;
			}
			else
			{
				ganchoDActivo = false;
			}
			if (estadoManoOnlineIzquierda == ControladorMano.EstadoDeLaMano.GanchoEnMano || estadoManoOnlineIzquierda == ControladorMano.EstadoDeLaMano.GanchoLanzandose || estadoManoOnlineIzquierda == ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar || estadoManoOnlineIzquierda == ControladorMano.EstadoDeLaMano.GanchoVolviendo)
			{
				bool fueraDelPadre2 = true;
				if (estadoManoOnlineDerecha == ControladorMano.EstadoDeLaMano.GanchoEnMano)
				{
					fueraDelPadre2 = false;
				}
				MoverGancho(manoDerecha: false, latestPosGanchoI, latestRotGanchoI, fueraDelPadre2, !ganchoIActivo);
				ganchoIActivo = false;
			}
			else
			{
				ganchoIActivo = false;
			}
		}
		else
		{
			if (anteriorEstadoRifleOnline != estadoRifleOnline)
			{
				CambiarEstadoRifle(estadoRifleOnline);
				anteriorEstadoRifleOnline = estadoRifleOnline;
			}
			MoverGanchoRifle(derecha: true, latestPosGanchoD, latestRotGanchoD, estadoRifleOnline != Rifle.EstadoArmaOnline.GanchoD);
			MoverGanchoRifle(derecha: false, latestPosGanchoI, latestRotGanchoI, estadoRifleOnline != Rifle.EstadoArmaOnline.GanchoI);
		}
		if (base.photonView.IsMine)
		{
			return;
		}
		if (!asVozSpeaker && idPhotonVoiceView != -1)
		{
			asVozSpeaker = PhotonView.Find(idPhotonVoiceView).GetComponent<AudioSource>();
		}
		if ((bool)asVozSpeaker && GameManager.instance.jugadoresMuteados && (asVozSpeaker.volume > 0.5f || asVozSpeaker.enabled))
		{
			asVozSpeaker.volume = 0f;
			asVozSpeaker.enabled = false;
			imgSpeaker.enabled = true;
			imgSpeaker.sprite = speakerOff;
			return;
		}
		if ((bool)asVozSpeaker && !GameManager.instance.jugadoresMuteados && (asVozSpeaker.volume < 0.5f || !asVozSpeaker.enabled))
		{
			asVozSpeaker.volume = 1f;
			asVozSpeaker.enabled = true;
		}
		if ((bool)asVozSpeaker && asVozSpeaker.isPlaying)
		{
			imgSpeaker.enabled = true;
			imgSpeaker.sprite = speakerOn;
		}
		else
		{
			imgSpeaker.enabled = false;
		}
	}

	private void CambiarEstadoPistola(ControladorMano.EstadoDeLaMano estado, bool manoDerecha)
	{
		switch (estado)
		{
		case ControladorMano.EstadoDeLaMano.EstadoInicialSinArma:
			if (manoDerecha)
			{
				pistolaOnlineSimpleD.gameObject.SetActive(value: false);
				pistolaOnlineComplejaD.gameObject.SetActive(value: false);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: true, pistola: false, sinGancho: true);
			}
			else
			{
				pistolaOnlineSimpleI.gameObject.SetActive(value: false);
				pistolaOnlineComplejaI.gameObject.SetActive(value: false);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: false, pistola: false, sinGancho: true);
			}
			break;
		case ControladorMano.EstadoDeLaMano.PistolaEnMano:
			if (manoDerecha)
			{
				pistolaOnlineSimpleD.gameObject.SetActive(value: true);
				pistolaOnlineComplejaD.gameObject.SetActive(value: false);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: true, pistola: true);
			}
			else
			{
				pistolaOnlineSimpleI.gameObject.SetActive(value: true);
				pistolaOnlineComplejaI.gameObject.SetActive(value: false);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: false, pistola: true);
			}
			break;
		case ControladorMano.EstadoDeLaMano.GanchoEnMano:
		case ControladorMano.EstadoDeLaMano.GanchoLanzandose:
		case ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar:
		case ControladorMano.EstadoDeLaMano.GanchoVolviendo:
			if (manoDerecha)
			{
				pistolaOnlineSimpleD.gameObject.SetActive(value: false);
				pistolaOnlineComplejaD.gameObject.SetActive(value: true);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: true, pistola: false);
			}
			else
			{
				pistolaOnlineSimpleI.gameObject.SetActive(value: false);
				pistolaOnlineComplejaI.gameObject.SetActive(value: true);
				controladorCadenaOnline.CambiarPuntoAnclaje(derecha: false, pistola: false);
			}
			break;
		}
	}

	private void MoverGancho(bool manoDerecha, Vector3 pos, Quaternion rot, bool fueraDelPadre, bool primeraVez)
	{
		if (manoDerecha)
		{
			if (fueraDelPadre && pistolaOnlineComplejaD.transform.parent != null)
			{
				pistolaOnlineComplejaD.transform.SetParent(null);
			}
			else if (!fueraDelPadre && pistolaOnlineComplejaD.transform.parent != padre)
			{
				pistolaOnlineComplejaD.transform.SetParent(padre);
			}
			if (primeraVez || Vector3.Distance(pistolaOnlineComplejaD.transform.position, pos) > 3f)
			{
				pistolaOnlineComplejaD.transform.position = pos;
			}
			else
			{
				pistolaOnlineComplejaD.transform.position = Vector3.Lerp(pistolaOnlineComplejaD.transform.position, pos, Time.deltaTime * velocidadLerpGancho);
			}
			pistolaOnlineComplejaD.transform.rotation = Quaternion.Lerp(pistolaOnlineComplejaD.transform.rotation, rot, Time.deltaTime * velocidadLerpGancho);
		}
		else
		{
			if (fueraDelPadre && pistolaOnlineComplejaI.transform.parent != null)
			{
				pistolaOnlineComplejaI.transform.SetParent(null);
			}
			else if (!fueraDelPadre && pistolaOnlineComplejaI.transform.parent != padre)
			{
				pistolaOnlineComplejaI.transform.SetParent(padre);
			}
			if (primeraVez || Vector3.Distance(pistolaOnlineComplejaI.transform.position, pos) > 3f)
			{
				pistolaOnlineComplejaI.transform.position = pos;
			}
			else
			{
				pistolaOnlineComplejaI.transform.position = Vector3.Lerp(pistolaOnlineComplejaI.transform.position, pos, Time.deltaTime * velocidadLerpGancho);
			}
			pistolaOnlineComplejaI.transform.rotation = Quaternion.Lerp(pistolaOnlineComplejaI.transform.rotation, rot, Time.deltaTime * velocidadLerpGancho);
		}
	}

	private void CambiarEstadoRifle(Rifle.EstadoArmaOnline estado)
	{
		switch (estado)
		{
		case Rifle.EstadoArmaOnline.SinArma:
			if ((bool)pistolaOnlineComplejaD)
			{
				pistolaOnlineComplejaD.transform.parent.gameObject.SetActive(value: false);
			}
			if ((bool)pistolaOnlineComplejaI)
			{
				pistolaOnlineComplejaI.transform.parent.gameObject.SetActive(value: false);
			}
			if ((bool)pistolaOnlineSimpleD)
			{
				pistolaOnlineSimpleD.transform.parent.gameObject.SetActive(value: false);
			}
			if ((bool)pistolaOnlineSimpleI)
			{
				pistolaOnlineSimpleI.transform.parent.gameObject.SetActive(value: false);
			}
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(value: false);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(value: false);
			}
			break;
		case Rifle.EstadoArmaOnline.Disparos:
		case Rifle.EstadoArmaOnline.Escopeta:
		case Rifle.EstadoArmaOnline.Laser:
		{
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(!zurdo);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(zurdo);
			}
			pistolaOnlineComplejaGanchoD.SetActive(value: false);
			pistolaOnlineComplejaGanchoI.SetActive(value: false);
			Animator component = pistolaOnlineComplejaGanchoD.transform.GetChild(0).GetComponent<Animator>();
			Animator component2 = pistolaOnlineComplejaGanchoI.transform.GetChild(0).GetComponent<Animator>();
			if (component.GetBool("Extender"))
			{
				component.SetBool("Extender", value: false);
			}
			if (component2.GetBool("Extender"))
			{
				component2.SetBool("Extender", value: false);
			}
			break;
		}
		case Rifle.EstadoArmaOnline.GanchoD:
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(!zurdo);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(zurdo);
			}
			pistolaOnlineComplejaGanchoD.SetActive(value: true);
			pistolaOnlineComplejaGanchoD.transform.GetChild(0).GetComponent<Animator>().SetBool("Extender", value: true);
			pistolaOnlineComplejaGanchoI.SetActive(value: false);
			break;
		case Rifle.EstadoArmaOnline.GanchoI:
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(!zurdo);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(zurdo);
			}
			pistolaOnlineComplejaGanchoD.SetActive(value: true);
			pistolaOnlineComplejaGanchoI.SetActive(value: true);
			pistolaOnlineComplejaGanchoI.transform.GetChild(0).GetComponent<Animator>().SetBool("Extender", value: true);
			break;
		case Rifle.EstadoArmaOnline.RecogerGanchos:
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(!zurdo);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(zurdo);
			}
			pistolaOnlineComplejaGanchoD.SetActive(value: true);
			pistolaOnlineComplejaGanchoI.SetActive(value: true);
			break;
		case Rifle.EstadoArmaOnline.RecogiendoGanchos:
			if ((bool)pistolaOnlineRifleD)
			{
				pistolaOnlineRifleD.SetActive(!zurdo);
			}
			if ((bool)pistolaOnlineRifleI)
			{
				pistolaOnlineRifleI.SetActive(zurdo);
			}
			pistolaOnlineComplejaGanchoD.SetActive(value: true);
			pistolaOnlineComplejaGanchoI.SetActive(value: true);
			pistolaOnlineComplejaGanchoD.transform.GetChild(0).GetComponent<Animator>().SetBool("Extender", value: false);
			pistolaOnlineComplejaGanchoI.transform.GetChild(0).GetComponent<Animator>().SetBool("Extender", value: false);
			break;
		}
	}

	private void MoverGanchoRifle(bool derecha, Vector3 pos, Quaternion rot, bool fueraDelPadre)
	{
		if (derecha)
		{
			if (fueraDelPadre && pistolaOnlineComplejaGanchoD.transform.parent != null)
			{
				pistolaOnlineComplejaGanchoD.transform.SetParent(null);
			}
			else if (!fueraDelPadre && pistolaOnlineComplejaGanchoD.transform.parent != padre)
			{
				pistolaOnlineComplejaGanchoD.transform.SetParent(padre);
			}
			if (Vector3.Distance(pistolaOnlineComplejaGanchoD.transform.position, pos) > 3f)
			{
				pistolaOnlineComplejaGanchoD.transform.position = pos;
			}
			else
			{
				pistolaOnlineComplejaGanchoD.transform.position = Vector3.Lerp(pistolaOnlineComplejaGanchoD.transform.position, pos, Time.deltaTime * velocidadLerpGancho);
			}
			pistolaOnlineComplejaGanchoD.transform.rotation = Quaternion.Lerp(pistolaOnlineComplejaGanchoD.transform.rotation, rot, Time.deltaTime * velocidadLerpGancho);
		}
		else
		{
			if (fueraDelPadre && pistolaOnlineComplejaGanchoI.transform.parent != null)
			{
				pistolaOnlineComplejaGanchoI.transform.SetParent(null);
			}
			else if (!fueraDelPadre && pistolaOnlineComplejaGanchoI.transform.parent != padre)
			{
				pistolaOnlineComplejaGanchoI.transform.SetParent(padre);
			}
			if (Vector3.Distance(pistolaOnlineComplejaGanchoI.transform.position, pos) > 3f)
			{
				pistolaOnlineComplejaGanchoI.transform.position = pos;
			}
			else
			{
				pistolaOnlineComplejaGanchoI.transform.position = Vector3.Lerp(pistolaOnlineComplejaGanchoI.transform.position, pos, Time.deltaTime * velocidadLerpGancho);
			}
			pistolaOnlineComplejaGanchoI.transform.rotation = Quaternion.Lerp(pistolaOnlineComplejaGanchoI.transform.rotation, rot, Time.deltaTime * velocidadLerpGancho);
		}
	}

	public ControladorMano.EstadoDeLaMano GanchoPuedeDestruirEsfera(Transform pistola)
	{
		if (pistola == pistolaOnlineSimpleD.transform || pistola == pistolaOnlineComplejaD.transform)
		{
			return estadoManoOnlineDerecha;
		}
		return estadoManoOnlineIzquierda;
	}

	public bool EsArmaDerecha(Transform pistola)
	{
		if (dosManos)
		{
			if (pistola == pistolaOnlineSimpleD.transform || pistola == pistolaOnlineComplejaD.transform)
			{
				return true;
			}
			return false;
		}
		if (pistola == pistolaOnlineRifleD.transform || pistola == pistolaOnlineComplejaGanchoD.transform)
		{
			return true;
		}
		return false;
	}

	public void PonermeFantasma()
	{
		if (GameManager.instance.player.gameObject == base.gameObject)
		{
			if (!estoyFantasmal)
			{
				meshManoD.material = fantasmalMat;
				meshManoI.material = fantasmalMat;
				if ((bool)GameManager.instance.player.cabezaMuñecoAbajo)
				{
					MeshRenderer component = GameManager.instance.player.cabezaMuñecoAbajo.GetComponent<MeshRenderer>();
					neoMat = component.sharedMaterials[0];
					Material[] sharedMaterials = component.sharedMaterials;
					sharedMaterials[0] = fantasmalMat;
					component.sharedMaterials = sharedMaterials;
				}
				estoyFantasmal = true;
			}
			return;
		}
		meshManoJugOnlineD.material = fantasmalMat;
		meshManoJugOnlineI.material = fantasmalMat;
		cabezaJugOnline.GetChild(0).GetComponent<MeshRenderer>().material = fantasmalMat;
		if (dosManos)
		{
			meshPistolaOnlineSimpleD.material = fantasmalMat;
			meshPistolaOnlineSimpleI.material = fantasmalMat;
			for (int i = 0; i < meshesPistolaOnlineComplejaD.Length; i++)
			{
				meshesPistolaOnlineComplejaD[i].material = fantasmalMat;
			}
			for (int j = 0; j < meshesPistolaOnlineComplejaI.Length; j++)
			{
				meshesPistolaOnlineComplejaI[j].material = fantasmalMat;
			}
		}
		else
		{
			meshRifleOnlineD.material = fantasmalMat;
			meshRifleOnlineI.material = fantasmalMat;
		}
	}

	public void PonermeResucitado()
	{
		if (GameManager.instance.player.gameObject == base.gameObject)
		{
			if (estoyFantasmal)
			{
				meshManoD.material = materialMano;
				meshManoI.material = materialMano;
				if ((bool)GameManager.instance.player.cabezaMuñecoAbajo && (bool)neoMat)
				{
					MeshRenderer component = GameManager.instance.player.cabezaMuñecoAbajo.GetComponent<MeshRenderer>();
					Material[] sharedMaterials = component.sharedMaterials;
					sharedMaterials[0] = neoMat;
					component.sharedMaterials = sharedMaterials;
				}
				estoyFantasmal = false;
			}
			return;
		}
		meshManoJugOnlineD.material = materialMano;
		meshManoJugOnlineI.material = materialMano;
		cabezaJugOnline.GetChild(0).GetComponent<MeshRenderer>().material = materialCabeza;
		if (dosManos)
		{
			meshPistolaOnlineSimpleD.material = materialPistola;
			meshPistolaOnlineSimpleI.material = materialPistola;
			for (int i = 0; i < meshesPistolaOnlineComplejaD.Length; i++)
			{
				meshesPistolaOnlineComplejaD[i].material = materialPistola;
			}
			for (int j = 0; j < meshesPistolaOnlineComplejaI.Length; j++)
			{
				meshesPistolaOnlineComplejaI[j].material = materialPistola;
			}
		}
		else
		{
			meshRifleOnlineD.material = materialRifle;
			meshRifleOnlineI.material = materialRifle;
		}
	}

	public void MutearMe()
	{
		yoMuteado = !yoMuteado;
		if ((bool)GameManager.instance.player.vozPun)
		{
			GameManager.instance.player.vozPun.IsRecording = !yoMuteado;
		}
		PersistentDataManager.SetInt("YoMuteado", yoMuteado ? 1 : 0);
		micButton.sprite = (yoMuteado ? micOff : micOn);
	}

	public void MutearJugadores()
	{
		GameManager.instance.jugadoresMuteados = !GameManager.instance.jugadoresMuteados;
		PersistentDataManager.SetInt("JugadoresMuteados", GameManager.instance.jugadoresMuteados ? 1 : 0);
		speakerButton.sprite = (GameManager.instance.jugadoresMuteados ? speakerOff : speakerOn);
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(Config.zurdo);
			stream.SendNext(Config.tipoDeControl == Config.TipoControl.DosManos);
			stream.SendNext(GameManager.instance.senDer.existe && GameManager.instance.senIzq.existe);
			stream.SendNext(empezar ? base.transform.position : (Vector3.one * 3000f));
			stream.SendNext(base.transform.rotation);
			stream.SendNext(empezar ? cabeza.position : (Vector3.one * 3000f));
			stream.SendNext(cabeza.rotation);
			stream.SendNext(empezar ? manoD.position : (Vector3.one * 3000f));
			stream.SendNext(manoD.rotation);
			stream.SendNext(empezar ? manoI.position : (Vector3.one * 3000f));
			stream.SendNext(manoI.rotation);
			if ((bool)GameManager.instance.player)
			{
				if ((Config.tipoDeControl == Config.TipoControl.DosManos && GameManager.instance.player.controladorManoDerecha.estadoDeLaMano != 0) || GameManager.instance.player.controladorManoIzquierda.estadoDeLaMano != 0)
				{
					stream.SendNext(TimeManager.GetInstance().miTiempo * 1000f);
					_ = TimeManager.GetInstance().miTiempo;
				}
				else if (Config.tipoDeControl == Config.TipoControl.UnaMano && GameManager.instance.player.rifle.GetEstadoArma() != 0)
				{
					stream.SendNext(TimeManager.GetInstance().miTiempo * 1000f);
					_ = TimeManager.GetInstance().miTiempo;
				}
				else
				{
					stream.SendNext(-1f);
				}
			}
			else
			{
				stream.SendNext(-1f);
			}
			int num = (GameManager.instance.m_salaManager ? GameManager.instance.m_salaManager.puntosTotales : 0);
			stream.SendNext(num);
			int num2 = ((Config.tipoDeControl != Config.TipoControl.DosManos) ? ((int)GameManager.instance.player.rifle.estadoArmaOnline) : ((int)((int)GameManager.instance.player.controladorManoDerecha.estadoDeLaMano * 10 + GameManager.instance.player.controladorManoIzquierda.estadoDeLaMano)));
			stream.SendNext(num2);
			if (Config.tipoDeControl == Config.TipoControl.DosManos)
			{
				stream.SendNext(pistolaComplejaD.position);
				stream.SendNext(pistolaComplejaD.rotation);
				stream.SendNext(pistolaComplejaI.position);
				stream.SendNext(pistolaComplejaI.rotation);
			}
			else
			{
				stream.SendNext(ganchoRifleD.position);
				stream.SendNext(ganchoRifleD.rotation);
				stream.SendNext(ganchoRifleI.position);
				stream.SendNext(ganchoRifleI.rotation);
			}
			stream.SendNext(GameManager.instance.player.idPhotonVoiceView);
			return;
		}
		if (Activado == 0)
		{
			Activado = 1;
		}
		zurdo = (bool)stream.ReceiveNext();
		dosManos = (bool)stream.ReceiveNext();
		dosSensores = (bool)stream.ReceiveNext();
		latestPosCuerpo = (Vector3)stream.ReceiveNext();
		latestRotCuerpo = (Quaternion)stream.ReceiveNext();
		latestPosCabeza = (Vector3)stream.ReceiveNext();
		latestRotCabeza = (Quaternion)stream.ReceiveNext();
		latestPosManoD = (Vector3)stream.ReceiveNext();
		latestRotManoD = (Quaternion)stream.ReceiveNext();
		latestPosManoI = (Vector3)stream.ReceiveNext();
		latestRotManoI = (Quaternion)stream.ReceiveNext();
		if (miIdPhoton == -1)
		{
			miIdPhoton = GetComponent<PhotonView>().ViewID;
		}
		if (miIdPhoton != -1 && miIdJuego == -1)
		{
			miIdJuego = PartidaSync.instance.GetIdJuegoSegunIdPhotonPlayer(miIdPhoton);
		}
		float num3 = (float)stream.ReceiveNext();
		num3 = ((!(num3 >= 0f)) ? 0f : (num3 / 1000f));
		int puntos = (int)stream.ReceiveNext();
		if (PartidaSync.instance.jugadores.ContainsKey(miIdJuego))
		{
			PartidaSync.instance.jugadores[miIdJuego].escalaTiempoJugador = num3;
			PartidaSync.instance.jugadores[miIdJuego].puntos = puntos;
		}
		int num4 = (int)stream.ReceiveNext();
		if (dosManos)
		{
			estadoManoOnlineDerecha = (ControladorMano.EstadoDeLaMano)(num4 / 10);
			estadoManoOnlineIzquierda = (ControladorMano.EstadoDeLaMano)(num4 % 10);
		}
		else
		{
			estadoRifleOnline = (Rifle.EstadoArmaOnline)num4;
		}
		latestPosGanchoD = (Vector3)stream.ReceiveNext();
		latestRotGanchoD = (Quaternion)stream.ReceiveNext();
		latestPosGanchoI = (Vector3)stream.ReceiveNext();
		latestRotGanchoI = (Quaternion)stream.ReceiveNext();
		idPhotonVoiceView = (int)stream.ReceiveNext();
	}
}
public class SyncMina : MonoBehaviourPun
{
	private const string RPC_Exploto = "ExplotoPUN";

	private void OnEnable()
	{
		GameManager.instance.minasEncendidas.Add(base.gameObject);
	}

	private void OnDisable()
	{
		GameManager.instance.minasEncendidas.Remove(base.gameObject);
	}

	public void Exploto()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("ExplotoPUN", RpcTarget.Others);
		}
	}

	[PunRPC]
	private void ExplotoPUN()
	{
		GetComponent<Mina>().ExplosionFake();
	}
}
[RequireComponent(typeof(PhotonView))]
public class SyncPelota : MonoBehaviourPun, IPunObservable
{
	public enum AccionesBolaOnline
	{
		Destruirse,
		Apagar,
		Encender
	}

	private Bola bola;

	[HideInInspector]
	public Bola.TipoEsfera tipoActual = Bola.TipoEsfera.desconocido;

	private Vector3 latestPos = Vector3.one * 3000f;

	private Quaternion latestRot;

	private Vector3 latestScale;

	[HideInInspector]
	public bool activadaSegunRed;

	private int estaActivada = -1;

	[HideInInspector]
	public int auxiliar;

	private MeshRenderer mesh;

	private GameObject particulaElectricidadGo;

	private GameObject particulasTrailGo;

	private Material matActivado;

	private Material matDesactivado;

	[HideInInspector]
	public Bola.TipoEsfera tipoEsferaSegunRed;

	[HideInInspector]
	public EsferaOnline esferaOnline;

	private SphereCollider sphereCollider;

	private float sensibilidadLerp = 10f;

	private int estaFantasmal = -1;

	private bool flag;

	[HideInInspector]
	public bool tengoEscudo;

	private const string RPC_EnviarAccion = "EnviarAccionPUN";

	private void OnEnable()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			EnviarAccion(AccionesBolaOnline.Encender, base.transform.position, base.transform.localScale);
			if (!PartidaSync.instance.pelotasEncendidas.Contains(this))
			{
				PartidaSync.instance.pelotasEncendidas.Add(this);
			}
		}
		if (tipoEsferaSegunRed == Bola.TipoEsfera.negra)
		{
			GetComponent<EfectoDesaparecer>().Aparecer(blackTexture: true);
		}
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			if (!sphereCollider)
			{
				sphereCollider = GetComponent<SphereCollider>();
			}
			sphereCollider.enabled = true;
		}
	}

	private void OnDisable()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			EnviarAccion(AccionesBolaOnline.Apagar, Vector3.one * 2000f, Vector3.one);
			if (PartidaSync.instance.pelotasEncendidas.Contains(this))
			{
				PartidaSync.instance.pelotasEncendidas.Remove(this);
			}
		}
	}

	public void ApagarEncenderMesh(bool activar)
	{
		mesh.enabled = activar;
	}

	private void Start()
	{
		bola = GetComponent<Bola>();
		mesh = base.transform.GetChild(0).GetChild(0).GetComponent<MeshRenderer>();
		PartidaSync.instance.pelotasSync.Add(this);
		base.transform.SetParent(null);
		sphereCollider = GetComponent<SphereCollider>();
		if (!base.photonView.IsMine)
		{
			EsferaScript component = GetComponent<EsferaScript>();
			if ((bool)component)
			{
				matDesactivado = component.desactivado;
				matActivado = component.activado;
			}
			esferaOnline = base.gameObject.AddComponent<EsferaOnline>();
			esferaOnline.explosion = component.explosion;
			esferaOnline.escudoEsfera = component.escudoEsfera;
			esferaOnline.iconosEscudos = component.iconosEscudos;
			esferaOnline.tiempoVida = component.tiempoVida;
			esferaOnline.particleTrailEsfera = component.particleTrailEsfera;
			esferaOnline.mesh = component.mesh;
			esferaOnline.activado = component.activado;
			esferaOnline.desactivado = component.desactivado;
			esferaOnline.setTiempoParaQuitarFantasmal(component.GetTiempoParaQuitarFantasmal());
			bola = esferaOnline;
			UnityEngine.Object.Destroy(GetComponent<Bola>());
			GetComponent<Rigidbody>().isKinematic = true;
		}
	}

	public void SetEstaActivada(int value)
	{
		estaActivada = value;
	}

	private void OnDestroy()
	{
		if ((bool)GameManager.instance.player)
		{
			if ((bool)GameManager.instance.player.weaponDer && (bool)GameManager.instance.player.weaponDer.bloque)
			{
				GameManager.instance.player.weaponDer.transform.SetParent(GameManager.instance.player.controladorManoDerecha.transform);
			}
			if ((bool)GameManager.instance.player.weaponIzq && (bool)GameManager.instance.player.weaponIzq.bloque)
			{
				GameManager.instance.player.weaponIzq.transform.SetParent(GameManager.instance.player.controladorManoIzquierda.transform);
			}
		}
		PartidaSync.instance.pelotasSync.Remove(this);
	}

	private void Update()
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if (!base.photonView || base.photonView.IsMine)
		{
			return;
		}
		if (estaActivada == 1)
		{
			if (Vector3.Distance(base.transform.position, latestPos) > 2f)
			{
				base.transform.position = latestPos;
			}
			else
			{
				base.transform.position = Vector3.Lerp(base.transform.position, latestPos, Time.deltaTime * sensibilidadLerp);
			}
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, latestRot, Time.deltaTime * sensibilidadLerp);
			base.transform.localScale = latestScale;
			if (tipoActual != tipoEsferaSegunRed || (estaFantasmal != 1 && (tipoEsferaSegunRed == Bola.TipoEsfera.azulFantasmal || tipoEsferaSegunRed == Bola.TipoEsfera.multiequipoFantasmal || tipoEsferaSegunRed == Bola.TipoEsfera.rojaFantasmal)) || (estaFantasmal != 0 && tipoEsferaSegunRed != Bola.TipoEsfera.azulFantasmal && tipoEsferaSegunRed != Bola.TipoEsfera.multiequipoFantasmal && tipoEsferaSegunRed != Bola.TipoEsfera.rojaFantasmal))
			{
				tipoActual = tipoEsferaSegunRed;
				esferaOnline.SetTipoEsfera(tipoActual);
				int num = -1;
				if (tipoEsferaSegunRed == Bola.TipoEsfera.multiEquipo || (tipoEsferaSegunRed == Bola.TipoEsfera.azul && GameManager.instance.player.miEquipo == 2) || (tipoEsferaSegunRed == Bola.TipoEsfera.roja && GameManager.instance.player.miEquipo == 1))
				{
					num = 1;
				}
				if ((tipoEsferaSegunRed == Bola.TipoEsfera.azul && GameManager.instance.player.miEquipo == 1) || (tipoEsferaSegunRed == Bola.TipoEsfera.roja && GameManager.instance.player.miEquipo == 2))
				{
					num = 0;
				}
				else if (tipoEsferaSegunRed == Bola.TipoEsfera.negra)
				{
					num = 2;
				}
				switch (num)
				{
				case 0:
				{
					matActivado = new Material(matActivado);
					ColorUtility.TryParseHtmlString("#0C0C6A", out var color3);
					matActivado.color = color3;
					matActivado.SetColor("_MainColor", color3);
					mesh.material = matActivado;
					estaFantasmal = 0;
					break;
				}
				case 1:
				{
					matActivado = new Material(matActivado);
					ColorUtility.TryParseHtmlString("#932323", out var color2);
					matActivado.color = color2;
					matActivado.SetColor("_MainColor", color2);
					mesh.material = matActivado;
					estaFantasmal = 0;
					break;
				}
				case 2:
				{
					matActivado = new Material(matActivado);
					ColorUtility.TryParseHtmlString("#1D1D1D", out var color);
					matActivado.color = color;
					matActivado.SetColor("_MainColor", color);
					mesh.material = matActivado;
					estaFantasmal = 0;
					break;
				}
				default:
					mesh.material = matDesactivado;
					estaFantasmal = 1;
					break;
				}
			}
		}
		else if (latestPos != Vector3.one * 3000f)
		{
			ActivarDesactivar(activar: false);
		}
	}

	public void ActivarDesactivar(bool activar, float px = 2000f, float py = 2000f, float pz = 2000f, float sx = 2000f, float sy = 2000f, float sz = 2000f)
	{
		if (!sphereCollider)
		{
			sphereCollider = GetComponent<SphereCollider>();
		}
		if (!mesh)
		{
			mesh = base.transform.GetChild(0).GetChild(0).GetComponent<MeshRenderer>();
		}
		if (!particulaElectricidadGo)
		{
			particulaElectricidadGo = base.transform.Find("ParticulasElectricidad").gameObject;
		}
		if (!particulasTrailGo)
		{
			Transform transform = base.transform.Find("ParticulasTrail");
			if ((bool)transform)
			{
				particulasTrailGo = transform.gameObject;
			}
		}
		if (activar)
		{
			estaActivada = 1;
			if (px != 2000f)
			{
				base.transform.position = new Vector3(px, py, pz);
				base.transform.localScale = new Vector3(sx, sy, sz);
				latestPos = base.transform.position;
			}
			else
			{
				base.transform.position = latestPos;
				base.transform.localScale = latestScale;
			}
			base.transform.rotation = latestRot;
			mesh.transform.parent.gameObject.SetActive(value: true);
			sphereCollider.enabled = true;
			particulaElectricidadGo.SetActive(value: true);
			if ((bool)particulasTrailGo)
			{
				particulasTrailGo.SetActive(value: true);
			}
			mesh.enabled = true;
		}
		else
		{
			estaActivada = 0;
			latestPos = Vector3.one * 3000f;
			base.transform.position = Vector3.one * 3000f;
			base.transform.rotation = Quaternion.identity;
			mesh.enabled = false;
			mesh.transform.parent.gameObject.SetActive(value: false);
			sphereCollider.enabled = false;
			particulaElectricidadGo.SetActive(value: false);
			if ((bool)particulasTrailGo)
			{
				particulasTrailGo.SetActive(value: false);
			}
			if (GameManager.instance.player.GetObjetoMuerte() == base.gameObject)
			{
				GameManager.instance.player.SetObjetoMuerte(null);
			}
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(base.transform.position);
			stream.SendNext(base.transform.rotation);
			stream.SendNext(base.transform.localScale);
			stream.SendNext((!bola) ? 1 : bola.GetEquipo());
			if (!bola)
			{
				bola = GetComponent<Bola>();
			}
			auxiliar = (int)bola.GetTipoEsfera();
			if (bola.GetEstadoEscudo() >= 0 || tengoEscudo)
			{
				if (flag)
				{
					if (bola.GetEstadoEscudo() == -1)
					{
						auxiliar = -99;
						tengoEscudo = false;
					}
					else
					{
						tengoEscudo = true;
						switch (bola.GetTipoEscudo())
						{
						case Bola.TipoEscudo.balas:
							auxiliar = bola.GetEstadoEscudo();
							break;
						case Bola.TipoEscudo.gancho:
							auxiliar = 10;
							break;
						case Bola.TipoEscudo.laser:
							auxiliar = 20;
							UnityEngine.Debug.Log(auxiliar);
							break;
						case Bola.TipoEscudo.mina:
							auxiliar = 30;
							break;
						}
						auxiliar++;
						auxiliar *= -1;
					}
					flag = false;
				}
				else
				{
					flag = true;
				}
			}
			stream.SendNext(auxiliar);
			return;
		}
		latestPos = (Vector3)stream.ReceiveNext();
		latestRot = (Quaternion)stream.ReceiveNext();
		latestScale = (Vector3)stream.ReceiveNext();
		int equipo = (int)stream.ReceiveNext();
		if ((bool)esferaOnline)
		{
			esferaOnline.SetEquipo(equipo);
		}
		auxiliar = (int)stream.ReceiveNext();
		if (estaActivada == 0 && latestPos != Vector3.one * 3000f)
		{
			ActivarDesactivar(activar: true);
		}
		if (auxiliar >= 0)
		{
			tipoEsferaSegunRed = (Bola.TipoEsfera)auxiliar;
			return;
		}
		if (!esferaOnline)
		{
			esferaOnline = GetComponent<EsferaOnline>();
		}
		if (!esferaOnline)
		{
			return;
		}
		if (auxiliar == -99)
		{
			esferaOnline.QuitarEscudo();
			tengoEscudo = false;
			return;
		}
		auxiliar *= -1;
		auxiliar--;
		if (auxiliar < 10)
		{
			if (!tengoEscudo)
			{
				esferaOnline.PonerEscudoOnline(auxiliar + 1);
				tengoEscudo = true;
			}
			if (esferaOnline.GetTipoEscudo() != Bola.TipoEscudo.balas)
			{
				esferaOnline.SetTipoEscudo(Bola.TipoEscudo.balas);
			}
			esferaOnline.tipoEscudoInicio = esferaOnline.GetTipoEscudo();
			if (esferaOnline.numBalasEscudo != auxiliar)
			{
				esferaOnline.CambiarNumBalasEscudo(auxiliar);
			}
		}
		else if (auxiliar < 20)
		{
			if (!tengoEscudo)
			{
				esferaOnline.PonerEscudoOnline(0);
				tengoEscudo = true;
			}
			if (esferaOnline.GetTipoEscudo() != Bola.TipoEscudo.gancho)
			{
				esferaOnline.SetTipoEscudo(Bola.TipoEscudo.gancho);
			}
			esferaOnline.tipoEscudoInicio = esferaOnline.GetTipoEscudo();
		}
		else if (auxiliar < 30)
		{
			if (!tengoEscudo)
			{
				esferaOnline.PonerEscudoOnline(5);
				tengoEscudo = true;
			}
			if (esferaOnline.GetTipoEscudo() != Bola.TipoEscudo.laser)
			{
				esferaOnline.SetTipoEscudo(Bola.TipoEscudo.laser);
			}
			esferaOnline.tipoEscudoInicio = esferaOnline.GetTipoEscudo();
		}
		else
		{
			if (!tengoEscudo)
			{
				esferaOnline.PonerEscudoOnline(6);
				tengoEscudo = true;
			}
			if (esferaOnline.GetTipoEscudo() != Bola.TipoEscudo.mina)
			{
				esferaOnline.SetTipoEscudo(Bola.TipoEscudo.mina);
			}
			esferaOnline.tipoEscudoInicio = esferaOnline.GetTipoEscudo();
		}
	}

	public void EnviarAccion(AccionesBolaOnline accion, Vector3 pos, Vector3 escala)
	{
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			base.photonView.RPC("EnviarAccionPUN", RpcTarget.Others, (int)accion, pos, escala);
		}
	}

	[PunRPC]
	private void EnviarAccionPUN(int accion, Vector3 pos, Vector3 escala)
	{
		switch ((AccionesBolaOnline)accion)
		{
		case AccionesBolaOnline.Destruirse:
			bola.Destruirse();
			break;
		case AccionesBolaOnline.Apagar:
			activadaSegunRed = false;
			ActivarDesactivar(activar: false);
			break;
		case AccionesBolaOnline.Encender:
			activadaSegunRed = true;
			ActivarDesactivar(activar: true, pos.x, pos.y, pos.z, escala.x, escala.y, escala.z);
			break;
		}
	}
}
public class SyncTorreta : MonoBehaviourPun
{
	private const string RPC_HeActivadoUnaTorreta = "HeActivadoUnaTorretaPUN";

	public void HeActivadoUnaTorreta(bool activar, int idPhotonPlayerTarget)
	{
		float num = 2.1474836E+09f;
		int num2 = -1;
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (!PartidaSync.instance.jugadores[key].estaMuerto)
			{
				GameObject gameObject = PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer);
				float num3 = Vector3.Distance(base.transform.position, gameObject.transform.position);
				if (num > num3)
				{
					num = num3;
					num2 = PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer;
				}
			}
		}
		if (num2 == -1)
		{
			return;
		}
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if (!base.photonView)
		{
			return;
		}
		if (PhotonNetwork.IsMasterClient)
		{
			ParedPistola component = base.transform.GetComponent<ParedPistola>();
			GameObject gameObject2 = null;
			if (activar)
			{
				gameObject2 = PartidaSync.instance.DameJugadorOnline(num2);
			}
			component.ActivarTorretaEnOnline(activar, gameObject2 ? gameObject2.transform : null, component.nivelTorreta);
			base.photonView.RPC("HeActivadoUnaTorretaPUN", RpcTarget.Others, activar, num2, component.nivelTorreta);
		}
		else
		{
			base.photonView.RPC("HeActivadoUnaTorretaPUN", RpcTarget.MasterClient, activar, num2, -1);
		}
	}

	[PunRPC]
	private void HeActivadoUnaTorretaPUN(bool activar, int idPhotonPlayerTarget, int nivelTorreta)
	{
		if (PhotonNetwork.IsMasterClient)
		{
			HeActivadoUnaTorreta(activar, idPhotonPlayerTarget);
			return;
		}
		if (!base.photonView)
		{
			GetComponent<PhotonView>();
		}
		if ((bool)base.photonView)
		{
			PhotonView photonView = PhotonView.Find(base.photonView.ViewID);
			GameObject gameObject = null;
			if (activar)
			{
				gameObject = PartidaSync.instance.DameJugadorOnline(idPhotonPlayerTarget);
			}
			if ((bool)photonView)
			{
				photonView.GetComponent<ParedPistola>().ActivarTorretaEnOnline(activar, gameObject ? gameObject.transform : null, nivelTorreta);
			}
		}
	}
}
public abstract class Arma : MonoBehaviour
{
	public enum ClipsAudioWeapon
	{
		Disparar,
		Golpear,
		InicioPowerup,
		FinPowerup,
		DisparoEscopeta,
		DisparoLaser,
		GolpearErrorEscudo,
		Atraer,
		DispararGancho,
		Recargar,
		Cont
	}

	public ControladorMano miMano;

	protected AudioClip[] audioClipsWeapon = new AudioClip[10];

	[HideInInspector]
	public bool puedeDisparar;

	[HideInInspector]
	public bool armaEstaEnBloque;

	[HideInInspector]
	public bool armaAncladaABloque;

	[HideInInspector]
	public bool nivelIniciado;

	[HideInInspector]
	public bool heDestruidoEsferaAlSerLanzado;

	[HideInInspector]
	public bool rifle;

	public int municion;

	public MeshRenderer pantalla;

	public GameObject PunteroFixParaCorregirDisparo;

	[HideInInspector]
	public GameObject coliderPistola;

	[HideInInspector]
	public GameObject triggerPistola;

	protected float cadenciaNormal = 15f;

	protected float cadenciaEscopeta = 22f;

	protected float cadenciaLaser = 12f;

	protected float anguloDispersion = 7.5f;

	protected float velocidadBalaEscopeta = 15f;

	public float fuerzaSalto;

	protected ParticleSystem particulasDisparo;

	protected ParticleSystem particulasDisparo2;

	protected int ticksDesdeUltimoDisparo;

	protected AudioSource[] audioSources;

	[HideInInspector]
	public Weapon weaponScript;

	[HideInInspector]
	public Rifle rifleScript;

	[HideInInspector]
	public bool armaEstaEnPared;

	[HideInInspector]
	public bool ChocadoPelota;

	public int municionMaxNormal = 2;

	[HideInInspector]
	public int municionMaxEscopeta = 1;

	[HideInInspector]
	public int municionMaxLaser = 2;

	[HideInInspector]
	public int municionMaxActual;

	[HideInInspector]
	public Vector3 transformInicial;

	[HideInInspector]
	public Quaternion rotacionInicial;

	[HideInInspector]
	public Transform padreInicio;

	public MeshRenderer meshArma;

	[HideInInspector]
	public bool armaEnFantasmal;

	public Material[] materiales = new Material[2];

	public TextMeshPro textoTiempoArma;

	protected Coroutine devolverALaNormalidadCor;

	public float tiempoRecarga = 0.5f;

	public bool recargando;

	private Coroutine corRecargar;

	[HideInInspector]
	public Animator animPistola;

	public GameObject laser;

	public abstract void Disparo();

	public abstract void PonerPosicionInicial();

	public void Recargar()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy && base.gameObject.activeSelf)
		{
			if (corRecargar == null)
			{
				corRecargar = StartCoroutine(RecargarCor());
			}
			recargando = true;
		}
		recargando = false;
	}

	private IEnumerator RecargarCor()
	{
		if ((bool)weaponScript)
		{
			weaponScript.ApagarPantallaPorTextura();
		}
		else
		{
			_ = (bool)rifleScript;
		}
		yield return null;
		if ((bool)weaponScript)
		{
			weaponScript.Recarga();
		}
		else if ((bool)rifleScript)
		{
			rifleScript.CambiarEstadoArma(Rifle.EstadoArma.Disparos);
		}
		recargando = false;
		corRecargar = null;
	}

	public void SetPosIniWeapon()
	{
		transformInicial = base.transform.localPosition;
		rotacionInicial = base.transform.localRotation;
		padreInicio = base.transform.parent;
	}
}
public class BalaEsfera : MonoBehaviour
{
	public Transform target;

	public Vector3 dir = Vector3.zero;

	public Vector3 destino = Vector3.zero;

	public Vector3 velocidadSinTrucar = Vector3.zero;

	private float ranPosX;

	private float ranPosY;

	private float ranPosZ;

	private Rigidbody rb;

	public float vel;

	private bool rebotado;

	private bool puedoDestruirBala;

	private float tiempoBalaPuedeDestruirse;

	public int equipo = 1;

	private SphereCollider colider;

	private SyncBala balaSync;

	private Coroutine SonidoRebote;

	private void OnEnable()
	{
		balaSync = GetComponent<SyncBala>();
		puedoDestruirBala = false;
		rebotado = false;
		rb = GetComponent<Rigidbody>();
		if ((bool)GameManager.instance.player)
		{
			if (!target)
			{
				target = GameManager.instance.player.cabeza.transform;
			}
			equipo = target.root.GetComponent<SyncJugadores>().equipo;
			base.transform.LookAt(target);
			ranPosX = UnityEngine.Random.Range(-0.1f, 0.1f);
			ranPosY = UnityEngine.Random.Range(-0.1f, 0.1f);
			ranPosZ = UnityEngine.Random.Range(-0.1f, 0.1f);
			destino = new Vector3(target.position.x + ranPosX, target.position.y + ranPosY, target.position.z + ranPosZ);
			dir = destino - base.transform.position;
			dir = dir.normalized;
			base.gameObject.CompareTag(GameManager.instance.tagBalaEsfera);
			colider = GetComponent<SphereCollider>();
			colider.enabled = true;
		}
	}

	public void CambiarTarget(Transform t)
	{
		target = t;
		equipo = target.root.GetComponent<SyncJugadores>().equipo;
		base.transform.LookAt(target);
		destino = new Vector3(target.position.x + ranPosX, target.position.y + ranPosY, target.position.z + ranPosZ);
		dir = destino - base.transform.position;
		dir = dir.normalized;
		velocidadSinTrucar = dir * 10f;
	}

	private void OnCollisionEnter(Collision other)
	{
		bool flag = other.gameObject.CompareTag(GameManager.instance.tagPistola);
		bool flag2 = other.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline);
		bool flag3 = other.gameObject.CompareTag(GameManager.instance.tagEsfera);
		if (!other.gameObject.CompareTag(base.gameObject.tag) && !flag3 && !other.gameObject.CompareTag(GameManager.instance.tagMano) && !flag && !flag2 && !other.gameObject.CompareTag(GameManager.instance.tagCadena) && !other.gameObject.CompareTag(GameManager.instance.tagCadenaOriginal))
		{
			PoolObjetos.GetInstance().Eliminar(base.gameObject);
		}
		else if ((flag || flag2) && other.gameObject.layer != GameManager.instance.layerPistolaTrigger)
		{
			rb.velocity /= 10f;
			velocidadSinTrucar = -other.gameObject.transform.forward;
			dir = velocidadSinTrucar;
			puedoDestruirBala = true;
			tiempoBalaPuedeDestruirse = 0f;
			base.gameObject.tag = "Suelo";
			if (SonidoRebote == null)
			{
				SonidoRebote = StartCoroutine(PonerSonidoRebote());
			}
		}
		else if (flag3)
		{
			colider.enabled = false;
			EsferaScript component = other.gameObject.GetComponent<EsferaScript>();
			if (component.GetTipoEscudo() == Bola.TipoEscudo.nunguno)
			{
				component.Divide(null, 0);
				PoolObjetos.GetInstance().Eliminar(base.gameObject);
			}
			else
			{
				PoolObjetos.GetInstance().Eliminar(base.gameObject);
			}
		}
	}

	private IEnumerator PonerSonidoRebote()
	{
		if (!GameManager.instance.player.muerto)
		{
			balaSync.PonerAudioRebote();
		}
		yield return new WaitForSeconds(1f);
		SonidoRebote = null;
	}

	public void Rebotar(Vector3 normal)
	{
		if (!rebotado)
		{
			rebotado = true;
			rb.velocity = Vector3.zero;
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(dir), Time.deltaTime * 1f);
		}
	}

	private void Update()
	{
		_ = velocidadSinTrucar;
		rb.velocity = velocidadSinTrucar * TimeManager.GetInstance().GetTiempoMedioGlobal();
		if (tiempoBalaPuedeDestruirse < 30f)
		{
			if (puedoDestruirBala && TimeManager.GetInstance().GetTiempoDeEquipo(equipo) > 0.1f)
			{
				tiempoBalaPuedeDestruirse += TimeManager.GetInstance().GetTiempoDeEquipo(equipo) / 10f;
			}
		}
		else
		{
			PoolObjetos.GetInstance().Eliminar(base.gameObject);
		}
	}
}
public class BloqueRompibleDummy : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public abstract class Bola : MonoBehaviour
{
	[HideInInspector]
	public enum TipoEsfera
	{
		roja,
		azul,
		rojaFantasmal,
		azulFantasmal,
		negra,
		multiEquipo,
		multiequipoFantasmal,
		Mina,
		desconocido
	}

	public enum TipoEscudo
	{
		nunguno,
		gancho,
		balas,
		laser,
		negro,
		mina,
		cont
	}

	public enum ClipsAudioEsfera
	{
		GolpeEscudoCorrecto,
		GolpeEscudoIncorrecto,
		EscudoRoto,
		Cont
	}

	public int NivelDeBolaInicial = 3;

	[HideInInspector]
	public int NivelDeBolaFinal = 1;

	[HideInInspector]
	public Texture[] iconosEscudos;

	public TipoEsfera tipoEsfera;

	public TipoEscudo tipoEscudo;

	[HideInInspector]
	public TipoEscudo tipoEscudoInicio;

	[HideInInspector]
	public bool escudoDestruido;

	[HideInInspector]
	public bool destruyendoEscudo;

	[HideInInspector]
	public bool ganchoEnganchado;

	public int escudoHeredable;

	public bool fantasmal;

	[HideInInspector]
	public int equipo = 1;

	public AudioSource audioSourceBola;

	public MeshRenderer escudoEsfera;

	public float tiempoVida;

	public ParticleSystem particleTrailEsfera;

	public MeshRenderer mesh;

	public Material activado;

	public Material activadoLow;

	public Material desactivado;

	private float tiempoParaQuitarFantasmal = 0.3f;

	[HideInInspector]
	public bool efectoAparecerEnOnEnable;

	protected AudioClip[] audioClipsBoss = new AudioClip[3];

	protected AudioSource[] audioSources;

	[HideInInspector]
	public List<GanchoRifle> ganchosRifleEnganchados = new List<GanchoRifle>();

	[HideInInspector]
	public List<Weapon> ganchosWeaponEnganchados = new List<Weapon>();

	private Coroutine efectoDestruccionEscudo;

	private Vector3 oldPuntoTrail = Vector3.zero;

	private Vector3[] puntos;

	protected float vertexOffsetInicial = 0.05f;

	protected float opacityInicial = 1f;

	private void Awake()
	{
		tiempoParaQuitarFantasmal = 0.3f;
		equipo = GetEquipo();
		if (CalidadManager.instance.GetCalidad() < CalidadManager.Calidad.Alta)
		{
			activado = activadoLow;
		}
	}

	public float GetTiempoParaQuitarFantasmal()
	{
		return tiempoParaQuitarFantasmal;
	}

	public void setTiempoParaQuitarFantasmal(float valor)
	{
		tiempoParaQuitarFantasmal = valor;
	}

	public void Resetear()
	{
		if (efectoDestruccionEscudo != null)
		{
			StopCoroutine(efectoDestruccionEscudo);
		}
		escudoHeredable = 0;
		tipoEscudo = TipoEscudo.nunguno;
		tipoEscudoInicio = TipoEscudo.nunguno;
		PonerEscudo();
		escudoDestruido = false;
		destruyendoEscudo = false;
		ganchoEnganchado = false;
		oldPuntoTrail = Vector3.zero;
		vertexOffsetInicial = 0.05f;
		opacityInicial = 1f;
	}

	public void CambiarDuracionTrail(float escala)
	{
		if ((bool)particleTrailEsfera)
		{
			particleTrailEsfera.Stop();
			ParticleSystem.MainModule main = particleTrailEsfera.main;
			main.startLifetime = GetTrailTiempoDeVida(escala);
			particleTrailEsfera.Play();
		}
	}

	public bool EsDeMiEquipo(int equipoJug = -1)
	{
		if (equipoJug == -1)
		{
			equipoJug = GameManager.instance.player.miEquipo;
		}
		if (GetEquipo() == 9 || GetEquipo() == equipoJug)
		{
			return true;
		}
		return false;
	}

	public int GetEquipo()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			if (equipo != 1 && (GetTipoEsfera() == TipoEsfera.roja || GetTipoEsfera() == TipoEsfera.rojaFantasmal))
			{
				SetEquipo(1);
			}
			else if (equipo != 9 && (GetTipoEsfera() == TipoEsfera.multiEquipo || GetTipoEsfera() == TipoEsfera.multiequipoFantasmal))
			{
				SetEquipo(9);
			}
			else if (equipo != 2 && (GetTipoEsfera() == TipoEsfera.azul || GetTipoEsfera() == TipoEsfera.azulFantasmal))
			{
				SetEquipo(2);
			}
		}
		return equipo;
	}

	public abstract void CalcularColor();

	public void SetEquipo(int valor)
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Cooperativo)
		{
			valor = 9;
		}
		equipo = valor;
	}

	public TipoEsfera GetTipoEsfera()
	{
		return tipoEsfera;
	}

	public void SetTipoEsfera(TipoEsfera tipo)
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Cooperativo)
		{
			switch (tipo)
			{
			case TipoEsfera.roja:
			case TipoEsfera.azul:
				tipo = TipoEsfera.multiEquipo;
				break;
			case TipoEsfera.rojaFantasmal:
			case TipoEsfera.azulFantasmal:
				tipo = TipoEsfera.multiequipoFantasmal;
				break;
			}
		}
		tipoEsfera = tipo;
		PonerColorAParticulasTrailEsfera();
		CalcularColor();
	}

	public abstract void Destruirse();

	public abstract int GetEstadoEscudo();

	public abstract void GolpeoEscudo(int numGolpes = 1);

	public abstract void ponerComoInicio();

	public TipoEscudo GetTipoEscudo()
	{
		return tipoEscudo;
	}

	public void SetTipoEscudo(TipoEscudo tipo)
	{
		tipoEscudo = tipo;
		PonerEscudo();
	}

	public void PonerEscudo()
	{
		switch (tipoEscudo)
		{
		case TipoEscudo.nunguno:
			escudoEsfera.transform.parent.gameObject.SetActive(value: false);
			escudoDestruido = true;
			return;
		case TipoEscudo.gancho:
			escudoEsfera.GetComponent<BloqueRompible>().enabled = true;
			escudoEsfera.transform.parent.gameObject.SetActive(value: true);
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[0]);
			escudoDestruido = false;
			break;
		case TipoEscudo.balas:
			escudoEsfera.transform.parent.gameObject.SetActive(value: true);
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[1]);
			escudoDestruido = false;
			break;
		case TipoEscudo.laser:
			escudoEsfera.transform.parent.gameObject.SetActive(value: true);
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[5]);
			escudoDestruido = false;
			break;
		case TipoEscudo.mina:
			escudoEsfera.transform.parent.gameObject.SetActive(value: true);
			escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[6]);
			escudoDestruido = false;
			break;
		}
		tipoEscudoInicio = tipoEscudo;
		Color baseColorShield = GetBaseColorShield();
		Color fresnelColorShield = GetFresnelColorShield();
		escudoEsfera.material.SetColor("_Fresnelcolor", fresnelColorShield);
		escudoEsfera.material.SetColor("_TintColor", baseColorShield);
		escudoEsfera.material.SetFloat("_Opacity", 0f);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
		if ((bool)escudoEsfera && tipoEscudo != 0)
		{
			escudoEsfera.GetComponent<EfectoDesaparecerEscudo>().AparecerEscudo();
		}
	}

	public Texture[] GetIconosEscudo()
	{
		return new Texture[7]
		{
			Resources.Load<Texture>("Texturas/shield_hook"),
			Resources.Load<Texture>("Texturas/shield_gun4"),
			Resources.Load<Texture>("Texturas/shield_gun3"),
			Resources.Load<Texture>("Texturas/shield_gun2"),
			Resources.Load<Texture>("Texturas/shield_gun1"),
			Resources.Load<Texture>("Texturas/shield_chain"),
			Resources.Load<Texture>("Texturas/shield_mine")
		};
	}

	public void DestruirEscudo()
	{
		destruyendoEscudo = true;
		if (efectoDestruccionEscudo == null)
		{
			efectoDestruccionEscudo = StartCoroutine(CorrutinaDestruirEscudo());
		}
	}

	private IEnumerator CorrutinaDestruirEscudo()
	{
		ganchoEnganchado = false;
		if (GetComponent<PhotonView>().IsMine)
		{
			if (GetTipoEscudo() == TipoEscudo.laser)
			{
				PonerInmune();
			}
			if (GetTipoEscudo() == TipoEscudo.gancho)
			{
				PonerInmune(0.1f);
			}
		}
		escudoEsfera.GetComponent<SphereCollider>().enabled = false;
		escudoDestruido = true;
		SetTipoEscudo(TipoEscudo.nunguno);
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.transform.parent.gameObject.SetActive(value: true);
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			yield return null;
		}
		for (float j = 0f; j < 1f; j += 0.1f)
		{
			escudoEsfera.material.SetFloat("_Vertexoffset", escudoEsfera.material.GetFloat("_Vertexoffset") + 0.1f);
			if (escudoEsfera.material.GetFloat("_Opacity") > 0f)
			{
				escudoEsfera.material.SetFloat("_Opacity", escudoEsfera.material.GetFloat("_Opacity") - 0.1f);
			}
			yield return null;
		}
		escudoEsfera.transform.parent.gameObject.SetActive(value: false);
		efectoDestruccionEscudo = null;
	}

	private void PonerInmune(float tiempo = 0.5f, bool sinCambiarMaterial = false)
	{
		fantasmal = true;
		if (!sinCambiarMaterial)
		{
			if (GetTipoEsfera() == TipoEsfera.roja)
			{
				SetTipoEsfera(TipoEsfera.rojaFantasmal);
			}
			else if (GetTipoEsfera() == TipoEsfera.azul)
			{
				SetTipoEsfera(TipoEsfera.azulFantasmal);
			}
			PonerColorAParticulasTrailEsfera();
			mesh.material = desactivado;
		}
		setTiempoParaQuitarFantasmal(tiempo);
		tiempoVida = 0f;
	}

	public void PonerColorAParticulasTrailEsfera()
	{
		if ((bool)particleTrailEsfera)
		{
			Color color = new Color32(93, 43, 43, byte.MaxValue);
			Color col;
			if (tipoEsfera == TipoEsfera.azulFantasmal || tipoEsfera == TipoEsfera.multiequipoFantasmal || tipoEsfera == TipoEsfera.rojaFantasmal)
			{
				col = Color.cyan;
				color = new Color32(43, 43, 180, byte.MaxValue);
			}
			else if (tipoEsfera == TipoEsfera.azul)
			{
				col = Color.blue;
				color = new Color32(43, 43, byte.MaxValue, byte.MaxValue);
			}
			else if (tipoEsfera == TipoEsfera.negra)
			{
				col = Color.grey;
				color = new Color32(48, 48, 48, byte.MaxValue);
			}
			else
			{
				col = Color.red;
				color = new Color32(93, 43, 43, byte.MaxValue);
			}
			if ((bool)particleTrailEsfera)
			{
				particleTrailEsfera.GetComponent<ParticleSystemRenderer>().material.SetColor("_TintColor", color);
			}
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = particleTrailEsfera.colorOverLifetime;
			Gradient gradient = new Gradient();
			gradient.SetKeys(new GradientColorKey[1]
			{
				new GradientColorKey(col, 0f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(0f, 1f)
			});
			colorOverLifetime.color = gradient;
		}
	}

	public Color GetBaseColorShield()
	{
		return tipoEscudo switch
		{
			TipoEscudo.balas => new Color(0.95f, 0.42f, 0.42f, 1f), 
			TipoEscudo.gancho => new Color(1f, 0.6f, 0.003f, 1f), 
			TipoEscudo.laser => new Color(0.35f, 0.61f, 0.68f, 1f), 
			TipoEscudo.mina => new Color(0.42f, 0.42f, 0.42f, 1f), 
			_ => new Color(0.5f, 0.68f, 0.36f, 1f), 
		};
	}

	public Color GetFresnelColorShield()
	{
		return tipoEscudo switch
		{
			TipoEscudo.balas => new Color(0.9f, 0.14f, 0.64f, 1f), 
			TipoEscudo.gancho => new Color(0.31f, 0.3f, 0.06f, 1f), 
			TipoEscudo.laser => new Color(0.16f, 0.47f, 1f, 1f), 
			TipoEscudo.mina => new Color(0f, 0f, 0f, 1f), 
			_ => new Color(0.16f, 1f, 0.32f, 1f), 
		};
	}

	public Vector3 GetEscala()
	{
		int num = ((Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo) ? 4 : 2);
		return NivelDeBolaInicial switch
		{
			1 => new Vector3(0.175f, 0.175f, 0.175f) * num, 
			2 => new Vector3(0.35f, 0.35f, 0.35f) * num, 
			3 => new Vector3(0.7f, 0.7f, 0.7f) * num, 
			4 => new Vector3(1.4f, 1.4f, 1.4f) * num, 
			5 => new Vector3(2.8f, 2.8f, 2.8f) * num, 
			6 => new Vector3(5.6f, 5.6f, 5.6f) * num, 
			_ => new Vector3(2.8f, 2.8f, 2.8f) * num, 
		};
	}

	public float GetTrailTiempoDeVida(float escala)
	{
		int num = ((Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo) ? 4 : 2);
		escala /= (float)num;
		if (escala < 0.2f)
		{
			return 0.25f;
		}
		if (escala < 0.5f)
		{
			return 0.4f;
		}
		if (escala < 1f)
		{
			return 0.8f;
		}
		if (escala < 2f)
		{
			return 1.8f;
		}
		if (escala < 4f)
		{
			return 3.5f;
		}
		return 7f;
	}

	public void CambiarDeEquipo(int equipo)
	{
		fantasmal = false;
		SetEquipo(equipo);
		switch (equipo)
		{
		case 1:
			SetTipoEsfera(fantasmal ? TipoEsfera.rojaFantasmal : TipoEsfera.roja);
			break;
		case 9:
			SetTipoEsfera(fantasmal ? TipoEsfera.multiequipoFantasmal : TipoEsfera.multiEquipo);
			break;
		default:
			SetTipoEsfera((!fantasmal) ? TipoEsfera.azul : TipoEsfera.azulFantasmal);
			break;
		}
		CalcularColor();
		PonerColorAParticulasTrailEsfera();
	}

	public void PonerAudioEnAudioSource(ClipsAudioEsfera clipAudio)
	{
		AudioClip audioClip = audioClipsBoss[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Weapon.cs " + clipAudio);
			return;
		}
		int num = 0;
		if (audioSources != null)
		{
			num = audioSources.Length;
		}
		if (num == 0)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en Weapon.cs");
			return;
		}
		int num2 = 0;
		while (audioSources[num2].isPlaying)
		{
			num2++;
			if (num2 >= audioSources.Length)
			{
				num2 = 0;
				audioSources[num2].Stop();
			}
		}
		if (num2 < 999)
		{
			audioSources[num2].clip = audioClip;
			audioSources[num2].Play();
		}
	}

	private void OnEnable()
	{
		escudoEsfera.GetComponent<SphereCollider>().enabled = true;
		escudoEsfera.GetComponent<BloqueRompible>().enabled = false;
		if ((bool)escudoEsfera.sharedMaterial)
		{
			escudoEsfera.sharedMaterial.SetFloat("_Vertexoffset", vertexOffsetInicial);
			escudoEsfera.sharedMaterial.SetFloat("_Opacity", opacityInicial);
		}
	}

	private void OnDisable()
	{
		Disable();
	}

	public void Disable()
	{
		destruyendoEscudo = false;
		escudoEsfera.GetComponent<SphereCollider>().enabled = true;
		escudoEsfera.GetComponent<BloqueRompible>().enabled = false;
		if ((bool)escudoEsfera.sharedMaterial)
		{
			escudoEsfera.sharedMaterial.SetFloat("_Vertexoffset", vertexOffsetInicial);
			escudoEsfera.sharedMaterial.SetFloat("_Opacity", opacityInicial);
		}
		StopAllCoroutines();
		ganchosRifleEnganchados.Clear();
		ganchosWeaponEnganchados.Clear();
	}
}
[ExecuteInEditMode]
public class BolaDummy : Bola
{
	public GameObject minaGo;

	public GameObject pelotaGo;

	public Material materialShield;

	private TipoEsfera tipo = TipoEsfera.desconocido;

	private TipoEscudo tipoE;

	public Vector3 direccion;

	private Material miMat;

	public override void Destruirse()
	{
		throw new NotImplementedException();
	}

	public override void CalcularColor()
	{
		Color color = Color.red;
		switch (tipoEsfera)
		{
		case TipoEsfera.azul:
		case TipoEsfera.azulFantasmal:
			pelotaGo.SetActive(value: true);
			minaGo.SetActive(value: false);
			color = Color.blue;
			break;
		case TipoEsfera.roja:
		case TipoEsfera.rojaFantasmal:
		case TipoEsfera.multiEquipo:
		case TipoEsfera.multiequipoFantasmal:
			pelotaGo.SetActive(value: true);
			minaGo.SetActive(value: false);
			color = Color.red;
			break;
		case TipoEsfera.negra:
			pelotaGo.SetActive(value: true);
			minaGo.SetActive(value: false);
			color = Color.black;
			break;
		case TipoEsfera.Mina:
			pelotaGo.SetActive(value: false);
			minaGo.SetActive(value: true);
			return;
		}
		if (!miMat)
		{
			mesh.material = activado;
			miMat = new Material(mesh.material);
			mesh.material = miMat;
		}
		mesh.material.shader = Shader.Find("Standard");
		mesh.material.SetTexture("_MainTex", null);
		mesh.material.color = color;
		mesh.material.SetColor("_MainColor", color);
		tipo = tipoEsfera;
		PonerColorAParticulasTrailEsfera();
	}

	public override void GolpeoEscudo(int numGolpes = 1)
	{
		throw new NotImplementedException();
	}

	public override void ponerComoInicio()
	{
		throw new NotImplementedException();
	}

	public override int GetEstadoEscudo()
	{
		throw new NotImplementedException();
	}
}
public class BossDummy : MonoBehaviour
{
	public enum TipoDeBoss
	{
		Mundo1_EscudoBala,
		Mundo2_HackerMetralleta,
		Mundo3_Mina,
		Mundo4_Laser,
		Mundo5_EscudoCadena,
		Mundo6_Dragon,
		Mundo7_OjoDebil,
		Mundo8_Teleport,
		Mundo9_Satelites,
		Mundo10_Indeciso,
		Mundo11_DragonDebil,
		Mundo12_HackerMetralleta,
		Mundo13_EscudoCadena,
		Mundo14_Teleport
	}

	public TipoDeBoss tipo;

	public Vector3 direccion;

	public bool bossMejorado;
}
public class EsferaOnline : Bola
{
	public GameObject explosion;

	private EfectoDesaparecer efectoDesaparecer;

	[HideInInspector]
	public int numBalasEscudo;

	private TrailRenderer trailEsfera;

	private float tiempoEnganchado;

	private GameObject ultimaBala;

	private void OnEnable()
	{
		NivelCompletado.GetInstance().SumarEsfera(base.transform, GetEquipo());
		trailEsfera = GetComponent<TrailRenderer>();
		CambiarDuracionTrail(base.transform.localScale.x);
		if ((bool)escudoEsfera && tipoEscudo != 0)
		{
			escudoEsfera.GetComponent<EfectoDesaparecerEscudo>().AparecerEscudo();
		}
	}

	private void OnDisable()
	{
		NivelCompletado.GetInstance().RestarEsfera(base.transform);
		ganchosRifleEnganchados.Clear();
		ganchosWeaponEnganchados.Clear();
	}

	private void QuitarGanchosAlDestruirEscudo()
	{
		for (int i = 0; i < ganchosRifleEnganchados.Count; i++)
		{
			if (!(ganchosRifleEnganchados[i] == null))
			{
				ganchosRifleEnganchados[i].transform.parent = null;
				ganchosRifleEnganchados[i].RebotarGancho();
				ganchosRifleEnganchados[i].bloque = null;
				ganchosRifleEnganchados[i].armaEstaEnBloque = false;
				ganchosRifleEnganchados[i].rb.useGravity = false;
				ganchosRifleEnganchados[i].rb.interpolation = RigidbodyInterpolation.Interpolate;
			}
		}
		for (int j = 0; j < ganchosWeaponEnganchados.Count; j++)
		{
			if (!(ganchosWeaponEnganchados[j] == null))
			{
				ganchosWeaponEnganchados[j].transform.parent = null;
				ganchosWeaponEnganchados[j].miMano.AtraerDesdeAire();
				ganchosWeaponEnganchados[j].bloque = null;
				ganchosWeaponEnganchados[j].armaEstaEnBloque = false;
				ganchosWeaponEnganchados[j].rb.useGravity = false;
				ganchosWeaponEnganchados[j].rb.interpolation = RigidbodyInterpolation.Interpolate;
			}
		}
		ganchosRifleEnganchados.Clear();
		ganchosWeaponEnganchados.Clear();
	}

	private void Awake()
	{
		if (iconosEscudos == null)
		{
			iconosEscudos = GetIconosEscudo();
		}
	}

	private void Start()
	{
		efectoDesaparecer = GetComponent<EfectoDesaparecer>();
	}

	private void Update()
	{
		if (ganchoEnganchado)
		{
			tiempoEnganchado += TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) * Time.deltaTime;
			float num = tiempoEnganchado * 0.1f;
			if (num < 0.05f)
			{
				num = 0.1f;
			}
			escudoEsfera.material.SetFloat("_Vertexoffset", num);
			if (tiempoEnganchado > 1.8f)
			{
				tiempoEnganchado = 0f;
				escudoEsfera.GetComponent<BloqueRompible>().Romper(1000f, 1000f, 1000f, ordenPorRed: false, porTiempo: true);
				PartidaSync.instance.MasterHeDestruidoUnEscudo(GetComponent<PhotonView>().ViewID, -1, -1, -1, -1);
			}
		}
		else
		{
			tiempoEnganchado = 0f;
		}
		if ((escudoEsfera == null || !escudoEsfera.gameObject.activeInHierarchy) && (ganchosRifleEnganchados.Count > 0 || ganchosWeaponEnganchados.Count > 0))
		{
			QuitarGanchosAlDestruirEscudo();
		}
	}

	public override void CalcularColor()
	{
		PonerColorAParticulasTrailEsfera();
	}

	public override void Destruirse()
	{
		StartCoroutine(Explota());
	}

	private IEnumerator Explota()
	{
		GameManager.instance.player.AddPuntos(200);
		yield return null;
		ultimaBala = null;
		GameObject obj = UnityEngine.Object.Instantiate(explosion, base.transform.position, base.transform.rotation, null);
		efectoDesaparecer.Desaparecer();
		obj.transform.localScale = base.transform.localScale / 2f;
	}

	public override void GolpeoEscudo(int numGolpes = 1)
	{
		throw new NotImplementedException();
	}

	public override void ponerComoInicio()
	{
		throw new NotImplementedException();
	}

	public override int GetEstadoEscudo()
	{
		throw new NotImplementedException();
	}

	public void PonerEscudoOnline(int numbalas)
	{
		TipoEscudo tipoEscudo;
		switch (numbalas)
		{
		case 0:
			tipoEscudo = TipoEscudo.gancho;
			break;
		case 5:
			tipoEscudo = TipoEscudo.laser;
			break;
		case 6:
			tipoEscudo = TipoEscudo.mina;
			break;
		default:
			tipoEscudo = TipoEscudo.balas;
			numBalasEscudo = numbalas - 1;
			break;
		}
		SetTipoEscudo(tipoEscudo);
	}

	public void QuitarEscudo()
	{
		DestruirEscudo();
	}

	public void CambiarNumBalasEscudo(int numbalas)
	{
		numBalasEscudo = numbalas;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numBalasEscudo + 1]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	private void OnTriggerEnter(Collider collision)
	{
		if (ultimaBala != collision.gameObject && collision.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			ultimaBala = collision.gameObject;
			SyncBala component = collision.transform.root.GetComponent<SyncBala>();
			if (!component || !PartidaSync.instance || component.idObjPhotonPlayer != PartidaSync.instance.miIdPhotonObjetoPlayer)
			{
				return;
			}
			PhotonView component2 = GetComponent<PhotonView>();
			Bala component3 = collision.transform.root.GetComponent<Bala>();
			if (!component2)
			{
				return;
			}
			SyncPelota component4 = base.gameObject.GetComponent<SyncPelota>();
			if (component4.tipoActual != TipoEsfera.azul && component4.tipoActual != 0 && component4.tipoActual != TipoEsfera.multiEquipo)
			{
				return;
			}
			if (component4.esferaOnline.GetTipoEscudo() != 0)
			{
				if (component4.esferaOnline.GetTipoEscudo() == TipoEscudo.balas)
				{
					PartidaSync.instance.MasterHeDestruidoUnEscudo(component2.ViewID, PartidaSync.instance.miJugador.idJuego, component3.GetNumUsosRestantes(), component3.GetComponent<PhotonView>().ViewID, PartidaSync.instance.miJugador.idJugador);
				}
				return;
			}
			Rigidbody component5 = collision.transform.root.GetComponent<Rigidbody>();
			PartidaSync.instance.MasterHeDestruidoUnaEsfera(component2.ViewID, PartidaSync.instance.miJugador.idJuego, component5 ? component5.velocity : (base.transform.position - collision.transform.position));
			GameManager.instance.m_salaManager.SumarPuntosTotales(500);
			if ((bool)component3)
			{
				component3.TocaObjetoBonus();
				component3.EfectoDesaparecer(1);
			}
		}
		else
		{
			if (!collision.gameObject.CompareTag(GameManager.instance.tagPistola) || EsDeMiEquipo() || GetTipoEscudo() == TipoEscudo.gancho)
			{
				return;
			}
			Arma component6 = collision.transform.root.GetComponent<Arma>();
			if ((bool)component6 && (bool)component6.weaponScript)
			{
				component6.weaponScript.RebotarGancho();
				return;
			}
			GanchoRifle component7 = collision.transform.root.GetComponent<GanchoRifle>();
			if ((bool)component7)
			{
				component7.RebotarGancho();
			}
		}
	}
}
public class EsferaScript : Bola
{
	public Vector3 velocidadSinTrucar = Vector3.zero;

	private bool heColisionadoAlgunaVez;

	public Vector3 posicionAnterior = Vector3.zero;

	public Vector3 iteracionesConMovimientoNulo = Vector3.zero;

	public float vel;

	public float porcentaje;

	public Vector3 dir;

	public Vector3 dirInicial = Vector3.zero;

	public GameObject bala;

	public GameObject explosion;

	public GameObject puntoReferencia;

	private AudioClip[] efectosDeExplosion = new AudioClip[4];

	private bool forzarTiempoNormal;

	private Vector3 prevDir;

	private Rigidbody rb;

	private EfectoDesaparecer efectoDesaparecer;

	public bool dividiendo;

	private Vector3 nuevaDireccionDesvioPorDisparoABola;

	private int ticksVagos;

	private Vector3 velocidadSinTrucarIdeal;

	private float velInicial;

	private float tiempoEnganchado;

	private float tiempoDesdeUltimaParedMovible;

	private GameObject balaAcabaDeEntrar;

	private bool muerta;

	private Coroutine reiniciarNumeroDisparos;

	public int numeroBalasEscudo;

	private Coroutine corForzarTiempo;

	private bool esferaDragon;

	private BossDragon bossDragon;

	private void Awake()
	{
		dirInicial = dir;
		if (iconosEscudos == null || iconosEscudos.Length == 0)
		{
			iconosEscudos = GetIconosEscudo();
		}
		efectosDeExplosion[0] = Resources.Load<AudioClip>("EfectosSonido/explosion_esfera1");
		efectosDeExplosion[1] = Resources.Load<AudioClip>("EfectosSonido/explosion_esfera4");
		efectosDeExplosion[2] = Resources.Load<AudioClip>("EfectosSonido/explosion_esfera3");
		efectosDeExplosion[3] = Resources.Load<AudioClip>("EfectosSonido/explosion_esfera2");
		if (CalidadManager.instance.GetCalidad() < CalidadManager.Calidad.Alta)
		{
			activado = activadoLow;
		}
	}

	private void OnEnable()
	{
		heColisionadoAlgunaVez = false;
		base.gameObject.layer = GameManager.instance.layerEsfera;
		base.gameObject.tag = GameManager.instance.tagEsfera;
		if (tipoEsfera != TipoEsfera.negra)
		{
			NivelCompletado.GetInstance().SumarEsfera(base.transform, GetEquipo());
		}
		muerta = false;
		if (dirInicial == Vector3.zero)
		{
			dirInicial = dir;
		}
		else
		{
			dir = dirInicial;
		}
		mesh.enabled = true;
		dividiendo = false;
		efectoDesaparecer = GetComponent<EfectoDesaparecer>();
		GetComponent<SphereCollider>().isTrigger = false;
		GetComponent<SphereCollider>().enabled = true;
		porcentaje = 0f;
		tiempoVida = 0f;
		numeroBalasEscudo = 0;
		rb = GetComponent<Rigidbody>();
		destruyendoEscudo = false;
		ganchoEnganchado = false;
		velInicial = vel;
		velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
		velocidadSinTrucarIdeal = velocidadSinTrucar;
		if (!muerta)
		{
			rb.AddForce(dir * vel, ForceMode.Impulse);
		}
		velInicial = vel;
		dir *= vel;
		ganchoEnganchado = false;
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			mesh.material = desactivado;
			if (GetTipoEsfera() == TipoEsfera.roja)
			{
				SetTipoEsfera(TipoEsfera.rojaFantasmal);
			}
			else if (GetTipoEsfera() == TipoEsfera.multiEquipo)
			{
				SetTipoEsfera(TipoEsfera.multiequipoFantasmal);
			}
			else if (GetTipoEsfera() == TipoEsfera.azul)
			{
				SetTipoEsfera(TipoEsfera.azulFantasmal);
			}
			else
			{
				CalcularColor();
			}
			fantasmal = true;
		}
		else
		{
			if (GetTipoEsfera() == TipoEsfera.roja)
			{
				SetTipoEsfera(TipoEsfera.roja);
			}
			else if (GetTipoEsfera() == TipoEsfera.multiEquipo)
			{
				SetTipoEsfera(TipoEsfera.multiEquipo);
			}
			else if (GetTipoEsfera() == TipoEsfera.azul)
			{
				SetTipoEsfera(TipoEsfera.azul);
			}
			else if (GetTipoEsfera() == TipoEsfera.negra)
			{
				SetTipoEsfera(TipoEsfera.negra);
			}
			else
			{
				CalcularColor();
			}
			fantasmal = false;
			if (efectoAparecerEnOnEnable)
			{
				efectoDesaparecer.Aparecer(GetTipoEsfera() == TipoEsfera.negra);
			}
		}
		efectoAparecerEnOnEnable = false;
		base.transform.localScale = GetEscala();
		CambiarDuracionTrail(GetEscala().x);
		GameManager.instance.esferasActivas.Add(this);
		PonerEscudo();
		escudoEsfera.GetComponent<SphereCollider>().enabled = true;
		escudoEsfera.GetComponent<BloqueRompible>().enabled = false;
		escudoEsfera.material.SetFloat("_Vertexoffset", vertexOffsetInicial);
		escudoEsfera.material.SetFloat("_Opacity", opacityInicial);
	}

	private void OnDisable()
	{
		DisableEsfera();
	}

	public void DisableEsfera()
	{
		base.gameObject.layer = GameManager.instance.layerEsfera;
		base.gameObject.tag = GameManager.instance.tagEsfera;
		destruyendoEscudo = false;
		ganchoEnganchado = false;
		tiempoEnganchado = 0f;
		if ((bool)NivelCompletado.GetInstance())
		{
			if (corForzarTiempo != null)
			{
				StopCoroutine(corForzarTiempo);
			}
			forzarTiempoNormal = false;
			vel = velInicial;
			NivelCompletado.GetInstance().RestarEsfera(base.transform);
			NivelCompletado.instance.listaEsferasEquipo1.Remove(base.transform);
			NivelCompletado.instance.listaEsferasEquipo2.Remove(base.transform);
			GameManager.instance.esferasActivas.Remove(this);
			ganchosRifleEnganchados.Clear();
			ganchosWeaponEnganchados.Clear();
		}
	}

	public override void CalcularColor()
	{
		ParticleSystem.MainModule main = base.transform.GetChild(1).GetChild(0).GetChild(0)
			.GetChild(0)
			.GetComponent<ParticleSystem>()
			.main;
		activado = new Material(activado);
		Color color = Color.red;
		if (tipoEsfera == TipoEsfera.negra)
		{
			ColorUtility.TryParseHtmlString("#1D1D1D", out color);
			base.gameObject.layer = 0;
		}
		else
		{
			if (!GameManager.instance.player)
			{
				return;
			}
			if (EsDeMiEquipo())
			{
				ColorUtility.TryParseHtmlString("#932323", out color);
			}
			else
			{
				ColorUtility.TryParseHtmlString("#0C0C6A", out color);
			}
		}
		activado.color = color;
		activado.SetColor("_MainColor", color);
		main.startColor = color;
		PonerColorAParticulasTrailEsfera();
		if (!fantasmal)
		{
			mesh.material = activado;
		}
	}

	private void Start()
	{
		velInicial = vel;
		GetComponent<SphereCollider>().isTrigger = false;
		audioSourceBola = GetComponent<AudioSource>();
		porcentaje = 0f;
		tiempoVida = 0f;
		destruyendoEscudo = false;
		ganchoEnganchado = false;
		rb = GetComponent<Rigidbody>();
		velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, dir, vel);
		dir *= vel;
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			mesh.material = desactivado;
			if (GetTipoEsfera() == TipoEsfera.roja)
			{
				SetTipoEsfera(TipoEsfera.rojaFantasmal);
			}
			else if (GetTipoEsfera() == TipoEsfera.multiEquipo)
			{
				SetTipoEsfera(TipoEsfera.multiequipoFantasmal);
			}
			else if (GetTipoEsfera() == TipoEsfera.azul)
			{
				SetTipoEsfera(TipoEsfera.azulFantasmal);
			}
			fantasmal = true;
		}
		PonerEscudo();
		audioSources = base.transform.GetComponents<AudioSource>();
		CargarClipsAudio();
	}

	private void Update()
	{
		if (CalidadManager.instance.calidadActual == CalidadManager.Calidad.Baja && !fantasmal)
		{
			ticksVagos++;
			if (ticksVagos < 3)
			{
				return;
			}
			ticksVagos = 0;
		}
		if (GetEquipo() == 1)
		{
			_ = NivelCompletado.GetInstance().listaEsferasEquipo1.Count;
		}
		else if (GetEquipo() == 2)
		{
			_ = NivelCompletado.GetInstance().listaEsferasEquipo2.Count;
		}
		else
		{
			_ = NivelCompletado.GetInstance().listaEsferasEquipo1.Count;
			_ = NivelCompletado.GetInstance().listaEsferasEquipo2.Count;
		}
		float num = TimeManager.instance.GetTiempoDeEquipo(GetEquipo());
		if (forzarTiempoNormal)
		{
			num = 1f;
		}
		if (dividiendo)
		{
			float num2 = num;
			base.transform.localScale += Vector3.one * Time.deltaTime * num2 * 0.2f;
			base.transform.Rotate(Vector3.up * (22f * Time.deltaTime * num2));
		}
		else
		{
			base.transform.eulerAngles = Vector3.zero;
		}
		if (heColisionadoAlgunaVez)
		{
			if (velocidadSinTrucar.x > 0f)
			{
				velocidadSinTrucar.x = 1f;
			}
			else
			{
				velocidadSinTrucar.x = -1f;
			}
			if (velocidadSinTrucar.y > 0f)
			{
				velocidadSinTrucar.y = 1f;
			}
			else
			{
				velocidadSinTrucar.y = -1f;
			}
			if (velocidadSinTrucar.z > 0f)
			{
				velocidadSinTrucar.z = 1f;
			}
			else
			{
				velocidadSinTrucar.z = -1f;
			}
		}
		if (num > 0.01f && heColisionadoAlgunaVez)
		{
			if (Mathf.Abs(posicionAnterior.x - base.transform.position.x) < 0.001f * num)
			{
				iteracionesConMovimientoNulo.x += 1f;
			}
			else
			{
				iteracionesConMovimientoNulo.x = 0f;
			}
			if (Mathf.Abs(posicionAnterior.y - base.transform.position.y) < 0.001f * num)
			{
				iteracionesConMovimientoNulo.y += 1f;
			}
			else
			{
				iteracionesConMovimientoNulo.y = 0f;
			}
			if (Mathf.Abs(posicionAnterior.z - base.transform.position.z) < 0.001f * num)
			{
				iteracionesConMovimientoNulo.z += 1f;
			}
			else
			{
				iteracionesConMovimientoNulo.z = 0f;
			}
			if (iteracionesConMovimientoNulo.x > 100f)
			{
				velocidadSinTrucar.x *= -1f;
				iteracionesConMovimientoNulo.x = 0f;
			}
			if (iteracionesConMovimientoNulo.y > 100f)
			{
				velocidadSinTrucar.y *= -1f;
				iteracionesConMovimientoNulo.y = 0f;
			}
			if (iteracionesConMovimientoNulo.z > 100f)
			{
				velocidadSinTrucar.z *= -1f;
				iteracionesConMovimientoNulo.z = 0f;
			}
			posicionAnterior = base.transform.position;
		}
		if (heColisionadoAlgunaVez)
		{
			if (velocidadSinTrucar.y > 0f)
			{
				velocidadSinTrucar.y = 1f;
			}
			else
			{
				velocidadSinTrucar.y = -1f;
			}
			if (velocidadSinTrucar.x > 0f)
			{
				velocidadSinTrucar.x = 1f;
			}
			else
			{
				velocidadSinTrucar.x = -1f;
			}
			if (velocidadSinTrucar.z > 0f)
			{
				velocidadSinTrucar.z = 1f;
			}
			else
			{
				velocidadSinTrucar.z = -1f;
			}
		}
		int num3 = ((Config.modoDeJuego != Config.ModosDeJuego.Online || Config.modoDePartida != Config.ModoDePartida.Competitivo) ? 1 : 2);
		if (!muerta)
		{
			rb.velocity = velocidadSinTrucar * num * num3;
		}
		if (tiempoVida > GetTiempoParaQuitarFantasmal() && fantasmal)
		{
			mesh.material = activado;
			if (GetTipoEsfera() == TipoEsfera.rojaFantasmal)
			{
				SetTipoEsfera(TipoEsfera.roja);
			}
			else if (GetTipoEsfera() == TipoEsfera.multiequipoFantasmal)
			{
				SetTipoEsfera(TipoEsfera.multiEquipo);
			}
			else if (GetTipoEsfera() == TipoEsfera.azulFantasmal)
			{
				SetTipoEsfera(TipoEsfera.azul);
			}
			fantasmal = false;
		}
		tiempoVida += Time.deltaTime * num;
		if (Debugs.dividirBolasConLaLetraO && Input.GetKeyDown(KeyCode.O) && !dividiendo)
		{
			Divide(null, 500);
		}
		if (ganchoEnganchado)
		{
			tiempoEnganchado += num * Time.deltaTime;
			float num4 = tiempoEnganchado * 0.1f;
			if (num4 < 0.05f)
			{
				num4 = 0.1f;
			}
			escudoEsfera.material.SetFloat("_Vertexoffset", num4);
			if (tiempoEnganchado > 1.8f)
			{
				tiempoEnganchado = 0f;
				escudoEsfera.GetComponent<BloqueRompible>().Romper(1000f, 1000f, 1000f, ordenPorRed: false, porTiempo: true);
			}
		}
		else
		{
			tiempoEnganchado = 0f;
		}
		if (vel > velInicial)
		{
			vel -= Time.deltaTime * 0.08f * vel;
		}
		if (vel < velInicial)
		{
			vel = velInicial;
		}
	}

	public override void ponerComoInicio()
	{
		if (ganchoEnganchado)
		{
			ganchoEnganchado = false;
			escudoEsfera.material.SetFloat("_Vertexoffset", 0.1f);
		}
	}

	public void CambiarDireccion(Vector3 newDir, float distance = -1f)
	{
		heColisionadoAlgunaVez = true;
		if (distance != -1f)
		{
			float num = (3f - distance) * 0.3f;
			if (num < 0f)
			{
				num = 0f;
			}
			vel += num;
			if (vel > 3f)
			{
				vel = 3f;
			}
		}
		velocidadSinTrucar += newDir * vel;
		velocidadSinTrucar *= 1.5f;
		rb.velocity = velocidadSinTrucar;
		dir = velocidadSinTrucar;
		int num2 = ((Config.modoDeJuego != Config.ModosDeJuego.Online || Config.modoDePartida != Config.ModoDePartida.Competitivo) ? 1 : 2);
		if (!muerta)
		{
			rb.velocity = velocidadSinTrucar * TimeManager.GetInstance().GetTiempoDeEquipo(GetEquipo()) * num2;
		}
	}

	private void DireccionEsferaAlJugador(Collision collision)
	{
		if (tiempoVida > 0.2f)
		{
			heColisionadoAlgunaVez = true;
		}
		Vector3 normal = collision.contacts[0].normal;
		dir = PhysicsControl.GetInsatance().BounceToPlayer(normal, dir, rb, vel, porcentaje, out velocidadSinTrucar);
		if (porcentaje < 0.6f)
		{
			porcentaje += 0.05f;
		}
		if (porcentaje > 0.75f)
		{
			porcentaje = 0.75f;
		}
		if (dir.y > 0f)
		{
			dir.y = 1f;
		}
		else
		{
			dir.y = -1f;
		}
	}

	public void DireccionEsferaNormal(Vector3 other)
	{
		UnityEngine.Debug.DrawRay(base.transform.position, Vector3.up, Color.green, 5f);
		UnityEngine.Debug.DrawRay(base.transform.position, other, Color.red, 5f);
		heColisionadoAlgunaVez = true;
		Vector3 b = dir;
		dir = PhysicsControl.GetInsatance().Bounce(other, dir, rb, 1f, out velocidadSinTrucar);
		if (Vector3.Distance(dir, b) < 1f)
		{
			dir -= Vector3.one;
		}
		if (dir.y > 0f)
		{
			dir.y = 1f;
		}
		else
		{
			dir.y = -1f;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (tipoEsfera == TipoEsfera.negra)
		{
			if ((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
			{
				if (Config.modoDeJuego == Config.ModosDeJuego.Online)
				{
					DireccionEsferaNormal(collision.contacts[0].normal);
				}
				else
				{
					DireccionEsferaAlJugador(collision);
				}
			}
			else
			{
				DireccionEsferaNormal(collision.contacts[0].normal);
			}
			return;
		}
		if (collision.gameObject.CompareTag(GameManager.instance.tagBala) && !fantasmal)
		{
			if (collision.gameObject.GetComponent<SyncBala>().equipo == GameManager.instance.player.miEquipo)
			{
				Divide(collision.gameObject, 500);
			}
			else
			{
				DireccionEsferaNormal(collision.transform.forward);
			}
		}
		if (collision.gameObject.CompareTag(GameManager.instance.tagBala) || collision.gameObject.layer == GameManager.instance.layerPistolaTrigger || collision.gameObject.CompareTag(GameManager.instance.tagPistola) || collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			return;
		}
		if (collision.gameObject.layer == GameManager.instance.layerMina)
		{
			collision.transform.GetComponent<Mina>().Colision(base.transform, 100f);
		}
		if ((bool)GameManager.instance.player && !collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			if (!collision.gameObject.CompareTag("ParedMovible"))
			{
				DireccionEsferaAlJugador(collision);
			}
			else
			{
				CambiarDireccion(-collision.transform.right * velocidadSinTrucar.magnitude);
			}
			return;
		}
		dir = PhysicsControl.GetInsatance().Bounce(collision.contacts[0].normal, dir, rb, vel, out velocidadSinTrucar);
		if (dir.y > 0f)
		{
			dir.y = 1f;
		}
		else
		{
			dir.y = -1f;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (tipoEsfera == TipoEsfera.negra)
		{
			if (other.tag == "Bala")
			{
				DireccionEsferaNormal(other.transform.forward);
				Bala component = other.GetComponent<Bala>();
				if ((bool)component)
				{
					component.TocaObjetoBonus();
					component.EfectoDesaparecer(1);
				}
			}
			return;
		}
		if (other.gameObject.layer == GameManager.instance.layerPistolaTrigger && tiempoVida > GetTiempoParaQuitarFantasmal() && !fantasmal)
		{
			Arma component2 = other.transform.parent.GetComponent<Arma>();
			if (!component2 && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
			{
				component2 = other.transform.parent.parent.parent.GetComponent<Arma>();
			}
			GanchoRifle ganchoRifle = null;
			if (!component2)
			{
				ganchoRifle = other.transform.parent.GetComponent<GanchoRifle>();
			}
			if (!component2 && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
			{
				ganchoRifle = other.transform.parent.parent.parent.GetComponent<GanchoRifle>();
			}
			if ((bool)component2 || (bool)ganchoRifle)
			{
				ControladorMano.EstadoDeLaMano estadoDeLaMano = (ganchoRifle ? ControladorMano.EstadoDeLaMano.GanchoLanzandose : ((!component2.rifle) ? component2.miMano.estadoDeLaMano : (component2.rifleScript.GetEstadoArma() switch
				{
					Rifle.EstadoArma.Disparos => ControladorMano.EstadoDeLaMano.PistolaEnMano, 
					Rifle.EstadoArma.Escopeta => ControladorMano.EstadoDeLaMano.PistolaEnMano, 
					Rifle.EstadoArma.GanchoD => ControladorMano.EstadoDeLaMano.GanchoEnMano, 
					Rifle.EstadoArma.GanchoI => ControladorMano.EstadoDeLaMano.GanchoEnMano, 
					Rifle.EstadoArma.Laser => ControladorMano.EstadoDeLaMano.PistolaEnMano, 
					Rifle.EstadoArma.SinArma => ControladorMano.EstadoDeLaMano.EstadoInicialSinArma, 
					_ => ControladorMano.EstadoDeLaMano.PistolaEnMano, 
				})));
				if (estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano && !fantasmal)
				{
					if (!GameManager.instance.player.muerto)
					{
						PhotonView component3 = base.gameObject.GetComponent<PhotonView>();
						PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, component3 ? component3.ViewID : (-1));
						GameManager.instance.player.Morir(base.gameObject, forzarMuerte: false, porCabeza: false, component2.miMano.mano == ControladorMano.Mano.Derecha);
					}
				}
				else
				{
					switch (estadoDeLaMano)
					{
					case ControladorMano.EstadoDeLaMano.GanchoEnMano:
						if (!escudoDestruido && GetTipoEscudo() == TipoEscudo.gancho)
						{
							break;
						}
						if (!escudoDestruido && GetTipoEscudo() == TipoEscudo.balas)
						{
							PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoIncorrecto);
							DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
						}
						else if (GetTipoEscudo() == TipoEscudo.nunguno)
						{
							if (Config.modoDeJuego == Config.ModosDeJuego.Online && !EsDeMiEquipo())
							{
								ForzarMovimientoConTiempo1(1f);
								DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
								return;
							}
							if ((bool)component2)
							{
								component2.municion = component2.municionMaxActual;
								if (component2.municion == 2)
								{
									component2.pantalla.gameObject.SetActive(value: true);
									component2.pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
								}
								else if (component2.municion == 1)
								{
									component2.pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, 0f));
								}
								else if ((bool)component2.rifleScript)
								{
									component2.pantalla.gameObject.SetActive(value: false);
								}
								else if ((bool)component2.weaponScript)
								{
									component2.pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
								}
								if (!component2.rifle)
								{
									component2.weaponScript.gancho.SetActive(value: false);
									component2.weaponScript.pistolaMesh.SetActive(value: true);
									component2.weaponScript.coliderGancho.SetActive(value: false);
									component2.weaponScript.coliderPistola.SetActive(value: true);
									component2.miMano.estadoDeLaMano = ControladorMano.EstadoDeLaMano.PistolaEnMano;
									component2.municion = 2;
								}
							}
							if (!dividiendo)
							{
								Divide(null, 400);
							}
						}
						else
						{
							PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoIncorrecto);
						}
						break;
					default:
						if (!escudoDestruido && GetTipoEscudo() == TipoEscudo.gancho)
						{
							break;
						}
						if (!escudoDestruido && GetTipoEscudo() == TipoEscudo.balas)
						{
							PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoIncorrecto);
							DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
							break;
						}
						if (GetTipoEscudo() == TipoEscudo.nunguno)
						{
							bool flag = false;
							if (Config.modoDeJuego == Config.ModosDeJuego.Online && !EsDeMiEquipo())
							{
								ForzarMovimientoConTiempo1(1f);
								DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
								flag = true;
								if (estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoLanzandose)
								{
									if ((bool)ganchoRifle)
									{
										ganchoRifle.RebotarGancho();
									}
									else if ((bool)component2 && (bool)component2.weaponScript)
									{
										component2.weaponScript.RebotarGancho();
									}
								}
							}
							if (!dividiendo && !flag && Divide(null, 400))
							{
								if ((bool)component2)
								{
									component2.heDestruidoEsferaAlSerLanzado = true;
								}
								if ((bool)ganchoRifle)
								{
									ganchoRifle.heDestruidoEsferaAlSerLanzado = true;
								}
							}
							break;
						}
						PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoIncorrecto);
						CambiarDireccion((base.transform.position - other.transform.position).normalized / 2f);
						if (estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoVolviendo || estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano || estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano)
						{
							break;
						}
						if ((bool)ganchoRifle)
						{
							if (ganchoRifle.estadoDelGancho == GanchoRifle.EstadoDelGancho.Lanzandose || ganchoRifle.estadoDelGancho == GanchoRifle.EstadoDelGancho.PuedeRetornar)
							{
								ganchoRifle.SaltarAPlayer();
							}
						}
						else if ((bool)component2.weaponScript)
						{
							component2.weaponScript.JumpTo(GameManager.instance.player.tJugador.gameObject, component2.weaponScript.fuerzaSalto * 0.7f);
						}
						break;
					case ControladorMano.EstadoDeLaMano.EstadoInicialSinArma:
						break;
					}
				}
			}
			else
			{
				SyncJugadores syncJugadores = other.transform.root.GetComponent<SyncJugadores>();
				if (!syncJugadores)
				{
					AnimTransformPistola component4 = other.transform.root.GetComponent<AnimTransformPistola>();
					syncJugadores = (component4 ? component4.syncjugador : null);
					if (!syncJugadores)
					{
						return;
					}
				}
				ControladorMano.EstadoDeLaMano estadoDeLaMano2 = syncJugadores.GanchoPuedeDestruirEsfera(other.transform.parent);
				if (estadoDeLaMano2 == ControladorMano.EstadoDeLaMano.PistolaEnMano && !fantasmal)
				{
					int num = -1;
					foreach (int key in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer == syncJugadores.GetComponent<PhotonView>().ViewID)
						{
							num = key;
							break;
						}
					}
					if (num == -1)
					{
						return;
					}
					PhotonView component5 = base.gameObject.GetComponent<PhotonView>();
					PartidaSync.instance.ClienteMuerete(num, component5 ? component5.ViewID : (-1));
				}
				else if (estadoDeLaMano2 == ControladorMano.EstadoDeLaMano.GanchoEnMano)
				{
					if (Config.modoDeJuego == Config.ModosDeJuego.Online && !EsDeMiEquipo(syncJugadores.equipo))
					{
						ForzarMovimientoConTiempo1(1f);
						DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
						return;
					}
					if (!dividiendo)
					{
						Divide(null, 0);
					}
					int num2 = -1;
					foreach (int key2 in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key2].idPhotonObjetoPlayer == syncJugadores.GetComponent<PhotonView>().ViewID)
						{
							num2 = PartidaSync.instance.jugadores[key2].idJugador;
							break;
						}
					}
					if (num2 == -1)
					{
						return;
					}
					PartidaSync.instance.ClienteHasDestruidoUnaEsfera(PhotonNetwork.CurrentRoom.GetPlayer(num2), syncJugadores.EsArmaDerecha(other.transform.parent), rebote: false, 400);
				}
				else
				{
					if (GetTipoEscudo() != 0)
					{
						return;
					}
					int num3 = -1;
					foreach (int key3 in PartidaSync.instance.jugadores.Keys)
					{
						if (PartidaSync.instance.jugadores[key3].idPhotonObjetoPlayer == syncJugadores.GetComponent<PhotonView>().ViewID)
						{
							num3 = PartidaSync.instance.jugadores[key3].idJugador;
							break;
						}
					}
					if (Config.modoDeJuego == Config.ModosDeJuego.Online && !EsDeMiEquipo(syncJugadores.equipo))
					{
						ForzarMovimientoConTiempo1(1f);
						DireccionEsferaNormal((other.transform.position - base.transform.position).normalized);
						return;
					}
					if (!dividiendo)
					{
						Divide(null, 0);
					}
					if (num3 == -1)
					{
						return;
					}
					PartidaSync.instance.ClienteHasDestruidoUnaEsfera(PhotonNetwork.CurrentRoom.GetPlayer(num3), syncJugadores.EsArmaDerecha(other.transform.parent), rebote: true, 400);
				}
			}
		}
		if (!other.gameObject.CompareTag(GameManager.instance.tagBala) || !(tiempoVida > GetTiempoParaQuitarFantasmal()) || fantasmal)
		{
			return;
		}
		Bala component6 = other.GetComponent<Bala>();
		if ((bool)component6)
		{
			if (!EsDeMiEquipo(component6.equipo) && GetTipoEscudo() != TipoEscudo.balas)
			{
				ForzarMovimientoConTiempo1(1f);
				Vector3 vector = base.transform.position - other.transform.position;
				if ((bool)component6.GetRigidBody() && component6.GetRigidBody().velocity.magnitude > 0.5f)
				{
					vector = component6.GetRigidBody().velocity;
				}
				DireccionEsferaNormal(vector.normalized);
			}
			else if (!escudoDestruido && GetTipoEscudo() == TipoEscudo.balas)
			{
				GameObject gameObject = other.gameObject;
				if (!(balaAcabaDeEntrar != gameObject))
				{
					return;
				}
				balaAcabaDeEntrar = gameObject;
				int numUsosRestantes = component6.GetNumUsosRestantes();
				int num4 = 0;
				int num5 = 4 - GetEstadoEscudo();
				if (num5 > 0)
				{
					num4 = numUsosRestantes;
					if (num4 > num5)
					{
						num4 = num5;
					}
				}
				GolpeoEscudo(num4);
				if ((bool)component6)
				{
					component6.TocaObjetoBonus();
					component6.EfectoDesaparecer(num4);
				}
			}
			else if (GetTipoEscudo() == TipoEscudo.nunguno)
			{
				if (!dividiendo)
				{
					Divide(other.gameObject, 500, component6);
				}
			}
			else
			{
				PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoIncorrecto);
				if ((bool)component6)
				{
					component6.RebotarPlayer();
				}
			}
		}
		else
		{
			SyncBala component7 = other.GetComponent<SyncBala>();
			if ((bool)component7 && !EsDeMiEquipo(component7.equipo))
			{
				ForzarMovimientoConTiempo1(1f);
				DireccionEsferaNormal((base.transform.position - other.transform.position).normalized);
			}
		}
	}

	private IEnumerator TiempoDispario()
	{
		GameObject instancia = base.gameObject;
		yield return new WaitForSeconds(UnityEngine.Random.Range(1, 10));
		if (instancia != null && (GetTipoEsfera() == TipoEsfera.roja || GetTipoEsfera() == TipoEsfera.azul || GetTipoEsfera() == TipoEsfera.multiEquipo))
		{
			Disparar();
		}
	}

	public bool Divide(GameObject other, int puntos, bool porBala = false, float xVelocityBalaOnline = -1000f, float yVelocityBalaOnline = -1000f, float zVelocityBalaOnline = -1000f)
	{
		if (tipoEsfera == TipoEsfera.negra)
		{
			return false;
		}
		if (esferaDragon)
		{
			if (other != null && !other.CompareTag(GameManager.instance.tagPistola) && !other.CompareTag(GameManager.instance.tagPistolaGanchoOnline) && !other.CompareTag(GameManager.instance.tagCadenaOriginal) && !other.CompareTag(GameManager.instance.tagCadena))
			{
				Vector3 zero = Vector3.zero;
				Rigidbody component = other.gameObject.GetComponent<Rigidbody>();
				zero = ((!component) ? (base.transform.position - other.transform.position) : component.velocity);
				nuevaDireccionDesvioPorDisparoABola = zero;
				if (other.CompareTag(GameManager.instance.tagBala))
				{
					Bala component2 = other.GetComponent<Bala>();
					if ((bool)component2)
					{
						component2.TocaObjetoBonus();
						component2.EfectoDesaparecer(1);
					}
				}
				else
				{
					PoolObjetos.GetInstance().Eliminar(other);
				}
			}
			bossDragon.QuitarEsferaPool(this);
			PonerEsferaDeInicio();
			Destruirse();
			return false;
		}
		if (tiempoVida > GetTiempoParaQuitarFantasmal() && !fantasmal)
		{
			dividiendo = true;
			dir = -dir;
			velocidadSinTrucar = PhysicsControl.GetInsatance().FuerzaInicial(rb, nuevaDireccionDesvioPorDisparoABola, vel);
			nuevaDireccionDesvioPorDisparoABola = base.transform.forward;
			if (other != null)
			{
				if (!other.CompareTag(GameManager.instance.tagPistola) && !other.CompareTag(GameManager.instance.tagPistolaGanchoOnline) && !other.CompareTag(GameManager.instance.tagCadenaOriginal) && !other.CompareTag(GameManager.instance.tagCadena))
				{
					Vector3 zero2 = Vector3.zero;
					Rigidbody component3 = other.gameObject.GetComponent<Rigidbody>();
					zero2 = ((!component3) ? (base.transform.position - other.transform.position) : component3.velocity);
					nuevaDireccionDesvioPorDisparoABola = zero2;
					if (other.CompareTag(GameManager.instance.tagBala))
					{
						Bala component4 = other.GetComponent<Bala>();
						if ((bool)component4)
						{
							component4.TocaObjetoBonus();
							component4.EfectoDesaparecer(1);
						}
					}
					else
					{
						PoolObjetos.GetInstance().Eliminar(other);
					}
				}
			}
			else if (xVelocityBalaOnline != -1000f)
			{
				nuevaDireccionDesvioPorDisparoABola = new Vector3(xVelocityBalaOnline, yVelocityBalaOnline, zVelocityBalaOnline);
			}
			GetComponent<SphereCollider>().isTrigger = true;
			if (NivelDeBolaInicial > NivelDeBolaFinal && !efectoDesaparecer.esferaEstaDesapareciendo)
			{
				Vector3 posicion = new Vector3(base.transform.position.x, base.transform.position.y, base.transform.position.z + base.transform.localScale.x * 0.1f);
				Vector3 posicion2 = new Vector3(base.transform.position.x, base.transform.position.y, base.transform.position.z - base.transform.localScale.x * 0.1f);
				GameObject gameObject = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, posicion, Quaternion.identity, null, GetEquipo(), GetTipoEsfera());
				GameObject gameObject2 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Esfera, posicion2, Quaternion.identity, null, GetEquipo(), GetTipoEsfera());
				EsferaScript esferaScript = null;
				EsferaScript esferaScript2 = null;
				esferaScript = gameObject.GetComponent<EsferaScript>();
				esferaScript2 = gameObject2.GetComponent<EsferaScript>();
				esferaScript.SetEquipo(GetEquipo());
				esferaScript2.SetEquipo(GetEquipo());
				NivelCompletado.GetInstance().SumarEsfera(gameObject.transform, GetEquipo());
				NivelCompletado.GetInstance().SumarEsfera(gameObject2.transform, GetEquipo());
				if (escudoHeredable > 0 && NivelDeBolaInicial - 1 > 1)
				{
					if (tipoEscudoInicio == TipoEscudo.nunguno)
					{
						escudoHeredable = 0;
					}
					esferaScript.SetTipoEscudo(tipoEscudoInicio);
					esferaScript2.SetTipoEscudo(tipoEscudoInicio);
					if (escudoHeredable < 999)
					{
						escudoHeredable--;
					}
					esferaScript.escudoHeredable = escudoHeredable;
					esferaScript2.escudoHeredable = escudoHeredable;
				}
				else
				{
					esferaScript.SetTipoEscudo(TipoEscudo.nunguno);
					esferaScript2.SetTipoEscudo(TipoEscudo.nunguno);
					escudoHeredable = 0;
				}
				esferaScript.dir = nuevaDireccionDesvioPorDisparoABola;
				esferaScript.NivelDeBolaInicial = NivelDeBolaInicial - 1;
				gameObject.transform.localScale = esferaScript.GetEscala();
				esferaScript.CambiarDuracionTrail(esferaScript.GetEscala().x);
				esferaScript2.dir = nuevaDireccionDesvioPorDisparoABola;
				esferaScript2.NivelDeBolaInicial = NivelDeBolaInicial - 1;
				gameObject2.transform.localScale = esferaScript2.GetEscala();
				esferaScript2.CambiarDuracionTrail(esferaScript2.GetEscala().x);
				gameObject.SetActive(value: true);
				gameObject2.SetActive(value: true);
				esferaScript.dir = nuevaDireccionDesvioPorDisparoABola;
				esferaScript2.dir = nuevaDireccionDesvioPorDisparoABola;
				if (puntos != 0)
				{
					GameManager.instance.m_salaManager.SumarPuntosTotales(puntos);
				}
				Destruirse();
				NivelCompletado.GetInstance().RestarEsfera(base.transform);
				if (GameManager.instance.powerUpShotgunActivo)
				{
					GameManager.instance.SumarEsferaDestruidaDurantePowerUpShotgun();
				}
				if (GameManager.instance.powerUpLaserActivo)
				{
					GameManager.instance.SumarEsferaDestruidaDurantePowerUpLaser();
				}
			}
			else if (NivelDeBolaInicial <= NivelDeBolaFinal)
			{
				SetTipoEscudo(TipoEscudo.nunguno);
				SetTipoEscudo(TipoEscudo.nunguno);
				escudoHeredable = 0;
				Destruirse();
				if (puntos != 0)
				{
					GameManager.instance.m_salaManager.SumarPuntosTotales(puntos);
				}
				NivelCompletado.GetInstance().RestarEsfera(base.transform);
			}
			return true;
		}
		return false;
	}

	public override void Destruirse()
	{
		SyncPelota component = GetComponent<SyncPelota>();
		if (PhotonNetwork.IsMasterClient)
		{
			component.EnviarAccion(SyncPelota.AccionesBolaOnline.Destruirse, Vector3.one * 2000f, Vector3.one);
			if (PartidaSync.instance.pelotasEncendidas.Contains(component))
			{
				PartidaSync.instance.pelotasEncendidas.Remove(component);
			}
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			StartCoroutine(Explota());
		}
	}

	private IEnumerator Explota()
	{
		muerta = true;
		GetComponent<SphereCollider>().enabled = false;
		rb.velocity = Vector3.zero;
		GameManager.instance.player.AddPuntos(200);
		yield return null;
		if (NivelDeBolaInicial < 1)
		{
			NivelDeBolaInicial = 1;
		}
		if (NivelDeBolaInicial > efectosDeExplosion.Length)
		{
			NivelDeBolaInicial = efectosDeExplosion.Length;
		}
		audioSourceBola.clip = efectosDeExplosion[NivelDeBolaInicial - 1];
		audioSourceBola.Play();
		SetTipoEscudo(TipoEscudo.nunguno);
		SetTipoEscudo(TipoEscudo.nunguno);
		escudoHeredable = 0;
		efectoDesaparecer.Desaparecer();
	}

	private void Disparar()
	{
		UnityEngine.Object.Instantiate(bala, base.transform.position, Quaternion.identity, null);
	}

	public override int GetEstadoEscudo()
	{
		int result = numeroBalasEscudo;
		if (escudoDestruido || GetTipoEscudo() == TipoEscudo.nunguno)
		{
			result = -1;
		}
		return result;
	}

	public override void GolpeoEscudo(int numGolpes = 1)
	{
		switch (GetTipoEscudo())
		{
		case TipoEscudo.nunguno:
			break;
		case TipoEscudo.gancho:
			DestruirEscudo();
			PonerAudioEnAudioSource(ClipsAudioEsfera.EscudoRoto);
			break;
		case TipoEscudo.balas:
			if (reiniciarNumeroDisparos != null)
			{
				StopCoroutine(reiniciarNumeroDisparos);
				reiniciarNumeroDisparos = null;
			}
			reiniciarNumeroDisparos = StartCoroutine(ReiniciarNumeroDisparosEscudo());
			numeroBalasEscudo += numGolpes;
			if (iconosEscudos == null || iconosEscudos.Length == 0)
			{
				iconosEscudos = GetIconosEscudo();
			}
			if (numeroBalasEscudo > 3 || numeroBalasEscudo > iconosEscudos.Length - 3)
			{
				if (!destruyendoEscudo)
				{
					DestruirEscudo();
					PonerAudioEnAudioSource(ClipsAudioEsfera.EscudoRoto);
				}
				if (numeroBalasEscudo > 4)
				{
					Divide(null, 500);
				}
			}
			else
			{
				PonerAudioEnAudioSource(ClipsAudioEsfera.GolpeEscudoCorrecto);
				escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo + 1]);
				escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f * (float)numeroBalasEscudo);
			}
			break;
		case TipoEscudo.laser:
			DestruirEscudo();
			PonerAudioEnAudioSource(ClipsAudioEsfera.EscudoRoto);
			break;
		}
	}

	private IEnumerator ReiniciarNumeroDisparosEscudo()
	{
		yield return new WaitForSeconds(5f);
		numeroBalasEscudo = 0;
		reiniciarNumeroDisparos = null;
		escudoEsfera.material.SetTexture("_MainTex", iconosEscudos[numeroBalasEscudo + 1]);
		escudoEsfera.material.SetFloat("_Vertexoffset", 0.05f);
	}

	protected void CargarClipsAudio()
	{
		audioClipsBoss[0] = Resources.Load<AudioClip>("EfectosSonido/impacto_OK_EscudoBala");
		audioClipsBoss[1] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsBoss[2] = Resources.Load<AudioClip>("EfectosSonido/impacto_final_EscudoBala");
	}

	public void ResetearEsfera()
	{
		tiempoEnganchado = 0f;
		dividiendo = false;
		numeroBalasEscudo = 0;
		muerta = false;
		tiempoDesdeUltimaParedMovible = 0f;
		SetTipoEscudo(TipoEscudo.nunguno);
		SetTipoEscudo(TipoEscudo.nunguno);
		escudoHeredable = 0;
		base.gameObject.layer = GameManager.instance.layerEsfera;
		base.gameObject.tag = GameManager.instance.tagEsfera;
	}

	public void ForzarMovimientoConTiempo1(float tiempo)
	{
		if (corForzarTiempo != null)
		{
			StopCoroutine(corForzarTiempo);
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			corForzarTiempo = StartCoroutine(ForzarMovimientoConTiempo(tiempo));
		}
	}

	private IEnumerator ForzarMovimientoConTiempo(float tiempo)
	{
		forzarTiempoNormal = true;
		yield return new WaitForSeconds(tiempo);
		forzarTiempoNormal = false;
	}

	public void ModificarTipoEsferaIngame(TipoEsfera tipo, BossDragon boss)
	{
		bossDragon = boss;
		esferaDragon = true;
		tipoEsfera = tipo;
		CalcularColor();
		base.gameObject.layer = 10;
	}

	public void PonerEsferaDeInicio()
	{
		bossDragon = null;
		esferaDragon = false;
		tipoEsfera = TipoEsfera.roja;
	}
}
public class GanchoRifle : MonoBehaviour
{
	public enum EstadoDelGancho
	{
		Deasactivado,
		EnRifle,
		Lanzandose,
		PuedeRetornar,
		Retornando
	}

	public enum ClipsAudioGancho
	{
		Golpear,
		GolpearErrorEscudo,
		TransformarAGancho,
		TransformarAPistola,
		Cont
	}

	public Rifle rifle;

	public bool derecha;

	public EstadoDelGancho estadoDelGancho;

	public EstadoDelGancho estadoAntiguoDelGancho;

	private Animator animWeapon;

	private Vector3 direccionLanzamiento;

	private float radioSpherecastCadena_SoloValeEnArmaDerecha = 0.075f;

	[HideInInspector]
	public bool heDestruidoEsferaAlSerLanzado;

	private AudioClip[] audioClipsWeapon = new AudioClip[4];

	[HideInInspector]
	public bool armaEstaEnBloque;

	[HideInInspector]
	public bool armaAncladaABloque;

	public GameObject cadenaEntreArmas;

	[HideInInspector]
	public BloqueRompible bloque;

	public LineRenderer lineRendererEntreArmas;

	private AudioSource audioSource;

	private Vector3 dir;

	public float inclinacionParaAnimacionGanchoQueVaDe0A1;

	public GanchoRifle otroGancho;

	public bool armaEstaEnPared;

	public bool ChocadoPelota;

	[HideInInspector]
	public GameObject player;

	public float fuerzaSalto;

	public Rigidbody rb;

	private float distanciaInicial;

	public Animator animPistola;

	public ControladorCadena controladorCadena;

	public Transform puntoCadena;

	private int layerMask = 33555456;

	public Vector3 transformInicial;

	public Quaternion rotacionInicial;

	public Transform padreInicio;

	public GameObject coliderGancho;

	public Collider col1;

	public Collider col2;

	private ParticleSystem particulasDisparo;

	private ParticleSystem particulasDisparo2;

	[HideInInspector]
	public bool armaEnFantasmal;

	private List<GameObject> pelotasEliminadas = new List<GameObject>();

	private bool cochandoConEsfera;

	private Vector3 inicio;

	private Vector3 final;

	private void Awake()
	{
		base.transform.tag = "Untagged";
		SetPosIniWeapon();
	}

	public void SetPosIniWeapon()
	{
		transformInicial = base.transform.localPosition;
		rotacionInicial = base.transform.localRotation;
		padreInicio = base.transform.parent;
	}

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		animPistola = base.transform.GetComponent<Animator>();
		controladorCadena = UnityEngine.Object.FindObjectOfType<ControladorCadena>();
		ChocadoPelota = false;
		if ((bool)cadenaEntreArmas)
		{
			lineRendererEntreArmas = cadenaEntreArmas.GetComponent<LineRenderer>();
		}
		armaAncladaABloque = false;
		rb = GetComponent<Rigidbody>();
		rb.interpolation = RigidbodyInterpolation.Interpolate;
		armaEstaEnBloque = false;
		rifle.PonerQuitarFantasmalGancho(activar: false, derecha);
		armaEstaEnPared = false;
		if (!base.transform.CompareTag(GameManager.instance.tagPistola))
		{
			base.transform.tag = "Pistola";
		}
		player = GameObject.FindGameObjectWithTag("Player");
		rb.isKinematic = true;
		if (audioClipsWeapon == null || audioClipsWeapon.Length == 0 || audioClipsWeapon[0] == null)
		{
			CargarClipsAudio();
		}
		layerMask = (1 << GameManager.instance.layerEsfera) | (1 << GameManager.instance.layerMina) | 0x200000;
		if (!animWeapon)
		{
			animWeapon = base.transform.GetChild(0).GetComponent<Animator>();
		}
	}

	private void Update()
	{
		if (TimeManager.instance.tiempoMuerto || !derecha || !lineRendererEntreArmas.enabled)
		{
			return;
		}
		inicio = lineRendererEntreArmas.transform.position;
		final = inicio + (controladorCadena.puntoFinal.transform.position - lineRendererEntreArmas.transform.position);
		Vector3 direction = controladorCadena.puntoFinal.transform.position - lineRendererEntreArmas.transform.position;
		float maxDistance = Vector3.Distance(final, inicio);
		if (Physics.SphereCast(inicio, radioSpherecastCadena_SoloValeEnArmaDerecha, direction, out var hitInfo, maxDistance, layerMask))
		{
			if (hitInfo.transform.tag == "Esfera")
			{
				EsferaScript component = hitInfo.transform.gameObject.GetComponent<EsferaScript>();
				if ((bool)component)
				{
					if (cochandoConEsfera)
					{
						component.tiempoVida = 0f;
					}
					if (component.fantasmal)
					{
						return;
					}
					if (!component.EsDeMiEquipo())
					{
						component.DireccionEsferaNormal(base.transform.forward);
					}
					else if (!component.escudoDestruido && component.GetTipoEscudo() == Bola.TipoEscudo.laser)
					{
						cochandoConEsfera = true;
						component.GolpeoEscudo();
					}
					else if (component.GetTipoEscudo() == Bola.TipoEscudo.nunguno && !component.dividiendo && component.Divide(null, 300))
					{
						if ((bool)GameManager.instance.player.weaponDer)
						{
							GameManager.instance.player.weaponDer.heDestruidoEsferaAlSerLanzado = true;
						}
						if ((bool)GameManager.instance.player.weaponIzq)
						{
							GameManager.instance.player.weaponIzq.heDestruidoEsferaAlSerLanzado = true;
						}
						if ((bool)GameManager.instance.player.rifle)
						{
							GameManager.instance.player.rifle.ganchoD.heDestruidoEsferaAlSerLanzado = true;
							GameManager.instance.player.rifle.ganchoI.heDestruidoEsferaAlSerLanzado = true;
						}
					}
					return;
				}
				SyncPelota component2 = hitInfo.transform.gameObject.GetComponent<SyncPelota>();
				if (((bool)GameManager.instance.player && GameManager.instance.player.muerto) || (component2.tipoActual != Bola.TipoEsfera.azul && component2.tipoActual != 0 && component2.tipoActual != Bola.TipoEsfera.multiEquipo) || !component2.esferaOnline.EsDeMiEquipo())
				{
					return;
				}
				if (component2.esferaOnline.GetTipoEscudo() == Bola.TipoEscudo.nunguno)
				{
					if (!pelotasEliminadas.Contains(hitInfo.transform.gameObject))
					{
						PartidaSync.instance.MasterHeDestruidoUnaEsfera(hitInfo.transform.gameObject.GetComponent<PhotonView>().ViewID, PartidaSync.instance.miJugador.idJuego, ((bool)rb && rb.velocity != Vector3.zero) ? rb.velocity : (component2.transform.position - base.transform.position).normalized);
						pelotasEliminadas.Add(hitInfo.transform.gameObject);
						GameManager.instance.player.weaponDer.heDestruidoEsferaAlSerLanzado = true;
						GameManager.instance.player.weaponIzq.heDestruidoEsferaAlSerLanzado = true;
						GameManager.instance.m_salaManager.SumarPuntosTotales(300);
						StartCoroutine(EliminarPelotaDeLista(hitInfo.transform.gameObject));
					}
				}
				else if (component2.esferaOnline.GetTipoEscudo() == Bola.TipoEscudo.laser)
				{
					PartidaSync.instance.MasterHeDestruidoUnEscudo(hitInfo.transform.gameObject.GetComponent<PhotonView>().ViewID, PartidaSync.instance.miJugador.idJuego, -1, -1, -1);
				}
			}
			else if (hitInfo.transform.tag == "Boss")
			{
				BossBase component3 = hitInfo.transform.gameObject.GetComponent<BossBase>();
				if ((bool)component3 && !component3.escudoDestruido && component3.tipoEscudo == Bola.TipoEscudo.laser)
				{
					if (component3.photonView.IsMine)
					{
						component3.GolpearBoss(2);
					}
					else
					{
						component3.GetComponent<SyncBoss>().MasterGolpeoABoss(2);
					}
				}
			}
			else
			{
				cochandoConEsfera = false;
			}
		}
		else
		{
			cochandoConEsfera = false;
		}
	}

	private void FixedUpdate()
	{
		if (base.transform.position.y < -10f || base.transform.position.y > 10f || base.transform.position.x > 5f || base.transform.position.x < -5f || base.transform.position.z > 3.6f || base.transform.position.z < -6f)
		{
			if (estadoDelGancho != EstadoDelGancho.Retornando)
			{
				rifle.CambiarEstadoArma(Rifle.EstadoArma.Disparos);
			}
			rb.velocity = Vector3.zero;
			rb.useGravity = false;
			rb.isKinematic = true;
		}
		if (TimeManager.instance.tiempoMuerto)
		{
			return;
		}
		if (estadoDelGancho == EstadoDelGancho.Lanzandose)
		{
			rb.velocity = direccionLanzamiento * TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) * 2f;
			col1.enabled = true;
			col2.enabled = true;
		}
		else if (estadoDelGancho == EstadoDelGancho.Retornando)
		{
			col1.enabled = false;
			col2.enabled = false;
			if (inclinacionParaAnimacionGanchoQueVaDe0A1 < 1f && Vector3.Distance(rifle.padreGanchos.position, base.transform.position) > 0.1f)
			{
				if (inclinacionParaAnimacionGanchoQueVaDe0A1 < 1f)
				{
					inclinacionParaAnimacionGanchoQueVaDe0A1 += TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) * Time.deltaTime * 0.2f;
				}
				if (inclinacionParaAnimacionGanchoQueVaDe0A1 > 1f)
				{
					inclinacionParaAnimacionGanchoQueVaDe0A1 = 1f;
				}
				rb.velocity = Vector3.zero;
				rb.useGravity = false;
				rb.isKinematic = true;
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, rifle.padreGanchos.rotation, inclinacionParaAnimacionGanchoQueVaDe0A1);
				base.transform.position = Vector3.Lerp(base.transform.position, rifle.padreGanchos.position, inclinacionParaAnimacionGanchoQueVaDe0A1);
			}
			else
			{
				base.transform.position = rifle.padreGanchos.position;
				base.transform.rotation = rifle.padreGanchos.rotation;
				TimeManager.GetInstance().MakeTimeNormal(condicion: false);
				CambiarEstadoGancho(EstadoDelGancho.Deasactivado);
				rifle.estadoArmaOnline = Rifle.EstadoArmaOnline.Disparos;
			}
		}
		else
		{
			col1.enabled = true;
			col2.enabled = true;
		}
	}

	private void LateUpdate()
	{
		if (armaAncladaABloque)
		{
			if (!otroGancho.bloque || otroGancho.bloque.isEscudo)
			{
				return;
			}
			if (distanciaInicial == 0f)
			{
				distanciaInicial = Vector3.Distance(base.transform.position, otroGancho.transform.position);
			}
			float num = Vector3.Distance(base.transform.position, otroGancho.transform.position);
			if (num > distanciaInicial)
			{
				dir = base.transform.position - otroGancho.transform.position;
				dir = dir.normalized;
				Rigidbody component = otroGancho.GetComponent<Rigidbody>();
				component.isKinematic = false;
				component.useGravity = false;
				component.AddForce(dir * 100f * (num - distanciaInicial), ForceMode.Impulse);
				dir = Vector3.zero;
			}
			if (Vector3.Distance(otroGancho.bloque.transform.position, otroGancho.bloque.posInicial) > 0.5f)
			{
				otroGancho.bloque.Romper();
				otroGancho.heDestruidoEsferaAlSerLanzado = true;
				if (!PhotonNetwork.IsMasterClient)
				{
					PartidaSync.instance.MasterHeDestruidoUnEscudo(otroGancho.bloque.bolaPadre.GetComponent<PhotonView>().ViewID, -1, -1, -1, -1);
				}
			}
			distanciaInicial = num;
		}
		else if (distanciaInicial != 0f)
		{
			distanciaInicial = 0f;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (TimeManager.instance.tiempoMuerto)
		{
			return;
		}
		if (estadoDelGancho == EstadoDelGancho.Lanzandose)
		{
			if (collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !ChocadoPelota)
			{
				ChocadoPelota = true;
				CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				Bola component = collision.gameObject.GetComponent<Bola>();
				if (!component.escudoDestruido && component.GetTipoEscudo() == Bola.TipoEscudo.gancho)
				{
					rb.isKinematic = true;
					rb.velocity = Vector3.zero;
					rb.interpolation = RigidbodyInterpolation.None;
					component.ganchoEnganchado = true;
					component.ganchosRifleEnganchados.Add(this);
					CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
					PonerAudioEnAudioSource(ClipsAudioGancho.Golpear);
					armaEstaEnBloque = true;
					bloque = collision.transform.GetChild(3).GetChild(0).gameObject.GetComponent<BloqueRompible>();
					bloque.HacerPadre(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					armaAncladaABloque = true;
				}
				else if (component.tipoEsfera == Bola.TipoEsfera.negra)
				{
					SaltarAPlayer();
					PonerAudioEnAudioSource(ClipsAudioGancho.Golpear);
				}
				else if (!component.escudoDestruido || component.GetTipoEscudo() != 0)
				{
					SaltarAPlayer();
				}
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagParedMovible))
			{
				SaltarAPlayer();
				CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				PonerAudioEnAudioSource(ClipsAudioGancho.GolpearErrorEscudo);
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagBoss) && !ChocadoPelota)
			{
				ChocadoPelota = true;
				CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				BossBase component2 = collision.gameObject.GetComponent<BossBase>();
				if (!component2.escudoDestruido && component2.tipoEscudo == Bola.TipoEscudo.gancho)
				{
					SaltarAPlayer();
					rb.isKinematic = true;
					rb.interpolation = RigidbodyInterpolation.None;
					component2.SetGanchoEnganchado(enganchado: true);
					if (collision.gameObject.CompareTag(GameManager.instance.tagPared))
					{
						armaEstaEnPared = true;
					}
					CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
					PonerAudioEnAudioSource(ClipsAudioGancho.Golpear);
					armaEstaEnBloque = true;
					bloque = collision.gameObject.GetComponentInChildren<BloqueRompible>();
					bloque.HacerPadre(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					armaAncladaABloque = true;
				}
				else if (!component2.escudoDestruido || component2.tipoEscudo != 0)
				{
					SaltarAPlayer();
				}
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagPared) || collision.gameObject.CompareTag(GameManager.instance.tagParedPistola))
			{
				SaltarAPlayer();
				rb.isKinematic = true;
				if (collision.gameObject.CompareTag(GameManager.instance.tagPared))
				{
					armaEstaEnPared = true;
				}
				CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				PonerAudioEnAudioSource(ClipsAudioGancho.Golpear);
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagRompible))
			{
				ChocadoPelota = true;
				SaltarAPlayer();
				CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				collision.gameObject.GetComponent<BossBase>();
			}
			if ((bool)collision.gameObject.GetComponent<BloqueRompible>() && bloque == null)
			{
				BloqueRompible component3 = collision.gameObject.GetComponent<BloqueRompible>();
				SaltarAPlayer();
				if (component3.isEscudo)
				{
					armaEstaEnBloque = true;
					bloque = collision.gameObject.GetComponent<BloqueRompible>();
					bloque.HacerHijo(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
				}
				else
				{
					heDestruidoEsferaAlSerLanzado = true;
					component3.Romper(base.transform.position.x, base.transform.position.y, base.transform.position.z);
				}
			}
		}
		if (estadoDelGancho == EstadoDelGancho.Retornando && collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			EsferaScript component4 = collision.gameObject.GetComponent<EsferaScript>();
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && !component4.EsDeMiEquipo())
			{
				component4.DireccionEsferaNormal(base.transform.forward);
			}
			else if (!component4.fantasmal && component4.GetTipoEscudo() == Bola.TipoEscudo.nunguno && !component4.dividiendo && component4.Divide(null, 400))
			{
				heDestruidoEsferaAlSerLanzado = true;
			}
		}
	}

	public void JumpTo(GameObject objetivo, float fuerza)
	{
		if (fuerza == 0f)
		{
			fuerza = fuerzaSalto;
		}
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		rb.velocity = Vector3.zero;
		try
		{
			Vector3 normalized = (objetivo.transform.position - base.transform.position).normalized;
			normalized += new Vector3(0f, 0.5f, 0f);
		}
		catch
		{
		}
		rb.AddForce(dir * fuerza, ForceMode.Impulse);
	}

	public void SaltarAPlayer()
	{
		JumpTo(player, fuerzaSalto / 2f);
		CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
	}

	public void RebotarGancho()
	{
		ChocadoPelota = true;
		JumpTo(player, fuerzaSalto / 2f);
		CambiarEstadoGancho(EstadoDelGancho.PuedeRetornar);
	}

	public void DesactivarCadenas()
	{
		lineRendererEntreArmas.enabled = false;
	}

	public void ActivarCadenas()
	{
		lineRendererEntreArmas.enabled = true;
	}

	private void CargarClipsAudio()
	{
		audioClipsWeapon[0] = Resources.Load<AudioClip>("EfectosSonido/golpear_gancho");
		audioClipsWeapon[1] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsWeapon[2] = Resources.Load<AudioClip>("EfectosSonido/tranformar_pistola_gancho");
		audioClipsWeapon[3] = Resources.Load<AudioClip>("EfectosSonido/transformar_pistola_gancho_rapido");
	}

	public void PonerAudioEnAudioSource(ClipsAudioGancho clipAudio)
	{
		if (audioClipsWeapon == null || audioClipsWeapon.Length == 0 || audioClipsWeapon[0] == null)
		{
			CargarClipsAudio();
		}
		AudioClip audioClip = audioClipsWeapon[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Weapon.cs " + clipAudio);
			return;
		}
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		audioSource.clip = audioClip;
		audioSource.Play();
	}

	private IEnumerator EliminarPelotaDeLista(GameObject pelota)
	{
		yield return new WaitForSeconds(2f);
		pelotasEliminadas.Remove(pelota);
	}

	public void Apagar()
	{
		base.transform.SetParent(rifle.padreGanchos);
		base.transform.localPosition = Vector3.zero;
		base.transform.localEulerAngles = Vector3.zero;
		coliderGancho.SetActive(value: false);
		base.gameObject.SetActive(value: false);
	}

	public void Encender()
	{
		rb.isKinematic = true;
		rifle.PonerQuitarFantasmalGancho(activar: false, derecha);
		GetComponent<EfectoDesaparecer>().Aparecer();
		TransformPistolToHook();
		coliderGancho.SetActive(value: true);
		PonerAudioEnAudioSource(ClipsAudioGancho.TransformarAGancho);
		inclinacionParaAnimacionGanchoQueVaDe0A1 = 0f;
		CambiarEstadoGancho(EstadoDelGancho.EnRifle);
	}

	public void LanzarGancho()
	{
		base.transform.parent = null;
		rb.isKinematic = false;
		rb.useGravity = false;
		rb.velocity = Vector3.zero;
		direccionLanzamiento = rifle.PunteroFixParaCorregirDisparo.transform.forward * 5f;
		TimeManager.GetInstance().ticksConTiempoNormalForzado = 15;
		rifle.miMano.PonerAudioEnAudioSource(ControladorMano.ClipsAudioMano.Lanzar);
		CambiarEstadoGancho(EstadoDelGancho.Lanzandose);
	}

	public void RecogerGancho()
	{
		if (estadoDelGancho != EstadoDelGancho.EnRifle && estadoAntiguoDelGancho != 0)
		{
			Atraer();
			CambiarEstadoGancho(EstadoDelGancho.Retornando);
		}
		else
		{
			TransformHookToPistol();
			PonerAudioEnAudioSource(ClipsAudioGancho.TransformarAGancho);
			if ((bool)this && (bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				StartCoroutine(ApagarEnUnosSegundos());
			}
		}
		bloque = null;
		armaEstaEnBloque = false;
		armaAncladaABloque = false;
		rb.interpolation = RigidbodyInterpolation.Interpolate;
	}

	public void Atraer(bool escudo = false)
	{
		rifle.estadoArmaOnline = Rifle.EstadoArmaOnline.RecogiendoGanchos;
		if (!rifle.nivelIniciado)
		{
			return;
		}
		TransformHookToPistol();
		ChocadoPelota = false;
		if (armaEstaEnPared)
		{
			armaEstaEnPared = false;
		}
		if (armaEstaEnBloque)
		{
			if (bloque.isEscudo)
			{
				bloque.GetComponent<SphereCollider>().isTrigger = false;
				otroGancho.armaEstaEnBloque = false;
			}
			else
			{
				bloque.GetComponent<BoxCollider>().isTrigger = false;
				bloque.transform.parent = null;
			}
			armaEstaEnBloque = false;
			bloque.pistolaAnclada = false;
			bloque = null;
		}
		if (rb.useGravity)
		{
			rb.useGravity = false;
		}
		TimeManager.GetInstance().MakeTimeNormal(condicion: true);
		if (!escudo)
		{
			TimeManager.GetInstance().ticksConTiempoNormalForzado = 20;
		}
		rb.isKinematic = false;
		rb.velocity = Vector3.zero;
		_ = base.transform.position - rifle.transform.position;
	}

	private IEnumerator ApagarEnUnosSegundos()
	{
		yield return new WaitForSeconds(0.9f);
		if ((bool)this && (bool)base.gameObject)
		{
			base.gameObject.SetActive(value: false);
		}
		rifle.estadoArmaOnline = Rifle.EstadoArmaOnline.Disparos;
	}

	public void TransformHookToPistol()
	{
		if (!animWeapon)
		{
			animWeapon = base.transform.GetChild(0).GetComponent<Animator>();
		}
		animWeapon.SetBool("Extender", value: false);
	}

	public void TransformPistolToHook()
	{
		if (!animWeapon)
		{
			animWeapon = base.transform.GetChild(0).GetComponent<Animator>();
		}
		animWeapon.SetBool("Extender", value: true);
	}

	public void CambiarEstadoGancho(EstadoDelGancho estadoNuevo)
	{
		if ((estadoNuevo == EstadoDelGancho.EnRifle || estadoNuevo == EstadoDelGancho.Deasactivado) && (estadoAntiguoDelGancho == EstadoDelGancho.Lanzandose || estadoAntiguoDelGancho == EstadoDelGancho.Retornando || estadoAntiguoDelGancho == EstadoDelGancho.PuedeRetornar))
		{
			if (!heDestruidoEsferaAlSerLanzado)
			{
				GameManager.instance.m_salaManager.ResetearRacha();
			}
			heDestruidoEsferaAlSerLanzado = false;
		}
		if ((estadoNuevo == EstadoDelGancho.Lanzandose || estadoNuevo == EstadoDelGancho.Retornando || estadoNuevo == EstadoDelGancho.PuedeRetornar) && estadoAntiguoDelGancho != 0)
		{
			_ = estadoAntiguoDelGancho;
			_ = 1;
		}
		switch (estadoNuevo)
		{
		case EstadoDelGancho.Deasactivado:
			Apagar();
			break;
		case EstadoDelGancho.EnRifle:
			if ((bool)puntoCadena)
			{
				puntoCadena.localPosition = new Vector3(0.005f, -0.016f, 0.075f);
			}
			break;
		case EstadoDelGancho.Lanzandose:
			if ((bool)puntoCadena)
			{
				puntoCadena.localPosition = new Vector3(0.005f, -0.016f, -0.156f);
			}
			rb.useGravity = false;
			break;
		case EstadoDelGancho.PuedeRetornar:
			rb.useGravity = true;
			break;
		case EstadoDelGancho.Retornando:
			rb.useGravity = false;
			TransformHookToPistol();
			break;
		}
		estadoDelGancho = estadoNuevo;
		estadoAntiguoDelGancho = estadoDelGancho;
	}
}
public class ParedPistola : MonoBehaviour
{
	public enum ClipsAudioTorreta
	{
		Disparo,
		TransformarOn,
		TransformarOff,
		Cont
	}

	public int nivelTorreta = 1;

	public GameObject[] torretasAnimacion;

	public GameObject[] torretasDisparo;

	public Animator[] animTorretas;

	public Transform[] baseTorreta;

	public Transform[] canonTorreta;

	public Transform[] cannonShot;

	public Material luzEstandar;

	public Material luzDespliege;

	public MeshRenderer meshLuz;

	private bool activado;

	public GameObject pistola;

	public GameObject pared;

	private MeshRenderer meshRenderer;

	private bool disparo;

	private Transform player;

	public Transform[] disparoSpawn;

	public Transform[] disparoSpawn1;

	public Transform[] disparoSpawn2;

	public Transform[] disparoSpawn3;

	private int vecesDisparado;

	private float tiempoEnEjecucionParaDisparo;

	private Vector3 posInicio;

	private AudioClip[] audioClipsTorreta = new AudioClip[3];

	public AudioSource audioSoruceTorreta;

	private bool animacionAparecerFinalizada;

	public MeshRenderer[] meshesMatStage;

	private bool puedoDisparar = true;

	private bool desactivadaPorMuerte;

	private float esperaEntreDisparos = 2f;

	private Transform ultimoTarget;

	private int equipoUltimoTarget = 1;

	public bool activadoAntesDeInicio;

	private Coroutine desactivar;

	private Coroutine disparando;

	private bool enRotacionDeCanon;

	private bool desactivandoTorreta;

	private void Start()
	{
		if ((bool)GameManager.instance.m_salaManager.matNivel)
		{
			for (int i = 0; i < meshesMatStage.Length; i++)
			{
				Material[] materials = meshesMatStage[i].materials;
				for (int j = 0; j < materials.Length; j++)
				{
					materials[j] = GameManager.instance.m_salaManager.matNivel;
				}
				meshesMatStage[i].materials = materials;
			}
		}
		vecesDisparado = 0;
		audioSoruceTorreta = GetComponent<AudioSource>();
		disparo = false;
		player = GameManager.instance.player.cabeza.transform;
		activado = false;
		meshRenderer = pared.GetComponent<MeshRenderer>();
		CargarClipsAudio();
		torretasAnimacion[nivelTorreta - 1].transform.parent.gameObject.SetActive(value: false);
		torretasDisparo[nivelTorreta - 1].SetActive(value: false);
		switch (nivelTorreta)
		{
		case 1:
			disparoSpawn = disparoSpawn1;
			break;
		case 2:
			disparoSpawn = disparoSpawn2;
			break;
		case 3:
			disparoSpawn = disparoSpawn3;
			break;
		}
		posInicio = base.transform.forward * -1f;
	}

	public void Resetear()
	{
		vecesDisparado = 0;
		disparo = false;
		activado = false;
		Desactivar();
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !collision.gameObject.CompareTag(GameManager.instance.tagPistola) && !collision.gameObject.CompareTag(GameManager.instance.tagPistolaGanchoOnline))
		{
			return;
		}
		int idPhotonTarget = GameManager.instance.player.photonView.ViewID;
		if (collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			if (collision.gameObject.GetComponent<SyncPelota>().tipoEsferaSegunRed == Bola.TipoEsfera.azul || collision.gameObject.GetComponent<SyncPelota>().tipoEsferaSegunRed == Bola.TipoEsfera.azulFantasmal)
			{
				foreach (int key in PartidaSync.instance.jugadores.Keys)
				{
					if (PartidaSync.instance.jugadores[key].equipo == 2)
					{
						idPhotonTarget = PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer;
						break;
					}
				}
			}
		}
		else
		{
			SyncJugadores component = collision.transform.root.GetComponent<SyncJugadores>();
			AnimTransformPistola component2 = collision.transform.root.GetComponent<AnimTransformPistola>();
			if ((bool)component)
			{
				idPhotonTarget = collision.transform.root.GetComponent<SyncJugadores>().photonView.ViewID;
			}
			else if ((bool)component2)
			{
				idPhotonTarget = component2.idPlayer;
			}
			else
			{
				collision.transform.root.GetComponent<GanchoRifle>();
			}
		}
		Activar(idPhotonTarget);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			_ = GameManager.instance.player.photonView.ViewID;
			Activar(other.transform.GetComponent<SyncBala>().idObjPhotonPlayer);
		}
	}

	private void Update()
	{
		if (activadoAntesDeInicio && GameManager.instance.m_salaManager.nivelIniciado)
		{
			Desactivar();
		}
		if (!animacionAparecerFinalizada)
		{
			return;
		}
		if (GameManager.instance.player.muerto && !desactivadaPorMuerte)
		{
			desactivadaPorMuerte = true;
			Desactivar();
		}
		else if (PhotonNetwork.IsMasterClient && activado && GameManager.instance.m_salaManager.nivelIniciado)
		{
			if (tiempoEnEjecucionParaDisparo < 100f)
			{
				float tiempoDeEquipo = TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget);
				tiempoEnEjecucionParaDisparo += Time.deltaTime * tiempoDeEquipo;
			}
			if (vecesDisparado == nivelTorreta && !desactivandoTorreta)
			{
				Desactivar();
			}
			if (torretasDisparo[nivelTorreta - 1].activeInHierarchy && !desactivandoTorreta)
			{
				Transform transform = player;
				if ((bool)ultimoTarget)
				{
					transform = ultimoTarget;
				}
				Vector3 forward = transform.transform.position - canonTorreta[nivelTorreta - 1].transform.position;
				float z = forward.z;
				canonTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(canonTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward), TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget) / 10f);
				forward = new Vector3(forward.x, forward.y, z);
				baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z - 90f);
				baseTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(baseTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward), TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget) / 10f);
				baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z + 90f);
			}
			if (desactivandoTorreta)
			{
				Vector3 forward2 = posInicio;
				float z2 = forward2.z;
				canonTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(canonTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward2), TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget) / 10f);
				forward2 = new Vector3(forward2.x, forward2.y, z2);
				baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z - 90f);
				baseTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(baseTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward2), TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget) / 10f);
				baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z + 90f);
			}
			if (vecesDisparado > 0)
			{
				esperaEntreDisparos = 0.4f;
			}
			else
			{
				esperaEntreDisparos = 0.8f;
			}
			if (tiempoEnEjecucionParaDisparo >= esperaEntreDisparos)
			{
				if (puedoDisparar)
				{
					Disparo();
				}
				else
				{
					puedoDisparar = true;
				}
				tiempoEnEjecucionParaDisparo = 0f;
			}
		}
		else if (!PhotonNetwork.IsMasterClient && activado && torretasDisparo[nivelTorreta - 1].activeInHierarchy)
		{
			Transform transform2 = player;
			if ((bool)ultimoTarget)
			{
				transform2 = ultimoTarget;
			}
			Vector3 forward3 = transform2.transform.position - canonTorreta[nivelTorreta - 1].transform.position;
			float z3 = forward3.z;
			canonTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(canonTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward3), 10f * Time.deltaTime);
			forward3 = new Vector3(forward3.x, forward3.y, z3);
			baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z - 90f);
			baseTorreta[nivelTorreta - 1].transform.rotation = Quaternion.Slerp(baseTorreta[nivelTorreta - 1].transform.rotation, Quaternion.LookRotation(forward3), 10f * Time.deltaTime);
			baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, baseTorreta[nivelTorreta - 1].transform.localEulerAngles.z + 90f);
		}
	}

	public void Activar(int idPhotonTarget)
	{
		if (activado)
		{
			return;
		}
		torretasAnimacion[nivelTorreta - 1].transform.parent.gameObject.SetActive(value: true);
		animacionAparecerFinalizada = false;
		desactivandoTorreta = false;
		UnityEngine.Debug.Log("Activamos torreta");
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			float num = 2.1474836E+09f;
			int idPhotonPlayerTarget = idPhotonTarget;
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				if (Vector3.Distance(base.transform.position, PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer).transform.position) < num)
				{
					idPhotonPlayerTarget = PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer;
				}
			}
			GetComponent<SyncTorreta>().HeActivadoUnaTorreta(activar: true, idPhotonPlayerTarget);
		}
		else
		{
			activado = true;
			animTorretas[nivelTorreta - 1].SetBool("activo", value: true);
			PonerAudioEnAudioSource(ClipsAudioTorreta.TransformarOn);
			ultimoTarget = GameManager.instance.player.cabeza.transform;
			torretasAnimacion[nivelTorreta - 1].SetActive(value: true);
			torretasDisparo[nivelTorreta - 1].SetActive(value: false);
			meshLuz.material = luzDespliege;
		}
		tiempoEnEjecucionParaDisparo = 0f;
		puedoDisparar = true;
		if (!GameManager.instance.m_salaManager.nivelIniciado)
		{
			activadoAntesDeInicio = true;
		}
		else
		{
			activadoAntesDeInicio = false;
		}
	}

	public void ActivarTorretaEnOnline(bool activar, Transform target, int nivelTorretaOnline)
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			nivelTorreta = nivelTorretaOnline;
		}
		if (activar)
		{
			if (!activado)
			{
				desactivandoTorreta = false;
				ultimoTarget = target;
				equipoUltimoTarget = target.root.GetComponent<SyncJugadores>().equipo;
				activado = true;
				torretasAnimacion[nivelTorreta - 1].transform.parent.gameObject.SetActive(value: true);
				animTorretas[nivelTorreta - 1].SetBool("activo", value: true);
				PonerAudioEnAudioSource(ClipsAudioTorreta.TransformarOn);
				torretasDisparo[nivelTorreta - 1].SetActive(value: false);
				meshLuz.material = luzDespliege;
			}
		}
		else
		{
			torretasAnimacion[nivelTorreta - 1].SetActive(value: true);
			torretasDisparo[nivelTorreta - 1].SetActive(value: false);
			activado = false;
			animTorretas[nivelTorreta - 1].SetBool("activo", value: false);
			disparo = false;
			vecesDisparado = 0;
			PonerAudioEnAudioSource(ClipsAudioTorreta.TransformarOff);
		}
	}

	public void Desactivar()
	{
		if (!desactivandoTorreta)
		{
			if (desactivar == null)
			{
				desactivar = StartCoroutine(Desactivando());
			}
			if (disparando != null)
			{
				StopCoroutine(disparando);
			}
		}
	}

	private IEnumerator Desactivando()
	{
		enRotacionDeCanon = false;
		puedoDisparar = false;
		yield return new WaitForSeconds(0.5f);
		desactivandoTorreta = true;
		yield return new WaitForSeconds(0.5f);
		animacionAparecerFinalizada = false;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			GetComponent<SyncTorreta>().HeActivadoUnaTorreta(activar: false, -1);
		}
		else
		{
			torretasAnimacion[nivelTorreta - 1].transform.parent.gameObject.SetActive(value: false);
			torretasAnimacion[nivelTorreta - 1].SetActive(value: false);
			torretasDisparo[nivelTorreta - 1].SetActive(value: false);
			canonTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(180f, 0f, 0f);
			baseTorreta[nivelTorreta - 1].transform.localEulerAngles = new Vector3(0f, -180f, -90f);
			cannonShot[nivelTorreta - 1].transform.localEulerAngles = Vector3.zero;
			activado = false;
			animTorretas[nivelTorreta - 1].SetBool("activo", value: false);
			disparo = false;
			vecesDisparado = 0;
			PonerAudioEnAudioSource(ClipsAudioTorreta.TransformarOff);
			enRotacionDeCanon = false;
			puedoDisparar = false;
		}
		activadoAntesDeInicio = false;
		desactivar = null;
		yield return null;
	}

	private void Disparo()
	{
		puedoDisparar = false;
		if (disparando == null)
		{
			disparando = StartCoroutine(Disparar());
		}
	}

	private IEnumerator Disparar()
	{
		enRotacionDeCanon = true;
		int anguloGiro = 110;
		int anguloGiroTotal = 130;
		if (nivelTorreta == 2)
		{
			anguloGiro = 180;
			anguloGiroTotal = 200;
		}
		if (vecesDisparado != 0)
		{
			if (vecesDisparado >= nivelTorreta)
			{
				yield break;
			}
			while (cannonShot[nivelTorreta - 1].localEulerAngles.z < (float)(anguloGiro * vecesDisparado))
			{
				if (vecesDisparado >= nivelTorreta)
				{
					yield break;
				}
				cannonShot[nivelTorreta - 1].localEulerAngles = new Vector3(cannonShot[nivelTorreta - 1].localEulerAngles.x, cannonShot[nivelTorreta - 1].localEulerAngles.y, Mathf.Lerp(cannonShot[nivelTorreta - 1].localEulerAngles.z, anguloGiroTotal * vecesDisparado, TimeManager.GetInstance().GetTiempoDeEquipo(equipoUltimoTarget) / 3f));
				yield return null;
			}
		}
		if ((!GameManager.instance.player.muerto || Config.ModoCooperativo()) && GameManager.instance.m_salaManager.nivelIniciado && enRotacionDeCanon)
		{
			if (!activadoAntesDeInicio)
			{
				Transform transform = disparoSpawn[vecesDisparado];
				tiempoEnEjecucionParaDisparo = 0f;
				PonerAudioEnAudioSource(ClipsAudioTorreta.Disparo);
				GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.BalaTorreta, transform.position, Quaternion.identity, null, equipoUltimoTarget);
				obj.GetComponent<SyncBala>().idObjPhotonPlayer = ultimoTarget.root.GetComponent<PhotonView>().ViewID;
				obj.GetComponent<BalaEsfera>().CambiarTarget(ultimoTarget);
				vecesDisparado++;
			}
			enRotacionDeCanon = false;
			disparando = null;
		}
	}

	private void CargarClipsAudio()
	{
		audioClipsTorreta[0] = Resources.Load<AudioClip>("EfectosSonido/disparo_torreta");
		audioClipsTorreta[1] = Resources.Load<AudioClip>("EfectosSonido/transformacion_torreta_On");
		audioClipsTorreta[2] = Resources.Load<AudioClip>("EfectosSonido/transformacion_torreta_Off");
	}

	public void PonerAudioEnAudioSource(ClipsAudioTorreta clipAudio)
	{
		AudioClip audioClip = audioClipsTorreta[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Player.cs " + clipAudio);
			return;
		}
		if (!audioSoruceTorreta)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en Player.cs");
			return;
		}
		audioSoruceTorreta.clip = audioClip;
		audioSoruceTorreta.Play();
	}

	public void AnimacionFinalizada()
	{
		if (animacionAparecerFinalizada)
		{
			torretasAnimacion[nivelTorreta - 1].SetActive(value: false);
			torretasDisparo[nivelTorreta - 1].SetActive(value: false);
			torretasAnimacion[nivelTorreta - 1].transform.parent.gameObject.SetActive(value: false);
		}
		else
		{
			torretasAnimacion[nivelTorreta - 1].SetActive(value: false);
			torretasDisparo[nivelTorreta - 1].SetActive(value: true);
		}
		animacionAparecerFinalizada = true;
		meshLuz.material = luzEstandar;
	}
}
public class Rifle : Arma
{
	public enum EstadoPantalla
	{
		Disparos4,
		Disparos3,
		Disparos2,
		Disparos1,
		Ganchos2,
		Ganchos1,
		Ganchos0,
		Escopeta,
		Laser,
		Tiempo,
		Inmunidad
	}

	public enum EstadoArma
	{
		SinArma,
		Disparos,
		GanchoD,
		GanchoI,
		Escopeta,
		Laser,
		RecogerGanchos
	}

	public enum EstadoArmaOnline
	{
		SinArma,
		Disparos,
		GanchoD,
		GanchoI,
		Escopeta,
		Laser,
		RecogerGanchos,
		RecogiendoGanchos
	}

	public Transform sensorDebug;

	public GanchoRifle ganchoD;

	public GanchoRifle ganchoI;

	private EstadoArma estadoArma;

	public EstadoArmaOnline estadoArmaOnline;

	private GameObject bala;

	public Transform puntoManoSecundaria;

	public GameObject meshPadre;

	public Transform padreGanchos;

	public MeshRenderer[] rendersRifle;

	public MeshRenderer[] rendersGanchoD;

	public MeshRenderer[] rendersGanchoI;

	[HideInInspector]
	public ControladorManoSecundariaRifle controladorManoSecundariaRifle;

	private void Awake()
	{
		rifleScript = this;
		SetPosIniWeapon();
	}

	public void Start()
	{
		audioSources = base.transform.Find("AudioSources").GetComponents<AudioSource>();
		particulasDisparo = base.transform.Find("Particles").GetComponent<ParticleSystem>();
		particulasDisparo2 = base.transform.Find("Particles2").GetComponent<ParticleSystem>();
		coliderPistola = base.transform.Find("PistolaMesh/Pistola").gameObject;
		triggerPistola = base.transform.Find("TriggerPistola").gameObject;
		CargarClipsAudio();
		animPistola = base.transform.GetComponent<Animator>();
		PonerQuitarFantasmal(activar: false);
		pantalla.material.mainTextureScale = new Vector2(1.1f, 1.1f);
	}

	private void Update()
	{
		if (TimeManager.instance.tiempoMuerto)
		{
			if (GameManager.instance.esperandoCojerPowerUp)
			{
				LanzarRaycastPistolaParaSaberSiDaraAlPowerUp();
			}
		}
		else
		{
			ticksDesdeUltimoDisparo++;
		}
	}

	private void LanzarRaycastPistolaParaSaberSiDaraAlPowerUp()
	{
		Ray ray = new Ray(PunteroFixParaCorregirDisparo.transform.position, base.transform.forward * 50f);
		UnityEngine.Debug.DrawRay(PunteroFixParaCorregirDisparo.transform.position, base.transform.forward * 50f);
		if (Physics.Raycast(ray, out var hitInfo, 50f) && hitInfo.transform.gameObject.name.Contains("PowerUp") && nivelIniciado && miMano.bTriggerUp)
		{
			GameManager.instance.player.QuitarTutoPowerup();
			puedeDisparar = true;
			Disparo();
			PartidaSync.instance.QuitarTutoPowerUp();
		}
	}

	public override void Disparo()
	{
		if (GameManager.instance.player.zonaOscuraActivada || !puedeDisparar || !nivelIniciado || TimeManager.instance.tiempoMuerto || GameManager.instance.player.muerto || ganchoD.estadoDelGancho == GanchoRifle.EstadoDelGancho.Retornando || ganchoI.estadoDelGancho == GanchoRifle.EstadoDelGancho.Retornando || estadoArma == EstadoArma.SinArma)
		{
			return;
		}
		puedeDisparar = false;
		ClipsAudioWeapon clipsAudioWeapon = ClipsAudioWeapon.Disparar;
		switch (estadoArma)
		{
		case EstadoArma.Disparos:
		{
			if ((float)ticksDesdeUltimoDisparo < cadenciaNormal)
			{
				return;
			}
			clipsAudioWeapon = ClipsAudioWeapon.Disparar;
			municion--;
			if (UnityEngine.Random.Range(0, 2) == 0)
			{
				particulasDisparo.transform.parent = PunteroFixParaCorregirDisparo.transform;
				particulasDisparo.transform.localEulerAngles = Vector3.zero;
				particulasDisparo.transform.position = PunteroFixParaCorregirDisparo.transform.position;
				particulasDisparo.Play();
				particulasDisparo.transform.parent = null;
			}
			else
			{
				particulasDisparo2.transform.parent = PunteroFixParaCorregirDisparo.transform;
				particulasDisparo2.transform.localEulerAngles = Vector3.zero;
				particulasDisparo2.transform.position = PunteroFixParaCorregirDisparo.transform.position;
				particulasDisparo2.Play();
				particulasDisparo2.transform.parent = null;
			}
			if (municion > 0)
			{
				if (municion == 3)
				{
					SetTexturepantalla(EstadoPantalla.Disparos3, enable: true);
				}
				if (municion == 2)
				{
					SetTexturepantalla(EstadoPantalla.Disparos2, enable: true);
				}
				if (municion == 1)
				{
					SetTexturepantalla(EstadoPantalla.Disparos1, enable: true);
				}
			}
			else
			{
				SetTexturepantalla(EstadoPantalla.Disparos4, enable: false);
			}
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
			obj.transform.localScale = Vector3.one * 0.03f;
			obj.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.SetParent(null);
			GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
			SyncBala component = obj.GetComponent<SyncBala>();
			if ((bool)component)
			{
				component.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
				component.numUsos = 1;
				component.ChangeTrail(laser: false);
			}
			Bala component2 = obj.GetComponent<Bala>();
			component2.velocidadSinTrucar = PunteroFixParaCorregirDisparo.transform.forward * 7.5f * 3f;
			component2.trail.Clear();
			component2.trail.enabled = true;
			if (municion <= 0)
			{
				Recargar();
			}
			ticksDesdeUltimoDisparo = 0;
			break;
		}
		case EstadoArma.Escopeta:
		{
			if ((float)ticksDesdeUltimoDisparo < cadenciaEscopeta)
			{
				return;
			}
			clipsAudioWeapon = ClipsAudioWeapon.DisparoEscopeta;
			Vector3 forward = PunteroFixParaCorregirDisparo.transform.forward;
			for (int i = 0; i < 5; i++)
			{
				GameObject obj2 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
				obj2.transform.localScale = Vector3.one * 0.03f;
				obj2.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
				obj2.transform.localEulerAngles = Vector3.zero;
				obj2.transform.SetParent(null);
				GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
				SyncBala component3 = obj2.GetComponent<SyncBala>();
				if ((bool)component3)
				{
					component3.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
					component3.numUsos = 1;
					component3.ChangeTrail(laser: false);
				}
				Vector3 vector = forward;
				Vector2 zero = Vector2.zero;
				if (i != 0)
				{
					zero.x = UnityEngine.Random.Range(0f - anguloDispersion, anguloDispersion);
					zero.y = UnityEngine.Random.Range(0f - anguloDispersion, anguloDispersion);
					vector = Quaternion.AngleAxis(zero.x, PunteroFixParaCorregirDisparo.transform.right) * forward;
					vector += Quaternion.AngleAxis(zero.y, PunteroFixParaCorregirDisparo.transform.up) * forward;
				}
				vector = vector.normalized;
				Bala component4 = obj2.GetComponent<Bala>();
				component4.velocidadSinTrucar = vector * velocidadBalaEscopeta;
				component4.deEscopeta = true;
				component4.trail.Clear();
				component4.trail.enabled = true;
			}
			puedeDisparar = false;
			ticksDesdeUltimoDisparo = 0;
			break;
		}
		case EstadoArma.Laser:
		{
			if ((float)ticksDesdeUltimoDisparo < cadenciaLaser)
			{
				return;
			}
			clipsAudioWeapon = ClipsAudioWeapon.DisparoLaser;
			GameObject obj3 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
			obj3.transform.localScale = Vector3.one * 0.09f;
			obj3.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
			obj3.transform.localEulerAngles = Vector3.zero;
			obj3.transform.SetParent(null);
			GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
			SyncBala component5 = obj3.GetComponent<SyncBala>();
			if ((bool)component5)
			{
				component5.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
				component5.numUsos = 2;
				component5.ChangeTrail(laser: true);
			}
			Bala component6 = obj3.GetComponent<Bala>();
			component6.velocidadSinTrucar = PunteroFixParaCorregirDisparo.transform.forward * 7.5f * 3f;
			component6.trail.Clear();
			component6.trail.enabled = true;
			ticksDesdeUltimoDisparo = 0;
			puedeDisparar = true;
			break;
		}
		case EstadoArma.GanchoD:
			clipsAudioWeapon = ClipsAudioWeapon.DispararGancho;
			ganchoD.LanzarGancho();
			GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
			CambiarEstadoArma(EstadoArma.GanchoI);
			break;
		case EstadoArma.GanchoI:
			clipsAudioWeapon = ClipsAudioWeapon.DispararGancho;
			ganchoI.LanzarGancho();
			GameManager.instance.player.Vibra(Player.TipoVibracion.lanzarGancho, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
			CambiarEstadoArma(EstadoArma.RecogerGanchos);
			break;
		case EstadoArma.RecogerGanchos:
			if (ganchoD.armaAncladaABloque || ganchoI.armaAncladaABloque)
			{
				return;
			}
			clipsAudioWeapon = ClipsAudioWeapon.Cont;
			GameManager.instance.player.Vibra(Player.TipoVibracion.cogerPistolas, miMano.mano == ControladorMano.Mano.Derecha, (bool)controladorManoSecundariaRifle && controladorManoSecundariaRifle.anclada);
			CambiarEstadoArma(EstadoArma.Disparos);
			break;
		}
		TimeManager.GetInstance().ticksConTiempoNormalForzado = 15;
		if (clipsAudioWeapon != ClipsAudioWeapon.Cont)
		{
			PonerAudioEnAudioSource(clipsAudioWeapon);
		}
	}

	public override void PonerPosicionInicial()
	{
		puedeDisparar = false;
		municion = municionMaxNormal;
		base.transform.parent = padreInicio;
		base.transform.localPosition = transformInicial;
		base.transform.localRotation = rotacionInicial;
		nivelIniciado = false;
		pantalla.gameObject.SetActive(value: false);
		meshPadre.SetActive(value: false);
		ganchoD.gameObject.SetActive(value: false);
		ganchoI.gameObject.SetActive(value: false);
		triggerPistola.SetActive(value: false);
	}

	private void CargarClipsAudio()
	{
		audioClipsWeapon[0] = Resources.Load<AudioClip>("EfectosSonido/disparo");
		audioClipsWeapon[2] = Resources.Load<AudioClip>("EfectosSonido/InicioPowerup");
		audioClipsWeapon[3] = Resources.Load<AudioClip>("EfectosSonido/FinalPowerup");
		audioClipsWeapon[4] = Resources.Load<AudioClip>("EfectosSonido/disparoEscopeta");
		audioClipsWeapon[5] = Resources.Load<AudioClip>("EfectosSonido/disparoLaser");
		audioClipsWeapon[7] = Resources.Load<AudioClip>("EfectosSonido/recoger_gancho");
		audioClipsWeapon[8] = Resources.Load<AudioClip>("EfectosSonido/disparar_gancho");
		audioClipsWeapon[9] = Resources.Load<AudioClip>("EfectosSonido/recargar");
	}

	public void PonerAudioEnAudioSource(ClipsAudioWeapon clipAudio)
	{
		AudioClip audioClip = audioClipsWeapon[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Weapon.cs " + clipAudio);
			return;
		}
		int num = 0;
		if (audioSources != null)
		{
			num = audioSources.Length;
		}
		if (num == 0)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en Weapon.cs");
			return;
		}
		int num2 = 0;
		while (audioSources[num2].isPlaying)
		{
			num2++;
			if (num2 >= audioSources.Length)
			{
				num2 = 0;
				audioSources[num2].Stop();
			}
		}
		if (num2 < 999)
		{
			audioSources[num2].clip = audioClip;
			audioSources[num2].Play();
		}
	}

	public void EncenderGancho(bool derecho)
	{
		GanchoRifle obj = (derecho ? ganchoD : ganchoI);
		obj.transform.SetParent(padreGanchos);
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localEulerAngles = Vector3.zero;
		obj.Encender();
	}

	public void ApagarGancho()
	{
		ganchoD.Apagar();
	}

	public void EncenderRifle()
	{
		if ((bool)controladorManoSecundariaRifle)
		{
			controladorManoSecundariaRifle.Anclar(valor: false);
		}
		meshPadre.SetActive(value: true);
		GetComponent<EfectoDesaparecer>().Aparecer();
		triggerPistola.SetActive(value: true);
		coliderPistola.SetActive(value: true);
		CambiarEstadoArma(EstadoArma.Disparos);
		ganchoD.CambiarEstadoGancho(GanchoRifle.EstadoDelGancho.Deasactivado);
		ganchoI.CambiarEstadoGancho(GanchoRifle.EstadoDelGancho.Deasactivado);
	}

	public void ApagarRifle(bool desvanecer = true)
	{
		if ((bool)controladorManoSecundariaRifle)
		{
			controladorManoSecundariaRifle.Anclar(valor: false);
		}
		if (desvanecer)
		{
			GetComponent<EfectoDesaparecer>().Desaparecer();
		}
		else
		{
			meshPadre.SetActive(value: false);
		}
		coliderPistola.SetActive(value: false);
		ganchoD.CambiarEstadoGancho(GanchoRifle.EstadoDelGancho.Deasactivado);
		ganchoI.CambiarEstadoGancho(GanchoRifle.EstadoDelGancho.Deasactivado);
	}

	public void MostrarRifle()
	{
		EncenderRifle();
	}

	public EstadoArma GetEstadoArma()
	{
		return estadoArma;
	}

	public void CambiarEstadoArma(EstadoArma nuevoEstado)
	{
		switch (nuevoEstado)
		{
		case EstadoArma.Disparos:
			municion = municionMaxNormal;
			SetTexturepantalla(EstadoPantalla.Disparos4, enable: true);
			if (estadoArma == EstadoArma.Escopeta || estadoArma == EstadoArma.Laser)
			{
				PonerAudioEnAudioSource(ClipsAudioWeapon.FinPowerup);
			}
			textoTiempoArma.gameObject.SetActive(value: false);
			laser.SetActive(value: false);
			pantalla.gameObject.SetActive(value: true);
			RecogerGanchos();
			break;
		case EstadoArma.Escopeta:
			municion = municionMaxEscopeta;
			if (devolverALaNormalidadCor != null)
			{
				StopCoroutine(devolverALaNormalidadCor);
			}
			PonerAudioEnAudioSource(ClipsAudioWeapon.InicioPowerup);
			municion = municionMaxEscopeta;
			textoTiempoArma.gameObject.SetActive(value: true);
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				devolverALaNormalidadCor = StartCoroutine(DevolverALaNormalidad(7f));
			}
			SetTexturepantalla(EstadoPantalla.Escopeta, enable: true);
			laser.SetActive(value: false);
			RecogerGanchos();
			break;
		case EstadoArma.Laser:
			municion = municionMaxLaser;
			if (devolverALaNormalidadCor != null)
			{
				StopCoroutine(devolverALaNormalidadCor);
			}
			PonerAudioEnAudioSource(ClipsAudioWeapon.InicioPowerup);
			municion = municionMaxLaser;
			textoTiempoArma.gameObject.SetActive(value: true);
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				devolverALaNormalidadCor = StartCoroutine(DevolverALaNormalidad(7f));
			}
			SetTexturepantalla(EstadoPantalla.Laser, enable: true);
			laser.SetActive(value: true);
			RecogerGanchos();
			break;
		case EstadoArma.GanchoD:
			EncenderGancho(derecho: true);
			ganchoD.controladorCadena.m_line.enabled = false;
			SetTexturepantalla(EstadoPantalla.Ganchos2, enable: true);
			break;
		case EstadoArma.GanchoI:
			EncenderGancho(derecho: false);
			ganchoD.controladorCadena.Aparecer();
			SetTexturepantalla(EstadoPantalla.Ganchos1, enable: true);
			break;
		case EstadoArma.RecogerGanchos:
			SetTexturepantalla(EstadoPantalla.Ganchos0, enable: true);
			break;
		}
		estadoArma = nuevoEstado;
		if (estadoArmaOnline != EstadoArmaOnline.RecogiendoGanchos)
		{
			estadoArmaOnline = (EstadoArmaOnline)nuevoEstado;
		}
	}

	private IEnumerator DevolverALaNormalidad(float tiempo)
	{
		int cont = (int)tiempo;
		do
		{
			textoTiempoArma.text = "00:0" + cont;
			cont--;
			yield return new WaitForSeconds(1f);
		}
		while (cont > 0);
		if (GameManager.instance.powerUpShotgunActivo)
		{
			GameManager.instance.powerUpShotgunActivo = false;
			GameManager.instance.numEsferasMientrasPWShotgun = 0;
		}
		if (GameManager.instance.powerUpLaserActivo)
		{
			GameManager.instance.powerUpLaserActivo = false;
			GameManager.instance.numEsferasMientrasPWLaser = 0;
		}
		CambiarEstadoArma(EstadoArma.Disparos);
	}

	public void RecogerGanchos()
	{
		bool flag = false;
		if (ganchoD.estadoDelGancho != 0)
		{
			ganchoD.RecogerGancho();
			flag = true;
		}
		if (ganchoI.estadoDelGancho != 0)
		{
			ganchoI.RecogerGancho();
			flag = true;
		}
		if (flag)
		{
			PonerAudioEnAudioSource(ClipsAudioWeapon.Atraer);
		}
	}

	public void PonerQuitarFantasmal(bool activar)
	{
		armaEnFantasmal = activar;
		int num = (activar ? 1 : 0);
		for (int i = 0; i < rendersRifle.Length; i++)
		{
			rendersRifle[i].material = materiales[num];
		}
		PonerQuitarFantasmalGancho(activar, ganchoDerecho: true);
		PonerQuitarFantasmalGancho(activar, ganchoDerecho: false);
	}

	public void PonerQuitarFantasmalGancho(bool activar, bool ganchoDerecho)
	{
		int num = (activar ? 1 : 2);
		MeshRenderer[] array = (ganchoDerecho ? rendersGanchoD : rendersGanchoI);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].material = materiales[num];
		}
		if (ganchoDerecho)
		{
			ganchoD.armaEnFantasmal = activar;
		}
		else
		{
			ganchoI.armaEnFantasmal = activar;
		}
	}

	public void SetTexturepantalla(EstadoPantalla estado, bool enable)
	{
		if (!enable)
		{
			pantalla.enabled = false;
			pantalla.gameObject.SetActive(value: false);
			return;
		}
		Vector2 value = Vector2.zero;
		switch (estado)
		{
		case EstadoPantalla.Disparos1:
			value = new Vector2(0.33f, 0.281f);
			break;
		case EstadoPantalla.Disparos2:
			value = new Vector2(0.33f, 0.357f);
			break;
		case EstadoPantalla.Disparos3:
			value = new Vector2(0.238f, 0.357f);
			break;
		case EstadoPantalla.Disparos4:
			value = new Vector2(0.147f, 0.357f);
			break;
		case EstadoPantalla.Escopeta:
			value = new Vector2(0.148f, 0.203f);
			break;
		case EstadoPantalla.Ganchos2:
			value = new Vector2(0.332f, 0.203f);
			break;
		case EstadoPantalla.Ganchos1:
			value = new Vector2(0.118f, -0.148f);
			break;
		case EstadoPantalla.Ganchos0:
			value = new Vector2(0.208f, -0.148f);
			break;
		case EstadoPantalla.Laser:
			value = new Vector2(0.238f, 0.203f);
			break;
		case EstadoPantalla.Tiempo:
			value = new Vector2(0.238f, 0.281f);
			break;
		case EstadoPantalla.Inmunidad:
			value = new Vector2(0.147f, 0.281f);
			break;
		}
		pantalla.material.SetTextureOffset("_MainTex", value);
		pantalla.enabled = true;
		pantalla.gameObject.SetActive(value: true);
	}
}
public class TorretaDummy : MonoBehaviour
{
	public int nivelTorreta = 1;
}
public class TriggerFinalAnimacionTorreta : MonoBehaviour
{
	public ParedPistola torreta;

	public void AnimacionFinalizada()
	{
		torreta.AnimacionFinalizada();
	}

	private void OnEnable()
	{
		GameManager.instance.torretasEncendidas.Add(base.gameObject);
		GetComponent<EfectoDesaparecer>().Aparecer();
	}

	private void OnDisable()
	{
		GameManager.instance.torretasEncendidas.Remove(base.gameObject);
	}
}
public class Weapon : Arma
{
	public enum TipoDeArma
	{
		Normal,
		Escopeta,
		Laser
	}

	public float tiempoDispario;

	public Material materialPantalla;

	private float radioSpherecastCadena_SoloValeEnArmaDerecha = 0.075f;

	private TipoDeArma tipoDeArma;

	[HideInInspector]
	public bool disparo;

	public GameObject bala;

	public GameObject balaEscopeta;

	public GameObject puntero;

	public GameObject gancho;

	public GameObject pistolaMesh;

	public GameObject balaDorada;

	[HideInInspector]
	public BloqueRompible bloque;

	private Vector3 dir;

	public float inclinacionParaAnimacionGanchoQueVaDe0A1;

	public Weapon otraPistola;

	[HideInInspector]
	public GameObject player;

	public Rigidbody rb;

	private float distanciaInicial;

	private AnimManos animManos;

	private AnimDoorsUp animDoors;

	private AnimDoorsDown animDoors2;

	public ControladorCadena controladorCadena;

	private GameObject llavePuerta;

	public GameObject puntoFinalFix;

	public Transform puntoUnionCadena;

	private int layerMask = 33555456;

	public GameObject coliderGancho;

	public GameObject pandreColiders;

	public Collider col1;

	public Collider col2;

	private List<GameObject> pelotasEliminadas = new List<GameObject>();

	private bool cochandoConEsfera;

	private Vector3 inicio;

	private Vector3 final;

	private void Awake()
	{
		weaponScript = this;
		base.transform.tag = "Untagged";
		SetPosIniWeapon();
	}

	private void Start()
	{
		audioSources = base.transform.Find("AudioSources").GetComponents<AudioSource>();
		animPistola = base.transform.GetComponent<Animator>();
		meshArma.material = materiales[0];
		armaEnFantasmal = false;
		llavePuerta = GameObject.FindGameObjectWithTag("LlavePuerta");
		if (!controladorCadena)
		{
			controladorCadena = UnityEngine.Object.FindObjectOfType<ControladorCadena>();
		}
		animDoors = UnityEngine.Object.FindObjectOfType<AnimDoorsUp>();
		animDoors2 = UnityEngine.Object.FindObjectOfType<AnimDoorsDown>();
		CambiarTipoDeArma(TipoDeArma.Normal);
		ChocadoPelota = false;
		armaAncladaABloque = false;
		rb = GetComponent<Rigidbody>();
		rb.interpolation = RigidbodyInterpolation.Interpolate;
		armaEstaEnBloque = false;
		armaEstaEnPared = false;
		if (!base.transform.CompareTag(GameManager.instance.tagPistola))
		{
			base.transform.tag = "Pistola";
		}
		player = GameObject.FindGameObjectWithTag("Player");
		puedeDisparar = false;
		pantalla.material = materialPantalla;
		rb.isKinematic = true;
		nivelIniciado = false;
		coliderPistola = base.transform.Find("PistolaMesh/Pistola").gameObject;
		triggerPistola = base.transform.Find("TriggerPistola").gameObject;
		coliderGancho = base.transform.Find("PistolaMesh/Gancho").gameObject;
		pandreColiders = coliderGancho.transform.parent.gameObject;
		coliderGancho.SetActive(value: false);
		if (TimeManager.GetInstance().testInicioDesactivado)
		{
			nivelIniciado = true;
		}
		CargarClipsAudio();
		layerMask = (1 << GameManager.instance.layerEsfera) | (1 << GameManager.instance.layerMina) | 0x200000;
		particulasDisparo = base.transform.Find("Particles").GetComponent<ParticleSystem>();
		particulasDisparo2 = base.transform.Find("Particles2").GetComponent<ParticleSystem>();
	}

	private void Update()
	{
		if (TimeManager.instance.tiempoMuerto)
		{
			if (GameManager.instance.esperandoCojerPowerUp)
			{
				LanzarRaycastPistolaParaSaberSiDaraAlPowerUp();
			}
			return;
		}
		ticksDesdeUltimoDisparo++;
		if (miMano.mano == ControladorMano.Mano.Izquierda || !controladorCadena.m_line.enabled)
		{
			return;
		}
		inicio = controladorCadena.m_line.transform.position;
		final = inicio + (controladorCadena.puntoFinal.transform.position - inicio);
		Vector3 direction = controladorCadena.puntoFinal.transform.position - inicio;
		float maxDistance = Vector3.Distance(final, inicio);
		if (Physics.SphereCast(inicio, radioSpherecastCadena_SoloValeEnArmaDerecha, direction, out var hitInfo, maxDistance, layerMask))
		{
			if (hitInfo.transform.tag == "Esfera")
			{
				EsferaScript component = hitInfo.transform.gameObject.GetComponent<EsferaScript>();
				if ((bool)component)
				{
					if (cochandoConEsfera)
					{
						component.tiempoVida = 0f;
					}
					if (!component.fantasmal)
					{
						if (!component.escudoDestruido && component.GetTipoEscudo() == Bola.TipoEscudo.laser)
						{
							cochandoConEsfera = true;
							component.GolpeoEscudo();
						}
						else if (!component.EsDeMiEquipo())
						{
							component.DireccionEsferaNormal(base.transform.forward);
						}
						else if (component.GetTipoEscudo() == Bola.TipoEscudo.nunguno && !component.dividiendo && component.Divide(null, 300))
						{
							GameManager.instance.player.weaponDer.heDestruidoEsferaAlSerLanzado = true;
							GameManager.instance.player.weaponIzq.heDestruidoEsferaAlSerLanzado = true;
						}
					}
					return;
				}
				esferaTorreta component2 = hitInfo.transform.gameObject.GetComponent<esferaTorreta>();
				if (!component2)
				{
					SyncPelota component3 = hitInfo.transform.gameObject.GetComponent<SyncPelota>();
					if (((bool)GameManager.instance.player && GameManager.instance.player.muerto) || (component3.tipoActual != Bola.TipoEsfera.azul && component3.tipoActual != 0 && component3.tipoActual != Bola.TipoEsfera.multiEquipo))
					{
						return;
					}
					if (component3.esferaOnline.EsDeMiEquipo() && component3.esferaOnline.GetTipoEscudo() == Bola.TipoEscudo.nunguno)
					{
						if (!pelotasEliminadas.Contains(hitInfo.transform.gameObject))
						{
							PartidaSync.instance.MasterHeDestruidoUnaEsfera(hitInfo.transform.gameObject.GetComponent<SyncPelota>().GetComponent<PhotonView>().ViewID, PartidaSync.instance.miJugador.idJuego, Vector3.one * -1000f);
							pelotasEliminadas.Add(hitInfo.transform.gameObject);
							GameManager.instance.player.weaponDer.heDestruidoEsferaAlSerLanzado = true;
							GameManager.instance.player.weaponIzq.heDestruidoEsferaAlSerLanzado = true;
							GameManager.instance.m_salaManager.SumarPuntosTotales(300);
							StartCoroutine(EliminarPelotaDeLista(hitInfo.transform.gameObject));
						}
					}
					else if (component3.esferaOnline.GetTipoEscudo() == Bola.TipoEscudo.laser)
					{
						PartidaSync.instance.MasterHeDestruidoUnEscudo(hitInfo.transform.gameObject.GetComponent<PhotonView>().ViewID, PartidaSync.instance.miJugador.idJuego, -1, -1, -1);
					}
				}
				else
				{
					component2.Destruir();
				}
			}
			else if (hitInfo.transform.tag == "Boss")
			{
				BossBase component4 = hitInfo.transform.gameObject.GetComponent<BossBase>();
				if ((bool)component4 && !component4.escudoDestruido && component4.tipoEscudo == Bola.TipoEscudo.laser)
				{
					if (component4.photonView.IsMine)
					{
						component4.GolpearBoss(2);
					}
					else
					{
						component4.GetComponent<SyncBoss>().MasterGolpeoABoss(2);
					}
				}
			}
			else
			{
				cochandoConEsfera = false;
			}
		}
		else
		{
			cochandoConEsfera = false;
		}
	}

	private void LanzarRaycastPistolaParaSaberSiDaraAlPowerUp()
	{
		if ((bool)PunteroFixParaCorregirDisparo)
		{
			PunteroFixParaCorregirDisparo.transform.position = puntero.transform.position;
			PunteroFixParaCorregirDisparo.transform.rotation = puntero.transform.rotation;
		}
		Ray ray = new Ray(base.transform.position, base.transform.forward * 50f);
		UnityEngine.Debug.DrawRay(base.transform.position, base.transform.forward * 50f);
		if (Physics.Raycast(ray, out var hitInfo, 50f) && hitInfo.transform.gameObject.name.Contains("PowerUp") && nivelIniciado && miMano.bTriggerUp)
		{
			GameManager.instance.player.QuitarTutoPowerup();
			puedeDisparar = true;
			Disparo();
			PartidaSync.instance.QuitarTutoPowerUp();
		}
	}

	private IEnumerator EliminarPelotaDeLista(GameObject pelota)
	{
		yield return new WaitForSeconds(2f);
		pelotasEliminadas.Remove(pelota);
	}

	private void FixedUpdate()
	{
		if ((base.transform.position.y < -10f || base.transform.position.y > 10f || base.transform.position.x > 5f || base.transform.position.x < -5f || base.transform.position.z > 3.6f || base.transform.position.z < -6f) && miMano.estadoDeLaMano != ControladorMano.EstadoDeLaMano.GanchoVolviendo)
		{
			miMano.Atraer();
			miMano.afectandoTiempo = true;
			armaEnFantasmal = true;
			miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoVolviendo);
			bloque = null;
			armaEstaEnBloque = false;
			armaAncladaABloque = false;
			weaponScript.rb.interpolation = RigidbodyInterpolation.Interpolate;
			weaponScript.otraPistola.armaEstaEnBloque = false;
		}
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoLanzandose || miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar)
		{
			pantalla.gameObject.SetActive(value: false);
		}
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoVolviendo)
		{
			col1.enabled = false;
			col2.enabled = false;
			pantalla.gameObject.SetActive(value: false);
		}
		else
		{
			col1.enabled = true;
			col2.enabled = true;
		}
		_ = miMano.armaImpulsandose;
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoLanzandose)
		{
			rb.velocity = miMano.armaImpulsandose * TimeManager.GetInstance().GetTiempoDeEquipo(GameManager.instance.player.miEquipo) * 2f;
		}
		if (!TimeManager.instance.tiempoMuerto)
		{
			_ = miMano.estadoDeLaMano;
			_ = 3;
		}
	}

	private void LateUpdate()
	{
		if (TimeManager.instance.tiempoMuerto)
		{
			return;
		}
		if ((bool)PunteroFixParaCorregirDisparo)
		{
			PunteroFixParaCorregirDisparo.transform.position = puntero.transform.position;
			PunteroFixParaCorregirDisparo.transform.rotation = puntero.transform.rotation;
		}
		if (municion > municionMaxActual)
		{
			municion = municionMaxActual;
		}
		if (armaAncladaABloque)
		{
			if ((bool)otraPistola.bloque && !otraPistola.bloque.isEscudo)
			{
				if (distanciaInicial == 0f)
				{
					distanciaInicial = Vector3.Distance(base.transform.position, otraPistola.transform.position);
				}
				float num = Vector3.Distance(base.transform.position, otraPistola.transform.position);
				if (num > distanciaInicial)
				{
					dir = base.transform.position - otraPistola.transform.position;
					dir = dir.normalized;
					Rigidbody component = otraPistola.GetComponent<Rigidbody>();
					component.isKinematic = false;
					component.useGravity = false;
					component.AddForce(dir * 100f * (num - distanciaInicial), ForceMode.Impulse);
					dir = Vector3.zero;
				}
				if (Vector3.Distance(otraPistola.bloque.transform.position, otraPistola.bloque.posInicial) > 0.5f)
				{
					otraPistola.bloque.Romper();
					otraPistola.heDestruidoEsferaAlSerLanzado = true;
					if (!PhotonNetwork.IsMasterClient)
					{
						PartidaSync.instance.MasterHeDestruidoUnEscudo(otraPistola.bloque.bolaPadre.GetComponent<PhotonView>().ViewID, -1, -1, -1, -1);
					}
				}
				distanciaInicial = num;
			}
		}
		else if (distanciaInicial != 0f)
		{
			distanciaInicial = 0f;
		}
		if (miMano.estadoDeLaMano != 0 && miMano.otherHand.estadoDeLaMano != 0)
		{
			controladorCadena.m_line.enabled = true;
			if (miMano.mano == ControladorMano.Mano.Derecha)
			{
				controladorCadena.m_line.transform.position = puntoUnionCadena.position;
			}
			else
			{
				controladorCadena.puntoFinal.transform.position = puntoFinalFix.transform.position;
			}
		}
		else
		{
			controladorCadena.m_line.enabled = false;
		}
		if ((miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar && miMano.otherHand.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar) || (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano && miMano.otherHand.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoEnMano))
		{
			_ = miMano.mano;
		}
		if ((!otraPistola.armaEstaEnPared || !armaEstaEnPared) && otraPistola.armaEstaEnBloque)
		{
			_ = armaEstaEnBloque;
		}
	}

	public void SaltarAPlayer()
	{
		JumpTo(player, fuerzaSalto / 2f);
		miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (TimeManager.instance.tiempoMuerto || !GameManager.instance.m_salaManager.nivelIniciado)
		{
			return;
		}
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoLanzandose)
		{
			municion = municionMaxActual;
			if (collision.gameObject.CompareTag(GameManager.instance.tagEsfera) && !ChocadoPelota)
			{
				ChocadoPelota = true;
				miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				Bola component = collision.gameObject.GetComponent<Bola>();
				if (!component.escudoDestruido && component.GetTipoEscudo() == Bola.TipoEscudo.gancho)
				{
					rb.isKinematic = true;
					rb.velocity = Vector3.zero;
					rb.interpolation = RigidbodyInterpolation.None;
					component.ganchoEnganchado = true;
					component.ganchosWeaponEnganchados.Add(this);
					miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
					PonerAudioEnAudioSource(ClipsAudioWeapon.Golpear);
					armaEstaEnBloque = true;
					bloque = collision.transform.GetChild(3).GetChild(0).gameObject.GetComponent<BloqueRompible>();
					bloque.HacerPadre(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					armaAncladaABloque = true;
				}
				else if (component.tipoEsfera == Bola.TipoEsfera.negra)
				{
					SaltarAPlayer();
					PonerAudioEnAudioSource(ClipsAudioWeapon.Golpear);
				}
				else if (!component.escudoDestruido || component.GetTipoEscudo() != 0)
				{
					SaltarAPlayer();
				}
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagParedMovible))
			{
				SaltarAPlayer();
				miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				PonerAudioEnAudioSource(ClipsAudioWeapon.GolpearErrorEscudo);
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagBoss) && !ChocadoPelota)
			{
				ChocadoPelota = true;
				miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				BossBase component2 = collision.gameObject.GetComponent<BossBase>();
				if (!component2.escudoDestruido && component2.tipoEscudo == Bola.TipoEscudo.gancho)
				{
					SaltarAPlayer();
					rb.isKinematic = true;
					rb.interpolation = RigidbodyInterpolation.None;
					component2.SetGanchoEnganchado(enganchado: true);
					if (collision.gameObject.CompareTag(GameManager.instance.tagPared))
					{
						armaEstaEnPared = true;
					}
					miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
					PonerAudioEnAudioSource(ClipsAudioWeapon.Golpear);
					armaEstaEnBloque = true;
					bloque = collision.gameObject.GetComponentInChildren<BloqueRompible>();
					bloque.HacerPadre(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					armaAncladaABloque = true;
					miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				}
				else if (!component2.escudoDestruido || component2.tipoEscudo != 0)
				{
					SaltarAPlayer();
				}
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagPared) || collision.gameObject.CompareTag(GameManager.instance.tagParedPistola))
			{
				SaltarAPlayer();
				rb.isKinematic = true;
				if (collision.gameObject.CompareTag(GameManager.instance.tagPared))
				{
					armaEstaEnPared = true;
				}
				miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				PonerAudioEnAudioSource(ClipsAudioWeapon.Golpear);
			}
			if (collision.gameObject.CompareTag(GameManager.instance.tagRompible))
			{
				ChocadoPelota = true;
				SaltarAPlayer();
				miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				collision.gameObject.GetComponent<BossBase>();
			}
			if ((bool)collision.gameObject.GetComponent<BloqueRompible>() && bloque == null)
			{
				BloqueRompible component3 = collision.gameObject.GetComponent<BloqueRompible>();
				SaltarAPlayer();
				if (component3.isEscudo)
				{
					armaEstaEnBloque = true;
					bloque = collision.gameObject.GetComponent<BloqueRompible>();
					bloque.HacerHijo(base.gameObject);
					bloque.pistolaAnclada = true;
					heDestruidoEsferaAlSerLanzado = true;
					miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
				}
				else
				{
					heDestruidoEsferaAlSerLanzado = true;
					component3.Romper(base.transform.position.x, base.transform.position.y, base.transform.position.z);
				}
			}
		}
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.PistolaEnMano)
		{
			bool flag = collision.gameObject.CompareTag(GameManager.instance.tagEsfera);
			bool flag2 = collision.gameObject.CompareTag(GameManager.instance.tagParedMovible);
			if (flag || flag2)
			{
				if (flag2 && GameManager.instance.player.GetInmortalidad())
				{
					GameManager.instance.player.QuitarInmortalidad();
				}
				PhotonView photonView = null;
				if (flag)
				{
					photonView = collision.gameObject.GetComponent<PhotonView>();
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, photonView ? photonView.ViewID : (-1));
				GameManager.instance.player.Morir(flag2 ? null : collision.gameObject, forzarMuerte: false, porCabeza: false, miMano.mano == ControladorMano.Mano.Derecha);
			}
			else if (collision.gameObject.CompareTag(GameManager.instance.tagBala) && !Debugs.sinMatarEnCompetitivo)
			{
				PhotonView component4 = collision.gameObject.GetComponent<PhotonView>();
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, component4 ? component4.ViewID : (-1));
				GameManager.instance.player.Morir(collision.gameObject, forzarMuerte: false, porCabeza: false, miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
		if (miMano.estadoDeLaMano == ControladorMano.EstadoDeLaMano.GanchoVolviendo && collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			EsferaScript component5 = collision.gameObject.GetComponent<EsferaScript>();
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && !component5.EsDeMiEquipo())
			{
				component5.DireccionEsferaNormal(base.transform.forward);
			}
			else if (!component5.fantasmal && (component5.escudoDestruido || component5.GetTipoEscudo() != Bola.TipoEscudo.gancho) && component5.GetTipoEscudo() == Bola.TipoEscudo.nunguno && !component5.dividiendo && component5.Divide(null, 400))
			{
				heDestruidoEsferaAlSerLanzado = true;
			}
		}
	}

	public override void Disparo()
	{
		if (GameManager.instance.player.zonaOscuraActivada || !puedeDisparar || !nivelIniciado || !otraPistola.nivelIniciado || municion <= 0 || TimeManager.instance.tiempoMuerto || miMano.estadoDeLaMano != ControladorMano.EstadoDeLaMano.PistolaEnMano)
		{
			return;
		}
		puedeDisparar = false;
		ClipsAudioWeapon clipAudio = ClipsAudioWeapon.Disparar;
		switch (tipoDeArma)
		{
		case TipoDeArma.Normal:
		{
			clipAudio = ClipsAudioWeapon.Disparar;
			municion--;
			if (municion == 2)
			{
				pantalla.gameObject.SetActive(value: true);
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
			}
			else if (municion == 1)
			{
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, 0f));
				particulasDisparo.transform.parent = PunteroFixParaCorregirDisparo.transform;
				particulasDisparo.transform.localEulerAngles = Vector3.zero;
				particulasDisparo.transform.position = PunteroFixParaCorregirDisparo.transform.position;
				particulasDisparo.Play();
				particulasDisparo.transform.parent = null;
			}
			else
			{
				particulasDisparo2.transform.parent = PunteroFixParaCorregirDisparo.transform;
				particulasDisparo2.transform.localEulerAngles = Vector3.zero;
				particulasDisparo2.transform.position = PunteroFixParaCorregirDisparo.transform.position;
				particulasDisparo2.Play();
				particulasDisparo2.transform.parent = null;
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
			}
			GameObject obj3 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
			obj3.transform.localScale = Vector3.one * 0.03f;
			obj3.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
			obj3.transform.localEulerAngles = Vector3.zero;
			obj3.transform.SetParent(null);
			GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha);
			SyncBala component5 = obj3.GetComponent<SyncBala>();
			if ((bool)component5)
			{
				component5.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
				component5.numUsos = 1;
				component5.ChangeTrail(laser: false);
			}
			Bala component6 = obj3.GetComponent<Bala>();
			component6.velocidadSinTrucar = PunteroFixParaCorregirDisparo.transform.forward * 7.5f * 3f;
			component6.trail.Clear();
			component6.trail.enabled = true;
			ticksDesdeUltimoDisparo = 0;
			break;
		}
		case TipoDeArma.Escopeta:
		{
			if ((float)ticksDesdeUltimoDisparo < cadenciaEscopeta)
			{
				return;
			}
			clipAudio = ClipsAudioWeapon.DisparoEscopeta;
			Vector3 forward = PunteroFixParaCorregirDisparo.transform.forward;
			for (int i = 0; i < 5; i++)
			{
				GameObject obj2 = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
				obj2.transform.localScale = Vector3.one * 0.03f;
				obj2.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
				obj2.transform.localEulerAngles = Vector3.zero;
				obj2.transform.SetParent(null);
				GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha);
				SyncBala component3 = obj2.GetComponent<SyncBala>();
				if ((bool)component3)
				{
					component3.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
					component3.numUsos = 1;
					component3.ChangeTrail(laser: false);
				}
				Vector3 vector = forward;
				Vector2 zero = Vector2.zero;
				if (i != 0)
				{
					zero.x = UnityEngine.Random.Range(0f - anguloDispersion, anguloDispersion);
					zero.y = UnityEngine.Random.Range(0f - anguloDispersion, anguloDispersion);
					vector = Quaternion.AngleAxis(zero.x, PunteroFixParaCorregirDisparo.transform.right) * forward;
					vector += Quaternion.AngleAxis(zero.y, PunteroFixParaCorregirDisparo.transform.up) * forward;
				}
				vector = vector.normalized;
				Bala component4 = obj2.GetComponent<Bala>();
				component4.velocidadSinTrucar = vector * velocidadBalaEscopeta;
				component4.deEscopeta = true;
				component4.trail.Clear();
				component4.trail.enabled = true;
			}
			puedeDisparar = true;
			ticksDesdeUltimoDisparo = 0;
			break;
		}
		case TipoDeArma.Laser:
		{
			if ((float)ticksDesdeUltimoDisparo < cadenciaLaser)
			{
				return;
			}
			clipAudio = ClipsAudioWeapon.DisparoLaser;
			GameObject obj = PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.Bala, PunteroFixParaCorregirDisparo.transform.position, PunteroFixParaCorregirDisparo.transform.rotation, null, GameManager.instance.player.miEquipo);
			GameManager.instance.player.Vibra(Player.TipoVibracion.disparar, miMano.mano == ControladorMano.Mano.Derecha);
			obj.transform.localScale = Vector3.one * 0.09f;
			obj.transform.SetParent(PunteroFixParaCorregirDisparo.transform);
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.SetParent(null);
			SyncBala component = obj.GetComponent<SyncBala>();
			if ((bool)component)
			{
				component.idObjPhotonPlayer = GameManager.instance.player.photonView.ViewID;
				component.numUsos = 2;
				component.ChangeTrail(laser: true);
			}
			Bala component2 = obj.GetComponent<Bala>();
			component2.velocidadSinTrucar = PunteroFixParaCorregirDisparo.transform.forward * 7.5f * 3f;
			component2.trail.Clear();
			component2.trail.enabled = true;
			ticksDesdeUltimoDisparo = 0;
			puedeDisparar = true;
			break;
		}
		}
		TimeManager.GetInstance().ticksConTiempoNormalForzado = 15;
		PonerAudioEnAudioSource(clipAudio);
	}

	public void PonerGancho(AnimManos animMano)
	{
		if (!gancho.activeInHierarchy)
		{
			TimeManager.instance.ticksConTiempoNormalForzado = 15;
			animManos = animMano;
			animManos.HoldHook();
			gancho.transform.localPosition = new Vector3(0f, 0.075f, 0.018f);
			gancho.transform.localRotation = Quaternion.Euler(-81.161f, 0f, 0f);
			municion = 0;
			miMano.PonerAudioEnAudioSource(ControladorMano.ClipsAudioMano.TransformarAGancho);
			inclinacionParaAnimacionGanchoQueVaDe0A1 = 0f;
			gancho.SetActive(value: true);
			pistolaMesh.SetActive(value: false);
			coliderPistola.SetActive(value: false);
			coliderGancho.SetActive(value: true);
			pantalla.gameObject.SetActive(value: false);
		}
	}

	public void JumpTo(GameObject objetivo, float fuerza)
	{
		if (fuerza == 0f)
		{
			fuerza = fuerzaSalto;
		}
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		rb.velocity = Vector3.zero;
		Vector3 normalized = (objetivo.transform.position - base.transform.position).normalized;
		normalized += new Vector3(0f, 0.5f, 0f);
		rb.AddForce(normalized * fuerza, ForceMode.Impulse);
	}

	private IEnumerator disparoTiempo(float tiempo)
	{
		yield return new WaitForSeconds(tiempo);
		puedeDisparar = true;
	}

	public void DesactivarCadenas()
	{
		controladorCadena.m_line.enabled = false;
	}

	public void ActivarCadenas()
	{
		controladorCadena.m_line.enabled = true;
	}

	public void Recarga()
	{
		if (miMano.estadoDeLaMano != ControladorMano.EstadoDeLaMano.GanchoEnMano)
		{
			municion = municionMaxActual;
			if (municion == 2)
			{
				pantalla.gameObject.SetActive(value: true);
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
			}
			else if (municion == 1)
			{
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, 0f));
			}
			else
			{
				pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
			}
		}
	}

	public void ApagarPantallaPorTextura()
	{
		pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
	}

	public IEnumerator TiempoRecarga(float tiempo)
	{
		yield return new WaitForSeconds(tiempo);
		if (tipoDeArma == TipoDeArma.Normal)
		{
			Recarga();
		}
	}

	public void MostrarPistola()
	{
		pistolaMesh.SetActive(value: true);
		pantalla.gameObject.SetActive(value: true);
		if (municion == 2)
		{
			pantalla.gameObject.SetActive(value: true);
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
		}
		else if (municion == 1)
		{
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, 0f));
		}
		else
		{
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(-0.1f, 0f));
		}
		gancho.SetActive(value: false);
		coliderPistola.SetActive(value: true);
		coliderGancho.SetActive(value: false);
		pandreColiders.transform.localPosition = new Vector3(0f, 0.017f, 0.081f);
		triggerPistola.SetActive(value: true);
		GetComponent<EfectoDesaparecer>().Aparecer();
	}

	public override void PonerPosicionInicial()
	{
		puedeDisparar = false;
		municion = municionMaxNormal;
		rb.isKinematic = true;
		rb.useGravity = false;
		base.transform.parent = padreInicio;
		base.transform.localPosition = transformInicial;
		base.transform.localRotation = rotacionInicial;
		nivelIniciado = false;
		pistolaMesh.SetActive(value: false);
		pantalla.gameObject.SetActive(value: false);
		gancho.SetActive(value: false);
		coliderPistola.SetActive(value: false);
		coliderGancho.SetActive(value: false);
		triggerPistola.SetActive(value: false);
	}

	private void CargarClipsAudio()
	{
		audioClipsWeapon[0] = Resources.Load<AudioClip>("EfectosSonido/disparo");
		audioClipsWeapon[1] = Resources.Load<AudioClip>("EfectosSonido/golpear_gancho");
		audioClipsWeapon[2] = Resources.Load<AudioClip>("EfectosSonido/InicioPowerup");
		audioClipsWeapon[3] = Resources.Load<AudioClip>("EfectosSonido/FinalPowerup");
		audioClipsWeapon[4] = Resources.Load<AudioClip>("EfectosSonido/disparoEscopeta");
		audioClipsWeapon[5] = Resources.Load<AudioClip>("EfectosSonido/disparoLaser");
		audioClipsWeapon[6] = Resources.Load<AudioClip>("EfectosSonido/impacto_error_EscudoBala");
		audioClipsWeapon[7] = Resources.Load<AudioClip>("EfectosSonido/recoger_gancho");
		audioClipsWeapon[9] = Resources.Load<AudioClip>("EfectosSonido/recargar");
	}

	public void PonerAudioEnAudioSource(ClipsAudioWeapon clipAudio)
	{
		AudioClip audioClip = audioClipsWeapon[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Weapon.cs " + clipAudio);
			return;
		}
		int num = 0;
		if (audioSources != null)
		{
			num = audioSources.Length;
		}
		if (num == 0)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en Weapon.cs");
			return;
		}
		int num2 = 0;
		while (audioSources[num2].isPlaying)
		{
			num2++;
			if (num2 >= audioSources.Length)
			{
				num2 = 0;
				audioSources[num2].Stop();
			}
		}
		if (num2 < 999)
		{
			audioSources[num2].clip = audioClip;
			audioSources[num2].Play();
		}
	}

	public TipoDeArma GetTipoDeArma()
	{
		return tipoDeArma;
	}

	public void CambiarTipoDeArma(TipoDeArma nuevoTipo, bool sinMunicion = false)
	{
		if (devolverALaNormalidadCor != null)
		{
			StopCoroutine(devolverALaNormalidadCor);
		}
		switch (nuevoTipo)
		{
		case TipoDeArma.Normal:
			if (tipoDeArma != 0)
			{
				PonerAudioEnAudioSource(ClipsAudioWeapon.FinPowerup);
			}
			if (sinMunicion)
			{
				municion = 0;
			}
			else
			{
				municion = municionMaxNormal;
			}
			textoTiempoArma.gameObject.SetActive(value: false);
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
			pantalla.enabled = true;
			laser.SetActive(value: false);
			pantalla.gameObject.SetActive(value: true);
			break;
		case TipoDeArma.Escopeta:
			PonerAudioEnAudioSource(ClipsAudioWeapon.InicioPowerup);
			miMano.PonerPistolaEnMano();
			municion = municionMaxEscopeta;
			textoTiempoArma.gameObject.SetActive(value: true);
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				devolverALaNormalidadCor = StartCoroutine(DevolverALaNormalidad(7f));
			}
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(0f, -0.14f));
			pantalla.enabled = true;
			pantalla.gameObject.SetActive(value: true);
			laser.SetActive(value: false);
			break;
		case TipoDeArma.Laser:
			PonerAudioEnAudioSource(ClipsAudioWeapon.InicioPowerup);
			miMano.PonerPistolaEnMano();
			municion = municionMaxLaser;
			textoTiempoArma.gameObject.SetActive(value: true);
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				devolverALaNormalidadCor = StartCoroutine(DevolverALaNormalidad(7f));
			}
			pantalla.material.SetTextureOffset("_MainTex", new Vector2(0.08f, -0.14f));
			pantalla.enabled = true;
			pantalla.gameObject.SetActive(value: true);
			laser.SetActive(value: true);
			break;
		}
		municionMaxActual = municion;
		tipoDeArma = nuevoTipo;
	}

	private IEnumerator DevolverALaNormalidad(float tiempo)
	{
		int cont = (int)tiempo;
		do
		{
			textoTiempoArma.text = "00:0" + cont;
			cont--;
			yield return new WaitForSeconds(1f);
		}
		while (cont > 0);
		if (GameManager.instance.powerUpShotgunActivo)
		{
			GameManager.instance.powerUpShotgunActivo = false;
			GameManager.instance.numEsferasMientrasPWShotgun = 0;
		}
		if (GameManager.instance.powerUpLaserActivo)
		{
			GameManager.instance.powerUpLaserActivo = false;
			GameManager.instance.numEsferasMientrasPWLaser = 0;
		}
		CambiarTipoDeArma(TipoDeArma.Normal);
	}

	public void RebotarGancho()
	{
		ChocadoPelota = true;
		JumpTo(player, fuerzaSalto / 2f);
		miMano.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.GanchoPuedeRetornar);
	}

	public void Apagar()
	{
		if (base.gameObject.activeInHierarchy)
		{
			GetComponent<EfectoDesaparecer>().Desaparecer();
		}
		controladorCadena.m_line.enabled = false;
	}

	public void Encender()
	{
		GetComponent<EfectoDesaparecer>().Aparecer();
		controladorCadena.Aparecer();
		controladorCadena.m_line.enabled = true;
	}
}
public class activarElectricidadSiEstaCerca : MonoBehaviour
{
	private AudioSource miAudioSource;

	private int tickSinHacerNada;

	private GameObject player;

	private void Start()
	{
		miAudioSource = GetComponent<AudioSource>();
		player = GameManager.instance.player.tJugador.gameObject;
		miAudioSource.mute = false;
	}

	private void Update()
	{
		tickSinHacerNada++;
		if (tickSinHacerNada >= 5)
		{
			tickSinHacerNada = 0;
			float num = Vector3.Distance(base.transform.position, player.transform.position);
			miAudioSource.mute = num > 5f;
		}
	}
}
public class esferaTorreta : MonoBehaviour
{
	public AudioSource explosion;

	public AudioSource disparo;

	public Transform posSpawnBala;

	public Animator anim;

	public EfectoDesaparecer efectoDesaparecer;

	public BossSatelites boss;

	public GameObject particulasExplosion;

	private PhotonView pv;

	private Transform ultimoTarget;

	private int equipoUltimoTarget = 1;

	private Vector3 posInicial = Vector3.zero;

	public GameObject mesh;

	private bool encendido;

	private Transform t;

	private void Start()
	{
		pv = GetComponent<PhotonView>();
		ultimoTarget = GameManager.instance.player.cabeza.transform;
		posInicial = base.transform.position;
		if (!pv.IsMine)
		{
			mesh.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (!pv)
		{
			return;
		}
		if (!pv.IsMine)
		{
			if (!encendido && posInicial != base.transform.position)
			{
				encendido = true;
				mesh.SetActive(value: true);
			}
		}
		else
		{
			t = PartidaSync.instance.GetPlayerObjetivo();
			Vector3 forward = t.transform.position - base.transform.GetChild(0).position;
			base.transform.GetChild(0).rotation = Quaternion.Slerp(base.transform.GetChild(0).rotation, Quaternion.LookRotation(forward), Time.deltaTime * 30f);
		}
	}

	public void Disparar()
	{
		try
		{
			if (pv.IsMine)
			{
				Transform transform = posSpawnBala;
				disparo.Play();
				PoolObjetos.GetInstance().Instanciar(PoolObjetos.TipoObjeto.BalaTorreta, transform.position, Quaternion.identity, null, equipoUltimoTarget).GetComponent<BalaEsfera>()
					.CambiarTarget(ultimoTarget);
				anim.SetTrigger("disparo");
			}
		}
		catch
		{
		}
	}

	public void Destruir(bool inmediatamente = false)
	{
		if (pv.IsMine)
		{
			if (inmediatamente)
			{
				PhotonNetwork.Destroy(base.gameObject);
				return;
			}
			boss.GetComponent<SyncBoss>().SateliteDestruido(GetComponent<PhotonView>().ViewID);
			boss.EliminarEsfera(this);
			efectoDesaparecer.gameObject.SetActive(value: true);
			efectoDesaparecer.Desaparecer();
			particulasExplosion.SetActive(value: true);
			explosion.Play();
		}
	}

	public void Encender()
	{
		efectoDesaparecer.gameObject.SetActive(value: true);
		efectoDesaparecer.Aparecer();
	}

	private void OnTriggerEnter(Collider collision)
	{
		if (!pv.IsMine)
		{
			return;
		}
		if (collision.gameObject.CompareTag(GameManager.instance.tagBala))
		{
			Destruir();
		}
		else if (collision.gameObject.CompareTag(GameManager.instance.tagPistola))
		{
			if (collision.gameObject.GetComponentInParent<Weapon>().miMano.estadoDeLaMano != ControladorMano.EstadoDeLaMano.PistolaEnMano)
			{
				Destruir();
			}
			else
			{
				GameManager.instance.player.Morir(null, forzarMuerte: false, porCabeza: false, collision.gameObject.GetComponentInParent<Weapon>().miMano.mano == ControladorMano.Mano.Derecha);
			}
		}
	}
}
public class grabadorIntro : MonoBehaviour
{
	private int tiempoPasado;

	public Camera camaraRender;

	public Camera camaraQueTengoQueApagar;

	private void Start()
	{
		tiempoPasado = 0;
	}

	private void Update()
	{
		tiempoPasado++;
		if (tiempoPasado == 300)
		{
			camaraQueTengoQueApagar.enabled = false;
			camaraRender.targetTexture = null;
		}
	}
}
public class ParedMovible : MonoBehaviour
{
	private struct BolasDentro
	{
		public EsferaScript bola;

		public float tiempoDentro;

		public BolasDentro(EsferaScript b, float t)
		{
			bola = b;
			tiempoDentro = t;
		}
	}

	private float tiempoASalir = -1f;

	private bool salir;

	private float velocidad = 0.0005f;

	private Vector3 posIni;

	public GameObject particulas;

	public GameObject destructorMuros;

	public ParticleSystem particleS;

	public BoxCollider collider;

	private List<BolasDentro> bolasDentro = new List<BolasDentro>();

	public AudioSource audio;

	private Coroutine corrEmpezar;

	private Coroutine apagarCor;

	private void Start()
	{
		collider = GetComponent<BoxCollider>();
		GameManager.instance.paredMovible = this;
		posIni = base.transform.localPosition;
		destructorMuros.SetActive(value: false);
	}

	public void Inicializar()
	{
		if (corrEmpezar != null)
		{
			StopCoroutine(corrEmpezar);
		}
		ParticleSystem.MainModule main = particleS.main;
		main.startColor = new Color(main.startColor.color.r, main.startColor.color.g, main.startColor.color.b, 1f);
		main.simulationSpeed = 1f;
		destructorMuros.SetActive(value: false);
		bolasDentro.Clear();
		collider.enabled = true;
		audio.Stop();
		base.transform.localPosition = posIni;
		salir = false;
		tiempoASalir = GameManager.instance.GetTiempoSalidaPared();
		GameManager.instance.DesactivarPanico();
	}

	public void EmpiezaNivel()
	{
		if (corrEmpezar != null)
		{
			StopCoroutine(corrEmpezar);
		}
		if (apagarCor != null)
		{
			StopCoroutine(apagarCor);
			Inicializar();
		}
		if (tiempoASalir != -1f)
		{
			corrEmpezar = StartCoroutine(Activar(tiempoASalir));
		}
	}

	private IEnumerator Activar(float tiempo)
	{
		float tiempoSalida = 0f;
		while (tiempoSalida < tiempo)
		{
			tiempoSalida += Time.deltaTime * TimeManager.instance.GetTiempoMedioGlobal();
			yield return null;
		}
		if (GameManager.instance.nivelActual + 1 != 10)
		{
			Activa();
		}
	}

	public void Activa()
	{
		if (!salir && !GameManager.instance.player.muerto)
		{
			if (GameManager.instance.paisActual == 0 && GameManager.instance.nivelActual == 0)
			{
				StartCoroutine(MostrarMensajePared());
			}
			destructorMuros.SetActive(value: true);
			audio.Play();
			collider.enabled = true;
			salir = true;
			GameManager.instance.ActivarPanico(audio);
		}
	}

	private IEnumerator MostrarMensajePared()
	{
		yield return new WaitForSeconds(1f);
		if (NivelCompletado.instance.listaEsferasEquipo1.Count > 0)
		{
			GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 10102, 14f, 0);
		}
	}

	public void Apagar()
	{
		if (apagarCor != null)
		{
			StopCoroutine(apagarCor);
		}
		apagarCor = StartCoroutine(ApagarPared());
		if (corrEmpezar != null)
		{
			StopCoroutine(corrEmpezar);
		}
		ParticleSystem.MainModule main = particleS.main;
		main.startColor = new Color(main.startColor.color.r, main.startColor.color.g, main.startColor.color.b, 0f);
		main.simulationSpeed = 3f;
		destructorMuros.SetActive(value: false);
		bolasDentro.Clear();
		audio.Stop();
		salir = false;
		collider.enabled = false;
		tiempoASalir = GameManager.instance.GetTiempoSalidaPared();
		GameManager.instance.DesactivarPanico();
	}

	private IEnumerator ApagarPared()
	{
		yield return new WaitForSeconds(3f);
		Inicializar();
	}

	private void Update()
	{
		if (!PhotonNetwork.IsMasterClient)
		{
			return;
		}
		if ((bool)GameManager.instance && salir)
		{
			if (GameManager.instance.player.muerto)
			{
				return;
			}
			base.transform.localPosition += base.transform.forward * TimeManager.instance.GetTiempoMedioGlobal() * velocidad;
		}
		else if ((bool)GameManager.instance && GameManager.instance.nivelActual + 1 != 10 && GameManager.instance.esferasActivas != null && GameManager.instance.m_salaManager.nivelIniciado && GameManager.instance.esferasActivas.Count > 0 && GameManager.instance.esferasActivas.Count <= 3)
		{
			int num = 0;
			foreach (EsferaScript esferasActiva in GameManager.instance.esferasActivas)
			{
				if ((bool)esferasActiva)
				{
					int nivelDeBolaInicial = esferasActiva.NivelDeBolaInicial;
					num += nivelDeBolaInicial;
					if (num > 2)
					{
						return;
					}
				}
			}
			if (tiempoASalir != -1f)
			{
				Activa();
			}
		}
		for (int i = 0; i < bolasDentro.Count; i++)
		{
			if (bolasDentro[i].bola == null)
			{
				bolasDentro.RemoveAt(i);
				continue;
			}
			if (bolasDentro[i].tiempoDentro > 4f)
			{
				bolasDentro[i].bola.Destruirse();
				bolasDentro.RemoveAt(i);
				continue;
			}
			if (bolasDentro[i].tiempoDentro > 0.3f)
			{
				bolasDentro[i].bola.CambiarDireccion((GameManager.instance.player.tJugador.position - base.transform.position).normalized, 3f);
			}
			BolasDentro value = bolasDentro[i];
			value.tiempoDentro += Time.deltaTime;
			bolasDentro[i] = value;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!PhotonNetwork.IsMasterClient || !collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			return;
		}
		EsferaScript component = collision.transform.GetComponent<EsferaScript>();
		if (!component)
		{
			return;
		}
		foreach (BolasDentro item2 in bolasDentro)
		{
			if (item2.bola == component)
			{
				return;
			}
		}
		BolasDentro item = new BolasDentro(component, 0f);
		bolasDentro.Add(item);
	}

	private void OnCollisionExit(Collision collision)
	{
		if (!PhotonNetwork.IsMasterClient || !collision.gameObject.CompareTag(GameManager.instance.tagEsfera))
		{
			return;
		}
		EsferaScript component = collision.gameObject.GetComponent<EsferaScript>();
		foreach (BolasDentro item in bolasDentro)
		{
			if (item.bola == component)
			{
				bolasDentro.Remove(item);
				break;
			}
		}
	}
}
public class PersistentDataManager
{
	public class DataSerializada
	{
		public Dictionary<string, string> stringData;

		public Dictionary<string, int> intData;

		public Dictionary<string, float> floatData;

		public DataSerializada(Dictionary<string, string> stringData, Dictionary<string, int> intData, Dictionary<string, float> floatData)
		{
			this.stringData = stringData;
			this.intData = intData;
			this.floatData = floatData;
		}
	}

	private const string encryptPass = "pleX:_wRPT756(FGkWtso";

	private const string FILENAME = "Pang_saveData.sav";

	private const string FILENAMEBCKUP = "BckUp_Pang_saveData.sav";

	private static Dictionary<string, string> stringData = new Dictionary<string, string>();

	private static Dictionary<string, int> intData = new Dictionary<string, int>();

	private static Dictionary<string, float> floatData = new Dictionary<string, float>();

	private static bool guardadoPendiente = false;

	private static bool nuevaKeyAgregada = false;

	public static bool guardando = false;

	private static bool infoCargada = false;

	public static void SaveData(bool forzarGuardado = false)
	{
		UnityEngine.Debug.Log("Data saved");
		if (!(guardadoPendiente || nuevaKeyAgregada || forzarGuardado))
		{
			return;
		}
		guardando = true;
		string plainText = "string";
		string text = Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		foreach (KeyValuePair<string, string> stringDatum in stringData)
		{
			plainText = stringDatum.Key + " = " + stringDatum.Value + ";";
			text = text + Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		}
		plainText = "int";
		text = text + Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		foreach (KeyValuePair<string, int> intDatum in intData)
		{
			plainText = intDatum.Key + " = " + intDatum.Value + ";";
			text = text + Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		}
		plainText = "float";
		text = text + Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		foreach (KeyValuePair<string, float> floatDatum in floatData)
		{
			plainText = floatDatum.Key + " = " + floatDatum.Value + ";";
			text = text + Encrypt.EncryptString(plainText, "pleX:_wRPT756(FGkWtso") + "\n";
		}
		StreamWriter streamWriter = new StreamWriter(File.Open(UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav", FileMode.OpenOrCreate, FileAccess.Write));
		streamWriter.WriteLine(text);
		streamWriter.Close();
		GuardarArchivoDeBackup();
	}

	public static void GuardarArchivoDeBackup()
	{
		string path = UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav";
		string path2 = UnityEngine.Application.persistentDataPath + "/BckUp_Pang_saveData.sav";
		if (ComprobarArchivoDeGuardado())
		{
			FileStream stream = File.Open(path, FileMode.Open, FileAccess.Read);
			FileStream stream2 = File.Open(path2, FileMode.OpenOrCreate, FileAccess.Write);
			StreamReader streamReader = new StreamReader(stream);
			StreamWriter streamWriter = new StreamWriter(stream2);
			streamWriter.WriteLine(streamReader.ReadToEnd());
			streamWriter.Close();
			streamReader.Close();
		}
		else if (File.Exists(path2))
		{
			FileStream stream3 = File.Open(path2, FileMode.Open, FileAccess.Read);
			FileStream stream4 = File.Open(path, FileMode.OpenOrCreate, FileAccess.Write);
			StreamReader streamReader2 = new StreamReader(stream3);
			StreamWriter streamWriter2 = new StreamWriter(stream4);
			streamWriter2.WriteLine(streamReader2.ReadToEnd());
			streamWriter2.Close();
			streamReader2.Close();
		}
		guardando = false;
	}

	private static bool ComprobarArchivoDeGuardado()
	{
		string path = UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav";
		FileStream fileStream = null;
		if (File.Exists(path))
		{
			try
			{
				fileStream = File.Open(path, FileMode.Open, FileAccess.Read);
			}
			catch
			{
				fileStream = null;
			}
		}
		if (fileStream != null)
		{
			try
			{
				using (StreamReader streamReader = new StreamReader(fileStream))
				{
					string text;
					while ((text = streamReader.ReadLine()) != null)
					{
						if (text.Length > 1)
						{
							Encrypt.DecryptString(text, "pleX:_wRPT756(FGkWtso").TrimEnd();
						}
					}
					fileStream.Close();
				}
				return true;
			}
			catch
			{
				return false;
			}
		}
		return false;
	}

	private static bool HashValidation(string hashCode, string fileString)
	{
		hashCode = hashCode.Substring(3);
		string text = Hash128.Compute(fileString).ToString();
		UnityEngine.Debug.LogError("B HashAAA: " + Hash128.Compute(fileString).ToString());
		UnityEngine.Debug.LogError("B Hash: " + text);
		if (hashCode.Equals(text))
		{
			return true;
		}
		return false;
	}

	public static void LoadData()
	{
		if (infoCargada)
		{
			return;
		}
		infoCargada = true;
		PlayerPrefs.Save();
		Debugs.Log("Data load");
		string path = UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav";
		FileStream fileStream = File.Open(path, FileMode.OpenOrCreate, FileAccess.Read);
		bool flag = false;
		int num = 0;
		try
		{
			using StreamReader streamReader = new StreamReader(fileStream);
			string text;
			while ((text = streamReader.ReadLine()) != null)
			{
				if (text.Length <= 1)
				{
					continue;
				}
				string text2 = Encrypt.DecryptString(text, "pleX:_wRPT756(FGkWtso");
				text2 = text2.TrimEnd();
				if (text2.Equals("string"))
				{
					num = 0;
					continue;
				}
				if (text2.Equals("int"))
				{
					num = 1;
					continue;
				}
				if (text2.Equals("float"))
				{
					num = 2;
					continue;
				}
				string key = text2.Substring(0, text2.IndexOf('=') - 1);
				string text3 = text2.Substring(text2.IndexOf('=') + 2, text2.Length - text2.IndexOf('=') - 3);
				switch (num)
				{
				case 0:
					stringData[key] = text3;
					break;
				case 1:
					intData[key] = int.Parse(text3);
					break;
				case 2:
					floatData[key] = float.Parse(text3);
					break;
				}
			}
			fileStream.Close();
		}
		catch (Exception ex)
		{
			EnviarMailProblemaDeGuardado(1);
			flag = true;
			Console.WriteLine("The file could not be read:");
			Console.WriteLine(ex.Message);
			File.Delete(path);
		}
		if (!flag && intData.ContainsKey("ArchivoDeGuardadoCreado"))
		{
			return;
		}
		string path2 = UnityEngine.Application.persistentDataPath + "/BckUp_Pang_saveData.sav";
		if (!File.Exists(path2))
		{
			return;
		}
		FileStream fileStream2 = File.Open(path2, FileMode.OpenOrCreate, FileAccess.Read);
		num = 0;
		using (StreamReader streamReader2 = new StreamReader(fileStream2))
		{
			try
			{
				string text4;
				while ((text4 = streamReader2.ReadLine()) != null)
				{
					if (text4.Length <= 1)
					{
						continue;
					}
					string text5 = Encrypt.DecryptString(text4, "pleX:_wRPT756(FGkWtso");
					text5 = text5.TrimEnd();
					if (text5.Equals("string"))
					{
						num = 0;
						continue;
					}
					if (text5.Equals("int"))
					{
						num = 1;
						continue;
					}
					if (text5.Equals("float"))
					{
						num = 2;
						continue;
					}
					string key2 = text5.Substring(0, text5.IndexOf('=') - 1);
					string text6 = text5.Substring(text5.IndexOf('=') + 2, text5.Length - text5.IndexOf('=') - 3);
					switch (num)
					{
					case 0:
						stringData[key2] = text6;
						break;
					case 1:
						intData[key2] = int.Parse(text6);
						break;
					case 2:
						floatData[key2] = float.Parse(text6);
						break;
					}
				}
				fileStream2.Close();
			}
			catch
			{
				EnviarMailProblemaDeGuardado(2);
				fileStream2.Close();
				if (File.Exists(path2))
				{
					File.Delete(path2);
				}
				UnityEngine.Application.Quit();
			}
		}
		if (flag && File.Exists(path2))
		{
			FileStream stream = File.Open(path2, FileMode.Open, FileAccess.Read);
			fileStream = File.Open(path, FileMode.OpenOrCreate, FileAccess.Write);
			StreamReader streamReader3 = new StreamReader(stream);
			StreamWriter streamWriter = new StreamWriter(fileStream);
			streamWriter.WriteLine(streamReader3.ReadToEnd());
			streamWriter.Close();
			streamReader3.Close();
		}
	}

	public static void EnviarMailProblemaDeGuardado(int archivo)
	{
		string text = "";
		text += "Archivo perdido: ";
		text = ((archivo != 1) ? (text + "Save Backup \n") : (text + "Save Normal \n"));
		text += "Contenido del fichero: \n";
		string path = UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav";
		FileStream fileStream = File.Open(path, FileMode.OpenOrCreate, FileAccess.Read);
		using (StreamReader streamReader = new StreamReader(fileStream))
		{
			string text2;
			while ((text2 = streamReader.ReadLine()) != null)
			{
				text = text + text2 + "\n";
			}
			fileStream.Close();
		}
		text += "Contenido del fichero backup: \n";
		path = UnityEngine.Application.persistentDataPath + "/BckUp_Pang_saveData.sav";
		if (!File.Exists(path))
		{
			return;
		}
		fileStream = File.Open(path, FileMode.Open, FileAccess.Read);
		using StreamReader streamReader2 = new StreamReader(fileStream);
		string text3;
		while ((text3 = streamReader2.ReadLine()) != null)
		{
			text = text + text3 + "\n";
		}
		fileStream.Close();
	}

	public static void SetString(string key, string value)
	{
		if (!stringData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			stringData.Add(key, value);
		}
		else if (stringData[key] != value)
		{
			guardadoPendiente = true;
			stringData[key] = value;
		}
	}

	public static string GetString(string key, string defaultValue = "")
	{
		if (!stringData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			stringData.Add(key, defaultValue);
			return defaultValue;
		}
		if (!stringData[key].Equals("-99"))
		{
			return stringData[key];
		}
		stringData[key] = defaultValue;
		return defaultValue;
	}

	public static void SetInt(string key, int value)
	{
		if (!intData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			intData.Add(key, value);
		}
		else if (intData[key] != value)
		{
			guardadoPendiente = true;
			intData[key] = value;
		}
	}

	public static int GetInt(string key, int defaultValue = 0)
	{
		if (!intData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			intData.Add(key, defaultValue);
			return defaultValue;
		}
		if (intData[key] != -99)
		{
			return intData[key];
		}
		intData[key] = defaultValue;
		return defaultValue;
	}

	public static void SetFloat(string key, float value)
	{
		if (!floatData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			floatData.Add(key, value);
		}
		else if (floatData[key] != value)
		{
			guardadoPendiente = true;
			floatData[key] = value;
		}
	}

	public static float GetFloat(string key, float defaultValue = 0f)
	{
		if (!floatData.ContainsKey(key))
		{
			nuevaKeyAgregada = true;
			guardadoPendiente = true;
			floatData.Add(key, defaultValue);
			return defaultValue;
		}
		if (floatData[key] != -99f)
		{
			return floatData[key];
		}
		floatData[key] = defaultValue;
		return defaultValue;
	}

	public static bool HasKey(string key)
	{
		if (stringData.ContainsKey(key))
		{
			if (!stringData[key].Equals("-99"))
			{
				return true;
			}
			return false;
		}
		if (intData.ContainsKey(key))
		{
			if (intData[key] != -99)
			{
				return true;
			}
			return false;
		}
		if (floatData.ContainsKey(key))
		{
			if (floatData[key] != -99f)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static void DeleteAll()
	{
		string path = UnityEngine.Application.persistentDataPath + "/Pang_saveData.sav";
		string path2 = UnityEngine.Application.persistentDataPath + "/BckUp_Pang_saveData.sav";
		stringData.Clear();
		intData.Clear();
		floatData.Clear();
		if (File.Exists(path))
		{
			File.Delete(path);
		}
		if (File.Exists(path2))
		{
			File.Delete(path2);
		}
	}
}
public static class Encrypt
{
	private const string initVector = "pemgail9uzpgzl88";

	private const int keysize = 256;

	public static string EncryptString(string plainText, string passPhrase)
	{
		byte[] bytes = Encoding.UTF8.GetBytes("pemgail9uzpgzl88");
		byte[] bytes2 = Encoding.UTF8.GetBytes(plainText);
		byte[] bytes3 = new PasswordDeriveBytes(passPhrase, null).GetBytes(32);
		ICryptoTransform transform = new RijndaelManaged
		{
			Mode = CipherMode.CBC
		}.CreateEncryptor(bytes3, bytes);
		MemoryStream memoryStream = new MemoryStream();
		CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write);
		cryptoStream.Write(bytes2, 0, bytes2.Length);
		cryptoStream.FlushFinalBlock();
		byte[] inArray = memoryStream.ToArray();
		memoryStream.Close();
		cryptoStream.Close();
		return Convert.ToBase64String(inArray);
	}

	public static string DecryptString(string cipherText, string passPhrase)
	{
		byte[] bytes = Encoding.UTF8.GetBytes("pemgail9uzpgzl88");
		byte[] array = Convert.FromBase64String(cipherText);
		byte[] bytes2 = new PasswordDeriveBytes(passPhrase, null).GetBytes(32);
		ICryptoTransform transform = new RijndaelManaged
		{
			Mode = CipherMode.CBC
		}.CreateDecryptor(bytes2, bytes);
		MemoryStream memoryStream = new MemoryStream(array);
		CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Read);
		byte[] array2 = new byte[array.Length];
		try
		{
			int count = cryptoStream.Read(array2, 0, array2.Length);
			memoryStream.Close();
			cryptoStream.Close();
			return Encoding.UTF8.GetString(array2, 0, count);
		}
		catch
		{
			UnityEngine.Debug.LogError("ERROR AL DESENCRIPTAR");
			return null;
		}
	}
}
public class Player : MonoBehaviourPun
{
	public enum ClipsAudioJugador
	{
		Muerte,
		Victoria,
		Inicio,
		AparecerGlobalRS,
		DesaparecerGlobalRS,
		Cool,
		Cont
	}

	public enum EstadoZonaNegra
	{
		Desactivado,
		FueraLimites,
		Pausa
	}

	public enum TipoVibracion
	{
		ninguno,
		disparar,
		cogerPistolas,
		lanzarGancho,
		rebotarBala,
		morir,
		pasarseLivel
	}

	private bool soyInmortal;

	[HideInInspector]
	public EstadoZonaNegra estadoZonaNegra;

	public Transform pistolasPadre;

	public Transform pistolasPadreRoomScale;

	[HideInInspector]
	public Transform tJugador;

	[HideInInspector]
	public ControladorMano controladorManoDerecha;

	[HideInInspector]
	public ControladorMano controladorManoIzquierda;

	[HideInInspector]
	public GameObject cabeza;

	[HideInInspector]
	public AudioSource audioSourcePlayer;

	private AudioClip[] audioClipsPlayer = new AudioClip[6];

	private int puntos;

	[HideInInspector]
	public float velCabeza;

	[HideInInspector]
	public float velManoDerecha;

	[HideInInspector]
	public float velManoIzquierda;

	private Vector3 posAnteriorCabeza;

	private Vector3 posAnteriorManoDerecha;

	private Vector3 posAnteriorManoIzquierda;

	public Weapon weaponDer;

	public Weapon weaponIzq;

	public Rifle rifle;

	[HideInInspector]
	public bool fueraDeLimites;

	public int miEquipo = 1;

	public bool menu;

	public SyncJugadores miSyncJugadores;

	public Transform playerRoomScale;

	public GameObject cabezaMuñecoAbajo;

	public Transform posInicialPlayerRoomScale;

	public Transform posInicialCabezaPlayerRoomScale;

	public Transform cabezaPlayerRoomScale;

	public Transform cabezaPlayerRoomScalePico;

	public Transform cabezaPlayerRoomScaleNolo;

	public Transform audioSourcesRoomScale;

	private AudioSource audioSourceRoomScaleAparecer;

	private AudioSource audioSourceRoomScaleDesaparecer;

	public bool roomScale;

	private Speaker speaker;

	private PhotonVoiceView photonVoiceView;

	public GameObject zonaOscura;

	public GameObject cajaNegra;

	public Transform tutorialDerecho;

	public Transform tutorialIzquierdo;

	public Transform padreOriginalTutorialDerecho;

	public Transform padreOriginalTutorialIzquierdo;

	public Transform padreFakeTutorialDerecho;

	public Transform padreFakeTutorialIzquuierdo;

	public GameObject pistolaRoomScaleFakeD;

	public GameObject pistolaRoomScaleFakeI;

	public GameObject rifleRommScaleFakeD;

	public GameObject rifleRommScaleFakeI;

	public GameObject hologramaRoomScaleD;

	public GameObject hologramaRoomScaleI;

	public GameObject huellas;

	public TextMeshPro textoIdOnline;

	private CamaraBlancoNegro camaraBlancoNegro;

	public Recorder vozPun;

	[HideInInspector]
	public int idPhotonVoiceView = -1;

	[HideInInspector]
	public float segReinicio;

	private int oldNumPlayers;

	private int oldPuntuacionE1;

	private int oldPuntuacionE2;

	private float esperaArenaInfo;

	private Coroutine enElLimboCor;

	[HideInInspector]
	public bool enElLimbo;

	public bool muerto;

	public bool noPoderMoverse;

	[HideInInspector]
	public bool pararTiempo;

	public bool inmune;

	private Coroutine muerte;

	private Coroutine laser;

	private GameObject objetoMuerte;

	[HideInInspector]
	public CabezaRoomSccale cabezaRoomScaleScript;

	private Coroutine corPosicionarPlayer;

	private Vector3 pistolasPadresInicio = Vector3.zero;

	private Transform padreInicial;

	private Coroutine mostrarPistolasCor;

	public bool zonaOscuraActivada;

	public Transform collidersLimitesRoomScale;

	private Vector3 posPlayerAlActivar = Vector3.zero;

	private Vector3 posIniPantallaDerecha = Vector3.zero;

	private Vector3 escalaIniPantallaDerecha = Vector3.zero;

	public GameObject botonesPausa;

	public GameObject botonesSalir;

	public TextMeshPro textJugQueHaPuestoPausa;

	public GameObject[] botonesPausaArray;

	public GameObject laserManoDRoomScale;

	public GameObject laserManoIRoomScale;

	public GameObject arenaGo;

	public TextMeshPro puntuacionArenaE1;

	public TextMeshPro puntuacionArenaE2;

	public TextMeshPro miembrosEquipo1;

	public TextMeshPro miembrosquipo2;

	private int idJugadorQueHaPuestoPausa = -1;

	private Coroutine ponerLaser;

	private Coroutine indicarSala;

	private Coroutine corInmortalidad;

	private bool pD;

	private bool pI;

	private bool rD;

	private bool rI;

	public bool enConfirmacionDeSalir;

	private Vector3 posIniTutoDerecho;

	private Vector3 posIniTutoIzquierdo;

	private Vector3 escalaTutoD;

	private Vector3 escalaTutoI;

	public float tiempoDesdeQueHeSubidoHastaQuePuedoBajar;

	private Transform audioSorucesDerecha;

	private Transform audioSorucesIzquierda;

	private bool meHeRecolocadoPorPrimeraVez;

	private bool haDeRecolocarse;

	public TipoVibracion tipoVibracionActual;

	public bool pararVibracion;

	public bool vibracionIniciada;

	public float fuerzaVibracion = 1f;

	public bool vibracionPermitida = true;

	private ControladorVRSteam controladorSteam;

	private ControladorVROculus controladorOculus;

	private ControladorVRPico controladorPico;

	private ControladorVRNolo controladorNolo;

	public AnimationCurve Out;

	public AnimationCurve Constant;

	public AnimationCurve In;

	private Coroutine vibracion;

	private void Start()
	{
		if (!base.photonView.IsMine && !menu)
		{
			if ((bool)speaker)
			{
				UnityEngine.Object.Destroy(speaker);
			}
			UnityEngine.Object.Destroy(playerRoomScale.gameObject);
			UnityEngine.Object.Destroy(this);
			return;
		}
		estadoZonaNegra = EstadoZonaNegra.Desactivado;
		BuscarReferencias();
		CargarClipsAudio();
		puntos = 0;
		audioSourcePlayer = cabeza.GetComponent<AudioSource>();
		noPoderMoverse = false;
		camaraBlancoNegro = cabeza.GetComponent<CamaraBlancoNegro>();
		posAnteriorCabeza = cabeza.transform.position;
		posAnteriorManoDerecha = controladorManoDerecha.transform.position;
		posAnteriorManoIzquierda = controladorManoIzquierda.transform.position;
		if (PhotonNetwork.IsMasterClient)
		{
			miEquipo = 1;
		}
		else
		{
			miEquipo = 2;
		}
		if ((bool)audioSourcesRoomScale)
		{
			AudioSource[] components = audioSourcesRoomScale.GetComponents<AudioSource>();
			audioSourceRoomScaleAparecer = components[0];
			audioSourceRoomScaleDesaparecer = components[1];
		}
		miSyncJugadores = GetComponent<SyncJugadores>();
		if (Debugs.SimularPlayer == 1)
		{
			cabeza.GetComponent<Camera>().fieldOfView = 80f;
		}
		GameManager.instance.player = this;
		if (Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			ActivarDesactiarZonaOscura(activar: false);
		}
		InicioVariablesVibracion();
		if (!menu && Config.modoDeJuego == Config.ModosDeJuego.Online && base.photonView.IsMine && (bool)vozPun)
		{
			vozPun.gameObject.SetActive(value: true);
			vozPun.transform.SetParent(null);
			photonVoiceView = PhotonNetwork.Instantiate("Prefabs/PhotonVoiceViewPrefab", Vector3.zero, Quaternion.identity, 0).GetComponent<PhotonVoiceView>();
			speaker = photonVoiceView.GetComponent<Speaker>();
			photonVoiceView.SpeakerInUse = speaker;
			photonVoiceView.RecorderInUse = vozPun;
			photonVoiceView.Init();
			idPhotonVoiceView = photonVoiceView.GetComponent<PhotonView>().ViewID;
			if (Microphone.devices.Length != 0)
			{
				vozPun.UnityMicrophoneDevice = Microphone.devices[0];
				vozPun.RestartRecording();
			}
			vozPun.IsRecording = PersistentDataManager.GetInt("YoMuteado") == 0;
		}
		if (menu)
		{
			StartCoroutine(RecolocarStartMenu());
			return;
		}
		GameManager.instance.seAcabanDePasarElBoss = false;
		if (PhotonNetwork.IsMasterClient)
		{
			GameManager.instance.acaboDeSerMaster = true;
		}
		else
		{
			GameManager.instance.acaboDeSerMaster = false;
		}
	}

	private IEnumerator RecolocarStartMenu()
	{
		yield return new WaitForSeconds(1f);
		InputsController.instance.RecolocarCabeza();
	}

	private void Update()
	{
		bool flag = false;
		if (InputsController.instance.botonRecolocar || flag || (InputsController.instance.botonPausa && GameManager.instance.player.fueraDeLimites))
		{
			InputsController.instance.RecolocarCabeza();
		}
		CalcularVelocidadesDeLosSensores();
		if (roomScale)
		{
			cabeza.transform.localPosition = cabezaPlayerRoomScale.localPosition;
			cabeza.transform.localEulerAngles = cabezaPlayerRoomScale.localEulerAngles;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			if (!Config.tiene2Sensores)
			{
				if (Config.zurdo)
				{
					controladorManoDerecha.mano3D.SetActive(value: false);
					controladorManoIzquierda.mano3D.SetActive(value: true);
				}
				else
				{
					controladorManoDerecha.mano3D.SetActive(value: true);
					controladorManoIzquierda.mano3D.SetActive(value: false);
				}
			}
			else
			{
				controladorManoDerecha.mano3D.SetActive(value: true);
				controladorManoIzquierda.mano3D.SetActive(value: true);
			}
		}
		if (Config.plataforma == Config.PlataformaJuego.Nolo && roomScale)
		{
			cabeza.transform.localPosition = cabezaPlayerRoomScale.localPosition;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && segReinicio > 0f)
		{
			textoIdOnline.gameObject.SetActive(value: true);
			textoIdOnline.text = LanguageManager.instance.DameTexto("#reiniciandoPartida") + " " + (int)segReinicio;
			segReinicio -= Time.unscaledDeltaTime;
		}
		else if (PhotonNetwork.PlayerList.Length >= Config.numJugadoresOnline)
		{
			textoIdOnline.gameObject.SetActive(value: false);
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && (bool)arenaGo && (!arenaGo.gameObject.activeInHierarchy || PartidaSync.instance.jugadores.Count != oldNumPlayers || oldPuntuacionE1 != PartidaSync.instance.puntuacionEquipo1 || oldPuntuacionE2 != PartidaSync.instance.puntuacionEquipo2) && roomScale)
		{
			if (esperaArenaInfo > 3f)
			{
				botonesPausa.SetActive(value: true);
				EncenderInfoArena();
				esperaArenaInfo = 0f;
				oldNumPlayers = PartidaSync.instance.jugadores.Count;
				oldPuntuacionE1 = PartidaSync.instance.puntuacionEquipo1;
				oldPuntuacionE2 = PartidaSync.instance.puntuacionEquipo2;
			}
			esperaArenaInfo += Time.unscaledDeltaTime;
		}
	}

	private void OnDestroy()
	{
		if ((bool)vozPun)
		{
			UnityEngine.Object.Destroy(vozPun);
		}
	}

	private void BuscarReferencias()
	{
		Transform transform = null;
		string text = "Player";
		transform = base.transform.Find(text);
		if ((bool)transform)
		{
			tJugador = transform;
		}
		else
		{
			UnityEngine.Debug.LogError("No se ha encontrado la referencia de: " + text);
		}
		text = "Player/ManoDerecha";
		transform = base.transform.Find(text);
		if ((bool)transform)
		{
			controladorManoDerecha = transform.GetComponent<ControladorMano>();
		}
		else
		{
			UnityEngine.Debug.LogError("No se ha encontrado la referencia de: " + text);
		}
		text = "Player/ManoIzquierda";
		transform = base.transform.Find(text);
		if ((bool)transform)
		{
			controladorManoIzquierda = transform.GetComponent<ControladorMano>();
		}
		else
		{
			UnityEngine.Debug.LogError("No se ha encontrado la referencia de: " + text);
		}
		text = "Player/Cabeza";
		transform = base.transform.Find(text);
		if ((bool)transform)
		{
			cabeza = transform.gameObject;
			return;
		}
		transform = base.transform.Find("Player/CabezaPadre/Cabeza");
		if ((bool)transform)
		{
			cabeza = transform.gameObject;
		}
		else
		{
			UnityEngine.Debug.LogError("No se ha encontrado la referencia de: " + text);
		}
	}

	private void CargarClipsAudio()
	{
		audioClipsPlayer[0] = Resources.Load<AudioClip>("EfectosSonido/muerte");
		audioClipsPlayer[1] = Resources.Load<AudioClip>("EfectosSonido/nivel_pasado");
		audioClipsPlayer[2] = Resources.Load<AudioClip>("EfectosSonido/empezar_nivel");
		audioClipsPlayer[5] = Resources.Load<AudioClip>("EfectosSonido/Rachas/Voz_Cool");
	}

	public bool GetInmortalidad()
	{
		return soyInmortal;
	}

	public void SetInmortalidad(bool valor)
	{
		soyInmortal = valor;
		if (soyInmortal)
		{
			miSyncJugadores.PonermeFantasma();
		}
		else
		{
			miSyncJugadores.PonermeResucitado();
		}
	}

	public int GetPuntos()
	{
		return puntos;
	}

	public void SetPuntos(int nuevosPuntos)
	{
		puntos = nuevosPuntos;
	}

	public void AddPuntos(int puntosGanados)
	{
		puntos += puntosGanados;
	}

	private void CalcularVelocidadesDeLosSensores()
	{
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled && estadoZonaNegra != EstadoZonaNegra.Pausa)
		{
			if (roomScale)
			{
				velManoDerecha = Vector3.Distance(InputsController.instance.posicionSensorR, posAnteriorManoDerecha) * 1000f;
				posAnteriorManoDerecha = InputsController.instance.posicionSensorR;
			}
			else
			{
				velManoDerecha = Vector3.Distance(controladorManoDerecha.transform.position, posAnteriorManoDerecha) * 1000f;
				posAnteriorManoDerecha = controladorManoDerecha.transform.position;
			}
		}
		else
		{
			velManoDerecha = 0f;
			posAnteriorManoDerecha = Vector3.zero;
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled && estadoZonaNegra != EstadoZonaNegra.Pausa)
		{
			if (roomScale)
			{
				velManoIzquierda = Vector3.Distance(InputsController.instance.posicionSensorL, posAnteriorManoIzquierda) * 1000f;
				posAnteriorManoIzquierda = InputsController.instance.posicionSensorL;
			}
			else
			{
				velManoIzquierda = Vector3.Distance(controladorManoIzquierda.transform.position, posAnteriorManoIzquierda) * 1000f;
				posAnteriorManoIzquierda = controladorManoIzquierda.transform.position;
			}
		}
		else
		{
			velManoIzquierda = 0f;
			posAnteriorManoIzquierda = Vector3.zero;
		}
		velCabeza = Vector3.Distance(cabeza.transform.position, posAnteriorCabeza) * 1000f;
		posAnteriorCabeza = cabeza.transform.position;
	}

	public void PonerAudioEnAudioSource(ClipsAudioJugador clipAudio)
	{
		AudioClip audioClip = audioClipsPlayer[(int)clipAudio];
		if (!audioClip)
		{
			UnityEngine.Debug.LogError("OJO!!! AudioClip NULL en Player.cs " + clipAudio);
			return;
		}
		if (!audioSourcePlayer)
		{
			UnityEngine.Debug.LogError("OJO!!! No hay AudioSource en Player.cs");
			return;
		}
		if (audioSourcePlayer.isPlaying)
		{
			UnityEngine.Debug.LogError(string.Concat("OJO!!! Superposicion de audios en AudioSource de Player.cs || Sonando: ", audioSourcePlayer.clip, " nuevo: ", audioClip));
		}
		audioSourcePlayer.clip = audioClip;
		audioSourcePlayer.Play();
	}

	public void Morir(GameObject objeto = null, bool forzarMuerte = false, bool porCabeza = true, bool mano = true, bool morirFinCompetitivo = false)
	{
		if ((muerto && !forzarMuerte && !morirFinCompetitivo) || (inmune && !morirFinCompetitivo) || (GetInmortalidad() && !morirFinCompetitivo) || (Config.modoDeJuego == Config.ModosDeJuego.Offline && !GameManager.instance.m_salaManager.nivelIniciado && !morirFinCompetitivo))
		{
			return;
		}
		objetoMuerte = objeto;
		noPoderMoverse = true;
		SyncBala syncBala = null;
		if ((bool)objetoMuerte)
		{
			syncBala = objetoMuerte.GetComponent<SyncBala>();
			if ((bool)syncBala)
			{
				for (float num = Vector3.Distance(syncBala.transform.position, cabeza.transform.position); num < 0.25f; num = Vector3.Distance(syncBala.transform.position, cabeza.transform.position))
				{
					syncBala.transform.position += -syncBala.transform.forward * 0.03f;
				}
				TrailRenderer componentInChildren = syncBala.GetComponentInChildren<TrailRenderer>();
				if ((bool)componentInChildren)
				{
					List<Vector3> list = new List<Vector3>();
					float num2 = 0f;
					componentInChildren.Clear();
					for (; num2 < 1f; num2 += Time.deltaTime * 5f)
					{
						Vector3 item = Vector3.Lerp(syncBala.posicionDeinstanciamiento, syncBala.transform.position, num2);
						list.Add(item);
					}
					StartCoroutine(ColocarPuntosTrailBala(componentInChildren, list.ToArray()));
				}
				AudioSource component = syncBala.GetComponent<AudioSource>();
				if ((bool)component)
				{
					component.Stop();
				}
			}
			Rigidbody componentInChildren2 = objetoMuerte.GetComponentInChildren<Rigidbody>();
			if ((bool)componentInChildren2)
			{
				componentInChildren2.velocity = Vector3.zero;
			}
		}
		muerto = true;
		noPoderMoverse = true;
		if (Config.modoDePartida != Config.ModoDePartida.Competitivo && !morirFinCompetitivo)
		{
			PonerAudioEnAudioSource(ClipsAudioJugador.Muerte);
		}
		if (!morirFinCompetitivo)
		{
			MuerteComun(forzarMuerte);
		}
		if (Config.modoDeJuego != Config.ModosDeJuego.Online || forzarMuerte || morirFinCompetitivo)
		{
			if (muerte == null)
			{
				muerte = StartCoroutine(EfectoMuerte(porCabeza, mano, morirFinCompetitivo));
			}
		}
		else
		{
			enElLimboCor = StartCoroutine(EsperarEnElLimbo(mano, porCabeza));
		}
	}

	private IEnumerator ColocarPuntosTrailBala(TrailRenderer tr, Vector3[] extraPositions)
	{
		yield return null;
		tr.SetPositions(extraPositions);
	}

	private void MuerteComun(bool forzarMuerte)
	{
		GameManager.instance.m_musica.CambiarMusicaATiempoParado();
		ColisionesJugador[] array = UnityEngine.Object.FindObjectsOfType<ColisionesJugador>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ActivarDesactivarCapsulaPlayer(estado: false);
		}
		miSyncJugadores.PonermeFantasma();
		if (laser == null)
		{
			laser = StartCoroutine(LaserFlechas());
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && !forzarMuerte)
		{
			GameManager.instance.ApagarMeshesDeLasBolasMenosLaQueMeHaMatadoPorUnRato(objetoMuerte);
		}
		PlayerProgreso.instance.rachaDerrotas++;
		PlayerProgreso.instance.rachaVictorias = 0;
	}

	private IEnumerator EsperarEnElLimbo(bool mano, bool porCabeza)
	{
		if (!GameManager.instance.hayEquipoGanador)
		{
			enElLimbo = true;
			TimeManager.instance.tiempoMuerto = true;
			Vibra(TipoVibracion.morir, mano, porCabeza);
			yield return new WaitForSeconds(2f);
			TimeManager.instance.tiempoMuerto = false;
			if (Config.modoDePartida == Config.ModoDePartida.Cooperativo)
			{
				GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.OnlinePlayersMuertos);
			}
			PonerQuitarModoRoomScale(activar: true);
			cabezaRoomScaleScript.DesactivarActivarColliderHabitacion(accion: false);
			yield return new WaitForSeconds(0.1f);
			cabezaRoomScaleScript.ComprobarSiEstaDentro();
			while (cabezaRoomScaleScript.estaFuera)
			{
				yield return new WaitForSeconds(0.1f);
			}
			cabezaRoomScaleScript.DesactivarActivarColliderHabitacion(accion: true);
		}
	}

	private IEnumerator EfectoMuerte(bool porCabeza = true, bool mano = true, bool morirFinCompetitivo = false)
	{
		while (zonaOscuraActivada)
		{
			yield return null;
		}
		enElLimbo = false;
		inmune = true;
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
		}
		GameManager.instance.m_salaManager.ResetPuntosTotales();
		if (PersistentDataManager.GetInt("MensajeUsarPowerUp") == 0 && !PlayerProgreso.instance.PowerUpUsado)
		{
			if (PlayerProgreso.instance.ultimoPaisPasado == GameManager.instance.paisActual && PlayerProgreso.instance.ultimoNivelPasado == GameManager.instance.nivelActual && GameManager.instance.nivelActual != 9)
			{
				PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado = true;
			}
		}
		else
		{
			PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado = false;
			PlayerProgreso.instance.PowerUpUsado = false;
		}
		if ((bool)cabezaRoomScaleScript && (bool)cabezaRoomScaleScript.ColliderHabitacion)
		{
			cabezaRoomScaleScript.ColliderHabitacion.SetActive(value: false);
		}
		if (enElLimboCor != null)
		{
			StopCoroutine(enElLimboCor);
		}
		GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala++;
		if (!morirFinCompetitivo)
		{
			Vibra(TipoVibracion.morir, mano, porCabeza);
		}
		if (Config.modoDePartida != Config.ModoDePartida.Competitivo)
		{
			GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.GameOver);
		}
		TimeManager.instance.tiempoMuerto = true;
		GameManager.instance.m_salaManager.nivelIniciado = false;
		yield return new WaitForSeconds(2f);
		if (estadoZonaNegra == EstadoZonaNegra.Pausa)
		{
			GameManager.instance.player.ActivarDesactiarZonaOscura(activar: false, EstadoZonaNegra.Pausa);
		}
		PonerQuitarModoRoomScale(activar: true);
		if (laser != null)
		{
			StopCoroutine(laser);
			laser = null;
		}
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
		{
			controladorManoDerecha.laser.gameObject.SetActive(value: false);
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
		{
			controladorManoIzquierda.laser.gameObject.SetActive(value: false);
		}
		yield return new WaitForSeconds(0.1f);
		cabezaRoomScaleScript.ComprobarSiEstaDentro();
		while (cabezaRoomScaleScript.estaFuera)
		{
			yield return new WaitForSeconds(0.1f);
		}
		cabezaRoomScaleScript.ColliderHabitacion.SetActive(value: true);
		float seconds = 2f;
		if (Config.plataforma == Config.PlataformaJuego.Nolo)
		{
			seconds = 0.3f;
		}
		yield return new WaitForSeconds(seconds);
		GameManager.instance.EliminarObjetos(null, porVictoria: true);
		NivelCompletado.instance.listaEsferasEquipo1 = new List<Transform>();
		NivelCompletado.instance.listaEsferasEquipo2 = new List<Transform>();
		GameManager.instance.esferasActivas.Clear();
		yield return null;
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Apagar();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Apagar();
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.ApagarRifle();
		}
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Apagar();
		}
		if (!morirFinCompetitivo && Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && (PartidaSync.instance.puntuacionEquipo1 >= PartidaSync.instance.MAXPARTIDASCOMPETITIVO || PartidaSync.instance.puntuacionEquipo2 >= PartidaSync.instance.MAXPARTIDASCOMPETITIVO))
		{
			muerte = null;
			yield break;
		}
		if (!morirFinCompetitivo)
		{
			ReproducirAudioSourceRoomScale(ClipsAudioJugador.DesaparecerGlobalRS);
		}
		yield return new WaitForSeconds(0.7f);
		ReproducirAudioSourceRoomScale(ClipsAudioJugador.AparecerGlobalRS);
		GameManager.instance.player.VolverAPosicionarPistolasEnSuSitio();
		GameManager.instance.hayEquipoGanador = false;
		InputsController.instance.CambiarPlayer();
		PosicionarAlPlayerEnSuSitio();
		ObjetosDelNivel antiguosObjetosNivel = GameManager.instance.m_salaManager.objetosNivelActual;
		GameManager.instance.m_salaManager.CargarSalaNivel(GameManager.instance.nivelActual, muerte: true);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		muerte = null;
		muerto = false;
		TimeManager.instance.tiempoMuerto = false;
		GameManager.instance.m_salaManager.ResetearRacha();
		ColisionesJugador[] array = UnityEngine.Object.FindObjectsOfType<ColisionesJugador>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ActivarDesactivarCapsulaPlayer(estado: true);
		}
		yield return new WaitForSeconds(1f);
		antiguosObjetosNivel.Destruirme();
		segReinicio = 0f;
		yield return new WaitForSeconds(0.5f);
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Encender();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Encender();
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.EncenderRifle();
		}
		GameManager.instance.player.MostrarPistolas();
		InicioNivel.instancia.GetTextPickUpGuns().SetActive(value: true);
		InicioNivel.instancia.ReconocerTextoArmas();
	}

	public void PosicionarAlPlayerEnSuSitio()
	{
		if (corPosicionarPlayer != null)
		{
			StopCoroutine(corPosicionarPlayer);
		}
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			corPosicionarPlayer = StartCoroutine(PosicionarPlayer());
		}
	}

	private IEnumerator PosicionarPlayer()
	{
		Transform puntoSpawn;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = PartidaSync.instance.miJugador.idJuego;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 4)
			{
				num = ((PartidaSync.instance.miJugador.idJuego < 2) ? PartidaSync.instance.miJugador.idJuego : (PartidaSync.instance.miJugador.idJuego + 2));
			}
			puntoSpawn = GameManager.instance.m_salaManager.puntosSpawn[num];
		}
		else
		{
			puntoSpawn = GameManager.instance.m_salaManager.posicionPlayer.transform;
		}
		float t = 0f;
		Vector3 posIni = base.transform.position;
		Vector3 posIniplayer = tJugador.localPosition;
		while (t < 1f && !GameManager.instance.m_salaManager.nivelIniciado)
		{
			base.transform.position = Vector3.Lerp(posIni, puntoSpawn.position, t);
			tJugador.localPosition = Vector3.Lerp(posIniplayer, InputsController.instance.ultimaPosicionPlayer, t);
			t += Time.deltaTime;
			yield return null;
		}
		base.transform.position = puntoSpawn.position;
		tJugador.localPosition = InputsController.instance.ultimaPosicionPlayer;
	}

	private IEnumerator LaserFlechas()
	{
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
		{
			controladorManoDerecha.laser.gameObject.SetActive(value: true);
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
		{
			controladorManoIzquierda.laser.gameObject.SetActive(value: true);
		}
		float tiempo = 4f;
		while (objetoMuerte != null && objetoMuerte.activeInHierarchy && tiempo > 0f)
		{
			if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
			{
				controladorManoDerecha.flecha.LookAt(objetoMuerte.transform);
			}
			if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
			{
				controladorManoDerecha.laser.SetPosition(0, controladorManoDerecha.laser.transform.position);
			}
			if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
			{
				controladorManoDerecha.laser.SetPosition(1, objetoMuerte.transform.position);
			}
			if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
			{
				controladorManoIzquierda.flecha.LookAt(objetoMuerte.transform);
			}
			if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
			{
				controladorManoIzquierda.laser.SetPosition(0, controladorManoIzquierda.laser.transform.position);
			}
			if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
			{
				controladorManoIzquierda.laser.SetPosition(1, objetoMuerte.transform.position);
			}
			tiempo -= Time.deltaTime;
			yield return null;
		}
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled && (bool)controladorManoDerecha.laser)
		{
			controladorManoDerecha.laser.gameObject.SetActive(value: false);
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled && (bool)controladorManoIzquierda.laser)
		{
			controladorManoIzquierda.laser.gameObject.SetActive(value: false);
		}
	}

	public void MostrarPistolas()
	{
		if (mostrarPistolasCor != null)
		{
			StopCoroutine(mostrarPistolasCor);
		}
		mostrarPistolasCor = StartCoroutine(EsperarAMostrarPistolas());
	}

	private IEnumerator EsperarAMostrarPistolas()
	{
		InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: true);
		InicioNivel.GetInstance().SetTextWaitingForPlayers();
		if (padreInicial == null || pistolasPadresInicio == Vector3.zero)
		{
			pistolasPadresInicio = pistolasPadreRoomScale.position;
			padreInicial = pistolasPadreRoomScale.parent;
		}
		else
		{
			pistolasPadreRoomScale.SetParent(padreInicial);
			pistolasPadreRoomScale.position = pistolasPadresInicio;
		}
		pistolasPadre.transform.SetParent(pistolasPadreRoomScale);
		if (Config.zurdo && Config.tipoDeControl == Config.TipoControl.UnaMano)
		{
			pistolasPadre.localPosition = new Vector3(0f, 0f, 0.2f);
			pistolasPadre.localEulerAngles = new Vector3(0f, 180f, 0f);
		}
		else
		{
			pistolasPadre.localPosition = Vector3.zero;
			pistolasPadre.localEulerAngles = Vector3.zero;
		}
		pistolasPadre.localScale = Vector3.one;
		Vector3 position = GameManager.instance.m_salaManager.PantallaDerecha.position;
		position.y = pistolasPadreRoomScale.position.y;
		pistolasPadreRoomScale.position = position;
		position.z = -30f;
		pistolasPadreRoomScale.transform.LookAt(position);
		pistolasPadreRoomScale.position = playerRoomScale.transform.position + pistolasPadreRoomScale.forward * 3f + Vector3.up * 7.2f;
		pistolasPadreRoomScale.SetParent(null);
		Vector3 position2 = pistolasPadreRoomScale.transform.position;
		position2.x = GameManager.instance.m_salaManager.PantallaDerecha.position.x;
		position2.y = GameManager.instance.m_salaManager.PantallaDerecha.position.y - 1.6f;
		position2.z = GameManager.instance.m_salaManager.PantallaDerecha.position.z + 1.2f;
		pistolasPadreRoomScale.position = position2;
		if ((bool)weaponDer)
		{
			weaponDer.Apagar();
		}
		if ((bool)weaponIzq)
		{
			weaponIzq.Apagar();
		}
		if ((bool)rifle)
		{
			rifle.ApagarRifle();
		}
		while (Config.modoDeJuego == Config.ModosDeJuego.Online && PartidaSync.instance.jugadores.Count < Config.numJugadoresOnline)
		{
			yield return new WaitForSeconds(1f);
		}
		if ((bool)weaponDer)
		{
			weaponDer.MostrarPistola();
			weaponDer.animPistola.enabled = true;
			weaponDer.transform.localScale = Vector3.one;
		}
		if ((bool)weaponIzq)
		{
			weaponIzq.MostrarPistola();
			weaponIzq.animPistola.enabled = true;
			weaponIzq.transform.localScale = Vector3.one;
		}
		if ((bool)rifle)
		{
			rifle.MostrarRifle();
			rifle.animPistola.enabled = true;
			rifle.transform.localScale = Vector3.one;
			rifle.transform.localPosition = new Vector3(0.21f, 0f, 0.1f);
			rifle.transform.localEulerAngles = new Vector3(0f, -90f, 0f);
		}
		InicioNivel.GetInstance().SetTextPickUpGuns();
		yield return null;
	}

	public void QuitarTutoPowerup()
	{
		GameManager.instance.esperandoCojerPowerUp = false;
		TimeManager.instance.tiempoMuerto = false;
		if ((bool)GameManager.instance.m_salaManager && (bool)GameManager.instance.m_salaManager.FlechaPowerUp)
		{
			GameManager.instance.m_salaManager.FlechaPowerUp.SetActive(value: false);
		}
		PlayerProgreso.instance.PowerUpUsado = true;
		noPoderMoverse = false;
	}

	public GameObject GetObjetoMuerte()
	{
		return objetoMuerte;
	}

	public void SetObjetoMuerte(GameObject valor)
	{
		objetoMuerte = valor;
	}

	public void ResetRotacionPlayer()
	{
		StartCoroutine(LerrpResetRotacionPadre());
	}

	private IEnumerator LerrpResetRotacionPadre()
	{
		Quaternion rotFin = Quaternion.Euler(InputsController.instance.DesrotarPlayer());
		Quaternion rotIni = tJugador.localRotation;
		float cont = 0f;
		while (cont < 1f)
		{
			tJugador.localRotation = Quaternion.Lerp(rotIni, rotFin, cont);
			cont += Time.deltaTime * 2f;
			yield return null;
		}
	}

	public void VolverAPosicionarPistolasEnSuSitio()
	{
		if ((bool)InicioNivel.GetInstance().GetTextPickUpGuns())
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		controladorManoDerecha.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.EstadoInicialSinArma);
		controladorManoIzquierda.CambiarEstadoMano(ControladorMano.EstadoDeLaMano.EstadoInicialSinArma);
		if ((bool)weaponDer)
		{
			weaponDer.PonerPosicionInicial();
		}
		if ((bool)weaponDer)
		{
			weaponIzq.PonerPosicionInicial();
		}
		if ((bool)rifle)
		{
			rifle.PonerPosicionInicial();
		}
	}

	public void ActivarDesactiarZonaOscura(bool activar, EstadoZonaNegra nuevoEstado = EstadoZonaNegra.Desactivado, bool desdeSalir = false, int porRedIdJugador = -1)
	{
		if (!GameManager.instance || !GameManager.instance.m_salaManager || (activar && muerto))
		{
			return;
		}
		if (!desdeSalir && !GameManager.instance.m_salaManager.nivelIniciado && nuevoEstado == EstadoZonaNegra.Pausa && activar)
		{
			Salir();
		}
		else
		{
			if (nuevoEstado == EstadoZonaNegra.Pausa && (menu || (!desdeSalir && !GameManager.instance.m_salaManager.nivelIniciado && activar)))
			{
				return;
			}
			bool flag = false;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && nuevoEstado != EstadoZonaNegra.FueraLimites && GameManager.instance.m_salaManager.nivelIniciado)
			{
				if (activar && estadoZonaNegra != EstadoZonaNegra.Pausa && idJugadorQueHaPuestoPausa == -1 && porRedIdJugador == -1)
				{
					PartidaSync.instance.Pausad(estado: true, PartidaSync.instance.miJugador.idJuego);
					idJugadorQueHaPuestoPausa = PartidaSync.instance.miJugador.idJuego;
				}
				else if (activar && estadoZonaNegra != EstadoZonaNegra.Pausa && idJugadorQueHaPuestoPausa != -1 && porRedIdJugador != -1)
				{
					idJugadorQueHaPuestoPausa = porRedIdJugador;
				}
				else if (!activar && idJugadorQueHaPuestoPausa == PartidaSync.instance.miJugador.idJuego)
				{
					PartidaSync.instance.Pausad(estado: false, PartidaSync.instance.miJugador.idJuego);
				}
				else if (!activar && porRedIdJugador == -1)
				{
					return;
				}
				if (activar && PartidaSync.instance.miJugador.idJuego != porRedIdJugador && porRedIdJugador != -1)
				{
					flag = true;
					textJugQueHaPuestoPausa.gameObject.SetActive(value: true);
					idJugadorQueHaPuestoPausa = porRedIdJugador;
					string nombre = PartidaSync.instance.jugadores[idJugadorQueHaPuestoPausa].nombre;
					textJugQueHaPuestoPausa.text = LanguageManager.instance.DameTexto("#EsperandoJugadorPausa") + " " + nombre;
					textJugQueHaPuestoPausa.font = LanguageManager.instance.GetFuentePro();
				}
			}
			zonaOscura.transform.position = InputsController.instance.head.position;
			if (!activar)
			{
				estadoZonaNegra = EstadoZonaNegra.Desactivado;
			}
			else
			{
				estadoZonaNegra = nuevoEstado;
			}
			if (nuevoEstado == EstadoZonaNegra.Pausa)
			{
				if (!GameManager.instance.esperandoCojerPowerUp)
				{
					TimeManager.instance.tiempoMuerto = activar;
				}
				if (activar)
				{
					PonerQuitarModoRoomScale(activar: true);
					GameManager.instance.player.noPoderMoverse = true;
					botonesPausa.SetActive(value: true);
					GameObject[] array = botonesPausaArray;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: true);
					}
					if (flag)
					{
						botonesPausaArray[0].SetActive(value: false);
					}
					botonesPausa.transform.SetParent(null);
					if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
					{
						botonesPausa.transform.position = new Vector3(0f, 1.25f, 1.68f);
					}
					else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
					{
						botonesPausa.transform.position = new Vector3(0.8f, 1.25f, 3.12f);
						botonesPausa.transform.localScale = new Vector3(0.0224f, 0.0224f, 0.0224f);
					}
					else
					{
						botonesPausa.transform.position = new Vector3(0f, 1.25f, 0.383f);
					}
					botonesPausa.transform.eulerAngles = Vector3.zero;
					GameManager.instance.player.controladorManoDerecha.manoRoomScale.animManoRS.MenuSeñalar();
					GameManager.instance.player.controladorManoIzquierda.manoRoomScale.animManoRS.MenuSeñalar();
					if ((bool)controladorManoDerecha)
					{
						laserManoDRoomScale.GetComponent<ManoLaser>().noApagar = true;
						laserManoDRoomScale.SetActive(value: true);
					}
					if ((bool)controladorManoIzquierda)
					{
						laserManoIRoomScale.GetComponent<ManoLaser>().noApagar = true;
						laserManoIRoomScale.SetActive(value: true);
					}
				}
				else
				{
					if (!desdeSalir && GameManager.instance.m_salaManager.nivelIniciado)
					{
						PonerQuitarModoRoomScale(activar: false);
					}
					textJugQueHaPuestoPausa.gameObject.SetActive(value: false);
					GameManager.instance.player.noPoderMoverse = false;
					idJugadorQueHaPuestoPausa = -1;
					if (!desdeSalir)
					{
						botonesPausa.SetActive(value: false);
						botonesPausa.transform.SetParent(base.transform);
					}
					GameObject[] array = botonesPausaArray;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
					if ((bool)controladorManoDerecha)
					{
						laserManoDRoomScale.SetActive(value: false);
					}
					if ((bool)controladorManoIzquierda)
					{
						laserManoIRoomScale.SetActive(value: false);
					}
				}
				return;
			}
			if (!activar && nuevoEstado == EstadoZonaNegra.Desactivado)
			{
				PonerQuitarModoRoomScale(activar: false);
				GameManager.instance.player.noPoderMoverse = false;
				botonesPausa.SetActive(value: false);
				botonesPausa.transform.SetParent(base.transform);
				if ((bool)controladorManoDerecha)
				{
					laserManoDRoomScale.SetActive(value: false);
				}
				if ((bool)controladorManoIzquierda)
				{
					laserManoIRoomScale.SetActive(value: false);
				}
				GameManager.instance.player.fueraDeLimites = false;
			}
			if (zonaOscuraActivada == activar)
			{
				return;
			}
			zonaOscuraActivada = activar;
			zonaOscura.SetActive(activar);
			if (!menu && !GameManager.instance.esperandoCojerPowerUp)
			{
				TimeManager.instance.tiempoMuerto = activar;
			}
			Camera[] componentsInChildren = cabeza.GetComponentsInChildren<Camera>();
			if (activar)
			{
				inmune = true;
				zonaOscura.transform.GetChild(0).gameObject.SetActive(value: true);
				Camera[] array2 = componentsInChildren;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].cullingMask = cabezaRoomScaleScript.layerLimites;
				}
				if ((bool)GameManager.instance.liv)
				{
					GameManager.instance.liv.SpectatorLayerMask = cabezaRoomScaleScript.layerLimites;
				}
				cabezaRoomScaleScript.cuboGrandeLimites.transform.SetParent(null);
				cabezaRoomScaleScript.cuboGrandeLimites.SetActive(value: true);
				huellas.SetActive(value: true);
				GameManager.instance.player.fueraDeLimites = true;
			}
			else
			{
				inmune = false;
				GameManager.instance.player.fueraDeLimites = false;
				GameManager.instance.player.noPoderMoverse = false;
				zonaOscura.transform.GetChild(0).gameObject.SetActive(value: false);
				Camera[] array2 = componentsInChildren;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].cullingMask = cabezaRoomScaleScript.layerNormal;
				}
				cabezaRoomScaleScript.cuboGrandeLimites.SetActive(value: false);
				if ((bool)GameManager.instance.liv)
				{
					GameManager.instance.liv.SpectatorLayerMask = -1;
				}
				huellas.SetActive(value: false);
			}
		}
	}

	public void Empezar()
	{
		inmune = false;
		muerto = false;
		if (corInmortalidad != null)
		{
			StopCoroutine(corInmortalidad);
		}
		GameManager.instance.m_musica.MusicaInmortal(activar: false);
		SetInmortalidad(valor: false);
		enElLimbo = false;
		if (PhotonNetwork.IsMasterClient)
		{
			foreach (int key in PartidaSync.instance.jugadores.Keys)
			{
				PartidaSync.instance.jugadores[key].estaMuerto = false;
			}
			PartidaSync.instance.RefrescarListaJugadores(forzarRefresco: true);
		}
		PonerQuitarModoRoomScale(activar: false);
	}

	private IEnumerator ActivarLaserZonaOscura()
	{
		yield return new WaitForSeconds(0.5f);
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled && (bool)controladorManoDerecha.animManos)
		{
			controladorManoDerecha.animManos.MenuSeñalar();
		}
		if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
		{
			controladorManoDerecha.laserDedo.gameObject.SetActive(value: true);
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled && (bool)controladorManoIzquierda.animManos)
		{
			controladorManoIzquierda.animManos.MenuSeñalar();
		}
		if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
		{
			controladorManoIzquierda.laserDedo.gameObject.SetActive(value: true);
		}
		ponerLaser = null;
	}

	private IEnumerator IndicarSala()
	{
		Transform flecha = zonaOscura.transform.GetChild(1);
		while (true)
		{
			flecha.LookAt(GameManager.instance.m_salaManager.posicionPlayer.transform);
			flecha.localEulerAngles = new Vector3(0f, flecha.localEulerAngles.y, 0f);
			yield return new WaitForSeconds(0.05f);
		}
	}

	public void SerInmortalPorXSegundos(float segundos)
	{
		miSyncJugadores.PonermeFantasma();
		soyInmortal = true;
		GameManager.instance.m_musica.MusicaInmortal(activar: true);
		if (corInmortalidad != null)
		{
			StopCoroutine(corInmortalidad);
		}
		if (segundos != -1f)
		{
			corInmortalidad = StartCoroutine(QuitarInmortalidad(segundos));
		}
	}

	public void QuitarInmortalidad()
	{
		miSyncJugadores.PonermeResucitado();
		soyInmortal = false;
		GameManager.instance.m_musica.MusicaInmortal(activar: false);
		if (corInmortalidad != null)
		{
			StopCoroutine(corInmortalidad);
		}
	}

	public void QuitarInmortalidadConCoroutina(float tiempo)
	{
		StartCoroutine(QuitarInmortalidad(tiempo));
	}

	private IEnumerator QuitarInmortalidad(float segundos)
	{
		yield return new WaitForSeconds(segundos);
		miSyncJugadores.PonermeResucitado();
		GameManager.instance.m_musica.MusicaInmortal(activar: false);
		yield return new WaitForSeconds(1f);
		soyInmortal = false;
	}

	public void Continuar()
	{
		ActivarDesactiarZonaOscura(activar: false, EstadoZonaNegra.Pausa);
	}

	public void Reiniciar()
	{
		if (Config.modoDeJuego != Config.ModosDeJuego.Online)
		{
			muerto = true;
			noPoderMoverse = true;
			GameManager.instance.m_musica.CambiarMusicaATiempoParado();
			if ((bool)GameManager.instance.player.weaponDer)
			{
				GameManager.instance.player.weaponDer.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
			}
			if ((bool)GameManager.instance.player.weaponIzq)
			{
				GameManager.instance.player.weaponIzq.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
			}
			TimeManager.instance.tiempoMuerto = true;
			GameManager.instance.m_salaManager.nivelIniciado = false;
			GameManager.instance.player.controladorManoDerecha.manoRoomScale.animManoRS.MenuNormal();
			GameManager.instance.player.controladorManoIzquierda.manoRoomScale.animManoRS.MenuNormal();
			estadoZonaNegra = EstadoZonaNegra.Desactivado;
			GameManager.instance.player.noPoderMoverse = false;
			botonesPausa.SetActive(value: false);
			botonesPausa.transform.SetParent(base.transform);
			if ((bool)controladorManoDerecha)
			{
				laserManoDRoomScale.SetActive(value: false);
			}
			if ((bool)controladorManoIzquierda)
			{
				laserManoIRoomScale.SetActive(value: false);
			}
			if (laser != null)
			{
				StopCoroutine(laser);
				laser = null;
			}
			if ((bool)controladorManoDerecha && controladorManoDerecha.enabled)
			{
				controladorManoDerecha.laser.gameObject.SetActive(value: false);
			}
			if ((bool)controladorManoIzquierda && controladorManoIzquierda.enabled)
			{
				controladorManoIzquierda.laser.gameObject.SetActive(value: false);
			}
			PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado = false;
			StartCoroutine(Reinicio());
		}
		else
		{
			PartidaSync.instance.Reiniciar();
		}
	}

	private IEnumerator Reinicio()
	{
		yield return new WaitForSeconds(1f);
		GameManager.instance.EliminarObjetos(null, porVictoria: true);
		NivelCompletado.instance.listaEsferasEquipo1 = new List<Transform>();
		NivelCompletado.instance.listaEsferasEquipo2 = new List<Transform>();
		GameManager.instance.esferasActivas.Clear();
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Apagar();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Apagar();
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.ApagarRifle();
		}
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Apagar();
		}
		ReproducirAudioSourceRoomScale(ClipsAudioJugador.DesaparecerGlobalRS);
		yield return new WaitForSeconds(0.7f);
		ReproducirAudioSourceRoomScale(ClipsAudioJugador.AparecerGlobalRS);
		GameManager.instance.player.VolverAPosicionarPistolasEnSuSitio();
		GameManager.instance.hayEquipoGanador = false;
		InputsController.instance.CambiarPlayer();
		PosicionarAlPlayerEnSuSitio();
		ObjetosDelNivel antiguosObjetosNivel = GameManager.instance.m_salaManager.objetosNivelActual;
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Encender();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Encender();
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.EncenderRifle();
		}
		GameManager.instance.m_salaManager.CargarSalaNivel(GameManager.instance.nivelActual, muerte: true);
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		GameManager.instance.player.MostrarPistolas();
		InicioNivel.instancia.GetTextPickUpGuns().SetActive(value: true);
		InicioNivel.instancia.ReconocerTextoArmas();
		muerte = null;
		muerto = false;
		TimeManager.instance.tiempoMuerto = false;
		GameManager.instance.m_salaManager.ResetearRacha();
		ColisionesJugador[] array = UnityEngine.Object.FindObjectsOfType<ColisionesJugador>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ActivarDesactivarCapsulaPlayer(estado: true);
		}
		yield return new WaitForSeconds(1f);
		antiguosObjetosNivel.Destruirme();
	}

	public void Salir()
	{
		if (estadoZonaNegra != EstadoZonaNegra.Pausa)
		{
			ActivarDesactiarZonaOscura(activar: true, EstadoZonaNegra.Pausa, desdeSalir: true);
		}
		botonesSalir.SetActive(value: true);
		GameObject[] array = botonesPausaArray;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		textoIdOnline.gameObject.SetActive(value: false);
		ApagarInfoArena();
		pD = pistolaRoomScaleFakeD.activeInHierarchy;
		pI = pistolaRoomScaleFakeI.activeInHierarchy;
		rD = rifleRommScaleFakeD.activeInHierarchy;
		rI = rifleRommScaleFakeI.activeInHierarchy;
		pistolaRoomScaleFakeD.SetActive(value: false);
		pistolaRoomScaleFakeI.SetActive(value: false);
		rifleRommScaleFakeD.SetActive(value: false);
		rifleRommScaleFakeI.SetActive(value: false);
		enConfirmacionDeSalir = true;
	}

	private void EncenderInfoArena()
	{
		arenaGo.gameObject.SetActive(value: true);
		string text = "";
		string text2 = "";
		puntuacionArenaE1.text = PartidaSync.instance.puntuacionEquipo1.ToString();
		puntuacionArenaE2.text = PartidaSync.instance.puntuacionEquipo2.ToString();
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key].equipo == 1)
			{
				text = text + PartidaSync.instance.jugadores[key].nombre + "<br>";
			}
			else
			{
				text2 = text2 + PartidaSync.instance.jugadores[key].nombre + "<br>";
			}
		}
		miembrosEquipo1.text = text;
		miembrosquipo2.text = text2;
	}

	private void ApagarInfoArena()
	{
		arenaGo.gameObject.SetActive(value: false);
	}

	public void SalirDefinitivamente()
	{
		GameManager.instance.CargarMenu();
	}

	public void NoSalir()
	{
		botonesSalir.SetActive(value: false);
		GameObject[] array = botonesPausaArray;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (Config.modoDePartida == Config.ModoDePartida.Competitivo && PhotonNetwork.PlayerList.Length >= Config.numJugadoresOnline)
			{
				EncenderInfoArena();
			}
			else
			{
				textoIdOnline.gameObject.SetActive(value: true);
			}
		}
		if (!GameManager.instance.m_salaManager.nivelIniciado)
		{
			ActivarDesactiarZonaOscura(activar: false, EstadoZonaNegra.Pausa, desdeSalir: true);
		}
		pistolaRoomScaleFakeD.SetActive(pD);
		pistolaRoomScaleFakeI.SetActive(pI);
		rifleRommScaleFakeD.SetActive(rD);
		rifleRommScaleFakeI.SetActive(rI);
		enConfirmacionDeSalir = false;
	}

	private void OnDisable()
	{
		GameManager.instance.hayEquipoGanador = false;
	}

	public void ReproducirAudioSourceRoomScale(ClipsAudioJugador clipAudio)
	{
		if (clipAudio == ClipsAudioJugador.AparecerGlobalRS)
		{
			audioSourceRoomScaleAparecer.Play();
		}
		else
		{
			audioSourceRoomScaleDesaparecer.Play();
		}
	}

	public void PonerQuitarModoRoomScale(bool activar, bool porInicioDeNivel = false)
	{
		if (Config.plataforma != Config.PlataformaJuego.Pico)
		{
			_ = Config.plataforma;
			_ = 4;
		}
		if (activar)
		{
			if (roomScale)
			{
				return;
			}
			if (Config.modoDeJuego == Config.ModosDeJuego.Online)
			{
				botonesPausa.SetActive(value: true);
				botonesPausa.transform.SetParent(null);
				float z = 0.383f;
				if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
				{
					z = 1.68f;
					botonesPausa.transform.position = new Vector3(0f, 1.25f, z);
				}
				else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline > 2)
				{
					z = 3.12f;
					botonesPausa.transform.position = new Vector3(0.8f, 1.25f, 3.12f);
					botonesPausa.transform.localScale = new Vector3(0.0224f, 0.0224f, 0.0224f);
				}
				else
				{
					botonesPausa.transform.position = new Vector3(0f, 1.25f, z);
				}
				botonesPausa.transform.eulerAngles = Vector3.zero;
				GameObject[] array = botonesPausaArray;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
				if (Config.modoDePartida == Config.ModoDePartida.Competitivo && PhotonNetwork.PlayerList.Length >= Config.numJugadoresOnline)
				{
					EncenderInfoArena();
				}
				else
				{
					textoIdOnline.gameObject.SetActive(value: true);
					textoIdOnline.text = LanguageManager.instance.DameTexto("#RoomId") + ": " + PhotonNetwork.versionPUNPartida;
					textoIdOnline.font = LanguageManager.instance.GetFuentePro();
				}
				if ((bool)speaker)
				{
					speaker.transform.SetParent(cabezaPlayerRoomScale);
					speaker.transform.position = Vector3.zero;
				}
			}
			else
			{
				textoIdOnline.gameObject.SetActive(value: false);
				ApagarInfoArena();
			}
			if (Config.plataforma != Config.PlataformaJuego.Pico)
			{
				_ = Config.plataforma;
				_ = 4;
			}
			collidersLimitesRoomScale.SetParent(null);
			collidersLimitesRoomScale.localPosition = Vector3.zero;
			collidersLimitesRoomScale.localEulerAngles = Vector3.zero;
			collidersLimitesRoomScale.localScale = Vector3.one;
			collidersLimitesRoomScale.gameObject.SetActive(value: true);
			if (estadoZonaNegra != EstadoZonaNegra.Pausa)
			{
				GameManager.instance.player.controladorManoDerecha.manoRoomScale.animManoRS.MenuNormal();
				GameManager.instance.player.controladorManoIzquierda.manoRoomScale.animManoRS.MenuNormal();
			}
			tiempoDesdeQueHeSubidoHastaQuePuedoBajar = Time.time;
			GameManager.instance.player.noPoderMoverse = true;
			if (porInicioDeNivel)
			{
				GameManager.instance.player.pararTiempo = true;
			}
			roomScale = true;
			if (Config.plataforma != Config.PlataformaJuego.Pico)
			{
				cabeza.GetComponent<Camera>().enabled = false;
			}
			cabeza.GetComponent<AudioListener>().enabled = false;
			posIniPantallaDerecha = GameManager.instance.m_salaManager.PantallaDerecha.localPosition;
			escalaIniPantallaDerecha = GameManager.instance.m_salaManager.PantallaDerecha.localScale;
			float z2 = 1.61f;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				z2 = 2.8f;
			}
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
			{
				GameManager.instance.m_salaManager.PantallaDerecha.localPosition = new Vector3(1.34f, 1.42f, z2);
				GameManager.instance.m_salaManager.PantallaDerecha.localScale = new Vector3(0.1199f, -0.023f, 0.1176f);
			}
			else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline > 2)
			{
				GameManager.instance.m_salaManager.PantallaDerecha.localPosition = new Vector3(1.04f, 0.918f, z2);
				GameManager.instance.m_salaManager.PantallaDerecha.localScale = new Vector3(0.1111f, -0.023f, 0.14f);
			}
			else
			{
				GameManager.instance.m_salaManager.PantallaDerecha.localPosition = new Vector3(1.04f, 0.918f, z2);
				GameManager.instance.m_salaManager.PantallaDerecha.localScale = new Vector3(0.0741f, -0.023f, 0.0826f);
			}
			playerRoomScale.gameObject.SetActive(value: true);
			playerRoomScale.SetParent(null);
			Vector3 position = playerRoomScale.transform.position;
			position.x = GameManager.instance.m_salaManager.PantallaDerecha.position.x;
			playerRoomScale.transform.position = position;
			cabezaMuñecoAbajo.transform.parent.gameObject.SetActive(value: true);
			z2 = 2f;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				z2 = 3.22f;
			}
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
			{
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localPosition = new Vector3(1.24f, -1.16f, z2);
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localScale = new Vector3(0.342f, 0.328f, -0.219f);
			}
			else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline > 2)
			{
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localPosition = new Vector3(1.02f, -0.66f, z2);
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localScale = new Vector3(0.29f, 0.279f, -0.219f);
			}
			else
			{
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localPosition = new Vector3(0.98f, -0.66f, z2);
				GameManager.instance.m_salaManager.frentePantallaIzquierda.localScale = new Vector3(0.225f, 0.219f, -0.219f);
			}
			posIniTutoDerecho = tutorialDerecho.localPosition;
			posIniTutoIzquierdo = tutorialIzquierdo.localPosition;
			escalaTutoD = tutorialDerecho.localScale;
			escalaTutoI = tutorialIzquierdo.localScale;
			if (!audioSorucesDerecha)
			{
				audioSorucesDerecha = tutorialDerecho.parent.Find("AudioSource");
			}
			if (!audioSorucesIzquierda)
			{
				audioSorucesIzquierda = tutorialIzquierdo.parent.Find("AudioSource");
			}
			audioSorucesDerecha.SetParent(padreFakeTutorialDerecho);
			audioSorucesDerecha.localPosition = Vector3.zero;
			audioSorucesDerecha.localScale = Vector3.one;
			AudioSource[] components = audioSorucesDerecha.GetComponents<AudioSource>();
			for (int j = 0; j < components.Length; j++)
			{
				components[j].maxDistance = 5f;
			}
			audioSorucesIzquierda.SetParent(padreFakeTutorialIzquuierdo);
			audioSorucesIzquierda.localPosition = Vector3.zero;
			audioSorucesIzquierda.localScale = Vector3.one;
			AudioSource[] components2 = audioSorucesIzquierda.GetComponents<AudioSource>();
			for (int k = 0; k < components2.Length; k++)
			{
				components2[k].maxDistance = 5f;
			}
			tutorialDerecho.SetParent(padreFakeTutorialDerecho);
			tutorialDerecho.localPosition = Vector3.zero;
			tutorialDerecho.localScale = Vector3.one;
			tutorialIzquierdo.SetParent(padreFakeTutorialIzquuierdo);
			tutorialIzquierdo.localPosition = Vector3.zero;
			tutorialIzquierdo.localScale = Vector3.one;
			cajaNegra.SetActive(value: true);
			cajaNegra.transform.SetParent(null);
			cajaNegra.transform.position = new Vector3(-5.5f, 1.6f, 3.8f);
			cajaNegra.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
			{
				cajaNegra.transform.localScale = new Vector3(40f, 21f, 21f);
				cajaNegra.transform.position = new Vector3(-6f, 1.6f, 6.62f);
			}
			else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 4)
			{
				cajaNegra.transform.localScale = new Vector3(36.3f, 29.04f, 30.949f);
				cajaNegra.transform.position = new Vector3(-7.5f, 1.6f, 3.8f);
			}
			else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 8)
			{
				cajaNegra.transform.localScale = new Vector3(36.3f, 29.04f, 30.949f);
				cajaNegra.transform.position = new Vector3(-7.5f, 1.6f, 3.8f);
			}
			if ((bool)GameManager.instance.neoGigante)
			{
				GameManager.instance.neoGigante.enabled = false;
			}
			audioSourcesRoomScale.SetParent(null);
			audioSourcesRoomScale.position = GameManager.instance.m_salaManager.PantallaDerecha.position;
			if ((bool)GameManager.instance.m_salaManager.puntoLuzSala)
			{
				GameManager.instance.m_salaManager.puntoLuzSala.gameObject.SetActive(value: false);
			}
			if (PlayerProgreso.instance.tengoLIVActivado)
			{
				PlayerProgreso.instance.liv.camaraLiv.transform.parent.parent = playerRoomScale;
				PlayerProgreso.instance.liv.camaraLiv.transform.parent.position = playerRoomScale.Find("Cabeza").position;
			}
			RecolocarCabezaRoomScale();
		}
		else
		{
			if (!roomScale)
			{
				return;
			}
			if (estadoZonaNegra == EstadoZonaNegra.Pausa)
			{
				ActivarDesactiarZonaOscura(activar: false, EstadoZonaNegra.Pausa, desdeSalir: true);
			}
			botonesPausa.SetActive(value: false);
			botonesSalir.SetActive(value: false);
			collidersLimitesRoomScale.gameObject.SetActive(value: false);
			GameManager.instance.player.noPoderMoverse = false;
			GameManager.instance.player.pararTiempo = false;
			GameManager.instance.player.muerto = false;
			roomScale = false;
			idJugadorQueHaPuestoPausa = -1;
			_ = Config.plataforma;
			_ = 4;
			if (Config.plataforma != Config.PlataformaJuego.Pico)
			{
				cabeza.GetComponent<Camera>().enabled = true;
			}
			cabeza.GetComponent<AudioListener>().enabled = true;
			playerRoomScale.gameObject.SetActive(value: false);
			cabezaMuñecoAbajo.transform.parent.gameObject.SetActive(value: false);
			Vector3 localPosition = new Vector3(1.0368f, -0.922f, 1.664f);
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				localPosition = new Vector3(1.32f, -1.2f, 2.94f);
			}
			GameManager.instance.m_salaManager.frentePantallaIzquierda.localPosition = localPosition;
			localPosition = new Vector3(0.24816f, 0.24816f, 0.24816f);
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				localPosition = new Vector3(0.378259f, 0.3530283f, 0.3739644f);
			}
			GameManager.instance.m_salaManager.frentePantallaIzquierda.localScale = localPosition;
			if (escalaIniPantallaDerecha != Vector3.zero)
			{
				GameManager.instance.m_salaManager.PantallaDerecha.localPosition = posIniPantallaDerecha;
			}
			if (escalaIniPantallaDerecha != Vector3.zero)
			{
				GameManager.instance.m_salaManager.PantallaDerecha.localScale = escalaIniPantallaDerecha;
			}
			try
			{
				audioSorucesDerecha.SetParent(padreOriginalTutorialDerecho);
				audioSorucesDerecha.localPosition = posIniTutoDerecho;
				audioSorucesDerecha.localScale = escalaTutoD;
				AudioSource[] components3 = audioSorucesDerecha.GetComponents<AudioSource>();
				for (int l = 0; l < components3.Length; l++)
				{
					components3[l].maxDistance = 1f;
				}
				audioSorucesIzquierda.SetParent(padreOriginalTutorialIzquierdo);
				audioSorucesIzquierda.localPosition = posIniTutoIzquierdo;
				audioSorucesIzquierda.localScale = escalaTutoI;
				AudioSource[] components4 = audioSorucesIzquierda.GetComponents<AudioSource>();
				for (int m = 0; m < components4.Length; m++)
				{
					components4[m].maxDistance = 1f;
				}
			}
			catch
			{
			}
			if (PlayerProgreso.instance.tengoLIVActivado)
			{
				PlayerProgreso.instance.liv.camaraLiv.transform.parent.parent = cabeza.transform.parent;
				PlayerProgreso.instance.liv.camaraLiv.transform.parent.position = cabeza.transform.position;
			}
			tutorialDerecho.SetParent(padreOriginalTutorialDerecho);
			tutorialDerecho.localPosition = posIniTutoDerecho;
			tutorialDerecho.localScale = escalaTutoD;
			tutorialIzquierdo.SetParent(padreOriginalTutorialIzquierdo);
			tutorialIzquierdo.localPosition = posIniTutoIzquierdo;
			tutorialIzquierdo.localScale = escalaTutoI;
			cajaNegra.SetActive(value: false);
			if ((bool)GameManager.instance.neoGigante)
			{
				GameManager.instance.neoGigante.enabled = true;
			}
			pistolaRoomScaleFakeD.SetActive(value: false);
			pistolaRoomScaleFakeI.SetActive(value: false);
			rifleRommScaleFakeD.SetActive(value: false);
			rifleRommScaleFakeI.SetActive(value: false);
			if ((bool)GameManager.instance.m_salaManager.puntoLuzSala)
			{
				GameManager.instance.m_salaManager.puntoLuzSala.gameObject.SetActive(value: true);
			}
			_ = Config.plataforma;
			_ = 3;
			if ((bool)speaker)
			{
				speaker.transform.SetParent(cabeza.transform);
				speaker.transform.position = Vector3.zero;
			}
		}
	}

	private void OnEnable()
	{
		if (haDeRecolocarse)
		{
			StartCoroutine(Recolocar());
		}
	}

	public void RecolocarCabezaRoomScale()
	{
		if ((bool)playerRoomScale)
		{
			playerRoomScale.SetParent(null);
			Vector3 position = GameManager.instance.m_salaManager.PantallaDerecha.position;
			float num = ((estadoZonaNegra == EstadoZonaNegra.Pausa) ? 1 : 0);
			posInicialPlayerRoomScale.position = new Vector3(position.x, position.y + 1f, position.z + 2.2f + num);
			playerRoomScale.position = posInicialPlayerRoomScale.position;
			if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
			{
				StartCoroutine(Recolocar());
			}
			else
			{
				haDeRecolocarse = true;
			}
		}
	}

	private IEnumerator Recolocar()
	{
		haDeRecolocarse = false;
		yield return null;
		playerRoomScale.localEulerAngles = GameManager.instance.ultimaRotacionCabeza;
		playerRoomScale.Rotate(Vector3.up * 180f, Space.World);
		Transform transform;
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			int num = PartidaSync.instance.miJugador.idJuego;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 4)
			{
				num = ((PartidaSync.instance.miJugador.idJuego < 2) ? PartidaSync.instance.miJugador.idJuego : (PartidaSync.instance.miJugador.idJuego + 2));
			}
			transform = GameManager.instance.m_salaManager.puntosSpawn[num];
		}
		else
		{
			transform = GameManager.instance.m_salaManager.posicionPlayer.transform;
		}
		Vector3 position = transform.position;
		_ = InputsController.instance.ultimaPosicionPlayer;
		Vector3 localPosition = tJugador.transform.localPosition;
		tJugador.localPosition = InputsController.instance.ultimaPosicionPlayer;
		Vector3 vector = (tJugador.transform.position - cabeza.transform.position) * 5f;
		Vector3 vector2 = (position - tJugador.transform.position) * 5f;
		Vector3 vector3 = vector + vector2;
		float angle = Vector3.SignedAngle(tJugador.forward, playerRoomScale.forward, Vector3.up);
		vector = Quaternion.AngleAxis(angle, Vector3.up) * vector;
		vector3 = Quaternion.AngleAxis(angle, Vector3.up) * vector3;
		playerRoomScale.transform.position += vector - vector3;
		tJugador.localPosition = localPosition;
	}

	public ControladorVRPico GetControladorVRPico()
	{
		return controladorPico;
	}

	public ControladorVRNolo GetControladorVRNolo()
	{
		return controladorNolo;
	}

	private void InicioVariablesVibracion()
	{
		if (Config.plataforma == Config.PlataformaJuego.SteamVR)
		{
			controladorSteam = (ControladorVRSteam)InputsController.instance.controladorVR;
		}
		if (Config.plataforma == Config.PlataformaJuego.Oculus)
		{
			controladorOculus = (ControladorVROculus)InputsController.instance.controladorVR;
		}
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			controladorPico = (ControladorVRPico)InputsController.instance.controladorVR;
		}
		if (Config.plataforma == Config.PlataformaJuego.Nolo)
		{
			controladorNolo = (ControladorVRNolo)InputsController.instance.controladorVR;
		}
	}

	public void Vibra(TipoVibracion tipoVibracion, bool mano = true, bool doble = false)
	{
		if (GameManager.instance.vibracionHabilitada)
		{
			tipoVibracionActual = tipoVibracion;
			switch (tipoVibracion)
			{
			case TipoVibracion.ninguno:
				PararVibracion();
				break;
			case TipoVibracion.disparar:
				Disparar(0.1f, mano, doble);
				break;
			case TipoVibracion.lanzarGancho:
				LanzarGancho(0.2f, mano, doble);
				break;
			case TipoVibracion.cogerPistolas:
				CogerPistolas(0.1f, mano);
				break;
			case TipoVibracion.morir:
				Muerte(0.5f, mano, doble);
				break;
			case TipoVibracion.pasarseLivel:
				PasarNivel(0.5f, mano);
				break;
			case TipoVibracion.rebotarBala:
				break;
			}
		}
	}

	public void Disparar(float duration, bool lado, bool doble)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			if (doble)
			{
				controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 0);
				controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 1);
			}
			else if (lado)
			{
				controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 1);
			}
			else
			{
				controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 0);
			}
		}
		else
		{
			PararVibracion();
			vibracion = StartCoroutine(Vibracion(duration, lado, 500, doble));
		}
	}

	public void LanzarGancho(float duration, bool lado, bool doble)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			if (doble)
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 0);
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 1);
			}
			else if (lado)
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 1);
			}
			else
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 0);
			}
		}
		else
		{
			PararVibracion();
			vibracion = StartCoroutine(Vibracion(duration, lado, 1000, doble));
		}
	}

	public void CogerPistolas(float duration, bool lado)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			if (lado)
			{
				controladorPico.Vibracion(0.4f, (int)(duration * 1000f), 1);
			}
			else
			{
				controladorPico.Vibracion(0.4f, (int)(duration * 1000f), 0);
			}
		}
		else
		{
			PararVibracion();
			vibracion = StartCoroutine(Vibracion(duration, lado, 400));
		}
	}

	public void Muerte(float duration, bool lado, bool doble)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			if (doble)
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 0);
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 1);
			}
			else if (lado)
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 1);
			}
			else
			{
				controladorPico.Vibracion(1f, (int)(duration * 1000f), 0);
			}
		}
		else
		{
			PararVibracion();
			vibracion = StartCoroutine(Vibracion(duration, lado, 1000, doble));
		}
	}

	public void PasarNivel(float duration, bool lado)
	{
		if (Config.plataforma == Config.PlataformaJuego.Pico)
		{
			controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 0);
			controladorPico.Vibracion(0.5f, (int)(duration * 1000f), 1);
			return;
		}
		if (vibracionIniciada)
		{
			PararVibracion();
		}
		vibracion = StartCoroutine(Vibracion(duration, lado, 500, dosMandos: true));
	}

	public void PararVibracion()
	{
	}

	private IEnumerator Vibracion(float duracion, bool lado, ushort potencia = 1000, bool dosMandos = false)
	{
		vibracionIniciada = true;
		float t = 0f;
		while (t < duracion && !pararVibracion)
		{
			t += Time.deltaTime;
			if (Config.plataforma == Config.PlataformaJuego.SteamVR)
			{
				if (dosMandos)
				{
					controladorSteam.Vibracion((int)controladorSteam.controladorDerecho_TrackedController.controllerIndex, potencia);
					controladorSteam.Vibracion((int)controladorSteam.controladorIzquierdo_TrackedController.controllerIndex, potencia);
				}
				else if (lado)
				{
					controladorSteam.Vibracion((int)controladorSteam.controladorDerecho_TrackedController.controllerIndex, potencia);
				}
				else
				{
					controladorSteam.Vibracion((int)controladorSteam.controladorIzquierdo_TrackedController.controllerIndex, potencia);
				}
			}
			else if (Config.plataforma == Config.PlataformaJuego.Oculus)
			{
				float p = Mathf.Clamp(Convert.ToSingle(potencia) / 1000f, 0f, 0.8f);
				if (dosMandos)
				{
					controladorOculus.Vibracion(duracion, p, mano: true);
					controladorOculus.Vibracion(duracion, p, mano: false);
				}
				else if (lado)
				{
					controladorOculus.Vibracion(duracion, p, mano: true);
				}
				else
				{
					controladorOculus.Vibracion(duracion, p, mano: false);
				}
			}
			yield return null;
		}
		if (Config.plataforma == Config.PlataformaJuego.Oculus)
		{
			if (dosMandos)
			{
				controladorOculus.Vibracion(0f, 0f, mano: true);
				controladorOculus.Vibracion(0f, 0f, mano: false);
			}
			else if (lado)
			{
				controladorOculus.Vibracion(0f, 0f, mano: true);
			}
			else
			{
				controladorOculus.Vibracion(0f, 0f, mano: false);
			}
		}
		pararVibracion = false;
		vibracion = null;
	}
}
[Serializable]
public class Drops
{
	public GameObject drop;

	public int probabilidad;
}
public class LookAtPlayer : MonoBehaviour
{
	private void Update()
	{
		if (!GameManager.instance || !GameManager.instance.player)
		{
			return;
		}
		if (GameManager.instance.player.roomScale)
		{
			if ((bool)GameManager.instance.player.cabezaRoomScaleScript)
			{
				base.transform.LookAt(GameManager.instance.player.cabezaRoomScaleScript.transform);
			}
		}
		else
		{
			base.transform.LookAt(GameManager.instance.player.cabeza.transform);
		}
	}
}
public class PowerUpEscopeta : Powerup
{
	private void Awake()
	{
		tipo = TipoPowerup.Escopeta;
	}

	public override void ActivarPowerUp()
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			PlayerProgreso.instance.PowerUpUsado = true;
			Weapon weapon = null;
			Weapon weapon2 = null;
			Rifle rifle = null;
			GetComponent<AudioSource>().Play();
			if ((bool)GameManager.instance.player.weaponDer)
			{
				weapon = GameManager.instance.player.weaponDer;
			}
			if ((bool)GameManager.instance.player.weaponIzq)
			{
				weapon2 = GameManager.instance.player.weaponIzq;
			}
			if ((bool)GameManager.instance.player.rifle)
			{
				rifle = GameManager.instance.player.rifle;
			}
			GameManager.instance.powerUpShotgunActivo = true;
			if ((bool)weapon)
			{
				weapon.CambiarTipoDeArma(Weapon.TipoDeArma.Escopeta);
			}
			if ((bool)weapon2)
			{
				weapon2.CambiarTipoDeArma(Weapon.TipoDeArma.Escopeta);
			}
			if ((bool)rifle)
			{
				rifle.CambiarEstadoArma(Rifle.EstadoArma.Escopeta);
			}
			Desactivar();
		}
	}
}
public class PowerUpInmortal : Powerup
{
	private ColisionesJugador vidaJugador;

	private void Awake()
	{
		tipo = TipoPowerup.Inmortal;
	}

	public override void ActivarPowerUp()
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			PlayerProgreso.instance.PowerUpUsado = true;
			GetComponent<AudioSource>().Play();
			GameManager.instance.player.SerInmortalPorXSegundos(-1f);
			TimeManager.GetInstance().PonerTiempoLentoPorXSegundos(4f);
			Desactivar();
		}
	}
}
public class PowerUpLaser : Powerup
{
	private void Awake()
	{
		tipo = TipoPowerup.Laser;
	}

	public override void ActivarPowerUp()
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			PlayerProgreso.instance.PowerUpUsado = true;
			Weapon weapon = null;
			Weapon weapon2 = null;
			Rifle rifle = null;
			GetComponent<AudioSource>().Play();
			if ((bool)GameManager.instance.player.weaponDer)
			{
				weapon = GameManager.instance.player.weaponDer;
			}
			if ((bool)GameManager.instance.player.weaponIzq)
			{
				weapon2 = GameManager.instance.player.weaponIzq;
			}
			if ((bool)GameManager.instance.player.rifle)
			{
				rifle = GameManager.instance.player.rifle;
			}
			GameManager.instance.powerUpLaserActivo = true;
			if ((bool)weapon)
			{
				weapon.CambiarTipoDeArma(Weapon.TipoDeArma.Laser);
			}
			if ((bool)weapon2)
			{
				weapon2.CambiarTipoDeArma(Weapon.TipoDeArma.Laser);
			}
			if ((bool)rifle)
			{
				rifle.CambiarEstadoArma(Rifle.EstadoArma.Laser);
			}
			Desactivar();
		}
	}
}
public class PowerUpTiempo : Powerup
{
	private bool tutorial;

	private bool activadoMensaje;

	private Coroutine corrutinaActivarXTiempoDespues;

	private bool tutorialMostrado;

	private void Awake()
	{
		if (GameManager.instance.paisActual == 0 && GameManager.instance.nivelActual == 1)
		{
			tutorial = true;
		}
		tipo = TipoPowerup.Tiempo;
	}

	public override void ActivarPowerUp()
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			PlayerProgreso.instance.PowerUpUsado = true;
			if (GameManager.instance.esperandoCojerPowerUp)
			{
				GameManager.instance.player.QuitarTutoPowerup();
				PartidaSync.instance.QuitarTutoPowerUp();
			}
			if (tutorial)
			{
				GetComponent<SphereCollider>().enabled = false;
				StartCoroutine(EsperarXEnMostrarMensage());
			}
			else
			{
				TimeManager.GetInstance().PonerTiempoLentoPorXSegundos(4f);
				GameManager.instance.powerUpTiempoActivo = true;
				Desactivar();
			}
		}
	}

	private IEnumerator EsperarXEnMostrarMensage()
	{
		miEfectoDesaparicion.Desaparecer();
		miSprite.enabled = false;
		yield return new WaitForSeconds(0.5f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 10202, 16f, 0);
		TimeManager.GetInstance().PonerTiempoLentoPorXSegundos(16f);
		corrutinaActivarXTiempoDespues = StartCoroutine(ActivarPowerUpDespuesDeTutorial(16f));
		activadoMensaje = true;
	}

	private IEnumerator ActivarPowerUpDespuesDeTutorial(float tiempo)
	{
		yield return new WaitForSeconds(tiempo);
		TimeManager.GetInstance().PonerTiempoLentoPorXSegundos(4f);
		GameManager.instance.powerUpTiempoActivo = true;
		Desactivar();
	}

	private IEnumerator EsperarSegundosPonerTutoTiempoMuerto()
	{
		yield return new WaitForSeconds(0.1f);
		GameManager.instance.PararJuegoEsperandoCojerPowerUp();
		GetComponent<SphereCollider>().isTrigger = false;
	}

	protected override void Update()
	{
		if (GameManager.instance.nivelActual == 1 && GameManager.instance.paisActual == 0 && GameManager.instance.m_salaManager.nivelIniciado && !tutorialMostrado)
		{
			tutorialMostrado = true;
			StartCoroutine(EsperarSegundosPonerTutoTiempoMuerto());
		}
		base.Update();
		if (tutorial && activadoMensaje && !TimeManager.instance.tiempoMuerto)
		{
			StopCoroutine(corrutinaActivarXTiempoDespues);
			TimeManager.GetInstance().PonerTiempoLentoPorXSegundos(4f);
			Desactivar();
			activadoMensaje = false;
		}
	}

	protected override void OnTriggerEnter(Collider other)
	{
		bool flag = other.CompareTag(GameManager.instance.tagPistola) || other.CompareTag(GameManager.instance.tagPistolaGanchoOnline);
		if ((!(other.CompareTag(GameManager.instance.tagBala) || flag) && !other.CompareTag(GameManager.instance.tagMano)) || !vivo)
		{
			return;
		}
		if (miSonido != null && GameManager.instance.m_salaManager.nivelIniciado)
		{
			miSonido.Play();
		}
		if (tutorial)
		{
			ActivarPowerUp();
			PartidaSync.instance.ActivarPowerUp(GetComponent<PhotonView>().ViewID);
			return;
		}
		if (flag)
		{
			Weapon component = other.transform.parent.GetComponent<Weapon>();
			if (!component && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
			{
				component = other.transform.parent.parent.parent.GetComponent<Weapon>();
			}
			if ((bool)component)
			{
				component.heDestruidoEsferaAlSerLanzado = true;
			}
			else
			{
				GanchoRifle component2 = other.transform.parent.GetComponent<GanchoRifle>();
				if (!component2 && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
				{
					component2 = other.transform.parent.parent.parent.GetComponent<GanchoRifle>();
				}
				if ((bool)component2 && component2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					component2.heDestruidoEsferaAlSerLanzado = true;
				}
			}
		}
		ActivarPowerUp();
		PartidaSync.instance.ActivarPowerUp(GetComponent<PhotonView>().ViewID);
	}
}
public abstract class Powerup : MonoBehaviour
{
	public enum TipoPowerup
	{
		Tiempo,
		Escopeta,
		Inmortal,
		Laser,
		Desconocido
	}

	public TipoPowerup tipo = TipoPowerup.Desconocido;

	private int contadorLevitacion;

	private int tickSinHacerCosasEsteticas;

	protected AudioSource miSonido;

	protected EfectoDesaparecer miEfectoDesaparicion;

	protected SpriteRenderer miSprite;

	[HideInInspector]
	public bool vivo;

	private void Start()
	{
		vivo = false;
		StartCoroutine(TiempoVida());
		contadorLevitacion = 1;
		miSonido = GetComponent<AudioSource>();
		miEfectoDesaparicion = GetComponentInChildren<EfectoDesaparecer>();
		miSprite = GetComponentInChildren<SpriteRenderer>();
	}

	protected virtual void Update()
	{
		tickSinHacerCosasEsteticas++;
		if (tickSinHacerCosasEsteticas < 1)
		{
			return;
		}
		tickSinHacerCosasEsteticas = 0;
		base.transform.LookAt(GameManager.instance.player.cabeza.transform);
		if (contadorLevitacion >= 0)
		{
			contadorLevitacion++;
			if (contadorLevitacion > 40)
			{
				contadorLevitacion = -1;
			}
			else
			{
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.1f * Time.deltaTime, base.transform.position.z);
			}
		}
		else
		{
			contadorLevitacion--;
			if (contadorLevitacion < -40)
			{
				contadorLevitacion = 1;
			}
			else
			{
				base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.1f * Time.deltaTime, base.transform.position.z);
			}
		}
	}

	protected virtual void OnTriggerEnter(Collider other)
	{
		bool flag = other.CompareTag(GameManager.instance.tagPistola) || other.CompareTag(GameManager.instance.tagPistolaGanchoOnline);
		if ((!(other.CompareTag(GameManager.instance.tagBala) || flag) && !other.CompareTag(GameManager.instance.tagMano)) || !vivo)
		{
			return;
		}
		if (miSonido != null && GameManager.instance.m_salaManager.nivelIniciado)
		{
			miSonido.Play();
		}
		if (flag)
		{
			Weapon component = other.transform.parent.GetComponent<Weapon>();
			if (!component && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
			{
				component = other.transform.parent.parent.parent.GetComponent<Weapon>();
			}
			if ((bool)component)
			{
				component.heDestruidoEsferaAlSerLanzado = true;
			}
			else
			{
				GanchoRifle component2 = other.transform.parent.GetComponent<GanchoRifle>();
				if (!component2 && (bool)other.transform.parent.parent && (bool)other.transform.parent.parent.parent)
				{
					component2 = other.transform.parent.parent.parent.GetComponent<GanchoRifle>();
				}
				if ((bool)component2 && component2.estadoDelGancho != GanchoRifle.EstadoDelGancho.EnRifle)
				{
					component2.heDestruidoEsferaAlSerLanzado = true;
				}
			}
		}
		ActivarPowerUp();
		PartidaSync.instance.ActivarPowerUp(GetComponent<PhotonView>().ViewID);
	}

	private IEnumerator TiempoVida()
	{
		yield return new WaitForSeconds(0.2f);
		vivo = true;
	}

	private IEnumerator DestruyemeEnUnRato()
	{
		yield return new WaitForSeconds(2f);
		PhotonNetwork.Destroy(base.gameObject);
	}

	public void Desactivar()
	{
		vivo = false;
		if ((bool)miEfectoDesaparicion)
		{
			miEfectoDesaparicion.Desaparecer();
		}
		miSprite.enabled = false;
		StartCoroutine(DestruyemeEnUnRato());
	}

	public abstract void ActivarPowerUp();
}
[ExecuteInEditMode]
public class PowerupDummy : Powerup
{
	private TipoPowerup oldTipo = TipoPowerup.Desconocido;

	public Sprite[] sprites;

	public SpriteRenderer sRenderer;

	private void Start()
	{
	}

	private new void Update()
	{
		if (tipo != oldTipo)
		{
			sRenderer.sprite = sprites[(int)tipo];
			oldTipo = tipo;
		}
	}

	public override void ActivarPowerUp()
	{
		throw new NotImplementedException();
	}
}
public class SaltarAJugador : MonoBehaviour
{
	private Rigidbody rb;

	public float strength;

	private void Start()
	{
		StartCoroutine(TiempoEsperaSalto(0.05f));
	}

	public void JumpTo(GameObject objetivo, float fuerza)
	{
		if (fuerza == 0f)
		{
			fuerza = 1f;
		}
		rb.velocity = Vector3.zero;
		Vector3 normalized = (objetivo.transform.position - base.transform.position).normalized;
		normalized += new Vector3(0f, 0.5f, 0f);
		rb.AddForce(normalized * fuerza, ForceMode.Impulse);
	}

	private IEnumerator TiempoEsperaSalto(float tiempo)
	{
		if (rb == null)
		{
			rb = GetComponent<Rigidbody>();
		}
		rb.isKinematic = true;
		yield return new WaitForSeconds(tiempo);
		rb.isKinematic = false;
		JumpTo(GameObject.FindGameObjectWithTag("Player"), strength);
	}
}
public class Radar : MonoBehaviour
{
	public Bola bola;

	private float ticksSinDetectar;

	private GameObject ultimoObjetoGancho;

	private Weapon ultimoWeapon;
}
public class Sala : MonoBehaviour
{
	public int numeroSala;
}
public class SalasManager : MonoBehaviour
{
	public GameObject[] niveles;

	public Transform[] puntosSpawn;

	public GameObject posicionPlayer;

	public ControladorTVs controladorTVs;

	public ObjetosDelNivel objetosNivelActual;

	public GameObject estructuras;

	public Transform frentePantallaIzquierda;

	public Transform PantallaDerecha;

	public Transform puntoLuzSala;

	public bool nivelIniciado;

	public MeshRenderer lucesSala;

	[HideInInspector]
	public Color luzSalaNormalColor = new Color(0.7f, 1.5f, 1.4f, 1f);

	[HideInInspector]
	public Color luzSalaAlarmaColor = new Color(0.17f, 1f, 0f, 1f);

	[HideInInspector]
	public int puntosTotales;

	[HideInInspector]
	public int puntosTotalesNivelAnterior;

	private MonedaMultiplicador rachaObj;

	private int racha;

	private AudioSource audioSource1;

	private AudioSource audioSource2;

	public GameObject FlechaPowerUp;

	public Material matNivel;

	public GameObject confeti;

	private bool playerCargado;

	[HideInInspector]
	public bool salaCargada;

	private List<Powerup> powerupsInstanciados = new List<Powerup>();

	private ParedPistola[] torretas;

	private void Awake()
	{
		lucesSala = null;
		switch (GameManager.instance.paisActual)
		{
		case 0:
		case 1:
		case 2:
		case 3:
		case 9:
			if (!lucesSala)
			{
				lucesSala = GameObject.Find("Estructuras/Salas/Sala1/lights").GetComponent<MeshRenderer>();
			}
			break;
		case 4:
		case 6:
		case 7:
			if (!lucesSala)
			{
				lucesSala = GameObject.Find("Estructuras/Salas/stage_04_top_floor/Object039").GetComponent<MeshRenderer>();
			}
			break;
		case 5:
		case 8:
			if (!lucesSala)
			{
				lucesSala = GameObject.Find("Estructuras/Salas/stage_04_bottomfloor/Object041").GetComponent<MeshRenderer>();
			}
			break;
		case 10:
		case 11:
		case 12:
		case 13:
			if (!lucesSala)
			{
				lucesSala = GameObject.Find("Estructuras/Salas/stage_04_double/Object041").GetComponent<MeshRenderer>();
			}
			break;
		default:
			if (!lucesSala)
			{
				lucesSala = GameObject.Find("Estructuras/Salas/Sala1/lights").GetComponent<MeshRenderer>();
			}
			break;
		}
		try
		{
			if (!GameManager.instance.m_musica)
			{
				GameObject gameObject = GameObject.Find("Sistemas");
				if ((bool)gameObject)
				{
					Transform transform = gameObject.transform.Find("Musica");
					if ((bool)transform)
					{
						GameManager.instance.m_musica = transform.GetComponent<Musica>();
					}
				}
			}
			GameManager.instance.m_musica.CambiarMusicaATiempoParado(sinFadeOut: true);
		}
		catch
		{
		}
		luzSalaNormalColor = lucesSala.material.color;
		StartCoroutine(InstanciarPlayerCor());
		estructuras = GameObject.Find("Estructuras");
		frentePantallaIzquierda = estructuras.transform.Find("FrentePantallaDerecha");
		PantallaDerecha = estructuras.transform.Find("PantallaDerecha");
		Transform transform2 = null;
		transform2 = estructuras.transform.Find("Salas/Sala1/Luces");
		if ((bool)transform2)
		{
			puntoLuzSala = ((transform2.childCount > 1) ? transform2.GetChild(1) : null);
		}
		for (int i = 0; i < niveles.Length; i++)
		{
			niveles[i].SetActive(value: false);
			niveles[i].transform.GetChild(0).gameObject.SetActive(value: true);
			niveles[i].transform.GetChild(1).gameObject.SetActive(value: false);
			niveles[i].transform.GetChild(2).gameObject.SetActive(value: false);
		}
		luzSalaAlarmaColor = new Color(0.17f, 1f, 0f, 1f);
		if (Config.plataforma == Config.PlataformaJuego.Oculus && (Config.esGO || Config.esQuest))
		{
			GameObject gameObject2 = GameObject.Find("Nubes");
			if ((bool)gameObject2)
			{
				gameObject2.SetActive(value: false);
			}
		}
	}

	private IEnumerator InstanciarPlayerCor()
	{
		if (!GameManager.instance)
		{
			yield break;
		}
		GameManager.instance.m_salaManager = this;
		controladorTVs = GameObject.Find("CanvasPantallas").GetComponent<ControladorTVs>();
		if (!GameManager.instance.player)
		{
			GameObject go = ((Config.plataforma != Config.PlataformaJuego.Oculus || (!Config.esQuest && !Config.esGO)) ? PhotonNetwork.Instantiate("Prefabs/PlayerInstancia", Vector3.zero, Quaternion.identity, 0) : PhotonNetwork.Instantiate("Prefabs/PlayerInstanciaQuestGo", Vector3.zero, Quaternion.identity, 0));
			go.transform.SetParent(null);
			yield return null;
			PartidaSync.instance.miIdPhotonObjetoPlayer = go.GetComponent<PhotonView>().ViewID;
			if (PhotonNetwork.IsMasterClient)
			{
				PartidaSync.instance.miJugador.idPhotonObjetoPlayer = PartidaSync.instance.miIdPhotonObjetoPlayer;
				PartidaSync.instance.RefrescarListaJugadores();
			}
			else
			{
				go.SetActive(value: false);
				bool inicializadoOnline = false;
				do
				{
					if ((bool)PartidaSync.instance && PartidaSync.instance.miJugador != null)
					{
						inicializadoOnline = true;
					}
					else
					{
						yield return null;
					}
				}
				while (!inicializadoOnline);
			}
			int num = PartidaSync.instance.miJugador.idJuego;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 4)
			{
				num = ((PartidaSync.instance.miJugador.idJuego < 2) ? PartidaSync.instance.miJugador.idJuego : (PartidaSync.instance.miJugador.idJuego + 2));
			}
			Transform transform = ((Config.modoDeJuego != Config.ModosDeJuego.Online) ? GameManager.instance.m_salaManager.posicionPlayer.transform : GameManager.instance.m_salaManager.puntosSpawn[num]);
			go.transform.position = transform.position;
			go.transform.rotation = transform.rotation;
			go.SetActive(value: true);
			InicioNivel.instancia.ReconocerTextoArmas();
			yield return null;
			if ((bool)GameManager.instance.player.weaponDer)
			{
				GameManager.instance.player.weaponDer.SetPosIniWeapon();
			}
			if ((bool)GameManager.instance.player.weaponIzq)
			{
				GameManager.instance.player.weaponIzq.SetPosIniWeapon();
			}
			if ((bool)GameManager.instance.player.rifle)
			{
				GameManager.instance.player.rifle.SetPosIniWeapon();
			}
			go.GetComponent<SyncJugadores>().empezar = true;
		}
		yield return null;
		playerCargado = true;
		PonerLimitesSala();
	}

	private IEnumerator Start()
	{
		audioSource1 = InicioNivel.instancia.transform.parent.Find("AudioSource").GetComponents<AudioSource>()[0];
		audioSource2 = InicioNivel.instancia.transform.parent.Find("AudioSource").GetComponents<AudioSource>()[1];
		while (!GameManager.instance.player || !playerCargado)
		{
			yield return null;
		}
		if (!rachaObj)
		{
			rachaObj = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/RachaPrefab") as GameObject).GetComponent<MonedaMultiplicador>();
		}
		rachaObj.gameObject.SetActive(value: false);
		CargarSalaNivel(GameManager.instance.nivelActual);
		yield return new WaitForSeconds(1f);
		if (CalidadManager.instance.GetCalidad() == CalidadManager.Calidad.Baja && GameManager.instance.paisActual != 0)
		{
			GameObject gameObject = GameObject.Find("FXs/MatrixDeSkybox");
			if ((bool)gameObject)
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
		salaCargada = true;
		yield return new WaitForSeconds(2f);
		if (LoadingCamera.instance.estadoActual != 0)
		{
			LoadingCamera.instance.DesactivarCamaraNegraAsync();
		}
	}

	public void CargarSalaNivel(int nivel, bool muerte = false)
	{
		bool flag = false;
		GameManager.instance.vengoDeMuerto = muerte;
		int num = GameManager.instance.paisActual + 1;
		int num2 = GameManager.instance.nivelActual + 1;
		bool flag2 = Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo;
		if (!muerte)
		{
			if (GameManager.instance.nivelActual == 9)
			{
				GameManager.instance.player.VolverAPosicionarPistolasEnSuSitio();
				controladorTVs.PonerEntradaBoss(audioSource1, audioSource2);
				flag = true;
			}
			else
			{
				if (!flag2)
				{
					int num3 = num;
					int num4 = num2;
					if (num3 == 1 && num4 == 4)
					{
						num3 = 2;
						num4 = 2;
					}
					if ((num3 == 1 && num4 == 3) || (num3 == 1 && num4 == 6) || (num3 == 1 && num4 == 7))
					{
						MostrarElMensaje(50);
						flag = true;
					}
					else if (num4 == 1 || num4 == 5 || num4 == 10 || (num3 < 6 && num4 == 2) || (num3 == 3 && num4 == 3) || (num3 == 7 && num4 == 2) || (num3 == 9 && num4 == 2) || (num3 == 1 && num4 == 7))
					{
						MostrarElMensaje(num3 * 10000 + num4 * 100 + 1);
						flag = true;
					}
					else
					{
						GameManager.instance.nivelesJugadosSinProTip++;
						if (GameManager.instance.nivelesJugadosSinProTip > 6)
						{
							GameManager.instance.nivelesJugadosSinProTip = 0;
							MostrarElMensaje(50);
							flag = true;
						}
					}
				}
				GameManager.instance.player.VolverAPosicionarPistolasEnSuSitio();
			}
		}
		else
		{
			flag = true;
		}
		if (PersistentDataManager.GetInt("MensajeUsarPowerUp") == 1 && !flag2)
		{
			PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado = false;
		}
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores.ContainsKey(key) && PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer >= 0)
			{
				SyncJugadores component = PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer).GetComponent<SyncJugadores>();
				if ((bool)component)
				{
					component.PonermeResucitado();
				}
			}
		}
		int num5 = nivel;
		if ((bool)PartidaSync.instance && flag2)
		{
			int num6 = PartidaSync.instance.puntuacionEquipo1;
			if (num6 < PartidaSync.instance.puntuacionEquipo2)
			{
				num6 = PartidaSync.instance.puntuacionEquipo2;
			}
			num5 = num6;
			if (num5 >= niveles.Length)
			{
				num5 = 0;
			}
		}
		objetosNivelActual = UnityEngine.Object.Instantiate(niveles[num5], niveles[num5].transform.position, niveles[num5].transform.rotation, niveles[num5].transform.parent).GetComponent<ObjetosDelNivel>();
		GameManager.instance.comenzarPartidaOnline = Config.modoDeJuego != Config.ModosDeJuego.Online;
		NivelCompletado.instance.yaLasHemosCambiado = false;
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.Inicializar();
		}
		GameManager.instance.m_musica.CambiarMusicaATiempoParado(sinFadeOut: true);
		if ((bool)NivelCompletado.instance)
		{
			NivelCompletado.instance.listaEsferasEquipo1.Clear();
		}
		if ((bool)NivelCompletado.instance)
		{
			NivelCompletado.instance.listaEsferasEquipo2.Clear();
		}
		BolaDummy[] esferasNivel = objetosNivelActual.GetEsferasNivel();
		for (int i = 0; i < esferasNivel.Length; i++)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				if (esferasNivel[i].tipoEsfera == Bola.TipoEsfera.Mina)
				{
					GameObject obj = PhotonNetwork.Instantiate("Prefabs/Mina", esferasNivel[i].transform.position, Quaternion.identity, 0);
					obj.transform.SetParent(esferasNivel[i].transform.parent);
					obj.GetComponent<Mina>().nivel = esferasNivel[i].NivelDeBolaInicial;
					UnityEngine.Object.Destroy(esferasNivel[i].gameObject);
					continue;
				}
				if (esferasNivel[i].tipoEscudo == Bola.TipoEscudo.nunguno && esferasNivel[i].escudoHeredable > 0)
				{
					esferasNivel[i].escudoHeredable = 0;
				}
				GameObject obj2 = PoolObjetos.instance.Instanciar(PoolObjetos.TipoObjeto.Esfera, esferasNivel[i].transform.position, esferasNivel[i].transform.rotation, null, esferasNivel[i].GetEquipo(), esferasNivel[i].GetTipoEsfera(), esferasNivel[i].GetTipoEscudo());
				Bola component2 = obj2.GetComponent<Bola>();
				obj2.transform.SetParent(null);
				obj2.transform.position = esferasNivel[i].transform.position;
				obj2.transform.rotation = esferasNivel[i].transform.rotation;
				obj2.transform.localScale = esferasNivel[i].transform.localScale;
				component2.escudoHeredable = esferasNivel[i].escudoHeredable;
				component2.NivelDeBolaInicial = esferasNivel[i].NivelDeBolaInicial;
				component2.efectoAparecerEnOnEnable = true;
				obj2.SetActive(esferasNivel[i].gameObject.activeSelf);
				if ((bool)(EsferaScript)component2 && esferasNivel[i].direccion != Vector3.zero)
				{
					((EsferaScript)component2).dir = esferasNivel[i].direccion;
				}
			}
			UnityEngine.Object.Destroy(esferasNivel[i].gameObject);
		}
		TorretaDummy[] torretasNivel = objetosNivelActual.GetTorretasNivel();
		if (torretasNivel != null)
		{
			for (int j = 0; j < torretasNivel.Length; j++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					GameObject obj3 = PhotonNetwork.Instantiate("Prefabs/Torreta", torretasNivel[j].transform.position, torretasNivel[j].transform.rotation, 0);
					ParedPistola component3 = obj3.GetComponent<ParedPistola>();
					obj3.transform.SetParent(torretasNivel[j].transform.parent);
					obj3.transform.position = torretasNivel[j].transform.position;
					obj3.transform.rotation = torretasNivel[j].transform.rotation;
					obj3.transform.localScale = torretasNivel[j].transform.localScale;
					obj3.SetActive(torretasNivel[j].gameObject.activeSelf);
					component3.nivelTorreta = torretasNivel[j].nivelTorreta;
				}
				UnityEngine.Object.Destroy(torretasNivel[j].gameObject);
			}
		}
		BloqueRompibleDummy[] bloqueRompiblesNivel = objetosNivelActual.GetBloqueRompiblesNivel();
		if (bloqueRompiblesNivel != null)
		{
			for (int k = 0; k < bloqueRompiblesNivel.Length; k++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					GameObject obj4 = PhotonNetwork.Instantiate("Prefabs/BloqueRompible", bloqueRompiblesNivel[k].transform.position, bloqueRompiblesNivel[k].transform.rotation, 0);
					obj4.GetComponent<BloqueRompible>();
					obj4.transform.SetParent(bloqueRompiblesNivel[k].transform.parent);
					obj4.transform.position = bloqueRompiblesNivel[k].transform.position;
					obj4.transform.rotation = bloqueRompiblesNivel[k].transform.rotation;
					obj4.transform.localScale = bloqueRompiblesNivel[k].transform.localScale;
					obj4.SetActive(bloqueRompiblesNivel[k].gameObject.activeSelf);
				}
				UnityEngine.Object.Destroy(bloqueRompiblesNivel[k].gameObject);
			}
		}
		for (int l = 0; l < powerupsInstanciados.Count; l++)
		{
			if (powerupsInstanciados[l] != null)
			{
				PhotonNetwork.Destroy(powerupsInstanciados[l].gameObject);
			}
		}
		powerupsInstanciados.Clear();
		PowerupDummy[] powerupsNivel = objetosNivelActual.GetPowerupsNivel();
		if (powerupsNivel != null)
		{
			for (int m = 0; m < powerupsNivel.Length; m++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					string text = "Prefabs/PowerUps/";
					switch (powerupsNivel[m].tipo)
					{
					case Powerup.TipoPowerup.Escopeta:
						text += "PowerUpEscopeta";
						break;
					case Powerup.TipoPowerup.Inmortal:
						text += "PowerUpInmortal";
						break;
					case Powerup.TipoPowerup.Laser:
						text += "PowerUpLaser";
						break;
					case Powerup.TipoPowerup.Tiempo:
						text += "PowerUpTiempo";
						break;
					case Powerup.TipoPowerup.Desconocido:
						UnityEngine.Debug.LogError("POWERUP NO SETEADO BIEN");
						continue;
					}
					GameObject obj5 = PhotonNetwork.Instantiate(text, powerupsNivel[m].transform.position, powerupsNivel[m].transform.rotation, 0);
					Powerup component4 = obj5.GetComponent<Powerup>();
					powerupsInstanciados.Add(component4);
					component4.tipo = powerupsNivel[m].tipo;
					obj5.transform.SetParent(powerupsNivel[m].transform.parent);
					obj5.transform.position = powerupsNivel[m].transform.position;
					obj5.transform.rotation = powerupsNivel[m].transform.rotation;
					obj5.transform.localScale = powerupsNivel[m].transform.localScale;
					obj5.SetActive(powerupsNivel[m].gameObject.activeSelf);
				}
				UnityEngine.Object.Destroy(powerupsNivel[m].gameObject);
			}
		}
		BossDummy[] bossNivel = objetosNivelActual.GetBossNivel();
		if (bossNivel != null)
		{
			for (int n = 0; n < bossNivel.Length; n++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					string text2 = "Prefabs/Bosses/";
					switch (bossNivel[n].tipo)
					{
					case BossDummy.TipoDeBoss.Mundo1_EscudoBala:
						text2 += "BossEscudoBala";
						break;
					case BossDummy.TipoDeBoss.Mundo2_HackerMetralleta:
						text2 += "BossHackerMetralleta";
						break;
					case BossDummy.TipoDeBoss.Mundo3_Mina:
						text2 += "BossMina";
						break;
					case BossDummy.TipoDeBoss.Mundo4_Laser:
						text2 += "BossLaser";
						break;
					case BossDummy.TipoDeBoss.Mundo5_EscudoCadena:
						text2 += "BossEscudoCadena";
						break;
					case BossDummy.TipoDeBoss.Mundo6_Dragon:
						text2 += "BoosDragon";
						break;
					case BossDummy.TipoDeBoss.Mundo7_OjoDebil:
						text2 += "BossOjoDebil";
						break;
					case BossDummy.TipoDeBoss.Mundo8_Teleport:
						text2 += "BossTeleport";
						break;
					case BossDummy.TipoDeBoss.Mundo9_Satelites:
						text2 += "BossSatelites";
						break;
					case BossDummy.TipoDeBoss.Mundo10_Indeciso:
						text2 += "BossIndeciso";
						break;
					case BossDummy.TipoDeBoss.Mundo11_DragonDebil:
						text2 += "BoosDragonDebil";
						break;
					case BossDummy.TipoDeBoss.Mundo12_HackerMetralleta:
						text2 += "BossHackerMetralleta";
						break;
					case BossDummy.TipoDeBoss.Mundo13_EscudoCadena:
						text2 += "BossEscudoCadena";
						break;
					case BossDummy.TipoDeBoss.Mundo14_Teleport:
						text2 += "BossTeleport";
						break;
					}
					GameObject gameObject = PhotonNetwork.Instantiate(text2, bossNivel[n].transform.position, bossNivel[n].transform.rotation, 0);
					BossHackerMetralleta component5 = gameObject.GetComponent<BossHackerMetralleta>();
					if ((bool)component5)
					{
						component5.dir = bossNivel[n].direccion;
						component5.bossMejorado = bossNivel[n].bossMejorado;
					}
					else
					{
						BossEscudoCadena component6 = gameObject.GetComponent<BossEscudoCadena>();
						if ((bool)component6)
						{
							component6.bossMejorado = bossNivel[n].bossMejorado;
						}
						else
						{
							BossTeleport component7 = gameObject.GetComponent<BossTeleport>();
							if ((bool)component7)
							{
								component7.bossMejorado = bossNivel[n].bossMejorado;
							}
						}
					}
					gameObject.transform.SetParent(bossNivel[n].transform.parent);
					gameObject.transform.position = bossNivel[n].transform.position;
					gameObject.transform.rotation = bossNivel[n].transform.rotation;
					gameObject.transform.localScale = bossNivel[n].transform.localScale;
					gameObject.SetActive(bossNivel[n].gameObject.activeSelf);
				}
				UnityEngine.Object.Destroy(bossNivel[n].gameObject);
			}
		}
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.meshArma.material = GameManager.instance.player.weaponDer.materiales[0];
			GameManager.instance.player.weaponDer.armaEnFantasmal = false;
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.meshArma.material = GameManager.instance.player.weaponIzq.materiales[0];
			GameManager.instance.player.weaponIzq.armaEnFantasmal = false;
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.PonerQuitarFantasmal(activar: false);
		}
		GameManager.instance.player.ResetRotacionPlayer();
		foreach (int key2 in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores[key2].idPhotonObjetoPlayer != int.MinValue)
			{
				SyncJugadores component8 = PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key2].idPhotonObjetoPlayer).GetComponent<SyncJugadores>();
				if ((bool)component8)
				{
					component8.PonermeResucitado();
				}
			}
		}
		objetosNivelActual.gameObject.SetActive(value: true);
		GameManager.instance.player.PonerQuitarModoRoomScale(activar: true, porInicioDeNivel: true);
		if (!muerte)
		{
			GameManager.instance.player.ReproducirAudioSourceRoomScale(Player.ClipsAudioJugador.AparecerGlobalRS);
		}
		if (!flag)
		{
			StartCoroutine(PonerPistolasArriba());
		}
		if (nivel + 1 == 10)
		{
			GameManager.instance.m_musica.PonerMusicaBoss();
		}
		if (num * 10000 + num2 * 100 + 1 == 10501 && !muerte)
		{
			StartCoroutine(MostrarTorretas());
		}
	}

	private IEnumerator PonerPistolasArriba()
	{
		yield return null;
		GameManager.instance.player.MostrarPistolas();
	}

	private void PonerLimitesSala()
	{
		if (GameManager.instance.paisActual == 5 || GameManager.instance.paisActual == 8 || GameManager.instance.paisActual == 10 || GameManager.instance.paisActual == 11 || GameManager.instance.paisActual == 12 || GameManager.instance.paisActual == 13)
		{
			InputsController.instance.maxRoomCapacityMovementForward = 1f;
		}
	}

	public void SumarRacha(Vector3 pos)
	{
		if ((bool)GameManager.instance.player && GameManager.instance.m_salaManager.nivelIniciado && !GameManager.instance.player.muerto)
		{
			racha++;
			controladorTVs.ModificarRacha(racha);
			if (racha == 5 || racha == 10 || racha == 15 || racha == 20 || racha == 25)
			{
				MostrarRacha(pos, racha);
			}
			switch (racha)
			{
			case 5:
				GameManager.instance.SetLogro(LogrosRecords.Logros.Streak5);
				break;
			case 10:
				GameManager.instance.SetLogro(LogrosRecords.Logros.Streak10);
				break;
			case 15:
				GameManager.instance.SetLogro(LogrosRecords.Logros.Streak15);
				break;
			case 20:
				GameManager.instance.SetLogro(LogrosRecords.Logros.Streak20);
				break;
			}
		}
	}

	public void ResetearRacha()
	{
		racha = 0;
		controladorTVs.ModificarRacha(racha);
	}

	public int GetRacha()
	{
		return racha;
	}

	private void MostrarRacha(Vector3 pos, int puntos)
	{
		if (!rachaObj)
		{
			rachaObj = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/RachaPrefab") as GameObject).GetComponent<MonedaMultiplicador>();
		}
		rachaObj.transform.position = pos;
		rachaObj.cantidadPuntos.text = "+" + puntos;
		rachaObj.gameObject.SetActive(value: true);
		rachaObj.PonerSonido(puntos);
	}

	public void SumarPuntosTotales(int nuevosPuntos)
	{
		nuevosPuntos += 100 * racha;
		controladorTVs.MostrarPuntosActuales(nuevosPuntos);
		puntosTotales += nuevosPuntos;
		controladorTVs.ModificarPuntosTotales(puntosTotales);
		PartidaSync.instance.miJugador.puntos = puntosTotales;
	}

	public void ResetPuntosTotales()
	{
		puntosTotalesNivelAnterior = puntosTotales;
		puntosTotales = 0;
		PartidaSync.instance.miJugador.puntos = puntosTotales;
	}

	private void MostrarElMensaje(int num, int chica = -1)
	{
		StartCoroutine(MostrarMensaje(num, chica));
	}

	private IEnumerator MostrarMensaje(int num, int chica = -1)
	{
		yield return new WaitForSeconds(0.1f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, num, 999f, chica);
	}

	public void ActivarTorretas()
	{
		torretas = objetosNivelActual.torretasGo.GetComponentsInChildren<ParedPistola>();
		for (int i = 0; i < torretas.Length; i++)
		{
			torretas[i].Activar(GameManager.instance.player.photonView.ViewID);
		}
	}

	public void DesactivarTorretas()
	{
		for (int i = 0; i < torretas.Length; i++)
		{
			torretas[i].Desactivar();
		}
	}

	private IEnumerator MostrarTorretas()
	{
		yield return new WaitForSeconds(1f);
		ActivarTorretas();
		yield return new WaitForSeconds(5f);
		DesactivarTorretas();
	}

	public void SubirPuntuacionARecords()
	{
		if (puntosTotales > PersistentDataManager.GetInt("Record_Mundo" + GameManager.instance.paisActual + "_Nivel" + GameManager.instance.nivelActual))
		{
			controladorTVs.MostrarMensajeNuevoRecord();
			PersistentDataManager.SetInt("Record_Mundo" + GameManager.instance.paisActual + "_Nivel" + GameManager.instance.nivelActual, puntosTotales);
			GameManager.instance.SumarPuntosMundoYEnviarRecord(puntosTotales);
		}
		ResetPuntosTotales();
	}
}
public class SetQuestGo : MonoBehaviour
{
	public GameObject der;

	public GameObject izq;

	private void Awake()
	{
		if (Config.plataforma != Config.PlataformaJuego.Oculus || (!Config.esQuest && !Config.esGO))
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		base.gameObject.AddComponent<TrackedPoseDriver>();
		GameObject obj = UnityEngine.Object.Instantiate(izq);
		obj.transform.SetParent(base.transform.parent);
		obj.name = "Izq";
		GameObject obj2 = UnityEngine.Object.Instantiate(der);
		obj2.transform.SetParent(base.transform.parent);
		obj2.name = "Der";
	}
}
public class ChangeSkybox : MonoBehaviour
{
	public Material[] skyboxes;

	private InputsController iCtr;

	private void Start()
	{
		iCtr = GetComponentInChildren<InputsController>();
	}

	private void Update()
	{
	}

	public void ChangeMySkybox()
	{
		int num = UnityEngine.Random.Range(0, skyboxes.Length - 1);
		RenderSettings.skybox = skyboxes[num];
	}
}
public class ColisionesJugador : MonoBehaviour
{
	public bool muerte;

	public bool inmortal;

	private Texture2D texturaFundido;

	private Material muerteMaterial;

	private Rect area;

	private float alpha;

	private CapsuleCollider capsuleColliderCuerpoPlayer;

	private AudioSource sonidoMuerte;

	private Vector3 origenPlayer;

	private void Start()
	{
		origenPlayer = Vector3.zero;
		sonidoMuerte = GetComponent<AudioSource>();
		capsuleColliderCuerpoPlayer = GetComponent<CapsuleCollider>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!GameManager.instance || !GameManager.instance.player || GameManager.instance.player.muerto || !GameManager.instance.m_salaManager || !GameManager.instance.m_salaManager.nivelIniciado)
		{
			return;
		}
		bool flag = other.gameObject.CompareTag(GameManager.instance.tagParedMovible);
		if (other.CompareTag(GameManager.instance.tagBalaEsfera) || other.CompareTag(GameManager.instance.tagEsfera) || other.gameObject.layer == GameManager.instance.layerMina || flag)
		{
			if (flag && GameManager.instance.player.GetInmortalidad())
			{
				GameManager.instance.player.QuitarInmortalidad();
			}
			PhotonView component = other.gameObject.GetComponent<PhotonView>();
			PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, component ? component.ViewID : (-1));
			GameManager.instance.player.Morir(flag ? null : other.gameObject);
		}
		else if (!Debugs.sinMatarEnCompetitivo && Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && (other.CompareTag(GameManager.instance.tagBala) || other.CompareTag(GameManager.instance.tagPistola) || other.CompareTag(GameManager.instance.tagPistolaGanchoOnline) || flag))
		{
			SyncBala component2 = other.GetComponent<SyncBala>();
			if ((bool)component2 && component2.equipo != PartidaSync.instance.miJugador.equipo)
			{
				if (flag && GameManager.instance.player.GetInmortalidad())
				{
					GameManager.instance.player.QuitarInmortalidad();
				}
				PhotonView component3 = other.gameObject.GetComponent<PhotonView>();
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego, component3 ? component3.ViewID : (-1));
				GameManager.instance.player.Morir(flag ? null : other.gameObject);
			}
			else if (other.gameObject.tag == GameManager.instance.tagPistolaGanchoOnline || other.gameObject.tag == GameManager.instance.tagPistolaGanchoOnline || flag)
			{
				if (flag && GameManager.instance.player.GetInmortalidad())
				{
					GameManager.instance.player.QuitarInmortalidad();
				}
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(other.gameObject);
			}
		}
		if (other.CompareTag(GameManager.instance.tagBoss))
		{
			if (!GameManager.instance.bossNivel || !GameManager.instance.bossNivel.muerto)
			{
				PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
				GameManager.instance.player.Morir(flag ? null : other.gameObject);
			}
		}
		else if (flag)
		{
			PartidaSync.instance.ComunicarMiMuerte(PartidaSync.instance.miJugador.idJuego);
			GameManager.instance.player.Morir(flag ? null : other.gameObject);
		}
	}

	public void ActivarDesactivarCapsulaPlayer(bool estado)
	{
		if ((bool)capsuleColliderCuerpoPlayer)
		{
			capsuleColliderCuerpoPlayer.enabled = estado;
		}
	}
}
public class ControladorCadena : MonoBehaviour
{
	public LineRenderer m_line;

	public Transform puntoFinal;

	public const int CantPuntos = 101;

	[SerializeField]
	public Vector3[] posicionesPuntos;

	[SerializeField]
	private float frecuencia = 1f;

	[SerializeField]
	public float amplitud = 1f;

	[SerializeField]
	private float velocidad = 1f;

	private const float frecuenciaGravedad = 3.2f;

	private float amplitudGravedad = 0.13f;

	[SerializeField]
	private float frecuencia2 = 1f;

	[SerializeField]
	private float amplitud2 = 0.13f;

	[SerializeField]
	private bool deformacionExtra;

	public Vector3 vectorAlDestino;

	private const float pi = (float)Math.PI;

	private int cont;

	private Coroutine corFade;

	private Coroutine corEncender;

	private void Start()
	{
		m_line = GetComponent<LineRenderer>();
		posicionesPuntos = new Vector3[102];
	}

	private void LateUpdate()
	{
		UpdateLinea();
	}

	private void UpdateLinea()
	{
		Vector3 position = base.transform.position;
		Vector3 position2 = puntoFinal.position;
		vectorAlDestino = position2 - position;
		m_line.positionCount = 101;
		for (int i = 0; i <= 101; i++)
		{
			float num = (float)i / 101f;
			Vector3 vector = position + vectorAlDestino * num;
			Vector3 vector2 = Vector3.down * Mathf.Sin(num * frecuencia + Time.unscaledTime * velocidad) * amplitud;
			Vector3 vector3 = Vector3.zero;
			if (deformacionExtra)
			{
				vector3 = Vector3.down * Mathf.Sin(num * frecuencia2 + Time.unscaledTime * velocidad) * amplitud2;
			}
			float num2 = Vector3.Distance(position, position2);
			if ((double)num2 < 0.1)
			{
				amplitudGravedad = 0.13f;
			}
			else
			{
				if ((double)num2 > 1.1)
				{
					amplitudGravedad = 0f;
				}
				else
				{
					amplitudGravedad = num2 * -0.13f + 0.143f;
				}
				amplitudGravedad = 0.13f;
			}
			Vector3 vector4 = Vector3.down * Mathf.Sin(num * 3.2f) * amplitudGravedad;
			float num3 = Mathf.Sin((float)Math.PI * num);
			if (posicionesPuntos.Length <= i)
			{
				posicionesPuntos = new Vector3[102];
				base.gameObject.SetActive(value: false);
				base.gameObject.SetActive(value: true);
			}
			posicionesPuntos[i] = vector + ((vector2 + vector3) * num3 + vector4);
		}
		m_line.widthMultiplier = 0.01f;
		m_line.positionCount = 101;
		m_line.SetPositions(posicionesPuntos);
	}

	public void Aparecer()
	{
		if ((bool)m_line)
		{
			m_line.enabled = true;
			Color color = m_line.material.color;
			color.a = 1f;
			m_line.material.color = color;
		}
	}

	private IEnumerator EncenderTrasUnTiempo()
	{
		yield return new WaitForSeconds(2f);
		Color color = m_line.material.color;
		color.a = 1f;
		m_line.material.color = color;
	}

	public void Desaparecer()
	{
	}

	private IEnumerator Fade(bool aparecer)
	{
		int mult = 1;
		if (!aparecer)
		{
			mult = -1;
		}
		float t = ((!aparecer) ? 1 : 0);
		while ((aparecer && t < 1f) || (!aparecer && t > 0f))
		{
			Color color = m_line.material.color;
			color.a = t;
			m_line.material.color = color;
			t += Time.deltaTime * (float)mult;
			yield return null;
		}
	}
}
public class ControladorCadenaOnline : MonoBehaviour
{
	[SerializeField]
	private LineRenderer m_line;

	private Transform puntoFinal;

	private Transform puntoInicial;

	public Transform puntoFinalPistola;

	public Transform puntoFinalGancho;

	public Transform puntoInicialPistola;

	public Transform puntoInicialGancho;

	public const int CantPuntos = 101;

	[SerializeField]
	public Vector3[] posicionesPuntos;

	[SerializeField]
	private float frecuencia = 1f;

	[SerializeField]
	public float amplitud = 1f;

	[SerializeField]
	private float velocidad = 1f;

	private const float frecuenciaGravedad = 3.2f;

	private float amplitudGravedad = 0.13f;

	[SerializeField]
	private float frecuencia2 = 1f;

	[SerializeField]
	private float amplitud2 = 0.13f;

	public Vector3 vectorAlDestino;

	private const float pi = (float)Math.PI;

	private void Start()
	{
		m_line = GetComponent<LineRenderer>();
		posicionesPuntos = new Vector3[102];
	}

	private void LateUpdate()
	{
		UpdateLinea();
	}

	private void UpdateLinea()
	{
		if (!m_line.enabled || puntoFinal == null || puntoInicial == null)
		{
			return;
		}
		vectorAlDestino = puntoFinal.position - puntoInicial.position;
		for (int i = 0; i <= 101; i++)
		{
			float num = (float)i / 101f;
			Vector3 vector = puntoInicial.position + vectorAlDestino * num;
			Vector3 vector2 = Vector3.down * Mathf.Sin(num * frecuencia + Time.unscaledTime * velocidad) * amplitud;
			Vector3 zero = Vector3.zero;
			float num2 = Vector3.Distance(puntoInicial.position, puntoFinal.position);
			if ((double)num2 < 0.1)
			{
				amplitudGravedad = 0.13f;
			}
			else if ((double)num2 > 1.1)
			{
				amplitudGravedad = 0f;
			}
			else
			{
				amplitudGravedad = num2 * -0.13f + 0.143f;
			}
			Vector3 vector3 = Vector3.down * Mathf.Sin(num * 3.2f) * amplitudGravedad;
			float num3 = Mathf.Sin((float)Math.PI * num);
			posicionesPuntos[i] = vector + ((vector2 + zero) * num3 + vector3);
		}
		m_line.SetPositions(posicionesPuntos);
	}

	public void CambiarPuntoAnclaje(bool derecha, bool pistola, bool sinGancho = false)
	{
		if (sinGancho)
		{
			m_line.enabled = false;
			return;
		}
		m_line.enabled = true;
		if (derecha)
		{
			if (pistola)
			{
				puntoInicial = puntoInicialPistola;
			}
			else
			{
				puntoInicial = puntoInicialGancho;
			}
		}
		else if (pistola)
		{
			puntoFinal = puntoFinalPistola;
		}
		else
		{
			puntoFinal = puntoFinalGancho;
		}
	}
}
public class InputsController : MonoBehaviour
{
	public enum DispositivosPosibles
	{
		SensorDerecho,
		SensorIzquierdo,
		mando,
		rudder,
		teclado,
		tracker
	}

	public enum TipoSensores
	{
		vive,
		oculus,
		index,
		cosmos,
		wmr,
		ninguno,
		mandoXbox,
		mandoSwitch,
		mandoSteam,
		tracker,
		pico,
		nolo
	}

	public struct JoyInput
	{
		public bool existe;

		public string name;

		public int joyNumber;

		public DispositivosPosibles soyTipo;

		public TipoSensores tipoSensor;

		public JoyInput(bool _existe, string nombre, int num, DispositivosPosibles tipo, TipoSensores tipoDeSensor)
		{
			existe = _existe;
			name = nombre;
			joyNumber = num;
			soyTipo = tipo;
			tipoSensor = tipoDeSensor;
		}
	}

	public bool menu;

	public bool escenaLoadingOnline;

	public static InputsController instance;

	public Transform head;

	public Transform rightHand;

	public Transform leftHand;

	public ControladorVR controladorVR;

	[HideInInspector]
	public ControladorVRNolo controladorVRNolo;

	private ControladorRudder controladorRudder;

	private bool rudderConectado;

	[Space(20f)]
	public Transform posicionDeseadaPlayer;

	public Transform posicionDeseadaCabeza;

	public float trigger;

	public float rightHandVelocity;

	private Vector3 posAnteriorManoDerecha;

	public float leftHandVelocity;

	private Vector3 posAnteriorManoIzquierda;

	public Vector3 leftHandVelocityVector;

	public Vector3 rightHandVelocityVector;

	public bool botonAtras;

	public bool botonPausa;

	public bool botonPausaUp;

	public bool botonPausaDown;

	public bool botonRecolocar;

	public bool botonRecolocarUp;

	public bool botonRecolocarDown;

	public bool botonCambiarPistolaGanchoDer;

	public bool botonCambiarPistolaGanchoDerUp;

	public bool botonCambiarPistolaGanchoDerDown;

	public bool botonCambiarPistolaGanchoIzq;

	public bool botonCambiarPistolaGanchoIzqUp;

	public bool botonCambiarPistolaGanchoIzqDown;

	public float triggerDerecho;

	public float triggerIzquierdo;

	public bool triggerDerechoUp;

	public bool triggerDerechoDown;

	public bool triggerIzquierdoUp;

	public bool triggerIzquierdoDown;

	private float anteriorGripD;

	private float anteriorGripI;

	public float gripDerecho;

	public bool gripDerechoDown;

	public bool gripDerechoUp;

	public float gripIzquierdo;

	public bool gripIzquierdoDown;

	public bool gripIzquierdoUp;

	public Vector2 stickIzquierdo;

	public Vector2 stickDerecho;

	public Vector2 rudder;

	public Transform playerInstance;

	public float playerMovementSpeed;

	public Vector3 posicionSensorR;

	public Vector3 posicionSensorL;

	public Vector3 rotacionSensorR;

	public Vector3 rotacionSensorL;

	public float maxRoomCapacityMovementForward = -2.7f;

	public float maxRoomCapacityMovementBackwards = 2.7f;

	public float maxRoomCapacityMovementToRight = 0.2f;

	public float maxRoomCapacityMovementToLeft = -3.2f;

	private float oldMouseX;

	private bool oldBotonPausa;

	private bool oldBotonRecolocar;

	private bool oldBotonCambiarPistolaGanchoDer;

	private bool oldBotonCambiarPistolaGanchoIzq;

	private Vector3 currentRotation = Vector3.zero;

	private Vector3 currentRotationInicial = Vector3.zero;

	private bool primeraVez;

	private float sensitivity = 5f;

	private Vector3 oldRotation = Vector3.zero;

	[HideInInspector]
	public float rotacionConJoystick;

	private Vector3 poscabezaAlRotar = Vector3.zero;

	private bool stickRotacionACero = true;

	private Vector3 rotacionExtraDesdeUltimaRecolocacion = Vector3.zero;

	private float ticksFuera;

	[HideInInspector]
	public bool estaFueraDeLimites;

	private float tiempo;

	[HideInInspector]
	public Vector3 ultimaPosicionPlayer = Vector3.zero;

	public static InputsController GetInstance()
	{
		return instance;
	}

	private void Awake()
	{
		if (!menu && !base.transform.parent.GetComponent<PhotonView>().IsMine)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		instance = this;
		switch (Config.plataforma)
		{
		case Config.PlataformaJuego.SteamVR:
			controladorVR = base.gameObject.AddComponent<ControladorVRSteam>();
			break;
		case Config.PlataformaJuego.Oculus:
			controladorVR = base.gameObject.AddComponent<ControladorVROculus>();
			break;
		case Config.PlataformaJuego.Pico:
			controladorVR = base.gameObject.AddComponent<ControladorVRPico>();
			break;
		case Config.PlataformaJuego.Nolo:
			controladorVR = base.gameObject.AddComponent<ControladorVRNolo>();
			controladorVRNolo = (ControladorVRNolo)controladorVR;
			break;
		case Config.PlataformaJuego.PS4:
			break;
		}
	}

	private void Start()
	{
		EstablecerLimitesSala();
		playerInstance = base.transform;
		playerMovementSpeed = 2f;
		bool recolocar = Config.modoDeJuego == Config.ModosDeJuego.menu;
		RecolocarCabeza(recolocar);
		if (Debugs.SimularPlayer > 0)
		{
			Cursor.lockState = CursorLockMode.Locked;
		}
		if (Config.plataforma != Config.PlataformaJuego.Pico && Config.plataforma != Config.PlataformaJuego.Nolo)
		{
			try
			{
				controladorRudder = base.transform.Find("RudderController").GetComponent<ControladorRudder>();
			}
			catch
			{
			}
			if ((bool)controladorRudder)
			{
				rudderConectado = true;
			}
		}
		currentRotation = base.transform.localEulerAngles;
		currentRotationInicial = currentRotation;
	}

	public void EstablecerLimitesSala()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 2)
		{
			maxRoomCapacityMovementForward = -4.3f;
			maxRoomCapacityMovementBackwards = 4.5f;
			maxRoomCapacityMovementToRight = 1.4f;
			maxRoomCapacityMovementToLeft = -3.7f;
		}
		else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 4)
		{
			maxRoomCapacityMovementForward = -6.3f;
			maxRoomCapacityMovementBackwards = 7.8f;
			maxRoomCapacityMovementToRight = 3f;
			maxRoomCapacityMovementToLeft = -5.3f;
		}
		else if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo && Config.numJugadoresOnline == 8)
		{
			maxRoomCapacityMovementForward = -6.3f;
			maxRoomCapacityMovementBackwards = 7.8f;
			maxRoomCapacityMovementToRight = 3f;
			maxRoomCapacityMovementToLeft = -5.3f;
		}
		else if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			maxRoomCapacityMovementForward = 0.1f;
			maxRoomCapacityMovementBackwards = 3f;
			maxRoomCapacityMovementToRight = 2f;
			maxRoomCapacityMovementToLeft = -2f;
		}
	}

	private Vector3 QuitarY(Vector3 miVector)
	{
		return new Vector3(miVector.x, 0f, miVector.z);
	}

	private void Update()
	{
		if (Debugs.SimularPlayer > 0)
		{
			GetInputsNOVR();
		}
		else
		{
			GetInputs();
		}
		if (rudderConectado)
		{
			UpdateRudder();
		}
		if (menu || Config.modoDeJuego == Config.ModosDeJuego.menu || ((bool)GameManager.instance && (bool)GameManager.instance.m_salaManager && GameManager.instance.m_salaManager.nivelIniciado))
		{
			Moverse();
		}
		if (Config.modoDeJuego != Config.ModosDeJuego.menu && !menu)
		{
			CalcularLimites();
		}
		if ((botonPausa || Input.GetKeyDown(KeyCode.M)) && !GameManager.instance.player.fueraDeLimites)
		{
			if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa)
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: false, Player.EstadoZonaNegra.Pausa);
			}
			else
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: true, Player.EstadoZonaNegra.Pausa);
			}
		}
	}

	public bool GetBotonCambiarPistolaGanchoUp(bool derecho)
	{
		if (derecho)
		{
			return botonCambiarPistolaGanchoDerUp;
		}
		return botonCambiarPistolaGanchoIzqUp;
	}

	public void SetBotonCambiarPistolaGanchoUp(bool derecho, bool value)
	{
		if (derecho)
		{
			botonCambiarPistolaGanchoDerUp = value;
		}
		else
		{
			botonCambiarPistolaGanchoIzqUp = value;
		}
	}

	private void GetInputsNOVR()
	{
		botonRecolocar = Input.GetKeyUp(KeyCode.Q);
		botonRecolocarUp = oldBotonPausa && !botonRecolocar;
		botonRecolocarDown = !oldBotonPausa && botonRecolocar;
		oldBotonPausa = botonPausa;
		botonPausa = Input.GetKeyUp(KeyCode.Escape);
		botonPausaUp = oldBotonPausa && !botonPausa;
		botonPausaDown = !oldBotonPausa && botonPausa;
		oldBotonPausa = botonPausa;
		triggerDerecho = (Input.GetMouseButton(1) ? 1 : 0);
		triggerDerechoUp = Input.GetMouseButtonDown(0);
		triggerIzquierdo = (Input.GetMouseButton(0) ? 1 : 0);
		triggerIzquierdoUp = Input.GetMouseButtonDown(1);
		gripDerecho = 0f;
		gripDerechoDown = Input.GetKeyDown(KeyCode.I);
		if (Input.GetKey(KeyCode.A))
		{
			stickIzquierdo.x = -1f;
		}
		else if (Input.GetKey(KeyCode.D))
		{
			stickIzquierdo.x = 1f;
		}
		else
		{
			stickIzquierdo.x = 0f;
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa)
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: false, Player.EstadoZonaNegra.Pausa);
			}
			else
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: true, Player.EstadoZonaNegra.Pausa);
			}
		}
		if (Input.GetKey(KeyCode.W))
		{
			stickIzquierdo.y = 1f;
		}
		else if (Input.GetKey(KeyCode.S))
		{
			stickIzquierdo.y = -1f;
		}
		else
		{
			stickIzquierdo.y = 0f;
		}
		stickDerecho.x = Input.GetAxis("Mouse X");
		stickDerecho.y = Input.GetAxis("Mouse Y");
	}

	private void GetInputs()
	{
		if (!controladorVR)
		{
			UnityEngine.Debug.Log("no hay controlador");
			return;
		}
		botonAtras = controladorVR.GetBoton(ControladorVR.TipoBoton.Atras);
		botonPausa = controladorVR.GetBoton(ControladorVR.TipoBoton.Pausa);
		botonPausaUp = oldBotonPausa && !botonPausa;
		botonPausaDown = !oldBotonPausa && botonPausa;
		oldBotonPausa = botonPausa;
		botonRecolocar = controladorVR.GetBoton(ControladorVR.TipoBoton.Recolocar);
		botonRecolocarUp = oldBotonRecolocar && !botonRecolocar;
		botonRecolocarDown = !oldBotonRecolocar && botonRecolocar;
		oldBotonRecolocar = botonRecolocar;
		botonCambiarPistolaGanchoDer = controladorVR.GetBoton(ControladorVR.TipoBoton.CambiarBalaGancho);
		botonCambiarPistolaGanchoDerUp = oldBotonCambiarPistolaGanchoDer && !botonCambiarPistolaGanchoDer;
		botonCambiarPistolaGanchoDerDown = !oldBotonCambiarPistolaGanchoDer && botonCambiarPistolaGanchoDer;
		oldBotonCambiarPistolaGanchoDer = botonCambiarPistolaGanchoDer;
		botonCambiarPistolaGanchoIzq = controladorVR.GetBoton(ControladorVR.TipoBoton.CambiarBalaGancho, derecha: false);
		botonCambiarPistolaGanchoIzqUp = oldBotonCambiarPistolaGanchoIzq && !botonCambiarPistolaGanchoIzq;
		botonCambiarPistolaGanchoIzqDown = !oldBotonCambiarPistolaGanchoIzq && botonCambiarPistolaGanchoIzq;
		oldBotonCambiarPistolaGanchoIzq = botonCambiarPistolaGanchoIzq;
		float num = controladorVR.GetTrigger(ControladorVR.TipoControl.ControlDerecha);
		triggerDerechoUp = triggerDerecho > 0.1f && num < 0.1f;
		triggerDerechoDown = triggerDerecho < 0.1f && num > 0.1f;
		triggerDerecho = num;
		num = controladorVR.GetTrigger(ControladorVR.TipoControl.ControlIzquierda);
		triggerIzquierdoUp = triggerIzquierdo > 0.1f && num < 0.1f;
		triggerIzquierdoDown = triggerIzquierdo < 0.1f && num > 0.1f;
		triggerIzquierdo = num;
		float grip = controladorVR.GetGrip(ControladorVR.TipoControl.ControlDerecha);
		gripDerechoUp = gripDerecho > 0.1f && grip < 0.1f;
		gripDerechoDown = gripDerecho < 0.1f && grip > 0.1f;
		gripDerecho = grip;
		grip = controladorVR.GetGrip(ControladorVR.TipoControl.ControlIzquierda);
		gripIzquierdoUp = gripIzquierdo > 0.1f && grip < 0.1f;
		gripIzquierdoDown = gripIzquierdo < 0.1f && grip > 0.1f;
		gripIzquierdo = grip;
		posicionSensorR = controladorVR.GetLocalPosition(ControladorVR.TipoControl.ControlDerecha);
		rotacionSensorR = controladorVR.GetLocalRotation(ControladorVR.TipoControl.ControlDerecha);
		posicionSensorL = controladorVR.GetLocalPosition(ControladorVR.TipoControl.ControlIzquierda);
		rotacionSensorL = controladorVR.GetLocalRotation(ControladorVR.TipoControl.ControlIzquierda);
		if ((bool)leftHand)
		{
			leftHandVelocity = (posicionSensorL - posAnteriorManoIzquierda).magnitude / Time.deltaTime;
			leftHandVelocityVector = (posicionSensorL - posAnteriorManoIzquierda).normalized;
			posAnteriorManoIzquierda = posicionSensorL;
		}
		if ((bool)rightHand)
		{
			rightHandVelocity = (posicionSensorR - posAnteriorManoDerecha).magnitude / Time.deltaTime;
			rightHandVelocityVector = (posicionSensorR - posAnteriorManoDerecha).normalized;
			posAnteriorManoDerecha = posicionSensorR;
		}
		stickIzquierdo = controladorVR.GetStick(ControladorVR.TipoControl.ControlIzquierda);
		stickDerecho = controladorVR.GetStick(ControladorVR.TipoControl.ControlDerecha);
		if (!Config.tiene2Sensores && (Mathf.Abs(stickDerecho.x) > 0f || Mathf.Abs(stickDerecho.y) > 0f))
		{
			if (Mathf.Abs(stickIzquierdo.x) < 0.1f || Mathf.Abs(stickIzquierdo.y) < 0.1f)
			{
				stickIzquierdo = stickDerecho;
			}
			stickDerecho = Vector3.zero;
		}
	}

	public void ResetLastPosHand(bool derecha)
	{
		if (derecha)
		{
			posAnteriorManoDerecha = rightHand.transform.position;
		}
		else
		{
			posAnteriorManoIzquierda = leftHand.transform.position;
		}
	}

	public Vector3 DesrotarPlayer()
	{
		currentRotation = currentRotationInicial;
		return currentRotation;
	}

	private void MovimientoDebugRoomScale()
	{
		if (!GameManager.instance.player || !GameManager.instance.player.roomScale)
		{
			return;
		}
		if (stickIzquierdo.y > 0.3f || stickDerecho.y > 0.3f)
		{
			float y = stickIzquierdo.y;
			if (stickDerecho.y > 0.3f)
			{
				y = stickDerecho.y;
			}
			GameManager.instance.player.playerRoomScale.position += QuitarY(GameManager.instance.player.playerRoomScale.transform.forward) * y * Time.deltaTime;
		}
		else if (stickIzquierdo.y < -0.3f || stickDerecho.y < -0.3f)
		{
			float y2 = stickIzquierdo.y;
			if (stickDerecho.y < -0.3f)
			{
				y2 = stickDerecho.y;
			}
			GameManager.instance.player.playerRoomScale.position += QuitarY(-GameManager.instance.player.playerRoomScale.transform.forward) * (0f - y2) * Time.deltaTime;
		}
		if (stickIzquierdo.x > 0.3f || stickDerecho.x > 0.3f)
		{
			float x = stickIzquierdo.x;
			if (stickDerecho.x > 0.3f)
			{
				x = stickDerecho.x;
			}
			GameManager.instance.player.playerRoomScale.position += QuitarY(GameManager.instance.player.playerRoomScale.transform.right) * x * Time.deltaTime;
		}
		else if (stickIzquierdo.x < -0.3f || stickDerecho.x < -0.3f)
		{
			float x2 = stickIzquierdo.x;
			if (stickDerecho.x < -0.3f)
			{
				x2 = stickDerecho.x;
			}
			GameManager.instance.player.playerRoomScale.position += QuitarY(-GameManager.instance.player.playerRoomScale.transform.right) * (0f - x2) * Time.deltaTime;
		}
		if (!primeraVez)
		{
			currentRotation = base.transform.localEulerAngles;
			currentRotationInicial = currentRotation;
			oldRotation = currentRotation;
			primeraVez = true;
		}
		if (Debugs.SimularPlayer > 0)
		{
			currentRotation.x += (0f - stickDerecho.y) * sensitivity;
			currentRotation.y -= (0f - stickDerecho.x) * sensitivity;
			currentRotation.x = Mathf.Repeat(currentRotation.x, 360f);
			currentRotation.y = Mathf.Clamp(currentRotation.y, -360f, 360f);
			bool num = oldRotation != currentRotation;
			if (num)
			{
				base.transform.position = head.transform.position;
			}
			base.transform.localEulerAngles = currentRotation;
			if (num)
			{
				RecolocarCabeza(recolocar: false, recolocarPorRotacionJoystick: true);
			}
		}
	}

	private void Moverse()
	{
		float num = 1f;
		num = 2f;
		Vector3 position = base.transform.position;
		if (GameManager.instance.player.noPoderMoverse && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			return;
		}
		if (stickIzquierdo.y > 0.3f || rudder.y > 0.3f)
		{
			float y = stickIzquierdo.y;
			if (rudder.y > 0.3f)
			{
				y = rudder.y;
			}
			y *= 1.5f;
			base.transform.position += QuitarY(GameManager.instance.player.cabeza.transform.forward) * y * num * Time.deltaTime;
		}
		else if (stickIzquierdo.y < -0.3f || rudder.y < -0.3f)
		{
			float y2 = stickIzquierdo.y;
			if (rudder.y < -0.3f)
			{
				y2 = rudder.y;
			}
			y2 *= 1.5f;
			base.transform.position += QuitarY(-GameManager.instance.player.cabeza.transform.forward) * (0f - y2) * num * Time.deltaTime;
		}
		if (stickIzquierdo.x > 0.3f || rudder.x > 0.3f)
		{
			float x = stickIzquierdo.x;
			if (rudder.x > 0.3f)
			{
				x = rudder.x;
			}
			x *= 1.5f;
			base.transform.position += QuitarY(GameManager.instance.player.cabeza.transform.right) * x * num * Time.deltaTime;
		}
		else if (stickIzquierdo.x < -0.3f || rudder.x < -0.3f)
		{
			float x2 = stickIzquierdo.x;
			if (rudder.x < -0.3f)
			{
				x2 = rudder.x;
			}
			x2 *= 1.5f;
			base.transform.position += QuitarY(-GameManager.instance.player.cabeza.transform.right) * (0f - x2) * num * Time.deltaTime;
		}
		base.transform.position = MovimientoPermitido(position, base.transform.position);
		if (!primeraVez)
		{
			currentRotation = base.transform.localEulerAngles;
			oldRotation = currentRotation;
			primeraVez = true;
		}
		float num2 = 0f;
		if (stickRotacionACero)
		{
			if (stickDerecho.x > 0.1f)
			{
				num2 = 45f;
				stickRotacionACero = false;
			}
			else if (stickDerecho.x < -0.1f)
			{
				num2 = -45f;
				stickRotacionACero = false;
			}
		}
		else if (Mathf.Abs(stickDerecho.x) < 0.1f)
		{
			stickRotacionACero = true;
		}
		if (Debugs.SimularPlayer > 0)
		{
			currentRotation.x += (0f - stickDerecho.y) * sensitivity;
			currentRotation.y -= (0f - stickDerecho.x) * sensitivity;
			currentRotation.x = Mathf.Repeat(currentRotation.x, 360f);
			currentRotation.y = Mathf.Clamp(currentRotation.y, -360f, 360f);
			base.transform.localEulerAngles = currentRotation;
		}
		else if (!stickRotacionACero && num2 != 0f && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			currentRotation.y += num2;
			rotacionConJoystick += num2;
			bool num3 = oldRotation != currentRotation;
			poscabezaAlRotar = head.transform.position;
			if (num3)
			{
				RecolocarCabeza(recolocar: false, recolocarPorRotacionJoystick: true);
				oldRotation = currentRotation;
			}
		}
	}

	private Vector3 MovimientoPermitido(Vector3 oldPos, Vector3 newPos)
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			return newPos;
		}
		if (head.position.x < maxRoomCapacityMovementForward - 0.15f && newPos.x < oldPos.x)
		{
			newPos.x = oldPos.x;
		}
		if (head.position.x > maxRoomCapacityMovementBackwards + 0.15f && newPos.x > oldPos.x)
		{
			newPos.x = oldPos.x;
		}
		if (head.position.z > maxRoomCapacityMovementToRight + 0.1f && newPos.z > oldPos.z)
		{
			newPos.z = oldPos.z;
		}
		if (head.position.z < maxRoomCapacityMovementToLeft - 0.1f && newPos.z < oldPos.z)
		{
			newPos.z = oldPos.z;
		}
		return newPos;
	}

	private void CalcularLimites()
	{
		if (!GameManager.instance.player)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		posicionDeseadaPlayer.localPosition = new Vector3(0f, -1.2f, 0f);
		Vector3 zero = Vector3.zero;
		if (head.position.x >= maxRoomCapacityMovementBackwards + 0.45f)
		{
			if (!GameManager.instance.player.roomScale)
			{
				flag2 = true;
				zero.x = maxRoomCapacityMovementBackwards;
				zero.z = base.transform.position.z;
			}
			else
			{
				flag = true;
				if (ticksFuera > 10f)
				{
					Vector3 position = head.position;
					position.x = maxRoomCapacityMovementBackwards;
					Vector3 vector = base.transform.position - head.position;
					base.transform.position = position + vector;
					estaFueraDeLimites = true;
				}
				else
				{
					ticksFuera += 1f;
				}
			}
		}
		if (head.position.x <= maxRoomCapacityMovementForward - 0.45f)
		{
			if (!GameManager.instance.player.roomScale)
			{
				flag2 = true;
				zero.x = maxRoomCapacityMovementForward;
				zero.z = base.transform.position.z;
			}
			else
			{
				flag = true;
				if (ticksFuera > 10f)
				{
					Vector3 position2 = head.position;
					position2.x = maxRoomCapacityMovementForward;
					Vector3 vector2 = base.transform.position - head.position;
					base.transform.position = position2 + vector2;
					estaFueraDeLimites = true;
				}
				else
				{
					ticksFuera += 1f;
				}
			}
		}
		if (head.position.z >= maxRoomCapacityMovementToRight + 0.4f)
		{
			if (!GameManager.instance.player.roomScale)
			{
				flag2 = true;
				if (zero.x == 0f)
				{
					zero.x = base.transform.position.x;
				}
				zero.z = maxRoomCapacityMovementToRight;
			}
			else
			{
				flag = true;
				if (ticksFuera > 10f)
				{
					Vector3 position3 = head.position;
					position3.z = maxRoomCapacityMovementToRight;
					Vector3 vector3 = base.transform.position - head.position;
					base.transform.position = position3 + vector3;
					estaFueraDeLimites = true;
				}
				else
				{
					ticksFuera += 1f;
				}
			}
		}
		if (head.position.z <= maxRoomCapacityMovementToLeft - 0.4f)
		{
			if (!GameManager.instance.player.roomScale)
			{
				flag2 = true;
				if (zero.x == 0f)
				{
					zero.x = base.transform.position.x;
				}
				zero.z = maxRoomCapacityMovementToLeft;
			}
			else
			{
				flag = true;
				if (ticksFuera > 10f)
				{
					Vector3 position4 = head.position;
					position4.z = maxRoomCapacityMovementToLeft;
					Vector3 vector4 = base.transform.position - head.position;
					base.transform.position = position4 + vector4;
					estaFueraDeLimites = true;
				}
				else
				{
					ticksFuera += 1f;
				}
			}
		}
		if (zero != Vector3.zero)
		{
			zero.y = posicionDeseadaPlayer.position.y;
			posicionDeseadaPlayer.position = zero;
		}
		if (!flag)
		{
			ticksFuera = 0f;
			estaFueraDeLimites = false;
		}
		if (flag2)
		{
			bool flag3 = true;
			if (Config.plataforma == Config.PlataformaJuego.Nolo)
			{
				tiempo += Time.deltaTime;
				if (tiempo < 0.5f)
				{
					flag3 = false;
				}
			}
			if (flag3)
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: true, Player.EstadoZonaNegra.FueraLimites);
			}
		}
		else if (GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.FueraLimites)
		{
			GameManager.instance.player.ActivarDesactiarZonaOscura(activar: false, Player.EstadoZonaNegra.FueraLimites);
			tiempo = 0f;
		}
		else
		{
			tiempo = 0f;
		}
	}

	private void OnEnable()
	{
		RecolocarCabeza(recolocar: false);
	}

	public void RecolocarCabeza(bool recolocar = true, bool recolocarPorRotacionJoystick = false)
	{
		if (escenaLoadingOnline)
		{
			return;
		}
		if (posicionDeseadaPlayer == null)
		{
			posicionDeseadaPlayer = GameObject.Find("PosicionDeseadaPlayer").GetComponent<Transform>();
		}
		if (posicionDeseadaCabeza == null)
		{
			posicionDeseadaCabeza = GameObject.Find("PosicionDeseadaCabeza").GetComponent<Transform>();
		}
		if ((bool)head)
		{
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.cabezaRoomScaleScript)
			{
				GameManager.instance.player.cabezaRoomScaleScript.DesactivarLimite();
			}
			posicionDeseadaPlayer.localPosition = new Vector3(0f, (Config.modoDeJuego == Config.ModosDeJuego.menu) ? 0f : (-1.2f), 0f);
			base.transform.position = posicionDeseadaPlayer.position;
			StartCoroutine(EsperaRecolocar(recolocar, recolocarPorRotacionJoystick));
		}
	}

	private IEnumerator EsperaRecolocar(bool recolocar, bool recolocarPorRotacionJoystick = false)
	{
		if (!recolocar)
		{
			yield return null;
		}
		_ = Vector3.zero;
		if (recolocar)
		{
			Vector3 vector = head.transform.position - posicionDeseadaCabeza.position;
			base.transform.position -= vector;
			GameManager.instance.ultimaPosicionRelativaCabeza = vector;
		}
		else if (recolocarPorRotacionJoystick)
		{
			base.transform.position = poscabezaAlRotar;
		}
		else
		{
			base.transform.position -= GameManager.instance.ultimaPosicionRelativaCabeza;
		}
		if (recolocar)
		{
			float num = 0f - head.transform.localEulerAngles.y;
			base.transform.rotation = posicionDeseadaPlayer.rotation;
			base.transform.Rotate(Vector3.up * num);
			GameManager.instance.ultimaRotacionCabeza = base.transform.localEulerAngles;
			currentRotation = base.transform.localEulerAngles;
			currentRotationInicial = currentRotation;
			rotacionConJoystick = 0f;
		}
		else if (!recolocarPorRotacionJoystick)
		{
			rotacionConJoystick = 0f;
			base.transform.localEulerAngles = GameManager.instance.ultimaRotacionCabeza;
			currentRotationInicial = base.transform.localEulerAngles;
		}
		else
		{
			base.transform.localEulerAngles = currentRotation;
		}
		base.transform.position = posicionDeseadaPlayer.position;
		if (recolocar)
		{
			Vector3 vector2 = posicionDeseadaPlayer.position + Vector3.up * 1.2f;
			Vector3 vector = head.transform.position - vector2;
			base.transform.position -= vector;
			GameManager.instance.ultimaPosicionRelativaCabeza = vector;
			ultimaPosicionPlayer = base.transform.localPosition;
		}
		else if (recolocarPorRotacionJoystick)
		{
			base.transform.position = poscabezaAlRotar;
			Vector3 vector = head.transform.position - base.transform.position;
			base.transform.position -= vector;
			GameManager.instance.ultimaPosicionRelativaCabeza = vector;
		}
		else
		{
			base.transform.position -= GameManager.instance.ultimaPosicionRelativaCabeza;
			ultimaPosicionPlayer = base.transform.localPosition;
		}
		if ((bool)GameManager.instance.player && Config.modoDeJuego != Config.ModosDeJuego.menu)
		{
			GameManager.instance.player.RecolocarCabezaRoomScale();
		}
	}

	public void CambiarPlayer()
	{
		if (GameManager.instance.m_salaManager.nivelIniciado)
		{
			playerInstance = base.transform.parent.GetComponent<Transform>();
		}
		else
		{
			playerInstance = base.transform.GetComponent<Transform>();
		}
	}

	private void UpdateRudder()
	{
		rudder = controladorRudder.movimientoRudder;
	}
}
public class JointSystem : MonoBehaviour
{
	public Transform conexion1;

	public Transform conexion2;

	private LineRenderer lr;

	private void Start()
	{
		lr = GetComponent<LineRenderer>();
	}

	private void Update()
	{
		Conectar();
	}

	private void Conectar()
	{
		lr.SetPosition(0, conexion1.position);
		lr.SetPosition(1, conexion2.position);
	}
}
public class PhysicsControl : MonoBehaviour
{
	public static PhysicsControl instance;

	private Transform player;

	public static PhysicsControl GetInsatance()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private IEnumerator Start()
	{
		while (!GameManager.instance.player)
		{
			yield return null;
		}
		player = GameManager.instance.player.tJugador;
	}

	public Vector3 FuerzaInicial(Rigidbody rb, Vector3 dir, float fuerza)
	{
		return dir * fuerza * 1.5f;
	}

	public Vector3 Bounce(Vector3 collisionNormal, Vector3 lastFrameVel, Rigidbody rb, float vel, out Vector3 velocidadSinTrucar)
	{
		Vector3 zero = Vector3.zero;
		_ = lastFrameVel.magnitude;
		zero = Vector3.Reflect(lastFrameVel.normalized, collisionNormal).normalized;
		Vector3 vector = zero * vel;
		if (vector.y > 0f)
		{
			vector.y = 1f;
		}
		else
		{
			vector.y = -1f;
		}
		vector *= 1.5f;
		rb.velocity = vector;
		velocidadSinTrucar = vector;
		return vector;
	}

	public Vector3 BounceToPlayer(Vector3 collisionNormal, Vector3 lastFrameVel, Rigidbody rb, float vel, float porcentaje, out Vector3 velocidadSinTrucar)
	{
		Vector3 zero = Vector3.zero;
		_ = lastFrameVel.magnitude;
		zero = Vector3.Reflect(lastFrameVel.normalized, collisionNormal);
		if (!player && (bool)GameManager.instance.player)
		{
			player = GameManager.instance.player.tJugador;
		}
		Vector3 vector = player.position - rb.transform.position;
		_ = (zero * (1f - porcentaje) + vector * porcentaje).normalized;
		Vector3 vector2 = zero.normalized * vel;
		if (vector2.y > 0f)
		{
			vector2.y = 1f;
		}
		else
		{
			vector2.y = -1f;
		}
		vector2 *= 1.5f;
		rb.velocity = vector2;
		velocidadSinTrucar = vector2;
		return vector2;
	}
}
public class SetCorrectCameraHeight : MonoBehaviour
{
	private enum TrackingSpace
	{
		Stationary,
		RoomScale
	}

	[Header("Camera Settings")]
	[SerializeField]
	[Tooltip("Decide if experience is Room Scale or Stationary. Note this option does nothing for mobile VR experiences, these experience will default to Stationary")]
	private TrackingSpace m_TrackingSpace;

	[SerializeField]
	[Tooltip("Camera Height - overwritten by device settings when using Room Scale ")]
	private float m_StationaryCameraYOffset = 1.36144f;

	[SerializeField]
	[Tooltip("GameObject to move to desired height off the floor (defaults to this object if none provided)")]
	private GameObject m_CameraFloorOffsetObject;

	private void Awake()
	{
		if (!m_CameraFloorOffsetObject)
		{
			UnityEngine.Debug.LogWarning("No camera container specified for VR Rig, using attached GameObject");
			m_CameraFloorOffsetObject = base.gameObject;
		}
	}

	private void Start()
	{
		SetCameraHeight();
	}

	private void SetCameraHeight()
	{
		float y = m_StationaryCameraYOffset;
		if (m_TrackingSpace == TrackingSpace.Stationary)
		{
			XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
			InputTracking.Recenter();
		}
		else if (m_TrackingSpace == TrackingSpace.RoomScale && XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
		{
			y = 0f;
		}
		if ((bool)m_CameraFloorOffsetObject)
		{
			m_CameraFloorOffsetObject.transform.localPosition = new Vector3(m_CameraFloorOffsetObject.transform.localPosition.x, y, m_CameraFloorOffsetObject.transform.localPosition.z);
		}
		InputTracking.Recenter();
	}
}
public class Musica : MonoBehaviour
{
	public AudioSource[] sonidos;

	public AudioMixer mixer;

	public AudioSource[] audioSourcesMusica;

	public AudioClip musicaBoss;

	public AudioSource musicaMenu;

	[HideInInspector]
	public int musicaNormal = -1;

	private Coroutine cambiandoMusicaCor;

	private void Awake()
	{
		GameManager.instance.m_musica = this;
		musicaNormal = -1;
	}

	private void Start()
	{
		sonidos = UnityEngine.Object.FindObjectsOfType<AudioSource>();
		audioSourcesMusica = GetComponents<AudioSource>();
	}

	public void ActivarMusica(bool activar)
	{
		if ((bool)musicaMenu)
		{
			if (activar)
			{
				musicaMenu.Play();
			}
			else
			{
				musicaMenu.Stop();
			}
		}
	}

	public void CambiarMusicaATiempoParado(bool sinFadeOut = false)
	{
		if (musicaNormal == 0)
		{
			return;
		}
		if (audioSourcesMusica == null || audioSourcesMusica.Length == 0)
		{
			audioSourcesMusica = GetComponents<AudioSource>();
		}
		if (audioSourcesMusica == null || audioSourcesMusica.Length == 0)
		{
			return;
		}
		musicaNormal = 0;
		if ((bool)this && (bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			if (cambiandoMusicaCor != null)
			{
				StopCoroutine(cambiandoMusicaCor);
			}
			cambiandoMusicaCor = StartCoroutine(CambiarMusica(audioSourcesMusica[1], audioSourcesMusica[0], 0.9f, sinFadeOut));
		}
	}

	public void CambiarMusicaATiempoNormal(bool sinFadeOut = false)
	{
		if (musicaNormal == 1)
		{
			return;
		}
		if (audioSourcesMusica == null || audioSourcesMusica.Length == 0)
		{
			audioSourcesMusica = GetComponents<AudioSource>();
		}
		if (audioSourcesMusica != null && audioSourcesMusica.Length != 0)
		{
			musicaNormal = 1;
			if (cambiandoMusicaCor != null)
			{
				StopCoroutine(cambiandoMusicaCor);
			}
			cambiandoMusicaCor = StartCoroutine(CambiarMusica(audioSourcesMusica[0], audioSourcesMusica[1], 0.9f, sinFadeOut));
		}
	}

	private IEnumerator CambiarMusica(AudioSource aOn, AudioSource aOff, float vel = 0.9f, bool sinFadeOut = false)
	{
		aOn.enabled = true;
		aOn.volume = 0f;
		float cont = 0f;
		if (sinFadeOut)
		{
			aOff.enabled = false;
		}
		while (aOn.volume < 1f)
		{
			cont = (aOn.volume = cont + Time.deltaTime * vel);
			if (!sinFadeOut)
			{
				aOff.volume = 1f - cont;
			}
			aOn.pitch = cont;
			if (!sinFadeOut)
			{
				aOff.pitch = 1f - cont;
			}
			yield return null;
		}
		aOn.volume = 1f;
		aOff.enabled = false;
		aOff.pitch = 1f;
		aOn.pitch = 1f;
	}

	public void ResetearMusica()
	{
		audioSourcesMusica[0].Stop();
		audioSourcesMusica[0].Play();
	}

	public void PonerMusicaBoss()
	{
		if ((bool)audioSourcesMusica[0] && (bool)musicaBoss)
		{
			audioSourcesMusica[0].clip = musicaBoss;
		}
	}

	public void MusicaInmortal(bool activar)
	{
		if (audioSourcesMusica.Length > 2)
		{
			if (activar)
			{
				audioSourcesMusica[2].Play();
			}
			else
			{
				audioSourcesMusica[2].Stop();
			}
		}
	}
}
public class InicioNivel : MonoBehaviour
{
	private SalasManager m_SalasManager;

	private GameObject luzTemporal;

	private bool textoReconocido;

	public GameObject textPickUpGuns;

	public GameObject pickUpGunsTexto;

	public GameObject waitingForPlayersTexto;

	public GameObject idRoomTexto;

	public TextMeshProUGUI textoNivel;

	private bool inicializado;

	public static InicioNivel instancia;

	private void Awake()
	{
		instancia = this;
	}

	public static InicioNivel GetInstance()
	{
		return instancia;
	}

	public GameObject GetTextPickUpGuns()
	{
		if (!textPickUpGuns)
		{
			textPickUpGuns = GameObject.FindGameObjectWithTag("TextPickUpGuns");
		}
		if (!pickUpGunsTexto)
		{
			pickUpGunsTexto = textPickUpGuns.transform.Find("TakeGuns").gameObject;
		}
		if (!waitingForPlayersTexto)
		{
			waitingForPlayersTexto = textPickUpGuns.transform.Find("Waiting4Players").gameObject;
		}
		if (!idRoomTexto)
		{
			idRoomTexto = textPickUpGuns.transform.Find("idRoom").gameObject;
		}
		return textPickUpGuns;
	}

	public void SetTextWaitingForPlayers()
	{
		if (!textPickUpGuns)
		{
			textPickUpGuns = GameObject.FindGameObjectWithTag("TextPickUpGuns");
		}
		if (!pickUpGunsTexto)
		{
			pickUpGunsTexto = textPickUpGuns.transform.Find("TakeGuns").gameObject;
		}
		if (!waitingForPlayersTexto)
		{
			waitingForPlayersTexto = textPickUpGuns.transform.Find("Waiting4Players").gameObject;
		}
		if (!idRoomTexto)
		{
			idRoomTexto = textPickUpGuns.transform.Find("idRoom").gameObject;
		}
		pickUpGunsTexto.SetActive(value: false);
		waitingForPlayersTexto.SetActive(value: true);
		idRoomTexto.GetComponent<TextMeshProUGUI>().text = LanguageManager.instance.DameTexto("#RoomId") + ": " + PhotonNetwork.versionPUNPartida;
		idRoomTexto.SetActive(value: true);
	}

	public void SetTextPickUpGuns()
	{
		if (!textPickUpGuns)
		{
			textPickUpGuns = GameObject.FindGameObjectWithTag("TextPickUpGuns");
		}
		if (!pickUpGunsTexto)
		{
			pickUpGunsTexto = textPickUpGuns.transform.Find("TakeGuns").gameObject;
		}
		if (!waitingForPlayersTexto)
		{
			waitingForPlayersTexto = textPickUpGuns.transform.Find("Waiting4Players").gameObject;
		}
		if (!idRoomTexto)
		{
			idRoomTexto = textPickUpGuns.transform.Find("idRoom").gameObject;
		}
		pickUpGunsTexto.SetActive(value: true);
		waitingForPlayersTexto.SetActive(value: false);
		idRoomTexto.SetActive(value: false);
	}

	private IEnumerator Start()
	{
		while (!GameManager.instance.m_salaManager)
		{
			yield return null;
		}
		m_SalasManager = GameManager.instance.m_salaManager;
		luzTemporal = GameObject.FindGameObjectWithTag("TemporaryLight");
		inicializado = true;
	}

	private void Update()
	{
		if (inicializado && (bool)GetTextPickUpGuns() && (bool)GameManager.instance.player && (bool)GameManager.instance.player.cabeza && ((textoReconocido && !GameManager.instance.player.weaponDer) || !GameManager.instance.player.weaponDer.nivelIniciado))
		{
			GetTextPickUpGuns().transform.LookAt(GameManager.instance.player.cabezaPlayerRoomScale.transform);
			GetTextPickUpGuns().transform.localEulerAngles = new Vector3(0f, GetTextPickUpGuns().transform.localEulerAngles.y, 0f);
		}
	}

	public void IniciarNivel()
	{
		if ((bool)GameManager.instance.paredMovible)
		{
			GameManager.instance.paredMovible.EmpiezaNivel();
		}
		GameManager.instance.vengoDeMuerto = false;
		GameManager.instance.nivelInicioMenu = false;
		GameManager.instance.m_salaManager.nivelIniciado = true;
		GameManager.instance.m_salaManager.ResetearRacha();
		GameManager.instance.m_musica.CambiarMusicaATiempoNormal();
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (!TimeManager.GetInstance().testInicioDesactivado)
			{
				m_SalasManager.objetosNivelActual.esferas2Player.SetActive(value: true);
			}
		}
		else if (!TimeManager.GetInstance().testInicioDesactivado)
		{
			m_SalasManager.objetosNivelActual.esferas1Player.SetActive(value: true);
		}
		if ((bool)m_SalasManager.objetosNivelActual.bloquesRompiblesGo)
		{
			m_SalasManager.objetosNivelActual.bloquesRompiblesGo.SetActive(value: true);
		}
		luzTemporal.SetActive(value: false);
		GetTextPickUpGuns().SetActive(value: false);
		GameManager.instance.m_salaManager.controladorTVs.enAnimacionBoss = false;
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.Info);
		InputsController.instance.CambiarPlayer();
		GameManager.instance.player.PonerAudioEnAudioSource(Player.ClipsAudioJugador.Inicio);
		GameManager.instance.player.inmune = false;
		if (PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado && (bool)GameManager.instance.m_salaManager.objetosNivelActual.powerupsGo && GameManager.instance.m_salaManager.objetosNivelActual.powerupsGo.transform.childCount > 0)
		{
			StartCoroutine(Esperar1SegMostrarMensaje());
		}
		else
		{
			PlayerProgreso.instance.PowerUpUsado = false;
		}
	}

	private IEnumerator Esperar1SegMostrarMensaje()
	{
		yield return new WaitForSeconds(1f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 10, 10f, 1);
		PersistentDataManager.SetInt("MensajeUsarPowerUp", 1);
	}

	private IEnumerator Esperar1SegMostrarMensajeCambioGancho()
	{
		yield return new WaitForSeconds(1f);
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 20201, 10f, 1);
		GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala = 0;
	}

	public void ReconocerTextoArmas()
	{
		textoReconocido = true;
		if (!textoNivel)
		{
			textoNivel = GetTextPickUpGuns().transform.GetChild(1).transform.GetComponent<TextMeshProUGUI>();
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
		{
			textoNivel.text = LanguageManager.instance.DameTexto("#CompetitiveArena", textoNivel);
		}
		else
		{
			textoNivel.text = GameManager.instance.NombrePais(GameManager.instance.paisActual, textoNivel) + " " + (GameManager.instance.nivelActual + 1);
		}
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.Inicio);
	}
}
public class NivelCompletado : MonoBehaviour
{
	public static NivelCompletado instance;

	public List<Transform> listaEsferasEquipo1 = new List<Transform>();

	public List<Transform> listaEsferasEquipo2 = new List<Transform>();

	public bool bossVivo;

	[HideInInspector]
	public bool yaLasHemosCambiado;

	private Coroutine pasarNivel;

	[HideInInspector]
	public bool pasandoDeNivel;

	private void Awake()
	{
		yaLasHemosCambiado = false;
		instance = this;
		GameManager.instance.bloquearBotones = false;
		listaEsferasEquipo1.Clear();
		listaEsferasEquipo2.Clear();
	}

	public static NivelCompletado GetInstance()
	{
		return instance;
	}

	public void SumarEsfera(Transform esfera, int equipo)
	{
		if (equipo == 1 || (equipo == 9 && listaEsferasEquipo1.Count > 0))
		{
			if (!listaEsferasEquipo1.Contains(esfera))
			{
				listaEsferasEquipo1.Add(esfera);
			}
		}
		else if (!listaEsferasEquipo2.Contains(esfera))
		{
			listaEsferasEquipo2.Add(esfera);
		}
	}

	public void RestarEsfera(Transform esfera)
	{
		if ((bool)this && (bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			StartCoroutine(restar(esfera));
		}
	}

	private IEnumerator restar(Transform esfera)
	{
		if (listaEsferasEquipo1.Contains(esfera))
		{
			GameManager.instance.m_salaManager.SumarRacha(esfera.position);
			listaEsferasEquipo1.Remove(esfera);
			if (GameManager.instance.powerUpTiempoActivo)
			{
				GameManager.instance.SumarEsferaDestruidaDurantePowerUpTiempo();
			}
		}
		if (listaEsferasEquipo2.Contains(esfera))
		{
			GameManager.instance.m_salaManager.SumarRacha(esfera.position);
			listaEsferasEquipo2.Remove(esfera);
			if (GameManager.instance.powerUpTiempoActivo)
			{
				GameManager.instance.SumarEsferaDestruidaDurantePowerUpTiempo();
			}
		}
		yield return new WaitForSeconds(0.5f);
		if (bossVivo || !GameManager.instance.m_salaManager.nivelIniciado || !PhotonNetwork.IsMasterClient)
		{
			yield break;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.Online)
		{
			if (Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				if (listaEsferasEquipo1.Count <= 0 && !GameManager.instance.hayEquipoGanador)
				{
					PartidaSync.instance.TenemosEquipoGanador(1, -1, porEliminacionDeBolas: true);
				}
				else if (listaEsferasEquipo2.Count <= 0 && !GameManager.instance.hayEquipoGanador)
				{
					PartidaSync.instance.TenemosEquipoGanador(2, -1, porEliminacionDeBolas: true);
				}
			}
			else if (Config.modoDePartida == Config.ModoDePartida.Cooperativo && listaEsferasEquipo1.Count + listaEsferasEquipo2.Count <= 0)
			{
				PartidaSync.instance.ClientesPasadDeNivel();
			}
		}
		else if (listaEsferasEquipo1.Count + listaEsferasEquipo2.Count <= 0)
		{
			PasarDeNivel();
		}
	}

	public void PoderAcabarConLasEsferasDelOtroPlayer(int equipoAAyudar, bool porMuerte, float tiempo = 0f)
	{
		if (!yaLasHemosCambiado || porMuerte)
		{
			yaLasHemosCambiado = true;
			StartCoroutine(TransferirBolasAlOtro(equipoAAyudar, porMuerte, tiempo));
		}
	}

	private IEnumerator TransferirBolasAlOtro(int equipoAAyudar, bool porMuerte, float tiempo = 0f)
	{
		if (tiempo > 0f)
		{
			yield return new WaitForSeconds(tiempo);
		}
		List<Transform> list = new List<Transform>();
		foreach (Transform item in listaEsferasEquipo1)
		{
			list.Add(item);
		}
		foreach (Transform item2 in listaEsferasEquipo2)
		{
			list.Add(item2);
		}
		foreach (Transform item3 in list)
		{
			Bola component = item3.GetComponent<Bola>();
			if (!porMuerte)
			{
				component.CambiarDeEquipo(9);
				continue;
			}
			component.CambiarDeEquipo((equipoAAyudar != 1) ? 1 : 2);
			if (equipoAAyudar == 1)
			{
				listaEsferasEquipo2.Add(item3);
			}
			else
			{
				listaEsferasEquipo1.Add(item3);
			}
		}
		if (porMuerte)
		{
			if (equipoAAyudar == 1)
			{
				listaEsferasEquipo1.Clear();
			}
			else
			{
				listaEsferasEquipo2.Clear();
			}
		}
	}

	public void Desbloquear()
	{
		if (!Debugs.nivelesDesbloqueados && PlayerProgreso.instance.ultimoPaisPasado < GameManager.instance.paisActual)
		{
			PlayerProgreso.instance.GuardarNuevoPaisPasado();
			GameManager.instance.nuevoPaisDesloqueado = true;
		}
	}

	public void PasarDeNivel()
	{
		if (pasarNivel == null)
		{
			PlayerProgreso.instance.MostrarMensajeNoPoerUpUsado = false;
			PlayerProgreso.instance.rachaDerrotas = 0;
			PlayerProgreso.instance.rachaVictorias++;
			GameManager.instance.m_salaManager.SubirPuntuacionARecords();
			GameManager.instance.player.QuitarInmortalidad();
			if ((bool)GameManager.instance.paredMovible)
			{
				GameManager.instance.paredMovible.Apagar();
			}
			yaLasHemosCambiado = false;
			GameManager.instance.esferasActivas.Clear();
			if (GameManager.instance.nivelActual == 9)
			{
				GameManager.instance.paisActual++;
				Desbloquear();
				GameManager.instance.vengoDeBoss = true;
				GameManager.instance.bloquearBotones = false;
				LoadingCamera.instance.CargarEscena("MenuPrincipal");
			}
			else if (pasarNivel == null)
			{
				pasarNivel = StartCoroutine(CorrutinaPasarDeNivel());
			}
		}
	}

	private IEnumerator CorrutinaPasarDeNivel()
	{
		while (GameManager.instance.player.zonaOscuraActivada)
		{
			yield return null;
		}
		GameManager.instance.player.noPoderMoverse = true;
		GameManager.instance.PartidasAcabadasSinCambiarEntreGanchoBala++;
		GameManager.instance.player.Vibra(Player.TipoVibracion.pasarseLivel);
		pasandoDeNivel = true;
		GameManager.instance.player.SetObjetoMuerte(null);
		GameManager.instance.m_musica.CambiarMusicaATiempoParado();
		GameManager.instance.player.PonerAudioEnAudioSource(Player.ClipsAudioJugador.Victoria);
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Apagar();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Apagar();
		}
		if ((bool)GameManager.instance.player.rifle)
		{
			GameManager.instance.player.rifle.ApagarRifle();
		}
		GameManager.instance.player.ReproducirAudioSourceRoomScale(Player.ClipsAudioJugador.DesaparecerGlobalRS);
		yield return new WaitForSeconds(1f);
		while (GameManager.instance.player.zonaOscuraActivada)
		{
			yield return null;
		}
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.CambiarTipoDeArma(Weapon.TipoDeArma.Normal);
		}
		GameManager.instance.comenzarPartidaOnline = false;
		GameManager.instance.player.VolverAPosicionarPistolasEnSuSitio();
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.gameObject.SetActive(value: true);
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.gameObject.SetActive(value: true);
		}
		if ((bool)GameManager.instance.player.weaponDer)
		{
			GameManager.instance.player.weaponDer.Encender();
		}
		if ((bool)GameManager.instance.player.weaponIzq)
		{
			GameManager.instance.player.weaponIzq.Encender();
		}
		TimeManager.instance.ticksConTiempoNormalForzado = 120;
		PoolObjetos.instance.EliminarTodosLosObjetos(null, porVictoria: true);
		GameManager.instance.m_salaManager.nivelIniciado = false;
		GameManager.instance.m_salaManager.controladorTVs.CambiarTV(ControladorTVs.PosicionEnMenu.LevelClear);
		yield return new WaitForSeconds(1f);
		while (GameManager.instance.player.zonaOscuraActivada)
		{
			yield return null;
		}
		GameManager.instance.MostrarOcultarMensajeBinarity(estado: true, 999, 4f, 1);
		while (GameManager.instance.player.zonaOscuraActivada)
		{
			yield return null;
		}
		yield return new WaitForSeconds(4f);
		while (GameManager.instance.player.zonaOscuraActivada)
		{
			yield return null;
		}
		GameManager.instance.player.PosicionarAlPlayerEnSuSitio();
		InputsController.instance.CambiarPlayer();
		GameManager.instance.nivelActual++;
		if (!Debugs.nivelesDesbloqueados && PlayerProgreso.instance.ultimoPaisPasado == GameManager.instance.paisActual && PlayerProgreso.instance.ultimoNivelPasado < GameManager.instance.nivelActual)
		{
			PlayerProgreso.instance.GuardarNuevoNivelPasado();
		}
		GameManager.instance.m_salaManager.objetosNivelActual.Destruirme();
		GameManager.instance.m_salaManager.CargarSalaNivel(GameManager.instance.nivelActual);
		foreach (int key in PartidaSync.instance.jugadores.Keys)
		{
			if (PartidaSync.instance.jugadores.ContainsKey(key) && PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer >= 0)
			{
				PartidaSync.instance.DameJugadorOnline(PartidaSync.instance.jugadores[key].idPhotonObjetoPlayer).GetComponent<SyncJugadores>().PonermeResucitado();
			}
		}
		if (GameManager.instance.paisActual == 0 && GameManager.instance.nivelActual == 1)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 0 && GameManager.instance.nivelActual == 4)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 0 && GameManager.instance.nivelActual == 9)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 1 && GameManager.instance.nivelActual == 4)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 1 && GameManager.instance.nivelActual == 9)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 2 && GameManager.instance.nivelActual == 4)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 2 && GameManager.instance.nivelActual == 9)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 3 && GameManager.instance.nivelActual == 4)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		else if (GameManager.instance.paisActual == 3 && GameManager.instance.nivelActual == 9)
		{
			InicioNivel.GetInstance().GetTextPickUpGuns().SetActive(value: false);
		}
		InicioNivel.instancia.ReconocerTextoArmas();
		pasarNivel = null;
		pasandoDeNivel = false;
		GameManager.instance.player.cabezaRoomScaleScript.ColliderHabitacion.SetActive(value: false);
		yield return new WaitForSeconds(0.1f);
		GameManager.instance.player.cabezaRoomScaleScript.ComprobarSiEstaDentro();
		while (GameManager.instance.player.cabezaRoomScaleScript.estaFuera)
		{
			yield return new WaitForSeconds(0.1f);
		}
		GameManager.instance.player.cabezaRoomScaleScript.ColliderHabitacion.SetActive(value: true);
	}
}
public class PoolObjetos : MonoBehaviour
{
	public enum TipoObjeto
	{
		Esfera,
		BalaTorreta,
		Bala
	}

	public static PoolObjetos instance;

	public string[] pathObjetos;

	public List<GameObject> objetosInstanciados;

	public int cantidad;

	private Vector3 posInstancia = new Vector3(0f, -100f, 0f);

	private List<GameObject> balasTorretas = new List<GameObject>();

	private List<GameObject> balas = new List<GameObject>();

	public List<GameObject> esferas = new List<GameObject>();

	private int contActualBalaTorreta;

	private int contActualBala;

	private int contActualEsfera;

	public static PoolObjetos GetInstance()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		for (int i = 0; i < 3; i++)
		{
			string text = "";
			switch (i)
			{
			case 0:
				text = "Esfera_";
				cantidad = 55;
				break;
			case 1:
				text = "BalaTorreta_";
				cantidad = 20;
				break;
			case 2:
				text = "Bala_";
				cantidad = 50;
				break;
			}
			for (int j = 0; j < cantidad; j++)
			{
				if (PhotonNetwork.IsMasterClient || (i != 0 && i != 1))
				{
					GameObject gameObject = PhotonNetwork.Instantiate(pathObjetos[i], posInstancia * (i + 1), Quaternion.identity, 0);
					gameObject.name = text + j;
					gameObject.transform.SetParent(base.transform);
					if (gameObject.tag != "EsferaExplotando")
					{
						gameObject.SetActive(value: false);
					}
					objetosInstanciados.Add(gameObject);
					switch (i)
					{
					case 0:
						esferas.Add(gameObject);
						break;
					case 1:
						balasTorretas.Add(gameObject);
						break;
					case 2:
						balas.Add(gameObject);
						break;
					}
				}
			}
		}
	}

	public GameObject Instanciar(TipoObjeto objeto, Vector3 posicion, Quaternion rotacion, Transform parent, int equipo, Bola.TipoEsfera tipoesfera = Bola.TipoEsfera.desconocido, Bola.TipoEscudo tipoEscudo = Bola.TipoEscudo.cont)
	{
		GameObject gameObject = null;
		int num = 0;
		int num2 = 0;
		switch (objeto)
		{
		case TipoObjeto.Esfera:
			num = contActualEsfera;
			break;
		case TipoObjeto.BalaTorreta:
			num = contActualBalaTorreta;
			break;
		case TipoObjeto.Bala:
			num = contActualBala;
			break;
		}
		do
		{
			switch (objeto)
			{
			case TipoObjeto.Esfera:
				gameObject = esferas[contActualEsfera];
				contActualEsfera++;
				if (contActualEsfera >= esferas.Count)
				{
					contActualEsfera = 0;
				}
				num2 = contActualEsfera;
				break;
			case TipoObjeto.BalaTorreta:
				gameObject = balasTorretas[contActualBalaTorreta];
				contActualBalaTorreta++;
				if (contActualBalaTorreta >= balasTorretas.Count)
				{
					contActualBalaTorreta = 0;
				}
				num2 = contActualBalaTorreta;
				break;
			case TipoObjeto.Bala:
				gameObject = balas[contActualBala];
				contActualBala++;
				if (contActualBala >= balas.Count)
				{
					contActualBala = 0;
				}
				num2 = contActualBala;
				break;
			}
		}
		while (gameObject.activeInHierarchy && num != num2);
		if (gameObject.activeInHierarchy)
		{
			EliminarInmediatamente(gameObject, objeto);
			gameObject.SetActive(value: false);
		}
		gameObject.transform.parent = parent;
		gameObject.transform.position = posicion;
		gameObject.transform.rotation = rotacion;
		switch (objeto)
		{
		case TipoObjeto.Bala:
			gameObject.GetComponent<Bala>().equipo = equipo;
			gameObject.transform.gameObject.SetActive(value: true);
			break;
		case TipoObjeto.Esfera:
		{
			Bola component = gameObject.GetComponent<Bola>();
			component.SetEquipo(equipo);
			if (tipoesfera != Bola.TipoEsfera.desconocido)
			{
				component.SetTipoEsfera(tipoesfera);
			}
			if (tipoEscudo != Bola.TipoEscudo.cont)
			{
				component.SetTipoEscudo(tipoEscudo);
			}
			gameObject.transform.gameObject.SetActive(value: false);
			break;
		}
		default:
			gameObject.GetComponent<BalaEsfera>().equipo = equipo;
			gameObject.transform.gameObject.SetActive(value: true);
			break;
		}
		return gameObject;
	}

	private void EliminarInmediatamente(GameObject obj, TipoObjeto tipo)
	{
		switch (tipo)
		{
		case TipoObjeto.Esfera:
		{
			obj.GetComponent<Bola>().Disable();
			EsferaScript component = obj.GetComponent<EsferaScript>();
			if ((bool)component)
			{
				component.DisableEsfera();
				component.Resetear();
			}
			break;
		}
		case TipoObjeto.BalaTorreta:
			obj.GetComponent<SyncBala>().Disable();
			break;
		case TipoObjeto.Bala:
			obj.GetComponent<Bala>().Disable();
			obj.GetComponent<SyncBala>().Disable();
			break;
		}
		EfectoDesaparecer component2 = obj.GetComponent<EfectoDesaparecer>();
		if ((bool)component2)
		{
			component2.Disable();
		}
	}

	public void Eliminar(GameObject objeto, bool HacerEfectoDesaparecer = false)
	{
		int num = 1;
		Bola component = objeto.GetComponent<Bola>();
		if ((bool)component)
		{
			if (HacerEfectoDesaparecer && component.gameObject.activeInHierarchy)
			{
				EfectoDesaparecer component2 = component.GetComponent<EfectoDesaparecer>();
				if ((bool)component2)
				{
					component.SetTipoEsfera(Bola.TipoEsfera.desconocido);
					component2.Desaparecer(rapido: true);
					return;
				}
			}
			component.Resetear();
			EsferaScript component3 = component.GetComponent<EsferaScript>();
			if ((bool)component3)
			{
				component3.ResetearEsfera();
			}
		}
		else
		{
			num = 2;
		}
		objeto.SetActive(value: false);
		if ((bool)this && (bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			StartCoroutine(SetParentConRetraso(objeto, num));
		}
		objeto.transform.position = posInstancia * num;
		objeto.transform.rotation = Quaternion.identity;
		if ((bool)objeto.GetComponent<Rigidbody>())
		{
			objeto.GetComponent<Rigidbody>().velocity = Vector3.zero;
		}
	}

	private IEnumerator SetParentConRetraso(GameObject objeto, int mult)
	{
		yield return null;
		if ((bool)objeto)
		{
			objeto.transform.SetParent(base.transform);
			objeto.transform.position = posInstancia * mult;
			objeto.transform.rotation = Quaternion.identity;
		}
	}

	public void EliminarTodosLosObjetos(GameObject excluir = null, bool porVictoria = false)
	{
		foreach (GameObject torretasEncendida in GameManager.instance.torretasEncendidas)
		{
			torretasEncendida.GetComponent<EfectoDesaparecer>().Desaparecer();
		}
		foreach (GameObject minasEncendida in GameManager.instance.minasEncendidas)
		{
			if (minasEncendida != excluir)
			{
				minasEncendida.GetComponent<EfectoDesaparecer>().Desaparecer();
			}
		}
		foreach (GameObject bloquesEncendido in GameManager.instance.bloquesEncendidos)
		{
			bloquesEncendido.GetComponent<EfectoDesaparecer>().Desaparecer();
		}
		GameManager.instance.torretasEncendidas.Clear();
		GameManager.instance.minasEncendidas.Clear();
		GameManager.instance.bloquesEncendidos.Clear();
		for (int i = 0; i < objetosInstanciados.Count; i++)
		{
			if (excluir != objetosInstanciados[i])
			{
				try
				{
					Eliminar(objetosInstanciados[i], porVictoria);
				}
				catch
				{
				}
			}
		}
	}
}
public class TimeManager : MonoBehaviour
{
	public float TIEMPO_MINIMO = 0.008f;

	private float tiempoEquipo1 = 1f;

	private float tiempoEquipo2 = 1f;

	public float miTiempo = 1f;

	public float deltaTime;

	public float fixedDelta;

	public float timeScale = 1f;

	public float timeDeseado;

	public float velocidadCabeza;

	public float velocidadManoDerecha;

	public float velocidadManoIzquierda;

	private float timeDeseadoAnterior;

	public static TimeManager instance;

	[Space(30f)]
	public bool testTiempoNormal;

	public bool testInicioDesactivado;

	public bool jugadorInmortal;

	public bool tiempoRapido;

	public bool timeNormal;

	public bool tiempoMenu;

	public bool tiempoMuerto;

	private float tiempoParado;

	public int ticksConTiempoNormalForzado;

	private float tiempoParadoInicial;

	public static TimeManager GetInstance()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
		if (!UnityEngine.Application.isEditor)
		{
			testInicioDesactivado = false;
			testTiempoNormal = false;
			jugadorInmortal = false;
		}
	}

	private void Start()
	{
		Time.timeScale = 1f;
		SetTiempoDeEquipo(0f, 1);
		SetTiempoDeEquipo(0f, 2);
		miTiempo = 0f;
		tiempoParado = 0f;
		if (jugadorInmortal)
		{
			GameObject.Find("ColisionCabeza").GetComponent<CapsuleCollider>().enabled = false;
		}
		timeDeseadoAnterior = 0f;
	}

	private void LateUpdate()
	{
		if (!GameManager.instance.player)
		{
			return;
		}
		timeNormal = ticksConTiempoNormalForzado > 0;
		if (ticksConTiempoNormalForzado > 0)
		{
			ticksConTiempoNormalForzado--;
		}
		if (tiempoMenu)
		{
			timeNormal = true;
		}
		if (tiempoMuerto)
		{
			miTiempo = 0f;
		}
		float num = miTiempo;
		if (tiempoParado > 0f || Debugs.poderPararTiempoSiempre || tiempoMuerto)
		{
			if (GameManager.instance.m_musica.musicaNormal != 0)
			{
				GameManager.instance.m_musica.CambiarMusicaATiempoParado();
			}
		}
		else if (GameManager.instance.m_musica.musicaNormal != 1 && GameManager.instance.m_salaManager.nivelIniciado && !GameManager.instance.player.muerto && !NivelCompletado.instance.pasandoDeNivel)
		{
			GameManager.instance.m_musica.CambiarMusicaATiempoNormal();
		}
		if (((bool)NivelCompletado.instance && NivelCompletado.instance.pasandoDeNivel) || GameManager.instance.estoyMuertoYMeEstanEnseñandoQueMeHaMatado || tiempoMuerto)
		{
			tiempoParado = 0f;
			if (GameManager.instance.player.GetInmortalidad())
			{
				GameManager.instance.player.QuitarInmortalidadConCoroutina(0f);
			}
			tiempoParadoInicial = 0f;
		}
		if (Debugs.SimularPlayer < 2)
		{
			if (((bool)NivelCompletado.instance && NivelCompletado.instance.pasandoDeNivel) || ((bool)GameManager.instance.m_salaManager && !GameManager.instance.m_salaManager.nivelIniciado) || ((bool)GameManager.instance.player && GameManager.instance.player.estadoZonaNegra == Player.EstadoZonaNegra.Pausa) || (GameManager.instance.player.roomScale && !GameManager.instance.player.enElLimbo) || instance.tiempoMuerto)
			{
				num = 0f;
				tiempoParado = 0f;
				tiempoParadoInicial = 0f;
				if (GameManager.instance.player.GetInmortalidad())
				{
					GameManager.instance.player.QuitarInmortalidad();
				}
			}
			else if (GameManager.instance.player.pararTiempo)
			{
				num = 0f;
				tiempoParado = 0f;
				tiempoParadoInicial = 0f;
			}
			else if (timeNormal && (tiempoParado < 0f || tiempoParadoInicial > 1f))
			{
				num = 1f;
				if (tiempoParado < 0f)
				{
					tiempoParadoInicial = 0f;
					if (GameManager.instance.player.GetInmortalidad())
					{
						GameManager.instance.player.QuitarInmortalidadConCoroutina(0f);
					}
				}
			}
			else if (GameManager.instance.estoyMuertoYMeEstanEnseñandoQueMeHaMatado || tiempoMuerto)
			{
				num = 0f;
				tiempoParadoInicial = 0f;
				if (GameManager.instance.player.GetInmortalidad())
				{
					GameManager.instance.player.QuitarInmortalidadConCoroutina(0f);
				}
			}
			else if (tiempoParado > 0f || Debugs.poderPararTiempoSiempre)
			{
				velocidadCabeza = GameManager.instance.player.velCabeza;
				velocidadManoDerecha = GameManager.instance.player.velManoDerecha;
				velocidadManoIzquierda = GameManager.instance.player.velManoIzquierda;
				if (velocidadManoDerecha >= velocidadManoIzquierda && velocidadManoDerecha >= 1f)
				{
					timeDeseado = velocidadManoDerecha / 14f;
					timeDeseado = Mathf.Clamp01(timeDeseado);
				}
				else if (velocidadManoIzquierda >= 2f)
				{
					timeDeseado = velocidadManoIzquierda / 14f;
					timeDeseado = Mathf.Clamp01(timeDeseado);
				}
				else
				{
					timeDeseado = TIEMPO_MINIMO;
				}
				num = timeDeseado;
				if (tiempoParadoInicial < 1f)
				{
					num = TIEMPO_MINIMO;
				}
				tiempoParadoInicial += Time.deltaTime;
				tiempoParado -= Time.deltaTime * num;
				if (tiempoParado < 0f)
				{
					tiempoParado = 0f;
					if (GameManager.instance.player.GetInmortalidad())
					{
						GameManager.instance.player.QuitarInmortalidadConCoroutina(0f);
					}
				}
			}
			else
			{
				num = 1f;
				tiempoParadoInicial = 0f;
			}
		}
		miTiempo = num;
		timeDeseado = miTiempo;
		if (PhotonNetwork.IsMasterClient)
		{
			try
			{
				PartidaSync.instance.jugadores[0].escalaTiempoJugador = num;
			}
			catch (Exception)
			{
			}
		}
		if (PhotonNetwork.IsMasterClient)
		{
			switch (Config.modoDePartida)
			{
			case Config.ModoDePartida.Solo:
				SetTiempoDeEquipo(miTiempo, GameManager.instance.player.miEquipo);
				break;
			case Config.ModoDePartida.Competitivo:
			{
				float num3 = 0f;
				float num4 = 0f;
				int num5 = 0;
				int num6 = 0;
				foreach (int key in PartidaSync.instance.jugadores.Keys)
				{
					if (PartidaSync.instance.jugadores[key].equipo == 1)
					{
						num3 += PartidaSync.instance.jugadores[key].escalaTiempoJugador;
						num5++;
					}
					else
					{
						num4 += PartidaSync.instance.jugadores[key].escalaTiempoJugador;
						num6++;
					}
				}
				if (num3 < 0f)
				{
					num3 = 0f;
				}
				if (num4 < 0f)
				{
					num4 = 0f;
				}
				if (NivelCompletado.instance.pasandoDeNivel)
				{
					num3 = 1f;
					num4 = 1f;
				}
				if (GameManager.instance.player.pararTiempo)
				{
					num3 = 0f;
					num4 = 0f;
				}
				SetTiempoDeEquipo(num3, 1);
				SetTiempoDeEquipo(num4, 2);
				break;
			}
			case Config.ModoDePartida.Cooperativo:
			{
				SetTiempoDeEquipo(miTiempo, GameManager.instance.player.miEquipo);
				float num2 = 0f;
				foreach (int key2 in PartidaSync.instance.jugadores.Keys)
				{
					if (PartidaSync.instance.jugadores[key2] != PartidaSync.instance.miJugador)
					{
						num2 += PartidaSync.instance.jugadores[key2].escalaTiempoJugador;
					}
				}
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				if (NivelCompletado.instance.pasandoDeNivel)
				{
					num2 = 1f;
				}
				SetTiempoDeEquipo(num2, 2);
				break;
			}
			}
		}
		timeDeseadoAnterior = timeDeseado;
	}

	public float GetTiempoParado()
	{
		return tiempoParado;
	}

	public float GetTiempoMedioGlobal()
	{
		if (PhotonNetwork.PlayerList.Length > 1)
		{
			return (GetTiempoDeEquipo(1) + GetTiempoDeEquipo(2)) / 2f;
		}
		return GetTiempoDeEquipo(1);
	}

	public float GetTiempoDeEquipo(int numeroEquipo)
	{
		float num;
		return num = numeroEquipo switch
		{
			1 => tiempoEquipo1, 
			9 => (tiempoEquipo1 + tiempoEquipo2) / 2f, 
			_ => tiempoEquipo2, 
		} * (Time.deltaTime / (1f / 90f));
	}

	public void SetTiempoDeEquipo(float valor, int numeroEquipo)
	{
		if (numeroEquipo == 1)
		{
			tiempoEquipo1 = valor;
		}
		else
		{
			tiempoEquipo2 = valor;
		}
	}

	public void PonerTiempoLentoPorXSegundos(float duracion)
	{
		tiempoParado = duracion;
	}

	public void MakeTimeNormal(bool condicion)
	{
		if (condicion)
		{
			timeNormal = true;
		}
		else
		{
			timeNormal = false;
		}
	}

	public void ActivarDesactivarTiempoMuerto(bool estado)
	{
		tiempoMuerto = estado;
	}
}
public class ControladorVR : MonoBehaviour
{
	public enum TipoControl
	{
		ControlDerecha,
		ControlIzquierda,
		Cabeza,
		Tracker
	}

	public enum TipoBoton
	{
		Pausa,
		Recolocar,
		CambiarBalaGancho,
		Atras
	}

	private Vector3 localPositionControlDerecha = Vector3.zero;

	private Vector3 localPositionControlIzquierda = Vector3.zero;

	private Vector3 localPositionCabeza = Vector3.zero;

	private Vector3 localRotationControlDerecha = Vector3.zero;

	private Vector3 localRotationControlIzquierda = Vector3.zero;

	private Vector3 localRotationCabeza = Vector3.zero;

	private float triggerDerecho;

	private float triggerIzquierdo;

	private float GripDerecho;

	private float GripIzquierdo;

	private bool botonPausa;

	private bool botonRecolocar;

	private bool botonCambiarPistolaGanchoDer;

	private bool botonCambiarPistolaGanchoIzq;

	private bool botonMenuDer;

	private bool botonMenuIzq;

	private bool botonAtras;

	private Vector2 stickDerecho = Vector2.zero;

	private Vector2 stickIzquierdo = Vector2.zero;

	public Vector3 GetLocalPosition(TipoControl tipo)
	{
		return tipo switch
		{
			TipoControl.Cabeza => localPositionCabeza, 
			TipoControl.ControlDerecha => localPositionControlDerecha, 
			TipoControl.ControlIzquierda => localPositionControlIzquierda, 
			_ => Vector3.zero, 
		};
	}

	public Vector3 GetLocalRotation(TipoControl tipo)
	{
		return tipo switch
		{
			TipoControl.Cabeza => localRotationCabeza, 
			TipoControl.ControlDerecha => localRotationControlDerecha, 
			TipoControl.ControlIzquierda => localRotationControlIzquierda, 
			_ => Vector3.zero, 
		};
	}

	public float GetTrigger(TipoControl tipo)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			return triggerDerecho;
		}
		return triggerIzquierdo;
	}

	public float GetGrip(TipoControl tipo)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			return GripDerecho;
		}
		return GripIzquierdo;
	}

	public bool GetBoton(TipoBoton tipo, bool derecha = true)
	{
		switch (tipo)
		{
		case TipoBoton.Pausa:
			return botonPausa;
		case TipoBoton.Recolocar:
			return botonRecolocar;
		case TipoBoton.CambiarBalaGancho:
			if (!derecha)
			{
				return botonCambiarPistolaGanchoIzq;
			}
			return botonCambiarPistolaGanchoDer;
		case TipoBoton.Atras:
			return botonAtras;
		default:
			return false;
		}
	}

	public Vector2 GetStick(TipoControl tipo)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			return stickDerecho;
		}
		return stickIzquierdo;
	}

	protected void SetLocalPosition(TipoControl tipo, Vector3 value)
	{
		switch (tipo)
		{
		case TipoControl.Cabeza:
			localPositionCabeza = value;
			break;
		case TipoControl.ControlDerecha:
			localPositionControlDerecha = value;
			break;
		case TipoControl.ControlIzquierda:
			localPositionControlIzquierda = value;
			break;
		}
	}

	protected void SetLocalRotation(TipoControl tipo, Vector3 value)
	{
		switch (tipo)
		{
		case TipoControl.Cabeza:
			localRotationCabeza = value;
			break;
		case TipoControl.ControlDerecha:
			localRotationControlDerecha = value;
			break;
		case TipoControl.ControlIzquierda:
			localRotationControlIzquierda = value;
			break;
		}
	}

	protected void SetTrigger(TipoControl tipo, float value)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			triggerDerecho = value;
		}
		else
		{
			triggerIzquierdo = value;
		}
	}

	protected void SetGrip(TipoControl tipo, float value)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			GripDerecho = value;
		}
		else
		{
			GripIzquierdo = value;
		}
	}

	protected void SetBoton(TipoBoton tipo, bool value, bool derecha = true)
	{
		switch (tipo)
		{
		case TipoBoton.Pausa:
			botonPausa = value;
			break;
		case TipoBoton.Recolocar:
			botonRecolocar = value;
			break;
		case TipoBoton.CambiarBalaGancho:
			if (derecha)
			{
				botonCambiarPistolaGanchoDer = value;
			}
			else
			{
				botonCambiarPistolaGanchoIzq = value;
			}
			break;
		case TipoBoton.Atras:
			botonAtras = value;
			break;
		}
	}

	protected void SetStick(TipoControl tipo, Vector2 value)
	{
		if (tipo == TipoControl.ControlDerecha)
		{
			stickDerecho = value;
		}
		else
		{
			stickIzquierdo = value;
		}
	}
}
public class ControladorVRNolo : ControladorVR
{
	private int indexDerecha;

	private int indexIzquierda;

	private bool mandoDerechoCargado;

	private bool mandoIzquierdoCargado;

	private MandoNolo mandoDerecho;

	private MandoNolo mandoIzquierdo;

	public bool invertirMandos;

	public void Vibracion(float strength, int time, int hand)
	{
	}
}
public class MandoNolo
{
	public Vector3 localPosition = Vector3.zero;

	public Quaternion localrotation = Quaternion.identity;

	public void LeerBotones()
	{
	}

	public void Vibra(int fuerza)
	{
	}
}
public class ControladorVROculus : ControladorVR
{
	private bool mandoDerechoCargado;

	private bool mandoIzquierdoCargado;

	private MandoOculus mandoDerecho;

	private MandoOculus mandoIzquierdo;

	private MandoOculus tracker;

	private bool isHandleHMDUnmounted;

	private bool isDashOpen;

	private Transform oculusOffsetDer;

	private Transform oculusOffsetIzq;

	private int mano = -1;

	private void OnEnable()
	{
		StartCoroutine(WaitEnable());
	}

	private IEnumerator WaitEnable()
	{
		yield return new WaitForSeconds(1f);
		try
		{
			OVRManager.display.RecenteredPose += EsperaParaRecolocar;
			OVRManager.VrFocusLost += HandleHMDUnmounted;
			OVRManager.HMDMounted += HandleHMDMounted;
		}
		catch
		{
		}
	}

	private void OnDisable()
	{
		try
		{
			OVRManager.display.RecenteredPose -= EsperaParaRecolocar;
			OVRManager.VrFocusLost -= HandleHMDUnmounted;
			OVRManager.HMDMounted -= HandleHMDMounted;
		}
		catch
		{
		}
	}

	private void Awake()
	{
		base.gameObject.AddComponent<OVRManager>();
	}

	private void Start()
	{
		if (Config.esQuest || Config.esGO)
		{
			GameObject mando_Go = GameObject.Find("Der");
			mandoDerecho = new MandoOculus(XRNode.RightHand, mando_Go);
			mandoDerechoCargado = true;
			mando_Go = GameObject.Find("Izq");
			mandoIzquierdo = new MandoOculus(XRNode.LeftHand, mando_Go);
			mandoIzquierdoCargado = true;
		}
		else
		{
			mandoDerecho = new MandoOculus(XRNode.RightHand);
			mandoDerechoCargado = true;
			mandoIzquierdo = new MandoOculus(XRNode.LeftHand);
			mandoIzquierdoCargado = true;
		}
		GameObject gameObject = GameObject.Find("ManoDerecha/DerOculusOffset");
		if ((bool)gameObject)
		{
			oculusOffsetDer = gameObject.transform;
		}
		gameObject = GameObject.Find("ManoIzquierda/IzqOculusOffset");
		if ((bool)gameObject)
		{
			oculusOffsetIzq = gameObject.transform;
		}
		bool flag = true;
		try
		{
			if (OVRPlugin.GetSystemHeadsetType() != OVRPlugin.SystemHeadset.Oculus_Quest)
			{
				flag = false;
			}
		}
		catch
		{
		}
		if (flag)
		{
			XRSettings.eyeTextureResolutionScale = 0.75f;
		}
		else
		{
			XRSettings.eyeTextureResolutionScale = 1f;
		}
	}

	public void ComprarRift()
	{
		ApplicationOptions deeplink_options = new ApplicationOptions();
		Oculus.Platform.Application.LaunchOtherApp(2845565575571255uL, deeplink_options);
	}

	public void ComprarQuest()
	{
		ApplicationOptions deeplink_options = new ApplicationOptions();
		Oculus.Platform.Application.LaunchOtherApp(5352805804730379uL, deeplink_options);
	}

	private bool CheckDashOpen()
	{
		return !OVRManager.hasInputFocus;
	}

	private void Update()
	{
		if (Config.esGO)
		{
			InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
			bool value = true;
			if (deviceAtXRNode.isValid)
			{
				deviceAtXRNode.TryGetFeatureValue(CommonUsages.userPresence, out value);
			}
			if (value && isHandleHMDUnmounted)
			{
				HandleHMDMounted();
			}
			else if (!value && !isHandleHMDUnmounted)
			{
				HandleHMDUnmounted();
			}
		}
		bool flag = CheckDashOpen();
		if (flag && !isDashOpen)
		{
			DashOpened();
		}
		else if (!flag && isDashOpen)
		{
			DashClosed();
		}
		if (Config.esGO && ManoCambiada())
		{
			GameManager.instance.senDer.existe = false;
			GameManager.instance.senIzq.existe = false;
			GameManager.instance.GetComponent<DeteccionDispositivos>().yaNoBuscar = false;
			GameManager.instance.CargarMenu();
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			if (IsRightie() && Config.zurdo)
			{
				Config.zurdo = false;
				DeteccionDispositivos.CambiarSensorOculusGO(oculusGoDer: true);
			}
			else if (IsLeftie() && !Config.zurdo)
			{
				Config.zurdo = true;
				DeteccionDispositivos.CambiarSensorOculusGO(oculusGoDer: false);
			}
		}
		bool flag2 = false;
		bool flag3 = false;
		bool value2 = false;
		bool value3 = false;
		bool flag4 = false;
		if (mandoDerechoCargado)
		{
			if (isHandleHMDUnmounted || isDashOpen)
			{
				mandoDerecho.SinBotones();
			}
			else
			{
				mandoDerecho.LeerBotones();
			}
			if (Config.esQuest || Config.esGO)
			{
				if ((bool)mandoDerecho.mando_Go && !isHandleHMDUnmounted && !isDashOpen)
				{
					SetLocalPosition(TipoControl.ControlDerecha, mandoDerecho.mando_Go.transform.localPosition);
					Vector3 localEulerAngles = mandoDerecho.mando_Go.transform.localEulerAngles;
					Quaternion quaternion = Quaternion.Euler(localEulerAngles);
					Quaternion quaternion2 = (oculusOffsetDer ? oculusOffsetDer.localRotation : Quaternion.identity);
					localEulerAngles = (quaternion * quaternion2).eulerAngles;
					SetLocalRotation(TipoControl.ControlDerecha, localEulerAngles);
				}
				flag4 = mandoDerecho.atras;
			}
			else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
			{
				SetLocalPosition(TipoControl.ControlDerecha, mandoDerecho.localPosition - new Vector3(0.03f, 0.05f, 0.07f));
				Vector3 localrotation = mandoDerecho.localrotation;
				Quaternion quaternion3 = Quaternion.Euler(mandoDerecho.localrotation);
				Quaternion quaternion4 = (oculusOffsetDer ? oculusOffsetDer.localRotation : Quaternion.identity);
				localrotation = (quaternion3 * quaternion4).eulerAngles;
				SetLocalRotation(TipoControl.ControlDerecha, localrotation);
			}
			else
			{
				SetLocalPosition(TipoControl.ControlDerecha, mandoDerecho.localPosition);
				SetLocalRotation(TipoControl.ControlDerecha, mandoDerecho.localrotation);
			}
			SetTrigger(TipoControl.ControlDerecha, mandoDerecho.trigger);
			SetGrip(TipoControl.ControlDerecha, mandoDerecho.gripPress ? 1 : 0);
			SetStick(TipoControl.ControlDerecha, mandoDerecho.stick);
			if (Config.tipoDeControl == Config.TipoControl.UnaMano)
			{
				if (Config.zurdo)
				{
					flag2 = mandoDerecho.botonBYOculusPressDown;
					flag3 = mandoDerecho.botonAXOculusPressDown;
				}
				else
				{
					flag2 = mandoDerecho.botonBYOculusPressDown;
					value2 = mandoDerecho.botonAXOculusPressDown;
				}
			}
			else
			{
				flag3 = mandoDerecho.botonBYOculusPressDown;
				value2 = mandoDerecho.botonAXOculusPressDown;
			}
			flag2 = mandoDerecho.botonAplicationPressDown;
			flag3 = mandoDerecho.botonAXOculusPressDown;
			value2 = mandoDerecho.botonBYOculusPress;
		}
		if (mandoIzquierdoCargado)
		{
			if (isHandleHMDUnmounted || isDashOpen)
			{
				mandoIzquierdo.SinBotones();
			}
			else
			{
				mandoIzquierdo.LeerBotones();
			}
			if (Config.esQuest || Config.esGO)
			{
				if ((bool)mandoIzquierdo.mando_Go && !isHandleHMDUnmounted && !isDashOpen)
				{
					SetLocalPosition(TipoControl.ControlIzquierda, mandoIzquierdo.mando_Go.transform.localPosition);
					Vector3 localEulerAngles2 = mandoIzquierdo.mando_Go.transform.localEulerAngles;
					Quaternion quaternion5 = Quaternion.Euler(localEulerAngles2);
					Quaternion quaternion6 = (oculusOffsetIzq ? oculusOffsetIzq.localRotation : Quaternion.identity);
					localEulerAngles2 = (quaternion5 * quaternion6).eulerAngles;
					SetLocalRotation(TipoControl.ControlIzquierda, localEulerAngles2);
				}
				if (!flag4)
				{
					flag4 = mandoIzquierdo.atras;
				}
			}
			else if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
			{
				SetLocalPosition(TipoControl.ControlIzquierda, mandoIzquierdo.localPosition - new Vector3(0.03f, 0.05f, 0.07f));
				Vector3 localrotation2 = mandoIzquierdo.localrotation;
				Quaternion quaternion7 = Quaternion.Euler(mandoIzquierdo.localrotation);
				Quaternion quaternion8 = (oculusOffsetIzq ? oculusOffsetIzq.localRotation : Quaternion.identity);
				localrotation2 = (quaternion7 * quaternion8).eulerAngles;
				SetLocalRotation(TipoControl.ControlIzquierda, localrotation2);
			}
			else
			{
				SetLocalPosition(TipoControl.ControlIzquierda, mandoIzquierdo.localPosition);
				SetLocalRotation(TipoControl.ControlIzquierda, mandoIzquierdo.localrotation);
			}
			SetTrigger(TipoControl.ControlIzquierda, mandoIzquierdo.trigger);
			SetGrip(TipoControl.ControlIzquierda, mandoIzquierdo.gripPress ? 1 : 0);
			SetStick(TipoControl.ControlIzquierda, mandoIzquierdo.stick);
			if (Config.tipoDeControl == Config.TipoControl.UnaMano)
			{
				if (Config.zurdo)
				{
					if (!flag2)
					{
						flag2 = mandoIzquierdo.botonBYOculusPressDown;
					}
					value3 = mandoIzquierdo.botonAXOculusPressDown;
				}
				else
				{
					if (!flag2)
					{
						flag2 = mandoIzquierdo.botonBYOculusPressDown;
					}
					if (!flag3)
					{
						flag3 = mandoIzquierdo.botonAXOculusPressDown;
					}
				}
			}
			else
			{
				if (!flag2)
				{
					flag2 = mandoIzquierdo.botonBYOculusPressDown;
				}
				value3 = mandoIzquierdo.botonAXOculusPressDown;
			}
		}
		SetBoton(TipoBoton.Pausa, flag2);
		SetBoton(TipoBoton.Recolocar, flag3);
		SetBoton(TipoBoton.CambiarBalaGancho, value2);
		SetBoton(TipoBoton.CambiarBalaGancho, value3, derecha: false);
		SetBoton(TipoBoton.Atras, flag2);
	}

	private void HandleHMDUnmounted()
	{
		if (Debugs.SimularPlayer == 0)
		{
			isHandleHMDUnmounted = true;
			if (Config.modoDeJuego != Config.ModosDeJuego.menu && (bool)GameManager.instance && (bool)GameManager.instance.player && GameManager.instance.player.estadoZonaNegra != Player.EstadoZonaNegra.Pausa)
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: true, Player.EstadoZonaNegra.Pausa);
			}
			ApagarManos();
			if (Config.modoDeJuego == Config.ModosDeJuego.menu)
			{
				GameManager.instance.cascoQuitado = true;
			}
		}
	}

	private void HandleHMDMounted()
	{
		isHandleHMDUnmounted = false;
		InputsController.instance.RecolocarCabeza();
		EncenderManos();
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			GameManager.instance.cascoQuitado = false;
		}
	}

	private void DashOpened()
	{
		if (Debugs.SimularPlayer == 0)
		{
			isDashOpen = true;
			if (Config.modoDeJuego != Config.ModosDeJuego.menu && (bool)GameManager.instance && (bool)GameManager.instance.player && GameManager.instance.player.estadoZonaNegra != Player.EstadoZonaNegra.Pausa)
			{
				GameManager.instance.player.ActivarDesactiarZonaOscura(activar: true, Player.EstadoZonaNegra.Pausa);
			}
			ApagarManos();
			if (Config.modoDeJuego == Config.ModosDeJuego.menu)
			{
				GameManager.instance.m_musica.ActivarMusica(activar: false);
				GameManager.instance.dashOpened = true;
			}
		}
	}

	private void DashClosed()
	{
		isDashOpen = false;
		EncenderManos();
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			GameManager.instance.m_musica.ActivarMusica(activar: true);
			GameManager.instance.dashOpened = false;
		}
	}

	private void ApagarManos()
	{
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoDerecha)
			{
				GameManager.instance.player.controladorManoDerecha.handModel.SetActive(value: false);
				GameManager.instance.player.controladorManoDerecha.laserModel.SetActive(value: false);
			}
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoIzquierda)
			{
				GameManager.instance.player.controladorManoIzquierda.handModel.SetActive(value: false);
				GameManager.instance.player.controladorManoIzquierda.laserModel.SetActive(value: false);
			}
		}
		else
		{
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoDerecha && (bool)GameManager.instance.player.controladorManoDerecha.manoRoomScale)
			{
				GameManager.instance.player.controladorManoDerecha.manoRoomScale.manoModel.SetActive(value: false);
			}
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoIzquierda && (bool)GameManager.instance.player.controladorManoIzquierda.manoRoomScale)
			{
				GameManager.instance.player.controladorManoIzquierda.manoRoomScale.manoModel.SetActive(value: false);
			}
		}
	}

	private void EncenderManos()
	{
		if (isDashOpen || isHandleHMDUnmounted)
		{
			return;
		}
		if (Config.modoDeJuego == Config.ModosDeJuego.menu)
		{
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoDerecha)
			{
				GameManager.instance.player.controladorManoDerecha.handModel.SetActive(value: true);
				GameManager.instance.player.controladorManoDerecha.laserModel.SetActive(value: true);
			}
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoIzquierda)
			{
				GameManager.instance.player.controladorManoIzquierda.handModel.SetActive(value: true);
				GameManager.instance.player.controladorManoIzquierda.laserModel.SetActive(value: true);
			}
		}
		else
		{
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoDerecha && (bool)GameManager.instance.player.controladorManoDerecha.manoRoomScale)
			{
				GameManager.instance.player.controladorManoDerecha.manoRoomScale.manoModel.SetActive(value: true);
			}
			if ((bool)GameManager.instance.player && (bool)GameManager.instance.player.controladorManoIzquierda && (bool)GameManager.instance.player.controladorManoIzquierda.manoRoomScale)
			{
				GameManager.instance.player.controladorManoIzquierda.manoRoomScale.manoModel.SetActive(value: true);
			}
		}
	}

	private void EsperaParaRecolocar()
	{
		StartCoroutine(CorutineEsperaParaRecolocar(dosFrames: false));
		StartCoroutine(CorutineEsperaParaRecolocar(dosFrames: true));
	}

	private IEnumerator CorutineEsperaParaRecolocar(bool dosFrames)
	{
		yield return null;
		if (dosFrames)
		{
			yield return null;
		}
		InputsController.instance.RecolocarCabeza();
	}

	public void Vibracion(float f, float p, bool mano)
	{
		if (mano)
		{
			OVRInput.SetControllerVibration(f, p, OVRInput.Controller.RTouch);
		}
		else
		{
			OVRInput.SetControllerVibration(f, p, OVRInput.Controller.LTouch);
		}
	}

	public bool ManoCambiada()
	{
		if (mano == -1)
		{
			if (IsRightie())
			{
				mano = 1;
			}
			else
			{
				if (!IsLeftie())
				{
					return false;
				}
				mano = 2;
			}
		}
		else
		{
			if (mano == 1 && IsLeftie())
			{
				mano = 2;
				return true;
			}
			if (mano == 2 && IsRightie())
			{
				mano = 1;
				return true;
			}
		}
		return false;
	}

	public bool IsRightie()
	{
		if (OVRPlugin.GetDominantHand() == OVRPlugin.Handedness.RightHanded)
		{
			return true;
		}
		return false;
	}

	public bool IsLeftie()
	{
		if (OVRPlugin.GetDominantHand() == OVRPlugin.Handedness.LeftHanded)
		{
			return true;
		}
		return false;
	}
}
public class MandoOculus
{
	private XRNode index;

	public float trigger;

	public bool triggerPress;

	public bool triggerUp;

	public bool triggerDown;

	public float grip;

	public bool gripPress;

	public bool gripPressDown;

	public bool gripPressUp;

	public bool botonAplicationPress;

	public bool botonAplicationPressDown;

	public bool botonAplicationPressUp;

	public bool touchPress;

	public bool touchPressUp;

	public bool touchPressDown;

	public Vector2 stick;

	public bool botonAXOculusPress;

	public bool botonAXOculusPressUp;

	public bool botonAXOculusPressDown;

	public bool botonBYOculusPress;

	public bool botonBYOculusPressUp;

	public bool botonBYOculusPressDown;

	public bool botonMenu;

	public bool atras;

	public Vector3 velocidadMando;

	public GameObject mando_Go;

	public bool algunBotonTocado;

	private bool pulsandoTrigger;

	private bool pulsandoGrip;

	private bool pulsandoAX;

	private bool pulsandoBY;

	private bool pulsandoMenu;

	public Vector3 localPosition = Vector3.zero;

	public Vector3 localrotation = Vector3.zero;

	private Vector3 oldLocalPosition = Vector3.zero;

	private Vector3 oldLocalrotation = Vector3.zero;

	public XRNode GetIndex()
	{
		return index;
	}

	public void SetIndex(XRNode newIndex)
	{
		index = newIndex;
	}

	public MandoOculus(XRNode newIndex, GameObject mando_Go)
	{
		SetIndex(newIndex);
		this.mando_Go = mando_Go;
	}

	public MandoOculus(XRNode newIndex)
	{
		SetIndex(newIndex);
	}

	public void LeerBotones()
	{
		if (!Config.esQuest || Config.esGO)
		{
			localPosition = ((GetIndex() == XRNode.RightHand) ? OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch) : OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch));
			localrotation = ((GetIndex() == XRNode.RightHand) ? OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch) : OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch)).eulerAngles;
		}
		if (Config.esGO)
		{
			trigger = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.RawAxis1D.RIndexTrigger) : OVRInput.Get(OVRInput.RawAxis1D.LIndexTrigger));
		}
		else if (Config.esQuest)
		{
			trigger = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) : OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger));
		}
		else
		{
			trigger = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.RawAxis1D.RIndexTrigger) : OVRInput.Get(OVRInput.RawAxis1D.LIndexTrigger));
		}
		triggerUp = trigger <= 0.1f && pulsandoTrigger;
		triggerDown = !pulsandoTrigger && trigger >= 0.1f;
		pulsandoTrigger = trigger > 0.1f;
		triggerPress = trigger > 0.1f;
		grip = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.Axis1D.SecondaryHandTrigger) : OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger));
		gripPressDown = !pulsandoGrip && grip >= 0.1f;
		gripPressUp = grip <= 0.1f && pulsandoGrip;
		gripPress = grip > 0.1f;
		pulsandoGrip = grip > 0.1f;
		velocidadMando = ((GetIndex() == XRNode.RightHand) ? (OVRInput.GetLocalControllerVelocity(OVRInput.Controller.RTouch) / 1f) : (OVRInput.GetLocalControllerVelocity(OVRInput.Controller.LTouch) / 1f));
		if (!Config.esGO)
		{
			stick = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			botonAXOculusPress = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.Button.One) : OVRInput.Get(OVRInput.Button.Three));
			botonAXOculusPressUp = !botonAXOculusPress && pulsandoAX;
			botonAXOculusPressDown = botonAXOculusPress && !pulsandoAX;
			pulsandoAX = botonAXOculusPress;
			botonBYOculusPress = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.Button.Two) : OVRInput.Get(OVRInput.Button.Four));
			botonBYOculusPressUp = !botonBYOculusPress && pulsandoBY;
			botonBYOculusPressDown = botonBYOculusPress && !pulsandoBY;
			pulsandoBY = botonBYOculusPress;
			atras = OVRInput.Get(OVRInput.RawButton.Back);
		}
		else
		{
			stick = ((GetIndex() == XRNode.RightHand) ? OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad) : OVRInput.Get(OVRInput.Axis2D.SecondaryTouchpad));
			if (stick.x > 0.05f || stick.x < -0.05f)
			{
				stick.x *= 2f;
			}
			if (stick.y > 0.05f || stick.y < -0.05f)
			{
				stick.y *= 2f;
			}
			botonBYOculusPressDown = OVRInput.Get(OVRInput.RawButton.Back);
			atras = botonBYOculusPressDown;
		}
		oldLocalPosition = localPosition;
		oldLocalrotation = localrotation;
	}

	public void SinBotones()
	{
		trigger = 0f;
		triggerPress = false;
		triggerUp = false;
		triggerDown = false;
		grip = 0f;
		gripPress = false;
		gripPressDown = false;
		gripPressUp = false;
		botonAplicationPress = false;
		botonAplicationPressDown = false;
		botonAplicationPressUp = false;
		touchPress = false;
		touchPressUp = false;
		touchPressDown = false;
		stick = Vector3.zero;
		botonAXOculusPress = false;
		botonAXOculusPressUp = false;
		botonAXOculusPressDown = false;
		botonBYOculusPress = false;
		botonBYOculusPressUp = false;
		botonBYOculusPressDown = false;
		botonMenu = false;
		atras = false;
		velocidadMando = Vector3.zero;
		algunBotonTocado = false;
		pulsandoTrigger = false;
		pulsandoGrip = false;
		pulsandoAX = false;
		pulsandoBY = false;
		pulsandoMenu = false;
		localPosition = oldLocalPosition;
		localrotation = oldLocalrotation;
	}
}
public class ControladorVRPS4 : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ControladorVRPico : ControladorVR
{
	private int indexDerecha;

	private int indexIzquierda;

	private bool mandoDerechoCargado;

	private bool mandoIzquierdoCargado;

	private MandoPico mandoDerecho;

	private MandoPico mandoIzquierdo;

	private GameObject fps_Go;

	private GameObject leftEye_Go;

	private GameObject rightEye_Go;

	private GameObject bothEyes_Go;

	private GameObject event_Go;

	private GameObject controllerManager_Go;

	public bool invertirMandos;

	public void Vibracion(float strength, int time, int hand)
	{
	}
}
public class MandoPico
{
	public int index;

	public float trigger;

	public bool triggerPress;

	public bool triggerUp;

	public bool triggerDown;

	public float grip;

	public bool gripPress;

	public bool gripPressDown;

	public bool gripPressUp;

	public bool botonAplicationPress;

	public bool botonAplicationPressDown;

	public bool botonAplicationPressUp;

	public bool touchPress;

	public bool touchPressUp;

	public bool touchPressDown;

	public Vector2 stick;

	public bool botonAXOculusPress;

	public bool botonAXOculusPressUp;

	public bool botonAXOculusPressDown;

	public bool botonBYOculusPress;

	public bool botonBYOculusPressUp;

	public bool botonBYOculusPressDown;

	public bool botonMenu;

	public Vector3 velocidadMando;

	public bool algunBotonTocado;

	public Transform mando;

	private bool pulsandoTrigger;

	private bool pulsandoGrip;

	private bool pulsandoAX;

	private bool pulsandoBY;

	private bool pulsandoMenu;

	public Vector3 localPosition = Vector3.zero;

	public Quaternion localrotation = Quaternion.identity;

	public MandoPico(Transform mando, int index)
	{
		this.mando = mando;
		this.index = index;
	}

	public void LeerBotones()
	{
	}
}
public class ControladorVRSteam : ControladorVR
{
	private MandoVive mandoDerecho;

	private MandoVive mandoIzquierdo;

	private MandoVive tracker;

	private bool mandoTrackerCargado;

	private bool mandoDerechoCargado;

	private bool mandoIzquierdoCargado;

	public bool hayTracker;

	private GameObject controladorDerecho_GO;

	private GameObject controladorIzquierdo_GO;

	private GameObject controladorTracker_GO;

	private SteamVR_TrackedObject camera_TrackedObject;

	private SteamVR_TrackedObject controladorDerecho_TrackedObject;

	private SteamVR_TrackedObject controladorIzquierdo_TrackedObject;

	private SteamVR_TrackedObject controladorTracker_TrackedObject;

	public SteamVR_TrackedController controladorDerecho_TrackedController;

	public SteamVR_TrackedController controladorIzquierdo_TrackedController;

	public SteamVR_TrackedController controladorTracker_TrackedController;

	private SteamVR_ControllerManager controllerManager;

	private int indexDerecha;

	private int indexIzquierda;

	private int indexTracker;

	private Coroutine EsperarMandosCor;

	private void Awake()
	{
		controladorDerecho_GO = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/VR/ControladorManoSteam") as GameObject);
		controladorDerecho_GO.transform.SetParent(base.transform);
		controladorDerecho_TrackedObject = controladorDerecho_GO.GetComponent<SteamVR_TrackedObject>();
		controladorDerecho_TrackedController = controladorDerecho_GO.GetComponent<SteamVR_TrackedController>();
		controladorDerecho_GO.name = "Controller (right)";
		controladorIzquierdo_GO = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/VR/ControladorManoSteam") as GameObject);
		controladorIzquierdo_GO.transform.SetParent(base.transform);
		controladorIzquierdo_TrackedObject = controladorIzquierdo_GO.GetComponent<SteamVR_TrackedObject>();
		controladorIzquierdo_TrackedController = controladorIzquierdo_GO.GetComponent<SteamVR_TrackedController>();
		controladorIzquierdo_GO.name = "Controller (left)";
		controladorTracker_GO = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/VR/ControladorManoSteam") as GameObject);
		controladorTracker_GO.transform.SetParent(base.transform);
		controladorTracker_TrackedObject = controladorTracker_GO.GetComponent<SteamVR_TrackedObject>();
		controladorTracker_TrackedController = controladorTracker_GO.GetComponent<SteamVR_TrackedController>();
		controladorTracker_GO.name = "Controller (Tracker)";
		controllerManager = base.gameObject.AddComponent<SteamVR_ControllerManager>();
		controllerManager.right = controladorDerecho_GO;
		controllerManager.left = controladorIzquierdo_GO;
		controllerManager.objects = new GameObject[1];
		controllerManager.objects[0] = controladorTracker_GO;
		controllerManager.enabled = true;
		Transform transform = base.transform.Find("Cabeza");
		if ((bool)transform)
		{
			camera_TrackedObject = transform.gameObject.AddComponent<SteamVR_TrackedObject>();
			camera_TrackedObject.index = SteamVR_TrackedObject.EIndex.Hmd;
		}
		EsperarMandosCor = StartCoroutine(EsperarMandos());
	}

	private void Update()
	{
		if (EsperarMandosCor == null && (!mandoDerechoCargado || !mandoIzquierdoCargado || !mandoTrackerCargado) && !hayTracker)
		{
			EsperarMandosCor = StartCoroutine(EsperarMandos());
		}
		bool flag = false;
		bool flag2 = false;
		bool value = false;
		bool value2 = false;
		bool flag3 = GameManager.instance.tipoDeSensores == InputsController.TipoSensores.index;
		bool flag4 = GameManager.instance.tipoDeSensores == InputsController.TipoSensores.vive;
		if (mandoDerechoCargado && mandoDerecho != null)
		{
			mandoDerecho.LeerBotones(derecho: true);
			if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
			{
				SetLocalPosition(TipoControl.ControlDerecha, controladorDerecho_GO.transform.localPosition - new Vector3(0.03f, 0.05f, 0.07f));
				SetLocalRotation(TipoControl.ControlDerecha, controladorDerecho_GO.transform.localEulerAngles);
			}
			else
			{
				SetLocalPosition(TipoControl.ControlDerecha, controladorDerecho_GO.transform.localPosition);
				SetLocalRotation(TipoControl.ControlDerecha, controladorDerecho_GO.transform.localEulerAngles);
			}
			SetTrigger(TipoControl.ControlDerecha, mandoDerecho.trigger);
			SetGrip(TipoControl.ControlDerecha, mandoDerecho.gripPress ? 1 : 0);
			if (flag3)
			{
				SetStick(TipoControl.ControlDerecha, mandoDerecho.posicionTouchTocado);
			}
			else if (flag4)
			{
				Vector3 vector = Vector3.zero;
				if (mandoDerecho.touchPress)
				{
					vector = mandoDerecho.posicionTouchTocado;
				}
				SetStick(TipoControl.ControlDerecha, vector);
			}
			else
			{
				SetStick(TipoControl.ControlDerecha, mandoDerecho.stick);
			}
			switch (GameManager.instance.tipoDeSensores)
			{
			case InputsController.TipoSensores.vive:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						flag = mandoDerecho.botonAppPressDown;
						flag2 = mandoDerecho.gripPressDown;
					}
					else
					{
						flag = mandoDerecho.botonAppPressDown;
						value = mandoDerecho.gripPressDown;
					}
				}
				else
				{
					flag2 = mandoDerecho.botonAppPressDown;
					value = mandoDerecho.gripPressDown;
				}
				break;
			case InputsController.TipoSensores.wmr:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						flag = mandoDerecho.touchPressUp;
						flag2 = mandoDerecho.botonAppPressDown;
					}
					else
					{
						flag = mandoDerecho.touchPressUp;
						value = mandoDerecho.botonAppPressDown;
					}
				}
				else
				{
					flag2 = mandoDerecho.botonUpBYPressDown;
					value = mandoDerecho.botonDownAXPressDown;
				}
				break;
			case InputsController.TipoSensores.cosmos:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						flag = mandoDerecho.botonUpBYPressDown;
						flag2 = mandoDerecho.botonDownAXPressDown;
					}
					else
					{
						flag = mandoDerecho.botonUpBYPressDown;
						value = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoDerecho.botonDownAXPressDown;
					}
				}
				else
				{
					flag2 = mandoDerecho.botonUpBYPressDown;
					value = mandoDerecho.botonDownAXPressDown;
				}
				break;
			default:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						flag = mandoDerecho.botonUpBYPressDown;
						flag2 = mandoDerecho.botonDownAXPressDown;
					}
					else
					{
						flag = mandoDerecho.botonUpBYPressDown;
						value = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoDerecho.botonDownAXPressDown;
					}
				}
				else
				{
					flag2 = mandoDerecho.botonUpBYPressDown;
					value = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoDerecho.botonDownAXPressDown;
				}
				break;
			}
		}
		if (mandoIzquierdoCargado && mandoIzquierdo != null)
		{
			mandoIzquierdo.LeerBotones(derecho: false);
			if (GameManager.instance.tipoDeSensores == InputsController.TipoSensores.oculus)
			{
				SetLocalPosition(TipoControl.ControlIzquierda, controladorIzquierdo_GO.transform.localPosition - new Vector3(0.03f, 0.05f, 0.07f));
				SetLocalRotation(TipoControl.ControlIzquierda, controladorIzquierdo_GO.transform.localEulerAngles);
			}
			else
			{
				SetLocalPosition(TipoControl.ControlIzquierda, controladorIzquierdo_GO.transform.localPosition);
				SetLocalRotation(TipoControl.ControlIzquierda, controladorIzquierdo_GO.transform.localEulerAngles);
			}
			SetTrigger(TipoControl.ControlIzquierda, mandoIzquierdo.trigger);
			SetGrip(TipoControl.ControlIzquierda, mandoIzquierdo.gripPress ? 1 : 0);
			if (flag3)
			{
				SetStick(TipoControl.ControlIzquierda, mandoIzquierdo.posicionTouchTocado);
			}
			else if (flag4)
			{
				Vector3 vector2 = Vector3.zero;
				if (mandoIzquierdo.touchPress)
				{
					vector2 = mandoIzquierdo.posicionTouchTocado;
				}
				SetStick(TipoControl.ControlIzquierda, vector2);
			}
			else
			{
				SetStick(TipoControl.ControlIzquierda, mandoIzquierdo.stick);
			}
			switch (GameManager.instance.tipoDeSensores)
			{
			case InputsController.TipoSensores.vive:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						if (!flag)
						{
							flag = mandoIzquierdo.botonAppPressDown;
						}
						value2 = mandoIzquierdo.gripPressDown;
						break;
					}
					if (!flag)
					{
						flag = mandoIzquierdo.botonAppPressDown;
					}
					if (!flag2)
					{
						flag2 = mandoIzquierdo.gripPressDown;
					}
				}
				else
				{
					if (!flag)
					{
						flag = mandoIzquierdo.botonAppPressDown;
					}
					value2 = mandoIzquierdo.gripPressDown;
				}
				break;
			case InputsController.TipoSensores.wmr:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						if (!flag)
						{
							flag = mandoIzquierdo.touchPressUp;
						}
						value2 = mandoIzquierdo.botonAppPressDown;
						break;
					}
					if (!flag)
					{
						flag = mandoIzquierdo.touchPressUp;
					}
					if (!flag2)
					{
						flag2 = mandoIzquierdo.botonAppPressDown;
					}
				}
				else
				{
					if (!flag)
					{
						flag = mandoIzquierdo.botonUpBYPressDown;
					}
					value2 = mandoIzquierdo.botonDownAXPressDown;
				}
				break;
			case InputsController.TipoSensores.cosmos:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						if (!flag)
						{
							flag = mandoIzquierdo.botonUpBYPressDown;
						}
						value2 = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoIzquierdo.botonDownAXPressDown;
						break;
					}
					if (!flag)
					{
						flag = mandoIzquierdo.botonUpBYPressDown;
					}
					if (!flag2)
					{
						flag2 = mandoIzquierdo.botonDownAXPressDown;
					}
				}
				else
				{
					if (!flag)
					{
						flag = mandoIzquierdo.botonUpBYPressDown;
					}
					value2 = mandoIzquierdo.botonDownAXPressDown;
				}
				break;
			default:
				if (Config.tipoDeControl == Config.TipoControl.UnaMano)
				{
					if (Config.zurdo)
					{
						if (!flag)
						{
							flag = mandoIzquierdo.botonUpBYPressDown;
						}
						value2 = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoIzquierdo.botonDownAXPressDown;
						break;
					}
					if (!flag)
					{
						flag = mandoIzquierdo.botonUpBYPressDown;
					}
					if (!flag2)
					{
						flag2 = mandoIzquierdo.botonDownAXPressDown;
					}
				}
				else
				{
					if (!flag)
					{
						flag = mandoIzquierdo.botonUpBYPressDown;
					}
					value2 = GameManager.instance.tipoDeSensores != InputsController.TipoSensores.index && mandoIzquierdo.botonDownAXPressDown;
				}
				break;
			}
		}
		SetBoton(TipoBoton.Pausa, flag);
		SetBoton(TipoBoton.Recolocar, flag2);
		SetBoton(TipoBoton.CambiarBalaGancho, value);
		SetBoton(TipoBoton.CambiarBalaGancho, value2, derecha: false);
		if ((bool)camera_TrackedObject)
		{
			if (InputsController.instance.estaFueraDeLimites)
			{
				camera_TrackedObject.enabled = false;
			}
			else
			{
				camera_TrackedObject.enabled = true;
			}
		}
	}

	private void OnEnable()
	{
		if (EsperarMandosCor == null && (!mandoDerechoCargado || !mandoIzquierdoCargado || !mandoTrackerCargado) && !hayTracker)
		{
			EsperarMandosCor = StartCoroutine(EsperarMandos());
		}
	}

	private void OnDisable()
	{
		if (EsperarMandosCor != null)
		{
			StopCoroutine(EsperarMandosCor);
		}
		EsperarMandosCor = null;
	}

	private IEnumerator EsperarMandos()
	{
		while ((!mandoDerechoCargado || !mandoIzquierdoCargado || !mandoTrackerCargado) && !hayTracker)
		{
			yield return new WaitForSeconds(0.01f);
			if (controladorDerecho_GO != null)
			{
				indexDerecha = (int)controladorDerecho_TrackedObject.index;
				if (indexDerecha != -1)
				{
					controladorDerecho_TrackedObject.enabled = true;
					if (controladorDerecho_TrackedObject.isTracker)
					{
						tracker = new MandoVive(TipoControl.Tracker, indexDerecha);
						mandoTrackerCargado = true;
						hayTracker = true;
					}
					else
					{
						mandoDerecho = new MandoVive(TipoControl.ControlDerecha, indexDerecha);
						mandoDerechoCargado = true;
					}
				}
			}
			if (controladorIzquierdo_GO != null)
			{
				indexIzquierda = (int)controladorIzquierdo_TrackedObject.index;
				if (indexIzquierda != -1)
				{
					controladorIzquierdo_TrackedObject.enabled = true;
					if (controladorIzquierdo_TrackedObject.isTracker)
					{
						tracker = new MandoVive(TipoControl.Tracker, indexIzquierda);
						mandoTrackerCargado = true;
						hayTracker = true;
					}
					else
					{
						mandoIzquierdo = new MandoVive(TipoControl.ControlIzquierda, indexIzquierda);
						mandoIzquierdoCargado = true;
					}
				}
			}
			if (!(controladorTracker_GO != null) || !Config.hayTracker)
			{
				continue;
			}
			indexTracker = (int)controladorTracker_TrackedObject.index;
			if (indexTracker != -1)
			{
				controladorTracker_TrackedObject.enabled = true;
				if (controladorTracker_TrackedObject.isTracker)
				{
					tracker = new MandoVive(TipoControl.Tracker, indexTracker);
					mandoTrackerCargado = true;
					hayTracker = true;
				}
				else
				{
					tracker = new MandoVive(TipoControl.Tracker, indexTracker);
					mandoTrackerCargado = true;
				}
			}
		}
	}

	public void Vibracion(int index, ushort potencia)
	{
		SteamVR_Controller.Input(index).TriggerHapticPulse(potencia);
	}
}
public class MandoVive
{
	public int index;

	public ControladorVR.TipoControl tipo;

	public float trigger;

	public bool triggerPress;

	public bool triggerUp;

	public bool triggerDown;

	public bool gripPress;

	public bool gripPressDown;

	public bool gripPressUp;

	public bool botonAppPress;

	public bool botonAppPressDown;

	public bool botonAppPressUp;

	public bool touchPress;

	public bool touchPressUp;

	public bool touchPressDown;

	public Vector2 posicionTouchTocado;

	public Vector2 stick;

	public bool botonDownAXPress;

	public bool botonDownAXPressUp;

	public bool botonDownAXPressDown;

	public bool botonUpBYPress;

	public bool botonUpBYPressUp;

	public bool botonUpBYPressDown;

	public Vector3 velocidadMando;

	public bool algunBotonTocado;

	private string inputHorDerStr = "stickDerechoHorizontal";

	private string inputHorIzqStr = "stickIzquierdoHorizontal";

	private string inputVerDer = "stickDerechoVertical";

	private string inputVerIzq = "stickIzquierdoVertical";

	public MandoVive(ControladorVR.TipoControl tipo, int index)
	{
		this.index = index;
		this.tipo = tipo;
	}

	public void LeerBotones(bool derecho)
	{
		LeerBotonesComunes(derecho);
		switch (GameManager.instance.tipoDeSensores)
		{
		case InputsController.TipoSensores.cosmos:
			LeerBotonesCosmos(derecho);
			break;
		case InputsController.TipoSensores.index:
			LeerBotonesIndex(derecho);
			break;
		case InputsController.TipoSensores.vive:
			LeerBotonesVive(derecho);
			break;
		case InputsController.TipoSensores.wmr:
			LeerBotonesWMR(derecho);
			break;
		default:
			LeerBotonesOculus(derecho);
			break;
		}
	}

	public void LeerBotonesComunes(bool derecho)
	{
		trigger = SteamVR_Controller.Input(index).GetAxis(EVRButtonId.k_EButton_Axis1).x;
		triggerUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_Axis1);
		triggerDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_Axis1);
		triggerPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_Axis1);
		gripPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_Grip);
		gripPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_Grip);
		gripPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_Grip);
		touchPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_Axis0);
		touchPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_Axis0);
		touchPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_Axis0);
		posicionTouchTocado = SteamVR_Controller.Input(index).GetAxis();
		string text = "";
		string text2 = "";
		if (derecho)
		{
			text = inputHorDerStr;
			text2 = inputVerDer;
		}
		else
		{
			text = inputHorIzqStr;
			text2 = inputVerIzq;
		}
		stick.x = Input.GetAxis(text);
		stick.y = Input.GetAxis(text2);
		velocidadMando = SteamVR_Controller.Input(index).velocity;
	}

	public void LeerBotonesWMR(bool derecho)
	{
		botonAppPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonDownAXPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_A);
		botonDownAXPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_A);
		botonDownAXPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_A);
		botonUpBYPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
	}

	public void LeerBotonesIndex(bool derecho)
	{
		botonAppPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPress = botonAppPress;
		botonUpBYPressUp = botonAppPressUp;
		botonUpBYPressDown = botonAppPressDown;
		botonDownAXPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_Grip);
		botonDownAXPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_Grip);
		botonDownAXPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_Grip);
	}

	public void LeerBotonesOculus(bool derecho)
	{
		botonAppPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonDownAXPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_A);
		botonDownAXPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_A);
		botonDownAXPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_A);
		botonUpBYPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
	}

	public void LeerBotonesCosmos(bool derecho)
	{
		botonAppPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonDownAXPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_A);
		botonDownAXPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_A);
		botonDownAXPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_A);
		botonUpBYPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
	}

	public void LeerBotonesVive(bool derecho)
	{
		botonAppPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
		botonAppPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonDownAXPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_A);
		botonDownAXPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_A);
		botonDownAXPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_A);
		botonUpBYPress = SteamVR_Controller.Input(index).GetPress(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressUp = SteamVR_Controller.Input(index).GetPressUp(EVRButtonId.k_EButton_ApplicationMenu);
		botonUpBYPressDown = SteamVR_Controller.Input(index).GetPressDown(EVRButtonId.k_EButton_ApplicationMenu);
	}
}
public class limpiarCamaraSegunCalidad : MonoBehaviour
{
	private void Start()
	{
		if (CalidadManager.instance.calidadActual != 0)
		{
			return;
		}
		bool flag = true;
		bool flag2 = true;
		try
		{
			if (OVRPlugin.GetSystemHeadsetType() != OVRPlugin.SystemHeadset.Oculus_Quest)
			{
				flag2 = false;
			}
		}
		catch
		{
		}
		flag = flag2;
		MKGlow component = GetComponent<MKGlow>();
		if ((bool)component && flag)
		{
			UnityEngine.Object.Destroy(component);
		}
		VolumetricFog component2 = GetComponent<VolumetricFog>();
		if ((bool)component2)
		{
			UnityEngine.Object.Destroy(component2);
		}
		VolumetricFogPosT component3 = GetComponent<VolumetricFogPosT>();
		if ((bool)component3)
		{
			UnityEngine.Object.Destroy(component3);
		}
	}

	private void Update()
	{
	}
}
[RequireComponent(typeof(Camera))]
public class EnableCameraDepthInForward : MonoBehaviour
{
	private void Start()
	{
		Set();
	}

	private void Set()
	{
		if (GetComponent<Camera>().depthTextureMode == DepthTextureMode.None)
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
public class SoftNormalsToVertexColor : MonoBehaviour
{
	public enum Method
	{
		Simple,
		AngularDeviation
	}

	public Method method = Method.AngularDeviation;

	public bool generateOnAwake;

	public bool generateNow;

	private void OnDrawGizmos()
	{
		if (generateNow)
		{
			generateNow = false;
			TryGenerate();
		}
	}

	private void Awake()
	{
		if (generateOnAwake)
		{
			TryGenerate();
		}
	}

	private void TryGenerate()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if (component == null)
		{
			UnityEngine.Debug.LogError("MeshFilter missing on the vertex color generator", base.gameObject);
			return;
		}
		if (component.sharedMesh == null)
		{
			UnityEngine.Debug.LogError("Assign a mesh to the MeshFilter before generating vertex colors", base.gameObject);
			return;
		}
		Generate(component.sharedMesh);
		UnityEngine.Debug.Log("Vertex colors generated", base.gameObject);
	}

	private void Generate(Mesh m)
	{
		Vector3[] normals = m.normals;
		Vector3[] vertices = m.vertices;
		Color[] array = new Color[normals.Length];
		List<List<int>> list = new List<List<int>>();
		for (int i = 0; i < vertices.Length; i++)
		{
			bool flag = false;
			foreach (List<int> item in list)
			{
				if (vertices[item[0]] == vertices[i])
				{
					item.Add(i);
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				List<int> list2 = new List<int>();
				list2.Add(i);
				list.Add(list2);
			}
		}
		foreach (List<int> item2 in list)
		{
			Vector3 zero = Vector3.zero;
			foreach (int item3 in item2)
			{
				zero += normals[item3];
			}
			zero.Normalize();
			if (method == Method.AngularDeviation)
			{
				float num = 0f;
				foreach (int item4 in item2)
				{
					num += Vector3.Dot(normals[item4], zero);
				}
				num /= (float)item2.Count;
				float num2 = Mathf.Acos(num) * 57.29578f;
				float num3 = 180f - num2 - 90f;
				float num4 = 0.5f / Mathf.Sin(num3 * ((float)Math.PI / 180f));
				zero *= num4;
			}
			foreach (int item5 in item2)
			{
				array[item5] = new Color(zero.x, zero.y, zero.z);
			}
		}
		m.colors = array;
	}
}
public class CargarLeaderboardsSteam : MonoBehaviour
{
	private string[] mundos = new string[14]
	{
		"Mundo1", "Mundo2", "Mundo3", "Mundo4", "Mundo5", "Mundo6", "Mundo7", "Mundo8", "Mundo9", "Mundo10",
		"Mundo11", "Mundo12", "Mundo13", "Mundo14"
	};

	private IEnumerator Start()
	{
		if (Config.plataforma == Config.PlataformaJuego.SteamVR)
		{
			yield return new WaitForSeconds(1f);
			List<LogrosRecords.InfoTabla> list = new List<LogrosRecords.InfoTabla>();
			for (int i = 0; i < mundos.Length; i++)
			{
				LogrosRecords.InfoTabla item = default(LogrosRecords.InfoTabla);
				item.nombre = mundos[i];
				item.orden = LogrosRecords.OrdenTabla.ascendente;
				list.Add(item);
			}
			LogrosRecords.instance.InicializarTablas(list);
		}
	}
}
public class IGSteamManager : LogrosRecords
{
	private struct Operacion
	{
		public TipoOperacion tipoOperacion;

		public TipoDatos tipoDatos;

		public OrdenTabla orden;

		public int record;

		public string tabla;

		public int numeroResultadosQueQuiero;
	}

	private enum TipoOperacion
	{
		buscarTabla,
		buscarCrearTabla,
		obtenerResultados,
		subirRecord,
		obtenerUserStats,
		GrabarUserStats
	}

	public struct ResultadoSteam
	{
		public string usuario;

		public int record;

		public int posicion;
	}

	public enum TipoAvatar
	{
		peque,
		medio,
		grande
	}

	public enum TipoDatos
	{
		top,
		alrededorMio
	}

	private List<Operacion> operacionesPendientes;

	private void Start()
	{
		if (Config.plataforma != 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public override void GuardarLogros()
	{
	}

	public override void InicializarLogros()
	{
	}

	public override void InicializarTablas(string[] tablas)
	{
	}

	public override void InicializarTablas(List<InfoTabla> tablas)
	{
	}

	public override void ObtenerResultadosAlrededorMioConTop(string tabla, int resultadosQueQuiero, bool esEvento, long record = -1L)
	{
	}

	public override void SubirRecord(string tabla, int record)
	{
	}

	public override void MarcarLogroCompletado(string idLogro)
	{
	}

	public override void ComprobarYDarLogroPlatino()
	{
	}

	public override void MostrarTienda()
	{
	}

	public override string DameMiNombre()
	{
		return "";
	}
}
public struct ClickedEventArgs
{
	public uint controllerIndex;

	public uint flags;

	public float padX;

	public float padY;
}
public delegate void ClickedEventHandler(object sender, ClickedEventArgs e);
public class SteamVR_TrackedController : MonoBehaviour
{
	public uint controllerIndex;

	public VRControllerState_t controllerState;

	public bool triggerPressed;

	public bool steamPressed;

	public bool menuPressed;

	public bool padPressed;

	public bool padTouched;

	public bool gripped;

	public event ClickedEventHandler MenuButtonClicked;

	public event ClickedEventHandler MenuButtonUnclicked;

	public event ClickedEventHandler TriggerClicked;

	public event ClickedEventHandler TriggerUnclicked;

	public event ClickedEventHandler SteamClicked;

	public event ClickedEventHandler PadClicked;

	public event ClickedEventHandler PadUnclicked;

	public event ClickedEventHandler PadTouched;

	public event ClickedEventHandler PadUntouched;

	public event ClickedEventHandler Gripped;

	public event ClickedEventHandler Ungripped;

	protected virtual void Start()
	{
		if (GetComponent<SteamVR_TrackedObject>() == null)
		{
			base.gameObject.AddComponent<SteamVR_TrackedObject>();
		}
		if (controllerIndex != 0)
		{
			GetComponent<SteamVR_TrackedObject>().index = (SteamVR_TrackedObject.EIndex)controllerIndex;
			if (GetComponent<SteamVR_RenderModel>() != null)
			{
				GetComponent<SteamVR_RenderModel>().index = (SteamVR_TrackedObject.EIndex)controllerIndex;
			}
		}
		else
		{
			controllerIndex = (uint)GetComponent<SteamVR_TrackedObject>().index;
		}
	}

	public void SetDeviceIndex(int index)
	{
		controllerIndex = (uint)index;
	}

	public virtual void OnTriggerClicked(ClickedEventArgs e)
	{
		if (this.TriggerClicked != null)
		{
			this.TriggerClicked(this, e);
		}
	}

	public virtual void OnTriggerUnclicked(ClickedEventArgs e)
	{
		if (this.TriggerUnclicked != null)
		{
			this.TriggerUnclicked(this, e);
		}
	}

	public virtual void OnMenuClicked(ClickedEventArgs e)
	{
		if (this.MenuButtonClicked != null)
		{
			this.MenuButtonClicked(this, e);
		}
	}

	public virtual void OnMenuUnclicked(ClickedEventArgs e)
	{
		if (this.MenuButtonUnclicked != null)
		{
			this.MenuButtonUnclicked(this, e);
		}
	}

	public virtual void OnSteamClicked(ClickedEventArgs e)
	{
		if (this.SteamClicked != null)
		{
			this.SteamClicked(this, e);
		}
	}

	public virtual void OnPadClicked(ClickedEventArgs e)
	{
		if (this.PadClicked != null)
		{
			this.PadClicked(this, e);
		}
	}

	public virtual void OnPadUnclicked(ClickedEventArgs e)
	{
		if (this.PadUnclicked != null)
		{
			this.PadUnclicked(this, e);
		}
	}

	public virtual void OnPadTouched(ClickedEventArgs e)
	{
		if (this.PadTouched != null)
		{
			this.PadTouched(this, e);
		}
	}

	public virtual void OnPadUntouched(ClickedEventArgs e)
	{
		if (this.PadUntouched != null)
		{
			this.PadUntouched(this, e);
		}
	}

	public virtual void OnGripped(ClickedEventArgs e)
	{
		if (this.Gripped != null)
		{
			this.Gripped(this, e);
		}
	}

	public virtual void OnUngripped(ClickedEventArgs e)
	{
		if (this.Ungripped != null)
		{
			this.Ungripped(this, e);
		}
	}

	protected virtual void Update()
	{
		CVRSystem system = OpenVR.System;
		if (system != null && system.GetControllerState(controllerIndex, ref controllerState, (uint)Marshal.SizeOf(typeof(VRControllerState_t))))
		{
			ulong num = controllerState.ulButtonPressed & 0x200000000uL;
			if (num != 0 && !triggerPressed)
			{
				triggerPressed = true;
				ClickedEventArgs e = default(ClickedEventArgs);
				e.controllerIndex = controllerIndex;
				e.flags = (uint)controllerState.ulButtonPressed;
				e.padX = controllerState.rAxis0.x;
				e.padY = controllerState.rAxis0.y;
				OnTriggerClicked(e);
			}
			else if (num == 0L && triggerPressed)
			{
				triggerPressed = false;
				ClickedEventArgs e2 = default(ClickedEventArgs);
				e2.controllerIndex = controllerIndex;
				e2.flags = (uint)controllerState.ulButtonPressed;
				e2.padX = controllerState.rAxis0.x;
				e2.padY = controllerState.rAxis0.y;
				OnTriggerUnclicked(e2);
			}
			ulong num2 = controllerState.ulButtonPressed & 4;
			if (num2 != 0 && !gripped)
			{
				gripped = true;
				ClickedEventArgs e3 = default(ClickedEventArgs);
				e3.controllerIndex = controllerIndex;
				e3.flags = (uint)controllerState.ulButtonPressed;
				e3.padX = controllerState.rAxis0.x;
				e3.padY = controllerState.rAxis0.y;
				OnGripped(e3);
			}
			else if (num2 == 0L && gripped)
			{
				gripped = false;
				ClickedEventArgs e4 = default(ClickedEventArgs);
				e4.controllerIndex = controllerIndex;
				e4.flags = (uint)controllerState.ulButtonPressed;
				e4.padX = controllerState.rAxis0.x;
				e4.padY = controllerState.rAxis0.y;
				OnUngripped(e4);
			}
			ulong num3 = controllerState.ulButtonPressed & 0x100000000uL;
			if (num3 != 0 && !padPressed)
			{
				padPressed = true;
				ClickedEventArgs e5 = default(ClickedEventArgs);
				e5.controllerIndex = controllerIndex;
				e5.flags = (uint)controllerState.ulButtonPressed;
				e5.padX = controllerState.rAxis0.x;
				e5.padY = controllerState.rAxis0.y;
				OnPadClicked(e5);
			}
			else if (num3 == 0L && padPressed)
			{
				padPressed = false;
				ClickedEventArgs e6 = default(ClickedEventArgs);
				e6.controllerIndex = controllerIndex;
				e6.flags = (uint)controllerState.ulButtonPressed;
				e6.padX = controllerState.rAxis0.x;
				e6.padY = controllerState.rAxis0.y;
				OnPadUnclicked(e6);
			}
			ulong num4 = controllerState.ulButtonPressed & 2;
			if (num4 != 0 && !menuPressed)
			{
				menuPressed = true;
				ClickedEventArgs e7 = default(ClickedEventArgs);
				e7.controllerIndex = controllerIndex;
				e7.flags = (uint)controllerState.ulButtonPressed;
				e7.padX = controllerState.rAxis0.x;
				e7.padY = controllerState.rAxis0.y;
				OnMenuClicked(e7);
			}
			else if (num4 == 0L && menuPressed)
			{
				menuPressed = false;
				ClickedEventArgs e8 = default(ClickedEventArgs);
				e8.controllerIndex = controllerIndex;
				e8.flags = (uint)controllerState.ulButtonPressed;
				e8.padX = controllerState.rAxis0.x;
				e8.padY = controllerState.rAxis0.y;
				OnMenuUnclicked(e8);
			}
			num3 = controllerState.ulButtonTouched & 0x100000000uL;
			if (num3 != 0 && !padTouched)
			{
				padTouched = true;
				ClickedEventArgs e9 = default(ClickedEventArgs);
				e9.controllerIndex = controllerIndex;
				e9.flags = (uint)controllerState.ulButtonPressed;
				e9.padX = controllerState.rAxis0.x;
				e9.padY = controllerState.rAxis0.y;
				OnPadTouched(e9);
			}
			else if (num3 == 0L && padTouched)
			{
				padTouched = false;
				ClickedEventArgs e10 = default(ClickedEventArgs);
				e10.controllerIndex = controllerIndex;
				e10.flags = (uint)controllerState.ulButtonPressed;
				e10.padX = controllerState.rAxis0.x;
				e10.padY = controllerState.rAxis0.y;
				OnPadUntouched(e10);
			}
		}
	}
}
public class SteamVR : IDisposable
{
	private static bool _enabled = true;

	private static SteamVR _instance;

	public static bool[] connected = new bool[64];

	public ETextureType textureType;

	public static bool active => _instance != null;

	public static bool enabled
	{
		get
		{
			if (!XRSettings.enabled)
			{
				enabled = false;
			}
			return _enabled;
		}
		set
		{
			_enabled = value;
			if (!_enabled)
			{
				SafeDispose();
			}
		}
	}

	public static SteamVR instance
	{
		get
		{
			if (!enabled)
			{
				return null;
			}
			if (_instance == null)
			{
				_instance = CreateInstance();
				if (_instance == null)
				{
					_enabled = false;
				}
			}
			return _instance;
		}
	}

	public static bool usingNativeSupport => XRDevice.GetNativePtr() != IntPtr.Zero;

	public CVRSystem hmd { get; private set; }

	public CVRCompositor compositor { get; private set; }

	public CVROverlay overlay { get; private set; }

	public static bool initializing { get; private set; }

	public static bool calibrating { get; private set; }

	public static bool outOfRange { get; private set; }

	public float sceneWidth { get; private set; }

	public float sceneHeight { get; private set; }

	public float aspect { get; private set; }

	public float fieldOfView { get; private set; }

	public Vector2 tanHalfFov { get; private set; }

	public VRTextureBounds_t[] textureBounds { get; private set; }

	public SteamVR_Utils.RigidTransform[] eyes { get; private set; }

	public string hmd_TrackingSystemName => GetStringProperty(ETrackedDeviceProperty.Prop_TrackingSystemName_String);

	public string hmd_ModelNumber => GetStringProperty(ETrackedDeviceProperty.Prop_ModelNumber_String);

	public string hmd_SerialNumber => GetStringProperty(ETrackedDeviceProperty.Prop_SerialNumber_String);

	public float hmd_SecondsFromVsyncToPhotons => GetFloatProperty(ETrackedDeviceProperty.Prop_SecondsFromVsyncToPhotons_Float);

	public float hmd_DisplayFrequency => GetFloatProperty(ETrackedDeviceProperty.Prop_DisplayFrequency_Float);

	private static SteamVR CreateInstance()
	{
		try
		{
			EVRInitError peError = EVRInitError.None;
			if (!usingNativeSupport)
			{
				UnityEngine.Debug.Log("OpenVR initialization failed.  Ensure 'Virtual Reality Supported' is checked in Player Settings, and OpenVR is added to the list of Virtual Reality SDKs.");
				return null;
			}
			OpenVR.GetGenericInterface("IVRCompositor_022", ref peError);
			if (peError != 0)
			{
				ReportError(peError);
				return null;
			}
			OpenVR.GetGenericInterface("IVROverlay_018", ref peError);
			if (peError != 0)
			{
				ReportError(peError);
				return null;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
			return null;
		}
		return new SteamVR();
	}

	private static void ReportError(EVRInitError error)
	{
		switch (error)
		{
		case EVRInitError.VendorSpecific_UnableToConnectToOculusRuntime:
			UnityEngine.Debug.Log("SteamVR Initialization Failed!  Make sure device is on, Oculus runtime is installed, and OVRService_*.exe is running.");
			break;
		case EVRInitError.Init_VRClientDLLNotFound:
			UnityEngine.Debug.Log("SteamVR drivers not found!  They can be installed via Steam under Library > Tools.  Visit http://steampowered.com to install Steam.");
			break;
		case EVRInitError.Driver_RuntimeOutOfDate:
			UnityEngine.Debug.Log("SteamVR Initialization Failed!  Make sure device's runtime is up to date.");
			break;
		default:
			UnityEngine.Debug.Log(OpenVR.GetStringForHmdError(error));
			break;
		case EVRInitError.None:
			break;
		}
	}

	public string GetTrackedDeviceString(uint deviceId)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = hmd.GetStringTrackedDeviceProperty(deviceId, ETrackedDeviceProperty.Prop_AttachedDeviceId_String, null, 0u, ref pError);
		if (stringTrackedDeviceProperty > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
			hmd.GetStringTrackedDeviceProperty(deviceId, ETrackedDeviceProperty.Prop_AttachedDeviceId_String, stringBuilder, stringTrackedDeviceProperty, ref pError);
			return stringBuilder.ToString();
		}
		return null;
	}

	public string GetStringProperty(ETrackedDeviceProperty prop, uint deviceId = 0u)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = hmd.GetStringTrackedDeviceProperty(deviceId, prop, null, 0u, ref pError);
		if (stringTrackedDeviceProperty > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
			hmd.GetStringTrackedDeviceProperty(deviceId, prop, stringBuilder, stringTrackedDeviceProperty, ref pError);
			return stringBuilder.ToString();
		}
		if (pError == ETrackedPropertyError.TrackedProp_Success)
		{
			return "<unknown>";
		}
		return pError.ToString();
	}

	public float GetFloatProperty(ETrackedDeviceProperty prop, uint deviceId = 0u)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		return hmd.GetFloatTrackedDeviceProperty(deviceId, prop, ref pError);
	}

	private void OnInitializing(bool initializing)
	{
		SteamVR.initializing = initializing;
	}

	private void OnCalibrating(bool calibrating)
	{
		SteamVR.calibrating = calibrating;
	}

	private void OnOutOfRange(bool outOfRange)
	{
		SteamVR.outOfRange = outOfRange;
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		SteamVR.connected[i] = connected;
	}

	private void OnNewPoses(TrackedDevicePose_t[] poses)
	{
		eyes[0] = new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Left));
		eyes[1] = new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Right));
		for (int i = 0; i < poses.Length; i++)
		{
			bool bDeviceIsConnected = poses[i].bDeviceIsConnected;
			if (bDeviceIsConnected != connected[i])
			{
				SteamVR_Events.DeviceConnected.Send(i, bDeviceIsConnected);
			}
		}
		if ((long)poses.Length > 0L)
		{
			ETrackingResult eTrackingResult = poses[0].eTrackingResult;
			bool flag = eTrackingResult == ETrackingResult.Uninitialized;
			if (flag != initializing)
			{
				SteamVR_Events.Initializing.Send(flag);
			}
			bool flag2 = eTrackingResult == ETrackingResult.Calibrating_InProgress || eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
			if (flag2 != calibrating)
			{
				SteamVR_Events.Calibrating.Send(flag2);
			}
			bool flag3 = eTrackingResult == ETrackingResult.Running_OutOfRange || eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
			if (flag3 != outOfRange)
			{
				SteamVR_Events.OutOfRange.Send(flag3);
			}
		}
	}

	private SteamVR()
	{
		hmd = OpenVR.System;
		UnityEngine.Debug.Log("Connected to " + hmd_TrackingSystemName + ":" + hmd_SerialNumber);
		compositor = OpenVR.Compositor;
		overlay = OpenVR.Overlay;
		uint pnWidth = 0u;
		uint pnHeight = 0u;
		hmd.GetRecommendedRenderTargetSize(ref pnWidth, ref pnHeight);
		sceneWidth = pnWidth;
		sceneHeight = pnHeight;
		float pfLeft = 0f;
		float pfRight = 0f;
		float pfTop = 0f;
		float pfBottom = 0f;
		hmd.GetProjectionRaw(EVREye.Eye_Left, ref pfLeft, ref pfRight, ref pfTop, ref pfBottom);
		float pfLeft2 = 0f;
		float pfRight2 = 0f;
		float pfTop2 = 0f;
		float pfBottom2 = 0f;
		hmd.GetProjectionRaw(EVREye.Eye_Right, ref pfLeft2, ref pfRight2, ref pfTop2, ref pfBottom2);
		tanHalfFov = new Vector2(Mathf.Max(0f - pfLeft, pfRight, 0f - pfLeft2, pfRight2), Mathf.Max(0f - pfTop, pfBottom, 0f - pfTop2, pfBottom2));
		textureBounds = new VRTextureBounds_t[2];
		textureBounds[0].uMin = 0.5f + 0.5f * pfLeft / tanHalfFov.x;
		textureBounds[0].uMax = 0.5f + 0.5f * pfRight / tanHalfFov.x;
		textureBounds[0].vMin = 0.5f - 0.5f * pfBottom / tanHalfFov.y;
		textureBounds[0].vMax = 0.5f - 0.5f * pfTop / tanHalfFov.y;
		textureBounds[1].uMin = 0.5f + 0.5f * pfLeft2 / tanHalfFov.x;
		textureBounds[1].uMax = 0.5f + 0.5f * pfRight2 / tanHalfFov.x;
		textureBounds[1].vMin = 0.5f - 0.5f * pfBottom2 / tanHalfFov.y;
		textureBounds[1].vMax = 0.5f - 0.5f * pfTop2 / tanHalfFov.y;
		sceneWidth /= Mathf.Max(textureBounds[0].uMax - textureBounds[0].uMin, textureBounds[1].uMax - textureBounds[1].uMin);
		sceneHeight /= Mathf.Max(textureBounds[0].vMax - textureBounds[0].vMin, textureBounds[1].vMax - textureBounds[1].vMin);
		aspect = tanHalfFov.x / tanHalfFov.y;
		fieldOfView = 2f * Mathf.Atan(tanHalfFov.y) * 57.29578f;
		eyes = new SteamVR_Utils.RigidTransform[2]
		{
			new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Left)),
			new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Right))
		};
		switch (SystemInfo.graphicsDeviceType)
		{
		case GraphicsDeviceType.OpenGLES2:
		case GraphicsDeviceType.OpenGLES3:
		case GraphicsDeviceType.OpenGLCore:
			textureType = ETextureType.OpenGL;
			break;
		case GraphicsDeviceType.Vulkan:
			textureType = ETextureType.Vulkan;
			break;
		default:
			textureType = ETextureType.DirectX;
			break;
		}
		SteamVR_Events.Initializing.Listen(OnInitializing);
		SteamVR_Events.Calibrating.Listen(OnCalibrating);
		SteamVR_Events.OutOfRange.Listen(OnOutOfRange);
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
		SteamVR_Events.NewPoses.Listen(OnNewPoses);
	}

	~SteamVR()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		SteamVR_Events.Initializing.Remove(OnInitializing);
		SteamVR_Events.Calibrating.Remove(OnCalibrating);
		SteamVR_Events.OutOfRange.Remove(OnOutOfRange);
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
		SteamVR_Events.NewPoses.Remove(OnNewPoses);
		_instance = null;
	}

	public static void SafeDispose()
	{
		if (_instance != null)
		{
			_instance.Dispose();
		}
	}
}
[RequireComponent(typeof(Camera))]
public class SteamVR_Camera : MonoBehaviour
{
	[SerializeField]
	private Transform _head;

	[SerializeField]
	private Transform _ears;

	public bool wireframe;

	private static System.Collections.Hashtable values;

	private const string eyeSuffix = " (eye)";

	private const string earsSuffix = " (ears)";

	private const string headSuffix = " (head)";

	private const string originSuffix = " (origin)";

	public Transform head => _head;

	public Transform offset => _head;

	public Transform origin => _head.parent;

	public Camera camera { get; private set; }

	public Transform ears => _ears;

	public static float sceneResolutionScale
	{
		get
		{
			return XRSettings.eyeTextureResolutionScale;
		}
		set
		{
			XRSettings.eyeTextureResolutionScale = value;
		}
	}

	public string baseName
	{
		get
		{
			if (!base.name.EndsWith(" (eye)"))
			{
				return base.name;
			}
			return base.name.Substring(0, base.name.Length - " (eye)".Length);
		}
	}

	public Ray GetRay()
	{
		return new Ray(_head.position, _head.forward);
	}

	private void OnDisable()
	{
		SteamVR_Render.Remove(this);
	}

	private void OnEnable()
	{
		if (SteamVR.instance == null)
		{
			if (head != null)
			{
				head.GetComponent<SteamVR_TrackedObject>().enabled = false;
			}
			base.enabled = false;
			return;
		}
		Transform transform = base.transform;
		if (head != transform)
		{
			Expand();
			transform.parent = origin;
			while (head.childCount > 0)
			{
				head.GetChild(0).parent = transform;
			}
			head.parent = transform;
			head.localPosition = Vector3.zero;
			head.localRotation = Quaternion.identity;
			head.localScale = Vector3.one;
			head.gameObject.SetActive(value: false);
			_head = transform;
		}
		if (ears == null)
		{
			SteamVR_Ears componentInChildren = base.transform.GetComponentInChildren<SteamVR_Ears>();
			if (componentInChildren != null)
			{
				_ears = componentInChildren.transform;
			}
		}
		if (ears != null)
		{
			ears.GetComponent<SteamVR_Ears>().vrcam = this;
		}
		SteamVR_Render.Add(this);
	}

	private void Awake()
	{
		camera = GetComponent<Camera>();
		ForceLast();
	}

	public void ForceLast()
	{
		if (values != null)
		{
			foreach (DictionaryEntry value in values)
			{
				(value.Key as FieldInfo).SetValue(this, value.Value);
			}
			values = null;
			return;
		}
		Component[] components = GetComponents<Component>();
		for (int i = 0; i < components.Length; i++)
		{
			SteamVR_Camera steamVR_Camera = components[i] as SteamVR_Camera;
			if (steamVR_Camera != null && steamVR_Camera != this)
			{
				UnityEngine.Object.DestroyImmediate(steamVR_Camera);
			}
		}
		if (!(this != GetComponents<Component>()[^1]))
		{
			return;
		}
		values = new System.Collections.Hashtable();
		FieldInfo[] fields = GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (fieldInfo.IsPublic || fieldInfo.IsDefined(typeof(SerializeField), inherit: true))
			{
				values[fieldInfo] = fieldInfo.GetValue(this);
			}
		}
		GameObject obj = base.gameObject;
		UnityEngine.Object.DestroyImmediate(this);
		obj.AddComponent<SteamVR_Camera>().ForceLast();
	}

	public void Expand()
	{
		Transform parent = base.transform.parent;
		if (parent == null)
		{
			parent = new GameObject(base.name + " (origin)").transform;
			parent.localPosition = base.transform.localPosition;
			parent.localRotation = base.transform.localRotation;
			parent.localScale = base.transform.localScale;
		}
		if (head == null)
		{
			_head = new GameObject(base.name + " (head)", typeof(SteamVR_TrackedObject)).transform;
			head.parent = parent;
			head.position = base.transform.position;
			head.rotation = base.transform.rotation;
			head.localScale = Vector3.one;
			head.tag = base.tag;
		}
		if (base.transform.parent != head)
		{
			base.transform.parent = head;
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			base.transform.localScale = Vector3.one;
			while (base.transform.childCount > 0)
			{
				base.transform.GetChild(0).parent = head;
			}
			AudioListener component = GetComponent<AudioListener>();
			if (component != null)
			{
				UnityEngine.Object.DestroyImmediate(component);
				_ears = new GameObject(base.name + " (ears)", typeof(SteamVR_Ears)).transform;
				ears.parent = _head;
				ears.localPosition = Vector3.zero;
				ears.localRotation = Quaternion.identity;
				ears.localScale = Vector3.one;
			}
		}
		if (!base.name.EndsWith(" (eye)"))
		{
			base.name += " (eye)";
		}
	}

	public void Collapse()
	{
		base.transform.parent = null;
		while (head.childCount > 0)
		{
			head.GetChild(0).parent = base.transform;
		}
		if (ears != null)
		{
			while (ears.childCount > 0)
			{
				ears.GetChild(0).parent = base.transform;
			}
			UnityEngine.Object.DestroyImmediate(ears.gameObject);
			_ears = null;
			base.gameObject.AddComponent(typeof(AudioListener));
		}
		if (origin != null)
		{
			if (origin.name.EndsWith(" (origin)"))
			{
				Transform transform = origin;
				while (transform.childCount > 0)
				{
					transform.GetChild(0).parent = transform.parent;
				}
				UnityEngine.Object.DestroyImmediate(transform.gameObject);
			}
			else
			{
				base.transform.parent = origin;
			}
		}
		UnityEngine.Object.DestroyImmediate(head.gameObject);
		_head = null;
		if (base.name.EndsWith(" (eye)"))
		{
			base.name = base.name.Substring(0, base.name.Length - " (eye)".Length);
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_CameraFlip : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_CameraFlip is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
[ExecuteInEditMode]
public class SteamVR_CameraMask : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_CameraMask is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_Controller
{
	public class ButtonMask
	{
		public const ulong System = 1uL;

		public const ulong ApplicationMenu = 2uL;

		public const ulong Grip = 4uL;

		public const ulong Axis0 = 4294967296uL;

		public const ulong Axis1 = 8589934592uL;

		public const ulong Axis2 = 17179869184uL;

		public const ulong Axis3 = 34359738368uL;

		public const ulong Axis4 = 68719476736uL;

		public const ulong Touchpad = 4294967296uL;

		public const ulong Trigger = 8589934592uL;
	}

	public class Device
	{
		private VRControllerState_t state;

		private VRControllerState_t prevState;

		private TrackedDevicePose_t pose;

		private int prevFrameCount = -1;

		public float hairTriggerDelta = 0.1f;

		private float hairTriggerLimit;

		private bool hairTriggerState;

		private bool hairTriggerPrevState;

		public uint index { get; private set; }

		public bool valid { get; private set; }

		public bool connected
		{
			get
			{
				Update();
				return pose.bDeviceIsConnected;
			}
		}

		public bool hasTracking
		{
			get
			{
				Update();
				return pose.bPoseIsValid;
			}
		}

		public bool outOfRange
		{
			get
			{
				Update();
				if (pose.eTrackingResult != ETrackingResult.Running_OutOfRange)
				{
					return pose.eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
				}
				return true;
			}
		}

		public bool calibrating
		{
			get
			{
				Update();
				if (pose.eTrackingResult != ETrackingResult.Calibrating_InProgress)
				{
					return pose.eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
				}
				return true;
			}
		}

		public bool uninitialized
		{
			get
			{
				Update();
				return pose.eTrackingResult == ETrackingResult.Uninitialized;
			}
		}

		public SteamVR_Utils.RigidTransform transform
		{
			get
			{
				Update();
				return new SteamVR_Utils.RigidTransform(pose.mDeviceToAbsoluteTracking);
			}
		}

		public Vector3 velocity
		{
			get
			{
				Update();
				return new Vector3(pose.vVelocity.v0, pose.vVelocity.v1, 0f - pose.vVelocity.v2);
			}
		}

		public Vector3 angularVelocity
		{
			get
			{
				Update();
				return new Vector3(0f - pose.vAngularVelocity.v0, 0f - pose.vAngularVelocity.v1, pose.vAngularVelocity.v2);
			}
		}

		public Device(uint i)
		{
			index = i;
		}

		public VRControllerState_t GetState()
		{
			Update();
			return state;
		}

		public VRControllerState_t GetPrevState()
		{
			Update();
			return prevState;
		}

		public TrackedDevicePose_t GetPose()
		{
			Update();
			return pose;
		}

		public void Update()
		{
			if (Time.frameCount != prevFrameCount)
			{
				prevFrameCount = Time.frameCount;
				prevState = state;
				CVRSystem system = OpenVR.System;
				if (system != null)
				{
					valid = system.GetControllerStateWithPose(SteamVR_Render.instance.trackingSpace, index, ref state, (uint)Marshal.SizeOf(typeof(VRControllerState_t)), ref pose);
					UpdateHairTrigger();
				}
			}
		}

		public bool GetPress(ulong buttonMask)
		{
			Update();
			return (state.ulButtonPressed & buttonMask) != 0;
		}

		public bool GetPressDown(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonPressed & buttonMask) != 0L)
			{
				return (prevState.ulButtonPressed & buttonMask) == 0;
			}
			return false;
		}

		public bool GetPressUp(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonPressed & buttonMask) == 0L)
			{
				return (prevState.ulButtonPressed & buttonMask) != 0;
			}
			return false;
		}

		public bool GetPress(EVRButtonId buttonId)
		{
			return GetPress((ulong)(1L << (int)buttonId));
		}

		public bool GetPressDown(EVRButtonId buttonId)
		{
			return GetPressDown((ulong)(1L << (int)buttonId));
		}

		public bool GetPressUp(EVRButtonId buttonId)
		{
			return GetPressUp((ulong)(1L << (int)buttonId));
		}

		public bool GetTouch(ulong buttonMask)
		{
			Update();
			return (state.ulButtonTouched & buttonMask) != 0;
		}

		public bool GetTouchDown(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonTouched & buttonMask) != 0L)
			{
				return (prevState.ulButtonTouched & buttonMask) == 0;
			}
			return false;
		}

		public bool GetTouchUp(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonTouched & buttonMask) == 0L)
			{
				return (prevState.ulButtonTouched & buttonMask) != 0;
			}
			return false;
		}

		public bool GetTouch(EVRButtonId buttonId)
		{
			return GetTouch((ulong)(1L << (int)buttonId));
		}

		public bool GetTouchDown(EVRButtonId buttonId)
		{
			return GetTouchDown((ulong)(1L << (int)buttonId));
		}

		public bool GetTouchUp(EVRButtonId buttonId)
		{
			return GetTouchUp((ulong)(1L << (int)buttonId));
		}

		public Vector2 GetAxis(EVRButtonId buttonId = EVRButtonId.k_EButton_Axis0)
		{
			Update();
			return (uint)buttonId switch
			{
				32u => new Vector2(state.rAxis0.x, state.rAxis0.y), 
				33u => new Vector2(state.rAxis1.x, state.rAxis1.y), 
				34u => new Vector2(state.rAxis2.x, state.rAxis2.y), 
				35u => new Vector2(state.rAxis3.x, state.rAxis3.y), 
				36u => new Vector2(state.rAxis4.x, state.rAxis4.y), 
				_ => Vector2.zero, 
			};
		}

		public void TriggerHapticPulse(ushort durationMicroSec = 500, EVRButtonId buttonId = EVRButtonId.k_EButton_Axis0)
		{
			CVRSystem system = OpenVR.System;
			if (system != null)
			{
				uint unAxisId = (uint)(buttonId - 32);
				system.TriggerHapticPulse(index, unAxisId, (char)durationMicroSec);
			}
		}

		private void UpdateHairTrigger()
		{
			hairTriggerPrevState = hairTriggerState;
			float x = state.rAxis1.x;
			if (hairTriggerState)
			{
				if (x < hairTriggerLimit - hairTriggerDelta || x <= 0f)
				{
					hairTriggerState = false;
				}
			}
			else if (x > hairTriggerLimit + hairTriggerDelta || x >= 1f)
			{
				hairTriggerState = true;
			}
			hairTriggerLimit = (hairTriggerState ? Mathf.Max(hairTriggerLimit, x) : Mathf.Min(hairTriggerLimit, x));
		}

		public bool GetHairTrigger()
		{
			Update();
			return hairTriggerState;
		}

		public bool GetHairTriggerDown()
		{
			Update();
			if (hairTriggerState)
			{
				return !hairTriggerPrevState;
			}
			return false;
		}

		public bool GetHairTriggerUp()
		{
			Update();
			if (!hairTriggerState)
			{
				return hairTriggerPrevState;
			}
			return false;
		}
	}

	public enum DeviceRelation
	{
		First,
		Leftmost,
		Rightmost,
		FarthestLeft,
		FarthestRight
	}

	private static Device[] devices;

	public static Device Input(int deviceIndex)
	{
		if (devices == null)
		{
			devices = new Device[64];
			for (uint num = 0u; num < devices.Length; num++)
			{
				devices[num] = new Device(num);
			}
		}
		return devices[deviceIndex];
	}

	public static void Update()
	{
		for (int i = 0; (long)i < 64L; i++)
		{
			Input(i).Update();
		}
	}

	public static int GetDeviceIndex(DeviceRelation relation, ETrackedDeviceClass deviceClass = ETrackedDeviceClass.Controller, int relativeTo = 0)
	{
		int result = -1;
		SteamVR_Utils.RigidTransform rigidTransform = (((uint)relativeTo < 64u) ? Input(relativeTo).transform.GetInverse() : SteamVR_Utils.RigidTransform.identity);
		CVRSystem system = OpenVR.System;
		if (system == null)
		{
			return result;
		}
		float num = float.MinValue;
		for (int i = 0; (long)i < 64L; i++)
		{
			if (i == relativeTo || system.GetTrackedDeviceClass((uint)i) != deviceClass)
			{
				continue;
			}
			Device device = Input(i);
			if (device.connected)
			{
				if (relation == DeviceRelation.First)
				{
					return i;
				}
				Vector3 vector = rigidTransform * device.transform.pos;
				float num3;
				switch (relation)
				{
				case DeviceRelation.FarthestRight:
					num3 = vector.x;
					break;
				case DeviceRelation.FarthestLeft:
					num3 = 0f - vector.x;
					break;
				default:
				{
					Vector3 normalized = new Vector3(vector.x, 0f, vector.z).normalized;
					float num2 = Vector3.Dot(normalized, Vector3.forward);
					Vector3 vector2 = Vector3.Cross(normalized, Vector3.forward);
					num3 = ((relation != DeviceRelation.Leftmost) ? ((vector2.y < 0f) ? (2f - num2) : num2) : ((vector2.y > 0f) ? (2f - num2) : num2));
					break;
				}
				}
				if (num3 > num)
				{
					result = i;
					num = num3;
				}
			}
		}
		return result;
	}
}
public class SteamVR_ControllerManager : MonoBehaviour
{
	public GameObject left;

	public GameObject right;

	[Tooltip("Populate with objects you want to assign to additional controllers")]
	public GameObject[] objects;

	[Tooltip("Set to true if you want objects arbitrarily assigned to controllers before their role (left vs right) is identified")]
	public bool assignAllBeforeIdentified;

	private uint[] indices;

	private bool[] connected = new bool[64];

	private uint leftIndex = uint.MaxValue;

	private uint rightIndex = uint.MaxValue;

	private bool targetsUpdated;

	private SteamVR_Events.Action inputFocusAction;

	private SteamVR_Events.Action deviceConnectedAction;

	private SteamVR_Events.Action trackedDeviceRoleChangedAction;

	private static string hiddenPrefix = "hidden (";

	private static string hiddenPostfix = ")";

	private static string[] labels = new string[2] { "left", "right" };

	private void SetUniqueObject(GameObject o, int index)
	{
		for (int i = 0; i < index; i++)
		{
			if (objects[i] == o)
			{
				return;
			}
		}
		objects[index] = o;
	}

	public void UpdateTargets()
	{
		targetsUpdated = true;
		GameObject[] array = objects;
		int num = ((array != null) ? array.Length : 0);
		objects = new GameObject[2 + num];
		SetUniqueObject(right, 0);
		SetUniqueObject(left, 1);
		for (int i = 0; i < num; i++)
		{
			SetUniqueObject(array[i], 2 + i);
		}
		indices = new uint[2 + num];
		for (int j = 0; j < indices.Length; j++)
		{
			indices[j] = uint.MaxValue;
		}
	}

	private void Awake()
	{
		base.enabled = false;
	}

	private void Start()
	{
		UpdateTargets();
	}

	private SteamVR_ControllerManager()
	{
		inputFocusAction = SteamVR_Events.InputFocusAction(OnInputFocus);
		deviceConnectedAction = SteamVR_Events.DeviceConnectedAction(OnDeviceConnected);
		trackedDeviceRoleChangedAction = SteamVR_Events.SystemAction(EVREventType.VREvent_TrackedDeviceRoleChanged, OnTrackedDeviceRoleChanged);
	}

	private void OnEnable()
	{
		if (!targetsUpdated)
		{
			UpdateTargets();
		}
		for (int i = 0; i < objects.Length; i++)
		{
			GameObject gameObject = objects[i];
			if (gameObject != null)
			{
				gameObject.SetActive(value: false);
			}
			indices[i] = uint.MaxValue;
		}
		Refresh();
		for (int j = 0; j < SteamVR.connected.Length; j++)
		{
			if (SteamVR.connected[j])
			{
				OnDeviceConnected(j, connected: true);
			}
		}
		inputFocusAction.enabled = true;
		deviceConnectedAction.enabled = true;
		trackedDeviceRoleChangedAction.enabled = true;
	}

	private void OnDisable()
	{
		inputFocusAction.enabled = false;
		deviceConnectedAction.enabled = false;
		trackedDeviceRoleChangedAction.enabled = false;
	}

	private void OnInputFocus(bool hasFocus)
	{
		if (hasFocus)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				GameObject gameObject = objects[i];
				if (gameObject != null)
				{
					string text = ((i < 2) ? labels[i] : (i - 1).ToString());
					ShowObject(gameObject.transform, hiddenPrefix + text + hiddenPostfix);
				}
			}
			return;
		}
		for (int j = 0; j < objects.Length; j++)
		{
			GameObject gameObject2 = objects[j];
			if (gameObject2 != null)
			{
				string text2 = ((j < 2) ? labels[j] : (j - 1).ToString());
				HideObject(gameObject2.transform, hiddenPrefix + text2 + hiddenPostfix);
			}
		}
	}

	private void HideObject(Transform t, string name)
	{
		if (t.gameObject.name.StartsWith(hiddenPrefix))
		{
			UnityEngine.Debug.Log("Ignoring double-hide.");
			return;
		}
		Transform transform = new GameObject(name).transform;
		transform.parent = t.parent;
		t.parent = transform;
		transform.gameObject.SetActive(value: false);
	}

	private void ShowObject(Transform t, string name)
	{
		Transform parent = t.parent;
		if (!(parent.gameObject.name != name))
		{
			t.parent = parent.parent;
			UnityEngine.Object.Destroy(parent.gameObject);
		}
	}

	private void SetTrackedDeviceIndex(int objectIndex, uint trackedDeviceIndex)
	{
		if (trackedDeviceIndex != uint.MaxValue)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				if (i != objectIndex && indices[i] == trackedDeviceIndex)
				{
					GameObject gameObject = objects[i];
					if (gameObject != null)
					{
						gameObject.SetActive(value: false);
					}
					indices[i] = uint.MaxValue;
				}
			}
		}
		if (trackedDeviceIndex == indices[objectIndex])
		{
			return;
		}
		indices[objectIndex] = trackedDeviceIndex;
		GameObject gameObject2 = objects[objectIndex];
		if (gameObject2 != null)
		{
			if (trackedDeviceIndex == uint.MaxValue)
			{
				gameObject2.SetActive(value: false);
				return;
			}
			gameObject2.SetActive(value: true);
			gameObject2.BroadcastMessage("SetDeviceIndex", (int)trackedDeviceIndex, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnTrackedDeviceRoleChanged(VREvent_t vrEvent)
	{
		Refresh();
	}

	private void OnDeviceConnected(int index, bool connected)
	{
		bool flag = this.connected[index];
		this.connected[index] = false;
		if (connected)
		{
			CVRSystem system = OpenVR.System;
			if (system != null)
			{
				ETrackedDeviceClass trackedDeviceClass = system.GetTrackedDeviceClass((uint)index);
				if (trackedDeviceClass == ETrackedDeviceClass.Controller || trackedDeviceClass == ETrackedDeviceClass.GenericTracker)
				{
					this.connected[index] = true;
					flag = !flag;
				}
			}
		}
		if (flag)
		{
			Refresh();
		}
	}

	public void Refresh()
	{
		int num = 0;
		CVRSystem system = OpenVR.System;
		if (system != null)
		{
			leftIndex = system.GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole.LeftHand);
			rightIndex = system.GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole.RightHand);
		}
		if (leftIndex == uint.MaxValue && rightIndex == uint.MaxValue)
		{
			for (uint num2 = 0u; num2 < connected.Length; num2++)
			{
				if (num >= objects.Length)
				{
					break;
				}
				if (connected[num2])
				{
					SetTrackedDeviceIndex(num++, num2);
					if (!assignAllBeforeIdentified)
					{
						break;
					}
				}
			}
		}
		else
		{
			SetTrackedDeviceIndex(num++, (rightIndex < connected.Length && connected[rightIndex]) ? rightIndex : uint.MaxValue);
			SetTrackedDeviceIndex(num++, (leftIndex < connected.Length && connected[leftIndex]) ? leftIndex : uint.MaxValue);
			if (leftIndex != uint.MaxValue && rightIndex != uint.MaxValue)
			{
				for (uint num3 = 0u; num3 < connected.Length; num3++)
				{
					if (num >= objects.Length)
					{
						break;
					}
					if (connected[num3] && num3 != leftIndex && num3 != rightIndex)
					{
						SetTrackedDeviceIndex(num++, num3);
					}
				}
			}
		}
		while (num < objects.Length)
		{
			SetTrackedDeviceIndex(num++, uint.MaxValue);
		}
	}
}
[RequireComponent(typeof(AudioListener))]
public class SteamVR_Ears : MonoBehaviour
{
	public SteamVR_Camera vrcam;

	private bool usingSpeakers;

	private Quaternion offset;

	private void OnNewPosesApplied()
	{
		Transform origin = vrcam.origin;
		Quaternion quaternion = ((origin != null) ? origin.rotation : Quaternion.identity);
		base.transform.rotation = quaternion * offset;
	}

	private void OnEnable()
	{
		usingSpeakers = false;
		CVRSettings settings = OpenVR.Settings;
		if (settings != null)
		{
			EVRSettingsError peError = EVRSettingsError.None;
			if (settings.GetBool("steamvr", "usingSpeakers", ref peError))
			{
				usingSpeakers = true;
				float @float = settings.GetFloat("steamvr", "speakersForwardYawOffsetDegrees", ref peError);
				offset = Quaternion.Euler(0f, @float, 0f);
			}
		}
		if (usingSpeakers)
		{
			SteamVR_Events.NewPosesApplied.Listen(OnNewPosesApplied);
		}
	}

	private void OnDisable()
	{
		if (usingSpeakers)
		{
			SteamVR_Events.NewPosesApplied.Remove(OnNewPosesApplied);
		}
	}
}
public static class SteamVR_Events
{
	public abstract class Action
	{
		public bool enabled
		{
			set
			{
				Enable(value);
			}
		}

		public abstract void Enable(bool enabled);
	}

	[Serializable]
	public class ActionNoArgs : Action
	{
		private Event _event;

		private UnityAction action;

		public ActionNoArgs(Event _event, UnityAction action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T> : Action
	{
		private Event<T> _event;

		private UnityAction<T> action;

		public Action(Event<T> _event, UnityAction<T> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T0, T1> : Action
	{
		private Event<T0, T1> _event;

		private UnityAction<T0, T1> action;

		public Action(Event<T0, T1> _event, UnityAction<T0, T1> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T0, T1, T2> : Action
	{
		private Event<T0, T1, T2> _event;

		private UnityAction<T0, T1, T2> action;

		public Action(Event<T0, T1, T2> _event, UnityAction<T0, T1, T2> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	public class Event : UnityEvent
	{
		public void Listen(UnityAction action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction action)
		{
			RemoveListener(action);
		}

		public void Send()
		{
			Invoke();
		}
	}

	public class Event<T> : UnityEvent<T>
	{
		public void Listen(UnityAction<T> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T> action)
		{
			RemoveListener(action);
		}

		public void Send(T arg0)
		{
			Invoke(arg0);
		}
	}

	public class Event<T0, T1> : UnityEvent<T0, T1>
	{
		public void Listen(UnityAction<T0, T1> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T0, T1> action)
		{
			RemoveListener(action);
		}

		public void Send(T0 arg0, T1 arg1)
		{
			Invoke(arg0, arg1);
		}
	}

	public class Event<T0, T1, T2> : UnityEvent<T0, T1, T2>
	{
		public void Listen(UnityAction<T0, T1, T2> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T0, T1, T2> action)
		{
			RemoveListener(action);
		}

		public void Send(T0 arg0, T1 arg1, T2 arg2)
		{
			Invoke(arg0, arg1, arg2);
		}
	}

	public static Event<bool> Calibrating = new Event<bool>();

	public static Event<int, bool> DeviceConnected = new Event<int, bool>();

	public static Event<Color, float, bool> Fade = new Event<Color, float, bool>();

	public static Event FadeReady = new Event();

	public static Event<bool> HideRenderModels = new Event<bool>();

	public static Event<bool> Initializing = new Event<bool>();

	public static Event<bool> InputFocus = new Event<bool>();

	public static Event<bool> Loading = new Event<bool>();

	public static Event<float> LoadingFadeIn = new Event<float>();

	public static Event<float> LoadingFadeOut = new Event<float>();

	public static Event<TrackedDevicePose_t[]> NewPoses = new Event<TrackedDevicePose_t[]>();

	public static Event NewPosesApplied = new Event();

	public static Event<bool> OutOfRange = new Event<bool>();

	public static Event<SteamVR_RenderModel, bool> RenderModelLoaded = new Event<SteamVR_RenderModel, bool>();

	private static Dictionary<EVREventType, Event<VREvent_t>> systemEvents = new Dictionary<EVREventType, Event<VREvent_t>>();

	public static Action CalibratingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Calibrating, action);
	}

	public static Action DeviceConnectedAction(UnityAction<int, bool> action)
	{
		return new Action<int, bool>(DeviceConnected, action);
	}

	public static Action FadeAction(UnityAction<Color, float, bool> action)
	{
		return new Action<Color, float, bool>(Fade, action);
	}

	public static Action FadeReadyAction(UnityAction action)
	{
		return new ActionNoArgs(FadeReady, action);
	}

	public static Action HideRenderModelsAction(UnityAction<bool> action)
	{
		return new Action<bool>(HideRenderModels, action);
	}

	public static Action InitializingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Initializing, action);
	}

	public static Action InputFocusAction(UnityAction<bool> action)
	{
		return new Action<bool>(InputFocus, action);
	}

	public static Action LoadingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Loading, action);
	}

	public static Action LoadingFadeInAction(UnityAction<float> action)
	{
		return new Action<float>(LoadingFadeIn, action);
	}

	public static Action LoadingFadeOutAction(UnityAction<float> action)
	{
		return new Action<float>(LoadingFadeOut, action);
	}

	public static Action NewPosesAction(UnityAction<TrackedDevicePose_t[]> action)
	{
		return new Action<TrackedDevicePose_t[]>(NewPoses, action);
	}

	public static Action NewPosesAppliedAction(UnityAction action)
	{
		return new ActionNoArgs(NewPosesApplied, action);
	}

	public static Action OutOfRangeAction(UnityAction<bool> action)
	{
		return new Action<bool>(OutOfRange, action);
	}

	public static Action RenderModelLoadedAction(UnityAction<SteamVR_RenderModel, bool> action)
	{
		return new Action<SteamVR_RenderModel, bool>(RenderModelLoaded, action);
	}

	public static Event<VREvent_t> System(EVREventType eventType)
	{
		if (!systemEvents.TryGetValue(eventType, out var value))
		{
			value = new Event<VREvent_t>();
			systemEvents.Add(eventType, value);
		}
		return value;
	}

	public static Action SystemAction(EVREventType eventType, UnityAction<VREvent_t> action)
	{
		return new Action<VREvent_t>(System(eventType), action);
	}
}
public class SteamVR_ExternalCamera : MonoBehaviour
{
	[Serializable]
	public struct Config
	{
		public float x;

		public float y;

		public float z;

		public float rx;

		public float ry;

		public float rz;

		public float fov;

		public float near;

		public float far;

		public float sceneResolutionScale;

		public float frameSkip;

		public float nearOffset;

		public float farOffset;

		public float hmdOffset;

		public float r;

		public float g;

		public float b;

		public float a;

		public bool disableStandardAssets;
	}

	public Config config;

	public string configPath;

	private FileSystemWatcher watcher;

	private Camera cam;

	private Transform target;

	private GameObject clipQuad;

	private Material clipMaterial;

	private Material colorMat;

	private Material alphaMat;

	private Camera[] cameras;

	private Rect[] cameraRects;

	private float sceneResolutionScale;

	public void ReadConfig()
	{
		try
		{
			HmdMatrix34_t pose = default(HmdMatrix34_t);
			bool flag = false;
			object obj = config;
			string[] array = File.ReadAllLines(configPath);
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split('=');
				if (array2.Length != 2)
				{
					continue;
				}
				string text = array2[0];
				if (text == "m")
				{
					string[] array3 = array2[1].Split(',');
					if (array3.Length == 12)
					{
						pose.m0 = float.Parse(array3[0]);
						pose.m1 = float.Parse(array3[1]);
						pose.m2 = float.Parse(array3[2]);
						pose.m3 = float.Parse(array3[3]);
						pose.m4 = float.Parse(array3[4]);
						pose.m5 = float.Parse(array3[5]);
						pose.m6 = float.Parse(array3[6]);
						pose.m7 = float.Parse(array3[7]);
						pose.m8 = float.Parse(array3[8]);
						pose.m9 = float.Parse(array3[9]);
						pose.m10 = float.Parse(array3[10]);
						pose.m11 = float.Parse(array3[11]);
						flag = true;
					}
				}
				else if (text == "disableStandardAssets")
				{
					FieldInfo field = obj.GetType().GetField(text);
					if (field != null)
					{
						field.SetValue(obj, bool.Parse(array2[1]));
					}
				}
				else
				{
					FieldInfo field2 = obj.GetType().GetField(text);
					if (field2 != null)
					{
						field2.SetValue(obj, float.Parse(array2[1]));
					}
				}
			}
			config = (Config)obj;
			if (flag)
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(pose);
				config.x = rigidTransform.pos.x;
				config.y = rigidTransform.pos.y;
				config.z = rigidTransform.pos.z;
				Vector3 eulerAngles = rigidTransform.rot.eulerAngles;
				config.rx = eulerAngles.x;
				config.ry = eulerAngles.y;
				config.rz = eulerAngles.z;
			}
		}
		catch
		{
		}
		target = null;
		if (watcher == null)
		{
			FileInfo fileInfo = new FileInfo(configPath);
			watcher = new FileSystemWatcher(fileInfo.DirectoryName, fileInfo.Name);
			watcher.NotifyFilter = NotifyFilters.LastWrite;
			watcher.Changed += OnChanged;
			watcher.EnableRaisingEvents = true;
		}
	}

	private void OnChanged(object source, FileSystemEventArgs e)
	{
		ReadConfig();
	}

	public void AttachToCamera(SteamVR_Camera vrcam)
	{
		if (!(target == vrcam.head))
		{
			target = vrcam.head;
			Transform parent = base.transform.parent;
			Transform parent2 = vrcam.head.parent;
			parent.parent = parent2;
			parent.localPosition = Vector3.zero;
			parent.localRotation = Quaternion.identity;
			parent.localScale = Vector3.one;
			vrcam.enabled = false;
			GameObject gameObject = UnityEngine.Object.Instantiate(vrcam.gameObject);
			vrcam.enabled = true;
			gameObject.name = "camera";
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<SteamVR_Camera>());
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<SteamVR_Fade>());
			cam = gameObject.GetComponent<Camera>();
			cam.stereoTargetEye = StereoTargetEyeMask.None;
			cam.fieldOfView = config.fov;
			cam.useOcclusionCulling = false;
			cam.enabled = false;
			colorMat = new Material(Shader.Find("Custom/SteamVR_ColorOut"));
			alphaMat = new Material(Shader.Find("Custom/SteamVR_AlphaOut"));
			clipMaterial = new Material(Shader.Find("Custom/SteamVR_ClearAll"));
			Transform transform = gameObject.transform;
			transform.parent = base.transform;
			transform.localPosition = new Vector3(config.x, config.y, config.z);
			transform.localRotation = Quaternion.Euler(config.rx, config.ry, config.rz);
			transform.localScale = Vector3.one;
			while (transform.childCount > 0)
			{
				UnityEngine.Object.DestroyImmediate(transform.GetChild(0).gameObject);
			}
			clipQuad = GameObject.CreatePrimitive(PrimitiveType.Quad);
			clipQuad.name = "ClipQuad";
			UnityEngine.Object.DestroyImmediate(clipQuad.GetComponent<MeshCollider>());
			MeshRenderer component = clipQuad.GetComponent<MeshRenderer>();
			component.material = clipMaterial;
			component.shadowCastingMode = ShadowCastingMode.Off;
			component.receiveShadows = false;
			component.lightProbeUsage = LightProbeUsage.Off;
			component.reflectionProbeUsage = ReflectionProbeUsage.Off;
			Transform obj = clipQuad.transform;
			obj.parent = transform;
			obj.localScale = new Vector3(1000f, 1000f, 1f);
			obj.localRotation = Quaternion.identity;
			clipQuad.SetActive(value: false);
		}
	}

	public float GetTargetDistance()
	{
		if (target == null)
		{
			return config.near + 0.01f;
		}
		Transform transform = cam.transform;
		Vector3 normalized = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
		Vector3 inPoint = target.position + new Vector3(target.forward.x, 0f, target.forward.z).normalized * config.hmdOffset;
		return Mathf.Clamp(0f - new Plane(normalized, inPoint).GetDistanceToPoint(transform.position), config.near + 0.01f, config.far - 0.01f);
	}

	public void RenderNear()
	{
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		if (cam.targetTexture == null || cam.targetTexture.width != num || cam.targetTexture.height != num2)
		{
			RenderTexture renderTexture = new RenderTexture(num, num2, 24, RenderTextureFormat.ARGB32);
			renderTexture.antiAliasing = ((QualitySettings.antiAliasing == 0) ? 1 : QualitySettings.antiAliasing);
			cam.targetTexture = renderTexture;
		}
		cam.nearClipPlane = config.near;
		cam.farClipPlane = config.far;
		CameraClearFlags clearFlags = cam.clearFlags;
		Color backgroundColor = cam.backgroundColor;
		cam.clearFlags = CameraClearFlags.Color;
		cam.backgroundColor = Color.clear;
		clipMaterial.color = new Color(config.r, config.g, config.b, config.a);
		float num3 = Mathf.Clamp(GetTargetDistance() + config.nearOffset, config.near, config.far);
		Transform parent = clipQuad.transform.parent;
		clipQuad.transform.position = parent.position + parent.forward * num3;
		MonoBehaviour[] array = null;
		bool[] array2 = null;
		if (config.disableStandardAssets)
		{
			array = cam.gameObject.GetComponents<MonoBehaviour>();
			array2 = new bool[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				MonoBehaviour monoBehaviour = array[i];
				if (monoBehaviour.enabled && monoBehaviour.GetType().ToString().StartsWith("UnityStandardAssets."))
				{
					monoBehaviour.enabled = false;
					array2[i] = true;
				}
			}
		}
		clipQuad.SetActive(value: true);
		cam.Render();
		Graphics.DrawTexture(new Rect(0f, 0f, num, num2), cam.targetTexture, colorMat);
		MonoBehaviour monoBehaviour2 = cam.gameObject.GetComponent("PostProcessingBehaviour") as MonoBehaviour;
		if (monoBehaviour2 != null && monoBehaviour2.enabled)
		{
			monoBehaviour2.enabled = false;
			cam.Render();
			monoBehaviour2.enabled = true;
		}
		Graphics.DrawTexture(new Rect(num, 0f, num, num2), cam.targetTexture, alphaMat);
		clipQuad.SetActive(value: false);
		if (array != null)
		{
			for (int j = 0; j < array.Length; j++)
			{
				if (array2[j])
				{
					array[j].enabled = true;
				}
			}
		}
		cam.clearFlags = clearFlags;
		cam.backgroundColor = backgroundColor;
	}

	public void RenderFar()
	{
		cam.nearClipPlane = config.near;
		cam.farClipPlane = config.far;
		cam.Render();
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		Graphics.DrawTexture(new Rect(0f, num2, num, num2), cam.targetTexture, colorMat);
	}

	private void OnGUI()
	{
	}

	private void OnEnable()
	{
		cameras = UnityEngine.Object.FindObjectsOfType<Camera>();
		if (cameras != null)
		{
			int num = cameras.Length;
			cameraRects = new Rect[num];
			for (int i = 0; i < num; i++)
			{
				Camera camera = cameras[i];
				cameraRects[i] = camera.rect;
				if (!(camera == cam) && !(camera.targetTexture != null) && !(camera.GetComponent<SteamVR_Camera>() != null))
				{
					camera.rect = new Rect(0.5f, 0f, 0.5f, 0.5f);
				}
			}
		}
		if (config.sceneResolutionScale > 0f)
		{
			sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
			SteamVR_Camera.sceneResolutionScale = config.sceneResolutionScale;
		}
	}

	private void OnDisable()
	{
		if (cameras != null)
		{
			int num = cameras.Length;
			for (int i = 0; i < num; i++)
			{
				Camera camera = cameras[i];
				if (camera != null)
				{
					camera.rect = cameraRects[i];
				}
			}
			cameras = null;
			cameraRects = null;
		}
		if (config.sceneResolutionScale > 0f)
		{
			SteamVR_Camera.sceneResolutionScale = sceneResolutionScale;
		}
	}
}
public class SteamVR_Fade : MonoBehaviour
{
	private Color currentColor = new Color(0f, 0f, 0f, 0f);

	private Color targetColor = new Color(0f, 0f, 0f, 0f);

	private Color deltaColor = new Color(0f, 0f, 0f, 0f);

	private bool fadeOverlay;

	private static Material fadeMaterial = null;

	private static int fadeMaterialColorID = -1;

	public static void Start(Color newColor, float duration, bool fadeOverlay = false)
	{
		SteamVR_Events.Fade.Send(newColor, duration, fadeOverlay);
	}

	public static void View(Color newColor, float duration)
	{
		OpenVR.Compositor?.FadeToColor(duration, newColor.r, newColor.g, newColor.b, newColor.a, bBackground: false);
	}

	public void OnStartFade(Color newColor, float duration, bool fadeOverlay)
	{
		if (duration > 0f)
		{
			targetColor = newColor;
			deltaColor = (targetColor - currentColor) / duration;
		}
		else
		{
			currentColor = newColor;
		}
	}

	private void OnEnable()
	{
		if (fadeMaterial == null)
		{
			fadeMaterial = new Material(Shader.Find("Custom/SteamVR_Fade"));
			fadeMaterialColorID = Shader.PropertyToID("fadeColor");
		}
		SteamVR_Events.Fade.Listen(OnStartFade);
		SteamVR_Events.FadeReady.Send();
	}

	private void OnDisable()
	{
		SteamVR_Events.Fade.Remove(OnStartFade);
	}

	private void OnPostRender()
	{
		if (currentColor != targetColor)
		{
			if (Mathf.Abs(currentColor.a - targetColor.a) < Mathf.Abs(deltaColor.a) * Time.deltaTime)
			{
				currentColor = targetColor;
				deltaColor = new Color(0f, 0f, 0f, 0f);
			}
			else
			{
				currentColor += deltaColor * Time.deltaTime;
			}
			if (fadeOverlay)
			{
				SteamVR_Overlay instance = SteamVR_Overlay.instance;
				if (instance != null)
				{
					instance.alpha = 1f - currentColor.a;
				}
			}
		}
		if (currentColor.a > 0f && (bool)fadeMaterial)
		{
			fadeMaterial.SetColor(fadeMaterialColorID, currentColor);
			fadeMaterial.SetPass(0);
			GL.Begin(7);
			GL.Vertex3(-1f, -1f, 0f);
			GL.Vertex3(1f, -1f, 0f);
			GL.Vertex3(1f, 1f, 0f);
			GL.Vertex3(-1f, 1f, 0f);
			GL.End();
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class SteamVR_Frustum : MonoBehaviour
{
	public SteamVR_TrackedObject.EIndex index;

	public float fovLeft = 45f;

	public float fovRight = 45f;

	public float fovTop = 45f;

	public float fovBottom = 45f;

	public float nearZ = 0.5f;

	public float farZ = 2.5f;

	public void UpdateModel()
	{
		fovLeft = Mathf.Clamp(fovLeft, 1f, 89f);
		fovRight = Mathf.Clamp(fovRight, 1f, 89f);
		fovTop = Mathf.Clamp(fovTop, 1f, 89f);
		fovBottom = Mathf.Clamp(fovBottom, 1f, 89f);
		farZ = Mathf.Max(farZ, nearZ + 0.01f);
		nearZ = Mathf.Clamp(nearZ, 0.01f, farZ - 0.01f);
		float num = Mathf.Sin((0f - fovLeft) * ((float)Math.PI / 180f));
		float num2 = Mathf.Sin(fovRight * ((float)Math.PI / 180f));
		float num3 = Mathf.Sin(fovTop * ((float)Math.PI / 180f));
		float num4 = Mathf.Sin((0f - fovBottom) * ((float)Math.PI / 180f));
		float num5 = Mathf.Cos((0f - fovLeft) * ((float)Math.PI / 180f));
		float num6 = Mathf.Cos(fovRight * ((float)Math.PI / 180f));
		float num7 = Mathf.Cos(fovTop * ((float)Math.PI / 180f));
		float num8 = Mathf.Cos((0f - fovBottom) * ((float)Math.PI / 180f));
		Vector3[] array = new Vector3[8]
		{
			new Vector3(num * nearZ / num5, num3 * nearZ / num7, nearZ),
			new Vector3(num2 * nearZ / num6, num3 * nearZ / num7, nearZ),
			new Vector3(num2 * nearZ / num6, num4 * nearZ / num8, nearZ),
			new Vector3(num * nearZ / num5, num4 * nearZ / num8, nearZ),
			new Vector3(num * farZ / num5, num3 * farZ / num7, farZ),
			new Vector3(num2 * farZ / num6, num3 * farZ / num7, farZ),
			new Vector3(num2 * farZ / num6, num4 * farZ / num8, farZ),
			new Vector3(num * farZ / num5, num4 * farZ / num8, farZ)
		};
		int[] array2 = new int[48]
		{
			0, 4, 7, 0, 7, 3, 0, 7, 4, 0,
			3, 7, 1, 5, 6, 1, 6, 2, 1, 6,
			5, 1, 2, 6, 0, 4, 5, 0, 5, 1,
			0, 5, 4, 0, 1, 5, 2, 3, 7, 2,
			7, 6, 2, 7, 3, 2, 6, 7
		};
		int num9 = 0;
		Vector3[] array3 = new Vector3[array2.Length];
		Vector3[] array4 = new Vector3[array2.Length];
		for (int i = 0; i < array2.Length / 3; i++)
		{
			Vector3 vector = array[array2[i * 3]];
			Vector3 vector2 = array[array2[i * 3 + 1]];
			Vector3 vector3 = array[array2[i * 3 + 2]];
			array4[i * 3 + 2] = (array4[i * 3 + 1] = (array4[i * 3] = Vector3.Cross(vector2 - vector, vector3 - vector).normalized));
			array3[i * 3] = vector;
			array3[i * 3 + 1] = vector2;
			array3[i * 3 + 2] = vector3;
			array2[i * 3] = num9++;
			array2[i * 3 + 1] = num9++;
			array2[i * 3 + 2] = num9++;
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array3;
		mesh.normals = array4;
		mesh.triangles = array2;
		GetComponent<MeshFilter>().mesh = mesh;
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		if (i != (int)index)
		{
			return;
		}
		GetComponent<MeshFilter>().mesh = null;
		if (!connected)
		{
			return;
		}
		CVRSystem system = OpenVR.System;
		if (system != null && system.GetTrackedDeviceClass((uint)i) == ETrackedDeviceClass.TrackingReference)
		{
			ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
			float floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewLeftDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovLeft = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewRightDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovRight = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewTopDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovTop = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewBottomDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovBottom = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_TrackingRangeMinimumMeters_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				nearZ = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_TrackingRangeMaximumMeters_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				farZ = floatTrackedDeviceProperty;
			}
			UpdateModel();
		}
	}

	private void OnEnable()
	{
		GetComponent<MeshFilter>().mesh = null;
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
	}

	private void OnDisable()
	{
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
		GetComponent<MeshFilter>().mesh = null;
	}
}
[ExecuteInEditMode]
public class SteamVR_GameView : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_GameView is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_IK : MonoBehaviour
{
	public Transform target;

	public Transform start;

	public Transform joint;

	public Transform end;

	public Transform poleVector;

	public Transform upVector;

	public float blendPct = 1f;

	[HideInInspector]
	public Transform startXform;

	[HideInInspector]
	public Transform jointXform;

	[HideInInspector]
	public Transform endXform;

	private void LateUpdate()
	{
		if (blendPct < 0.001f)
		{
			return;
		}
		Vector3 worldUp = (upVector ? upVector.up : Vector3.Cross(end.position - start.position, joint.position - start.position).normalized);
		Vector3 position = target.position;
		Quaternion rotation = target.rotation;
		Vector3 result = joint.position;
		Solve(start.position, position, poleVector.position, (joint.position - start.position).magnitude, (end.position - joint.position).magnitude, ref result, out var _, out var up);
		if (!(up == Vector3.zero))
		{
			Vector3 position2 = start.position;
			Vector3 position3 = joint.position;
			Vector3 position4 = end.position;
			Quaternion localRotation = start.localRotation;
			Quaternion localRotation2 = joint.localRotation;
			Quaternion localRotation3 = end.localRotation;
			Transform parent = start.parent;
			Transform parent2 = joint.parent;
			Transform parent3 = end.parent;
			Vector3 localScale = start.localScale;
			Vector3 localScale2 = joint.localScale;
			Vector3 localScale3 = end.localScale;
			if (startXform == null)
			{
				startXform = new GameObject("startXform").transform;
				startXform.parent = base.transform;
			}
			startXform.position = position2;
			startXform.LookAt(joint, worldUp);
			start.parent = startXform;
			if (jointXform == null)
			{
				jointXform = new GameObject("jointXform").transform;
				jointXform.parent = startXform;
			}
			jointXform.position = position3;
			jointXform.LookAt(end, worldUp);
			joint.parent = jointXform;
			if (endXform == null)
			{
				endXform = new GameObject("endXform").transform;
				endXform.parent = jointXform;
			}
			endXform.position = position4;
			end.parent = endXform;
			startXform.LookAt(result, up);
			jointXform.LookAt(position, up);
			endXform.rotation = rotation;
			start.parent = parent;
			joint.parent = parent2;
			end.parent = parent3;
			end.rotation = rotation;
			if (blendPct < 1f)
			{
				start.localRotation = Quaternion.Slerp(localRotation, start.localRotation, blendPct);
				joint.localRotation = Quaternion.Slerp(localRotation2, joint.localRotation, blendPct);
				end.localRotation = Quaternion.Slerp(localRotation3, end.localRotation, blendPct);
			}
			start.localScale = localScale;
			joint.localScale = localScale2;
			end.localScale = localScale3;
		}
	}

	public static bool Solve(Vector3 start, Vector3 end, Vector3 poleVector, float jointDist, float targetDist, ref Vector3 result, out Vector3 forward, out Vector3 up)
	{
		float num = jointDist + targetDist;
		Vector3 vector = end - start;
		Vector3 normalized = (poleVector - start).normalized;
		float magnitude = vector.magnitude;
		result = start;
		if (magnitude < 0.001f)
		{
			result += normalized * jointDist;
			forward = Vector3.Cross(normalized, Vector3.up);
			up = Vector3.Cross(forward, normalized).normalized;
		}
		else
		{
			forward = vector * (1f / magnitude);
			up = Vector3.Cross(forward, normalized).normalized;
			if (magnitude + 0.001f < num)
			{
				float num2 = (num + magnitude) * 0.5f;
				if (num2 > jointDist + 0.001f && num2 > targetDist + 0.001f)
				{
					float num3 = Mathf.Sqrt(num2 * (num2 - jointDist) * (num2 - targetDist) * (num2 - magnitude));
					float num4 = 2f * num3 / magnitude;
					float num5 = Mathf.Sqrt(jointDist * jointDist - num4 * num4);
					Vector3 vector2 = Vector3.Cross(up, forward);
					result += forward * num5 + vector2 * num4;
					return true;
				}
				result += normalized * jointDist;
			}
			else
			{
				result += forward * jointDist;
			}
		}
		return false;
	}
}
public class SteamVR_LoadLevel : MonoBehaviour
{
	private static SteamVR_LoadLevel _active;

	public string levelName;

	public string internalProcessPath;

	public string internalProcessArgs;

	public bool loadAdditive;

	public bool loadAsync = true;

	public Texture loadingScreen;

	public Texture progressBarEmpty;

	public Texture progressBarFull;

	public float loadingScreenWidthInMeters = 6f;

	public float progressBarWidthInMeters = 3f;

	public float loadingScreenDistance;

	public Transform loadingScreenTransform;

	public Transform progressBarTransform;

	public Texture front;

	public Texture back;

	public Texture left;

	public Texture right;

	public Texture top;

	public Texture bottom;

	public Color backgroundColor = Color.black;

	public bool showGrid;

	public float fadeOutTime = 0.5f;

	public float fadeInTime = 0.5f;

	public float postLoadSettleTime;

	public float loadingScreenFadeInTime = 1f;

	public float loadingScreenFadeOutTime = 0.25f;

	private float fadeRate = 1f;

	private float alpha;

	private AsyncOperation async;

	private RenderTexture renderTexture;

	private ulong loadingScreenOverlayHandle;

	private ulong progressBarOverlayHandle;

	public bool autoTriggerOnEnable;

	public static bool loading => _active != null;

	public static float progress
	{
		get
		{
			if (!(_active != null) || _active.async == null)
			{
				return 0f;
			}
			return _active.async.progress;
		}
	}

	public static Texture progressTexture
	{
		get
		{
			if (!(_active != null))
			{
				return null;
			}
			return _active.renderTexture;
		}
	}

	private void OnEnable()
	{
		if (autoTriggerOnEnable)
		{
			Trigger();
		}
	}

	public void Trigger()
	{
		if (!loading && !string.IsNullOrEmpty(levelName))
		{
			StartCoroutine(LoadLevel());
		}
	}

	public static void Begin(string levelName, bool showGrid = false, float fadeOutTime = 0.5f, float r = 0f, float g = 0f, float b = 0f, float a = 1f)
	{
		SteamVR_LoadLevel steamVR_LoadLevel = new GameObject("loader").AddComponent<SteamVR_LoadLevel>();
		steamVR_LoadLevel.levelName = levelName;
		steamVR_LoadLevel.showGrid = showGrid;
		steamVR_LoadLevel.fadeOutTime = fadeOutTime;
		steamVR_LoadLevel.backgroundColor = new Color(r, g, b, a);
		steamVR_LoadLevel.Trigger();
	}

	private void OnGUI()
	{
		if (_active != this || !(progressBarEmpty != null) || !(progressBarFull != null))
		{
			return;
		}
		if (progressBarOverlayHandle == 0L)
		{
			progressBarOverlayHandle = GetOverlayHandle("progressBar", (progressBarTransform != null) ? progressBarTransform : base.transform, progressBarWidthInMeters);
		}
		if (progressBarOverlayHandle != 0L)
		{
			float num = ((async != null) ? async.progress : 0f);
			int width = progressBarFull.width;
			int height = progressBarFull.height;
			if (renderTexture == null)
			{
				renderTexture = new RenderTexture(width, height, 0);
				renderTexture.Create();
			}
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = renderTexture;
			if (Event.current.type == EventType.Repaint)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.clear);
			}
			GUILayout.BeginArea(new Rect(0f, 0f, width, height));
			GUI.DrawTexture(new Rect(0f, 0f, width, height), progressBarEmpty);
			GUI.DrawTextureWithTexCoords(new Rect(0f, 0f, num * (float)width, height), progressBarFull, new Rect(0f, 0f, num, 1f));
			GUILayout.EndArea();
			RenderTexture.active = active;
			CVROverlay overlay = OpenVR.Overlay;
			if (overlay != null)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = renderTexture.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(progressBarOverlayHandle, ref pTexture);
			}
		}
	}

	private void Update()
	{
		if (_active != this)
		{
			return;
		}
		alpha = Mathf.Clamp01(alpha + fadeRate * Time.deltaTime);
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay != null)
		{
			if (loadingScreenOverlayHandle != 0L)
			{
				overlay.SetOverlayAlpha(loadingScreenOverlayHandle, alpha);
			}
			if (progressBarOverlayHandle != 0L)
			{
				overlay.SetOverlayAlpha(progressBarOverlayHandle, alpha);
			}
		}
	}

	private IEnumerator LoadLevel()
	{
		if (loadingScreen != null && loadingScreenDistance > 0f)
		{
			SteamVR_Controller.Device hmd = SteamVR_Controller.Input(0);
			while (!hmd.hasTracking)
			{
				yield return null;
			}
			SteamVR_Utils.RigidTransform rigidTransform = hmd.transform;
			rigidTransform.rot = Quaternion.Euler(0f, rigidTransform.rot.eulerAngles.y, 0f);
			rigidTransform.pos += rigidTransform.rot * new Vector3(0f, 0f, loadingScreenDistance);
			Transform obj = ((loadingScreenTransform != null) ? loadingScreenTransform : base.transform);
			obj.position = rigidTransform.pos;
			obj.rotation = rigidTransform.rot;
		}
		_active = this;
		SteamVR_Events.Loading.Send(arg0: true);
		if (loadingScreenFadeInTime > 0f)
		{
			fadeRate = 1f / loadingScreenFadeInTime;
		}
		else
		{
			alpha = 1f;
		}
		CVROverlay overlay = OpenVR.Overlay;
		if (loadingScreen != null && overlay != null)
		{
			loadingScreenOverlayHandle = GetOverlayHandle("loadingScreen", (loadingScreenTransform != null) ? loadingScreenTransform : base.transform, loadingScreenWidthInMeters);
			if (loadingScreenOverlayHandle != 0L)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = loadingScreen.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(loadingScreenOverlayHandle, ref pTexture);
			}
		}
		bool fadedForeground = false;
		SteamVR_Events.LoadingFadeOut.Send(fadeOutTime);
		CVRCompositor compositor2 = OpenVR.Compositor;
		if (compositor2 != null)
		{
			if (front != null)
			{
				SteamVR_Skybox.SetOverride(front, back, left, right, top, bottom);
				compositor2.FadeGrid(fadeOutTime, bFadeIn: true);
				yield return new WaitForSeconds(fadeOutTime);
			}
			else if (backgroundColor != Color.clear)
			{
				if (showGrid)
				{
					compositor2.FadeToColor(0f, backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a, bBackground: true);
					compositor2.FadeGrid(fadeOutTime, bFadeIn: true);
					yield return new WaitForSeconds(fadeOutTime);
				}
				else
				{
					compositor2.FadeToColor(fadeOutTime, backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a, bBackground: false);
					yield return new WaitForSeconds(fadeOutTime + 0.1f);
					compositor2.FadeGrid(0f, bFadeIn: true);
					fadedForeground = true;
				}
			}
		}
		SteamVR_Render.pauseRendering = true;
		while (alpha < 1f)
		{
			yield return null;
		}
		base.transform.parent = null;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		if (!string.IsNullOrEmpty(internalProcessPath))
		{
			UnityEngine.Debug.Log("Launching external application...");
			CVRApplications applications = OpenVR.Applications;
			if (applications == null)
			{
				UnityEngine.Debug.Log("Failed to get OpenVR.Applications interface!");
			}
			else
			{
				string currentDirectory = Directory.GetCurrentDirectory();
				string text = Path.Combine(currentDirectory, internalProcessPath);
				UnityEngine.Debug.Log("LaunchingInternalProcess");
				UnityEngine.Debug.Log("ExternalAppPath = " + internalProcessPath);
				UnityEngine.Debug.Log("FullPath = " + text);
				UnityEngine.Debug.Log("ExternalAppArgs = " + internalProcessArgs);
				UnityEngine.Debug.Log("WorkingDirectory = " + currentDirectory);
				EVRApplicationError eVRApplicationError = applications.LaunchInternalProcess(text, internalProcessArgs, currentDirectory);
				UnityEngine.Debug.Log("LaunchInternalProcessError: " + eVRApplicationError);
				Process.GetCurrentProcess().Kill();
			}
		}
		else
		{
			LoadSceneMode mode = (loadAdditive ? LoadSceneMode.Additive : LoadSceneMode.Single);
			if (loadAsync)
			{
				UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
				async = SceneManager.LoadSceneAsync(levelName, mode);
				while (!async.isDone)
				{
					yield return null;
				}
			}
			else
			{
				SceneManager.LoadScene(levelName, mode);
			}
		}
		yield return null;
		GC.Collect();
		yield return null;
		yield return new WaitForSeconds(postLoadSettleTime);
		SteamVR_Render.pauseRendering = false;
		if (loadingScreenFadeOutTime > 0f)
		{
			fadeRate = -1f / loadingScreenFadeOutTime;
		}
		else
		{
			alpha = 0f;
		}
		SteamVR_Events.LoadingFadeIn.Send(fadeInTime);
		compositor2 = OpenVR.Compositor;
		if (compositor2 != null)
		{
			if (fadedForeground)
			{
				compositor2.FadeGrid(0f, bFadeIn: false);
				compositor2.FadeToColor(fadeInTime, 0f, 0f, 0f, 0f, bBackground: false);
				yield return new WaitForSeconds(fadeInTime);
			}
			else
			{
				compositor2.FadeGrid(fadeInTime, bFadeIn: false);
				yield return new WaitForSeconds(fadeInTime);
				if (front != null)
				{
					SteamVR_Skybox.ClearOverride();
				}
			}
		}
		while (alpha > 0f)
		{
			yield return null;
		}
		if (overlay != null)
		{
			if (progressBarOverlayHandle != 0L)
			{
				overlay.HideOverlay(progressBarOverlayHandle);
			}
			if (loadingScreenOverlayHandle != 0L)
			{
				overlay.HideOverlay(loadingScreenOverlayHandle);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
		_active = null;
		SteamVR_Events.Loading.Send(arg0: false);
	}

	private ulong GetOverlayHandle(string overlayName, Transform transform, float widthInMeters = 1f)
	{
		ulong pOverlayHandle = 0uL;
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return pOverlayHandle;
		}
		string pchOverlayKey = SteamVR_Overlay.key + "." + overlayName;
		EVROverlayError eVROverlayError = overlay.FindOverlay(pchOverlayKey, ref pOverlayHandle);
		if (eVROverlayError != 0)
		{
			eVROverlayError = overlay.CreateOverlay(pchOverlayKey, overlayName, ref pOverlayHandle);
		}
		if (eVROverlayError == EVROverlayError.None)
		{
			overlay.ShowOverlay(pOverlayHandle);
			overlay.SetOverlayAlpha(pOverlayHandle, alpha);
			overlay.SetOverlayWidthInMeters(pOverlayHandle, widthInMeters);
			if (SteamVR.instance.textureType == ETextureType.DirectX)
			{
				VRTextureBounds_t pOverlayTextureBounds = default(VRTextureBounds_t);
				pOverlayTextureBounds.uMin = 0f;
				pOverlayTextureBounds.vMin = 1f;
				pOverlayTextureBounds.uMax = 1f;
				pOverlayTextureBounds.vMax = 0f;
				overlay.SetOverlayTextureBounds(pOverlayHandle, ref pOverlayTextureBounds);
			}
			SteamVR_Camera steamVR_Camera = ((loadingScreenDistance == 0f) ? SteamVR_Render.Top() : null);
			if (steamVR_Camera != null && steamVR_Camera.origin != null)
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(steamVR_Camera.origin, transform);
				rigidTransform.pos.x /= steamVR_Camera.origin.localScale.x;
				rigidTransform.pos.y /= steamVR_Camera.origin.localScale.y;
				rigidTransform.pos.z /= steamVR_Camera.origin.localScale.z;
				HmdMatrix34_t pmatTrackingOriginToOverlayTransform = rigidTransform.ToHmdMatrix34();
				overlay.SetOverlayTransformAbsolute(pOverlayHandle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform);
			}
			else
			{
				HmdMatrix34_t pmatTrackingOriginToOverlayTransform2 = new SteamVR_Utils.RigidTransform(transform).ToHmdMatrix34();
				overlay.SetOverlayTransformAbsolute(pOverlayHandle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform2);
			}
		}
		return pOverlayHandle;
	}
}
public class SteamVR_Menu : MonoBehaviour
{
	public Texture cursor;

	public Texture background;

	public Texture logo;

	public float logoHeight;

	public float menuOffset;

	public Vector2 scaleLimits = new Vector2(0.1f, 5f);

	public float scaleRate = 0.5f;

	private SteamVR_Overlay overlay;

	private Camera overlayCam;

	private Vector4 uvOffset;

	private float distance;

	private string scaleLimitX;

	private string scaleLimitY;

	private string scaleRateText;

	private CursorLockMode savedCursorLockState;

	private bool savedCursorVisible;

	public RenderTexture texture
	{
		get
		{
			if (!overlay)
			{
				return null;
			}
			return overlay.texture as RenderTexture;
		}
	}

	public float scale { get; private set; }

	private void Awake()
	{
		scaleLimitX = $"{scaleLimits.x:N1}";
		scaleLimitY = $"{scaleLimits.y:N1}";
		scaleRateText = $"{scaleRate:N1}";
		SteamVR_Overlay instance = SteamVR_Overlay.instance;
		if (instance != null)
		{
			uvOffset = instance.uvOffset;
			distance = instance.distance;
		}
	}

	private void OnGUI()
	{
		if (overlay == null)
		{
			return;
		}
		RenderTexture renderTexture = overlay.texture as RenderTexture;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = renderTexture;
		if (Event.current.type == EventType.Repaint)
		{
			GL.Clear(clearDepth: false, clearColor: true, Color.clear);
		}
		Rect screenRect = new Rect(0f, 0f, renderTexture.width, renderTexture.height);
		if (Screen.width < renderTexture.width)
		{
			screenRect.width = Screen.width;
			overlay.uvOffset.x = (0f - (float)(renderTexture.width - Screen.width)) / (float)(2 * renderTexture.width);
		}
		if (Screen.height < renderTexture.height)
		{
			screenRect.height = Screen.height;
			overlay.uvOffset.y = (float)(renderTexture.height - Screen.height) / (float)(2 * renderTexture.height);
		}
		GUILayout.BeginArea(screenRect);
		if (background != null)
		{
			GUI.DrawTexture(new Rect((screenRect.width - (float)background.width) / 2f, (screenRect.height - (float)background.height) / 2f, background.width, background.height), background);
		}
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.BeginVertical();
		if (logo != null)
		{
			GUILayout.Space(screenRect.height / 2f - logoHeight);
			GUILayout.Box(logo);
		}
		GUILayout.Space(menuOffset);
		bool num = GUILayout.Button("[Esc] - Close menu");
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale: {scale:N4}");
		float num2 = GUILayout.HorizontalSlider(scale, scaleLimits.x, scaleLimits.y);
		if (num2 != scale)
		{
			SetScale(num2);
		}
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale limits:");
		string text = GUILayout.TextField(scaleLimitX);
		if (text != scaleLimitX && float.TryParse(text, out scaleLimits.x))
		{
			scaleLimitX = text;
		}
		string text2 = GUILayout.TextField(scaleLimitY);
		if (text2 != scaleLimitY && float.TryParse(text2, out scaleLimits.y))
		{
			scaleLimitY = text2;
		}
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale rate:");
		string text3 = GUILayout.TextField(scaleRateText);
		if (text3 != scaleRateText && float.TryParse(text3, out scaleRate))
		{
			scaleRateText = text3;
		}
		GUILayout.EndHorizontal();
		if (SteamVR.active)
		{
			SteamVR instance = SteamVR.instance;
			GUILayout.BeginHorizontal();
			float sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
			int num3 = (int)(instance.sceneWidth * sceneResolutionScale);
			int num4 = (int)(instance.sceneHeight * sceneResolutionScale);
			int num5 = (int)(100f * sceneResolutionScale);
			GUILayout.Label($"Scene quality: {num3}x{num4} ({num5}%)");
			int num6 = Mathf.RoundToInt(GUILayout.HorizontalSlider(num5, 50f, 200f));
			if (num6 != num5)
			{
				SteamVR_Camera.sceneResolutionScale = (float)num6 / 100f;
			}
			GUILayout.EndHorizontal();
		}
		overlay.highquality = GUILayout.Toggle(overlay.highquality, "High quality");
		if (overlay.highquality)
		{
			overlay.curved = GUILayout.Toggle(overlay.curved, "Curved overlay");
			overlay.antialias = GUILayout.Toggle(overlay.antialias, "Overlay RGSS(2x2)");
		}
		else
		{
			overlay.curved = false;
			overlay.antialias = false;
		}
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			steamVR_Camera.wireframe = GUILayout.Toggle(steamVR_Camera.wireframe, "Wireframe");
			SteamVR_Render instance2 = SteamVR_Render.instance;
			if (instance2.trackingSpace == ETrackingUniverseOrigin.TrackingUniverseSeated)
			{
				if (GUILayout.Button("Switch to Standing"))
				{
					instance2.trackingSpace = ETrackingUniverseOrigin.TrackingUniverseStanding;
				}
				if (GUILayout.Button("Center View"))
				{
					OpenVR.System?.ResetSeatedZeroPose();
				}
			}
			else if (GUILayout.Button("Switch to Seated"))
			{
				instance2.trackingSpace = ETrackingUniverseOrigin.TrackingUniverseSeated;
			}
		}
		if (GUILayout.Button("Exit"))
		{
			UnityEngine.Application.Quit();
		}
		GUILayout.Space(menuOffset);
		string environmentVariable = Environment.GetEnvironmentVariable("VR_OVERRIDE");
		if (environmentVariable != null)
		{
			GUILayout.Label("VR_OVERRIDE=" + environmentVariable);
		}
		GUILayout.Label("Graphics device: " + SystemInfo.graphicsDeviceVersion);
		GUILayout.EndVertical();
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
		if (cursor != null)
		{
			float x = Input.mousePosition.x;
			float y = (float)Screen.height - Input.mousePosition.y;
			float width = cursor.width;
			float height = cursor.height;
			GUI.DrawTexture(new Rect(x, y, width, height), cursor);
		}
		RenderTexture.active = active;
		if (num)
		{
			HideMenu();
		}
	}

	public void ShowMenu()
	{
		SteamVR_Overlay instance = SteamVR_Overlay.instance;
		if (instance == null)
		{
			return;
		}
		RenderTexture renderTexture = instance.texture as RenderTexture;
		if (renderTexture == null)
		{
			UnityEngine.Debug.LogError("Menu requires overlay texture to be a render texture.");
			return;
		}
		SaveCursorState();
		Cursor.visible = true;
		Cursor.lockState = CursorLockMode.None;
		overlay = instance;
		uvOffset = instance.uvOffset;
		distance = instance.distance;
		Camera[] array = UnityEngine.Object.FindObjectsOfType(typeof(Camera)) as Camera[];
		foreach (Camera camera in array)
		{
			if (camera.enabled && camera.targetTexture == renderTexture)
			{
				overlayCam = camera;
				overlayCam.enabled = false;
				break;
			}
		}
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			scale = steamVR_Camera.origin.localScale.x;
		}
	}

	public void HideMenu()
	{
		RestoreCursorState();
		if (overlayCam != null)
		{
			overlayCam.enabled = true;
		}
		if (overlay != null)
		{
			overlay.uvOffset = uvOffset;
			overlay.distance = distance;
			overlay = null;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.Joystick1Button7))
		{
			if (overlay == null)
			{
				ShowMenu();
			}
			else
			{
				HideMenu();
			}
		}
		else if (Input.GetKeyDown(KeyCode.Home))
		{
			SetScale(1f);
		}
		else if (Input.GetKey(KeyCode.PageUp))
		{
			SetScale(Mathf.Clamp(scale + scaleRate * Time.deltaTime, scaleLimits.x, scaleLimits.y));
		}
		else if (Input.GetKey(KeyCode.PageDown))
		{
			SetScale(Mathf.Clamp(scale - scaleRate * Time.deltaTime, scaleLimits.x, scaleLimits.y));
		}
	}

	private void SetScale(float scale)
	{
		this.scale = scale;
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			steamVR_Camera.origin.localScale = new Vector3(scale, scale, scale);
		}
	}

	private void SaveCursorState()
	{
		savedCursorVisible = Cursor.visible;
		savedCursorLockState = Cursor.lockState;
	}

	private void RestoreCursorState()
	{
		Cursor.visible = savedCursorVisible;
		Cursor.lockState = savedCursorLockState;
	}
}
public class SteamVR_Overlay : MonoBehaviour
{
	public struct IntersectionResults
	{
		public Vector3 point;

		public Vector3 normal;

		public Vector2 UVs;

		public float distance;
	}

	public Texture texture;

	public bool curved = true;

	public bool antialias = true;

	public bool highquality = true;

	[Tooltip("Size of overlay view.")]
	public float scale = 3f;

	[Tooltip("Distance from surface.")]
	public float distance = 1.25f;

	[Tooltip("Opacity")]
	[Range(0f, 1f)]
	public float alpha = 1f;

	public Vector4 uvOffset = new Vector4(0f, 0f, 1f, 1f);

	public Vector2 mouseScale = new Vector2(1f, 1f);

	public Vector2 curvedRange = new Vector2(1f, 2f);

	public VROverlayInputMethod inputMethod;

	private ulong handle;

	public static SteamVR_Overlay instance { get; private set; }

	public static string key => "unity:" + UnityEngine.Application.companyName + "." + UnityEngine.Application.productName;

	private void OnEnable()
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay != null)
		{
			EVROverlayError eVROverlayError = overlay.CreateOverlay(key, base.gameObject.name, ref handle);
			if (eVROverlayError != 0)
			{
				UnityEngine.Debug.Log(overlay.GetOverlayErrorNameFromEnum(eVROverlayError));
				base.enabled = false;
				return;
			}
		}
		instance = this;
	}

	private void OnDisable()
	{
		if (handle != 0L)
		{
			OpenVR.Overlay?.DestroyOverlay(handle);
			handle = 0uL;
		}
		instance = null;
	}

	public void UpdateOverlay()
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return;
		}
		if (texture != null)
		{
			EVROverlayError eVROverlayError = overlay.ShowOverlay(handle);
			if ((eVROverlayError != EVROverlayError.InvalidHandle && eVROverlayError != EVROverlayError.UnknownOverlay) || overlay.FindOverlay(key, ref handle) == EVROverlayError.None)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = texture.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(handle, ref pTexture);
				overlay.SetOverlayAlpha(handle, alpha);
				overlay.SetOverlayWidthInMeters(handle, scale);
				overlay.SetOverlayAutoCurveDistanceRangeInMeters(handle, curvedRange.x, curvedRange.y);
				VRTextureBounds_t pOverlayTextureBounds = default(VRTextureBounds_t);
				pOverlayTextureBounds.uMin = (0f + uvOffset.x) * uvOffset.z;
				pOverlayTextureBounds.vMin = (1f + uvOffset.y) * uvOffset.w;
				pOverlayTextureBounds.uMax = (1f + uvOffset.x) * uvOffset.z;
				pOverlayTextureBounds.vMax = (0f + uvOffset.y) * uvOffset.w;
				overlay.SetOverlayTextureBounds(handle, ref pOverlayTextureBounds);
				HmdVector2_t pvecMouseScale = default(HmdVector2_t);
				pvecMouseScale.v0 = mouseScale.x;
				pvecMouseScale.v1 = mouseScale.y;
				overlay.SetOverlayMouseScale(handle, ref pvecMouseScale);
				SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
				if (steamVR_Camera != null && steamVR_Camera.origin != null)
				{
					SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(steamVR_Camera.origin, base.transform);
					rigidTransform.pos.x /= steamVR_Camera.origin.localScale.x;
					rigidTransform.pos.y /= steamVR_Camera.origin.localScale.y;
					rigidTransform.pos.z /= steamVR_Camera.origin.localScale.z;
					rigidTransform.pos.z += distance;
					HmdMatrix34_t pmatTrackingOriginToOverlayTransform = rigidTransform.ToHmdMatrix34();
					overlay.SetOverlayTransformAbsolute(handle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform);
				}
				overlay.SetOverlayInputMethod(handle, inputMethod);
				if (curved || antialias)
				{
					highquality = true;
				}
				if (highquality)
				{
					overlay.SetHighQualityOverlay(handle);
					overlay.SetOverlayFlag(handle, VROverlayFlags.Curved, curved);
					overlay.SetOverlayFlag(handle, VROverlayFlags.RGSS4X, antialias);
				}
				else if (overlay.GetHighQualityOverlay() == handle)
				{
					overlay.SetHighQualityOverlay(0uL);
				}
			}
		}
		else
		{
			overlay.HideOverlay(handle);
		}
	}

	public bool PollNextEvent(ref VREvent_t pEvent)
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return false;
		}
		uint uncbVREvent = (uint)Marshal.SizeOf(typeof(VREvent_t));
		return overlay.PollNextOverlayEvent(handle, ref pEvent, uncbVREvent);
	}

	public bool ComputeIntersection(Vector3 source, Vector3 direction, ref IntersectionResults results)
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return false;
		}
		VROverlayIntersectionParams_t pParams = default(VROverlayIntersectionParams_t);
		pParams.eOrigin = SteamVR_Render.instance.trackingSpace;
		pParams.vSource.v0 = source.x;
		pParams.vSource.v1 = source.y;
		pParams.vSource.v2 = 0f - source.z;
		pParams.vDirection.v0 = direction.x;
		pParams.vDirection.v1 = direction.y;
		pParams.vDirection.v2 = 0f - direction.z;
		VROverlayIntersectionResults_t pResults = default(VROverlayIntersectionResults_t);
		if (!overlay.ComputeOverlayIntersection(handle, ref pParams, ref pResults))
		{
			return false;
		}
		results.point = new Vector3(pResults.vPoint.v0, pResults.vPoint.v1, 0f - pResults.vPoint.v2);
		results.normal = new Vector3(pResults.vNormal.v0, pResults.vNormal.v1, 0f - pResults.vNormal.v2);
		results.UVs = new Vector2(pResults.vUVs.v0, pResults.vUVs.v1);
		results.distance = pResults.fDistance;
		return true;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class SteamVR_PlayArea : MonoBehaviour
{
	public enum Size
	{
		Calibrated,
		_400x300,
		_300x225,
		_200x150
	}

	public float borderThickness = 0.15f;

	public float wireframeHeight = 2f;

	public bool drawWireframeWhenSelectedOnly;

	public bool drawInGame = true;

	public Size size;

	public Color color = Color.cyan;

	[HideInInspector]
	public Vector3[] vertices;

	public static bool GetBounds(Size size, ref HmdQuad_t pRect)
	{
		bool flag;
		int num;
		if (size == Size.Calibrated)
		{
			flag = !SteamVR.active && !SteamVR.usingNativeSupport;
			if (flag)
			{
				EVRInitError peError = EVRInitError.None;
				OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
			}
			CVRChaperone chaperone = OpenVR.Chaperone;
			if (chaperone != null)
			{
				num = (chaperone.GetPlayAreaRect(ref pRect) ? 1 : 0);
				if (num != 0)
				{
					goto IL_0044;
				}
			}
			else
			{
				num = 0;
			}
			UnityEngine.Debug.LogWarning("Failed to get Calibrated Play Area bounds!  Make sure you have tracking first, and that your space is calibrated.");
			goto IL_0044;
		}
		try
		{
			string[] array = size.ToString().Substring(1).Split(new char[1] { 'x' }, 2);
			float num2 = float.Parse(array[0]) / 200f;
			float num3 = float.Parse(array[1]) / 200f;
			pRect.vCorners0.v0 = num2;
			pRect.vCorners0.v1 = 0f;
			pRect.vCorners0.v2 = 0f - num3;
			pRect.vCorners1.v0 = 0f - num2;
			pRect.vCorners1.v1 = 0f;
			pRect.vCorners1.v2 = 0f - num3;
			pRect.vCorners2.v0 = 0f - num2;
			pRect.vCorners2.v1 = 0f;
			pRect.vCorners2.v2 = num3;
			pRect.vCorners3.v0 = num2;
			pRect.vCorners3.v1 = 0f;
			pRect.vCorners3.v2 = num3;
			return true;
		}
		catch
		{
		}
		return false;
		IL_0044:
		if (flag)
		{
			OpenVR.Shutdown();
		}
		return (byte)num != 0;
	}

	public void BuildMesh()
	{
		HmdQuad_t pRect = default(HmdQuad_t);
		if (!GetBounds(size, ref pRect))
		{
			return;
		}
		HmdVector3_t[] array = new HmdVector3_t[4] { pRect.vCorners0, pRect.vCorners1, pRect.vCorners2, pRect.vCorners3 };
		vertices = new Vector3[array.Length * 2];
		for (int i = 0; i < array.Length; i++)
		{
			HmdVector3_t hmdVector3_t = array[i];
			vertices[i] = new Vector3(hmdVector3_t.v0, 0.01f, hmdVector3_t.v2);
		}
		if (borderThickness == 0f)
		{
			GetComponent<MeshFilter>().mesh = null;
			return;
		}
		for (int j = 0; j < array.Length; j++)
		{
			int num = (j + 1) % array.Length;
			int num2 = (j + array.Length - 1) % array.Length;
			Vector3 normalized = (vertices[num] - vertices[j]).normalized;
			Vector3 normalized2 = (vertices[num2] - vertices[j]).normalized;
			Vector3 vector = vertices[j];
			vector += Vector3.Cross(normalized, Vector3.up) * borderThickness;
			vector += Vector3.Cross(normalized2, Vector3.down) * borderThickness;
			vertices[array.Length + j] = vector;
		}
		int[] triangles = new int[24]
		{
			0, 4, 1, 1, 4, 5, 1, 5, 2, 2,
			5, 6, 2, 6, 3, 3, 6, 7, 3, 7,
			0, 0, 7, 4
		};
		Vector2[] uv = new Vector2[8]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
		Color[] colors = new Color[8]
		{
			color,
			color,
			color,
			color,
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f)
		};
		Mesh mesh = new Mesh();
		GetComponent<MeshFilter>().mesh = mesh;
		mesh.vertices = vertices;
		mesh.uv = uv;
		mesh.colors = colors;
		mesh.triangles = triangles;
		MeshRenderer component = GetComponent<MeshRenderer>();
		component.material = new Material(Shader.Find("Sprites/Default"));
		component.reflectionProbeUsage = ReflectionProbeUsage.Off;
		component.shadowCastingMode = ShadowCastingMode.Off;
		component.receiveShadows = false;
		component.lightProbeUsage = LightProbeUsage.Off;
	}

	private void OnDrawGizmos()
	{
		if (!drawWireframeWhenSelectedOnly)
		{
			DrawWireframe();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (drawWireframeWhenSelectedOnly)
		{
			DrawWireframe();
		}
	}

	public void DrawWireframe()
	{
		if (vertices != null && vertices.Length != 0)
		{
			Vector3 vector = base.transform.TransformVector(Vector3.up * wireframeHeight);
			for (int i = 0; i < 4; i++)
			{
				int num = (i + 1) % 4;
				Vector3 vector2 = base.transform.TransformPoint(vertices[i]);
				Vector3 vector3 = vector2 + vector;
				Vector3 vector4 = base.transform.TransformPoint(vertices[num]);
				Vector3 to = vector4 + vector;
				Gizmos.DrawLine(vector2, vector3);
				Gizmos.DrawLine(vector2, vector4);
				Gizmos.DrawLine(vector3, to);
			}
		}
	}

	public void OnEnable()
	{
		if (UnityEngine.Application.isPlaying)
		{
			GetComponent<MeshRenderer>().enabled = drawInGame;
			base.enabled = false;
			if (drawInGame && size == Size.Calibrated)
			{
				StartCoroutine(UpdateBounds());
			}
		}
	}

	private IEnumerator UpdateBounds()
	{
		GetComponent<MeshFilter>().mesh = null;
		CVRChaperone chaperone = OpenVR.Chaperone;
		if (chaperone != null)
		{
			while (chaperone.GetCalibrationState() != ChaperoneCalibrationState.OK)
			{
				yield return null;
			}
			BuildMesh();
		}
	}
}
public class SteamVR_Render : MonoBehaviour
{
	public bool pauseGameWhenDashboardIsVisible = true;

	public bool lockPhysicsUpdateRateToRenderFrequency = true;

	public SteamVR_ExternalCamera externalCamera;

	public string externalCameraConfigPath = "externalcamera-legacy.cfg";

	public ETrackingUniverseOrigin trackingSpace = ETrackingUniverseOrigin.TrackingUniverseStanding;

	private static SteamVR_Render _instance;

	private static bool isQuitting;

	private SteamVR_Camera[] cameras = new SteamVR_Camera[0];

	public TrackedDevicePose_t[] poses = new TrackedDevicePose_t[64];

	public TrackedDevicePose_t[] gamePoses = new TrackedDevicePose_t[0];

	private static bool _pauseRendering;

	private WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

	private float sceneResolutionScale = 1f;

	private float timeScale = 1f;

	public static EVREye eye { get; private set; }

	public static SteamVR_Render instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<SteamVR_Render>();
				if (_instance == null)
				{
					_instance = new GameObject("[SteamVR]").AddComponent<SteamVR_Render>();
				}
			}
			return _instance;
		}
	}

	public static bool pauseRendering
	{
		get
		{
			return _pauseRendering;
		}
		set
		{
			_pauseRendering = value;
			OpenVR.Compositor?.SuspendRendering(value);
		}
	}

	private void OnDestroy()
	{
		_instance = null;
	}

	private void OnApplicationQuit()
	{
		isQuitting = true;
		SteamVR.SafeDispose();
	}

	public static void Add(SteamVR_Camera vrcam)
	{
		if (!isQuitting)
		{
			instance.AddInternal(vrcam);
		}
	}

	public static void Remove(SteamVR_Camera vrcam)
	{
		if (!isQuitting && _instance != null)
		{
			instance.RemoveInternal(vrcam);
		}
	}

	public static SteamVR_Camera Top()
	{
		if (!isQuitting)
		{
			return instance.TopInternal();
		}
		return null;
	}

	private void AddInternal(SteamVR_Camera vrcam)
	{
		Camera component = vrcam.GetComponent<Camera>();
		int num = cameras.Length;
		SteamVR_Camera[] array = new SteamVR_Camera[num + 1];
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			Camera component2 = cameras[i].GetComponent<Camera>();
			if (i == num2 && component2.depth > component.depth)
			{
				array[num2++] = vrcam;
			}
			array[num2++] = cameras[i];
		}
		if (num2 == num)
		{
			array[num2] = vrcam;
		}
		cameras = array;
	}

	private void RemoveInternal(SteamVR_Camera vrcam)
	{
		int num = cameras.Length;
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			if (cameras[i] == vrcam)
			{
				num2++;
			}
		}
		if (num2 == 0)
		{
			return;
		}
		SteamVR_Camera[] array = new SteamVR_Camera[num - num2];
		int num3 = 0;
		for (int j = 0; j < num; j++)
		{
			SteamVR_Camera steamVR_Camera = cameras[j];
			if (steamVR_Camera != vrcam)
			{
				array[num3++] = steamVR_Camera;
			}
		}
		cameras = array;
	}

	private SteamVR_Camera TopInternal()
	{
		if (cameras.Length != 0)
		{
			return cameras[cameras.Length - 1];
		}
		return null;
	}

	private IEnumerator RenderLoop()
	{
		while (UnityEngine.Application.isPlaying)
		{
			yield return waitForEndOfFrame;
			if (pauseRendering)
			{
				continue;
			}
			CVRCompositor compositor = OpenVR.Compositor;
			if (compositor != null)
			{
				if (!compositor.CanRenderScene())
				{
					continue;
				}
				compositor.SetTrackingSpace(trackingSpace);
			}
			SteamVR_Overlay steamVR_Overlay = SteamVR_Overlay.instance;
			if (steamVR_Overlay != null)
			{
				steamVR_Overlay.UpdateOverlay();
			}
			RenderExternalCamera();
		}
	}

	private void RenderExternalCamera()
	{
		if (!(externalCamera == null) && externalCamera.gameObject.activeInHierarchy)
		{
			int num = (int)Mathf.Max(externalCamera.config.frameSkip, 0f);
			if (Time.frameCount % (num + 1) == 0)
			{
				externalCamera.AttachToCamera(TopInternal());
				externalCamera.RenderNear();
				externalCamera.RenderFar();
			}
		}
	}

	private void OnInputFocus(bool hasFocus)
	{
		if (hasFocus)
		{
			if (pauseGameWhenDashboardIsVisible)
			{
				Time.timeScale = timeScale;
			}
			SteamVR_Camera.sceneResolutionScale = sceneResolutionScale;
			return;
		}
		if (pauseGameWhenDashboardIsVisible)
		{
			timeScale = Time.timeScale;
			Time.timeScale = 0f;
		}
		sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
		SteamVR_Camera.sceneResolutionScale = 0.5f;
	}

	private void OnQuit(VREvent_t vrEvent)
	{
		UnityEngine.Application.Quit();
	}

	private string GetScreenshotFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames screenshotPropertyFilename)
	{
		EVRScreenshotError pError = EVRScreenshotError.None;
		uint screenshotPropertyFilename2 = OpenVR.Screenshots.GetScreenshotPropertyFilename(screenshotHandle, screenshotPropertyFilename, null, 0u, ref pError);
		if (pError != 0 && pError != EVRScreenshotError.BufferTooSmall)
		{
			return null;
		}
		if (screenshotPropertyFilename2 > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)screenshotPropertyFilename2);
			OpenVR.Screenshots.GetScreenshotPropertyFilename(screenshotHandle, screenshotPropertyFilename, stringBuilder, screenshotPropertyFilename2, ref pError);
			if (pError != 0)
			{
				return null;
			}
			return stringBuilder.ToString();
		}
		return null;
	}

	private void OnRequestScreenshot(VREvent_t vrEvent)
	{
		uint handle = vrEvent.data.screenshot.handle;
		EVRScreenshotType type = (EVRScreenshotType)vrEvent.data.screenshot.type;
		if (type == EVRScreenshotType.StereoPanorama)
		{
			string previewFilename = GetScreenshotFilename(handle, EVRScreenshotPropertyFilenames.Preview);
			string VRFilename = GetScreenshotFilename(handle, EVRScreenshotPropertyFilenames.VR);
			if (previewFilename != null && VRFilename != null)
			{
				GameObject gameObject = new GameObject("screenshotPosition");
				gameObject.transform.position = Top().transform.position;
				gameObject.transform.rotation = Top().transform.rotation;
				gameObject.transform.localScale = Top().transform.lossyScale;
				SteamVR_Utils.TakeStereoScreenshot(handle, gameObject, 32, 0.064f, ref previewFilename, ref VRFilename);
				OpenVR.Screenshots.SubmitScreenshot(handle, type, previewFilename, VRFilename);
			}
		}
	}

	private void OnEnable()
	{
		StartCoroutine(RenderLoop());
		SteamVR_Events.InputFocus.Listen(OnInputFocus);
		SteamVR_Events.System(EVREventType.VREvent_Quit).Listen(OnQuit);
		SteamVR_Events.System(EVREventType.VREvent_RequestScreenshot).Listen(OnRequestScreenshot);
		UnityEngine.Application.onBeforeRender += OnBeforeRender;
		if (SteamVR.instance == null)
		{
			base.enabled = false;
			return;
		}
		EVRScreenshotType[] pSupportedTypes = new EVRScreenshotType[1] { EVRScreenshotType.StereoPanorama };
		OpenVR.Screenshots.HookScreenshot(pSupportedTypes);
	}

	private void OnDisable()
	{
		StopAllCoroutines();
		SteamVR_Events.InputFocus.Remove(OnInputFocus);
		SteamVR_Events.System(EVREventType.VREvent_Quit).Remove(OnQuit);
		SteamVR_Events.System(EVREventType.VREvent_RequestScreenshot).Remove(OnRequestScreenshot);
		UnityEngine.Application.onBeforeRender -= OnBeforeRender;
	}

	private void Awake()
	{
		if (externalCamera == null && File.Exists(externalCameraConfigPath))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("SteamVR_ExternalCamera"));
			gameObject.gameObject.name = "External Camera";
			externalCamera = gameObject.transform.GetChild(0).GetComponent<SteamVR_ExternalCamera>();
			externalCamera.configPath = externalCameraConfigPath;
			externalCamera.ReadConfig();
		}
	}

	public void UpdatePoses()
	{
		CVRCompositor compositor = OpenVR.Compositor;
		if (compositor != null)
		{
			compositor.GetLastPoses(poses, gamePoses);
			SteamVR_Events.NewPoses.Send(poses);
			SteamVR_Events.NewPosesApplied.Send();
		}
	}

	private void OnBeforeRender()
	{
		UpdatePoses();
	}

	private void Update()
	{
		SteamVR_Controller.Update();
		CVRSystem system = OpenVR.System;
		if (system != null)
		{
			VREvent_t pEvent = default(VREvent_t);
			uint uncbVREvent = (uint)Marshal.SizeOf(typeof(VREvent_t));
			for (int i = 0; i < 64; i++)
			{
				if (!system.PollNextEvent(ref pEvent, uncbVREvent))
				{
					break;
				}
				switch ((EVREventType)pEvent.eventType)
				{
				case EVREventType.VREvent_InputFocusCaptured:
					if (pEvent.data.process.oldPid == 0)
					{
						SteamVR_Events.InputFocus.Send(arg0: false);
					}
					break;
				case EVREventType.VREvent_InputFocusReleased:
					if (pEvent.data.process.pid == 0)
					{
						SteamVR_Events.InputFocus.Send(arg0: true);
					}
					break;
				case EVREventType.VREvent_ShowRenderModels:
					SteamVR_Events.HideRenderModels.Send(arg0: false);
					break;
				case EVREventType.VREvent_HideRenderModels:
					SteamVR_Events.HideRenderModels.Send(arg0: true);
					break;
				default:
					SteamVR_Events.System((EVREventType)pEvent.eventType).Send(pEvent);
					break;
				}
			}
		}
		UnityEngine.Application.targetFrameRate = -1;
		UnityEngine.Application.runInBackground = true;
		QualitySettings.maxQueuedFrames = -1;
		QualitySettings.vSyncCount = 0;
		if (lockPhysicsUpdateRateToRenderFrequency && Time.timeScale > 0f)
		{
			SteamVR steamVR = SteamVR.instance;
			if (steamVR != null)
			{
				Compositor_FrameTiming pTiming = default(Compositor_FrameTiming);
				pTiming.m_nSize = (uint)Marshal.SizeOf(typeof(Compositor_FrameTiming));
				steamVR.compositor.GetFrameTiming(ref pTiming, 0u);
				Time.fixedDeltaTime = Time.timeScale / steamVR.hmd_DisplayFrequency;
			}
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_RenderModel : MonoBehaviour
{
	public class RenderModel
	{
		public Mesh mesh { get; private set; }

		public Material material { get; private set; }

		public RenderModel(Mesh mesh, Material material)
		{
			this.mesh = mesh;
			this.material = material;
		}
	}

	public sealed class RenderModelInterfaceHolder : IDisposable
	{
		private bool needsShutdown;

		private bool failedLoadInterface;

		private CVRRenderModels _instance;

		public CVRRenderModels instance
		{
			get
			{
				if (_instance == null && !failedLoadInterface)
				{
					if (!SteamVR.active && !SteamVR.usingNativeSupport)
					{
						EVRInitError peError = EVRInitError.None;
						OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
						needsShutdown = true;
					}
					_instance = OpenVR.RenderModels;
					if (_instance == null)
					{
						UnityEngine.Debug.LogError("Failed to load IVRRenderModels interface version IVRRenderModels_005");
						failedLoadInterface = true;
					}
				}
				return _instance;
			}
		}

		public void Dispose()
		{
			if (needsShutdown)
			{
				OpenVR.Shutdown();
			}
		}
	}

	public SteamVR_TrackedObject.EIndex index = SteamVR_TrackedObject.EIndex.None;

	public const string modelOverrideWarning = "Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.";

	[Tooltip("Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.")]
	public string modelOverride;

	[Tooltip("Shader to apply to model.")]
	public Shader shader;

	[Tooltip("Enable to print out when render models are loaded.")]
	public bool verbose;

	[Tooltip("If available, break down into separate components instead of loading as a single mesh.")]
	public bool createComponents = true;

	[Tooltip("Update transforms of components at runtime to reflect user action.")]
	public bool updateDynamically = true;

	public RenderModel_ControllerMode_State_t controllerModeState;

	public const string k_localTransformName = "attach";

	public static System.Collections.Hashtable models = new System.Collections.Hashtable();

	public static System.Collections.Hashtable materials = new System.Collections.Hashtable();

	private SteamVR_Events.Action deviceConnectedAction;

	private SteamVR_Events.Action hideRenderModelsAction;

	private SteamVR_Events.Action modelSkinSettingsHaveChangedAction;

	private Dictionary<int, string> nameCache;

	public string renderModelName { get; private set; }

	private void OnModelSkinSettingsHaveChanged(VREvent_t vrEvent)
	{
		if (!string.IsNullOrEmpty(renderModelName))
		{
			renderModelName = "";
			UpdateModel();
		}
	}

	private void OnHideRenderModels(bool hidden)
	{
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = !hidden;
		}
		MeshRenderer[] componentsInChildren = base.transform.GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = !hidden;
		}
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		if (i == (int)index && connected)
		{
			UpdateModel();
		}
	}

	public void UpdateModel()
	{
		CVRSystem system = OpenVR.System;
		if (system == null)
		{
			return;
		}
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, null, 0u, ref pError);
		if (stringTrackedDeviceProperty <= 1)
		{
			UnityEngine.Debug.LogError("Failed to get render model name for tracked object " + index);
			return;
		}
		StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
		system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, stringBuilder, stringTrackedDeviceProperty, ref pError);
		string text = stringBuilder.ToString();
		if (renderModelName != text)
		{
			renderModelName = text;
			StartCoroutine(SetModelAsync(text));
		}
	}

	private IEnumerator SetModelAsync(string renderModelName)
	{
		if (string.IsNullOrEmpty(renderModelName))
		{
			yield break;
		}
		using (RenderModelInterfaceHolder holder = new RenderModelInterfaceHolder())
		{
			CVRRenderModels renderModels = holder.instance;
			if (renderModels == null)
			{
				yield break;
			}
			uint componentCount = renderModels.GetComponentCount(renderModelName);
			string[] renderModelNames;
			if (componentCount == 0)
			{
				renderModelNames = ((models[renderModelName] is RenderModel renderModel && !(renderModel.mesh == null)) ? new string[0] : new string[1] { renderModelName });
			}
			else
			{
				renderModelNames = new string[componentCount];
				for (int i = 0; i < componentCount; i++)
				{
					uint componentName = renderModels.GetComponentName(renderModelName, (uint)i, null, 0u);
					if (componentName == 0)
					{
						continue;
					}
					StringBuilder stringBuilder = new StringBuilder((int)componentName);
					if (renderModels.GetComponentName(renderModelName, (uint)i, stringBuilder, componentName) == 0)
					{
						continue;
					}
					componentName = renderModels.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), null, 0u);
					if (componentName == 0)
					{
						continue;
					}
					StringBuilder stringBuilder2 = new StringBuilder((int)componentName);
					if (renderModels.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), stringBuilder2, componentName) != 0)
					{
						string text = stringBuilder2.ToString();
						if (!(models[text] is RenderModel renderModel2) || renderModel2.mesh == null)
						{
							renderModelNames[i] = text;
						}
					}
				}
			}
			while (true)
			{
				bool flag = false;
				string[] array = renderModelNames;
				foreach (string text2 in array)
				{
					if (string.IsNullOrEmpty(text2))
					{
						continue;
					}
					IntPtr ppRenderModel = IntPtr.Zero;
					switch (renderModels.LoadRenderModel_Async(text2, ref ppRenderModel))
					{
					case EVRRenderModelError.Loading:
						flag = true;
						break;
					case EVRRenderModelError.None:
					{
						RenderModel_t renderModel_t = MarshalRenderModel(ppRenderModel);
						Material material = materials[renderModel_t.diffuseTextureId] as Material;
						if (material == null || material.mainTexture == null)
						{
							IntPtr ppTexture = IntPtr.Zero;
							EVRRenderModelError eVRRenderModelError = renderModels.LoadTexture_Async(renderModel_t.diffuseTextureId, ref ppTexture);
							if (eVRRenderModelError == EVRRenderModelError.Loading)
							{
								flag = true;
							}
						}
						break;
					}
					}
				}
				if (!flag)
				{
					break;
				}
				yield return new WaitForSecondsRealtime(0.1f);
			}
		}
		bool arg = SetModel(renderModelName);
		SteamVR_Events.RenderModelLoaded.Send(this, arg);
	}

	private bool SetModel(string renderModelName)
	{
		StripMesh(base.gameObject);
		using (RenderModelInterfaceHolder renderModelInterfaceHolder = new RenderModelInterfaceHolder())
		{
			if (createComponents)
			{
				if (LoadComponents(renderModelInterfaceHolder, renderModelName))
				{
					UpdateComponents(renderModelInterfaceHolder.instance);
					return true;
				}
				UnityEngine.Debug.Log("[" + base.gameObject.name + "] Render model does not support components, falling back to single mesh.");
			}
			if (!string.IsNullOrEmpty(renderModelName))
			{
				RenderModel renderModel = models[renderModelName] as RenderModel;
				if (renderModel == null || renderModel.mesh == null)
				{
					CVRRenderModels instance = renderModelInterfaceHolder.instance;
					if (instance == null)
					{
						return false;
					}
					if (verbose)
					{
						UnityEngine.Debug.Log("Loading render model " + renderModelName);
					}
					renderModel = LoadRenderModel(instance, renderModelName, renderModelName);
					if (renderModel == null)
					{
						return false;
					}
					models[renderModelName] = renderModel;
				}
				base.gameObject.AddComponent<MeshFilter>().mesh = renderModel.mesh;
				base.gameObject.AddComponent<MeshRenderer>().sharedMaterial = renderModel.material;
				return true;
			}
		}
		return false;
	}

	private RenderModel LoadRenderModel(CVRRenderModels renderModels, string renderModelName, string baseName)
	{
		IntPtr ppRenderModel = IntPtr.Zero;
		while (true)
		{
			EVRRenderModelError eVRRenderModelError = renderModels.LoadRenderModel_Async(renderModelName, ref ppRenderModel);
			switch (eVRRenderModelError)
			{
			case EVRRenderModelError.Loading:
				break;
			default:
				UnityEngine.Debug.LogError($"Failed to load render model {renderModelName} - {eVRRenderModelError.ToString()}");
				return null;
			case EVRRenderModelError.None:
			{
				RenderModel_t renderModel_t = MarshalRenderModel(ppRenderModel);
				Vector3[] array = new Vector3[renderModel_t.unVertexCount];
				Vector3[] array2 = new Vector3[renderModel_t.unVertexCount];
				Vector2[] array3 = new Vector2[renderModel_t.unVertexCount];
				Type typeFromHandle = typeof(RenderModel_Vertex_t);
				for (int i = 0; i < renderModel_t.unVertexCount; i++)
				{
					RenderModel_Vertex_t renderModel_Vertex_t = (RenderModel_Vertex_t)Marshal.PtrToStructure(new IntPtr(renderModel_t.rVertexData.ToInt64() + i * Marshal.SizeOf(typeFromHandle)), typeFromHandle);
					array[i] = new Vector3(renderModel_Vertex_t.vPosition.v0, renderModel_Vertex_t.vPosition.v1, 0f - renderModel_Vertex_t.vPosition.v2);
					array2[i] = new Vector3(renderModel_Vertex_t.vNormal.v0, renderModel_Vertex_t.vNormal.v1, 0f - renderModel_Vertex_t.vNormal.v2);
					array3[i] = new Vector2(renderModel_Vertex_t.rfTextureCoord0, renderModel_Vertex_t.rfTextureCoord1);
				}
				uint num = renderModel_t.unTriangleCount * 3;
				short[] array4 = new short[num];
				Marshal.Copy(renderModel_t.rIndexData, array4, 0, array4.Length);
				int[] array5 = new int[num];
				for (int j = 0; j < renderModel_t.unTriangleCount; j++)
				{
					array5[j * 3] = array4[j * 3 + 2];
					array5[j * 3 + 1] = array4[j * 3 + 1];
					array5[j * 3 + 2] = array4[j * 3];
				}
				Mesh mesh = new Mesh();
				mesh.vertices = array;
				mesh.normals = array2;
				mesh.uv = array3;
				mesh.triangles = array5;
				Material material = materials[renderModel_t.diffuseTextureId] as Material;
				if (material == null || material.mainTexture == null)
				{
					IntPtr ppTexture = IntPtr.Zero;
					while (true)
					{
						switch (renderModels.LoadTexture_Async(renderModel_t.diffuseTextureId, ref ppTexture))
						{
						case EVRRenderModelError.Loading:
							goto IL_0230;
						case EVRRenderModelError.None:
						{
							RenderModel_TextureMap_t renderModel_TextureMap_t = MarshalRenderModel_TextureMap(ppTexture);
							Texture2D texture2D = new Texture2D(renderModel_TextureMap_t.unWidth, renderModel_TextureMap_t.unHeight, TextureFormat.RGBA32, mipChain: false);
							if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
							{
								texture2D.Apply();
								while (true)
								{
									eVRRenderModelError = renderModels.LoadIntoTextureD3D11_Async(renderModel_t.diffuseTextureId, texture2D.GetNativeTexturePtr());
									if (eVRRenderModelError != EVRRenderModelError.Loading)
									{
										break;
									}
									Sleep();
								}
							}
							else
							{
								byte[] array6 = new byte[renderModel_TextureMap_t.unWidth * renderModel_TextureMap_t.unHeight * 4];
								Marshal.Copy(renderModel_TextureMap_t.rubTextureMapData, array6, 0, array6.Length);
								Color32[] array7 = new Color32[renderModel_TextureMap_t.unWidth * renderModel_TextureMap_t.unHeight];
								int num2 = 0;
								for (int k = 0; k < renderModel_TextureMap_t.unHeight; k++)
								{
									for (int l = 0; l < renderModel_TextureMap_t.unWidth; l++)
									{
										byte r = array6[num2++];
										byte g = array6[num2++];
										byte b = array6[num2++];
										byte a = array6[num2++];
										array7[k * renderModel_TextureMap_t.unWidth + l] = new Color32(r, g, b, a);
									}
								}
								texture2D.SetPixels32(array7);
								texture2D.Apply();
							}
							material = new Material((shader != null) ? shader : Shader.Find("Standard"));
							material.mainTexture = texture2D;
							materials[renderModel_t.diffuseTextureId] = material;
							renderModels.FreeTexture(ppTexture);
							break;
						}
						default:
							UnityEngine.Debug.Log("Failed to load render model texture for render model " + renderModelName);
							break;
						}
						break;
						IL_0230:
						Sleep();
					}
				}
				StartCoroutine(FreeRenderModel(ppRenderModel));
				return new RenderModel(mesh, material);
			}
			}
			Sleep();
		}
	}

	private IEnumerator FreeRenderModel(IntPtr pRenderModel)
	{
		yield return new WaitForSeconds(1f);
		using RenderModelInterfaceHolder renderModelInterfaceHolder = new RenderModelInterfaceHolder();
		renderModelInterfaceHolder.instance.FreeRenderModel(pRenderModel);
	}

	public Transform FindComponent(string componentName)
	{
		Transform transform = base.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (child.name == componentName)
			{
				return child;
			}
		}
		return null;
	}

	private void StripMesh(GameObject go)
	{
		MeshRenderer component = go.GetComponent<MeshRenderer>();
		if (component != null)
		{
			UnityEngine.Object.DestroyImmediate(component);
		}
		MeshFilter component2 = go.GetComponent<MeshFilter>();
		if (component2 != null)
		{
			UnityEngine.Object.DestroyImmediate(component2);
		}
	}

	private bool LoadComponents(RenderModelInterfaceHolder holder, string renderModelName)
	{
		Transform transform = base.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			child.gameObject.SetActive(value: false);
			StripMesh(child.gameObject);
		}
		if (string.IsNullOrEmpty(renderModelName))
		{
			return true;
		}
		CVRRenderModels instance = holder.instance;
		if (instance == null)
		{
			return false;
		}
		uint componentCount = instance.GetComponentCount(renderModelName);
		if (componentCount == 0)
		{
			return false;
		}
		for (int j = 0; j < componentCount; j++)
		{
			uint componentName = instance.GetComponentName(renderModelName, (uint)j, null, 0u);
			if (componentName == 0)
			{
				continue;
			}
			StringBuilder stringBuilder = new StringBuilder((int)componentName);
			if (instance.GetComponentName(renderModelName, (uint)j, stringBuilder, componentName) == 0)
			{
				continue;
			}
			transform = FindComponent(stringBuilder.ToString());
			if (transform != null)
			{
				transform.gameObject.SetActive(value: true);
			}
			else
			{
				transform = new GameObject(stringBuilder.ToString()).transform;
				transform.parent = base.transform;
				transform.gameObject.layer = base.gameObject.layer;
				Transform obj = new GameObject("attach").transform;
				obj.parent = transform;
				obj.localPosition = Vector3.zero;
				obj.localRotation = Quaternion.identity;
				obj.localScale = Vector3.one;
				obj.gameObject.layer = base.gameObject.layer;
			}
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
			componentName = instance.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), null, 0u);
			if (componentName == 0)
			{
				continue;
			}
			StringBuilder stringBuilder2 = new StringBuilder((int)componentName);
			if (instance.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), stringBuilder2, componentName) == 0)
			{
				continue;
			}
			RenderModel renderModel = models[stringBuilder2] as RenderModel;
			if (renderModel == null || renderModel.mesh == null)
			{
				if (verbose)
				{
					UnityEngine.Debug.Log("Loading render model " + stringBuilder2);
				}
				renderModel = LoadRenderModel(instance, stringBuilder2.ToString(), renderModelName);
				if (renderModel == null)
				{
					continue;
				}
				models[stringBuilder2] = renderModel;
			}
			transform.gameObject.AddComponent<MeshFilter>().mesh = renderModel.mesh;
			transform.gameObject.AddComponent<MeshRenderer>().sharedMaterial = renderModel.material;
		}
		return true;
	}

	private SteamVR_RenderModel()
	{
		deviceConnectedAction = SteamVR_Events.DeviceConnectedAction(OnDeviceConnected);
		hideRenderModelsAction = SteamVR_Events.HideRenderModelsAction(OnHideRenderModels);
		modelSkinSettingsHaveChangedAction = SteamVR_Events.SystemAction(EVREventType.VREvent_ModelSkinSettingsHaveChanged, OnModelSkinSettingsHaveChanged);
	}

	private void OnEnable()
	{
		if (!string.IsNullOrEmpty(modelOverride))
		{
			UnityEngine.Debug.Log("Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.");
			base.enabled = false;
			return;
		}
		CVRSystem system = OpenVR.System;
		if (system != null && system.IsTrackedDeviceConnected((uint)index))
		{
			UpdateModel();
		}
		deviceConnectedAction.enabled = true;
		hideRenderModelsAction.enabled = true;
		modelSkinSettingsHaveChangedAction.enabled = true;
	}

	private void OnDisable()
	{
		deviceConnectedAction.enabled = false;
		hideRenderModelsAction.enabled = false;
		modelSkinSettingsHaveChangedAction.enabled = false;
	}

	private void Update()
	{
		if (updateDynamically)
		{
			UpdateComponents(OpenVR.RenderModels);
		}
	}

	public void UpdateComponents(CVRRenderModels renderModels)
	{
		if (renderModels == null)
		{
			return;
		}
		Transform transform = base.transform;
		if (transform.childCount == 0)
		{
			return;
		}
		VRControllerState_t pControllerState = ((index != SteamVR_TrackedObject.EIndex.None) ? SteamVR_Controller.Input((int)index).GetState() : default(VRControllerState_t));
		if (nameCache == null)
		{
			nameCache = new Dictionary<int, string>();
		}
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!nameCache.TryGetValue(child.GetInstanceID(), out var value))
			{
				value = child.name;
				nameCache.Add(child.GetInstanceID(), value);
			}
			RenderModel_ComponentState_t pComponentState = default(RenderModel_ComponentState_t);
			if (renderModels.GetComponentState(renderModelName, value, ref pControllerState, ref controllerModeState, ref pComponentState))
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(pComponentState.mTrackingToComponentRenderModel);
				child.localPosition = rigidTransform.pos;
				child.localRotation = rigidTransform.rot;
				Transform transform2 = child.Find("attach");
				if (transform2 != null)
				{
					SteamVR_Utils.RigidTransform rigidTransform2 = new SteamVR_Utils.RigidTransform(pComponentState.mTrackingToComponentLocal);
					transform2.position = transform.TransformPoint(rigidTransform2.pos);
					transform2.rotation = transform.rotation * rigidTransform2.rot;
				}
				bool flag = (pComponentState.uProperties & 2) != 0;
				if (flag != child.gameObject.activeSelf)
				{
					child.gameObject.SetActive(flag);
				}
			}
		}
	}

	public void SetDeviceIndex(int index)
	{
		this.index = (SteamVR_TrackedObject.EIndex)index;
		modelOverride = "";
		if (base.enabled)
		{
			UpdateModel();
		}
	}

	private static void Sleep()
	{
		Thread.Sleep(1);
	}

	private RenderModel_t MarshalRenderModel(IntPtr pRenderModel)
	{
		if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
		{
			RenderModel_t_Packed renderModel_t_Packed = (RenderModel_t_Packed)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_t_Packed));
			RenderModel_t unpacked = default(RenderModel_t);
			renderModel_t_Packed.Unpack(ref unpacked);
			return unpacked;
		}
		return (RenderModel_t)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_t));
	}

	private RenderModel_TextureMap_t MarshalRenderModel_TextureMap(IntPtr pRenderModel)
	{
		if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
		{
			RenderModel_TextureMap_t_Packed renderModel_TextureMap_t_Packed = (RenderModel_TextureMap_t_Packed)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_TextureMap_t_Packed));
			RenderModel_TextureMap_t unpacked = default(RenderModel_TextureMap_t);
			renderModel_TextureMap_t_Packed.Unpack(ref unpacked);
			return unpacked;
		}
		return (RenderModel_TextureMap_t)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_TextureMap_t));
	}
}
public class SteamVR_Skybox : MonoBehaviour
{
	public enum CellSize
	{
		x1024,
		x64,
		x32,
		x16,
		x8
	}

	public Texture front;

	public Texture back;

	public Texture left;

	public Texture right;

	public Texture top;

	public Texture bottom;

	public CellSize StereoCellSize = CellSize.x32;

	public float StereoIpdMm = 64f;

	public void SetTextureByIndex(int i, Texture t)
	{
		switch (i)
		{
		case 0:
			front = t;
			break;
		case 1:
			back = t;
			break;
		case 2:
			left = t;
			break;
		case 3:
			right = t;
			break;
		case 4:
			top = t;
			break;
		case 5:
			bottom = t;
			break;
		}
	}

	public Texture GetTextureByIndex(int i)
	{
		return i switch
		{
			0 => front, 
			1 => back, 
			2 => left, 
			3 => right, 
			4 => top, 
			5 => bottom, 
			_ => null, 
		};
	}

	public static void SetOverride(Texture front = null, Texture back = null, Texture left = null, Texture right = null, Texture top = null, Texture bottom = null)
	{
		CVRCompositor compositor = OpenVR.Compositor;
		if (compositor == null)
		{
			return;
		}
		Texture[] array = new Texture[6] { front, back, left, right, top, bottom };
		Texture_t[] array2 = new Texture_t[6];
		for (int i = 0; i < 6; i++)
		{
			array2[i].handle = ((array[i] != null) ? array[i].GetNativeTexturePtr() : IntPtr.Zero);
			array2[i].eType = SteamVR.instance.textureType;
			array2[i].eColorSpace = EColorSpace.Auto;
		}
		EVRCompositorError eVRCompositorError = compositor.SetSkyboxOverride(array2);
		if (eVRCompositorError != 0)
		{
			UnityEngine.Debug.LogError("Failed to set skybox override with error: " + eVRCompositorError);
			switch (eVRCompositorError)
			{
			case EVRCompositorError.TextureIsOnWrongDevice:
				UnityEngine.Debug.Log("Set your graphics driver to use the same video card as the headset is plugged into for Unity.");
				break;
			case EVRCompositorError.TextureUsesUnsupportedFormat:
				UnityEngine.Debug.Log("Ensure skybox textures are not compressed and have no mipmaps.");
				break;
			}
		}
	}

	public static void ClearOverride()
	{
		OpenVR.Compositor?.ClearSkyboxOverride();
	}

	private void OnEnable()
	{
		SetOverride(front, back, left, right, top, bottom);
	}

	private void OnDisable()
	{
		ClearOverride();
	}
}
[ExecuteInEditMode]
public class SteamVR_SphericalProjection : MonoBehaviour
{
	private static Material material;

	public void Set(Vector3 N, float phi0, float phi1, float theta0, float theta1, Vector3 uAxis, Vector3 uOrigin, float uScale, Vector3 vAxis, Vector3 vOrigin, float vScale)
	{
		if (material == null)
		{
			material = new Material(Shader.Find("Custom/SteamVR_SphericalProjection"));
		}
		material.SetVector("_N", new Vector4(N.x, N.y, N.z));
		material.SetFloat("_Phi0", phi0 * ((float)Math.PI / 180f));
		material.SetFloat("_Phi1", phi1 * ((float)Math.PI / 180f));
		material.SetFloat("_Theta0", theta0 * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
		material.SetFloat("_Theta1", theta1 * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
		material.SetVector("_UAxis", uAxis);
		material.SetVector("_VAxis", vAxis);
		material.SetVector("_UOrigin", uOrigin);
		material.SetVector("_VOrigin", vOrigin);
		material.SetFloat("_UScale", uScale);
		material.SetFloat("_VScale", vScale);
	}

	private void OnRenderImage(RenderTexture src, RenderTexture dest)
	{
		Graphics.Blit(src, dest, material);
	}
}
[ExecuteInEditMode]
public class SteamVR_Stats : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_Stats is deprecated in Unity 2017.2 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_TestController : MonoBehaviour
{
	private List<int> controllerIndices = new List<int>();

	private EVRButtonId[] buttonIds = new EVRButtonId[4]
	{
		EVRButtonId.k_EButton_ApplicationMenu,
		EVRButtonId.k_EButton_Grip,
		EVRButtonId.k_EButton_Axis0,
		EVRButtonId.k_EButton_Axis1
	};

	private EVRButtonId[] axisIds = new EVRButtonId[2]
	{
		EVRButtonId.k_EButton_Axis0,
		EVRButtonId.k_EButton_Axis1
	};

	public Transform point;

	public Transform pointer;

	private void OnDeviceConnected(int index, bool connected)
	{
		CVRSystem system = OpenVR.System;
		if (system != null && system.GetTrackedDeviceClass((uint)index) == ETrackedDeviceClass.Controller)
		{
			if (connected)
			{
				UnityEngine.Debug.Log($"Controller {index} connected.");
				PrintControllerStatus(index);
				controllerIndices.Add(index);
			}
			else
			{
				UnityEngine.Debug.Log($"Controller {index} disconnected.");
				PrintControllerStatus(index);
				controllerIndices.Remove(index);
			}
		}
	}

	private void OnEnable()
	{
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
	}

	private void OnDisable()
	{
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
	}

	private void PrintControllerStatus(int index)
	{
		SteamVR_Controller.Device device = SteamVR_Controller.Input(index);
		UnityEngine.Debug.Log("index: " + device.index);
		UnityEngine.Debug.Log("connected: " + device.connected);
		UnityEngine.Debug.Log("hasTracking: " + device.hasTracking);
		UnityEngine.Debug.Log("outOfRange: " + device.outOfRange);
		UnityEngine.Debug.Log("calibrating: " + device.calibrating);
		UnityEngine.Debug.Log("uninitialized: " + device.uninitialized);
		UnityEngine.Debug.Log("pos: " + device.transform.pos);
		UnityEngine.Debug.Log("rot: " + device.transform.rot.eulerAngles);
		UnityEngine.Debug.Log("velocity: " + device.velocity);
		UnityEngine.Debug.Log("angularVelocity: " + device.angularVelocity);
		int deviceIndex = SteamVR_Controller.GetDeviceIndex(SteamVR_Controller.DeviceRelation.Leftmost);
		int deviceIndex2 = SteamVR_Controller.GetDeviceIndex(SteamVR_Controller.DeviceRelation.Rightmost);
		UnityEngine.Debug.Log((deviceIndex == deviceIndex2) ? "first" : ((deviceIndex == index) ? "left" : "right"));
	}

	private void Update()
	{
		foreach (int controllerIndex in controllerIndices)
		{
			SteamVR_Overlay instance = SteamVR_Overlay.instance;
			if ((bool)instance && (bool)point && (bool)pointer)
			{
				SteamVR_Utils.RigidTransform rigidTransform = SteamVR_Controller.Input(controllerIndex).transform;
				pointer.transform.localPosition = rigidTransform.pos;
				pointer.transform.localRotation = rigidTransform.rot;
				SteamVR_Overlay.IntersectionResults results = default(SteamVR_Overlay.IntersectionResults);
				if (instance.ComputeIntersection(rigidTransform.pos, rigidTransform.rot * Vector3.forward, ref results))
				{
					point.transform.localPosition = results.point;
					point.transform.localRotation = Quaternion.LookRotation(results.normal);
				}
				continue;
			}
			EVRButtonId[] array = buttonIds;
			foreach (EVRButtonId eVRButtonId in array)
			{
				if (SteamVR_Controller.Input(controllerIndex).GetPressDown(eVRButtonId))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId, " press down"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetPressUp(eVRButtonId))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId, " press up"));
					if (eVRButtonId == EVRButtonId.k_EButton_Axis1)
					{
						SteamVR_Controller.Input(controllerIndex).TriggerHapticPulse(500);
						PrintControllerStatus(controllerIndex);
					}
				}
				if (SteamVR_Controller.Input(controllerIndex).GetPress(eVRButtonId))
				{
					UnityEngine.Debug.Log(eVRButtonId);
				}
			}
			array = axisIds;
			foreach (EVRButtonId eVRButtonId2 in array)
			{
				if (SteamVR_Controller.Input(controllerIndex).GetTouchDown(eVRButtonId2))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId2, " touch down"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetTouchUp(eVRButtonId2))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId2, " touch up"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetTouch(eVRButtonId2))
				{
					Vector2 axis = SteamVR_Controller.Input(controllerIndex).GetAxis(eVRButtonId2);
					UnityEngine.Debug.Log("axis: " + axis);
				}
			}
		}
	}
}
public class SteamVR_TrackedCamera
{
	public class VideoStreamTexture
	{
		private Texture2D _texture;

		private int prevFrameCount = -1;

		private uint glTextureId;

		private VideoStream videostream;

		private CameraVideoStreamFrameHeader_t header;

		public bool undistorted { get; private set; }

		public uint deviceIndex => videostream.deviceIndex;

		public bool hasCamera => videostream.hasCamera;

		public bool hasTracking
		{
			get
			{
				Update();
				return header.standingTrackedDevicePose.bPoseIsValid;
			}
		}

		public uint frameId
		{
			get
			{
				Update();
				return header.nFrameSequence;
			}
		}

		public VRTextureBounds_t frameBounds { get; private set; }

		public EVRTrackedCameraFrameType frameType
		{
			get
			{
				if (!undistorted)
				{
					return EVRTrackedCameraFrameType.Distorted;
				}
				return EVRTrackedCameraFrameType.Undistorted;
			}
		}

		public Texture2D texture
		{
			get
			{
				Update();
				return _texture;
			}
		}

		public SteamVR_Utils.RigidTransform transform
		{
			get
			{
				Update();
				return new SteamVR_Utils.RigidTransform(header.standingTrackedDevicePose.mDeviceToAbsoluteTracking);
			}
		}

		public Vector3 velocity
		{
			get
			{
				Update();
				TrackedDevicePose_t standingTrackedDevicePose = header.standingTrackedDevicePose;
				return new Vector3(standingTrackedDevicePose.vVelocity.v0, standingTrackedDevicePose.vVelocity.v1, 0f - standingTrackedDevicePose.vVelocity.v2);
			}
		}

		public Vector3 angularVelocity
		{
			get
			{
				Update();
				TrackedDevicePose_t standingTrackedDevicePose = header.standingTrackedDevicePose;
				return new Vector3(0f - standingTrackedDevicePose.vAngularVelocity.v0, 0f - standingTrackedDevicePose.vAngularVelocity.v1, standingTrackedDevicePose.vAngularVelocity.v2);
			}
		}

		public VideoStreamTexture(uint deviceIndex, bool undistorted)
		{
			this.undistorted = undistorted;
			videostream = Stream(deviceIndex);
		}

		public TrackedDevicePose_t GetPose()
		{
			Update();
			return header.standingTrackedDevicePose;
		}

		public ulong Acquire()
		{
			return videostream.Acquire();
		}

		public ulong Release()
		{
			ulong result = videostream.Release();
			if (videostream.handle == 0L)
			{
				UnityEngine.Object.Destroy(_texture);
				_texture = null;
			}
			return result;
		}

		private void Update()
		{
			if (Time.frameCount == prevFrameCount)
			{
				return;
			}
			prevFrameCount = Time.frameCount;
			if (videostream.handle == 0L)
			{
				return;
			}
			SteamVR instance = SteamVR.instance;
			if (instance == null)
			{
				return;
			}
			CVRTrackedCamera trackedCamera = OpenVR.TrackedCamera;
			if (trackedCamera == null)
			{
				return;
			}
			IntPtr ppD3D11ShaderResourceView = IntPtr.Zero;
			Texture2D texture2D = ((_texture != null) ? _texture : new Texture2D(2, 2));
			uint nFrameHeaderSize = (uint)Marshal.SizeOf(header.GetType());
			if (instance.textureType == ETextureType.OpenGL)
			{
				if (glTextureId != 0)
				{
					trackedCamera.ReleaseVideoStreamTextureGL(videostream.handle, glTextureId);
				}
				if (trackedCamera.GetVideoStreamTextureGL(videostream.handle, frameType, ref glTextureId, ref header, nFrameHeaderSize) != 0)
				{
					return;
				}
				ppD3D11ShaderResourceView = (IntPtr)glTextureId;
			}
			else if (instance.textureType == ETextureType.DirectX && trackedCamera.GetVideoStreamTextureD3D11(videostream.handle, frameType, texture2D.GetNativeTexturePtr(), ref ppD3D11ShaderResourceView, ref header, nFrameHeaderSize) != 0)
			{
				return;
			}
			if (_texture == null)
			{
				_texture = Texture2D.CreateExternalTexture((int)header.nWidth, (int)header.nHeight, TextureFormat.RGBA32, mipChain: false, linear: false, ppD3D11ShaderResourceView);
				uint pnWidth = 0u;
				uint pnHeight = 0u;
				VRTextureBounds_t pTextureBounds = default(VRTextureBounds_t);
				if (trackedCamera.GetVideoStreamTextureSize(deviceIndex, frameType, ref pTextureBounds, ref pnWidth, ref pnHeight) == EVRTrackedCameraError.None)
				{
					pTextureBounds.vMin = 1f - pTextureBounds.vMin;
					pTextureBounds.vMax = 1f - pTextureBounds.vMax;
					frameBounds = pTextureBounds;
				}
			}
			else
			{
				_texture.UpdateExternalTexture(ppD3D11ShaderResourceView);
			}
		}
	}

	private class VideoStream
	{
		private ulong _handle;

		private bool _hasCamera;

		private ulong refCount;

		public uint deviceIndex { get; private set; }

		public ulong handle => _handle;

		public bool hasCamera => _hasCamera;

		public VideoStream(uint deviceIndex)
		{
			this.deviceIndex = deviceIndex;
			OpenVR.TrackedCamera?.HasCamera(deviceIndex, ref _hasCamera);
		}

		public ulong Acquire()
		{
			if (_handle == 0L && hasCamera)
			{
				OpenVR.TrackedCamera?.AcquireVideoStreamingService(deviceIndex, ref _handle);
			}
			return ++refCount;
		}

		public ulong Release()
		{
			if (refCount != 0 && --refCount == 0L && _handle != 0L)
			{
				OpenVR.TrackedCamera?.ReleaseVideoStreamingService(_handle);
				_handle = 0uL;
			}
			return refCount;
		}
	}

	private static VideoStreamTexture[] distorted;

	private static VideoStreamTexture[] undistorted;

	private static VideoStream[] videostreams;

	public static VideoStreamTexture Distorted(int deviceIndex = 0)
	{
		if (distorted == null)
		{
			distorted = new VideoStreamTexture[64];
		}
		if (distorted[deviceIndex] == null)
		{
			distorted[deviceIndex] = new VideoStreamTexture((uint)deviceIndex, undistorted: false);
		}
		return distorted[deviceIndex];
	}

	public static VideoStreamTexture Undistorted(int deviceIndex = 0)
	{
		if (undistorted == null)
		{
			undistorted = new VideoStreamTexture[64];
		}
		if (undistorted[deviceIndex] == null)
		{
			undistorted[deviceIndex] = new VideoStreamTexture((uint)deviceIndex, undistorted: true);
		}
		return undistorted[deviceIndex];
	}

	public static VideoStreamTexture Source(bool undistorted, int deviceIndex = 0)
	{
		if (!undistorted)
		{
			return Distorted(deviceIndex);
		}
		return Undistorted(deviceIndex);
	}

	private static VideoStream Stream(uint deviceIndex)
	{
		if (videostreams == null)
		{
			videostreams = new VideoStream[64];
		}
		if (videostreams[deviceIndex] == null)
		{
			videostreams[deviceIndex] = new VideoStream(deviceIndex);
		}
		return videostreams[deviceIndex];
	}
}
public class SteamVR_TrackedObject : MonoBehaviour
{
	public enum EIndex
	{
		None = -1,
		Hmd,
		Device1,
		Device2,
		Device3,
		Device4,
		Device5,
		Device6,
		Device7,
		Device8,
		Device9,
		Device10,
		Device11,
		Device12,
		Device13,
		Device14,
		Device15
	}

	public EIndex index;

	[Tooltip("If not set, relative to parent")]
	public Transform origin;

	public bool isTracker;

	private SteamVR_Events.Action newPosesAction;

	public bool isValid { get; private set; }

	private void OnNewPoses(TrackedDevicePose_t[] poses)
	{
		if (index == EIndex.None)
		{
			return;
		}
		int num = (int)index;
		isValid = false;
		if (poses.Length > num && poses[num].bDeviceIsConnected && poses[num].bPoseIsValid)
		{
			isValid = true;
			SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(poses[num].mDeviceToAbsoluteTracking);
			if (origin != null)
			{
				base.transform.position = origin.transform.TransformPoint(rigidTransform.pos);
				base.transform.rotation = origin.rotation * rigidTransform.rot;
			}
			else
			{
				base.transform.localPosition = rigidTransform.pos;
				base.transform.localRotation = rigidTransform.rot;
			}
		}
	}

	private SteamVR_TrackedObject()
	{
		newPosesAction = SteamVR_Events.NewPosesAction(OnNewPoses);
	}

	private void OnEnable()
	{
		if (SteamVR_Render.instance == null)
		{
			base.enabled = false;
		}
		else
		{
			newPosesAction.enabled = true;
		}
	}

	private void OnDisable()
	{
		newPosesAction.enabled = false;
		isValid = false;
	}

	private void Start()
	{
		CheckIfTracker();
	}

	public void SetDeviceIndex(int index)
	{
		if (Enum.IsDefined(typeof(EIndex), index))
		{
			this.index = (EIndex)index;
		}
	}

	public void CheckIfTracker()
	{
		CVRSystem system = OpenVR.System;
		if (system != null)
		{
			ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
			uint stringTrackedDeviceProperty = system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, null, 0u, ref pError);
			if (stringTrackedDeviceProperty <= 1)
			{
				UnityEngine.Debug.LogError("Failed to get render model name for tracked object " + index);
				return;
			}
			StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
			system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, stringBuilder, stringTrackedDeviceProperty, ref pError);
			string text = stringBuilder.ToString();
			isTracker = text.Contains("tracker");
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_UpdatePoses : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_UpdatePoses has been deprecated - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public static class SteamVR_Utils
{
	[Serializable]
	public struct RigidTransform
	{
		public Vector3 pos;

		public Quaternion rot;

		public static RigidTransform identity => new RigidTransform(Vector3.zero, Quaternion.identity);

		public static RigidTransform FromLocal(Transform t)
		{
			return new RigidTransform(t.localPosition, t.localRotation);
		}

		public RigidTransform(Vector3 pos, Quaternion rot)
		{
			this.pos = pos;
			this.rot = rot;
		}

		public RigidTransform(Transform t)
		{
			pos = t.position;
			rot = t.rotation;
		}

		public RigidTransform(Transform from, Transform to)
		{
			Quaternion quaternion = Quaternion.Inverse(from.rotation);
			rot = quaternion * to.rotation;
			pos = quaternion * (to.position - from.position);
		}

		public RigidTransform(HmdMatrix34_t pose)
		{
			Matrix4x4 matrix = Matrix4x4.identity;
			matrix[0, 0] = pose.m0;
			matrix[0, 1] = pose.m1;
			matrix[0, 2] = 0f - pose.m2;
			matrix[0, 3] = pose.m3;
			matrix[1, 0] = pose.m4;
			matrix[1, 1] = pose.m5;
			matrix[1, 2] = 0f - pose.m6;
			matrix[1, 3] = pose.m7;
			matrix[2, 0] = 0f - pose.m8;
			matrix[2, 1] = 0f - pose.m9;
			matrix[2, 2] = pose.m10;
			matrix[2, 3] = 0f - pose.m11;
			pos = matrix.GetPosition();
			rot = matrix.GetRotation();
		}

		public RigidTransform(HmdMatrix44_t pose)
		{
			Matrix4x4 matrix = Matrix4x4.identity;
			matrix[0, 0] = pose.m0;
			matrix[0, 1] = pose.m1;
			matrix[0, 2] = 0f - pose.m2;
			matrix[0, 3] = pose.m3;
			matrix[1, 0] = pose.m4;
			matrix[1, 1] = pose.m5;
			matrix[1, 2] = 0f - pose.m6;
			matrix[1, 3] = pose.m7;
			matrix[2, 0] = 0f - pose.m8;
			matrix[2, 1] = 0f - pose.m9;
			matrix[2, 2] = pose.m10;
			matrix[2, 3] = 0f - pose.m11;
			matrix[3, 0] = pose.m12;
			matrix[3, 1] = pose.m13;
			matrix[3, 2] = 0f - pose.m14;
			matrix[3, 3] = pose.m15;
			pos = matrix.GetPosition();
			rot = matrix.GetRotation();
		}

		public HmdMatrix44_t ToHmdMatrix44()
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(pos, rot, Vector3.one);
			HmdMatrix44_t result = default(HmdMatrix44_t);
			result.m0 = matrix4x[0, 0];
			result.m1 = matrix4x[0, 1];
			result.m2 = 0f - matrix4x[0, 2];
			result.m3 = matrix4x[0, 3];
			result.m4 = matrix4x[1, 0];
			result.m5 = matrix4x[1, 1];
			result.m6 = 0f - matrix4x[1, 2];
			result.m7 = matrix4x[1, 3];
			result.m8 = 0f - matrix4x[2, 0];
			result.m9 = 0f - matrix4x[2, 1];
			result.m10 = matrix4x[2, 2];
			result.m11 = 0f - matrix4x[2, 3];
			result.m12 = matrix4x[3, 0];
			result.m13 = matrix4x[3, 1];
			result.m14 = 0f - matrix4x[3, 2];
			result.m15 = matrix4x[3, 3];
			return result;
		}

		public HmdMatrix34_t ToHmdMatrix34()
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(pos, rot, Vector3.one);
			HmdMatrix34_t result = default(HmdMatrix34_t);
			result.m0 = matrix4x[0, 0];
			result.m1 = matrix4x[0, 1];
			result.m2 = 0f - matrix4x[0, 2];
			result.m3 = matrix4x[0, 3];
			result.m4 = matrix4x[1, 0];
			result.m5 = matrix4x[1, 1];
			result.m6 = 0f - matrix4x[1, 2];
			result.m7 = matrix4x[1, 3];
			result.m8 = 0f - matrix4x[2, 0];
			result.m9 = 0f - matrix4x[2, 1];
			result.m10 = matrix4x[2, 2];
			result.m11 = 0f - matrix4x[2, 3];
			return result;
		}

		public override bool Equals(object o)
		{
			if (o is RigidTransform rigidTransform)
			{
				if (pos == rigidTransform.pos)
				{
					return rot == rigidTransform.rot;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return pos.GetHashCode() ^ rot.GetHashCode();
		}

		public static bool operator ==(RigidTransform a, RigidTransform b)
		{
			if (a.pos == b.pos)
			{
				return a.rot == b.rot;
			}
			return false;
		}

		public static bool operator !=(RigidTransform a, RigidTransform b)
		{
			if (!(a.pos != b.pos))
			{
				return a.rot != b.rot;
			}
			return true;
		}

		public static RigidTransform operator *(RigidTransform a, RigidTransform b)
		{
			RigidTransform result = default(RigidTransform);
			result.rot = a.rot * b.rot;
			result.pos = a.pos + a.rot * b.pos;
			return result;
		}

		public void Inverse()
		{
			rot = Quaternion.Inverse(rot);
			pos = -(rot * pos);
		}

		public RigidTransform GetInverse()
		{
			RigidTransform result = new RigidTransform(pos, rot);
			result.Inverse();
			return result;
		}

		public void Multiply(RigidTransform a, RigidTransform b)
		{
			rot = a.rot * b.rot;
			pos = a.pos + a.rot * b.pos;
		}

		public Vector3 InverseTransformPoint(Vector3 point)
		{
			return Quaternion.Inverse(rot) * (point - pos);
		}

		public Vector3 TransformPoint(Vector3 point)
		{
			return pos + rot * point;
		}

		public static Vector3 operator *(RigidTransform t, Vector3 v)
		{
			return t.TransformPoint(v);
		}

		public static RigidTransform Interpolate(RigidTransform a, RigidTransform b, float t)
		{
			return new RigidTransform(Vector3.Lerp(a.pos, b.pos, t), Quaternion.Slerp(a.rot, b.rot, t));
		}

		public void Interpolate(RigidTransform to, float t)
		{
			pos = Lerp(pos, to.pos, t);
			rot = Slerp(rot, to.rot, t);
		}
	}

	public delegate object SystemFn(CVRSystem system, params object[] args);

	public static Quaternion Slerp(Quaternion A, Quaternion B, float t)
	{
		float num = Mathf.Clamp(A.x * B.x + A.y * B.y + A.z * B.z + A.w * B.w, -1f, 1f);
		if (num < 0f)
		{
			B = new Quaternion(0f - B.x, 0f - B.y, 0f - B.z, 0f - B.w);
			num = 0f - num;
		}
		float num4;
		float num5;
		if (1f - num > 0.0001f)
		{
			float num2 = Mathf.Acos(num);
			float num3 = Mathf.Sin(num2);
			num4 = Mathf.Sin((1f - t) * num2) / num3;
			num5 = Mathf.Sin(t * num2) / num3;
		}
		else
		{
			num4 = 1f - t;
			num5 = t;
		}
		return new Quaternion(num4 * A.x + num5 * B.x, num4 * A.y + num5 * B.y, num4 * A.z + num5 * B.z, num4 * A.w + num5 * B.w);
	}

	public static Vector3 Lerp(Vector3 A, Vector3 B, float t)
	{
		return new Vector3(Lerp(A.x, B.x, t), Lerp(A.y, B.y, t), Lerp(A.z, B.z, t));
	}

	public static float Lerp(float A, float B, float t)
	{
		return A + (B - A) * t;
	}

	public static double Lerp(double A, double B, double t)
	{
		return A + (B - A) * t;
	}

	public static float InverseLerp(Vector3 A, Vector3 B, Vector3 result)
	{
		return Vector3.Dot(result - A, B - A);
	}

	public static float InverseLerp(float A, float B, float result)
	{
		return (result - A) / (B - A);
	}

	public static double InverseLerp(double A, double B, double result)
	{
		return (result - A) / (B - A);
	}

	public static float Saturate(float A)
	{
		if (!(A < 0f))
		{
			if (!(A > 1f))
			{
				return A;
			}
			return 1f;
		}
		return 0f;
	}

	public static Vector2 Saturate(Vector2 A)
	{
		return new Vector2(Saturate(A.x), Saturate(A.y));
	}

	public static float Abs(float A)
	{
		if (!(A < 0f))
		{
			return A;
		}
		return 0f - A;
	}

	public static Vector2 Abs(Vector2 A)
	{
		return new Vector2(Abs(A.x), Abs(A.y));
	}

	private static float _copysign(float sizeval, float signval)
	{
		if (Mathf.Sign(signval) != 1f)
		{
			return 0f - Mathf.Abs(sizeval);
		}
		return Mathf.Abs(sizeval);
	}

	public static Quaternion GetRotation(this Matrix4x4 matrix)
	{
		Quaternion result = default(Quaternion);
		result.w = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 + matrix.m11 + matrix.m22)) / 2f;
		result.x = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 - matrix.m11 - matrix.m22)) / 2f;
		result.y = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 + matrix.m11 - matrix.m22)) / 2f;
		result.z = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 - matrix.m11 + matrix.m22)) / 2f;
		result.x = _copysign(result.x, matrix.m21 - matrix.m12);
		result.y = _copysign(result.y, matrix.m02 - matrix.m20);
		result.z = _copysign(result.z, matrix.m10 - matrix.m01);
		return result;
	}

	public static Vector3 GetPosition(this Matrix4x4 matrix)
	{
		float m = matrix.m03;
		float m2 = matrix.m13;
		float m3 = matrix.m23;
		return new Vector3(m, m2, m3);
	}

	public static Vector3 GetScale(this Matrix4x4 m)
	{
		float x = Mathf.Sqrt(m.m00 * m.m00 + m.m01 * m.m01 + m.m02 * m.m02);
		float y = Mathf.Sqrt(m.m10 * m.m10 + m.m11 * m.m11 + m.m12 * m.m12);
		float z = Mathf.Sqrt(m.m20 * m.m20 + m.m21 * m.m21 + m.m22 * m.m22);
		return new Vector3(x, y, z);
	}

	public static object CallSystemFn(SystemFn fn, params object[] args)
	{
		bool flag = !SteamVR.active && !SteamVR.usingNativeSupport;
		if (flag)
		{
			EVRInitError peError = EVRInitError.None;
			OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
		}
		CVRSystem system = OpenVR.System;
		object result = ((system != null) ? fn(system, args) : null);
		if (flag)
		{
			OpenVR.Shutdown();
		}
		return result;
	}

	public static void TakeStereoScreenshot(uint screenshotHandle, GameObject target, int cellSize, float ipd, ref string previewFilename, ref string VRFilename)
	{
		Texture2D texture2D = new Texture2D(4096, 4096, TextureFormat.ARGB32, mipChain: false);
		Stopwatch stopwatch = new Stopwatch();
		Camera camera = null;
		stopwatch.Start();
		Camera camera2 = target.GetComponent<Camera>();
		if (camera2 == null)
		{
			if (camera == null)
			{
				camera = new GameObject().AddComponent<Camera>();
			}
			camera2 = camera;
		}
		Texture2D texture2D2 = new Texture2D(2048, 2048, TextureFormat.ARGB32, mipChain: false);
		RenderTexture renderTexture = new RenderTexture(2048, 2048, 24);
		RenderTexture targetTexture = camera2.targetTexture;
		bool orthographic = camera2.orthographic;
		float fieldOfView = camera2.fieldOfView;
		float aspect = camera2.aspect;
		StereoTargetEyeMask stereoTargetEye = camera2.stereoTargetEye;
		camera2.stereoTargetEye = StereoTargetEyeMask.None;
		camera2.fieldOfView = 60f;
		camera2.orthographic = false;
		camera2.targetTexture = renderTexture;
		camera2.aspect = 1f;
		camera2.Render();
		RenderTexture.active = renderTexture;
		texture2D2.ReadPixels(new Rect(0f, 0f, renderTexture.width, renderTexture.height), 0, 0);
		RenderTexture.active = null;
		camera2.targetTexture = null;
		UnityEngine.Object.DestroyImmediate(renderTexture);
		SteamVR_SphericalProjection steamVR_SphericalProjection = camera2.gameObject.AddComponent<SteamVR_SphericalProjection>();
		Vector3 localPosition = target.transform.localPosition;
		Quaternion localRotation = target.transform.localRotation;
		Vector3 position = target.transform.position;
		Quaternion quaternion = Quaternion.Euler(0f, target.transform.rotation.eulerAngles.y, 0f);
		Transform transform = camera2.transform;
		int num = 1024 / cellSize;
		float num2 = 90f / (float)num;
		float num3 = num2 / 2f;
		RenderTexture renderTexture2 = new RenderTexture(cellSize, cellSize, 24);
		renderTexture2.wrapMode = TextureWrapMode.Clamp;
		renderTexture2.antiAliasing = 8;
		camera2.fieldOfView = num2;
		camera2.orthographic = false;
		camera2.targetTexture = renderTexture2;
		camera2.aspect = aspect;
		camera2.stereoTargetEye = StereoTargetEyeMask.None;
		for (int i = 0; i < num; i++)
		{
			float num4 = 90f - (float)i * num2 - num3;
			int num5 = 4096 / renderTexture2.width;
			float num6 = 360f / (float)num5;
			float num7 = num6 / 2f;
			int num8 = i * 1024 / num;
			for (int j = 0; j < 2; j++)
			{
				if (j == 1)
				{
					num4 = 0f - num4;
					num8 = 2048 - num8 - cellSize;
				}
				for (int k = 0; k < num5; k++)
				{
					float num9 = -180f + (float)k * num6 + num7;
					int destX = k * 4096 / num5;
					int num10 = 0;
					float num11 = (0f - ipd) / 2f * Mathf.Cos(num4 * ((float)Math.PI / 180f));
					for (int l = 0; l < 2; l++)
					{
						if (l == 1)
						{
							num10 = 2048;
							num11 = 0f - num11;
						}
						Vector3 vector = quaternion * Quaternion.Euler(0f, num9, 0f) * new Vector3(num11, 0f, 0f);
						transform.position = position + vector;
						Quaternion quaternion2 = Quaternion.Euler(num4, num9, 0f);
						transform.rotation = quaternion * quaternion2;
						Vector3 vector2 = quaternion2 * Vector3.forward;
						float num12 = num9 - num6 / 2f;
						float num13 = num12 + num6;
						float num14 = num4 + num2 / 2f;
						float num15 = num14 - num2;
						float y = (num12 + num13) / 2f;
						float x = ((Mathf.Abs(num14) < Mathf.Abs(num15)) ? num14 : num15);
						Vector3 vector3 = Quaternion.Euler(x, num12, 0f) * Vector3.forward;
						Vector3 vector4 = Quaternion.Euler(x, num13, 0f) * Vector3.forward;
						Vector3 vector5 = Quaternion.Euler(num14, y, 0f) * Vector3.forward;
						Vector3 vector6 = Quaternion.Euler(num15, y, 0f) * Vector3.forward;
						Vector3 vector7 = vector3 / Vector3.Dot(vector3, vector2);
						Vector3 vector8 = vector4 / Vector3.Dot(vector4, vector2);
						Vector3 vector9 = vector5 / Vector3.Dot(vector5, vector2);
						Vector3 vector10 = vector6 / Vector3.Dot(vector6, vector2);
						Vector3 vector11 = vector8 - vector7;
						Vector3 vector12 = vector10 - vector9;
						float magnitude = vector11.magnitude;
						float magnitude2 = vector12.magnitude;
						float num16 = 1f / magnitude;
						float num17 = 1f / magnitude2;
						Vector3 uAxis = vector11 * num16;
						Vector3 vAxis = vector12 * num17;
						steamVR_SphericalProjection.Set(vector2, num12, num13, num14, num15, uAxis, vector7, num16, vAxis, vector9, num17);
						camera2.aspect = magnitude / magnitude2;
						camera2.Render();
						RenderTexture.active = renderTexture2;
						texture2D.ReadPixels(new Rect(0f, 0f, renderTexture2.width, renderTexture2.height), destX, num8 + num10);
						RenderTexture.active = null;
					}
					float flProgress = ((float)i * ((float)num5 * 2f) + (float)k + (float)(j * num5)) / ((float)num * ((float)num5 * 2f));
					OpenVR.Screenshots.UpdateScreenshotProgress(screenshotHandle, flProgress);
				}
			}
		}
		OpenVR.Screenshots.UpdateScreenshotProgress(screenshotHandle, 1f);
		previewFilename += ".png";
		VRFilename += ".png";
		texture2D2.Apply();
		File.WriteAllBytes(previewFilename, texture2D2.EncodeToPNG());
		texture2D.Apply();
		File.WriteAllBytes(VRFilename, texture2D.EncodeToPNG());
		if (camera2 != camera)
		{
			camera2.targetTexture = targetTexture;
			camera2.orthographic = orthographic;
			camera2.fieldOfView = fieldOfView;
			camera2.aspect = aspect;
			camera2.stereoTargetEye = stereoTargetEye;
			target.transform.localPosition = localPosition;
			target.transform.localRotation = localRotation;
		}
		else
		{
			camera.targetTexture = null;
		}
		UnityEngine.Object.DestroyImmediate(renderTexture2);
		UnityEngine.Object.DestroyImmediate(steamVR_SphericalProjection);
		stopwatch.Stop();
		UnityEngine.Debug.Log($"Screenshot took {stopwatch.Elapsed} seconds.");
		if (camera != null)
		{
			UnityEngine.Object.DestroyImmediate(camera.gameObject);
		}
		UnityEngine.Object.DestroyImmediate(texture2D2);
		UnityEngine.Object.DestroyImmediate(texture2D);
	}
}
namespace Valve.VR
{
	public struct IVRSystem
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetRecommendedRenderTargetSize(ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix44_t _GetProjectionMatrix(EVREye eEye, float fNearZ, float fFarZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetProjectionRaw(EVREye eEye, ref float pfLeft, ref float pfRight, ref float pfTop, ref float pfBottom);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ComputeDistortion(EVREye eEye, float fU, float fV, ref DistortionCoordinates_t pDistortionCoordinates);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetEyeToHeadTransform(EVREye eEye);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetTimeSinceLastVsync(ref float pfSecondsSinceLastVsync, ref ulong pulFrameCounter);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetD3D9AdapterIndex();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDXGIOutputInfo(ref int pnAdapterIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetOutputDevice(ref ulong pnDevice, ETextureType textureType, IntPtr pInstance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsDisplayOnDesktop();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _SetDisplayVisibility(bool bIsVisibleOnDesktop);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDeviceToAbsoluteTrackingPose(ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, [In][Out] TrackedDevicePose_t[] pTrackedDevicePoseArray, uint unTrackedDevicePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ResetSeatedZeroPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetSeatedZeroPoseToStandingAbsoluteTrackingPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetRawZeroPoseToStandingAbsoluteTrackingPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetSortedTrackedDeviceIndicesOfClass(ETrackedDeviceClass eTrackedDeviceClass, [In][Out] uint[] punTrackedDeviceIndexArray, uint unTrackedDeviceIndexArrayCount, uint unRelativeToTrackedDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EDeviceActivityLevel _GetTrackedDeviceActivityLevel(uint unDeviceId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ApplyTransform(ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pTrackedDevicePose, ref HmdMatrix34_t pTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole unDeviceType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackedControllerRole _GetControllerRoleForTrackedDeviceIndex(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackedDeviceClass _GetTrackedDeviceClass(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsTrackedDeviceConnected(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetBoolTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFloatTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetInt32TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetUint64TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetMatrix34TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetArrayTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, uint propType, IntPtr pBuffer, uint unBufferSize, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetStringTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, StringBuilder pchValue, uint unBufferSize, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetPropErrorNameFromEnum(ETrackedPropertyError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEvent(ref VREvent_t pEvent, uint uncbVREvent);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEventWithPose(ETrackingUniverseOrigin eOrigin, ref VREvent_t pEvent, uint uncbVREvent, ref TrackedDevicePose_t pTrackedDevicePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetEventTypeNameFromEnum(EVREventType eType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HiddenAreaMesh_t _GetHiddenAreaMesh(EVREye eEye, EHiddenAreaMeshType type);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerState(uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStateWithPose(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _TriggerHapticPulse(uint unControllerDeviceIndex, uint unAxisId, char usDurationMicroSec);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetButtonIdNameFromEnum(EVRButtonId eButtonId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetControllerAxisTypeNameFromEnum(EVRControllerAxisType eAxisType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsInputAvailable();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsSteamVRDrawingControllers();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldApplicationPause();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldApplicationReduceRenderingWork();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _DriverDebugRequest(uint unDeviceIndex, string pchRequest, StringBuilder pchResponseBuffer, uint unResponseBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRFirmwareError _PerformFirmwareUpdate(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _AcknowledgeQuit_Exiting();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _AcknowledgeQuit_UserPrompt();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRecommendedRenderTargetSize GetRecommendedRenderTargetSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetProjectionMatrix GetProjectionMatrix;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetProjectionRaw GetProjectionRaw;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ComputeDistortion ComputeDistortion;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEyeToHeadTransform GetEyeToHeadTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTimeSinceLastVsync GetTimeSinceLastVsync;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetD3D9AdapterIndex GetD3D9AdapterIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDXGIOutputInfo GetDXGIOutputInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOutputDevice GetOutputDevice;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsDisplayOnDesktop IsDisplayOnDesktop;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDisplayVisibility SetDisplayVisibility;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDeviceToAbsoluteTrackingPose GetDeviceToAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ResetSeatedZeroPose ResetSeatedZeroPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSeatedZeroPoseToStandingAbsoluteTrackingPose GetSeatedZeroPoseToStandingAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRawZeroPoseToStandingAbsoluteTrackingPose GetRawZeroPoseToStandingAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSortedTrackedDeviceIndicesOfClass GetSortedTrackedDeviceIndicesOfClass;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceActivityLevel GetTrackedDeviceActivityLevel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ApplyTransform ApplyTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceIndexForControllerRole GetTrackedDeviceIndexForControllerRole;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerRoleForTrackedDeviceIndex GetControllerRoleForTrackedDeviceIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceClass GetTrackedDeviceClass;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsTrackedDeviceConnected IsTrackedDeviceConnected;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBoolTrackedDeviceProperty GetBoolTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFloatTrackedDeviceProperty GetFloatTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetInt32TrackedDeviceProperty GetInt32TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetUint64TrackedDeviceProperty GetUint64TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMatrix34TrackedDeviceProperty GetMatrix34TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetArrayTrackedDeviceProperty GetArrayTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetStringTrackedDeviceProperty GetStringTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPropErrorNameFromEnum GetPropErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextEvent PollNextEvent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextEventWithPose PollNextEventWithPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEventTypeNameFromEnum GetEventTypeNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetHiddenAreaMesh GetHiddenAreaMesh;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerState GetControllerState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerStateWithPose GetControllerStateWithPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _TriggerHapticPulse TriggerHapticPulse;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetButtonIdNameFromEnum GetButtonIdNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerAxisTypeNameFromEnum GetControllerAxisTypeNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsInputAvailable IsInputAvailable;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsSteamVRDrawingControllers IsSteamVRDrawingControllers;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldApplicationPause ShouldApplicationPause;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldApplicationReduceRenderingWork ShouldApplicationReduceRenderingWork;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _DriverDebugRequest DriverDebugRequest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PerformFirmwareUpdate PerformFirmwareUpdate;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcknowledgeQuit_Exiting AcknowledgeQuit_Exiting;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcknowledgeQuit_UserPrompt AcknowledgeQuit_UserPrompt;
	}
	public struct IVRExtendedDisplay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetWindowBounds(ref int pnX, ref int pnY, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetEyeOutputViewport(EVREye eEye, ref uint pnX, ref uint pnY, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDXGIOutputInfo(ref int pnAdapterIndex, ref int pnAdapterOutputIndex);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWindowBounds GetWindowBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEyeOutputViewport GetEyeOutputViewport;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDXGIOutputInfo GetDXGIOutputInfo;
	}
	public struct IVRTrackedCamera
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetCameraErrorNameFromEnum(EVRTrackedCameraError eCameraError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _HasCamera(uint nDeviceIndex, ref bool pHasCamera);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraFrameSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref uint pnWidth, ref uint pnHeight, ref uint pnFrameBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraIntrinsics(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref HmdVector2_t pFocalLength, ref HmdVector2_t pCenter);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraProjection(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, ref HmdMatrix44_t pProjection);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _AcquireVideoStreamingService(uint nDeviceIndex, ref ulong pHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _ReleaseVideoStreamingService(ulong hTrackedCamera);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamFrameBuffer(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pFrameBuffer, uint nFrameBufferSize, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref VRTextureBounds_t pTextureBounds, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureD3D11(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureGL(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, ref uint pglTextureId, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _ReleaseVideoStreamTextureGL(ulong hTrackedCamera, uint glTextureId);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraErrorNameFromEnum GetCameraErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HasCamera HasCamera;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraFrameSize GetCameraFrameSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraIntrinsics GetCameraIntrinsics;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraProjection GetCameraProjection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcquireVideoStreamingService AcquireVideoStreamingService;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseVideoStreamingService ReleaseVideoStreamingService;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamFrameBuffer GetVideoStreamFrameBuffer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureSize GetVideoStreamTextureSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureD3D11 GetVideoStreamTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureGL GetVideoStreamTextureGL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseVideoStreamTextureGL ReleaseVideoStreamTextureGL;
	}
	public struct IVRApplications
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _AddApplicationManifest(string pchApplicationManifestFullPath, bool bTemporary);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _RemoveApplicationManifest(string pchApplicationManifestFullPath);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsApplicationInstalled(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetApplicationKeyByIndex(uint unApplicationIndex, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetApplicationKeyByProcessId(uint unProcessId, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchApplication(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchTemplateApplication(string pchTemplateAppKey, string pchNewAppKey, [In][Out] AppOverrideKeys_t[] pKeys, uint unKeys);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchApplicationFromMimeType(string pchMimeType, string pchArgs);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchDashboardOverlay(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CancelApplicationLaunch(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _IdentifyApplication(uint unProcessId, string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationProcessId(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetApplicationsErrorNameFromEnum(EVRApplicationError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationPropertyString(string pchAppKey, EVRApplicationProperty eProperty, StringBuilder pchPropertyValueBuffer, uint unPropertyValueBufferLen, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationPropertyBool(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetApplicationPropertyUint64(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _SetApplicationAutoLaunch(string pchAppKey, bool bAutoLaunch);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationAutoLaunch(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _SetDefaultApplicationForMimeType(string pchAppKey, string pchMimeType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetDefaultApplicationForMimeType(string pchMimeType, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationSupportedMimeTypes(string pchAppKey, StringBuilder pchMimeTypesBuffer, uint unMimeTypesBuffer);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationsThatSupportMimeType(string pchMimeType, StringBuilder pchAppKeysThatSupportBuffer, uint unAppKeysThatSupportBuffer);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationLaunchArguments(uint unHandle, StringBuilder pchArgs, uint unArgs);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetStartingApplication(StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationTransitionState _GetTransitionState();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _PerformApplicationPrelaunchCheck(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetApplicationsTransitionStateNameFromEnum(EVRApplicationTransitionState state);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsQuitUserPromptRequested();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchInternalProcess(string pchBinaryPath, string pchArguments, string pchWorkingDirectory);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetCurrentSceneProcessId();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AddApplicationManifest AddApplicationManifest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveApplicationManifest RemoveApplicationManifest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsApplicationInstalled IsApplicationInstalled;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationCount GetApplicationCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationKeyByIndex GetApplicationKeyByIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationKeyByProcessId GetApplicationKeyByProcessId;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchApplication LaunchApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchTemplateApplication LaunchTemplateApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchApplicationFromMimeType LaunchApplicationFromMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchDashboardOverlay LaunchDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CancelApplicationLaunch CancelApplicationLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IdentifyApplication IdentifyApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationProcessId GetApplicationProcessId;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsErrorNameFromEnum GetApplicationsErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyString GetApplicationPropertyString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyBool GetApplicationPropertyBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyUint64 GetApplicationPropertyUint64;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetApplicationAutoLaunch SetApplicationAutoLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationAutoLaunch GetApplicationAutoLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDefaultApplicationForMimeType SetDefaultApplicationForMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDefaultApplicationForMimeType GetDefaultApplicationForMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationSupportedMimeTypes GetApplicationSupportedMimeTypes;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsThatSupportMimeType GetApplicationsThatSupportMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationLaunchArguments GetApplicationLaunchArguments;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetStartingApplication GetStartingApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTransitionState GetTransitionState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PerformApplicationPrelaunchCheck PerformApplicationPrelaunchCheck;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsTransitionStateNameFromEnum GetApplicationsTransitionStateNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsQuitUserPromptRequested IsQuitUserPromptRequested;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchInternalProcess LaunchInternalProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentSceneProcessId GetCurrentSceneProcessId;
	}
	public struct IVRChaperone
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ChaperoneCalibrationState _GetCalibrationState();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetPlayAreaSize(ref float pSizeX, ref float pSizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetPlayAreaRect(ref HmdQuad_t rect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReloadInfo();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetSceneColor(HmdColor_t color);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetBoundsColor(ref HmdColor_t pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, ref HmdColor_t pOutputCameraColor);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _AreBoundsVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceBoundsVisible(bool bForce);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCalibrationState GetCalibrationState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPlayAreaSize GetPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPlayAreaRect GetPlayAreaRect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReloadInfo ReloadInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetSceneColor SetSceneColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBoundsColor GetBoundsColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AreBoundsVisible AreBoundsVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceBoundsVisible ForceBoundsVisible;
	}
	public struct IVRChaperoneSetup
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CommitWorkingCopy(EChaperoneConfigFile configFile);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RevertWorkingCopy();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingPlayAreaSize(ref float pSizeX, ref float pSizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingPlayAreaRect(ref HmdQuad_t rect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatStandingZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingPlayAreaSize(float sizeX, float sizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, uint unQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatStandingZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReloadFromDisk(EChaperoneConfigFile configFile);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingCollisionBoundsTagsInfo([In][Out] byte[] pTagsBuffer, uint unTagCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveCollisionBoundsTagsInfo([In][Out] byte[] pTagsBuffer, ref uint punTagCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _SetWorkingPhysicalBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, uint unQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLivePhysicalBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ExportLiveToBuffer(StringBuilder pBuffer, ref uint pnBufferLength);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ImportFromBufferToWorking(string pBuffer, uint nImportFlags);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CommitWorkingCopy CommitWorkingCopy;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RevertWorkingCopy RevertWorkingCopy;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingPlayAreaSize GetWorkingPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingPlayAreaRect GetWorkingPlayAreaRect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingCollisionBoundsInfo GetWorkingCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveCollisionBoundsInfo GetLiveCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingSeatedZeroPoseToRawTrackingPose GetWorkingSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingStandingZeroPoseToRawTrackingPose GetWorkingStandingZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingPlayAreaSize SetWorkingPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingCollisionBoundsInfo SetWorkingCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingSeatedZeroPoseToRawTrackingPose SetWorkingSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingStandingZeroPoseToRawTrackingPose SetWorkingStandingZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReloadFromDisk ReloadFromDisk;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveSeatedZeroPoseToRawTrackingPose GetLiveSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingCollisionBoundsTagsInfo SetWorkingCollisionBoundsTagsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveCollisionBoundsTagsInfo GetLiveCollisionBoundsTagsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingPhysicalBoundsInfo SetWorkingPhysicalBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLivePhysicalBoundsInfo GetLivePhysicalBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ExportLiveToBuffer ExportLiveToBuffer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ImportFromBufferToWorking ImportFromBufferToWorking;
	}
	public struct IVRCompositor
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetTrackingSpace(ETrackingUniverseOrigin eOrigin);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackingUniverseOrigin _GetTrackingSpace();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _WaitGetPoses([In][Out] TrackedDevicePose_t[] pRenderPoseArray, uint unRenderPoseArrayCount, [In][Out] TrackedDevicePose_t[] pGamePoseArray, uint unGamePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetLastPoses([In][Out] TrackedDevicePose_t[] pRenderPoseArray, uint unRenderPoseArrayCount, [In][Out] TrackedDevicePose_t[] pGamePoseArray, uint unGamePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetLastPoseForTrackedDeviceIndex(uint unDeviceIndex, ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pOutputGamePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _Submit(EVREye eEye, ref Texture_t pTexture, ref VRTextureBounds_t pBounds, EVRSubmitFlags nSubmitFlags);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ClearLastSubmittedFrame();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _PostPresentHandoff();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetFrameTiming(ref Compositor_FrameTiming pTiming, uint unFramesAgo);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetFrameTimings(ref Compositor_FrameTiming pTiming, uint nFrames);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFrameTimeRemaining();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetCumulativeStats(ref Compositor_CumulativeStats pStats, uint nStatsSizeInBytes);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FadeToColor(float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdColor_t _GetCurrentFadeColor(bool bBackground);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FadeGrid(float fSeconds, bool bFadeIn);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetCurrentGridAlpha();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _SetSkyboxOverride([In][Out] Texture_t[] pTextures, uint unTextureCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ClearSkyboxOverride();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorBringToFront();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorGoToBack();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorQuit();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsFullscreen();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetCurrentSceneFocusProcess();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetLastFrameRenderer();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CanRenderScene();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ShowMirrorWindow();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _HideMirrorWindow();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsMirrorWindowVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorDumpImages();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldAppRenderWithLowResources();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceInterleavedReprojectionOn(bool bOverride);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceReconnectProcess();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SuspendRendering(bool bSuspend);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetMirrorTextureD3D11(EVREye eEye, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReleaseMirrorTextureD3D11(IntPtr pD3D11ShaderResourceView);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetMirrorTextureGL(EVREye eEye, ref uint pglTextureId, IntPtr pglSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ReleaseSharedGLTexture(uint glTextureId, IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _LockGLSharedTextureForAccess(IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _UnlockGLSharedTextureForAccess(IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetVulkanInstanceExtensionsRequired(StringBuilder pchValue, uint unBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetVulkanDeviceExtensionsRequired(IntPtr pPhysicalDevice, StringBuilder pchValue, uint unBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetExplicitTimingMode(EVRCompositorTimingMode eTimingMode);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _SubmitExplicitTimingData();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetTrackingSpace SetTrackingSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackingSpace GetTrackingSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _WaitGetPoses WaitGetPoses;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastPoses GetLastPoses;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastPoseForTrackedDeviceIndex GetLastPoseForTrackedDeviceIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _Submit Submit;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearLastSubmittedFrame ClearLastSubmittedFrame;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PostPresentHandoff PostPresentHandoff;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTiming GetFrameTiming;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTimings GetFrameTimings;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTimeRemaining GetFrameTimeRemaining;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCumulativeStats GetCumulativeStats;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FadeToColor FadeToColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentFadeColor GetCurrentFadeColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FadeGrid FadeGrid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentGridAlpha GetCurrentGridAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetSkyboxOverride SetSkyboxOverride;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearSkyboxOverride ClearSkyboxOverride;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorBringToFront CompositorBringToFront;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorGoToBack CompositorGoToBack;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorQuit CompositorQuit;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsFullscreen IsFullscreen;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentSceneFocusProcess GetCurrentSceneFocusProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastFrameRenderer GetLastFrameRenderer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CanRenderScene CanRenderScene;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowMirrorWindow ShowMirrorWindow;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideMirrorWindow HideMirrorWindow;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsMirrorWindowVisible IsMirrorWindowVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorDumpImages CompositorDumpImages;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldAppRenderWithLowResources ShouldAppRenderWithLowResources;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceInterleavedReprojectionOn ForceInterleavedReprojectionOn;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceReconnectProcess ForceReconnectProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SuspendRendering SuspendRendering;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMirrorTextureD3D11 GetMirrorTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseMirrorTextureD3D11 ReleaseMirrorTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMirrorTextureGL GetMirrorTextureGL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseSharedGLTexture ReleaseSharedGLTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LockGLSharedTextureForAccess LockGLSharedTextureForAccess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _UnlockGLSharedTextureForAccess UnlockGLSharedTextureForAccess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVulkanInstanceExtensionsRequired GetVulkanInstanceExtensionsRequired;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVulkanDeviceExtensionsRequired GetVulkanDeviceExtensionsRequired;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetExplicitTimingMode SetExplicitTimingMode;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SubmitExplicitTimingData SubmitExplicitTimingData;
	}
	public struct IVROverlay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _FindOverlay(string pchOverlayKey, ref ulong pOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _CreateOverlay(string pchOverlayKey, string pchOverlayName, ref ulong pOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _DestroyOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetHighQualityOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetHighQualityOverlay();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayKey(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayName(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayName(ulong ulOverlayHandle, string pchName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayImageData(ulong ulOverlayHandle, IntPtr pvBuffer, uint unBufferSize, ref uint punWidth, ref uint punHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetOverlayErrorNameFromEnum(EVROverlayError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRenderingPid(ulong ulOverlayHandle, uint unPID);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayRenderingPid(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, bool bEnabled);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, ref bool pbEnabled);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayColor(ulong ulOverlayHandle, float fRed, float fGreen, float fBlue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayColor(ulong ulOverlayHandle, ref float pfRed, ref float pfGreen, ref float pfBlue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayAlpha(ulong ulOverlayHandle, float fAlpha);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayAlpha(ulong ulOverlayHandle, ref float pfAlpha);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTexelAspect(ulong ulOverlayHandle, float fTexelAspect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTexelAspect(ulong ulOverlayHandle, ref float pfTexelAspect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlaySortOrder(ulong ulOverlayHandle, uint unSortOrder);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlaySortOrder(ulong ulOverlayHandle, ref uint punSortOrder);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayWidthInMeters(ulong ulOverlayHandle, float fWidthInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayWidthInMeters(ulong ulOverlayHandle, ref float pfWidthInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, float fMinDistanceInMeters, float fMaxDistanceInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, ref float pfMinDistanceInMeters, ref float pfMaxDistanceInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTextureColorSpace(ulong ulOverlayHandle, EColorSpace eTextureColorSpace);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureColorSpace(ulong ulOverlayHandle, ref EColorSpace peTextureColorSpace);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayRenderModel(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref HmdColor_t pColor, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRenderModel(ulong ulOverlayHandle, string pchRenderModel, ref HmdColor_t pColor);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformType(ulong ulOverlayHandle, ref VROverlayTransformType peTransformType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformAbsolute(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformAbsolute(ulong ulOverlayHandle, ref ETrackingUniverseOrigin peTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, uint unTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, ref uint punTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, uint unDeviceIndex, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, ref uint punDeviceIndex, StringBuilder pchComponentName, uint unComponentNameSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ref ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _HideOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsOverlayVisible(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetTransformForOverlayCoordinates(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, HmdVector2_t coordinatesInOverlay, ref HmdMatrix34_t pmatTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextOverlayEvent(ulong ulOverlayHandle, ref VREvent_t pEvent, uint uncbVREvent);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayInputMethod(ulong ulOverlayHandle, ref VROverlayInputMethod peInputMethod);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayInputMethod(ulong ulOverlayHandle, VROverlayInputMethod eInputMethod);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ComputeOverlayIntersection(ulong ulOverlayHandle, ref VROverlayIntersectionParams_t pParams, ref VROverlayIntersectionResults_t pResults);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsHoverTargetOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetGamepadFocusOverlay();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetGamepadFocusOverlay(ulong ulNewFocusOverlay);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayNeighbor(EOverlayDirection eDirection, ulong ulFrom, ulong ulTo);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _MoveGamepadFocusToNeighbor(EOverlayDirection eDirection, ulong ulFrom);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, IntPtr vCenter, float fRadius);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, ref HmdVector2_t pvCenter, ref float pfRadius);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTexture(ulong ulOverlayHandle, ref Texture_t pTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ClearOverlayTexture(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRaw(ulong ulOverlayHandle, IntPtr pvBuffer, uint unWidth, uint unHeight, uint unDepth);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayFromFile(ulong ulOverlayHandle, string pchFilePath);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTexture(ulong ulOverlayHandle, ref IntPtr pNativeTextureHandle, IntPtr pNativeTextureRef, ref uint pWidth, ref uint pHeight, ref uint pNativeFormat, ref ETextureType pAPIType, ref EColorSpace pColorSpace, ref VRTextureBounds_t pTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ReleaseNativeOverlayHandle(ulong ulOverlayHandle, IntPtr pNativeTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureSize(ulong ulOverlayHandle, ref uint pWidth, ref uint pHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _CreateDashboardOverlay(string pchOverlayKey, string pchOverlayFriendlyName, ref ulong pMainHandle, ref ulong pThumbnailHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsDashboardVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsActiveDashboardOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetDashboardOverlaySceneProcess(ulong ulOverlayHandle, uint unProcessId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetDashboardOverlaySceneProcess(ulong ulOverlayHandle, ref uint punProcessId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ShowDashboard(string pchOverlayToShow);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetPrimaryDashboardDevice();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowKeyboard(int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowKeyboardForOverlay(ulong ulOverlayHandle, int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetKeyboardText(StringBuilder pchText, uint cchText);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _HideKeyboard();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetKeyboardTransformAbsolute(ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToKeyboardTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetKeyboardPositionForOverlay(ulong ulOverlayHandle, HmdRect2_t avoidRect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayIntersectionMask(ulong ulOverlayHandle, ref VROverlayIntersectionMaskPrimitive_t pMaskPrimitives, uint unNumMaskPrimitives, uint unPrimitiveSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayFlags(ulong ulOverlayHandle, ref uint pFlags);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate VRMessageOverlayResponse _ShowMessageOverlay(string pchText, string pchCaption, string pchButton0Text, string pchButton1Text, string pchButton2Text, string pchButton3Text);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CloseMessageOverlay();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FindOverlay FindOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateOverlay CreateOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _DestroyOverlay DestroyOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetHighQualityOverlay SetHighQualityOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetHighQualityOverlay GetHighQualityOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayKey GetOverlayKey;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayName GetOverlayName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayName SetOverlayName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayImageData GetOverlayImageData;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayErrorNameFromEnum GetOverlayErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRenderingPid SetOverlayRenderingPid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayRenderingPid GetOverlayRenderingPid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayFlag SetOverlayFlag;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayFlag GetOverlayFlag;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayColor SetOverlayColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayColor GetOverlayColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayAlpha SetOverlayAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayAlpha GetOverlayAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTexelAspect SetOverlayTexelAspect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTexelAspect GetOverlayTexelAspect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlaySortOrder SetOverlaySortOrder;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlaySortOrder GetOverlaySortOrder;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayWidthInMeters SetOverlayWidthInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayWidthInMeters GetOverlayWidthInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayAutoCurveDistanceRangeInMeters SetOverlayAutoCurveDistanceRangeInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayAutoCurveDistanceRangeInMeters GetOverlayAutoCurveDistanceRangeInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTextureColorSpace SetOverlayTextureColorSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureColorSpace GetOverlayTextureColorSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTextureBounds SetOverlayTextureBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureBounds GetOverlayTextureBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayRenderModel GetOverlayRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRenderModel SetOverlayRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformType GetOverlayTransformType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformAbsolute SetOverlayTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformAbsolute GetOverlayTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformTrackedDeviceRelative SetOverlayTransformTrackedDeviceRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformTrackedDeviceRelative GetOverlayTransformTrackedDeviceRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformTrackedDeviceComponent SetOverlayTransformTrackedDeviceComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformTrackedDeviceComponent GetOverlayTransformTrackedDeviceComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformOverlayRelative GetOverlayTransformOverlayRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformOverlayRelative SetOverlayTransformOverlayRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowOverlay ShowOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideOverlay HideOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsOverlayVisible IsOverlayVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTransformForOverlayCoordinates GetTransformForOverlayCoordinates;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextOverlayEvent PollNextOverlayEvent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayInputMethod GetOverlayInputMethod;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayInputMethod SetOverlayInputMethod;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayMouseScale GetOverlayMouseScale;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayMouseScale SetOverlayMouseScale;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ComputeOverlayIntersection ComputeOverlayIntersection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsHoverTargetOverlay IsHoverTargetOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetGamepadFocusOverlay GetGamepadFocusOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetGamepadFocusOverlay SetGamepadFocusOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayNeighbor SetOverlayNeighbor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _MoveGamepadFocusToNeighbor MoveGamepadFocusToNeighbor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayDualAnalogTransform SetOverlayDualAnalogTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayDualAnalogTransform GetOverlayDualAnalogTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTexture SetOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearOverlayTexture ClearOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRaw SetOverlayRaw;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayFromFile SetOverlayFromFile;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTexture GetOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseNativeOverlayHandle ReleaseNativeOverlayHandle;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureSize GetOverlayTextureSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateDashboardOverlay CreateDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsDashboardVisible IsDashboardVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsActiveDashboardOverlay IsActiveDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDashboardOverlaySceneProcess SetDashboardOverlaySceneProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDashboardOverlaySceneProcess GetDashboardOverlaySceneProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowDashboard ShowDashboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPrimaryDashboardDevice GetPrimaryDashboardDevice;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowKeyboard ShowKeyboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowKeyboardForOverlay ShowKeyboardForOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetKeyboardText GetKeyboardText;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideKeyboard HideKeyboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetKeyboardTransformAbsolute SetKeyboardTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetKeyboardPositionForOverlay SetKeyboardPositionForOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayIntersectionMask SetOverlayIntersectionMask;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayFlags GetOverlayFlags;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowMessageOverlay ShowMessageOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CloseMessageOverlay CloseMessageOverlay;
	}
	public struct IVRRenderModels
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadRenderModel_Async(string pchRenderModelName, ref IntPtr ppRenderModel);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeRenderModel(IntPtr pRenderModel);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadTexture_Async(int textureId, ref IntPtr ppTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeTexture(IntPtr pTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadTextureD3D11_Async(int textureId, IntPtr pD3D11Device, ref IntPtr ppD3D11Texture2D);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadIntoTextureD3D11_Async(int textureId, IntPtr pDstTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeTextureD3D11(IntPtr pD3D11Texture2D);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelName(uint unRenderModelIndex, StringBuilder pchRenderModelName, uint unRenderModelNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentCount(string pchRenderModelName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentName(string pchRenderModelName, uint unComponentIndex, StringBuilder pchComponentName, uint unComponentNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetComponentButtonMask(string pchRenderModelName, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentRenderModelName(string pchRenderModelName, string pchComponentName, StringBuilder pchComponentRenderModelName, uint unComponentRenderModelNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetComponentState(string pchRenderModelName, string pchComponentName, ref VRControllerState_t pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _RenderModelHasComponent(string pchRenderModelName, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelThumbnailURL(string pchRenderModelName, StringBuilder pchThumbnailURL, uint unThumbnailURLLen, ref EVRRenderModelError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelOriginalPath(string pchRenderModelName, StringBuilder pchOriginalPath, uint unOriginalPathLen, ref EVRRenderModelError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetRenderModelErrorNameFromEnum(EVRRenderModelError error);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadRenderModel_Async LoadRenderModel_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeRenderModel FreeRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadTexture_Async LoadTexture_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeTexture FreeTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadTextureD3D11_Async LoadTextureD3D11_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadIntoTextureD3D11_Async LoadIntoTextureD3D11_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeTextureD3D11 FreeTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelName GetRenderModelName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelCount GetRenderModelCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentCount GetComponentCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentName GetComponentName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentButtonMask GetComponentButtonMask;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentRenderModelName GetComponentRenderModelName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentState GetComponentState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RenderModelHasComponent RenderModelHasComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelThumbnailURL GetRenderModelThumbnailURL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelOriginalPath GetRenderModelOriginalPath;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelErrorNameFromEnum GetRenderModelErrorNameFromEnum;
	}
	public struct IVRNotifications
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRNotificationError _CreateNotification(ulong ulOverlayHandle, ulong ulUserValue, EVRNotificationType type, string pchText, EVRNotificationStyle style, ref NotificationBitmap_t pImage, ref uint pNotificationId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRNotificationError _RemoveNotification(uint notificationId);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateNotification CreateNotification;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveNotification RemoveNotification;
	}
	public struct IVRSettings
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetSettingsErrorNameFromEnum(EVRSettingsError eError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _Sync(bool bForce, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetBool(string pchSection, string pchSettingsKey, bool bValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetInt32(string pchSection, string pchSettingsKey, int nValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetFloat(string pchSection, string pchSettingsKey, float flValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetString(string pchSection, string pchSettingsKey, string pchValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetBool(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetInt32(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFloat(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetString(string pchSection, string pchSettingsKey, StringBuilder pchValue, uint unValueLen, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RemoveSection(string pchSection, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RemoveKeyInSection(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSettingsErrorNameFromEnum GetSettingsErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _Sync Sync;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetBool SetBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetInt32 SetInt32;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetFloat SetFloat;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetString SetString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBool GetBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetInt32 GetInt32;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFloat GetFloat;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetString GetString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveSection RemoveSection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveKeyInSection RemoveKeyInSection;
	}
	public struct IVRScreenshots
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _RequestScreenshot(ref uint pOutScreenshotHandle, EVRScreenshotType type, string pchPreviewFilename, string pchVRFilename);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _HookScreenshot([In][Out] EVRScreenshotType[] pSupportedTypes, int numTypes);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotType _GetScreenshotPropertyType(uint screenshotHandle, ref EVRScreenshotError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetScreenshotPropertyFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames filenameType, StringBuilder pchFilename, uint cchFilename, ref EVRScreenshotError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _UpdateScreenshotProgress(uint screenshotHandle, float flProgress);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _TakeStereoScreenshot(ref uint pOutScreenshotHandle, string pchPreviewFilename, string pchVRFilename);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _SubmitScreenshot(uint screenshotHandle, EVRScreenshotType type, string pchSourcePreviewFilename, string pchSourceVRFilename);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RequestScreenshot RequestScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HookScreenshot HookScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetScreenshotPropertyType GetScreenshotPropertyType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetScreenshotPropertyFilename GetScreenshotPropertyFilename;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _UpdateScreenshotProgress UpdateScreenshotProgress;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _TakeStereoScreenshot TakeStereoScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SubmitScreenshot SubmitScreenshot;
	}
	public struct IVRResources
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _LoadSharedResource(string pchResourceName, string pchBuffer, uint unBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetResourceFullPath(string pchResourceName, string pchResourceTypeDirectory, StringBuilder pchPathBuffer, uint unBufferLen);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadSharedResource LoadSharedResource;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetResourceFullPath GetResourceFullPath;
	}
	public struct IVRDriverManager
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetDriverCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetDriverName(uint nDriver, StringBuilder pchValue, uint unBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetDriverHandle(string pchDriverName);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDriverCount GetDriverCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDriverName GetDriverName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDriverHandle GetDriverHandle;
	}
	public class CVRSystem
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEventPacked(ref VREvent_t_Packed pEvent, uint uncbVREvent);

		[StructLayout(LayoutKind.Explicit)]
		private struct PollNextEventUnion
		{
			[FieldOffset(0)]
			public IVRSystem._PollNextEvent pPollNextEvent;

			[FieldOffset(0)]
			public _PollNextEventPacked pPollNextEventPacked;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStatePacked(uint unControllerDeviceIndex, ref VRControllerState_t_Packed pControllerState, uint unControllerStateSize);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetControllerStateUnion
		{
			[FieldOffset(0)]
			public IVRSystem._GetControllerState pGetControllerState;

			[FieldOffset(0)]
			public _GetControllerStatePacked pGetControllerStatePacked;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStateWithPosePacked(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t_Packed pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetControllerStateWithPoseUnion
		{
			[FieldOffset(0)]
			public IVRSystem._GetControllerStateWithPose pGetControllerStateWithPose;

			[FieldOffset(0)]
			public _GetControllerStateWithPosePacked pGetControllerStateWithPosePacked;
		}

		private IVRSystem FnTable;

		internal CVRSystem(IntPtr pInterface)
		{
			FnTable = (IVRSystem)Marshal.PtrToStructure(pInterface, typeof(IVRSystem));
		}

		public void GetRecommendedRenderTargetSize(ref uint pnWidth, ref uint pnHeight)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetRecommendedRenderTargetSize(ref pnWidth, ref pnHeight);
		}

		public HmdMatrix44_t GetProjectionMatrix(EVREye eEye, float fNearZ, float fFarZ)
		{
			return FnTable.GetProjectionMatrix(eEye, fNearZ, fFarZ);
		}

		public void GetProjectionRaw(EVREye eEye, ref float pfLeft, ref float pfRight, ref float pfTop, ref float pfBottom)
		{
			pfLeft = 0f;
			pfRight = 0f;
			pfTop = 0f;
			pfBottom = 0f;
			FnTable.GetProjectionRaw(eEye, ref pfLeft, ref pfRight, ref pfTop, ref pfBottom);
		}

		public bool ComputeDistortion(EVREye eEye, float fU, float fV, ref DistortionCoordinates_t pDistortionCoordinates)
		{
			return FnTable.ComputeDistortion(eEye, fU, fV, ref pDistortionCoordinates);
		}

		public HmdMatrix34_t GetEyeToHeadTransform(EVREye eEye)
		{
			return FnTable.GetEyeToHeadTransform(eEye);
		}

		public bool GetTimeSinceLastVsync(ref float pfSecondsSinceLastVsync, ref ulong pulFrameCounter)
		{
			pfSecondsSinceLastVsync = 0f;
			pulFrameCounter = 0uL;
			return FnTable.GetTimeSinceLastVsync(ref pfSecondsSinceLastVsync, ref pulFrameCounter);
		}

		public int GetD3D9AdapterIndex()
		{
			return FnTable.GetD3D9AdapterIndex();
		}

		public void GetDXGIOutputInfo(ref int pnAdapterIndex)
		{
			pnAdapterIndex = 0;
			FnTable.GetDXGIOutputInfo(ref pnAdapterIndex);
		}

		public void GetOutputDevice(ref ulong pnDevice, ETextureType textureType, IntPtr pInstance)
		{
			pnDevice = 0uL;
			FnTable.GetOutputDevice(ref pnDevice, textureType, pInstance);
		}

		public bool IsDisplayOnDesktop()
		{
			return FnTable.IsDisplayOnDesktop();
		}

		public bool SetDisplayVisibility(bool bIsVisibleOnDesktop)
		{
			return FnTable.SetDisplayVisibility(bIsVisibleOnDesktop);
		}

		public void GetDeviceToAbsoluteTrackingPose(ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, TrackedDevicePose_t[] pTrackedDevicePoseArray)
		{
			FnTable.GetDeviceToAbsoluteTrackingPose(eOrigin, fPredictedSecondsToPhotonsFromNow, pTrackedDevicePoseArray, (uint)pTrackedDevicePoseArray.Length);
		}

		public void ResetSeatedZeroPose()
		{
			FnTable.ResetSeatedZeroPose();
		}

		public HmdMatrix34_t GetSeatedZeroPoseToStandingAbsoluteTrackingPose()
		{
			return FnTable.GetSeatedZeroPoseToStandingAbsoluteTrackingPose();
		}

		public HmdMatrix34_t GetRawZeroPoseToStandingAbsoluteTrackingPose()
		{
			return FnTable.GetRawZeroPoseToStandingAbsoluteTrackingPose();
		}

		public uint GetSortedTrackedDeviceIndicesOfClass(ETrackedDeviceClass eTrackedDeviceClass, uint[] punTrackedDeviceIndexArray, uint unRelativeToTrackedDeviceIndex)
		{
			return FnTable.GetSortedTrackedDeviceIndicesOfClass(eTrackedDeviceClass, punTrackedDeviceIndexArray, (uint)punTrackedDeviceIndexArray.Length, unRelativeToTrackedDeviceIndex);
		}

		public EDeviceActivityLevel GetTrackedDeviceActivityLevel(uint unDeviceId)
		{
			return FnTable.GetTrackedDeviceActivityLevel(unDeviceId);
		}

		public void ApplyTransform(ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pTrackedDevicePose, ref HmdMatrix34_t pTransform)
		{
			FnTable.ApplyTransform(ref pOutputPose, ref pTrackedDevicePose, ref pTransform);
		}

		public uint GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole unDeviceType)
		{
			return FnTable.GetTrackedDeviceIndexForControllerRole(unDeviceType);
		}

		public ETrackedControllerRole GetControllerRoleForTrackedDeviceIndex(uint unDeviceIndex)
		{
			return FnTable.GetControllerRoleForTrackedDeviceIndex(unDeviceIndex);
		}

		public ETrackedDeviceClass GetTrackedDeviceClass(uint unDeviceIndex)
		{
			return FnTable.GetTrackedDeviceClass(unDeviceIndex);
		}

		public bool IsTrackedDeviceConnected(uint unDeviceIndex)
		{
			return FnTable.IsTrackedDeviceConnected(unDeviceIndex);
		}

		public bool GetBoolTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetBoolTrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public float GetFloatTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetFloatTrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public int GetInt32TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetInt32TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public ulong GetUint64TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetUint64TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public HmdMatrix34_t GetMatrix34TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetMatrix34TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public uint GetArrayTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, uint propType, IntPtr pBuffer, uint unBufferSize, ref ETrackedPropertyError pError)
		{
			return FnTable.GetArrayTrackedDeviceProperty(unDeviceIndex, prop, propType, pBuffer, unBufferSize, ref pError);
		}

		public uint GetStringTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, StringBuilder pchValue, uint unBufferSize, ref ETrackedPropertyError pError)
		{
			return FnTable.GetStringTrackedDeviceProperty(unDeviceIndex, prop, pchValue, unBufferSize, ref pError);
		}

		public string GetPropErrorNameFromEnum(ETrackedPropertyError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetPropErrorNameFromEnum(error));
		}

		public bool PollNextEvent(ref VREvent_t pEvent, uint uncbVREvent)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VREvent_t_Packed pEvent2 = default(VREvent_t_Packed);
				PollNextEventUnion pollNextEventUnion = default(PollNextEventUnion);
				pollNextEventUnion.pPollNextEventPacked = null;
				pollNextEventUnion.pPollNextEvent = FnTable.PollNextEvent;
				bool result = pollNextEventUnion.pPollNextEventPacked(ref pEvent2, (uint)Marshal.SizeOf(typeof(VREvent_t_Packed)));
				pEvent2.Unpack(ref pEvent);
				return result;
			}
			return FnTable.PollNextEvent(ref pEvent, uncbVREvent);
		}

		public bool PollNextEventWithPose(ETrackingUniverseOrigin eOrigin, ref VREvent_t pEvent, uint uncbVREvent, ref TrackedDevicePose_t pTrackedDevicePose)
		{
			return FnTable.PollNextEventWithPose(eOrigin, ref pEvent, uncbVREvent, ref pTrackedDevicePose);
		}

		public string GetEventTypeNameFromEnum(EVREventType eType)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetEventTypeNameFromEnum(eType));
		}

		public HiddenAreaMesh_t GetHiddenAreaMesh(EVREye eEye, EHiddenAreaMeshType type)
		{
			return FnTable.GetHiddenAreaMesh(eEye, type);
		}

		public bool GetControllerState(uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetControllerStateUnion getControllerStateUnion = default(GetControllerStateUnion);
				getControllerStateUnion.pGetControllerStatePacked = null;
				getControllerStateUnion.pGetControllerState = FnTable.GetControllerState;
				bool result = getControllerStateUnion.pGetControllerStatePacked(unControllerDeviceIndex, ref pControllerState2, (uint)Marshal.SizeOf(typeof(VRControllerState_t_Packed)));
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetControllerState(unControllerDeviceIndex, ref pControllerState, unControllerStateSize);
		}

		public bool GetControllerStateWithPose(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetControllerStateWithPoseUnion getControllerStateWithPoseUnion = default(GetControllerStateWithPoseUnion);
				getControllerStateWithPoseUnion.pGetControllerStateWithPosePacked = null;
				getControllerStateWithPoseUnion.pGetControllerStateWithPose = FnTable.GetControllerStateWithPose;
				bool result = getControllerStateWithPoseUnion.pGetControllerStateWithPosePacked(eOrigin, unControllerDeviceIndex, ref pControllerState2, (uint)Marshal.SizeOf(typeof(VRControllerState_t_Packed)), ref pTrackedDevicePose);
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetControllerStateWithPose(eOrigin, unControllerDeviceIndex, ref pControllerState, unControllerStateSize, ref pTrackedDevicePose);
		}

		public void TriggerHapticPulse(uint unControllerDeviceIndex, uint unAxisId, char usDurationMicroSec)
		{
			FnTable.TriggerHapticPulse(unControllerDeviceIndex, unAxisId, usDurationMicroSec);
		}

		public string GetButtonIdNameFromEnum(EVRButtonId eButtonId)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetButtonIdNameFromEnum(eButtonId));
		}

		public string GetControllerAxisTypeNameFromEnum(EVRControllerAxisType eAxisType)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetControllerAxisTypeNameFromEnum(eAxisType));
		}

		public bool IsInputAvailable()
		{
			return FnTable.IsInputAvailable();
		}

		public bool IsSteamVRDrawingControllers()
		{
			return FnTable.IsSteamVRDrawingControllers();
		}

		public bool ShouldApplicationPause()
		{
			return FnTable.ShouldApplicationPause();
		}

		public bool ShouldApplicationReduceRenderingWork()
		{
			return FnTable.ShouldApplicationReduceRenderingWork();
		}

		public uint DriverDebugRequest(uint unDeviceIndex, string pchRequest, StringBuilder pchResponseBuffer, uint unResponseBufferSize)
		{
			return FnTable.DriverDebugRequest(unDeviceIndex, pchRequest, pchResponseBuffer, unResponseBufferSize);
		}

		public EVRFirmwareError PerformFirmwareUpdate(uint unDeviceIndex)
		{
			return FnTable.PerformFirmwareUpdate(unDeviceIndex);
		}

		public void AcknowledgeQuit_Exiting()
		{
			FnTable.AcknowledgeQuit_Exiting();
		}

		public void AcknowledgeQuit_UserPrompt()
		{
			FnTable.AcknowledgeQuit_UserPrompt();
		}
	}
	public class CVRExtendedDisplay
	{
		private IVRExtendedDisplay FnTable;

		internal CVRExtendedDisplay(IntPtr pInterface)
		{
			FnTable = (IVRExtendedDisplay)Marshal.PtrToStructure(pInterface, typeof(IVRExtendedDisplay));
		}

		public void GetWindowBounds(ref int pnX, ref int pnY, ref uint pnWidth, ref uint pnHeight)
		{
			pnX = 0;
			pnY = 0;
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetWindowBounds(ref pnX, ref pnY, ref pnWidth, ref pnHeight);
		}

		public void GetEyeOutputViewport(EVREye eEye, ref uint pnX, ref uint pnY, ref uint pnWidth, ref uint pnHeight)
		{
			pnX = 0u;
			pnY = 0u;
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetEyeOutputViewport(eEye, ref pnX, ref pnY, ref pnWidth, ref pnHeight);
		}

		public void GetDXGIOutputInfo(ref int pnAdapterIndex, ref int pnAdapterOutputIndex)
		{
			pnAdapterIndex = 0;
			pnAdapterOutputIndex = 0;
			FnTable.GetDXGIOutputInfo(ref pnAdapterIndex, ref pnAdapterOutputIndex);
		}
	}
	public class CVRTrackedCamera
	{
		private IVRTrackedCamera FnTable;

		internal CVRTrackedCamera(IntPtr pInterface)
		{
			FnTable = (IVRTrackedCamera)Marshal.PtrToStructure(pInterface, typeof(IVRTrackedCamera));
		}

		public string GetCameraErrorNameFromEnum(EVRTrackedCameraError eCameraError)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetCameraErrorNameFromEnum(eCameraError));
		}

		public EVRTrackedCameraError HasCamera(uint nDeviceIndex, ref bool pHasCamera)
		{
			pHasCamera = false;
			return FnTable.HasCamera(nDeviceIndex, ref pHasCamera);
		}

		public EVRTrackedCameraError GetCameraFrameSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref uint pnWidth, ref uint pnHeight, ref uint pnFrameBufferSize)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			pnFrameBufferSize = 0u;
			return FnTable.GetCameraFrameSize(nDeviceIndex, eFrameType, ref pnWidth, ref pnHeight, ref pnFrameBufferSize);
		}

		public EVRTrackedCameraError GetCameraIntrinsics(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref HmdVector2_t pFocalLength, ref HmdVector2_t pCenter)
		{
			return FnTable.GetCameraIntrinsics(nDeviceIndex, eFrameType, ref pFocalLength, ref pCenter);
		}

		public EVRTrackedCameraError GetCameraProjection(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, ref HmdMatrix44_t pProjection)
		{
			return FnTable.GetCameraProjection(nDeviceIndex, eFrameType, flZNear, flZFar, ref pProjection);
		}

		public EVRTrackedCameraError AcquireVideoStreamingService(uint nDeviceIndex, ref ulong pHandle)
		{
			pHandle = 0uL;
			return FnTable.AcquireVideoStreamingService(nDeviceIndex, ref pHandle);
		}

		public EVRTrackedCameraError ReleaseVideoStreamingService(ulong hTrackedCamera)
		{
			return FnTable.ReleaseVideoStreamingService(hTrackedCamera);
		}

		public EVRTrackedCameraError GetVideoStreamFrameBuffer(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pFrameBuffer, uint nFrameBufferSize, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			return FnTable.GetVideoStreamFrameBuffer(hTrackedCamera, eFrameType, pFrameBuffer, nFrameBufferSize, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError GetVideoStreamTextureSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref VRTextureBounds_t pTextureBounds, ref uint pnWidth, ref uint pnHeight)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			return FnTable.GetVideoStreamTextureSize(nDeviceIndex, eFrameType, ref pTextureBounds, ref pnWidth, ref pnHeight);
		}

		public EVRTrackedCameraError GetVideoStreamTextureD3D11(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			return FnTable.GetVideoStreamTextureD3D11(hTrackedCamera, eFrameType, pD3D11DeviceOrResource, ref ppD3D11ShaderResourceView, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError GetVideoStreamTextureGL(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, ref uint pglTextureId, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			pglTextureId = 0u;
			return FnTable.GetVideoStreamTextureGL(hTrackedCamera, eFrameType, ref pglTextureId, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError ReleaseVideoStreamTextureGL(ulong hTrackedCamera, uint glTextureId)
		{
			return FnTable.ReleaseVideoStreamTextureGL(hTrackedCamera, glTextureId);
		}
	}
	public class CVRApplications
	{
		private IVRApplications FnTable;

		internal CVRApplications(IntPtr pInterface)
		{
			FnTable = (IVRApplications)Marshal.PtrToStructure(pInterface, typeof(IVRApplications));
		}

		public EVRApplicationError AddApplicationManifest(string pchApplicationManifestFullPath, bool bTemporary)
		{
			return FnTable.AddApplicationManifest(pchApplicationManifestFullPath, bTemporary);
		}

		public EVRApplicationError RemoveApplicationManifest(string pchApplicationManifestFullPath)
		{
			return FnTable.RemoveApplicationManifest(pchApplicationManifestFullPath);
		}

		public bool IsApplicationInstalled(string pchAppKey)
		{
			return FnTable.IsApplicationInstalled(pchAppKey);
		}

		public uint GetApplicationCount()
		{
			return FnTable.GetApplicationCount();
		}

		public EVRApplicationError GetApplicationKeyByIndex(uint unApplicationIndex, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetApplicationKeyByIndex(unApplicationIndex, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationError GetApplicationKeyByProcessId(uint unProcessId, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetApplicationKeyByProcessId(unProcessId, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationError LaunchApplication(string pchAppKey)
		{
			return FnTable.LaunchApplication(pchAppKey);
		}

		public EVRApplicationError LaunchTemplateApplication(string pchTemplateAppKey, string pchNewAppKey, AppOverrideKeys_t[] pKeys)
		{
			return FnTable.LaunchTemplateApplication(pchTemplateAppKey, pchNewAppKey, pKeys, (uint)pKeys.Length);
		}

		public EVRApplicationError LaunchApplicationFromMimeType(string pchMimeType, string pchArgs)
		{
			return FnTable.LaunchApplicationFromMimeType(pchMimeType, pchArgs);
		}

		public EVRApplicationError LaunchDashboardOverlay(string pchAppKey)
		{
			return FnTable.LaunchDashboardOverlay(pchAppKey);
		}

		public bool CancelApplicationLaunch(string pchAppKey)
		{
			return FnTable.CancelApplicationLaunch(pchAppKey);
		}

		public EVRApplicationError IdentifyApplication(uint unProcessId, string pchAppKey)
		{
			return FnTable.IdentifyApplication(unProcessId, pchAppKey);
		}

		public uint GetApplicationProcessId(string pchAppKey)
		{
			return FnTable.GetApplicationProcessId(pchAppKey);
		}

		public string GetApplicationsErrorNameFromEnum(EVRApplicationError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetApplicationsErrorNameFromEnum(error));
		}

		public uint GetApplicationPropertyString(string pchAppKey, EVRApplicationProperty eProperty, StringBuilder pchPropertyValueBuffer, uint unPropertyValueBufferLen, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyString(pchAppKey, eProperty, pchPropertyValueBuffer, unPropertyValueBufferLen, ref peError);
		}

		public bool GetApplicationPropertyBool(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyBool(pchAppKey, eProperty, ref peError);
		}

		public ulong GetApplicationPropertyUint64(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyUint64(pchAppKey, eProperty, ref peError);
		}

		public EVRApplicationError SetApplicationAutoLaunch(string pchAppKey, bool bAutoLaunch)
		{
			return FnTable.SetApplicationAutoLaunch(pchAppKey, bAutoLaunch);
		}

		public bool GetApplicationAutoLaunch(string pchAppKey)
		{
			return FnTable.GetApplicationAutoLaunch(pchAppKey);
		}

		public EVRApplicationError SetDefaultApplicationForMimeType(string pchAppKey, string pchMimeType)
		{
			return FnTable.SetDefaultApplicationForMimeType(pchAppKey, pchMimeType);
		}

		public bool GetDefaultApplicationForMimeType(string pchMimeType, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetDefaultApplicationForMimeType(pchMimeType, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public bool GetApplicationSupportedMimeTypes(string pchAppKey, StringBuilder pchMimeTypesBuffer, uint unMimeTypesBuffer)
		{
			return FnTable.GetApplicationSupportedMimeTypes(pchAppKey, pchMimeTypesBuffer, unMimeTypesBuffer);
		}

		public uint GetApplicationsThatSupportMimeType(string pchMimeType, StringBuilder pchAppKeysThatSupportBuffer, uint unAppKeysThatSupportBuffer)
		{
			return FnTable.GetApplicationsThatSupportMimeType(pchMimeType, pchAppKeysThatSupportBuffer, unAppKeysThatSupportBuffer);
		}

		public uint GetApplicationLaunchArguments(uint unHandle, StringBuilder pchArgs, uint unArgs)
		{
			return FnTable.GetApplicationLaunchArguments(unHandle, pchArgs, unArgs);
		}

		public EVRApplicationError GetStartingApplication(StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetStartingApplication(pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationTransitionState GetTransitionState()
		{
			return FnTable.GetTransitionState();
		}

		public EVRApplicationError PerformApplicationPrelaunchCheck(string pchAppKey)
		{
			return FnTable.PerformApplicationPrelaunchCheck(pchAppKey);
		}

		public string GetApplicationsTransitionStateNameFromEnum(EVRApplicationTransitionState state)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetApplicationsTransitionStateNameFromEnum(state));
		}

		public bool IsQuitUserPromptRequested()
		{
			return FnTable.IsQuitUserPromptRequested();
		}

		public EVRApplicationError LaunchInternalProcess(string pchBinaryPath, string pchArguments, string pchWorkingDirectory)
		{
			return FnTable.LaunchInternalProcess(pchBinaryPath, pchArguments, pchWorkingDirectory);
		}

		public uint GetCurrentSceneProcessId()
		{
			return FnTable.GetCurrentSceneProcessId();
		}
	}
	public class CVRChaperone
	{
		private IVRChaperone FnTable;

		internal CVRChaperone(IntPtr pInterface)
		{
			FnTable = (IVRChaperone)Marshal.PtrToStructure(pInterface, typeof(IVRChaperone));
		}

		public ChaperoneCalibrationState GetCalibrationState()
		{
			return FnTable.GetCalibrationState();
		}

		public bool GetPlayAreaSize(ref float pSizeX, ref float pSizeZ)
		{
			pSizeX = 0f;
			pSizeZ = 0f;
			return FnTable.GetPlayAreaSize(ref pSizeX, ref pSizeZ);
		}

		public bool GetPlayAreaRect(ref HmdQuad_t rect)
		{
			return FnTable.GetPlayAreaRect(ref rect);
		}

		public void ReloadInfo()
		{
			FnTable.ReloadInfo();
		}

		public void SetSceneColor(HmdColor_t color)
		{
			FnTable.SetSceneColor(color);
		}

		public void GetBoundsColor(ref HmdColor_t pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, ref HmdColor_t pOutputCameraColor)
		{
			FnTable.GetBoundsColor(ref pOutputColorArray, nNumOutputColors, flCollisionBoundsFadeDistance, ref pOutputCameraColor);
		}

		public bool AreBoundsVisible()
		{
			return FnTable.AreBoundsVisible();
		}

		public void ForceBoundsVisible(bool bForce)
		{
			FnTable.ForceBoundsVisible(bForce);
		}
	}
	public class CVRChaperoneSetup
	{
		private IVRChaperoneSetup FnTable;

		internal CVRChaperoneSetup(IntPtr pInterface)
		{
			FnTable = (IVRChaperoneSetup)Marshal.PtrToStructure(pInterface, typeof(IVRChaperoneSetup));
		}

		public bool CommitWorkingCopy(EChaperoneConfigFile configFile)
		{
			return FnTable.CommitWorkingCopy(configFile);
		}

		public void RevertWorkingCopy()
		{
			FnTable.RevertWorkingCopy();
		}

		public bool GetWorkingPlayAreaSize(ref float pSizeX, ref float pSizeZ)
		{
			pSizeX = 0f;
			pSizeZ = 0f;
			return FnTable.GetWorkingPlayAreaSize(ref pSizeX, ref pSizeZ);
		}

		public bool GetWorkingPlayAreaRect(ref HmdQuad_t rect)
		{
			return FnTable.GetWorkingPlayAreaRect(ref rect);
		}

		public bool GetWorkingCollisionBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetWorkingCollisionBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetWorkingCollisionBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool GetLiveCollisionBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetLiveCollisionBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetLiveCollisionBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool GetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose)
		{
			return FnTable.GetWorkingSeatedZeroPoseToRawTrackingPose(ref pmatSeatedZeroPoseToRawTrackingPose);
		}

		public bool GetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatStandingZeroPoseToRawTrackingPose)
		{
			return FnTable.GetWorkingStandingZeroPoseToRawTrackingPose(ref pmatStandingZeroPoseToRawTrackingPose);
		}

		public void SetWorkingPlayAreaSize(float sizeX, float sizeZ)
		{
			FnTable.SetWorkingPlayAreaSize(sizeX, sizeZ);
		}

		public void SetWorkingCollisionBoundsInfo(HmdQuad_t[] pQuadsBuffer)
		{
			FnTable.SetWorkingCollisionBoundsInfo(pQuadsBuffer, (uint)pQuadsBuffer.Length);
		}

		public void SetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatSeatedZeroPoseToRawTrackingPose)
		{
			FnTable.SetWorkingSeatedZeroPoseToRawTrackingPose(ref pMatSeatedZeroPoseToRawTrackingPose);
		}

		public void SetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatStandingZeroPoseToRawTrackingPose)
		{
			FnTable.SetWorkingStandingZeroPoseToRawTrackingPose(ref pMatStandingZeroPoseToRawTrackingPose);
		}

		public void ReloadFromDisk(EChaperoneConfigFile configFile)
		{
			FnTable.ReloadFromDisk(configFile);
		}

		public bool GetLiveSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose)
		{
			return FnTable.GetLiveSeatedZeroPoseToRawTrackingPose(ref pmatSeatedZeroPoseToRawTrackingPose);
		}

		public void SetWorkingCollisionBoundsTagsInfo(byte[] pTagsBuffer)
		{
			FnTable.SetWorkingCollisionBoundsTagsInfo(pTagsBuffer, (uint)pTagsBuffer.Length);
		}

		public bool GetLiveCollisionBoundsTagsInfo(out byte[] pTagsBuffer)
		{
			uint punTagCount = 0u;
			FnTable.GetLiveCollisionBoundsTagsInfo(null, ref punTagCount);
			pTagsBuffer = new byte[punTagCount];
			return FnTable.GetLiveCollisionBoundsTagsInfo(pTagsBuffer, ref punTagCount);
		}

		public bool SetWorkingPhysicalBoundsInfo(HmdQuad_t[] pQuadsBuffer)
		{
			return FnTable.SetWorkingPhysicalBoundsInfo(pQuadsBuffer, (uint)pQuadsBuffer.Length);
		}

		public bool GetLivePhysicalBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetLivePhysicalBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetLivePhysicalBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool ExportLiveToBuffer(StringBuilder pBuffer, ref uint pnBufferLength)
		{
			pnBufferLength = 0u;
			return FnTable.ExportLiveToBuffer(pBuffer, ref pnBufferLength);
		}

		public bool ImportFromBufferToWorking(string pBuffer, uint nImportFlags)
		{
			return FnTable.ImportFromBufferToWorking(pBuffer, nImportFlags);
		}
	}
	public class CVRCompositor
	{
		private IVRCompositor FnTable;

		internal CVRCompositor(IntPtr pInterface)
		{
			FnTable = (IVRCompositor)Marshal.PtrToStructure(pInterface, typeof(IVRCompositor));
		}

		public void SetTrackingSpace(ETrackingUniverseOrigin eOrigin)
		{
			FnTable.SetTrackingSpace(eOrigin);
		}

		public ETrackingUniverseOrigin GetTrackingSpace()
		{
			return FnTable.GetTrackingSpace();
		}

		public EVRCompositorError WaitGetPoses(TrackedDevicePose_t[] pRenderPoseArray, TrackedDevicePose_t[] pGamePoseArray)
		{
			return FnTable.WaitGetPoses(pRenderPoseArray, (uint)pRenderPoseArray.Length, pGamePoseArray, (uint)pGamePoseArray.Length);
		}

		public EVRCompositorError GetLastPoses(TrackedDevicePose_t[] pRenderPoseArray, TrackedDevicePose_t[] pGamePoseArray)
		{
			return FnTable.GetLastPoses(pRenderPoseArray, (uint)pRenderPoseArray.Length, pGamePoseArray, (uint)pGamePoseArray.Length);
		}

		public EVRCompositorError GetLastPoseForTrackedDeviceIndex(uint unDeviceIndex, ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pOutputGamePose)
		{
			return FnTable.GetLastPoseForTrackedDeviceIndex(unDeviceIndex, ref pOutputPose, ref pOutputGamePose);
		}

		public EVRCompositorError Submit(EVREye eEye, ref Texture_t pTexture, ref VRTextureBounds_t pBounds, EVRSubmitFlags nSubmitFlags)
		{
			return FnTable.Submit(eEye, ref pTexture, ref pBounds, nSubmitFlags);
		}

		public void ClearLastSubmittedFrame()
		{
			FnTable.ClearLastSubmittedFrame();
		}

		public void PostPresentHandoff()
		{
			FnTable.PostPresentHandoff();
		}

		public bool GetFrameTiming(ref Compositor_FrameTiming pTiming, uint unFramesAgo)
		{
			return FnTable.GetFrameTiming(ref pTiming, unFramesAgo);
		}

		public uint GetFrameTimings(ref Compositor_FrameTiming pTiming, uint nFrames)
		{
			return FnTable.GetFrameTimings(ref pTiming, nFrames);
		}

		public float GetFrameTimeRemaining()
		{
			return FnTable.GetFrameTimeRemaining();
		}

		public void GetCumulativeStats(ref Compositor_CumulativeStats pStats, uint nStatsSizeInBytes)
		{
			FnTable.GetCumulativeStats(ref pStats, nStatsSizeInBytes);
		}

		public void FadeToColor(float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground)
		{
			FnTable.FadeToColor(fSeconds, fRed, fGreen, fBlue, fAlpha, bBackground);
		}

		public HmdColor_t GetCurrentFadeColor(bool bBackground)
		{
			return FnTable.GetCurrentFadeColor(bBackground);
		}

		public void FadeGrid(float fSeconds, bool bFadeIn)
		{
			FnTable.FadeGrid(fSeconds, bFadeIn);
		}

		public float GetCurrentGridAlpha()
		{
			return FnTable.GetCurrentGridAlpha();
		}

		public EVRCompositorError SetSkyboxOverride(Texture_t[] pTextures)
		{
			return FnTable.SetSkyboxOverride(pTextures, (uint)pTextures.Length);
		}

		public void ClearSkyboxOverride()
		{
			FnTable.ClearSkyboxOverride();
		}

		public void CompositorBringToFront()
		{
			FnTable.CompositorBringToFront();
		}

		public void CompositorGoToBack()
		{
			FnTable.CompositorGoToBack();
		}

		public void CompositorQuit()
		{
			FnTable.CompositorQuit();
		}

		public bool IsFullscreen()
		{
			return FnTable.IsFullscreen();
		}

		public uint GetCurrentSceneFocusProcess()
		{
			return FnTable.GetCurrentSceneFocusProcess();
		}

		public uint GetLastFrameRenderer()
		{
			return FnTable.GetLastFrameRenderer();
		}

		public bool CanRenderScene()
		{
			return FnTable.CanRenderScene();
		}

		public void ShowMirrorWindow()
		{
			FnTable.ShowMirrorWindow();
		}

		public void HideMirrorWindow()
		{
			FnTable.HideMirrorWindow();
		}

		public bool IsMirrorWindowVisible()
		{
			return FnTable.IsMirrorWindowVisible();
		}

		public void CompositorDumpImages()
		{
			FnTable.CompositorDumpImages();
		}

		public bool ShouldAppRenderWithLowResources()
		{
			return FnTable.ShouldAppRenderWithLowResources();
		}

		public void ForceInterleavedReprojectionOn(bool bOverride)
		{
			FnTable.ForceInterleavedReprojectionOn(bOverride);
		}

		public void ForceReconnectProcess()
		{
			FnTable.ForceReconnectProcess();
		}

		public void SuspendRendering(bool bSuspend)
		{
			FnTable.SuspendRendering(bSuspend);
		}

		public EVRCompositorError GetMirrorTextureD3D11(EVREye eEye, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView)
		{
			return FnTable.GetMirrorTextureD3D11(eEye, pD3D11DeviceOrResource, ref ppD3D11ShaderResourceView);
		}

		public void ReleaseMirrorTextureD3D11(IntPtr pD3D11ShaderResourceView)
		{
			FnTable.ReleaseMirrorTextureD3D11(pD3D11ShaderResourceView);
		}

		public EVRCompositorError GetMirrorTextureGL(EVREye eEye, ref uint pglTextureId, IntPtr pglSharedTextureHandle)
		{
			pglTextureId = 0u;
			return FnTable.GetMirrorTextureGL(eEye, ref pglTextureId, pglSharedTextureHandle);
		}

		public bool ReleaseSharedGLTexture(uint glTextureId, IntPtr glSharedTextureHandle)
		{
			return FnTable.ReleaseSharedGLTexture(glTextureId, glSharedTextureHandle);
		}

		public void LockGLSharedTextureForAccess(IntPtr glSharedTextureHandle)
		{
			FnTable.LockGLSharedTextureForAccess(glSharedTextureHandle);
		}

		public void UnlockGLSharedTextureForAccess(IntPtr glSharedTextureHandle)
		{
			FnTable.UnlockGLSharedTextureForAccess(glSharedTextureHandle);
		}

		public uint GetVulkanInstanceExtensionsRequired(StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetVulkanInstanceExtensionsRequired(pchValue, unBufferSize);
		}

		public uint GetVulkanDeviceExtensionsRequired(IntPtr pPhysicalDevice, StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetVulkanDeviceExtensionsRequired(pPhysicalDevice, pchValue, unBufferSize);
		}

		public void SetExplicitTimingMode(EVRCompositorTimingMode eTimingMode)
		{
			FnTable.SetExplicitTimingMode(eTimingMode);
		}

		public EVRCompositorError SubmitExplicitTimingData()
		{
			return FnTable.SubmitExplicitTimingData();
		}
	}
	public class CVROverlay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextOverlayEventPacked(ulong ulOverlayHandle, ref VREvent_t_Packed pEvent, uint uncbVREvent);

		[StructLayout(LayoutKind.Explicit)]
		private struct PollNextOverlayEventUnion
		{
			[FieldOffset(0)]
			public IVROverlay._PollNextOverlayEvent pPollNextOverlayEvent;

			[FieldOffset(0)]
			public _PollNextOverlayEventPacked pPollNextOverlayEventPacked;
		}

		private IVROverlay FnTable;

		internal CVROverlay(IntPtr pInterface)
		{
			FnTable = (IVROverlay)Marshal.PtrToStructure(pInterface, typeof(IVROverlay));
		}

		public EVROverlayError FindOverlay(string pchOverlayKey, ref ulong pOverlayHandle)
		{
			pOverlayHandle = 0uL;
			return FnTable.FindOverlay(pchOverlayKey, ref pOverlayHandle);
		}

		public EVROverlayError CreateOverlay(string pchOverlayKey, string pchOverlayName, ref ulong pOverlayHandle)
		{
			pOverlayHandle = 0uL;
			return FnTable.CreateOverlay(pchOverlayKey, pchOverlayName, ref pOverlayHandle);
		}

		public EVROverlayError DestroyOverlay(ulong ulOverlayHandle)
		{
			return FnTable.DestroyOverlay(ulOverlayHandle);
		}

		public EVROverlayError SetHighQualityOverlay(ulong ulOverlayHandle)
		{
			return FnTable.SetHighQualityOverlay(ulOverlayHandle);
		}

		public ulong GetHighQualityOverlay()
		{
			return FnTable.GetHighQualityOverlay();
		}

		public uint GetOverlayKey(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayKey(ulOverlayHandle, pchValue, unBufferSize, ref pError);
		}

		public uint GetOverlayName(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayName(ulOverlayHandle, pchValue, unBufferSize, ref pError);
		}

		public EVROverlayError SetOverlayName(ulong ulOverlayHandle, string pchName)
		{
			return FnTable.SetOverlayName(ulOverlayHandle, pchName);
		}

		public EVROverlayError GetOverlayImageData(ulong ulOverlayHandle, IntPtr pvBuffer, uint unBufferSize, ref uint punWidth, ref uint punHeight)
		{
			punWidth = 0u;
			punHeight = 0u;
			return FnTable.GetOverlayImageData(ulOverlayHandle, pvBuffer, unBufferSize, ref punWidth, ref punHeight);
		}

		public string GetOverlayErrorNameFromEnum(EVROverlayError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetOverlayErrorNameFromEnum(error));
		}

		public EVROverlayError SetOverlayRenderingPid(ulong ulOverlayHandle, uint unPID)
		{
			return FnTable.SetOverlayRenderingPid(ulOverlayHandle, unPID);
		}

		public uint GetOverlayRenderingPid(ulong ulOverlayHandle)
		{
			return FnTable.GetOverlayRenderingPid(ulOverlayHandle);
		}

		public EVROverlayError SetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, bool bEnabled)
		{
			return FnTable.SetOverlayFlag(ulOverlayHandle, eOverlayFlag, bEnabled);
		}

		public EVROverlayError GetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, ref bool pbEnabled)
		{
			pbEnabled = false;
			return FnTable.GetOverlayFlag(ulOverlayHandle, eOverlayFlag, ref pbEnabled);
		}

		public EVROverlayError SetOverlayColor(ulong ulOverlayHandle, float fRed, float fGreen, float fBlue)
		{
			return FnTable.SetOverlayColor(ulOverlayHandle, fRed, fGreen, fBlue);
		}

		public EVROverlayError GetOverlayColor(ulong ulOverlayHandle, ref float pfRed, ref float pfGreen, ref float pfBlue)
		{
			pfRed = 0f;
			pfGreen = 0f;
			pfBlue = 0f;
			return FnTable.GetOverlayColor(ulOverlayHandle, ref pfRed, ref pfGreen, ref pfBlue);
		}

		public EVROverlayError SetOverlayAlpha(ulong ulOverlayHandle, float fAlpha)
		{
			return FnTable.SetOverlayAlpha(ulOverlayHandle, fAlpha);
		}

		public EVROverlayError GetOverlayAlpha(ulong ulOverlayHandle, ref float pfAlpha)
		{
			pfAlpha = 0f;
			return FnTable.GetOverlayAlpha(ulOverlayHandle, ref pfAlpha);
		}

		public EVROverlayError SetOverlayTexelAspect(ulong ulOverlayHandle, float fTexelAspect)
		{
			return FnTable.SetOverlayTexelAspect(ulOverlayHandle, fTexelAspect);
		}

		public EVROverlayError GetOverlayTexelAspect(ulong ulOverlayHandle, ref float pfTexelAspect)
		{
			pfTexelAspect = 0f;
			return FnTable.GetOverlayTexelAspect(ulOverlayHandle, ref pfTexelAspect);
		}

		public EVROverlayError SetOverlaySortOrder(ulong ulOverlayHandle, uint unSortOrder)
		{
			return FnTable.SetOverlaySortOrder(ulOverlayHandle, unSortOrder);
		}

		public EVROverlayError GetOverlaySortOrder(ulong ulOverlayHandle, ref uint punSortOrder)
		{
			punSortOrder = 0u;
			return FnTable.GetOverlaySortOrder(ulOverlayHandle, ref punSortOrder);
		}

		public EVROverlayError SetOverlayWidthInMeters(ulong ulOverlayHandle, float fWidthInMeters)
		{
			return FnTable.SetOverlayWidthInMeters(ulOverlayHandle, fWidthInMeters);
		}

		public EVROverlayError GetOverlayWidthInMeters(ulong ulOverlayHandle, ref float pfWidthInMeters)
		{
			pfWidthInMeters = 0f;
			return FnTable.GetOverlayWidthInMeters(ulOverlayHandle, ref pfWidthInMeters);
		}

		public EVROverlayError SetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, float fMinDistanceInMeters, float fMaxDistanceInMeters)
		{
			return FnTable.SetOverlayAutoCurveDistanceRangeInMeters(ulOverlayHandle, fMinDistanceInMeters, fMaxDistanceInMeters);
		}

		public EVROverlayError GetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, ref float pfMinDistanceInMeters, ref float pfMaxDistanceInMeters)
		{
			pfMinDistanceInMeters = 0f;
			pfMaxDistanceInMeters = 0f;
			return FnTable.GetOverlayAutoCurveDistanceRangeInMeters(ulOverlayHandle, ref pfMinDistanceInMeters, ref pfMaxDistanceInMeters);
		}

		public EVROverlayError SetOverlayTextureColorSpace(ulong ulOverlayHandle, EColorSpace eTextureColorSpace)
		{
			return FnTable.SetOverlayTextureColorSpace(ulOverlayHandle, eTextureColorSpace);
		}

		public EVROverlayError GetOverlayTextureColorSpace(ulong ulOverlayHandle, ref EColorSpace peTextureColorSpace)
		{
			return FnTable.GetOverlayTextureColorSpace(ulOverlayHandle, ref peTextureColorSpace);
		}

		public EVROverlayError SetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds)
		{
			return FnTable.SetOverlayTextureBounds(ulOverlayHandle, ref pOverlayTextureBounds);
		}

		public EVROverlayError GetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds)
		{
			return FnTable.GetOverlayTextureBounds(ulOverlayHandle, ref pOverlayTextureBounds);
		}

		public uint GetOverlayRenderModel(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref HmdColor_t pColor, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayRenderModel(ulOverlayHandle, pchValue, unBufferSize, ref pColor, ref pError);
		}

		public EVROverlayError SetOverlayRenderModel(ulong ulOverlayHandle, string pchRenderModel, ref HmdColor_t pColor)
		{
			return FnTable.SetOverlayRenderModel(ulOverlayHandle, pchRenderModel, ref pColor);
		}

		public EVROverlayError GetOverlayTransformType(ulong ulOverlayHandle, ref VROverlayTransformType peTransformType)
		{
			return FnTable.GetOverlayTransformType(ulOverlayHandle, ref peTransformType);
		}

		public EVROverlayError SetOverlayTransformAbsolute(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform)
		{
			return FnTable.SetOverlayTransformAbsolute(ulOverlayHandle, eTrackingOrigin, ref pmatTrackingOriginToOverlayTransform);
		}

		public EVROverlayError GetOverlayTransformAbsolute(ulong ulOverlayHandle, ref ETrackingUniverseOrigin peTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform)
		{
			return FnTable.GetOverlayTransformAbsolute(ulOverlayHandle, ref peTrackingOrigin, ref pmatTrackingOriginToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, uint unTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform)
		{
			return FnTable.SetOverlayTransformTrackedDeviceRelative(ulOverlayHandle, unTrackedDevice, ref pmatTrackedDeviceToOverlayTransform);
		}

		public EVROverlayError GetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, ref uint punTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform)
		{
			punTrackedDevice = 0u;
			return FnTable.GetOverlayTransformTrackedDeviceRelative(ulOverlayHandle, ref punTrackedDevice, ref pmatTrackedDeviceToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, uint unDeviceIndex, string pchComponentName)
		{
			return FnTable.SetOverlayTransformTrackedDeviceComponent(ulOverlayHandle, unDeviceIndex, pchComponentName);
		}

		public EVROverlayError GetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, ref uint punDeviceIndex, StringBuilder pchComponentName, uint unComponentNameSize)
		{
			punDeviceIndex = 0u;
			return FnTable.GetOverlayTransformTrackedDeviceComponent(ulOverlayHandle, ref punDeviceIndex, pchComponentName, unComponentNameSize);
		}

		public EVROverlayError GetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ref ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform)
		{
			ulOverlayHandleParent = 0uL;
			return FnTable.GetOverlayTransformOverlayRelative(ulOverlayHandle, ref ulOverlayHandleParent, ref pmatParentOverlayToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform)
		{
			return FnTable.SetOverlayTransformOverlayRelative(ulOverlayHandle, ulOverlayHandleParent, ref pmatParentOverlayToOverlayTransform);
		}

		public EVROverlayError ShowOverlay(ulong ulOverlayHandle)
		{
			return FnTable.ShowOverlay(ulOverlayHandle);
		}

		public EVROverlayError HideOverlay(ulong ulOverlayHandle)
		{
			return FnTable.HideOverlay(ulOverlayHandle);
		}

		public bool IsOverlayVisible(ulong ulOverlayHandle)
		{
			return FnTable.IsOverlayVisible(ulOverlayHandle);
		}

		public EVROverlayError GetTransformForOverlayCoordinates(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, HmdVector2_t coordinatesInOverlay, ref HmdMatrix34_t pmatTransform)
		{
			return FnTable.GetTransformForOverlayCoordinates(ulOverlayHandle, eTrackingOrigin, coordinatesInOverlay, ref pmatTransform);
		}

		public bool PollNextOverlayEvent(ulong ulOverlayHandle, ref VREvent_t pEvent, uint uncbVREvent)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VREvent_t_Packed pEvent2 = default(VREvent_t_Packed);
				PollNextOverlayEventUnion pollNextOverlayEventUnion = default(PollNextOverlayEventUnion);
				pollNextOverlayEventUnion.pPollNextOverlayEventPacked = null;
				pollNextOverlayEventUnion.pPollNextOverlayEvent = FnTable.PollNextOverlayEvent;
				bool result = pollNextOverlayEventUnion.pPollNextOverlayEventPacked(ulOverlayHandle, ref pEvent2, (uint)Marshal.SizeOf(typeof(VREvent_t_Packed)));
				pEvent2.Unpack(ref pEvent);
				return result;
			}
			return FnTable.PollNextOverlayEvent(ulOverlayHandle, ref pEvent, uncbVREvent);
		}

		public EVROverlayError GetOverlayInputMethod(ulong ulOverlayHandle, ref VROverlayInputMethod peInputMethod)
		{
			return FnTable.GetOverlayInputMethod(ulOverlayHandle, ref peInputMethod);
		}

		public EVROverlayError SetOverlayInputMethod(ulong ulOverlayHandle, VROverlayInputMethod eInputMethod)
		{
			return FnTable.SetOverlayInputMethod(ulOverlayHandle, eInputMethod);
		}

		public EVROverlayError GetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale)
		{
			return FnTable.GetOverlayMouseScale(ulOverlayHandle, ref pvecMouseScale);
		}

		public EVROverlayError SetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale)
		{
			return FnTable.SetOverlayMouseScale(ulOverlayHandle, ref pvecMouseScale);
		}

		public bool ComputeOverlayIntersection(ulong ulOverlayHandle, ref VROverlayIntersectionParams_t pParams, ref VROverlayIntersectionResults_t pResults)
		{
			return FnTable.ComputeOverlayIntersection(ulOverlayHandle, ref pParams, ref pResults);
		}

		public bool IsHoverTargetOverlay(ulong ulOverlayHandle)
		{
			return FnTable.IsHoverTargetOverlay(ulOverlayHandle);
		}

		public ulong GetGamepadFocusOverlay()
		{
			return FnTable.GetGamepadFocusOverlay();
		}

		public EVROverlayError SetGamepadFocusOverlay(ulong ulNewFocusOverlay)
		{
			return FnTable.SetGamepadFocusOverlay(ulNewFocusOverlay);
		}

		public EVROverlayError SetOverlayNeighbor(EOverlayDirection eDirection, ulong ulFrom, ulong ulTo)
		{
			return FnTable.SetOverlayNeighbor(eDirection, ulFrom, ulTo);
		}

		public EVROverlayError MoveGamepadFocusToNeighbor(EOverlayDirection eDirection, ulong ulFrom)
		{
			return FnTable.MoveGamepadFocusToNeighbor(eDirection, ulFrom);
		}

		public EVROverlayError SetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, IntPtr vCenter, float fRadius)
		{
			return FnTable.SetOverlayDualAnalogTransform(ulOverlay, eWhich, vCenter, fRadius);
		}

		public EVROverlayError GetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, ref HmdVector2_t pvCenter, ref float pfRadius)
		{
			pfRadius = 0f;
			return FnTable.GetOverlayDualAnalogTransform(ulOverlay, eWhich, ref pvCenter, ref pfRadius);
		}

		public EVROverlayError SetOverlayTexture(ulong ulOverlayHandle, ref Texture_t pTexture)
		{
			return FnTable.SetOverlayTexture(ulOverlayHandle, ref pTexture);
		}

		public EVROverlayError ClearOverlayTexture(ulong ulOverlayHandle)
		{
			return FnTable.ClearOverlayTexture(ulOverlayHandle);
		}

		public EVROverlayError SetOverlayRaw(ulong ulOverlayHandle, IntPtr pvBuffer, uint unWidth, uint unHeight, uint unDepth)
		{
			return FnTable.SetOverlayRaw(ulOverlayHandle, pvBuffer, unWidth, unHeight, unDepth);
		}

		public EVROverlayError SetOverlayFromFile(ulong ulOverlayHandle, string pchFilePath)
		{
			return FnTable.SetOverlayFromFile(ulOverlayHandle, pchFilePath);
		}

		public EVROverlayError GetOverlayTexture(ulong ulOverlayHandle, ref IntPtr pNativeTextureHandle, IntPtr pNativeTextureRef, ref uint pWidth, ref uint pHeight, ref uint pNativeFormat, ref ETextureType pAPIType, ref EColorSpace pColorSpace, ref VRTextureBounds_t pTextureBounds)
		{
			pWidth = 0u;
			pHeight = 0u;
			pNativeFormat = 0u;
			return FnTable.GetOverlayTexture(ulOverlayHandle, ref pNativeTextureHandle, pNativeTextureRef, ref pWidth, ref pHeight, ref pNativeFormat, ref pAPIType, ref pColorSpace, ref pTextureBounds);
		}

		public EVROverlayError ReleaseNativeOverlayHandle(ulong ulOverlayHandle, IntPtr pNativeTextureHandle)
		{
			return FnTable.ReleaseNativeOverlayHandle(ulOverlayHandle, pNativeTextureHandle);
		}

		public EVROverlayError GetOverlayTextureSize(ulong ulOverlayHandle, ref uint pWidth, ref uint pHeight)
		{
			pWidth = 0u;
			pHeight = 0u;
			return FnTable.GetOverlayTextureSize(ulOverlayHandle, ref pWidth, ref pHeight);
		}

		public EVROverlayError CreateDashboardOverlay(string pchOverlayKey, string pchOverlayFriendlyName, ref ulong pMainHandle, ref ulong pThumbnailHandle)
		{
			pMainHandle = 0uL;
			pThumbnailHandle = 0uL;
			return FnTable.CreateDashboardOverlay(pchOverlayKey, pchOverlayFriendlyName, ref pMainHandle, ref pThumbnailHandle);
		}

		public bool IsDashboardVisible()
		{
			return FnTable.IsDashboardVisible();
		}

		public bool IsActiveDashboardOverlay(ulong ulOverlayHandle)
		{
			return FnTable.IsActiveDashboardOverlay(ulOverlayHandle);
		}

		public EVROverlayError SetDashboardOverlaySceneProcess(ulong ulOverlayHandle, uint unProcessId)
		{
			return FnTable.SetDashboardOverlaySceneProcess(ulOverlayHandle, unProcessId);
		}

		public EVROverlayError GetDashboardOverlaySceneProcess(ulong ulOverlayHandle, ref uint punProcessId)
		{
			punProcessId = 0u;
			return FnTable.GetDashboardOverlaySceneProcess(ulOverlayHandle, ref punProcessId);
		}

		public void ShowDashboard(string pchOverlayToShow)
		{
			FnTable.ShowDashboard(pchOverlayToShow);
		}

		public uint GetPrimaryDashboardDevice()
		{
			return FnTable.GetPrimaryDashboardDevice();
		}

		public EVROverlayError ShowKeyboard(int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue)
		{
			return FnTable.ShowKeyboard(eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText, bUseMinimalMode, uUserValue);
		}

		public EVROverlayError ShowKeyboardForOverlay(ulong ulOverlayHandle, int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue)
		{
			return FnTable.ShowKeyboardForOverlay(ulOverlayHandle, eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText, bUseMinimalMode, uUserValue);
		}

		public uint GetKeyboardText(StringBuilder pchText, uint cchText)
		{
			return FnTable.GetKeyboardText(pchText, cchText);
		}

		public void HideKeyboard()
		{
			FnTable.HideKeyboard();
		}

		public void SetKeyboardTransformAbsolute(ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToKeyboardTransform)
		{
			FnTable.SetKeyboardTransformAbsolute(eTrackingOrigin, ref pmatTrackingOriginToKeyboardTransform);
		}

		public void SetKeyboardPositionForOverlay(ulong ulOverlayHandle, HmdRect2_t avoidRect)
		{
			FnTable.SetKeyboardPositionForOverlay(ulOverlayHandle, avoidRect);
		}

		public EVROverlayError SetOverlayIntersectionMask(ulong ulOverlayHandle, ref VROverlayIntersectionMaskPrimitive_t pMaskPrimitives, uint unNumMaskPrimitives, uint unPrimitiveSize)
		{
			return FnTable.SetOverlayIntersectionMask(ulOverlayHandle, ref pMaskPrimitives, unNumMaskPrimitives, unPrimitiveSize);
		}

		public EVROverlayError GetOverlayFlags(ulong ulOverlayHandle, ref uint pFlags)
		{
			pFlags = 0u;
			return FnTable.GetOverlayFlags(ulOverlayHandle, ref pFlags);
		}

		public VRMessageOverlayResponse ShowMessageOverlay(string pchText, string pchCaption, string pchButton0Text, string pchButton1Text, string pchButton2Text, string pchButton3Text)
		{
			return FnTable.ShowMessageOverlay(pchText, pchCaption, pchButton0Text, pchButton1Text, pchButton2Text, pchButton3Text);
		}

		public void CloseMessageOverlay()
		{
			FnTable.CloseMessageOverlay();
		}
	}
	public class CVRRenderModels
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetComponentStatePacked(string pchRenderModelName, string pchComponentName, ref VRControllerState_t_Packed pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetComponentStateUnion
		{
			[FieldOffset(0)]
			public IVRRenderModels._GetComponentState pGetComponentState;

			[FieldOffset(0)]
			public _GetComponentStatePacked pGetComponentStatePacked;
		}

		private IVRRenderModels FnTable;

		internal CVRRenderModels(IntPtr pInterface)
		{
			FnTable = (IVRRenderModels)Marshal.PtrToStructure(pInterface, typeof(IVRRenderModels));
		}

		public EVRRenderModelError LoadRenderModel_Async(string pchRenderModelName, ref IntPtr ppRenderModel)
		{
			return FnTable.LoadRenderModel_Async(pchRenderModelName, ref ppRenderModel);
		}

		public void FreeRenderModel(IntPtr pRenderModel)
		{
			FnTable.FreeRenderModel(pRenderModel);
		}

		public EVRRenderModelError LoadTexture_Async(int textureId, ref IntPtr ppTexture)
		{
			return FnTable.LoadTexture_Async(textureId, ref ppTexture);
		}

		public void FreeTexture(IntPtr pTexture)
		{
			FnTable.FreeTexture(pTexture);
		}

		public EVRRenderModelError LoadTextureD3D11_Async(int textureId, IntPtr pD3D11Device, ref IntPtr ppD3D11Texture2D)
		{
			return FnTable.LoadTextureD3D11_Async(textureId, pD3D11Device, ref ppD3D11Texture2D);
		}

		public EVRRenderModelError LoadIntoTextureD3D11_Async(int textureId, IntPtr pDstTexture)
		{
			return FnTable.LoadIntoTextureD3D11_Async(textureId, pDstTexture);
		}

		public void FreeTextureD3D11(IntPtr pD3D11Texture2D)
		{
			FnTable.FreeTextureD3D11(pD3D11Texture2D);
		}

		public uint GetRenderModelName(uint unRenderModelIndex, StringBuilder pchRenderModelName, uint unRenderModelNameLen)
		{
			return FnTable.GetRenderModelName(unRenderModelIndex, pchRenderModelName, unRenderModelNameLen);
		}

		public uint GetRenderModelCount()
		{
			return FnTable.GetRenderModelCount();
		}

		public uint GetComponentCount(string pchRenderModelName)
		{
			return FnTable.GetComponentCount(pchRenderModelName);
		}

		public uint GetComponentName(string pchRenderModelName, uint unComponentIndex, StringBuilder pchComponentName, uint unComponentNameLen)
		{
			return FnTable.GetComponentName(pchRenderModelName, unComponentIndex, pchComponentName, unComponentNameLen);
		}

		public ulong GetComponentButtonMask(string pchRenderModelName, string pchComponentName)
		{
			return FnTable.GetComponentButtonMask(pchRenderModelName, pchComponentName);
		}

		public uint GetComponentRenderModelName(string pchRenderModelName, string pchComponentName, StringBuilder pchComponentRenderModelName, uint unComponentRenderModelNameLen)
		{
			return FnTable.GetComponentRenderModelName(pchRenderModelName, pchComponentName, pchComponentRenderModelName, unComponentRenderModelNameLen);
		}

		public bool GetComponentState(string pchRenderModelName, string pchComponentName, ref VRControllerState_t pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetComponentStateUnion getComponentStateUnion = default(GetComponentStateUnion);
				getComponentStateUnion.pGetComponentStatePacked = null;
				getComponentStateUnion.pGetComponentState = FnTable.GetComponentState;
				bool result = getComponentStateUnion.pGetComponentStatePacked(pchRenderModelName, pchComponentName, ref pControllerState2, ref pState, ref pComponentState);
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetComponentState(pchRenderModelName, pchComponentName, ref pControllerState, ref pState, ref pComponentState);
		}

		public bool RenderModelHasComponent(string pchRenderModelName, string pchComponentName)
		{
			return FnTable.RenderModelHasComponent(pchRenderModelName, pchComponentName);
		}

		public uint GetRenderModelThumbnailURL(string pchRenderModelName, StringBuilder pchThumbnailURL, uint unThumbnailURLLen, ref EVRRenderModelError peError)
		{
			return FnTable.GetRenderModelThumbnailURL(pchRenderModelName, pchThumbnailURL, unThumbnailURLLen, ref peError);
		}

		public uint GetRenderModelOriginalPath(string pchRenderModelName, StringBuilder pchOriginalPath, uint unOriginalPathLen, ref EVRRenderModelError peError)
		{
			return FnTable.GetRenderModelOriginalPath(pchRenderModelName, pchOriginalPath, unOriginalPathLen, ref peError);
		}

		public string GetRenderModelErrorNameFromEnum(EVRRenderModelError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetRenderModelErrorNameFromEnum(error));
		}
	}
	public class CVRNotifications
	{
		private IVRNotifications FnTable;

		internal CVRNotifications(IntPtr pInterface)
		{
			FnTable = (IVRNotifications)Marshal.PtrToStructure(pInterface, typeof(IVRNotifications));
		}

		public EVRNotificationError CreateNotification(ulong ulOverlayHandle, ulong ulUserValue, EVRNotificationType type, string pchText, EVRNotificationStyle style, ref NotificationBitmap_t pImage, ref uint pNotificationId)
		{
			pNotificationId = 0u;
			return FnTable.CreateNotification(ulOverlayHandle, ulUserValue, type, pchText, style, ref pImage, ref pNotificationId);
		}

		public EVRNotificationError RemoveNotification(uint notificationId)
		{
			return FnTable.RemoveNotification(notificationId);
		}
	}
	public class CVRSettings
	{
		private IVRSettings FnTable;

		internal CVRSettings(IntPtr pInterface)
		{
			FnTable = (IVRSettings)Marshal.PtrToStructure(pInterface, typeof(IVRSettings));
		}

		public string GetSettingsErrorNameFromEnum(EVRSettingsError eError)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetSettingsErrorNameFromEnum(eError));
		}

		public bool Sync(bool bForce, ref EVRSettingsError peError)
		{
			return FnTable.Sync(bForce, ref peError);
		}

		public void SetBool(string pchSection, string pchSettingsKey, bool bValue, ref EVRSettingsError peError)
		{
			FnTable.SetBool(pchSection, pchSettingsKey, bValue, ref peError);
		}

		public void SetInt32(string pchSection, string pchSettingsKey, int nValue, ref EVRSettingsError peError)
		{
			FnTable.SetInt32(pchSection, pchSettingsKey, nValue, ref peError);
		}

		public void SetFloat(string pchSection, string pchSettingsKey, float flValue, ref EVRSettingsError peError)
		{
			FnTable.SetFloat(pchSection, pchSettingsKey, flValue, ref peError);
		}

		public void SetString(string pchSection, string pchSettingsKey, string pchValue, ref EVRSettingsError peError)
		{
			FnTable.SetString(pchSection, pchSettingsKey, pchValue, ref peError);
		}

		public bool GetBool(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetBool(pchSection, pchSettingsKey, ref peError);
		}

		public int GetInt32(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetInt32(pchSection, pchSettingsKey, ref peError);
		}

		public float GetFloat(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetFloat(pchSection, pchSettingsKey, ref peError);
		}

		public void GetString(string pchSection, string pchSettingsKey, StringBuilder pchValue, uint unValueLen, ref EVRSettingsError peError)
		{
			FnTable.GetString(pchSection, pchSettingsKey, pchValue, unValueLen, ref peError);
		}

		public void RemoveSection(string pchSection, ref EVRSettingsError peError)
		{
			FnTable.RemoveSection(pchSection, ref peError);
		}

		public void RemoveKeyInSection(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			FnTable.RemoveKeyInSection(pchSection, pchSettingsKey, ref peError);
		}
	}
	public class CVRScreenshots
	{
		private IVRScreenshots FnTable;

		internal CVRScreenshots(IntPtr pInterface)
		{
			FnTable = (IVRScreenshots)Marshal.PtrToStructure(pInterface, typeof(IVRScreenshots));
		}

		public EVRScreenshotError RequestScreenshot(ref uint pOutScreenshotHandle, EVRScreenshotType type, string pchPreviewFilename, string pchVRFilename)
		{
			pOutScreenshotHandle = 0u;
			return FnTable.RequestScreenshot(ref pOutScreenshotHandle, type, pchPreviewFilename, pchVRFilename);
		}

		public EVRScreenshotError HookScreenshot(EVRScreenshotType[] pSupportedTypes)
		{
			return FnTable.HookScreenshot(pSupportedTypes, pSupportedTypes.Length);
		}

		public EVRScreenshotType GetScreenshotPropertyType(uint screenshotHandle, ref EVRScreenshotError pError)
		{
			return FnTable.GetScreenshotPropertyType(screenshotHandle, ref pError);
		}

		public uint GetScreenshotPropertyFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames filenameType, StringBuilder pchFilename, uint cchFilename, ref EVRScreenshotError pError)
		{
			return FnTable.GetScreenshotPropertyFilename(screenshotHandle, filenameType, pchFilename, cchFilename, ref pError);
		}

		public EVRScreenshotError UpdateScreenshotProgress(uint screenshotHandle, float flProgress)
		{
			return FnTable.UpdateScreenshotProgress(screenshotHandle, flProgress);
		}

		public EVRScreenshotError TakeStereoScreenshot(ref uint pOutScreenshotHandle, string pchPreviewFilename, string pchVRFilename)
		{
			pOutScreenshotHandle = 0u;
			return FnTable.TakeStereoScreenshot(ref pOutScreenshotHandle, pchPreviewFilename, pchVRFilename);
		}

		public EVRScreenshotError SubmitScreenshot(uint screenshotHandle, EVRScreenshotType type, string pchSourcePreviewFilename, string pchSourceVRFilename)
		{
			return FnTable.SubmitScreenshot(screenshotHandle, type, pchSourcePreviewFilename, pchSourceVRFilename);
		}
	}
	public class CVRResources
	{
		private IVRResources FnTable;

		internal CVRResources(IntPtr pInterface)
		{
			FnTable = (IVRResources)Marshal.PtrToStructure(pInterface, typeof(IVRResources));
		}

		public uint LoadSharedResource(string pchResourceName, string pchBuffer, uint unBufferLen)
		{
			return FnTable.LoadSharedResource(pchResourceName, pchBuffer, unBufferLen);
		}

		public uint GetResourceFullPath(string pchResourceName, string pchResourceTypeDirectory, StringBuilder pchPathBuffer, uint unBufferLen)
		{
			return FnTable.GetResourceFullPath(pchResourceName, pchResourceTypeDirectory, pchPathBuffer, unBufferLen);
		}
	}
	public class CVRDriverManager
	{
		private IVRDriverManager FnTable;

		internal CVRDriverManager(IntPtr pInterface)
		{
			FnTable = (IVRDriverManager)Marshal.PtrToStructure(pInterface, typeof(IVRDriverManager));
		}

		public uint GetDriverCount()
		{
			return FnTable.GetDriverCount();
		}

		public uint GetDriverName(uint nDriver, StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetDriverName(nDriver, pchValue, unBufferSize);
		}

		public ulong GetDriverHandle(string pchDriverName)
		{
			return FnTable.GetDriverHandle(pchDriverName);
		}
	}
	public class OpenVRInterop
	{
		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_InitInternal")]
		internal static extern uint InitInternal(ref EVRInitError peError, EVRApplicationType eApplicationType);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_ShutdownInternal")]
		internal static extern void ShutdownInternal();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsHmdPresent")]
		internal static extern bool IsHmdPresent();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsRuntimeInstalled")]
		internal static extern bool IsRuntimeInstalled();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetStringForHmdError")]
		internal static extern IntPtr GetStringForHmdError(EVRInitError error);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetGenericInterface")]
		internal static extern IntPtr GetGenericInterface([In][MarshalAs(UnmanagedType.LPStr)] string pchInterfaceVersion, ref EVRInitError peError);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsInterfaceVersionValid")]
		internal static extern bool IsInterfaceVersionValid([In][MarshalAs(UnmanagedType.LPStr)] string pchInterfaceVersion);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetInitToken")]
		internal static extern uint GetInitToken();
	}
	public enum EVREye
	{
		Eye_Left,
		Eye_Right
	}
	public enum ETextureType
	{
		DirectX,
		OpenGL,
		Vulkan,
		IOSurface,
		DirectX12,
		DXGISharedHandle
	}
	public enum EColorSpace
	{
		Auto,
		Gamma,
		Linear
	}
	public enum ETrackingResult
	{
		Uninitialized = 1,
		Calibrating_InProgress = 100,
		Calibrating_OutOfRange = 101,
		Running_OK = 200,
		Running_OutOfRange = 201
	}
	public enum ETrackedDeviceClass
	{
		Invalid,
		HMD,
		Controller,
		GenericTracker,
		TrackingReference,
		DisplayRedirect
	}
	public enum ETrackedControllerRole
	{
		Invalid,
		LeftHand,
		RightHand,
		OptOut
	}
	public enum ETrackingUniverseOrigin
	{
		TrackingUniverseSeated,
		TrackingUniverseStanding,
		TrackingUniverseRawAndUncalibrated
	}
	public enum ETrackedDeviceProperty
	{
		Prop_Invalid = 0,
		Prop_TrackingSystemName_String = 1000,
		Prop_ModelNumber_String = 1001,
		Prop_SerialNumber_String = 1002,
		Prop_RenderModelName_String = 1003,
		Prop_WillDriftInYaw_Bool = 1004,
		Prop_ManufacturerName_String = 1005,
		Prop_TrackingFirmwareVersion_String = 1006,
		Prop_HardwareRevision_String = 1007,
		Prop_AllWirelessDongleDescriptions_String = 1008,
		Prop_ConnectedWirelessDongle_String = 1009,
		Prop_DeviceIsWireless_Bool = 1010,
		Prop_DeviceIsCharging_Bool = 1011,
		Prop_DeviceBatteryPercentage_Float = 1012,
		Prop_StatusDisplayTransform_Matrix34 = 1013,
		Prop_Firmware_UpdateAvailable_Bool = 1014,
		Prop_Firmware_ManualUpdate_Bool = 1015,
		Prop_Firmware_ManualUpdateURL_String = 1016,
		Prop_HardwareRevision_Uint64 = 1017,
		Prop_FirmwareVersion_Uint64 = 1018,
		Prop_FPGAVersion_Uint64 = 1019,
		Prop_VRCVersion_Uint64 = 1020,
		Prop_RadioVersion_Uint64 = 1021,
		Prop_DongleVersion_Uint64 = 1022,
		Prop_BlockServerShutdown_Bool = 1023,
		Prop_CanUnifyCoordinateSystemWithHmd_Bool = 1024,
		Prop_ContainsProximitySensor_Bool = 1025,
		Prop_DeviceProvidesBatteryStatus_Bool = 1026,
		Prop_DeviceCanPowerOff_Bool = 1027,
		Prop_Firmware_ProgrammingTarget_String = 1028,
		Prop_DeviceClass_Int32 = 1029,
		Prop_HasCamera_Bool = 1030,
		Prop_DriverVersion_String = 1031,
		Prop_Firmware_ForceUpdateRequired_Bool = 1032,
		Prop_ViveSystemButtonFixRequired_Bool = 1033,
		Prop_ParentDriver_Uint64 = 1034,
		Prop_ResourceRoot_String = 1035,
		Prop_RegisteredDeviceType_String = 1036,
		Prop_InputProfilePath_String = 1037,
		Prop_NeverTracked_Bool = 1038,
		Prop_ReportsTimeSinceVSync_Bool = 2000,
		Prop_SecondsFromVsyncToPhotons_Float = 2001,
		Prop_DisplayFrequency_Float = 2002,
		Prop_UserIpdMeters_Float = 2003,
		Prop_CurrentUniverseId_Uint64 = 2004,
		Prop_PreviousUniverseId_Uint64 = 2005,
		Prop_DisplayFirmwareVersion_Uint64 = 2006,
		Prop_IsOnDesktop_Bool = 2007,
		Prop_DisplayMCType_Int32 = 2008,
		Prop_DisplayMCOffset_Float = 2009,
		Prop_DisplayMCScale_Float = 2010,
		Prop_EdidVendorID_Int32 = 2011,
		Prop_DisplayMCImageLeft_String = 2012,
		Prop_DisplayMCImageRight_String = 2013,
		Prop_DisplayGCBlackClamp_Float = 2014,
		Prop_EdidProductID_Int32 = 2015,
		Prop_CameraToHeadTransform_Matrix34 = 2016,
		Prop_DisplayGCType_Int32 = 2017,
		Prop_DisplayGCOffset_Float = 2018,
		Prop_DisplayGCScale_Float = 2019,
		Prop_DisplayGCPrescale_Float = 2020,
		Prop_DisplayGCImage_String = 2021,
		Prop_LensCenterLeftU_Float = 2022,
		Prop_LensCenterLeftV_Float = 2023,
		Prop_LensCenterRightU_Float = 2024,
		Prop_LensCenterRightV_Float = 2025,
		Prop_UserHeadToEyeDepthMeters_Float = 2026,
		Prop_CameraFirmwareVersion_Uint64 = 2027,
		Prop_CameraFirmwareDescription_String = 2028,
		Prop_DisplayFPGAVersion_Uint64 = 2029,
		Prop_DisplayBootloaderVersion_Uint64 = 2030,
		Prop_DisplayHardwareVersion_Uint64 = 2031,
		Prop_AudioFirmwareVersion_Uint64 = 2032,
		Prop_CameraCompatibilityMode_Int32 = 2033,
		Prop_ScreenshotHorizontalFieldOfViewDegrees_Float = 2034,
		Prop_ScreenshotVerticalFieldOfViewDegrees_Float = 2035,
		Prop_DisplaySuppressed_Bool = 2036,
		Prop_DisplayAllowNightMode_Bool = 2037,
		Prop_DisplayMCImageWidth_Int32 = 2038,
		Prop_DisplayMCImageHeight_Int32 = 2039,
		Prop_DisplayMCImageNumChannels_Int32 = 2040,
		Prop_DisplayMCImageData_Binary = 2041,
		Prop_SecondsFromPhotonsToVblank_Float = 2042,
		Prop_DriverDirectModeSendsVsyncEvents_Bool = 2043,
		Prop_DisplayDebugMode_Bool = 2044,
		Prop_GraphicsAdapterLuid_Uint64 = 2045,
		Prop_DriverProvidedChaperonePath_String = 2048,
		Prop_ExpectedTrackingReferenceCount_Int32 = 2049,
		Prop_ExpectedControllerCount_Int32 = 2050,
		Prop_NamedIconPathControllerLeftDeviceOff_String = 2051,
		Prop_NamedIconPathControllerRightDeviceOff_String = 2052,
		Prop_NamedIconPathTrackingReferenceDeviceOff_String = 2053,
		Prop_DoNotApplyPrediction_Bool = 2054,
		Prop_CameraToHeadTransforms_Matrix34_Array = 2055,
		Prop_DistortionMeshResolution_Int32 = 2056,
		Prop_DriverIsDrawingControllers_Bool = 2057,
		Prop_DriverRequestsApplicationPause_Bool = 2058,
		Prop_DriverRequestsReducedRendering_Bool = 2059,
		Prop_MinimumIpdStepMeters_Float = 2060,
		Prop_AudioBridgeFirmwareVersion_Uint64 = 2061,
		Prop_ImageBridgeFirmwareVersion_Uint64 = 2062,
		Prop_AttachedDeviceId_String = 3000,
		Prop_SupportedButtons_Uint64 = 3001,
		Prop_Axis0Type_Int32 = 3002,
		Prop_Axis1Type_Int32 = 3003,
		Prop_Axis2Type_Int32 = 3004,
		Prop_Axis3Type_Int32 = 3005,
		Prop_Axis4Type_Int32 = 3006,
		Prop_ControllerRoleHint_Int32 = 3007,
		Prop_FieldOfViewLeftDegrees_Float = 4000,
		Prop_FieldOfViewRightDegrees_Float = 4001,
		Prop_FieldOfViewTopDegrees_Float = 4002,
		Prop_FieldOfViewBottomDegrees_Float = 4003,
		Prop_TrackingRangeMinimumMeters_Float = 4004,
		Prop_TrackingRangeMaximumMeters_Float = 4005,
		Prop_ModeLabel_String = 4006,
		Prop_IconPathName_String = 5000,
		Prop_NamedIconPathDeviceOff_String = 5001,
		Prop_NamedIconPathDeviceSearching_String = 5002,
		Prop_NamedIconPathDeviceSearchingAlert_String = 5003,
		Prop_NamedIconPathDeviceReady_String = 5004,
		Prop_NamedIconPathDeviceReadyAlert_String = 5005,
		Prop_NamedIconPathDeviceNotReady_String = 5006,
		Prop_NamedIconPathDeviceStandby_String = 5007,
		Prop_NamedIconPathDeviceAlertLow_String = 5008,
		Prop_DisplayHiddenArea_Binary_Start = 5100,
		Prop_DisplayHiddenArea_Binary_End = 5150,
		Prop_ParentContainer = 5151,
		Prop_UserConfigPath_String = 6000,
		Prop_InstallPath_String = 6001,
		Prop_HasDisplayComponent_Bool = 6002,
		Prop_HasControllerComponent_Bool = 6003,
		Prop_HasCameraComponent_Bool = 6004,
		Prop_HasDriverDirectModeComponent_Bool = 6005,
		Prop_HasVirtualDisplayComponent_Bool = 6006,
		Prop_ControllerType_String = 7000,
		Prop_LegacyInputProfile_String = 7001,
		Prop_VendorSpecific_Reserved_Start = 10000,
		Prop_VendorSpecific_Reserved_End = 10999,
		Prop_TrackedDeviceProperty_Max = 1000000
	}
	public enum ETrackedPropertyError
	{
		TrackedProp_Success,
		TrackedProp_WrongDataType,
		TrackedProp_WrongDeviceClass,
		TrackedProp_BufferTooSmall,
		TrackedProp_UnknownProperty,
		TrackedProp_InvalidDevice,
		TrackedProp_CouldNotContactServer,
		TrackedProp_ValueNotProvidedByDevice,
		TrackedProp_StringExceedsMaximumLength,
		TrackedProp_NotYetAvailable,
		TrackedProp_PermissionDenied,
		TrackedProp_InvalidOperation,
		TrackedProp_CannotWriteToWildcards
	}
	public enum EVRSubmitFlags
	{
		Submit_Default = 0,
		Submit_LensDistortionAlreadyApplied = 1,
		Submit_GlRenderBuffer = 2,
		Submit_Reserved = 4,
		Submit_TextureWithPose = 8,
		Submit_TextureWithDepth = 0x10
	}
	public enum EVRState
	{
		Undefined = -1,
		Off,
		Searching,
		Searching_Alert,
		Ready,
		Ready_Alert,
		NotReady,
		Standby,
		Ready_Alert_Low
	}
	public enum EVREventType
	{
		VREvent_None = 0,
		VREvent_TrackedDeviceActivated = 100,
		VREvent_TrackedDeviceDeactivated = 101,
		VREvent_TrackedDeviceUpdated = 102,
		VREvent_TrackedDeviceUserInteractionStarted = 103,
		VREvent_TrackedDeviceUserInteractionEnded = 104,
		VREvent_IpdChanged = 105,
		VREvent_EnterStandbyMode = 106,
		VREvent_LeaveStandbyMode = 107,
		VREvent_TrackedDeviceRoleChanged = 108,
		VREvent_WatchdogWakeUpRequested = 109,
		VREvent_LensDistortionChanged = 110,
		VREvent_PropertyChanged = 111,
		VREvent_WirelessDisconnect = 112,
		VREvent_WirelessReconnect = 113,
		VREvent_ButtonPress = 200,
		VREvent_ButtonUnpress = 201,
		VREvent_ButtonTouch = 202,
		VREvent_ButtonUntouch = 203,
		VREvent_DualAnalog_Press = 250,
		VREvent_DualAnalog_Unpress = 251,
		VREvent_DualAnalog_Touch = 252,
		VREvent_DualAnalog_Untouch = 253,
		VREvent_DualAnalog_Move = 254,
		VREvent_DualAnalog_ModeSwitch1 = 255,
		VREvent_DualAnalog_ModeSwitch2 = 256,
		VREvent_DualAnalog_Cancel = 257,
		VREvent_MouseMove = 300,
		VREvent_MouseButtonDown = 301,
		VREvent_MouseButtonUp = 302,
		VREvent_FocusEnter = 303,
		VREvent_FocusLeave = 304,
		VREvent_Scroll = 305,
		VREvent_TouchPadMove = 306,
		VREvent_OverlayFocusChanged = 307,
		VREvent_InputFocusCaptured = 400,
		VREvent_InputFocusReleased = 401,
		VREvent_SceneFocusLost = 402,
		VREvent_SceneFocusGained = 403,
		VREvent_SceneApplicationChanged = 404,
		VREvent_SceneFocusChanged = 405,
		VREvent_InputFocusChanged = 406,
		VREvent_SceneApplicationSecondaryRenderingStarted = 407,
		VREvent_SceneApplicationUsingWrongGraphicsAdapter = 408,
		VREvent_HideRenderModels = 410,
		VREvent_ShowRenderModels = 411,
		VREvent_ConsoleOpened = 420,
		VREvent_ConsoleClosed = 421,
		VREvent_OverlayShown = 500,
		VREvent_OverlayHidden = 501,
		VREvent_DashboardActivated = 502,
		VREvent_DashboardDeactivated = 503,
		VREvent_DashboardThumbSelected = 504,
		VREvent_DashboardRequested = 505,
		VREvent_ResetDashboard = 506,
		VREvent_RenderToast = 507,
		VREvent_ImageLoaded = 508,
		VREvent_ShowKeyboard = 509,
		VREvent_HideKeyboard = 510,
		VREvent_OverlayGamepadFocusGained = 511,
		VREvent_OverlayGamepadFocusLost = 512,
		VREvent_OverlaySharedTextureChanged = 513,
		VREvent_ScreenshotTriggered = 516,
		VREvent_ImageFailed = 517,
		VREvent_DashboardOverlayCreated = 518,
		VREvent_SwitchGamepadFocus = 519,
		VREvent_RequestScreenshot = 520,
		VREvent_ScreenshotTaken = 521,
		VREvent_ScreenshotFailed = 522,
		VREvent_SubmitScreenshotToDashboard = 523,
		VREvent_ScreenshotProgressToDashboard = 524,
		VREvent_PrimaryDashboardDeviceChanged = 525,
		VREvent_RoomViewShown = 526,
		VREvent_RoomViewHidden = 527,
		VREvent_Notification_Shown = 600,
		VREvent_Notification_Hidden = 601,
		VREvent_Notification_BeginInteraction = 602,
		VREvent_Notification_Destroyed = 603,
		VREvent_Quit = 700,
		VREvent_ProcessQuit = 701,
		VREvent_QuitAborted_UserPrompt = 702,
		VREvent_QuitAcknowledged = 703,
		VREvent_DriverRequestedQuit = 704,
		VREvent_ChaperoneDataHasChanged = 800,
		VREvent_ChaperoneUniverseHasChanged = 801,
		VREvent_ChaperoneTempDataHasChanged = 802,
		VREvent_ChaperoneSettingsHaveChanged = 803,
		VREvent_SeatedZeroPoseReset = 804,
		VREvent_AudioSettingsHaveChanged = 820,
		VREvent_BackgroundSettingHasChanged = 850,
		VREvent_CameraSettingsHaveChanged = 851,
		VREvent_ReprojectionSettingHasChanged = 852,
		VREvent_ModelSkinSettingsHaveChanged = 853,
		VREvent_EnvironmentSettingsHaveChanged = 854,
		VREvent_PowerSettingsHaveChanged = 855,
		VREvent_EnableHomeAppSettingsHaveChanged = 856,
		VREvent_SteamVRSectionSettingChanged = 857,
		VREvent_LighthouseSectionSettingChanged = 858,
		VREvent_NullSectionSettingChanged = 859,
		VREvent_UserInterfaceSectionSettingChanged = 860,
		VREvent_NotificationsSectionSettingChanged = 861,
		VREvent_KeyboardSectionSettingChanged = 862,
		VREvent_PerfSectionSettingChanged = 863,
		VREvent_DashboardSectionSettingChanged = 864,
		VREvent_WebInterfaceSectionSettingChanged = 865,
		VREvent_StatusUpdate = 900,
		VREvent_WebInterface_InstallDriverCompleted = 950,
		VREvent_MCImageUpdated = 1000,
		VREvent_FirmwareUpdateStarted = 1100,
		VREvent_FirmwareUpdateFinished = 1101,
		VREvent_KeyboardClosed = 1200,
		VREvent_KeyboardCharInput = 1201,
		VREvent_KeyboardDone = 1202,
		VREvent_ApplicationTransitionStarted = 1300,
		VREvent_ApplicationTransitionAborted = 1301,
		VREvent_ApplicationTransitionNewAppStarted = 1302,
		VREvent_ApplicationListUpdated = 1303,
		VREvent_ApplicationMimeTypeLoad = 1304,
		VREvent_ApplicationTransitionNewAppLaunchComplete = 1305,
		VREvent_ProcessConnected = 1306,
		VREvent_ProcessDisconnected = 1307,
		VREvent_Compositor_MirrorWindowShown = 1400,
		VREvent_Compositor_MirrorWindowHidden = 1401,
		VREvent_Compositor_ChaperoneBoundsShown = 1410,
		VREvent_Compositor_ChaperoneBoundsHidden = 1411,
		VREvent_TrackedCamera_StartVideoStream = 1500,
		VREvent_TrackedCamera_StopVideoStream = 1501,
		VREvent_TrackedCamera_PauseVideoStream = 1502,
		VREvent_TrackedCamera_ResumeVideoStream = 1503,
		VREvent_TrackedCamera_EditingSurface = 1550,
		VREvent_PerformanceTest_EnableCapture = 1600,
		VREvent_PerformanceTest_DisableCapture = 1601,
		VREvent_PerformanceTest_FidelityLevel = 1602,
		VREvent_MessageOverlay_Closed = 1650,
		VREvent_MessageOverlayCloseRequested = 1651,
		VREvent_Input_HapticVibration = 1700,
		VREvent_VendorSpecific_Reserved_Start = 10000,
		VREvent_VendorSpecific_Reserved_End = 19999
	}
	public enum EDeviceActivityLevel
	{
		k_EDeviceActivityLevel_Unknown = -1,
		k_EDeviceActivityLevel_Idle,
		k_EDeviceActivityLevel_UserInteraction,
		k_EDeviceActivityLevel_UserInteraction_Timeout,
		k_EDeviceActivityLevel_Standby
	}
	public enum EVRButtonId
	{
		k_EButton_System = 0,
		k_EButton_ApplicationMenu = 1,
		k_EButton_Grip = 2,
		k_EButton_DPad_Left = 3,
		k_EButton_DPad_Up = 4,
		k_EButton_DPad_Right = 5,
		k_EButton_DPad_Down = 6,
		k_EButton_A = 7,
		k_EButton_ProximitySensor = 31,
		k_EButton_Axis0 = 32,
		k_EButton_Axis1 = 33,
		k_EButton_Axis2 = 34,
		k_EButton_Axis3 = 35,
		k_EButton_Axis4 = 36,
		k_EButton_SteamVR_Touchpad = 32,
		k_EButton_SteamVR_Trigger = 33,
		k_EButton_Dashboard_Back = 2,
		k_EButton_Max = 64
	}
	public enum EVRMouseButton
	{
		Left = 1,
		Right = 2,
		Middle = 4
	}
	public enum EDualAnalogWhich
	{
		k_EDualAnalog_Left,
		k_EDualAnalog_Right
	}
	public enum EVRInputError
	{
		None,
		NameNotFound,
		WrongType,
		InvalidHandle,
		InvalidParam,
		NoSteam,
		MaxCapacityReached,
		IPCError,
		NoActiveActionSet,
		InvalidDevice
	}
	public enum EHiddenAreaMeshType
	{
		k_eHiddenAreaMesh_Standard,
		k_eHiddenAreaMesh_Inverse,
		k_eHiddenAreaMesh_LineLoop,
		k_eHiddenAreaMesh_Max
	}
	public enum EVRControllerAxisType
	{
		k_eControllerAxis_None,
		k_eControllerAxis_TrackPad,
		k_eControllerAxis_Joystick,
		k_eControllerAxis_Trigger
	}
	public enum EVRControllerEventOutputType
	{
		ControllerEventOutput_OSEvents,
		ControllerEventOutput_VREvents
	}
	public enum ECollisionBoundsStyle
	{
		COLLISION_BOUNDS_STYLE_BEGINNER,
		COLLISION_BOUNDS_STYLE_INTERMEDIATE,
		COLLISION_BOUNDS_STYLE_SQUARES,
		COLLISION_BOUNDS_STYLE_ADVANCED,
		COLLISION_BOUNDS_STYLE_NONE,
		COLLISION_BOUNDS_STYLE_COUNT
	}
	public enum EVROverlayError
	{
		None = 0,
		UnknownOverlay = 10,
		InvalidHandle = 11,
		PermissionDenied = 12,
		OverlayLimitExceeded = 13,
		WrongVisibilityType = 14,
		KeyTooLong = 15,
		NameTooLong = 16,
		KeyInUse = 17,
		WrongTransformType = 18,
		InvalidTrackedDevice = 19,
		InvalidParameter = 20,
		ThumbnailCantBeDestroyed = 21,
		ArrayTooSmall = 22,
		RequestFailed = 23,
		InvalidTexture = 24,
		UnableToLoadFile = 25,
		KeyboardAlreadyInUse = 26,
		NoNeighbor = 27,
		TooManyMaskPrimitives = 29,
		BadMaskPrimitive = 30,
		TextureAlreadyLocked = 31,
		TextureLockCapacityReached = 32,
		TextureNotLocked = 33
	}
	public enum EVRApplicationType
	{
		VRApplication_Other,
		VRApplication_Scene,
		VRApplication_Overlay,
		VRApplication_Background,
		VRApplication_Utility,
		VRApplication_VRMonitor,
		VRApplication_SteamWatchdog,
		VRApplication_Bootstrapper,
		VRApplication_Max
	}
	public enum EVRFirmwareError
	{
		None,
		Success,
		Fail
	}
	public enum EVRNotificationError
	{
		OK = 0,
		InvalidNotificationId = 100,
		NotificationQueueFull = 101,
		InvalidOverlayHandle = 102,
		SystemWithUserValueAlreadyExists = 103
	}
	public enum EVRInitError
	{
		None = 0,
		Unknown = 1,
		Init_InstallationNotFound = 100,
		Init_InstallationCorrupt = 101,
		Init_VRClientDLLNotFound = 102,
		Init_FileNotFound = 103,
		Init_FactoryNotFound = 104,
		Init_InterfaceNotFound = 105,
		Init_InvalidInterface = 106,
		Init_UserConfigDirectoryInvalid = 107,
		Init_HmdNotFound = 108,
		Init_NotInitialized = 109,
		Init_PathRegistryNotFound = 110,
		Init_NoConfigPath = 111,
		Init_NoLogPath = 112,
		Init_PathRegistryNotWritable = 113,
		Init_AppInfoInitFailed = 114,
		Init_Retry = 115,
		Init_InitCanceledByUser = 116,
		Init_AnotherAppLaunching = 117,
		Init_SettingsInitFailed = 118,
		Init_ShuttingDown = 119,
		Init_TooManyObjects = 120,
		Init_NoServerForBackgroundApp = 121,
		Init_NotSupportedWithCompositor = 122,
		Init_NotAvailableToUtilityApps = 123,
		Init_Internal = 124,
		Init_HmdDriverIdIsNone = 125,
		Init_HmdNotFoundPresenceFailed = 126,
		Init_VRMonitorNotFound = 127,
		Init_VRMonitorStartupFailed = 128,
		Init_LowPowerWatchdogNotSupported = 129,
		Init_InvalidApplicationType = 130,
		Init_NotAvailableToWatchdogApps = 131,
		Init_WatchdogDisabledInSettings = 132,
		Init_VRDashboardNotFound = 133,
		Init_VRDashboardStartupFailed = 134,
		Init_VRHomeNotFound = 135,
		Init_VRHomeStartupFailed = 136,
		Init_RebootingBusy = 137,
		Init_FirmwareUpdateBusy = 138,
		Init_FirmwareRecoveryBusy = 139,
		Init_USBServiceBusy = 140,
		Init_VRWebHelperStartupFailed = 141,
		Driver_Failed = 200,
		Driver_Unknown = 201,
		Driver_HmdUnknown = 202,
		Driver_NotLoaded = 203,
		Driver_RuntimeOutOfDate = 204,
		Driver_HmdInUse = 205,
		Driver_NotCalibrated = 206,
		Driver_CalibrationInvalid = 207,
		Driver_HmdDisplayNotFound = 208,
		Driver_TrackedDeviceInterfaceUnknown = 209,
		Driver_HmdDriverIdOutOfBounds = 211,
		Driver_HmdDisplayMirrored = 212,
		IPC_ServerInitFailed = 300,
		IPC_ConnectFailed = 301,
		IPC_SharedStateInitFailed = 302,
		IPC_CompositorInitFailed = 303,
		IPC_MutexInitFailed = 304,
		IPC_Failed = 305,
		IPC_CompositorConnectFailed = 306,
		IPC_CompositorInvalidConnectResponse = 307,
		IPC_ConnectFailedAfterMultipleAttempts = 308,
		Compositor_Failed = 400,
		Compositor_D3D11HardwareRequired = 401,
		Compositor_FirmwareRequiresUpdate = 402,
		Compositor_OverlayInitFailed = 403,
		Compositor_ScreenshotsInitFailed = 404,
		Compositor_UnableToCreateDevice = 405,
		VendorSpecific_UnableToConnectToOculusRuntime = 1000,
		VendorSpecific_WindowsNotInDevMode = 1001,
		VendorSpecific_HmdFound_CantOpenDevice = 1101,
		VendorSpecific_HmdFound_UnableToRequestConfigStart = 1102,
		VendorSpecific_HmdFound_NoStoredConfig = 1103,
		VendorSpecific_HmdFound_ConfigTooBig = 1104,
		VendorSpecific_HmdFound_ConfigTooSmall = 1105,
		VendorSpecific_HmdFound_UnableToInitZLib = 1106,
		VendorSpecific_HmdFound_CantReadFirmwareVersion = 1107,
		VendorSpecific_HmdFound_UnableToSendUserDataStart = 1108,
		VendorSpecific_HmdFound_UnableToGetUserDataStart = 1109,
		VendorSpecific_HmdFound_UnableToGetUserDataNext = 1110,
		VendorSpecific_HmdFound_UserDataAddressRange = 1111,
		VendorSpecific_HmdFound_UserDataError = 1112,
		VendorSpecific_HmdFound_ConfigFailedSanityCheck = 1113,
		Steam_SteamInstallationNotFound = 2000
	}
	public enum EVRScreenshotType
	{
		None,
		Mono,
		Stereo,
		Cubemap,
		MonoPanorama,
		StereoPanorama
	}
	public enum EVRScreenshotPropertyFilenames
	{
		Preview,
		VR
	}
	public enum EVRTrackedCameraError
	{
		None = 0,
		OperationFailed = 100,
		InvalidHandle = 101,
		InvalidFrameHeaderVersion = 102,
		OutOfHandles = 103,
		IPCFailure = 104,
		NotSupportedForThisDevice = 105,
		SharedMemoryFailure = 106,
		FrameBufferingFailure = 107,
		StreamSetupFailure = 108,
		InvalidGLTextureId = 109,
		InvalidSharedTextureHandle = 110,
		FailedToGetGLTextureId = 111,
		SharedTextureFailure = 112,
		NoFrameAvailable = 113,
		InvalidArgument = 114,
		InvalidFrameBufferSize = 115
	}
	public enum EVRTrackedCameraFrameType
	{
		Distorted,
		Undistorted,
		MaximumUndistorted,
		MAX_CAMERA_FRAME_TYPES
	}
	public enum EVRApplicationError
	{
		None = 0,
		AppKeyAlreadyExists = 100,
		NoManifest = 101,
		NoApplication = 102,
		InvalidIndex = 103,
		UnknownApplication = 104,
		IPCFailed = 105,
		ApplicationAlreadyRunning = 106,
		InvalidManifest = 107,
		InvalidApplication = 108,
		LaunchFailed = 109,
		ApplicationAlreadyStarting = 110,
		LaunchInProgress = 111,
		OldApplicationQuitting = 112,
		TransitionAborted = 113,
		IsTemplate = 114,
		SteamVRIsExiting = 115,
		BufferTooSmall = 200,
		PropertyNotSet = 201,
		UnknownProperty = 202,
		InvalidParameter = 203
	}
	public enum EVRApplicationProperty
	{
		Name_String = 0,
		LaunchType_String = 11,
		WorkingDirectory_String = 12,
		BinaryPath_String = 13,
		Arguments_String = 14,
		URL_String = 15,
		Description_String = 50,
		NewsURL_String = 51,
		ImagePath_String = 52,
		Source_String = 53,
		ActionManifestURL_String = 54,
		IsDashboardOverlay_Bool = 60,
		IsTemplate_Bool = 61,
		IsInstanced_Bool = 62,
		IsInternal_Bool = 63,
		WantsCompositorPauseInStandby_Bool = 64,
		LastLaunchTime_Uint64 = 70
	}
	public enum EVRApplicationTransitionState
	{
		VRApplicationTransition_None = 0,
		VRApplicationTransition_OldAppQuitSent = 10,
		VRApplicationTransition_WaitingForExternalLaunch = 11,
		VRApplicationTransition_NewAppLaunched = 20
	}
	public enum ChaperoneCalibrationState
	{
		OK = 1,
		Warning = 100,
		Warning_BaseStationMayHaveMoved = 101,
		Warning_BaseStationRemoved = 102,
		Warning_SeatedBoundsInvalid = 103,
		Error = 200,
		Error_BaseStationUninitialized = 201,
		Error_BaseStationConflict = 202,
		Error_PlayAreaInvalid = 203,
		Error_CollisionBoundsInvalid = 204
	}
	public enum EChaperoneConfigFile
	{
		Live = 1,
		Temp
	}
	public enum EChaperoneImportFlags
	{
		EChaperoneImport_BoundsOnly = 1
	}
	public enum EVRCompositorError
	{
		None = 0,
		RequestFailed = 1,
		IncompatibleVersion = 100,
		DoNotHaveFocus = 101,
		InvalidTexture = 102,
		IsNotSceneApplication = 103,
		TextureIsOnWrongDevice = 104,
		TextureUsesUnsupportedFormat = 105,
		SharedTexturesNotSupported = 106,
		IndexOutOfRange = 107,
		AlreadySubmitted = 108,
		InvalidBounds = 109
	}
	public enum EVRCompositorTimingMode
	{
		Implicit,
		Explicit_RuntimePerformsPostPresentHandoff,
		Explicit_ApplicationPerformsPostPresentHandoff
	}
	public enum VROverlayInputMethod
	{
		None,
		Mouse,
		DualAnalog
	}
	public enum VROverlayTransformType
	{
		VROverlayTransform_Absolute,
		VROverlayTransform_TrackedDeviceRelative,
		VROverlayTransform_SystemOverlay,
		VROverlayTransform_TrackedComponent
	}
	public enum VROverlayFlags
	{
		None,
		Curved,
		RGSS4X,
		NoDashboardTab,
		AcceptsGamepadEvents,
		ShowGamepadFocus,
		SendVRScrollEvents,
		SendVRTouchpadEvents,
		ShowTouchPadScrollWheel,
		TransferOwnershipToInternalProcess,
		SideBySide_Parallel,
		SideBySide_Crossed,
		Panorama,
		StereoPanorama,
		SortWithNonSceneOverlays,
		VisibleInDashboard
	}
	public enum VRMessageOverlayResponse
	{
		ButtonPress_0,
		ButtonPress_1,
		ButtonPress_2,
		ButtonPress_3,
		CouldntFindSystemOverlay,
		CouldntFindOrCreateClientOverlay,
		ApplicationQuit
	}
	public enum EGamepadTextInputMode
	{
		k_EGamepadTextInputModeNormal,
		k_EGamepadTextInputModePassword,
		k_EGamepadTextInputModeSubmit
	}
	public enum EGamepadTextInputLineMode
	{
		k_EGamepadTextInputLineModeSingleLine,
		k_EGamepadTextInputLineModeMultipleLines
	}
	public enum EOverlayDirection
	{
		Up,
		Down,
		Left,
		Right,
		Count
	}
	public enum EVROverlayIntersectionMaskPrimitiveType
	{
		OverlayIntersectionPrimitiveType_Rectangle,
		OverlayIntersectionPrimitiveType_Circle
	}
	public enum EVRRenderModelError
	{
		None = 0,
		Loading = 100,
		NotSupported = 200,
		InvalidArg = 300,
		InvalidModel = 301,
		NoShapes = 302,
		MultipleShapes = 303,
		TooManyVertices = 304,
		MultipleTextures = 305,
		BufferTooSmall = 306,
		NotEnoughNormals = 307,
		NotEnoughTexCoords = 308,
		InvalidTexture = 400
	}
	public enum EVRComponentProperty
	{
		IsStatic = 1,
		IsVisible = 2,
		IsTouched = 4,
		IsPressed = 8,
		IsScrolled = 0x10
	}
	public enum EVRNotificationType
	{
		Transient,
		Persistent,
		Transient_SystemWithUserValue
	}
	public enum EVRNotificationStyle
	{
		None = 0,
		Application = 100,
		Contact_Disabled = 200,
		Contact_Enabled = 201,
		Contact_Active = 202
	}
	public enum EVRSettingsError
	{
		None,
		IPCFailed,
		WriteFailed,
		ReadFailed,
		JsonParseFailed,
		UnsetSettingHasNoDefault
	}
	public enum EVRScreenshotError
	{
		None = 0,
		RequestFailed = 1,
		IncompatibleVersion = 100,
		NotFound = 101,
		BufferTooSmall = 102,
		ScreenshotAlreadyInProgress = 108
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct VREvent_Data_t
	{
		[FieldOffset(0)]
		public VREvent_Reserved_t reserved;

		[FieldOffset(0)]
		public VREvent_Controller_t controller;

		[FieldOffset(0)]
		public VREvent_Mouse_t mouse;

		[FieldOffset(0)]
		public VREvent_Scroll_t scroll;

		[FieldOffset(0)]
		public VREvent_Process_t process;

		[FieldOffset(0)]
		public VREvent_Notification_t notification;

		[FieldOffset(0)]
		public VREvent_Overlay_t overlay;

		[FieldOffset(0)]
		public VREvent_Status_t status;

		[FieldOffset(0)]
		public VREvent_Ipd_t ipd;

		[FieldOffset(0)]
		public VREvent_Chaperone_t chaperone;

		[FieldOffset(0)]
		public VREvent_PerformanceTest_t performanceTest;

		[FieldOffset(0)]
		public VREvent_TouchPadMove_t touchPadMove;

		[FieldOffset(0)]
		public VREvent_SeatedZeroPoseReset_t seatedZeroPoseReset;

		[FieldOffset(0)]
		public VREvent_Screenshot_t screenshot;

		[FieldOffset(0)]
		public VREvent_ScreenshotProgress_t screenshotProgress;

		[FieldOffset(0)]
		public VREvent_ApplicationLaunch_t applicationLaunch;

		[FieldOffset(0)]
		public VREvent_EditingCameraSurface_t cameraSurface;

		[FieldOffset(0)]
		public VREvent_MessageOverlay_t messageOverlay;

		[FieldOffset(0)]
		public VREvent_Property_t property;

		[FieldOffset(0)]
		public VREvent_DualAnalog_t dualAnalog;

		[FieldOffset(0)]
		public VREvent_HapticVibration_t hapticVibration;

		[FieldOffset(0)]
		public VREvent_Keyboard_t keyboard;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct VROverlayIntersectionMaskPrimitive_Data_t
	{
		[FieldOffset(0)]
		public IntersectionMaskRectangle_t m_Rectangle;

		[FieldOffset(0)]
		public IntersectionMaskCircle_t m_Circle;
	}
	public struct HmdMatrix34_t
	{
		public float m0;

		public float m1;

		public float m2;

		public float m3;

		public float m4;

		public float m5;

		public float m6;

		public float m7;

		public float m8;

		public float m9;

		public float m10;

		public float m11;
	}
	public struct HmdMatrix44_t
	{
		public float m0;

		public float m1;

		public float m2;

		public float m3;

		public float m4;

		public float m5;

		public float m6;

		public float m7;

		public float m8;

		public float m9;

		public float m10;

		public float m11;

		public float m12;

		public float m13;

		public float m14;

		public float m15;
	}
	public struct HmdVector3_t
	{
		public float v0;

		public float v1;

		public float v2;
	}
	public struct HmdVector4_t
	{
		public float v0;

		public float v1;

		public float v2;

		public float v3;
	}
	public struct HmdVector3d_t
	{
		public double v0;

		public double v1;

		public double v2;
	}
	public struct HmdVector2_t
	{
		public float v0;

		public float v1;
	}
	public struct HmdQuaternion_t
	{
		public double w;

		public double x;

		public double y;

		public double z;
	}
	public struct HmdColor_t
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}
	public struct HmdQuad_t
	{
		public HmdVector3_t vCorners0;

		public HmdVector3_t vCorners1;

		public HmdVector3_t vCorners2;

		public HmdVector3_t vCorners3;
	}
	public struct HmdRect2_t
	{
		public HmdVector2_t vTopLeft;

		public HmdVector2_t vBottomRight;
	}
	public struct DistortionCoordinates_t
	{
		public float rfRed0;

		public float rfRed1;

		public float rfGreen0;

		public float rfGreen1;

		public float rfBlue0;

		public float rfBlue1;
	}
	public struct Texture_t
	{
		public IntPtr handle;

		public ETextureType eType;

		public EColorSpace eColorSpace;
	}
	public struct TrackedDevicePose_t
	{
		public HmdMatrix34_t mDeviceToAbsoluteTracking;

		public HmdVector3_t vVelocity;

		public HmdVector3_t vAngularVelocity;

		public ETrackingResult eTrackingResult;

		[MarshalAs(UnmanagedType.I1)]
		public bool bPoseIsValid;

		[MarshalAs(UnmanagedType.I1)]
		public bool bDeviceIsConnected;
	}
	public struct VRTextureBounds_t
	{
		public float uMin;

		public float vMin;

		public float uMax;

		public float vMax;
	}
	public struct VRTextureWithPose_t
	{
		public HmdMatrix34_t mDeviceToAbsoluteTracking;
	}
	public struct VRTextureDepthInfo_t
	{
		public IntPtr handle;

		public HmdMatrix44_t mProjection;

		public HmdVector2_t vRange;
	}
	public struct VRTextureWithDepth_t
	{
		public VRTextureDepthInfo_t depth;
	}
	public struct VRTextureWithPoseAndDepth_t
	{
		public VRTextureDepthInfo_t depth;
	}
	public struct VRVulkanTextureData_t
	{
		public ulong m_nImage;

		public IntPtr m_pDevice;

		public IntPtr m_pPhysicalDevice;

		public IntPtr m_pInstance;

		public IntPtr m_pQueue;

		public uint m_nQueueFamilyIndex;

		public uint m_nWidth;

		public uint m_nHeight;

		public uint m_nFormat;

		public uint m_nSampleCount;
	}
	public struct D3D12TextureData_t
	{
		public IntPtr m_pResource;

		public IntPtr m_pCommandQueue;

		public uint m_nNodeMask;
	}
	public struct VREvent_Controller_t
	{
		public uint button;
	}
	public struct VREvent_Mouse_t
	{
		public float x;

		public float y;

		public uint button;
	}
	public struct VREvent_Scroll_t
	{
		public float xdelta;

		public float ydelta;

		public uint repeatCount;
	}
	public struct VREvent_TouchPadMove_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bFingerDown;

		public float flSecondsFingerDown;

		public float fValueXFirst;

		public float fValueYFirst;

		public float fValueXRaw;

		public float fValueYRaw;
	}
	public struct VREvent_Notification_t
	{
		public ulong ulUserValue;

		public uint notificationId;
	}
	public struct VREvent_Process_t
	{
		public uint pid;

		public uint oldPid;

		[MarshalAs(UnmanagedType.I1)]
		public bool bForced;
	}
	public struct VREvent_Overlay_t
	{
		public ulong overlayHandle;
	}
	public struct VREvent_Status_t
	{
		public uint statusState;
	}
	public struct VREvent_Keyboard_t
	{
		public byte cNewInput0;

		public byte cNewInput1;

		public byte cNewInput2;

		public byte cNewInput3;

		public byte cNewInput4;

		public byte cNewInput5;

		public byte cNewInput6;

		public byte cNewInput7;

		public ulong uUserValue;
	}
	public struct VREvent_Ipd_t
	{
		public float ipdMeters;
	}
	public struct VREvent_Chaperone_t
	{
		public ulong m_nPreviousUniverse;

		public ulong m_nCurrentUniverse;
	}
	public struct VREvent_Reserved_t
	{
		public ulong reserved0;

		public ulong reserved1;

		public ulong reserved2;

		public ulong reserved3;
	}
	public struct VREvent_PerformanceTest_t
	{
		public uint m_nFidelityLevel;
	}
	public struct VREvent_SeatedZeroPoseReset_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bResetBySystemMenu;
	}
	public struct VREvent_Screenshot_t
	{
		public uint handle;

		public uint type;
	}
	public struct VREvent_ScreenshotProgress_t
	{
		public float progress;
	}
	public struct VREvent_ApplicationLaunch_t
	{
		public uint pid;

		public uint unArgsHandle;
	}
	public struct VREvent_EditingCameraSurface_t
	{
		public ulong overlayHandle;

		public uint nVisualMode;
	}
	public struct VREvent_MessageOverlay_t
	{
		public uint unVRMessageOverlayResponse;
	}
	public struct VREvent_Property_t
	{
		public ulong container;

		public ETrackedDeviceProperty prop;
	}
	public struct VREvent_DualAnalog_t
	{
		public float x;

		public float y;

		public float transformedX;

		public float transformedY;

		public EDualAnalogWhich which;
	}
	public struct VREvent_HapticVibration_t
	{
		public ulong containerHandle;

		public ulong componentHandle;

		public float fDurationSeconds;

		public float fFrequency;

		public float fAmplitude;
	}
	public struct VREvent_t
	{
		public uint eventType;

		public uint trackedDeviceIndex;

		public float eventAgeSeconds;

		public VREvent_Data_t data;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct VREvent_t_Packed
	{
		public uint eventType;

		public uint trackedDeviceIndex;

		public float eventAgeSeconds;

		public VREvent_Data_t data;

		public VREvent_t_Packed(VREvent_t unpacked)
		{
			eventType = unpacked.eventType;
			trackedDeviceIndex = unpacked.trackedDeviceIndex;
			eventAgeSeconds = unpacked.eventAgeSeconds;
			data = unpacked.data;
		}

		public void Unpack(ref VREvent_t unpacked)
		{
			unpacked.eventType = eventType;
			unpacked.trackedDeviceIndex = trackedDeviceIndex;
			unpacked.eventAgeSeconds = eventAgeSeconds;
			unpacked.data = data;
		}
	}
	public struct HiddenAreaMesh_t
	{
		public IntPtr pVertexData;

		public uint unTriangleCount;
	}
	public struct VRControllerAxis_t
	{
		public float x;

		public float y;
	}
	public struct VRControllerState_t
	{
		public uint unPacketNum;

		public ulong ulButtonPressed;

		public ulong ulButtonTouched;

		public VRControllerAxis_t rAxis0;

		public VRControllerAxis_t rAxis1;

		public VRControllerAxis_t rAxis2;

		public VRControllerAxis_t rAxis3;

		public VRControllerAxis_t rAxis4;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct VRControllerState_t_Packed
	{
		public uint unPacketNum;

		public ulong ulButtonPressed;

		public ulong ulButtonTouched;

		public VRControllerAxis_t rAxis0;

		public VRControllerAxis_t rAxis1;

		public VRControllerAxis_t rAxis2;

		public VRControllerAxis_t rAxis3;

		public VRControllerAxis_t rAxis4;

		public VRControllerState_t_Packed(VRControllerState_t unpacked)
		{
			unPacketNum = unpacked.unPacketNum;
			ulButtonPressed = unpacked.ulButtonPressed;
			ulButtonTouched = unpacked.ulButtonTouched;
			rAxis0 = unpacked.rAxis0;
			rAxis1 = unpacked.rAxis1;
			rAxis2 = unpacked.rAxis2;
			rAxis3 = unpacked.rAxis3;
			rAxis4 = unpacked.rAxis4;
		}

		public void Unpack(ref VRControllerState_t unpacked)
		{
			unpacked.unPacketNum = unPacketNum;
			unpacked.ulButtonPressed = ulButtonPressed;
			unpacked.ulButtonTouched = ulButtonTouched;
			unpacked.rAxis0 = rAxis0;
			unpacked.rAxis1 = rAxis1;
			unpacked.rAxis2 = rAxis2;
			unpacked.rAxis3 = rAxis3;
			unpacked.rAxis4 = rAxis4;
		}
	}
	public struct Compositor_OverlaySettings
	{
		public uint size;

		[MarshalAs(UnmanagedType.I1)]
		public bool curved;

		[MarshalAs(UnmanagedType.I1)]
		public bool antialias;

		public float scale;

		public float distance;

		public float alpha;

		public float uOffset;

		public float vOffset;

		public float uScale;

		public float vScale;

		public float gridDivs;

		public float gridWidth;

		public float gridScale;

		public HmdMatrix44_t transform;
	}
	public struct CameraVideoStreamFrameHeader_t
	{
		public EVRTrackedCameraFrameType eFrameType;

		public uint nWidth;

		public uint nHeight;

		public uint nBytesPerPixel;

		public uint nFrameSequence;

		public TrackedDevicePose_t standingTrackedDevicePose;
	}
	public struct DriverDirectMode_FrameTiming
	{
		public uint m_nSize;

		public uint m_nNumFramePresents;

		public uint m_nNumMisPresented;

		public uint m_nNumDroppedFrames;

		public uint m_nReprojectionFlags;
	}
	public struct AppOverrideKeys_t
	{
		public IntPtr pchKey;

		public IntPtr pchValue;
	}
	public struct Compositor_FrameTiming
	{
		public uint m_nSize;

		public uint m_nFrameIndex;

		public uint m_nNumFramePresents;

		public uint m_nNumMisPresented;

		public uint m_nNumDroppedFrames;

		public uint m_nReprojectionFlags;

		public double m_flSystemTimeInSeconds;

		public float m_flPreSubmitGpuMs;

		public float m_flPostSubmitGpuMs;

		public float m_flTotalRenderGpuMs;

		public float m_flCompositorRenderGpuMs;

		public float m_flCompositorRenderCpuMs;

		public float m_flCompositorIdleCpuMs;

		public float m_flClientFrameIntervalMs;

		public float m_flPresentCallCpuMs;

		public float m_flWaitForPresentCpuMs;

		public float m_flSubmitFrameMs;

		public float m_flWaitGetPosesCalledMs;

		public float m_flNewPosesReadyMs;

		public float m_flNewFrameReadyMs;

		public float m_flCompositorUpdateStartMs;

		public float m_flCompositorUpdateEndMs;

		public float m_flCompositorRenderStartMs;

		public TrackedDevicePose_t m_HmdPose;
	}
	public struct Compositor_CumulativeStats
	{
		public uint m_nPid;

		public uint m_nNumFramePresents;

		public uint m_nNumDroppedFrames;

		public uint m_nNumReprojectedFrames;

		public uint m_nNumFramePresentsOnStartup;

		public uint m_nNumDroppedFramesOnStartup;

		public uint m_nNumReprojectedFramesOnStartup;

		public uint m_nNumLoading;

		public uint m_nNumFramePresentsLoading;

		public uint m_nNumDroppedFramesLoading;

		public uint m_nNumReprojectedFramesLoading;

		public uint m_nNumTimedOut;

		public uint m_nNumFramePresentsTimedOut;

		public uint m_nNumDroppedFramesTimedOut;

		public uint m_nNumReprojectedFramesTimedOut;
	}
	public struct VROverlayIntersectionParams_t
	{
		public HmdVector3_t vSource;

		public HmdVector3_t vDirection;

		public ETrackingUniverseOrigin eOrigin;
	}
	public struct VROverlayIntersectionResults_t
	{
		public HmdVector3_t vPoint;

		public HmdVector3_t vNormal;

		public HmdVector2_t vUVs;

		public float fDistance;
	}
	public struct IntersectionMaskRectangle_t
	{
		public float m_flTopLeftX;

		public float m_flTopLeftY;

		public float m_flWidth;

		public float m_flHeight;
	}
	public struct IntersectionMaskCircle_t
	{
		public float m_flCenterX;

		public float m_flCenterY;

		public float m_flRadius;
	}
	public struct VROverlayIntersectionMaskPrimitive_t
	{
		public EVROverlayIntersectionMaskPrimitiveType m_nPrimitiveType;

		public VROverlayIntersectionMaskPrimitive_Data_t m_Primitive;
	}
	public struct RenderModel_ComponentState_t
	{
		public HmdMatrix34_t mTrackingToComponentRenderModel;

		public HmdMatrix34_t mTrackingToComponentLocal;

		public uint uProperties;
	}
	public struct RenderModel_Vertex_t
	{
		public HmdVector3_t vPosition;

		public HmdVector3_t vNormal;

		public float rfTextureCoord0;

		public float rfTextureCoord1;
	}
	public struct RenderModel_TextureMap_t
	{
		public char unWidth;

		public char unHeight;

		public IntPtr rubTextureMapData;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct RenderModel_TextureMap_t_Packed
	{
		public char unWidth;

		public char unHeight;

		public IntPtr rubTextureMapData;

		public RenderModel_TextureMap_t_Packed(RenderModel_TextureMap_t unpacked)
		{
			unWidth = unpacked.unWidth;
			unHeight = unpacked.unHeight;
			rubTextureMapData = unpacked.rubTextureMapData;
		}

		public void Unpack(ref RenderModel_TextureMap_t unpacked)
		{
			unpacked.unWidth = unWidth;
			unpacked.unHeight = unHeight;
			unpacked.rubTextureMapData = rubTextureMapData;
		}
	}
	public struct RenderModel_t
	{
		public IntPtr rVertexData;

		public uint unVertexCount;

		public IntPtr rIndexData;

		public uint unTriangleCount;

		public int diffuseTextureId;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct RenderModel_t_Packed
	{
		public IntPtr rVertexData;

		public uint unVertexCount;

		public IntPtr rIndexData;

		public uint unTriangleCount;

		public int diffuseTextureId;

		public RenderModel_t_Packed(RenderModel_t unpacked)
		{
			rVertexData = unpacked.rVertexData;
			unVertexCount = unpacked.unVertexCount;
			rIndexData = unpacked.rIndexData;
			unTriangleCount = unpacked.unTriangleCount;
			diffuseTextureId = unpacked.diffuseTextureId;
		}

		public void Unpack(ref RenderModel_t unpacked)
		{
			unpacked.rVertexData = rVertexData;
			unpacked.unVertexCount = unVertexCount;
			unpacked.rIndexData = rIndexData;
			unpacked.unTriangleCount = unTriangleCount;
			unpacked.diffuseTextureId = diffuseTextureId;
		}
	}
	public struct RenderModel_ControllerMode_State_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bScrollWheelVisible;
	}
	public struct NotificationBitmap_t
	{
		public IntPtr m_pImageData;

		public int m_nWidth;

		public int m_nHeight;

		public int m_nBytesPerPixel;
	}
	public struct COpenVRContext
	{
		public IntPtr m_pVRSystem;

		public IntPtr m_pVRChaperone;

		public IntPtr m_pVRChaperoneSetup;

		public IntPtr m_pVRCompositor;

		public IntPtr m_pVROverlay;

		public IntPtr m_pVRResources;

		public IntPtr m_pVRRenderModels;

		public IntPtr m_pVRExtendedDisplay;

		public IntPtr m_pVRSettings;

		public IntPtr m_pVRApplications;

		public IntPtr m_pVRTrackedCamera;

		public IntPtr m_pVRScreenshots;

		public IntPtr m_pVRDriverManager;
	}
	public class OpenVR
	{
		private class COpenVRContext
		{
			private CVRSystem m_pVRSystem;

			private CVRChaperone m_pVRChaperone;

			private CVRChaperoneSetup m_pVRChaperoneSetup;

			private CVRCompositor m_pVRCompositor;

			private CVROverlay m_pVROverlay;

			private CVRRenderModels m_pVRRenderModels;

			private CVRExtendedDisplay m_pVRExtendedDisplay;

			private CVRSettings m_pVRSettings;

			private CVRApplications m_pVRApplications;

			private CVRScreenshots m_pVRScreenshots;

			private CVRTrackedCamera m_pVRTrackedCamera;

			public COpenVRContext()
			{
				Clear();
			}

			public void Clear()
			{
				m_pVRSystem = null;
				m_pVRChaperone = null;
				m_pVRChaperoneSetup = null;
				m_pVRCompositor = null;
				m_pVROverlay = null;
				m_pVRRenderModels = null;
				m_pVRExtendedDisplay = null;
				m_pVRSettings = null;
				m_pVRApplications = null;
				m_pVRScreenshots = null;
				m_pVRTrackedCamera = null;
			}

			private void CheckClear()
			{
				if (VRToken != GetInitToken())
				{
					Clear();
					VRToken = GetInitToken();
				}
			}

			public CVRSystem VRSystem()
			{
				CheckClear();
				if (m_pVRSystem == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRSystem_019", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRSystem = new CVRSystem(genericInterface);
					}
				}
				return m_pVRSystem;
			}

			public CVRChaperone VRChaperone()
			{
				CheckClear();
				if (m_pVRChaperone == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRChaperone_003", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRChaperone = new CVRChaperone(genericInterface);
					}
				}
				return m_pVRChaperone;
			}

			public CVRChaperoneSetup VRChaperoneSetup()
			{
				CheckClear();
				if (m_pVRChaperoneSetup == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRChaperoneSetup_005", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRChaperoneSetup = new CVRChaperoneSetup(genericInterface);
					}
				}
				return m_pVRChaperoneSetup;
			}

			public CVRCompositor VRCompositor()
			{
				CheckClear();
				if (m_pVRCompositor == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRCompositor_022", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRCompositor = new CVRCompositor(genericInterface);
					}
				}
				return m_pVRCompositor;
			}

			public CVROverlay VROverlay()
			{
				CheckClear();
				if (m_pVROverlay == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVROverlay_018", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVROverlay = new CVROverlay(genericInterface);
					}
				}
				return m_pVROverlay;
			}

			public CVRRenderModels VRRenderModels()
			{
				CheckClear();
				if (m_pVRRenderModels == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRRenderModels_005", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRRenderModels = new CVRRenderModels(genericInterface);
					}
				}
				return m_pVRRenderModels;
			}

			public CVRExtendedDisplay VRExtendedDisplay()
			{
				CheckClear();
				if (m_pVRExtendedDisplay == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRExtendedDisplay_001", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRExtendedDisplay = new CVRExtendedDisplay(genericInterface);
					}
				}
				return m_pVRExtendedDisplay;
			}

			public CVRSettings VRSettings()
			{
				CheckClear();
				if (m_pVRSettings == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRSettings_002", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRSettings = new CVRSettings(genericInterface);
					}
				}
				return m_pVRSettings;
			}

			public CVRApplications VRApplications()
			{
				CheckClear();
				if (m_pVRApplications == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRApplications_006", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRApplications = new CVRApplications(genericInterface);
					}
				}
				return m_pVRApplications;
			}

			public CVRScreenshots VRScreenshots()
			{
				CheckClear();
				if (m_pVRScreenshots == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRScreenshots_001", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRScreenshots = new CVRScreenshots(genericInterface);
					}
				}
				return m_pVRScreenshots;
			}

			public CVRTrackedCamera VRTrackedCamera()
			{
				CheckClear();
				if (m_pVRTrackedCamera == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRTrackedCamera_003", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRTrackedCamera = new CVRTrackedCamera(genericInterface);
					}
				}
				return m_pVRTrackedCamera;
			}
		}

		public const uint k_nDriverNone = uint.MaxValue;

		public const uint k_unMaxDriverDebugResponseSize = 32768u;

		public const uint k_unTrackedDeviceIndex_Hmd = 0u;

		public const uint k_unMaxTrackedDeviceCount = 64u;

		public const uint k_unTrackedDeviceIndexOther = 4294967294u;

		public const uint k_unTrackedDeviceIndexInvalid = uint.MaxValue;

		public const ulong k_ulInvalidPropertyContainer = 0uL;

		public const uint k_unInvalidPropertyTag = 0u;

		public const ulong k_ulInvalidDriverHandle = 0uL;

		public const uint k_unFloatPropertyTag = 1u;

		public const uint k_unInt32PropertyTag = 2u;

		public const uint k_unUint64PropertyTag = 3u;

		public const uint k_unBoolPropertyTag = 4u;

		public const uint k_unStringPropertyTag = 5u;

		public const uint k_unHmdMatrix34PropertyTag = 20u;

		public const uint k_unHmdMatrix44PropertyTag = 21u;

		public const uint k_unHmdVector3PropertyTag = 22u;

		public const uint k_unHmdVector4PropertyTag = 23u;

		public const uint k_unHiddenAreaPropertyTag = 30u;

		public const uint k_unPathHandleInfoTag = 31u;

		public const uint k_unActionPropertyTag = 32u;

		public const uint k_unInputValuePropertyTag = 33u;

		public const uint k_unWildcardPropertyTag = 34u;

		public const uint k_unHapticVibrationPropertyTag = 35u;

		public const uint k_unOpenVRInternalReserved_Start = 1000u;

		public const uint k_unOpenVRInternalReserved_End = 10000u;

		public const uint k_unMaxPropertyStringSize = 32768u;

		public const uint k_unControllerStateAxisCount = 5u;

		public const ulong k_ulOverlayHandleInvalid = 0uL;

		public const uint k_unScreenshotHandleInvalid = 0u;

		public const string IVRSystem_Version = "IVRSystem_019";

		public const string IVRExtendedDisplay_Version = "IVRExtendedDisplay_001";

		public const string IVRTrackedCamera_Version = "IVRTrackedCamera_003";

		public const uint k_unMaxApplicationKeyLength = 128u;

		public const string k_pch_MimeType_HomeApp = "vr/home";

		public const string k_pch_MimeType_GameTheater = "vr/game_theater";

		public const string IVRApplications_Version = "IVRApplications_006";

		public const string IVRChaperone_Version = "IVRChaperone_003";

		public const string IVRChaperoneSetup_Version = "IVRChaperoneSetup_005";

		public const string IVRCompositor_Version = "IVRCompositor_022";

		public const uint k_unVROverlayMaxKeyLength = 128u;

		public const uint k_unVROverlayMaxNameLength = 128u;

		public const uint k_unMaxOverlayCount = 64u;

		public const uint k_unMaxOverlayIntersectionMaskPrimitivesCount = 32u;

		public const string IVROverlay_Version = "IVROverlay_018";

		public const string k_pch_Controller_Component_GDC2015 = "gdc2015";

		public const string k_pch_Controller_Component_Base = "base";

		public const string k_pch_Controller_Component_Tip = "tip";

		public const string k_pch_Controller_Component_HandGrip = "handgrip";

		public const string k_pch_Controller_Component_Status = "status";

		public const string IVRRenderModels_Version = "IVRRenderModels_005";

		public const uint k_unNotificationTextMaxSize = 256u;

		public const string IVRNotifications_Version = "IVRNotifications_002";

		public const uint k_unMaxSettingsKeyLength = 128u;

		public const string IVRSettings_Version = "IVRSettings_002";

		public const string k_pch_SteamVR_Section = "steamvr";

		public const string k_pch_SteamVR_RequireHmd_String = "requireHmd";

		public const string k_pch_SteamVR_ForcedDriverKey_String = "forcedDriver";

		public const string k_pch_SteamVR_ForcedHmdKey_String = "forcedHmd";

		public const string k_pch_SteamVR_DisplayDebug_Bool = "displayDebug";

		public const string k_pch_SteamVR_DebugProcessPipe_String = "debugProcessPipe";

		public const string k_pch_SteamVR_DisplayDebugX_Int32 = "displayDebugX";

		public const string k_pch_SteamVR_DisplayDebugY_Int32 = "displayDebugY";

		public const string k_pch_SteamVR_SendSystemButtonToAllApps_Bool = "sendSystemButtonToAllApps";

		public const string k_pch_SteamVR_LogLevel_Int32 = "loglevel";

		public const string k_pch_SteamVR_IPD_Float = "ipd";

		public const string k_pch_SteamVR_Background_String = "background";

		public const string k_pch_SteamVR_BackgroundUseDomeProjection_Bool = "backgroundUseDomeProjection";

		public const string k_pch_SteamVR_BackgroundCameraHeight_Float = "backgroundCameraHeight";

		public const string k_pch_SteamVR_BackgroundDomeRadius_Float = "backgroundDomeRadius";

		public const string k_pch_SteamVR_GridColor_String = "gridColor";

		public const string k_pch_SteamVR_PlayAreaColor_String = "playAreaColor";

		public const string k_pch_SteamVR_ShowStage_Bool = "showStage";

		public const string k_pch_SteamVR_ActivateMultipleDrivers_Bool = "activateMultipleDrivers";

		public const string k_pch_SteamVR_DirectMode_Bool = "directMode";

		public const string k_pch_SteamVR_DirectModeEdidVid_Int32 = "directModeEdidVid";

		public const string k_pch_SteamVR_DirectModeEdidPid_Int32 = "directModeEdidPid";

		public const string k_pch_SteamVR_UsingSpeakers_Bool = "usingSpeakers";

		public const string k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float = "speakersForwardYawOffsetDegrees";

		public const string k_pch_SteamVR_BaseStationPowerManagement_Bool = "basestationPowerManagement";

		public const string k_pch_SteamVR_NeverKillProcesses_Bool = "neverKillProcesses";

		public const string k_pch_SteamVR_SupersampleScale_Float = "supersampleScale";

		public const string k_pch_SteamVR_AllowAsyncReprojection_Bool = "allowAsyncReprojection";

		public const string k_pch_SteamVR_AllowReprojection_Bool = "allowInterleavedReprojection";

		public const string k_pch_SteamVR_ForceReprojection_Bool = "forceReprojection";

		public const string k_pch_SteamVR_ForceFadeOnBadTracking_Bool = "forceFadeOnBadTracking";

		public const string k_pch_SteamVR_DefaultMirrorView_Int32 = "defaultMirrorView";

		public const string k_pch_SteamVR_ShowMirrorView_Bool = "showMirrorView";

		public const string k_pch_SteamVR_MirrorViewGeometry_String = "mirrorViewGeometry";

		public const string k_pch_SteamVR_StartMonitorFromAppLaunch = "startMonitorFromAppLaunch";

		public const string k_pch_SteamVR_StartCompositorFromAppLaunch_Bool = "startCompositorFromAppLaunch";

		public const string k_pch_SteamVR_StartDashboardFromAppLaunch_Bool = "startDashboardFromAppLaunch";

		public const string k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool = "startOverlayAppsFromDashboard";

		public const string k_pch_SteamVR_EnableHomeApp = "enableHomeApp";

		public const string k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32 = "CycleBackgroundImageTimeSec";

		public const string k_pch_SteamVR_RetailDemo_Bool = "retailDemo";

		public const string k_pch_SteamVR_IpdOffset_Float = "ipdOffset";

		public const string k_pch_SteamVR_AllowSupersampleFiltering_Bool = "allowSupersampleFiltering";

		public const string k_pch_SteamVR_EnableLinuxVulkanAsync_Bool = "enableLinuxVulkanAsync";

		public const string k_pch_SteamVR_AllowDisplayLockedMode_Bool = "allowDisplayLockedMode";

		public const string k_pch_SteamVR_HaveStartedTutorialForNativeChaperoneDriver_Bool = "haveStartedTutorialForNativeChaperoneDriver";

		public const string k_pch_SteamVR_ForceWindows32bitVRMonitor = "forceWindows32BitVRMonitor";

		public const string k_pch_SteamVR_DebugInput = "debugInput";

		public const string k_pch_Lighthouse_Section = "driver_lighthouse";

		public const string k_pch_Lighthouse_DisableIMU_Bool = "disableimu";

		public const string k_pch_Lighthouse_DisableIMUExceptHMD_Bool = "disableimuexcepthmd";

		public const string k_pch_Lighthouse_UseDisambiguation_String = "usedisambiguation";

		public const string k_pch_Lighthouse_DisambiguationDebug_Int32 = "disambiguationdebug";

		public const string k_pch_Lighthouse_PrimaryBasestation_Int32 = "primarybasestation";

		public const string k_pch_Lighthouse_DBHistory_Bool = "dbhistory";

		public const string k_pch_Lighthouse_EnableBluetooth_Bool = "enableBluetooth";

		public const string k_pch_Lighthouse_PowerManagedBaseStations_String = "PowerManagedBaseStations";

		public const string k_pch_Null_Section = "driver_null";

		public const string k_pch_Null_SerialNumber_String = "serialNumber";

		public const string k_pch_Null_ModelNumber_String = "modelNumber";

		public const string k_pch_Null_WindowX_Int32 = "windowX";

		public const string k_pch_Null_WindowY_Int32 = "windowY";

		public const string k_pch_Null_WindowWidth_Int32 = "windowWidth";

		public const string k_pch_Null_WindowHeight_Int32 = "windowHeight";

		public const string k_pch_Null_RenderWidth_Int32 = "renderWidth";

		public const string k_pch_Null_RenderHeight_Int32 = "renderHeight";

		public const string k_pch_Null_SecondsFromVsyncToPhotons_Float = "secondsFromVsyncToPhotons";

		public const string k_pch_Null_DisplayFrequency_Float = "displayFrequency";

		public const string k_pch_UserInterface_Section = "userinterface";

		public const string k_pch_UserInterface_StatusAlwaysOnTop_Bool = "StatusAlwaysOnTop";

		public const string k_pch_UserInterface_MinimizeToTray_Bool = "MinimizeToTray";

		public const string k_pch_UserInterface_Screenshots_Bool = "screenshots";

		public const string k_pch_UserInterface_ScreenshotType_Int = "screenshotType";

		public const string k_pch_Notifications_Section = "notifications";

		public const string k_pch_Notifications_DoNotDisturb_Bool = "DoNotDisturb";

		public const string k_pch_Keyboard_Section = "keyboard";

		public const string k_pch_Keyboard_TutorialCompletions = "TutorialCompletions";

		public const string k_pch_Keyboard_ScaleX = "ScaleX";

		public const string k_pch_Keyboard_ScaleY = "ScaleY";

		public const string k_pch_Keyboard_OffsetLeftX = "OffsetLeftX";

		public const string k_pch_Keyboard_OffsetRightX = "OffsetRightX";

		public const string k_pch_Keyboard_OffsetY = "OffsetY";

		public const string k_pch_Keyboard_Smoothing = "Smoothing";

		public const string k_pch_Perf_Section = "perfcheck";

		public const string k_pch_Perf_HeuristicActive_Bool = "heuristicActive";

		public const string k_pch_Perf_NotifyInHMD_Bool = "warnInHMD";

		public const string k_pch_Perf_NotifyOnlyOnce_Bool = "warnOnlyOnce";

		public const string k_pch_Perf_AllowTimingStore_Bool = "allowTimingStore";

		public const string k_pch_Perf_SaveTimingsOnExit_Bool = "saveTimingsOnExit";

		public const string k_pch_Perf_TestData_Float = "perfTestData";

		public const string k_pch_Perf_LinuxGPUProfiling_Bool = "linuxGPUProfiling";

		public const string k_pch_CollisionBounds_Section = "collisionBounds";

		public const string k_pch_CollisionBounds_Style_Int32 = "CollisionBoundsStyle";

		public const string k_pch_CollisionBounds_GroundPerimeterOn_Bool = "CollisionBoundsGroundPerimeterOn";

		public const string k_pch_CollisionBounds_CenterMarkerOn_Bool = "CollisionBoundsCenterMarkerOn";

		public const string k_pch_CollisionBounds_PlaySpaceOn_Bool = "CollisionBoundsPlaySpaceOn";

		public const string k_pch_CollisionBounds_FadeDistance_Float = "CollisionBoundsFadeDistance";

		public const string k_pch_CollisionBounds_ColorGammaR_Int32 = "CollisionBoundsColorGammaR";

		public const string k_pch_CollisionBounds_ColorGammaG_Int32 = "CollisionBoundsColorGammaG";

		public const string k_pch_CollisionBounds_ColorGammaB_Int32 = "CollisionBoundsColorGammaB";

		public const string k_pch_CollisionBounds_ColorGammaA_Int32 = "CollisionBoundsColorGammaA";

		public const string k_pch_Camera_Section = "camera";

		public const string k_pch_Camera_EnableCamera_Bool = "enableCamera";

		public const string k_pch_Camera_EnableCameraInDashboard_Bool = "enableCameraInDashboard";

		public const string k_pch_Camera_EnableCameraForCollisionBounds_Bool = "enableCameraForCollisionBounds";

		public const string k_pch_Camera_EnableCameraForRoomView_Bool = "enableCameraForRoomView";

		public const string k_pch_Camera_BoundsColorGammaR_Int32 = "cameraBoundsColorGammaR";

		public const string k_pch_Camera_BoundsColorGammaG_Int32 = "cameraBoundsColorGammaG";

		public const string k_pch_Camera_BoundsColorGammaB_Int32 = "cameraBoundsColorGammaB";

		public const string k_pch_Camera_BoundsColorGammaA_Int32 = "cameraBoundsColorGammaA";

		public const string k_pch_Camera_BoundsStrength_Int32 = "cameraBoundsStrength";

		public const string k_pch_audio_Section = "audio";

		public const string k_pch_audio_OnPlaybackDevice_String = "onPlaybackDevice";

		public const string k_pch_audio_OnRecordDevice_String = "onRecordDevice";

		public const string k_pch_audio_OnPlaybackMirrorDevice_String = "onPlaybackMirrorDevice";

		public const string k_pch_audio_OffPlaybackDevice_String = "offPlaybackDevice";

		public const string k_pch_audio_OffRecordDevice_String = "offRecordDevice";

		public const string k_pch_audio_VIVEHDMIGain = "viveHDMIGain";

		public const string k_pch_Power_Section = "power";

		public const string k_pch_Power_PowerOffOnExit_Bool = "powerOffOnExit";

		public const string k_pch_Power_TurnOffScreensTimeout_Float = "turnOffScreensTimeout";

		public const string k_pch_Power_TurnOffControllersTimeout_Float = "turnOffControllersTimeout";

		public const string k_pch_Power_ReturnToWatchdogTimeout_Float = "returnToWatchdogTimeout";

		public const string k_pch_Power_AutoLaunchSteamVROnButtonPress = "autoLaunchSteamVROnButtonPress";

		public const string k_pch_Power_PauseCompositorOnStandby_Bool = "pauseCompositorOnStandby";

		public const string k_pch_Dashboard_Section = "dashboard";

		public const string k_pch_Dashboard_EnableDashboard_Bool = "enableDashboard";

		public const string k_pch_Dashboard_ArcadeMode_Bool = "arcadeMode";

		public const string k_pch_Dashboard_EnableWebUI = "webUI";

		public const string k_pch_modelskin_Section = "modelskins";

		public const string k_pch_Driver_Enable_Bool = "enable";

		public const string k_pch_WebInterface_Section = "WebInterface";

		public const string k_pch_WebInterface_WebPort_String = "WebPort";

		public const string IVRScreenshots_Version = "IVRScreenshots_001";

		public const string IVRResources_Version = "IVRResources_001";

		public const string IVRDriverManager_Version = "IVRDriverManager_001";

		private const string FnTable_Prefix = "FnTable:";

		private static COpenVRContext _OpenVRInternal_ModuleContext;

		private static uint VRToken { get; set; }

		private static COpenVRContext OpenVRInternal_ModuleContext
		{
			get
			{
				if (_OpenVRInternal_ModuleContext == null)
				{
					_OpenVRInternal_ModuleContext = new COpenVRContext();
				}
				return _OpenVRInternal_ModuleContext;
			}
		}

		public static CVRSystem System => OpenVRInternal_ModuleContext.VRSystem();

		public static CVRChaperone Chaperone => OpenVRInternal_ModuleContext.VRChaperone();

		public static CVRChaperoneSetup ChaperoneSetup => OpenVRInternal_ModuleContext.VRChaperoneSetup();

		public static CVRCompositor Compositor => OpenVRInternal_ModuleContext.VRCompositor();

		public static CVROverlay Overlay => OpenVRInternal_ModuleContext.VROverlay();

		public static CVRRenderModels RenderModels => OpenVRInternal_ModuleContext.VRRenderModels();

		public static CVRExtendedDisplay ExtendedDisplay => OpenVRInternal_ModuleContext.VRExtendedDisplay();

		public static CVRSettings Settings => OpenVRInternal_ModuleContext.VRSettings();

		public static CVRApplications Applications => OpenVRInternal_ModuleContext.VRApplications();

		public static CVRScreenshots Screenshots => OpenVRInternal_ModuleContext.VRScreenshots();

		public static CVRTrackedCamera TrackedCamera => OpenVRInternal_ModuleContext.VRTrackedCamera();

		public static uint InitInternal(ref EVRInitError peError, EVRApplicationType eApplicationType)
		{
			return OpenVRInterop.InitInternal(ref peError, eApplicationType);
		}

		public static void ShutdownInternal()
		{
			OpenVRInterop.ShutdownInternal();
		}

		public static bool IsHmdPresent()
		{
			return OpenVRInterop.IsHmdPresent();
		}

		public static bool IsRuntimeInstalled()
		{
			return OpenVRInterop.IsRuntimeInstalled();
		}

		public static string GetStringForHmdError(EVRInitError error)
		{
			return Marshal.PtrToStringAnsi(OpenVRInterop.GetStringForHmdError(error));
		}

		public static IntPtr GetGenericInterface(string pchInterfaceVersion, ref EVRInitError peError)
		{
			return OpenVRInterop.GetGenericInterface(pchInterfaceVersion, ref peError);
		}

		public static bool IsInterfaceVersionValid(string pchInterfaceVersion)
		{
			return OpenVRInterop.IsInterfaceVersionValid(pchInterfaceVersion);
		}

		public static uint GetInitToken()
		{
			return OpenVRInterop.GetInitToken();
		}

		public static CVRSystem Init(ref EVRInitError peError, EVRApplicationType eApplicationType = EVRApplicationType.VRApplication_Scene)
		{
			VRToken = InitInternal(ref peError, eApplicationType);
			OpenVRInternal_ModuleContext.Clear();
			if (peError != 0)
			{
				return null;
			}
			if (!IsInterfaceVersionValid("IVRSystem_019"))
			{
				ShutdownInternal();
				peError = EVRInitError.Init_InterfaceNotFound;
				return null;
			}
			return System;
		}

		public static void Shutdown()
		{
			ShutdownInternal();
		}
	}
}
namespace Progreso
{
	public class PlayerProgreso : MonoBehaviour
	{
		public static PlayerProgreso instance;

		public int dificultadActual;

		public Vector2 resolucionPantalla = Vector2.one;

		[HideInInspector]
		public int rachaVictorias;

		[HideInInspector]
		public int rachaDerrotas;

		public bool tengoLIVActivado;

		public LIV.SDK.Unity.LIV liv;

		public int proTipQueTocaMostrar;

		public bool MostrarMensajeNoPoerUpUsado;

		public bool PowerUpUsado;

		public bool MostrarMensajeTipCambiarGancho;

		public int ultimoNivelPasado;

		public int ultimoPaisPasado;

		[HideInInspector]
		public bool primeroRequest;

		private void Awake()
		{
			base.transform.SetParent(null);
			if (instance != null && instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(this);
		}

		private void Start()
		{
			CargarPaisYNivelPasado();
		}

		public void ResetearPlayerProgreso()
		{
		}

		public string ConvertirINTaSTRING10(int num)
		{
			string text = "";
			string text2 = num.ToString();
			for (int i = 0; i < 10 - text2.Length; i++)
			{
				text += "0";
			}
			return text + text2;
		}

		public int ConvertirSTRINGaINT(string num)
		{
			int result = 0;
			int i;
			for (i = 0; i < num.Length - 1 && num[i] == '0'; i++)
			{
			}
			num = num.Remove(0, i);
			int.TryParse(num, out result);
			return result;
		}

		public void SetRachaVictoriasDerrotas(bool victoria)
		{
		}

		public void GuardarSettings()
		{
		}

		public void CargarSettings()
		{
		}

		public void ResetearEstado()
		{
			PersistentDataManager.SetInt("PaisPasado", 0);
			PersistentDataManager.SetInt("NivelPasado", 0);
			PersistentDataManager.SetInt("IntroVista", 0);
			PersistentDataManager.SetInt("ProTipQueTocaMostrar", 1);
			PersistentDataManager.SetFloat("Volumen_musica", 1f);
			PersistentDataManager.SetFloat("Volumen_fx", 1f);
			PersistentDataManager.SetInt("Calidad", (int)CalidadManager.instance.GetCalidadRecomendada());
			PersistentDataManager.SaveData();
		}

		public void CargarPaisYNivelPasado()
		{
			ultimoPaisPasado = PersistentDataManager.GetInt("PaisPasado");
			ultimoNivelPasado = PersistentDataManager.GetInt("NivelPasado");
			proTipQueTocaMostrar = PersistentDataManager.GetInt("ProTipQueTocaMostrar", 1);
		}

		public void GuardarNuevoPaisPasado()
		{
			PersistentDataManager.SetInt("PaisPasado", GameManager.instance.paisActual);
			PersistentDataManager.SetInt("NivelPasado", 0);
			PersistentDataManager.SetInt("ProTipQueTocaMostrar", proTipQueTocaMostrar);
			PersistentDataManager.SaveData();
			ultimoPaisPasado = GameManager.instance.paisActual;
			ultimoNivelPasado = 0;
		}

		public void GuardarNuevoNivelPasado()
		{
			PersistentDataManager.SetInt("NivelPasado", GameManager.instance.nivelActual);
			PersistentDataManager.SetInt("ProTipQueTocaMostrar", proTipQueTocaMostrar);
			PersistentDataManager.SaveData();
			ultimoNivelPasado = GameManager.instance.nivelActual;
		}
	}
}
namespace PA.ParticleField.Samples
{
	public class FPSCounter : MonoBehaviour
	{
		public TextMesh texto;

		public float updateInterval = 0.5f;

		private float accum;

		private int frames;

		private float timeleft;

		private string frameString;

		public int avgFrameRate;

		private void Start()
		{
			texto = GetComponent<TextMesh>();
			timeleft = updateInterval;
		}

		private void Update()
		{
			timeleft -= Time.deltaTime;
			accum += Time.timeScale / Time.deltaTime;
			frames++;
			if ((double)timeleft <= 0.0)
			{
				float num = accum / (float)frames;
				frameString = ((int)num).ToString();
				timeleft = updateInterval;
				accum = 0f;
				frames = 0;
				texto.text = frameString;
			}
		}

		private void UpdateNuevo()
		{
			float num = 0f;
			num = (float)Time.frameCount / Time.time;
			avgFrameRate = (int)num;
			texto.text = avgFrameRate + " FPS";
		}
	}
}
namespace Performance
{
	public class FpsToText : MonoBehaviour
	{
		[Header("// Sample Groups of Data ")]
		public bool GroupSampling = true;

		public int SampleSize = 20;

		[Header("// Config ")]
		public TextMesh TargetText;

		public int UpdateTextEvery = 1;

		public int MaxTextLength = 5;

		public bool Smoothed = true;

		public bool ForceIntResult = true;

		public bool ZeroAllocOnly;

		[Header("// System FPS (updates once/sec)")]
		public bool UseSystemTick;

		[Header("// Color Config ")]
		public bool UseColors = true;

		public Color Good = Color.green;

		public Color Okay = Color.yellow;

		public Color Bad = Color.red;

		public int OkayBelow = 60;

		public int BadBelow = 30;

		protected float[] FpsSamples;

		protected int SampleIndex;

		protected int TextUpdateIndex;

		private float _fps;

		private int _sysLastSysTick;

		private int _sysLastFrameRate;

		private int _sysFrameRate;

		private string _localfps;

		private static readonly string[] FpsStringMap = new string[300]
		{
			"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
			"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
			"20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
			"30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
			"40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
			"50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
			"60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
			"70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
			"80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
			"90", "91", "92", "93", "94", "95", "96", "97", "98", "99",
			"100", "101", "102", "103", "104", "105", "106", "107", "108", "109",
			"110", "111", "122", "113", "114", "115", "116", "117", "118", "119",
			"120", "121", "132", "123", "124", "125", "126", "127", "128", "129",
			"130", "131", "142", "133", "134", "135", "136", "137", "138", "139",
			"140", "141", "152", "143", "144", "145", "146", "147", "148", "149",
			"150", "151", "162", "153", "154", "155", "156", "157", "158", "159",
			"160", "161", "172", "163", "164", "165", "166", "167", "168", "169",
			"170", "171", "182", "173", "174", "175", "176", "177", "178", "179",
			"180", "181", "192", "183", "184", "185", "186", "187", "188", "189",
			"190", "191", "192", "193", "194", "195", "196", "197", "198", "199",
			"200", "201", "202", "203", "204", "205", "206", "207", "208", "209",
			"210", "211", "222", "213", "214", "215", "216", "217", "218", "219",
			"220", "221", "222", "223", "224", "225", "226", "227", "228", "229",
			"230", "231", "232", "233", "234", "235", "236", "237", "238", "239",
			"240", "241", "242", "243", "244", "245", "246", "247", "248", "249",
			"250", "251", "252", "253", "254", "255", "256", "257", "258", "259",
			"260", "261", "262", "263", "264", "265", "266", "267", "268", "269",
			"270", "271", "272", "273", "274", "275", "276", "277", "278", "279",
			"280", "281", "282", "283", "284", "285", "286", "287", "288", "289",
			"290", "291", "292", "293", "294", "295", "296", "297", "298", "299+"
		};

		public float Framerate => _fps;

		protected virtual void Reset()
		{
			SampleSize = 20;
			UpdateTextEvery = 1;
			MaxTextLength = 5;
			Smoothed = true;
			UseColors = true;
			Good = Color.green;
			Okay = Color.yellow;
			Bad = Color.red;
			OkayBelow = 60;
			BadBelow = 30;
			UseSystemTick = false;
			ForceIntResult = true;
		}

		protected virtual void Start()
		{
			if (!Debugs.contadorFPS)
			{
				UnityEngine.Object.Destroy(base.transform.gameObject);
				return;
			}
			FpsSamples = new float[SampleSize];
			for (int i = 0; i < FpsSamples.Length; i++)
			{
				FpsSamples[i] = 0.001f;
			}
			if (!TargetText)
			{
				base.enabled = false;
			}
		}

		protected virtual void Update()
		{
			if (!Debugs.contadorFPS)
			{
				return;
			}
			if (GroupSampling)
			{
				Group();
			}
			else
			{
				SingleFrame();
			}
			_localfps = (ZeroAllocOnly ? FpsStringMap[Mathf.Clamp((int)_fps, 0, 299)] : _fps.ToString(CultureInfo.CurrentCulture));
			SampleIndex = ((SampleIndex < SampleSize - 1) ? (SampleIndex + 1) : 0);
			TextUpdateIndex = ((TextUpdateIndex <= UpdateTextEvery) ? (TextUpdateIndex + 1) : 0);
			if (TextUpdateIndex == UpdateTextEvery)
			{
				TargetText.text = _localfps.Substring(0, (_localfps.Length < 5) ? _localfps.Length : 5);
			}
			if (UseColors)
			{
				if (_fps < (float)BadBelow)
				{
					TargetText.color = Bad;
					return;
				}
				TargetText.color = ((_fps < (float)OkayBelow) ? Okay : Good);
				TargetText.text += GameManager.instance.logFPS;
			}
		}

		protected virtual void SingleFrame()
		{
			_fps = (UseSystemTick ? ((float)GetSystemFramerate()) : (Smoothed ? (1f / Time.smoothDeltaTime) : (1f / Time.deltaTime)));
			if (ForceIntResult)
			{
				_fps = (int)_fps;
			}
		}

		protected virtual void Group()
		{
			FpsSamples[SampleIndex] = (UseSystemTick ? ((float)GetSystemFramerate()) : (Smoothed ? (1f / Time.smoothDeltaTime) : (1f / Time.deltaTime)));
			_fps = 0f;
			bool flag = true;
			int num = 0;
			while (flag)
			{
				if (num == SampleSize - 1)
				{
					flag = false;
				}
				_fps += FpsSamples[num];
				num++;
			}
			_fps /= FpsSamples.Length;
			if (ForceIntResult)
			{
				_fps = (int)_fps;
			}
		}

		protected virtual int GetSystemFramerate()
		{
			if (Environment.TickCount - _sysLastSysTick >= 1000)
			{
				_sysLastFrameRate = _sysFrameRate;
				_sysFrameRate = 0;
				_sysLastSysTick = Environment.TickCount;
			}
			_sysFrameRate++;
			return _sysLastFrameRate;
		}
	}
}
namespace MK.Glow
{
	internal abstract class CameraData
	{
		internal int width;

		internal int height;

		internal bool stereoEnabled;

		internal float aspect;

		internal Matrix4x4 worldToCameraMatrix;
	}
	public enum Workflow
	{
		Threshold,
		Selective,
		Natural
	}
	public enum Quality
	{
		Ultra = 1,
		High = 2,
		Medium = 4,
		Low = 8,
		VeryLow = 12
	}
	public enum DebugView
	{
		None,
		RawBloom,
		RawLensFlare,
		RawGlare,
		Bloom,
		LensFlare,
		Glare,
		Composite
	}
	public enum RenderPriority
	{
		Quality,
		Balanced,
		Performance
	}
	public enum LensFlareStyle
	{
		Custom,
		Average,
		MultiAverage,
		Old,
		OldFocused,
		Distorted
	}
	public enum GlareStyle
	{
		Custom,
		Line,
		Tri,
		Cross,
		DistortedCross,
		Star,
		Flake
	}
	internal struct RenderDimension : IDimension
	{
		public int width { get; set; }

		public int height { get; set; }

		public RenderDimension renderDimension => this;

		public RenderDimension(int width, int height)
		{
			this = default(RenderDimension);
			this.width = width;
			this.height = height;
		}
	}
	internal enum RenderPipeline
	{
		Legacy,
		SRP
	}
	public static class Compatibility
	{
		private static readonly bool _defaultHDRFormatSupported = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.DefaultHDR);

		private static readonly bool _11R11G10BFormatSupported = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float);

		private static readonly bool _2A10R10G10BFormatSupported = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGB2101010);

		public static readonly bool IsSupported = _11R11G10BFormatSupported || _2A10R10G10BFormatSupported || (_defaultHDRFormatSupported ? true : false);

		public static bool CheckGeometryShaderSupport()
		{
			bool flag = false;
			switch (SystemInfo.graphicsDeviceType)
			{
			case GraphicsDeviceType.Direct3D11:
			case GraphicsDeviceType.PlayStation4:
			case GraphicsDeviceType.XboxOne:
			case GraphicsDeviceType.OpenGLCore:
			case GraphicsDeviceType.Direct3D12:
			case GraphicsDeviceType.Vulkan:
			case GraphicsDeviceType.XboxOneD3D12:
				flag = true;
				break;
			default:
				flag = false;
				break;
			}
			RuntimePlatform platform = UnityEngine.Application.platform;
			if ((uint)platform <= 1u || platform == RuntimePlatform.IPhonePlayer || platform == RuntimePlatform.tvOS)
			{
				flag = false;
			}
			return SystemInfo.graphicsShaderLevel >= 40 && flag;
		}

		public static bool CheckComputeShaderSupport()
		{
			bool flag = false;
			switch (SystemInfo.graphicsDeviceType)
			{
			case GraphicsDeviceType.Direct3D11:
			case GraphicsDeviceType.PlayStation4:
			case GraphicsDeviceType.XboxOne:
			case GraphicsDeviceType.OpenGLCore:
			case GraphicsDeviceType.Direct3D12:
			case GraphicsDeviceType.Vulkan:
			case GraphicsDeviceType.Switch:
			case GraphicsDeviceType.XboxOneD3D12:
				flag = true;
				break;
			default:
				flag = false;
				break;
			}
			return SystemInfo.supportsComputeShaders && flag;
		}

		public static bool CheckLensFlareFeatureSupport()
		{
			bool flag;
			switch (SystemInfo.graphicsDeviceType)
			{
			case GraphicsDeviceType.Direct3D11:
			case GraphicsDeviceType.OpenGLES3:
			case GraphicsDeviceType.PlayStation4:
			case GraphicsDeviceType.XboxOne:
			case GraphicsDeviceType.Metal:
			case GraphicsDeviceType.OpenGLCore:
			case GraphicsDeviceType.Direct3D12:
			case GraphicsDeviceType.Vulkan:
			case GraphicsDeviceType.Switch:
			case GraphicsDeviceType.XboxOneD3D12:
				flag = true;
				break;
			default:
				flag = false;
				break;
			}
			if (SystemInfo.graphicsShaderLevel >= 30 && SystemInfo.supportedRenderTargetCount >= 2 && flag)
			{
				return !PipelineProperties.singlePassStereoInstancedEnabled;
			}
			return false;
		}

		public static bool CheckGlareFeatureSupport()
		{
			bool flag;
			switch (SystemInfo.graphicsDeviceType)
			{
			case GraphicsDeviceType.Direct3D11:
			case GraphicsDeviceType.PlayStation4:
			case GraphicsDeviceType.XboxOne:
			case GraphicsDeviceType.Metal:
			case GraphicsDeviceType.OpenGLCore:
			case GraphicsDeviceType.Direct3D12:
			case GraphicsDeviceType.Vulkan:
			case GraphicsDeviceType.Switch:
			case GraphicsDeviceType.XboxOneD3D12:
				flag = true;
				break;
			default:
				flag = false;
				break;
			}
			if (SystemInfo.graphicsShaderLevel >= 40 && SystemInfo.supportedRenderTargetCount >= 6 && flag)
			{
				return !PipelineProperties.singlePassStereoInstancedEnabled;
			}
			return false;
		}

		internal static RenderTextureFormat CheckSupportedRenderTextureFormat()
		{
			if (!_11R11G10BFormatSupported)
			{
				if (!_2A10R10G10BFormatSupported)
				{
					if (!_defaultHDRFormatSupported)
					{
						return RenderTextureFormat.Default;
					}
					return RenderTextureFormat.DefaultHDR;
				}
				return RenderTextureFormat.ARGB2101010;
			}
			return RenderTextureFormat.RGB111110Float;
		}
	}
	internal sealed class ComputeShaderVariants
	{
		internal static class KeywordValues
		{
			internal const int BLOOM = 1;

			internal const int LENS_SURFACE = 1;

			internal const int LENS_FLARE = 1;

			internal const int GLARE = 4;

			internal const int MK_NATURAL = 1;

			internal const int RENDER_PRIORITY = 2;
		}

		internal struct KeywordState
		{
			public int bloom;

			public int lensSurface;

			public int lensFlare;

			public int glare;

			public int natural;

			public int renderPriority;

			public KeywordState(int bloom, int lensSurface, int lensFlare, int glare, int natural, int renderPriority)
			{
				this.bloom = bloom;
				this.lensSurface = lensSurface;
				this.lensFlare = lensFlare;
				this.glare = glare;
				this.natural = natural;
				this.renderPriority = renderPriority;
			}
		}

		private Dictionary<KeywordState, int> variants = new Dictionary<KeywordState, int>();

		internal void GetVariantNumber(KeywordState features, out int index)
		{
			variants.TryGetValue(features, out index);
		}

		public ComputeShaderVariants(int offset)
		{
			int num = 0;
			for (int i = 0; i <= 2; i++)
			{
				for (int j = 0; j <= 1; j++)
				{
					for (int k = 0; k <= 4; k++)
					{
						for (int l = 0; l <= 1; l++)
						{
							for (int m = 0; m <= 1; m++)
							{
								for (int n = 0; n <= 1; n++)
								{
									variants.Add(new KeywordState(n, m, l, k, j, i), num + offset);
									num++;
								}
							}
						}
					}
				}
			}
		}
	}
	internal sealed class Effect
	{
		internal enum ShaderRenderPass
		{
			Copy,
			Presample,
			Downsample,
			Upsample,
			Composite,
			Debug
		}

		internal enum MaterialKeywords
		{
			Bloom,
			LensSurface,
			LensFlare,
			Glare1,
			DebugRawBloom,
			DebugRawLensFlare,
			DebugRawGlare,
			DebugBloom,
			DebugLensFlare,
			DebugGlare,
			DebugComposite,
			LegacyBlit,
			RenderPriorityQuality,
			Natural,
			Glare2,
			Glare3,
			Glare4,
			Null,
			RenderPriorityBalanced
		}

		internal struct Keyword
		{
			internal string name;

			internal bool enabled;

			internal Keyword(string name, bool enabled)
			{
				this.name = name;
				this.enabled = enabled;
			}
		}

		private static Resources _resources;

		private static readonly Vector2 _referenceResolution = new Vector2(3840f, 2160f);

		private static readonly float _referenceAspectRatio = 0.5625f;

		private static readonly Vector2 _selectiveWorkflowThreshold = new Vector2(0.1f, 10f);

		private static readonly int _cArgBufferSize = 66;

		private static readonly int _glareIterationsBase = 3;

		private static readonly RenderDimension _directComputeSize = new RenderDimension(8, 7);

		private static readonly float naturalIntensityMult = 0.1f;

		private static readonly string _selectiveReplacementTag = "RenderType";

		private static readonly string _selectiveGlowCameraObjectName = "selectiveGlowCameraObject";

		private GameObject _selectiveGlowCameraObject;

		private Camera _selectiveGlowCamera;

		private ComputeShaderVariants _presampleComputeVariants = new ComputeShaderVariants(0);

		private ComputeShaderVariants _downsampleComputeVariants = new ComputeShaderVariants(240);

		private ComputeShaderVariants _upsampleComputeVariants = new ComputeShaderVariants(480);

		private CommandBuffer _commandBuffer;

		private RenderTarget _selectiveRenderTarget;

		private MipBuffer _bloomDownsampleBuffer;

		private MipBuffer _bloomUpsampleBuffer;

		private MipBuffer _lensFlareDownsampleBuffer;

		private MipBuffer _lensFlareUpsampleBuffer;

		private MipBuffer _glareDownsampleBuffer0;

		private MipBuffer _glareDownsampleBuffer1;

		private MipBuffer _glareDownsampleBuffer2;

		private MipBuffer _glareDownsampleBuffer3;

		private MipBuffer _glareUpsampleBuffer0;

		private MipBuffer _glareUpsampleBuffer1;

		private MipBuffer _glareUpsampleBuffer2;

		private MipBuffer _glareUpsampleBuffer3;

		private RenderTarget _sourceFrameBuffer;

		private RenderTarget _destinationFrameBuffer;

		private Keyword[] _shaderKeywords = new Keyword[19]
		{
			new Keyword("_NORMALMAP", enabled: false),
			new Keyword("_ALPHATEST_ON", enabled: false),
			new Keyword("_ALPHABLEND_ON", enabled: false),
			new Keyword("_ALPHAPREMULTIPLY_ON", enabled: false),
			new Keyword("_EMISSION", enabled: false),
			new Keyword("_METALLICGLOSSMAP", enabled: false),
			new Keyword("_DETAIL_MULX2", enabled: false),
			new Keyword("_SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A", enabled: false),
			new Keyword("_SPECULARHIGHLIGHTS_OFF", enabled: false),
			new Keyword("_GLOSSYREFLECTIONS_OFF", enabled: false),
			new Keyword("EDITOR_VISUALIZATION", enabled: false),
			new Keyword("_COLOROVERLAY_ON", enabled: false),
			new Keyword("_COLORCOLOR_ON", enabled: false),
			new Keyword("UNDERLAY_ON", enabled: false),
			new Keyword("BILLBOARD_FACE_CAMERA_POS", enabled: false),
			new Keyword("LOD_FADE_CROSSFADE", enabled: false),
			new Keyword("_SUNDISK_NONE", enabled: false),
			new Keyword("", enabled: false),
			new Keyword("OUTLINE_ON", enabled: false)
		};

		private bool _useGeometryShaders;

		private bool _useComputeShaders;

		private bool _useLensSurface;

		private bool _useLensFlare;

		private bool _useGlare;

		private List<RenderTarget> _renderTargetsBundle;

		private List<MaterialKeywords> _renderKeywordsBundle;

		private int _bloomIterations;

		private int _lensFlareIterations;

		private int _minIterations;

		private int _glareIterations;

		private int _currentRenderIndex;

		private float bloomUpsampleSpread;

		private float _lensFlareUpsampleSpread;

		private float _glareScatteringMult;

		private Vector2 _resolutionScale;

		private Vector2[] glareAngles = new Vector2[4];

		private RenderTextureFormat _renderTextureFormat;

		private ComputeShaderVariants.KeywordState computeShaderFeatures = new ComputeShaderVariants.KeywordState(0, 0, 0, 0, 0, 0);

		private RenderContext[] _sourceContext;

		private RenderContext[] _renderContext;

		private RenderContext _selectiveRenderContext;

		private Camera _renderingCamera;

		private CameraData _cameraData;

		private RenderPipeline _renderPipeline;

		private Material _renderMaterialNoGeometry;

		private Material _renderMaterialGeometry;

		private float[] _cArgArray = new float[_cArgBufferSize];

		private ComputeBuffer _cArgsComputeBuffer;

		private RenderDimension _computeThreadGroups;

		private Settings _settings;

		private RenderTarget sourceFrameBuffer
		{
			get
			{
				if (_settings.workflow != Workflow.Selective || _settings.debugView == DebugView.None)
				{
					return _sourceFrameBuffer;
				}
				return _selectiveRenderTarget;
			}
		}

		internal int currentRenderIndex => _currentRenderIndex;

		internal RenderTextureFormat renderTextureFormat => _renderTextureFormat;

		internal Material renderMaterialNoGeometry => _renderMaterialNoGeometry;

		private GameObject selectiveGlowCameraObject
		{
			get
			{
				if (!_selectiveGlowCameraObject)
				{
					_selectiveGlowCameraObject = new GameObject(_selectiveGlowCameraObjectName);
					_selectiveGlowCameraObject.AddComponent<Camera>();
					_selectiveGlowCameraObject.hideFlags = HideFlags.HideAndDontSave;
				}
				return _selectiveGlowCameraObject;
			}
		}

		private Camera selectiveGlowCamera
		{
			get
			{
				if (_selectiveGlowCamera == null)
				{
					_selectiveGlowCamera = selectiveGlowCameraObject.GetComponent<Camera>();
					_selectiveGlowCamera.hideFlags = HideFlags.HideAndDontSave;
					_selectiveGlowCamera.enabled = false;
				}
				return _selectiveGlowCamera;
			}
		}

		internal Effect()
		{
		}

		internal void Enable(RenderPipeline renderPipeline, Shader shaderOverwrite = null, Shader shaderGeometryOverwrite = null)
		{
			_resources = Resources.LoadResourcesAsset();
			_renderTextureFormat = Compatibility.CheckSupportedRenderTextureFormat();
			_renderPipeline = renderPipeline;
			_sourceContext = new RenderContext[1]
			{
				new RenderContext()
			};
			_renderContext = new RenderContext[PipelineProperties.renderBufferSize];
			for (int i = 0; i < PipelineProperties.renderBufferSize; i++)
			{
				_renderContext[i] = new RenderContext();
			}
			_selectiveRenderContext = new RenderContext();
			if (shaderOverwrite == null)
			{
				_renderMaterialNoGeometry = new Material(_resources.sm40Shader)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}
			else
			{
				_renderMaterialNoGeometry = new Material(shaderOverwrite)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}
			if (shaderGeometryOverwrite == null)
			{
				_renderMaterialGeometry = new Material(Compatibility.CheckGeometryShaderSupport() ? _resources.sm40GeometryShader : _resources.sm40Shader)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}
			else
			{
				_renderMaterialGeometry = new Material(Compatibility.CheckGeometryShaderSupport() ? shaderGeometryOverwrite : shaderOverwrite)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}
			_renderTargetsBundle = new List<RenderTarget>();
			_renderKeywordsBundle = new List<MaterialKeywords>();
			_cArgsComputeBuffer = new ComputeBuffer(_cArgBufferSize, 4, ComputeBufferType.Default);
			_bloomDownsampleBuffer = new MipBuffer(PipelineProperties.CommandBufferProperties.bloomDownsampleBuffer, _renderPipeline);
			_bloomUpsampleBuffer = new MipBuffer(PipelineProperties.CommandBufferProperties.bloomUpsampleBuffer, _renderPipeline);
			_lensFlareDownsampleBuffer = new MipBuffer(PipelineProperties.CommandBufferProperties.lensFlareDownsampleBuffer, _renderPipeline);
			_lensFlareUpsampleBuffer = new MipBuffer(PipelineProperties.CommandBufferProperties.lensFlareUpsampleBuffer, _renderPipeline);
			_glareDownsampleBuffer0 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareDownsampleBuffer0, _renderPipeline);
			_glareDownsampleBuffer1 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareDownsampleBuffer1, _renderPipeline);
			_glareDownsampleBuffer2 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareDownsampleBuffer2, _renderPipeline);
			_glareDownsampleBuffer3 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareDownsampleBuffer3, _renderPipeline);
			_glareUpsampleBuffer0 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareUpsampleBuffer0, _renderPipeline);
			_glareUpsampleBuffer1 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareUpsampleBuffer1, _renderPipeline);
			_glareUpsampleBuffer2 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareUpsampleBuffer2, _renderPipeline);
			_glareUpsampleBuffer3 = new MipBuffer(PipelineProperties.CommandBufferProperties.glareUpsampleBuffer3, _renderPipeline);
		}

		internal void Disable()
		{
			_cArgsComputeBuffer.Release();
			_currentRenderIndex = 0;
			_renderTargetsBundle.Clear();
			_renderKeywordsBundle.Clear();
			UnityEngine.Object.DestroyImmediate(_selectiveGlowCamera);
			UnityEngine.Object.DestroyImmediate(_selectiveGlowCameraObject);
			UnityEngine.Object.DestroyImmediate(_renderMaterialNoGeometry);
			UnityEngine.Object.DestroyImmediate(_renderMaterialGeometry);
		}

		private void PrepareScattering(float Scattering, float scale, ref int iterations, ref float spread)
		{
			float num = scale + Mathf.Clamp(Scattering, 1f, 10f) - 10f;
			iterations = Mathf.Max(Mathf.FloorToInt(num), 1);
			spread = ((num > 1f) ? (0.5f + num - (float)iterations) : 0.5f);
		}

		private void UpdateRenderBuffers()
		{
			RenderDimension renderDimension = new RenderDimension(_cameraData.width, _cameraData.height);
			_sourceContext[0].UpdateRenderContext(_cameraData.stereoEnabled, _renderTextureFormat, 0, _useComputeShaders, renderDimension);
			_sourceContext[0].SinglePassStereoAdjustWidth(_cameraData.stereoEnabled);
			renderDimension = new RenderDimension(Mathf.CeilToInt((float)_sourceContext[0].width * ((_settings.anamorphicRatio > 0f) ? (1f - _settings.anamorphicRatio * 0.5f) : 1f)), Mathf.CeilToInt((float)_sourceContext[0].height * ((_settings.anamorphicRatio < 0f) ? (1f + _settings.anamorphicRatio * 0.5f) : 1f)));
			renderDimension.width /= (int)_settings.quality;
			renderDimension.height /= (int)_settings.quality;
			float scale = Mathf.Log(Mathf.FloorToInt(Mathf.Max(renderDimension.width, renderDimension.height)), 2f);
			PrepareScattering(_settings.bloomScattering, scale, ref _bloomIterations, ref bloomUpsampleSpread);
			_minIterations = _bloomIterations;
			if (_useLensFlare)
			{
				PrepareScattering(_settings.lensFlareScattering, scale, ref _lensFlareIterations, ref _lensFlareUpsampleSpread);
				if (_lensFlareIterations > _minIterations)
				{
					_minIterations = _lensFlareIterations;
				}
			}
			if (_useGlare)
			{
				Quality quality = _settings.quality;
				if (quality == Quality.High || quality == Quality.Medium || quality == Quality.Low)
				{
					_glareIterations = _glareIterationsBase;
					_glareScatteringMult = 1f;
				}
				else
				{
					_glareIterations = _glareIterationsBase;
					_glareScatteringMult = 1f;
				}
				if (_glareIterations > _minIterations)
				{
					_minIterations = _glareIterations;
				}
			}
			_cameraData.UpdateMipRenderContext(_renderContext, renderDimension, _minIterations + 1, _renderTextureFormat, 0, _useComputeShaders);
		}

		private void SetupSelectiveGlowCamera()
		{
			selectiveGlowCamera.CopyFrom(_renderingCamera);
			selectiveGlowCamera.targetTexture = _selectiveRenderTarget.renderTexture;
			selectiveGlowCamera.clearFlags = CameraClearFlags.Color;
			selectiveGlowCamera.rect = new Rect(0f, 0f, 1f, 1f);
			selectiveGlowCamera.backgroundColor = new Color(0f, 0f, 0f, 1f);
			selectiveGlowCamera.cullingMask = _settings.selectiveRenderLayerMask;
			selectiveGlowCamera.renderingPath = RenderingPath.VertexLit;
		}

		private void CheckFeatureSupport()
		{
			if (_settings.allowLensSurface)
			{
				_useLensSurface = true;
			}
			else
			{
				_useLensSurface = false;
			}
			if (_settings.allowLensFlare && Compatibility.CheckLensFlareFeatureSupport() && _settings.quality <= Quality.Medium)
			{
				_useLensFlare = true;
			}
			else
			{
				_useLensFlare = false;
			}
			if (_settings.allowGlare && Compatibility.CheckGlareFeatureSupport() && _settings.quality <= Quality.Medium)
			{
				_useGlare = true;
			}
			else
			{
				_useGlare = false;
			}
			if (_settings.allowGeometryShaders && Compatibility.CheckGeometryShaderSupport())
			{
				_useGeometryShaders = true;
			}
			else
			{
				_useGeometryShaders = false;
			}
			if (_settings.allowComputeShaders && Compatibility.CheckComputeShaderSupport() && !_cameraData.stereoEnabled)
			{
				_useComputeShaders = true;
			}
			else
			{
				_useComputeShaders = false;
			}
			if (_settings.debugView != 0 && ((!_useLensFlare && (_settings.debugView == DebugView.LensFlare || _settings.debugView == DebugView.RawLensFlare)) || (!_useGlare && (_settings.debugView == DebugView.Glare || _settings.debugView == DebugView.RawGlare))))
			{
				_settings.debugView = DebugView.None;
			}
			_useComputeShaders = false;
		}

		private void BeginProfileSample(string text)
		{
			if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.BeginSample(text);
			}
		}

		private void EndProfileSample(string text)
		{
			if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.EndSample(text);
			}
		}

		internal void Build(RenderTarget source, RenderTarget destination, Settings settings, CommandBuffer cmd, CameraData cameraData, Camera renderingCamera = null)
		{
			_commandBuffer = cmd;
			_settings = settings;
			_renderingCamera = renderingCamera;
			_cameraData = cameraData;
			BeginProfileSample(PipelineProperties.CommandBufferProperties.samplePrepare);
			CheckFeatureSupport();
			_sourceFrameBuffer = source;
			_destinationFrameBuffer = destination;
			UpdateRenderBuffers();
			EndProfileSample(PipelineProperties.CommandBufferProperties.samplePrepare);
			if (_settings.workflow == Workflow.Selective)
			{
				BeginProfileSample(PipelineProperties.CommandBufferProperties.sampleReplacement);
				_selectiveRenderContext.UpdateRenderContext(_cameraData.stereoEnabled, _renderTextureFormat, 16, enableRandomWrite: false, _sourceContext[0].renderDimension);
				_selectiveRenderTarget.renderTexture = RenderTexture.GetTemporary(_cameraData.width / (int)_settings.quality, _cameraData.height / (int)_settings.quality, 16, _renderTextureFormat, RenderTextureReadWrite.Default, 1);
				SetupSelectiveGlowCamera();
				selectiveGlowCamera.RenderWithShader(_resources.selectiveRenderShader, _selectiveReplacementTag);
				EndProfileSample(PipelineProperties.CommandBufferProperties.sampleReplacement);
			}
			BeginProfileSample(PipelineProperties.CommandBufferProperties.sampleSetup);
			_resolutionScale = new Vector2((float)_renderContext[0].width / _referenceResolution.x * (float)_renderContext[0].height / (float)_renderContext[0].width / _referenceAspectRatio, (float)_renderContext[0].height / _referenceResolution.y);
			UpdateConstantBuffers();
			EndProfileSample(PipelineProperties.CommandBufferProperties.sampleSetup);
			PreSample();
			Downsample();
			Upsample();
			Composite();
		}

		private void UpdateConstantBuffers()
		{
			SetVector(PipelineProperties.ShaderProperties.screenSize, new Vector2(_cameraData.width, _cameraData.height), forcePixelShader: true);
			SetFloat(PipelineProperties.ShaderProperties.singlePassStereoScale, (!PipelineProperties.singlePassStereoDoubleWideEnabled) ? 1 : 2);
			SetFloat(PipelineProperties.ShaderProperties.lumaScale, _settings.lumaScale);
			SetFloat(PipelineProperties.ShaderProperties.blooming, _settings.blooming, forcePixelShader: true);
			SetVector(PipelineProperties.ShaderProperties.resolutionScale, _resolutionScale);
			SetVector(PipelineProperties.ShaderProperties.resolutionScale, _resolutionScale, forcePixelShader: true);
			Matrix4x4 worldToCameraMatrix = _cameraData.worldToCameraMatrix;
			if (_useComputeShaders)
			{
				SetVector(PipelineProperties.ShaderProperties.viewMatrix, worldToCameraMatrix.GetRow(0), forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.viewMatrix, worldToCameraMatrix.GetRow(1), forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.viewMatrix, worldToCameraMatrix.GetRow(2), forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.viewMatrix, worldToCameraMatrix.GetRow(3), forcePixelShader: true);
			}
			else
			{
				Shader.SetGlobalMatrix(PipelineProperties.ShaderProperties.viewMatrix.id, worldToCameraMatrix);
			}
			SetFloat(PipelineProperties.ShaderProperties.bloomIntensity, ConvertGammaValue(_settings.bloomIntensity * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f)), forcePixelShader: true);
			SetFloat(PipelineProperties.ShaderProperties.bloomSpread, bloomUpsampleSpread);
			SetFloat(PipelineProperties.ShaderProperties.bloomSpread, bloomUpsampleSpread, forcePixelShader: true);
			SetVector(PipelineProperties.ShaderProperties.bloomThreshold, (_settings.workflow == Workflow.Selective) ? _selectiveWorkflowThreshold : new Vector2(ConvertGammaValue(_settings.bloomThreshold.minValue), ConvertGammaValue(_settings.bloomThreshold.maxValue)), _settings.debugView == DebugView.RawBloom);
			if (_useLensSurface)
			{
				SetFloat(PipelineProperties.ShaderProperties.lensSurfaceDirtIntensity, ConvertGammaValue(_settings.lensSurfaceDirtIntensity * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f)), forcePixelShader: true);
				SetFloat(PipelineProperties.ShaderProperties.lensSurfaceDiffractionIntensity, ConvertGammaValue(_settings.lensSurfaceDiffractionIntensity * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f)), forcePixelShader: true);
				float num = (float)(_settings.lensSurfaceDirtTexture ? _settings.lensSurfaceDirtTexture.width : _resources.lensSurfaceDirtTextureDefault.width) / (float)(_settings.lensSurfaceDirtTexture ? _settings.lensSurfaceDirtTexture.height : _resources.lensSurfaceDirtTextureDefault.height);
				float num2 = _cameraData.aspect / num;
				float num3 = num / _cameraData.aspect;
				SetVector(PipelineProperties.ShaderProperties.lensSurfaceDirtTexST, (num > _cameraData.aspect) ? new Vector4(num2, 1f, (1f - num2) * 0.5f, 0f) : new Vector4(1f, num3, 0f, (1f - num3) * 0.5f), forcePixelShader: true);
			}
			if (_useLensFlare)
			{
				SetVector(PipelineProperties.ShaderProperties.lensFlareThreshold, (_settings.workflow == Workflow.Selective) ? _selectiveWorkflowThreshold : new Vector2(ConvertGammaValue(_settings.lensFlareThreshold.minValue), ConvertGammaValue(_settings.lensFlareThreshold.maxValue)), _settings.debugView == DebugView.RawLensFlare);
				SetVector(PipelineProperties.ShaderProperties.lensFlareGhostParams, new Vector4(_settings.lensFlareGhostCount, _settings.lensFlareGhostDispersal, _settings.lensFlareGhostFade, ConvertGammaValue(_settings.lensFlareGhostIntensity * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f))));
				SetVector(PipelineProperties.ShaderProperties.lensFlareHaloParams, new Vector3(_settings.lensFlareHaloSize, _settings.lensFlareHaloFade, ConvertGammaValue(_settings.lensFlareHaloIntensity * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f))));
				SetFloat(PipelineProperties.ShaderProperties.lensFlareSpread, _lensFlareUpsampleSpread);
				SetFloat(PipelineProperties.ShaderProperties.lensFlareChromaticAberration, _settings.lensFlareChromaticAberration, forcePixelShader: true);
			}
			if (_useGlare)
			{
				SetVector(PipelineProperties.ShaderProperties.glareThreshold, (_settings.workflow == Workflow.Selective) ? _selectiveWorkflowThreshold : new Vector2(ConvertGammaValue(_settings.glareThreshold.minValue), ConvertGammaValue(_settings.glareThreshold.maxValue)), _settings.debugView == DebugView.RawGlare);
				SetFloat(PipelineProperties.ShaderProperties.glareBlend, _settings.glareBlend, forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.glareIntensity, ConvertGammaValue(new Vector4(_settings.glareSample0Intensity, _settings.glareSample1Intensity, _settings.glareSample2Intensity, _settings.glareSample3Intensity)), forcePixelShader: true);
				Vector4 value = new Vector4(_settings.glareSample0Scattering * _glareScatteringMult * _settings.glareScattering, _settings.glareSample1Scattering * _glareScatteringMult * _settings.glareScattering, _settings.glareSample2Scattering * _glareScatteringMult * _settings.glareScattering, _settings.glareSample3Scattering * _glareScatteringMult * _settings.glareScattering);
				glareAngles[0] = AngleToDirection(_settings.glareSample0Angle + _settings.glareAngle);
				glareAngles[1] = AngleToDirection(_settings.glareSample1Angle + _settings.glareAngle);
				glareAngles[2] = AngleToDirection(_settings.glareSample2Angle + _settings.glareAngle);
				glareAngles[3] = AngleToDirection(_settings.glareSample3Angle + _settings.glareAngle);
				Vector4 value2 = new Vector4(glareAngles[0].x, glareAngles[0].y, glareAngles[1].x, glareAngles[1].y);
				Vector4 value3 = new Vector4(glareAngles[2].x, glareAngles[2].y, glareAngles[3].x, glareAngles[3].y);
				Vector4 value4 = new Vector4(_settings.glareSample0Offset, _settings.glareSample1Offset, _settings.glareSample2Offset, _settings.glareSample3Offset);
				SetVector(PipelineProperties.ShaderProperties.glareScattering, value);
				SetVector(PipelineProperties.ShaderProperties.glareDirection01, value2);
				SetVector(PipelineProperties.ShaderProperties.glareDirection23, value3);
				SetVector(PipelineProperties.ShaderProperties.glareOffset, value4);
				SetVector(PipelineProperties.ShaderProperties.glareScattering, value, forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.glareDirection01, value2, forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.glareDirection23, value3, forcePixelShader: true);
				SetVector(PipelineProperties.ShaderProperties.glareOffset, value4, forcePixelShader: true);
				SetFloat(PipelineProperties.ShaderProperties.glareGlobalIntensity, ConvertGammaValue(_settings.glareIntensity) * ((_settings.workflow == Workflow.Natural) ? naturalIntensityMult : 1f), forcePixelShader: true);
			}
			if (_useComputeShaders)
			{
				_cArgsComputeBuffer.SetData(_cArgArray);
			}
		}

		private void SetKeyword(MaterialKeywords keyword, bool enable)
		{
			if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetKeyword(_shaderKeywords[(int)keyword].name, enable);
			}
			else
			{
				PipelineExtensions.SetKeyword(_shaderKeywords[(int)keyword].name, enable);
			}
			_shaderKeywords[(int)keyword].enabled = enable;
		}

		private Vector2 AngleToDirection(float angleDegree)
		{
			return new Vector2(Mathf.Sin(angleDegree * ((float)Math.PI / 180f)), Mathf.Cos(angleDegree * ((float)Math.PI / 180f)));
		}

		private float ConvertGammaValue(float gammaSpacedValue)
		{
			if (QualitySettings.activeColorSpace == ColorSpace.Linear)
			{
				return Mathf.GammaToLinearSpace(gammaSpacedValue);
			}
			return gammaSpacedValue;
		}

		private Vector4 ConvertGammaValue(Vector4 gammaSpacedVector)
		{
			if (QualitySettings.activeColorSpace == ColorSpace.Linear)
			{
				gammaSpacedVector.x = ConvertGammaValue(gammaSpacedVector.x);
				gammaSpacedVector.y = ConvertGammaValue(gammaSpacedVector.y);
				gammaSpacedVector.z = ConvertGammaValue(gammaSpacedVector.z);
				gammaSpacedVector.w = ConvertGammaValue(gammaSpacedVector.w);
				return gammaSpacedVector;
			}
			return gammaSpacedVector;
		}

		private void UpdateComputeShaderThreadGroups(RenderDimension renderDimension)
		{
			_computeThreadGroups.width = Mathf.Max(1, Mathf.FloorToInt((renderDimension.width + _directComputeSize.height) / _directComputeSize.width));
			_computeThreadGroups.height = Mathf.Max(1, Mathf.FloorToInt((renderDimension.height + _directComputeSize.height) / _directComputeSize.width));
		}

		private void UpdateRenderIndex(int v)
		{
			_currentRenderIndex = v;
		}

		private void UpdateRenderIndex(ComputeShaderVariants variants, ComputeShaderVariants.KeywordState features)
		{
			variants.GetVariantNumber(features, out _currentRenderIndex);
		}

		private void AttachCArgBufferToComputeKernel()
		{
			if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetComputeBufferParam(_resources.computeShader, _currentRenderIndex, PipelineProperties.ShaderProperties.cArgBuffer.id, _cArgsComputeBuffer);
			}
			else
			{
				_resources.computeShader.SetBuffer(_currentRenderIndex, PipelineProperties.ShaderProperties.cArgBuffer.id, _cArgsComputeBuffer);
			}
		}

		private void SetFloat(PipelineProperties.ShaderProperties.CBufferProperty property, float value, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				_cArgArray[property.index] = value;
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalFloat(property.id, value);
			}
			else
			{
				Shader.SetGlobalFloat(property.id, value);
			}
		}

		private void SetVector(PipelineProperties.ShaderProperties.CBufferProperty property, Vector4 value, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				_cArgArray[property.index] = value.x;
				_cArgArray[property.index + 1] = value.y;
				_cArgArray[property.index + 2] = value.z;
				_cArgArray[property.index + 3] = value.w;
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalVector(property.id, value);
			}
			else
			{
				Shader.SetGlobalVector(property.id, value);
			}
		}

		private void SetVector(PipelineProperties.ShaderProperties.CBufferProperty property, Vector3 value, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				_cArgArray[property.index] = value.x;
				_cArgArray[property.index + 1] = value.y;
				_cArgArray[property.index + 2] = value.z;
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalVector(property.id, value);
			}
			else
			{
				Shader.SetGlobalVector(property.id, value);
			}
		}

		private void SetVector(PipelineProperties.ShaderProperties.CBufferProperty property, Vector2 value, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				_cArgArray[property.index] = value.x;
				_cArgArray[property.index + 1] = value.y;
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalVector(property.id, value);
			}
			else
			{
				Shader.SetGlobalVector(property.id, value);
			}
		}

		private void SetTexture(PipelineProperties.ShaderProperties.DefaultProperty property, RenderTarget rt, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				if (_renderPipeline == RenderPipeline.SRP)
				{
					_commandBuffer.SetComputeTextureParam(_resources.computeShader, _currentRenderIndex, property.id, rt.renderTargetIdentifier);
				}
				else
				{
					_resources.computeShader.SetTexture(_currentRenderIndex, property.id, rt.renderTexture);
				}
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalTexture(property.id, rt.renderTargetIdentifier);
			}
			else
			{
				Shader.SetGlobalTexture(property.id, rt.renderTexture);
			}
		}

		private void SetTexture(PipelineProperties.ShaderProperties.DefaultProperty property, Texture tex, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				if (_renderPipeline == RenderPipeline.SRP)
				{
					_commandBuffer.SetComputeTextureParam(_resources.computeShader, _currentRenderIndex, property.id, tex);
				}
				else
				{
					_resources.computeShader.SetTexture(_currentRenderIndex, property.id, tex);
				}
			}
			else if (_renderPipeline == RenderPipeline.SRP)
			{
				_commandBuffer.SetGlobalTexture(property.id, tex);
			}
			else
			{
				Shader.SetGlobalTexture(property.id, tex);
			}
		}

		private void PrepareDraw(int variant, RenderDimension renderDimension, bool forcePixelShader = false)
		{
			if (_useComputeShaders && !forcePixelShader)
			{
				UpdateRenderIndex(variant);
				AttachCArgBufferToComputeKernel();
				UpdateComputeShaderThreadGroups(renderDimension);
				return;
			}
			SetRenderPriority();
			UpdateRenderIndex(variant);
			DisableRenderKeywords();
			foreach (MaterialKeywords item in _renderKeywordsBundle)
			{
				SetKeyword(item, enable: true);
			}
			_renderKeywordsBundle.Clear();
		}

		private void PrepareDraw(int materialPass, ComputeShaderVariants variants, bool enableBloom, bool enableLensflare, bool enableGlare, RenderDimension renderDimension)
		{
			if (_useComputeShaders)
			{
				computeShaderFeatures.bloom = (enableBloom ? 1 : 0);
				computeShaderFeatures.lensSurface = (_settings.allowLensSurface ? 1 : 0);
				computeShaderFeatures.lensFlare = (enableLensflare ? 1 : 0);
				computeShaderFeatures.glare = (enableGlare ? _settings.glareStreaks : 0);
				computeShaderFeatures.natural = ((_settings.workflow == Workflow.Natural) ? 1 : 0);
				computeShaderFeatures.renderPriority = ((_settings.renderPriority > RenderPriority.Quality) ? ((_settings.renderPriority == RenderPriority.Balanced) ? 1 : 2) : 0);
				UpdateRenderIndex(variants, computeShaderFeatures);
				AttachCArgBufferToComputeKernel();
				UpdateComputeShaderThreadGroups(renderDimension);
				return;
			}
			SetRenderPriority();
			UpdateRenderIndex(materialPass);
			DisableRenderKeywords();
			foreach (MaterialKeywords item in _renderKeywordsBundle)
			{
				SetKeyword(item, enable: true);
			}
			_renderKeywordsBundle.Clear();
		}

		private void Draw(RenderDimension dimension, bool forcePixelShader = false)
		{
			if (_renderPipeline == RenderPipeline.SRP)
			{
				if (_useComputeShaders && !forcePixelShader)
				{
					_commandBuffer.Draw(_renderTargetsBundle, _resources.computeShader, _currentRenderIndex, _computeThreadGroups);
				}
				else
				{
					_commandBuffer.Draw(_renderTargetsBundle, _useGeometryShaders ? _renderMaterialGeometry : _renderMaterialNoGeometry, _useGeometryShaders, _currentRenderIndex, new Rect(0f, 0f, dimension.width, dimension.height));
				}
			}
			else if (_useComputeShaders && !forcePixelShader)
			{
				PipelineExtensions.Draw(_renderTargetsBundle, _resources.computeShader, _currentRenderIndex, _computeThreadGroups);
			}
			else
			{
				PipelineExtensions.Draw(_renderTargetsBundle, _useGeometryShaders ? _renderMaterialGeometry : _renderMaterialNoGeometry, _useGeometryShaders, _currentRenderIndex);
			}
			_renderTargetsBundle.Clear();
		}

		private MaterialKeywords GetGlareKeyword(int streaks)
		{
			return streaks switch
			{
				1 => MaterialKeywords.Glare1, 
				2 => MaterialKeywords.Glare2, 
				3 => MaterialKeywords.Glare3, 
				4 => MaterialKeywords.Glare4, 
				_ => MaterialKeywords.Null, 
			};
		}

		private void DisableRenderKeywords()
		{
			SetKeyword(MaterialKeywords.Bloom, enable: false);
			SetKeyword(MaterialKeywords.LensSurface, enable: false);
			SetKeyword(MaterialKeywords.LensFlare, enable: false);
			SetKeyword(MaterialKeywords.Glare1, enable: false);
			SetKeyword(MaterialKeywords.Glare2, enable: false);
			SetKeyword(MaterialKeywords.Glare3, enable: false);
			SetKeyword(MaterialKeywords.Glare4, enable: false);
			SetKeyword(MaterialKeywords.RenderPriorityBalanced, enable: false);
			SetKeyword(MaterialKeywords.RenderPriorityQuality, enable: false);
			SetKeyword(MaterialKeywords.Natural, enable: false);
		}

		private void DisableDebugKeywords()
		{
			SetKeyword(MaterialKeywords.DebugRawBloom, enable: false);
			SetKeyword(MaterialKeywords.DebugRawLensFlare, enable: false);
			SetKeyword(MaterialKeywords.DebugRawGlare, enable: false);
			SetKeyword(MaterialKeywords.DebugBloom, enable: false);
			SetKeyword(MaterialKeywords.DebugLensFlare, enable: false);
			SetKeyword(MaterialKeywords.DebugGlare, enable: false);
			SetKeyword(MaterialKeywords.DebugComposite, enable: false);
		}

		private void SetRenderPriority()
		{
			if (_settings.renderPriority == RenderPriority.Quality)
			{
				_renderKeywordsBundle.Add(MaterialKeywords.RenderPriorityQuality);
			}
			else if (_settings.renderPriority == RenderPriority.Balanced)
			{
				_renderKeywordsBundle.Add(MaterialKeywords.RenderPriorityBalanced);
			}
		}

		private void PreSample()
		{
			BeginProfileSample(PipelineProperties.CommandBufferProperties.samplePreSample);
			_bloomDownsampleBuffer.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
			_renderKeywordsBundle.Add(MaterialKeywords.Bloom);
			if (_settings.workflow == Workflow.Natural)
			{
				_renderKeywordsBundle.Add(MaterialKeywords.Natural);
			}
			_renderTargetsBundle.Add(_bloomDownsampleBuffer.renderTargets[0]);
			if (_useLensFlare)
			{
				_lensFlareDownsampleBuffer.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
				_renderKeywordsBundle.Add(MaterialKeywords.LensFlare);
				_renderTargetsBundle.Add(_lensFlareDownsampleBuffer.renderTargets[0]);
			}
			if (_useGlare)
			{
				_glareDownsampleBuffer0.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
				_glareDownsampleBuffer1.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
				_glareDownsampleBuffer2.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
				_glareDownsampleBuffer3.CreateTemporary(_renderContext, 0, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
				_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
				_renderTargetsBundle.Add(_glareDownsampleBuffer0.renderTargets[0]);
				_renderTargetsBundle.Add(_glareDownsampleBuffer1.renderTargets[0]);
				_renderTargetsBundle.Add(_glareDownsampleBuffer2.renderTargets[0]);
				_renderTargetsBundle.Add(_glareDownsampleBuffer3.renderTargets[0]);
			}
			PrepareDraw(1, _presampleComputeVariants, enableBloom: true, _useLensFlare, _useGlare, _renderContext[0].renderDimension);
			if (_useComputeShaders)
			{
				SetTexture(PipelineProperties.ShaderProperties.bloomTargetTex, _bloomDownsampleBuffer.renderTargets[0]);
			}
			if (_settings.workflow == Workflow.Selective)
			{
				SetTexture(PipelineProperties.ShaderProperties.sourceTex, _selectiveRenderTarget.renderTexture);
			}
			else
			{
				SetTexture(PipelineProperties.ShaderProperties.sourceTex, sourceFrameBuffer);
			}
			if (_useLensFlare)
			{
				SetTexture(PipelineProperties.ShaderProperties.lensFlareColorRamp, _settings.lensFlareColorRamp ? _settings.lensFlareColorRamp : _resources.lensFlareColorRampDefault);
				if (_useComputeShaders)
				{
					SetTexture(PipelineProperties.ShaderProperties.lensFlareTargetTex, _lensFlareDownsampleBuffer.renderTargets[0]);
				}
			}
			if (_useGlare && _useComputeShaders)
			{
				SetTexture(PipelineProperties.ShaderProperties.glare0TargetTex, _glareDownsampleBuffer0.renderTargets[0]);
				SetTexture(PipelineProperties.ShaderProperties.glare1TargetTex, _glareDownsampleBuffer1.renderTargets[0]);
				SetTexture(PipelineProperties.ShaderProperties.glare2TargetTex, _glareDownsampleBuffer2.renderTargets[0]);
				SetTexture(PipelineProperties.ShaderProperties.glare3TargetTex, _glareDownsampleBuffer3.renderTargets[0]);
			}
			Draw(_renderContext[0].renderDimension);
			if (_settings.workflow == Workflow.Selective)
			{
				RenderTexture.ReleaseTemporary(_selectiveRenderTarget.renderTexture);
			}
			EndProfileSample(PipelineProperties.CommandBufferProperties.samplePreSample);
		}

		private void Downsample()
		{
			BeginProfileSample(PipelineProperties.CommandBufferProperties.sampleDownsample);
			for (int i = 0; i < _minIterations; i++)
			{
				bool flag = i < _bloomIterations;
				bool flag2 = _useLensFlare && i < _lensFlareIterations;
				bool flag3 = _useGlare && i < _glareIterations;
				if (flag)
				{
					_bloomDownsampleBuffer.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_renderKeywordsBundle.Add(MaterialKeywords.Bloom);
					_renderTargetsBundle.Add(_bloomDownsampleBuffer.renderTargets[i + 1]);
				}
				if (flag2)
				{
					_lensFlareDownsampleBuffer.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_renderKeywordsBundle.Add(MaterialKeywords.LensFlare);
					_renderTargetsBundle.Add(_lensFlareDownsampleBuffer.renderTargets[i + 1]);
				}
				if (flag3)
				{
					_glareDownsampleBuffer0.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_glareDownsampleBuffer1.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_glareDownsampleBuffer2.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_glareDownsampleBuffer3.CreateTemporary(_renderContext, i + 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
					_renderTargetsBundle.Add(_glareDownsampleBuffer0.renderTargets[i + 1]);
					_renderTargetsBundle.Add(_glareDownsampleBuffer1.renderTargets[i + 1]);
					_renderTargetsBundle.Add(_glareDownsampleBuffer2.renderTargets[i + 1]);
					_renderTargetsBundle.Add(_glareDownsampleBuffer3.renderTargets[i + 1]);
				}
				PrepareDraw(2, _downsampleComputeVariants, flag, flag2, flag3, _renderContext[i + 1].renderDimension);
				if (flag)
				{
					SetTexture(PipelineProperties.ShaderProperties.bloomTex, _bloomDownsampleBuffer.renderTargets[i]);
					if (_useComputeShaders)
					{
						SetTexture(PipelineProperties.ShaderProperties.bloomTargetTex, _bloomDownsampleBuffer.renderTargets[i + 1]);
					}
				}
				if (flag2)
				{
					SetTexture(PipelineProperties.ShaderProperties.lensFlareTex, _lensFlareDownsampleBuffer.renderTargets[i]);
					if (_useComputeShaders)
					{
						SetTexture(PipelineProperties.ShaderProperties.lensFlareTargetTex, _lensFlareDownsampleBuffer.renderTargets[i + 1]);
					}
				}
				if (flag3)
				{
					SetTexture(PipelineProperties.ShaderProperties.glare0Tex, _glareDownsampleBuffer0.renderTargets[i]);
					SetTexture(PipelineProperties.ShaderProperties.glare1Tex, _glareDownsampleBuffer1.renderTargets[i]);
					SetTexture(PipelineProperties.ShaderProperties.glare2Tex, _glareDownsampleBuffer2.renderTargets[i]);
					SetTexture(PipelineProperties.ShaderProperties.glare3Tex, _glareDownsampleBuffer3.renderTargets[i]);
					if (_useComputeShaders)
					{
						SetTexture(PipelineProperties.ShaderProperties.glare0TargetTex, _glareDownsampleBuffer0.renderTargets[i + 1]);
						SetTexture(PipelineProperties.ShaderProperties.glare1TargetTex, _glareDownsampleBuffer1.renderTargets[i + 1]);
						SetTexture(PipelineProperties.ShaderProperties.glare2TargetTex, _glareDownsampleBuffer2.renderTargets[i + 1]);
						SetTexture(PipelineProperties.ShaderProperties.glare3TargetTex, _glareDownsampleBuffer3.renderTargets[i + 1]);
					}
				}
				Draw(_renderContext[i + 1].renderDimension);
			}
			EndProfileSample(PipelineProperties.CommandBufferProperties.sampleDownsample);
		}

		private void Upsample()
		{
			BeginProfileSample(PipelineProperties.CommandBufferProperties.sampleUpsample);
			for (int num = _minIterations; num > 0; num--)
			{
				bool flag = num <= _bloomIterations;
				bool flag2 = _useLensFlare && num <= _lensFlareIterations;
				bool flag3 = _useGlare && num <= _glareIterations;
				if (flag)
				{
					_bloomUpsampleBuffer.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_renderKeywordsBundle.Add(MaterialKeywords.Bloom);
					_renderTargetsBundle.Add(_bloomUpsampleBuffer.renderTargets[num - 1]);
				}
				if (flag2)
				{
					_lensFlareUpsampleBuffer.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
					_renderKeywordsBundle.Add(MaterialKeywords.LensFlare);
					_renderTargetsBundle.Add(_lensFlareUpsampleBuffer.renderTargets[num - 1]);
				}
				if (flag3)
				{
					if (_settings.glareStreaks >= 1)
					{
						_glareUpsampleBuffer0.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
						_renderTargetsBundle.Add(_glareUpsampleBuffer0.renderTargets[num - 1]);
					}
					if (_settings.glareStreaks >= 2)
					{
						_glareUpsampleBuffer1.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
						_renderTargetsBundle.Add(_glareUpsampleBuffer1.renderTargets[num - 1]);
					}
					if (_settings.glareStreaks >= 3)
					{
						_glareUpsampleBuffer2.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
						_renderTargetsBundle.Add(_glareUpsampleBuffer2.renderTargets[num - 1]);
					}
					if (_settings.glareStreaks >= 4)
					{
						_glareUpsampleBuffer3.CreateTemporary(_renderContext, num - 1, _commandBuffer, _renderTextureFormat, _useComputeShaders, _renderPipeline);
						_renderTargetsBundle.Add(_glareUpsampleBuffer3.renderTargets[num - 1]);
					}
					_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
				}
				PrepareDraw(3, _upsampleComputeVariants, flag, flag2, flag3, _renderContext[num - 1].renderDimension);
				if (flag)
				{
					SetTexture(PipelineProperties.ShaderProperties.higherMipBloomTex, _bloomDownsampleBuffer.renderTargets[num - 1]);
					SetTexture(PipelineProperties.ShaderProperties.bloomTex, (num >= _bloomIterations) ? _bloomDownsampleBuffer.renderTargets[num] : _bloomUpsampleBuffer.renderTargets[num]);
					if (_useComputeShaders)
					{
						SetTexture(PipelineProperties.ShaderProperties.bloomTargetTex, _bloomUpsampleBuffer.renderTargets[num - 1]);
					}
				}
				if (flag2)
				{
					SetTexture(PipelineProperties.ShaderProperties.lensFlareTex, (num >= _lensFlareIterations) ? _lensFlareDownsampleBuffer.renderTargets[num] : _lensFlareUpsampleBuffer.renderTargets[num]);
					if (_useComputeShaders)
					{
						SetTexture(PipelineProperties.ShaderProperties.lensFlareTargetTex, _lensFlareUpsampleBuffer.renderTargets[num - 1]);
					}
				}
				if (flag3)
				{
					if (_settings.glareStreaks >= 1)
					{
						SetTexture(PipelineProperties.ShaderProperties.glare0Tex, (num >= _glareIterations) ? _glareDownsampleBuffer0.renderTargets[num] : _glareUpsampleBuffer0.renderTargets[num]);
					}
					if (_settings.glareStreaks >= 2)
					{
						SetTexture(PipelineProperties.ShaderProperties.glare1Tex, (num >= _glareIterations) ? _glareDownsampleBuffer1.renderTargets[num] : _glareUpsampleBuffer1.renderTargets[num]);
					}
					if (_settings.glareStreaks >= 3)
					{
						SetTexture(PipelineProperties.ShaderProperties.glare2Tex, (num >= _glareIterations) ? _glareDownsampleBuffer2.renderTargets[num] : _glareUpsampleBuffer2.renderTargets[num]);
					}
					if (_settings.glareStreaks >= 4)
					{
						SetTexture(PipelineProperties.ShaderProperties.glare3Tex, (num >= _glareIterations) ? _glareDownsampleBuffer3.renderTargets[num] : _glareUpsampleBuffer3.renderTargets[num]);
					}
					if (_useComputeShaders)
					{
						if (_settings.glareStreaks >= 1)
						{
							SetTexture(PipelineProperties.ShaderProperties.glare0TargetTex, _glareUpsampleBuffer0.renderTargets[num - 1]);
						}
						if (_settings.glareStreaks >= 2)
						{
							SetTexture(PipelineProperties.ShaderProperties.glare1TargetTex, _glareUpsampleBuffer1.renderTargets[num - 1]);
						}
						if (_settings.glareStreaks >= 3)
						{
							SetTexture(PipelineProperties.ShaderProperties.glare2TargetTex, _glareUpsampleBuffer2.renderTargets[num - 1]);
						}
						if (_settings.glareStreaks >= 4)
						{
							SetTexture(PipelineProperties.ShaderProperties.glare3TargetTex, _glareUpsampleBuffer3.renderTargets[num - 1]);
						}
					}
				}
				Draw(_renderContext[num - 1].renderDimension);
				if (flag)
				{
					if (num >= _bloomIterations)
					{
						_bloomDownsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
					}
					else
					{
						_bloomDownsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
						_bloomUpsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
					}
				}
				if (flag2)
				{
					if (num >= _lensFlareIterations)
					{
						_lensFlareDownsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
					}
					else
					{
						_lensFlareDownsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
						_lensFlareUpsampleBuffer.ClearTemporary(_commandBuffer, num, _renderPipeline);
					}
				}
				if (flag3)
				{
					if (num >= _glareIterations)
					{
						_glareDownsampleBuffer0.ClearTemporary(_commandBuffer, num, _renderPipeline);
						_glareDownsampleBuffer1.ClearTemporary(_commandBuffer, num, _renderPipeline);
						_glareDownsampleBuffer2.ClearTemporary(_commandBuffer, num, _renderPipeline);
						_glareDownsampleBuffer3.ClearTemporary(_commandBuffer, num, _renderPipeline);
					}
					else
					{
						_glareDownsampleBuffer0.ClearTemporary(_commandBuffer, num, _renderPipeline);
						if (_settings.glareStreaks >= 1)
						{
							_glareUpsampleBuffer0.ClearTemporary(_commandBuffer, num, _renderPipeline);
						}
						if (_settings.glareStreaks >= 2)
						{
							_glareUpsampleBuffer1.ClearTemporary(_commandBuffer, num, _renderPipeline);
						}
						if (_settings.glareStreaks >= 3)
						{
							_glareUpsampleBuffer2.ClearTemporary(_commandBuffer, num, _renderPipeline);
						}
						if (_settings.glareStreaks >= 4)
						{
							_glareUpsampleBuffer3.ClearTemporary(_commandBuffer, num, _renderPipeline);
						}
					}
				}
			}
			_bloomDownsampleBuffer.ClearTemporary(_commandBuffer, 0, _renderPipeline);
			if (_useLensFlare)
			{
				_lensFlareDownsampleBuffer.ClearTemporary(_commandBuffer, 0, _renderPipeline);
			}
			if (_useGlare)
			{
				_glareDownsampleBuffer0.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				_glareDownsampleBuffer1.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				_glareDownsampleBuffer2.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				_glareDownsampleBuffer3.ClearTemporary(_commandBuffer, 0, _renderPipeline);
			}
			EndProfileSample(PipelineProperties.CommandBufferProperties.sampleUpsample);
		}

		private void Composite()
		{
			BeginProfileSample(PipelineProperties.CommandBufferProperties.sampleComposite);
			int variant;
			switch (_settings.debugView)
			{
			case DebugView.RawBloom:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugRawBloom);
				variant = 5;
				break;
			case DebugView.RawLensFlare:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugRawLensFlare);
				variant = 5;
				break;
			case DebugView.RawGlare:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugRawGlare);
				variant = 5;
				break;
			case DebugView.Bloom:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugBloom);
				variant = 5;
				break;
			case DebugView.LensFlare:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugLensFlare);
				variant = 5;
				break;
			case DebugView.Glare:
				_renderKeywordsBundle.Add(MaterialKeywords.DebugGlare);
				_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
				variant = 5;
				break;
			case DebugView.Composite:
				if (_settings.workflow == Workflow.Natural)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.Natural);
				}
				if (_useLensSurface)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.LensSurface);
				}
				if (_useLensFlare)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.LensFlare);
				}
				if (_useGlare)
				{
					_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
				}
				_renderKeywordsBundle.Add(MaterialKeywords.DebugComposite);
				variant = 5;
				break;
			default:
				if (_settings.workflow == Workflow.Natural)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.Natural);
				}
				if (_useLensSurface)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.LensSurface);
				}
				if (_useLensFlare)
				{
					_renderKeywordsBundle.Add(MaterialKeywords.LensFlare);
				}
				if (_useGlare)
				{
					_renderKeywordsBundle.Add(GetGlareKeyword(_settings.glareStreaks));
				}
				variant = 4;
				break;
			}
			if (_settings.workflow == Workflow.Natural)
			{
				_renderKeywordsBundle.Add(MaterialKeywords.Natural);
			}
			PrepareDraw(variant, _sourceContext[0].renderDimension, forcePixelShader: true);
			if (_settings.workflow == Workflow.Selective && (_settings.debugView == DebugView.RawBloom || _settings.debugView == DebugView.RawLensFlare || _settings.debugView == DebugView.RawGlare))
			{
				SetTexture(PipelineProperties.ShaderProperties.sourceTex, sourceFrameBuffer.renderTexture, forcePixelShader: true);
			}
			else
			{
				SetTexture(PipelineProperties.ShaderProperties.sourceTex, _sourceFrameBuffer, forcePixelShader: true);
				SetTexture(PipelineProperties.ShaderProperties.bloomTex, _bloomUpsampleBuffer.renderTargets[0], forcePixelShader: true);
			}
			if (_useLensSurface)
			{
				SetTexture(PipelineProperties.ShaderProperties.lensSurfaceDirtTex, _settings.lensSurfaceDirtTexture ? _settings.lensSurfaceDirtTexture : _resources.lensSurfaceDirtTextureDefault, forcePixelShader: true);
				SetTexture(PipelineProperties.ShaderProperties.lensSurfaceDiffractionTex, _settings.lensSurfaceDiffractionTexture ? _settings.lensSurfaceDiffractionTexture : _resources.lensSurfaceDiffractionTextureDefault, forcePixelShader: true);
			}
			if (_useLensFlare)
			{
				SetTexture(PipelineProperties.ShaderProperties.lensFlareTex, _lensFlareUpsampleBuffer.renderTargets[0], forcePixelShader: true);
			}
			if (_useGlare)
			{
				if (_settings.glareStreaks >= 1)
				{
					SetTexture(PipelineProperties.ShaderProperties.glare0Tex, _glareUpsampleBuffer0.renderTargets[0], forcePixelShader: true);
				}
				if (_settings.glareStreaks >= 2)
				{
					SetTexture(PipelineProperties.ShaderProperties.glare1Tex, _glareUpsampleBuffer1.renderTargets[0], forcePixelShader: true);
				}
				if (_settings.glareStreaks >= 3)
				{
					SetTexture(PipelineProperties.ShaderProperties.glare2Tex, _glareUpsampleBuffer2.renderTargets[0], forcePixelShader: true);
				}
				if (_settings.glareStreaks >= 4)
				{
					SetTexture(PipelineProperties.ShaderProperties.glare3Tex, _glareUpsampleBuffer3.renderTargets[0], forcePixelShader: true);
				}
			}
			if (_renderPipeline == RenderPipeline.SRP)
			{
				_renderTargetsBundle.Add(_destinationFrameBuffer);
				Draw(_sourceContext[0].renderDimension, forcePixelShader: true);
				AfterCompositeCleanup();
			}
			else
			{
				PipelineExtensions.SetKeyword(_shaderKeywords[11].name, enable: true);
				_renderTargetsBundle.Clear();
			}
			EndProfileSample(PipelineProperties.CommandBufferProperties.sampleComposite);
		}

		internal void AfterCompositeCleanup()
		{
			_bloomUpsampleBuffer.ClearTemporary(_commandBuffer, 0, _renderPipeline);
			if (_useLensFlare)
			{
				_lensFlareUpsampleBuffer.ClearTemporary(_commandBuffer, 0, _renderPipeline);
			}
			if (_useGlare)
			{
				if (_settings.glareStreaks >= 1)
				{
					_glareUpsampleBuffer0.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				}
				if (_settings.glareStreaks >= 2)
				{
					_glareUpsampleBuffer1.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				}
				if (_settings.glareStreaks >= 3)
				{
					_glareUpsampleBuffer2.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				}
				if (_settings.glareStreaks >= 4)
				{
					_glareUpsampleBuffer3.ClearTemporary(_commandBuffer, 0, _renderPipeline);
				}
			}
			DisableDebugKeywords();
			DisableRenderKeywords();
			if (_renderPipeline == RenderPipeline.Legacy)
			{
				PipelineExtensions.SetKeyword(_shaderKeywords[11].name, enable: false);
			}
		}
	}
	internal interface IDimension
	{
		int width { get; }

		int height { get; }

		RenderDimension renderDimension { get; }
	}
	public sealed class MinMaxRangeAttribute : PropertyAttribute
	{
		public float minLimit;

		public float maxLimit;

		public MinMaxRangeAttribute(float minLimit, float maxLimit)
		{
			this.minLimit = minLimit;
			this.maxLimit = maxLimit;
		}
	}
	[Serializable]
	public struct MinMaxRange
	{
		public float minValue;

		public float maxValue;

		public MinMaxRange(float minValue, float maxValue)
		{
			this.minValue = minValue;
			this.maxValue = maxValue;
		}
	}
	internal sealed class MipBuffer
	{
		private RenderTarget[] _renderTargets = new RenderTarget[PipelineProperties.renderBufferSize];

		internal RenderTarget[] renderTargets => _renderTargets;

		public MipBuffer(string name, RenderPipeline renderPipeline)
		{
			if (renderPipeline == RenderPipeline.SRP)
			{
				for (int i = 0; i < PipelineProperties.renderBufferSize; i++)
				{
					_renderTargets[i].identifier = Shader.PropertyToID(name + i);
					_renderTargets[i].renderTargetIdentifier = new RenderTargetIdentifier(renderTargets[i].identifier, 0, CubemapFace.Unknown, -1);
				}
			}
			else
			{
				for (int j = 0; j < PipelineProperties.renderBufferSize; j++)
				{
					renderTargets[j].identifier = Shader.PropertyToID(name + j);
				}
			}
		}

		internal void CreateTemporary(RenderContext[] renderContext, int level, CommandBuffer cmd, RenderTextureFormat format, bool useComputeShaders, RenderPipeline renderPipeline)
		{
			if (renderPipeline == RenderPipeline.SRP)
			{
				cmd.GetTemporaryRT(renderTargets[level].identifier, renderContext[level].descriptor, FilterMode.Bilinear);
			}
			else
			{
				renderTargets[level].renderTexture = PipelineExtensions.GetTemporary(renderContext[level], format);
			}
		}

		internal void ClearTemporary(CommandBuffer cmd, int level, RenderPipeline renderPipeline)
		{
			if (renderPipeline == RenderPipeline.SRP)
			{
				cmd.ReleaseTemporaryRT(renderTargets[level].identifier);
			}
			else
			{
				RenderTexture.ReleaseTemporary(renderTargets[level].renderTexture);
			}
		}
	}
	internal static class PipelineExtensions
	{
		private static Mesh _screenMesh;

		private static Mesh screenMesh
		{
			get
			{
				if (_screenMesh == null)
				{
					_screenMesh = new Mesh
					{
						name = "MKGlowScreenMesh"
					};
					_screenMesh.SetVertices(new List<Vector3>
					{
						new Vector3(-1f, -1f, 0f),
						new Vector3(3f, -1f, 0f),
						new Vector3(-1f, 3f, 0f)
					});
					_screenMesh.SetIndices(new int[3] { 0, 1, 2 }, MeshTopology.Triangles, 0, calculateBounds: false);
					_screenMesh.UploadMeshData(markNoLongerReadable: false);
				}
				return _screenMesh;
			}
		}

		internal static void SetKeyword(this CommandBuffer cmd, string keyword, bool enable)
		{
			if (enable)
			{
				cmd.EnableShaderKeyword(keyword);
			}
			else
			{
				cmd.DisableShaderKeyword(keyword);
			}
		}

		internal static void SetKeyword(string keyword, bool enable)
		{
			if (enable)
			{
				Shader.EnableKeyword(keyword);
			}
			else
			{
				Shader.DisableKeyword(keyword);
			}
		}

		internal static void Draw(this CommandBuffer cmd, List<RenderTarget> destinations, Material material, bool useGeometryShader, int pass, Rect viewport)
		{
			cmd.SetRenderTargetContext(destinations);
			cmd.SetViewport(viewport);
			if (useGeometryShader)
			{
				cmd.DrawProcedural(Matrix4x4.identity, material, pass, MeshTopology.Points, 1);
			}
			else
			{
				cmd.DrawMesh(screenMesh, Matrix4x4.identity, material, 0, pass);
			}
		}

		internal static void Draw(List<RenderTarget> destinations, Material material, bool useGeometryShader, int pass)
		{
			RenderTargetContext.SetRenderTargetContext(destinations);
			if (useGeometryShader)
			{
				material.SetPass(pass);
				Graphics.DrawProceduralNow(MeshTopology.Points, 1);
			}
			else
			{
				material.SetPass(pass);
				Graphics.DrawMeshNow(screenMesh, Vector3.zero, Quaternion.identity);
			}
		}

		internal static void Draw(this CommandBuffer cmd, List<RenderTarget> destinations, ComputeShader computeShader, int kernelIndex, RenderDimension computeThreadGroups)
		{
			cmd.DispatchCompute(computeShader, kernelIndex, computeThreadGroups.width, computeThreadGroups.height, 1);
		}

		internal static void Draw(List<RenderTarget> destinations, ComputeShader computeShader, int kernelIndex, RenderDimension computeThreadGroups)
		{
			computeShader.Dispatch(kernelIndex, computeThreadGroups.width, computeThreadGroups.height, 1);
		}

		private static int SinglePassStereoDownscale(bool cameraIsStereo, int size, int scale)
		{
			if (!cameraIsStereo || !PipelineProperties.singlePassStereoDoubleWideEnabled || size / 2 % 2 <= 0)
			{
				return size / scale;
			}
			return 1 + size / scale;
		}

		internal static void UpdateMipRenderContext(this CameraData cameraData, RenderContext[] renderContexts, RenderDimension rawDimension, int levels, RenderTextureFormat format, int depthBufferBits, bool enableRandomWrite)
		{
			for (int i = 0; i < levels; i++)
			{
				renderContexts[i].UpdateRenderContext(cameraData.stereoEnabled, format, depthBufferBits, enableRandomWrite, rawDimension);
				rawDimension.width = Mathf.Max(SinglePassStereoDownscale(cameraData.stereoEnabled, rawDimension.width, 2), 1);
				rawDimension.height = Mathf.Max(rawDimension.height / 2, 1);
			}
		}

		internal static RenderTexture GetTemporary(RenderContext renderContext, RenderTextureFormat format)
		{
			return RenderTexture.GetTemporary(renderContext.descriptor);
		}
	}
	internal static class PipelineProperties
	{
		internal static class ShaderProperties
		{
			internal class DefaultProperty
			{
				protected string _name;

				protected int _id;

				internal string name => _name;

				internal int id => _id;

				internal DefaultProperty(string name)
				{
					_name = name;
					_id = Shader.PropertyToID(name);
				}
			}

			internal sealed class CBufferProperty : DefaultProperty
			{
				private int _index;

				private int _size;

				internal int index => _index;

				internal int size => _size;

				internal CBufferProperty(string name, int index, int size)
					: base("")
				{
					_name = name;
					_id = Shader.PropertyToID(name);
					_index = index;
					_size = size;
				}
			}

			internal static readonly CBufferProperty screenSize = new CBufferProperty("_DisplaySize", 0, 2);

			internal static readonly CBufferProperty singlePassStereoScale = new CBufferProperty("_SinglePassStereoScale", 65, 1);

			internal static readonly CBufferProperty viewMatrix = new CBufferProperty("_ViewMatrix", 49, 16);

			internal static readonly DefaultProperty cArgBuffer = new DefaultProperty("_CArgBuffer");

			internal static readonly DefaultProperty sourceTex = new DefaultProperty("_SourceTex");

			internal static readonly DefaultProperty targetTex = new DefaultProperty("_TargetTex");

			internal static readonly DefaultProperty copyTargetTex = new DefaultProperty("_CopyTargetTex");

			internal static readonly DefaultProperty bloomTex = new DefaultProperty("_BloomTex");

			internal static readonly DefaultProperty bloomTargetTex = new DefaultProperty("_BloomTargetTex");

			internal static readonly CBufferProperty bloomSpread = new CBufferProperty("_BloomSpread", 3, 1);

			internal static readonly CBufferProperty bloomThreshold = new CBufferProperty("_BloomThreshold", 0, 2);

			internal static readonly CBufferProperty lumaScale = new CBufferProperty("_LumaScale", 2, 1);

			internal static readonly CBufferProperty bloomIntensity = new CBufferProperty("_BloomIntensity", 4, 1);

			internal static readonly CBufferProperty blooming = new CBufferProperty("_Blooming", 5, 1);

			internal static readonly DefaultProperty higherMipBloomTex = new DefaultProperty("_HigherMipBloomTex");

			internal static readonly CBufferProperty resolutionScale = new CBufferProperty("_ResolutionScale", 38, 2);

			internal static readonly DefaultProperty lensSurfaceDirtTex = new DefaultProperty("_LensSurfaceDirtTex");

			internal static readonly DefaultProperty lensSurfaceDiffractionTex = new DefaultProperty("_LensSurfaceDiffractionTex");

			internal static readonly CBufferProperty lensSurfaceDirtIntensity = new CBufferProperty("_LensSurfaceDirtIntensity", 6, 1);

			internal static readonly CBufferProperty lensSurfaceDiffractionIntensity = new CBufferProperty("_LensSurfaceDiffractionIntensity", 7, 1);

			internal static readonly CBufferProperty lensSurfaceDirtTexST = new CBufferProperty("_LensSurfaceDirtTex_ST", 44, 4);

			internal static readonly CBufferProperty lensFlareThreshold = new CBufferProperty("_LensFlareThreshold", 8, 2);

			internal static readonly CBufferProperty lensFlareGhostParams = new CBufferProperty("_LensFlareGhostParams", 10, 4);

			internal static readonly CBufferProperty lensFlareHaloParams = new CBufferProperty("_LensFlareHaloParams", 14, 3);

			internal static readonly DefaultProperty lensFlareTex = new DefaultProperty("_LensFlareTex");

			internal static readonly DefaultProperty lensFlareTargetTex = new DefaultProperty("_LensFlareTargetTex");

			internal static readonly CBufferProperty lensFlareSpread = new CBufferProperty("_LensFlareSpread", 17, 1);

			internal static readonly CBufferProperty lensFlareChromaticAberration = new CBufferProperty("_LensFlareChromaticAberration", 18, 1);

			internal static readonly DefaultProperty lensFlareColorRamp = new DefaultProperty("_LensFlareColorRamp");

			internal static readonly CBufferProperty glareThreshold = new CBufferProperty("_GlareThreshold", 19, 2);

			internal static readonly CBufferProperty glareBlend = new CBufferProperty("_GlareBlend", 33, 1);

			internal static readonly CBufferProperty glareGlobalIntensity = new CBufferProperty("_GlareGlobalIntensity", 33, 1);

			internal static readonly CBufferProperty glareIntensity = new CBufferProperty("_GlareIntensity", 34, 4);

			internal static readonly CBufferProperty glareScattering = new CBufferProperty("_GlareScattering", 21, 4);

			internal static readonly CBufferProperty glareDirection01 = new CBufferProperty("_GlareDirection01", 25, 4);

			internal static readonly CBufferProperty glareDirection23 = new CBufferProperty("_GlareDirection23", 29, 4);

			internal static readonly CBufferProperty glareOffset = new CBufferProperty("_GlareOffset", 40, 4);

			internal static readonly DefaultProperty glare0Tex = new DefaultProperty("_Glare0Tex");

			internal static readonly DefaultProperty glare0TargetTex = new DefaultProperty("_Glare0TargetTex");

			internal static readonly DefaultProperty glare1Tex = new DefaultProperty("_Glare1Tex");

			internal static readonly DefaultProperty glare1TargetTex = new DefaultProperty("_Glare1TargetTex");

			internal static readonly DefaultProperty glare2Tex = new DefaultProperty("_Glare2Tex");

			internal static readonly DefaultProperty glare2TargetTex = new DefaultProperty("_Glare2TargetTex");

			internal static readonly DefaultProperty glare3Tex = new DefaultProperty("_Glare3Tex");

			internal static readonly DefaultProperty glare3TargetTex = new DefaultProperty("_Glare3TargetTex");
		}

		internal static class CommandBufferProperties
		{
			internal static readonly string commandBufferName = "MK Glow";

			internal static readonly string selectiveRenderBuffer = "_SelectiveRenderBuffer";

			internal static readonly string bloomDownsampleBuffer = "_BloomDownsampleBuffer";

			internal static readonly string bloomUpsampleBuffer = "_BloomUpsampleBuffer";

			internal static readonly string sourceBuffer = "_SourceBuffer";

			internal static readonly string glareDownsampleBuffer0 = "GlareDownsampleBuffer0";

			internal static readonly string glareDownsampleBuffer1 = "GlareDownsampleBuffer1";

			internal static readonly string glareDownsampleBuffer2 = "GlareDownsampleBuffer2";

			internal static readonly string glareDownsampleBuffer3 = "GlareDownsampleBuffer3";

			internal static readonly string glareUpsampleBuffer0 = "GlareUpsampleBuffer0";

			internal static readonly string glareUpsampleBuffer1 = "GlareUpsampleBuffer1";

			internal static readonly string glareUpsampleBuffer2 = "GlareUpsampleBuffer2";

			internal static readonly string glareUpsampleBuffer3 = "GlareUpsampleBuffer3";

			internal static readonly string lensFlareDownsampleBuffer = "LensFlareDownsampleBuffer";

			internal static readonly string lensFlareUpsampleBuffer = "LensFlareUpsampleBuffer";

			internal static readonly string sampleDownsample = "Downsample";

			internal static readonly string samplePreSample = "Presample";

			internal static readonly string sampleUpsample = "Upsample";

			internal static readonly string sampleComposite = "Composite";

			internal static readonly string sampleCreateBuffers = "Create Mip Buffers";

			internal static readonly string sampleClearBuffers = "Clear Mip Buffers";

			internal static readonly string sampleSetup = "Setup Constant Buffer";

			internal static readonly string sampleCopySource = "Copy Source";

			internal static readonly string sampleReplacement = "Render Replacement";

			internal static readonly string samplePrepare = "Prepare";
		}

		internal static readonly int renderBufferSize = 15;

		internal static bool scriptableRenderPipelineActive => GraphicsSettings.renderPipelineAsset != null;

		internal static bool xrEnabled => XRSettings.enabled;

		internal static bool singlePassStereoDoubleWideEnabled
		{
			get
			{
				if (XRSettings.enabled)
				{
					return XRSettings.stereoRenderingMode == XRSettings.StereoRenderingMode.SinglePass;
				}
				return false;
			}
		}

		internal static bool singlePassStereoInstancedEnabled
		{
			get
			{
				if (XRSettings.enabled)
				{
					if (XRSettings.stereoRenderingMode != XRSettings.StereoRenderingMode.SinglePassInstanced)
					{
						return XRSettings.stereoRenderingMode == XRSettings.StereoRenderingMode.SinglePassMultiview;
					}
					return true;
				}
				return false;
			}
		}
	}
	internal sealed class RenderContext : IDimension
	{
		private RenderTextureDescriptor _descriptor;

		public RenderTextureDescriptor descriptor => _descriptor;

		public RenderDimension renderDimension => new RenderDimension(_descriptor.width, _descriptor.height);

		public bool enableRandomWrite => _descriptor.enableRandomWrite;

		public int width => _descriptor.width;

		public int height => _descriptor.height;

		internal RenderContext()
		{
			_descriptor = (XRSettings.enabled ? XRSettings.eyeTextureDesc : default(RenderTextureDescriptor));
			_descriptor.msaaSamples = 1;
			_descriptor.useMipMap = false;
			_descriptor.autoGenerateMips = false;
			_descriptor.mipCount = 1;
		}

		internal void SinglePassStereoAdjustWidth(bool stereoEnabled)
		{
			_descriptor.width = ((stereoEnabled && PipelineProperties.singlePassStereoDoubleWideEnabled) ? (_descriptor.width * 2) : _descriptor.width);
		}

		internal void UpdateRenderContext(bool stereoEnabled, RenderTextureFormat format, int depthBufferBits, bool enableRandomWrite, RenderDimension dimension)
		{
			_descriptor.dimension = (stereoEnabled ? XRSettings.eyeTextureDesc.dimension : TextureDimension.Tex2D);
			_descriptor.vrUsage = (stereoEnabled ? XRSettings.eyeTextureDesc.vrUsage : VRTextureUsage.None);
			_descriptor.volumeDepth = ((!stereoEnabled) ? 1 : XRSettings.eyeTextureDesc.volumeDepth);
			_descriptor.colorFormat = format;
			_descriptor.depthBufferBits = depthBufferBits;
			_descriptor.enableRandomWrite = enableRandomWrite;
			_descriptor.width = dimension.width;
			_descriptor.height = dimension.height;
			_descriptor.memoryless = RenderTextureMemoryless.None;
			_descriptor.sRGB = true;
		}
	}
	internal struct RenderTarget
	{
		internal RenderTexture renderTexture;

		internal RenderTargetIdentifier renderTargetIdentifier;

		internal int identifier;
	}
	internal static class RenderTargetContext
	{
		private static int _renderTargetCount;

		private static RenderTargetSetup[] _mrtBindingsLegacy;

		private static RenderTargetBinding[] _mrtBindingsSRP;

		internal static void SetRenderTargetContext(this CommandBuffer cmd, List<RenderTarget> renderTargets)
		{
			_renderTargetCount = renderTargets.Count - 1;
			for (int i = 0; i <= _renderTargetCount; i++)
			{
				_mrtBindingsSRP[_renderTargetCount].colorRenderTargets[i] = renderTargets[i].renderTargetIdentifier;
			}
			_mrtBindingsSRP[_renderTargetCount].depthRenderTarget = _mrtBindingsSRP[_renderTargetCount].colorRenderTargets[0];
			cmd.SetRenderTarget(_mrtBindingsSRP[_renderTargetCount]);
		}

		internal static void SetRenderTargetContext(List<RenderTarget> renderTargets)
		{
			_renderTargetCount = renderTargets.Count - 1;
			for (int i = 0; i <= _renderTargetCount; i++)
			{
				_mrtBindingsLegacy[_renderTargetCount].color[i] = renderTargets[i].renderTexture.colorBuffer;
			}
			_mrtBindingsLegacy[_renderTargetCount].depth = renderTargets[_renderTargetCount].renderTexture.depthBuffer;
			Graphics.SetRenderTarget(_mrtBindingsLegacy[_renderTargetCount]);
		}

		static RenderTargetContext()
		{
			RenderTargetSetup[] array = new RenderTargetSetup[6];
			RenderTargetSetup renderTargetSetup = new RenderTargetSetup(new RenderBuffer[1], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[1] { RenderBufferLoadAction.DontCare }, new RenderBufferStoreAction[1], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[0] = renderTargetSetup;
			renderTargetSetup = new RenderTargetSetup(new RenderBuffer[2], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[2]
			{
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare
			}, new RenderBufferStoreAction[2], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[1] = renderTargetSetup;
			renderTargetSetup = new RenderTargetSetup(new RenderBuffer[3], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[3]
			{
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare
			}, new RenderBufferStoreAction[3], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[2] = renderTargetSetup;
			renderTargetSetup = new RenderTargetSetup(new RenderBuffer[4], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[4]
			{
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare
			}, new RenderBufferStoreAction[4], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[3] = renderTargetSetup;
			renderTargetSetup = new RenderTargetSetup(new RenderBuffer[5], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[5]
			{
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare
			}, new RenderBufferStoreAction[5], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[4] = renderTargetSetup;
			renderTargetSetup = new RenderTargetSetup(new RenderBuffer[6], default(RenderBuffer), 0, CubemapFace.Unknown, new RenderBufferLoadAction[6]
			{
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare,
				RenderBufferLoadAction.DontCare
			}, new RenderBufferStoreAction[6], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			{
				depthSlice = -1
			};
			array[5] = renderTargetSetup;
			_mrtBindingsLegacy = array;
			_mrtBindingsSRP = new RenderTargetBinding[6]
			{
				new RenderTargetBinding(new RenderTargetIdentifier[1], new RenderBufferLoadAction[1] { RenderBufferLoadAction.DontCare }, new RenderBufferStoreAction[1], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store),
				new RenderTargetBinding(new RenderTargetIdentifier[2], new RenderBufferLoadAction[2]
				{
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare
				}, new RenderBufferStoreAction[2], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store),
				new RenderTargetBinding(new RenderTargetIdentifier[3], new RenderBufferLoadAction[3]
				{
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare
				}, new RenderBufferStoreAction[3], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store),
				new RenderTargetBinding(new RenderTargetIdentifier[4], new RenderBufferLoadAction[4]
				{
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare
				}, new RenderBufferStoreAction[4], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store),
				new RenderTargetBinding(new RenderTargetIdentifier[5], new RenderBufferLoadAction[5]
				{
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare
				}, new RenderBufferStoreAction[5], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store),
				new RenderTargetBinding(new RenderTargetIdentifier[6], new RenderBufferLoadAction[6]
				{
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare,
					RenderBufferLoadAction.DontCare
				}, new RenderBufferStoreAction[6], 0, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store)
			};
		}
	}
	[Serializable]
	public sealed class Resources : ScriptableObject
	{
		[SerializeField]
		private Texture2D _lensSurfaceDirtTextureDefault;

		[SerializeField]
		private Texture2D _lensSurfaceDiffractionTextureDefault;

		[SerializeField]
		private Texture2D _lensFlareColorRampDefault;

		[SerializeField]
		private Shader _selectiveRenderShader;

		[SerializeField]
		private Shader _sm20Shader;

		[SerializeField]
		private Shader _sm25Shader;

		[SerializeField]
		private Shader _sm30Shader;

		[SerializeField]
		private Shader _sm35Shader;

		[SerializeField]
		private Shader _sm40Shader;

		[SerializeField]
		private Shader _sm40GeometryShader;

		[SerializeField]
		private ComputeShader _computeShader;

		[SerializeField]
		private ComputeShader _computeShaderGles;

		internal Texture2D lensSurfaceDirtTextureDefault => _lensSurfaceDirtTextureDefault;

		internal Texture2D lensSurfaceDiffractionTextureDefault => _lensSurfaceDiffractionTextureDefault;

		internal Texture2D lensFlareColorRampDefault => _lensFlareColorRampDefault;

		internal Shader selectiveRenderShader => _selectiveRenderShader;

		internal Shader sm20Shader => _sm20Shader;

		internal Shader sm25Shader => _sm25Shader;

		internal Shader sm30Shader => _sm30Shader;

		internal Shader sm35Shader => _sm35Shader;

		internal Shader sm40Shader => _sm40Shader;

		internal Shader sm40GeometryShader => _sm40GeometryShader;

		internal ComputeShader computeShader
		{
			get
			{
				if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES3)
				{
					return _computeShader;
				}
				return _computeShaderGles;
			}
		}

		internal static void ResourcesNotAvailableWarning()
		{
			UnityEngine.Debug.LogWarning("MK Glow resources asset couldn't be found. Effect will be skipped.");
		}

		internal static Resources LoadResourcesAsset()
		{
			return UnityEngine.Resources.Load<Resources>("MKGlowResources");
		}
	}
	internal abstract class Settings
	{
		protected bool _allowGeometryShaders;

		protected bool _allowComputeShaders;

		protected RenderPriority _renderPriority;

		protected DebugView _debugView;

		protected Quality _quality;

		protected Workflow _workflow;

		protected LayerMask _selectiveRenderLayerMask;

		protected float _anamorphicRatio;

		protected float _lumaScale;

		protected float _blooming;

		protected MinMaxRange _bloomThreshold;

		protected float _bloomScattering;

		protected float _bloomIntensity;

		protected bool _allowLensSurface;

		protected Texture2D _lensSurfaceDirtTexture;

		protected float _lensSurfaceDirtIntensity;

		protected Texture2D _lensSurfaceDirtDistortionTexture;

		protected float _lensSurfaceDirtDistortion;

		protected Texture2D _lensSurfaceDiffractionTexture;

		protected float _lensSurfaceDiffractionIntensity;

		protected bool _allowLensFlare;

		protected LensFlareStyle _lensFlareStyle;

		protected float _lensFlareGhostFade;

		protected float _lensFlareGhostIntensity;

		protected MinMaxRange _lensFlareThreshold;

		protected float _lensFlareScattering;

		protected Texture2D _lensFlareColorRamp;

		protected float _lensFlareChromaticAberration;

		protected int _lensFlareGhostCount;

		protected float _lensFlareGhostDispersal;

		protected float _lensFlareHaloFade;

		protected float _lensFlareHaloIntensity;

		protected float _lensFlareHaloSize;

		protected bool _allowGlare;

		protected float _glareBlend;

		protected float _glareIntensity;

		protected float _glareAngle;

		protected MinMaxRange _glareThreshold;

		protected int _glareStreaks;

		protected float _glareScattering;

		protected GlareStyle _glareStyle;

		protected float _glareSample0Scattering;

		protected float _glareSample0Angle;

		protected float _glareSample0Intensity;

		protected float _glareSample0Offset;

		protected float _glareSample1Scattering;

		protected float _glareSample1Angle;

		protected float _glareSample1Intensity;

		protected float _glareSample1Offset;

		protected float _glareSample2Scattering;

		protected float _glareSample2Angle;

		protected float _glareSample2Intensity;

		protected float _glareSample2Offset;

		protected float _glareSample3Scattering;

		protected float _glareSample3Angle;

		protected float _glareSample3Intensity;

		protected float _glareSample3Offset;

		internal bool allowGeometryShaders
		{
			get
			{
				return _allowGeometryShaders;
			}
			set
			{
				_allowGeometryShaders = value;
			}
		}

		internal bool allowComputeShaders
		{
			get
			{
				return _allowComputeShaders;
			}
			set
			{
				_allowComputeShaders = value;
			}
		}

		internal RenderPriority renderPriority
		{
			get
			{
				return _renderPriority;
			}
			set
			{
				_renderPriority = value;
			}
		}

		internal DebugView debugView
		{
			get
			{
				return _debugView;
			}
			set
			{
				_debugView = value;
			}
		}

		internal Quality quality
		{
			get
			{
				return _quality;
			}
			set
			{
				_quality = value;
			}
		}

		internal Workflow workflow
		{
			get
			{
				return _workflow;
			}
			set
			{
				_workflow = value;
			}
		}

		internal LayerMask selectiveRenderLayerMask
		{
			get
			{
				return _selectiveRenderLayerMask;
			}
			set
			{
				_selectiveRenderLayerMask = value;
			}
		}

		internal float anamorphicRatio
		{
			get
			{
				return _anamorphicRatio;
			}
			set
			{
				_anamorphicRatio = Mathf.Clamp(value, -1f, 1f);
			}
		}

		internal float lumaScale
		{
			get
			{
				return _lumaScale;
			}
			set
			{
				_lumaScale = Mathf.Clamp01(value);
			}
		}

		internal float blooming
		{
			get
			{
				return _blooming;
			}
			set
			{
				_blooming = Mathf.Clamp01(value);
			}
		}

		internal MinMaxRange bloomThreshold
		{
			get
			{
				return _bloomThreshold;
			}
			set
			{
				_bloomThreshold = value;
			}
		}

		internal float bloomScattering
		{
			get
			{
				return _bloomScattering;
			}
			set
			{
				_bloomScattering = Mathf.Clamp(value, 0f, 10f);
			}
		}

		internal float bloomIntensity
		{
			get
			{
				return _bloomIntensity;
			}
			set
			{
				_bloomIntensity = Mathf.Max(0f, value);
			}
		}

		internal bool allowLensSurface
		{
			get
			{
				return _allowLensSurface;
			}
			set
			{
				_allowLensSurface = value;
			}
		}

		internal Texture2D lensSurfaceDirtTexture
		{
			get
			{
				return _lensSurfaceDirtTexture;
			}
			set
			{
				_lensSurfaceDirtTexture = value;
			}
		}

		internal float lensSurfaceDirtIntensity
		{
			get
			{
				return _lensSurfaceDirtIntensity;
			}
			set
			{
				_lensSurfaceDirtIntensity = Mathf.Max(0f, value);
			}
		}

		internal Texture2D lensSurfaceDirtDistortionTexture
		{
			get
			{
				return _lensSurfaceDirtDistortionTexture;
			}
			set
			{
				_lensSurfaceDirtDistortionTexture = value;
			}
		}

		internal float lensSurfaceDirtDistortion
		{
			get
			{
				return _lensSurfaceDirtDistortion;
			}
			set
			{
				_lensSurfaceDirtDistortion = Mathf.Max(0f, value);
			}
		}

		internal Texture2D lensSurfaceDiffractionTexture
		{
			get
			{
				return _lensSurfaceDiffractionTexture;
			}
			set
			{
				_lensSurfaceDiffractionTexture = value;
			}
		}

		internal float lensSurfaceDiffractionIntensity
		{
			get
			{
				return _lensSurfaceDiffractionIntensity;
			}
			set
			{
				_lensSurfaceDiffractionIntensity = Mathf.Max(0f, value);
			}
		}

		internal bool allowLensFlare
		{
			get
			{
				return _allowLensFlare;
			}
			set
			{
				_allowLensFlare = value;
			}
		}

		internal LensFlareStyle lensFlareStyle
		{
			get
			{
				return _lensFlareStyle;
			}
			set
			{
				_lensFlareStyle = value;
			}
		}

		internal float lensFlareGhostFade
		{
			get
			{
				return _lensFlareGhostFade;
			}
			set
			{
				_lensFlareGhostFade = Mathf.Max(0f, value);
			}
		}

		internal float lensFlareGhostIntensity
		{
			get
			{
				return _lensFlareGhostIntensity;
			}
			set
			{
				_lensFlareGhostIntensity = Mathf.Max(0f, value);
			}
		}

		internal MinMaxRange lensFlareThreshold
		{
			get
			{
				return _lensFlareThreshold;
			}
			set
			{
				_lensFlareThreshold = value;
			}
		}

		internal float lensFlareScattering
		{
			get
			{
				return _lensFlareScattering;
			}
			set
			{
				_lensFlareScattering = Mathf.Clamp(value, 0f, 10f);
			}
		}

		internal Texture2D lensFlareColorRamp
		{
			get
			{
				return _lensFlareColorRamp;
			}
			set
			{
				_lensFlareColorRamp = value;
			}
		}

		internal float lensFlareChromaticAberration
		{
			get
			{
				return _lensFlareChromaticAberration;
			}
			set
			{
				_lensFlareChromaticAberration = value;
			}
		}

		internal int lensFlareGhostCount
		{
			get
			{
				return _lensFlareGhostCount;
			}
			set
			{
				_lensFlareGhostCount = Mathf.Clamp(value, 0, 5);
			}
		}

		internal float lensFlareGhostDispersal
		{
			get
			{
				return _lensFlareGhostDispersal;
			}
			set
			{
				_lensFlareGhostDispersal = Mathf.Clamp(value, -1f, 1f);
			}
		}

		internal float lensFlareHaloFade
		{
			get
			{
				return _lensFlareHaloFade;
			}
			set
			{
				_lensFlareHaloFade = Mathf.Max(0f, value);
			}
		}

		internal float lensFlareHaloIntensity
		{
			get
			{
				return _lensFlareHaloIntensity;
			}
			set
			{
				_lensFlareHaloIntensity = Mathf.Max(0f, value);
			}
		}

		internal float lensFlareHaloSize
		{
			get
			{
				return _lensFlareHaloSize;
			}
			set
			{
				_lensFlareHaloSize = Mathf.Clamp01(value);
			}
		}

		internal bool allowGlare
		{
			get
			{
				return _allowGlare;
			}
			set
			{
				_allowGlare = value;
			}
		}

		internal float glareBlend
		{
			get
			{
				return _glareBlend;
			}
			set
			{
				_glareBlend = Mathf.Clamp01(value);
			}
		}

		internal float glareIntensity
		{
			get
			{
				return _glareIntensity;
			}
			set
			{
				_glareIntensity = Mathf.Max(0f, value);
			}
		}

		internal float glareAngle
		{
			get
			{
				return _glareAngle;
			}
			set
			{
				_glareAngle = Mathf.Clamp(value, 0f, 360f);
			}
		}

		internal MinMaxRange glareThreshold
		{
			get
			{
				return _glareThreshold;
			}
			set
			{
				_glareThreshold = value;
			}
		}

		internal int glareStreaks
		{
			get
			{
				return _glareStreaks;
			}
			set
			{
				_glareStreaks = Mathf.Clamp(value, 1, 4);
			}
		}

		internal float glareScattering
		{
			get
			{
				return _glareScattering;
			}
			set
			{
				_glareScattering = Mathf.Max(0f, value);
			}
		}

		internal GlareStyle glareStyle
		{
			get
			{
				return _glareStyle;
			}
			set
			{
				_glareStyle = value;
			}
		}

		internal float glareSample0Scattering
		{
			get
			{
				return _glareSample0Scattering;
			}
			set
			{
				_glareSample0Scattering = value;
			}
		}

		internal float glareSample0Angle
		{
			get
			{
				return _glareSample0Angle;
			}
			set
			{
				_glareSample0Angle = value;
			}
		}

		internal float glareSample0Intensity
		{
			get
			{
				return _glareSample0Intensity;
			}
			set
			{
				_glareSample0Intensity = Mathf.Max(0f, value);
			}
		}

		internal float glareSample0Offset
		{
			get
			{
				return _glareSample0Offset;
			}
			set
			{
				_glareSample0Offset = value;
			}
		}

		internal float glareSample1Scattering
		{
			get
			{
				return _glareSample1Scattering;
			}
			set
			{
				_glareSample1Scattering = value;
			}
		}

		internal float glareSample1Angle
		{
			get
			{
				return _glareSample1Angle;
			}
			set
			{
				_glareSample1Angle = value;
			}
		}

		internal float glareSample1Intensity
		{
			get
			{
				return _glareSample1Intensity;
			}
			set
			{
				_glareSample1Intensity = Mathf.Max(0f, value);
			}
		}

		internal float glareSample1Offset
		{
			get
			{
				return _glareSample1Offset;
			}
			set
			{
				_glareSample1Offset = value;
			}
		}

		internal float glareSample2Scattering
		{
			get
			{
				return _glareSample2Scattering;
			}
			set
			{
				_glareSample2Scattering = value;
			}
		}

		internal float glareSample2Angle
		{
			get
			{
				return _glareSample2Angle;
			}
			set
			{
				_glareSample2Angle = value;
			}
		}

		internal float glareSample2Intensity
		{
			get
			{
				return _glareSample2Intensity;
			}
			set
			{
				_glareSample2Intensity = Mathf.Max(0f, value);
			}
		}

		internal float glareSample2Offset
		{
			get
			{
				return _glareSample2Offset;
			}
			set
			{
				_glareSample2Offset = value;
			}
		}

		internal float glareSample3Scattering
		{
			get
			{
				return _glareSample3Scattering;
			}
			set
			{
				_glareSample3Scattering = value;
			}
		}

		internal float glareSample3Angle
		{
			get
			{
				return _glareSample3Angle;
			}
			set
			{
				_glareSample3Angle = value;
			}
		}

		internal float glareSample3Intensity
		{
			get
			{
				return _glareSample3Intensity;
			}
			set
			{
				_glareSample3Intensity = Mathf.Max(0f, value);
			}
		}

		internal float glareSample3Offset
		{
			get
			{
				return _glareSample3Offset;
			}
			set
			{
				_glareSample3Offset = value;
			}
		}

		internal void SetLensFlarePreset(LensFlareStyle lensFlareStyle)
		{
			switch (lensFlareStyle)
			{
			case LensFlareStyle.Average:
				lensFlareGhostFade = 7.5f;
				lensFlareGhostCount = 3;
				lensFlareGhostDispersal = 0.67f;
				lensFlareHaloFade = 7.5f;
				lensFlareHaloSize = 0.5f;
				break;
			case LensFlareStyle.MultiAverage:
				lensFlareGhostFade = 7.5f;
				lensFlareGhostCount = 4;
				lensFlareGhostDispersal = 0.4f;
				lensFlareHaloFade = 7.5f;
				lensFlareHaloSize = 0.5f;
				break;
			case LensFlareStyle.Old:
				lensFlareGhostFade = 7.5f;
				lensFlareGhostCount = 3;
				lensFlareGhostDispersal = -1f;
				lensFlareHaloFade = 7.5f;
				lensFlareHaloSize = 0.5f;
				break;
			case LensFlareStyle.OldFocused:
				lensFlareGhostFade = 7.5f;
				lensFlareGhostCount = 3;
				lensFlareGhostDispersal = -0.75f;
				lensFlareHaloFade = 7.5f;
				lensFlareHaloSize = 0.2f;
				break;
			case LensFlareStyle.Distorted:
				lensFlareGhostFade = 7.5f;
				lensFlareGhostCount = 3;
				lensFlareGhostDispersal = 0.62f;
				lensFlareHaloFade = 7.5f;
				lensFlareHaloSize = 0.56f;
				break;
			}
		}

		internal void SetGlarePreset(GlareStyle glareStyle)
		{
			switch (glareStyle)
			{
			case GlareStyle.Line:
				glareStreaks = 1;
				glareSample0Angle = 90f;
				glareSample0Scattering = 5f;
				glareSample0Offset = 0f;
				glareSample0Intensity = 1f;
				break;
			case GlareStyle.Tri:
				glareStreaks = 3;
				glareSample0Angle = 0f;
				glareSample0Scattering = 2.5f;
				glareSample0Offset = 2.5f;
				glareSample0Intensity = 1f;
				glareSample1Angle = 120f;
				glareSample1Scattering = 2.5f;
				glareSample1Offset = 2.5f;
				glareSample1Intensity = 1f;
				glareSample2Angle = 240f;
				glareSample2Scattering = 2.5f;
				glareSample2Offset = 2.5f;
				glareSample2Intensity = 1f;
				break;
			case GlareStyle.Cross:
				glareStreaks = 2;
				glareSample0Angle = 45f;
				glareSample0Scattering = 5f;
				glareSample0Offset = 0f;
				glareSample0Intensity = 1f;
				glareSample1Angle = 135f;
				glareSample1Scattering = 5f;
				glareSample1Offset = 0f;
				glareSample1Intensity = 1f;
				break;
			default:
				glareStreaks = 2;
				glareSample0Angle = 60f;
				glareSample0Scattering = 5f;
				glareSample0Offset = 0f;
				glareSample0Intensity = 1f;
				glareSample1Angle = 120f;
				glareSample1Scattering = 5f;
				glareSample1Offset = 0f;
				glareSample1Intensity = 1f;
				break;
			case GlareStyle.Star:
				glareStreaks = 3;
				glareSample0Angle = 0f;
				glareSample0Scattering = 5f;
				glareSample0Offset = 0f;
				glareSample0Intensity = 1f;
				glareSample1Angle = 60f;
				glareSample1Scattering = 5f;
				glareSample1Offset = 0f;
				glareSample1Intensity = 1f;
				glareSample2Angle = 120f;
				glareSample2Scattering = 5f;
				glareSample2Offset = 0f;
				glareSample2Intensity = 1f;
				break;
			case GlareStyle.Flake:
				glareStreaks = 4;
				glareSample0Angle = 45f;
				glareSample0Scattering = 5f;
				glareSample0Offset = 0f;
				glareSample0Intensity = 1f;
				glareSample1Angle = 90f;
				glareSample1Scattering = 5f;
				glareSample1Offset = 0f;
				glareSample1Intensity = 1f;
				glareSample2Angle = 135f;
				glareSample2Scattering = 5f;
				glareSample2Offset = 0f;
				glareSample2Intensity = 1f;
				glareSample3Angle = 180f;
				glareSample3Scattering = 5f;
				glareSample3Offset = 0f;
				glareSample3Intensity = 1f;
				break;
			case GlareStyle.Custom:
				break;
			}
		}
	}
}
namespace MK.Glow.Example
{
	public class Asteroid : MonoBehaviour
	{
		[SerializeField]
		private Texture2D[] _emissionTextures = new Texture2D[0];

		private readonly MinMaxRange _minMaxVelocity = new MinMaxRange(-1f, 1f);

		[SerializeField]
		private MinMaxRange _minMaxScale = new MinMaxRange(0.25f, 2f);

		[SerializeField]
		private MinMaxRange _emissionColorIntensity = new MinMaxRange(1.5f, 2f);

		private readonly MinMaxRange _colorChangeTime = new MinMaxRange(2f, 6f);

		private readonly MinMaxRange _colorIntensityChangeTime = new MinMaxRange(2f, 6f);

		private float _nextColorChangeTime;

		private float _nextColorIntensityChangeTime;

		private int _nextColorIndex;

		private float _nextColorIntensity;

		[SerializeField]
		private Color[] _colors = new Color[1];

		private Color _currentColor;

		private float _currentColorIntensity = 1f;

		[SerializeField]
		private Material _baseMaterial;

		private Material _usedMaterial;

		private Rigidbody _rigidBody;

		private int _emissionColorId;

		private int _emissionTextureId;

		private void Awake()
		{
			_emissionColorId = Shader.PropertyToID("_EmissionColor");
			_emissionTextureId = Shader.PropertyToID("_EmissionMap");
			float num = UnityEngine.Random.Range(_minMaxScale.minValue, _minMaxScale.maxValue);
			base.transform.localScale = new Vector3(num, num, num);
			_rigidBody = GetComponent<Rigidbody>();
			_rigidBody.velocity = new Vector3(UnityEngine.Random.Range(_minMaxVelocity.minValue, _minMaxVelocity.maxValue), UnityEngine.Random.Range(_minMaxVelocity.minValue, _minMaxVelocity.maxValue), UnityEngine.Random.Range(_minMaxVelocity.minValue, _minMaxVelocity.maxValue));
			_usedMaterial = new Material(_baseMaterial);
			GetComponent<Renderer>().material = _usedMaterial;
			_nextColorIndex = UnityEngine.Random.Range(0, _colors.Length);
			_currentColor = _colors[_nextColorIndex];
			_currentColorIntensity = UnityEngine.Random.Range(_emissionColorIntensity.minValue, _emissionColorIntensity.maxValue);
			_usedMaterial.SetColor(_emissionColorId, _currentColor * _currentColorIntensity);
			_usedMaterial.SetTexture(_emissionTextureId, _emissionTextures[UnityEngine.Random.Range(0, _emissionTextures.Length - 1)]);
		}

		private void Update()
		{
			if (Time.time > _nextColorChangeTime)
			{
				_nextColorChangeTime += UnityEngine.Random.Range(_colorChangeTime.minValue, _colorChangeTime.maxValue);
				_nextColorIndex++;
				if (_nextColorIndex > _colors.Length - 1)
				{
					_nextColorIndex = 0;
				}
			}
			if (Time.time > _nextColorIntensityChangeTime)
			{
				_nextColorIntensityChangeTime += UnityEngine.Random.Range(_colorIntensityChangeTime.minValue, _colorIntensityChangeTime.maxValue);
				_nextColorIntensity = UnityEngine.Random.Range(_emissionColorIntensity.minValue, _emissionColorIntensity.maxValue);
			}
			_currentColor = Color.Lerp(_currentColor, _colors[_nextColorIndex], Time.smoothDeltaTime);
			_currentColorIntensity = Mathf.Lerp(_currentColorIntensity, _nextColorIntensity, Time.smoothDeltaTime);
			_usedMaterial.SetColor(_emissionColorId, _currentColor * _currentColorIntensity);
		}

		private void OnCollisionEnter(Collision collision)
		{
			ContactPoint contactPoint = collision.contacts[0];
			Vector3 normalized = Vector3.Reflect(_rigidBody.velocity, contactPoint.normal).normalized;
			_rigidBody.velocity = normalized;
		}
	}
	public class AsteroidSpawner : MonoBehaviour
	{
		private static readonly float _spawnTime = 0.125f;

		[SerializeField]
		private GameObject _asteroidObject;

		[SerializeField]
		private int _maxObjects;

		private int _spawnedObjects;

		private float _time;

		private void Update()
		{
			if (_spawnedObjects < _maxObjects)
			{
				if (_time > _spawnTime)
				{
					UnityEngine.Object.Instantiate(_asteroidObject, base.transform.position, Quaternion.identity);
					_spawnedObjects++;
					_time = 0f;
				}
				_time += Time.smoothDeltaTime;
			}
		}
	}
	public class ChangeSettingsLegacy : MonoBehaviour
	{
		private MKGlow _mkGlow;

		public int debugView
		{
			get
			{
				return (int)_mkGlow.debugView;
			}
			set
			{
				_mkGlow.debugView = (DebugView)value;
			}
		}

		public float anamorphicRatio
		{
			get
			{
				return _mkGlow.anamorphicRatio;
			}
			set
			{
				_mkGlow.anamorphicRatio = value;
			}
		}

		public float lumaScale
		{
			get
			{
				return _mkGlow.lumaScale;
			}
			set
			{
				_mkGlow.lumaScale = value;
			}
		}

		public float blooming
		{
			get
			{
				return _mkGlow.blooming;
			}
			set
			{
				_mkGlow.blooming = value;
			}
		}

		public float bloomThreshold
		{
			get
			{
				return _mkGlow.bloomThreshold.minValue;
			}
			set
			{
				_mkGlow.bloomThreshold.minValue = value;
			}
		}

		public float bloomClamp
		{
			get
			{
				return _mkGlow.bloomThreshold.maxValue;
			}
			set
			{
				_mkGlow.bloomThreshold.maxValue = value;
			}
		}

		public float bloomScattering
		{
			get
			{
				return _mkGlow.bloomScattering;
			}
			set
			{
				_mkGlow.bloomScattering = value;
			}
		}

		public float bloomIntensity
		{
			get
			{
				return _mkGlow.bloomIntensity;
			}
			set
			{
				_mkGlow.bloomIntensity = value;
			}
		}

		public bool allowLensSurface
		{
			get
			{
				return _mkGlow.allowLensSurface;
			}
			set
			{
				_mkGlow.allowLensSurface = value;
			}
		}

		public float lensSurfaceDirtIntensity
		{
			get
			{
				return _mkGlow.lensSurfaceDirtIntensity;
			}
			set
			{
				_mkGlow.lensSurfaceDirtIntensity = value;
			}
		}

		public float lensSurfaceDiffractionIntensity
		{
			get
			{
				return _mkGlow.lensSurfaceDiffractionIntensity;
			}
			set
			{
				_mkGlow.lensSurfaceDiffractionIntensity = value;
			}
		}

		public bool allowLensFlare
		{
			get
			{
				return _mkGlow.allowLensFlare;
			}
			set
			{
				_mkGlow.allowLensFlare = value;
			}
		}

		public float lensFlareThreshold
		{
			get
			{
				return _mkGlow.lensFlareThreshold.minValue;
			}
			set
			{
				_mkGlow.lensFlareThreshold.minValue = value;
			}
		}

		public float lensFlareClamp
		{
			get
			{
				return _mkGlow.lensFlareThreshold.maxValue;
			}
			set
			{
				_mkGlow.lensFlareThreshold.maxValue = value;
			}
		}

		public float lensFlareChromaticAberration
		{
			get
			{
				return _mkGlow.lensFlareChromaticAberration;
			}
			set
			{
				_mkGlow.lensFlareChromaticAberration = value;
			}
		}

		public float lensFlareScattering
		{
			get
			{
				return _mkGlow.lensFlareScattering;
			}
			set
			{
				_mkGlow.lensFlareScattering = value;
			}
		}

		public float lensFlareGhostFade
		{
			get
			{
				return _mkGlow.lensFlareGhostFade;
			}
			set
			{
				_mkGlow.lensFlareGhostFade = value;
			}
		}

		public float lensFlareGhostCount
		{
			get
			{
				return _mkGlow.lensFlareGhostCount;
			}
			set
			{
				_mkGlow.lensFlareGhostCount = (int)value;
			}
		}

		public float lensFlareGhostDispersal
		{
			get
			{
				return _mkGlow.lensFlareGhostDispersal;
			}
			set
			{
				_mkGlow.lensFlareGhostDispersal = value;
			}
		}

		public float lensFlareGhostIntensity
		{
			get
			{
				return _mkGlow.lensFlareGhostIntensity;
			}
			set
			{
				_mkGlow.lensFlareGhostIntensity = value;
			}
		}

		public float lensFlareHaloFade
		{
			get
			{
				return _mkGlow.lensFlareHaloFade;
			}
			set
			{
				_mkGlow.lensFlareHaloFade = value;
			}
		}

		public float lensFlareHaloSize
		{
			get
			{
				return _mkGlow.lensFlareHaloSize;
			}
			set
			{
				_mkGlow.lensFlareHaloSize = value;
			}
		}

		public float lensFlareHaloIntensity
		{
			get
			{
				return _mkGlow.lensFlareHaloIntensity;
			}
			set
			{
				_mkGlow.lensFlareHaloIntensity = value;
			}
		}

		public bool allowGlare
		{
			get
			{
				return _mkGlow.allowGlare;
			}
			set
			{
				_mkGlow.allowGlare = value;
			}
		}

		public float glareThreshold
		{
			get
			{
				return _mkGlow.glareThreshold.minValue;
			}
			set
			{
				_mkGlow.glareThreshold.minValue = value;
			}
		}

		public float glareClamp
		{
			get
			{
				return _mkGlow.glareThreshold.maxValue;
			}
			set
			{
				_mkGlow.glareThreshold.maxValue = value;
			}
		}

		public float glareBlend
		{
			get
			{
				return _mkGlow.glareBlend;
			}
			set
			{
				_mkGlow.glareBlend = value;
			}
		}

		public float glareSample0Scattering
		{
			get
			{
				return _mkGlow.glareSample0Scattering;
			}
			set
			{
				_mkGlow.glareSample0Scattering = value;
			}
		}

		public float glareSample0Angle
		{
			get
			{
				return _mkGlow.glareSample0Angle;
			}
			set
			{
				_mkGlow.glareSample0Angle = value;
			}
		}

		public float glareSample0Offset
		{
			get
			{
				return _mkGlow.glareSample0Offset;
			}
			set
			{
				_mkGlow.glareSample0Offset = value;
			}
		}

		public float glareSample0Intensity
		{
			get
			{
				return _mkGlow.glareSample0Intensity;
			}
			set
			{
				_mkGlow.glareSample0Intensity = value;
			}
		}

		public float glareSample1Scattering
		{
			get
			{
				return _mkGlow.glareSample1Scattering;
			}
			set
			{
				_mkGlow.glareSample1Scattering = value;
			}
		}

		public float glareSample1Angle
		{
			get
			{
				return _mkGlow.glareSample1Angle;
			}
			set
			{
				_mkGlow.glareSample1Angle = value;
			}
		}

		public float glareSample1Offset
		{
			get
			{
				return _mkGlow.glareSample1Offset;
			}
			set
			{
				_mkGlow.glareSample1Offset = value;
			}
		}

		public float glareSample1Intensity
		{
			get
			{
				return _mkGlow.glareSample1Intensity;
			}
			set
			{
				_mkGlow.glareSample1Intensity = value;
			}
		}

		public float glareSample2Scattering
		{
			get
			{
				return _mkGlow.glareSample2Scattering;
			}
			set
			{
				_mkGlow.glareSample2Scattering = value;
			}
		}

		public float glareSample2Angle
		{
			get
			{
				return _mkGlow.glareSample2Angle;
			}
			set
			{
				_mkGlow.glareSample2Angle = value;
			}
		}

		public float glareSample2Offset
		{
			get
			{
				return _mkGlow.glareSample2Offset;
			}
			set
			{
				_mkGlow.glareSample2Offset = value;
			}
		}

		public float glareSample2Intensity
		{
			get
			{
				return _mkGlow.glareSample2Intensity;
			}
			set
			{
				_mkGlow.glareSample2Intensity = value;
			}
		}

		public float glareSample3Scattering
		{
			get
			{
				return _mkGlow.glareSample3Scattering;
			}
			set
			{
				_mkGlow.glareSample3Scattering = value;
			}
		}

		public float glareSample3Angle
		{
			get
			{
				return _mkGlow.glareSample3Angle;
			}
			set
			{
				_mkGlow.glareSample3Angle = value;
			}
		}

		public float glareSample3Offset
		{
			get
			{
				return _mkGlow.glareSample3Offset;
			}
			set
			{
				_mkGlow.glareSample3Offset = value;
			}
		}

		public float glareSample3Intensity
		{
			get
			{
				return _mkGlow.glareSample3Intensity;
			}
			set
			{
				_mkGlow.glareSample3Intensity = value;
			}
		}

		private void Awake()
		{
			_mkGlow = GetComponent<MKGlow>();
		}
	}
	public class Cube : MonoBehaviour
	{
		private readonly MinMaxRange _minMaxSpeed = new MinMaxRange(0.05f, 0.5f);

		[SerializeField]
		private MinMaxRange _emissionColorIntensity = new MinMaxRange(1f, 1.5f);

		private readonly MinMaxRange _colorChangeTime = new MinMaxRange(2f, 6f);

		private readonly MinMaxRange _colorIntensityChangeTime = new MinMaxRange(2f, 6f);

		private MinMaxRange _directionSwitchTime = new MinMaxRange(2f, 6f);

		private float _nextColorChangeTime;

		private float _nextColorIntensityChangeTime;

		private int _nextColorIndex;

		private float _nextColorIntensity;

		private float _nextDirectionChangeTime;

		private float _currentSpeed;

		[SerializeField]
		private Color[] _colors = new Color[1];

		private Color _currentColor;

		private float _currentColorIntensity = 1f;

		private Material _baseMaterial;

		private Material _usedMaterial;

		private int _emissionColorId;

		private int _colorId;

		private Vector3 _startPos;

		[SerializeField]
		private Vector3 _endPos = Vector3.zero;

		private bool _forward = true;

		private Vector3 _forwardDirection;

		private Vector3 _targetPosition
		{
			get
			{
				if (_forward)
				{
					return _endPos;
				}
				return _startPos;
			}
		}

		private void Awake()
		{
			_emissionColorId = Shader.PropertyToID("_EmissionColor");
			_colorId = Shader.PropertyToID("_Color");
			_forward = true;
			_startPos = base.transform.position;
			_baseMaterial = new Material(GetComponent<Renderer>().material);
			_usedMaterial = new Material(_baseMaterial);
			GetComponent<Renderer>().material = _usedMaterial;
			_nextColorIndex = UnityEngine.Random.Range(0, _colors.Length);
			_currentColor = _colors[_nextColorIndex];
			_currentColorIntensity = UnityEngine.Random.Range(_emissionColorIntensity.minValue, _emissionColorIntensity.maxValue);
			_usedMaterial.SetColor(_emissionColorId, _currentColor * _currentColorIntensity);
			_usedMaterial.SetColor(_colorId, _currentColor * 0.5f);
			_forwardDirection = (_endPos - _startPos).normalized;
			_currentSpeed = UnityEngine.Random.Range(_minMaxSpeed.minValue, _minMaxSpeed.maxValue);
		}

		private void Update()
		{
			if (Time.time > _nextDirectionChangeTime)
			{
				_forward = !_forward;
				_nextDirectionChangeTime += UnityEngine.Random.Range(_directionSwitchTime.minValue, _directionSwitchTime.maxValue);
				_currentSpeed = UnityEngine.Random.Range(_minMaxSpeed.minValue, _minMaxSpeed.maxValue);
			}
			else if (Vector3.Distance(_targetPosition, base.transform.position) < 0.1f)
			{
				_forward = !_forward;
				_nextDirectionChangeTime += UnityEngine.Random.Range(_directionSwitchTime.minValue, _directionSwitchTime.maxValue);
				_currentSpeed = UnityEngine.Random.Range(_minMaxSpeed.minValue, _minMaxSpeed.maxValue);
			}
			if (_forward)
			{
				base.transform.position += _forwardDirection * Time.smoothDeltaTime;
				base.transform.position = Vector3.Lerp(base.transform.position, _targetPosition, Time.smoothDeltaTime * _currentSpeed);
			}
			else
			{
				base.transform.position -= _forwardDirection * Time.smoothDeltaTime;
				base.transform.position = Vector3.Lerp(base.transform.position, _targetPosition, Time.smoothDeltaTime * _currentSpeed);
			}
			if (Time.time > _nextColorChangeTime)
			{
				_nextColorChangeTime += UnityEngine.Random.Range(_colorChangeTime.minValue, _colorChangeTime.maxValue);
				_nextColorIndex++;
				if (_nextColorIndex > _colors.Length - 1)
				{
					_nextColorIndex = 0;
				}
			}
			if (Time.time > _nextColorIntensityChangeTime)
			{
				_nextColorIntensityChangeTime += UnityEngine.Random.Range(_colorIntensityChangeTime.minValue, _colorIntensityChangeTime.maxValue);
				_nextColorIntensity = UnityEngine.Random.Range(_emissionColorIntensity.minValue, _emissionColorIntensity.maxValue);
			}
			_currentColor = Color.Lerp(_currentColor, _colors[_nextColorIndex], Time.smoothDeltaTime);
			_currentColorIntensity = Mathf.Lerp(_currentColorIntensity, _nextColorIntensity, Time.smoothDeltaTime);
			_usedMaterial.SetColor(_emissionColorId, _currentColor * _currentColorIntensity);
			_usedMaterial.SetColor(_colorId, _currentColor * 0.5f);
		}
	}
	public class DestroyOpenMenuText : MonoBehaviour
	{
		[SerializeField]
		private Text _text;

		[SerializeField]
		private Outline _outline;

		private float _blinkSpeed = 2f;

		private float _alpha = 1f;

		private Color _textColor = Color.white;

		private Color _outlineColor = new Color(0f, 0f, 0f, 1f);

		private bool _forward;

		private void Update()
		{
			if (_forward)
			{
				_alpha += Time.smoothDeltaTime * _blinkSpeed;
				if (_alpha >= 1f)
				{
					_forward = !_forward;
				}
			}
			else
			{
				_alpha -= Time.smoothDeltaTime * _blinkSpeed;
				if (_alpha <= 0f)
				{
					_forward = !_forward;
				}
			}
			_textColor.a = _alpha;
			_outlineColor.a = _alpha;
			_text.color = _textColor;
			_outline.effectColor = _outlineColor;
			if (Input.GetKeyDown(KeyCode.Space) || Time.time > 10f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class HandleMenu : MonoBehaviour
	{
		[SerializeField]
		private GameObject _canvas;

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space) && UnityEngine.Application.isPlaying)
			{
				_canvas.SetActive(!_canvas.activeSelf);
			}
		}
	}
	public class MoveCamera : MonoBehaviour
	{
		[SerializeField]
		private float _distance = 20f;

		[SerializeField]
		private float _horizontalSpeed = 10f;

		[SerializeField]
		private float _verticalSpeed = 5f;

		[SerializeField]
		private Transform _centerTransform;

		private void Update()
		{
			base.transform.position = _centerTransform.position + new Vector3(Mathf.Sin(Time.time * ((float)Math.PI / 180f) * _horizontalSpeed), Mathf.Sin(Time.time * ((float)Math.PI / 180f) * _verticalSpeed), Mathf.Cos(Time.time * ((float)Math.PI / 180f) * _horizontalSpeed)) * Mathf.Abs(Mathf.Sin(Time.time * 0.125f)) * _distance;
			base.transform.LookAt(_centerTransform);
		}
	}
	public class RotateObject : MonoBehaviour
	{
		[SerializeField]
		private Vector3 _rotation = Vector3.zero;

		private readonly float _heightMovement = 0.125f;

		private readonly float _heightMovementSpeed = 1f;

		private Vector3 _startPosition;

		private void Awake()
		{
			_startPosition = base.transform.position;
		}

		private void Update()
		{
			base.transform.Rotate(_rotation * Time.smoothDeltaTime);
			base.transform.position = _startPosition + Vector3.up * _heightMovement * Mathf.Sin(Time.time * _heightMovementSpeed);
		}
	}
	public class SpectateObjects : MonoBehaviour
	{
		[SerializeField]
		private GameObject[] _gameObjects = new GameObject[1];

		private int _currentObject;

		public void SwitchObject()
		{
			_gameObjects[_currentObject++].SetActive(value: false);
			if (_currentObject > _gameObjects.Length - 1)
			{
				_currentObject = 0;
			}
			_gameObjects[_currentObject].SetActive(value: true);
		}
	}
}
namespace MK.Glow.Legacy
{
	internal class CameraDataLegacy : CameraData
	{
		public static implicit operator CameraDataLegacy(Camera input)
		{
			return new CameraDataLegacy
			{
				width = input.pixelWidth,
				height = input.pixelHeight,
				stereoEnabled = input.stereoEnabled,
				aspect = input.aspect,
				worldToCameraMatrix = input.worldToCameraMatrix
			};
		}
	}
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[ImageEffectAllowedInSceneView]
	[RequireComponent(typeof(Camera))]
	public class MKGlow : MonoBehaviour
	{
		public bool allowGeometryShaders;

		public bool allowComputeShaders;

		public RenderPriority renderPriority = RenderPriority.Balanced;

		public DebugView debugView;

		public Quality quality = Quality.High;

		public Workflow workflow;

		public LayerMask selectiveRenderLayerMask = -1;

		[Range(-1f, 1f)]
		public float anamorphicRatio;

		[Range(0f, 1f)]
		public float lumaScale = 0.5f;

		[Range(0f, 1f)]
		public float blooming;

		[MinMaxRange(0f, 10f)]
		public MinMaxRange bloomThreshold = new MinMaxRange(1.25f, 10f);

		[Range(1f, 10f)]
		public float bloomScattering = 7f;

		public float bloomIntensity = 1f;

		public bool allowLensSurface;

		public Texture2D lensSurfaceDirtTexture;

		public float lensSurfaceDirtIntensity = 2.5f;

		public Texture2D lensSurfaceDiffractionTexture;

		public float lensSurfaceDiffractionIntensity = 2f;

		public bool allowLensFlare;

		public LensFlareStyle lensFlareStyle = LensFlareStyle.Average;

		[Range(0f, 25f)]
		public float lensFlareGhostFade = 10f;

		public float lensFlareGhostIntensity = 1f;

		[MinMaxRange(0f, 10f)]
		public MinMaxRange lensFlareThreshold = new MinMaxRange(1.3f, 10f);

		[Range(0f, 8f)]
		public float lensFlareScattering = 5f;

		public Texture2D lensFlareColorRamp;

		[Range(-100f, 100f)]
		public float lensFlareChromaticAberration = 53f;

		[Range(1f, 4f)]
		public int lensFlareGhostCount = 3;

		[Range(-1f, 1f)]
		public float lensFlareGhostDispersal = 0.6f;

		[Range(0f, 25f)]
		public float lensFlareHaloFade = 2f;

		public float lensFlareHaloIntensity = 1f;

		[Range(0f, 1f)]
		public float lensFlareHaloSize = 0.4f;

		public bool allowGlare;

		[Range(0f, 1f)]
		public float glareBlend = 0.33f;

		public float glareIntensity = 1f;

		[Range(0f, 360f)]
		public float glareAngle;

		[MinMaxRange(0f, 10f)]
		public MinMaxRange glareThreshold = new MinMaxRange(1.25f, 10f);

		[Range(1f, 4f)]
		public int glareStreaks = 4;

		public GlareStyle glareStyle = GlareStyle.DistortedCross;

		[Range(0f, 4f)]
		public float glareScattering = 2f;

		[Range(0f, 10f)]
		public float glareSample0Scattering = 5f;

		[Range(0f, 360f)]
		public float glareSample0Angle;

		public float glareSample0Intensity = 1f;

		[Range(-5f, 5f)]
		public float glareSample0Offset;

		[Range(0f, 10f)]
		public float glareSample1Scattering = 5f;

		[Range(0f, 360f)]
		public float glareSample1Angle = 45f;

		public float glareSample1Intensity = 1f;

		[Range(-5f, 5f)]
		public float glareSample1Offset;

		[Range(0f, 10f)]
		public float glareSample2Scattering = 5f;

		[Range(0f, 360f)]
		public float glareSample2Angle = 90f;

		public float glareSample2Intensity = 1f;

		[Range(-5f, 5f)]
		public float glareSample2Offset;

		[Range(0f, 10f)]
		public float glareSample3Scattering = 5f;

		[Range(0f, 360f)]
		public float glareSample3Angle = 135f;

		public float glareSample3Intensity = 1f;

		[Range(-5f, 5f)]
		public float glareSample3Offset;

		private Effect _effect;

		private RenderTarget _source;

		private RenderTarget _destination;

		private Camera renderingCamera => GetComponent<Camera>();

		[ContextMenu("Load Preset For Mobile")]
		private void LoadMobilePreset()
		{
			bloomScattering = 5f;
			renderPriority = RenderPriority.Performance;
			quality = Quality.Low;
			allowGlare = false;
			allowLensFlare = false;
			lensFlareScattering = 5f;
			allowLensSurface = false;
		}

		[ContextMenu("Load Preset For Quality")]
		private void LoadQualityPreset()
		{
			bloomScattering = 7f;
			renderPriority = RenderPriority.Quality;
			quality = Quality.High;
			allowGlare = false;
			allowLensFlare = false;
			lensFlareScattering = 6f;
			allowLensSurface = false;
		}

		public void OnEnable()
		{
			_effect = new Effect();
			_effect.Enable(RenderPipeline.Legacy);
			base.enabled = Compatibility.IsSupported;
		}

		public void OnDisable()
		{
			_effect.Disable();
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (workflow == Workflow.Selective && ((bool)GraphicsSettings.renderPipelineAsset || PipelineProperties.xrEnabled))
			{
				Graphics.Blit(source, destination);
				return;
			}
			_source.renderTexture = source;
			_destination.renderTexture = destination;
			SettingsLegacy settings = this;
			CameraDataLegacy cameraData = renderingCamera;
			_effect.Build(_source, _destination, settings, null, cameraData, renderingCamera);
			Graphics.Blit(source, destination, _effect.renderMaterialNoGeometry, _effect.currentRenderIndex);
			_effect.AfterCompositeCleanup();
		}
	}
	internal sealed class SettingsLegacy : Settings
	{
		public static implicit operator SettingsLegacy(MKGlow input)
		{
			SettingsLegacy settingsLegacy = new SettingsLegacy();
			settingsLegacy.allowComputeShaders = input.allowComputeShaders;
			settingsLegacy.allowGeometryShaders = input.allowGeometryShaders;
			settingsLegacy.renderPriority = input.renderPriority;
			settingsLegacy.debugView = input.debugView;
			settingsLegacy.quality = input.quality;
			settingsLegacy.workflow = input.workflow;
			settingsLegacy.selectiveRenderLayerMask = input.selectiveRenderLayerMask;
			settingsLegacy.anamorphicRatio = input.anamorphicRatio;
			settingsLegacy.lumaScale = input.lumaScale;
			settingsLegacy.bloomThreshold = input.bloomThreshold;
			settingsLegacy.bloomScattering = input.bloomScattering;
			settingsLegacy.bloomIntensity = input.bloomIntensity;
			settingsLegacy.blooming = input.blooming;
			settingsLegacy.allowLensSurface = input.allowLensSurface;
			settingsLegacy.lensSurfaceDirtTexture = input.lensSurfaceDirtTexture;
			settingsLegacy.lensSurfaceDirtIntensity = input.lensSurfaceDirtIntensity;
			settingsLegacy.lensSurfaceDiffractionTexture = input.lensSurfaceDiffractionTexture;
			settingsLegacy.lensSurfaceDiffractionIntensity = input.lensSurfaceDiffractionIntensity;
			settingsLegacy.allowLensFlare = input.allowLensFlare;
			settingsLegacy.lensFlareStyle = input.lensFlareStyle;
			settingsLegacy.lensFlareGhostFade = input.lensFlareGhostFade;
			settingsLegacy.lensFlareGhostIntensity = input.lensFlareGhostIntensity;
			settingsLegacy.lensFlareThreshold = input.lensFlareThreshold;
			settingsLegacy.lensFlareScattering = input.lensFlareScattering;
			settingsLegacy.lensFlareColorRamp = input.lensFlareColorRamp;
			settingsLegacy.lensFlareChromaticAberration = input.lensFlareChromaticAberration;
			settingsLegacy.lensFlareGhostCount = input.lensFlareGhostCount;
			settingsLegacy.lensFlareGhostDispersal = input.lensFlareGhostDispersal;
			settingsLegacy.lensFlareHaloFade = input.lensFlareHaloFade;
			settingsLegacy.lensFlareHaloIntensity = input.lensFlareHaloIntensity;
			settingsLegacy.lensFlareHaloSize = input.lensFlareHaloSize;
			settingsLegacy.SetLensFlarePreset(input.lensFlareStyle);
			settingsLegacy.allowGlare = input.allowGlare;
			settingsLegacy.glareBlend = input.glareBlend;
			settingsLegacy.glareIntensity = input.glareIntensity;
			settingsLegacy.glareThreshold = input.glareThreshold;
			settingsLegacy.glareStreaks = input.glareStreaks;
			settingsLegacy.glareScattering = input.glareScattering;
			settingsLegacy.glareStyle = input.glareStyle;
			settingsLegacy.glareAngle = input.glareAngle;
			settingsLegacy.glareSample0Scattering = input.glareSample0Scattering;
			settingsLegacy.glareSample0Angle = input.glareSample0Angle;
			settingsLegacy.glareSample0Intensity = input.glareSample0Intensity;
			settingsLegacy.glareSample0Offset = input.glareSample0Offset;
			settingsLegacy.glareSample1Scattering = input.glareSample1Scattering;
			settingsLegacy.glareSample1Angle = input.glareSample1Angle;
			settingsLegacy.glareSample1Intensity = input.glareSample1Intensity;
			settingsLegacy.glareSample1Offset = input.glareSample1Offset;
			settingsLegacy.glareSample2Scattering = input.glareSample2Scattering;
			settingsLegacy.glareSample2Angle = input.glareSample2Angle;
			settingsLegacy.glareSample2Intensity = input.glareSample2Intensity;
			settingsLegacy.glareSample2Offset = input.glareSample2Offset;
			settingsLegacy.glareSample3Scattering = input.glareSample3Scattering;
			settingsLegacy.glareSample3Angle = input.glareSample3Angle;
			settingsLegacy.glareSample3Intensity = input.glareSample3Intensity;
			settingsLegacy.glareSample3Offset = input.glareSample3Offset;
			settingsLegacy.SetGlarePreset(input.glareStyle);
			return settingsLegacy;
		}
	}
}
namespace VortexStudios.PostProcessing
{
	[Serializable]
	public class ChromaticAberrationProfile : PostProcessingProfile
	{
		[SerializeField]
		public Texture pattern;

		[SerializeField]
		public float magnetude = 0.2f;

		public override void OnEnable()
		{
			if (pattern == null)
			{
				pattern = base.material.GetTexture("_MaskTex");
			}
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			if (base.material != null && pattern != null && magnetude > 0f)
			{
				base.material.SetTexture("_MaskTex", pattern);
				base.material.SetFloat("_Magnitude", magnetude * magnetude);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material, 0);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	[Serializable]
	public class CompositeProfile : PostProcessingProfile
	{
		[SerializeField]
		private Material _materialBleeding;

		private bool _polarity;

		private float[] _polarityPositive = new float[3] { -1f, 2f, -1f };

		private float[] _polarityNegative = new float[3] { 1f, -2f, 1f };

		private Texture2D _bleedingTexture;

		[SerializeField]
		public int lineCount = 224;

		[SerializeField]
		public float distortion = 0.5f;

		[SerializeField]
		public float artifact = 0.2f;

		[SerializeField]
		public float fringing = 0.7f;

		[SerializeField]
		public float bleeding = 1f;

		private float t;

		public Material materialBleeding
		{
			get
			{
				if (_materialBleeding == null)
				{
					Shader shader = Shader.Find("Vortex Game Studios/Filters/OLD TV Filter/Bleeding");
					if (shader != null)
					{
						_materialBleeding = new Material(shader);
					}
				}
				return _materialBleeding;
			}
		}

		public override void OnEnable()
		{
		}

		public override void OnFixedUpdate()
		{
			t += Time.unscaledDeltaTime;
			if (t >= 0.25f)
			{
				t -= 0.25f;
				_polarity = !_polarity;
			}
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			float num = (float)lineCount / (float)source.height;
			Vector2 vector = new Vector2(1f / ((float)source.width * num), 1f / ((float)source.height * num));
			if (base.material != null && (fringing > 0f || artifact > 0f))
			{
				base.material.SetFloat("_ScreenWidth", vector.x);
				base.material.SetFloat("_ScreenHeight", vector.y);
				base.material.SetFloat("_Distortion", distortion);
				base.material.SetFloat("_Fringing", fringing);
				base.material.SetFloat("_Artifact", artifact);
				base.material.SetFloatArray("_Kernel", _polarity ? _polarityPositive : _polarityNegative);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material);
				PostProcessingProfile.SWAPBUFFER();
			}
			if (materialBleeding != null && bleeding > 0f)
			{
				materialBleeding.SetFloat("_ScreenWidth", vector.x);
				materialBleeding.SetFloat("_ScreenHeight", vector.y);
				materialBleeding.SetFloat("_Magnitude", bleeding);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, materialBleeding);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	[Serializable]
	public class NoiseProfile : PostProcessingProfile
	{
		[SerializeField]
		public Texture pattern;

		[SerializeField]
		public float magnetude = 0.25f;

		[SerializeField]
		public Vector2 scale = Vector2.one;

		private Vector2 _offset = Vector2.zero;

		public override void OnEnable()
		{
			if (pattern == null)
			{
				pattern = base.material.GetTexture("_PatternTex");
			}
		}

		public override void OnFixedUpdate()
		{
			_offset.x = _offset.y;
			_offset.y = UnityEngine.Random.Range(-1f, 1f);
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			if (base.material != null && pattern != null && magnetude != 0f)
			{
				base.material.SetTexture("_PatternTex", pattern);
				base.material.SetFloat("_PatternOffsetX", _offset.x);
				base.material.SetFloat("_PatternOffsetY", _offset.y);
				base.material.SetFloat("_PatternScaleX", scale.x);
				base.material.SetFloat("_PatternScaleY", scale.y);
				base.material.SetFloat("_Magnitude", magnetude);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	public class OLDTVPreset : ScriptableObject
	{
		[SerializeField]
		private NoiseProfile _noiseFilter = new NoiseProfile();

		[SerializeField]
		private CompositeProfile _compositeFilter = new CompositeProfile();

		[SerializeField]
		private StaticProfile _staticFilter = new StaticProfile();

		[SerializeField]
		private TelevisionProfile _televisionFilter = new TelevisionProfile();

		[SerializeField]
		private ChromaticAberrationProfile _chromaticAberrationFilter = new ChromaticAberrationProfile();

		[SerializeField]
		private ScanlineProfile _scanlineFilter = new ScanlineProfile();

		[SerializeField]
		private TubeProfile _tubeFilter = new TubeProfile();

		public NoiseProfile noiseFilter => _noiseFilter;

		public CompositeProfile compositeFilter => _compositeFilter;

		public StaticProfile staticFilter => _staticFilter;

		public TelevisionProfile televisionFilter => _televisionFilter;

		public ChromaticAberrationProfile chromaticAberrationFilter => _chromaticAberrationFilter;

		public ScanlineProfile scanlineFilter => _scanlineFilter;

		public TubeProfile tubeFilter => _tubeFilter;

		private void OnEnable()
		{
			_noiseFilter.OnEnable();
			_compositeFilter.OnEnable();
			_staticFilter.OnEnable();
			_televisionFilter.OnEnable();
			_chromaticAberrationFilter.OnEnable();
			_scanlineFilter.OnEnable();
			_tubeFilter.OnEnable();
		}
	}
	[Serializable]
	public class PostProcessingProfile
	{
		protected RenderBuffer _BUFFER;

		private static bool _CURRENTBUFFER = false;

		private static RenderTexture[] _TEMPBUFFER = new RenderTexture[2];

		[SerializeField]
		private bool _foldout;

		[SerializeField]
		protected Material _material;

		[SerializeField]
		protected bool _enabled = true;

		public static RenderTexture SOURCEBUFFER
		{
			get
			{
				return _TEMPBUFFER[(!_CURRENTBUFFER) ? 1u : 0u];
			}
			set
			{
				_TEMPBUFFER[(!_CURRENTBUFFER) ? 1u : 0u] = value;
			}
		}

		public static RenderTexture DESTBUFFER
		{
			get
			{
				return _TEMPBUFFER[_CURRENTBUFFER ? 1 : 0];
			}
			set
			{
				_TEMPBUFFER[_CURRENTBUFFER ? 1 : 0] = value;
			}
		}

		public Material material
		{
			get
			{
				if (_material == null)
				{
					Shader shader = Shader.Find("Vortex Game Studios/Filters/OLD TV Filter/" + GetType().Name.Replace("Profile", ""));
					if (shader != null)
					{
						_material = new Material(shader);
					}
				}
				if (_enabled && !_material.shader.isSupported)
				{
					enabled = false;
				}
				return _material;
			}
		}

		public bool enabled
		{
			get
			{
				return _enabled;
			}
			set
			{
				_enabled = value;
				if (value)
				{
					OnValidate();
				}
			}
		}

		public static void SWAPBUFFER()
		{
			_CURRENTBUFFER = !_CURRENTBUFFER;
		}

		public PostProcessingProfile()
		{
			_foldout = false;
		}

		public virtual void OnFixedUpdate()
		{
		}

		public virtual void OnEnable()
		{
		}

		public virtual void OnValidate()
		{
		}

		public virtual void OnReset()
		{
		}

		public virtual RenderTexture OnRenderImage(RenderTexture source)
		{
			return source;
		}
	}
	[Serializable]
	public class ScanlineProfile : PostProcessingProfile
	{
		[SerializeField]
		public Texture pattern;

		[SerializeField]
		public int lineCount = 224;

		[SerializeField]
		public float magnetude = 0.75f;

		public override void OnEnable()
		{
			if (pattern == null)
			{
				pattern = base.material.GetTexture("_PatternTex");
			}
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			if (base.material != null && pattern != null && magnetude != 0f)
			{
				base.material.SetInt("_ScreenWidth", (int)((float)source.width * ((float)lineCount / (float)source.height)));
				base.material.SetInt("_ScreenHeight", lineCount);
				base.material.SetTexture("_PatternTex", pattern);
				base.material.SetFloat("_Magnitude", 1f - magnetude);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	[Serializable]
	public class StaticProfile : PostProcessingProfile
	{
		[SerializeField]
		public Texture staticPattern;

		[SerializeField]
		public float staticMagnitude = 0.1f;

		[SerializeField]
		public float staticScale = 1f;

		[SerializeField]
		public float staticOffset;

		[SerializeField]
		public Texture dirtPattern;

		[SerializeField]
		public float dirtMagnitude = 0.35f;

		private Vector2 _offset = Vector2.zero;

		public override void OnEnable()
		{
			if (staticPattern == null)
			{
				staticPattern = base.material.GetTexture("_StaticTex");
			}
			if (dirtPattern == null)
			{
				dirtPattern = base.material.GetTexture("_DirtTex");
			}
		}

		public override void OnFixedUpdate()
		{
			_offset.x = UnityEngine.Random.Range(0f, 1f);
			_offset.y = 0f;
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			if (base.material != null && ((staticPattern != null && staticMagnitude != 0f) || (dirtPattern != null && (double)dirtMagnitude != 0.0)))
			{
				base.material.SetTexture("_StaticTex", staticPattern);
				base.material.SetFloat("_PatternOffsetX", _offset.x);
				base.material.SetFloat("_PatternOffsetY", staticOffset);
				base.material.SetFloat("_PatternScaleY", staticScale);
				base.material.SetFloat("_StaticMagnitude", staticMagnitude);
				base.material.SetTexture("_DirtTex", dirtPattern);
				base.material.SetFloat("_DirtMagnitude", dirtMagnitude);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	[Serializable]
	public class TelevisionProfile : PostProcessingProfile
	{
		[SerializeField]
		public int lineCount = 224;

		[SerializeField]
		public Vector2 sync = new Vector2(0f, 0f);

		private Vector2 _sync = new Vector2(0f, 0f);

		[SerializeField]
		public float brightness;

		[SerializeField]
		public float contrast;

		[SerializeField]
		public float saturation = 0.5f;

		[SerializeField]
		public float sharpness = -1f;

		public override void OnEnable()
		{
		}

		public override void OnFixedUpdate()
		{
			_sync += sync * Time.fixedUnscaledDeltaTime;
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			float num = (float)lineCount / (float)source.height;
			if (base.material != null && (brightness != 0f || contrast != 0f || saturation != 0f || sharpness != 0f))
			{
				base.material.SetFloat("_ScreenWidth", 1f / ((float)source.width * num));
				base.material.SetFloat("_ScreenHeight", 1f / ((float)source.height * num));
				base.material.SetVector("_Sync", sync);
				base.material.SetFloat("_Brightness", brightness);
				base.material.SetFloat("_Contrast", 1.016f * (contrast + 1f) / (1.016f * (1.016f - contrast)));
				base.material.SetFloat("_Saturation", saturation * 2f);
				base.material.SetFloat("_Sharpness", sharpness);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
	[Serializable]
	public class TubeProfile : PostProcessingProfile
	{
		[SerializeField]
		public Texture maskPattern;

		[SerializeField]
		public Texture reflexPattern;

		[SerializeField]
		public float distortionMagnitude = 0.15f;

		[SerializeField]
		public float reflexMagnitude = 0.15f;

		public override void OnEnable()
		{
			if (maskPattern == null)
			{
				maskPattern = base.material.GetTexture("_MaskTex");
			}
		}

		public override RenderTexture OnRenderImage(RenderTexture source)
		{
			base.OnRenderImage(source);
			if (base.material != null && (maskPattern != null || distortionMagnitude != 0f || (reflexPattern != null && distortionMagnitude > 0f)))
			{
				base.material.SetTexture("_MaskTex", maskPattern);
				base.material.SetTexture("_ReflexTex", reflexPattern);
				base.material.SetFloat("_Distortion", distortionMagnitude);
				base.material.SetFloat("_Reflex", reflexMagnitude);
				Graphics.Blit(PostProcessingProfile.SOURCEBUFFER, PostProcessingProfile.DESTBUFFER, base.material, 0);
				PostProcessingProfile.SWAPBUFFER();
			}
			return null;
		}
	}
}
namespace UnityStandardAssets.CrossPlatformInput
{
	public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public string axisName = "Horizontal";

		public float axisValue = 1f;

		public float responseSpeed = 3f;

		public float returnToCentreSpeed = 3f;

		private AxisTouchButton m_PairedWith;

		private CrossPlatformInputManager.VirtualAxis m_Axis;

		private void OnEnable()
		{
			if (!CrossPlatformInputManager.AxisExists(axisName))
			{
				m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
			}
			else
			{
				m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
			}
			FindPairedButton();
		}

		private void FindPairedButton()
		{
			if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
			{
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].axisName == axisName && array[i] != this)
				{
					m_PairedWith = array[i];
				}
			}
		}

		private void OnDisable()
		{
			m_Axis.Remove();
		}

		public void OnPointerDown(PointerEventData data)
		{
			if (m_PairedWith == null)
			{
				FindPairedButton();
			}
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
		}
	}
	public class ButtonHandler : MonoBehaviour
	{
		public string Name;

		private void OnEnable()
		{
		}

		public void SetDownState()
		{
			CrossPlatformInputManager.SetButtonDown(Name);
		}

		public void SetUpState()
		{
			CrossPlatformInputManager.SetButtonUp(Name);
		}

		public void SetAxisPositiveState()
		{
			CrossPlatformInputManager.SetAxisPositive(Name);
		}

		public void SetAxisNeutralState()
		{
			CrossPlatformInputManager.SetAxisZero(Name);
		}

		public void SetAxisNegativeState()
		{
			CrossPlatformInputManager.SetAxisNegative(Name);
		}

		public void Update()
		{
		}
	}
	public static class CrossPlatformInputManager
	{
		public enum ActiveInputMethod
		{
			Hardware,
			Touch
		}

		public class VirtualAxis
		{
			private float m_Value;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public float GetValue => m_Value;

			public float GetValueRaw => m_Value;

			public VirtualAxis(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualAxis(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Remove()
			{
				UnRegisterVirtualAxis(name);
			}

			public void Update(float value)
			{
				m_Value = value;
			}
		}

		public class VirtualButton
		{
			private int m_LastPressedFrame = -5;

			private int m_ReleasedFrame = -5;

			private bool m_Pressed;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public bool GetButton => m_Pressed;

			public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

			public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

			public VirtualButton(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualButton(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Pressed()
			{
				if (!m_Pressed)
				{
					m_Pressed = true;
					m_LastPressedFrame = Time.frameCount;
				}
			}

			public void Released()
			{
				m_Pressed = false;
				m_ReleasedFrame = Time.frameCount;
			}

			public void Remove()
			{
				UnRegisterVirtualButton(name);
			}
		}

		private static VirtualInput activeInput;

		private static VirtualInput s_TouchInput;

		private static VirtualInput s_HardwareInput;

		public static Vector3 mousePosition => activeInput.MousePosition();

		static CrossPlatformInputManager()
		{
			s_TouchInput = new MobileInput();
			s_HardwareInput = new StandaloneInput();
			activeInput = s_TouchInput;
		}

		public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
		{
			switch (activeInputMethod)
			{
			case ActiveInputMethod.Hardware:
				activeInput = s_HardwareInput;
				break;
			case ActiveInputMethod.Touch:
				activeInput = s_TouchInput;
				break;
			}
		}

		public static bool AxisExists(string name)
		{
			return activeInput.AxisExists(name);
		}

		public static bool ButtonExists(string name)
		{
			return activeInput.ButtonExists(name);
		}

		public static void RegisterVirtualAxis(VirtualAxis axis)
		{
			activeInput.RegisterVirtualAxis(axis);
		}

		public static void RegisterVirtualButton(VirtualButton button)
		{
			activeInput.RegisterVirtualButton(button);
		}

		public static void UnRegisterVirtualAxis(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			activeInput.UnRegisterVirtualAxis(name);
		}

		public static void UnRegisterVirtualButton(string name)
		{
			activeInput.UnRegisterVirtualButton(name);
		}

		public static VirtualAxis VirtualAxisReference(string name)
		{
			return activeInput.VirtualAxisReference(name);
		}

		public static float GetAxis(string name)
		{
			return GetAxis(name, raw: false);
		}

		public static float GetAxisRaw(string name)
		{
			return GetAxis(name, raw: true);
		}

		private static float GetAxis(string name, bool raw)
		{
			return activeInput.GetAxis(name, raw);
		}

		public static bool GetButton(string name)
		{
			return activeInput.GetButton(name);
		}

		public static bool GetButtonDown(string name)
		{
			return activeInput.GetButtonDown(name);
		}

		public static bool GetButtonUp(string name)
		{
			return activeInput.GetButtonUp(name);
		}

		public static void SetButtonDown(string name)
		{
			activeInput.SetButtonDown(name);
		}

		public static void SetButtonUp(string name)
		{
			activeInput.SetButtonUp(name);
		}

		public static void SetAxisPositive(string name)
		{
			activeInput.SetAxisPositive(name);
		}

		public static void SetAxisNegative(string name)
		{
			activeInput.SetAxisNegative(name);
		}

		public static void SetAxisZero(string name)
		{
			activeInput.SetAxisZero(name);
		}

		public static void SetAxis(string name, float value)
		{
			activeInput.SetAxis(name, value);
		}

		public static void SetVirtualMousePositionX(float f)
		{
			activeInput.SetVirtualMousePositionX(f);
		}

		public static void SetVirtualMousePositionY(float f)
		{
			activeInput.SetVirtualMousePositionY(f);
		}

		public static void SetVirtualMousePositionZ(float f)
		{
			activeInput.SetVirtualMousePositionZ(f);
		}
	}
	public class InputAxisScrollbar : MonoBehaviour
	{
		public string axis;

		private void Update()
		{
		}

		public void HandleInput(float value)
		{
			CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
		}
	}
	public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public int MovementRange = 100;

		public AxisOption axesToUse;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		private Vector3 m_StartPos;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_StartPos = base.transform.position;
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			Vector3 vector = m_StartPos - value;
			vector.y = 0f - vector.y;
			vector /= (float)MovementRange;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(0f - vector.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(vector.y);
			}
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		public void OnDrag(PointerEventData data)
		{
			Vector3 zero = Vector3.zero;
			if (m_UseX)
			{
				int value = (int)(data.position.x - m_StartPos.x);
				value = Mathf.Clamp(value, -MovementRange, MovementRange);
				zero.x = value;
			}
			if (m_UseY)
			{
				int value2 = (int)(data.position.y - m_StartPos.y);
				value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
				zero.y = value2;
			}
			base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
			UpdateVirtualAxes(base.transform.position);
		}

		public void OnPointerUp(PointerEventData data)
		{
			base.transform.position = m_StartPos;
			UpdateVirtualAxes(m_StartPos);
		}

		public void OnPointerDown(PointerEventData data)
		{
		}

		private void OnDisable()
		{
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Remove();
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Remove();
			}
		}
	}
	[ExecuteInEditMode]
	public class MobileControlRig : MonoBehaviour
	{
		private void OnEnable()
		{
			CheckEnableControlRig();
		}

		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}

		private void CheckEnableControlRig()
		{
			EnableControlRig(enabled: true);
		}

		private void EnableControlRig(bool enabled)
		{
			foreach (Transform item in base.transform)
			{
				item.gameObject.SetActive(enabled);
			}
		}
	}
	[RequireComponent(typeof(Image))]
	public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public enum ControlStyle
		{
			Absolute,
			Relative,
			Swipe
		}

		public AxisOption axesToUse;

		public ControlStyle controlStyle;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		public float Xsensitivity = 1f;

		public float Ysensitivity = 1f;

		private Vector3 m_StartPos;

		private Vector2 m_PreviousDelta;

		private Vector3 m_JoytickOutput;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private bool m_Dragging;

		private int m_Id = -1;

		private Vector2 m_PreviousTouchPos;

		private Vector3 m_Center;

		private Image m_Image;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_Image = GetComponent<Image>();
			m_Center = m_Image.transform.position;
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			value = value.normalized;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(value.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(value.y);
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			m_Dragging = true;
			m_Id = data.pointerId;
			if (controlStyle != 0)
			{
				m_Center = data.position;
			}
		}

		private void Update()
		{
			if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
			{
				if (controlStyle == ControlStyle.Swipe)
				{
					m_Center = m_PreviousTouchPos;
					m_PreviousTouchPos = Input.touches[m_Id].position;
				}
				Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
				normalized.x *= Xsensitivity;
				normalized.y *= Ysensitivity;
				UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
			}
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Dragging = false;
			m_Id = -1;
			UpdateVirtualAxes(Vector3.zero);
		}

		private void OnDisable()
		{
			if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
			}
			if (CrossPlatformInputManager.AxisExists(verticalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
			}
		}
	}
	public abstract class VirtualInput
	{
		protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

		protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

		protected List<string> m_AlwaysUseVirtual = new List<string>();

		public Vector3 virtualMousePosition { get; private set; }

		public bool AxisExists(string name)
		{
			return m_VirtualAxes.ContainsKey(name);
		}

		public bool ButtonExists(string name)
		{
			return m_VirtualButtons.ContainsKey(name);
		}

		public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
		{
			if (m_VirtualAxes.ContainsKey(axis.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
				return;
			}
			m_VirtualAxes.Add(axis.name, axis);
			if (!axis.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(axis.name);
			}
		}

		public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
		{
			if (m_VirtualButtons.ContainsKey(button.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
				return;
			}
			m_VirtualButtons.Add(button.name, button);
			if (!button.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(button.name);
			}
		}

		public void UnRegisterVirtualAxis(string name)
		{
			if (m_VirtualAxes.ContainsKey(name))
			{
				m_VirtualAxes.Remove(name);
			}
		}

		public void UnRegisterVirtualButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				m_VirtualButtons.Remove(name);
			}
		}

		public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				return null;
			}
			return m_VirtualAxes[name];
		}

		public void SetVirtualMousePositionX(float f)
		{
			virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionY(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionZ(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
		}

		public abstract float GetAxis(string name, bool raw);

		public abstract bool GetButton(string name);

		public abstract bool GetButtonDown(string name);

		public abstract bool GetButtonUp(string name);

		public abstract void SetButtonDown(string name);

		public abstract void SetButtonUp(string name);

		public abstract void SetAxisPositive(string name);

		public abstract void SetAxisNegative(string name);

		public abstract void SetAxisZero(string name);

		public abstract void SetAxis(string name, float value);

		public abstract Vector3 MousePosition();
	}
}
namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
{
	public class MobileInput : VirtualInput
	{
		private void AddButton(string name)
		{
			CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
		}

		private void AddAxes(string name)
		{
			CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
		}

		public override float GetAxis(string name, bool raw)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			return m_VirtualAxes[name].GetValue;
		}

		public override void SetButtonDown(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Pressed();
		}

		public override void SetButtonUp(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Released();
		}

		public override void SetAxisPositive(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(1f);
		}

		public override void SetAxisNegative(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(-1f);
		}

		public override void SetAxisZero(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(0f);
		}

		public override void SetAxis(string name, float value)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(value);
		}

		public override bool GetButtonDown(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonDown;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonDown;
		}

		public override bool GetButtonUp(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonUp;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonUp;
		}

		public override bool GetButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButton;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButton;
		}

		public override Vector3 MousePosition()
		{
			return base.virtualMousePosition;
		}
	}
	public class StandaloneInput : VirtualInput
	{
		public override float GetAxis(string name, bool raw)
		{
			if (!raw)
			{
				return Input.GetAxis(name);
			}
			return Input.GetAxisRaw(name);
		}

		public override bool GetButton(string name)
		{
			return Input.GetButton(name);
		}

		public override bool GetButtonDown(string name)
		{
			return Input.GetButtonDown(name);
		}

		public override bool GetButtonUp(string name)
		{
			return Input.GetButtonUp(name);
		}

		public override void SetButtonDown(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetButtonUp(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisPositive(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisNegative(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisZero(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxis(string name, float value)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override Vector3 MousePosition()
		{
			return Input.mousePosition;
		}
	}
}
namespace ExitGames.Demos.DemoPunVoice
{
	[RequireComponent(typeof(PhotonView))]
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(Animator))]
	public abstract class BaseController : MonoBehaviour
	{
		public Camera ControllerCamera;

		protected Rigidbody rigidBody;

		protected Animator animator;

		protected Transform camTrans;

		private float h;

		private float v;

		[SerializeField]
		protected float speed = 5f;

		[SerializeField]
		private float cameraDistance;

		protected virtual void OnEnable()
		{
			ChangePOV.CameraChanged += ChangePOV_CameraChanged;
		}

		protected virtual void OnDisable()
		{
			ChangePOV.CameraChanged -= ChangePOV_CameraChanged;
		}

		protected virtual void ChangePOV_CameraChanged(Camera camera)
		{
			if (camera != ControllerCamera)
			{
				base.enabled = false;
				HideCamera(ControllerCamera);
			}
			else
			{
				ShowCamera(ControllerCamera);
			}
		}

		protected virtual void Start()
		{
			if (GetComponent<PhotonView>().IsMine)
			{
				Init();
				SetCamera();
			}
			else
			{
				base.enabled = false;
			}
		}

		protected virtual void Init()
		{
			rigidBody = GetComponent<Rigidbody>();
			animator = GetComponent<Animator>();
		}

		protected virtual void SetCamera()
		{
			camTrans = ControllerCamera.transform;
			camTrans.position += cameraDistance * base.transform.forward;
		}

		protected virtual void UpdateAnimator(float h, float v)
		{
			bool value = h != 0f || v != 0f;
			animator.SetBool("IsWalking", value);
		}

		protected virtual void FixedUpdate()
		{
			h = CrossPlatformInputManager.GetAxisRaw("Horizontal");
			v = CrossPlatformInputManager.GetAxisRaw("Vertical");
			if (Mathf.Abs(h) < 0.5f)
			{
				h = 0f;
			}
			else
			{
				h = Mathf.Sign(h);
			}
			if (Mathf.Abs(v) < 0.5f)
			{
				v = 0f;
			}
			else
			{
				v = Mathf.Sign(v);
			}
			UpdateAnimator(h, v);
			Move(h, v);
		}

		protected virtual void ShowCamera(Camera camera)
		{
			if (camera != null)
			{
				camera.gameObject.SetActive(value: true);
			}
		}

		protected virtual void HideCamera(Camera camera)
		{
			if (camera != null)
			{
				camera.gameObject.SetActive(value: false);
			}
		}

		protected abstract void Move(float h, float v);
	}
	[RequireComponent(typeof(Toggle))]
	[DisallowMultipleComponent]
	public class BetterToggle : MonoBehaviour
	{
		public delegate void OnToggle(Toggle toggle);

		private Toggle toggle;

		public static event OnToggle ToggleValueChanged;

		private void Start()
		{
			toggle = GetComponent<Toggle>();
			toggle.onValueChanged.AddListener(delegate
			{
				OnToggleValueChanged();
			});
		}

		public void OnToggleValueChanged()
		{
			if (BetterToggle.ToggleValueChanged != null)
			{
				BetterToggle.ToggleValueChanged(toggle);
			}
		}
	}
	public class ChangePOV : MonoBehaviour, IMatchmakingCallbacks
	{
		public delegate void OnCameraChanged(Camera newCamera);

		private FirstPersonController firstPersonController;

		private ThirdPersonController thirdPersonController;

		private OrthographicController orthographicController;

		private Vector3 initialCameraPosition;

		private Quaternion initialCameraRotation;

		private Camera defaultCamera;

		[SerializeField]
		private GameObject ButtonsHolder;

		[SerializeField]
		private Button FirstPersonCamActivator;

		[SerializeField]
		private Button ThirdPersonCamActivator;

		[SerializeField]
		private Button OrthographicCamActivator;

		public static event OnCameraChanged CameraChanged;

		private void OnEnable()
		{
			CharacterInstantiation.CharacterInstantiated += OnCharacterInstantiated;
			PhotonNetwork.AddCallbackTarget(this);
		}

		private void OnDisable()
		{
			CharacterInstantiation.CharacterInstantiated -= OnCharacterInstantiated;
			PhotonNetwork.RemoveCallbackTarget(this);
		}

		private void Start()
		{
			defaultCamera = Camera.main;
			initialCameraPosition = new Vector3(defaultCamera.transform.position.x, defaultCamera.transform.position.y, defaultCamera.transform.position.z);
			initialCameraRotation = new Quaternion(defaultCamera.transform.rotation.x, defaultCamera.transform.rotation.y, defaultCamera.transform.rotation.z, defaultCamera.transform.rotation.w);
			FirstPersonCamActivator.gameObject.SetActive(value: false);
			ThirdPersonCamActivator.onClick.AddListener(ThirdPersonMode);
			OrthographicCamActivator.onClick.AddListener(OrthographicMode);
		}

		private void OnCharacterInstantiated(GameObject character)
		{
			firstPersonController = character.GetComponent<FirstPersonController>();
			firstPersonController.enabled = false;
			thirdPersonController = character.GetComponent<ThirdPersonController>();
			thirdPersonController.enabled = false;
			orthographicController = character.GetComponent<OrthographicController>();
			ButtonsHolder.SetActive(value: true);
		}

		private void FirstPersonMode()
		{
			ToggleMode(firstPersonController);
		}

		private void ThirdPersonMode()
		{
			ToggleMode(thirdPersonController);
		}

		private void OrthographicMode()
		{
			ToggleMode(orthographicController);
		}

		private void ToggleMode(BaseController controller)
		{
			if (!(controller == null) && !(controller.ControllerCamera == null))
			{
				controller.ControllerCamera.gameObject.SetActive(value: true);
				controller.enabled = true;
				FirstPersonCamActivator.interactable = !(controller == firstPersonController);
				ThirdPersonCamActivator.interactable = !(controller == thirdPersonController);
				OrthographicCamActivator.interactable = !(controller == orthographicController);
				BroadcastChange(controller.ControllerCamera);
			}
		}

		private void BroadcastChange(Camera camera)
		{
			if (!(camera == null) && ChangePOV.CameraChanged != null)
			{
				ChangePOV.CameraChanged(camera);
			}
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
		}

		public void OnLeftRoom()
		{
			if (!ConnectionHandler.AppQuits)
			{
				defaultCamera.gameObject.SetActive(value: true);
				FirstPersonCamActivator.interactable = true;
				ThirdPersonCamActivator.interactable = true;
				OrthographicCamActivator.interactable = false;
				defaultCamera.transform.position = initialCameraPosition;
				defaultCamera.transform.rotation = initialCameraRotation;
				ButtonsHolder.SetActive(value: false);
			}
		}
	}
	public class CharacterInstantiation : MonoBehaviourPunCallbacks, IOnEventCallback
	{
		public enum SpawnSequence
		{
			Connection,
			Random,
			RoundRobin
		}

		public delegate void OnCharacterInstantiated(GameObject character);

		public Transform SpawnPosition;

		public float PositionOffset = 2f;

		public GameObject[] PrefabsToInstantiate;

		public List<Transform> SpawnPoints;

		public bool AutoSpawn = true;

		public bool UseRandomOffset = true;

		public SpawnSequence Sequence;

		[SerializeField]
		private byte manualInstantiationEventCode = 1;

		protected int lastUsedSpawnPointIndex = -1;

		[SerializeField]
		private bool manualInstantiation;

		[SerializeField]
		private bool differentPrefabs;

		[SerializeField]
		private string localPrefabSuffix;

		[SerializeField]
		private string remotePrefabSuffix;

		public static event OnCharacterInstantiated CharacterInstantiated;

		public override void OnJoinedRoom()
		{
			if (!AutoSpawn || PrefabsToInstantiate == null)
			{
				return;
			}
			int num = PhotonNetwork.LocalPlayer.ActorNumber;
			if (num < 1)
			{
				num = 1;
			}
			int num2 = (num - 1) % PrefabsToInstantiate.Length;
			GetSpawnPoint(out var spawnPos, out var spawnRot);
			Camera.main.transform.position += spawnPos;
			if (manualInstantiation)
			{
				ManualInstantiation(num2, spawnPos, spawnRot);
				return;
			}
			GameObject gameObject = PrefabsToInstantiate[num2];
			gameObject = PhotonNetwork.Instantiate(gameObject.name, spawnPos, spawnRot, 0);
			if (CharacterInstantiation.CharacterInstantiated != null)
			{
				CharacterInstantiation.CharacterInstantiated(gameObject);
			}
		}

		private void ManualInstantiation(int index, Vector3 position, Quaternion rotation)
		{
			GameObject gameObject = PrefabsToInstantiate[index];
			GameObject gameObject2 = ((!differentPrefabs) ? UnityEngine.Object.Instantiate(gameObject, position, rotation) : UnityEngine.Object.Instantiate(Resources.Load($"{gameObject.name}{localPrefabSuffix}") as GameObject, position, rotation));
			PhotonView component = gameObject2.GetComponent<PhotonView>();
			if (PhotonNetwork.AllocateViewID(component))
			{
				object[] eventContent = new object[4]
				{
					index,
					gameObject2.transform.position,
					gameObject2.transform.rotation,
					component.ViewID
				};
				RaiseEventOptions raiseEventOptions = new RaiseEventOptions
				{
					Receivers = ReceiverGroup.Others,
					CachingOption = EventCaching.AddToRoomCache
				};
				PhotonNetwork.RaiseEvent(manualInstantiationEventCode, eventContent, raiseEventOptions, SendOptions.SendReliable);
				if (CharacterInstantiation.CharacterInstantiated != null)
				{
					CharacterInstantiation.CharacterInstantiated(gameObject2);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Failed to allocate a ViewId.");
				UnityEngine.Object.Destroy(gameObject2);
			}
		}

		public void OnEvent(ExitGames.Client.Photon.EventData photonEvent)
		{
			if (photonEvent.Code == manualInstantiationEventCode)
			{
				object[] array = photonEvent.CustomData as object[];
				int num = (int)array[0];
				GameObject gameObject = PrefabsToInstantiate[num];
				Vector3 position = (Vector3)array[1];
				Quaternion rotation = (Quaternion)array[2];
				GameObject gameObject2 = ((!differentPrefabs) ? UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity) : UnityEngine.Object.Instantiate(Resources.Load($"{gameObject.name}{remotePrefabSuffix}") as GameObject, position, rotation));
				gameObject2.GetComponent<PhotonView>().ViewID = (int)array[3];
			}
		}

		protected virtual void GetSpawnPoint(out Vector3 spawnPos, out Quaternion spawnRot)
		{
			Transform spawnPoint = GetSpawnPoint();
			if (spawnPoint != null)
			{
				spawnPos = spawnPoint.position;
				spawnRot = spawnPoint.rotation;
			}
			else
			{
				spawnPos = new Vector3(0f, 0f, 0f);
				spawnRot = new Quaternion(0f, 0f, 0f, 1f);
			}
			if (UseRandomOffset)
			{
				UnityEngine.Random.InitState((int)(Time.time * 10000f));
				Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
				insideUnitSphere.y = 0f;
				insideUnitSphere = insideUnitSphere.normalized;
				spawnPos += PositionOffset * insideUnitSphere;
			}
		}

		protected virtual Transform GetSpawnPoint()
		{
			if (SpawnPoints == null || SpawnPoints.Count == 0)
			{
				return null;
			}
			switch (Sequence)
			{
			case SpawnSequence.Connection:
			{
				int actorNumber = PhotonNetwork.LocalPlayer.ActorNumber;
				return SpawnPoints[(actorNumber != -1) ? (actorNumber % SpawnPoints.Count) : 0];
			}
			case SpawnSequence.RoundRobin:
				lastUsedSpawnPointIndex++;
				if (lastUsedSpawnPointIndex >= SpawnPoints.Count)
				{
					lastUsedSpawnPointIndex = 0;
				}
				return SpawnPoints[lastUsedSpawnPointIndex];
			case SpawnSequence.Random:
				return SpawnPoints[UnityEngine.Random.Range(0, SpawnPoints.Count)];
			default:
				return null;
			}
		}
	}
	public class FirstPersonController : BaseController
	{
		[SerializeField]
		private MouseLookHelper mouseLook = new MouseLookHelper();

		private float oldYRotation;

		private Quaternion velRotation;

		public Vector3 Velocity => rigidBody.velocity;

		protected override void SetCamera()
		{
			base.SetCamera();
			mouseLook.Init(base.transform, camTrans);
		}

		protected override void Move(float h, float v)
		{
			Vector3 velocity = camTrans.forward * v + camTrans.right * h;
			velocity.x *= speed;
			velocity.z *= speed;
			velocity.y = 0f;
			rigidBody.velocity = velocity;
		}

		private void Update()
		{
			RotateView();
		}

		private void RotateView()
		{
			oldYRotation = base.transform.eulerAngles.y;
			mouseLook.LookRotation(base.transform, camTrans);
			velRotation = Quaternion.AngleAxis(base.transform.eulerAngles.y - oldYRotation, Vector3.up);
			rigidBody.velocity = velRotation * rigidBody.velocity;
		}
	}
	[RequireComponent(typeof(Canvas))]
	public class Highlighter : MonoBehaviour
	{
		private Canvas canvas;

		private PhotonVoiceView photonVoiceView;

		[SerializeField]
		private Image recorderSprite;

		[SerializeField]
		private Image speakerSprite;

		[SerializeField]
		private Text bufferLagText;

		private bool showSpeakerLag;

		private void OnEnable()
		{
			ChangePOV.CameraChanged += ChangePOV_CameraChanged;
			VoiceDemoUI.DebugToggled += VoiceDemoUI_DebugToggled;
		}

		private void OnDisable()
		{
			ChangePOV.CameraChanged -= ChangePOV_CameraChanged;
			VoiceDemoUI.DebugToggled -= VoiceDemoUI_DebugToggled;
		}

		private void VoiceDemoUI_DebugToggled(bool debugMode)
		{
			showSpeakerLag = debugMode;
		}

		private void ChangePOV_CameraChanged(Camera camera)
		{
			canvas.worldCamera = camera;
		}

		private void Awake()
		{
			canvas = GetComponent<Canvas>();
			if (canvas != null && canvas.worldCamera == null)
			{
				canvas.worldCamera = Camera.main;
			}
			photonVoiceView = GetComponentInParent<PhotonVoiceView>();
		}

		private void Update()
		{
			recorderSprite.enabled = photonVoiceView.IsRecording;
			speakerSprite.enabled = photonVoiceView.IsSpeaking;
			bufferLagText.enabled = showSpeakerLag && photonVoiceView.IsSpeaking;
			if (bufferLagText.enabled)
			{
				bufferLagText.text = $"{photonVoiceView.SpeakerInUse.Lag}";
			}
		}

		private void LateUpdate()
		{
			if (!(canvas == null) && !(canvas.worldCamera == null))
			{
				base.transform.rotation = Quaternion.Euler(0f, canvas.worldCamera.transform.eulerAngles.y, 0f);
			}
		}
	}
	public class OrthographicController : ThirdPersonController
	{
		public float smoothing = 5f;

		private Vector3 offset;

		protected override void Init()
		{
			base.Init();
			ControllerCamera = Camera.main;
		}

		protected override void SetCamera()
		{
			base.SetCamera();
			offset = camTrans.position - base.transform.position;
		}

		protected override void Move(float h, float v)
		{
			base.Move(h, v);
			CameraFollow();
		}

		private void CameraFollow()
		{
			Vector3 b = base.transform.position + offset;
			camTrans.position = Vector3.Lerp(camTrans.position, b, smoothing * Time.deltaTime);
		}
	}
	public class ThirdPersonController : BaseController
	{
		[SerializeField]
		private float movingTurnSpeed = 360f;

		protected override void Move(float h, float v)
		{
			rigidBody.velocity = v * speed * base.transform.forward;
			base.transform.rotation *= Quaternion.AngleAxis(movingTurnSpeed * h * Time.deltaTime, Vector3.up);
		}
	}
	public class VoiceDemoUI : MonoBehaviour
	{
		public delegate void OnDebugToggle(bool debugMode);

		[SerializeField]
		private Text punState;

		[SerializeField]
		private Text voiceState;

		private PhotonVoiceNetwork punVoiceNetwork;

		private Canvas canvas;

		[SerializeField]
		private Button punSwitch;

		private Text punSwitchText;

		[SerializeField]
		private Button voiceSwitch;

		private Text voiceSwitchText;

		[SerializeField]
		private Button calibrateButton;

		private Text calibrateText;

		[SerializeField]
		private Text voiceDebugText;

		public Recorder recorder;

		[SerializeField]
		private GameObject inGameSettings;

		[SerializeField]
		private GameObject globalSettings;

		[SerializeField]
		private Text devicesInfoText;

		private GameObject debugGO;

		private bool debugMode;

		private float volumeBeforeMute;

		private DebugLevel previousDebugLevel;

		[SerializeField]
		private int calibrationMilliSeconds = 2000;

		public bool DebugMode
		{
			get
			{
				return debugMode;
			}
			set
			{
				debugMode = value;
				debugGO.SetActive(debugMode);
				voiceDebugText.text = string.Empty;
				if (debugMode)
				{
					previousDebugLevel = punVoiceNetwork.Client.LoadBalancingPeer.DebugOut;
					punVoiceNetwork.Client.LoadBalancingPeer.DebugOut = DebugLevel.ALL;
				}
				else
				{
					punVoiceNetwork.Client.LoadBalancingPeer.DebugOut = previousDebugLevel;
				}
				if (VoiceDemoUI.DebugToggled != null)
				{
					VoiceDemoUI.DebugToggled(debugMode);
				}
			}
		}

		public static event OnDebugToggle DebugToggled;

		private void Awake()
		{
			punVoiceNetwork = PhotonVoiceNetwork.Instance;
		}

		private void OnEnable()
		{
			ChangePOV.CameraChanged += OnCameraChanged;
			BetterToggle.ToggleValueChanged += BetterToggle_ToggleValueChanged;
			CharacterInstantiation.CharacterInstantiated += CharacterInstantiation_CharacterInstantiated;
			punVoiceNetwork.Client.StateChanged += VoiceClientStateChanged;
			PhotonNetwork.NetworkingClient.StateChanged += PunClientStateChanged;
		}

		private void OnDisable()
		{
			ChangePOV.CameraChanged -= OnCameraChanged;
			BetterToggle.ToggleValueChanged -= BetterToggle_ToggleValueChanged;
			CharacterInstantiation.CharacterInstantiated -= CharacterInstantiation_CharacterInstantiated;
			punVoiceNetwork.Client.StateChanged -= VoiceClientStateChanged;
			PhotonNetwork.NetworkingClient.StateChanged -= PunClientStateChanged;
		}

		private void CharacterInstantiation_CharacterInstantiated(GameObject character)
		{
			if (!recorder)
			{
				PhotonVoiceView component = character.GetComponent<PhotonVoiceView>();
				if (component.IsRecorder)
				{
					recorder = component.RecorderInUse;
				}
			}
		}

		private void InitToggles(Toggle[] toggles)
		{
			if (toggles == null)
			{
				return;
			}
			foreach (Toggle toggle in toggles)
			{
				switch (toggle.name)
				{
				case "Mute":
					toggle.isOn = AudioListener.volume <= 0.001f;
					break;
				case "VoiceDetection":
					toggle.isOn = recorder != null && recorder.VoiceDetection;
					break;
				case "DebugVoice":
					toggle.isOn = DebugMode;
					break;
				case "Transmit":
					toggle.isOn = recorder != null && recorder.TransmitEnabled;
					break;
				case "DebugEcho":
					toggle.isOn = recorder != null && recorder.DebugEchoMode;
					break;
				case "AutoConnectAndJoin":
					toggle.isOn = punVoiceNetwork.AutoConnectAndJoin;
					break;
				case "AutoLeaveAndDisconnect":
					toggle.isOn = punVoiceNetwork.AutoLeaveAndDisconnect;
					break;
				}
			}
		}

		private void BetterToggle_ToggleValueChanged(Toggle toggle)
		{
			switch (toggle.name)
			{
			case "Mute":
				if (toggle.isOn)
				{
					volumeBeforeMute = AudioListener.volume;
					AudioListener.volume = 0f;
				}
				else
				{
					AudioListener.volume = volumeBeforeMute;
					volumeBeforeMute = 0f;
				}
				break;
			case "Transmit":
				if ((bool)recorder)
				{
					recorder.TransmitEnabled = toggle.isOn;
				}
				break;
			case "VoiceDetection":
				if ((bool)recorder)
				{
					recorder.VoiceDetection = toggle.isOn;
				}
				break;
			case "DebugEcho":
				if ((bool)recorder)
				{
					recorder.DebugEchoMode = toggle.isOn;
				}
				break;
			case "DebugVoice":
				DebugMode = toggle.isOn;
				break;
			case "AutoConnectAndJoin":
				punVoiceNetwork.AutoConnectAndJoin = toggle.isOn;
				break;
			case "AutoLeaveAndDisconnect":
				punVoiceNetwork.AutoLeaveAndDisconnect = toggle.isOn;
				break;
			}
		}

		private void OnCameraChanged(Camera newCamera)
		{
			canvas.worldCamera = newCamera;
		}

		private void Start()
		{
			canvas = GetComponentInChildren<Canvas>();
			if (punSwitch != null)
			{
				punSwitchText = punSwitch.GetComponentInChildren<Text>();
				punSwitch.onClick.AddListener(PunSwitchOnClick);
			}
			if (voiceSwitch != null)
			{
				voiceSwitchText = voiceSwitch.GetComponentInChildren<Text>();
				voiceSwitch.onClick.AddListener(VoiceSwitchOnClick);
			}
			if (calibrateButton != null)
			{
				calibrateButton.onClick.AddListener(CalibrateButtonOnClick);
				calibrateText = calibrateButton.GetComponentInChildren<Text>();
			}
			if (punState != null)
			{
				debugGO = punState.transform.parent.gameObject;
			}
			volumeBeforeMute = AudioListener.volume;
			previousDebugLevel = punVoiceNetwork.Client.LoadBalancingPeer.DebugOut;
			if (globalSettings != null)
			{
				globalSettings.SetActive(value: true);
				InitToggles(globalSettings.GetComponentsInChildren<Toggle>());
			}
			if (!(devicesInfoText != null))
			{
				return;
			}
			if (Microphone.devices == null || Microphone.devices.Length == 0)
			{
				devicesInfoText.enabled = true;
				devicesInfoText.color = Color.red;
				devicesInfoText.text = "No microphone device detected!";
				return;
			}
			if (Microphone.devices.Length == 1)
			{
				devicesInfoText.text = $"Mic.: {Microphone.devices[0]}";
				return;
			}
			devicesInfoText.text = $"Multi.Mic.Devices:\n0. {Microphone.devices[0]} (active)\n";
			for (int i = 1; i < Microphone.devices.Length; i++)
			{
				devicesInfoText.text += $"{i}. {Microphone.devices[i]}\n";
			}
		}

		private void PunSwitchOnClick()
		{
			if (PhotonNetwork.NetworkClientState == ClientState.Joined)
			{
				PhotonNetwork.Disconnect();
			}
			else if (PhotonNetwork.NetworkClientState == ClientState.Disconnected || PhotonNetwork.NetworkClientState == ClientState.PeerCreated)
			{
				PhotonNetwork.ConnectUsingSettings();
			}
		}

		private void VoiceSwitchOnClick()
		{
			if (punVoiceNetwork.ClientState == ClientState.Joined)
			{
				punVoiceNetwork.Disconnect();
			}
			else if (punVoiceNetwork.ClientState == ClientState.PeerCreated || punVoiceNetwork.ClientState == ClientState.Disconnected)
			{
				punVoiceNetwork.ConnectAndJoinRoom();
			}
		}

		private void CalibrateButtonOnClick()
		{
			if ((bool)recorder && !recorder.VoiceDetectorCalibrating)
			{
				recorder.VoiceDetectorCalibrate(calibrationMilliSeconds);
			}
		}

		private void Update()
		{
			if (recorder != null && recorder.LevelMeter != null)
			{
				voiceDebugText.text = $"Amp: avg. {recorder.LevelMeter.CurrentAvgAmp:0.000000}, peak {recorder.LevelMeter.CurrentPeakAmp:0.000000}";
			}
		}

		private void PunClientStateChanged(ClientState fromState, ClientState toState)
		{
			punState.text = $"PUN: {toState}";
			switch (toState)
			{
			case ClientState.PeerCreated:
			case ClientState.Disconnected:
				punSwitch.interactable = true;
				punSwitchText.text = "PUN Connect";
				break;
			case ClientState.Joined:
				punSwitch.interactable = true;
				punSwitchText.text = "PUN Disconnect";
				break;
			default:
				punSwitch.interactable = false;
				punSwitchText.text = "PUN busy";
				break;
			}
			UpdateUiBasedOnVoiceState(punVoiceNetwork.ClientState);
		}

		private void VoiceClientStateChanged(ClientState fromState, ClientState toState)
		{
			UpdateUiBasedOnVoiceState(toState);
		}

		private void UpdateUiBasedOnVoiceState(ClientState voiceClientState)
		{
			voiceState.text = $"PhotonVoice: {voiceClientState}";
			switch (voiceClientState)
			{
			case ClientState.Joined:
				voiceSwitch.interactable = true;
				inGameSettings.SetActive(value: true);
				voiceSwitchText.text = "Voice Disconnect";
				InitToggles(inGameSettings.GetComponentsInChildren<Toggle>());
				if (recorder != null)
				{
					calibrateButton.interactable = !recorder.VoiceDetectorCalibrating;
					calibrateText.text = (recorder.VoiceDetectorCalibrating ? "Calibrating" : $"Calibrate ({calibrationMilliSeconds / 1000}s)");
				}
				else
				{
					calibrateButton.interactable = false;
					calibrateText.text = "Unavailable";
				}
				break;
			case ClientState.PeerCreated:
			case ClientState.Disconnected:
				if (PhotonNetwork.InRoom)
				{
					voiceSwitch.interactable = true;
					voiceSwitchText.text = "Voice Connect";
					voiceDebugText.text = string.Empty;
				}
				else
				{
					voiceSwitch.interactable = false;
					voiceSwitchText.text = "Voice N/A";
					voiceDebugText.text = string.Empty;
				}
				calibrateButton.interactable = false;
				voiceSwitchText.text = "Voice Connect";
				calibrateText.text = "Unavailable";
				inGameSettings.SetActive(value: false);
				break;
			default:
				voiceSwitch.interactable = false;
				voiceSwitchText.text = "Voice busy";
				break;
			}
		}
	}
}
namespace OculusSampleFramework
{
	public class ColorGrabbable : OVRGrabbable
	{
		public static readonly Color COLOR_GRAB = new Color(1f, 0.5f, 0f, 1f);

		public static readonly Color COLOR_HIGHLIGHT = new Color(1f, 0f, 1f, 1f);

		private Color m_color = Color.black;

		private MeshRenderer[] m_meshRenderers;

		private bool m_highlight;

		public bool Highlight
		{
			get
			{
				return m_highlight;
			}
			set
			{
				m_highlight = value;
				UpdateColor();
			}
		}

		protected void UpdateColor()
		{
			if (base.isGrabbed)
			{
				SetColor(COLOR_GRAB);
			}
			else if (Highlight)
			{
				SetColor(COLOR_HIGHLIGHT);
			}
			else
			{
				SetColor(m_color);
			}
		}

		public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
		{
			base.GrabBegin(hand, grabPoint);
			UpdateColor();
		}

		public override void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
		{
			base.GrabEnd(linearVelocity, angularVelocity);
			UpdateColor();
		}

		private void Awake()
		{
			if (m_grabPoints.Length == 0)
			{
				Collider component = GetComponent<Collider>();
				if (component == null)
				{
					throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
				}
				m_grabPoints = new Collider[1] { component };
				m_meshRenderers = new MeshRenderer[1];
				m_meshRenderers[0] = GetComponent<MeshRenderer>();
			}
			else
			{
				m_meshRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			m_color = new Color(UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), 1f);
			SetColor(m_color);
		}

		private void SetColor(Color color)
		{
			for (int i = 0; i < m_meshRenderers.Length; i++)
			{
				MeshRenderer meshRenderer = m_meshRenderers[i];
				for (int j = 0; j < meshRenderer.materials.Length; j++)
				{
					meshRenderer.materials[j].color = color;
				}
			}
		}
	}
	public class DistanceGrabbable : OVRGrabbable
	{
		public string m_materialColorField;

		private GrabbableCrosshair m_crosshair;

		private GrabManager m_crosshairManager;

		private Renderer m_renderer;

		private MaterialPropertyBlock m_mpb;

		private bool m_inRange;

		private bool m_targeted;

		public bool InRange
		{
			get
			{
				return m_inRange;
			}
			set
			{
				m_inRange = value;
				RefreshCrosshair();
			}
		}

		public bool Targeted
		{
			get
			{
				return m_targeted;
			}
			set
			{
				m_targeted = value;
				RefreshCrosshair();
			}
		}

		protected override void Start()
		{
			base.Start();
			m_crosshair = base.gameObject.GetComponentInChildren<GrabbableCrosshair>();
			m_renderer = base.gameObject.GetComponent<Renderer>();
			m_crosshairManager = UnityEngine.Object.FindObjectOfType<GrabManager>();
			m_mpb = new MaterialPropertyBlock();
			RefreshCrosshair();
			m_renderer.SetPropertyBlock(m_mpb);
		}

		private void RefreshCrosshair()
		{
			if ((bool)m_crosshair)
			{
				if (base.isGrabbed)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else if (!InRange)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else
				{
					m_crosshair.SetState((!Targeted) ? GrabbableCrosshair.CrosshairState.Enabled : GrabbableCrosshair.CrosshairState.Targeted);
				}
			}
			if (m_materialColorField != null)
			{
				m_renderer.GetPropertyBlock(m_mpb);
				if (base.isGrabbed || !InRange)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorOutOfRange);
				}
				else if (Targeted)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorHighlighted);
				}
				else
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorInRange);
				}
				m_renderer.SetPropertyBlock(m_mpb);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class DistanceGrabber : OVRGrabber
	{
		[SerializeField]
		private float m_spherecastRadius;

		[SerializeField]
		private float m_noSnapThreshhold = 0.05f;

		[SerializeField]
		private bool m_useSpherecast;

		[SerializeField]
		public bool m_preventGrabThroughWalls;

		[SerializeField]
		private float m_objectPullVelocity = 10f;

		private float m_objectPullMaxRotationRate = 360f;

		private bool m_movingObjectToHand;

		[SerializeField]
		private float m_maxGrabDistance;

		[SerializeField]
		private int m_grabObjectsInLayer;

		[SerializeField]
		private int m_obstructionLayer;

		private DistanceGrabber m_otherHand;

		protected DistanceGrabbable m_target;

		protected Collider m_targetCollider;

		public bool UseSpherecast
		{
			get
			{
				return m_useSpherecast;
			}
			set
			{
				m_useSpherecast = value;
				GrabVolumeEnable(!m_useSpherecast);
			}
		}

		protected override void Start()
		{
			base.Start();
			Collider componentInChildren = m_player.GetComponentInChildren<Collider>();
			if (componentInChildren != null)
			{
				m_maxGrabDistance = componentInChildren.bounds.size.z * 0.5f + 3f;
			}
			else
			{
				m_maxGrabDistance = 12f;
			}
			if (m_parentHeldObject)
			{
				UnityEngine.Debug.LogError("m_parentHeldObject incompatible with DistanceGrabber. Setting to false.");
				m_parentHeldObject = false;
			}
			DistanceGrabber[] array = UnityEngine.Object.FindObjectsOfType<DistanceGrabber>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != this)
				{
					m_otherHand = array[i];
				}
			}
		}

		public override void Update()
		{
			base.Update();
			UnityEngine.Debug.DrawRay(base.transform.position, base.transform.forward, Color.red, 0.1f);
			FindTarget(out var dgOut, out var collOut);
			if (dgOut != m_target)
			{
				if (m_target != null)
				{
					m_target.Targeted = m_otherHand.m_target == m_target;
				}
				m_target = dgOut;
				m_targetCollider = collOut;
				if (m_target != null)
				{
					m_target.Targeted = true;
				}
			}
		}

		protected override void GrabBegin()
		{
			DistanceGrabbable target = m_target;
			Collider targetCollider = m_targetCollider;
			GrabVolumeEnable(enabled: false);
			if (!(target != null))
			{
				return;
			}
			if (target.isGrabbed)
			{
				((DistanceGrabber)target.grabbedBy).OffhandGrabbed(target);
			}
			m_grabbedObj = target;
			m_grabbedObj.GrabBegin(this, targetCollider);
			SetPlayerIgnoreCollision(m_grabbedObj.gameObject, ignore: true);
			m_movingObjectToHand = true;
			m_lastPos = base.transform.position;
			m_lastRot = base.transform.rotation;
			Vector3 vector = targetCollider.ClosestPointOnBounds(m_gripTransform.position);
			if (!m_grabbedObj.snapPosition && !m_grabbedObj.snapOrientation && m_noSnapThreshhold > 0f && (vector - m_gripTransform.position).magnitude < m_noSnapThreshhold)
			{
				Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
				m_movingObjectToHand = false;
				vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
				m_grabbedObjectPosOff = vector2;
				Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
				m_grabbedObjectRotOff = grabbedObjectRotOff;
				return;
			}
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}

		protected override void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
		{
			if (m_grabbedObj == null)
			{
				return;
			}
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 vector = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (m_movingObjectToHand)
			{
				float num = m_objectPullVelocity * Time.deltaTime;
				Vector3 vector2 = vector - m_grabbedObj.transform.position;
				if (num * num * 1.1f > vector2.sqrMagnitude)
				{
					m_movingObjectToHand = false;
				}
				else
				{
					vector2.Normalize();
					vector = m_grabbedObj.transform.position + vector2 * num;
					quaternion = Quaternion.RotateTowards(m_grabbedObj.transform.rotation, quaternion, m_objectPullMaxRotationRate * Time.deltaTime);
				}
			}
			grabbedRigidbody.MovePosition(vector);
			grabbedRigidbody.MoveRotation(quaternion);
		}

		private static DistanceGrabbable HitInfoToGrabbable(RaycastHit hitInfo)
		{
			if (hitInfo.collider != null)
			{
				GameObject gameObject = hitInfo.collider.gameObject;
				return gameObject.GetComponent<DistanceGrabbable>() ?? gameObject.GetComponentInParent<DistanceGrabbable>();
			}
			return null;
		}

		protected bool FindTarget(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			float num = float.MaxValue;
			foreach (OVRGrabbable key in m_grabCandidates.Keys)
			{
				DistanceGrabbable distanceGrabbable = key as DistanceGrabbable;
				bool flag = distanceGrabbable != null && distanceGrabbable.InRange && (!distanceGrabbable.isGrabbed || distanceGrabbable.allowOffhandGrab);
				if (flag && m_grabObjectsInLayer >= 0)
				{
					flag = distanceGrabbable.gameObject.layer == m_grabObjectsInLayer;
				}
				if (!flag)
				{
					continue;
				}
				for (int i = 0; i < distanceGrabbable.grabPoints.Length; i++)
				{
					Collider collider = distanceGrabbable.grabPoints[i];
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (!(sqrMagnitude < num))
					{
						continue;
					}
					bool flag2 = true;
					if (m_preventGrabThroughWalls)
					{
						Ray ray = default(Ray);
						ray.direction = distanceGrabbable.transform.position - m_gripTransform.position;
						ray.origin = m_gripTransform.position;
						UnityEngine.Debug.DrawRay(ray.origin, ray.direction, Color.red, 0.1f);
						if (Physics.Raycast(ray, out var hitInfo, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore) && (double)(collider.ClosestPointOnBounds(m_gripTransform.position) - m_gripTransform.position).magnitude > (double)hitInfo.distance * 1.1)
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						num = sqrMagnitude;
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
			}
			if (dgOut == null && m_useSpherecast)
			{
				return FindTargetWithSpherecast(out dgOut, out collOut);
			}
			return dgOut != null;
		}

		protected bool FindTargetWithSpherecast(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			Ray ray = new Ray(m_gripTransform.position, m_gripTransform.forward);
			int layerMask = ((m_grabObjectsInLayer == -1) ? (-1) : (1 << m_grabObjectsInLayer));
			if (Physics.SphereCast(ray, m_spherecastRadius, out var hitInfo, m_maxGrabDistance, layerMask))
			{
				DistanceGrabbable distanceGrabbable = null;
				Collider collider = null;
				if (hitInfo.collider != null)
				{
					distanceGrabbable = hitInfo.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
					collider = ((distanceGrabbable == null) ? null : hitInfo.collider);
					if ((bool)distanceGrabbable)
					{
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
				if (distanceGrabbable != null && m_preventGrabThroughWalls)
				{
					ray.direction = hitInfo.point - m_gripTransform.position;
					dgOut = distanceGrabbable;
					collOut = collider;
					if (Physics.Raycast(ray, out var hitInfo2, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore))
					{
						DistanceGrabbable distanceGrabbable2 = null;
						if (hitInfo.collider != null)
						{
							distanceGrabbable2 = hitInfo2.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
						}
						if (distanceGrabbable2 != distanceGrabbable && hitInfo2.distance < hitInfo.distance)
						{
							dgOut = null;
							collOut = null;
						}
					}
				}
			}
			return dgOut != null;
		}

		protected override void GrabVolumeEnable(bool enabled)
		{
			if (m_useSpherecast)
			{
				enabled = false;
			}
			base.GrabVolumeEnable(enabled);
		}

		protected override void OffhandGrabbed(OVRGrabbable grabbable)
		{
			base.OffhandGrabbed(grabbable);
		}
	}
	public class GrabManager : MonoBehaviour
	{
		private Collider m_grabVolume;

		public Color OutlineColorInRange;

		public Color OutlineColorHighlighted;

		public Color OutlineColorOutOfRange;

		private void OnTriggerEnter(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = true;
			}
		}

		private void OnTriggerExit(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = false;
			}
		}
	}
	public class GrabbableCrosshair : MonoBehaviour
	{
		public enum CrosshairState
		{
			Disabled,
			Enabled,
			Targeted
		}

		private CrosshairState m_state;

		private Transform m_centerEyeAnchor;

		[SerializeField]
		private GameObject m_targetedCrosshair;

		[SerializeField]
		private GameObject m_enabledCrosshair;

		private void Start()
		{
			m_centerEyeAnchor = GameObject.Find("CenterEyeAnchor").transform;
		}

		public void SetState(CrosshairState cs)
		{
			m_state = cs;
			switch (cs)
			{
			case CrosshairState.Disabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: false);
				break;
			case CrosshairState.Enabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: true);
				break;
			case CrosshairState.Targeted:
				m_targetedCrosshair.SetActive(value: true);
				m_enabledCrosshair.SetActive(value: false);
				break;
			}
		}

		private void Update()
		{
			if (m_state != 0)
			{
				base.transform.LookAt(m_centerEyeAnchor);
			}
		}
	}
	public class PauseOnInputLoss : MonoBehaviour
	{
		private void Start()
		{
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			Time.timeScale = 0f;
		}

		private void OnInputFocusAcquired()
		{
			Time.timeScale = 1f;
		}
	}
	public class BoneCapsuleTriggerLogic : MonoBehaviour
	{
		public InteractableToolTags ToolTags;

		public HashSet<ColliderZone> CollidersTouchingUs = new HashSet<ColliderZone>();

		private List<ColliderZone> _elementsToCleanUp = new List<ColliderZone>();

		private void OnDisable()
		{
			CollidersTouchingUs.Clear();
		}

		private void Update()
		{
			CleanUpDeadColliders();
		}

		private void OnTriggerEnter(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Add(component);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Remove(component);
			}
		}

		private void CleanUpDeadColliders()
		{
			_elementsToCleanUp.Clear();
			foreach (ColliderZone collidersTouchingU in CollidersTouchingUs)
			{
				if (!collidersTouchingU.Collider.gameObject.activeInHierarchy)
				{
					_elementsToCleanUp.Add(collidersTouchingU);
				}
			}
			foreach (ColliderZone item in _elementsToCleanUp)
			{
				CollidersTouchingUs.Remove(item);
			}
		}
	}
	public class ButtonController : Interactable
	{
		public enum ContactTest
		{
			PerpenTest,
			BackwardsPress
		}

		private const float ENTRY_DOT_THRESHOLD = 0.8f;

		private const float PERP_DOT_THRESHOLD = 0.5f;

		[SerializeField]
		private GameObject _proximityZone;

		[SerializeField]
		private GameObject _contactZone;

		[SerializeField]
		private GameObject _actionZone;

		[SerializeField]
		private ContactTest[] _contactTests;

		[SerializeField]
		private Transform _buttonPlaneCenter;

		[SerializeField]
		private bool _makeSureToolIsOnPositiveSide = true;

		[SerializeField]
		private Vector3 _localButtonDirection = Vector3.down;

		[SerializeField]
		private InteractableToolTags[] _allValidToolsTags = new InteractableToolTags[1] { InteractableToolTags.All };

		private int _toolTagsMask;

		private InteractableState _currentButtonState;

		private Dictionary<InteractableTool, InteractableState> _toolToState = new Dictionary<InteractableTool, InteractableState>();

		public override int ValidToolTagsMask => _toolTagsMask;

		public Vector3 LocalButtonDirection => _localButtonDirection;

		protected override void Awake()
		{
			base.Awake();
			InteractableToolTags[] allValidToolsTags = _allValidToolsTags;
			foreach (InteractableToolTags interactableToolTags in allValidToolsTags)
			{
				_toolTagsMask |= (int)interactableToolTags;
			}
			_proximityZoneCollider = _proximityZone.GetComponent<ColliderZone>();
			_contactZoneCollider = _contactZone.GetComponent<ColliderZone>();
			_actionZoneCollider = _actionZone.GetComponent<ColliderZone>();
		}

		private void FireInteractionEventsOnDepth(InteractableCollisionDepth oldDepth, InteractableTool collidingTool, InteractionType interactionType)
		{
			switch (oldDepth)
			{
			case InteractableCollisionDepth.Action:
				OnActionZoneEvent(new ColliderZoneArgs(base.ActionCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Contact:
				OnContactZoneEvent(new ColliderZoneArgs(base.ContactCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Proximity:
				OnProximityZoneEvent(new ColliderZoneArgs(base.ProximityCollider, Time.frameCount, collidingTool, interactionType));
				break;
			}
		}

		public override void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth)
		{
			bool isFarFieldTool = interactableTool.IsFarFieldTool;
			if (!isFarFieldTool && _toolToState.Keys.Count > 0 && !_toolToState.ContainsKey(interactableTool))
			{
				return;
			}
			InteractableState currentButtonState = _currentButtonState;
			Vector3 vector = base.transform.TransformDirection(_localButtonDirection);
			bool validContact = IsValidContact(interactableTool, vector) || interactableTool.IsFarFieldTool;
			bool toolIsInProximity = newCollisionDepth >= InteractableCollisionDepth.Proximity;
			bool flag = newCollisionDepth == InteractableCollisionDepth.Contact;
			bool flag2 = newCollisionDepth == InteractableCollisionDepth.Action;
			bool flag3 = oldCollisionDepth != newCollisionDepth;
			if (flag3)
			{
				FireInteractionEventsOnDepth(oldCollisionDepth, interactableTool, InteractionType.Exit);
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Enter);
			}
			else
			{
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Stay);
			}
			InteractableState interactableState = currentButtonState;
			if (interactableTool.IsFarFieldTool)
			{
				interactableState = (flag ? InteractableState.ContactState : (flag2 ? InteractableState.ActionState : InteractableState.Default));
			}
			else
			{
				Plane plane = new Plane(-vector, _buttonPlaneCenter.position);
				bool onPositiveSideOfInteractable = !_makeSureToolIsOnPositiveSide || plane.GetSide(interactableTool.InteractionPosition);
				interactableState = GetUpcomingStateNearField(currentButtonState, newCollisionDepth, flag2, flag, toolIsInProximity, validContact, onPositiveSideOfInteractable);
			}
			if (interactableState != 0)
			{
				_toolToState[interactableTool] = interactableState;
			}
			else
			{
				_toolToState.Remove(interactableTool);
			}
			if (isFarFieldTool)
			{
				foreach (InteractableState value in _toolToState.Values)
				{
					if (interactableState < value)
					{
						interactableState = value;
					}
				}
			}
			if (currentButtonState != interactableState)
			{
				_currentButtonState = interactableState;
				InteractionType interactionType = ((!flag3) ? InteractionType.Stay : ((newCollisionDepth == InteractableCollisionDepth.None) ? InteractionType.Exit : InteractionType.Enter));
				ColliderZone collider = ((_currentButtonState == InteractableState.ProximityState) ? base.ProximityCollider : ((_currentButtonState == InteractableState.ContactState) ? base.ContactCollider : ((_currentButtonState == InteractableState.ActionState) ? base.ActionCollider : null)));
				if (InteractableStateChanged != null)
				{
					InteractableStateChanged.Invoke(new InteractableStateArgs(this, interactableTool, _currentButtonState, currentButtonState, new ColliderZoneArgs(collider, Time.frameCount, interactableTool, interactionType)));
				}
			}
		}

		private InteractableState GetUpcomingStateNearField(InteractableState oldState, InteractableCollisionDepth newCollisionDepth, bool toolIsInActionZone, bool toolIsInContactZone, bool toolIsInProximity, bool validContact, bool onPositiveSideOfInteractable)
		{
			InteractableState result = oldState;
			switch (oldState)
			{
			case InteractableState.ActionState:
				if (!toolIsInActionZone)
				{
					result = ((!toolIsInContactZone) ? (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default) : InteractableState.ContactState);
				}
				break;
			case InteractableState.ContactState:
				if (newCollisionDepth < InteractableCollisionDepth.Contact)
				{
					result = (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default);
				}
				else if (toolIsInActionZone && validContact && onPositiveSideOfInteractable)
				{
					result = InteractableState.ActionState;
				}
				break;
			case InteractableState.ProximityState:
				if (newCollisionDepth < InteractableCollisionDepth.Proximity)
				{
					result = InteractableState.Default;
				}
				else if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				break;
			case InteractableState.Default:
				if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				else if (toolIsInProximity)
				{
					result = InteractableState.ProximityState;
				}
				break;
			}
			return result;
		}

		private bool IsValidContact(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (_contactTests == null || collidingTool.IsFarFieldTool)
			{
				return true;
			}
			ContactTest[] contactTests = _contactTests;
			foreach (ContactTest contactTest in contactTests)
			{
				if (contactTest == ContactTest.BackwardsPress)
				{
					if (!PassEntryTest(collidingTool, buttonDirection))
					{
						return false;
					}
				}
				else if (!PassPerpTest(collidingTool, buttonDirection))
				{
					return false;
				}
			}
			return true;
		}

		private bool PassEntryTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (Vector3.Dot(collidingTool.Velocity.normalized, buttonDirection) < 0.8f)
			{
				return false;
			}
			return true;
		}

		private bool PassPerpTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			Vector3 vector = collidingTool.ToolTransform.right;
			if (collidingTool.IsRightHandedTool)
			{
				vector = -vector;
			}
			if (Vector3.Dot(vector, buttonDirection) < 0.5f)
			{
				return false;
			}
			return true;
		}
	}
	public class ButtonTriggerZone : MonoBehaviour, ColliderZone
	{
		[SerializeField]
		private GameObject _parentInteractableObj;

		public Collider Collider { get; private set; }

		public Interactable ParentInteractable { get; private set; }

		public InteractableCollisionDepth CollisionDepth
		{
			get
			{
				if (ParentInteractable.ProximityCollider != this)
				{
					if (ParentInteractable.ContactCollider != this)
					{
						if (ParentInteractable.ActionCollider != this)
						{
							return InteractableCollisionDepth.None;
						}
						return InteractableCollisionDepth.Action;
					}
					return InteractableCollisionDepth.Contact;
				}
				return InteractableCollisionDepth.Proximity;
			}
		}

		private void Awake()
		{
			Collider = GetComponent<Collider>();
			ParentInteractable = _parentInteractableObj.GetComponent<Interactable>();
		}
	}
	public interface ColliderZone
	{
		Collider Collider { get; }

		Interactable ParentInteractable { get; }

		InteractableCollisionDepth CollisionDepth { get; }
	}
	public class ColliderZoneArgs : EventArgs
	{
		public readonly ColliderZone Collider;

		public readonly float FrameTime;

		public readonly InteractableTool CollidingTool;

		public readonly InteractionType InteractionT;

		public ColliderZoneArgs(ColliderZone collider, float frameTime, InteractableTool collidingTool, InteractionType interactionType)
		{
			Collider = collider;
			FrameTime = frameTime;
			CollidingTool = collidingTool;
			InteractionT = interactionType;
		}
	}
	public enum InteractionType
	{
		Enter,
		Stay,
		Exit
	}
	public class HandsManager : MonoBehaviour
	{
		public enum HandsVisualMode
		{
			Mesh,
			Skeleton,
			Both
		}

		private const string SKELETON_VISUALIZER_NAME = "SkeletonRenderer";

		[SerializeField]
		private GameObject _leftHand;

		[SerializeField]
		private GameObject _rightHand;

		public HandsVisualMode VisualMode;

		private OVRHand[] _hand = new OVRHand[2];

		private OVRSkeleton[] _handSkeleton = new OVRSkeleton[2];

		private OVRSkeletonRenderer[] _handSkeletonRenderer = new OVRSkeletonRenderer[2];

		private OVRMesh[] _handMesh = new OVRMesh[2];

		private OVRMeshRenderer[] _handMeshRenderer = new OVRMeshRenderer[2];

		private SkinnedMeshRenderer _leftMeshRenderer;

		private SkinnedMeshRenderer _rightMeshRenderer;

		private GameObject _leftSkeletonVisual;

		private GameObject _rightSkeletonVisual;

		private float _currentHandAlpha = 1f;

		private int HandAlphaId = Shader.PropertyToID("_HandAlpha");

		public OVRHand RightHand
		{
			get
			{
				return _hand[1];
			}
			private set
			{
				_hand[1] = value;
			}
		}

		public OVRSkeleton RightHandSkeleton
		{
			get
			{
				return _handSkeleton[1];
			}
			private set
			{
				_handSkeleton[1] = value;
			}
		}

		public OVRSkeletonRenderer RightHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[1];
			}
			private set
			{
				_handSkeletonRenderer[1] = value;
			}
		}

		public OVRMesh RightHandMesh
		{
			get
			{
				return _handMesh[1];
			}
			private set
			{
				_handMesh[1] = value;
			}
		}

		public OVRMeshRenderer RightHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[1];
			}
			private set
			{
				_handMeshRenderer[1] = value;
			}
		}

		public OVRHand LeftHand
		{
			get
			{
				return _hand[0];
			}
			private set
			{
				_hand[0] = value;
			}
		}

		public OVRSkeleton LeftHandSkeleton
		{
			get
			{
				return _handSkeleton[0];
			}
			private set
			{
				_handSkeleton[0] = value;
			}
		}

		public OVRSkeletonRenderer LeftHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[0];
			}
			private set
			{
				_handSkeletonRenderer[0] = value;
			}
		}

		public OVRMesh LeftHandMesh
		{
			get
			{
				return _handMesh[0];
			}
			private set
			{
				_handMesh[0] = value;
			}
		}

		public OVRMeshRenderer LeftHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[0];
			}
			private set
			{
				_handMeshRenderer[0] = value;
			}
		}

		public static HandsManager Instance { get; private set; }

		private void Awake()
		{
			if ((bool)Instance && Instance != this)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			Instance = this;
			LeftHand = _leftHand.GetComponent<OVRHand>();
			LeftHandSkeleton = _leftHand.GetComponent<OVRSkeleton>();
			LeftHandSkeletonRenderer = _leftHand.GetComponent<OVRSkeletonRenderer>();
			LeftHandMesh = _leftHand.GetComponent<OVRMesh>();
			LeftHandMeshRenderer = _leftHand.GetComponent<OVRMeshRenderer>();
			RightHand = _rightHand.GetComponent<OVRHand>();
			RightHandSkeleton = _rightHand.GetComponent<OVRSkeleton>();
			RightHandSkeletonRenderer = _rightHand.GetComponent<OVRSkeletonRenderer>();
			RightHandMesh = _rightHand.GetComponent<OVRMesh>();
			RightHandMeshRenderer = _rightHand.GetComponent<OVRMeshRenderer>();
			_leftMeshRenderer = LeftHand.GetComponent<SkinnedMeshRenderer>();
			_rightMeshRenderer = RightHand.GetComponent<SkinnedMeshRenderer>();
			StartCoroutine(FindSkeletonVisualGameObjects());
		}

		private void Update()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
			case HandsVisualMode.Skeleton:
				_currentHandAlpha = 1f;
				break;
			case HandsVisualMode.Both:
				_currentHandAlpha = 0.6f;
				break;
			default:
				_currentHandAlpha = 1f;
				break;
			}
			_rightMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
			_leftMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
		}

		private IEnumerator FindSkeletonVisualGameObjects()
		{
			while (!_leftSkeletonVisual || !_rightSkeletonVisual)
			{
				if (!_leftSkeletonVisual)
				{
					Transform transform = LeftHand.transform.Find("SkeletonRenderer");
					if ((bool)transform)
					{
						_leftSkeletonVisual = transform.gameObject;
					}
				}
				if (!_rightSkeletonVisual)
				{
					Transform transform2 = RightHand.transform.Find("SkeletonRenderer");
					if ((bool)transform2)
					{
						_rightSkeletonVisual = transform2.gameObject;
					}
				}
				yield return null;
			}
			SetToCurrentVisualMode();
		}

		public void SwitchVisualization()
		{
			if ((bool)_leftSkeletonVisual && (bool)_rightSkeletonVisual)
			{
				VisualMode = (HandsVisualMode)((int)(VisualMode + 1) % 3);
				SetToCurrentVisualMode();
			}
		}

		private void SetToCurrentVisualMode()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: false);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: false);
				break;
			case HandsVisualMode.Skeleton:
				RightHandMeshRenderer.enabled = false;
				_rightMeshRenderer.enabled = false;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = false;
				_leftMeshRenderer.enabled = false;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			case HandsVisualMode.Both:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			}
		}

		public static List<OVRBoneCapsule> GetCapsulesPerBone(OVRSkeleton skeleton, OVRSkeleton.BoneId boneId)
		{
			List<OVRBoneCapsule> list = new List<OVRBoneCapsule>();
			IList<OVRBoneCapsule> capsules = skeleton.Capsules;
			for (int i = 0; i < capsules.Count; i++)
			{
				if (capsules[i].BoneIndex == (short)boneId)
				{
					list.Add(capsules[i]);
				}
			}
			return list;
		}

		public bool IsInitialized()
		{
			if ((bool)LeftHandSkeleton && LeftHandSkeleton.IsInitialized && (bool)RightHandSkeleton && RightHandSkeleton.IsInitialized && (bool)LeftHandMesh && LeftHandMesh.IsInitialized && (bool)RightHandMesh)
			{
				return RightHandMesh.IsInitialized;
			}
			return false;
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		[Serializable]
		public class InteractableStateArgsEvent : UnityEvent<InteractableStateArgs>
		{
		}

		protected ColliderZone _proximityZoneCollider;

		protected ColliderZone _contactZoneCollider;

		protected ColliderZone _actionZoneCollider;

		public InteractableStateArgsEvent InteractableStateChanged;

		public ColliderZone ProximityCollider => _proximityZoneCollider;

		public ColliderZone ContactCollider => _contactZoneCollider;

		public ColliderZone ActionCollider => _actionZoneCollider;

		public virtual int ValidToolTagsMask => -1;

		public event Action<ColliderZoneArgs> ProximityZoneEvent;

		public event Action<ColliderZoneArgs> ContactZoneEvent;

		public event Action<ColliderZoneArgs> ActionZoneEvent;

		protected virtual void OnProximityZoneEvent(ColliderZoneArgs args)
		{
			if (this.ProximityZoneEvent != null)
			{
				this.ProximityZoneEvent(args);
			}
		}

		protected virtual void OnContactZoneEvent(ColliderZoneArgs args)
		{
			if (this.ContactZoneEvent != null)
			{
				this.ContactZoneEvent(args);
			}
		}

		protected virtual void OnActionZoneEvent(ColliderZoneArgs args)
		{
			if (this.ActionZoneEvent != null)
			{
				this.ActionZoneEvent(args);
			}
		}

		public abstract void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth);

		protected virtual void Awake()
		{
			InteractableRegistry.RegisterInteractable(this);
		}

		protected virtual void OnDestroy()
		{
			InteractableRegistry.UnregisterInteractable(this);
		}
	}
	public enum InteractableCollisionDepth
	{
		None,
		Proximity,
		Contact,
		Action
	}
	public enum InteractableState
	{
		Default,
		ProximityState,
		ContactState,
		ActionState
	}
	public class InteractableStateArgs : EventArgs
	{
		public readonly Interactable Interactable;

		public readonly InteractableTool Tool;

		public readonly InteractableState OldInteractableState;

		public readonly InteractableState NewInteractableState;

		public readonly ColliderZoneArgs ColliderArgs;

		public InteractableStateArgs(Interactable interactable, InteractableTool tool, InteractableState newInteractableState, InteractableState oldState, ColliderZoneArgs colliderArgs)
		{
			Interactable = interactable;
			Tool = tool;
			NewInteractableState = newInteractableState;
			OldInteractableState = oldState;
			ColliderArgs = colliderArgs;
		}
	}
	public class InteractableRegistry : MonoBehaviour
	{
		public static HashSet<Interactable> _interactables = new HashSet<Interactable>();

		public static HashSet<Interactable> Interactables => _interactables;

		public static void RegisterInteractable(Interactable interactable)
		{
			Interactables.Add(interactable);
		}

		public static void UnregisterInteractable(Interactable interactable)
		{
			Interactables.Remove(interactable);
		}
	}
	public class InteractableToolsCreator : MonoBehaviour
	{
		[SerializeField]
		private Transform[] LeftHandTools;

		[SerializeField]
		private Transform[] RightHandTools;

		private void Awake()
		{
			if (LeftHandTools != null && LeftHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(LeftHandTools, isRightHand: false));
			}
			if (RightHandTools != null && RightHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(RightHandTools, isRightHand: true));
			}
		}

		private IEnumerator AttachToolsToHands(Transform[] toolObjects, bool isRightHand)
		{
			HandsManager handsManagerObj;
			while (true)
			{
				HandsManager instance;
				handsManagerObj = (instance = HandsManager.Instance);
				if (!(instance == null) && handsManagerObj.IsInitialized())
				{
					break;
				}
				yield return null;
			}
			HashSet<Transform> hashSet = new HashSet<Transform>();
			foreach (Transform transform in toolObjects)
			{
				hashSet.Add(transform.transform);
			}
			foreach (Transform toolObject in hashSet)
			{
				OVRSkeleton handSkeletonToAttachTo = (isRightHand ? handsManagerObj.RightHandSkeleton : handsManagerObj.LeftHandSkeleton);
				while (handSkeletonToAttachTo == null || handSkeletonToAttachTo.Bones == null)
				{
					yield return null;
				}
				AttachToolToHandTransform(toolObject, isRightHand);
			}
		}

		private void AttachToolToHandTransform(Transform tool, bool isRightHanded)
		{
			Transform obj = UnityEngine.Object.Instantiate(tool).transform;
			obj.localPosition = Vector3.zero;
			InteractableTool component = obj.GetComponent<InteractableTool>();
			component.IsRightHandedTool = isRightHanded;
			component.Initialize();
		}
	}
	public class InteractableToolsInputRouter : MonoBehaviour
	{
		private static InteractableToolsInputRouter _instance;

		private bool _leftPinch;

		private bool _rightPinch;

		private HashSet<InteractableTool> _leftHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _leftHandFarTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandFarTools = new HashSet<InteractableTool>();

		public static InteractableToolsInputRouter Instance
		{
			get
			{
				if (_instance == null)
				{
					InteractableToolsInputRouter[] array = UnityEngine.Object.FindObjectsOfType<InteractableToolsInputRouter>();
					if (array.Length != 0)
					{
						_instance = array[0];
						for (int i = 1; i < array.Length; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return _instance;
			}
		}

		public void RegisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Add(interactableTool);
				}
				else
				{
					_rightHandNearTools.Add(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Add(interactableTool);
			}
			else
			{
				_leftHandNearTools.Add(interactableTool);
			}
		}

		public void UnregisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Remove(interactableTool);
				}
				else
				{
					_rightHandNearTools.Remove(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Remove(interactableTool);
			}
			else
			{
				_leftHandNearTools.Remove(interactableTool);
			}
		}

		private void Update()
		{
			if (HandsManager.Instance.IsInitialized())
			{
				bool flag = HandsManager.Instance.LeftHand.IsTracked && HandsManager.Instance.LeftHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool flag2 = HandsManager.Instance.RightHand.IsTracked && HandsManager.Instance.RightHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool isPointerPoseValid = HandsManager.Instance.LeftHand.IsPointerPoseValid;
				bool isPointerPoseValid2 = HandsManager.Instance.RightHand.IsPointerPoseValid;
				bool flag3 = UpdateToolsAndEnableState(_leftHandNearTools, flag);
				UpdateToolsAndEnableState(_leftHandFarTools, !flag3 && flag && isPointerPoseValid);
				bool flag4 = UpdateToolsAndEnableState(_rightHandNearTools, flag2);
				UpdateToolsAndEnableState(_rightHandFarTools, !flag4 && flag2 && isPointerPoseValid2);
			}
		}

		private bool UpdateToolsAndEnableState(HashSet<InteractableTool> tools, bool toolsAreEnabledThisFrame)
		{
			bool result = UpdateTools(tools, !toolsAreEnabledThisFrame);
			ToggleToolsEnableState(tools, toolsAreEnabledThisFrame);
			return result;
		}

		private bool UpdateTools(HashSet<InteractableTool> tools, bool resetCollisionData = false)
		{
			bool flag = false;
			foreach (InteractableTool tool in tools)
			{
				List<InteractableCollisionInfo> nextIntersectingObjects = tool.GetNextIntersectingObjects();
				if (nextIntersectingObjects.Count > 0 && !resetCollisionData)
				{
					if (!flag)
					{
						flag = nextIntersectingObjects.Count > 0;
					}
					tool.UpdateCurrentCollisionsBasedOnDepth();
					if (tool.IsFarFieldTool)
					{
						KeyValuePair<Interactable, InteractableCollisionInfo> firstCurrentCollisionInfo = tool.GetFirstCurrentCollisionInfo();
						if (tool.ToolInputState == ToolInputState.PrimaryInputUp)
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ActionCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Action;
						}
						else
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ContactCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Contact;
						}
						tool.FocusOnInteractable(firstCurrentCollisionInfo.Key, firstCurrentCollisionInfo.Value.InteractableCollider);
					}
				}
				else
				{
					tool.DeFocus();
					tool.ClearAllCurrentCollisionInfos();
				}
				tool.UpdateLatestCollisionData();
			}
			return flag;
		}

		private void ToggleToolsEnableState(HashSet<InteractableTool> tools, bool enableState)
		{
			foreach (InteractableTool tool in tools)
			{
				if (tool.EnableState != enableState)
				{
					tool.EnableState = enableState;
				}
			}
		}
	}
	public class FingerTipPokeTool : InteractableTool
	{
		private const int NUM_VELOCITY_FRAMES = 10;

		[SerializeField]
		private FingerTipPokeToolView _fingerTipPokeToolView;

		[SerializeField]
		private OVRPlugin.HandFinger _fingerToFollow = OVRPlugin.HandFinger.Index;

		private Vector3[] _velocityFrames;

		private int _currVelocityFrame;

		private bool _sampledMaxFramesAlready;

		private Vector3 _position;

		private BoneCapsuleTriggerLogic[] _boneCapsuleTriggerLogic;

		private float _lastScale = 1f;

		private bool _isInitialized;

		private OVRBoneCapsule _capsuleToTrack;

		public override InteractableToolTags ToolTags => InteractableToolTags.Poke;

		public override ToolInputState ToolInputState => ToolInputState.Inactive;

		public override bool IsFarFieldTool => false;

		public override bool EnableState
		{
			get
			{
				return _fingerTipPokeToolView.gameObject.activeSelf;
			}
			set
			{
				_fingerTipPokeToolView.gameObject.SetActive(value);
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_fingerTipPokeToolView.InteractableTool = this;
			_velocityFrames = new Vector3[10];
			Array.Clear(_velocityFrames, 0, 10);
			StartCoroutine(AttachTriggerLogic());
		}

		private IEnumerator AttachTriggerLogic()
		{
			while (!HandsManager.Instance || !HandsManager.Instance.IsInitialized())
			{
				yield return null;
			}
			OVRSkeleton skeleton = (base.IsRightHandedTool ? HandsManager.Instance.RightHandSkeleton : HandsManager.Instance.LeftHandSkeleton);
			OVRSkeleton.BoneId boneId = _fingerToFollow switch
			{
				OVRPlugin.HandFinger.Thumb => OVRSkeleton.BoneId.Hand_Thumb3, 
				OVRPlugin.HandFinger.Index => OVRSkeleton.BoneId.Hand_Index3, 
				OVRPlugin.HandFinger.Middle => OVRSkeleton.BoneId.Hand_Middle3, 
				OVRPlugin.HandFinger.Ring => OVRSkeleton.BoneId.Hand_Ring3, 
				_ => OVRSkeleton.BoneId.Hand_Pinky3, 
			};
			List<BoneCapsuleTriggerLogic> list = new List<BoneCapsuleTriggerLogic>();
			List<OVRBoneCapsule> capsulesPerBone = HandsManager.GetCapsulesPerBone(skeleton, boneId);
			foreach (OVRBoneCapsule item in capsulesPerBone)
			{
				BoneCapsuleTriggerLogic boneCapsuleTriggerLogic = item.CapsuleRigidbody.gameObject.AddComponent<BoneCapsuleTriggerLogic>();
				item.CapsuleCollider.isTrigger = true;
				boneCapsuleTriggerLogic.ToolTags = ToolTags;
				list.Add(boneCapsuleTriggerLogic);
			}
			_boneCapsuleTriggerLogic = list.ToArray();
			if (capsulesPerBone.Count > 0)
			{
				_capsuleToTrack = capsulesPerBone[0];
			}
			_isInitialized = true;
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _isInitialized && _capsuleToTrack != null)
			{
				float handScale = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand).HandScale;
				Transform transform = _capsuleToTrack.CapsuleCollider.transform;
				Vector3 right = transform.right;
				Vector3 vector = transform.position + _capsuleToTrack.CapsuleCollider.height * 0.5f * right;
				Vector3 vector2 = handScale * _fingerTipPokeToolView.SphereRadius * right;
				Vector3 position = vector + vector2;
				base.transform.position = position;
				base.transform.rotation = transform.rotation;
				base.InteractionPosition = vector;
				UpdateAverageVelocity();
				CheckAndUpdateScale();
			}
		}

		private void UpdateAverageVelocity()
		{
			Vector3 position = _position;
			Vector3 position2 = base.transform.position;
			Vector3 vector = (position2 - position) / Time.deltaTime;
			_position = position2;
			_velocityFrames[_currVelocityFrame] = vector;
			_currVelocityFrame = (_currVelocityFrame + 1) % 10;
			base.Velocity = Vector3.zero;
			if (!_sampledMaxFramesAlready && _currVelocityFrame == 9)
			{
				_sampledMaxFramesAlready = true;
			}
			int num = (_sampledMaxFramesAlready ? 10 : (_currVelocityFrame + 1));
			for (int i = 0; i < num; i++)
			{
				base.Velocity += _velocityFrames[i];
			}
			base.Velocity /= (float)num;
		}

		private void CheckAndUpdateScale()
		{
			float num = (base.IsRightHandedTool ? HandsManager.Instance.RightHand.HandScale : HandsManager.Instance.LeftHand.HandScale);
			if (Mathf.Abs(num - _lastScale) > Mathf.Epsilon)
			{
				base.transform.localScale = new Vector3(num, num, num);
				_lastScale = num;
			}
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			_currentIntersectingObjects.Clear();
			BoneCapsuleTriggerLogic[] boneCapsuleTriggerLogic = _boneCapsuleTriggerLogic;
			for (int i = 0; i < boneCapsuleTriggerLogic.Length; i++)
			{
				foreach (ColliderZone collidersTouchingU in boneCapsuleTriggerLogic[i].CollidersTouchingUs)
				{
					_currentIntersectingObjects.Add(new InteractableCollisionInfo(collidersTouchingU, collidersTouchingU.CollisionDepth, this));
				}
			}
			return _currentIntersectingObjects;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
		}

		public override void DeFocus()
		{
		}
	}
	public class FingerTipPokeToolView : MonoBehaviour, InteractableToolView
	{
		[SerializeField]
		private MeshRenderer _sphereMeshRenderer;

		public InteractableTool InteractableTool { get; set; }

		public bool EnableState
		{
			get
			{
				return _sphereMeshRenderer.enabled;
			}
			set
			{
				_sphereMeshRenderer.enabled = value;
			}
		}

		public bool ToolActivateState { get; set; }

		public float SphereRadius { get; private set; }

		private void Awake()
		{
			SphereRadius = _sphereMeshRenderer.transform.localScale.z * 0.5f;
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
		}
	}
	[Flags]
	public enum InteractableToolTags
	{
		None = 0,
		Ray = 1,
		Poke = 4,
		All = -1
	}
	public enum ToolInputState
	{
		Inactive,
		PrimaryInputDown,
		PrimaryInputDownStay,
		PrimaryInputUp
	}
	public class InteractableCollisionInfo
	{
		public ColliderZone InteractableCollider;

		public InteractableCollisionDepth CollisionDepth;

		public InteractableTool CollidingTool;

		public InteractableCollisionInfo(ColliderZone collider, InteractableCollisionDepth collisionDepth, InteractableTool collidingTool)
		{
			InteractableCollider = collider;
			CollisionDepth = collisionDepth;
			CollidingTool = collidingTool;
		}
	}
	public abstract class InteractableTool : MonoBehaviour
	{
		protected List<InteractableCollisionInfo> _currentIntersectingObjects = new List<InteractableCollisionInfo>();

		private List<Interactable> _addedInteractables = new List<Interactable>();

		private List<Interactable> _removedInteractables = new List<Interactable>();

		private List<Interactable> _remainingInteractables = new List<Interactable>();

		private Dictionary<Interactable, InteractableCollisionInfo> _currInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		private Dictionary<Interactable, InteractableCollisionInfo> _prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		public Transform ToolTransform => base.transform;

		public bool IsRightHandedTool { get; set; }

		public abstract InteractableToolTags ToolTags { get; }

		public abstract ToolInputState ToolInputState { get; }

		public abstract bool IsFarFieldTool { get; }

		public Vector3 Velocity { get; protected set; }

		public Vector3 InteractionPosition { get; protected set; }

		public abstract bool EnableState { get; set; }

		public List<InteractableCollisionInfo> GetCurrentIntersectingObjects()
		{
			return _currentIntersectingObjects;
		}

		public abstract List<InteractableCollisionInfo> GetNextIntersectingObjects();

		public abstract void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone);

		public abstract void DeFocus();

		public abstract void Initialize();

		public KeyValuePair<Interactable, InteractableCollisionInfo> GetFirstCurrentCollisionInfo()
		{
			return _currInteractableToCollisionInfos.First();
		}

		public void ClearAllCurrentCollisionInfos()
		{
			_currInteractableToCollisionInfos.Clear();
		}

		public virtual void UpdateCurrentCollisionsBasedOnDepth()
		{
			_currInteractableToCollisionInfos.Clear();
			foreach (InteractableCollisionInfo currentIntersectingObject in _currentIntersectingObjects)
			{
				Interactable parentInteractable = currentIntersectingObject.InteractableCollider.ParentInteractable;
				InteractableCollisionDepth collisionDepth = currentIntersectingObject.CollisionDepth;
				InteractableCollisionInfo value = null;
				if (!_currInteractableToCollisionInfos.TryGetValue(parentInteractable, out value))
				{
					_currInteractableToCollisionInfos[parentInteractable] = currentIntersectingObject;
				}
				else if (value.CollisionDepth < collisionDepth)
				{
					value.InteractableCollider = currentIntersectingObject.InteractableCollider;
					value.CollisionDepth = collisionDepth;
				}
			}
		}

		public virtual void UpdateLatestCollisionData()
		{
			_addedInteractables.Clear();
			_removedInteractables.Clear();
			_remainingInteractables.Clear();
			foreach (Interactable key in _currInteractableToCollisionInfos.Keys)
			{
				if (!_prevInteractableToCollisionInfos.ContainsKey(key))
				{
					_addedInteractables.Add(key);
				}
				else
				{
					_remainingInteractables.Add(key);
				}
			}
			foreach (Interactable key2 in _prevInteractableToCollisionInfos.Keys)
			{
				if (!_currInteractableToCollisionInfos.ContainsKey(key2))
				{
					_removedInteractables.Add(key2);
				}
			}
			foreach (Interactable removedInteractable in _removedInteractables)
			{
				removedInteractable.UpdateCollisionDepth(this, _prevInteractableToCollisionInfos[removedInteractable].CollisionDepth, InteractableCollisionDepth.None);
			}
			foreach (Interactable addedInteractable in _addedInteractables)
			{
				InteractableCollisionDepth collisionDepth = _currInteractableToCollisionInfos[addedInteractable].CollisionDepth;
				addedInteractable.UpdateCollisionDepth(this, InteractableCollisionDepth.None, collisionDepth);
			}
			foreach (Interactable remainingInteractable in _remainingInteractables)
			{
				InteractableCollisionDepth collisionDepth2 = _currInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				InteractableCollisionDepth collisionDepth3 = _prevInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				remainingInteractable.UpdateCollisionDepth(this, collisionDepth3, collisionDepth2);
			}
			_prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>(_currInteractableToCollisionInfos);
		}
	}
	public interface InteractableToolView
	{
		InteractableTool InteractableTool { get; }

		bool EnableState { get; set; }

		bool ToolActivateState { get; set; }

		void SetFocusedInteractable(Interactable interactable);
	}
	public class PinchStateModule
	{
		private enum PinchState
		{
			None,
			PinchDown,
			PinchStay,
			PinchUp
		}

		private const float PINCH_STRENGTH_THRESHOLD = 1f;

		private PinchState _currPinchState;

		private Interactable _firstFocusedInteractable;

		public bool PinchUpAndDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchUp)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchSteadyOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchStay)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchDown)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public PinchStateModule()
		{
			_currPinchState = PinchState.None;
			_firstFocusedInteractable = null;
		}

		public void UpdateState(OVRHand hand, Interactable currFocusedInteractable)
		{
			float fingerPinchStrength = hand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
			bool flag = Mathf.Abs(1f - fingerPinchStrength) < Mathf.Epsilon;
			switch (_currPinchState)
			{
			case PinchState.PinchUp:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					if (currFocusedInteractable != _firstFocusedInteractable)
					{
						_firstFocusedInteractable = null;
					}
				}
				else
				{
					_currPinchState = PinchState.None;
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchStay:
				if (!flag)
				{
					_currPinchState = PinchState.PinchUp;
				}
				if (currFocusedInteractable != _firstFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchDown:
				_currPinchState = (flag ? PinchState.PinchStay : PinchState.PinchUp);
				if (_firstFocusedInteractable != currFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			default:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					_firstFocusedInteractable = currFocusedInteractable;
				}
				break;
			}
		}
	}
	public class RayTool : InteractableTool
	{
		private const float MINIMUM_RAY_CAST_DISTANCE = 0.8f;

		private const float COLLIDER_RADIUS = 0.01f;

		private const int NUM_MAX_PRIMARY_HITS = 10;

		private const int NUM_MAX_SECONDARY_HITS = 25;

		private const int NUM_COLLIDERS_TO_TEST = 20;

		[SerializeField]
		private RayToolView _rayToolView;

		[Range(0f, 45f)]
		[SerializeField]
		private float _coneAngleDegrees = 20f;

		[SerializeField]
		private float _farFieldMaxDistance = 5f;

		private PinchStateModule _pinchStateModule = new PinchStateModule();

		private Interactable _focusedInteractable;

		private Collider[] _collidersOverlapped = new Collider[20];

		private Interactable _currInteractableCastedAgainst;

		private float _coneAngleReleaseDegrees;

		private RaycastHit[] _primaryHits = new RaycastHit[10];

		private Collider[] _secondaryOverlapResults = new Collider[25];

		private bool _initialized;

		public override InteractableToolTags ToolTags => InteractableToolTags.Ray;

		public override ToolInputState ToolInputState
		{
			get
			{
				if (_pinchStateModule.PinchDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDown;
				}
				if (_pinchStateModule.PinchSteadyOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDownStay;
				}
				if (_pinchStateModule.PinchUpAndDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputUp;
				}
				return ToolInputState.Inactive;
			}
		}

		public override bool IsFarFieldTool => true;

		public override bool EnableState
		{
			get
			{
				return _rayToolView.EnableState;
			}
			set
			{
				_rayToolView.EnableState = value;
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_rayToolView.InteractableTool = this;
			_coneAngleReleaseDegrees = _coneAngleDegrees * 1.2f;
			_initialized = true;
		}

		private void OnDestroy()
		{
			if (InteractableToolsInputRouter.Instance != null)
			{
				InteractableToolsInputRouter.Instance.UnregisterInteractableTool(this);
			}
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _initialized)
			{
				OVRHand oVRHand = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand);
				Transform pointerPose = oVRHand.PointerPose;
				base.transform.position = pointerPose.position;
				base.transform.rotation = pointerPose.rotation;
				Vector3 interactionPosition = base.InteractionPosition;
				Vector3 position = base.transform.position;
				base.Velocity = (position - interactionPosition) / Time.deltaTime;
				base.InteractionPosition = position;
				_pinchStateModule.UpdateState(oVRHand, _focusedInteractable);
				_rayToolView.ToolActivateState = _pinchStateModule.PinchSteadyOnFocusedObject || _pinchStateModule.PinchDownOnFocusedObject;
			}
		}

		private Vector3 GetRayCastOrigin()
		{
			return base.transform.position + 0.8f * base.transform.forward;
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			if (!_initialized)
			{
				return _currentIntersectingObjects;
			}
			if (_currInteractableCastedAgainst != null && HasRayReleasedInteractable(_currInteractableCastedAgainst))
			{
				_currInteractableCastedAgainst = null;
			}
			if (_currInteractableCastedAgainst == null)
			{
				_currentIntersectingObjects.Clear();
				_currInteractableCastedAgainst = FindTargetInteractable();
				if (_currInteractableCastedAgainst != null)
				{
					int num = Physics.OverlapSphereNonAlloc(_currInteractableCastedAgainst.transform.position, 0.01f, _collidersOverlapped);
					for (int i = 0; i < num; i++)
					{
						ColliderZone component = _collidersOverlapped[i].GetComponent<ColliderZone>();
						if (component != null)
						{
							Interactable parentInteractable = component.ParentInteractable;
							if (!(parentInteractable == null) && !(parentInteractable != _currInteractableCastedAgainst))
							{
								InteractableCollisionInfo item = new InteractableCollisionInfo(component, component.CollisionDepth, this);
								_currentIntersectingObjects.Add(item);
							}
						}
					}
					if (_currentIntersectingObjects.Count == 0)
					{
						_currInteractableCastedAgainst = null;
					}
				}
			}
			return _currentIntersectingObjects;
		}

		private bool HasRayReleasedInteractable(Interactable focusedInteractable)
		{
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			float num = Mathf.Cos(_coneAngleReleaseDegrees * ((float)Math.PI / 180f));
			Vector3 lhs = focusedInteractable.transform.position - position;
			lhs.Normalize();
			return Vector3.Dot(lhs, forward) < num;
		}

		private Interactable FindTargetInteractable()
		{
			Vector3 rayCastOrigin = GetRayCastOrigin();
			Vector3 forward = base.transform.forward;
			Interactable interactable = null;
			interactable = FindPrimaryRaycastHit(rayCastOrigin, forward);
			if (interactable == null)
			{
				interactable = FindInteractableViaConeTest(rayCastOrigin, forward);
			}
			return interactable;
		}

		private Interactable FindPrimaryRaycastHit(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			int num = Physics.RaycastNonAlloc(new Ray(rayOrigin, rayDirection), _primaryHits, float.PositiveInfinity);
			float num2 = 0f;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = _primaryHits[i];
				ColliderZone component = raycastHit.transform.GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					float magnitude = (parentInteractable.transform.position - rayOrigin).magnitude;
					if (interactable == null || magnitude < num2)
					{
						interactable = parentInteractable;
						num2 = magnitude;
					}
				}
			}
			return interactable;
		}

		private Interactable FindInteractableViaConeTest(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			float num = 0f;
			float num2 = Mathf.Cos(_coneAngleDegrees * ((float)Math.PI / 180f));
			float num3 = Mathf.Tan((float)Math.PI / 180f * _coneAngleDegrees * 0.5f) * _farFieldMaxDistance;
			int num4 = Physics.OverlapBoxNonAlloc(rayOrigin + rayDirection * _farFieldMaxDistance * 0.5f, new Vector3(num3, num3, _farFieldMaxDistance * 0.5f), _secondaryOverlapResults, base.transform.rotation);
			for (int i = 0; i < num4; i++)
			{
				ColliderZone component = _secondaryOverlapResults[i].GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					Vector3 lhs = parentInteractable.transform.position - rayOrigin;
					float magnitude = lhs.magnitude;
					lhs /= magnitude;
					if (!(Vector3.Dot(lhs, rayDirection) < num2) && (interactable == null || magnitude < num))
					{
						interactable = parentInteractable;
						num = magnitude;
					}
				}
			}
			return interactable;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
			_rayToolView.SetFocusedInteractable(focusedInteractable);
			_focusedInteractable = focusedInteractable;
		}

		public override void DeFocus()
		{
			_rayToolView.SetFocusedInteractable(null);
			_focusedInteractable = null;
		}
	}
	public class RayToolView : MonoBehaviour, InteractableToolView
	{
		private const int NUM_RAY_LINE_POSITIONS = 25;

		private const float DEFAULT_RAY_CAST_DISTANCE = 3f;

		[SerializeField]
		private Transform _targetTransform;

		[SerializeField]
		private LineRenderer _lineRenderer;

		private bool _toolActivateState;

		private Transform _focusedTransform;

		private Vector3[] linePositions = new Vector3[25];

		private Gradient _oldColorGradient;

		private Gradient _highLightColorGradient;

		public bool EnableState
		{
			get
			{
				return _lineRenderer.enabled;
			}
			set
			{
				_targetTransform.gameObject.SetActive(value);
				_lineRenderer.enabled = value;
			}
		}

		public bool ToolActivateState
		{
			get
			{
				return _toolActivateState;
			}
			set
			{
				_toolActivateState = value;
				_lineRenderer.colorGradient = (_toolActivateState ? _highLightColorGradient : _oldColorGradient);
			}
		}

		public InteractableTool InteractableTool { get; set; }

		private void Awake()
		{
			_lineRenderer.positionCount = 25;
			_oldColorGradient = _lineRenderer.colorGradient;
			_highLightColorGradient = new Gradient();
			_highLightColorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 0f),
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
			if (interactable == null)
			{
				_focusedTransform = null;
			}
			else
			{
				_focusedTransform = interactable.transform;
			}
		}

		private void Update()
		{
			Vector3 position = InteractableTool.ToolTransform.position;
			Vector3 forward = InteractableTool.ToolTransform.forward;
			Vector3 vector = ((_focusedTransform != null) ? _focusedTransform.position : (position + forward * 3f));
			float magnitude = (vector - position).magnitude;
			Vector3 p = position;
			Vector3 p2 = position + forward * magnitude * 0.3333333f;
			Vector3 p3 = position + forward * magnitude * (2f / 3f);
			Vector3 p4 = vector;
			for (int i = 0; i < 25; i++)
			{
				linePositions[i] = GetPointOnBezierCurve(p, p2, p3, p4, (float)i / 25f);
			}
			_lineRenderer.SetPositions(linePositions);
			_targetTransform.position = vector;
		}

		public static Vector3 GetPointOnBezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return num * num2 * p0 + 3f * num2 * t * p1 + 3f * num * num3 * p2 + t * num3 * p3;
		}
	}
	public class DistanceGrabberSample : MonoBehaviour
	{
		private bool useSpherecast;

		private bool allowGrabThroughWalls;

		[SerializeField]
		private DistanceGrabber[] m_grabbers;

		public bool UseSpherecast
		{
			get
			{
				return useSpherecast;
			}
			set
			{
				useSpherecast = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].UseSpherecast = useSpherecast;
				}
			}
		}

		public bool AllowGrabThroughWalls
		{
			get
			{
				return allowGrabThroughWalls;
			}
			set
			{
				allowGrabThroughWalls = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].m_preventGrabThroughWalls = !allowGrabThroughWalls;
				}
			}
		}

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("Distance Grab Sample");
			DebugUIBuilder.instance.AddToggle("Use Spherecasting", ToggleSphereCasting, useSpherecast);
			DebugUIBuilder.instance.AddToggle("Grab Through Walls", ToggleGrabThroughWalls, allowGrabThroughWalls);
			DebugUIBuilder.instance.Show();
			float displayFrequency = OVRManager.display.displayFrequency;
			if (displayFrequency > 0.1f)
			{
				UnityEngine.Debug.Log("Setting Time.fixedDeltaTime to: " + 1f / displayFrequency);
				Time.fixedDeltaTime = 1f / displayFrequency;
			}
		}

		public void ToggleSphereCasting(Toggle t)
		{
			UseSpherecast = !UseSpherecast;
		}

		public void ToggleGrabThroughWalls(Toggle t)
		{
			AllowGrabThroughWalls = !AllowGrabThroughWalls;
		}
	}
	public class ControllerBoxController : MonoBehaviour
	{
		[SerializeField]
		private TrainLocomotive _locomotive;

		[SerializeField]
		private CowController _cowController;

		private void Awake()
		{
		}

		public void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.StartStopStateChanged();
			}
		}

		public void DecreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.DecreaseSpeedStateChanged();
			}
		}

		public void IncreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.IncreaseSpeedStateChanged();
			}
		}

		public void SmokeButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.SmokeButtonStateChanged();
			}
		}

		public void WhistleButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.WhistleButtonStateChanged();
			}
		}

		public void ReverseButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.ReverseButtonStateChanged();
			}
		}

		public void SwitchVisualization(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				HandsManager.Instance.SwitchVisualization();
			}
		}

		public void GoMoo(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_cowController.GoMooCowGo();
			}
		}
	}
	public class CowController : MonoBehaviour
	{
		[SerializeField]
		private Animation _cowAnimation;

		[SerializeField]
		private AudioSource _mooCowAudioSource;

		private void Start()
		{
		}

		public void PlayMooSound()
		{
			_mooCowAudioSource.timeSamples = 0;
			_mooCowAudioSource.Play();
		}

		public void GoMooCowGo()
		{
			_cowAnimation.Rewind();
			_cowAnimation.Play();
		}
	}
	public class PanelHMDFollower : MonoBehaviour
	{
		private const float TOTAL_DURATION = 3f;

		private const float HMD_MOVEMENT_THRESHOLD = 0.3f;

		[SerializeField]
		private float _maxDistance = 0.3f;

		[SerializeField]
		private float _minDistance = 0.05f;

		[SerializeField]
		private float _minZDistance = 0.05f;

		private OVRCameraRig _cameraRig;

		private Vector3 _panelInitialPosition = Vector3.zero;

		private Coroutine _coroutine;

		private Vector3 _prevPos = Vector3.zero;

		private Vector3 _lastMovedToPos = Vector3.zero;

		private void Awake()
		{
			_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			_panelInitialPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 position = _cameraRig.centerEyeAnchor.position;
			_ = base.transform.position;
			float num = Vector3.Distance(position, _lastMovedToPos);
			float num2 = (_cameraRig.centerEyeAnchor.position - _prevPos).magnitude / Time.deltaTime;
			Vector3 vector = base.transform.position - position;
			float magnitude = vector.magnitude;
			if ((num > _maxDistance || _minZDistance > vector.z || _minDistance > magnitude) && num2 < 0.3f && _coroutine == null && _coroutine == null)
			{
				_coroutine = StartCoroutine(LerpToHMD());
			}
			_prevPos = _cameraRig.centerEyeAnchor.position;
		}

		private Vector3 CalculateIdealAnchorPosition()
		{
			return _cameraRig.centerEyeAnchor.position + _panelInitialPosition;
		}

		private IEnumerator LerpToHMD()
		{
			Vector3 newPanelPosition = CalculateIdealAnchorPosition();
			_lastMovedToPos = _cameraRig.centerEyeAnchor.position;
			float startTime = Time.time;
			float endTime = Time.time + 3f;
			while (Time.time < endTime)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, newPanelPosition, (Time.time - startTime) / 3f);
				yield return null;
			}
			base.transform.position = newPanelPosition;
			_coroutine = null;
		}
	}
	public class SelectionCylinder : MonoBehaviour
	{
		public enum SelectionState
		{
			Off,
			Selected,
			Highlighted
		}

		[SerializeField]
		private MeshRenderer _selectionMeshRenderer;

		private static int _colorId = Shader.PropertyToID("_Color");

		private Material[] _selectionMaterials;

		private Color[] _defaultSelectionColors;

		private Color[] _highlightColors;

		private SelectionState _currSelectionState;

		public SelectionState CurrSelectionState
		{
			get
			{
				return _currSelectionState;
			}
			set
			{
				SelectionState currSelectionState = _currSelectionState;
				_currSelectionState = value;
				if (currSelectionState != _currSelectionState)
				{
					if (_currSelectionState > SelectionState.Off)
					{
						_selectionMeshRenderer.enabled = true;
						AffectSelectionColor((_currSelectionState == SelectionState.Selected) ? _defaultSelectionColors : _highlightColors);
					}
					else
					{
						_selectionMeshRenderer.enabled = false;
					}
				}
			}
		}

		private void Awake()
		{
			_selectionMaterials = _selectionMeshRenderer.materials;
			int num = _selectionMaterials.Length;
			_defaultSelectionColors = new Color[num];
			_highlightColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				_defaultSelectionColors[i] = _selectionMaterials[i].GetColor(_colorId);
				_highlightColors[i] = new Color(1f, 1f, 1f, _defaultSelectionColors[i].a);
			}
			CurrSelectionState = SelectionState.Off;
		}

		private void OnDestroy()
		{
			if (_selectionMaterials == null)
			{
				return;
			}
			Material[] selectionMaterials = _selectionMaterials;
			foreach (Material material in selectionMaterials)
			{
				if (material != null)
				{
					UnityEngine.Object.Destroy(material);
				}
			}
		}

		private void AffectSelectionColor(Color[] newColors)
		{
			int num = newColors.Length;
			for (int i = 0; i < num; i++)
			{
				_selectionMaterials[i].SetColor(_colorId, newColors[i]);
			}
		}
	}
	public class TrackSegment : MonoBehaviour
	{
		public enum SegmentType
		{
			Straight,
			LeftTurn,
			RightTurn,
			Switch
		}

		[SerializeField]
		private SegmentType _segmentType;

		[SerializeField]
		private MeshFilter _straight;

		[SerializeField]
		private MeshFilter _leftTurn;

		[SerializeField]
		private MeshFilter _rightTurn;

		private float _gridSize = 0.8f;

		private int _subDivCount = 20;

		private const float _originalGridSize = 0.8f;

		private const float _trackWidth = 0.15f;

		private GameObject _mesh;

		private Pose _p1 = new Pose();

		private Pose _p2 = new Pose();

		private Pose _endPose = new Pose();

		public float StartDistance { get; set; }

		public float GridSize
		{
			get
			{
				return _gridSize;
			}
			private set
			{
				_gridSize = value;
			}
		}

		public int SubDivCount
		{
			get
			{
				return _subDivCount;
			}
			set
			{
				_subDivCount = value;
			}
		}

		public SegmentType Type => _segmentType;

		public Pose EndPose
		{
			get
			{
				UpdatePose(SegmentLength, _endPose);
				return _endPose;
			}
		}

		public float Radius => 0.5f * GridSize;

		public float SegmentLength
		{
			get
			{
				switch (Type)
				{
				case SegmentType.Straight:
					return GridSize;
				case SegmentType.LeftTurn:
				case SegmentType.RightTurn:
					return (float)Math.PI / 2f * Radius;
				default:
					return 1f;
				}
			}
		}

		public float setGridSize(float size)
		{
			GridSize = size;
			return GridSize / 0.8f;
		}

		private void Awake()
		{
		}

		public void UpdatePose(float distanceIntoSegment, Pose pose)
		{
			if (Type == SegmentType.Straight)
			{
				pose.Position = base.transform.position + distanceIntoSegment * base.transform.forward;
				pose.Rotation = base.transform.rotation;
			}
			else if (Type == SegmentType.LeftTurn)
			{
				float num = distanceIntoSegment / SegmentLength;
				float num2 = (float)Math.PI / 2f * num;
				Vector3 position = new Vector3(Radius * Mathf.Cos(num2) - Radius, 0f, Radius * Mathf.Sin(num2));
				Quaternion quaternion = Quaternion.Euler(0f, (0f - num2) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position);
				pose.Rotation = base.transform.rotation * quaternion;
			}
			else if (Type == SegmentType.RightTurn)
			{
				float num3 = (float)Math.PI - (float)Math.PI / 2f * distanceIntoSegment / SegmentLength;
				Vector3 position2 = new Vector3(Radius * Mathf.Cos(num3) + Radius, 0f, Radius * Mathf.Sin(num3));
				Quaternion quaternion2 = Quaternion.Euler(0f, ((float)Math.PI - num3) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position2);
				pose.Rotation = base.transform.rotation * quaternion2;
			}
			else
			{
				pose.Position = Vector3.zero;
				pose.Rotation = Quaternion.identity;
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			UnityEngine.Object.Destroy(_mesh);
		}

		private void DrawDebugLines()
		{
			for (int i = 1; i < SubDivCount + 1; i++)
			{
				float num = SegmentLength / (float)SubDivCount;
				UpdatePose((float)(i - 1) * num, _p1);
				UpdatePose((float)i * num, _p2);
				float num2 = 0.075f;
				UnityEngine.Debug.DrawLine(_p1.Position + num2 * (_p1.Rotation * Vector3.right), _p2.Position + num2 * (_p2.Rotation * Vector3.right));
				UnityEngine.Debug.DrawLine(_p1.Position - num2 * (_p1.Rotation * Vector3.right), _p2.Position - num2 * (_p2.Rotation * Vector3.right));
			}
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position + 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
		}

		public void RegenerateTrackAndMesh()
		{
			if (base.transform.childCount > 0 && !_mesh)
			{
				_mesh = base.transform.GetChild(0).gameObject;
			}
			if ((bool)_mesh)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
			}
			if (_segmentType == SegmentType.LeftTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_leftTurn.gameObject);
			}
			else if (_segmentType == SegmentType.RightTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_rightTurn.gameObject);
			}
			else
			{
				_mesh = UnityEngine.Object.Instantiate(_straight.gameObject);
			}
			_mesh.transform.SetParent(base.transform, worldPositionStays: false);
			_mesh.transform.position += GridSize / 2f * base.transform.forward;
			_mesh.transform.localScale = new Vector3(GridSize / 0.8f, GridSize / 0.8f, GridSize / 0.8f);
		}
	}
	public class TrainButtonVisualController : MonoBehaviour
	{
		private const float LERP_TO_OLD_POS_DURATION = 1f;

		private const float LOCAL_SIZE_HALVED = 0.5f;

		[SerializeField]
		private MeshRenderer _meshRenderer;

		[SerializeField]
		private MeshRenderer _glowRenderer;

		[SerializeField]
		private ButtonController _buttonController;

		[SerializeField]
		private Color _buttonContactColor = new Color(0.51f, 0.78f, 0.92f, 1f);

		[SerializeField]
		private Color _buttonActionColor = new Color(0.24f, 0.72f, 0.98f, 1f);

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _actionSoundEffect;

		[SerializeField]
		private Transform _buttonContactTransform;

		[SerializeField]
		private float _contactMaxDisplacementDistance = 0.0141f;

		private Material _buttonMaterial;

		private Color _buttonDefaultColor;

		private int _materialColorId;

		private bool _buttonInContactOrActionStates;

		private Coroutine _lerpToOldPositionCr;

		private Vector3 _oldPosition;

		private void Awake()
		{
			_materialColorId = Shader.PropertyToID("_Color");
			_buttonMaterial = _meshRenderer.material;
			_buttonDefaultColor = _buttonMaterial.GetColor(_materialColorId);
			_oldPosition = base.transform.localPosition;
		}

		private void OnDestroy()
		{
			if (_buttonMaterial != null)
			{
				UnityEngine.Object.Destroy(_buttonMaterial);
			}
		}

		private void OnEnable()
		{
			_buttonController.InteractableStateChanged.AddListener(InteractableStateChanged);
			_buttonController.ContactZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonController.ActionZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonInContactOrActionStates = false;
		}

		private void OnDisable()
		{
			if (_buttonController != null)
			{
				_buttonController.InteractableStateChanged.RemoveListener(InteractableStateChanged);
				_buttonController.ContactZoneEvent -= ActionOrInContactZoneStayEvent;
				_buttonController.ActionZoneEvent -= ActionOrInContactZoneStayEvent;
			}
		}

		private void ActionOrInContactZoneStayEvent(ColliderZoneArgs collisionArgs)
		{
			if (_buttonInContactOrActionStates && !collisionArgs.CollidingTool.IsFarFieldTool)
			{
				Vector3 localScale = _buttonContactTransform.localScale;
				Vector3 interactionPosition = collisionArgs.CollidingTool.InteractionPosition;
				float num = (_buttonContactTransform.InverseTransformPoint(interactionPosition) - 0.5f * Vector3.one).y * localScale.y;
				if (num > 0f - _contactMaxDisplacementDistance && num <= 0f)
				{
					base.transform.localPosition = new Vector3(_oldPosition.x, _oldPosition.y + num, _oldPosition.z);
				}
			}
		}

		private void InteractableStateChanged(InteractableStateArgs obj)
		{
			_buttonInContactOrActionStates = false;
			_glowRenderer.gameObject.SetActive(obj.NewInteractableState > InteractableState.Default);
			switch (obj.NewInteractableState)
			{
			case InteractableState.ContactState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonContactColor);
				_buttonInContactOrActionStates = true;
				break;
			case InteractableState.ProximityState:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			case InteractableState.ActionState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonActionColor);
				PlaySound(_actionSoundEffect);
				_buttonInContactOrActionStates = true;
				break;
			default:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			}
		}

		private void PlaySound(AudioClip clip)
		{
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}

		private void StopResetLerping()
		{
			if (_lerpToOldPositionCr != null)
			{
				StopCoroutine(_lerpToOldPositionCr);
			}
		}

		private void LerpToOldPosition()
		{
			if (!((base.transform.localPosition - _oldPosition).sqrMagnitude < Mathf.Epsilon))
			{
				StopResetLerping();
				_lerpToOldPositionCr = StartCoroutine(ResetPosition());
			}
		}

		private IEnumerator ResetPosition()
		{
			float startTime = Time.time;
			float endTime = Time.time + 1f;
			while (Time.time < endTime)
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, _oldPosition, (Time.time - startTime) / 1f);
				yield return null;
			}
			base.transform.localPosition = _oldPosition;
			_lerpToOldPositionCr = null;
		}
	}
	public class TrainCar : TrainCarBase
	{
		[SerializeField]
		private TrainCarBase _parentLocomotive;

		[SerializeField]
		protected float _distanceBehindParent = 0.1f;

		public float DistanceBehindParentScaled => scale * _distanceBehindParent;

		protected override void Awake()
		{
			base.Awake();
		}

		public override void UpdatePosition()
		{
			base.Distance = _parentLocomotive.Distance - DistanceBehindParentScaled;
			UpdateCarPosition();
			RotateCarWheels();
		}
	}
	public abstract class TrainCarBase : MonoBehaviour
	{
		private static Vector3 OFFSET = new Vector3(0f, 0.0195f, 0f);

		private const float WHEEL_RADIUS = 0.027f;

		private const float TWO_PI = (float)Math.PI * 2f;

		[SerializeField]
		protected Transform _frontWheels;

		[SerializeField]
		protected Transform _rearWheels;

		[SerializeField]
		protected TrainTrack _trainTrack;

		[SerializeField]
		protected Transform[] _individualWheels;

		protected float scale = 1f;

		private Pose _frontPose = new Pose();

		private Pose _rearPose = new Pose();

		public float Distance { get; protected set; }

		public float Scale
		{
			get
			{
				return scale;
			}
			set
			{
				scale = value;
			}
		}

		protected virtual void Awake()
		{
		}

		public void UpdatePose(float distance, TrainCarBase train, Pose pose)
		{
			distance = (train._trainTrack.TrackLength + distance) % train._trainTrack.TrackLength;
			if (distance < 0f)
			{
				distance += train._trainTrack.TrackLength;
			}
			TrackSegment segment = train._trainTrack.GetSegment(distance);
			float distanceIntoSegment = distance - segment.StartDistance;
			segment.UpdatePose(distanceIntoSegment, pose);
		}

		protected void UpdateCarPosition()
		{
			UpdatePose(Distance + _frontWheels.transform.localPosition.z * scale, this, _frontPose);
			UpdatePose(Distance + _rearWheels.transform.localPosition.z * scale, this, _rearPose);
			Vector3 vector = 0.5f * (_frontPose.Position + _rearPose.Position);
			Vector3 forward = _frontPose.Position - _rearPose.Position;
			base.transform.position = vector + OFFSET;
			base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
			_frontWheels.transform.rotation = _frontPose.Rotation;
			_rearWheels.transform.rotation = _rearPose.Rotation;
		}

		protected void RotateCarWheels()
		{
			float num = Distance / 0.027f % ((float)Math.PI * 2f);
			Transform[] individualWheels = _individualWheels;
			for (int i = 0; i < individualWheels.Length; i++)
			{
				individualWheels[i].localRotation = Quaternion.AngleAxis(57.29578f * num, Vector3.right);
			}
		}

		public abstract void UpdatePosition();
	}
	public class TrainCrossingController : MonoBehaviour
	{
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip[] _crossingSounds;

		[SerializeField]
		private MeshRenderer _lightSide1Renderer;

		[SerializeField]
		private MeshRenderer _lightSide2Renderer;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private Material _lightsSide1Mat;

		private Material _lightsSide2Mat;

		private int _colorId = Shader.PropertyToID("_Color");

		private Coroutine _xingAnimationCr;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_lightsSide1Mat = _lightSide1Renderer.material;
			_lightsSide2Mat = _lightSide2Renderer.material;
		}

		private void OnDestroy()
		{
			if (_lightsSide1Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide1Mat);
			}
			if (_lightsSide2Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide2Mat);
			}
		}

		public void CrossingButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				ActivateTrainCrossing();
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}

		private void ActivateTrainCrossing()
		{
			int num = _crossingSounds.Length - 1;
			AudioClip audioClip = _crossingSounds[(int)(UnityEngine.Random.value * (float)num)];
			_audioSource.clip = audioClip;
			_audioSource.timeSamples = 0;
			_audioSource.Play();
			if (_xingAnimationCr != null)
			{
				StopCoroutine(_xingAnimationCr);
			}
			_xingAnimationCr = StartCoroutine(AnimateCrossing(audioClip.length * 0.75f));
		}

		private IEnumerator AnimateCrossing(float animationLength)
		{
			ToggleLightObjects(enableState: true);
			float animationEndTime = Time.time + animationLength;
			float lightBlinkDuration = animationLength * 0.1f;
			float lightBlinkStartTime = Time.time;
			float lightBlinkEndTime = Time.time + lightBlinkDuration;
			Material lightToBlinkOn = _lightsSide1Mat;
			Material lightToBlinkOff = _lightsSide2Mat;
			Color onColor = new Color(1f, 1f, 1f, 1f);
			Color offColor = new Color(1f, 1f, 1f, 0f);
			while (Time.time < animationEndTime)
			{
				float t = (Time.time - lightBlinkStartTime) / lightBlinkDuration;
				lightToBlinkOn.SetColor(_colorId, Color.Lerp(offColor, onColor, t));
				lightToBlinkOff.SetColor(_colorId, Color.Lerp(onColor, offColor, t));
				if (Time.time > lightBlinkEndTime)
				{
					Material material = lightToBlinkOn;
					lightToBlinkOn = lightToBlinkOff;
					lightToBlinkOff = material;
					lightBlinkStartTime = Time.time;
					lightBlinkEndTime = Time.time + lightBlinkDuration;
				}
				yield return null;
			}
			ToggleLightObjects(enableState: false);
		}

		private void AffectMaterials(Material[] materials, Color newColor)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].SetColor(_colorId, newColor);
			}
		}

		private void ToggleLightObjects(bool enableState)
		{
			_lightSide1Renderer.gameObject.SetActive(enableState);
			_lightSide2Renderer.gameObject.SetActive(enableState);
		}
	}
	public class TrainLocomotive : TrainCarBase
	{
		private enum EngineSoundState
		{
			Start,
			AccelerateOrSetProperSpeed,
			Stop
		}

		private const float MIN_SPEED = 0.2f;

		private const float MAX_SPEED = 2.7f;

		private const float SMOKE_SPEED_MULTIPLIER = 8f;

		private const int MAX_PARTICLES_MULTIPLIER = 3;

		[SerializeField]
		[Range(0.2f, 2.7f)]
		protected float _initialSpeed;

		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private GameObject _decreaseSpeedButton;

		[SerializeField]
		private GameObject _increaseSpeedButton;

		[SerializeField]
		private GameObject _smokeButton;

		[SerializeField]
		private GameObject _whistleButton;

		[SerializeField]
		private GameObject _reverseButton;

		[SerializeField]
		private AudioSource _whistleAudioSource;

		[SerializeField]
		private AudioClip _whistleSound;

		[SerializeField]
		private AudioSource _engineAudioSource;

		[SerializeField]
		private AudioClip[] _accelerationSounds;

		[SerializeField]
		private AudioClip[] _decelerationSounds;

		[SerializeField]
		private AudioClip _startUpSound;

		[SerializeField]
		private AudioSource _smokeStackAudioSource;

		[SerializeField]
		private AudioClip _smokeSound;

		[SerializeField]
		private ParticleSystem _smoke1;

		[SerializeField]
		private ParticleSystem _smoke2;

		[SerializeField]
		private TrainCarBase[] _childCars;

		private bool _isMoving = true;

		private bool _reverse;

		private float _currentSpeed;

		private float _speedDiv;

		private float _standardRateOverTimeMultiplier;

		private int _standardMaxParticles;

		private Coroutine _startStopTrainCr;

		private void Start()
		{
			_standardRateOverTimeMultiplier = _smoke1.emission.rateOverTimeMultiplier;
			_standardMaxParticles = _smoke1.main.maxParticles;
			base.Distance = 0f;
			_speedDiv = 2.5f / (float)_accelerationSounds.Length;
			_currentSpeed = _initialSpeed;
			UpdateCarPosition();
			_smoke1.Stop();
			_startStopTrainCr = StartCoroutine(StartStopTrain(startTrain: true));
		}

		private void Update()
		{
			UpdatePosition();
		}

		public override void UpdatePosition()
		{
			if (_isMoving)
			{
				if (_trainTrack != null)
				{
					UpdateDistance();
					UpdateCarPosition();
					RotateCarWheels();
				}
				TrainCarBase[] childCars = _childCars;
				for (int i = 0; i < childCars.Length; i++)
				{
					childCars[i].UpdatePosition();
				}
			}
		}

		public void StartStopStateChanged()
		{
			if (_startStopTrainCr == null)
			{
				_startStopTrainCr = StartCoroutine(StartStopTrain(!_isMoving));
			}
		}

		private IEnumerator StartStopTrain(bool startTrain)
		{
			float endSpeed = (startTrain ? _initialSpeed : 0f);
			float timePeriodForSpeedChange2;
			if (startTrain)
			{
				_smoke1.Play();
				_isMoving = true;
				ParticleSystem.EmissionModule emission = _smoke1.emission;
				ParticleSystem.MainModule main = _smoke1.main;
				emission.rateOverTimeMultiplier = _standardRateOverTimeMultiplier;
				main.maxParticles = _standardMaxParticles;
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Start);
			}
			else
			{
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Stop);
			}
			_engineAudioSource.loop = false;
			timePeriodForSpeedChange2 *= 0.9f;
			float startTime = Time.time;
			float endTime = Time.time + timePeriodForSpeedChange2;
			float startSpeed = _currentSpeed;
			while (Time.time < endTime)
			{
				float num = (Time.time - startTime) / timePeriodForSpeedChange2;
				_currentSpeed = startSpeed * (1f - num) + endSpeed * num;
				UpdateSmokeEmissionBasedOnSpeed();
				yield return null;
			}
			_currentSpeed = endSpeed;
			_startStopTrainCr = null;
			_isMoving = startTrain;
			if (!_isMoving)
			{
				_smoke1.Stop();
				yield break;
			}
			_engineAudioSource.loop = true;
			PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
		}

		private float PlayEngineSound(EngineSoundState engineSoundState)
		{
			AudioClip audioClip = null;
			if (engineSoundState == EngineSoundState.Start)
			{
				audioClip = _startUpSound;
			}
			else
			{
				AudioClip[] obj = ((engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed) ? _accelerationSounds : _decelerationSounds);
				int num = obj.Length;
				int value = (int)Mathf.Round((_currentSpeed - 0.2f) / _speedDiv);
				audioClip = obj[Mathf.Clamp(value, 0, num - 1)];
			}
			if (_engineAudioSource.clip == audioClip && _engineAudioSource.isPlaying && engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed)
			{
				return 0f;
			}
			_engineAudioSource.clip = audioClip;
			_engineAudioSource.timeSamples = 0;
			_engineAudioSource.Play();
			return audioClip.length;
		}

		private void UpdateDistance()
		{
			float num = (_reverse ? (0f - _currentSpeed) : _currentSpeed);
			base.Distance = (base.Distance + num * Time.deltaTime) % _trainTrack.TrackLength;
		}

		public void DecreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed - _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		public void IncreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed + _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		private void UpdateSmokeEmissionBasedOnSpeed()
		{
			ParticleSystem.EmissionModule emission = _smoke1.emission;
			emission.rateOverTimeMultiplier = GetCurrentSmokeEmission();
			ParticleSystem.MainModule main = _smoke1.main;
			main.maxParticles = (int)Mathf.Lerp(_standardMaxParticles, _standardMaxParticles * 3, _currentSpeed / 2.5f);
		}

		private float GetCurrentSmokeEmission()
		{
			return Mathf.Lerp(_standardRateOverTimeMultiplier, _standardRateOverTimeMultiplier * 8f, _currentSpeed / 2.5f);
		}

		public void SmokeButtonStateChanged()
		{
			if (_isMoving)
			{
				_smokeStackAudioSource.clip = _smokeSound;
				_smokeStackAudioSource.timeSamples = 0;
				_smokeStackAudioSource.Play();
				_smoke2.time = 0f;
				_smoke2.Play();
			}
		}

		public void WhistleButtonStateChanged()
		{
			if (_whistleSound != null)
			{
				_whistleAudioSource.clip = _whistleSound;
				_whistleAudioSource.timeSamples = 0;
				_whistleAudioSource.Play();
			}
		}

		public void ReverseButtonStateChanged()
		{
			_reverse = !_reverse;
		}
	}
	public class TrainTrack : MonoBehaviour
	{
		[SerializeField]
		private float _gridSize = 0.5f;

		[SerializeField]
		private int _subDivCount = 20;

		[SerializeField]
		private Transform _segmentParent;

		[SerializeField]
		private Transform _trainParent;

		[SerializeField]
		private bool _regnerateTrackMeshOnAwake;

		private float _trainLength = -1f;

		private TrackSegment[] _trackSegments;

		public float TrackLength
		{
			get
			{
				return _trainLength;
			}
			private set
			{
				_trainLength = value;
			}
		}

		private void Awake()
		{
			Regenerate();
		}

		public TrackSegment GetSegment(float distance)
		{
			int childCount = _segmentParent.childCount;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment = _trackSegments[i];
				TrackSegment trackSegment2 = _trackSegments[(i + 1) % childCount];
				if (distance >= trackSegment.StartDistance && (distance < trackSegment2.StartDistance || i == childCount - 1))
				{
					return trackSegment;
				}
			}
			return null;
		}

		public void Regenerate()
		{
			_trackSegments = _segmentParent.GetComponentsInChildren<TrackSegment>();
			TrackLength = 0f;
			int childCount = _segmentParent.childCount;
			TrackSegment trackSegment = null;
			float scale = 0f;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment2 = _trackSegments[i];
				trackSegment2.SubDivCount = _subDivCount;
				scale = trackSegment2.setGridSize(_gridSize);
				if (trackSegment != null)
				{
					Pose endPose = trackSegment.EndPose;
					trackSegment2.transform.position = endPose.Position;
					trackSegment2.transform.rotation = endPose.Rotation;
					trackSegment2.StartDistance = TrackLength;
				}
				if (_regnerateTrackMeshOnAwake)
				{
					trackSegment2.RegenerateTrackAndMesh();
				}
				TrackLength += trackSegment2.SegmentLength;
				trackSegment = trackSegment2;
			}
			SetScale(scale);
		}

		private void SetScale(float ratio)
		{
			_trainParent.localScale = new Vector3(ratio, ratio, ratio);
			TrainCar[] componentsInChildren = _trainParent.GetComponentsInChildren<TrainCar>();
			_trainParent.GetComponentInChildren<TrainLocomotive>().Scale = ratio;
			TrainCar[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale = ratio;
			}
		}
	}
	public class Pose
	{
		public Vector3 Position;

		public Quaternion Rotation;

		public Pose()
		{
			Position = Vector3.zero;
			Rotation = Quaternion.identity;
		}

		public Pose(Vector3 position, Quaternion rotation)
		{
			Position = position;
			Rotation = rotation;
		}
	}
	public class WindmillBladesController : MonoBehaviour
	{
		private const float MAX_TIME = 1f;

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _windMillRotationSound;

		[SerializeField]
		private AudioClip _windMillStartSound;

		[SerializeField]
		private AudioClip _windMillStopSound;

		private float _currentSpeed;

		private Coroutine _lerpSpeedCoroutine;

		private Coroutine _audioChangeCr;

		private Quaternion _originalRotation;

		private float _rotAngle;

		public bool IsMoving { get; private set; }

		private void Start()
		{
			_originalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			_rotAngle += _currentSpeed * Time.deltaTime;
			if (_rotAngle > 360f)
			{
				_rotAngle = 0f;
			}
			base.transform.localRotation = _originalRotation * Quaternion.AngleAxis(_rotAngle, Vector3.forward);
		}

		public void SetMoveState(bool newMoveState, float goalSpeed)
		{
			IsMoving = newMoveState;
			if (_lerpSpeedCoroutine != null)
			{
				StopCoroutine(_lerpSpeedCoroutine);
			}
			_lerpSpeedCoroutine = StartCoroutine(LerpToSpeed(goalSpeed));
		}

		private IEnumerator LerpToSpeed(float goalSpeed)
		{
			float totalTime = 0f;
			float startSpeed = _currentSpeed;
			if (_audioChangeCr != null)
			{
				StopCoroutine(_audioChangeCr);
			}
			if (IsMoving)
			{
				_audioChangeCr = StartCoroutine(PlaySoundDelayed(_windMillStartSound, _windMillRotationSound, _windMillStartSound.length * 0.95f));
			}
			else
			{
				PlaySound(_windMillStopSound);
			}
			for (float num = Mathf.Abs(_currentSpeed - goalSpeed); num > Mathf.Epsilon; num = Mathf.Abs(_currentSpeed - goalSpeed))
			{
				_currentSpeed = Mathf.Lerp(startSpeed, goalSpeed, totalTime / 1f);
				totalTime += Time.deltaTime;
				yield return null;
			}
			_lerpSpeedCoroutine = null;
		}

		private IEnumerator PlaySoundDelayed(AudioClip initial, AudioClip clip, float timeDelayAfterInitial)
		{
			PlaySound(initial);
			yield return new WaitForSeconds(timeDelayAfterInitial);
			PlaySound(clip, loop: true);
		}

		private void PlaySound(AudioClip clip, bool loop = false)
		{
			_audioSource.loop = loop;
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}
	}
	public class WindmillController : MonoBehaviour
	{
		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private float _maxSpeed = 10f;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private WindmillBladesController _bladesRotation;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_bladesRotation = GetComponentInChildren<WindmillBladesController>();
			_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
		}

		private void OnEnable()
		{
			_startStopButton.GetComponent<Interactable>().InteractableStateChanged.AddListener(StartStopStateChanged);
		}

		private void OnDisable()
		{
			if (_startStopButton != null)
			{
				_startStopButton.GetComponent<Interactable>().InteractableStateChanged.RemoveListener(StartStopStateChanged);
			}
		}

		private void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				if (_bladesRotation.IsMoving)
				{
					_bladesRotation.SetMoveState(newMoveState: false, 0f);
				}
				else
				{
					_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
				}
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}
	}
	public enum EUiDisplayType
	{
		EUDT_WorldGeoQuad,
		EUDT_OverlayQuad,
		EUDT_None,
		EUDT_MaxDislayTypes
	}
	public class OVROverlaySample : MonoBehaviour
	{
		private bool inMenu;

		private const string ovrOverlayID = "OVROverlayID";

		private const string applicationID = "ApplicationID";

		private const string noneID = "NoneID";

		private Toggle applicationRadioButton;

		private Toggle noneRadioButton;

		[Header("App vs Compositor Comparison Settings")]
		public GameObject mainCamera;

		public GameObject uiCamera;

		public GameObject uiGeoParent;

		public GameObject worldspaceGeoParent;

		public OVROverlay cameraRenderOverlay;

		public OVROverlay renderingLabelOverlay;

		public Texture applicationLabelTexture;

		public Texture compositorLabelTexture;

		[Header("Level Loading Sim Settings")]
		public GameObject prefabForLevelLoadSim;

		public OVROverlay cubemapOverlay;

		public OVROverlay loadingTextQuadOverlay;

		public float distanceFromCamToLoadText;

		public float cubeSpawnRadius;

		public float heightBetweenItems;

		public int numObjectsPerLevel;

		public int numLevels;

		public int numLoopsTrigger = 500000000;

		private List<GameObject> spawnedCubes = new List<GameObject>();

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("OVROverlay Sample");
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("Level Loading Example");
			DebugUIBuilder.instance.AddButton("Simulate Level Load", TriggerLoad);
			DebugUIBuilder.instance.AddButton("Destroy Cubes", TriggerUnload);
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("OVROverlay vs. Application Render Comparison");
			DebugUIBuilder.instance.AddRadio("OVROverlay", "group", delegate(Toggle t)
			{
				RadioPressed("OVROverlayID", "group", t);
			}).GetComponentInChildren<Toggle>();
			applicationRadioButton = DebugUIBuilder.instance.AddRadio("Application", "group", delegate(Toggle t)
			{
				RadioPressed("ApplicationID", "group", t);
			}).GetComponentInChildren<Toggle>();
			noneRadioButton = DebugUIBuilder.instance.AddRadio("None", "group", delegate(Toggle t)
			{
				RadioPressed("NoneID", "group", t);
			}).GetComponentInChildren<Toggle>();
			DebugUIBuilder.instance.Show();
			CameraAndRenderTargetSetup();
			cameraRenderOverlay.enabled = true;
			cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
			spawnedCubes.Capacity = numObjectsPerLevel * numLevels;
		}

		private void Update()
		{
			if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
			{
				if (inMenu)
				{
					DebugUIBuilder.instance.Hide();
				}
				else
				{
					DebugUIBuilder.instance.Show();
				}
				inMenu = !inMenu;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				TriggerLoad();
			}
		}

		private void ActivateWorldGeo()
		{
			worldspaceGeoParent.SetActive(value: true);
			uiGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = applicationLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateWorldGeo");
		}

		private void ActivateOVROverlay()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: true);
			cameraRenderOverlay.enabled = true;
			uiGeoParent.SetActive(value: true);
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = compositorLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateOVROVerlay");
		}

		private void ActivateNone()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			uiGeoParent.SetActive(value: false);
			renderingLabelOverlay.enabled = false;
			UnityEngine.Debug.Log("Switched to ActivateNone");
		}

		private void TriggerLoad()
		{
			StartCoroutine(WaitforOVROverlay());
		}

		private IEnumerator WaitforOVROverlay()
		{
			Transform transform = mainCamera.transform;
			Transform obj = loadingTextQuadOverlay.transform;
			Vector3 position = transform.position + transform.forward * distanceFromCamToLoadText;
			position.y = transform.position.y;
			obj.position = position;
			cubemapOverlay.enabled = true;
			loadingTextQuadOverlay.enabled = true;
			noneRadioButton.isOn = true;
			yield return new WaitForSeconds(0.1f);
			ClearObjects();
			SimulateLevelLoad();
			cubemapOverlay.enabled = false;
			loadingTextQuadOverlay.enabled = false;
			yield return null;
		}

		private void TriggerUnload()
		{
			ClearObjects();
			applicationRadioButton.isOn = true;
		}

		private void CameraAndRenderTargetSetup()
		{
			float x = cameraRenderOverlay.transform.localScale.x;
			float y = cameraRenderOverlay.transform.localScale.y;
			float z = cameraRenderOverlay.transform.localScale.z;
			float num = 1440f;
			float num2 = 2560f * 0.5f;
			float num3 = mainCamera.GetComponent<Camera>().fieldOfView / 2f;
			float num4 = 2f * z * Mathf.Tan((float)Math.PI / 180f * num3);
			float num5 = num / num4 * x;
			float num6 = 0f;
			float num7 = num4 * mainCamera.GetComponent<Camera>().aspect;
			num6 = num2 / num7 * x;
			float orthographicSize = y / 2f;
			float aspect = x / y;
			uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;
			uiCamera.GetComponent<Camera>().aspect = aspect;
			if (uiCamera.GetComponent<Camera>().targetTexture != null)
			{
				uiCamera.GetComponent<Camera>().targetTexture.Release();
			}
			RenderTexture renderTexture = new RenderTexture((int)num6 * 2, (int)num5 * 2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
			UnityEngine.Debug.Log("Created RT of resolution w: " + num6 + " and h: " + num5);
			renderTexture.hideFlags = HideFlags.DontSave;
			renderTexture.useMipMap = true;
			renderTexture.filterMode = FilterMode.Trilinear;
			renderTexture.anisoLevel = 4;
			renderTexture.autoGenerateMips = true;
			uiCamera.GetComponent<Camera>().targetTexture = renderTexture;
			cameraRenderOverlay.textures[0] = renderTexture;
		}

		private void SimulateLevelLoad()
		{
			int num = 0;
			for (int i = 0; i < numLoopsTrigger; i++)
			{
				num++;
			}
			UnityEngine.Debug.Log("Finished " + num + " Loops");
			Vector3 position = mainCamera.transform.position;
			position.y = 0.5f;
			for (int j = 0; j < numLevels; j++)
			{
				for (int k = 0; k < numObjectsPerLevel; k++)
				{
					float f = (float)k * (float)Math.PI * 2f / (float)numObjectsPerLevel;
					float num2 = ((k % 2 == 0) ? 1.5f : 1f);
					Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * cubeSpawnRadius * num2;
					vector.y = (float)j * heightBetweenItems;
					GameObject gameObject = UnityEngine.Object.Instantiate(prefabForLevelLoadSim, vector + position, Quaternion.identity);
					Transform obj = gameObject.transform;
					obj.LookAt(position);
					Vector3 eulerAngles = obj.rotation.eulerAngles;
					eulerAngles.x = 0f;
					obj.rotation = Quaternion.Euler(eulerAngles);
					spawnedCubes.Add(gameObject);
				}
			}
		}

		private void ClearObjects()
		{
			for (int i = 0; i < spawnedCubes.Count; i++)
			{
				UnityEngine.Object.DestroyImmediate(spawnedCubes[i]);
			}
			spawnedCubes.Clear();
			GC.Collect();
		}

		public void RadioPressed(string radioLabel, string group, Toggle t)
		{
			if (string.Compare(radioLabel, "OVROverlayID") == 0)
			{
				ActivateOVROverlay();
			}
			else if (string.Compare(radioLabel, "ApplicationID") == 0)
			{
				ActivateWorldGeo();
			}
			else if (string.Compare(radioLabel, "NoneID") == 0)
			{
				ActivateNone();
			}
		}
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabber))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabber m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		private float m_collisionScaleCurrent;

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabber>();
		}

		private void Start()
		{
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnDestroy()
		{
			OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
			OVRManager.InputFocusLost -= OnInputFocusLost;
		}

		private void Update()
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			m_showAfterInputFocusAcquired.Clear();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].enabled)
				{
					componentsInChildren[i].enabled = false;
					m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
				}
			}
			CollisionEnable(enabled: false);
			m_restoreOnInputAcquired = true;
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = (isDown ? 1f : (-1f));
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool num = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (num)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float value = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat(m_animParamIndexFlex, value);
			float weight = ((!num || handPose.AllowPointing) ? m_pointBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexPoint, weight);
			float weight2 = ((!num || handPose.AllowThumbsUp) ? m_thumbsUpBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexThumb, weight2);
			float value2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			m_animator.SetFloat("Pinch", value2);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider obj = m_colliders[i];
					obj.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					obj.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider obj2 = m_colliders[j];
					obj2.enabled = false;
					obj2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
	public class TouchController : MonoBehaviour
	{
		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		private bool m_restoreOnInputAcquired;

		private void Update()
		{
			m_animator.SetFloat("Button 1", OVRInput.Get(OVRInput.Button.One, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Button 2", OVRInput.Get(OVRInput.Button.Two, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Joy X", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).x);
			m_animator.SetFloat("Joy Y", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).y);
			m_animator.SetFloat("Grip", OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller));
			m_animator.SetFloat("Trigger", OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller));
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			if (base.gameObject.activeInHierarchy)
			{
				base.gameObject.SetActive(value: false);
				m_restoreOnInputAcquired = true;
			}
		}

		private void OnInputFocusAcquired()
		{
			if (m_restoreOnInputAcquired)
			{
				base.gameObject.SetActive(value: true);
				m_restoreOnInputAcquired = false;
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			UnityEngine.Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				UnityEngine.Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private static int CalculateMaxEmittersSize()
		{
			return theAudioManager.maxSoundEmitters + 1;
		}

		private static bool ValidateEmitterIndex(int index)
		{
			if (index > -1)
			{
				return index < CalculateMaxEmittersSize();
			}
			return false;
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[CalculateMaxEmittersSize()];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < CalculateMaxEmittersSize(); i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
namespace Photon.Voice.DemoVoiceUI
{
	[RequireComponent(typeof(VoiceConnection))]
	public class DemoVoiceUI : MonoBehaviour
	{
		[SerializeField]
		private Text connectionStatusText;

		[SerializeField]
		private Text serverStatusText;

		[SerializeField]
		private Text roomStatusText;

		[SerializeField]
		private Text inputWarningText;

		[SerializeField]
		private Text packetLossWarningText;

		[SerializeField]
		private InputField localNicknameText;

		[SerializeField]
		private WebRtcAudioDsp voiceAudioPreprocessor;

		[SerializeField]
		private Toggle debugEchoToggle;

		[SerializeField]
		private Toggle reliableTransmissionToggle;

		[SerializeField]
		private GameObject webRtcDspGameObject;

		[SerializeField]
		private Toggle aecToggle;

		[SerializeField]
		private Toggle noiseSuppressionToggle;

		[SerializeField]
		private Toggle agcToggle;

		[SerializeField]
		private Toggle vadToggle;

		[SerializeField]
		private Toggle muteToggle;

		[SerializeField]
		private Toggle streamAudioClipToggle;

		[SerializeField]
		private Toggle dspToggle;

		[SerializeField]
		private Toggle photonVadToggle;

		public Transform RemoteVoicesPanel;

		private VoiceConnection voiceConnection;

		[SerializeField]
		private GameObject microphoneSetupGameObject;

		protected internal const string MutePropKey = "mute";

		private Color warningColor = new Color(0.9f, 0.5f, 0f, 1f);

		private Color okColor = new Color(0f, 0.6f, 0.2f, 1f);

		private void Awake()
		{
			voiceConnection = GetComponent<VoiceConnection>();
			InitToggles();
		}

		private void OnEnable()
		{
			voiceConnection.SpeakerLinked += OnSpeakerCreated;
			if (localNicknameText != null)
			{
				string @string = PlayerPrefs.GetString("vNick");
				if (!string.IsNullOrEmpty(@string))
				{
					localNicknameText.text = @string;
					voiceConnection.Client.NickName = @string;
				}
			}
		}

		private void OnDisable()
		{
			voiceConnection.SpeakerLinked -= OnSpeakerCreated;
		}

		private void OnSpeakerCreated(Speaker speaker)
		{
			speaker.gameObject.transform.SetParent(RemoteVoicesPanel, worldPositionStays: false);
			speaker.OnRemoteVoiceRemoveAction = (Action<Speaker>)Delegate.Combine(speaker.OnRemoteVoiceRemoveAction, new Action<Speaker>(OnRemoteVoiceRemove));
		}

		private void OnRemoteVoiceRemove(Speaker speaker)
		{
			if (speaker != null)
			{
				UnityEngine.Object.Destroy(speaker.gameObject);
			}
		}

		public void ToggleMute()
		{
			voiceConnection.PrimaryRecorder.TransmitEnabled = !muteToggle.isOn;
			voiceConnection.Client.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "mute", muteToggle.isOn } });
		}

		public void ToggleDebugEcho()
		{
			voiceConnection.PrimaryRecorder.DebugEchoMode = debugEchoToggle.isOn;
		}

		public void ToggleReliable()
		{
			voiceConnection.PrimaryRecorder.ReliableMode = reliableTransmissionToggle.isOn;
		}

		public void ToggleAEC()
		{
			voiceAudioPreprocessor.AEC = aecToggle.isOn;
		}

		public void ToggleNoiseSuppression()
		{
			voiceAudioPreprocessor.NoiseSuppression = noiseSuppressionToggle.isOn;
		}

		public void ToggleAGC()
		{
			voiceAudioPreprocessor.AGC = agcToggle.isOn;
		}

		public void ToggleVAD()
		{
			voiceAudioPreprocessor.VAD = vadToggle.isOn;
		}

		public void ToggleDsp()
		{
			voiceAudioPreprocessor.Bypass = !dspToggle.isOn;
			voiceAudioPreprocessor.enabled = dspToggle.isOn;
		}

		public void ToggleAudioClipStreaming()
		{
			microphoneSetupGameObject.SetActive(!streamAudioClipToggle.isOn);
			if (streamAudioClipToggle.isOn)
			{
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.AudioClip;
			}
			else
			{
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.Microphone;
			}
			if (voiceConnection.PrimaryRecorder.RequiresRestart)
			{
				voiceConnection.PrimaryRecorder.RestartRecording();
			}
		}

		public void TogglePhotonVAD()
		{
			voiceConnection.PrimaryRecorder.VoiceDetection = photonVadToggle.isOn;
		}

		public void UpdateSyncedNickname(string nickname)
		{
			nickname = nickname.Trim();
			if (!string.IsNullOrEmpty(nickname))
			{
				voiceConnection.Client.LocalPlayer.NickName = nickname;
				PlayerPrefs.SetString("vNick", nickname);
			}
		}

		public void JoinOrCreateRoom(string roomname)
		{
			roomname = roomname.Trim();
			ConnectAndJoin component = GetComponent<ConnectAndJoin>();
			if (!(component == null))
			{
				if (string.IsNullOrEmpty(roomname))
				{
					component.RoomName = string.Empty;
					component.RandomRoom = true;
				}
				else
				{
					component.RoomName = roomname;
					component.RandomRoom = false;
				}
				if (voiceConnection.Client.InRoom)
				{
					voiceConnection.Client.OpLeaveRoom(becomeInactive: false);
				}
				else if (!voiceConnection.Client.IsConnected)
				{
					voiceConnection.ConnectUsingSettings();
				}
			}
		}

		protected void Update()
		{
			connectionStatusText.text = voiceConnection.Client.State.ToString();
			serverStatusText.text = $"{voiceConnection.Client.CloudRegion}/{voiceConnection.Client.CurrentServerAddress}";
			string text = string.Empty;
			if (voiceConnection.Client.InRoom)
			{
				Dictionary<int, Photon.Realtime.Player>.ValueCollection values = voiceConnection.Client.CurrentRoom.Players.Values;
				if (values.Count > 1)
				{
					foreach (Photon.Realtime.Player item in values)
					{
						text += item.ToStringFull();
					}
				}
			}
			roomStatusText.text = ((voiceConnection.Client.CurrentRoom == null) ? string.Empty : $"{voiceConnection.Client.CurrentRoom.Name} {text}");
			if (voiceConnection.PrimaryRecorder.IsCurrentlyTransmitting)
			{
				float num = voiceConnection.PrimaryRecorder.LevelMeter.CurrentAvgAmp;
				if (num > 1f)
				{
					num /= 32768f;
				}
				if ((double)num > 0.1)
				{
					inputWarningText.text = "Input too loud!";
					inputWarningText.color = warningColor;
				}
				else
				{
					inputWarningText.text = string.Empty;
				}
			}
			if (voiceConnection.FramesReceivedPerSecond > 0f)
			{
				packetLossWarningText.text = $"{voiceConnection.FramesLostPercent:0.##}% Packet Loss";
				packetLossWarningText.color = ((voiceConnection.FramesLostPercent > 1f) ? warningColor : okColor);
			}
			else
			{
				packetLossWarningText.text = "(no data)";
			}
		}

		private void InitToggles()
		{
			if (voiceConnection != null && voiceConnection.PrimaryRecorder != null)
			{
				if (debugEchoToggle != null)
				{
					debugEchoToggle.isOn = voiceConnection.PrimaryRecorder.DebugEchoMode;
				}
				if (reliableTransmissionToggle != null)
				{
					reliableTransmissionToggle.isOn = voiceConnection.PrimaryRecorder.ReliableMode;
				}
				if (streamAudioClipToggle != null)
				{
					streamAudioClipToggle.isOn = voiceConnection.PrimaryRecorder.SourceType == Recorder.InputSourceType.AudioClip;
				}
				microphoneSetupGameObject.SetActive(!streamAudioClipToggle.isOn);
			}
			if (webRtcDspGameObject != null)
			{
				if (voiceAudioPreprocessor == null)
				{
					webRtcDspGameObject.SetActive(value: false);
					dspToggle.gameObject.SetActive(value: false);
					return;
				}
				dspToggle.gameObject.SetActive(value: true);
				dspToggle.isOn = !voiceAudioPreprocessor.Bypass && voiceAudioPreprocessor.enabled;
				webRtcDspGameObject.SetActive(dspToggle.isOn);
				if (aecToggle != null)
				{
					aecToggle.isOn = voiceAudioPreprocessor.AEC;
				}
				if (noiseSuppressionToggle != null)
				{
					noiseSuppressionToggle.isOn = voiceAudioPreprocessor.NoiseSuppression;
				}
				if (agcToggle != null)
				{
					agcToggle.isOn = voiceAudioPreprocessor.AGC;
				}
				if (vadToggle != null)
				{
					vadToggle.isOn = voiceAudioPreprocessor.VAD;
				}
			}
			else
			{
				dspToggle.gameObject.SetActive(value: false);
			}
		}
	}
	public struct MicRef
	{
		public Recorder.MicType MicType;

		public string Name;

		public int PhotonId;

		public MicRef(string name, int id)
		{
			MicType = Recorder.MicType.Photon;
			Name = name;
			PhotonId = id;
		}

		public MicRef(string name)
		{
			MicType = Recorder.MicType.Unity;
			Name = name;
			PhotonId = -1;
		}

		public override string ToString()
		{
			return $"Mic reference: {Name}";
		}
	}
	public class MicrophoneDropdownFiller : MonoBehaviour
	{
		[SerializeField]
		private Recorder recorder;

		[SerializeField]
		private Dropdown micDropdown;

		private List<MicRef> micOptions;

		[SerializeField]
		[FormerlySerializedAs("RefreshButton")]
		private GameObject refreshButton;

		[SerializeField]
		[FormerlySerializedAs("ToggleButton")]
		private GameObject toggleButton;

		private Toggle photonToggle;

		private void Awake()
		{
			photonToggle = toggleButton.GetComponentInChildren<Toggle>();
			RefreshMicrophones();
		}

		private void SetupMicDropdown()
		{
			micDropdown.ClearOptions();
			micOptions = new List<MicRef>();
			List<string> list = new List<string>();
			for (int i = 0; i < Microphone.devices.Length; i++)
			{
				string arg = Microphone.devices[i];
				micOptions.Add(new MicRef(arg));
				list.Add($"[Unity] {arg}");
			}
			micDropdown.AddOptions(list);
			micDropdown.onValueChanged.RemoveAllListeners();
			micDropdown.onValueChanged.AddListener(delegate
			{
				MicDropdownValueChanged(micOptions[micDropdown.value]);
			});
		}

		private void MicDropdownValueChanged(MicRef mic)
		{
			recorder.MicrophoneType = mic.MicType;
			switch (mic.MicType)
			{
			case Recorder.MicType.Unity:
				recorder.UnityMicrophoneDevice = mic.Name;
				break;
			case Recorder.MicType.Photon:
				recorder.PhotonMicrophoneDeviceId = mic.PhotonId;
				break;
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		private void SetCurrentValue()
		{
			if (micOptions == null)
			{
				UnityEngine.Debug.LogWarning("micOptions list is null");
				return;
			}
			bool flag = false;
			photonToggle.onValueChanged.RemoveAllListeners();
			photonToggle.isOn = recorder.MicrophoneType == Recorder.MicType.Photon;
			if (!flag)
			{
				photonToggle.onValueChanged.AddListener(PhotonMicToggled);
			}
			micDropdown.gameObject.SetActive(flag || recorder.MicrophoneType == Recorder.MicType.Unity);
			toggleButton.SetActive(!flag);
			refreshButton.SetActive(flag || recorder.MicrophoneType == Recorder.MicType.Unity);
			for (int i = 0; i < micOptions.Count; i++)
			{
				MicRef micRef = micOptions[i];
				if (recorder.MicrophoneType == micRef.MicType)
				{
					if (recorder.MicrophoneType == Recorder.MicType.Unity && Recorder.CompareUnityMicNames(micRef.Name, recorder.UnityMicrophoneDevice))
					{
						micDropdown.value = i;
						return;
					}
					if (recorder.MicrophoneType == Recorder.MicType.Photon && micRef.PhotonId == recorder.PhotonMicrophoneDeviceId)
					{
						micDropdown.value = i;
						return;
					}
				}
			}
			for (int j = 0; j < micOptions.Count; j++)
			{
				MicRef micRef2 = micOptions[j];
				if (recorder.MicrophoneType == micRef2.MicType)
				{
					if (recorder.MicrophoneType == Recorder.MicType.Unity)
					{
						micDropdown.value = j;
						recorder.UnityMicrophoneDevice = micRef2.Name;
						break;
					}
					if (recorder.MicrophoneType == Recorder.MicType.Photon)
					{
						micDropdown.value = j;
						recorder.PhotonMicrophoneDeviceId = micRef2.PhotonId;
						break;
					}
				}
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		public void PhotonMicToggled(bool on)
		{
			micDropdown.gameObject.SetActive(!on);
			refreshButton.SetActive(!on);
			if (on)
			{
				recorder.MicrophoneType = Recorder.MicType.Photon;
			}
			else
			{
				recorder.MicrophoneType = Recorder.MicType.Unity;
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		public void RefreshMicrophones()
		{
			SetupMicDropdown();
			SetCurrentValue();
		}

		private void PhotonVoiceCreated()
		{
			RefreshMicrophones();
		}
	}
	[RequireComponent(typeof(Speaker))]
	public class RemoteSpeakerUI : MonoBehaviour
	{
		[SerializeField]
		private Text nameText;

		[SerializeField]
		private Image remoteIsMuting;

		[SerializeField]
		private Image remoteIsTalking;

		private void Start()
		{
			nameText = GetComponentInChildren<Text>();
		}

		private void Update()
		{
			Speaker component = GetComponent<Speaker>();
			if (component.Actor != null)
			{
				string text = component.Actor.NickName;
				if (string.IsNullOrEmpty(text))
				{
					text = "user " + component.Actor.ActorNumber;
				}
				nameText.text = text;
				if (remoteIsMuting != null)
				{
					bool? flag = component.Actor.CustomProperties["mute"] as bool?;
					if (flag.HasValue)
					{
						remoteIsMuting.enabled = flag.Value;
					}
				}
				if (remoteIsTalking != null)
				{
					remoteIsTalking.enabled = component.IsPlaying;
				}
			}
			else
			{
				nameText.text = component.name;
			}
		}
	}
}
namespace Photon.Realtime.Demo
{
	public class ConnectAndJoinRandomLb : MonoBehaviour, IConnectionCallbacks, IMatchmakingCallbacks, ILobbyCallbacks
	{
		[SerializeField]
		private AppSettings appSettings = new AppSettings();

		private LoadBalancingClient lbc;

		private ConnectionHandler ch;

		public Text StateUiText;

		public void Start()
		{
			lbc = new LoadBalancingClient();
			lbc.AddCallbackTarget(this);
			lbc.SerializationProtocol = SerializationProtocol.GpBinaryV16;
			if (!lbc.ConnectUsingSettings(appSettings))
			{
				UnityEngine.Debug.LogError("Error while connecting");
			}
			ch = base.gameObject.GetComponent<ConnectionHandler>();
			if (ch != null)
			{
				ch.Client = lbc;
				ch.StartFallbackSendAckThread();
			}
		}

		public void Update()
		{
			LoadBalancingClient loadBalancingClient = lbc;
			if (loadBalancingClient != null)
			{
				loadBalancingClient.Service();
				Text stateUiText = StateUiText;
				string text = loadBalancingClient.State.ToString();
				if (stateUiText != null && !stateUiText.text.Equals(text))
				{
					stateUiText.text = "State: " + text;
				}
			}
		}

		public void OnConnected()
		{
		}

		public void OnConnectedToMaster()
		{
			UnityEngine.Debug.Log("OnConnectedToMaster");
			lbc.OpJoinRandomRoom();
		}

		public void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log(string.Concat("OnDisconnected(", cause, ")"));
		}

		public void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public void OnRegionListReceived(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionListReceived");
			regionHandler.PingMinimumOfRegions(OnRegionPingCompleted, null);
		}

		public void OnRoomListUpdate(List<RoomInfo> roomList)
		{
		}

		public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
		{
		}

		public void OnJoinedLobby()
		{
		}

		public void OnLeftLobby()
		{
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
			UnityEngine.Debug.Log("OnJoinedRoom");
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
			UnityEngine.Debug.Log("OnJoinRandomFailed");
			lbc.OpCreateRoom(new EnterRoomParams());
		}

		public void OnLeftRoom()
		{
		}

		private void OnRegionPingCompleted(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionPingCompleted " + regionHandler.BestRegion);
			UnityEngine.Debug.Log("RegionPingSummary: " + regionHandler.SummaryToCache);
			lbc.ConnectToRegionMaster(regionHandler.BestRegion.Code);
		}
	}
}
namespace Photon.Chat.UtilityScripts
{
	public class EventSystemSpawner : MonoBehaviour
	{
		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}
	}
	public class OnStartDelete : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextButtonTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private Text _text;

		public Selectable Selectable;

		public Color NormalColor = Color.white;

		public Color HoverColor = Color.black;

		public void Awake()
		{
			_text = GetComponent<Text>();
		}

		public void OnEnable()
		{
			_text.color = NormalColor;
		}

		public void OnDisable()
		{
			_text.color = NormalColor;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = HoverColor;
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = NormalColor;
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextToggleIsOnTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Toggle toggle;

		private Text _text;

		public Color NormalOnColor = Color.white;

		public Color NormalOffColor = Color.black;

		public Color HoverOnColor = Color.black;

		public Color HoverOffColor = Color.black;

		private bool isHover;

		public void OnEnable()
		{
			_text = GetComponent<Text>();
			OnValueChanged(toggle.isOn);
			toggle.onValueChanged.AddListener(OnValueChanged);
		}

		public void OnDisable()
		{
			toggle.onValueChanged.RemoveListener(OnValueChanged);
		}

		public void OnValueChanged(bool isOn)
		{
			_text.color = ((!isOn) ? (isHover ? NormalOffColor : NormalOffColor) : (isHover ? HoverOnColor : HoverOnColor));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHover = true;
			_text.color = (toggle.isOn ? HoverOnColor : HoverOffColor);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHover = false;
			_text.color = (toggle.isOn ? NormalOnColor : NormalOffColor);
		}
	}
}
namespace Photon.Pun.Demo.PunBasics
{
	public class OnlineStart : MonoBehaviourPunCallbacks
	{
		[Tooltip("The maximum number of players per room")]
		[SerializeField]
		private byte maxPlayersPerRoom = 4;

		public Text textoInfo;

		public Camera cam;

		private bool isConnecting;

		private string gameVersion = "888888";

		private Coroutine corutinaEsperarAmigo;

		private int contTicksEsperaAmigo;

		private void Awake()
		{
			PhotonNetwork.AutomaticallySyncScene = true;
			textoInfo.text = LanguageManager.instance.DameTexto("#Conectando", textoInfo);
		}

		private void Start()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				Connect();
			}
			else
			{
				CargarPartida();
			}
		}

		public void Connect()
		{
			isConnecting = true;
			if (PhotonNetwork.IsConnected)
			{
				LogFeedback("Joining Room...");
				PhotonNetwork.JoinRandomRoom();
			}
			else
			{
				LogFeedback("Connecting...");
				PhotonNetwork.GameVersion = gameVersion;
				PhotonNetwork.ConnectUsingSettings();
			}
		}

		private void LogFeedback(string message)
		{
			Debugs.Log(message);
		}

		public override void OnConnectedToMaster()
		{
			if (isConnecting)
			{
				LogFeedback("OnConnectedToMaster: Next -> try to Join Random Room");
				Debugs.Log("PUN Basics Tutorial/Launcher: OnConnectedToMaster() was called by PUN. Now this client is connected and could join a room.\n Calling: PhotonNetwork.JoinRandomRoom(); Operation will fail if no room found", 4);
				PhotonNetwork.JoinRandomRoom();
			}
		}

		public override void OnJoinRandomFailed(short returnCode, string message)
		{
			LogFeedback("<Color=Red>OnJoinRandomFailed</Color>: Next -> Create a new Room");
			Debugs.Log("PUN Basics Tutorial/Launcher:OnJoinRandomFailed() was called by PUN. No random room available, so we create one.\nCalling: PhotonNetwork.CreateRoom", 4);
			if (!PhotonNetwork.MirarSiPunCoincide(PhotonNetwork.versionPUNPartida))
			{
				textoInfo.text = LanguageManager.instance.DameTexto("#EsperandoSala", textoInfo);
				if (corutinaEsperarAmigo != null)
				{
					StopCoroutine(corutinaEsperarAmigo);
				}
				StartCoroutine(EsperarAlAmigo());
			}
			else
			{
				textoInfo.text = LanguageManager.instance.DameTexto("#CreandoSala", textoInfo);
				PhotonNetwork.CreateRoom(null, new Photon.Realtime.RoomOptions
				{
					MaxPlayers = maxPlayersPerRoom
				});
			}
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			LogFeedback("<Color=Red>OnDisconnected</Color> " + cause);
			UnityEngine.Debug.LogError("PUN Basics Tutorial/Launcher:Disconnected" + cause);
			isConnecting = false;
			if ((bool)LoadingCamera.instance)
			{
				LoadingCamera.instance.CargarEscena("MenuPrincipal");
			}
			else
			{
				SceneManager.LoadScene("MenuPrincipal");
			}
		}

		public override void OnJoinedRoom()
		{
			LogFeedback("<Color=Green>OnJoinedRoom</Color> with " + PhotonNetwork.CurrentRoom.PlayerCount + " Player(s)");
			Debugs.Log("PUN Basics Tutorial/Launcher: OnJoinedRoom() called by PUN. Now this client is in a room.\nFrom here on, your game would be running.", 4);
			if (PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				Debugs.Log("We load the 'Room for 1' ", 4);
				CargarPartida();
			}
		}

		private void CargarPartida()
		{
			string levelName = Config.mundo;
			if (Config.modoDeJuego == Config.ModosDeJuego.Online && Config.modoDePartida == Config.ModoDePartida.Competitivo)
			{
				levelName = Config.numJugadoresOnline switch
				{
					2 => "MundoOnline1", 
					4 => "MundoOnline2", 
					8 => "MundoOnline2", 
					_ => "MundoOnline1", 
				};
			}
			PhotonNetwork.LoadLevel(levelName);
		}

		private IEnumerator EsperarAlAmigo()
		{
			if (contTicksEsperaAmigo > 4)
			{
				LoadingCamera.instance.CargarEscena("MenuPrincipal");
				yield break;
			}
			contTicksEsperaAmigo++;
			float tiempo = 0f;
			while (tiempo < 5f)
			{
				bool flag = false;
				if ((bool)InputsController.instance)
				{
					flag = InputsController.instance.botonAtras;
				}
				if (flag)
				{
					LoadingCamera.instance.CargarEscena("MenuPrincipal");
					yield break;
				}
				tiempo += Time.unscaledDeltaTime;
				yield return null;
			}
			Connect();
			corutinaEsperarAmigo = null;
		}
	}
}
namespace LIV.SDK.Unity
{
	public static class Calibration
	{
		private const string ConfigFileName = "externalcamera.cfg";

		public static float X;

		public static float Y;

		public static float Z;

		public static float Yaw;

		public static float Pitch;

		public static float Roll;

		public static float FieldOfVision;

		public static float NearClip;

		public static float FarClip;

		public static float HMDOffset;

		public static float NearOffset;

		private static readonly FileSystemWatcher ConfigWatcher;

		public static Vector3 PositionOffset => new Vector3(X, Y, Z);

		public static Quaternion RotationOffset => Quaternion.Euler(Pitch, Yaw, Roll);

		public static event EventHandler Changed;

		static Calibration()
		{
			try
			{
				FileInfo fileInfo = new FileInfo("externalcamera.cfg");
				ConfigWatcher = new FileSystemWatcher(fileInfo.DirectoryName ?? "", fileInfo.Name)
				{
					NotifyFilter = NotifyFilters.LastWrite
				};
				ConfigWatcher.Changed += delegate
				{
					Read();
				};
				ConfigWatcher.EnableRaisingEvents = true;
			}
			catch
			{
			}
			Read();
		}

		private static void Reset()
		{
			X = (Y = (Z = 0f));
			Pitch = (Yaw = (Roll = 0f));
			FieldOfVision = 60f;
			NearClip = 0.01f;
			FarClip = 1000f;
			HMDOffset = 0f;
			NearOffset = 0f;
		}

		public static void Read()
		{
			Reset();
			string[] array = new string[0];
			try
			{
				array = File.ReadAllLines("externalcamera.cfg");
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarningFormat("LIV: Failed to read camera calibration from disk. Error: {0}", ex);
			}
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string[] array3 = array2[i].Split(new char[1] { '=' }, StringSplitOptions.RemoveEmptyEntries);
				if (array3.Length == 2)
				{
					switch (array3[0].ToLowerInvariant())
					{
					case "x":
						TryParseInvariantFloat(array3[1], out X);
						break;
					case "y":
						TryParseInvariantFloat(array3[1], out Y);
						break;
					case "z":
						TryParseInvariantFloat(array3[1], out Z);
						break;
					case "rx":
						TryParseInvariantFloat(array3[1], out Pitch);
						break;
					case "ry":
						TryParseInvariantFloat(array3[1], out Yaw);
						break;
					case "rz":
						TryParseInvariantFloat(array3[1], out Roll);
						break;
					case "fov":
						TryParseInvariantFloat(array3[1], out FieldOfVision);
						break;
					case "near":
						TryParseInvariantFloat(array3[1], out NearClip);
						break;
					case "far":
						TryParseInvariantFloat(array3[1], out FarClip);
						break;
					case "hmdoffset":
						TryParseInvariantFloat(array3[1], out HMDOffset);
						break;
					case "nearoffset":
						TryParseInvariantFloat(array3[1], out NearOffset);
						break;
					}
				}
			}
			if (Calibration.Changed != null)
			{
				Calibration.Changed(null, EventArgs.Empty);
			}
		}

		private static bool TryParseInvariantFloat(string number, out float result)
		{
			return float.TryParse(number, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
		}
	}
	public static class Extensions
	{
		private static float _copysign(float sizeval, float signval)
		{
			if ((int)Mathf.Sign(signval) != 1)
			{
				return 0f - Mathf.Abs(sizeval);
			}
			return Mathf.Abs(sizeval);
		}

		public static Quaternion GetRotation(this Matrix4x4 matrix)
		{
			Quaternion quaternion = default(Quaternion);
			quaternion.w = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 + matrix.m11 + matrix.m22)) / 2f;
			quaternion.x = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 - matrix.m11 - matrix.m22)) / 2f;
			quaternion.y = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 + matrix.m11 - matrix.m22)) / 2f;
			quaternion.z = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 - matrix.m11 + matrix.m22)) / 2f;
			Quaternion result = quaternion;
			result.x = _copysign(result.x, matrix.m21 - matrix.m12);
			result.y = _copysign(result.y, matrix.m02 - matrix.m20);
			result.z = _copysign(result.z, matrix.m10 - matrix.m01);
			return result;
		}

		public static Vector3 GetPosition(this Matrix4x4 matrix)
		{
			float m = matrix.m03;
			float m2 = matrix.m13;
			float m3 = matrix.m23;
			return new Vector3(m, m2, m3);
		}
	}
	[AddComponentMenu("LIV/ExternalCamera")]
	public class ExternalCamera : MonoBehaviour
	{
		private TrackedDevicePose_t _trackedDevicePose;

		private TrackedDevicePose_t[] _devices = new TrackedDevicePose_t[64];

		private TrackedDevicePose_t[] _gameDevices = new TrackedDevicePose_t[64];

		public bool IsValid => OpenVRTrackedDeviceId != uint.MaxValue;

		public uint OpenVRTrackedDeviceId { get; protected set; }

		private void OnEnable()
		{
			InvokeRepeating("UpdateOpenVRDevice", 0.5f, 0.5f);
			UpdateOpenVRDevice();
		}

		private void OnDisable()
		{
			CancelInvoke("UpdateOpenVRDevice");
		}

		private void LateUpdate()
		{
			UpdateCamera();
		}

		private void OnPreCull()
		{
			UpdateCamera();
		}

		private void UpdateCamera()
		{
			if (OpenVRTrackedDeviceId == uint.MaxValue)
			{
				return;
			}
			UpdateOpenVRPose();
			if (!_trackedDevicePose.bDeviceIsConnected)
			{
				UpdateOpenVRDevice();
				if (OpenVRTrackedDeviceId == uint.MaxValue)
				{
					return;
				}
				UpdateOpenVRPose();
			}
			UpdateTransform(_trackedDevicePose.mDeviceToAbsoluteTracking);
		}

		private void UpdateOpenVRPose()
		{
			if (OpenVR.Compositor.GetLastPoses(_devices, _gameDevices) == EVRCompositorError.None)
			{
				_trackedDevicePose = _devices[OpenVRTrackedDeviceId];
			}
		}

		private void UpdateTransform(HmdMatrix34_t deviceToAbsolute)
		{
			Matrix4x4 identity = Matrix4x4.identity;
			identity[0, 0] = deviceToAbsolute.m0;
			identity[0, 1] = deviceToAbsolute.m1;
			identity[0, 2] = 0f - deviceToAbsolute.m2;
			identity[0, 3] = deviceToAbsolute.m3;
			identity[1, 0] = deviceToAbsolute.m4;
			identity[1, 1] = deviceToAbsolute.m5;
			identity[1, 2] = 0f - deviceToAbsolute.m6;
			identity[1, 3] = deviceToAbsolute.m7;
			identity[2, 0] = 0f - deviceToAbsolute.m8;
			identity[2, 1] = 0f - deviceToAbsolute.m9;
			identity[2, 2] = deviceToAbsolute.m10;
			identity[2, 3] = 0f - deviceToAbsolute.m11;
			base.transform.localPosition = identity.GetPosition();
			base.transform.localRotation = identity.GetRotation();
		}

		private void UpdateOpenVRDevice()
		{
			OpenVRTrackedDeviceId = IdentifyExternalCameraDevice();
		}

		private uint IdentifyExternalCameraDevice()
		{
			EVRCompositorError lastPoses = OpenVR.Compositor.GetLastPoses(_devices, _gameDevices);
			if (lastPoses != 0)
			{
				UnityEngine.Debug.Log("Encountered an error whilst looking for the external camera: " + lastPoses);
				return uint.MaxValue;
			}
			return (uint)(((int?)(from candidate in _devices.Select((TrackedDevicePose_t pose, int index) => new
				{
					pose = pose,
					index = (uint)index
				})
				where candidate.pose.bDeviceIsConnected
				select new
				{
					pose = candidate.pose,
					index = candidate.index,
					deviceClass = OpenVR.System.GetTrackedDeviceClass(candidate.index)
				} into candidate
				where candidate.deviceClass == ETrackedDeviceClass.Controller || candidate.deviceClass == ETrackedDeviceClass.GenericTracker
				select new
				{
					pose = candidate.pose,
					index = candidate.index,
					deviceClass = candidate.deviceClass,
					deviceRole = OpenVR.System.GetControllerRoleForTrackedDeviceIndex(candidate.index),
					modelNumber = GetStringTrackedDeviceProperty(candidate.index, ETrackedDeviceProperty.Prop_ModelNumber_String),
					renderModel = GetStringTrackedDeviceProperty(candidate.index, ETrackedDeviceProperty.Prop_RenderModelName_String)
				}).OrderByDescending(candidate =>
			{
				if (candidate.modelNumber == "LIV Virtual Camera")
				{
					return 10;
				}
				if (candidate.modelNumber == "Virtual Controller Device")
				{
					return 9;
				}
				if (candidate.deviceClass == ETrackedDeviceClass.GenericTracker)
				{
					return 5;
				}
				if (candidate.deviceClass == ETrackedDeviceClass.Controller)
				{
					if (candidate.renderModel == "{htc}vr_tracker_vive_1_0")
					{
						return 8;
					}
					if (candidate.deviceRole == ETrackedControllerRole.OptOut)
					{
						return 7;
					}
					if (candidate.deviceRole == ETrackedControllerRole.Invalid)
					{
						return 6;
					}
					return 1;
				}
				return 0;
			}).FirstOrDefault()?.index) ?? (-1));
		}

		private static string GetStringTrackedDeviceProperty(uint device, ETrackedDeviceProperty property)
		{
			StringBuilder stringBuilder = new StringBuilder(1024);
			ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
			OpenVR.System.GetStringTrackedDeviceProperty(device, property, stringBuilder, 1024u, ref pError);
			switch (pError)
			{
			case ETrackedPropertyError.TrackedProp_Success:
				return stringBuilder.ToString();
			case ETrackedPropertyError.TrackedProp_UnknownProperty:
				return "";
			default:
				UnityEngine.Debug.Log("Encountered an error whilst reading a tracked device property: " + pError);
				return null;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true)]
	public class HelpAttribute : PropertyAttribute
	{
		public readonly string text;

		public HelpAttribute(string text)
		{
			this.text = text;
		}
	}
	[AddComponentMenu("LIV/LIV")]
	public class LIV : MonoBehaviour
	{
		[Tooltip("If unpopulated, we'll use the parent transform.")]
		public Transform TrackedSpaceOrigin;

		[Space]
		public Camera HMDCamera;

		[Space]
		public bool DisableStandardAssets;

		[Space]
		public LayerMask SpectatorLayerMask = -1;

		protected bool WasActive;

		private SharedTextureProtocol _sharedTextureProtocol;

		private ExternalCamera _externalCamera;

		private MixedRealityRender _mixedRealityRender;

		private bool _wasSteamVRExternalCameraActive;

		private VolumetricFog volFog;

		private VolumetricFogPosT volFogPosT;

		private MKGlow[] glow = new MKGlow[2];

		private MKGlow glowPlay;

		public GameObject camaraLiv;

		public Transform Origin
		{
			get
			{
				if (!(TrackedSpaceOrigin == null))
				{
					return TrackedSpaceOrigin;
				}
				return base.transform.parent;
			}
		}

		private void OnEnable()
		{
			if (!XRSettings.enabled)
			{
				UnityEngine.Debug.LogWarning("LIV: Project is not in XR mode! Disabling.");
				base.enabled = false;
				return;
			}
			if (XRSettings.loadedDeviceName != "OpenVR")
			{
				UnityEngine.Debug.LogWarningFormat("LIV: Unity is currently using {0} for XR support. Please switch to OpenVR to enable the LIV SDK. Disabling.", XRSettings.loadedDeviceName);
				base.enabled = false;
				return;
			}
			if (SteamVRCompatibility.IsAvailable)
			{
				UnityEngine.Debug.Log("LIV: SteamVR asset found!");
			}
			if (HMDCamera == null)
			{
				UnityEngine.Debug.LogError("LIV: HMD Camera is a required parameter!");
				base.enabled = false;
			}
			else if ((int)SpectatorLayerMask == 0)
			{
				UnityEngine.Debug.LogWarning("LIV: The spectator layer mask is set to not show anything. Is this right?");
			}
		}

		private void OnDisable()
		{
			if (WasActive)
			{
				OnCompositorDeactivated();
			}
		}

		private void Update()
		{
			if (SharedTextureProtocol.IsActive && !WasActive)
			{
				OnCompositorActivated();
			}
			if (!SharedTextureProtocol.IsActive && WasActive)
			{
				OnCompositorDeactivated();
			}
		}

		private void OnCompositorActivated()
		{
			try
			{
				PlayerProgreso.instance.tengoLIVActivado = true;
				PlayerProgreso.instance.liv = this;
			}
			catch (Exception)
			{
				UnityEngine.Debug.Log("Problema con el player progreso");
			}
			WasActive = true;
			UnityEngine.Debug.Log("LIV: Compositor connected, setting up MR!");
			CreateSharedTextureProtocol();
			CreateExternalCamera();
			CreateMixedRealityRender();
			if (SteamVRCompatibility.IsAvailable)
			{
				Component component = GetComponent(SteamVRCompatibility.SteamVRExternalCamera);
				if (component != null)
				{
					_wasSteamVRExternalCameraActive = component.gameObject.activeInHierarchy;
					component.gameObject.SetActive(value: false);
				}
			}
		}

		private void OnCompositorDeactivated()
		{
			try
			{
				PlayerProgreso.instance.tengoLIVActivado = false;
				PlayerProgreso.instance.liv = null;
			}
			catch (Exception)
			{
				UnityEngine.Debug.Log("Problema con el player progreso");
			}
			WasActive = false;
			UnityEngine.Debug.Log("LIV: Compositor disconnected, cleaning up.");
			DestroySharedTextureProtocol();
			DestroyMixedRealityRender();
			DestroyExternalCamera();
			if (SteamVRCompatibility.IsAvailable)
			{
				Component component = GetComponent(SteamVRCompatibility.SteamVRExternalCamera);
				if (component != null)
				{
					component.gameObject.SetActive(_wasSteamVRExternalCameraActive);
				}
			}
		}

		private void CreateSharedTextureProtocol()
		{
			_sharedTextureProtocol = base.gameObject.AddComponent<SharedTextureProtocol>();
		}

		private void DestroySharedTextureProtocol()
		{
			if (_sharedTextureProtocol != null)
			{
				UnityEngine.Object.Destroy(_sharedTextureProtocol);
				_sharedTextureProtocol = null;
			}
		}

		private void CreateExternalCamera()
		{
			GameObject gameObject = new GameObject("LIV Camera Reference");
			gameObject.transform.parent = Origin;
			gameObject.transform.localScale = Vector3.one;
			_externalCamera = gameObject.AddComponent<ExternalCamera>();
		}

		private void DestroyExternalCamera()
		{
			if (_externalCamera != null)
			{
				UnityEngine.Object.Destroy(_externalCamera.gameObject);
				_externalCamera = null;
			}
		}

		private void CreateMixedRealityRender()
		{
			HMDCamera.enabled = false;
			HMDCamera.gameObject.SetActive(value: false);
			GameObject gameObject = UnityEngine.Object.Instantiate(HMDCamera.gameObject);
			HMDCamera.gameObject.SetActive(value: true);
			HMDCamera.enabled = true;
			gameObject.name = "LIV Camera";
			camaraLiv = gameObject.gameObject;
			if ((bool)camaraLiv)
			{
				camaraLiv.GetComponent<Camera>().farClipPlane = 10000f;
			}
			if (Config.modoDeJuego == Config.ModosDeJuego.menu)
			{
				volFog = gameObject.GetComponent<VolumetricFog>();
				volFogPosT = gameObject.GetComponent<VolumetricFogPosT>();
				glow = gameObject.GetComponents<MKGlow>();
			}
			else
			{
				glowPlay = gameObject.GetComponent<MKGlow>();
				glowPlay.bloomIntensity = 1.2f;
			}
			if (CalidadManager.instance.GetCalidad() == CalidadManager.Calidad.Baja)
			{
				UnityEngine.Object.Destroy(gameObject.GetComponent<VolumetricFog>());
				UnityEngine.Object.Destroy(gameObject.GetComponent<VolumetricFogPosT>());
				UnityEngine.Object.Destroy(gameObject.GetComponent<MKGlow>());
			}
			while (gameObject.transform.childCount > 0)
			{
				UnityEngine.Object.DestroyImmediate(gameObject.transform.GetChild(0).gameObject);
			}
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent("AudioListener"));
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent("MeshCollider"));
			if (SteamVRCompatibility.IsAvailable)
			{
				UnityEngine.Object.DestroyImmediate(gameObject.GetComponent(SteamVRCompatibility.SteamVRCamera));
				UnityEngine.Object.DestroyImmediate(gameObject.GetComponent(SteamVRCompatibility.SteamVRFade));
			}
			_mixedRealityRender = gameObject.AddComponent<MixedRealityRender>();
			gameObject.transform.parent = _externalCamera.transform;
			gameObject.SetActive(value: true);
			_mixedRealityRender.Setup(this);
		}

		private void DestroyMixedRealityRender()
		{
			if (_mixedRealityRender != null)
			{
				UnityEngine.Object.Destroy(_mixedRealityRender.gameObject);
				_mixedRealityRender = null;
			}
		}

		public void ActivarNiebla()
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.menu)
			{
				volFog.enabled = true;
				volFogPosT.enabled = true;
				glow[0].enabled = true;
				glow[1].enabled = true;
			}
			else
			{
				glowPlay.enabled = true;
			}
		}

		public void DesActivarNiebla()
		{
			if (Config.modoDeJuego == Config.ModosDeJuego.menu)
			{
				volFog.enabled = false;
				volFogPosT.enabled = false;
				glow[0].enabled = false;
				glow[1].enabled = false;
			}
			else
			{
				glowPlay.enabled = false;
			}
		}
	}
	[AddComponentMenu("LIV/MixedRealityRender")]
	public class MixedRealityRender : MonoBehaviour
	{
		private bool _isSetup;

		private LIV _liv;

		private Camera _mrCamera;

		private Transform _hmd;

		private GameObject _clipQuad;

		private Material _clipMaterial;

		private Material _blitMaterial;

		private RenderTexture _compositeTexture;

		private RenderTexture _foregroundTexture;

		private RenderTexture _backgroundTexture;

		public void Setup(LIV liv)
		{
			_liv = liv;
			_mrCamera = GetComponent<Camera>();
			_mrCamera.rect = new Rect(0f, 0f, 1f, 1f);
			_mrCamera.depth = float.MaxValue;
			_mrCamera.stereoTargetEye = StereoTargetEyeMask.None;
			_mrCamera.useOcclusionCulling = false;
			_mrCamera.enabled = false;
			_clipMaterial = new Material(Shader.Find("Custom/LIV_ClearBackground"));
			_blitMaterial = new Material(Shader.Find("Custom/LIV_Blit"));
			CreateClipQuad();
			_isSetup = true;
		}

		private void CreateClipQuad()
		{
			_clipQuad = GameObject.CreatePrimitive(PrimitiveType.Quad);
			_clipQuad.name = "ClipQuad";
			UnityEngine.Object.Destroy(_clipQuad.GetComponent<MeshCollider>());
			_clipQuad.transform.parent = base.transform;
			MeshRenderer component = _clipQuad.GetComponent<MeshRenderer>();
			component.material = _clipMaterial;
			component.shadowCastingMode = ShadowCastingMode.Off;
			component.receiveShadows = false;
			component.lightProbeUsage = LightProbeUsage.Off;
			component.reflectionProbeUsage = ReflectionProbeUsage.Off;
			Transform obj = _clipQuad.transform;
			obj.localScale = new Vector3(1000f, 1000f, 1f);
			obj.localRotation = Quaternion.identity;
			_clipQuad.SetActive(value: false);
		}

		private void UpdateCamera()
		{
			_mrCamera.fieldOfView = Calibration.FieldOfVision;
			_mrCamera.cullingMask = _liv.SpectatorLayerMask;
			_hmd = _liv.HMDCamera.transform;
			base.transform.localPosition = Calibration.PositionOffset;
			base.transform.localRotation = Calibration.RotationOffset;
			base.transform.localScale = Vector3.one;
		}

		private void UpdateTextures()
		{
			int textureWidth = SharedTextureProtocol.TextureWidth;
			int textureHeight = SharedTextureProtocol.TextureHeight;
			int num = SharedTextureProtocol.TextureHeight / 2;
			if (_compositeTexture == null || _compositeTexture.width != textureWidth || _compositeTexture.height != textureHeight)
			{
				_compositeTexture = new RenderTexture(textureWidth, textureHeight, 24, RenderTextureFormat.ARGB32);
				_compositeTexture.antiAliasing = 1;
			}
			if (_foregroundTexture == null || _foregroundTexture.width != textureWidth || _foregroundTexture.height != num)
			{
				_foregroundTexture = new RenderTexture(textureWidth, num, 24, RenderTextureFormat.ARGB32)
				{
					antiAliasing = 1,
					wrapMode = TextureWrapMode.Clamp,
					useMipMap = false,
					anisoLevel = 0
				};
			}
			if (_backgroundTexture == null || _backgroundTexture.width != textureWidth || _backgroundTexture.height != num)
			{
				_backgroundTexture = new RenderTexture(textureWidth, num, 24, RenderTextureFormat.ARGB32)
				{
					antiAliasing = 1,
					wrapMode = TextureWrapMode.Clamp,
					useMipMap = false,
					anisoLevel = 0
				};
			}
		}

		public float GetDistanceToHMD()
		{
			if (_hmd == null)
			{
				return Calibration.NearClip;
			}
			Transform transform = _mrCamera.transform;
			Vector3 normalized = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
			Vector3 inPoint = _hmd.position + new Vector3(_hmd.forward.x, 0f, _hmd.forward.z).normalized * Calibration.HMDOffset;
			return 0f - new Plane(normalized, inPoint).GetDistanceToPoint(transform.position);
		}

		private void OrientClipQuad()
		{
		}

		private void RenderNear()
		{
			_mrCamera.targetTexture = _foregroundTexture;
			_foregroundTexture.DiscardContents(discardColor: true, discardDepth: true);
			_mrCamera.Render();
		}

		private void RenderFar()
		{
			_mrCamera.targetTexture = _backgroundTexture;
			_backgroundTexture.DiscardContents(discardColor: true, discardDepth: true);
			_mrCamera.Render();
		}

		private void Composite()
		{
			_compositeTexture.DiscardContents(discardColor: true, discardDepth: true);
			_blitMaterial.SetTexture("_NearTex", _foregroundTexture);
			_blitMaterial.SetTexture("_FarTex", _backgroundTexture);
			Graphics.Blit(null, _compositeTexture, _blitMaterial);
			SharedTextureProtocol.SetOutputTexture(_compositeTexture);
		}

		private void OnEnable()
		{
			StartCoroutine(RenderLoop());
		}

		private IEnumerator RenderLoop()
		{
			while (UnityEngine.Application.isPlaying && base.enabled)
			{
				yield return new WaitForEndOfFrame();
				if (_isSetup && SharedTextureProtocol.IsActive)
				{
					UpdateCamera();
					UpdateTextures();
					OrientClipQuad();
					RenderNear();
					RenderFar();
					Composite();
				}
			}
			yield return null;
		}
	}
	[AddComponentMenu("LIV/SharedTextureProtocol")]
	public class SharedTextureProtocol : MonoBehaviour
	{
		public static bool IsActive => GetIsCaptureActive();

		public static int TextureWidth => GetTextureWidth();

		public static int TextureHeight => GetTextureHeight();

		[DllImport("LIV_MR")]
		private static extern IntPtr GetRenderEventFunc();

		[DllImport("LIV_MR", EntryPoint = "LivCaptureIsActive")]
		[return: MarshalAs(UnmanagedType.U1)]
		private static extern bool GetIsCaptureActive();

		[DllImport("LIV_MR", EntryPoint = "LivCaptureWidth")]
		private static extern int GetTextureWidth();

		[DllImport("LIV_MR", EntryPoint = "LivCaptureHeight")]
		private static extern int GetTextureHeight();

		[DllImport("LIV_MR", EntryPoint = "LivCaptureSetTextureFromUnity")]
		private static extern void SetTexture(IntPtr texture);

		public static void SetOutputTexture(Texture texture)
		{
			if (IsActive)
			{
				SetTexture(texture.GetNativeTexturePtr());
			}
		}

		private void OnEnable()
		{
			StartCoroutine(CallPluginAtEndOfFrames());
		}

		private IEnumerator CallPluginAtEndOfFrames()
		{
			while (base.enabled)
			{
				yield return new WaitForEndOfFrame();
				GL.IssuePluginEvent(GetRenderEventFunc(), 1);
			}
		}

		private void OnDisable()
		{
			SetTexture(IntPtr.Zero);
		}
	}
	internal static class SteamVRCompatibility
	{
		public static bool IsAvailable;

		public static Type SteamVRCamera;

		public static Type SteamVRExternalCamera;

		public static Type SteamVRFade;

		static SteamVRCompatibility()
		{
			IsAvailable = FindSteamVRAsset();
		}

		private static bool FindSteamVRAsset()
		{
			if (SteamVRCamera == null)
			{
				SteamVRCamera = Type.GetType("SteamVR_Camera", throwOnError: false);
			}
			if (SteamVRCamera == null)
			{
				SteamVRCamera = Type.GetType("Valve.VR.SteamVR_Camera", throwOnError: false);
			}
			if (SteamVRExternalCamera == null)
			{
				SteamVRExternalCamera = Type.GetType("SteamVR_ExternalCamera", throwOnError: false);
			}
			if (SteamVRExternalCamera == null)
			{
				SteamVRExternalCamera = Type.GetType("Valve.VR.SteamVR_ExternalCamera", throwOnError: false);
			}
			if (SteamVRFade == null)
			{
				SteamVRFade = Type.GetType("SteamVR_Fade", throwOnError: false);
			}
			if (SteamVRFade == null)
			{
				SteamVRFade = Type.GetType("Valve.VR.SteamVR_Fade", throwOnError: false);
			}
			if (SteamVRCamera != null && SteamVRExternalCamera != null)
			{
				return SteamVRFade != null;
			}
			return false;
		}
	}
}
namespace VolumetricFogAndMist
{
	[AddComponentMenu("")]
	public class FogAreaCullingManager : MonoBehaviour
	{
		public VolumetricFog fog;

		private void OnEnable()
		{
			if (fog == null)
			{
				fog = GetComponent<VolumetricFog>();
				if (fog == null)
				{
					fog = base.gameObject.AddComponent<VolumetricFog>();
				}
			}
		}

		private void OnBecameVisible()
		{
			if (fog != null)
			{
				fog.enabled = true;
			}
		}

		private void OnBecameInvisible()
		{
			if (fog != null)
			{
				fog.enabled = false;
			}
		}
	}
	[ExecuteInEditMode]
	public class FogOfWarHole : MonoBehaviour
	{
		public enum HoleShape
		{
			Disc,
			Box
		}

		public HoleShape shape;

		[Range(0f, 1f)]
		[Tooltip("The transparency of the fog")]
		public float alpha;

		[Range(0f, 1f)]
		[Tooltip("The smoothness/harshness of the hole's border")]
		public float smoothness = 0.85f;

		private HoleShape lastShape;

		private Vector3 lastPosition = Vector3.zero;

		private Vector3 lastScale;

		private void Start()
		{
			StampHole(base.transform.position, shape, base.transform.localScale.x, base.transform.localScale.z);
		}

		private void RestoreHole(Vector3 position, HoleShape shape, float sizeX, float sizeZ)
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (!(instance == null))
			{
				instance.fogOfWarEnabled = true;
				switch (shape)
				{
				case HoleShape.Box:
					instance.ResetFogOfWarAlpha(position, sizeX * 0.5f, sizeZ * 0.5f);
					break;
				case HoleShape.Disc:
					instance.ResetFogOfWarAlpha(position, Mathf.Max(sizeX, sizeZ) * 0.5f);
					break;
				}
			}
		}

		private void StampHole(Vector3 position, HoleShape shape, float sizeX, float sizeZ)
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (!(instance == null))
			{
				instance.fogOfWarEnabled = true;
				switch (shape)
				{
				case HoleShape.Box:
					instance.SetFogOfWarAlpha(new Bounds(position, new Vector3(sizeX, 0f, sizeZ)), alpha, blendAlpha: false, 0f, smoothness, 0f, 0f);
					break;
				case HoleShape.Disc:
					instance.SetFogOfWarAlpha(position, Mathf.Max(sizeX, sizeZ) * 0.5f, alpha, blendAlpha: false, 0f, smoothness, 0f, 0f);
					break;
				}
				lastPosition = position;
				lastShape = shape;
				lastScale = base.transform.localScale;
			}
		}

		public void Refresh()
		{
			RestoreHole(lastPosition, lastShape, lastScale.x, lastScale.z);
			StampHole(base.transform.position, shape, base.transform.localScale.x, base.transform.localScale.z);
		}
	}
	[AddComponentMenu("")]
	public class FogVolume : MonoBehaviour
	{
		private const float GRAY = 0.8901961f;

		[Tooltip("Enables transition to a given profile.")]
		public bool enableProfileTransition;

		[Tooltip("Assign the transition profile.")]
		public VolumetricFogProfile targetProfile;

		[Tooltip("Enables alpha transition.")]
		public bool enableAlphaTransition;

		[Tooltip("Target alpha for fog when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetFogAlpha = 0.5f;

		[Tooltip("Target alpha for sky haze when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetSkyHazeAlpha = 0.5f;

		[Tooltip("Enables fog color transition.")]
		public bool enableFogColorTransition;

		[Tooltip("Target fog color 1 when gamera enters this fog folume")]
		public Color targetFogColor = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Enables fog specular color transition.")]
		public bool enableFogSpecularColorTransition;

		[Tooltip("Target fog color 2 when gamera enters this fog folume")]
		public Color targetFogSpecularColor = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Enables light color transition.")]
		public bool enableLightColorTransition;

		[Tooltip("Target light color when gamera enters this fog folume")]
		public Color targetLightColor = Color.white;

		[Tooltip("Set this to zero for changing fog alpha immediately upon enter/exit fog volume.")]
		public float transitionDuration = 3f;

		[Tooltip("Set collider that will trigger this fog volume. If not set, this fog volume will react to any collider which has the main camera. If you use a third person controller, assign the character collider here.")]
		public Collider targetCollider;

		[Tooltip("When enabled, a console message will be printed whenever this fog volume is entered or exited.")]
		public bool debugMode;

		[Tooltip("Assign target Volumetric Fog component that will be affected by this volume.")]
		public VolumetricFog targetFog;

		private bool cameraInside;

		private void Start()
		{
			if (targetFog == null)
			{
				targetFog = VolumetricFog.instance;
			}
			if (targetFog != null)
			{
				targetFog.useFogVolumes = true;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = true;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.SetTargetProfile(targetProfile, transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.SetTargetAlpha(targetFogAlpha, targetSkyHazeAlpha, transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.SetTargetColor(targetFogColor, transitionDuration);
				}
				if (enableFogSpecularColorTransition)
				{
					targetFog.SetTargetSpecularColor(targetFogSpecularColor, transitionDuration);
				}
				if (enableLightColorTransition)
				{
					targetFog.SetTargetLightColor(targetLightColor, transitionDuration);
				}
				if (debugMode)
				{
					Debugs.Log("Fog Volume entered by " + other.name);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = false;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.ClearTargetProfile(transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.ClearTargetAlpha(transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.ClearTargetColor(transitionDuration);
				}
				if (enableFogSpecularColorTransition)
				{
					targetFog.ClearTargetSpecularColor(transitionDuration);
				}
				if (enableLightColorTransition)
				{
					targetFog.ClearTargetLightColor(transitionDuration);
				}
				if (debugMode)
				{
					Debugs.Log("Fog Volume exited by " + other.name);
				}
			}
		}
	}
	internal interface IVolumetricFogRenderComponent
	{
		VolumetricFog fog { get; set; }

		void DestroySelf();
	}
	public enum FOG_PRESET
	{
		Clear = 0,
		Mist = 10,
		WindyMist = 11,
		LowClouds = 20,
		SeaClouds = 21,
		GroundFog = 30,
		FrostedGround = 31,
		FoggyLake = 32,
		Fog = 41,
		HeavyFog = 42,
		SandStorm1 = 50,
		Smoke = 51,
		ToxicSwamp = 52,
		SandStorm2 = 53,
		WorldEdge = 200,
		Custom = 1000
	}
	public enum SPSR_BEHAVIOUR
	{
		AutoDetectInEditor,
		ForcedOn,
		ForcedOff
	}
	public enum TRANSPARENT_MODE
	{
		None,
		Blend
	}
	public enum COMPUTE_DEPTH_SCOPE
	{
		OnlyTreeBillboards,
		EverythingInLayer,
		TreeBillboardsAndTransparentObjects
	}
	public enum LIGHTING_MODEL
	{
		Classic,
		Natural,
		SingleLight
	}
	public enum SUN_SHADOWS_BAKE_MODE
	{
		Realtime,
		Discrete
	}
	public enum FOG_VOID_TOPOLOGY
	{
		Sphere,
		Box
	}
	public enum FOG_AREA_TOPOLOGY
	{
		Sphere = 1,
		Box
	}
	public enum FOG_AREA_SORTING_MODE
	{
		DistanceToCamera,
		Altitude,
		Fixed
	}
	public enum FOG_AREA_FOLLOW_MODE
	{
		FullXYZ,
		RestrictToXZPlane
	}
	public enum FOG_VISIBILITY_SCOPE
	{
		Global,
		Volume
	}
	public struct FOG_TEMPORARY_PROPERTIES
	{
		public Color color;

		public float density;
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Rendering/Volumetric Fog & Mist")]
	[HelpURL("http://kronnect.com/taptapgo")]
	public class VolumetricFog : MonoBehaviour
	{
		[Serializable]
		public struct PointLightParams
		{
			public Light light;

			[HideInInspector]
			public VolumetricFogLightParams lightParams;

			public float range;

			public float rangeMultiplier;

			public float intensity;

			public float intensityMultiplier;

			public Vector3 position;

			public Color color;
		}

		private struct FogOfWarTransition
		{
			public bool enabled;

			public int x;

			public int y;

			public float startTime;

			public float startDelay;

			public float duration;

			public byte initialAlpha;

			public byte targetAlpha;
		}

		public const string SKW_FOG_DISTANCE_ON = "FOG_DISTANCE_ON";

		public const string SKW_LIGHT_SCATTERING = "FOG_SCATTERING_ON";

		public const string SKW_FOG_AREA_BOX = "FOG_AREA_BOX";

		public const string SKW_FOG_AREA_SPHERE = "FOG_AREA_SPHERE";

		public const string SKW_FOG_VOID_BOX = "FOG_VOID_BOX";

		public const string SKW_FOG_VOID_SPHERE = "FOG_VOID_SPHERE";

		public const string SKW_FOG_HAZE_ON = "FOG_HAZE_ON";

		public const string SKW_FOG_OF_WAR_ON = "FOG_OF_WAR_ON";

		public const string SKW_FOG_BLUR = "FOG_BLUR_ON";

		public const string SKW_SUN_SHADOWS = "FOG_SUN_SHADOWS_ON";

		public const string SKW_FOG_USE_XY_PLANE = "FOG_USE_XY_PLANE";

		public const string SKW_FOG_COMPUTE_DEPTH = "FOG_COMPUTE_DEPTH";

		public const string SKW_POINT_LIGHTS = "FOG_POINT_LIGHTS";

		private const string DEPTH_CAM_NAME = "VFMDepthCamera";

		private const string DEPTH_SUN_CAM_NAME = "VFMDepthSunCamera";

		private const string VFM_BUILD_FIRST_INSTALL = "VFMFirstInstall";

		private const string VFM_BUILD_HINT = "VFMBuildHint102RC1";

		private static VolumetricFog _fog;

		[HideInInspector]
		public bool isDirty;

		[SerializeField]
		private FOG_PRESET _preset = FOG_PRESET.Mist;

		[SerializeField]
		private VolumetricFogProfile _profile;

		[SerializeField]
		private bool _profileSync;

		[SerializeField]
		private bool _useFogVolumes;

		[SerializeField]
		private bool _debugPass;

		[SerializeField]
		private bool _showInSceneView = true;

		[SerializeField]
		private TRANSPARENT_MODE _transparencyBlendMode;

		[SerializeField]
		[Range(0f, 1f)]
		private float _transparencyBlendPower = 1f;

		[SerializeField]
		private LayerMask _transparencyLayerMask = -1;

		[SerializeField]
		private FOG_VISIBILITY_SCOPE _visibilityScope;

		[SerializeField]
		private Bounds _visibilityVolume = new Bounds(Vector3.zero, new Vector3(1000f, 1000f, 1000f));

		[SerializeField]
		private LIGHTING_MODEL _lightingModel;

		[SerializeField]
		private bool _enableMultipleCameras;

		[SerializeField]
		private bool _computeDepth;

		[SerializeField]
		private COMPUTE_DEPTH_SCOPE _computeDepthScope;

		[SerializeField]
		private float _transparencyCutOff = 0.1f;

		[SerializeField]
		private bool _renderBeforeTransparent;

		[SerializeField]
		private GameObject _sun;

		[SerializeField]
		[Range(0f, 0.5f)]
		private float _timeBetweenTextureUpdates = 0.2f;

		[SerializeField]
		private bool _sunCopyColor = true;

		[SerializeField]
		[Range(0f, 1.25f)]
		private float _density = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _noiseStrength = 0.8f;

		[SerializeField]
		[Range(1f, 2f)]
		private float _noiseFinalMultiplier = 1f;

		[SerializeField]
		[Range(-0.3f, 2f)]
		private float _noiseSparse;

		[SerializeField]
		[Range(0f, 1000f)]
		private float _distance;

		[SerializeField]
		private float _maxFogLength = 1000f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maxFogLengthFallOff;

		[SerializeField]
		[Range(0f, 5f)]
		private float _distanceFallOff;

		[SerializeField]
		[Range(0.0001f, 500f)]
		private float _height = 4f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _heightFallOff = 0.6f;

		[SerializeField]
		private float _deepObscurance = 1f;

		[SerializeField]
		private float _baselineHeight;

		[SerializeField]
		private bool _baselineRelativeToCamera;

		[SerializeField]
		[Range(0f, 1f)]
		private float _baselineRelativeToCameraDelay;

		[SerializeField]
		private float _noiseScale = 1f;

		[SerializeField]
		[Range(0f, 1.05f)]
		private float _alpha = 1f;

		[SerializeField]
		private Color _color = new Color(0.89f, 0.89f, 0.89f, 1f);

		[SerializeField]
		private Color _specularColor = new Color(1f, 1f, 0.8f, 1f);

		[SerializeField]
		[Range(0f, 1f)]
		private float _specularThreshold = 0.6f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _specularIntensity = 0.2f;

		[SerializeField]
		private Vector3 _lightDirection = new Vector3(1f, 0f, -1f);

		[SerializeField]
		private float _lightIntensity = 0.2f;

		[SerializeField]
		private Color _lightColor = Color.white;

		[SerializeField]
		[Range(1f, 5f)]
		private int _updateTextureSpread = 1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _speed = 0.01f;

		[SerializeField]
		private Vector3 _windDirection = new Vector3(-1f, 0f, 0f);

		[SerializeField]
		private bool _useRealTime;

		[SerializeField]
		private Color _skyColor = new Color(0.89f, 0.89f, 0.89f, 1f);

		[SerializeField]
		private float _skyHaze = 50f;

		[SerializeField]
		private float _skyNoiseScale = 1.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skySpeed = 0.3f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyNoiseStrength = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyAlpha = 1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float _skyDepth = 0.999f;

		[SerializeField]
		private GameObject _character;

		[SerializeField]
		private FOG_VOID_TOPOLOGY _fogVoidTopology;

		[SerializeField]
		[Range(0f, 10f)]
		private float _fogVoidFallOff = 1f;

		[SerializeField]
		private float _fogVoidRadius;

		[SerializeField]
		private Vector3 _fogVoidPosition = Vector3.zero;

		[SerializeField]
		private float _fogVoidDepth;

		[SerializeField]
		private float _fogVoidHeight;

		[SerializeField]
		private bool _fogVoidInverted;

		[SerializeField]
		private bool _fogAreaShowGizmos = true;

		[SerializeField]
		private GameObject _fogAreaCenter;

		[SerializeField]
		[Range(0.001f, 10f)]
		private float _fogAreaFallOff = 1f;

		[SerializeField]
		private FOG_AREA_FOLLOW_MODE _fogAreaFollowMode;

		[SerializeField]
		private FOG_AREA_TOPOLOGY _fogAreaTopology = FOG_AREA_TOPOLOGY.Sphere;

		[SerializeField]
		private float _fogAreaRadius;

		[SerializeField]
		private Vector3 _fogAreaPosition = Vector3.zero;

		[SerializeField]
		private float _fogAreaDepth;

		[SerializeField]
		private float _fogAreaHeight;

		[SerializeField]
		private FOG_AREA_SORTING_MODE _fogAreaSortingMode;

		[SerializeField]
		private int _fogAreaRenderOrder = 1;

		public PointLightParams[] pointLightParams;

		[SerializeField]
		private bool pointLightDataMigrated;

		private Vector4[] pointLightColorBuffer;

		private Vector4[] pointLightPositionBuffer;

		[SerializeField]
		private GameObject[] _pointLights = new GameObject[6];

		[SerializeField]
		private float[] _pointLightRanges = new float[6];

		[SerializeField]
		private float[] _pointLightIntensities = new float[6] { 1f, 1f, 1f, 1f, 1f, 1f };

		[SerializeField]
		private float[] _pointLightIntensitiesMultiplier = new float[6] { 1f, 1f, 1f, 1f, 1f, 1f };

		[SerializeField]
		private Vector3[] _pointLightPositions = new Vector3[6];

		[SerializeField]
		private Color[] _pointLightColors = new Color[6]
		{
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f)
		};

		[SerializeField]
		private bool _pointLightTrackingAuto;

		[SerializeField]
		private Transform _pointLightTrackingPivot;

		[SerializeField]
		private int _pointLightTrackingCount;

		[SerializeField]
		[Range(0f, 5f)]
		private float _pointLightTrackingCheckInterval = 1f;

		[SerializeField]
		private float _pointLightTrackingNewLightsCheckInterval = 3f;

		[SerializeField]
		private float _pointLightInscattering = 1f;

		[SerializeField]
		private float _pointLightIntensity = 1f;

		[SerializeField]
		private float _pointLightInsideAtten;

		[SerializeField]
		[Range(1f, 8f)]
		private int _downsampling = 1;

		[SerializeField]
		private bool _forceComposition;

		[SerializeField]
		private bool _edgeImprove;

		[SerializeField]
		[Range(1E-05f, 0.005f)]
		private float _edgeThreshold = 0.0005f;

		[SerializeField]
		[Range(1f, 20f)]
		private float _stepping = 12f;

		[SerializeField]
		[Range(0f, 50f)]
		private float _steppingNear = 1f;

		[SerializeField]
		private bool _dithering;

		[SerializeField]
		[Range(0.1f, 5f)]
		private float _ditherStrength = 0.75f;

		[SerializeField]
		[Range(0f, 2f)]
		private float _jitterStrength = 0.5f;

		[SerializeField]
		private bool _lightScatteringEnabled;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringDiffusion = 0.7f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringSpread = 0.686f;

		[SerializeField]
		[Range(4f, 64f)]
		private int _lightScatteringSamples = 16;

		[SerializeField]
		[Range(0f, 50f)]
		private float _lightScatteringWeight = 1.9f;

		[SerializeField]
		[Range(0f, 50f)]
		private float _lightScatteringIllumination = 18f;

		[SerializeField]
		[Range(0.9f, 1.1f)]
		private float _lightScatteringDecay = 0.986f;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _lightScatteringExposure;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringJittering = 0.5f;

		[SerializeField]
		[Range(1f, 4f)]
		private int _lightScatteringBlurDownscale = 1;

		[SerializeField]
		private bool _fogBlur;

		[SerializeField]
		[Range(0f, 1f)]
		private float _fogBlurDepth = 0.05f;

		[SerializeField]
		private bool _sunShadows;

		[SerializeField]
		private LayerMask _sunShadowsLayerMask = -1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunShadowsStrength = 0.5f;

		[SerializeField]
		private float _sunShadowsBias = 0.1f;

		[SerializeField]
		[Range(0f, 0.5f)]
		private float _sunShadowsJitterStrength = 0.1f;

		[SerializeField]
		[Range(0f, 4f)]
		private int _sunShadowsResolution = 2;

		[SerializeField]
		[Range(50f, 2000f)]
		private float _sunShadowsMaxDistance = 200f;

		[SerializeField]
		private SUN_SHADOWS_BAKE_MODE _sunShadowsBakeMode = SUN_SHADOWS_BAKE_MODE.Discrete;

		[SerializeField]
		private float _sunShadowsRefreshInterval;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunShadowsCancellation;

		[SerializeField]
		[Range(0f, 10f)]
		private float _turbulenceStrength;

		[SerializeField]
		private bool _useXYPlane;

		[SerializeField]
		private bool _useSinglePassStereoRenderingMatrix;

		[SerializeField]
		public SPSR_BEHAVIOUR _spsrBehaviour;

		[SerializeField]
		private bool _reduceFlickerBigWorlds;

		[SerializeField]
		private bool _enableMask;

		[SerializeField]
		private LayerMask _maskLayer = 8388608;

		[SerializeField]
		[Range(1f, 4f)]
		private int _maskDownsampling = 1;

		public bool isRendering;

		[NonSerialized]
		public float distanceToCameraMin;

		[NonSerialized]
		public float distanceToCameraMax;

		[NonSerialized]
		public float distanceToCamera;

		[NonSerialized]
		public float distanceToCameraYAxis;

		[NonSerialized]
		public FOG_TEMPORARY_PROPERTIES temporaryProperties;

		public VolumetricFog fogRenderer;

		private VolumetricFog[] allFogRenderers;

		private bool isPartOfScene;

		private int noiseTextureSize;

		private float initialFogAlpha;

		private float targetFogAlpha;

		private float initialSkyHazeAlpha;

		private float targetSkyHazeAlpha;

		private bool transitionAlpha;

		private bool transitionColor;

		private bool transitionSpecularColor;

		private bool transitionLightColor;

		private bool transitionProfile;

		private bool targetColorActive;

		private bool targetSpecularColorActive;

		private bool targetLightColorActive;

		private Color initialFogColor;

		private Color targetFogColor;

		private Color initialFogSpecularColor;

		private Color targetFogSpecularColor;

		private Color initialLightColor;

		private Color targetLightColor;

		private float transitionDuration;

		private float transitionStartTime;

		private float currentFogAlpha;

		private float currentSkyHazeAlpha;

		private Color currentFogColor;

		private Color currentFogSpecularColor;

		private Color currentLightColor;

		private VolumetricFogProfile initialProfile;

		private VolumetricFogProfile targetProfile;

		private float oldBaselineRelativeCameraY;

		private float currentFogAltitude;

		private float skyHazeSpeedAcum;

		private Color skyHazeLightColor;

		private bool _hasCamera;

		private bool _hasCameraChecked;

		private Camera mainCamera;

		private List<string> shaderKeywords;

		private Material blurMat;

		private RenderBuffer[] mrt;

		private int _renderingInstancesCount;

		private bool shouldUpdateMaterialProperties;

		private int lastFrameCount;

		[NonSerialized]
		public Material fogMat;

		private RenderTexture depthTexture;

		private RenderTexture depthSunTexture;

		private RenderTexture reducedDestination;

		private Light[] lastFoundLights;

		private Light[] lightBuffer;

		private Light[] currentLights;

		private float trackPointAutoLastTime;

		private float trackPointCheckNewLightsLastTime;

		private Vector4 black = new Vector4(0f, 0f, 0f, 1f);

		private Shader depthShader;

		private Shader depthShaderAndTrans;

		private GameObject depthCamObj;

		private Camera depthCam;

		private float lastTextureUpdate;

		private Vector3 windSpeedAcum;

		private Texture2D adjustedTexture;

		private Color[] noiseColors;

		private Color[] adjustedColors;

		private float sunLightIntensity = 1f;

		private bool needUpdateTexture;

		private bool hasChangeAdjustedColorsAlpha;

		private int updatingTextureSlice;

		private Color updatingTextureLightColor;

		private Color lastRenderSettingsAmbientLight;

		private float lastRenderSettingsAmbientIntensity;

		private int lastFrameAppliedChaos;

		private int lastFrameAppliedWind;

		private Light sunLight;

		private Vector2 oldSunPos;

		private float sunFade = 1f;

		private GameObject depthSunCamObj;

		private Camera depthSunCam;

		private Shader depthSunShader;

		[NonSerialized]
		public bool needUpdateDepthSunTexture;

		private float lastShadowUpdateFrame;

		private bool sunShadowsActive;

		private int currentDepthSunTextureRes;

		private Texture2D adjustedChaosTexture;

		private Material chaosLerpMat;

		private float turbAcum;

		private float deltaTime;

		private float timeOfLastRender;

		private List<VolumetricFog> fogInstances = new List<VolumetricFog>();

		private List<VolumetricFog> fogRenderInstances = new List<VolumetricFog>();

		private MeshRenderer mr;

		private float lastTimeSortInstances;

		private const float FOG_INSTANCES_SORT_INTERVAL = 2f;

		private Vector3 lastCamPos;

		private bool needResort;

		private CommandBuffer maskCommandBuffer;

		private RenderTextureDescriptor rtMaskDesc;

		private Material maskMaterial;

		private const int MAX_SIMULTANEOUS_TRANSITIONS = 10000;

		[SerializeField]
		private bool _fogOfWarEnabled;

		[SerializeField]
		private Vector3 _fogOfWarCenter;

		[SerializeField]
		private Vector3 _fogOfWarSize = new Vector3(1024f, 0f, 1024f);

		[SerializeField]
		[Range(32f, 2048f)]
		private int _fogOfWarTextureSize = 256;

		[SerializeField]
		[Range(0f, 100f)]
		private float _fogOfWarRestoreDelay;

		[SerializeField]
		[Range(0f, 25f)]
		private float _fogOfWarRestoreDuration = 2f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _fogOfWarSmoothness = 1f;

		[SerializeField]
		private bool _maskEditorEnabled;

		[SerializeField]
		private MASK_TEXTURE_BRUSH_MODE _maskBrushMode = MASK_TEXTURE_BRUSH_MODE.RemoveFog;

		[SerializeField]
		[Range(1f, 128f)]
		private int _maskBrushWidth = 20;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maskBrushFuzziness = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maskBrushOpacity = 0.15f;

		[SerializeField]
		private Texture2D _fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		private FogOfWarTransition[] fowTransitionList;

		private int lastTransitionPos;

		private Dictionary<int, int> fowTransitionIndices;

		private bool requiresTextureUpload;

		public const int MAX_POINT_LIGHTS = 6;

		public const bool LIGHT_SCATTERING_BLUR_ENABLED = false;

		public static VolumetricFog instance
		{
			get
			{
				if (_fog == null)
				{
					if (Camera.main != null)
					{
						_fog = Camera.main.GetComponent<VolumetricFog>();
					}
					if (_fog == null)
					{
						Camera[] allCameras = Camera.allCameras;
						for (int i = 0; i < allCameras.Length; i++)
						{
							_fog = allCameras[i].GetComponent<VolumetricFog>();
							if (_fog != null)
							{
								break;
							}
						}
					}
				}
				return _fog;
			}
		}

		public FOG_PRESET preset
		{
			get
			{
				return _preset;
			}
			set
			{
				if (value != _preset)
				{
					_preset = value;
					UpdatePreset();
					isDirty = true;
				}
			}
		}

		public VolumetricFogProfile profile
		{
			get
			{
				return _profile;
			}
			set
			{
				if (value != _profile)
				{
					_profile = value;
					if (_profile != null)
					{
						_profile.Load(this);
						_preset = FOG_PRESET.Custom;
					}
					isDirty = true;
				}
			}
		}

		public bool profileSync
		{
			get
			{
				return _profileSync;
			}
			set
			{
				if (value != _profileSync)
				{
					_profileSync = value;
					isDirty = true;
				}
			}
		}

		public bool useFogVolumes
		{
			get
			{
				return _useFogVolumes;
			}
			set
			{
				if (value != _useFogVolumes)
				{
					_useFogVolumes = value;
					isDirty = true;
				}
			}
		}

		public bool debugDepthPass
		{
			get
			{
				return _debugPass;
			}
			set
			{
				if (value != _debugPass)
				{
					_debugPass = value;
					isDirty = true;
				}
			}
		}

		public bool showInSceneView
		{
			get
			{
				return _showInSceneView;
			}
			set
			{
				if (value != _showInSceneView)
				{
					_showInSceneView = value;
					isDirty = true;
				}
			}
		}

		public TRANSPARENT_MODE transparencyBlendMode
		{
			get
			{
				return _transparencyBlendMode;
			}
			set
			{
				if (value != _transparencyBlendMode)
				{
					_transparencyBlendMode = value;
					UpdateRenderComponents();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float transparencyBlendPower
		{
			get
			{
				return _transparencyBlendPower;
			}
			set
			{
				if (value != _transparencyBlendPower)
				{
					_transparencyBlendPower = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public LayerMask transparencyLayerMask
		{
			get
			{
				return _transparencyLayerMask;
			}
			set
			{
				if ((int)_transparencyLayerMask != (int)value)
				{
					_transparencyLayerMask = value;
					isDirty = true;
				}
			}
		}

		public FOG_VISIBILITY_SCOPE visibilityScope
		{
			get
			{
				return _visibilityScope;
			}
			set
			{
				if (_visibilityScope != value)
				{
					_visibilityScope = value;
					isDirty = true;
				}
			}
		}

		public Bounds visibilityVolume
		{
			get
			{
				return _visibilityVolume;
			}
			set
			{
				if (_visibilityVolume != value)
				{
					_visibilityVolume = value;
					isDirty = true;
				}
			}
		}

		public LIGHTING_MODEL lightingModel
		{
			get
			{
				return _lightingModel;
			}
			set
			{
				if (value != _lightingModel)
				{
					_lightingModel = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public bool enableMultipleCameras
		{
			get
			{
				return _enableMultipleCameras;
			}
			set
			{
				if (value != _enableMultipleCameras)
				{
					_enableMultipleCameras = value;
					UpdateMultiCameraSetup();
					isDirty = true;
				}
			}
		}

		public bool computeDepth
		{
			get
			{
				return _computeDepth;
			}
			set
			{
				if (value != _computeDepth)
				{
					_computeDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public COMPUTE_DEPTH_SCOPE computeDepthScope
		{
			get
			{
				return _computeDepthScope;
			}
			set
			{
				if (value != _computeDepthScope)
				{
					_computeDepthScope = value;
					if (_computeDepthScope == COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects)
					{
						_transparencyBlendMode = TRANSPARENT_MODE.None;
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float transparencyCutOff
		{
			get
			{
				return _transparencyCutOff;
			}
			set
			{
				if (value != _transparencyCutOff)
				{
					_transparencyCutOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool renderBeforeTransparent
		{
			get
			{
				return _renderBeforeTransparent;
			}
			set
			{
				if (value != _renderBeforeTransparent)
				{
					_renderBeforeTransparent = value;
					if (_renderBeforeTransparent)
					{
						_transparencyBlendMode = TRANSPARENT_MODE.None;
					}
					UpdateRenderComponents();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public GameObject sun
		{
			get
			{
				return _sun;
			}
			set
			{
				if (value != _sun)
				{
					_sun = value;
					UpdateSun();
					isDirty = true;
				}
			}
		}

		public float timeBetweenTextureUpdates
		{
			get
			{
				return _timeBetweenTextureUpdates;
			}
			set
			{
				if (value != _timeBetweenTextureUpdates)
				{
					_timeBetweenTextureUpdates = value;
					isDirty = true;
				}
			}
		}

		public bool sunCopyColor
		{
			get
			{
				return _sunCopyColor;
			}
			set
			{
				if (value != _sunCopyColor)
				{
					_sunCopyColor = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float density
		{
			get
			{
				return _density;
			}
			set
			{
				if (value != _density)
				{
					_preset = FOG_PRESET.Custom;
					_density = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseStrength
		{
			get
			{
				return _noiseStrength;
			}
			set
			{
				if (value != _noiseStrength)
				{
					_preset = FOG_PRESET.Custom;
					_noiseStrength = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseFinalMultiplier
		{
			get
			{
				return _noiseFinalMultiplier;
			}
			set
			{
				if (value != _noiseFinalMultiplier)
				{
					_preset = FOG_PRESET.Custom;
					_noiseFinalMultiplier = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseSparse
		{
			get
			{
				return _noiseSparse;
			}
			set
			{
				if (value != _noiseSparse)
				{
					_preset = FOG_PRESET.Custom;
					_noiseSparse = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float distance
		{
			get
			{
				return _distance;
			}
			set
			{
				if (value != _distance)
				{
					_preset = FOG_PRESET.Custom;
					_distance = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float maxFogLength
		{
			get
			{
				return _maxFogLength;
			}
			set
			{
				if (value != _maxFogLength)
				{
					_maxFogLength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float maxFogLengthFallOff
		{
			get
			{
				return _maxFogLengthFallOff;
			}
			set
			{
				if (value != _maxFogLengthFallOff)
				{
					_maxFogLengthFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float distanceFallOff
		{
			get
			{
				return _distanceFallOff;
			}
			set
			{
				if (value != _distanceFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_distanceFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float height
		{
			get
			{
				return _height;
			}
			set
			{
				if (value != _height)
				{
					_preset = FOG_PRESET.Custom;
					_height = Mathf.Max(value, 0.0001f);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float heightFallOff
		{
			get
			{
				return _heightFallOff;
			}
			set
			{
				if (value != _heightFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_heightFallOff = Mathf.Clamp01(value);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float deepObscurance
		{
			get
			{
				return _deepObscurance;
			}
			set
			{
				if (value != _deepObscurance && value >= 0f)
				{
					_preset = FOG_PRESET.Custom;
					_deepObscurance = Mathf.Clamp01(value);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float baselineHeight
		{
			get
			{
				return _baselineHeight;
			}
			set
			{
				if (value != _baselineHeight)
				{
					_preset = FOG_PRESET.Custom;
					_baselineHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool baselineRelativeToCamera
		{
			get
			{
				return _baselineRelativeToCamera;
			}
			set
			{
				if (value != _baselineRelativeToCamera)
				{
					_preset = FOG_PRESET.Custom;
					_baselineRelativeToCamera = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float baselineRelativeToCameraDelay
		{
			get
			{
				return _baselineRelativeToCameraDelay;
			}
			set
			{
				if (value != _baselineRelativeToCameraDelay)
				{
					_baselineRelativeToCameraDelay = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float noiseScale
		{
			get
			{
				return _noiseScale;
			}
			set
			{
				if (value != _noiseScale && value >= 0.2f)
				{
					_preset = FOG_PRESET.Custom;
					_noiseScale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float alpha
		{
			get
			{
				return _alpha;
			}
			set
			{
				if (value != _alpha)
				{
					_preset = FOG_PRESET.Custom;
					_alpha = value;
					currentFogAlpha = _alpha;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Color color
		{
			get
			{
				return _color;
			}
			set
			{
				if (value != _color)
				{
					_preset = FOG_PRESET.Custom;
					_color = value;
					currentFogColor = _color;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Color specularColor
		{
			get
			{
				return _specularColor;
			}
			set
			{
				if (value != _specularColor)
				{
					_preset = FOG_PRESET.Custom;
					_specularColor = value;
					currentFogSpecularColor = _specularColor;
					UpdateTexture();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float specularThreshold
		{
			get
			{
				return _specularThreshold;
			}
			set
			{
				if (value != _specularThreshold)
				{
					_preset = FOG_PRESET.Custom;
					_specularThreshold = value;
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float specularIntensity
		{
			get
			{
				return _specularIntensity;
			}
			set
			{
				if (value != _specularIntensity)
				{
					_preset = FOG_PRESET.Custom;
					_specularIntensity = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public Vector3 lightDirection
		{
			get
			{
				return _lightDirection;
			}
			set
			{
				if (value != _lightDirection)
				{
					_preset = FOG_PRESET.Custom;
					_lightDirection = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float lightIntensity
		{
			get
			{
				return _lightIntensity;
			}
			set
			{
				if (value != _lightIntensity)
				{
					_preset = FOG_PRESET.Custom;
					_lightIntensity = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public Color lightColor
		{
			get
			{
				return _lightColor;
			}
			set
			{
				if (value != _lightColor)
				{
					_preset = FOG_PRESET.Custom;
					_lightColor = value;
					currentLightColor = _lightColor;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public int updateTextureSpread
		{
			get
			{
				return _updateTextureSpread;
			}
			set
			{
				if (value != _updateTextureSpread)
				{
					_updateTextureSpread = value;
					isDirty = true;
				}
			}
		}

		public float speed
		{
			get
			{
				return _speed;
			}
			set
			{
				if (value != _speed)
				{
					_preset = FOG_PRESET.Custom;
					_speed = value;
					if (!UnityEngine.Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public Vector3 windDirection
		{
			get
			{
				return _windDirection;
			}
			set
			{
				if (value != _windDirection)
				{
					_preset = FOG_PRESET.Custom;
					_windDirection = value.normalized;
					if (!UnityEngine.Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public bool useRealTime
		{
			get
			{
				return _useRealTime;
			}
			set
			{
				if (value != _useRealTime)
				{
					_useRealTime = value;
					isDirty = true;
				}
			}
		}

		public Color skyColor
		{
			get
			{
				return _skyColor;
			}
			set
			{
				if (value != _skyColor)
				{
					_preset = FOG_PRESET.Custom;
					_skyColor = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skyHaze
		{
			get
			{
				return _skyHaze;
			}
			set
			{
				if (value != _skyHaze)
				{
					_preset = FOG_PRESET.Custom;
					_skyHaze = value;
					if (!UnityEngine.Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public float skyNoiseScale
		{
			get
			{
				return _skyNoiseScale;
			}
			set
			{
				if (value != _skyNoiseScale)
				{
					_skyNoiseScale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skySpeed
		{
			get
			{
				return _skySpeed;
			}
			set
			{
				if (value != _skySpeed)
				{
					_preset = FOG_PRESET.Custom;
					_skySpeed = value;
					isDirty = true;
				}
			}
		}

		public float skyNoiseStrength
		{
			get
			{
				return _skyNoiseStrength;
			}
			set
			{
				if (value != _skyNoiseStrength)
				{
					_preset = FOG_PRESET.Custom;
					_skyNoiseStrength = value;
					if (!UnityEngine.Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public float skyAlpha
		{
			get
			{
				return _skyAlpha;
			}
			set
			{
				if (value != _skyAlpha)
				{
					_preset = FOG_PRESET.Custom;
					_skyAlpha = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skyDepth
		{
			get
			{
				return _skyDepth;
			}
			set
			{
				if (value != _skyDepth)
				{
					_skyDepth = value;
					if (!UnityEngine.Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public GameObject character
		{
			get
			{
				return _character;
			}
			set
			{
				if (value != _character)
				{
					_character = value;
					isDirty = true;
				}
			}
		}

		public FOG_VOID_TOPOLOGY fogVoidTopology
		{
			get
			{
				return _fogVoidTopology;
			}
			set
			{
				if (value != _fogVoidTopology)
				{
					_fogVoidTopology = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidFallOff
		{
			get
			{
				return _fogVoidFallOff;
			}
			set
			{
				if (value != _fogVoidFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidRadius
		{
			get
			{
				return _fogVoidRadius;
			}
			set
			{
				if (value != _fogVoidRadius)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidRadius = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogVoidPosition
		{
			get
			{
				return _fogVoidPosition;
			}
			set
			{
				if (value != _fogVoidPosition)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidPosition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidDepth
		{
			get
			{
				return _fogVoidDepth;
			}
			set
			{
				if (value != _fogVoidDepth)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidHeight
		{
			get
			{
				return _fogVoidHeight;
			}
			set
			{
				if (value != _fogVoidHeight)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		[Obsolete("Fog Void inverted is now deprecated. Use Fog Area settings.")]
		public bool fogVoidInverted
		{
			get
			{
				return _fogVoidInverted;
			}
			set
			{
				_fogVoidInverted = value;
			}
		}

		public bool fogAreaShowGizmos
		{
			get
			{
				return _fogAreaShowGizmos;
			}
			set
			{
				if (value != _fogAreaShowGizmos)
				{
					_fogAreaShowGizmos = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public GameObject fogAreaCenter
		{
			get
			{
				return _fogAreaCenter;
			}
			set
			{
				if (value != _fogAreaCenter)
				{
					_fogAreaCenter = value;
					isDirty = true;
				}
			}
		}

		public float fogAreaFallOff
		{
			get
			{
				return _fogAreaFallOff;
			}
			set
			{
				if (value != _fogAreaFallOff)
				{
					_fogAreaFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_FOLLOW_MODE fogAreaFollowMode
		{
			get
			{
				return _fogAreaFollowMode;
			}
			set
			{
				if (value != _fogAreaFollowMode)
				{
					_fogAreaFollowMode = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_TOPOLOGY fogAreaTopology
		{
			get
			{
				return _fogAreaTopology;
			}
			set
			{
				if (value != _fogAreaTopology)
				{
					_fogAreaTopology = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaRadius
		{
			get
			{
				return _fogAreaRadius;
			}
			set
			{
				if (value != _fogAreaRadius)
				{
					_fogAreaRadius = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogAreaPosition
		{
			get
			{
				return _fogAreaPosition;
			}
			set
			{
				if (value != _fogAreaPosition)
				{
					_fogAreaPosition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaDepth
		{
			get
			{
				return _fogAreaDepth;
			}
			set
			{
				if (value != _fogAreaDepth)
				{
					_fogAreaDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaHeight
		{
			get
			{
				return _fogAreaHeight;
			}
			set
			{
				if (value != _fogAreaHeight)
				{
					_fogAreaHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_SORTING_MODE fogAreaSortingMode
		{
			get
			{
				return _fogAreaSortingMode;
			}
			set
			{
				if (value != _fogAreaSortingMode)
				{
					_fogAreaSortingMode = value;
					lastTimeSortInstances = 0f;
					isDirty = true;
				}
			}
		}

		public int fogAreaRenderOrder
		{
			get
			{
				return _fogAreaRenderOrder;
			}
			set
			{
				if (value != _fogAreaRenderOrder)
				{
					_fogAreaRenderOrder = value;
					lastTimeSortInstances = 0f;
					isDirty = true;
				}
			}
		}

		public bool pointLightTrackAuto
		{
			get
			{
				return _pointLightTrackingAuto;
			}
			set
			{
				if (value != _pointLightTrackingAuto)
				{
					_pointLightTrackingAuto = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public Transform pointLightTrackingPivot
		{
			get
			{
				return _pointLightTrackingPivot;
			}
			set
			{
				if (value != _pointLightTrackingPivot)
				{
					_pointLightTrackingPivot = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public int pointLightTrackingCount
		{
			get
			{
				return _pointLightTrackingCount;
			}
			set
			{
				if (value != _pointLightTrackingCount)
				{
					_pointLightTrackingCount = Mathf.Clamp(value, 0, 6);
					CheckPointLightData();
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightTrackingCheckInterval
		{
			get
			{
				return _pointLightTrackingCheckInterval;
			}
			set
			{
				if (value != _pointLightTrackingCheckInterval)
				{
					_pointLightTrackingCheckInterval = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightTrackingNewLightsCheckInterval
		{
			get
			{
				return _pointLightTrackingNewLightsCheckInterval;
			}
			set
			{
				if (value != _pointLightTrackingNewLightsCheckInterval)
				{
					_pointLightTrackingNewLightsCheckInterval = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightInscattering
		{
			get
			{
				return _pointLightInscattering;
			}
			set
			{
				if (value != _pointLightInscattering)
				{
					_pointLightInscattering = value;
					isDirty = true;
				}
			}
		}

		public float pointLightIntensity
		{
			get
			{
				return _pointLightIntensity;
			}
			set
			{
				if (value != _pointLightIntensity)
				{
					_pointLightIntensity = value;
					isDirty = true;
				}
			}
		}

		public float pointLightInsideAtten
		{
			get
			{
				return _pointLightInsideAtten;
			}
			set
			{
				if (value != _pointLightInsideAtten)
				{
					_pointLightInsideAtten = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int downsampling
		{
			get
			{
				return _downsampling;
			}
			set
			{
				if (value != _downsampling)
				{
					_preset = FOG_PRESET.Custom;
					_downsampling = value;
					isDirty = true;
				}
			}
		}

		public bool forceComposition
		{
			get
			{
				return _forceComposition;
			}
			set
			{
				if (value != _forceComposition)
				{
					_preset = FOG_PRESET.Custom;
					_forceComposition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool edgeImprove
		{
			get
			{
				return _edgeImprove;
			}
			set
			{
				if (value != _edgeImprove)
				{
					_preset = FOG_PRESET.Custom;
					_edgeImprove = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float edgeThreshold
		{
			get
			{
				return _edgeThreshold;
			}
			set
			{
				if (value != _edgeThreshold)
				{
					_preset = FOG_PRESET.Custom;
					_edgeThreshold = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float stepping
		{
			get
			{
				return _stepping;
			}
			set
			{
				if (value != _stepping)
				{
					_preset = FOG_PRESET.Custom;
					_stepping = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float steppingNear
		{
			get
			{
				return _steppingNear;
			}
			set
			{
				if (value != _steppingNear)
				{
					_preset = FOG_PRESET.Custom;
					_steppingNear = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool dithering
		{
			get
			{
				return _dithering;
			}
			set
			{
				if (value != _dithering)
				{
					_dithering = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float ditherStrength
		{
			get
			{
				return _ditherStrength;
			}
			set
			{
				if (value != _ditherStrength)
				{
					_ditherStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float jitterStrength
		{
			get
			{
				return _jitterStrength;
			}
			set
			{
				if (value != _jitterStrength)
				{
					_jitterStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool lightScatteringEnabled
		{
			get
			{
				return _lightScatteringEnabled;
			}
			set
			{
				if (value != _lightScatteringEnabled)
				{
					_lightScatteringEnabled = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringDiffusion
		{
			get
			{
				return _lightScatteringDiffusion;
			}
			set
			{
				if (value != _lightScatteringDiffusion)
				{
					_lightScatteringDiffusion = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringSpread
		{
			get
			{
				return _lightScatteringSpread;
			}
			set
			{
				if (value != _lightScatteringSpread)
				{
					_lightScatteringSpread = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int lightScatteringSamples
		{
			get
			{
				return _lightScatteringSamples;
			}
			set
			{
				if (value != _lightScatteringSamples)
				{
					_lightScatteringSamples = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringWeight
		{
			get
			{
				return _lightScatteringWeight;
			}
			set
			{
				if (value != _lightScatteringWeight)
				{
					_lightScatteringWeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringIllumination
		{
			get
			{
				return _lightScatteringIllumination;
			}
			set
			{
				if (value != _lightScatteringIllumination)
				{
					_lightScatteringIllumination = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringDecay
		{
			get
			{
				return _lightScatteringDecay;
			}
			set
			{
				if (value != _lightScatteringDecay)
				{
					_lightScatteringDecay = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringExposure
		{
			get
			{
				return _lightScatteringExposure;
			}
			set
			{
				if (value != _lightScatteringExposure)
				{
					_lightScatteringExposure = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringJittering
		{
			get
			{
				return _lightScatteringJittering;
			}
			set
			{
				if (value != _lightScatteringJittering)
				{
					_lightScatteringJittering = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int lightScatteringBlurDownscale
		{
			get
			{
				return _lightScatteringBlurDownscale;
			}
			set
			{
				if (value != _lightScatteringBlurDownscale)
				{
					_lightScatteringBlurDownscale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool fogBlur
		{
			get
			{
				return _fogBlur;
			}
			set
			{
				if (value != _fogBlur)
				{
					_fogBlur = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogBlurDepth
		{
			get
			{
				return _fogBlurDepth;
			}
			set
			{
				if (value != _fogBlurDepth)
				{
					_fogBlurDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool sunShadows
		{
			get
			{
				return _sunShadows;
			}
			set
			{
				if (value != _sunShadows)
				{
					_sunShadows = value;
					CleanUpTextureDepthSun();
					if (_sunShadows)
					{
						needUpdateDepthSunTexture = true;
					}
					else
					{
						DestroySunShadowsDependencies();
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public LayerMask sunShadowsLayerMask
		{
			get
			{
				return _sunShadowsLayerMask;
			}
			set
			{
				if ((int)_sunShadowsLayerMask != (int)value)
				{
					_sunShadowsLayerMask = value;
					isDirty = true;
				}
			}
		}

		public float sunShadowsStrength
		{
			get
			{
				return _sunShadowsStrength;
			}
			set
			{
				if (value != _sunShadowsStrength)
				{
					_sunShadowsStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsBias
		{
			get
			{
				return _sunShadowsBias;
			}
			set
			{
				if (value != _sunShadowsBias)
				{
					_sunShadowsBias = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsJitterStrength
		{
			get
			{
				return _sunShadowsJitterStrength;
			}
			set
			{
				if (value != _sunShadowsJitterStrength)
				{
					_sunShadowsJitterStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int sunShadowsResolution
		{
			get
			{
				return _sunShadowsResolution;
			}
			set
			{
				if (value != _sunShadowsResolution)
				{
					_sunShadowsResolution = value;
					needUpdateDepthSunTexture = true;
					CleanUpTextureDepthSun();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsMaxDistance
		{
			get
			{
				return _sunShadowsMaxDistance;
			}
			set
			{
				if (value != _sunShadowsMaxDistance)
				{
					_sunShadowsMaxDistance = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public SUN_SHADOWS_BAKE_MODE sunShadowsBakeMode
		{
			get
			{
				return _sunShadowsBakeMode;
			}
			set
			{
				if (value != _sunShadowsBakeMode)
				{
					_sunShadowsBakeMode = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsRefreshInterval
		{
			get
			{
				return _sunShadowsRefreshInterval;
			}
			set
			{
				if (value != _sunShadowsRefreshInterval)
				{
					_sunShadowsRefreshInterval = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsCancellation
		{
			get
			{
				return _sunShadowsCancellation;
			}
			set
			{
				if (value != _sunShadowsCancellation)
				{
					_sunShadowsCancellation = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float turbulenceStrength
		{
			get
			{
				return _turbulenceStrength;
			}
			set
			{
				if (value != _turbulenceStrength)
				{
					_turbulenceStrength = value;
					if (_turbulenceStrength <= 0f)
					{
						UpdateTexture();
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool useXYPlane
		{
			get
			{
				return _useXYPlane;
			}
			set
			{
				if (value != _useXYPlane)
				{
					_useXYPlane = value;
					if (_sunShadows)
					{
						needUpdateDepthSunTexture = true;
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool useSinglePassStereoRenderingMatrix
		{
			get
			{
				return _useSinglePassStereoRenderingMatrix;
			}
			set
			{
				if (value != _useSinglePassStereoRenderingMatrix)
				{
					_useSinglePassStereoRenderingMatrix = value;
					isDirty = true;
				}
			}
		}

		public SPSR_BEHAVIOUR spsrBehaviour
		{
			get
			{
				return _spsrBehaviour;
			}
			set
			{
				if (value != _spsrBehaviour)
				{
					_spsrBehaviour = value;
					isDirty = true;
				}
			}
		}

		public bool reduceFlickerBigWorlds
		{
			get
			{
				return _reduceFlickerBigWorlds;
			}
			set
			{
				if (value != _reduceFlickerBigWorlds)
				{
					_reduceFlickerBigWorlds = value;
					isDirty = true;
				}
			}
		}

		public bool enableMask
		{
			get
			{
				return _enableMask;
			}
			set
			{
				if (value != _enableMask)
				{
					_enableMask = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public LayerMask maskLayer
		{
			get
			{
				return _maskLayer;
			}
			set
			{
				if ((int)value != (int)_maskLayer)
				{
					_maskLayer = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public int maskDownsampling
		{
			get
			{
				return _maskDownsampling;
			}
			set
			{
				if (value != _maskDownsampling)
				{
					_maskDownsampling = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public Camera fogCamera => mainCamera;

		public int renderingInstancesCount => _renderingInstancesCount;

		public List<VolumetricFog> renderingInstances => fogRenderInstances;

		public List<VolumetricFog> instances => fogInstances;

		public bool hasCamera
		{
			get
			{
				if (!_hasCameraChecked)
				{
					_hasCamera = GetComponent<Camera>() != null;
					_hasCameraChecked = true;
				}
				return _hasCamera;
			}
		}

		public bool fogOfWarEnabled
		{
			get
			{
				return _fogOfWarEnabled;
			}
			set
			{
				if (value != _fogOfWarEnabled)
				{
					_fogOfWarEnabled = value;
					FogOfWarInit();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogOfWarCenter
		{
			get
			{
				return _fogOfWarCenter;
			}
			set
			{
				if (value != _fogOfWarCenter)
				{
					_fogOfWarCenter = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogOfWarSize
		{
			get
			{
				return _fogOfWarSize;
			}
			set
			{
				if (value != _fogOfWarSize && value.x > 0f && value.z > 0f)
				{
					_fogOfWarSize = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int fogOfWarTextureSize
		{
			get
			{
				return _fogOfWarTextureSize;
			}
			set
			{
				if (value != _fogOfWarTextureSize && value > 16)
				{
					_fogOfWarTextureSize = value;
					FogOfWarUpdateTexture();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogOfWarRestoreDelay
		{
			get
			{
				return _fogOfWarRestoreDelay;
			}
			set
			{
				if (value != _fogOfWarRestoreDelay)
				{
					_fogOfWarRestoreDelay = value;
					isDirty = true;
				}
			}
		}

		public float fogOfWarRestoreDuration
		{
			get
			{
				return _fogOfWarRestoreDuration;
			}
			set
			{
				if (value != _fogOfWarRestoreDuration)
				{
					_fogOfWarRestoreDuration = value;
					isDirty = true;
				}
			}
		}

		public float fogOfWarSmoothness
		{
			get
			{
				return _fogOfWarSmoothness;
			}
			set
			{
				if (value != _fogOfWarSmoothness)
				{
					_fogOfWarSmoothness = value;
					isDirty = true;
				}
			}
		}

		public bool maskEditorEnabled
		{
			get
			{
				return _maskEditorEnabled;
			}
			set
			{
				if (value != _maskEditorEnabled)
				{
					_maskEditorEnabled = value;
				}
			}
		}

		public MASK_TEXTURE_BRUSH_MODE maskBrushMode
		{
			get
			{
				return _maskBrushMode;
			}
			set
			{
				if (value != _maskBrushMode)
				{
					_maskBrushMode = value;
				}
			}
		}

		public int maskBrushWidth
		{
			get
			{
				return _maskBrushWidth;
			}
			set
			{
				if (value != _maskBrushWidth)
				{
					_maskBrushWidth = value;
				}
			}
		}

		public float maskBrushFuzziness
		{
			get
			{
				return _maskBrushFuzziness;
			}
			set
			{
				if (value != _maskBrushFuzziness)
				{
					_maskBrushFuzziness = value;
				}
			}
		}

		public float maskBrushOpacity
		{
			get
			{
				return _maskBrushOpacity;
			}
			set
			{
				if (value != _maskBrushOpacity)
				{
					_maskBrushOpacity = value;
				}
			}
		}

		public Texture2D fogOfWarTexture
		{
			get
			{
				return _fogOfWarTexture;
			}
			set
			{
				if (_fogOfWarTexture != value && value != null)
				{
					if (value.width != value.height)
					{
						UnityEngine.Debug.LogError("Fog of war texture must be square.");
						return;
					}
					_fogOfWarTexture = value;
					ReloadFogOfWarTexture();
				}
			}
		}

		public Color32[] fogOfWarTextureData
		{
			get
			{
				return fogOfWarColorBuffer;
			}
			set
			{
				fogOfWarEnabled = true;
				fogOfWarColorBuffer = value;
				if (value != null && !(_fogOfWarTexture == null) && value.Length == _fogOfWarTexture.width * _fogOfWarTexture.height)
				{
					_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
					_fogOfWarTexture.Apply();
				}
			}
		}

		private void OnEnable()
		{
			isPartOfScene = isPartOfScene || IsPartOfScene();
			if (!isPartOfScene)
			{
				return;
			}
			temporaryProperties.color = Color.white;
			temporaryProperties.density = 1f;
			if (_fogVoidInverted)
			{
				_fogVoidInverted = false;
				_fogAreaCenter = _character;
				_fogAreaDepth = _fogVoidDepth;
				_fogAreaFallOff = _fogVoidFallOff;
				_fogAreaHeight = _fogVoidHeight;
				_fogAreaPosition = _fogVoidPosition;
				_fogAreaRadius = _fogVoidRadius;
				_fogVoidRadius = 0f;
				_character = null;
			}
			mainCamera = base.gameObject.GetComponent<Camera>();
			_hasCamera = mainCamera != null;
			_hasCameraChecked = true;
			if (_hasCamera)
			{
				fogRenderer = this;
				if (mainCamera.depthTextureMode == DepthTextureMode.None)
				{
					mainCamera.depthTextureMode = DepthTextureMode.Depth;
				}
				UpdateVolumeMask();
			}
			else if (fogRenderer == null)
			{
				FindMainCamera();
				if (mainCamera == null)
				{
					UnityEngine.Debug.LogError("Volumetric Fog: no camera found!");
					return;
				}
				fogRenderer = mainCamera.GetComponent<VolumetricFog>();
				if (fogRenderer == null)
				{
					fogRenderer = mainCamera.gameObject.AddComponent<VolumetricFog>();
					fogRenderer.density = 0f;
				}
			}
			else
			{
				mainCamera = fogRenderer.mainCamera;
				if (mainCamera == null)
				{
					mainCamera = fogRenderer.GetComponent<Camera>();
				}
			}
			if (fogMat == null)
			{
				InitFogMaterial();
				if (_profile != null && _profileSync)
				{
					_profile.Load(this);
				}
			}
			else
			{
				UpdateMaterialPropertiesNow();
			}
			RegisterWithRenderers();
			needResort = true;
		}

		private void OnDisable()
		{
			RemoveMaskCommandBuffer();
		}

		private void OnDestroy()
		{
			if (!_hasCamera)
			{
				UnregisterWithRenderers();
			}
			else
			{
				RemoveMaskCommandBuffer();
				UnregisterFogArea(this);
			}
			if (depthCamObj != null)
			{
				UnityEngine.Object.DestroyImmediate(depthCamObj);
				depthCamObj = null;
			}
			if (adjustedTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(adjustedTexture);
				adjustedTexture = null;
			}
			if (chaosLerpMat != null)
			{
				UnityEngine.Object.DestroyImmediate(chaosLerpMat);
				chaosLerpMat = null;
			}
			if (adjustedChaosTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(adjustedChaosTexture);
				adjustedChaosTexture = null;
			}
			if (blurMat != null)
			{
				UnityEngine.Object.DestroyImmediate(blurMat);
				blurMat = null;
			}
			if (fogMat != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMat);
				fogMat = null;
			}
			CleanUpDepthTexture();
			DestroySunShadowsDependencies();
		}

		public void DestroySelf()
		{
			DestroyRenderComponent<VolumetricFogPreT>();
			DestroyRenderComponent<VolumetricFogPosT>();
			UnityEngine.Object.DestroyImmediate(this);
		}

		private void Start()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			lastTextureUpdate = Time.time + _timeBetweenTextureUpdates;
			RegisterWithRenderers();
			Update();
		}

		private void Update()
		{
			if (!isPartOfScene || fogRenderer == null)
			{
				return;
			}
			if (fogRenderer.sun != null)
			{
				Vector3 forward = fogRenderer.sun.transform.forward;
				if (!UnityEngine.Application.isPlaying || (updatingTextureSlice < 0 && Time.time - lastTextureUpdate >= _timeBetweenTextureUpdates))
				{
					if (forward != _lightDirection)
					{
						_lightDirection = forward;
						needUpdateTexture = true;
						needUpdateDepthSunTexture = true;
					}
					if (sunLight != null)
					{
						if (_sunCopyColor && sunLight.color != _lightColor)
						{
							_lightColor = sunLight.color;
							currentLightColor = _lightColor;
							needUpdateTexture = true;
						}
						if (sunLightIntensity != sunLight.intensity)
						{
							sunLightIntensity = sunLight.intensity;
							needUpdateTexture = true;
						}
					}
				}
			}
			if (!needUpdateTexture)
			{
				if (_lightingModel == LIGHTING_MODEL.Classic)
				{
					if (lastRenderSettingsAmbientIntensity != RenderSettings.ambientIntensity)
					{
						needUpdateTexture = true;
					}
					else if (lastRenderSettingsAmbientLight != RenderSettings.ambientLight)
					{
						needUpdateTexture = true;
					}
				}
				else if (_lightingModel == LIGHTING_MODEL.Natural && lastRenderSettingsAmbientLight != RenderSettings.ambientLight)
				{
					needUpdateTexture = true;
				}
			}
			if (transitionProfile)
			{
				float num = (Time.time - transitionStartTime) / transitionDuration;
				if (num > 1f)
				{
					num = 1f;
				}
				VolumetricFogProfile.Lerp(initialProfile, targetProfile, num, this);
				if (num >= 1f)
				{
					transitionProfile = false;
				}
			}
			if (transitionAlpha)
			{
				if (targetFogAlpha >= 0f || targetSkyHazeAlpha >= 0f)
				{
					if (targetFogAlpha != currentFogAlpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
					{
						if (transitionDuration > 0f)
						{
							currentFogAlpha = Mathf.Lerp(initialFogAlpha, targetFogAlpha, (Time.time - transitionStartTime) / transitionDuration);
							currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, targetSkyHazeAlpha, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogAlpha = targetFogAlpha;
							currentSkyHazeAlpha = targetSkyHazeAlpha;
							transitionAlpha = false;
						}
						fogMat.SetFloat("_FogAlpha", currentFogAlpha);
						UpdateSkyColor(currentSkyHazeAlpha);
					}
				}
				else if (currentFogAlpha != _alpha || currentSkyHazeAlpha != _skyAlpha)
				{
					if (transitionDuration > 0f)
					{
						currentFogAlpha = Mathf.Lerp(initialFogAlpha, _alpha, (Time.time - transitionStartTime) / transitionDuration);
						currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, alpha, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogAlpha = _alpha;
						currentSkyHazeAlpha = _skyAlpha;
						transitionAlpha = false;
					}
					fogMat.SetFloat("_FogAlpha", currentFogAlpha);
					UpdateSkyColor(currentSkyHazeAlpha);
				}
			}
			if (transitionColor)
			{
				if (targetColorActive)
				{
					if (targetFogColor != currentFogColor)
					{
						if (transitionDuration > 0f)
						{
							currentFogColor = Color.Lerp(initialFogColor, targetFogColor, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogColor = targetFogColor;
							transitionColor = false;
						}
					}
				}
				else if (currentFogColor != _color)
				{
					if (transitionDuration > 0f)
					{
						currentFogColor = Color.Lerp(initialFogColor, _color, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogColor = _color;
						transitionColor = false;
					}
				}
				UpdateMaterialFogColor();
			}
			if (transitionSpecularColor)
			{
				if (targetSpecularColorActive)
				{
					if (targetFogSpecularColor != currentFogSpecularColor)
					{
						if (transitionDuration > 0f)
						{
							currentFogSpecularColor = Color.Lerp(initialFogSpecularColor, targetFogSpecularColor, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogSpecularColor = targetFogSpecularColor;
							transitionSpecularColor = false;
						}
						needUpdateTexture = true;
					}
				}
				else if (currentFogSpecularColor != _specularColor)
				{
					if (transitionDuration > 0f)
					{
						currentFogSpecularColor = Color.Lerp(initialFogSpecularColor, _specularColor, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogSpecularColor = _specularColor;
						transitionSpecularColor = false;
					}
					needUpdateTexture = true;
				}
			}
			if (transitionLightColor)
			{
				if (targetLightColorActive)
				{
					if (targetLightColor != currentLightColor)
					{
						if (transitionDuration > 0f)
						{
							currentLightColor = Color.Lerp(initialLightColor, targetLightColor, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentLightColor = targetLightColor;
							transitionLightColor = false;
						}
						needUpdateTexture = true;
					}
				}
				else if (currentLightColor != _lightColor)
				{
					if (transitionDuration > 0f)
					{
						currentLightColor = Color.Lerp(initialLightColor, _lightColor, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentLightColor = _lightColor;
						transitionLightColor = false;
					}
					needUpdateTexture = true;
				}
			}
			if (_baselineRelativeToCamera)
			{
				UpdateMaterialHeights(mainCamera);
			}
			else if (_character != null)
			{
				_fogVoidPosition = _character.transform.position;
				UpdateMaterialHeights(mainCamera);
			}
			if (_fogAreaCenter != null)
			{
				if (_fogAreaFollowMode == FOG_AREA_FOLLOW_MODE.FullXYZ)
				{
					_fogAreaPosition = _fogAreaCenter.transform.position;
				}
				else
				{
					_fogAreaPosition.x = _fogAreaCenter.transform.position.x;
					_fogAreaPosition.z = _fogAreaCenter.transform.position.z;
				}
				UpdateMaterialHeights(mainCamera);
			}
			if (_pointLightTrackingAuto && (!UnityEngine.Application.isPlaying || Time.time - trackPointAutoLastTime > _pointLightTrackingCheckInterval))
			{
				trackPointAutoLastTime = Time.time;
				TrackPointLights();
			}
			if (updatingTextureSlice >= 0)
			{
				UpdateTextureColors(adjustedColors, forceUpdateEntireTexture: false);
			}
			else if (needUpdateTexture)
			{
				UpdateTexture();
			}
			if (!_hasCamera)
			{
				return;
			}
			if (_fogOfWarEnabled)
			{
				UpdateFogOfWar();
			}
			if (sunShadowsActive)
			{
				CastSunShadows();
			}
			int count = fogInstances.Count;
			if (count <= 1)
			{
				return;
			}
			Vector3 position = mainCamera.transform.position;
			if (!UnityEngine.Application.isPlaying || Time.time - lastTimeSortInstances >= 2f)
			{
				needResort = true;
			}
			if (!needResort && (position.x - lastCamPos.x) * (position.x - lastCamPos.x) + (position.y - lastCamPos.y) * (position.y - lastCamPos.y) + (position.z - lastCamPos.z) * (position.z - lastCamPos.z) > 625f)
			{
				lastCamPos = position;
				needResort = true;
			}
			if (!needResort)
			{
				return;
			}
			needResort = false;
			lastTimeSortInstances = Time.time;
			float x2 = position.x;
			float y2 = position.y;
			float z = position.z;
			for (int i = 0; i < count; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				if (volumetricFog != null)
				{
					Vector3 position2 = volumetricFog.transform.position;
					position2.y = volumetricFog.currentFogAltitude;
					float num2 = x2 - position2.x;
					float num3 = y2 - position2.y;
					float num4 = num3 * num3;
					float num5 = y2 - (position2.y + volumetricFog.height);
					float num6 = num5 * num5;
					volumetricFog.distanceToCameraYAxis = ((num4 < num6) ? num4 : num6);
					float num7 = z - position2.z;
					float num8 = num2 * num2 + num3 * num3 + num7 * num7;
					volumetricFog.distanceToCamera = num8;
					Vector3 position3 = position2 - volumetricFog.transform.localScale * 0.5f;
					Vector3 position4 = position2 + volumetricFog.transform.localScale * 0.5f;
					volumetricFog.distanceToCameraMin = mainCamera.WorldToScreenPoint(position3).z;
					volumetricFog.distanceToCameraMax = mainCamera.WorldToScreenPoint(position4).z;
				}
			}
			fogInstances.Sort(delegate(VolumetricFog x, VolumetricFog y)
			{
				if (!x || !y)
				{
					return 0;
				}
				if (x._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Fixed || y._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Fixed)
				{
					if (x._fogAreaRenderOrder < y._fogAreaRenderOrder)
					{
						return -1;
					}
					if (x._fogAreaRenderOrder > y._fogAreaRenderOrder)
					{
						return 1;
					}
					return 0;
				}
				if ((x.distanceToCameraMin < y.distanceToCameraMin && x.distanceToCameraMax > y.distanceToCameraMax) || (y.distanceToCameraMin < x.distanceToCameraMin && y.distanceToCameraMax > x.distanceToCameraMax) || x._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Altitude || y._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Altitude)
				{
					if (x.distanceToCameraYAxis < y.distanceToCameraYAxis)
					{
						return 1;
					}
					if (x.distanceToCameraYAxis > y.distanceToCameraYAxis)
					{
						return -1;
					}
					return 0;
				}
				if (x.distanceToCamera < y.distanceToCamera)
				{
					return 1;
				}
				return (x.distanceToCamera > y.distanceToCamera) ? (-1) : 0;
			});
		}

		private void OnPreCull()
		{
			if (!base.enabled || !base.gameObject.activeSelf || fogMat == null || !_hasCamera || mainCamera == null)
			{
				return;
			}
			if (mainCamera.depthTextureMode == DepthTextureMode.None)
			{
				mainCamera.depthTextureMode = DepthTextureMode.Depth;
			}
			if (_computeDepth)
			{
				GetTransparentDepth();
			}
			if (!_hasCamera || !UnityEngine.Application.isPlaying)
			{
				return;
			}
			int count = fogRenderInstances.Count;
			for (int i = 0; i < count; i++)
			{
				if (fogRenderInstances[i] != null && fogRenderInstances[i].turbulenceStrength > 0f)
				{
					fogRenderInstances[i].ApplyChaos();
				}
			}
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		private void FindMainCamera()
		{
			mainCamera = Camera.main;
			if (!(mainCamera == null))
			{
				return;
			}
			Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].isActiveAndEnabled)
				{
					mainCamera = array[i];
					break;
				}
			}
		}

		private bool IsPartOfScene()
		{
			VolumetricFog[] array = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == this)
				{
					return true;
				}
			}
			return false;
		}

		private void InitFogMaterial()
		{
			targetFogAlpha = -1f;
			targetSkyHazeAlpha = -1f;
			_skyColor.a = _skyAlpha;
			updatingTextureSlice = -1;
			fogMat = new Material(Shader.Find("VolumetricFogAndMist/VolumetricFog"));
			fogMat.hideFlags = HideFlags.DontSave;
			Texture2D texture2D = Resources.Load<Texture2D>("Textures/Noise3");
			noiseTextureSize = texture2D.width;
			noiseColors = texture2D.GetPixels();
			adjustedColors = new Color[noiseColors.Length];
			adjustedTexture = new Texture2D(texture2D.width, texture2D.height, TextureFormat.RGBA32, mipChain: false);
			adjustedTexture.hideFlags = HideFlags.DontSave;
			timeOfLastRender = Time.time;
			CheckPointLightData();
			if (_pointLightTrackingAuto)
			{
				TrackPointLights();
			}
			FogOfWarInit();
			CopyTransitionValues();
			UpdatePreset();
			oldBaselineRelativeCameraY = mainCamera.transform.position.y;
			if (_sunShadows)
			{
				needUpdateDepthSunTexture = true;
			}
		}

		private void UpdateRenderComponents()
		{
			if (_hasCamera)
			{
				if (_renderBeforeTransparent)
				{
					AssignRenderComponent<VolumetricFogPreT>();
					DestroyRenderComponent<VolumetricFogPosT>();
				}
				else if (_transparencyBlendMode == TRANSPARENT_MODE.Blend)
				{
					AssignRenderComponent<VolumetricFogPreT>();
					AssignRenderComponent<VolumetricFogPosT>();
				}
				else
				{
					AssignRenderComponent<VolumetricFogPosT>();
					DestroyRenderComponent<VolumetricFogPreT>();
				}
			}
		}

		private void DestroyRenderComponent<T>() where T : IVolumetricFogRenderComponent
		{
			T[] componentsInChildren = GetComponentsInChildren<T>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].fog == this || componentsInChildren[i].fog == null)
				{
					componentsInChildren[i].DestroySelf();
				}
			}
		}

		private void AssignRenderComponent<T>() where T : Component, IVolumetricFogRenderComponent
		{
			T[] componentsInChildren = GetComponentsInChildren<T>(includeInactive: true);
			int num = -1;
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].fog == this)
				{
					return;
				}
				if (componentsInChildren[i].fog == null)
				{
					num = i;
				}
			}
			if (num < 0)
			{
				base.gameObject.AddComponent<T>().fog = this;
			}
			else
			{
				componentsInChildren[num].fog = this;
			}
		}

		private void RegisterFogArea(VolumetricFog fog)
		{
			if (!fogInstances.Contains(fog))
			{
				fogInstances.Add(fog);
			}
		}

		private void UnregisterFogArea(VolumetricFog fog)
		{
			if (fogInstances.Contains(fog))
			{
				fogInstances.Remove(fog);
			}
		}

		private void RegisterWithRenderers()
		{
			allFogRenderers = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			if (!_hasCamera && fogRenderer != null)
			{
				if (fogRenderer.enableMultipleCameras)
				{
					for (int i = 0; i < allFogRenderers.Length; i++)
					{
						if (allFogRenderers[i].hasCamera)
						{
							allFogRenderers[i].RegisterFogArea(this);
						}
					}
				}
				else
				{
					fogRenderer.RegisterFogArea(this);
				}
			}
			else
			{
				fogInstances.Clear();
				RegisterFogArea(this);
				for (int j = 0; j < allFogRenderers.Length; j++)
				{
					if (!allFogRenderers[j].hasCamera && (_enableMultipleCameras || allFogRenderers[j].fogRenderer == this))
					{
						RegisterFogArea(allFogRenderers[j]);
					}
				}
			}
			lastTimeSortInstances = 0f;
		}

		private void UnregisterWithRenderers()
		{
			if (allFogRenderers == null)
			{
				return;
			}
			for (int i = 0; i < allFogRenderers.Length; i++)
			{
				if (allFogRenderers[i] != null && allFogRenderers[i].hasCamera)
				{
					allFogRenderers[i].UnregisterFogArea(this);
				}
			}
		}

		public void UpdateMultiCameraSetup()
		{
			allFogRenderers = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			for (int i = 0; i < allFogRenderers.Length; i++)
			{
				if (allFogRenderers[i] != null && allFogRenderers[i].hasCamera)
				{
					allFogRenderers[i].SetEnableMultipleCameras(_enableMultipleCameras);
				}
			}
			RegisterWithRenderers();
		}

		private void SetEnableMultipleCameras(bool state)
		{
			_enableMultipleCameras = state;
			RegisterWithRenderers();
		}

		internal void DoOnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int count = fogInstances.Count;
			fogRenderInstances.Clear();
			Vector3 position = Camera.current.transform.position;
			for (int i = 0; i < count; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				volumetricFog.isRendering = false;
				if (volumetricFog != null && volumetricFog.isActiveAndEnabled && volumetricFog.density > 0f && (volumetricFog._visibilityScope == FOG_VISIBILITY_SCOPE.Global || volumetricFog._visibilityVolume.Contains(position)))
				{
					fogRenderInstances.Add(fogInstances[i]);
				}
			}
			_renderingInstancesCount = fogRenderInstances.Count;
			if (_renderingInstancesCount == 0 || mainCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (_hasCamera && _density <= 0f && shouldUpdateMaterialProperties)
			{
				UpdateMaterialPropertiesNow(Camera.current);
			}
			if (_renderingInstancesCount == 1)
			{
				fogRenderInstances[0].DoOnRenderImageInstance(source, destination);
				return;
			}
			RenderTextureDescriptor descriptor = source.descriptor;
			descriptor.depthBufferBits = 0;
			descriptor.msaaSamples = 1;
			RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
			fogRenderInstances[0].DoOnRenderImageInstance(source, temporary);
			if (_renderingInstancesCount == 2)
			{
				fogRenderInstances[1].DoOnRenderImageInstance(temporary, destination);
			}
			if (_renderingInstancesCount >= 3)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(descriptor);
				RenderTexture source2 = temporary;
				RenderTexture renderTexture = temporary2;
				int num = _renderingInstancesCount - 1;
				for (int j = 1; j < num; j++)
				{
					if (j > 1)
					{
						renderTexture.DiscardContents();
					}
					fogRenderInstances[j].DoOnRenderImageInstance(source2, renderTexture);
					if (renderTexture == temporary2)
					{
						source2 = temporary2;
						renderTexture = temporary;
					}
					else
					{
						source2 = temporary;
						renderTexture = temporary2;
					}
				}
				fogRenderInstances[num].DoOnRenderImageInstance(source2, destination);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		internal void DoOnRenderImageInstance(RenderTexture source, RenderTexture destination)
		{
			Camera current = Camera.current;
			if (current == null || fogMat == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			isRendering = true;
			if (!_hasCamera)
			{
				CheckFogAreaDimensions();
				if (_sunShadows && !fogRenderer.sunShadows)
				{
					fogRenderer.sunShadows = true;
				}
			}
			if (shouldUpdateMaterialProperties)
			{
				UpdateMaterialPropertiesNow(current);
			}
			if (lastFrameCount != Time.frameCount && UnityEngine.Application.isPlaying)
			{
				if (_useRealTime)
				{
					deltaTime = Time.time - timeOfLastRender;
					timeOfLastRender = Time.time;
				}
				else
				{
					deltaTime = Time.deltaTime;
				}
				UpdateWindSpeedQuick();
			}
			if (_hasCamera)
			{
				if (_spsrBehaviour == SPSR_BEHAVIOUR.ForcedOn && !_useSinglePassStereoRenderingMatrix)
				{
					useSinglePassStereoRenderingMatrix = true;
				}
				else if (_spsrBehaviour == SPSR_BEHAVIOUR.ForcedOff && _useSinglePassStereoRenderingMatrix)
				{
					useSinglePassStereoRenderingMatrix = false;
				}
			}
			bool flag = XRSettings.enabled;
			Vector3 position = current.transform.position;
			bool flag2 = fogRenderer.reduceFlickerBigWorlds;
			if (flag2)
			{
				fogMat.SetVector("_FlickerFreeCamPos", position);
				current.transform.position = Vector3.zero;
				if (flag)
				{
					current.ResetWorldToCameraMatrix();
				}
			}
			else
			{
				fogMat.SetVector("_FlickerFreeCamPos", Vector3.zero);
			}
			if (current.orthographic)
			{
				fogMat.SetVector("_ClipDir", current.transform.forward);
			}
			if (flag && fogRenderer.useSinglePassStereoRenderingMatrix)
			{
				fogMat.SetMatrix("_ClipToWorld", current.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", current.cameraToWorldMatrix * current.projectionMatrix.inverse);
			}
			if (flag2)
			{
				current.transform.position = position;
			}
			if (_lightScatteringEnabled && (bool)fogRenderer.sun)
			{
				UpdateScatteringData(current);
			}
			if (lastFrameCount != Time.frameCount || !UnityEngine.Application.isPlaying)
			{
				if (pointLightParams.Length != 6)
				{
					CheckPointLightData();
				}
				for (int i = 0; i < pointLightParams.Length; i++)
				{
					Light light = pointLightParams[i].light;
					if (!(light != null))
					{
						continue;
					}
					if (pointLightParams[i].color != light.color)
					{
						pointLightParams[i].color = light.color;
						isDirty = true;
					}
					if (pointLightParams[i].range != light.range)
					{
						pointLightParams[i].range = light.range;
						isDirty = true;
					}
					if (pointLightParams[i].position != light.transform.position)
					{
						pointLightParams[i].position = light.transform.position;
						isDirty = true;
					}
					if (pointLightParams[i].intensity != light.intensity)
					{
						pointLightParams[i].intensity = light.intensity;
						isDirty = true;
					}
					if (pointLightParams[i].lightParams == null)
					{
						pointLightParams[i].lightParams = pointLightParams[i].light.GetComponent<VolumetricFogLightParams>();
						if (pointLightParams[i].lightParams == null)
						{
							pointLightParams[i].lightParams = pointLightParams[i].light.gameObject.AddComponent<VolumetricFogLightParams>();
						}
					}
					pointLightParams[i].rangeMultiplier = pointLightParams[i].lightParams.rangeMultiplier;
					pointLightParams[i].intensityMultiplier = pointLightParams[i].lightParams.intensityMultiplier;
				}
				SetPointLightMaterialProperties(current);
			}
			RenderTexture renderTexture = null;
			if ((float)_downsampling > 1f || _forceComposition)
			{
				int scaledSize = GetScaledSize(source.width, _downsampling);
				int scaledSize2 = GetScaledSize(source.width, _downsampling);
				RenderTextureDescriptor descriptor = source.descriptor;
				descriptor.width = scaledSize;
				descriptor.height = scaledSize2;
				descriptor.msaaSamples = 1;
				reducedDestination = RenderTexture.GetTemporary(descriptor);
				RenderTextureDescriptor descriptor2 = source.descriptor;
				descriptor2.width = scaledSize;
				descriptor2.height = scaledSize2;
				descriptor2.msaaSamples = 1;
				RenderTextureFormat colorFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RFloat) ? RenderTextureFormat.RFloat : RenderTextureFormat.ARGBFloat);
				descriptor.colorFormat = colorFormat;
				RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
				if (_fogBlur)
				{
					SetBlurTexture(source, descriptor);
				}
				if (!_edgeImprove || flag || SystemInfo.supportedRenderTargetCount < 2)
				{
					Graphics.Blit(source, reducedDestination, fogMat, 3);
					if (_edgeImprove)
					{
						Graphics.Blit(source, temporary, fogMat, 4);
						fogMat.SetTexture("_DownsampledDepth", temporary);
					}
					else
					{
						fogMat.SetTexture("_DownsampledDepth", null);
					}
				}
				else
				{
					fogMat.SetTexture("_MainTex", source);
					if (mrt == null)
					{
						mrt = new RenderBuffer[2];
					}
					mrt[0] = reducedDestination.colorBuffer;
					mrt[1] = temporary.colorBuffer;
					Graphics.SetRenderTarget(mrt, reducedDestination.depthBuffer);
					Graphics.Blit(null, fogMat, 1);
					fogMat.SetTexture("_DownsampledDepth", temporary);
				}
				fogMat.SetTexture("_FogDownsampled", reducedDestination);
				Graphics.Blit(source, destination, fogMat, 2);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(reducedDestination);
			}
			else
			{
				if (_fogBlur)
				{
					RenderTextureDescriptor descriptor3 = source.descriptor;
					descriptor3.width = 256;
					descriptor3.height = 256;
					SetBlurTexture(source, descriptor3);
				}
				Graphics.Blit(source, destination, fogMat, 0);
			}
			if (flag2 && flag)
			{
				current.ResetWorldToCameraMatrix();
			}
			if (renderTexture != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			lastFrameCount = Time.frameCount;
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}

		private void CleanUpDepthTexture()
		{
			if ((bool)depthTexture)
			{
				RenderTexture.ReleaseTemporary(depthTexture);
				depthTexture = null;
			}
		}

		private void GetTransparentDepth()
		{
			CleanUpDepthTexture();
			if (depthCam == null)
			{
				if (depthCamObj == null)
				{
					depthCamObj = GameObject.Find("VFMDepthCamera");
				}
				if (depthCamObj == null)
				{
					depthCamObj = new GameObject("VFMDepthCamera");
					depthCam = depthCamObj.AddComponent<Camera>();
					depthCam.enabled = false;
					depthCamObj.hideFlags = HideFlags.HideAndDontSave;
				}
				else
				{
					depthCam = depthCamObj.GetComponent<Camera>();
					if (depthCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthCamObj);
						depthCamObj = null;
						return;
					}
				}
			}
			depthCam.CopyFrom(mainCamera);
			depthCam.depthTextureMode = DepthTextureMode.None;
			depthTexture = RenderTexture.GetTemporary(mainCamera.pixelWidth, mainCamera.pixelHeight, 24, RenderTextureFormat.Depth, RenderTextureReadWrite.Linear);
			depthCam.backgroundColor = new Color(0f, 0f, 0f, 0f);
			depthCam.clearFlags = CameraClearFlags.Color;
			depthCam.cullingMask = _transparencyLayerMask;
			depthCam.targetTexture = depthTexture;
			depthCam.renderingPath = RenderingPath.Forward;
			if (depthShader == null)
			{
				depthShader = Shader.Find("VolumetricFogAndMist/CopyDepth");
			}
			if (depthShaderAndTrans == null)
			{
				depthShaderAndTrans = Shader.Find("VolumetricFogAndMist/CopyDepthAndTrans");
			}
			switch (_computeDepthScope)
			{
			case COMPUTE_DEPTH_SCOPE.OnlyTreeBillboards:
				depthCam.RenderWithShader(depthShader, "RenderType");
				break;
			case COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects:
				depthCam.RenderWithShader(depthShaderAndTrans, "RenderType");
				break;
			default:
				depthCam.RenderWithShader(depthShaderAndTrans, null);
				break;
			}
			Shader.SetGlobalTexture("_VolumetricFogDepthTexture", depthTexture);
		}

		private void CastSunShadows()
		{
			if (base.enabled && base.gameObject.activeSelf && !(fogMat == null))
			{
				if (_sunShadowsBakeMode == SUN_SHADOWS_BAKE_MODE.Discrete && _sunShadowsRefreshInterval > 0f && Time.time > lastShadowUpdateFrame + _sunShadowsRefreshInterval)
				{
					needUpdateDepthSunTexture = true;
				}
				if (!UnityEngine.Application.isPlaying || needUpdateDepthSunTexture || depthSunTexture == null || !depthSunTexture.IsCreated())
				{
					needUpdateDepthSunTexture = false;
					lastShadowUpdateFrame = Time.time;
					GetSunShadows();
				}
			}
		}

		private void GetSunShadows()
		{
			if (_sun == null || !_sunShadows)
			{
				return;
			}
			if (depthSunCam == null)
			{
				if (depthSunCamObj == null)
				{
					depthSunCamObj = GameObject.Find("VFMDepthSunCamera");
				}
				if (depthSunCamObj == null)
				{
					depthSunCamObj = new GameObject("VFMDepthSunCamera");
					depthSunCamObj.hideFlags = HideFlags.HideAndDontSave;
					depthSunCam = depthSunCamObj.AddComponent<Camera>();
				}
				else
				{
					depthSunCam = depthSunCamObj.GetComponent<Camera>();
					if (depthSunCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthSunCamObj);
						depthSunCamObj = null;
						return;
					}
				}
				if (depthSunShader == null)
				{
					depthSunShader = Shader.Find("VolumetricFogAndMist/CopySunDepth");
				}
				depthSunCam.SetReplacementShader(depthSunShader, "RenderType");
				depthSunCam.nearClipPlane = 1f;
				depthSunCam.renderingPath = RenderingPath.Forward;
				depthSunCam.orthographic = true;
				depthSunCam.aspect = 1f;
				depthSunCam.backgroundColor = new Color(0f, 0f, 0.5f, 0f);
				depthSunCam.clearFlags = CameraClearFlags.Color;
				depthSunCam.depthTextureMode = DepthTextureMode.None;
			}
			float orthographicSize = _sunShadowsMaxDistance / 0.95f;
			depthSunCam.transform.position = mainCamera.transform.position - _sun.transform.forward * 2000f;
			depthSunCam.transform.rotation = _sun.transform.rotation;
			depthSunCam.farClipPlane = 4000f;
			depthSunCam.orthographicSize = orthographicSize;
			if (sunLight != null)
			{
				depthSunCam.cullingMask = _sunShadowsLayerMask;
			}
			if (depthSunTexture == null || currentDepthSunTextureRes != _sunShadowsResolution)
			{
				currentDepthSunTextureRes = _sunShadowsResolution;
				int width = (int)Mathf.Pow(2f, _sunShadowsResolution + 9);
				depthSunTexture = new RenderTexture(width, width, 24, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				depthSunTexture.hideFlags = HideFlags.DontSave;
				depthSunTexture.filterMode = FilterMode.Point;
				depthSunTexture.wrapMode = TextureWrapMode.Clamp;
				depthSunTexture.Create();
			}
			depthSunCam.targetTexture = depthSunTexture;
			Shader.SetGlobalFloat("_VF_ShadowBias", _sunShadowsBias);
			if (UnityEngine.Application.isPlaying && _sunShadowsBakeMode == SUN_SHADOWS_BAKE_MODE.Realtime)
			{
				if (!depthSunCam.enabled)
				{
					depthSunCam.enabled = true;
				}
			}
			else
			{
				if (depthSunCam.enabled)
				{
					depthSunCam.enabled = false;
				}
				depthSunCam.Render();
			}
			Shader.SetGlobalMatrix("_VolumetricFogSunProj", depthSunCam.projectionMatrix * depthSunCam.worldToCameraMatrix);
			Shader.SetGlobalTexture("_VolumetricFogSunDepthTexture", depthSunTexture);
			Vector4 value = depthSunCam.transform.position;
			value.w = Mathf.Min(_sunShadowsMaxDistance, _maxFogLength);
			Shader.SetGlobalVector("_VolumetricFogSunWorldPos", value);
			UpdateSunShadowsData();
		}

		private void SetBlurTexture(RenderTexture source, RenderTextureDescriptor desc)
		{
			if (blurMat == null)
			{
				Shader shader = Shader.Find("VolumetricFogAndMist/Blur");
				blurMat = new Material(shader);
				blurMat.hideFlags = HideFlags.DontSave;
			}
			if (!(blurMat == null))
			{
				blurMat.SetFloat("_BlurDepth", _fogBlurDepth);
				RenderTexture temporary = RenderTexture.GetTemporary(desc);
				Graphics.Blit(source, temporary, blurMat, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(desc);
				Graphics.Blit(temporary, temporary2, blurMat, 1);
				blurMat.SetFloat("_BlurDepth", _fogBlurDepth * 2f);
				temporary.DiscardContents();
				Graphics.Blit(temporary2, temporary, blurMat, 0);
				temporary2.DiscardContents();
				Graphics.Blit(temporary, temporary2, blurMat, 1);
				fogMat.SetTexture("_BlurTex", temporary2);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary);
			}
		}

		private void DestroySunShadowsDependencies()
		{
			if (depthSunCamObj != null)
			{
				UnityEngine.Object.DestroyImmediate(depthSunCamObj);
				depthSunCamObj = null;
			}
			CleanUpTextureDepthSun();
		}

		private void CleanUpTextureDepthSun()
		{
			if (depthSunTexture != null)
			{
				depthSunTexture.Release();
				depthSunTexture = null;
			}
		}

		public string GetCurrentPresetName()
		{
			return Enum.GetName(typeof(FOG_PRESET), _preset);
		}

		public void UpdatePreset()
		{
			switch (_preset)
			{
			case FOG_PRESET.Clear:
				_density = 0f;
				_fogOfWarEnabled = false;
				_fogVoidRadius = 0f;
				break;
			case FOG_PRESET.Mist:
				_skySpeed = 0.3f;
				_skyHaze = 15f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.8f;
				_density = 0.3f;
				_noiseStrength = 0.6f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 6f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.89f, 0.89f, 0.89f);
				_skyColor = new Color(0.81f, 0.81f, 0.81f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.1f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.12f;
				_speed = 0.01f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.WindyMist:
				_skySpeed = 0.3f;
				_skyHaze = 25f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.85f;
				_density = 0.3f;
				_noiseStrength = 0.5f;
				_noiseScale = 1.15f;
				_skyNoiseScale = 1.15f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 6.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 10f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.81f, 0.81f, 0.81f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.1f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.15f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.GroundFog:
				_skySpeed = 0.3f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.85f;
				_density = 0.6f;
				_noiseStrength = 0.479f;
				_noiseScale = 1.15f;
				_skyNoiseScale = 1.15f;
				_noiseSparse = 0f;
				_distance = 5f;
				_distanceFallOff = 1f;
				_height = 1.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 0.95f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.2f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.2f;
				_speed = 0.01f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.FrostedGround:
				_skySpeed = 0f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.729f;
				_skyAlpha = 0.55f;
				_density = 1f;
				_noiseStrength = 0.164f;
				_noiseScale = 1.81f;
				_skyNoiseScale = 1.81f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 0.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 20f;
				_steppingNear = 50f;
				_alpha = 0.97f;
				_color = new Color(0.546f, 0.648f, 0.71f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.792f, 0.792f, 0.792f, 1f);
				_specularIntensity = 1f;
				_specularThreshold = 0.866f;
				_lightColor = new Color(0.972f, 0.972f, 0.972f, 1f);
				_lightIntensity = 0.743f;
				_speed = 0f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.FoggyLake:
				_skySpeed = 0.3f;
				_skyHaze = 40f;
				_skyNoiseStrength = 0.574f;
				_skyAlpha = 0.827f;
				_density = 1f;
				_noiseStrength = 0.03f;
				_noiseScale = 5.77f;
				_skyNoiseScale = 5.77f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 4f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_steppingNear = 14.4f;
				_alpha = 1f;
				_color = new Color(0f, 0.96f, 1f, 1f);
				_skyColor = _color;
				_specularColor = Color.white;
				_lightColor = Color.white;
				_specularIntensity = 0.861f;
				_specularThreshold = 0.907f;
				_lightIntensity = 0.126f;
				_speed = 0f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.LowClouds:
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 0.7f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 4f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 12f;
				_steppingNear = 0f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.15f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.008f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SeaClouds:
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 1.5f;
				_skyNoiseScale = 1.5f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_deepObscurance = 1f;
				_height = 12.4f;
				_heightFallOff = 0.6f;
				_stepping = 6f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.83f, 0.83f, 0.83f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.259f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.008f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.Fog:
				_skySpeed = 0.3f;
				_skyHaze = 144f;
				_skyNoiseStrength = 0.7f;
				_skyAlpha = 0.9f;
				_density = 0.35f;
				_noiseStrength = 0.3f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 20f;
				_distanceFallOff = 0.7f;
				_height = 8f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 0.97f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.05f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.HeavyFog:
				_skySpeed = 0.05f;
				_skyHaze = 500f;
				_skyNoiseStrength = 0.826f;
				_skyAlpha = 1f;
				_density = 0.35f;
				_noiseStrength = 0.1f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 20f;
				_distanceFallOff = 0.8f;
				_deepObscurance = 1f;
				_height = 18f;
				_heightFallOff = 0.6f;
				_stepping = 6f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.91f, 0.91f, 0.91f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.015f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SandStorm1:
				_skySpeed = 0.35f;
				_skyHaze = 388f;
				_skyNoiseStrength = 0.847f;
				_skyAlpha = 1f;
				_density = 0.487f;
				_noiseStrength = 0.758f;
				_noiseScale = 1.71f;
				_skyNoiseScale = 1.71f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 16f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.505f, 0.505f, 0.505f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.3f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.Smoke:
				_skySpeed = 0.109f;
				_skyHaze = 10f;
				_skyNoiseStrength = 0.119f;
				_skyAlpha = 1f;
				_density = 1f;
				_noiseStrength = 0.767f;
				_noiseScale = 1.6f;
				_skyNoiseScale = 1.6f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 8f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 12f;
				_steppingNear = 25f;
				_alpha = 1f;
				_color = new Color(0.125f, 0.125f, 0.125f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 1f, 1f);
				_specularIntensity = 0.575f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 1f;
				_speed = 0.075f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_baselineHeight += 8f;
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.ToxicSwamp:
				_skySpeed = 0.062f;
				_skyHaze = 22f;
				_skyNoiseStrength = 0.694f;
				_skyAlpha = 1f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 2.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 20f;
				_steppingNear = 50f;
				_alpha = 0.95f;
				_color = new Color(0.0238f, 0.175f, 0.109f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.593f, 0.625f, 0.207f, 1f);
				_specularIntensity = 0.735f;
				_specularThreshold = 0.6f;
				_lightColor = new Color(0.73f, 0.746f, 0.511f, 1f);
				_lightIntensity = 0.492f;
				_speed = 0.0003f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SandStorm2:
				_skySpeed = 0f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.729f;
				_skyAlpha = 0.55f;
				_density = 0.545f;
				_noiseStrength = 1f;
				_noiseScale = 3f;
				_skyNoiseScale = 3f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 12f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 5f;
				_steppingNear = 19.6f;
				_alpha = 0.96f;
				_color = new Color(0.609f, 0.609f, 0.609f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.589f, 0.621f, 0.207f, 1f);
				_specularIntensity = 0.505f;
				_specularThreshold = 0.6f;
				_lightColor = new Color(0.726f, 0.742f, 0.507f, 1f);
				_lightIntensity = 0.581f;
				_speed = 0.168f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.WorldEdge:
			{
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 3f;
				_skyNoiseScale = 3f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 20f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.259f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.03f;
				_downsampling = 2;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				Terrain activeTerrain = GetActiveTerrain();
				if (activeTerrain != null)
				{
					_fogVoidPosition = activeTerrain.transform.position + activeTerrain.terrainData.size * 0.5f;
					_fogVoidRadius = activeTerrain.terrainData.size.x * 0.45f;
					_fogVoidHeight = activeTerrain.terrainData.size.y;
					_fogVoidDepth = activeTerrain.terrainData.size.z * 0.45f;
					_fogVoidFallOff = 6f;
					_fogAreaRadius = 0f;
					_character = null;
					_fogAreaCenter = null;
					float x = activeTerrain.terrainData.size.x;
					if (mainCamera.farClipPlane < x)
					{
						mainCamera.farClipPlane = x;
					}
					if (_maxFogLength < x * 0.6f)
					{
						_maxFogLength = x * 0.6f;
					}
				}
				CopyTransitionValues();
				break;
			}
			}
			currentFogAlpha = _alpha;
			currentFogColor = _color;
			currentFogSpecularColor = _specularColor;
			currentLightColor = _lightColor;
			currentSkyHazeAlpha = _skyAlpha;
			UpdateSun();
			FogOfWarUpdateTexture();
			UpdateMaterialProperties(forceNow: true);
			UpdateRenderComponents();
			UpdateTextureAlpha();
			UpdateTexture();
			if (_sunShadows)
			{
				needUpdateDepthSunTexture = true;
			}
			else
			{
				DestroySunShadowsDependencies();
			}
			if (!UnityEngine.Application.isPlaying)
			{
				UpdateWindSpeedQuick();
			}
			TrackPointLights();
			lastTimeSortInstances = 0f;
		}

		public void CheckWaterLevel(bool baseZero)
		{
			if (mainCamera == null)
			{
				return;
			}
			if (_baselineHeight > mainCamera.transform.position.y || baseZero)
			{
				_baselineHeight = 0f;
			}
			GameObject gameObject = GameObject.Find("Water");
			if (gameObject == null)
			{
				GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null && array[i].layer == 4)
					{
						gameObject = array[i];
						break;
					}
				}
			}
			if (gameObject != null)
			{
				_renderBeforeTransparent = false;
				if (_baselineHeight < gameObject.transform.position.y)
				{
					_baselineHeight = gameObject.transform.position.y;
				}
			}
			UpdateMaterialHeights(mainCamera);
		}

		public static Terrain GetActiveTerrain()
		{
			Terrain activeTerrain = Terrain.activeTerrain;
			if (activeTerrain != null && activeTerrain.isActiveAndEnabled)
			{
				return activeTerrain;
			}
			for (int i = 0; i < Terrain.activeTerrains.Length; i++)
			{
				activeTerrain = Terrain.activeTerrains[i];
				if (activeTerrain != null && activeTerrain.isActiveAndEnabled)
				{
					return activeTerrain;
				}
			}
			return null;
		}

		private void UpdateMaterialFogColor()
		{
			Color value = currentFogColor;
			value.r *= 2f * temporaryProperties.color.r;
			value.g *= 2f * temporaryProperties.color.g;
			value.b *= 2f * temporaryProperties.color.b;
			value.a = 1f - _heightFallOff;
			fogMat.SetColor("_Color", value);
		}

		private void UpdateMaterialHeights(Camera mainCamera)
		{
			currentFogAltitude = _baselineHeight;
			Vector3 vector = _fogAreaPosition;
			if (_fogAreaRadius > 0f)
			{
				currentFogAltitude += _fogAreaPosition.y;
				if (_useXYPlane)
				{
					vector.z = 0f;
				}
				else
				{
					vector.y = 0f;
				}
			}
			if (_baselineRelativeToCamera && !_useXYPlane)
			{
				oldBaselineRelativeCameraY += (mainCamera.transform.position.y - oldBaselineRelativeCameraY) * Mathf.Clamp01(1.001f - _baselineRelativeToCameraDelay);
				currentFogAltitude += oldBaselineRelativeCameraY - 1f;
			}
			float w = 0.01f / _noiseScale;
			fogMat.SetVector("_FogData", new Vector4(currentFogAltitude, _height, 1f / (_density * temporaryProperties.density), w));
			fogMat.SetFloat("_FogSkyHaze", _skyHaze + currentFogAltitude);
			Vector3 vector2 = _fogVoidPosition - currentFogAltitude * Vector3.up;
			fogMat.SetVector("_FogVoidPosition", vector2);
			fogMat.SetVector("_FogAreaPosition", vector);
		}

		public void UpdateMaterialProperties(bool forceNow = false)
		{
			if (forceNow || !UnityEngine.Application.isPlaying)
			{
				UpdateMaterialPropertiesNow();
			}
			else
			{
				shouldUpdateMaterialProperties = true;
			}
		}

		public void UpdateMaterialPropertiesNow()
		{
			UpdateMaterialPropertiesNow(mainCamera);
		}

		private void UpdateMaterialPropertiesNow(Camera mainCamera)
		{
			if (fogMat == null || fogRenderer == null)
			{
				return;
			}
			shouldUpdateMaterialProperties = false;
			UpdateSkyColor(_skyAlpha);
			fogMat.SetFloat("_DeepObscurance", _deepObscurance);
			Vector4 value = new Vector4(1f / (_stepping + 1f), 1f / (1f + _steppingNear), _edgeThreshold, _dithering ? (_ditherStrength * 0.01f) : 0f);
			fogMat.SetFloat("_Jitter", _jitterStrength);
			if (!_edgeImprove)
			{
				value.z = 0f;
			}
			fogMat.SetVector("_FogStepping", value);
			fogMat.SetFloat("_FogAlpha", currentFogAlpha);
			UpdateMaterialHeights(mainCamera);
			float num = 0.01f / _noiseScale;
			if (_maxFogLength < 0f)
			{
				_maxFogLength = 0f;
			}
			float w = _maxFogLength - _maxFogLength * _maxFogLengthFallOff + 1f;
			fogMat.SetVector("_FogDistance", new Vector4(num * num * _distance * _distance, _distanceFallOff * _distanceFallOff + 0.1f, _maxFogLength, w));
			UpdateMaterialFogColor();
			if (shaderKeywords == null)
			{
				shaderKeywords = new List<string>();
			}
			else
			{
				shaderKeywords.Clear();
			}
			if (_distance > 0f)
			{
				shaderKeywords.Add("FOG_DISTANCE_ON");
			}
			if (_fogVoidRadius > 0f && _fogVoidFallOff > 0f)
			{
				Vector4 value2 = new Vector4(1f / (1f + _fogVoidRadius), 1f / (1f + _fogVoidHeight), 1f / (1f + _fogVoidDepth), _fogVoidFallOff);
				if (_fogVoidTopology == FOG_VOID_TOPOLOGY.Box)
				{
					shaderKeywords.Add("FOG_VOID_BOX");
				}
				else
				{
					shaderKeywords.Add("FOG_VOID_SPHERE");
				}
				fogMat.SetVector("_FogVoidData", value2);
			}
			if (_fogAreaRadius > 0f && _fogAreaFallOff > 0f)
			{
				Vector4 value3 = new Vector4(1f / (0.0001f + _fogAreaRadius), 1f / (0.0001f + _fogAreaHeight), 1f / (0.0001f + _fogAreaDepth), _fogAreaFallOff);
				if (_fogAreaTopology == FOG_AREA_TOPOLOGY.Box)
				{
					shaderKeywords.Add("FOG_AREA_BOX");
				}
				else
				{
					shaderKeywords.Add("FOG_AREA_SPHERE");
					value3.y = _fogAreaRadius * _fogAreaRadius;
					value3.x /= num;
					value3.z /= num;
				}
				fogMat.SetVector("_FogAreaData", value3);
			}
			if (_skyHaze < 0f)
			{
				_skyHaze = 0f;
			}
			if (_skyHaze > 0f && _skyAlpha > 0f && !_useXYPlane && hasCamera)
			{
				shaderKeywords.Add("FOG_HAZE_ON");
			}
			if (_fogOfWarEnabled)
			{
				shaderKeywords.Add("FOG_OF_WAR_ON");
				fogMat.SetTexture("_FogOfWar", fogOfWarTexture);
				fogMat.SetVector("_FogOfWarCenter", _fogOfWarCenter);
				fogMat.SetVector("_FogOfWarSize", _fogOfWarSize);
				Vector3 vector = _fogOfWarCenter - 0.5f * _fogOfWarSize;
				if (_useXYPlane)
				{
					fogMat.SetVector("_FogOfWarCenterAdjusted", new Vector3(vector.x / _fogOfWarSize.x, vector.y / (_fogOfWarSize.y + 0.0001f), 1f));
				}
				else
				{
					fogMat.SetVector("_FogOfWarCenterAdjusted", new Vector3(vector.x / _fogOfWarSize.x, 1f, vector.z / (_fogOfWarSize.z + 0.0001f)));
				}
			}
			CheckPointLightData();
			bool flag = false;
			for (int i = 0; i < pointLightParams.Length; i++)
			{
				if (pointLightParams[i].light != null || pointLightParams[i].range * pointLightParams[i].intensity > 0f)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				fogMat.SetFloat("_PointLightInsideAtten", _pointLightInsideAtten);
				shaderKeywords.Add("FOG_POINT_LIGHTS");
			}
			sunShadowsActive = false;
			if ((bool)fogRenderer.sun)
			{
				UpdateScatteringData(mainCamera);
				if (_lightScatteringEnabled && _lightScatteringExposure > 0f)
				{
					shaderKeywords.Add("FOG_SCATTERING_ON");
				}
				if (_sunShadows)
				{
					sunShadowsActive = true;
					shaderKeywords.Add("FOG_SUN_SHADOWS_ON");
					UpdateSunShadowsData();
				}
			}
			if (_fogBlur)
			{
				shaderKeywords.Add("FOG_BLUR_ON");
				fogMat.SetFloat("_FogBlurDepth", _fogBlurDepth);
			}
			if (_useXYPlane)
			{
				shaderKeywords.Add("FOG_USE_XY_PLANE");
			}
			if (fogRenderer.computeDepth)
			{
				shaderKeywords.Add("FOG_COMPUTE_DEPTH");
			}
			fogMat.shaderKeywords = shaderKeywords.ToArray();
			if (_computeDepth && _computeDepthScope == COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects)
			{
				Shader.SetGlobalFloat("_VFM_CutOff", _transparencyCutOff);
			}
		}

		public void NotifyChangesToFogInstances()
		{
			if (!hasCamera)
			{
				return;
			}
			int num = ((fogInstances != null) ? fogInstances.Count : 0);
			for (int i = 0; i < num; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				if (volumetricFog != null && volumetricFog != this)
				{
					volumetricFog.UpdateMaterialProperties();
				}
			}
		}

		private void UpdateSunShadowsData()
		{
			if (!(_sun == null) && _sunShadows && !(fogMat == null))
			{
				float num = _sunShadowsStrength * Mathf.Clamp01((0f - _sun.transform.forward.y) * 10f);
				if (num < 0f)
				{
					num = 0f;
				}
				if (num > 0f && !fogMat.IsKeywordEnabled("FOG_SUN_SHADOWS_ON"))
				{
					fogMat.EnableKeyword("FOG_SUN_SHADOWS_ON");
				}
				else if (num <= 0f && fogMat.IsKeywordEnabled("FOG_SUN_SHADOWS_ON"))
				{
					fogMat.DisableKeyword("FOG_SUN_SHADOWS_ON");
				}
				if (_hasCamera)
				{
					Shader.SetGlobalVector("_VolumetricFogSunShadowsData", new Vector4(num, _sunShadowsJitterStrength, _sunShadowsCancellation, 0f));
				}
			}
		}

		private void UpdateWindSpeedQuick()
		{
			if (!(fogMat == null) && (!UnityEngine.Application.isPlaying || lastFrameAppliedWind != Time.frameCount))
			{
				lastFrameAppliedWind = Time.frameCount;
				windSpeedAcum += deltaTime * _windDirection * _speed;
				fogMat.SetVector("_FogWindDir", new Vector3(windSpeedAcum.x % (float)noiseTextureSize, 0f, windSpeedAcum.z % (float)noiseTextureSize));
				skyHazeSpeedAcum += deltaTime * _skySpeed / 20f;
				fogMat.SetVector("_FogSkyData", new Vector4(_skyHaze, _skyNoiseStrength / (0.0001f + _density * temporaryProperties.density), skyHazeSpeedAcum, _skyDepth));
			}
		}

		private void UpdateScatteringData(Camera mainCamera)
		{
			Vector3 position = mainCamera.transform.position + _lightDirection * 1000f;
			Vector3 vector = mainCamera.WorldToViewportPoint(position, (!XRSettings.enabled) ? Camera.MonoOrStereoscopicEye.Mono : Camera.MonoOrStereoscopicEye.Left);
			if (vector.z < 0f)
			{
				Vector2 vector2 = new Vector2(vector.x, vector.y);
				float num = Mathf.Clamp01(1f - _lightDirection.y);
				if (vector2 != oldSunPos)
				{
					oldSunPos = vector2;
					sunFade = Mathf.SmoothStep(1f, 0f, (vector2 - Vector2.one * 0.5f).magnitude * 0.5f) * num;
				}
				fogMat.SetVector("_SunPosition", vector2);
				if (XRSettings.enabled)
				{
					Vector3 vector3 = mainCamera.WorldToViewportPoint(position, Camera.MonoOrStereoscopicEye.Right);
					fogMat.SetVector("_SunPositionRightEye", vector3);
				}
				if (_lightScatteringEnabled && !fogMat.IsKeywordEnabled("FOG_SCATTERING_ON"))
				{
					fogMat.EnableKeyword("FOG_SCATTERING_ON");
				}
				float num2 = _lightScatteringExposure * sunFade;
				fogMat.SetVector("_FogScatteringData", new Vector4(_lightScatteringSpread / (float)_lightScatteringSamples, (num2 > 0f) ? _lightScatteringSamples : 0, num2, _lightScatteringWeight / (float)_lightScatteringSamples));
				fogMat.SetVector("_FogScatteringData2", new Vector4(_lightScatteringIllumination, _lightScatteringDecay, _lightScatteringJittering, _lightScatteringEnabled ? (1.2f * _lightScatteringDiffusion * num * sunLightIntensity) : 0f));
				fogMat.SetVector("_SunDir", -_lightDirection);
				fogMat.SetColor("_SunColor", _lightColor);
			}
			else if (fogMat.IsKeywordEnabled("FOG_SCATTERING_ON"))
			{
				fogMat.DisableKeyword("FOG_SCATTERING_ON");
			}
		}

		private void UpdateSun()
		{
			if (fogRenderer != null && fogRenderer.sun != null)
			{
				sunLight = fogRenderer.sun.GetComponent<Light>();
			}
			else
			{
				sunLight = null;
			}
		}

		private void UpdateSkyColor(float alpha)
		{
			if (!(fogMat == null))
			{
				Color value = skyHazeLightColor;
				value.a = alpha;
				fogMat.SetColor("_FogSkyColor", value);
				fogMat.SetFloat("_FogSkyNoiseScale", 0.01f / _skyNoiseScale);
			}
		}

		private void UpdateTextureAlpha()
		{
			if (adjustedColors == null)
			{
				return;
			}
			float num = Mathf.Clamp(_noiseStrength, 0f, 0.95f);
			for (int i = 0; i < adjustedColors.Length; i++)
			{
				float num2 = 1f - (_noiseSparse + noiseColors[i].b) * num;
				num2 *= _density * temporaryProperties.density * _noiseFinalMultiplier;
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				else if (num2 > 1f)
				{
					num2 = 1f;
				}
				adjustedColors[i].a = num2;
			}
			hasChangeAdjustedColorsAlpha = true;
		}

		private void UpdateTexture()
		{
			if (!(fogMat == null))
			{
				float num = _lightIntensity + sunLightIntensity;
				if (!_useXYPlane)
				{
					num *= Mathf.Clamp01(1f - _lightDirection.y * 2f);
				}
				switch (_lightingModel)
				{
				default:
				{
					lastRenderSettingsAmbientLight = RenderSettings.ambientLight;
					lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
					Color a = lastRenderSettingsAmbientLight * lastRenderSettingsAmbientIntensity;
					updatingTextureLightColor = Color.Lerp(a, currentLightColor * num, num);
					skyHazeLightColor = Color.Lerp(a, _skyColor * num, num);
					break;
				}
				case LIGHTING_MODEL.Natural:
					lastRenderSettingsAmbientLight = RenderSettings.ambientLight;
					lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
					updatingTextureLightColor = Color.Lerp(lastRenderSettingsAmbientLight, currentLightColor * num + lastRenderSettingsAmbientLight, _lightIntensity);
					skyHazeLightColor = Color.Lerp(lastRenderSettingsAmbientLight, _skyColor * num + lastRenderSettingsAmbientLight, _lightIntensity);
					break;
				case LIGHTING_MODEL.SingleLight:
					lastRenderSettingsAmbientLight = Color.black;
					lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
					updatingTextureLightColor = Color.Lerp(lastRenderSettingsAmbientLight, currentLightColor * num, _lightIntensity);
					skyHazeLightColor = Color.Lerp(lastRenderSettingsAmbientLight, _skyColor * num, _lightIntensity);
					break;
				}
				if (UnityEngine.Application.isPlaying)
				{
					updatingTextureSlice = 0;
				}
				else
				{
					updatingTextureSlice = -1;
				}
				UpdateTextureColors(adjustedColors, hasChangeAdjustedColorsAlpha);
				needUpdateTexture = false;
				UpdateSkyColor(_skyAlpha);
			}
		}

		private void UpdateTextureColors(Color[] colors, bool forceUpdateEntireTexture)
		{
			float num = 1.0001f - _specularThreshold;
			int width = adjustedTexture.width;
			Vector3 vector = new Vector3(0f - _lightDirection.x, 0f, 0f - _lightDirection.z).normalized * 0.3f;
			vector.y = ((_lightDirection.y > 0f) ? Mathf.Clamp01(1f - _lightDirection.y) : (1f - Mathf.Clamp01(0f - _lightDirection.y)));
			int num2 = (int)((float)(Mathf.FloorToInt(vector.z * (float)width) * width) + vector.x * (float)width) + colors.Length;
			float num3 = vector.y / num;
			Color obj = currentFogSpecularColor * (1f + _specularIntensity) * _specularIntensity;
			bool flag = false;
			if (updatingTextureSlice >= 1 || forceUpdateEntireTexture)
			{
				flag = true;
			}
			float num4 = updatingTextureLightColor.r * 0.5f;
			float num5 = updatingTextureLightColor.g * 0.5f;
			float num6 = updatingTextureLightColor.b * 0.5f;
			float num7 = obj.r * 0.5f;
			float num8 = obj.g * 0.5f;
			float num9 = obj.b * 0.5f;
			int num10 = colors.Length;
			int num11 = 0;
			int num12 = num10;
			if (updatingTextureSlice >= 0)
			{
				if (updatingTextureSlice > _updateTextureSpread)
				{
					updatingTextureSlice = -1;
					needUpdateTexture = true;
					return;
				}
				num11 = num10 * updatingTextureSlice / _updateTextureSpread;
				num12 = num10 * (updatingTextureSlice + 1) / _updateTextureSpread;
			}
			int num13 = 0;
			for (int i = num11; i < num12; i++)
			{
				int num14 = (i + num2) % num10;
				float num15 = (colors[i].a - colors[num14].a) * num3;
				if (num15 < 0f)
				{
					num15 = 0f;
				}
				else if (num15 > 1f)
				{
					num15 = 1f;
				}
				float num16 = num4 + num7 * num15;
				float num17 = num5 + num8 * num15;
				float num18 = num6 + num9 * num15;
				if (!flag)
				{
					if (num13++ < 100)
					{
						if (num16 != colors[i].r || num17 != colors[i].g || num18 != colors[i].b)
						{
							flag = true;
						}
					}
					else if (!flag)
					{
						break;
					}
				}
				colors[i].r = num16;
				colors[i].g = num17;
				colors[i].b = num18;
			}
			bool flag2 = forceUpdateEntireTexture;
			if (flag)
			{
				if (updatingTextureSlice >= 0)
				{
					updatingTextureSlice++;
					if (updatingTextureSlice >= _updateTextureSpread)
					{
						updatingTextureSlice = -1;
						flag2 = true;
					}
				}
				else
				{
					flag2 = true;
				}
			}
			else
			{
				updatingTextureSlice = -1;
			}
			if (flag2)
			{
				if (UnityEngine.Application.isPlaying && _turbulenceStrength > 0f && (bool)adjustedChaosTexture)
				{
					adjustedChaosTexture.SetPixels(adjustedColors);
					adjustedChaosTexture.Apply();
				}
				else
				{
					adjustedTexture.SetPixels(adjustedColors);
					adjustedTexture.Apply();
					fogMat.SetTexture("_NoiseTex", adjustedTexture);
				}
				lastTextureUpdate = Time.time;
			}
		}

		internal void ApplyChaos()
		{
			if ((bool)adjustedTexture && (!UnityEngine.Application.isPlaying || lastFrameAppliedChaos != Time.frameCount))
			{
				lastFrameAppliedChaos = Time.frameCount;
				if (chaosLerpMat == null)
				{
					Shader shader = Shader.Find("VolumetricFogAndMist/Chaos Lerp");
					chaosLerpMat = new Material(shader);
					chaosLerpMat.hideFlags = HideFlags.DontSave;
				}
				turbAcum += deltaTime * _turbulenceStrength;
				chaosLerpMat.SetFloat("_Amount", turbAcum);
				if (!adjustedChaosTexture)
				{
					adjustedChaosTexture = UnityEngine.Object.Instantiate(adjustedTexture);
					adjustedChaosTexture.hideFlags = HideFlags.DontSave;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(adjustedTexture.width, adjustedTexture.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				temporary.wrapMode = TextureWrapMode.Repeat;
				Graphics.Blit(adjustedChaosTexture, temporary, chaosLerpMat);
				fogMat.SetTexture("_NoiseTex", temporary);
				RenderTexture.ReleaseTemporary(temporary);
			}
		}

		private void CopyTransitionValues()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			currentFogColor = _color;
			currentFogSpecularColor = _specularColor;
			currentLightColor = _lightColor;
		}

		public void SetTargetProfile(VolumetricFogProfile targetProfile, float duration)
		{
			if (_useFogVolumes)
			{
				initialProfile = ScriptableObject.CreateInstance<VolumetricFogProfile>();
				initialProfile.Save(this);
				this.targetProfile = targetProfile;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionProfile = true;
			}
		}

		public void ClearTargetProfile(float duration)
		{
			SetTargetProfile(initialProfile, duration);
		}

		public void SetTargetAlpha(float newFogAlpha, float newSkyHazeAlpha, float duration)
		{
			if (_useFogVolumes)
			{
				initialFogAlpha = currentFogAlpha;
				initialSkyHazeAlpha = currentSkyHazeAlpha;
				targetFogAlpha = newFogAlpha;
				targetSkyHazeAlpha = newSkyHazeAlpha;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionAlpha = true;
			}
		}

		public void ClearTargetAlpha(float duration)
		{
			SetTargetAlpha(-1f, -1f, duration);
		}

		public void SetTargetColor(Color newColor, float duration)
		{
			if (useFogVolumes)
			{
				initialFogColor = currentFogColor;
				targetFogColor = newColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionColor = true;
				targetColorActive = true;
			}
		}

		public void ClearTargetColor(float duration)
		{
			SetTargetColor(_color, duration);
			targetColorActive = false;
		}

		public void SetTargetSpecularColor(Color newSpecularColor, float duration)
		{
			if (useFogVolumes)
			{
				initialFogSpecularColor = currentFogSpecularColor;
				targetFogSpecularColor = newSpecularColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionSpecularColor = true;
				targetSpecularColorActive = true;
			}
		}

		public void ClearTargetSpecularColor(float duration)
		{
			SetTargetSpecularColor(_specularColor, duration);
			targetSpecularColorActive = false;
		}

		public void SetTargetLightColor(Color newLightColor, float duration)
		{
			if (useFogVolumes)
			{
				_sunCopyColor = false;
				initialLightColor = currentLightColor;
				targetLightColor = newLightColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionLightColor = true;
				targetLightColorActive = true;
			}
		}

		public void ClearTargetLightColor(float duration)
		{
			SetTargetLightColor(_lightColor, duration);
			targetLightColorActive = false;
		}

		public void CheckPointLightData()
		{
			if (_pointLightTrackingPivot == null)
			{
				_pointLightTrackingPivot = base.transform;
			}
			if (!pointLightDataMigrated)
			{
				pointLightParams = new PointLightParams[6];
				for (int i = 0; i < _pointLightColors.Length; i++)
				{
					pointLightParams[i].color = _pointLightColors[i];
					Light light = null;
					if (_pointLights[i] != null)
					{
						light = _pointLights[i].GetComponent<Light>();
					}
					pointLightParams[i].light = light;
					pointLightParams[i].intensity = _pointLightIntensities[i];
					pointLightParams[i].intensityMultiplier = _pointLightIntensitiesMultiplier[i];
					pointLightParams[i].position = _pointLightPositions[i];
					pointLightParams[i].range = _pointLightRanges[i];
					pointLightParams[i].rangeMultiplier = 1f;
				}
				for (int j = _pointLightColors.Length; j < 6; j++)
				{
					PointLightDataSetDefaults(j);
				}
				pointLightDataMigrated = true;
				isDirty = true;
			}
			if (_pointLightTrackingCount > 6)
			{
				_pointLightTrackingCount = 6;
				isDirty = true;
			}
			if (pointLightParams != null)
			{
				if (pointLightParams.Length != 6)
				{
					PointLightParams[] array = new PointLightParams[6];
					int num = Mathf.Min(array.Length, pointLightParams.Length);
					Array.Copy(pointLightParams, array, num);
					pointLightParams = array;
					for (int k = num; k < array.Length; k++)
					{
						PointLightDataSetDefaults(k);
					}
					isDirty = true;
				}
				for (int l = 0; l < pointLightParams.Length; l++)
				{
					if (pointLightParams[l].rangeMultiplier <= 0f)
					{
						pointLightParams[l].rangeMultiplier = 1f;
					}
				}
			}
			else
			{
				pointLightParams = new PointLightParams[6];
				for (int m = 0; m < pointLightParams.Length; m++)
				{
					PointLightDataSetDefaults(m);
				}
				isDirty = true;
			}
			if (currentLights == null || currentLights.Length != 6)
			{
				currentLights = new Light[6];
			}
		}

		private void PointLightDataSetDefaults(int k)
		{
			if (k < pointLightParams.Length)
			{
				pointLightParams[k].color = new Color(1f, 1f, 0f, 1f);
				pointLightParams[k].intensity = 1f;
				pointLightParams[k].intensityMultiplier = 1f;
				pointLightParams[k].range = 0f;
				pointLightParams[k].rangeMultiplier = 1f;
			}
		}

		private void SetPointLightMaterialProperties(Camera mainCamera)
		{
			int num = pointLightParams.Length;
			if (pointLightColorBuffer == null || pointLightColorBuffer.Length != num)
			{
				pointLightColorBuffer = new Vector4[num];
			}
			if (pointLightPositionBuffer == null || pointLightPositionBuffer.Length != num)
			{
				pointLightPositionBuffer = new Vector4[num];
			}
			Vector3 vector = ((mainCamera != null) ? mainCamera.transform.position : Vector3.zero);
			for (int i = 0; i < num; i++)
			{
				Vector3 position = pointLightParams[i].position;
				if (!sunShadowsActive)
				{
					position.y -= _baselineHeight;
				}
				float num2 = pointLightParams[i].range * pointLightParams[i].rangeMultiplier * _pointLightInscattering / 25f;
				float num3 = pointLightParams[i].intensity * pointLightParams[i].intensityMultiplier * _pointLightIntensity;
				if (num2 > 0f && num3 > 0f)
				{
					if (_distance > 0f)
					{
						float num4 = 0.01f / _noiseScale;
						float num5 = _distance * num4;
						float num6 = Mathf.Max(num5 * num5 - new Vector2((vector.x - position.x) * num4, (vector.z - position.z) * num4).sqrMagnitude, 0f);
						num6 *= _distanceFallOff * _distanceFallOff + 0.1f;
						num3 = ((num3 > num6) ? (num3 - num6) : 0f);
					}
					pointLightPositionBuffer[i].x = position.x;
					pointLightPositionBuffer[i].y = position.y;
					pointLightPositionBuffer[i].z = position.z;
					pointLightPositionBuffer[i].w = 0f;
					pointLightColorBuffer[i] = new Vector4(pointLightParams[i].color.r * num3, pointLightParams[i].color.g * num3, pointLightParams[i].color.b * num3, num2);
				}
				else
				{
					pointLightColorBuffer[i] = black;
				}
			}
			fogMat.SetVectorArray("_FogPointLightColor", pointLightColorBuffer);
			fogMat.SetVectorArray("_FogPointLightPosition", pointLightPositionBuffer);
		}

		public Light GetPointLight(int index)
		{
			if (index < 0 || index >= pointLightParams.Length)
			{
				return null;
			}
			return pointLightParams[index].light;
		}

		private void TrackNewLights()
		{
			lastFoundLights = UnityEngine.Object.FindObjectsOfType<Light>();
		}

		public void TrackPointLights(bool forceImmediateUpdate = false)
		{
			if (!_pointLightTrackingAuto)
			{
				return;
			}
			if (_pointLightTrackingPivot == null)
			{
				_pointLightTrackingPivot = base.transform;
			}
			if (forceImmediateUpdate || lastFoundLights == null || !UnityEngine.Application.isPlaying || (_pointLightTrackingNewLightsCheckInterval > 0f && Time.time - trackPointCheckNewLightsLastTime > _pointLightTrackingNewLightsCheckInterval))
			{
				trackPointCheckNewLightsLastTime = Time.time;
				TrackNewLights();
			}
			int num = lastFoundLights.Length;
			if (lightBuffer == null || lightBuffer.Length != num)
			{
				lightBuffer = new Light[num];
			}
			for (int i = 0; i < num; i++)
			{
				lightBuffer[i] = lastFoundLights[i];
			}
			bool flag = false;
			for (int j = 0; j < pointLightParams.Length && j < currentLights.Length; j++)
			{
				Light light = null;
				if (j < _pointLightTrackingCount)
				{
					light = GetNearestLight(lightBuffer);
				}
				pointLightParams[j].light = light;
				if (pointLightParams[j].range != 0f && light == null)
				{
					pointLightParams[j].range = 0f;
				}
				if (currentLights[j] != light)
				{
					currentLights[j] = light;
					flag = true;
				}
			}
			if (flag)
			{
				UpdateMaterialProperties();
			}
		}

		private Light GetNearestLight(Light[] lights)
		{
			float num = float.MaxValue;
			Vector3 position = _pointLightTrackingPivot.position;
			Light result = null;
			int num2 = -1;
			for (int i = 0; i < lights.Length; i++)
			{
				Light light = lights[i];
				if (!(light == null) && light.isActiveAndEnabled && light.type == LightType.Point)
				{
					float sqrMagnitude = (light.transform.position - position).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						result = light;
						num = sqrMagnitude;
						num2 = i;
					}
				}
			}
			if (num2 >= 0)
			{
				lights[num2] = null;
			}
			return result;
		}

		public static VolumetricFog CreateFogArea(Vector3 position, float radius, float height = 16f, float fallOff = 1f)
		{
			VolumetricFog volumetricFog = CreateFogAreaPlaceholder(spherical: true, position, radius, height, radius);
			volumetricFog.preset = FOG_PRESET.SeaClouds;
			volumetricFog.transform.position = position;
			volumetricFog.skyHaze = 0f;
			volumetricFog.dithering = true;
			return volumetricFog;
		}

		public static VolumetricFog CreateFogArea(Vector3 position, Vector3 boxSize)
		{
			VolumetricFog volumetricFog = CreateFogAreaPlaceholder(spherical: false, position, boxSize.x * 0.5f, boxSize.y * 0.5f, boxSize.z * 0.5f);
			volumetricFog.preset = FOG_PRESET.SeaClouds;
			volumetricFog.transform.position = position;
			volumetricFog.height = boxSize.y * 0.98f;
			volumetricFog.skyHaze = 0f;
			return volumetricFog;
		}

		private static VolumetricFog CreateFogAreaPlaceholder(bool spherical, Vector3 position, float radius, float height, float depth)
		{
			GameObject obj = UnityEngine.Object.Instantiate(spherical ? Resources.Load<GameObject>("Prefabs/FogSphereArea") : Resources.Load<GameObject>("Prefabs/FogBoxArea"));
			obj.transform.position = position;
			obj.transform.localScale = new Vector3(radius, height, depth);
			return obj.GetComponent<VolumetricFog>();
		}

		public static void RemoveAllFogAreas()
		{
			VolumetricFog[] array = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null && !array[i].hasCamera)
				{
					UnityEngine.Object.DestroyImmediate(array[i].gameObject);
				}
			}
		}

		private void CheckFogAreaDimensions()
		{
			if (!_hasCamera && mr == null)
			{
				mr = GetComponent<MeshRenderer>();
			}
			if (mr == null)
			{
				return;
			}
			Vector3 extents = mr.bounds.extents;
			switch (_fogAreaTopology)
			{
			case FOG_AREA_TOPOLOGY.Box:
				fogAreaRadius = extents.x;
				fogAreaHeight = extents.y;
				fogAreaDepth = extents.z;
				break;
			case FOG_AREA_TOPOLOGY.Sphere:
				fogAreaRadius = extents.x;
				if (base.transform.localScale.z != base.transform.localScale.x)
				{
					base.transform.localScale = new Vector3(base.transform.localScale.x, base.transform.localScale.y, base.transform.localScale.x);
				}
				break;
			}
			if (_fogAreaCenter != null)
			{
				if (_fogAreaFollowMode == FOG_AREA_FOLLOW_MODE.FullXYZ)
				{
					base.transform.position = _fogAreaCenter.transform.position;
				}
				else
				{
					base.transform.position = new Vector3(_fogAreaCenter.transform.position.x, base.transform.position.y, _fogAreaCenter.transform.position.z);
				}
			}
			fogAreaPosition = base.transform.position;
		}

		public void UpdateVolumeMask()
		{
			if (!_hasCamera || mainCamera == null)
			{
				return;
			}
			RemoveMaskCommandBuffer();
			if (!_enableMask)
			{
				return;
			}
			if (maskCommandBuffer != null)
			{
				maskCommandBuffer.Clear();
			}
			else
			{
				maskCommandBuffer = new CommandBuffer();
				maskCommandBuffer.name = "Volumetric Fog Mask Write";
			}
			if (maskMaterial == null)
			{
				maskMaterial = new Material(Shader.Find("VolumetricFogAndMist/MaskWrite"));
			}
			if (XRSettings.enabled)
			{
				rtMaskDesc = XRSettings.eyeTextureDesc;
			}
			else
			{
				rtMaskDesc = new RenderTextureDescriptor(mainCamera.pixelWidth, mainCamera.pixelHeight);
			}
			rtMaskDesc.colorFormat = RenderTextureFormat.Depth;
			rtMaskDesc.depthBufferBits = 24;
			rtMaskDesc.sRGB = false;
			rtMaskDesc.msaaSamples = 1;
			rtMaskDesc.useMipMap = false;
			rtMaskDesc.volumeDepth = 1;
			int num = Mathf.Max(1, _maskDownsampling);
			rtMaskDesc.width /= num;
			rtMaskDesc.height /= num;
			int num2 = Shader.PropertyToID("_VolumetricFogScreenMaskTexture");
			maskCommandBuffer.GetTemporaryRT(num2, rtMaskDesc);
			maskCommandBuffer.SetRenderTarget(num2);
			maskCommandBuffer.ClearRenderTarget(clearDepth: true, clearColor: false, Color.white);
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			for (int i = 0; i < array.Length; i++)
			{
				if (((1 << array[i].gameObject.layer) & _maskLayer.value) != 0 && array[i].gameObject.activeSelf)
				{
					if (array[i].enabled && UnityEngine.Application.isPlaying)
					{
						array[i].enabled = false;
					}
					maskCommandBuffer.DrawRenderer(array[i], maskMaterial);
				}
			}
			maskCommandBuffer.ReleaseTemporaryRT(num2);
			mainCamera.AddCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, maskCommandBuffer);
		}

		public void TogglePreviewMask()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			for (int i = 0; i < array.Length; i++)
			{
				if (((1 << array[i].gameObject.layer) & _maskLayer.value) != 0 && array[i].gameObject.activeSelf)
				{
					array[i].enabled = !array[i].enabled;
				}
			}
		}

		private void RemoveMaskCommandBuffer()
		{
			if (maskCommandBuffer != null && mainCamera != null)
			{
				mainCamera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, maskCommandBuffer);
			}
		}

		private void FogOfWarInit()
		{
			if (fowTransitionList == null || fowTransitionList.Length != 10000)
			{
				fowTransitionList = new FogOfWarTransition[10000];
			}
			if (fowTransitionIndices == null)
			{
				fowTransitionIndices = new Dictionary<int, int>(10000);
			}
			else
			{
				fowTransitionIndices.Clear();
			}
			lastTransitionPos = -1;
			if (_fogOfWarTexture == null)
			{
				FogOfWarUpdateTexture();
			}
			else if (_fogOfWarEnabled && (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0))
			{
				ReloadFogOfWarTexture();
			}
		}

		public void ReloadFogOfWarTexture()
		{
			if (!(_fogOfWarTexture == null))
			{
				_fogOfWarTextureSize = _fogOfWarTexture.width;
				fogOfWarColorBuffer = _fogOfWarTexture.GetPixels32();
				lastTransitionPos = -1;
				fowTransitionIndices.Clear();
				isDirty = true;
				fogOfWarEnabled = true;
			}
		}

		private void FogOfWarUpdateTexture()
		{
			if (_fogOfWarEnabled && UnityEngine.Application.isPlaying)
			{
				int scaledSize = GetScaledSize(_fogOfWarTextureSize, 1f);
				if (_fogOfWarTexture == null || _fogOfWarTexture.width != scaledSize || _fogOfWarTexture.height != scaledSize)
				{
					_fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.Alpha8, mipChain: false);
					_fogOfWarTexture.hideFlags = HideFlags.DontSave;
					_fogOfWarTexture.filterMode = FilterMode.Bilinear;
					_fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
					ResetFogOfWar();
				}
			}
		}

		public void UpdateFogOfWar(bool forceUpload = false)
		{
			if (!_fogOfWarEnabled || _fogOfWarTexture == null)
			{
				return;
			}
			if (forceUpload)
			{
				requiresTextureUpload = true;
			}
			int width = _fogOfWarTexture.width;
			for (int i = 0; i <= lastTransitionPos; i++)
			{
				FogOfWarTransition fogOfWarTransition = fowTransitionList[i];
				if (!fogOfWarTransition.enabled)
				{
					continue;
				}
				float num = Time.time - fogOfWarTransition.startTime - fogOfWarTransition.startDelay;
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = ((fogOfWarTransition.duration <= 0f) ? 1f : (num / fogOfWarTransition.duration));
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				else if (num2 > 1f)
				{
					num2 = 1f;
				}
				byte a = (byte)((float)(int)fogOfWarTransition.initialAlpha + (float)(fogOfWarTransition.targetAlpha - fogOfWarTransition.initialAlpha) * num2);
				int num3 = fogOfWarTransition.y * width + fogOfWarTransition.x;
				fogOfWarColorBuffer[num3].a = a;
				requiresTextureUpload = true;
				if (num2 >= 1f)
				{
					fowTransitionList[i].enabled = false;
					if (fogOfWarTransition.targetAlpha < byte.MaxValue && _fogOfWarRestoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(fogOfWarTransition.x, fogOfWarTransition.y, fogOfWarTransition.targetAlpha, byte.MaxValue, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
					}
				}
			}
			if (requiresTextureUpload)
			{
				requiresTextureUpload = false;
				_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				_fogOfWarTexture.Apply();
			}
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, 1f);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, float duration)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, blendAlpha: true, duration, _fogOfWarSmoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, float duration, float smoothness)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, blendAlpha: true, duration, smoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, bool blendAlpha, float duration, float smoothness, float restoreDelay, float restoreDuration)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = 0.0001f + smoothness;
			int num7 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			float num8 = radius / _fogOfWarSize.z;
			int num9 = (int)((float)num3 * num8);
			int num10 = num9 * num9;
			for (int i = num5 - num9; i <= num5 + num9; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num9; j <= num4 + num9; j++)
				{
					if (j <= 0 || j >= width - 1)
					{
						continue;
					}
					int num11 = (num5 - i) * (num5 - i) + (num4 - j) * (num4 - j);
					if (num11 > num10)
					{
						continue;
					}
					num7 = i * width + j;
					Color32 color = fogOfWarColorBuffer[num7];
					if (!blendAlpha)
					{
						color.a = byte.MaxValue;
					}
					num11 = num10 - num11;
					float num12 = (float)num11 / ((float)num10 * num6);
					num12 = 1f - num12;
					if (num12 < 0f)
					{
						num12 = 0f;
					}
					else if (num12 > 1f)
					{
						num12 = 1f;
					}
					byte b2 = (byte)((float)(int)b + (float)(color.a - b) * num12);
					if (b2 >= byte.MaxValue)
					{
						continue;
					}
					if (duration > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, color.a, b2, 0f, duration);
						continue;
					}
					color.a = b2;
					fogOfWarColorBuffer[num7] = color;
					requiresTextureUpload = true;
					if (restoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, b2, byte.MaxValue, restoreDelay, restoreDuration);
					}
				}
			}
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, float duration)
		{
			SetFogOfWarAlpha(bounds, fogNewAlpha, blendAlpha: true, duration, _fogOfWarSmoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, float duration, float smoothness)
		{
			SetFogOfWarAlpha(bounds, fogNewAlpha, blendAlpha: true, duration, smoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, bool blendAlpha, float duration, float smoothness, float restoreDelay, float restoreDuration)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			Vector3 center = bounds.center;
			float num = (center.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (center.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			float num7 = bounds.extents.z / _fogOfWarSize.z;
			float num8 = bounds.extents.x / _fogOfWarSize.x;
			float num9 = ((num8 > num7) ? 1f : (num7 / num8));
			float num10 = ((num8 > num7) ? (num8 / num7) : 1f);
			int num11 = (int)((float)num3 * num7);
			int num12 = num11 * num11;
			int num13 = (int)((float)width * num8);
			int num14 = num13 * num13;
			float num15 = 0.0001f + smoothness;
			for (int i = num5 - num11; i <= num5 + num11; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				int num16 = (num5 - i) * (num5 - i);
				num16 = num12 - num16;
				float num17 = (float)num16 * num9 / ((float)num12 * num15);
				for (int j = num4 - num13; j <= num4 + num13; j++)
				{
					if (j <= 0 || j >= width - 1)
					{
						continue;
					}
					int num18 = (num4 - j) * (num4 - j);
					num6 = i * width + j;
					Color32 color = fogOfWarColorBuffer[num6];
					if (!blendAlpha)
					{
						color.a = byte.MaxValue;
					}
					num18 = num14 - num18;
					float num19 = (float)num18 * num10 / ((float)num14 * num15);
					float num20 = ((num17 < num19) ? num17 : num19);
					num20 = 1f - num20;
					if (num20 < 0f)
					{
						num20 = 0f;
					}
					else if (num20 > 1f)
					{
						num20 = 1f;
					}
					byte b2 = (byte)((float)(int)b + (float)(color.a - b) * num20);
					if (b2 >= byte.MaxValue)
					{
						continue;
					}
					if (duration > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, color.a, b2, 0f, duration);
						continue;
					}
					color.a = b2;
					fogOfWarColorBuffer[num6] = color;
					requiresTextureUpload = true;
					if (restoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, b2, byte.MaxValue, restoreDelay, restoreDuration);
					}
				}
			}
		}

		public void ResetFogOfWarAlpha(Vector3 worldPosition, float radius)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = radius / _fogOfWarSize.z;
			int num7 = (int)((float)num3 * num6);
			int num8 = num7 * num7;
			for (int i = num5 - num7; i <= num5 + num7; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num7; j <= num4 + num7; j++)
				{
					if (j > 0 && j < width - 1 && (num5 - i) * (num5 - i) + (num4 - j) * (num4 - j) <= num8)
					{
						int num9 = i * width + j;
						Color32 color = fogOfWarColorBuffer[num9];
						color.a = byte.MaxValue;
						fogOfWarColorBuffer[num9] = color;
						requiresTextureUpload = true;
					}
				}
			}
		}

		public void ResetFogOfWarAlpha(Bounds bounds)
		{
			ResetFogOfWarAlpha(bounds.center, bounds.extents.x, bounds.extents.z);
		}

		public void ResetFogOfWarAlpha(Vector3 position, Vector3 size)
		{
			ResetFogOfWarAlpha(position, size.x * 0.5f, size.z * 0.5f);
		}

		public void ResetFogOfWarAlpha(Vector3 position, float extentsX, float extentsZ)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (position.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (position.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = extentsZ / _fogOfWarSize.z;
			float num7 = extentsX / _fogOfWarSize.x;
			int num8 = (int)((float)num3 * num6);
			int num9 = (int)((float)width * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num9; j <= num4 + num9; j++)
				{
					if (j > 0 && j < width - 1)
					{
						int num10 = i * width + j;
						Color32 color = fogOfWarColorBuffer[num10];
						color.a = byte.MaxValue;
						fogOfWarColorBuffer[num10] = color;
						requiresTextureUpload = true;
					}
				}
			}
		}

		public void ResetFogOfWar(byte alpha = byte.MaxValue)
		{
			if (!(_fogOfWarTexture == null) && isPartOfScene)
			{
				int num = _fogOfWarTexture.height;
				int width = _fogOfWarTexture.width;
				int num2 = num * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num2)
				{
					fogOfWarColorBuffer = new Color32[num2];
				}
				Color32 color = new Color32(alpha, alpha, alpha, alpha);
				for (int i = 0; i < num2; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				_fogOfWarTexture.Apply();
				lastTransitionPos = -1;
				fowTransitionIndices.Clear();
				isDirty = true;
			}
		}

		private void AddFogOfWarTransitionSlot(int x, int y, byte initialAlpha, byte targetAlpha, float delay, float duration)
		{
			int key = y * 64000 + x;
			if (!fowTransitionIndices.TryGetValue(key, out var value))
			{
				value = -1;
				for (int i = 0; i <= lastTransitionPos; i++)
				{
					if (!fowTransitionList[i].enabled)
					{
						value = i;
						fowTransitionIndices[key] = value;
						break;
					}
				}
			}
			if (value >= 0 && fowTransitionList[value].enabled && (fowTransitionList[value].x != x || fowTransitionList[value].y != y))
			{
				value = -1;
			}
			if (value < 0)
			{
				if (lastTransitionPos >= 9999)
				{
					return;
				}
				value = ++lastTransitionPos;
				fowTransitionIndices[key] = value;
			}
			fowTransitionList[value].x = x;
			fowTransitionList[value].y = y;
			fowTransitionList[value].duration = duration;
			fowTransitionList[value].startTime = Time.time;
			fowTransitionList[value].startDelay = delay;
			fowTransitionList[value].initialAlpha = initialAlpha;
			fowTransitionList[value].targetAlpha = targetAlpha;
			fowTransitionList[value].enabled = true;
		}

		public float GetFogOfWarAlpha(Vector3 worldPosition)
		{
			if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0 || _fogOfWarTexture == null)
			{
				return 1f;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return 1f;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return 1f;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3) * width + num4;
			if (num5 < 0 || num5 >= fogOfWarColorBuffer.Length)
			{
				return 1f;
			}
			return (float)(int)fogOfWarColorBuffer[num5].a / 255f;
		}

		private void ShowFoWGizmo()
		{
			if (_maskEditorEnabled && _fogOfWarEnabled && !UnityEngine.Application.isPlaying)
			{
				Vector3 center = _fogOfWarCenter;
				center.y = -10f;
				center.y += _baselineHeight + _height * 0.5f;
				Vector3 size = new Vector3(_fogOfWarSize.x, 0.1f, _fogOfWarSize.z);
				for (int i = 0; i < 5; i++)
				{
					Gizmos.color = Color.yellow;
					Gizmos.DrawWireCube(center, size);
					center.y += 0.5f;
					Gizmos.color = Color.white;
					Gizmos.DrawWireCube(center, size);
					center.y += 0.5f;
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class VolumetricFogDayCycleManager : MonoBehaviour
	{
		[Range(0f, 24f)]
		public float currentTime;

		public Gradient colorOverTime;

		public AnimationCurve densityOverTime;

		private int prevTime;

		private VolumetricFog[] fogs;

		private void OnEnable()
		{
			fogs = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			if (colorOverTime == null)
			{
				colorOverTime = new Gradient();
				GradientColorKey[] array = new GradientColorKey[2];
				array[0].color = Color.white;
				array[0].time = 0f;
				array[1].color = Color.white;
				array[1].time = 1f;
				colorOverTime.colorKeys = array;
				GradientAlphaKey[] array2 = new GradientAlphaKey[2];
				array2[0].alpha = 1f;
				array2[0].time = 0f;
				array2[1].alpha = 1f;
				array2[1].time = 1f;
				colorOverTime.alphaKeys = array2;
			}
			if (densityOverTime == null)
			{
				densityOverTime = new AnimationCurve();
				densityOverTime.AddKey(0f, 1f);
				densityOverTime.AddKey(24f, 1f);
			}
		}

		private void Update()
		{
			currentTime = GetCurrentTime();
			int num = (int)(currentTime * 60f);
			if (num == prevTime && UnityEngine.Application.isPlaying)
			{
				return;
			}
			prevTime = num;
			Color color = colorOverTime.Evaluate(currentTime / 24f);
			float num2 = densityOverTime.Evaluate(currentTime);
			for (int i = 0; i < fogs.Length; i++)
			{
				bool flag = false;
				if (!(fogs[i] == null))
				{
					if (fogs[i].temporaryProperties.color != color)
					{
						fogs[i].color = color;
						flag = true;
					}
					if (fogs[i].temporaryProperties.density != num2)
					{
						fogs[i].density = num2;
						flag = true;
					}
					if (flag)
					{
						fogs[i].UpdateMaterialProperties();
					}
				}
			}
		}

		private float GetCurrentTime()
		{
			return currentTime;
		}
	}
	public enum MASK_TEXTURE_BRUSH_MODE
	{
		AddFog,
		RemoveFog
	}
	public class VolumetricFogLightParams : MonoBehaviour
	{
		public float rangeMultiplier = 1f;

		public float intensityMultiplier = 1f;
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(VolumetricFog))]
	public class VolumetricFogMaterialIntegration : MonoBehaviour
	{
		private enum PropertyType
		{
			Float,
			Float3,
			Float4,
			Color,
			Texture2D,
			FloatArray,
			Float4Array,
			ColorArray,
			Matrix4x4
		}

		private struct Properties
		{
			public string name;

			public PropertyType type;
		}

		private static Properties[] props = new Properties[29]
		{
			new Properties
			{
				name = "_NoiseTex",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogAlpha",
				type = PropertyType.Float
			},
			new Properties
			{
				name = "_Color",
				type = PropertyType.Color
			},
			new Properties
			{
				name = "_FogDistance",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogWindDir",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogStepping",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_BlurTex",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogVoidPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogVoidData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogAreaPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogAreaData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogOfWar",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogOfWarCenter",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogOfWarSize",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogOfWarCenterAdjusted",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogPointLightPosition",
				type = PropertyType.Float4Array
			},
			new Properties
			{
				name = "_FogPointLightColor",
				type = PropertyType.ColorArray
			},
			new Properties
			{
				name = "_SunPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_SunDir",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_SunColor",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogScatteringData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogScatteringData2",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunDepthTexture",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_VolumetricFogSunDepthTexture_TexelSize",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunProj",
				type = PropertyType.Matrix4x4
			},
			new Properties
			{
				name = "_VolumetricFogSunWorldPos",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunShadowsData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_Jitter",
				type = PropertyType.Float
			}
		};

		private static string[] keywords = new string[10] { "FOG_DISTANCE_ON", "FOG_AREA_SPHERE", "FOG_AREA_BOX", "FOG_VOID_SPHERE", "FOG_VOID_BOX", "FOG_OF_WAR_ON", "FOG_SCATTERING_ON", "FOG_BLUR_ON", "FOG_POINT_LIGHTS", "FOG_SUN_SHADOWS_ON" };

		public VolumetricFog fog;

		public Renderer[] materials;

		private void OnEnable()
		{
			fog = GetComponent<VolumetricFog>();
		}

		private void OnPreRender()
		{
			if (fog == null)
			{
				return;
			}
			Material fogMat = fog.fogMat;
			if (fogMat == null || materials == null || materials.Length == 0)
			{
				return;
			}
			for (int i = 0; i < props.Length; i++)
			{
				if (!fogMat.HasProperty(props[i].name))
				{
					continue;
				}
				switch (props[i].type)
				{
				case PropertyType.Color:
				{
					Color color = fogMat.GetColor(props[i].name);
					for (int num = 0; num < materials.Length; num++)
					{
						if (materials[num] != null && materials[num].sharedMaterial != null)
						{
							materials[num].sharedMaterial.SetColor(props[i].name, color);
						}
					}
					break;
				}
				case PropertyType.ColorArray:
				{
					Color[] colorArray = fogMat.GetColorArray(props[i].name);
					if (colorArray == null)
					{
						break;
					}
					for (int m = 0; m < materials.Length; m++)
					{
						if (materials[m] != null && materials[m].sharedMaterial != null)
						{
							materials[m].sharedMaterial.SetColorArray(props[i].name, colorArray);
						}
					}
					break;
				}
				case PropertyType.FloatArray:
				{
					float[] floatArray = fogMat.GetFloatArray(props[i].name);
					if (floatArray == null)
					{
						break;
					}
					for (int num3 = 0; num3 < materials.Length; num3++)
					{
						if (materials[num3] != null && materials[num3].sharedMaterial != null)
						{
							materials[num3].sharedMaterial.SetFloatArray(props[i].name, floatArray);
						}
					}
					break;
				}
				case PropertyType.Float4Array:
				{
					Vector4[] vectorArray = fogMat.GetVectorArray(props[i].name);
					if (vectorArray == null)
					{
						break;
					}
					for (int k = 0; k < materials.Length; k++)
					{
						if (materials[k] != null && materials[k].sharedMaterial != null)
						{
							materials[k].sharedMaterial.SetVectorArray(props[i].name, vectorArray);
						}
					}
					break;
				}
				case PropertyType.Float:
				{
					for (int num2 = 0; num2 < materials.Length; num2++)
					{
						if (materials[num2] != null && materials[num2].sharedMaterial != null)
						{
							materials[num2].sharedMaterial.SetFloat(props[i].name, fogMat.GetFloat(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Float3:
				case PropertyType.Float4:
				{
					for (int n = 0; n < materials.Length; n++)
					{
						if (materials[n] != null && materials[n].sharedMaterial != null)
						{
							materials[n].sharedMaterial.SetVector(props[i].name, fogMat.GetVector(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Matrix4x4:
				{
					for (int l = 0; l < materials.Length; l++)
					{
						if (materials[l] != null && materials[l].sharedMaterial != null)
						{
							materials[l].sharedMaterial.SetMatrix(props[i].name, fogMat.GetMatrix(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Texture2D:
				{
					for (int j = 0; j < materials.Length; j++)
					{
						if (materials[j] != null && materials[j].sharedMaterial != null)
						{
							materials[j].sharedMaterial.SetTexture(props[i].name, fogMat.GetTexture(props[i].name));
						}
					}
					break;
				}
				}
			}
			for (int num4 = 0; num4 < keywords.Length; num4++)
			{
				if (fogMat.IsKeywordEnabled(keywords[num4]))
				{
					for (int num5 = 0; num5 < materials.Length; num5++)
					{
						if (materials[num5] != null && materials[num5].sharedMaterial != null)
						{
							materials[num5].sharedMaterial.EnableKeyword(keywords[num4]);
						}
					}
					continue;
				}
				for (int num6 = 0; num6 < materials.Length; num6++)
				{
					if (materials[num6] != null && materials[num6].sharedMaterial != null)
					{
						materials[num6].sharedMaterial.DisableKeyword(keywords[num4]);
					}
				}
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("")]
	[RequireComponent(typeof(Camera))]
	[ImageEffectAllowedInSceneView]
	public class VolumetricFogPosT : MonoBehaviour, IVolumetricFogRenderComponent
	{
		private Material copyOpaqueMat;

		public VolumetricFog fog { get; set; }

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fog == null || !fog.enabled)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (fog.transparencyBlendMode == TRANSPARENT_MODE.None)
			{
				fog.DoOnRenderImage(source, destination);
				return;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(source.descriptor);
			if (copyOpaqueMat == null)
			{
				copyOpaqueMat = new Material(Shader.Find("VolumetricFogAndMist/CopyOpaque"));
			}
			copyOpaqueMat.SetFloat("_BlendPower", fog.transparencyBlendPower);
			Graphics.Blit(source, destination, copyOpaqueMat, (fog.computeDepth && fog.downsampling == 1) ? 1 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}

		public void DestroySelf()
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("")]
	[RequireComponent(typeof(Camera))]
	[ImageEffectAllowedInSceneView]
	public class VolumetricFogPreT : MonoBehaviour, IVolumetricFogRenderComponent
	{
		private RenderTexture opaqueFrame;

		public VolumetricFog fog { get; set; }

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fog == null || !fog.enabled)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (fog.renderBeforeTransparent)
			{
				fog.DoOnRenderImage(source, destination);
				return;
			}
			RenderTextureDescriptor descriptor = source.descriptor;
			opaqueFrame = RenderTexture.GetTemporary(descriptor);
			fog.DoOnRenderImage(source, opaqueFrame);
			Shader.SetGlobalTexture("_VolumetricFog_OpaqueFrame", opaqueFrame);
			Graphics.Blit(opaqueFrame, destination);
		}

		private void OnPostRender()
		{
			if (opaqueFrame != null)
			{
				RenderTexture.ReleaseTemporary(opaqueFrame);
				opaqueFrame = null;
			}
		}

		public void DestroySelf()
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}
	[CreateAssetMenu(fileName = "VolumetricFogProfile", menuName = "Volumetric Fog Profile", order = 100)]
	public class VolumetricFogProfile : ScriptableObject
	{
		public LIGHTING_MODEL lightingModel;

		public bool sunCopyColor = true;

		[Range(0f, 1.25f)]
		public float density = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.8f;

		[Range(0f, 500f)]
		public float height = 4f;

		[Range(0f, 1f)]
		public float heightFallOff = 0.6f;

		public float baselineHeight;

		[Range(0f, 1000f)]
		public float distance;

		[Range(0f, 5f)]
		public float distanceFallOff;

		public float maxFogLength = 1000f;

		[Range(0f, 1f)]
		public float maxFogLengthFallOff;

		public bool baselineRelativeToCamera;

		[Range(0f, 1f)]
		public float baselineRelativeToCameraDelay;

		[Range(0.2f, 10f)]
		public float noiseScale = 1f;

		[Range(-0.3f, 2f)]
		public float noiseSparse;

		[Range(1f, 2f)]
		public float noiseFinalMultiplier = 1f;

		[Range(0f, 1.05f)]
		public float alpha = 1f;

		public Color color = new Color(0.89f, 0.89f, 0.89f, 1f);

		[Range(0f, 1f)]
		public float deepObscurance = 1f;

		public Color specularColor = new Color(1f, 1f, 0.8f, 1f);

		[Range(0f, 1f)]
		public float specularThreshold = 0.6f;

		[Range(0f, 1f)]
		public float specularIntensity = 0.2f;

		public Vector3 lightDirection = new Vector3(1f, 0f, -1f);

		[Range(-1f, 3f)]
		public float lightIntensity = 0.2f;

		public Color lightColor = Color.white;

		[Range(0f, 1f)]
		public float speed = 0.01f;

		public bool useRealTime;

		public Vector3 windDirection = new Vector3(-1f, 0f, 0f);

		[Range(0f, 10f)]
		public float turbulenceStrength;

		public bool useXYPlane;

		public Color skyColor = new Color(0.89f, 0.89f, 0.89f, 1f);

		public float skyHaze = 50f;

		[Range(0f, 1f)]
		public float skySpeed = 0.3f;

		[Range(0f, 1f)]
		public float skyNoiseStrength = 0.1f;

		public float skyNoiseScale = 1.5f;

		[Range(0f, 1f)]
		public float skyAlpha = 1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float skyDepth = 0.999f;

		public float stepping = 12f;

		public float steppingNear = 1f;

		public bool dithering;

		public float ditherStrength = 0.75f;

		public bool downsamplingOverride;

		[Range(1f, 8f)]
		public int downsampling = 1;

		public bool forceComposition;

		public bool edgeImprove;

		[Range(1E-05f, 0.005f)]
		public float edgeThreshold = 0.0005f;

		public bool lightScatteringOverride;

		public bool lightScatteringEnabled;

		[Range(0f, 1f)]
		public float lightScatteringDiffusion = 0.7f;

		[Range(0f, 1f)]
		public float lightScatteringSpread = 0.686f;

		[Range(4f, 64f)]
		public int lightScatteringSamples = 16;

		[Range(0f, 50f)]
		public float lightScatteringWeight = 1.9f;

		[Range(0f, 50f)]
		public float lightScatteringIllumination = 18f;

		[Range(0.9f, 1.1f)]
		public float lightScatteringDecay = 0.986f;

		[Range(0f, 0.2f)]
		public float lightScatteringExposure;

		[Range(0f, 1f)]
		public float lightScatteringJittering = 0.5f;

		[Range(1f, 4f)]
		public int lightScatteringBlurDownscale = 1;

		public bool fogVoidOverride;

		public FOG_VOID_TOPOLOGY fogVoidTopology;

		[SerializeField]
		[Range(0f, 10f)]
		public float fogVoidFallOff = 1f;

		public float fogVoidRadius;

		public Vector3 fogVoidPosition = Vector3.zero;

		public float fogVoidDepth;

		public float fogVoidHeight;

		public void Load(VolumetricFog fog)
		{
			fog.density = density;
			fog.noiseStrength = noiseStrength;
			fog.height = height;
			fog.heightFallOff = heightFallOff;
			fog.baselineHeight = baselineHeight;
			fog.distance = distance;
			fog.distanceFallOff = distanceFallOff;
			fog.maxFogLength = maxFogLength;
			fog.maxFogLengthFallOff = maxFogLengthFallOff;
			fog.baselineRelativeToCamera = baselineRelativeToCamera;
			fog.baselineRelativeToCameraDelay = baselineRelativeToCameraDelay;
			fog.noiseScale = noiseScale;
			fog.noiseSparse = noiseSparse;
			fog.noiseFinalMultiplier = noiseFinalMultiplier;
			fog.useXYPlane = useXYPlane;
			fog.lightingModel = lightingModel;
			fog.sunCopyColor = sunCopyColor;
			fog.alpha = alpha;
			fog.color = color;
			fog.deepObscurance = deepObscurance;
			fog.specularColor = specularColor;
			fog.specularThreshold = specularThreshold;
			fog.specularIntensity = specularIntensity;
			fog.lightDirection = lightDirection;
			fog.lightIntensity = lightIntensity;
			fog.lightColor = lightColor;
			fog.speed = speed;
			fog.windDirection = windDirection;
			fog.turbulenceStrength = turbulenceStrength;
			fog.useRealTime = useRealTime;
			fog.skyColor = skyColor;
			fog.skyHaze = skyHaze;
			fog.skySpeed = skySpeed;
			fog.skyNoiseStrength = skyNoiseStrength;
			fog.skyNoiseScale = skyNoiseScale;
			fog.skyAlpha = skyAlpha;
			fog.skyDepth = skyDepth;
			fog.stepping = stepping;
			fog.steppingNear = steppingNear;
			fog.dithering = dithering;
			fog.ditherStrength = ditherStrength;
			if (downsamplingOverride)
			{
				fog.downsampling = downsampling;
				fog.forceComposition = forceComposition;
				fog.edgeImprove = edgeImprove;
				fog.edgeThreshold = edgeThreshold;
			}
			if (fogVoidOverride)
			{
				fog.fogVoidTopology = fogVoidTopology;
				fog.fogVoidDepth = fogVoidDepth;
				fog.fogVoidFallOff = fogVoidFallOff;
				fog.fogVoidHeight = fogVoidHeight;
				fog.fogVoidPosition = fogVoidPosition;
				fog.fogVoidRadius = fogVoidRadius;
			}
			if (lightScatteringOverride)
			{
				fog.lightScatteringEnabled = lightScatteringEnabled;
				fog.lightScatteringDecay = lightScatteringDecay;
				fog.lightScatteringDiffusion = lightScatteringDiffusion;
				fog.lightScatteringExposure = lightScatteringExposure;
				fog.lightScatteringIllumination = lightScatteringIllumination;
				fog.lightScatteringJittering = lightScatteringJittering;
				fog.lightScatteringBlurDownscale = lightScatteringBlurDownscale;
				fog.lightScatteringSamples = lightScatteringSamples;
				fog.lightScatteringSpread = lightScatteringSpread;
				fog.lightScatteringWeight = lightScatteringWeight;
			}
		}

		public void Save(VolumetricFog fog)
		{
			density = fog.density;
			noiseStrength = fog.noiseStrength;
			height = fog.height;
			heightFallOff = fog.heightFallOff;
			baselineHeight = fog.baselineHeight;
			distance = fog.distance;
			distanceFallOff = fog.distanceFallOff;
			maxFogLength = fog.maxFogLength;
			maxFogLengthFallOff = fog.maxFogLengthFallOff;
			baselineRelativeToCamera = fog.baselineRelativeToCamera;
			baselineRelativeToCameraDelay = fog.baselineRelativeToCameraDelay;
			noiseScale = fog.noiseScale;
			noiseSparse = fog.noiseSparse;
			noiseFinalMultiplier = fog.noiseFinalMultiplier;
			useXYPlane = fog.useXYPlane;
			sunCopyColor = fog.sunCopyColor;
			alpha = fog.alpha;
			color = fog.color;
			deepObscurance = fog.deepObscurance;
			specularColor = fog.specularColor;
			specularThreshold = fog.specularThreshold;
			specularIntensity = fog.specularIntensity;
			lightDirection = fog.lightDirection;
			lightIntensity = fog.lightIntensity;
			lightColor = fog.lightColor;
			lightingModel = fog.lightingModel;
			speed = fog.speed;
			windDirection = fog.windDirection;
			turbulenceStrength = fog.turbulenceStrength;
			useRealTime = fog.useRealTime;
			skyColor = fog.skyColor;
			skyHaze = fog.skyHaze;
			skySpeed = fog.skySpeed;
			skyNoiseStrength = fog.skyNoiseStrength;
			skyNoiseScale = fog.skyNoiseScale;
			skyAlpha = fog.skyAlpha;
			skyDepth = fog.skyDepth;
			stepping = fog.stepping;
			steppingNear = fog.steppingNear;
			dithering = fog.dithering;
			ditherStrength = fog.ditherStrength;
			downsampling = fog.downsampling;
			forceComposition = fog.forceComposition;
			edgeImprove = fog.edgeImprove;
			edgeThreshold = fog.edgeThreshold;
			fogVoidTopology = fog.fogVoidTopology;
			fogVoidDepth = fog.fogVoidDepth;
			fogVoidFallOff = fog.fogVoidFallOff;
			fogVoidHeight = fog.fogVoidHeight;
			fogVoidPosition = fog.fogVoidPosition;
			fogVoidRadius = fog.fogVoidRadius;
			lightScatteringEnabled = fog.lightScatteringEnabled;
			lightScatteringDecay = fog.lightScatteringDecay;
			lightScatteringDiffusion = fog.lightScatteringDiffusion;
			lightScatteringExposure = fog.lightScatteringExposure;
			lightScatteringIllumination = fog.lightScatteringIllumination;
			lightScatteringJittering = fog.lightScatteringJittering;
			lightScatteringSamples = fog.lightScatteringSamples;
			lightScatteringSpread = fog.lightScatteringSamples;
			lightScatteringSpread = fog.lightScatteringSpread;
			lightScatteringWeight = fog.lightScatteringWeight;
			lightScatteringBlurDownscale = fog.lightScatteringBlurDownscale;
		}

		public static void Lerp(VolumetricFogProfile profile1, VolumetricFogProfile profile2, float t, VolumetricFog fog)
		{
			if (t < 0f)
			{
				t = 0f;
			}
			else if (t > 1f)
			{
				t = 1f;
			}
			fog.density = profile1.density * (1f - t) + profile2.density * t;
			fog.noiseStrength = profile1.noiseStrength * (1f - t) + profile2.noiseStrength * t;
			fog.height = profile1.height * (1f - t) + profile2.height * t;
			fog.heightFallOff = profile1.heightFallOff * (1f - t) + profile2.heightFallOff * t;
			fog.baselineHeight = profile1.baselineHeight * (1f - t) + profile2.baselineHeight * t;
			fog.distance = profile1.distance * (1f - t) + profile2.distance * t;
			fog.distanceFallOff = profile1.distanceFallOff * (1f - t) + profile2.distanceFallOff * t;
			fog.maxFogLength = profile1.maxFogLength * (1f - t) + profile2.maxFogLength * t;
			fog.maxFogLengthFallOff = profile1.maxFogLengthFallOff * (1f - t) + profile2.maxFogLengthFallOff * t;
			fog.baselineRelativeToCamera = ((t < 0.5f) ? profile1.baselineRelativeToCamera : profile2.baselineRelativeToCamera);
			fog.baselineRelativeToCameraDelay = profile1.baselineRelativeToCameraDelay * (1f - t) + profile2.baselineRelativeToCameraDelay * t;
			fog.noiseScale = profile1.noiseScale * (1f - t) + profile2.noiseScale * t;
			fog.noiseSparse = profile1.noiseSparse * (1f - t) + profile2.noiseSparse * t;
			fog.noiseFinalMultiplier = profile1.noiseFinalMultiplier * (1f - t) + profile2.noiseFinalMultiplier * t;
			fog.sunCopyColor = ((t < 0.5f) ? profile1.sunCopyColor : profile2.sunCopyColor);
			fog.alpha = profile1.alpha * (1f - t) + profile2.alpha * t;
			fog.color = profile1.color * (1f - t) + profile2.color * t;
			fog.deepObscurance = profile1.deepObscurance * (1f - t) + profile2.deepObscurance * t;
			fog.specularColor = profile1.specularColor * (1f - t) + profile2.specularColor * t;
			fog.specularThreshold = profile1.specularThreshold * (1f - t) + profile2.specularThreshold * t;
			fog.specularIntensity = profile1.specularIntensity * (1f - t) + profile2.specularIntensity * t;
			fog.lightDirection = profile1.lightDirection * (1f - t) + profile2.lightDirection * t;
			fog.lightIntensity = profile1.lightIntensity * (1f - t) + profile2.lightIntensity * t;
			fog.lightColor = profile1.lightColor * (1f - t) + profile2.lightColor * t;
			fog.speed = profile1.speed * (1f - t) + profile2.speed * t;
			fog.windDirection = profile1.windDirection * (1f - t) + profile2.windDirection * t;
			fog.turbulenceStrength = profile1.turbulenceStrength * (1f - t) + profile2.turbulenceStrength * t;
			fog.skyColor = profile1.skyColor * (1f - t) + profile2.skyColor * t;
			fog.skyHaze = profile1.skyHaze * (1f - t) + profile2.skyHaze * t;
			fog.skySpeed = profile1.skySpeed * (1f - t) + profile2.skySpeed * t;
			fog.skyNoiseStrength = profile1.skyNoiseStrength * (1f - t) + profile2.skyNoiseStrength * t;
			fog.skyNoiseScale = profile1.skyNoiseScale * (1f - t) + profile2.skyNoiseScale * t;
			fog.skyAlpha = profile1.skyAlpha * (1f - t) + profile2.skyAlpha * t;
			fog.skyDepth = profile1.skyDepth * (1f - t) + profile2.skyDepth * t;
			fog.stepping = profile1.stepping * (1f - t) + profile2.stepping * t;
			fog.steppingNear = profile1.steppingNear * (1f - t) + profile2.steppingNear * t;
			fog.dithering = ((t < 0.5f) ? profile1.dithering : profile2.dithering);
			fog.ditherStrength = profile1.ditherStrength * (1f - t) + profile2.ditherStrength * t;
			if (profile1.fogVoidOverride && profile2.fogVoidOverride)
			{
				fog.fogVoidDepth = profile1.fogVoidDepth * (1f - t) + profile2.fogVoidDepth * t;
				fog.fogVoidFallOff = profile1.fogVoidFallOff * (1f - t) + profile2.fogVoidFallOff * t;
				fog.fogVoidHeight = profile1.fogVoidHeight * (1f - t) + profile2.fogVoidHeight * t;
				fog.fogVoidPosition = profile1.fogVoidPosition * (1f - t) + profile2.fogVoidPosition * t;
				fog.fogVoidRadius = profile1.fogVoidRadius * (1f - t) + profile2.fogVoidRadius * t;
			}
			if (profile1.lightScatteringOverride && profile2.lightScatteringOverride)
			{
				fog.lightScatteringDecay = profile1.lightScatteringDecay * (1f - t) + profile2.lightScatteringDecay * t;
				fog.lightScatteringDiffusion = profile1.lightScatteringDiffusion * (1f - t) + profile2.lightScatteringDiffusion * t;
				fog.lightScatteringExposure = profile1.lightScatteringExposure * (1f - t) + profile2.lightScatteringExposure * t;
				fog.lightScatteringIllumination = profile1.lightScatteringIllumination * (1f - t) + profile2.lightScatteringIllumination * t;
				fog.lightScatteringJittering = profile1.lightScatteringJittering * (1f - t) + profile2.lightScatteringJittering * t;
				fog.lightScatteringSamples = (int)((float)profile1.lightScatteringSamples * (1f - t) + (float)profile2.lightScatteringSamples * t);
				fog.lightScatteringSpread = profile1.lightScatteringSpread * (1f - t) + profile2.lightScatteringSpread * t;
				fog.lightScatteringWeight = profile1.lightScatteringWeight * (1f - t) + profile2.lightScatteringWeight * t;
			}
		}
	}
}
namespace DynamicFogAndMist
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[HelpURL("http://kronnect.com/taptapgo")]
	[ImageEffectAllowedInSceneView]
	public class DynamicFog : DynamicFogBase
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && XRSettings.enabled)
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			Graphics.Blit(source, destination, fogMat);
		}
	}
	public enum FOG_TYPE
	{
		DesktopFogWithSkyHaze,
		MobileFogWithSkyHaze,
		MobileFogOnlyGround,
		DesktopFogPlusWithSkyHaze,
		MobileFogSimple,
		MobileFogBasic,
		MobileFogOrthogonal,
		DesktopFogPlusOrthogonal
	}
	internal static class FOG_TYPE_Ext
	{
		public static bool isPlus(this FOG_TYPE fogType)
		{
			if (fogType != FOG_TYPE.DesktopFogPlusWithSkyHaze && fogType != FOG_TYPE.MobileFogSimple && fogType != FOG_TYPE.MobileFogBasic && fogType != FOG_TYPE.MobileFogOrthogonal)
			{
				return fogType == FOG_TYPE.DesktopFogPlusOrthogonal;
			}
			return true;
		}
	}
	public enum FOG_PRESET
	{
		Clear,
		Mist,
		WindyMist,
		GroundFog,
		Fog,
		HeavyFog,
		SandStorm,
		Custom
	}
	[AddComponentMenu("")]
	public class DynamicFogBase : MonoBehaviour
	{
		[SerializeField]
		private FOG_TYPE _effectType = FOG_TYPE.DesktopFogPlusWithSkyHaze;

		[SerializeField]
		private FOG_PRESET _preset = FOG_PRESET.Mist;

		[SerializeField]
		private DynamicFogProfile _profile;

		[SerializeField]
		private bool _useFogVolumes;

		[SerializeField]
		private bool _enableDithering;

		[SerializeField]
		[Range(0f, 0.3f)]
		private float _ditherStrength = 0.03f;

		[SerializeField]
		[Range(0f, 1f)]
		protected float _alpha = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _noiseStrength = 0.5f;

		[SerializeField]
		[Range(0.01f, 1f)]
		private float _noiseScale = 0.1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float _distance = 0.1f;

		[SerializeField]
		[Range(0.0001f, 2f)]
		private float _distanceFallOff = 0.01f;

		[SerializeField]
		[Range(0f, 1.2f)]
		private float _maxDistance = 0.999f;

		[SerializeField]
		[Range(0.0001f, 0.5f)]
		private float _maxDistanceFallOff;

		[SerializeField]
		[Range(0f, 500f)]
		private float _height = 1f;

		[SerializeField]
		[Range(0f, 500f)]
		private float _maxHeight = 100f;

		[SerializeField]
		[Range(0.0001f, 1f)]
		private float _heightFallOff = 0.1f;

		[SerializeField]
		private float _baselineHeight;

		[SerializeField]
		private bool _clipUnderBaseline;

		[SerializeField]
		[Range(0f, 15f)]
		private float _turbulence = 0.1f;

		[SerializeField]
		[Range(0f, 5f)]
		private float _speed = 0.1f;

		[SerializeField]
		private Vector3 _windDirection = new Vector3(1f, 0f, 1f);

		[SerializeField]
		private Color _color = Color.white;

		[SerializeField]
		private Color _color2 = Color.gray;

		[SerializeField]
		[Range(0f, 500f)]
		private float _skyHaze = 50f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skySpeed = 0.3f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyNoiseStrength = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyAlpha = 1f;

		[SerializeField]
		private GameObject _sun;

		[SerializeField]
		private bool _fogOfWarEnabled;

		[SerializeField]
		private Vector3 _fogOfWarCenter;

		[SerializeField]
		private Vector3 _fogOfWarSize = new Vector3(1024f, 0f, 1024f);

		[SerializeField]
		private int _fogOfWarTextureSize = 256;

		[SerializeField]
		protected bool _useSinglePassStereoRenderingMatrix;

		[SerializeField]
		private bool _useXZDistance;

		[SerializeField]
		[Range(0f, 1f)]
		private float _scattering = 0.7f;

		[SerializeField]
		private Color _scatteringColor = new Color(1f, 1f, 0.8f);

		private Material fogMatAdv;

		private Material fogMatFogSky;

		private Material fogMatOnlyFog;

		private Material fogMatVol;

		private Material fogMatSimple;

		private Material fogMatBasic;

		private Material fogMatOrthogonal;

		private Material fogMatDesktopPlusOrthogonal;

		[SerializeField]
		protected Material fogMat;

		private float initialFogAlpha;

		private float targetFogAlpha;

		private float initialSkyHazeAlpha;

		private float targetSkyHazeAlpha;

		private bool targetFogColors;

		private Color initialFogColor1;

		private Color targetFogColor1;

		private Color initialFogColor2;

		private Color targetFogColor2;

		private float transitionDuration;

		private float transitionStartTime;

		private float currentFogAlpha;

		private float currentSkyHazeAlpha;

		private bool transitionAlpha;

		private bool transitionColor;

		private bool transitionProfile;

		private DynamicFogProfile initialProfile;

		private DynamicFogProfile targetProfile;

		private Color currentFogColor1;

		private Color currentFogColor2;

		protected Camera currentCamera;

		private Texture2D fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		private Light sunLight;

		private Vector3 sunDirection = Vector3.zero;

		private Color sunColor = Color.white;

		private float sunIntensity = 1f;

		private static DynamicFog _fog;

		private List<string> shaderKeywords;

		protected bool matOrtho;

		protected bool shouldUpdateMaterialProperties;

		public FOG_TYPE effectType
		{
			get
			{
				return _effectType;
			}
			set
			{
				if (value != _effectType)
				{
					_effectType = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public FOG_PRESET preset
		{
			get
			{
				return _preset;
			}
			set
			{
				if (value != _preset)
				{
					_preset = value;
					UpdateMaterialPropertiesNow();
				}
			}
		}

		public DynamicFogProfile profile
		{
			get
			{
				return _profile;
			}
			set
			{
				if (value != _profile)
				{
					_profile = value;
					if (_profile != null)
					{
						_profile.Load(this);
						_preset = FOG_PRESET.Custom;
						UpdateMaterialProperties();
					}
				}
			}
		}

		public bool useFogVolumes
		{
			get
			{
				return _useFogVolumes;
			}
			set
			{
				if (value != _useFogVolumes)
				{
					_useFogVolumes = value;
				}
			}
		}

		public bool enableDithering
		{
			get
			{
				return _enableDithering;
			}
			set
			{
				if (value != _enableDithering)
				{
					_enableDithering = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float ditherStrength
		{
			get
			{
				return _ditherStrength;
			}
			set
			{
				if (value != _ditherStrength)
				{
					_ditherStrength = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float alpha
		{
			get
			{
				return _alpha;
			}
			set
			{
				if (value != _alpha)
				{
					_alpha = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float noiseStrength
		{
			get
			{
				return _noiseStrength;
			}
			set
			{
				if (value != _noiseStrength)
				{
					_noiseStrength = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float noiseScale
		{
			get
			{
				return _noiseScale;
			}
			set
			{
				if (value != _noiseScale)
				{
					_noiseScale = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float distance
		{
			get
			{
				return _distance;
			}
			set
			{
				if (value != _distance)
				{
					_distance = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float distanceFallOff
		{
			get
			{
				return _distanceFallOff;
			}
			set
			{
				if (value != _distanceFallOff)
				{
					_distanceFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxDistance
		{
			get
			{
				return _maxDistance;
			}
			set
			{
				if (value != _maxDistance)
				{
					_maxDistance = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxDistanceFallOff
		{
			get
			{
				return _maxDistanceFallOff;
			}
			set
			{
				if (value != _maxDistanceFallOff)
				{
					_maxDistanceFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float height
		{
			get
			{
				return _height;
			}
			set
			{
				if (value != _height)
				{
					_height = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxHeight
		{
			get
			{
				return _maxHeight;
			}
			set
			{
				if (value != _maxHeight)
				{
					_maxHeight = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float heightFallOff
		{
			get
			{
				return _heightFallOff;
			}
			set
			{
				if (value != _heightFallOff)
				{
					_heightFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float baselineHeight
		{
			get
			{
				return _baselineHeight;
			}
			set
			{
				if (value != _baselineHeight)
				{
					_baselineHeight = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool clipUnderBaseline
		{
			get
			{
				return _clipUnderBaseline;
			}
			set
			{
				if (value != _clipUnderBaseline)
				{
					_clipUnderBaseline = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float turbulence
		{
			get
			{
				return _turbulence;
			}
			set
			{
				if (value != _turbulence)
				{
					_turbulence = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float speed
		{
			get
			{
				return _speed;
			}
			set
			{
				if (value != _speed)
				{
					_speed = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 windDirection
		{
			get
			{
				return _windDirection;
			}
			set
			{
				if (value != _windDirection)
				{
					_windDirection = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color color
		{
			get
			{
				return _color;
			}
			set
			{
				if (value != _color)
				{
					_color = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public Color color2
		{
			get
			{
				return _color2;
			}
			set
			{
				if (value != _color2)
				{
					_color2 = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyHaze
		{
			get
			{
				return _skyHaze;
			}
			set
			{
				if (value != _skyHaze)
				{
					_skyHaze = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skySpeed
		{
			get
			{
				return _skySpeed;
			}
			set
			{
				if (value != _skySpeed)
				{
					_skySpeed = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyNoiseStrength
		{
			get
			{
				return _skyNoiseStrength;
			}
			set
			{
				if (value != _skyNoiseStrength)
				{
					_skyNoiseStrength = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyAlpha
		{
			get
			{
				return _skyAlpha;
			}
			set
			{
				if (value != _skyAlpha)
				{
					_skyAlpha = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public GameObject sun
		{
			get
			{
				return _sun;
			}
			set
			{
				if (value != _sun)
				{
					_sun = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool fogOfWarEnabled
		{
			get
			{
				return _fogOfWarEnabled;
			}
			set
			{
				if (value != _fogOfWarEnabled)
				{
					_fogOfWarEnabled = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 fogOfWarCenter
		{
			get
			{
				return _fogOfWarCenter;
			}
			set
			{
				if (value != _fogOfWarCenter)
				{
					_fogOfWarCenter = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 fogOfWarSize
		{
			get
			{
				return _fogOfWarSize;
			}
			set
			{
				if (value != _fogOfWarSize)
				{
					_fogOfWarSize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int fogOfWarTextureSize
		{
			get
			{
				return _fogOfWarTextureSize;
			}
			set
			{
				if (value != _fogOfWarTextureSize)
				{
					_fogOfWarTextureSize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool useSinglePassStereoRenderingMatrix
		{
			get
			{
				return _useSinglePassStereoRenderingMatrix;
			}
			set
			{
				if (value != _useSinglePassStereoRenderingMatrix)
				{
					_useSinglePassStereoRenderingMatrix = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool useXZDistance
		{
			get
			{
				return _useXZDistance;
			}
			set
			{
				if (value != _useXZDistance)
				{
					_useXZDistance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float scattering
		{
			get
			{
				return _scattering;
			}
			set
			{
				if (value != _scattering)
				{
					_scattering = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color scatteringColor
		{
			get
			{
				return _scatteringColor;
			}
			set
			{
				if (value != _scatteringColor)
				{
					_scatteringColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public static DynamicFog instance
		{
			get
			{
				if (_fog == null)
				{
					Camera[] allCameras = Camera.allCameras;
					for (int i = 0; i < allCameras.Length; i++)
					{
						_fog = allCameras[i].GetComponent<DynamicFog>();
						if (_fog != null)
						{
							break;
						}
					}
				}
				return _fog;
			}
		}

		public Camera fogCamera => currentCamera;

		public string GetCurrentPresetName()
		{
			return Enum.GetName(typeof(FOG_PRESET), preset);
		}

		private void OnEnable()
		{
			Init();
			UpdateMaterialPropertiesNow();
		}

		private void Reset()
		{
			UpdateMaterialPropertiesNow();
		}

		private void OnDestroy()
		{
			fogMat = null;
			if (fogMatVol != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatVol);
				fogMatVol = null;
				if (fogMatDesktopPlusOrthogonal != null)
				{
					UnityEngine.Object.DestroyImmediate(fogMatDesktopPlusOrthogonal);
					fogMatDesktopPlusOrthogonal = null;
				}
			}
			if (fogMatAdv != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatAdv);
				fogMatAdv = null;
			}
			if (fogMatFogSky != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatFogSky);
				fogMatFogSky = null;
			}
			if (fogMatOnlyFog != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatOnlyFog);
				fogMatOnlyFog = null;
			}
			if (fogMatSimple != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatSimple);
				fogMatSimple = null;
			}
			if (fogMatBasic != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatBasic);
				fogMatBasic = null;
			}
			if (fogMatOrthogonal != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatOrthogonal);
				fogMatOrthogonal = null;
			}
			if (fogMatDesktopPlusOrthogonal != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatDesktopPlusOrthogonal);
				fogMatOrthogonal = null;
			}
			if (fogOfWarTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(fogOfWarTexture);
				fogOfWarTexture = null;
			}
		}

		private void Init()
		{
			targetFogAlpha = -1f;
			targetSkyHazeAlpha = -1f;
			currentCamera = GetComponent<Camera>();
			UpdateFogOfWarTexture();
			if (_profile != null)
			{
				_profile.Load(this);
			}
		}

		private void Update()
		{
			if (fogMat == null)
			{
				return;
			}
			if (transitionProfile)
			{
				float num = (Time.time - transitionStartTime) / transitionDuration;
				if (num > 1f)
				{
					num = 1f;
				}
				DynamicFogProfile.Lerp(initialProfile, targetProfile, num, this);
				if (num >= 1f)
				{
					transitionProfile = false;
				}
			}
			if (transitionAlpha)
			{
				if (targetFogAlpha >= 0f)
				{
					if (targetFogAlpha != currentFogAlpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
					{
						if (transitionDuration > 0f)
						{
							currentFogAlpha = Mathf.Lerp(initialFogAlpha, targetFogAlpha, (Time.time - transitionStartTime) / transitionDuration);
							currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, targetSkyHazeAlpha, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogAlpha = targetFogAlpha;
							currentSkyHazeAlpha = targetSkyHazeAlpha;
							transitionAlpha = false;
						}
						fogMat.SetFloat("_FogAlpha", currentFogAlpha);
						SetSkyData();
					}
				}
				else if (currentFogAlpha != alpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
				{
					if (transitionDuration > 0f)
					{
						currentFogAlpha = Mathf.Lerp(initialFogAlpha, alpha, (Time.time - transitionStartTime) / transitionDuration);
						currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, alpha, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogAlpha = alpha;
						currentSkyHazeAlpha = skyAlpha;
						transitionAlpha = false;
					}
					fogMat.SetFloat("_FogAlpha", currentFogAlpha);
					SetSkyData();
				}
			}
			if (transitionColor)
			{
				if (targetFogColors)
				{
					if (targetFogColor1 != currentFogColor1 || targetFogColor2 != currentFogColor2)
					{
						if (transitionDuration > 0f)
						{
							currentFogColor1 = Color.Lerp(initialFogColor1, targetFogColor1, (Time.time - transitionStartTime) / transitionDuration);
							currentFogColor2 = Color.Lerp(initialFogColor2, targetFogColor2, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogColor1 = targetFogColor1;
							currentFogColor2 = targetFogColor2;
							transitionColor = false;
						}
						fogMat.SetColor("_FogColor", currentFogColor1);
						fogMat.SetColor("_FogColor2", currentFogColor2);
					}
				}
				else if (currentFogColor1 != color || currentFogColor2 != color2)
				{
					if (transitionDuration > 0f)
					{
						currentFogColor1 = Color.Lerp(initialFogColor1, color, (Time.time - transitionStartTime) / transitionDuration);
						currentFogColor2 = Color.Lerp(initialFogColor2, color2, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogColor1 = color;
						currentFogColor2 = color2;
						transitionColor = false;
					}
					fogMat.SetColor("_FogColor", currentFogColor1);
					fogMat.SetColor("_FogColor2", currentFogColor2);
				}
			}
			if (sun != null)
			{
				bool flag = false;
				if (sun.transform.forward != sunDirection)
				{
					flag = true;
				}
				if (sunLight != null && (sunLight.color != sunColor || sunLight.intensity != sunIntensity))
				{
					flag = true;
				}
				if (flag)
				{
					UpdateFogColor();
				}
			}
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		public void CheckPreset()
		{
			if (_preset != FOG_PRESET.Custom)
			{
				_effectType = FOG_TYPE.DesktopFogWithSkyHaze;
			}
			switch (preset)
			{
			case FOG_PRESET.Clear:
				alpha = 0f;
				break;
			case FOG_PRESET.Mist:
				alpha = 0.75f;
				skySpeed = 0.11f;
				skyHaze = 15f;
				skyNoiseStrength = 1f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0.07f;
				height = 4.4f;
				heightFallOff = 1f;
				turbulence = 0f;
				noiseStrength = 0.6f;
				speed = 0.01f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.WindyMist:
				alpha = 0.75f;
				skySpeed = 0.3f;
				skyHaze = 35f;
				skyNoiseStrength = 0.32f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0.07f;
				height = 2f;
				heightFallOff = 1f;
				turbulence = 2f;
				noiseStrength = 0.6f;
				speed = 0.06f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.GroundFog:
				alpha = 1f;
				skySpeed = 0.3f;
				skyHaze = 35f;
				skyNoiseStrength = 0.32f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0f;
				height = 1f;
				heightFallOff = 1f;
				turbulence = 0.4f;
				noiseStrength = 0.7f;
				speed = 0.005f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.Fog:
				alpha = 0.96f;
				skySpeed = 0.3f;
				skyHaze = 155f;
				skyNoiseStrength = 0.6f;
				skyAlpha = 0.93f;
				distance = (effectType.isPlus() ? 0.2f : 0.01f);
				distanceFallOff = 0.04f;
				height = 20f;
				heightFallOff = 1f;
				turbulence = 0.4f;
				noiseStrength = 0.4f;
				speed = 0.005f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.HeavyFog:
				alpha = 1f;
				skySpeed = 0.05f;
				skyHaze = 350f;
				skyNoiseStrength = 0.8f;
				skyAlpha = 0.97f;
				distance = (effectType.isPlus() ? 0.1f : 0f);
				distanceFallOff = 0.045f;
				height = 35f;
				heightFallOff = 0.88f;
				turbulence = 0.4f;
				noiseStrength = 0.24f;
				speed = 0.003f;
				color = new Color(0.86f, 0.847f, 0.847f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.SandStorm:
				alpha = 1f;
				skySpeed = 0.49f;
				skyHaze = 333f;
				skyNoiseStrength = 0.72f;
				skyAlpha = 0.97f;
				distance = (effectType.isPlus() ? 0.15f : 0f);
				distanceFallOff = 0.028f;
				height = 83f;
				heightFallOff = 0f;
				turbulence = 15f;
				noiseStrength = 0.45f;
				speed = 0.2f;
				color = new Color(0.364f, 0.36f, 0.36f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			}
		}

		private void OnPreCull()
		{
			if (currentCamera != null && currentCamera.depthTextureMode == DepthTextureMode.None)
			{
				currentCamera.depthTextureMode = DepthTextureMode.Depth;
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && XRSettings.enabled)
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			Graphics.Blit(source, destination, fogMat);
		}

		protected void ResetMaterial()
		{
			fogMat = null;
			fogMatAdv = null;
			fogMatFogSky = null;
			fogMatOnlyFog = null;
			fogMatSimple = null;
			fogMatBasic = null;
			fogMatVol = null;
			fogMatDesktopPlusOrthogonal = null;
			fogMatOrthogonal = null;
			UpdateMaterialProperties();
		}

		public void UpdateMaterialProperties()
		{
			if (UnityEngine.Application.isPlaying)
			{
				shouldUpdateMaterialProperties = true;
			}
			else
			{
				UpdateMaterialPropertiesNow();
			}
		}

		protected void UpdateMaterialPropertiesNow()
		{
			CheckPreset();
			CopyTransitionValues();
			if (currentCamera == null)
			{
				currentCamera = GetComponent<Camera>();
			}
			switch (effectType)
			{
			case FOG_TYPE.MobileFogOnlyGround:
				if (fogMatOnlyFog == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOOnlyFog";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGOnlyFog";
					}
					fogMatOnlyFog = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatOnlyFog.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatOnlyFog;
				break;
			case FOG_TYPE.MobileFogWithSkyHaze:
				if (fogMatFogSky == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOWithSky";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGWithSky";
					}
					fogMatFogSky = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatFogSky.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatFogSky;
				break;
			case FOG_TYPE.DesktopFogPlusWithSkyHaze:
				if (fogMatVol == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktopPlus";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktopPlus";
					}
					fogMatVol = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatVol.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatVol;
				break;
			case FOG_TYPE.MobileFogSimple:
				if (fogMatSimple == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOSimple";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGSimple";
					}
					fogMatSimple = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatSimple.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatSimple;
				break;
			case FOG_TYPE.MobileFogBasic:
				if (fogMatBasic == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOBasic";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGBasic";
					}
					fogMatBasic = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatBasic.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatBasic;
				break;
			case FOG_TYPE.MobileFogOrthogonal:
				if (fogMatOrthogonal == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOOrthogonal";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGOrthogonal";
					}
					fogMatOrthogonal = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatOrthogonal.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatOrthogonal;
				break;
			case FOG_TYPE.DesktopFogPlusOrthogonal:
				if (fogMatDesktopPlusOrthogonal == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktopPlusOrthogonal";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktopPlusOrthogonal";
					}
					fogMatDesktopPlusOrthogonal = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatDesktopPlusOrthogonal.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatDesktopPlusOrthogonal;
				break;
			default:
				if (fogMatAdv == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktop";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktop";
					}
					fogMatAdv = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatAdv.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatAdv;
				break;
			}
			if (fogMat == null)
			{
				return;
			}
			float num = ((effectType == FOG_TYPE.DesktopFogPlusWithSkyHaze) ? (_speed * 5f) : _speed);
			fogMat.SetVector("_FogSpeed", -_windDirection.normalized * num);
			Vector4 value = new Vector4(_noiseStrength, _turbulence, currentCamera.farClipPlane * 15f / 1000f, _noiseScale);
			fogMat.SetVector("_FogNoiseData", value);
			Vector4 value2 = new Vector4(_height + 0.001f, _baselineHeight, _clipUnderBaseline ? (-0.01f) : (-10000f), _heightFallOff);
			if (_effectType == FOG_TYPE.MobileFogOrthogonal || _effectType == FOG_TYPE.DesktopFogPlusOrthogonal)
			{
				value2.z = maxHeight;
			}
			fogMat.SetVector("_FogHeightData", value2);
			fogMat.SetFloat("_FogAlpha", currentFogAlpha);
			Vector4 value3 = new Vector4(_distance, _distanceFallOff, _maxDistance, _maxDistanceFallOff);
			if (effectType.isPlus())
			{
				value3.x = currentCamera.farClipPlane * _distance;
				value3.y = distanceFallOff * value3.x + 0.0001f;
				value3.z *= currentCamera.farClipPlane;
			}
			fogMat.SetVector("_FogDistance", value3);
			UpdateFogColor();
			SetSkyData();
			if (shaderKeywords == null)
			{
				shaderKeywords = new List<string>();
			}
			else
			{
				shaderKeywords.Clear();
			}
			if (fogOfWarEnabled)
			{
				if (fogOfWarTexture == null)
				{
					UpdateFogOfWarTexture();
				}
				fogMat.SetTexture("_FogOfWar", fogOfWarTexture);
				fogMat.SetVector("_FogOfWarCenter", _fogOfWarCenter);
				fogMat.SetVector("_FogOfWarSize", _fogOfWarSize);
				Vector3 vector = fogOfWarCenter - 0.5f * _fogOfWarSize;
				fogMat.SetVector("_FogOfWarCenterAdjusted", new Vector3(vector.x / _fogOfWarSize.x, 1f, vector.z / _fogOfWarSize.z));
				shaderKeywords.Add("FOG_OF_WAR_ON");
			}
			if (_enableDithering)
			{
				fogMat.SetFloat("_FogDither", _ditherStrength * 0.1f);
				shaderKeywords.Add("DITHER_ON");
			}
			fogMat.shaderKeywords = shaderKeywords.ToArray();
		}

		private void CopyTransitionValues()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			currentFogColor1 = _color;
			currentFogColor2 = _color2;
		}

		private void SetSkyData()
		{
			Vector4 value = new Vector4(_skyHaze, _skySpeed, _skyNoiseStrength, currentSkyHazeAlpha);
			fogMat.SetVector("_FogSkyData", value);
		}

		private void UpdateFogColor()
		{
			if (fogMat == null)
			{
				return;
			}
			if (_sun != null)
			{
				if (sunLight == null)
				{
					sunLight = _sun.GetComponent<Light>();
				}
				if (sunLight != null && sunLight.transform != _sun.transform)
				{
					sunLight = _sun.GetComponent<Light>();
				}
				sunDirection = _sun.transform.forward;
				if (sunLight != null)
				{
					sunColor = sunLight.color;
					sunIntensity = sunLight.intensity;
				}
			}
			float num = sunIntensity * Mathf.Clamp01(1f - sunDirection.y);
			fogMat.SetColor("_FogColor", num * currentFogColor1 * sunColor);
			fogMat.SetColor("_FogColor2", num * currentFogColor2 * sunColor);
			Color color = num * scatteringColor;
			fogMat.SetColor("_SunColor", new Vector4(color.r, color.g, color.b, scattering));
			fogMat.SetVector("_SunDir", -sunDirection);
		}

		public void SetTargetProfile(DynamicFogProfile targetProfile, float duration)
		{
			if (_useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialProfile = ScriptableObject.CreateInstance<DynamicFogProfile>();
				initialProfile.Save(this);
				this.targetProfile = targetProfile;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionProfile = true;
			}
		}

		public void ClearTargetProfile(float duration)
		{
			SetTargetProfile(initialProfile, duration);
		}

		public void SetTargetAlpha(float newFogAlpha, float newSkyHazeAlpha, float duration)
		{
			if (useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialFogAlpha = currentFogAlpha;
				initialSkyHazeAlpha = currentSkyHazeAlpha;
				targetFogAlpha = newFogAlpha;
				targetSkyHazeAlpha = newSkyHazeAlpha;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionAlpha = true;
			}
		}

		public void ClearTargetAlpha(float duration)
		{
			SetTargetAlpha(-1f, -1f, duration);
		}

		public void SetTargetColors(Color color1, Color color2, float duration)
		{
			if (useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialFogColor1 = currentFogColor1;
				initialFogColor2 = currentFogColor2;
				targetFogColor1 = color1;
				targetFogColor2 = color2;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				targetFogColors = true;
				transitionColor = true;
			}
		}

		public void ClearTargetColors(float duration)
		{
			targetFogColors = false;
			SetTargetColors(color, color2, duration);
		}

		private void UpdateFogOfWarTexture()
		{
			if (fogOfWarEnabled)
			{
				int scaledSize = GetScaledSize(fogOfWarTextureSize, 1f);
				fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.ARGB32, mipChain: false);
				fogOfWarTexture.hideFlags = HideFlags.DontSave;
				fogOfWarTexture.filterMode = FilterMode.Bilinear;
				fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
				ResetFogOfWar();
			}
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - fogOfWarCenter.x) / fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - fogOfWarCenter.z) / fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int num3 = fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			Color32 color = fogOfWarColorBuffer[num6];
			if (b == color.a)
			{
				return;
			}
			float num7 = radius / fogOfWarSize.z;
			int num8 = Mathf.FloorToInt((float)num3 * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num8; j <= num4 + num8; j++)
				{
					if (j > 0 && j < width - 1)
					{
						int num9 = Mathf.FloorToInt(Mathf.Sqrt((num5 - i) * (num5 - i) + (num4 - j) * (num4 - j)));
						if (num9 <= num8)
						{
							num6 = i * width + j;
							Color32 color2 = fogOfWarColorBuffer[num6];
							color2.a = (byte)Mathf.Lerp((int)b, (int)color2.a, (float)num9 / (float)num8);
							fogOfWarColorBuffer[num6] = color2;
							fogOfWarTexture.SetPixel(j, i, color2);
						}
					}
				}
			}
			fogOfWarTexture.Apply();
		}

		public void ResetFogOfWarAlpha(Vector3 worldPosition, float radius)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - fogOfWarCenter.x) / fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - fogOfWarCenter.z) / fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int num3 = fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			float num7 = radius / fogOfWarSize.z;
			int num8 = Mathf.FloorToInt((float)num3 * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i > 0 && i < num3 - 1)
				{
					for (int j = num4 - num8; j <= num4 + num8; j++)
					{
						if (j > 0 && j < width - 1 && Mathf.FloorToInt(Mathf.Sqrt((num5 - i) * (num5 - i) + (num4 - j) * (num4 - j))) <= num8)
						{
							num6 = i * width + j;
							Color32 color = fogOfWarColorBuffer[num6];
							color.a = byte.MaxValue;
							fogOfWarColorBuffer[num6] = color;
							fogOfWarTexture.SetPixel(j, i, color);
						}
					}
				}
				fogOfWarTexture.Apply();
			}
		}

		public void ResetFogOfWar()
		{
			if (!(fogOfWarTexture == null))
			{
				int num = fogOfWarTexture.height;
				int width = fogOfWarTexture.width;
				int num2 = num * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num2)
				{
					fogOfWarColorBuffer = new Color32[num2];
				}
				Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = 0; i < num2; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				fogOfWarTexture.Apply();
			}
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[HelpURL("http://kronnect.com/taptapgo")]
	[ImageEffectAllowedInSceneView]
	public class DynamicFogExclusive : DynamicFogBase
	{
		private RenderTexture rt;

		[Range(0.1f, 2f)]
		public float renderScale = 1f;

		private void OnPreRender()
		{
			if (!(fogMat == null) && _alpha != 0f && !(currentCamera == null))
			{
				if (XRSettings.enabled)
				{
					RenderTextureDescriptor eyeTextureDesc = XRSettings.eyeTextureDesc;
					eyeTextureDesc.width = (int)((float)eyeTextureDesc.width * renderScale);
					eyeTextureDesc.height = (int)((float)eyeTextureDesc.height * renderScale);
					rt = RenderTexture.GetTemporary(eyeTextureDesc);
				}
				else
				{
					int width = (int)((float)currentCamera.pixelWidth * renderScale);
					int num = (int)((float)currentCamera.pixelHeight * renderScale);
					rt = RenderTexture.GetTemporary(width, num, 24, RenderTextureFormat.ARGB32);
					rt.antiAliasing = 1;
				}
				rt.wrapMode = TextureWrapMode.Clamp;
				currentCamera.targetTexture = rt;
			}
		}

		private void OnPostRender()
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && XRSettings.enabled)
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			currentCamera.targetTexture = null;
			Graphics.Blit(rt, null, fogMat);
			RenderTexture.ReleaseTemporary(rt);
		}
	}
	[ExecuteInEditMode]
	[HelpURL("http://kronnect.com/taptapgo")]
	public class DynamicFogManager : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float alpha = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.5f;

		[Range(0f, 0.999f)]
		public float distance = 0.2f;

		[Range(0f, 2f)]
		public float distanceFallOff = 1f;

		[Range(0f, 500f)]
		public float height = 1f;

		[Range(0f, 1f)]
		public float heightFallOff = 1f;

		public float baselineHeight;

		public Color color = new Color(0.89f, 0.89f, 0.89f, 1f);

		public GameObject sun;

		private Light sunLight;

		private Vector3 sunDirection = Vector3.zero;

		private Color sunColor = Color.white;

		private float sunIntensity = 1f;

		private void OnEnable()
		{
			UpdateMaterialProperties();
		}

		private void Reset()
		{
			UpdateMaterialProperties();
		}

		private void Update()
		{
			if (sun != null)
			{
				bool flag = false;
				if (sun.transform.forward != sunDirection)
				{
					flag = true;
				}
				if (sunLight != null && (sunLight.color != sunColor || sunLight.intensity != sunIntensity))
				{
					flag = true;
				}
				if (flag)
				{
					UpdateFogColor();
				}
			}
			UpdateFogData();
		}

		public void UpdateMaterialProperties()
		{
			UpdateFogData();
			UpdateFogColor();
		}

		private void UpdateFogData()
		{
			Vector4 value = new Vector4(height + 0.001f, baselineHeight, Camera.main.farClipPlane * distance, heightFallOff);
			Shader.SetGlobalVector("_FogData", value);
			Shader.SetGlobalFloat("_FogData2", distanceFallOff * value.z + 0.0001f);
		}

		private void UpdateFogColor()
		{
			if (sun != null)
			{
				if (sunLight == null)
				{
					sunLight = sun.GetComponent<Light>();
				}
				if (sunLight != null && sunLight.transform != sun.transform)
				{
					sunLight = sun.GetComponent<Light>();
				}
				sunDirection = sun.transform.forward;
				if (sunLight != null)
				{
					sunColor = sunLight.color;
					sunIntensity = sunLight.intensity;
				}
			}
			float num = sunIntensity * Mathf.Clamp01(1f - sunDirection.y);
			Color value = color * sunColor * num;
			value.a = alpha;
			Shader.SetGlobalColor("_FogColor", value);
		}
	}
	[ExecuteInEditMode]
	public class DynamicFogOfWar : MonoBehaviour
	{
		public int fogOfWarTextureSize = 512;

		private Material fogMat;

		private static DynamicFogOfWar _instance;

		private Texture2D fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		public static DynamicFogOfWar instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<DynamicFogOfWar>();
				}
				return _instance;
			}
		}

		private void OnEnable()
		{
			fogMat = GetComponent<MeshRenderer>().sharedMaterial;
			UpdateFogOfWarTexture();
		}

		private void OnDisable()
		{
			if (fogOfWarTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(fogOfWarTexture);
				fogOfWarTexture = null;
			}
		}

		private void Update()
		{
			fogMat.SetVector("_FogOfWarData", new Vector4(base.transform.position.x, base.transform.position.z, base.transform.localScale.x, base.transform.localScale.y));
		}

		private void UpdateFogOfWarTexture()
		{
			int scaledSize = GetScaledSize(fogOfWarTextureSize, 1f);
			fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.ARGB32, mipChain: false);
			fogOfWarTexture.hideFlags = HideFlags.DontSave;
			fogOfWarTexture.filterMode = FilterMode.Bilinear;
			fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
			fogMat.mainTexture = fogOfWarTexture;
			ResetFogOfWar();
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - base.transform.position.x) / base.transform.localScale.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - base.transform.position.z) / base.transform.localScale.y + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int height = fogOfWarTexture.height;
			int num3 = (int)(num * (float)width);
			int num4 = (int)(num2 * (float)height);
			int num5 = num4 * width + num3;
			byte b = (byte)(fogNewAlpha * 255f);
			Color32 color = fogOfWarColorBuffer[num5];
			if (b == color.a)
			{
				return;
			}
			float num6 = radius / base.transform.localScale.y;
			int num7 = Mathf.FloorToInt((float)height * num6);
			for (int i = num4 - num7; i <= num4 + num7; i++)
			{
				if (i < 0 || i >= height)
				{
					continue;
				}
				for (int j = num3 - num7; j <= num3 + num7; j++)
				{
					if (j >= 0 && j < width)
					{
						int num8 = (int)Mathf.Sqrt((num4 - i) * (num4 - i) + (num3 - j) * (num3 - j));
						if (num8 <= num7)
						{
							num5 = i * width + j;
							Color32 color2 = fogOfWarColorBuffer[num5];
							color2.a = (byte)Mathf.Lerp((int)b, (int)color2.a, (float)num8 / (float)num7);
							fogOfWarColorBuffer[num5] = color2;
							fogOfWarTexture.SetPixel(j, i, color2);
						}
					}
				}
			}
			fogOfWarTexture.Apply();
		}

		public void ResetFogOfWar()
		{
			if (!(fogOfWarTexture == null))
			{
				int height = fogOfWarTexture.height;
				int width = fogOfWarTexture.width;
				int num = height * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num)
				{
					fogOfWarColorBuffer = new Color32[num];
				}
				Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = 0; i < num; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				fogOfWarTexture.Apply();
			}
		}

		public void SetFogOfWarTerrainBoundary(Terrain terrain, float borderWidth)
		{
			TerrainData terrainData = terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			float y = terrainData.size.y;
			float[,] heights = terrainData.GetHeights(0, 0, heightmapResolution, heightmapResolution2);
			float num = base.transform.position.y - 1f;
			float num2 = base.transform.position.y + 10f;
			Vector3 position = terrain.GetPosition();
			for (int i = 0; i < heightmapResolution2; i++)
			{
				for (int j = 0; j < heightmapResolution; j++)
				{
					float num3 = heights[i, j] * y + terrain.transform.position.y;
					if (num3 > num && num3 < num2)
					{
						Vector3 worldPosition = position + new Vector3(terrainData.size.x * ((float)j + 0.5f) / (float)heightmapResolution, 0f, terrainData.size.z * ((float)i + 0.5f) / (float)heightmapResolution2);
						SetFogOfWarAlpha(worldPosition, borderWidth, 0f);
					}
				}
			}
		}
	}
	[CreateAssetMenu(fileName = "DynamicFogProfile", menuName = "Dynamic Fog Profile", order = 100)]
	public class DynamicFogProfile : ScriptableObject
	{
		public FOG_TYPE effectType = FOG_TYPE.DesktopFogPlusWithSkyHaze;

		public bool enableDithering;

		[Range(0f, 0.2f)]
		public float ditherStrength = 0.03f;

		[Range(0f, 1f)]
		public float alpha = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.5f;

		[Range(0.01f, 1f)]
		public float noiseScale = 0.1f;

		[Range(0f, 0.999f)]
		public float distance = 0.1f;

		[Range(0.0001f, 2f)]
		public float distanceFallOff = 0.01f;

		[Range(0f, 1.2f)]
		public float maxDistance = 0.999f;

		[Range(0.0001f, 0.5f)]
		public float maxDistanceFallOff;

		[Range(0f, 500f)]
		public float height = 1f;

		[Range(0f, 500f)]
		public float maxHeight = 100f;

		[Range(0.0001f, 1f)]
		public float heightFallOff = 0.1f;

		public float baselineHeight;

		public bool clipUnderBaseline;

		[Range(0f, 15f)]
		public float turbulence = 0.1f;

		[Range(0f, 5f)]
		public float speed = 0.1f;

		public Vector3 windDirection = new Vector3(1f, 0f, 1f);

		public Color color = Color.white;

		public Color color2 = Color.gray;

		[Range(0f, 500f)]
		public float skyHaze = 50f;

		[Range(0f, 1f)]
		public float skySpeed = 0.3f;

		[Range(0f, 1f)]
		public float skyNoiseStrength = 0.1f;

		[Range(0f, 1f)]
		public float skyAlpha = 1f;

		public bool useXZDistance;

		[Range(0f, 1f)]
		public float scattering = 0.7f;

		public Color scatteringColor = new Color(1f, 1f, 0.8f);

		public void Load(DynamicFogBase fog)
		{
			fog.preset = FOG_PRESET.Custom;
			fog.effectType = effectType;
			fog.enableDithering = enableDithering;
			fog.ditherStrength = ditherStrength;
			fog.alpha = alpha;
			fog.noiseStrength = noiseStrength;
			fog.noiseScale = noiseScale;
			fog.distance = distance;
			fog.distanceFallOff = distanceFallOff;
			fog.maxDistance = maxDistance;
			fog.maxDistanceFallOff = maxDistanceFallOff;
			fog.height = height;
			fog.maxHeight = maxHeight;
			fog.heightFallOff = heightFallOff;
			fog.baselineHeight = baselineHeight;
			fog.clipUnderBaseline = clipUnderBaseline;
			fog.turbulence = turbulence;
			fog.speed = speed;
			fog.windDirection = windDirection;
			fog.color = color;
			fog.color2 = color2;
			fog.skyHaze = skyHaze;
			fog.skySpeed = skySpeed;
			fog.skyNoiseStrength = skyNoiseStrength;
			fog.skyAlpha = skyAlpha;
			fog.useXZDistance = useXZDistance;
			fog.scattering = scattering;
			fog.scatteringColor = scatteringColor;
		}

		public void Save(DynamicFogBase fog)
		{
			effectType = fog.effectType;
			enableDithering = fog.enableDithering;
			ditherStrength = fog.ditherStrength;
			alpha = fog.alpha;
			noiseStrength = fog.noiseStrength;
			noiseScale = fog.noiseScale;
			distance = fog.distance;
			distanceFallOff = fog.distanceFallOff;
			maxDistance = fog.maxDistance;
			maxDistanceFallOff = fog.maxDistanceFallOff;
			height = fog.height;
			maxHeight = fog.maxHeight;
			heightFallOff = fog.heightFallOff;
			baselineHeight = fog.baselineHeight;
			clipUnderBaseline = fog.clipUnderBaseline;
			turbulence = fog.turbulence;
			speed = fog.speed;
			windDirection = fog.windDirection;
			color = fog.color;
			color2 = fog.color2;
			skyHaze = fog.skyHaze;
			skySpeed = fog.skySpeed;
			skyNoiseStrength = fog.skyNoiseStrength;
			skyAlpha = fog.skyAlpha;
			useXZDistance = fog.useXZDistance;
			scattering = fog.scattering;
			scatteringColor = fog.scatteringColor;
		}

		public static void Lerp(DynamicFogProfile profile1, DynamicFogProfile profile2, float t, DynamicFogBase fog)
		{
			if (t < 0f)
			{
				t = 0f;
			}
			else if (t > 1f)
			{
				t = 1f;
			}
			fog.enableDithering = ((t < 0.5f) ? profile1.enableDithering : profile2.enableDithering);
			fog.ditherStrength = profile1.ditherStrength * (1f - t) + profile2.ditherStrength * t;
			fog.alpha = profile1.alpha * (1f - t) + profile2.alpha * t;
			fog.noiseStrength = profile1.noiseStrength * (1f - t) + profile2.noiseStrength * t;
			fog.noiseScale = profile1.noiseScale * (1f - t) + profile2.noiseScale * t;
			fog.distance = profile1.distance * (1f - t) + profile2.distance * t;
			fog.distanceFallOff = profile1.distanceFallOff * (1f - t) + profile2.distanceFallOff * t;
			fog.maxDistance = profile1.maxDistance * (1f - t) + profile2.maxDistance * t;
			fog.maxDistanceFallOff = profile1.maxDistanceFallOff * (1f - t) + profile2.maxDistanceFallOff * t;
			fog.height = profile1.height * (1f - t) + profile2.height * t;
			fog.maxHeight = profile1.maxHeight * (1f - t) + profile2.maxHeight * t;
			fog.heightFallOff = profile1.heightFallOff * (1f - t) + profile2.heightFallOff * t;
			fog.baselineHeight = profile1.baselineHeight * (1f - t) + profile2.baselineHeight * t;
			fog.clipUnderBaseline = ((t < 0.5f) ? profile1.clipUnderBaseline : profile2.clipUnderBaseline);
			fog.turbulence = profile1.turbulence * (1f - t) + profile2.turbulence * t;
			fog.speed = profile1.speed * (1f - t) + profile2.speed * t;
			fog.windDirection = profile1.windDirection * (1f - t) + profile2.windDirection * t;
			fog.color = profile1.color * (1f - t) + profile2.color * t;
			fog.color2 = profile1.color2 * (1f - t) + profile2.color * t;
			fog.skyHaze = profile1.skyHaze * (1f - t) + profile2.skyHaze * t;
			fog.skySpeed = profile1.skySpeed * (1f - t) + profile2.skySpeed * t;
			fog.skyNoiseStrength = profile1.skyNoiseStrength * (1f - t) + profile2.skyNoiseStrength * t;
			fog.skyAlpha = profile1.skyAlpha * (1f - t) + profile2.skyAlpha * t;
			fog.useXZDistance = ((t < 0.5f) ? profile1.useXZDistance : profile2.useXZDistance);
			fog.scattering = profile1.scattering * (1f - t) + profile2.scattering * t;
			fog.scatteringColor = profile1.scatteringColor * (1f - t) + profile2.scatteringColor * t;
		}
	}
	public class FogVolume : MonoBehaviour
	{
		private const float GRAY = 0.8901961f;

		[Tooltip("Enables transition to a given profile.")]
		public bool enableProfileTransition;

		[Tooltip("Assign the transition profile.")]
		public DynamicFogProfile targetProfile;

		[Tooltip("Enables alpha transition.")]
		public bool enableAlphaTransition;

		[Tooltip("Target alpha for fog when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetFogAlpha = 0.5f;

		[Tooltip("Target alpha for sky haze when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetSkyHazeAlpha = 0.5f;

		[Tooltip("Enables fog color transition.")]
		public bool enableFogColorTransition;

		[Tooltip("Target fog color 1 when gamera enters this fog folume")]
		public Color targetFogColor1 = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Target fog color 2 when gamera enters this fog folume")]
		public Color targetFogColor2 = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Set this to zero for changing fog alpha immediately upon enter/exit fog volume.")]
		public float transitionDuration = 3f;

		[Tooltip("Set collider that will trigger this fog volume. If not set, this fog volume will react to any collider which has the main camera. If you use a third person controller, assign the character collider here.")]
		public Collider targetCollider;

		[Tooltip("When enabled, a console message will be printed whenever this fog volume is entered or exited.")]
		public bool debugMode;

		[Tooltip("Assign target Dynamic Fog component that will be affected by this volume.")]
		public DynamicFog targetFog;

		private bool cameraInside;

		private void Start()
		{
			if (targetFog == null)
			{
				targetFog = DynamicFogBase.instance;
			}
			if (targetFog != null)
			{
				targetFog.useFogVolumes = true;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = true;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.SetTargetProfile(targetProfile, transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.SetTargetAlpha(targetFogAlpha, targetSkyHazeAlpha, transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.SetTargetColors(targetFogColor1, targetFogColor2, transitionDuration);
				}
				if (debugMode)
				{
					Debugs.Log("Fog Volume entered by " + other.name);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = false;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.ClearTargetProfile(transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.ClearTargetAlpha(transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.ClearTargetColors(transitionDuration);
				}
				if (debugMode)
				{
					Debugs.Log("Fog Volume exited by " + other.name);
				}
			}
		}
	}
}
namespace ns3dRudder
{
	public class U3D_AnimationCurve : Curve
	{
		public AnimationCurve Curve;

		public U3D_AnimationCurve(float fxSat, AnimationCurve curve)
			: base(fxSat, 0f, 1f)
		{
			Curve = curve;
		}

		public override float CalcCurveValue(float fValue)
		{
			return Curve.Evaluate(fValue) * XSat;
		}
	}
	public class AxesParamUnity3D : IAxesParam
	{
		public AnimationCurve[] animationCurves;

		public AxesParamUnity3D()
		{
			NonSymmetrical = true;
			animationCurves = new AnimationCurve[4];
			for (int i = 0; i < animationCurves.Length; i++)
			{
				animationCurves[i] = new AnimationCurve(new Keyframe(-1f, -1f), new Keyframe(-0.25f, 0f), new Keyframe(0f, 0f), new Keyframe(0.25f, 0f), new Keyframe(1f, 1f));
			}
		}

		public override ErrorCode UpdateParam(uint nPortNumber)
		{
			ErrorCode result = ErrorCode.Success;
			DeviceInformation deviceInformation = Sdk3dRudder.GetDeviceInformation(nPortNumber);
			if (deviceInformation != null)
			{
				SetCurve(Axes.LeftRight, new U3D_AnimationCurve(deviceInformation.GetUserRoll() / deviceInformation.GetMaxRoll(), animationCurves[0]));
				SetCurve(Axes.ForwardBackward, new U3D_AnimationCurve(deviceInformation.GetUserPitch() / deviceInformation.GetUserPitch(), animationCurves[1]));
				SetCurve(Axes.UpDown, new U3D_AnimationCurve(0.6f, animationCurves[2]));
				SetCurve(Axes.Rotation, new U3D_AnimationCurve(deviceInformation.GetUserYaw() / deviceInformation.GetMaxYaw(), animationCurves[3]));
			}
			else
			{
				result = Sdk3dRudder.GetLastError();
			}
			Roll2YawCompensation = deviceInformation.GetDefaultRoll2YawCompensation();
			return result;
		}
	}
	public class FPSLocomotion : ILocomotion
	{
		public float AnglePerSecond = 90f;

		public bool LocalTranslation = true;

		public bool UsePhysics;

		protected Vector3 translation;

		protected float angle;

		protected Transform trans;

		private void Start()
		{
			translation = Vector3.zero;
			angle = 0f;
			trans = base.transform;
		}

		public override void UpdateAxes(Controller3dRudder controller3dRudder, Vector4 axesWithFactor)
		{
			translation = axesWithFactor;
			angle = axesWithFactor.w;
		}

		private void Update()
		{
			if (!UsePhysics)
			{
				trans.Translate(translation * Time.deltaTime, LocalTranslation ? Space.Self : Space.World);
			}
			trans.Rotate(0f, angle * AnglePerSecond * Time.deltaTime, 0f);
		}

		private void FixedUpdate()
		{
			if (UsePhysics)
			{
				trans.Translate(translation * Time.deltaTime, LocalTranslation ? Space.Self : Space.World);
			}
		}
	}
	public abstract class ILocomotion : MonoBehaviour
	{
		public abstract void UpdateAxes(Controller3dRudder controller3dRudder, Vector4 axesWithFactor);
	}
	public class AxesParamCustom : IAxesParam
	{
		public Curve[] CustomCurves;

		public AxesParamCustom()
		{
			CustomCurves = AxesParamDefault.GetDefaultNonNormalizedCurves();
			NonSymmetrical = true;
		}

		public override ErrorCode UpdateParam(uint nPortNumber)
		{
			ErrorCode result = ErrorCode.Success;
			DeviceInformation deviceInformation = Sdk3dRudder.GetDeviceInformation(nPortNumber);
			if (deviceInformation != null)
			{
				float num = deviceInformation.GetUserRoll() * CustomCurves[0].XSat / deviceInformation.GetMaxRoll();
				SetCurve(Axes.LeftRight, new Curve(num, CustomCurves[0].DeadZone * num, CustomCurves[0].Exp));
				float num2 = deviceInformation.GetUserPitch() * CustomCurves[1].XSat / deviceInformation.GetMaxPitch();
				SetCurve(Axes.ForwardBackward, new Curve(num2, CustomCurves[1].DeadZone * num2, CustomCurves[1].Exp));
				float num3 = deviceInformation.GetUserYaw() * CustomCurves[3].XSat / deviceInformation.GetMaxYaw();
				SetCurve(Axes.Rotation, new Curve(num3, CustomCurves[3].DeadZone * num3, CustomCurves[3].Exp));
			}
			else
			{
				result = Sdk3dRudder.GetLastError();
			}
			SetCurve(Axes.UpDown, new Curve(CustomCurves[2].XSat, CustomCurves[2].DeadZone * CustomCurves[2].XSat, CustomCurves[2].Exp));
			return result;
		}
	}
	public class AxesParamDefault : IAxesParam
	{
		public static float DEFAULT_DEADZONE = 0.25f;

		public static float DEFAULT_XSAT = 0.7f;

		public static float DEFAULT_DEADZONE_ROTATION = 0.15f;

		public AxesParamDefault()
		{
			SetCurves(GetDefaultNonNormalizedCurves());
			NonSymmetrical = true;
		}

		public override ErrorCode UpdateParam(uint nPortNumber)
		{
			ErrorCode result = ErrorCode.Success;
			DeviceInformation deviceInformation = Sdk3dRudder.GetDeviceInformation(nPortNumber);
			if (deviceInformation != null)
			{
				float num = deviceInformation.GetUserRoll() / deviceInformation.GetMaxRoll();
				float num2 = deviceInformation.GetUserPitch() / deviceInformation.GetMaxPitch();
				float xSat = deviceInformation.GetUserYaw() / deviceInformation.GetMaxYaw();
				Curve curve = GetCurve(Axes.LeftRight);
				curve.XSat = DEFAULT_XSAT * num;
				curve.DeadZone = DEFAULT_DEADZONE * curve.XSat;
				curve = GetCurve(Axes.ForwardBackward);
				curve.XSat = DEFAULT_XSAT * num2;
				curve.DeadZone = DEFAULT_DEADZONE * curve.XSat;
				curve = GetCurve(Axes.Rotation);
				curve.XSat = xSat;
				curve.DeadZone = DEFAULT_DEADZONE_ROTATION * curve.XSat;
				Roll2YawCompensation = deviceInformation.GetDefaultRoll2YawCompensation();
			}
			else
			{
				result = Sdk3dRudder.GetLastError();
			}
			return result;
		}

		public static Curve[] GetDefaultNonNormalizedCurves()
		{
			Curve[] array = new Curve[4];
			array[1] = new Curve(DEFAULT_XSAT, DEFAULT_DEADZONE, 1f);
			array[0] = new Curve(DEFAULT_XSAT, DEFAULT_DEADZONE, 1f);
			array[2] = new Curve(0.6f, 0.1f, 2f);
			array[3] = new Curve(1f, DEFAULT_DEADZONE_ROTATION, 1f);
			return array;
		}
	}
	public class AxesParamNormalizedLinear : IAxesParam
	{
		public AxesParamNormalizedLinear()
		{
			SetCurve(Axes.LeftRight, new Curve(1f, 0f, 1f));
			SetCurve(Axes.ForwardBackward, new Curve(1f, 0f, 1f));
			SetCurve(Axes.UpDown, new Curve(1f, 0f, 1f));
			SetCurve(Axes.Rotation, new Curve(1f, 0f, 1f));
			NonSymmetrical = false;
			Roll2YawCompensation = 0f;
		}

		public override ErrorCode UpdateParam(uint nPortNumber)
		{
			Sdk3dRudder.GetDeviceInformation(nPortNumber);
			return Sdk3dRudder.GetLastError();
		}
	}
	public enum Axes
	{
		LeftRight,
		ForwardBackward,
		UpDown,
		Rotation,
		MaxAxes
	}
	public enum Status
	{
		NoStatus = 0,
		NoFootStayStill = 1,
		Initialization = 2,
		PutYourFeet = 3,
		PutSecondFoot = 4,
		StayStill = 5,
		InUse = 6,
		Frozen = 253,
		IsNotConnected = 254,
		Error = 255
	}
	public enum ErrorCode
	{
		Success = 0,
		NotConnected = 1,
		Fail = 2,
		IncorrectCommand = 3,
		Timeout = 4,
		DeviceNotSupported = 5,
		DeviceInitError = 6,
		ValidationError = 7,
		ValidationTimeOut = 8,
		NotReady = 9,
		FirmwareNeedToBeUpdated = 10,
		NotInitialized = 11,
		NotSupported = 12,
		DashboardInstallError = 13,
		DashboardUpdateError = 14,
		Other = 255
	}
	public delegate float CalcCurveValue_t(IntPtr pCurve, float value);
	public delegate void CallbackTypeConnect(uint value);
	public class Sdk3dRudder
	{
		private class Import
		{
			[DllImport("i3DR")]
			public static extern uint Init();

			[DllImport("i3DR")]
			public static extern ushort GetSDKVersion();

			[DllImport("i3DR")]
			public static extern uint GetNumberOfConnectedDevice();

			[DllImport("i3DR")]
			public static extern bool IsDeviceConnected(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern ushort GetFWVersion(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern ErrorCode HideSystemDevice(uint nPortNumber, bool bHide);

			[DllImport("i3DR")]
			public static extern bool IsSystemDeviceHidden(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern ErrorCode PlaySnd(uint nPortNumber, ushort nFrequency, ushort nDuration);

			[DllImport("i3DR")]
			public static extern ErrorCode PlaySndEx1(uint nPortNumber, uint nSize, IntPtr pTones, bool bAddToPlayedList);

			[DllImport("i3DR")]
			public static extern ErrorCode PlaySndEx2(uint nPortNumber, IntPtr sTones, bool bAddToPlayedList);

			[DllImport("i3DR")]
			public static extern ErrorCode GetUserOffset(uint nPortNumber, IntPtr pAxisValue);

			[DllImport("i3DR")]
			public static extern ErrorCode GetAxes(uint nPortNumber, IntPtr pAxesParam, IntPtr pAxisValue, CalcCurveValue_t pCalcCurve);

			[DllImport("i3DR")]
			public static extern Status GetStatus(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern ushort GetSensor(uint nPortNumber, uint nIndex);

			[DllImport("i3DR")]
			public static extern IntPtr GetDeviceInformation(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern ErrorCode SetFreeze(uint nPortNumber, bool bEnable);

			[DllImport("i3DR")]
			public static extern bool IsFrozen(uint nPortNumber);

			[DllImport("i3DR")]
			public static extern IntPtr GetErrorText(ErrorCode nError);

			[DllImport("i3DR")]
			public static extern ErrorCode GetLastSdkError();

			[DllImport("i3DR")]
			public static extern void Set3dREvent(CallbackTypeConnect OnConnect, CallbackTypeConnect OnDisconnect, CallbackTypeConnect OnEndSound);

			[DllImport("i3DR")]
			public static extern void InitQueueEvent();

			[DllImport("i3DR")]
			public static extern IntPtr GetEventMessage();

			[DllImport("i3DR")]
			public static extern float CalcCurveValue(float fDeadZone, float fxSat, float fExp, float fValue);

			[DllImport("i3DR")]
			public static extern float CalcNonSymmetricalPitch(uint nPortNumber, float fNormalizedV, IntPtr pCurve);

			[DllImport("i3DR")]
			public static extern void MemCpy(IntPtr pDest, IntPtr pSrc, int nSize);

			[DllImport("i3DR")]
			public static extern ErrorCode StopSDK();

			[DllImport("i3DR")]
			public static extern void EndSDK();
		}

		public static readonly int MAX_DEVICE = 4;

		public static readonly uint _3DRUDDER_SDK_VERSION = 517u;

		public static readonly uint _3DRUDDER_PACKAGE_VERSION = 521u;

		public static void Initialize()
		{
			EventRudder.OnConnectEvent = (Action<uint>)Delegate.Combine(EventRudder.OnConnectEvent, (Action<uint>)delegate(uint portNumber)
			{
				UnityEngine.Debug.LogFormat("[3dRudder]  {0} connected, firmware :{1:X4}", portNumber, GetVersion(portNumber));
			});
			EventRudder.OnDisconnectEvent = (Action<uint>)Delegate.Combine(EventRudder.OnDisconnectEvent, (Action<uint>)delegate(uint portNumber)
			{
				UnityEngine.Debug.LogFormat("[3dRudder]  {0} disconnected, firmware : {1:X4}", portNumber, GetVersion(portNumber));
			});
			EventRudder.OnEndSoundEvent = (Action<uint>)Delegate.Combine(EventRudder.OnEndSoundEvent, (Action<uint>)delegate(uint portNumber)
			{
				UnityEngine.Debug.LogFormat("[3dRudder]  {0} EndSound Event", portNumber);
			});
			if (IntPtr.Size == 8)
			{
				SetEvent(EventRudder.OnConnect, EventRudder.OnDisconnect, EventRudder.OnEndSound);
			}
			else
			{
				Import.InitQueueEvent();
			}
			Init();
			UnityEngine.Debug.LogFormat("[3dRudder] SDK Version : {0:X4} / Package Version {1:X4}", GetSDKVersion(), _3DRUDDER_PACKAGE_VERSION);
		}

		public static ErrorCode Init()
		{
			ErrorCode errorCode = (ErrorCode)Import.Init();
			UnityEngine.Debug.LogFormat("[3dRudder] SDK Init : {0}[{1}]", errorCode, GetErrorText(errorCode));
			return errorCode;
		}

		public static ushort GetSDKVersion()
		{
			return Import.GetSDKVersion();
		}

		public static uint GetNumberOfConnectedDevice()
		{
			return Import.GetNumberOfConnectedDevice();
		}

		public static bool IsDeviceConnected(uint nPortNumber)
		{
			return Import.IsDeviceConnected(nPortNumber);
		}

		public static ushort GetVersion(uint nPortNumber)
		{
			return Import.GetFWVersion(nPortNumber);
		}

		public static ErrorCode HideSystemDevice(uint nPortNumber, bool bHide)
		{
			return Import.HideSystemDevice(nPortNumber, bHide);
		}

		public static bool IsSystemDeviceHidden(uint nPortNumber)
		{
			return Import.IsSystemDeviceHidden(nPortNumber);
		}

		public static ErrorCode PlaySnd(uint nPortNumber, ushort nFrequency, ushort nDuration)
		{
			return Import.PlaySnd(nPortNumber, nFrequency, nDuration);
		}

		public static ErrorCode PlaySndEx(uint nPortNumber, uint nSize, Tone sTones, bool bAddToPlayedList = true)
		{
			GCHandle gCHandle = GCHandle.Alloc(sTones, GCHandleType.Pinned);
			ErrorCode result = Import.PlaySndEx1(nPortNumber, nSize, gCHandle.AddrOfPinnedObject(), bAddToPlayedList);
			gCHandle.Free();
			return result;
		}

		public static ErrorCode PlaySndEx(uint nPortNumber, string sTones, bool bAddToPlayedList = true)
		{
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(sTones);
			ErrorCode result = Import.PlaySndEx2(nPortNumber, intPtr, bAddToPlayedList);
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public static ErrorCode GetUserOffset(uint nPortNumber, AxesValue sAxis)
		{
			GCHandle gCHandle = GCHandle.Alloc(sAxis, GCHandleType.Pinned);
			ErrorCode userOffset = Import.GetUserOffset(nPortNumber, gCHandle.AddrOfPinnedObject());
			gCHandle.Free();
			return userOffset;
		}

		public static ErrorCode GetAxes(uint nPortNumber, IAxesParam sAxesParam, AxesValue sAxes)
		{
			GCHandle gCHandle = GCHandle.Alloc(sAxes, GCHandleType.Pinned);
			if (sAxesParam == null)
			{
				ErrorCode axes = Import.GetAxes(nPortNumber, gCHandle.AddrOfPinnedObject(), IntPtr.Zero, null);
				gCHandle.Free();
				return axes;
			}
			sAxesParam.UpdateParam(nPortNumber);
			InternalAxesParam internalAxesParam = default(InternalAxesParam);
			GCHandle value = default(GCHandle);
			Curve curve = sAxesParam.GetCurve(Axes.LeftRight);
			if (curve == null)
			{
				internalAxesParam.m_bValidatedAxes1 = 0u;
			}
			else
			{
				internalAxesParam.m_fDeadZone1 = curve.DeadZone;
				internalAxesParam.m_fxSat1 = curve.XSat;
				internalAxesParam.m_fExp1 = curve.Exp;
				internalAxesParam.m_bValidatedAxes1 = 1u;
				value = GCHandle.Alloc(curve);
				internalAxesParam.m_handleCurveObject1 = (ulong)(long)GCHandle.ToIntPtr(value);
			}
			GCHandle value2 = default(GCHandle);
			Curve curve2 = sAxesParam.GetCurve(Axes.ForwardBackward);
			if (curve2 == null)
			{
				internalAxesParam.m_bValidatedAxes2 = 0u;
			}
			else
			{
				internalAxesParam.m_fDeadZone2 = curve2.DeadZone;
				internalAxesParam.m_fxSat2 = curve2.XSat;
				internalAxesParam.m_fExp2 = curve2.Exp;
				internalAxesParam.m_bValidatedAxes2 = 1u;
				value2 = GCHandle.Alloc(curve2);
				internalAxesParam.m_handleCurveObject2 = (ulong)(long)GCHandle.ToIntPtr(value2);
			}
			GCHandle value3 = default(GCHandle);
			Curve curve3 = sAxesParam.GetCurve(Axes.UpDown);
			if (curve3 == null)
			{
				internalAxesParam.m_bValidatedAxes3 = 0u;
			}
			else
			{
				internalAxesParam.m_fDeadZone3 = curve3.DeadZone;
				internalAxesParam.m_fxSat3 = curve3.XSat;
				internalAxesParam.m_fExp3 = curve3.Exp;
				internalAxesParam.m_bValidatedAxes3 = 1u;
				value3 = GCHandle.Alloc(curve3);
				internalAxesParam.m_handleCurveObject3 = (ulong)(long)GCHandle.ToIntPtr(value3);
			}
			GCHandle value4 = default(GCHandle);
			Curve curve4 = sAxesParam.GetCurve(Axes.Rotation);
			if (curve4 == null)
			{
				internalAxesParam.m_bValidatedAxes4 = 0u;
			}
			else
			{
				internalAxesParam.m_fDeadZone4 = curve4.DeadZone;
				internalAxesParam.m_fxSat4 = curve4.XSat;
				internalAxesParam.m_fExp4 = curve4.Exp;
				internalAxesParam.m_bValidatedAxes4 = 1u;
				value4 = GCHandle.Alloc(curve4);
				internalAxesParam.m_handleCurveObject4 = (ulong)(long)GCHandle.ToIntPtr(value4);
			}
			internalAxesParam.m_fRoll2YawCompensation = sAxesParam.Roll2YawCompensation;
			internalAxesParam.m_bNonSymmetrical = (sAxesParam.NonSymmetrical ? 1u : 0u);
			GCHandle gCHandle2 = GCHandle.Alloc(internalAxesParam, GCHandleType.Pinned);
			ErrorCode axes2 = Import.GetAxes(nPortNumber, gCHandle.AddrOfPinnedObject(), gCHandle2.AddrOfPinnedObject(), IAxesParam.CalcCurveValueCb);
			gCHandle.Free();
			gCHandle2.Free();
			if (value.IsAllocated)
			{
				value.Free();
			}
			if (value2.IsAllocated)
			{
				value2.Free();
			}
			if (value3.IsAllocated)
			{
				value3.Free();
			}
			if (value4.IsAllocated)
			{
				value4.Free();
			}
			return axes2;
		}

		public static Status GetStatus(uint nPortNumber)
		{
			return Import.GetStatus(nPortNumber);
		}

		public static ushort GetSensor(uint nPortNumber, uint nIndex)
		{
			return Import.GetSensor(nPortNumber, nIndex);
		}

		public static DeviceInformation GetDeviceInformation(uint nPortNumber)
		{
			IntPtr deviceInformation = Import.GetDeviceInformation(nPortNumber);
			if (deviceInformation == IntPtr.Zero)
			{
				return null;
			}
			DeviceInformation deviceInformation2 = new DeviceInformation();
			GCHandle gCHandle = GCHandle.Alloc(deviceInformation2, GCHandleType.Pinned);
			Import.MemCpy(gCHandle.AddrOfPinnedObject(), deviceInformation, Marshal.SizeOf(deviceInformation2));
			gCHandle.Free();
			return deviceInformation2;
		}

		public static ErrorCode SetFreeze(uint nPortNumber, bool bEnable)
		{
			return Import.SetFreeze(nPortNumber, bEnable);
		}

		public static bool IsFrozen(uint nPortNumber)
		{
			return Import.IsFrozen(nPortNumber);
		}

		public static ErrorCode GetLastError()
		{
			return Import.GetLastSdkError();
		}

		public static string GetErrorText(ErrorCode nError)
		{
			return Marshal.PtrToStringAnsi(Import.GetErrorText(nError));
		}

		public static void SetEvent(CallbackTypeConnect OnConnect, CallbackTypeConnect OnDisconnect, CallbackTypeConnect OnEndSound)
		{
			Import.Set3dREvent(OnConnect, OnDisconnect, OnEndSound);
		}

		public static EventData GetEventMessage()
		{
			IntPtr eventMessage = Import.GetEventMessage();
			EventData eventData = null;
			if (eventMessage != IntPtr.Zero)
			{
				eventData = new EventData();
				GCHandle gCHandle = GCHandle.Alloc(eventData, GCHandleType.Pinned);
				Import.MemCpy(gCHandle.AddrOfPinnedObject(), eventMessage, Marshal.SizeOf(eventData));
				gCHandle.Free();
			}
			return eventData;
		}

		public static float CalcCurveValue(float fDeadZone, float fxSat, float fExp, float fValue)
		{
			return Import.CalcCurveValue(fDeadZone, fxSat, fExp, fValue);
		}

		public static float CalcNonSymmetricalPitch(uint nPortNumber, float fNormalizedV, Curve sCurve)
		{
			GCHandle gCHandle = GCHandle.Alloc(sCurve, GCHandleType.Pinned);
			float result = Import.CalcNonSymmetricalPitch(nPortNumber, fNormalizedV, gCHandle.AddrOfPinnedObject());
			gCHandle.Free();
			return result;
		}

		public static ErrorCode Stop()
		{
			ErrorCode errorCode = Import.StopSDK();
			UnityEngine.Debug.LogFormat("[3dRudder] SDK Stop: {0}[{1}]", errorCode, GetErrorText(errorCode));
			return errorCode;
		}

		public static Vector3 GetAxes3D(AxesValue sAxis)
		{
			return new Vector3(sAxis.Get(Axes.LeftRight), sAxis.Get(Axes.UpDown), sAxis.Get(Axes.ForwardBackward));
		}
	}
	public class EventRudder
	{
		public static Action<uint> OnConnectEvent;

		public static Action<uint> OnDisconnectEvent;

		public static Action<uint> OnEndSoundEvent;

		[MonoPInvokeCallback(typeof(CallbackTypeConnect))]
		public static void OnConnect(uint nPortNumber)
		{
			if (OnConnectEvent != null)
			{
				OnConnectEvent(nPortNumber);
			}
		}

		[MonoPInvokeCallback(typeof(CallbackTypeConnect))]
		public static void OnDisconnect(uint nPortNumber)
		{
			if (OnDisconnectEvent != null)
			{
				OnDisconnectEvent(nPortNumber);
			}
		}

		[MonoPInvokeCallback(typeof(CallbackTypeConnect))]
		public static void OnEndSound(uint nPortNumber)
		{
			if (OnEndSoundEvent != null)
			{
				OnEndSoundEvent(nPortNumber);
			}
		}

		public void Dispose()
		{
			OnConnectEvent = null;
			OnDisconnectEvent = null;
			OnEndSoundEvent = null;
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class EventData
	{
		public enum TypeEVent
		{
			OnConnect,
			OnDisconnect,
			OnEndSound
		}

		public TypeEVent typeEvent;

		public uint portNumber;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class DeviceInformation
	{
		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName0;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName1;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName2;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName3;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName4;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName5;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName6;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName7;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName8;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName9;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName10;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName11;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName12;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName13;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName14;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName15;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName16;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName17;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName18;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName19;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName20;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName21;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName22;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName23;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName24;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName25;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName26;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName27;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName28;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName29;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName30;

		[MarshalAs(UnmanagedType.U1)]
		private byte m_sDeviceName31;

		[MarshalAs(UnmanagedType.U4)]
		private uint m_nSerialNumber;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fMaxRoll;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fMaxPitch;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fMaxYaw;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fUserRoll;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fUserPitch;

		[MarshalAs(UnmanagedType.R4)]
		private float m_fUserYaw;

		[MarshalAs(UnmanagedType.R4)]
		private float m_DefaultRoll2YawCompensation;

		public string GetName()
		{
			byte[] bytes = new byte[32]
			{
				m_sDeviceName0, m_sDeviceName1, m_sDeviceName2, m_sDeviceName3, m_sDeviceName4, m_sDeviceName5, m_sDeviceName6, m_sDeviceName7, m_sDeviceName8, m_sDeviceName9,
				m_sDeviceName10, m_sDeviceName11, m_sDeviceName12, m_sDeviceName13, m_sDeviceName14, m_sDeviceName15, m_sDeviceName16, m_sDeviceName17, m_sDeviceName18, m_sDeviceName19,
				m_sDeviceName20, m_sDeviceName21, m_sDeviceName22, m_sDeviceName23, m_sDeviceName24, m_sDeviceName25, m_sDeviceName26, m_sDeviceName27, m_sDeviceName28, m_sDeviceName29,
				m_sDeviceName30, m_sDeviceName31
			};
			return Encoding.Default.GetString(bytes);
		}

		public uint GetSerialNumber()
		{
			return m_nSerialNumber;
		}

		public void SetUserRoll(float nVal)
		{
			m_fUserRoll = nVal;
		}

		public void SetUserPitch(float nVal)
		{
			m_fUserPitch = nVal;
		}

		public void SetUserYaw(float nVal)
		{
			m_fUserYaw = nVal;
		}

		public float GetMaxRoll()
		{
			return m_fMaxRoll;
		}

		public float GetMaxPitch()
		{
			return m_fMaxPitch;
		}

		public float GetMaxYaw()
		{
			return m_fMaxYaw;
		}

		public float GetUserRoll()
		{
			return m_fUserRoll;
		}

		public float GetUserPitch()
		{
			return m_fUserPitch;
		}

		public float GetUserYaw()
		{
			return m_fUserYaw;
		}

		public float GetDefaultRoll2YawCompensation()
		{
			return m_DefaultRoll2YawCompensation;
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class AxesValue : IDisposable
	{
		[MarshalAs(UnmanagedType.R4)]
		private float m_Axes1;

		[MarshalAs(UnmanagedType.R4)]
		private float m_Axes2;

		[MarshalAs(UnmanagedType.R4)]
		private float m_Axes3;

		[MarshalAs(UnmanagedType.R4)]
		private float m_Axes4;

		~AxesValue()
		{
			Dispose();
		}

		public AxesValue()
		{
			m_Axes1 = 0f;
			m_Axes2 = 0f;
			m_Axes3 = 0f;
			m_Axes4 = 0f;
		}

		public float Get(Axes nAxis)
		{
			return nAxis switch
			{
				Axes.LeftRight => m_Axes1, 
				Axes.ForwardBackward => m_Axes2, 
				Axes.UpDown => m_Axes3, 
				Axes.Rotation => m_Axes4, 
				_ => 0f, 
			};
		}

		public virtual void Dispose()
		{
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class Curve : IDisposable
	{
		public float DeadZone;

		public float XSat;

		public float Exp;

		public Curve()
		{
			DeadZone = 0f;
			XSat = 1f;
			Exp = 1f;
		}

		public Curve(float fxSat, float fDeadZone, float fExp)
		{
			DeadZone = fDeadZone;
			XSat = fxSat;
			Exp = fExp;
		}

		~Curve()
		{
			Dispose();
		}

		public virtual float CalcCurveValue(float fValue)
		{
			return Sdk3dRudder.CalcCurveValue(DeadZone, XSat, Exp, fValue);
		}

		public virtual void Dispose()
		{
		}
	}
	[Serializable]
	public abstract class IAxesParam : ScriptableObject
	{
		[SerializeField]
		[HideInInspector]
		private Curve[] m_Curve;

		[HideInInspector]
		public float Roll2YawCompensation;

		[HideInInspector]
		public bool NonSymmetrical;

		public IAxesParam()
		{
			m_Curve = new Curve[4];
			for (int i = 0; i < 4; i++)
			{
				m_Curve[i] = null;
			}
			Roll2YawCompensation = 0.15f;
			NonSymmetrical = false;
		}

		public virtual ErrorCode UpdateParam(uint nPortNumber)
		{
			return ErrorCode.Success;
		}

		public Curve GetCurve(Axes nCurve)
		{
			if (nCurve >= Axes.LeftRight && nCurve < Axes.MaxAxes)
			{
				return m_Curve[(int)nCurve];
			}
			return null;
		}

		public void SetCurve(Axes nCurve, Curve pCurve)
		{
			if (nCurve >= Axes.LeftRight && nCurve < Axes.MaxAxes)
			{
				m_Curve[(int)nCurve] = pCurve;
			}
		}

		public void SetCurves(Curve[] curves)
		{
			if (curves.Length == 4)
			{
				m_Curve = curves;
			}
		}

		public void NoUpDown()
		{
			SetCurve(Axes.UpDown, null);
		}

		[MonoPInvokeCallback(typeof(CalcCurveValue_t))]
		public static float CalcCurveValueCb(IntPtr pCurve, float fVal)
		{
			return ((Curve)GCHandle.FromIntPtr(pCurve).Target).CalcCurveValue(fVal);
		}
	}
	public struct InternalAxesParam
	{
		[MarshalAs(UnmanagedType.R4)]
		public float m_fDeadZone1;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fDeadZone2;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fDeadZone3;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fDeadZone4;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fxSat1;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fxSat2;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fxSat3;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fxSat4;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fExp1;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fExp2;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fExp3;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fExp4;

		[MarshalAs(UnmanagedType.U8)]
		public ulong m_handleCurveObject1;

		[MarshalAs(UnmanagedType.U8)]
		public ulong m_handleCurveObject2;

		[MarshalAs(UnmanagedType.U8)]
		public ulong m_handleCurveObject3;

		[MarshalAs(UnmanagedType.U8)]
		public ulong m_handleCurveObject4;

		[MarshalAs(UnmanagedType.U4)]
		public uint m_bValidatedAxes1;

		[MarshalAs(UnmanagedType.U4)]
		public uint m_bValidatedAxes2;

		[MarshalAs(UnmanagedType.U4)]
		public uint m_bValidatedAxes3;

		[MarshalAs(UnmanagedType.U4)]
		public uint m_bValidatedAxes4;

		[MarshalAs(UnmanagedType.R4)]
		public float m_fRoll2YawCompensation;

		[MarshalAs(UnmanagedType.U4)]
		public uint m_bNonSymmetrical;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class Tone : IDisposable
	{
		public ushort Frequency { get; private set; }

		public ushort DurationOfTone { get; private set; }

		public ushort PauseAfterTone { get; private set; }

		~Tone()
		{
			Dispose();
		}

		public Tone()
		{
			Frequency = 440;
			DurationOfTone = 50;
			PauseAfterTone = 50;
		}

		public Tone(ushort nFrequency, ushort nDurationOfTone, ushort nPauseAfterTone)
		{
			Frequency = nFrequency;
			DurationOfTone = nDurationOfTone;
			PauseAfterTone = nPauseAfterTone;
		}

		public virtual void Dispose()
		{
		}
	}
	[Serializable]
	public class SmoothMovement
	{
		public bool Enable;

		[Range(0.1f, 1f)]
		public float Smoothness;

		private float CurrentSpeed;

		public SmoothMovement()
		{
			Enable = false;
			Smoothness = 0.15f;
			CurrentSpeed = 0f;
		}

		public float ComputeSpeed(float input, float deltatime)
		{
			float num = (input - CurrentSpeed) / Smoothness;
			CurrentSpeed += num * deltatime;
			return CurrentSpeed;
		}
	}
}
