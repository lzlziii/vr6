using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using RootMotion.FinalIK;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;

[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace FluffyUnderware.Curvy.Generator
{
	public abstract class SplineInputModuleBase : CGModule
	{
		[Tab("General")]
		[SerializeField]
		[Tooltip("Makes this module use the cached approximations of the spline's positions and tangents")]
		private bool m_UseCache;

		[Tooltip("Whether to use local or global coordinates of the input's control points.\r\nUsing the global space when the input's transform is updating every frame will lead to the generator refreshing too frequently")]
		[SerializeField]
		private bool m_UseGlobalSpace;

		[Tab("Range")]
		[SerializeField]
		protected CurvySplineSegment m_StartCP;

		[FieldCondition("m_StartCP", null, true, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		protected CurvySplineSegment m_EndCP;

		public bool UseCache
		{
			get
			{
				return m_UseCache;
			}
			set
			{
				if (m_UseCache != value)
				{
					m_UseCache = value;
				}
				base.Dirty = true;
			}
		}

		public CurvySplineSegment StartCP
		{
			get
			{
				return m_StartCP;
			}
			set
			{
				if (m_StartCP != value)
				{
					m_StartCP = value;
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public CurvySplineSegment EndCP
		{
			get
			{
				return m_EndCP;
			}
			set
			{
				if (m_EndCP != value)
				{
					m_EndCP = value;
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool UseGlobalSpace
		{
			get
			{
				return m_UseGlobalSpace;
			}
			set
			{
				m_UseGlobalSpace = value;
				base.Dirty = true;
			}
		}

		public override bool IsConfigured => base.IsConfigured && InputSpline != null;

		public override bool IsInitialized => base.IsInitialized && (InputSpline == null || InputSpline.IsInitialized);

		public float PathLength => (!IsConfigured) ? 0f : getPathLength(InputSpline);

		public bool PathIsClosed => IsConfigured && getPathClosed(InputSpline);

		protected abstract CurvySpline InputSpline { get; set; }

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			OnSplineAssigned();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if ((bool)InputSpline)
			{
				InputSpline.OnRefresh.RemoveListener(OnSplineRefreshed);
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Remove(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		public override void Reset()
		{
			base.Reset();
			InputSpline = null;
			UseCache = false;
			StartCP = null;
			EndCP = null;
			UseGlobalSpace = false;
		}

		private void OnSplineRefreshed(CurvySplineEventArgs e)
		{
			if (base.enabled && base.gameObject.activeInHierarchy)
			{
				if (InputSpline == e.Spline)
				{
					ForceRefresh();
				}
				else
				{
					e.Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
				}
			}
		}

		private void OnInputSplineCoordinatesChanged(CurvySpline sender)
		{
			if (!base.enabled || !base.gameObject.activeInHierarchy)
			{
				return;
			}
			if (InputSpline == sender)
			{
				if (UseGlobalSpace)
				{
					ForceRefresh();
				}
			}
			else
			{
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Remove(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		private void ForceRefresh()
		{
			base.Dirty = true;
		}

		private float getPathLength(CurvySpline spline)
		{
			if (!spline)
			{
				return 0f;
			}
			if ((bool)StartCP && (bool)EndCP)
			{
				return EndCP.Distance - StartCP.Distance;
			}
			return spline.Length;
		}

		private bool getPathClosed(CurvySpline spline)
		{
			if (!spline || !spline.Closed)
			{
				return false;
			}
			return EndCP == null;
		}

		protected CGData GetSplineData(CurvySpline spline, bool fullPath, CGDataRequestRasterization raster, CGDataRequestMetaCGOptions options)
		{
			if (spline == null || spline.Count == 0)
			{
				return null;
			}
			List<ControlPointOption> list = new List<ControlPointOption>();
			int initialMaterialID = 0;
			float initialMaxStep = float.MaxValue;
			CGShape cGShape = ((!fullPath) ? new CGShape() : new CGPath());
			float num;
			float num2;
			if ((bool)StartCP)
			{
				float pathLength = getPathLength(spline);
				num = StartCP.Distance + pathLength * raster.Start;
				num2 = StartCP.Distance + pathLength * (raster.Start + raster.RasterizedRelativeLength);
			}
			else
			{
				num = spline.Length * raster.Start;
				num2 = spline.Length * (raster.Start + raster.RasterizedRelativeLength);
			}
			float num3 = CurvySpline.CalculateSamplingPointsPerUnit(raster.Resolution, spline.MaxPointsPerUnit);
			float num4 = (num2 - num) / (raster.SplineAbsoluteLength * raster.RasterizedRelativeLength * num3);
			cGShape.Length = num2 - num;
			float tf = spline.DistanceToTF(num);
			float startTF = tf;
			float num5 = ((!(num2 > spline.Length) || !spline.Closed) ? spline.DistanceToTF(num2) : (spline.DistanceToTF(num2 - spline.Length) + 1f));
			cGShape.SourceIsManaged = IsManagedResource(spline);
			cGShape.Closed = spline.Closed;
			cGShape.Seamless = spline.Closed && raster.RasterizedRelativeLength == 1f;
			if (cGShape.Length == 0f)
			{
				return cGShape;
			}
			if ((bool)options)
			{
				list = CGUtility.GetControlPointsWithOptions(options, spline, num, num2, raster.Mode == CGDataRequestRasterization.ModeEnum.Optimized, out initialMaterialID, out initialMaxStep);
			}
			List<SamplePointUData> list2 = new List<SamplePointUData>();
			List<Vector3> list3 = new List<Vector3>();
			List<float> list4 = new List<float>();
			List<float> list5 = new List<float>();
			List<Vector3> list6 = new List<Vector3>();
			List<Vector3> list7 = new List<Vector3>();
			float num6 = num;
			Vector3 tangent = Vector3.zero;
			Vector3 up = Vector3.zero;
			List<int> list8 = new List<int>();
			int num7 = 100000;
			switch (raster.Mode)
			{
			case CGDataRequestRasterization.ModeEnum.Even:
			{
				bool flag = false;
				SamplePointsMaterialGroup samplePointsMaterialGroup = new SamplePointsMaterialGroup(initialMaterialID);
				SamplePointsPatch item = new SamplePointsPatch(0);
				CurvyClamping clamping = (cGShape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
				while (num6 <= num2 && --num7 > 0)
				{
					tf = spline.DistanceToTF(spline.ClampDistance(num6, clamping));
					float num8 = (num6 - num) / cGShape.Length;
					if (Mathf.Approximately(1f, num8))
					{
						num8 = 1f;
					}
					float localF;
					CurvySplineSegment curvySplineSegment = spline.TFToSegment(tf, out localF, CurvyClamping.Clamp);
					Vector3 pos = ((!UseCache) ? curvySplineSegment.Interpolate(localF, spline.Interpolation) : curvySplineSegment.InterpolateFast(localF));
					if (fullPath)
					{
						tangent = ((!UseCache) ? curvySplineSegment.GetTangent(localF, pos) : curvySplineSegment.GetTangentFast(localF));
						up = curvySplineSegment.GetOrientationUpFast(localF);
					}
					AddPoint(num6 / spline.Length, num8, fullPath, pos, tangent, up, list5, list4, list3, list6, list7);
					if (flag)
					{
						AddPoint(num6 / spline.Length, num8, fullPath, pos, tangent, up, list5, list4, list3, list6, list7);
						flag = false;
					}
					num6 += num4;
					if (list.Count > 0 && num6 >= list[0].Distance)
					{
						if (list[0].UVEdge || list[0].UVShift)
						{
							list2.Add(new SamplePointUData(list3.Count, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
						}
						num6 = list[0].Distance;
						flag = list[0].HardEdge || list[0].MaterialID != samplePointsMaterialGroup.MaterialID || (options.CheckExtendedUV && list[0].UVEdge);
						if (flag)
						{
							item.End = list3.Count;
							samplePointsMaterialGroup.Patches.Add(item);
							if (samplePointsMaterialGroup.MaterialID != list[0].MaterialID)
							{
								cGShape.MaterialGroups.Add(samplePointsMaterialGroup);
								samplePointsMaterialGroup = new SamplePointsMaterialGroup(list[0].MaterialID);
							}
							item = new SamplePointsPatch(list3.Count + 1);
							if (!list[0].HardEdge)
							{
								list8.Add(list3.Count + 1);
							}
							if (list[0].UVEdge || list[0].UVShift)
							{
								list2.Add(new SamplePointUData(list3.Count + 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
							}
						}
						list.RemoveAt(0);
					}
					if (num6 > num2 && num8 < 1f)
					{
						num6 = num2;
					}
				}
				if (num7 <= 0)
				{
					Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Even)! Please send a bug report.");
				}
				item.End = list3.Count - 1;
				samplePointsMaterialGroup.Patches.Add(item);
				if (cGShape.Closed && !spline[0].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge)
				{
					list8.Add(0);
				}
				FillData(cGShape, samplePointsMaterialGroup, list5, list4, fullPath, list3, list6, list7, spline.Bounds, UseGlobalSpace, spline.transform, base.Generator.transform);
				break;
			}
			case CGDataRequestRasterization.ModeEnum.Optimized:
			{
				bool flag = false;
				SamplePointsMaterialGroup samplePointsMaterialGroup = new SamplePointsMaterialGroup(initialMaterialID);
				SamplePointsPatch item = new SamplePointsPatch(0);
				float stepDist = num4 / spline.Length;
				float angleThreshold = raster.AngleThreshold;
				Vector3 pos = ((!UseCache) ? spline.Interpolate(tf) : spline.InterpolateFast(tf));
				tangent = ((!UseCache) ? spline.GetTangent(tf, pos) : spline.GetTangentFast(tf));
				while (tf < num5 && num7-- > 0)
				{
					AddPoint(num6 / spline.Length, (num6 - num) / cGShape.Length, fullPath, pos, tangent, spline.GetOrientationUpFast(tf % 1f), list5, list4, list3, list6, list7);
					float stopTF = ((list.Count <= 0) ? num5 : list[0].TF);
					bool flag2 = MoveByAngleExt(spline, UseCache, ref tf, initialMaxStep, angleThreshold, out pos, out tangent, stopTF, cGShape.Closed, stepDist);
					num6 = spline.TFToDistance(tf);
					if (Mathf.Approximately(tf, num5) || tf > num5)
					{
						num6 = num2;
						num5 = ((!cGShape.Closed) ? Mathf.Clamp01(num5) : DTMath.Repeat(num5, 1f));
						pos = ((!UseCache) ? spline.Interpolate(num5) : spline.InterpolateFast(num5));
						if (fullPath)
						{
							tangent = ((!UseCache) ? spline.GetTangent(num5, pos) : spline.GetTangentFast(num5));
						}
						AddPoint(num6 / spline.Length, (num6 - num) / cGShape.Length, fullPath, pos, tangent, spline.GetOrientationUpFast(num5), list5, list4, list3, list6, list7);
						break;
					}
					if (!flag2)
					{
						continue;
					}
					if (list.Count > 0)
					{
						if (list[0].UVEdge || list[0].UVShift)
						{
							list2.Add(new SamplePointUData(list3.Count, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
						}
						num6 = list[0].Distance;
						initialMaxStep = list[0].MaxStepDistance;
						if (list[0].HardEdge || list[0].MaterialID != samplePointsMaterialGroup.MaterialID || (options.CheckExtendedUV && list[0].UVEdge))
						{
							item.End = list3.Count;
							samplePointsMaterialGroup.Patches.Add(item);
							if (samplePointsMaterialGroup.MaterialID != list[0].MaterialID)
							{
								cGShape.MaterialGroups.Add(samplePointsMaterialGroup);
								samplePointsMaterialGroup = new SamplePointsMaterialGroup(list[0].MaterialID);
							}
							item = new SamplePointsPatch(list3.Count + 1);
							if (!list[0].HardEdge)
							{
								list8.Add(list3.Count + 1);
							}
							if (list[0].UVEdge || list[0].UVShift)
							{
								list2.Add(new SamplePointUData(list3.Count + 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
							}
							AddPoint(num6 / spline.Length, (num6 - num) / cGShape.Length, fullPath, pos, tangent, spline.GetOrientationUpFast(tf), list5, list4, list3, list6, list7);
						}
						list.RemoveAt(0);
						continue;
					}
					AddPoint(num6 / spline.Length, (num6 - num) / cGShape.Length, fullPath, pos, tangent, spline.GetOrientationUpFast(tf), list5, list4, list3, list6, list7);
					break;
				}
				if (num7 <= 0)
				{
					Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Optimized)! Please send a bug report.");
				}
				item.End = list3.Count - 1;
				samplePointsMaterialGroup.Patches.Add(item);
				if (list.Count > 0 && list[0].UVShift)
				{
					list2.Add(new SamplePointUData(list3.Count - 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
				}
				if (cGShape.Closed && !spline[0].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge)
				{
					list8.Add(0);
				}
				FillData(cGShape, samplePointsMaterialGroup, list5, list4, fullPath, list3, list6, list7, spline.Bounds, UseGlobalSpace, spline.transform, base.Generator.transform);
				break;
			}
			}
			cGShape.Map = (float[])cGShape.F.Clone();
			if (!fullPath)
			{
				cGShape.RecalculateNormals(list8);
				if ((bool)options && options.CheckExtendedUV)
				{
					CalculateExtendedUV(spline, startTF, num5, list2, cGShape);
				}
			}
			return cGShape;
		}

		private static void FillData(CGShape dataToFill, SamplePointsMaterialGroup materialGroup, List<float> sourceFs, List<float> relativeFs, bool isFullPath, List<Vector3> positions, List<Vector3> tangents, List<Vector3> normals, Bounds bounds, bool considerSplineTransform, Transform splineTransform, Transform generatorTransform)
		{
			if (considerSplineTransform)
			{
				for (int i = 0; i < positions.Count; i++)
				{
					positions[i] = generatorTransform.InverseTransformPoint(splineTransform.TransformPoint(positions[i]));
				}
				for (int j = 0; j < tangents.Count; j++)
				{
					tangents[j] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(tangents[j]));
				}
				for (int k = 0; k < normals.Count; k++)
				{
					normals[k] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(normals[k]));
				}
			}
			dataToFill.MaterialGroups.Add(materialGroup);
			dataToFill.SourceF = sourceFs.ToArray();
			dataToFill.F = relativeFs.ToArray();
			dataToFill.Position = positions.ToArray();
			dataToFill.Bounds = bounds;
			if (isFullPath)
			{
				((CGPath)dataToFill).Direction = tangents.ToArray();
				dataToFill.Normal = normals.ToArray();
			}
		}

		private static void AddPoint(float sourceF, float relativeF, bool isFullPath, Vector3 position, Vector3 tangent, Vector3 up, List<float> sourceFList, List<float> relativeFList, List<Vector3> positionList, List<Vector3> tangentList, List<Vector3> upList)
		{
			sourceFList.Add(sourceF);
			positionList.Add(position);
			relativeFList.Add(relativeF);
			if (isFullPath)
			{
				tangentList.Add(tangent);
				upList.Add(up);
			}
		}

		private static bool MoveByAngleExt(CurvySpline spline, bool useCache, ref float tf, float maxDistance, float maxAngle, out Vector3 pos, out Vector3 tan, float stopTF, bool loop, float stepDist)
		{
			if (!loop)
			{
				tf = Mathf.Clamp01(tf);
			}
			float tf2 = ((!loop) ? tf : (tf % 1f));
			GetPositionAndTangent(spline, useCache, out pos, out tan, tf2);
			Vector3 vector = pos;
			Vector3 from = tan;
			float num = 0f;
			float num2 = 0f;
			if (stopTF < tf && loop)
			{
				stopTF += 1f;
			}
			bool flag = false;
			Vector3 vector2 = default(Vector3);
			while (tf < stopTF && !flag)
			{
				tf = Mathf.Min(stopTF, tf + stepDist);
				tf2 = ((!loop) ? tf : (tf % 1f));
				GetPositionAndTangent(spline, useCache, out pos, out tan, tf2);
				vector2.x = pos.x - vector.x;
				vector2.y = pos.y - vector.y;
				vector2.z = pos.z - vector.z;
				num += vector2.magnitude;
				float num3 = Vector3.Angle(from, tan);
				num2 += num3;
				if (num >= maxDistance || num2 >= maxAngle || (num3 == 0f && num2 > 0f))
				{
					flag = true;
					continue;
				}
				vector = pos;
				from = tan;
			}
			return Mathf.Approximately(tf, stopTF);
		}

		private static void GetPositionAndTangent(CurvySpline spline, bool useCache, out Vector3 position, out Vector3 tangent, float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = spline.TFToSegment(tf, out localF, CurvyClamping.Clamp);
			if (useCache)
			{
				position = curvySplineSegment.InterpolateFast(localF);
				tangent = curvySplineSegment.GetTangentFast(localF);
			}
			else
			{
				position = curvySplineSegment.Interpolate(localF, spline.Interpolation);
				tangent = curvySplineSegment.GetTangent(localF, position);
			}
		}

		private void CalculateExtendedUV(CurvySpline spline, float startTF, float endTF, List<SamplePointUData> ext, CGShape data)
		{
			MetaCGOptions metaCGOptions = findPreviousReferenceCPOptions(spline, startTF, out var cp);
			MetaCGOptions metaCGOptions2 = findNextReferenceCPOptions(spline, startTF, out var cp2);
			ext.Insert(0, new SamplePointUData(uv0: ((!(spline.FirstVisibleControlPoint == cp2)) ? ((data.SourceF[0] * spline.Length - cp.Distance) / (cp2.Distance - cp.Distance)) : ((data.SourceF[0] * spline.Length - cp.Distance) / (spline.Length - cp.Distance))) * (metaCGOptions2.FirstU - metaCGOptions.GetDefinedFirstU(0f)) + metaCGOptions.GetDefinedFirstU(0f), vt: 0, uvEdge: startTF == 0f && metaCGOptions.UVEdge, uv1: (startTF != 0f || !metaCGOptions.UVEdge) ? 0f : metaCGOptions.SecondU));
			if (ext[ext.Count - 1].Vertex < data.Count - 1)
			{
				metaCGOptions = findPreviousReferenceCPOptions(spline, endTF, out cp);
				metaCGOptions2 = findNextReferenceCPOptions(spline, endTF, out cp2);
				float num = metaCGOptions2.FirstU;
				float definedSecondU = metaCGOptions.GetDefinedSecondU(0f);
				float num2;
				if (spline.FirstVisibleControlPoint == cp2)
				{
					num2 = (data.SourceF[data.Count - 1] * spline.Length - cp.Distance) / (spline.Length - cp.Distance);
					num = (metaCGOptions2.UVEdge ? metaCGOptions2.FirstU : ((ext.Count <= 1) ? 1f : ((float)(Mathf.FloorToInt((!ext[ext.Count - 1].UVEdge) ? ext[ext.Count - 1].FirstU : ext[ext.Count - 1].SecondU) + 1))));
				}
				else
				{
					num2 = (data.SourceF[data.Count - 1] * spline.Length - cp.Distance) / (cp2.Distance - cp.Distance);
				}
				ext.Add(new SamplePointUData(data.Count - 1, uvEdge: false, num2 * (num - definedSecondU) + definedSecondU, 0f));
			}
			float num3 = 0f;
			float num4 = ((!ext[0].UVEdge) ? ext[0].FirstU : ext[0].SecondU);
			float firstU = ext[1].FirstU;
			float num5 = data.F[ext[1].Vertex] - data.F[ext[0].Vertex];
			int num6 = 1;
			for (int i = 0; i < data.Count - 1; i++)
			{
				float num7 = (data.F[i] - num3) / num5;
				data.Map[i] = (firstU - num4) * num7 + num4;
				if (ext[num6].Vertex == i)
				{
					if (ext[num6].FirstU == ext[num6 + 1].FirstU)
					{
						num4 = ((!ext[num6].UVEdge) ? ext[num6].FirstU : ext[num6].SecondU);
						num6++;
					}
					else
					{
						num4 = ext[num6].FirstU;
					}
					firstU = ext[num6 + 1].FirstU;
					num5 = data.F[ext[num6 + 1].Vertex] - data.F[ext[num6].Vertex];
					num3 = data.F[i];
					num6++;
				}
			}
			data.Map[data.Count - 1] = ext[ext.Count - 1].FirstU;
		}

		private static MetaCGOptions findPreviousReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
		{
			cp = spline.TFToSegment(tf);
			MetaCGOptions metadata;
			do
			{
				metadata = cp.GetMetadata<MetaCGOptions>(autoCreate: true);
				if (spline.FirstVisibleControlPoint == cp)
				{
					return metadata;
				}
				cp = spline.GetPreviousSegment(cp);
			}
			while ((bool)cp && !metadata.UVEdge && !metadata.ExplicitU && !metadata.HasDifferentMaterial);
			return metadata;
		}

		private static MetaCGOptions findNextReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
		{
			cp = spline.TFToSegment(tf, out var _);
			MetaCGOptions metadata;
			do
			{
				cp = spline.GetNextControlPoint(cp);
				metadata = cp.GetMetadata<MetaCGOptions>(autoCreate: true);
				if (!spline.Closed && spline.LastVisibleControlPoint == cp)
				{
					return metadata;
				}
			}
			while (!metadata.UVEdge && !metadata.ExplicitU && !metadata.HasDifferentMaterial && !(spline.FirstSegment == cp));
			return metadata;
		}

		protected virtual void OnSplineAssigned()
		{
			if ((bool)InputSpline)
			{
				InputSpline.OnRefresh.AddListenerOnce(OnSplineRefreshed);
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Combine(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		protected void ValidateStartAndEndCps()
		{
			if (!(InputSpline == null))
			{
				if ((bool)m_StartCP && m_StartCP.Spline != InputSpline)
				{
					m_StartCP = null;
				}
				if ((bool)m_EndCP && m_EndCP.Spline != InputSpline)
				{
					m_EndCP = null;
				}
				if (InputSpline.IsInitialized && m_EndCP != null && m_StartCP != null && InputSpline.GetControlPointIndex(m_EndCP) <= InputSpline.GetControlPointIndex(m_StartCP))
				{
					m_EndCP = null;
				}
			}
		}
	}
	public class TRSModuleBase : CGModule
	{
		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Transpose;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public Vector3 Transpose
		{
			get
			{
				return m_Transpose;
			}
			set
			{
				if (m_Transpose != value)
				{
					m_Transpose = value;
				}
				base.Dirty = true;
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
				base.Dirty = true;
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
				base.Dirty = true;
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Transpose, Quaternion.Euler(Rotation), Scale);

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 200f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Transpose = Vector3.zero;
			Rotation = Vector3.zero;
			Scale = Vector3.one;
		}
	}
}
namespace FluffyUnderware.Curvy.Generator.Modules
{
	[ModuleInfo("Build/Rasterize Path", ModuleName = "Rasterize Path", Description = "Rasterizes a virtual path")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildrasterizedpath")]
	public class BuildRasterizedPath : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path", RequestDataOnly = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath), Name = "Path", DisplayName = "Rasterized Path")]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_Resolution = 50;

		[SerializeField]
		private bool m_Optimize;

		[FieldCondition("m_Optimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "", "")]
		private float m_AngleTreshold = 10f;

		public float From
		{
			get
			{
				return m_Range.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_Range.From != num)
				{
					m_Range.From = num;
				}
				base.Dirty = true;
			}
		}

		public float To
		{
			get
			{
				return m_Range.To;
			}
			set
			{
				float num = Mathf.Max(From, value);
				if (PathIsClosed)
				{
					num = Mathf.Repeat(value, 1f);
				}
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public float Length
		{
			get
			{
				return (!PathIsClosed) ? m_Range.To : (m_Range.To - m_Range.From);
			}
			set
			{
				float num = ((!PathIsClosed) ? value : (value - m_Range.To));
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public int Resolution
		{
			get
			{
				return m_Resolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_Resolution != num)
				{
					m_Resolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool Optimize
		{
			get
			{
				return m_Optimize;
			}
			set
			{
				if (m_Optimize != value)
				{
					m_Optimize = value;
				}
				base.Dirty = true;
			}
		}

		public float AngleThreshold
		{
			get
			{
				return m_AngleTreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_AngleTreshold != num)
				{
					m_AngleTreshold = num;
				}
				base.Dirty = true;
			}
		}

		public CGPath Path => OutPath.GetData<CGPath>();

		public bool PathIsClosed => !IsConfigured || InPath.SourceSlot().OnRequestPathModule.PathIsClosed;

		private RegionOptions<float> RangeOptions
		{
			get
			{
				if (!PathIsClosed)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 100f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Range = FloatRegion.ZeroOne;
			Resolution = 50;
			AngleThreshold = 10f;
			OutPath.ClearData();
			Optimize = false;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (Length == 0f)
			{
				Reset();
				return;
			}
			List<CGDataRequestParameter> list = new List<CGDataRequestParameter>();
			list.Add(new CGDataRequestRasterization(From, Length, Resolution, InPath.SourceSlot().OnRequestPathModule.PathLength, AngleThreshold, Optimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			CGPath data = InPath.GetData<CGPath>(list.ToArray());
			OutPath.SetData(data);
		}
	}
	[ModuleInfo("Build/Shape Extrusion", ModuleName = "Shape Extrusion", Description = "Simple Shape Extrusion")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildshapeextrusion")]
	public class BuildShapeExtrusion : CGModule
	{
		public enum ScaleModeEnum
		{
			Simple,
			Advanced
		}

		public enum CrossShiftModeEnum
		{
			None,
			ByOrientation,
			Custom
		}

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, RequestDataOnly = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, RequestDataOnly = true)]
		public CGModuleInputSlot InCross = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVolume))]
		public CGModuleOutputSlot OutVolume = new CGModuleOutputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVolume))]
		public CGModuleOutputSlot OutVolumeHollow = new CGModuleOutputSlot();

		[Tab("Path")]
		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_Resolution = 50;

		[SerializeField]
		private bool m_Optimize = true;

		[FieldCondition("m_Optimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "", "", Tooltip = "Max angle")]
		private float m_AngleThreshold = 10f;

		[Tab("Cross")]
		[FieldAction("CBEditCrossButton", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Above)]
		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "CrossRangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_CrossRange = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "", Tooltip = "Defines how densely the cross spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_CrossResolution = 50;

		[SerializeField]
		[Label("Optimize", "")]
		private bool m_CrossOptimize = true;

		[FieldCondition("m_CrossOptimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "Angle Threshold", "", Tooltip = "Max angle")]
		private float m_CrossAngleThreshold = 10f;

		[SerializeField]
		[Label("Include CP", "")]
		private bool m_CrossIncludeControlpoints;

		[SerializeField]
		[Label("Hard Edges", "")]
		private bool m_CrossHardEdges;

		[SerializeField]
		[Label("Materials", "")]
		private bool m_CrossMaterials;

		[SerializeField]
		[Label("Extended UV", "")]
		private bool m_CrossExtendedUV;

		[SerializeField]
		[Label("Shift", "", Tooltip = "Defines a shift to be applied on the output volume's cross.\r\nThis shift is used when interpolating values (position, normal, ...) along the volume's surface.")]
		private CrossShiftModeEnum m_CrossShiftMode = CrossShiftModeEnum.ByOrientation;

		[SerializeField]
		[RangeEx(0f, 1f, "Value", "Shift By", Slider = true)]
		[FieldCondition("m_CrossShiftMode", CrossShiftModeEnum.Custom, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private float m_CrossShiftValue;

		[Label("Reverse Normal", "Reverse Vertex Normals?")]
		[SerializeField]
		private bool m_CrossReverseNormals;

		[Tab("Scale")]
		[Label("Mode", "")]
		[SerializeField]
		private ScaleModeEnum m_ScaleMode;

		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Label("Reference", "")]
		[SerializeField]
		private CGReferenceMode m_ScaleReference = CGReferenceMode.Self;

		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Label("Offset", "")]
		[SerializeField]
		private float m_ScaleOffset;

		[SerializeField]
		[Label("Uniform", "", Tooltip = "Use a single curve")]
		private bool m_ScaleUniform = true;

		[SerializeField]
		private float m_ScaleX = 1f;

		[SerializeField]
		[FieldCondition("m_ScaleUniform", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private float m_ScaleY = 1f;

		[SerializeField]
		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[AnimationCurveEx("Multiplier X", "")]
		[Tooltip("Defines scale multiplier depending on the TF, the relative position of a point on the path")]
		private AnimationCurve m_ScaleCurveX = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		[FieldCondition("m_ScaleUniform", false, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_ScaleMode", ScaleModeEnum.Advanced, false)]
		[AnimationCurveEx("Multiplier Y", "")]
		[Tooltip("Defines scale multiplier depending on the TF, the relative position of a point on the path")]
		private AnimationCurve m_ScaleCurveY = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[Tab("Hollow")]
		[RangeEx(0f, 1f, "", "", Slider = true, Label = "Inset")]
		[SerializeField]
		private float m_HollowInset;

		[Label("Reverse Normal", "Reverse Vertex Normals?")]
		[SerializeField]
		private bool m_HollowReverseNormals;

		public float From
		{
			get
			{
				return m_Range.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_Range.From != num)
				{
					m_Range.From = num;
				}
				base.Dirty = true;
			}
		}

		public float To
		{
			get
			{
				return m_Range.To;
			}
			set
			{
				float num = Mathf.Max(From, value);
				if (ClampPath)
				{
					num = DTMath.Repeat(value, 1f);
				}
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public float Length
		{
			get
			{
				return (!ClampPath) ? m_Range.To : (m_Range.To - m_Range.From);
			}
			set
			{
				float num = ((!ClampPath) ? value : (value - m_Range.To));
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public int Resolution
		{
			get
			{
				return m_Resolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_Resolution != num)
				{
					m_Resolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool Optimize
		{
			get
			{
				return m_Optimize;
			}
			set
			{
				if (m_Optimize != value)
				{
					m_Optimize = value;
				}
				base.Dirty = true;
			}
		}

		public float AngleThreshold
		{
			get
			{
				return m_AngleThreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_AngleThreshold != num)
				{
					m_AngleThreshold = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossFrom
		{
			get
			{
				return m_CrossRange.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossRange.From != num)
				{
					m_CrossRange.From = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossTo
		{
			get
			{
				return m_CrossRange.To;
			}
			set
			{
				float num = Mathf.Max(CrossFrom, value);
				if (ClampCross)
				{
					num = DTMath.Repeat(value, 1f);
				}
				if (m_CrossRange.To != num)
				{
					m_CrossRange.To = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossLength
		{
			get
			{
				return (!ClampCross) ? m_CrossRange.To : (m_CrossRange.To - m_CrossRange.From);
			}
			set
			{
				float num = ((!ClampCross) ? value : (value - m_CrossRange.To));
				if (m_CrossRange.To != num)
				{
					m_CrossRange.To = num;
				}
				base.Dirty = true;
			}
		}

		public int CrossResolution
		{
			get
			{
				return m_CrossResolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_CrossResolution != num)
				{
					m_CrossResolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossOptimize
		{
			get
			{
				return m_CrossOptimize;
			}
			set
			{
				if (m_CrossOptimize != value)
				{
					m_CrossOptimize = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossAngleThreshold
		{
			get
			{
				return m_CrossAngleThreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_CrossAngleThreshold != num)
				{
					m_CrossAngleThreshold = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossIncludeControlPoints
		{
			get
			{
				return m_CrossIncludeControlpoints;
			}
			set
			{
				if (m_CrossIncludeControlpoints != value)
				{
					m_CrossIncludeControlpoints = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossHardEdges
		{
			get
			{
				return m_CrossHardEdges;
			}
			set
			{
				if (m_CrossHardEdges != value)
				{
					m_CrossHardEdges = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossMaterials
		{
			get
			{
				return m_CrossMaterials;
			}
			set
			{
				if (m_CrossMaterials != value)
				{
					m_CrossMaterials = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossExtendedUV
		{
			get
			{
				return m_CrossExtendedUV;
			}
			set
			{
				if (m_CrossExtendedUV != value)
				{
					m_CrossExtendedUV = value;
				}
				base.Dirty = true;
			}
		}

		public CrossShiftModeEnum CrossShiftMode
		{
			get
			{
				return m_CrossShiftMode;
			}
			set
			{
				if (m_CrossShiftMode != value)
				{
					m_CrossShiftMode = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossShiftValue
		{
			get
			{
				return m_CrossShiftValue;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossShiftValue != num)
				{
					m_CrossShiftValue = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossReverseNormals
		{
			get
			{
				return m_CrossReverseNormals;
			}
			set
			{
				if (m_CrossReverseNormals != value)
				{
					m_CrossReverseNormals = value;
				}
				base.Dirty = true;
			}
		}

		public ScaleModeEnum ScaleMode
		{
			get
			{
				return m_ScaleMode;
			}
			set
			{
				if (m_ScaleMode != value)
				{
					m_ScaleMode = value;
				}
				base.Dirty = true;
			}
		}

		public CGReferenceMode ScaleReference
		{
			get
			{
				return m_ScaleReference;
			}
			set
			{
				if (m_ScaleReference != value)
				{
					m_ScaleReference = value;
				}
				base.Dirty = true;
			}
		}

		public bool ScaleUniform
		{
			get
			{
				return m_ScaleUniform;
			}
			set
			{
				if (m_ScaleUniform != value)
				{
					m_ScaleUniform = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleOffset
		{
			get
			{
				return m_ScaleOffset;
			}
			set
			{
				if (m_ScaleOffset != value)
				{
					m_ScaleOffset = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleX
		{
			get
			{
				return m_ScaleX;
			}
			set
			{
				if (m_ScaleX != value)
				{
					m_ScaleX = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleY
		{
			get
			{
				return m_ScaleY;
			}
			set
			{
				if (m_ScaleY != value)
				{
					m_ScaleY = value;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve ScaleMultiplierX
		{
			get
			{
				return m_ScaleCurveX;
			}
			set
			{
				if (m_ScaleCurveX != value)
				{
					m_ScaleCurveX = value;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve ScaleMultiplierY
		{
			get
			{
				return m_ScaleCurveY;
			}
			set
			{
				if (m_ScaleCurveY != value)
				{
					m_ScaleCurveY = value;
				}
				base.Dirty = true;
			}
		}

		public float HollowInset
		{
			get
			{
				return m_HollowInset;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_HollowInset != num)
				{
					m_HollowInset = num;
				}
				base.Dirty = true;
			}
		}

		public bool HollowReverseNormals
		{
			get
			{
				return m_HollowReverseNormals;
			}
			set
			{
				if (m_HollowReverseNormals != value)
				{
					m_HollowReverseNormals = value;
				}
				base.Dirty = true;
			}
		}

		public int PathSamples { get; private set; }

		public int CrossSamples { get; private set; }

		public int CrossGroups { get; private set; }

		public IExternalInput Cross => (!IsConfigured) ? null : InCross.SourceSlot().ExternalInput;

		public Vector3 CrossPosition { get; protected set; }

		public Quaternion CrossRotation { get; protected set; }

		private bool ClampPath => !InPath.IsLinked || !InPath.SourceSlot().OnRequestPathModule.PathIsClosed;

		private bool ClampCross => !InCross.IsLinked || !InCross.SourceSlot().OnRequestPathModule.PathIsClosed;

		private RegionOptions<float> RangeOptions
		{
			get
			{
				if (ClampPath)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		private RegionOptions<float> CrossRangeOptions
		{
			get
			{
				if (ClampCross)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 270f;
			Properties.LabelWidth = 100f;
		}

		public override void Reset()
		{
			base.Reset();
			From = 0f;
			To = 1f;
			Resolution = 50;
			AngleThreshold = 10f;
			Optimize = true;
			CrossFrom = 0f;
			CrossTo = 1f;
			CrossResolution = 50;
			CrossAngleThreshold = 10f;
			CrossOptimize = true;
			CrossIncludeControlPoints = false;
			CrossHardEdges = false;
			CrossMaterials = false;
			CrossShiftMode = CrossShiftModeEnum.ByOrientation;
			ScaleMode = ScaleModeEnum.Simple;
			ScaleUniform = true;
			ScaleX = 1f;
			ScaleY = 1f;
			ScaleMultiplierX = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			ScaleMultiplierY = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			HollowInset = 0f;
			CrossExtendedUV = false;
			CrossReverseNormals = false;
			HollowReverseNormals = false;
			ScaleReference = CGReferenceMode.Self;
			ScaleOffset = 0f;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (Length == 0f)
			{
				OutVolume.SetData((CGData[])null);
				OutVolumeHollow.SetData((CGData[])null);
				return;
			}
			List<CGDataRequestParameter> list = new List<CGDataRequestParameter>();
			list.Add(new CGDataRequestRasterization(From, Length, Resolution, InPath.SourceSlot().OnRequestPathModule.PathLength, AngleThreshold, Optimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			CGPath data = InPath.GetData<CGPath>(list.ToArray());
			list.Clear();
			list.Add(new CGDataRequestRasterization(CrossFrom, CrossLength, CrossResolution, InCross.SourceSlot().OnRequestPathModule.PathLength, CrossAngleThreshold, CrossOptimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			if (CrossIncludeControlPoints || CrossHardEdges || CrossMaterials)
			{
				list.Add(new CGDataRequestMetaCGOptions(CrossHardEdges, CrossMaterials, CrossIncludeControlPoints, CrossExtendedUV));
			}
			CGShape data2 = InCross.GetData<CGShape>(list.ToArray());
			if (!data || !data2 || data.Count == 0 || data2.Count == 0)
			{
				OutVolume.ClearData();
				OutVolumeHollow.ClearData();
				return;
			}
			CGVolume cGVolume = CGVolume.Get(OutVolume.GetData<CGVolume>(), data, data2);
			CGVolume cGVolume2 = ((!OutVolumeHollow.IsLinked) ? null : CGVolume.Get(OutVolumeHollow.GetData<CGVolume>(), data, data2));
			PathSamples = data.Count;
			CrossSamples = data2.Count;
			CrossGroups = data2.MaterialGroups.Count;
			CrossPosition = cGVolume.Position[0];
			CrossRotation = Quaternion.LookRotation(cGVolume.Direction[0], cGVolume.Normal[0]);
			Vector3 vector = ((!ScaleUniform) ? new Vector3(ScaleX, ScaleY, 1f) : new Vector3(ScaleX, ScaleX, 1f));
			Vector3 scale = vector;
			int num = 0;
			float[] array = ((ScaleReference != 0) ? data.F : data.SourceF);
			float num2 = ((!CrossReverseNormals) ? 1 : (-1));
			float num3 = ((!HollowReverseNormals) ? 1 : (-1));
			for (int i = 0; i < data.Count; i++)
			{
				Quaternion quaternion = Quaternion.LookRotation(data.Direction[i], data.Normal[i]);
				getScaleInternal(array[i], vector, ref scale);
				Matrix4x4 matrix4x = Matrix4x4.TRS(data.Position[i], quaternion, scale);
				Matrix4x4 matrix4x2 = ((!cGVolume2) ? default(Matrix4x4) : Matrix4x4.TRS(data.Position[i], quaternion, scale * (1f - HollowInset)));
				for (int j = 0; j < data2.Count; j++)
				{
					ref Vector3 reference = ref cGVolume.Vertex[num];
					reference = matrix4x.MultiplyPoint(data2.Position[j]);
					Vector3 vector2 = quaternion * data2.Normal[j];
					cGVolume.VertexNormal[num].x = vector2.x * num2;
					cGVolume.VertexNormal[num].y = vector2.y * num2;
					cGVolume.VertexNormal[num].z = vector2.z * num2;
					if ((bool)cGVolume2)
					{
						ref Vector3 reference2 = ref cGVolume2.Vertex[num];
						reference2 = matrix4x2.MultiplyPoint(data2.Position[j]);
						cGVolume2.VertexNormal[num].x = vector2.x * num3;
						cGVolume2.VertexNormal[num].y = vector2.y * num3;
						cGVolume2.VertexNormal[num].z = vector2.z * num3;
					}
					num++;
				}
			}
			switch (CrossShiftMode)
			{
			case CrossShiftModeEnum.ByOrientation:
			{
				cGVolume.CrossFShift = 0f;
				for (int k = 0; k < data2.Count - 1; k++)
				{
					if (DTMath.RayLineSegmentIntersection(cGVolume.Position[0], cGVolume.Normal[0], cGVolume.Vertex[k], cGVolume.Vertex[k + 1], out var _, out var frag))
					{
						cGVolume.CrossFShift = DTMath.SnapPrecision(cGVolume.CrossF[k] + (cGVolume.CrossF[k + 1] - cGVolume.CrossF[k]) * frag, 2);
						break;
					}
				}
				break;
			}
			case CrossShiftModeEnum.Custom:
				cGVolume.CrossFShift = CrossShiftValue;
				break;
			case CrossShiftModeEnum.None:
				cGVolume.CrossFShift = 0f;
				break;
			default:
				throw new ArgumentOutOfRangeException("CrossShiftMode");
			}
			if (cGVolume2 != null)
			{
				cGVolume2.CrossFShift = cGVolume.CrossFShift;
			}
			OutVolume.SetData(cGVolume);
			OutVolumeHollow.SetData(cGVolume2);
		}

		public Vector3 GetScale(float f)
		{
			Vector3 baseScale = ((!ScaleUniform) ? new Vector3(ScaleX, ScaleY, 1f) : new Vector3(ScaleX, ScaleX, 1f));
			Vector3 scale = Vector3.zero;
			getScaleInternal(f, baseScale, ref scale);
			return scale;
		}

		private void getScaleInternal(float f, Vector3 baseScale, ref Vector3 scale)
		{
			if (ScaleMode == ScaleModeEnum.Advanced)
			{
				float time = DTMath.Repeat(f - ScaleOffset, 1f);
				float num = baseScale.x * ScaleMultiplierX.Evaluate(time);
				scale.Set(num, (!m_ScaleUniform) ? (baseScale.y * ScaleMultiplierY.Evaluate(time)) : num, 1f);
			}
			else
			{
				scale = baseScale;
			}
		}
	}
	[ModuleInfo("Build/Volume Caps", ModuleName = "Volume Caps", Description = "Build volume caps")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildvolumecaps")]
	public class BuildVolumeCaps : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) })]
		public CGModuleInputSlot InVolume = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) }, Optional = true, Array = true)]
		public CGModuleInputSlot InVolumeHoles = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[Tab("General")]
		[SerializeField]
		private CGYesNoAuto m_StartCap = CGYesNoAuto.Auto;

		[SerializeField]
		private CGYesNoAuto m_EndCap = CGYesNoAuto.Auto;

		[SerializeField]
		[FormerlySerializedAs("m_ReverseNormals")]
		private bool m_ReverseTriOrder;

		[SerializeField]
		private bool m_GenerateUV = true;

		[Tab("Start Cap")]
		[Inline]
		[SerializeField]
		private CGMaterialSettings m_StartMaterialSettings = new CGMaterialSettings();

		[Label("Material", "")]
		[SerializeField]
		private Material m_StartMaterial;

		[Tab("End Cap")]
		[SerializeField]
		private bool m_CloneStartCap = true;

		[AsGroup(null, Invisible = true)]
		[GroupCondition("m_CloneStartCap", false, false)]
		[SerializeField]
		private CGMaterialSettings m_EndMaterialSettings = new CGMaterialSettings();

		[Group("Default/End Cap")]
		[Label("Material", "")]
		[FieldCondition("m_CloneStartCap", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private Material m_EndMaterial;

		public bool GenerateUV
		{
			get
			{
				return m_GenerateUV;
			}
			set
			{
				if (m_GenerateUV != value)
				{
					m_GenerateUV = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReverseTriOrder
		{
			get
			{
				return m_ReverseTriOrder;
			}
			set
			{
				if (m_ReverseTriOrder != value)
				{
					m_ReverseTriOrder = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto StartCap
		{
			get
			{
				return m_StartCap;
			}
			set
			{
				if (m_StartCap != value)
				{
					m_StartCap = value;
				}
				base.Dirty = true;
			}
		}

		public Material StartMaterial
		{
			get
			{
				return m_StartMaterial;
			}
			set
			{
				if (m_StartMaterial != value)
				{
					m_StartMaterial = value;
				}
				base.Dirty = true;
			}
		}

		public CGMaterialSettings StartMaterialSettings => m_StartMaterialSettings;

		public CGYesNoAuto EndCap
		{
			get
			{
				return m_EndCap;
			}
			set
			{
				if (m_EndCap != value)
				{
					m_EndCap = value;
				}
				base.Dirty = true;
			}
		}

		public bool CloneStartCap
		{
			get
			{
				return m_CloneStartCap;
			}
			set
			{
				if (m_CloneStartCap != value)
				{
					m_CloneStartCap = value;
				}
				base.Dirty = true;
			}
		}

		public CGMaterialSettings EndMaterialSettings => m_EndMaterialSettings;

		public Material EndMaterial
		{
			get
			{
				return m_EndMaterial;
			}
			set
			{
				if (m_EndMaterial != value)
				{
					m_EndMaterial = value;
				}
				base.Dirty = true;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			if (StartMaterial == null)
			{
				StartMaterial = CurvyUtility.GetDefaultMaterial();
			}
			if (EndMaterial == null)
			{
				EndMaterial = CurvyUtility.GetDefaultMaterial();
			}
		}

		public override void Reset()
		{
			base.Reset();
			StartCap = CGYesNoAuto.Auto;
			EndCap = CGYesNoAuto.Auto;
			ReverseTriOrder = false;
			GenerateUV = true;
			m_StartMaterialSettings = new CGMaterialSettings();
			m_EndMaterialSettings = new CGMaterialSettings();
			StartMaterial = CurvyUtility.GetDefaultMaterial();
			EndMaterial = CurvyUtility.GetDefaultMaterial();
			CloneStartCap = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			CGVolume data = InVolume.GetData<CGVolume>(new CGDataRequestParameter[0]);
			List<CGVolume> allData = InVolumeHoles.GetAllData<CGVolume>(new CGDataRequestParameter[0]);
			if (!data)
			{
				return;
			}
			bool flag = StartCap == CGYesNoAuto.Yes || (StartCap == CGYesNoAuto.Auto && !data.Seamless);
			bool flag2 = EndCap == CGYesNoAuto.Yes || (EndCap == CGYesNoAuto.Auto && !data.Seamless);
			if (!flag && !flag2)
			{
				OutVMesh.SetData((CGData[])null);
				return;
			}
			CGVMesh cGVMesh = new CGVMesh();
			Vector3[] array = new Vector3[0];
			Vector3[] array2 = new Vector3[0];
			cGVMesh.AddSubMesh(new CGVSubMesh());
			CGVSubMesh cGVSubMesh = cGVMesh.SubMeshes[0];
			if (flag)
			{
				Tess tess = new Tess();
				tess.UsePooling = true;
				tess.AddContour(make2DSegment(data, 0));
				for (int i = 0; i < allData.Count; i++)
				{
					if (allData[i].Count < 3)
					{
						OutVMesh.SetData((CGData[])null);
						UIMessages.Add("Hole Cross has less than 3 Vertices: Can't create Caps!");
						return;
					}
					tess.AddContour(make2DSegment(allData[i], 0));
				}
				tess.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);
				array = UnityLibTessUtility.FromContourVertex(tess.Vertices);
				int num = 0;
				cGVMesh.Vertex = applyMatrix(array, getMatrix(data, num, inverse: true), out var bounds);
				Vector3[] array3 = new Vector3[cGVMesh.Vertex.Length];
				Vector3 vector = -data.Direction[num];
				for (int j = 0; j < array3.Length; j++)
				{
					array3[j] = vector;
				}
				cGVMesh.Normal = array3;
				cGVSubMesh.Material = StartMaterial;
				cGVSubMesh.Triangles = tess.Elements;
				if (ReverseTriOrder)
				{
					flipTris(ref cGVSubMesh.Triangles, 0, cGVSubMesh.Triangles.Length);
				}
				if (GenerateUV)
				{
					cGVMesh.UV = new Vector2[array.Length];
					applyUV(array, ref cGVMesh.UV, 0, array.Length, StartMaterialSettings, bounds);
				}
			}
			if (flag2)
			{
				Tess tess2 = new Tess();
				tess2.UsePooling = true;
				tess2.AddContour(make2DSegment(data, 0));
				for (int k = 0; k < allData.Count; k++)
				{
					if (allData[k].Count < 3)
					{
						OutVMesh.SetData((CGData[])null);
						UIMessages.Add("Hole Cross has <3 Vertices: Can't create Caps!");
						return;
					}
					tess2.AddContour(make2DSegment(allData[k], 0));
				}
				tess2.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);
				array2 = UnityLibTessUtility.FromContourVertex(tess2.Vertices);
				int num2 = cGVMesh.Vertex.Length;
				int num3 = data.Count - 1;
				cGVMesh.Vertex = cGVMesh.Vertex.AddRange(applyMatrix(array2, getMatrix(data, num3, inverse: true), out var bounds2));
				Vector3[] array4 = new Vector3[num2];
				Vector3 vector2 = data.Direction[num3];
				for (int l = 0; l < array4.Length; l++)
				{
					array4[l] = vector2;
				}
				cGVMesh.Normal = cGVMesh.Normal.AddRange(array4);
				int[] indices = tess2.Elements;
				if (!ReverseTriOrder)
				{
					flipTris(ref indices, 0, indices.Length);
				}
				for (int m = 0; m < indices.Length; m++)
				{
					indices[m] += num2;
				}
				if (!CloneStartCap && StartMaterial != EndMaterial)
				{
					cGVMesh.AddSubMesh(new CGVSubMesh(indices, EndMaterial));
				}
				else
				{
					cGVSubMesh.Material = StartMaterial;
					cGVSubMesh.Triangles = cGVSubMesh.Triangles.AddRange(indices);
				}
				if (GenerateUV)
				{
					Array.Resize(ref cGVMesh.UV, cGVMesh.UV.Length + array2.Length);
					applyUV(array2, ref cGVMesh.UV, array.Length, array2.Length, (!CloneStartCap) ? EndMaterialSettings : StartMaterialSettings, bounds2);
				}
			}
			OutVMesh.SetData(cGVMesh);
		}

		private static Matrix4x4 getMatrix(CGVolume vol, int index, bool inverse)
		{
			if (inverse)
			{
				Quaternion q = Quaternion.LookRotation(vol.Direction[index], vol.Normal[index]);
				return Matrix4x4.TRS(vol.Position[index], q, Vector3.one);
			}
			Quaternion quaternion = Quaternion.Inverse(Quaternion.LookRotation(vol.Direction[index], vol.Normal[index]));
			return Matrix4x4.TRS(-(quaternion * vol.Position[index]), quaternion, Vector3.one);
		}

		private static void flipTris(ref int[] indices, int start, int end)
		{
			for (int i = start; i < end; i += 3)
			{
				int num = indices[i];
				indices[i] = indices[i + 2];
				indices[i + 2] = num;
			}
		}

		private static Vector3[] applyMatrix(Vector3[] vt, Matrix4x4 matrix, out Bounds bounds)
		{
			Vector3[] array = new Vector3[vt.Length];
			float num = float.MaxValue;
			float num2 = float.MaxValue;
			float num3 = float.MinValue;
			float num4 = float.MinValue;
			for (int i = 0; i < vt.Length; i++)
			{
				num = Mathf.Min(vt[i].x, num);
				num2 = Mathf.Min(vt[i].y, num2);
				num3 = Mathf.Max(vt[i].x, num3);
				num4 = Mathf.Max(vt[i].y, num4);
				ref Vector3 reference = ref array[i];
				reference = matrix.MultiplyPoint(vt[i]);
			}
			Vector3 size = new Vector3(Mathf.Abs(num3 - num), Mathf.Abs(num4 - num2));
			bounds = new Bounds(new Vector3(num + size.x / 2f, num2 + size.y / 2f, 0f), size);
			return array;
		}

		private static ContourVertex[] make2DSegment(CGVolume vol, int index)
		{
			Matrix4x4 matrix = getMatrix(vol, index, inverse: false);
			int segmentIndex = vol.GetSegmentIndex(index);
			ContourVertex[] array = new ContourVertex[vol.CrossSize];
			for (int i = 0; i < vol.CrossSize; i++)
			{
				ref ContourVertex reference = ref array[i];
				reference = matrix.MultiplyPoint(vol.Vertex[segmentIndex + i]).ContourVertex();
			}
			return array;
		}

		private static void applyUV(Vector3[] vts, ref Vector2[] uvArray, int index, int count, CGMaterialSettings mat, Bounds bounds)
		{
			float x = bounds.size.x;
			float y = bounds.size.y;
			float x2 = bounds.min.x;
			float y2 = bounds.min.y;
			float num = mat.UVScale.x;
			float num2 = mat.UVScale.y;
			switch (mat.KeepAspect)
			{
			case CGKeepAspectMode.ScaleU:
			{
				float num5 = x * mat.UVScale.x;
				float num6 = y * mat.UVScale.y;
				num *= num5 / num6;
				break;
			}
			case CGKeepAspectMode.ScaleV:
			{
				float num3 = x * mat.UVScale.x;
				float num4 = y * mat.UVScale.y;
				num2 *= num4 / num3;
				break;
			}
			}
			bool swapUV = mat.SwapUV;
			if (mat.UVRotation != 0f)
			{
				float f = mat.UVRotation * ((float)Math.PI / 180f);
				float num7 = Mathf.Sin(f);
				float num8 = Mathf.Cos(f);
				float num9 = num * 0.5f;
				float num10 = num2 * 0.5f;
				for (int i = 0; i < count; i++)
				{
					float num11 = (vts[i].x - x2) / x * num;
					float num12 = (vts[i].y - y2) / y * num2;
					float num13 = num11 - num9;
					float num14 = num12 - num10;
					num11 = num8 * num13 - num7 * num14 + num9 + mat.UVOffset.x;
					num12 = num7 * num13 + num8 * num14 + num10 + mat.UVOffset.y;
					int num15 = i + index;
					uvArray[num15].x = ((!swapUV) ? num11 : num12);
					uvArray[num15].y = ((!swapUV) ? num12 : num11);
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					float num11 = mat.UVOffset.x + (vts[j].x - x2) / x * num;
					float num12 = mat.UVOffset.y + (vts[j].y - y2) / y * num2;
					int num16 = j + index;
					uvArray[num16].x = ((!swapUV) ? num11 : num12);
					uvArray[num16].y = ((!swapUV) ? num12 : num11);
				}
			}
		}
	}
	[ModuleInfo("Build/Volume Mesh", ModuleName = "Volume Mesh", Description = "Build a volume mesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildvolumemesh")]
	public class BuildVolumeMesh : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) })]
		public CGModuleInputSlot InVolume = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[Tab("General")]
		[SerializeField]
		private bool m_GenerateUV = true;

		[SerializeField]
		private bool m_Split;

		[Positive(MinValue = 1f)]
		[FieldCondition("m_Split", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private float m_SplitLength = 100f;

		[FieldAction("CBAddMaterial", ActionAttribute.ActionEnum.Callback)]
		[SerializeField]
		[FormerlySerializedAs("m_ReverseNormals")]
		private bool m_ReverseTriOrder;

		[SerializeField]
		[HideInInspector]
		private List<CGMaterialSettingsEx> m_MaterialSettings = new List<CGMaterialSettingsEx>();

		[SerializeField]
		[HideInInspector]
		private Material[] m_Material = new Material[0];

		private List<SamplePointsMaterialGroupCollection> groupsByMatID;

		public bool GenerateUV
		{
			get
			{
				return m_GenerateUV;
			}
			set
			{
				if (m_GenerateUV != value)
				{
					m_GenerateUV = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReverseTriOrder
		{
			get
			{
				return m_ReverseTriOrder;
			}
			set
			{
				if (m_ReverseTriOrder != value)
				{
					m_ReverseTriOrder = value;
				}
				base.Dirty = true;
			}
		}

		public bool Split
		{
			get
			{
				return m_Split;
			}
			set
			{
				if (m_Split != value)
				{
					m_Split = value;
				}
				base.Dirty = true;
			}
		}

		public float SplitLength
		{
			get
			{
				return m_SplitLength;
			}
			set
			{
				float num = Mathf.Max(1f, value);
				if (m_SplitLength != num)
				{
					m_SplitLength = num;
				}
				base.Dirty = true;
			}
		}

		public List<CGMaterialSettingsEx> MaterialSetttings => m_MaterialSettings;

		public int MaterialCount => m_MaterialSettings.Count;

		protected override void Awake()
		{
			base.Awake();
			if (MaterialCount == 0)
			{
				AddMaterial();
			}
		}

		public override void Reset()
		{
			base.Reset();
			GenerateUV = true;
			Split = false;
			SplitLength = 100f;
			ReverseTriOrder = false;
			m_MaterialSettings = new List<CGMaterialSettingsEx>(new CGMaterialSettingsEx[1]
			{
				new CGMaterialSettingsEx()
			});
			m_Material = new Material[1] { CurvyUtility.GetDefaultMaterial() };
		}

		public override void Refresh()
		{
			base.Refresh();
			CGVolume data = InVolume.GetData<CGVolume>(new CGDataRequestParameter[0]);
			if ((bool)data && data.Count > 0 && data.CrossSize > 0 && data.CrossMaterialGroups.Count > 0)
			{
				List<IntRegion> list = new List<IntRegion>();
				if (Split)
				{
					float num = 0f;
					int num2 = 0;
					for (int i = 0; i < data.Count; i++)
					{
						float num3 = data.FToDistance(data.F[i]);
						if (num3 - num >= SplitLength)
						{
							list.Add(new IntRegion(num2, i));
							num = num3;
							num2 = i;
						}
					}
					if (num2 < data.Count - 1)
					{
						list.Add(new IntRegion(num2, data.Count - 1));
					}
				}
				else
				{
					list.Add(new IntRegion(0, data.Count - 1));
				}
				CGVMesh[] array = OutVMesh.GetAllData<CGVMesh>();
				Array.Resize(ref array, list.Count);
				prepare(data);
				for (int j = 0; j < list.Count; j++)
				{
					array[j] = CGVMesh.Get(array[j], data, list[j], GenerateUV, ReverseTriOrder);
					build(array[j], data, list[j]);
				}
				OutVMesh.SetData(array);
			}
			else
			{
				OutVMesh.SetData((CGData[])null);
			}
		}

		public int AddMaterial()
		{
			m_MaterialSettings.Add(new CGMaterialSettingsEx());
			m_Material = m_Material.Add(CurvyUtility.GetDefaultMaterial());
			base.Dirty = true;
			return MaterialCount;
		}

		public void RemoveMaterial(int index)
		{
			if (validateMaterialIndex(index))
			{
				m_MaterialSettings.RemoveAt(index);
				m_Material = m_Material.RemoveAt(index);
				base.Dirty = true;
			}
		}

		public void SetMaterial(int index, Material mat)
		{
			if (validateMaterialIndex(index) && !(mat == m_Material[index]) && m_Material[index] != mat)
			{
				m_Material[index] = mat;
				base.Dirty = true;
			}
		}

		public Material GetMaterial(int index)
		{
			if (!validateMaterialIndex(index))
			{
				return null;
			}
			return m_Material[index];
		}

		private void prepare(CGVolume vol)
		{
			groupsByMatID = getMaterialIDGroups(vol);
		}

		private void build(CGVMesh vmesh, CGVolume vol, IntRegion subset)
		{
			if (GenerateUV)
			{
				Array.Resize(ref vmesh.UV, vmesh.Count);
			}
			prepareSubMeshes(vmesh, groupsByMatID, subset.Length, ref m_Material);
			int num = 0;
			int[] array = new int[groupsByMatID.Count];
			for (int i = subset.From; i < subset.To; i++)
			{
				for (int j = 0; j < groupsByMatID.Count; j++)
				{
					SamplePointsMaterialGroupCollection samplePointsMaterialGroupCollection = groupsByMatID[j];
					for (int k = 0; k < samplePointsMaterialGroupCollection.Count; k++)
					{
						SamplePointsMaterialGroup grp = samplePointsMaterialGroupCollection[k];
						if (GenerateUV)
						{
							createMaterialGroupUV(ref vmesh, ref vol, ref grp, samplePointsMaterialGroupCollection.MaterialID, samplePointsMaterialGroupCollection.AspectCorrection, i, num);
						}
						for (int l = 0; l < grp.Patches.Count; l++)
						{
							createPatchTriangles(ref vmesh.SubMeshes[j].Triangles, ref array[j], num + grp.Patches[l].Start, grp.Patches[l].Count, vol.CrossSize, ReverseTriOrder);
						}
					}
				}
				num += vol.CrossSize;
			}
			if (!GenerateUV)
			{
				return;
			}
			for (int m = 0; m < groupsByMatID.Count; m++)
			{
				SamplePointsMaterialGroupCollection samplePointsMaterialGroupCollection = groupsByMatID[m];
				for (int n = 0; n < samplePointsMaterialGroupCollection.Count; n++)
				{
					SamplePointsMaterialGroup grp = samplePointsMaterialGroupCollection[n];
					createMaterialGroupUV(ref vmesh, ref vol, ref grp, samplePointsMaterialGroupCollection.MaterialID, samplePointsMaterialGroupCollection.AspectCorrection, subset.To, num);
				}
			}
		}

		private static void prepareSubMeshes(CGVMesh vmesh, List<SamplePointsMaterialGroupCollection> groupsBySubMeshes, int extrusions, ref Material[] materials)
		{
			vmesh.SetSubMeshCount(groupsBySubMeshes.Count);
			for (int i = 0; i < groupsBySubMeshes.Count; i++)
			{
				CGVSubMesh data = vmesh.SubMeshes[i];
				vmesh.SubMeshes[i] = CGVSubMesh.Get(data, groupsBySubMeshes[i].TriangleCount * extrusions * 3, materials[Mathf.Min(groupsBySubMeshes[i].MaterialID, materials.Length - 1)]);
			}
		}

		private void createMaterialGroupUV(ref CGVMesh vmesh, ref CGVolume vol, ref SamplePointsMaterialGroup grp, int matIndex, float grpAspectCorrection, int sample, int baseVertex)
		{
			CGMaterialSettingsEx cGMaterialSettingsEx = m_MaterialSettings[matIndex];
			float num = cGMaterialSettingsEx.UVOffset.y + vol.F[sample] * cGMaterialSettingsEx.UVScale.y * grpAspectCorrection;
			int endVertex = grp.EndVertex;
			bool swapUV = cGMaterialSettingsEx.SwapUV;
			Vector2[] uV = vmesh.UV;
			for (int i = grp.StartVertex; i <= endVertex; i++)
			{
				float num2 = cGMaterialSettingsEx.UVOffset.x + vol.CrossMap[i] * cGMaterialSettingsEx.UVScale.x;
				uV[baseVertex + i].x = ((!swapUV) ? num2 : num);
				uV[baseVertex + i].y = ((!swapUV) ? num : num2);
			}
		}

		private static int createPatchTriangles(ref int[] triangles, ref int triIdx, int curVTIndex, int patchSize, int crossSize, bool reverse)
		{
			int num = (reverse ? 1 : 0);
			int num2 = 1 - num;
			int num3 = curVTIndex + crossSize;
			for (int i = 0; i < patchSize; i++)
			{
				triangles[triIdx + num] = curVTIndex + i;
				triangles[triIdx + num2] = num3 + i;
				triangles[triIdx + 2] = curVTIndex + i + 1;
				triangles[triIdx + num + 3] = curVTIndex + i + 1;
				triangles[triIdx + num2 + 3] = num3 + i;
				triangles[triIdx + 5] = num3 + i + 1;
				triIdx += 6;
			}
			return curVTIndex + patchSize + 1;
		}

		private List<SamplePointsMaterialGroupCollection> getMaterialIDGroups(CGVolume volume)
		{
			Dictionary<int, SamplePointsMaterialGroupCollection> dictionary = new Dictionary<int, SamplePointsMaterialGroupCollection>();
			for (int i = 0; i < volume.CrossMaterialGroups.Count; i++)
			{
				int num = Mathf.Min(volume.CrossMaterialGroups[i].MaterialID, MaterialCount - 1);
				if (!dictionary.TryGetValue(num, out var value))
				{
					value = new SamplePointsMaterialGroupCollection();
					value.MaterialID = num;
					dictionary.Add(num, value);
				}
				value.Add(volume.CrossMaterialGroups[i]);
			}
			List<SamplePointsMaterialGroupCollection> list = new List<SamplePointsMaterialGroupCollection>();
			foreach (SamplePointsMaterialGroupCollection value2 in dictionary.Values)
			{
				value2.CalculateAspectCorrection(volume, MaterialSetttings[value2.MaterialID]);
				list.Add(value2);
			}
			return list;
		}

		private bool validateMaterialIndex(int index)
		{
			if (index < 0 || index >= m_MaterialSettings.Count)
			{
				Debug.LogError("TriangulateTube: Invalid Material Index!");
				return false;
			}
			return true;
		}
	}
	[ModuleInfo("Build/Volume Spots", ModuleName = "Volume Spots", Description = "Generate spots along a path/volume", UsesRandom = true)]
	[HelpURL("https://curvyeditor.com/doclink/cgvolumespots")]
	public class BuildVolumeSpots : CGModule
	{
		private class GroupSet
		{
			public CGBoundsGroup Group;

			public float Length;

			public List<int> Items = new List<int>();

			public List<float> Distances = new List<float>();
		}

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path/Volume", DisplayName = "Volume/Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGBounds) }, Array = true)]
		public CGModuleInputSlot InBounds = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGSpots))]
		public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

		[Tab("General")]
		[FloatRegion(RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[Tooltip("When the source is a Volume, you can choose if you want to use it's path or the volume")]
		[FieldCondition("Volume", null, true, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_UseVolume;

		[Tooltip("Dry run without actually creating spots?")]
		[SerializeField]
		private bool m_Simulate;

		[Section("Default/General/Cross", true, false, 100)]
		[SerializeField]
		[RangeEx(-1f, 1f, "", "")]
		private float m_CrossBase;

		[SerializeField]
		private AnimationCurve m_CrossCurve = AnimationCurve.Linear(0f, 0f, 1f, 0f);

		[Tab("Groups")]
		[ArrayEx(Space = 10)]
		[SerializeField]
		private List<CGBoundsGroup> m_Groups = new List<CGBoundsGroup>();

		[IntRegion(UseSlider = false, RegionOptionsPropertyName = "RepeatingGroupsOptions", Options = AttributeOptionsFlags.Compact)]
		[SerializeField]
		private IntRegion m_RepeatingGroups;

		[SerializeField]
		private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

		[SerializeField]
		private bool m_FitEnd;

		public CGSpots SimulatedSpots;

		private WeightedRandom<int> mGroupBag;

		private List<CGBounds> mBounds;

		public FloatRegion Range
		{
			get
			{
				return m_Range;
			}
			set
			{
				if (m_Range != value)
				{
					m_Range = value;
				}
				base.Dirty = true;
			}
		}

		public bool UseVolume
		{
			get
			{
				return m_UseVolume;
			}
			set
			{
				if (m_UseVolume != value)
				{
					m_UseVolume = value;
				}
				base.Dirty = true;
			}
		}

		public bool Simulate
		{
			get
			{
				return m_Simulate;
			}
			set
			{
				if (m_Simulate != value)
				{
					m_Simulate = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossBase
		{
			get
			{
				return m_CrossBase;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossBase != num)
				{
					m_CrossBase = num;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve CrossCurve
		{
			get
			{
				return m_CrossCurve;
			}
			set
			{
				if (m_CrossCurve != value)
				{
					m_CrossCurve = value;
				}
				base.Dirty = true;
			}
		}

		public List<CGBoundsGroup> Groups
		{
			get
			{
				return m_Groups;
			}
			set
			{
				if (m_Groups != value)
				{
					m_Groups = value;
				}
			}
		}

		public CurvyRepeatingOrderEnum RepeatingOrder
		{
			get
			{
				return m_RepeatingOrder;
			}
			set
			{
				if (m_RepeatingOrder != value)
				{
					m_RepeatingOrder = value;
				}
				base.Dirty = true;
			}
		}

		public int FirstRepeating
		{
			get
			{
				return m_RepeatingGroups.From;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, Mathf.Max(0, GroupCount - 1));
				if (m_RepeatingGroups.From != num)
				{
					m_RepeatingGroups.From = num;
				}
				base.Dirty = true;
			}
		}

		public int LastRepeating
		{
			get
			{
				return m_RepeatingGroups.To;
			}
			set
			{
				int num = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, GroupCount - 1));
				if (m_RepeatingGroups.To != num)
				{
					m_RepeatingGroups.To = num;
				}
				base.Dirty = true;
			}
		}

		public bool FitEnd
		{
			get
			{
				return m_FitEnd;
			}
			set
			{
				if (m_FitEnd != value)
				{
					m_FitEnd = value;
				}
				base.Dirty = true;
			}
		}

		public int GroupCount => Groups.Count;

		public GUIContent[] BoundsNames
		{
			get
			{
				if (mBounds == null)
				{
					return new GUIContent[0];
				}
				GUIContent[] array = new GUIContent[mBounds.Count];
				for (int i = 0; i < mBounds.Count; i++)
				{
					array[i] = new GUIContent(string.Format(CultureInfo.InvariantCulture, "{0}:{1}", i.ToString(CultureInfo.InvariantCulture), mBounds[i].Name));
				}
				return array;
			}
		}

		public int[] BoundsIndices
		{
			get
			{
				if (mBounds == null)
				{
					return new int[0];
				}
				int[] array = new int[mBounds.Count];
				for (int i = 0; i < mBounds.Count; i++)
				{
					array[i] = i;
				}
				return array;
			}
		}

		public int Count { get; private set; }

		private int lastGroupIndex => Mathf.Max(0, GroupCount - 1);

		private RegionOptions<float> RangeOptions => RegionOptions<float>.MinMax(0f, 1f);

		private RegionOptions<int> RepeatingGroupsOptions => RegionOptions<int>.MinMax(0, Mathf.Max(0, GroupCount - 1));

		private CGPath Path { get; set; }

		private CGVolume Volume => Path as CGVolume;

		private float Length => (Path == null) ? 0f : (Path.Length * m_Range.Length);

		private float StartDistance { get; set; }

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 350f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Range = FloatRegion.ZeroOne;
			UseVolume = false;
			Simulate = false;
			CrossBase = 0f;
			CrossCurve = AnimationCurve.Linear(0f, 0f, 1f, 0f);
			RepeatingOrder = CurvyRepeatingOrderEnum.Row;
			FirstRepeating = 0;
			LastRepeating = 0;
			FitEnd = false;
			Groups.Clear();
			AddGroup("Group");
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public void Clear()
		{
			Count = 0;
			SimulatedSpots = new CGSpots();
			OutSpots.SetData(SimulatedSpots);
		}

		public override void Refresh()
		{
			base.Refresh();
			mBounds = InBounds.GetAllData<CGBounds>(new CGDataRequestParameter[0]);
			bool flag = false;
			for (int i = 0; i < mBounds.Count; i++)
			{
				CGBounds cGBounds = mBounds[i];
				if (cGBounds is CGGameObject && ((CGGameObject)cGBounds).Object == null)
				{
					flag = true;
					UIMessages.Add($"Input object of index {i} has no Game Object attached to it. Correct this to enable spots generation.");
				}
				else if (cGBounds.Depth <= 0.01f)
				{
					CGBounds cGBounds2 = new CGBounds(cGBounds);
					UIMessages.Add($"Input object \"{cGBounds2.Name}\" has bounds with a depth of {cGBounds.Depth}. The minimal accepted depth is {0.01f}. The depth value was overriden.");
					cGBounds2.Bounds = new Bounds(cGBounds.Bounds.center, new Vector3(cGBounds.Bounds.size.x, cGBounds.Bounds.size.y, 0.01f));
					mBounds[i] = cGBounds2;
				}
			}
			if (mBounds.Count == 0)
			{
				flag = true;
				UIMessages.Add("The input bounds list is empty. Add some to enable spots generation.");
			}
			foreach (CGBoundsGroup group in Groups)
			{
				if (group.ItemCount == 0)
				{
					flag = true;
					UIMessages.Add($"Group \"{group.Name}\" has 0 item in it. Add some to enable spots generation.");
					continue;
				}
				foreach (CGBoundsGroupItem item in group.Items)
				{
					int index = item.Index;
					if (index < 0 || index >= mBounds.Count)
					{
						flag = true;
						UIMessages.Add($"Group \"{group.Name}\" has a reference to an inexistent item of index {index}. Correct the reference to enable spots generation.");
						break;
					}
				}
			}
			Path = InPath.GetData<CGPath>(new CGDataRequestParameter[0]);
			if (Path != null && Volume == null && UseVolume)
			{
				m_UseVolume = false;
			}
			List<CGSpot> spots = new List<CGSpot>();
			List<GroupSet> sets = null;
			prepare();
			if ((bool)Path && !flag)
			{
				float remainingLength = Length;
				StartDistance = Path.FToDistance(m_Range.Low);
				float currentDistance = StartDistance;
				for (int j = 0; j < FirstRepeating; j++)
				{
					addGroupItems(Groups[j], ref spots, ref remainingLength, ref currentDistance);
					if (remainingLength <= 0f)
					{
						break;
					}
				}
				if (GroupCount - LastRepeating - 1 > 0)
				{
					sets = new List<GroupSet>();
					float currentDistance2 = 0f;
					for (int k = LastRepeating + 1; k < GroupCount; k++)
					{
						sets.Add(addGroupItems(Groups[k], ref spots, ref remainingLength, ref currentDistance2, calcLengthOnly: true));
					}
				}
				bool flag2 = false;
				if (RepeatingOrder == CurvyRepeatingOrderEnum.Row)
				{
					int firstRepeating = FirstRepeating;
					while (remainingLength > 0f)
					{
						addGroupItems(Groups[firstRepeating++], ref spots, ref remainingLength, ref currentDistance);
						if (firstRepeating > LastRepeating)
						{
							firstRepeating = FirstRepeating;
						}
						if (spots.Count >= 10000)
						{
							flag2 = true;
							break;
						}
					}
				}
				else
				{
					while (remainingLength > 0f)
					{
						addGroupItems(Groups[mGroupBag.Next()], ref spots, ref remainingLength, ref currentDistance);
						if (spots.Count >= 10000)
						{
							flag2 = true;
							break;
						}
					}
				}
				if (flag2)
				{
					string text = $"Number of generated spots reached the maximal allowed number, which is {10000}. Spots generation was stopped. Try to reduce the number of spots needed by using bigger Bounds as inputs and/or setting bigger space between two spots.";
					UIMessages.Add(text);
					DTLog.LogError("[Curvy] Volume spots: " + text);
				}
				if (sets != null)
				{
					rebase(ref spots, ref sets, currentDistance);
				}
			}
			Count = spots.Count;
			SimulatedSpots = new CGSpots(spots);
			if (Simulate)
			{
				OutSpots.SetData(new CGSpots());
			}
			else
			{
				OutSpots.SetData(SimulatedSpots);
			}
		}

		public CGBoundsGroup AddGroup(string name)
		{
			CGBoundsGroup cGBoundsGroup = new CGBoundsGroup(name);
			cGBoundsGroup.Items.Add(new CGBoundsGroupItem());
			Groups.Add(cGBoundsGroup);
			base.Dirty = true;
			return cGBoundsGroup;
		}

		public void RemoveGroup(CGBoundsGroup group)
		{
			Groups.Remove(group);
			base.Dirty = true;
		}

		private GroupSet addGroupItems(CGBoundsGroup group, ref List<CGSpot> spots, ref float remainingLength, ref float currentDistance, bool calcLengthOnly = false)
		{
			for (int i = 0; i < group.ItemCount; i++)
			{
				CGBounds itemBounds = getItemBounds(group.Items[i].Index);
			}
			int num = 0;
			float next = group.SpaceBefore.Next;
			float next2 = group.SpaceAfter.Next;
			float num2 = remainingLength - next;
			GroupSet groupSet = null;
			GroupSet groupSet2 = new GroupSet();
			float num3 = currentDistance + next;
			if (calcLengthOnly)
			{
				groupSet = new GroupSet();
				groupSet.Group = group;
				groupSet.Length = next + next2;
			}
			for (int j = 0; j < group.FirstRepeating; j++)
			{
				int index = group.Items[j].Index;
				CGBounds bounds = getItemBounds(index);
				num2 -= bounds.Depth;
				if (num2 > 0f)
				{
					if (calcLengthOnly)
					{
						groupSet.Length += bounds.Depth;
						groupSet.Items.Add(index);
						groupSet.Distances.Add(num3);
					}
					else
					{
						spots.Add(getSpot(index, ref group, ref bounds, num3));
					}
					num3 += bounds.Depth;
					num++;
					continue;
				}
				if (group.KeepTogether && num > 0)
				{
					spots.RemoveRange(spots.Count - num, num);
				}
				break;
			}
			if (num2 > 0f)
			{
				float num4 = 0f;
				for (int k = group.LastRepeating + 1; k < group.ItemCount; k++)
				{
					int index = group.Items[k].Index;
					CGBounds bounds = getItemBounds(index);
					num2 -= bounds.Depth;
					if (num2 > 0f)
					{
						groupSet2.Length += bounds.Depth;
						groupSet2.Items.Add(index);
						groupSet2.Distances.Add(num4);
						num4 += bounds.Depth;
						continue;
					}
					break;
				}
				if (num2 > 0f)
				{
					for (int l = group.FirstRepeating; l <= group.LastRepeating; l++)
					{
						int index2 = ((group.RepeatingOrder != CurvyRepeatingOrderEnum.Row) ? group.getRandomItemINTERNAL() : l);
						int index = group.Items[index2].Index;
						CGBounds bounds = getItemBounds(index);
						num2 -= bounds.Depth;
						if (num2 > 0f)
						{
							if (calcLengthOnly)
							{
								groupSet.Length += bounds.Depth;
								groupSet.Items.Add(index);
								groupSet.Distances.Add(num3);
							}
							else
							{
								spots.Add(getSpot(index, ref group, ref bounds, num3));
							}
							num3 += bounds.Depth;
							num++;
							continue;
						}
						if (group.KeepTogether && num > 0)
						{
							spots.RemoveRange(spots.Count - num, num);
						}
						break;
					}
				}
				if (num2 > 0f || !group.KeepTogether)
				{
					for (int m = 0; m < groupSet2.Items.Count; m++)
					{
						CGBounds bounds2 = getItemBounds(groupSet2.Items[m]);
						spots.Add(getSpot(groupSet2.Items[m], ref group, ref bounds2, num3 + groupSet2.Distances[m]));
						num3 += bounds2.Depth;
					}
				}
			}
			remainingLength = num2 - next2;
			currentDistance = num3 + next2;
			return groupSet;
		}

		private void rebase(ref List<CGSpot> spots, ref List<GroupSet> sets, float currentDistance)
		{
			if (FitEnd)
			{
				currentDistance = Path.FToDistance(m_Range.To);
				for (int i = 0; i < sets.Count; i++)
				{
					currentDistance -= sets[i].Length;
				}
			}
			for (int j = 0; j < sets.Count; j++)
			{
				GroupSet groupSet = sets[j];
				for (int k = 0; k < groupSet.Items.Count; k++)
				{
					CGBounds bounds = getItemBounds(groupSet.Items[k]);
					spots.Add(getSpot(groupSet.Items[k], ref groupSet.Group, ref bounds, currentDistance + groupSet.Distances[k]));
				}
			}
		}

		private CGSpot getSpot(int itemID, ref CGBoundsGroup group, ref CGBounds bounds, float startDist)
		{
			CGSpot result = new CGSpot(itemID);
			float f = Path.DistanceToF(startDist + bounds.Depth / 2f);
			Vector3 pos = Vector3.zero;
			Vector3 dir = Vector3.forward;
			Vector3 up = Vector3.up;
			float crossValue = getCrossValue((startDist - StartDistance) / Length, group);
			if (group.RotationMode != CGBoundsGroup.RotationModeEnum.Independent)
			{
				if (UseVolume)
				{
					Volume.InterpolateVolume(f, crossValue, out pos, out dir, out up);
				}
				else
				{
					Path.Interpolate(f, crossValue, out pos, out dir, out up);
				}
				switch (group.RotationMode)
				{
				case CGBoundsGroup.RotationModeEnum.Direction:
					up = Vector3.up;
					break;
				case CGBoundsGroup.RotationModeEnum.Horizontal:
					up = Vector3.up;
					dir.y = 0f;
					break;
				}
			}
			else
			{
				pos = ((!UseVolume) ? Path.InterpolatePosition(f) : Volume.InterpolateVolumePosition(f, crossValue));
			}
			if (Path.SourceIsManaged)
			{
				result.Rotation = Quaternion.LookRotation(dir, up) * Quaternion.Euler(group.RotationOffset.x + group.RotationScatter.x * (float)Random.Range(-1, 1), group.RotationOffset.y + group.RotationScatter.y * (float)Random.Range(-1, 1), group.RotationOffset.z + group.RotationScatter.z * (float)Random.Range(-1, 1));
				result.Position = pos + result.Rotation * new Vector3(0f, group.Height.Next, 0f);
			}
			else
			{
				result.Rotation = Quaternion.LookRotation(dir, up) * Quaternion.Euler(group.RotationOffset.x + group.RotationScatter.x * (float)Random.Range(-1, 1), group.RotationOffset.y + group.RotationScatter.y * (float)Random.Range(-1, 1), group.RotationOffset.z + group.RotationScatter.z * (float)Random.Range(-1, 1));
				result.Position = pos + result.Rotation * new Vector3(0f, group.Height.Next, 0f);
			}
			return result;
		}

		private void prepare()
		{
			m_RepeatingGroups.MakePositive();
			m_RepeatingGroups.Clamp(0, GroupCount - 1);
			if (mGroupBag == null)
			{
				mGroupBag = new WeightedRandom<int>();
			}
			else
			{
				mGroupBag.Clear();
			}
			if (RepeatingOrder == CurvyRepeatingOrderEnum.Random)
			{
				for (int i = FirstRepeating; i <= LastRepeating; i++)
				{
					mGroupBag.Add(i, (int)(Groups[i].Weight * 10f));
				}
			}
			for (int j = 0; j < Groups.Count; j++)
			{
				Groups[j].PrepareINTERNAL();
			}
		}

		private CGBounds getItemBounds(int itemIndex)
		{
			return (itemIndex < 0 || itemIndex >= mBounds.Count) ? null : mBounds[itemIndex];
		}

		private float getCrossValue(float globalF, CGBoundsGroup group)
		{
			return group.DistributionMode switch
			{
				CGBoundsGroup.DistributionModeEnum.Parent => DTMath.MapValue(-0.5f, 0.5f, CrossBase + m_CrossCurve.Evaluate(globalF) + group.PositionOffset.Next), 
				CGBoundsGroup.DistributionModeEnum.Self => DTMath.MapValue(-0.5f, 0.5f, group.PositionOffset.Next), 
				_ => 0f, 
			};
		}
	}
	[ModuleInfo("Modifier/Conform Path", ModuleName = "Conform Path", Description = "Projects a path")]
	[HelpURL("https://curvyeditor.com/doclink/cgconformpath")]
	public class ConformPath : CGModule, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[VectorEx("", "")]
		[Tooltip("The direction to raycast in ")]
		private Vector3 m_Direction = new Vector3(0f, -1f, 0f);

		[SerializeField]
		[Tooltip("The maximum raycast distance")]
		private float m_MaxDistance = 100f;

		[SerializeField]
		[Tooltip("Defines an offset shift along the raycast direction")]
		private float m_Offset;

		[SerializeField]
		[Tooltip("If enabled, the entire path is moved to the nearest possible distance. If disabled, each path point is moved individually")]
		private bool m_Warp;

		[SerializeField]
		[Tooltip("The layers to raycast against")]
		private LayerMask m_LayerMask;

		public Vector3 Direction
		{
			get
			{
				return m_Direction;
			}
			set
			{
				if (m_Direction != value)
				{
					m_Direction = value;
				}
				base.Dirty = true;
			}
		}

		public float MaxDistance
		{
			get
			{
				return m_MaxDistance;
			}
			set
			{
				if (m_MaxDistance != value)
				{
					m_MaxDistance = value;
				}
				base.Dirty = true;
			}
		}

		public float Offset
		{
			get
			{
				return m_Offset;
			}
			set
			{
				if (m_Offset != value)
				{
					m_Offset = value;
				}
				base.Dirty = true;
			}
		}

		public bool Warp
		{
			get
			{
				return m_Warp;
			}
			set
			{
				if (m_Warp != value)
				{
					m_Warp = value;
				}
				base.Dirty = true;
			}
		}

		public LayerMask LayerMask
		{
			get
			{
				return m_LayerMask;
			}
			set
			{
				if ((int)m_LayerMask != (int)value)
				{
					m_LayerMask = value;
				}
				base.Dirty = true;
			}
		}

		public float PathLength
		{
			get
			{
				if (OutPath.HasData)
				{
					return OutPath.GetData<CGPath>().Length;
				}
				return (!IsConfigured) ? 0f : InPath.SourceSlot().OnRequestPathModule.PathLength;
			}
		}

		public bool PathIsClosed => IsConfigured && InPath.SourceSlot().OnRequestPathModule.PathIsClosed;

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.LabelWidth = 80f;
		}

		public override void Reset()
		{
			base.Reset();
			Direction = new Vector3(0f, -1f, 0f);
			MaxDistance = 100f;
			Offset = 0f;
			Warp = false;
			LayerMask = 0;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			if (!requestParameter)
			{
				return null;
			}
			if ((int)LayerMask == 0)
			{
				UIMessages.Add("Please set a Layer Mask different than Nothing.");
			}
			CGPath data = InPath.GetData<CGPath>(requests);
			return new CGData[1] { Conform(base.Generator.transform, data, LayerMask, Direction, Offset, MaxDistance, Warp) };
		}

		public static CGPath Conform(Transform pathTransform, CGPath path, LayerMask layers, Vector3 projectionDirection, float offset, float rayLength, bool warp)
		{
			int count = path.Count;
			if (projectionDirection != Vector3.zero && rayLength > 0f && count > 0)
			{
				RaycastHit hitInfo;
				if (warp)
				{
					float num = float.MaxValue;
					for (int i = 0; i < count; i++)
					{
						if (Physics.Raycast(pathTransform.TransformPoint(path.Position[i]), projectionDirection, out hitInfo, rayLength, layers) && hitInfo.distance < num)
						{
							num = hitInfo.distance;
						}
					}
					if (num != float.MaxValue)
					{
						Vector3 vector = projectionDirection * (num + offset);
						for (int j = 0; j < path.Count; j++)
						{
							path.Position[j] += vector;
						}
					}
				}
				else
				{
					for (int k = 0; k < count; k++)
					{
						if (Physics.Raycast(pathTransform.TransformPoint(path.Position[k]), projectionDirection, out hitInfo, rayLength, layers))
						{
							path.Position[k] += projectionDirection * (hitInfo.distance + offset);
						}
					}
				}
			}
			return path;
		}
	}
	[ModuleInfo("Create/GameObject", ModuleName = "Create GameObject")]
	[HelpURL("https://curvyeditor.com/doclink/cgcreategameobject")]
	public class CreateGameObject : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGGameObject) }, Array = true, Name = "GameObject")]
		public CGModuleInputSlot InGameObjectArray = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGSpots) }, Name = "Spots")]
		public CGModuleInputSlot InSpots = new CGModuleInputSlot();

		[SerializeField]
		[CGResourceCollectionManager("GameObject", ShowCount = true)]
		private CGGameObjectResourceCollection m_Resources = new CGGameObjectResourceCollection();

		[Tab("General")]
		[SerializeField]
		private bool m_MakeStatic;

		[SerializeField]
		[Layer("", "")]
		private int m_Layer;

		public int Layer
		{
			get
			{
				return m_Layer;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, 32);
				if (m_Layer != num)
				{
					m_Layer = num;
				}
				base.Dirty = true;
			}
		}

		public bool MakeStatic
		{
			get
			{
				return m_MakeStatic;
			}
			set
			{
				if (m_MakeStatic != value)
				{
					m_MakeStatic = value;
				}
				base.Dirty = true;
			}
		}

		public CGGameObjectResourceCollection GameObjects => m_Resources;

		public int GameObjectCount => GameObjects.Count;

		public override void Reset()
		{
			base.Reset();
			MakeStatic = false;
			Layer = 0;
			Clear();
		}

		protected override void OnDestroy()
		{
			if (!base.Generator.Destroying)
			{
				DeleteAllPrefabPools();
			}
			base.OnDestroy();
		}

		public override void OnTemplateCreated()
		{
			Clear();
		}

		public void Clear()
		{
			for (int i = 0; i < GameObjects.Count; i++)
			{
				DeleteManagedResource("GameObject", GameObjects.Items[i], GameObjects.PoolNames[i]);
			}
			GameObjects.Items.Clear();
			GameObjects.PoolNames.Clear();
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public override void Refresh()
		{
			base.Refresh();
			List<CGGameObject> allData = InGameObjectArray.GetAllData<CGGameObject>(new CGDataRequestParameter[0]);
			CGSpots data = InSpots.GetData<CGSpots>(new CGDataRequestParameter[0]);
			Clear();
			List<IPool> allPrefabPools = GetAllPrefabPools();
			HashSet<string> hashSet = new HashSet<string>();
			if (allData.Count > 0 && data.Count > 0)
			{
				for (int i = 0; i < data.Count; i++)
				{
					CGSpot cGSpot = data.Points[i];
					int index = cGSpot.Index;
					if (index >= 0 && index < allData.Count && allData[index].Object != null)
					{
						string identifier = GetPrefabPool(allData[index].Object).Identifier;
						hashSet.Add(identifier);
						Transform transform = (Transform)AddManagedResource("GameObject", identifier, i);
						transform.gameObject.isStatic = MakeStatic;
						transform.gameObject.layer = Layer;
						transform.localPosition = cGSpot.Position;
						transform.localRotation = cGSpot.Rotation;
						transform.localScale = new Vector3(transform.localScale.x * cGSpot.Scale.x * allData[index].Scale.x, transform.localScale.y * cGSpot.Scale.y * allData[index].Scale.y, transform.localScale.z * cGSpot.Scale.z * allData[index].Scale.z);
						if (allData[index].Matrix != Matrix4x4.identity)
						{
							transform.Translate(allData[index].Translate);
							transform.Rotate(allData[index].Rotate);
						}
						GameObjects.Items.Add(transform);
						GameObjects.PoolNames.Add(identifier);
					}
				}
			}
			foreach (IPool item in allPrefabPools)
			{
				if (!hashSet.Contains(item.Identifier))
				{
					base.Generator.PoolManager.DeletePool(item);
				}
			}
		}
	}
	[ModuleInfo("Create/Mesh", ModuleName = "Create Mesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgcreatemesh")]
	public class CreateMesh : CGModule
	{
		private const string DefaultTag = "Untagged";

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Array = true, Name = "VMesh")]
		public CGModuleInputSlot InVMeshArray = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGSpots) }, Name = "Spots", Optional = true)]
		public CGModuleInputSlot InSpots = new CGModuleInputSlot();

		[SerializeField]
		[CGResourceCollectionManager("Mesh", ShowCount = true)]
		private CGMeshResourceCollection m_MeshResources = new CGMeshResourceCollection();

		[Tab("General")]
		[Tooltip("Merge meshes")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		private bool m_Combine;

		[Tooltip("Merge meshes sharing the same Index")]
		[SerializeField]
		private bool m_GroupMeshes = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGYesNoAuto m_AddNormals = CGYesNoAuto.Auto;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGYesNoAuto m_AddTangents = CGYesNoAuto.No;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_AddUV2 = true;

		[SerializeField]
		[Tooltip("If enabled, meshes will have the Static flag set, and will not be updated in Play Mode")]
		[FieldCondition("canModifyStaticFlag", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_MakeStatic;

		[SerializeField]
		[Tooltip("The Layer of the created game object")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[Layer("", "")]
		private int m_Layer;

		[SerializeField]
		[Tooltip("The Tag of the created game object")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[Tag("", "")]
		private string m_Tag = "Untagged";

		[Tab("Renderer")]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_RendererEnabled = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private ShadowCastingMode m_CastShadows = ShadowCastingMode.On;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_ReceiveShadows = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private LightProbeUsage m_LightProbeUsage = LightProbeUsage.BlendProbes;

		[HideInInspector]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_UseLightProbes = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private ReflectionProbeUsage m_ReflectionProbes = ReflectionProbeUsage.BlendProbes;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private Transform m_AnchorOverride;

		[Tab("Collider")]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGColliderEnum m_Collider = CGColliderEnum.Mesh;

		[FieldCondition("m_Collider", CGColliderEnum.Mesh, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_Convex;

		[Tooltip("Options used to enable or disable certain features in Collider mesh cooking. See Unity's MeshCollider.cookingOptions for more details")]
		[FieldCondition("m_Collider", CGColliderEnum.Mesh, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[EnumFlag("", "")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private MeshColliderCookingOptions m_CookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices;

		[Label("Auto Update", "")]
		[SerializeField]
		private bool m_AutoUpdateColliders = true;

		[SerializeField]
		private PhysicMaterial m_Material;

		private int mCurrentMeshCount;

		public bool Combine
		{
			get
			{
				return m_Combine;
			}
			set
			{
				if (m_Combine != value)
				{
					m_Combine = value;
				}
				base.Dirty = true;
			}
		}

		public bool GroupMeshes
		{
			get
			{
				return m_GroupMeshes;
			}
			set
			{
				if (m_GroupMeshes != value)
				{
					m_GroupMeshes = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto AddNormals
		{
			get
			{
				return m_AddNormals;
			}
			set
			{
				if (m_AddNormals != value)
				{
					m_AddNormals = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto AddTangents
		{
			get
			{
				return m_AddTangents;
			}
			set
			{
				if (m_AddTangents != value)
				{
					m_AddTangents = value;
				}
				base.Dirty = true;
			}
		}

		public bool AddUV2
		{
			get
			{
				return m_AddUV2;
			}
			set
			{
				if (m_AddUV2 != value)
				{
					m_AddUV2 = value;
				}
				base.Dirty = true;
			}
		}

		public int Layer
		{
			get
			{
				return m_Layer;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, 32);
				if (m_Layer != num)
				{
					m_Layer = num;
				}
				base.Dirty = true;
			}
		}

		public string Tag
		{
			get
			{
				return m_Tag;
			}
			set
			{
				if (m_Tag != value)
				{
					m_Tag = value;
				}
				base.Dirty = true;
			}
		}

		public bool MakeStatic
		{
			get
			{
				return m_MakeStatic;
			}
			set
			{
				if (m_MakeStatic != value)
				{
					m_MakeStatic = value;
				}
				base.Dirty = true;
			}
		}

		public bool RendererEnabled
		{
			get
			{
				return m_RendererEnabled;
			}
			set
			{
				if (m_RendererEnabled != value)
				{
					m_RendererEnabled = value;
				}
				base.Dirty = true;
			}
		}

		public ShadowCastingMode CastShadows
		{
			get
			{
				return m_CastShadows;
			}
			set
			{
				if (m_CastShadows != value)
				{
					m_CastShadows = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReceiveShadows
		{
			get
			{
				return m_ReceiveShadows;
			}
			set
			{
				if (m_ReceiveShadows != value)
				{
					m_ReceiveShadows = value;
				}
				base.Dirty = true;
			}
		}

		public bool UseLightProbes
		{
			get
			{
				return m_UseLightProbes;
			}
			set
			{
				if (m_UseLightProbes != value)
				{
					m_UseLightProbes = value;
				}
				base.Dirty = true;
			}
		}

		public LightProbeUsage LightProbeUsage
		{
			get
			{
				return m_LightProbeUsage;
			}
			set
			{
				if (m_LightProbeUsage != value)
				{
					m_LightProbeUsage = value;
				}
				base.Dirty = true;
			}
		}

		public ReflectionProbeUsage ReflectionProbes
		{
			get
			{
				return m_ReflectionProbes;
			}
			set
			{
				if (m_ReflectionProbes != value)
				{
					m_ReflectionProbes = value;
				}
				base.Dirty = true;
			}
		}

		public Transform AnchorOverride
		{
			get
			{
				return m_AnchorOverride;
			}
			set
			{
				if (m_AnchorOverride != value)
				{
					m_AnchorOverride = value;
				}
				base.Dirty = true;
			}
		}

		public CGColliderEnum Collider
		{
			get
			{
				return m_Collider;
			}
			set
			{
				if (m_Collider != value)
				{
					m_Collider = value;
				}
				base.Dirty = true;
			}
		}

		public bool AutoUpdateColliders
		{
			get
			{
				return m_AutoUpdateColliders;
			}
			set
			{
				if (m_AutoUpdateColliders != value)
				{
					m_AutoUpdateColliders = value;
				}
				base.Dirty = true;
			}
		}

		public bool Convex
		{
			get
			{
				return m_Convex;
			}
			set
			{
				if (m_Convex != value)
				{
					m_Convex = value;
				}
				base.Dirty = true;
			}
		}

		public MeshColliderCookingOptions CookingOptions
		{
			get
			{
				return m_CookingOptions;
			}
			set
			{
				if (m_CookingOptions != value)
				{
					m_CookingOptions = value;
				}
				base.Dirty = true;
			}
		}

		public PhysicMaterial Material
		{
			get
			{
				return m_Material;
			}
			set
			{
				if (m_Material != value)
				{
					m_Material = value;
				}
				base.Dirty = true;
			}
		}

		public CGMeshResourceCollection Meshes => m_MeshResources;

		public int MeshCount => Meshes.Count;

		public int VertexCount { get; private set; }

		private bool canGroupMeshes => InSpots.IsLinked && m_Combine;

		private bool canModifyStaticFlag => false;

		private bool canUpdate => !Application.isPlaying || !MakeStatic;

		public override void Reset()
		{
			base.Reset();
			Combine = false;
			GroupMeshes = true;
			AddNormals = CGYesNoAuto.Auto;
			AddTangents = CGYesNoAuto.No;
			MakeStatic = false;
			Material = null;
			Convex = false;
			Layer = 0;
			Tag = "Untagged";
			CastShadows = ShadowCastingMode.On;
			RendererEnabled = true;
			ReceiveShadows = true;
			UseLightProbes = true;
			LightProbeUsage = LightProbeUsage.BlendProbes;
			ReflectionProbes = ReflectionProbeUsage.BlendProbes;
			AnchorOverride = null;
			Collider = CGColliderEnum.Mesh;
			AutoUpdateColliders = true;
			Convex = false;
			AddUV2 = true;
			CookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices;
			Clear();
		}

		public override void OnTemplateCreated()
		{
			Clear();
		}

		public void Clear()
		{
			mCurrentMeshCount = 0;
			removeUnusedResource();
			Resources.UnloadUnusedAssets();
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public override void Refresh()
		{
			base.Refresh();
			if (canUpdate)
			{
				List<CGVMesh> vMeshes = InVMeshArray.GetAllData<CGVMesh>(new CGDataRequestParameter[0]);
				CGSpots spots = InSpots.GetData<CGSpots>(new CGDataRequestParameter[0]);
				mCurrentMeshCount = 0;
				VertexCount = 0;
				if (vMeshes.Count > 0 && (!InSpots.IsLinked || (spots != null && spots.Count > 0)))
				{
					if (spots != null && spots.Count > 0)
					{
						createSpotMeshes(ref vMeshes, ref spots, Combine);
					}
					else
					{
						createMeshes(ref vMeshes, Combine);
					}
				}
				removeUnusedResource();
				if (AutoUpdateColliders)
				{
					UpdateColliders();
				}
			}
			else
			{
				UIMessages.Add("In Play Mode, and when Make Static is enabled, mesh generation is stopped to avoid overriding the optimizations Unity do to static game objects'meshs.");
			}
		}

		public GameObject SaveToScene(Transform parent = null)
		{
			GetManagedResources(out var components, out var _);
			if (components.Count == 0)
			{
				return null;
			}
			if (components.Count > 1)
			{
				Transform transform = new GameObject(base.ModuleName).transform;
				transform.transform.parent = ((!(parent == null)) ? parent : base.Generator.transform.parent);
				for (int i = 0; i < components.Count; i++)
				{
					MeshFilter component = components[i].GetComponent<MeshFilter>();
					GameObject gameObject = components[i].gameObject.DuplicateGameObject(transform.transform);
					gameObject.name = components[i].name;
					gameObject.GetComponent<CGMeshResource>().Destroy();
					gameObject.GetComponent<MeshFilter>().sharedMesh = UnityEngine.Object.Instantiate(component.sharedMesh);
				}
				return transform.gameObject;
			}
			MeshFilter component2 = components[0].GetComponent<MeshFilter>();
			GameObject gameObject2 = components[0].gameObject.DuplicateGameObject(parent);
			gameObject2.name = components[0].name;
			gameObject2.GetComponent<CGMeshResource>().Destroy();
			gameObject2.GetComponent<MeshFilter>().sharedMesh = UnityEngine.Object.Instantiate(component2.sharedMesh);
			return gameObject2;
		}

		public void UpdateColliders()
		{
			bool flag = true;
			for (int i = 0; i < m_MeshResources.Count; i++)
			{
				if (!m_MeshResources.Items[i].UpdateCollider(Collider, Convex, Material, CookingOptions))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				UIMessages.Add("Error setting collider!");
			}
		}

		private void createMeshes(ref List<CGVMesh> vMeshes, bool combine)
		{
			if (combine && vMeshes.Count > 1)
			{
				int i = 0;
				while (i < vMeshes.Count)
				{
					int startIndex = i;
					int num;
					for (num = 0; i < vMeshes.Count && num + vMeshes[i].Count <= 65534; i++)
					{
						num += vMeshes[i].Count;
					}
					if (num == 0)
					{
						UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "Mesh of index {0}, and subsequent ones, skipped because vertex count {2} > {1}", i, 65534, vMeshes[i].Count));
						break;
					}
					CGVMesh vmesh = new CGVMesh();
					vmesh.MergeVMeshes(vMeshes, startIndex, i - 1);
					writeVMeshToMesh(ref vmesh);
				}
				return;
			}
			for (int j = 0; j < vMeshes.Count; j++)
			{
				CGVMesh vmesh2 = vMeshes[j];
				if (vmesh2.Count < 65534)
				{
					writeVMeshToMesh(ref vmesh2);
					continue;
				}
				UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "Mesh of index {0} skipped because vertex count {2} > {1}", j, 65534, vmesh2.Count));
			}
		}

		private void createSpotMeshes(ref List<CGVMesh> vMeshes, ref CGSpots spots, bool combine)
		{
			int num = 0;
			int count = vMeshes.Count;
			if (combine)
			{
				List<CGSpot> list = new List<CGSpot>(spots.Points);
				if (GroupMeshes)
				{
					list.Sort((CGSpot a, CGSpot b) => a.Index.CompareTo(b.Index));
				}
				CGSpot cGSpot = list[0];
				CGVMesh vmesh = new CGVMesh(vMeshes[cGSpot.Index]);
				if (cGSpot.Position != Vector3.zero || cGSpot.Rotation != Quaternion.identity || cGSpot.Scale != Vector3.one)
				{
					vmesh.TRS(cGSpot.Matrix);
				}
				for (int i = 1; i < list.Count; i++)
				{
					cGSpot = list[i];
					if (cGSpot.Index <= -1 || cGSpot.Index >= count)
					{
						continue;
					}
					if (vmesh.Count + vMeshes[cGSpot.Index].Count > 65534 || (GroupMeshes && cGSpot.Index != list[i - 1].Index))
					{
						writeVMeshToMesh(ref vmesh);
						vmesh = new CGVMesh(vMeshes[cGSpot.Index]);
						if (!cGSpot.Matrix.isIdentity)
						{
							vmesh.TRS(cGSpot.Matrix);
						}
					}
					else if (!cGSpot.Matrix.isIdentity)
					{
						vmesh.MergeVMesh(vMeshes[cGSpot.Index], cGSpot.Matrix);
					}
					else
					{
						vmesh.MergeVMesh(vMeshes[cGSpot.Index]);
					}
				}
				writeVMeshToMesh(ref vmesh);
			}
			else
			{
				for (int j = 0; j < spots.Count; j++)
				{
					CGSpot cGSpot = spots.Points[j];
					if (cGSpot.Index <= -1 || cGSpot.Index >= count)
					{
						continue;
					}
					if (vMeshes[cGSpot.Index].Count < 65535)
					{
						CGVMesh vmesh2 = vMeshes[cGSpot.Index];
						CGMeshResource cGMeshResource = writeVMeshToMesh(ref vmesh2);
						if (cGSpot.Position != Vector3.zero || cGSpot.Rotation != Quaternion.identity || cGSpot.Scale != Vector3.one)
						{
							cGSpot.ToTransform(cGMeshResource.Filter.transform);
						}
					}
					else
					{
						num++;
					}
				}
			}
			if (num > 0)
			{
				UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "{0} meshes skipped (VertexCount>65534)", num));
			}
		}

		private CGMeshResource writeVMeshToMesh(ref CGVMesh vmesh)
		{
			bool flag = AddNormals != CGYesNoAuto.No;
			bool flag2 = AddTangents != CGYesNoAuto.No;
			CGMeshResource newMesh = getNewMesh();
			if (canModifyStaticFlag)
			{
				newMesh.Filter.gameObject.isStatic = false;
			}
			Mesh msh = newMesh.Prepare();
			newMesh.gameObject.layer = Layer;
			newMesh.gameObject.tag = Tag;
			vmesh.ToMesh(ref msh);
			VertexCount += vmesh.Count;
			if (AddUV2 && !vmesh.HasUV2)
			{
				msh.uv2 = CGUtility.CalculateUV2(vmesh.UV);
			}
			if (flag && !vmesh.HasNormals)
			{
				msh.RecalculateNormals();
			}
			if (flag2 && !vmesh.HasTangents)
			{
				newMesh.Filter.CalculateTangents();
			}
			newMesh.Filter.transform.localPosition = Vector3.zero;
			newMesh.Filter.transform.localRotation = Quaternion.identity;
			newMesh.Filter.transform.localScale = Vector3.one;
			if (canModifyStaticFlag)
			{
				newMesh.Filter.gameObject.isStatic = MakeStatic;
			}
			newMesh.Renderer.sharedMaterials = vmesh.GetMaterials();
			return newMesh;
		}

		private void removeUnusedResource()
		{
			for (int i = mCurrentMeshCount; i < Meshes.Count; i++)
			{
				DeleteManagedResource("Mesh", Meshes.Items[i], string.Empty);
			}
			Meshes.Items.RemoveRange(mCurrentMeshCount, Meshes.Count - mCurrentMeshCount);
		}

		private CGMeshResource getNewMesh()
		{
			CGMeshResource cGMeshResource;
			if (mCurrentMeshCount < Meshes.Count)
			{
				cGMeshResource = Meshes.Items[mCurrentMeshCount];
				if (cGMeshResource == null)
				{
					cGMeshResource = (CGMeshResource)AddManagedResource("Mesh", string.Empty, mCurrentMeshCount);
					Meshes.Items[mCurrentMeshCount] = cGMeshResource;
				}
			}
			else
			{
				cGMeshResource = (CGMeshResource)AddManagedResource("Mesh", string.Empty, mCurrentMeshCount);
				Meshes.Items.Add(cGMeshResource);
			}
			cGMeshResource.Renderer.shadowCastingMode = CastShadows;
			cGMeshResource.Renderer.enabled = RendererEnabled;
			cGMeshResource.Renderer.receiveShadows = ReceiveShadows;
			cGMeshResource.Renderer.lightProbeUsage = LightProbeUsage;
			cGMeshResource.Renderer.reflectionProbeUsage = ReflectionProbes;
			cGMeshResource.Renderer.probeAnchor = AnchorOverride;
			if (!cGMeshResource.ColliderMatches(Collider))
			{
				cGMeshResource.RemoveCollider();
			}
			mCurrentMeshCount++;
			return cGMeshResource;
		}
	}
	[ModuleInfo("Create/Path Line Renderer", ModuleName = "Create Path Line Renderer", Description = "Feeds a Line Renderer with a Path")]
	public class CreatePathLineRenderer : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, DisplayName = "Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		private LineRenderer mLineRenderer;

		public LineRenderer LineRenderer
		{
			get
			{
				if (mLineRenderer == null)
				{
					mLineRenderer = GetComponent<LineRenderer>();
				}
				return mLineRenderer;
			}
		}

		public override bool IsConfigured => base.IsConfigured;

		public override bool IsInitialized => base.IsInitialized;

		protected override void Awake()
		{
			base.Awake();
			createLR();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
		}

		public override void Reset()
		{
			base.Reset();
		}

		public override void Refresh()
		{
			base.Refresh();
			CGPath data = InPath.GetData<CGPath>(new CGDataRequestParameter[0]);
			if (data != null)
			{
				LineRenderer.positionCount = data.Position.Length;
				LineRenderer.SetPositions(data.Position);
			}
			else
			{
				LineRenderer.positionCount = 0;
			}
		}

		private void createLR()
		{
			if (LineRenderer == null)
			{
				mLineRenderer = base.gameObject.AddComponent<LineRenderer>();
				mLineRenderer.useWorldSpace = false;
				mLineRenderer.textureMode = LineTextureMode.Tile;
				mLineRenderer.sharedMaterial = CurvyUtility.GetDefaultMaterial();
			}
		}
	}
	[ModuleInfo("Debug/Rasterized Path", ModuleName = "Debug Rasterized Path", Description = "Shows the tangents and orientation of a rasterized path")]
	public class DebugRasterizedPath : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, DisplayName = "Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[Tooltip("Display the normal at each one of the path's points")]
		public bool ShowNormals = true;

		[Tooltip("Display the orientation at each one of the path's points")]
		public bool ShowOrientation = true;

		public override void Reset()
		{
			base.Reset();
			ShowNormals = (ShowOrientation = true);
		}
	}
	[ModuleInfo("Debug/VMesh", ModuleName = "Debug VMesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgdebugvmesh")]
	public class DebugVMesh : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Name = "VMesh")]
		public CGModuleInputSlot InData = new CGModuleInputSlot();

		[Tab("General")]
		public bool ShowVertices;

		public bool ShowVertexID;

		public bool ShowUV;

		public override void Reset()
		{
			base.Reset();
			ShowVertices = false;
			ShowVertexID = false;
			ShowUV = false;
		}
	}
	[ModuleInfo("Debug/Volume", ModuleName = "Debug Volume")]
	[HelpURL("https://curvyeditor.com/doclink/cgdebugvolume")]
	public class DebugVolume : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) }, Name = "Volume")]
		public CGModuleInputSlot InData = new CGModuleInputSlot();

		[Tab("General")]
		public bool ShowPathSamples = true;

		public bool ShowCrossSamples = true;

		[FieldCondition("ShowCrossSamples", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[IntRegion(RegionIsOptional = true)]
		public IntRegion LimitCross = new IntRegion(0, 0);

		public bool ShowNormals;

		public bool ShowIndex;

		public bool ShowMap;

		public Color PathColor = Color.white;

		public Color VolumeColor = Color.gray;

		public Color NormalColor = Color.yellow;

		[Tab("Interpolate")]
		public bool Interpolate;

		[RangeEx(-1f, 1f, "Path", "")]
		public float InterpolatePathF;

		[RangeEx(-1f, 1f, "Cross", "")]
		public float InterpolateCrossF;
	}
	[ModuleInfo("Input/Game Objects", ModuleName = "Input GameObjects", Description = "")]
	[HelpURL("https://curvyeditor.com/doclink/cginputgameobject")]
	public class InputGameObject : CGModule
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGGameObject), Array = true)]
		public CGModuleOutputSlot OutGameObject = new CGModuleOutputSlot();

		[ArrayEx]
		[SerializeField]
		private List<CGGameObjectProperties> m_GameObjects = new List<CGGameObjectProperties>();

		public List<CGGameObjectProperties> GameObjects => m_GameObjects;

		public bool SupportsIPE => false;

		public override void Reset()
		{
			base.Reset();
			GameObjects.Clear();
			base.Dirty = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (!OutGameObject.IsLinked)
			{
				return;
			}
			CGGameObject[] array = new CGGameObject[GameObjects.Count];
			int newSize = 0;
			for (int i = 0; i < GameObjects.Count; i++)
			{
				if (GameObjects[i] != null)
				{
					array[newSize++] = new CGGameObject(GameObjects[i]);
				}
			}
			Array.Resize(ref array, newSize);
			OutGameObject.SetData(array);
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			GameObjects.Clear();
		}
	}
	[ModuleInfo("Input/Meshes", ModuleName = "Input Meshes", Description = "Create VMeshes")]
	[HelpURL("https://curvyeditor.com/doclink/cginputmesh")]
	public class InputMesh : CGModule, IExternalInput
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[SerializeField]
		[ArrayEx]
		private List<CGMeshProperties> m_Meshes = new List<CGMeshProperties>(new CGMeshProperties[1]
		{
			new CGMeshProperties()
		});

		public List<CGMeshProperties> Meshes => m_Meshes;

		public bool SupportsIPE => false;

		public override void Reset()
		{
			base.Reset();
			Meshes.Clear();
			base.Dirty = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (!OutVMesh.IsLinked)
			{
				return;
			}
			CGVMesh[] array = new CGVMesh[Meshes.Count];
			int newSize = 0;
			for (int i = 0; i < Meshes.Count; i++)
			{
				if ((bool)Meshes[i].Mesh)
				{
					array[newSize++] = new CGVMesh(Meshes[i]);
				}
			}
			Array.Resize(ref array, newSize);
			OutVMesh.SetData(array);
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			Meshes.Clear();
		}
	}
	[ModuleInfo("Input/Spline Path", ModuleName = "Input Spline Path", Description = "Spline Path")]
	[HelpURL("https://curvyeditor.com/doclink/cginputsplinepath")]
	public class InputSplinePath : SplineInputModuleBase, IExternalInput, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot Path = new CGModuleOutputSlot();

		[Tab("General", Sort = 0)]
		[SerializeField]
		[CGResourceManager("Spline")]
		[FieldCondition("m_Spline", null, false, ActionAttribute.ActionEnum.ShowWarning, "Create or assign spline", ActionAttribute.ActionPositionEnum.Below)]
		private CurvySpline m_Spline;

		public CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					m_Spline = value;
					OnSplineAssigned();
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool SupportsIPE => false;

		protected override CurvySpline InputSpline
		{
			get
			{
				return Spline;
			}
			set
			{
				Spline = value;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			CGDataRequestMetaCGOptions requestParameter2 = CGModule.GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);
			if ((bool)requestParameter2)
			{
				if (requestParameter2.CheckMaterialID)
				{
					requestParameter2.CheckMaterialID = false;
					UIMessages.Add("MaterialID option not supported!");
				}
				if (requestParameter2.IncludeControlPoints)
				{
					requestParameter2.IncludeControlPoints = false;
					UIMessages.Add("IncludeCP option not supported!");
				}
			}
			if (!requestParameter || requestParameter.RasterizedRelativeLength == 0f)
			{
				return null;
			}
			CGData splineData = GetSplineData(Spline, fullPath: true, requestParameter, requestParameter2);
			return new CGData[1] { splineData };
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			if ((bool)Spline && !IsManagedResource(Spline))
			{
				Spline = null;
			}
		}
	}
	[ModuleInfo("Input/Spline Shape", ModuleName = "Input Spline Shape", Description = "Spline Shape")]
	[HelpURL("https://curvyeditor.com/doclink/cginputsplineshape")]
	public class InputSplineShape : SplineInputModuleBase, IExternalInput, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		[Tab("General", Sort = 0)]
		[SerializeField]
		[CGResourceManager("Shape")]
		private CurvySpline m_Shape;

		public CurvySpline Shape
		{
			get
			{
				return m_Shape;
			}
			set
			{
				if (m_Shape != value)
				{
					m_Shape = value;
					OnSplineAssigned();
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool SupportsIPE => FreeForm;

		public bool FreeForm
		{
			get
			{
				return Shape != null && Shape.GetComponent<CurvyShape>() == null;
			}
			set
			{
				if (Shape != null)
				{
					CurvyShape component = Shape.GetComponent<CurvyShape>();
					if (value && component != null)
					{
						component.Delete();
					}
					else if (!value && component == null)
					{
						Shape.gameObject.AddComponent<CSCircle>();
					}
				}
			}
		}

		protected override CurvySpline InputSpline
		{
			get
			{
				return Shape;
			}
			set
			{
				Shape = value;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			CGDataRequestMetaCGOptions requestParameter2 = CGModule.GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);
			if (!requestParameter || requestParameter.RasterizedRelativeLength == 0f)
			{
				return null;
			}
			CGData splineData = GetSplineData(Shape, fullPath: false, requestParameter, requestParameter2);
			return new CGData[1] { splineData };
		}

		public T SetManagedShape<T>() where T : CurvyShape2D
		{
			if (!Shape)
			{
				Shape = (CurvySpline)AddManagedResource("Shape", string.Empty);
			}
			CurvyShape component = Shape.GetComponent<CurvyShape>();
			if (component != null)
			{
				component.Delete();
			}
			return Shape.gameObject.AddComponent<T>();
		}

		public void RemoveManagedShape()
		{
			if ((bool)Shape)
			{
				DeleteManagedResource("Shape", Shape, string.Empty);
			}
		}

		protected override void OnSplineAssigned()
		{
			base.OnSplineAssigned();
			if ((bool)Shape)
			{
				Shape.RestrictTo2D = true;
			}
		}
	}
	[ModuleInfo("Input/Spots", ModuleName = "Input Spots", Description = "Defines an array of placement spots")]
	[HelpURL("https://curvyeditor.com/doclink/cginputspots")]
	public class InputSpots : CGModule
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGSpots))]
		public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

		[ArrayEx]
		[SerializeField]
		private List<CGSpot> m_Spots = new List<CGSpot>();

		public List<CGSpot> Spots
		{
			get
			{
				return m_Spots;
			}
			set
			{
				if (m_Spots != value)
				{
					m_Spots = value;
				}
				base.Dirty = true;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
		}

		public override void Reset()
		{
			base.Reset();
			Spots.Clear();
			base.Dirty = true;
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
		}

		public override void Refresh()
		{
			if (OutSpots.IsLinked)
			{
				OutSpots.SetData(new CGSpots(Spots.ToArray()));
			}
		}
	}
	[ModuleInfo("Modifier/Mix Paths", ModuleName = "Mix Paths", Description = "Lerps between two paths")]
	[HelpURL("https://curvyeditor.com/doclink/cgmixpaths")]
	public class ModifierMixPaths : CGModule, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A")]
		public CGModuleInputSlot InPathA = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path B")]
		public CGModuleInputSlot InPathB = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[RangeEx(-1f, 1f, "", "", Tooltip = "Mix between the paths")]
		private float m_Mix;

		public float Mix
		{
			get
			{
				return m_Mix;
			}
			set
			{
				if (m_Mix != value)
				{
					m_Mix = value;
				}
				base.Dirty = true;
			}
		}

		public float PathLength => (!IsConfigured) ? 0f : Mathf.Max(InPathA.SourceSlot().OnRequestPathModule.PathLength, InPathB.SourceSlot().OnRequestPathModule.PathLength);

		public bool PathIsClosed => IsConfigured && InPathA.SourceSlot().OnRequestPathModule.PathIsClosed && InPathB.SourceSlot().OnRequestPathModule.PathIsClosed;

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 200f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Mix = 0f;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			if (!requestParameter)
			{
				return null;
			}
			CGPath data = InPathA.GetData<CGPath>(requests);
			CGPath data2 = InPathB.GetData<CGPath>(requests);
			return new CGData[1] { MixPath(data, data2, Mix, UIMessages) };
		}

		public static CGPath MixPath(CGPath pathA, CGPath pathB, float mix, [NotNull] List<string> warningsContainer)
		{
			CGPath cGPath = ((pathA.Count <= pathB.Count) ? pathB : pathA);
			CGPath cGPath2 = ((pathA.Count <= pathB.Count) ? pathA : pathB);
			CGPath cGPath3 = new CGPath();
			cGPath3.Direction = new Vector3[cGPath.Count];
			ModifierMixShapes.InterpolateShape(cGPath3, cGPath, cGPath2, mix, warningsContainer);
			float t = (mix + 1f) * 0.5f;
			Vector3[] array = new Vector3[cGPath.Count];
			for (int i = 0; i < cGPath.Count; i++)
			{
				float frag;
				int fIndex = cGPath2.GetFIndex(cGPath.F[i], out frag);
				Vector3 b = Vector3.SlerpUnclamped(cGPath2.Direction[fIndex], cGPath2.Direction[fIndex + 1], frag);
				ref Vector3 reference = ref array[i];
				reference = Vector3.SlerpUnclamped(cGPath.Direction[i], b, t);
			}
			cGPath3.Direction = array;
			return cGPath3;
		}
	}
	[ModuleInfo("Modifier/Mix Shapes", ModuleName = "Mix Shapes", Description = "Lerps between two shapes")]
	[HelpURL("https://curvyeditor.com/doclink/cgmixshapes")]
	public class ModifierMixShapes : CGModule, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape A")]
		public CGModuleInputSlot InShapeA = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape B")]
		public CGModuleInputSlot InShapeB = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		[SerializeField]
		[RangeEx(-1f, 1f, "", "", Tooltip = "Mix between the paths")]
		private float m_Mix;

		public float Mix
		{
			get
			{
				return m_Mix;
			}
			set
			{
				if (m_Mix != value)
				{
					m_Mix = value;
				}
				base.Dirty = true;
			}
		}

		public float PathLength => (!IsConfigured) ? 0f : Mathf.Max(InShapeA.SourceSlot().OnRequestPathModule.PathLength, InShapeB.SourceSlot().OnRequestPathModule.PathLength);

		public bool PathIsClosed => IsConfigured && InShapeA.SourceSlot().OnRequestPathModule.PathIsClosed && InShapeB.SourceSlot().OnRequestPathModule.PathIsClosed;

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 200f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Mix = 0f;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			if (!requestParameter)
			{
				return null;
			}
			CGShape data = InShapeA.GetData<CGShape>(requests);
			CGShape data2 = InShapeB.GetData<CGShape>(requests);
			CGShape cGShape = MixShapes(data, data2, Mix, UIMessages);
			return new CGData[1] { cGShape };
		}

		public static CGShape MixShapes(CGShape shapeA, CGShape shapeB, float mix, [NotNull] List<string> warningsContainer)
		{
			CGShape mainShape = ((shapeA.Count <= shapeB.Count) ? shapeB : shapeA);
			CGShape secondaryShape = ((shapeA.Count <= shapeB.Count) ? shapeA : shapeB);
			CGShape cGShape = new CGShape();
			InterpolateShape(cGShape, mainShape, secondaryShape, mix, warningsContainer);
			return cGShape;
		}

		public static void InterpolateShape([NotNull] CGShape resultShape, CGShape mainShape, CGShape secondaryShape, float mix, [NotNull] List<string> warningsContainer)
		{
			float t = (mix + 1f) * 0.5f;
			Vector3[] array = new Vector3[mainShape.Count];
			Vector3[] array2 = new Vector3[mainShape.Count];
			Bounds bounds = default(Bounds);
			for (int i = 0; i < mainShape.Count; i++)
			{
				float frag;
				int fIndex = secondaryShape.GetFIndex(mainShape.F[i], out frag);
				Vector3 b = Vector3.LerpUnclamped(secondaryShape.Position[fIndex], secondaryShape.Position[fIndex + 1], frag);
				ref Vector3 reference = ref array[i];
				reference = Vector3.LerpUnclamped(mainShape.Position[i], b, t);
				Vector3 b2 = Vector3.LerpUnclamped(secondaryShape.Normal[fIndex], secondaryShape.Normal[fIndex + 1], frag);
				ref Vector3 reference2 = ref array2[i];
				reference2 = Vector3.LerpUnclamped(mainShape.Normal[i], b2, t);
				bounds.Encapsulate(array[i]);
			}
			resultShape.Position = array;
			resultShape.Normal = array2;
			resultShape.Map = (float[])mainShape.Map.Clone();
			resultShape.F = new float[mainShape.Count];
			resultShape.Recalculate();
			resultShape.SourceF = (float[])mainShape.SourceF.Clone();
			resultShape.Bounds = bounds;
			resultShape.MaterialGroups = new List<SamplePointsMaterialGroup>(mainShape.MaterialGroups);
			if (mainShape.Closed != secondaryShape.Closed)
			{
				warningsContainer.Add("Mixing inputs with different Closed values is not supported");
			}
			if (mainShape.Seamless != secondaryShape.Seamless)
			{
				warningsContainer.Add("Mixing inputs with different Seamless values is not supported");
			}
			if (mainShape.SourceIsManaged != secondaryShape.SourceIsManaged)
			{
				warningsContainer.Add("Mixing inputs with different SourceIsManaged values is not supported");
			}
			resultShape.Closed = mainShape.Closed;
			resultShape.Seamless = mainShape.Seamless;
			resultShape.SourceIsManaged = mainShape.SourceIsManaged;
		}
	}
	[ModuleInfo("Modifier/Path Relative Translation", ModuleName = "Path Relative Translation", Description = "Translates a path relatively to it's direction, instead of relatively to the world as does the TRS Path module.")]
	[HelpURL("https://curvyeditor.com/doclink/cgpathrelativetranslation")]
	public class ModifierPathRelativeTranslation : CGModule, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[Tooltip("The translation amount")]
		private float lateralTranslation;

		public float LateralTranslation
		{
			get
			{
				return lateralTranslation;
			}
			set
			{
				if (lateralTranslation != value)
				{
					lateralTranslation = value;
					base.Dirty = true;
				}
			}
		}

		public float PathLength => (!IsConfigured) ? 0f : InPath.SourceSlot().OnRequestPathModule.PathLength;

		public bool PathIsClosed => IsConfigured && InPath.SourceSlot().OnRequestPathModule.PathIsClosed;

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutPath)
			{
				CGPath data = InPath.GetData<CGPath>(requests);
				for (int i = 0; i < data.Count; i++)
				{
					Vector3 vector = Vector3.Cross(data.Normal[i], data.Direction[i]) * lateralTranslation;
					data.Position[i].x = data.Position[i].x + vector.x;
					data.Position[i].y = data.Position[i].y + vector.y;
					data.Position[i].z = data.Position[i].z + vector.z;
				}
				data.Recalculate();
				return new CGData[1] { data };
			}
			return null;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 230f;
			Properties.LabelWidth = 165f;
		}

		public override void Reset()
		{
			base.Reset();
			LateralTranslation = 0f;
		}
	}
	[ModuleInfo("Modifier/TRS Mesh", ModuleName = "TRS Mesh", Description = "Transform,Rotate,Scale a VMesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrsmesh")]
	public class ModifierTRSMesh : TRSModuleBase
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Array = true, ModifiesData = true)]
		public CGModuleInputSlot InVMesh = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		public override void Refresh()
		{
			base.Refresh();
			if (OutVMesh.IsLinked)
			{
				List<CGVMesh> allData = InVMesh.GetAllData<CGVMesh>(new CGDataRequestParameter[0]);
				Matrix4x4 matrix = base.Matrix;
				for (int i = 0; i < allData.Count; i++)
				{
					allData[i].TRS(matrix);
				}
				OutVMesh.SetData(allData);
			}
		}
	}
	[ModuleInfo("Modifier/TRS Path", ModuleName = "TRS Path", Description = "Transform,Rotate,Scale a Path")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrspath")]
	public class ModifierTRSPath : TRSModuleBase, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		public float PathLength => (!IsConfigured) ? 0f : InPath.SourceSlot().OnRequestPathModule.PathLength;

		public bool PathIsClosed => IsConfigured && InPath.SourceSlot().OnRequestPathModule.PathIsClosed;

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutPath)
			{
				CGPath data = InPath.GetData<CGPath>(requests);
				Matrix4x4 matrix = base.Matrix;
				Matrix4x4 matrix4x = Matrix4x4.TRS(base.Transpose, Quaternion.Euler(base.Rotation), Vector3.one);
				for (int i = 0; i < data.Count; i++)
				{
					ref Vector3 reference = ref data.Position[i];
					reference = matrix.MultiplyPoint3x4(data.Position[i]);
					ref Vector3 reference2 = ref data.Normal[i];
					reference2 = matrix4x.MultiplyVector(data.Normal[i]);
				}
				data.Recalculate();
				return new CGData[1] { data };
			}
			return null;
		}
	}
	[ModuleInfo("Modifier/TRS Shape", ModuleName = "TRS Shape", Description = "Transform,Rotate,Scale a Shape")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrsshape")]
	public class ModifierTRSShape : TRSModuleBase, IOnRequestPath, IOnRequestProcessing
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape A", ModifiesData = true)]
		public CGModuleInputSlot InShape = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		public float PathLength => (!IsConfigured) ? 0f : InShape.SourceSlot().OnRequestPathModule.PathLength;

		public bool PathIsClosed => IsConfigured && InShape.SourceSlot().OnRequestPathModule.PathIsClosed;

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutShape)
			{
				CGShape data = InShape.GetData<CGShape>(requests);
				Matrix4x4 matrix = base.Matrix;
				Matrix4x4 matrix4x = Matrix4x4.TRS(base.Transpose, Quaternion.Euler(base.Rotation), Vector3.one);
				for (int i = 0; i < data.Count; i++)
				{
					ref Vector3 reference = ref data.Position[i];
					reference = matrix.MultiplyPoint3x4(data.Position[i]);
					ref Vector3 reference2 = ref data.Normal[i];
					reference2 = matrix4x.MultiplyPoint3x4(data.Normal[i]);
				}
				data.Recalculate();
				return new CGData[1] { data };
			}
			return null;
		}
	}
	[ModuleInfo("Note", ModuleName = "Note", Description = "Creates a note")]
	[HelpURL("https://curvyeditor.com/doclink/cgnote")]
	public class Note : CGModule, INoProcessing
	{
		[SerializeField]
		[TextArea(3, 10)]
		private string m_Note;

		public string NoteText
		{
			get
			{
				return m_Note;
			}
			set
			{
				if (m_Note != value)
				{
					m_Note = value;
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 200f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Note = null;
		}
	}
}
namespace FluffyUnderware.Curvy.Generator
{
	public enum CGYesNoAuto
	{
		Yes,
		No,
		Auto
	}
	public enum CGReferenceMode
	{
		Source,
		Self
	}
	public enum CGKeepAspectMode
	{
		Off,
		ScaleU,
		ScaleV
	}
	public enum CGUVEnum
	{
		U,
		V
	}
	public enum CGColliderEnum
	{
		None,
		Mesh,
		Box,
		Sphere
	}
	[Serializable]
	public struct CGSpot : IEquatable<CGSpot>
	{
		[SerializeField]
		[Label("Idx", "")]
		private int m_Index;

		[SerializeField]
		[VectorEx("Pos", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Vector3 m_Position;

		[SerializeField]
		[VectorEx("Rot", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Quaternion m_Rotation;

		[SerializeField]
		[VectorEx("Scl", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Vector3 m_Scale;

		public int Index => m_Index;

		public Vector3 Position
		{
			get
			{
				return m_Position;
			}
			set
			{
				if (m_Position != value)
				{
					m_Position = value;
				}
			}
		}

		public Quaternion Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(m_Position, m_Rotation, m_Scale);

		public CGSpot(int index)
			: this(index, Vector3.zero, Quaternion.identity, Vector3.one)
		{
		}

		public CGSpot(int index, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			m_Index = index;
			m_Position = position;
			m_Rotation = rotation;
			m_Scale = scale;
		}

		public void ToTransform(Transform transform)
		{
			transform.localPosition = Position;
			transform.localRotation = Rotation;
			transform.localScale = Scale;
		}

		public bool Equals(CGSpot other)
		{
			return m_Index == other.m_Index && m_Position.Equals(other.m_Position) && m_Rotation.Equals(other.m_Rotation) && m_Scale.Equals(other.m_Scale);
		}

		public override bool Equals(object obj)
		{
			if (object.ReferenceEquals(null, obj))
			{
				return false;
			}
			return obj is CGSpot && Equals((CGSpot)obj);
		}

		public override int GetHashCode()
		{
			int index = m_Index;
			index = (index * 397) ^ m_Position.GetHashCode();
			index = (index * 397) ^ m_Rotation.GetHashCode();
			return (index * 397) ^ m_Scale.GetHashCode();
		}

		public static bool operator ==(CGSpot left, CGSpot right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(CGSpot left, CGSpot right)
		{
			return !left.Equals(right);
		}
	}
	[Serializable]
	public class CGMaterialSettings
	{
		public bool SwapUV;

		public CGKeepAspectMode KeepAspect;

		public float UVRotation;

		public Vector2 UVOffset = Vector2.zero;

		public Vector2 UVScale = Vector2.one;
	}
	[Serializable]
	public class CGMaterialSettingsEx : CGMaterialSettings
	{
		public int MaterialID;
	}
	[Serializable]
	public class CGMeshProperties
	{
		[SerializeField]
		private Mesh m_Mesh;

		[SerializeField]
		private Material[] m_Material = new Material[0];

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Translation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public Mesh Mesh
		{
			get
			{
				return m_Mesh;
			}
			set
			{
				if (m_Mesh != value)
				{
					m_Mesh = value;
				}
				if ((bool)m_Mesh && m_Mesh.subMeshCount != m_Material.Length)
				{
					Array.Resize(ref m_Material, m_Mesh.subMeshCount);
				}
			}
		}

		public Material[] Material
		{
			get
			{
				return m_Material;
			}
			set
			{
				if (m_Material != value)
				{
					m_Material = value;
				}
			}
		}

		public Vector3 Translation
		{
			get
			{
				return m_Translation;
			}
			set
			{
				if (m_Translation != value)
				{
					m_Translation = value;
				}
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale);

		public CGMeshProperties()
		{
		}

		public CGMeshProperties(Mesh mesh)
		{
			Mesh = mesh;
			Material = ((!(mesh != null)) ? new Material[0] : new Material[mesh.subMeshCount]);
		}
	}
	[Serializable]
	public class CGGameObjectProperties
	{
		[SerializeField]
		private GameObject m_Object;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Translation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public GameObject Object
		{
			get
			{
				return m_Object;
			}
			set
			{
				if (m_Object != value)
				{
					m_Object = value;
				}
			}
		}

		public Vector3 Translation
		{
			get
			{
				return m_Translation;
			}
			set
			{
				if (m_Translation != value)
				{
					m_Translation = value;
				}
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale);

		public CGGameObjectProperties()
		{
		}

		public CGGameObjectProperties(GameObject gameObject)
		{
			Object = gameObject;
		}
	}
	[Serializable]
	public class CGBoundsGroup
	{
		public enum DistributionModeEnum
		{
			Parent,
			Self
		}

		public enum RotationModeEnum
		{
			Full,
			Direction,
			Horizontal,
			Independent
		}

		[SerializeField]
		private string m_Name;

		[SerializeField]
		private bool m_KeepTogether;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_SpaceBefore = new FloatRegion
		{
			SimpleValue = true
		};

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_SpaceAfter = new FloatRegion
		{
			SimpleValue = true
		};

		[RangeEx(0f, 1f, "", "", Slider = true, Precision = 1)]
		[SerializeField]
		private float m_Weight = 0.5f;

		[SerializeField]
		private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

		[IntRegion(UseSlider = false, RegionOptionsPropertyName = "RepeatingGroupsOptions", Options = AttributeOptionsFlags.Compact)]
		[SerializeField]
		private IntRegion m_RepeatingItems;

		[SerializeField]
		[Header("Lateral Placement")]
		private DistributionModeEnum m_DistributionMode;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = "PositionRangeOptions", UseSlider = true, Precision = 3)]
		private FloatRegion m_PositionOffset = new FloatRegion(0f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_Height = new FloatRegion(0f);

		[Header("Rotation")]
		[Label("Mode", "")]
		[SerializeField]
		private RotationModeEnum m_RotationMode;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_RotationOffset;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_RotationScatter;

		[SerializeField]
		private List<CGBoundsGroupItem> m_Items = new List<CGBoundsGroupItem>();

		private WeightedRandom<int> mItemBag;

		public string Name
		{
			get
			{
				return m_Name;
			}
			set
			{
				if (m_Name != value)
				{
					m_Name = value;
				}
			}
		}

		public bool KeepTogether
		{
			get
			{
				return m_KeepTogether;
			}
			set
			{
				if (m_KeepTogether != value)
				{
					m_KeepTogether = value;
				}
			}
		}

		public FloatRegion SpaceBefore
		{
			get
			{
				return m_SpaceBefore;
			}
			set
			{
				if (m_SpaceBefore != value)
				{
					m_SpaceBefore = value;
				}
			}
		}

		public FloatRegion SpaceAfter
		{
			get
			{
				return m_SpaceAfter;
			}
			set
			{
				if (m_SpaceAfter != value)
				{
					m_SpaceAfter = value;
				}
			}
		}

		public float Weight
		{
			get
			{
				return m_Weight;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Weight != num)
				{
					m_Weight = num;
				}
			}
		}

		public CurvyRepeatingOrderEnum RepeatingOrder
		{
			get
			{
				return m_RepeatingOrder;
			}
			set
			{
				if (m_RepeatingOrder != value)
				{
					m_RepeatingOrder = value;
				}
			}
		}

		public IntRegion RepeatingItems
		{
			get
			{
				return m_RepeatingItems;
			}
			set
			{
				if (m_RepeatingItems != value)
				{
					m_RepeatingItems = value;
				}
			}
		}

		public DistributionModeEnum DistributionMode
		{
			get
			{
				return m_DistributionMode;
			}
			set
			{
				if (m_DistributionMode != value)
				{
					m_DistributionMode = value;
				}
			}
		}

		public FloatRegion PositionOffset
		{
			get
			{
				return m_PositionOffset;
			}
			set
			{
				if (m_PositionOffset != value)
				{
					m_PositionOffset = value;
				}
			}
		}

		public FloatRegion Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				if (m_Height != value)
				{
					m_Height = value;
				}
			}
		}

		public RotationModeEnum RotationMode
		{
			get
			{
				return m_RotationMode;
			}
			set
			{
				if (m_RotationMode != value)
				{
					m_RotationMode = value;
				}
			}
		}

		public Vector3 RotationOffset
		{
			get
			{
				return m_RotationOffset;
			}
			set
			{
				if (m_RotationOffset != value)
				{
					m_RotationOffset = value;
				}
			}
		}

		public Vector3 RotationScatter
		{
			get
			{
				return m_RotationScatter;
			}
			set
			{
				if (m_RotationScatter != value)
				{
					m_RotationScatter = value;
				}
			}
		}

		public List<CGBoundsGroupItem> Items => m_Items;

		public int FirstRepeating
		{
			get
			{
				return m_RepeatingItems.From;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, Mathf.Max(0, ItemCount - 1));
				if (m_RepeatingItems.From != num)
				{
					m_RepeatingItems.From = num;
				}
			}
		}

		public int LastRepeating
		{
			get
			{
				return m_RepeatingItems.To;
			}
			set
			{
				int num = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, ItemCount - 1));
				if (m_RepeatingItems.To != num)
				{
					m_RepeatingItems.To = num;
				}
			}
		}

		public int ItemCount => Items.Count;

		private RegionOptions<int> RepeatingGroupsOptions => RegionOptions<int>.MinMax(0, Mathf.Max(0, ItemCount - 1));

		private RegionOptions<float> PositionRangeOptions => RegionOptions<float>.MinMax(-1f, 1f);

		private int lastItemIndex => Mathf.Max(0, ItemCount - 1);

		public CGBoundsGroup(string name)
		{
			Name = name;
		}

		internal void PrepareINTERNAL()
		{
			m_RepeatingItems.MakePositive();
			m_RepeatingItems.Clamp(0, ItemCount - 1);
			if (mItemBag == null)
			{
				mItemBag = new WeightedRandom<int>();
			}
			else
			{
				mItemBag.Clear();
			}
			if (Items.Count != 0 && RepeatingOrder == CurvyRepeatingOrderEnum.Random)
			{
				for (int i = FirstRepeating; i <= LastRepeating; i++)
				{
					mItemBag.Add(i, (int)(Items[i].Weight * 10f));
				}
			}
		}

		internal int getRandomItemINTERNAL()
		{
			return mItemBag.Next();
		}
	}
	[Serializable]
	public class CGBoundsGroupItem
	{
		public int Index;

		[RangeEx(0f, 1f, "", "", Slider = true, Precision = 1)]
		[SerializeField]
		private float m_Weight = 0.5f;

		public float Weight
		{
			get
			{
				return m_Weight;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Weight != num)
				{
					m_Weight = num;
				}
			}
		}
	}
	public struct ControlPointOption : IEquatable<ControlPointOption>
	{
		public float TF;

		public float Distance;

		public bool Include;

		public int MaterialID;

		public bool HardEdge;

		public float MaxStepDistance;

		public bool UVEdge;

		public bool UVShift;

		public float FirstU;

		public float SecondU;

		public ControlPointOption(float tf, float dist, bool includeAnyways, int materialID, bool hardEdge, float maxStepDistance, bool uvEdge, bool uvShift, float firstU, float secondU)
		{
			TF = tf;
			Distance = dist;
			Include = includeAnyways;
			MaterialID = materialID;
			HardEdge = hardEdge;
			if (maxStepDistance == 0f)
			{
				MaxStepDistance = float.MaxValue;
			}
			else
			{
				MaxStepDistance = maxStepDistance;
			}
			UVEdge = uvEdge;
			UVShift = uvShift;
			FirstU = firstU;
			SecondU = secondU;
		}

		public bool Equals(ControlPointOption other)
		{
			return TF.Equals(other.TF) && Distance.Equals(other.Distance) && Include == other.Include && MaterialID == other.MaterialID && HardEdge == other.HardEdge && MaxStepDistance.Equals(other.MaxStepDistance) && UVEdge == other.UVEdge && UVShift == other.UVShift && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
		}

		public override bool Equals(object obj)
		{
			if (object.ReferenceEquals(null, obj))
			{
				return false;
			}
			return obj is ControlPointOption && Equals((ControlPointOption)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = TF.GetHashCode();
			hashCode = (hashCode * 397) ^ Distance.GetHashCode();
			hashCode = (hashCode * 397) ^ Include.GetHashCode();
			hashCode = (hashCode * 397) ^ MaterialID;
			hashCode = (hashCode * 397) ^ HardEdge.GetHashCode();
			hashCode = (hashCode * 397) ^ MaxStepDistance.GetHashCode();
			hashCode = (hashCode * 397) ^ UVEdge.GetHashCode();
			hashCode = (hashCode * 397) ^ UVShift.GetHashCode();
			hashCode = (hashCode * 397) ^ FirstU.GetHashCode();
			return (hashCode * 397) ^ SecondU.GetHashCode();
		}

		public static bool operator ==(ControlPointOption left, ControlPointOption right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(ControlPointOption left, ControlPointOption right)
		{
			return !left.Equals(right);
		}
	}
	public struct SamplePointsPatch : IEquatable<SamplePointsPatch>
	{
		public int Start;

		public int Count;

		public int End
		{
			get
			{
				return Start + Count;
			}
			set
			{
				Count = Mathf.Max(0, value - Start);
			}
		}

		public int TriangleCount => Count * 2;

		public SamplePointsPatch(int start)
		{
			Start = start;
			Count = 0;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "Size={0} ({1}-{2}, {3} Tris)", Count, Start, End, TriangleCount);
		}

		public bool Equals(SamplePointsPatch other)
		{
			return Start == other.Start && Count == other.Count;
		}

		public override bool Equals(object obj)
		{
			if (object.ReferenceEquals(null, obj))
			{
				return false;
			}
			return obj is SamplePointsPatch && Equals((SamplePointsPatch)obj);
		}

		public override int GetHashCode()
		{
			return (Start * 397) ^ Count;
		}

		public static bool operator ==(SamplePointsPatch left, SamplePointsPatch right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(SamplePointsPatch left, SamplePointsPatch right)
		{
			return !left.Equals(right);
		}
	}
	public class SamplePointsMaterialGroup
	{
		public int MaterialID;

		public List<SamplePointsPatch> Patches = new List<SamplePointsPatch>();

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < Patches.Count; i++)
				{
					num += Patches[i].TriangleCount;
				}
				return num;
			}
		}

		public int StartVertex => Patches[0].Start;

		public int EndVertex => Patches[Patches.Count - 1].End;

		public int VertexCount => EndVertex - StartVertex + 1;

		public SamplePointsMaterialGroup(int materialID)
		{
			MaterialID = materialID;
		}

		public void GetLengths(CGVolume volume, out float worldLength, out float uLength)
		{
			worldLength = 0f;
			for (int i = StartVertex; i < EndVertex; i++)
			{
				worldLength += (volume.Vertex[i + 1] - volume.Vertex[i]).magnitude;
			}
			uLength = volume.CrossMap[EndVertex] - volume.CrossMap[StartVertex];
		}
	}
	public struct SamplePointUData : IEquatable<SamplePointUData>
	{
		public int Vertex;

		public bool UVEdge;

		public float FirstU;

		public float SecondU;

		public SamplePointUData(int vt, bool uvEdge, float uv0, float uv1)
		{
			Vertex = vt;
			UVEdge = uvEdge;
			FirstU = uv0;
			SecondU = uv1;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "SamplePointUData (Vertex={0},Edge={1},FirstU={2},SecondU={3}", Vertex, UVEdge, FirstU, SecondU);
		}

		public bool Equals(SamplePointUData other)
		{
			return Vertex == other.Vertex && UVEdge == other.UVEdge && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
		}

		public override bool Equals(object obj)
		{
			if (object.ReferenceEquals(null, obj))
			{
				return false;
			}
			return obj is SamplePointUData && Equals((SamplePointUData)obj);
		}

		public override int GetHashCode()
		{
			int vertex = Vertex;
			vertex = (vertex * 397) ^ UVEdge.GetHashCode();
			vertex = (vertex * 397) ^ FirstU.GetHashCode();
			return (vertex * 397) ^ SecondU.GetHashCode();
		}

		public static bool operator ==(SamplePointUData left, SamplePointUData right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(SamplePointUData left, SamplePointUData right)
		{
			return !left.Equals(right);
		}
	}
	public class SamplePointsMaterialGroupCollection : List<SamplePointsMaterialGroup>
	{
		public int MaterialID;

		public float AspectCorrection = 1f;

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i].TriangleCount;
				}
				return num;
			}
		}

		public SamplePointsMaterialGroupCollection()
		{
		}

		public SamplePointsMaterialGroupCollection(int capacity)
			: base(capacity)
		{
		}

		public SamplePointsMaterialGroupCollection(IEnumerable<SamplePointsMaterialGroup> collection)
			: base(collection)
		{
		}

		public void CalculateAspectCorrection(CGVolume volume, CGMaterialSettingsEx matSettings)
		{
			if (matSettings.KeepAspect == CGKeepAspectMode.Off)
			{
				AspectCorrection = 1f;
				return;
			}
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < base.Count; i++)
			{
				base[i].GetLengths(volume, out var worldLength, out var uLength);
				num += worldLength;
				num2 += uLength;
			}
			AspectCorrection = volume.Length / (num / num2);
		}
	}
	[Serializable]
	public class CGDataReference
	{
		[SerializeField]
		private CGModule m_Module;

		[SerializeField]
		private string m_SlotName;

		private CGModuleOutputSlot mSlot;

		public CGData[] Data => (Slot == null) ? new CGData[0] : Slot.Data;

		public CGModuleOutputSlot Slot
		{
			get
			{
				if ((mSlot == null || mSlot.Module != m_Module || mSlot.Info == null || mSlot.Info.Name != m_SlotName) && m_Module != null && m_Module.Generator != null && m_Module.Generator.IsInitialized && !string.IsNullOrEmpty(m_SlotName))
				{
					mSlot = m_Module.GetOutputSlot(m_SlotName);
				}
				return mSlot;
			}
		}

		public bool HasValue
		{
			get
			{
				CGModuleOutputSlot slot = Slot;
				return slot != null && slot.Data.Length > 0;
			}
		}

		public bool IsEmpty => string.IsNullOrEmpty(SlotName);

		public CGModule Module => m_Module;

		public string SlotName => m_SlotName;

		public CGDataReference()
		{
		}

		public CGDataReference(CGModule module, string slotName)
		{
			setINTERNAL(module, slotName);
		}

		public CGDataReference(CurvyGenerator generator, string moduleName, string slotName)
		{
			setINTERNAL(generator, moduleName, slotName);
		}

		public void Clear()
		{
			setINTERNAL(null, string.Empty);
		}

		public T GetData<T>() where T : CGData
		{
			return (Data.Length != 0) ? (Data[0] as T) : ((T)null);
		}

		public T[] GetAllData<T>() where T : CGData
		{
			return Data as T[];
		}

		public void setINTERNAL(CGModule module, string slotName)
		{
			m_Module = module;
			m_SlotName = slotName;
			mSlot = null;
		}

		public void setINTERNAL(CurvyGenerator generator, string moduleName, string slotName)
		{
			m_Module = generator.GetModule(moduleName);
			m_SlotName = slotName;
			mSlot = null;
		}
	}
	public sealed class CGDataInfoAttribute : Attribute
	{
		public readonly Color Color;

		public CGDataInfoAttribute(Color color)
		{
			Color = color;
		}

		public CGDataInfoAttribute(float r, float g, float b, float a = 1f)
		{
			Color = new Color(r, g, b, a);
		}

		public CGDataInfoAttribute(string htmlColor)
		{
			Color = htmlColor.ColorFromHtml();
		}
	}
	public class CGData
	{
		public string Name;

		public virtual int Count => 0;

		public static implicit operator bool(CGData a)
		{
			return !object.ReferenceEquals(a, null);
		}

		public virtual T Clone<T>() where T : CGData
		{
			return new CGData() as T;
		}

		protected int getGenericFIndex(ref float[] FMapArray, float fValue, out float frag)
		{
			if (fValue == 1f)
			{
				frag = 1f;
				return FMapArray.Length - 2;
			}
			fValue = Mathf.Repeat(fValue, 1f);
			for (int i = 1; i < FMapArray.Length; i++)
			{
				if (FMapArray[i] > fValue)
				{
					frag = (fValue - FMapArray[i - 1]) / (FMapArray[i] - FMapArray[i - 1]);
					return i - 1;
				}
			}
			frag = 0f;
			return 0;
		}
	}
	[CGDataInfo(0.73f, 0.87f, 0.98f, 1f)]
	public class CGShape : CGData
	{
		public float[] SourceF = new float[0];

		public float[] F = new float[0];

		public Vector3[] Position = new Vector3[0];

		public Vector3[] Normal = new Vector3[0];

		public float[] Map = new float[0];

		[Obsolete("Bounds are computed but not used by Curvy. It will be removed in a future version as an optimization")]
		public Bounds Bounds;

		public List<SamplePointsMaterialGroup> MaterialGroups = new List<SamplePointsMaterialGroup>();

		public bool SourceIsManaged;

		public bool Closed;

		public bool Seamless;

		public float Length;

		private float mCacheLastF = float.MaxValue;

		private int mCacheLastIndex;

		private float mCacheLastFrag;

		public override int Count => F.Length;

		public CGShape()
		{
		}

		public CGShape(CGShape source)
		{
			Position = (Vector3[])source.Position.Clone();
			Normal = (Vector3[])source.Normal.Clone();
			Map = (float[])source.Map.Clone();
			F = (float[])source.F.Clone();
			SourceF = (float[])source.SourceF.Clone();
			MaterialGroups = new List<SamplePointsMaterialGroup>(source.MaterialGroups);
			Closed = source.Closed;
			Seamless = source.Seamless;
			Length = source.Length;
			Bounds = source.Bounds;
			SourceIsManaged = source.SourceIsManaged;
		}

		public override T Clone<T>()
		{
			return new CGShape(this) as T;
		}

		public static void Copy(CGShape dest, CGShape source)
		{
			Array.Resize(ref dest.Position, source.Position.Length);
			source.Position.CopyTo(dest.Position, 0);
			Array.Resize(ref dest.Normal, source.Normal.Length);
			source.Normal.CopyTo(dest.Normal, 0);
			Array.Resize(ref dest.Map, source.Map.Length);
			source.Map.CopyTo(dest.Map, 0);
			Array.Resize(ref dest.F, source.F.Length);
			source.F.CopyTo(dest.F, 0);
			Array.Resize(ref dest.SourceF, source.SourceF.Length);
			source.SourceF.CopyTo(dest.SourceF, 0);
			dest.MaterialGroups = new List<SamplePointsMaterialGroup>(source.MaterialGroups);
			dest.Bounds = source.Bounds;
			dest.Closed = source.Closed;
			dest.Seamless = source.Seamless;
			dest.Length = source.Length;
		}

		public float DistanceToF(float distance)
		{
			return Mathf.Clamp(distance, 0f, Length) / Length;
		}

		public float FToDistance(float f)
		{
			return Mathf.Clamp01(f) * Length;
		}

		public int GetFIndex(float f, out float frag)
		{
			if (mCacheLastF != f)
			{
				mCacheLastF = f;
				mCacheLastIndex = getGenericFIndex(ref F, f, out mCacheLastFrag);
			}
			frag = mCacheLastFrag;
			return mCacheLastIndex;
		}

		public Vector3 InterpolatePosition(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Vector3.LerpUnclamped(Position[fIndex], Position[fIndex + 1], frag);
		}

		public Vector3 InterpolateUp(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Interpolate(float f, out Vector3 pos, out Vector3 up)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			pos = Vector3.LerpUnclamped(Position[fIndex], Position[fIndex + 1], frag);
			up = Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Move(ref float f, ref int direction, float speed, CurvyClamping clamping)
		{
			f = CurvyUtility.ClampTF(f + speed, ref direction, clamping);
		}

		public void MoveBy(ref float f, ref int direction, float speedDist, CurvyClamping clamping)
		{
			float distance = CurvyUtility.ClampDistance(FToDistance(f) + speedDist * (float)direction, ref direction, clamping, Length);
			f = DistanceToF(distance);
		}

		public virtual void Recalculate()
		{
			Length = 0f;
			float[] array = new float[Count];
			for (int i = 1; i < Count; i++)
			{
				array[i] = array[i - 1] + (Position[i] - Position[i - 1]).magnitude;
			}
			if (Count <= 0)
			{
				return;
			}
			Length = array[Count - 1];
			if (Length > 0f)
			{
				F[0] = 0f;
				for (int j = 1; j < Count - 1; j++)
				{
					F[j] = array[j] / Length;
				}
				F[Count - 1] = 1f;
			}
			else
			{
				F = new float[Count];
			}
		}

		public void RecalculateNormals(List<int> softEdges)
		{
			if (Normal.Length != Position.Length)
			{
				Array.Resize(ref Normal, Position.Length);
			}
			for (int i = 0; i < MaterialGroups.Count; i++)
			{
				for (int j = 0; j < MaterialGroups[i].Patches.Count; j++)
				{
					SamplePointsPatch samplePointsPatch = MaterialGroups[i].Patches[j];
					Vector3 normalized;
					for (int k = 0; k < samplePointsPatch.Count; k++)
					{
						int num = samplePointsPatch.Start + k;
						normalized = (Position[num + 1] - Position[num]).normalized;
						ref Vector3 reference = ref Normal[num];
						reference = new Vector3(0f - normalized.y, normalized.x, 0f);
					}
					normalized = (Position[samplePointsPatch.End] - Position[samplePointsPatch.End - 1]).normalized;
					ref Vector3 reference2 = ref Normal[samplePointsPatch.End];
					reference2 = new Vector3(0f - normalized.y, normalized.x, 0f);
				}
			}
			for (int l = 0; l < softEdges.Count; l++)
			{
				int num2 = softEdges[l] - 1;
				if (num2 < 0)
				{
					num2 = Position.Length - 1;
				}
				int num3 = num2 - 1;
				int num4 = softEdges[l] + 1;
				if (num4 == Position.Length)
				{
					num4 = 0;
				}
				ref Vector3 reference3 = ref Normal[softEdges[l]];
				reference3 = Vector3.Slerp(Normal[num3], Normal[num4], 0.5f);
				ref Vector3 reference4 = ref Normal[num2];
				reference4 = Normal[softEdges[l]];
			}
		}
	}
	[CGDataInfo(0.13f, 0.59f, 0.95f, 1f)]
	public class CGPath : CGShape
	{
		public Vector3[] Direction = new Vector3[0];

		public CGPath()
		{
		}

		public CGPath(CGPath source)
			: base(source)
		{
			Direction = (Vector3[])source.Direction.Clone();
		}

		public override T Clone<T>()
		{
			return new CGPath(this) as T;
		}

		public static void Copy(CGPath dest, CGPath source)
		{
			CGShape.Copy(dest, source);
			Array.Resize(ref dest.Direction, source.Direction.Length);
			source.Direction.CopyTo(dest.Direction, 0);
		}

		public void Interpolate(float f, out Vector3 pos, out Vector3 dir, out Vector3 up)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			pos = Vector3.LerpUnclamped(Position[fIndex], Position[fIndex + 1], frag);
			dir = Vector3.SlerpUnclamped(Direction[fIndex], Direction[fIndex + 1], frag);
			up = Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Interpolate(float f, float angleF, out Vector3 pos, out Vector3 dir, out Vector3 up)
		{
			Interpolate(f, out pos, out dir, out up);
			if (angleF != 0f)
			{
				Quaternion quaternion = Quaternion.AngleAxis(angleF * -360f, dir);
				up = quaternion * up;
			}
		}

		public Vector3 InterpolateDirection(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Vector3.SlerpUnclamped(Direction[fIndex], Direction[fIndex + 1], frag);
		}

		public override void Recalculate()
		{
			base.Recalculate();
			for (int i = 1; i < Count; i++)
			{
				Direction[i].x = Position[i].x - Position[i - 1].x;
				Direction[i].y = Position[i].y - Position[i - 1].y;
				Direction[i].z = Position[i].z - Position[i - 1].z;
				ref Vector3 reference = ref Direction[i];
				reference = Vector3.Normalize(Direction[i]);
			}
		}
	}
	[CGDataInfo(0.08f, 0.4f, 0.75f, 1f)]
	public class CGVolume : CGPath
	{
		public Vector3[] Vertex = new Vector3[0];

		public Vector3[] VertexNormal = new Vector3[0];

		public float[] CrossF = new float[0];

		public float[] CrossMap = new float[0];

		public float[] SegmentLength;

		public bool CrossClosed;

		public bool CrossSeamless;

		public float CrossFShift;

		public SamplePointsMaterialGroupCollection CrossMaterialGroups;

		public int CrossSize => CrossF.Length;

		public int VertexCount => Vertex.Length;

		public CGVolume()
		{
		}

		public CGVolume(int samplePoints, CGShape crossShape)
		{
			CrossF = (float[])crossShape.F.Clone();
			CrossMap = (float[])crossShape.Map.Clone();
			CrossClosed = crossShape.Closed;
			CrossSeamless = crossShape.Seamless;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			SegmentLength = new float[Count];
			Vertex = new Vector3[CrossSize * samplePoints];
			VertexNormal = new Vector3[Vertex.Length];
		}

		public CGVolume(CGPath path, CGShape crossShape)
			: base(path)
		{
			CrossF = (float[])crossShape.F.Clone();
			CrossMap = (float[])crossShape.Map.Clone();
			SegmentLength = new float[Count];
			CrossClosed = crossShape.Closed;
			CrossSeamless = crossShape.Seamless;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			Vertex = new Vector3[CrossSize * Count];
			VertexNormal = new Vector3[Vertex.Length];
		}

		public CGVolume(CGVolume source)
			: base(source)
		{
			Vertex = (Vector3[])source.Vertex.Clone();
			VertexNormal = (Vector3[])source.VertexNormal.Clone();
			CrossF = (float[])source.CrossF.Clone();
			CrossMap = (float[])source.CrossMap.Clone();
			SegmentLength = new float[Count];
			CrossClosed = source.Closed;
			CrossSeamless = source.CrossSeamless;
			CrossFShift = source.CrossFShift;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(source.CrossMaterialGroups);
		}

		public static CGVolume Get(CGVolume data, CGPath path, CGShape crossShape)
		{
			if (data == null)
			{
				return new CGVolume(path, crossShape);
			}
			CGPath.Copy(data, path);
			Array.Resize(ref data.SegmentLength, data.CrossF.Length);
			data.SegmentLength = new float[data.Count];
			Array.Resize(ref data.CrossF, crossShape.F.Length);
			crossShape.F.CopyTo(data.CrossF, 0);
			Array.Resize(ref data.CrossMap, crossShape.Map.Length);
			crossShape.Map.CopyTo(data.CrossMap, 0);
			data.CrossClosed = crossShape.Closed;
			data.CrossSeamless = crossShape.Seamless;
			data.CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			Array.Resize(ref data.Vertex, data.CrossSize * data.Position.Length);
			Array.Resize(ref data.VertexNormal, data.Vertex.Length);
			return data;
		}

		public override T Clone<T>()
		{
			return new CGVolume(this) as T;
		}

		public void InterpolateVolume(float f, float crossF, out Vector3 pos, out Vector3 dir, out Vector3 up)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex];
			Vector3 vector2 = Vertex[vertexIndex + 1];
			Vector3 vector3 = Vertex[vertexIndex + CrossSize];
			Vector3 vector5;
			Vector3 vector6;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector4 = Vertex[vertexIndex + CrossSize + 1];
				vector5 = vector4 - vector3;
				vector6 = vector4 - vector2;
				pos = vector3 - vector6 * (1f - pathFrag) + vector5 * crossFrag;
			}
			else
			{
				vector5 = vector2 - vector;
				vector6 = vector3 - vector;
				pos = vector + vector6 * pathFrag + vector5 * crossFrag;
			}
			dir = vector6.normalized;
			up = Vector3.Cross(vector6, vector5);
		}

		public Vector3 InterpolateVolumePosition(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex];
			Vector3 vector2 = Vertex[vertexIndex + 1];
			Vector3 vector3 = Vertex[vertexIndex + CrossSize];
			Vector3 vector5;
			Vector3 vector6;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector4 = Vertex[vertexIndex + CrossSize + 1];
				vector5 = vector4 - vector3;
				vector6 = vector4 - vector2;
				return vector3 - vector6 * (1f - pathFrag) + vector5 * crossFrag;
			}
			vector5 = vector2 - vector;
			vector6 = vector3 - vector;
			return vector + vector6 * pathFrag + vector5 * crossFrag;
		}

		public Vector3 InterpolateVolumeDirection(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector = Vertex[vertexIndex + 1];
				Vector3 vector2 = Vertex[vertexIndex + CrossSize + 1];
				return (vector2 - vector).normalized;
			}
			Vector3 vector3 = Vertex[vertexIndex];
			Vector3 vector4 = Vertex[vertexIndex + CrossSize];
			return (vector4 - vector3).normalized;
		}

		public Vector3 InterpolateVolumeUp(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex + 1];
			Vector3 vector2 = Vertex[vertexIndex + CrossSize];
			Vector3 rhs;
			Vector3 lhs;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector3 = Vertex[vertexIndex + CrossSize + 1];
				rhs = vector3 - vector2;
				lhs = vector3 - vector;
			}
			else
			{
				Vector3 vector4 = Vertex[vertexIndex];
				rhs = vector - vector4;
				lhs = vector2 - vector4;
			}
			return Vector3.Cross(lhs, rhs);
		}

		public float GetCrossLength(float pathF)
		{
			GetSegmentIndices(pathF, out var s0Index, out var s1Index, out var frag);
			if (SegmentLength[s0Index] == 0f)
			{
				SegmentLength[s0Index] = calcSegmentLength(s0Index);
			}
			if (SegmentLength[s1Index] == 0f)
			{
				SegmentLength[s1Index] = calcSegmentLength(s1Index);
			}
			return Mathf.LerpUnclamped(SegmentLength[s0Index], SegmentLength[s1Index], frag);
		}

		public float CrossFToDistance(float f, float crossF, CurvyClamping crossClamping = CurvyClamping.Clamp)
		{
			return GetCrossLength(f) * CurvyUtility.ClampTF(crossF, crossClamping);
		}

		public float CrossDistanceToF(float f, float distance, CurvyClamping crossClamping = CurvyClamping.Clamp)
		{
			float crossLength = GetCrossLength(f);
			return CurvyUtility.ClampDistance(distance, crossClamping, crossLength) / crossLength;
		}

		public void GetSegmentIndices(float pathF, out int s0Index, out int s1Index, out float frag)
		{
			s0Index = GetFIndex(Mathf.Repeat(pathF, 1f), out frag);
			s1Index = s0Index + 1;
		}

		public int GetSegmentIndex(int segment)
		{
			return segment * CrossSize;
		}

		public int GetCrossFIndex(float crossF, out float frag)
		{
			float num = crossF + CrossFShift;
			if (num != 1f)
			{
				return getGenericFIndex(ref CrossF, Mathf.Repeat(num, 1f), out frag);
			}
			return getGenericFIndex(ref CrossF, num, out frag);
		}

		public int GetVertexIndex(float pathF, out float pathFrag)
		{
			int fIndex = GetFIndex(pathF, out pathFrag);
			return fIndex * CrossSize;
		}

		public int GetVertexIndex(float pathF, float crossF, out float pathFrag, out float crossFrag)
		{
			int vertexIndex = GetVertexIndex(pathF, out pathFrag);
			int crossFIndex = GetCrossFIndex(crossF, out crossFrag);
			return vertexIndex + crossFIndex;
		}

		public Vector3[] GetSegmentVertices(params int[] segmentIndices)
		{
			Vector3[] array = new Vector3[CrossSize * segmentIndices.Length];
			for (int i = 0; i < segmentIndices.Length; i++)
			{
				Array.Copy(Vertex, segmentIndices[i] * CrossSize, array, i * CrossSize, CrossSize);
			}
			return array;
		}

		private float calcSegmentLength(int segmentIndex)
		{
			int num = segmentIndex * CrossSize;
			int num2 = num + CrossSize - 1;
			float num3 = 0f;
			for (int i = num; i < num2; i++)
			{
				num3 += (Vertex[i + 1] - Vertex[i]).magnitude;
			}
			return num3;
		}
	}
	[CGDataInfo(1f, 0.8f, 0.5f, 1f)]
	public class CGBounds : CGData
	{
		protected Bounds? mBounds;

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					RecalculateBounds();
				}
				return mBounds.Value;
			}
			set
			{
				if (mBounds != value)
				{
					mBounds = value;
				}
			}
		}

		public float Depth => Bounds.size.z;

		public CGBounds()
		{
		}

		public CGBounds(Bounds bounds)
		{
			Bounds = bounds;
		}

		public CGBounds(CGBounds source)
		{
			Name = source.Name;
			if (source.mBounds.HasValue)
			{
				Bounds = source.Bounds;
			}
		}

		public virtual void RecalculateBounds()
		{
			Bounds = default(Bounds);
		}

		public override T Clone<T>()
		{
			return new CGBounds(this) as T;
		}

		public static void Copy(CGBounds dest, CGBounds source)
		{
			if (source.mBounds.HasValue)
			{
				dest.Bounds = source.Bounds;
			}
		}
	}
	public class CGVSubMesh : CGData
	{
		public int[] Triangles;

		public Material Material;

		public override int Count => Triangles.Length;

		public CGVSubMesh(Material material = null)
		{
			Material = material;
			Triangles = new int[0];
		}

		public CGVSubMesh(int[] triangles, Material material = null)
		{
			Material = material;
			Triangles = triangles;
		}

		public CGVSubMesh(int triangleCount, Material material = null)
		{
			Material = material;
			Triangles = new int[triangleCount];
		}

		public CGVSubMesh(CGVSubMesh source)
		{
			Material = source.Material;
			Triangles = (int[])source.Triangles.Clone();
		}

		public override T Clone<T>()
		{
			return new CGVSubMesh(this) as T;
		}

		public static CGVSubMesh Get(CGVSubMesh data, int triangleCount, Material material = null)
		{
			if (data == null)
			{
				return new CGVSubMesh(triangleCount, material);
			}
			Array.Resize(ref data.Triangles, triangleCount);
			data.Material = material;
			return data;
		}

		public void ShiftIndices(int offset, int startIndex = 0)
		{
			for (int i = startIndex; i < Triangles.Length; i++)
			{
				Triangles[i] += offset;
			}
		}

		public void Add(CGVSubMesh other, int shiftIndexOffset = 0)
		{
			int num = Triangles.Length;
			int num2 = other.Triangles.Length;
			if (num2 != 0)
			{
				int[] triangles = Triangles;
				Triangles = new int[num + num2];
				Array.Copy(triangles, Triangles, num);
				Array.Copy(other.Triangles, 0, Triangles, num, num2);
				if (shiftIndexOffset != 0)
				{
					ShiftIndices(shiftIndexOffset, num);
				}
			}
		}
	}
	[CGDataInfo(0.98f, 0.5f, 0f, 1f)]
	public class CGVMesh : CGBounds
	{
		public Vector3[] Vertex;

		public Vector2[] UV;

		public Vector2[] UV2;

		public Vector3[] Normal;

		public Vector4[] Tangents;

		public CGVSubMesh[] SubMeshes;

		public override int Count => Vertex.Length;

		public bool HasUV => UV.Length > 0;

		public bool HasUV2 => UV2.Length > 0;

		public bool HasNormals => Normal.Length > 0;

		public bool HasTangents => Tangents.Length > 0;

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < SubMeshes.Length; i++)
				{
					num += SubMeshes[i].Triangles.Length;
				}
				return num / 3;
			}
		}

		public CGVMesh()
			: this(0)
		{
		}

		public CGVMesh(int vertexCount, bool addUV = false, bool addUV2 = false, bool addNormals = false, bool addTangents = false)
		{
			Vertex = new Vector3[vertexCount];
			UV = ((!addUV) ? new Vector2[0] : new Vector2[vertexCount]);
			UV2 = ((!addUV2) ? new Vector2[0] : new Vector2[vertexCount]);
			Normal = ((!addNormals) ? new Vector3[0] : new Vector3[vertexCount]);
			Tangents = ((!addTangents) ? new Vector4[0] : new Vector4[vertexCount]);
			SubMeshes = new CGVSubMesh[0];
		}

		public CGVMesh(CGVolume volume)
			: this(volume.Vertex.Length)
		{
			Array.Copy(volume.Vertex, Vertex, volume.Vertex.Length);
		}

		public CGVMesh(CGVolume volume, IntRegion subset)
			: this((subset.LengthPositive + 1) * volume.CrossSize, addUV: false, addUV2: false, addNormals: true)
		{
			int sourceIndex = subset.Low * volume.CrossSize;
			Array.Copy(volume.Vertex, sourceIndex, Vertex, 0, Vertex.Length);
			Array.Copy(volume.VertexNormal, sourceIndex, Normal, 0, Normal.Length);
		}

		public CGVMesh(CGVMesh source)
			: base(source)
		{
			Vertex = (Vector3[])source.Vertex.Clone();
			UV = (Vector2[])source.UV.Clone();
			UV2 = (Vector2[])source.UV2.Clone();
			Normal = (Vector3[])source.Normal.Clone();
			Tangents = (Vector4[])source.Tangents.Clone();
			SubMeshes = new CGVSubMesh[source.SubMeshes.Length];
			for (int i = 0; i < source.SubMeshes.Length; i++)
			{
				SubMeshes[i] = new CGVSubMesh(source.SubMeshes[i]);
			}
		}

		public CGVMesh(CGMeshProperties meshProperties)
			: this(meshProperties.Mesh, meshProperties.Material, meshProperties.Matrix)
		{
		}

		public CGVMesh(Mesh source, Material[] materials, Matrix4x4 trsMatrix)
		{
			Name = source.name;
			Vertex = (Vector3[])source.vertices.Clone();
			Normal = (Vector3[])source.normals.Clone();
			Tangents = (Vector4[])source.tangents.Clone();
			UV = (Vector2[])source.uv.Clone();
			UV2 = (Vector2[])source.uv2.Clone();
			SubMeshes = new CGVSubMesh[source.subMeshCount];
			for (int i = 0; i < source.subMeshCount; i++)
			{
				SubMeshes[i] = new CGVSubMesh(source.GetTriangles(i), (materials.Length <= i) ? null : materials[i]);
			}
			base.Bounds = source.bounds;
			if (!trsMatrix.isIdentity)
			{
				TRS(trsMatrix);
			}
		}

		public override T Clone<T>()
		{
			return new CGVMesh(this) as T;
		}

		public static CGVMesh Get(CGVMesh data, CGVolume source, bool addUV, bool reverseNormals)
		{
			return Get(data, source, new IntRegion(0, source.Count - 1), addUV, reverseNormals);
		}

		public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool reverseNormals)
		{
			int sourceIndex = subset.Low * source.CrossSize;
			int num = (subset.LengthPositive + 1) * source.CrossSize;
			if (data == null)
			{
				data = new CGVMesh(num, addUV, addUV2: false, addNormals: true);
			}
			else
			{
				if (data.Vertex.Length != num)
				{
					data.Vertex = new Vector3[num];
				}
				if (data.Normal.Length != num)
				{
					data.Normal = new Vector3[num];
				}
				int num2 = (addUV ? source.Vertex.Length : 0);
				if (data.UV.Length != num2)
				{
					data.UV = new Vector2[num2];
				}
				if (data.UV2.Length != 0)
				{
					data.UV2 = new Vector2[0];
				}
				if (data.Tangents.Length != 0)
				{
					data.Tangents = new Vector4[0];
				}
			}
			Array.Copy(source.Vertex, sourceIndex, data.Vertex, 0, num);
			Array.Copy(source.VertexNormal, sourceIndex, data.Normal, 0, num);
			if (reverseNormals)
			{
				for (int i = 0; i < data.Normal.Length; i++)
				{
					data.Normal[i].x = 0f - data.Normal[i].x;
					data.Normal[i].y = 0f - data.Normal[i].y;
					data.Normal[i].z = 0f - data.Normal[i].z;
				}
			}
			return data;
		}

		public void SetSubMeshCount(int count)
		{
			Array.Resize(ref SubMeshes, count);
		}

		public void AddSubMesh(CGVSubMesh submesh = null)
		{
			SubMeshes = SubMeshes.Add(submesh);
		}

		public void MergeVMesh(CGVMesh source)
		{
			int count = Count;
			copyData(ref source.Vertex, ref Vertex, count, source.Count);
			MergeUVsNormalsAndTangents(source, count);
			for (int i = 0; i < source.SubMeshes.Length; i++)
			{
				GetMaterialSubMesh(source.SubMeshes[i].Material).Add(source.SubMeshes[i], count);
			}
			mBounds = null;
		}

		public void MergeVMesh(CGVMesh source, Matrix4x4 matrix)
		{
			int count = Count;
			Array.Resize(ref Vertex, Count + source.Count);
			int count2 = Count;
			for (int i = count; i < count2; i++)
			{
				ref Vector3 reference = ref Vertex[i];
				reference = matrix.MultiplyPoint3x4(source.Vertex[i - count]);
			}
			MergeUVsNormalsAndTangents(source, count);
			for (int j = 0; j < source.SubMeshes.Length; j++)
			{
				GetMaterialSubMesh(source.SubMeshes[j].Material).Add(source.SubMeshes[j], count);
			}
			mBounds = null;
		}

		public void MergeVMeshes(List<CGVMesh> vMeshes, int startIndex, int endIndex)
		{
			int num = 0;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			Dictionary<Material, List<int[]>> dictionary = new Dictionary<Material, List<int[]>>();
			Dictionary<Material, int> dictionary2 = new Dictionary<Material, int>();
			for (int i = startIndex; i <= endIndex; i++)
			{
				CGVMesh cGVMesh = vMeshes[i];
				num += cGVMesh.Count;
				flag |= cGVMesh.HasNormals;
				flag2 |= cGVMesh.HasTangents;
				flag3 |= cGVMesh.HasUV;
				flag4 |= cGVMesh.HasUV2;
				for (int j = 0; j < cGVMesh.SubMeshes.Length; j++)
				{
					CGVSubMesh cGVSubMesh = cGVMesh.SubMeshes[j];
					if (!dictionary.ContainsKey(cGVSubMesh.Material))
					{
						dictionary[cGVSubMesh.Material] = new List<int[]>(1);
						dictionary2[cGVSubMesh.Material] = 0;
					}
					List<int[]> list = dictionary[cGVSubMesh.Material];
					list.Add(cGVSubMesh.Triangles);
				}
			}
			Vertex = new Vector3[num];
			if (flag)
			{
				Normal = new Vector3[num];
			}
			if (flag2)
			{
				Tangents = new Vector4[num];
			}
			if (flag3)
			{
				UV = new Vector2[num];
			}
			if (flag4)
			{
				UV2 = new Vector2[num];
			}
			foreach (KeyValuePair<Material, List<int[]>> item in dictionary)
			{
				List<int[]> value = item.Value;
				CGVSubMesh cGVSubMesh2 = new CGVSubMesh(item.Key);
				int num2 = 0;
				for (int k = 0; k < item.Value.Count; k++)
				{
					num2 += value[k].Length;
				}
				cGVSubMesh2.Triangles = new int[num2];
				AddSubMesh(cGVSubMesh2);
			}
			int num3 = 0;
			for (int l = startIndex; l <= endIndex; l++)
			{
				CGVMesh cGVMesh2 = vMeshes[l];
				Array.Copy(cGVMesh2.Vertex, 0, Vertex, num3, cGVMesh2.Vertex.Length);
				if (flag && cGVMesh2.HasNormals)
				{
					Array.Copy(cGVMesh2.Normal, 0, Normal, num3, cGVMesh2.Normal.Length);
				}
				if (flag2 && cGVMesh2.HasTangents)
				{
					Array.Copy(cGVMesh2.Tangents, 0, Tangents, num3, cGVMesh2.Tangents.Length);
				}
				if (flag3 && cGVMesh2.HasUV)
				{
					Array.Copy(cGVMesh2.UV, 0, UV, num3, cGVMesh2.UV.Length);
				}
				if (flag4 && cGVMesh2.HasUV2)
				{
					Array.Copy(cGVMesh2.UV2, 0, UV2, num3, cGVMesh2.UV2.Length);
				}
				for (int m = 0; m < cGVMesh2.SubMeshes.Length; m++)
				{
					CGVSubMesh cGVSubMesh3 = cGVMesh2.SubMeshes[m];
					Material material = cGVSubMesh3.Material;
					int[] triangles = cGVSubMesh3.Triangles;
					int num4 = triangles.Length;
					int[] triangles2 = GetMaterialSubMesh(material).Triangles;
					int num5 = dictionary2[material];
					if (num4 == 0)
					{
						continue;
					}
					if (num3 == 0)
					{
						Array.Copy(triangles, 0, triangles2, num5, num4);
					}
					else
					{
						for (int n = 0; n < num4; n++)
						{
							triangles2[num5 + n] = triangles[n] + num3;
						}
					}
					dictionary2[material] = num5 + num4;
				}
				num3 += cGVMesh2.Vertex.Length;
			}
		}

		private void MergeUVsNormalsAndTangents(CGVMesh source, int preMergeVertexCount)
		{
			int count = source.Count;
			if (count == 0)
			{
				return;
			}
			int num = preMergeVertexCount + count;
			if (HasUV || source.HasUV)
			{
				Vector2[] uV = UV;
				UV = new Vector2[num];
				if (HasUV)
				{
					Array.Copy(uV, UV, preMergeVertexCount);
				}
				if (source.HasUV)
				{
					Array.Copy(source.UV, 0, UV, preMergeVertexCount, count);
				}
			}
			if (HasUV2 || source.HasUV2)
			{
				Vector2[] uV2 = UV2;
				UV2 = new Vector2[num];
				if (HasUV2)
				{
					Array.Copy(uV2, UV2, preMergeVertexCount);
				}
				if (source.HasUV2)
				{
					Array.Copy(source.UV2, 0, UV2, preMergeVertexCount, count);
				}
			}
			if (HasNormals || source.HasNormals)
			{
				Vector3[] normal = Normal;
				Normal = new Vector3[num];
				if (HasNormals)
				{
					Array.Copy(normal, Normal, preMergeVertexCount);
				}
				if (source.HasNormals)
				{
					Array.Copy(source.Normal, 0, Normal, preMergeVertexCount, count);
				}
			}
			if (HasTangents || source.HasTangents)
			{
				Vector4[] tangents = Tangents;
				Tangents = new Vector4[num];
				if (HasTangents)
				{
					Array.Copy(tangents, Tangents, preMergeVertexCount);
				}
				if (source.HasTangents)
				{
					Array.Copy(source.Tangents, 0, Tangents, preMergeVertexCount, count);
				}
			}
		}

		public CGVSubMesh GetMaterialSubMesh(Material mat, bool createIfMissing = true)
		{
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				if (SubMeshes[i].Material == mat)
				{
					return SubMeshes[i];
				}
			}
			if (createIfMissing)
			{
				CGVSubMesh cGVSubMesh = new CGVSubMesh(mat);
				AddSubMesh(cGVSubMesh);
				return cGVSubMesh;
			}
			return null;
		}

		public Mesh AsMesh()
		{
			Mesh msh = new Mesh();
			ToMesh(ref msh);
			return msh;
		}

		public void ToMesh(ref Mesh msh)
		{
			msh.vertices = Vertex;
			if (HasUV)
			{
				msh.uv = UV;
			}
			if (HasUV2)
			{
				msh.uv2 = UV2;
			}
			if (HasNormals)
			{
				msh.normals = Normal;
			}
			if (HasTangents)
			{
				msh.tangents = Tangents;
			}
			msh.subMeshCount = SubMeshes.Length;
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				msh.SetTriangles(SubMeshes[i].Triangles, i);
			}
		}

		public Material[] GetMaterials()
		{
			List<Material> list = new List<Material>();
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				list.Add(SubMeshes[i].Material);
			}
			return list.ToArray();
		}

		public override void RecalculateBounds()
		{
			if (Count == 0)
			{
				mBounds = new Bounds(Vector3.zero, Vector3.zero);
				return;
			}
			Bounds value = new Bounds(Vertex[0], Vector3.zero);
			int num = Vertex.Length;
			for (int i = 1; i < num; i++)
			{
				value.Encapsulate(Vertex[i]);
			}
			mBounds = value;
		}

		public void RecalculateUV2()
		{
			UV2 = CGUtility.CalculateUV2(UV);
		}

		public void TRS(Matrix4x4 matrix)
		{
			int count = Count;
			for (int i = 0; i < count; i++)
			{
				ref Vector3 reference = ref Vertex[i];
				reference = matrix.MultiplyPoint3x4(Vertex[i]);
			}
			count = Normal.Length;
			for (int j = 0; j < count; j++)
			{
				ref Vector3 reference2 = ref Normal[j];
				reference2 = matrix.MultiplyVector(Normal[j]);
			}
			count = Tangents.Length;
			for (int k = 0; k < count; k++)
			{
				Vector3 vector = matrix.MultiplyVector(Tangents[k]);
				Tangents[k].x = vector.x;
				Tangents[k].y = vector.y;
				Tangents[k].z = vector.z;
			}
			mBounds = null;
		}

		private void copyData<T>(ref T[] src, ref T[] dst, int currentSize, int extraSize)
		{
			if (extraSize != 0)
			{
				T[] sourceArray = dst;
				dst = new T[currentSize + extraSize];
				Array.Copy(sourceArray, dst, currentSize);
				Array.Copy(src, 0, dst, currentSize, extraSize);
			}
		}
	}
	[CGDataInfo("#FFF59D")]
	public class CGGameObject : CGBounds
	{
		public GameObject Object;

		public Vector3 Translate;

		public Vector3 Rotate;

		public Vector3 Scale = Vector3.one;

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translate, Quaternion.Euler(Rotate), Scale);

		public CGGameObject()
		{
		}

		public CGGameObject(CGGameObjectProperties properties)
			: this(properties.Object, properties.Translation, properties.Rotation, properties.Scale)
		{
		}

		public CGGameObject(GameObject obj)
			: this(obj, Vector3.zero, Vector3.zero, Vector3.one)
		{
		}

		public CGGameObject(GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
		{
			Object = obj;
			Translate = translate;
			Rotate = rotate;
			Scale = scale;
			if ((bool)Object)
			{
				Name = Object.name;
			}
		}

		public CGGameObject(CGGameObject source)
			: base(source)
		{
			Object = source.Object;
			Translate = source.Translate;
			Rotate = source.Rotate;
			Scale = source.Scale;
		}

		public override T Clone<T>()
		{
			return new CGGameObject(this) as T;
		}

		public static CGGameObject Get(CGGameObject data, GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
		{
			if (data == null)
			{
				return new CGGameObject(obj);
			}
			data.Object = obj;
			data.Name = ((!(obj != null)) ? null : obj.name);
			data.Translate = translate;
			data.Rotate = rotate;
			data.Scale = scale;
			return data;
		}

		public override void RecalculateBounds()
		{
			if (Object == null)
			{
				mBounds = default(Bounds);
				return;
			}
			Renderer[] componentsInChildren = Object.GetComponentsInChildren<Renderer>(includeInactive: true);
			Collider[] componentsInChildren2 = Object.GetComponentsInChildren<Collider>(includeInactive: true);
			Bounds value;
			if (componentsInChildren.Length > 0)
			{
				value = componentsInChildren[0].bounds;
				for (int i = 1; i < componentsInChildren.Length; i++)
				{
					value.Encapsulate(componentsInChildren[i].bounds);
				}
				for (int j = 0; j < componentsInChildren2.Length; j++)
				{
					value.Encapsulate(componentsInChildren2[j].bounds);
				}
			}
			else if (componentsInChildren2.Length > 0)
			{
				value = componentsInChildren2[0].bounds;
				for (int k = 1; k < componentsInChildren2.Length; k++)
				{
					value.Encapsulate(componentsInChildren2[k].bounds);
				}
			}
			else
			{
				value = default(Bounds);
			}
			value.size = new Vector3(value.size.x * Scale.x, value.size.y * Scale.y, value.size.z * Scale.z);
			mBounds = value;
		}
	}
	[CGDataInfo(0.96f, 0.96f, 0.96f, 1f)]
	public class CGSpots : CGData
	{
		public CGSpot[] Points;

		public override int Count => Points.Length;

		public CGSpots()
		{
			Points = new CGSpot[0];
		}

		public CGSpots(params CGSpot[] points)
		{
			Points = points;
		}

		public CGSpots(params List<CGSpot>[] lists)
		{
			int num = 0;
			for (int i = 0; i < lists.Length; i++)
			{
				num += lists[i].Count;
			}
			Points = new CGSpot[num];
			num = 0;
			for (int j = 0; j < lists.Length; j++)
			{
				lists[j].CopyTo(Points, num);
				num += lists[j].Count;
			}
		}

		public CGSpots(CGSpots source)
		{
			Points = source.Points;
		}

		public override T Clone<T>()
		{
			return new CGSpots(this) as T;
		}
	}
	public class CGDataRequestParameter
	{
		public static implicit operator bool(CGDataRequestParameter a)
		{
			return !object.ReferenceEquals(a, null);
		}
	}
	public class CGDataRequestMetaCGOptions : CGDataRequestParameter
	{
		public bool CheckHardEdges;

		public bool CheckMaterialID;

		public bool IncludeControlPoints;

		public bool CheckExtendedUV;

		public CGDataRequestMetaCGOptions(bool checkEdges, bool checkMaterials, bool includeCP, bool extendedUV)
		{
			CheckHardEdges = checkEdges;
			CheckMaterialID = checkMaterials;
			IncludeControlPoints = includeCP;
			CheckExtendedUV = extendedUV;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CGDataRequestMetaCGOptions cGDataRequestMetaCGOptions))
			{
				return false;
			}
			return CheckHardEdges == cGDataRequestMetaCGOptions.CheckHardEdges && CheckMaterialID == cGDataRequestMetaCGOptions.CheckMaterialID && IncludeControlPoints == cGDataRequestMetaCGOptions.IncludeControlPoints && CheckExtendedUV == cGDataRequestMetaCGOptions.CheckExtendedUV;
		}

		public override int GetHashCode()
		{
			return new
			{
				A = CheckHardEdges,
				B = CheckMaterialID,
				C = IncludeControlPoints,
				D = CheckExtendedUV
			}.GetHashCode();
		}
	}
	public class CGDataRequestRasterization : CGDataRequestParameter
	{
		public enum ModeEnum
		{
			Even,
			Optimized
		}

		public float Start;

		public float RasterizedRelativeLength;

		public int Resolution;

		public float SplineAbsoluteLength;

		public float AngleThreshold;

		public ModeEnum Mode;

		public CGDataRequestRasterization(float start, float rasterizedRelativeLength, int resolution, float splineAbsoluteLength, float angle, ModeEnum mode = ModeEnum.Even)
		{
			Start = Mathf.Repeat(start, 1f);
			RasterizedRelativeLength = Mathf.Clamp01(rasterizedRelativeLength);
			Resolution = resolution;
			SplineAbsoluteLength = splineAbsoluteLength;
			AngleThreshold = angle;
			Mode = mode;
		}

		public CGDataRequestRasterization(CGDataRequestRasterization source)
			: this(source.Start, source.RasterizedRelativeLength, source.Resolution, source.SplineAbsoluteLength, source.AngleThreshold, source.Mode)
		{
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CGDataRequestRasterization cGDataRequestRasterization))
			{
				return false;
			}
			return Start == cGDataRequestRasterization.Start && RasterizedRelativeLength == cGDataRequestRasterization.RasterizedRelativeLength && Resolution == cGDataRequestRasterization.Resolution && SplineAbsoluteLength == cGDataRequestRasterization.SplineAbsoluteLength && AngleThreshold == cGDataRequestRasterization.AngleThreshold && Mode == cGDataRequestRasterization.Mode;
		}

		public override int GetHashCode()
		{
			return new
			{
				A = Start,
				B = RasterizedRelativeLength,
				C = Resolution,
				D = AngleThreshold,
				E = Mode,
				F = SplineAbsoluteLength
			}.GetHashCode();
		}
	}
	public interface INoProcessing
	{
	}
	public interface IExternalInput
	{
		bool SupportsIPE { get; }
	}
	public interface IOnRequestProcessing
	{
		CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests);
	}
	public interface IOnRequestPath : IOnRequestProcessing
	{
		float PathLength { get; }

		bool PathIsClosed { get; }
	}
	public interface ICGResourceLoader
	{
		Component Create(CGModule cgModule, string context);

		void Destroy(CGModule cgModule, Component obj, string context, bool kill);
	}
	public interface ICGResourceCollection
	{
		int Count { get; }

		Component[] ItemsArray { get; }
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	public class CGMeshResource : DuplicateEditorMesh, IPoolable
	{
		private MeshRenderer mRenderer;

		private Collider mCollider;

		public MeshRenderer Renderer
		{
			get
			{
				if (mRenderer == null)
				{
					mRenderer = GetComponent<MeshRenderer>();
				}
				return mRenderer;
			}
		}

		public Collider Collider
		{
			get
			{
				if (mCollider == null)
				{
					mCollider = GetComponent<Collider>();
				}
				return mCollider;
			}
		}

		public Mesh Prepare()
		{
			return base.Filter.PrepareNewShared();
		}

		public bool ColliderMatches(CGColliderEnum type)
		{
			if (Collider == null && type == CGColliderEnum.None)
			{
				return true;
			}
			if (Collider is MeshCollider && type == CGColliderEnum.Mesh)
			{
				return true;
			}
			if (Collider is BoxCollider && type == CGColliderEnum.Box)
			{
				return true;
			}
			if (Collider is SphereCollider && type == CGColliderEnum.Sphere)
			{
				return true;
			}
			return false;
		}

		public void RemoveCollider()
		{
			if ((bool)Collider)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(mCollider);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(mCollider);
				}
				mCollider = null;
			}
		}

		public bool UpdateCollider(CGColliderEnum mode, bool convex, PhysicMaterial material, MeshColliderCookingOptions meshCookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices)
		{
			if (Collider == null)
			{
				switch (mode)
				{
				case CGColliderEnum.Mesh:
					mCollider = base.gameObject.AddComponent<MeshCollider>();
					break;
				case CGColliderEnum.Box:
					mCollider = base.gameObject.AddComponent<BoxCollider>();
					break;
				case CGColliderEnum.Sphere:
					mCollider = base.gameObject.AddComponent<SphereCollider>();
					break;
				default:
					throw new ArgumentOutOfRangeException();
				case CGColliderEnum.None:
					break;
				}
			}
			switch (mode)
			{
			case CGColliderEnum.Mesh:
			{
				MeshCollider meshCollider = Collider as MeshCollider;
				if (meshCollider != null)
				{
					meshCollider.sharedMesh = null;
					meshCollider.convex = convex;
					meshCollider.cookingOptions = meshCookingOptions;
					try
					{
						meshCollider.sharedMesh = base.Filter.sharedMesh;
					}
					catch
					{
						return false;
					}
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_01de;
			}
			case CGColliderEnum.Box:
			{
				BoxCollider boxCollider = Collider as BoxCollider;
				if (boxCollider != null)
				{
					boxCollider.center = base.Filter.sharedMesh.bounds.center;
					boxCollider.size = base.Filter.sharedMesh.bounds.size;
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_01de;
			}
			case CGColliderEnum.Sphere:
			{
				SphereCollider sphereCollider = Collider as SphereCollider;
				if (sphereCollider != null)
				{
					sphereCollider.center = base.Filter.sharedMesh.bounds.center;
					sphereCollider.radius = base.Filter.sharedMesh.bounds.extents.magnitude;
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_01de;
			}
			default:
				throw new ArgumentOutOfRangeException();
			case CGColliderEnum.None:
				break;
				IL_01de:
				Collider.material = material;
				break;
			}
			return true;
		}

		public void OnBeforePush()
		{
		}

		public void OnAfterPop()
		{
		}
	}
	[Serializable]
	public class CGMeshResourceCollection : ICGResourceCollection
	{
		public List<CGMeshResource> Items = new List<CGMeshResource>();

		public int Count => Items.Count;

		public Component[] ItemsArray => Items.ToArray();
	}
	[ExecuteInEditMode]
	public class CGModule : DTVersionedMonoBehaviour
	{
		[Group("Events", Expanded = false, Sort = 1000)]
		[SerializeField]
		private CurvyCGEvent m_OnBeforeRefresh = new CurvyCGEvent();

		[Group("Events")]
		[SerializeField]
		private CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

		[SerializeField]
		[HideInInspector]
		private string m_ModuleName;

		[SerializeField]
		[HideInInspector]
		private bool m_Active = true;

		[Group("Seed Options", Expanded = false, Sort = 1001)]
		[GroupCondition("usesRandom")]
		[FieldAction("CBSeedOptions", ActionAttribute.ActionEnum.Callback, ShowBelowProperty = true)]
		[SerializeField]
		private bool m_RandomizeSeed;

		[SerializeField]
		[HideInInspector]
		private int m_Seed = (int)DateTime.Now.Ticks;

		[NonSerialized]
		public List<string> UIMessages = new List<string>();

		private CurvyGenerator mGenerator;

		[SerializeField]
		[HideInInspector]
		private int m_UniqueID;

		internal int SortAncestors;

		[HideInInspector]
		public CGModuleProperties Properties = new CGModuleProperties();

		[HideInInspector]
		public List<CGModuleLink> InputLinks = new List<CGModuleLink>();

		[HideInInspector]
		public List<CGModuleLink> OutputLinks = new List<CGModuleLink>();

		private ModuleInfoAttribute mInfo;

		private bool mDirty = true;

		private bool mInitialized;

		private bool mIsConfiguredInternal;

		private bool mStateChangeDirty;

		private bool mLastIsConfiguredState;

		public CurvyCGEvent OnBeforeRefresh
		{
			get
			{
				return m_OnBeforeRefresh;
			}
			set
			{
				if (m_OnBeforeRefresh != value)
				{
					m_OnBeforeRefresh = value;
				}
			}
		}

		public CurvyCGEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public string ModuleName
		{
			get
			{
				return base.name;
			}
			set
			{
				if (base.name != value)
				{
					base.name = value;
					renameManagedResourcesINTERNAL();
				}
			}
		}

		public bool Active
		{
			get
			{
				return m_Active;
			}
			set
			{
				if (m_Active != value)
				{
					m_Active = value;
					Dirty = true;
					Generator.sortModulesINTERNAL();
				}
			}
		}

		public int Seed
		{
			get
			{
				return m_Seed;
			}
			set
			{
				if (m_Seed != value)
				{
					m_Seed = value;
				}
				Dirty = true;
			}
		}

		public bool RandomizeSeed
		{
			get
			{
				return m_RandomizeSeed;
			}
			set
			{
				if (m_RandomizeSeed != value)
				{
					m_RandomizeSeed = value;
				}
			}
		}

		public CurvyGenerator Generator => mGenerator;

		public int UniqueID => m_UniqueID;

		public bool CircularReferenceError { get; set; }

		public Dictionary<string, CGModuleInputSlot> InputByName { get; private set; }

		public Dictionary<string, CGModuleOutputSlot> OutputByName { get; private set; }

		public List<CGModuleInputSlot> Input { get; private set; }

		public List<CGModuleOutputSlot> Output { get; private set; }

		public ModuleInfoAttribute Info
		{
			get
			{
				if (mInfo == null)
				{
					mInfo = getInfo();
				}
				return mInfo;
			}
		}

		public bool Dirty
		{
			get
			{
				return mDirty;
			}
			set
			{
				if (mDirty != value)
				{
					mDirty = value;
				}
				if (mDirty)
				{
					setTreeDirtyState();
				}
				if (!(this is IOnRequestProcessing) && !(this is INoProcessing))
				{
					return;
				}
				mDirty = false;
				if (Output != null)
				{
					for (int i = 0; i < Output.Count; i++)
					{
						Output[i].LastRequestParameters = null;
					}
				}
			}
		}

		public virtual bool IsConfigured
		{
			get
			{
				if (!IsInitialized || CircularReferenceError || !Active)
				{
					mIsConfiguredInternal = false;
					return false;
				}
				int num = 0;
				for (int i = 0; i < Input.Count; i++)
				{
					InputSlotInfo inputInfo = Input[i].InputInfo;
					if (Input[i].IsLinked)
					{
						for (int j = 0; j < Input[i].Count; j++)
						{
							if (Input[i].SourceSlot(j) != null)
							{
								if (Input[i].SourceSlot(j).Module.IsConfigured)
								{
									num++;
								}
								else if (!inputInfo.Optional)
								{
									mIsConfiguredInternal = false;
									return false;
								}
							}
						}
					}
					else if (inputInfo == null || !inputInfo.Optional)
					{
						mIsConfiguredInternal = false;
						return false;
					}
				}
				mIsConfiguredInternal = num > 0 || Input.Count == 0;
				return mIsConfiguredInternal;
			}
		}

		public virtual bool IsInitialized => mInitialized;

		protected CurvyCGEventArgs OnBeforeRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnBeforeRefresh != null)
			{
				OnBeforeRefresh.Invoke(e);
			}
			return e;
		}

		protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		protected virtual void Awake()
		{
			mGenerator = GetComponentInParent<CurvyGenerator>();
		}

		protected virtual void OnEnable()
		{
			if ((bool)mGenerator)
			{
				Initialize();
				Generator.sortModulesINTERNAL();
			}
		}

		public void Initialize()
		{
			if (!mGenerator)
			{
				mGenerator = GetComponentInParent<CurvyGenerator>();
			}
			if (!mGenerator)
			{
				Invoke("Delete", 0f);
				return;
			}
			mInfo = getInfo();
			CheckForVersionUpgrade();
			if (string.IsNullOrEmpty(ModuleName))
			{
				if (string.IsNullOrEmpty(Info.ModuleName))
				{
					ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.MenuName.Substring(Info.MenuName.LastIndexOf("/", StringComparison.Ordinal) + 1));
				}
				else
				{
					ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.ModuleName);
				}
			}
			loadSlots();
			mInitialized = true;
		}

		protected virtual void OnDisable()
		{
		}

		protected virtual void OnDestroy()
		{
			bool flag = true;
			setTreeDirtyStateChange();
			if (flag && GetManagedResources(out var components, out var componentNames))
			{
				for (int num = components.Count - 1; num >= 0; num--)
				{
					DeleteManagedResource(componentNames[num], components[num], string.Empty, dontUsePool: true);
				}
			}
			List<CGModuleInputSlot> inputSlots = GetInputSlots();
			List<CGModuleOutputSlot> outputSlots = GetOutputSlots();
			foreach (CGModuleInputSlot item in inputSlots)
			{
				item.ReInitializeLinkedTargetModules();
			}
			foreach (CGModuleOutputSlot item2 in outputSlots)
			{
				item2.ReInitializeLinkedTargetModules();
			}
			if ((bool)Generator)
			{
				Generator.ModulesByID.Remove(UniqueID);
				Generator.Modules.Remove(this);
				Generator.sortModulesINTERNAL();
			}
			mInitialized = false;
		}

		private void OnDidApplyAnimationProperties()
		{
			Dirty = true;
		}

		public virtual void Refresh()
		{
			UIMessages.Clear();
		}

		public virtual void Reset()
		{
			ModuleName = ((!string.IsNullOrEmpty(Info.ModuleName)) ? Info.ModuleName : GetType().Name);
			if (OnBeforeRefresh != null)
			{
				OnBeforeRefresh.RemoveAllListeners();
			}
			if (OnRefresh != null)
			{
				OnRefresh.RemoveAllListeners();
			}
			OnBeforeRefresh = new CurvyCGEvent();
			OnRefresh = new CurvyCGEvent();
		}

		public void ReInitializeLinkedSlots()
		{
			List<CGModuleInputSlot> inputSlots = GetInputSlots();
			List<CGModuleOutputSlot> outputSlots = GetOutputSlots();
			for (int i = 0; i < inputSlots.Count; i++)
			{
				inputSlots[i].ReInitializeLinkedSlots();
			}
			for (int j = 0; j < outputSlots.Count; j++)
			{
				outputSlots[j].ReInitializeLinkedSlots();
			}
		}

		public virtual void OnStateChange()
		{
			Dirty = true;
			if (Output != null)
			{
				for (int i = 0; i < Output.Count; i++)
				{
					Output[i].ClearData();
				}
			}
		}

		public virtual void OnTemplateCreated()
		{
		}

		protected static T GetRequestParameter<T>(ref CGDataRequestParameter[] requests) where T : CGDataRequestParameter
		{
			for (int i = 0; i < requests.Length; i++)
			{
				if (requests[i] is T)
				{
					return (T)requests[i];
				}
			}
			return (T)null;
		}

		protected static void RemoveRequestParameter(ref CGDataRequestParameter[] requests, CGDataRequestParameter request)
		{
			for (int i = 0; i < requests.Length; i++)
			{
				if (requests[i] == request)
				{
					requests = requests.RemoveAt(i);
					break;
				}
			}
		}

		public CGModuleLink GetOutputLink(CGModuleOutputSlot outSlot, CGModuleInputSlot inSlot)
		{
			return GetLink(OutputLinks, outSlot, inSlot);
		}

		public List<CGModuleLink> GetOutputLinks(CGModuleOutputSlot outSlot)
		{
			return GetLinks(OutputLinks, outSlot);
		}

		public CGModuleLink GetInputLink(CGModuleInputSlot inSlot, CGModuleOutputSlot outSlot)
		{
			return GetLink(InputLinks, inSlot, outSlot);
		}

		public List<CGModuleLink> GetInputLinks(CGModuleInputSlot inSlot)
		{
			return GetLinks(InputLinks, inSlot);
		}

		private static CGModuleLink GetLink(List<CGModuleLink> lst, CGModuleSlot source, CGModuleSlot target)
		{
			for (int i = 0; i < lst.Count; i++)
			{
				if (lst[i].IsSame(source, target))
				{
					return lst[i];
				}
			}
			return null;
		}

		private static List<CGModuleLink> GetLinks(List<CGModuleLink> lst, CGModuleSlot source)
		{
			List<CGModuleLink> list = new List<CGModuleLink>();
			for (int i = 0; i < lst.Count; i++)
			{
				if (lst[i].IsFrom(source))
				{
					list.Add(lst[i]);
				}
			}
			return list;
		}

		public CGModule CopyTo(CurvyGenerator targetGenerator)
		{
			CGModule cGModule = this.DuplicateGameObject<CGModule>(targetGenerator.transform);
			cGModule.mGenerator = targetGenerator;
			cGModule.Initialize();
			cGModule.ModuleName = ModuleName;
			cGModule.ModuleName = targetGenerator.getUniqueModuleNameINTERNAL(cGModule.ModuleName);
			cGModule.SetUniqueIdINTERNAL();
			cGModule.renameManagedResourcesINTERNAL();
			return cGModule;
		}

		public Component AddManagedResource(string resourceName, string context = "", int index = -1)
		{
			Component component = CGResourceHandler.CreateResource(this, resourceName, context);
			RenameResource(resourceName + context, component, index);
			component.transform.SetParent(base.transform);
			return component;
		}

		public void DeleteManagedResource(string resourceName, Component res, string context = "", bool dontUsePool = false)
		{
			if ((bool)res)
			{
				CGResourceHandler.DestroyResource(this, resourceName, res, context, dontUsePool);
			}
		}

		public bool IsManagedResource(Component res)
		{
			return (bool)res && res.transform.parent == base.transform;
		}

		protected void RenameResource(string resourceName, Component resource, int index = -1)
		{
			resource.name = string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}", ModuleName, UniqueID, resourceName);
			if (index > -1)
			{
				resource.name += string.Format(CultureInfo.InvariantCulture, "{0:000}", index);
			}
		}

		protected PrefabPool GetPrefabPool(GameObject prefab)
		{
			return Generator.PoolManager.GetPrefabPool(UniqueID.ToString(CultureInfo.InvariantCulture) + "_" + prefab.name, prefab);
		}

		public List<IPool> GetAllPrefabPools()
		{
			return Generator.PoolManager.FindPools(UniqueID.ToString(CultureInfo.InvariantCulture) + "_");
		}

		public void DeleteAllPrefabPools()
		{
			Generator.PoolManager.DeletePools(UniqueID.ToString(CultureInfo.InvariantCulture) + "_");
		}

		public void Delete()
		{
			OnStateChange();
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public CGModuleInputSlot GetInputSlot(string name)
		{
			return (InputByName == null || !InputByName.ContainsKey(name)) ? null : InputByName[name];
		}

		public List<CGModuleInputSlot> GetInputSlots(Type filterType = null)
		{
			if (filterType == null)
			{
				return new List<CGModuleInputSlot>(Input);
			}
			List<CGModuleInputSlot> list = new List<CGModuleInputSlot>();
			for (int i = 0; i < Output.Count; i++)
			{
				if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
				{
					list.Add(Input[i]);
				}
			}
			return list;
		}

		public CGModuleOutputSlot GetOutputSlot(string name)
		{
			return (OutputByName == null || !OutputByName.ContainsKey(name)) ? null : OutputByName[name];
		}

		public List<CGModuleOutputSlot> GetOutputSlots(Type filterType = null)
		{
			if (filterType == null)
			{
				return new List<CGModuleOutputSlot>(Output);
			}
			List<CGModuleOutputSlot> list = new List<CGModuleOutputSlot>();
			for (int i = 0; i < Output.Count; i++)
			{
				if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
				{
					list.Add(Output[i]);
				}
			}
			return list;
		}

		public bool GetManagedResources(out List<Component> components, out List<string> componentNames)
		{
			components = new List<Component>();
			componentNames = new List<string>();
			FieldInfo[] allFields = GetType().GetAllFields(includeInherited: false, includePrivate: true);
			FieldInfo[] array = allFields;
			foreach (FieldInfo fieldInfo in array)
			{
				CGResourceManagerAttribute customAttribute = fieldInfo.GetCustomAttribute<CGResourceManagerAttribute>();
				if (customAttribute == null)
				{
					continue;
				}
				if (typeof(ICGResourceCollection).IsAssignableFrom(fieldInfo.FieldType))
				{
					if (!(fieldInfo.GetValue(this) is ICGResourceCollection { ItemsArray: var itemsArray }))
					{
						continue;
					}
					Component[] array2 = itemsArray;
					foreach (Component component in array2)
					{
						if (component.transform.parent == base.transform)
						{
							components.Add(component);
							componentNames.Add(customAttribute.ResourceName);
						}
					}
				}
				else
				{
					Component component2 = fieldInfo.GetValue(this) as Component;
					if ((bool)component2 && component2.transform.parent == base.transform)
					{
						components.Add(component2);
						componentNames.Add(customAttribute.ResourceName);
					}
				}
			}
			return components.Count > 0;
		}

		public int SetUniqueIdINTERNAL()
		{
			m_UniqueID = ++Generator.m_LastModuleID;
			return m_UniqueID;
		}

		internal void initializeSort()
		{
			SortAncestors = 0;
			CircularReferenceError = false;
			for (int i = 0; i < Input.Count; i++)
			{
				if (Input[i].IsLinked)
				{
					SortAncestors++;
				}
			}
		}

		internal List<CGModule> decrementChilds()
		{
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < Output.Count; i++)
			{
				for (int j = 0; j < Output[i].LinkedSlots.Count; j++)
				{
					if (--Output[i].LinkedSlots[j].Module.SortAncestors == 0)
					{
						list.Add(Output[i].LinkedSlots[j].Module);
					}
				}
			}
			return list;
		}

		internal void doRefresh()
		{
			if (RandomizeSeed)
			{
				setSeed((int)DateTime.Now.Ticks);
			}
			else
			{
				setSeed(Seed);
			}
			OnBeforeRefreshEvent(new CurvyCGEventArgs(this));
			Refresh();
			setSeed((int)DateTime.Now.Ticks);
			OnRefreshEvent(new CurvyCGEventArgs(this));
			mDirty = false;
		}

		private static void setSeed(int seed)
		{
			Random.InitState(seed);
		}

		internal ModuleInfoAttribute getInfo()
		{
			object[] customAttributes = GetType().GetCustomAttributes(typeof(ModuleInfoAttribute), inherit: true);
			return (customAttributes.Length <= 0) ? null : ((ModuleInfoAttribute)customAttributes[0]);
		}

		private bool usesRandom()
		{
			return (Info != null) & Info.UsesRandom;
		}

		private void loadSlots()
		{
			InputByName = new Dictionary<string, CGModuleInputSlot>();
			OutputByName = new Dictionary<string, CGModuleOutputSlot>();
			Input = new List<CGModuleInputSlot>();
			Output = new List<CGModuleOutputSlot>();
			FieldInfo[] allFields = GetType().GetAllFields();
			FieldInfo[] array = allFields;
			foreach (FieldInfo fieldInfo in array)
			{
				if (fieldInfo.FieldType == typeof(CGModuleInputSlot))
				{
					CGModuleInputSlot cGModuleInputSlot = (CGModuleInputSlot)fieldInfo.GetValue(this);
					cGModuleInputSlot.Module = this;
					cGModuleInputSlot.Info = getSlotInfo(fieldInfo);
					cGModuleInputSlot.ReInitializeLinkedSlots();
					InputByName.Add(cGModuleInputSlot.Info.Name, cGModuleInputSlot);
					Input.Add(cGModuleInputSlot);
				}
				else if (fieldInfo.FieldType == typeof(CGModuleOutputSlot))
				{
					CGModuleOutputSlot cGModuleOutputSlot = (CGModuleOutputSlot)fieldInfo.GetValue(this);
					cGModuleOutputSlot.Module = this;
					cGModuleOutputSlot.Info = getSlotInfo(fieldInfo);
					cGModuleOutputSlot.ReInitializeLinkedSlots();
					OutputByName.Add(cGModuleOutputSlot.Info.Name, cGModuleOutputSlot);
					Output.Add(cGModuleOutputSlot);
				}
			}
		}

		private SlotInfo getSlotInfo(FieldInfo f)
		{
			SlotInfo customAttribute = f.GetCustomAttribute<SlotInfo>();
			if (customAttribute != null)
			{
				if (string.IsNullOrEmpty(customAttribute.Name))
				{
					customAttribute.Name = f.Name.TrimStart("In").TrimStart("Out");
				}
				for (int i = 0; i < customAttribute.DataTypes.Length; i++)
				{
					if (!customAttribute.DataTypes[i].IsSubclassOf(typeof(CGData)))
					{
						Debug.LogError(string.Format(CultureInfo.InvariantCulture, "{0}, Slot '{1}': Data type needs to be subclass of CGData!", GetType().Name, customAttribute.Name));
					}
				}
				return customAttribute;
			}
			Debug.LogError("The Slot '" + f.Name + "' of type '" + f.DeclaringType.Name + "' needs a SlotInfo attribute!");
			return null;
		}

		private void setTreeDirtyStateChange()
		{
			mStateChangeDirty = true;
			if (Output == null)
			{
				return;
			}
			for (int i = 0; i < Output.Count; i++)
			{
				if (!Output[i].IsLinked)
				{
					continue;
				}
				List<CGModule> linkedModules = Output[i].GetLinkedModules();
				for (int j = 0; j < linkedModules.Count; j++)
				{
					if (linkedModules[j] != this || linkedModules[j].CircularReferenceError)
					{
						linkedModules[j].setTreeDirtyStateChange();
					}
				}
			}
		}

		private void setTreeDirtyState()
		{
			bool isConfigured = IsConfigured;
			if (mLastIsConfiguredState != isConfigured)
			{
				mStateChangeDirty = true;
			}
			mLastIsConfiguredState = isConfigured;
			if (Output == null)
			{
				return;
			}
			for (int i = 0; i < Output.Count; i++)
			{
				if (!Output[i].IsLinked)
				{
					continue;
				}
				List<CGModule> linkedModules = Output[i].GetLinkedModules();
				for (int j = 0; j < linkedModules.Count; j++)
				{
					if (linkedModules[j] != this || linkedModules[j].CircularReferenceError)
					{
						linkedModules[j].Dirty = true;
					}
				}
			}
		}

		public void checkOnStateChangedINTERNAL()
		{
			if (mStateChangeDirty)
			{
				OnStateChange();
			}
			mStateChangeDirty = false;
		}

		public void renameManagedResourcesINTERNAL()
		{
			FieldInfo[] allFields = GetType().GetAllFields(includeInherited: false, includePrivate: true);
			FieldInfo[] array = allFields;
			foreach (FieldInfo fieldInfo in array)
			{
				CGResourceManagerAttribute customAttribute = fieldInfo.GetCustomAttribute<CGResourceManagerAttribute>();
				if (customAttribute != null)
				{
					Component component = fieldInfo.GetValue(this) as Component;
					if ((bool)component && component.transform.parent == base.transform)
					{
						RenameResource(customAttribute.ResourceName, component);
					}
				}
			}
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ModuleInfoAttribute : Attribute, IComparable
	{
		public readonly string MenuName;

		public string ModuleName;

		public string Description;

		public bool UsesRandom;

		public ModuleInfoAttribute(string name)
		{
			MenuName = name;
		}

		public int CompareTo(object obj)
		{
			return string.Compare(MenuName, ((ModuleInfoAttribute)obj).MenuName, StringComparison.Ordinal);
		}
	}
	[Serializable]
	public class CGModuleProperties
	{
		public Rect Dimensions;

		public float MinWidth = 250f;

		public float LabelWidth;

		public Color BackgroundColor = Color.black;
	}
	[Serializable]
	public class CGModuleLink
	{
		[SerializeField]
		private int m_ModuleID;

		[SerializeField]
		private string m_SlotName;

		[SerializeField]
		private int m_TargetModuleID;

		[SerializeField]
		private string m_TargetSlotName;

		public int ModuleID => m_ModuleID;

		public string SlotName => m_SlotName;

		public int TargetModuleID => m_TargetModuleID;

		public string TargetSlotName => m_TargetSlotName;

		public CGModuleLink(int sourceID, string sourceSlotName, int targetID, string targetSlotName)
		{
			m_ModuleID = sourceID;
			m_SlotName = sourceSlotName;
			m_TargetModuleID = targetID;
			m_TargetSlotName = targetSlotName;
		}

		public CGModuleLink(CGModuleSlot source, CGModuleSlot target)
			: this(source.Module.UniqueID, source.Name, target.Module.UniqueID, target.Name)
		{
		}

		public bool IsSame(CGModuleLink o)
		{
			return ModuleID == o.ModuleID && SlotName == o.SlotName && TargetModuleID == o.TargetModuleID && TargetSlotName == o.m_TargetSlotName;
		}

		public bool IsSame(CGModuleSlot source, CGModuleSlot target)
		{
			return ModuleID == source.Module.UniqueID && SlotName == source.Name && TargetModuleID == target.Module.UniqueID && TargetSlotName == target.Name;
		}

		public bool IsTo(CGModuleSlot s)
		{
			return s.Module.UniqueID == TargetModuleID && s.Name == TargetSlotName;
		}

		public bool IsFrom(CGModuleSlot s)
		{
			return s.Module.UniqueID == ModuleID && s.Name == SlotName;
		}

		public bool IsUsing(CGModule module)
		{
			return ModuleID == module.UniqueID || TargetModuleID == module.UniqueID;
		}

		public bool IsBetween(CGModuleSlot one, CGModuleSlot another)
		{
			return (IsTo(one) && IsFrom(another)) || (IsTo(another) && IsFrom(one));
		}

		public void SetModuleIDIINTERNAL(int moduleID, int targetModuleID)
		{
			m_ModuleID = moduleID;
			m_TargetModuleID = targetModuleID;
		}

		public static implicit operator bool(CGModuleLink a)
		{
			return !object.ReferenceEquals(a, null);
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}({1})->{2}({3})", SlotName, ModuleID, TargetSlotName, TargetModuleID);
		}
	}
	public class CGModuleSlot
	{
		protected List<CGModuleSlot> mLinkedSlots;

		public CGModule Module { get; internal set; }

		public SlotInfo Info { get; internal set; }

		public Vector2 Origin { get; set; }

		public Rect DropZone { get; set; }

		public bool IsLinked => LinkedSlots != null && LinkedSlots.Count > 0;

		public bool IsLinkedAndConfigured
		{
			get
			{
				if (!IsLinked)
				{
					return false;
				}
				for (int i = 0; i < LinkedSlots.Count; i++)
				{
					if (!LinkedSlots[i].Module.IsConfigured)
					{
						return false;
					}
				}
				return true;
			}
		}

		public IOnRequestProcessing OnRequestModule => Module as IOnRequestProcessing;

		public IOnRequestPath OnRequestPathModule => Module as IOnRequestPath;

		public IExternalInput ExternalInput => Module as IExternalInput;

		public List<CGModuleSlot> LinkedSlots
		{
			get
			{
				if (mLinkedSlots == null)
				{
					LoadLinkedSlots();
				}
				return mLinkedSlots ?? new List<CGModuleSlot>();
			}
		}

		public int Count => LinkedSlots.Count;

		public string Name => (Info == null) ? string.Empty : Info.Name;

		public bool HasLinkTo(CGModuleSlot other)
		{
			for (int i = 0; i < LinkedSlots.Count; i++)
			{
				if (LinkedSlots[i] == other)
				{
					return true;
				}
			}
			return false;
		}

		public List<CGModule> GetLinkedModules()
		{
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < LinkedSlots.Count; i++)
			{
				list.Add(LinkedSlots[i].Module);
			}
			return list;
		}

		public virtual void LinkTo(CGModuleSlot other)
		{
			if ((bool)Module)
			{
				Module.Generator.sortModulesINTERNAL();
				Module.Dirty = true;
			}
			if ((bool)other.Module)
			{
				other.Module.Dirty = true;
			}
		}

		public virtual void UnlinkFrom(CGModuleSlot other)
		{
			if ((bool)Module)
			{
				Module.Generator.sortModulesINTERNAL();
				Module.Dirty = true;
			}
			if ((bool)other.Module)
			{
				other.Module.Dirty = true;
			}
		}

		public virtual void UnlinkAll()
		{
		}

		public void ReInitializeLinkedSlots()
		{
			mLinkedSlots = null;
		}

		public void ReInitializeLinkedTargetModules()
		{
			List<CGModule> linkedModules = GetLinkedModules();
			foreach (CGModule item in linkedModules)
			{
				if (item != null)
				{
					item.ReInitializeLinkedSlots();
				}
			}
		}

		protected virtual void LoadLinkedSlots()
		{
		}

		public static implicit operator bool(CGModuleSlot a)
		{
			return !object.ReferenceEquals(a, null);
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}: {1}.{2}", GetType().Name, Module.name, Name);
		}
	}
	[Serializable]
	public class CGModuleInputSlot : CGModuleSlot
	{
		public InputSlotInfo InputInfo => base.Info as InputSlotInfo;

		protected override void LoadLinkedSlots()
		{
			if (!base.Module.Generator.IsInitialized)
			{
				return;
			}
			base.LoadLinkedSlots();
			mLinkedSlots = new List<CGModuleSlot>();
			List<CGModuleLink> inputLinks = base.Module.GetInputLinks(this);
			foreach (CGModuleLink item in inputLinks)
			{
				CGModule module = base.Module.Generator.GetModule(item.TargetModuleID, includeOnRequestProcessing: true);
				if ((bool)module)
				{
					CGModuleOutputSlot cGModuleOutputSlot = module.OutputByName[item.TargetSlotName];
					if (!cGModuleOutputSlot.Module.GetOutputLink(cGModuleOutputSlot, this))
					{
						cGModuleOutputSlot.Module.OutputLinks.Add(new CGModuleLink(cGModuleOutputSlot, this));
						cGModuleOutputSlot.ReInitializeLinkedSlots();
					}
					if (!mLinkedSlots.Contains(cGModuleOutputSlot))
					{
						mLinkedSlots.Add(cGModuleOutputSlot);
					}
				}
				else
				{
					base.Module.InputLinks.Remove(item);
				}
			}
		}

		public override void UnlinkAll()
		{
			List<CGModuleSlot> list = new List<CGModuleSlot>(base.LinkedSlots);
			foreach (CGModuleSlot item in list)
			{
				UnlinkFrom(item);
			}
		}

		public override void LinkTo(CGModuleSlot outputSlot)
		{
			if (!HasLinkTo(outputSlot))
			{
				base.Module.InputLinks.Add(new CGModuleLink(this, outputSlot));
				outputSlot.Module.OutputLinks.Add(new CGModuleLink(outputSlot, this));
				if (!base.LinkedSlots.Contains(outputSlot))
				{
					base.LinkedSlots.Add(outputSlot);
				}
				if (!outputSlot.LinkedSlots.Contains(this))
				{
					outputSlot.LinkedSlots.Add(this);
				}
				base.LinkTo(outputSlot);
			}
		}

		public override void UnlinkFrom(CGModuleSlot outputSlot)
		{
			if (HasLinkTo(outputSlot))
			{
				CGModuleOutputSlot outSlot = (CGModuleOutputSlot)outputSlot;
				CGModuleLink inputLink = base.Module.GetInputLink(this, outSlot);
				base.Module.InputLinks.Remove(inputLink);
				CGModuleLink outputLink = outputSlot.Module.GetOutputLink(outSlot, this);
				outputSlot.Module.OutputLinks.Remove(outputLink);
				base.LinkedSlots.Remove(outputSlot);
				outputSlot.LinkedSlots.Remove(this);
				base.UnlinkFrom(outputSlot);
			}
		}

		public CGModuleOutputSlot SourceSlot(int index = 0)
		{
			return (index >= base.Count || index < 0) ? null : ((CGModuleOutputSlot)base.LinkedSlots[index]);
		}

		public bool CanLinkTo(CGModuleOutputSlot source)
		{
			return source.Module != base.Module && AreInputAndOutputSlotsCompatible(InputInfo, base.OnRequestModule != null, source.OutputInfo, source.OnRequestModule != null);
		}

		public static bool AreInputAndOutputSlotsCompatible(InputSlotInfo inputSlotInfo, bool inputSlotModuleIsOnRequest, OutputSlotInfo outputSlotInfo, bool outputSlotModuleIsOnRequest)
		{
			return inputSlotInfo.IsValidFrom(outputSlotInfo.DataType) && ((outputSlotModuleIsOnRequest && (inputSlotInfo.RequestDataOnly || inputSlotModuleIsOnRequest)) || (!outputSlotModuleIsOnRequest && !inputSlotInfo.RequestDataOnly));
		}

		private CGModule SourceModule(int index)
		{
			return (index >= base.Count || index < 0) ? null : base.LinkedSlots[index].Module;
		}

		public T GetData<T>(params CGDataRequestParameter[] requests) where T : CGData
		{
			CGData[] data = GetData<T>(0, requests);
			return (data != null && data.Length != 0) ? (data[0] as T) : ((T)null);
		}

		public List<T> GetAllData<T>(params CGDataRequestParameter[] requests) where T : CGData
		{
			List<T> list = new List<T>();
			for (int i = 0; i < base.Count; i++)
			{
				CGData[] data = GetData<T>(i, requests);
				if (data != null)
				{
					if (!base.Info.Array)
					{
						list.Add(data[0] as T);
						break;
					}
					list.Capacity += data.Length;
					for (int j = 0; j < data.Length; j++)
					{
						list.Add(data[j] as T);
					}
				}
			}
			return list;
		}

		private CGData[] GetData<T>(int slotIndex, params CGDataRequestParameter[] requests) where T : CGData
		{
			CGModuleOutputSlot cGModuleOutputSlot = SourceSlot(slotIndex);
			if ((bool)cGModuleOutputSlot)
			{
				if (!cGModuleOutputSlot.Module.Active)
				{
					return new T[0];
				}
				bool modifiesData = InputInfo.ModifiesData;
				if (cGModuleOutputSlot.Module is IOnRequestProcessing)
				{
					bool flag = cGModuleOutputSlot.Data == null || cGModuleOutputSlot.Data.Length == 0;
					if (!flag && cGModuleOutputSlot.LastRequestParameters != null && cGModuleOutputSlot.LastRequestParameters.Length == requests.Length)
					{
						for (int i = 0; i < requests.Length; i++)
						{
							if (!requests[i].Equals(cGModuleOutputSlot.LastRequestParameters[i]))
							{
								flag = true;
								break;
							}
						}
					}
					else
					{
						flag = true;
					}
					if (flag)
					{
						cGModuleOutputSlot.LastRequestParameters = requests;
						cGModuleOutputSlot.Module.UIMessages.Clear();
						cGModuleOutputSlot.SetData(((IOnRequestProcessing)cGModuleOutputSlot.Module).OnSlotDataRequest(this, cGModuleOutputSlot, requests));
					}
					if (modifiesData)
					{
						return cloneData<T>(ref cGModuleOutputSlot.Data);
					}
					return cGModuleOutputSlot.Data;
				}
				if (modifiesData)
				{
					return cloneData<T>(ref cGModuleOutputSlot.Data);
				}
				return cGModuleOutputSlot.Data;
			}
			return new CGData[0];
		}

		private static CGData[] cloneData<T>(ref CGData[] source) where T : CGData
		{
			T[] array = new T[source.Length];
			for (int i = 0; i < source.Length; i++)
			{
				array[i] = source[i].Clone<T>();
			}
			return array;
		}
	}
	[Serializable]
	public class CGModuleOutputSlot : CGModuleSlot
	{
		public CGData[] Data = new CGData[0];

		public CGDataRequestParameter[] LastRequestParameters;

		public OutputSlotInfo OutputInfo => base.Info as OutputSlotInfo;

		public bool HasData => Data != null && Data.Length > 0 && Data[0] != null;

		protected override void LoadLinkedSlots()
		{
			if (!base.Module.Generator.IsInitialized)
			{
				return;
			}
			base.LoadLinkedSlots();
			mLinkedSlots = new List<CGModuleSlot>();
			List<CGModuleLink> outputLinks = base.Module.GetOutputLinks(this);
			foreach (CGModuleLink item in outputLinks)
			{
				CGModule module = base.Module.Generator.GetModule(item.TargetModuleID, includeOnRequestProcessing: true);
				if ((bool)module)
				{
					CGModuleInputSlot cGModuleInputSlot = module.InputByName[item.TargetSlotName];
					if (!cGModuleInputSlot.Module.GetInputLink(cGModuleInputSlot, this))
					{
						cGModuleInputSlot.Module.InputLinks.Add(new CGModuleLink(cGModuleInputSlot, this));
						cGModuleInputSlot.ReInitializeLinkedSlots();
					}
					if (!mLinkedSlots.Contains(cGModuleInputSlot))
					{
						mLinkedSlots.Add(cGModuleInputSlot);
					}
				}
				else
				{
					base.Module.OutputLinks.Remove(item);
				}
			}
		}

		public override void LinkTo(CGModuleSlot inputSlot)
		{
			if (!HasLinkTo(inputSlot))
			{
				if (!inputSlot.Info.Array && inputSlot.IsLinked)
				{
					inputSlot.UnlinkAll();
				}
				base.Module.OutputLinks.Add(new CGModuleLink(this, inputSlot));
				inputSlot.Module.InputLinks.Add(new CGModuleLink(inputSlot, this));
				if (!base.LinkedSlots.Contains(inputSlot))
				{
					base.LinkedSlots.Add(inputSlot);
				}
				if (!inputSlot.LinkedSlots.Contains(this))
				{
					inputSlot.LinkedSlots.Add(this);
				}
				base.LinkTo(inputSlot);
			}
		}

		public override void UnlinkFrom(CGModuleSlot inputSlot)
		{
			if (HasLinkTo(inputSlot))
			{
				CGModuleInputSlot inSlot = (CGModuleInputSlot)inputSlot;
				CGModuleLink outputLink = base.Module.GetOutputLink(this, inSlot);
				base.Module.OutputLinks.Remove(outputLink);
				CGModuleLink inputLink = inputSlot.Module.GetInputLink(inSlot, this);
				inputSlot.Module.InputLinks.Remove(inputLink);
				base.LinkedSlots.Remove(inputSlot);
				inputSlot.LinkedSlots.Remove(this);
				base.UnlinkFrom(inputSlot);
			}
		}

		public void ClearData()
		{
			Data = new CGData[0];
		}

		public void SetData<T>(List<T> data) where T : CGData
		{
			if (data == null)
			{
				Data = new CGData[0];
				return;
			}
			if (!base.Info.Array && data.Count > 1)
			{
				Debug.LogWarning("[Curvy] " + base.Module.GetType().Name + " (" + base.Info.Name + ") only supports a single data item! Either avoid calculating unneccessary data or define the slot as an array!");
			}
			Data = data.ToArray();
		}

		public void SetData(params CGData[] data)
		{
			Data = ((data != null) ? data : new CGData[0]);
		}

		public T GetData<T>() where T : CGData
		{
			return (Data.Length != 0) ? (Data[0] as T) : ((T)null);
		}

		public T[] GetAllData<T>() where T : CGData
		{
			return Data as T[];
		}
	}
	public class SlotInfo : Attribute, IComparable
	{
		public readonly Type[] DataTypes;

		public string Name;

		private string displayName;

		public string Tooltip;

		public bool Array;

		public string DisplayName
		{
			get
			{
				return displayName ?? Name;
			}
			set
			{
				displayName = value;
			}
		}

		protected SlotInfo(string name, params Type[] type)
		{
			DataTypes = type;
			Name = name;
		}

		protected SlotInfo(params Type[] type)
			: this(null, type)
		{
		}

		public int CompareTo(object obj)
		{
			return string.Compare(((SlotInfo)obj).Name, Name, StringComparison.Ordinal);
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class InputSlotInfo : SlotInfo
	{
		public bool RequestDataOnly;

		public bool Optional;

		public bool ModifiesData;

		public InputSlotInfo(string name, params Type[] type)
			: base(name, type)
		{
		}

		public InputSlotInfo(params Type[] type)
			: this(null, type)
		{
		}

		public bool IsValidFrom(Type outType)
		{
			for (int i = 0; i < DataTypes.Length; i++)
			{
				if (outType == DataTypes[i] || outType.IsSubclassOf(DataTypes[i]))
				{
					return true;
				}
			}
			return false;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class OutputSlotInfo : SlotInfo
	{
		public Type DataType => DataTypes[0];

		public OutputSlotInfo(Type type)
			: this(null, type)
		{
		}

		public OutputSlotInfo(string name, Type type)
			: base(name, type)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ResourceLoaderAttribute : Attribute
	{
		public readonly string ResourceName;

		public ResourceLoaderAttribute(string resName)
		{
			ResourceName = resName;
		}
	}
	public static class CGResourceHandler
	{
		private static Dictionary<string, ICGResourceLoader> Loader = new Dictionary<string, ICGResourceLoader>();

		public static Component CreateResource(CGModule module, string resName, string context)
		{
			if (Loader.Count == 0)
			{
				getLoaders();
			}
			if (Loader.ContainsKey(resName))
			{
				ICGResourceLoader iCGResourceLoader = Loader[resName];
				return iCGResourceLoader.Create(module, context);
			}
			Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
			return null;
		}

		public static void DestroyResource(CGModule module, string resName, Component obj, string context, bool kill)
		{
			if (Loader.Count == 0)
			{
				getLoaders();
			}
			if (Loader.ContainsKey(resName))
			{
				ICGResourceLoader iCGResourceLoader = Loader[resName];
				iCGResourceLoader.Destroy(module, obj, context, kill);
			}
			else
			{
				Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
			}
		}

		private static void getLoaders()
		{
			Type[] loadedTypes = TypeExt.GetLoadedTypes();
			Type typeFromHandle = typeof(ICGResourceLoader);
			Type[] array = loadedTypes;
			foreach (Type type in array)
			{
				if (!typeFromHandle.IsAssignableFrom(type) || typeFromHandle == type)
				{
					continue;
				}
				object[] customAttributes = type.GetCustomAttributes(typeof(ResourceLoaderAttribute), inherit: true);
				if (customAttributes.Length > 0)
				{
					ICGResourceLoader iCGResourceLoader = (ICGResourceLoader)Activator.CreateInstance(type);
					if (iCGResourceLoader != null)
					{
						Loader.Add(((ResourceLoaderAttribute)customAttributes[0]).ResourceName, iCGResourceLoader);
					}
				}
				else
				{
					DTLog.LogError($"[Curvy] Could not register resource loader of type {type.FullName} because it does not have a ResourceLoader attribute");
				}
			}
		}
	}
	[ResourceLoader("Spline")]
	public class CGSplineResourceLoader : ICGResourceLoader
	{
		public Component Create(CGModule cgModule, string context)
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.transform.position = Vector3.zero;
			curvySpline.Closed = true;
			curvySpline.Add(new Vector3(0f, 0f, 0f), new Vector3(5f, 0f, 10f), new Vector3(-5f, 0f, 10f));
			return curvySpline;
		}

		public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}
	[ResourceLoader("Shape")]
	public class CGShapeResourceLoader : ICGResourceLoader
	{
		public Component Create(CGModule cgModule, string context)
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.transform.position = Vector3.zero;
			curvySpline.RestrictTo2D = true;
			curvySpline.Closed = true;
			curvySpline.Orientation = CurvyOrientation.None;
			curvySpline.gameObject.AddComponent<CSCircle>().Refresh();
			return curvySpline;
		}

		public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}
	[ResourceLoader("Mesh")]
	public class CGMeshResourceLoader : ICGResourceLoader
	{
		public Component Create(CGModule cgModule, string context)
		{
			return cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Pop();
		}

		public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
		{
			if (!(obj != null))
			{
				return;
			}
			if (kill)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(obj.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(obj.gameObject);
				}
			}
			else
			{
				obj.StripComponents(typeof(CGMeshResource), typeof(MeshFilter), typeof(MeshRenderer));
				cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Push(obj);
			}
		}
	}
	[ResourceLoader("GameObject")]
	public class CGGameObjectResourceLoader : ICGResourceLoader
	{
		public Component Create(CGModule cgModule, string context)
		{
			GameObject gameObject = cgModule.Generator.PoolManager.GetPrefabPool(context).Pop();
			return gameObject.transform;
		}

		public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
		{
			if (!(obj != null))
			{
				return;
			}
			if (kill)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(obj.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(obj.gameObject);
				}
			}
			else
			{
				cgModule.Generator.PoolManager.GetPrefabPool(context).Push(obj.gameObject);
			}
		}
	}
	[Serializable]
	public class CGGameObjectResourceCollection : ICGResourceCollection
	{
		public List<Transform> Items = new List<Transform>();

		public List<string> PoolNames = new List<string>();

		public int Count => Items.Count;

		public Component[] ItemsArray => Items.ToArray();
	}
	public static class CGUtility
	{
		public static Vector2[] CalculateUV2(Vector2[] uv)
		{
			Vector2[] array = new Vector2[uv.Length];
			float num = 1f;
			float num2 = 1f;
			for (int i = 0; i < uv.Length; i++)
			{
				num = ((!(num < uv[i].x)) ? num : uv[i].x);
				num2 = ((!(num2 < uv[i].y)) ? num2 : uv[i].y);
			}
			float num3 = 1f / num;
			float num4 = 1f / num2;
			for (int j = 0; j < uv.Length; j++)
			{
				array[j].x = uv[j].x * num3;
				array[j].y = uv[j].y * num4;
			}
			return array;
		}

		public static List<ControlPointOption> GetControlPointsWithOptions(CGDataRequestMetaCGOptions options, CurvySpline shape, float startDist, float endDist, bool optimize, out int initialMaterialID, out float initialMaxStep)
		{
			List<ControlPointOption> list = new List<ControlPointOption>();
			initialMaterialID = 0;
			initialMaxStep = float.MaxValue;
			CurvySplineSegment curvySplineSegment = shape.DistanceToSegment(startDist);
			float num = shape.ClampDistance(endDist, shape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
			if (num == 0f)
			{
				num = endDist;
			}
			CurvySplineSegment curvySplineSegment2 = ((num != shape.Length) ? shape.DistanceToSegment(num) : shape.LastVisibleControlPoint);
			if (endDist != shape.Length && endDist > curvySplineSegment2.Distance)
			{
				curvySplineSegment2 = shape.GetNextControlPoint(curvySplineSegment2);
			}
			float num2 = 0f;
			if ((bool)curvySplineSegment)
			{
				MetaCGOptions metadata = curvySplineSegment.GetMetadata<MetaCGOptions>(autoCreate: true);
				initialMaxStep = ((metadata.MaxStepDistance != 0f) ? metadata.MaxStepDistance : float.MaxValue);
				if (options.CheckMaterialID)
				{
					initialMaterialID = metadata.MaterialID;
				}
				int num3 = initialMaterialID;
				float num4 = metadata.MaxStepDistance;
				CurvySplineSegment curvySplineSegment3 = shape.GetNextSegment(curvySplineSegment) ?? shape.GetNextControlPoint(curvySplineSegment);
				do
				{
					metadata = curvySplineSegment3.GetMetadata<MetaCGOptions>(autoCreate: true);
					if (shape.GetControlPointIndex(curvySplineSegment3) < shape.GetControlPointIndex(curvySplineSegment))
					{
						num2 = shape.Length;
					}
					if (options.IncludeControlPoints || (options.CheckHardEdges && metadata.HardEdge) || (options.CheckMaterialID && metadata.MaterialID != num3) || (optimize && metadata.MaxStepDistance != num4) || (options.CheckExtendedUV && (metadata.UVEdge || metadata.ExplicitU)))
					{
						bool flag = metadata.MaterialID != num3;
						num4 = ((metadata.MaxStepDistance != 0f) ? metadata.MaxStepDistance : float.MaxValue);
						num3 = ((!options.CheckMaterialID) ? initialMaterialID : metadata.MaterialID);
						list.Add(new ControlPointOption(curvySplineSegment3.LocalFToTF(0f) + (float)Mathf.FloorToInt(num2 / shape.Length), curvySplineSegment3.Distance + num2, options.IncludeControlPoints, num3, options.CheckHardEdges && metadata.HardEdge, metadata.MaxStepDistance, (options.CheckExtendedUV && metadata.UVEdge) || flag, options.CheckExtendedUV && metadata.ExplicitU, metadata.FirstU, metadata.SecondU));
					}
					curvySplineSegment3 = shape.GetNextSegment(curvySplineSegment3);
				}
				while ((bool)curvySplineSegment3 && curvySplineSegment3 != curvySplineSegment2);
				if (options.CheckExtendedUV && !curvySplineSegment3 && shape.LastVisibleControlPoint == curvySplineSegment2)
				{
					metadata = curvySplineSegment2.GetMetadata<MetaCGOptions>(autoCreate: true);
					if (metadata.ExplicitU)
					{
						list.Add(new ControlPointOption(1f, curvySplineSegment2.Distance + num2, options.IncludeControlPoints, num3, options.CheckHardEdges && metadata.HardEdge, metadata.MaxStepDistance, (options.CheckExtendedUV && metadata.UVEdge) || (options.CheckMaterialID && metadata.MaterialID != num3), options.CheckExtendedUV && metadata.ExplicitU, metadata.FirstU, metadata.SecondU));
					}
				}
			}
			return list;
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/generator")]
	[AddComponentMenu("Curvy/Generator", 3)]
	[RequireComponent(typeof(PoolManager))]
	public class CurvyGenerator : DTVersionedMonoBehaviour
	{
		[Tooltip("Show Debug Output?")]
		[SerializeField]
		private bool m_ShowDebug;

		[Tooltip("Whether to automatically refresh the generator's output when necessary")]
		[SerializeField]
		private bool m_AutoRefresh = true;

		[FieldCondition("m_AutoRefresh", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Play mode, in milliseconds")]
		[SerializeField]
		private int m_RefreshDelay;

		[FieldCondition("m_AutoRefresh", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Edit mode, in milliseconds")]
		[SerializeField]
		private int m_RefreshDelayEditor = 10;

		[Section("Events", false, false, 1000, HelpURL = "https://curvyeditor.com/doclink/generator_events")]
		[SerializeField]
		private CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

		[HideInInspector]
		public List<CGModule> Modules = new List<CGModule>();

		[SerializeField]
		[HideInInspector]
		internal int m_LastModuleID;

		public Dictionary<int, CGModule> ModulesByID = new Dictionary<int, CGModule>();

		private bool mInitialized;

		private bool mInitializedPhaseOne;

		private bool mNeedSort = true;

		private double mLastUpdateTime;

		private PoolManager mPoolManager;

		private const int ModulesReorderingDeltaX = 50;

		private const int ModulesReorderingDeltaY = 20;

		public bool ShowDebug
		{
			get
			{
				return m_ShowDebug;
			}
			set
			{
				if (m_ShowDebug != value)
				{
					m_ShowDebug = value;
				}
			}
		}

		public bool AutoRefresh
		{
			get
			{
				return m_AutoRefresh;
			}
			set
			{
				if (m_AutoRefresh != value)
				{
					m_AutoRefresh = value;
				}
			}
		}

		public int RefreshDelay
		{
			get
			{
				return m_RefreshDelay;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_RefreshDelay != num)
				{
					m_RefreshDelay = num;
				}
			}
		}

		public int RefreshDelayEditor
		{
			get
			{
				return m_RefreshDelayEditor;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_RefreshDelayEditor != num)
				{
					m_RefreshDelayEditor = num;
				}
			}
		}

		public PoolManager PoolManager
		{
			get
			{
				if (mPoolManager == null)
				{
					mPoolManager = GetComponent<PoolManager>();
				}
				return mPoolManager;
			}
		}

		public CurvyCGEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public bool IsInitialized => mInitialized;

		public bool Destroying { get; private set; }

		private void Awake()
		{
		}

		private void OnEnable()
		{
			PoolManager.AutoCreatePools = true;
		}

		private void OnDisable()
		{
			mInitialized = false;
			mInitializedPhaseOne = false;
			mNeedSort = true;
		}

		private void OnDestroy()
		{
			Destroying = true;
		}

		private void Update()
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			else if (AutoRefresh && Application.isPlaying && DTTime.TimeSinceStartup - mLastUpdateTime > (double)((float)RefreshDelay * 0.001f))
			{
				mLastUpdateTime = DTTime.TimeSinceStartup;
				Refresh();
			}
		}

		public static CurvyGenerator Create()
		{
			GameObject gameObject = new GameObject("Curvy Generator", typeof(CurvyGenerator));
			return gameObject.GetComponent<CurvyGenerator>();
		}

		public T AddModule<T>() where T : CGModule
		{
			return (T)AddModule(typeof(T));
		}

		public CGModule AddModule(Type type)
		{
			GameObject gameObject = new GameObject(string.Empty);
			gameObject.transform.SetParent(base.transform, worldPositionStays: false);
			CGModule cGModule = (CGModule)gameObject.AddComponent(type);
			cGModule.SetUniqueIdINTERNAL();
			Modules.Add(cGModule);
			ModulesByID.Add(cGModule.UniqueID, cGModule);
			return cGModule;
		}

		public void ArrangeModules()
		{
			Vector2 vector = new Vector2(float.MaxValue, float.MaxValue);
			foreach (CGModule module in Modules)
			{
				vector.x = Mathf.Min(module.Properties.Dimensions.x, vector.x);
				vector.y = Mathf.Min(module.Properties.Dimensions.y, vector.y);
			}
			vector -= new Vector2(10f, 10f);
			foreach (CGModule module2 in Modules)
			{
				module2.Properties.Dimensions.x -= vector.x;
				module2.Properties.Dimensions.y -= vector.y;
			}
		}

		public void ReorderModules()
		{
			Dictionary<CGModule, Rect> dictionary = new Dictionary<CGModule, Rect>(Modules.Count);
			foreach (CGModule module in Modules)
			{
				dictionary[module] = module.Properties.Dimensions;
			}
			List<CGModule> list = Modules.Where((CGModule m) => !m.OutputLinks.Any()).ToList();
			Dictionary<CGModule, HashSet<CGModule>> dictionary2 = new Dictionary<CGModule, HashSet<CGModule>>(Modules.Count);
			foreach (CGModule item in list)
			{
				UpdateModulesRecursiveInputs(dictionary2, item);
			}
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < list.Count; i++)
			{
				float y = ((i != 0) ? (dictionary2[list[i - 1]].Max((CGModule m) => m.Properties.Dimensions.yMax) + 20f) : 0f);
				CGModule cGModule = list[i];
				cGModule.Properties.Dimensions.position = new Vector2(0f, y);
				hashSet.Add(cGModule.UniqueID);
				ReorderEndpointRecursiveInputs(cGModule, hashSet, dictionary2);
			}
			ArrangeModules();
		}

		public void Clear()
		{
			clearModules();
		}

		public void DeleteModule(CGModule module)
		{
			if ((bool)module)
			{
				module.Delete();
			}
		}

		public List<T> FindModules<T>(bool includeOnRequestProcessing = false) where T : CGModule
		{
			List<T> list = new List<T>();
			for (int i = 0; i < Modules.Count; i++)
			{
				if (Modules[i] is T && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
				{
					list.Add((T)Modules[i]);
				}
			}
			return list;
		}

		public List<CGModule> GetModules(bool includeOnRequestProcessing = false)
		{
			if (includeOnRequestProcessing)
			{
				return new List<CGModule>(Modules);
			}
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < Modules.Count; i++)
			{
				if (!(Modules[i] is IOnRequestProcessing))
				{
					list.Add(Modules[i]);
				}
			}
			return list;
		}

		public CGModule GetModule(int moduleID, bool includeOnRequestProcessing = false)
		{
			if (ModulesByID.TryGetValue(moduleID, out var value) && (includeOnRequestProcessing || !(value is IOnRequestProcessing)))
			{
				return value;
			}
			return null;
		}

		public T GetModule<T>(int moduleID, bool includeOnRequestProcessing = false) where T : CGModule
		{
			return GetModule(moduleID, includeOnRequestProcessing) as T;
		}

		public CGModule GetModule(string moduleName, bool includeOnRequestProcessing = false)
		{
			for (int i = 0; i < Modules.Count; i++)
			{
				if (Modules[i].ModuleName.Equals(moduleName, StringComparison.CurrentCultureIgnoreCase) && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
				{
					return Modules[i];
				}
			}
			return null;
		}

		public T GetModule<T>(string moduleName, bool includeOnRequestProcessing = false) where T : CGModule
		{
			return GetModule(moduleName, includeOnRequestProcessing) as T;
		}

		public CGModuleOutputSlot GetModuleOutputSlot(int moduleId, string slotName)
		{
			CGModule module = GetModule(moduleId);
			if ((bool)module)
			{
				return module.GetOutputSlot(slotName);
			}
			return null;
		}

		public CGModuleOutputSlot GetModuleOutputSlot(string moduleName, string slotName)
		{
			CGModule module = GetModule(moduleName);
			if ((bool)module)
			{
				return module.GetOutputSlot(slotName);
			}
			return null;
		}

		public void Initialize(bool force = false)
		{
			if (!mInitializedPhaseOne || force)
			{
				Modules = new List<CGModule>(GetComponentsInChildren<CGModule>());
				ModulesByID.Clear();
				for (int i = 0; i < Modules.Count; i++)
				{
					if (!Modules[i].IsInitialized || force)
					{
						Modules[i].Initialize();
					}
					if (ModulesByID.ContainsKey(Modules[i].UniqueID))
					{
						Debug.LogError("ID of '" + Modules[i].ModuleName + "' isn't unique!");
						return;
					}
					ModulesByID.Add(Modules[i].UniqueID, Modules[i]);
				}
				if (Modules.Count > 0)
				{
					sortModulesINTERNAL();
				}
				mInitializedPhaseOne = true;
			}
			for (int j = 0; j < Modules.Count; j++)
			{
				if (Modules[j] is IExternalInput && !Modules[j].IsInitialized)
				{
					return;
				}
			}
			mInitialized = true;
			mInitializedPhaseOne = false;
			mNeedSort = mNeedSort || force;
			Refresh(forceUpdate: true);
		}

		public void Refresh(bool forceUpdate = false)
		{
			if (!IsInitialized)
			{
				return;
			}
			if (mNeedSort)
			{
				doSortModules();
			}
			CGModule cGModule = null;
			for (int i = 0; i < Modules.Count; i++)
			{
				if (forceUpdate && Modules[i] is IOnRequestProcessing)
				{
					Modules[i].Dirty = true;
				}
				if (Modules[i] is INoProcessing || (!Modules[i].Dirty && (!forceUpdate || Modules[i] is IOnRequestProcessing)))
				{
					continue;
				}
				Modules[i].checkOnStateChangedINTERNAL();
				if (Modules[i].IsInitialized && Modules[i].IsConfigured)
				{
					if (cGModule == null)
					{
						cGModule = Modules[i];
					}
					Modules[i].doRefresh();
				}
			}
			if (cGModule != null)
			{
				OnRefreshEvent(new CurvyCGEventArgs(this, cGModule));
			}
		}

		protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		private void clearModules()
		{
			for (int num = Modules.Count - 1; num >= 0; num--)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(Modules[num].gameObject);
				}
			}
			Modules.Clear();
			ModulesByID.Clear();
			m_LastModuleID = 0;
		}

		public string getUniqueModuleNameINTERNAL(string name)
		{
			string text = name;
			int num = 1;
			bool flag;
			do
			{
				flag = true;
				foreach (CGModule module in Modules)
				{
					if (module.ModuleName.Equals(text, StringComparison.CurrentCultureIgnoreCase))
					{
						text = name + num++.ToString(CultureInfo.InvariantCulture);
						flag = false;
						break;
					}
				}
			}
			while (!flag);
			return text;
		}

		internal void sortModulesINTERNAL()
		{
			mNeedSort = true;
		}

		private bool doSortModules()
		{
			List<CGModule> list = new List<CGModule>(Modules);
			List<CGModule> list2 = new List<CGModule>();
			List<CGModule> list3 = new List<CGModule>();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				list[num].initializeSort();
				if (list[num] is INoProcessing)
				{
					list3.Add(list[num]);
					list.RemoveAt(num);
				}
				else if (list[num].SortAncestors == 0)
				{
					list2.Add(list[num]);
					list.RemoveAt(num);
				}
			}
			Modules.Clear();
			int num2 = 0;
			while (list2.Count > 0)
			{
				CGModule cGModule = list2[0];
				list2.RemoveAt(0);
				List<CGModule> list4 = cGModule.decrementChilds();
				list2.AddRange(list4);
				for (int i = 0; i < list4.Count; i++)
				{
					list.Remove(list4[i]);
				}
				Modules.Add(cGModule);
				cGModule.transform.SetSiblingIndex(num2++);
			}
			for (int j = 0; j < list.Count; j++)
			{
				list[j].CircularReferenceError = true;
			}
			Modules.AddRange(list);
			Modules.AddRange(list3);
			mNeedSort = false;
			return list.Count > 0;
		}

		private static void ReorderEndpointRecursiveInputs(CGModule endPoint, HashSet<int> reordredModuleIds, Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs)
		{
			float num = endPoint.Properties.Dimensions.xMin - 50f;
			float num2 = endPoint.Properties.Dimensions.yMin;
			List<CGModule> list = endPoint.Input.SelectMany((CGModuleInputSlot i) => i.GetLinkedModules()).ToList();
			foreach (CGModule item in list)
			{
				float num3 = num - item.Properties.Dimensions.width;
				if (!reordredModuleIds.Contains(item.UniqueID))
				{
					item.Properties.Dimensions.position = new Vector2(num3, num2);
					reordredModuleIds.Add(item.UniqueID);
					ReorderEndpointRecursiveInputs(item, reordredModuleIds, modulesRecursiveInputs);
				}
				else if (num3 < item.Properties.Dimensions.xMin)
				{
					item.Properties.Dimensions.position = new Vector2(num3, item.Properties.Dimensions.yMin);
					ReorderEndpointRecursiveInputs(item, reordredModuleIds, modulesRecursiveInputs);
				}
				num2 = Math.Max(num2, modulesRecursiveInputs[item].Max((CGModule m) => m.Properties.Dimensions.yMax) + 20f);
			}
		}

		private static HashSet<CGModule> UpdateModulesRecursiveInputs(Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs, CGModule moduleToAdd)
		{
			if (modulesRecursiveInputs.ContainsKey(moduleToAdd))
			{
				return modulesRecursiveInputs[moduleToAdd];
			}
			List<CGModule> source = moduleToAdd.Input.SelectMany((CGModuleInputSlot i) => i.GetLinkedModules()).ToList();
			HashSet<CGModule> hashSet = new HashSet<CGModule>();
			hashSet.Add(moduleToAdd);
			hashSet.UnionWith(source.SelectMany((CGModule i) => UpdateModulesRecursiveInputs(modulesRecursiveInputs, i)));
			modulesRecursiveInputs[moduleToAdd] = hashSet;
			return hashSet;
		}
	}
}
namespace FluffyUnderware.Curvy
{
	[HelpURL("https://curvyeditor.com/doclink/metacgoptions")]
	public class MetaCGOptions : CurvyMetadataBase, ICurvyMetadata
	{
		[Positive]
		[SerializeField]
		private int m_MaterialID;

		[SerializeField]
		private bool m_HardEdge;

		[Positive(Tooltip = "Max step distance when using optimization")]
		[SerializeField]
		private float m_MaxStepDistance;

		[Section("Extended UV", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/metacgoptions_extendeduv")]
		[FieldCondition("showUVEdge", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_UVEdge;

		[Positive]
		[FieldCondition("showExplicitU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_ExplicitU;

		[FieldCondition("showFirstU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[FieldAction("CBSetFirstU", ActionAttribute.ActionEnum.Callback)]
		[Positive]
		[SerializeField]
		private float m_FirstU;

		[FieldCondition("showSecondU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive]
		[SerializeField]
		private float m_SecondU;

		public int MaterialID
		{
			get
			{
				return m_MaterialID;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_MaterialID != num)
				{
					m_MaterialID = num;
					NotifyModification();
				}
			}
		}

		public bool HardEdge
		{
			get
			{
				return m_HardEdge;
			}
			set
			{
				if (m_HardEdge != value)
				{
					m_HardEdge = value;
					NotifyModification();
				}
			}
		}

		public bool UVEdge
		{
			get
			{
				return m_UVEdge;
			}
			set
			{
				if (m_UVEdge != value)
				{
					m_UVEdge = value;
					NotifyModification();
				}
			}
		}

		public bool ExplicitU
		{
			get
			{
				return m_ExplicitU;
			}
			set
			{
				if (m_ExplicitU != value)
				{
					m_ExplicitU = value;
					NotifyModification();
				}
			}
		}

		public float FirstU
		{
			get
			{
				return m_FirstU;
			}
			set
			{
				if (m_FirstU != value)
				{
					m_FirstU = value;
					NotifyModification();
				}
			}
		}

		public float SecondU
		{
			get
			{
				return m_SecondU;
			}
			set
			{
				if (m_SecondU != value)
				{
					m_SecondU = value;
					NotifyModification();
				}
			}
		}

		public float MaxStepDistance
		{
			get
			{
				return m_MaxStepDistance;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_MaxStepDistance != num)
				{
					m_MaxStepDistance = num;
					NotifyModification();
				}
			}
		}

		public bool HasDifferentMaterial
		{
			get
			{
				MetaCGOptions previousData = GetPreviousData<MetaCGOptions>();
				return (bool)previousData && previousData.MaterialID != MaterialID;
			}
		}

		private bool showUVEdge => (bool)base.ControlPoint && (base.Spline.Closed || (!(base.Spline.FirstVisibleControlPoint == base.ControlPoint) && !(base.Spline.LastVisibleControlPoint == base.ControlPoint))) && !HasDifferentMaterial;

		private bool showExplicitU => (bool)base.ControlPoint && !UVEdge && !HasDifferentMaterial;

		private bool showFirstU
		{
			get
			{
				bool result = false;
				if ((bool)base.ControlPoint)
				{
					result = UVEdge || ExplicitU || HasDifferentMaterial;
				}
				return result;
			}
		}

		private bool showSecondU => UVEdge || HasDifferentMaterial;

		public void Reset()
		{
			MaterialID = 0;
			HardEdge = false;
			MaxStepDistance = 0f;
			UVEdge = false;
			ExplicitU = false;
			FirstU = 0f;
			SecondU = 0f;
		}

		public float GetDefinedFirstU(float defaultValue)
		{
			return (!UVEdge && !ExplicitU && !HasDifferentMaterial) ? defaultValue : FirstU;
		}

		public float GetDefinedSecondU(float defaultValue)
		{
			return (!UVEdge && !HasDifferentMaterial) ? GetDefinedFirstU(defaultValue) : SecondU;
		}
	}
	public interface ICurvyMetadata
	{
	}
	public interface ICurvyInterpolatableMetadata : ICurvyMetadata
	{
		object Value { get; }

		object InterpolateObject(ICurvyMetadata b, float f);
	}
	public interface ICurvyInterpolatableMetadata<U> : ICurvyInterpolatableMetadata, ICurvyMetadata
	{
		U Interpolate(ICurvyMetadata b, float f);
	}
	public enum OrientationModeEnum
	{
		None,
		Orientation,
		Tangent
	}
	public enum OrientationAxisEnum
	{
		Up,
		Down,
		Forward,
		Backward,
		Left,
		Right
	}
	public enum ConnectionHeadingEnum
	{
		Minus = -1,
		Sharp,
		Plus,
		Auto
	}
	public static class ConnectionHeadingEnumMethods
	{
		public static ConnectionHeadingEnum ResolveAuto(this ConnectionHeadingEnum heading, CurvySplineSegment followUp)
		{
			if (heading == ConnectionHeadingEnum.Auto)
			{
				heading = ((followUp.Spline.FirstVisibleControlPoint == followUp) ? ConnectionHeadingEnum.Plus : ((followUp.Spline.LastVisibleControlPoint == followUp) ? ConnectionHeadingEnum.Minus : ConnectionHeadingEnum.Sharp));
			}
			return heading;
		}
	}
	public enum CurvyUpdateMethod
	{
		Update,
		LateUpdate,
		FixedUpdate
	}
	public enum CurvyRepeatingOrderEnum
	{
		Random,
		Row
	}
	public enum CurvyPlane
	{
		XY,
		XZ,
		YZ
	}
	public enum CurvyPositionMode
	{
		Relative,
		WorldUnits
	}
	[Flags]
	public enum CurvyBezierModeEnum
	{
		None = 0,
		Direction = 1,
		Length = 2,
		Connections = 4,
		Combine = 8
	}
	public enum CurvyAdvBezierModeEnum
	{
		None = 0,
		Direction = 1,
		Length = 2,
		Combine = 8
	}
	public enum CurvyInterpolation
	{
		Linear,
		CatmullRom,
		TCB,
		Bezier
	}
	public enum CurvyClamping
	{
		Clamp,
		Loop,
		PingPong
	}
	public enum CurvyOrientation
	{
		None,
		Dynamic,
		Static
	}
	public enum CurvyOrientationSwirl
	{
		None,
		Segment,
		AnchorGroup,
		AnchorGroupAbs
	}
	[Flags]
	public enum CurvySplineGizmos
	{
		None = 0,
		Curve = 2,
		Approximation = 4,
		Tangents = 8,
		Orientation = 0x10,
		Labels = 0x20,
		Metadata = 0x40,
		Bounds = 0x80,
		All = 0xFFFF
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvyconnection")]
	public class CurvyConnection : MonoBehaviour, ISerializationCallbackReceiver
	{
		[SerializeField]
		[Hide]
		private List<CurvySplineSegment> m_ControlPoints = new List<CurvySplineSegment>();

		private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

		private Couple<Vector3, Quaternion> processedConnectionCoordinates;

		private Dictionary<CurvySplineSegment, Couple<Vector3, Quaternion>> processedControlPointsCoordinates = new Dictionary<CurvySplineSegment, Couple<Vector3, Quaternion>>();

		public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
		{
			get
			{
				if (readOnlyControlPoints == null)
				{
					readOnlyControlPoints = m_ControlPoints.AsReadOnly();
				}
				return readOnlyControlPoints;
			}
		}

		public int Count => m_ControlPoints.Count;

		public CurvySplineSegment this[int idx] => m_ControlPoints[idx];

		private void OnEnable()
		{
			Transform transform = base.transform;
			processedConnectionCoordinates = new Couple<Vector3, Quaternion>(transform.position, transform.rotation);
			processedControlPointsCoordinates.Clear();
			for (int i = 0; i < m_ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = m_ControlPoints[i];
				processedControlPointsCoordinates[curvySplineSegment] = new Couple<Vector3, Quaternion>(curvySplineSegment.transform.position, curvySplineSegment.transform.rotation);
			}
		}

		private void OnDisable()
		{
		}

		private void Update()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void LateUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void OnDestroy()
		{
			if (1 == 0)
			{
				return;
			}
			foreach (CurvySplineSegment controlPoint in m_ControlPoints)
			{
				controlPoint.ResetConnectionRelatedData();
			}
			m_ControlPoints.Clear();
			processedControlPointsCoordinates.Clear();
		}

		public static CurvyConnection Create(params CurvySplineSegment[] controlPoints)
		{
			CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
			if (instance == null)
			{
				DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
				return null;
			}
			CurvyConnection curvyConnection = instance.AddChildGameObject<CurvyConnection>("Connection");
			if (!curvyConnection)
			{
				return null;
			}
			if (controlPoints.Length > 0)
			{
				curvyConnection.transform.position = controlPoints[0].transform.position;
				curvyConnection.AddControlPoints(controlPoints);
			}
			return curvyConnection;
		}

		public void AddControlPoints(params CurvySplineSegment[] controlPoints)
		{
			foreach (CurvySplineSegment curvySplineSegment in controlPoints)
			{
				if (!curvySplineSegment.Connection)
				{
					m_ControlPoints.Add(curvySplineSegment);
					processedControlPointsCoordinates[curvySplineSegment] = new Couple<Vector3, Quaternion>(curvySplineSegment.transform.position, curvySplineSegment.transform.rotation);
					curvySplineSegment.Connection = this;
				}
			}
			AutoSetFollowUp();
		}

		public void AutoSetFollowUp()
		{
			if (Count != 2)
			{
				return;
			}
			CurvySplineSegment curvySplineSegment = m_ControlPoints[0];
			CurvySplineSegment curvySplineSegment2 = m_ControlPoints[1];
			if (curvySplineSegment.transform.position == curvySplineSegment2.transform.position && curvySplineSegment.ConnectionSyncPosition && curvySplineSegment2.ConnectionSyncPosition)
			{
				if (curvySplineSegment.FollowUp == null && (bool)curvySplineSegment.Spline && curvySplineSegment.Spline.CanControlPointHaveFollowUp(curvySplineSegment))
				{
					curvySplineSegment.SetFollowUp(curvySplineSegment2);
				}
				if (curvySplineSegment2.FollowUp == null && (bool)curvySplineSegment2.Spline && curvySplineSegment2.Spline.CanControlPointHaveFollowUp(curvySplineSegment2))
				{
					curvySplineSegment2.SetFollowUp(curvySplineSegment);
				}
			}
		}

		public void RemoveControlPoint(CurvySplineSegment controlPoint, bool destroySelfIfEmpty = true)
		{
			controlPoint.Connection = null;
			m_ControlPoints.Remove(controlPoint);
			processedControlPointsCoordinates.Remove(controlPoint);
			if (m_ControlPoints.Count == 0 && destroySelfIfEmpty)
			{
				Delete();
			}
		}

		public void Delete()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public List<CurvySplineSegment> OtherControlPoints(CurvySplineSegment source)
		{
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(m_ControlPoints);
			list.Remove(source);
			return list;
		}

		public void SetSynchronisationPositionAndRotation(Vector3 referencePosition, Quaternion referenceRotation)
		{
			Transform transform = base.transform;
			transform.position = referencePosition;
			transform.rotation = referenceRotation;
			transform.hasChanged = false;
			processedConnectionCoordinates.First = referencePosition;
			processedConnectionCoordinates.Second = referenceRotation;
			for (int i = 0; i < m_ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = m_ControlPoints[i];
				bool flag = curvySplineSegment.ConnectionSyncPosition && curvySplineSegment.transform.position.NotApproximately(referencePosition);
				bool flag2 = curvySplineSegment.ConnectionSyncRotation && curvySplineSegment.transform.rotation.DifferentOrientation(referenceRotation);
				if (flag)
				{
					curvySplineSegment.transform.position = referencePosition;
				}
				if (flag2)
				{
					curvySplineSegment.transform.rotation = referenceRotation;
				}
				Couple<Vector3, Quaternion> couple = processedControlPointsCoordinates[curvySplineSegment];
				couple.First = curvySplineSegment.transform.position;
				couple.Second = curvySplineSegment.transform.rotation;
				if (flag || (flag2 && curvySplineSegment.OrientatinInfluencesSpline))
				{
					curvySplineSegment.Spline.SetDirtyPartial(curvySplineSegment, flag ? SplineDirtyingType.Everything : SplineDirtyingType.OrientationOnly);
				}
			}
		}

		private void DoUpdate()
		{
			Transform transform = base.transform;
			bool flag;
			if (transform.hasChanged)
			{
				transform.hasChanged = false;
				if (transform.position.NotApproximately(processedConnectionCoordinates.First) || transform.rotation.DifferentOrientation(processedConnectionCoordinates.Second))
				{
					SetSynchronisationPositionAndRotation(transform.position, transform.rotation);
					flag = true;
				}
				else
				{
					flag = false;
				}
			}
			else
			{
				flag = false;
			}
			if (flag)
			{
				return;
			}
			Vector3? vector = null;
			Quaternion? quaternion = null;
			foreach (CurvySplineSegment controlPoint in m_ControlPoints)
			{
				Couple<Vector3, Quaternion> couple = processedControlPointsCoordinates[controlPoint];
				Transform transform2 = controlPoint.transform;
				if (controlPoint.ConnectionSyncPosition && transform2.position.NotApproximately(couple.First))
				{
					vector = transform2.position;
				}
				if (controlPoint.ConnectionSyncRotation && transform2.rotation.DifferentOrientation(couple.Second))
				{
					quaternion = transform2.rotation;
				}
				if (vector.HasValue && quaternion.HasValue)
				{
					break;
				}
			}
			if (vector.HasValue || quaternion.HasValue)
			{
				SetSynchronisationPositionAndRotation((!vector.HasValue) ? base.transform.position : vector.Value, (!quaternion.HasValue) ? base.transform.rotation : quaternion.Value);
			}
		}

		public void OnBeforeSerialize()
		{
			m_ControlPoints.RemoveAll((CurvySplineSegment cp) => object.ReferenceEquals(cp, null));
		}

		public void OnAfterDeserialize()
		{
			m_ControlPoints.RemoveAll((CurvySplineSegment cp) => object.ReferenceEquals(cp, null));
		}
	}
	public class CurvyEventArgs : EventArgs
	{
		public readonly MonoBehaviour Sender;

		public readonly object Data;

		public CurvyEventArgs(MonoBehaviour sender, object data)
		{
			Sender = sender;
			Data = data;
		}
	}
	[Serializable]
	public class CurvySplineEvent : UnityEventEx<CurvySplineEventArgs>
	{
	}
	[Serializable]
	public class CurvyControlPointEvent : UnityEventEx<CurvyControlPointEventArgs>
	{
	}
	public class CurvyControlPointEventArgs : CurvySplineEventArgs
	{
		public enum ModeEnum
		{
			None,
			AddBefore,
			AddAfter,
			Delete
		}

		public readonly ModeEnum Mode;

		public readonly CurvySplineSegment ControlPoint;

		public CurvyControlPointEventArgs(MonoBehaviour sender, CurvySpline spline, CurvySplineSegment cp, ModeEnum mode = ModeEnum.None, object data = null)
			: base(sender, spline, data)
		{
			ControlPoint = cp;
			Mode = mode;
		}
	}
	public class CurvySplineEventArgs : CurvyEventArgs
	{
		public readonly CurvySpline Spline;

		public CurvySplineEventArgs(MonoBehaviour sender, CurvySpline spline, object data = null)
			: base(sender, data)
		{
			Spline = spline;
		}
	}
	[Serializable]
	public class CurvyCGEvent : UnityEventEx<CurvyCGEventArgs>
	{
	}
	public class CurvyCGEventArgs : EventArgs
	{
		public readonly MonoBehaviour Sender;

		public readonly CurvyGenerator Generator;

		public readonly CGModule Module;

		public CurvyCGEventArgs(CGModule module)
		{
			Sender = module;
			Generator = module.Generator;
			Module = module;
		}

		public CurvyCGEventArgs(CurvyGenerator generator, CGModule module)
		{
			Sender = generator;
			Generator = generator;
			Module = module;
		}
	}
	public static class CurvyGizmoHelper
	{
		public static Matrix4x4 Matrix = Matrix4x4.identity;

		public static void SegmentCurveGizmo(CurvySplineSegment seg, Color col, float stepSize = 0.05f)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			if (seg.Spline.Interpolation == CurvyInterpolation.Linear)
			{
				Gizmos.DrawLine(seg.Interpolate(0f), seg.Interpolate(1f));
				return;
			}
			Vector3 from = seg.Interpolate(0f);
			for (float num = stepSize; num < 1f; num += stepSize)
			{
				Vector3 vector = seg.Interpolate(num);
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
			Gizmos.DrawLine(from, seg.Interpolate(1f));
			Gizmos.matrix = matrix;
		}

		public static void SegmentApproximationGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Vector3 vector = new Vector3(0.1f / seg.Spline.transform.localScale.x, 0.1f / seg.Spline.transform.localScale.y, 0.1f / seg.Spline.transform.localScale.z);
			for (int i = 0; i < seg.Approximation.Length; i++)
			{
				Vector3 vector2 = seg.Approximation[i];
				Gizmos.DrawCube(vector2, DTUtility.GetHandleSize(vector2) * vector);
			}
			Gizmos.matrix = matrix;
		}

		public static void SegmentOrientationAnchorGizmo(CurvySplineSegment seg, Color col)
		{
			if (seg.ApproximationUp.Length != 0)
			{
				Matrix4x4 matrix = Gizmos.matrix;
				Gizmos.matrix = Matrix;
				Gizmos.color = col;
				Vector3 vector = new Vector3(1f / seg.Spline.transform.localScale.x, 1f / seg.Spline.transform.localScale.y, 1f / seg.Spline.transform.localScale.z);
				Vector3 vector2 = seg.ApproximationUp[0];
				vector2.Set(vector2.x * vector.x, vector2.y * vector.y, vector2.z * vector.z);
				Gizmos.DrawRay(seg.Approximation[0], vector2 * CurvyGlobalManager.GizmoOrientationLength * 1.75f);
				Gizmos.matrix = matrix;
			}
		}

		public static void SegmentOrientationGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Vector3 vector = new Vector3(1f / seg.Spline.transform.localScale.x, 1f / seg.Spline.transform.localScale.y, 1f / seg.Spline.transform.localScale.z);
			for (int i = 0; i < seg.ApproximationUp.Length; i++)
			{
				Vector3 vector2 = seg.ApproximationUp[i];
				vector2.Set(vector2.x * vector.x, vector2.y * vector.y, vector2.z * vector.z);
				Gizmos.DrawRay(seg.Approximation[i], vector2 * CurvyGlobalManager.GizmoOrientationLength);
			}
			Gizmos.matrix = matrix;
		}

		public static void SegmentTangentGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			for (int i = 0; i < seg.ApproximationT.Length; i++)
			{
				Gizmos.color = ((i != seg.CacheSize) ? ((i != 0) ? col : Color.blue) : Color.black);
				Vector3 from = seg.Approximation[i];
				Vector3 normalized = seg.ApproximationT[i].normalized;
				Gizmos.DrawRay(from, normalized * CurvyGlobalManager.GizmoOrientationLength);
			}
			Gizmos.matrix = matrix;
		}

		public static void ControlPointGizmo(CurvySplineSegment cp, bool selected, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix4x4.identity;
			Gizmos.color = col;
			Vector3 vector = Matrix.MultiplyPoint(cp.transform.localPosition);
			float num = ((!selected) ? 0.7f : 1f);
			if ((bool)cp.Spline && cp.Spline.RestrictTo2D)
			{
				Gizmos.DrawCube(vector, Vector3.one * DTUtility.GetHandleSize(vector) * num * CurvyGlobalManager.GizmoControlPointSize);
			}
			else
			{
				Gizmos.DrawSphere(vector, DTUtility.GetHandleSize(vector) * num * CurvyGlobalManager.GizmoControlPointSize);
			}
			Gizmos.matrix = matrix;
		}

		public static void BoundsGizmo(CurvySplineSegment cp, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Gizmos.DrawWireCube(cp.Bounds.center, cp.Bounds.size);
			Gizmos.matrix = matrix;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(PoolManager))]
	public class CurvyGlobalManager : DTSingleton<CurvyGlobalManager>
	{
		public static bool HideManager = false;

		public static float SceneViewResolution = 0.5f;

		public static Color DefaultGizmoColor = new Color(0.71f, 0.71f, 0.71f);

		public static Color DefaultGizmoSelectionColor = new Color(0.15f, 0.35f, 0.68f);

		public static CurvyInterpolation DefaultInterpolation = CurvyInterpolation.CatmullRom;

		public static float GizmoControlPointSize = 0.15f;

		public static float GizmoOrientationLength = 1f;

		public static Color GizmoOrientationColor = new Color(0.75f, 0.75f, 0.4f);

		public static int SplineLayer = 0;

		public static CurvySplineGizmos Gizmos = CurvySplineGizmos.Curve | CurvySplineGizmos.Orientation;

		private PoolManager mPoolManager;

		private ComponentPool mControlPointPool;

		public static bool ShowCurveGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Curve) == CurvySplineGizmos.Curve;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Curve;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Curve;
				}
			}
		}

		public static bool ShowApproximationGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Approximation) == CurvySplineGizmos.Approximation;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Approximation;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Approximation;
				}
			}
		}

		public static bool ShowTangentsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Tangents) == CurvySplineGizmos.Tangents;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Tangents;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Tangents;
				}
			}
		}

		public static bool ShowOrientationGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Orientation) == CurvySplineGizmos.Orientation;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Orientation;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Orientation;
				}
			}
		}

		public static bool ShowLabelsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Labels) == CurvySplineGizmos.Labels;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Labels;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Labels;
				}
			}
		}

		public static bool ShowMetadataGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Metadata) == CurvySplineGizmos.Metadata;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Metadata;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Metadata;
				}
			}
		}

		public static bool ShowBoundsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Bounds) == CurvySplineGizmos.Bounds;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Bounds;
				}
				else
				{
					Gizmos &= ~CurvySplineGizmos.Bounds;
				}
			}
		}

		public PoolManager PoolManager
		{
			get
			{
				if (mPoolManager == null)
				{
					mPoolManager = GetComponent<PoolManager>();
				}
				return mPoolManager;
			}
		}

		public ComponentPool ControlPointPool => mControlPointPool;

		public CurvyConnection[] Connections => GetComponentsInChildren<CurvyConnection>();

		public CurvyConnection[] GetContainingConnections(params CurvySpline[] splines)
		{
			List<CurvyConnection> list = new List<CurvyConnection>();
			List<CurvySpline> list2 = new List<CurvySpline>(splines);
			foreach (CurvySpline item in list2)
			{
				foreach (CurvySplineSegment controlPoints in item.ControlPointsList)
				{
					if (!(controlPoints.Connection != null) || list.Contains(controlPoints.Connection))
					{
						continue;
					}
					bool flag = true;
					foreach (CurvySplineSegment controlPoints2 in controlPoints.Connection.ControlPointsList)
					{
						if (controlPoints2.Spline != null && !list2.Contains(controlPoints2.Spline))
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						list.Add(controlPoints.Connection);
					}
				}
			}
			return list.ToArray();
		}

		public override void Awake()
		{
			base.Awake();
			base.name = "_CurvyGlobal_";
			base.transform.SetAsLastSibling();
			if (Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(this);
			}
			mPoolManager = GetComponent<PoolManager>();
			PoolSettings poolSettings = new PoolSettings();
			poolSettings.MinItems = 0;
			poolSettings.Threshold = 50;
			poolSettings.Prewarm = true;
			poolSettings.AutoCreate = true;
			poolSettings.AutoEnableDisable = true;
			PoolSettings settings = poolSettings;
			mControlPointPool = mPoolManager.CreateComponentPool<CurvySplineSegment>(settings);
		}

		private void Start()
		{
			if (HideManager)
			{
				base.gameObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				base.gameObject.hideFlags = HideFlags.None;
			}
		}

		[RuntimeInitializeOnLoadMethod]
		private static void LoadRuntimeSettings()
		{
			if (!PlayerPrefs.HasKey("Curvy_MaxCachePPU"))
			{
				SaveRuntimeSettings();
			}
			SceneViewResolution = DTUtility.GetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
			HideManager = DTUtility.GetPlayerPrefs("Curvy_HideManager", HideManager);
			DefaultGizmoColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
			DefaultGizmoSelectionColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoColor);
			DefaultInterpolation = DTUtility.GetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
			GizmoControlPointSize = DTUtility.GetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
			GizmoOrientationLength = DTUtility.GetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
			GizmoOrientationColor = DTUtility.GetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
			Gizmos = DTUtility.GetPlayerPrefs("Curvy_Gizmos", Gizmos);
			SplineLayer = DTUtility.GetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
		}

		public static void SaveRuntimeSettings()
		{
			DTUtility.SetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
			DTUtility.SetPlayerPrefs("Curvy_HideManager", HideManager);
			DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
			DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoSelectionColor);
			DTUtility.SetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
			DTUtility.SetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
			DTUtility.SetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
			DTUtility.SetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
			DTUtility.SetPlayerPrefs("Curvy_Gizmos", Gizmos);
			DTUtility.SetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
			PlayerPrefs.Save();
		}

		public override void MergeDoubleLoaded(IDTSingleton newInstance)
		{
			base.MergeDoubleLoaded(newInstance);
			CurvyGlobalManager curvyGlobalManager = newInstance as CurvyGlobalManager;
			CurvyConnection[] connections = curvyGlobalManager.Connections;
			for (int i = 0; i < connections.Length; i++)
			{
				connections[i].transform.SetParent(base.transform);
			}
		}
	}
	[ExecuteInEditMode]
	public class CurvyMetadataBase : MonoBehaviour
	{
		private CurvySplineSegment mCP;

		public CurvySplineSegment ControlPoint => mCP;

		public CurvySpline Spline => (!mCP) ? null : mCP.Spline;

		protected virtual void Awake()
		{
			mCP = GetComponent<CurvySplineSegment>();
		}

		public T GetPreviousData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : MonoBehaviour, ICurvyMetadata
		{
			if ((bool)ControlPoint)
			{
				CurvySplineSegment controlPoint = ControlPoint;
				CurvySpline spline = Spline;
				CurvySplineSegment curvySplineSegment;
				if (!spline || spline.ControlPointsList.Count == 0)
				{
					curvySplineSegment = null;
				}
				else
				{
					curvySplineSegment = ((!useFollowUp) ? spline.GetPreviousControlPoint(controlPoint) : spline.GetPreviousControlPointUsingFollowUp(controlPoint));
					if (segmentsOnly && (bool)curvySplineSegment && !spline.IsControlPointASegment(curvySplineSegment))
					{
						curvySplineSegment = null;
					}
				}
				if ((bool)curvySplineSegment)
				{
					return curvySplineSegment.GetMetadata<T>(autoCreate);
				}
			}
			return (T)null;
		}

		public T GetNextData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : MonoBehaviour, ICurvyMetadata
		{
			if ((bool)ControlPoint)
			{
				CurvySplineSegment controlPoint = ControlPoint;
				CurvySpline spline = Spline;
				CurvySplineSegment curvySplineSegment;
				if (!spline || spline.ControlPointsList.Count == 0)
				{
					curvySplineSegment = null;
				}
				else
				{
					curvySplineSegment = ((!useFollowUp) ? spline.GetNextControlPoint(controlPoint) : spline.GetNextControlPointUsingFollowUp(controlPoint));
					if (segmentsOnly && (bool)curvySplineSegment && !spline.IsControlPointASegment(curvySplineSegment))
					{
						curvySplineSegment = null;
					}
				}
				if ((bool)curvySplineSegment)
				{
					return curvySplineSegment.GetMetadata<T>(autoCreate);
				}
			}
			return (T)null;
		}

		protected void NotifyModification()
		{
			CurvySpline spline = Spline;
			if ((bool)spline && spline.IsInitialized)
			{
				spline.NotifyMetaDataModification();
			}
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public class CGResourceManagerAttribute : DTPropertyAttribute
	{
		public readonly string ResourceName;

		public bool ReadOnly;

		public CGResourceManagerAttribute(string resourceName)
			: base(string.Empty, string.Empty)
		{
			ResourceName = resourceName;
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public sealed class CGResourceCollectionManagerAttribute : CGResourceManagerAttribute
	{
		public bool ShowCount;

		public CGResourceCollectionManagerAttribute(string resourceName)
			: base(resourceName)
		{
			ReadOnly = true;
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public sealed class CGDataReferenceSelectorAttribute : DTPropertyAttribute
	{
		public readonly Type DataType;

		public CGDataReferenceSelectorAttribute(Type dataType)
			: base(string.Empty, string.Empty)
		{
			DataType = dataType;
		}
	}
	[RequireComponent(typeof(CurvySpline))]
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvyshape")]
	public class CurvyShape : DTVersionedMonoBehaviour
	{
		[SerializeField]
		[Label("Plane", "")]
		private CurvyPlane m_Plane;

		[SerializeField]
		[HideInInspector]
		private bool m_Persistent = true;

		private static Dictionary<CurvyShapeInfo, Type> mShapeDefs = new Dictionary<CurvyShapeInfo, Type>();

		private CurvySpline mSpline;

		[NonSerialized]
		public bool Dirty;

		public CurvyPlane Plane
		{
			get
			{
				return m_Plane;
			}
			set
			{
				if (m_Plane != value)
				{
					m_Plane = value;
					Dirty = true;
				}
			}
		}

		public bool Persistent
		{
			get
			{
				return m_Persistent;
			}
			set
			{
				if (m_Persistent != value)
				{
					m_Persistent = value;
					base.hideFlags = ((!value) ? HideFlags.HideInInspector : HideFlags.None);
				}
			}
		}

		public CurvySpline Spline
		{
			get
			{
				if (!mSpline)
				{
					mSpline = GetComponent<CurvySpline>();
				}
				return mSpline;
			}
		}

		public static Dictionary<CurvyShapeInfo, Type> ShapeDefinitions
		{
			get
			{
				if (mShapeDefs.Count == 0)
				{
					mShapeDefs = typeof(CurvyShape).GetAllTypesWithAttribute<CurvyShapeInfo>();
				}
				return mShapeDefs;
			}
		}

		private void Update()
		{
			base.hideFlags = ((!Persistent) ? HideFlags.HideInInspector : HideFlags.None);
			Refresh();
		}

		protected virtual void Reset()
		{
			Plane = CurvyPlane.XY;
		}

		public void Delete()
		{
			UnityEngine.Object.Destroy(this);
		}

		public void Refresh()
		{
			if ((bool)Spline && Spline.IsInitialized && Dirty)
			{
				ApplyShape();
				applyPlane();
				Spline.SetDirtyAll();
				Spline.Refresh();
			}
			Dirty = false;
		}

		public CurvyShape Replace(string menuName)
		{
			bool persistent = Persistent;
			Type shapeType = GetShapeType(menuName);
			if (shapeType != null)
			{
				GameObject gameObject = base.gameObject;
				Delete();
				CurvyShape curvyShape = (CurvyShape)gameObject.AddComponent(shapeType);
				curvyShape.Persistent = persistent;
				curvyShape.Dirty = true;
				return curvyShape;
			}
			return null;
		}

		protected void PrepareSpline(CurvyInterpolation interpolation, CurvyOrientation orientation = CurvyOrientation.Dynamic, int cachedensity = 50, bool closed = true)
		{
			Spline.Interpolation = interpolation;
			Spline.Orientation = orientation;
			Spline.CacheDensity = cachedensity;
			Spline.Closed = closed;
			Spline.RestrictTo2D = this is CurvyShape2D;
		}

		protected void SetPosition(int no, Vector3 position)
		{
			Spline.ControlPointsList[no].SetLocalPosition(position);
		}

		protected void SetRotation(int no, Quaternion rotation)
		{
			Spline.ControlPointsList[no].SetLocalRotation(rotation);
		}

		protected void SetBezierHandles(int no, float distanceFrag)
		{
			SetBezierHandles(no, distanceFrag, distanceFrag);
		}

		protected void SetBezierHandles(int no, float inDistanceFrag, float outDistanceFrag)
		{
			CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];
			if (no >= 0 && no < Spline.ControlPointCount)
			{
				if (inDistanceFrag == outDistanceFrag)
				{
					curvySplineSegment.AutoHandles = true;
					curvySplineSegment.AutoHandleDistance = inDistanceFrag;
					return;
				}
				curvySplineSegment.AutoHandles = false;
				curvySplineSegment.AutoHandleDistance = (inDistanceFrag + outDistanceFrag) / 2f;
				SetBezierHandles(inDistanceFrag, true, false, curvySplineSegment);
				SetBezierHandles(outDistanceFrag, false, true, curvySplineSegment);
			}
		}

		protected void SetBezierHandles(int no, Vector3 i, Vector3 o, Space space = Space.World)
		{
			if (no >= 0 && no < Spline.ControlPointCount)
			{
				CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];
				curvySplineSegment.AutoHandles = false;
				if (space == Space.World)
				{
					curvySplineSegment.HandleInPosition = i;
					curvySplineSegment.HandleOutPosition = o;
				}
				else
				{
					curvySplineSegment.HandleIn = i;
					curvySplineSegment.HandleOut = o;
				}
			}
		}

		public static void SetBezierHandles(float distanceFrag, bool setIn, bool setOut, params CurvySplineSegment[] controlPoints)
		{
			if (controlPoints.Length != 0)
			{
				foreach (CurvySplineSegment curvySplineSegment in controlPoints)
				{
					curvySplineSegment.SetBezierHandles(distanceFrag, setIn, setOut);
				}
			}
		}

		protected void SetCGHardEdges(params int[] controlPoints)
		{
			if (controlPoints.Length == 0)
			{
				for (int i = 0; i < Spline.ControlPointCount; i++)
				{
					Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge = true;
				}
				return;
			}
			for (int j = 0; j < controlPoints.Length; j++)
			{
				if (j >= 0 && j < Spline.ControlPointCount)
				{
					Spline.ControlPointsList[j].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge = true;
				}
			}
		}

		protected virtual void ApplyShape()
		{
		}

		protected void PrepareControlPoints(int count)
		{
			int i = count - Spline.ControlPointCount;
			bool flag = i != 0;
			while (i > 0)
			{
				Spline.InsertAfter(null, skipRefreshingAndEvents: true);
				i--;
			}
			for (; i < 0; i++)
			{
				Spline.Delete(Spline.LastVisibleControlPoint, skipRefreshingAndEvents: true);
			}
			for (int j = 0; j < Spline.ControlPointsList.Count; j++)
			{
				CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[j];
				curvySplineSegment.Reset();
				curvySplineSegment.Disconnect();
				MetaCGOptions metadata = curvySplineSegment.GetMetadata<MetaCGOptions>();
				if ((bool)metadata)
				{
					metadata.Reset();
				}
			}
			if (flag)
			{
				Spline.Refresh();
			}
		}

		public static List<string> GetShapesMenuNames(bool only2D = false)
		{
			List<string> list = new List<string>();
			foreach (CurvyShapeInfo key in ShapeDefinitions.Keys)
			{
				if (!only2D || key.Is2D)
				{
					list.Add(key.Name);
				}
			}
			return list;
		}

		public static List<string> GetShapesMenuNames(Type currentShapeType, out int currentIndex, bool only2D = false)
		{
			currentIndex = 0;
			if (currentShapeType == null)
			{
				return GetShapesMenuNames(only2D);
			}
			List<string> list = new List<string>();
			foreach (KeyValuePair<CurvyShapeInfo, Type> shapeDefinition in ShapeDefinitions)
			{
				if (!only2D || shapeDefinition.Key.Is2D)
				{
					list.Add(shapeDefinition.Key.Name);
				}
				if (shapeDefinition.Value == currentShapeType)
				{
					currentIndex = list.Count - 1;
				}
			}
			return list;
		}

		public static string GetShapeName(Type shapeType)
		{
			foreach (KeyValuePair<CurvyShapeInfo, Type> shapeDefinition in ShapeDefinitions)
			{
				if (shapeDefinition.Value == shapeType)
				{
					return shapeDefinition.Key.Name;
				}
			}
			return null;
		}

		public static Type GetShapeType(string menuName)
		{
			foreach (CurvyShapeInfo key in ShapeDefinitions.Keys)
			{
				if (key.Name == menuName)
				{
					return ShapeDefinitions[key];
				}
			}
			return null;
		}

		private void applyPlane()
		{
			switch (Plane)
			{
			case CurvyPlane.XZ:
				applyRotation(Quaternion.Euler(90f, 0f, 0f));
				break;
			case CurvyPlane.YZ:
				applyRotation(Quaternion.Euler(0f, 90f, 0f));
				break;
			default:
				applyRotation(Quaternion.Euler(0f, 0f, 0f));
				break;
			}
		}

		private void applyRotation(Quaternion q)
		{
			Spline.transform.localRotation = Quaternion.identity;
			if (Spline.Interpolation == CurvyInterpolation.Bezier)
			{
				for (int i = 0; i < Spline.ControlPointCount; i++)
				{
					CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[i];
					curvySplineSegment.SetLocalPosition(q * curvySplineSegment.transform.localPosition);
					curvySplineSegment.HandleIn = q * curvySplineSegment.HandleIn;
					curvySplineSegment.HandleOut = q * curvySplineSegment.HandleOut;
				}
			}
			else
			{
				for (int j = 0; j < Spline.ControlPointCount; j++)
				{
					CurvySplineSegment curvySplineSegment2 = Spline.ControlPointsList[j];
					curvySplineSegment2.SetLocalRotation(Quaternion.identity);
					curvySplineSegment2.SetLocalPosition(q * curvySplineSegment2.transform.localPosition);
				}
			}
			Spline.ControlPointsList[0].transform.localRotation = q;
		}
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
	public sealed class CurvyShapeInfo : Attribute
	{
		public readonly string Name;

		public readonly bool Is2D;

		public CurvyShapeInfo(string name, bool is2D = true)
		{
			Name = name;
			Is2D = is2D;
		}
	}
	public class CurvyShape2D : CurvyShape
	{
	}
	[HelpURL("https://curvyeditor.com/doclink/curvyspline")]
	[AddComponentMenu("Curvy/Curvy Spline", 1)]
	[ExecuteInEditMode]
	public class CurvySpline : DTVersionedMonoBehaviour
	{
		public const string VERSION = "5.2.0";

		public const string APIVERSION = "520";

		public const string WEBROOT = "https://curvyeditor.com/";

		public const string DOCLINK = "https://curvyeditor.com/doclink/";

		[SerializeField]
		[HideInInspector]
		private List<CurvySplineSegment> ControlPoints = new List<CurvySplineSegment>();

		[HideInInspector]
		public bool ShowGizmos = true;

		[Section("General", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_general")]
		[Tooltip("Interpolation Method")]
		[SerializeField]
		[FormerlySerializedAs("Interpolation")]
		private CurvyInterpolation m_Interpolation = CurvyGlobalManager.DefaultInterpolation;

		[Tooltip("Restrict Control Points to local X/Y axis")]
		[FieldAction("CBCheck2DPlanar", ActionAttribute.ActionEnum.Callback)]
		[SerializeField]
		private bool m_RestrictTo2D;

		[SerializeField]
		[FormerlySerializedAs("Closed")]
		private bool m_Closed;

		[FieldCondition("canHaveManualEndCP", Action = ActionAttribute.ActionEnum.Enable)]
		[Tooltip("Handle End Control Points automatically?")]
		[SerializeField]
		[FormerlySerializedAs("AutoEndTangents")]
		private bool m_AutoEndTangents = true;

		[Tooltip("Orientation Flow")]
		[SerializeField]
		[FormerlySerializedAs("Orientation")]
		private CurvyOrientation m_Orientation = CurvyOrientation.Dynamic;

		[Section("Global Bezier Options", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_bezier")]
		[GroupCondition("m_Interpolation", CurvyInterpolation.Bezier, false)]
		[RangeEx(0f, 1f, "Default Distance %", "Handle length by distance to neighbours")]
		[SerializeField]
		private float m_AutoHandleDistance = 0.39f;

		[Section("Global TCB Options", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_tcb")]
		[GroupCondition("m_Interpolation", CurvyInterpolation.TCB, false)]
		[GroupAction("TCBOptionsGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("Tension")]
		private float m_Tension;

		[SerializeField]
		[FormerlySerializedAs("Continuity")]
		private float m_Continuity;

		[SerializeField]
		[FormerlySerializedAs("Bias")]
		private float m_Bias;

		[Section("Advanced Settings", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_advanced")]
		[FieldAction("ShowGizmoGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Above)]
		[Label("Color", "Gizmo color")]
		[SerializeField]
		private Color m_GizmoColor = CurvyGlobalManager.DefaultGizmoColor;

		[Label("Active Color", "Selected Gizmo color")]
		[SerializeField]
		private Color m_GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;

		[RangeEx(1f, 100f, "", "")]
		[SerializeField]
		[FormerlySerializedAs("Granularity")]
		[Tooltip("Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's MaxPointsPerUnit")]
		private int m_CacheDensity = 50;

		[SerializeField]
		[Tooltip("The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example")]
		private float m_MaxPointsPerUnit = 8f;

		[SerializeField]
		[Tooltip("Use a GameObject pool at runtime")]
		private bool m_UsePooling = true;

		[SerializeField]
		[Tooltip("Use threading where applicable. Threading is is currently not supported when targetting WebGL and Universal Windows Platform")]
		private bool m_UseThreading;

		[Tooltip("Refresh when Control Point position change?")]
		[SerializeField]
		[FormerlySerializedAs("AutoRefresh")]
		private bool m_CheckTransform = true;

		[SerializeField]
		private CurvyUpdateMethod m_UpdateIn;

		[Group("Events", Expanded = false, Sort = 1000, HelpURL = "https://curvyeditor.com/doclink/curvyspline_events")]
		[SortOrder(0)]
		[SerializeField]
		private CurvySplineEvent m_OnRefresh = new CurvySplineEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(1)]
		[SerializeField]
		private CurvySplineEvent m_OnAfterControlPointChanges = new CurvySplineEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(2)]
		[SerializeField]
		private CurvyControlPointEvent m_OnBeforeControlPointAdd = new CurvyControlPointEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(3)]
		[SerializeField]
		private CurvyControlPointEvent m_OnAfterControlPointAdd = new CurvyControlPointEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(4)]
		[SerializeField]
		private CurvyControlPointEvent m_OnBeforeControlPointDelete = new CurvyControlPointEvent();

		private bool mIsInitialized;

		private bool isStarted;

		private bool sendOnRefreshEventNextUpdate;

		private readonly object controlPointsRelationshipCacheLock = new object();

		private List<CurvySplineSegment> mSegments = new List<CurvySplineSegment>();

		private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

		private float length = -1f;

		private int mCacheSize = -1;

		private Bounds? mBounds;

		private bool mDirtyCurve;

		private bool mDirtyOrientation;

		private HashSet<CurvySplineSegment> dirtyControlPointsMinimalSet = new HashSet<CurvySplineSegment>();

		private List<CurvySplineSegment> dirtyCpsExtendedList = new List<CurvySplineSegment>();

		private bool allControlPointsAreDirty;

		private ThreadPoolWorker<CurvySplineSegment> mThreadWorker = new ThreadPoolWorker<CurvySplineSegment>();

		private readonly CurvySplineEventArgs defaultSplineEventArgs;

		private readonly CurvyControlPointEventArgs defaultAddAfterEventArgs;

		private readonly CurvyControlPointEventArgs defaultDeleteEventArgs;

		private CurvySplineSegment _lastDistToSeg;

		private readonly Action<CurvySplineSegment> refreshCurveAction;

		private Vector3 lastProcessedPosition;

		private Quaternion lastProcessedRotation;

		private Vector3 lastProcessedScale;

		private bool globalCoordinatesChangedThisFrame;

		private bool isCpsRelationshipCacheValid;

		private CurvySplineSegment firstSegment;

		private CurvySplineSegment lastSegment;

		private CurvySplineSegment firstVisibleControlPoint;

		private CurvySplineSegment lastVisibleControlPoint;

		public CurvyInterpolation Interpolation
		{
			get
			{
				return m_Interpolation;
			}
			set
			{
				if (m_Interpolation != value)
				{
					m_Interpolation = value;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
				AutoEndTangents = m_AutoEndTangents;
			}
		}

		public bool RestrictTo2D
		{
			get
			{
				return m_RestrictTo2D;
			}
			set
			{
				if (m_RestrictTo2D != value)
				{
					m_RestrictTo2D = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float AutoHandleDistance
		{
			get
			{
				return m_AutoHandleDistance;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_AutoHandleDistance != num)
				{
					m_AutoHandleDistance = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool Closed
		{
			get
			{
				return m_Closed;
			}
			set
			{
				if (m_Closed != value)
				{
					m_Closed = value;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
				}
				AutoEndTangents = m_AutoEndTangents;
			}
		}

		public bool AutoEndTangents
		{
			get
			{
				return m_AutoEndTangents;
			}
			set
			{
				bool flag = !canHaveManualEndCP() || value;
				if (m_AutoEndTangents != flag)
				{
					m_AutoEndTangents = flag;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
				}
			}
		}

		public CurvyOrientation Orientation
		{
			get
			{
				return m_Orientation;
			}
			set
			{
				if (m_Orientation != value)
				{
					m_Orientation = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public CurvyUpdateMethod UpdateIn
		{
			get
			{
				return m_UpdateIn;
			}
			set
			{
				if (m_UpdateIn != value)
				{
					m_UpdateIn = value;
				}
			}
		}

		public Color GizmoColor
		{
			get
			{
				return m_GizmoColor;
			}
			set
			{
				if (m_GizmoColor != value)
				{
					m_GizmoColor = value;
				}
			}
		}

		public Color GizmoSelectionColor
		{
			get
			{
				return m_GizmoSelectionColor;
			}
			set
			{
				if (m_GizmoSelectionColor != value)
				{
					m_GizmoSelectionColor = value;
				}
			}
		}

		public int CacheDensity
		{
			get
			{
				return m_CacheDensity;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_CacheDensity != num)
				{
					m_CacheDensity = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float MaxPointsPerUnit
		{
			get
			{
				return m_MaxPointsPerUnit;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.0001f, 1000f);
				if (m_MaxPointsPerUnit != num)
				{
					m_MaxPointsPerUnit = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool UsePooling
		{
			get
			{
				return m_UsePooling;
			}
			set
			{
				if (m_UsePooling != value)
				{
					m_UsePooling = value;
				}
			}
		}

		public bool UseThreading
		{
			get
			{
				return m_UseThreading;
			}
			set
			{
				if (m_UseThreading != value)
				{
					m_UseThreading = value;
				}
			}
		}

		public bool CheckTransform
		{
			get
			{
				return m_CheckTransform;
			}
			set
			{
				if (m_CheckTransform != value)
				{
					m_CheckTransform = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Tension
		{
			get
			{
				return m_Tension;
			}
			set
			{
				if (m_Tension != value)
				{
					m_Tension = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Continuity
		{
			get
			{
				return m_Continuity;
			}
			set
			{
				if (m_Continuity != value)
				{
					m_Continuity = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Bias
		{
			get
			{
				return m_Bias;
			}
			set
			{
				if (m_Bias != value)
				{
					m_Bias = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool IsInitialized => mIsInitialized;

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					Bounds bounds2;
					if (Count > 0)
					{
						Bounds bounds = this[0].Bounds;
						for (int i = 1; i < Count; i++)
						{
							bounds.Encapsulate(this[i].Bounds);
						}
						bounds2 = bounds;
					}
					else
					{
						bounds2 = new Bounds(base.transform.position, Vector3.zero);
					}
					if (!Dirty)
					{
						mBounds = bounds2;
					}
					return bounds2;
				}
				return mBounds.Value;
			}
		}

		public int Count => Segments.Count;

		public int ControlPointCount => ControlPoints.Count;

		public int CacheSize
		{
			get
			{
				if (mCacheSize < 0)
				{
					int num = 0;
					List<CurvySplineSegment> segments = Segments;
					for (int i = 0; i < segments.Count; i++)
					{
						num += segments[i].CacheSize;
					}
					if (!Dirty)
					{
						mCacheSize = num;
					}
					return num;
				}
				return mCacheSize;
			}
		}

		public float Length
		{
			get
			{
				if (length < 0f)
				{
					float result = ((Segments.Count != 0) ? ((!Closed) ? LastVisibleControlPoint.Distance : (this[Count - 1].Distance + this[Count - 1].Length)) : 0f);
					if (!Dirty)
					{
						length = result;
					}
					return result;
				}
				return length;
			}
		}

		public bool Dirty => allControlPointsAreDirty || dirtyControlPointsMinimalSet.Count > 0;

		public CurvySplineSegment this[int idx] => Segments[idx];

		public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
		{
			get
			{
				if (readOnlyControlPoints == null)
				{
					readOnlyControlPoints = ControlPoints.AsReadOnly();
				}
				return readOnlyControlPoints;
			}
		}

		[CanBeNull]
		public CurvySplineSegment FirstVisibleControlPoint
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return firstVisibleControlPoint;
			}
		}

		[CanBeNull]
		public CurvySplineSegment LastVisibleControlPoint
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return lastVisibleControlPoint;
			}
		}

		public CurvySplineSegment FirstSegment
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return firstSegment;
			}
		}

		public CurvySplineSegment LastSegment
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return lastSegment;
			}
		}

		[Obsolete("Use Closed instead")]
		public bool IsClosed => Closed;

		public CurvySpline NextSpline
		{
			get
			{
				CurvySplineSegment curvySplineSegment = LastVisibleControlPoint;
				return (!curvySplineSegment || !curvySplineSegment.FollowUp) ? null : curvySplineSegment.FollowUp.Spline;
			}
		}

		public CurvySpline PreviousSpline
		{
			get
			{
				CurvySplineSegment curvySplineSegment = FirstVisibleControlPoint;
				return (!curvySplineSegment || !curvySplineSegment.FollowUp) ? null : curvySplineSegment.FollowUp.Spline;
			}
		}

		public bool GlobalCoordinatesChangedThisFrame => globalCoordinatesChangedThisFrame;

		public Action<CurvySpline> OnGlobalCoordinatesChanged { get; set; }

		public CurvySplineEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public CurvySplineEvent OnAfterControlPointChanges
		{
			get
			{
				return m_OnAfterControlPointChanges;
			}
			set
			{
				if (m_OnAfterControlPointChanges != value)
				{
					m_OnAfterControlPointChanges = value;
				}
			}
		}

		public CurvyControlPointEvent OnBeforeControlPointAdd
		{
			get
			{
				return m_OnBeforeControlPointAdd;
			}
			set
			{
				if (m_OnBeforeControlPointAdd != value)
				{
					m_OnBeforeControlPointAdd = value;
				}
			}
		}

		public CurvyControlPointEvent OnAfterControlPointAdd
		{
			get
			{
				return m_OnAfterControlPointAdd;
			}
			set
			{
				if (m_OnAfterControlPointAdd != value)
				{
					m_OnAfterControlPointAdd = value;
				}
			}
		}

		public CurvyControlPointEvent OnBeforeControlPointDelete
		{
			get
			{
				return m_OnBeforeControlPointDelete;
			}
			set
			{
				if (m_OnBeforeControlPointDelete != value)
				{
					m_OnBeforeControlPointDelete = value;
				}
			}
		}

		private List<CurvySplineSegment> controlPoints => ControlPoints;

		private List<CurvySplineSegment> Segments
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return mSegments;
			}
		}

		public CurvySpline()
		{
			refreshCurveAction = delegate(CurvySplineSegment controlPoint)
			{
				controlPoint.refreshCurveINTERNAL(Interpolation, IsControlPointASegment(controlPoint), this);
			};
			defaultSplineEventArgs = new CurvySplineEventArgs(this, this);
			defaultAddAfterEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.AddAfter);
			defaultDeleteEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.Delete);
		}

		public static CurvySpline Create()
		{
			CurvySpline component = new GameObject("Curvy Spline", typeof(CurvySpline)).GetComponent<CurvySpline>();
			component.gameObject.layer = CurvyGlobalManager.SplineLayer;
			component.Start();
			return component;
		}

		public static CurvySpline Create(CurvySpline takeOptionsFrom)
		{
			CurvySpline curvySpline = Create();
			if ((bool)takeOptionsFrom)
			{
				curvySpline.RestrictTo2D = takeOptionsFrom.RestrictTo2D;
				curvySpline.GizmoColor = takeOptionsFrom.GizmoColor;
				curvySpline.GizmoSelectionColor = takeOptionsFrom.GizmoSelectionColor;
				curvySpline.Interpolation = takeOptionsFrom.Interpolation;
				curvySpline.Closed = takeOptionsFrom.Closed;
				curvySpline.AutoEndTangents = takeOptionsFrom.AutoEndTangents;
				curvySpline.CacheDensity = takeOptionsFrom.CacheDensity;
				curvySpline.MaxPointsPerUnit = takeOptionsFrom.MaxPointsPerUnit;
				curvySpline.Orientation = takeOptionsFrom.Orientation;
				curvySpline.CheckTransform = takeOptionsFrom.CheckTransform;
			}
			return curvySpline;
		}

		public static int CalculateCacheSize(int density, float splineLength, float maxPointsPerUnit)
		{
			return Mathf.FloorToInt(CalculateSamplingPointsPerUnit(density, maxPointsPerUnit) * splineLength) + 1;
		}

		public static float CalculateSamplingPointsPerUnit(int density, float maxPointsPerUnit)
		{
			int num = Mathf.Clamp(density, 1, 100);
			if (num != density)
			{
				DTLog.LogWarning("[Curvy] CalculateSamplingPointsPerUnit got an invalid density parameter. It should be between 1 and 100. The parameter value was " + density);
				density = num;
			}
			return DTTween.QuadIn(density - 1, 0f, maxPointsPerUnit, 99f);
		}

		public static Vector3 Bezier(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			double num = (double)(0f - P0.x) + 3.0 * (double)T0.x + -3.0 * (double)T1.x + (double)P1.x;
			double num2 = 3.0 * (double)P0.x + -6.0 * (double)T0.x + 3.0 * (double)T1.x;
			double num3 = -3.0 * (double)P0.x + 3.0 * (double)T0.x;
			double num4 = P0.x;
			double num5 = (double)(0f - P0.y) + 3.0 * (double)T0.y + -3.0 * (double)T1.y + (double)P1.y;
			double num6 = 3.0 * (double)P0.y + -6.0 * (double)T0.y + 3.0 * (double)T1.y;
			double num7 = -3.0 * (double)P0.y + 3.0 * (double)T0.y;
			double num8 = P0.y;
			double num9 = (double)(0f - P0.z) + 3.0 * (double)T0.z + -3.0 * (double)T1.z + (double)P1.z;
			double num10 = 3.0 * (double)P0.z + -6.0 * (double)T0.z + 3.0 * (double)T1.z;
			double num11 = -3.0 * (double)P0.z + 3.0 * (double)T0.z;
			double num12 = P0.z;
			float x = (float)(((num * (double)f + num2) * (double)f + num3) * (double)f + num4);
			float y = (float)(((num5 * (double)f + num6) * (double)f + num7) * (double)f + num8);
			float z = (float)(((num9 * (double)f + num10) * (double)f + num11) * (double)f + num12);
			return new Vector3(x, y, z);
		}

		public static float BezierTangent(float T0, float P0, float P1, float T1, float t)
		{
			float num = P1 - 3f * T1 + 3f * T0 - P0;
			float num2 = 3f * T1 - 6f * T0 + 3f * P0;
			float num3 = 3f * T0 - 3f * P0;
			return 3f * num * t * t + 2f * num2 * t + num3;
		}

		public static Vector3 BezierTangent(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			Vector3 vector = P1 - 3f * T1 + 3f * T0 - P0;
			Vector3 vector2 = 3f * T1 - 6f * T0 + 3f * P0;
			Vector3 vector3 = 3f * T0 - 3f * P0;
			return 3f * vector * f * f + 2f * vector2 * f + vector3;
		}

		public static Vector3 CatmullRom(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			double num = -0.5 * (double)T0.x + 1.5 * (double)P0.x + -1.5 * (double)P1.x + 0.5 * (double)T1.x;
			double num2 = (double)T0.x + -2.5 * (double)P0.x + 2.0 * (double)P1.x + -0.5 * (double)T1.x;
			double num3 = -0.5 * (double)T0.x + 0.5 * (double)P1.x;
			double num4 = P0.x;
			double num5 = -0.5 * (double)T0.y + 1.5 * (double)P0.y + -1.5 * (double)P1.y + 0.5 * (double)T1.y;
			double num6 = (double)T0.y + -2.5 * (double)P0.y + 2.0 * (double)P1.y + -0.5 * (double)T1.y;
			double num7 = -0.5 * (double)T0.y + 0.5 * (double)P1.y;
			double num8 = P0.y;
			double num9 = -0.5 * (double)T0.z + 1.5 * (double)P0.z + -1.5 * (double)P1.z + 0.5 * (double)T1.z;
			double num10 = (double)T0.z + -2.5 * (double)P0.z + 2.0 * (double)P1.z + -0.5 * (double)T1.z;
			double num11 = -0.5 * (double)T0.z + 0.5 * (double)P1.z;
			double num12 = P0.z;
			float x = (float)(((num * (double)f + num2) * (double)f + num3) * (double)f + num4);
			float y = (float)(((num5 * (double)f + num6) * (double)f + num7) * (double)f + num8);
			float z = (float)(((num9 * (double)f + num10) * (double)f + num11) * (double)f + num12);
			return new Vector3(x, y, z);
		}

		public static Vector3 TCB(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f, float FT0, float FC0, float FB0, float FT1, float FC1, float FB1)
		{
			double num = (1f - FT0) * (1f + FC0) * (1f + FB0);
			double num2 = (1f - FT0) * (1f - FC0) * (1f - FB0);
			double num3 = (1f - FT1) * (1f - FC1) * (1f + FB1);
			double num4 = (1f - FT1) * (1f + FC1) * (1f - FB1);
			double num5 = 2.0;
			double num6 = (0.0 - num) / num5;
			double num7 = (4.0 + num - num2 - num3) / num5;
			double num8 = (-4.0 + num2 + num3 - num4) / num5;
			double num9 = num4 / num5;
			double num10 = 2.0 * num / num5;
			double num11 = (-6.0 - 2.0 * num + 2.0 * num2 + num3) / num5;
			double num12 = (6.0 - 2.0 * num2 - num3 + num4) / num5;
			double num13 = (0.0 - num4) / num5;
			double num14 = (0.0 - num) / num5;
			double num15 = (num - num2) / num5;
			double num16 = num2 / num5;
			double num17 = 2.0 / num5;
			double num18 = num6 * (double)T0.x + num7 * (double)P0.x + num8 * (double)P1.x + num9 * (double)T1.x;
			double num19 = num10 * (double)T0.x + num11 * (double)P0.x + num12 * (double)P1.x + num13 * (double)T1.x;
			double num20 = num14 * (double)T0.x + num15 * (double)P0.x + num16 * (double)P1.x;
			double num21 = num17 * (double)P0.x;
			double num22 = num6 * (double)T0.y + num7 * (double)P0.y + num8 * (double)P1.y + num9 * (double)T1.y;
			double num23 = num10 * (double)T0.y + num11 * (double)P0.y + num12 * (double)P1.y + num13 * (double)T1.y;
			double num24 = num14 * (double)T0.y + num15 * (double)P0.y + num16 * (double)P1.y;
			double num25 = num17 * (double)P0.y;
			double num26 = num6 * (double)T0.z + num7 * (double)P0.z + num8 * (double)P1.z + num9 * (double)T1.z;
			double num27 = num10 * (double)T0.z + num11 * (double)P0.z + num12 * (double)P1.z + num13 * (double)T1.z;
			double num28 = num14 * (double)T0.z + num15 * (double)P0.z + num16 * (double)P1.z;
			double num29 = num17 * (double)P0.z;
			float x = (float)(((num18 * (double)f + num19) * (double)f + num20) * (double)f + num21);
			float y = (float)(((num22 * (double)f + num23) * (double)f + num24) * (double)f + num25);
			float z = (float)(((num26 * (double)f + num27) * (double)f + num28) * (double)f + num29);
			return new Vector3(x, y, z);
		}

		public Vector3 Interpolate(float tf)
		{
			return Interpolate(tf, Interpolation);
		}

		public Vector3 Interpolate(float tf, CurvyInterpolation interpolation)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.Interpolate(localF, interpolation);
		}

		public Vector3 InterpolateFast(float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.InterpolateFast(localF);
		}

		public T GetMetadata<T>(float tf) where T : Component, ICurvyMetadata
		{
			return (T)GetMetadata(typeof(T), tf);
		}

		public Component GetMetadata(Type type, float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? null : curvySplineSegment.GetMetaData(type);
		}

		public U InterpolateMetadata<T, U>(float tf) where T : Component, ICurvyInterpolatableMetadata<U>
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? default(U) : curvySplineSegment.InterpolateMetadata<T, U>(localF);
		}

		public object InterpolateMetadata(Type type, float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? null : curvySplineSegment.InterpolateMetadata(type, localF);
		}

		public Vector3 InterpolateScale(float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.InterpolateScale(localF);
		}

		public Vector3 GetOrientationUpFast(float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.GetOrientationUpFast(localF);
		}

		public Quaternion GetOrientationFast(float tf, bool inverse = false)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Quaternion.identity : curvySplineSegment.GetOrientationFast(localF, inverse);
		}

		public Vector3 GetTangent(float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.GetTangent(localF);
		}

		public Vector3 GetTangent(float tf, Vector3 localPosition)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.GetTangent(localF, localPosition);
		}

		public Vector3 GetTangentFast(float tf)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			return (!curvySplineSegment) ? Vector3.zero : curvySplineSegment.GetTangentFast(localF);
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3 GetExtrusionPoint(float tf, float radius, float angle)
		{
			Vector3 vector = Interpolate(tf);
			Vector3 tangent = GetTangent(tf, vector);
			Quaternion quaternion = Quaternion.AngleAxis(angle, tangent);
			return vector + quaternion * GetOrientationUpFast(tf) * radius;
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3 GetExtrusionPointFast(float tf, float radius, float angle)
		{
			Vector3 vector = InterpolateFast(tf);
			Vector3 tangentFast = GetTangentFast(tf);
			Quaternion quaternion = Quaternion.AngleAxis(angle, tangentFast);
			return vector + quaternion * GetOrientationUpFast(tf) * radius;
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3 GetRotatedUp(float tf, float angle)
		{
			Vector3 tangent = GetTangent(tf);
			Quaternion quaternion = Quaternion.AngleAxis(angle, tangent);
			return quaternion * GetOrientationUpFast(tf);
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3 GetRotatedUpFast(float tf, float angle)
		{
			Vector3 tangentFast = GetTangentFast(tf);
			Quaternion quaternion = Quaternion.AngleAxis(angle, tangentFast);
			return quaternion * GetOrientationUpFast(tf);
		}

		public Vector3 GetTangentByDistance(float distance)
		{
			return GetTangent(DistanceToTF(distance));
		}

		public Vector3 GetTangentByDistanceFast(float distance)
		{
			return GetTangentFast(DistanceToTF(distance));
		}

		public Vector3 InterpolateByDistance(float distance)
		{
			return Interpolate(DistanceToTF(distance));
		}

		public Vector3 InterpolateByDistanceFast(float distance)
		{
			return InterpolateFast(DistanceToTF(distance));
		}

		public float ExtrapolateDistanceToTF(float tf, float distance, float stepSize)
		{
			stepSize = Mathf.Max(0.0001f, stepSize);
			Vector3 vector = Interpolate(tf);
			float num = ((tf != 1f) ? Mathf.Min(1f, tf + stepSize) : Mathf.Min(1f, tf - stepSize));
			stepSize = Mathf.Abs(num - tf);
			Vector3 vector2 = Interpolate(num);
			float magnitude = (vector2 - vector).magnitude;
			if (magnitude != 0f)
			{
				return 1f / magnitude * stepSize * distance;
			}
			return 0f;
		}

		public float ExtrapolateDistanceToTFFast(float tf, float distance, float stepSize)
		{
			stepSize = Mathf.Max(0.0001f, stepSize);
			Vector3 vector = InterpolateFast(tf);
			float num = ((tf != 1f) ? Mathf.Min(1f, tf + stepSize) : Mathf.Min(1f, tf - stepSize));
			stepSize = Mathf.Abs(num - tf);
			Vector3 vector2 = InterpolateFast(num);
			float magnitude = (vector2 - vector).magnitude;
			if (magnitude != 0f)
			{
				return 1f / magnitude * stepSize * distance;
			}
			return 0f;
		}

		public float TFToDistance(float tf, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			float num = Length;
			if (num == 0f)
			{
				return 0f;
			}
			if (tf == 0f)
			{
				return 0f;
			}
			if (tf == 1f)
			{
				return num;
			}
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF, clamping);
			return (!curvySplineSegment) ? 0f : (curvySplineSegment.Distance + curvySplineSegment.LocalFToDistance(localF));
		}

		public CurvySplineSegment TFToSegment(float tf, out float localF, CurvyClamping clamping)
		{
			tf = CurvyUtility.ClampTF(tf, clamping);
			localF = 0f;
			int count = Count;
			if (count == 0)
			{
				return null;
			}
			float num = tf * (float)count;
			double num2 = Math.Round(num);
			int num3;
			if (num.Approximately((float)num2))
			{
				num3 = (int)num2;
				localF = 0f;
			}
			else
			{
				num3 = (int)num;
				localF = num - (float)num3;
			}
			if (num3 == count)
			{
				num3--;
				localF = 1f;
			}
			return this[num3];
		}

		public CurvySplineSegment TFToSegment(float tf, CurvyClamping clamping)
		{
			float localF;
			return TFToSegment(tf, out localF, clamping);
		}

		public CurvySplineSegment TFToSegment(float tf)
		{
			float localF;
			return TFToSegment(tf, out localF, CurvyClamping.Clamp);
		}

		public CurvySplineSegment TFToSegment(float tf, out float localF)
		{
			return TFToSegment(tf, out localF, CurvyClamping.Clamp);
		}

		public float SegmentToTF(CurvySplineSegment segment)
		{
			return SegmentToTF(segment, 0f);
		}

		public float SegmentToTF(CurvySplineSegment segment, float localF)
		{
			int segmentIndex = GetSegmentIndex(segment);
			if (segmentIndex != -1)
			{
				return (float)segmentIndex / (float)Count + 1f / (float)Count * localF;
			}
			if (!Closed && segment == LastVisibleControlPoint)
			{
				return 1f;
			}
			if (Count == 0)
			{
				return 0f;
			}
			short controlPointIndex = GetControlPointIndex(segment);
			if (!AutoEndTangents && controlPointIndex == 0)
			{
				return 0f;
			}
			if (!AutoEndTangents && controlPointIndex == ControlPointCount - 1)
			{
				return 1f;
			}
			DTLog.LogError("[Curvy] SegmentToTF reached an unexpected case. Please raise a bug report.");
			return -1f;
		}

		public float DistanceToTF(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			if (Length == 0f)
			{
				return 0f;
			}
			if (distance == 0f)
			{
				return 0f;
			}
			if (distance == Length)
			{
				return 1f;
			}
			float localDistance;
			CurvySplineSegment curvySplineSegment = DistanceToSegment(distance, out localDistance, clamping);
			return (!curvySplineSegment) ? 0f : SegmentToTF(curvySplineSegment, curvySplineSegment.DistanceToLocalF(localDistance));
		}

		public CurvySplineSegment DistanceToSegment(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			float localDistance;
			return DistanceToSegment(distance, out localDistance, clamping);
		}

		public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			distance = CurvyUtility.ClampDistance(distance, clamping, Length);
			CurvySplineSegment curvySplineSegment;
			if (Count > 0)
			{
				if (distance >= LastSegment.Distance)
				{
					curvySplineSegment = LastSegment;
					localDistance = ((!Mathf.Approximately(distance, Length)) ? (distance - curvySplineSegment.Distance) : curvySplineSegment.Length);
				}
				else
				{
					CurvySplineSegment curvySplineSegment2 = ((!(_lastDistToSeg != null) || !(distance >= _lastDistToSeg.Distance)) ? Segments[0] : _lastDistToSeg);
					int count = Count;
					CurvySplineSegment nextSegment = GetNextSegment(curvySplineSegment2);
					while ((bool)nextSegment && distance >= nextSegment.Distance && count-- > 0)
					{
						curvySplineSegment2 = nextSegment;
						nextSegment = GetNextSegment(curvySplineSegment2);
					}
					if (count <= 0)
					{
						DTLog.LogError("[Curvy] CurvySpline.DistanceToSegment() caused a deadloop! This shouldn't happen at all. Please raise a bug report.");
					}
					curvySplineSegment = curvySplineSegment2;
					localDistance = ((!distance.Approximately(curvySplineSegment.Distance)) ? (distance - curvySplineSegment.Distance) : 0f);
					if (!Dirty)
					{
						_lastDistToSeg = curvySplineSegment;
					}
				}
			}
			else
			{
				curvySplineSegment = null;
				localDistance = -1f;
			}
			return curvySplineSegment;
		}

		public Vector3 Move(ref float tf, ref int direction, float fDistance, CurvyClamping clamping)
		{
			tf = CurvyUtility.ClampTF(tf + fDistance * (float)direction, ref direction, clamping);
			return Interpolate(tf);
		}

		public Vector3 MoveFast(ref float tf, ref int direction, float fDistance, CurvyClamping clamping)
		{
			tf = CurvyUtility.ClampTF(tf + fDistance * (float)direction, ref direction, clamping);
			return InterpolateFast(tf);
		}

		public Vector3 MoveBy(ref float tf, ref int direction, float distance, CurvyClamping clamping, float stepSize = 0.002f)
		{
			return Move(ref tf, ref direction, ExtrapolateDistanceToTF(tf, distance, stepSize), clamping);
		}

		public Vector3 MoveByFast(ref float tf, ref int direction, float distance, CurvyClamping clamping, float stepSize = 0.002f)
		{
			return MoveFast(ref tf, ref direction, ExtrapolateDistanceToTFFast(tf, distance, stepSize), clamping);
		}

		public Vector3 MoveByLengthFast(ref float tf, ref int direction, float distance, CurvyClamping clamping)
		{
			float distance2 = ClampDistance(TFToDistance(tf) + distance * (float)direction, ref direction, clamping);
			tf = DistanceToTF(distance2);
			return InterpolateFast(tf);
		}

		public Vector3 MoveByAngle(ref float tf, ref int direction, float angle, CurvyClamping clamping, float stepSize = 0.002f)
		{
			if (clamping == CurvyClamping.PingPong)
			{
				DTLog.LogError("[Curvy] MoveByAngle does not support PingPong clamping");
				return Vector3.zero;
			}
			stepSize = Mathf.Max(0.0001f, stepSize);
			float num = tf;
			Vector3 vector = Interpolate(tf);
			Vector3 tangent = GetTangent(tf, vector);
			Vector3 vector2 = Vector3.zero;
			int num2 = 10000;
			while (num2-- > 0)
			{
				tf += stepSize * (float)direction;
				if (tf > 1f)
				{
					if (clamping != CurvyClamping.Loop)
					{
						tf = 1f;
						return Interpolate(1f);
					}
					tf -= 1f;
				}
				else if (tf < 0f)
				{
					if (clamping != CurvyClamping.Loop)
					{
						tf = 0f;
						return Interpolate(0f);
					}
					tf += 1f;
				}
				vector2 = Interpolate(tf);
				Vector3 to = vector2 - vector;
				float num3 = Vector3.Angle(tangent, to);
				if (num3 >= angle)
				{
					tf = num + (tf - num) * angle / num3;
					return Interpolate(tf);
				}
			}
			return vector2;
		}

		public Vector3 MoveByAngleFast(ref float tf, ref int direction, float angle, CurvyClamping clamping, float stepSize)
		{
			if (clamping == CurvyClamping.PingPong)
			{
				DTLog.LogError("[Curvy] MoveByAngleFast does not support PingPong clamping");
				return Vector3.zero;
			}
			stepSize = Mathf.Max(0.0001f, stepSize);
			float num = tf;
			Vector3 vector = InterpolateFast(tf);
			Vector3 tangentFast = GetTangentFast(tf);
			Vector3 vector2 = Vector3.zero;
			int num2 = 10000;
			while (num2-- > 0)
			{
				tf += stepSize * (float)direction;
				if (tf > 1f)
				{
					if (clamping != CurvyClamping.Loop)
					{
						tf = 1f;
						return InterpolateFast(1f);
					}
					tf -= 1f;
				}
				else if (tf < 0f)
				{
					if (clamping != CurvyClamping.Loop)
					{
						tf = 0f;
						return InterpolateFast(0f);
					}
					tf += 1f;
				}
				vector2 = InterpolateFast(tf);
				Vector3 to = vector2 - vector;
				float num3 = Vector3.Angle(tangentFast, to);
				if (num3 >= angle)
				{
					tf = num + (tf - num) * angle / num3;
					return InterpolateFast(tf);
				}
			}
			return vector2;
		}

		public float ClampDistance(float distance, CurvyClamping clamping)
		{
			return CurvyUtility.ClampDistance(distance, clamping, Length);
		}

		public float ClampDistance(float distance, CurvyClamping clamping, float min, float max)
		{
			return CurvyUtility.ClampDistance(distance, clamping, Length, min, max);
		}

		public float ClampDistance(float distance, ref int dir, CurvyClamping clamping)
		{
			return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length);
		}

		public float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float min, float max)
		{
			return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length, min, max);
		}

		public CurvySplineSegment Add()
		{
			return InsertAfter(null);
		}

		public CurvySplineSegment[] Add(params Vector3[] controlPoints)
		{
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			CurvySplineSegment[] array = new CurvySplineSegment[controlPoints.Length];
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			for (int i = 0; i < controlPoints.Length; i++)
			{
				array[i] = InsertAfter(null, localToWorldMatrix.MultiplyPoint3x4(controlPoints[i]), skipRefreshingAndEvents: true);
			}
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			return array;
		}

		public CurvySplineSegment InsertBefore(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			Vector3 globalPosition;
			if ((bool)controlPoint)
			{
				CurvySplineSegment previousControlPoint = GetPreviousControlPoint(controlPoint);
				globalPosition = ((!IsControlPointASegment(previousControlPoint)) ? ((!previousControlPoint) ? controlPoint.transform.position : Vector3.LerpUnclamped(previousControlPoint.transform.position, controlPoint.transform.position, 0.5f)) : base.transform.localToWorldMatrix.MultiplyPoint3x4(previousControlPoint.Interpolate(0.5f)));
			}
			else
			{
				globalPosition = base.transform.position;
			}
			return InsertBefore(controlPoint, globalPosition, skipRefreshingAndEvents);
		}

		public CurvySplineSegment InsertBefore(CurvySplineSegment controlPoint, Vector3 globalPosition, bool skipRefreshingAndEvents = false)
		{
			return InsertAt(controlPoint, globalPosition, controlPoint ? Mathf.Max(0, GetControlPointIndex(controlPoint)) : 0, CurvyControlPointEventArgs.ModeEnum.AddBefore, skipRefreshingAndEvents);
		}

		public CurvySplineSegment InsertAfter(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			Vector3 globalPosition;
			if ((bool)controlPoint)
			{
				if (IsControlPointASegment(controlPoint))
				{
					globalPosition = base.transform.localToWorldMatrix.MultiplyPoint3x4(controlPoint.Interpolate(0.5f));
				}
				else
				{
					CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
					globalPosition = ((!nextControlPoint) ? controlPoint.transform.position : Vector3.LerpUnclamped(nextControlPoint.transform.position, controlPoint.transform.position, 0.5f));
				}
			}
			else
			{
				globalPosition = base.transform.position;
			}
			return InsertAfter(controlPoint, globalPosition, skipRefreshingAndEvents);
		}

		public CurvySplineSegment InsertAfter(CurvySplineSegment controlPoint, Vector3 globalPosition, bool skipRefreshingAndEvents = false)
		{
			return InsertAt(controlPoint, globalPosition, (!controlPoint) ? ControlPoints.Count : (GetControlPointIndex(controlPoint) + 1), CurvyControlPointEventArgs.ModeEnum.AddAfter, skipRefreshingAndEvents);
		}

		public void Clear()
		{
			OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);
			for (int num = ControlPointCount - 1; num >= 0; num--)
			{
				if (UsePooling && Application.isPlaying)
				{
					CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
					if (instance == null)
					{
						DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
					}
					else
					{
						instance.ControlPointPool.Push(ControlPoints[num]);
					}
				}
				else
				{
					UnityEngine.Object.Destroy(controlPoints[num].gameObject);
				}
			}
			ClearControlPoints();
			Refresh();
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			if (!controlPoint)
			{
				return;
			}
			if (!skipRefreshingAndEvents)
			{
				OnBeforeControlPointDeleteEvent(new CurvyControlPointEventArgs(this, this, controlPoint, CurvyControlPointEventArgs.ModeEnum.Delete));
			}
			RemoveControlPoint(controlPoint);
			controlPoint.transform.SetAsLastSibling();
			if (UsePooling && Application.isPlaying)
			{
				CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
				if (instance == null)
				{
					DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
				}
				else
				{
					instance.ControlPointPool.Push(controlPoint);
				}
			}
			else
			{
				UnityEngine.Object.Destroy(controlPoint.gameObject);
			}
			if (!skipRefreshingAndEvents)
			{
				Refresh();
				OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			}
		}

		public Vector3[] GetApproximation(Space space = Space.Self)
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].Approximation.CopyTo(array, num);
				num += Mathf.Max(0, this[i].Approximation.Length - 1);
			}
			if (space == Space.World)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int j = 0; j < array.Length; j++)
				{
					ref Vector3 reference = ref array[j];
					reference = localToWorldMatrix.MultiplyPoint3x4(array[j]);
				}
			}
			return array;
		}

		public Vector3[] GetApproximationT()
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].ApproximationT.CopyTo(array, num);
				num += Mathf.Max(0, this[i].ApproximationT.Length - 1);
			}
			return array;
		}

		public Vector3[] GetApproximationUpVectors()
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].ApproximationUp.CopyTo(array, num);
				num += Mathf.Max(0, this[i].ApproximationUp.Length - 1);
			}
			return array;
		}

		public float GetNearestPointTF(Vector3 localPosition)
		{
			Vector3 nearest;
			return GetNearestPointTF(localPosition, out nearest, 0, -1);
		}

		public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearest)
		{
			return GetNearestPointTF(localPosition, out nearest, 0, -1);
		}

		public float GetNearestPointTF(Vector3 localPosition, int startSegmentIndex = 0, int stopSegmentIndex = -1)
		{
			Vector3 nearest;
			return GetNearestPointTF(localPosition, out nearest, startSegmentIndex, stopSegmentIndex);
		}

		public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearest, int startSegmentIndex = 0, int stopSegmentIndex = -1)
		{
			CurvySplineSegment nearestSegment;
			float nearestSegmentF;
			return GetNearestPointTF(localPosition, out nearest, out nearestSegment, out nearestSegmentF, startSegmentIndex, stopSegmentIndex);
		}

		public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearestPoint, [CanBeNull] out CurvySplineSegment nearestSegment, out float nearestSegmentF, int startSegmentIndex = 0, int stopSegmentIndex = -1)
		{
			nearestPoint = Vector3.zero;
			if (Count == 0)
			{
				nearestSegment = null;
				nearestSegmentF = -1f;
				return -1f;
			}
			float num = float.MaxValue;
			float num2 = 0f;
			CurvySplineSegment curvySplineSegment = null;
			if (stopSegmentIndex == -1)
			{
				stopSegmentIndex = Count - 1;
			}
			startSegmentIndex = Mathf.Clamp(startSegmentIndex, 0, Count - 1);
			stopSegmentIndex = Mathf.Clamp(stopSegmentIndex + 1, startSegmentIndex + 1, Count);
			for (int i = startSegmentIndex; i < stopSegmentIndex; i++)
			{
				float nearestPointF = this[i].GetNearestPointF(localPosition);
				Vector3 vector = this[i].Interpolate(nearestPointF);
				float sqrMagnitude = (vector - localPosition).sqrMagnitude;
				if (sqrMagnitude <= num)
				{
					curvySplineSegment = this[i];
					num2 = nearestPointF;
					nearestPoint = vector;
					num = sqrMagnitude;
				}
			}
			nearestSegment = curvySplineSegment;
			nearestSegmentF = num2;
			return curvySplineSegment.LocalFToTF(num2);
		}

		public void Refresh()
		{
			ProcessDirtyControlPoints();
			OnRefreshEvent(defaultSplineEventArgs);
		}

		public void SetDirtyAll()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
		}

		public void SetDirtyAll(SplineDirtyingType dirtyingType, bool dirtyConnectedControlPoints)
		{
			allControlPointsAreDirty = true;
			SetDirtyingFlags(dirtyingType);
			if (!dirtyConnectedControlPoints)
			{
				return;
			}
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				if (!curvySplineSegment || !curvySplineSegment.Connection)
				{
					continue;
				}
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = curvySplineSegment.Connection.ControlPointsList;
				for (int j = 0; j < controlPointsList.Count; j++)
				{
					CurvySplineSegment curvySplineSegment2 = controlPointsList[j];
					CurvySpline curvySpline = ((!(curvySplineSegment2 != null)) ? null : curvySplineSegment2.Spline);
					if ((bool)curvySpline && curvySpline != this)
					{
						curvySpline.dirtyControlPointsMinimalSet.Add(curvySplineSegment2);
						curvySpline.SetDirtyingFlags(dirtyingType);
					}
				}
			}
		}

		public void SetDirty(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
		{
			SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), ignoreConnectionOfInputControlPoint: false);
		}

		public void SetDirtyPartial(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
		{
			SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), ignoreConnectionOfInputControlPoint: true);
		}

		public Vector3 ToWorldPosition(Vector3 localPosition)
		{
			return base.transform.TransformPoint(localPosition);
		}

		public void SyncSplineFromHierarchy()
		{
			ClearControlPoints();
			for (int i = 0; i < base.transform.childCount; i++)
			{
				CurvySplineSegment component = base.transform.GetChild(i).GetComponent<CurvySplineSegment>();
				if ((bool)component)
				{
					AddControlPoint(component);
				}
			}
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3[] GetPolygonByAngle(float angle, float minDistance)
		{
			if (Mathf.Approximately(angle, 0f))
			{
				DTLog.LogError("[Curvy] GetPolygonByAngle: angle must be greater than 0");
				return new Vector3[0];
			}
			List<Vector3> list = new List<Vector3>();
			float tf = 0f;
			int direction = 1;
			float num = minDistance * minDistance;
			list.Add(Interpolate(0f));
			while (tf < 1f)
			{
				Vector3 vector = MoveByAngle(ref tf, ref direction, angle, CurvyClamping.Clamp);
				if ((vector - list[list.Count - 1]).sqrMagnitude >= num)
				{
					list.Add(vector);
				}
			}
			return list.ToArray();
		}

		[Obsolete("This method will be removed in an effort to simplify the API. If you use it, please copy it into your own code.")]
		public Vector3[] GetPolygon(float fromTF, float toTF, float maxAngle, float minDistance, float maxDistance, out List<float> vertexTF, out List<Vector3> vertexTangents, bool includeEndPoint = true, float stepSize = 0.01f)
		{
			stepSize = Mathf.Clamp(stepSize, 0.002f, 1f);
			maxDistance = ((maxDistance != -1f) ? Mathf.Clamp(maxDistance, 0f, Length) : Length);
			minDistance = Mathf.Clamp(minDistance, 0f, maxDistance);
			if (!Closed)
			{
				toTF = Mathf.Clamp01(toTF);
				fromTF = Mathf.Clamp(fromTF, 0f, toTF);
			}
			List<Vector3> vPos = new List<Vector3>();
			List<Vector3> vTan = new List<Vector3>();
			List<float> vTF = new List<float>();
			int linearSteps = 0;
			float angleFromLast = 0f;
			float distAccu = 0f;
			Vector3 curPos = Interpolate(fromTF);
			Vector3 curTangent = GetTangent(fromTF);
			Vector3 vector = curPos;
			Vector3 vector2 = curTangent;
			Action<float> action = delegate(float f)
			{
				vPos.Add(curPos);
				vTan.Add(curTangent);
				vTF.Add(f);
				angleFromLast = 0f;
				distAccu = 0f;
				linearSteps = 0;
			};
			action(fromTF);
			float num = fromTF + stepSize;
			while (num < toTF)
			{
				float num2 = num % 1f;
				curPos = Interpolate(num2);
				curTangent = GetTangent(num2);
				if (curTangent == Vector3.zero)
				{
					Debug.Log("zero Tangent! Oh no!");
				}
				distAccu += (curPos - vector).magnitude;
				if (curTangent == vector2)
				{
					linearSteps++;
				}
				if (distAccu >= minDistance)
				{
					if (distAccu >= maxDistance)
					{
						action(num2);
					}
					else
					{
						angleFromLast += Vector3.Angle(vector2, curTangent);
						if (angleFromLast >= maxAngle || (linearSteps > 0 && angleFromLast > 0f))
						{
							action(num2);
						}
					}
				}
				num += stepSize;
				vector = curPos;
				vector2 = curTangent;
			}
			if (includeEndPoint)
			{
				vTF.Add(toTF % 1f);
				curPos = Interpolate(toTF % 1f);
				vPos.Add(curPos);
				vTan.Add(GetTangent(toTF % 1f, curPos));
			}
			vertexTF = vTF;
			vertexTangents = vTan;
			return vPos.ToArray();
		}

		public Vector3[] GetApproximationPoints(float fromTF, float toTF, bool includeEndPoint = true)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(fromTF, out localF);
			float frag;
			int num = curvySplineSegment.getApproximationIndexINTERNAL(localF, out frag);
			float localF2;
			CurvySplineSegment curvySplineSegment2 = TFToSegment(toTF, out localF2);
			float frag2;
			int approximationIndexINTERNAL = curvySplineSegment2.getApproximationIndexINTERNAL(localF2, out frag2);
			CurvySplineSegment curvySplineSegment3 = curvySplineSegment;
			Vector3[] array = new Vector3[1] { Vector3.Lerp(curvySplineSegment3.Approximation[num], curvySplineSegment3.Approximation[num + 1], frag) };
			while ((bool)curvySplineSegment3 && curvySplineSegment3 != curvySplineSegment2)
			{
				array = array.AddRange(curvySplineSegment3.Approximation.SubArray(num + 1, curvySplineSegment3.Approximation.Length - 1));
				num = 1;
				curvySplineSegment3 = curvySplineSegment3.Spline.GetNextSegment(curvySplineSegment3);
			}
			if ((bool)curvySplineSegment3)
			{
				int num2 = ((!(curvySplineSegment == curvySplineSegment3)) ? 1 : (num + 1));
				array = array.AddRange(curvySplineSegment3.Approximation.SubArray(num2, approximationIndexINTERNAL - num2));
				if (includeEndPoint && (frag2 > 0f || frag2 < 1f))
				{
					return array.Add(Vector3.Lerp(curvySplineSegment3.Approximation[approximationIndexINTERNAL], curvySplineSegment3.Approximation[approximationIndexINTERNAL + 1], frag2));
				}
			}
			return array;
		}

		public bool IsPlanar(out int ignoreAxis)
		{
			bool xplanar;
			bool yplanar;
			bool zplanar;
			bool result = IsPlanar(out xplanar, out yplanar, out zplanar);
			if (xplanar)
			{
				ignoreAxis = 0;
			}
			else if (yplanar)
			{
				ignoreAxis = 1;
			}
			else
			{
				ignoreAxis = 2;
			}
			return result;
		}

		public bool IsPlanar(out bool xplanar, out bool yplanar, out bool zplanar)
		{
			xplanar = true;
			yplanar = true;
			zplanar = true;
			if (ControlPointCount == 0)
			{
				return true;
			}
			Vector3 localPosition = ControlPoints[0].transform.localPosition;
			for (int i = 1; i < ControlPointCount; i++)
			{
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.x, localPosition.x))
				{
					xplanar = false;
				}
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.y, localPosition.y))
				{
					yplanar = false;
				}
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.z, localPosition.z))
				{
					zplanar = false;
				}
				if (!xplanar && !yplanar && !zplanar)
				{
					return false;
				}
			}
			return true;
		}

		public bool IsPlanar(CurvyPlane plane)
		{
			switch (plane)
			{
			case CurvyPlane.XY:
			{
				for (int j = 0; j < ControlPointCount; j++)
				{
					if (ControlPoints[j].transform.localPosition.z != 0f)
					{
						return false;
					}
				}
				break;
			}
			case CurvyPlane.XZ:
			{
				for (int k = 0; k < ControlPointCount; k++)
				{
					if (ControlPoints[k].transform.localPosition.y != 0f)
					{
						return false;
					}
				}
				break;
			}
			case CurvyPlane.YZ:
			{
				for (int i = 0; i < ControlPointCount; i++)
				{
					if (ControlPoints[i].transform.localPosition.x != 0f)
					{
						return false;
					}
				}
				break;
			}
			}
			return true;
		}

		public void MakePlanar(CurvyPlane plane)
		{
			switch (plane)
			{
			case CurvyPlane.XY:
			{
				for (int j = 0; j < ControlPointCount; j++)
				{
					if (ControlPoints[j].transform.localPosition.z != 0f)
					{
						ControlPoints[j].SetLocalPosition(new Vector3(ControlPoints[j].transform.localPosition.x, ControlPoints[j].transform.localPosition.y, 0f));
					}
				}
				break;
			}
			case CurvyPlane.XZ:
			{
				for (int k = 0; k < ControlPointCount; k++)
				{
					if (ControlPoints[k].transform.localPosition.y != 0f)
					{
						ControlPoints[k].SetLocalPosition(new Vector3(ControlPoints[k].transform.localPosition.x, 0f, ControlPoints[k].transform.localPosition.z));
					}
				}
				break;
			}
			case CurvyPlane.YZ:
			{
				for (int i = 0; i < ControlPointCount; i++)
				{
					if (ControlPoints[i].transform.localPosition.x != 0f)
					{
						ControlPoints[i].SetLocalPosition(new Vector3(0f, ControlPoints[i].transform.localPosition.y, ControlPoints[i].transform.localPosition.z));
					}
				}
				break;
			}
			default:
				throw new NotImplementedException();
			}
		}

		public void Subdivide(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), num + 1, ControlPointCount - 1);
			if (num2 - num < 1)
			{
				Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
				return;
			}
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			for (int num3 = num2 - 1; num3 >= num; num3--)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[num3];
				CurvySplineSegment curvySplineSegment2 = ControlPoints[num3 + 1];
				CurvySplineSegment curvySplineSegment3 = InsertAfter(ControlPoints[num3], localToWorldMatrix.MultiplyPoint3x4(ControlPoints[num3].Interpolate(0.5f)), skipRefreshingAndEvents: true);
				if (Interpolation == CurvyInterpolation.Bezier)
				{
					Vector3 position = curvySplineSegment.transform.position;
					Vector3 handleOutPosition = curvySplineSegment.HandleOutPosition;
					Vector3 handleInPosition = curvySplineSegment2.HandleInPosition;
					Vector3 position2 = curvySplineSegment2.transform.position;
					Vector3 vector = (position + handleOutPosition) / 2f;
					Vector3 vector2 = (handleOutPosition + handleInPosition) / 2f;
					Vector3 vector3 = (handleInPosition + position2) / 2f;
					Vector3 handleInPosition2 = (vector + vector2) / 2f;
					Vector3 handleOutPosition2 = (vector2 + vector3) / 2f;
					curvySplineSegment.AutoHandles = false;
					curvySplineSegment.HandleOutPosition = vector;
					curvySplineSegment2.AutoHandles = false;
					curvySplineSegment2.HandleInPosition = vector3;
					curvySplineSegment3.AutoHandles = false;
					curvySplineSegment3.HandleInPosition = handleInPosition2;
					curvySplineSegment3.HandleOutPosition = handleOutPosition2;
				}
			}
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Simplify(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), num + 2, ControlPointCount - 1);
			if (num2 - num < 2)
			{
				Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
				return;
			}
			OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);
			for (int num3 = num2 - 2; num3 >= num; num3 -= 2)
			{
				Delete(ControlPoints[num3 + 1], skipRefreshingAndEvents: true);
			}
			Refresh();
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Equalize(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), num + 2, ControlPointCount - 1);
			if (num2 - num < 2)
			{
				Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
				return;
			}
			float num3 = ControlPoints[num2].Distance - ControlPoints[num].Distance;
			float num4 = num3 / (float)(num2 - num);
			float num5 = ControlPoints[num].Distance;
			for (int i = num + 1; i < num2; i++)
			{
				num5 += num4;
				ControlPoints[i].SetLocalPosition(InterpolateByDistance(num5));
			}
		}

		public void Normalize()
		{
			Vector3 localScale = base.transform.localScale;
			if (localScale != Vector3.one)
			{
				base.transform.localScale = Vector3.one;
				for (int i = 0; i < ControlPointCount; i++)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[i];
					curvySplineSegment.SetLocalPosition(Vector3.Scale(curvySplineSegment.transform.localPosition, localScale));
					curvySplineSegment.HandleIn = Vector3.Scale(curvySplineSegment.HandleIn, localScale);
					curvySplineSegment.HandleOut = Vector3.Scale(curvySplineSegment.HandleOut, localScale);
				}
			}
		}

		public void MakePlanar(int axis)
		{
			Vector3 localPosition = ControlPoints[0].transform.localPosition;
			for (int i = 1; i < ControlPointCount; i++)
			{
				Vector3 localPosition2 = ControlPoints[i].transform.localPosition;
				switch (axis)
				{
				case 0:
					localPosition2.x = localPosition.x;
					break;
				case 1:
					localPosition2.y = localPosition.y;
					break;
				case 2:
					localPosition2.z = localPosition.z;
					break;
				}
				ControlPoints[i].transform.localPosition = localPosition2;
			}
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
		}

		public Vector3 SetPivot(float xRel = 0f, float yRel = 0f, float zRel = 0f, bool preview = false)
		{
			Bounds bounds = Bounds;
			Vector3 vector = new Vector3(bounds.min.x + bounds.size.x * ((xRel + 1f) / 2f), bounds.max.y - bounds.size.y * ((yRel + 1f) / 2f), bounds.min.z + bounds.size.z * ((zRel + 1f) / 2f));
			Vector3 vector2 = base.transform.position - vector;
			if (preview)
			{
				return base.transform.position - vector2;
			}
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				curvySplineSegment.transform.position += vector2;
			}
			base.transform.position -= vector2;
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			return base.transform.position;
		}

		public void Flip()
		{
			if (ControlPointCount <= 1)
			{
				return;
			}
			switch (Interpolation)
			{
			case CurvyInterpolation.TCB:
			{
				Bias *= -1f;
				for (int num2 = ControlPointCount - 1; num2 >= 0; num2--)
				{
					CurvySplineSegment curvySplineSegment2 = ControlPoints[num2];
					int num3 = num2 - 1;
					if (num3 >= 0)
					{
						CurvySplineSegment curvySplineSegment3 = ControlPoints[num3];
						curvySplineSegment2.EndBias = curvySplineSegment3.StartBias * -1f;
						curvySplineSegment2.EndContinuity = curvySplineSegment3.StartContinuity;
						curvySplineSegment2.EndTension = curvySplineSegment3.StartTension;
						curvySplineSegment2.StartBias = curvySplineSegment3.EndBias * -1f;
						curvySplineSegment2.StartContinuity = curvySplineSegment3.EndContinuity;
						curvySplineSegment2.StartTension = curvySplineSegment3.EndTension;
						curvySplineSegment2.OverrideGlobalBias = curvySplineSegment3.OverrideGlobalBias;
						curvySplineSegment2.OverrideGlobalContinuity = curvySplineSegment3.OverrideGlobalContinuity;
						curvySplineSegment2.OverrideGlobalTension = curvySplineSegment3.OverrideGlobalTension;
						curvySplineSegment2.SynchronizeTCB = curvySplineSegment3.SynchronizeTCB;
					}
				}
				break;
			}
			case CurvyInterpolation.Bezier:
			{
				for (int num = ControlPointCount - 1; num >= 0; num--)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[num];
					Vector3 handleIn = curvySplineSegment.HandleIn;
					curvySplineSegment.HandleIn = curvySplineSegment.HandleOut;
					curvySplineSegment.HandleOut = handleIn;
				}
				break;
			}
			}
			ReverseControlPoints();
			Refresh();
		}

		public void MoveControlPoints(int startIndex, int count, CurvySplineSegment destCP)
		{
			if ((bool)destCP && !(this == destCP.Spline) && destCP.Spline.GetControlPointIndex(destCP) != -1)
			{
				startIndex = Mathf.Clamp(startIndex, 0, ControlPointCount - 1);
				count = Mathf.Clamp(count, startIndex, ControlPointCount - startIndex);
				for (int i = 0; i < count; i++)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[startIndex];
					RemoveControlPoint(curvySplineSegment);
					curvySplineSegment.transform.SetParent(destCP.Spline.transform, worldPositionStays: true);
					destCP.Spline.InsertControlPoint(destCP.Spline.GetControlPointIndex(destCP) + i + 1, curvySplineSegment);
				}
				Refresh();
				destCP.Spline.Refresh();
			}
		}

		public void JoinWith(CurvySplineSegment destCP)
		{
			if (!(destCP.Spline == this))
			{
				MoveControlPoints(0, ControlPointCount, destCP);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public CurvySpline Split(CurvySplineSegment controlPoint)
		{
			CurvySpline curvySpline = Create(this);
			curvySpline.transform.SetParent(base.transform.parent, worldPositionStays: true);
			curvySpline.name = base.name + "_parted";
			int segmentIndex = GetSegmentIndex(controlPoint);
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(ControlPointCount - segmentIndex);
			for (int i = segmentIndex; i < ControlPointCount; i++)
			{
				list.Add(ControlPoints[i]);
			}
			for (int j = 0; j < list.Count; j++)
			{
				CurvySplineSegment curvySplineSegment = list[j];
				RemoveControlPoint(curvySplineSegment);
				if (Application.isPlaying)
				{
					curvySplineSegment.transform.SetParent(curvySpline.transform, worldPositionStays: true);
				}
				curvySpline.AddControlPoint(curvySplineSegment);
			}
			Refresh();
			curvySpline.Refresh();
			return curvySpline;
		}

		public void SetFirstControlPoint(CurvySplineSegment controlPoint)
		{
			short controlPointIndex = GetControlPointIndex(controlPoint);
			CurvySplineSegment[] array = new CurvySplineSegment[controlPointIndex];
			for (int i = 0; i < controlPointIndex; i++)
			{
				array[i] = ControlPoints[i];
			}
			foreach (CurvySplineSegment item in array)
			{
				RemoveControlPoint(item);
				AddControlPoint(item);
			}
			Refresh();
		}

		public bool IsControlPointAnOrientationAnchor(CurvySplineSegment controlPoint)
		{
			return IsControlPointVisible(controlPoint) && (controlPoint.SerializedOrientationAnchor || controlPoint == FirstVisibleControlPoint || controlPoint == LastVisibleControlPoint);
		}

		public bool CanControlPointHaveFollowUp(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().CanHaveFollowUp;
		}

		public short GetControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().ControlPointIndex;
		}

		[Obsolete("Please use GetSegmentIndex instead. Sorry for the typo.")]
		public short GetSegementIndex(CurvySplineSegment segment)
		{
			return GetSegmentIndex(segment);
		}

		public short GetSegmentIndex(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return segment.GetExtrinsicPropertiesINTERNAL().SegmentIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetNextControlPoint(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			short nextControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
			return (nextControlPointIndex != -1) ? ControlPoints[nextControlPointIndex] : null;
		}

		[CanBeNull]
		public short GetNextControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetNextControlPointUsingFollowUp(CurvySplineSegment controlPoint)
		{
			return (!(controlPoint.FollowUp != null) || !(LastVisibleControlPoint == controlPoint)) ? GetNextControlPoint(controlPoint) : GetFollowUpNextControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading);
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousControlPoint(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			short previousControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
			return (previousControlPointIndex != -1) ? ControlPoints[previousControlPointIndex] : null;
		}

		[CanBeNull]
		public short GetPreviousControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousControlPointUsingFollowUp(CurvySplineSegment controlPoint)
		{
			return (!(controlPoint.FollowUp != null) || !(FirstVisibleControlPoint == controlPoint)) ? GetPreviousControlPoint(controlPoint) : GetFollowUpNextControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading);
		}

		[CanBeNull]
		public CurvySplineSegment GetNextSegment(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = segment.GetExtrinsicPropertiesINTERNAL();
			return (!extrinsicPropertiesINTERNAL.NextControlPointIsSegment) ? null : ControlPoints[extrinsicPropertiesINTERNAL.NextControlPointIndex];
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousSegment(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = segment.GetExtrinsicPropertiesINTERNAL();
			return (!extrinsicPropertiesINTERNAL.PreviousControlPointIsSegment) ? null : ControlPoints[extrinsicPropertiesINTERNAL.PreviousControlPointIndex];
		}

		public bool IsControlPointASegment(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().IsSegment;
		}

		public bool IsControlPointVisible(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().IsVisible;
		}

		public short GetControlPointOrientationAnchorIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().OrientationAnchorIndex;
		}

		public void SetFromString(string fieldAndValue)
		{
			string[] array = fieldAndValue.Split('=');
			if (array.Length != 2)
			{
				return;
			}
			FieldInfo fieldInfo = GetType().FieldByName(array[0], includeInherited: true);
			if (fieldInfo != null)
			{
				try
				{
					if (fieldInfo.FieldType.IsEnum)
					{
						fieldInfo.SetValue(this, Enum.Parse(fieldInfo.FieldType, array[1]));
					}
					else
					{
						fieldInfo.SetValue(this, Convert.ChangeType(array[1], fieldInfo.FieldType, CultureInfo.InvariantCulture));
					}
					return;
				}
				catch (Exception ex)
				{
					Debug.LogWarning(base.name + ".SetFromString(): " + ex.ToString());
					return;
				}
			}
			PropertyInfo propertyInfo = GetType().PropertyByName(array[0], includeInherited: true);
			if (propertyInfo == null)
			{
				return;
			}
			try
			{
				if (propertyInfo.PropertyType.IsEnum)
				{
					propertyInfo.SetValue(this, Enum.Parse(propertyInfo.PropertyType, array[1]), null);
				}
				else
				{
					propertyInfo.SetValue(this, Convert.ChangeType(array[1], propertyInfo.PropertyType, CultureInfo.InvariantCulture), null);
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning(base.name + ".SetFromString(): " + ex2.ToString());
			}
		}

		private void Awake()
		{
			if (UsePooling)
			{
				CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
			}
		}

		private void OnEnable()
		{
			SyncSplineFromHierarchy();
			if (isStarted)
			{
				Initialize();
			}
		}

		public void Start()
		{
			if (!isStarted)
			{
				Initialize();
				isStarted = true;
			}
			Refresh();
		}

		private void OnDisable()
		{
			mIsInitialized = false;
		}

		private void OnDestroy()
		{
			if (true)
			{
				if (UsePooling && Application.isPlaying)
				{
					CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
					if (instance != null)
					{
						for (int i = 0; i < ControlPointCount; i++)
						{
							instance.ControlPointPool.Push(ControlPoints[i]);
						}
					}
				}
				else
				{
					mThreadWorker.Dispose();
				}
			}
			ClearControlPoints();
			isStarted = false;
		}

		protected virtual void Reset()
		{
			Interpolation = CurvyGlobalManager.DefaultInterpolation;
			RestrictTo2D = false;
			AutoHandleDistance = 0.39f;
			Closed = false;
			AutoEndTangents = true;
			Orientation = CurvyOrientation.Dynamic;
			GizmoColor = CurvyGlobalManager.DefaultGizmoColor;
			GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;
			CacheDensity = 50;
			MaxPointsPerUnit = 8f;
			CheckTransform = true;
			Tension = 0f;
			Continuity = 0f;
			Bias = 0f;
			SyncSplineFromHierarchy();
		}

		private void Update()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.Update)
			{
				doUpdate();
			}
		}

		private void LateUpdate()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.LateUpdate)
			{
				doUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate)
			{
				doUpdate();
			}
		}

		private void Initialize()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
			ProcessDirtyControlPoints();
			UpdatedLastProcessedGlobalCoordinates();
			mIsInitialized = true;
		}

		private void doUpdate()
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			globalCoordinatesChangedThisFrame = false;
			if (base.transform.hasChanged)
			{
				base.transform.hasChanged = false;
				if (base.transform.position.NotApproximately(lastProcessedPosition) || base.transform.rotation.DifferentOrientation(lastProcessedRotation) || base.transform.lossyScale != lastProcessedScale)
				{
					globalCoordinatesChangedThisFrame = true;
					UpdatedLastProcessedGlobalCoordinates();
					mBounds = null;
					for (int i = 0; i < ControlPointCount; i++)
					{
						ControlPoints[i].ClearBoundsINTERNAL();
					}
				}
			}
			if ((CheckTransform || !Application.isPlaying) && !allControlPointsAreDirty)
			{
				for (int j = 0; j < ControlPointCount; j++)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[j];
					bool hasUnprocessedLocalPosition = curvySplineSegment.HasUnprocessedLocalPosition;
					if (hasUnprocessedLocalPosition || (curvySplineSegment.HasUnprocessedLocalOrientation && curvySplineSegment.OrientatinInfluencesSpline))
					{
						curvySplineSegment.Spline.SetDirty(curvySplineSegment, hasUnprocessedLocalPosition ? SplineDirtyingType.Everything : SplineDirtyingType.OrientationOnly);
					}
				}
			}
			if (Dirty)
			{
				Refresh();
			}
			else if (sendOnRefreshEventNextUpdate)
			{
				OnRefreshEvent(defaultSplineEventArgs);
			}
			sendOnRefreshEventNextUpdate = false;
			if (globalCoordinatesChangedThisFrame && OnGlobalCoordinatesChanged != null)
			{
				OnGlobalCoordinatesChanged(this);
			}
		}

		private bool canHaveManualEndCP()
		{
			return !Closed && (Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB);
		}

		private void SetDirty(CurvySplineSegment controlPoint, SplineDirtyingType dirtyingType, CurvySplineSegment previousControlPoint, CurvySplineSegment nextControlPoint, bool ignoreConnectionOfInputControlPoint)
		{
			if (!ignoreConnectionOfInputControlPoint && (bool)controlPoint.Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = controlPoint.Connection.ControlPointsList;
				for (int i = 0; i < controlPointsList.Count; i++)
				{
					CurvySplineSegment curvySplineSegment = controlPointsList[i];
					CurvySpline spline = curvySplineSegment.Spline;
					if ((bool)spline)
					{
						spline.dirtyControlPointsMinimalSet.Add(curvySplineSegment);
						spline.SetDirtyingFlags(dirtyingType);
					}
				}
			}
			else
			{
				dirtyControlPointsMinimalSet.Add(controlPoint);
				SetDirtyingFlags(dirtyingType);
			}
			if ((bool)previousControlPoint && (bool)previousControlPoint.Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList2 = previousControlPoint.Connection.ControlPointsList;
				for (int j = 0; j < controlPointsList2.Count; j++)
				{
					CurvySplineSegment curvySplineSegment2 = controlPointsList2[j];
					CurvySpline spline2 = curvySplineSegment2.Spline;
					if ((bool)spline2 && curvySplineSegment2.FollowUp == previousControlPoint)
					{
						spline2.dirtyControlPointsMinimalSet.Add(curvySplineSegment2);
						spline2.SetDirtyingFlags(dirtyingType);
					}
				}
			}
			if (!nextControlPoint || !nextControlPoint.Connection)
			{
				return;
			}
			ReadOnlyCollection<CurvySplineSegment> controlPointsList3 = nextControlPoint.Connection.ControlPointsList;
			for (int k = 0; k < controlPointsList3.Count; k++)
			{
				CurvySplineSegment curvySplineSegment3 = controlPointsList3[k];
				CurvySpline spline3 = curvySplineSegment3.Spline;
				if ((bool)spline3 && curvySplineSegment3.FollowUp == nextControlPoint)
				{
					spline3.dirtyControlPointsMinimalSet.Add(curvySplineSegment3);
					spline3.SetDirtyingFlags(dirtyingType);
				}
			}
		}

		private void SetDirtyingFlags(SplineDirtyingType dirtyingType)
		{
			mDirtyCurve = mDirtyCurve || dirtyingType == SplineDirtyingType.Everything;
			mDirtyOrientation = true;
			if (mDirtyCurve)
			{
				mCacheSize = -1;
				length = -1f;
				mBounds = null;
				_lastDistToSeg = null;
			}
		}

		private void ReverseControlPoints()
		{
			ControlPoints.Reverse();
			InvalidateControlPointsRelationshipCacheINTERNAL();
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
		}

		private static short GetNextControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
		{
			return (short)((controlPointIndex + 1 < controlPointsCount) ? (controlPointIndex + 1) : ((!isSplineClosed) ? (-1) : 0));
		}

		private static short GetPreviousControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
		{
			return (short)((controlPointIndex - 1 >= 0) ? (controlPointIndex - 1) : ((!isSplineClosed) ? (-1) : (controlPointsCount - 1)));
		}

		private static bool IsControlPointASegment(int controlPointIndex, int controlPointCount, bool isClosed, bool notAutoEndTangentsAndIsCatmullRomOrTCB)
		{
			return isClosed || ((!notAutoEndTangentsAndIsCatmullRomOrTCB) ? (controlPointIndex < controlPointCount - 1) : (controlPointIndex > 0 && controlPointIndex < controlPointCount - 2));
		}

		[NotNull]
		private static CurvySplineSegment GetFollowUpNextControlPoint(CurvySplineSegment followUp, ConnectionHeadingEnum headToDirection)
		{
			return headToDirection.ResolveAuto(followUp) switch
			{
				ConnectionHeadingEnum.Minus => followUp.Spline.GetPreviousControlPoint(followUp), 
				ConnectionHeadingEnum.Plus => followUp.Spline.GetNextControlPoint(followUp), 
				ConnectionHeadingEnum.Sharp => followUp, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private void AddControlPoint(CurvySplineSegment item)
		{
			ControlPoints.Add(item);
			item.LinkToSpline(this);
			InvalidateControlPointsRelationshipCacheINTERNAL();
			short previousControlPointIndex = GetPreviousControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
			short nextControlPointIndex = GetNextControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
			SetDirty(item, SplineDirtyingType.Everything, (previousControlPointIndex == -1) ? null : ControlPoints[previousControlPointIndex], (nextControlPointIndex == -1) ? null : ControlPoints[nextControlPointIndex], ignoreConnectionOfInputControlPoint: false);
		}

		private void InsertControlPoint(int index, CurvySplineSegment item)
		{
			ControlPoints.Insert(index, item);
			item.LinkToSpline(this);
			InvalidateControlPointsRelationshipCacheINTERNAL();
			short previousControlPointIndex = GetPreviousControlPointIndex((short)index, Closed, ControlPoints.Count);
			short nextControlPointIndex = GetNextControlPointIndex((short)index, Closed, ControlPoints.Count);
			SetDirty(item, SplineDirtyingType.Everything, (previousControlPointIndex != -1) ? ControlPoints[previousControlPointIndex] : null, (nextControlPointIndex != -1) ? ControlPoints[nextControlPointIndex] : null, ignoreConnectionOfInputControlPoint: false);
		}

		private void RemoveControlPoint(CurvySplineSegment item)
		{
			int controlPointIndex = GetControlPointIndex(item);
			if (ControlPoints.Count == 1)
			{
				SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			}
			else
			{
				short previousControlPointIndex = GetPreviousControlPointIndex((short)controlPointIndex, Closed, ControlPoints.Count);
				short nextControlPointIndex = GetNextControlPointIndex((short)controlPointIndex, Closed, ControlPoints.Count);
				if (previousControlPointIndex != -1)
				{
					SetDirty(ControlPoints[previousControlPointIndex], SplineDirtyingType.Everything);
				}
				if (nextControlPointIndex != -1)
				{
					SetDirty(ControlPoints[nextControlPointIndex], SplineDirtyingType.Everything);
				}
			}
			ControlPoints.RemoveAt(controlPointIndex);
			dirtyControlPointsMinimalSet.Remove(item);
			if (item.Spline == this)
			{
				item.UnlinkFromSpline();
			}
			InvalidateControlPointsRelationshipCacheINTERNAL();
		}

		private void ClearControlPoints()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				if ((bool)curvySplineSegment && curvySplineSegment.Spline == this)
				{
					curvySplineSegment.UnlinkFromSpline();
				}
			}
			ControlPoints.Clear();
			dirtyControlPointsMinimalSet.Clear();
			InvalidateControlPointsRelationshipCacheINTERNAL();
		}

		internal void InvalidateControlPointsRelationshipCacheINTERNAL()
		{
			if (isCpsRelationshipCacheValid)
			{
				lock (controlPointsRelationshipCacheLock)
				{
					isCpsRelationshipCacheValid = false;
					firstSegment = (lastSegment = (firstVisibleControlPoint = (lastVisibleControlPoint = null)));
				}
			}
		}

		private void RebuildControlPointsRelationshipCache(bool fixNonCoherentControlPoints)
		{
			lock (controlPointsRelationshipCacheLock)
			{
				if (isCpsRelationshipCacheValid)
				{
					return;
				}
				int count = ControlPoints.Count;
				mSegments.Clear();
				mSegments.Capacity = count;
				if (count > 0)
				{
					CurvySplineSegment curvySplineSegment = null;
					bool flag = false;
					CurvySplineSegment curvySplineSegment2 = null;
					CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = new CurvySplineSegment.ControlPointExtrinsicProperties(isVisible: false, -1, -1, -1, -1, previousControlPointIsSegment: false, nextControlPointIsSegment: false, canHaveFollowUp: false, -1);
					bool closed = Closed;
					bool flag2 = Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB;
					bool notAutoEndTangentsAndIsCatmullRomOrTCB = !AutoEndTangents && flag2;
					short num = 0;
					short num2 = -1;
					for (short num3 = 0; num3 < count; num3++)
					{
						CurvySplineSegment curvySplineSegment3 = ControlPoints[num3];
						short previousControlPointIndex = GetPreviousControlPointIndex(num3, closed, count);
						short nextControlPointIndex = GetNextControlPointIndex(num3, closed, count);
						bool flag3 = IsControlPointASegment(num3, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB);
						bool flag4 = flag3 || extrinsicPropertiesINTERNAL.IsSegment;
						if (flag4 && (num2 == -1 || curvySplineSegment3.SerializedOrientationAnchor || !flag3))
						{
							num2 = num3;
						}
						bool flag5 = flag4 && (nextControlPointIndex == -1 || previousControlPointIndex == -1);
						extrinsicPropertiesINTERNAL = new CurvySplineSegment.ControlPointExtrinsicProperties(flag4, (short)((!flag3) ? (-1) : num), num3, previousControlPointIndex, nextControlPointIndex, previousControlPointIndex != -1 && IsControlPointASegment(previousControlPointIndex, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB), nextControlPointIndex != -1 && IsControlPointASegment(nextControlPointIndex, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB), flag5, (short)((!flag4) ? (-1) : num2));
						curvySplineSegment3.SetExtrinsicPropertiesINTERNAL(extrinsicPropertiesINTERNAL);
						if (flag3)
						{
							mSegments.Add(curvySplineSegment3);
							num++;
							if (!flag)
							{
								flag = true;
								curvySplineSegment = curvySplineSegment3;
							}
							curvySplineSegment2 = curvySplineSegment3;
						}
						if (fixNonCoherentControlPoints && !flag5)
						{
							curvySplineSegment3.UnsetFollowUpWithoutDirtyingINTERNAL();
						}
					}
					firstSegment = curvySplineSegment;
					lastSegment = curvySplineSegment2;
					firstVisibleControlPoint = firstSegment;
					lastVisibleControlPoint = ((!(lastSegment != null)) ? null : ControlPoints[lastSegment.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex]);
				}
				else
				{
					firstSegment = (lastSegment = (firstVisibleControlPoint = (lastVisibleControlPoint = null)));
				}
				isCpsRelationshipCacheValid = true;
			}
		}

		private void ProcessDirtyControlPoints()
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			FillDirtyCpsExtendedList();
			dirtyControlPointsMinimalSet.Clear();
			allControlPointsAreDirty = false;
			if (dirtyCpsExtendedList.Count > 0)
			{
				if (!mDirtyOrientation && !mDirtyCurve)
				{
					Debug.LogError("Invalid dirtying flags");
				}
				PrepareTTransforms();
				int controlPointCount = ControlPointCount;
				if (mDirtyCurve)
				{
					if (Interpolation == CurvyInterpolation.Bezier)
					{
						for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
						{
							CurvySplineSegment curvySplineSegment = dirtyCpsExtendedList[i];
							if (curvySplineSegment.AutoHandles)
							{
								curvySplineSegment.SetBezierHandles(-1f, setIn: true, setOut: true, noDirtying: true);
							}
						}
					}
					if (UseThreading)
					{
						mThreadWorker.ParralelFor(refreshCurveAction, dirtyCpsExtendedList);
					}
					else
					{
						CurvyInterpolation interpolation = Interpolation;
						for (int j = 0; j < dirtyCpsExtendedList.Count; j++)
						{
							CurvySplineSegment curvySplineSegment2 = dirtyCpsExtendedList[j];
							curvySplineSegment2.refreshCurveINTERNAL(interpolation, IsControlPointASegment(curvySplineSegment2), this);
						}
					}
					if (controlPointCount > 0)
					{
						ControlPoints[0].Distance = 0f;
						for (int k = 1; k < controlPointCount; k++)
						{
							ControlPoints[k].Distance = ControlPoints[k - 1].Distance + ControlPoints[k - 1].Length;
						}
						List<CurvySplineSegment> segments = Segments;
						for (int l = 0; l < segments.Count; l++)
						{
							CurvySplineSegment curvySplineSegment3 = segments[l];
							CurvySplineSegment nextSegment = GetNextSegment(curvySplineSegment3);
							if ((bool)nextSegment)
							{
								ref Vector3 reference = ref curvySplineSegment3.ApproximationT[curvySplineSegment3.CacheSize];
								reference = nextSegment.ApproximationT[0];
							}
							else
							{
								ref Vector3 reference2 = ref GetNextControlPoint(curvySplineSegment3).ApproximationT[0];
								reference2 = curvySplineSegment3.ApproximationT[curvySplineSegment3.CacheSize];
							}
						}
					}
				}
				if (mDirtyOrientation && Count > 0)
				{
					switch (Orientation)
					{
					case CurvyOrientation.None:
					{
						for (int n = 0; n < dirtyCpsExtendedList.Count; n++)
						{
							dirtyCpsExtendedList[n].refreshOrientationNoneINTERNAL();
						}
						break;
					}
					case CurvyOrientation.Static:
						if (UseThreading)
						{
							Action<CurvySplineSegment> action = delegate(CurvySplineSegment controlPoint)
							{
								controlPoint.refreshOrientationStaticINTERNAL();
							};
							mThreadWorker.ParralelFor(action, dirtyCpsExtendedList);
						}
						else
						{
							for (int num13 = 0; num13 < dirtyCpsExtendedList.Count; num13++)
							{
								dirtyCpsExtendedList[num13].refreshOrientationStaticINTERNAL();
							}
						}
						break;
					case CurvyOrientation.Dynamic:
					{
						int num = controlPointCount + 1;
						do
						{
							CurvySplineSegment curvySplineSegment4 = dirtyCpsExtendedList[0];
							if (!IsControlPointASegment(curvySplineSegment4))
							{
								curvySplineSegment4.refreshOrientationDynamicINTERNAL(curvySplineSegment4.getOrthoUp0INTERNAL());
								dirtyCpsExtendedList.RemoveAt(0);
								continue;
							}
							short controlPointOrientationAnchorIndex = GetControlPointOrientationAnchorIndex(curvySplineSegment4);
							CurvySplineSegment curvySplineSegment5 = ControlPoints[controlPointOrientationAnchorIndex];
							int num2 = 0;
							short num3 = controlPointOrientationAnchorIndex;
							CurvySplineSegment curvySplineSegment6 = curvySplineSegment5;
							int num4 = 0;
							float num5 = 0f;
							Vector3 vector = curvySplineSegment5.getOrthoUp0INTERNAL();
							do
							{
								num2 += curvySplineSegment6.CacheSize;
								num4++;
								num5 += curvySplineSegment6.Length;
								curvySplineSegment6.refreshOrientationDynamicINTERNAL(vector);
								vector = curvySplineSegment6.ApproximationUp[curvySplineSegment6.ApproximationUp.Length - 1];
								num3 = GetNextControlPointIndex(num3, m_Closed, controlPointCount);
								curvySplineSegment6 = ControlPoints[num3];
							}
							while (!IsControlPointAnOrientationAnchor(curvySplineSegment6));
							short num6 = num3;
							float num7 = vector.AngleSigned(curvySplineSegment6.getOrthoUp0INTERNAL(), curvySplineSegment6.ApproximationT[0]) / (float)num2;
							float num8;
							switch (curvySplineSegment5.Swirl)
							{
							case CurvyOrientationSwirl.Segment:
								num8 = curvySplineSegment5.SwirlTurns * 360f;
								break;
							case CurvyOrientationSwirl.AnchorGroup:
								num8 = curvySplineSegment5.SwirlTurns * 360f / (float)num4;
								break;
							case CurvyOrientationSwirl.AnchorGroupAbs:
								num8 = curvySplineSegment5.SwirlTurns * 360f / num5;
								break;
							case CurvyOrientationSwirl.None:
								num8 = 0f;
								break;
							default:
								num8 = 0f;
								DTLog.LogError("[Curvy] Invalid Swirl value " + curvySplineSegment5.Swirl);
								break;
							}
							float num9 = num7;
							short num10 = controlPointOrientationAnchorIndex;
							bool flag = curvySplineSegment5.Swirl == CurvyOrientationSwirl.AnchorGroupAbs;
							Vector3 vector2 = curvySplineSegment5.ApproximationUp[0];
							do
							{
								CurvySplineSegment curvySplineSegment7 = ControlPoints[num10];
								float num11 = ((!flag) ? (num7 + num8 / (float)curvySplineSegment7.CacheSize) : (num7 + num8 * curvySplineSegment7.Length / (float)curvySplineSegment7.CacheSize));
								Vector3[] approximationT = curvySplineSegment7.ApproximationT;
								Vector3[] approximationUp = curvySplineSegment7.ApproximationUp;
								int num12 = approximationUp.Length;
								approximationUp[0] = vector2;
								for (int m = 1; m < num12; m++)
								{
									ref Vector3 reference3 = ref approximationUp[m];
									reference3 = Quaternion.AngleAxis(num9, approximationT[m]) * approximationUp[m];
									num9 += num11;
								}
								vector2 = approximationUp[num12 - 1];
								dirtyCpsExtendedList.Remove(curvySplineSegment7);
								num10 = GetNextControlPointIndex(num10, m_Closed, controlPointCount);
							}
							while (num10 != num6);
						}
						while (dirtyCpsExtendedList.Count > 0 && num-- > 0);
						if (num <= 0)
						{
							DTLog.LogWarning("[Curvy] Deadloop in CurvySpline.Refresh! Please raise a bugreport!");
						}
						break;
					}
					default:
						DTLog.LogError("[Curvy] Invalid Orientation value " + Orientation);
						break;
					}
					if (!Closed)
					{
						CurvySplineSegment previousControlPoint = GetPreviousControlPoint(LastVisibleControlPoint);
						ref Vector3 reference4 = ref LastVisibleControlPoint.ApproximationUp[0];
						reference4 = previousControlPoint.ApproximationUp[previousControlPoint.CacheSize];
					}
				}
			}
			mDirtyCurve = false;
			mDirtyOrientation = false;
		}

		private void PrepareTTransforms()
		{
			int controlPointCount = ControlPointCount;
			for (int i = 0; i < controlPointCount; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				curvySplineSegment.PrepareThreadSafeTransfromINTERNAL();
			}
			if (Count > 0)
			{
				CurvySplineSegment previousControlPointUsingFollowUp = GetPreviousControlPointUsingFollowUp(FirstVisibleControlPoint);
				if ((bool)previousControlPointUsingFollowUp && previousControlPointUsingFollowUp.Spline != this)
				{
					previousControlPointUsingFollowUp.PrepareThreadSafeTransfromINTERNAL();
				}
				CurvySplineSegment nextControlPointUsingFollowUp = GetNextControlPointUsingFollowUp(LastVisibleControlPoint);
				if ((bool)nextControlPointUsingFollowUp && nextControlPointUsingFollowUp.Spline != this)
				{
					nextControlPointUsingFollowUp.PrepareThreadSafeTransfromINTERNAL();
				}
			}
		}

		private void FillDirtyCpsExtendedList()
		{
			int count = ControlPoints.Count;
			dirtyCpsExtendedList.Clear();
			if (allControlPointsAreDirty)
			{
				for (int i = 0; i < count; i++)
				{
					dirtyCpsExtendedList.Add(ControlPoints[i]);
				}
				return;
			}
			int count2 = dirtyControlPointsMinimalSet.Count;
			for (int j = 0; j < count2; j++)
			{
				CurvySplineSegment controlPoint = dirtyControlPointsMinimalSet.ElementAt(j);
				CurvySplineSegment previousControlPoint = GetPreviousControlPoint(controlPoint);
				if ((bool)previousControlPoint)
				{
					dirtyControlPointsMinimalSet.Add(previousControlPoint);
				}
				if (Interpolation == CurvyInterpolation.Linear)
				{
					continue;
				}
				if ((bool)previousControlPoint)
				{
					CurvySplineSegment previousControlPoint2 = GetPreviousControlPoint(previousControlPoint);
					if ((bool)previousControlPoint2)
					{
						dirtyControlPointsMinimalSet.Add(previousControlPoint2);
					}
				}
				CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
				if ((bool)nextControlPoint)
				{
					dirtyControlPointsMinimalSet.Add(nextControlPoint);
				}
			}
			dirtyCpsExtendedList.AddRange(dirtyControlPointsMinimalSet);
		}

		internal void NotifyMetaDataModification()
		{
			sendOnRefreshEventNextUpdate = true;
		}

		private void SyncHierarchyFromSpline(bool renameControlPoints = true)
		{
		}

		private void UpdatedLastProcessedGlobalCoordinates()
		{
			lastProcessedPosition = base.transform.position;
			lastProcessedRotation = base.transform.rotation;
			lastProcessedScale = base.transform.lossyScale;
		}

		private CurvySplineSegment InsertAt(CurvySplineSegment controlPoint, Vector3 globalPosition, int insertionIndex, CurvyControlPointEventArgs.ModeEnum insertionMode, bool skipRefreshingAndEvents)
		{
			if (!skipRefreshingAndEvents)
			{
				OnBeforeControlPointAddEvent(new CurvyControlPointEventArgs(this, this, controlPoint, insertionMode));
			}
			CurvySplineSegment curvySplineSegment;
			GameObject gameObject;
			if (UsePooling && Application.isPlaying)
			{
				CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
				if (instance != null)
				{
					curvySplineSegment = instance.ControlPointPool.Pop<CurvySplineSegment>(base.transform);
					gameObject = curvySplineSegment.gameObject;
				}
				else
				{
					DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
					gameObject = new GameObject("NewCP", typeof(CurvySplineSegment));
					curvySplineSegment = gameObject.GetComponent<CurvySplineSegment>();
				}
			}
			else
			{
				gameObject = new GameObject("NewCP", typeof(CurvySplineSegment));
				curvySplineSegment = gameObject.GetComponent<CurvySplineSegment>();
			}
			gameObject.layer = base.gameObject.layer;
			gameObject.transform.SetParent(base.transform);
			InsertControlPoint(insertionIndex, curvySplineSegment);
			curvySplineSegment.AutoHandleDistance = AutoHandleDistance;
			curvySplineSegment.transform.position = globalPosition;
			curvySplineSegment.transform.rotation = Quaternion.identity;
			curvySplineSegment.transform.localScale = Vector3.one;
			if (!skipRefreshingAndEvents)
			{
				Refresh();
				OnAfterControlPointAddEvent(new CurvyControlPointEventArgs(this, this, curvySplineSegment, insertionMode));
				OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			}
			return curvySplineSegment;
		}

		private CurvySplineEventArgs OnRefreshEvent(CurvySplineEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnBeforeControlPointAddEvent(CurvyControlPointEventArgs e)
		{
			if (OnBeforeControlPointAdd != null)
			{
				OnBeforeControlPointAdd.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnAfterControlPointAddEvent(CurvyControlPointEventArgs e)
		{
			if (OnAfterControlPointAdd != null)
			{
				OnAfterControlPointAdd.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnBeforeControlPointDeleteEvent(CurvyControlPointEventArgs e)
		{
			if (OnBeforeControlPointDelete != null)
			{
				OnBeforeControlPointDelete.Invoke(e);
			}
			return e;
		}

		private CurvySplineEventArgs OnAfterControlPointChangesEvent(CurvySplineEventArgs e)
		{
			if (OnAfterControlPointChanges != null)
			{
				OnAfterControlPointChanges.Invoke(e);
			}
			return e;
		}
	}
	public enum SplineDirtyingType
	{
		OrientationOnly,
		Everything
	}
	public static class CurvySplineDefaultValues
	{
		public const bool AutoEndTangents = true;

		public const CurvyOrientation Orientation = CurvyOrientation.Dynamic;

		public const float AutoHandleDistance = 0.39f;

		public const int CacheDensity = 50;

		public const float MaxPointsPerUnit = 8f;

		public const bool UsePooling = true;

		public const CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update;

		public const bool CheckTransform = true;
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvysplinesegment")]
	public class CurvySplineSegment : MonoBehaviour, IPoolable
	{
		internal struct ControlPointExtrinsicProperties : IEquatable<ControlPointExtrinsicProperties>
		{
			private readonly bool isVisible;

			private readonly short segmentIndex;

			private readonly short controlPointIndex;

			private readonly short nextControlPointIndex;

			private readonly short previousControlPointIndex;

			private readonly bool previousControlPointIsSegment;

			private readonly bool nextControlPointIsSegment;

			private readonly bool canHaveFollowUp;

			private readonly short orientationAnchorIndex;

			internal bool IsVisible => isVisible;

			internal short SegmentIndex => segmentIndex;

			internal short ControlPointIndex => controlPointIndex;

			internal short NextControlPointIndex => nextControlPointIndex;

			internal short PreviousControlPointIndex => previousControlPointIndex;

			internal bool PreviousControlPointIsSegment => previousControlPointIsSegment;

			internal bool NextControlPointIsSegment => nextControlPointIsSegment;

			internal bool CanHaveFollowUp => canHaveFollowUp;

			internal bool IsSegment => SegmentIndex != -1;

			internal short OrientationAnchorIndex => orientationAnchorIndex;

			internal ControlPointExtrinsicProperties(bool isVisible, short segmentIndex, short controlPointIndex, short previousControlPointIndex, short nextControlPointIndex, bool previousControlPointIsSegment, bool nextControlPointIsSegment, bool canHaveFollowUp, short orientationAnchorIndex)
			{
				this.isVisible = isVisible;
				this.segmentIndex = segmentIndex;
				this.controlPointIndex = controlPointIndex;
				this.nextControlPointIndex = nextControlPointIndex;
				this.previousControlPointIndex = previousControlPointIndex;
				this.previousControlPointIsSegment = previousControlPointIsSegment;
				this.nextControlPointIsSegment = nextControlPointIsSegment;
				this.canHaveFollowUp = canHaveFollowUp;
				this.orientationAnchorIndex = orientationAnchorIndex;
			}

			public bool Equals(ControlPointExtrinsicProperties other)
			{
				return IsVisible == other.IsVisible && SegmentIndex == other.SegmentIndex && ControlPointIndex == other.ControlPointIndex && NextControlPointIndex == other.NextControlPointIndex && PreviousControlPointIndex == other.PreviousControlPointIndex && PreviousControlPointIsSegment == other.PreviousControlPointIsSegment && NextControlPointIsSegment == other.NextControlPointIsSegment && CanHaveFollowUp == other.CanHaveFollowUp && OrientationAnchorIndex == other.OrientationAnchorIndex;
			}

			public override bool Equals(object obj)
			{
				if (object.ReferenceEquals(null, obj))
				{
					return false;
				}
				return obj is ControlPointExtrinsicProperties && Equals((ControlPointExtrinsicProperties)obj);
			}

			public override int GetHashCode()
			{
				int hashCode = IsVisible.GetHashCode();
				hashCode = (hashCode * 397) ^ SegmentIndex.GetHashCode();
				hashCode = (hashCode * 397) ^ ControlPointIndex.GetHashCode();
				hashCode = (hashCode * 397) ^ NextControlPointIndex.GetHashCode();
				hashCode = (hashCode * 397) ^ PreviousControlPointIndex.GetHashCode();
				hashCode = (hashCode * 397) ^ PreviousControlPointIsSegment.GetHashCode();
				hashCode = (hashCode * 397) ^ NextControlPointIsSegment.GetHashCode();
				hashCode = (hashCode * 397) ^ CanHaveFollowUp.GetHashCode();
				return (hashCode * 397) ^ OrientationAnchorIndex.GetHashCode();
			}

			public static bool operator ==(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
			{
				return !left.Equals(right);
			}
		}

		public static readonly Color GizmoTangentColor = new Color(0f, 0.7f, 0f);

		[NonSerialized]
		public Vector3[] Approximation = new Vector3[0];

		[NonSerialized]
		public float[] ApproximationDistances = new float[0];

		[NonSerialized]
		public Vector3[] ApproximationUp = new Vector3[0];

		[NonSerialized]
		public Vector3[] ApproximationT = new Vector3[0];

		[Group("General")]
		[FieldAction("CBBakeOrientation", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[Label("Bake Orientation", "Automatically apply orientation to CP transforms?")]
		[SerializeField]
		private bool m_AutoBakeOrientation;

		[Group("General")]
		[Tooltip("Check to use this transform's rotation")]
		[FieldCondition("IsOrientationAnchorEditable", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_OrientationAnchor;

		[Label("Swirl", "Add Swirl to orientation?")]
		[Group("General")]
		[FieldCondition("canHaveSwirl", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private CurvyOrientationSwirl m_Swirl;

		[Label("Turns", "Number of swirl turns")]
		[Group("General")]
		[FieldCondition("canHaveSwirl", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_Swirl", CurvyOrientationSwirl.None, true)]
		[SerializeField]
		private float m_SwirlTurns;

		[Section("Bezier Options", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/curvysplinesegment_bezier")]
		[GroupCondition("interpolation", CurvyInterpolation.Bezier, false)]
		[SerializeField]
		private bool m_AutoHandles = true;

		[RangeEx(0f, 1f, "Distance %", "Handle length by distance to neighbours")]
		[FieldCondition("m_AutoHandles", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		private float m_AutoHandleDistance = 0.39f;

		[VectorEx("", "", Precision = 3, Options = (AttributeOptionsFlags)1152, Color = "#FFFF00")]
		[SerializeField]
		[FormerlySerializedAs("HandleIn")]
		private Vector3 m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;

		[VectorEx("", "", Precision = 3, Options = (AttributeOptionsFlags)1152, Color = "#00FF00")]
		[SerializeField]
		[FormerlySerializedAs("HandleOut")]
		private Vector3 m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;

		[Section("TCB Options", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/curvysplinesegment_tcb")]
		[GroupCondition("interpolation", CurvyInterpolation.TCB, false)]
		[GroupAction("TCBOptionsGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[Label("Local Tension", "Override Spline Tension?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalTension")]
		private bool m_OverrideGlobalTension;

		[Label("Local Continuity", "Override Spline Continuity?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalContinuity")]
		private bool m_OverrideGlobalContinuity;

		[Label("Local Bias", "Override Spline Bias?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalBias")]
		private bool m_OverrideGlobalBias;

		[Tooltip("Synchronize Start and End Values")]
		[SerializeField]
		[FormerlySerializedAs("SynchronizeTCB")]
		private bool m_SynchronizeTCB = true;

		[Label("Tension", "")]
		[FieldCondition("m_OverrideGlobalTension", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartTension")]
		private float m_StartTension;

		[Label("Tension (End)", "")]
		[FieldCondition("m_OverrideGlobalTension", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndTension")]
		private float m_EndTension;

		[Label("Continuity", "")]
		[FieldCondition("m_OverrideGlobalContinuity", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartContinuity")]
		private float m_StartContinuity;

		[Label("Continuity (End)", "")]
		[FieldCondition("m_OverrideGlobalContinuity", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndContinuity")]
		private float m_EndContinuity;

		[Label("Bias", "")]
		[FieldCondition("m_OverrideGlobalBias", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartBias")]
		private float m_StartBias;

		[Label("Bias (End)", "")]
		[FieldCondition("m_OverrideGlobalBias", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndBias")]
		private float m_EndBias;

		[SerializeField]
		[HideInInspector]
		private CurvySplineSegment m_FollowUp;

		[SerializeField]
		[HideInInspector]
		private ConnectionHeadingEnum m_FollowUpHeading = ConnectionHeadingEnum.Auto;

		[SerializeField]
		[HideInInspector]
		private bool m_ConnectionSyncPosition;

		[SerializeField]
		[HideInInspector]
		private bool m_ConnectionSyncRotation;

		[SerializeField]
		[HideInInspector]
		private CurvyConnection m_Connection;

		private int cacheSize = -1;

		private Vector3 threadSafeLocalPosition;

		private Quaternion threadSafeLocalRotation;

		private CurvySpline mSpline;

		private float mStepSize;

		private Bounds? mBounds;

		private int mCacheLastDistanceToLocalFIndex;

		private List<Component> mMetaData;

		private Vector3 lastProcessedLocalPosition;

		private Quaternion lastProcessedLocalRotation;

		private ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL;

		public bool AutoBakeOrientation
		{
			get
			{
				return m_AutoBakeOrientation;
			}
			set
			{
				if (m_AutoBakeOrientation != value)
				{
					m_AutoBakeOrientation = value;
				}
			}
		}

		public bool SerializedOrientationAnchor
		{
			get
			{
				return m_OrientationAnchor;
			}
			set
			{
				if (m_OrientationAnchor != value)
				{
					m_OrientationAnchor = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
					Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
				}
			}
		}

		public CurvyOrientationSwirl Swirl
		{
			get
			{
				return m_Swirl;
			}
			set
			{
				if (m_Swirl != value)
				{
					m_Swirl = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
				}
			}
		}

		public float SwirlTurns
		{
			get
			{
				return m_SwirlTurns;
			}
			set
			{
				if (m_SwirlTurns != value)
				{
					m_SwirlTurns = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
				}
			}
		}

		public Vector3 HandleIn
		{
			get
			{
				return m_HandleIn;
			}
			set
			{
				if (m_HandleIn != value)
				{
					m_HandleIn = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public Vector3 HandleOut
		{
			get
			{
				return m_HandleOut;
			}
			set
			{
				if (m_HandleOut != value)
				{
					m_HandleOut = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public Vector3 HandleInPosition
		{
			get
			{
				return base.transform.position + Spline.transform.rotation * HandleIn;
			}
			set
			{
				HandleIn = Spline.transform.InverseTransformDirection(value - base.transform.position);
			}
		}

		public Vector3 HandleOutPosition
		{
			get
			{
				return base.transform.position + Spline.transform.rotation * HandleOut;
			}
			set
			{
				HandleOut = Spline.transform.InverseTransformDirection(value - base.transform.position);
			}
		}

		public bool AutoHandles
		{
			get
			{
				return m_AutoHandles;
			}
			set
			{
				if (SetAutoHandles(value))
				{
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float AutoHandleDistance
		{
			get
			{
				return m_AutoHandleDistance;
			}
			set
			{
				if (m_AutoHandleDistance != value)
				{
					float num = Mathf.Clamp01(value);
					if (m_AutoHandleDistance != num)
					{
						m_AutoHandleDistance = num;
						Spline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public bool SynchronizeTCB
		{
			get
			{
				return m_SynchronizeTCB;
			}
			set
			{
				if (m_SynchronizeTCB != value)
				{
					m_SynchronizeTCB = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalTension
		{
			get
			{
				return m_OverrideGlobalTension;
			}
			set
			{
				if (m_OverrideGlobalTension != value)
				{
					m_OverrideGlobalTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalContinuity
		{
			get
			{
				return m_OverrideGlobalContinuity;
			}
			set
			{
				if (m_OverrideGlobalContinuity != value)
				{
					m_OverrideGlobalContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalBias
		{
			get
			{
				return m_OverrideGlobalBias;
			}
			set
			{
				if (m_OverrideGlobalBias != value)
				{
					m_OverrideGlobalBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartTension
		{
			get
			{
				return m_StartTension;
			}
			set
			{
				if (m_StartTension != value)
				{
					m_StartTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartContinuity
		{
			get
			{
				return m_StartContinuity;
			}
			set
			{
				if (m_StartContinuity != value)
				{
					m_StartContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartBias
		{
			get
			{
				return m_StartBias;
			}
			set
			{
				if (m_StartBias != value)
				{
					m_StartBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndTension
		{
			get
			{
				return m_EndTension;
			}
			set
			{
				if (m_EndTension != value)
				{
					m_EndTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndContinuity
		{
			get
			{
				return m_EndContinuity;
			}
			set
			{
				if (m_EndContinuity != value)
				{
					m_EndContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndBias
		{
			get
			{
				return m_EndBias;
			}
			set
			{
				if (m_EndBias != value)
				{
					m_EndBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public CurvySplineSegment FollowUp
		{
			get
			{
				return m_FollowUp;
			}
			private set
			{
				if (m_FollowUp != value)
				{
					m_FollowUp = value;
					if (mSpline != null)
					{
						mSpline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public ConnectionHeadingEnum FollowUpHeading
		{
			get
			{
				return m_FollowUpHeading;
			}
			set
			{
				if (m_FollowUpHeading != value)
				{
					m_FollowUpHeading = value;
					if (mSpline != null)
					{
						mSpline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public bool ConnectionSyncPosition
		{
			get
			{
				return m_ConnectionSyncPosition;
			}
			set
			{
				if (m_ConnectionSyncPosition != value)
				{
					m_ConnectionSyncPosition = value;
				}
			}
		}

		public bool ConnectionSyncRotation
		{
			get
			{
				return m_ConnectionSyncRotation;
			}
			set
			{
				if (m_ConnectionSyncRotation != value)
				{
					m_ConnectionSyncRotation = value;
				}
			}
		}

		public CurvyConnection Connection
		{
			get
			{
				return m_Connection;
			}
			internal set
			{
				if (SetConnection(value) && mSpline != null)
				{
					mSpline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public int CacheSize
		{
			get
			{
				return cacheSize;
			}
			private set
			{
				cacheSize = value;
			}
		}

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					Bounds value;
					if (Approximation.Length == 0)
					{
						value = new Bounds(base.transform.position, Vector3.zero);
					}
					else
					{
						Matrix4x4 localToWorldMatrix = Spline.transform.localToWorldMatrix;
						value = new Bounds(localToWorldMatrix.MultiplyPoint3x4(Approximation[0]), Vector3.zero);
						int num = Approximation.Length;
						for (int i = 1; i < num; i++)
						{
							value.Encapsulate(localToWorldMatrix.MultiplyPoint(Approximation[i]));
						}
					}
					mBounds = value;
				}
				return mBounds.Value;
			}
		}

		public float Length { get; private set; }

		public float Distance { get; internal set; }

		public float TF => LocalFToTF(0f);

		public bool IsFirstControlPoint => Spline.GetControlPointIndex(this) == 0;

		public bool IsLastControlPoint => Spline.GetControlPointIndex(this) == Spline.ControlPointCount - 1;

		public List<Component> MetaData
		{
			get
			{
				if (mMetaData == null)
				{
					ReloadMetaData();
				}
				return mMetaData;
			}
		}

		public CurvySpline Spline => mSpline;

		public bool HasUnprocessedLocalPosition => base.transform.localPosition != lastProcessedLocalPosition;

		public bool HasUnprocessedLocalOrientation => base.transform.localRotation.DifferentOrientation(lastProcessedLocalRotation);

		public bool OrientatinInfluencesSpline => mSpline != null && (mSpline.Orientation == CurvyOrientation.Static || mSpline.IsControlPointAnOrientationAnchor(this));

		private CurvyInterpolation interpolation => Spline ? Spline.Interpolation : CurvyInterpolation.Linear;

		private bool isDynamicOrientation => (bool)Spline && Spline.Orientation == CurvyOrientation.Dynamic;

		private bool IsOrientationAnchorEditable
		{
			get
			{
				CurvySpline spline = Spline;
				return isDynamicOrientation && spline.IsControlPointVisible(this) && spline.FirstVisibleControlPoint != this && spline.LastVisibleControlPoint != this;
			}
		}

		private bool canHaveSwirl
		{
			get
			{
				CurvySpline spline = Spline;
				return isDynamicOrientation && (bool)spline && spline.IsControlPointAnOrientationAnchor(this) && (spline.Closed || spline.LastVisibleControlPoint != this);
			}
		}

		public void SetBezierHandleIn(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
		{
			if (space == Space.Self)
			{
				HandleIn = position;
			}
			else
			{
				HandleInPosition = position;
			}
			bool flag = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
			bool flag2 = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
			bool flag3 = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;
			if (flag)
			{
				HandleOut = HandleOut.magnitude * (HandleIn.normalized * -1f);
			}
			if (flag2)
			{
				HandleOut = HandleIn.magnitude * ((!(HandleOut == Vector3.zero)) ? HandleOut.normalized : (HandleIn.normalized * -1f));
			}
			if (!Connection || !flag3 || (!flag && !flag2))
			{
				return;
			}
			ReadOnlyCollection<CurvySplineSegment> controlPointsList = Connection.ControlPointsList;
			for (int i = 0; i < controlPointsList.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = controlPointsList[i];
				if (!(curvySplineSegment == this))
				{
					if (curvySplineSegment.HandleIn.magnitude == 0f)
					{
						curvySplineSegment.HandleIn = HandleIn;
					}
					if (flag)
					{
						curvySplineSegment.SetBezierHandleIn(curvySplineSegment.HandleIn.magnitude * HandleIn.normalized * Mathf.Sign(Vector3.Dot(HandleIn, curvySplineSegment.HandleIn)), Space.Self, CurvyBezierModeEnum.Direction);
					}
					if (flag2)
					{
						curvySplineSegment.SetBezierHandleIn(curvySplineSegment.HandleIn.normalized * HandleIn.magnitude, Space.Self, CurvyBezierModeEnum.Length);
					}
				}
			}
		}

		public void SetBezierHandleOut(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
		{
			if (space == Space.Self)
			{
				HandleOut = position;
			}
			else
			{
				HandleOutPosition = position;
			}
			bool flag = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
			bool flag2 = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
			bool flag3 = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;
			if (flag)
			{
				HandleIn = HandleIn.magnitude * (HandleOut.normalized * -1f);
			}
			if (flag2)
			{
				HandleIn = HandleOut.magnitude * ((!(HandleIn == Vector3.zero)) ? HandleIn.normalized : (HandleOut.normalized * -1f));
			}
			if (!Connection || !flag3 || (!flag && !flag2))
			{
				return;
			}
			for (int i = 0; i < Connection.ControlPointsList.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = Connection.ControlPointsList[i];
				if (!(curvySplineSegment == this))
				{
					if (curvySplineSegment.HandleOut.magnitude == 0f)
					{
						curvySplineSegment.HandleOut = HandleOut;
					}
					if (flag)
					{
						curvySplineSegment.SetBezierHandleOut(curvySplineSegment.HandleOut.magnitude * HandleOut.normalized * Mathf.Sign(Vector3.Dot(HandleOut, curvySplineSegment.HandleOut)), Space.Self, CurvyBezierModeEnum.Direction);
					}
					if (flag2)
					{
						curvySplineSegment.SetBezierHandleOut(curvySplineSegment.HandleOut.normalized * HandleOut.magnitude, Space.Self, CurvyBezierModeEnum.Length);
					}
				}
			}
		}

		public void SetBezierHandles(float distanceFrag = -1f, bool setIn = true, bool setOut = true, bool noDirtying = false)
		{
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			if (distanceFrag == -1f)
			{
				distanceFrag = AutoHandleDistance;
			}
			if (distanceFrag > 0f)
			{
				CurvySpline spline = Spline;
				Transform transform = base.transform;
				CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
				Transform transform2 = ((!nextControlPoint) ? transform : nextControlPoint.transform);
				CurvySplineSegment previousControlPoint = spline.GetPreviousControlPoint(this);
				Transform transform3 = ((!previousControlPoint) ? transform : previousControlPoint.transform);
				Vector3 localPosition = transform.localPosition;
				Vector3 p = transform3.localPosition - localPosition;
				Vector3 n = transform2.localPosition - localPosition;
				SetBezierHandles(distanceFrag, p, n, setIn, setOut, noDirtying);
				return;
			}
			if (setIn)
			{
				if (noDirtying)
				{
					m_HandleIn = zero;
				}
				else
				{
					HandleIn = zero;
				}
			}
			if (setOut)
			{
				if (noDirtying)
				{
					m_HandleOut = zero2;
				}
				else
				{
					HandleOut = zero2;
				}
			}
		}

		public void SetBezierHandles(float distanceFrag, Vector3 p, Vector3 n, bool setIn = true, bool setOut = true, bool noDirtying = false)
		{
			float magnitude = p.magnitude;
			float magnitude2 = n.magnitude;
			Vector3 handleIn = Vector3.zero;
			Vector3 handleOut = Vector3.zero;
			if (magnitude != 0f || magnitude2 != 0f)
			{
				Vector3 normalized = (magnitude / magnitude2 * n - p).normalized;
				handleIn = -normalized * (magnitude * distanceFrag);
				handleOut = normalized * (magnitude2 * distanceFrag);
			}
			if (setIn)
			{
				if (noDirtying)
				{
					m_HandleIn = handleIn;
				}
				else
				{
					HandleIn = handleIn;
				}
			}
			if (setOut)
			{
				if (noDirtying)
				{
					m_HandleOut = handleOut;
				}
				else
				{
					HandleOut = handleOut;
				}
			}
		}

		public void ReloadMetaData()
		{
			mMetaData = new List<Component>();
			GetComponents(typeof(ICurvyMetadata), mMetaData);
		}

		public void SetFollowUp(CurvySplineSegment target, ConnectionHeadingEnum heading = ConnectionHeadingEnum.Auto)
		{
			if (target == null || Spline.CanControlPointHaveFollowUp(this))
			{
				FollowUp = target;
				FollowUpHeading = heading;
			}
			else
			{
				DTLog.LogError("[Curvy] Setting a Follow-Up to a Control Point that can't have one");
			}
		}

		public void Disconnect()
		{
			if ((bool)Connection)
			{
				Connection.RemoveControlPoint(this);
			}
			ResetConnectionRelatedData();
		}

		public void ResetConnectionRelatedData()
		{
			Connection = null;
			FollowUp = null;
			FollowUpHeading = ConnectionHeadingEnum.Auto;
			ConnectionSyncPosition = false;
			ConnectionSyncRotation = false;
		}

		public Vector3 Interpolate(float localF)
		{
			return Interpolate(localF, Spline.Interpolation);
		}

		public Vector3 Interpolate(float localF, CurvyInterpolation interpolation)
		{
			switch (interpolation)
			{
			case CurvyInterpolation.Bezier:
				return interpolateBezier(localF);
			case CurvyInterpolation.CatmullRom:
				return interpolateCatmull(localF);
			case CurvyInterpolation.TCB:
				return interpolateTCB(localF);
			case CurvyInterpolation.Linear:
				return interpolateLinear(localF);
			default:
				DTLog.LogError("[Curvy] Invalid interpolation value " + interpolation);
				return Vector3.zero;
			}
		}

		public Vector3 InterpolateFast(float localF)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(Approximation.Length - 1, approximationIndexINTERNAL + 1);
			return Vector3.LerpUnclamped(Approximation[approximationIndexINTERNAL], Approximation[num], frag);
		}

		public Component GetMetaData(Type type, bool autoCreate = false)
		{
			List<Component> metaData = MetaData;
			if (metaData != null && type.IsSubclassOf(typeof(Component)) && typeof(ICurvyMetadata).IsAssignableFrom(type))
			{
				for (int i = 0; i < metaData.Count; i++)
				{
					if (metaData[i] != null && metaData[i].GetType() == type)
					{
						return metaData[i];
					}
				}
			}
			Component component = null;
			if (autoCreate)
			{
				component = base.gameObject.AddComponent(type);
				MetaData.Add(component);
			}
			return component;
		}

		public T GetMetadata<T>(bool autoCreate = false) where T : Component, ICurvyMetadata
		{
			return (T)GetMetaData(typeof(T), autoCreate);
		}

		public U InterpolateMetadata<T, U>(float f) where T : Component, ICurvyInterpolatableMetadata<U>
		{
			T metadata = GetMetadata<T>();
			if (metadata != null)
			{
				CurvySplineSegment nextControlPointUsingFollowUp = Spline.GetNextControlPointUsingFollowUp(this);
				ICurvyInterpolatableMetadata<U> b = null;
				if ((bool)nextControlPointUsingFollowUp)
				{
					b = nextControlPointUsingFollowUp.GetMetadata<T>();
				}
				return metadata.Interpolate(b, f);
			}
			return default(U);
		}

		public object InterpolateMetadata(Type type, float f)
		{
			if (GetMetaData(type) is ICurvyInterpolatableMetadata curvyInterpolatableMetadata)
			{
				CurvySplineSegment nextControlPointUsingFollowUp = Spline.GetNextControlPointUsingFollowUp(this);
				ICurvyInterpolatableMetadata curvyInterpolatableMetadata2 = null;
				if ((bool)nextControlPointUsingFollowUp && nextControlPointUsingFollowUp.GetMetaData(type) is ICurvyInterpolatableMetadata b)
				{
					return curvyInterpolatableMetadata.InterpolateObject(b, f);
				}
			}
			return null;
		}

		public void DeleteMetadata()
		{
			List<Component> metaData = MetaData;
			for (int num = metaData.Count - 1; num >= 0; num--)
			{
				metaData[num].Destroy();
			}
		}

		public Vector3 InterpolateScale(float localF)
		{
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			return (!nextControlPoint) ? base.transform.lossyScale : Vector3.Lerp(base.transform.lossyScale, nextControlPoint.transform.lossyScale, localF);
		}

		public Vector3 GetTangent(float localF)
		{
			localF = Mathf.Clamp01(localF);
			Vector3 position = Interpolate(localF);
			return GetTangent(localF, position);
		}

		public Vector3 GetTangent(float localF, Vector3 position)
		{
			CurvySpline spline = Spline;
			int num = 2;
			Vector3 vector;
			do
			{
				float num2 = localF + 0.01f;
				if (num2 > 1f)
				{
					CurvySplineSegment nextSegment = spline.GetNextSegment(this);
					if (!nextSegment)
					{
						num2 = localF - 0.01f;
						return (position - Interpolate(num2)).normalized;
					}
					vector = nextSegment.Interpolate(num2 - 1f);
				}
				else
				{
					vector = Interpolate(num2);
				}
				localF += 0.01f;
			}
			while (vector == position && --num > 0);
			return (vector - position).normalized;
		}

		public Vector3 GetTangentFast(float localF)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(ApproximationT.Length - 1, approximationIndexINTERNAL + 1);
			return Vector3.SlerpUnclamped(ApproximationT[approximationIndexINTERNAL], ApproximationT[num], frag);
		}

		public Quaternion GetOrientationFast(float localF)
		{
			return GetOrientationFast(localF, inverse: false);
		}

		public Quaternion GetOrientationFast(float localF, bool inverse)
		{
			Vector3 tangentFast = GetTangentFast(localF);
			if (tangentFast != Vector3.zero)
			{
				if (inverse)
				{
					tangentFast *= -1f;
				}
				return Quaternion.LookRotation(tangentFast, GetOrientationUpFast(localF));
			}
			return Quaternion.identity;
		}

		public Vector3 GetOrientationUpFast(float localF)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(ApproximationUp.Length - 1, approximationIndexINTERNAL + 1);
			return Vector3.SlerpUnclamped(ApproximationUp[approximationIndexINTERNAL], ApproximationUp[num], frag);
		}

		public float GetNearestPointF(Vector3 p)
		{
			int num = CacheSize + 1;
			float num2 = float.MaxValue;
			int num3 = 0;
			Vector3 vector = default(Vector3);
			for (int i = 0; i < num; i++)
			{
				vector.x = Approximation[i].x - p.x;
				vector.y = Approximation[i].y - p.y;
				vector.z = Approximation[i].z - p.z;
				float num4 = vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;
				if (num4 <= num2)
				{
					num2 = num4;
					num3 = i;
				}
			}
			int num5 = ((num3 <= 0) ? (-1) : (num3 - 1));
			int num6 = ((num3 >= CacheSize) ? (-1) : (num3 + 1));
			float frag = 0f;
			float frag2 = 0f;
			float num7 = float.MaxValue;
			float num8 = float.MaxValue;
			if (num5 > -1)
			{
				num7 = DTMath.LinePointDistanceSqr(Approximation[num5], Approximation[num3], p, out frag);
			}
			if (num6 > -1)
			{
				num8 = DTMath.LinePointDistanceSqr(Approximation[num3], Approximation[num6], p, out frag2);
			}
			if (num7 < num8)
			{
				return getApproximationLocalF(num5) + frag * mStepSize;
			}
			return getApproximationLocalF(num3) + frag2 * mStepSize;
		}

		public float DistanceToLocalF(float localDistance)
		{
			localDistance = Mathf.Clamp(localDistance, 0f, Length);
			if (ApproximationDistances.Length <= 1 || localDistance == 0f)
			{
				return 0f;
			}
			if (Mathf.Approximately(localDistance, Length))
			{
				return 1f;
			}
			int num = Mathf.Min(ApproximationDistances.Length - 1, mCacheLastDistanceToLocalFIndex);
			if (ApproximationDistances[num] < localDistance)
			{
				num = ApproximationDistances.Length - 1;
			}
			while (ApproximationDistances[num] > localDistance)
			{
				num--;
			}
			mCacheLastDistanceToLocalFIndex = num + 1;
			float num2 = (localDistance - ApproximationDistances[num]) / (ApproximationDistances[num + 1] - ApproximationDistances[num]);
			float approximationLocalF = getApproximationLocalF(num);
			float approximationLocalF2 = getApproximationLocalF(num + 1);
			return approximationLocalF + (approximationLocalF2 - approximationLocalF) * num2;
		}

		public float LocalFToDistance(float localF)
		{
			localF = Mathf.Clamp01(localF);
			if (ApproximationDistances.Length <= 1 || localF == 0f)
			{
				return 0f;
			}
			if (Mathf.Approximately(localF, 1f))
			{
				return Length;
			}
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			float num = ApproximationDistances[approximationIndexINTERNAL + 1] - ApproximationDistances[approximationIndexINTERNAL];
			return ApproximationDistances[approximationIndexINTERNAL] + num * frag;
		}

		public float LocalFToTF(float localF)
		{
			return Spline.SegmentToTF(this, localF);
		}

		public override string ToString()
		{
			if (Spline != null)
			{
				return Spline.name + "." + base.name;
			}
			return base.ToString();
		}

		public void BakeOrientationToTransform()
		{
			Quaternion orientationFast = GetOrientationFast(0f);
			if (base.transform.localRotation.DifferentOrientation(orientationFast))
			{
				SetLocalRotation(orientationFast);
			}
		}

		public int getApproximationIndexINTERNAL(float localF, out float frag)
		{
			localF = Mathf.Clamp01(localF);
			if (localF == 1f)
			{
				frag = 1f;
				return Mathf.Max(0, Approximation.Length - 2);
			}
			float num = localF / mStepSize;
			int num2 = (int)num;
			frag = num - (float)num2;
			return num2;
		}

		public void LinkToSpline(CurvySpline spline)
		{
			mSpline = spline;
		}

		public void UnlinkFromSpline()
		{
			mSpline = null;
		}

		public void SetLocalPosition(Vector3 newPosition)
		{
			Transform transform = base.transform;
			if (transform.localPosition != newPosition)
			{
				transform.localPosition = newPosition;
				Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation((!ConnectionSyncPosition) ? Connection.transform.position : transform.position, (!ConnectionSyncRotation) ? Connection.transform.rotation : transform.rotation);
				}
			}
		}

		public void SetPosition(Vector3 value)
		{
			Transform transform = base.transform;
			if (transform.position != value)
			{
				transform.position = value;
				Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation((!ConnectionSyncPosition) ? Connection.transform.position : transform.position, (!ConnectionSyncRotation) ? Connection.transform.rotation : transform.rotation);
				}
			}
		}

		public void SetLocalRotation(Quaternion value)
		{
			Transform transform = base.transform;
			if (transform.localRotation != value)
			{
				transform.localRotation = value;
				if (OrientatinInfluencesSpline)
				{
					Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
				}
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation((!ConnectionSyncPosition) ? Connection.transform.position : transform.position, (!ConnectionSyncRotation) ? Connection.transform.rotation : transform.rotation);
				}
			}
		}

		public void SetRotation(Quaternion value)
		{
			Transform transform = base.transform;
			if (transform.rotation != value)
			{
				transform.rotation = value;
				if (OrientatinInfluencesSpline)
				{
					Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
				}
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation((!ConnectionSyncPosition) ? Connection.transform.position : transform.position, (!ConnectionSyncRotation) ? Connection.transform.rotation : transform.rotation);
				}
			}
		}

		public void OnBeforePush()
		{
			this.StripComponents();
			Disconnect();
			DeleteMetadata();
		}

		public void OnAfterPop()
		{
			Reset();
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
		}

		private void Update()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void LateUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void OnDestroy()
		{
			if (true)
			{
				Disconnect();
			}
		}

		public void Reset()
		{
			m_OrientationAnchor = false;
			m_Swirl = CurvyOrientationSwirl.None;
			m_SwirlTurns = 0f;
			m_AutoHandles = true;
			m_AutoHandleDistance = 0.39f;
			m_HandleIn = new Vector3(-1f, 0f, 0f);
			m_HandleOut = new Vector3(1f, 0f, 0f);
			m_SynchronizeTCB = true;
			m_OverrideGlobalTension = false;
			m_OverrideGlobalContinuity = false;
			m_OverrideGlobalBias = false;
			m_StartTension = 0f;
			m_EndTension = 0f;
			m_StartContinuity = 0f;
			m_EndContinuity = 0f;
			m_StartBias = 0f;
			m_EndBias = 0f;
			if ((bool)mSpline)
			{
				Spline.SetDirty(this, SplineDirtyingType.Everything);
				Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
			}
		}

		internal void SetExtrinsicPropertiesINTERNAL(ControlPointExtrinsicProperties value)
		{
			extrinsicPropertiesINTERNAL = value;
		}

		internal ControlPointExtrinsicProperties GetExtrinsicPropertiesINTERNAL()
		{
			return extrinsicPropertiesINTERNAL;
		}

		private void DoUpdate()
		{
			if (AutoBakeOrientation && ApproximationUp.Length > 0)
			{
				BakeOrientationToTransform();
			}
		}

		private bool SetConnection(CurvyConnection newConnection)
		{
			bool result = false;
			if (m_Connection != newConnection)
			{
				result = true;
				m_Connection = newConnection;
			}
			if (m_Connection == null && m_FollowUp != null)
			{
				result = true;
				m_FollowUp = null;
			}
			return result;
		}

		private bool SetAutoHandles(bool newValue)
		{
			bool flag = false;
			if ((bool)Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = Connection.ControlPointsList;
				for (int i = 0; i < controlPointsList.Count; i++)
				{
					CurvySplineSegment curvySplineSegment = controlPointsList[i];
					flag = flag || curvySplineSegment.m_AutoHandles != newValue;
					curvySplineSegment.m_AutoHandles = newValue;
				}
			}
			else
			{
				flag = m_AutoHandles != newValue;
				m_AutoHandles = newValue;
			}
			return flag;
		}

		private float getApproximationLocalF(int idx)
		{
			return (float)idx * mStepSize;
		}

		private Vector3 interpolateLinear(float localF)
		{
			Transform transform = base.transform;
			localF = Mathf.Clamp01(localF);
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			return Vector3.LerpUnclamped(transform.localPosition, ((!nextControlPoint) ? transform : nextControlPoint.transform).localPosition, localF);
		}

		private Vector3 interpolateBezier(float localF)
		{
			localF = Mathf.Clamp01(localF);
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			Transform transform = nextControlPoint.transform;
			Vector3 localPosition = base.transform.localPosition;
			return CurvySpline.Bezier(localPosition + HandleOut, localPosition, transform.localPosition, transform.localPosition + nextControlPoint.HandleIn, localF);
		}

		private Vector3 interpolateCatmull(float localF)
		{
			localF = Mathf.Clamp01(localF);
			CurvySpline spline = Spline;
			CurvySplineSegment previousControlPointUsingFollowUp = spline.GetPreviousControlPointUsingFollowUp(this);
			CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
			CurvySplineSegment nextControlPointUsingFollowUp = nextControlPoint.Spline.GetNextControlPointUsingFollowUp(nextControlPoint);
			Vector3 localPosition = base.transform.localPosition;
			Vector3 t = ((!previousControlPointUsingFollowUp) ? localPosition : previousControlPointUsingFollowUp.transform.localPosition);
			Vector3 localPosition2 = nextControlPoint.transform.localPosition;
			Vector3 t2 = ((!nextControlPointUsingFollowUp) ? localPosition2 : nextControlPointUsingFollowUp.transform.localPosition);
			return CurvySpline.CatmullRom(t, localPosition, localPosition2, t2, localF);
		}

		private Vector3 interpolateTCB(float localF)
		{
			localF = Mathf.Clamp01(localF);
			float fT = StartTension;
			float fT2 = EndTension;
			float fC = StartContinuity;
			float fC2 = EndContinuity;
			float fB = StartBias;
			float fB2 = EndBias;
			CurvySpline spline = Spline;
			if (!OverrideGlobalTension)
			{
				fT = (fT2 = spline.Tension);
			}
			if (!OverrideGlobalContinuity)
			{
				fC = (fC2 = spline.Continuity);
			}
			if (!OverrideGlobalBias)
			{
				fB = (fB2 = spline.Bias);
			}
			CurvySplineSegment previousControlPointUsingFollowUp = spline.GetPreviousControlPointUsingFollowUp(this);
			CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
			CurvySplineSegment nextControlPointUsingFollowUp = nextControlPoint.Spline.GetNextControlPointUsingFollowUp(nextControlPoint);
			Vector3 localPosition = base.transform.localPosition;
			Vector3 t = ((!previousControlPointUsingFollowUp) ? localPosition : previousControlPointUsingFollowUp.transform.localPosition);
			Vector3 localPosition2 = nextControlPoint.transform.localPosition;
			Vector3 t2 = ((!nextControlPointUsingFollowUp) ? localPosition2 : nextControlPointUsingFollowUp.transform.localPosition);
			return CurvySpline.TCB(t, localPosition, localPosition2, t2, localF, fT, fC, fB, fT2, fC2, fB2);
		}

		internal void refreshCurveINTERNAL(CurvyInterpolation splineInterpolation, bool isControlPointASegment, CurvySpline spline)
		{
			bool flag = isControlPointASegment;
			short nextControlPointIndex = spline.GetNextControlPointIndex(this);
			CurvySplineSegment curvySplineSegment = ((nextControlPointIndex != -1) ? spline.ControlPointsList[nextControlPointIndex] : null);
			int num2 = (CacheSize = (flag ? CurvySpline.CalculateCacheSize(spline.CacheDensity, (curvySplineSegment.threadSafeLocalPosition - threadSafeLocalPosition).magnitude, spline.MaxPointsPerUnit) : 0));
			Array.Resize(ref Approximation, num2 + 1);
			Array.Resize(ref ApproximationT, num2 + 1);
			Array.Resize(ref ApproximationDistances, num2 + 1);
			Array.Resize(ref ApproximationUp, num2 + 1);
			ref Vector3 reference = ref Approximation[0];
			reference = threadSafeLocalPosition;
			ApproximationDistances[0] = 0f;
			mBounds = null;
			Length = 0f;
			mStepSize = 1f / (float)num2;
			if (num2 != 0)
			{
				ref Vector3 reference2 = ref Approximation[num2];
				reference2 = ((nextControlPointIndex == -1) ? threadSafeLocalPosition : curvySplineSegment.threadSafeLocalPosition);
			}
			if (flag)
			{
				float length = 0f;
				switch (splineInterpolation)
				{
				case CurvyInterpolation.Bezier:
					length = InterpolateBezierSegment(spline, num2);
					break;
				case CurvyInterpolation.CatmullRom:
					length = InterpolateCatmullSegment(spline, curvySplineSegment, num2);
					break;
				case CurvyInterpolation.TCB:
					length = InterpolateTCBSegment(spline, curvySplineSegment, num2);
					break;
				case CurvyInterpolation.Linear:
					length = InterpolateLinearSegment(spline, num2);
					break;
				default:
					DTLog.LogError("[Curvy] Invalid interpolation value " + splineInterpolation);
					break;
				}
				Length = length;
				Vector3 vector = Approximation[num2] - Approximation[num2 - 1];
				Length += vector.magnitude;
				ApproximationDistances[num2] = Length;
				ref Vector3 reference3 = ref ApproximationT[num2 - 1];
				reference3 = vector.normalized;
				ref Vector3 reference4 = ref ApproximationT[num2];
				reference4 = ApproximationT[num2 - 1];
			}
			else if (nextControlPointIndex != -1)
			{
				ref Vector3 reference5 = ref ApproximationT[0];
				reference5 = (curvySplineSegment.threadSafeLocalPosition - Approximation[0]).normalized;
			}
			else
			{
				short previousControlPointIndex = spline.GetPreviousControlPointIndex(this);
				if (previousControlPointIndex != -1)
				{
					ref Vector3 reference6 = ref ApproximationT[0];
					reference6 = (Approximation[0] - spline.ControlPointsList[previousControlPointIndex].threadSafeLocalPosition).normalized;
				}
				else
				{
					ref Vector3 reference7 = ref ApproximationT[0];
					reference7 = threadSafeLocalRotation * Vector3.forward;
				}
			}
			lastProcessedLocalPosition = threadSafeLocalPosition;
		}

		private float InterpolateBezierSegment(CurvySpline spline, int newCacheSize)
		{
			float num = 0f;
			CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = vector + HandleOut;
			Vector3 vector3 = nextControlPoint.threadSafeLocalPosition;
			Vector3 vector4 = vector3 + nextControlPoint.HandleIn;
			double num2 = (double)(0f - vector.x) + 3.0 * (double)vector2.x + -3.0 * (double)vector4.x + (double)vector3.x;
			double num3 = 3.0 * (double)vector.x + -6.0 * (double)vector2.x + 3.0 * (double)vector4.x;
			double num4 = -3.0 * (double)vector.x + 3.0 * (double)vector2.x;
			double num5 = vector.x;
			double num6 = (double)(0f - vector.y) + 3.0 * (double)vector2.y + -3.0 * (double)vector4.y + (double)vector3.y;
			double num7 = 3.0 * (double)vector.y + -6.0 * (double)vector2.y + 3.0 * (double)vector4.y;
			double num8 = -3.0 * (double)vector.y + 3.0 * (double)vector2.y;
			double num9 = vector.y;
			double num10 = (double)(0f - vector.z) + 3.0 * (double)vector2.z + -3.0 * (double)vector4.z + (double)vector3.z;
			double num11 = 3.0 * (double)vector.z + -6.0 * (double)vector2.z + 3.0 * (double)vector4.z;
			double num12 = -3.0 * (double)vector.z + 3.0 * (double)vector2.z;
			double num13 = vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num14 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num2 * (double)num14 + num3) * (double)num14 + num4) * (double)num14 + num5);
				Approximation[i].y = (float)(((num6 * (double)num14 + num7) * (double)num14 + num8) * (double)num14 + num9);
				Approximation[i].z = (float)(((num10 * (double)num14 + num11) * (double)num14 + num12) * (double)num14 + num13);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num15 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num15;
				ApproximationDistances[i] = num;
				if ((double)num15 > 9.99999974737875E-06)
				{
					float num16 = 1f / num15;
					ApproximationT[i - 1].x = vector5.x * num16;
					ApproximationT[i - 1].y = vector5.y * num16;
					ApproximationT[i - 1].z = vector5.z * num16;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateTCBSegment(CurvySpline spline, CurvySplineSegment nextControlPoint, int newCacheSize)
		{
			float num = 0f;
			float num2 = StartTension;
			float num3 = EndTension;
			float num4 = StartContinuity;
			float num5 = EndContinuity;
			float num6 = StartBias;
			float num7 = EndBias;
			if (!OverrideGlobalTension)
			{
				num2 = (num3 = spline.Tension);
			}
			if (!OverrideGlobalContinuity)
			{
				num4 = (num5 = spline.Continuity);
			}
			if (!OverrideGlobalBias)
			{
				num6 = (num7 = spline.Bias);
			}
			CurvySplineSegment previousControlPointUsingFollowUp = spline.GetPreviousControlPointUsingFollowUp(this);
			CurvySplineSegment nextControlPointUsingFollowUp = nextControlPoint.Spline.GetNextControlPointUsingFollowUp(nextControlPoint);
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = nextControlPoint.threadSafeLocalPosition;
			Vector3 vector3 = ((!previousControlPointUsingFollowUp) ? vector : previousControlPointUsingFollowUp.threadSafeLocalPosition);
			Vector3 vector4 = ((!nextControlPointUsingFollowUp) ? vector2 : nextControlPointUsingFollowUp.threadSafeLocalPosition);
			double num8 = (1f - num2) * (1f + num4) * (1f + num6);
			double num9 = (1f - num2) * (1f - num4) * (1f - num6);
			double num10 = (1f - num3) * (1f - num5) * (1f + num7);
			double num11 = (1f - num3) * (1f + num5) * (1f - num7);
			double num12 = 2.0;
			double num13 = (0.0 - num8) / num12;
			double num14 = (4.0 + num8 - num9 - num10) / num12;
			double num15 = (-4.0 + num9 + num10 - num11) / num12;
			double num16 = num11 / num12;
			double num17 = 2.0 * num8 / num12;
			double num18 = (-6.0 - 2.0 * num8 + 2.0 * num9 + num10) / num12;
			double num19 = (6.0 - 2.0 * num9 - num10 + num11) / num12;
			double num20 = (0.0 - num11) / num12;
			double num21 = (0.0 - num8) / num12;
			double num22 = (num8 - num9) / num12;
			double num23 = num9 / num12;
			double num24 = 2.0 / num12;
			double num25 = num13 * (double)vector3.x + num14 * (double)vector.x + num15 * (double)vector2.x + num16 * (double)vector4.x;
			double num26 = num17 * (double)vector3.x + num18 * (double)vector.x + num19 * (double)vector2.x + num20 * (double)vector4.x;
			double num27 = num21 * (double)vector3.x + num22 * (double)vector.x + num23 * (double)vector2.x;
			double num28 = num24 * (double)vector.x;
			double num29 = num13 * (double)vector3.y + num14 * (double)vector.y + num15 * (double)vector2.y + num16 * (double)vector4.y;
			double num30 = num17 * (double)vector3.y + num18 * (double)vector.y + num19 * (double)vector2.y + num20 * (double)vector4.y;
			double num31 = num21 * (double)vector3.y + num22 * (double)vector.y + num23 * (double)vector2.y;
			double num32 = num24 * (double)vector.y;
			double num33 = num13 * (double)vector3.z + num14 * (double)vector.z + num15 * (double)vector2.z + num16 * (double)vector4.z;
			double num34 = num17 * (double)vector3.z + num18 * (double)vector.z + num19 * (double)vector2.z + num20 * (double)vector4.z;
			double num35 = num21 * (double)vector3.z + num22 * (double)vector.z + num23 * (double)vector2.z;
			double num36 = num24 * (double)vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num37 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num25 * (double)num37 + num26) * (double)num37 + num27) * (double)num37 + num28);
				Approximation[i].y = (float)(((num29 * (double)num37 + num30) * (double)num37 + num31) * (double)num37 + num32);
				Approximation[i].z = (float)(((num33 * (double)num37 + num34) * (double)num37 + num35) * (double)num37 + num36);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num38 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num38;
				ApproximationDistances[i] = num;
				if ((double)num38 > 9.99999974737875E-06)
				{
					float num39 = 1f / num38;
					ApproximationT[i - 1].x = vector5.x * num39;
					ApproximationT[i - 1].y = vector5.y * num39;
					ApproximationT[i - 1].z = vector5.z * num39;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateCatmullSegment(CurvySpline spline, CurvySplineSegment nextControlPoint, int newCacheSize)
		{
			float num = 0f;
			CurvySplineSegment previousControlPointUsingFollowUp = spline.GetPreviousControlPointUsingFollowUp(this);
			CurvySplineSegment nextControlPointUsingFollowUp = nextControlPoint.Spline.GetNextControlPointUsingFollowUp(nextControlPoint);
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = nextControlPoint.threadSafeLocalPosition;
			Vector3 vector3 = ((!previousControlPointUsingFollowUp) ? vector : previousControlPointUsingFollowUp.threadSafeLocalPosition);
			Vector3 vector4 = ((!nextControlPointUsingFollowUp) ? vector2 : nextControlPointUsingFollowUp.threadSafeLocalPosition);
			double num2 = -0.5 * (double)vector3.x + 1.5 * (double)vector.x + -1.5 * (double)vector2.x + 0.5 * (double)vector4.x;
			double num3 = (double)vector3.x + -2.5 * (double)vector.x + 2.0 * (double)vector2.x + -0.5 * (double)vector4.x;
			double num4 = -0.5 * (double)vector3.x + 0.5 * (double)vector2.x;
			double num5 = vector.x;
			double num6 = -0.5 * (double)vector3.y + 1.5 * (double)vector.y + -1.5 * (double)vector2.y + 0.5 * (double)vector4.y;
			double num7 = (double)vector3.y + -2.5 * (double)vector.y + 2.0 * (double)vector2.y + -0.5 * (double)vector4.y;
			double num8 = -0.5 * (double)vector3.y + 0.5 * (double)vector2.y;
			double num9 = vector.y;
			double num10 = -0.5 * (double)vector3.z + 1.5 * (double)vector.z + -1.5 * (double)vector2.z + 0.5 * (double)vector4.z;
			double num11 = (double)vector3.z + -2.5 * (double)vector.z + 2.0 * (double)vector2.z + -0.5 * (double)vector4.z;
			double num12 = -0.5 * (double)vector3.z + 0.5 * (double)vector2.z;
			double num13 = vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num14 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num2 * (double)num14 + num3) * (double)num14 + num4) * (double)num14 + num5);
				Approximation[i].y = (float)(((num6 * (double)num14 + num7) * (double)num14 + num8) * (double)num14 + num9);
				Approximation[i].z = (float)(((num10 * (double)num14 + num11) * (double)num14 + num12) * (double)num14 + num13);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num15 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num15;
				ApproximationDistances[i] = num;
				if ((double)num15 > 9.99999974737875E-06)
				{
					float num16 = 1f / num15;
					ApproximationT[i - 1].x = vector5.x * num16;
					ApproximationT[i - 1].y = vector5.y * num16;
					ApproximationT[i - 1].z = vector5.z * num16;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateLinearSegment(CurvySpline spline, int newCacheSize)
		{
			float num = 0f;
			Vector3 a = threadSafeLocalPosition;
			Vector3 b = spline.GetNextControlPoint(this).threadSafeLocalPosition;
			Vector3 vector = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float t = (float)i * mStepSize;
				ref Vector3 reference = ref Approximation[i];
				reference = Vector3.LerpUnclamped(a, b, t);
				vector.x = Approximation[i].x - Approximation[i - 1].x;
				vector.y = Approximation[i].y - Approximation[i - 1].y;
				vector.z = Approximation[i].z - Approximation[i - 1].z;
				float num2 = Mathf.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
				num += num2;
				ApproximationDistances[i] = num;
				if ((double)num2 > 9.99999974737875E-06)
				{
					float num3 = 1f / num2;
					ApproximationT[i - 1].x = vector.x * num3;
					ApproximationT[i - 1].y = vector.y * num3;
					ApproximationT[i - 1].z = vector.z * num3;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		internal void refreshOrientationNoneINTERNAL()
		{
			Array.Clear(ApproximationUp, 0, ApproximationUp.Length);
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void refreshOrientationStaticINTERNAL()
		{
			ref Vector3 reference = ref ApproximationUp[0];
			Vector3 a = (reference = getOrthoUp0INTERNAL());
			if (Approximation.Length > 1)
			{
				int num = CacheSize;
				ref Vector3 reference2 = ref ApproximationUp[num];
				Vector3 b = (reference2 = getOrthoUp1INTERNAL());
				float num2 = 1f / (float)num;
				for (int i = 1; i < num; i++)
				{
					ref Vector3 reference3 = ref ApproximationUp[i];
					reference3 = Vector3.SlerpUnclamped(a, b, (float)i * num2);
				}
			}
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void refreshOrientationDynamicINTERNAL(Vector3 initialUp)
		{
			int num = ApproximationUp.Length;
			ApproximationUp[0] = initialUp;
			Vector3 axis = default(Vector3);
			for (int i = 1; i < num; i++)
			{
				Vector3 vector = ApproximationT[i - 1];
				Vector3 vector2 = ApproximationT[i];
				axis.x = vector.y * vector2.z - vector.z * vector2.y;
				axis.y = vector.z * vector2.x - vector.x * vector2.z;
				axis.z = vector.x * vector2.y - vector.y * vector2.x;
				float num2 = (float)Math.Atan2(Math.Sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z), vector.x * vector2.x + vector.y * vector2.y + vector.z * vector2.z);
				ref Vector3 reference = ref ApproximationUp[i];
				reference = Quaternion.AngleAxis(57.29578f * num2, axis) * ApproximationUp[i - 1];
			}
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void ClearBoundsINTERNAL()
		{
			mBounds = null;
		}

		internal Vector3 getOrthoUp0INTERNAL()
		{
			Vector3 tangent = threadSafeLocalRotation * Vector3.up;
			Vector3.OrthoNormalize(ref ApproximationT[0], ref tangent);
			return tangent;
		}

		private Vector3 getOrthoUp1INTERNAL()
		{
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			Quaternion quaternion = ((!nextControlPoint) ? threadSafeLocalRotation : nextControlPoint.threadSafeLocalRotation);
			Vector3 tangent = quaternion * Vector3.up;
			Vector3.OrthoNormalize(ref ApproximationT[CacheSize], ref tangent);
			return tangent;
		}

		internal void UnsetFollowUpWithoutDirtyingINTERNAL()
		{
			m_FollowUp = null;
			m_FollowUpHeading = ConnectionHeadingEnum.Auto;
		}

		private bool SnapToFitSplineLength(float newSplineLength, float stepSize)
		{
			CurvySpline spline = Spline;
			if (stepSize == 0f || Mathf.Approximately(newSplineLength, spline.Length))
			{
				return true;
			}
			Transform transform = base.transform;
			float length = spline.Length;
			Vector3 position = transform.position;
			Vector3 vector = transform.up * stepSize;
			transform.position += vector;
			spline.SetDirty(this, SplineDirtyingType.Everything);
			spline.Refresh();
			bool flag = spline.Length > length;
			int num = 30000;
			transform.position = position;
			if (newSplineLength > length)
			{
				if (!flag)
				{
					vector *= -1f;
				}
				while (spline.Length < newSplineLength)
				{
					num--;
					length = spline.Length;
					transform.position += vector;
					spline.SetDirty(this, SplineDirtyingType.Everything);
					spline.Refresh();
					if (length > spline.Length)
					{
						return false;
					}
					if (num == 0)
					{
						Debug.LogError("CurvySplineSegment.SnapToFitSplineLength exceeds 30000 loops, considering this a dead loop! This shouldn't happen, please send a bug report.");
						return false;
					}
				}
			}
			else
			{
				if (flag)
				{
					vector *= -1f;
				}
				while (spline.Length > newSplineLength)
				{
					num--;
					length = spline.Length;
					transform.position += vector;
					spline.SetDirty(this, SplineDirtyingType.Everything);
					spline.Refresh();
					if (length < spline.Length)
					{
						return false;
					}
					if (num == 0)
					{
						Debug.LogError("CurvySplineSegment.SnapToFitSplineLength exceeds 30000 loops, considering this a dead loop! This shouldn't happen, please send a bug report.");
						return false;
					}
				}
			}
			return true;
		}

		internal void PrepareThreadSafeTransfromINTERNAL()
		{
			Transform transform = base.transform;
			threadSafeLocalPosition = transform.localPosition;
			threadSafeLocalRotation = transform.localRotation;
		}
	}
	public static class CurvySplineSegmentDefaultValues
	{
		public const CurvyOrientationSwirl Swirl = CurvyOrientationSwirl.None;

		public const bool AutoHandles = true;

		public const float AutoHandleDistance = 0.39f;

		public static readonly Vector3 HandleIn = new Vector3(-1f, 0f, 0f);

		public static readonly Vector3 HandleOut = new Vector3(1f, 0f, 0f);
	}
	[RequireComponent(typeof(RectTransform))]
	[AddComponentMenu("Curvy/Curvy UI Spline", 2)]
	public class CurvyUISpline : CurvySpline
	{
		public static CurvyUISpline CreateUISpline(string gameObjectName = "Curvy UI Spline")
		{
			CurvyUISpline component = new GameObject(gameObjectName, typeof(CurvyUISpline)).GetComponent<CurvyUISpline>();
			component.SetupUISpline();
			return component;
		}

		protected override void Reset()
		{
			base.Reset();
			SetupUISpline();
		}

		private void SetupUISpline()
		{
			base.RestrictTo2D = true;
			base.MaxPointsPerUnit = 1f;
			base.Orientation = CurvyOrientation.None;
		}
	}
}
namespace FluffyUnderware.Curvy.Utils
{
	public static class CurvyUtility
	{
		public static float ClampTF(float tf, CurvyClamping clamping)
		{
			return clamping switch
			{
				CurvyClamping.Loop => Mathf.Repeat(tf, 1f), 
				CurvyClamping.PingPong => Mathf.PingPong(tf, 1f), 
				CurvyClamping.Clamp => Mathf.Clamp01(tf), 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		public static float ClampValue(float tf, CurvyClamping clamping, float minTF, float maxTF)
		{
			switch (clamping)
			{
			case CurvyClamping.Loop:
			{
				float t2 = DTMath.MapValue(0f, 1f, tf, minTF, maxTF);
				return DTMath.MapValue(minTF, maxTF, Mathf.Repeat(t2, 1f), 0f);
			}
			case CurvyClamping.PingPong:
			{
				float t = DTMath.MapValue(0f, 1f, tf, minTF, maxTF);
				return DTMath.MapValue(minTF, maxTF, Mathf.PingPong(t, 1f), 0f);
			}
			case CurvyClamping.Clamp:
				return Mathf.Clamp(tf, minTF, maxTF);
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static float ClampTF(float tf, ref int dir, CurvyClamping clamping)
		{
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return Mathf.Repeat(tf, 1f);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(tf) % 2 != 0)
				{
					dir *= -1;
				}
				return Mathf.PingPong(tf, 1f);
			default:
				return Mathf.Clamp01(tf);
			}
		}

		public static float ClampTF(float tf, ref int dir, CurvyClamping clamping, float minTF, float maxTF)
		{
			minTF = Mathf.Clamp01(minTF);
			maxTF = Mathf.Clamp(maxTF, minTF, 1f);
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return minTF + Mathf.Repeat(tf, maxTF - minTF);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(tf / (maxTF - minTF)) % 2 != 0)
				{
					dir *= -1;
				}
				return minTF + Mathf.PingPong(tf, maxTF - minTF);
			default:
				return Mathf.Clamp(tf, minTF, maxTF);
			}
		}

		public static float ClampDistance(float distance, CurvyClamping clamping, float length)
		{
			if (length == 0f)
			{
				return 0f;
			}
			return clamping switch
			{
				CurvyClamping.Loop => Mathf.Repeat(distance, length), 
				CurvyClamping.PingPong => Mathf.PingPong(distance, length), 
				_ => Mathf.Clamp(distance, 0f, length), 
			};
		}

		public static float ClampDistance(float distance, CurvyClamping clamping, float length, float min, float max)
		{
			if (length == 0f)
			{
				return 0f;
			}
			min = Mathf.Clamp(min, 0f, length);
			max = Mathf.Clamp(max, min, length);
			return clamping switch
			{
				CurvyClamping.Loop => min + Mathf.Repeat(distance, max - min), 
				CurvyClamping.PingPong => min + Mathf.PingPong(distance, max - min), 
				_ => Mathf.Clamp(distance, min, max), 
			};
		}

		public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length)
		{
			if (length == 0f)
			{
				return 0f;
			}
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return Mathf.Repeat(distance, length);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(distance / length) % 2 != 0)
				{
					dir *= -1;
				}
				return Mathf.PingPong(distance, length);
			default:
				return Mathf.Clamp(distance, 0f, length);
			}
		}

		public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length, float min, float max)
		{
			if (length == 0f)
			{
				return 0f;
			}
			min = Mathf.Clamp(min, 0f, length);
			max = Mathf.Clamp(max, min, length);
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return min + Mathf.Repeat(distance, max - min);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(distance / (max - min)) % 2 != 0)
				{
					dir *= -1;
				}
				return min + Mathf.PingPong(distance, max - min);
			default:
				return Mathf.Clamp(distance, min, max);
			}
		}

		public static Material GetDefaultMaterial()
		{
			Material material = Resources.Load("CurvyDefaultMaterial") as Material;
			if (material == null)
			{
				material = new Material(Shader.Find("Diffuse"));
			}
			return material;
		}

		public static bool Approximately(this float x, float y)
		{
			float num = Mathf.Epsilon * 8f;
			if (Math.Abs(x) < num)
			{
				return Math.Abs(y) < 1E-06f;
			}
			if (Math.Abs(y) < num)
			{
				return Math.Abs(x) < 1E-06f;
			}
			return Mathf.Approximately(x, y);
		}
	}
	public class Spline2Mesh
	{
		public List<SplinePolyLine> Lines = new List<SplinePolyLine>();

		public WindingRule Winding;

		public Vector2 UVTiling = Vector2.one;

		public Vector2 UVOffset = Vector2.zero;

		public bool SuppressUVMapping;

		public bool UV2;

		public string MeshName = string.Empty;

		public bool VertexLineOnly;

		private Tess mTess;

		private Mesh mMesh;

		public string Error { get; private set; }

		public bool Apply(out Mesh result)
		{
			mTess = null;
			mMesh = null;
			Error = string.Empty;
			bool flag = triangulate();
			if (flag)
			{
				mMesh = new Mesh();
				mMesh.name = MeshName;
				if (VertexLineOnly && Lines.Count > 0 && Lines[0] != null)
				{
					mMesh.vertices = Lines[0].GetVertices();
				}
				else
				{
					mMesh.vertices = UnityLibTessUtility.FromContourVertex(mTess.Vertices);
					mMesh.triangles = mTess.Elements;
				}
				mMesh.RecalculateBounds();
				mMesh.RecalculateNormals();
				if (!SuppressUVMapping && !VertexLineOnly)
				{
					Vector3 size = mMesh.bounds.size;
					Vector3 min = mMesh.bounds.min;
					float num = Mathf.Min(size.x, Mathf.Min(size.y, size.z));
					bool flag2 = num == size.x;
					bool flag3 = num == size.y;
					bool flag4 = num == size.z;
					Vector3[] vertices = mMesh.vertices;
					Vector2[] array = new Vector2[vertices.Length];
					float num2 = 0f;
					float num3 = 0f;
					for (int i = 0; i < vertices.Length; i++)
					{
						float num4;
						float num5;
						if (flag2)
						{
							num4 = UVOffset.x + (vertices[i].y - min.y) / size.y;
							num5 = UVOffset.y + (vertices[i].z - min.z) / size.z;
						}
						else if (flag3)
						{
							num4 = UVOffset.x + (vertices[i].z - min.z) / size.z;
							num5 = UVOffset.y + (vertices[i].x - min.x) / size.x;
						}
						else
						{
							if (!flag4)
							{
								throw new InvalidOperationException("Couldn't find the minimal bound dimension");
							}
							num4 = UVOffset.x + (vertices[i].x - min.x) / size.x;
							num5 = UVOffset.y + (vertices[i].y - min.y) / size.y;
						}
						num4 *= UVTiling.x;
						num5 *= UVTiling.y;
						num2 = ((!(num4 < num2)) ? num4 : num2);
						num3 = ((!(num5 < num3)) ? num5 : num3);
						array[i].x = num4;
						array[i].y = num5;
					}
					mMesh.uv = array;
					Vector2[] array2 = new Vector2[0];
					if (UV2)
					{
						array2 = new Vector2[array.Length];
						float num6 = 1f / num2;
						float num7 = 1f / num3;
						for (int j = 0; j < vertices.Length; j++)
						{
							array2[j].x = array[j].x * num6;
							array2[j].y = array[j].y * num7;
						}
					}
					mMesh.uv2 = array2;
				}
			}
			result = mMesh;
			return flag;
		}

		private bool triangulate()
		{
			if (Lines.Count == 0)
			{
				Error = "Missing splines to triangulate";
				return false;
			}
			if (VertexLineOnly)
			{
				return true;
			}
			mTess = new Tess();
			for (int i = 0; i < Lines.Count; i++)
			{
				if (Lines[i].Spline == null)
				{
					Error = "Missing Spline";
					return false;
				}
				if (!polyLineIsValid(Lines[i]))
				{
					Error = Lines[i].Spline.name + ": Angle must be >0";
					return false;
				}
				Vector3[] vertices = Lines[i].GetVertices();
				if (vertices.Length < 3)
				{
					Error = Lines[i].Spline.name + ": At least 3 Vertices needed!";
					return false;
				}
				mTess.AddContour(UnityLibTessUtility.ToContourVertex(vertices), Lines[i].Orientation);
			}
			try
			{
				mTess.Tessellate(Winding, ElementType.Polygons, 3);
				return true;
			}
			catch (Exception ex)
			{
				Error = ex.Message;
			}
			return false;
		}

		private static bool polyLineIsValid(SplinePolyLine pl)
		{
			return (pl != null && pl.VertexMode == SplinePolyLine.VertexCalculation.ByApproximation) || !Mathf.Approximately(0f, pl.Angle);
		}
	}
	[Serializable]
	public class SplinePolyLine
	{
		public enum VertexCalculation
		{
			ByApproximation,
			ByAngle
		}

		public ContourOrientation Orientation;

		public CurvySpline Spline;

		public VertexCalculation VertexMode;

		public float Angle;

		public float Distance;

		public Space Space;

		public bool IsClosed => (bool)Spline && Spline.Closed;

		public SplinePolyLine(CurvySpline spline)
			: this(spline, VertexCalculation.ByApproximation, 0f, 0f)
		{
		}

		public SplinePolyLine(CurvySpline spline, float angle, float distance)
			: this(spline, VertexCalculation.ByAngle, angle, distance)
		{
		}

		private SplinePolyLine(CurvySpline spline, VertexCalculation vertexMode, float angle, float distance, Space space = Space.World)
		{
			Spline = spline;
			VertexMode = vertexMode;
			Angle = angle;
			Distance = distance;
			Space = space;
		}

		public Vector3[] GetVertices()
		{
			Vector3[] array = new Vector3[0];
			VertexCalculation vertexMode = VertexMode;
			array = ((vertexMode != VertexCalculation.ByAngle) ? Spline.GetApproximation() : GetPolygon(Spline, 0f, 1f, Angle, Distance, -1f, out var _, out var _, includeEndPoint: false));
			if (Space == Space.World)
			{
				for (int i = 0; i < array.Length; i++)
				{
					ref Vector3 reference = ref array[i];
					reference = Spline.transform.TransformPoint(array[i]);
				}
			}
			return array;
		}

		private static Vector3[] GetPolygon(CurvySpline spline, float fromTF, float toTF, float maxAngle, float minDistance, float maxDistance, out List<float> vertexTF, out List<Vector3> vertexTangents, bool includeEndPoint = true, float stepSize = 0.01f)
		{
			stepSize = Mathf.Clamp(stepSize, 0.002f, 1f);
			maxDistance = ((maxDistance != -1f) ? Mathf.Clamp(maxDistance, 0f, spline.Length) : spline.Length);
			minDistance = Mathf.Clamp(minDistance, 0f, maxDistance);
			if (!spline.Closed)
			{
				toTF = Mathf.Clamp01(toTF);
				fromTF = Mathf.Clamp(fromTF, 0f, toTF);
			}
			List<Vector3> vPos = new List<Vector3>();
			List<Vector3> vTan = new List<Vector3>();
			List<float> vTF = new List<float>();
			int linearSteps = 0;
			float angleFromLast = 0f;
			float distAccu = 0f;
			Vector3 curPos = spline.Interpolate(fromTF);
			Vector3 curTangent = spline.GetTangent(fromTF);
			Vector3 vector = curPos;
			Vector3 vector2 = curTangent;
			Action<float> action = delegate(float f)
			{
				vPos.Add(curPos);
				vTan.Add(curTangent);
				vTF.Add(f);
				angleFromLast = 0f;
				distAccu = 0f;
				linearSteps = 0;
			};
			action(fromTF);
			float num = fromTF + stepSize;
			while (num < toTF)
			{
				float num2 = num % 1f;
				curPos = spline.Interpolate(num2);
				curTangent = spline.GetTangent(num2);
				if (curTangent == Vector3.zero)
				{
					Debug.Log("zero Tangent! Oh no!");
				}
				distAccu += (curPos - vector).magnitude;
				if (curTangent == vector2)
				{
					linearSteps++;
				}
				if (distAccu >= minDistance)
				{
					if (distAccu >= maxDistance)
					{
						action(num2);
					}
					else
					{
						angleFromLast += Vector3.Angle(vector2, curTangent);
						if (angleFromLast >= maxAngle || (linearSteps > 0 && angleFromLast > 0f))
						{
							action(num2);
						}
					}
				}
				num += stepSize;
				vector = curPos;
				vector2 = curTangent;
			}
			if (includeEndPoint)
			{
				vTF.Add(toTF % 1f);
				curPos = spline.Interpolate(toTF % 1f);
				vPos.Add(curPos);
				vTan.Add(spline.GetTangent(toTF % 1f, curPos));
			}
			vertexTF = vTF;
			vertexTangents = vTan;
			return vPos.ToArray();
		}
	}
}
namespace FluffyUnderware.Curvy.Shapes
{
	[CurvyShapeInfo("2D/Circle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Circle")]
	public class CSCircle : CurvyShape2D
	{
		[Positive(Tooltip = "Number of Control Points")]
		[SerializeField]
		private int m_Count = 4;

		[SerializeField]
		private float m_Radius = 1f;

		public int Count
		{
			get
			{
				return m_Count;
			}
			set
			{
				int num = Mathf.Max(2, value);
				if (m_Count != num)
				{
					m_Count = num;
					Dirty = true;
				}
			}
		}

		public float Radius
		{
			get
			{
				return m_Radius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Radius != num)
				{
					m_Radius = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Count = 4;
			Radius = 1f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			PrepareControlPoints(Count);
			float num = (float)Math.PI * 2f / (float)Count;
			for (int i = 0; i < Count; i++)
			{
				base.Spline.ControlPointsList[i].transform.localPosition = new Vector3(Mathf.Sin(num * (float)i) * Radius, Mathf.Cos(num * (float)i) * Radius, 0f);
			}
		}
	}
	[CurvyShapeInfo("2D/Pie", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Pie")]
	public class CSPie : CSCircle
	{
		public enum EatModeEnum
		{
			Left,
			Right,
			Center
		}

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Roundness = 1f;

		[SerializeField]
		[RangeEx(0f, "maxEmpty", "Empty", "Number of empty slices")]
		private int m_Empty = 1;

		[Label(Tooltip = "Eat Mode")]
		[SerializeField]
		private EatModeEnum m_Eat = EatModeEnum.Right;

		public float Roundness
		{
			get
			{
				return m_Roundness;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Roundness != num)
				{
					m_Roundness = num;
					Dirty = true;
				}
			}
		}

		public int Empty
		{
			get
			{
				return m_Empty;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, maxEmpty);
				if (m_Empty != num)
				{
					m_Empty = num;
					Dirty = true;
				}
			}
		}

		private int maxEmpty => base.Count;

		public EatModeEnum Eat
		{
			get
			{
				return m_Eat;
			}
			set
			{
				if (m_Eat != value)
				{
					m_Eat = value;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Roundness = 0.5f;
			Empty = 1;
			Eat = EatModeEnum.Right;
		}

		private Vector3 cpPosition(int i, int empty, float d)
		{
			return Eat switch
			{
				EatModeEnum.Left => new Vector3(Mathf.Sin(d * (float)i) * base.Radius, Mathf.Cos(d * (float)i) * base.Radius, 0f), 
				EatModeEnum.Right => new Vector3(Mathf.Sin(d * (float)(i + empty)) * base.Radius, Mathf.Cos(d * (float)(i + empty)) * base.Radius, 0f), 
				_ => new Vector3(Mathf.Sin(d * ((float)i + (float)empty * 0.5f)) * base.Radius, Mathf.Cos(d * ((float)i + (float)empty * 0.5f)) * base.Radius, 0f), 
			};
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier, CurvyOrientation.Static);
			PrepareControlPoints(base.Count - Empty + 2);
			float d = (float)Math.PI * 2f / (float)base.Count;
			float num = Roundness * 0.39f;
			for (int i = 0; i < base.Spline.ControlPointCount - 1; i++)
			{
				base.Spline.ControlPointsList[i].AutoHandles = true;
				base.Spline.ControlPointsList[i].AutoHandleDistance = num;
				SetPosition(i, cpPosition(i, Empty, d));
				SetRotation(i, Quaternion.Euler(90f, 0f, 0f));
			}
			SetPosition(base.Spline.ControlPointCount - 1, Vector3.zero);
			SetRotation(base.Spline.ControlPointCount - 1, Quaternion.Euler(90f, 0f, 0f));
			SetBezierHandles(base.Spline.ControlPointCount - 1, 0f);
			base.Spline.ControlPointsList[0].AutoHandles = false;
			base.Spline.ControlPointsList[0].HandleIn = Vector3.zero;
			base.Spline.ControlPointsList[0].SetBezierHandles(num, cpPosition(base.Count - 1, Empty, d) - base.Spline.ControlPointsList[0].transform.localPosition, cpPosition(1, Empty, d) - base.Spline.ControlPointsList[0].transform.localPosition, setIn: false);
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].AutoHandles = false;
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].HandleOut = Vector3.zero;
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].SetBezierHandles(num, cpPosition(base.Count - 1 - Empty, Empty, d) - base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].transform.localPosition, cpPosition(base.Count + 1 - Empty, Empty, d) - base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].transform.localPosition, setIn: true, setOut: false);
		}
	}
	[CurvyShapeInfo("2D/Rectangle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Rectangle")]
	public class CSRectangle : CurvyShape2D
	{
		[Positive]
		[SerializeField]
		private float m_Width = 1f;

		[Positive]
		[SerializeField]
		private float m_Height = 1f;

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Width != num)
				{
					m_Width = num;
					Dirty = true;
				}
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Height != num)
				{
					m_Height = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Width = 1f;
			Height = 1f;
		}

		protected override void ApplyShape()
		{
			base.ApplyShape();
			PrepareSpline(CurvyInterpolation.Linear, CurvyOrientation.Static, 1);
			PrepareControlPoints(4);
			float num = Width / 2f;
			float num2 = Height / 2f;
			SetCGHardEdges();
			SetPosition(0, new Vector3(0f - num, 0f - num2));
			SetPosition(1, new Vector3(0f - num, num2));
			SetPosition(2, new Vector3(num, num2));
			SetPosition(3, new Vector3(num, 0f - num2));
		}
	}
	[CurvyShapeInfo("2D/Rounded Rectangle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Rounded Rectangle")]
	public class CSRoundedRectangle : CurvyShape2D
	{
		[Positive]
		[SerializeField]
		private float m_Width = 1f;

		[Positive]
		[SerializeField]
		private float m_Height = 1f;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Roundness = 0.5f;

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Width != num)
				{
					m_Width = num;
					Dirty = true;
				}
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Height != num)
				{
					m_Height = num;
					Dirty = true;
				}
			}
		}

		public float Roundness
		{
			get
			{
				return m_Roundness;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Roundness != num)
				{
					m_Roundness = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Width = 1f;
			Height = 1f;
			Roundness = 0.5f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			PrepareControlPoints(8);
			float num = Width / 2f;
			float num2 = Height / 2f;
			float num3 = Mathf.Min(num, num2) * Roundness;
			SetPosition(0, new Vector3(0f - num, 0f - num2 + num3));
			SetPosition(1, new Vector3(0f - num, num2 - num3));
			SetPosition(2, new Vector3(0f - num + num3, num2));
			SetPosition(3, new Vector3(num - num3, num2));
			SetPosition(4, new Vector3(num, num2 - num3));
			SetPosition(5, new Vector3(num, 0f - num2 + num3));
			SetPosition(6, new Vector3(num - num3, 0f - num2));
			SetPosition(7, new Vector3(0f - num + num3, 0f - num2));
			SetBezierHandles(0, Vector3.down * num3, Vector3.zero, Space.Self);
			SetBezierHandles(1, Vector3.zero, Vector3.up * num3, Space.Self);
			SetBezierHandles(2, Vector3.left * num3, Vector3.right * num3, Space.Self);
			SetBezierHandles(3, Vector3.zero, Vector3.right * num3, Space.Self);
			SetBezierHandles(4, Vector3.up * num3, Vector3.zero, Space.Self);
			SetBezierHandles(5, Vector3.zero, Vector3.down * num3, Space.Self);
			SetBezierHandles(6, Vector3.right * num3, Vector3.zero, Space.Self);
			SetBezierHandles(7, Vector3.zero, Vector3.left * num3, Space.Self);
		}
	}
	[CurvyShapeInfo("3D/Spiral", false)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Spiral")]
	public class CSSpiral : CurvyShape2D
	{
		[Positive(Tooltip = "Number of Control Points per full Circle")]
		[SerializeField]
		private int m_Count = 8;

		[Positive(Tooltip = "Number of Full Circles")]
		[SerializeField]
		private float m_Circles = 3f;

		[Positive(Tooltip = "Base Radius")]
		[SerializeField]
		private float m_Radius = 5f;

		[Label(Tooltip = "Radius Multiplicator")]
		[SerializeField]
		private AnimationCurve m_RadiusFactor = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		private AnimationCurve m_Z = AnimationCurve.Linear(0f, 0f, 1f, 10f);

		public int Count
		{
			get
			{
				return m_Count;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_Count != num)
				{
					m_Count = num;
					Dirty = true;
				}
			}
		}

		public float Circles
		{
			get
			{
				return m_Circles;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Circles != num)
				{
					m_Circles = num;
					Dirty = true;
				}
			}
		}

		public float Radius
		{
			get
			{
				return m_Radius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Radius != num)
				{
					m_Radius = num;
					Dirty = true;
				}
			}
		}

		public AnimationCurve RadiusFactor
		{
			get
			{
				return m_RadiusFactor;
			}
			set
			{
				if (m_RadiusFactor != value)
				{
					m_RadiusFactor = value;
					Dirty = true;
				}
			}
		}

		public AnimationCurve Z
		{
			get
			{
				return m_Z;
			}
			set
			{
				if (m_Z != value)
				{
					m_Z = value;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Count = 8;
			Circles = 3f;
			Radius = 5f;
			RadiusFactor = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			Z = AnimationCurve.Linear(0f, 0f, 1f, 10f);
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.CatmullRom, CurvyOrientation.Dynamic, 50, closed: false);
			base.Spline.RestrictTo2D = false;
			int num = Mathf.FloorToInt((float)Count * Circles);
			PrepareControlPoints(num);
			if (num != 0)
			{
				float num2 = (float)Math.PI * 2f / (float)Count;
				for (int i = 0; i < num; i++)
				{
					float time = (float)i / (float)num;
					float num3 = Radius * RadiusFactor.Evaluate(time);
					SetPosition(i, new Vector3(Mathf.Sin(num2 * (float)i) * num3, Mathf.Cos(num2 * (float)i) * num3, m_Z.Evaluate(time)));
				}
			}
		}
	}
	[CurvyShapeInfo("2D/Star", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Star")]
	public class CSStar : CurvyShape2D
	{
		[SerializeField]
		[Positive(Tooltip = "Number of Sides", MinValue = 2f)]
		private int m_Sides = 5;

		[SerializeField]
		[Positive]
		private float m_OuterRadius = 2f;

		[SerializeField]
		[RangeEx(0f, 1f, "", "")]
		private float m_OuterRoundness;

		[SerializeField]
		[Positive]
		private float m_InnerRadius = 1f;

		[SerializeField]
		[RangeEx(0f, 1f, "", "")]
		private float m_InnerRoundness;

		public int Sides
		{
			get
			{
				return m_Sides;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_Sides != num)
				{
					m_Sides = num;
					Dirty = true;
				}
			}
		}

		public float OuterRadius
		{
			get
			{
				return m_OuterRadius;
			}
			set
			{
				float num = Mathf.Max(InnerRadius, value);
				if (m_OuterRadius != num)
				{
					m_OuterRadius = num;
					Dirty = true;
				}
			}
		}

		public float OuterRoundness
		{
			get
			{
				return m_OuterRoundness;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_OuterRoundness != num)
				{
					m_OuterRoundness = num;
					Dirty = true;
				}
			}
		}

		public float InnerRadius
		{
			get
			{
				return m_InnerRadius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_InnerRadius != num)
				{
					m_InnerRadius = num;
					Dirty = true;
				}
			}
		}

		public float InnerRoundness
		{
			get
			{
				return m_InnerRoundness;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_InnerRoundness != num)
				{
					m_InnerRoundness = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Sides = 5;
			OuterRadius = 2f;
			OuterRoundness = 0f;
			InnerRadius = 1f;
			InnerRoundness = 0f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			PrepareControlPoints(Sides * 2);
			float num = (float)Math.PI * 2f / (float)base.Spline.ControlPointCount;
			for (int i = 0; i < base.Spline.ControlPointCount; i += 2)
			{
				Vector3 vector = new Vector3(Mathf.Sin(num * (float)i), Mathf.Cos(num * (float)i), 0f);
				SetPosition(i, vector * OuterRadius);
				base.Spline.ControlPointsList[i].AutoHandleDistance = OuterRoundness;
				vector = new Vector3(Mathf.Sin(num * (float)(i + 1)), Mathf.Cos(num * (float)(i + 1)), 0f);
				SetPosition(i + 1, vector * InnerRadius);
				base.Spline.ControlPointsList[i + 1].AutoHandleDistance = InnerRoundness;
			}
		}
	}
}
namespace FluffyUnderware.Curvy.Components
{
	[HelpURL("https://curvyeditor.com/doclink/curvyglrenderer")]
	[AddComponentMenu("Curvy/Misc/Curvy GL Renderer")]
	public class CurvyGLRenderer : MonoBehaviour
	{
		[ArrayEx(ShowAdd = false, Draggable = false)]
		public List<GLSlotData> Splines = new List<GLSlotData>();

		private Material lineMaterial;

		private void CreateLineMaterial()
		{
			if (!lineMaterial)
			{
				lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));
				lineMaterial.hideFlags = HideFlags.HideAndDontSave;
				lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
			}
		}

		private void OnPostRender()
		{
			sanitize();
			CreateLineMaterial();
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				Splines[num].Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
				if (Splines[num].VertexData.Count == 0)
				{
					Splines[num].GetVertexData();
				}
				Splines[num].Render(lineMaterial);
			}
		}

		private void sanitize()
		{
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				if (Splines[num] == null || Splines[num].Spline == null)
				{
					Splines.RemoveAt(num);
				}
			}
		}

		private void OnSplineRefresh(CurvySplineEventArgs e)
		{
			GLSlotData slot = getSlot((CurvySpline)e.Sender);
			if (slot == null)
			{
				((CurvySpline)e.Sender).OnRefresh.RemoveListener(OnSplineRefresh);
			}
			else
			{
				slot.VertexData.Clear();
			}
		}

		private GLSlotData getSlot(CurvySpline spline)
		{
			if ((bool)spline)
			{
				foreach (GLSlotData spline2 in Splines)
				{
					if (spline2.Spline == spline)
					{
						return spline2;
					}
				}
			}
			return null;
		}

		public void Add(CurvySpline spline)
		{
			if (spline != null)
			{
				Splines.Add(new GLSlotData
				{
					Spline = spline
				});
			}
		}

		public void Remove(CurvySpline spline)
		{
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				if (Splines[num].Spline == spline)
				{
					Splines.RemoveAt(num);
				}
			}
		}
	}
	[Serializable]
	public class GLSlotData
	{
		[SerializeField]
		public CurvySpline Spline;

		public Color LineColor = CurvyGlobalManager.DefaultGizmoColor;

		public List<Vector3[]> VertexData = new List<Vector3[]>();

		public void GetVertexData()
		{
			VertexData.Clear();
			List<CurvySpline> list = new List<CurvySpline>();
			list.Add(Spline);
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].IsInitialized)
				{
					VertexData.Add(list[i].GetApproximation(Space.World));
				}
			}
		}

		public void Render(Material mat)
		{
			for (int i = 0; i < VertexData.Count; i++)
			{
				if (VertexData[i].Length > 0)
				{
					mat.SetPass(0);
					GL.Begin(1);
					GL.Color(LineColor);
					for (int j = 1; j < VertexData[i].Length; j++)
					{
						GL.Vertex(VertexData[i][j - 1]);
						GL.Vertex(VertexData[i][j]);
					}
					GL.End();
				}
			}
		}
	}
	[AddComponentMenu("Curvy/Misc/Curvy Line Renderer")]
	[RequireComponent(typeof(LineRenderer))]
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvylinerenderer")]
	public class CurvyLineRenderer : MonoBehaviour
	{
		public CurvySpline m_Spline;

		private LineRenderer mRenderer;

		public CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					unbindEvents();
					m_Spline = value;
					bindEvents();
					Refresh();
				}
			}
		}

		private void Awake()
		{
			mRenderer = GetComponent<LineRenderer>();
			if (m_Spline == null)
			{
				m_Spline = GetComponent<CurvySpline>();
			}
		}

		private void OnEnable()
		{
			mRenderer = GetComponent<LineRenderer>();
			bindEvents();
		}

		private void OnDisable()
		{
			unbindEvents();
		}

		private void Start()
		{
			Refresh();
		}

		public void Refresh()
		{
			if ((bool)Spline && Spline.IsInitialized)
			{
				Vector3[] approximation = Spline.GetApproximation();
				mRenderer.positionCount = approximation.Length;
				mRenderer.SetPositions(approximation);
			}
			else if (mRenderer != null)
			{
				mRenderer.positionCount = 0;
			}
		}

		private void OnSplineRefresh(CurvySplineEventArgs e)
		{
			Refresh();
		}

		private void bindEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
			}
		}

		private void unbindEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.RemoveListener(OnSplineRefresh);
			}
		}
	}
}
namespace FluffyUnderware.Curvy.Controllers
{
	public abstract class ConnectedControlPointsSelector : MonoBehaviour
	{
		public abstract CurvySplineSegment SelectConnectedControlPoint(SplineController caller, CurvyConnection connection, CurvySplineSegment currentControlPoint);
	}
	[Serializable]
	public class ControllerEvent : UnityEventEx<CurvyController>
	{
	}
	public class CurvyControllerEventArgs : CurvyEventArgs
	{
		public readonly CurvyController Controller;

		public CurvyControllerEventArgs(MonoBehaviour sender, CurvyController controller)
			: base(sender, null)
		{
			Controller = controller;
		}
	}
	[Serializable]
	public class CurvySplineMoveEvent : UnityEventEx<CurvySplineMoveEventArgs>
	{
	}
	public class CurvySplineMoveEventArgs : CancelEventArgs
	{
		public SplineController Sender { get; private set; }

		public CurvySpline Spline { get; private set; }

		public CurvySplineSegment ControlPoint { get; private set; }

		public bool WorldUnits { get; private set; }

		public MovementDirection MovementDirection { get; private set; }

		public float Delta { get; private set; }

		public float Position { get; private set; }

		public CurvySplineMoveEventArgs(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, bool usingWorldUnits, float delta, MovementDirection direction)
		{
			Set_INTERNAL(sender, spline, controlPoint, position, delta, direction, usingWorldUnits);
		}

		internal void Set_INTERNAL(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, float delta, MovementDirection direction, bool usingWorldUnits)
		{
			Sender = sender;
			Spline = spline;
			ControlPoint = controlPoint;
			MovementDirection = direction;
			Delta = delta;
			Position = position;
			WorldUnits = usingWorldUnits;
			base.Cancel = false;
		}
	}
	[ExecuteInEditMode]
	public abstract class CurvyController : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
	{
		public enum MoveModeEnum
		{
			Relative,
			AbsolutePrecise
		}

		public enum CurvyControllerState
		{
			Stopped,
			Playing,
			Paused
		}

		[Section("General", true, false, 100, Sort = 0, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_general")]
		[Label(Tooltip = "Determines when to update")]
		public CurvyUpdateMethod UpdateIn;

		[Section("Position", true, false, 100, Sort = 100, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_position")]
		[SerializeField]
		private CurvyPositionMode m_PositionMode;

		[RangeEx(0f, "maxPosition", "", "")]
		[SerializeField]
		[FormerlySerializedAs("m_InitialPosition")]
		protected float m_Position;

		[Section("Move", true, false, 100, Sort = 200, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_move")]
		[SerializeField]
		private MoveModeEnum m_MoveMode = MoveModeEnum.AbsolutePrecise;

		[Positive]
		[SerializeField]
		private float m_Speed;

		[SerializeField]
		private MovementDirection m_Direction;

		[SerializeField]
		private CurvyClamping m_Clamping = CurvyClamping.Loop;

		[SerializeField]
		[Tooltip("Start playing automatically when entering play mode")]
		private bool m_PlayAutomatically = true;

		[Section("Orientation", true, false, 100, Sort = 300, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_orientation")]
		[Label("Source", "Source Vector")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private OrientationModeEnum m_OrientationMode = OrientationModeEnum.Orientation;

		[Label("Lock Rotation", "When set, the controller will enforce the rotation to not change")]
		[SerializeField]
		private bool m_LockRotation = true;

		[Label("Target", "Target Vector3")]
		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private OrientationAxisEnum m_OrientationAxis;

		[Tooltip("Should the orientation ignore the movement direction?")]
		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private bool m_IgnoreDirection;

		[Min(0f, "Direction Damping Time", "If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_DampingDirection;

		[Min(0f, "Up Damping Time", "If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_DampingUp;

		[Section("Offset", true, false, 100, Sort = 400, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_orientation")]
		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOffsetSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[RangeEx(-180f, 180f, "", "")]
		[SerializeField]
		private float m_OffsetAngle;

		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOffsetSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_OffsetRadius;

		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOffsetSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[Label("Compensate Offset", "")]
		[SerializeField]
		private bool m_OffsetCompensation = true;

		[Section("Events", true, false, 100, Sort = 500)]
		[SerializeField]
		private ControllerEvent onInitialized;

		protected const string ControllerNotReadyMessage = "The controller is not yet ready";

		private CurvyControllerState state;

		private Vector3 directionDampingVelocity;

		private Vector3 upDampingVelocity;

		private float prePlayPosition;

		private Quaternion lockedRotation;

		private MovementDirection prePlayDirection;

		public ControllerEvent OnInitialized => onInitialized;

		public CurvyPositionMode PositionMode
		{
			get
			{
				return m_PositionMode;
			}
			set
			{
				m_PositionMode = value;
			}
		}

		public MoveModeEnum MoveMode
		{
			get
			{
				return m_MoveMode;
			}
			set
			{
				if (m_MoveMode != value)
				{
					m_MoveMode = value;
				}
			}
		}

		public bool PlayAutomatically
		{
			get
			{
				return m_PlayAutomatically;
			}
			set
			{
				if (m_PlayAutomatically != value)
				{
					m_PlayAutomatically = value;
				}
			}
		}

		public CurvyClamping Clamping
		{
			get
			{
				return m_Clamping;
			}
			set
			{
				if (m_Clamping != value)
				{
					m_Clamping = value;
				}
			}
		}

		public OrientationModeEnum OrientationMode
		{
			get
			{
				return m_OrientationMode;
			}
			set
			{
				if (m_OrientationMode != value)
				{
					m_OrientationMode = value;
				}
			}
		}

		public bool LockRotation
		{
			get
			{
				return m_LockRotation;
			}
			set
			{
				if (m_LockRotation != value)
				{
					m_LockRotation = value;
				}
				if (m_LockRotation)
				{
					lockedRotation = Transform.rotation;
				}
			}
		}

		public OrientationAxisEnum OrientationAxis
		{
			get
			{
				return m_OrientationAxis;
			}
			set
			{
				if (m_OrientationAxis != value)
				{
					m_OrientationAxis = value;
				}
			}
		}

		public float DirectionDampingTime
		{
			get
			{
				return m_DampingDirection;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_DampingDirection != num)
				{
					m_DampingDirection = num;
				}
			}
		}

		public float UpDampingTime
		{
			get
			{
				return m_DampingUp;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_DampingUp != num)
				{
					m_DampingUp = num;
				}
			}
		}

		public bool IgnoreDirection
		{
			get
			{
				return m_IgnoreDirection;
			}
			set
			{
				if (m_IgnoreDirection != value)
				{
					m_IgnoreDirection = value;
				}
			}
		}

		public float OffsetAngle
		{
			get
			{
				return m_OffsetAngle;
			}
			set
			{
				if (m_OffsetAngle != value)
				{
					m_OffsetAngle = value;
				}
			}
		}

		public float OffsetRadius
		{
			get
			{
				return m_OffsetRadius;
			}
			set
			{
				if (m_OffsetRadius != value)
				{
					m_OffsetRadius = value;
				}
			}
		}

		public bool OffsetCompensation
		{
			get
			{
				return m_OffsetCompensation;
			}
			set
			{
				m_OffsetCompensation = value;
			}
		}

		public float Speed
		{
			get
			{
				return m_Speed;
			}
			set
			{
				if (value < 0f)
				{
					value = 0f - value;
				}
				m_Speed = value;
			}
		}

		public float RelativePosition
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length), 
					CurvyPositionMode.WorldUnits => AbsoluteToRelative(GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length)), 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				float clampedPosition = GetClampedPosition(value, CurvyPositionMode.Relative, Clamping, Length);
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					m_Position = clampedPosition;
					break;
				case CurvyPositionMode.WorldUnits:
					m_Position = RelativeToAbsolute(clampedPosition);
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
		}

		public float AbsolutePosition
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => RelativeToAbsolute(GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length)), 
					CurvyPositionMode.WorldUnits => GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length), 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				float clampedPosition = GetClampedPosition(value, CurvyPositionMode.WorldUnits, Clamping, Length);
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					m_Position = AbsoluteToRelative(clampedPosition);
					break;
				case CurvyPositionMode.WorldUnits:
					m_Position = clampedPosition;
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
		}

		public float Position
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => RelativePosition, 
					CurvyPositionMode.WorldUnits => AbsolutePosition, 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					RelativePosition = value;
					break;
				case CurvyPositionMode.WorldUnits:
					AbsolutePosition = value;
					break;
				default:
					throw new NotSupportedException();
				}
			}
		}

		public MovementDirection MovementDirection
		{
			get
			{
				return m_Direction;
			}
			set
			{
				m_Direction = value;
			}
		}

		public CurvyControllerState PlayState => state;

		public abstract bool IsReady { get; }

		protected bool isInitialized { get; private set; }

		public virtual Transform Transform => base.transform;

		protected virtual bool ShowOrientationSection => true;

		protected virtual bool ShowOffsetSection => true;

		public abstract float Length { get; }

		private float TimeSinceLastUpdate => Time.deltaTime;

		private float maxPosition => PositionMode switch
		{
			CurvyPositionMode.Relative => 1f, 
			CurvyPositionMode.WorldUnits => (!IsReady) ? 0f : Length, 
			_ => throw new NotSupportedException(), 
		};

		protected virtual void OnEnable()
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
				InitializedApplyDeltaTime(0f);
			}
		}

		protected virtual void Start()
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
				InitializedApplyDeltaTime(0f);
			}
			if (PlayAutomatically && Application.isPlaying)
			{
				Play();
			}
		}

		protected virtual void OnDisable()
		{
			if (isInitialized)
			{
				Deinitialize();
			}
		}

		protected virtual void Update()
		{
			if (UpdateIn == CurvyUpdateMethod.Update)
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void LateUpdate()
		{
			if (UpdateIn == CurvyUpdateMethod.LateUpdate || (!Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate))
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void FixedUpdate()
		{
			if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void Reset()
		{
			UpdateIn = CurvyUpdateMethod.Update;
			PositionMode = CurvyPositionMode.Relative;
			m_Position = 0f;
			PlayAutomatically = true;
			MoveMode = MoveModeEnum.AbsolutePrecise;
			Speed = 0f;
			LockRotation = true;
			Clamping = CurvyClamping.Loop;
			OrientationMode = OrientationModeEnum.Orientation;
			OrientationAxis = OrientationAxisEnum.Up;
			IgnoreDirection = false;
		}

		protected virtual void InitializedApplyDeltaTime(float deltaTime)
		{
			if (state == CurvyControllerState.Playing && Speed * deltaTime != 0f)
			{
				float num = ((!OffsetCompensation) ? Speed : ComputeOffsetCompensatedSpeed(deltaTime));
				if (num * deltaTime != 0f)
				{
					Advance(num, deltaTime);
				}
			}
			Vector3 position = Transform.position;
			Quaternion rotation = Transform.rotation;
			ComputeTargetPositionAndRotation(out var targetPosition, out var targetUp, out var targetForward);
			Vector3 forward = ((!(DirectionDampingTime > 0f) || state != CurvyControllerState.Playing) ? targetForward : ((!(deltaTime > 0f)) ? Transform.forward : Vector3.SmoothDamp(Transform.forward, targetForward, ref directionDampingVelocity, DirectionDampingTime, float.PositiveInfinity, deltaTime)));
			Vector3 upwards = ((!(UpDampingTime > 0f) || state != CurvyControllerState.Playing) ? targetUp : ((!(deltaTime > 0f)) ? Transform.up : Vector3.SmoothDamp(Transform.up, targetUp, ref upDampingVelocity, UpDampingTime, float.PositiveInfinity, deltaTime)));
			Transform.rotation = Quaternion.LookRotation(forward, upwards);
			Transform.position = targetPosition;
			if (position.NotApproximately(Transform.position) || rotation.DifferentOrientation(Transform.rotation))
			{
				UserAfterUpdate();
			}
		}

		protected virtual void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
		{
			GetInterpolatedSourcePosition(RelativePosition, out var interpolatedPosition, out var tangent, out var up);
			if (tangent == Vector3.zero || up == Vector3.zero)
			{
				GetOrientationNoneUpAndForward(out targetUp, out targetForward);
			}
			else
			{
				switch (OrientationMode)
				{
				case OrientationModeEnum.None:
					GetOrientationNoneUpAndForward(out targetUp, out targetForward);
					break;
				case OrientationModeEnum.Orientation:
				{
					Vector3 vector2 = ((m_Direction != MovementDirection.Backward || IgnoreDirection) ? tangent : (-tangent));
					switch (OrientationAxis)
					{
					case OrientationAxisEnum.Up:
						targetUp = up;
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Down:
						targetUp = -up;
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Forward:
						targetUp = -vector2;
						targetForward = up;
						break;
					case OrientationAxisEnum.Backward:
						targetUp = vector2;
						targetForward = -up;
						break;
					case OrientationAxisEnum.Left:
						targetUp = Vector3.Cross(up, vector2);
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Right:
						targetUp = Vector3.Cross(vector2, up);
						targetForward = vector2;
						break;
					default:
						throw new NotSupportedException();
					}
					break;
				}
				case OrientationModeEnum.Tangent:
				{
					Vector3 vector = ((m_Direction != MovementDirection.Backward || IgnoreDirection) ? tangent : (-tangent));
					switch (OrientationAxis)
					{
					case OrientationAxisEnum.Up:
						targetUp = vector;
						targetForward = -up;
						break;
					case OrientationAxisEnum.Down:
						targetUp = -vector;
						targetForward = up;
						break;
					case OrientationAxisEnum.Forward:
						targetUp = up;
						targetForward = vector;
						break;
					case OrientationAxisEnum.Backward:
						targetUp = up;
						targetForward = -vector;
						break;
					case OrientationAxisEnum.Left:
						targetUp = up;
						targetForward = Vector3.Cross(up, vector);
						break;
					case OrientationAxisEnum.Right:
						targetUp = up;
						targetForward = Vector3.Cross(vector, up);
						break;
					default:
						throw new NotSupportedException();
					}
					break;
				}
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
			targetPosition = ApplyOffset(interpolatedPosition, tangent, up, OffsetAngle, OffsetRadius);
		}

		private void GetOrientationNoneUpAndForward(out Vector3 targetUp, out Vector3 targetForward)
		{
			if (LockRotation)
			{
				targetUp = lockedRotation * Vector3.up;
				targetForward = lockedRotation * Vector3.forward;
			}
			else
			{
				targetUp = Transform.up;
				targetForward = Transform.forward;
			}
		}

		protected virtual void Initialize()
		{
			isInitialized = true;
			lockedRotation = Transform.rotation;
			directionDampingVelocity = (upDampingVelocity = Vector3.zero);
			BindEvents();
			UserAfterInit();
			onInitialized.Invoke(this);
		}

		protected virtual void Deinitialize()
		{
			UnbindEvents();
			isInitialized = false;
		}

		protected virtual void BindEvents()
		{
		}

		protected virtual void UnbindEvents()
		{
		}

		protected virtual void SavePrePlayState()
		{
			prePlayPosition = m_Position;
			prePlayDirection = m_Direction;
		}

		protected virtual void RestorePrePlayState()
		{
			m_Position = prePlayPosition;
			m_Direction = prePlayDirection;
		}

		protected virtual void UserAfterInit()
		{
		}

		protected virtual void UserAfterUpdate()
		{
		}

		protected abstract void Advance(float speed, float deltaTime);

		protected abstract void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime);

		protected abstract float AbsoluteToRelative(float worldUnitDistance);

		protected abstract float RelativeToAbsolute(float relativeDistance);

		protected abstract Vector3 GetInterpolatedSourcePosition(float tf);

		protected abstract void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up);

		protected abstract Vector3 GetOrientation(float tf);

		protected abstract Vector3 GetTangent(float tf);

		public void Play()
		{
			if (PlayState == CurvyControllerState.Stopped)
			{
				SavePrePlayState();
			}
			state = CurvyControllerState.Playing;
		}

		public void Stop()
		{
			if (PlayState != 0)
			{
				RestorePrePlayState();
			}
			state = CurvyControllerState.Stopped;
		}

		public void Pause()
		{
			if (PlayState == CurvyControllerState.Playing)
			{
				state = CurvyControllerState.Paused;
			}
		}

		public void Refresh()
		{
			ApplyDeltaTime(0f);
		}

		public void ApplyDeltaTime(float deltaTime)
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
			}
			else if (isInitialized && !IsReady)
			{
				Deinitialize();
			}
			if (isInitialized)
			{
				InitializedApplyDeltaTime(deltaTime);
			}
		}

		public void TeleportTo(float newPosition)
		{
			float distance = Mathf.Abs(Position - newPosition);
			MovementDirection direction = ((!(Position < newPosition)) ? MovementDirection.Backward : MovementDirection.Forward);
			TeleportBy(distance, direction);
		}

		public void TeleportBy(float distance, MovementDirection direction)
		{
			float speed = Speed;
			MovementDirection movementDirection = MovementDirection;
			Speed = Mathf.Abs(distance) * 1000f;
			MovementDirection = direction;
			ApplyDeltaTime(0.001f);
			Speed = speed;
			MovementDirection = movementDirection;
		}

		public void SetFromString(string fieldAndValue)
		{
			string[] array = fieldAndValue.Split('=');
			if (array.Length != 2)
			{
				return;
			}
			FieldInfo fieldInfo = GetType().FieldByName(array[0], includeInherited: true);
			if (fieldInfo != null)
			{
				try
				{
					if (fieldInfo.FieldType.IsEnum)
					{
						fieldInfo.SetValue(this, Enum.Parse(fieldInfo.FieldType, array[1]));
					}
					else
					{
						fieldInfo.SetValue(this, Convert.ChangeType(array[1], fieldInfo.FieldType, CultureInfo.InvariantCulture));
					}
					return;
				}
				catch (Exception ex)
				{
					Debug.LogWarning(base.name + ".SetFromString(): " + ex.ToString());
					return;
				}
			}
			PropertyInfo propertyInfo = GetType().PropertyByName(array[0], includeInherited: true);
			if (propertyInfo == null)
			{
				return;
			}
			try
			{
				if (propertyInfo.PropertyType.IsEnum)
				{
					propertyInfo.SetValue(this, Enum.Parse(propertyInfo.PropertyType, array[1]), null);
				}
				else
				{
					propertyInfo.SetValue(this, Convert.ChangeType(array[1], propertyInfo.PropertyType, CultureInfo.InvariantCulture), null);
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning(base.name + ".SetFromString(): " + ex2.ToString());
			}
		}

		private static Vector3 ApplyOffset(Vector3 pos, Vector3 tan, Vector3 up, float angle, float radius)
		{
			Quaternion quaternion = Quaternion.AngleAxis(angle, tan);
			return pos + quaternion * up * radius;
		}

		protected static float GetClampedPosition(float position, CurvyPositionMode positionMode, CurvyClamping clampingMode, float length)
		{
			return positionMode switch
			{
				CurvyPositionMode.Relative => CurvyUtility.ClampTF(position, clampingMode), 
				CurvyPositionMode.WorldUnits => CurvyUtility.ClampDistance(position, clampingMode, length), 
				_ => throw new NotSupportedException(), 
			};
		}

		private float ComputeOffsetCompensatedSpeed(float deltaTime)
		{
			if (OrientationMode == OrientationModeEnum.None || OffsetRadius.Approximately(0f))
			{
				return Speed;
			}
			GetInterpolatedSourcePosition(RelativePosition, out var interpolatedPosition, out var tangent, out var up);
			Vector3 vector = ApplyOffset(interpolatedPosition, tangent, up, OffsetAngle, OffsetRadius);
			float tf = RelativePosition;
			MovementDirection curyDirection = m_Direction;
			SimulateAdvance(ref tf, ref curyDirection, Speed, deltaTime);
			GetInterpolatedSourcePosition(tf, out var interpolatedPosition2, out var tangent2, out var up2);
			Vector3 vector2 = ApplyOffset(interpolatedPosition2, tangent2, up2, OffsetAngle, OffsetRadius);
			float magnitude = (interpolatedPosition2 - interpolatedPosition).magnitude;
			float magnitude2 = (vector - vector2).magnitude;
			float num = magnitude / magnitude2;
			return Speed * ((!float.IsNaN(num)) ? num : 1f);
		}

		public virtual void OnAfterDeserialize()
		{
			if (m_Speed < 0f)
			{
				m_Speed = Mathf.Abs(m_Speed);
				m_Direction = MovementDirection.Backward;
			}
			if ((short)MoveMode == 2)
			{
				MoveMode = MoveModeEnum.AbsolutePrecise;
			}
		}

		public void OnBeforeSerialize()
		{
		}
	}
	public enum MovementDirection
	{
		Forward,
		Backward
	}
	public static class MovementDirectionMethods
	{
		public static MovementDirection FromInt(int value)
		{
			return (value < 0) ? MovementDirection.Backward : MovementDirection.Forward;
		}

		public static MovementDirection GetOpposite(this MovementDirection value)
		{
			return value switch
			{
				MovementDirection.Forward => MovementDirection.Backward, 
				MovementDirection.Backward => MovementDirection.Forward, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		public static int ToInt(this MovementDirection direction)
		{
			return direction switch
			{
				MovementDirection.Forward => 1, 
				MovementDirection.Backward => -1, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}
	}
	[AddComponentMenu("Curvy/Controller/CG Path Controller", 7)]
	[HelpURL("https://curvyeditor.com/doclink/pathcontroller")]
	public class PathController : CurvyController
	{
		[Section("General", true, false, 100, Sort = 0)]
		[SerializeField]
		[CGDataReferenceSelector(typeof(CGPath), Label = "Path/Slot")]
		private CGDataReference m_Path = new CGDataReference();

		public CGDataReference Path
		{
			get
			{
				return m_Path;
			}
			set
			{
				m_Path = value;
			}
		}

		public CGPath PathData => (!Path.HasValue) ? null : Path.GetData<CGPath>();

		public override float Length => (PathData == null) ? 0f : PathData.Length;

		public override bool IsReady => Path != null && !Path.IsEmpty && Path.HasValue;

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			return (PathData == null) ? 0f : PathData.FToDistance(relativeDistance);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			return (PathData == null) ? 0f : PathData.DistanceToF(worldUnitDistance);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			return Path.Module.Generator.transform.TransformPoint(PathData.InterpolatePosition(tf));
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			PathData.Interpolate(tf, out interpolatedPosition, out tangent, out up);
			Transform transform = Path.Module.Generator.transform;
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateDirection(tf));
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateUp(tf));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float tf = base.RelativePosition;
			MovementDirection curyDirection = base.MovementDirection;
			SimulateAdvance(ref tf, ref curyDirection, speed, deltaTime);
			base.MovementDirection = curyDirection;
			base.RelativePosition = tf;
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			int direction = curyDirection.ToInt();
			switch (base.MoveMode)
			{
			case MoveModeEnum.Relative:
				PathData.Move(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			case MoveModeEnum.AbsolutePrecise:
				PathData.MoveBy(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			default:
				throw new NotSupportedException();
			}
			curyDirection = MovementDirectionMethods.FromInt(direction);
		}
	}
	public enum SplineControllerConnectionBehavior
	{
		CurrentSpline,
		FollowUpSpline,
		RandomSpline,
		FollowUpOtherwiseRandom,
		Custom
	}
	[AddComponentMenu("Curvy/Controller/Spline Controller", 5)]
	[HelpURL("https://curvyeditor.com/doclink/splinecontroller")]
	public class SplineController : CurvyController
	{
		[Section("General", true, false, 100, Sort = 0)]
		[FieldCondition("m_Spline", null, false, ActionAttribute.ActionEnum.ShowError, "Missing source Spline", ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		protected CurvySpline m_Spline;

		[SerializeField]
		[Tooltip("Whether spline's cache data should be used. Set this to true to gain performance if precision is not required.")]
		private bool m_UseCache;

		[Section("Connections handling", true, false, 100, Sort = 250, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_move")]
		[SerializeField]
		[Label("At connection, use", "What spline should the controller use when reaching a Connection")]
		private SplineControllerConnectionBehavior connectionBehavior;

		[SerializeField]
		[Label("Allow direction change", "When true, the controller will modify its direction to best fit the connected spline")]
		private bool allowDirectionChange = true;

		[SerializeField]
		[Label("Reject current spline", "Whether the current spline should be excluded from the randomly selected splines")]
		[FieldCondition("ShowRandomConnectionOptions", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private bool rejectCurrentSpline = true;

		[SerializeField]
		[Label("Reject divergent splines", "Whether splines that diverge from the current spline with more than a specific angle should be excluded from the randomly selected splines")]
		[FieldCondition("ShowRandomConnectionOptions", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private bool rejectTooDivergentSplines;

		[SerializeField]
		[Label("Max allowed angle", "Maximum allowed divergence angle in degrees")]
		[Range(0f, 180f)]
		private float maxAllowedDivergenceAngle = 90f;

		[SerializeField]
		[Label("Custom Selector", "A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior")]
		[FieldCondition("connectionBehavior", SplineControllerConnectionBehavior.Custom, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[FieldCondition("connectionCustomSelector", null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing custom selector", ActionAttribute.ActionPositionEnum.Below)]
		private ConnectedControlPointsSelector connectionCustomSelector;

		[Section("Events", false, false, 1000, HelpURL = "https://curvyeditor.com/doclink/splinecontroller_events")]
		[SerializeField]
		private CurvySplineMoveEvent m_OnControlPointReached;

		[SerializeField]
		private CurvySplineMoveEvent m_OnEndReached;

		[SerializeField]
		private CurvySplineMoveEvent m_OnSwitch;

		private const float StepSize = 0.002f;

		private CurvySpline prePlaySpline;

		private float switchStartTime;

		private float switchDuration;

		private CurvySpline switchTarget;

		private float tfOnSwitchTarget;

		private MovementDirection directionOnSwitchTarget;

		private readonly CurvySplineMoveEventArgs preAllocatedEventArgs;

		public virtual CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				m_Spline = value;
			}
		}

		public bool UseCache
		{
			get
			{
				return m_UseCache;
			}
			set
			{
				if (m_UseCache != value)
				{
					m_UseCache = value;
				}
			}
		}

		public SplineControllerConnectionBehavior ConnectionBehavior
		{
			get
			{
				return connectionBehavior;
			}
			set
			{
				connectionBehavior = value;
			}
		}

		public ConnectedControlPointsSelector ConnectionCustomSelector
		{
			get
			{
				return connectionCustomSelector;
			}
			set
			{
				connectionCustomSelector = value;
			}
		}

		public bool AllowDirectionChange
		{
			get
			{
				return allowDirectionChange;
			}
			set
			{
				allowDirectionChange = value;
			}
		}

		public bool RejectCurrentSpline
		{
			get
			{
				return rejectCurrentSpline;
			}
			set
			{
				rejectCurrentSpline = value;
			}
		}

		public bool RejectTooDivergentSplines
		{
			get
			{
				return rejectTooDivergentSplines;
			}
			set
			{
				rejectTooDivergentSplines = value;
			}
		}

		public float MaxAllowedDivergenceAngle
		{
			get
			{
				return maxAllowedDivergenceAngle;
			}
			set
			{
				maxAllowedDivergenceAngle = value;
			}
		}

		public CurvySplineMoveEvent OnControlPointReached
		{
			get
			{
				return m_OnControlPointReached;
			}
			set
			{
				m_OnControlPointReached = value;
			}
		}

		public CurvySplineMoveEvent OnEndReached
		{
			get
			{
				return m_OnEndReached;
			}
			set
			{
				m_OnEndReached = value;
			}
		}

		public CurvySplineMoveEvent OnSwitch
		{
			get
			{
				return m_OnSwitch;
			}
			set
			{
				m_OnSwitch = value;
			}
		}

		public bool IsSwitching { get; private set; }

		public override float Length => (!Spline) ? 0f : Spline.Length;

		private float SwitchProgress => (!IsSwitching) ? 0f : Mathf.Clamp01((Time.time - switchStartTime) / switchDuration);

		public override bool IsReady => Spline != null && Spline.IsInitialized;

		private bool ShowRandomConnectionOptions => ConnectionBehavior == SplineControllerConnectionBehavior.FollowUpOtherwiseRandom || ConnectionBehavior == SplineControllerConnectionBehavior.RandomSpline;

		public SplineController()
		{
			preAllocatedEventArgs = new CurvySplineMoveEventArgs(this, Spline, null, float.NaN, usingWorldUnits: false, float.NaN, MovementDirection.Forward);
		}

		public virtual void SwitchTo(CurvySpline destinationSpline, float destinationTf, float duration)
		{
			if (base.PlayState == CurvyControllerState.Stopped)
			{
				DTLog.LogError("[Curvy] Contoller can not switch when stopped. The switch call will be ignored");
				return;
			}
			switchStartTime = Time.time;
			switchDuration = duration;
			switchTarget = destinationSpline;
			tfOnSwitchTarget = destinationTf;
			directionOnSwitchTarget = base.MovementDirection;
			IsSwitching = true;
		}

		public void FinishCurrentSwitch()
		{
			if (IsSwitching)
			{
				IsSwitching = false;
				Spline = switchTarget;
				base.RelativePosition = tfOnSwitchTarget;
			}
		}

		public void CancelCurrentSwitch()
		{
			if (IsSwitching)
			{
				IsSwitching = false;
			}
		}

		public static float GetAngleBetweenConnectedSplines(CurvySplineSegment before, MovementDirection movementMode, CurvySplineSegment after, bool allowMovementModeChange)
		{
			Vector3 from = before.GetTangentFast(0f) * movementMode.ToInt();
			Vector3 to = after.GetTangentFast(0f) * GetPostConnectionDirection(after, movementMode, allowMovementModeChange).ToInt();
			return Vector3.Angle(from, to);
		}

		protected override void SavePrePlayState()
		{
			prePlaySpline = Spline;
			base.SavePrePlayState();
		}

		protected override void RestorePrePlayState()
		{
			Spline = prePlaySpline;
			base.RestorePrePlayState();
		}

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			return Spline.TFToDistance(relativeDistance, base.Clamping);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			return Spline.DistanceToTF(worldUnitDistance, base.Clamping);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			Vector3 position = ((!UseCache) ? Spline.Interpolate(tf) : Spline.InterpolateFast(tf));
			return Spline.transform.TransformPoint(position);
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			CurvySpline spline = Spline;
			Transform transform = spline.transform;
			if (UseCache)
			{
				interpolatedPosition = spline.InterpolateFast(tf);
				tangent = spline.GetTangentFast(tf);
			}
			else
			{
				interpolatedPosition = spline.Interpolate(tf);
				tangent = spline.GetTangent(tf, interpolatedPosition);
			}
			up = spline.GetOrientationUpFast(tf);
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			Vector3 direction = ((!UseCache) ? Spline.GetTangent(tf) : Spline.GetTangentFast(tf));
			return Spline.transform.TransformDirection(direction);
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Spline.transform.TransformDirection(Spline.GetOrientationUpFast(tf));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float distance = speed * deltaTime;
			if (Spline.Count != 0)
			{
				EventAwareMove(distance);
			}
			if (IsSwitching && switchTarget.Count > 0)
			{
				SimulateAdvanceOnSpline(ref tfOnSwitchTarget, ref directionOnSwitchTarget, switchTarget, speed * deltaTime);
				preAllocatedEventArgs.Set_INTERNAL(this, switchTarget, null, tfOnSwitchTarget, SwitchProgress, directionOnSwitchTarget, usingWorldUnits: false);
				OnSwitch.Invoke(preAllocatedEventArgs);
				if (preAllocatedEventArgs.Cancel)
				{
					CancelCurrentSwitch();
				}
			}
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			SimulateAdvanceOnSpline(ref tf, ref curyDirection, Spline, speed * deltaTime);
		}

		private void SimulateAdvanceOnSpline(ref float tf, ref MovementDirection curyDirection, CurvySpline spline, float distance)
		{
			if (spline.Count > 0)
			{
				int dir = curyDirection.ToInt();
				switch (base.MoveMode)
				{
				case MoveModeEnum.AbsolutePrecise:
					tf = spline.DistanceToTF(spline.ClampDistance(spline.TFToDistance(tf) + distance * (float)dir, ref dir, base.Clamping));
					break;
				case MoveModeEnum.Relative:
					tf = CurvyUtility.ClampTF(tf + distance * (float)dir, ref dir, base.Clamping);
					break;
				default:
					throw new NotSupportedException();
				}
				curyDirection = MovementDirectionMethods.FromInt(dir);
			}
		}

		protected override void InitializedApplyDeltaTime(float deltaTime)
		{
			if (Spline.Dirty)
			{
				Spline.Refresh();
			}
			base.InitializedApplyDeltaTime(deltaTime);
			if (IsSwitching && SwitchProgress >= 1f)
			{
				FinishCurrentSwitch();
			}
		}

		protected override void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
		{
			base.ComputeTargetPositionAndRotation(out var targetPosition2, out var targetUp2, out var targetForward2);
			Quaternion a = Quaternion.LookRotation(targetForward2, targetUp2);
			if (IsSwitching)
			{
				CurvySpline spline = Spline;
				float relativePosition = base.RelativePosition;
				m_Spline = switchTarget;
				base.RelativePosition = tfOnSwitchTarget;
				base.ComputeTargetPositionAndRotation(out var targetPosition3, out var targetUp3, out var targetForward3);
				Quaternion b = Quaternion.LookRotation(targetForward3, targetUp3);
				m_Spline = spline;
				base.RelativePosition = relativePosition;
				targetPosition = Vector3.LerpUnclamped(targetPosition2, targetPosition3, SwitchProgress);
				Quaternion quaternion = Quaternion.LerpUnclamped(a, b, SwitchProgress);
				targetUp = quaternion * Vector3.up;
				targetForward = quaternion * Vector3.forward;
			}
			else
			{
				targetPosition = targetPosition2;
				targetUp = targetUp2;
				targetForward = targetForward2;
			}
		}

		private static float MovementCompatibleGetPosition(SplineController controller, CurvyPositionMode positionMode, out CurvySplineSegment controlPoint, out bool isOnControlPoint)
		{
			CurvySpline spline = controller.Spline;
			float position = controller.m_Position;
			float num;
			switch (controller.PositionMode)
			{
			case CurvyPositionMode.Relative:
				num = ((controller.Clamping != CurvyClamping.Loop || !position.Approximately(1f)) ? CurvyUtility.ClampTF(position, controller.Clamping) : 1f);
				break;
			case CurvyPositionMode.WorldUnits:
			{
				float length = controller.Length;
				num = ((controller.Clamping != CurvyClamping.Loop || !position.Approximately(length)) ? CurvyUtility.ClampDistance(position, controller.Clamping, length) : length);
				break;
			}
			default:
				throw new NotSupportedException();
			}
			float localF;
			bool flag;
			bool flag2;
			switch (controller.PositionMode)
			{
			case CurvyPositionMode.Relative:
				controlPoint = spline.TFToSegment(num, out localF, CurvyClamping.Clamp);
				flag = localF.Approximately(0f);
				flag2 = localF.Approximately(1f);
				break;
			case CurvyPositionMode.WorldUnits:
				controlPoint = spline.DistanceToSegment(num, out localF);
				flag = localF.Approximately(0f);
				flag2 = localF.Approximately(controlPoint.Length);
				break;
			default:
				throw new NotSupportedException();
			}
			float result = ((positionMode == controller.PositionMode) ? num : (positionMode switch
			{
				CurvyPositionMode.Relative => spline.SegmentToTF(controlPoint, controlPoint.DistanceToLocalF(localF)), 
				CurvyPositionMode.WorldUnits => controlPoint.Distance + controlPoint.LocalFToDistance(localF), 
				_ => throw new ArgumentOutOfRangeException(), 
			}));
			if (flag2)
			{
				controlPoint = spline.GetNextControlPoint(controlPoint);
			}
			isOnControlPoint = flag || flag2;
			return result;
		}

		private static void MovementCompatibleSetPosition(SplineController controller, CurvyPositionMode positionMode, float position)
		{
			CurvyPositionMode positionMode2 = controller.PositionMode;
			CurvyClamping clamping = controller.Clamping;
			float num;
			switch (positionMode)
			{
			case CurvyPositionMode.Relative:
				num = ((clamping != CurvyClamping.Loop || !position.Approximately(1f)) ? CurvyUtility.ClampTF(position, clamping) : 1f);
				break;
			case CurvyPositionMode.WorldUnits:
			{
				float length = controller.Length;
				num = ((clamping != CurvyClamping.Loop || !position.Approximately(length)) ? CurvyUtility.ClampDistance(position, clamping, length) : length);
				break;
			}
			default:
				throw new NotSupportedException();
			}
			if (positionMode == positionMode2)
			{
				controller.m_Position = num;
				return;
			}
			switch (positionMode)
			{
			case CurvyPositionMode.Relative:
				controller.m_Position = controller.Spline.TFToDistance(num, controller.Clamping);
				break;
			case CurvyPositionMode.WorldUnits:
				controller.m_Position = controller.Spline.DistanceToTF(num, controller.Clamping);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private void EventAwareMove(float distance)
		{
			CurvyPositionMode positionMode = base.MoveMode switch
			{
				MoveModeEnum.AbsolutePrecise => CurvyPositionMode.WorldUnits, 
				MoveModeEnum.Relative => CurvyPositionMode.Relative, 
				_ => throw new NotSupportedException(), 
			};
			float num = distance;
			bool cancelMovement = false;
			if ((base.MovementDirection == MovementDirection.Backward && base.RelativePosition.Approximately(0f)) || (base.MovementDirection == MovementDirection.Forward && base.RelativePosition.Approximately(1f)))
			{
				switch (base.Clamping)
				{
				case CurvyClamping.Clamp:
					num = 0f;
					break;
				case CurvyClamping.PingPong:
					base.MovementDirection = base.MovementDirection.GetOpposite();
					break;
				}
			}
			int num2 = 50;
			while (!cancelMovement && num > 0f && num2-- > 0)
			{
				bool isOnControlPoint;
				float position;
				CurvySplineSegment currentControlPoint = GetCurrentControlPoint(out isOnControlPoint, out position, positionMode);
				CurvySplineSegment curvySplineSegment = ((base.MovementDirection != 0) ? ((!isOnControlPoint) ? currentControlPoint : Spline.GetPreviousControlPoint(currentControlPoint)) : Spline.GetNextControlPoint(currentControlPoint));
				if (curvySplineSegment != null && Spline.IsControlPointVisible(curvySplineSegment))
				{
					float num3 = Mathf.Abs(GetControlPointPosition(curvySplineSegment, positionMode, base.MovementDirection) - position);
					if (num3 > num)
					{
						MovementCompatibleSetPosition(this, positionMode, position + num * (float)base.MovementDirection.ToInt());
						break;
					}
					num -= num3;
					HandleReachingNewControlPoint(curvySplineSegment, positionMode, num, ref cancelMovement);
				}
				bool isOnControlPoint2;
				float position2;
				CurvySplineSegment currentControlPoint2 = GetCurrentControlPoint(out isOnControlPoint2, out position2, positionMode);
				if (isOnControlPoint2 && (bool)currentControlPoint2.Connection && currentControlPoint2.Connection.ControlPointsList.Count > 1)
				{
					CurvySplineSegment curvySplineSegment2;
					MovementDirection newDirection;
					switch (ConnectionBehavior)
					{
					case SplineControllerConnectionBehavior.CurrentSpline:
						curvySplineSegment2 = currentControlPoint2;
						newDirection = base.MovementDirection;
						break;
					case SplineControllerConnectionBehavior.FollowUpSpline:
						curvySplineSegment2 = HandleFolloUpConnectionBahavior(currentControlPoint2, base.MovementDirection, out newDirection);
						break;
					case SplineControllerConnectionBehavior.FollowUpOtherwiseRandom:
						curvySplineSegment2 = ((!currentControlPoint2.FollowUp) ? HandleRandomConnectionBehavior(currentControlPoint2, base.MovementDirection, out newDirection, currentControlPoint2.Connection.ControlPointsList) : HandleFolloUpConnectionBahavior(currentControlPoint2, base.MovementDirection, out newDirection));
						break;
					case SplineControllerConnectionBehavior.RandomSpline:
						curvySplineSegment2 = HandleRandomConnectionBehavior(currentControlPoint2, base.MovementDirection, out newDirection, currentControlPoint2.Connection.ControlPointsList);
						break;
					case SplineControllerConnectionBehavior.Custom:
						if (ConnectionCustomSelector == null)
						{
							DTLog.LogError("[Curvy] You need to set a non null ConnectionCustomSelector when using SplineControllerConnectionBehavior.Custom");
							curvySplineSegment2 = currentControlPoint2;
						}
						else
						{
							curvySplineSegment2 = ConnectionCustomSelector.SelectConnectedControlPoint(this, currentControlPoint2.Connection, currentControlPoint2);
						}
						newDirection = base.MovementDirection;
						break;
					default:
						throw new ArgumentOutOfRangeException();
					}
					if (curvySplineSegment2 != currentControlPoint2)
					{
						base.MovementDirection = newDirection;
						HandleReachingNewControlPoint(curvySplineSegment2, positionMode, num, ref cancelMovement);
					}
				}
				bool isOnControlPoint3;
				float position3;
				CurvySplineSegment currentControlPoint3 = GetCurrentControlPoint(out isOnControlPoint3, out position3, positionMode);
				if (isOnControlPoint3)
				{
					switch (base.Clamping)
					{
					case CurvyClamping.Loop:
						if (!Spline.Closed)
						{
							if (base.MovementDirection == MovementDirection.Backward && currentControlPoint3 == Spline.FirstVisibleControlPoint)
							{
								HandleReachingNewControlPoint(Spline.LastVisibleControlPoint, positionMode, num, ref cancelMovement);
							}
							else if (base.MovementDirection == MovementDirection.Forward && currentControlPoint3 == Spline.LastVisibleControlPoint)
							{
								HandleReachingNewControlPoint(Spline.FirstVisibleControlPoint, positionMode, num, ref cancelMovement);
							}
						}
						break;
					case CurvyClamping.Clamp:
						if ((base.MovementDirection == MovementDirection.Backward && currentControlPoint3 == Spline.FirstVisibleControlPoint) || (base.MovementDirection == MovementDirection.Forward && currentControlPoint3 == Spline.LastVisibleControlPoint))
						{
							num = 0f;
						}
						break;
					case CurvyClamping.PingPong:
						if ((base.MovementDirection == MovementDirection.Backward && currentControlPoint3 == Spline.FirstVisibleControlPoint) || (base.MovementDirection == MovementDirection.Forward && currentControlPoint3 == Spline.LastVisibleControlPoint))
						{
							base.MovementDirection = base.MovementDirection.GetOpposite();
						}
						break;
					default:
						throw new ArgumentOutOfRangeException();
					}
				}
				bool isOnControlPoint4;
				CurvySplineSegment currentControlPoint4 = GetCurrentControlPoint(out isOnControlPoint4, out position, positionMode);
				if (!(currentControlPoint == currentControlPoint4) || isOnControlPoint != isOnControlPoint4)
				{
					continue;
				}
				CurvySplineSegment curvySplineSegment3 = null;
				for (int i = 0; i < Spline.Count; i++)
				{
					if (Spline[i].Length == 0f)
					{
						curvySplineSegment3 = Spline[i];
						break;
					}
				}
				if (curvySplineSegment3 != null)
				{
					DTLog.LogError($"[Curvy] Spline Controller '{base.name}' is stuck at control point '{currentControlPoint4}'. This is probably caused by the presence of a segment with a length of 0. Please remove control point '{curvySplineSegment3}' to proceed");
				}
				else
				{
					DTLog.LogError($"[Curvy] Spline Controller '{base.name}' is stuck at control point '{currentControlPoint4}'. Please raise a bug report");
				}
				break;
			}
			if (num2 <= 0)
			{
				DTLog.LogError($"[Curvy] Unexpected behavior in Spline Controller '{base.name}'. Please raise a Bug Report.");
			}
		}

		private CurvySplineSegment GetCurrentControlPoint(out bool isOnControlPoint, out float position, CurvyPositionMode positionMode)
		{
			position = MovementCompatibleGetPosition(this, positionMode, out var controlPoint, out isOnControlPoint);
			return controlPoint;
		}

		private void HandleReachingNewControlPoint(CurvySplineSegment newControlPoint, CurvyPositionMode positionMode, float currentDelta, ref bool cancelMovement)
		{
			Spline = newControlPoint.Spline;
			float controlPointPosition = GetControlPointPosition(newControlPoint, positionMode, base.MovementDirection);
			MovementCompatibleSetPosition(this, positionMode, controlPointPosition);
			bool usingWorldUnits = positionMode switch
			{
				CurvyPositionMode.Relative => false, 
				CurvyPositionMode.WorldUnits => true, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
			preAllocatedEventArgs.Set_INTERNAL(this, Spline, newControlPoint, controlPointPosition, currentDelta, base.MovementDirection, usingWorldUnits);
			OnControlPointReached.Invoke(preAllocatedEventArgs);
			if (preAllocatedEventArgs.Spline.FirstVisibleControlPoint == preAllocatedEventArgs.ControlPoint || preAllocatedEventArgs.Spline.LastVisibleControlPoint == preAllocatedEventArgs.ControlPoint)
			{
				OnEndReached.Invoke(preAllocatedEventArgs);
			}
			cancelMovement |= preAllocatedEventArgs.Cancel;
		}

		private CurvySplineSegment HandleRandomConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection, ReadOnlyCollection<CurvySplineSegment> connectedControlPoints)
		{
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(connectedControlPoints.Count);
			for (int i = 0; i < connectedControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = connectedControlPoints[i];
				if ((!RejectCurrentSpline || !(curvySplineSegment == currentControlPoint)) && (!RejectTooDivergentSplines || !(GetAngleBetweenConnectedSplines(currentControlPoint, currentDirection, curvySplineSegment, AllowDirectionChange) > MaxAllowedDivergenceAngle)))
				{
					list.Add(curvySplineSegment);
				}
			}
			CurvySplineSegment curvySplineSegment2 = ((list.Count != 0) ? list[Random.Range(0, list.Count)] : currentControlPoint);
			newDirection = GetPostConnectionDirection(curvySplineSegment2, currentDirection, AllowDirectionChange);
			return curvySplineSegment2;
		}

		private static MovementDirection GetPostConnectionDirection(CurvySplineSegment connectedControlPoint, MovementDirection currentDirection, bool directionChangeAllowed)
		{
			return (!directionChangeAllowed || connectedControlPoint.Spline.Closed) ? currentDirection : HeadingToDirection(ConnectionHeadingEnum.Auto, connectedControlPoint, currentDirection);
		}

		private CurvySplineSegment HandleFolloUpConnectionBahavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection)
		{
			CurvySplineSegment result = ((!currentControlPoint.FollowUp) ? currentControlPoint : currentControlPoint.FollowUp);
			newDirection = ((!AllowDirectionChange || !currentControlPoint.FollowUp) ? currentDirection : HeadingToDirection(currentControlPoint.FollowUpHeading, currentControlPoint.FollowUp, currentDirection));
			return result;
		}

		private static MovementDirection HeadingToDirection(ConnectionHeadingEnum heading, CurvySplineSegment controlPoint, MovementDirection currentDirection)
		{
			return heading.ResolveAuto(controlPoint) switch
			{
				ConnectionHeadingEnum.Minus => MovementDirection.Backward, 
				ConnectionHeadingEnum.Sharp => currentDirection, 
				ConnectionHeadingEnum.Plus => MovementDirection.Forward, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static float GetControlPointPosition(CurvySplineSegment controlPoint, CurvyPositionMode positionMode, MovementDirection movementDirection)
		{
			CurvySpline spline = controlPoint.Spline;
			float num = positionMode switch
			{
				CurvyPositionMode.Relative => spline.SegmentToTF(controlPoint), 
				CurvyPositionMode.WorldUnits => controlPoint.Distance, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
			float num2 = positionMode switch
			{
				CurvyPositionMode.Relative => 1f, 
				CurvyPositionMode.WorldUnits => spline.Length, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
			return (movementDirection != 0 || !num.Approximately(0f) || !spline.Closed) ? num : num2;
		}
	}
	[RequireComponent(typeof(Text))]
	[AddComponentMenu("Curvy/Controller/UI Text Spline Controller")]
	[HelpURL("https://curvyeditor.com/doclink/uitextsplinecontroller")]
	public class UITextSplineController : SplineController, IMeshModifier
	{
		protected class GlyphQuad
		{
			public UIVertex[] V = new UIVertex[4];

			public Rect Rect;

			public Vector3 Center => Rect.center;

			public void Load(List<UIVertex> verts, int index)
			{
				ref UIVertex reference = ref V[0];
				reference = verts[index];
				ref UIVertex reference2 = ref V[1];
				reference2 = verts[index + 1];
				ref UIVertex reference3 = ref V[2];
				reference3 = verts[index + 2];
				ref UIVertex reference4 = ref V[3];
				reference4 = verts[index + 3];
				calcRect();
			}

			public void LoadTris(List<UIVertex> verts, int index)
			{
				ref UIVertex reference = ref V[0];
				reference = verts[index];
				ref UIVertex reference2 = ref V[1];
				reference2 = verts[index + 1];
				ref UIVertex reference3 = ref V[2];
				reference3 = verts[index + 2];
				ref UIVertex reference4 = ref V[3];
				reference4 = verts[index + 4];
				calcRect();
			}

			public void calcRect()
			{
				Rect = new Rect(V[0].position.x, V[2].position.y, V[2].position.x - V[0].position.x, V[0].position.y - V[2].position.y);
			}

			public void Save(List<UIVertex> verts, int index)
			{
				verts[index] = V[0];
				verts[index + 1] = V[1];
				verts[index + 2] = V[2];
				verts[index + 3] = V[3];
			}

			public void Save(VertexHelper vh)
			{
				vh.AddUIVertexQuad(V);
			}

			public void Transpose(Vector3 v)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i].position += v;
				}
			}

			public void Rotate(Quaternion rotation)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i].position = V[i].position.RotateAround(Center, rotation);
				}
			}
		}

		protected class GlyphPlain
		{
			public Vector3[] V = new Vector3[4];

			public Rect Rect;

			public Vector3 Center => Rect.center;

			public void Load(ref Vector3[] verts, int index)
			{
				ref Vector3 reference = ref V[0];
				reference = verts[index];
				ref Vector3 reference2 = ref V[1];
				reference2 = verts[index + 1];
				ref Vector3 reference3 = ref V[2];
				reference3 = verts[index + 2];
				ref Vector3 reference4 = ref V[3];
				reference4 = verts[index + 3];
				calcRect();
			}

			public void calcRect()
			{
				Rect = new Rect(V[0].x, V[2].y, V[2].x - V[0].x, V[0].y - V[2].y);
			}

			public void Save(ref Vector3[] verts, int index)
			{
				ref Vector3 reference = ref verts[index];
				reference = V[0];
				ref Vector3 reference2 = ref verts[index + 1];
				reference2 = V[1];
				ref Vector3 reference3 = ref verts[index + 2];
				reference3 = V[2];
				ref Vector3 reference4 = ref verts[index + 3];
				reference4 = V[3];
			}

			public void Transpose(Vector3 v)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i] += v;
				}
			}

			public void Rotate(Quaternion rotation)
			{
				for (int i = 0; i < 4; i++)
				{
					ref Vector3 reference = ref V[i];
					reference = V[i].RotateAround(Center, rotation);
				}
			}
		}

		[Section("Orientation", true, false, 100)]
		[Tooltip("If true, the text characters will keep the same orientation regardless of the spline they follow")]
		[SerializeField]
		private bool staticOrientation;

		private Graphic m_Graphic;

		private RectTransform mRect;

		private Text mText;

		public bool StaticOrientation
		{
			get
			{
				return staticOrientation;
			}
			set
			{
				staticOrientation = value;
			}
		}

		protected override bool ShowOrientationSection => false;

		protected override bool ShowOffsetSection => false;

		protected Text Text
		{
			get
			{
				if (mText == null)
				{
					mText = GetComponent<Text>();
				}
				return mText;
			}
		}

		protected RectTransform Rect
		{
			get
			{
				if (mRect == null)
				{
					mRect = GetComponent<RectTransform>();
				}
				return mRect;
			}
		}

		protected Graphic graphic
		{
			get
			{
				if (m_Graphic == null)
				{
					m_Graphic = GetComponent<Graphic>();
				}
				return m_Graphic;
			}
		}

		public override CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					if (base.isInitialized)
					{
						UnbindSplineRelatedEvents();
					}
					m_Spline = value;
					if (base.isInitialized)
					{
						BindSplineRelatedEvents();
					}
				}
			}
		}

		protected override void InitializedApplyDeltaTime(float deltaTime)
		{
			base.InitializedApplyDeltaTime(deltaTime);
			graphic.SetVerticesDirty();
		}

		public void ModifyMesh(Mesh verts)
		{
			if (base.enabled && base.gameObject.activeInHierarchy && base.isInitialized)
			{
				Vector3[] verts2 = verts.vertices;
				GlyphPlain glyphPlain = new GlyphPlain();
				for (int i = 0; i < Text.text.Length; i++)
				{
					glyphPlain.Load(ref verts2, i * 4);
					float position = base.AbsolutePosition + glyphPlain.Rect.center.x;
					float tf = AbsoluteToRelative(CurvyController.GetClampedPosition(position, CurvyPositionMode.WorldUnits, base.Clamping, Length));
					Vector3 interpolatedSourcePosition = GetInterpolatedSourcePosition(tf);
					Vector3 tangent = GetTangent(tf);
					Vector3 v = interpolatedSourcePosition - Rect.position - glyphPlain.Center;
					glyphPlain.Transpose(new Vector3(0f, glyphPlain.Center.y, 0f));
					glyphPlain.Rotate(Quaternion.AngleAxis(Mathf.Atan2(tangent.x, 0f - tangent.y) * 57.29578f - 90f, Vector3.forward));
					glyphPlain.Transpose(v);
					glyphPlain.Save(ref verts2, i * 4);
				}
				verts.vertices = verts2;
			}
		}

		public void ModifyMesh(VertexHelper vertexHelper)
		{
			if (!base.enabled || !base.gameObject.activeInHierarchy || !base.isInitialized)
			{
				return;
			}
			List<UIVertex> list = new List<UIVertex>();
			GlyphQuad glyphQuad = new GlyphQuad();
			vertexHelper.GetUIVertexStream(list);
			vertexHelper.Clear();
			for (int i = 0; i < Text.text.Length; i++)
			{
				glyphQuad.LoadTris(list, i * 6);
				float position = base.AbsolutePosition + glyphQuad.Rect.center.x;
				float tf = AbsoluteToRelative(CurvyController.GetClampedPosition(position, CurvyPositionMode.WorldUnits, base.Clamping, Length));
				Vector3 interpolatedSourcePosition = GetInterpolatedSourcePosition(tf);
				Vector3 tangent = GetTangent(tf);
				Vector3 v = interpolatedSourcePosition - Rect.position - glyphQuad.Center;
				glyphQuad.Transpose(new Vector3(0f, glyphQuad.Center.y, 0f));
				if (!StaticOrientation)
				{
					glyphQuad.Rotate(Quaternion.AngleAxis(Mathf.Atan2(tangent.x, 0f - tangent.y) * 57.29578f - 90f, Vector3.forward));
				}
				glyphQuad.Transpose(v);
				glyphQuad.Save(vertexHelper);
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
		}

		protected override void BindEvents()
		{
			base.BindEvents();
			BindSplineRelatedEvents();
		}

		protected override void UnbindEvents()
		{
			base.UnbindEvents();
			UnbindSplineRelatedEvents();
		}

		private void BindSplineRelatedEvents()
		{
			if ((bool)Spline)
			{
				UnbindSplineRelatedEvents();
				Spline.OnRefresh.AddListener(OnSplineRefreshed);
			}
		}

		private void UnbindSplineRelatedEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
			}
		}

		private void OnSplineRefreshed(CurvySplineEventArgs e)
		{
			CurvySpline curvySpline = e.Sender as CurvySpline;
			if (curvySpline != Spline)
			{
				curvySpline.OnRefresh.RemoveListener(OnSplineRefreshed);
			}
			else
			{
				graphic.SetVerticesDirty();
			}
		}
	}
	[AddComponentMenu("Curvy/Controller/CG Volume Controller", 8)]
	[HelpURL("https://curvyeditor.com/doclink/volumecontroller")]
	public class VolumeController : CurvyController
	{
		private const float CrossPositionRangeMin = -0.5f;

		private const float CrossPositionRangeMax = 0.5f;

		[Section("General", true, false, 100)]
		[CGDataReferenceSelector(typeof(CGVolume), Label = "Volume/Slot")]
		[SerializeField]
		private CGDataReference m_Volume = new CGDataReference();

		[Section("Cross Position", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/volumecontroller_crossposition")]
		[SerializeField]
		[FloatRegion(UseSlider = true, Precision = 4, RegionOptionsPropertyName = "CrossRangeOptions", Options = AttributeOptionsFlags.Full)]
		private FloatRegion m_CrossRange = new FloatRegion(-0.5f, 0.5f);

		[RangeEx("MinCrossRelativePosition", "MaxCrossRelativePosition", "", "")]
		[SerializeField]
		private float crossRelativePosition;

		[SerializeField]
		private CurvyClamping m_CrossClamping;

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use crossRelativePosition instead. This field is kept for retro compatibility reasons")]
		private float m_CrossInitialPosition;

		public CGDataReference Volume
		{
			get
			{
				return m_Volume;
			}
			set
			{
				m_Volume = value;
			}
		}

		public CGVolume VolumeData => (!Volume.HasValue) ? null : Volume.GetData<CGVolume>();

		public float CrossFrom
		{
			get
			{
				return m_CrossRange.From;
			}
			set
			{
				m_CrossRange.From = Mathf.Clamp(value, -0.5f, 0.5f);
			}
		}

		public float CrossTo
		{
			get
			{
				return m_CrossRange.To;
			}
			set
			{
				m_CrossRange.To = Mathf.Clamp(value, CrossFrom, 0.5f);
			}
		}

		public float CrossLength => m_CrossRange.Length;

		public CurvyClamping CrossClamping
		{
			get
			{
				return m_CrossClamping;
			}
			set
			{
				m_CrossClamping = value;
			}
		}

		public float CrossRelativePosition
		{
			get
			{
				return GetClampedCrossPosition(crossRelativePosition);
			}
			set
			{
				crossRelativePosition = GetClampedCrossPosition(value);
			}
		}

		public override float Length => (VolumeData == null) ? 0f : VolumeData.Length;

		public override bool IsReady => Volume != null && !Volume.IsEmpty && Volume.HasValue;

		private RegionOptions<float> CrossRangeOptions => RegionOptions<float>.MinMax(-0.5f, 0.5f);

		private float MinCrossRelativePosition => m_CrossRange.From;

		private float MaxCrossRelativePosition => m_CrossRange.To;

		public float CrossRelativeToAbsolute(float relativeDistance)
		{
			return (VolumeData == null) ? 0f : VolumeData.CrossFToDistance(base.RelativePosition, relativeDistance, CrossClamping);
		}

		public float CrossAbsoluteToRelative(float worldUnitDistance)
		{
			return (VolumeData == null) ? 0f : VolumeData.CrossDistanceToF(base.RelativePosition, worldUnitDistance, CrossClamping);
		}

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			return (VolumeData == null) ? 0f : VolumeData.FToDistance(relativeDistance);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			return (VolumeData == null) ? 0f : VolumeData.DistanceToF(worldUnitDistance);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			return Volume.Module.Generator.transform.TransformPoint(VolumeData.InterpolateVolumePosition(tf, CrossRelativePosition));
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			VolumeData.InterpolateVolume(tf, CrossRelativePosition, out interpolatedPosition, out tangent, out up);
			Transform transform = Volume.Module.Generator.transform;
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeDirection(tf, CrossRelativePosition));
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeUp(tf, CrossRelativePosition));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float tf = base.RelativePosition;
			MovementDirection curyDirection = base.MovementDirection;
			SimulateAdvance(ref tf, ref curyDirection, speed, deltaTime);
			base.MovementDirection = curyDirection;
			base.RelativePosition = tf;
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			int direction = curyDirection.ToInt();
			switch (base.MoveMode)
			{
			case MoveModeEnum.Relative:
				VolumeData.Move(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			case MoveModeEnum.AbsolutePrecise:
				VolumeData.MoveBy(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			default:
				throw new NotSupportedException();
			}
			curyDirection = MovementDirectionMethods.FromInt(direction);
		}

		private float GetClampedCrossPosition(float position)
		{
			return CurvyUtility.ClampValue(position, CrossClamping, CrossFrom, CrossTo);
		}

		public override void OnAfterDeserialize()
		{
			base.OnAfterDeserialize();
			if (!float.IsNaN(m_CrossInitialPosition))
			{
				crossRelativePosition = DTMath.MapValue(CrossFrom, CrossTo, m_CrossInitialPosition, -0.5f, 0.5f);
				m_CrossInitialPosition = float.NaN;
			}
		}
	}
}
namespace FluffyUnderware.Curvy.ImportExport
{
	public enum CurvySerializationSpace
	{
		Global,
		Local
	}
	[Serializable]
	public class SerializedCurvySpline
	{
		public string Name;

		public Vector3 Position;

		public Vector3 Rotation;

		public CurvyInterpolation Interpolation;

		public bool RestrictTo2D;

		public bool Closed;

		public bool AutoEndTangents;

		public CurvyOrientation Orientation;

		public float AutoHandleDistance;

		public int CacheDensity;

		public float MaxPointsPerUnit;

		public bool UsePooling;

		public bool UseThreading;

		public bool CheckTransform;

		public CurvyUpdateMethod UpdateIn;

		public SerializedCurvySplineSegment[] ControlPoints;

		public SerializedCurvySpline()
		{
			Interpolation = CurvyGlobalManager.DefaultInterpolation;
			AutoEndTangents = true;
			Orientation = CurvyOrientation.Dynamic;
			AutoHandleDistance = 0.39f;
			CacheDensity = 50;
			MaxPointsPerUnit = 8f;
			UsePooling = true;
			CheckTransform = true;
			UpdateIn = CurvyUpdateMethod.Update;
			ControlPoints = new SerializedCurvySplineSegment[0];
		}

		public SerializedCurvySpline([NotNull] CurvySpline spline, CurvySerializationSpace space)
		{
			Name = spline.name;
			Position = ((space != CurvySerializationSpace.Local) ? spline.transform.position : spline.transform.localPosition);
			Rotation = ((space != CurvySerializationSpace.Local) ? spline.transform.rotation.eulerAngles : spline.transform.localRotation.eulerAngles);
			Interpolation = spline.Interpolation;
			RestrictTo2D = spline.RestrictTo2D;
			Closed = spline.Closed;
			AutoEndTangents = spline.AutoEndTangents;
			Orientation = spline.Orientation;
			AutoHandleDistance = spline.AutoHandleDistance;
			CacheDensity = spline.CacheDensity;
			MaxPointsPerUnit = spline.MaxPointsPerUnit;
			UsePooling = spline.UsePooling;
			UseThreading = spline.UseThreading;
			CheckTransform = spline.CheckTransform;
			UpdateIn = spline.UpdateIn;
			ControlPoints = new SerializedCurvySplineSegment[spline.ControlPointCount];
			for (int i = 0; i < spline.ControlPointCount; i++)
			{
				ControlPoints[i] = new SerializedCurvySplineSegment(spline.ControlPointsList[i], space);
			}
		}

		public void WriteIntoSpline([NotNull] CurvySpline deserializedSpline, CurvySerializationSpace space)
		{
			deserializedSpline.name = Name;
			if (space == CurvySerializationSpace.Local)
			{
				deserializedSpline.transform.localPosition = Position;
				deserializedSpline.transform.localRotation = Quaternion.Euler(Rotation);
			}
			else
			{
				deserializedSpline.transform.position = Position;
				deserializedSpline.transform.rotation = Quaternion.Euler(Rotation);
			}
			deserializedSpline.Interpolation = Interpolation;
			deserializedSpline.RestrictTo2D = RestrictTo2D;
			deserializedSpline.Closed = Closed;
			deserializedSpline.AutoEndTangents = AutoEndTangents;
			deserializedSpline.Orientation = Orientation;
			deserializedSpline.AutoHandleDistance = AutoHandleDistance;
			deserializedSpline.CacheDensity = CacheDensity;
			deserializedSpline.MaxPointsPerUnit = MaxPointsPerUnit;
			deserializedSpline.UsePooling = UsePooling;
			deserializedSpline.UseThreading = UseThreading;
			deserializedSpline.CheckTransform = CheckTransform;
			deserializedSpline.UpdateIn = UpdateIn;
			SerializedCurvySplineSegment[] controlPoints = ControlPoints;
			foreach (SerializedCurvySplineSegment serializedCurvySplineSegment in controlPoints)
			{
				serializedCurvySplineSegment.WriteIntoControlPoint(deserializedSpline.InsertAfter(null, skipRefreshingAndEvents: true), space);
			}
			deserializedSpline.SetDirtyAll();
		}
	}
	[Serializable]
	public class SerializedCurvySplineSegment
	{
		public Vector3 Position;

		public Vector3 Rotation;

		public bool AutoBakeOrientation;

		public bool OrientationAnchor;

		public CurvyOrientationSwirl Swirl;

		public float SwirlTurns;

		public bool AutoHandles;

		public float AutoHandleDistance;

		public Vector3 HandleOut;

		public Vector3 HandleIn;

		public SerializedCurvySplineSegment()
		{
			Swirl = CurvyOrientationSwirl.None;
			AutoHandles = true;
			AutoHandleDistance = 0.39f;
			HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
			HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
		}

		public SerializedCurvySplineSegment([NotNull] CurvySplineSegment segment, CurvySerializationSpace space)
		{
			Position = ((space != 0) ? segment.transform.localPosition : segment.transform.position);
			Rotation = ((space != 0) ? segment.transform.localRotation.eulerAngles : segment.transform.rotation.eulerAngles);
			AutoBakeOrientation = segment.AutoBakeOrientation;
			OrientationAnchor = segment.SerializedOrientationAnchor;
			Swirl = segment.Swirl;
			SwirlTurns = segment.SwirlTurns;
			AutoHandles = segment.AutoHandles;
			AutoHandleDistance = segment.AutoHandleDistance;
			HandleOut = segment.HandleOut;
			HandleIn = segment.HandleIn;
		}

		public void WriteIntoControlPoint([NotNull] CurvySplineSegment controlPoint, CurvySerializationSpace space)
		{
			if (space == CurvySerializationSpace.Global)
			{
				controlPoint.transform.position = Position;
				controlPoint.transform.rotation = Quaternion.Euler(Rotation);
			}
			else
			{
				controlPoint.transform.localPosition = Position;
				controlPoint.transform.localRotation = Quaternion.Euler(Rotation);
			}
			controlPoint.AutoBakeOrientation = AutoBakeOrientation;
			controlPoint.SerializedOrientationAnchor = OrientationAnchor;
			controlPoint.Swirl = Swirl;
			controlPoint.SwirlTurns = SwirlTurns;
			controlPoint.AutoHandles = AutoHandles;
			controlPoint.AutoHandleDistance = AutoHandleDistance;
			controlPoint.SetBezierHandleIn(HandleIn);
			controlPoint.SetBezierHandleOut(HandleOut);
		}
	}
}
namespace FluffyUnderware.DevTools
{
	public interface IDTGroupParsingAttribute
	{
		string Path { get; }
	}
	public interface IDTFieldParsingAttribute
	{
	}
	public interface IDTGroupRenderAttribute
	{
	}
	public interface IDTFieldRenderAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public class DTVersionAttribute : Attribute
	{
		public readonly string Version;

		public DTVersionAttribute(string version)
		{
			Version = version;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
	public class DTAttribute : Attribute, IComparable
	{
		public int Sort = 100;

		public bool ShowBelowProperty;

		public int Space;

		public int TypeSort { get; protected set; }

		public DTAttribute(int sortOrder, bool showBelow = false)
		{
			TypeSort = sortOrder;
			ShowBelowProperty = showBelow;
		}

		public virtual int CompareTo(object obj)
		{
			DTAttribute dTAttribute = (DTAttribute)obj;
			int num = ShowBelowProperty.CompareTo(dTAttribute.ShowBelowProperty);
			if (num == 0)
			{
				int num2 = TypeSort.CompareTo(dTAttribute.TypeSort);
				if (num2 == 0)
				{
					return Sort.CompareTo(dTAttribute.Sort);
				}
				return num2;
			}
			return num;
		}
	}
	public class GroupAttribute : DTAttribute, IDTGroupParsingAttribute, IDTGroupRenderAttribute
	{
		public bool Expanded = true;

		public bool Invisible;

		public string Label;

		public string Tooltip;

		public string HelpURL;

		private string mPath;

		public string Path
		{
			get
			{
				return mPath;
			}
			protected set
			{
				PathIsAbsolute = !string.IsNullOrEmpty(value) && value.StartsWith("@");
				if (PathIsAbsolute)
				{
					mPath = value.Substring(1);
					if (string.IsNullOrEmpty(mPath))
					{
						mPath = null;
					}
				}
				else
				{
					mPath = value;
				}
			}
		}

		public bool PathIsAbsolute { get; private set; }

		public GroupAttribute(string pathAndName)
			: base(15)
		{
			Path = pathAndName;
		}
	}
	public class ActionAttribute : DTAttribute
	{
		public enum ActionEnum
		{
			Show,
			Hide,
			Enable,
			Disable,
			ShowInfo,
			ShowWarning,
			ShowError,
			Callback
		}

		public enum ActionPositionEnum
		{
			Above,
			Below
		}

		public ActionEnum Action = ActionEnum.Callback;

		public ActionPositionEnum Position = ActionPositionEnum.Below;

		public object ActionData;

		private MethodInfo mCallback;

		protected ActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(50)
		{
			ActionData = actionData;
			Action = action;
		}

		public void Callback(object classInstance)
		{
			string text = ActionData as string;
			if (!string.IsNullOrEmpty(text))
			{
				if (mCallback == null)
				{
					mCallback = classInstance.GetType().MethodByName(text, includeInherited: true, includePrivate: true);
				}
				if (mCallback != null)
				{
					mCallback.Invoke(classInstance, null);
					return;
				}
				Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", text, classInstance.GetType().Name);
			}
		}
	}
	public class ConditionalAttribute : ActionAttribute
	{
		public enum OperatorEnum
		{
			AND,
			OR
		}

		public class Condition
		{
			public string FieldName;

			public FieldInfo FieldInfo;

			public PropertyInfo PropertyInfo;

			public object CompareTo;

			public bool CompareFalse;

			public OperatorEnum Operator;

			public MethodInfo MethodInfo;

			public string MethodName;
		}

		public Condition[] Conditions;

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[1]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				}
			};
		}

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[2]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				},
				new Condition
				{
					FieldName = fieldOrProperty2,
					CompareTo = compareTo2,
					CompareFalse = compareFalse2,
					Operator = op
				}
			};
		}

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[3]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				},
				new Condition
				{
					FieldName = fieldOrProperty2,
					CompareTo = compareTo2,
					CompareFalse = compareFalse2,
					Operator = op
				},
				new Condition
				{
					FieldName = fieldOrProperty3,
					CompareTo = compareTo3,
					CompareFalse = compareFalse3,
					Operator = op
				}
			};
		}

		protected ConditionalAttribute(string methodToQuery)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[1]
			{
				new Condition
				{
					MethodName = methodToQuery,
					CompareTo = null
				}
			};
		}

		public virtual bool ConditionMet(object classInstance)
		{
			bool flag = evaluate(Conditions[0], classInstance);
			for (int i = 1; i < Conditions.Length; i++)
			{
				Condition condition = Conditions[i];
				switch (condition.Operator)
				{
				case OperatorEnum.AND:
					flag = flag && evaluate(condition, classInstance);
					break;
				case OperatorEnum.OR:
					flag = flag || evaluate(condition, classInstance);
					break;
				}
			}
			return flag;
		}

		private bool evaluate(Condition cond, object classInstance)
		{
			if (!string.IsNullOrEmpty(cond.MethodName))
			{
				if (cond.MethodInfo == null)
				{
					cond.MethodInfo = classInstance.GetType().MethodByName(cond.MethodName, includeInherited: true, includePrivate: true);
				}
				if (cond.MethodInfo != null)
				{
					if (cond.CompareFalse)
					{
						return !(bool)cond.MethodInfo.Invoke(classInstance, null);
					}
					return (bool)cond.MethodInfo.Invoke(classInstance, null);
				}
				Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", cond.MethodName, classInstance.GetType().Name);
				return cond.CompareFalse;
			}
			if (cond.FieldInfo == null)
			{
				cond.FieldInfo = classInstance.GetType().FieldByName(cond.FieldName, includeInherited: true, includePrivate: true);
				if (cond.FieldInfo == null)
				{
					cond.PropertyInfo = classInstance.GetType().PropertyByName(cond.FieldName, includeInherited: true, includePrivate: true);
				}
			}
			object obj = null;
			if (cond.FieldInfo != null)
			{
				obj = cond.FieldInfo.GetValue(classInstance);
			}
			else if (cond.PropertyInfo != null)
			{
				obj = cond.PropertyInfo.GetValue(classInstance, null);
			}
			if (obj == null)
			{
				return cond.CompareTo == null && !cond.CompareFalse;
			}
			return obj.Equals(cond.CompareTo) == !cond.CompareFalse;
		}
	}
	public class SortOrderAttribute : DTAttribute, IDTFieldParsingAttribute
	{
		public SortOrderAttribute(int sort = 100)
			: base(0)
		{
			Sort = sort;
		}
	}
	public class AsGroupAttribute : GroupAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public AsGroupAttribute(string pathAndName = null)
			: base(pathAndName)
		{
			base.TypeSort = 10;
		}
	}
	public class TabAttribute : GroupAttribute
	{
		public readonly string TabName;

		public readonly string TabBarName;

		public TabAttribute(string pathAndName)
			: base(string.Empty)
		{
			base.TypeSort = 10;
			split(pathAndName, out var path, out TabBarName, out TabName);
			base.Path = path;
		}

		private static bool split(string pathAndName, out string path, out string tabBar, out string tabname)
		{
			string[] array = pathAndName.Split('/');
			path = string.Empty;
			tabBar = string.Empty;
			tabname = pathAndName;
			if (array.Length == 0)
			{
				return false;
			}
			if (array.Length == 1)
			{
				tabname = array[0];
				tabBar = "Default";
				return true;
			}
			tabname = array[array.Length - 1];
			tabBar = array[array.Length - 2];
			path = string.Join("/", array, 0, array.Length - 2);
			return true;
		}
	}
	public class SectionAttribute : GroupAttribute
	{
		public bool Fixed;

		public SectionAttribute(string name, bool expanded = true, bool fix = false, int sort = 100)
			: base(name)
		{
			Expanded = expanded;
			base.TypeSort = 10;
			Sort = sort;
			Fixed = fix;
		}
	}
	public class NoSectionAttribute : SectionAttribute
	{
		public NoSectionAttribute()
			: base(string.Empty)
		{
			base.TypeSort = 10;
		}
	}
	public class Hide : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public Hide()
			: base(20)
		{
		}
	}
	public class Inline : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public Inline()
			: base(21)
		{
		}
	}
	public class ArrayExAttribute : DTAttribute, IDTFieldParsingAttribute
	{
		public bool Draggable = true;

		public bool ShowHeader = true;

		public bool ShowAdd = true;

		public bool ShowDelete = true;

		public bool DropTarget = true;

		public ArrayExAttribute()
			: base(35)
		{
		}
	}
	public class FieldActionAttribute : ActionAttribute, IDTFieldRenderAttribute
	{
		public FieldActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(actionData, action)
		{
		}
	}
	public class GroupActionAttribute : ActionAttribute, IDTGroupRenderAttribute
	{
		public GroupActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(actionData, action)
		{
		}
	}
	public class FieldConditionAttribute : ConditionalAttribute, IDTFieldRenderAttribute
	{
		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false, ActionEnum action = ActionEnum.Show, object actionData = null, ActionPositionEnum position = ActionPositionEnum.Below)
			: base(fieldOrProperty, compareTo, compareFalse)
		{
			Action = action;
			ActionData = actionData;
			Position = position;
		}

		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2)
		{
		}

		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3)
		{
		}

		public FieldConditionAttribute(string methodToQuery)
			: base(methodToQuery)
		{
		}
	}
	public class GroupConditionAttribute : ConditionalAttribute, IDTGroupRenderAttribute
	{
		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
			: base(fieldOrProperty, compareTo, compareFalse)
		{
		}

		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2)
		{
		}

		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3)
		{
		}

		public GroupConditionAttribute(string methodToQuery)
			: base(methodToQuery)
		{
		}
	}
	public class Couple<T1, T2>
	{
		public T1 First { get; set; }

		public T2 Second { get; set; }

		public Couple(T1 first, T2 second)
		{
			First = first;
			Second = second;
		}
	}
	[Serializable]
	public struct FloatRegion
	{
		public float From;

		public float To;

		public bool SimpleValue;

		public static FloatRegion ZeroOne => new FloatRegion(0f, 1f);

		public bool Positive => From <= To;

		public float Low
		{
			get
			{
				return (!Positive) ? To : From;
			}
			set
			{
				if (Positive)
				{
					From = value;
				}
				else
				{
					To = value;
				}
			}
		}

		public float High
		{
			get
			{
				return (!Positive) ? From : To;
			}
			set
			{
				if (Positive)
				{
					To = value;
				}
				else
				{
					From = value;
				}
			}
		}

		public float Random => UnityEngine.Random.Range(From, To);

		public float Next
		{
			get
			{
				if (SimpleValue)
				{
					return From;
				}
				return Random;
			}
		}

		public float Length => To - From;

		public float LengthPositive => (!Positive) ? (From - To) : (To - From);

		public FloatRegion(float value)
		{
			From = value;
			To = value;
			SimpleValue = true;
		}

		public FloatRegion(float A, float B)
		{
			From = A;
			To = B;
			SimpleValue = false;
		}

		public void MakePositive()
		{
			if (To < From)
			{
				float to = To;
				To = From;
				From = to;
			}
		}

		public void Clamp(float low, float high)
		{
			Low = Mathf.Clamp(Low, low, high);
			High = Mathf.Clamp(High, low, high);
		}

		public override string ToString()
		{
			return $"({From:F1}-{To:F1})";
		}

		public override int GetHashCode()
		{
			return From.GetHashCode() ^ (To.GetHashCode() << 2);
		}

		public override bool Equals(object other)
		{
			if (!(other is FloatRegion floatRegion))
			{
				return false;
			}
			return From.Equals(floatRegion.From) && To.Equals(floatRegion.To);
		}

		public static FloatRegion operator +(FloatRegion a, FloatRegion b)
		{
			return new FloatRegion(a.From + b.From, a.To + b.To);
		}

		public static FloatRegion operator -(FloatRegion a, FloatRegion b)
		{
			return new FloatRegion(a.From - b.From, a.To - b.To);
		}

		public static FloatRegion operator -(FloatRegion a)
		{
			return new FloatRegion(0f - a.From, 0f - a.To);
		}

		public static FloatRegion operator *(FloatRegion a, float v)
		{
			return new FloatRegion(a.From * v, a.To * v);
		}

		public static FloatRegion operator *(float v, FloatRegion a)
		{
			return new FloatRegion(a.From * v, a.To * v);
		}

		public static FloatRegion operator /(FloatRegion a, float v)
		{
			return new FloatRegion(a.From / v, a.To / v);
		}

		public static bool operator ==(FloatRegion lhs, FloatRegion rhs)
		{
			return lhs.SimpleValue == rhs.SimpleValue && Mathf.Approximately(lhs.From, rhs.From) && Mathf.Approximately(lhs.To, rhs.To);
		}

		public static bool operator !=(FloatRegion lhs, FloatRegion rhs)
		{
			return lhs.SimpleValue != rhs.SimpleValue || !Mathf.Approximately(lhs.From, rhs.From) || !Mathf.Approximately(lhs.To, rhs.To);
		}
	}
	[Serializable]
	public struct IntRegion
	{
		public int From;

		public int To;

		public bool SimpleValue;

		public static IntRegion ZeroOne => new IntRegion(0, 1);

		public bool Positive => From <= To;

		public int Low
		{
			get
			{
				return (!Positive) ? To : From;
			}
			set
			{
				if (Positive)
				{
					From = value;
				}
				else
				{
					To = value;
				}
			}
		}

		public int High
		{
			get
			{
				return (!Positive) ? From : To;
			}
			set
			{
				if (Positive)
				{
					To = value;
				}
				else
				{
					From = value;
				}
			}
		}

		public int Random => UnityEngine.Random.Range(From, To);

		public int Length => To - From;

		public int LengthPositive => (!Positive) ? (From - To) : (To - From);

		public IntRegion(int value)
		{
			From = value;
			To = value;
			SimpleValue = true;
		}

		public IntRegion(int A, int B)
		{
			From = A;
			To = B;
			SimpleValue = false;
		}

		public void MakePositive()
		{
			if (To < From)
			{
				int to = To;
				To = From;
				From = to;
			}
		}

		public void Clamp(int low, int high)
		{
			Low = Mathf.Clamp(Low, low, high);
			High = Mathf.Clamp(High, low, high);
		}

		public override string ToString()
		{
			return $"({From}-{To})";
		}

		public override int GetHashCode()
		{
			return From.GetHashCode() ^ (To.GetHashCode() << 2);
		}

		public override bool Equals(object other)
		{
			if (!(other is IntRegion intRegion))
			{
				return false;
			}
			return From.Equals(intRegion.From) && To.Equals(intRegion.To);
		}

		public static IntRegion operator +(IntRegion a, IntRegion b)
		{
			return new IntRegion(a.From + b.From, a.To + b.To);
		}

		public static IntRegion operator -(IntRegion a, IntRegion b)
		{
			return new IntRegion(a.From - b.From, a.To - b.To);
		}

		public static IntRegion operator -(IntRegion a)
		{
			return new IntRegion(-a.From, -a.To);
		}

		public static IntRegion operator *(IntRegion a, int v)
		{
			return new IntRegion(a.From * v, a.To * v);
		}

		public static IntRegion operator *(int v, IntRegion a)
		{
			return new IntRegion(a.From * v, a.To * v);
		}

		public static IntRegion operator /(IntRegion a, int v)
		{
			return new IntRegion(a.From / v, a.To / v);
		}

		public static bool operator ==(IntRegion lhs, IntRegion rhs)
		{
			return lhs.From == rhs.From && lhs.To == rhs.To && lhs.SimpleValue != rhs.SimpleValue;
		}

		public static bool operator !=(IntRegion lhs, IntRegion rhs)
		{
			return lhs.From != rhs.From || lhs.To != rhs.To || lhs.SimpleValue != rhs.SimpleValue;
		}
	}
	public class WeightedRandom<T>
	{
		private List<T> mData;

		private int mCurrentPosition = -1;

		private T mCurrentItem;

		public int Seed { get; set; }

		public bool RandomizeSeed { get; set; }

		private int Capacity => mData.Capacity;

		public int Size => mData.Count;

		public WeightedRandom(int initCapacity = 0)
		{
			mData = new List<T>(initCapacity);
		}

		public void Add(T item, int amount)
		{
			for (int i = 0; i < amount; i++)
			{
				mData.Add(item);
			}
			mCurrentPosition = Size - 1;
		}

		public T Next()
		{
			if (mCurrentPosition < 1)
			{
				mCurrentPosition = Size - 1;
				mCurrentItem = mData[0];
				return mCurrentItem;
			}
			Random.State state = Random.state;
			if (RandomizeSeed)
			{
				Seed = Random.Range(0, int.MaxValue);
			}
			Random.InitState(Seed);
			int index = Random.Range(0, mCurrentPosition);
			Random.state = state;
			mCurrentItem = mData[index];
			mData[index] = mData[mCurrentPosition];
			mData[mCurrentPosition] = mCurrentItem;
			mCurrentPosition--;
			return mCurrentItem;
		}

		public void Reset()
		{
			mCurrentPosition = Size - 1;
		}

		public void Clear()
		{
			mData.Clear();
			mCurrentPosition = -1;
		}
	}
	public class Ring<T> : IList<T>, IEnumerable, ICollection<T>, IEnumerable<T>
	{
		private List<T> mList;

		private int mIndex;

		public int Size { get; private set; }

		public T this[int index]
		{
			get
			{
				return mList[index];
			}
			set
			{
				mList[index] = value;
			}
		}

		public int Count => mList.Count;

		public bool IsReadOnly
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public Ring(int size)
		{
			mList = new List<T>(size);
			Size = size;
		}

		public void Add(T item)
		{
			if (mList.Count == Size)
			{
				mList[mIndex++] = item;
				if (mIndex == mList.Count)
				{
					mIndex = 0;
				}
			}
			else
			{
				mList.Add(item);
			}
		}

		public void Clear()
		{
			mList.Clear();
			mIndex = 0;
		}

		public int IndexOf(T item)
		{
			return mList.IndexOf(item);
		}

		public void Insert(int index, T item)
		{
			throw new NotSupportedException();
		}

		public void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public IEnumerator GetEnumerator()
		{
			return mList.GetEnumerator();
		}

		public bool Contains(T item)
		{
			return mList.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			mList.CopyTo(array, arrayIndex);
		}

		public bool Remove(T item)
		{
			return mList.Remove(item);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	public class Pool<T> : IPool
	{
		private List<T> mObjects = new List<T>();

		private double mLastTime;

		private double mDeltaTime;

		public string Identifier { get; set; }

		public PoolSettings Settings { get; protected set; }

		public Type Type => typeof(T);

		public int Count => mObjects.Count;

		public Pool(PoolSettings settings = null)
		{
			Settings = settings ?? new PoolSettings();
			Identifier = typeof(T).FullName;
			mLastTime = DTTime.TimeSinceStartup + (double)Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Update()
		{
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
						log("Threshold exceeded: Deleting item");
					}
				}
				else if (Count < Settings.MinItems)
				{
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						mObjects.Add(create());
						log("Below MinItems: Adding item");
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				log("Prewarm/Reset");
			}
		}

		public void Clear()
		{
			log("Clear");
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public virtual T Pop(Transform parent = null)
		{
			T val = default(T);
			if (Count > 0)
			{
				val = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				log("Auto create item");
				val = create();
			}
			if (val != null)
			{
				sendAfterPop(val);
				setParent(val, parent);
				log("Pop " + val);
			}
			return val;
		}

		public virtual void Push(T item)
		{
			log("Push " + item);
			if (Application.isPlaying && item != null)
			{
				sendBeforePush(item);
				mObjects.Add(item);
			}
		}

		protected virtual void sendBeforePush(T item)
		{
			if (item is IPoolable)
			{
				((IPoolable)(object)item).OnBeforePush();
			}
		}

		protected virtual void sendAfterPop(T item)
		{
			if (item is IPoolable)
			{
				((IPoolable)(object)item).OnAfterPop();
			}
		}

		protected virtual void setParent(T item, Transform parent)
		{
		}

		protected virtual T create()
		{
			return Activator.CreateInstance<T>();
		}

		protected virtual void destroy(T item)
		{
		}

		private void log(string msg)
		{
			if (Settings.Debug)
			{
				Debug.Log($"[{Identifier}] ({Count} items) {msg}");
			}
		}
	}
	[Serializable]
	public class PoolSettings
	{
		[SerializeField]
		private bool m_Prewarm;

		[SerializeField]
		private bool m_AutoCreate = true;

		[SerializeField]
		private bool m_AutoEnableDisable = true;

		[Positive]
		[SerializeField]
		private int m_MinItems;

		[Positive]
		[SerializeField]
		private int m_Threshold;

		[Positive]
		[SerializeField]
		private float m_Speed = 1f;

		public bool Debug;

		public bool Prewarm
		{
			get
			{
				return m_Prewarm;
			}
			set
			{
				if (m_Prewarm != value)
				{
					m_Prewarm = value;
				}
			}
		}

		public bool AutoCreate
		{
			get
			{
				return m_AutoCreate;
			}
			set
			{
				if (m_AutoCreate != value)
				{
					m_AutoCreate = value;
				}
			}
		}

		public bool AutoEnableDisable
		{
			get
			{
				return m_AutoEnableDisable;
			}
			set
			{
				if (m_AutoEnableDisable != value)
				{
					m_AutoEnableDisable = value;
				}
			}
		}

		public int MinItems
		{
			get
			{
				return m_MinItems;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_MinItems != num)
				{
					m_MinItems = num;
				}
			}
		}

		public int Threshold
		{
			get
			{
				return m_Threshold;
			}
			set
			{
				int num = Mathf.Max(MinItems, value);
				if (m_Threshold != num)
				{
					m_Threshold = num;
				}
			}
		}

		public float Speed
		{
			get
			{
				return m_Speed;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Speed != num)
				{
					m_Speed = num;
				}
			}
		}

		public PoolSettings()
		{
		}

		public PoolSettings(PoolSettings src)
		{
			Prewarm = src.Prewarm;
			AutoCreate = src.AutoCreate;
			MinItems = src.MinItems;
			Threshold = src.Threshold;
			Speed = src.Speed;
			Debug = src.Debug;
		}

		public void OnValidate()
		{
			MinItems = m_MinItems;
			Threshold = m_Threshold;
			Speed = m_Speed;
		}
	}
	public interface IPool
	{
		string Identifier { get; set; }

		PoolSettings Settings { get; }

		int Count { get; }

		void Clear();

		void Reset();

		void Update();
	}
	public interface IPoolable
	{
		void OnBeforePush();

		void OnAfterPop();
	}
	public static class DTTween
	{
		public enum EasingMethod
		{
			Linear,
			ExponentialIn,
			ExponentialOut,
			ExponentialInOut,
			ExponentialOutIn,
			CircularIn,
			CircularOut,
			CircularInOut,
			CircularOutIn,
			QuadraticIn,
			QuadraticOut,
			QuadraticInOut,
			QuadraticOutIn,
			SinusIn,
			SinusOut,
			SinusInOut,
			SinusOutIn,
			CubicIn,
			CubicOut,
			CubicInOut,
			CubicOutIn,
			QuarticIn,
			QuarticOut,
			QuarticInOut,
			QuarticOutIn,
			QuinticIn,
			QuinticOut,
			QuinticInOut,
			QuinticOutIn
		}

		public static float Ease(EasingMethod method, float t, float b, float c)
		{
			return method switch
			{
				EasingMethod.ExponentialIn => ExpoIn(t, b, c), 
				EasingMethod.ExponentialOut => ExpoOut(t, b, c), 
				EasingMethod.ExponentialInOut => ExpoInOut(t, b, c), 
				EasingMethod.ExponentialOutIn => ExpoOutIn(t, b, c), 
				EasingMethod.CircularIn => CircIn(t, b, c), 
				EasingMethod.CircularOut => CircOut(t, b, c), 
				EasingMethod.CircularInOut => CircInOut(t, b, c), 
				EasingMethod.CircularOutIn => CircOutIn(t, b, c), 
				EasingMethod.QuadraticIn => QuadIn(t, b, c), 
				EasingMethod.QuadraticOut => QuadOut(t, b, c), 
				EasingMethod.QuadraticInOut => QuadInOut(t, b, c), 
				EasingMethod.QuadraticOutIn => QuadOutIn(t, b, c), 
				EasingMethod.SinusIn => SineIn(t, b, c), 
				EasingMethod.SinusOut => SineOut(t, b, c), 
				EasingMethod.SinusInOut => SineInOut(t, b, c), 
				EasingMethod.SinusOutIn => SineOutIn(t, b, c), 
				EasingMethod.CubicIn => CubicIn(t, b, c), 
				EasingMethod.CubicOut => CubicOut(t, b, c), 
				EasingMethod.CubicInOut => CubicInOut(t, b, c), 
				EasingMethod.CubicOutIn => CubicOutIn(t, b, c), 
				EasingMethod.QuarticIn => QuartIn(t, b, c), 
				EasingMethod.QuarticOut => QuartOut(t, b, c), 
				EasingMethod.QuarticInOut => QuartInOut(t, b, c), 
				EasingMethod.QuarticOutIn => QuartOutIn(t, b, c), 
				EasingMethod.QuinticIn => QuintIn(t, b, c), 
				EasingMethod.QuinticOut => QuintOut(t, b, c), 
				EasingMethod.QuinticInOut => QuintInOut(t, b, c), 
				EasingMethod.QuinticOutIn => QuintOutIn(t, b, c), 
				_ => Linear(t, b, c), 
			};
		}

		public static float Ease(EasingMethod method, float t, float b, float c, float d)
		{
			return method switch
			{
				EasingMethod.ExponentialIn => ExpoIn(t, b, c, d), 
				EasingMethod.ExponentialOut => ExpoOut(t, b, c, d), 
				EasingMethod.ExponentialInOut => ExpoInOut(t, b, c, d), 
				EasingMethod.ExponentialOutIn => ExpoOutIn(t, b, c, d), 
				EasingMethod.CircularIn => CircIn(t, b, c, d), 
				EasingMethod.CircularOut => CircOut(t, b, c, d), 
				EasingMethod.CircularInOut => CircInOut(t, b, c, d), 
				EasingMethod.CircularOutIn => CircOutIn(t, b, c, d), 
				EasingMethod.QuadraticIn => QuadIn(t, b, c, d), 
				EasingMethod.QuadraticOut => QuadOut(t, b, c, d), 
				EasingMethod.QuadraticInOut => QuadInOut(t, b, c, d), 
				EasingMethod.QuadraticOutIn => QuadOutIn(t, b, c, d), 
				EasingMethod.SinusIn => SineIn(t, b, c, d), 
				EasingMethod.SinusOut => SineOut(t, b, c, d), 
				EasingMethod.SinusInOut => SineInOut(t, b, c, d), 
				EasingMethod.SinusOutIn => SineOutIn(t, b, c, d), 
				EasingMethod.CubicIn => CubicIn(t, b, c, d), 
				EasingMethod.CubicOut => CubicOut(t, b, c, d), 
				EasingMethod.CubicInOut => CubicInOut(t, b, c, d), 
				EasingMethod.CubicOutIn => CubicOutIn(t, b, c, d), 
				EasingMethod.QuarticIn => QuartIn(t, b, c, d), 
				EasingMethod.QuarticOut => QuartOut(t, b, c, d), 
				EasingMethod.QuarticInOut => QuartInOut(t, b, c, d), 
				EasingMethod.QuarticOutIn => QuartOutIn(t, b, c, d), 
				EasingMethod.QuinticIn => QuintIn(t, b, c, d), 
				EasingMethod.QuinticOut => QuintOut(t, b, c, d), 
				EasingMethod.QuinticInOut => QuintInOut(t, b, c, d), 
				EasingMethod.QuinticOutIn => QuintOutIn(t, b, c, d), 
				_ => Linear(t, b, c, d), 
			};
		}

		public static float Linear(float t, float b, float c)
		{
			return c * Mathf.Clamp01(t) + b;
		}

		public static float Linear(float t, float b, float c, float d)
		{
			return c * t / d + b;
		}

		public static float ExpoOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (t != 1f) ? (c * (0f - Mathf.Pow(2f, -10f * t) + 1f) + b) : (b + c);
		}

		public static float ExpoOut(float t, float b, float c, float d)
		{
			return (t != d) ? (c * (0f - Mathf.Pow(2f, -10f * t / d) + 1f) + b) : (b + c);
		}

		public static float ExpoIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (t != 0f) ? (c * Mathf.Pow(2f, 10f * (t - 1f)) + b) : b;
		}

		public static float ExpoIn(float t, float b, float c, float d)
		{
			return (t != 0f) ? (c * Mathf.Pow(2f, 10f * (t / d - 1f)) + b) : b;
		}

		public static float ExpoInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t == 0f)
			{
				return b;
			}
			if (t == 1f)
			{
				return b + c;
			}
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * Mathf.Pow(2f, 10f * (t - 1f)) + b;
			}
			return c / 2f * (0f - Mathf.Pow(2f, -10f * (t -= 1f)) + 2f) + b;
		}

		public static float ExpoInOut(float t, float b, float c, float d)
		{
			if (t == 0f)
			{
				return b;
			}
			if (t == d)
			{
				return b + c;
			}
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * Mathf.Pow(2f, 10f * (t - 1f)) + b;
			}
			return c / 2f * (0f - Mathf.Pow(2f, -10f * (t -= 1f)) + 2f) + b;
		}

		public static float ExpoOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return ExpoOut(t * 2f, b, c / 2f);
			}
			return ExpoIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float ExpoOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return ExpoOut(t * 2f, b, c / 2f, d);
			}
			return ExpoIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float CircOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * Mathf.Sqrt(1f - (t -= 1f) * t) + b;
		}

		public static float CircOut(float t, float b, float c, float d)
		{
			return c * Mathf.Sqrt(1f - (t = t / d - 1f) * t) + b;
		}

		public static float CircIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * (Mathf.Sqrt(1f - t * t) - 1f) + b;
		}

		public static float CircIn(float t, float b, float c, float d)
		{
			return (0f - c) * (Mathf.Sqrt(1f - (t /= d) * t) - 1f) + b;
		}

		public static float CircInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float CircInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float CircOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return CircOut(t * 2f, b, c / 2f);
			}
			return CircIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float CircOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return CircOut(t * 2f, b, c / 2f, d);
			}
			return CircIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuadOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * t * (t - 2f) + b;
		}

		public static float QuadOut(float t, float b, float c, float d)
		{
			return (0f - c) * (t /= d) * (t - 2f) + b;
		}

		public static float QuadIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t + b;
		}

		public static float QuadIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t + b;
		}

		public static float QuadInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float QuadInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float QuadOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuadOut(t * 2f, b, c / 2f);
			}
			return QuadIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuadOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuadOut(t * 2f, b, c / 2f, d);
			}
			return QuadIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float SineOut(float t, float b, float c)
		{
			return c * Mathf.Sin(Mathf.Clamp01(t) * ((float)Math.PI / 2f)) + b;
		}

		public static float SineOut(float t, float b, float c, float d)
		{
			return c * Mathf.Sin(t / d * ((float)Math.PI / 2f)) + b;
		}

		public static float SineIn(float t, float b, float c)
		{
			return (0f - c) * Mathf.Cos(Mathf.Clamp01(t) * ((float)Math.PI / 2f)) + c + b;
		}

		public static float SineIn(float t, float b, float c, float d)
		{
			return (0f - c) * Mathf.Cos(t / d * ((float)Math.PI / 2f)) + c + b;
		}

		public static float SineInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * Mathf.Sin((float)Math.PI * t / 2f) + b;
			}
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * (t -= 1f) / 2f) - 2f) + b;
		}

		public static float SineInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * Mathf.Sin((float)Math.PI * t / 2f) + b;
			}
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * (t -= 1f) / 2f) - 2f) + b;
		}

		public static float SineOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return SineOut(t * 2f, b, c / 2f);
			}
			return SineIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float SineOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return SineOut(t * 2f, b, c / 2f, d);
			}
			return SineIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float CubicOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * ((t -= 1f) * t * t + 1f) + b;
		}

		public static float CubicOut(float t, float b, float c, float d)
		{
			return c * ((t = t / d - 1f) * t * t + 1f) + b;
		}

		public static float CubicIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t + b;
		}

		public static float CubicIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t + b;
		}

		public static float CubicInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t + 2f) + b;
		}

		public static float CubicInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t + 2f) + b;
		}

		public static float CubicOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return CubicOut(t * 2f, b, c / 2f);
			}
			return CubicIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float CubicOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return CubicOut(t * 2f, b, c / 2f, d);
			}
			return CubicIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuartOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * ((t -= 1f) * t * t * t - 1f) + b;
		}

		public static float QuartOut(float t, float b, float c, float d)
		{
			return (0f - c) * ((t = t / d - 1f) * t * t * t - 1f) + b;
		}

		public static float QuartIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t * t + b;
		}

		public static float QuartIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t * t + b;
		}

		public static float QuartInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t * t + b;
			}
			return (0f - c) / 2f * ((t -= 2f) * t * t * t - 2f) + b;
		}

		public static float QuartInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t * t + b;
			}
			return (0f - c) / 2f * ((t -= 2f) * t * t * t - 2f) + b;
		}

		public static float QuartOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuartOut(t * 2f, b, c / 2f);
			}
			return QuartIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuartOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuartOut(t * 2f, b, c / 2f, d);
			}
			return QuartIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuintOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * ((t -= 1f) * t * t * t * t + 1f) + b;
		}

		public static float QuintOut(float t, float b, float c, float d)
		{
			return c * ((t = t / d - 1f) * t * t * t * t + 1f) + b;
		}

		public static float QuintIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t * t * t + b;
		}

		public static float QuintIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t * t * t + b;
		}

		public static float QuintInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t * t * t + 2f) + b;
		}

		public static float QuintInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t * t * t + 2f) + b;
		}

		public static float QuintOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuintOut(t * 2f, b, c / 2f);
			}
			return QuintIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuintOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuintOut(t * 2f, b, c / 2f, d);
			}
			return QuintIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}
	}
	public class DTObjectDump
	{
		private const int INDENTSPACES = 5;

		private string mIndent;

		private StringBuilder mSB;

		private object mObject;

		public DTObjectDump(object o, int indent = 0)
		{
			mIndent = new string(' ', indent);
			mSB = new StringBuilder();
			mObject = o;
			Type type = o.GetType();
			FieldInfo[] allFields = type.GetAllFields(includeInherited: false, includePrivate: true);
			if (allFields.Length > 0)
			{
				AppendHeader("Fields");
			}
			FieldInfo[] array = allFields;
			foreach (FieldInfo info in array)
			{
				AppendMember(info);
			}
			PropertyInfo[] allProperties = type.GetAllProperties(includeInherited: false, includePrivate: true);
			if (allProperties.Length > 0)
			{
				AppendHeader("Properties");
			}
			PropertyInfo[] array2 = allProperties;
			foreach (PropertyInfo info2 in array2)
			{
				AppendMember(info2);
			}
		}

		public override string ToString()
		{
			return mSB.ToString();
		}

		private void AppendHeader(string name)
		{
			mSB.AppendLine(mIndent + "<b>---===| " + name + " |===---</b>\n");
		}

		private void AppendMember(MemberInfo info)
		{
			Type type;
			string arg;
			object value;
			if (info is FieldInfo fieldInfo)
			{
				type = fieldInfo.FieldType;
				arg = type.Name;
				value = fieldInfo.GetValue(mObject);
			}
			else
			{
				PropertyInfo propertyInfo = info as PropertyInfo;
				type = propertyInfo.PropertyType;
				arg = type.Name;
				value = propertyInfo.GetValue(mObject, null);
			}
			if (value == null)
			{
				return;
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				string text = mIndent;
				int num = 0;
				if (value is IEnumerable enumerable)
				{
					if (type.GetEnumerableType().BaseType == typeof(ValueType))
					{
						foreach (object item in enumerable)
						{
							text += $"<b>{num++.ToString()}</b>: {item.ToString()} ";
						}
					}
					else
					{
						if (typeof(IList).IsAssignableFrom(type))
						{
							arg = string.Concat("IList<", type.GetEnumerableType(), ">");
						}
						text += "\n";
						foreach (object item2 in enumerable)
						{
							text += $"<b>{num++.ToString()}</b>: {new DTObjectDump(item2, mIndent.Length + 5).ToString()} ";
						}
					}
				}
				mSB.Append(mIndent);
				mSB.AppendFormat("(<i>{0}</i>) <b>{1}[{2}]</b> = ", arg, info.Name, num);
				mSB.AppendLine(text);
			}
			else
			{
				mSB.Append(mIndent);
				mSB.AppendFormat("(<i>{0}</i>) <b>{1}</b> = ", arg, info.Name);
				mSB.AppendLine(mIndent + value.ToString());
			}
		}
	}
	public static class DTUtility
	{
		public static bool IsEditorStateChange => false;

		public static Material GetDefaultMaterial()
		{
			return null;
		}

		public static float GetHandleSize(Vector3 position)
		{
			Camera current = Camera.current;
			position = Gizmos.matrix.MultiplyPoint(position);
			if ((bool)current)
			{
				Transform transform = current.transform;
				Vector3 position2 = transform.position;
				float z = Vector3.Dot(position - position2, transform.TransformDirection(new Vector3(0f, 0f, 1f)));
				Vector3 vector = current.WorldToScreenPoint(position2 + transform.TransformDirection(new Vector3(0f, 0f, z)));
				Vector3 vector2 = current.WorldToScreenPoint(position2 + transform.TransformDirection(new Vector3(1f, 0f, z)));
				float magnitude = (vector - vector2).magnitude;
				return 80f / Mathf.Max(magnitude, 0.0001f);
			}
			return 20f;
		}

		public static void SetPlayerPrefs<T>(string key, T value)
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsEnum)
			{
				PlayerPrefs.SetInt(key, Convert.ToInt32(Enum.Parse(typeof(T), value.ToString()) as Enum));
				return;
			}
			if (typeFromHandle.IsArray)
			{
				throw new NotImplementedException();
			}
			if (typeFromHandle.Matches(typeof(int), typeof(int)))
			{
				PlayerPrefs.SetInt(key, (value as int?).Value);
			}
			else if (typeFromHandle == typeof(string))
			{
				PlayerPrefs.SetString(key, value as string);
			}
			else if (typeFromHandle == typeof(float))
			{
				PlayerPrefs.SetFloat(key, (value as float?).Value);
			}
			else if (typeFromHandle == typeof(bool))
			{
				PlayerPrefs.SetInt(key, (value as bool?).Value ? 1 : 0);
			}
			else if (typeFromHandle == typeof(Color))
			{
				PlayerPrefs.SetString(key, (value as Color?).Value.ToHtml());
			}
			else
			{
				Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + typeFromHandle.Name);
			}
		}

		public static T GetPlayerPrefs<T>(string key, T defaultValue)
		{
			if (PlayerPrefs.HasKey(key))
			{
				Type typeFromHandle = typeof(T);
				try
				{
					if (typeFromHandle.IsEnum || typeFromHandle.Matches(typeof(int), typeof(int)))
					{
						return (T)(object)PlayerPrefs.GetInt(key, (int)(object)defaultValue);
					}
					if (typeFromHandle.IsArray)
					{
						throw new NotImplementedException();
					}
					if (typeFromHandle == typeof(string))
					{
						return (T)(object)PlayerPrefs.GetString(key, defaultValue.ToString());
					}
					if (typeFromHandle == typeof(float))
					{
						return (T)(object)PlayerPrefs.GetFloat(key, (float)(object)defaultValue);
					}
					if (typeFromHandle == typeof(bool))
					{
						return (T)(object)(PlayerPrefs.GetInt(key, ((bool)(object)defaultValue) ? 1 : 0) == 1);
					}
					if (typeFromHandle == typeof(Color))
					{
						return (T)(object)PlayerPrefs.GetString(key, ((Color)(object)defaultValue).ToHtml()).ColorFromHtml();
					}
					Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + typeFromHandle.Name);
				}
				catch
				{
					return defaultValue;
				}
			}
			return defaultValue;
		}

		public static float RandomSign()
		{
			return Random.Range(0, 2) * 2 - 1;
		}

		public static string GetHelpUrl(object forClass)
		{
			return (forClass != null) ? GetHelpUrl(forClass.GetType()) : string.Empty;
		}

		public static string GetHelpUrl(Type classType)
		{
			if (classType != null)
			{
				object[] customAttributes = classType.GetCustomAttributes(typeof(HelpURLAttribute), inherit: true);
				if (customAttributes.Length > 0)
				{
					return ((HelpURLAttribute)customAttributes[0]).URL;
				}
			}
			return string.Empty;
		}

		public static Vector3 GetCenterPosition(Vector3 fallback, params Vector3[] vectors)
		{
			if (vectors.Length == 0)
			{
				return fallback;
			}
			Vector3 vector = vectors[0];
			for (int i = 1; i < vectors.Length; i++)
			{
				vector += vectors[i];
			}
			return vector / vectors.Length;
		}

		public static T CreateGameObject<T>(Transform parent, string name) where T : MonoBehaviour
		{
			GameObject gameObject = new GameObject(name);
			gameObject.transform.parent = parent;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			return gameObject.AddComponent<T>();
		}
	}
	public static class DTTime
	{
		private static float _EditorDeltaTime;

		private static float _EditorLastTime;

		public static double TimeSinceStartup => Time.timeSinceLevelLoad;

		public static float deltaTime => (!Application.isPlaying) ? _EditorDeltaTime : Time.deltaTime;

		public static void InitializeEditorTime()
		{
			_EditorLastTime = Time.realtimeSinceStartup;
			_EditorDeltaTime = 0f;
		}

		public static void UpdateEditorTime()
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float editorDeltaTime = realtimeSinceStartup - _EditorLastTime;
			_EditorDeltaTime = editorDeltaTime;
			_EditorLastTime = realtimeSinceStartup;
		}
	}
	public class TimeMeasure : Ring<long>
	{
		public Stopwatch mWatch = new Stopwatch();

		public double LastTicks => base[base.Count - 1];

		public double LastMS => LastTicks / 10000.0;

		public double AverageMS
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i];
				}
				return DTMath.FixNaN((double)num / 10000.0 / (double)base.Count);
			}
		}

		public double MinimumMS
		{
			get
			{
				long num = long.MaxValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Min(num, base[i]);
				}
				return DTMath.FixNaN((double)num / 10000.0);
			}
		}

		public double MaximumMS
		{
			get
			{
				long num = long.MinValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Max(num, base[i]);
				}
				return DTMath.FixNaN((double)num / 10000.0);
			}
		}

		public double AverageTicks
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i];
				}
				return (double)num / (double)base.Count;
			}
		}

		public double MinimumTicks
		{
			get
			{
				long num = long.MaxValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Min(num, base[i]);
				}
				return num;
			}
		}

		public double MaximumTicks
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Max(num, base[i]);
				}
				return num;
			}
		}

		public TimeMeasure(int size)
			: base(size)
		{
		}

		public void Start()
		{
			mWatch.Start();
		}

		public void Stop()
		{
			mWatch.Stop();
			Add(mWatch.ElapsedTicks);
			mWatch.Reset();
		}

		public void Pause()
		{
			mWatch.Stop();
		}
	}
	public static class DTMath
	{
		public static Vector3 ParallelTransportFrame(Vector3 up, Vector3 tan0, Vector3 tan1)
		{
			Vector3 axis = Vector3.Cross(tan0, tan1);
			if (tan0 == -tan1)
			{
				Debug.LogWarning("[DevTools] ParallelTransportFrame's result is undefined for cases where tan0 == -tan1");
			}
			float num = Mathf.Atan2(axis.magnitude, Vector3.Dot(tan0, tan1));
			return Quaternion.AngleAxis(57.29578f * num, axis) * up;
		}

		public static Vector3 LeftTan(ref Vector3 tan, ref Vector3 up)
		{
			return Vector3.Cross(tan, up);
		}

		public static Vector3 RightTan(ref Vector3 tan, ref Vector3 up)
		{
			return Vector3.Cross(up, tan);
		}

		public static float Repeat(float t, float length)
		{
			return (t != length) ? (t - Mathf.Floor(t / length) * length) : t;
		}

		public static double FixNaN(double v)
		{
			if (double.IsNaN(v))
			{
				v = 0.0;
			}
			return v;
		}

		public static float FixNaN(float v)
		{
			if (float.IsNaN(v))
			{
				v = 0f;
			}
			return v;
		}

		public static Vector2 FixNaN(Vector2 v)
		{
			if (float.IsNaN(v.x))
			{
				v.x = 0f;
			}
			if (float.IsNaN(v.y))
			{
				v.y = 0f;
			}
			return v;
		}

		public static Vector3 FixNaN(Vector3 v)
		{
			if (float.IsNaN(v.x))
			{
				v.x = 0f;
			}
			if (float.IsNaN(v.y))
			{
				v.y = 0f;
			}
			if (float.IsNaN(v.z))
			{
				v.z = 0f;
			}
			return v;
		}

		public static float MapValue(float min, float max, float value, float vMin = -1f, float vMax = 1f)
		{
			return min + (max - min) * (value - vMin) / (vMax - vMin);
		}

		public static float SnapPrecision(float value, int decimals)
		{
			return (decimals < 0) ? value : ((float)Math.Round(value, decimals));
		}

		public static Vector2 SnapPrecision(Vector2 value, int decimals)
		{
			if (decimals < 0)
			{
				return value;
			}
			value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals));
			return value;
		}

		public static Vector3 SnapPrecision(Vector3 value, int decimals)
		{
			if (decimals < 0)
			{
				return value;
			}
			value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals), SnapPrecision(value.z, decimals));
			return value;
		}

		public static float LinePointDistanceSqr(Vector3 l1, Vector3 l2, Vector3 p, out float frag)
		{
			Vector3 vector = l2 - l1;
			Vector3 lhs = p - l1;
			float num = Vector3.Dot(lhs, vector);
			if (num <= 0f)
			{
				frag = 0f;
				return (p - l1).sqrMagnitude;
			}
			float num2 = Vector3.Dot(vector, vector);
			if (num2 <= num)
			{
				frag = 1f;
				return (p - l2).sqrMagnitude;
			}
			frag = num / num2;
			Vector3 vector2 = l1 + frag * vector;
			return (p - vector2).sqrMagnitude;
		}

		public static bool RayLineSegmentIntersection(Vector2 r0, Vector2 dir, Vector2 l1, Vector2 l2, out Vector2 hit, out float frag)
		{
			Vector2 vector = l2 - l1;
			frag = ((0f - dir.y) * (r0.x - l1.x) + dir.x * (r0.y - l1.y)) / ((0f - vector.x) * dir.y + dir.x * vector.y);
			float num = (vector.x * (r0.y - l1.y) - vector.y * (r0.x - l1.x)) / ((0f - vector.x) * dir.y + dir.x * vector.y);
			if (frag >= 0f && frag <= 1f && num > 0f)
			{
				hit = new Vector2(r0.x + num * dir.x, r0.y + num * dir.y);
				return true;
			}
			hit = Vector2.zero;
			return false;
		}

		public static bool ShortestIntersectionLine(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 resultSegmentA, out Vector3 resultSegmentB)
		{
			resultSegmentA = Vector3.zero;
			resultSegmentB = Vector3.zero;
			Vector3 vector = line1A;
			Vector3 vector2 = line2A;
			Vector3 vector3 = vector - vector2;
			Vector3 vector4 = line2B - vector2;
			if (vector4.sqrMagnitude < Mathf.Epsilon)
			{
				return false;
			}
			Vector3 vector5 = line1B - vector;
			if (vector5.sqrMagnitude < Mathf.Epsilon)
			{
				return false;
			}
			double num = (double)vector3.x * (double)vector4.x + (double)vector3.y * (double)vector4.y + (double)vector3.z * (double)vector4.z;
			double num2 = (double)vector4.x * (double)vector5.x + (double)vector4.y * (double)vector5.y + (double)vector4.z * (double)vector5.z;
			double num3 = (double)vector3.x * (double)vector5.x + (double)vector3.y * (double)vector5.y + (double)vector3.z * (double)vector5.z;
			double num4 = (double)vector4.x * (double)vector4.x + (double)vector4.y * (double)vector4.y + (double)vector4.z * (double)vector4.z;
			double num5 = (double)vector5.x * (double)vector5.x + (double)vector5.y * (double)vector5.y + (double)vector5.z * (double)vector5.z;
			double num6 = num5 * num4 - num2 * num2;
			if (Math.Abs(num6) < double.Epsilon)
			{
				return false;
			}
			double num7 = num * num2 - num3 * num4;
			double num8 = num7 / num6;
			double num9 = (num + num2 * num8) / num4;
			resultSegmentA = new Vector3((float)((double)vector.x + num8 * (double)vector5.x), (float)((double)vector.y + num8 * (double)vector5.y), (float)((double)vector.z + num8 * (double)vector5.z));
			resultSegmentB = new Vector3((float)((double)vector2.x + num9 * (double)vector4.x), (float)((double)vector2.y + num9 * (double)vector4.y), (float)((double)vector2.z + num9 * (double)vector4.z));
			return true;
		}

		public static bool LineLineIntersection(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 hitPoint)
		{
			if (ShortestIntersectionLine(line1A, line1B, line2A, line2B, out hitPoint, out var resultSegmentB) && (resultSegmentB - hitPoint).sqrMagnitude <= Mathf.Epsilon * Mathf.Epsilon)
			{
				return true;
			}
			return false;
		}

		public static bool LineLineIntersect(Vector2 line1A, Vector2 line1B, Vector2 line2A, Vector2 line2B, out Vector2 hitPoint, bool segmentOnly = true)
		{
			hitPoint = Vector2.zero;
			double num = (line2B.y - line2A.y) * (line1B.x - line1A.x) - (line2B.x - line2A.x) * (line1B.y - line1A.y);
			double num2 = (line2B.x - line2A.x) * (line1A.y - line2A.y) - (line2B.y - line2A.y) * (line1A.x - line2A.x);
			double num3 = (line1B.x - line1A.x) * (line1A.y - line2A.y) - (line1B.y - line1A.y) * (line1A.x - line2A.x);
			if (num == 0.0)
			{
				return false;
			}
			double num4 = num2 / num;
			double num5 = num3 / num;
			if (!segmentOnly || (num4 >= 0.0 && num4 <= 1.0 && num5 >= 0.0 && num5 <= 1.0))
			{
				hitPoint.Set((float)((double)line1A.x + num4 * (double)(line1B.x - line1A.x)), (float)((double)line1A.y + num4 * (double)(line1B.y - line1A.y)));
				return true;
			}
			return false;
		}

		public static bool PointInsideTriangle(Vector3 A, Vector3 B, Vector3 C, Vector3 p, out float ac, out float ab, bool edgesAllowed)
		{
			Vector3 vector = C - A;
			Vector3 vector2 = B - A;
			Vector3 rhs = p - A;
			float num = Vector3.Dot(vector, vector);
			float num2 = Vector3.Dot(vector, vector2);
			float num3 = Vector3.Dot(vector, rhs);
			float num4 = Vector3.Dot(vector2, vector2);
			float num5 = Vector3.Dot(vector2, rhs);
			float num6 = 1f / (num * num4 - num2 * num2);
			ac = (num4 * num3 - num2 * num5) * num6;
			ab = (num * num5 - num2 * num3) * num6;
			if (edgesAllowed)
			{
				return ac >= 0f && ab >= 0f && ac + ab < 1f;
			}
			return ac > 0f && ab > 0f && ac + ab < 1f;
		}
	}
	public class UnityEventEx<T0> : UnityEvent<T0>
	{
		private object mCallerList;

		private MethodInfo mCallsCount;

		private int mCount = -1;

		public void AddListenerOnce(UnityAction<T0> call)
		{
			RemoveListener(call);
			AddListener(call);
			CheckForListeners();
		}

		public bool HasListeners()
		{
			if (mCallsCount == null)
			{
				FieldInfo fieldInfo = typeof(UnityEventBase).FieldByName("m_Calls", includeInherited: false, includePrivate: true);
				if (fieldInfo != null)
				{
					mCallerList = fieldInfo.GetValue(this);
					if (mCallerList != null)
					{
						mCallsCount = mCallerList.GetType().PropertyByName("Count").GetGetMethod();
					}
				}
			}
			if (mCount == -1)
			{
				if (mCallerList != null && mCallsCount != null)
				{
					mCount = (int)mCallsCount.Invoke(mCallerList, null);
				}
				mCount += GetPersistentEventCount();
			}
			return mCount > 0;
		}

		public void CheckForListeners()
		{
			mCount = -1;
		}
	}
	public static class DTLog
	{
		public static void Log(object message)
		{
			Debug.Log(message);
		}

		public static void Log(object message, UnityEngine.Object context)
		{
			Debug.Log(message, context);
		}

		public static void LogError(object message)
		{
			Debug.LogError(message);
		}

		public static void LogError(object message, UnityEngine.Object context)
		{
			Debug.LogError(message, context);
		}

		public static void LogErrorFormat(string format, params object[] args)
		{
			Debug.LogErrorFormat(format, args);
		}

		public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
		{
			Debug.LogErrorFormat(context, format, args);
		}

		public static void LogException(Exception exception)
		{
			Debug.LogException(exception);
		}

		public static void LogException(Exception exception, UnityEngine.Object context)
		{
			Debug.LogException(exception, context);
		}

		public static void LogFormat(string format, params object[] args)
		{
			Debug.LogFormat(format, args);
		}

		public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
		{
			Debug.LogFormat(context, format, args);
		}

		public static void LogWarning(object message)
		{
			Debug.LogWarning(message);
		}

		public static void LogWarning(object message, UnityEngine.Object context)
		{
			Debug.LogWarning(message, context);
		}

		public static void LogWarningFormat(string format, params object[] args)
		{
			Debug.LogWarningFormat(format, args);
		}

		public static void LogWarningFormat(UnityEngine.Object context, string format, params object[] args)
		{
			Debug.LogWarningFormat(context, format, args);
		}
	}
	public enum DTMessageType
	{
		None,
		Info,
		Warning,
		Error
	}
	public enum AttributeOptionsFlags
	{
		None = 0,
		Compact = 1,
		Clipboard = 128,
		Zero = 256,
		One = 512,
		Negate = 1024,
		Full = 1920,
		FullCompact = 1921
	}
	public class DTPropertyAttribute : PropertyAttribute
	{
		public string Label;

		public string Tooltip;

		public string Color;

		public AttributeOptionsFlags Options;

		public int Precision = -1;

		public DTPropertyAttribute(string label = "", string tooltip = "")
		{
			Label = label;
			Tooltip = tooltip;
		}
	}
	public class LabelAttribute : DTPropertyAttribute
	{
		public LabelAttribute()
			: base(string.Empty, string.Empty)
		{
		}

		public LabelAttribute(string label, string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class ToggleButtonAttribute : DTPropertyAttribute
	{
		public ToggleButtonAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class LayerAttribute : DTPropertyAttribute
	{
		public LayerAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class TagAttribute : DTPropertyAttribute
	{
		public TagAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class VectorExAttribute : DTPropertyAttribute
	{
		public VectorExAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			Options = AttributeOptionsFlags.Full;
		}
	}
	public class AnimationCurveExAttribute : DTPropertyAttribute
	{
		public AnimationCurveExAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			Options = AttributeOptionsFlags.Clipboard;
		}
	}
	public class MinAttribute : DTPropertyAttribute
	{
		public float MinValue;

		public string MinFieldOrPropertyName;

		public MinAttribute(float value, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = value;
		}

		public MinAttribute(string fieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = fieldOrProperty;
		}
	}
	public class PositiveAttribute : MinAttribute
	{
		public PositiveAttribute()
			: base(0f, string.Empty, string.Empty)
		{
		}
	}
	public class MaxAttribute : DTPropertyAttribute
	{
		public float MaxValue;

		public string MaxFieldOrPropertyName;

		public MaxAttribute(float value, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxValue = value;
		}

		public MaxAttribute(string fieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxFieldOrPropertyName = fieldOrProperty;
		}
	}
	public class RangeExAttribute : DTPropertyAttribute
	{
		public float MinValue;

		public string MinFieldOrPropertyName;

		public float MaxValue;

		public string MaxFieldOrPropertyName;

		public bool Slider = true;

		public RangeExAttribute(float minValue, float maxValue, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = minValue;
			MaxValue = maxValue;
		}

		public RangeExAttribute(string minFieldOrProperty, float maxValue, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = minFieldOrProperty;
			MaxValue = maxValue;
		}

		public RangeExAttribute(float minValue, string maxFieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = minValue;
			MaxFieldOrPropertyName = maxFieldOrProperty;
		}

		public RangeExAttribute(string minFieldOrProperty, string maxFieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = minFieldOrProperty;
			MaxFieldOrPropertyName = maxFieldOrProperty;
		}
	}
	public class MinMaxAttribute : DTPropertyAttribute
	{
		public readonly string MaxValueField;

		public float Min;

		public string MinBoundFieldOrPropertyName;

		public float Max;

		public string MaxBoundFieldOrPropertyName;

		public MinMaxAttribute(string maxValueField, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxValueField = maxValueField;
			Min = 0f;
			Max = 1f;
		}
	}
	public class EnumFlagAttribute : DTPropertyAttribute
	{
		public EnumFlagAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class ObjectSelectorAttribute : DTPropertyAttribute
	{
		public ObjectSelectorAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class PathSelectorAttribute : DTPropertyAttribute
	{
		public enum DialogMode
		{
			OpenFile,
			OpenFolder,
			CreateFile
		}

		public readonly DialogMode Mode;

		public string Title;

		public string Directory;

		public string Extension;

		public string DefaultName;

		public PathSelectorAttribute(DialogMode mode = DialogMode.OpenFile)
			: base(string.Empty, string.Empty)
		{
			Mode = mode;
			Directory = Application.dataPath;
		}
	}
	public class EnumSelectionGridAttribute : DTPropertyAttribute
	{
		public EnumSelectionGridAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class DTRegionAttribute : DTPropertyAttribute
	{
		public bool RegionIsOptional;

		public string RegionOptionsPropertyName;

		public bool UseSlider = true;

		public DTRegionAttribute()
			: base(string.Empty, string.Empty)
		{
		}
	}
	public class FloatRegionAttribute : DTRegionAttribute
	{
	}
	public class IntRegionAttribute : DTRegionAttribute
	{
	}
	public struct RegionOptions<T>
	{
		public string LabelFrom;

		public string LabelTo;

		public string OptionalTooltip;

		public DTValueClamping ClampFrom;

		public DTValueClamping ClampTo;

		public T FromMin;

		public T FromMax;

		public T ToMin;

		public T ToMax;

		public static RegionOptions<T> Default
		{
			get
			{
				RegionOptions<T> result = default(RegionOptions<T>);
				result.OptionalTooltip = "Range";
				result.LabelFrom = "From";
				result.LabelTo = "To";
				result.ClampFrom = DTValueClamping.None;
				result.ClampTo = DTValueClamping.None;
				return result;
			}
		}

		public static RegionOptions<T> MinMax(T min, T max)
		{
			RegionOptions<T> result = default(RegionOptions<T>);
			result.LabelFrom = "From";
			result.LabelTo = "To";
			result.ClampFrom = DTValueClamping.Range;
			result.ClampTo = DTValueClamping.Range;
			result.FromMin = min;
			result.FromMax = max;
			result.ToMin = min;
			result.ToMax = max;
			return result;
		}
	}
	public enum DTValueClamping
	{
		None,
		Min,
		Max,
		Range
	}
	public class ThreadPoolWorker<T> : IDisposable
	{
		private readonly SimplePool<QueuedCallback> queuedCallbackPool = new SimplePool<QueuedCallback>(4);

		private readonly SimplePool<LoopState<T>> loopStatePool = new SimplePool<LoopState<T>>(4);

		private int _remainingWorkItems = 1;

		private ManualResetEvent _done = new ManualResetEvent(initialState: false);

		private WaitCallback handleWorkItemCallBack;

		private WaitCallback handleLoopCallBack;

		public ThreadPoolWorker()
		{
			handleWorkItemCallBack = delegate(object o)
			{
				QueuedCallback queuedCallback = (QueuedCallback)o;
				try
				{
					queuedCallback.Callback(queuedCallback.State);
				}
				finally
				{
					lock (queuedCallbackPool)
					{
						queuedCallbackPool.ReleaseItem(queuedCallback);
					}
					DoneWorkItem();
				}
			};
			handleLoopCallBack = delegate(object state)
			{
				LoopState<T> loopState = (LoopState<T>)state;
				for (int i = loopState.StartIndex; i <= loopState.EndIndex; i++)
				{
					loopState.Action(loopState.Items[i]);
				}
				lock (loopStatePool)
				{
					loopStatePool.ReleaseItem(loopState);
				}
			};
		}

		public void ParralelFor(Action<T> action, List<T> list)
		{
			int val = Environment.ProcessorCount - 1;
			int num = 1 + Math.Min(val, Environment.ProcessorCount - 1);
			int count = list.Count;
			int num2 = ((num != 1) ? ((int)Math.Ceiling((float)count / (float)num)) : count);
			int num3 = 0;
			while (num3 < count)
			{
				int num4 = Math.Min(num3 + num2 - 1, count - 1);
				if (num4 == count - 1)
				{
					for (int i = num3; i <= num4; i++)
					{
						action(list[i]);
					}
				}
				else
				{
					QueuedCallback item;
					lock (queuedCallbackPool)
					{
						item = queuedCallbackPool.GetItem();
					}
					LoopState<T> item2;
					lock (loopStatePool)
					{
						item2 = loopStatePool.GetItem();
					}
					item2.StartIndex = (short)num3;
					item2.EndIndex = (short)num4;
					item2.Action = action;
					item2.Items = list;
					item.State = item2;
					item.Callback = handleLoopCallBack;
					ThrowIfDisposed();
					lock (_done)
					{
						_remainingWorkItems++;
					}
					ThreadPool.QueueUserWorkItem(handleWorkItemCallBack, item);
				}
				num3 = num4 + 1;
			}
			WaitAll(-1, exitContext: false);
		}

		private bool WaitAll(int millisecondsTimeout, bool exitContext)
		{
			ThrowIfDisposed();
			DoneWorkItem();
			bool flag = _done.WaitOne(millisecondsTimeout, exitContext);
			lock (_done)
			{
				if (flag)
				{
					_remainingWorkItems = 1;
					_done.Reset();
				}
				else
				{
					_remainingWorkItems++;
				}
			}
			return flag;
		}

		private void ThrowIfDisposed()
		{
			if (_done == null)
			{
				throw new ObjectDisposedException(GetType().Name);
			}
		}

		private void DoneWorkItem()
		{
			lock (_done)
			{
				_remainingWorkItems--;
				if (_remainingWorkItems == 0)
				{
					_done.Set();
				}
			}
		}

		public void Dispose()
		{
			if (_done != null)
			{
				((IDisposable)_done).Dispose();
				_done = null;
			}
		}
	}
	internal class SimplePool<T> where T : new()
	{
		private readonly List<T> freeItemsBackfield;

		public SimplePool(int preCreatedElementsCount)
		{
			freeItemsBackfield = new List<T>();
			for (int i = 0; i < preCreatedElementsCount; i++)
			{
				freeItemsBackfield.Add(new T());
			}
		}

		public T GetItem()
		{
			T result;
			if (freeItemsBackfield.Count == 0)
			{
				result = new T();
			}
			else
			{
				int index = freeItemsBackfield.Count - 1;
				result = freeItemsBackfield[index];
				freeItemsBackfield.RemoveAt(index);
			}
			return result;
		}

		public void ReleaseItem(T item)
		{
			freeItemsBackfield.Add(item);
		}
	}
	internal class QueuedCallback
	{
		public WaitCallback Callback;

		public object State;
	}
	internal class LoopState<T>
	{
		public short StartIndex;

		public short EndIndex;

		public List<T> Items;

		public Action<T> Action;
	}
	public class ThreadPoolWorker : IDisposable
	{
		private int _remainingWorkItems = 1;

		private ManualResetEvent _done = new ManualResetEvent(initialState: false);

		public void QueueWorkItem(WaitCallback callback)
		{
			QueueWorkItem(callback, null);
		}

		public void QueueWorkItem(Action act)
		{
			QueueWorkItem(act, null);
		}

		public void ParralelFor<T>(Action<T> action, List<T> list)
		{
			int val = Environment.ProcessorCount - 1;
			int num = 1 + Math.Min(val, Environment.ProcessorCount - 1);
			int count = list.Count;
			if (num == 1 || count == 1)
			{
				for (int i = 0; i < count; i++)
				{
					action(list[i]);
				}
				return;
			}
			int num2 = (int)Math.Ceiling((float)count / (float)num);
			int num3 = 0;
			while (num3 < count)
			{
				QueuedCallback queuedCallback = new QueuedCallback();
				int num4 = Math.Min(num3 + num2, count - 1);
				LoopState<T> loopState = new LoopState<T>();
				loopState.StartIndex = (short)num3;
				loopState.EndIndex = (short)num4;
				loopState.Action = action;
				loopState.Items = list;
				queuedCallback.State = loopState;
				queuedCallback.Callback = delegate(object state)
				{
					LoopState<T> loopState2 = (LoopState<T>)state;
					for (int j = loopState2.StartIndex; j <= loopState2.EndIndex; j++)
					{
						loopState2.Action(loopState2.Items[j]);
					}
				};
				QueueWorkItem(queuedCallback);
				num3 = num4 + 1;
			}
		}

		private void QueueWorkItem(QueuedCallback callback)
		{
			ThrowIfDisposed();
			lock (_done)
			{
				_remainingWorkItems++;
			}
			ThreadPool.QueueUserWorkItem(HandleWorkItem, callback);
		}

		public void QueueWorkItem(WaitCallback callback, object state)
		{
			QueuedCallback queuedCallback = new QueuedCallback();
			queuedCallback.Callback = callback;
			queuedCallback.State = state;
			QueueWorkItem(queuedCallback);
		}

		public void QueueWorkItem(Action act, object state)
		{
			QueuedCallback queuedCallback = new QueuedCallback();
			queuedCallback.Callback = delegate
			{
				act();
			};
			queuedCallback.State = state;
			QueueWorkItem(queuedCallback);
		}

		public bool WaitAll()
		{
			return WaitAll(-1, exitContext: false);
		}

		public bool WaitAll(TimeSpan timeout, bool exitContext)
		{
			return WaitAll((int)timeout.TotalMilliseconds, exitContext);
		}

		public bool WaitAll(int millisecondsTimeout, bool exitContext)
		{
			ThrowIfDisposed();
			DoneWorkItem();
			bool flag = _done.WaitOne(millisecondsTimeout, exitContext);
			lock (_done)
			{
				if (flag)
				{
					_remainingWorkItems = 1;
					_done.Reset();
				}
				else
				{
					_remainingWorkItems++;
				}
			}
			return flag;
		}

		private void HandleWorkItem(object state)
		{
			QueuedCallback queuedCallback = (QueuedCallback)state;
			try
			{
				queuedCallback.Callback(queuedCallback.State);
			}
			finally
			{
				DoneWorkItem();
			}
		}

		private void DoneWorkItem()
		{
			lock (_done)
			{
				_remainingWorkItems--;
				if (_remainingWorkItems == 0)
				{
					_done.Set();
				}
			}
		}

		private void ThrowIfDisposed()
		{
			if (_done == null)
			{
				throw new ObjectDisposedException(GetType().Name);
			}
		}

		public void Dispose()
		{
			if (_done != null)
			{
				((IDisposable)_done).Dispose();
				_done = null;
			}
		}
	}
	public class ComponentPool : MonoBehaviour, IPool, ISerializationCallbackReceiver
	{
		[SerializeField]
		[HideInInspector]
		private string m_Identifier;

		[Inline]
		[SerializeField]
		private PoolSettings m_Settings;

		private PoolManager mManager;

		private List<Component> mObjects = new List<Component>();

		private double mLastTime;

		private double mDeltaTime;

		public PoolSettings Settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				if (m_Settings != value)
				{
					m_Settings = value;
				}
				if (m_Settings != null)
				{
					m_Settings.OnValidate();
				}
			}
		}

		public PoolManager Manager
		{
			get
			{
				if (mManager == null)
				{
					mManager = GetComponent<PoolManager>();
				}
				return mManager;
			}
		}

		public string Identifier
		{
			get
			{
				return m_Identifier;
			}
			set
			{
				throw new InvalidOperationException("Component pool's identifier should always indicate the pooled type's assembly qualified name");
			}
		}

		public Type Type
		{
			get
			{
				Type type = Type.GetType(Identifier);
				if (type == null)
				{
					DTLog.LogWarning("[DevTools] ComponentPool's Type is an unknown type " + m_Identifier);
				}
				return type;
			}
		}

		public int Count => mObjects.Count;

		public void Initialize(Type type, PoolSettings settings)
		{
			m_Identifier = type.AssemblyQualifiedName;
			m_Settings = settings;
			mLastTime = DTTime.TimeSinceStartup + (double)Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		private void Start()
		{
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnDisable()
		{
		}

		public void Update()
		{
			if (!Application.isPlaying)
			{
				return;
			}
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Threshold exceeded: Deleting item");
						}
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
					}
				}
				else
				{
					if (Count >= Settings.MinItems)
					{
						return;
					}
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Below MinItems: Adding item");
						}
						mObjects.Add(create());
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				if (Settings.Debug)
				{
					log("Prewarm/Reset");
				}
			}
		}

		public void OnSceneLoaded(Scene scn, LoadSceneMode mode)
		{
			for (int num = mObjects.Count - 1; num >= 0; num--)
			{
				if (mObjects[num] == null)
				{
					mObjects.RemoveAt(num);
				}
			}
		}

		public void Clear()
		{
			if (Settings.Debug)
			{
				log("Clear");
			}
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public void Push(Component item)
		{
			sendBeforePush(item);
			if (item != null)
			{
				mObjects.Add(item);
				item.transform.parent = Manager.transform;
				item.gameObject.hideFlags = ((!Settings.Debug) ? HideFlags.HideAndDontSave : HideFlags.DontSave);
				if (Settings.AutoEnableDisable)
				{
					item.gameObject.SetActive(value: false);
				}
			}
		}

		public Component Pop(Transform parent = null)
		{
			Component component = null;
			if (Count > 0)
			{
				component = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				if (Settings.Debug)
				{
					log("Auto create item");
				}
				component = create();
			}
			if ((bool)component)
			{
				component.gameObject.hideFlags = HideFlags.None;
				component.transform.parent = parent;
				if (Settings.AutoEnableDisable)
				{
					component.gameObject.SetActive(value: true);
				}
				sendAfterPop(component);
				if (Settings.Debug)
				{
					log("Pop " + component);
				}
			}
			return component;
		}

		public T Pop<T>(Transform parent) where T : Component
		{
			return Pop(parent) as T;
		}

		private Component create()
		{
			GameObject gameObject = new GameObject();
			gameObject.name = Identifier;
			gameObject.transform.parent = Manager.transform;
			if (Settings.AutoEnableDisable)
			{
				gameObject.SetActive(value: false);
			}
			return gameObject.AddComponent(Type);
		}

		private void destroy(Component item)
		{
			if (item != null)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}

		private void setParent(Component item, Transform parent)
		{
			if (item != null)
			{
				item.transform.parent = parent;
			}
		}

		private void sendAfterPop(Component item)
		{
			GameObject gameObject = item.gameObject;
			if (gameObject.activeSelf && gameObject.activeInHierarchy)
			{
				gameObject.SendMessage("OnAfterPop", SendMessageOptions.DontRequireReceiver);
			}
			else if (item is IPoolable)
			{
				((IPoolable)item).OnAfterPop();
			}
			else
			{
				DTLog.LogWarning("[Curvy] sendAfterPop could not send message because the receiver " + item.name + " is not active");
			}
		}

		private void sendBeforePush(Component item)
		{
			GameObject gameObject = item.gameObject;
			if (gameObject.activeSelf && gameObject.activeInHierarchy)
			{
				gameObject.SendMessage("OnBeforePush", SendMessageOptions.DontRequireReceiver);
			}
			else if (item is IPoolable)
			{
				((IPoolable)item).OnBeforePush();
			}
			else
			{
				DTLog.LogWarning("[Curvy] sendBeforePush could not send message because the receiver " + item.name + " is not active");
			}
		}

		private void log(string msg)
		{
			Debug.Log($"[{Identifier}] ({Count} items) {msg}");
		}

		public void OnBeforeSerialize()
		{
		}

		public void OnAfterDeserialize()
		{
			if (Type.GetType(m_Identifier) != null)
			{
				return;
			}
			string[] array = m_Identifier.Split(',');
			if (array.Length >= 5)
			{
				string typeName = string.Join(",", array.SubArray(0, array.Length - 4));
				Type[] loadedTypes = TypeExt.GetLoadedTypes();
				Type type = loadedTypes.FirstOrDefault((Type t) => t.FullName == typeName);
				if (type != null)
				{
					m_Identifier = type.AssemblyQualifiedName;
				}
			}
		}
	}
	public class DTSingleton<T> : MonoBehaviour, IDTSingleton where T : MonoBehaviour, IDTSingleton
	{
		private static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		private bool isDuplicateInstance;

		public static bool HasInstance => _instance != null;

		public static T Instance
		{
			get
			{
				if (!Application.isPlaying)
				{
					applicationIsQuitting = false;
				}
				if (applicationIsQuitting)
				{
					return (T)null;
				}
				if (_instance == null)
				{
					lock (_lock)
					{
						if (_instance == null)
						{
							UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(typeof(T));
							_instance = ((array.Length < 1) ? new GameObject().AddComponent<T>() : ((T)array[0]));
						}
					}
				}
				return _instance;
			}
		}

		public virtual void Awake()
		{
			T instance = Instance;
			lock (_lock)
			{
				if (GetInstanceID() != instance.GetInstanceID())
				{
					instance.MergeDoubleLoaded(this);
					isDuplicateInstance = true;
					Invoke("DestroySelf", 0f);
				}
			}
		}

		protected virtual void OnDestroy()
		{
			lock (_lock)
			{
				if (Application.isPlaying && !isDuplicateInstance)
				{
					applicationIsQuitting = true;
					_instance = (T)null;
				}
			}
		}

		public virtual void MergeDoubleLoaded(IDTSingleton newInstance)
		{
		}

		private void DestroySelf()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public interface IDTSingleton
	{
		void MergeDoubleLoaded(IDTSingleton newInstance);
	}
	public class DTVersionedMonoBehaviour : MonoBehaviour
	{
		[SerializeField]
		[HideInInspector]
		private string m_Version;

		public string Version
		{
			get
			{
				return m_Version;
			}
			protected set
			{
				m_Version = value;
			}
		}

		[Obsolete("This upgrading mechanism is tied to the Editor. Meaning it does not work when in Play mode. A better way to handle upgrading would be to use Unity's ISerializationCallbackReceiver")]
		protected void CheckForVersionUpgrade()
		{
		}

		[Obsolete("This upgrading mechanism is tied to the Editor. Meaning it does not work when in Play mode. A better way to handle upgrading would be to use Unity's ISerializationCallbackReceiver")]
		protected virtual bool UpgradeVersion(string oldVersion, string newVersion)
		{
			if (string.IsNullOrEmpty(oldVersion))
			{
				Debug.LogFormat("[{0}] Upgrading '{1}' to version {2}! PLEASE SAVE THE SCENE!", GetType().Name, base.name, newVersion);
			}
			else
			{
				Debug.LogFormat("[{0}] Upgrading '{1}' from version {2} to {3}! PLEASE SAVE THE SCENE!", GetType().Name, base.name, oldVersion, newVersion);
			}
			return true;
		}

		public void Destroy()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}
	}
	[ExecuteInEditMode]
	public class DuplicateEditorMesh : MonoBehaviour
	{
		private MeshFilter mFilter;

		public MeshFilter Filter
		{
			get
			{
				if (mFilter == null)
				{
					mFilter = GetComponent<MeshFilter>();
				}
				return mFilter;
			}
		}

		protected virtual void Awake()
		{
			if (Application.isPlaying)
			{
				return;
			}
			MeshFilter filter = Filter;
			if (!filter || !(filter.sharedMesh != null))
			{
				return;
			}
			DuplicateEditorMesh[] array = UnityEngine.Object.FindObjectsOfType<DuplicateEditorMesh>();
			DuplicateEditorMesh[] array2 = array;
			foreach (DuplicateEditorMesh duplicateEditorMesh in array2)
			{
				if (duplicateEditorMesh != this)
				{
					MeshFilter filter2 = duplicateEditorMesh.Filter;
					if ((bool)filter2 && filter2.sharedMesh == filter.sharedMesh)
					{
						Mesh mesh = new Mesh();
						mesh.name = filter2.sharedMesh.name;
						filter.mesh = mesh;
					}
				}
			}
		}
	}
	public class InspectorNote : MonoBehaviour
	{
		[TextArea(5, 20)]
		[SerializeField]
		private string m_Note;
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	public class PoolManager : MonoBehaviour
	{
		[Section("General", true, false, 100)]
		[SerializeField]
		private bool m_AutoCreatePools = true;

		[AsGroup(null, Expanded = false)]
		[SerializeField]
		private PoolSettings m_DefaultSettings = new PoolSettings();

		public Dictionary<string, IPool> Pools = new Dictionary<string, IPool>();

		public Dictionary<Type, IPool> TypePools = new Dictionary<Type, IPool>();

		private IPool[] mPools = new IPool[0];

		public bool AutoCreatePools
		{
			get
			{
				return m_AutoCreatePools;
			}
			set
			{
				if (m_AutoCreatePools != value)
				{
					m_AutoCreatePools = value;
				}
			}
		}

		public PoolSettings DefaultSettings
		{
			get
			{
				return m_DefaultSettings;
			}
			set
			{
				if (m_DefaultSettings != value)
				{
					m_DefaultSettings = value;
				}
				if (m_DefaultSettings != null)
				{
					m_DefaultSettings.OnValidate();
				}
			}
		}

		public bool IsInitialized { get; private set; }

		public int Count => Pools.Count + TypePools.Count;

		private void OnDisable()
		{
			IsInitialized = false;
		}

		private void Update()
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			if (mPools.Length != TypePools.Count)
			{
				Array.Resize(ref mPools, TypePools.Count);
				TypePools.Values.CopyTo(mPools, 0);
			}
			for (int i = 0; i < mPools.Length; i++)
			{
				mPools[i].Update();
			}
		}

		private void Initialize()
		{
			Pools.Clear();
			IPool[] components = GetComponents<IPool>();
			IPool[] array = components;
			foreach (IPool pool in array)
			{
				if (pool is ComponentPool)
				{
					if (!Pools.ContainsKey(pool.Identifier))
					{
						Pools.Add(pool.Identifier, pool);
						continue;
					}
					DTLog.Log("[DevTools] Found a duplicated ComponentPool for type " + pool.Identifier + ". The duplicated pool will be destroyed");
					UnityEngine.Object.Destroy(pool as ComponentPool);
				}
				else
				{
					pool.Identifier = GetUniqueIdentifier(pool.Identifier);
					Pools.Add(pool.Identifier, pool);
				}
			}
			IsInitialized = true;
		}

		public string GetUniqueIdentifier(string ident)
		{
			int num = 0;
			string text = ident;
			while (Pools.ContainsKey(text))
			{
				int num2 = ++num;
				text = ident + num2;
			}
			return text;
		}

		public Pool<T> GetTypePool<T>()
		{
			IPool value = null;
			if (!TypePools.TryGetValue(typeof(T), out value) && AutoCreatePools)
			{
				value = CreateTypePool<T>();
			}
			return (Pool<T>)value;
		}

		public ComponentPool GetComponentPool<T>() where T : Component
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			IPool value = null;
			if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out value) && AutoCreatePools)
			{
				value = CreateComponentPool<T>();
			}
			return (ComponentPool)value;
		}

		public PrefabPool GetPrefabPool(string identifier, params GameObject[] prefabs)
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			if (!Pools.TryGetValue(identifier, out var value) && AutoCreatePools)
			{
				value = CreatePrefabPool(identifier, null, prefabs);
			}
			return (PrefabPool)value;
		}

		public Pool<T> CreateTypePool<T>(PoolSettings settings = null)
		{
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!TypePools.TryGetValue(typeof(T), out value))
			{
				value = new Pool<T>(settings2);
				TypePools.Add(typeof(T), value);
			}
			return (Pool<T>)value;
		}

		public ComponentPool CreateComponentPool<T>(PoolSettings settings = null) where T : Component
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out value))
			{
				value = base.gameObject.AddComponent<ComponentPool>();
				((ComponentPool)value).Initialize(typeof(T), settings2);
				Pools.Add(value.Identifier, value);
			}
			return (ComponentPool)value;
		}

		public PrefabPool CreatePrefabPool(string name, PoolSettings settings = null, params GameObject[] prefabs)
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!Pools.TryGetValue(name, out value))
			{
				PrefabPool prefabPool = base.gameObject.AddComponent<PrefabPool>();
				prefabPool.Initialize(name, settings2, prefabs);
				Pools.Add(name, prefabPool);
				return prefabPool;
			}
			return (PrefabPool)value;
		}

		public List<IPool> FindPools(string identifierStartsWith)
		{
			List<IPool> list = new List<IPool>();
			foreach (KeyValuePair<string, IPool> pool in Pools)
			{
				if (pool.Key.StartsWith(identifierStartsWith))
				{
					list.Add(pool.Value);
				}
			}
			return list;
		}

		public void DeletePools(string startsWith)
		{
			List<IPool> list = FindPools(startsWith);
			for (int num = list.Count - 1; num >= 0; num--)
			{
				DeletePool(list[num]);
			}
		}

		public void DeletePool(IPool pool)
		{
			if (pool is PrefabPool || pool is ComponentPool)
			{
				UnityEngine.Object.Destroy((MonoBehaviour)pool);
				Pools.Remove(pool.Identifier);
			}
		}

		public void DeletePool<T>()
		{
			TypePools.Remove(typeof(T));
		}
	}
	[RequireComponent(typeof(PoolManager))]
	public class PrefabPool : MonoBehaviour, IPool
	{
		[FieldCondition("m_Identifier", "", false, ActionAttribute.ActionEnum.ShowWarning, "Please enter an identifier! (Select a prefab to set automatically)", ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private string m_Identifier;

		[SerializeField]
		private List<GameObject> m_Prefabs = new List<GameObject>();

		[Inline]
		[SerializeField]
		private PoolSettings m_Settings;

		private PoolManager mManager;

		private List<GameObject> mObjects = new List<GameObject>();

		private double mLastTime;

		private double mDeltaTime;

		public string Identifier
		{
			get
			{
				return m_Identifier;
			}
			set
			{
				if (m_Identifier != value)
				{
					string ident = value;
					if (string.IsNullOrEmpty(m_Identifier))
					{
						ident = Manager.GetUniqueIdentifier(ident);
					}
					m_Identifier = value;
				}
			}
		}

		public List<GameObject> Prefabs
		{
			get
			{
				return m_Prefabs;
			}
			set
			{
				if (m_Prefabs != value)
				{
					m_Prefabs = value;
				}
			}
		}

		public PoolSettings Settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				if (m_Settings != value)
				{
					m_Settings = value;
				}
				if (m_Settings != null)
				{
					m_Settings.OnValidate();
				}
			}
		}

		public PoolManager Manager
		{
			get
			{
				if (mManager == null)
				{
					mManager = GetComponent<PoolManager>();
				}
				return mManager;
			}
		}

		public int Count => mObjects.Count;

		private void Awake()
		{
		}

		private void Start()
		{
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Initialize(string ident, PoolSettings settings, params GameObject[] prefabs)
		{
			Identifier = ident;
			m_Settings = settings;
			Prefabs = new List<GameObject>(prefabs);
			mLastTime = DTTime.TimeSinceStartup + (double)Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Update()
		{
			if (!Application.isPlaying)
			{
				return;
			}
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Threshold exceeded: Deleting item");
						}
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
					}
				}
				else
				{
					if (Count >= Settings.MinItems)
					{
						return;
					}
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Below MinItems: Adding item");
						}
						mObjects.Add(create());
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				if (Settings.Debug)
				{
					log("Prewarm/Reset");
				}
			}
		}

		public void Clear()
		{
			if (Settings.Debug)
			{
				log("Clear");
			}
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public GameObject Pop(Transform parent = null)
		{
			GameObject gameObject = null;
			if (Count > 0)
			{
				gameObject = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				if (Settings.Debug)
				{
					log("Auto create item");
				}
				gameObject = create();
			}
			if ((bool)gameObject)
			{
				gameObject.gameObject.hideFlags = HideFlags.None;
				gameObject.transform.parent = parent;
				if (Settings.AutoEnableDisable)
				{
					gameObject.SetActive(value: true);
				}
				sendAfterPop(gameObject);
				if (Settings.Debug)
				{
					log("Pop " + gameObject);
				}
			}
			return gameObject;
		}

		public virtual void Push(GameObject item)
		{
			if (Settings.Debug)
			{
				log("Push " + item);
			}
			if (item != null)
			{
				sendBeforePush(item);
				mObjects.Add(item);
				item.transform.parent = base.transform;
				item.gameObject.hideFlags = ((!Settings.Debug) ? HideFlags.HideAndDontSave : HideFlags.DontSave);
				if (Settings.AutoEnableDisable)
				{
					item.SetActive(value: false);
				}
			}
		}

		private GameObject create()
		{
			GameObject gameObject = null;
			if (Prefabs.Count > 0)
			{
				GameObject gameObject2 = Prefabs[Random.Range(0, Prefabs.Count)];
				gameObject = UnityEngine.Object.Instantiate(gameObject2);
				gameObject.name = gameObject2.name;
				gameObject.transform.parent = base.transform;
				if (Settings.AutoEnableDisable)
				{
					gameObject.SetActive(value: false);
				}
			}
			return gameObject;
		}

		private void destroy(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		private void log(string msg)
		{
			Debug.Log($"[{Identifier}] ({Count} items) {msg}");
		}

		private void setParent(Transform item, Transform parent)
		{
			if (item != null)
			{
				item.parent = parent;
			}
		}

		private void sendAfterPop(GameObject item)
		{
			item.SendMessage("OnAfterPop", SendMessageOptions.DontRequireReceiver);
		}

		private void sendBeforePush(GameObject item)
		{
			item.SendMessage("OnBeforePush", SendMessageOptions.DontRequireReceiver);
		}
	}
}
namespace FluffyUnderware.DevTools.Extensions
{
	public static class TransformExt
	{
		public static void CopyFrom(this Transform t, Transform other)
		{
			t.position = other.position;
			t.rotation = other.rotation;
			t.localScale = other.localScale;
		}

		public static void SetChildrenHideFlags(this Transform t, HideFlags flags)
		{
			if (t != null)
			{
				int childCount = t.childCount;
				for (int i = 0; i < childCount; i++)
				{
					t.GetChild(i).hideFlags = flags;
				}
			}
		}
	}
	public static class ObjectExt
	{
		public static void Destroy(this UnityEngine.Object c)
		{
			UnityEngine.Object.Destroy(c);
		}

		public static string ToDumpString(this object o)
		{
			return new DTObjectDump(o).ToString();
		}
	}
	public static class Vector2Ext
	{
		public static Vector2 Snap(this Vector2 v, float snapX, float snapY = -1f)
		{
			if (snapY == -1f)
			{
				snapY = snapX;
			}
			return new Vector2(v.x - v.x % snapX, v.y - v.y % snapY);
		}

		public static float AngleSigned(this Vector2 a, Vector2 b)
		{
			float num = Mathf.Sign(a.x * b.y - a.y * b.x);
			return Vector2.Angle(a, b) * num;
		}

		public static Vector2 LeftNormal(this Vector2 v)
		{
			return new Vector2(0f - v.y, v.x);
		}

		public static Vector2 RightNormal(this Vector2 v)
		{
			return new Vector2(v.y, 0f - v.x);
		}

		public static Vector2 Rotate(this Vector2 v, float degree)
		{
			float f = degree * ((float)Math.PI / 180f);
			float num = Mathf.Cos(f);
			float num2 = Mathf.Sin(f);
			return new Vector2(num * v.x - num2 * v.y, num2 * v.x + num * v.y);
		}

		public static Vector2 ToVector3(this Vector2 v)
		{
			return new Vector3(v.x, v.y, 0f);
		}
	}
	public static class Vector3Ext
	{
		public static float AngleSigned(this Vector3 a, Vector3 b, Vector3 normal)
		{
			return Mathf.Atan2(Vector3.Dot(normal, Vector3.Cross(a, b)), Vector3.Dot(a, b)) * 57.29578f;
		}

		public static Vector3 RotateAround(this Vector3 point, Vector3 origin, Quaternion rotation)
		{
			Vector3 vector = point - origin;
			vector = rotation * vector;
			return origin + vector;
		}

		public static Vector2 ToVector2(this Vector3 v)
		{
			return new Vector2(v.x, v.y);
		}

		public static bool Approximately(this Vector3 v1, Vector3 v2)
		{
			return Vector3.SqrMagnitude(v1 - v2) < 1E-06f;
		}

		public static bool NotApproximately(this Vector3 v1, Vector3 v2)
		{
			return !v1.Approximately(v2);
		}
	}
	public static class QuaternionExt
	{
		public static bool SameOrientation(this Quaternion q1, Quaternion q2)
		{
			return Math.Abs((double)Quaternion.Dot(q1, q2)) > 0.999998986721039;
		}

		public static bool DifferentOrientation(this Quaternion q1, Quaternion q2)
		{
			return Math.Abs((double)Quaternion.Dot(q1, q2)) <= 0.999998986721039;
		}
	}
	public static class CameraExt
	{
		private static Plane[] camPlanes = new Plane[6];

		private static Vector3 camPos;

		private static Vector3 camForward;

		private static float fov;

		private static float screenW;

		private static float screenH;

		public static bool BoundsInView(this Camera c, Bounds bounds)
		{
			if (camPos != c.transform.position || camForward != c.transform.forward || screenW != (float)Screen.width || screenH != (float)Screen.height || fov != c.fieldOfView)
			{
				camPos = c.transform.position;
				camForward = c.transform.forward;
				screenW = Screen.width;
				screenH = Screen.height;
				fov = c.fieldOfView;
				GeometryUtility.CalculateFrustumPlanes(c, camPlanes);
			}
			return GeometryUtility.TestPlanesAABB(camPlanes, bounds);
		}

		public static bool BoundsPartiallyInView(this Camera c, Bounds bounds)
		{
			Plane[] planes = GeometryUtility.CalculateFrustumPlanes(c);
			Vector3 zero = Vector3.zero;
			Vector3 center = bounds.center;
			Vector3 extents = bounds.extents;
			zero.Set(center.x - extents.x, center.y + extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y + extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y - extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y - extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y + extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y + extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y - extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y - extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			return false;
		}
	}
	public static class GameObjectExt
	{
		public static GameObject DuplicateGameObject(this GameObject source, Transform newParent, bool keepPrefabReference = false)
		{
			if (!source)
			{
				return null;
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.parent = newParent;
			}
			return gameObject;
		}

		public static void StripComponents(this GameObject go, params Type[] toKeep)
		{
			List<Type> list = new List<Type>(toKeep);
			list.Add(typeof(Transform));
			list.Add(typeof(RectTransform));
			Component[] components = go.GetComponents<Component>();
			for (int i = 0; i < components.Length; i++)
			{
				if (!list.Contains(components[i].GetType()))
				{
					if (!Application.isPlaying)
					{
						UnityEngine.Object.DestroyImmediate(components[i]);
					}
					else
					{
						UnityEngine.Object.Destroy(components[i]);
					}
				}
			}
		}
	}
	public static class ComponentExt
	{
		public static void StripComponents(this Component c, params Type[] toKeep)
		{
			if (toKeep.Length == 0)
			{
				c.gameObject.StripComponents(c.GetType());
			}
			else
			{
				c.gameObject.StripComponents(toKeep);
			}
		}

		public static GameObject AddChildGameObject(this Component c, string name)
		{
			GameObject gameObject = new GameObject(name);
			gameObject.transform.SetParent(c.transform);
			return gameObject;
		}

		public static T AddChildGameObject<T>(this Component c, string name) where T : Component
		{
			GameObject gameObject = new GameObject(name);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(c.transform);
				return gameObject.AddComponent<T>();
			}
			return (T)null;
		}

		public static T DuplicateGameObject<T>(this Component source, Transform newParent, bool keepPrefabConnection = false) where T : Component
		{
			if (!source || !source.gameObject)
			{
				return (T)null;
			}
			List<Component> list = new List<Component>(source.gameObject.GetComponents<Component>());
			int num = list.IndexOf(source);
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(newParent, worldPositionStays: false);
				Component[] components = gameObject.GetComponents<Component>();
				return components[num] as T;
			}
			return (T)null;
		}

		public static Component DuplicateGameObject(this Component source, Transform newParent, bool keepPrefabConnection = false)
		{
			if (!source || !source.gameObject || !newParent)
			{
				return null;
			}
			List<Component> list = new List<Component>(source.gameObject.GetComponents<Component>());
			int num = list.IndexOf(source);
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(newParent, worldPositionStays: false);
				Component[] components = gameObject.GetComponents<Component>();
				return components[num];
			}
			return null;
		}
	}
	public static class ColorExt
	{
		public static string ToHtml(this Color c)
		{
			Color32 color = c;
			return $"#{color.r:X2}{color.g:X2}{color.b:X2}{color.a:X2}";
		}
	}
	public static class EnumExt
	{
		public static bool HasFlag(this Enum variable, params Enum[] flags)
		{
			if (flags.Length == 0)
			{
				throw new ArgumentNullException("flags");
			}
			int num = Convert.ToInt32(variable);
			Type type = variable.GetType();
			for (int i = 0; i < flags.Length; i++)
			{
				if (!Enum.IsDefined(type, flags[i]))
				{
					throw new ArgumentException($"Enumeration type mismatch.  The flag is of type '{flags[i].GetType()}', was expecting '{type}'.");
				}
				int num2 = Convert.ToInt32(flags[i]);
				if ((num & num2) == num2)
				{
					return true;
				}
			}
			return false;
		}

		public static bool HasFlag<T>(this T value, T flag) where T : struct
		{
			long num = Convert.ToInt64(value);
			long num2 = Convert.ToInt64(flag);
			return (num & num2) != 0;
		}

		public static T Set<T>(this Enum value, T append)
		{
			return value.Set(append, OnOff: true);
		}

		public static T Set<T>(this Enum value, T append, bool OnOff)
		{
			if (append == null)
			{
				throw new ArgumentNullException("append");
			}
			Type type = value.GetType();
			if (OnOff)
			{
				return (T)Enum.Parse(type, (Convert.ToUInt64(value) | Convert.ToUInt64(append)).ToString());
			}
			return (T)Enum.Parse(type, (Convert.ToUInt64(value) & ~Convert.ToUInt64(append)).ToString());
		}

		public static T Toggle<T>(this Enum value, T toggleValue)
		{
			if (toggleValue == null)
			{
				throw new ArgumentNullException("toggleValue");
			}
			Type type = value.GetType();
			ulong num = Convert.ToUInt64(value);
			return (T)Enum.Parse(type, (num ^ num).ToString());
		}

		public static T SetAll<T>(this Enum value)
		{
			Type type = value.GetType();
			string[] names = Enum.GetNames(type);
			string[] array = names;
			foreach (string value2 in array)
			{
				value.Set(Enum.Parse(type, value2));
			}
			return (T)(object)value;
		}
	}
	public static class RectExt
	{
		public static Rect Set(this Rect rect, Vector2 pos, Vector2 size)
		{
			rect.Set(pos.x, pos.y, size.x, size.y);
			return new Rect(rect);
		}

		public static Rect SetBetween(this Rect rect, Vector2 pos, Vector2 pos2)
		{
			rect.Set(pos.x, pos.y, pos2.x - pos.x, pos2.y - pos.y);
			return new Rect(rect);
		}

		public static Rect SetPosition(this Rect rect, Vector2 pos)
		{
			rect.x = pos.x;
			rect.y = pos.y;
			return new Rect(rect);
		}

		public static Rect SetPosition(this Rect rect, float x, float y)
		{
			rect.x = x;
			rect.y = y;
			return new Rect(rect);
		}

		public static Vector2 GetSize(this Rect rect)
		{
			return new Vector2(rect.width, rect.height);
		}

		public static Rect SetSize(this Rect rect, Vector2 size)
		{
			rect.width = size.x;
			rect.height = size.y;
			return new Rect(rect);
		}

		public static Rect ScaleBy(this Rect rect, int pixel)
		{
			return rect.ScaleBy(pixel, pixel);
		}

		public static Rect ScaleBy(this Rect rect, int x, int y)
		{
			rect.x -= x;
			rect.y -= y;
			rect.width += (float)x * 2f;
			rect.height += (float)y * 2f;
			return new Rect(rect);
		}

		public static Rect ShiftBy(this Rect rect, int x, int y)
		{
			rect.x += x;
			rect.y += y;
			return new Rect(rect);
		}

		public static Rect Include(this Rect rect, Rect other)
		{
			Rect result = default(Rect);
			result.xMin = Mathf.Min(rect.xMin, other.xMin);
			result.xMax = Mathf.Max(rect.xMax, other.xMax);
			result.yMin = Mathf.Min(rect.yMin, other.yMin);
			result.yMax = Mathf.Max(rect.yMax, other.yMax);
			return result;
		}
	}
	public static class StringExt
	{
		public static Color ColorFromHtml(this string hexString)
		{
			if (hexString.Length < 9)
			{
				hexString += "FF";
			}
			if (hexString.StartsWith("#") && hexString.Length == 9)
			{
				int[] array = new int[4];
				try
				{
					array[0] = int.Parse(hexString.Substring(1, 2), NumberStyles.HexNumber);
					array[1] = int.Parse(hexString.Substring(3, 2), NumberStyles.HexNumber);
					array[2] = int.Parse(hexString.Substring(5, 2), NumberStyles.HexNumber);
					array[3] = int.Parse(hexString.Substring(7, 2), NumberStyles.HexNumber);
					return new Color((float)array[0] / 255f, (float)array[1] / 255f, (float)array[2] / 255f, (float)array[3] / 255f);
				}
				catch
				{
					return Color.white;
				}
			}
			return Color.white;
		}

		public static string TrimStart(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
		{
			if (!s.StartsWith(trim, compare))
			{
				return s;
			}
			return s.Substring(trim.Length);
		}

		public static string TrimEnd(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
		{
			if (!s.EndsWith(trim, compare))
			{
				return s;
			}
			return s.Substring(0, s.Length - trim.Length);
		}
	}
	public static class IEnumerableExt
	{
		public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
		{
			foreach (T item in ie)
			{
				action(item);
			}
		}
	}
	public static class ArrayExt
	{
		public static T[] SubArray<T>(this T[] data, int index, int length)
		{
			length = Mathf.Clamp(length, 0, data.Length - index);
			T[] array = new T[length];
			if (length > 0)
			{
				Array.Copy(data, index, array, 0, length);
			}
			return array;
		}

		public static T[] RemoveAt<T>(this T[] source, int index)
		{
			T[] array = new T[source.Length - 1];
			if (index > 0)
			{
				Array.Copy(source, 0, array, 0, index);
			}
			if (index < source.Length - 1)
			{
				Array.Copy(source, index + 1, array, index, source.Length - index - 1);
			}
			return array;
		}

		public static T[] InsertAt<T>(this T[] source, int index)
		{
			T[] array = new T[source.Length + 1];
			index = Mathf.Clamp(index, 0, source.Length - 1);
			if (index > 0)
			{
				Array.Copy(source, 0, array, 0, index);
			}
			Array.Copy(source, index, array, index + 1, source.Length - index);
			return array;
		}

		public static T[] Swap<T>(this T[] source, int index, int with)
		{
			index = Mathf.Clamp(index, 0, source.Length - 1);
			with = Mathf.Clamp(index, 0, source.Length - 1);
			T val = source[index];
			source[index] = source[with];
			source[with] = val;
			return source;
		}

		public static T[] Add<T>(this T[] source, T item)
		{
			Array.Resize(ref source, source.Length + 1);
			source[source.Length - 1] = item;
			return source;
		}

		public static T[] AddRange<T>(this T[] source, T[] items)
		{
			Array.Resize(ref source, source.Length + items.Length);
			Array.Copy(items, 0, source, source.Length - items.Length, items.Length);
			return source;
		}

		public static T[] RemoveDuplicates<T>(this T[] source)
		{
			List<T> list = new List<T>();
			HashSet<T> hashSet = new HashSet<T>();
			foreach (T item in source)
			{
				if (hashSet.Add(item))
				{
					list.Add(item);
				}
			}
			return list.ToArray();
		}

		public static int IndexOf<T>(this T[] source, T item)
		{
			for (int i = 0; i < source.Length; i++)
			{
				if (source[i].Equals(item))
				{
					return i;
				}
			}
			return -1;
		}

		public static T[] Remove<T>(this T[] source, T item)
		{
			int num = source.IndexOf(item);
			if (num > -1)
			{
				return source.RemoveAt(num);
			}
			return source;
		}
	}
	public static class MeshFilterExt
	{
		public static Mesh PrepareNewShared(this MeshFilter m, string name = "Mesh")
		{
			if (m == null)
			{
				return null;
			}
			if (m.sharedMesh == null)
			{
				Mesh mesh = new Mesh();
				mesh.MarkDynamic();
				mesh.name = name;
				m.sharedMesh = mesh;
			}
			else
			{
				m.sharedMesh.Clear();
				m.sharedMesh.name = name;
				m.sharedMesh.subMeshCount = 0;
			}
			return m.sharedMesh;
		}

		public static void CalculateTangents(this MeshFilter m)
		{
			int[] triangles = m.sharedMesh.triangles;
			Vector3[] vertices = m.sharedMesh.vertices;
			Vector2[] uv = m.sharedMesh.uv;
			Vector3[] normals = m.sharedMesh.normals;
			if (uv.Length != 0)
			{
				int num = triangles.Length;
				int num2 = vertices.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				Vector4[] array3 = new Vector4[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = vertices[num3];
					Vector3 vector2 = vertices[num4];
					Vector3 vector3 = vertices[num5];
					Vector2 vector4 = uv[num3];
					Vector2 vector5 = uv[num4];
					Vector2 vector6 = uv[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					float num17 = ((num16 != 0f) ? (1f / num16) : 0f);
					float num18 = (num15 * num6 - num14 * num7) * num17;
					float num19 = (num15 * num8 - num14 * num9) * num17;
					float num20 = (num15 * num10 - num14 * num11) * num17;
					float num21 = (num12 * num7 - num13 * num6) * num17;
					float num22 = (num12 * num9 - num13 * num8) * num17;
					float num23 = (num12 * num11 - num13 * num10) * num17;
					array[num3].x += num18;
					array[num3].y += num19;
					array[num3].z += num20;
					array[num4].x += num18;
					array[num4].y += num19;
					array[num4].z += num20;
					array[num5].x += num18;
					array[num5].y += num19;
					array[num5].z += num20;
					array2[num3].x += num21;
					array2[num3].y += num22;
					array2[num3].z += num23;
					array2[num4].x += num21;
					array2[num4].y += num22;
					array2[num4].z += num23;
					array2[num5].x += num21;
					array2[num5].y += num22;
					array2[num5].z += num23;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 normal = normals[j];
					Vector3 tangent = array[j];
					Vector3.OrthoNormalize(ref normal, ref tangent);
					array3[j].x = tangent.x;
					array3[j].y = tangent.y;
					array3[j].z = tangent.z;
					float num24 = (normal.y * tangent.z - normal.z * tangent.y) * array2[j].x + (normal.z * tangent.x - normal.x * tangent.z) * array2[j].y + (normal.x * tangent.y - normal.y * tangent.x) * array2[j].z;
					array3[j].w = ((!(num24 < 0f)) ? 1f : (-1f));
				}
				m.sharedMesh.tangents = array3;
			}
		}
	}
	public static class TypeExt
	{
		[Obsolete("Use GetLoadedTypes() instead")]
		public static Type[] GetAllTypes(this Type typeFromAssembly)
		{
			return typeFromAssembly.Assembly.GetTypes();
		}

		public static Type[] GetLoadedTypes()
		{
			return GetLoadedAssemblies().SelectMany((Assembly a) => a.GetTypes()).ToArray();
		}

		public static IEnumerable<Assembly> GetLoadedAssemblies()
		{
			return AppDomain.CurrentDomain.GetAssemblies();
		}

		public static Dictionary<U, Type> GetAllTypesWithAttribute<U>(this Type type)
		{
			Dictionary<U, Type> dictionary = new Dictionary<U, Type>();
			Type[] loadedTypes = GetLoadedTypes();
			Type[] array = loadedTypes;
			foreach (Type type2 in array)
			{
				if (type2.IsSubclassOf(type))
				{
					object[] customAttributes = type2.GetCustomAttributes(typeof(U), inherit: false);
					if (customAttributes.Length > 0)
					{
						dictionary.Add((U)customAttributes[0], type2);
					}
				}
			}
			return dictionary;
		}

		public static List<FieldInfo> GetFieldsWithAttribute<T>(this Type type, bool includeInherited = false, bool includePrivate = false) where T : Attribute
		{
			FieldInfo[] allFields = type.GetAllFields(includeInherited, includePrivate);
			List<FieldInfo> list = new List<FieldInfo>();
			FieldInfo[] array = allFields;
			foreach (FieldInfo fieldInfo in array)
			{
				if (fieldInfo.GetCustomAttribute<T>() != null)
				{
					list.Add(fieldInfo);
				}
			}
			return list;
		}

		public static T GetCustomAttribute<T>(this Type type) where T : Attribute
		{
			object[] customAttributes = type.GetCustomAttributes(typeof(T), inherit: true);
			return (customAttributes.Length <= 0) ? ((T)null) : ((T)customAttributes[0]);
		}

		public static MethodInfo MethodByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetMethodIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetMethod(name, bindingFlags);
		}

		public static FieldInfo FieldByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetFieldIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetField(name, bindingFlags);
		}

		public static PropertyInfo PropertyByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetPropertyIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetProperty(name, bindingFlags);
		}

		public static FieldInfo[] GetAllFields(this Type type, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				Type type2 = type;
				List<FieldInfo> list = new List<FieldInfo>();
				while (type2 != typeof(object))
				{
					list.AddRange(type2.GetFields(bindingFlags));
					type2 = type2.BaseType;
				}
				return list.ToArray();
			}
			return type.GetFields(bindingFlags);
		}

		public static PropertyInfo[] GetAllProperties(this Type type, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				Type type2 = type;
				List<PropertyInfo> list = new List<PropertyInfo>();
				while (type2 != typeof(object))
				{
					list.AddRange(type2.GetProperties(bindingFlags));
					type2 = type2.BaseType;
				}
				return list.ToArray();
			}
			return type.GetProperties(bindingFlags);
		}

		public static bool IsFrameworkType(this Type type)
		{
			return type.IsPrimitive || type.Equals(typeof(string)) || type.Equals(typeof(DateTime));
		}

		public static bool IsArrayOrList(this Type type)
		{
			return type.IsArray || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>));
		}

		public static Type GetEnumerableType(this Type t)
		{
			Type type = FindIEnumerable(t);
			if (type == null)
			{
				return t;
			}
			return type.GetGenericArguments()[0];
		}

		private static Type FindIEnumerable(Type seqType)
		{
			if (seqType == null || seqType == typeof(string))
			{
				return null;
			}
			if (seqType.IsArray)
			{
				return typeof(IEnumerable<>).MakeGenericType(seqType.GetElementType());
			}
			if (seqType.IsGenericType)
			{
				Type[] genericArguments = seqType.GetGenericArguments();
				foreach (Type type in genericArguments)
				{
					Type type2 = typeof(IEnumerable<>).MakeGenericType(type);
					if (type2.IsAssignableFrom(seqType))
					{
						return type2;
					}
				}
			}
			Type[] interfaces = seqType.GetInterfaces();
			if (interfaces != null && interfaces.Length > 0)
			{
				Type[] array = interfaces;
				foreach (Type seqType2 in array)
				{
					Type type3 = FindIEnumerable(seqType2);
					if (type3 != null)
					{
						return type3;
					}
				}
			}
			if (seqType.BaseType != null && seqType.BaseType != typeof(object))
			{
				return FindIEnumerable(seqType.BaseType);
			}
			return null;
		}

		private static MethodInfo GetMethodIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			MethodInfo method = type.GetMethod(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return method;
			}
			for (Type type2 = type; type2 != typeof(object); type2 = type2.BaseType)
			{
				method = type2.GetMethod(name, bindingFlags);
				if (method != null)
				{
					return method;
				}
			}
			return null;
		}

		private static FieldInfo GetFieldIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			FieldInfo field = type.GetField(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return field;
			}
			for (Type type2 = type; type2 != typeof(object); type2 = type2.BaseType)
			{
				field = type2.GetField(name, bindingFlags);
				if (field != null)
				{
					return field;
				}
			}
			return null;
		}

		private static PropertyInfo GetPropertyIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			PropertyInfo property = type.GetProperty(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return property;
			}
			for (Type type2 = type; type2 != typeof(object); type2 = type2.BaseType)
			{
				property = type2.GetProperty(name, bindingFlags);
				if (property != null)
				{
					return property;
				}
			}
			return null;
		}

		public static bool Matches(this Type type, params Type[] types)
		{
			foreach (Type type2 in types)
			{
				if (type == type2 || type.IsAssignableFrom(type2))
				{
					return true;
				}
			}
			return false;
		}
	}
	public static class FieldInfoExt
	{
		public static T GetCustomAttribute<T>(this FieldInfo field) where T : Attribute
		{
			object[] customAttributes = field.GetCustomAttributes(typeof(T), inherit: true);
			return (customAttributes.Length <= 0) ? ((T)null) : ((T)customAttributes[0]);
		}
	}
}
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
	internal class Dict<TValue> where TValue : class
	{
		public class Node
		{
			internal TValue _key;

			internal Node _prev;

			internal Node _next;

			public TValue Key => _key;

			public Node Prev => _prev;

			public Node Next => _next;
		}

		public delegate bool LessOrEqual(TValue lhs, TValue rhs);

		private LessOrEqual _leq;

		private Node _head;

		public Dict(LessOrEqual leq)
		{
			_leq = leq;
			_head = new Node
			{
				_key = (TValue)null
			};
			_head._prev = _head;
			_head._next = _head;
		}

		public Node Insert(TValue key)
		{
			return InsertBefore(_head, key);
		}

		public Node InsertBefore(Node node, TValue key)
		{
			do
			{
				node = node._prev;
			}
			while (node._key != null && !_leq(node._key, key));
			Node node2 = new Node();
			node2._key = key;
			Node node3 = node2;
			node3._next = node._next;
			node._next._prev = node3;
			node3._prev = node;
			node._next = node3;
			return node3;
		}

		public Node Find(TValue key)
		{
			Node node = _head;
			do
			{
				node = node._next;
			}
			while (node._key != null && !_leq(key, node._key));
			return node;
		}

		public Node Min()
		{
			return _head._next;
		}

		public void Remove(Node node)
		{
			node._next._prev = node._prev;
			node._prev._next = node._next;
		}
	}
	internal static class Geom
	{
		public static bool IsWindingInside(WindingRule rule, int n)
		{
			return rule switch
			{
				WindingRule.EvenOdd => (n & 1) == 1, 
				WindingRule.NonZero => n != 0, 
				WindingRule.Positive => n > 0, 
				WindingRule.Negative => n < 0, 
				WindingRule.AbsGeqTwo => n >= 2 || n <= -2, 
				_ => throw new Exception("Wrong winding rule"), 
			};
		}

		public static bool VertCCW(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			return u._s * (v._t - w._t) + v._s * (w._t - u._t) + w._s * (u._t - v._t) >= 0f;
		}

		public static bool VertEq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			return lhs._s == rhs._s && lhs._t == rhs._t;
		}

		public static bool VertLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			return lhs._s < rhs._s || (lhs._s == rhs._s && lhs._t <= rhs._t);
		}

		public static float EdgeEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._s - u._s;
			float num2 = w._s - v._s;
			if (num + num2 > 0f)
			{
				if (num < num2)
				{
					return v._t - u._t + (u._t - w._t) * (num / (num + num2));
				}
				return v._t - w._t + (w._t - u._t) * (num2 / (num + num2));
			}
			return 0f;
		}

		public static float EdgeSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._s - u._s;
			float num2 = w._s - v._s;
			if (num + num2 > 0f)
			{
				return (v._t - w._t) * num + (v._t - u._t) * num2;
			}
			return 0f;
		}

		public static bool TransLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			return lhs._t < rhs._t || (lhs._t == rhs._t && lhs._s <= rhs._s);
		}

		public static float TransEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._t - u._t;
			float num2 = w._t - v._t;
			if (num + num2 > 0f)
			{
				if (num < num2)
				{
					return v._s - u._s + (u._s - w._s) * (num / (num + num2));
				}
				return v._s - w._s + (w._s - u._s) * (num2 / (num + num2));
			}
			return 0f;
		}

		public static float TransSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._t - u._t;
			float num2 = w._t - v._t;
			if (num + num2 > 0f)
			{
				return (v._s - w._s) * num + (v._s - u._s) * num2;
			}
			return 0f;
		}

		public static bool EdgeGoesLeft(MeshUtils.Edge e)
		{
			return VertLeq(e._Dst, e._Org);
		}

		public static bool EdgeGoesRight(MeshUtils.Edge e)
		{
			return VertLeq(e._Org, e._Dst);
		}

		public static float VertL1dist(MeshUtils.Vertex u, MeshUtils.Vertex v)
		{
			return Math.Abs(u._s - v._s) + Math.Abs(u._t - v._t);
		}

		public static void AddWinding(MeshUtils.Edge eDst, MeshUtils.Edge eSrc)
		{
			eDst._winding += eSrc._winding;
			eDst._Sym._winding += eSrc._Sym._winding;
		}

		public static float Interpolate(float a, float x, float b, float y)
		{
			if (a < 0f)
			{
				a = 0f;
			}
			if (b < 0f)
			{
				b = 0f;
			}
			return (!(a <= b)) ? (y + (x - y) * (b / (a + b))) : ((b != 0f) ? (x + (y - x) * (a / (a + b))) : ((x + y) / 2f));
		}

		private static void Swap(ref MeshUtils.Vertex a, ref MeshUtils.Vertex b)
		{
			MeshUtils.Vertex vertex = a;
			a = b;
			b = vertex;
		}

		public static void EdgeIntersect(MeshUtils.Vertex o1, MeshUtils.Vertex d1, MeshUtils.Vertex o2, MeshUtils.Vertex d2, MeshUtils.Vertex v)
		{
			if (!VertLeq(o1, d1))
			{
				Swap(ref o1, ref d1);
			}
			if (!VertLeq(o2, d2))
			{
				Swap(ref o2, ref d2);
			}
			if (!VertLeq(o1, o2))
			{
				Swap(ref o1, ref o2);
				Swap(ref d1, ref d2);
			}
			if (!VertLeq(o2, d1))
			{
				v._s = (o2._s + d1._s) / 2f;
			}
			else if (VertLeq(d1, d2))
			{
				float num = EdgeEval(o1, o2, d1);
				float num2 = EdgeEval(o2, d1, d2);
				if (num + num2 < 0f)
				{
					num = 0f - num;
					num2 = 0f - num2;
				}
				v._s = Interpolate(num, o2._s, num2, d1._s);
			}
			else
			{
				float num3 = EdgeSign(o1, o2, d1);
				float num4 = 0f - EdgeSign(o1, d2, d1);
				if (num3 + num4 < 0f)
				{
					num3 = 0f - num3;
					num4 = 0f - num4;
				}
				v._s = Interpolate(num3, o2._s, num4, d2._s);
			}
			if (!TransLeq(o1, d1))
			{
				Swap(ref o1, ref d1);
			}
			if (!TransLeq(o2, d2))
			{
				Swap(ref o2, ref d2);
			}
			if (!TransLeq(o1, o2))
			{
				Swap(ref o1, ref o2);
				Swap(ref d1, ref d2);
			}
			if (!TransLeq(o2, d1))
			{
				v._t = (o2._t + d1._t) / 2f;
			}
			else if (TransLeq(d1, d2))
			{
				float num5 = TransEval(o1, o2, d1);
				float num6 = TransEval(o2, d1, d2);
				if (num5 + num6 < 0f)
				{
					num5 = 0f - num5;
					num6 = 0f - num6;
				}
				v._t = Interpolate(num5, o2._t, num6, d1._t);
			}
			else
			{
				float num7 = TransSign(o1, o2, d1);
				float num8 = 0f - TransSign(o1, d2, d1);
				if (num7 + num8 < 0f)
				{
					num7 = 0f - num7;
					num8 = 0f - num8;
				}
				v._t = Interpolate(num7, o2._t, num8, d2._t);
			}
		}
	}
	internal class LTMesh : MeshUtils.Pooled<LTMesh>
	{
		internal MeshUtils.Vertex _vHead;

		internal MeshUtils.Face _fHead;

		internal MeshUtils.Edge _eHead;

		internal MeshUtils.Edge _eHeadSym;

		public LTMesh()
		{
			MeshUtils.Vertex vertex = (_vHead = MeshUtils.Pooled<MeshUtils.Vertex>.Create());
			MeshUtils.Face face = (_fHead = MeshUtils.Pooled<MeshUtils.Face>.Create());
			MeshUtils.EdgePair edgePair = MeshUtils.EdgePair.Create();
			MeshUtils.Edge edge = (_eHead = edgePair._e);
			MeshUtils.Edge edge2 = (_eHeadSym = edgePair._eSym);
			vertex._next = (vertex._prev = vertex);
			vertex._anEdge = null;
			face._next = (face._prev = face);
			face._anEdge = null;
			face._trail = null;
			face._marked = false;
			face._inside = false;
			edge._next = edge;
			edge._Sym = edge2;
			edge._Onext = null;
			edge._Lnext = null;
			edge._Org = null;
			edge._Lface = null;
			edge._winding = 0;
			edge._activeRegion = null;
			edge2._next = edge2;
			edge2._Sym = edge;
			edge2._Onext = null;
			edge2._Lnext = null;
			edge2._Org = null;
			edge2._Lface = null;
			edge2._winding = 0;
			edge2._activeRegion = null;
		}

		public override void Reset()
		{
			_vHead = null;
			_fHead = null;
			_eHead = (_eHeadSym = null);
		}

		public override void OnFree()
		{
			MeshUtils.Face face = _fHead._next;
			MeshUtils.Face fHead = _fHead;
			while (face != _fHead)
			{
				fHead = face._next;
				face.Free();
				face = fHead;
			}
			MeshUtils.Vertex vertex = _vHead._next;
			MeshUtils.Vertex vHead = _vHead;
			while (vertex != _vHead)
			{
				vHead = vertex._next;
				vertex.Free();
				vertex = vHead;
			}
			MeshUtils.Edge edge = _eHead._next;
			MeshUtils.Edge eHead = _eHead;
			while (edge != _eHead)
			{
				eHead = edge._next;
				edge.Free();
				edge = eHead;
			}
		}

		public MeshUtils.Edge MakeEdge()
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(_eHead);
			MeshUtils.MakeVertex(edge, _vHead);
			MeshUtils.MakeVertex(edge._Sym, _vHead);
			MeshUtils.MakeFace(edge, _fHead);
			return edge;
		}

		public void Splice(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
		{
			if (eOrg != eDst)
			{
				bool flag = false;
				if (eDst._Org != eOrg._Org)
				{
					flag = true;
					MeshUtils.KillVertex(eDst._Org, eOrg._Org);
				}
				bool flag2 = false;
				if (eDst._Lface != eOrg._Lface)
				{
					flag2 = true;
					MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
				}
				MeshUtils.Splice(eDst, eOrg);
				if (!flag)
				{
					MeshUtils.MakeVertex(eDst, eOrg._Org);
					eOrg._Org._anEdge = eOrg;
				}
				if (!flag2)
				{
					MeshUtils.MakeFace(eDst, eOrg._Lface);
					eOrg._Lface._anEdge = eOrg;
				}
			}
		}

		public void Delete(MeshUtils.Edge eDel)
		{
			MeshUtils.Edge sym = eDel._Sym;
			bool flag = false;
			if (eDel._Lface != eDel._Rface)
			{
				flag = true;
				MeshUtils.KillFace(eDel._Lface, eDel._Rface);
			}
			if (eDel._Onext == eDel)
			{
				MeshUtils.KillVertex(eDel._Org, null);
			}
			else
			{
				eDel._Rface._anEdge = eDel._Oprev;
				eDel._Org._anEdge = eDel._Onext;
				MeshUtils.Splice(eDel, eDel._Oprev);
				if (!flag)
				{
					MeshUtils.MakeFace(eDel, eDel._Lface);
				}
			}
			if (sym._Onext == sym)
			{
				MeshUtils.KillVertex(sym._Org, null);
				MeshUtils.KillFace(sym._Lface, null);
			}
			else
			{
				eDel._Lface._anEdge = sym._Oprev;
				sym._Org._anEdge = sym._Onext;
				MeshUtils.Splice(sym, sym._Oprev);
			}
			MeshUtils.KillEdge(eDel);
		}

		public MeshUtils.Edge AddEdgeVertex(MeshUtils.Edge eOrg)
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(eOrg);
			MeshUtils.Edge sym = edge._Sym;
			MeshUtils.Splice(edge, eOrg._Lnext);
			edge._Org = eOrg._Dst;
			MeshUtils.MakeVertex(sym, edge._Org);
			edge._Lface = (sym._Lface = eOrg._Lface);
			return edge;
		}

		public MeshUtils.Edge SplitEdge(MeshUtils.Edge eOrg)
		{
			MeshUtils.Edge edge = AddEdgeVertex(eOrg);
			MeshUtils.Edge sym = edge._Sym;
			MeshUtils.Splice(eOrg._Sym, eOrg._Sym._Oprev);
			MeshUtils.Splice(eOrg._Sym, sym);
			eOrg._Dst = sym._Org;
			sym._Dst._anEdge = sym._Sym;
			sym._Rface = eOrg._Rface;
			sym._winding = eOrg._winding;
			sym._Sym._winding = eOrg._Sym._winding;
			return sym;
		}

		public MeshUtils.Edge Connect(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(eOrg);
			MeshUtils.Edge sym = edge._Sym;
			bool flag = false;
			if (eDst._Lface != eOrg._Lface)
			{
				flag = true;
				MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
			}
			MeshUtils.Splice(edge, eOrg._Lnext);
			MeshUtils.Splice(sym, eDst);
			edge._Org = eOrg._Dst;
			sym._Org = eDst._Org;
			edge._Lface = (sym._Lface = eOrg._Lface);
			eOrg._Lface._anEdge = sym;
			if (!flag)
			{
				MeshUtils.MakeFace(edge, eOrg._Lface);
			}
			return edge;
		}

		public void ZapFace(MeshUtils.Face fZap)
		{
			MeshUtils.Edge anEdge = fZap._anEdge;
			MeshUtils.Edge lnext = anEdge._Lnext;
			MeshUtils.Edge edge;
			do
			{
				edge = lnext;
				lnext = edge._Lnext;
				edge._Lface = null;
				if (edge._Rface == null)
				{
					if (edge._Onext == edge)
					{
						MeshUtils.KillVertex(edge._Org, null);
					}
					else
					{
						edge._Org._anEdge = edge._Onext;
						MeshUtils.Splice(edge, edge._Oprev);
					}
					MeshUtils.Edge sym = edge._Sym;
					if (sym._Onext == sym)
					{
						MeshUtils.KillVertex(sym._Org, null);
					}
					else
					{
						sym._Org._anEdge = sym._Onext;
						MeshUtils.Splice(sym, sym._Oprev);
					}
					MeshUtils.KillEdge(edge);
				}
			}
			while (edge != anEdge);
			MeshUtils.Face prev = fZap._prev;
			MeshUtils.Face next = fZap._next;
			next._prev = prev;
			prev._next = next;
			fZap.Free();
		}

		public void MergeConvexFaces(int maxVertsPerFace)
		{
			for (MeshUtils.Face next = _fHead._next; next != _fHead; next = next._next)
			{
				if (next._inside)
				{
					MeshUtils.Edge edge = next._anEdge;
					MeshUtils.Vertex org = edge._Org;
					while (true)
					{
						MeshUtils.Edge lnext = edge._Lnext;
						MeshUtils.Edge sym = edge._Sym;
						if (sym != null && sym._Lface != null && sym._Lface._inside)
						{
							int vertsCount = next.VertsCount;
							int vertsCount2 = sym._Lface.VertsCount;
							if (vertsCount + vertsCount2 - 2 <= maxVertsPerFace && Geom.VertCCW(edge._Lprev._Org, edge._Org, sym._Lnext._Lnext._Org) && Geom.VertCCW(sym._Lprev._Org, sym._Org, edge._Lnext._Lnext._Org))
							{
								lnext = sym._Lnext;
								Delete(sym);
								edge = null;
							}
						}
						if (edge != null && edge._Lnext._Org == org)
						{
							break;
						}
						edge = lnext;
					}
				}
			}
		}

		[System.Diagnostics.Conditional("DEBUG")]
		public void Check()
		{
			MeshUtils.Face fHead = _fHead;
			fHead = _fHead;
			MeshUtils.Face next;
			MeshUtils.Edge edge;
			while ((next = fHead._next) != _fHead)
			{
				edge = next._anEdge;
				do
				{
					edge = edge._Lnext;
				}
				while (edge != next._anEdge);
				fHead = next;
			}
			MeshUtils.Vertex vHead = _vHead;
			vHead = _vHead;
			MeshUtils.Vertex next2;
			while ((next2 = vHead._next) != _vHead)
			{
				edge = next2._anEdge;
				do
				{
					edge = edge._Onext;
				}
				while (edge != next2._anEdge);
				vHead = next2;
			}
			MeshUtils.Edge eHead = _eHead;
			eHead = _eHead;
			while ((edge = eHead._next) != _eHead)
			{
				eHead = edge;
			}
		}
	}
	public struct Vec3
	{
		public static readonly Vec3 Zero = default(Vec3);

		public float X;

		public float Y;

		public float Z;

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => X, 
					1 => Y, 
					2 => Z, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					X = value;
					break;
				case 1:
					Y = value;
					break;
				case 2:
					Z = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public static void Sub(ref Vec3 lhs, ref Vec3 rhs, out Vec3 result)
		{
			result.X = lhs.X - rhs.X;
			result.Y = lhs.Y - rhs.Y;
			result.Z = lhs.Z - rhs.Z;
		}

		public static void Neg(ref Vec3 v)
		{
			v.X = 0f - v.X;
			v.Y = 0f - v.Y;
			v.Z = 0f - v.Z;
		}

		public static void Dot(ref Vec3 u, ref Vec3 v, out float dot)
		{
			dot = u.X * v.X + u.Y * v.Y + u.Z * v.Z;
		}

		public static void Normalize(ref Vec3 v)
		{
			float num = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
			num = 1f / (float)Math.Sqrt(num);
			v.X *= num;
			v.Y *= num;
			v.Z *= num;
		}

		public static int LongAxis(ref Vec3 v)
		{
			int num = 0;
			if (Math.Abs(v.Y) > Math.Abs(v.X))
			{
				num = 1;
			}
			if (Math.Abs(v.Z) > Math.Abs((num != 0) ? v.Y : v.X))
			{
				num = 2;
			}
			return num;
		}

		public override string ToString()
		{
			return $"{X}, {Y}, {Z}";
		}
	}
	internal static class MeshUtils
	{
		public abstract class Pooled<T> where T : Pooled<T>, new()
		{
			private static Stack<T> _stack;

			public abstract void Reset();

			public virtual void OnFree()
			{
			}

			public static T Create()
			{
				if (_stack != null && _stack.Count > 0)
				{
					return _stack.Pop();
				}
				return new T();
			}

			public void Free()
			{
				OnFree();
				Reset();
				if (_stack == null)
				{
					_stack = new Stack<T>();
				}
				_stack.Push((T)this);
			}
		}

		public class Vertex : Pooled<Vertex>
		{
			internal Vertex _prev;

			internal Vertex _next;

			internal Edge _anEdge;

			internal Vec3 _coords;

			internal float _s;

			internal float _t;

			internal PQHandle _pqHandle;

			internal int _n;

			internal object _data;

			public override void Reset()
			{
				_prev = (_next = null);
				_anEdge = null;
				_coords = Vec3.Zero;
				_s = 0f;
				_t = 0f;
				_pqHandle = default(PQHandle);
				_n = 0;
				_data = null;
			}
		}

		public class Face : Pooled<Face>
		{
			internal Face _prev;

			internal Face _next;

			internal Edge _anEdge;

			internal Face _trail;

			internal int _n;

			internal bool _marked;

			internal bool _inside;

			internal int VertsCount
			{
				get
				{
					int num = 0;
					Edge edge = _anEdge;
					do
					{
						num++;
						edge = edge._Lnext;
					}
					while (edge != _anEdge);
					return num;
				}
			}

			public override void Reset()
			{
				_prev = (_next = null);
				_anEdge = null;
				_trail = null;
				_n = 0;
				_marked = false;
				_inside = false;
			}
		}

		public struct EdgePair
		{
			internal Edge _e;

			internal Edge _eSym;

			public static EdgePair Create()
			{
				EdgePair edgePair = default(EdgePair);
				edgePair._e = Pooled<Edge>.Create();
				edgePair._e._pair = edgePair;
				edgePair._eSym = Pooled<Edge>.Create();
				edgePair._eSym._pair = edgePair;
				return edgePair;
			}

			public void Reset()
			{
				_e = (_eSym = null);
			}
		}

		public class Edge : Pooled<Edge>
		{
			internal EdgePair _pair;

			internal Edge _next;

			internal Edge _Sym;

			internal Edge _Onext;

			internal Edge _Lnext;

			internal Vertex _Org;

			internal Face _Lface;

			internal Tess.ActiveRegion _activeRegion;

			internal int _winding;

			internal Face _Rface
			{
				get
				{
					return _Sym._Lface;
				}
				set
				{
					_Sym._Lface = value;
				}
			}

			internal Vertex _Dst
			{
				get
				{
					return _Sym._Org;
				}
				set
				{
					_Sym._Org = value;
				}
			}

			internal Edge _Oprev
			{
				get
				{
					return _Sym._Lnext;
				}
				set
				{
					_Sym._Lnext = value;
				}
			}

			internal Edge _Lprev
			{
				get
				{
					return _Onext._Sym;
				}
				set
				{
					_Onext._Sym = value;
				}
			}

			internal Edge _Dprev
			{
				get
				{
					return _Lnext._Sym;
				}
				set
				{
					_Lnext._Sym = value;
				}
			}

			internal Edge _Rprev
			{
				get
				{
					return _Sym._Onext;
				}
				set
				{
					_Sym._Onext = value;
				}
			}

			internal Edge _Dnext
			{
				get
				{
					return _Rprev._Sym;
				}
				set
				{
					_Rprev._Sym = value;
				}
			}

			internal Edge _Rnext
			{
				get
				{
					return _Oprev._Sym;
				}
				set
				{
					_Oprev._Sym = value;
				}
			}

			internal static void EnsureFirst(ref Edge e)
			{
				if (e == e._pair._eSym)
				{
					e = e._Sym;
				}
			}

			public override void Reset()
			{
				_pair.Reset();
				_next = (_Sym = (_Onext = (_Lnext = null)));
				_Org = null;
				_Lface = null;
				_activeRegion = null;
				_winding = 0;
			}
		}

		public const int Undef = -1;

		public static Edge MakeEdge(Edge eNext)
		{
			EdgePair edgePair = EdgePair.Create();
			Edge e = edgePair._e;
			Edge eSym = edgePair._eSym;
			Edge.EnsureFirst(ref eNext);
			(eSym._next = eNext._Sym._next)._Sym._next = e;
			e._next = eNext;
			eNext._Sym._next = eSym;
			e._Sym = eSym;
			e._Onext = e;
			e._Lnext = eSym;
			e._Org = null;
			e._Lface = null;
			e._winding = 0;
			e._activeRegion = null;
			eSym._Sym = e;
			eSym._Onext = eSym;
			eSym._Lnext = e;
			eSym._Org = null;
			eSym._Lface = null;
			eSym._winding = 0;
			eSym._activeRegion = null;
			return e;
		}

		public static void Splice(Edge a, Edge b)
		{
			Edge onext = a._Onext;
			Edge onext2 = b._Onext;
			onext._Sym._Lnext = b;
			onext2._Sym._Lnext = a;
			a._Onext = onext2;
			b._Onext = onext;
		}

		public static void MakeVertex(Edge eOrig, Vertex vNext)
		{
			Vertex vertex = Pooled<Vertex>.Create();
			(vertex._prev = vNext._prev)._next = vertex;
			vertex._next = vNext;
			vNext._prev = vertex;
			vertex._anEdge = eOrig;
			Edge edge = eOrig;
			do
			{
				edge._Org = vertex;
				edge = edge._Onext;
			}
			while (edge != eOrig);
		}

		public static void MakeFace(Edge eOrig, Face fNext)
		{
			Face face = Pooled<Face>.Create();
			(face._prev = fNext._prev)._next = face;
			face._next = fNext;
			fNext._prev = face;
			face._anEdge = eOrig;
			face._trail = null;
			face._marked = false;
			face._inside = fNext._inside;
			Edge edge = eOrig;
			do
			{
				edge._Lface = face;
				edge = edge._Lnext;
			}
			while (edge != eOrig);
		}

		public static void KillEdge(Edge eDel)
		{
			Edge.EnsureFirst(ref eDel);
			Edge next = eDel._next;
			Edge next2 = eDel._Sym._next;
			next._Sym._next = next2;
			next2._Sym._next = next;
			eDel.Free();
		}

		public static void KillVertex(Vertex vDel, Vertex newOrg)
		{
			Edge anEdge = vDel._anEdge;
			Edge edge = anEdge;
			do
			{
				edge._Org = newOrg;
				edge = edge._Onext;
			}
			while (edge != anEdge);
			Vertex prev = vDel._prev;
			Vertex next = vDel._next;
			next._prev = prev;
			prev._next = next;
			vDel.Free();
		}

		public static void KillFace(Face fDel, Face newLFace)
		{
			Edge anEdge = fDel._anEdge;
			Edge edge = anEdge;
			do
			{
				edge._Lface = newLFace;
				edge = edge._Lnext;
			}
			while (edge != anEdge);
			Face prev = fDel._prev;
			Face next = fDel._next;
			next._prev = prev;
			prev._next = next;
			fDel.Free();
		}

		public static float FaceArea(Face f)
		{
			float num = 0f;
			Edge edge = f._anEdge;
			do
			{
				num += (edge._Org._s - edge._Dst._s) * (edge._Org._t + edge._Dst._t);
				edge = edge._Lnext;
			}
			while (edge != f._anEdge);
			return num;
		}
	}
	internal struct PQHandle
	{
		public static readonly int Invalid = 268435455;

		internal int _handle;
	}
	internal class PriorityHeap<TValue> where TValue : class
	{
		public delegate bool LessOrEqual(TValue lhs, TValue rhs);

		protected class HandleElem
		{
			internal TValue _key;

			internal int _node;
		}

		private LessOrEqual _leq;

		private int[] _nodes;

		private HandleElem[] _handles;

		private int _size;

		private int _max;

		private int _freeList;

		private bool _initialized;

		public bool Empty => _size == 0;

		public PriorityHeap(int initialSize, LessOrEqual leq)
		{
			_leq = leq;
			_nodes = new int[initialSize + 1];
			_handles = new HandleElem[initialSize + 1];
			_size = 0;
			_max = initialSize;
			_freeList = 0;
			_initialized = false;
			_nodes[1] = 1;
			_handles[1] = new HandleElem
			{
				_key = (TValue)null
			};
		}

		private void FloatDown(int curr)
		{
			int num = _nodes[curr];
			while (true)
			{
				int num2 = curr << 1;
				if (num2 < _size && _leq(_handles[_nodes[num2 + 1]]._key, _handles[_nodes[num2]]._key))
				{
					num2++;
				}
				int num3 = _nodes[num2];
				if (num2 > _size || _leq(_handles[num]._key, _handles[num3]._key))
				{
					break;
				}
				_nodes[curr] = num3;
				_handles[num3]._node = curr;
				curr = num2;
			}
			_nodes[curr] = num;
			_handles[num]._node = curr;
		}

		private void FloatUp(int curr)
		{
			int num = _nodes[curr];
			while (true)
			{
				int num2 = curr >> 1;
				int num3 = _nodes[num2];
				if (num2 == 0 || _leq(_handles[num3]._key, _handles[num]._key))
				{
					break;
				}
				_nodes[curr] = num3;
				_handles[num3]._node = curr;
				curr = num2;
			}
			_nodes[curr] = num;
			_handles[num]._node = curr;
		}

		public void Init()
		{
			for (int num = _size; num >= 1; num--)
			{
				FloatDown(num);
			}
			_initialized = true;
		}

		public PQHandle Insert(TValue value)
		{
			int num = ++_size;
			if (num * 2 > _max)
			{
				_max <<= 1;
				Array.Resize(ref _nodes, _max + 1);
				Array.Resize(ref _handles, _max + 1);
			}
			int num2;
			if (_freeList == 0)
			{
				num2 = num;
			}
			else
			{
				num2 = _freeList;
				_freeList = _handles[num2]._node;
			}
			_nodes[num] = num2;
			if (_handles[num2] == null)
			{
				_handles[num2] = new HandleElem
				{
					_key = value,
					_node = num
				};
			}
			else
			{
				_handles[num2]._node = num;
				_handles[num2]._key = value;
			}
			if (_initialized)
			{
				FloatUp(num);
			}
			PQHandle result = default(PQHandle);
			result._handle = num2;
			return result;
		}

		public TValue ExtractMin()
		{
			int num = _nodes[1];
			TValue key = _handles[num]._key;
			if (_size > 0)
			{
				_nodes[1] = _nodes[_size];
				_handles[_nodes[1]]._node = 1;
				_handles[num]._key = (TValue)null;
				_handles[num]._node = _freeList;
				_freeList = num;
				if (--_size > 0)
				{
					FloatDown(1);
				}
			}
			return key;
		}

		public TValue Minimum()
		{
			return _handles[_nodes[1]]._key;
		}

		public void Remove(PQHandle handle)
		{
			int handle2 = handle._handle;
			int node = _handles[handle2]._node;
			_nodes[node] = _nodes[_size];
			_handles[_nodes[node]]._node = node;
			if (node <= --_size)
			{
				if (node <= 1 || _leq(_handles[_nodes[node >> 1]]._key, _handles[_nodes[node]]._key))
				{
					FloatDown(node);
				}
				else
				{
					FloatUp(node);
				}
			}
			_handles[handle2]._key = (TValue)null;
			_handles[handle2]._node = _freeList;
			_freeList = handle2;
		}
	}
	internal class PriorityQueue<TValue> where TValue : class
	{
		private class StackItem
		{
			internal int p;

			internal int r;
		}

		private PriorityHeap<TValue>.LessOrEqual _leq;

		private PriorityHeap<TValue> _heap;

		private TValue[] _keys;

		private int[] _order;

		private int _size;

		private int _max;

		private bool _initialized;

		public bool Empty => _size == 0 && _heap.Empty;

		public PriorityQueue(int initialSize, PriorityHeap<TValue>.LessOrEqual leq)
		{
			_leq = leq;
			_heap = new PriorityHeap<TValue>(initialSize, leq);
			_keys = new TValue[initialSize];
			_size = 0;
			_max = initialSize;
			_initialized = false;
		}

		private static void Swap(ref int a, ref int b)
		{
			int num = a;
			a = b;
			b = num;
		}

		public void Init()
		{
			Stack<StackItem> stack = new Stack<StackItem>();
			uint num = 2016473283u;
			int num2 = 0;
			int num3 = _size - 1;
			_order = new int[_size + 1];
			int num4 = 0;
			for (int i = num2; i <= num3; i++)
			{
				_order[i] = num4;
				num4++;
			}
			stack.Push(new StackItem
			{
				p = num2,
				r = num3
			});
			while (stack.Count > 0)
			{
				StackItem stackItem = stack.Pop();
				num2 = stackItem.p;
				num3 = stackItem.r;
				while (num3 > num2 + 10)
				{
					num = num * 1539415821 + 1;
					int i = num2 + (int)(num % (num3 - num2 + 1));
					num4 = _order[i];
					_order[i] = _order[num2];
					_order[num2] = num4;
					i = num2 - 1;
					int num5 = num3 + 1;
					while (true)
					{
						i++;
						if (_leq(_keys[_order[i]], _keys[num4]))
						{
							do
							{
								num5--;
							}
							while (!_leq(_keys[num4], _keys[_order[num5]]));
							Swap(ref _order[i], ref _order[num5]);
							if (i >= num5)
							{
								break;
							}
						}
					}
					Swap(ref _order[i], ref _order[num5]);
					if (i - num2 < num3 - num5)
					{
						stack.Push(new StackItem
						{
							p = num5 + 1,
							r = num3
						});
						num3 = i - 1;
					}
					else
					{
						stack.Push(new StackItem
						{
							p = num2,
							r = i - 1
						});
						num2 = num5 + 1;
					}
				}
				for (int i = num2 + 1; i <= num3; i++)
				{
					num4 = _order[i];
					int num5 = i;
					while (num5 > num2 && !_leq(_keys[num4], _keys[_order[num5 - 1]]))
					{
						_order[num5] = _order[num5 - 1];
						num5--;
					}
					_order[num5] = num4;
				}
			}
			_max = _size;
			_initialized = true;
			_heap.Init();
		}

		public PQHandle Insert(TValue value)
		{
			if (_initialized)
			{
				return _heap.Insert(value);
			}
			int size = _size;
			if (++_size >= _max)
			{
				_max <<= 1;
				Array.Resize(ref _keys, _max);
			}
			_keys[size] = value;
			PQHandle result = default(PQHandle);
			result._handle = -(size + 1);
			return result;
		}

		public TValue ExtractMin()
		{
			if (_size == 0)
			{
				return _heap.ExtractMin();
			}
			TValue val = _keys[_order[_size - 1]];
			if (!_heap.Empty)
			{
				TValue lhs = _heap.Minimum();
				if (_leq(lhs, val))
				{
					return _heap.ExtractMin();
				}
			}
			do
			{
				_size--;
			}
			while (_size > 0 && _keys[_order[_size - 1]] == null);
			return val;
		}

		public TValue Minimum()
		{
			if (_size == 0)
			{
				return _heap.Minimum();
			}
			TValue val = _keys[_order[_size - 1]];
			if (!_heap.Empty)
			{
				TValue val2 = _heap.Minimum();
				if (_leq(val2, val))
				{
					return val2;
				}
			}
			return val;
		}

		public void Remove(PQHandle handle)
		{
			int handle2 = handle._handle;
			if (handle2 >= 0)
			{
				_heap.Remove(handle);
				return;
			}
			handle2 = -(handle2 + 1);
			_keys[handle2] = (TValue)null;
			while (_size > 0 && _keys[_order[_size - 1]] == null)
			{
				_size--;
			}
		}
	}
	public class Tess
	{
		internal class ActiveRegion
		{
			internal MeshUtils.Edge _eUp;

			internal Dict<ActiveRegion>.Node _nodeUp;

			internal int _windingNumber;

			internal bool _inside;

			internal bool _sentinel;

			internal bool _dirty;

			internal bool _fixUpperEdge;
		}

		private LTMesh _mesh;

		private Vec3 _normal;

		private Vec3 _sUnit;

		private Vec3 _tUnit;

		private float _bminX;

		private float _bminY;

		private float _bmaxX;

		private float _bmaxY;

		private WindingRule _windingRule;

		private Dict<ActiveRegion> _dict;

		private PriorityQueue<MeshUtils.Vertex> _pq;

		private MeshUtils.Vertex _event;

		private CombineCallback _combineCallback;

		private ContourVertex[] _vertices;

		private int _vertexCount;

		private int[] _elements;

		private int _elementCount;

		public float SUnitX = 1f;

		public float SUnitY;

		public float SentinelCoord = 4E+30f;

		public bool NoEmptyPolygons;

		public bool UsePooling;

		public Vec3 Normal
		{
			get
			{
				return _normal;
			}
			set
			{
				_normal = value;
			}
		}

		public ContourVertex[] Vertices => _vertices;

		public int VertexCount => _vertexCount;

		public int[] Elements => _elements;

		public int ElementCount => _elementCount;

		public Tess()
		{
			_normal = Vec3.Zero;
			_bminX = (_bminY = (_bmaxX = (_bmaxY = 0f)));
			_windingRule = WindingRule.EvenOdd;
			_mesh = null;
			_vertices = null;
			_vertexCount = 0;
			_elements = null;
			_elementCount = 0;
		}

		private ActiveRegion RegionBelow(ActiveRegion reg)
		{
			return reg._nodeUp._prev._key;
		}

		private ActiveRegion RegionAbove(ActiveRegion reg)
		{
			return reg._nodeUp._next._key;
		}

		private bool EdgeLeq(ActiveRegion reg1, ActiveRegion reg2)
		{
			MeshUtils.Edge eUp = reg1._eUp;
			MeshUtils.Edge eUp2 = reg2._eUp;
			if (eUp._Dst == _event)
			{
				if (eUp2._Dst == _event)
				{
					if (Geom.VertLeq(eUp._Org, eUp2._Org))
					{
						return Geom.EdgeSign(eUp2._Dst, eUp._Org, eUp2._Org) <= 0f;
					}
					return Geom.EdgeSign(eUp._Dst, eUp2._Org, eUp._Org) >= 0f;
				}
				return Geom.EdgeSign(eUp2._Dst, _event, eUp2._Org) <= 0f;
			}
			if (eUp2._Dst == _event)
			{
				return Geom.EdgeSign(eUp._Dst, _event, eUp._Org) >= 0f;
			}
			float num = Geom.EdgeEval(eUp._Dst, _event, eUp._Org);
			float num2 = Geom.EdgeEval(eUp2._Dst, _event, eUp2._Org);
			return num >= num2;
		}

		private void DeleteRegion(ActiveRegion reg)
		{
			if (reg._fixUpperEdge)
			{
			}
			reg._eUp._activeRegion = null;
			_dict.Remove(reg._nodeUp);
		}

		private void FixUpperEdge(ActiveRegion reg, MeshUtils.Edge newEdge)
		{
			_mesh.Delete(reg._eUp);
			reg._fixUpperEdge = false;
			reg._eUp = newEdge;
			newEdge._activeRegion = reg;
		}

		private ActiveRegion TopLeftRegion(ActiveRegion reg)
		{
			MeshUtils.Vertex org = reg._eUp._Org;
			do
			{
				reg = RegionAbove(reg);
			}
			while (reg._eUp._Org == org);
			if (reg._fixUpperEdge)
			{
				MeshUtils.Edge newEdge = _mesh.Connect(RegionBelow(reg)._eUp._Sym, reg._eUp._Lnext);
				FixUpperEdge(reg, newEdge);
				reg = RegionAbove(reg);
			}
			return reg;
		}

		private ActiveRegion TopRightRegion(ActiveRegion reg)
		{
			MeshUtils.Vertex dst = reg._eUp._Dst;
			do
			{
				reg = RegionAbove(reg);
			}
			while (reg._eUp._Dst == dst);
			return reg;
		}

		private ActiveRegion AddRegionBelow(ActiveRegion regAbove, MeshUtils.Edge eNewUp)
		{
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = eNewUp;
			activeRegion._nodeUp = _dict.InsertBefore(regAbove._nodeUp, activeRegion);
			activeRegion._fixUpperEdge = false;
			activeRegion._sentinel = false;
			activeRegion._dirty = false;
			eNewUp._activeRegion = activeRegion;
			return activeRegion;
		}

		private void ComputeWinding(ActiveRegion reg)
		{
			reg._windingNumber = RegionAbove(reg)._windingNumber + reg._eUp._winding;
			reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);
		}

		private void FinishRegion(ActiveRegion reg)
		{
			MeshUtils.Edge eUp = reg._eUp;
			MeshUtils.Face lface = eUp._Lface;
			lface._inside = reg._inside;
			lface._anEdge = eUp;
			DeleteRegion(reg);
		}

		private MeshUtils.Edge FinishLeftRegions(ActiveRegion regFirst, ActiveRegion regLast)
		{
			ActiveRegion activeRegion = regFirst;
			MeshUtils.Edge eUp = regFirst._eUp;
			while (activeRegion != regLast)
			{
				activeRegion._fixUpperEdge = false;
				ActiveRegion activeRegion2 = RegionBelow(activeRegion);
				MeshUtils.Edge edge = activeRegion2._eUp;
				if (edge._Org != eUp._Org)
				{
					if (!activeRegion2._fixUpperEdge)
					{
						FinishRegion(activeRegion);
						break;
					}
					edge = _mesh.Connect(eUp._Lprev, edge._Sym);
					FixUpperEdge(activeRegion2, edge);
				}
				if (eUp._Onext != edge)
				{
					_mesh.Splice(edge._Oprev, edge);
					_mesh.Splice(eUp, edge);
				}
				FinishRegion(activeRegion);
				eUp = activeRegion2._eUp;
				activeRegion = activeRegion2;
			}
			return eUp;
		}

		private void AddRightEdges(ActiveRegion regUp, MeshUtils.Edge eFirst, MeshUtils.Edge eLast, MeshUtils.Edge eTopLeft, bool cleanUp)
		{
			bool flag = true;
			MeshUtils.Edge edge = eFirst;
			do
			{
				AddRegionBelow(regUp, edge._Sym);
				edge = edge._Onext;
			}
			while (edge != eLast);
			if (eTopLeft == null)
			{
				eTopLeft = RegionBelow(regUp)._eUp._Rprev;
			}
			ActiveRegion activeRegion = regUp;
			MeshUtils.Edge edge2 = eTopLeft;
			while (true)
			{
				ActiveRegion activeRegion2 = RegionBelow(activeRegion);
				edge = activeRegion2._eUp._Sym;
				if (edge._Org != edge2._Org)
				{
					break;
				}
				if (edge._Onext != edge2)
				{
					_mesh.Splice(edge._Oprev, edge);
					_mesh.Splice(edge2._Oprev, edge);
				}
				activeRegion2._windingNumber = activeRegion._windingNumber - edge._winding;
				activeRegion2._inside = Geom.IsWindingInside(_windingRule, activeRegion2._windingNumber);
				activeRegion._dirty = true;
				if (!flag && CheckForRightSplice(activeRegion))
				{
					Geom.AddWinding(edge, edge2);
					DeleteRegion(activeRegion);
					_mesh.Delete(edge2);
				}
				flag = false;
				activeRegion = activeRegion2;
				edge2 = edge;
			}
			activeRegion._dirty = true;
			if (cleanUp)
			{
				WalkDirtyRegions(activeRegion);
			}
		}

		private void SpliceMergeVertices(MeshUtils.Edge e1, MeshUtils.Edge e2)
		{
			_mesh.Splice(e1, e2);
		}

		private void VertexWeights(MeshUtils.Vertex isect, MeshUtils.Vertex org, MeshUtils.Vertex dst, out float w0, out float w1)
		{
			float num = Geom.VertL1dist(org, isect);
			float num2 = Geom.VertL1dist(dst, isect);
			w0 = num2 / (num + num2) / 2f;
			w1 = num / (num + num2) / 2f;
			isect._coords.X += w0 * org._coords.X + w1 * dst._coords.X;
			isect._coords.Y += w0 * org._coords.Y + w1 * dst._coords.Y;
			isect._coords.Z += w0 * org._coords.Z + w1 * dst._coords.Z;
		}

		private void GetIntersectData(MeshUtils.Vertex isect, MeshUtils.Vertex orgUp, MeshUtils.Vertex dstUp, MeshUtils.Vertex orgLo, MeshUtils.Vertex dstLo)
		{
			isect._coords = Vec3.Zero;
			VertexWeights(isect, orgUp, dstUp, out var w, out var w2);
			VertexWeights(isect, orgLo, dstLo, out var w3, out var w4);
			if (_combineCallback != null)
			{
				isect._data = _combineCallback(isect._coords, new object[4] { orgUp._data, dstUp._data, orgLo._data, dstLo._data }, new float[4] { w, w2, w3, w4 });
			}
		}

		private bool CheckForRightSplice(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			if (Geom.VertLeq(eUp._Org, eUp2._Org))
			{
				if (Geom.EdgeSign(eUp2._Dst, eUp._Org, eUp2._Org) > 0f)
				{
					return false;
				}
				if (!Geom.VertEq(eUp._Org, eUp2._Org))
				{
					_mesh.SplitEdge(eUp2._Sym);
					_mesh.Splice(eUp, eUp2._Oprev);
					regUp._dirty = (activeRegion._dirty = true);
				}
				else if (eUp._Org != eUp2._Org)
				{
					_pq.Remove(eUp._Org._pqHandle);
					SpliceMergeVertices(eUp2._Oprev, eUp);
				}
			}
			else
			{
				if (Geom.EdgeSign(eUp._Dst, eUp2._Org, eUp._Org) < 0f)
				{
					return false;
				}
				RegionAbove(regUp)._dirty = (regUp._dirty = true);
				_mesh.SplitEdge(eUp._Sym);
				_mesh.Splice(eUp2._Oprev, eUp);
			}
			return true;
		}

		private bool CheckForLeftSplice(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			if (Geom.VertLeq(eUp._Dst, eUp2._Dst))
			{
				if (Geom.EdgeSign(eUp._Dst, eUp2._Dst, eUp._Org) < 0f)
				{
					return false;
				}
				RegionAbove(regUp)._dirty = (regUp._dirty = true);
				MeshUtils.Edge edge = _mesh.SplitEdge(eUp);
				_mesh.Splice(eUp2._Sym, edge);
				edge._Lface._inside = regUp._inside;
			}
			else
			{
				if (Geom.EdgeSign(eUp2._Dst, eUp._Dst, eUp2._Org) > 0f)
				{
					return false;
				}
				regUp._dirty = (activeRegion._dirty = true);
				MeshUtils.Edge edge2 = _mesh.SplitEdge(eUp2);
				_mesh.Splice(eUp._Lnext, eUp2._Sym);
				edge2._Rface._inside = regUp._inside;
			}
			return true;
		}

		private bool CheckForIntersect(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			MeshUtils.Vertex org = eUp._Org;
			MeshUtils.Vertex org2 = eUp2._Org;
			MeshUtils.Vertex dst = eUp._Dst;
			MeshUtils.Vertex dst2 = eUp2._Dst;
			if (org == org2)
			{
				return false;
			}
			float num = Math.Min(org._t, dst._t);
			float num2 = Math.Max(org2._t, dst2._t);
			if (num > num2)
			{
				return false;
			}
			if (Geom.VertLeq(org, org2))
			{
				if (Geom.EdgeSign(dst2, org, org2) > 0f)
				{
					return false;
				}
			}
			else if (Geom.EdgeSign(dst, org2, org) < 0f)
			{
				return false;
			}
			MeshUtils.Vertex vertex = MeshUtils.Pooled<MeshUtils.Vertex>.Create();
			Geom.EdgeIntersect(dst, org, dst2, org2, vertex);
			if (Geom.VertLeq(vertex, _event))
			{
				vertex._s = _event._s;
				vertex._t = _event._t;
			}
			MeshUtils.Vertex vertex2 = ((!Geom.VertLeq(org, org2)) ? org2 : org);
			if (Geom.VertLeq(vertex2, vertex))
			{
				vertex._s = vertex2._s;
				vertex._t = vertex2._t;
			}
			if (Geom.VertEq(vertex, org) || Geom.VertEq(vertex, org2))
			{
				CheckForRightSplice(regUp);
				return false;
			}
			if ((!Geom.VertEq(dst, _event) && Geom.EdgeSign(dst, _event, vertex) >= 0f) || (!Geom.VertEq(dst2, _event) && Geom.EdgeSign(dst2, _event, vertex) <= 0f))
			{
				if (dst2 == _event)
				{
					_mesh.SplitEdge(eUp._Sym);
					_mesh.Splice(eUp2._Sym, eUp);
					regUp = TopLeftRegion(regUp);
					eUp = RegionBelow(regUp)._eUp;
					FinishLeftRegions(RegionBelow(regUp), activeRegion);
					AddRightEdges(regUp, eUp._Oprev, eUp, eUp, cleanUp: true);
					return true;
				}
				if (dst == _event)
				{
					_mesh.SplitEdge(eUp2._Sym);
					_mesh.Splice(eUp._Lnext, eUp2._Oprev);
					activeRegion = regUp;
					regUp = TopRightRegion(regUp);
					MeshUtils.Edge rprev = RegionBelow(regUp)._eUp._Rprev;
					activeRegion._eUp = eUp2._Oprev;
					eUp2 = FinishLeftRegions(activeRegion, null);
					AddRightEdges(regUp, eUp2._Onext, eUp._Rprev, rprev, cleanUp: true);
					return true;
				}
				if (Geom.EdgeSign(dst, _event, vertex) >= 0f)
				{
					RegionAbove(regUp)._dirty = (regUp._dirty = true);
					_mesh.SplitEdge(eUp._Sym);
					eUp._Org._s = _event._s;
					eUp._Org._t = _event._t;
				}
				if (Geom.EdgeSign(dst2, _event, vertex) <= 0f)
				{
					regUp._dirty = (activeRegion._dirty = true);
					_mesh.SplitEdge(eUp2._Sym);
					eUp2._Org._s = _event._s;
					eUp2._Org._t = _event._t;
				}
				return false;
			}
			_mesh.SplitEdge(eUp._Sym);
			_mesh.SplitEdge(eUp2._Sym);
			_mesh.Splice(eUp2._Oprev, eUp);
			eUp._Org._s = vertex._s;
			eUp._Org._t = vertex._t;
			eUp._Org._pqHandle = _pq.Insert(eUp._Org);
			if (eUp._Org._pqHandle._handle == PQHandle.Invalid)
			{
				throw new InvalidOperationException("PQHandle should not be invalid");
			}
			GetIntersectData(eUp._Org, org, dst, org2, dst2);
			RegionAbove(regUp)._dirty = (regUp._dirty = (activeRegion._dirty = true));
			return false;
		}

		private void WalkDirtyRegions(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			while (true)
			{
				if (activeRegion._dirty)
				{
					regUp = activeRegion;
					activeRegion = RegionBelow(activeRegion);
					continue;
				}
				if (!regUp._dirty)
				{
					activeRegion = regUp;
					regUp = RegionAbove(regUp);
					if (regUp == null || !regUp._dirty)
					{
						break;
					}
				}
				regUp._dirty = false;
				MeshUtils.Edge eUp = regUp._eUp;
				MeshUtils.Edge eUp2 = activeRegion._eUp;
				if (eUp._Dst != eUp2._Dst && CheckForLeftSplice(regUp))
				{
					if (activeRegion._fixUpperEdge)
					{
						DeleteRegion(activeRegion);
						_mesh.Delete(eUp2);
						activeRegion = RegionBelow(regUp);
						eUp2 = activeRegion._eUp;
					}
					else if (regUp._fixUpperEdge)
					{
						DeleteRegion(regUp);
						_mesh.Delete(eUp);
						regUp = RegionAbove(activeRegion);
						eUp = regUp._eUp;
					}
				}
				if (eUp._Org != eUp2._Org)
				{
					if (eUp._Dst != eUp2._Dst && !regUp._fixUpperEdge && !activeRegion._fixUpperEdge && (eUp._Dst == _event || eUp2._Dst == _event))
					{
						if (CheckForIntersect(regUp))
						{
							break;
						}
					}
					else
					{
						CheckForRightSplice(regUp);
					}
				}
				if (eUp._Org == eUp2._Org && eUp._Dst == eUp2._Dst)
				{
					Geom.AddWinding(eUp2, eUp);
					DeleteRegion(regUp);
					_mesh.Delete(eUp);
					regUp = RegionAbove(activeRegion);
				}
			}
		}

		private void ConnectRightVertex(ActiveRegion regUp, MeshUtils.Edge eBottomLeft)
		{
			MeshUtils.Edge edge = eBottomLeft._Onext;
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			bool flag = false;
			if (eUp._Dst != eUp2._Dst)
			{
				CheckForIntersect(regUp);
			}
			if (Geom.VertEq(eUp._Org, _event))
			{
				_mesh.Splice(edge._Oprev, eUp);
				regUp = TopLeftRegion(regUp);
				edge = RegionBelow(regUp)._eUp;
				FinishLeftRegions(RegionBelow(regUp), activeRegion);
				flag = true;
			}
			if (Geom.VertEq(eUp2._Org, _event))
			{
				_mesh.Splice(eBottomLeft, eUp2._Oprev);
				eBottomLeft = FinishLeftRegions(activeRegion, null);
				flag = true;
			}
			if (flag)
			{
				AddRightEdges(regUp, eBottomLeft._Onext, edge, edge, cleanUp: true);
				return;
			}
			MeshUtils.Edge eDst = ((!Geom.VertLeq(eUp2._Org, eUp._Org)) ? eUp : eUp2._Oprev);
			eDst = _mesh.Connect(eBottomLeft._Lprev, eDst);
			AddRightEdges(regUp, eDst, eDst._Onext, eDst._Onext, cleanUp: false);
			eDst._Sym._activeRegion._fixUpperEdge = true;
			WalkDirtyRegions(regUp);
		}

		private void ConnectLeftDegenerate(ActiveRegion regUp, MeshUtils.Vertex vEvent)
		{
			MeshUtils.Edge eUp = regUp._eUp;
			if (Geom.VertEq(eUp._Org, vEvent))
			{
				throw new InvalidOperationException("Vertices should have been merged before");
			}
			if (!Geom.VertEq(eUp._Dst, vEvent))
			{
				_mesh.SplitEdge(eUp._Sym);
				if (regUp._fixUpperEdge)
				{
					_mesh.Delete(eUp._Onext);
					regUp._fixUpperEdge = false;
				}
				_mesh.Splice(vEvent._anEdge, eUp);
				SweepEvent(vEvent);
				return;
			}
			throw new InvalidOperationException("Vertices should have been merged before");
		}

		private void ConnectLeftVertex(MeshUtils.Vertex vEvent)
		{
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = vEvent._anEdge._Sym;
			ActiveRegion key = _dict.Find(activeRegion).Key;
			ActiveRegion activeRegion2 = RegionBelow(key);
			if (activeRegion2 == null)
			{
				return;
			}
			MeshUtils.Edge eUp = key._eUp;
			MeshUtils.Edge eUp2 = activeRegion2._eUp;
			if (Geom.EdgeSign(eUp._Dst, vEvent, eUp._Org) == 0f)
			{
				ConnectLeftDegenerate(key, vEvent);
				return;
			}
			ActiveRegion activeRegion3 = ((!Geom.VertLeq(eUp2._Dst, eUp._Dst)) ? activeRegion2 : key);
			if (key._inside || activeRegion3._fixUpperEdge)
			{
				MeshUtils.Edge edge = ((activeRegion3 != key) ? _mesh.Connect(eUp2._Dnext, vEvent._anEdge)._Sym : _mesh.Connect(vEvent._anEdge._Sym, eUp._Lnext));
				if (activeRegion3._fixUpperEdge)
				{
					FixUpperEdge(activeRegion3, edge);
				}
				else
				{
					ComputeWinding(AddRegionBelow(key, edge));
				}
				SweepEvent(vEvent);
			}
			else
			{
				AddRightEdges(key, vEvent._anEdge, vEvent._anEdge, null, cleanUp: true);
			}
		}

		private void SweepEvent(MeshUtils.Vertex vEvent)
		{
			_event = vEvent;
			MeshUtils.Edge edge = vEvent._anEdge;
			while (edge._activeRegion == null)
			{
				edge = edge._Onext;
				if (edge == vEvent._anEdge)
				{
					ConnectLeftVertex(vEvent);
					return;
				}
			}
			ActiveRegion activeRegion = TopLeftRegion(edge._activeRegion);
			ActiveRegion activeRegion2 = RegionBelow(activeRegion);
			MeshUtils.Edge eUp = activeRegion2._eUp;
			MeshUtils.Edge edge2 = FinishLeftRegions(activeRegion2, null);
			if (edge2._Onext == eUp)
			{
				ConnectRightVertex(activeRegion, edge2);
			}
			else
			{
				AddRightEdges(activeRegion, edge2._Onext, eUp, eUp, cleanUp: true);
			}
		}

		private void AddSentinel(float smin, float smax, float t)
		{
			MeshUtils.Edge edge = _mesh.MakeEdge();
			edge._Org._s = smax;
			edge._Org._t = t;
			edge._Dst._s = smin;
			edge._Dst._t = t;
			_event = edge._Dst;
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = edge;
			activeRegion._windingNumber = 0;
			activeRegion._inside = false;
			activeRegion._fixUpperEdge = false;
			activeRegion._sentinel = true;
			activeRegion._dirty = false;
			activeRegion._nodeUp = _dict.Insert(activeRegion);
		}

		private void InitEdgeDict()
		{
			_dict = new Dict<ActiveRegion>(EdgeLeq);
			AddSentinel(0f - SentinelCoord, SentinelCoord, 0f - SentinelCoord);
			AddSentinel(0f - SentinelCoord, SentinelCoord, SentinelCoord);
		}

		private void DoneEdgeDict()
		{
			int num = 0;
			ActiveRegion key;
			while ((key = _dict.Min().Key) != null)
			{
				if (!key._sentinel)
				{
				}
				DeleteRegion(key);
			}
			_dict = null;
		}

		private void RemoveDegenerateEdges()
		{
			MeshUtils.Edge eHead = _mesh._eHead;
			MeshUtils.Edge edge = eHead._next;
			while (edge != eHead)
			{
				MeshUtils.Edge next = edge._next;
				MeshUtils.Edge lnext = edge._Lnext;
				if (Geom.VertEq(edge._Org, edge._Dst) && edge._Lnext._Lnext != edge)
				{
					SpliceMergeVertices(lnext, edge);
					_mesh.Delete(edge);
					edge = lnext;
					lnext = edge._Lnext;
				}
				if (lnext._Lnext == edge)
				{
					if (lnext != edge)
					{
						if (lnext == next || lnext == next._Sym)
						{
							next = next._next;
						}
						_mesh.Delete(lnext);
					}
					if (edge == next || edge == next._Sym)
					{
						next = next._next;
					}
					_mesh.Delete(edge);
				}
				edge = next;
			}
		}

		private void InitPriorityQ()
		{
			MeshUtils.Vertex vHead = _mesh._vHead;
			int num = 0;
			for (MeshUtils.Vertex next = vHead._next; next != vHead; next = next._next)
			{
				num++;
			}
			num += 8;
			_pq = new PriorityQueue<MeshUtils.Vertex>(num, Geom.VertLeq);
			vHead = _mesh._vHead;
			for (MeshUtils.Vertex next = vHead._next; next != vHead; next = next._next)
			{
				next._pqHandle = _pq.Insert(next);
				if (next._pqHandle._handle == PQHandle.Invalid)
				{
					throw new InvalidOperationException("PQHandle should not be invalid");
				}
			}
			_pq.Init();
		}

		private void DonePriorityQ()
		{
			_pq = null;
		}

		private void RemoveDegenerateFaces()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				MeshUtils.Edge anEdge = face._anEdge;
				if (anEdge._Lnext._Lnext == anEdge)
				{
					Geom.AddWinding(anEdge._Onext, anEdge);
					_mesh.Delete(anEdge);
				}
				face = next;
			}
		}

		protected void ComputeInterior()
		{
			RemoveDegenerateEdges();
			InitPriorityQ();
			RemoveDegenerateFaces();
			InitEdgeDict();
			MeshUtils.Vertex vertex;
			while ((vertex = _pq.ExtractMin()) != null)
			{
				while (true)
				{
					MeshUtils.Vertex vertex2 = _pq.Minimum();
					if (vertex2 == null || !Geom.VertEq(vertex2, vertex))
					{
						break;
					}
					vertex2 = _pq.ExtractMin();
					SpliceMergeVertices(vertex._anEdge, vertex2._anEdge);
				}
				SweepEvent(vertex);
			}
			DoneEdgeDict();
			DonePriorityQ();
			RemoveDegenerateFaces();
		}

		private void ComputeNormal(ref Vec3 norm)
		{
			MeshUtils.Vertex next = _mesh._vHead._next;
			float[] array = new float[3]
			{
				next._coords.X,
				next._coords.Y,
				next._coords.Z
			};
			MeshUtils.Vertex[] array2 = new MeshUtils.Vertex[3] { next, next, next };
			float[] array3 = new float[3]
			{
				next._coords.X,
				next._coords.Y,
				next._coords.Z
			};
			MeshUtils.Vertex[] array4 = new MeshUtils.Vertex[3] { next, next, next };
			while (next != _mesh._vHead)
			{
				if (next._coords.X < array[0])
				{
					array[0] = next._coords.X;
					array2[0] = next;
				}
				if (next._coords.Y < array[1])
				{
					array[1] = next._coords.Y;
					array2[1] = next;
				}
				if (next._coords.Z < array[2])
				{
					array[2] = next._coords.Z;
					array2[2] = next;
				}
				if (next._coords.X > array3[0])
				{
					array3[0] = next._coords.X;
					array4[0] = next;
				}
				if (next._coords.Y > array3[1])
				{
					array3[1] = next._coords.Y;
					array4[1] = next;
				}
				if (next._coords.Z > array3[2])
				{
					array3[2] = next._coords.Z;
					array4[2] = next;
				}
				next = next._next;
			}
			int num = 0;
			if (array3[1] - array[1] > array3[0] - array[0])
			{
				num = 1;
			}
			if (array3[2] - array[2] > array3[num] - array[num])
			{
				num = 2;
			}
			if (array[num] >= array3[num])
			{
				norm = new Vec3
				{
					X = 0f,
					Y = 0f,
					Z = 1f
				};
				return;
			}
			float num2 = 0f;
			MeshUtils.Vertex vertex = array2[num];
			MeshUtils.Vertex vertex2 = array4[num];
			Vec3.Sub(ref vertex._coords, ref vertex2._coords, out var result);
			Vec3 vec = default(Vec3);
			for (next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				Vec3.Sub(ref next._coords, ref vertex2._coords, out var result2);
				vec.X = result.Y * result2.Z - result.Z * result2.Y;
				vec.Y = result.Z * result2.X - result.X * result2.Z;
				vec.Z = result.X * result2.Y - result.Y * result2.X;
				float num3 = vec.X * vec.X + vec.Y * vec.Y + vec.Z * vec.Z;
				if (num3 > num2)
				{
					num2 = num3;
					norm = vec;
				}
			}
			if (num2 <= 0f)
			{
				norm = Vec3.Zero;
				num = Vec3.LongAxis(ref result);
				norm[num] = 1f;
			}
		}

		private void CheckOrientation()
		{
			float num = 0f;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._anEdge._winding > 0)
				{
					num += MeshUtils.FaceArea(next);
				}
			}
			if (num < 0f)
			{
				for (MeshUtils.Vertex next2 = _mesh._vHead._next; next2 != _mesh._vHead; next2 = next2._next)
				{
					next2._t = 0f - next2._t;
				}
				Vec3.Neg(ref _tUnit);
			}
		}

		private void ProjectPolygon()
		{
			Vec3 norm = _normal;
			bool flag = false;
			if (norm.X == 0f && norm.Y == 0f && norm.Z == 0f)
			{
				ComputeNormal(ref norm);
				_normal = norm;
				flag = true;
			}
			int num = Vec3.LongAxis(ref norm);
			_sUnit[num] = 0f;
			_sUnit[(num + 1) % 3] = SUnitX;
			_sUnit[(num + 2) % 3] = SUnitY;
			_tUnit[num] = 0f;
			_tUnit[(num + 1) % 3] = ((!(norm[num] > 0f)) ? SUnitY : (0f - SUnitY));
			_tUnit[(num + 2) % 3] = ((!(norm[num] > 0f)) ? (0f - SUnitX) : SUnitX);
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				Vec3.Dot(ref next._coords, ref _sUnit, out next._s);
				Vec3.Dot(ref next._coords, ref _tUnit, out next._t);
			}
			if (flag)
			{
				CheckOrientation();
			}
			bool flag2 = true;
			for (MeshUtils.Vertex next2 = _mesh._vHead._next; next2 != _mesh._vHead; next2 = next2._next)
			{
				if (flag2)
				{
					_bminX = (_bmaxX = next2._s);
					_bminY = (_bmaxY = next2._t);
					flag2 = false;
				}
				else
				{
					if (next2._s < _bminX)
					{
						_bminX = next2._s;
					}
					if (next2._s > _bmaxX)
					{
						_bmaxX = next2._s;
					}
					if (next2._t < _bminY)
					{
						_bminY = next2._t;
					}
					if (next2._t > _bmaxY)
					{
						_bmaxY = next2._t;
					}
				}
			}
		}

		private void TessellateMonoRegion(MeshUtils.Face face)
		{
			MeshUtils.Edge edge = face._anEdge;
			while (Geom.VertLeq(edge._Dst, edge._Org))
			{
				edge = edge._Lprev;
			}
			while (Geom.VertLeq(edge._Org, edge._Dst))
			{
				edge = edge._Lnext;
			}
			MeshUtils.Edge edge2 = edge._Lprev;
			while (edge._Lnext != edge2)
			{
				if (Geom.VertLeq(edge._Dst, edge2._Org))
				{
					while (edge2._Lnext != edge && (Geom.EdgeGoesLeft(edge2._Lnext) || Geom.EdgeSign(edge2._Org, edge2._Dst, edge2._Lnext._Dst) <= 0f))
					{
						edge2 = _mesh.Connect(edge2._Lnext, edge2)._Sym;
					}
					edge2 = edge2._Lprev;
				}
				else
				{
					while (edge2._Lnext != edge && (Geom.EdgeGoesRight(edge._Lprev) || Geom.EdgeSign(edge._Dst, edge._Org, edge._Lprev._Org) >= 0f))
					{
						edge = _mesh.Connect(edge, edge._Lprev)._Sym;
					}
					edge = edge._Lnext;
				}
			}
			while (edge2._Lnext._Lnext != edge)
			{
				edge2 = _mesh.Connect(edge2._Lnext, edge2)._Sym;
			}
		}

		private void TessellateInterior()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				if (face._inside)
				{
					TessellateMonoRegion(face);
				}
				face = next;
			}
		}

		private void DiscardExterior()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				if (!face._inside)
				{
					_mesh.ZapFace(face);
				}
				face = next;
			}
		}

		private void SetWindingNumber(int value, bool keepOnlyBoundary)
		{
			MeshUtils.Edge edge = _mesh._eHead._next;
			while (edge != _mesh._eHead)
			{
				MeshUtils.Edge next = edge._next;
				if (edge._Rface._inside != edge._Lface._inside)
				{
					edge._winding = ((!edge._Lface._inside) ? (-value) : value);
				}
				else if (!keepOnlyBoundary)
				{
					edge._winding = 0;
				}
				else
				{
					_mesh.Delete(edge);
				}
				edge = next;
			}
		}

		private int GetNeighbourFace(MeshUtils.Edge edge)
		{
			if (edge._Rface == null)
			{
				return -1;
			}
			if (!edge._Rface._inside)
			{
				return -1;
			}
			return edge._Rface._n;
		}

		private void OutputPolymesh(ElementType elementType, int polySize)
		{
			int num = 0;
			int num2 = 0;
			if (polySize < 3)
			{
				polySize = 3;
			}
			if (polySize > 3)
			{
				_mesh.MergeConvexFaces(polySize);
			}
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				next._n = -1;
			}
			for (MeshUtils.Face next2 = _mesh._fHead._next; next2 != _mesh._fHead; next2 = next2._next)
			{
				next2._n = -1;
				if (!next2._inside)
				{
					continue;
				}
				if (NoEmptyPolygons)
				{
					float value = MeshUtils.FaceArea(next2);
					if (Math.Abs(value) < float.Epsilon)
					{
						continue;
					}
				}
				MeshUtils.Edge edge = next2._anEdge;
				int num3 = 0;
				do
				{
					MeshUtils.Vertex next = edge._Org;
					if (next._n == -1)
					{
						next._n = num2;
						num2++;
					}
					num3++;
					edge = edge._Lnext;
				}
				while (edge != next2._anEdge);
				next2._n = num;
				num++;
			}
			_elementCount = num;
			if (elementType == ElementType.ConnectedPolygons)
			{
				num *= 2;
			}
			_elements = new int[num * polySize];
			_vertexCount = num2;
			_vertices = new ContourVertex[_vertexCount];
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				if (next._n != -1)
				{
					_vertices[next._n].Position = next._coords;
					_vertices[next._n].Data = next._data;
				}
			}
			int num4 = 0;
			for (MeshUtils.Face next2 = _mesh._fHead._next; next2 != _mesh._fHead; next2 = next2._next)
			{
				if (!next2._inside)
				{
					continue;
				}
				if (NoEmptyPolygons)
				{
					float value2 = MeshUtils.FaceArea(next2);
					if (Math.Abs(value2) < float.Epsilon)
					{
						continue;
					}
				}
				MeshUtils.Edge edge = next2._anEdge;
				int num3 = 0;
				do
				{
					MeshUtils.Vertex next = edge._Org;
					_elements[num4++] = next._n;
					num3++;
					edge = edge._Lnext;
				}
				while (edge != next2._anEdge);
				for (int i = num3; i < polySize; i++)
				{
					_elements[num4++] = -1;
				}
				if (elementType == ElementType.ConnectedPolygons)
				{
					edge = next2._anEdge;
					do
					{
						_elements[num4++] = GetNeighbourFace(edge);
						edge = edge._Lnext;
					}
					while (edge != next2._anEdge);
					for (int i = num3; i < polySize; i++)
					{
						_elements[num4++] = -1;
					}
				}
			}
		}

		private void OutputContours()
		{
			int num = 0;
			int num2 = 0;
			_vertexCount = 0;
			_elementCount = 0;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._inside)
				{
					MeshUtils.Edge edge;
					MeshUtils.Edge edge2 = (edge = next._anEdge);
					do
					{
						_vertexCount++;
						edge = edge._Lnext;
					}
					while (edge != edge2);
					_elementCount++;
				}
			}
			_elements = new int[_elementCount * 2];
			_vertices = new ContourVertex[_vertexCount];
			int num3 = 0;
			int num4 = 0;
			num = 0;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._inside)
				{
					num2 = 0;
					MeshUtils.Edge edge;
					MeshUtils.Edge edge2 = (edge = next._anEdge);
					do
					{
						_vertices[num3].Position = edge._Org._coords;
						_vertices[num3].Data = edge._Org._data;
						num3++;
						num2++;
						edge = edge._Lnext;
					}
					while (edge != edge2);
					_elements[num4++] = num;
					_elements[num4++] = num2;
					num += num2;
				}
			}
		}

		private float SignedArea(ContourVertex[] vertices)
		{
			float num = 0f;
			for (int i = 0; i < vertices.Length; i++)
			{
				ContourVertex contourVertex = vertices[i];
				ContourVertex contourVertex2 = vertices[(i + 1) % vertices.Length];
				num += contourVertex.Position.X * contourVertex2.Position.Y;
				num -= contourVertex.Position.Y * contourVertex2.Position.X;
			}
			return 0.5f * num;
		}

		public void AddContour(ContourVertex[] vertices)
		{
			AddContour(vertices, ContourOrientation.Original);
		}

		public void AddContour(ContourVertex[] vertices, ContourOrientation forceOrientation)
		{
			if (_mesh == null)
			{
				_mesh = new LTMesh();
			}
			bool flag = false;
			if (forceOrientation != 0)
			{
				float num = SignedArea(vertices);
				flag = (forceOrientation == ContourOrientation.Clockwise && num < 0f) || (forceOrientation == ContourOrientation.CounterClockwise && num > 0f);
			}
			MeshUtils.Edge edge = null;
			for (int i = 0; i < vertices.Length; i++)
			{
				if (edge == null)
				{
					edge = _mesh.MakeEdge();
					_mesh.Splice(edge, edge._Sym);
				}
				else
				{
					_mesh.SplitEdge(edge);
					edge = edge._Lnext;
				}
				int num2 = ((!flag) ? i : (vertices.Length - 1 - i));
				edge._Org._coords = vertices[num2].Position;
				edge._Org._data = vertices[num2].Data;
				edge._winding = 1;
				edge._Sym._winding = -1;
			}
		}

		public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize)
		{
			Tessellate(windingRule, elementType, polySize, null);
		}

		public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize, CombineCallback combineCallback)
		{
			_normal = Vec3.Zero;
			_vertices = null;
			_elements = null;
			_windingRule = windingRule;
			_combineCallback = combineCallback;
			if (_mesh != null)
			{
				ProjectPolygon();
				ComputeInterior();
				if (elementType == ElementType.BoundaryContours)
				{
					SetWindingNumber(1, keepOnlyBoundary: true);
				}
				else
				{
					TessellateInterior();
				}
				if (elementType == ElementType.BoundaryContours)
				{
					OutputContours();
				}
				else
				{
					OutputPolymesh(elementType, polySize);
				}
				if (UsePooling)
				{
					_mesh.Free();
				}
				_mesh = null;
			}
		}
	}
	public enum WindingRule
	{
		EvenOdd,
		NonZero,
		Positive,
		Negative,
		AbsGeqTwo
	}
	public enum ElementType
	{
		Polygons,
		ConnectedPolygons,
		BoundaryContours
	}
	public enum ContourOrientation
	{
		Original,
		Clockwise,
		CounterClockwise
	}
	public struct ContourVertex
	{
		public Vec3 Position;

		public object Data;

		public override string ToString()
		{
			return $"{Position}, {Data}";
		}
	}
	public delegate object CombineCallback(Vec3 position, object[] data, float[] weights);
	public static class LibTessVector3Extension
	{
		public static Vec3 Vec3(this Vector3 v)
		{
			Vec3 result = default(Vec3);
			result.X = v.x;
			result.Y = v.y;
			result.Z = v.z;
			return result;
		}

		public static ContourVertex ContourVertex(this Vector3 v)
		{
			ContourVertex result = default(ContourVertex);
			result.Position = v.Vec3();
			return result;
		}
	}
	public static class LibTessV3Extension
	{
		public static Vector3 Vector3(this Vec3 v)
		{
			return new Vector3(v.X, v.Y, v.Z);
		}
	}
	public static class UnityLibTessUtility
	{
		public static ContourVertex[] ToContourVertex(Vector3[] v, bool zeroZ = false)
		{
			ContourVertex[] array = new ContourVertex[v.Length];
			for (int i = 0; i < v.Length; i++)
			{
				array[i].Position.X = v[i].x;
				array[i].Position.Y = v[i].y;
				array[i].Position.Z = ((!zeroZ) ? v[i].z : 0f);
			}
			return array;
		}

		public static Vector3[] FromContourVertex(ContourVertex[] v)
		{
			Vector3[] v3Array = new Vector3[v.Length];
			SetFromContourVertex(ref v3Array, ref v);
			return v3Array;
		}

		public static void SetFromContourVertex(ref Vector3[] v3Array, ref ContourVertex[] cvArray)
		{
			Array.Resize(ref v3Array, cvArray.Length);
			for (int i = 0; i < v3Array.Length; i++)
			{
				v3Array[i].x = cvArray[i].Position.X;
				v3Array[i].y = cvArray[i].Position.Y;
				v3Array[i].z = cvArray[i].Position.Z;
			}
		}

		public static void SetToContourVertex(ref ContourVertex[] cvArray, ref Vector3[] v3Array)
		{
			Array.Resize(ref cvArray, v3Array.Length);
			for (int i = 0; i < cvArray.Length; i++)
			{
				cvArray[i].Position.X = v3Array[i].x;
				cvArray[i].Position.Y = v3Array[i].y;
				cvArray[i].Position.Z = v3Array[i].z;
			}
		}
	}
}
public class iTween : MonoBehaviour
{
	private delegate float EasingFunction(float start, float end, float Value);

	private delegate void ApplyTween();

	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static int cameraFadeDepth = 999999;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 vector = pts[num2];
			Vector3 vector2 = pts[num2 + 1];
			Vector3 vector3 = pts[num2 + 2];
			Vector3 vector4 = pts[num2 + 3];
			return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
		}
	}

	public static List<Hashtable> tweens = new List<Hashtable>();

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	private Transform thisTransform;

	private iTween(Hashtable h)
	{
		tweenArguments = h;
	}

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void CameraFadeFrom(float amount, float time)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void CameraFadeFrom(Hashtable args)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void CameraFadeTo(float amount, float time)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void CameraFadeTo(Hashtable args)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void ValueTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (args["from"].GetType() != typeof(Color))
			{
				Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			Transform obj = target.transform;
			Transform target2 = (Transform)args["looktarget"];
			Vector3? vector = (Vector3?)args["up"];
			obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			Transform obj2 = target.transform;
			Vector3 worldPosition = (Vector3)args["looktarget"];
			Vector3? vector2 = (Vector3?)args["up"];
			obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					ref Vector3 reference = ref array2[i];
					reference = array3[i].position;
				}
			}
			if (array2[array2.Length - 1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					ref Vector3 reference2 = ref array4[array4.Length - 1];
					reference2 = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					ref Vector3 reference3 = ref array4[array4.Length - 1];
					reference3 = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = ((!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition));
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					Transform transform = (Transform)args["position"];
					vector = transform.position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = (localScale = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				localScale = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		Vector3 vector;
		Vector3 vector2 = ((!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles));
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				vector = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
		{
			string text2 = method;
			if (text2 != null && text2 == "to")
			{
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
			}
			break;
		}
		case "audio":
		{
			string text3 = method;
			if (text3 != null && text3 == "to")
			{
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
			}
			break;
		}
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
		{
			string text = method;
			if (text != null && text == "to")
			{
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
			}
			break;
		}
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		ref Rect reference = ref rects[0];
		reference = (Rect)tweenArguments["from"];
		ref Rect reference2 = ref rects[1];
		reference2 = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		ref Color reference = ref colors[0, 0];
		reference = (Color)tweenArguments["from"];
		ref Color reference2 = ref colors[0, 1];
		reference2 = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = (Vector3)tweenArguments["from"];
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		ref Vector2 reference = ref vector2s[0];
		reference = (Vector2)tweenArguments["from"];
		ref Vector2 reference2 = ref vector2s[1];
		reference2 = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 a = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(a, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				ref Color reference = ref colors[i, 0];
				reference = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				ref Color reference2 = ref colors[i, 1];
				reference2 = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			ref Color reference3 = ref colors[0, 0];
			ref Color reference4 = ref colors[0, 1];
			reference3 = (reference4 = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				ref Color reference5 = ref colors[j, 1];
				reference5 = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		ref Vector2 reference = ref vector2s[0];
		ref Vector2 reference2 = ref vector2s[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent<AudioSource>();
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = thisTransform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = thisTransform;
				Transform target = (Transform)tweenArguments["looktarget"];
				Vector3? vector = (Vector3?)tweenArguments["up"];
				obj.LookAt(target, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = thisTransform;
				Vector3 worldPosition = (Vector3)tweenArguments["looktarget"];
				Vector3? vector2 = (Vector3?)tweenArguments["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = thisTransform.eulerAngles;
		thisTransform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		ref Vector3 reference3 = ref vector3s[1];
		reference3 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				ref Vector3 reference = ref array2[i];
				reference = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (thisTransform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = thisTransform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		ref Vector3 reference3 = ref vector3s[0];
		reference3 = vector3s[1] + (vector3s[1] - vector3s[2]);
		ref Vector3 reference4 = ref vector3s[vector3s.Length - 1];
		reference4 = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			ref Vector3 reference5 = ref array4[0];
			reference5 = array4[array4.Length - 3];
			ref Vector3 reference6 = ref array4[array4.Length - 1];
			reference6 = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = thisTransform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = thisTransform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		ref Vector3 reference = ref vector3s[4];
		reference = thisTransform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference2 = (reference3 = (reference4 = thisTransform.position));
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		thisTransform.Translate(vector3s[1], space);
		ref Vector3 reference6 = ref vector3s[5];
		reference6 = thisTransform.position;
		thisTransform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = thisTransform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				ref Vector3 reference3 = ref vector3s[1];
				reference3 = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref vector3s[1];
				reference4 = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = thisTransform.localEulerAngles);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = thisTransform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		ref Vector3 reference7 = ref vector3s[1];
		reference7 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[3];
		reference = thisTransform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = thisTransform.position;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = thisTransform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = thisTransform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[4];
		reference = thisTransform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = thisTransform.position;
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference3 = (reference4 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		reference = thisTransform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference2 = (reference3 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference4 = ref vector3s[1];
			reference4 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = thisTransform.localScale;
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = thisTransform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			thisTransform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = ((!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]));
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = thisTransform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[2];
		}
		else
		{
			thisTransform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localPosition = vector3s[1];
			}
			else
			{
				thisTransform.position = vector3s[1];
			}
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			thisTransform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				thisTransform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = thisTransform.localPosition;
		}
		else
		{
			preUpdate = thisTransform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			thisTransform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[0];
		}
		else
		{
			thisTransform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			thisTransform.localPosition += vector3s[2];
		}
		else
		{
			thisTransform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			thisTransform.localScale = vector3s[1];
		}
		thisTransform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (percentage == 0f)
		{
			thisTransform.Rotate(vector3s[1], space);
		}
		thisTransform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.Rotate(vector3s[2], space);
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			ref Color reference = ref array[0];
			ref Color reference2 = ref array[1];
			reference = (reference2 = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			ref Color reference3 = ref array[0];
			ref Color reference4 = ref array[1];
			reference3 = (reference4 = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			ref Color reference5 = ref array[1];
			reference5 = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		ref Vector2 reference = ref array[0];
		ref Vector2 reference2 = ref array[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 eulerAngles = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			reference = target.transform.localEulerAngles;
		}
		else
		{
			ref Vector3 reference2 = ref array[0];
			reference2 = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			target.transform.eulerAngles = eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles2));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		ref Vector3 reference2 = ref array[1];
		reference = (reference2 = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 position = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			ref Vector3 reference2 = ref array[1];
			reference = (reference2 = target.transform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref array[0];
			ref Vector3 reference4 = ref array[1];
			reference3 = (reference4 = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				ref Vector3 reference5 = ref array[1];
				reference5 = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref array[1];
				reference6 = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position2 = target.transform.position;
			target.transform.position = position;
			target.GetComponent<Rigidbody>().MovePosition(position2);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		reference = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = target.transform;
				Transform target2 = (Transform)args["looktarget"];
				Vector3? vector = (Vector3?)args["up"];
				obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = target.transform;
				Vector3 worldPosition = (Vector3)args["looktarget"];
				Vector3? vector2 = (Vector3?)args["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
			ref Vector3 reference2 = ref array[1];
			reference2 = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				ref Vector3 reference3 = ref array[4];
				reference3 = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static Texture2D CameraTexture(Color color)
	{
		Texture2D texture2D = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, mipmap: false);
		Color[] array = new Color[Screen.width * Screen.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return texture2D;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void CameraFadeDepth(int depth)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void CameraFadeDestroy()
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static void CameraFadeSwap(Texture2D texture)
	{
		Debug.LogWarning("This feature is no longer supported");
	}

	public static GameObject CameraFadeAdd(Texture2D texture, int depth)
	{
		Debug.LogWarning("This feature is no longer supported");
		return null;
	}

	public static GameObject CameraFadeAdd(Texture2D texture)
	{
		Debug.LogWarning("This feature is no longer supported");
		return null;
	}

	public static GameObject CameraFadeAdd()
	{
		Debug.LogWarning("This feature is no longer supported");
		return null;
	}

	public static void Resume(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, includechildren: true);
		}
	}

	public static void Resume(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, type, includechildren: true);
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Resume(target);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.delay > 0f)
			{
				iTween2.delay -= Time.time - iTween2.delayStarted;
				iTween2.StopCoroutine("TweenDelay");
			}
			iTween2.isPaused = true;
			iTween2.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, includechildren: true);
		}
	}

	public static void Pause(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, type, includechildren: true);
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Pause(target);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			string text = (string)hashtable["type"] + (string)hashtable["method"];
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Stop(target);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, includechildren: true);
		}
	}

	public static void Stop(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, type, includechildren: true);
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			StopByName(item.gameObject, name, includechildren: true);
		}
	}

	public static Hashtable Hash(params object[] args)
	{
		Hashtable hashtable = new Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private void Awake()
	{
		thisTransform = base.transform;
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		ref Vector3 reference = ref array[0];
		reference = array[1] + (array[1] - array[2]);
		ref Vector3 reference2 = ref array[array.Length - 1];
		reference2 = array[array.Length - 2] + (array[array.Length - 2] - array[array.Length - 3]);
		if (array[1] == array[array.Length - 2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			ref Vector3 reference3 = ref array2[0];
			reference3 = array2[array2.Length - 3];
			ref Vector3 reference4 = ref array2[array2.Length - 1];
			reference4 = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 vector = pts[num2];
		Vector3 vector2 = pts[num2 + 1];
		Vector3 vector3 = pts[num2 + 2];
		Vector3 vector4 = pts[num2 + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
	}

	private static void Launch(GameObject target, Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static Hashtable CleanArgs(Hashtable args)
	{
		Hashtable hashtable = new Hashtable(args.Count);
		Hashtable hashtable2 = new Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				int num = (int)item.Value;
				float num2 = num;
				args[item.Key] = num2;
			}
			if (item.Value.GetType() == typeof(double))
			{
				double num3 = (double)item.Value;
				float num4 = (float)num3;
				args[item.Key] = num4;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		return Guid.NewGuid().ToString();
	}

	private void RetrieveArgs()
	{
		foreach (Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = ((!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]));
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			if ((string)hashtable["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		Component[] components = GetComponents<iTween>();
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.type == "value")
			{
				break;
			}
			if (!iTween2.isRunning || !(iTween2.type == type))
			{
				continue;
			}
			if (iTween2.method != method)
			{
				break;
			}
			if (iTween2.tweenArguments.Count != tweenArguments.Count)
			{
				iTween2.Dispose();
				break;
			}
			foreach (DictionaryEntry tweenArgument in tweenArguments)
			{
				if (!iTween2.tweenArguments.Contains(tweenArgument.Key))
				{
					iTween2.Dispose();
					return;
				}
				if (!iTween2.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
				{
					iTween2.Dispose();
					return;
				}
			}
			Dispose();
		}
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) * 0.5f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value + start;
		}
		value -= 1f;
		return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num * 0.5f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value -= 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 * 0.25f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}
}
public class MoveSample : MonoBehaviour
{
	private void Start()
	{
		iTween.MoveBy(base.gameObject, iTween.Hash("x", 2, "easeType", "easeInOutExpo", "loopType", "pingPong", "delay", 0.1));
	}
}
public class RotateSample : MonoBehaviour
{
	private void Start()
	{
		iTween.RotateBy(base.gameObject, iTween.Hash("x", 0.25, "easeType", "easeInOutBack", "loopType", "pingPong", "delay", 0.4));
	}
}
public class SampleInfo : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("iTween can spin, shake, punch, move, handle audio, fade color and transparency \nand much more with each task needing only one line of code.");
		GUILayout.BeginHorizontal();
		GUILayout.Label("iTween works with C#, JavaScript and Boo. For full documentation and examples visit:");
		if (GUILayout.Button("http://itween.pixelplacement.com"))
		{
			Application.OpenURL("http://itween.pixelplacement.com");
		}
		GUILayout.EndHorizontal();
	}
}
namespace RootMotion.Demos
{
	public class AimBoxing : MonoBehaviour
	{
		public AimIK aimIK;

		public Transform pin;

		private void LateUpdate()
		{
			aimIK.solver.transform.LookAt(pin.position);
			aimIK.solver.IKPosition = base.transform.position;
		}
	}
	public class SimpleAimingSystem : MonoBehaviour
	{
		[Tooltip("AimPoser is a tool that returns an animation name based on direction.")]
		public AimPoser aimPoser;

		[Tooltip("Reference to the AimIK component.")]
		public AimIK aim;

		[Tooltip("Reference to the LookAt component (only used for the head in this instance).")]
		public LookAtIK lookAt;

		[Tooltip("Reference to the Animator component.")]
		public Animator animator;

		[Tooltip("Time of cross-fading from pose to pose.")]
		public float crossfadeTime = 0.2f;

		[Tooltip("Will keep the aim target at a distance.")]
		public float minAimDistance = 0.5f;

		private AimPoser.Pose aimPose;

		private AimPoser.Pose lastPose;

		private void Start()
		{
			aim.enabled = false;
			lookAt.enabled = false;
		}

		private void LateUpdate()
		{
			if (aim.solver.target == null)
			{
				Debug.LogWarning("AimIK and LookAtIK need to have their 'Target' value assigned.", base.transform);
			}
			Pose();
			aim.solver.Update();
			if (lookAt != null)
			{
				lookAt.solver.Update();
			}
		}

		private void Pose()
		{
			LimitAimTarget();
			Vector3 direction = aim.solver.target.position - aim.solver.bones[0].transform.position;
			Vector3 localDirection = base.transform.InverseTransformDirection(direction);
			aimPose = aimPoser.GetPose(localDirection);
			if (aimPose != lastPose)
			{
				aimPoser.SetPoseActive(aimPose);
				lastPose = aimPose;
			}
			AimPoser.Pose[] poses = aimPoser.poses;
			foreach (AimPoser.Pose pose in poses)
			{
				if (pose == aimPose)
				{
					DirectCrossFade(pose.name, 1f);
				}
				else
				{
					DirectCrossFade(pose.name, 0f);
				}
			}
		}

		private void LimitAimTarget()
		{
			Vector3 position = aim.solver.bones[0].transform.position;
			Vector3 vector = aim.solver.target.position - position;
			vector = vector.normalized * Mathf.Max(vector.magnitude, minAimDistance);
			aim.solver.target.position = position + vector;
		}

		private void DirectCrossFade(string state, float target)
		{
			float value = Mathf.MoveTowards(animator.GetFloat(state), target, Time.deltaTime * (1f / crossfadeTime));
			animator.SetFloat(state, value);
		}
	}
	public class TerrainOffset : MonoBehaviour
	{
		public AimIK aimIK;

		public Vector3 raycastOffset = new Vector3(0f, 2f, 1.5f);

		public LayerMask raycastLayers;

		public float min = -2f;

		public float max = 2f;

		public float lerpSpeed = 10f;

		private RaycastHit hit;

		private Vector3 offset;

		private void LateUpdate()
		{
			Vector3 vector = base.transform.rotation * raycastOffset;
			Vector3 groundHeightOffset = GetGroundHeightOffset(base.transform.position + vector);
			offset = Vector3.Lerp(offset, groundHeightOffset, Time.deltaTime * lerpSpeed);
			Vector3 vector2 = base.transform.position + new Vector3(vector.x, 0f, vector.z);
			aimIK.solver.transform.LookAt(vector2);
			aimIK.solver.IKPosition = vector2 + offset;
		}

		private Vector3 GetGroundHeightOffset(Vector3 worldPosition)
		{
			Debug.DrawRay(worldPosition, Vector3.down * raycastOffset.y * 2f, Color.green);
			if (Physics.Raycast(worldPosition, Vector3.down, out hit, raycastOffset.y * 2f))
			{
				return Mathf.Clamp(hit.point.y - base.transform.position.y, min, max) * Vector3.up;
			}
			return Vector3.zero;
		}
	}
	public class BipedIKvsAnimatorIK : MonoBehaviour
	{
		[LargeHeader("References")]
		public Animator animator;

		public BipedIK bipedIK;

		[LargeHeader("Look At")]
		public Transform lookAtTargetBiped;

		public Transform lookAtTargetAnimator;

		[Range(0f, 1f)]
		public float lookAtWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtBodyWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtHeadWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtEyesWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtClampWeight = 0.5f;

		[Range(0f, 1f)]
		public float lookAtClampWeightHead = 0.5f;

		[Range(0f, 1f)]
		public float lookAtClampWeightEyes = 0.5f;

		[LargeHeader("Foot")]
		public Transform footTargetBiped;

		public Transform footTargetAnimator;

		[Range(0f, 1f)]
		public float footPositionWeight;

		[Range(0f, 1f)]
		public float footRotationWeight;

		[LargeHeader("Hand")]
		public Transform handTargetBiped;

		public Transform handTargetAnimator;

		[Range(0f, 1f)]
		public float handPositionWeight;

		[Range(0f, 1f)]
		public float handRotationWeight;

		private void OnAnimatorIK(int layer)
		{
			animator.transform.rotation = bipedIK.transform.rotation;
			Vector3 vector = animator.transform.position - bipedIK.transform.position;
			lookAtTargetAnimator.position = lookAtTargetBiped.position + vector;
			bipedIK.SetLookAtPosition(lookAtTargetBiped.position);
			bipedIK.SetLookAtWeight(lookAtWeight, lookAtBodyWeight, lookAtHeadWeight, lookAtEyesWeight, lookAtClampWeight, lookAtClampWeightHead, lookAtClampWeightEyes);
			animator.SetLookAtPosition(lookAtTargetAnimator.position);
			animator.SetLookAtWeight(lookAtWeight, lookAtBodyWeight, lookAtHeadWeight, lookAtEyesWeight, lookAtClampWeight);
			footTargetAnimator.position = footTargetBiped.position + vector;
			footTargetAnimator.rotation = footTargetBiped.rotation;
			bipedIK.SetIKPosition(AvatarIKGoal.LeftFoot, footTargetBiped.position);
			bipedIK.SetIKRotation(AvatarIKGoal.LeftFoot, footTargetBiped.rotation);
			bipedIK.SetIKPositionWeight(AvatarIKGoal.LeftFoot, footPositionWeight);
			bipedIK.SetIKRotationWeight(AvatarIKGoal.LeftFoot, footRotationWeight);
			animator.SetIKPosition(AvatarIKGoal.LeftFoot, footTargetAnimator.position);
			animator.SetIKRotation(AvatarIKGoal.LeftFoot, footTargetAnimator.rotation);
			animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, footPositionWeight);
			animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, footRotationWeight);
			handTargetAnimator.position = handTargetBiped.position + vector;
			handTargetAnimator.rotation = handTargetBiped.rotation;
			bipedIK.SetIKPosition(AvatarIKGoal.LeftHand, handTargetBiped.position);
			bipedIK.SetIKRotation(AvatarIKGoal.LeftHand, handTargetBiped.rotation);
			bipedIK.SetIKPositionWeight(AvatarIKGoal.LeftHand, handPositionWeight);
			bipedIK.SetIKRotationWeight(AvatarIKGoal.LeftHand, handRotationWeight);
			animator.SetIKPosition(AvatarIKGoal.LeftHand, handTargetAnimator.position);
			animator.SetIKRotation(AvatarIKGoal.LeftHand, handTargetAnimator.rotation);
			animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, handPositionWeight);
			animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, handRotationWeight);
		}
	}
	public class MechSpider : MonoBehaviour
	{
		public LayerMask raycastLayers;

		public float scale = 1f;

		public Transform body;

		public MechSpiderLeg[] legs;

		public float legRotationWeight = 1f;

		public float rootPositionSpeed = 5f;

		public float rootRotationSpeed = 30f;

		public float breatheSpeed = 2f;

		public float breatheMagnitude = 0.2f;

		public float height = 3.5f;

		public float minHeight = 2f;

		public float raycastHeight = 10f;

		public float raycastDistance = 5f;

		private Vector3 lastPosition;

		private Vector3 defaultBodyLocalPosition;

		private float sine;

		private RaycastHit rootHit;

		private void Update()
		{
			Vector3 legsPlaneNormal = GetLegsPlaneNormal();
			Quaternion quaternion = Quaternion.FromToRotation(base.transform.up, legsPlaneNormal);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion * base.transform.rotation, Time.deltaTime * rootRotationSpeed);
			Vector3 legCentroid = GetLegCentroid();
			Vector3 vector = Vector3.Project(legCentroid + base.transform.up * height * scale - base.transform.position, base.transform.up);
			base.transform.position += vector * Time.deltaTime * (rootPositionSpeed * scale);
			if (Physics.Raycast(base.transform.position + base.transform.up * raycastHeight * scale, -base.transform.up, out rootHit, raycastHeight * scale + raycastDistance * scale, raycastLayers))
			{
				rootHit.distance -= raycastHeight * scale + minHeight * scale;
				if (rootHit.distance < 0f)
				{
					Vector3 b = base.transform.position - base.transform.up * rootHit.distance;
					base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * rootPositionSpeed * scale);
				}
			}
			sine += Time.deltaTime * breatheSpeed;
			if (sine >= (float)Math.PI * 2f)
			{
				sine -= (float)Math.PI * 2f;
			}
			float num = Mathf.Sin(sine) * breatheMagnitude * scale;
			Vector3 vector2 = base.transform.up * num;
			body.transform.position = base.transform.position + vector2;
		}

		private Vector3 GetLegCentroid()
		{
			Vector3 zero = Vector3.zero;
			float num = 1f / (float)legs.Length;
			for (int i = 0; i < legs.Length; i++)
			{
				zero += legs[i].position * num;
			}
			return zero;
		}

		private Vector3 GetLegsPlaneNormal()
		{
			Vector3 vector = base.transform.up;
			if (legRotationWeight <= 0f)
			{
				return vector;
			}
			float t = 1f / Mathf.Lerp(legs.Length, 1f, legRotationWeight);
			for (int i = 0; i < legs.Length; i++)
			{
				Vector3 vector2 = legs[i].position - (base.transform.position - base.transform.up * height * scale);
				Vector3 normal = base.transform.up;
				Vector3 tangent = vector2;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				Quaternion b = Quaternion.FromToRotation(tangent, vector2);
				b = Quaternion.Lerp(Quaternion.identity, b, t);
				vector = b * vector;
			}
			return vector;
		}
	}
	public class MechSpiderController : MonoBehaviour
	{
		public MechSpider mechSpider;

		public Transform cameraTransform;

		public float speed = 6f;

		public float turnSpeed = 30f;

		public Vector3 inputVector => new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));

		private void Update()
		{
			Vector3 tangent = cameraTransform.forward;
			Vector3 normal = base.transform.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			Quaternion quaternion = Quaternion.LookRotation(tangent, base.transform.up);
			base.transform.Translate(quaternion * inputVector.normalized * Time.deltaTime * speed * mechSpider.scale, Space.World);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * turnSpeed);
		}
	}
	public class MechSpiderLeg : MonoBehaviour
	{
		public MechSpider mechSpider;

		public MechSpiderLeg unSync;

		public Vector3 offset;

		public float minDelay = 0.2f;

		public float maxOffset = 1f;

		public float stepSpeed = 5f;

		public float footHeight = 0.15f;

		public float velocityPrediction = 0.2f;

		public float raycastFocus = 0.1f;

		public AnimationCurve yOffset;

		public ParticleSystem sand;

		private IK ik;

		private float stepProgress = 1f;

		private float lastStepTime;

		private Vector3 defaultPosition;

		private RaycastHit hit = default(RaycastHit);

		public bool isStepping => stepProgress < 1f;

		public Vector3 position
		{
			get
			{
				return ik.GetIKSolver().GetIKPosition();
			}
			set
			{
				ik.GetIKSolver().SetIKPosition(value);
			}
		}

		private void Start()
		{
			ik = GetComponent<IK>();
			stepProgress = 1f;
			hit = default(RaycastHit);
			IKSolver.Point[] points = ik.GetIKSolver().GetPoints();
			position = points[points.Length - 1].transform.position;
			hit.point = position;
			defaultPosition = mechSpider.transform.InverseTransformPoint(position + offset * mechSpider.scale);
		}

		private Vector3 GetStepTarget(out bool stepFound, float focus, float distance)
		{
			stepFound = false;
			Vector3 vector = mechSpider.transform.TransformPoint(defaultPosition);
			vector += (hit.point - position) * velocityPrediction;
			Vector3 up = mechSpider.transform.up;
			Vector3 rhs = mechSpider.body.position - position;
			Vector3 axis = Vector3.Cross(up, rhs);
			up = Quaternion.AngleAxis(focus, axis) * up;
			if (Physics.Raycast(vector + up * mechSpider.raycastHeight * mechSpider.scale, -up, out hit, mechSpider.raycastHeight * mechSpider.scale + distance, mechSpider.raycastLayers))
			{
				stepFound = true;
			}
			return hit.point + mechSpider.transform.up * footHeight * mechSpider.scale;
		}

		private void Update()
		{
			if (!isStepping && !(Time.time < lastStepTime + minDelay) && (!(unSync != null) || !unSync.isStepping))
			{
				bool stepFound = false;
				Vector3 stepTarget = GetStepTarget(out stepFound, raycastFocus, mechSpider.raycastDistance * mechSpider.scale);
				if (!stepFound)
				{
					stepTarget = GetStepTarget(out stepFound, 0f - raycastFocus, mechSpider.raycastDistance * 3f * mechSpider.scale);
				}
				if (stepFound && !(Vector3.Distance(position, stepTarget) < maxOffset * mechSpider.scale * Random.Range(0.9f, 1.2f)))
				{
					StopAllCoroutines();
					StartCoroutine(Step(position, stepTarget));
				}
			}
		}

		private IEnumerator Step(Vector3 stepStartPosition, Vector3 targetPosition)
		{
			stepProgress = 0f;
			while (stepProgress < 1f)
			{
				stepProgress += Time.deltaTime * stepSpeed;
				position = Vector3.Lerp(stepStartPosition, targetPosition, stepProgress);
				position += mechSpider.transform.up * yOffset.Evaluate(stepProgress) * mechSpider.scale;
				yield return null;
			}
			position = targetPosition;
			if (sand != null)
			{
				sand.transform.position = position - mechSpider.transform.up * footHeight * mechSpider.scale;
				sand.Emit(20);
			}
			lastStepTime = Time.time;
		}
	}
	public class MechSpiderParticles : MonoBehaviour
	{
		public MechSpiderController mechSpiderController;

		private ParticleSystem particles;

		private void Start()
		{
			particles = (ParticleSystem)GetComponent(typeof(ParticleSystem));
		}

		private void Update()
		{
			float magnitude = mechSpiderController.inputVector.magnitude;
			float constant = Mathf.Clamp(magnitude * 50f, 30f, 50f);
			ParticleSystem.EmissionModule emission = particles.emission;
			emission.rateOverTime = new ParticleSystem.MinMaxCurve(constant);
			ParticleSystem.MainModule main = particles.main;
			main.startColor = new Color(particles.main.startColor.color.r, particles.main.startColor.color.g, particles.main.startColor.color.b, Mathf.Clamp(magnitude, 0.4f, 1f));
		}
	}
	public class AnimationWarping : OffsetModifier
	{
		[Serializable]
		public struct Warp
		{
			[Tooltip("Layer of the 'Animation State' in the Animator.")]
			public int animationLayer;

			[Tooltip("Name of the state in the Animator to warp.")]
			public string animationState;

			[Tooltip("Warping weight by normalized time of the animation state.")]
			public AnimationCurve weightCurve;

			[Tooltip("Animated point to warp from. This should be in character space so keep this Transform parented to the root of the character.")]
			public Transform warpFrom;

			[Tooltip("World space point to warp to.")]
			public Transform warpTo;

			[Tooltip("Which FBBIK effector to use?")]
			public FullBodyBipedEffector effector;
		}

		[Serializable]
		public enum EffectorMode
		{
			PositionOffset,
			Position
		}

		[Tooltip("Reference to the Animator component to use")]
		public Animator animator;

		[Tooltip("Using effector.positionOffset or effector.position with effector.positionWeight? The former will enable you to use effector.position for other things, the latter will weigh in the effectors, hence using Reach and Pull in the process.")]
		public EffectorMode effectorMode;

		[Space(10f)]
		[Tooltip("The array of warps, can have multiple simultaneous warps.")]
		public Warp[] warps;

		private EffectorMode lastMode;

		protected override void Start()
		{
			base.Start();
			lastMode = effectorMode;
		}

		public float GetWarpWeight(int warpIndex)
		{
			if (warpIndex < 0)
			{
				Debug.LogError("Warp index out of range.");
				return 0f;
			}
			if (warpIndex >= warps.Length)
			{
				Debug.LogError("Warp index out of range.");
				return 0f;
			}
			if (animator == null)
			{
				Debug.LogError("Animator unassigned in AnimationWarping");
				return 0f;
			}
			AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(warps[warpIndex].animationLayer);
			if (!currentAnimatorStateInfo.IsName(warps[warpIndex].animationState))
			{
				return 0f;
			}
			return warps[warpIndex].weightCurve.Evaluate(currentAnimatorStateInfo.normalizedTime - (float)(int)currentAnimatorStateInfo.normalizedTime);
		}

		protected override void OnModifyOffset()
		{
			for (int i = 0; i < warps.Length; i++)
			{
				float warpWeight = GetWarpWeight(i);
				Vector3 vector = warps[i].warpTo.position - warps[i].warpFrom.position;
				switch (effectorMode)
				{
				case EffectorMode.PositionOffset:
					ik.solver.GetEffector(warps[i].effector).positionOffset += vector * warpWeight * weight;
					break;
				case EffectorMode.Position:
					ik.solver.GetEffector(warps[i].effector).position = ik.solver.GetEffector(warps[i].effector).bone.position + vector;
					ik.solver.GetEffector(warps[i].effector).positionWeight = weight * warpWeight;
					break;
				}
			}
			if (lastMode == EffectorMode.Position && effectorMode == EffectorMode.PositionOffset)
			{
				Warp[] array = warps;
				for (int j = 0; j < array.Length; j++)
				{
					Warp warp = array[j];
					ik.solver.GetEffector(warp.effector).positionWeight = 0f;
				}
			}
			lastMode = effectorMode;
		}

		private void OnDisable()
		{
			if (effectorMode == EffectorMode.Position)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					ik.solver.GetEffector(warp.effector).positionWeight = 0f;
				}
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class AnimatorController3rdPerson : MonoBehaviour
	{
		public float rotateSpeed = 7f;

		public float blendSpeed = 10f;

		public float maxAngle = 90f;

		public float moveSpeed = 1.5f;

		public float rootMotionWeight;

		protected Animator animator;

		protected Vector3 moveBlend;

		protected Vector3 moveInput;

		protected Vector3 velocity;

		protected virtual void Start()
		{
			animator = GetComponent<Animator>();
		}

		private void OnAnimatorMove()
		{
			velocity = Vector3.Lerp(velocity, base.transform.rotation * Vector3.ClampMagnitude(moveInput, 1f) * moveSpeed, Time.deltaTime * blendSpeed);
			base.transform.position += Vector3.Lerp(velocity * Time.deltaTime, animator.deltaPosition, rootMotionWeight);
		}

		public virtual void Move(Vector3 moveInput, bool isMoving, Vector3 faceDirection, Vector3 aimTarget)
		{
			this.moveInput = moveInput;
			Vector3 vector = base.transform.InverseTransformDirection(faceDirection);
			float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			float num2 = num * Time.deltaTime * rotateSpeed;
			if (num > maxAngle)
			{
				num2 = Mathf.Clamp(num2, num - maxAngle, num2);
			}
			if (num < 0f - maxAngle)
			{
				num2 = Mathf.Clamp(num2, num2, num + maxAngle);
			}
			base.transform.Rotate(Vector3.up, num2);
			moveBlend = Vector3.Lerp(moveBlend, moveInput, Time.deltaTime * blendSpeed);
			animator.SetFloat("X", moveBlend.x);
			animator.SetFloat("Z", moveBlend.z);
			animator.SetBool("IsMoving", isMoving);
		}
	}
	[RequireComponent(typeof(AimIK))]
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class AnimatorController3rdPersonIK : AnimatorController3rdPerson
	{
		[Range(0f, 1f)]
		public float headLookWeight = 1f;

		public Vector3 gunHoldOffset;

		public Vector3 leftHandOffset;

		public Recoil recoil;

		private AimIK aim;

		private FullBodyBipedIK ik;

		private Vector3 headLookAxis;

		private Vector3 leftHandPosRelToRightHand;

		private Quaternion leftHandRotRelToRightHand;

		private Vector3 aimTarget;

		private Quaternion rightHandRotation;

		protected override void Start()
		{
			base.Start();
			aim = GetComponent<AimIK>();
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			aim.enabled = false;
			ik.enabled = false;
			headLookAxis = ik.references.head.InverseTransformVector(ik.references.root.forward);
			animator.SetLayerWeight(1, 1f);
		}

		public override void Move(Vector3 moveInput, bool isMoving, Vector3 faceDirection, Vector3 aimTarget)
		{
			base.Move(moveInput, isMoving, faceDirection, aimTarget);
			this.aimTarget = aimTarget;
			Read();
			AimIK();
			FBBIK();
			HeadLookAt(aimTarget);
		}

		private void Read()
		{
			leftHandPosRelToRightHand = ik.references.rightHand.InverseTransformPoint(ik.references.leftHand.position);
			leftHandRotRelToRightHand = Quaternion.Inverse(ik.references.rightHand.rotation) * ik.references.leftHand.rotation;
		}

		private void AimIK()
		{
			aim.solver.IKPosition = aimTarget;
			aim.solver.Update();
		}

		private void FBBIK()
		{
			rightHandRotation = ik.references.rightHand.rotation;
			Vector3 vector = ik.references.rightHand.rotation * gunHoldOffset;
			ik.solver.rightHandEffector.positionOffset += vector;
			if (recoil != null)
			{
				recoil.SetHandRotations(rightHandRotation * leftHandRotRelToRightHand, rightHandRotation);
			}
			ik.solver.Update();
			if (recoil != null)
			{
				ik.references.rightHand.rotation = recoil.rotationOffset * rightHandRotation;
				ik.references.leftHand.rotation = recoil.rotationOffset * rightHandRotation * leftHandRotRelToRightHand;
			}
			else
			{
				ik.references.rightHand.rotation = rightHandRotation;
				ik.references.leftHand.rotation = rightHandRotation * leftHandRotRelToRightHand;
			}
		}

		private void OnPreRead()
		{
			Quaternion quaternion = ((!(recoil != null)) ? rightHandRotation : (recoil.rotationOffset * rightHandRotation));
			Vector3 vector = ik.references.rightHand.position + ik.solver.rightHandEffector.positionOffset + quaternion * leftHandPosRelToRightHand;
			ik.solver.leftHandEffector.positionOffset += vector - ik.references.leftHand.position - ik.solver.leftHandEffector.positionOffset + quaternion * leftHandOffset;
		}

		private void HeadLookAt(Vector3 lookAtTarget)
		{
			Quaternion b = Quaternion.FromToRotation(ik.references.head.rotation * headLookAxis, lookAtTarget - ik.references.head.position);
			ik.references.head.rotation = Quaternion.Lerp(Quaternion.identity, b, headLookWeight) * ik.references.head.rotation;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			}
		}
	}
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class CharacterAnimationThirdPersonIK : CharacterAnimationThirdPerson
	{
		private FullBodyBipedIK ik;

		protected override void Start()
		{
			base.Start();
			ik = GetComponent<FullBodyBipedIK>();
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
			if (!(Vector3.Angle(base.transform.up, Vector3.up) <= 0.01f))
			{
				Quaternion rotation = Quaternion.FromToRotation(base.transform.up, Vector3.up);
				RotateEffector(ik.solver.bodyEffector, rotation, 0.1f);
				RotateEffector(ik.solver.leftShoulderEffector, rotation, 0.2f);
				RotateEffector(ik.solver.rightShoulderEffector, rotation, 0.2f);
				RotateEffector(ik.solver.leftHandEffector, rotation, 0.1f);
				RotateEffector(ik.solver.rightHandEffector, rotation, 0.1f);
			}
		}

		private void RotateEffector(IKEffector effector, Quaternion rotation, float mlp)
		{
			Vector3 vector = effector.bone.position - base.transform.position;
			Vector3 vector2 = rotation * vector;
			Vector3 vector3 = vector2 - vector;
			effector.positionOffset += vector3 * mlp;
		}
	}
	[RequireComponent(typeof(AnimatorController3rdPerson))]
	public class CharacterController3rdPerson : MonoBehaviour
	{
		[SerializeField]
		private CameraController cam;

		private AnimatorController3rdPerson animatorController;

		private static Vector3 inputVector => new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));

		private static Vector3 inputVectorRaw => new Vector3(Input.GetAxisRaw("Horizontal"), 0f, Input.GetAxisRaw("Vertical"));

		private void Start()
		{
			animatorController = GetComponent<AnimatorController3rdPerson>();
			cam.enabled = false;
		}

		private void LateUpdate()
		{
			cam.UpdateInput();
			cam.UpdateTransform();
			Vector3 moveInput = inputVector;
			bool isMoving = inputVector != Vector3.zero || inputVectorRaw != Vector3.zero;
			Vector3 forward = cam.transform.forward;
			Vector3 aimTarget = cam.transform.position + forward * 10f;
			animatorController.Move(moveInput, isMoving, forward, aimTarget);
		}
	}
	public class EffectorOffset : OffsetModifier
	{
		[Range(0f, 1f)]
		public float handsMaintainRelativePositionWeight;

		public Vector3 bodyOffset;

		public Vector3 leftShoulderOffset;

		public Vector3 rightShoulderOffset;

		public Vector3 leftThighOffset;

		public Vector3 rightThighOffset;

		public Vector3 leftHandOffset;

		public Vector3 rightHandOffset;

		public Vector3 leftFootOffset;

		public Vector3 rightFootOffset;

		protected override void OnModifyOffset()
		{
			ik.solver.leftHandEffector.maintainRelativePositionWeight = handsMaintainRelativePositionWeight;
			ik.solver.rightHandEffector.maintainRelativePositionWeight = handsMaintainRelativePositionWeight;
			ik.solver.bodyEffector.positionOffset += base.transform.rotation * bodyOffset * weight;
			ik.solver.leftShoulderEffector.positionOffset += base.transform.rotation * leftShoulderOffset * weight;
			ik.solver.rightShoulderEffector.positionOffset += base.transform.rotation * rightShoulderOffset * weight;
			ik.solver.leftThighEffector.positionOffset += base.transform.rotation * leftThighOffset * weight;
			ik.solver.rightThighEffector.positionOffset += base.transform.rotation * rightThighOffset * weight;
			ik.solver.leftHandEffector.positionOffset += base.transform.rotation * leftHandOffset * weight;
			ik.solver.rightHandEffector.positionOffset += base.transform.rotation * rightHandOffset * weight;
			ik.solver.leftFootEffector.positionOffset += base.transform.rotation * leftFootOffset * weight;
			ik.solver.rightFootEffector.positionOffset += base.transform.rotation * rightFootOffset * weight;
		}
	}
	public class ExplosionDemo : MonoBehaviour
	{
		public SimpleLocomotion character;

		public float forceMlp = 1f;

		public float upForce = 1f;

		public float weightFalloffSpeed = 1f;

		public AnimationCurve weightFalloff;

		public AnimationCurve explosionForceByDistance;

		public AnimationCurve scale;

		private float weight;

		private Vector3 defaultScale = Vector3.one;

		private Rigidbody r;

		private FullBodyBipedIK ik;

		private void Start()
		{
			defaultScale = base.transform.localScale;
			r = character.GetComponent<Rigidbody>();
			ik = character.GetComponent<FullBodyBipedIK>();
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight - Time.deltaTime * weightFalloffSpeed, 0f, 1f);
			if (Input.GetKeyDown(KeyCode.E) && character.isGrounded)
			{
				ik.solver.IKPositionWeight = 1f;
				ik.solver.leftHandEffector.position = ik.solver.leftHandEffector.bone.position;
				ik.solver.rightHandEffector.position = ik.solver.rightHandEffector.bone.position;
				ik.solver.leftFootEffector.position = ik.solver.leftFootEffector.bone.position;
				ik.solver.rightFootEffector.position = ik.solver.rightFootEffector.bone.position;
				weight = 1f;
				Vector3 vector = r.position - base.transform.position;
				vector.y = 0f;
				float num = explosionForceByDistance.Evaluate(vector.magnitude);
				r.velocity = (vector.normalized + Vector3.up * upForce) * num * forceMlp;
			}
			if (weight < 0.5f && character.isGrounded)
			{
				weight = Mathf.Clamp(weight - Time.deltaTime * 3f, 0f, 1f);
			}
			SetEffectorWeights(weightFalloff.Evaluate(weight));
			base.transform.localScale = scale.Evaluate(weight) * defaultScale;
		}

		private void SetEffectorWeights(float w)
		{
			ik.solver.leftHandEffector.positionWeight = w;
			ik.solver.rightHandEffector.positionWeight = w;
			ik.solver.leftFootEffector.positionWeight = w;
			ik.solver.rightFootEffector.positionWeight = w;
		}
	}
	public class FBBIKSettings : MonoBehaviour
	{
		[Serializable]
		public class Limb
		{
			public FBIKChain.Smoothing reachSmoothing;

			public float maintainRelativePositionWeight;

			public float mappingWeight = 1f;

			public void Apply(FullBodyBipedChain chain, IKSolverFullBodyBiped solver)
			{
				solver.GetChain(chain).reachSmoothing = reachSmoothing;
				solver.GetEndEffector(chain).maintainRelativePositionWeight = maintainRelativePositionWeight;
				solver.GetLimbMapping(chain).weight = mappingWeight;
			}
		}

		public FullBodyBipedIK ik;

		public bool disableAfterStart;

		public Limb leftArm;

		public Limb rightArm;

		public Limb leftLeg;

		public Limb rightLeg;

		public float rootPin;

		public bool bodyEffectChildNodes = true;

		public void UpdateSettings()
		{
			if (!(ik == null))
			{
				leftArm.Apply(FullBodyBipedChain.LeftArm, ik.solver);
				rightArm.Apply(FullBodyBipedChain.RightArm, ik.solver);
				leftLeg.Apply(FullBodyBipedChain.LeftLeg, ik.solver);
				rightLeg.Apply(FullBodyBipedChain.RightLeg, ik.solver);
				ik.solver.chain[0].pin = rootPin;
				ik.solver.bodyEffector.effectChildNodes = bodyEffectChildNodes;
			}
		}

		private void Start()
		{
			Debug.Log("FBBIKSettings is deprecated, you can now edit all the settings from the custom inspector of the FullBodyBipedIK component.");
			UpdateSettings();
			if (disableAfterStart)
			{
				base.enabled = false;
			}
		}

		private void Update()
		{
			UpdateSettings();
		}
	}
	public class FBIKBendGoal : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public FullBodyBipedChain chain;

		public float weight;

		private void Start()
		{
			Debug.Log("FBIKBendGoal is deprecated, you can now a bend goal from the custom inspector of the FullBodyBipedIK component.");
		}

		private void Update()
		{
			if (!(ik == null))
			{
				ik.solver.GetBendConstraint(chain).bendGoal = base.transform;
				ik.solver.GetBendConstraint(chain).weight = weight;
			}
		}
	}
	public class FBIKBoxing : MonoBehaviour
	{
		[Tooltip("The target we want to hit")]
		public Transform target;

		[Tooltip("The pin Transform is used to reference the exact hit point in the animation (used by AimIK to aim the upper body to follow the target).In Legacy and Generic modes you can just create and position a reference point in your animating software and include it in the FBX. Then in Unity if you added a GameObject with the exact same name under the character's root, it would be animated to the required position.In Humanoid mode however, Mecanim loses track of any Transform that does not belong to the avatar, so in this case the pin point has to be manually set inside the Unity Editor.")]
		public Transform pin;

		[Tooltip("The Full Body Biped IK component")]
		public FullBodyBipedIK ik;

		[Tooltip("The Aim IK component. Aim IK is ust used for following the target slightly with the body.")]
		public AimIK aim;

		[Tooltip("The master weight")]
		public float weight;

		[Tooltip("The effector type of the punching hand")]
		public FullBodyBipedEffector effector;

		[Tooltip("Weight of aiming the body to follow the target")]
		public AnimationCurve aimWeight;

		private Animator animator;

		private void Start()
		{
			animator = GetComponent<Animator>();
		}

		private void LateUpdate()
		{
			float @float = animator.GetFloat("HitWeight");
			ik.solver.GetEffector(effector).position = target.position;
			ik.solver.GetEffector(effector).positionWeight = @float * weight;
			if (aim != null)
			{
				aim.solver.transform.LookAt(pin.position);
				aim.solver.IKPosition = target.position;
				aim.solver.IKPositionWeight = aimWeight.Evaluate(@float) * weight;
			}
		}
	}
	public class FBIKHandsOnProp : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public bool leftHanded;

		private void Awake()
		{
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
		}

		private void OnPreRead()
		{
			if (leftHanded)
			{
				HandsOnProp(ik.solver.leftHandEffector, ik.solver.rightHandEffector);
			}
			else
			{
				HandsOnProp(ik.solver.rightHandEffector, ik.solver.leftHandEffector);
			}
		}

		private void HandsOnProp(IKEffector mainHand, IKEffector otherHand)
		{
			Vector3 vector = otherHand.bone.position - mainHand.bone.position;
			Vector3 vector2 = Quaternion.Inverse(mainHand.bone.rotation) * vector;
			Vector3 vector3 = mainHand.bone.position + vector * 0.5f;
			Quaternion quaternion = Quaternion.Inverse(mainHand.bone.rotation) * otherHand.bone.rotation;
			Vector3 toDirection = otherHand.bone.position + otherHand.positionOffset - (mainHand.bone.position + mainHand.positionOffset);
			Vector3 vector4 = mainHand.bone.position + mainHand.positionOffset + vector * 0.5f;
			mainHand.position = mainHand.bone.position + mainHand.positionOffset + (vector4 - vector3);
			mainHand.positionWeight = 1f;
			Quaternion quaternion2 = Quaternion.FromToRotation(vector, toDirection);
			mainHand.rotation = quaternion2 * mainHand.bone.rotation;
			mainHand.rotationWeight = 1f;
			otherHand.position = mainHand.position + mainHand.rotation * vector2;
			otherHand.positionWeight = 1f;
			otherHand.rotation = mainHand.rotation * quaternion;
			otherHand.rotationWeight = 1f;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			}
		}
	}
	public class FPSAiming : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float aimWeight = 1f;

		[Range(0f, 1f)]
		public float sightWeight = 1f;

		[Range(0f, 180f)]
		public float maxAngle = 80f;

		[SerializeField]
		private bool animatePhysics;

		[SerializeField]
		private Transform gun;

		[SerializeField]
		private Transform gunTarget;

		[SerializeField]
		private FullBodyBipedIK ik;

		[SerializeField]
		private AimIK gunAim;

		[SerializeField]
		private CameraControllerFPS cam;

		[SerializeField]
		private Recoil recoil;

		[SerializeField]
		[Range(0f, 1f)]
		private float cameraRecoilWeight = 0.5f;

		private Vector3 gunTargetDefaultLocalPosition;

		private Quaternion gunTargetDefaultLocalRotation;

		private Vector3 camDefaultLocalPosition;

		private Vector3 camRelativeToGunTarget;

		private bool updateFrame;

		private void Start()
		{
			gunTargetDefaultLocalPosition = gunTarget.localPosition;
			gunTargetDefaultLocalRotation = gunTarget.localRotation;
			camDefaultLocalPosition = cam.transform.localPosition;
			cam.enabled = false;
			gunAim.enabled = false;
			ik.enabled = false;
			if (recoil != null && ik.solver.iterations == 0)
			{
				Debug.LogWarning("FPSAiming with Recoil needs FBBIK solver iteration count to be at least 1 to maintain accuracy.");
			}
		}

		private void FixedUpdate()
		{
			updateFrame = true;
		}

		private void LateUpdate()
		{
			if (!animatePhysics)
			{
				updateFrame = true;
			}
			if (updateFrame)
			{
				updateFrame = false;
				cam.transform.localPosition = camDefaultLocalPosition;
				camRelativeToGunTarget = gunTarget.InverseTransformPoint(cam.transform.position);
				cam.LateUpdate();
				RotateCharacter();
				Aiming();
				LookDownTheSight();
			}
		}

		private void Aiming()
		{
			if (!(aimWeight <= 0f))
			{
				Quaternion rotation = cam.transform.rotation;
				gunAim.solver.IKPosition = cam.transform.position + cam.transform.forward * 10f;
				gunAim.solver.IKPositionWeight = aimWeight;
				gunAim.solver.Update();
				cam.transform.rotation = rotation;
			}
		}

		private void LookDownTheSight()
		{
			float t = aimWeight * sightWeight;
			gunTarget.position = Vector3.Lerp(gun.position, gunTarget.parent.TransformPoint(gunTargetDefaultLocalPosition), t);
			gunTarget.rotation = Quaternion.Lerp(gun.rotation, gunTarget.parent.rotation * gunTargetDefaultLocalRotation, t);
			Vector3 position = gun.InverseTransformPoint(ik.solver.leftHandEffector.bone.position);
			Vector3 position2 = gun.InverseTransformPoint(ik.solver.rightHandEffector.bone.position);
			Quaternion quaternion = Quaternion.Inverse(gun.rotation) * ik.solver.leftHandEffector.bone.rotation;
			Quaternion quaternion2 = Quaternion.Inverse(gun.rotation) * ik.solver.rightHandEffector.bone.rotation;
			float num = 1f;
			ik.solver.leftHandEffector.positionOffset += (gunTarget.TransformPoint(position) - (ik.solver.leftHandEffector.bone.position + ik.solver.leftHandEffector.positionOffset)) * num;
			ik.solver.rightHandEffector.positionOffset += (gunTarget.TransformPoint(position2) - (ik.solver.rightHandEffector.bone.position + ik.solver.rightHandEffector.positionOffset)) * num;
			ik.solver.headMapping.maintainRotationWeight = 1f;
			if (recoil != null)
			{
				recoil.SetHandRotations(gunTarget.rotation * quaternion, gunTarget.rotation * quaternion2);
			}
			ik.solver.Update();
			if (recoil != null)
			{
				ik.references.leftHand.rotation = recoil.rotationOffset * (gunTarget.rotation * quaternion);
				ik.references.rightHand.rotation = recoil.rotationOffset * (gunTarget.rotation * quaternion2);
			}
			else
			{
				ik.references.leftHand.rotation = gunTarget.rotation * quaternion;
				ik.references.rightHand.rotation = gunTarget.rotation * quaternion2;
			}
			cam.transform.position = Vector3.Lerp(cam.transform.position, Vector3.Lerp(gunTarget.TransformPoint(camRelativeToGunTarget), gun.transform.TransformPoint(camRelativeToGunTarget), cameraRecoilWeight), t);
		}

		private void RotateCharacter()
		{
			if (maxAngle >= 180f)
			{
				return;
			}
			if (maxAngle <= 0f)
			{
				base.transform.rotation = Quaternion.LookRotation(new Vector3(cam.transform.forward.x, 0f, cam.transform.forward.z));
				return;
			}
			Vector3 vector = base.transform.InverseTransformDirection(cam.transform.forward);
			float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			if (Mathf.Abs(num) > Mathf.Abs(maxAngle))
			{
				float angle = num - maxAngle;
				if (num < 0f)
				{
					angle = num + maxAngle;
				}
				base.transform.rotation = Quaternion.AngleAxis(angle, base.transform.up) * base.transform.rotation;
			}
		}
	}
	[RequireComponent(typeof(FPSAiming))]
	[RequireComponent(typeof(Animator))]
	public class FPSCharacter : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float walkSpeed = 0.5f;

		private float sVel;

		private Animator animator;

		private FPSAiming FPSAiming;

		private void Start()
		{
			animator = GetComponent<Animator>();
			FPSAiming = GetComponent<FPSAiming>();
		}

		private void Update()
		{
			FPSAiming.sightWeight = Mathf.SmoothDamp(FPSAiming.sightWeight, (!Input.GetMouseButton(1)) ? 0f : 1f, ref sVel, 0.1f);
			if (FPSAiming.sightWeight < 0.001f)
			{
				FPSAiming.sightWeight = 0f;
			}
			if (FPSAiming.sightWeight > 0.999f)
			{
				FPSAiming.sightWeight = 1f;
			}
			animator.SetFloat("Speed", walkSpeed);
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(Screen.width - 210, 10f, 200f, 25f), "Hold RMB to aim down the sight");
		}
	}
	public class HitReactionTrigger : MonoBehaviour
	{
		[SerializeField]
		private HitReaction hitReaction;

		[SerializeField]
		private float hitForce = 1f;

		private string colliderName;

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
				RaycastHit hitInfo = default(RaycastHit);
				if (Physics.Raycast(ray, out hitInfo, 100f))
				{
					hitReaction.Hit(hitInfo.collider, ray.direction * hitForce, hitInfo.point);
					colliderName = hitInfo.collider.name;
				}
			}
		}

		private void OnGUI()
		{
			GUILayout.Label("LMB to shoot the Dummy, RMB to rotate the camera.");
			if (colliderName != string.Empty)
			{
				GUILayout.Label("Last Bone Hit: " + colliderName);
			}
		}
	}
	public class HoldingHands : MonoBehaviour
	{
		public FullBodyBipedIK rightHandChar;

		public FullBodyBipedIK leftHandChar;

		public Transform rightHandTarget;

		public Transform leftHandTarget;

		public float crossFade;

		public float speed = 10f;

		private Quaternion rightHandRotation;

		private Quaternion leftHandRotation;

		private void Start()
		{
			rightHandRotation = Quaternion.Inverse(rightHandChar.solver.rightHandEffector.bone.rotation) * base.transform.rotation;
			leftHandRotation = Quaternion.Inverse(leftHandChar.solver.leftHandEffector.bone.rotation) * base.transform.rotation;
		}

		private void LateUpdate()
		{
			Vector3 b = Vector3.Lerp(rightHandChar.solver.rightHandEffector.bone.position, leftHandChar.solver.leftHandEffector.bone.position, crossFade);
			base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * speed);
			base.transform.rotation = Quaternion.Slerp(rightHandChar.solver.rightHandEffector.bone.rotation * rightHandRotation, leftHandChar.solver.leftHandEffector.bone.rotation * leftHandRotation, crossFade);
			rightHandChar.solver.rightHandEffector.position = rightHandTarget.position;
			rightHandChar.solver.rightHandEffector.rotation = rightHandTarget.rotation;
			leftHandChar.solver.leftHandEffector.position = leftHandTarget.position;
			leftHandChar.solver.leftHandEffector.rotation = leftHandTarget.rotation;
		}
	}
	public class InteractionC2CDemo : MonoBehaviour
	{
		public InteractionSystem character1;

		public InteractionSystem character2;

		public InteractionObject handShake;

		private void OnGUI()
		{
			if (GUILayout.Button("Shake Hands"))
			{
				character1.StartInteraction(FullBodyBipedEffector.RightHand, handShake, interrupt: true);
				character2.StartInteraction(FullBodyBipedEffector.RightHand, handShake, interrupt: true);
			}
		}

		private void LateUpdate()
		{
			Vector3 position = Vector3.Lerp(character1.ik.solver.rightHandEffector.bone.position, character2.ik.solver.rightHandEffector.bone.position, 0.5f);
			handShake.transform.position = position;
		}
	}
	public class InteractionDemo : MonoBehaviour
	{
		public InteractionSystem interactionSystem;

		public bool interrupt;

		public InteractionObject ball;

		public InteractionObject benchMain;

		public InteractionObject benchHands;

		public InteractionObject button;

		public InteractionObject cigarette;

		public InteractionObject door;

		private bool isSitting;

		private void OnGUI()
		{
			interrupt = GUILayout.Toggle(interrupt, "Interrupt");
			if (isSitting)
			{
				if (!interactionSystem.inInteraction && GUILayout.Button("Stand Up"))
				{
					interactionSystem.ResumeAll();
					isSitting = false;
				}
				return;
			}
			if (GUILayout.Button("Pick Up Ball"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, ball, interrupt);
			}
			if (GUILayout.Button("Button Left Hand"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, button, interrupt);
			}
			if (GUILayout.Button("Button Right Hand"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, button, interrupt);
			}
			if (GUILayout.Button("Put Out Cigarette"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightFoot, cigarette, interrupt);
			}
			if (GUILayout.Button("Open Door"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, door, interrupt);
			}
			if (!interactionSystem.inInteraction && GUILayout.Button("Sit Down"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.Body, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftThigh, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightThigh, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftFoot, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, benchHands, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, benchHands, interrupt);
				isSitting = true;
			}
		}
	}
	[RequireComponent(typeof(InteractionSystem))]
	public class InteractionSystemTestGUI : MonoBehaviour
	{
		[Tooltip("The object to interact to")]
		[SerializeField]
		private InteractionObject interactionObject;

		[Tooltip("The effectors to interact with")]
		[SerializeField]
		private FullBodyBipedEffector[] effectors;

		private InteractionSystem interactionSystem;

		private void Awake()
		{
			interactionSystem = GetComponent<InteractionSystem>();
		}

		private void OnGUI()
		{
			if (interactionSystem == null)
			{
				return;
			}
			if (GUILayout.Button("Start Interaction With " + interactionObject.name))
			{
				if (effectors.Length == 0)
				{
					Debug.Log("Please select the effectors to interact with.");
				}
				FullBodyBipedEffector[] array = effectors;
				foreach (FullBodyBipedEffector effectorType in array)
				{
					interactionSystem.StartInteraction(effectorType, interactionObject, interrupt: true);
				}
			}
			if (effectors.Length != 0 && interactionSystem.IsPaused(effectors[0]) && GUILayout.Button("Resume Interaction With " + interactionObject.name))
			{
				interactionSystem.ResumeAll();
			}
		}
	}
	public class KissingRig : MonoBehaviour
	{
		[Serializable]
		public class Partner
		{
			public FullBodyBipedIK ik;

			public Transform mouth;

			public Transform mouthTarget;

			public Transform touchTargetLeftHand;

			public Transform touchTargetRightHand;

			public float bodyWeightHorizontal = 0.4f;

			public float bodyWeightVertical = 1f;

			public float neckRotationWeight = 0.3f;

			public float headTiltAngle = 10f;

			public Vector3 headTiltAxis;

			private Quaternion neckRotation;

			private Transform neck => ik.solver.spineMapping.spineBones[ik.solver.spineMapping.spineBones.Length - 1];

			public void Initiate()
			{
				ik.enabled = false;
			}

			public void Update(float weight)
			{
				ik.solver.leftShoulderEffector.positionWeight = weight;
				ik.solver.rightShoulderEffector.positionWeight = weight;
				ik.solver.leftHandEffector.positionWeight = weight;
				ik.solver.rightHandEffector.positionWeight = weight;
				ik.solver.leftHandEffector.rotationWeight = weight;
				ik.solver.rightHandEffector.rotationWeight = weight;
				ik.solver.bodyEffector.positionWeight = weight;
				InverseTransformEffector(FullBodyBipedEffector.LeftShoulder, mouth, mouthTarget.position, weight);
				InverseTransformEffector(FullBodyBipedEffector.RightShoulder, mouth, mouthTarget.position, weight);
				InverseTransformEffector(FullBodyBipedEffector.Body, mouth, mouthTarget.position, weight);
				ik.solver.bodyEffector.position = Vector3.Lerp(new Vector3(ik.solver.bodyEffector.position.x, ik.solver.bodyEffector.bone.position.y, ik.solver.bodyEffector.position.z), ik.solver.bodyEffector.position, bodyWeightVertical * weight);
				ik.solver.bodyEffector.position = Vector3.Lerp(new Vector3(ik.solver.bodyEffector.bone.position.x, ik.solver.bodyEffector.position.y, ik.solver.bodyEffector.bone.position.z), ik.solver.bodyEffector.position, bodyWeightHorizontal * weight);
				ik.solver.leftHandEffector.position = touchTargetLeftHand.position;
				ik.solver.rightHandEffector.position = touchTargetRightHand.position;
				ik.solver.leftHandEffector.rotation = touchTargetLeftHand.rotation;
				ik.solver.rightHandEffector.rotation = touchTargetRightHand.rotation;
				neckRotation = neck.rotation;
				ik.solver.Update();
				neck.rotation = Quaternion.Slerp(neck.rotation, neckRotation, neckRotationWeight * weight);
				ik.references.head.localRotation = Quaternion.AngleAxis(headTiltAngle * weight, headTiltAxis) * ik.references.head.localRotation;
			}

			private void InverseTransformEffector(FullBodyBipedEffector effector, Transform target, Vector3 targetPosition, float weight)
			{
				Vector3 vector = ik.solver.GetEffector(effector).bone.position - target.position;
				ik.solver.GetEffector(effector).position = Vector3.Lerp(ik.solver.GetEffector(effector).bone.position, targetPosition + vector, weight);
			}
		}

		public Partner partner1;

		public Partner partner2;

		public float weight;

		public int iterations = 3;

		private void Start()
		{
			partner1.Initiate();
			partner2.Initiate();
		}

		private void LateUpdate()
		{
			for (int i = 0; i < iterations; i++)
			{
				partner1.Update(weight);
				partner2.Update(weight);
			}
		}
	}
	public class MotionAbsorb : MonoBehaviour
	{
		[Serializable]
		public class Absorber
		{
			[Tooltip("The type of effector (hand, foot, shoulder...) - this is just an enum")]
			public FullBodyBipedEffector effector;

			[Tooltip("How much should motion be absorbed on this effector")]
			public float weight = 1f;

			public void SetToBone(IKSolverFullBodyBiped solver)
			{
				solver.GetEffector(effector).position = solver.GetEffector(effector).bone.position;
				solver.GetEffector(effector).rotation = solver.GetEffector(effector).bone.rotation;
			}

			public void SetEffectorWeights(IKSolverFullBodyBiped solver, float w)
			{
				solver.GetEffector(effector).positionWeight = w * weight;
				solver.GetEffector(effector).rotationWeight = w * weight;
			}
		}

		[Tooltip("Reference to the FBBIK component")]
		public FullBodyBipedIK ik;

		[Tooltip("Array containing the absorbers")]
		public Absorber[] absorbers;

		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Weight falloff curve (how fast will the effect reduce after impact)")]
		public AnimationCurve falloff;

		[Tooltip("How fast will the impact fade away. (if 1, effect lasts for 1 second)")]
		public float falloffSpeed = 1f;

		private float timer;

		private void OnCollisionEnter()
		{
			if (!(timer > 0f))
			{
				StartCoroutine(AbsorbMotion());
			}
		}

		private IEnumerator AbsorbMotion()
		{
			timer = 1f;
			for (int i = 0; i < absorbers.Length; i++)
			{
				absorbers[i].SetToBone(ik.solver);
			}
			while (timer > 0f)
			{
				timer -= Time.deltaTime * falloffSpeed;
				float w = falloff.Evaluate(timer);
				for (int j = 0; j < absorbers.Length; j++)
				{
					absorbers[j].SetEffectorWeights(ik.solver, w * weight);
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class MotionAbsorbCharacter : MonoBehaviour
	{
		public Animator animator;

		public MotionAbsorb motionAbsorb;

		public Transform cube;

		public float cubeRandomPosition = 0.1f;

		public AnimationCurve motionAbsorbWeight;

		private Vector3 cubeDefaultPosition;

		private AnimatorStateInfo info;

		private Rigidbody cubeRigidbody;

		private void Start()
		{
			cubeDefaultPosition = cube.position;
			cubeRigidbody = cube.GetComponent<Rigidbody>();
		}

		private void Update()
		{
			info = animator.GetCurrentAnimatorStateInfo(0);
			motionAbsorb.weight = motionAbsorbWeight.Evaluate(info.normalizedTime - (float)(int)info.normalizedTime);
		}

		private void SwingStart()
		{
			cubeRigidbody.MovePosition(cubeDefaultPosition + Random.insideUnitSphere * cubeRandomPosition);
			cubeRigidbody.MoveRotation(Quaternion.identity);
			cubeRigidbody.velocity = Vector3.zero;
			cubeRigidbody.angularVelocity = Vector3.zero;
		}
	}
	public class OffsetEffector : OffsetModifier
	{
		[Serializable]
		public class EffectorLink
		{
			public FullBodyBipedEffector effectorType;

			public float weightMultiplier = 1f;

			[HideInInspector]
			public Vector3 localPosition;
		}

		public EffectorLink[] effectorLinks;

		protected override void Start()
		{
			base.Start();
			EffectorLink[] array = effectorLinks;
			foreach (EffectorLink effectorLink in array)
			{
				effectorLink.localPosition = base.transform.InverseTransformPoint(ik.solver.GetEffector(effectorLink.effectorType).bone.position);
				if (effectorLink.effectorType == FullBodyBipedEffector.Body)
				{
					ik.solver.bodyEffector.effectChildNodes = false;
				}
			}
		}

		protected override void OnModifyOffset()
		{
			EffectorLink[] array = effectorLinks;
			foreach (EffectorLink effectorLink in array)
			{
				Vector3 vector = base.transform.TransformPoint(effectorLink.localPosition);
				ik.solver.GetEffector(effectorLink.effectorType).positionOffset += (vector - (ik.solver.GetEffector(effectorLink.effectorType).bone.position + ik.solver.GetEffector(effectorLink.effectorType).positionOffset)) * weight * effectorLink.weightMultiplier;
			}
		}
	}
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class PendulumExample : MonoBehaviour
	{
		[Tooltip("The master weight of this script.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("Multiplier for the distance of the root to the target.")]
		public float hangingDistanceMlp = 1.3f;

		[Tooltip("Where does the root of the character land when weight is blended out?")]
		[HideInInspector]
		public Vector3 rootTargetPosition;

		[Tooltip("How is the root of the character rotated when weight is blended out?")]
		[HideInInspector]
		public Quaternion rootTargetRotation;

		[SerializeField]
		private Transform target;

		[SerializeField]
		private Transform leftHandTarget;

		[SerializeField]
		private Transform rightHandTarget;

		[SerializeField]
		private Transform leftFootTarget;

		[SerializeField]
		private Transform rightFootTarget;

		[SerializeField]
		private Transform pelvisTarget;

		[SerializeField]
		private Transform bodyTarget;

		[SerializeField]
		private Transform headTarget;

		[SerializeField]
		private Vector3 pelvisDownAxis = Vector3.right;

		private FullBodyBipedIK ik;

		private Quaternion rootRelativeToPelvis;

		private Vector3 pelvisToRoot;

		private float lastWeight;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			Quaternion rotation = target.rotation;
			target.rotation = leftHandTarget.rotation;
			FixedJoint fixedJoint = target.gameObject.AddComponent<FixedJoint>();
			fixedJoint.connectedBody = leftHandTarget.GetComponent<Rigidbody>();
			target.GetComponent<Rigidbody>().MoveRotation(rotation);
			rootRelativeToPelvis = Quaternion.Inverse(pelvisTarget.rotation) * base.transform.rotation;
			pelvisToRoot = Quaternion.Inverse(ik.references.pelvis.rotation) * (base.transform.position - ik.references.pelvis.position);
			rootTargetPosition = base.transform.position;
			rootTargetRotation = base.transform.rotation;
			lastWeight = weight;
		}

		private void LateUpdate()
		{
			if (weight > 0f)
			{
				ik.solver.leftHandEffector.positionWeight = weight;
				ik.solver.leftHandEffector.rotationWeight = weight;
			}
			else
			{
				rootTargetPosition = base.transform.position;
				rootTargetRotation = base.transform.rotation;
				if (lastWeight > 0f)
				{
					ik.solver.leftHandEffector.positionWeight = 0f;
					ik.solver.leftHandEffector.rotationWeight = 0f;
				}
			}
			lastWeight = weight;
			if (!(weight <= 0f))
			{
				base.transform.position = Vector3.Lerp(rootTargetPosition, pelvisTarget.position + pelvisTarget.rotation * pelvisToRoot * hangingDistanceMlp, weight);
				base.transform.rotation = Quaternion.Lerp(rootTargetRotation, pelvisTarget.rotation * rootRelativeToPelvis, weight);
				ik.solver.leftHandEffector.position = leftHandTarget.position;
				ik.solver.leftHandEffector.rotation = leftHandTarget.rotation;
				Vector3 fromDirection = ik.references.pelvis.rotation * pelvisDownAxis;
				Quaternion b = Quaternion.FromToRotation(fromDirection, rightHandTarget.position - headTarget.position);
				ik.references.rightUpperArm.rotation = Quaternion.Lerp(Quaternion.identity, b, weight) * ik.references.rightUpperArm.rotation;
				Quaternion b2 = Quaternion.FromToRotation(fromDirection, leftFootTarget.position - bodyTarget.position);
				ik.references.leftThigh.rotation = Quaternion.Lerp(Quaternion.identity, b2, weight) * ik.references.leftThigh.rotation;
				Quaternion b3 = Quaternion.FromToRotation(fromDirection, rightFootTarget.position - bodyTarget.position);
				ik.references.rightThigh.rotation = Quaternion.Lerp(Quaternion.identity, b3, weight) * ik.references.rightThigh.rotation;
			}
		}
	}
	public abstract class PickUp2Handed : MonoBehaviour
	{
		[SerializeField]
		private int GUIspace;

		public InteractionSystem interactionSystem;

		public InteractionObject obj;

		public Transform pivot;

		public Transform holdPoint;

		public float pickUpTime = 0.3f;

		private float holdWeight;

		private float holdWeightVel;

		private Vector3 pickUpPosition;

		private Quaternion pickUpRotation;

		private bool holding => interactionSystem.IsPaused(FullBodyBipedEffector.LeftHand);

		private void OnGUI()
		{
			GUILayout.BeginHorizontal();
			GUILayout.Space(GUIspace);
			if (!holding)
			{
				if (GUILayout.Button("Pick Up " + obj.name))
				{
					interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, obj, interrupt: false);
					interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, obj, interrupt: false);
				}
			}
			else if (GUILayout.Button("Drop " + obj.name))
			{
				interactionSystem.ResumeAll();
			}
			GUILayout.EndHorizontal();
		}

		protected abstract void RotatePivot();

		private void Start()
		{
			InteractionSystem obj = interactionSystem;
			obj.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnStart));
			InteractionSystem obj2 = interactionSystem;
			obj2.OnInteractionPause = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj2.OnInteractionPause, new InteractionSystem.InteractionDelegate(OnPause));
			InteractionSystem obj3 = interactionSystem;
			obj3.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj3.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnDrop));
		}

		private void OnPause(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				obj.transform.parent = interactionSystem.transform;
				Rigidbody component = obj.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.isKinematic = true;
				}
				pickUpPosition = obj.transform.position;
				pickUpRotation = obj.transform.rotation;
				holdWeight = 0f;
				holdWeightVel = 0f;
			}
		}

		private void OnStart(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				RotatePivot();
				holdPoint.rotation = obj.transform.rotation;
			}
		}

		private void OnDrop(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				obj.transform.parent = null;
				if (obj.GetComponent<Rigidbody>() != null)
				{
					obj.GetComponent<Rigidbody>().isKinematic = false;
				}
			}
		}

		private void LateUpdate()
		{
			if (holding)
			{
				holdWeight = Mathf.SmoothDamp(holdWeight, 1f, ref holdWeightVel, pickUpTime);
				obj.transform.position = Vector3.Lerp(pickUpPosition, holdPoint.position, holdWeight);
				obj.transform.rotation = Quaternion.Lerp(pickUpRotation, holdPoint.rotation, holdWeight);
			}
		}

		private void OnDestroy()
		{
			if (!(interactionSystem == null))
			{
				InteractionSystem obj = interactionSystem;
				obj.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnStart));
				InteractionSystem obj2 = interactionSystem;
				obj2.OnInteractionPause = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj2.OnInteractionPause, new InteractionSystem.InteractionDelegate(OnPause));
				InteractionSystem obj3 = interactionSystem;
				obj3.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj3.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnDrop));
			}
		}
	}
	public class PickUpBox : PickUp2Handed
	{
		protected override void RotatePivot()
		{
			Vector3 normalized = (pivot.position - interactionSystem.transform.position).normalized;
			normalized.y = 0f;
			Vector3 v = obj.transform.InverseTransformDirection(normalized);
			Vector3 axis = QuaTools.GetAxis(v);
			Vector3 axis2 = QuaTools.GetAxis(obj.transform.InverseTransformDirection(interactionSystem.transform.up));
			pivot.localRotation = Quaternion.LookRotation(axis, axis2);
		}
	}
	public class PickUpSphere : PickUp2Handed
	{
		protected override void RotatePivot()
		{
			Vector3 vector = Vector3.Lerp(interactionSystem.ik.solver.leftHandEffector.bone.position, interactionSystem.ik.solver.rightHandEffector.bone.position, 0.5f);
			Vector3 forward = obj.transform.position - vector;
			pivot.rotation = Quaternion.LookRotation(forward);
		}
	}
	public class RagdollUtilityDemo : MonoBehaviour
	{
		public RagdollUtility ragdollUtility;

		public Transform root;

		public Rigidbody pelvis;

		private void OnGUI()
		{
			GUILayout.Label(" Press R to switch to ragdoll. \n Weigh in one of the FBBIK effectors to make kinematic changes to the ragdoll pose.\n A to blend back to animation");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.R))
			{
				ragdollUtility.EnableRagdoll();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				Vector3 vector = pelvis.position - root.position;
				root.position += vector;
				pelvis.transform.position -= vector;
				ragdollUtility.DisableRagdoll();
			}
		}
	}
	[RequireComponent(typeof(Recoil))]
	public class RecoilTest : MonoBehaviour
	{
		public float magnitude = 1f;

		private Recoil recoil;

		private void Start()
		{
			recoil = GetComponent<Recoil>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.R) || Input.GetMouseButtonDown(0))
			{
				recoil.Fire(magnitude);
			}
		}

		private void OnGUI()
		{
			GUILayout.Label("Press R or LMB for procedural recoil.");
		}
	}
	public class ResetInteractionObject : MonoBehaviour
	{
		public float resetDelay = 1f;

		private Vector3 defaultPosition;

		private Quaternion defaultRotation;

		private Transform defaultParent;

		private Rigidbody r;

		private void Start()
		{
			defaultPosition = base.transform.position;
			defaultRotation = base.transform.rotation;
			defaultParent = base.transform.parent;
			r = GetComponent<Rigidbody>();
		}

		private void OnPickUp(Transform t)
		{
			StopAllCoroutines();
			StartCoroutine(ResetObject(Time.time + resetDelay));
		}

		private IEnumerator ResetObject(float resetTime)
		{
			while (Time.time < resetTime)
			{
				yield return null;
			}
			Poser poser = base.transform.parent.GetComponent<Poser>();
			if (poser != null)
			{
				poser.poseRoot = null;
				poser.weight = 0f;
			}
			base.transform.parent = defaultParent;
			base.transform.position = defaultPosition;
			base.transform.rotation = defaultRotation;
			if (r != null)
			{
				r.isKinematic = false;
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class SoccerDemo : MonoBehaviour
	{
		private Animator animator;

		private Vector3 defaultPosition;

		private Quaternion defaultRotation;

		private void Start()
		{
			animator = GetComponent<Animator>();
			defaultPosition = base.transform.position;
			defaultRotation = base.transform.rotation;
			StartCoroutine(ResetDelayed());
		}

		private IEnumerator ResetDelayed()
		{
			while (true)
			{
				yield return new WaitForSeconds(3f);
				base.transform.position = defaultPosition;
				base.transform.rotation = defaultRotation;
				animator.CrossFade("SoccerKick", 0f, 0, 0f);
				yield return null;
			}
		}
	}
	public class TouchWalls : MonoBehaviour
	{
		[Serializable]
		public class EffectorLink
		{
			public bool enabled = true;

			public FullBodyBipedEffector effectorType;

			public InteractionObject interactionObject;

			public Transform spherecastFrom;

			public float spherecastRadius = 0.1f;

			public float minDistance = 0.3f;

			public LayerMask touchLayers;

			public float lerpSpeed = 10f;

			public float minSwitchTime = 0.2f;

			public float releaseDistance = 0.4f;

			public bool sliding;

			private Vector3 raycastDirectionLocal;

			private float raycastDistance;

			private bool inTouch;

			private RaycastHit hit = default(RaycastHit);

			private Vector3 targetPosition;

			private Quaternion targetRotation;

			private bool initiated;

			private float nextSwitchTime;

			private float speedF;

			public void Initiate(InteractionSystem interactionSystem)
			{
				raycastDirectionLocal = spherecastFrom.InverseTransformDirection(interactionObject.transform.position - spherecastFrom.position);
				raycastDistance = Vector3.Distance(spherecastFrom.position, interactionObject.transform.position);
				interactionSystem.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnInteractionStart));
				interactionSystem.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnInteractionResume));
				interactionSystem.OnInteractionStop = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionStop, new InteractionSystem.InteractionDelegate(OnInteractionStop));
				hit.normal = Vector3.forward;
				targetPosition = interactionObject.transform.position;
				targetRotation = interactionObject.transform.rotation;
				initiated = true;
			}

			private bool FindWalls(Vector3 direction)
			{
				if (!enabled)
				{
					return false;
				}
				bool result = Physics.SphereCast(spherecastFrom.position, spherecastRadius, direction, out hit, raycastDistance, touchLayers);
				if (hit.distance < minDistance)
				{
					result = false;
				}
				return result;
			}

			public void Update(InteractionSystem interactionSystem)
			{
				if (!initiated)
				{
					return;
				}
				Vector3 vector = spherecastFrom.TransformDirection(raycastDirectionLocal);
				hit.point = spherecastFrom.position + vector;
				bool flag = FindWalls(vector);
				if (!inTouch)
				{
					if (flag && Time.time > nextSwitchTime)
					{
						interactionObject.transform.parent = null;
						interactionSystem.StartInteraction(effectorType, interactionObject, interrupt: true);
						nextSwitchTime = Time.time + minSwitchTime / interactionSystem.speed;
						targetPosition = hit.point;
						targetRotation = Quaternion.LookRotation(-hit.normal);
						interactionObject.transform.position = targetPosition;
						interactionObject.transform.rotation = targetRotation;
					}
				}
				else
				{
					if (!flag)
					{
						StopTouch(interactionSystem);
					}
					else if (!interactionSystem.IsPaused(effectorType) || sliding)
					{
						targetPosition = hit.point;
						targetRotation = Quaternion.LookRotation(-hit.normal);
					}
					if (Vector3.Distance(interactionObject.transform.position, hit.point) > releaseDistance)
					{
						if (flag)
						{
							targetPosition = hit.point;
							targetRotation = Quaternion.LookRotation(-hit.normal);
						}
						else
						{
							StopTouch(interactionSystem);
						}
					}
				}
				float b = ((inTouch && (!interactionSystem.IsPaused(effectorType) || !(interactionObject.transform.position == targetPosition))) ? 1f : 0f);
				speedF = Mathf.Lerp(speedF, b, Time.deltaTime * 3f * interactionSystem.speed);
				float t = Time.deltaTime * lerpSpeed * speedF * interactionSystem.speed;
				interactionObject.transform.position = Vector3.Lerp(interactionObject.transform.position, targetPosition, t);
				interactionObject.transform.rotation = Quaternion.Slerp(interactionObject.transform.rotation, targetRotation, t);
			}

			private void StopTouch(InteractionSystem interactionSystem)
			{
				interactionObject.transform.parent = interactionSystem.transform;
				nextSwitchTime = Time.time + minSwitchTime / interactionSystem.speed;
				if (interactionSystem.IsPaused(effectorType))
				{
					interactionSystem.ResumeInteraction(effectorType);
					return;
				}
				speedF = 0f;
				targetPosition = hit.point;
				targetRotation = Quaternion.LookRotation(-hit.normal);
			}

			private void OnInteractionStart(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = true;
				}
			}

			private void OnInteractionResume(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = false;
				}
			}

			private void OnInteractionStop(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = false;
				}
			}

			public void Destroy(InteractionSystem interactionSystem)
			{
				if (initiated)
				{
					interactionSystem.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnInteractionStart));
					interactionSystem.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnInteractionResume));
					interactionSystem.OnInteractionStop = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionStop, new InteractionSystem.InteractionDelegate(OnInteractionStop));
				}
			}
		}

		public InteractionSystem interactionSystem;

		public EffectorLink[] effectorLinks;

		private void Start()
		{
			EffectorLink[] array = effectorLinks;
			foreach (EffectorLink effectorLink in array)
			{
				effectorLink.Initiate(interactionSystem);
			}
		}

		private void FixedUpdate()
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Update(interactionSystem);
			}
		}

		private void OnDestroy()
		{
			if (interactionSystem != null)
			{
				for (int i = 0; i < effectorLinks.Length; i++)
				{
					effectorLinks[i].Destroy(interactionSystem);
				}
			}
		}
	}
	public class TransferMotion : MonoBehaviour
	{
		[Tooltip("The Transform to transfer motion to.")]
		public Transform to;

		[Tooltip("The amount of motion to transfer.")]
		[Range(0f, 1f)]
		public float transferMotion = 0.9f;

		private Vector3 lastPosition;

		private void OnEnable()
		{
			lastPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 vector = base.transform.position - lastPosition;
			to.position += vector * transferMotion;
			lastPosition = base.transform.position;
		}
	}
	public class TwoHandedProp : MonoBehaviour
	{
		[Tooltip("The left hand target parented to the right hand.")]
		public Transform leftHandTarget;

		private FullBodyBipedIK ik;

		private Vector3 targetPosRelativeToRight;

		private Quaternion targetRotRelativeToRight;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
			ik.solver.leftHandEffector.positionWeight = 1f;
			ik.solver.rightHandEffector.positionWeight = 1f;
			if (ik.solver.rightHandEffector.target == null)
			{
				Debug.LogError("Right Hand Effector needs a Target in this demo.");
			}
		}

		private void LateUpdate()
		{
			targetPosRelativeToRight = ik.references.rightHand.InverseTransformPoint(leftHandTarget.position);
			targetRotRelativeToRight = Quaternion.Inverse(ik.references.rightHand.rotation) * leftHandTarget.rotation;
			ik.solver.leftHandEffector.position = ik.solver.rightHandEffector.target.position + ik.solver.rightHandEffector.target.rotation * targetPosRelativeToRight;
			ik.solver.leftHandEffector.rotation = ik.solver.rightHandEffector.target.rotation * targetRotRelativeToRight;
		}

		private void AfterFBBIK()
		{
			ik.solver.leftHandEffector.bone.rotation = ik.solver.leftHandEffector.rotation;
			ik.solver.rightHandEffector.bone.rotation = ik.solver.rightHandEffector.rotation;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
			}
		}
	}
	public class UserControlInteractions : UserControlThirdPerson
	{
		[SerializeField]
		private CharacterThirdPerson character;

		[SerializeField]
		private InteractionSystem interactionSystem;

		[SerializeField]
		private bool disableInputInInteraction = true;

		public float enableInputAtProgress = 0.8f;

		protected override void Update()
		{
			if (disableInputInInteraction && interactionSystem != null && (interactionSystem.inInteraction || interactionSystem.IsPaused()))
			{
				float minActiveProgress = interactionSystem.GetMinActiveProgress();
				if (minActiveProgress > 0f && minActiveProgress < enableInputAtProgress)
				{
					state.move = Vector3.zero;
					state.jump = false;
					return;
				}
			}
			base.Update();
		}

		private void OnGUI()
		{
			if (!character.onGround)
			{
				return;
			}
			if (interactionSystem.IsPaused() && interactionSystem.IsInSync())
			{
				GUILayout.Label("Press E to resume interaction");
				if (Input.GetKey(KeyCode.E))
				{
					interactionSystem.ResumeAll();
				}
				return;
			}
			int closestTriggerIndex = interactionSystem.GetClosestTriggerIndex();
			if (closestTriggerIndex != -1 && interactionSystem.TriggerEffectorsReady(closestTriggerIndex))
			{
				GUILayout.Label("Press E to start interaction");
				if (Input.GetKey(KeyCode.E))
				{
					interactionSystem.TriggerInteraction(closestTriggerIndex, interrupt: false);
				}
			}
		}
	}
	public class GrounderDemo : MonoBehaviour
	{
		public GameObject[] characters;

		private void OnGUI()
		{
			if (GUILayout.Button("Biped"))
			{
				Activate(0);
			}
			if (GUILayout.Button("Quadruped"))
			{
				Activate(1);
			}
			if (GUILayout.Button("Mech"))
			{
				Activate(2);
			}
			if (GUILayout.Button("Bot"))
			{
				Activate(3);
			}
		}

		public void Activate(int index)
		{
			for (int i = 0; i < characters.Length; i++)
			{
				characters[i].SetActive(i == index);
			}
		}
	}
	public class PlatformRotator : MonoBehaviour
	{
		public float maxAngle = 70f;

		public float switchRotationTime = 0.5f;

		public float random = 0.5f;

		public float rotationSpeed = 50f;

		public Vector3 movePosition;

		public float moveSpeed = 5f;

		public int characterLayer;

		private Quaternion defaultRotation;

		private Quaternion targetRotation;

		private Vector3 targetPosition;

		private Vector3 velocity;

		private Rigidbody r;

		private void Start()
		{
			defaultRotation = base.transform.rotation;
			targetPosition = base.transform.position + movePosition;
			r = GetComponent<Rigidbody>();
			StartCoroutine(SwitchRotation());
		}

		private void FixedUpdate()
		{
			r.MovePosition(Vector3.SmoothDamp(r.position, targetPosition, ref velocity, 1f, moveSpeed));
			if (Vector3.Distance(GetComponent<Rigidbody>().position, targetPosition) < 0.1f)
			{
				movePosition = -movePosition;
				targetPosition += movePosition;
			}
			r.MoveRotation(Quaternion.RotateTowards(r.rotation, targetRotation, rotationSpeed * Time.deltaTime));
		}

		private IEnumerator SwitchRotation()
		{
			while (true)
			{
				float angle = Random.Range(0f - maxAngle, maxAngle);
				Vector3 axis = Random.onUnitSphere;
				targetRotation = Quaternion.AngleAxis(angle, axis) * defaultRotation;
				yield return new WaitForSeconds(switchRotationTime + Random.value * random);
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer == characterLayer)
			{
				CharacterThirdPerson component = collision.gameObject.GetComponent<CharacterThirdPerson>();
				if (!(component == null) && component.smoothPhysics)
				{
					component.smoothPhysics = false;
				}
			}
		}

		private void OnCollisionExit(Collision collision)
		{
			if (collision.gameObject.layer == characterLayer)
			{
				CharacterThirdPerson component = collision.gameObject.GetComponent<CharacterThirdPerson>();
				if (!(component == null))
				{
					component.smoothPhysics = true;
				}
			}
		}
	}
	public class BendGoal : MonoBehaviour
	{
		public LimbIK limbIK;

		[Range(0f, 1f)]
		public float weight = 1f;

		private void Start()
		{
			Debug.Log("BendGoal is deprecated, you can now a bend goal from the custom inspector of the LimbIK component.");
		}

		private void LateUpdate()
		{
			if (!(limbIK == null))
			{
				limbIK.solver.SetBendGoalPosition(base.transform.position, weight);
			}
		}
	}
	public class Turret : MonoBehaviour
	{
		[Serializable]
		public class Part
		{
			public Transform transform;

			private RotationLimit rotationLimit;

			public void AimAt(Transform target)
			{
				transform.LookAt(target.position, transform.up);
				if (rotationLimit == null)
				{
					rotationLimit = transform.GetComponent<RotationLimit>();
					rotationLimit.Disable();
				}
				rotationLimit.Apply();
			}
		}

		public Transform target;

		public Part[] parts;

		private void Update()
		{
			Part[] array = parts;
			foreach (Part part in array)
			{
				part.AimAt(target);
			}
		}
	}
	public class VRIKPlatform : MonoBehaviour
	{
		public VRIK ik;

		private Vector3 lastPosition;

		private Quaternion lastRotation = Quaternion.identity;

		private void Start()
		{
			lastPosition = base.transform.position;
			lastRotation = base.transform.rotation;
		}

		private void Update()
		{
			ik.solver.AddPlatformMotion(base.transform.position - lastPosition, base.transform.rotation * Quaternion.Inverse(lastRotation), base.transform.position);
			lastRotation = base.transform.rotation;
			lastPosition = base.transform.position;
		}
	}
}
namespace RootMotion.FinalIK
{
	[HelpURL("http://www.root-motion.com/finalikdox/html/page2.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Biped IK")]
	public class BipedIK : SolverManager
	{
		public BipedReferences references = new BipedReferences();

		public BipedIKSolvers solvers = new BipedIKSolvers();

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page2.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_biped_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public float GetIKPositionWeight(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKPositionWeight();
		}

		public float GetIKRotationWeight(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKRotationWeight();
		}

		public void SetIKPositionWeight(AvatarIKGoal goal, float weight)
		{
			GetGoalIK(goal).SetIKPositionWeight(weight);
		}

		public void SetIKRotationWeight(AvatarIKGoal goal, float weight)
		{
			GetGoalIK(goal).SetIKRotationWeight(weight);
		}

		public void SetIKPosition(AvatarIKGoal goal, Vector3 IKPosition)
		{
			GetGoalIK(goal).SetIKPosition(IKPosition);
		}

		public void SetIKRotation(AvatarIKGoal goal, Quaternion IKRotation)
		{
			GetGoalIK(goal).SetIKRotation(IKRotation);
		}

		public Vector3 GetIKPosition(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKPosition();
		}

		public Quaternion GetIKRotation(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKRotation();
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight, float clampWeight, float clampWeightHead, float clampWeightEyes)
		{
			solvers.lookAt.SetLookAtWeight(weight, bodyWeight, headWeight, eyesWeight, clampWeight, clampWeightHead, clampWeightEyes);
		}

		public void SetLookAtPosition(Vector3 lookAtPosition)
		{
			solvers.lookAt.SetIKPosition(lookAtPosition);
		}

		public void SetSpinePosition(Vector3 spinePosition)
		{
			solvers.spine.SetIKPosition(spinePosition);
		}

		public void SetSpineWeight(float weight)
		{
			solvers.spine.SetIKPositionWeight(weight);
		}

		public IKSolverLimb GetGoalIK(AvatarIKGoal goal)
		{
			return goal switch
			{
				AvatarIKGoal.LeftFoot => solvers.leftFoot, 
				AvatarIKGoal.RightFoot => solvers.rightFoot, 
				AvatarIKGoal.LeftHand => solvers.leftHand, 
				AvatarIKGoal.RightHand => solvers.rightHand, 
				_ => null, 
			};
		}

		public void InitiateBipedIK()
		{
			InitiateSolver();
		}

		public void UpdateBipedIK()
		{
			UpdateSolver();
		}

		public void SetToDefaults()
		{
			IKSolverLimb[] limbs = solvers.limbs;
			foreach (IKSolverLimb iKSolverLimb in limbs)
			{
				iKSolverLimb.SetIKPositionWeight(0f);
				iKSolverLimb.SetIKRotationWeight(0f);
				iKSolverLimb.bendModifier = IKSolverLimb.BendModifier.Animation;
				iKSolverLimb.bendModifierWeight = 1f;
			}
			solvers.leftHand.maintainRotationWeight = 0f;
			solvers.rightHand.maintainRotationWeight = 0f;
			solvers.spine.SetIKPositionWeight(0f);
			solvers.spine.tolerance = 0f;
			solvers.spine.maxIterations = 2;
			solvers.spine.useRotationLimits = false;
			solvers.aim.SetIKPositionWeight(0f);
			solvers.aim.tolerance = 0f;
			solvers.aim.maxIterations = 2;
			SetLookAtWeight(0f, 0.5f, 1f, 1f, 0.5f, 0.7f, 0.5f);
		}

		protected override void FixTransforms()
		{
			solvers.lookAt.FixTransforms();
			for (int i = 0; i < solvers.limbs.Length; i++)
			{
				solvers.limbs[i].FixTransforms();
			}
		}

		protected override void InitiateSolver()
		{
			string errorMessage = string.Empty;
			if (BipedReferences.SetupError(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root);
				return;
			}
			solvers.AssignReferences(references);
			if (solvers.spine.bones.Length > 1)
			{
				solvers.spine.Initiate(base.transform);
			}
			solvers.lookAt.Initiate(base.transform);
			solvers.aim.Initiate(base.transform);
			IKSolverLimb[] limbs = solvers.limbs;
			foreach (IKSolverLimb iKSolverLimb in limbs)
			{
				iKSolverLimb.Initiate(base.transform);
			}
			solvers.pelvis.Initiate(references.pelvis);
		}

		protected override void UpdateSolver()
		{
			for (int i = 0; i < solvers.limbs.Length; i++)
			{
				solvers.limbs[i].MaintainBend();
				solvers.limbs[i].MaintainRotation();
			}
			solvers.pelvis.Update();
			if (solvers.spine.bones.Length > 1)
			{
				solvers.spine.Update();
			}
			solvers.aim.Update();
			solvers.lookAt.Update();
			for (int j = 0; j < solvers.limbs.Length; j++)
			{
				solvers.limbs[j].Update();
			}
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}
	}
	[Serializable]
	public class BipedIKSolvers
	{
		public IKSolverLimb leftFoot = new IKSolverLimb(AvatarIKGoal.LeftFoot);

		public IKSolverLimb rightFoot = new IKSolverLimb(AvatarIKGoal.RightFoot);

		public IKSolverLimb leftHand = new IKSolverLimb(AvatarIKGoal.LeftHand);

		public IKSolverLimb rightHand = new IKSolverLimb(AvatarIKGoal.RightHand);

		public IKSolverFABRIK spine = new IKSolverFABRIK();

		public IKSolverLookAt lookAt = new IKSolverLookAt();

		public IKSolverAim aim = new IKSolverAim();

		public Constraints pelvis = new Constraints();

		private IKSolverLimb[] _limbs;

		private IKSolver[] _ikSolvers;

		public IKSolverLimb[] limbs
		{
			get
			{
				if (_limbs == null || (_limbs != null && _limbs.Length != 4))
				{
					_limbs = new IKSolverLimb[4] { leftFoot, rightFoot, leftHand, rightHand };
				}
				return _limbs;
			}
		}

		public IKSolver[] ikSolvers
		{
			get
			{
				if (_ikSolvers == null || (_ikSolvers != null && _ikSolvers.Length != 7))
				{
					_ikSolvers = new IKSolver[7] { leftFoot, rightFoot, leftHand, rightHand, spine, lookAt, aim };
				}
				return _ikSolvers;
			}
		}

		public void AssignReferences(BipedReferences references)
		{
			leftHand.SetChain(references.leftUpperArm, references.leftForearm, references.leftHand, references.root);
			rightHand.SetChain(references.rightUpperArm, references.rightForearm, references.rightHand, references.root);
			leftFoot.SetChain(references.leftThigh, references.leftCalf, references.leftFoot, references.root);
			rightFoot.SetChain(references.rightThigh, references.rightCalf, references.rightFoot, references.root);
			spine.SetChain(references.spine, references.root);
			lookAt.SetChain(references.spine, references.head, references.eyes, references.root);
			aim.SetChain(references.spine, references.root);
			leftFoot.goal = AvatarIKGoal.LeftFoot;
			rightFoot.goal = AvatarIKGoal.RightFoot;
			leftHand.goal = AvatarIKGoal.LeftHand;
			rightHand.goal = AvatarIKGoal.RightHand;
		}
	}
	[Serializable]
	public abstract class Constraint
	{
		public Transform transform;

		public float weight;

		public bool isValid => transform != null;

		public abstract void UpdateConstraint();
	}
	[Serializable]
	public class ConstraintPosition : Constraint
	{
		public Vector3 position;

		public ConstraintPosition()
		{
		}

		public ConstraintPosition(Transform transform)
		{
			base.transform = transform;
		}

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				transform.position = Vector3.Lerp(transform.position, position, weight);
			}
		}
	}
	[Serializable]
	public class ConstraintPositionOffset : Constraint
	{
		public Vector3 offset;

		private Vector3 defaultLocalPosition;

		private Vector3 lastLocalPosition;

		private bool initiated;

		private bool positionChanged => transform.localPosition != lastLocalPosition;

		public ConstraintPositionOffset()
		{
		}

		public ConstraintPositionOffset(Transform transform)
		{
			base.transform = transform;
		}

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				if (!initiated)
				{
					defaultLocalPosition = transform.localPosition;
					lastLocalPosition = transform.localPosition;
					initiated = true;
				}
				if (positionChanged)
				{
					defaultLocalPosition = transform.localPosition;
				}
				transform.localPosition = defaultLocalPosition;
				transform.position += offset * weight;
				lastLocalPosition = transform.localPosition;
			}
		}
	}
	[Serializable]
	public class ConstraintRotation : Constraint
	{
		public Quaternion rotation;

		public ConstraintRotation()
		{
		}

		public ConstraintRotation(Transform transform)
		{
			base.transform = transform;
		}

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				transform.rotation = Quaternion.Slerp(transform.rotation, rotation, weight);
			}
		}
	}
	[Serializable]
	public class ConstraintRotationOffset : Constraint
	{
		public Quaternion offset;

		private Quaternion defaultRotation;

		private Quaternion defaultLocalRotation;

		private Quaternion lastLocalRotation;

		private Quaternion defaultTargetLocalRotation;

		private bool initiated;

		private bool rotationChanged => transform.localRotation != lastLocalRotation;

		public ConstraintRotationOffset()
		{
		}

		public ConstraintRotationOffset(Transform transform)
		{
			base.transform = transform;
		}

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				if (!initiated)
				{
					defaultLocalRotation = transform.localRotation;
					lastLocalRotation = transform.localRotation;
					initiated = true;
				}
				if (rotationChanged)
				{
					defaultLocalRotation = transform.localRotation;
				}
				transform.localRotation = defaultLocalRotation;
				transform.rotation = Quaternion.Slerp(transform.rotation, offset, weight);
				lastLocalRotation = transform.localRotation;
			}
		}
	}
	[Serializable]
	public class Constraints
	{
		public Transform transform;

		public Transform target;

		public Vector3 positionOffset;

		public Vector3 position;

		[Range(0f, 1f)]
		public float positionWeight;

		public Vector3 rotationOffset;

		public Vector3 rotation;

		[Range(0f, 1f)]
		public float rotationWeight;

		public bool IsValid()
		{
			return transform != null;
		}

		public void Initiate(Transform transform)
		{
			this.transform = transform;
			position = transform.position;
			rotation = transform.eulerAngles;
		}

		public void Update()
		{
			if (IsValid())
			{
				if (target != null)
				{
					position = target.position;
				}
				transform.position += positionOffset;
				if (positionWeight > 0f)
				{
					transform.position = Vector3.Lerp(transform.position, position, positionWeight);
				}
				if (target != null)
				{
					rotation = target.eulerAngles;
				}
				transform.rotation = Quaternion.Euler(rotationOffset) * transform.rotation;
				if (rotationWeight > 0f)
				{
					transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(rotation), rotationWeight);
				}
			}
		}
	}
	[Serializable]
	public class Finger
	{
		[Tooltip("Master Weight for the finger.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("The first bone of the finger.")]
		public Transform bone1;

		[Tooltip("The second bone of the finger.")]
		public Transform bone2;

		[Tooltip("The (optional) third bone of the finger. This can be ignored for thumbs.")]
		public Transform bone3;

		[Tooltip("The fingertip object. If your character doesn't have tip bones, you can create an empty GameObject and parent it to the last bone in the finger. Place it to the tip of the finger.")]
		public Transform tip;

		[Tooltip("The IK target (optional, can use IKPosition and IKRotation directly).")]
		public Transform target;

		private IKSolverLimb solver;

		private Quaternion bone3RelativeToTarget;

		private Vector3 bone3DefaultLocalPosition;

		private Quaternion bone3DefaultLocalRotation;

		public bool initiated { get; private set; }

		public Vector3 IKPosition
		{
			get
			{
				return solver.IKPosition;
			}
			set
			{
				solver.IKPosition = value;
			}
		}

		public Quaternion IKRotation
		{
			get
			{
				return solver.IKRotation;
			}
			set
			{
				solver.IKRotation = value;
			}
		}

		public bool IsValid(ref string errorMessage)
		{
			if (bone1 == null || bone2 == null || tip == null)
			{
				errorMessage = "One of the bones in the Finger Rig is null, can not initiate solvers.";
				return false;
			}
			return true;
		}

		public void Initiate(Transform hand, int index)
		{
			initiated = false;
			string errorMessage = string.Empty;
			if (!IsValid(ref errorMessage))
			{
				Warning.Log(errorMessage, hand);
				return;
			}
			solver = new IKSolverLimb();
			solver.IKPositionWeight = weight;
			solver.bendModifier = IKSolverLimb.BendModifier.Target;
			solver.bendModifierWeight = 1f;
			IKPosition = tip.position;
			IKRotation = tip.rotation;
			if (bone3 != null)
			{
				bone3RelativeToTarget = Quaternion.Inverse(IKRotation) * bone3.rotation;
				bone3DefaultLocalPosition = bone3.localPosition;
				bone3DefaultLocalRotation = bone3.localRotation;
			}
			solver.SetChain(bone1, bone2, tip, hand);
			solver.Initiate(hand);
			initiated = true;
		}

		public void FixTransforms()
		{
			if (initiated)
			{
				solver.FixTransforms();
				if (bone3 != null)
				{
					bone3.localPosition = bone3DefaultLocalPosition;
					bone3.localRotation = bone3DefaultLocalRotation;
				}
			}
		}

		public void Update(float masterWeight)
		{
			if (!initiated)
			{
				return;
			}
			float num = weight * masterWeight;
			if (num <= 0f)
			{
				return;
			}
			solver.target = target;
			if (target != null)
			{
				IKPosition = target.position;
				IKRotation = target.rotation;
			}
			if (bone3 != null)
			{
				if (num >= 1f)
				{
					bone3.rotation = IKRotation * bone3RelativeToTarget;
				}
				else
				{
					bone3.rotation = Quaternion.Lerp(bone3.rotation, IKRotation * bone3RelativeToTarget, num);
				}
			}
			solver.IKPositionWeight = num;
			solver.Update();
		}
	}
	public class FingerRig : SolverManager
	{
		[Tooltip("The master weight for all fingers.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		public Finger[] fingers = new Finger[0];

		public bool initiated { get; private set; }

		public bool IsValid(ref string errorMessage)
		{
			Finger[] array = fingers;
			foreach (Finger finger in array)
			{
				if (!finger.IsValid(ref errorMessage))
				{
					return false;
				}
			}
			return true;
		}

		[ContextMenu("Auto-detect")]
		public void AutoDetect()
		{
			fingers = new Finger[0];
			for (int i = 0; i < base.transform.childCount; i++)
			{
				Transform[] array = new Transform[0];
				AddChildrenRecursive(base.transform.GetChild(i), ref array);
				if (array.Length == 3 || array.Length == 4)
				{
					Finger finger = new Finger();
					finger.bone1 = array[0];
					finger.bone2 = array[1];
					if (array.Length == 3)
					{
						finger.tip = array[2];
					}
					else
					{
						finger.bone3 = array[2];
						finger.tip = array[3];
					}
					finger.weight = 1f;
					Array.Resize(ref fingers, fingers.Length + 1);
					fingers[fingers.Length - 1] = finger;
				}
			}
		}

		public void AddFinger(Transform bone1, Transform bone2, Transform bone3, Transform tip, Transform target = null)
		{
			Finger finger = new Finger();
			finger.bone1 = bone1;
			finger.bone2 = bone2;
			finger.bone3 = bone3;
			finger.tip = tip;
			finger.target = target;
			Array.Resize(ref fingers, fingers.Length + 1);
			fingers[fingers.Length - 1] = finger;
			initiated = false;
			finger.Initiate(base.transform, fingers.Length - 1);
			if (fingers[fingers.Length - 1].initiated)
			{
				initiated = true;
			}
		}

		public void RemoveFinger(int index)
		{
			if ((float)index < 0f || index >= fingers.Length)
			{
				Warning.Log("RemoveFinger index out of bounds.", base.transform);
				return;
			}
			if (fingers.Length == 1)
			{
				fingers = new Finger[0];
				return;
			}
			Finger[] array = new Finger[fingers.Length - 1];
			int num = 0;
			for (int i = 0; i < fingers.Length; i++)
			{
				if (i != index)
				{
					array[num] = fingers[i];
					num++;
				}
			}
			fingers = array;
		}

		private void AddChildrenRecursive(Transform parent, ref Transform[] array)
		{
			Array.Resize(ref array, array.Length + 1);
			array[array.Length - 1] = parent;
			if (parent.childCount == 1)
			{
				AddChildrenRecursive(parent.GetChild(0), ref array);
			}
		}

		protected override void InitiateSolver()
		{
			initiated = true;
			for (int i = 0; i < fingers.Length; i++)
			{
				fingers[i].Initiate(base.transform, i);
				if (!fingers[i].initiated)
				{
					initiated = false;
				}
			}
		}

		public void UpdateFingerSolvers()
		{
			if (!(weight <= 0f))
			{
				Finger[] array = fingers;
				foreach (Finger finger in array)
				{
					finger.Update(weight);
				}
			}
		}

		public void FixFingerTransforms()
		{
			Finger[] array = fingers;
			foreach (Finger finger in array)
			{
				finger.FixTransforms();
			}
		}

		protected override void UpdateSolver()
		{
			UpdateFingerSolvers();
		}

		protected override void FixTransforms()
		{
			FixFingerTransforms();
		}
	}
	public abstract class Grounder : MonoBehaviour
	{
		public delegate void GrounderDelegate();

		[Tooltip("The master weight. Use this to fade in/out the grounding effect.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("The Grounding solver. Not to confuse with IK solvers.")]
		public Grounding solver = new Grounding();

		public GrounderDelegate OnPreGrounder;

		public GrounderDelegate OnPostGrounder;

		protected bool initiated;

		public abstract void ResetPosition();

		protected Vector3 GetSpineOffsetTarget()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < solver.legs.Length; i++)
			{
				zero += GetLegSpineBendVector(solver.legs[i]);
			}
			return zero;
		}

		protected void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}

		private Vector3 GetLegSpineBendVector(Grounding.Leg leg)
		{
			Vector3 legSpineTangent = GetLegSpineTangent(leg);
			float num = (Vector3.Dot(solver.root.forward, legSpineTangent.normalized) + 1f) * 0.5f;
			float magnitude = (leg.IKPosition - leg.transform.position).magnitude;
			return legSpineTangent * magnitude * num;
		}

		private Vector3 GetLegSpineTangent(Grounding.Leg leg)
		{
			Vector3 tangent = leg.transform.position - solver.root.position;
			if (!solver.rotateSolver || solver.root.up == Vector3.up)
			{
				return new Vector3(tangent.x, 0f, tangent.z);
			}
			Vector3 normal = solver.root.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}

		protected abstract void OpenUserManual();

		protected abstract void OpenScriptReference();
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Biped")]
	public class GrounderBipedIK : Grounder
	{
		[Tooltip("The BipedIK componet.")]
		public BipedIK ik;

		[Tooltip("The amount of spine bending towards upward slopes.")]
		public float spineBend = 7f;

		[Tooltip("The interpolation speed of spine bending.")]
		public float spineSpeed = 3f;

		private Transform[] feet = new Transform[2];

		private Quaternion[] footRotations = new Quaternion[2];

		private Vector3 animatedPelvisLocalPosition;

		private Vector3 solvedPelvisLocalPosition;

		private Vector3 spineOffset;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_biped_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			spineOffset = Vector3.zero;
		}

		private bool IsReadyToInitiate()
		{
			if (ik == null)
			{
				return false;
			}
			if (!ik.solvers.leftFoot.initiated)
			{
				return false;
			}
			if (!ik.solvers.rightFoot.initiated)
			{
				return false;
			}
			return true;
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f) && !initiated && IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void Initiate()
		{
			feet = new Transform[2];
			footRotations = new Quaternion[2];
			feet[0] = ik.references.leftFoot;
			feet[1] = ik.references.rightFoot;
			ref Quaternion reference = ref footRotations[0];
			reference = Quaternion.identity;
			ref Quaternion reference2 = ref footRotations[1];
			reference2 = Quaternion.identity;
			IKSolverFABRIK spine = ik.solvers.spine;
			spine.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(spine.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			IKSolverLimb rightFoot = ik.solvers.rightFoot;
			rightFoot.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(rightFoot.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			animatedPelvisLocalPosition = ik.references.pelvis.localPosition;
			solver.Initiate(ik.references.root, feet);
			initiated = true;
		}

		private void OnDisable()
		{
			if (initiated)
			{
				ik.solvers.leftFoot.IKPositionWeight = 0f;
				ik.solvers.rightFoot.IKPositionWeight = 0f;
			}
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			if (ik.references.pelvis.localPosition != solvedPelvisLocalPosition)
			{
				animatedPelvisLocalPosition = ik.references.pelvis.localPosition;
			}
			else
			{
				ik.references.pelvis.localPosition = animatedPelvisLocalPosition;
			}
			solver.Update();
			ik.references.pelvis.position += solver.pelvis.IKOffset * weight;
			SetLegIK(ik.solvers.leftFoot, 0);
			SetLegIK(ik.solvers.rightFoot, 1);
			if (spineBend != 0f && ik.references.spine.Length > 0)
			{
				spineSpeed = Mathf.Clamp(spineSpeed, 0f, spineSpeed);
				Vector3 vector = GetSpineOffsetTarget() * weight;
				spineOffset = Vector3.Lerp(spineOffset, vector * spineBend, Time.deltaTime * spineSpeed);
				Quaternion rotation = ik.references.leftUpperArm.rotation;
				Quaternion rotation2 = ik.references.rightUpperArm.rotation;
				Vector3 up = solver.up;
				Quaternion quaternion = Quaternion.FromToRotation(up, up + spineOffset);
				ik.references.spine[0].rotation = quaternion * ik.references.spine[0].rotation;
				ik.references.leftUpperArm.rotation = rotation;
				ik.references.rightUpperArm.rotation = rotation2;
			}
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void SetLegIK(IKSolverLimb limb, int index)
		{
			ref Quaternion reference = ref footRotations[index];
			reference = feet[index].rotation;
			limb.IKPosition = solver.legs[index].IKPosition;
			limb.IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (!(weight <= 0f) && base.enabled)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].rotation = Quaternion.Slerp(Quaternion.identity, solver.legs[i].rotationOffset, weight) * footRotations[i];
				}
				solvedPelvisLocalPosition = ik.references.pelvis.localPosition;
			}
		}

		private void OnDestroy()
		{
			if (initiated && ik != null)
			{
				IKSolverFABRIK spine = ik.solvers.spine;
				spine.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(spine.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolverLimb rightFoot = ik.solvers.rightFoot;
				rightFoot.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(rightFoot.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=9MiZiaJorws&index=6&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Full Body Biped")]
	public class GrounderFBBIK : Grounder
	{
		[Serializable]
		public class SpineEffector
		{
			[Tooltip("The type of the effector.")]
			public FullBodyBipedEffector effectorType;

			[Tooltip("The weight of horizontal bend offset towards the slope.")]
			public float horizontalWeight = 1f;

			[Tooltip("The vertical bend offset weight.")]
			public float verticalWeight;
		}

		[Tooltip("Reference to the FBBIK componet.")]
		public FullBodyBipedIK ik;

		[Tooltip("The amount of spine bending towards upward slopes.")]
		public float spineBend = 2f;

		[Tooltip("The interpolation speed of spine bending.")]
		public float spineSpeed = 3f;

		public SpineEffector[] spine = new SpineEffector[0];

		private Transform[] feet = new Transform[2];

		private Vector3 spineOffset;

		private bool firstSolve;

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=9MiZiaJorws&index=6&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_f_b_b_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			spineOffset = Vector3.zero;
		}

		private bool IsReadyToInitiate()
		{
			if (ik == null)
			{
				return false;
			}
			if (!ik.solver.initiated)
			{
				return false;
			}
			return true;
		}

		private void Update()
		{
			firstSolve = true;
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f) && !initiated && IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void FixedUpdate()
		{
			firstSolve = true;
		}

		private void LateUpdate()
		{
			firstSolve = true;
		}

		private void Initiate()
		{
			ik.solver.leftLegMapping.maintainRotationWeight = 1f;
			ik.solver.rightLegMapping.maintainRotationWeight = 1f;
			feet = new Transform[2];
			feet[0] = ik.solver.leftFootEffector.bone;
			feet[1] = ik.solver.rightFootEffector.bone;
			IKSolverFullBodyBiped iKSolverFullBodyBiped = ik.solver;
			iKSolverFullBodyBiped.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolverFullBodyBiped.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			solver.Initiate(ik.references.root, feet);
			initiated = true;
		}

		private void OnSolverUpdate()
		{
			if (!firstSolve)
			{
				return;
			}
			firstSolve = false;
			if (!base.enabled || weight <= 0f)
			{
				return;
			}
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			solver.Update();
			ik.references.pelvis.position += solver.pelvis.IKOffset * weight;
			SetLegIK(ik.solver.leftFootEffector, solver.legs[0]);
			SetLegIK(ik.solver.rightFootEffector, solver.legs[1]);
			if (spineBend != 0f)
			{
				spineSpeed = Mathf.Clamp(spineSpeed, 0f, spineSpeed);
				Vector3 vector = GetSpineOffsetTarget() * weight;
				spineOffset = Vector3.Lerp(spineOffset, vector * spineBend, Time.deltaTime * spineSpeed);
				Vector3 vector2 = ik.references.root.up * spineOffset.magnitude;
				for (int i = 0; i < spine.Length; i++)
				{
					ik.solver.GetEffector(spine[i].effectorType).positionOffset += spineOffset * spine[i].horizontalWeight + vector2 * spine[i].verticalWeight;
				}
			}
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void SetLegIK(IKEffector effector, Grounding.Leg leg)
		{
			effector.positionOffset += (leg.IKPosition - effector.bone.position) * weight;
			effector.bone.rotation = Quaternion.Slerp(Quaternion.identity, leg.rotationOffset, weight) * effector.bone.rotation;
		}

		private void OnDrawGizmosSelected()
		{
			if (ik == null)
			{
				ik = GetComponent<FullBodyBipedIK>();
			}
			if (ik == null)
			{
				ik = GetComponentInParent<FullBodyBipedIK>();
			}
			if (ik == null)
			{
				ik = GetComponentInChildren<FullBodyBipedIK>();
			}
		}

		private void OnDestroy()
		{
			if (initiated && ik != null)
			{
				IKSolverFullBodyBiped iKSolverFullBodyBiped = ik.solver;
				iKSolverFullBodyBiped.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolverFullBodyBiped.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			}
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder IK")]
	public class GrounderIK : Grounder
	{
		public IK[] legs;

		[Tooltip("The pelvis transform. Common ancestor of all the legs.")]
		public Transform pelvis;

		[Tooltip("The root Transform of the character, with the rigidbody and the collider.")]
		public Transform characterRoot;

		[Tooltip("The weight of rotating the character root to the ground normal (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float rootRotationWeight;

		[Tooltip("The speed of rotating the character root to the ground normal (range: 0 - inf).")]
		public float rootRotationSpeed = 5f;

		[Tooltip("The maximum angle of root rotation (range: 0 - 90).")]
		public float maxRootRotationAngle = 45f;

		private Transform[] feet = new Transform[0];

		private Quaternion[] footRotations = new Quaternion[0];

		private Vector3 animatedPelvisLocalPosition;

		private Vector3 solvedPelvisLocalPosition;

		private int solvedFeet;

		private bool solved;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
		}

		private bool IsReadyToInitiate()
		{
			if (pelvis == null)
			{
				return false;
			}
			if (legs.Length == 0)
			{
				return false;
			}
			IK[] array = legs;
			foreach (IK iK in array)
			{
				if (iK == null)
				{
					return false;
				}
				if (iK is FullBodyBipedIK)
				{
					LogWarning("GrounderIK does not support FullBodyBipedIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead. If you want to use FullBodyBipedIK, use the GrounderFBBIK component.");
					return false;
				}
				if (iK is FABRIKRoot)
				{
					LogWarning("GrounderIK does not support FABRIKRoot, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
				if (iK is AimIK)
				{
					LogWarning("GrounderIK does not support AimIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
			}
			return true;
		}

		private void OnDisable()
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < legs.Length; i++)
			{
				if (legs[i] != null)
				{
					legs[i].GetIKSolver().IKPositionWeight = 0f;
				}
			}
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (weight <= 0f)
			{
				return;
			}
			solved = false;
			if (initiated)
			{
				rootRotationWeight = Mathf.Clamp(rootRotationWeight, 0f, 1f);
				rootRotationSpeed = Mathf.Clamp(rootRotationSpeed, 0f, rootRotationSpeed);
				if (characterRoot != null && rootRotationSpeed > 0f && rootRotationWeight > 0f)
				{
					Vector3 vector = solver.GetLegsPlaneNormal();
					if (rootRotationWeight < 1f)
					{
						vector = Vector3.Slerp(Vector3.up, vector, rootRotationWeight);
					}
					Quaternion from = Quaternion.FromToRotation(base.transform.up, Vector3.up) * characterRoot.rotation;
					Quaternion b = Quaternion.RotateTowards(from, Quaternion.FromToRotation(base.transform.up, vector) * characterRoot.rotation, maxRootRotationAngle);
					characterRoot.rotation = Quaternion.Lerp(characterRoot.rotation, b, Time.deltaTime * rootRotationSpeed);
				}
			}
			else if (IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void Initiate()
		{
			feet = new Transform[legs.Length];
			footRotations = new Quaternion[legs.Length];
			for (int i = 0; i < feet.Length; i++)
			{
				ref Quaternion reference = ref footRotations[i];
				reference = Quaternion.identity;
			}
			for (int j = 0; j < legs.Length; j++)
			{
				IKSolver.Point[] points = legs[j].GetIKSolver().GetPoints();
				feet[j] = points[points.Length - 1].transform;
				IKSolver iKSolver = legs[j].GetIKSolver();
				iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolver iKSolver2 = legs[j].GetIKSolver();
				iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
			animatedPelvisLocalPosition = pelvis.localPosition;
			solver.Initiate(base.transform, feet);
			for (int k = 0; k < legs.Length; k++)
			{
				if (legs[k] is LegIK)
				{
					solver.legs[k].invertFootCenter = true;
				}
			}
			initiated = true;
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (!solved)
			{
				if (OnPreGrounder != null)
				{
					OnPreGrounder();
				}
				if (pelvis.localPosition != solvedPelvisLocalPosition)
				{
					animatedPelvisLocalPosition = pelvis.localPosition;
				}
				else
				{
					pelvis.localPosition = animatedPelvisLocalPosition;
				}
				solver.Update();
				for (int i = 0; i < legs.Length; i++)
				{
					SetLegIK(i);
				}
				pelvis.position += solver.pelvis.IKOffset * weight;
				solved = true;
				solvedFeet = 0;
				if (OnPostGrounder != null)
				{
					OnPostGrounder();
				}
			}
		}

		private void SetLegIK(int index)
		{
			ref Quaternion reference = ref footRotations[index];
			reference = feet[index].rotation;
			if (legs[index] is LegIK)
			{
				(legs[index].GetIKSolver() as IKSolverLeg).IKRotation = Quaternion.Slerp(Quaternion.identity, solver.legs[index].rotationOffset, weight) * footRotations[index];
				(legs[index].GetIKSolver() as IKSolverLeg).IKRotationWeight = 1f;
			}
			legs[index].GetIKSolver().IKPosition = solver.legs[index].IKPosition;
			legs[index].GetIKSolver().IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (weight <= 0f || !base.enabled)
			{
				return;
			}
			solvedFeet++;
			if (solvedFeet >= feet.Length)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].rotation = Quaternion.Slerp(Quaternion.identity, solver.legs[i].rotationOffset, weight) * footRotations[i];
				}
				solvedPelvisLocalPosition = pelvis.localPosition;
			}
		}

		private void OnDestroy()
		{
			if (!initiated)
			{
				return;
			}
			IK[] array = legs;
			foreach (IK iK in array)
			{
				if (iK != null)
				{
					IKSolver iKSolver = iK.GetIKSolver();
					iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
					IKSolver iKSolver2 = iK.GetIKSolver();
					iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
				}
			}
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Quadruped")]
	public class GrounderQuadruped : Grounder
	{
		public struct Foot
		{
			public IKSolver solver;

			public Transform transform;

			public Quaternion rotation;

			public Grounding.Leg leg;

			public Foot(IKSolver solver, Transform transform)
			{
				this.solver = solver;
				this.transform = transform;
				leg = null;
				rotation = transform.rotation;
			}
		}

		[Tooltip("The Grounding solver for the forelegs.")]
		public Grounding forelegSolver = new Grounding();

		[Tooltip("The weight of rotating the character root to the ground angle (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float rootRotationWeight = 0.5f;

		[Tooltip("The maximum angle of rotating the quadruped downwards (going downhill, range: -90 - 0).")]
		[Range(-90f, 0f)]
		public float minRootRotation = -25f;

		[Tooltip("The maximum angle of rotating the quadruped upwards (going uphill, range: 0 - 90).")]
		[Range(0f, 90f)]
		public float maxRootRotation = 45f;

		[Tooltip("The speed of interpolating the character root rotation (range: 0 - inf).")]
		public float rootRotationSpeed = 5f;

		[Tooltip("The maximum IK offset for the legs (range: 0 - inf).")]
		public float maxLegOffset = 0.5f;

		[Tooltip("The maximum IK offset for the forelegs (range: 0 - inf).")]
		public float maxForeLegOffset = 0.5f;

		[Tooltip("The weight of maintaining the head's rotation as it was before solving the Grounding (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float maintainHeadRotationWeight = 0.5f;

		[Tooltip("The root Transform of the character, with the rigidbody and the collider.")]
		public Transform characterRoot;

		[Tooltip("The pelvis transform. Common ancestor of both legs and the spine.")]
		public Transform pelvis;

		[Tooltip("The last bone in the spine that is the common parent for both forelegs.")]
		public Transform lastSpineBone;

		[Tooltip("The head (optional, if you intend to maintain it's rotation).")]
		public Transform head;

		public IK[] legs;

		public IK[] forelegs;

		[HideInInspector]
		public Vector3 gravity = Vector3.down;

		private Foot[] feet = new Foot[0];

		private Vector3 animatedPelvisLocalPosition;

		private Quaternion animatedPelvisLocalRotation;

		private Quaternion animatedHeadLocalRotation;

		private Vector3 solvedPelvisLocalPosition;

		private Quaternion solvedPelvisLocalRotation;

		private Quaternion solvedHeadLocalRotation;

		private int solvedFeet;

		private bool solved;

		private float angle;

		private Transform forefeetRoot;

		private Quaternion headRotation;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_quadruped.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			forelegSolver.Reset();
		}

		private bool IsReadyToInitiate()
		{
			if (pelvis == null)
			{
				return false;
			}
			if (lastSpineBone == null)
			{
				return false;
			}
			if (legs.Length == 0)
			{
				return false;
			}
			if (forelegs.Length == 0)
			{
				return false;
			}
			if (characterRoot == null)
			{
				return false;
			}
			if (!IsReadyToInitiateLegs(legs))
			{
				return false;
			}
			if (!IsReadyToInitiateLegs(forelegs))
			{
				return false;
			}
			return true;
		}

		private bool IsReadyToInitiateLegs(IK[] ikComponents)
		{
			foreach (IK iK in ikComponents)
			{
				if (iK == null)
				{
					return false;
				}
				if (iK is FullBodyBipedIK)
				{
					LogWarning("GrounderIK does not support FullBodyBipedIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead. If you want to use FullBodyBipedIK, use the GrounderFBBIK component.");
					return false;
				}
				if (iK is FABRIKRoot)
				{
					LogWarning("GrounderIK does not support FABRIKRoot, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
				if (iK is AimIK)
				{
					LogWarning("GrounderIK does not support AimIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
			}
			return true;
		}

		private void OnDisable()
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < feet.Length; i++)
			{
				if (feet[i].solver != null)
				{
					feet[i].solver.IKPositionWeight = 0f;
				}
			}
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f))
			{
				solved = false;
				if (!initiated && IsReadyToInitiate())
				{
					Initiate();
				}
			}
		}

		private void Initiate()
		{
			feet = new Foot[legs.Length + forelegs.Length];
			Transform[] array = InitiateFeet(legs, ref feet, 0);
			Transform[] array2 = InitiateFeet(forelegs, ref feet, legs.Length);
			animatedPelvisLocalPosition = pelvis.localPosition;
			animatedPelvisLocalRotation = pelvis.localRotation;
			if (head != null)
			{
				animatedHeadLocalRotation = head.localRotation;
			}
			forefeetRoot = new GameObject().transform;
			forefeetRoot.parent = base.transform;
			forefeetRoot.name = "Forefeet Root";
			solver.Initiate(base.transform, array);
			forelegSolver.Initiate(forefeetRoot, array2);
			for (int i = 0; i < array.Length; i++)
			{
				feet[i].leg = solver.legs[i];
			}
			for (int j = 0; j < array2.Length; j++)
			{
				feet[j + legs.Length].leg = forelegSolver.legs[j];
			}
			initiated = true;
		}

		private Transform[] InitiateFeet(IK[] ikComponents, ref Foot[] f, int indexOffset)
		{
			Transform[] array = new Transform[ikComponents.Length];
			for (int i = 0; i < ikComponents.Length; i++)
			{
				IKSolver.Point[] points = ikComponents[i].GetIKSolver().GetPoints();
				ref Foot reference = ref f[i + indexOffset];
				reference = new Foot(ikComponents[i].GetIKSolver(), points[points.Length - 1].transform);
				array[i] = f[i + indexOffset].transform;
				IKSolver iKSolver = f[i + indexOffset].solver;
				iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolver iKSolver2 = f[i + indexOffset].solver;
				iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
			return array;
		}

		private void LateUpdate()
		{
			if (!(weight <= 0f))
			{
				rootRotationWeight = Mathf.Clamp(rootRotationWeight, 0f, 1f);
				minRootRotation = Mathf.Clamp(minRootRotation, -90f, maxRootRotation);
				maxRootRotation = Mathf.Clamp(maxRootRotation, minRootRotation, 90f);
				rootRotationSpeed = Mathf.Clamp(rootRotationSpeed, 0f, rootRotationSpeed);
				maxLegOffset = Mathf.Clamp(maxLegOffset, 0f, maxLegOffset);
				maxForeLegOffset = Mathf.Clamp(maxForeLegOffset, 0f, maxForeLegOffset);
				maintainHeadRotationWeight = Mathf.Clamp(maintainHeadRotationWeight, 0f, 1f);
				RootRotation();
			}
		}

		private void RootRotation()
		{
			if (!(rootRotationWeight <= 0f) && !(rootRotationSpeed <= 0f))
			{
				solver.rotateSolver = true;
				forelegSolver.rotateSolver = true;
				Vector3 tangent = characterRoot.forward;
				Vector3 normal = -gravity;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				Quaternion quaternion = Quaternion.LookRotation(tangent, -gravity);
				Vector3 vector = forelegSolver.rootHit.point - solver.rootHit.point;
				Vector3 vector2 = Quaternion.Inverse(quaternion) * vector;
				float num = Mathf.Atan2(vector2.y, vector2.z) * 57.29578f;
				num = Mathf.Clamp(num * rootRotationWeight, minRootRotation, maxRootRotation);
				angle = Mathf.Lerp(angle, num, Time.deltaTime * rootRotationSpeed);
				characterRoot.rotation = Quaternion.Slerp(characterRoot.rotation, Quaternion.AngleAxis(0f - angle, characterRoot.right) * quaternion, weight);
			}
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (solved)
			{
				return;
			}
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			if (pelvis.localPosition != solvedPelvisLocalPosition)
			{
				animatedPelvisLocalPosition = pelvis.localPosition;
			}
			else
			{
				pelvis.localPosition = animatedPelvisLocalPosition;
			}
			if (pelvis.localRotation != solvedPelvisLocalRotation)
			{
				animatedPelvisLocalRotation = pelvis.localRotation;
			}
			else
			{
				pelvis.localRotation = animatedPelvisLocalRotation;
			}
			if (head != null)
			{
				if (head.localRotation != solvedHeadLocalRotation)
				{
					animatedHeadLocalRotation = head.localRotation;
				}
				else
				{
					head.localRotation = animatedHeadLocalRotation;
				}
			}
			for (int i = 0; i < feet.Length; i++)
			{
				feet[i].rotation = feet[i].transform.rotation;
			}
			if (head != null)
			{
				headRotation = head.rotation;
			}
			UpdateForefeetRoot();
			solver.Update();
			forelegSolver.Update();
			pelvis.position += solver.pelvis.IKOffset * weight;
			Vector3 fromDirection = lastSpineBone.position - pelvis.position;
			Vector3 vector = lastSpineBone.position + forelegSolver.root.up * Mathf.Clamp(forelegSolver.pelvis.heightOffset, float.NegativeInfinity, 0f) - solver.root.up * solver.pelvis.heightOffset;
			Vector3 toDirection = vector - pelvis.position;
			Quaternion b = Quaternion.FromToRotation(fromDirection, toDirection);
			pelvis.rotation = Quaternion.Slerp(Quaternion.identity, b, weight) * pelvis.rotation;
			for (int j = 0; j < feet.Length; j++)
			{
				SetFootIK(feet[j], (j >= 2) ? maxForeLegOffset : maxLegOffset);
			}
			solved = true;
			solvedFeet = 0;
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void UpdateForefeetRoot()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < forelegSolver.legs.Length; i++)
			{
				zero += forelegSolver.legs[i].transform.position;
			}
			zero /= (float)forelegs.Length;
			Vector3 vector = zero - base.transform.position;
			Vector3 normal = base.transform.up;
			Vector3 tangent = vector;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			forefeetRoot.position = base.transform.position + tangent.normalized * vector.magnitude;
		}

		private void SetFootIK(Foot foot, float maxOffset)
		{
			Vector3 vector = foot.leg.IKPosition - foot.transform.position;
			foot.solver.IKPosition = foot.transform.position + Vector3.ClampMagnitude(vector, maxOffset);
			foot.solver.IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (weight <= 0f || !base.enabled)
			{
				return;
			}
			solvedFeet++;
			if (solvedFeet >= feet.Length)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].transform.rotation = Quaternion.Slerp(Quaternion.identity, feet[i].leg.rotationOffset, weight) * feet[i].rotation;
				}
				if (head != null)
				{
					head.rotation = Quaternion.Lerp(head.rotation, headRotation, maintainHeadRotationWeight * weight);
				}
				solvedPelvisLocalPosition = pelvis.localPosition;
				solvedPelvisLocalRotation = pelvis.localRotation;
				if (head != null)
				{
					solvedHeadLocalRotation = head.localRotation;
				}
			}
		}

		private void OnDestroy()
		{
			if (initiated)
			{
				DestroyLegs(legs);
				DestroyLegs(forelegs);
			}
		}

		private void DestroyLegs(IK[] ikComponents)
		{
			foreach (IK iK in ikComponents)
			{
				if (iK != null)
				{
					IKSolver iKSolver = iK.GetIKSolver();
					iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
					IKSolver iKSolver2 = iK.GetIKSolver();
					iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
				}
			}
		}
	}
	[Serializable]
	public class Grounding
	{
		[Serializable]
		public enum Quality
		{
			Fastest,
			Simple,
			Best
		}

		public class Leg
		{
			public Quaternion rotationOffset = Quaternion.identity;

			public bool invertFootCenter;

			private Grounding grounding;

			private float lastTime;

			private float deltaTime;

			private Vector3 lastPosition;

			private Quaternion toHitNormal;

			private Quaternion r;

			private RaycastHit heelHit;

			private Vector3 up = Vector3.up;

			public bool isGrounded { get; private set; }

			public Vector3 IKPosition { get; private set; }

			public bool initiated { get; private set; }

			public float heightFromGround { get; private set; }

			public Vector3 velocity { get; private set; }

			public Transform transform { get; private set; }

			public float IKOffset { get; private set; }

			public float stepHeightFromGround => Mathf.Clamp(heightFromGround, 0f - grounding.maxStep, grounding.maxStep);

			private float rootYOffset => grounding.GetVerticalOffset(transform.position, grounding.root.position - up * grounding.heightOffset);

			public void Initiate(Grounding grounding, Transform transform)
			{
				initiated = false;
				this.grounding = grounding;
				this.transform = transform;
				up = Vector3.up;
				IKPosition = transform.position;
				rotationOffset = Quaternion.identity;
				initiated = true;
				OnEnable();
			}

			public void OnEnable()
			{
				if (initiated)
				{
					lastPosition = transform.position;
					lastTime = Time.deltaTime;
				}
			}

			public void Reset()
			{
				lastPosition = transform.position;
				lastTime = Time.deltaTime;
				IKOffset = 0f;
				IKPosition = transform.position;
				rotationOffset = Quaternion.identity;
			}

			public void Process()
			{
				if (!initiated || grounding.maxStep <= 0f)
				{
					return;
				}
				deltaTime = Time.time - lastTime;
				lastTime = Time.time;
				if (deltaTime == 0f)
				{
					return;
				}
				up = grounding.up;
				heightFromGround = float.PositiveInfinity;
				velocity = (transform.position - lastPosition) / deltaTime;
				velocity = grounding.Flatten(velocity);
				lastPosition = transform.position;
				Vector3 vector = velocity * grounding.prediction;
				if (grounding.footRadius <= 0f)
				{
					grounding.quality = Quality.Fastest;
				}
				switch (grounding.quality)
				{
				case Quality.Fastest:
				{
					RaycastHit raycastHit3 = GetRaycastHit(vector);
					SetFootToPoint(raycastHit3.normal, raycastHit3.point);
					break;
				}
				case Quality.Simple:
				{
					heelHit = GetRaycastHit(Vector3.zero);
					Vector3 vector2 = grounding.GetFootCenterOffset();
					if (invertFootCenter)
					{
						vector2 = -vector2;
					}
					RaycastHit raycastHit = GetRaycastHit(vector2 + vector);
					RaycastHit raycastHit2 = GetRaycastHit(grounding.root.right * grounding.footRadius * 0.5f);
					Vector3 vector3 = Vector3.Cross(raycastHit.point - heelHit.point, raycastHit2.point - heelHit.point).normalized;
					if (Vector3.Dot(vector3, up) < 0f)
					{
						vector3 = -vector3;
					}
					SetFootToPlane(vector3, heelHit.point, heelHit.point);
					break;
				}
				case Quality.Best:
				{
					heelHit = GetRaycastHit((!invertFootCenter) ? Vector3.zero : (-grounding.GetFootCenterOffset()));
					RaycastHit capsuleHit = GetCapsuleHit(vector);
					SetFootToPlane(capsuleHit.normal, capsuleHit.point, heelHit.point);
					break;
				}
				}
				isGrounded = heightFromGround < grounding.maxStep;
				float num = stepHeightFromGround;
				if (!grounding.rootGrounded)
				{
					num = 0f;
				}
				IKOffset = Interp.LerpValue(IKOffset, num, grounding.footSpeed, grounding.footSpeed);
				IKOffset = Mathf.Lerp(IKOffset, num, deltaTime * grounding.footSpeed);
				float verticalOffset = grounding.GetVerticalOffset(transform.position, grounding.root.position);
				float num2 = Mathf.Clamp(grounding.maxStep - verticalOffset, 0f, grounding.maxStep);
				IKOffset = Mathf.Clamp(IKOffset, 0f - num2, IKOffset);
				RotateFoot();
				IKPosition = transform.position - up * IKOffset;
				float footRotationWeight = grounding.footRotationWeight;
				rotationOffset = ((!(footRotationWeight >= 1f)) ? Quaternion.Slerp(Quaternion.identity, r, footRotationWeight) : r);
			}

			private RaycastHit GetCapsuleHit(Vector3 offsetFromHeel)
			{
				RaycastHit hitInfo = default(RaycastHit);
				Vector3 vector = grounding.GetFootCenterOffset();
				if (invertFootCenter)
				{
					vector = -vector;
				}
				Vector3 vector2 = transform.position + vector;
				hitInfo.point = vector2 - up * grounding.maxStep * 2f;
				hitInfo.normal = up;
				Vector3 vector3 = vector2 + grounding.maxStep * up;
				Vector3 point = vector3 + offsetFromHeel;
				if (Physics.CapsuleCast(vector3, point, grounding.footRadius, -up, out hitInfo, grounding.maxStep * 3f, grounding.layers) && float.IsNaN(hitInfo.point.x))
				{
					hitInfo.point = vector2 - up * grounding.maxStep * 2f;
					hitInfo.normal = up;
				}
				return hitInfo;
			}

			private RaycastHit GetRaycastHit(Vector3 offsetFromHeel)
			{
				RaycastHit hitInfo = default(RaycastHit);
				Vector3 vector = transform.position + offsetFromHeel;
				hitInfo.point = vector - up * grounding.maxStep * 2f;
				hitInfo.normal = up;
				if (grounding.maxStep <= 0f)
				{
					return hitInfo;
				}
				Physics.Raycast(vector + grounding.maxStep * up, -up, out hitInfo, grounding.maxStep * 3f, grounding.layers);
				return hitInfo;
			}

			private Vector3 RotateNormal(Vector3 normal)
			{
				if (grounding.quality == Quality.Best)
				{
					return normal;
				}
				return Vector3.RotateTowards(up, normal, grounding.maxFootRotationAngle * ((float)Math.PI / 180f), deltaTime);
			}

			private void SetFootToPoint(Vector3 normal, Vector3 point)
			{
				toHitNormal = Quaternion.FromToRotation(up, RotateNormal(normal));
				heightFromGround = GetHeightFromGround(point);
			}

			private void SetFootToPlane(Vector3 planeNormal, Vector3 planePoint, Vector3 heelHitPoint)
			{
				planeNormal = RotateNormal(planeNormal);
				toHitNormal = Quaternion.FromToRotation(up, planeNormal);
				Vector3 hitPoint = V3Tools.LineToPlane(transform.position + up * grounding.maxStep, -up, planeNormal, planePoint);
				heightFromGround = GetHeightFromGround(hitPoint);
				float max = GetHeightFromGround(heelHitPoint);
				heightFromGround = Mathf.Clamp(heightFromGround, float.NegativeInfinity, max);
			}

			private float GetHeightFromGround(Vector3 hitPoint)
			{
				return grounding.GetVerticalOffset(transform.position, hitPoint) - rootYOffset;
			}

			private void RotateFoot()
			{
				Quaternion rotationOffsetTarget = GetRotationOffsetTarget();
				r = Quaternion.Slerp(r, rotationOffsetTarget, deltaTime * grounding.footRotationSpeed);
			}

			private Quaternion GetRotationOffsetTarget()
			{
				if (grounding.maxFootRotationAngle <= 0f)
				{
					return Quaternion.identity;
				}
				if (grounding.maxFootRotationAngle >= 180f)
				{
					return toHitNormal;
				}
				return Quaternion.RotateTowards(Quaternion.identity, toHitNormal, grounding.maxFootRotationAngle);
			}
		}

		public class Pelvis
		{
			private Grounding grounding;

			private Vector3 lastRootPosition;

			private float damperF;

			private bool initiated;

			private float lastTime;

			public Vector3 IKOffset { get; private set; }

			public float heightOffset { get; private set; }

			public void Initiate(Grounding grounding)
			{
				this.grounding = grounding;
				initiated = true;
				OnEnable();
			}

			public void Reset()
			{
				lastRootPosition = grounding.root.transform.position;
				lastTime = Time.deltaTime;
				IKOffset = Vector3.zero;
				heightOffset = 0f;
			}

			public void OnEnable()
			{
				if (initiated)
				{
					lastRootPosition = grounding.root.transform.position;
					lastTime = Time.time;
				}
			}

			public void Process(float lowestOffset, float highestOffset, bool isGrounded)
			{
				if (!initiated)
				{
					return;
				}
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(num <= 0f))
				{
					float b = lowestOffset + highestOffset;
					if (!grounding.rootGrounded)
					{
						b = 0f;
					}
					heightOffset = Mathf.Lerp(heightOffset, b, num * grounding.pelvisSpeed);
					Vector3 p = grounding.root.position - lastRootPosition;
					lastRootPosition = grounding.root.position;
					damperF = Interp.LerpValue(damperF, (!isGrounded) ? 0f : 1f, 1f, 10f);
					heightOffset -= grounding.GetVerticalOffset(p, Vector3.zero) * grounding.pelvisDamper * damperF;
					IKOffset = grounding.up * heightOffset;
				}
			}
		}

		[Tooltip("Layers to ground the character to. Make sure to exclude the layer of the character controller.")]
		public LayerMask layers;

		[Tooltip("Max step height. Maximum vertical distance of Grounding from the root of the character.")]
		public float maxStep = 0.5f;

		[Tooltip("The height offset of the root.")]
		public float heightOffset;

		[Tooltip("The speed of moving the feet up/down.")]
		public float footSpeed = 2.5f;

		[Tooltip("CapsuleCast radius. Should match approximately with the size of the feet.")]
		public float footRadius = 0.15f;

		[Tooltip("Offset of the foot center along character forward axis.")]
		[HideInInspector]
		public float footCenterOffset;

		[Tooltip("Amount of velocity based prediction of the foot positions.")]
		public float prediction = 0.05f;

		[Tooltip("Weight of rotating the feet to the ground normal offset.")]
		[Range(0f, 1f)]
		public float footRotationWeight = 1f;

		[Tooltip("Speed of slerping the feet to their grounded rotations.")]
		public float footRotationSpeed = 7f;

		[Tooltip("Max Foot Rotation Angle. Max angular offset from the foot's rotation.")]
		[Range(0f, 90f)]
		public float maxFootRotationAngle = 45f;

		[Tooltip("If true, solver will rotate with the character root so the character can be grounded for example to spherical planets. For performance reasons leave this off unless needed.")]
		public bool rotateSolver;

		[Tooltip("The speed of moving the character up/down.")]
		public float pelvisSpeed = 5f;

		[Tooltip("Used for smoothing out vertical pelvis movement (range 0 - 1).")]
		[Range(0f, 1f)]
		public float pelvisDamper;

		[Tooltip("The weight of lowering the pelvis to the lowest foot.")]
		public float lowerPelvisWeight = 1f;

		[Tooltip("The weight of lifting the pelvis to the highest foot. This is useful when you don't want the feet to go too high relative to the body when crouching.")]
		public float liftPelvisWeight;

		[Tooltip("The radius of the spherecast from the root that determines whether the character root is grounded.")]
		public float rootSphereCastRadius = 0.1f;

		[Tooltip("The raycasting quality. Fastest is a single raycast per foot, Simple is three raycasts, Best is one raycast and a capsule cast per foot.")]
		public Quality quality = Quality.Best;

		private bool initiated;

		public Leg[] legs { get; private set; }

		public Pelvis pelvis { get; private set; }

		public bool isGrounded { get; private set; }

		public Transform root { get; private set; }

		public RaycastHit rootHit { get; private set; }

		public bool rootGrounded => rootHit.distance < maxStep * 2f;

		public Vector3 up => (!useRootRotation) ? Vector3.up : root.up;

		private bool useRootRotation
		{
			get
			{
				if (!rotateSolver)
				{
					return false;
				}
				if (root.up == Vector3.up)
				{
					return false;
				}
				return true;
			}
		}

		public RaycastHit GetRootHit(float maxDistanceMlp = 10f)
		{
			RaycastHit hitInfo = default(RaycastHit);
			Vector3 vector = up;
			Vector3 zero = Vector3.zero;
			Leg[] array = legs;
			foreach (Leg leg in array)
			{
				zero += leg.transform.position;
			}
			zero /= (float)legs.Length;
			hitInfo.point = zero - vector * maxStep * 10f;
			float num = maxDistanceMlp + 1f;
			hitInfo.distance = maxStep * num;
			if (maxStep <= 0f)
			{
				return hitInfo;
			}
			if (quality != Quality.Best)
			{
				Physics.Raycast(zero + vector * maxStep, -vector, out hitInfo, maxStep * num, layers);
			}
			else
			{
				Physics.SphereCast(zero + vector * maxStep, rootSphereCastRadius, -up, out hitInfo, maxStep * num, layers);
			}
			return hitInfo;
		}

		public bool IsValid(ref string errorMessage)
		{
			if (root == null)
			{
				errorMessage = "Root transform is null. Can't initiate Grounding.";
				return false;
			}
			if (legs == null)
			{
				errorMessage = "Grounding legs is null. Can't initiate Grounding.";
				return false;
			}
			if (pelvis == null)
			{
				errorMessage = "Grounding pelvis is null. Can't initiate Grounding.";
				return false;
			}
			if (legs.Length == 0)
			{
				errorMessage = "Grounding has 0 legs. Can't initiate Grounding.";
				return false;
			}
			return true;
		}

		public void Initiate(Transform root, Transform[] feet)
		{
			this.root = root;
			initiated = false;
			rootHit = default(RaycastHit);
			if (legs == null)
			{
				legs = new Leg[feet.Length];
			}
			if (legs.Length != feet.Length)
			{
				legs = new Leg[feet.Length];
			}
			for (int i = 0; i < feet.Length; i++)
			{
				if (legs[i] == null)
				{
					legs[i] = new Leg();
				}
			}
			if (pelvis == null)
			{
				pelvis = new Pelvis();
			}
			string errorMessage = string.Empty;
			if (!IsValid(ref errorMessage))
			{
				Warning.Log(errorMessage, root);
			}
			else if (Application.isPlaying)
			{
				for (int j = 0; j < feet.Length; j++)
				{
					legs[j].Initiate(this, feet[j]);
				}
				pelvis.Initiate(this);
				initiated = true;
			}
		}

		public void Update()
		{
			if (!initiated)
			{
				return;
			}
			if ((int)layers == 0)
			{
				LogWarning("Grounding layers are set to nothing. Please add a ground layer.");
			}
			maxStep = Mathf.Clamp(maxStep, 0f, maxStep);
			footRadius = Mathf.Clamp(footRadius, 0.0001f, maxStep);
			pelvisDamper = Mathf.Clamp(pelvisDamper, 0f, 1f);
			rootSphereCastRadius = Mathf.Clamp(rootSphereCastRadius, 0.0001f, rootSphereCastRadius);
			maxFootRotationAngle = Mathf.Clamp(maxFootRotationAngle, 0f, 90f);
			prediction = Mathf.Clamp(prediction, 0f, prediction);
			footSpeed = Mathf.Clamp(footSpeed, 0f, footSpeed);
			rootHit = GetRootHit();
			float num = float.NegativeInfinity;
			float num2 = float.PositiveInfinity;
			isGrounded = false;
			Leg[] array = legs;
			foreach (Leg leg in array)
			{
				leg.Process();
				if (leg.IKOffset > num)
				{
					num = leg.IKOffset;
				}
				if (leg.IKOffset < num2)
				{
					num2 = leg.IKOffset;
				}
				if (leg.isGrounded)
				{
					isGrounded = true;
				}
			}
			pelvis.Process((0f - num) * lowerPelvisWeight, (0f - num2) * liftPelvisWeight, isGrounded);
		}

		public Vector3 GetLegsPlaneNormal()
		{
			if (!initiated)
			{
				return Vector3.up;
			}
			Vector3 vector = up;
			Vector3 vector2 = vector;
			for (int i = 0; i < legs.Length; i++)
			{
				Vector3 vector3 = legs[i].IKPosition - root.position;
				Vector3 normal = vector;
				Vector3 tangent = vector3;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				Quaternion quaternion = Quaternion.FromToRotation(tangent, vector3);
				vector2 = quaternion * vector2;
			}
			return vector2;
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				pelvis.Reset();
				Leg[] array = legs;
				foreach (Leg leg in array)
				{
					leg.Reset();
				}
			}
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, root);
		}

		public float GetVerticalOffset(Vector3 p1, Vector3 p2)
		{
			if (useRootRotation)
			{
				return (Quaternion.Inverse(root.rotation) * (p1 - p2)).y;
			}
			return p1.y - p2.y;
		}

		public Vector3 Flatten(Vector3 v)
		{
			if (useRootRotation)
			{
				Vector3 tangent = v;
				Vector3 normal = root.up;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				return Vector3.Project(v, tangent);
			}
			v.y = 0f;
			return v;
		}

		public Vector3 GetFootCenterOffset()
		{
			return root.forward * footRadius + root.forward * footCenterOffset;
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=wT8fViZpLmQ&index=3&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Aim IK")]
	public class AimIK : IK
	{
		public IKSolverAim solver = new IKSolverAim();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page1.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_aim_i_k.html");
		}

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=wT8fViZpLmQ");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page3.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/CCD IK")]
	public class CCDIK : IK
	{
		public IKSolverCCD solver = new IKSolverCCD();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page3.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_c_c_d_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page4.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/FABRIK")]
	public class FABRIK : IK
	{
		public IKSolverFABRIK solver = new IKSolverFABRIK();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page4.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_f_a_b_r_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page5.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/FABRIK Root")]
	public class FABRIKRoot : IK
	{
		public IKSolverFABRIKRoot solver = new IKSolverFABRIKRoot();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page5.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_f_a_b_r_i_k_root.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=7__IafZGwvI&index=1&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Full Body Biped IK")]
	public class FullBodyBipedIK : IK
	{
		public BipedReferences references = new BipedReferences();

		public IKSolverFullBodyBiped solver = new IKSolverFullBodyBiped();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page6.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_full_body_biped_i_k.html");
		}

		[ContextMenu("TUTORIAL VIDEO (SETUP)")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=7__IafZGwvI");
		}

		[ContextMenu("TUTORIAL VIDEO (INSPECTOR)")]
		private void OpenInspectorTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=tgRMsTphjJo");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetReferences(BipedReferences references, Transform rootNode)
		{
			this.references = references;
			solver.SetToReferences(this.references, rootNode);
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}

		public bool ReferencesError(ref string errorMessage)
		{
			if (BipedReferences.SetupError(references, ref errorMessage))
			{
				return true;
			}
			if (references.spine.Length == 0)
			{
				errorMessage = "References has no spine bones assigned, can not initiate the solver.";
				return true;
			}
			if (solver.rootNode == null)
			{
				errorMessage = "Root Node bone is null, can not initiate the solver.";
				return true;
			}
			if (solver.rootNode != references.pelvis)
			{
				bool flag = false;
				for (int i = 0; i < references.spine.Length; i++)
				{
					if (solver.rootNode == references.spine[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					errorMessage = "The Root Node has to be one of the bones in the Spine or the Pelvis, can not initiate the solver.";
					return true;
				}
			}
			return false;
		}

		public bool ReferencesWarning(ref string warningMessage)
		{
			if (BipedReferences.SetupWarning(references, ref warningMessage))
			{
				return true;
			}
			Vector3 vector = references.rightUpperArm.position - references.leftUpperArm.position;
			Vector3 vector2 = solver.rootNode.position - references.leftUpperArm.position;
			float num = Vector3.Dot(vector.normalized, vector2.normalized);
			if (num > 0.95f)
			{
				warningMessage = "The root node, the left upper arm and the right upper arm bones should ideally form a triangle that is as close to equilateral as possible. Currently the root node bone seems to be very close to the line between the left upper arm and the right upper arm bones. This might cause unwanted behaviour like the spine turning upside down when pulled by a hand effector.Please set the root node bone to be one of the lower bones in the spine.";
				return true;
			}
			Vector3 vector3 = references.rightThigh.position - references.leftThigh.position;
			Vector3 vector4 = solver.rootNode.position - references.leftThigh.position;
			num = Vector3.Dot(vector3.normalized, vector4.normalized);
			if (num > 0.95f)
			{
				warningMessage = "The root node, the left thigh and the right thigh bones should ideally form a triangle that is as close to equilateral as possible. Currently the root node bone seems to be very close to the line between the left thigh and the right thigh bones. This might cause unwanted behaviour like the hip turning upside down when pulled by an effector.Please set the root node bone to be one of the higher bones in the spine.";
				return true;
			}
			return false;
		}

		[ContextMenu("Reinitiate")]
		private void Reinitiate()
		{
			SetReferences(references, solver.rootNode);
		}

		[ContextMenu("Auto-detect References")]
		private void AutoDetectReferences()
		{
			references = new BipedReferences();
			BipedReferences.AutoDetectReferences(ref references, base.transform, new BipedReferences.AutoDetectParams(legsParentInSpine: true, includeEyes: false));
			solver.rootNode = IKSolverFullBodyBiped.DetectRootNodeBone(references);
			solver.SetToReferences(references, solver.rootNode);
		}
	}
	public abstract class IK : SolverManager
	{
		public abstract IKSolver GetIKSolver();

		protected override void UpdateSolver()
		{
			if (!GetIKSolver().initiated)
			{
				InitiateSolver();
			}
			if (GetIKSolver().initiated)
			{
				GetIKSolver().Update();
			}
		}

		protected override void InitiateSolver()
		{
			if (!GetIKSolver().initiated)
			{
				GetIKSolver().Initiate(base.transform);
			}
		}

		protected override void FixTransforms()
		{
			if (GetIKSolver().initiated)
			{
				GetIKSolver().FixTransforms();
			}
		}

		protected abstract void OpenUserManual();

		protected abstract void OpenScriptReference();
	}
	public class IKExecutionOrder : MonoBehaviour
	{
		[Tooltip("The IK components, assign in the order in which you wish to update them.")]
		public IK[] IKComponents;

		[Tooltip("Optional. Assign it if you are using 'Animate Physics' as the Update Mode.")]
		public Animator animator;

		private bool fixedFrame;

		private bool animatePhysics
		{
			get
			{
				if (animator == null)
				{
					return false;
				}
				return animator.updateMode == AnimatorUpdateMode.AnimatePhysics;
			}
		}

		private void Start()
		{
			for (int i = 0; i < IKComponents.Length; i++)
			{
				IKComponents[i].enabled = false;
			}
		}

		private void Update()
		{
			if (!animatePhysics)
			{
				FixTransforms();
			}
		}

		private void FixedUpdate()
		{
			fixedFrame = true;
			if (animatePhysics)
			{
				FixTransforms();
			}
		}

		private void LateUpdate()
		{
			if (!animatePhysics || fixedFrame)
			{
				for (int i = 0; i < IKComponents.Length; i++)
				{
					IKComponents[i].GetIKSolver().Update();
				}
				fixedFrame = false;
			}
		}

		private void FixTransforms()
		{
			for (int i = 0; i < IKComponents.Length; i++)
			{
				if (IKComponents[i].fixTransforms)
				{
					IKComponents[i].GetIKSolver().FixTransforms();
				}
			}
		}
	}
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Leg IK")]
	public class LegIK : IK
	{
		public IKSolverLeg solver = new IKSolverLeg();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Debug.Log("No User Manual page for this component yet, sorry.");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Debug.Log("No Script Reference for this component yet, sorry.");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page7.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Limb IK")]
	public class LimbIK : IK
	{
		public IKSolverLimb solver = new IKSolverLimb();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page7.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_limb_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page8.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Look At IK")]
	public class LookAtIK : IK
	{
		public IKSolverLookAt solver = new IKSolverLookAt();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page8.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_look_at_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page9.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Trigonometric IK")]
	public class TrigonometricIK : IK
	{
		public IKSolverTrigonometric solver = new IKSolverTrigonometric();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page9.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_trigonometric_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/VR IK")]
	public class VRIK : IK
	{
		[Serializable]
		public class References
		{
			public Transform root;

			public Transform pelvis;

			public Transform spine;

			public Transform chest;

			public Transform neck;

			public Transform head;

			public Transform leftShoulder;

			public Transform leftUpperArm;

			public Transform leftForearm;

			public Transform leftHand;

			public Transform rightShoulder;

			public Transform rightUpperArm;

			public Transform rightForearm;

			public Transform rightHand;

			public Transform leftThigh;

			public Transform leftCalf;

			public Transform leftFoot;

			public Transform leftToes;

			public Transform rightThigh;

			public Transform rightCalf;

			public Transform rightFoot;

			public Transform rightToes;

			public bool isFilled
			{
				get
				{
					if (root == null || pelvis == null || spine == null || head == null || leftUpperArm == null || leftForearm == null || leftHand == null || rightUpperArm == null || rightForearm == null || rightHand == null || leftThigh == null || leftCalf == null || leftFoot == null || rightThigh == null || rightCalf == null || rightFoot == null)
					{
						return false;
					}
					return true;
				}
			}

			public bool isEmpty
			{
				get
				{
					if (root != null || pelvis != null || spine != null || chest != null || neck != null || head != null || leftShoulder != null || leftUpperArm != null || leftForearm != null || leftHand != null || rightShoulder != null || rightUpperArm != null || rightForearm != null || rightHand != null || leftThigh != null || leftCalf != null || leftFoot != null || leftToes != null || rightThigh != null || rightCalf != null || rightFoot != null || rightToes != null)
					{
						return false;
					}
					return true;
				}
			}

			public Transform[] GetTransforms()
			{
				return new Transform[22]
				{
					root, pelvis, spine, chest, neck, head, leftShoulder, leftUpperArm, leftForearm, leftHand,
					rightShoulder, rightUpperArm, rightForearm, rightHand, leftThigh, leftCalf, leftFoot, leftToes, rightThigh, rightCalf,
					rightFoot, rightToes
				};
			}

			public static bool AutoDetectReferences(Transform root, out References references)
			{
				references = new References();
				Animator componentInChildren = root.GetComponentInChildren<Animator>();
				if (componentInChildren == null || !componentInChildren.isHuman)
				{
					Debug.LogWarning("VRIK needs a Humanoid Animator to auto-detect biped references. Please assign references manually.");
					return false;
				}
				references.root = root;
				references.pelvis = componentInChildren.GetBoneTransform(HumanBodyBones.Hips);
				references.spine = componentInChildren.GetBoneTransform(HumanBodyBones.Spine);
				references.chest = componentInChildren.GetBoneTransform(HumanBodyBones.Chest);
				references.neck = componentInChildren.GetBoneTransform(HumanBodyBones.Neck);
				references.head = componentInChildren.GetBoneTransform(HumanBodyBones.Head);
				references.leftShoulder = componentInChildren.GetBoneTransform(HumanBodyBones.LeftShoulder);
				references.leftUpperArm = componentInChildren.GetBoneTransform(HumanBodyBones.LeftUpperArm);
				references.leftForearm = componentInChildren.GetBoneTransform(HumanBodyBones.LeftLowerArm);
				references.leftHand = componentInChildren.GetBoneTransform(HumanBodyBones.LeftHand);
				references.rightShoulder = componentInChildren.GetBoneTransform(HumanBodyBones.RightShoulder);
				references.rightUpperArm = componentInChildren.GetBoneTransform(HumanBodyBones.RightUpperArm);
				references.rightForearm = componentInChildren.GetBoneTransform(HumanBodyBones.RightLowerArm);
				references.rightHand = componentInChildren.GetBoneTransform(HumanBodyBones.RightHand);
				references.leftThigh = componentInChildren.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				references.leftCalf = componentInChildren.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
				references.leftFoot = componentInChildren.GetBoneTransform(HumanBodyBones.LeftFoot);
				references.leftToes = componentInChildren.GetBoneTransform(HumanBodyBones.LeftToes);
				references.rightThigh = componentInChildren.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				references.rightCalf = componentInChildren.GetBoneTransform(HumanBodyBones.RightLowerLeg);
				references.rightFoot = componentInChildren.GetBoneTransform(HumanBodyBones.RightFoot);
				references.rightToes = componentInChildren.GetBoneTransform(HumanBodyBones.RightToes);
				return true;
			}
		}

		[ContextMenuItem("Auto-detect References", "AutoDetectReferences")]
		[Tooltip("Bone mapping. Right-click on the component header and select 'Auto-detect References' of fill in manually if not a Humanoid character.")]
		public References references = new References();

		[Tooltip("The VRIK solver.")]
		public IKSolverVR solver = new IKSolverVR();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Debug.Log("Sorry, VRIK User Manual is not finished yet.");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Debug.Log("Sorry, VRIK Script reference is not finished yet.");
		}

		[ContextMenu("TUTORIAL VIDEO (STEAMVR SETUP)")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=6Pfx7lYQiIA&feature=youtu.be");
		}

		[ContextMenu("Auto-detect References")]
		public void AutoDetectReferences()
		{
			References.AutoDetectReferences(base.transform, out references);
		}

		[ContextMenu("Guess Hand Orientations")]
		public void GuessHandOrientations()
		{
			solver.GuessHandOrientations(references, onlyIfZero: false);
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}

		protected override void InitiateSolver()
		{
			if (references.isEmpty)
			{
				AutoDetectReferences();
			}
			if (references.isFilled)
			{
				solver.SetToReferences(references);
			}
			base.InitiateSolver();
		}
	}
	[Serializable]
	public class FABRIKChain
	{
		public FABRIK ik;

		[Range(0f, 1f)]
		public float pull = 1f;

		[Range(0f, 1f)]
		public float pin = 1f;

		public int[] children = new int[0];

		public bool IsValid(ref string message)
		{
			if (ik == null)
			{
				message = "IK unassigned in FABRIKChain.";
				return false;
			}
			if (!ik.solver.IsValid(ref message))
			{
				return false;
			}
			return true;
		}

		public void Initiate()
		{
			ik.enabled = false;
		}

		public void Stage1(FABRIKChain[] chain)
		{
			for (int i = 0; i < children.Length; i++)
			{
				chain[children[i]].Stage1(chain);
			}
			if (children.Length == 0)
			{
				ik.solver.SolveForward(ik.solver.GetIKPosition());
			}
			else
			{
				ik.solver.SolveForward(GetCentroid(chain));
			}
		}

		public void Stage2(Vector3 rootPosition, FABRIKChain[] chain)
		{
			ik.solver.SolveBackward(rootPosition);
			for (int i = 0; i < children.Length; i++)
			{
				chain[children[i]].Stage2(ik.solver.bones[ik.solver.bones.Length - 1].transform.position, chain);
			}
		}

		private Vector3 GetCentroid(FABRIKChain[] chain)
		{
			Vector3 iKPosition = ik.solver.GetIKPosition();
			if (pin >= 1f)
			{
				return iKPosition;
			}
			float num = 0f;
			for (int i = 0; i < children.Length; i++)
			{
				num += chain[children[i]].pull;
			}
			if (num <= 0f)
			{
				return iKPosition;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			Vector3 vector = iKPosition;
			for (int j = 0; j < children.Length; j++)
			{
				Vector3 vector2 = chain[children[j]].ik.solver.bones[0].solverPosition - iKPosition;
				float num2 = chain[children[j]].pull / num;
				vector += vector2 * num2;
			}
			if (pin <= 0f)
			{
				return vector;
			}
			return vector + (iKPosition - vector) * pin;
		}
	}
	public class FBBIKArmBending : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public Vector3 bendDirectionOffsetLeft;

		public Vector3 bendDirectionOffsetRight;

		public Vector3 characterSpaceBendOffsetLeft;

		public Vector3 characterSpaceBendOffsetRight;

		private Quaternion leftHandTargetRotation;

		private Quaternion rightHandTargetRotation;

		private bool initiated;

		private void LateUpdate()
		{
			if (!(ik == null))
			{
				if (!initiated)
				{
					IKSolverFullBodyBiped solver = ik.solver;
					solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
					initiated = true;
				}
				if (ik.solver.leftHandEffector.target != null)
				{
					Vector3 left = Vector3.left;
					ik.solver.leftArmChain.bendConstraint.direction = ik.solver.leftHandEffector.target.rotation * left + ik.solver.leftHandEffector.target.rotation * bendDirectionOffsetLeft + ik.transform.rotation * characterSpaceBendOffsetLeft;
					ik.solver.leftArmChain.bendConstraint.weight = 1f;
				}
				if (ik.solver.rightHandEffector.target != null)
				{
					Vector3 right = Vector3.right;
					ik.solver.rightArmChain.bendConstraint.direction = ik.solver.rightHandEffector.target.rotation * right + ik.solver.rightHandEffector.target.rotation * bendDirectionOffsetRight + ik.transform.rotation * characterSpaceBendOffsetRight;
					ik.solver.rightArmChain.bendConstraint.weight = 1f;
				}
			}
		}

		private void OnPostFBBIK()
		{
			if (!(ik == null))
			{
				if (ik.solver.leftHandEffector.target != null)
				{
					ik.references.leftHand.rotation = ik.solver.leftHandEffector.target.rotation;
				}
				if (ik.solver.rightHandEffector.target != null)
				{
					ik.references.rightHand.rotation = ik.solver.rightHandEffector.target.rotation;
				}
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
			}
		}
	}
	public class FBBIKHeadEffector : MonoBehaviour
	{
		[Serializable]
		public class BendBone
		{
			[Tooltip("Assign spine and/or neck bones.")]
			public Transform transform;

			[Tooltip("The weight of rotating this bone.")]
			[Range(0f, 1f)]
			public float weight = 0.5f;

			private Quaternion defaultLocalRotation = Quaternion.identity;

			public BendBone()
			{
			}

			public BendBone(Transform transform, float weight)
			{
				this.transform = transform;
				this.weight = weight;
			}

			public void StoreDefaultLocalState()
			{
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransforms()
			{
				transform.localRotation = defaultLocalRotation;
			}
		}

		[Tooltip("Reference to the FBBIK component.")]
		public FullBodyBipedIK ik;

		[LargeHeader("Position")]
		[Tooltip("Master weight for positioning the head.")]
		[Range(0f, 1f)]
		public float positionWeight = 1f;

		[Tooltip("The weight of moving the body along with the head")]
		[Range(0f, 1f)]
		public float bodyWeight = 0.8f;

		[Tooltip("The weight of moving the thighs along with the head")]
		[Range(0f, 1f)]
		public float thighWeight = 0.8f;

		[Tooltip("If false, hands will not pull the head away if they are too far. Disabling this will improve performance significantly.")]
		public bool handsPullBody = true;

		[LargeHeader("Rotation")]
		[Tooltip("The weight of rotating the head bone after solving")]
		[Range(0f, 1f)]
		public float rotationWeight;

		[Tooltip("Clamping the rotation of the body")]
		[Range(0f, 1f)]
		public float bodyClampWeight = 0.5f;

		[Tooltip("Clamping the rotation of the head")]
		[Range(0f, 1f)]
		public float headClampWeight = 0.5f;

		[Tooltip("The master weight of bending/twisting the spine to the rotation of the head effector. This is similar to CCD, but uses the rotation of the head effector not the position.")]
		[Range(0f, 1f)]
		public float bendWeight = 1f;

		[Tooltip("The bones to use for bending.")]
		public BendBone[] bendBones = new BendBone[0];

		[LargeHeader("CCD")]
		[Tooltip("Optional. The master weight of the CCD (Cyclic Coordinate Descent) IK effect that bends the spine towards the head effector before FBBIK solves.")]
		[Range(0f, 1f)]
		public float CCDWeight = 1f;

		[Tooltip("The weight of rolling the bones in towards the target")]
		[Range(0f, 1f)]
		public float roll;

		[Tooltip("Smoothing the CCD effect.")]
		[Range(0f, 1000f)]
		public float damper = 500f;

		[Tooltip("Bones to use for the CCD pass. Assign spine and/or neck bones.")]
		public Transform[] CCDBones = new Transform[0];

		[LargeHeader("Stretching")]
		[Tooltip("Stretching the spine/neck to help reach the target. This is useful for making sure the head stays locked relative to the VR headset. NB! Stretching is done after FBBIK has solved so if you have the hand effectors pinned and spine bones included in the 'Stretch Bones', the hands might become offset from their target positions.")]
		[Range(0f, 1f)]
		public float postStretchWeight = 1f;

		[Tooltip("Stretch magnitude limit.")]
		public float maxStretch = 0.1f;

		[Tooltip("If > 0, dampers the stretching effect.")]
		public float stretchDamper;

		[Tooltip("If true, will fix head position to this Transform no matter what. Good for making sure the head will not budge away from the VR headset")]
		public bool fixHead;

		[Tooltip("Bones to use for stretching. The more bones you add, the less noticable the effect.")]
		public Transform[] stretchBones = new Transform[0];

		[LargeHeader("Chest Direction")]
		public Vector3 chestDirection = Vector3.forward;

		[Range(0f, 1f)]
		public float chestDirectionWeight = 1f;

		public Transform[] chestBones = new Transform[0];

		public IKSolver.UpdateDelegate OnPostHeadEffectorFK;

		private Vector3 offset;

		private Vector3 headToBody;

		private Vector3 shoulderCenterToHead;

		private Vector3 headToLeftThigh;

		private Vector3 headToRightThigh;

		private Vector3 leftShoulderPos;

		private Vector3 rightShoulderPos;

		private float shoulderDist;

		private float leftShoulderDist;

		private float rightShoulderDist;

		private Quaternion chestRotation;

		private Quaternion headRotationRelativeToRoot;

		private Quaternion[] ccdDefaultLocalRotations = new Quaternion[0];

		private Vector3 headLocalPosition;

		private Quaternion headLocalRotation;

		private Vector3[] stretchLocalPositions = new Vector3[0];

		private Quaternion[] stretchLocalRotations = new Quaternion[0];

		private Vector3[] chestLocalPositions = new Vector3[0];

		private Quaternion[] chestLocalRotations = new Quaternion[0];

		private int bendBonesCount;

		private int ccdBonesCount;

		private int stretchBonesCount;

		private int chestBonesCount;

		private void Awake()
		{
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			IKSolverFullBodyBiped solver2 = ik.solver;
			solver2.OnPreIteration = (IKSolver.IterationDelegate)Delegate.Combine(solver2.OnPreIteration, new IKSolver.IterationDelegate(Iterate));
			IKSolverFullBodyBiped solver3 = ik.solver;
			solver3.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver3.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
			IKSolverFullBodyBiped solver4 = ik.solver;
			solver4.OnStoreDefaultLocalState = (IKSolver.UpdateDelegate)Delegate.Combine(solver4.OnStoreDefaultLocalState, new IKSolver.UpdateDelegate(OnStoreDefaultLocalState));
			IKSolverFullBodyBiped solver5 = ik.solver;
			solver5.OnFixTransforms = (IKSolver.UpdateDelegate)Delegate.Combine(solver5.OnFixTransforms, new IKSolver.UpdateDelegate(OnFixTransforms));
			headRotationRelativeToRoot = Quaternion.Inverse(ik.references.root.rotation) * ik.references.head.rotation;
		}

		private void OnStoreDefaultLocalState()
		{
			BendBone[] array = bendBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.StoreDefaultLocalState();
			}
			ccdDefaultLocalRotations = new Quaternion[CCDBones.Length];
			for (int j = 0; j < CCDBones.Length; j++)
			{
				if (CCDBones[j] != null)
				{
					ref Quaternion reference = ref ccdDefaultLocalRotations[j];
					reference = CCDBones[j].localRotation;
				}
			}
			headLocalPosition = ik.references.head.localPosition;
			headLocalRotation = ik.references.head.localRotation;
			stretchLocalPositions = new Vector3[stretchBones.Length];
			stretchLocalRotations = new Quaternion[stretchBones.Length];
			for (int k = 0; k < stretchBones.Length; k++)
			{
				if (stretchBones[k] != null)
				{
					ref Vector3 reference2 = ref stretchLocalPositions[k];
					reference2 = stretchBones[k].localPosition;
					ref Quaternion reference3 = ref stretchLocalRotations[k];
					reference3 = stretchBones[k].localRotation;
				}
			}
			chestLocalPositions = new Vector3[chestBones.Length];
			chestLocalRotations = new Quaternion[chestBones.Length];
			for (int l = 0; l < chestBones.Length; l++)
			{
				if (chestBones[l] != null)
				{
					ref Vector3 reference4 = ref chestLocalPositions[l];
					reference4 = chestBones[l].localPosition;
					ref Quaternion reference5 = ref chestLocalRotations[l];
					reference5 = chestBones[l].localRotation;
				}
			}
			bendBonesCount = bendBones.Length;
			ccdBonesCount = CCDBones.Length;
			stretchBonesCount = stretchBones.Length;
			chestBonesCount = chestBones.Length;
		}

		private void OnFixTransforms()
		{
			if (!ik.enabled)
			{
				return;
			}
			BendBone[] array = bendBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.FixTransforms();
			}
			for (int j = 0; j < CCDBones.Length; j++)
			{
				if (CCDBones[j] != null)
				{
					CCDBones[j].localRotation = ccdDefaultLocalRotations[j];
				}
			}
			ik.references.head.localPosition = headLocalPosition;
			ik.references.head.localRotation = headLocalRotation;
			for (int k = 0; k < stretchBones.Length; k++)
			{
				if (stretchBones[k] != null)
				{
					stretchBones[k].localPosition = stretchLocalPositions[k];
					stretchBones[k].localRotation = stretchLocalRotations[k];
				}
			}
			for (int l = 0; l < chestBones.Length; l++)
			{
				if (chestBones[l] != null)
				{
					chestBones[l].localPosition = chestLocalPositions[l];
					chestBones[l].localRotation = chestLocalRotations[l];
				}
			}
		}

		private void OnPreRead()
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy && ik.solver.iterations != 0)
			{
				ik.solver.FABRIKPass = handsPullBody;
				if (bendBonesCount != bendBones.Length || ccdBonesCount != CCDBones.Length || stretchBonesCount != stretchBones.Length || chestBonesCount != chestBones.Length)
				{
					OnStoreDefaultLocalState();
				}
				ChestDirection();
				SpineBend();
				CCDPass();
				offset = base.transform.position - ik.references.head.position;
				shoulderDist = Vector3.Distance(ik.references.leftUpperArm.position, ik.references.rightUpperArm.position);
				leftShoulderDist = Vector3.Distance(ik.references.head.position, ik.references.leftUpperArm.position);
				rightShoulderDist = Vector3.Distance(ik.references.head.position, ik.references.rightUpperArm.position);
				headToBody = ik.solver.rootNode.position - ik.references.head.position;
				headToLeftThigh = ik.references.leftThigh.position - ik.references.head.position;
				headToRightThigh = ik.references.rightThigh.position - ik.references.head.position;
				leftShoulderPos = ik.references.leftUpperArm.position + offset * bodyWeight;
				rightShoulderPos = ik.references.rightUpperArm.position + offset * bodyWeight;
				chestRotation = Quaternion.LookRotation(ik.references.head.position - ik.references.leftUpperArm.position, ik.references.rightUpperArm.position - ik.references.leftUpperArm.position);
				if (OnPostHeadEffectorFK != null)
				{
					OnPostHeadEffectorFK();
				}
			}
		}

		private void SpineBend()
		{
			float num = bendWeight * ik.solver.IKPositionWeight;
			if (num <= 0f || bendBones.Length == 0)
			{
				return;
			}
			Quaternion rotation = base.transform.rotation * Quaternion.Inverse(ik.references.root.rotation * headRotationRelativeToRoot);
			rotation = QuaTools.ClampRotation(rotation, bodyClampWeight, 2);
			float num2 = 1f / (float)bendBones.Length;
			for (int i = 0; i < bendBones.Length; i++)
			{
				if (bendBones[i].transform != null)
				{
					bendBones[i].transform.rotation = Quaternion.Lerp(Quaternion.identity, rotation, num2 * bendBones[i].weight * num) * bendBones[i].transform.rotation;
				}
			}
		}

		private void CCDPass()
		{
			float num = CCDWeight * ik.solver.IKPositionWeight;
			if (!(num <= 0f))
			{
				for (int num2 = CCDBones.Length - 1; num2 > -1; num2--)
				{
					Quaternion quaternion = Quaternion.FromToRotation(ik.references.head.position - CCDBones[num2].position, base.transform.position - CCDBones[num2].position) * CCDBones[num2].rotation;
					float num3 = Mathf.Lerp((CCDBones.Length - num2) / CCDBones.Length, 1f, roll);
					float num4 = Quaternion.Angle(Quaternion.identity, quaternion);
					num4 = Mathf.Lerp(0f, num4, (damper - num4) / damper);
					CCDBones[num2].rotation = Quaternion.RotateTowards(CCDBones[num2].rotation, quaternion, num4 * num * num3);
				}
			}
		}

		private void Iterate(int iteration)
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy && ik.solver.iterations != 0)
			{
				leftShoulderPos = base.transform.position + (leftShoulderPos - base.transform.position).normalized * leftShoulderDist;
				rightShoulderPos = base.transform.position + (rightShoulderPos - base.transform.position).normalized * rightShoulderDist;
				Solve(ref leftShoulderPos, ref rightShoulderPos, shoulderDist);
				LerpSolverPosition(ik.solver.leftShoulderEffector, leftShoulderPos, positionWeight * ik.solver.IKPositionWeight, ik.solver.leftShoulderEffector.positionOffset);
				LerpSolverPosition(ik.solver.rightShoulderEffector, rightShoulderPos, positionWeight * ik.solver.IKPositionWeight, ik.solver.rightShoulderEffector.positionOffset);
				Quaternion to = Quaternion.LookRotation(base.transform.position - leftShoulderPos, rightShoulderPos - leftShoulderPos);
				Quaternion quaternion = QuaTools.FromToRotation(chestRotation, to);
				Vector3 vector = quaternion * headToBody;
				LerpSolverPosition(ik.solver.bodyEffector, base.transform.position + vector, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset);
				Quaternion quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion, thighWeight);
				Vector3 vector2 = quaternion2 * headToLeftThigh;
				Vector3 vector3 = quaternion2 * headToRightThigh;
				LerpSolverPosition(ik.solver.leftThighEffector, base.transform.position + vector2, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset + ik.solver.leftThighEffector.positionOffset);
				LerpSolverPosition(ik.solver.rightThighEffector, base.transform.position + vector3, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset + ik.solver.rightThighEffector.positionOffset);
			}
		}

		private void OnPostUpdate()
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy)
			{
				PostStretching();
				Quaternion rotation = QuaTools.FromToRotation(ik.references.head.rotation, base.transform.rotation);
				rotation = QuaTools.ClampRotation(rotation, headClampWeight, 2);
				ik.references.head.rotation = Quaternion.Lerp(Quaternion.identity, rotation, rotationWeight * ik.solver.IKPositionWeight) * ik.references.head.rotation;
			}
		}

		private void ChestDirection()
		{
			float num = chestDirectionWeight * ik.solver.IKPositionWeight;
			if (num <= 0f)
			{
				return;
			}
			bool changed = false;
			chestDirection = V3Tools.ClampDirection(chestDirection, ik.references.root.forward, 0.45f, 2, out changed);
			if (!(chestDirection == Vector3.zero))
			{
				Quaternion b = Quaternion.FromToRotation(ik.references.root.forward, chestDirection);
				b = Quaternion.Lerp(Quaternion.identity, b, num * (1f / (float)chestBones.Length));
				Transform[] array = chestBones;
				foreach (Transform transform in array)
				{
					transform.rotation = b * transform.rotation;
				}
			}
		}

		private void PostStretching()
		{
			float num = postStretchWeight * ik.solver.IKPositionWeight;
			if (num > 0f)
			{
				Vector3 vector = Vector3.ClampMagnitude(base.transform.position - ik.references.head.position, maxStretch);
				vector *= num;
				stretchDamper = Mathf.Max(stretchDamper, 0f);
				if (stretchDamper > 0f)
				{
					vector /= (1f + vector.magnitude) * (1f + stretchDamper);
				}
				for (int i = 0; i < stretchBones.Length; i++)
				{
					if (stretchBones[i] != null)
					{
						stretchBones[i].position += vector / stretchBones.Length;
					}
				}
			}
			if (fixHead && ik.solver.IKPositionWeight > 0f)
			{
				ik.references.head.position = base.transform.position;
			}
		}

		private void LerpSolverPosition(IKEffector effector, Vector3 position, float weight, Vector3 offset)
		{
			effector.GetNode(ik.solver).solverPosition = Vector3.Lerp(effector.GetNode(ik.solver).solverPosition, position + offset, weight);
		}

		private void Solve(ref Vector3 pos1, ref Vector3 pos2, float nominalDistance)
		{
			Vector3 vector = pos2 - pos1;
			float magnitude = vector.magnitude;
			if (magnitude != nominalDistance && magnitude != 0f)
			{
				float num = 1f;
				num *= 1f - nominalDistance / magnitude;
				Vector3 vector2 = vector * num * 0.5f;
				pos1 += vector2;
				pos2 -= vector2;
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
				IKSolverFullBodyBiped solver2 = ik.solver;
				solver2.OnPreIteration = (IKSolver.IterationDelegate)Delegate.Remove(solver2.OnPreIteration, new IKSolver.IterationDelegate(Iterate));
				IKSolverFullBodyBiped solver3 = ik.solver;
				solver3.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver3.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
				IKSolverFullBodyBiped solver4 = ik.solver;
				solver4.OnStoreDefaultLocalState = (IKSolver.UpdateDelegate)Delegate.Remove(solver4.OnStoreDefaultLocalState, new IKSolver.UpdateDelegate(OnStoreDefaultLocalState));
				IKSolverFullBodyBiped solver5 = ik.solver;
				solver5.OnFixTransforms = (IKSolver.UpdateDelegate)Delegate.Remove(solver5.OnFixTransforms, new IKSolver.UpdateDelegate(OnFixTransforms));
			}
		}
	}
	[Serializable]
	public class FBIKChain
	{
		[Serializable]
		public class ChildConstraint
		{
			public float pushElasticity;

			public float pullElasticity;

			[SerializeField]
			private Transform bone1;

			[SerializeField]
			private Transform bone2;

			private float crossFade;

			private float inverseCrossFade;

			private int chain1Index;

			private int chain2Index;

			public float nominalDistance { get; private set; }

			public bool isRigid { get; private set; }

			public ChildConstraint(Transform bone1, Transform bone2, float pushElasticity = 0f, float pullElasticity = 0f)
			{
				this.bone1 = bone1;
				this.bone2 = bone2;
				this.pushElasticity = pushElasticity;
				this.pullElasticity = pullElasticity;
			}

			public void Initiate(IKSolverFullBody solver)
			{
				chain1Index = solver.GetChainIndex(bone1);
				chain2Index = solver.GetChainIndex(bone2);
				OnPreSolve(solver);
			}

			public void OnPreSolve(IKSolverFullBody solver)
			{
				nominalDistance = Vector3.Distance(solver.chain[chain1Index].nodes[0].transform.position, solver.chain[chain2Index].nodes[0].transform.position);
				isRigid = pushElasticity <= 0f && pullElasticity <= 0f;
				if (isRigid)
				{
					float num = solver.chain[chain1Index].pull - solver.chain[chain2Index].pull;
					crossFade = 1f - (0.5f + num * 0.5f);
				}
				else
				{
					crossFade = 0.5f;
				}
				inverseCrossFade = 1f - crossFade;
			}

			public void Solve(IKSolverFullBody solver)
			{
				if (pushElasticity >= 1f && pullElasticity >= 1f)
				{
					return;
				}
				Vector3 vector = solver.chain[chain2Index].nodes[0].solverPosition - solver.chain[chain1Index].nodes[0].solverPosition;
				float magnitude = vector.magnitude;
				if (magnitude != nominalDistance && magnitude != 0f)
				{
					float num = 1f;
					if (!isRigid)
					{
						float num2 = ((!(magnitude > nominalDistance)) ? pushElasticity : pullElasticity);
						num = 1f - num2;
					}
					num *= 1f - nominalDistance / magnitude;
					Vector3 vector2 = vector * num;
					solver.chain[chain1Index].nodes[0].solverPosition += vector2 * crossFade;
					solver.chain[chain2Index].nodes[0].solverPosition -= vector2 * inverseCrossFade;
				}
			}
		}

		[Serializable]
		public enum Smoothing
		{
			None,
			Exponential,
			Cubic
		}

		[Range(0f, 1f)]
		public float pin;

		[Range(0f, 1f)]
		public float pull = 1f;

		[Range(0f, 1f)]
		public float push;

		[Range(-1f, 1f)]
		public float pushParent;

		[Range(0f, 1f)]
		public float reach = 0.1f;

		public Smoothing reachSmoothing = Smoothing.Exponential;

		public Smoothing pushSmoothing = Smoothing.Exponential;

		public IKSolver.Node[] nodes = new IKSolver.Node[0];

		public int[] children = new int[0];

		public ChildConstraint[] childConstraints = new ChildConstraint[0];

		public IKConstraintBend bendConstraint = new IKConstraintBend();

		private float rootLength;

		private bool initiated;

		private float length;

		private float distance;

		private IKSolver.Point p;

		private float reachForce;

		private float pullParentSum;

		private float[] crossFades;

		private float sqrMag1;

		private float sqrMag2;

		private float sqrMagDif;

		private const float maxLimbLength = 0.99999f;

		public FBIKChain()
		{
		}

		public FBIKChain(float pin, float pull, params Transform[] nodeTransforms)
		{
			this.pin = pin;
			this.pull = pull;
			SetNodes(nodeTransforms);
			children = new int[0];
		}

		public void SetNodes(params Transform[] boneTransforms)
		{
			nodes = new IKSolver.Node[boneTransforms.Length];
			for (int i = 0; i < boneTransforms.Length; i++)
			{
				nodes[i] = new IKSolver.Node(boneTransforms[i]);
			}
		}

		public int GetNodeIndex(Transform boneTransform)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].transform == boneTransform)
				{
					return i;
				}
			}
			return -1;
		}

		public bool IsValid(ref string message)
		{
			if (nodes.Length == 0)
			{
				message = "FBIK chain contains no nodes.";
				return false;
			}
			IKSolver.Node[] array = nodes;
			foreach (IKSolver.Node node in array)
			{
				if (node.transform == null)
				{
					message = "Node transform is null in FBIK chain.";
					return false;
				}
			}
			return true;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			initiated = false;
			IKSolver.Node[] array = nodes;
			foreach (IKSolver.Node node in array)
			{
				node.solverPosition = node.transform.position;
			}
			CalculateBoneLengths(solver);
			ChildConstraint[] array2 = childConstraints;
			foreach (ChildConstraint childConstraint in array2)
			{
				childConstraint.Initiate(solver);
			}
			if (nodes.Length == 3)
			{
				bendConstraint.SetBones(nodes[0].transform, nodes[1].transform, nodes[2].transform);
				bendConstraint.Initiate(solver);
			}
			crossFades = new float[children.Length];
			initiated = true;
		}

		public void ReadPose(IKSolverFullBody solver, bool fullBody)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i].solverPosition = nodes[i].transform.position + nodes[i].offset;
			}
			CalculateBoneLengths(solver);
			if (!fullBody)
			{
				return;
			}
			for (int j = 0; j < childConstraints.Length; j++)
			{
				childConstraints[j].OnPreSolve(solver);
			}
			if (children.Length > 0)
			{
				float num = nodes[nodes.Length - 1].effectorPositionWeight;
				for (int k = 0; k < children.Length; k++)
				{
					num += solver.chain[children[k]].nodes[0].effectorPositionWeight * solver.chain[children[k]].pull;
				}
				num = Mathf.Clamp(num, 1f, float.PositiveInfinity);
				for (int l = 0; l < children.Length; l++)
				{
					crossFades[l] = solver.chain[children[l]].nodes[0].effectorPositionWeight * solver.chain[children[l]].pull / num;
				}
			}
			pullParentSum = 0f;
			for (int m = 0; m < children.Length; m++)
			{
				pullParentSum += solver.chain[children[m]].pull;
			}
			pullParentSum = Mathf.Clamp(pullParentSum, 1f, float.PositiveInfinity);
			if (nodes.Length == 3)
			{
				reachForce = reach * Mathf.Clamp(nodes[2].effectorPositionWeight, 0f, 1f);
			}
			else
			{
				reachForce = 0f;
			}
			if (push > 0f && nodes.Length > 1)
			{
				distance = Vector3.Distance(nodes[0].transform.position, nodes[nodes.Length - 1].transform.position);
			}
		}

		private void CalculateBoneLengths(IKSolverFullBody solver)
		{
			length = 0f;
			for (int i = 0; i < nodes.Length - 1; i++)
			{
				nodes[i].length = Vector3.Distance(nodes[i].transform.position, nodes[i + 1].transform.position);
				length += nodes[i].length;
				if (nodes[i].length == 0f)
				{
					Warning.Log("Bone " + nodes[i].transform.name + " - " + nodes[i + 1].transform.name + " length is zero, can not solve.", nodes[i].transform);
					return;
				}
			}
			for (int j = 0; j < children.Length; j++)
			{
				solver.chain[children[j]].rootLength = (solver.chain[children[j]].nodes[0].transform.position - nodes[nodes.Length - 1].transform.position).magnitude;
				if (solver.chain[children[j]].rootLength == 0f)
				{
					return;
				}
			}
			if (nodes.Length == 3)
			{
				sqrMag1 = nodes[0].length * nodes[0].length;
				sqrMag2 = nodes[1].length * nodes[1].length;
				sqrMagDif = sqrMag1 - sqrMag2;
			}
		}

		public void Reach(IKSolverFullBody solver)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].Reach(solver);
			}
			if (reachForce <= 0f)
			{
				return;
			}
			Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
			if (!(vector == Vector3.zero))
			{
				float magnitude = vector.magnitude;
				Vector3 vector2 = vector / magnitude * length;
				float num = Mathf.Clamp(magnitude / length, 1f - reachForce, 1f + reachForce) - 1f;
				num = Mathf.Clamp(num + reachForce, -1f, 1f);
				switch (reachSmoothing)
				{
				case Smoothing.Exponential:
					num *= num;
					break;
				case Smoothing.Cubic:
					num *= num * num;
					break;
				}
				Vector3 vector3 = vector2 * Mathf.Clamp(num, 0f, magnitude);
				nodes[0].solverPosition += vector3 * (1f - nodes[0].effectorPositionWeight);
				nodes[2].solverPosition += vector3;
			}
		}

		public Vector3 Push(IKSolverFullBody solver)
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < children.Length; i++)
			{
				zero += solver.chain[children[i]].Push(solver) * solver.chain[children[i]].pushParent;
			}
			nodes[nodes.Length - 1].solverPosition += zero;
			if (nodes.Length < 2)
			{
				return Vector3.zero;
			}
			if (push <= 0f)
			{
				return Vector3.zero;
			}
			Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
			float magnitude = vector.magnitude;
			if (magnitude == 0f)
			{
				return Vector3.zero;
			}
			float num = 1f - magnitude / distance;
			if (num <= 0f)
			{
				return Vector3.zero;
			}
			switch (pushSmoothing)
			{
			case Smoothing.Exponential:
				num *= num;
				break;
			case Smoothing.Cubic:
				num *= num * num;
				break;
			}
			Vector3 vector2 = -vector * num * push;
			nodes[0].solverPosition += vector2;
			return vector2;
		}

		public void SolveTrigonometric(IKSolverFullBody solver, bool calculateBendDirection = false)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].SolveTrigonometric(solver, calculateBendDirection);
			}
			if (nodes.Length == 3)
			{
				Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
				float magnitude = vector.magnitude;
				if (magnitude != 0f)
				{
					float num = Mathf.Clamp(magnitude, 0f, length * 0.99999f);
					Vector3 direction = vector / magnitude * num;
					Vector3 bendDirection = ((!calculateBendDirection || !bendConstraint.initiated) ? (nodes[1].solverPosition - nodes[0].solverPosition) : bendConstraint.GetDir(solver));
					Vector3 dirToBendPoint = GetDirToBendPoint(direction, bendDirection, num);
					nodes[1].solverPosition = nodes[0].solverPosition + dirToBendPoint;
				}
			}
		}

		public void Stage1(IKSolverFullBody solver)
		{
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].Stage1(solver);
			}
			if (children.Length == 0)
			{
				ForwardReach(nodes[nodes.Length - 1].solverPosition);
				return;
			}
			Vector3 solverPosition = nodes[nodes.Length - 1].solverPosition;
			SolveChildConstraints(solver);
			for (int j = 0; j < children.Length; j++)
			{
				Vector3 vector = solver.chain[children[j]].nodes[0].solverPosition;
				if (solver.chain[children[j]].rootLength > 0f)
				{
					vector = SolveFABRIKJoint(nodes[nodes.Length - 1].solverPosition, solver.chain[children[j]].nodes[0].solverPosition, solver.chain[children[j]].rootLength);
				}
				if (pullParentSum > 0f)
				{
					solverPosition += (vector - nodes[nodes.Length - 1].solverPosition) * (solver.chain[children[j]].pull / pullParentSum);
				}
			}
			ForwardReach(Vector3.Lerp(solverPosition, nodes[nodes.Length - 1].solverPosition, pin));
		}

		public void Stage2(IKSolverFullBody solver, Vector3 position)
		{
			BackwardReach(position);
			int num = Mathf.Clamp(solver.iterations, 2, 4);
			if (childConstraints.Length > 0)
			{
				for (int i = 0; i < num; i++)
				{
					SolveConstraintSystems(solver);
				}
			}
			for (int j = 0; j < children.Length; j++)
			{
				solver.chain[children[j]].Stage2(solver, nodes[nodes.Length - 1].solverPosition);
			}
		}

		public void SolveConstraintSystems(IKSolverFullBody solver)
		{
			SolveChildConstraints(solver);
			for (int i = 0; i < children.Length; i++)
			{
				SolveLinearConstraint(nodes[nodes.Length - 1], solver.chain[children[i]].nodes[0], crossFades[i], solver.chain[children[i]].rootLength);
			}
		}

		private Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			return pos2 + (pos1 - pos2).normalized * length;
		}

		protected Vector3 GetDirToBendPoint(Vector3 direction, Vector3 bendDirection, float directionMagnitude)
		{
			float num = (directionMagnitude * directionMagnitude + sqrMagDif) / 2f / directionMagnitude;
			float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
			if (direction == Vector3.zero)
			{
				return Vector3.zero;
			}
			return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
		}

		private void SolveChildConstraints(IKSolverFullBody solver)
		{
			for (int i = 0; i < childConstraints.Length; i++)
			{
				childConstraints[i].Solve(solver);
			}
		}

		private void SolveLinearConstraint(IKSolver.Node node1, IKSolver.Node node2, float crossFade, float distance)
		{
			Vector3 vector = node2.solverPosition - node1.solverPosition;
			float magnitude = vector.magnitude;
			if (distance != magnitude && magnitude != 0f)
			{
				Vector3 vector2 = vector * (1f - distance / magnitude);
				node1.solverPosition += vector2 * crossFade;
				node2.solverPosition -= vector2 * (1f - crossFade);
			}
		}

		public void ForwardReach(Vector3 position)
		{
			nodes[nodes.Length - 1].solverPosition = position;
			for (int num = nodes.Length - 2; num > -1; num--)
			{
				nodes[num].solverPosition = SolveFABRIKJoint(nodes[num].solverPosition, nodes[num + 1].solverPosition, nodes[num].length);
			}
		}

		private void BackwardReach(Vector3 position)
		{
			if (rootLength > 0f)
			{
				position = SolveFABRIKJoint(nodes[0].solverPosition, position, rootLength);
			}
			nodes[0].solverPosition = position;
			for (int i = 1; i < nodes.Length; i++)
			{
				nodes[i].solverPosition = SolveFABRIKJoint(nodes[i].solverPosition, nodes[i - 1].solverPosition, nodes[i - 1].length);
			}
		}
	}
	[Serializable]
	public class IKConstraintBend
	{
		public Transform bone1;

		public Transform bone2;

		public Transform bone3;

		public Transform bendGoal;

		public Vector3 direction = Vector3.right;

		public Quaternion rotationOffset;

		[Range(0f, 1f)]
		public float weight;

		public Vector3 defaultLocalDirection;

		public Vector3 defaultChildDirection;

		[NonSerialized]
		public float clampF = 0.505f;

		private int chainIndex1;

		private int nodeIndex1;

		private int chainIndex2;

		private int nodeIndex2;

		private int chainIndex3;

		private int nodeIndex3;

		public bool initiated { get; private set; }

		public IKConstraintBend()
		{
		}

		public IKConstraintBend(Transform bone1, Transform bone2, Transform bone3)
		{
			SetBones(bone1, bone2, bone3);
		}

		public bool IsValid(IKSolverFullBody solver, Warning.Logger logger)
		{
			if (bone1 == null || bone2 == null || bone3 == null)
			{
				logger?.Invoke("Bend Constraint contains a null reference.");
				return false;
			}
			if (solver.GetPoint(bone1) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone1.name + "' that does not excist in the Node Chain.");
				return false;
			}
			if (solver.GetPoint(bone2) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone2.name + "' that does not excist in the Node Chain.");
				return false;
			}
			if (solver.GetPoint(bone3) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone3.name + "' that does not excist in the Node Chain.");
				return false;
			}
			return true;
		}

		public void SetBones(Transform bone1, Transform bone2, Transform bone3)
		{
			this.bone1 = bone1;
			this.bone2 = bone2;
			this.bone3 = bone3;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			solver.GetChainAndNodeIndexes(bone1, out chainIndex1, out nodeIndex1);
			solver.GetChainAndNodeIndexes(bone2, out chainIndex2, out nodeIndex2);
			solver.GetChainAndNodeIndexes(bone3, out chainIndex3, out nodeIndex3);
			direction = OrthoToBone1(solver, OrthoToLimb(solver, bone2.position - bone1.position));
			defaultLocalDirection = Quaternion.Inverse(bone1.rotation) * direction;
			Vector3 vector = Vector3.Cross((bone3.position - bone1.position).normalized, direction);
			defaultChildDirection = Quaternion.Inverse(bone3.rotation) * vector;
			initiated = true;
		}

		public void SetLimbOrientation(Vector3 upper, Vector3 lower, Vector3 last)
		{
			if (upper == Vector3.zero)
			{
				Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			if (lower == Vector3.zero)
			{
				Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			if (last == Vector3.zero)
			{
				Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			defaultLocalDirection = upper.normalized;
			defaultChildDirection = last.normalized;
		}

		public void LimitBend(float solverWeight, float positionWeight)
		{
			if (initiated)
			{
				Vector3 vector = bone1.rotation * -defaultLocalDirection;
				Vector3 fromDirection = bone3.position - bone2.position;
				bool changed = false;
				Vector3 toDirection = V3Tools.ClampDirection(fromDirection, vector, clampF * solverWeight, 0, out changed);
				Quaternion rotation = bone3.rotation;
				if (changed)
				{
					Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
					bone2.rotation = quaternion * bone2.rotation;
				}
				if (positionWeight > 0f)
				{
					Vector3 normal = bone2.position - bone1.position;
					Vector3 tangent = bone3.position - bone2.position;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					Quaternion quaternion2 = Quaternion.FromToRotation(tangent, vector);
					bone2.rotation = Quaternion.Lerp(bone2.rotation, quaternion2 * bone2.rotation, positionWeight * solverWeight);
				}
				if (changed || positionWeight > 0f)
				{
					bone3.rotation = rotation;
				}
			}
		}

		public Vector3 GetDir(IKSolverFullBody solver)
		{
			if (!initiated)
			{
				return Vector3.zero;
			}
			float num = weight * solver.IKPositionWeight;
			if (bendGoal != null)
			{
				Vector3 vector = bendGoal.position - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
				if (vector != Vector3.zero)
				{
					direction = vector;
				}
			}
			if (num >= 1f)
			{
				return direction.normalized;
			}
			Vector3 vector2 = solver.GetNode(chainIndex3, nodeIndex3).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Quaternion quaternion = Quaternion.FromToRotation(bone3.position - bone1.position, vector2);
			Vector3 vector3 = quaternion * (bone2.position - bone1.position);
			if (solver.GetNode(chainIndex3, nodeIndex3).effectorRotationWeight > 0f)
			{
				Vector3 b = -Vector3.Cross(vector2, solver.GetNode(chainIndex3, nodeIndex3).solverRotation * defaultChildDirection);
				vector3 = Vector3.Lerp(vector3, b, solver.GetNode(chainIndex3, nodeIndex3).effectorRotationWeight);
			}
			if (rotationOffset != Quaternion.identity)
			{
				Quaternion quaternion2 = Quaternion.FromToRotation(rotationOffset * vector2, vector2);
				vector3 = quaternion2 * rotationOffset * vector3;
			}
			if (num <= 0f)
			{
				return vector3;
			}
			return Vector3.Lerp(vector3, direction.normalized, num);
		}

		private Vector3 OrthoToLimb(IKSolverFullBody solver, Vector3 tangent)
		{
			Vector3 normal = solver.GetNode(chainIndex3, nodeIndex3).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}

		private Vector3 OrthoToBone1(IKSolverFullBody solver, Vector3 tangent)
		{
			Vector3 normal = solver.GetNode(chainIndex2, nodeIndex2).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}
	}
	[Serializable]
	public class IKEffector
	{
		public Transform bone;

		public Transform target;

		[Range(0f, 1f)]
		public float positionWeight;

		[Range(0f, 1f)]
		public float rotationWeight;

		public Vector3 position = Vector3.zero;

		public Quaternion rotation = Quaternion.identity;

		public Vector3 positionOffset;

		public bool effectChildNodes = true;

		[Range(0f, 1f)]
		public float maintainRelativePositionWeight;

		public Transform[] childBones = new Transform[0];

		public Transform planeBone1;

		public Transform planeBone2;

		public Transform planeBone3;

		public Quaternion planeRotationOffset = Quaternion.identity;

		private float posW;

		private float rotW;

		private Vector3[] localPositions = new Vector3[0];

		private bool usePlaneNodes;

		private Quaternion animatedPlaneRotation = Quaternion.identity;

		private Vector3 animatedPosition;

		private bool firstUpdate;

		private int chainIndex = -1;

		private int nodeIndex = -1;

		private int plane1ChainIndex;

		private int plane1NodeIndex = -1;

		private int plane2ChainIndex = -1;

		private int plane2NodeIndex = -1;

		private int plane3ChainIndex = -1;

		private int plane3NodeIndex = -1;

		private int[] childChainIndexes = new int[0];

		private int[] childNodeIndexes = new int[0];

		public bool isEndEffector { get; private set; }

		public IKEffector()
		{
		}

		public IKEffector(Transform bone, Transform[] childBones)
		{
			this.bone = bone;
			this.childBones = childBones;
		}

		public IKSolver.Node GetNode(IKSolverFullBody solver)
		{
			return solver.chain[chainIndex].nodes[nodeIndex];
		}

		public void PinToBone(float positionWeight, float rotationWeight)
		{
			position = bone.position;
			this.positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			rotation = bone.rotation;
			this.rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
		}

		public bool IsValid(IKSolver solver, ref string message)
		{
			if (bone == null)
			{
				message = "IK Effector bone is null.";
				return false;
			}
			if (solver.GetPoint(bone) == null)
			{
				message = "IK Effector is referencing to a bone '" + bone.name + "' that does not excist in the Node Chain.";
				return false;
			}
			Transform[] array = childBones;
			foreach (Transform transform in array)
			{
				if (transform == null)
				{
					message = "IK Effector contains a null reference.";
					return false;
				}
			}
			Transform[] array2 = childBones;
			foreach (Transform transform2 in array2)
			{
				if (solver.GetPoint(transform2) == null)
				{
					message = "IK Effector is referencing to a bone '" + transform2.name + "' that does not excist in the Node Chain.";
					return false;
				}
			}
			if (planeBone1 != null && solver.GetPoint(planeBone1) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone1.name + "' that does not excist in the Node Chain.";
				return false;
			}
			if (planeBone2 != null && solver.GetPoint(planeBone2) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone2.name + "' that does not excist in the Node Chain.";
				return false;
			}
			if (planeBone3 != null && solver.GetPoint(planeBone3) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone3.name + "' that does not excist in the Node Chain.";
				return false;
			}
			return true;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			position = bone.position;
			rotation = bone.rotation;
			animatedPlaneRotation = Quaternion.identity;
			solver.GetChainAndNodeIndexes(bone, out chainIndex, out nodeIndex);
			childChainIndexes = new int[childBones.Length];
			childNodeIndexes = new int[childBones.Length];
			for (int i = 0; i < childBones.Length; i++)
			{
				solver.GetChainAndNodeIndexes(childBones[i], out childChainIndexes[i], out childNodeIndexes[i]);
			}
			localPositions = new Vector3[childBones.Length];
			usePlaneNodes = false;
			if (planeBone1 != null)
			{
				solver.GetChainAndNodeIndexes(planeBone1, out plane1ChainIndex, out plane1NodeIndex);
				if (planeBone2 != null)
				{
					solver.GetChainAndNodeIndexes(planeBone2, out plane2ChainIndex, out plane2NodeIndex);
					if (planeBone3 != null)
					{
						solver.GetChainAndNodeIndexes(planeBone3, out plane3ChainIndex, out plane3NodeIndex);
						usePlaneNodes = true;
					}
				}
				isEndEffector = true;
			}
			else
			{
				isEndEffector = false;
			}
		}

		public void ResetOffset(IKSolverFullBody solver)
		{
			solver.GetNode(chainIndex, nodeIndex).offset = Vector3.zero;
			for (int i = 0; i < childChainIndexes.Length; i++)
			{
				solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).offset = Vector3.zero;
			}
		}

		public void SetToTarget()
		{
			if (!(target == null))
			{
				position = target.position;
				rotation = target.rotation;
			}
		}

		public void OnPreSolve(IKSolverFullBody solver)
		{
			positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
			maintainRelativePositionWeight = Mathf.Clamp(maintainRelativePositionWeight, 0f, 1f);
			posW = positionWeight * solver.IKPositionWeight;
			rotW = rotationWeight * solver.IKPositionWeight;
			solver.GetNode(chainIndex, nodeIndex).effectorPositionWeight = posW;
			solver.GetNode(chainIndex, nodeIndex).effectorRotationWeight = rotW;
			solver.GetNode(chainIndex, nodeIndex).solverRotation = rotation;
			if (float.IsInfinity(positionOffset.x) || float.IsInfinity(positionOffset.y) || float.IsInfinity(positionOffset.z))
			{
				Debug.LogError("Invalid IKEffector.positionOffset (contains Infinity)! Please make sure not to set IKEffector.positionOffset to infinite values.", bone);
			}
			if (float.IsNaN(positionOffset.x) || float.IsNaN(positionOffset.y) || float.IsNaN(positionOffset.z))
			{
				Debug.LogError("Invalid IKEffector.positionOffset (contains NaN)! Please make sure not to set IKEffector.positionOffset to NaN values.", bone);
			}
			if (positionOffset.sqrMagnitude > 1E+10f)
			{
				Debug.LogError("Additive effector positionOffset detected in Full Body IK (extremely large value). Make sure you are not circularily adding to effector positionOffset each frame.", bone);
			}
			if (float.IsInfinity(position.x) || float.IsInfinity(position.y) || float.IsInfinity(position.z))
			{
				Debug.LogError("Invalid IKEffector.position (contains Infinity)!");
			}
			solver.GetNode(chainIndex, nodeIndex).offset += positionOffset * solver.IKPositionWeight;
			if (effectChildNodes && solver.iterations > 0)
			{
				for (int i = 0; i < childBones.Length; i++)
				{
					ref Vector3 reference = ref localPositions[i];
					reference = childBones[i].transform.position - bone.transform.position;
					solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).offset += positionOffset * solver.IKPositionWeight;
				}
			}
			if (usePlaneNodes && maintainRelativePositionWeight > 0f)
			{
				animatedPlaneRotation = Quaternion.LookRotation(planeBone2.position - planeBone1.position, planeBone3.position - planeBone1.position);
			}
			firstUpdate = true;
		}

		public void OnPostWrite()
		{
			positionOffset = Vector3.zero;
		}

		private Quaternion GetPlaneRotation(IKSolverFullBody solver)
		{
			Vector3 solverPosition = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition;
			Vector3 solverPosition2 = solver.GetNode(plane2ChainIndex, plane2NodeIndex).solverPosition;
			Vector3 solverPosition3 = solver.GetNode(plane3ChainIndex, plane3NodeIndex).solverPosition;
			Vector3 vector = solverPosition2 - solverPosition;
			Vector3 upwards = solverPosition3 - solverPosition;
			if (vector == Vector3.zero)
			{
				Warning.Log("Make sure you are not placing 2 or more FBBIK effectors of the same chain to exactly the same position.", bone);
				return Quaternion.identity;
			}
			return Quaternion.LookRotation(vector, upwards);
		}

		public void Update(IKSolverFullBody solver)
		{
			if (firstUpdate)
			{
				animatedPosition = bone.position + solver.GetNode(chainIndex, nodeIndex).offset;
				firstUpdate = false;
			}
			solver.GetNode(chainIndex, nodeIndex).solverPosition = Vector3.Lerp(GetPosition(solver, out planeRotationOffset), position, posW);
			if (effectChildNodes)
			{
				for (int i = 0; i < childBones.Length; i++)
				{
					solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).solverPosition = Vector3.Lerp(solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).solverPosition, solver.GetNode(chainIndex, nodeIndex).solverPosition + localPositions[i], posW);
				}
			}
		}

		private Vector3 GetPosition(IKSolverFullBody solver, out Quaternion planeRotationOffset)
		{
			planeRotationOffset = Quaternion.identity;
			if (!isEndEffector)
			{
				return solver.GetNode(chainIndex, nodeIndex).solverPosition;
			}
			if (maintainRelativePositionWeight <= 0f)
			{
				return animatedPosition;
			}
			Vector3 vector = bone.position;
			Vector3 vector2 = vector - planeBone1.position;
			planeRotationOffset = GetPlaneRotation(solver) * Quaternion.Inverse(animatedPlaneRotation);
			vector = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition + planeRotationOffset * vector2;
			planeRotationOffset = Quaternion.Lerp(Quaternion.identity, planeRotationOffset, maintainRelativePositionWeight);
			return Vector3.Lerp(animatedPosition, vector + solver.GetNode(chainIndex, nodeIndex).offset, maintainRelativePositionWeight);
		}
	}
	[Serializable]
	public class IKMapping
	{
		[Serializable]
		public class BoneMap
		{
			public Transform transform;

			public int chainIndex = -1;

			public int nodeIndex = -1;

			public Vector3 defaultLocalPosition;

			public Quaternion defaultLocalRotation;

			public Vector3 localSwingAxis;

			public Vector3 localTwistAxis;

			public Vector3 planePosition;

			public Vector3 ikPosition;

			public Quaternion defaultLocalTargetRotation;

			private Quaternion maintainRotation;

			public float length;

			public Quaternion animatedRotation;

			private Transform planeBone1;

			private Transform planeBone2;

			private Transform planeBone3;

			private int plane1ChainIndex = -1;

			private int plane1NodeIndex = -1;

			private int plane2ChainIndex = -1;

			private int plane2NodeIndex = -1;

			private int plane3ChainIndex = -1;

			private int plane3NodeIndex = -1;

			public Vector3 swingDirection => transform.rotation * localSwingAxis;

			public bool isNodeBone => nodeIndex != -1;

			private Quaternion lastAnimatedTargetRotation
			{
				get
				{
					if (planeBone1.position == planeBone3.position)
					{
						return Quaternion.identity;
					}
					return Quaternion.LookRotation(planeBone2.position - planeBone1.position, planeBone3.position - planeBone1.position);
				}
			}

			public void Initiate(Transform transform, IKSolverFullBody solver)
			{
				this.transform = transform;
				solver.GetChainAndNodeIndexes(transform, out chainIndex, out nodeIndex);
			}

			public void StoreDefaultLocalState()
			{
				defaultLocalPosition = transform.localPosition;
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransform(bool position)
			{
				if (position)
				{
					transform.localPosition = defaultLocalPosition;
				}
				transform.localRotation = defaultLocalRotation;
			}

			public void SetLength(BoneMap nextBone)
			{
				length = Vector3.Distance(transform.position, nextBone.transform.position);
			}

			public void SetLocalSwingAxis(BoneMap swingTarget)
			{
				SetLocalSwingAxis(swingTarget, this);
			}

			public void SetLocalSwingAxis(BoneMap bone1, BoneMap bone2)
			{
				localSwingAxis = Quaternion.Inverse(transform.rotation) * (bone1.transform.position - bone2.transform.position);
			}

			public void SetLocalTwistAxis(Vector3 twistDirection, Vector3 normalDirection)
			{
				Vector3.OrthoNormalize(ref normalDirection, ref twistDirection);
				localTwistAxis = Quaternion.Inverse(transform.rotation) * twistDirection;
			}

			public void SetPlane(IKSolverFullBody solver, Transform planeBone1, Transform planeBone2, Transform planeBone3)
			{
				this.planeBone1 = planeBone1;
				this.planeBone2 = planeBone2;
				this.planeBone3 = planeBone3;
				solver.GetChainAndNodeIndexes(planeBone1, out plane1ChainIndex, out plane1NodeIndex);
				solver.GetChainAndNodeIndexes(planeBone2, out plane2ChainIndex, out plane2NodeIndex);
				solver.GetChainAndNodeIndexes(planeBone3, out plane3ChainIndex, out plane3NodeIndex);
				UpdatePlane(rotation: true, position: true);
			}

			public void UpdatePlane(bool rotation, bool position)
			{
				Quaternion rotation2 = lastAnimatedTargetRotation;
				if (rotation)
				{
					defaultLocalTargetRotation = QuaTools.RotationToLocalSpace(transform.rotation, rotation2);
				}
				if (position)
				{
					planePosition = Quaternion.Inverse(rotation2) * (transform.position - planeBone1.position);
				}
			}

			public void SetIKPosition()
			{
				ikPosition = transform.position;
			}

			public void MaintainRotation()
			{
				maintainRotation = transform.rotation;
			}

			public void SetToIKPosition()
			{
				transform.position = ikPosition;
			}

			public void FixToNode(IKSolverFullBody solver, float weight, IKSolver.Node fixNode = null)
			{
				if (fixNode == null)
				{
					fixNode = solver.GetNode(chainIndex, nodeIndex);
				}
				if (weight >= 1f)
				{
					transform.position = fixNode.solverPosition;
				}
				else
				{
					transform.position = Vector3.Lerp(transform.position, fixNode.solverPosition, weight);
				}
			}

			public Vector3 GetPlanePosition(IKSolverFullBody solver)
			{
				return solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition + GetTargetRotation(solver) * planePosition;
			}

			public void PositionToPlane(IKSolverFullBody solver)
			{
				transform.position = GetPlanePosition(solver);
			}

			public void RotateToPlane(IKSolverFullBody solver, float weight)
			{
				Quaternion quaternion = GetTargetRotation(solver) * defaultLocalTargetRotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void Swing(Vector3 swingTarget, float weight)
			{
				Swing(swingTarget, transform.position, weight);
			}

			public void Swing(Vector3 pos1, Vector3 pos2, float weight)
			{
				Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * localSwingAxis, pos1 - pos2) * transform.rotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void Twist(Vector3 twistDirection, Vector3 normalDirection, float weight)
			{
				Vector3.OrthoNormalize(ref normalDirection, ref twistDirection);
				Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * localTwistAxis, twistDirection) * transform.rotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void RotateToMaintain(float weight)
			{
				if (!(weight <= 0f))
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, maintainRotation, weight);
				}
			}

			public void RotateToEffector(IKSolverFullBody solver, float weight)
			{
				if (!isNodeBone)
				{
					return;
				}
				float num = weight * solver.GetNode(chainIndex, nodeIndex).effectorRotationWeight;
				if (!(num <= 0f))
				{
					if (num >= 1f)
					{
						transform.rotation = solver.GetNode(chainIndex, nodeIndex).solverRotation;
					}
					else
					{
						transform.rotation = Quaternion.Lerp(transform.rotation, solver.GetNode(chainIndex, nodeIndex).solverRotation, num);
					}
				}
			}

			private Quaternion GetTargetRotation(IKSolverFullBody solver)
			{
				Vector3 solverPosition = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition;
				Vector3 solverPosition2 = solver.GetNode(plane2ChainIndex, plane2NodeIndex).solverPosition;
				Vector3 solverPosition3 = solver.GetNode(plane3ChainIndex, plane3NodeIndex).solverPosition;
				if (solverPosition == solverPosition3)
				{
					return Quaternion.identity;
				}
				return Quaternion.LookRotation(solverPosition2 - solverPosition, solverPosition3 - solverPosition);
			}
		}

		public virtual bool IsValid(IKSolver solver, ref string message)
		{
			return true;
		}

		public virtual void Initiate(IKSolverFullBody solver)
		{
		}

		protected bool BoneIsValid(Transform bone, IKSolver solver, ref string message, Warning.Logger logger = null)
		{
			if (bone == null)
			{
				message = "IKMappingLimb contains a null reference.";
				logger?.Invoke(message);
				return false;
			}
			if (solver.GetPoint(bone) == null)
			{
				message = "IKMappingLimb is referencing to a bone '" + bone.name + "' that does not excist in the Node Chain.";
				logger?.Invoke(message);
				return false;
			}
			return true;
		}

		protected Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			return pos2 + (pos1 - pos2).normalized * length;
		}
	}
	[Serializable]
	public class IKMappingBone : IKMapping
	{
		public Transform bone;

		[Range(0f, 1f)]
		public float maintainRotationWeight = 1f;

		private BoneMap boneMap = new BoneMap();

		public IKMappingBone()
		{
		}

		public IKMappingBone(Transform bone)
		{
			this.bone = bone;
		}

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			if (bone == null)
			{
				message = "IKMappingBone's bone is null.";
				return false;
			}
			return true;
		}

		public void StoreDefaultLocalState()
		{
			boneMap.StoreDefaultLocalState();
		}

		public void FixTransforms()
		{
			boneMap.FixTransform(position: false);
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (boneMap == null)
			{
				boneMap = new BoneMap();
			}
			boneMap.Initiate(bone, solver);
		}

		public void ReadPose()
		{
			boneMap.MaintainRotation();
		}

		public void WritePose(float solverWeight)
		{
			boneMap.RotateToMaintain(solverWeight * maintainRotationWeight);
		}
	}
	[Serializable]
	public class IKMappingLimb : IKMapping
	{
		[Serializable]
		public enum BoneMapType
		{
			Parent,
			Bone1,
			Bone2,
			Bone3
		}

		public Transform parentBone;

		public Transform bone1;

		public Transform bone2;

		public Transform bone3;

		[Range(0f, 1f)]
		public float maintainRotationWeight;

		[Range(0f, 1f)]
		public float weight = 1f;

		private BoneMap boneMapParent = new BoneMap();

		private BoneMap boneMap1 = new BoneMap();

		private BoneMap boneMap2 = new BoneMap();

		private BoneMap boneMap3 = new BoneMap();

		public IKMappingLimb()
		{
		}

		public IKMappingLimb(Transform bone1, Transform bone2, Transform bone3, Transform parentBone = null)
		{
			SetBones(bone1, bone2, bone3, parentBone);
		}

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone1, solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone2, solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone3, solver, ref message))
			{
				return false;
			}
			return true;
		}

		public BoneMap GetBoneMap(BoneMapType boneMap)
		{
			switch (boneMap)
			{
			case BoneMapType.Parent:
				if (parentBone == null)
				{
					Warning.Log("This limb does not have a parent (shoulder) bone", bone1);
				}
				return boneMapParent;
			case BoneMapType.Bone1:
				return boneMap1;
			case BoneMapType.Bone2:
				return boneMap2;
			default:
				return boneMap3;
			}
		}

		public void SetLimbOrientation(Vector3 upper, Vector3 lower)
		{
			boneMap1.defaultLocalTargetRotation = Quaternion.Inverse(Quaternion.Inverse(bone1.rotation) * Quaternion.LookRotation(bone2.position - bone1.position, bone1.rotation * -upper));
			boneMap2.defaultLocalTargetRotation = Quaternion.Inverse(Quaternion.Inverse(bone2.rotation) * Quaternion.LookRotation(bone3.position - bone2.position, bone2.rotation * -lower));
		}

		public void SetBones(Transform bone1, Transform bone2, Transform bone3, Transform parentBone = null)
		{
			this.bone1 = bone1;
			this.bone2 = bone2;
			this.bone3 = bone3;
			this.parentBone = parentBone;
		}

		public void StoreDefaultLocalState()
		{
			if (parentBone != null)
			{
				boneMapParent.StoreDefaultLocalState();
			}
			boneMap1.StoreDefaultLocalState();
			boneMap2.StoreDefaultLocalState();
			boneMap3.StoreDefaultLocalState();
		}

		public void FixTransforms()
		{
			if (parentBone != null)
			{
				boneMapParent.FixTransform(position: false);
			}
			boneMap1.FixTransform(position: true);
			boneMap2.FixTransform(position: false);
			boneMap3.FixTransform(position: false);
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (boneMapParent == null)
			{
				boneMapParent = new BoneMap();
			}
			if (boneMap1 == null)
			{
				boneMap1 = new BoneMap();
			}
			if (boneMap2 == null)
			{
				boneMap2 = new BoneMap();
			}
			if (boneMap3 == null)
			{
				boneMap3 = new BoneMap();
			}
			if (parentBone != null)
			{
				boneMapParent.Initiate(parentBone, solver);
			}
			boneMap1.Initiate(bone1, solver);
			boneMap2.Initiate(bone2, solver);
			boneMap3.Initiate(bone3, solver);
			boneMap1.SetPlane(solver, boneMap1.transform, boneMap2.transform, boneMap3.transform);
			boneMap2.SetPlane(solver, boneMap2.transform, boneMap3.transform, boneMap1.transform);
			if (parentBone != null)
			{
				boneMapParent.SetLocalSwingAxis(boneMap1);
			}
		}

		public void ReadPose()
		{
			boneMap1.UpdatePlane(rotation: true, position: true);
			boneMap2.UpdatePlane(rotation: true, position: false);
			weight = Mathf.Clamp(weight, 0f, 1f);
			boneMap3.MaintainRotation();
		}

		public void WritePose(IKSolverFullBody solver, bool fullBody)
		{
			if (weight <= 0f)
			{
				return;
			}
			if (fullBody)
			{
				if (parentBone != null)
				{
					boneMapParent.Swing(solver.GetNode(boneMap1.chainIndex, boneMap1.nodeIndex).solverPosition, weight);
				}
				boneMap1.FixToNode(solver, weight);
			}
			boneMap1.RotateToPlane(solver, weight);
			boneMap2.RotateToPlane(solver, weight);
			boneMap3.RotateToMaintain(maintainRotationWeight * weight * solver.IKPositionWeight);
			boneMap3.RotateToEffector(solver, weight);
		}
	}
	[Serializable]
	public class IKMappingSpine : IKMapping
	{
		public Transform[] spineBones;

		public Transform leftUpperArmBone;

		public Transform rightUpperArmBone;

		public Transform leftThighBone;

		public Transform rightThighBone;

		[Range(1f, 3f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float twistWeight = 1f;

		private int rootNodeIndex;

		private BoneMap[] spine = new BoneMap[0];

		private BoneMap leftUpperArm = new BoneMap();

		private BoneMap rightUpperArm = new BoneMap();

		private BoneMap leftThigh = new BoneMap();

		private BoneMap rightThigh = new BoneMap();

		private bool useFABRIK;

		public IKMappingSpine()
		{
		}

		public IKMappingSpine(Transform[] spineBones, Transform leftUpperArmBone, Transform rightUpperArmBone, Transform leftThighBone, Transform rightThighBone)
		{
			SetBones(spineBones, leftUpperArmBone, rightUpperArmBone, leftThighBone, rightThighBone);
		}

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			Transform[] array = spineBones;
			foreach (Transform transform in array)
			{
				if (transform == null)
				{
					message = "Spine bones contains a null reference.";
					return false;
				}
			}
			int num = 0;
			for (int j = 0; j < spineBones.Length; j++)
			{
				if (solver.GetPoint(spineBones[j]) != null)
				{
					num++;
				}
			}
			if (num == 0)
			{
				message = "IKMappingSpine does not contain any nodes.";
				return false;
			}
			if (leftUpperArmBone == null)
			{
				message = "IKMappingSpine is missing the left upper arm bone.";
				return false;
			}
			if (rightUpperArmBone == null)
			{
				message = "IKMappingSpine is missing the right upper arm bone.";
				return false;
			}
			if (leftThighBone == null)
			{
				message = "IKMappingSpine is missing the left thigh bone.";
				return false;
			}
			if (rightThighBone == null)
			{
				message = "IKMappingSpine is missing the right thigh bone.";
				return false;
			}
			if (solver.GetPoint(leftUpperArmBone) == null)
			{
				message = "Full Body IK is missing the left upper arm node.";
				return false;
			}
			if (solver.GetPoint(rightUpperArmBone) == null)
			{
				message = "Full Body IK is missing the right upper arm node.";
				return false;
			}
			if (solver.GetPoint(leftThighBone) == null)
			{
				message = "Full Body IK is missing the left thigh node.";
				return false;
			}
			if (solver.GetPoint(rightThighBone) == null)
			{
				message = "Full Body IK is missing the right thigh node.";
				return false;
			}
			return true;
		}

		public void SetBones(Transform[] spineBones, Transform leftUpperArmBone, Transform rightUpperArmBone, Transform leftThighBone, Transform rightThighBone)
		{
			this.spineBones = spineBones;
			this.leftUpperArmBone = leftUpperArmBone;
			this.rightUpperArmBone = rightUpperArmBone;
			this.leftThighBone = leftThighBone;
			this.rightThighBone = rightThighBone;
		}

		public void StoreDefaultLocalState()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].StoreDefaultLocalState();
			}
		}

		public void FixTransforms()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].FixTransform(i == 0 || i == spine.Length - 1);
			}
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (iterations <= 0)
			{
				iterations = 3;
			}
			if (spine == null || spine.Length != spineBones.Length)
			{
				spine = new BoneMap[spineBones.Length];
			}
			rootNodeIndex = -1;
			for (int i = 0; i < spineBones.Length; i++)
			{
				if (spine[i] == null)
				{
					spine[i] = new BoneMap();
				}
				spine[i].Initiate(spineBones[i], solver);
				if (spine[i].isNodeBone)
				{
					rootNodeIndex = i;
				}
			}
			if (leftUpperArm == null)
			{
				leftUpperArm = new BoneMap();
			}
			if (rightUpperArm == null)
			{
				rightUpperArm = new BoneMap();
			}
			if (leftThigh == null)
			{
				leftThigh = new BoneMap();
			}
			if (rightThigh == null)
			{
				rightThigh = new BoneMap();
			}
			leftUpperArm.Initiate(leftUpperArmBone, solver);
			rightUpperArm.Initiate(rightUpperArmBone, solver);
			leftThigh.Initiate(leftThighBone, solver);
			rightThigh.Initiate(rightThighBone, solver);
			for (int j = 0; j < spine.Length; j++)
			{
				spine[j].SetIKPosition();
			}
			spine[0].SetPlane(solver, spine[rootNodeIndex].transform, leftThigh.transform, rightThigh.transform);
			for (int k = 0; k < spine.Length - 1; k++)
			{
				spine[k].SetLength(spine[k + 1]);
				spine[k].SetLocalSwingAxis(spine[k + 1]);
				spine[k].SetLocalTwistAxis(leftUpperArm.transform.position - rightUpperArm.transform.position, spine[k + 1].transform.position - spine[k].transform.position);
			}
			spine[spine.Length - 1].SetPlane(solver, spine[rootNodeIndex].transform, leftUpperArm.transform, rightUpperArm.transform);
			spine[spine.Length - 1].SetLocalSwingAxis(leftUpperArm, rightUpperArm);
			useFABRIK = UseFABRIK();
		}

		private bool UseFABRIK()
		{
			if (spine.Length > 3)
			{
				return true;
			}
			if (rootNodeIndex != 1)
			{
				return true;
			}
			return false;
		}

		public void ReadPose()
		{
			spine[0].UpdatePlane(rotation: true, position: true);
			for (int i = 0; i < spine.Length - 1; i++)
			{
				spine[i].SetLength(spine[i + 1]);
				spine[i].SetLocalSwingAxis(spine[i + 1]);
				spine[i].SetLocalTwistAxis(leftUpperArm.transform.position - rightUpperArm.transform.position, spine[i + 1].transform.position - spine[i].transform.position);
			}
			spine[spine.Length - 1].UpdatePlane(rotation: true, position: true);
			spine[spine.Length - 1].SetLocalSwingAxis(leftUpperArm, rightUpperArm);
		}

		public void WritePose(IKSolverFullBody solver)
		{
			Vector3 planePosition = spine[0].GetPlanePosition(solver);
			Vector3 solverPosition = solver.GetNode(spine[rootNodeIndex].chainIndex, spine[rootNodeIndex].nodeIndex).solverPosition;
			Vector3 planePosition2 = spine[spine.Length - 1].GetPlanePosition(solver);
			if (useFABRIK)
			{
				Vector3 vector = solver.GetNode(spine[rootNodeIndex].chainIndex, spine[rootNodeIndex].nodeIndex).solverPosition - spine[rootNodeIndex].transform.position;
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].ikPosition = spine[i].transform.position + vector;
				}
				for (int j = 0; j < iterations; j++)
				{
					ForwardReach(planePosition2);
					BackwardReach(planePosition);
					spine[rootNodeIndex].ikPosition = solverPosition;
				}
			}
			else
			{
				spine[0].ikPosition = planePosition;
				spine[rootNodeIndex].ikPosition = solverPosition;
			}
			spine[spine.Length - 1].ikPosition = planePosition2;
			MapToSolverPositions(solver);
		}

		public void ForwardReach(Vector3 position)
		{
			spine[spineBones.Length - 1].ikPosition = position;
			for (int num = spine.Length - 2; num > -1; num--)
			{
				spine[num].ikPosition = SolveFABRIKJoint(spine[num].ikPosition, spine[num + 1].ikPosition, spine[num].length);
			}
		}

		private void BackwardReach(Vector3 position)
		{
			spine[0].ikPosition = position;
			for (int i = 1; i < spine.Length; i++)
			{
				spine[i].ikPosition = SolveFABRIKJoint(spine[i].ikPosition, spine[i - 1].ikPosition, spine[i - 1].length);
			}
		}

		private void MapToSolverPositions(IKSolverFullBody solver)
		{
			spine[0].SetToIKPosition();
			spine[0].RotateToPlane(solver, 1f);
			for (int i = 1; i < spine.Length - 1; i++)
			{
				spine[i].Swing(spine[i + 1].ikPosition, 1f);
				if (twistWeight > 0f)
				{
					float num = (float)i / ((float)spine.Length - 2f);
					Vector3 solverPosition = solver.GetNode(leftUpperArm.chainIndex, leftUpperArm.nodeIndex).solverPosition;
					Vector3 solverPosition2 = solver.GetNode(rightUpperArm.chainIndex, rightUpperArm.nodeIndex).solverPosition;
					spine[i].Twist(solverPosition - solverPosition2, spine[i + 1].ikPosition - spine[i].transform.position, num * twistWeight);
				}
			}
			spine[spine.Length - 1].SetToIKPosition();
			spine[spine.Length - 1].RotateToPlane(solver, 1f);
		}
	}
	[Serializable]
	public abstract class IKSolver
	{
		[Serializable]
		public class Point
		{
			public Transform transform;

			[Range(0f, 1f)]
			public float weight = 1f;

			public Vector3 solverPosition;

			public Quaternion solverRotation = Quaternion.identity;

			public Vector3 defaultLocalPosition;

			public Quaternion defaultLocalRotation;

			public void StoreDefaultLocalState()
			{
				defaultLocalPosition = transform.localPosition;
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransform()
			{
				if (transform.localPosition != defaultLocalPosition)
				{
					transform.localPosition = defaultLocalPosition;
				}
				if (transform.localRotation != defaultLocalRotation)
				{
					transform.localRotation = defaultLocalRotation;
				}
			}

			public void UpdateSolverPosition()
			{
				solverPosition = transform.position;
			}

			public void UpdateSolverLocalPosition()
			{
				solverPosition = transform.localPosition;
			}

			public void UpdateSolverState()
			{
				solverPosition = transform.position;
				solverRotation = transform.rotation;
			}

			public void UpdateSolverLocalState()
			{
				solverPosition = transform.localPosition;
				solverRotation = transform.localRotation;
			}
		}

		[Serializable]
		public class Bone : Point
		{
			public float length;

			public float sqrMag;

			public Vector3 axis = -Vector3.right;

			private RotationLimit _rotationLimit;

			private bool isLimited = true;

			public RotationLimit rotationLimit
			{
				get
				{
					if (!isLimited)
					{
						return null;
					}
					if (_rotationLimit == null)
					{
						_rotationLimit = transform.GetComponent<RotationLimit>();
					}
					isLimited = _rotationLimit != null;
					return _rotationLimit;
				}
				set
				{
					_rotationLimit = value;
					isLimited = value != null;
				}
			}

			public Bone()
			{
			}

			public Bone(Transform transform)
			{
				base.transform = transform;
			}

			public Bone(Transform transform, float weight)
			{
				base.transform = transform;
				base.weight = weight;
			}

			public void Swing(Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * axis, swingTarget - transform.position);
					if (weight >= 1f)
					{
						transform.rotation = quaternion * transform.rotation;
					}
					else
					{
						transform.rotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * transform.rotation;
					}
				}
			}

			public static void SolverSwing(Bone[] bones, int index, Vector3 swingTarget, float weight = 1f)
			{
				if (weight <= 0f)
				{
					return;
				}
				Quaternion quaternion = Quaternion.FromToRotation(bones[index].solverRotation * bones[index].axis, swingTarget - bones[index].solverPosition);
				if (weight >= 1f)
				{
					for (int i = index; i < bones.Length; i++)
					{
						bones[i].solverRotation = quaternion * bones[i].solverRotation;
					}
				}
				else
				{
					for (int j = index; j < bones.Length; j++)
					{
						bones[j].solverRotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * bones[j].solverRotation;
					}
				}
			}

			public void Swing2D(Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Vector3 vector = transform.rotation * axis;
					Vector3 vector2 = swingTarget - transform.position;
					float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
					float target = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
					transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, target) * weight, Vector3.back) * transform.rotation;
				}
			}

			public void SetToSolverPosition()
			{
				transform.position = solverPosition;
			}
		}

		[Serializable]
		public class Node : Point
		{
			public float length;

			public float effectorPositionWeight;

			public float effectorRotationWeight;

			public Vector3 offset;

			public Node()
			{
			}

			public Node(Transform transform)
			{
				base.transform = transform;
			}

			public Node(Transform transform, float weight)
			{
				base.transform = transform;
				base.weight = weight;
			}
		}

		public delegate void UpdateDelegate();

		public delegate void IterationDelegate(int i);

		[HideInInspector]
		public Vector3 IKPosition;

		[Tooltip("The positional or the master weight of the solver.")]
		[Range(0f, 1f)]
		public float IKPositionWeight = 1f;

		public UpdateDelegate OnPreInitiate;

		public UpdateDelegate OnPostInitiate;

		public UpdateDelegate OnPreUpdate;

		public UpdateDelegate OnPostUpdate;

		protected bool firstInitiation = true;

		[SerializeField]
		[HideInInspector]
		protected Transform root;

		public bool initiated { get; private set; }

		public bool IsValid()
		{
			string message = string.Empty;
			return IsValid(ref message);
		}

		public abstract bool IsValid(ref string message);

		public void Initiate(Transform root)
		{
			if (OnPreInitiate != null)
			{
				OnPreInitiate();
			}
			if (root == null)
			{
				Debug.LogError("Initiating IKSolver with null root Transform.");
			}
			this.root = root;
			initiated = false;
			string message = string.Empty;
			if (!IsValid(ref message))
			{
				Warning.Log(message, root);
				return;
			}
			OnInitiate();
			StoreDefaultLocalState();
			initiated = true;
			firstInitiation = false;
			if (OnPostInitiate != null)
			{
				OnPostInitiate();
			}
		}

		public void Update()
		{
			if (OnPreUpdate != null)
			{
				OnPreUpdate();
			}
			if (firstInitiation)
			{
				Initiate(root);
			}
			if (initiated)
			{
				OnUpdate();
				if (OnPostUpdate != null)
				{
					OnPostUpdate();
				}
			}
		}

		public virtual Vector3 GetIKPosition()
		{
			return IKPosition;
		}

		public void SetIKPosition(Vector3 position)
		{
			IKPosition = position;
		}

		public float GetIKPositionWeight()
		{
			return IKPositionWeight;
		}

		public void SetIKPositionWeight(float weight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public Transform GetRoot()
		{
			return root;
		}

		public abstract Point[] GetPoints();

		public abstract Point GetPoint(Transform transform);

		public abstract void FixTransforms();

		public abstract void StoreDefaultLocalState();

		protected abstract void OnInitiate();

		protected abstract void OnUpdate();

		protected void LogWarning(string message)
		{
			Warning.Log(message, root, logInEditMode: true);
		}

		public static Transform ContainsDuplicateBone(Bone[] bones)
		{
			for (int i = 0; i < bones.Length; i++)
			{
				for (int j = 0; j < bones.Length; j++)
				{
					if (i != j && bones[i].transform == bones[j].transform)
					{
						return bones[i].transform;
					}
				}
			}
			return null;
		}

		public static bool HierarchyIsValid(Bone[] bones)
		{
			for (int i = 1; i < bones.Length; i++)
			{
				if (!Hierarchy.IsAncestor(bones[i].transform, bones[i - 1].transform))
				{
					return false;
				}
			}
			return true;
		}

		protected static float PreSolveBones(ref Bone[] bones)
		{
			float num = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
			}
			for (int j = 0; j < bones.Length; j++)
			{
				if (j < bones.Length - 1)
				{
					bones[j].sqrMag = (bones[j + 1].solverPosition - bones[j].solverPosition).sqrMagnitude;
					bones[j].length = Mathf.Sqrt(bones[j].sqrMag);
					num += bones[j].length;
					bones[j].axis = Quaternion.Inverse(bones[j].solverRotation) * (bones[j + 1].solverPosition - bones[j].solverPosition);
				}
				else
				{
					bones[j].sqrMag = 0f;
					bones[j].length = 0f;
				}
			}
			return num;
		}
	}
	[Serializable]
	public class IKSolverAim : IKSolverHeuristic
	{
		public Transform transform;

		public Vector3 axis = Vector3.forward;

		public Vector3 poleAxis = Vector3.up;

		public Vector3 polePosition;

		[Range(0f, 1f)]
		public float poleWeight;

		public Transform poleTarget;

		[Range(0f, 1f)]
		public float clampWeight = 0.1f;

		[Range(0f, 2f)]
		public int clampSmoothing = 2;

		public IterationDelegate OnPreIteration;

		private float step;

		private Vector3 clampedIKPosition;

		private RotationLimit transformLimit;

		private Transform lastTransform;

		public Vector3 transformAxis => transform.rotation * axis;

		public Vector3 transformPoleAxis => transform.rotation * poleAxis;

		protected override int minBones => 1;

		protected override Vector3 localDirection => bones[0].transform.InverseTransformDirection(bones[bones.Length - 1].transform.forward);

		public float GetAngle()
		{
			return Vector3.Angle(transformAxis, IKPosition - transform.position);
		}

		protected override void OnInitiate()
		{
			if ((firstInitiation || !Application.isPlaying) && transform != null)
			{
				IKPosition = transform.position + transformAxis * 3f;
				polePosition = transform.position + transformPoleAxis * 3f;
			}
			for (int i = 0; i < bones.Length; i++)
			{
				if (bones[i].rotationLimit != null)
				{
					bones[i].rotationLimit.Disable();
				}
			}
			step = 1f / (float)bones.Length;
			if (Application.isPlaying)
			{
				axis = axis.normalized;
			}
		}

		protected override void OnUpdate()
		{
			if (axis == Vector3.zero)
			{
				if (!Warning.logged)
				{
					LogWarning("IKSolverAim axis is Vector3.zero.");
				}
				return;
			}
			if (poleAxis == Vector3.zero && poleWeight > 0f)
			{
				if (!Warning.logged)
				{
					LogWarning("IKSolverAim poleAxis is Vector3.zero.");
				}
				return;
			}
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (poleTarget != null)
			{
				polePosition = poleTarget.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			if (transform != lastTransform)
			{
				transformLimit = transform.GetComponent<RotationLimit>();
				if (transformLimit != null)
				{
					transformLimit.enabled = false;
				}
				lastTransform = transform;
			}
			if (transformLimit != null)
			{
				transformLimit.Apply();
			}
			if (transform == null)
			{
				if (!Warning.logged)
				{
					LogWarning("Aim Transform unassigned in Aim IK solver. Please Assign a Transform (lineal descendant to the last bone in the spine) that you want to be aimed at IKPosition");
				}
				return;
			}
			clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			clampedIKPosition = GetClampedIKPosition();
			Vector3 b = clampedIKPosition - transform.position;
			b = Vector3.Slerp(transformAxis * b.magnitude, b, IKPositionWeight);
			clampedIKPosition = transform.position + b;
			for (int i = 0; i < maxIterations && (i < 1 || !(tolerance > 0f) || !(GetAngle() < tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve();
			}
			lastLocalDirection = localDirection;
		}

		private void Solve()
		{
			for (int i = 0; i < bones.Length - 1; i++)
			{
				RotateToTarget(clampedIKPosition, bones[i], step * (float)(i + 1) * IKPositionWeight * bones[i].weight);
			}
			RotateToTarget(clampedIKPosition, bones[bones.Length - 1], IKPositionWeight * bones[bones.Length - 1].weight);
		}

		private Vector3 GetClampedIKPosition()
		{
			if (clampWeight <= 0f)
			{
				return IKPosition;
			}
			if (clampWeight >= 1f)
			{
				return transform.position + transformAxis * (IKPosition - transform.position).magnitude;
			}
			float num = Vector3.Angle(transformAxis, IKPosition - transform.position);
			float num2 = 1f - num / 180f;
			float num3 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f));
			float num4 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(num2 / clampWeight, 0f, 1f));
			for (int i = 0; i < clampSmoothing; i++)
			{
				float f = num4 * (float)Math.PI * 0.5f;
				num4 = Mathf.Sin(f);
			}
			return transform.position + Vector3.Slerp(transformAxis * 10f, IKPosition - transform.position, num4 * num3);
		}

		private void RotateToTarget(Vector3 targetPosition, Bone bone, float weight)
		{
			if (XY)
			{
				if (weight >= 0f)
				{
					Vector3 vector = transformAxis;
					Vector3 vector2 = targetPosition - transform.position;
					float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
					float num = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
					bone.transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, num), Vector3.back) * bone.transform.rotation;
				}
			}
			else
			{
				if (weight >= 0f)
				{
					Quaternion quaternion = Quaternion.FromToRotation(transformAxis, targetPosition - transform.position);
					if (weight >= 1f)
					{
						bone.transform.rotation = quaternion * bone.transform.rotation;
					}
					else
					{
						bone.transform.rotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * bone.transform.rotation;
					}
				}
				if (poleWeight > 0f)
				{
					Vector3 vector3 = polePosition - transform.position;
					Vector3 tangent = vector3;
					Vector3 normal = transformAxis;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					Quaternion b = Quaternion.FromToRotation(transformPoleAxis, tangent);
					bone.transform.rotation = Quaternion.Lerp(Quaternion.identity, b, weight * poleWeight) * bone.transform.rotation;
				}
			}
			if (useRotationLimits && bone.rotationLimit != null)
			{
				bone.rotationLimit.Apply();
			}
		}
	}
	[Serializable]
	public class IKSolverCCD : IKSolverHeuristic
	{
		public IterationDelegate OnPreIteration;

		public void FadeOutBoneWeights()
		{
			if (bones.Length >= 2)
			{
				bones[0].weight = 1f;
				float num = 1f / (float)(bones.Length - 1);
				for (int i = 1; i < bones.Length; i++)
				{
					bones[i].weight = num * (float)(bones.Length - 1 - i);
				}
			}
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				IKPosition = bones[bones.Length - 1].transform.position;
			}
			InitiateBones();
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			Vector3 vector = ((maxIterations <= 1) ? Vector3.zero : GetSingularityOffset());
			for (int i = 0; i < maxIterations && (!(vector == Vector3.zero) || i < 1 || !(tolerance > 0f) || !(base.positionOffset < tolerance * tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve(IKPosition + ((i != 0) ? Vector3.zero : vector));
			}
			lastLocalDirection = localDirection;
		}

		private void Solve(Vector3 targetPosition)
		{
			if (XY)
			{
				for (int num = bones.Length - 2; num > -1; num--)
				{
					float num2 = bones[num].weight * IKPositionWeight;
					if (num2 > 0f)
					{
						Vector3 vector = bones[bones.Length - 1].transform.position - bones[num].transform.position;
						Vector3 vector2 = targetPosition - bones[num].transform.position;
						float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
						float num3 = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
						bones[num].transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, num3) * num2, Vector3.back) * bones[num].transform.rotation;
					}
					if (useRotationLimits && bones[num].rotationLimit != null)
					{
						bones[num].rotationLimit.Apply();
					}
				}
				return;
			}
			for (int num4 = bones.Length - 2; num4 > -1; num4--)
			{
				float num5 = bones[num4].weight * IKPositionWeight;
				if (num5 > 0f)
				{
					Vector3 fromDirection = bones[bones.Length - 1].transform.position - bones[num4].transform.position;
					Vector3 toDirection = targetPosition - bones[num4].transform.position;
					Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection) * bones[num4].transform.rotation;
					if (num5 >= 1f)
					{
						bones[num4].transform.rotation = quaternion;
					}
					else
					{
						bones[num4].transform.rotation = Quaternion.Lerp(bones[num4].transform.rotation, quaternion, num5);
					}
				}
				if (useRotationLimits && bones[num4].rotationLimit != null)
				{
					bones[num4].rotationLimit.Apply();
				}
			}
		}
	}
	[Serializable]
	public class IKSolverFABRIK : IKSolverHeuristic
	{
		public IterationDelegate OnPreIteration;

		private bool[] limitedBones = new bool[0];

		private Vector3[] solverLocalPositions = new Vector3[0];

		protected override bool boneLengthCanBeZero => false;

		public void SolveForward(Vector3 position)
		{
			if (!base.initiated)
			{
				if (!Warning.logged)
				{
					LogWarning("Trying to solve uninitiated FABRIK chain.");
				}
			}
			else
			{
				OnPreSolve();
				ForwardReach(position);
			}
		}

		public void SolveBackward(Vector3 position)
		{
			if (!base.initiated)
			{
				if (!Warning.logged)
				{
					LogWarning("Trying to solve uninitiated FABRIK chain.");
				}
			}
			else
			{
				BackwardReach(position);
				OnPostSolve();
			}
		}

		public override Vector3 GetIKPosition()
		{
			if (target != null)
			{
				return target.position;
			}
			return IKPosition;
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				IKPosition = bones[bones.Length - 1].transform.position;
			}
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
			}
			limitedBones = new bool[bones.Length];
			solverLocalPositions = new Vector3[bones.Length];
			InitiateBones();
			for (int j = 0; j < bones.Length; j++)
			{
				ref Vector3 reference = ref solverLocalPositions[j];
				reference = Quaternion.Inverse(GetParentSolverRotation(j)) * (bones[j].transform.position - GetParentSolverPosition(j));
			}
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			OnPreSolve();
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			Vector3 vector = ((maxIterations <= 1) ? Vector3.zero : GetSingularityOffset());
			for (int i = 0; i < maxIterations && (!(vector == Vector3.zero) || i < 1 || !(tolerance > 0f) || !(base.positionOffset < tolerance * tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve(IKPosition + ((i != 0) ? Vector3.zero : vector));
			}
			OnPostSolve();
		}

		private Vector3 SolveJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			if (XY)
			{
				pos1.z = pos2.z;
			}
			return pos2 + (pos1 - pos2).normalized * length;
		}

		private void OnPreSolve()
		{
			chainLength = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
				if (i < bones.Length - 1)
				{
					bones[i].length = (bones[i].transform.position - bones[i + 1].transform.position).magnitude;
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (bones[i + 1].transform.position - bones[i].transform.position);
					chainLength += bones[i].length;
				}
				if (useRotationLimits)
				{
					ref Vector3 reference = ref solverLocalPositions[i];
					reference = Quaternion.Inverse(GetParentSolverRotation(i)) * (bones[i].transform.position - GetParentSolverPosition(i));
				}
			}
		}

		private void OnPostSolve()
		{
			if (!useRotationLimits)
			{
				MapToSolverPositions();
			}
			else
			{
				MapToSolverPositionsLimited();
			}
			lastLocalDirection = localDirection;
		}

		private void Solve(Vector3 targetPosition)
		{
			ForwardReach(targetPosition);
			BackwardReach(bones[0].transform.position);
		}

		private void ForwardReach(Vector3 position)
		{
			bones[bones.Length - 1].solverPosition = Vector3.Lerp(bones[bones.Length - 1].solverPosition, position, IKPositionWeight);
			for (int i = 0; i < limitedBones.Length; i++)
			{
				limitedBones[i] = false;
			}
			for (int num = bones.Length - 2; num > -1; num--)
			{
				bones[num].solverPosition = SolveJoint(bones[num].solverPosition, bones[num + 1].solverPosition, bones[num].length);
				LimitForward(num, num + 1);
			}
			LimitForward(0, 0);
		}

		private void SolverMove(int index, Vector3 offset)
		{
			for (int i = index; i < bones.Length; i++)
			{
				bones[i].solverPosition += offset;
			}
		}

		private void SolverRotate(int index, Quaternion rotation, bool recursive)
		{
			for (int i = index; i < bones.Length; i++)
			{
				bones[i].solverRotation = rotation * bones[i].solverRotation;
				if (!recursive)
				{
					break;
				}
			}
		}

		private void SolverRotateChildren(int index, Quaternion rotation)
		{
			for (int i = index + 1; i < bones.Length; i++)
			{
				bones[i].solverRotation = rotation * bones[i].solverRotation;
			}
		}

		private void SolverMoveChildrenAroundPoint(int index, Quaternion rotation)
		{
			for (int i = index + 1; i < bones.Length; i++)
			{
				Vector3 vector = bones[i].solverPosition - bones[index].solverPosition;
				bones[i].solverPosition = bones[index].solverPosition + rotation * vector;
			}
		}

		private Quaternion GetParentSolverRotation(int index)
		{
			if (index > 0)
			{
				return bones[index - 1].solverRotation;
			}
			if (bones[0].transform.parent == null)
			{
				return Quaternion.identity;
			}
			return bones[0].transform.parent.rotation;
		}

		private Vector3 GetParentSolverPosition(int index)
		{
			if (index > 0)
			{
				return bones[index - 1].solverPosition;
			}
			if (bones[0].transform.parent == null)
			{
				return Vector3.zero;
			}
			return bones[0].transform.parent.position;
		}

		private Quaternion GetLimitedRotation(int index, Quaternion q, out bool changed)
		{
			changed = false;
			Quaternion parentSolverRotation = GetParentSolverRotation(index);
			Quaternion localRotation = Quaternion.Inverse(parentSolverRotation) * q;
			Quaternion limitedLocalRotation = bones[index].rotationLimit.GetLimitedLocalRotation(localRotation, out changed);
			if (!changed)
			{
				return q;
			}
			return parentSolverRotation * limitedLocalRotation;
		}

		private void LimitForward(int rotateBone, int limitBone)
		{
			if (!useRotationLimits || bones[limitBone].rotationLimit == null)
			{
				return;
			}
			Vector3 solverPosition = bones[bones.Length - 1].solverPosition;
			for (int i = rotateBone; i < bones.Length - 1 && !limitedBones[i]; i++)
			{
				Quaternion rotation = Quaternion.FromToRotation(bones[i].solverRotation * bones[i].axis, bones[i + 1].solverPosition - bones[i].solverPosition);
				SolverRotate(i, rotation, recursive: false);
			}
			bool changed = false;
			Quaternion limitedRotation = GetLimitedRotation(limitBone, bones[limitBone].solverRotation, out changed);
			if (changed)
			{
				if (limitBone < bones.Length - 1)
				{
					Quaternion rotation2 = QuaTools.FromToRotation(bones[limitBone].solverRotation, limitedRotation);
					bones[limitBone].solverRotation = limitedRotation;
					SolverRotateChildren(limitBone, rotation2);
					SolverMoveChildrenAroundPoint(limitBone, rotation2);
					Quaternion rotation3 = Quaternion.FromToRotation(bones[bones.Length - 1].solverPosition - bones[rotateBone].solverPosition, solverPosition - bones[rotateBone].solverPosition);
					SolverRotate(rotateBone, rotation3, recursive: true);
					SolverMoveChildrenAroundPoint(rotateBone, rotation3);
					SolverMove(rotateBone, solverPosition - bones[bones.Length - 1].solverPosition);
				}
				else
				{
					bones[limitBone].solverRotation = limitedRotation;
				}
			}
			limitedBones[limitBone] = true;
		}

		private void BackwardReach(Vector3 position)
		{
			if (useRotationLimits)
			{
				BackwardReachLimited(position);
			}
			else
			{
				BackwardReachUnlimited(position);
			}
		}

		private void BackwardReachUnlimited(Vector3 position)
		{
			bones[0].solverPosition = position;
			for (int i = 1; i < bones.Length; i++)
			{
				bones[i].solverPosition = SolveJoint(bones[i].solverPosition, bones[i - 1].solverPosition, bones[i - 1].length);
			}
		}

		private void BackwardReachLimited(Vector3 position)
		{
			bones[0].solverPosition = position;
			for (int i = 0; i < bones.Length - 1; i++)
			{
				Vector3 vector = SolveJoint(bones[i + 1].solverPosition, bones[i].solverPosition, bones[i].length);
				Quaternion quaternion = Quaternion.FromToRotation(bones[i].solverRotation * bones[i].axis, vector - bones[i].solverPosition);
				Quaternion quaternion2 = quaternion * bones[i].solverRotation;
				if (bones[i].rotationLimit != null)
				{
					bool changed = false;
					quaternion2 = GetLimitedRotation(i, quaternion2, out changed);
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[i].solverRotation, quaternion2);
				bones[i].solverRotation = quaternion2;
				SolverRotateChildren(i, rotation);
				bones[i + 1].solverPosition = bones[i].solverPosition + bones[i].solverRotation * solverLocalPositions[i + 1];
			}
			for (int j = 0; j < bones.Length; j++)
			{
				bones[j].solverRotation = Quaternion.LookRotation(bones[j].solverRotation * Vector3.forward, bones[j].solverRotation * Vector3.up);
			}
		}

		private void MapToSolverPositions()
		{
			bones[0].transform.position = bones[0].solverPosition;
			for (int i = 0; i < bones.Length - 1; i++)
			{
				if (XY)
				{
					bones[i].Swing2D(bones[i + 1].solverPosition);
				}
				else
				{
					bones[i].Swing(bones[i + 1].solverPosition);
				}
			}
		}

		private void MapToSolverPositionsLimited()
		{
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].transform.position = bones[i].solverPosition;
				if (i < bones.Length - 1)
				{
					bones[i].transform.rotation = bones[i].solverRotation;
				}
			}
		}
	}
	[Serializable]
	public class IKSolverFABRIKRoot : IKSolver
	{
		public int iterations = 4;

		[Range(0f, 1f)]
		public float rootPin;

		public FABRIKChain[] chains = new FABRIKChain[0];

		private bool zeroWeightApplied;

		private bool[] isRoot;

		private Vector3 rootDefaultPosition;

		public override bool IsValid(ref string message)
		{
			if (chains.Length == 0)
			{
				message = "IKSolverFABRIKRoot contains no chains.";
				return false;
			}
			FABRIKChain[] array = chains;
			foreach (FABRIKChain fABRIKChain in array)
			{
				if (!fABRIKChain.IsValid(ref message))
				{
					return false;
				}
			}
			for (int j = 0; j < chains.Length; j++)
			{
				for (int k = 0; k < chains.Length; k++)
				{
					if (j != k && chains[j].ik == chains[k].ik)
					{
						message = chains[j].ik.name + " is represented more than once in IKSolverFABRIKRoot chain.";
						return false;
					}
				}
			}
			for (int l = 0; l < chains.Length; l++)
			{
				for (int m = 0; m < chains[l].children.Length; m++)
				{
					int num = chains[l].children[m];
					if (num < 0)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index is < 0.";
						return false;
					}
					if (num == l)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index is referencing to itself.";
						return false;
					}
					if (num >= chains.Length)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index > number of chains";
						return false;
					}
					for (int n = 0; n < chains.Length; n++)
					{
						if (num != n)
						{
							continue;
						}
						for (int num2 = 0; num2 < chains[n].children.Length; num2++)
						{
							if (chains[n].children[num2] == l)
							{
								message = "Circular parenting. " + chains[n].ik.name + " already has " + chains[l].ik.name + " listed as it's child.";
								return false;
							}
						}
					}
					for (int num3 = 0; num3 < chains[l].children.Length; num3++)
					{
						if (m != num3 && chains[l].children[num3] == num)
						{
							message = "Chain number " + num + " is represented more than once in the children of " + chains[l].ik.name;
							return false;
						}
					}
				}
			}
			return true;
		}

		public override void StoreDefaultLocalState()
		{
			rootDefaultPosition = root.localPosition;
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			root.localPosition = rootDefaultPosition;
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.FixTransforms();
			}
		}

		protected override void OnInitiate()
		{
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].Initiate();
			}
			isRoot = new bool[chains.Length];
			for (int j = 0; j < chains.Length; j++)
			{
				isRoot[j] = IsRoot(j);
			}
		}

		private bool IsRoot(int index)
		{
			for (int i = 0; i < chains.Length; i++)
			{
				for (int j = 0; j < chains[i].children.Length; j++)
				{
					if (chains[i].children[j] == index)
					{
						return false;
					}
				}
			}
			return true;
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f && zeroWeightApplied)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.IKPositionWeight = IKPositionWeight;
			}
			if (IKPositionWeight <= 0f)
			{
				zeroWeightApplied = true;
				return;
			}
			zeroWeightApplied = false;
			for (int j = 0; j < iterations; j++)
			{
				for (int k = 0; k < chains.Length; k++)
				{
					if (isRoot[k])
					{
						chains[k].Stage1(chains);
					}
				}
				Vector3 centroid = GetCentroid();
				root.position = centroid;
				for (int l = 0; l < chains.Length; l++)
				{
					if (isRoot[l])
					{
						chains[l].Stage2(centroid, chains);
					}
				}
			}
		}

		public override Point[] GetPoints()
		{
			Point[] array = new Point[0];
			for (int i = 0; i < chains.Length; i++)
			{
				AddPointsToArray(ref array, chains[i]);
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			Point point = null;
			for (int i = 0; i < chains.Length; i++)
			{
				point = chains[i].ik.solver.GetPoint(transform);
				if (point != null)
				{
					return point;
				}
			}
			return null;
		}

		private void AddPointsToArray(ref Point[] array, FABRIKChain chain)
		{
			Point[] points = chain.ik.solver.GetPoints();
			Array.Resize(ref array, array.Length + points.Length);
			int num = 0;
			for (int i = array.Length - points.Length; i < array.Length; i++)
			{
				array[i] = points[num];
				num++;
			}
		}

		private Vector3 GetCentroid()
		{
			Vector3 position = root.position;
			if (rootPin >= 1f)
			{
				return position;
			}
			float num = 0f;
			for (int i = 0; i < chains.Length; i++)
			{
				if (isRoot[i])
				{
					num += chains[i].pull;
				}
			}
			for (int j = 0; j < chains.Length; j++)
			{
				if (isRoot[j] && num > 0f)
				{
					position += (chains[j].ik.solver.bones[0].solverPosition - root.position) * (chains[j].pull / Mathf.Clamp(num, 1f, num));
				}
			}
			return Vector3.Lerp(position, root.position, rootPin);
		}
	}
	[Serializable]
	public class IKSolverFullBody : IKSolver
	{
		[Range(0f, 10f)]
		public int iterations = 4;

		public FBIKChain[] chain = new FBIKChain[0];

		public IKEffector[] effectors = new IKEffector[0];

		public IKMappingSpine spineMapping = new IKMappingSpine();

		public IKMappingBone[] boneMappings = new IKMappingBone[0];

		public IKMappingLimb[] limbMappings = new IKMappingLimb[0];

		public bool FABRIKPass = true;

		public UpdateDelegate OnPreRead;

		public UpdateDelegate OnPreSolve;

		public IterationDelegate OnPreIteration;

		public IterationDelegate OnPostIteration;

		public UpdateDelegate OnPreBend;

		public UpdateDelegate OnPostSolve;

		public UpdateDelegate OnStoreDefaultLocalState;

		public UpdateDelegate OnFixTransforms;

		public IKEffector GetEffector(Transform t)
		{
			for (int i = 0; i < effectors.Length; i++)
			{
				if (effectors[i].bone == t)
				{
					return effectors[i];
				}
			}
			return null;
		}

		public FBIKChain GetChain(Transform transform)
		{
			int chainIndex = GetChainIndex(transform);
			if (chainIndex == -1)
			{
				return null;
			}
			return chain[chainIndex];
		}

		public int GetChainIndex(Transform transform)
		{
			for (int i = 0; i < chain.Length; i++)
			{
				for (int j = 0; j < chain[i].nodes.Length; j++)
				{
					if (chain[i].nodes[j].transform == transform)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public Node GetNode(int chainIndex, int nodeIndex)
		{
			return chain[chainIndex].nodes[nodeIndex];
		}

		public void GetChainAndNodeIndexes(Transform transform, out int chainIndex, out int nodeIndex)
		{
			chainIndex = GetChainIndex(transform);
			if (chainIndex == -1)
			{
				nodeIndex = -1;
			}
			else
			{
				nodeIndex = chain[chainIndex].GetNodeIndex(transform);
			}
		}

		public override Point[] GetPoints()
		{
			int num = 0;
			for (int i = 0; i < chain.Length; i++)
			{
				num += chain[i].nodes.Length;
			}
			Point[] array = new Point[num];
			int num2 = 0;
			for (int j = 0; j < chain.Length; j++)
			{
				for (int k = 0; k < chain[j].nodes.Length; k++)
				{
					array[num2] = chain[j].nodes[k];
				}
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			for (int i = 0; i < chain.Length; i++)
			{
				for (int j = 0; j < chain[i].nodes.Length; j++)
				{
					if (chain[i].nodes[j].transform == transform)
					{
						return chain[i].nodes[j];
					}
				}
			}
			return null;
		}

		public override bool IsValid(ref string message)
		{
			if (chain == null)
			{
				message = "FBIK chain is null, can't initiate solver.";
				return false;
			}
			if (chain.Length == 0)
			{
				message = "FBIK chain length is 0, can't initiate solver.";
				return false;
			}
			for (int i = 0; i < chain.Length; i++)
			{
				if (!chain[i].IsValid(ref message))
				{
					return false;
				}
			}
			IKEffector[] array = effectors;
			foreach (IKEffector iKEffector in array)
			{
				if (!iKEffector.IsValid(this, ref message))
				{
					return false;
				}
			}
			if (!spineMapping.IsValid(this, ref message))
			{
				return false;
			}
			IKMappingLimb[] array2 = limbMappings;
			foreach (IKMappingLimb iKMappingLimb in array2)
			{
				if (!iKMappingLimb.IsValid(this, ref message))
				{
					return false;
				}
			}
			IKMappingBone[] array3 = boneMappings;
			foreach (IKMappingBone iKMappingBone in array3)
			{
				if (!iKMappingBone.IsValid(this, ref message))
				{
					return false;
				}
			}
			return true;
		}

		public override void StoreDefaultLocalState()
		{
			spineMapping.StoreDefaultLocalState();
			for (int i = 0; i < limbMappings.Length; i++)
			{
				limbMappings[i].StoreDefaultLocalState();
			}
			for (int j = 0; j < boneMappings.Length; j++)
			{
				boneMappings[j].StoreDefaultLocalState();
			}
			if (OnStoreDefaultLocalState != null)
			{
				OnStoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				spineMapping.FixTransforms();
				for (int i = 0; i < limbMappings.Length; i++)
				{
					limbMappings[i].FixTransforms();
				}
				for (int j = 0; j < boneMappings.Length; j++)
				{
					boneMappings[j].FixTransforms();
				}
				if (OnFixTransforms != null)
				{
					OnFixTransforms();
				}
			}
		}

		protected override void OnInitiate()
		{
			for (int i = 0; i < chain.Length; i++)
			{
				chain[i].Initiate(this);
			}
			IKEffector[] array = effectors;
			foreach (IKEffector iKEffector in array)
			{
				iKEffector.Initiate(this);
			}
			spineMapping.Initiate(this);
			IKMappingBone[] array2 = boneMappings;
			foreach (IKMappingBone iKMappingBone in array2)
			{
				iKMappingBone.Initiate(this);
			}
			IKMappingLimb[] array3 = limbMappings;
			foreach (IKMappingLimb iKMappingLimb in array3)
			{
				iKMappingLimb.Initiate(this);
			}
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				for (int i = 0; i < effectors.Length; i++)
				{
					effectors[i].positionOffset = Vector3.zero;
				}
			}
			else if (chain.Length != 0)
			{
				IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
				if (OnPreRead != null)
				{
					OnPreRead();
				}
				ReadPose();
				if (OnPreSolve != null)
				{
					OnPreSolve();
				}
				Solve();
				if (OnPostSolve != null)
				{
					OnPostSolve();
				}
				WritePose();
				for (int j = 0; j < effectors.Length; j++)
				{
					effectors[j].OnPostWrite();
				}
			}
		}

		protected virtual void ReadPose()
		{
			for (int i = 0; i < chain.Length; i++)
			{
				if (chain[i].bendConstraint.initiated)
				{
					chain[i].bendConstraint.LimitBend(IKPositionWeight, GetEffector(chain[i].nodes[2].transform).positionWeight);
				}
			}
			for (int j = 0; j < effectors.Length; j++)
			{
				effectors[j].ResetOffset(this);
			}
			for (int k = 0; k < effectors.Length; k++)
			{
				effectors[k].OnPreSolve(this);
			}
			for (int l = 0; l < chain.Length; l++)
			{
				chain[l].ReadPose(this, iterations > 0);
			}
			if (iterations > 0)
			{
				spineMapping.ReadPose();
				for (int m = 0; m < boneMappings.Length; m++)
				{
					boneMappings[m].ReadPose();
				}
			}
			for (int n = 0; n < limbMappings.Length; n++)
			{
				limbMappings[n].ReadPose();
			}
		}

		protected virtual void Solve()
		{
			if (iterations > 0)
			{
				for (int i = 0; i < ((!FABRIKPass) ? 1 : iterations); i++)
				{
					if (OnPreIteration != null)
					{
						OnPreIteration(i);
					}
					for (int j = 0; j < effectors.Length; j++)
					{
						if (effectors[j].isEndEffector)
						{
							effectors[j].Update(this);
						}
					}
					if (FABRIKPass)
					{
						chain[0].Push(this);
						if (FABRIKPass)
						{
							chain[0].Reach(this);
						}
						for (int k = 0; k < effectors.Length; k++)
						{
							if (!effectors[k].isEndEffector)
							{
								effectors[k].Update(this);
							}
						}
					}
					chain[0].SolveTrigonometric(this);
					if (FABRIKPass)
					{
						chain[0].Stage1(this);
						for (int l = 0; l < effectors.Length; l++)
						{
							if (!effectors[l].isEndEffector)
							{
								effectors[l].Update(this);
							}
						}
						chain[0].Stage2(this, chain[0].nodes[0].solverPosition);
					}
					if (OnPostIteration != null)
					{
						OnPostIteration(i);
					}
				}
			}
			if (OnPreBend != null)
			{
				OnPreBend();
			}
			for (int m = 0; m < effectors.Length; m++)
			{
				if (effectors[m].isEndEffector)
				{
					effectors[m].Update(this);
				}
			}
			ApplyBendConstraints();
		}

		protected virtual void ApplyBendConstraints()
		{
			chain[0].SolveTrigonometric(this, calculateBendDirection: true);
		}

		protected virtual void WritePose()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			if (iterations > 0)
			{
				spineMapping.WritePose(this);
				for (int i = 0; i < boneMappings.Length; i++)
				{
					boneMappings[i].WritePose(IKPositionWeight);
				}
			}
			for (int j = 0; j < limbMappings.Length; j++)
			{
				limbMappings[j].WritePose(this, iterations > 0);
			}
		}
	}
	[Serializable]
	public enum FullBodyBipedEffector
	{
		Body,
		LeftShoulder,
		RightShoulder,
		LeftThigh,
		RightThigh,
		LeftHand,
		RightHand,
		LeftFoot,
		RightFoot
	}
	[Serializable]
	public enum FullBodyBipedChain
	{
		LeftArm,
		RightArm,
		LeftLeg,
		RightLeg
	}
	[Serializable]
	public class IKSolverFullBodyBiped : IKSolverFullBody
	{
		public Transform rootNode;

		[Range(0f, 1f)]
		public float spineStiffness = 0.5f;

		[Range(-1f, 1f)]
		public float pullBodyVertical = 0.5f;

		[Range(-1f, 1f)]
		public float pullBodyHorizontal;

		private Vector3 offset;

		public IKEffector bodyEffector => GetEffector(FullBodyBipedEffector.Body);

		public IKEffector leftShoulderEffector => GetEffector(FullBodyBipedEffector.LeftShoulder);

		public IKEffector rightShoulderEffector => GetEffector(FullBodyBipedEffector.RightShoulder);

		public IKEffector leftThighEffector => GetEffector(FullBodyBipedEffector.LeftThigh);

		public IKEffector rightThighEffector => GetEffector(FullBodyBipedEffector.RightThigh);

		public IKEffector leftHandEffector => GetEffector(FullBodyBipedEffector.LeftHand);

		public IKEffector rightHandEffector => GetEffector(FullBodyBipedEffector.RightHand);

		public IKEffector leftFootEffector => GetEffector(FullBodyBipedEffector.LeftFoot);

		public IKEffector rightFootEffector => GetEffector(FullBodyBipedEffector.RightFoot);

		public FBIKChain leftArmChain => chain[1];

		public FBIKChain rightArmChain => chain[2];

		public FBIKChain leftLegChain => chain[3];

		public FBIKChain rightLegChain => chain[4];

		public IKMappingLimb leftArmMapping => limbMappings[0];

		public IKMappingLimb rightArmMapping => limbMappings[1];

		public IKMappingLimb leftLegMapping => limbMappings[2];

		public IKMappingLimb rightLegMapping => limbMappings[3];

		public IKMappingBone headMapping => boneMappings[0];

		public Vector3 pullBodyOffset { get; private set; }

		public void SetChainWeights(FullBodyBipedChain c, float pull, float reach = 0f)
		{
			GetChain(c).pull = pull;
			GetChain(c).reach = reach;
		}

		public void SetEffectorWeights(FullBodyBipedEffector effector, float positionWeight, float rotationWeight)
		{
			GetEffector(effector).positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			GetEffector(effector).rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
		}

		public FBIKChain GetChain(FullBodyBipedChain c)
		{
			return c switch
			{
				FullBodyBipedChain.LeftArm => chain[1], 
				FullBodyBipedChain.RightArm => chain[2], 
				FullBodyBipedChain.LeftLeg => chain[3], 
				FullBodyBipedChain.RightLeg => chain[4], 
				_ => null, 
			};
		}

		public FBIKChain GetChain(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.Body => chain[0], 
				FullBodyBipedEffector.LeftShoulder => chain[1], 
				FullBodyBipedEffector.RightShoulder => chain[2], 
				FullBodyBipedEffector.LeftThigh => chain[3], 
				FullBodyBipedEffector.RightThigh => chain[4], 
				FullBodyBipedEffector.LeftHand => chain[1], 
				FullBodyBipedEffector.RightHand => chain[2], 
				FullBodyBipedEffector.LeftFoot => chain[3], 
				FullBodyBipedEffector.RightFoot => chain[4], 
				_ => null, 
			};
		}

		public IKEffector GetEffector(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.Body => effectors[0], 
				FullBodyBipedEffector.LeftShoulder => effectors[1], 
				FullBodyBipedEffector.RightShoulder => effectors[2], 
				FullBodyBipedEffector.LeftThigh => effectors[3], 
				FullBodyBipedEffector.RightThigh => effectors[4], 
				FullBodyBipedEffector.LeftHand => effectors[5], 
				FullBodyBipedEffector.RightHand => effectors[6], 
				FullBodyBipedEffector.LeftFoot => effectors[7], 
				FullBodyBipedEffector.RightFoot => effectors[8], 
				_ => null, 
			};
		}

		public IKEffector GetEndEffector(FullBodyBipedChain c)
		{
			return c switch
			{
				FullBodyBipedChain.LeftArm => effectors[5], 
				FullBodyBipedChain.RightArm => effectors[6], 
				FullBodyBipedChain.LeftLeg => effectors[7], 
				FullBodyBipedChain.RightLeg => effectors[8], 
				_ => null, 
			};
		}

		public IKMappingLimb GetLimbMapping(FullBodyBipedChain chain)
		{
			return chain switch
			{
				FullBodyBipedChain.LeftArm => limbMappings[0], 
				FullBodyBipedChain.RightArm => limbMappings[1], 
				FullBodyBipedChain.LeftLeg => limbMappings[2], 
				FullBodyBipedChain.RightLeg => limbMappings[3], 
				_ => null, 
			};
		}

		public IKMappingLimb GetLimbMapping(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.LeftShoulder => limbMappings[0], 
				FullBodyBipedEffector.RightShoulder => limbMappings[1], 
				FullBodyBipedEffector.LeftThigh => limbMappings[2], 
				FullBodyBipedEffector.RightThigh => limbMappings[3], 
				FullBodyBipedEffector.LeftHand => limbMappings[0], 
				FullBodyBipedEffector.RightHand => limbMappings[1], 
				FullBodyBipedEffector.LeftFoot => limbMappings[2], 
				FullBodyBipedEffector.RightFoot => limbMappings[3], 
				_ => null, 
			};
		}

		public IKMappingSpine GetSpineMapping()
		{
			return spineMapping;
		}

		public IKMappingBone GetHeadMapping()
		{
			return boneMappings[0];
		}

		public IKConstraintBend GetBendConstraint(FullBodyBipedChain limb)
		{
			return limb switch
			{
				FullBodyBipedChain.LeftArm => chain[1].bendConstraint, 
				FullBodyBipedChain.RightArm => chain[2].bendConstraint, 
				FullBodyBipedChain.LeftLeg => chain[3].bendConstraint, 
				FullBodyBipedChain.RightLeg => chain[4].bendConstraint, 
				_ => null, 
			};
		}

		public override bool IsValid(ref string message)
		{
			if (!base.IsValid(ref message))
			{
				return false;
			}
			if (rootNode == null)
			{
				message = "Root Node bone is null. FBBIK will not initiate.";
				return false;
			}
			if (chain.Length != 5 || chain[0].nodes.Length != 1 || chain[1].nodes.Length != 3 || chain[2].nodes.Length != 3 || chain[3].nodes.Length != 3 || chain[4].nodes.Length != 3 || effectors.Length != 9 || limbMappings.Length != 4)
			{
				message = "Invalid FBBIK setup. Please right-click on the component header and select 'Reinitiate'.";
				return false;
			}
			return true;
		}

		public void SetToReferences(BipedReferences references, Transform rootNode = null)
		{
			root = references.root;
			if (rootNode == null)
			{
				rootNode = DetectRootNodeBone(references);
			}
			this.rootNode = rootNode;
			if (chain == null || chain.Length != 5)
			{
				chain = new FBIKChain[5];
			}
			for (int i = 0; i < chain.Length; i++)
			{
				if (chain[i] == null)
				{
					chain[i] = new FBIKChain();
				}
			}
			chain[0].pin = 0f;
			chain[0].SetNodes(rootNode);
			chain[0].children = new int[4] { 1, 2, 3, 4 };
			chain[1].SetNodes(references.leftUpperArm, references.leftForearm, references.leftHand);
			chain[2].SetNodes(references.rightUpperArm, references.rightForearm, references.rightHand);
			chain[3].SetNodes(references.leftThigh, references.leftCalf, references.leftFoot);
			chain[4].SetNodes(references.rightThigh, references.rightCalf, references.rightFoot);
			if (effectors.Length != 9)
			{
				effectors = new IKEffector[9]
				{
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector()
				};
			}
			effectors[0].bone = rootNode;
			effectors[0].childBones = new Transform[2] { references.leftThigh, references.rightThigh };
			effectors[1].bone = references.leftUpperArm;
			effectors[2].bone = references.rightUpperArm;
			effectors[3].bone = references.leftThigh;
			effectors[4].bone = references.rightThigh;
			effectors[5].bone = references.leftHand;
			effectors[6].bone = references.rightHand;
			effectors[7].bone = references.leftFoot;
			effectors[8].bone = references.rightFoot;
			effectors[5].planeBone1 = references.leftUpperArm;
			effectors[5].planeBone2 = references.rightUpperArm;
			effectors[5].planeBone3 = rootNode;
			effectors[6].planeBone1 = references.rightUpperArm;
			effectors[6].planeBone2 = references.leftUpperArm;
			effectors[6].planeBone3 = rootNode;
			effectors[7].planeBone1 = references.leftThigh;
			effectors[7].planeBone2 = references.rightThigh;
			effectors[7].planeBone3 = rootNode;
			effectors[8].planeBone1 = references.rightThigh;
			effectors[8].planeBone2 = references.leftThigh;
			effectors[8].planeBone3 = rootNode;
			chain[0].childConstraints = new FBIKChain.ChildConstraint[4]
			{
				new FBIKChain.ChildConstraint(references.leftUpperArm, references.rightThigh, 0f, 1f),
				new FBIKChain.ChildConstraint(references.rightUpperArm, references.leftThigh, 0f, 1f),
				new FBIKChain.ChildConstraint(references.leftUpperArm, references.rightUpperArm),
				new FBIKChain.ChildConstraint(references.leftThigh, references.rightThigh)
			};
			Transform[] array = new Transform[references.spine.Length + 1];
			array[0] = references.pelvis;
			for (int j = 0; j < references.spine.Length; j++)
			{
				array[j + 1] = references.spine[j];
			}
			if (spineMapping == null)
			{
				spineMapping = new IKMappingSpine();
				spineMapping.iterations = 3;
			}
			spineMapping.SetBones(array, references.leftUpperArm, references.rightUpperArm, references.leftThigh, references.rightThigh);
			int num = ((references.head != null) ? 1 : 0);
			if (boneMappings.Length != num)
			{
				boneMappings = new IKMappingBone[num];
				for (int k = 0; k < boneMappings.Length; k++)
				{
					boneMappings[k] = new IKMappingBone();
				}
				if (num == 1)
				{
					boneMappings[0].maintainRotationWeight = 0f;
				}
			}
			if (boneMappings.Length > 0)
			{
				boneMappings[0].bone = references.head;
			}
			if (limbMappings.Length != 4)
			{
				limbMappings = new IKMappingLimb[4]
				{
					new IKMappingLimb(),
					new IKMappingLimb(),
					new IKMappingLimb(),
					new IKMappingLimb()
				};
				limbMappings[2].maintainRotationWeight = 1f;
				limbMappings[3].maintainRotationWeight = 1f;
			}
			limbMappings[0].SetBones(references.leftUpperArm, references.leftForearm, references.leftHand, GetLeftClavicle(references));
			limbMappings[1].SetBones(references.rightUpperArm, references.rightForearm, references.rightHand, GetRightClavicle(references));
			limbMappings[2].SetBones(references.leftThigh, references.leftCalf, references.leftFoot);
			limbMappings[3].SetBones(references.rightThigh, references.rightCalf, references.rightFoot);
			if (Application.isPlaying)
			{
				Initiate(references.root);
			}
		}

		public static Transform DetectRootNodeBone(BipedReferences references)
		{
			if (!references.isFilled)
			{
				return null;
			}
			if (references.spine.Length < 1)
			{
				return null;
			}
			int num = references.spine.Length;
			if (num == 1)
			{
				return references.spine[0];
			}
			Vector3 vector = Vector3.Lerp(references.leftThigh.position, references.rightThigh.position, 0.5f);
			Vector3 vector2 = Vector3.Lerp(references.leftUpperArm.position, references.rightUpperArm.position, 0.5f);
			Vector3 onNormal = vector2 - vector;
			float magnitude = onNormal.magnitude;
			if (references.spine.Length < 2)
			{
				return references.spine[0];
			}
			int num2 = 0;
			for (int i = 1; i < num; i++)
			{
				Vector3 vector3 = references.spine[i].position - vector;
				Vector3 vector4 = Vector3.Project(vector3, onNormal);
				float num3 = Vector3.Dot(vector4.normalized, onNormal.normalized);
				if (num3 > 0f)
				{
					float num4 = vector4.magnitude / magnitude;
					if (num4 < 0.5f)
					{
						num2 = i;
					}
				}
			}
			return references.spine[num2];
		}

		public void SetLimbOrientations(BipedLimbOrientations o)
		{
			SetLimbOrientation(FullBodyBipedChain.LeftArm, o.leftArm);
			SetLimbOrientation(FullBodyBipedChain.RightArm, o.rightArm);
			SetLimbOrientation(FullBodyBipedChain.LeftLeg, o.leftLeg);
			SetLimbOrientation(FullBodyBipedChain.RightLeg, o.rightLeg);
		}

		private void SetLimbOrientation(FullBodyBipedChain chain, BipedLimbOrientations.LimbOrientation limbOrientation)
		{
			if (chain == FullBodyBipedChain.LeftArm || chain == FullBodyBipedChain.RightArm)
			{
				GetBendConstraint(chain).SetLimbOrientation(-limbOrientation.upperBoneForwardAxis, -limbOrientation.lowerBoneForwardAxis, -limbOrientation.lastBoneLeftAxis);
				GetLimbMapping(chain).SetLimbOrientation(-limbOrientation.upperBoneForwardAxis, -limbOrientation.lowerBoneForwardAxis);
			}
			else
			{
				GetBendConstraint(chain).SetLimbOrientation(limbOrientation.upperBoneForwardAxis, limbOrientation.lowerBoneForwardAxis, limbOrientation.lastBoneLeftAxis);
				GetLimbMapping(chain).SetLimbOrientation(limbOrientation.upperBoneForwardAxis, limbOrientation.lowerBoneForwardAxis);
			}
		}

		private static Transform GetLeftClavicle(BipedReferences references)
		{
			if (references.leftUpperArm == null)
			{
				return null;
			}
			if (!Contains(references.spine, references.leftUpperArm.parent))
			{
				return references.leftUpperArm.parent;
			}
			return null;
		}

		private static Transform GetRightClavicle(BipedReferences references)
		{
			if (references.rightUpperArm == null)
			{
				return null;
			}
			if (!Contains(references.spine, references.rightUpperArm.parent))
			{
				return references.rightUpperArm.parent;
			}
			return null;
		}

		private static bool Contains(Transform[] array, Transform transform)
		{
			foreach (Transform transform2 in array)
			{
				if (transform2 == transform)
				{
					return true;
				}
			}
			return false;
		}

		protected override void ReadPose()
		{
			for (int i = 0; i < effectors.Length; i++)
			{
				effectors[i].SetToTarget();
			}
			PullBody();
			float pushElasticity = Mathf.Clamp(1f - spineStiffness, 0f, 1f);
			chain[0].childConstraints[0].pushElasticity = pushElasticity;
			chain[0].childConstraints[1].pushElasticity = pushElasticity;
			base.ReadPose();
		}

		private void PullBody()
		{
			if (iterations >= 1 && (pullBodyVertical != 0f || pullBodyHorizontal != 0f))
			{
				Vector3 bodyOffset = GetBodyOffset();
				pullBodyOffset = V3Tools.ExtractVertical(bodyOffset, root.up, pullBodyVertical) + V3Tools.ExtractHorizontal(bodyOffset, root.up, pullBodyHorizontal);
				bodyEffector.positionOffset += pullBodyOffset;
			}
		}

		private Vector3 GetBodyOffset()
		{
			Vector3 vector = Vector3.zero + GetHandBodyPull(leftHandEffector, leftArmChain, Vector3.zero) * Mathf.Clamp(leftHandEffector.positionWeight, 0f, 1f);
			return vector + GetHandBodyPull(rightHandEffector, rightArmChain, vector) * Mathf.Clamp(rightHandEffector.positionWeight, 0f, 1f);
		}

		private Vector3 GetHandBodyPull(IKEffector effector, FBIKChain arm, Vector3 offset)
		{
			Vector3 vector = effector.position - (arm.nodes[0].transform.position + offset);
			float num = arm.nodes[0].length + arm.nodes[1].length;
			float magnitude = vector.magnitude;
			if (magnitude < num)
			{
				return Vector3.zero;
			}
			float num2 = magnitude - num;
			return vector / magnitude * num2;
		}

		protected override void ApplyBendConstraints()
		{
			if (iterations > 0)
			{
				chain[1].bendConstraint.rotationOffset = leftHandEffector.planeRotationOffset;
				chain[2].bendConstraint.rotationOffset = rightHandEffector.planeRotationOffset;
				chain[3].bendConstraint.rotationOffset = leftFootEffector.planeRotationOffset;
				chain[4].bendConstraint.rotationOffset = rightFootEffector.planeRotationOffset;
			}
			else
			{
				offset = Vector3.Lerp(effectors[0].positionOffset, effectors[0].position - (effectors[0].bone.position + effectors[0].positionOffset), effectors[0].positionWeight);
				for (int i = 0; i < 5; i++)
				{
					effectors[i].GetNode(this).solverPosition += offset;
				}
			}
			base.ApplyBendConstraints();
		}

		protected override void WritePose()
		{
			if (iterations == 0)
			{
				spineMapping.spineBones[0].position += offset;
			}
			base.WritePose();
		}
	}
	[Serializable]
	public class IKSolverHeuristic : IKSolver
	{
		public Transform target;

		public float tolerance;

		public int maxIterations = 4;

		public bool useRotationLimits = true;

		public bool XY;

		public Bone[] bones = new Bone[0];

		protected Vector3 lastLocalDirection;

		protected float chainLength;

		protected virtual int minBones => 2;

		protected virtual bool boneLengthCanBeZero => true;

		protected virtual bool allowCommonParent => false;

		protected virtual Vector3 localDirection => bones[0].transform.InverseTransformDirection(bones[bones.Length - 1].transform.position - bones[0].transform.position);

		protected float positionOffset => Vector3.SqrMagnitude(localDirection - lastLocalDirection);

		public bool SetChain(Transform[] hierarchy, Transform root)
		{
			if (bones == null || bones.Length != hierarchy.Length)
			{
				bones = new Bone[hierarchy.Length];
			}
			for (int i = 0; i < hierarchy.Length; i++)
			{
				if (bones[i] == null)
				{
					bones[i] = new Bone();
				}
				bones[i].transform = hierarchy[i];
			}
			Initiate(root);
			return base.initiated;
		}

		public void AddBone(Transform bone)
		{
			Transform[] array = new Transform[bones.Length + 1];
			for (int i = 0; i < bones.Length; i++)
			{
				array[i] = bones[i].transform;
			}
			array[array.Length - 1] = bone;
			SetChain(array, root);
		}

		public override void StoreDefaultLocalState()
		{
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				for (int i = 0; i < bones.Length; i++)
				{
					bones[i].FixTransform();
				}
			}
		}

		public override bool IsValid(ref string message)
		{
			if (bones.Length == 0)
			{
				message = "IK chain has no Bones.";
				return false;
			}
			if (bones.Length < minBones)
			{
				message = "IK chain has less than " + minBones + " Bones.";
				return false;
			}
			Bone[] array = bones;
			foreach (Bone bone in array)
			{
				if (bone.transform == null)
				{
					message = "One of the Bones is null.";
					return false;
				}
			}
			Transform transform = IKSolver.ContainsDuplicateBone(bones);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the Bones.";
				return false;
			}
			if (!allowCommonParent && !IKSolver.HierarchyIsValid(bones))
			{
				message = "Invalid bone hierarchy detected. IK requires for it's bones to be parented to each other in descending order.";
				return false;
			}
			if (!boneLengthCanBeZero)
			{
				for (int j = 0; j < bones.Length - 1; j++)
				{
					float magnitude = (bones[j].transform.position - bones[j + 1].transform.position).magnitude;
					if (magnitude == 0f)
					{
						message = "Bone " + j + " length is zero.";
						return false;
					}
				}
			}
			return true;
		}

		public override Point[] GetPoints()
		{
			return bones;
		}

		public override Point GetPoint(Transform transform)
		{
			for (int i = 0; i < bones.Length; i++)
			{
				if (bones[i].transform == transform)
				{
					return bones[i];
				}
			}
			return null;
		}

		protected override void OnInitiate()
		{
		}

		protected override void OnUpdate()
		{
		}

		protected void InitiateBones()
		{
			chainLength = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				if (i < bones.Length - 1)
				{
					bones[i].length = (bones[i].transform.position - bones[i + 1].transform.position).magnitude;
					chainLength += bones[i].length;
					Vector3 position = bones[i + 1].transform.position;
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (position - bones[i].transform.position);
					if (bones[i].rotationLimit != null)
					{
						if (XY && !(bones[i].rotationLimit is RotationLimitHinge))
						{
							Warning.Log("Only Hinge Rotation Limits should be used on 2D IK solvers.", bones[i].transform);
						}
						bones[i].rotationLimit.Disable();
					}
				}
				else
				{
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (bones[bones.Length - 1].transform.position - bones[0].transform.position);
				}
			}
		}

		protected Vector3 GetSingularityOffset()
		{
			if (!SingularityDetected())
			{
				return Vector3.zero;
			}
			Vector3 normalized = (IKPosition - bones[0].transform.position).normalized;
			Vector3 rhs = new Vector3(normalized.y, normalized.z, normalized.x);
			if (useRotationLimits && bones[bones.Length - 2].rotationLimit != null && bones[bones.Length - 2].rotationLimit is RotationLimitHinge)
			{
				rhs = bones[bones.Length - 2].transform.rotation * bones[bones.Length - 2].rotationLimit.axis;
			}
			return Vector3.Cross(normalized, rhs) * bones[bones.Length - 2].length * 0.5f;
		}

		private bool SingularityDetected()
		{
			if (!base.initiated)
			{
				return false;
			}
			Vector3 vector = bones[bones.Length - 1].transform.position - bones[0].transform.position;
			Vector3 vector2 = IKPosition - bones[0].transform.position;
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude < magnitude2)
			{
				return false;
			}
			if (magnitude < chainLength - bones[bones.Length - 2].length * 0.1f)
			{
				return false;
			}
			if (magnitude == 0f)
			{
				return false;
			}
			if (magnitude2 == 0f)
			{
				return false;
			}
			if (magnitude2 > magnitude)
			{
				return false;
			}
			float num = Vector3.Dot(vector / magnitude, vector2 / magnitude2);
			if (num < 0.999f)
			{
				return false;
			}
			return true;
		}
	}
	[Serializable]
	public class IKSolverLeg : IKSolver
	{
		[Range(0f, 1f)]
		public float IKRotationWeight = 1f;

		public Quaternion IKRotation = Quaternion.identity;

		public Point pelvis = new Point();

		public Point thigh = new Point();

		public Point calf = new Point();

		public Point foot = new Point();

		public Point toe = new Point();

		public IKSolverVR.Leg leg = new IKSolverVR.Leg();

		public Vector3 heelOffset;

		private Vector3[] positions = new Vector3[6];

		private Quaternion[] rotations = new Quaternion[6];

		public override bool IsValid(ref string message)
		{
			if (pelvis.transform == null || thigh.transform == null || calf.transform == null || foot.transform == null || toe.transform == null)
			{
				message = "Please assign all bone slots of the Leg IK solver.";
				return false;
			}
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(new Transform[5] { pelvis.transform, thigh.transform, calf.transform, foot.transform, toe.transform });
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the LegIK.";
				return false;
			}
			return true;
		}

		public bool SetChain(Transform pelvis, Transform thigh, Transform calf, Transform foot, Transform toe, Transform root)
		{
			this.pelvis.transform = pelvis;
			this.thigh.transform = thigh;
			this.calf.transform = calf;
			this.foot.transform = foot;
			this.toe.transform = toe;
			Initiate(root);
			return base.initiated;
		}

		public override Point[] GetPoints()
		{
			return new Point[5] { pelvis, thigh, calf, foot, toe };
		}

		public override Point GetPoint(Transform transform)
		{
			if (pelvis.transform == transform)
			{
				return pelvis;
			}
			if (thigh.transform == transform)
			{
				return thigh;
			}
			if (calf.transform == transform)
			{
				return calf;
			}
			if (foot.transform == transform)
			{
				return foot;
			}
			if (toe.transform == transform)
			{
				return toe;
			}
			return null;
		}

		public override void StoreDefaultLocalState()
		{
			thigh.StoreDefaultLocalState();
			calf.StoreDefaultLocalState();
			foot.StoreDefaultLocalState();
			toe.StoreDefaultLocalState();
		}

		public override void FixTransforms()
		{
			thigh.FixTransform();
			calf.FixTransform();
			foot.FixTransform();
			toe.FixTransform();
		}

		protected override void OnInitiate()
		{
			IKPosition = toe.transform.position;
			IKRotation = toe.transform.rotation;
			Read();
		}

		protected override void OnUpdate()
		{
			Read();
			Solve();
			Write();
		}

		private void Solve()
		{
			leg.heelPositionOffset += heelOffset;
			leg.PreSolve();
			leg.ApplyOffsets();
			leg.Solve();
			leg.ResetOffsets();
		}

		private void Read()
		{
			leg.IKPosition = IKPosition;
			leg.positionWeight = IKPositionWeight;
			leg.IKRotation = IKRotation;
			leg.rotationWeight = IKRotationWeight;
			ref Vector3 reference = ref positions[0];
			reference = root.position;
			ref Vector3 reference2 = ref positions[1];
			reference2 = pelvis.transform.position;
			ref Vector3 reference3 = ref positions[2];
			reference3 = thigh.transform.position;
			ref Vector3 reference4 = ref positions[3];
			reference4 = calf.transform.position;
			ref Vector3 reference5 = ref positions[4];
			reference5 = foot.transform.position;
			ref Vector3 reference6 = ref positions[5];
			reference6 = toe.transform.position;
			ref Quaternion reference7 = ref rotations[0];
			reference7 = root.rotation;
			ref Quaternion reference8 = ref rotations[1];
			reference8 = pelvis.transform.rotation;
			ref Quaternion reference9 = ref rotations[2];
			reference9 = thigh.transform.rotation;
			ref Quaternion reference10 = ref rotations[3];
			reference10 = calf.transform.rotation;
			ref Quaternion reference11 = ref rotations[4];
			reference11 = foot.transform.rotation;
			ref Quaternion reference12 = ref rotations[5];
			reference12 = toe.transform.rotation;
			leg.Read(positions, rotations, hasChest: false, hasNeck: false, hasShoulders: false, hasToes: true, 1, 2);
		}

		private void Write()
		{
			leg.Write(ref positions, ref rotations);
			thigh.transform.rotation = rotations[2];
			calf.transform.rotation = rotations[3];
			foot.transform.rotation = rotations[4];
			toe.transform.rotation = rotations[5];
		}
	}
	[Serializable]
	public class IKSolverLimb : IKSolverTrigonometric
	{
		[Serializable]
		public enum BendModifier
		{
			Animation,
			Target,
			Parent,
			Arm,
			Goal
		}

		[Serializable]
		public struct AxisDirection
		{
			public Vector3 direction;

			public Vector3 axis;

			public float dot;

			public AxisDirection(Vector3 direction, Vector3 axis)
			{
				this.direction = direction.normalized;
				this.axis = axis.normalized;
				dot = 0f;
			}
		}

		public AvatarIKGoal goal;

		public BendModifier bendModifier;

		[Range(0f, 1f)]
		public float maintainRotationWeight;

		[Range(0f, 1f)]
		public float bendModifierWeight = 1f;

		public Transform bendGoal;

		private bool maintainBendFor1Frame;

		private bool maintainRotationFor1Frame;

		private Quaternion defaultRootRotation;

		private Quaternion parentDefaultRotation;

		private Quaternion bone3RotationBeforeSolve;

		private Quaternion maintainRotation;

		private Quaternion bone3DefaultRotation;

		private Vector3 _bendNormal;

		private Vector3 animationNormal;

		private AxisDirection[] axisDirectionsLeft = new AxisDirection[4];

		private AxisDirection[] axisDirectionsRight = new AxisDirection[4];

		private AxisDirection[] axisDirections
		{
			get
			{
				if (goal == AvatarIKGoal.LeftHand)
				{
					return axisDirectionsLeft;
				}
				return axisDirectionsRight;
			}
		}

		public IKSolverLimb()
		{
		}

		public IKSolverLimb(AvatarIKGoal goal)
		{
			this.goal = goal;
		}

		public void MaintainRotation()
		{
			if (base.initiated)
			{
				maintainRotation = bone3.transform.rotation;
				maintainRotationFor1Frame = true;
			}
		}

		public void MaintainBend()
		{
			if (base.initiated)
			{
				animationNormal = bone1.GetBendNormalFromCurrentRotation();
				maintainBendFor1Frame = true;
			}
		}

		protected override void OnInitiateVirtual()
		{
			defaultRootRotation = root.rotation;
			if (bone1.transform.parent != null)
			{
				parentDefaultRotation = Quaternion.Inverse(defaultRootRotation) * bone1.transform.parent.rotation;
			}
			if (bone3.rotationLimit != null)
			{
				bone3.rotationLimit.Disable();
			}
			bone3DefaultRotation = bone3.transform.rotation;
			Vector3 vector = Vector3.Cross(bone2.transform.position - bone1.transform.position, bone3.transform.position - bone2.transform.position);
			if (vector != Vector3.zero)
			{
				bendNormal = vector;
			}
			animationNormal = bendNormal;
			StoreAxisDirections(ref axisDirectionsLeft);
			StoreAxisDirections(ref axisDirectionsRight);
		}

		protected override void OnUpdateVirtual()
		{
			if (IKPositionWeight > 0f)
			{
				bendModifierWeight = Mathf.Clamp(bendModifierWeight, 0f, 1f);
				maintainRotationWeight = Mathf.Clamp(maintainRotationWeight, 0f, 1f);
				_bendNormal = bendNormal;
				bendNormal = GetModifiedBendNormal();
			}
			if (maintainRotationWeight * IKPositionWeight > 0f)
			{
				bone3RotationBeforeSolve = ((!maintainRotationFor1Frame) ? bone3.transform.rotation : maintainRotation);
				maintainRotationFor1Frame = false;
			}
		}

		protected override void OnPostSolveVirtual()
		{
			if (IKPositionWeight > 0f)
			{
				bendNormal = _bendNormal;
			}
			if (maintainRotationWeight * IKPositionWeight > 0f)
			{
				bone3.transform.rotation = Quaternion.Slerp(bone3.transform.rotation, bone3RotationBeforeSolve, maintainRotationWeight * IKPositionWeight);
			}
		}

		private void StoreAxisDirections(ref AxisDirection[] axisDirections)
		{
			ref AxisDirection reference = ref axisDirections[0];
			reference = new AxisDirection(Vector3.zero, new Vector3(-1f, 0f, 0f));
			ref AxisDirection reference2 = ref axisDirections[1];
			reference2 = new AxisDirection(new Vector3(0.5f, 0f, -0.2f), new Vector3(-0.5f, -1f, 1f));
			ref AxisDirection reference3 = ref axisDirections[2];
			reference3 = new AxisDirection(new Vector3(-0.5f, -1f, -0.2f), new Vector3(0f, 0.5f, -1f));
			ref AxisDirection reference4 = ref axisDirections[3];
			reference4 = new AxisDirection(new Vector3(-0.5f, -0.5f, 1f), new Vector3(-1f, -1f, -1f));
		}

		private Vector3 GetModifiedBendNormal()
		{
			float num = bendModifierWeight;
			if (num <= 0f)
			{
				return bendNormal;
			}
			switch (bendModifier)
			{
			case BendModifier.Animation:
				if (!maintainBendFor1Frame)
				{
					MaintainBend();
				}
				maintainBendFor1Frame = false;
				return Vector3.Lerp(bendNormal, animationNormal, num);
			case BendModifier.Parent:
			{
				if (bone1.transform.parent == null)
				{
					return bendNormal;
				}
				Quaternion quaternion = bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation);
				return Quaternion.Slerp(Quaternion.identity, quaternion * Quaternion.Inverse(defaultRootRotation), num) * bendNormal;
			}
			case BendModifier.Target:
			{
				Quaternion b = IKRotation * Quaternion.Inverse(bone3DefaultRotation);
				return Quaternion.Slerp(Quaternion.identity, b, num) * bendNormal;
			}
			case BendModifier.Arm:
			{
				if (bone1.transform.parent == null)
				{
					return bendNormal;
				}
				if (goal == AvatarIKGoal.LeftFoot || goal == AvatarIKGoal.RightFoot)
				{
					if (!Warning.logged)
					{
						LogWarning("Trying to use the 'Arm' bend modifier on a leg.");
					}
					return bendNormal;
				}
				Vector3 normalized = (IKPosition - bone1.transform.position).normalized;
				normalized = Quaternion.Inverse(bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation)) * normalized;
				if (goal == AvatarIKGoal.LeftHand)
				{
					normalized.x = 0f - normalized.x;
				}
				for (int i = 1; i < axisDirections.Length; i++)
				{
					axisDirections[i].dot = Mathf.Clamp(Vector3.Dot(axisDirections[i].direction, normalized), 0f, 1f);
					axisDirections[i].dot = Interp.Float(axisDirections[i].dot, InterpolationMode.InOutQuintic);
				}
				Vector3 vector2 = axisDirections[0].axis;
				for (int j = 1; j < axisDirections.Length; j++)
				{
					vector2 = Vector3.Slerp(vector2, axisDirections[j].axis, axisDirections[j].dot);
				}
				if (goal == AvatarIKGoal.LeftHand)
				{
					vector2.x = 0f - vector2.x;
					vector2 = -vector2;
				}
				Vector3 vector3 = bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation) * vector2;
				if (num >= 1f)
				{
					return vector3;
				}
				return Vector3.Lerp(bendNormal, vector3, num);
			}
			case BendModifier.Goal:
			{
				if (bendGoal == null)
				{
					if (!Warning.logged)
					{
						LogWarning("Trying to use the 'Goal' Bend Modifier, but the Bend Goal is unassigned.");
					}
					return bendNormal;
				}
				Vector3 vector = Vector3.Cross(bendGoal.position - bone1.transform.position, IKPosition - bone1.transform.position);
				if (vector == Vector3.zero)
				{
					return bendNormal;
				}
				if (num >= 1f)
				{
					return vector;
				}
				return Vector3.Lerp(bendNormal, vector, num);
			}
			default:
				return bendNormal;
			}
		}
	}
	[Serializable]
	public class IKSolverLookAt : IKSolver
	{
		[Serializable]
		public class LookAtBone : Bone
		{
			public Vector3 forward => transform.rotation * axis;

			public LookAtBone()
			{
			}

			public LookAtBone(Transform transform)
			{
				base.transform = transform;
			}

			public void Initiate(Transform root)
			{
				if (!(transform == null))
				{
					axis = Quaternion.Inverse(transform.rotation) * root.forward;
				}
			}

			public void LookAt(Vector3 direction, float weight)
			{
				Quaternion quaternion = Quaternion.FromToRotation(forward, direction);
				Quaternion rotation = transform.rotation;
				transform.rotation = Quaternion.Lerp(rotation, quaternion * rotation, weight);
			}
		}

		public Transform target;

		public LookAtBone[] spine = new LookAtBone[0];

		public LookAtBone head = new LookAtBone();

		public LookAtBone[] eyes = new LookAtBone[0];

		[Range(0f, 1f)]
		public float bodyWeight = 0.5f;

		[Range(0f, 1f)]
		public float headWeight = 0.5f;

		[Range(0f, 1f)]
		public float eyesWeight = 1f;

		[Range(0f, 1f)]
		public float clampWeight = 0.5f;

		[Range(0f, 1f)]
		public float clampWeightHead = 0.5f;

		[Range(0f, 1f)]
		public float clampWeightEyes = 0.5f;

		[Range(0f, 2f)]
		public int clampSmoothing = 2;

		public AnimationCurve spineWeightCurve = new AnimationCurve(new Keyframe(0f, 0.3f), new Keyframe(1f, 1f));

		private Vector3[] spineForwards = new Vector3[0];

		private Vector3[] headForwards = new Vector3[1];

		private Vector3[] eyeForward = new Vector3[1];

		private bool spineIsValid
		{
			get
			{
				if (spine == null)
				{
					return false;
				}
				if (spine.Length == 0)
				{
					return true;
				}
				for (int i = 0; i < spine.Length; i++)
				{
					if (spine[i] == null || spine[i].transform == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		private bool spineIsEmpty => spine.Length == 0;

		private bool headIsValid
		{
			get
			{
				if (head == null)
				{
					return false;
				}
				return true;
			}
		}

		private bool headIsEmpty => head.transform == null;

		private bool eyesIsValid
		{
			get
			{
				if (eyes == null)
				{
					return false;
				}
				if (eyes.Length == 0)
				{
					return true;
				}
				for (int i = 0; i < eyes.Length; i++)
				{
					if (eyes[i] == null || eyes[i].transform == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		private bool eyesIsEmpty => eyes.Length == 0;

		public void SetLookAtWeight(float weight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight, float clampWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
			this.clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			clampWeightHead = this.clampWeight;
			clampWeightEyes = this.clampWeight;
		}

		public void SetLookAtWeight(float weight, float bodyWeight = 0f, float headWeight = 1f, float eyesWeight = 0.5f, float clampWeight = 0.5f, float clampWeightHead = 0.5f, float clampWeightEyes = 0.3f)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
			this.clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			this.clampWeightHead = Mathf.Clamp(clampWeightHead, 0f, 1f);
			this.clampWeightEyes = Mathf.Clamp(clampWeightEyes, 0f, 1f);
		}

		public override void StoreDefaultLocalState()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].StoreDefaultLocalState();
			}
			for (int j = 0; j < eyes.Length; j++)
			{
				eyes[j].StoreDefaultLocalState();
			}
			if (head != null && head.transform != null)
			{
				head.StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].FixTransform();
				}
				for (int j = 0; j < eyes.Length; j++)
				{
					eyes[j].FixTransform();
				}
				if (head != null && head.transform != null)
				{
					head.FixTransform();
				}
			}
		}

		public override bool IsValid(ref string message)
		{
			if (!spineIsValid)
			{
				message = "IKSolverLookAt spine setup is invalid. Can't initiate solver.";
				return false;
			}
			if (!headIsValid)
			{
				message = "IKSolverLookAt head transform is null. Can't initiate solver.";
				return false;
			}
			if (!eyesIsValid)
			{
				message = "IKSolverLookAt eyes setup is invalid. Can't initiate solver.";
				return false;
			}
			if (spineIsEmpty && headIsEmpty && eyesIsEmpty)
			{
				message = "IKSolverLookAt eyes setup is invalid. Can't initiate solver.";
				return false;
			}
			Transform transform = IKSolver.ContainsDuplicateBone(spine);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in a single IK chain. Can't initiate solver.";
				return false;
			}
			Transform transform2 = IKSolver.ContainsDuplicateBone(eyes);
			if (transform2 != null)
			{
				message = transform2.name + " is represented multiple times in a single IK chain. Can't initiate solver.";
				return false;
			}
			return true;
		}

		public override Point[] GetPoints()
		{
			Point[] array = new Point[spine.Length + eyes.Length + ((head.transform != null) ? 1 : 0)];
			for (int i = 0; i < spine.Length; i++)
			{
				array[i] = spine[i];
			}
			int num = 0;
			for (int j = spine.Length; j < array.Length; j++)
			{
				array[j] = eyes[num];
				num++;
			}
			if (head.transform != null)
			{
				array[array.Length - 1] = head;
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			LookAtBone[] array = spine;
			foreach (LookAtBone lookAtBone in array)
			{
				if (lookAtBone.transform == transform)
				{
					return lookAtBone;
				}
			}
			LookAtBone[] array2 = eyes;
			foreach (LookAtBone lookAtBone2 in array2)
			{
				if (lookAtBone2.transform == transform)
				{
					return lookAtBone2;
				}
			}
			if (head.transform == transform)
			{
				return head;
			}
			return null;
		}

		public bool SetChain(Transform[] spine, Transform head, Transform[] eyes, Transform root)
		{
			SetBones(spine, ref this.spine);
			this.head = new LookAtBone(head);
			SetBones(eyes, ref this.eyes);
			Initiate(root);
			return base.initiated;
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				if (spine.Length > 0)
				{
					IKPosition = spine[spine.Length - 1].transform.position + root.forward * 3f;
				}
				else if (head.transform != null)
				{
					IKPosition = head.transform.position + root.forward * 3f;
				}
				else if (eyes.Length > 0 && eyes[0].transform != null)
				{
					IKPosition = eyes[0].transform.position + root.forward * 3f;
				}
			}
			LookAtBone[] array = spine;
			foreach (LookAtBone lookAtBone in array)
			{
				lookAtBone.Initiate(root);
			}
			if (head != null)
			{
				head.Initiate(root);
			}
			LookAtBone[] array2 = eyes;
			foreach (LookAtBone lookAtBone2 in array2)
			{
				lookAtBone2.Initiate(root);
			}
			if (spineForwards == null || spineForwards.Length != spine.Length)
			{
				spineForwards = new Vector3[spine.Length];
			}
			if (headForwards == null)
			{
				headForwards = new Vector3[1];
			}
			if (eyeForward == null)
			{
				eyeForward = new Vector3[1];
			}
		}

		protected override void OnUpdate()
		{
			if (!(IKPositionWeight <= 0f))
			{
				IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
				if (target != null)
				{
					IKPosition = target.position;
				}
				SolveSpine();
				SolveHead();
				SolveEyes();
			}
		}

		private void SolveSpine()
		{
			if (!(bodyWeight <= 0f) && !spineIsEmpty)
			{
				Vector3 normalized = (IKPosition - spine[spine.Length - 1].transform.position).normalized;
				GetForwards(ref spineForwards, spine[0].forward, normalized, spine.Length, clampWeight);
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].LookAt(spineForwards[i], bodyWeight * IKPositionWeight);
				}
			}
		}

		private void SolveHead()
		{
			if (!(headWeight <= 0f) && !headIsEmpty)
			{
				Vector3 vector = ((spine.Length <= 0 || !(spine[spine.Length - 1].transform != null)) ? head.forward : spine[spine.Length - 1].forward);
				Vector3 normalized = Vector3.Lerp(vector, (IKPosition - head.transform.position).normalized, headWeight * IKPositionWeight).normalized;
				GetForwards(ref headForwards, vector, normalized, 1, clampWeightHead);
				head.LookAt(headForwards[0], headWeight * IKPositionWeight);
			}
		}

		private void SolveEyes()
		{
			if (!(eyesWeight <= 0f) && !eyesIsEmpty)
			{
				for (int i = 0; i < eyes.Length; i++)
				{
					Vector3 baseForward = ((!(head.transform != null)) ? eyes[i].forward : head.forward);
					GetForwards(ref eyeForward, baseForward, (IKPosition - eyes[i].transform.position).normalized, 1, clampWeightEyes);
					eyes[i].LookAt(eyeForward[0], eyesWeight * IKPositionWeight);
				}
			}
		}

		private Vector3[] GetForwards(ref Vector3[] forwards, Vector3 baseForward, Vector3 targetForward, int bones, float clamp)
		{
			if (clamp >= 1f || IKPositionWeight <= 0f)
			{
				for (int i = 0; i < forwards.Length; i++)
				{
					forwards[i] = baseForward;
				}
				return forwards;
			}
			float num = Vector3.Angle(baseForward, targetForward);
			float num2 = 1f - num / 180f;
			float num3 = ((!(clamp > 0f)) ? 1f : Mathf.Clamp(1f - (clamp - num2) / (1f - num2), 0f, 1f));
			float num4 = ((!(clamp > 0f)) ? 1f : Mathf.Clamp(num2 / clamp, 0f, 1f));
			for (int j = 0; j < clampSmoothing; j++)
			{
				float f = num4 * (float)Math.PI * 0.5f;
				num4 = Mathf.Sin(f);
			}
			if (forwards.Length == 1)
			{
				ref Vector3 reference = ref forwards[0];
				reference = Vector3.Slerp(baseForward, targetForward, num4 * num3);
			}
			else
			{
				float num5 = 1f / (float)(forwards.Length - 1);
				for (int k = 0; k < forwards.Length; k++)
				{
					ref Vector3 reference2 = ref forwards[k];
					reference2 = Vector3.Slerp(baseForward, targetForward, spineWeightCurve.Evaluate(num5 * (float)k) * num4 * num3);
				}
			}
			return forwards;
		}

		private void SetBones(Transform[] array, ref LookAtBone[] bones)
		{
			if (array == null)
			{
				bones = new LookAtBone[0];
				return;
			}
			if (bones.Length != array.Length)
			{
				bones = new LookAtBone[array.Length];
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (bones[i] == null)
				{
					bones[i] = new LookAtBone(array[i]);
				}
				else
				{
					bones[i].transform = array[i];
				}
			}
		}
	}
	[Serializable]
	public class IKSolverTrigonometric : IKSolver
	{
		[Serializable]
		public class TrigonometricBone : Bone
		{
			private Quaternion targetToLocalSpace;

			private Vector3 defaultLocalBendNormal;

			public void Initiate(Vector3 childPosition, Vector3 bendNormal)
			{
				Quaternion rotation = Quaternion.LookRotation(childPosition - transform.position, bendNormal);
				targetToLocalSpace = QuaTools.RotationToLocalSpace(transform.rotation, rotation);
				defaultLocalBendNormal = Quaternion.Inverse(transform.rotation) * bendNormal;
			}

			public Quaternion GetRotation(Vector3 direction, Vector3 bendNormal)
			{
				return Quaternion.LookRotation(direction, bendNormal) * targetToLocalSpace;
			}

			public Vector3 GetBendNormalFromCurrentRotation()
			{
				return transform.rotation * defaultLocalBendNormal;
			}
		}

		public Transform target;

		[Range(0f, 1f)]
		public float IKRotationWeight = 1f;

		public Quaternion IKRotation = Quaternion.identity;

		public Vector3 bendNormal = Vector3.right;

		public TrigonometricBone bone1 = new TrigonometricBone();

		public TrigonometricBone bone2 = new TrigonometricBone();

		public TrigonometricBone bone3 = new TrigonometricBone();

		protected Vector3 weightIKPosition;

		protected bool directHierarchy = true;

		public void SetBendGoalPosition(Vector3 goalPosition, float weight)
		{
			if (!base.initiated || weight <= 0f)
			{
				return;
			}
			Vector3 vector = Vector3.Cross(goalPosition - bone1.transform.position, IKPosition - bone1.transform.position);
			if (vector != Vector3.zero)
			{
				if (weight >= 1f)
				{
					bendNormal = vector;
				}
				else
				{
					bendNormal = Vector3.Lerp(bendNormal, vector, weight);
				}
			}
		}

		public void SetBendPlaneToCurrent()
		{
			if (base.initiated)
			{
				Vector3 vector = Vector3.Cross(bone2.transform.position - bone1.transform.position, bone3.transform.position - bone2.transform.position);
				if (vector != Vector3.zero)
				{
					bendNormal = vector;
				}
			}
		}

		public void SetIKRotation(Quaternion rotation)
		{
			IKRotation = rotation;
		}

		public void SetIKRotationWeight(float weight)
		{
			IKRotationWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public Quaternion GetIKRotation()
		{
			return IKRotation;
		}

		public float GetIKRotationWeight()
		{
			return IKRotationWeight;
		}

		public override Point[] GetPoints()
		{
			return new Point[3] { bone1, bone2, bone3 };
		}

		public override Point GetPoint(Transform transform)
		{
			if (bone1.transform == transform)
			{
				return bone1;
			}
			if (bone2.transform == transform)
			{
				return bone2;
			}
			if (bone3.transform == transform)
			{
				return bone3;
			}
			return null;
		}

		public override void StoreDefaultLocalState()
		{
			bone1.StoreDefaultLocalState();
			bone2.StoreDefaultLocalState();
			bone3.StoreDefaultLocalState();
		}

		public override void FixTransforms()
		{
			bone1.FixTransform();
			bone2.FixTransform();
			bone3.FixTransform();
		}

		public override bool IsValid(ref string message)
		{
			if (bone1.transform == null || bone2.transform == null || bone3.transform == null)
			{
				message = "Please assign all Bones to the IK solver.";
				return false;
			}
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(new Transform[3] { bone1.transform, bone2.transform, bone3.transform });
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the Bones.";
				return false;
			}
			if (bone1.transform.position == bone2.transform.position)
			{
				message = "first bone position is the same as second bone position.";
				return false;
			}
			if (bone2.transform.position == bone3.transform.position)
			{
				message = "second bone position is the same as third bone position.";
				return false;
			}
			return true;
		}

		public bool SetChain(Transform bone1, Transform bone2, Transform bone3, Transform root)
		{
			this.bone1.transform = bone1;
			this.bone2.transform = bone2;
			this.bone3.transform = bone3;
			Initiate(root);
			return base.initiated;
		}

		public static void Solve(Transform bone1, Transform bone2, Transform bone3, Vector3 targetPosition, Vector3 bendNormal, float weight)
		{
			if (weight <= 0f)
			{
				return;
			}
			targetPosition = Vector3.Lerp(bone3.position, targetPosition, weight);
			Vector3 vector = targetPosition - bone1.position;
			float magnitude = vector.magnitude;
			if (magnitude != 0f)
			{
				float sqrMagnitude = (bone2.position - bone1.position).sqrMagnitude;
				float sqrMagnitude2 = (bone3.position - bone2.position).sqrMagnitude;
				Vector3 bendDirection = Vector3.Cross(vector, bendNormal);
				Vector3 directionToBendPoint = GetDirectionToBendPoint(vector, magnitude, bendDirection, sqrMagnitude, sqrMagnitude2);
				Quaternion quaternion = Quaternion.FromToRotation(bone2.position - bone1.position, directionToBendPoint);
				if (weight < 1f)
				{
					quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
				}
				bone1.rotation = quaternion * bone1.rotation;
				Quaternion quaternion2 = Quaternion.FromToRotation(bone3.position - bone2.position, targetPosition - bone2.position);
				if (weight < 1f)
				{
					quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion2, weight);
				}
				bone2.rotation = quaternion2 * bone2.rotation;
			}
		}

		private static Vector3 GetDirectionToBendPoint(Vector3 direction, float directionMag, Vector3 bendDirection, float sqrMag1, float sqrMag2)
		{
			float num = (directionMag * directionMag + (sqrMag1 - sqrMag2)) / 2f / directionMag;
			float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
			if (direction == Vector3.zero)
			{
				return Vector3.zero;
			}
			return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
		}

		protected override void OnInitiate()
		{
			if (bendNormal == Vector3.zero)
			{
				bendNormal = Vector3.right;
			}
			OnInitiateVirtual();
			IKPosition = bone3.transform.position;
			IKRotation = bone3.transform.rotation;
			InitiateBones();
			directHierarchy = IsDirectHierarchy();
		}

		private bool IsDirectHierarchy()
		{
			if (bone3.transform.parent != bone2.transform)
			{
				return false;
			}
			if (bone2.transform.parent != bone1.transform)
			{
				return false;
			}
			return true;
		}

		private void InitiateBones()
		{
			bone1.Initiate(bone2.transform.position, bendNormal);
			bone2.Initiate(bone3.transform.position, bendNormal);
			SetBendPlaneToCurrent();
		}

		protected override void OnUpdate()
		{
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			IKRotationWeight = Mathf.Clamp(IKRotationWeight, 0f, 1f);
			if (target != null)
			{
				IKPosition = target.position;
				IKRotation = target.rotation;
			}
			OnUpdateVirtual();
			if (IKPositionWeight > 0f)
			{
				if (!directHierarchy)
				{
					bone1.Initiate(bone2.transform.position, bendNormal);
					bone2.Initiate(bone3.transform.position, bendNormal);
				}
				bone1.sqrMag = (bone2.transform.position - bone1.transform.position).sqrMagnitude;
				bone2.sqrMag = (bone3.transform.position - bone2.transform.position).sqrMagnitude;
				if (bendNormal == Vector3.zero && !Warning.logged)
				{
					LogWarning("IKSolverTrigonometric Bend Normal is Vector3.zero.");
				}
				weightIKPosition = Vector3.Lerp(bone3.transform.position, IKPosition, IKPositionWeight);
				Vector3 vector = Vector3.Lerp(bone1.GetBendNormalFromCurrentRotation(), bendNormal, IKPositionWeight);
				Vector3 vector2 = Vector3.Lerp(bone2.transform.position - bone1.transform.position, GetBendDirection(weightIKPosition, vector), IKPositionWeight);
				if (vector2 == Vector3.zero)
				{
					vector2 = bone2.transform.position - bone1.transform.position;
				}
				bone1.transform.rotation = bone1.GetRotation(vector2, vector);
				bone2.transform.rotation = bone2.GetRotation(weightIKPosition - bone2.transform.position, bone2.GetBendNormalFromCurrentRotation());
			}
			if (IKRotationWeight > 0f)
			{
				bone3.transform.rotation = Quaternion.Slerp(bone3.transform.rotation, IKRotation, IKRotationWeight);
			}
			OnPostSolveVirtual();
		}

		protected virtual void OnInitiateVirtual()
		{
		}

		protected virtual void OnUpdateVirtual()
		{
		}

		protected virtual void OnPostSolveVirtual()
		{
		}

		protected Vector3 GetBendDirection(Vector3 IKPosition, Vector3 bendNormal)
		{
			Vector3 vector = IKPosition - bone1.transform.position;
			if (vector == Vector3.zero)
			{
				return Vector3.zero;
			}
			float sqrMagnitude = vector.sqrMagnitude;
			float num = (float)Math.Sqrt(sqrMagnitude);
			float num2 = (sqrMagnitude + bone1.sqrMag - bone2.sqrMag) / 2f / num;
			float y = (float)Math.Sqrt(Mathf.Clamp(bone1.sqrMag - num2 * num2, 0f, float.PositiveInfinity));
			Vector3 upwards = Vector3.Cross(vector, bendNormal);
			return Quaternion.LookRotation(vector, upwards) * new Vector3(0f, y, num2);
		}
	}
	[Serializable]
	public class IKSolverVR : IKSolver
	{
		[Serializable]
		public class Arm : BodyPart
		{
			[Serializable]
			public enum ShoulderRotationMode
			{
				YawPitch,
				FromTo
			}

			[Tooltip("The hand target")]
			public Transform target;

			[Tooltip("The elbow will be bent towards this Transform if 'Bend Goal Weight' > 0.")]
			public Transform bendGoal;

			[Tooltip("Positional weight of the hand target.")]
			[Range(0f, 1f)]
			public float positionWeight = 1f;

			[Tooltip("Rotational weight of the hand target")]
			[Range(0f, 1f)]
			public float rotationWeight = 1f;

			[Tooltip("Different techniques for shoulder bone rotation.")]
			public ShoulderRotationMode shoulderRotationMode;

			[Tooltip("The weight of shoulder rotation")]
			[Range(0f, 1f)]
			public float shoulderRotationWeight = 1f;

			[Tooltip("If greater than 0, will bend the elbow towards the 'Bend Goal' Transform.")]
			[Range(0f, 1f)]
			public float bendGoalWeight;

			[Tooltip("Angular offset of the elbow bending direction.")]
			[Range(-180f, 180f)]
			public float swivelOffset;

			[Tooltip("Local axis of the hand bone that points from the wrist towards the palm. Used for defining hand bone orientation.")]
			public Vector3 wristToPalmAxis = Vector3.zero;

			[Tooltip("Local axis of the hand bone that points from the palm towards the thumb. Used for defining hand bone orientation.")]
			public Vector3 palmToThumbAxis = Vector3.zero;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPosition;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotation = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 bendDirection = Vector3.back;

			[NonSerialized]
			[HideInInspector]
			public Vector3 handPositionOffset;

			private bool hasShoulder;

			private Vector3 chestForwardAxis;

			private Vector3 chestUpAxis;

			private Quaternion chestRotation = Quaternion.identity;

			private Vector3 chestForward;

			private Vector3 chestUp;

			private Quaternion forearmRelToUpperArm = Quaternion.identity;

			private const float yawOffsetAngle = 45f;

			private const float pitchOffsetAngle = -30f;

			public Vector3 position { get; private set; }

			public Quaternion rotation { get; private set; }

			private VirtualBone shoulder => bones[0];

			private VirtualBone upperArm => bones[1];

			private VirtualBone forearm => bones[2];

			private VirtualBone hand => bones[3];

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 vector3 = positions[index + 2];
				Quaternion quaternion3 = rotations[index + 2];
				Vector3 iKPosition = positions[index + 3];
				Quaternion iKRotation = rotations[index + 3];
				if (!initiated)
				{
					IKPosition = iKPosition;
					IKRotation = iKRotation;
					rotation = IKRotation;
					hasShoulder = hasShoulders;
					bones = new VirtualBone[(!hasShoulder) ? 3 : 4];
					if (hasShoulder)
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(vector3, quaternion3);
						bones[3] = new VirtualBone(iKPosition, iKRotation);
					}
					else
					{
						bones[0] = new VirtualBone(vector2, quaternion2);
						bones[1] = new VirtualBone(vector3, quaternion3);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
					}
					chestForwardAxis = Quaternion.Inverse(rootRotation) * (rotations[0] * Vector3.forward);
					chestUpAxis = Quaternion.Inverse(rootRotation) * (rotations[0] * Vector3.up);
				}
				if (hasShoulder)
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(vector3, quaternion3);
					bones[3].Read(iKPosition, iKRotation);
				}
				else
				{
					bones[0].Read(vector2, quaternion2);
					bones[1].Read(vector3, quaternion3);
					bones[2].Read(iKPosition, iKRotation);
				}
			}

			public override void PreSolve()
			{
				if (target != null)
				{
					IKPosition = target.position;
					IKRotation = target.rotation;
				}
				position = V3Tools.Lerp(hand.solverPosition, IKPosition, positionWeight);
				rotation = QuaTools.Lerp(hand.solverRotation, IKRotation, rotationWeight);
				shoulder.axis = shoulder.axis.normalized;
				forearmRelToUpperArm = Quaternion.Inverse(upperArm.solverRotation) * forearm.solverRotation;
			}

			public override void ApplyOffsets()
			{
				position += handPositionOffset;
			}

			public void Solve(bool isLeft)
			{
				chestRotation = Quaternion.LookRotation(rootRotation * chestForwardAxis, rootRotation * chestUpAxis);
				chestForward = chestRotation * Vector3.forward;
				chestUp = chestRotation * Vector3.up;
				if (hasShoulder && shoulderRotationWeight > 0f)
				{
					switch (shoulderRotationMode)
					{
					case ShoulderRotationMode.YawPitch:
					{
						Vector3 normalized = (position - shoulder.solverPosition).normalized;
						float num3 = ((!isLeft) ? (-45f) : 45f);
						Quaternion quaternion2 = Quaternion.AngleAxis(((!isLeft) ? 90f : (-90f)) + num3, chestUp);
						Quaternion quaternion3 = quaternion2 * chestRotation;
						Vector3 lhs = Quaternion.Inverse(quaternion3) * normalized;
						float num4 = Mathf.Atan2(lhs.x, lhs.z) * 57.29578f;
						float f = Vector3.Dot(lhs, Vector3.up);
						f = 1f - Mathf.Abs(f);
						num4 *= f;
						num4 -= num3;
						num4 = DamperValue(num4, -45f - num3, 45f - num3, 0.7f);
						Vector3 fromDirection = shoulder.solverRotation * shoulder.axis;
						Vector3 toDirection = quaternion3 * (Quaternion.AngleAxis(num4, Vector3.up) * Vector3.forward);
						Quaternion quaternion4 = Quaternion.FromToRotation(fromDirection, toDirection);
						Quaternion quaternion5 = Quaternion.AngleAxis((!isLeft) ? 90f : (-90f), chestUp);
						quaternion3 = quaternion5 * chestRotation;
						quaternion3 = Quaternion.AngleAxis((!isLeft) ? 30f : (-30f), chestForward) * quaternion3;
						normalized = position - (shoulder.solverPosition + chestRotation * ((!isLeft) ? Vector3.left : Vector3.right) * base.mag);
						lhs = Quaternion.Inverse(quaternion3) * normalized;
						float num5 = Mathf.Atan2(lhs.y, lhs.z) * 57.29578f;
						num5 -= -30f;
						num5 = DamperValue(num5, -15f, 75f);
						Quaternion quaternion6 = Quaternion.AngleAxis(0f - num5, quaternion3 * Vector3.right);
						Quaternion b2 = quaternion6 * quaternion4;
						if (shoulderRotationWeight * positionWeight < 1f)
						{
							b2 = Quaternion.Lerp(Quaternion.identity, b2, shoulderRotationWeight * positionWeight);
						}
						VirtualBone.RotateBy(bones, b2);
						VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
						float angle = Mathf.Clamp(num5 * 2f * positionWeight, 0f, 180f);
						shoulder.solverRotation = Quaternion.AngleAxis(angle, shoulder.solverRotation * ((!isLeft) ? (-shoulder.axis) : shoulder.axis)) * shoulder.solverRotation;
						upperArm.solverRotation = Quaternion.AngleAxis(angle, upperArm.solverRotation * ((!isLeft) ? (-upperArm.axis) : upperArm.axis)) * upperArm.solverRotation;
						break;
					}
					case ShoulderRotationMode.FromTo:
					{
						Quaternion solverRotation = shoulder.solverRotation;
						Quaternion b = Quaternion.FromToRotation((upperArm.solverPosition - shoulder.solverPosition).normalized + chestForward, position - shoulder.solverPosition);
						b = Quaternion.Slerp(Quaternion.identity, b, 0.5f * shoulderRotationWeight * positionWeight);
						VirtualBone.RotateBy(bones, b);
						VirtualBone.SolveTrigonometric(bones, 0, 2, 3, position, Vector3.Cross(forearm.solverPosition - shoulder.solverPosition, hand.solverPosition - shoulder.solverPosition), 0.5f * shoulderRotationWeight * positionWeight);
						VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
						Quaternion quaternion = Quaternion.Inverse(Quaternion.LookRotation(chestUp, chestForward));
						Vector3 vector = quaternion * (solverRotation * shoulder.axis);
						Vector3 vector2 = quaternion * (shoulder.solverRotation * shoulder.axis);
						float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
						float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
						float num2 = Mathf.DeltaAngle(current, num);
						if (isLeft)
						{
							num2 = 0f - num2;
						}
						num2 = Mathf.Clamp(num2 * 2f * positionWeight, 0f, 180f);
						shoulder.solverRotation = Quaternion.AngleAxis(num2, shoulder.solverRotation * ((!isLeft) ? (-shoulder.axis) : shoulder.axis)) * shoulder.solverRotation;
						upperArm.solverRotation = Quaternion.AngleAxis(num2, upperArm.solverRotation * ((!isLeft) ? (-upperArm.axis) : upperArm.axis)) * upperArm.solverRotation;
						break;
					}
					}
				}
				else
				{
					VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
				}
				Quaternion quaternion7 = upperArm.solverRotation * forearmRelToUpperArm;
				Quaternion quaternion8 = Quaternion.FromToRotation(quaternion7 * forearm.axis, hand.solverPosition - forearm.solverPosition);
				RotateTo(forearm, quaternion8 * quaternion7, positionWeight);
				if (rotationWeight >= 1f)
				{
					hand.solverRotation = rotation;
				}
				else if (rotationWeight > 0f)
				{
					hand.solverRotation = Quaternion.Lerp(hand.solverRotation, rotation, rotationWeight);
				}
			}

			public override void ResetOffsets()
			{
				handPositionOffset = Vector3.zero;
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				if (hasShoulder)
				{
					ref Quaternion reference = ref solvedRotations[index];
					reference = shoulder.solverRotation;
				}
				ref Quaternion reference2 = ref solvedRotations[index + 1];
				reference2 = upperArm.solverRotation;
				ref Quaternion reference3 = ref solvedRotations[index + 2];
				reference3 = forearm.solverRotation;
				ref Quaternion reference4 = ref solvedRotations[index + 3];
				reference4 = hand.solverRotation;
			}

			private float DamperValue(float value, float min, float max, float weight = 1f)
			{
				float num = max - min;
				if (weight < 1f)
				{
					float num2 = max - num * 0.5f;
					float num3 = value - num2;
					num3 *= 0.5f;
					value = num2 + num3;
				}
				value -= min;
				float t = Mathf.Clamp(value / num, 0f, 1f);
				float t2 = Interp.Float(t, InterpolationMode.InOutQuintic);
				return Mathf.Lerp(min, max, t2);
			}

			private Vector3 GetBendNormal(Vector3 dir)
			{
				if (bendGoal != null)
				{
					bendDirection = bendGoal.position - bones[0].solverPosition;
				}
				if (bendGoalWeight < 1f)
				{
					Vector3 vector = bones[0].solverRotation * bones[0].axis;
					Vector3 down = Vector3.down;
					Vector3 toDirection = Quaternion.Inverse(chestRotation) * dir.normalized + Vector3.forward;
					Quaternion quaternion = Quaternion.FromToRotation(down, toDirection);
					Vector3 vector2 = quaternion * Vector3.back;
					down = Quaternion.Inverse(chestRotation) * vector;
					toDirection = Quaternion.Inverse(chestRotation) * dir;
					quaternion = Quaternion.FromToRotation(down, toDirection);
					vector2 = quaternion * vector2;
					vector2 = chestRotation * vector2;
					vector2 += vector;
					vector2 -= rotation * wristToPalmAxis;
					vector2 -= rotation * palmToThumbAxis * 0.5f;
					if (bendGoalWeight > 0f)
					{
						vector2 = Vector3.Slerp(vector2, bendDirection, bendGoalWeight);
					}
					if (swivelOffset != 0f)
					{
						vector2 = Quaternion.AngleAxis(swivelOffset, -dir) * vector2;
					}
					return Vector3.Cross(vector2, dir);
				}
				return Vector3.Cross(bendDirection, dir);
			}

			private void Visualize(VirtualBone bone1, VirtualBone bone2, VirtualBone bone3, Color color)
			{
				Debug.DrawLine(bone1.solverPosition, bone2.solverPosition, color);
				Debug.DrawLine(bone2.solverPosition, bone3.solverPosition, color);
			}
		}

		[Serializable]
		public abstract class BodyPart
		{
			[HideInInspector]
			public VirtualBone[] bones = new VirtualBone[0];

			protected bool initiated;

			protected Vector3 rootPosition;

			protected Quaternion rootRotation = Quaternion.identity;

			protected int index = -1;

			public float sqrMag { get; private set; }

			public float mag { get; private set; }

			protected abstract void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index);

			public abstract void PreSolve();

			public abstract void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations);

			public abstract void ApplyOffsets();

			public abstract void ResetOffsets();

			public void Read(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				this.index = index;
				rootPosition = positions[rootIndex];
				rootRotation = rotations[rootIndex];
				OnRead(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, rootIndex, index);
				mag = VirtualBone.PreSolve(ref bones);
				sqrMag = mag * mag;
				initiated = true;
			}

			public void MovePosition(Vector3 position)
			{
				Vector3 vector = position - bones[0].solverPosition;
				VirtualBone[] array = bones;
				foreach (VirtualBone virtualBone in array)
				{
					virtualBone.solverPosition += vector;
				}
			}

			public void MoveRotation(Quaternion rotation)
			{
				Quaternion rotation2 = QuaTools.FromToRotation(bones[0].solverRotation, rotation);
				VirtualBone.RotateAroundPoint(bones, 0, bones[0].solverPosition, rotation2);
			}

			public void Translate(Vector3 position, Quaternion rotation)
			{
				MovePosition(position);
				MoveRotation(rotation);
			}

			public void TranslateRoot(Vector3 newRootPos, Quaternion newRootRot)
			{
				Vector3 vector = newRootPos - rootPosition;
				rootPosition = newRootPos;
				VirtualBone[] array = bones;
				foreach (VirtualBone virtualBone in array)
				{
					virtualBone.solverPosition += vector;
				}
				Quaternion rotation = QuaTools.FromToRotation(rootRotation, newRootRot);
				rootRotation = newRootRot;
				VirtualBone.RotateAroundPoint(bones, 0, newRootPos, rotation);
			}

			public void RotateTo(VirtualBone bone, Quaternion rotation, float weight = 1f)
			{
				if (weight <= 0f)
				{
					return;
				}
				Quaternion quaternion = QuaTools.FromToRotation(bone.solverRotation, rotation);
				if (weight < 1f)
				{
					quaternion = Quaternion.Slerp(Quaternion.identity, quaternion, weight);
				}
				for (int i = 0; i < bones.Length; i++)
				{
					if (bones[i] == bone)
					{
						VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, quaternion);
						break;
					}
				}
			}

			public void Visualize(Color color)
			{
				for (int i = 0; i < bones.Length - 1; i++)
				{
					Debug.DrawLine(bones[i].solverPosition, bones[i + 1].solverPosition, color);
				}
			}

			public void Visualize()
			{
				Visualize(Color.white);
			}
		}

		[Serializable]
		public class Footstep
		{
			public float stepSpeed = 3f;

			public Vector3 characterSpaceOffset;

			public Vector3 position;

			public Quaternion rotation = Quaternion.identity;

			public Quaternion stepToRootRot = Quaternion.identity;

			public bool isSupportLeg;

			public Vector3 stepFrom;

			public Vector3 stepTo;

			public Quaternion stepFromRot = Quaternion.identity;

			public Quaternion stepToRot = Quaternion.identity;

			private Quaternion footRelativeToRoot = Quaternion.identity;

			private float supportLegW;

			private float supportLegWV;

			public bool isStepping => stepProgress < 1f;

			public float stepProgress { get; private set; }

			public Footstep(Quaternion rootRotation, Vector3 footPosition, Quaternion footRotation, Vector3 characterSpaceOffset)
			{
				this.characterSpaceOffset = characterSpaceOffset;
				Reset(rootRotation, footPosition, footRotation);
			}

			public void Reset(Quaternion rootRotation, Vector3 footPosition, Quaternion footRotation)
			{
				position = footPosition;
				rotation = footRotation;
				stepFrom = position;
				stepTo = position;
				stepFromRot = rotation;
				stepToRot = rotation;
				stepToRootRot = rootRotation;
				stepProgress = 1f;
				footRelativeToRoot = Quaternion.Inverse(rootRotation) * rotation;
			}

			public void StepTo(Vector3 p, Quaternion rootRotation)
			{
				stepFrom = position;
				stepTo = p;
				stepFromRot = rotation;
				stepToRootRot = rootRotation;
				stepToRot = rootRotation * footRelativeToRoot;
				stepProgress = 0f;
			}

			public void UpdateStepping(Vector3 p, Quaternion rootRotation, float speed)
			{
				stepTo = Vector3.Lerp(stepTo, p, Time.deltaTime * speed);
				stepToRot = Quaternion.Lerp(stepToRot, rootRotation * footRelativeToRoot, Time.deltaTime * speed);
				stepToRootRot = stepToRot * Quaternion.Inverse(footRelativeToRoot);
			}

			public void UpdateStanding(Quaternion rootRotation, float minAngle, float speed)
			{
				if (!(speed <= 0f) && !(minAngle >= 180f))
				{
					Quaternion quaternion = rootRotation * footRelativeToRoot;
					float num = Quaternion.Angle(rotation, quaternion);
					if (num > minAngle)
					{
						rotation = Quaternion.RotateTowards(rotation, quaternion, Mathf.Min(Time.deltaTime * speed * (1f - supportLegW), num - minAngle));
					}
				}
			}

			public void Update(InterpolationMode interpolation, UnityEvent onStep)
			{
				float target = ((!isSupportLeg) ? 0f : 1f);
				supportLegW = Mathf.SmoothDamp(supportLegW, target, ref supportLegWV, 0.2f);
				if (isStepping)
				{
					stepProgress = Mathf.MoveTowards(stepProgress, 1f, Time.deltaTime * stepSpeed);
					if (stepProgress >= 1f)
					{
						onStep.Invoke();
					}
					float t = Interp.Float(stepProgress, interpolation);
					position = Vector3.Lerp(stepFrom, stepTo, t);
					rotation = Quaternion.Lerp(stepFromRot, stepToRot, t);
				}
			}
		}

		[Serializable]
		public class Leg : BodyPart
		{
			[Tooltip("The toe/foot target.")]
			public Transform target;

			[Tooltip("The knee will be bent towards this Transform if 'Bend Goal Weight' > 0.")]
			public Transform bendGoal;

			[Tooltip("Positional weight of the toe/foot target.")]
			[Range(0f, 1f)]
			public float positionWeight;

			[Tooltip("Rotational weight of the toe/foot target.")]
			[Range(0f, 1f)]
			public float rotationWeight;

			[Tooltip("If greater than 0, will bend the knee towards the 'Bend Goal' Transform.")]
			[Range(0f, 1f)]
			public float bendGoalWeight;

			[Tooltip("Angular offset of the knee bending direction.")]
			[Range(-180f, 180f)]
			public float swivelOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPosition;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotation = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 footPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 heelPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Quaternion footRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public float currentMag;

			private Vector3 footPosition;

			private Quaternion footRotation = Quaternion.identity;

			private Vector3 bendNormal;

			private Quaternion calfRelToThigh = Quaternion.identity;

			public Vector3 position { get; private set; }

			public Quaternion rotation { get; private set; }

			public bool hasToes { get; private set; }

			public VirtualBone thigh => bones[0];

			private VirtualBone calf => bones[1];

			private VirtualBone foot => bones[2];

			private VirtualBone toes => bones[3];

			public VirtualBone lastBone => bones[bones.Length - 1];

			public Vector3 thighRelativeToPelvis { get; private set; }

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 iKPosition = positions[index + 2];
				Quaternion iKRotation = rotations[index + 2];
				Vector3 iKPosition2 = positions[index + 3];
				Quaternion iKRotation2 = rotations[index + 3];
				if (!initiated)
				{
					this.hasToes = hasToes;
					bones = new VirtualBone[(!hasToes) ? 3 : 4];
					if (hasToes)
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
						bones[3] = new VirtualBone(iKPosition2, iKRotation2);
						IKPosition = iKPosition2;
						IKRotation = iKRotation2;
					}
					else
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
						IKPosition = iKPosition;
						IKRotation = iKRotation;
					}
					rotation = IKRotation;
				}
				if (hasToes)
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(iKPosition, iKRotation);
					bones[3].Read(iKPosition2, iKRotation2);
				}
				else
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(iKPosition, iKRotation);
				}
			}

			public override void PreSolve()
			{
				if (target != null)
				{
					IKPosition = target.position;
					IKRotation = target.rotation;
				}
				footPosition = foot.solverPosition;
				footRotation = foot.solverRotation;
				position = lastBone.solverPosition;
				rotation = lastBone.solverRotation;
				if (rotationWeight > 0f)
				{
					ApplyRotationOffset(QuaTools.FromToRotation(rotation, IKRotation), rotationWeight);
				}
				if (positionWeight > 0f)
				{
					ApplyPositionOffset(IKPosition - position, positionWeight);
				}
				thighRelativeToPelvis = Quaternion.Inverse(rootRotation) * (thigh.solverPosition - rootPosition);
				calfRelToThigh = Quaternion.Inverse(thigh.solverRotation) * calf.solverRotation;
				bendNormal = Vector3.Cross(calf.solverPosition - thigh.solverPosition, foot.solverPosition - calf.solverPosition);
			}

			public override void ApplyOffsets()
			{
				ApplyPositionOffset(footPositionOffset, 1f);
				ApplyRotationOffset(footRotationOffset, 1f);
				Quaternion quaternion = Quaternion.FromToRotation(footPosition - position, footPosition + heelPositionOffset - position);
				footPosition = position + quaternion * (footPosition - position);
				footRotation = quaternion * footRotation;
				float num = 0f;
				if (bendGoal != null && bendGoalWeight > 0f)
				{
					Vector3 vector = Vector3.Cross(bendGoal.position - thigh.solverPosition, foot.solverPosition - thigh.solverPosition);
					Quaternion quaternion2 = Quaternion.LookRotation(bendNormal, thigh.solverPosition - foot.solverPosition);
					Vector3 vector2 = Quaternion.Inverse(quaternion2) * vector;
					num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f * bendGoalWeight;
				}
				float num2 = swivelOffset + num;
				if (num2 != 0f)
				{
					bendNormal = Quaternion.AngleAxis(num2, thigh.solverPosition - lastBone.solverPosition) * bendNormal;
					thigh.solverRotation = Quaternion.AngleAxis(0f - num2, thigh.solverRotation * thigh.axis) * thigh.solverRotation;
				}
			}

			private void ApplyPositionOffset(Vector3 offset, float weight)
			{
				if (!(weight <= 0f))
				{
					offset *= weight;
					footPosition += offset;
					position += offset;
				}
			}

			private void ApplyRotationOffset(Quaternion offset, float weight)
			{
				if (!(weight <= 0f))
				{
					if (weight < 1f)
					{
						offset = Quaternion.Lerp(Quaternion.identity, offset, weight);
					}
					footRotation = offset * footRotation;
					rotation = offset * rotation;
					bendNormal = offset * bendNormal;
					footPosition = position + offset * (footPosition - position);
				}
			}

			public void Solve()
			{
				VirtualBone.SolveTrigonometric(bones, 0, 1, 2, footPosition, bendNormal, 1f);
				RotateTo(foot, footRotation);
				if (hasToes)
				{
					Vector3 vector = Vector3.Cross(foot.solverPosition - thigh.solverPosition, toes.solverPosition - foot.solverPosition);
					VirtualBone.SolveTrigonometric(bones, 0, 2, 3, position, vector, 1f);
					Quaternion quaternion = thigh.solverRotation * calfRelToThigh;
					Quaternion quaternion2 = Quaternion.FromToRotation(quaternion * calf.axis, foot.solverPosition - calf.solverPosition);
					RotateTo(calf, quaternion2 * quaternion);
					toes.solverRotation = rotation;
				}
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				ref Quaternion reference = ref solvedRotations[index];
				reference = thigh.solverRotation;
				ref Quaternion reference2 = ref solvedRotations[index + 1];
				reference2 = calf.solverRotation;
				ref Quaternion reference3 = ref solvedRotations[index + 2];
				reference3 = foot.solverRotation;
				if (hasToes)
				{
					ref Quaternion reference4 = ref solvedRotations[index + 3];
					reference4 = toes.solverRotation;
				}
			}

			public override void ResetOffsets()
			{
				footPositionOffset = Vector3.zero;
				footRotationOffset = Quaternion.identity;
				heelPositionOffset = Vector3.zero;
			}
		}

		[Serializable]
		public class Locomotion
		{
			[Tooltip("Used for blending in/out of procedural locomotion.")]
			[Range(0f, 1f)]
			public float weight = 1f;

			[Tooltip("Tries to maintain this distance between the legs.")]
			public float footDistance = 0.3f;

			[Tooltip("Makes a step only if step target position is at least this far from the current footstep or the foot does not reach the current footstep anymore or footstep angle is past the 'Angle Threshold'.")]
			public float stepThreshold = 0.4f;

			[Tooltip("Makes a step only if step target position is at least 'Step Threshold' far from the current footstep or the foot does not reach the current footstep anymore or footstep angle is past this value.")]
			public float angleThreshold = 60f;

			[Tooltip("Multiplies angle of the center of mass - center of pressure vector. Larger value makes the character step sooner if losing balance.")]
			public float comAngleMlp = 1f;

			[Tooltip("Maximum magnitude of head/hand target velocity used in prediction.")]
			public float maxVelocity = 0.4f;

			[Tooltip("The amount of head/hand target velocity prediction.")]
			public float velocityFactor = 0.4f;

			[Tooltip("How much can a leg be extended before it is forced to step to another position? 1 means fully stretched.")]
			[Range(0.9f, 1f)]
			public float maxLegStretch = 1f;

			[Tooltip("The speed of lerping the root of the character towards the horizontal mid-point of the footsteps.")]
			public float rootSpeed = 20f;

			[Tooltip("The speed of steps.")]
			public float stepSpeed = 3f;

			[Tooltip("The height of the foot by normalized step progress (0 - 1).")]
			public AnimationCurve stepHeight;

			[Tooltip("The height offset of the heel by normalized step progress (0 - 1).")]
			public AnimationCurve heelHeight;

			[Tooltip("Rotates the foot while the leg is not stepping to relax the twist rotation of the leg if ideal rotation is past this angle.")]
			[Range(0f, 180f)]
			public float relaxLegTwistMinAngle = 20f;

			[Tooltip("The speed of rotating the foot while the leg is not stepping to relax the twist rotation of the leg.")]
			public float relaxLegTwistSpeed = 400f;

			[Tooltip("Interpolation mode of the step.")]
			public InterpolationMode stepInterpolation = InterpolationMode.InOutSine;

			[Tooltip("Offset for the approximated center of mass.")]
			public Vector3 offset;

			[HideInInspector]
			public bool blockingEnabled;

			[HideInInspector]
			public LayerMask blockingLayers;

			[HideInInspector]
			public float raycastRadius = 0.2f;

			[HideInInspector]
			public float raycastHeight = 0.2f;

			[Tooltip("Called when the left foot has finished a step.")]
			public UnityEvent onLeftFootstep = new UnityEvent();

			[Tooltip("Called when the right foot has finished a step")]
			public UnityEvent onRightFootstep = new UnityEvent();

			private Footstep[] footsteps = new Footstep[0];

			private Vector3 lastComPosition;

			private Vector3 comVelocity;

			private int leftFootIndex;

			private int rightFootIndex;

			public Vector3 centerOfMass { get; private set; }

			public Vector3 leftFootstepPosition => footsteps[0].position;

			public Vector3 rightFootstepPosition => footsteps[1].position;

			public Quaternion leftFootstepRotation => footsteps[0].rotation;

			public Quaternion rightFootstepRotation => footsteps[1].rotation;

			public void Initiate(Vector3[] positions, Quaternion[] rotations, bool hasToes)
			{
				leftFootIndex = ((!hasToes) ? 16 : 17);
				rightFootIndex = ((!hasToes) ? 20 : 21);
				footsteps = new Footstep[2]
				{
					new Footstep(rotations[0], positions[leftFootIndex], rotations[leftFootIndex], footDistance * Vector3.left),
					new Footstep(rotations[0], positions[rightFootIndex], rotations[rightFootIndex], footDistance * Vector3.right)
				};
			}

			public void Reset(Vector3[] positions, Quaternion[] rotations)
			{
				lastComPosition = Vector3.Lerp(positions[1], positions[5], 0.25f) + rotations[0] * offset;
				comVelocity = Vector3.zero;
				footsteps[0].Reset(rotations[0], positions[leftFootIndex], rotations[leftFootIndex]);
				footsteps[1].Reset(rotations[0], positions[rightFootIndex], rotations[rightFootIndex]);
			}

			public void AddDeltaRotation(Quaternion delta, Vector3 pivot)
			{
				Vector3 vector = lastComPosition - pivot;
				lastComPosition = pivot + delta * vector;
				Footstep[] array = footsteps;
				foreach (Footstep footstep in array)
				{
					footstep.rotation = delta * footstep.rotation;
					footstep.stepFromRot = delta * footstep.stepFromRot;
					footstep.stepToRot = delta * footstep.stepToRot;
					footstep.stepToRootRot = delta * footstep.stepToRootRot;
					Vector3 vector2 = footstep.position - pivot;
					footstep.position = pivot + delta * vector2;
					Vector3 vector3 = footstep.stepFrom - pivot;
					footstep.stepFrom = pivot + delta * vector3;
					Vector3 vector4 = footstep.stepTo - pivot;
					footstep.stepTo = pivot + delta * vector4;
				}
			}

			public void AddDeltaPosition(Vector3 delta)
			{
				lastComPosition += delta;
				Footstep[] array = footsteps;
				foreach (Footstep footstep in array)
				{
					footstep.position += delta;
					footstep.stepFrom += delta;
					footstep.stepTo += delta;
				}
			}

			public void Solve(VirtualBone rootBone, Spine spine, Leg leftLeg, Leg rightLeg, Arm leftArm, Arm rightArm, int supportLegIndex, out Vector3 leftFootPosition, out Vector3 rightFootPosition, out Quaternion leftFootRotation, out Quaternion rightFootRotation, out float leftFootOffset, out float rightFootOffset, out float leftHeelOffset, out float rightHeelOffset)
			{
				if (weight <= 0f)
				{
					leftFootPosition = Vector3.zero;
					rightFootPosition = Vector3.zero;
					leftFootRotation = Quaternion.identity;
					rightFootRotation = Quaternion.identity;
					leftFootOffset = 0f;
					rightFootOffset = 0f;
					leftHeelOffset = 0f;
					rightHeelOffset = 0f;
					return;
				}
				Vector3 vector = rootBone.solverRotation * Vector3.up;
				Vector3 vector2 = spine.pelvis.solverPosition + spine.pelvis.solverRotation * leftLeg.thighRelativeToPelvis;
				Vector3 vector3 = spine.pelvis.solverPosition + spine.pelvis.solverRotation * rightLeg.thighRelativeToPelvis;
				footsteps[0].characterSpaceOffset = footDistance * Vector3.left;
				footsteps[1].characterSpaceOffset = footDistance * Vector3.right;
				Vector3 faceDirection = spine.faceDirection;
				Vector3 vector4 = V3Tools.ExtractVertical(faceDirection, vector, 1f);
				faceDirection -= vector4;
				Quaternion quaternion = Quaternion.LookRotation(faceDirection, vector);
				float num = 1f;
				float num2 = 1f;
				float num3 = 0.2f;
				float num4 = num + num2 + 2f * num3;
				centerOfMass = Vector3.zero;
				centerOfMass += spine.pelvis.solverPosition * num;
				centerOfMass += spine.head.solverPosition * num2;
				centerOfMass += leftArm.position * num3;
				centerOfMass += rightArm.position * num3;
				centerOfMass /= num4;
				centerOfMass += rootBone.solverRotation * offset;
				comVelocity = ((!(Time.deltaTime > 0f)) ? Vector3.zero : ((centerOfMass - lastComPosition) / Time.deltaTime));
				lastComPosition = centerOfMass;
				comVelocity = Vector3.ClampMagnitude(comVelocity, maxVelocity) * velocityFactor;
				Vector3 vector5 = centerOfMass + comVelocity;
				Vector3 vector6 = V3Tools.PointToPlane(spine.pelvis.solverPosition, rootBone.solverPosition, vector);
				Vector3 vector7 = V3Tools.PointToPlane(vector5, rootBone.solverPosition, vector);
				Vector3 vector8 = Vector3.Lerp(footsteps[0].position, footsteps[1].position, 0.5f);
				Vector3 from = vector5 - vector8;
				float num5 = Vector3.Angle(from, rootBone.solverRotation * Vector3.up) * comAngleMlp;
				for (int i = 0; i < footsteps.Length; i++)
				{
					footsteps[i].isSupportLeg = supportLegIndex == i;
				}
				for (int j = 0; j < footsteps.Length; j++)
				{
					if (footsteps[j].isStepping)
					{
						Vector3 vector9 = vector7 + rootBone.solverRotation * footsteps[j].characterSpaceOffset;
						if (!StepBlocked(footsteps[j].stepFrom, vector9, rootBone.solverPosition))
						{
							footsteps[j].UpdateStepping(vector9, quaternion, 10f);
						}
					}
					else
					{
						footsteps[j].UpdateStanding(quaternion, relaxLegTwistMinAngle, relaxLegTwistSpeed);
					}
				}
				if (CanStep())
				{
					int num6 = -1;
					float num7 = float.NegativeInfinity;
					for (int k = 0; k < footsteps.Length; k++)
					{
						if (footsteps[k].isStepping)
						{
							continue;
						}
						Vector3 vector10 = vector7 + rootBone.solverRotation * footsteps[k].characterSpaceOffset;
						float num8 = ((k != 0) ? rightLeg.mag : leftLeg.mag);
						Vector3 b = ((k != 0) ? vector3 : vector2);
						float num9 = Vector3.Distance(footsteps[k].position, b);
						bool flag = false;
						if (num9 >= num8 * maxLegStretch)
						{
							vector10 = vector6 + rootBone.solverRotation * footsteps[k].characterSpaceOffset;
							flag = true;
						}
						bool flag2 = false;
						for (int l = 0; l < footsteps.Length; l++)
						{
							if (l != k && !flag)
							{
								if (!(Vector3.Distance(footsteps[k].position, footsteps[l].position) < 0.25f) || !((footsteps[k].position - vector10).sqrMagnitude < (footsteps[l].position - vector10).sqrMagnitude))
								{
									flag2 = GetLineSphereCollision(footsteps[k].position, vector10, footsteps[l].position, 0.25f);
								}
								if (flag2)
								{
									break;
								}
							}
						}
						float num10 = Quaternion.Angle(quaternion, footsteps[k].stepToRootRot);
						if (flag2 && !(num10 > angleThreshold))
						{
							continue;
						}
						float num11 = Vector3.Distance(footsteps[k].position, vector10);
						float num12 = Mathf.Lerp(stepThreshold, stepThreshold * 0.1f, num5 * 0.015f);
						if (flag)
						{
							num12 *= 0.5f;
						}
						if (k == 0)
						{
							num12 *= 0.9f;
						}
						if (!StepBlocked(footsteps[k].position, vector10, rootBone.solverPosition) && (num11 > num12 || num10 > angleThreshold))
						{
							float num13 = 0f;
							num13 -= num11;
							if (num13 > num7)
							{
								num6 = k;
								num7 = num13;
							}
						}
					}
					if (num6 != -1)
					{
						Vector3 p = vector7 + rootBone.solverRotation * footsteps[num6].characterSpaceOffset;
						footsteps[num6].stepSpeed = Random.Range(stepSpeed, stepSpeed * 1.5f);
						footsteps[num6].StepTo(p, quaternion);
					}
				}
				footsteps[0].Update(stepInterpolation, onLeftFootstep);
				footsteps[1].Update(stepInterpolation, onRightFootstep);
				leftFootPosition = footsteps[0].position;
				rightFootPosition = footsteps[1].position;
				leftFootPosition = V3Tools.PointToPlane(leftFootPosition, leftLeg.lastBone.readPosition, vector);
				rightFootPosition = V3Tools.PointToPlane(rightFootPosition, rightLeg.lastBone.readPosition, vector);
				leftFootOffset = stepHeight.Evaluate(footsteps[0].stepProgress);
				rightFootOffset = stepHeight.Evaluate(footsteps[1].stepProgress);
				leftHeelOffset = heelHeight.Evaluate(footsteps[0].stepProgress);
				rightHeelOffset = heelHeight.Evaluate(footsteps[1].stepProgress);
				leftFootRotation = footsteps[0].rotation;
				rightFootRotation = footsteps[1].rotation;
			}

			private bool StepBlocked(Vector3 fromPosition, Vector3 toPosition, Vector3 rootPosition)
			{
				if ((int)blockingLayers == -1 || !blockingEnabled)
				{
					return false;
				}
				Vector3 vector = fromPosition;
				vector.y = rootPosition.y + raycastHeight + raycastRadius;
				Vector3 direction = toPosition - vector;
				direction.y = 0f;
				RaycastHit hitInfo;
				if (raycastRadius <= 0f)
				{
					return Physics.Raycast(vector, direction, out hitInfo, direction.magnitude, blockingLayers);
				}
				return Physics.SphereCast(vector, raycastRadius, direction, out hitInfo, direction.magnitude, blockingLayers);
			}

			private bool CanStep()
			{
				Footstep[] array = footsteps;
				foreach (Footstep footstep in array)
				{
					if (footstep.isStepping && footstep.stepProgress < 0.8f)
					{
						return false;
					}
				}
				return true;
			}

			private static bool GetLineSphereCollision(Vector3 lineStart, Vector3 lineEnd, Vector3 sphereCenter, float sphereRadius)
			{
				Vector3 forward = lineEnd - lineStart;
				Vector3 vector = sphereCenter - lineStart;
				float magnitude = vector.magnitude;
				float num = magnitude - sphereRadius;
				if (num > forward.magnitude)
				{
					return false;
				}
				Quaternion rotation = Quaternion.LookRotation(forward, vector);
				Vector3 vector2 = Quaternion.Inverse(rotation) * vector;
				if (vector2.z < 0f)
				{
					return num < 0f;
				}
				return vector2.y - sphereRadius < 0f;
			}
		}

		[Serializable]
		public class Spine : BodyPart
		{
			[Tooltip("The head target.")]
			public Transform headTarget;

			[Tooltip("The pelvis target, useful with seated rigs.")]
			public Transform pelvisTarget;

			[Tooltip("Positional weight of the head target.")]
			[Range(0f, 1f)]
			public float positionWeight = 1f;

			[Tooltip("Rotational weight of the head target.")]
			[Range(0f, 1f)]
			public float rotationWeight = 1f;

			[Tooltip("Positional weight of the pelvis target.")]
			[Range(0f, 1f)]
			public float pelvisPositionWeight;

			[Tooltip("Rotational weight of the pelvis target.")]
			[Range(0f, 1f)]
			public float pelvisRotationWeight;

			[Tooltip("If 'Chest Goal Weight' is greater than 0, the chest will be turned towards this Transform.")]
			public Transform chestGoal;

			[Tooltip("Rotational weight of the chest target.")]
			[Range(0f, 1f)]
			public float chestGoalWeight;

			[Tooltip("Minimum height of the head from the root of the character.")]
			public float minHeadHeight = 0.8f;

			[Tooltip("Determines how much the body will follow the position of the head.")]
			[Range(0f, 1f)]
			public float bodyPosStiffness = 0.55f;

			[Tooltip("Determines how much the body will follow the rotation of the head.")]
			[Range(0f, 1f)]
			public float bodyRotStiffness = 0.1f;

			[Tooltip("Determines how much the chest will rotate to the rotation of the head.")]
			[FormerlySerializedAs("chestRotationWeight")]
			[Range(0f, 1f)]
			public float neckStiffness = 0.2f;

			[Tooltip("Clamps chest rotation.")]
			[Range(0f, 1f)]
			public float chestClampWeight = 0.5f;

			[Tooltip("Clamps head rotation.")]
			[Range(0f, 1f)]
			public float headClampWeight = 0.6f;

			[Tooltip("How much will the pelvis maintain it's animated position?")]
			[Range(0f, 1f)]
			public float maintainPelvisPosition = 0.2f;

			[Tooltip("Will automatically rotate the root of the character if the head target has turned past this angle.")]
			[Range(0f, 180f)]
			public float maxRootAngle = 25f;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPositionHead;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotationHead = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPositionPelvis;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotationPelvis = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 goalPositionChest;

			[NonSerialized]
			[HideInInspector]
			public Vector3 pelvisPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 chestPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 headPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Quaternion pelvisRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Quaternion chestRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Quaternion headRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 faceDirection;

			[NonSerialized]
			[HideInInspector]
			public Vector3 locomotionHeadPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 headPosition;

			private Quaternion headRotation = Quaternion.identity;

			private Quaternion anchorRelativeToHead = Quaternion.identity;

			private Quaternion pelvisRelativeRotation = Quaternion.identity;

			private Quaternion chestRelativeRotation = Quaternion.identity;

			private Vector3 headDeltaPosition;

			private Quaternion pelvisDeltaRotation = Quaternion.identity;

			private Quaternion chestTargetRotation = Quaternion.identity;

			private int pelvisIndex;

			private int spineIndex = 1;

			private int chestIndex = -1;

			private int neckIndex = -1;

			private int headIndex = -1;

			private float length;

			private bool hasChest;

			private bool hasNeck;

			private float headHeight;

			private float sizeMlp;

			private Vector3 chestForward;

			public VirtualBone pelvis => bones[pelvisIndex];

			public VirtualBone firstSpineBone => bones[spineIndex];

			public VirtualBone chest
			{
				get
				{
					if (hasChest)
					{
						return bones[chestIndex];
					}
					return bones[spineIndex];
				}
			}

			private VirtualBone neck => bones[neckIndex];

			public VirtualBone head => bones[headIndex];

			public Quaternion anchorRotation { get; private set; }

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 vector3 = positions[index + 2];
				Quaternion quaternion3 = rotations[index + 2];
				Vector3 position = positions[index + 3];
				Quaternion rotation = rotations[index + 3];
				Vector3 vector4 = positions[index + 4];
				Quaternion quaternion4 = rotations[index + 4];
				if (!hasChest)
				{
					vector3 = vector2;
					quaternion3 = quaternion2;
				}
				if (!initiated)
				{
					this.hasChest = hasChest;
					this.hasNeck = hasNeck;
					headHeight = V3Tools.ExtractVertical(vector4 - positions[0], rotations[0] * Vector3.up, 1f).magnitude;
					int num = 3;
					if (hasChest)
					{
						num++;
					}
					if (hasNeck)
					{
						num++;
					}
					bones = new VirtualBone[num];
					chestIndex = ((!hasChest) ? 1 : 2);
					neckIndex = 1;
					if (hasChest)
					{
						neckIndex++;
					}
					if (hasNeck)
					{
						neckIndex++;
					}
					headIndex = 2;
					if (hasChest)
					{
						headIndex++;
					}
					if (hasNeck)
					{
						headIndex++;
					}
					bones[0] = new VirtualBone(vector, quaternion);
					bones[1] = new VirtualBone(vector2, quaternion2);
					if (hasChest)
					{
						bones[chestIndex] = new VirtualBone(vector3, quaternion3);
					}
					if (hasNeck)
					{
						bones[neckIndex] = new VirtualBone(position, rotation);
					}
					bones[headIndex] = new VirtualBone(vector4, quaternion4);
					pelvisRotationOffset = Quaternion.identity;
					chestRotationOffset = Quaternion.identity;
					headRotationOffset = Quaternion.identity;
					anchorRelativeToHead = Quaternion.Inverse(quaternion4) * rotations[0];
					pelvisRelativeRotation = Quaternion.Inverse(quaternion4) * quaternion;
					chestRelativeRotation = Quaternion.Inverse(quaternion4) * quaternion3;
					chestForward = Quaternion.Inverse(quaternion3) * (rotations[0] * Vector3.forward);
					faceDirection = rotations[0] * Vector3.forward;
					IKPositionHead = vector4;
					IKRotationHead = quaternion4;
					IKPositionPelvis = vector;
					IKRotationPelvis = quaternion;
					goalPositionChest = vector3 + rotations[0] * Vector3.forward;
				}
				bones[0].Read(vector, quaternion);
				bones[1].Read(vector2, quaternion2);
				if (hasChest)
				{
					bones[chestIndex].Read(vector3, quaternion3);
				}
				if (hasNeck)
				{
					bones[neckIndex].Read(position, rotation);
				}
				bones[headIndex].Read(vector4, quaternion4);
				float num2 = Vector3.Distance(vector, vector4);
				sizeMlp = num2 / 0.7f;
			}

			public override void PreSolve()
			{
				if (headTarget != null)
				{
					IKPositionHead = headTarget.position;
					IKRotationHead = headTarget.rotation;
				}
				if (chestGoal != null)
				{
					goalPositionChest = chestGoal.position;
				}
				if (pelvisTarget != null)
				{
					IKPositionPelvis = pelvisTarget.position;
					IKRotationPelvis = pelvisTarget.rotation;
				}
				headPosition = V3Tools.Lerp(head.solverPosition, IKPositionHead, positionWeight);
				headRotation = QuaTools.Lerp(head.solverRotation, IKRotationHead, rotationWeight);
			}

			public override void ApplyOffsets()
			{
				headPosition += headPositionOffset;
				Vector3 vector = rootRotation * Vector3.up;
				if (vector == Vector3.up)
				{
					headPosition.y = Math.Max(rootPosition.y + minHeadHeight, headPosition.y);
				}
				else
				{
					Vector3 vector2 = headPosition - rootPosition;
					Vector3 vector3 = V3Tools.ExtractHorizontal(vector2, vector, 1f);
					Vector3 vector4 = vector2 - vector3;
					float num = Vector3.Dot(vector4, vector);
					if (num > 0f)
					{
						if (vector4.magnitude < minHeadHeight)
						{
							vector4 = vector4.normalized * minHeadHeight;
						}
					}
					else
					{
						vector4 = -vector4.normalized * minHeadHeight;
					}
					headPosition = rootPosition + vector3 + vector4;
				}
				headRotation = headRotationOffset * headRotation;
				headDeltaPosition = headPosition - head.solverPosition;
				pelvisDeltaRotation = QuaTools.FromToRotation(pelvis.solverRotation, headRotation * pelvisRelativeRotation);
				anchorRotation = headRotation * anchorRelativeToHead;
			}

			private void CalculateChestTargetRotation(VirtualBone rootBone, Arm[] arms)
			{
				chestTargetRotation = headRotation * chestRelativeRotation;
				AdjustChestByHands(ref chestTargetRotation, arms);
				faceDirection = Vector3.Cross(anchorRotation * Vector3.right, rootBone.readRotation * Vector3.up) + anchorRotation * Vector3.forward;
			}

			public void Solve(VirtualBone rootBone, Leg[] legs, Arm[] arms)
			{
				CalculateChestTargetRotation(rootBone, arms);
				if (maxRootAngle < 180f)
				{
					Vector3 vector = Quaternion.Inverse(rootBone.solverRotation) * faceDirection;
					float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					float angle = 0f;
					float num2 = 25f;
					if (num > num2)
					{
						angle = num - num2;
					}
					if (num < 0f - num2)
					{
						angle = num + num2;
					}
					rootBone.solverRotation = Quaternion.AngleAxis(angle, rootBone.readRotation * Vector3.up) * rootBone.solverRotation;
				}
				Vector3 solverPosition = pelvis.solverPosition;
				TranslatePelvis(legs, headDeltaPosition, pelvisDeltaRotation);
				VirtualBone.SolveFABRIK(bones, Vector3.Lerp(pelvis.solverPosition, solverPosition, maintainPelvisPosition) + pelvisPositionOffset - chestPositionOffset, headPosition - chestPositionOffset, 1f, 1f, 1, base.mag);
				Bend(bones, pelvisIndex, chestIndex, chestTargetRotation, chestRotationOffset, chestClampWeight, uniformWeight: false, neckStiffness);
				if (chestGoalWeight > 0f)
				{
					Quaternion targetRotation = Quaternion.FromToRotation(bones[chestIndex].solverRotation * chestForward, goalPositionChest - bones[chestIndex].solverPosition) * bones[chestIndex].solverRotation;
					Bend(bones, pelvisIndex, chestIndex, targetRotation, chestRotationOffset, chestClampWeight, uniformWeight: false, chestGoalWeight);
				}
				InverseTranslateToHead(legs, limited: false, useCurrentLegMag: false, Vector3.zero, 1f);
				VirtualBone.SolveFABRIK(bones, Vector3.Lerp(pelvis.solverPosition, solverPosition, maintainPelvisPosition) + pelvisPositionOffset - chestPositionOffset, headPosition - chestPositionOffset, 1f, 1f, 1, base.mag);
				Bend(bones, neckIndex, headIndex, headRotation, headClampWeight, uniformWeight: true, 1f);
				SolvePelvis();
			}

			private void SolvePelvis()
			{
				if (pelvisPositionWeight > 0f)
				{
					Quaternion solverRotation = head.solverRotation;
					Vector3 vector = (IKPositionPelvis + pelvisPositionOffset - pelvis.solverPosition) * pelvisPositionWeight;
					VirtualBone[] array = bones;
					foreach (VirtualBone virtualBone in array)
					{
						virtualBone.solverPosition += vector;
					}
					Vector3 bendNormal = anchorRotation * Vector3.right;
					if (hasChest && hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.6f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, chestIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.6f);
						VirtualBone.SolveTrigonometric(bones, chestIndex, neckIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (hasChest && !hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.75f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, chestIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (!hasChest && hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.75f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, neckIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (!hasNeck && !hasChest)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight);
					}
					head.solverRotation = solverRotation;
				}
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				ref Vector3 reference = ref solvedPositions[index];
				reference = bones[0].solverPosition;
				ref Quaternion reference2 = ref solvedRotations[index];
				reference2 = bones[0].solverRotation;
				ref Quaternion reference3 = ref solvedRotations[index + 1];
				reference3 = bones[1].solverRotation;
				if (hasChest)
				{
					ref Quaternion reference4 = ref solvedRotations[index + 2];
					reference4 = bones[chestIndex].solverRotation;
				}
				if (hasNeck)
				{
					ref Quaternion reference5 = ref solvedRotations[index + 3];
					reference5 = bones[neckIndex].solverRotation;
				}
				ref Quaternion reference6 = ref solvedRotations[index + 4];
				reference6 = bones[headIndex].solverRotation;
			}

			public override void ResetOffsets()
			{
				pelvisPositionOffset = Vector3.zero;
				chestPositionOffset = Vector3.zero;
				headPositionOffset = locomotionHeadPositionOffset;
				pelvisRotationOffset = Quaternion.identity;
				chestRotationOffset = Quaternion.identity;
				headRotationOffset = Quaternion.identity;
			}

			private void AdjustChestByHands(ref Quaternion chestTargetRotation, Arm[] arms)
			{
				Quaternion quaternion = Quaternion.Inverse(anchorRotation);
				Vector3 vector = quaternion * (arms[0].position - headPosition) / sizeMlp;
				Vector3 vector2 = quaternion * (arms[1].position - headPosition) / sizeMlp;
				Vector3 forward = Vector3.forward;
				forward.x += vector.x * Mathf.Abs(vector.x);
				forward.x += vector.z * Mathf.Abs(vector.z);
				forward.x += vector2.x * Mathf.Abs(vector2.x);
				forward.x -= vector2.z * Mathf.Abs(vector2.z);
				forward.x *= 5f;
				Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, forward);
				chestTargetRotation = quaternion2 * chestTargetRotation;
				Vector3 up = Vector3.up;
				up.x += vector.y;
				up.x -= vector2.y;
				up.x *= 0.5f;
				quaternion2 = Quaternion.FromToRotation(Vector3.up, anchorRotation * up);
				chestTargetRotation = quaternion2 * chestTargetRotation;
			}

			public void InverseTranslateToHead(Leg[] legs, bool limited, bool useCurrentLegMag, Vector3 offset, float w)
			{
				Vector3 vector = pelvis.solverPosition + (headPosition + offset - head.solverPosition) * w * (1f - pelvisPositionWeight);
				MovePosition((!limited) ? vector : LimitPelvisPosition(legs, vector, useCurrentLegMag));
			}

			private void TranslatePelvis(Leg[] legs, Vector3 deltaPosition, Quaternion deltaRotation)
			{
				Vector3 solverPosition = head.solverPosition;
				deltaRotation = QuaTools.ClampRotation(deltaRotation, chestClampWeight, 2);
				Quaternion a = Quaternion.Slerp(Quaternion.identity, deltaRotation, bodyRotStiffness);
				a = Quaternion.Slerp(a, QuaTools.FromToRotation(pelvis.solverRotation, IKRotationPelvis), pelvisRotationWeight);
				VirtualBone.RotateAroundPoint(bones, 0, pelvis.solverPosition, pelvisRotationOffset * a);
				deltaPosition -= head.solverPosition - solverPosition;
				Vector3 vector = rootRotation * Vector3.forward;
				vector.y = 0f;
				float num = deltaPosition.y * 0.35f * headHeight;
				deltaPosition += vector * num;
				MovePosition(LimitPelvisPosition(legs, pelvis.solverPosition + deltaPosition * bodyPosStiffness, useCurrentLegMag: false));
			}

			private Vector3 LimitPelvisPosition(Leg[] legs, Vector3 pelvisPosition, bool useCurrentLegMag, int it = 2)
			{
				if (useCurrentLegMag)
				{
					foreach (Leg leg in legs)
					{
						leg.currentMag = Vector3.Distance(leg.thigh.solverPosition, leg.lastBone.solverPosition);
					}
				}
				for (int j = 0; j < it; j++)
				{
					foreach (Leg leg2 in legs)
					{
						Vector3 vector = pelvisPosition - pelvis.solverPosition;
						Vector3 vector2 = leg2.thigh.solverPosition + vector;
						Vector3 vector3 = vector2 - leg2.position;
						float maxLength = ((!useCurrentLegMag) ? leg2.mag : leg2.currentMag);
						Vector3 vector4 = leg2.position + Vector3.ClampMagnitude(vector3, maxLength);
						pelvisPosition += vector4 - vector2;
					}
				}
				return pelvisPosition;
			}

			private void Bend(VirtualBone[] bones, int firstIndex, int lastIndex, Quaternion targetRotation, float clampWeight, bool uniformWeight, float w)
			{
				if (w <= 0f || bones.Length == 0)
				{
					return;
				}
				int num = lastIndex + 1 - firstIndex;
				if (num < 1)
				{
					return;
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[lastIndex].solverRotation, targetRotation);
				rotation = QuaTools.ClampRotation(rotation, clampWeight, 2);
				float num2 = ((!uniformWeight) ? 0f : (1f / (float)num));
				for (int i = firstIndex; i < lastIndex + 1; i++)
				{
					if (!uniformWeight)
					{
						num2 = Mathf.Clamp((i - firstIndex + 1) / num, 0f, 1f);
					}
					VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, Quaternion.Slerp(Quaternion.identity, rotation, num2 * w));
				}
			}

			private void Bend(VirtualBone[] bones, int firstIndex, int lastIndex, Quaternion targetRotation, Quaternion rotationOffset, float clampWeight, bool uniformWeight, float w)
			{
				if (w <= 0f || bones.Length == 0)
				{
					return;
				}
				int num = lastIndex + 1 - firstIndex;
				if (num < 1)
				{
					return;
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[lastIndex].solverRotation, targetRotation);
				rotation = QuaTools.ClampRotation(rotation, clampWeight, 2);
				float num2 = ((!uniformWeight) ? 0f : (1f / (float)num));
				for (int i = firstIndex; i < lastIndex + 1; i++)
				{
					if (!uniformWeight)
					{
						num2 = Mathf.Clamp((i - firstIndex + 1) / num, 0f, 1f);
					}
					VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, Quaternion.Slerp(Quaternion.Slerp(Quaternion.identity, rotationOffset, num2), rotation, num2 * w));
				}
			}
		}

		[Serializable]
		public enum PositionOffset
		{
			Pelvis,
			Chest,
			Head,
			LeftHand,
			RightHand,
			LeftFoot,
			RightFoot,
			LeftHeel,
			RightHeel
		}

		[Serializable]
		public enum RotationOffset
		{
			Pelvis,
			Chest,
			Head
		}

		[Serializable]
		public class VirtualBone
		{
			public Vector3 readPosition;

			public Quaternion readRotation;

			public Vector3 solverPosition;

			public Quaternion solverRotation;

			public float length;

			public float sqrMag;

			public Vector3 axis;

			public VirtualBone(Vector3 position, Quaternion rotation)
			{
				Read(position, rotation);
			}

			public void Read(Vector3 position, Quaternion rotation)
			{
				readPosition = position;
				readRotation = rotation;
				solverPosition = position;
				solverRotation = rotation;
			}

			public static void SwingRotation(VirtualBone[] bones, int index, Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Quaternion quaternion = Quaternion.FromToRotation(bones[index].solverRotation * bones[index].axis, swingTarget - bones[index].solverPosition);
					if (weight < 1f)
					{
						quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
					}
					for (int i = index; i < bones.Length; i++)
					{
						bones[i].solverRotation = quaternion * bones[i].solverRotation;
					}
				}
			}

			public static float PreSolve(ref VirtualBone[] bones)
			{
				float num = 0f;
				for (int i = 0; i < bones.Length; i++)
				{
					if (i < bones.Length - 1)
					{
						bones[i].sqrMag = (bones[i + 1].solverPosition - bones[i].solverPosition).sqrMagnitude;
						bones[i].length = Mathf.Sqrt(bones[i].sqrMag);
						num += bones[i].length;
						bones[i].axis = Quaternion.Inverse(bones[i].solverRotation) * (bones[i + 1].solverPosition - bones[i].solverPosition);
					}
					else
					{
						bones[i].sqrMag = 0f;
						bones[i].length = 0f;
					}
				}
				return num;
			}

			public static void RotateAroundPoint(VirtualBone[] bones, int index, Vector3 point, Quaternion rotation)
			{
				for (int i = index; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						Vector3 vector = bones[i].solverPosition - point;
						bones[i].solverPosition = point + rotation * vector;
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateBy(VirtualBone[] bones, int index, Quaternion rotation)
			{
				for (int i = index; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						Vector3 vector = bones[i].solverPosition - bones[index].solverPosition;
						bones[i].solverPosition = bones[index].solverPosition + rotation * vector;
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateBy(VirtualBone[] bones, Quaternion rotation)
			{
				for (int i = 0; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						if (i > 0)
						{
							Vector3 vector = bones[i].solverPosition - bones[0].solverPosition;
							bones[i].solverPosition = bones[0].solverPosition + rotation * vector;
						}
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateTo(VirtualBone[] bones, int index, Quaternion rotation)
			{
				Quaternion rotation2 = QuaTools.FromToRotation(bones[index].solverRotation, rotation);
				RotateAroundPoint(bones, index, bones[index].solverPosition, rotation2);
			}

			public static void SolveTrigonometric(VirtualBone[] bones, int first, int second, int third, Vector3 targetPosition, Vector3 bendNormal, float weight)
			{
				if (weight <= 0f)
				{
					return;
				}
				targetPosition = Vector3.Lerp(bones[third].solverPosition, targetPosition, weight);
				Vector3 vector = targetPosition - bones[first].solverPosition;
				float sqrMagnitude = vector.sqrMagnitude;
				if (sqrMagnitude != 0f)
				{
					float directionMag = Mathf.Sqrt(sqrMagnitude);
					float sqrMagnitude2 = (bones[second].solverPosition - bones[first].solverPosition).sqrMagnitude;
					float sqrMagnitude3 = (bones[third].solverPosition - bones[second].solverPosition).sqrMagnitude;
					Vector3 bendDirection = Vector3.Cross(vector, bendNormal);
					Vector3 directionToBendPoint = GetDirectionToBendPoint(vector, directionMag, bendDirection, sqrMagnitude2, sqrMagnitude3);
					Quaternion quaternion = Quaternion.FromToRotation(bones[second].solverPosition - bones[first].solverPosition, directionToBendPoint);
					if (weight < 1f)
					{
						quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
					}
					RotateAroundPoint(bones, first, bones[first].solverPosition, quaternion);
					Quaternion quaternion2 = Quaternion.FromToRotation(bones[third].solverPosition - bones[second].solverPosition, targetPosition - bones[second].solverPosition);
					if (weight < 1f)
					{
						quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion2, weight);
					}
					RotateAroundPoint(bones, second, bones[second].solverPosition, quaternion2);
				}
			}

			private static Vector3 GetDirectionToBendPoint(Vector3 direction, float directionMag, Vector3 bendDirection, float sqrMag1, float sqrMag2)
			{
				float num = (directionMag * directionMag + (sqrMag1 - sqrMag2)) / 2f / directionMag;
				float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
				if (direction == Vector3.zero)
				{
					return Vector3.zero;
				}
				return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
			}

			public static void SolveFABRIK(VirtualBone[] bones, Vector3 startPosition, Vector3 targetPosition, float weight, float minNormalizedTargetDistance, int iterations, float length)
			{
				if (weight <= 0f)
				{
					return;
				}
				if (minNormalizedTargetDistance > 0f)
				{
					Vector3 vector = targetPosition - startPosition;
					float magnitude = vector.magnitude;
					targetPosition = startPosition + vector / magnitude * Mathf.Max(length * minNormalizedTargetDistance, magnitude);
				}
				for (int i = 0; i < iterations; i++)
				{
					bones[bones.Length - 1].solverPosition = Vector3.Lerp(bones[bones.Length - 1].solverPosition, targetPosition, weight);
					for (int num = bones.Length - 2; num > -1; num--)
					{
						bones[num].solverPosition = SolveFABRIKJoint(bones[num].solverPosition, bones[num + 1].solverPosition, bones[num].length);
					}
					bones[0].solverPosition = startPosition;
					for (int j = 1; j < bones.Length; j++)
					{
						bones[j].solverPosition = SolveFABRIKJoint(bones[j].solverPosition, bones[j - 1].solverPosition, bones[j - 1].length);
					}
				}
				for (int k = 0; k < bones.Length - 1; k++)
				{
					SwingRotation(bones, k, bones[k + 1].solverPosition);
				}
			}

			private static Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
			{
				return pos2 + (pos1 - pos2).normalized * length;
			}

			public static void SolveCCD(VirtualBone[] bones, Vector3 targetPosition, float weight, int iterations)
			{
				if (weight <= 0f)
				{
					return;
				}
				for (int i = 0; i < iterations; i++)
				{
					for (int num = bones.Length - 2; num > -1; num--)
					{
						Vector3 fromDirection = bones[bones.Length - 1].solverPosition - bones[num].solverPosition;
						Vector3 toDirection = targetPosition - bones[num].solverPosition;
						Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
						if (weight >= 1f)
						{
							RotateBy(bones, num, quaternion);
						}
						else
						{
							RotateBy(bones, num, Quaternion.Lerp(Quaternion.identity, quaternion, weight));
						}
					}
				}
			}
		}

		private Transform[] solverTransforms = new Transform[0];

		private bool hasChest;

		private bool hasNeck;

		private bool hasShoulders;

		private bool hasToes;

		private Vector3[] readPositions = new Vector3[0];

		private Quaternion[] readRotations = new Quaternion[0];

		private Vector3[] solvedPositions = new Vector3[2];

		private Quaternion[] solvedRotations = new Quaternion[22];

		private Vector3 defaultPelvisLocalPosition;

		private Quaternion[] defaultLocalRotations = new Quaternion[21];

		private Vector3 rootV;

		private Vector3 rootVelocity;

		private Vector3 bodyOffset;

		private int supportLegIndex;

		[Tooltip("If true, will keep the toes planted even if head target is out of reach.")]
		public bool plantFeet = true;

		[Tooltip("The spine solver.")]
		public Spine spine = new Spine();

		[Tooltip("The left arm solver.")]
		public Arm leftArm = new Arm();

		[Tooltip("The right arm solver.")]
		public Arm rightArm = new Arm();

		[Tooltip("The left leg solver.")]
		public Leg leftLeg = new Leg();

		[Tooltip("The right leg solver.")]
		public Leg rightLeg = new Leg();

		[Tooltip("The procedural locomotion solver.")]
		public Locomotion locomotion = new Locomotion();

		private Leg[] legs = new Leg[2];

		private Arm[] arms = new Arm[2];

		private Vector3 headPosition;

		private Vector3 headDeltaPosition;

		private Vector3 raycastOriginPelvis;

		private Vector3 lastOffset;

		private Vector3 debugPos1;

		private Vector3 debugPos2;

		private Vector3 debugPos3;

		private Vector3 debugPos4;

		[HideInInspector]
		public VirtualBone rootBone { get; private set; }

		public void SetToReferences(VRIK.References references)
		{
			if (!references.isFilled)
			{
				Debug.LogError("Invalid references, one or more Transforms are missing.");
				return;
			}
			solverTransforms = references.GetTransforms();
			hasChest = solverTransforms[3] != null;
			hasNeck = solverTransforms[4] != null;
			hasShoulders = solverTransforms[6] != null && solverTransforms[10] != null;
			hasToes = solverTransforms[17] != null && solverTransforms[21] != null;
			readPositions = new Vector3[solverTransforms.Length];
			readRotations = new Quaternion[solverTransforms.Length];
			DefaultAnimationCurves();
			GuessHandOrientations(references, onlyIfZero: true);
		}

		public void GuessHandOrientations(VRIK.References references, bool onlyIfZero)
		{
			if (!references.isFilled)
			{
				Debug.LogWarning("VRIK References are not filled in, can not guess hand orientations. Right-click on VRIK header and slect 'Guess Hand Orientations' when you have filled in the References.");
				return;
			}
			if (leftArm.wristToPalmAxis == Vector3.zero || !onlyIfZero)
			{
				leftArm.wristToPalmAxis = GuessWristToPalmAxis(references.leftHand, references.leftForearm);
			}
			if (leftArm.palmToThumbAxis == Vector3.zero || !onlyIfZero)
			{
				leftArm.palmToThumbAxis = GuessPalmToThumbAxis(references.leftHand, references.leftForearm);
			}
			if (rightArm.wristToPalmAxis == Vector3.zero || !onlyIfZero)
			{
				rightArm.wristToPalmAxis = GuessWristToPalmAxis(references.rightHand, references.rightForearm);
			}
			if (rightArm.palmToThumbAxis == Vector3.zero || !onlyIfZero)
			{
				rightArm.palmToThumbAxis = GuessPalmToThumbAxis(references.rightHand, references.rightForearm);
			}
		}

		public void DefaultAnimationCurves()
		{
			if (locomotion.stepHeight == null)
			{
				locomotion.stepHeight = new AnimationCurve();
			}
			if (locomotion.heelHeight == null)
			{
				locomotion.heelHeight = new AnimationCurve();
			}
			if (locomotion.stepHeight.keys.Length == 0)
			{
				locomotion.stepHeight.keys = GetSineKeyframes(0.03f);
			}
			if (locomotion.heelHeight.keys.Length == 0)
			{
				locomotion.heelHeight.keys = GetSineKeyframes(0.03f);
			}
		}

		public void AddPositionOffset(PositionOffset positionOffset, Vector3 value)
		{
			switch (positionOffset)
			{
			case PositionOffset.Pelvis:
				spine.pelvisPositionOffset += value;
				break;
			case PositionOffset.Chest:
				spine.chestPositionOffset += value;
				break;
			case PositionOffset.Head:
				spine.headPositionOffset += value;
				break;
			case PositionOffset.LeftHand:
				leftArm.handPositionOffset += value;
				break;
			case PositionOffset.RightHand:
				rightArm.handPositionOffset += value;
				break;
			case PositionOffset.LeftFoot:
				leftLeg.footPositionOffset += value;
				break;
			case PositionOffset.RightFoot:
				rightLeg.footPositionOffset += value;
				break;
			case PositionOffset.LeftHeel:
				leftLeg.heelPositionOffset += value;
				break;
			case PositionOffset.RightHeel:
				rightLeg.heelPositionOffset += value;
				break;
			}
		}

		public void AddRotationOffset(RotationOffset rotationOffset, Vector3 value)
		{
			AddRotationOffset(rotationOffset, Quaternion.Euler(value));
		}

		public void AddRotationOffset(RotationOffset rotationOffset, Quaternion value)
		{
			switch (rotationOffset)
			{
			case RotationOffset.Pelvis:
				spine.pelvisRotationOffset = value * spine.pelvisRotationOffset;
				break;
			case RotationOffset.Chest:
				spine.chestRotationOffset = value * spine.chestRotationOffset;
				break;
			case RotationOffset.Head:
				spine.headRotationOffset = value * spine.headRotationOffset;
				break;
			}
		}

		public void AddPlatformMotion(Vector3 deltaPosition, Quaternion deltaRotation, Vector3 platformPivot)
		{
			locomotion.AddDeltaPosition(deltaPosition);
			raycastOriginPelvis += deltaPosition;
			locomotion.AddDeltaRotation(deltaRotation, platformPivot);
			spine.faceDirection = deltaRotation * spine.faceDirection;
		}

		public void Reset()
		{
			if (base.initiated)
			{
				UpdateSolverTransforms();
				Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
				spine.faceDirection = rootBone.readRotation * Vector3.forward;
				locomotion.Reset(readPositions, readRotations);
				raycastOriginPelvis = spine.pelvis.readPosition;
			}
		}

		public override void StoreDefaultLocalState()
		{
			defaultPelvisLocalPosition = solverTransforms[1].localPosition;
			for (int i = 1; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					ref Quaternion reference = ref defaultLocalRotations[i - 1];
					reference = solverTransforms[i].localRotation;
				}
			}
		}

		public override void FixTransforms()
		{
			solverTransforms[1].localPosition = defaultPelvisLocalPosition;
			for (int i = 1; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					solverTransforms[i].localRotation = defaultLocalRotations[i - 1];
				}
			}
		}

		public override Point[] GetPoints()
		{
			Debug.LogError("GetPoints() is not applicable to IKSolverVR.");
			return null;
		}

		public override Point GetPoint(Transform transform)
		{
			Debug.LogError("GetPoint is not applicable to IKSolverVR.");
			return null;
		}

		public override bool IsValid(ref string message)
		{
			if (solverTransforms == null || solverTransforms.Length == 0)
			{
				message = "Trying to initiate IKSolverVR with invalid bone references.";
				return false;
			}
			if (leftArm.wristToPalmAxis == Vector3.zero)
			{
				message = "Left arm 'Wrist To Palm Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the wrist towards the palm. If the arrow points away from the palm, axis must be negative.";
				return false;
			}
			if (rightArm.wristToPalmAxis == Vector3.zero)
			{
				message = "Right arm 'Wrist To Palm Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the wrist towards the palm. If the arrow points away from the palm, axis must be negative.";
				return false;
			}
			if (leftArm.palmToThumbAxis == Vector3.zero)
			{
				message = "Left arm 'Palm To Thumb Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the palm towards the thumb. If the arrow points away from the thumb, axis must be negative.";
				return false;
			}
			if (rightArm.palmToThumbAxis == Vector3.zero)
			{
				message = "Right arm 'Palm To Thumb Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the palm towards the thumb. If the arrow points away from the thumb, axis must be negative.";
				return false;
			}
			return true;
		}

		private Vector3 GetNormal(Transform[] transforms)
		{
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			for (int i = 0; i < transforms.Length; i++)
			{
				zero2 += transforms[i].position;
			}
			zero2 /= (float)transforms.Length;
			for (int j = 0; j < transforms.Length - 1; j++)
			{
				zero += Vector3.Cross(transforms[j].position - zero2, transforms[j + 1].position - zero2).normalized;
			}
			return zero;
		}

		private Vector3 GuessWristToPalmAxis(Transform hand, Transform forearm)
		{
			Vector3 vector = forearm.position - hand.position;
			Vector3 vector2 = AxisTools.ToVector3(AxisTools.GetAxisToDirection(hand, vector));
			if (Vector3.Dot(vector, hand.rotation * vector2) > 0f)
			{
				vector2 = -vector2;
			}
			return vector2;
		}

		private Vector3 GuessPalmToThumbAxis(Transform hand, Transform forearm)
		{
			if (hand.childCount == 0)
			{
				Debug.LogWarning("Hand " + hand.name + " does not have any fingers, VRIK can not guess the hand bone's orientation. Please assign 'Wrist To Palm Axis' and 'Palm To Thumb Axis' manually for both arms in VRIK settings.", hand);
				return Vector3.zero;
			}
			float num = float.PositiveInfinity;
			int index = 0;
			for (int i = 0; i < hand.childCount; i++)
			{
				float num2 = Vector3.SqrMagnitude(hand.GetChild(i).position - hand.position);
				if (num2 < num)
				{
					num = num2;
					index = i;
				}
			}
			Vector3 lhs = Vector3.Cross(hand.position - forearm.position, hand.GetChild(index).position - hand.position);
			Vector3 vector = Vector3.Cross(lhs, hand.position - forearm.position);
			Vector3 vector2 = AxisTools.ToVector3(AxisTools.GetAxisToDirection(hand, vector));
			if (Vector3.Dot(vector, hand.rotation * vector2) < 0f)
			{
				vector2 = -vector2;
			}
			return vector2;
		}

		private static Keyframe[] GetSineKeyframes(float mag)
		{
			Keyframe[] array = new Keyframe[3];
			array[0].time = 0f;
			array[0].value = 0f;
			array[1].time = 0.5f;
			array[1].value = mag;
			array[2].time = 1f;
			array[2].value = 0f;
			return array;
		}

		private void UpdateSolverTransforms()
		{
			for (int i = 0; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					ref Vector3 reference = ref readPositions[i];
					reference = solverTransforms[i].position;
					ref Quaternion reference2 = ref readRotations[i];
					reference2 = solverTransforms[i].rotation;
				}
			}
		}

		protected override void OnInitiate()
		{
			UpdateSolverTransforms();
			Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight > 0f)
			{
				UpdateSolverTransforms();
				Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
				Solve();
				Write();
				WriteTransforms();
			}
		}

		private void WriteTransforms()
		{
			for (int i = 0; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					if (i < 2)
					{
						solverTransforms[i].position = V3Tools.Lerp(solverTransforms[i].position, GetPosition(i), IKPositionWeight);
					}
					solverTransforms[i].rotation = QuaTools.Lerp(solverTransforms[i].rotation, GetRotation(i), IKPositionWeight);
				}
			}
		}

		private void Read(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes)
		{
			if (rootBone == null)
			{
				rootBone = new VirtualBone(positions[0], rotations[0]);
			}
			else
			{
				rootBone.Read(positions[0], rotations[0]);
			}
			spine.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 0, 1);
			leftArm.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, (!hasChest) ? 2 : 3, 6);
			rightArm.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, (!hasChest) ? 2 : 3, 10);
			leftLeg.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 1, 14);
			rightLeg.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 1, 18);
			for (int i = 0; i < rotations.Length; i++)
			{
				if (i < 2)
				{
					ref Vector3 reference = ref solvedPositions[i];
					reference = positions[i];
				}
				ref Quaternion reference2 = ref solvedRotations[i];
				reference2 = rotations[i];
			}
			if (!base.initiated)
			{
				legs = new Leg[2] { leftLeg, rightLeg };
				arms = new Arm[2] { leftArm, rightArm };
				locomotion.Initiate(positions, rotations, hasToes);
				raycastOriginPelvis = spine.pelvis.readPosition;
				spine.faceDirection = readRotations[0] * Vector3.forward;
			}
		}

		private void Solve()
		{
			spine.PreSolve();
			Arm[] array = arms;
			foreach (Arm arm in array)
			{
				arm.PreSolve();
			}
			Leg[] array2 = legs;
			foreach (Leg leg in array2)
			{
				leg.PreSolve();
			}
			Arm[] array3 = arms;
			foreach (Arm arm2 in array3)
			{
				arm2.ApplyOffsets();
			}
			spine.ApplyOffsets();
			spine.Solve(rootBone, legs, arms);
			if (spine.pelvisPositionWeight > 0f && plantFeet)
			{
				Warning.Log("If VRIK 'Pelvis Position Weight' is > 0, 'Plant Feet' should be disabled to improve performance and stability.", root);
			}
			if (locomotion.weight > 0f)
			{
				Vector3 leftFootPosition = Vector3.zero;
				Vector3 rightFootPosition = Vector3.zero;
				Quaternion leftFootRotation = Quaternion.identity;
				Quaternion rightFootRotation = Quaternion.identity;
				float leftFootOffset = 0f;
				float rightFootOffset = 0f;
				float leftHeelOffset = 0f;
				float rightHeelOffset = 0f;
				locomotion.Solve(rootBone, spine, leftLeg, rightLeg, leftArm, rightArm, supportLegIndex, out leftFootPosition, out rightFootPosition, out leftFootRotation, out rightFootRotation, out leftFootOffset, out rightFootOffset, out leftHeelOffset, out rightHeelOffset);
				leftFootPosition += root.up * leftFootOffset;
				rightFootPosition += root.up * rightFootOffset;
				leftLeg.footPositionOffset += (leftFootPosition - leftLeg.lastBone.solverPosition) * IKPositionWeight * (1f - leftLeg.positionWeight) * locomotion.weight;
				rightLeg.footPositionOffset += (rightFootPosition - rightLeg.lastBone.solverPosition) * IKPositionWeight * (1f - rightLeg.positionWeight) * locomotion.weight;
				leftLeg.heelPositionOffset += root.up * leftHeelOffset * locomotion.weight;
				rightLeg.heelPositionOffset += root.up * rightHeelOffset * locomotion.weight;
				Quaternion b = QuaTools.FromToRotation(leftLeg.lastBone.solverRotation, leftFootRotation);
				Quaternion b2 = QuaTools.FromToRotation(rightLeg.lastBone.solverRotation, rightFootRotation);
				b = Quaternion.Lerp(Quaternion.identity, b, IKPositionWeight * (1f - leftLeg.rotationWeight) * locomotion.weight);
				b2 = Quaternion.Lerp(Quaternion.identity, b2, IKPositionWeight * (1f - rightLeg.rotationWeight) * locomotion.weight);
				leftLeg.footRotationOffset = b * leftLeg.footRotationOffset;
				rightLeg.footRotationOffset = b2 * rightLeg.footRotationOffset;
				Vector3 point = Vector3.Lerp(leftLeg.position + leftLeg.footPositionOffset, rightLeg.position + rightLeg.footPositionOffset, 0.5f);
				point = V3Tools.PointToPlane(point, rootBone.solverPosition, root.up);
				rootVelocity += (point - rootBone.solverPosition) * Time.deltaTime * 10f;
				Vector3 vector = V3Tools.ExtractVertical(rootVelocity, root.up, 1f);
				rootVelocity -= vector;
				Vector3 a = rootBone.solverPosition + rootVelocity * Time.deltaTime * 2f * locomotion.weight;
				a = Vector3.Lerp(a, point, Time.deltaTime * locomotion.rootSpeed * locomotion.weight);
				rootBone.solverPosition = a;
				float num = leftFootOffset + rightFootOffset;
				bodyOffset = Vector3.Lerp(bodyOffset, root.up * num, Time.deltaTime * 3f);
				bodyOffset = Vector3.Lerp(Vector3.zero, bodyOffset, locomotion.weight);
			}
			Leg[] array4 = legs;
			foreach (Leg leg2 in array4)
			{
				leg2.ApplyOffsets();
			}
			if (!plantFeet)
			{
				spine.InverseTranslateToHead(legs, limited: false, useCurrentLegMag: false, bodyOffset, 1f);
				Leg[] array5 = legs;
				foreach (Leg leg3 in array5)
				{
					leg3.TranslateRoot(spine.pelvis.solverPosition, spine.pelvis.solverRotation);
				}
				Leg[] array6 = legs;
				foreach (Leg leg4 in array6)
				{
					leg4.Solve();
				}
			}
			else
			{
				for (int num2 = 0; num2 < 2; num2++)
				{
					spine.InverseTranslateToHead(legs, limited: true, num2 == 0, bodyOffset, 1f);
					Leg[] array7 = legs;
					foreach (Leg leg5 in array7)
					{
						leg5.TranslateRoot(spine.pelvis.solverPosition, spine.pelvis.solverRotation);
					}
					Leg[] array8 = legs;
					foreach (Leg leg6 in array8)
					{
						leg6.Solve();
					}
				}
			}
			for (int num5 = 0; num5 < arms.Length; num5++)
			{
				arms[num5].TranslateRoot(spine.chest.solverPosition, spine.chest.solverRotation);
				arms[num5].Solve(num5 == 0);
			}
			spine.ResetOffsets();
			Leg[] array9 = legs;
			foreach (Leg leg7 in array9)
			{
				leg7.ResetOffsets();
			}
			Arm[] array10 = arms;
			foreach (Arm arm3 in array10)
			{
				arm3.ResetOffsets();
			}
			spine.pelvisPositionOffset += GetPelvisOffset();
			spine.chestPositionOffset += spine.pelvisPositionOffset;
			Write();
			supportLegIndex = -1;
			float num8 = float.PositiveInfinity;
			for (int num9 = 0; num9 < legs.Length; num9++)
			{
				float num10 = Vector3.SqrMagnitude(legs[num9].lastBone.solverPosition - legs[num9].bones[0].solverPosition);
				if (num10 < num8)
				{
					supportLegIndex = num9;
					num8 = num10;
				}
			}
		}

		private Vector3 GetPosition(int index)
		{
			if (index >= 2)
			{
				Debug.LogError("Can only get root and pelvis positions from IKSolverVR. GetPosition index out of range.");
			}
			return solvedPositions[index];
		}

		private Quaternion GetRotation(int index)
		{
			return solvedRotations[index];
		}

		private void Write()
		{
			ref Vector3 reference = ref solvedPositions[0];
			reference = rootBone.solverPosition;
			ref Quaternion reference2 = ref solvedRotations[0];
			reference2 = rootBone.solverRotation;
			spine.Write(ref solvedPositions, ref solvedRotations);
			Leg[] array = legs;
			foreach (Leg leg in array)
			{
				leg.Write(ref solvedPositions, ref solvedRotations);
			}
			Arm[] array2 = arms;
			foreach (Arm arm in array2)
			{
				arm.Write(ref solvedPositions, ref solvedRotations);
			}
		}

		private Vector3 GetPelvisOffset()
		{
			if (locomotion.weight <= 0f)
			{
				return Vector3.zero;
			}
			if ((int)locomotion.blockingLayers == -1)
			{
				return Vector3.zero;
			}
			Vector3 vector = raycastOriginPelvis;
			vector.y = spine.pelvis.solverPosition.y;
			Vector3 vector2 = spine.pelvis.readPosition;
			vector2.y = spine.pelvis.solverPosition.y;
			Vector3 direction = vector2 - vector;
			RaycastHit hitInfo;
			if (locomotion.raycastRadius <= 0f)
			{
				if (Physics.Raycast(vector, direction, out hitInfo, direction.magnitude * 1.1f, locomotion.blockingLayers))
				{
					vector2 = hitInfo.point;
				}
			}
			else if (Physics.SphereCast(vector, locomotion.raycastRadius * 1.1f, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
			{
				vector2 = vector + direction.normalized * hitInfo.distance / 1.1f;
			}
			Vector3 vector3 = spine.pelvis.solverPosition;
			direction = vector3 - vector2;
			if (locomotion.raycastRadius <= 0f)
			{
				if (Physics.Raycast(vector2, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
				{
					vector3 = hitInfo.point;
				}
			}
			else if (Physics.SphereCast(vector2, locomotion.raycastRadius, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
			{
				vector3 = vector2 + direction.normalized * hitInfo.distance;
			}
			lastOffset = Vector3.Lerp(lastOffset, Vector3.zero, Time.deltaTime * 3f);
			vector3 += Vector3.ClampMagnitude(lastOffset, 0.75f);
			vector3.y = spine.pelvis.solverPosition.y;
			lastOffset = Vector3.Lerp(lastOffset, vector3 - spine.pelvis.solverPosition, Time.deltaTime * 15f);
			return lastOffset;
		}
	}
	public class TwistRelaxer : MonoBehaviour
	{
		[Tooltip("The weight of relaxing the twist of this Transform")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("If 0.5, this Transform will be twisted half way from parent to child. If 1, the twist angle will be locked to the child and will rotate with along with it.")]
		[Range(0f, 1f)]
		public float parentChildCrossfade = 0.5f;

		private Vector3 twistAxis = Vector3.right;

		private Vector3 axis = Vector3.forward;

		private Vector3 axisRelativeToParentDefault;

		private Vector3 axisRelativeToChildDefault;

		private Transform parent;

		private Transform child;

		public void Relax()
		{
			if (!(weight <= 0f))
			{
				Vector3 a = parent.rotation * axisRelativeToParentDefault;
				Vector3 b = child.rotation * axisRelativeToChildDefault;
				Vector3 vector = Vector3.Slerp(a, b, parentChildCrossfade);
				Quaternion rotation = Quaternion.LookRotation(base.transform.rotation * axis, base.transform.rotation * twistAxis);
				vector = Quaternion.Inverse(rotation) * vector;
				float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				Quaternion rotation2 = child.rotation;
				base.transform.rotation = Quaternion.AngleAxis(num * weight, base.transform.rotation * twistAxis) * base.transform.rotation;
				child.rotation = rotation2;
			}
		}

		private void Start()
		{
			parent = base.transform.parent;
			if (base.transform.childCount == 0)
			{
				Debug.LogError("The Transform of a TwistRelaxer has no children. Can not use TwistRelaxer on that bone.");
				return;
			}
			child = base.transform.GetChild(0);
			twistAxis = base.transform.InverseTransformDirection(child.position - base.transform.position);
			axis = new Vector3(twistAxis.y, twistAxis.z, twistAxis.x);
			Vector3 vector = base.transform.rotation * axis;
			axisRelativeToParentDefault = Quaternion.Inverse(parent.rotation) * vector;
			axisRelativeToChildDefault = Quaternion.Inverse(child.rotation) * vector;
		}

		private void LateUpdate()
		{
			Relax();
		}
	}
	[Serializable]
	public class InteractionEffector
	{
		private Poser poser;

		private IKEffector effector;

		private float timer;

		private float length;

		private float weight;

		private float fadeInSpeed;

		private float defaultPositionWeight;

		private float defaultRotationWeight;

		private float defaultPull;

		private float defaultReach;

		private float defaultPush;

		private float defaultPushParent;

		private float resetTimer;

		private bool positionWeightUsed;

		private bool rotationWeightUsed;

		private bool pullUsed;

		private bool reachUsed;

		private bool pushUsed;

		private bool pushParentUsed;

		private bool pickedUp;

		private bool defaults;

		private bool pickUpOnPostFBBIK;

		private Vector3 pickUpPosition;

		private Vector3 pausePositionRelative;

		private Quaternion pickUpRotation;

		private Quaternion pauseRotationRelative;

		private InteractionTarget interactionTarget;

		private Transform target;

		private List<bool> triggered = new List<bool>();

		private InteractionSystem interactionSystem;

		private bool started;

		public FullBodyBipedEffector effectorType { get; private set; }

		public bool isPaused { get; private set; }

		public InteractionObject interactionObject { get; private set; }

		public bool inInteraction => interactionObject != null;

		public float progress
		{
			get
			{
				if (!inInteraction)
				{
					return 0f;
				}
				if (length == 0f)
				{
					return 0f;
				}
				return timer / length;
			}
		}

		public InteractionEffector(FullBodyBipedEffector effectorType)
		{
			this.effectorType = effectorType;
		}

		public void Initiate(InteractionSystem interactionSystem)
		{
			this.interactionSystem = interactionSystem;
			if (effector == null)
			{
				effector = interactionSystem.ik.solver.GetEffector(effectorType);
				poser = effector.bone.GetComponent<Poser>();
			}
			StoreDefaults();
		}

		private void StoreDefaults()
		{
			defaultPositionWeight = interactionSystem.ik.solver.GetEffector(effectorType).positionWeight;
			defaultRotationWeight = interactionSystem.ik.solver.GetEffector(effectorType).rotationWeight;
			defaultPull = interactionSystem.ik.solver.GetChain(effectorType).pull;
			defaultReach = interactionSystem.ik.solver.GetChain(effectorType).reach;
			defaultPush = interactionSystem.ik.solver.GetChain(effectorType).push;
			defaultPushParent = interactionSystem.ik.solver.GetChain(effectorType).pushParent;
		}

		public bool ResetToDefaults(float speed)
		{
			if (inInteraction)
			{
				return false;
			}
			if (isPaused)
			{
				return false;
			}
			if (defaults)
			{
				return false;
			}
			resetTimer = Mathf.Clamp(resetTimer -= Time.deltaTime * speed, 0f, 1f);
			if (effector.isEndEffector)
			{
				if (pullUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).pull = Mathf.Lerp(defaultPull, interactionSystem.ik.solver.GetChain(effectorType).pull, resetTimer);
				}
				if (reachUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).reach = Mathf.Lerp(defaultReach, interactionSystem.ik.solver.GetChain(effectorType).reach, resetTimer);
				}
				if (pushUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).push = Mathf.Lerp(defaultPush, interactionSystem.ik.solver.GetChain(effectorType).push, resetTimer);
				}
				if (pushParentUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).pushParent = Mathf.Lerp(defaultPushParent, interactionSystem.ik.solver.GetChain(effectorType).pushParent, resetTimer);
				}
			}
			if (positionWeightUsed)
			{
				effector.positionWeight = Mathf.Lerp(defaultPositionWeight, effector.positionWeight, resetTimer);
			}
			if (rotationWeightUsed)
			{
				effector.rotationWeight = Mathf.Lerp(defaultRotationWeight, effector.rotationWeight, resetTimer);
			}
			if (resetTimer <= 0f)
			{
				pullUsed = false;
				reachUsed = false;
				pushUsed = false;
				pushParentUsed = false;
				positionWeightUsed = false;
				rotationWeightUsed = false;
				defaults = true;
			}
			return true;
		}

		public bool Pause()
		{
			if (!inInteraction)
			{
				return false;
			}
			isPaused = true;
			pausePositionRelative = target.InverseTransformPoint(effector.position);
			pauseRotationRelative = Quaternion.Inverse(target.rotation) * effector.rotation;
			if (interactionSystem.OnInteractionPause != null)
			{
				interactionSystem.OnInteractionPause(effectorType, interactionObject);
			}
			return true;
		}

		public bool Resume()
		{
			if (!inInteraction)
			{
				return false;
			}
			isPaused = false;
			if (interactionSystem.OnInteractionResume != null)
			{
				interactionSystem.OnInteractionResume(effectorType, interactionObject);
			}
			return true;
		}

		public bool Start(InteractionObject interactionObject, string tag, float fadeInTime, bool interrupt)
		{
			if (!inInteraction)
			{
				effector.position = effector.bone.position;
				effector.rotation = effector.bone.rotation;
			}
			else if (!interrupt)
			{
				return false;
			}
			target = interactionObject.GetTarget(effectorType, tag);
			if (target == null)
			{
				return false;
			}
			interactionTarget = target.GetComponent<InteractionTarget>();
			this.interactionObject = interactionObject;
			if (interactionSystem.OnInteractionStart != null)
			{
				interactionSystem.OnInteractionStart(effectorType, interactionObject);
			}
			interactionObject.OnStartInteraction(interactionSystem);
			triggered.Clear();
			for (int i = 0; i < interactionObject.events.Length; i++)
			{
				triggered.Add(item: false);
			}
			if (poser != null)
			{
				if (poser.poseRoot == null)
				{
					poser.weight = 0f;
				}
				if (interactionTarget != null)
				{
					poser.poseRoot = target.transform;
				}
				else
				{
					poser.poseRoot = null;
				}
				poser.AutoMapping();
			}
			positionWeightUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.PositionWeight);
			rotationWeightUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.RotationWeight);
			pullUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Pull);
			reachUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Reach);
			pushUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Push);
			pushParentUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.PushParent);
			StoreDefaults();
			timer = 0f;
			weight = 0f;
			fadeInSpeed = ((!(fadeInTime > 0f)) ? 1000f : (1f / fadeInTime));
			length = interactionObject.length;
			isPaused = false;
			pickedUp = false;
			pickUpPosition = Vector3.zero;
			pickUpRotation = Quaternion.identity;
			if (interactionTarget != null)
			{
				interactionTarget.RotateTo(effector.bone.position);
			}
			started = true;
			return true;
		}

		public void Update(Transform root, float speed)
		{
			if (!inInteraction)
			{
				if (started)
				{
					isPaused = false;
					pickedUp = false;
					defaults = false;
					resetTimer = 1f;
					started = false;
				}
				return;
			}
			if (interactionTarget != null && !interactionTarget.rotateOnce)
			{
				interactionTarget.RotateTo(effector.bone.position);
			}
			if (isPaused)
			{
				effector.position = target.TransformPoint(pausePositionRelative);
				effector.rotation = target.rotation * pauseRotationRelative;
				interactionObject.Apply(interactionSystem.ik.solver, effectorType, interactionTarget, timer, weight);
				return;
			}
			timer += Time.deltaTime * speed * ((!(interactionTarget != null)) ? 1f : interactionTarget.interactionSpeedMlp);
			weight = Mathf.Clamp(weight + Time.deltaTime * fadeInSpeed * speed, 0f, 1f);
			bool pickUp = false;
			bool pause = false;
			TriggerUntriggeredEvents(checkTime: true, out pickUp, out pause);
			Vector3 b = ((!pickedUp) ? target.position : pickUpPosition);
			Quaternion b2 = ((!pickedUp) ? target.rotation : pickUpRotation);
			effector.position = Vector3.Lerp(effector.bone.position, b, weight);
			effector.rotation = Quaternion.Lerp(effector.bone.rotation, b2, weight);
			interactionObject.Apply(interactionSystem.ik.solver, effectorType, interactionTarget, timer, weight);
			if (pickUp)
			{
				PickUp(root);
			}
			if (pause)
			{
				Pause();
			}
			float value = interactionObject.GetValue(InteractionObject.WeightCurve.Type.PoserWeight, interactionTarget, timer);
			if (poser != null)
			{
				poser.weight = Mathf.Lerp(poser.weight, value, weight);
			}
			else if (value > 0f)
			{
				Warning.Log("InteractionObject " + interactionObject.name + " has a curve/multipler for Poser Weight, but the bone of effector " + effectorType.ToString() + " has no HandPoser/GenericPoser attached.", effector.bone);
			}
			if (timer >= length)
			{
				Stop();
			}
		}

		private void TriggerUntriggeredEvents(bool checkTime, out bool pickUp, out bool pause)
		{
			pickUp = false;
			pause = false;
			for (int i = 0; i < triggered.Count; i++)
			{
				if (triggered[i] || (checkTime && !(interactionObject.events[i].time < timer)))
				{
					continue;
				}
				interactionObject.events[i].Activate(effector.bone);
				if (interactionObject.events[i].pickUp)
				{
					if (timer >= interactionObject.events[i].time)
					{
						timer = interactionObject.events[i].time;
					}
					pickUp = true;
				}
				if (interactionObject.events[i].pause)
				{
					if (timer >= interactionObject.events[i].time)
					{
						timer = interactionObject.events[i].time;
					}
					pause = true;
				}
				if (interactionSystem.OnInteractionEvent != null)
				{
					interactionSystem.OnInteractionEvent(effectorType, interactionObject, interactionObject.events[i]);
				}
				triggered[i] = true;
			}
		}

		private void PickUp(Transform root)
		{
			pickUpPosition = effector.position;
			pickUpRotation = effector.rotation;
			pickUpOnPostFBBIK = true;
			pickedUp = true;
			Rigidbody component = interactionObject.targetsRoot.GetComponent<Rigidbody>();
			if (component != null)
			{
				if (!component.isKinematic)
				{
					component.isKinematic = true;
				}
				if (root.GetComponent<Collider>() != null)
				{
					Collider[] componentsInChildren = interactionObject.targetsRoot.GetComponentsInChildren<Collider>();
					Collider[] array = componentsInChildren;
					foreach (Collider collider in array)
					{
						if (!collider.isTrigger)
						{
							Physics.IgnoreCollision(root.GetComponent<Collider>(), collider);
						}
					}
				}
			}
			if (interactionSystem.OnInteractionPickUp != null)
			{
				interactionSystem.OnInteractionPickUp(effectorType, interactionObject);
			}
		}

		public bool Stop()
		{
			if (!inInteraction)
			{
				return false;
			}
			bool pickUp = false;
			bool pause = false;
			TriggerUntriggeredEvents(checkTime: false, out pickUp, out pause);
			if (interactionSystem.OnInteractionStop != null)
			{
				interactionSystem.OnInteractionStop(effectorType, interactionObject);
			}
			if (interactionTarget != null)
			{
				interactionTarget.ResetRotation();
			}
			interactionObject = null;
			weight = 0f;
			timer = 0f;
			isPaused = false;
			target = null;
			defaults = false;
			resetTimer = 1f;
			if (poser != null && !pickedUp)
			{
				poser.weight = 0f;
			}
			pickedUp = false;
			started = false;
			return true;
		}

		public void OnPostFBBIK()
		{
			if (inInteraction)
			{
				float num = interactionObject.GetValue(InteractionObject.WeightCurve.Type.RotateBoneWeight, interactionTarget, timer) * weight;
				if (num > 0f)
				{
					Quaternion b = ((!pickedUp) ? effector.rotation : pickUpRotation);
					Quaternion quaternion = Quaternion.Slerp(effector.bone.rotation, b, num * num);
					effector.bone.localRotation = Quaternion.Inverse(effector.bone.parent.rotation) * quaternion;
				}
				if (pickUpOnPostFBBIK)
				{
					Vector3 position = effector.bone.position;
					effector.bone.position = pickUpPosition;
					interactionObject.targetsRoot.parent = effector.bone;
					effector.bone.position = position;
					pickUpOnPostFBBIK = false;
				}
			}
		}
	}
	[Serializable]
	public class InteractionLookAt
	{
		[Tooltip("(Optional) reference to the LookAtIK component that will be used to make the character look at the objects that it is interacting with.")]
		public LookAtIK ik;

		[Tooltip("Interpolation speed of the LookAtIK target.")]
		public float lerpSpeed = 5f;

		[Tooltip("Interpolation speed of the LookAtIK weight.")]
		public float weightSpeed = 1f;

		[HideInInspector]
		public bool isPaused;

		private Transform lookAtTarget;

		private float stopLookTime;

		private float weight;

		private bool firstFBBIKSolve;

		public void Look(Transform target, float time)
		{
			if (!(ik == null))
			{
				if (ik.solver.IKPositionWeight <= 0f)
				{
					ik.solver.IKPosition = ik.solver.GetRoot().position + ik.solver.GetRoot().forward * 3f;
				}
				lookAtTarget = target;
				stopLookTime = time;
			}
		}

		public void Update()
		{
			if (ik == null)
			{
				return;
			}
			if (ik.enabled)
			{
				ik.enabled = false;
			}
			if (!(lookAtTarget == null))
			{
				if (isPaused)
				{
					stopLookTime += Time.deltaTime;
				}
				float num = ((!(Time.time < stopLookTime)) ? (0f - weightSpeed) : weightSpeed);
				weight = Mathf.Clamp(weight + num * Time.deltaTime, 0f, 1f);
				ik.solver.IKPositionWeight = Interp.Float(weight, InterpolationMode.InOutQuintic);
				ik.solver.IKPosition = Vector3.Lerp(ik.solver.IKPosition, lookAtTarget.position, lerpSpeed * Time.deltaTime);
				if (weight <= 0f)
				{
					lookAtTarget = null;
				}
				firstFBBIKSolve = true;
			}
		}

		public void SolveSpine()
		{
			if (!(ik == null) && firstFBBIKSolve)
			{
				float headWeight = ik.solver.headWeight;
				float eyesWeight = ik.solver.eyesWeight;
				ik.solver.headWeight = 0f;
				ik.solver.eyesWeight = 0f;
				ik.solver.Update();
				ik.solver.headWeight = headWeight;
				ik.solver.eyesWeight = eyesWeight;
			}
		}

		public void SolveHead()
		{
			if (!(ik == null) && firstFBBIKSolve)
			{
				float bodyWeight = ik.solver.bodyWeight;
				ik.solver.bodyWeight = 0f;
				ik.solver.Update();
				ik.solver.bodyWeight = bodyWeight;
				firstFBBIKSolve = false;
			}
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Object")]
	public class InteractionObject : MonoBehaviour
	{
		[Serializable]
		public class InteractionEvent
		{
			[Tooltip("The time of the event since interaction start.")]
			public float time;

			[Tooltip("If true, the interaction will be paused on this event. The interaction can be resumed by InteractionSystem.ResumeInteraction() or InteractionSystem.ResumeAll;")]
			public bool pause;

			[Tooltip("If true, the object will be parented to the effector bone on this event. Note that picking up like this can be done by only a single effector at a time. If you wish to pick up an object with both hands, see the Interaction PickUp2Handed demo scene.")]
			public bool pickUp;

			[Tooltip("The animations called on this event.")]
			public AnimatorEvent[] animations;

			[Tooltip("The messages sent on this event using GameObject.SendMessage().")]
			public Message[] messages;

			public void Activate(Transform t)
			{
				AnimatorEvent[] array = animations;
				foreach (AnimatorEvent animatorEvent in array)
				{
					animatorEvent.Activate(pickUp);
				}
				Message[] array2 = messages;
				foreach (Message message in array2)
				{
					message.Send(t);
				}
			}
		}

		[Serializable]
		public class Message
		{
			[Tooltip("The name of the function called.")]
			public string function;

			[Tooltip("The recipient game object.")]
			public GameObject recipient;

			private const string empty = "";

			public void Send(Transform t)
			{
				if (!(recipient == null) && !(function == string.Empty) && !(function == string.Empty))
				{
					recipient.SendMessage(function, t, SendMessageOptions.RequireReceiver);
				}
			}
		}

		[Serializable]
		public class AnimatorEvent
		{
			[Tooltip("The Animator component that will receive the AnimatorEvents.")]
			public Animator animator;

			[Tooltip("The Animation component that will receive the AnimatorEvents (Legacy).")]
			public Animation animation;

			[Tooltip("The name of the animation state.")]
			public string animationState;

			[Tooltip("The crossfading time.")]
			public float crossfadeTime = 0.3f;

			[Tooltip("The layer of the animation state (if using Legacy, the animation state will be forced to this layer).")]
			public int layer;

			[Tooltip("Should the animation always start from 0 normalized time?")]
			public bool resetNormalizedTime;

			private const string empty = "";

			public void Activate(bool pickUp)
			{
				if (animator != null)
				{
					if (pickUp)
					{
						animator.applyRootMotion = false;
					}
					Activate(animator);
				}
				if (animation != null)
				{
					Activate(animation);
				}
			}

			private void Activate(Animator animator)
			{
				if (!(animationState == string.Empty))
				{
					if (resetNormalizedTime)
					{
						animator.CrossFade(animationState, crossfadeTime, layer, 0f);
					}
					else
					{
						animator.CrossFade(animationState, crossfadeTime, layer);
					}
				}
			}

			private void Activate(Animation animation)
			{
				if (!(animationState == string.Empty))
				{
					if (resetNormalizedTime)
					{
						animation[animationState].normalizedTime = 0f;
					}
					animation[animationState].layer = layer;
					animation.CrossFade(animationState, crossfadeTime);
				}
			}
		}

		[Serializable]
		public class WeightCurve
		{
			[Serializable]
			public enum Type
			{
				PositionWeight,
				RotationWeight,
				PositionOffsetX,
				PositionOffsetY,
				PositionOffsetZ,
				Pull,
				Reach,
				RotateBoneWeight,
				Push,
				PushParent,
				PoserWeight
			}

			[Tooltip("The type of the curve (InteractionObject.WeightCurve.Type).")]
			public Type type;

			[Tooltip("The weight curve.")]
			public AnimationCurve curve;

			public float GetValue(float timer)
			{
				return curve.Evaluate(timer);
			}
		}

		[Serializable]
		public class Multiplier
		{
			[Tooltip("The curve type to multiply.")]
			public WeightCurve.Type curve;

			[Tooltip("The multiplier of the curve's value.")]
			public float multiplier = 1f;

			[Tooltip("The resulting value will be applied to this channel.")]
			public WeightCurve.Type result;

			public float GetValue(WeightCurve weightCurve, float timer)
			{
				return weightCurve.GetValue(timer) * multiplier;
			}
		}

		[Tooltip("If the Interaction System has a 'Look At' LookAtIK component assigned, will use it to make the character look at the specified Transform. If unassigned, will look at this GameObject.")]
		public Transform otherLookAtTarget;

		[Tooltip("The root Transform of the InteractionTargets. If null, will use this GameObject. GetComponentsInChildren<InteractionTarget>() will be used at initiation to find all InteractionTargets associated with this InteractionObject.")]
		public Transform otherTargetsRoot;

		[Tooltip("If assigned, all PositionOffset channels will be applied in the rotation space of this Transform. If not, they will be in the rotation space of the character.")]
		public Transform positionOffsetSpace;

		public WeightCurve[] weightCurves;

		public Multiplier[] multipliers;

		public InteractionEvent[] events;

		private InteractionTarget[] targets = new InteractionTarget[0];

		public float length { get; private set; }

		public InteractionSystem lastUsedInteractionSystem { get; private set; }

		public Transform lookAtTarget
		{
			get
			{
				if (otherLookAtTarget != null)
				{
					return otherLookAtTarget;
				}
				return base.transform;
			}
		}

		public Transform targetsRoot
		{
			get
			{
				if (otherTargetsRoot != null)
				{
					return otherTargetsRoot;
				}
				return base.transform;
			}
		}

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void Initiate()
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				if (weightCurves[i].curve.length > 0)
				{
					float time = weightCurves[i].curve.keys[weightCurves[i].curve.length - 1].time;
					length = Mathf.Clamp(length, time, length);
				}
			}
			for (int j = 0; j < events.Length; j++)
			{
				length = Mathf.Clamp(length, events[j].time, length);
			}
			targets = targetsRoot.GetComponentsInChildren<InteractionTarget>();
		}

		public InteractionTarget GetTarget(FullBodyBipedEffector effectorType, InteractionSystem interactionSystem)
		{
			if (interactionSystem.tag == string.Empty || interactionSystem.tag == string.Empty)
			{
				InteractionTarget[] array = targets;
				foreach (InteractionTarget interactionTarget in array)
				{
					if (interactionTarget.effectorType == effectorType)
					{
						return interactionTarget;
					}
				}
				return null;
			}
			InteractionTarget[] array2 = targets;
			foreach (InteractionTarget interactionTarget2 in array2)
			{
				if (interactionTarget2.effectorType == effectorType && interactionTarget2.tag == interactionSystem.tag)
				{
					return interactionTarget2;
				}
			}
			return null;
		}

		public bool CurveUsed(WeightCurve.Type type)
		{
			WeightCurve[] array = weightCurves;
			foreach (WeightCurve weightCurve in array)
			{
				if (weightCurve.type == type)
				{
					return true;
				}
			}
			Multiplier[] array2 = multipliers;
			foreach (Multiplier multiplier in array2)
			{
				if (multiplier.result == type)
				{
					return true;
				}
			}
			return false;
		}

		public InteractionTarget[] GetTargets()
		{
			return targets;
		}

		public Transform GetTarget(FullBodyBipedEffector effectorType, string tag)
		{
			if (tag == string.Empty || tag == string.Empty)
			{
				return GetTarget(effectorType);
			}
			for (int i = 0; i < targets.Length; i++)
			{
				if (targets[i].effectorType == effectorType && targets[i].tag == tag)
				{
					return targets[i].transform;
				}
			}
			return base.transform;
		}

		public void OnStartInteraction(InteractionSystem interactionSystem)
		{
			lastUsedInteractionSystem = interactionSystem;
		}

		public void Apply(IKSolverFullBodyBiped solver, FullBodyBipedEffector effector, InteractionTarget target, float timer, float weight)
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				float num = ((!(target == null)) ? target.GetValue(weightCurves[i].type) : 1f);
				Apply(solver, effector, weightCurves[i].type, weightCurves[i].GetValue(timer), weight * num);
			}
			for (int j = 0; j < multipliers.Length; j++)
			{
				if (multipliers[j].curve == multipliers[j].result && !Warning.logged)
				{
					Warning.Log("InteractionObject Multiplier 'Curve' " + multipliers[j].curve.ToString() + "and 'Result' are the same.", base.transform);
				}
				int weightCurveIndex = GetWeightCurveIndex(multipliers[j].curve);
				if (weightCurveIndex != -1)
				{
					float num2 = ((!(target == null)) ? target.GetValue(multipliers[j].result) : 1f);
					Apply(solver, effector, multipliers[j].result, multipliers[j].GetValue(weightCurves[weightCurveIndex], timer), weight * num2);
				}
				else if (!Warning.logged)
				{
					Warning.Log("InteractionObject Multiplier curve " + multipliers[j].curve.ToString() + "does not exist.", base.transform);
				}
			}
		}

		public float GetValue(WeightCurve.Type weightCurveType, InteractionTarget target, float timer)
		{
			int weightCurveIndex = GetWeightCurveIndex(weightCurveType);
			if (weightCurveIndex != -1)
			{
				float num = ((!(target == null)) ? target.GetValue(weightCurveType) : 1f);
				return weightCurves[weightCurveIndex].GetValue(timer) * num;
			}
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].result == weightCurveType)
				{
					int weightCurveIndex2 = GetWeightCurveIndex(multipliers[i].curve);
					if (weightCurveIndex2 != -1)
					{
						float num2 = ((!(target == null)) ? target.GetValue(multipliers[i].result) : 1f);
						return multipliers[i].GetValue(weightCurves[weightCurveIndex2], timer) * num2;
					}
				}
			}
			return 0f;
		}

		private void Awake()
		{
			Initiate();
		}

		private void Apply(IKSolverFullBodyBiped solver, FullBodyBipedEffector effector, WeightCurve.Type type, float value, float weight)
		{
			switch (type)
			{
			case WeightCurve.Type.PositionWeight:
				solver.GetEffector(effector).positionWeight = Mathf.Lerp(solver.GetEffector(effector).positionWeight, value, weight);
				break;
			case WeightCurve.Type.RotationWeight:
				solver.GetEffector(effector).rotationWeight = Mathf.Lerp(solver.GetEffector(effector).rotationWeight, value, weight);
				break;
			case WeightCurve.Type.PositionOffsetX:
				solver.GetEffector(effector).position += ((!(positionOffsetSpace != null)) ? solver.GetRoot().rotation : positionOffsetSpace.rotation) * Vector3.right * value * weight;
				break;
			case WeightCurve.Type.PositionOffsetY:
				solver.GetEffector(effector).position += ((!(positionOffsetSpace != null)) ? solver.GetRoot().rotation : positionOffsetSpace.rotation) * Vector3.up * value * weight;
				break;
			case WeightCurve.Type.PositionOffsetZ:
				solver.GetEffector(effector).position += ((!(positionOffsetSpace != null)) ? solver.GetRoot().rotation : positionOffsetSpace.rotation) * Vector3.forward * value * weight;
				break;
			case WeightCurve.Type.Pull:
				solver.GetChain(effector).pull = Mathf.Lerp(solver.GetChain(effector).pull, value, weight);
				break;
			case WeightCurve.Type.Reach:
				solver.GetChain(effector).reach = Mathf.Lerp(solver.GetChain(effector).reach, value, weight);
				break;
			case WeightCurve.Type.Push:
				solver.GetChain(effector).push = Mathf.Lerp(solver.GetChain(effector).push, value, weight);
				break;
			case WeightCurve.Type.PushParent:
				solver.GetChain(effector).pushParent = Mathf.Lerp(solver.GetChain(effector).pushParent, value, weight);
				break;
			case WeightCurve.Type.RotateBoneWeight:
				break;
			}
		}

		private Transform GetTarget(FullBodyBipedEffector effectorType)
		{
			for (int i = 0; i < targets.Length; i++)
			{
				if (targets[i].effectorType == effectorType)
				{
					return targets[i].transform;
				}
			}
			return base.transform;
		}

		private int GetWeightCurveIndex(WeightCurve.Type weightCurveType)
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				if (weightCurves[i].type == weightCurveType)
				{
					return i;
				}
			}
			return -1;
		}

		private int GetMultiplierIndex(WeightCurve.Type weightCurveType)
		{
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].result == weightCurveType)
				{
					return i;
				}
			}
			return -1;
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_object.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction System")]
	public class InteractionSystem : MonoBehaviour
	{
		public delegate void InteractionDelegate(FullBodyBipedEffector effectorType, InteractionObject interactionObject);

		public delegate void InteractionEventDelegate(FullBodyBipedEffector effectorType, InteractionObject interactionObject, InteractionObject.InteractionEvent interactionEvent);

		[Tooltip("If not empty, only the targets with the specified tag will be used by this Interaction System.")]
		public string targetTag = string.Empty;

		[Tooltip("The fade in time of the interaction.")]
		public float fadeInTime = 0.3f;

		[Tooltip("The master speed for all interactions.")]
		public float speed = 1f;

		[Tooltip("If > 0, lerps all the FBBIK channels used by the Interaction System back to their default or initial values when not in interaction.")]
		public float resetToDefaultsSpeed = 1f;

		[Header("Triggering")]
		[Tooltip("The collider that registers OnTriggerEnter and OnTriggerExit events with InteractionTriggers.")]
		[FormerlySerializedAs("collider")]
		public Collider characterCollider;

		[Tooltip("Will be used by Interaction Triggers that need the camera's position. Assign the first person view character camera.")]
		[FormerlySerializedAs("camera")]
		public Transform FPSCamera;

		[Tooltip("The layers that will be raycasted from the camera (along camera.forward). All InteractionTrigger look at target colliders should be included.")]
		public LayerMask camRaycastLayers;

		[Tooltip("Max distance of raycasting from the camera.")]
		public float camRaycastDistance = 1f;

		private List<InteractionTrigger> inContact = new List<InteractionTrigger>();

		private List<int> bestRangeIndexes = new List<int>();

		public InteractionDelegate OnInteractionStart;

		public InteractionDelegate OnInteractionPause;

		public InteractionDelegate OnInteractionPickUp;

		public InteractionDelegate OnInteractionResume;

		public InteractionDelegate OnInteractionStop;

		public InteractionEventDelegate OnInteractionEvent;

		public RaycastHit raycastHit;

		[Space(10f)]
		[Tooltip("Reference to the FBBIK component.")]
		[SerializeField]
		private FullBodyBipedIK fullBody;

		[Tooltip("Handles looking at the interactions.")]
		public InteractionLookAt lookAt = new InteractionLookAt();

		private InteractionEffector[] interactionEffectors = new InteractionEffector[9]
		{
			new InteractionEffector(FullBodyBipedEffector.Body),
			new InteractionEffector(FullBodyBipedEffector.LeftFoot),
			new InteractionEffector(FullBodyBipedEffector.LeftHand),
			new InteractionEffector(FullBodyBipedEffector.LeftShoulder),
			new InteractionEffector(FullBodyBipedEffector.LeftThigh),
			new InteractionEffector(FullBodyBipedEffector.RightFoot),
			new InteractionEffector(FullBodyBipedEffector.RightHand),
			new InteractionEffector(FullBodyBipedEffector.RightShoulder),
			new InteractionEffector(FullBodyBipedEffector.RightThigh)
		};

		private bool initiated;

		private Collider lastCollider;

		private Collider c;

		public bool inInteraction
		{
			get
			{
				if (!IsValid(log: true))
				{
					return false;
				}
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					if (interactionEffectors[i].inInteraction && !interactionEffectors[i].isPaused)
					{
						return true;
					}
				}
				return false;
			}
		}

		public FullBodyBipedIK ik
		{
			get
			{
				return fullBody;
			}
			set
			{
				fullBody = value;
			}
		}

		public List<InteractionTrigger> triggersInRange { get; private set; }

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public bool IsInInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].inInteraction && !interactionEffectors[i].isPaused;
				}
			}
			return false;
		}

		public bool IsPaused(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].inInteraction && interactionEffectors[i].isPaused;
				}
			}
			return false;
		}

		public bool IsPaused()
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].inInteraction && interactionEffectors[i].isPaused)
				{
					return true;
				}
			}
			return false;
		}

		public bool IsInSync()
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (!interactionEffectors[i].isPaused)
				{
					continue;
				}
				for (int j = 0; j < interactionEffectors.Length; j++)
				{
					if (j != i && interactionEffectors[j].inInteraction && !interactionEffectors[j].isPaused)
					{
						return false;
					}
				}
			}
			return true;
		}

		public bool StartInteraction(FullBodyBipedEffector effectorType, InteractionObject interactionObject, bool interrupt)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (interactionObject == null)
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Start(interactionObject, targetTag, fadeInTime, interrupt);
				}
			}
			return false;
		}

		public bool PauseInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Pause();
				}
			}
			return false;
		}

		public bool ResumeInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Resume();
				}
			}
			return false;
		}

		public bool StopInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Stop();
				}
			}
			return false;
		}

		public void PauseAll()
		{
			if (IsValid(log: true))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Pause();
				}
			}
		}

		public void ResumeAll()
		{
			if (IsValid(log: true))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Resume();
				}
			}
		}

		public void StopAll()
		{
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				interactionEffectors[i].Stop();
			}
		}

		public InteractionObject GetInteractionObject(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].interactionObject;
				}
			}
			return null;
		}

		public float GetProgress(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return 0f;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].progress;
				}
			}
			return 0f;
		}

		public float GetMinActiveProgress()
		{
			if (!IsValid(log: true))
			{
				return 0f;
			}
			float num = 1f;
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].inInteraction)
				{
					float progress = interactionEffectors[i].progress;
					if (progress > 0f && progress < num)
					{
						num = progress;
					}
				}
			}
			return num;
		}

		public bool TriggerInteraction(int index, bool interrupt)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					if (!StartInteraction(range.interactions[i].effectors[j], range.interactions[i].interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public bool TriggerInteraction(int index, bool interrupt, out InteractionObject interactionObject)
		{
			interactionObject = null;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					interactionObject = range.interactions[i].interactionObject;
					if (!StartInteraction(range.interactions[i].effectors[j], interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public bool TriggerInteraction(int index, bool interrupt, out InteractionTarget interactionTarget)
		{
			interactionTarget = null;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					InteractionObject interactionObject = range.interactions[i].interactionObject;
					Transform target = interactionObject.GetTarget(range.interactions[i].effectors[j], base.tag);
					if (target != null)
					{
						interactionTarget = target.GetComponent<InteractionTarget>();
					}
					if (!StartInteraction(range.interactions[i].effectors[j], interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public InteractionTrigger.Range GetClosestInteractionRange()
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			int closestTriggerIndex = GetClosestTriggerIndex();
			if (closestTriggerIndex < 0 || closestTriggerIndex >= triggersInRange.Count)
			{
				return null;
			}
			return triggersInRange[closestTriggerIndex].ranges[bestRangeIndexes[closestTriggerIndex]];
		}

		public InteractionObject GetClosestInteractionObjectInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return null;
			}
			return closestInteractionRange.interactions[0].interactionObject;
		}

		public InteractionTarget GetClosestInteractionTargetInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return null;
			}
			return closestInteractionRange.interactions[0].interactionObject.GetTarget(closestInteractionRange.interactions[0].effectors[0], this);
		}

		public InteractionObject[] GetClosestInteractionObjectsInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return new InteractionObject[0];
			}
			InteractionObject[] array = new InteractionObject[closestInteractionRange.interactions.Length];
			for (int i = 0; i < closestInteractionRange.interactions.Length; i++)
			{
				array[i] = closestInteractionRange.interactions[i].interactionObject;
			}
			return array;
		}

		public InteractionTarget[] GetClosestInteractionTargetsInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return new InteractionTarget[0];
			}
			List<InteractionTarget> list = new List<InteractionTarget>();
			InteractionTrigger.Range.Interaction[] interactions = closestInteractionRange.interactions;
			foreach (InteractionTrigger.Range.Interaction interaction in interactions)
			{
				FullBodyBipedEffector[] effectors = interaction.effectors;
				foreach (FullBodyBipedEffector effectorType in effectors)
				{
					list.Add(interaction.interactionObject.GetTarget(effectorType, this));
				}
			}
			return list.ToArray();
		}

		public bool TriggerEffectorsReady(int index)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			for (int i = 0; i < triggersInRange[index].ranges.Length; i++)
			{
				InteractionTrigger.Range range = triggersInRange[index].ranges[i];
				for (int j = 0; j < range.interactions.Length; j++)
				{
					for (int k = 0; k < range.interactions[j].effectors.Length; k++)
					{
						if (IsInInteraction(range.interactions[j].effectors[k]))
						{
							return false;
						}
					}
				}
				for (int l = 0; l < range.interactions.Length; l++)
				{
					for (int m = 0; m < range.interactions[l].effectors.Length; m++)
					{
						if (!IsPaused(range.interactions[l].effectors[m]))
						{
							continue;
						}
						for (int n = 0; n < range.interactions[l].effectors.Length; n++)
						{
							if (n != m && !IsPaused(range.interactions[l].effectors[n]))
							{
								return false;
							}
						}
					}
				}
			}
			return true;
		}

		public InteractionTrigger.Range GetTriggerRange(int index)
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			if (index < 0 || index >= bestRangeIndexes.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return null;
			}
			return triggersInRange[index].ranges[bestRangeIndexes[index]];
		}

		public int GetClosestTriggerIndex()
		{
			if (!IsValid(log: true))
			{
				return -1;
			}
			if (triggersInRange.Count == 0)
			{
				return -1;
			}
			if (triggersInRange.Count == 1)
			{
				return 0;
			}
			int result = -1;
			float num = float.PositiveInfinity;
			for (int i = 0; i < triggersInRange.Count; i++)
			{
				if (triggersInRange[i] != null)
				{
					float num2 = Vector3.SqrMagnitude(triggersInRange[i].transform.position - base.transform.position);
					if (num2 < num)
					{
						result = i;
						num = num2;
					}
				}
			}
			return result;
		}

		protected virtual void Start()
		{
			if (fullBody == null)
			{
				fullBody = GetComponent<FullBodyBipedIK>();
			}
			if (fullBody == null)
			{
				Warning.Log("InteractionSystem can not find a FullBodyBipedIK component", base.transform);
				return;
			}
			IKSolverFullBodyBiped solver = fullBody.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(OnPreFBBIK));
			IKSolverFullBodyBiped solver2 = fullBody.solver;
			solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
			OnInteractionStart = (InteractionDelegate)Delegate.Combine(OnInteractionStart, new InteractionDelegate(LookAtInteraction));
			OnInteractionPause = (InteractionDelegate)Delegate.Combine(OnInteractionPause, new InteractionDelegate(InteractionPause));
			OnInteractionResume = (InteractionDelegate)Delegate.Combine(OnInteractionResume, new InteractionDelegate(InteractionResume));
			OnInteractionStop = (InteractionDelegate)Delegate.Combine(OnInteractionStop, new InteractionDelegate(InteractionStop));
			InteractionEffector[] array = interactionEffectors;
			foreach (InteractionEffector interactionEffector in array)
			{
				interactionEffector.Initiate(this);
			}
			triggersInRange = new List<InteractionTrigger>();
			c = GetComponent<Collider>();
			UpdateTriggerEventBroadcasting();
			initiated = true;
		}

		private void InteractionPause(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = true;
		}

		private void InteractionResume(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = false;
		}

		private void InteractionStop(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = false;
		}

		private void LookAtInteraction(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.Look(interactionObject.lookAtTarget, Time.time + interactionObject.length * 0.5f);
		}

		public void OnTriggerEnter(Collider c)
		{
			if (!(fullBody == null))
			{
				InteractionTrigger component = c.GetComponent<InteractionTrigger>();
				if (!(component == null) && !inContact.Contains(component))
				{
					inContact.Add(component);
				}
			}
		}

		public void OnTriggerExit(Collider c)
		{
			if (!(fullBody == null))
			{
				InteractionTrigger component = c.GetComponent<InteractionTrigger>();
				if (!(component == null))
				{
					inContact.Remove(component);
				}
			}
		}

		private bool ContactIsInRange(int index, out int bestRangeIndex)
		{
			bestRangeIndex = -1;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (index < 0 || index >= inContact.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return false;
			}
			if (inContact[index] == null)
			{
				Warning.Log("The InteractionTrigger in the list 'inContact' has been destroyed", base.transform);
				return false;
			}
			bestRangeIndex = inContact[index].GetBestRangeIndex(base.transform, FPSCamera, raycastHit);
			if (bestRangeIndex == -1)
			{
				return false;
			}
			return true;
		}

		private void OnDrawGizmosSelected()
		{
			if (!Application.isPlaying)
			{
				if (fullBody == null)
				{
					fullBody = GetComponent<FullBodyBipedIK>();
				}
				if (characterCollider == null)
				{
					characterCollider = GetComponent<Collider>();
				}
			}
		}

		private void Update()
		{
			if (fullBody == null)
			{
				return;
			}
			UpdateTriggerEventBroadcasting();
			Raycasting();
			triggersInRange.Clear();
			bestRangeIndexes.Clear();
			for (int i = 0; i < inContact.Count; i++)
			{
				int bestRangeIndex = -1;
				if (inContact[i] != null && inContact[i].gameObject.activeInHierarchy && inContact[i].enabled && ContactIsInRange(i, out bestRangeIndex))
				{
					triggersInRange.Add(inContact[i]);
					bestRangeIndexes.Add(bestRangeIndex);
				}
			}
			lookAt.Update();
		}

		private void Raycasting()
		{
			if ((int)camRaycastLayers != -1 && !(FPSCamera == null))
			{
				Physics.Raycast(FPSCamera.position, FPSCamera.forward, out raycastHit, camRaycastDistance, camRaycastLayers);
			}
		}

		private void UpdateTriggerEventBroadcasting()
		{
			if (characterCollider == null)
			{
				characterCollider = c;
			}
			if (characterCollider != null && characterCollider != c)
			{
				if (characterCollider.GetComponent<TriggerEventBroadcaster>() == null)
				{
					TriggerEventBroadcaster triggerEventBroadcaster = characterCollider.gameObject.AddComponent<TriggerEventBroadcaster>();
					triggerEventBroadcaster.target = base.gameObject;
				}
				if (lastCollider != null && lastCollider != c && lastCollider != characterCollider)
				{
					TriggerEventBroadcaster component = lastCollider.GetComponent<TriggerEventBroadcaster>();
					if (component != null)
					{
						UnityEngine.Object.Destroy(component);
					}
				}
			}
			lastCollider = characterCollider;
		}

		private void LateUpdate()
		{
			if (!(fullBody == null))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Update(base.transform, speed);
				}
				for (int j = 0; j < interactionEffectors.Length; j++)
				{
					interactionEffectors[j].ResetToDefaults(resetToDefaultsSpeed * speed);
				}
			}
		}

		private void OnPreFBBIK()
		{
			if (base.enabled && !(fullBody == null))
			{
				lookAt.SolveSpine();
			}
		}

		private void OnPostFBBIK()
		{
			if (base.enabled && !(fullBody == null))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].OnPostFBBIK();
				}
				lookAt.SolveHead();
			}
		}

		private void OnDestroy()
		{
			if (!(fullBody == null))
			{
				IKSolverFullBodyBiped solver = fullBody.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(OnPreFBBIK));
				IKSolverFullBodyBiped solver2 = fullBody.solver;
				solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
				OnInteractionStart = (InteractionDelegate)Delegate.Remove(OnInteractionStart, new InteractionDelegate(LookAtInteraction));
				OnInteractionPause = (InteractionDelegate)Delegate.Remove(OnInteractionPause, new InteractionDelegate(InteractionPause));
				OnInteractionResume = (InteractionDelegate)Delegate.Remove(OnInteractionResume, new InteractionDelegate(InteractionResume));
				OnInteractionStop = (InteractionDelegate)Delegate.Remove(OnInteractionStop, new InteractionDelegate(InteractionStop));
			}
		}

		private bool IsValid(bool log)
		{
			if (fullBody == null)
			{
				if (log)
				{
					Warning.Log("FBBIK is null. Will not update the InteractionSystem", base.transform);
				}
				return false;
			}
			if (!initiated)
			{
				if (log)
				{
					Warning.Log("The InteractionSystem has not been initiated yet.", base.transform);
				}
				return false;
			}
			return true;
		}

		private bool TriggerIndexIsValid(int index)
		{
			if (index < 0 || index >= triggersInRange.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return false;
			}
			if (triggersInRange[index] == null)
			{
				Warning.Log("The InteractionTrigger in the list 'inContact' has been destroyed", base.transform);
				return false;
			}
			return true;
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_system.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Target")]
	public class InteractionTarget : MonoBehaviour
	{
		[Serializable]
		public class Multiplier
		{
			[Tooltip("The curve type (InteractionObject.WeightCurve.Type).")]
			public InteractionObject.WeightCurve.Type curve;

			[Tooltip("Multiplier of the curve's value.")]
			public float multiplier;
		}

		[Tooltip("The type of the FBBIK effector.")]
		public FullBodyBipedEffector effectorType;

		[Tooltip("InteractionObject weight curve multipliers for this effector target.")]
		public Multiplier[] multipliers;

		[Tooltip("The interaction speed multiplier for this effector. This can be used to make interactions faster/slower for specific effectors.")]
		public float interactionSpeedMlp = 1f;

		[Tooltip("The pivot to twist/swing this interaction target about. For symmetric objects that can be interacted with from a certain angular range.")]
		public Transform pivot;

		[Tooltip("The axis of twisting the interaction target (blue line).")]
		public Vector3 twistAxis = Vector3.up;

		[Tooltip("The weight of twisting the interaction target towards the effector bone in the start of the interaction.")]
		public float twistWeight = 1f;

		[Tooltip("The weight of swinging the interaction target towards the effector bone in the start of the interaction. Swing is defined as a 3-DOF rotation around any axis, while twist is only around the twist axis.")]
		public float swingWeight;

		[Tooltip("If true, will twist/swing around the pivot only once at the start of the interaction. If false, will continue rotating throuout the whole interaction.")]
		public bool rotateOnce = true;

		private Quaternion defaultLocalRotation;

		private Transform lastPivot;

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public float GetValue(InteractionObject.WeightCurve.Type curveType)
		{
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].curve == curveType)
				{
					return multipliers[i].multiplier;
				}
			}
			return 1f;
		}

		public void ResetRotation()
		{
			if (pivot != null)
			{
				pivot.localRotation = defaultLocalRotation;
			}
		}

		public void RotateTo(Vector3 position)
		{
			if (!(pivot == null))
			{
				if (pivot != lastPivot)
				{
					defaultLocalRotation = pivot.localRotation;
					lastPivot = pivot;
				}
				pivot.localRotation = defaultLocalRotation;
				if (twistWeight > 0f)
				{
					Vector3 tangent = base.transform.position - pivot.position;
					Vector3 vector = pivot.rotation * twistAxis;
					Vector3 normal = vector;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					normal = vector;
					Vector3 tangent2 = position - pivot.position;
					Vector3.OrthoNormalize(ref normal, ref tangent2);
					Quaternion b = QuaTools.FromToAroundAxis(tangent, tangent2, vector);
					pivot.rotation = Quaternion.Lerp(Quaternion.identity, b, twistWeight) * pivot.rotation;
				}
				if (swingWeight > 0f)
				{
					Quaternion b2 = Quaternion.FromToRotation(base.transform.position - pivot.position, position - pivot.position);
					pivot.rotation = Quaternion.Lerp(Quaternion.identity, b2, swingWeight) * pivot.rotation;
				}
			}
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_target.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Trigger")]
	public class InteractionTrigger : MonoBehaviour
	{
		[Serializable]
		public class CharacterPosition
		{
			[Tooltip("If false, will not care where the character stands, as long as it is in contact with the trigger collider.")]
			public bool use;

			[Tooltip("The offset of the character's position relative to the trigger in XZ plane. Y position of the character is unlimited as long as it is contact with the collider.")]
			public Vector2 offset;

			[Tooltip("Angle offset from the default forward direction.")]
			[Range(-180f, 180f)]
			public float angleOffset;

			[Tooltip("Max angular offset of the character's forward from the direction of this trigger.")]
			[Range(0f, 180f)]
			public float maxAngle = 45f;

			[Tooltip("Max offset of the character's position from this range's center.")]
			public float radius = 0.5f;

			[Tooltip("If true, will rotate the trigger around it's Y axis relative to the position of the character, so the object can be interacted with from all sides.")]
			public bool orbit;

			[Tooltip("Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object. For example a gun will be able to be picked up from the same direction relative to the barrel no matter which side the gun is resting on.")]
			public bool fixYAxis;

			public Vector3 offset3D => new Vector3(offset.x, 0f, offset.y);

			public Vector3 direction3D => Quaternion.AngleAxis(angleOffset, Vector3.up) * Vector3.forward;

			public bool IsInRange(Transform character, Transform trigger, out float error)
			{
				error = 0f;
				if (!use)
				{
					return true;
				}
				error = 180f;
				if (radius <= 0f)
				{
					return false;
				}
				if (maxAngle <= 0f)
				{
					return false;
				}
				Vector3 forward = trigger.forward;
				if (fixYAxis)
				{
					forward.y = 0f;
				}
				if (forward == Vector3.zero)
				{
					return false;
				}
				Vector3 normal = ((!fixYAxis) ? trigger.up : Vector3.up);
				Quaternion quaternion = Quaternion.LookRotation(forward, normal);
				Vector3 vector = trigger.position + quaternion * offset3D;
				Vector3 vector2 = ((!orbit) ? vector : trigger.position);
				Vector3 tangent = character.position - vector2;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				tangent *= Vector3.Project(character.position - vector2, tangent).magnitude;
				if (orbit)
				{
					float magnitude = offset.magnitude;
					float magnitude2 = tangent.magnitude;
					if (magnitude2 < magnitude - radius || magnitude2 > magnitude + radius)
					{
						return false;
					}
				}
				else if (tangent.magnitude > radius)
				{
					return false;
				}
				Vector3 tangent2 = quaternion * direction3D;
				Vector3.OrthoNormalize(ref normal, ref tangent2);
				if (orbit)
				{
					Vector3 vector3 = vector - trigger.position;
					if (vector3 == Vector3.zero)
					{
						vector3 = Vector3.forward;
					}
					Quaternion rotation = Quaternion.LookRotation(vector3, normal);
					tangent = Quaternion.Inverse(rotation) * tangent;
					float angle = Mathf.Atan2(tangent.x, tangent.z) * 57.29578f;
					tangent2 = Quaternion.AngleAxis(angle, normal) * tangent2;
				}
				float num = Vector3.Angle(tangent2, character.forward);
				if (num > maxAngle)
				{
					return false;
				}
				error = num / maxAngle * 180f;
				return true;
			}
		}

		[Serializable]
		public class CameraPosition
		{
			[Tooltip("What the camera should be looking at to trigger the interaction?")]
			public Collider lookAtTarget;

			[Tooltip("The direction from the lookAtTarget towards the camera (in lookAtTarget's space).")]
			public Vector3 direction = -Vector3.forward;

			[Tooltip("Max distance from the lookAtTarget to the camera.")]
			public float maxDistance = 0.5f;

			[Tooltip("Max angle between the direction and the direction towards the camera.")]
			[Range(0f, 180f)]
			public float maxAngle = 45f;

			[Tooltip("Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object.")]
			public bool fixYAxis;

			public Quaternion GetRotation()
			{
				Vector3 forward = lookAtTarget.transform.forward;
				if (fixYAxis)
				{
					forward.y = 0f;
				}
				if (forward == Vector3.zero)
				{
					return Quaternion.identity;
				}
				Vector3 upwards = ((!fixYAxis) ? lookAtTarget.transform.up : Vector3.up);
				return Quaternion.LookRotation(forward, upwards);
			}

			public bool IsInRange(Transform raycastFrom, RaycastHit hit, Transform trigger, out float error)
			{
				error = 0f;
				if (lookAtTarget == null)
				{
					return true;
				}
				error = 180f;
				if (raycastFrom == null)
				{
					return false;
				}
				if (hit.collider != lookAtTarget)
				{
					return false;
				}
				if (hit.distance > maxDistance)
				{
					return false;
				}
				if (direction == Vector3.zero)
				{
					return false;
				}
				if (maxDistance <= 0f)
				{
					return false;
				}
				if (maxAngle <= 0f)
				{
					return false;
				}
				Vector3 to = GetRotation() * direction;
				float num = Vector3.Angle(raycastFrom.position - hit.point, to);
				if (num > maxAngle)
				{
					return false;
				}
				error = num / maxAngle * 180f;
				return true;
			}
		}

		[Serializable]
		public class Range
		{
			[Serializable]
			public class Interaction
			{
				[Tooltip("The InteractionObject to interact with.")]
				public InteractionObject interactionObject;

				[Tooltip("The effectors to interact with.")]
				public FullBodyBipedEffector[] effectors;
			}

			[HideInInspector]
			[SerializeField]
			public string name;

			[HideInInspector]
			[SerializeField]
			public bool show = true;

			[Tooltip("The range for the character's position and rotation.")]
			public CharacterPosition characterPosition;

			[Tooltip("The range for the character camera's position and rotation.")]
			public CameraPosition cameraPosition;

			[Tooltip("Definitions of the interactions associated with this range.")]
			public Interaction[] interactions;

			public bool IsInRange(Transform character, Transform raycastFrom, RaycastHit raycastHit, Transform trigger, out float maxError)
			{
				maxError = 0f;
				float error = 0f;
				float error2 = 0f;
				if (!characterPosition.IsInRange(character, trigger, out error))
				{
					return false;
				}
				if (!cameraPosition.IsInRange(raycastFrom, raycastHit, trigger, out error2))
				{
					return false;
				}
				maxError = Mathf.Max(error, error2);
				return true;
			}
		}

		[Tooltip("The valid ranges of the character's and/or it's camera's position for triggering interaction when the character is in contact with the collider of this trigger.")]
		public Range[] ranges = new Range[0];

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		private void Start()
		{
		}

		public int GetBestRangeIndex(Transform character, Transform raycastFrom, RaycastHit raycastHit)
		{
			if (GetComponent<Collider>() == null)
			{
				Warning.Log("Using the InteractionTrigger requires a Collider component.", base.transform);
				return -1;
			}
			int result = -1;
			float num = 180f;
			float maxError = 0f;
			for (int i = 0; i < ranges.Length; i++)
			{
				if (ranges[i].IsInRange(character, raycastFrom, raycastHit, base.transform, out maxError) && maxError <= num)
				{
					num = maxError;
					result = i;
				}
			}
			return result;
		}
	}
	public class GenericPoser : Poser
	{
		[Serializable]
		public class Map
		{
			public Transform bone;

			public Transform target;

			private Vector3 defaultLocalPosition;

			private Quaternion defaultLocalRotation;

			public Map(Transform bone, Transform target)
			{
				this.bone = bone;
				this.target = target;
				StoreDefaultState();
			}

			public void StoreDefaultState()
			{
				defaultLocalPosition = bone.localPosition;
				defaultLocalRotation = bone.localRotation;
			}

			public void FixTransform()
			{
				bone.localPosition = defaultLocalPosition;
				bone.localRotation = defaultLocalRotation;
			}

			public void Update(float localRotationWeight, float localPositionWeight)
			{
				bone.localRotation = Quaternion.Lerp(bone.localRotation, target.localRotation, localRotationWeight);
				bone.localPosition = Vector3.Lerp(bone.localPosition, target.localPosition, localPositionWeight);
			}
		}

		public Map[] maps;

		[ContextMenu("Auto-Mapping")]
		public override void AutoMapping()
		{
			if (poseRoot == null)
			{
				maps = new Map[0];
				return;
			}
			maps = new Map[0];
			Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>();
			Transform[] componentsInChildren2 = poseRoot.GetComponentsInChildren<Transform>();
			for (int i = 1; i < componentsInChildren.Length; i++)
			{
				Transform targetNamed = GetTargetNamed(componentsInChildren[i].name, componentsInChildren2);
				if (targetNamed != null)
				{
					Array.Resize(ref maps, maps.Length + 1);
					maps[maps.Length - 1] = new Map(componentsInChildren[i], targetNamed);
				}
			}
			StoreDefaultState();
		}

		protected override void InitiatePoser()
		{
			StoreDefaultState();
		}

		protected override void UpdatePoser()
		{
			if (!(weight <= 0f) && (!(localPositionWeight <= 0f) || !(localRotationWeight <= 0f)) && !(poseRoot == null))
			{
				float num = localRotationWeight * weight;
				float num2 = localPositionWeight * weight;
				for (int i = 0; i < maps.Length; i++)
				{
					maps[i].Update(num, num2);
				}
			}
		}

		protected override void FixPoserTransforms()
		{
			for (int i = 0; i < maps.Length; i++)
			{
				maps[i].FixTransform();
			}
		}

		private void StoreDefaultState()
		{
			for (int i = 0; i < maps.Length; i++)
			{
				maps[i].StoreDefaultState();
			}
		}

		private Transform GetTargetNamed(string tName, Transform[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].name == tName)
				{
					return array[i];
				}
			}
			return null;
		}
	}
	public class HandPoser : Poser
	{
		private Transform _poseRoot;

		private Transform[] children;

		private Transform[] poseChildren;

		private Vector3[] defaultLocalPositions;

		private Quaternion[] defaultLocalRotations;

		public override void AutoMapping()
		{
			if (poseRoot == null)
			{
				poseChildren = new Transform[0];
			}
			else
			{
				poseChildren = poseRoot.GetComponentsInChildren<Transform>();
			}
			_poseRoot = poseRoot;
		}

		protected override void InitiatePoser()
		{
			children = GetComponentsInChildren<Transform>();
			StoreDefaultState();
		}

		protected override void FixPoserTransforms()
		{
			for (int i = 0; i < children.Length; i++)
			{
				children[i].localPosition = defaultLocalPositions[i];
				children[i].localRotation = defaultLocalRotations[i];
			}
		}

		protected override void UpdatePoser()
		{
			if (weight <= 0f || (localPositionWeight <= 0f && localRotationWeight <= 0f))
			{
				return;
			}
			if (_poseRoot != poseRoot)
			{
				AutoMapping();
			}
			if (poseRoot == null)
			{
				return;
			}
			if (children.Length != poseChildren.Length)
			{
				Warning.Log("Number of children does not match with the pose", base.transform);
				return;
			}
			float t = localRotationWeight * weight;
			float t2 = localPositionWeight * weight;
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] != base.transform)
				{
					children[i].localRotation = Quaternion.Lerp(children[i].localRotation, poseChildren[i].localRotation, t);
					children[i].localPosition = Vector3.Lerp(children[i].localPosition, poseChildren[i].localPosition, t2);
				}
			}
		}

		private void StoreDefaultState()
		{
			defaultLocalPositions = new Vector3[children.Length];
			defaultLocalRotations = new Quaternion[children.Length];
			for (int i = 0; i < children.Length; i++)
			{
				ref Vector3 reference = ref defaultLocalPositions[i];
				reference = children[i].localPosition;
				ref Quaternion reference2 = ref defaultLocalRotations[i];
				reference2 = children[i].localRotation;
			}
		}
	}
	public abstract class Poser : SolverManager
	{
		public Transform poseRoot;

		[Range(0f, 1f)]
		public float weight = 1f;

		[Range(0f, 1f)]
		public float localRotationWeight = 1f;

		[Range(0f, 1f)]
		public float localPositionWeight;

		private bool initiated;

		public abstract void AutoMapping();

		protected abstract void InitiatePoser();

		protected abstract void UpdatePoser();

		protected abstract void FixPoserTransforms();

		protected override void UpdateSolver()
		{
			if (!initiated)
			{
				InitiateSolver();
			}
			if (initiated)
			{
				UpdatePoser();
			}
		}

		protected override void InitiateSolver()
		{
			if (!initiated)
			{
				InitiatePoser();
				initiated = true;
			}
		}

		protected override void FixTransforms()
		{
			if (initiated)
			{
				FixPoserTransforms();
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class RagdollUtility : MonoBehaviour
	{
		public class Rigidbone
		{
			public Rigidbody r;

			public Transform t;

			public Collider collider;

			public Joint joint;

			public Rigidbody c;

			public bool updateAnchor;

			public Vector3 deltaPosition;

			public Quaternion deltaRotation;

			public float deltaTime;

			public Vector3 lastPosition;

			public Quaternion lastRotation;

			public Rigidbone(Rigidbody r)
			{
				this.r = r;
				t = r.transform;
				joint = t.GetComponent<Joint>();
				collider = t.GetComponent<Collider>();
				if (joint != null)
				{
					c = joint.connectedBody;
					updateAnchor = c != null;
				}
				lastPosition = t.position;
				lastRotation = t.rotation;
			}

			public void RecordVelocity()
			{
				deltaPosition = t.position - lastPosition;
				lastPosition = t.position;
				deltaRotation = QuaTools.FromToRotation(lastRotation, t.rotation);
				lastRotation = t.rotation;
				deltaTime = Time.deltaTime;
			}

			public void WakeUp(float velocityWeight, float angularVelocityWeight)
			{
				if (updateAnchor)
				{
					joint.connectedAnchor = t.InverseTransformPoint(c.position);
				}
				r.isKinematic = false;
				if (velocityWeight != 0f)
				{
					r.velocity = deltaPosition / deltaTime * velocityWeight;
				}
				if (angularVelocityWeight != 0f)
				{
					float angle = 0f;
					Vector3 axis = Vector3.zero;
					deltaRotation.ToAngleAxis(out angle, out axis);
					angle *= (float)Math.PI / 180f;
					angle /= deltaTime;
					axis *= angle * angularVelocityWeight;
					r.angularVelocity = Vector3.ClampMagnitude(axis, r.maxAngularVelocity);
				}
				r.WakeUp();
			}
		}

		public class Child
		{
			public Transform t;

			public Vector3 localPosition;

			public Quaternion localRotation;

			public Child(Transform transform)
			{
				t = transform;
				localPosition = t.localPosition;
				localRotation = t.localRotation;
			}

			public void FixTransform(float weight)
			{
				if (!(weight <= 0f))
				{
					if (weight >= 1f)
					{
						t.localPosition = localPosition;
						t.localRotation = localRotation;
					}
					else
					{
						t.localPosition = Vector3.Lerp(t.localPosition, localPosition, weight);
						t.localRotation = Quaternion.Lerp(t.localRotation, localRotation, weight);
					}
				}
			}

			public void StoreLocalState()
			{
				localPosition = t.localPosition;
				localRotation = t.localRotation;
			}
		}

		[Tooltip("If you have multiple IK components, then this should be the one that solves last each frame.")]
		public IK ik;

		[Tooltip("How long does it take to blend from ragdoll to animation?")]
		public float ragdollToAnimationTime = 0.2f;

		[Tooltip("If true, IK can be used on top of physical ragdoll simulation.")]
		public bool applyIkOnRagdoll;

		[Tooltip("How much velocity transfer from animation to ragdoll?")]
		public float applyVelocity = 1f;

		[Tooltip("How much angular velocity to transfer from animation to ragdoll?")]
		public float applyAngularVelocity = 1f;

		private Animator animator;

		private Rigidbone[] rigidbones = new Rigidbone[0];

		private Child[] children = new Child[0];

		private bool enableRagdollFlag;

		private AnimatorUpdateMode animatorUpdateMode;

		private IK[] allIKComponents = new IK[0];

		private bool[] fixTransforms = new bool[0];

		private float ragdollWeight;

		private float ragdollWeightV;

		private bool fixedFrame;

		private bool[] disabledIKComponents = new bool[0];

		private bool isRagdoll => !rigidbones[0].r.isKinematic && !animator.enabled;

		private bool ikUsed
		{
			get
			{
				if (ik == null)
				{
					return false;
				}
				if (ik.enabled && ik.GetIKSolver().IKPositionWeight > 0f)
				{
					return true;
				}
				IK[] array = allIKComponents;
				foreach (IK iK in array)
				{
					if (iK.enabled && iK.GetIKSolver().IKPositionWeight > 0f)
					{
						return true;
					}
				}
				return false;
			}
		}

		public void EnableRagdoll()
		{
			if (!isRagdoll)
			{
				StopAllCoroutines();
				enableRagdollFlag = true;
			}
		}

		public void DisableRagdoll()
		{
			if (isRagdoll)
			{
				StoreLocalState();
				StopAllCoroutines();
				StartCoroutine(DisableRagdollSmooth());
			}
		}

		public void Start()
		{
			animator = GetComponent<Animator>();
			allIKComponents = GetComponentsInChildren<IK>();
			disabledIKComponents = new bool[allIKComponents.Length];
			fixTransforms = new bool[allIKComponents.Length];
			if (ik != null)
			{
				IKSolver iKSolver = ik.GetIKSolver();
				iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterLastIK));
			}
			Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
			int num = ((componentsInChildren[0].gameObject == base.gameObject) ? 1 : 0);
			rigidbones = new Rigidbone[(num != 0) ? (componentsInChildren.Length - 1) : componentsInChildren.Length];
			for (int i = 0; i < rigidbones.Length; i++)
			{
				rigidbones[i] = new Rigidbone(componentsInChildren[i + num]);
			}
			Transform[] componentsInChildren2 = GetComponentsInChildren<Transform>();
			children = new Child[componentsInChildren2.Length - 1];
			for (int j = 0; j < children.Length; j++)
			{
				children[j] = new Child(componentsInChildren2[j + 1]);
			}
		}

		private IEnumerator DisableRagdollSmooth()
		{
			for (int i = 0; i < rigidbones.Length; i++)
			{
				rigidbones[i].r.isKinematic = true;
			}
			for (int j = 0; j < allIKComponents.Length; j++)
			{
				allIKComponents[j].fixTransforms = fixTransforms[j];
				if (disabledIKComponents[j])
				{
					allIKComponents[j].enabled = true;
				}
			}
			animator.updateMode = animatorUpdateMode;
			animator.enabled = true;
			while (ragdollWeight > 0f)
			{
				ragdollWeight = Mathf.SmoothDamp(ragdollWeight, 0f, ref ragdollWeightV, ragdollToAnimationTime);
				if (ragdollWeight < 0.001f)
				{
					ragdollWeight = 0f;
				}
				yield return null;
			}
			yield return null;
		}

		private void Update()
		{
			if (!isRagdoll)
			{
				return;
			}
			if (!applyIkOnRagdoll)
			{
				bool flag = false;
				for (int i = 0; i < allIKComponents.Length; i++)
				{
					if (allIKComponents[i].enabled)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					for (int j = 0; j < allIKComponents.Length; j++)
					{
						disabledIKComponents[j] = false;
					}
				}
				for (int k = 0; k < allIKComponents.Length; k++)
				{
					if (allIKComponents[k].enabled)
					{
						allIKComponents[k].enabled = false;
						disabledIKComponents[k] = true;
					}
				}
				return;
			}
			bool flag2 = false;
			for (int l = 0; l < allIKComponents.Length; l++)
			{
				if (disabledIKComponents[l])
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				return;
			}
			for (int m = 0; m < allIKComponents.Length; m++)
			{
				if (disabledIKComponents[m])
				{
					allIKComponents[m].enabled = true;
				}
			}
			for (int n = 0; n < allIKComponents.Length; n++)
			{
				disabledIKComponents[n] = false;
			}
		}

		private void FixedUpdate()
		{
			if (isRagdoll && applyIkOnRagdoll)
			{
				FixTransforms(1f);
			}
			fixedFrame = true;
		}

		private void LateUpdate()
		{
			if (animator.updateMode != AnimatorUpdateMode.AnimatePhysics || (animator.updateMode == AnimatorUpdateMode.AnimatePhysics && fixedFrame))
			{
				AfterAnimation();
			}
			fixedFrame = false;
			if (!ikUsed)
			{
				OnFinalPose();
			}
		}

		private void AfterLastIK()
		{
			if (ikUsed)
			{
				OnFinalPose();
			}
		}

		private void AfterAnimation()
		{
			if (isRagdoll)
			{
				StoreLocalState();
			}
			else
			{
				FixTransforms(ragdollWeight);
			}
		}

		private void OnFinalPose()
		{
			if (!isRagdoll)
			{
				RecordVelocities();
			}
			if (enableRagdollFlag)
			{
				RagdollEnabler();
			}
		}

		private void RagdollEnabler()
		{
			StoreLocalState();
			for (int i = 0; i < allIKComponents.Length; i++)
			{
				disabledIKComponents[i] = false;
			}
			if (!applyIkOnRagdoll)
			{
				for (int j = 0; j < allIKComponents.Length; j++)
				{
					if (allIKComponents[j].enabled)
					{
						allIKComponents[j].enabled = false;
						disabledIKComponents[j] = true;
					}
				}
			}
			animatorUpdateMode = animator.updateMode;
			animator.updateMode = AnimatorUpdateMode.AnimatePhysics;
			animator.enabled = false;
			for (int k = 0; k < rigidbones.Length; k++)
			{
				rigidbones[k].WakeUp(applyVelocity, applyAngularVelocity);
			}
			for (int l = 0; l < fixTransforms.Length; l++)
			{
				fixTransforms[l] = allIKComponents[l].fixTransforms;
				allIKComponents[l].fixTransforms = false;
			}
			ragdollWeight = 1f;
			ragdollWeightV = 0f;
			enableRagdollFlag = false;
		}

		private void RecordVelocities()
		{
			Rigidbone[] array = rigidbones;
			foreach (Rigidbone rigidbone in array)
			{
				rigidbone.RecordVelocity();
			}
		}

		private void StoreLocalState()
		{
			Child[] array = children;
			foreach (Child child in array)
			{
				child.StoreLocalState();
			}
		}

		private void FixTransforms(float weight)
		{
			Child[] array = children;
			foreach (Child child in array)
			{
				child.FixTransform(weight);
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolver iKSolver = ik.GetIKSolver();
				iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterLastIK));
			}
		}
	}
	public abstract class RotationLimit : MonoBehaviour
	{
		public Vector3 axis = Vector3.forward;

		[HideInInspector]
		public Quaternion defaultLocalRotation;

		private bool initiated;

		private bool applicationQuit;

		private bool defaultLocalRotationSet;

		public Vector3 secondaryAxis => new Vector3(axis.y, axis.z, axis.x);

		public Vector3 crossAxis => Vector3.Cross(axis, secondaryAxis);

		public void SetDefaultLocalRotation()
		{
			defaultLocalRotation = base.transform.localRotation;
			defaultLocalRotationSet = true;
		}

		public Quaternion GetLimitedLocalRotation(Quaternion localRotation, out bool changed)
		{
			if (!initiated)
			{
				Awake();
			}
			Quaternion quaternion = Quaternion.Inverse(defaultLocalRotation) * localRotation;
			Quaternion quaternion2 = LimitRotation(quaternion);
			changed = quaternion2 != quaternion;
			if (!changed)
			{
				return localRotation;
			}
			return defaultLocalRotation * quaternion2;
		}

		public bool Apply()
		{
			bool changed = false;
			base.transform.localRotation = GetLimitedLocalRotation(base.transform.localRotation, out changed);
			return changed;
		}

		public void Disable()
		{
			if (initiated)
			{
				base.enabled = false;
				return;
			}
			Awake();
			base.enabled = false;
		}

		protected abstract Quaternion LimitRotation(Quaternion rotation);

		private void Awake()
		{
			if (!defaultLocalRotationSet)
			{
				SetDefaultLocalRotation();
			}
			if (axis == Vector3.zero)
			{
				Debug.LogError("Axis is Vector3.zero.");
			}
			initiated = true;
		}

		private void LateUpdate()
		{
			Apply();
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}

		protected static Quaternion Limit1DOF(Quaternion rotation, Vector3 axis)
		{
			return Quaternion.FromToRotation(rotation * axis, axis) * rotation;
		}

		protected static Quaternion LimitTwist(Quaternion rotation, Vector3 axis, Vector3 orthoAxis, float twistLimit)
		{
			twistLimit = Mathf.Clamp(twistLimit, 0f, 180f);
			if (twistLimit >= 180f)
			{
				return rotation;
			}
			Vector3 normal = rotation * axis;
			Vector3 tangent = orthoAxis;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			Vector3 tangent2 = rotation * orthoAxis;
			Vector3.OrthoNormalize(ref normal, ref tangent2);
			Quaternion quaternion = Quaternion.FromToRotation(tangent2, tangent) * rotation;
			if (twistLimit <= 0f)
			{
				return quaternion;
			}
			return Quaternion.RotateTowards(quaternion, rotation, twistLimit);
		}

		protected static float GetOrthogonalAngle(Vector3 v1, Vector3 v2, Vector3 normal)
		{
			Vector3.OrthoNormalize(ref normal, ref v1);
			Vector3.OrthoNormalize(ref normal, ref v2);
			return Vector3.Angle(v1, v2);
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Angle")]
	public class RotationLimitAngle : RotationLimit
	{
		[Range(0f, 180f)]
		public float limit = 45f;

		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_angle.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			Quaternion rotation2 = LimitSwing(rotation);
			return RotationLimit.LimitTwist(rotation2, axis, base.secondaryAxis, twistLimit);
		}

		private Quaternion LimitSwing(Quaternion rotation)
		{
			if (axis == Vector3.zero)
			{
				return rotation;
			}
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			if (limit >= 180f)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			Quaternion to = Quaternion.FromToRotation(axis, vector);
			Quaternion quaternion = Quaternion.RotateTowards(Quaternion.identity, to, limit);
			Quaternion quaternion2 = Quaternion.FromToRotation(vector, quaternion * axis);
			return quaternion2 * rotation;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Hinge")]
	public class RotationLimitHinge : RotationLimit
	{
		public bool useLimits = true;

		public float min = -45f;

		public float max = 90f;

		[HideInInspector]
		public float zeroAxisDisplayOffset;

		private Quaternion lastRotation = Quaternion.identity;

		private float lastAngle;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_hinge.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			lastRotation = LimitHinge(rotation);
			return lastRotation;
		}

		private Quaternion LimitHinge(Quaternion rotation)
		{
			if (min == 0f && max == 0f && useLimits)
			{
				return Quaternion.AngleAxis(0f, axis);
			}
			Quaternion quaternion = RotationLimit.Limit1DOF(rotation, axis);
			if (!useLimits)
			{
				return quaternion;
			}
			Quaternion quaternion2 = quaternion * Quaternion.Inverse(lastRotation);
			float num = Quaternion.Angle(Quaternion.identity, quaternion2);
			Vector3 vector = new Vector3(axis.z, axis.x, axis.y);
			Vector3 rhs = Vector3.Cross(vector, axis);
			if (Vector3.Dot(quaternion2 * vector, rhs) > 0f)
			{
				num = 0f - num;
			}
			lastAngle = Mathf.Clamp(lastAngle + num, min, max);
			return Quaternion.AngleAxis(lastAngle, axis);
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Polygonal")]
	public class RotationLimitPolygonal : RotationLimit
	{
		[Serializable]
		public class ReachCone
		{
			public Vector3[] tetrahedron;

			public float volume;

			public Vector3 S;

			public Vector3 B;

			public Vector3 o => tetrahedron[0];

			public Vector3 a => tetrahedron[1];

			public Vector3 b => tetrahedron[2];

			public Vector3 c => tetrahedron[3];

			public bool isValid => volume > 0f;

			public ReachCone(Vector3 _o, Vector3 _a, Vector3 _b, Vector3 _c)
			{
				tetrahedron = new Vector3[4];
				tetrahedron[0] = _o;
				tetrahedron[1] = _a;
				tetrahedron[2] = _b;
				tetrahedron[3] = _c;
				volume = 0f;
				S = Vector3.zero;
				B = Vector3.zero;
			}

			public void Calculate()
			{
				Vector3 lhs = Vector3.Cross(a, b);
				volume = Vector3.Dot(lhs, c) / 6f;
				S = Vector3.Cross(a, b).normalized;
				B = Vector3.Cross(b, c).normalized;
			}
		}

		[Serializable]
		public class LimitPoint
		{
			public Vector3 point;

			public float tangentWeight;

			public LimitPoint()
			{
				point = Vector3.forward;
				tangentWeight = 1f;
			}
		}

		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[Range(0f, 3f)]
		public int smoothIterations;

		[SerializeField]
		[HideInInspector]
		public LimitPoint[] points;

		[SerializeField]
		[HideInInspector]
		public Vector3[] P;

		[SerializeField]
		[HideInInspector]
		public ReachCone[] reachCones = new ReachCone[0];

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_polygonal.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetLimitPoints(LimitPoint[] points)
		{
			if (points.Length < 3)
			{
				LogWarning("The polygon must have at least 3 Limit Points.");
				return;
			}
			this.points = points;
			BuildReachCones();
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			if (reachCones.Length == 0)
			{
				Start();
			}
			Quaternion rotation2 = LimitSwing(rotation);
			return RotationLimit.LimitTwist(rotation2, axis, base.secondaryAxis, twistLimit);
		}

		private void Start()
		{
			if (points.Length < 3)
			{
				ResetToDefault();
			}
			for (int i = 0; i < reachCones.Length; i++)
			{
				if (!reachCones[i].isValid)
				{
					if (smoothIterations <= 0)
					{
						int num = 0;
						num = ((i < reachCones.Length - 1) ? (i + 1) : 0);
						LogWarning("Reach Cone {point " + i + ", point " + num + ", Origin} has negative volume. Make sure Axis vector is in the reachable area and the polygon is convex.");
					}
					else
					{
						LogWarning("One of the Reach Cones in the polygon has negative volume. Make sure Axis vector is in the reachable area and the polygon is convex.");
					}
				}
			}
			axis = axis.normalized;
		}

		public void ResetToDefault()
		{
			points = new LimitPoint[4];
			for (int i = 0; i < points.Length; i++)
			{
				points[i] = new LimitPoint();
			}
			Quaternion quaternion = Quaternion.AngleAxis(45f, Vector3.right);
			Quaternion quaternion2 = Quaternion.AngleAxis(45f, Vector3.up);
			points[0].point = quaternion * quaternion2 * axis;
			points[1].point = Quaternion.Inverse(quaternion) * quaternion2 * axis;
			points[2].point = Quaternion.Inverse(quaternion) * Quaternion.Inverse(quaternion2) * axis;
			points[3].point = quaternion * Quaternion.Inverse(quaternion2) * axis;
			BuildReachCones();
		}

		public void BuildReachCones()
		{
			smoothIterations = Mathf.Clamp(smoothIterations, 0, 3);
			P = new Vector3[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				ref Vector3 reference = ref P[i];
				reference = points[i].point.normalized;
			}
			for (int j = 0; j < smoothIterations; j++)
			{
				P = SmoothPoints();
			}
			reachCones = new ReachCone[P.Length];
			for (int k = 0; k < reachCones.Length - 1; k++)
			{
				reachCones[k] = new ReachCone(Vector3.zero, axis.normalized, P[k], P[k + 1]);
			}
			reachCones[P.Length - 1] = new ReachCone(Vector3.zero, axis.normalized, P[P.Length - 1], P[0]);
			for (int l = 0; l < reachCones.Length; l++)
			{
				reachCones[l].Calculate();
			}
		}

		private Vector3[] SmoothPoints()
		{
			Vector3[] array = new Vector3[P.Length * 2];
			float scalar = GetScalar(P.Length);
			for (int i = 0; i < array.Length; i += 2)
			{
				ref Vector3 reference = ref array[i];
				reference = PointToTangentPlane(P[i / 2], 1f);
			}
			for (int j = 1; j < array.Length; j += 2)
			{
				Vector3 vector = Vector3.zero;
				Vector3 zero = Vector3.zero;
				Vector3 vector2 = Vector3.zero;
				if (j > 1 && j < array.Length - 2)
				{
					vector = array[j - 2];
					vector2 = array[j + 1];
				}
				else if (j == 1)
				{
					vector = array[array.Length - 2];
					vector2 = array[j + 1];
				}
				else if (j == array.Length - 1)
				{
					vector = array[j - 2];
					vector2 = array[0];
				}
				zero = ((j >= array.Length - 1) ? array[0] : array[j + 1]);
				int num = array.Length / points.Length;
				ref Vector3 reference2 = ref array[j];
				reference2 = 0.5f * (array[j - 1] + zero) + scalar * points[j / num].tangentWeight * (zero - vector) + scalar * points[j / num].tangentWeight * (array[j - 1] - vector2);
			}
			for (int k = 0; k < array.Length; k++)
			{
				ref Vector3 reference3 = ref array[k];
				reference3 = TangentPointToSphere(array[k], 1f);
			}
			return array;
		}

		private float GetScalar(int k)
		{
			if (k <= 3)
			{
				return 0.1667f;
			}
			return k switch
			{
				4 => 0.1036f, 
				5 => 0.085f, 
				6 => 0.0773f, 
				7 => 0.07f, 
				_ => 0.0625f, 
			};
		}

		private Vector3 PointToTangentPlane(Vector3 p, float r)
		{
			float num = Vector3.Dot(axis, p);
			float num2 = 2f * r * r / (r * r + num);
			return num2 * p + (1f - num2) * -axis;
		}

		private Vector3 TangentPointToSphere(Vector3 q, float r)
		{
			float num = Vector3.Dot(q - axis, q - axis);
			float num2 = 4f * r * r / (4f * r * r + num);
			return num2 * q + (1f - num2) * -axis;
		}

		private Quaternion LimitSwing(Quaternion rotation)
		{
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			int reachCone = GetReachCone(vector);
			if (reachCone == -1)
			{
				if (!Warning.logged)
				{
					LogWarning("RotationLimitPolygonal reach cones are invalid.");
				}
				return rotation;
			}
			float num = Vector3.Dot(reachCones[reachCone].B, vector);
			if (num > 0f)
			{
				return rotation;
			}
			Vector3 rhs = Vector3.Cross(axis, vector);
			vector = Vector3.Cross(-reachCones[reachCone].B, rhs);
			Quaternion quaternion = Quaternion.FromToRotation(rotation * axis, vector);
			return quaternion * rotation;
		}

		private int GetReachCone(Vector3 L)
		{
			float num = 0f;
			float num2 = Vector3.Dot(reachCones[0].S, L);
			for (int i = 0; i < reachCones.Length; i++)
			{
				num = num2;
				num2 = ((i >= reachCones.Length - 1) ? Vector3.Dot(reachCones[0].S, L) : Vector3.Dot(reachCones[i + 1].S, L));
				if (num >= 0f && num2 < 0f)
				{
					return i;
				}
			}
			return -1;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Spline")]
	public class RotationLimitSpline : RotationLimit
	{
		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[SerializeField]
		[HideInInspector]
		public AnimationCurve spline;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_spline.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetSpline(Keyframe[] keyframes)
		{
			spline.keys = keyframes;
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			Quaternion rotation2 = LimitSwing(rotation);
			return RotationLimit.LimitTwist(rotation2, axis, base.secondaryAxis, twistLimit);
		}

		public Quaternion LimitSwing(Quaternion rotation)
		{
			if (axis == Vector3.zero)
			{
				return rotation;
			}
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			float num = RotationLimit.GetOrthogonalAngle(vector, base.secondaryAxis, axis);
			float num2 = Vector3.Dot(vector, base.crossAxis);
			if (num2 < 0f)
			{
				num = 180f + (180f - num);
			}
			float maxDegreesDelta = spline.Evaluate(num);
			Quaternion to = Quaternion.FromToRotation(axis, vector);
			Quaternion quaternion = Quaternion.RotateTowards(Quaternion.identity, to, maxDegreesDelta);
			Quaternion quaternion2 = Quaternion.FromToRotation(vector, quaternion * axis);
			return quaternion2 * rotation;
		}
	}
	public class AimPoser : MonoBehaviour
	{
		[Serializable]
		public class Pose
		{
			public bool visualize = true;

			public string name;

			public Vector3 direction;

			public float yaw = 75f;

			public float pitch = 45f;

			private float angleBuffer;

			public bool IsInDirection(Vector3 d)
			{
				if (direction == Vector3.zero)
				{
					return false;
				}
				if (yaw <= 0f || pitch <= 0f)
				{
					return false;
				}
				if (yaw < 180f)
				{
					Vector3 vector = new Vector3(direction.x, 0f, direction.z);
					if (vector == Vector3.zero)
					{
						vector = Vector3.forward;
					}
					Vector3 from = new Vector3(d.x, 0f, d.z);
					float num = Vector3.Angle(from, vector);
					if (num > yaw + angleBuffer)
					{
						return false;
					}
				}
				if (pitch >= 180f)
				{
					return true;
				}
				float num2 = Vector3.Angle(Vector3.up, direction);
				float num3 = Vector3.Angle(Vector3.up, d);
				return Mathf.Abs(num3 - num2) < pitch + angleBuffer;
			}

			public void SetAngleBuffer(float value)
			{
				angleBuffer = value;
			}
		}

		public float angleBuffer = 5f;

		public Pose[] poses = new Pose[0];

		public Pose GetPose(Vector3 localDirection)
		{
			if (poses.Length == 0)
			{
				return null;
			}
			for (int i = 0; i < poses.Length - 1; i++)
			{
				if (poses[i].IsInDirection(localDirection))
				{
					return poses[i];
				}
			}
			return poses[poses.Length - 1];
		}

		public void SetPoseActive(Pose pose)
		{
			for (int i = 0; i < poses.Length; i++)
			{
				poses[i].SetAngleBuffer((poses[i] != pose) ? 0f : angleBuffer);
			}
		}
	}
	public class Amplifier : OffsetModifier
	{
		[Serializable]
		public class Body
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("The Transform that's motion we are reading.")]
			public Transform transform;

			[Tooltip("Amplify the 'transform's' position relative to this Transform.")]
			public Transform relativeTo;

			[Tooltip("Linking the body to effectors. One Body can be used to offset more than one effector.")]
			public EffectorLink[] effectorLinks;

			[Tooltip("Amplification magnitude along the up axis of the character.")]
			public float verticalWeight = 1f;

			[Tooltip("Amplification magnitude along the horizontal axes of the character.")]
			public float horizontalWeight = 1f;

			[Tooltip("Speed of the amplifier. 0 means instant.")]
			public float speed = 3f;

			private Vector3 lastRelativePos;

			private Vector3 smoothDelta;

			private bool firstUpdate;

			public void Update(IKSolverFullBodyBiped solver, float w, float deltaTime)
			{
				if (!(transform == null) && !(relativeTo == null))
				{
					Vector3 vector = relativeTo.InverseTransformDirection(transform.position - relativeTo.position);
					if (firstUpdate)
					{
						lastRelativePos = vector;
						firstUpdate = false;
					}
					Vector3 vector2 = (vector - lastRelativePos) / deltaTime;
					smoothDelta = ((!(speed <= 0f)) ? Vector3.Lerp(smoothDelta, vector2, deltaTime * speed) : vector2);
					Vector3 v = relativeTo.TransformDirection(smoothDelta);
					Vector3 vector3 = V3Tools.ExtractVertical(v, solver.GetRoot().up, verticalWeight) + V3Tools.ExtractHorizontal(v, solver.GetRoot().up, horizontalWeight);
					for (int i = 0; i < effectorLinks.Length; i++)
					{
						solver.GetEffector(effectorLinks[i].effector).positionOffset += vector3 * w * effectorLinks[i].weight;
					}
					lastRelativePos = vector;
				}
			}

			private static Vector3 Multiply(Vector3 v1, Vector3 v2)
			{
				v1.x *= v2.x;
				v1.y *= v2.y;
				v1.z *= v2.z;
				return v1;
			}
		}

		[Tooltip("The amplified bodies.")]
		public Body[] bodies;

		protected override void OnModifyOffset()
		{
			if (!ik.fixTransforms)
			{
				if (!Warning.logged)
				{
					Warning.Log("Amplifier needs the Fix Transforms option of the FBBIK to be set to true. Otherwise it might amplify to infinity, should the animator of the character stop because of culling.", base.transform);
				}
				return;
			}
			Body[] array = bodies;
			foreach (Body body in array)
			{
				body.Update(ik.solver, weight, base.deltaTime);
			}
		}
	}
	public class BodyTilt : OffsetModifier
	{
		[Tooltip("Speed of tilting")]
		public float tiltSpeed = 6f;

		[Tooltip("Sensitivity of tilting")]
		public float tiltSensitivity = 0.07f;

		[Tooltip("The OffsetPose components")]
		public OffsetPose poseLeft;

		[Tooltip("The OffsetPose components")]
		public OffsetPose poseRight;

		private float tiltAngle;

		private Vector3 lastForward;

		protected override void Start()
		{
			base.Start();
			lastForward = base.transform.forward;
		}

		protected override void OnModifyOffset()
		{
			Quaternion quaternion = Quaternion.FromToRotation(lastForward, base.transform.forward);
			float angle = 0f;
			Vector3 axis = Vector3.zero;
			quaternion.ToAngleAxis(out angle, out axis);
			if (axis.y > 0f)
			{
				angle = 0f - angle;
			}
			angle *= tiltSensitivity * 0.01f;
			angle /= base.deltaTime;
			angle = Mathf.Clamp(angle, -1f, 1f);
			tiltAngle = Mathf.Lerp(tiltAngle, angle, base.deltaTime * tiltSpeed);
			float num = Mathf.Abs(tiltAngle) / 1f;
			if (tiltAngle < 0f)
			{
				poseRight.Apply(ik.solver, num);
			}
			else
			{
				poseLeft.Apply(ik.solver, num);
			}
			lastForward = base.transform.forward;
		}
	}
	public class HitReaction : OffsetModifier
	{
		[Serializable]
		public abstract class HitPoint
		{
			[Tooltip("Just for visual clarity, not used at all")]
			public string name;

			[Tooltip("Linking this hit point to a collider")]
			public Collider collider;

			[Tooltip("Only used if this hit point gets hit when already processing another hit")]
			[SerializeField]
			private float crossFadeTime = 0.1f;

			private float length;

			private float crossFadeSpeed;

			private float lastTime;

			public bool inProgress => timer < length;

			protected float crossFader { get; private set; }

			protected float timer { get; private set; }

			protected Vector3 force { get; private set; }

			protected Vector3 point { get; private set; }

			public void Hit(Vector3 force, Vector3 point)
			{
				if (length == 0f)
				{
					length = GetLength();
				}
				if (length <= 0f)
				{
					Debug.LogError("Hit Point WeightCurve length is zero.");
					return;
				}
				if (timer < 1f)
				{
					crossFader = 0f;
				}
				crossFadeSpeed = ((!(crossFadeTime > 0f)) ? 0f : (1f / crossFadeTime));
				CrossFadeStart();
				timer = 0f;
				this.force = force;
				this.point = point;
			}

			public void Apply(IKSolverFullBodyBiped solver, float weight)
			{
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(timer >= length))
				{
					timer = Mathf.Clamp(timer + num, 0f, length);
					if (crossFadeSpeed > 0f)
					{
						crossFader = Mathf.Clamp(crossFader + num * crossFadeSpeed, 0f, 1f);
					}
					else
					{
						crossFader = 1f;
					}
					OnApply(solver, weight);
				}
			}

			protected abstract float GetLength();

			protected abstract void CrossFadeStart();

			protected abstract void OnApply(IKSolverFullBodyBiped solver, float weight);
		}

		[Serializable]
		public class HitPointEffector : HitPoint
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("The FBBIK effector type")]
				public FullBodyBipedEffector effector;

				[Tooltip("The weight of this effector (could also be negative)")]
				public float weight;

				private Vector3 lastValue;

				private Vector3 current;

				public void Apply(IKSolverFullBodyBiped solver, Vector3 offset, float crossFader)
				{
					current = Vector3.Lerp(lastValue, offset * weight, crossFader);
					solver.GetEffector(effector).positionOffset += current;
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("Offset magnitude in the direction of the hit force")]
			public AnimationCurve offsetInForceDirection;

			[Tooltip("Offset magnitude in the direction of character.up")]
			public AnimationCurve offsetInUpDirection;

			[Tooltip("Linking this offset to the FBBIK effectors")]
			public EffectorLink[] effectorLinks;

			protected override float GetLength()
			{
				float num = ((offsetInForceDirection.keys.Length <= 0) ? 0f : offsetInForceDirection.keys[offsetInForceDirection.length - 1].time);
				float min = ((offsetInUpDirection.keys.Length <= 0) ? 0f : offsetInUpDirection.keys[offsetInUpDirection.length - 1].time);
				return Mathf.Clamp(num, min, num);
			}

			protected override void CrossFadeStart()
			{
				EffectorLink[] array = effectorLinks;
				foreach (EffectorLink effectorLink in array)
				{
					effectorLink.CrossFadeStart();
				}
			}

			protected override void OnApply(IKSolverFullBodyBiped solver, float weight)
			{
				Vector3 vector = solver.GetRoot().up * base.force.magnitude;
				Vector3 offset = offsetInForceDirection.Evaluate(base.timer) * base.force + offsetInUpDirection.Evaluate(base.timer) * vector;
				offset *= weight;
				EffectorLink[] array = effectorLinks;
				foreach (EffectorLink effectorLink in array)
				{
					effectorLink.Apply(solver, offset, base.crossFader);
				}
			}
		}

		[Serializable]
		public class HitPointBone : HitPoint
		{
			[Serializable]
			public class BoneLink
			{
				[Tooltip("Reference to the bone that this hit point rotates")]
				public Transform bone;

				[Tooltip("Weight of rotating the bone")]
				[Range(0f, 1f)]
				public float weight;

				private Quaternion lastValue = Quaternion.identity;

				private Quaternion current = Quaternion.identity;

				public void Apply(IKSolverFullBodyBiped solver, Quaternion offset, float crossFader)
				{
					current = Quaternion.Lerp(lastValue, Quaternion.Lerp(Quaternion.identity, offset, weight), crossFader);
					bone.rotation = current * bone.rotation;
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("The angle to rotate the bone around it's rigidbody's world center of mass")]
			public AnimationCurve aroundCenterOfMass;

			[Tooltip("Linking this hit point to bone(s)")]
			public BoneLink[] boneLinks;

			private Rigidbody rigidbody;

			protected override float GetLength()
			{
				return (aroundCenterOfMass.keys.Length <= 0) ? 0f : aroundCenterOfMass.keys[aroundCenterOfMass.length - 1].time;
			}

			protected override void CrossFadeStart()
			{
				BoneLink[] array = boneLinks;
				foreach (BoneLink boneLink in array)
				{
					boneLink.CrossFadeStart();
				}
			}

			protected override void OnApply(IKSolverFullBodyBiped solver, float weight)
			{
				if (rigidbody == null)
				{
					rigidbody = collider.GetComponent<Rigidbody>();
				}
				if (rigidbody != null)
				{
					Vector3 axis = Vector3.Cross(base.force, base.point - rigidbody.worldCenterOfMass);
					float angle = aroundCenterOfMass.Evaluate(base.timer) * weight;
					Quaternion offset = Quaternion.AngleAxis(angle, axis);
					BoneLink[] array = boneLinks;
					foreach (BoneLink boneLink in array)
					{
						boneLink.Apply(solver, offset, base.crossFader);
					}
				}
			}
		}

		[Tooltip("Hit points for the FBBIK effectors")]
		public HitPointEffector[] effectorHitPoints;

		[Tooltip(" Hit points for bones without an effector, such as the head")]
		public HitPointBone[] boneHitPoints;

		public bool inProgress
		{
			get
			{
				HitPointEffector[] array = effectorHitPoints;
				foreach (HitPointEffector hitPointEffector in array)
				{
					if (hitPointEffector.inProgress)
					{
						return true;
					}
				}
				HitPointBone[] array2 = boneHitPoints;
				foreach (HitPointBone hitPointBone in array2)
				{
					if (hitPointBone.inProgress)
					{
						return true;
					}
				}
				return false;
			}
		}

		protected override void OnModifyOffset()
		{
			HitPointEffector[] array = effectorHitPoints;
			foreach (HitPointEffector hitPointEffector in array)
			{
				hitPointEffector.Apply(ik.solver, weight);
			}
			HitPointBone[] array2 = boneHitPoints;
			foreach (HitPointBone hitPointBone in array2)
			{
				hitPointBone.Apply(ik.solver, weight);
			}
		}

		public void Hit(Collider collider, Vector3 force, Vector3 point)
		{
			if (ik == null)
			{
				Debug.LogError("No IK assigned in HitReaction");
				return;
			}
			HitPointEffector[] array = effectorHitPoints;
			foreach (HitPointEffector hitPointEffector in array)
			{
				if (hitPointEffector.collider == collider)
				{
					hitPointEffector.Hit(force, point);
				}
			}
			HitPointBone[] array2 = boneHitPoints;
			foreach (HitPointBone hitPointBone in array2)
			{
				if (hitPointBone.collider == collider)
				{
					hitPointBone.Hit(force, point);
				}
			}
		}
	}
	public class HitReactionVRIK : OffsetModifierVRIK
	{
		[Serializable]
		public abstract class Offset
		{
			[Tooltip("Just for visual clarity, not used at all")]
			public string name;

			[Tooltip("Linking this hit point to a collider")]
			public Collider collider;

			[Tooltip("Only used if this hit point gets hit when already processing another hit")]
			[SerializeField]
			private float crossFadeTime = 0.1f;

			private float length;

			private float crossFadeSpeed;

			private float lastTime;

			protected float crossFader { get; private set; }

			protected float timer { get; private set; }

			protected Vector3 force { get; private set; }

			protected Vector3 point { get; private set; }

			public void Hit(Vector3 force, AnimationCurve[] curves, Vector3 point)
			{
				if (length == 0f)
				{
					length = GetLength(curves);
				}
				if (length <= 0f)
				{
					Debug.LogError("Hit Point WeightCurve length is zero.");
					return;
				}
				if (timer < 1f)
				{
					crossFader = 0f;
				}
				crossFadeSpeed = ((!(crossFadeTime > 0f)) ? 0f : (1f / crossFadeTime));
				CrossFadeStart();
				timer = 0f;
				this.force = force;
				this.point = point;
			}

			public void Apply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(timer >= length))
				{
					timer = Mathf.Clamp(timer + num, 0f, length);
					if (crossFadeSpeed > 0f)
					{
						crossFader = Mathf.Clamp(crossFader + num * crossFadeSpeed, 0f, 1f);
					}
					else
					{
						crossFader = 1f;
					}
					OnApply(ik, curves, weight);
				}
			}

			protected abstract float GetLength(AnimationCurve[] curves);

			protected abstract void CrossFadeStart();

			protected abstract void OnApply(VRIK ik, AnimationCurve[] curves, float weight);
		}

		[Serializable]
		public class PositionOffset : Offset
		{
			[Serializable]
			public class PositionOffsetLink
			{
				[Tooltip("The FBBIK effector type")]
				public IKSolverVR.PositionOffset positionOffset;

				[Tooltip("The weight of this effector (could also be negative)")]
				public float weight;

				private Vector3 lastValue;

				private Vector3 current;

				public void Apply(VRIK ik, Vector3 offset, float crossFader)
				{
					current = Vector3.Lerp(lastValue, offset * weight, crossFader);
					ik.solver.AddPositionOffset(positionOffset, current);
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("Offset magnitude in the direction of the hit force")]
			public int forceDirCurveIndex;

			[Tooltip("Offset magnitude in the direction of character.up")]
			public int upDirCurveIndex = 1;

			[Tooltip("Linking this offset to the VRIK position offsets")]
			public PositionOffsetLink[] offsetLinks;

			protected override float GetLength(AnimationCurve[] curves)
			{
				float num = ((curves[forceDirCurveIndex].keys.Length <= 0) ? 0f : curves[forceDirCurveIndex].keys[curves[forceDirCurveIndex].length - 1].time);
				float min = ((curves[upDirCurveIndex].keys.Length <= 0) ? 0f : curves[upDirCurveIndex].keys[curves[upDirCurveIndex].length - 1].time);
				return Mathf.Clamp(num, min, num);
			}

			protected override void CrossFadeStart()
			{
				PositionOffsetLink[] array = offsetLinks;
				foreach (PositionOffsetLink positionOffsetLink in array)
				{
					positionOffsetLink.CrossFadeStart();
				}
			}

			protected override void OnApply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				Vector3 vector = ik.transform.up * base.force.magnitude;
				Vector3 offset = curves[forceDirCurveIndex].Evaluate(base.timer) * base.force + curves[upDirCurveIndex].Evaluate(base.timer) * vector;
				offset *= weight;
				PositionOffsetLink[] array = offsetLinks;
				foreach (PositionOffsetLink positionOffsetLink in array)
				{
					positionOffsetLink.Apply(ik, offset, base.crossFader);
				}
			}
		}

		[Serializable]
		public class RotationOffset : Offset
		{
			[Serializable]
			public class RotationOffsetLink
			{
				[Tooltip("Reference to the bone that this hit point rotates")]
				public IKSolverVR.RotationOffset rotationOffset;

				[Tooltip("Weight of rotating the bone")]
				[Range(0f, 1f)]
				public float weight;

				private Quaternion lastValue = Quaternion.identity;

				private Quaternion current = Quaternion.identity;

				public void Apply(VRIK ik, Quaternion offset, float crossFader)
				{
					current = Quaternion.Lerp(lastValue, Quaternion.Lerp(Quaternion.identity, offset, weight), crossFader);
					ik.solver.AddRotationOffset(rotationOffset, current);
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("The angle to rotate the bone around it's rigidbody's world center of mass")]
			public int curveIndex;

			[Tooltip("Linking this hit point to bone(s)")]
			public RotationOffsetLink[] offsetLinks;

			private Rigidbody rigidbody;

			protected override float GetLength(AnimationCurve[] curves)
			{
				return (curves[curveIndex].keys.Length <= 0) ? 0f : curves[curveIndex].keys[curves[curveIndex].length - 1].time;
			}

			protected override void CrossFadeStart()
			{
				RotationOffsetLink[] array = offsetLinks;
				foreach (RotationOffsetLink rotationOffsetLink in array)
				{
					rotationOffsetLink.CrossFadeStart();
				}
			}

			protected override void OnApply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				if (collider == null)
				{
					Debug.LogError("No collider assigned for a HitPointBone in the HitReaction component.");
					return;
				}
				if (rigidbody == null)
				{
					rigidbody = collider.GetComponent<Rigidbody>();
				}
				if (rigidbody != null)
				{
					Vector3 axis = Vector3.Cross(base.force, base.point - rigidbody.worldCenterOfMass);
					float angle = curves[curveIndex].Evaluate(base.timer) * weight;
					Quaternion offset = Quaternion.AngleAxis(angle, axis);
					RotationOffsetLink[] array = offsetLinks;
					foreach (RotationOffsetLink rotationOffsetLink in array)
					{
						rotationOffsetLink.Apply(ik, offset, base.crossFader);
					}
				}
			}
		}

		public AnimationCurve[] offsetCurves;

		[Tooltip("Hit points for the FBBIK effectors")]
		public PositionOffset[] positionOffsets;

		[Tooltip(" Hit points for bones without an effector, such as the head")]
		public RotationOffset[] rotationOffsets;

		protected override void OnModifyOffset()
		{
			PositionOffset[] array = positionOffsets;
			foreach (PositionOffset positionOffset in array)
			{
				positionOffset.Apply(ik, offsetCurves, weight);
			}
			RotationOffset[] array2 = rotationOffsets;
			foreach (RotationOffset rotationOffset in array2)
			{
				rotationOffset.Apply(ik, offsetCurves, weight);
			}
		}

		public void Hit(Collider collider, Vector3 force, Vector3 point)
		{
			if (ik == null)
			{
				Debug.LogError("No IK assigned in HitReaction");
				return;
			}
			PositionOffset[] array = positionOffsets;
			foreach (PositionOffset positionOffset in array)
			{
				if (positionOffset.collider == collider)
				{
					positionOffset.Hit(force, offsetCurves, point);
				}
			}
			RotationOffset[] array2 = rotationOffsets;
			foreach (RotationOffset rotationOffset in array2)
			{
				if (rotationOffset.collider == collider)
				{
					rotationOffset.Hit(force, offsetCurves, point);
				}
			}
		}
	}
	public class Inertia : OffsetModifier
	{
		[Serializable]
		public class Body
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("The Transform to follow, can be any bone of the character")]
			public Transform transform;

			[Tooltip("Linking the body to effectors. One Body can be used to offset more than one effector")]
			public EffectorLink[] effectorLinks;

			[Tooltip("The speed to follow the Transform")]
			public float speed = 10f;

			[Tooltip("The acceleration, smaller values means lazyer following")]
			public float acceleration = 3f;

			[Tooltip("Matching target velocity")]
			[Range(0f, 1f)]
			public float matchVelocity;

			[Tooltip("gravity applied to the Body")]
			public float gravity;

			private Vector3 delta;

			private Vector3 lazyPoint;

			private Vector3 direction;

			private Vector3 lastPosition;

			private bool firstUpdate = true;

			public void Reset()
			{
				if (!(transform == null))
				{
					lazyPoint = transform.position;
					lastPosition = transform.position;
					direction = Vector3.zero;
				}
			}

			public void Update(IKSolverFullBodyBiped solver, float weight, float deltaTime)
			{
				if (!(transform == null))
				{
					if (firstUpdate)
					{
						Reset();
						firstUpdate = false;
					}
					direction = Vector3.Lerp(direction, (transform.position - lazyPoint) / deltaTime * 0.01f, deltaTime * acceleration);
					lazyPoint += direction * deltaTime * speed;
					delta = transform.position - lastPosition;
					lazyPoint += delta * matchVelocity;
					lazyPoint.y += gravity * deltaTime;
					EffectorLink[] array = effectorLinks;
					foreach (EffectorLink effectorLink in array)
					{
						solver.GetEffector(effectorLink.effector).positionOffset += (lazyPoint - transform.position) * effectorLink.weight * weight;
					}
					lastPosition = transform.position;
				}
			}
		}

		[Tooltip("The array of Bodies")]
		public Body[] bodies;

		[Tooltip("The array of OffsetLimits")]
		public OffsetLimits[] limits;

		public void ResetBodies()
		{
			lastTime = Time.time;
			Body[] array = bodies;
			foreach (Body body in array)
			{
				body.Reset();
			}
		}

		protected override void OnModifyOffset()
		{
			Body[] array = bodies;
			foreach (Body body in array)
			{
				body.Update(ik.solver, weight, base.deltaTime);
			}
			ApplyLimits(limits);
		}
	}
	public abstract class OffsetModifier : MonoBehaviour
	{
		[Serializable]
		public class OffsetLimits
		{
			[Tooltip("The effector type (this is just an enum)")]
			public FullBodyBipedEffector effector;

			[Tooltip("Spring force, if zero then this is a hard limit, if not, offset can exceed the limit.")]
			public float spring;

			[Tooltip("Which axes to limit the offset on?")]
			public bool x;

			[Tooltip("Which axes to limit the offset on?")]
			public bool y;

			[Tooltip("Which axes to limit the offset on?")]
			public bool z;

			[Tooltip("The limits")]
			public float minX;

			[Tooltip("The limits")]
			public float maxX;

			[Tooltip("The limits")]
			public float minY;

			[Tooltip("The limits")]
			public float maxY;

			[Tooltip("The limits")]
			public float minZ;

			[Tooltip("The limits")]
			public float maxZ;

			public void Apply(IKEffector e, Quaternion rootRotation)
			{
				Vector3 vector = Quaternion.Inverse(rootRotation) * e.positionOffset;
				if (spring <= 0f)
				{
					if (x)
					{
						vector.x = Mathf.Clamp(vector.x, minX, maxX);
					}
					if (y)
					{
						vector.y = Mathf.Clamp(vector.y, minY, maxY);
					}
					if (z)
					{
						vector.z = Mathf.Clamp(vector.z, minZ, maxZ);
					}
				}
				else
				{
					if (x)
					{
						vector.x = SpringAxis(vector.x, minX, maxX);
					}
					if (y)
					{
						vector.y = SpringAxis(vector.y, minY, maxY);
					}
					if (z)
					{
						vector.z = SpringAxis(vector.z, minZ, maxZ);
					}
				}
				e.positionOffset = rootRotation * vector;
			}

			private float SpringAxis(float value, float min, float max)
			{
				if (value > min && value < max)
				{
					return value;
				}
				if (value < min)
				{
					return Spring(value, min, negative: true);
				}
				return Spring(value, max, negative: false);
			}

			private float Spring(float value, float limit, bool negative)
			{
				float num = value - limit;
				float num2 = num * spring;
				if (negative)
				{
					return value + Mathf.Clamp(0f - num2, 0f, 0f - num);
				}
				return value - Mathf.Clamp(num2, 0f, num);
			}
		}

		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Reference to the FBBIK component")]
		public FullBodyBipedIK ik;

		protected float lastTime;

		protected float deltaTime => Time.time - lastTime;

		protected abstract void OnModifyOffset();

		protected virtual void Start()
		{
			StartCoroutine(Initiate());
		}

		private IEnumerator Initiate()
		{
			while (ik == null)
			{
				yield return null;
			}
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			lastTime = Time.time;
		}

		private void ModifyOffset()
		{
			if (base.enabled && !(weight <= 0f) && !(deltaTime <= 0f) && !(ik == null))
			{
				weight = Mathf.Clamp(weight, 0f, 1f);
				OnModifyOffset();
				lastTime = Time.time;
			}
		}

		protected void ApplyLimits(OffsetLimits[] limits)
		{
			foreach (OffsetLimits offsetLimits in limits)
			{
				offsetLimits.Apply(ik.solver.GetEffector(offsetLimits.effector), base.transform.rotation);
			}
		}

		protected virtual void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			}
		}
	}
	public abstract class OffsetModifierVRIK : MonoBehaviour
	{
		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Reference to the VRIK component")]
		public VRIK ik;

		private float lastTime;

		protected float deltaTime => Time.time - lastTime;

		protected abstract void OnModifyOffset();

		protected virtual void Start()
		{
			StartCoroutine(Initiate());
		}

		private IEnumerator Initiate()
		{
			while (ik == null)
			{
				yield return null;
			}
			IKSolverVR solver = ik.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			lastTime = Time.time;
		}

		private void ModifyOffset()
		{
			if (base.enabled && !(weight <= 0f) && !(deltaTime <= 0f) && !(ik == null))
			{
				weight = Mathf.Clamp(weight, 0f, 1f);
				OnModifyOffset();
				lastTime = Time.time;
			}
		}

		protected virtual void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverVR solver = ik.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			}
		}
	}
	public class OffsetPose : MonoBehaviour
	{
		[Serializable]
		public class EffectorLink
		{
			public FullBodyBipedEffector effector;

			public Vector3 offset;

			public Vector3 pin;

			public Vector3 pinWeight;

			public void Apply(IKSolverFullBodyBiped solver, float weight, Quaternion rotation)
			{
				solver.GetEffector(effector).positionOffset += rotation * offset * weight;
				Vector3 vector = solver.GetRoot().position + rotation * pin;
				Vector3 vector2 = vector - solver.GetEffector(effector).bone.position;
				Vector3 vector3 = pinWeight * Mathf.Abs(weight);
				solver.GetEffector(effector).positionOffset = new Vector3(Mathf.Lerp(solver.GetEffector(effector).positionOffset.x, vector2.x, vector3.x), Mathf.Lerp(solver.GetEffector(effector).positionOffset.y, vector2.y, vector3.y), Mathf.Lerp(solver.GetEffector(effector).positionOffset.z, vector2.z, vector3.z));
			}
		}

		public EffectorLink[] effectorLinks = new EffectorLink[0];

		public void Apply(IKSolverFullBodyBiped solver, float weight)
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Apply(solver, weight, solver.GetRoot().rotation);
			}
		}

		public void Apply(IKSolverFullBodyBiped solver, float weight, Quaternion rotation)
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Apply(solver, weight, rotation);
			}
		}
	}
	public class Recoil : OffsetModifier
	{
		[Serializable]
		public class RecoilOffset
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("Offset vector for the associated effector when doing recoil.")]
			public Vector3 offset;

			[Tooltip("When firing before the last recoil has faded, how much of the current recoil offset will be maintained?")]
			[Range(0f, 1f)]
			public float additivity = 1f;

			[Tooltip("Max additive recoil for automatic fire.")]
			public float maxAdditiveOffsetMag = 0.2f;

			[Tooltip("Linking this recoil offset to FBBIK effectors.")]
			public EffectorLink[] effectorLinks;

			private Vector3 additiveOffset;

			private Vector3 lastOffset;

			public void Start()
			{
				if (!(additivity <= 0f))
				{
					additiveOffset = Vector3.ClampMagnitude(lastOffset * additivity, maxAdditiveOffsetMag);
				}
			}

			public void Apply(IKSolverFullBodyBiped solver, Quaternion rotation, float masterWeight, float length, float timeLeft)
			{
				additiveOffset = Vector3.Lerp(Vector3.zero, additiveOffset, timeLeft / length);
				lastOffset = rotation * (offset * masterWeight) + rotation * additiveOffset;
				EffectorLink[] array = effectorLinks;
				foreach (EffectorLink effectorLink in array)
				{
					solver.GetEffector(effectorLink.effector).positionOffset += lastOffset * effectorLink.weight;
				}
			}
		}

		[Serializable]
		public enum Handedness
		{
			Right,
			Left
		}

		[Tooltip("Reference to the AimIK component. Optional, only used to getting the aiming direction.")]
		public AimIK aimIK;

		[Tooltip("Set this true if you are using IKExecutionOrder.cs or a custom script to force AimIK solve after FBBIK.")]
		public bool aimIKSolvedLast;

		[Tooltip("Which hand is holding the weapon?")]
		public Handedness handedness;

		[Tooltip("Check for 2-handed weapons.")]
		public bool twoHanded = true;

		[Tooltip("Weight curve for the recoil offsets. Recoil procedure is as long as this curve.")]
		public AnimationCurve recoilWeight;

		[Tooltip("How much is the magnitude randomized each time Recoil is called?")]
		public float magnitudeRandom = 0.1f;

		[Tooltip("How much is the rotation randomized each time Recoil is called?")]
		public Vector3 rotationRandom;

		[Tooltip("Rotating the primary hand bone for the recoil (in local space).")]
		public Vector3 handRotationOffset;

		[Tooltip("Time of blending in another recoil when doing automatic fire.")]
		public float blendTime;

		[Space(10f)]
		[Tooltip("FBBIK effector position offsets for the recoil (in aiming direction space).")]
		public RecoilOffset[] offsets;

		[HideInInspector]
		public Quaternion rotationOffset = Quaternion.identity;

		private float magnitudeMlp = 1f;

		private float endTime = -1f;

		private Quaternion handRotation;

		private Quaternion secondaryHandRelativeRotation;

		private Quaternion randomRotation;

		private float length = 1f;

		private bool initiated;

		private float blendWeight;

		private float w;

		private Quaternion primaryHandRotation = Quaternion.identity;

		private bool handRotationsSet;

		private Vector3 aimIKAxis;

		public bool isFinished => Time.time > endTime;

		private IKEffector primaryHandEffector
		{
			get
			{
				if (handedness == Handedness.Right)
				{
					return ik.solver.rightHandEffector;
				}
				return ik.solver.leftHandEffector;
			}
		}

		private IKEffector secondaryHandEffector
		{
			get
			{
				if (handedness == Handedness.Right)
				{
					return ik.solver.leftHandEffector;
				}
				return ik.solver.rightHandEffector;
			}
		}

		private Transform primaryHand => primaryHandEffector.bone;

		private Transform secondaryHand => secondaryHandEffector.bone;

		public void SetHandRotations(Quaternion leftHandRotation, Quaternion rightHandRotation)
		{
			if (handedness == Handedness.Left)
			{
				primaryHandRotation = leftHandRotation;
			}
			else
			{
				primaryHandRotation = rightHandRotation;
			}
			handRotationsSet = true;
		}

		public void Fire(float magnitude)
		{
			float num = magnitude * Random.value * magnitudeRandom;
			magnitudeMlp = magnitude + num;
			randomRotation = Quaternion.Euler(rotationRandom * Random.value);
			RecoilOffset[] array = offsets;
			foreach (RecoilOffset recoilOffset in array)
			{
				recoilOffset.Start();
			}
			if (Time.time < endTime)
			{
				blendWeight = 0f;
			}
			else
			{
				blendWeight = 1f;
			}
			Keyframe[] keys = recoilWeight.keys;
			length = keys[keys.Length - 1].time;
			endTime = Time.time + length;
		}

		protected override void OnModifyOffset()
		{
			if (aimIK != null)
			{
				aimIKAxis = aimIK.solver.axis;
			}
			if (Time.time >= endTime)
			{
				rotationOffset = Quaternion.identity;
				return;
			}
			if (!initiated && ik != null)
			{
				initiated = true;
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
				if (aimIK != null)
				{
					IKSolverAim solver2 = aimIK.solver;
					solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(AfterAimIK));
				}
			}
			blendTime = Mathf.Max(blendTime, 0f);
			if (blendTime > 0f)
			{
				blendWeight = Mathf.Min(blendWeight + Time.deltaTime * (1f / blendTime), 1f);
			}
			else
			{
				blendWeight = 1f;
			}
			float b = recoilWeight.Evaluate(length - (endTime - Time.time)) * magnitudeMlp;
			w = Mathf.Lerp(w, b, blendWeight);
			Quaternion quaternion = ((!(aimIK != null) || aimIKSolvedLast) ? ik.references.root.rotation : Quaternion.LookRotation(aimIK.solver.IKPosition - aimIK.solver.transform.position, ik.references.root.up));
			quaternion = randomRotation * quaternion;
			RecoilOffset[] array = offsets;
			foreach (RecoilOffset recoilOffset in array)
			{
				recoilOffset.Apply(ik.solver, quaternion, w, length, endTime - Time.time);
			}
			if (!handRotationsSet)
			{
				primaryHandRotation = primaryHand.rotation;
			}
			handRotationsSet = false;
			rotationOffset = Quaternion.Lerp(Quaternion.identity, Quaternion.Euler(randomRotation * primaryHandRotation * handRotationOffset), w);
			handRotation = rotationOffset * primaryHandRotation;
			if (twoHanded)
			{
				Vector3 vector = Quaternion.Inverse(primaryHand.rotation) * (secondaryHand.position - primaryHand.position);
				secondaryHandRelativeRotation = Quaternion.Inverse(primaryHand.rotation) * secondaryHand.rotation;
				Vector3 vector2 = primaryHand.position + primaryHandEffector.positionOffset;
				Vector3 vector3 = vector2 + handRotation * vector;
				secondaryHandEffector.positionOffset += vector3 - (secondaryHand.position + secondaryHandEffector.positionOffset);
			}
			if (aimIK != null && aimIKSolvedLast)
			{
				aimIK.solver.axis = Quaternion.Inverse(ik.references.root.rotation) * Quaternion.Inverse(rotationOffset) * aimIKAxis;
			}
		}

		private void AfterFBBIK()
		{
			if (!(Time.time >= endTime))
			{
				primaryHand.rotation = handRotation;
				if (twoHanded)
				{
					secondaryHand.rotation = primaryHand.rotation * secondaryHandRelativeRotation;
				}
			}
		}

		private void AfterAimIK()
		{
			if (aimIKSolvedLast)
			{
				aimIK.solver.axis = aimIKAxis;
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (ik != null && initiated)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
				if (aimIK != null)
				{
					IKSolverAim solver2 = aimIK.solver;
					solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(AfterAimIK));
				}
			}
		}
	}
	public class ShoulderRotator : MonoBehaviour
	{
		[Tooltip("Weight of shoulder rotation")]
		public float weight = 1.5f;

		[Tooltip("The greater the offset, the sooner the shoulder will start rotating")]
		public float offset = 0.2f;

		private FullBodyBipedIK ik;

		private bool skip;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(RotateShoulders));
		}

		private void RotateShoulders()
		{
			if (!(ik == null) && !(ik.solver.IKPositionWeight <= 0f))
			{
				if (skip)
				{
					skip = false;
					return;
				}
				RotateShoulder(FullBodyBipedChain.LeftArm, weight, offset);
				RotateShoulder(FullBodyBipedChain.RightArm, weight, offset);
				skip = true;
				ik.solver.Update();
			}
		}

		private void RotateShoulder(FullBodyBipedChain chain, float weight, float offset)
		{
			Quaternion b = Quaternion.FromToRotation(GetParentBoneMap(chain).swingDirection, ik.solver.GetEndEffector(chain).position - GetParentBoneMap(chain).transform.position);
			Vector3 vector = ik.solver.GetEndEffector(chain).position - ik.solver.GetLimbMapping(chain).bone1.position;
			float num = ik.solver.GetChain(chain).nodes[0].length + ik.solver.GetChain(chain).nodes[1].length;
			float num2 = vector.magnitude / num - 1f + offset;
			num2 = Mathf.Clamp(num2 * weight, 0f, 1f);
			Quaternion quaternion = Quaternion.Lerp(Quaternion.identity, b, num2 * ik.solver.GetEndEffector(chain).positionWeight * ik.solver.IKPositionWeight);
			ik.solver.GetLimbMapping(chain).parentBone.rotation = quaternion * ik.solver.GetLimbMapping(chain).parentBone.rotation;
		}

		private IKMapping.BoneMap GetParentBoneMap(FullBodyBipedChain chain)
		{
			return ik.solver.GetLimbMapping(chain).GetBoneMap(IKMappingLimb.BoneMapType.Parent);
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(RotateShoulders));
			}
		}
	}
}
namespace RootMotion
{
	public class CameraController : MonoBehaviour
	{
		[Serializable]
		public enum UpdateMode
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		public Transform target;

		public Transform rotationSpace;

		public UpdateMode updateMode = UpdateMode.LateUpdate;

		public bool lockCursor = true;

		public bool smoothFollow;

		public float followSpeed = 10f;

		public float distance = 10f;

		public float minDistance = 4f;

		public float maxDistance = 10f;

		public float zoomSpeed = 10f;

		public float zoomSensitivity = 1f;

		public float rotationSensitivity = 3.5f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public Vector3 offset = new Vector3(0f, 1.5f, 0.5f);

		public bool rotateAlways = true;

		public bool rotateOnLeftButton;

		public bool rotateOnRightButton;

		public bool rotateOnMiddleButton;

		private Vector3 targetDistance;

		private Vector3 position;

		private Quaternion rotation = Quaternion.identity;

		private Vector3 smoothPosition;

		private Camera cam;

		private Quaternion r = Quaternion.identity;

		private Vector3 lastUp;

		public float x { get; private set; }

		public float y { get; private set; }

		public float distanceTarget { get; private set; }

		private float zoomAdd
		{
			get
			{
				float axis = Input.GetAxis("Mouse ScrollWheel");
				if (axis > 0f)
				{
					return 0f - zoomSensitivity;
				}
				if (axis < 0f)
				{
					return zoomSensitivity;
				}
				return 0f;
			}
		}

		protected virtual void Awake()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
			distanceTarget = distance;
			smoothPosition = base.transform.position;
			cam = GetComponent<Camera>();
			lastUp = ((!(rotationSpace != null)) ? Vector3.up : rotationSpace.up);
		}

		protected virtual void Update()
		{
			if (updateMode == UpdateMode.Update)
			{
				UpdateTransform();
			}
		}

		protected virtual void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate)
			{
				UpdateTransform();
			}
		}

		protected virtual void LateUpdate()
		{
			UpdateInput();
			if (updateMode == UpdateMode.LateUpdate)
			{
				UpdateTransform();
			}
		}

		public void UpdateInput()
		{
			if (!(target == null) && cam.enabled)
			{
				Cursor.lockState = (lockCursor ? CursorLockMode.Locked : CursorLockMode.None);
				Cursor.visible = !lockCursor;
				if (rotateAlways || (rotateOnLeftButton && Input.GetMouseButton(0)) || (rotateOnRightButton && Input.GetMouseButton(1)) || (rotateOnMiddleButton && Input.GetMouseButton(2)))
				{
					x += Input.GetAxis("Mouse X") * rotationSensitivity;
					y = ClampAngle(y - Input.GetAxis("Mouse Y") * rotationSensitivity, yMinLimit, yMaxLimit);
				}
				distanceTarget = Mathf.Clamp(distanceTarget + zoomAdd, minDistance, maxDistance);
			}
		}

		public void UpdateTransform()
		{
			UpdateTransform(Time.deltaTime);
		}

		public void UpdateTransform(float deltaTime)
		{
			if (!(target == null) && cam.enabled)
			{
				distance += (distanceTarget - distance) * zoomSpeed * deltaTime;
				rotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
				if (rotationSpace != null)
				{
					r = Quaternion.FromToRotation(lastUp, rotationSpace.up) * r;
					rotation = r * rotation;
					lastUp = rotationSpace.up;
				}
				if (!smoothFollow)
				{
					smoothPosition = target.position;
				}
				else
				{
					smoothPosition = Vector3.Lerp(smoothPosition, target.position, deltaTime * followSpeed);
				}
				position = smoothPosition + rotation * (offset - Vector3.forward * distance);
				base.transform.position = position;
				base.transform.rotation = rotation;
			}
		}

		private float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class CameraControllerFPS : MonoBehaviour
	{
		public float rotationSensitivity = 3f;

		public float yMinLimit = -89f;

		public float yMaxLimit = 89f;

		private float x;

		private float y;

		private void Awake()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
		}

		public void LateUpdate()
		{
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * rotationSensitivity;
			y = ClampAngle(y - Input.GetAxis("Mouse Y") * rotationSensitivity, yMinLimit, yMaxLimit);
			base.transform.rotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
		}

		private float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
}
namespace RootMotion.Demos
{
	public abstract class CharacterAnimationBase : MonoBehaviour
	{
		public bool smoothFollow = true;

		public float smoothFollowSpeed = 20f;

		private Vector3 lastPosition;

		private Vector3 localPosition;

		private Quaternion localRotation;

		private Quaternion lastRotation;

		public virtual bool animationGrounded => true;

		public virtual Vector3 GetPivotPoint()
		{
			return base.transform.position;
		}

		public float GetAngleFromForward(Vector3 worldDirection)
		{
			Vector3 vector = base.transform.InverseTransformDirection(worldDirection);
			return Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		}

		protected virtual void Start()
		{
			if (base.transform.parent.GetComponent<CharacterBase>() == null)
			{
				Debug.LogWarning("Animation controllers should be parented to character controllers!", base.transform);
			}
			lastPosition = base.transform.position;
			localPosition = base.transform.parent.InverseTransformPoint(base.transform.position);
			lastRotation = base.transform.rotation;
			localRotation = Quaternion.Inverse(base.transform.parent.rotation) * base.transform.rotation;
		}

		protected virtual void LateUpdate()
		{
			if (smoothFollow)
			{
				base.transform.position = Vector3.Lerp(lastPosition, base.transform.parent.TransformPoint(localPosition), Time.deltaTime * smoothFollowSpeed);
				base.transform.rotation = Quaternion.Lerp(lastRotation, base.transform.parent.rotation * localRotation, Time.deltaTime * smoothFollowSpeed);
			}
			lastPosition = base.transform.position;
			lastRotation = base.transform.rotation;
		}
	}
	[RequireComponent(typeof(Animator))]
	public class CharacterAnimationSimple : CharacterAnimationBase
	{
		[SerializeField]
		private CharacterThirdPerson characterController;

		[SerializeField]
		private float pivotOffset;

		[SerializeField]
		private AnimationCurve moveSpeed;

		private Animator animator;

		protected override void Start()
		{
			base.Start();
			animator = GetComponentInChildren<Animator>();
		}

		public override Vector3 GetPivotPoint()
		{
			if (pivotOffset == 0f)
			{
				return base.transform.position;
			}
			return base.transform.position + base.transform.forward * pivotOffset;
		}

		private void Update()
		{
			float num = moveSpeed.Evaluate(characterController.animState.moveDirection.z);
			animator.SetFloat("Speed", num);
			characterController.Move(characterController.transform.forward * Time.deltaTime * num, Quaternion.identity);
		}
	}
	[RequireComponent(typeof(Animator))]
	public class CharacterAnimationThirdPerson : CharacterAnimationBase
	{
		public CharacterThirdPerson characterController;

		[SerializeField]
		private float turnSensitivity = 0.2f;

		[SerializeField]
		private float turnSpeed = 5f;

		[SerializeField]
		private float runCycleLegOffset = 0.2f;

		[Range(0.1f, 3f)]
		[SerializeField]
		private float animSpeedMultiplier = 1f;

		protected Animator animator;

		private Vector3 lastForward;

		private const string groundedDirectional = "Grounded Directional";

		private const string groundedStrafe = "Grounded Strafe";

		public override bool animationGrounded => animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded Directional") || animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded Strafe");

		protected override void Start()
		{
			base.Start();
			animator = GetComponent<Animator>();
			lastForward = base.transform.forward;
		}

		public override Vector3 GetPivotPoint()
		{
			return animator.pivotPosition;
		}

		protected virtual void Update()
		{
			if (Time.deltaTime != 0f)
			{
				if (characterController.animState.jump)
				{
					float num = Mathf.Repeat(animator.GetCurrentAnimatorStateInfo(0).normalizedTime + runCycleLegOffset, 1f);
					float value = (float)((num < 0f) ? 1 : (-1)) * characterController.animState.moveDirection.z;
					animator.SetFloat("JumpLeg", value);
				}
				float num2 = 0f - GetAngleFromForward(lastForward);
				lastForward = base.transform.forward;
				num2 *= turnSensitivity * 0.01f;
				num2 = Mathf.Clamp(num2 / Time.deltaTime, -1f, 1f);
				animator.SetFloat("Turn", Mathf.Lerp(animator.GetFloat("Turn"), num2, Time.deltaTime * turnSpeed));
				animator.SetFloat("Forward", characterController.animState.moveDirection.z);
				animator.SetFloat("Right", characterController.animState.moveDirection.x);
				animator.SetBool("Crouch", characterController.animState.crouch);
				animator.SetBool("OnGround", characterController.animState.onGround);
				animator.SetBool("IsStrafing", characterController.animState.isStrafing);
				if (!characterController.animState.onGround)
				{
					animator.SetFloat("Jump", characterController.animState.yVelocity);
				}
				if (characterController.animState.onGround && characterController.animState.moveDirection.z > 0f)
				{
					animator.speed = animSpeedMultiplier;
				}
				else
				{
					animator.speed = 1f;
				}
			}
		}

		private void OnAnimatorMove()
		{
			characterController.Move(animator.deltaPosition, animator.deltaRotation);
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public abstract class CharacterBase : MonoBehaviour
	{
		[Header("Base Parameters")]
		[Tooltip("If specified, will use the direction from the character to this Transform as the gravity vector instead of Physics.gravity. Physics.gravity.magnitude will be used as the magnitude of the gravity vector.")]
		public Transform gravityTarget;

		[Tooltip("Multiplies gravity applied to the character even if 'Individual Gravity' is unchecked.")]
		[SerializeField]
		protected float gravityMultiplier = 2f;

		[SerializeField]
		protected float airborneThreshold = 0.6f;

		[SerializeField]
		private float slopeStartAngle = 50f;

		[SerializeField]
		private float slopeEndAngle = 85f;

		[SerializeField]
		private float spherecastRadius = 0.1f;

		[SerializeField]
		private LayerMask groundLayers;

		private PhysicMaterial zeroFrictionMaterial;

		private PhysicMaterial highFrictionMaterial;

		protected Rigidbody r;

		protected const float half = 0.5f;

		protected float originalHeight;

		protected Vector3 originalCenter;

		protected CapsuleCollider capsule;

		public abstract void Move(Vector3 deltaPosition, Quaternion deltaRotation);

		protected Vector3 GetGravity()
		{
			if (gravityTarget != null)
			{
				return (gravityTarget.position - base.transform.position).normalized * Physics.gravity.magnitude;
			}
			return Physics.gravity;
		}

		protected virtual void Start()
		{
			capsule = GetComponent<Collider>() as CapsuleCollider;
			r = GetComponent<Rigidbody>();
			originalHeight = capsule.height;
			originalCenter = capsule.center;
			zeroFrictionMaterial = new PhysicMaterial();
			zeroFrictionMaterial.dynamicFriction = 0f;
			zeroFrictionMaterial.staticFriction = 0f;
			zeroFrictionMaterial.frictionCombine = PhysicMaterialCombine.Minimum;
			zeroFrictionMaterial.bounciness = 0f;
			zeroFrictionMaterial.bounceCombine = PhysicMaterialCombine.Minimum;
			highFrictionMaterial = new PhysicMaterial();
			r.constraints = RigidbodyConstraints.FreezeRotation;
		}

		protected virtual RaycastHit GetSpherecastHit()
		{
			Vector3 up = base.transform.up;
			Ray ray = new Ray(r.position + up * airborneThreshold, -up);
			RaycastHit hitInfo = default(RaycastHit);
			hitInfo.point = base.transform.position - base.transform.transform.up * airborneThreshold;
			hitInfo.normal = base.transform.up;
			Physics.SphereCast(ray, spherecastRadius, out hitInfo, airborneThreshold * 2f, groundLayers);
			return hitInfo;
		}

		public float GetAngleFromForward(Vector3 worldDirection)
		{
			Vector3 vector = base.transform.InverseTransformDirection(worldDirection);
			return Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		}

		protected void RigidbodyRotateAround(Vector3 point, Vector3 axis, float angle)
		{
			Quaternion quaternion = Quaternion.AngleAxis(angle, axis);
			Vector3 vector = base.transform.position - point;
			r.MovePosition(point + quaternion * vector);
			r.MoveRotation(quaternion * base.transform.rotation);
		}

		protected void ScaleCapsule(float mlp)
		{
			if (capsule.height != originalHeight * mlp)
			{
				capsule.height = Mathf.MoveTowards(capsule.height, originalHeight * mlp, Time.deltaTime * 4f);
				capsule.center = Vector3.MoveTowards(capsule.center, originalCenter * mlp, Time.deltaTime * 2f);
			}
		}

		protected void HighFriction()
		{
			capsule.material = highFrictionMaterial;
		}

		protected void ZeroFriction()
		{
			capsule.material = zeroFrictionMaterial;
		}

		protected float GetSlopeDamper(Vector3 velocity, Vector3 groundNormal)
		{
			float num = 90f - Vector3.Angle(velocity, groundNormal);
			num -= slopeStartAngle;
			float num2 = slopeEndAngle - slopeStartAngle;
			return 1f - Mathf.Clamp(num / num2, 0f, 1f);
		}
	}
	public class CharacterThirdPerson : CharacterBase
	{
		[Serializable]
		public enum MoveMode
		{
			Directional,
			Strafe
		}

		public struct AnimState
		{
			public Vector3 moveDirection;

			public bool jump;

			public bool crouch;

			public bool onGround;

			public bool isStrafing;

			public float yVelocity;
		}

		[Header("References")]
		public CharacterAnimationBase characterAnimation;

		public UserControlThirdPerson userControl;

		public CameraController cam;

		[Header("Movement")]
		public MoveMode moveMode;

		public bool smoothPhysics = true;

		public float smoothAccelerationTime = 0.2f;

		public float linearAccelerationSpeed = 3f;

		public float platformFriction = 7f;

		public float groundStickyEffect = 4f;

		public float maxVerticalVelocityOnGround = 3f;

		public float velocityToGroundTangentWeight;

		[Header("Rotation")]
		public bool lookInCameraDirection;

		public float turnSpeed = 5f;

		public float stationaryTurnSpeedMlp = 1f;

		[Header("Jumping and Falling")]
		public float airSpeed = 6f;

		public float airControl = 2f;

		public float jumpPower = 12f;

		public float jumpRepeatDelayTime;

		[Header("Wall Running")]
		[SerializeField]
		private LayerMask wallRunLayers;

		public float wallRunMaxLength = 1f;

		public float wallRunMinMoveMag = 0.6f;

		public float wallRunMinVelocityY = -1f;

		public float wallRunRotationSpeed = 1.5f;

		public float wallRunMaxRotationAngle = 70f;

		public float wallRunWeightSpeed = 5f;

		[Header("Crouching")]
		public float crouchCapsuleScaleMlp = 0.6f;

		public AnimState animState = default(AnimState);

		protected Vector3 moveDirection;

		private Animator animator;

		private Vector3 normal;

		private Vector3 platformVelocity;

		private Vector3 platformAngularVelocity;

		private RaycastHit hit;

		private float jumpLeg;

		private float jumpEndTime;

		private float forwardMlp;

		private float groundDistance;

		private float lastAirTime;

		private float stickyForce;

		private Vector3 wallNormal = Vector3.up;

		private Vector3 moveDirectionVelocity;

		private float wallRunWeight;

		private float lastWallRunWeight;

		private Vector3 fixedDeltaPosition;

		private Quaternion fixedDeltaRotation;

		private bool fixedFrame;

		private float wallRunEndTime;

		private Vector3 gravity;

		private Vector3 verticalVelocity;

		private float velocityY;

		public bool onGround { get; private set; }

		protected override void Start()
		{
			base.Start();
			animator = GetComponent<Animator>();
			if (animator == null)
			{
				animator = characterAnimation.GetComponent<Animator>();
			}
			wallNormal = -gravity.normalized;
			onGround = true;
			animState.onGround = true;
			if (cam != null)
			{
				cam.enabled = false;
			}
		}

		private void OnAnimatorMove()
		{
			Move(animator.deltaPosition, animator.deltaRotation);
		}

		public override void Move(Vector3 deltaPosition, Quaternion deltaRotation)
		{
			fixedDeltaPosition += deltaPosition;
			fixedDeltaRotation *= deltaRotation;
		}

		private void FixedUpdate()
		{
			gravity = GetGravity();
			verticalVelocity = V3Tools.ExtractVertical(r.velocity, gravity, 1f);
			velocityY = verticalVelocity.magnitude;
			if (Vector3.Dot(verticalVelocity, gravity) > 0f)
			{
				velocityY = 0f - velocityY;
			}
			if (animator != null && animator.updateMode == AnimatorUpdateMode.AnimatePhysics)
			{
				smoothPhysics = false;
				characterAnimation.smoothFollow = false;
			}
			r.interpolation = (smoothPhysics ? RigidbodyInterpolation.Interpolate : RigidbodyInterpolation.None);
			characterAnimation.smoothFollow = smoothPhysics;
			MoveFixed(fixedDeltaPosition);
			fixedDeltaPosition = Vector3.zero;
			base.transform.rotation *= fixedDeltaRotation;
			fixedDeltaRotation = Quaternion.identity;
			Rotate();
			GroundCheck();
			if (userControl.state.move == Vector3.zero && groundDistance < airborneThreshold * 0.5f)
			{
				HighFriction();
			}
			else
			{
				ZeroFriction();
			}
			bool flag = onGround && userControl.state.move == Vector3.zero && r.velocity.magnitude < 0.5f && groundDistance < airborneThreshold * 0.5f;
			if (gravityTarget != null)
			{
				r.useGravity = false;
				if (!flag)
				{
					r.AddForce(gravity);
				}
			}
			if (flag)
			{
				r.useGravity = false;
				r.velocity = Vector3.zero;
			}
			else if (gravityTarget == null)
			{
				r.useGravity = true;
			}
			if (onGround)
			{
				animState.jump = Jump();
			}
			else
			{
				r.AddForce(gravity * gravityMultiplier);
			}
			ScaleCapsule((!userControl.state.crouch) ? 1f : crouchCapsuleScaleMlp);
			fixedFrame = true;
		}

		protected virtual void Update()
		{
			animState.onGround = onGround;
			animState.moveDirection = GetMoveDirection();
			animState.yVelocity = Mathf.Lerp(animState.yVelocity, velocityY, Time.deltaTime * 10f);
			animState.crouch = userControl.state.crouch;
			animState.isStrafing = moveMode == MoveMode.Strafe;
		}

		protected virtual void LateUpdate()
		{
			if (!(cam == null))
			{
				cam.UpdateInput();
				if (fixedFrame || r.interpolation != 0)
				{
					cam.UpdateTransform((r.interpolation != 0) ? Time.deltaTime : Time.fixedDeltaTime);
					fixedFrame = false;
				}
			}
		}

		private void MoveFixed(Vector3 deltaPosition)
		{
			WallRun();
			Vector3 vector = deltaPosition / Time.deltaTime;
			vector += V3Tools.ExtractHorizontal(platformVelocity, gravity, 1f);
			if (onGround)
			{
				if (velocityToGroundTangentWeight > 0f)
				{
					Quaternion b = Quaternion.FromToRotation(base.transform.up, normal);
					vector = Quaternion.Lerp(Quaternion.identity, b, velocityToGroundTangentWeight) * vector;
				}
			}
			else
			{
				Vector3 b2 = V3Tools.ExtractHorizontal(userControl.state.move * airSpeed, gravity, 1f);
				vector = Vector3.Lerp(r.velocity, b2, Time.deltaTime * airControl);
			}
			if (onGround && Time.time > jumpEndTime)
			{
				r.velocity -= base.transform.up * stickyForce * Time.deltaTime;
			}
			Vector3 vector2 = V3Tools.ExtractVertical(r.velocity, gravity, 1f);
			Vector3 vector3 = V3Tools.ExtractHorizontal(vector, gravity, 1f);
			if (onGround && Vector3.Dot(vector2, gravity) < 0f)
			{
				vector2 = Vector3.ClampMagnitude(vector2, maxVerticalVelocityOnGround);
			}
			r.velocity = vector3 + vector2;
			float b3 = (onGround ? GetSlopeDamper(-deltaPosition / Time.deltaTime, normal) : 1f);
			forwardMlp = Mathf.Lerp(forwardMlp, b3, Time.deltaTime * 5f);
		}

		private void WallRun()
		{
			bool flag = CanWallRun();
			if (wallRunWeight > 0f && !flag)
			{
				wallRunEndTime = Time.time;
			}
			if (Time.time < wallRunEndTime + 0.5f)
			{
				flag = false;
			}
			wallRunWeight = Mathf.MoveTowards(wallRunWeight, (!flag) ? 0f : 1f, Time.deltaTime * wallRunWeightSpeed);
			if (wallRunWeight <= 0f && lastWallRunWeight > 0f)
			{
				Vector3 forward = V3Tools.ExtractHorizontal(base.transform.forward, gravity, 1f);
				base.transform.rotation = Quaternion.LookRotation(forward, -gravity);
				wallNormal = -gravity.normalized;
			}
			lastWallRunWeight = wallRunWeight;
			if (!(wallRunWeight <= 0f))
			{
				if (onGround && velocityY < 0f)
				{
					r.velocity = V3Tools.ExtractHorizontal(r.velocity, gravity, 1f);
				}
				Vector3 vector = V3Tools.ExtractHorizontal(base.transform.forward, gravity, 1f);
				RaycastHit hitInfo = default(RaycastHit);
				hitInfo.normal = -gravity.normalized;
				Physics.Raycast((!onGround) ? capsule.bounds.center : base.transform.position, vector, out hitInfo, 3f, wallRunLayers);
				wallNormal = Vector3.Lerp(wallNormal, hitInfo.normal, Time.deltaTime * wallRunRotationSpeed);
				wallNormal = Vector3.RotateTowards(-gravity.normalized, wallNormal, wallRunMaxRotationAngle * ((float)Math.PI / 180f), 0f);
				Vector3 tangent = base.transform.forward;
				Vector3 vector2 = wallNormal;
				Vector3.OrthoNormalize(ref vector2, ref tangent);
				base.transform.rotation = Quaternion.Slerp(Quaternion.LookRotation(vector, -gravity), Quaternion.LookRotation(tangent, wallNormal), wallRunWeight);
			}
		}

		private bool CanWallRun()
		{
			if (Time.time < jumpEndTime - 0.1f)
			{
				return false;
			}
			if (Time.time > jumpEndTime - 0.1f + wallRunMaxLength)
			{
				return false;
			}
			if (velocityY < wallRunMinVelocityY)
			{
				return false;
			}
			if (userControl.state.move.magnitude < wallRunMinMoveMag)
			{
				return false;
			}
			return true;
		}

		private Vector3 GetMoveDirection()
		{
			switch (moveMode)
			{
			case MoveMode.Directional:
				moveDirection = Vector3.SmoothDamp(moveDirection, new Vector3(0f, 0f, userControl.state.move.magnitude), ref moveDirectionVelocity, smoothAccelerationTime);
				moveDirection = Vector3.MoveTowards(moveDirection, new Vector3(0f, 0f, userControl.state.move.magnitude), Time.deltaTime * linearAccelerationSpeed);
				return moveDirection * forwardMlp;
			case MoveMode.Strafe:
				moveDirection = Vector3.SmoothDamp(moveDirection, userControl.state.move, ref moveDirectionVelocity, smoothAccelerationTime);
				moveDirection = Vector3.MoveTowards(moveDirection, userControl.state.move, Time.deltaTime * linearAccelerationSpeed);
				return base.transform.InverseTransformDirection(moveDirection);
			default:
				return Vector3.zero;
			}
		}

		protected virtual void Rotate()
		{
			if (gravityTarget != null)
			{
				base.transform.rotation = Quaternion.FromToRotation(base.transform.up, base.transform.position - gravityTarget.position) * base.transform.rotation;
			}
			if (platformAngularVelocity != Vector3.zero)
			{
				base.transform.rotation = Quaternion.Euler(platformAngularVelocity) * base.transform.rotation;
			}
			float num = GetAngleFromForward(GetForwardDirection());
			if (userControl.state.move == Vector3.zero)
			{
				num *= (1.01f - Mathf.Abs(num) / 180f) * stationaryTurnSpeedMlp;
			}
			RigidbodyRotateAround(characterAnimation.GetPivotPoint(), base.transform.up, num * Time.deltaTime * turnSpeed);
		}

		private Vector3 GetForwardDirection()
		{
			bool flag = userControl.state.move != Vector3.zero;
			switch (moveMode)
			{
			case MoveMode.Directional:
				if (flag)
				{
					return userControl.state.move;
				}
				return (!lookInCameraDirection) ? base.transform.forward : (userControl.state.lookPos - r.position);
			case MoveMode.Strafe:
				if (flag)
				{
					return userControl.state.lookPos - r.position;
				}
				return (!lookInCameraDirection) ? base.transform.forward : (userControl.state.lookPos - r.position);
			default:
				return Vector3.zero;
			}
		}

		protected virtual bool Jump()
		{
			if (!userControl.state.jump)
			{
				return false;
			}
			if (userControl.state.crouch)
			{
				return false;
			}
			if (!characterAnimation.animationGrounded)
			{
				return false;
			}
			if (Time.time < lastAirTime + jumpRepeatDelayTime)
			{
				return false;
			}
			onGround = false;
			jumpEndTime = Time.time + 0.1f;
			Vector3 velocity = userControl.state.move * airSpeed;
			r.velocity = velocity;
			r.velocity += base.transform.up * jumpPower;
			return true;
		}

		private void GroundCheck()
		{
			Vector3 b = Vector3.zero;
			platformAngularVelocity = Vector3.zero;
			float num = 0f;
			hit = GetSpherecastHit();
			normal = base.transform.up;
			groundDistance = Vector3.Project(r.position - hit.point, base.transform.up).magnitude;
			if (Time.time > jumpEndTime && velocityY < jumpPower * 0.5f)
			{
				bool flag = onGround;
				onGround = false;
				float num2 = (flag ? airborneThreshold : (airborneThreshold * 0.5f));
				float magnitude = V3Tools.ExtractHorizontal(r.velocity, gravity, 1f).magnitude;
				if (groundDistance < num2)
				{
					num = groundStickyEffect * magnitude * num2;
					if (hit.rigidbody != null)
					{
						b = hit.rigidbody.GetPointVelocity(hit.point);
						platformAngularVelocity = Vector3.Project(hit.rigidbody.angularVelocity, base.transform.up);
					}
					onGround = true;
				}
			}
			platformVelocity = Vector3.Lerp(platformVelocity, b, Time.deltaTime * platformFriction);
			stickyForce = num;
			if (!onGround)
			{
				lastAirTime = Time.time;
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class SimpleLocomotion : MonoBehaviour
	{
		[Serializable]
		public enum RotationMode
		{
			Smooth,
			Linear
		}

		[Tooltip("The component that updates the camera.")]
		[SerializeField]
		private CameraController cameraController;

		[Tooltip("Acceleration of movement.")]
		[SerializeField]
		private float accelerationTime = 0.2f;

		[Tooltip("Turning speed.")]
		[SerializeField]
		private float turnTime = 0.2f;

		[Tooltip("If true, will run on left shift, if not will walk on left shift.")]
		[SerializeField]
		private bool walkByDefault = true;

		[Tooltip("Smooth or linear rotation.")]
		[SerializeField]
		private RotationMode rotationMode;

		[Tooltip("Procedural motion speed (if not using root motion).")]
		[SerializeField]
		private float moveSpeed = 3f;

		private Animator animator;

		private float speed;

		private float angleVel;

		private float speedVel;

		private Vector3 linearTargetDirection;

		private CharacterController characterController;

		public bool isGrounded { get; private set; }

		private void Start()
		{
			animator = GetComponent<Animator>();
			characterController = GetComponent<CharacterController>();
			cameraController.enabled = false;
		}

		private void Update()
		{
			isGrounded = base.transform.position.y < 0.1f;
			Rotate();
			Move();
		}

		private void LateUpdate()
		{
			cameraController.UpdateInput();
			cameraController.UpdateTransform();
		}

		private void Rotate()
		{
			if (!isGrounded)
			{
				return;
			}
			Vector3 inputVector = GetInputVector();
			if (inputVector == Vector3.zero)
			{
				return;
			}
			Vector3 forward = base.transform.forward;
			switch (rotationMode)
			{
			case RotationMode.Smooth:
			{
				Vector3 vector = cameraController.transform.rotation * inputVector;
				float current = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
				float target = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				float angle = Mathf.SmoothDampAngle(current, target, ref angleVel, turnTime);
				base.transform.rotation = Quaternion.AngleAxis(angle, Vector3.up);
				break;
			}
			case RotationMode.Linear:
			{
				Vector3 inputVectorRaw = GetInputVectorRaw();
				if (inputVectorRaw != Vector3.zero)
				{
					linearTargetDirection = cameraController.transform.rotation * inputVectorRaw;
				}
				forward = Vector3.RotateTowards(forward, linearTargetDirection, Time.deltaTime * (1f / turnTime), 1f);
				forward.y = 0f;
				base.transform.rotation = Quaternion.LookRotation(forward);
				break;
			}
			}
		}

		private void Move()
		{
			float target = (walkByDefault ? ((!Input.GetKey(KeyCode.LeftShift)) ? 0.5f : 1f) : ((!Input.GetKey(KeyCode.LeftShift)) ? 1f : 0.5f));
			speed = Mathf.SmoothDamp(speed, target, ref speedVel, accelerationTime);
			float num = GetInputVector().magnitude * speed;
			animator.SetFloat("Speed", num);
			if (!animator.hasRootMotion && isGrounded)
			{
				Vector3 vector = base.transform.forward * num * moveSpeed;
				if (characterController != null)
				{
					characterController.SimpleMove(vector);
				}
				else
				{
					base.transform.position += vector * Time.deltaTime;
				}
			}
		}

		private Vector3 GetInputVector()
		{
			Vector3 result = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
			result.z += Mathf.Abs(result.x) * 0.05f;
			result.x -= Mathf.Abs(result.z) * 0.05f;
			return result;
		}

		private Vector3 GetInputVectorRaw()
		{
			return new Vector3(Input.GetAxisRaw("Horizontal"), 0f, Input.GetAxisRaw("Vertical"));
		}
	}
	public class UserControlAI : UserControlThirdPerson
	{
		public Transform moveTarget;

		public float stoppingDistance = 0.5f;

		public float stoppingThreshold = 1.5f;

		protected override void Update()
		{
			float num = ((!walkByDefault) ? 1f : 0.5f);
			Vector3 tangent = moveTarget.position - base.transform.position;
			float magnitude = tangent.magnitude;
			Vector3 normal = base.transform.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			float num2 = ((!(state.move != Vector3.zero)) ? (stoppingDistance * stoppingThreshold) : stoppingDistance);
			state.move = ((!(magnitude > num2)) ? Vector3.zero : (tangent * num));
		}
	}
	public class UserControlThirdPerson : MonoBehaviour
	{
		public struct State
		{
			public Vector3 move;

			public Vector3 lookPos;

			public bool crouch;

			public bool jump;

			public int actionIndex;
		}

		public bool walkByDefault;

		public bool canCrouch = true;

		public bool canJump = true;

		public State state = default(State);

		protected Transform cam;

		private void Start()
		{
			cam = Camera.main.transform;
		}

		protected virtual void Update()
		{
			state.crouch = canCrouch && Input.GetKey(KeyCode.C);
			state.jump = canJump && Input.GetButton("Jump");
			float axisRaw = Input.GetAxisRaw("Horizontal");
			float axisRaw2 = Input.GetAxisRaw("Vertical");
			Vector3 tangent = cam.rotation * new Vector3(axisRaw, 0f, axisRaw2).normalized;
			if (tangent != Vector3.zero)
			{
				Vector3 normal = base.transform.up;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				state.move = tangent;
			}
			else
			{
				state.move = Vector3.zero;
			}
			bool key = Input.GetKey(KeyCode.LeftShift);
			float num = (walkByDefault ? ((!key) ? 0.5f : 1f) : ((!key) ? 1f : 0.5f));
			state.move *= num;
			state.lookPos = base.transform.position + cam.forward * 100f;
		}
	}
	public class ApplicationQuit : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Q) || Input.GetKeyDown(KeyCode.Escape))
			{
				Application.Quit();
			}
		}
	}
	public class SlowMo : MonoBehaviour
	{
		[SerializeField]
		private KeyCode[] keyCodes;

		[SerializeField]
		private bool mouse0;

		[SerializeField]
		private bool mouse1;

		[SerializeField]
		private float slowMoTimeScale = 0.3f;

		private void Update()
		{
			Time.timeScale = ((!IsSlowMotion()) ? 1f : slowMoTimeScale);
		}

		private bool IsSlowMotion()
		{
			if (mouse0 && Input.GetMouseButton(0))
			{
				return true;
			}
			if (mouse1 && Input.GetMouseButton(1))
			{
				return true;
			}
			for (int i = 0; i < keyCodes.Length; i++)
			{
				if (Input.GetKey(keyCodes[i]))
				{
					return true;
				}
			}
			return false;
		}
	}
}
namespace RootMotion
{
	[Serializable]
	public enum Axis
	{
		X,
		Y,
		Z
	}
	public class AxisTools
	{
		public static Vector3 ToVector3(Axis axis)
		{
			return axis switch
			{
				Axis.X => Vector3.right, 
				Axis.Y => Vector3.up, 
				_ => Vector3.forward, 
			};
		}

		public static Axis ToAxis(Vector3 v)
		{
			float num = Mathf.Abs(v.x);
			float num2 = Mathf.Abs(v.y);
			float num3 = Mathf.Abs(v.z);
			Axis result = Axis.X;
			if (num2 > num && num2 > num3)
			{
				result = Axis.Y;
			}
			if (num3 > num && num3 > num2)
			{
				result = Axis.Z;
			}
			return result;
		}

		public static Axis GetAxisToPoint(Transform t, Vector3 worldPosition)
		{
			Vector3 axisVectorToPoint = GetAxisVectorToPoint(t, worldPosition);
			if (axisVectorToPoint == Vector3.right)
			{
				return Axis.X;
			}
			if (axisVectorToPoint == Vector3.up)
			{
				return Axis.Y;
			}
			return Axis.Z;
		}

		public static Axis GetAxisToDirection(Transform t, Vector3 direction)
		{
			Vector3 axisVectorToDirection = GetAxisVectorToDirection(t, direction);
			if (axisVectorToDirection == Vector3.right)
			{
				return Axis.X;
			}
			if (axisVectorToDirection == Vector3.up)
			{
				return Axis.Y;
			}
			return Axis.Z;
		}

		public static Vector3 GetAxisVectorToPoint(Transform t, Vector3 worldPosition)
		{
			return GetAxisVectorToDirection(t, worldPosition - t.position);
		}

		public static Vector3 GetAxisVectorToDirection(Transform t, Vector3 direction)
		{
			direction = direction.normalized;
			Vector3 result = Vector3.right;
			float num = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.right), direction));
			float num2 = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.up), direction));
			if (num2 > num)
			{
				result = Vector3.up;
			}
			float num3 = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.forward), direction));
			if (num3 > num && num3 > num2)
			{
				result = Vector3.forward;
			}
			return result;
		}
	}
	[Serializable]
	public class BipedLimbOrientations
	{
		[Serializable]
		public class LimbOrientation
		{
			public Vector3 upperBoneForwardAxis;

			public Vector3 lowerBoneForwardAxis;

			public Vector3 lastBoneLeftAxis;

			public LimbOrientation(Vector3 upperBoneForwardAxis, Vector3 lowerBoneForwardAxis, Vector3 lastBoneLeftAxis)
			{
				this.upperBoneForwardAxis = upperBoneForwardAxis;
				this.lowerBoneForwardAxis = lowerBoneForwardAxis;
				this.lastBoneLeftAxis = lastBoneLeftAxis;
			}
		}

		public LimbOrientation leftArm;

		public LimbOrientation rightArm;

		public LimbOrientation leftLeg;

		public LimbOrientation rightLeg;

		public static BipedLimbOrientations UMA => new BipedLimbOrientations(new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.forward), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.back), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.down), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.down));

		public static BipedLimbOrientations MaxBiped => new BipedLimbOrientations(new LimbOrientation(Vector3.down, Vector3.down, Vector3.down), new LimbOrientation(Vector3.down, Vector3.down, Vector3.up), new LimbOrientation(Vector3.up, Vector3.up, Vector3.back), new LimbOrientation(Vector3.up, Vector3.up, Vector3.back));

		public BipedLimbOrientations(LimbOrientation leftArm, LimbOrientation rightArm, LimbOrientation leftLeg, LimbOrientation rightLeg)
		{
			this.leftArm = leftArm;
			this.rightArm = rightArm;
			this.leftLeg = leftLeg;
			this.rightLeg = rightLeg;
		}
	}
	public static class BipedNaming
	{
		[Serializable]
		public enum BoneType
		{
			Unassigned,
			Spine,
			Head,
			Arm,
			Leg,
			Tail,
			Eye
		}

		[Serializable]
		public enum BoneSide
		{
			Center,
			Left,
			Right
		}

		public static string[] typeLeft = new string[9] { " L ", "_L_", "-L-", " l ", "_l_", "-l-", "Left", "left", "CATRigL" };

		public static string[] typeRight = new string[9] { " R ", "_R_", "-R-", " r ", "_r_", "-r-", "Right", "right", "CATRigR" };

		public static string[] typeSpine = new string[16]
		{
			"Spine", "spine", "Pelvis", "pelvis", "Root", "root", "Torso", "torso", "Body", "body",
			"Hips", "hips", "Neck", "neck", "Chest", "chest"
		};

		public static string[] typeHead = new string[2] { "Head", "head" };

		public static string[] typeArm = new string[10] { "Arm", "arm", "Hand", "hand", "Wrist", "Wrist", "Elbow", "elbow", "Palm", "palm" };

		public static string[] typeLeg = new string[16]
		{
			"Leg", "leg", "Thigh", "thigh", "Calf", "calf", "Femur", "femur", "Knee", "knee",
			"Foot", "foot", "Ankle", "ankle", "Hip", "hip"
		};

		public static string[] typeTail = new string[2] { "Tail", "tail" };

		public static string[] typeEye = new string[2] { "Eye", "eye" };

		public static string[] typeExclude = new string[6] { "Nub", "Dummy", "dummy", "Tip", "IK", "Mesh" };

		public static string[] typeExcludeSpine = new string[2] { "Head", "head" };

		public static string[] typeExcludeHead = new string[2] { "Top", "End" };

		public static string[] typeExcludeArm = new string[19]
		{
			"Collar", "collar", "Clavicle", "clavicle", "Finger", "finger", "Index", "index", "Mid", "mid",
			"Pinky", "pinky", "Ring", "Thumb", "thumb", "Adjust", "adjust", "Twist", "twist"
		};

		public static string[] typeExcludeLeg = new string[7] { "Toe", "toe", "Platform", "Adjust", "adjust", "Twist", "twist" };

		public static string[] typeExcludeTail = new string[0];

		public static string[] typeExcludeEye = new string[6] { "Lid", "lid", "Brow", "brow", "Lash", "lash" };

		public static string[] pelvis = new string[4] { "Pelvis", "pelvis", "Hip", "hip" };

		public static string[] hand = new string[6] { "Hand", "hand", "Wrist", "wrist", "Palm", "palm" };

		public static string[] foot = new string[4] { "Foot", "foot", "Ankle", "ankle" };

		public static Transform[] GetBonesOfType(BoneType boneType, Transform[] bones)
		{
			Transform[] array = new Transform[0];
			foreach (Transform transform in bones)
			{
				if (transform != null && GetBoneType(transform.name) == boneType)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform;
				}
			}
			return array;
		}

		public static Transform[] GetBonesOfSide(BoneSide boneSide, Transform[] bones)
		{
			Transform[] array = new Transform[0];
			foreach (Transform transform in bones)
			{
				if (transform != null && GetBoneSide(transform.name) == boneSide)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform;
				}
			}
			return array;
		}

		public static Transform[] GetBonesOfTypeAndSide(BoneType boneType, BoneSide boneSide, Transform[] bones)
		{
			Transform[] bonesOfType = GetBonesOfType(boneType, bones);
			return GetBonesOfSide(boneSide, bonesOfType);
		}

		public static Transform GetFirstBoneOfTypeAndSide(BoneType boneType, BoneSide boneSide, Transform[] bones)
		{
			Transform[] bonesOfTypeAndSide = GetBonesOfTypeAndSide(boneType, boneSide, bones);
			if (bonesOfTypeAndSide.Length == 0)
			{
				return null;
			}
			return bonesOfTypeAndSide[0];
		}

		public static Transform GetNamingMatch(Transform[] transforms, params string[][] namings)
		{
			foreach (Transform transform in transforms)
			{
				bool flag = true;
				foreach (string[] namingConvention in namings)
				{
					if (!matchesNaming(transform.name, namingConvention))
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					return transform;
				}
			}
			return null;
		}

		public static BoneType GetBoneType(string boneName)
		{
			if (isSpine(boneName))
			{
				return BoneType.Spine;
			}
			if (isHead(boneName))
			{
				return BoneType.Head;
			}
			if (isArm(boneName))
			{
				return BoneType.Arm;
			}
			if (isLeg(boneName))
			{
				return BoneType.Leg;
			}
			if (isTail(boneName))
			{
				return BoneType.Tail;
			}
			if (isEye(boneName))
			{
				return BoneType.Eye;
			}
			return BoneType.Unassigned;
		}

		public static BoneSide GetBoneSide(string boneName)
		{
			if (isLeft(boneName))
			{
				return BoneSide.Left;
			}
			if (isRight(boneName))
			{
				return BoneSide.Right;
			}
			return BoneSide.Center;
		}

		public static Transform GetBone(Transform[] transforms, BoneType boneType, BoneSide boneSide = BoneSide.Center, params string[][] namings)
		{
			Transform[] bonesOfTypeAndSide = GetBonesOfTypeAndSide(boneType, boneSide, transforms);
			return GetNamingMatch(bonesOfTypeAndSide, namings);
		}

		private static bool isLeft(string boneName)
		{
			return matchesNaming(boneName, typeLeft) || lastLetter(boneName) == "L" || firstLetter(boneName) == "L";
		}

		private static bool isRight(string boneName)
		{
			return matchesNaming(boneName, typeRight) || lastLetter(boneName) == "R" || firstLetter(boneName) == "R";
		}

		private static bool isSpine(string boneName)
		{
			return matchesNaming(boneName, typeSpine) && !excludesNaming(boneName, typeExcludeSpine);
		}

		private static bool isHead(string boneName)
		{
			return matchesNaming(boneName, typeHead) && !excludesNaming(boneName, typeExcludeHead);
		}

		private static bool isArm(string boneName)
		{
			return matchesNaming(boneName, typeArm) && !excludesNaming(boneName, typeExcludeArm);
		}

		private static bool isLeg(string boneName)
		{
			return matchesNaming(boneName, typeLeg) && !excludesNaming(boneName, typeExcludeLeg);
		}

		private static bool isTail(string boneName)
		{
			return matchesNaming(boneName, typeTail) && !excludesNaming(boneName, typeExcludeTail);
		}

		private static bool isEye(string boneName)
		{
			return matchesNaming(boneName, typeEye) && !excludesNaming(boneName, typeExcludeEye);
		}

		private static bool isTypeExclude(string boneName)
		{
			return matchesNaming(boneName, typeExclude);
		}

		private static bool matchesNaming(string boneName, string[] namingConvention)
		{
			if (excludesNaming(boneName, typeExclude))
			{
				return false;
			}
			foreach (string value in namingConvention)
			{
				if (boneName.Contains(value))
				{
					return true;
				}
			}
			return false;
		}

		private static bool excludesNaming(string boneName, string[] namingConvention)
		{
			foreach (string value in namingConvention)
			{
				if (boneName.Contains(value))
				{
					return true;
				}
			}
			return false;
		}

		private static bool matchesLastLetter(string boneName, string[] namingConvention)
		{
			foreach (string letter in namingConvention)
			{
				if (LastLetterIs(boneName, letter))
				{
					return true;
				}
			}
			return false;
		}

		private static bool LastLetterIs(string boneName, string letter)
		{
			string text = boneName.Substring(boneName.Length - 1, 1);
			return text == letter;
		}

		private static string firstLetter(string boneName)
		{
			if (boneName.Length > 0)
			{
				return boneName.Substring(0, 1);
			}
			return string.Empty;
		}

		private static string lastLetter(string boneName)
		{
			if (boneName.Length > 0)
			{
				return boneName.Substring(boneName.Length - 1, 1);
			}
			return string.Empty;
		}
	}
	[Serializable]
	public class BipedReferences
	{
		public struct AutoDetectParams
		{
			public bool legsParentInSpine;

			public bool includeEyes;

			public static AutoDetectParams Default => new AutoDetectParams(legsParentInSpine: true, includeEyes: true);

			public AutoDetectParams(bool legsParentInSpine, bool includeEyes)
			{
				this.legsParentInSpine = legsParentInSpine;
				this.includeEyes = includeEyes;
			}
		}

		public Transform root;

		public Transform pelvis;

		public Transform leftThigh;

		public Transform leftCalf;

		public Transform leftFoot;

		public Transform rightThigh;

		public Transform rightCalf;

		public Transform rightFoot;

		public Transform leftUpperArm;

		public Transform leftForearm;

		public Transform leftHand;

		public Transform rightUpperArm;

		public Transform rightForearm;

		public Transform rightHand;

		public Transform head;

		public Transform[] spine = new Transform[0];

		public Transform[] eyes = new Transform[0];

		public virtual bool isFilled
		{
			get
			{
				if (root == null)
				{
					return false;
				}
				if (pelvis == null)
				{
					return false;
				}
				if (leftThigh == null || leftCalf == null || leftFoot == null)
				{
					return false;
				}
				if (rightThigh == null || rightCalf == null || rightFoot == null)
				{
					return false;
				}
				if (leftUpperArm == null || leftForearm == null || leftHand == null)
				{
					return false;
				}
				if (rightUpperArm == null || rightForearm == null || rightHand == null)
				{
					return false;
				}
				Transform[] array = spine;
				foreach (Transform transform in array)
				{
					if (transform == null)
					{
						return false;
					}
				}
				Transform[] array2 = eyes;
				foreach (Transform transform2 in array2)
				{
					if (transform2 == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		public bool isEmpty => IsEmpty(includeRoot: true);

		public virtual bool IsEmpty(bool includeRoot)
		{
			if (includeRoot && root != null)
			{
				return false;
			}
			if (pelvis != null || head != null)
			{
				return false;
			}
			if (leftThigh != null || leftCalf != null || leftFoot != null)
			{
				return false;
			}
			if (rightThigh != null || rightCalf != null || rightFoot != null)
			{
				return false;
			}
			if (leftUpperArm != null || leftForearm != null || leftHand != null)
			{
				return false;
			}
			if (rightUpperArm != null || rightForearm != null || rightHand != null)
			{
				return false;
			}
			Transform[] array = spine;
			foreach (Transform transform in array)
			{
				if (transform != null)
				{
					return false;
				}
			}
			Transform[] array2 = eyes;
			foreach (Transform transform2 in array2)
			{
				if (transform2 != null)
				{
					return false;
				}
			}
			return true;
		}

		public virtual bool Contains(Transform t, bool ignoreRoot = false)
		{
			if (!ignoreRoot && root == t)
			{
				return true;
			}
			if (pelvis == t)
			{
				return true;
			}
			if (leftThigh == t)
			{
				return true;
			}
			if (leftCalf == t)
			{
				return true;
			}
			if (leftFoot == t)
			{
				return true;
			}
			if (rightThigh == t)
			{
				return true;
			}
			if (rightCalf == t)
			{
				return true;
			}
			if (rightFoot == t)
			{
				return true;
			}
			if (leftUpperArm == t)
			{
				return true;
			}
			if (leftForearm == t)
			{
				return true;
			}
			if (leftHand == t)
			{
				return true;
			}
			if (rightUpperArm == t)
			{
				return true;
			}
			if (rightForearm == t)
			{
				return true;
			}
			if (rightHand == t)
			{
				return true;
			}
			if (head == t)
			{
				return true;
			}
			Transform[] array = spine;
			foreach (Transform transform in array)
			{
				if (transform == t)
				{
					return true;
				}
			}
			Transform[] array2 = eyes;
			foreach (Transform transform2 in array2)
			{
				if (transform2 == t)
				{
					return true;
				}
			}
			return false;
		}

		public static bool AutoDetectReferences(ref BipedReferences references, Transform root, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			references.root = root;
			Animator component = root.GetComponent<Animator>();
			if (component != null && component.isHuman)
			{
				AssignHumanoidReferences(ref references, component, autoDetectParams);
				return true;
			}
			DetectReferencesByNaming(ref references, root, autoDetectParams);
			Warning.logged = false;
			if (!references.isFilled)
			{
				Warning.Log("BipedReferences contains one or more missing Transforms.", root, logInEditMode: true);
				return false;
			}
			string errorMessage = string.Empty;
			if (SetupError(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root, logInEditMode: true);
				return false;
			}
			if (SetupWarning(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root, logInEditMode: true);
			}
			return true;
		}

		public static void DetectReferencesByNaming(ref BipedReferences references, Transform root, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			Transform[] componentsInChildren = root.GetComponentsInChildren<Transform>();
			DetectLimb(BipedNaming.BoneType.Arm, BipedNaming.BoneSide.Left, ref references.leftUpperArm, ref references.leftForearm, ref references.leftHand, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Arm, BipedNaming.BoneSide.Right, ref references.rightUpperArm, ref references.rightForearm, ref references.rightHand, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Leg, BipedNaming.BoneSide.Left, ref references.leftThigh, ref references.leftCalf, ref references.leftFoot, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Leg, BipedNaming.BoneSide.Right, ref references.rightThigh, ref references.rightCalf, ref references.rightFoot, componentsInChildren);
			references.head = BipedNaming.GetBone(componentsInChildren, BipedNaming.BoneType.Head, BipedNaming.BoneSide.Center);
			references.pelvis = BipedNaming.GetNamingMatch(componentsInChildren, BipedNaming.pelvis);
			if ((references.pelvis == null || !Hierarchy.IsAncestor(references.leftThigh, references.pelvis)) && references.leftThigh != null)
			{
				references.pelvis = references.leftThigh.parent;
			}
			if (references.leftUpperArm != null && references.rightUpperArm != null && references.pelvis != null && references.leftThigh != null)
			{
				Transform firstCommonAncestor = Hierarchy.GetFirstCommonAncestor(references.leftUpperArm, references.rightUpperArm);
				if (firstCommonAncestor != null)
				{
					Transform[] array = new Transform[1] { firstCommonAncestor };
					Hierarchy.AddAncestors(array[0], references.pelvis, ref array);
					references.spine = new Transform[0];
					for (int num = array.Length - 1; num > -1; num--)
					{
						if (AddBoneToSpine(array[num], ref references, autoDetectParams))
						{
							Array.Resize(ref references.spine, references.spine.Length + 1);
							references.spine[references.spine.Length - 1] = array[num];
						}
					}
					if (references.head == null)
					{
						for (int i = 0; i < firstCommonAncestor.childCount; i++)
						{
							Transform child = firstCommonAncestor.GetChild(i);
							if (!Hierarchy.ContainsChild(child, references.leftUpperArm) && !Hierarchy.ContainsChild(child, references.rightUpperArm))
							{
								references.head = child;
								break;
							}
						}
					}
				}
			}
			Transform[] bonesOfType = BipedNaming.GetBonesOfType(BipedNaming.BoneType.Eye, componentsInChildren);
			references.eyes = new Transform[0];
			if (!autoDetectParams.includeEyes)
			{
				return;
			}
			for (int j = 0; j < bonesOfType.Length; j++)
			{
				if (AddBoneToEyes(bonesOfType[j], ref references, autoDetectParams))
				{
					Array.Resize(ref references.eyes, references.eyes.Length + 1);
					references.eyes[references.eyes.Length - 1] = bonesOfType[j];
				}
			}
		}

		public static void AssignHumanoidReferences(ref BipedReferences references, Animator animator, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			if (!(animator == null) && animator.isHuman)
			{
				references.spine = new Transform[0];
				references.eyes = new Transform[0];
				references.head = animator.GetBoneTransform(HumanBodyBones.Head);
				references.leftThigh = animator.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				references.leftCalf = animator.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
				references.leftFoot = animator.GetBoneTransform(HumanBodyBones.LeftFoot);
				references.rightThigh = animator.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				references.rightCalf = animator.GetBoneTransform(HumanBodyBones.RightLowerLeg);
				references.rightFoot = animator.GetBoneTransform(HumanBodyBones.RightFoot);
				references.leftUpperArm = animator.GetBoneTransform(HumanBodyBones.LeftUpperArm);
				references.leftForearm = animator.GetBoneTransform(HumanBodyBones.LeftLowerArm);
				references.leftHand = animator.GetBoneTransform(HumanBodyBones.LeftHand);
				references.rightUpperArm = animator.GetBoneTransform(HumanBodyBones.RightUpperArm);
				references.rightForearm = animator.GetBoneTransform(HumanBodyBones.RightLowerArm);
				references.rightHand = animator.GetBoneTransform(HumanBodyBones.RightHand);
				references.pelvis = animator.GetBoneTransform(HumanBodyBones.Hips);
				AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Spine));
				AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Chest));
				if (references.leftUpperArm != null && !IsNeckBone(animator.GetBoneTransform(HumanBodyBones.Neck), references.leftUpperArm))
				{
					AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Neck));
				}
				if (autoDetectParams.includeEyes)
				{
					AddBoneToHierarchy(ref references.eyes, animator.GetBoneTransform(HumanBodyBones.LeftEye));
					AddBoneToHierarchy(ref references.eyes, animator.GetBoneTransform(HumanBodyBones.RightEye));
				}
			}
		}

		public static bool SetupError(BipedReferences references, ref string errorMessage)
		{
			if (!references.isFilled)
			{
				errorMessage = "BipedReferences contains one or more missing Transforms.";
				return true;
			}
			if (LimbError(references.leftThigh, references.leftCalf, references.leftFoot, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.rightThigh, references.rightCalf, references.rightFoot, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.leftUpperArm, references.leftForearm, references.leftHand, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.rightUpperArm, references.rightForearm, references.rightHand, ref errorMessage))
			{
				return true;
			}
			if (SpineError(references, ref errorMessage))
			{
				return true;
			}
			if (EyesError(references, ref errorMessage))
			{
				return true;
			}
			return false;
		}

		public static bool SetupWarning(BipedReferences references, ref string warningMessage)
		{
			if (LimbWarning(references.leftThigh, references.leftCalf, references.leftFoot, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.rightThigh, references.rightCalf, references.rightFoot, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.leftUpperArm, references.leftForearm, references.leftHand, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.rightUpperArm, references.rightForearm, references.rightHand, ref warningMessage))
			{
				return true;
			}
			if (SpineWarning(references, ref warningMessage))
			{
				return true;
			}
			if (EyesWarning(references, ref warningMessage))
			{
				return true;
			}
			if (RootHeightWarning(references, ref warningMessage))
			{
				return true;
			}
			if (FacingAxisWarning(references, ref warningMessage))
			{
				return true;
			}
			return false;
		}

		private static bool IsNeckBone(Transform bone, Transform leftUpperArm)
		{
			if (leftUpperArm.parent != null && leftUpperArm.parent == bone)
			{
				return false;
			}
			if (Hierarchy.IsAncestor(leftUpperArm, bone))
			{
				return false;
			}
			return true;
		}

		private static bool AddBoneToEyes(Transform bone, ref BipedReferences references, AutoDetectParams autoDetectParams)
		{
			if (references.head != null && !Hierarchy.IsAncestor(bone, references.head))
			{
				return false;
			}
			if (bone.GetComponent<SkinnedMeshRenderer>() != null)
			{
				return false;
			}
			return true;
		}

		private static bool AddBoneToSpine(Transform bone, ref BipedReferences references, AutoDetectParams autoDetectParams)
		{
			if (bone == references.root)
			{
				return false;
			}
			if (bone == references.leftThigh.parent && !autoDetectParams.legsParentInSpine)
			{
				return false;
			}
			if (references.pelvis != null)
			{
				if (bone == references.pelvis)
				{
					return false;
				}
				if (Hierarchy.IsAncestor(references.pelvis, bone))
				{
					return false;
				}
			}
			return true;
		}

		private static void DetectLimb(BipedNaming.BoneType boneType, BipedNaming.BoneSide boneSide, ref Transform firstBone, ref Transform secondBone, ref Transform lastBone, Transform[] transforms)
		{
			Transform[] bonesOfTypeAndSide = BipedNaming.GetBonesOfTypeAndSide(boneType, boneSide, transforms);
			if (bonesOfTypeAndSide.Length >= 3)
			{
				if (bonesOfTypeAndSide.Length == 3)
				{
					firstBone = bonesOfTypeAndSide[0];
					secondBone = bonesOfTypeAndSide[1];
					lastBone = bonesOfTypeAndSide[2];
				}
				if (bonesOfTypeAndSide.Length > 3)
				{
					firstBone = bonesOfTypeAndSide[0];
					secondBone = bonesOfTypeAndSide[2];
					lastBone = bonesOfTypeAndSide[bonesOfTypeAndSide.Length - 1];
				}
			}
		}

		private static void AddBoneToHierarchy(ref Transform[] bones, Transform transform)
		{
			if (!(transform == null))
			{
				Array.Resize(ref bones, bones.Length + 1);
				bones[bones.Length - 1] = transform;
			}
		}

		private static bool LimbError(Transform bone1, Transform bone2, Transform bone3, ref string errorMessage)
		{
			if (bone1 == null)
			{
				errorMessage = "Bone 1 of a BipedReferences limb is null.";
				return true;
			}
			if (bone2 == null)
			{
				errorMessage = "Bone 2 of a BipedReferences limb is null.";
				return true;
			}
			if (bone3 == null)
			{
				errorMessage = "Bone 3 of a BipedReferences limb is null.";
				return true;
			}
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(new Transform[3] { bone1, bone2, bone3 });
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in the same BipedReferences limb.";
				return true;
			}
			if (bone2.position == bone1.position)
			{
				errorMessage = "Second bone's position equals first bone's position in the biped's limb.";
				return true;
			}
			if (bone3.position == bone2.position)
			{
				errorMessage = "Third bone's position equals second bone's position in the biped's limb.";
				return true;
			}
			if (!Hierarchy.HierarchyIsValid(new Transform[3] { bone1, bone2, bone3 }))
			{
				errorMessage = "BipedReferences limb hierarchy is invalid. Bone transforms in a limb do not belong to the same ancestry. Please make sure the bones are parented to each other. Bones: " + bone1.name + ", " + bone2.name + ", " + bone3.name;
				return true;
			}
			return false;
		}

		private static bool LimbWarning(Transform bone1, Transform bone2, Transform bone3, ref string warningMessage)
		{
			Vector3 vector = Vector3.Cross(bone2.position - bone1.position, bone3.position - bone1.position);
			if (vector == Vector3.zero)
			{
				warningMessage = "BipedReferences limb is completely stretched out in the initial pose. IK solver can not calculate the default bend plane for the limb. Please make sure you character's limbs are at least slightly bent in the initial pose. First bone: " + bone1.name + ", second bone: " + bone2.name + ".";
				return true;
			}
			return false;
		}

		private static bool SpineError(BipedReferences references, ref string errorMessage)
		{
			if (references.spine.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < references.spine.Length; i++)
			{
				if (references.spine[i] == null)
				{
					errorMessage = "BipedReferences spine bone at index " + i + " is null.";
					return true;
				}
			}
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(references.spine);
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in BipedReferences spine.";
				return true;
			}
			if (!Hierarchy.HierarchyIsValid(references.spine))
			{
				errorMessage = "BipedReferences spine hierarchy is invalid. Bone transforms in the spine do not belong to the same ancestry. Please make sure the bones are parented to each other.";
				return true;
			}
			for (int j = 0; j < references.spine.Length; j++)
			{
				bool flag = false;
				if (j == 0 && references.spine[j].position == references.pelvis.position)
				{
					flag = true;
				}
				if (j != 0 && references.spine.Length > 1 && references.spine[j].position == references.spine[j - 1].position)
				{
					flag = true;
				}
				if (flag)
				{
					errorMessage = "Biped's spine bone nr " + j + " position is the same as it's parent spine/pelvis bone's position. Please remove this bone from the spine.";
					return true;
				}
			}
			return false;
		}

		private static bool SpineWarning(BipedReferences references, ref string warningMessage)
		{
			return false;
		}

		private static bool EyesError(BipedReferences references, ref string errorMessage)
		{
			if (references.eyes.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < references.eyes.Length; i++)
			{
				if (references.eyes[i] == null)
				{
					errorMessage = "BipedReferences eye bone at index " + i + " is null.";
					return true;
				}
			}
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(references.eyes);
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in BipedReferences eyes.";
				return true;
			}
			return false;
		}

		private static bool EyesWarning(BipedReferences references, ref string warningMessage)
		{
			return false;
		}

		private static bool RootHeightWarning(BipedReferences references, ref string warningMessage)
		{
			if (references.head == null)
			{
				return false;
			}
			float verticalOffset = GetVerticalOffset(references.head.position, references.leftFoot.position, references.root.rotation);
			float verticalOffset2 = GetVerticalOffset(references.root.position, references.leftFoot.position, references.root.rotation);
			if (verticalOffset2 / verticalOffset > 0.2f)
			{
				warningMessage = "Biped's root Transform's position should be at ground level relative to the character (at the character's feet not at it's pelvis).";
				return true;
			}
			return false;
		}

		private static bool FacingAxisWarning(BipedReferences references, ref string warningMessage)
		{
			Vector3 vector = references.rightHand.position - references.leftHand.position;
			Vector3 vector2 = references.rightFoot.position - references.leftFoot.position;
			float num = Vector3.Dot(vector.normalized, references.root.right);
			float num2 = Vector3.Dot(vector2.normalized, references.root.right);
			if (num < 0f || num2 < 0f)
			{
				warningMessage = "Biped does not seem to be facing it's forward axis. Please make sure that in the initial pose the character is facing towards the positive Z axis of the Biped root gameobject.";
				return true;
			}
			return false;
		}

		private static float GetVerticalOffset(Vector3 p1, Vector3 p2, Quaternion rotation)
		{
			return (Quaternion.Inverse(rotation) * (p1 - p2)).y;
		}
	}
	public class Comments : MonoBehaviour
	{
		[Multiline]
		public string text;
	}
	public class DemoGUIMessage : MonoBehaviour
	{
		public string text;

		public Color color = Color.white;

		private void OnGUI()
		{
			GUI.color = color;
			GUILayout.Label(text);
			GUI.color = Color.white;
		}
	}
	public class Hierarchy
	{
		public static bool HierarchyIsValid(Transform[] bones)
		{
			for (int i = 1; i < bones.Length; i++)
			{
				if (!IsAncestor(bones[i], bones[i - 1]))
				{
					return false;
				}
			}
			return true;
		}

		public static UnityEngine.Object ContainsDuplicate(UnityEngine.Object[] objects)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				for (int j = 0; j < objects.Length; j++)
				{
					if (i != j && objects[i] == objects[j])
					{
						return objects[i];
					}
				}
			}
			return null;
		}

		public static bool IsAncestor(Transform transform, Transform ancestor)
		{
			if (transform == null)
			{
				return true;
			}
			if (ancestor == null)
			{
				return true;
			}
			if (transform.parent == null)
			{
				return false;
			}
			if (transform.parent == ancestor)
			{
				return true;
			}
			return IsAncestor(transform.parent, ancestor);
		}

		public static bool ContainsChild(Transform transform, Transform child)
		{
			if (transform == child)
			{
				return true;
			}
			Transform[] componentsInChildren = transform.GetComponentsInChildren<Transform>();
			Transform[] array = componentsInChildren;
			foreach (Transform transform2 in array)
			{
				if (transform2 == child)
				{
					return true;
				}
			}
			return false;
		}

		public static void AddAncestors(Transform transform, Transform blocker, ref Transform[] array)
		{
			if (transform.parent != null && transform.parent != blocker)
			{
				if (transform.parent.position != transform.position && transform.parent.position != blocker.position)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform.parent;
				}
				AddAncestors(transform.parent, blocker, ref array);
			}
		}

		public static Transform GetAncestor(Transform transform, int minChildCount)
		{
			if (transform == null)
			{
				return null;
			}
			if (transform.parent != null)
			{
				if (transform.parent.childCount >= minChildCount)
				{
					return transform.parent;
				}
				return GetAncestor(transform.parent, minChildCount);
			}
			return null;
		}

		public static Transform GetFirstCommonAncestor(Transform t1, Transform t2)
		{
			if (t1 == null)
			{
				return null;
			}
			if (t2 == null)
			{
				return null;
			}
			if (t1.parent == null)
			{
				return null;
			}
			if (t2.parent == null)
			{
				return null;
			}
			if (IsAncestor(t2, t1.parent))
			{
				return t1.parent;
			}
			return GetFirstCommonAncestor(t1.parent, t2);
		}

		public static Transform GetFirstCommonAncestor(Transform[] transforms)
		{
			if (transforms == null)
			{
				Debug.LogWarning("Transforms is null.");
				return null;
			}
			if (transforms.Length == 0)
			{
				Debug.LogWarning("Transforms.Length is 0.");
				return null;
			}
			for (int i = 0; i < transforms.Length; i++)
			{
				if (transforms[i] == null)
				{
					return null;
				}
				if (IsCommonAncestor(transforms[i], transforms))
				{
					return transforms[i];
				}
			}
			return GetFirstCommonAncestorRecursive(transforms[0], transforms);
		}

		public static Transform GetFirstCommonAncestorRecursive(Transform transform, Transform[] transforms)
		{
			if (transform == null)
			{
				Debug.LogWarning("Transform is null.");
				return null;
			}
			if (transforms == null)
			{
				Debug.LogWarning("Transforms is null.");
				return null;
			}
			if (transforms.Length == 0)
			{
				Debug.LogWarning("Transforms.Length is 0.");
				return null;
			}
			if (IsCommonAncestor(transform, transforms))
			{
				return transform;
			}
			if (transform.parent == null)
			{
				return null;
			}
			return GetFirstCommonAncestorRecursive(transform.parent, transforms);
		}

		public static bool IsCommonAncestor(Transform transform, Transform[] transforms)
		{
			if (transform == null)
			{
				Debug.LogWarning("Transform is null.");
				return false;
			}
			for (int i = 0; i < transforms.Length; i++)
			{
				if (transforms[i] == null)
				{
					Debug.Log("Transforms[" + i + "] is null.");
					return false;
				}
				if (!IsAncestor(transforms[i], transform) && transforms[i] != transform)
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	public enum InterpolationMode
	{
		None,
		InOutCubic,
		InOutQuintic,
		InOutSine,
		InQuintic,
		InQuartic,
		InCubic,
		InQuadratic,
		InElastic,
		InElasticSmall,
		InElasticBig,
		InSine,
		InBack,
		OutQuintic,
		OutQuartic,
		OutCubic,
		OutInCubic,
		OutInQuartic,
		OutElastic,
		OutElasticSmall,
		OutElasticBig,
		OutSine,
		OutBack,
		OutBackCubic,
		OutBackQuartic,
		BackInCubic,
		BackInQuartic
	}
	public class Interp
	{
		public static float Float(float t, InterpolationMode mode)
		{
			float num = 0f;
			return mode switch
			{
				InterpolationMode.None => None(t, 0f, 1f), 
				InterpolationMode.InOutCubic => InOutCubic(t, 0f, 1f), 
				InterpolationMode.InOutQuintic => InOutQuintic(t, 0f, 1f), 
				InterpolationMode.InQuintic => InQuintic(t, 0f, 1f), 
				InterpolationMode.InQuartic => InQuartic(t, 0f, 1f), 
				InterpolationMode.InCubic => InCubic(t, 0f, 1f), 
				InterpolationMode.InQuadratic => InQuadratic(t, 0f, 1f), 
				InterpolationMode.OutQuintic => OutQuintic(t, 0f, 1f), 
				InterpolationMode.OutQuartic => OutQuartic(t, 0f, 1f), 
				InterpolationMode.OutCubic => OutCubic(t, 0f, 1f), 
				InterpolationMode.OutInCubic => OutInCubic(t, 0f, 1f), 
				InterpolationMode.OutInQuartic => OutInCubic(t, 0f, 1f), 
				InterpolationMode.BackInCubic => BackInCubic(t, 0f, 1f), 
				InterpolationMode.BackInQuartic => BackInQuartic(t, 0f, 1f), 
				InterpolationMode.OutBackCubic => OutBackCubic(t, 0f, 1f), 
				InterpolationMode.OutBackQuartic => OutBackQuartic(t, 0f, 1f), 
				InterpolationMode.OutElasticSmall => OutElasticSmall(t, 0f, 1f), 
				InterpolationMode.OutElasticBig => OutElasticBig(t, 0f, 1f), 
				InterpolationMode.InElasticSmall => InElasticSmall(t, 0f, 1f), 
				InterpolationMode.InElasticBig => InElasticBig(t, 0f, 1f), 
				InterpolationMode.InSine => InSine(t, 0f, 1f), 
				InterpolationMode.OutSine => OutSine(t, 0f, 1f), 
				InterpolationMode.InOutSine => InOutSine(t, 0f, 1f), 
				InterpolationMode.InElastic => OutElastic(t, 0f, 1f), 
				InterpolationMode.OutElastic => OutElastic(t, 0f, 1f), 
				InterpolationMode.InBack => InBack(t, 0f, 1f), 
				InterpolationMode.OutBack => OutBack(t, 0f, 1f), 
				_ => 0f, 
			};
		}

		public static Vector3 V3(Vector3 v1, Vector3 v2, float t, InterpolationMode mode)
		{
			float num = Float(t, mode);
			return (1f - num) * v1 + num * v2;
		}

		public static float LerpValue(float value, float target, float increaseSpeed, float decreaseSpeed)
		{
			if (value == target)
			{
				return target;
			}
			if (value < target)
			{
				return Mathf.Clamp(value + Time.deltaTime * increaseSpeed, float.NegativeInfinity, target);
			}
			return Mathf.Clamp(value - Time.deltaTime * decreaseSpeed, target, float.PositiveInfinity);
		}

		private static float None(float t, float b, float c)
		{
			return b + c * t;
		}

		private static float InOutCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-2f * num2 + 3f * num);
		}

		private static float InOutQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (6f * num2 * num + -15f * num * num + 10f * num2);
		}

		private static float InQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 * num);
		}

		private static float InQuartic(float t, float b, float c)
		{
			float num = t * t;
			return b + c * (num * num);
		}

		private static float InCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * num2;
		}

		private static float InQuadratic(float t, float b, float c)
		{
			float num = t * t;
			return b + c * num;
		}

		private static float OutQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 * num + -5f * num * num + 10f * num2 + -10f * num + 5f * t);
		}

		private static float OutQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-1f * num * num + 4f * num2 + -6f * num + 4f * t);
		}

		private static float OutCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 + -3f * num + 3f * t);
		}

		private static float OutInCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -6f * num + 3f * t);
		}

		private static float OutInQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (6f * num2 + -9f * num + 4f * t);
		}

		private static float BackInCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -3f * num);
		}

		private static float BackInQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (2f * num * num + 2f * num2 + -3f * num);
		}

		private static float OutBackCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -9f * num + 6f * t);
		}

		private static float OutBackQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-2f * num * num + 10f * num2 + -15f * num + 8f * t);
		}

		private static float OutElasticSmall(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (33f * num2 * num + -106f * num * num + 126f * num2 + -67f * num + 15f * t);
		}

		private static float OutElasticBig(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (56f * num2 * num + -175f * num * num + 200f * num2 + -100f * num + 20f * t);
		}

		private static float InElasticSmall(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (33f * num2 * num + -59f * num * num + 32f * num2 + -5f * num);
		}

		private static float InElasticBig(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (56f * num2 * num + -105f * num * num + 60f * num2 + -10f * num);
		}

		private static float InSine(float t, float b, float c)
		{
			c -= b;
			return (0f - c) * Mathf.Cos(t / 1f * ((float)Math.PI / 2f)) + c + b;
		}

		private static float OutSine(float t, float b, float c)
		{
			c -= b;
			return c * Mathf.Sin(t / 1f * ((float)Math.PI / 2f)) + b;
		}

		private static float InOutSine(float t, float b, float c)
		{
			c -= b;
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * t / 1f) - 1f) + b;
		}

		private static float InElastic(float t, float b, float c)
		{
			c -= b;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (t == 0f)
			{
				return b;
			}
			if ((t /= num) == 1f)
			{
				return b + c;
			}
			if (num4 == 0f || num4 < Mathf.Abs(c))
			{
				num4 = c;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(c / num4);
			}
			return 0f - num4 * Mathf.Pow(2f, 10f * (t -= 1f)) * Mathf.Sin((t * num - num3) * ((float)Math.PI * 2f) / num2) + b;
		}

		private static float OutElastic(float t, float b, float c)
		{
			c -= b;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (t == 0f)
			{
				return b;
			}
			if ((t /= num) == 1f)
			{
				return b + c;
			}
			if (num4 == 0f || num4 < Mathf.Abs(c))
			{
				num4 = c;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(c / num4);
			}
			return num4 * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t * num - num3) * ((float)Math.PI * 2f) / num2) + c + b;
		}

		private static float InBack(float t, float b, float c)
		{
			c -= b;
			t /= 1f;
			float num = 1.70158f;
			return c * t * t * ((num + 1f) * t - num) + b;
		}

		private static float OutBack(float t, float b, float c)
		{
			float num = 1.70158f;
			c -= b;
			t = t / 1f - 1f;
			return c * (t * t * ((num + 1f) * t + num) + 1f) + b;
		}
	}
	public class LargeHeader : PropertyAttribute
	{
		public string name;

		public string color = "white";

		public LargeHeader(string name)
		{
			this.name = name;
			color = "white";
		}

		public LargeHeader(string name, string color)
		{
			this.name = name;
			this.color = color;
		}
	}
	public static class LayerMaskExtensions
	{
		public static bool Contains(LayerMask mask, int layer)
		{
			return (int)mask == ((int)mask | (1 << layer));
		}

		public static LayerMask Create(params string[] layerNames)
		{
			return NamesToMask(layerNames);
		}

		public static LayerMask Create(params int[] layerNumbers)
		{
			return LayerNumbersToMask(layerNumbers);
		}

		public static LayerMask NamesToMask(params string[] layerNames)
		{
			LayerMask layerMask = 0;
			foreach (string layerName in layerNames)
			{
				layerMask = (int)layerMask | (1 << LayerMask.NameToLayer(layerName));
			}
			return layerMask;
		}

		public static LayerMask LayerNumbersToMask(params int[] layerNumbers)
		{
			LayerMask layerMask = 0;
			foreach (int num in layerNumbers)
			{
				layerMask = (int)layerMask | (1 << num);
			}
			return layerMask;
		}

		public static LayerMask Inverse(this LayerMask original)
		{
			return ~(int)original;
		}

		public static LayerMask AddToMask(this LayerMask original, params string[] layerNames)
		{
			return (int)original | (int)NamesToMask(layerNames);
		}

		public static LayerMask RemoveFromMask(this LayerMask original, params string[] layerNames)
		{
			LayerMask layerMask = ~(int)original;
			return ~((int)layerMask | (int)NamesToMask(layerNames));
		}

		public static string[] MaskToNames(this LayerMask original)
		{
			List<string> list = new List<string>();
			for (int i = 0; i < 32; i++)
			{
				int num = 1 << i;
				if (((int)original & num) == num)
				{
					string text = LayerMask.LayerToName(i);
					if (!string.IsNullOrEmpty(text))
					{
						list.Add(text);
					}
				}
			}
			return list.ToArray();
		}

		public static int[] MaskToNumbers(this LayerMask original)
		{
			List<int> list = new List<int>();
			for (int i = 0; i < 32; i++)
			{
				int num = 1 << i;
				if (((int)original & num) == num)
				{
					list.Add(i);
				}
			}
			return list.ToArray();
		}

		public static string MaskToString(this LayerMask original)
		{
			return original.MaskToString(", ");
		}

		public static string MaskToString(this LayerMask original, string delimiter)
		{
			return string.Join(delimiter, original.MaskToNames());
		}
	}
	public static class QuaTools
	{
		public static Quaternion Lerp(Quaternion fromRotation, Quaternion toRotation, float weight)
		{
			if (weight <= 0f)
			{
				return fromRotation;
			}
			if (weight >= 1f)
			{
				return toRotation;
			}
			return Quaternion.Lerp(fromRotation, toRotation, weight);
		}

		public static Quaternion Slerp(Quaternion fromRotation, Quaternion toRotation, float weight)
		{
			if (weight <= 0f)
			{
				return fromRotation;
			}
			if (weight >= 1f)
			{
				return toRotation;
			}
			return Quaternion.Slerp(fromRotation, toRotation, weight);
		}

		public static Quaternion LinearBlend(Quaternion q, float weight)
		{
			if (weight <= 0f)
			{
				return Quaternion.identity;
			}
			if (weight >= 1f)
			{
				return q;
			}
			return Quaternion.Lerp(Quaternion.identity, q, weight);
		}

		public static Quaternion SphericalBlend(Quaternion q, float weight)
		{
			if (weight <= 0f)
			{
				return Quaternion.identity;
			}
			if (weight >= 1f)
			{
				return q;
			}
			return Quaternion.Slerp(Quaternion.identity, q, weight);
		}

		public static Quaternion FromToAroundAxis(Vector3 fromDirection, Vector3 toDirection, Vector3 axis)
		{
			Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
			float angle = 0f;
			Vector3 axis2 = Vector3.zero;
			quaternion.ToAngleAxis(out angle, out axis2);
			float num = Vector3.Dot(axis2, axis);
			if (num < 0f)
			{
				angle = 0f - angle;
			}
			return Quaternion.AngleAxis(angle, axis);
		}

		public static Quaternion RotationToLocalSpace(Quaternion space, Quaternion rotation)
		{
			return Quaternion.Inverse(Quaternion.Inverse(space) * rotation);
		}

		public static Quaternion FromToRotation(Quaternion from, Quaternion to)
		{
			if (to == from)
			{
				return Quaternion.identity;
			}
			return to * Quaternion.Inverse(from);
		}

		public static Vector3 GetAxis(Vector3 v)
		{
			Vector3 vector = Vector3.right;
			bool flag = false;
			float num = Vector3.Dot(v, Vector3.right);
			float num2 = Mathf.Abs(num);
			if (num < 0f)
			{
				flag = true;
			}
			float num3 = Vector3.Dot(v, Vector3.up);
			float num4 = Mathf.Abs(num3);
			if (num4 > num2)
			{
				num2 = num4;
				vector = Vector3.up;
				flag = num3 < 0f;
			}
			float num5 = Vector3.Dot(v, Vector3.forward);
			num4 = Mathf.Abs(num5);
			if (num4 > num2)
			{
				vector = Vector3.forward;
				flag = num5 < 0f;
			}
			if (flag)
			{
				vector = -vector;
			}
			return vector;
		}

		public static Quaternion ClampRotation(Quaternion rotation, float clampWeight, int clampSmoothing)
		{
			if (clampWeight >= 1f)
			{
				return Quaternion.identity;
			}
			if (clampWeight <= 0f)
			{
				return rotation;
			}
			float num = Quaternion.Angle(Quaternion.identity, rotation);
			float num2 = 1f - num / 180f;
			float num3 = Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f);
			float num4 = Mathf.Clamp(num2 / clampWeight, 0f, 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				float f = num4 * (float)Math.PI * 0.5f;
				num4 = Mathf.Sin(f);
			}
			return Quaternion.Slerp(Quaternion.identity, rotation, num4 * num3);
		}

		public static float ClampAngle(float angle, float clampWeight, int clampSmoothing)
		{
			if (clampWeight >= 1f)
			{
				return 0f;
			}
			if (clampWeight <= 0f)
			{
				return angle;
			}
			float num = 1f - Mathf.Abs(angle) / 180f;
			float num2 = Mathf.Clamp(1f - (clampWeight - num) / (1f - num), 0f, 1f);
			float num3 = Mathf.Clamp(num / clampWeight, 0f, 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				float f = num3 * (float)Math.PI * 0.5f;
				num3 = Mathf.Sin(f);
			}
			return Mathf.Lerp(0f, angle, num3 * num2);
		}

		public static Quaternion MatchRotation(Quaternion targetRotation, Vector3 targetforwardAxis, Vector3 targetUpAxis, Vector3 forwardAxis, Vector3 upAxis)
		{
			Quaternion rotation = Quaternion.LookRotation(forwardAxis, upAxis);
			Quaternion quaternion = Quaternion.LookRotation(targetforwardAxis, targetUpAxis);
			Quaternion quaternion2 = targetRotation * quaternion;
			return quaternion2 * Quaternion.Inverse(rotation);
		}
	}
	public abstract class Singleton<T> : MonoBehaviour where T : Singleton<T>
	{
		private static T sInstance;

		public static T instance => sInstance;

		protected virtual void Awake()
		{
			if (sInstance != null)
			{
				Debug.LogError(base.name + "error: already initialized", this);
			}
			sInstance = (T)this;
		}
	}
	public class SolverManager : MonoBehaviour
	{
		[Tooltip("If true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance. Not recommended for CCD and FABRIK solvers.")]
		public bool fixTransforms = true;

		private Animator animator;

		private Animation legacy;

		private bool updateFrame;

		private bool componentInitiated;

		private bool skipSolverUpdate;

		private bool animatePhysics
		{
			get
			{
				if (animator != null)
				{
					return animator.updateMode == AnimatorUpdateMode.AnimatePhysics;
				}
				if (legacy != null)
				{
					return legacy.animatePhysics;
				}
				return false;
			}
		}

		private bool isAnimated => animator != null || legacy != null;

		public void Disable()
		{
			Debug.Log("IK.Disable() is deprecated. Use enabled = false instead", base.transform);
			base.enabled = false;
		}

		protected virtual void InitiateSolver()
		{
		}

		protected virtual void UpdateSolver()
		{
		}

		protected virtual void FixTransforms()
		{
		}

		private void OnDisable()
		{
			if (Application.isPlaying)
			{
				Initiate();
			}
		}

		private void Start()
		{
			Initiate();
		}

		private void Initiate()
		{
			if (!componentInitiated)
			{
				FindAnimatorRecursive(base.transform, findInChildren: true);
				InitiateSolver();
				componentInitiated = true;
			}
		}

		private void Update()
		{
			if (!skipSolverUpdate && !animatePhysics && fixTransforms)
			{
				FixTransforms();
			}
		}

		private void FindAnimatorRecursive(Transform t, bool findInChildren)
		{
			if (isAnimated)
			{
				return;
			}
			animator = t.GetComponent<Animator>();
			legacy = t.GetComponent<Animation>();
			if (!isAnimated)
			{
				if (animator == null && findInChildren)
				{
					animator = t.GetComponentInChildren<Animator>();
				}
				if (legacy == null && findInChildren)
				{
					legacy = t.GetComponentInChildren<Animation>();
				}
				if (!isAnimated && t.parent != null)
				{
					FindAnimatorRecursive(t.parent, findInChildren: false);
				}
			}
		}

		private void FixedUpdate()
		{
			if (skipSolverUpdate)
			{
				skipSolverUpdate = false;
			}
			updateFrame = true;
			if (animatePhysics && fixTransforms)
			{
				FixTransforms();
			}
		}

		private void LateUpdate()
		{
			if (!skipSolverUpdate)
			{
				if (!animatePhysics)
				{
					updateFrame = true;
				}
				if (updateFrame)
				{
					updateFrame = false;
					UpdateSolver();
				}
			}
		}

		public void UpdateSolverExternal()
		{
			if (base.enabled)
			{
				skipSolverUpdate = true;
				UpdateSolver();
			}
		}
	}
	public class TriggerEventBroadcaster : MonoBehaviour
	{
		public GameObject target;

		private void OnTriggerEnter(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerEnter", collider, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void OnTriggerStay(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerStay", collider, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void OnTriggerExit(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerExit", collider, SendMessageOptions.DontRequireReceiver);
			}
		}
	}
	public static class V3Tools
	{
		public static Vector3 Lerp(Vector3 fromVector, Vector3 toVector, float weight)
		{
			if (weight <= 0f)
			{
				return fromVector;
			}
			if (weight >= 1f)
			{
				return toVector;
			}
			return Vector3.Lerp(fromVector, toVector, weight);
		}

		public static Vector3 Slerp(Vector3 fromVector, Vector3 toVector, float weight)
		{
			if (weight <= 0f)
			{
				return fromVector;
			}
			if (weight >= 1f)
			{
				return toVector;
			}
			return Vector3.Slerp(fromVector, toVector, weight);
		}

		public static Vector3 ExtractVertical(Vector3 v, Vector3 verticalAxis, float weight)
		{
			if (weight == 0f)
			{
				return Vector3.zero;
			}
			return Vector3.Project(v, verticalAxis) * weight;
		}

		public static Vector3 ExtractHorizontal(Vector3 v, Vector3 normal, float weight)
		{
			if (weight == 0f)
			{
				return Vector3.zero;
			}
			Vector3 tangent = v;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return Vector3.Project(v, tangent) * weight;
		}

		public static Vector3 ClampDirection(Vector3 direction, Vector3 normalDirection, float clampWeight, int clampSmoothing, out bool changed)
		{
			changed = false;
			if (clampWeight <= 0f)
			{
				return direction;
			}
			if (clampWeight >= 1f)
			{
				changed = true;
				return normalDirection;
			}
			float num = Vector3.Angle(normalDirection, direction);
			float num2 = 1f - num / 180f;
			if (num2 > clampWeight)
			{
				return direction;
			}
			changed = true;
			float num3 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f));
			float num4 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(num2 / clampWeight, 0f, 1f));
			for (int i = 0; i < clampSmoothing; i++)
			{
				float f = num4 * (float)Math.PI * 0.5f;
				num4 = Mathf.Sin(f);
			}
			return Vector3.Slerp(normalDirection, direction, num4 * num3);
		}

		public static Vector3 ClampDirection(Vector3 direction, Vector3 normalDirection, float clampWeight, int clampSmoothing, out float clampValue)
		{
			clampValue = 1f;
			if (clampWeight <= 0f)
			{
				return direction;
			}
			if (clampWeight >= 1f)
			{
				return normalDirection;
			}
			float num = Vector3.Angle(normalDirection, direction);
			float num2 = 1f - num / 180f;
			if (num2 > clampWeight)
			{
				clampValue = 0f;
				return direction;
			}
			float num3 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f));
			float num4 = ((!(clampWeight > 0f)) ? 1f : Mathf.Clamp(num2 / clampWeight, 0f, 1f));
			for (int i = 0; i < clampSmoothing; i++)
			{
				float f = num4 * (float)Math.PI * 0.5f;
				num4 = Mathf.Sin(f);
			}
			float num5 = num4 * num3;
			clampValue = 1f - num5;
			return Vector3.Slerp(normalDirection, direction, num5);
		}

		public static Vector3 LineToPlane(Vector3 origin, Vector3 direction, Vector3 planeNormal, Vector3 planePoint)
		{
			float num = Vector3.Dot(planePoint - origin, planeNormal);
			float num2 = Vector3.Dot(direction, planeNormal);
			if (num2 == 0f)
			{
				return Vector3.zero;
			}
			float num3 = num / num2;
			return origin + direction.normalized * num3;
		}

		public static Vector3 PointToPlane(Vector3 point, Vector3 planePosition, Vector3 planeNormal)
		{
			if (planeNormal == Vector3.up)
			{
				return new Vector3(point.x, planePosition.y, point.z);
			}
			Vector3 tangent = point - planePosition;
			Vector3 normal = planeNormal;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return planePosition + Vector3.Project(point - planePosition, tangent);
		}
	}
	public static class Warning
	{
		public delegate void Logger(string message);

		public static bool logged;

		public static void Log(string message, Logger logger, bool logInEditMode = false)
		{
			if ((logInEditMode || Application.isPlaying) && !logged)
			{
				logger?.Invoke(message);
				logged = true;
			}
		}

		public static void Log(string message, Transform context, bool logInEditMode = false)
		{
			if ((logInEditMode || Application.isPlaying) && !logged)
			{
				Debug.LogWarning(message, context);
				logged = true;
			}
		}
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Blur")]
public class BlurEffect : MonoBehaviour
{
	public int iterations = 3;

	public float blurSpread = 0.6f;

	public Shader blurShader;

	private static Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(blurShader);
				m_Material.hideFlags = HideFlags.DontSave;
			}
			return m_Material;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!blurShader || !material.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		float num = 1f;
		Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		for (int i = 0; i < iterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		Graphics.Blit(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
public class ColorCorrectionEffect : ImageEffectBase
{
	public Texture textureRamp;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
public class ContrastStretchEffect : MonoBehaviour
{
	public float adaptationSpeed = 0.02f;

	public float limitMinimum = 0.2f;

	public float limitMaximum = 0.6f;

	private RenderTexture[] adaptRenderTex = new RenderTexture[2];

	private int curAdaptIndex;

	public Shader shaderLum;

	private Material m_materialLum;

	public Shader shaderReduce;

	private Material m_materialReduce;

	public Shader shaderAdapt;

	private Material m_materialAdapt;

	public Shader shaderApply;

	private Material m_materialApply;

	protected Material materialLum
	{
		get
		{
			if (m_materialLum == null)
			{
				m_materialLum = new Material(shaderLum);
				m_materialLum.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialLum;
		}
	}

	protected Material materialReduce
	{
		get
		{
			if (m_materialReduce == null)
			{
				m_materialReduce = new Material(shaderReduce);
				m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialReduce;
		}
	}

	protected Material materialAdapt
	{
		get
		{
			if (m_materialAdapt == null)
			{
				m_materialAdapt = new Material(shaderAdapt);
				m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialAdapt;
		}
	}

	protected Material materialApply
	{
		get
		{
			if (m_materialApply == null)
			{
				m_materialApply = new Material(shaderApply);
				m_materialApply.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialApply;
		}
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
		{
			base.enabled = false;
		}
	}

	private void OnEnable()
	{
		for (int i = 0; i < 2; i++)
		{
			if (!adaptRenderTex[i])
			{
				adaptRenderTex[i] = new RenderTexture(1, 1, 0);
				adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
			}
		}
	}

	private void OnDisable()
	{
		for (int i = 0; i < 2; i++)
		{
			UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
			adaptRenderTex[i] = null;
		}
		if ((bool)m_materialLum)
		{
			UnityEngine.Object.DestroyImmediate(m_materialLum);
		}
		if ((bool)m_materialReduce)
		{
			UnityEngine.Object.DestroyImmediate(m_materialReduce);
		}
		if ((bool)m_materialAdapt)
		{
			UnityEngine.Object.DestroyImmediate(m_materialAdapt);
		}
		if ((bool)m_materialApply)
		{
			UnityEngine.Object.DestroyImmediate(m_materialApply);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width, source.height);
		Graphics.Blit(source, renderTexture, materialLum);
		while (renderTexture.width > 1 || renderTexture.height > 1)
		{
			int num = renderTexture.width / 2;
			if (num < 1)
			{
				num = 1;
			}
			int num2 = renderTexture.height / 2;
			if (num2 < 1)
			{
				num2 = 1;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
			Graphics.Blit(renderTexture, temporary, materialReduce);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		CalculateAdaptation(renderTexture);
		materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
		Graphics.Blit(source, destination, materialApply);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	private void CalculateAdaptation(Texture curTexture)
	{
		int num = curAdaptIndex;
		curAdaptIndex = (curAdaptIndex + 1) % 2;
		float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
		value = Mathf.Clamp(value, 0.01f, 1f);
		materialAdapt.SetTexture("_CurTex", curTexture);
		materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
		Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
		GL.Clear(clearDepth: false, clearColor: true, Color.black);
		Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Bloom and Glow/Glow (Deprecated)")]
public class GlowEffect : MonoBehaviour
{
	public float glowIntensity = 1.5f;

	public int blurIterations = 3;

	public float blurSpread = 0.7f;

	public Color glowTint = new Color(1f, 1f, 1f, 0f);

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	public Shader downsampleShader;

	private Material m_DownsampleMaterial;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material downsampleMaterial
	{
		get
		{
			if (m_DownsampleMaterial == null)
			{
				m_DownsampleMaterial = new Material(downsampleShader);
				m_DownsampleMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_DownsampleMaterial;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_DownsampleMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_DownsampleMaterial);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (downsampleShader == null)
		{
			Debug.Log("No downsample shader assigned! Disabling glow.");
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!downsampleMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		Graphics.BlitMultiTap(source, dest, blurMaterial, new Vector2(num, num), new Vector2(0f - num, num), new Vector2(num, 0f - num), new Vector2(0f - num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		downsampleMaterial.color = new Color(glowTint.r, glowTint.g, glowTint.b, glowTint.a / 4f);
		Graphics.Blit(source, dest, downsampleMaterial);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		glowIntensity = Mathf.Clamp(glowIntensity, 0f, 10f);
		blurIterations = Mathf.Clamp(blurIterations, 0, 30);
		blurSpread = Mathf.Clamp(blurSpread, 0.5f, 1f);
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		float num = Mathf.Clamp01((glowIntensity - 1f) / 4f);
		blurMaterial.color = new Color(1f, 1f, 1f, 0.25f + num);
		for (int i = 0; i < blurIterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		Graphics.Blit(source, destination);
		BlitGlow(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	public void BlitGlow(RenderTexture source, RenderTexture dest)
	{
		compositeMaterial.color = new Color(1f, 1f, 1f, Mathf.Clamp01(glowIntensity));
		Graphics.Blit(source, dest, compositeMaterial);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
public class GrayscaleEffect : ImageEffectBase
{
	public Texture textureRamp;

	public float rampOffset;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		base.material.SetFloat("_RampOffset", rampOffset);
		Graphics.Blit(source, destination, base.material);
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("")]
public class ImageEffectBase : MonoBehaviour
{
	public Shader shader;

	private Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(shader);
				m_Material.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_Material;
		}
	}

	protected virtual void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shader || !shader.isSupported)
		{
			base.enabled = false;
		}
	}

	protected virtual void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}
}
[AddComponentMenu("")]
public class ImageEffects
{
	public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
	{
		if (source.texelSize.y < 0f)
		{
			center.y = 1f - center.y;
			angle = 0f - angle;
		}
		Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
		material.SetMatrix("_RotationMatrix", value);
		material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
		material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
		Graphics.Blit(source, destination, material);
	}

	[Obsolete("Use Graphics.Blit(source,dest) instead")]
	public static void Blit(RenderTexture source, RenderTexture dest)
	{
		Graphics.Blit(source, dest);
	}

	[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
	public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
	{
		Graphics.Blit(source, dest, material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
[RequireComponent(typeof(Camera))]
public class MotionBlur : ImageEffectBase
{
	public float blurAmount = 0.8f;

	public bool extraBlur;

	private RenderTexture accumTexture;

	protected override void Start()
	{
		if (!SystemInfo.supportsRenderTextures)
		{
			base.enabled = false;
		}
		else
		{
			base.Start();
		}
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		UnityEngine.Object.DestroyImmediate(accumTexture);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
		{
			UnityEngine.Object.DestroyImmediate(accumTexture);
			accumTexture = new RenderTexture(source.width, source.height, 0);
			accumTexture.hideFlags = HideFlags.HideAndDontSave;
			Graphics.Blit(source, accumTexture);
		}
		if (extraBlur)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
			accumTexture.MarkRestoreExpected();
			Graphics.Blit(accumTexture, temporary);
			Graphics.Blit(temporary, accumTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
		base.material.SetTexture("_MainTex", accumTexture);
		base.material.SetFloat("_AccumOrig", 1f - blurAmount);
		accumTexture.MarkRestoreExpected();
		Graphics.Blit(source, accumTexture, base.material);
		Graphics.Blit(accumTexture, destination);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
public class NoiseEffect : MonoBehaviour
{
	public bool monochrome = true;

	private bool rgbFallback;

	public float grainIntensityMin = 0.1f;

	public float grainIntensityMax = 0.2f;

	public float grainSize = 2f;

	public float scratchIntensityMin = 0.05f;

	public float scratchIntensityMax = 0.25f;

	public float scratchFPS = 10f;

	public float scratchJitter = 0.01f;

	public Texture grainTexture;

	public Texture scratchTexture;

	public Shader shaderRGB;

	public Shader shaderYUV;

	private Material m_MaterialRGB;

	private Material m_MaterialYUV;

	private float scratchTimeLeft;

	private float scratchX;

	private float scratchY;

	protected Material material
	{
		get
		{
			if (m_MaterialRGB == null)
			{
				m_MaterialRGB = new Material(shaderRGB);
				m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
			}
			if (m_MaterialYUV == null && !rgbFallback)
			{
				m_MaterialYUV = new Material(shaderYUV);
				m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
			}
			return (rgbFallback || monochrome) ? m_MaterialRGB : m_MaterialYUV;
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (shaderRGB == null || shaderYUV == null)
		{
			Debug.Log("Noise shaders are not set up! Disabling noise effect.");
			base.enabled = false;
		}
		else if (!shaderRGB.isSupported)
		{
			base.enabled = false;
		}
		else if (!shaderYUV.isSupported)
		{
			rgbFallback = true;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_MaterialRGB)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
		}
		if ((bool)m_MaterialYUV)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
		}
	}

	private void SanitizeParameters()
	{
		grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
		grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
		scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
		scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
		scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
		scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
		grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		SanitizeParameters();
		if (scratchTimeLeft <= 0f)
		{
			scratchTimeLeft = Random.value * 2f / scratchFPS;
			scratchX = Random.value;
			scratchY = Random.value;
		}
		scratchTimeLeft -= Time.deltaTime;
		Material material = this.material;
		material.SetTexture("_GrainTex", grainTexture);
		material.SetTexture("_ScratchTex", scratchTexture);
		float num = 1f / grainSize;
		material.SetVector("_GrainOffsetScale", new Vector4(Random.value, Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
		material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + Random.value * scratchJitter, scratchY + Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
		material.SetVector("_Intensity", new Vector4(Random.Range(grainIntensityMin, grainIntensityMax), Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
		Graphics.Blit(source, destination, material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
public class SepiaToneEffect : ImageEffectBase
{
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
public class SSAOEffect : MonoBehaviour
{
	public enum SSAOSamples
	{
		Low,
		Medium,
		High
	}

	public float m_Radius = 0.4f;

	public SSAOSamples m_SampleCount = SSAOSamples.Medium;

	public float m_OcclusionIntensity = 1.5f;

	public int m_Blur = 2;

	public int m_Downsampling = 2;

	public float m_OcclusionAttenuation = 1f;

	public float m_MinZ = 0.01f;

	public Shader m_SSAOShader;

	private Material m_SSAOMaterial;

	public Texture2D m_RandomTexture;

	private bool m_Supported;

	private static Material CreateMaterial(Shader shader)
	{
		if (!shader)
		{
			return null;
		}
		Material material = new Material(shader);
		material.hideFlags = HideFlags.HideAndDontSave;
		return material;
	}

	private static void DestroyMaterial(Material mat)
	{
		if ((bool)mat)
		{
			UnityEngine.Object.DestroyImmediate(mat);
			mat = null;
		}
	}

	private void OnDisable()
	{
		DestroyMaterial(m_SSAOMaterial);
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			m_Supported = false;
			base.enabled = false;
			return;
		}
		CreateMaterials();
		if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
		{
			m_Supported = false;
			base.enabled = false;
		}
		else
		{
			m_Supported = true;
		}
	}

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
	}

	private void CreateMaterials()
	{
		if (!m_SSAOMaterial && m_SSAOShader.isSupported)
		{
			m_SSAOMaterial = CreateMaterial(m_SSAOShader);
			m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
		}
	}

	[ImageEffectOpaque]
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!m_Supported || !m_SSAOShader.isSupported)
		{
			base.enabled = false;
			return;
		}
		CreateMaterials();
		m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
		m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
		m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
		m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
		m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
		m_Blur = Mathf.Clamp(m_Blur, 0, 4);
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
		float fieldOfView = GetComponent<Camera>().fieldOfView;
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
		float x = num * GetComponent<Camera>().aspect;
		m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
		int num2;
		int num3;
		if ((bool)m_RandomTexture)
		{
			num2 = m_RandomTexture.width;
			num3 = m_RandomTexture.height;
		}
		else
		{
			num2 = 1;
			num3 = 1;
		}
		m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
		m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
		bool flag = m_Blur > 0;
		Graphics.Blit((!flag) ? source : null, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
		if (flag)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", temporary);
			Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(temporary);
			renderTexture = temporary2;
		}
		m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
		Graphics.Blit(source, destination, m_SSAOMaterial, 4);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Twirl")]
public class TwirlEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.3f, 0.3f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Vortex")]
public class VortexEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.4f, 0.4f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
[ExecuteInEditMode]
public class Water : MonoBehaviour
{
	public enum WaterMode
	{
		Simple,
		Reflective,
		Refractive
	}

	public WaterMode m_WaterMode = WaterMode.Refractive;

	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 256;

	public float m_ClipPlaneOffset = 0.07f;

	public LayerMask m_ReflectLayers = -1;

	public LayerMask m_RefractLayers = -1;

	private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

	private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

	private RenderTexture m_ReflectionTexture;

	private RenderTexture m_RefractionTexture;

	private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

	private int m_OldReflectionTextureSize;

	private int m_OldRefractionTextureSize;

	private static bool s_InsideWater;

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if ((bool)current && !s_InsideWater)
		{
			s_InsideWater = true;
			m_HardwareWaterSupport = FindHardwareWaterSupport();
			WaterMode waterMode = GetWaterMode();
			CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
			Vector3 position = base.transform.position;
			Vector3 up = base.transform.up;
			int pixelLightCount = QualitySettings.pixelLightCount;
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = 0;
			}
			UpdateCameraModes(current, reflectionCamera);
			UpdateCameraModes(current, refractionCamera);
			if (waterMode >= WaterMode.Reflective)
			{
				float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 reflectionMat = Matrix4x4.zero;
				CalculateReflectionMatrix(ref reflectionMat, plane);
				Vector3 position2 = current.transform.position;
				Vector3 position3 = reflectionMat.MultiplyPoint(position2);
				reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
				Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
				Matrix4x4 projection = current.projectionMatrix;
				CalculateObliqueMatrix(ref projection, clipPlane);
				reflectionCamera.projectionMatrix = projection;
				reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
				reflectionCamera.targetTexture = m_ReflectionTexture;
				GL.SetRevertBackfacing(revertBackFaces: true);
				reflectionCamera.transform.position = position3;
				Vector3 eulerAngles = current.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				reflectionCamera.Render();
				reflectionCamera.transform.position = position2;
				GL.SetRevertBackfacing(revertBackFaces: false);
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
			if (waterMode >= WaterMode.Refractive)
			{
				refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
				Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
				Matrix4x4 projection2 = current.projectionMatrix;
				CalculateObliqueMatrix(ref projection2, clipPlane2);
				refractionCamera.projectionMatrix = projection2;
				refractionCamera.cullingMask = -17 & m_RefractLayers.value;
				refractionCamera.targetTexture = m_RefractionTexture;
				refractionCamera.transform.position = current.transform.position;
				refractionCamera.transform.rotation = current.transform.rotation;
				refractionCamera.Render();
				GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
			}
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = pixelLightCount;
			}
			switch (waterMode)
			{
			case WaterMode.Simple:
				Shader.EnableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Reflective:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.EnableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Refractive:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.EnableKeyword("WATER_REFRACTIVE");
				break;
			}
			s_InsideWater = false;
		}
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		if ((bool)m_RefractionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
			m_RefractionTexture = null;
		}
		foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
		}
		m_ReflectionCameras.Clear();
		foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
		{
			UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
		}
		m_RefractionCameras.Clear();
	}

	private void Update()
	{
		if ((bool)GetComponent<Renderer>())
		{
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if ((bool)sharedMaterial)
			{
				Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
				float @float = sharedMaterial.GetFloat("_WaveScale");
				Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
				double num = (double)Time.timeSinceLevelLoad / 20.0;
				Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
				sharedMaterial.SetVector("_WaveOffset", value2);
				sharedMaterial.SetVector("_WaveScale4", value);
				Vector3 size = GetComponent<Renderer>().bounds.size;
				Matrix4x4 value3 = Matrix4x4.TRS(s: new Vector3(size.x * value.x, size.z * value.y, 1f), pos: new Vector3(value2.x, value2.y, 0f), q: Quaternion.identity);
				sharedMaterial.SetMatrix("_WaveMatrix", value3);
				value3 = Matrix4x4.TRS(s: new Vector3(size.x * value.z, size.z * value.w, 1f), pos: new Vector3(value2.z, value2.w, 0f), q: Quaternion.identity);
				sharedMaterial.SetMatrix("_WaveMatrix2", value3);
			}
		}
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
	{
		WaterMode waterMode = GetWaterMode();
		reflectionCamera = null;
		refractionCamera = null;
		if (waterMode >= WaterMode.Reflective)
		{
			if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
			{
				if ((bool)m_ReflectionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				}
				m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
				m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
				m_ReflectionTexture.isPowerOfTwo = true;
				m_ReflectionTexture.hideFlags = HideFlags.DontSave;
				m_OldReflectionTextureSize = m_TextureSize;
			}
			m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
			if (!reflectionCamera)
			{
				GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				reflectionCamera = gameObject.GetComponent<Camera>();
				reflectionCamera.enabled = false;
				reflectionCamera.transform.position = base.transform.position;
				reflectionCamera.transform.rotation = base.transform.rotation;
				reflectionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject.hideFlags = HideFlags.HideAndDontSave;
				m_ReflectionCameras[currentCamera] = reflectionCamera;
			}
		}
		if (waterMode < WaterMode.Refractive)
		{
			return;
		}
		if (!m_RefractionTexture || m_OldRefractionTextureSize != m_TextureSize)
		{
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
			}
			m_RefractionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
			m_RefractionTexture.isPowerOfTwo = true;
			m_RefractionTexture.hideFlags = HideFlags.DontSave;
			m_OldRefractionTextureSize = m_TextureSize;
		}
		m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
		if (!refractionCamera)
		{
			GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			refractionCamera = gameObject2.GetComponent<Camera>();
			refractionCamera.enabled = false;
			refractionCamera.transform.position = base.transform.position;
			refractionCamera.transform.rotation = base.transform.rotation;
			refractionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject2.hideFlags = HideFlags.HideAndDontSave;
			m_RefractionCameras[currentCamera] = refractionCamera;
		}
	}

	private WaterMode GetWaterMode()
	{
		if (m_HardwareWaterSupport < m_WaterMode)
		{
			return m_HardwareWaterSupport;
		}
		return m_WaterMode;
	}

	private WaterMode FindHardwareWaterSupport()
	{
		if (!SystemInfo.supportsRenderTextures || !GetComponent<Renderer>())
		{
			return WaterMode.Simple;
		}
		Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
		if (!sharedMaterial)
		{
			return WaterMode.Simple;
		}
		string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
		if (text == "Refractive")
		{
			return WaterMode.Refractive;
		}
		if (text == "Reflective")
		{
			return WaterMode.Reflective;
		}
		return WaterMode.Simple;
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class Displace : MonoBehaviour
{
	public void Awake()
	{
		if (base.enabled)
		{
			OnEnable();
		}
		else
		{
			OnDisable();
		}
	}

	public void OnEnable()
	{
		Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
	}

	public void OnDisable()
	{
		Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class GerstnerDisplace : Displace
{
}
public class MeshContainer
{
	public Mesh mesh;

	public Vector3[] vertices;

	public Vector3[] normals;

	public MeshContainer(Mesh m)
	{
		mesh = m;
		vertices = m.vertices;
		normals = m.normals;
	}

	public void Update()
	{
		mesh.vertices = vertices;
		mesh.normals = normals;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class PlanarReflection : MonoBehaviour
{
	public LayerMask reflectionMask;

	public bool reflectSkybox;

	public Color clearColor = Color.grey;

	public string reflectionSampler = "_ReflectionTex";

	public float clipPlaneOffset = 0.07f;

	private Vector3 oldpos = Vector3.zero;

	private Camera reflectionCamera;

	private Material sharedMaterial;

	private Dictionary<Camera, bool> helperCameras;

	public void Start()
	{
		sharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
	}

	private Camera CreateReflectionCameraFor(Camera cam)
	{
		string text = base.gameObject.name + "Reflection" + cam.name;
		GameObject gameObject = GameObject.Find(text);
		if (!gameObject)
		{
			gameObject = new GameObject(text, typeof(Camera));
		}
		if (!gameObject.GetComponent(typeof(Camera)))
		{
			gameObject.AddComponent(typeof(Camera));
		}
		Camera component = gameObject.GetComponent<Camera>();
		component.backgroundColor = clearColor;
		component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
		SetStandardCameraParameter(component, reflectionMask);
		if (!component.targetTexture)
		{
			component.targetTexture = CreateTextureFor(cam);
		}
		return component;
	}

	private void SetStandardCameraParameter(Camera cam, LayerMask mask)
	{
		cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
		cam.backgroundColor = Color.black;
		cam.enabled = false;
	}

	private RenderTexture CreateTextureFor(Camera cam)
	{
		RenderTexture renderTexture = new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24);
		renderTexture.hideFlags = HideFlags.DontSave;
		return renderTexture;
	}

	public void RenderHelpCameras(Camera currentCam)
	{
		if (helperCameras == null)
		{
			helperCameras = new Dictionary<Camera, bool>();
		}
		if (!helperCameras.ContainsKey(currentCam))
		{
			helperCameras.Add(currentCam, value: false);
		}
		if (!helperCameras[currentCam])
		{
			if (!reflectionCamera)
			{
				reflectionCamera = CreateReflectionCameraFor(currentCam);
			}
			RenderReflectionFor(currentCam, reflectionCamera);
			helperCameras[currentCam] = true;
		}
	}

	public void LateUpdate()
	{
		if (helperCameras != null)
		{
			helperCameras.Clear();
		}
	}

	public void WaterTileBeingRendered(Transform tr, Camera currentCam)
	{
		RenderHelpCameras(currentCam);
		if ((bool)reflectionCamera && (bool)sharedMaterial)
		{
			sharedMaterial.SetTexture(reflectionSampler, reflectionCamera.targetTexture);
		}
	}

	public void OnEnable()
	{
		Shader.EnableKeyword("WATER_REFLECTIVE");
		Shader.DisableKeyword("WATER_SIMPLE");
	}

	public void OnDisable()
	{
		Shader.EnableKeyword("WATER_SIMPLE");
		Shader.DisableKeyword("WATER_REFLECTIVE");
	}

	private void RenderReflectionFor(Camera cam, Camera reflectCamera)
	{
		if (!reflectCamera || ((bool)sharedMaterial && !sharedMaterial.HasProperty(reflectionSampler)))
		{
			return;
		}
		reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
		SaneCameraSettings(reflectCamera);
		reflectCamera.backgroundColor = clearColor;
		reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
		if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
		{
			Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
			if (!skybox)
			{
				skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
			}
			skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
		}
		GL.SetRevertBackfacing(revertBackFaces: true);
		Transform transform = base.transform;
		Vector3 eulerAngles = cam.transform.eulerAngles;
		reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
		reflectCamera.transform.position = cam.transform.position;
		Vector3 position = transform.transform.position;
		position.y = transform.position.y;
		Vector3 up = transform.transform.up;
		float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
		Vector4 plane = new Vector4(up.x, up.y, up.z, w);
		Matrix4x4 zero = Matrix4x4.zero;
		zero = CalculateReflectionMatrix(zero, plane);
		oldpos = cam.transform.position;
		Vector3 position2 = zero.MultiplyPoint(oldpos);
		reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
		Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
		Matrix4x4 projectionMatrix = cam.projectionMatrix;
		projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
		reflectCamera.projectionMatrix = projectionMatrix;
		reflectCamera.transform.position = position2;
		Vector3 eulerAngles2 = cam.transform.eulerAngles;
		reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
		reflectCamera.Render();
		GL.SetRevertBackfacing(revertBackFaces: false);
	}

	private void SaneCameraSettings(Camera helperCam)
	{
		helperCam.depthTextureMode = DepthTextureMode.None;
		helperCam.backgroundColor = Color.black;
		helperCam.clearFlags = CameraClearFlags.Color;
		helperCam.renderingPath = RenderingPath.Forward;
	}

	private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
		return projection;
	}

	private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
		return reflectionMat;
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * clipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}
}
[RequireComponent(typeof(WaterBase))]
[ExecuteInEditMode]
public class SpecularLighting : MonoBehaviour
{
	public Transform specularLight;

	private WaterBase waterBase;

	public void Start()
	{
		waterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
	}

	public void Update()
	{
		if (!waterBase)
		{
			waterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
		}
		if ((bool)specularLight && (bool)waterBase.sharedMaterial)
		{
			waterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
		}
	}
}
public enum WaterQuality
{
	High = 2,
	Medium = 1,
	Low = 0
}
[ExecuteInEditMode]
public class WaterBase : MonoBehaviour
{
	public Material sharedMaterial;

	public WaterQuality waterQuality = WaterQuality.High;

	public bool edgeBlend = true;

	public void UpdateShader()
	{
		if (waterQuality > WaterQuality.Medium)
		{
			sharedMaterial.shader.maximumLOD = 501;
		}
		else if (waterQuality > WaterQuality.Low)
		{
			sharedMaterial.shader.maximumLOD = 301;
		}
		else
		{
			sharedMaterial.shader.maximumLOD = 201;
		}
		if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			edgeBlend = false;
		}
		if (edgeBlend)
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_ON");
			Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
			if ((bool)Camera.main)
			{
				Camera.main.depthTextureMode |= DepthTextureMode.Depth;
			}
		}
		else
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
			Shader.DisableKeyword("WATER_EDGEBLEND_ON");
		}
	}

	public void WaterTileBeingRendered(Transform tr, Camera currentCam)
	{
		if ((bool)currentCam && edgeBlend)
		{
			currentCam.depthTextureMode |= DepthTextureMode.Depth;
		}
	}

	public void Update()
	{
		if ((bool)sharedMaterial)
		{
			UpdateShader();
		}
	}
}
[ExecuteInEditMode]
public class WaterTile : MonoBehaviour
{
	public PlanarReflection reflection;

	public WaterBase waterBase;

	public void Start()
	{
		AcquireComponents();
	}

	private void AcquireComponents()
	{
		if (!reflection)
		{
			if ((bool)base.transform.parent)
			{
				reflection = base.transform.parent.GetComponent<PlanarReflection>();
			}
			else
			{
				reflection = base.transform.GetComponent<PlanarReflection>();
			}
		}
		if (!waterBase)
		{
			if ((bool)base.transform.parent)
			{
				waterBase = base.transform.parent.GetComponent<WaterBase>();
			}
			else
			{
				waterBase = base.transform.GetComponent<WaterBase>();
			}
		}
	}

	public void OnWillRenderObject()
	{
		if ((bool)reflection)
		{
			reflection.WaterTileBeingRendered(base.transform, Camera.current);
		}
		if ((bool)waterBase)
		{
			waterBase.WaterTileBeingRendered(base.transform, Camera.current);
		}
	}
}
